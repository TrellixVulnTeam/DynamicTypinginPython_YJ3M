commit 17d0866155e7300f21daf1a8fa2781cb8deeff83
Author: Lyn Nagara <lyn.nagara@gmail.com>
Date:   Wed Aug 14 10:26:52 2019 -0700

    feat(eventstore): Implement functions to get next/prev event ID (#14265)

diff --git a/src/sentry/api/bases/organization_events.py b/src/sentry/api/bases/organization_events.py
index 1b078de2c3..cf485b6d87 100644
--- a/src/sentry/api/bases/organization_events.py
+++ b/src/sentry/api/bases/organization_events.py
@@ -1,10 +1,8 @@
 from __future__ import absolute_import
 
-import six
 from rest_framework.exceptions import PermissionDenied
-from enum import Enum
 
-from sentry import features
+from sentry import eventstore, features
 from sentry.api.bases import OrganizationEndpoint, OrganizationEventsError
 from sentry.api.event_search import (
     get_snuba_query_args,
@@ -12,12 +10,6 @@ from sentry.api.event_search import (
     InvalidSearchQuery
 )
 from sentry.models.project import Project
-from sentry.utils import snuba
-
-
-class Direction(Enum):
-    NEXT = 0
-    PREV = 1
 
 
 class OrganizationEventsEndpointBase(OrganizationEndpoint):
@@ -121,54 +113,30 @@ class OrganizationEventsEndpointBase(OrganizationEndpoint):
                 'Boolean search operator OR and AND not allowed in this search.')
         return snuba_args
 
-    def next_event_id(self, *args):
+    def next_event_id(self, request, organization, snuba_args, event):
         """
         Returns the next event ID if there is a subsequent event matching the
-        conditions provided
+        conditions provided. Ignores the project_id.
         """
-        return self._get_next_or_prev_id(Direction.NEXT, *args)
+        next_event = eventstore.get_next_event_id(
+            event,
+            conditions=snuba_args['conditions'],
+            filter_keys=snuba_args['filter_keys']
+        )
 
-    def prev_event_id(self, *args):
+        if next_event:
+            return next_event[1]
+
+    def prev_event_id(self, request, organization, snuba_args, event):
         """
         Returns the previous event ID if there is a previous event matching the
-        conditions provided
+        conditions provided. Ignores the project_id.
         """
-        return self._get_next_or_prev_id(Direction.PREV, *args)
-
-    def _get_next_or_prev_id(self, direction, request, organization, snuba_args, event):
-        if (direction == Direction.NEXT):
-            time_condition = [
-                ['timestamp', '>=', event.timestamp],
-                [['timestamp', '>', event.timestamp], ['event_id', '>', event.event_id]]
-            ]
-            orderby = ['timestamp', 'event_id']
-            start = max(event.datetime, snuba_args['start'])
-            end = snuba_args['end']
-
-        else:
-            time_condition = [
-                ['timestamp', '<=', event.timestamp],
-                [['timestamp', '<', event.timestamp], ['event_id', '<', event.event_id]]
-            ]
-            orderby = ['-timestamp', '-event_id']
-            start = snuba_args['start']
-            end = min(event.datetime, snuba_args['end'])
-
-        conditions = snuba_args['conditions'][:]
-        conditions.extend(time_condition)
-
-        result = snuba.raw_query(
-            start=start,
-            end=end,
-            selected_columns=['event_id'],
-            conditions=conditions,
-            filter_keys=snuba_args['filter_keys'],
-            orderby=orderby,
-            limit=1,
-            referrer='api.organization-events.next-or-prev-id',
+        prev_event = eventstore.get_prev_event_id(
+            event,
+            conditions=snuba_args['conditions'],
+            filter_keys=snuba_args['filter_keys']
         )
 
-        if 'error' in result or len(result['data']) == 0:
-            return None
-
-        return six.text_type(result['data'][0]['event_id'])
+        if prev_event:
+            return prev_event[1]
diff --git a/src/sentry/api/endpoints/organization_event_details.py b/src/sentry/api/endpoints/organization_event_details.py
index 7988c2a32e..09254c4927 100644
--- a/src/sentry/api/endpoints/organization_event_details.py
+++ b/src/sentry/api/endpoints/organization_event_details.py
@@ -45,10 +45,21 @@ class OrganizationEventDetailsEndpoint(OrganizationEventsEndpointBase):
         if event is None:
             return Response({'detail': 'Event not found'}, status=404)
 
+        next_event = eventstore.get_next_event_id(
+            event,
+            conditions=snuba_args['conditions'],
+            filter_keys=snuba_args['filter_keys']
+        )
+        prev_event = eventstore.get_prev_event_id(
+            event,
+            conditions=snuba_args['conditions'],
+            filter_keys=snuba_args['filter_keys']
+        )
+
         data = serialize(event)
+        data['nextEventID'] = next_event[1] if next_event else None
+        data['previousEventID'] = prev_event[1] if prev_event else None
 
-        data['nextEventID'] = self.next_event_id(request, organization, snuba_args, event)
-        data['previousEventID'] = self.prev_event_id(request, organization, snuba_args, event)
         data['projectSlug'] = project_slug
 
         return Response(data)
diff --git a/src/sentry/api/endpoints/project_event_details.py b/src/sentry/api/endpoints/project_event_details.py
index 50f03217ee..cd5e5fe62d 100644
--- a/src/sentry/api/endpoints/project_event_details.py
+++ b/src/sentry/api/endpoints/project_event_details.py
@@ -3,6 +3,7 @@ from __future__ import absolute_import
 from datetime import datetime
 from rest_framework.response import Response
 
+from sentry import eventstore
 from sentry.api.base import DocSection
 from sentry.api.bases.project import ProjectEndpoint
 from sentry.api.serializers import DetailedEventSerializer, serialize
@@ -41,16 +42,38 @@ class ProjectEventDetailsEndpoint(ProjectEndpoint):
         :auth: required
         """
 
-        snuba_event = SnubaEvent.objects.from_event_id(event_id, project.id)
+        event = eventstore.get_event_by_id(project.id, event_id)
 
-        if snuba_event is None:
+        if event is None:
             return Response({'detail': 'Event not found'}, status=404)
 
-        data = serialize(snuba_event, request.user, DetailedEventSerializer())
-        requested_environments = set(request.GET.getlist('environment'))
+        data = serialize(event, request.user, DetailedEventSerializer())
 
-        next_event_id = snuba_event.next_event_id(environments=requested_environments)
-        prev_event_id = snuba_event.prev_event_id(environments=requested_environments)
+        # Used for paginating through events of a single issue in group details
+        # Skip next/prev for issueless events
+        next_event_id = None
+        prev_event_id = None
+
+        if event.group_id:
+            requested_environments = set(request.GET.getlist('environment'))
+            conditions = []
+
+            if requested_environments:
+                conditions.append(['environment', 'IN', requested_environments])
+
+            filter_keys = {
+                'project_id': [event.project_id],
+                'issue': [event.group_id],
+            }
+
+            next_event = eventstore.get_next_event_id(
+                event, conditions=conditions, filter_keys=filter_keys)
+
+            prev_event = eventstore.get_prev_event_id(
+                event, conditions=conditions, filter_keys=filter_keys)
+
+            next_event_id = next_event[1] if next_event else None
+            prev_event_id = prev_event[1] if prev_event else None
 
         data['nextEventID'] = next_event_id
         data['previousEventID'] = prev_event_id
diff --git a/src/sentry/constants.py b/src/sentry/constants.py
index 2eef8f19e8..0fcd5ec1db 100644
--- a/src/sentry/constants.py
+++ b/src/sentry/constants.py
@@ -12,7 +12,6 @@ from datetime import timedelta
 from collections import OrderedDict, namedtuple
 from django.conf import settings
 from django.utils.translation import ugettext_lazy as _
-from operator import attrgetter
 
 from sentry.utils.integrationdocs import load_doc
 from sentry.utils.geo import rust_geoip
@@ -210,9 +209,6 @@ OK_PLUGIN_SAVED = _('Configuration for the {name} integration has been saved.')
 
 WARN_SESSION_EXPIRED = 'Your session has expired.'  # TODO: translate this
 
-# Key to use when ordering a list of events manually
-EVENT_ORDERING_KEY = attrgetter('datetime', 'id')
-
 FILTER_MASK = '[Filtered]'
 
 # Maximum length of a symbol
diff --git a/src/sentry/eventstore/snuba/backend.py b/src/sentry/eventstore/snuba/backend.py
index 5fb8b79f6c..7175788d76 100644
--- a/src/sentry/eventstore/snuba/backend.py
+++ b/src/sentry/eventstore/snuba/backend.py
@@ -1,7 +1,11 @@
 from __future__ import absolute_import
 
-from sentry.utils import snuba
+from datetime import datetime
+import six
+from copy import copy
+
 from sentry.models import SnubaEvent
+from sentry.utils import snuba
 from sentry.eventstore.base import EventStorage
 from sentry.utils.validators import normalize_event_id
 
@@ -62,6 +66,58 @@ class SnubaEventStorage(EventStorage):
 
         return SnubaEvent.get_event(project_id, event_id, snuba_cols=cols)
 
+    def get_next_event_id(self, event, conditions=None, filter_keys=None):
+        """
+        Returns (project_id, event_id) of a next event given a current event
+        and any filters/conditions. Returns None if no next event is found.
+        """
+
+        if not event:
+            return None
+
+        conditions = copy(conditions)
+
+        time_condition = [
+            ['timestamp', '>=', event.timestamp],
+            [['timestamp', '>', event.timestamp], ['event_id', '>', event.event_id]]
+        ]
+
+        conditions = conditions or []
+        conditions.extend(time_condition)
+
+        return self.__get_next_or_prev_event_id(
+            start=event.datetime,
+            end=datetime.utcnow(),
+            conditions=conditions,
+            filter_keys=filter_keys,
+            orderby=['timestamp', 'event_id']
+        )
+
+    def get_prev_event_id(self, event, conditions=None, filter_keys=None):
+        """
+        Returns (project_id, event_id) of a previous event given a current event
+        and any filters/conditions. Returns None if no previous event is found.
+        """
+        if not event:
+            return None
+
+        conditions = copy(conditions)
+
+        time_condition = [
+            ['timestamp', '<=', event.timestamp],
+            [['timestamp', '<', event.timestamp], ['event_id', '<', event.event_id]]
+        ]
+        conditions = conditions or []
+        conditions.extend(time_condition)
+
+        return self.__get_next_or_prev_event_id(
+            end=event.datetime,
+            start=datetime.utcfromtimestamp(0),
+            conditions=conditions,
+            filter_keys=filter_keys,
+            orderby=['-timestamp', '-event_id']
+        )
+
     def __get_columns(self, additional_columns):
         columns = EventStorage.minimal_columns
 
@@ -69,3 +125,19 @@ class SnubaEventStorage(EventStorage):
             columns = set(columns + additional_columns)
 
         return [col.value for col in columns]
+
+    def __get_next_or_prev_event_id(self, **kwargs):
+
+        result = snuba.raw_query(
+            selected_columns=['event_id', 'project_id'],
+            limit=1,
+            referrer='eventstore.get_next_or_prev_event_id',
+            **kwargs
+        )
+
+        if 'error' in result or len(result['data']) == 0:
+            return None
+
+        row = result['data'][0]
+
+        return (six.text_type(row['project_id']), six.text_type(row['event_id']))
diff --git a/src/sentry/models/event.py b/src/sentry/models/event.py
index 2d51b3aabc..722260651d 100644
--- a/src/sentry/models/event.py
+++ b/src/sentry/models/event.py
@@ -5,7 +5,6 @@ import string
 import warnings
 import pytz
 
-from datetime import datetime
 from collections import OrderedDict
 from dateutil.parser import parse as parse_date
 from django.db import models
@@ -16,7 +15,6 @@ from hashlib import md5
 from semaphore.processing import StoreNormalizer
 
 from sentry import eventtypes
-from sentry.constants import EVENT_ORDERING_KEY
 from sentry.db.models import (
     BoundedBigIntegerField,
     BoundedIntegerField,
@@ -27,7 +25,7 @@ from sentry.db.models import (
 )
 from sentry.db.models.manager import EventManager, SnubaEventManager
 from sentry.interfaces.base import get_interfaces
-from sentry.utils import json, metrics
+from sentry.utils import json
 from sentry.utils.cache import memoize
 from sentry.utils.canonical import CanonicalKeyDict, CanonicalKeyView
 from sentry.utils.safe import get_path
@@ -612,70 +610,6 @@ class SnubaEvent(EventCommon):
         # have to reference the row id anyway.
         return self.event_id
 
-    def next_event_id(self, environments=None):
-        from sentry.utils import snuba
-
-        conditions = [
-            ['timestamp', '>=', self.timestamp],
-            [['timestamp', '>', self.timestamp], ['event_id', '>', self.event_id]]
-        ]
-
-        if environments:
-            conditions.append(['environment', 'IN', environments])
-
-        result = snuba.raw_query(
-            start=self.datetime,  # gte current event
-            selected_columns=['event_id', 'timestamp'],
-            conditions=conditions,
-            filter_keys={
-                'project_id': [self.project_id],
-                'issue': [self.group_id] if self.group_id else [],
-            },
-            orderby=['timestamp', 'event_id'],
-            limit=1,
-            referrer='SnubaEvent.next_event_id',
-        )
-
-        if 'error' in result or len(result['data']) == 0:
-            return None
-
-        # Increment count if the next event ID is after utcnow
-        event_time = parse_date(result['data'][0]['timestamp']).replace(tzinfo=pytz.utc)
-
-        if event_time > datetime.utcnow().replace(tzinfo=pytz.utc):
-            metrics.incr('events.future_next_event_id', skip_internal=False)
-
-        return six.text_type(result['data'][0]['event_id'])
-
-    def prev_event_id(self, environments=None):
-        from sentry.utils import snuba
-
-        conditions = [
-            ['timestamp', '<=', self.timestamp],
-            [['timestamp', '<', self.timestamp], ['event_id', '<', self.event_id]]
-        ]
-
-        if environments:
-            conditions.append(['environment', 'IN', environments])
-
-        result = snuba.raw_query(
-            end=self.datetime,  # lte current event
-            selected_columns=['event_id'],
-            conditions=conditions,
-            filter_keys={
-                'project_id': [self.project_id],
-                'issue': [self.group_id] if self.group_id else [],
-            },
-            orderby=['-timestamp', '-event_id'],
-            limit=1,
-            referrer='SnubaEvent.prev_event_id',
-        )
-
-        if 'error' in result or len(result['data']) == 0:
-            return None
-
-        return six.text_type(result['data'][0]['event_id'])
-
     def save(self):
         raise NotImplementedError
 
@@ -728,34 +662,6 @@ class Event(EventCommon, Model):
 
         return state
 
-    # Find next and previous events based on datetime and id. We cannot
-    # simply `ORDER BY (datetime, id)` as this is too slow (no index), so
-    # we grab the next 5 / prev 5 events by datetime, and sort locally to
-    # get the next/prev events. Given that timestamps only have 1-second
-    # granularity, this will be inaccurate if there are more than 5 events
-    # in a given second.
-    def next_event_id(self, environments=None):
-        events = self.__class__.objects.filter(
-            datetime__gte=self.datetime,
-            group_id=self.group_id,
-        ).exclude(id=self.id).order_by('datetime')[0:5]
-
-        events = [e for e in events if e.datetime == self.datetime and e.id > self.id or
-                  e.datetime > self.datetime]
-        events.sort(key=EVENT_ORDERING_KEY)
-        return six.text_type(events[0].event_id) if events else None
-
-    def prev_event_id(self, environments=None):
-        events = self.__class__.objects.filter(
-            datetime__lte=self.datetime,
-            group_id=self.group_id,
-        ).exclude(id=self.id).order_by('-datetime')[0:5]
-
-        events = [e for e in events if e.datetime == self.datetime and e.id < self.id or
-                  e.datetime < self.datetime]
-        events.sort(key=EVENT_ORDERING_KEY, reverse=True)
-        return six.text_type(events[0].event_id) if events else None
-
 
 class EventSubjectTemplate(string.Template):
     idpattern = r'(tag:)?[_a-z][_a-z0-9]*'
diff --git a/tests/sentry/eventstore/snuba/test_backend.py b/tests/sentry/eventstore/snuba/test_backend.py
index 8ea97e4017..7304864465 100644
--- a/tests/sentry/eventstore/snuba/test_backend.py
+++ b/tests/sentry/eventstore/snuba/test_backend.py
@@ -1,5 +1,6 @@
 from __future__ import absolute_import
 
+import six
 from datetime import timedelta
 from django.utils import timezone
 
@@ -12,6 +13,9 @@ class SnubaEventStorageTest(TestCase, SnubaTestCase):
         super(SnubaEventStorageTest, self).setUp()
         self.min_ago = (timezone.now() - timedelta(minutes=1)).isoformat()[:19]
         self.two_min_ago = (timezone.now() - timedelta(minutes=2)).isoformat()[:19]
+        self.project1 = self.create_project()
+        self.project2 = self.create_project()
+
         self.event1 = self.store_event(
             data={
                 'event_id': 'a' * 32,
@@ -21,9 +25,9 @@ class SnubaEventStorageTest(TestCase, SnubaTestCase):
                 'timestamp': self.two_min_ago,
                 'tags': {'foo': '1'},
             },
-            project_id=self.project.id,
+            project_id=self.project1.id,
         )
-        self.store_event(
+        self.event2 = self.store_event(
             data={
                 'event_id': 'b' * 32,
                 'type': 'default',
@@ -32,9 +36,9 @@ class SnubaEventStorageTest(TestCase, SnubaTestCase):
                 'timestamp': self.min_ago,
                 'tags': {'foo': '1'},
             },
-            project_id=self.project.id,
+            project_id=self.project2.id,
         )
-        self.store_event(
+        self.event3 = self.store_event(
             data={
                 'event_id': 'c' * 32,
                 'type': 'default',
@@ -43,13 +47,14 @@ class SnubaEventStorageTest(TestCase, SnubaTestCase):
                 'timestamp': self.min_ago,
                 'tags': {'foo': '1'},
             },
-            project_id=self.project.id,
+            project_id=self.project2.id,
         )
 
         self.eventstore = SnubaEventStorage()
 
     def test_get_events(self):
-        events = self.eventstore.get_events(filter_keys={'project_id': [self.project.id]})
+        events = self.eventstore.get_events(
+            filter_keys={'project_id': [self.project1.id, self.project2.id]})
         assert len(events) == 3
         # Default sort is timestamp desc, event_id desc
         assert events[0].id == 'c' * 32
@@ -63,21 +68,39 @@ class SnubaEventStorageTest(TestCase, SnubaTestCase):
 
     def test_get_event_by_id(self):
         # Get event with default columns
-        event = self.eventstore.get_event_by_id(self.project.id, 'a' * 32)
+        event = self.eventstore.get_event_by_id(self.project1.id, 'a' * 32)
 
         assert event.id == 'a' * 32
         assert event.event_id == 'a' * 32
-        assert event.project_id == self.project.id
+        assert event.project_id == self.project1.id
         assert len(event.snuba_data.keys()) == 4
 
         # Get all columns
         event = self.eventstore.get_event_by_id(
-            self.project.id, 'b' * 32, self.eventstore.full_columns)
+            self.project2.id, 'b' * 32, self.eventstore.full_columns)
         assert event.id == 'b' * 32
         assert event.event_id == 'b' * 32
-        assert event.project_id == self.project.id
+        assert event.project_id == self.project2.id
         assert len(event.snuba_data.keys()) == 16
 
         # Get non existent event
-        event = self.eventstore.get_event_by_id(self.project.id, 'd' * 32)
+        event = self.eventstore.get_event_by_id(self.project2.id, 'd' * 32)
         assert event is None
+
+    def test_get_next_prev_event_id(self):
+        event = self.eventstore.get_event_by_id(self.project2.id, 'b' * 32)
+
+        filter_keys = {'project_id': [self.project1.id, self.project2.id]}
+
+        prev_event = self.eventstore.get_prev_event_id(event, filter_keys=filter_keys)
+
+        next_event = self.eventstore.get_next_event_id(event, filter_keys=filter_keys)
+
+        assert prev_event == (six.text_type(self.project1.id), 'a' * 32)
+
+        # Events with the same timestamp are sorted by event_id
+        assert next_event == (six.text_type(self.project2.id), 'c' * 32)
+
+        # Returns None if no event
+        assert self.eventstore.get_prev_event_id(None, filter_keys=filter_keys) is None
+        assert self.eventstore.get_next_event_id(None, filter_keys=filter_keys) is None
diff --git a/tests/snuba/api/endpoints/test_project_event_details.py b/tests/snuba/api/endpoints/test_project_event_details.py
index 3e8bd104ef..e432888019 100644
--- a/tests/snuba/api/endpoints/test_project_event_details.py
+++ b/tests/snuba/api/endpoints/test_project_event_details.py
@@ -17,11 +17,12 @@ class ProjectEventDetailsTest(APITestCase, SnubaTestCase):
         one_min_ago = (timezone.now() - timedelta(minutes=1)).isoformat()[:19]
         two_min_ago = (timezone.now() - timedelta(minutes=2)).isoformat()[:19]
         three_min_ago = (timezone.now() - timedelta(minutes=3)).isoformat()[:19]
+        four_min_ago = (timezone.now() - timedelta(minutes=4)).isoformat()[:19]
 
         self.prev_event = self.store_event(
             data={
                 'event_id': 'a' * 32,
-                'timestamp': three_min_ago,
+                'timestamp': four_min_ago,
                 'fingerprint': ['group-1']
             },
             project_id=project.id
@@ -29,7 +30,7 @@ class ProjectEventDetailsTest(APITestCase, SnubaTestCase):
         self.cur_event = self.store_event(
             data={
                 'event_id': 'b' * 32,
-                'timestamp': two_min_ago,
+                'timestamp': three_min_ago,
                 'fingerprint': ['group-1']
             },
             project_id=project.id
@@ -37,7 +38,7 @@ class ProjectEventDetailsTest(APITestCase, SnubaTestCase):
         self.next_event = self.store_event(
             data={
                 'event_id': 'c' * 32,
-                'timestamp': one_min_ago,
+                'timestamp': two_min_ago,
                 'fingerprint': ['group-1'],
                 'environment': 'production',
                 'tags': {'environment': 'production'}
@@ -45,28 +46,23 @@ class ProjectEventDetailsTest(APITestCase, SnubaTestCase):
             project_id=project.id
         )
 
-    def test_snuba(self):
-        url = reverse(
-            'sentry-api-0-project-event-details',
-            kwargs={
-                'event_id': self.cur_event.event_id,
-                'project_slug': self.cur_event.project.slug,
-                'organization_slug': self.cur_event.project.organization.slug,
-            }
+        # Event in different group
+        self.store_event(
+            data={
+                'event_id': 'd' * 32,
+                'timestamp': one_min_ago,
+                'fingerprint': ['group-2'],
+                'environment': 'production',
+                'tags': {'environment': 'production'}
+            },
+            project_id=project.id
         )
-        response = self.client.get(url, format='json')
 
-        assert response.status_code == 200, response.content
-        assert response.data['id'] == six.text_type(self.cur_event.event_id)
-        assert response.data['nextEventID'] == six.text_type(self.next_event.event_id)
-        assert response.data['previousEventID'] == six.text_type(self.prev_event.event_id)
-        assert response.data['groupID'] == six.text_type(self.cur_event.group.id)
-
-        # Same event can be looked up by primary key
+    def test_snuba(self):
         url = reverse(
             'sentry-api-0-project-event-details',
             kwargs={
-                'event_id': self.cur_event.id,
+                'event_id': self.cur_event.event_id,
                 'project_slug': self.cur_event.project.slug,
                 'organization_slug': self.cur_event.project.organization.slug,
             }
@@ -115,6 +111,21 @@ class ProjectEventDetailsTest(APITestCase, SnubaTestCase):
         assert response.data['nextEventID'] == self.next_event.event_id
         assert response.data['groupID'] == six.text_type(self.prev_event.group.id)
 
+    def test_ignores_different_group(self):
+        url = reverse(
+            'sentry-api-0-project-event-details',
+            kwargs={
+                'event_id': self.next_event.event_id,
+                'project_slug': self.next_event.project.slug,
+                'organization_slug': self.next_event.project.organization.slug,
+            }
+        )
+        response = self.client.get(url, format='json')
+
+        assert response.status_code == 200, response.content
+        assert response.data['id'] == six.text_type(self.next_event.event_id)
+        assert response.data['nextEventID'] is None
+
 
 class ProjectEventJsonEndpointTest(APITestCase, SnubaTestCase):
     def setUp(self):

commit 5e93e718d638c638de95be3cc10bc786c31f393e
Author: Stephen Cefali <scefali@sentry.io>
Date:   Tue Jan 14 10:33:21 2020 -0800

    feat(ui): adds callback for AsyncComponent when all endpoints are loaded (#16427)

diff --git a/src/sentry/static/sentry/app/components/asyncComponent.tsx b/src/sentry/static/sentry/app/components/asyncComponent.tsx
index 66bf71c789..123e9cd0bf 100644
--- a/src/sentry/static/sentry/app/components/asyncComponent.tsx
+++ b/src/sentry/static/sentry/app/components/asyncComponent.tsx
@@ -292,23 +292,35 @@ export default class AsyncComponent<
     // Allow children to implement this
   }
 
-  handleRequestSuccess({stateKey, data, jqXHR}, initialRequest?: boolean) {
-    this.setState(prevState => {
-      const state = {
-        [stateKey]: data,
-        // TODO(billy): This currently fails if this request is retried by SudoModal
-        [`${stateKey}PageLinks`]: jqXHR && jqXHR.getResponseHeader('Link'),
-      };
+  onLoadAllEndpointsSuccess() {
+    // Allow children to implement this
+  }
 
-      if (initialRequest) {
-        state.remainingRequests = prevState.remainingRequests! - 1;
-        state.loading = prevState.remainingRequests! > 1;
-        state.reloading = prevState.reloading && state.loading;
-        this.markShouldMeasure({remainingRequests: state.remainingRequests});
+  handleRequestSuccess({stateKey, data, jqXHR}, initialRequest?: boolean) {
+    this.setState(
+      prevState => {
+        const state = {
+          [stateKey]: data,
+          // TODO(billy): This currently fails if this request is retried by SudoModal
+          [`${stateKey}PageLinks`]: jqXHR && jqXHR.getResponseHeader('Link'),
+        };
+
+        if (initialRequest) {
+          state.remainingRequests = prevState.remainingRequests! - 1;
+          state.loading = prevState.remainingRequests! > 1;
+          state.reloading = prevState.reloading && state.loading;
+          this.markShouldMeasure({remainingRequests: state.remainingRequests});
+        }
+
+        return state;
+      },
+      () => {
+        //if everything is loaded and we don't have an error, call the callback
+        if (this.state.remainingRequests === 0 && !this.state.error) {
+          this.onLoadAllEndpointsSuccess();
+        }
       }
-
-      return state;
-    });
+    );
     this.onRequestSuccess({stateKey, data, jqXHR});
   }
 
diff --git a/tests/js/spec/components/asyncComponent.spec.jsx b/tests/js/spec/components/asyncComponent.spec.jsx
index a8324b594e..91c83dbf47 100644
--- a/tests/js/spec/components/asyncComponent.spec.jsx
+++ b/tests/js/spec/components/asyncComponent.spec.jsx
@@ -55,4 +55,51 @@ describe('AsyncComponent', function() {
         .text()
     ).toEqual('oops there was a problem');
   });
+
+  describe('multi-route component', () => {
+    class MultiRouteComponent extends TestAsyncComponent {
+      getEndpoints() {
+        return [['data', '/some/path/to/something/'], ['project', '/another/path/here']];
+      }
+    }
+
+    it('calls onLoadAllEndpointsSuccess when all endpoints have been loaded', () => {
+      jest.useFakeTimers();
+      jest.spyOn(Client.prototype, 'request').mockImplementation((url, options) => {
+        const timeout = url.includes('something') ? 100 : 50;
+        setTimeout(
+          () =>
+            options.success({
+              message: 'good',
+            }),
+          timeout
+        );
+      });
+      const mockOnAllEndpointsSuccess = jest.spyOn(
+        MultiRouteComponent.prototype,
+        'onLoadAllEndpointsSuccess'
+      );
+
+      const wrapper = shallow(<MultiRouteComponent />);
+
+      expect(wrapper.state('loading')).toEqual(true);
+      expect(wrapper.state('remainingRequests')).toEqual(2);
+
+      jest.advanceTimersByTime(40);
+      expect(wrapper.state('loading')).toEqual(true);
+      expect(wrapper.state('remainingRequests')).toEqual(2);
+
+      jest.advanceTimersByTime(40);
+      expect(wrapper.state('loading')).toEqual(true);
+      expect(wrapper.state('remainingRequests')).toEqual(1);
+      expect(mockOnAllEndpointsSuccess).not.toHaveBeenCalled();
+
+      jest.advanceTimersByTime(40);
+      expect(wrapper.state('loading')).toEqual(false);
+      expect(wrapper.state('remainingRequests')).toEqual(0);
+      expect(mockOnAllEndpointsSuccess).toHaveBeenCalled();
+
+      jest.restoreAllMocks();
+    });
+  });
 });

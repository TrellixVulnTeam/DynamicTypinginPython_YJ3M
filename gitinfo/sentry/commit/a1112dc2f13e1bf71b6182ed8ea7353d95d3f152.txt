commit a1112dc2f13e1bf71b6182ed8ea7353d95d3f152
Author: Alex Hofsteede <alex@hofsteede.com>
Date:   Tue Dec 5 11:00:42 2017 +1300

    Model most of input validation as a schema (#6625)
    
    * feat(schemas): Model most of input validation as schema (#6481)
    
    * feat(schemas): Model most of input validation as schema
    
    This takes most of the imperative validation code in validate_data
    and uses declarative JSON schema to validate it instead. There is an
    associated helper method that uses the schema validation errors to do
    the same things as the old code, namely deleting invalid keys, or
    defaulting them if there is an applicable default.
    
    There is a pre-validation casting step that forces some of the values to be
    certain types before we apply the schema validation. This is to avoid
    having to create a bunch of special cases in the schema for eg. values
    that are either integers OR numeric strings. In theory this casting code
    could be removed completely if all clients were well behaved and only
    sent data for a given key in a single correct format.
    
    There are also additional validators for the individual interfaces that
    are created. These are checked when the interface is created with
    to_python.
    
    I had to make minor changes to some tests as the choice to raise an
    APIError on some types of invalid keys (eg. non-string event_id value)
    but not on others (culprit too long, too short, etc) seemed kinda
    arbitrary anyway and it would have made for some messy special case code
    to fix.
    
    * fix: Small validation changes for schema.
    
    1. Don't try to add default properties unless the object being validated
    is a dict.
    2. Make sure that the User interface is validated as an object, as the
    interface to_python method assumes that it is.
    
    * Allow Frames to have anything
    
    * Consolidate validate_data and normalize
    
    Both for performance reasons (to avoid too many to_python/to_json
    cycles) and for the simplicity of having this all in one place.
    
    * Strip newlines along with regular whitespace in tags
    
    Newlines within the body of the tag are stll disallowed, but newlines
    at the end will be stripped off with all the other whitespace.
    
    * Don't attempt to get() from a nonn-dict
    
    * More changes for parity with master
    
    * Cache validators per interface and make interface checking cleaner
    
    * Review fixes

diff --git a/requirements-base.txt b/requirements-base.txt
index 4d8b4305be..61b0f6bfea 100644
--- a/requirements-base.txt
+++ b/requirements-base.txt
@@ -20,6 +20,7 @@ honcho>=0.7.0,<0.8.0
 kombu==3.0.35
 ipaddress>=1.0.16,<1.1.0
 loremipsum>=1.0.5,<1.1.0
+jsonschema==2.6.0
 lxml>=3.4.1
 mock>=0.8.0,<1.1
 mmh3>=2.3.1,<2.4
diff --git a/src/sentry/coreapi.py b/src/sentry/coreapi.py
index a10643ceef..a1adeb722f 100644
--- a/src/sentry/coreapi.py
+++ b/src/sentry/coreapi.py
@@ -13,31 +13,18 @@ from __future__ import absolute_import, print_function
 import base64
 import logging
 import six
-import uuid
 import zlib
 import re
 
 from collections import MutableMapping
-from datetime import datetime, timedelta
 from django.core.exceptions import SuspiciousOperation
 from django.utils.crypto import constant_time_compare
 from gzip import GzipFile
 from six import BytesIO
 from time import time
 
-from sentry import filters, tagstore
+from sentry import filters
 from sentry.cache import default_cache
-from sentry.constants import (
-    CLIENT_RESERVED_ATTRS,
-    DEFAULT_LOG_LEVEL,
-    LOG_LEVELS_MAP,
-    MAX_TAG_VALUE_LENGTH,
-    MAX_TAG_KEY_LENGTH,
-    VALID_PLATFORMS,
-    VERSION_LENGTH,
-)
-from sentry.db.models import BoundedIntegerField
-from sentry.interfaces.base import get_interface, InterfaceValidationError
 from sentry.interfaces.csp import Csp
 from sentry.event_manager import EventManager
 from sentry.models import EventError, ProjectKey, upload_minidump, merge_minidump_event
@@ -50,7 +37,6 @@ from sentry.utils.http import origin_from_request
 from sentry.utils.data_filters import is_valid_ip, \
     is_valid_release, is_valid_error_message, FilterStatKeys
 from sentry.utils.strings import decompress
-from sentry.utils.validators import is_float, is_event_id
 
 try:
     # Attempt to load ujson if it's installed.
@@ -98,14 +84,6 @@ class APIRateLimited(APIError):
         self.retry_after = retry_after
 
 
-class InvalidTimestamp(Exception):
-    pass
-
-
-class InvalidFingerprint(Exception):
-    pass
-
-
 class Auth(object):
     def __init__(self, auth_vars, is_public=False):
         self.client = auth_vars.get('sentry_client')
@@ -317,61 +295,6 @@ class ClientApiHelper(object):
                            (type(e).__name__, e))
         return obj
 
-    def _process_data_timestamp(self, data, current_datetime=None):
-        value = data['timestamp']
-        if not value:
-            del data['timestamp']
-            return data
-        elif is_float(value):
-            try:
-                value = datetime.fromtimestamp(float(value))
-            except Exception:
-                raise InvalidTimestamp(
-                    'Invalid value for timestamp: %r' % data['timestamp'])
-        elif not isinstance(value, datetime):
-            # all timestamps are in UTC, but the marker is optional
-            if value.endswith('Z'):
-                value = value[:-1]
-            if '.' in value:
-                # Python doesn't support long microsecond values
-                # https://github.com/getsentry/sentry/issues/1610
-                ts_bits = value.split('.', 1)
-                value = '%s.%s' % (ts_bits[0], ts_bits[1][:2])
-                fmt = '%Y-%m-%dT%H:%M:%S.%f'
-            else:
-                fmt = '%Y-%m-%dT%H:%M:%S'
-            try:
-                value = datetime.strptime(value, fmt)
-            except Exception:
-                raise InvalidTimestamp(
-                    'Invalid value for timestamp: %r' % data['timestamp'])
-
-        if current_datetime is None:
-            current_datetime = datetime.now()
-
-        if value > current_datetime + timedelta(minutes=1):
-            raise InvalidTimestamp(
-                'Invalid value for timestamp (in future): %r' % value)
-
-        if value < current_datetime - timedelta(days=30):
-            raise InvalidTimestamp(
-                'Invalid value for timestamp (too old): %r' % value)
-
-        data['timestamp'] = float(value.strftime('%s'))
-
-        return data
-
-    def _process_fingerprint(self, data):
-        if not isinstance(data['fingerprint'], (list, tuple)):
-            raise InvalidFingerprint
-
-        result = []
-        for bit in data['fingerprint']:
-            if not isinstance(bit, six.string_types + six.integer_types + (float, )):
-                raise InvalidFingerprint
-            result.append(six.text_type(bit))
-        return result
-
     def parse_client_as_sdk(self, value):
         if not value:
             return
@@ -415,398 +338,6 @@ class ClientApiHelper(object):
         return (False, None)
 
     def validate_data(self, data):
-        data['errors'] = []
-
-        if data.get('culprit'):
-            if not isinstance(data['culprit'], six.string_types):
-                raise APIForbidden('Invalid value for culprit')
-
-        if not data.get('event_id'):
-            data['event_id'] = uuid.uuid4().hex
-        elif not isinstance(data['event_id'], six.string_types):
-            raise APIForbidden('Invalid value for event_id')
-
-        if len(data['event_id']) > 32:
-            self.log.debug(
-                'Discarded value for event_id due to length (%d chars)', len(
-                    data['event_id'])
-            )
-            data['errors'].append(
-                {
-                    'type': EventError.VALUE_TOO_LONG,
-                    'name': 'event_id',
-                    'value': data['event_id'],
-                }
-            )
-            data['event_id'] = uuid.uuid4().hex
-        elif not is_event_id(data['event_id']):
-            self.log.debug(
-                'Discarded invalid value for event_id: %r', data['event_id'], exc_info=True
-            )
-            data['errors'].append(
-                {
-                    'type': EventError.INVALID_DATA,
-                    'name': 'event_id',
-                    'value': data['event_id'],
-                }
-            )
-            data['event_id'] = uuid.uuid4().hex
-
-        if 'timestamp' in data:
-            try:
-                self._process_data_timestamp(data)
-            except InvalidTimestamp as e:
-                self.log.debug(
-                    'Discarded invalid value for timestamp: %r', data['timestamp'], exc_info=True
-                )
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'timestamp',
-                        'value': data['timestamp'],
-                    }
-                )
-                del data['timestamp']
-
-        if 'fingerprint' in data:
-            try:
-                data['fingerprint'] = self._process_fingerprint(data)
-            except InvalidFingerprint as e:
-                self.log.debug(
-                    'Discarded invalid value for fingerprint: %r',
-                    data['fingerprint'],
-                    exc_info=True
-                )
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'fingerprint',
-                        'value': data['fingerprint'],
-                    }
-                )
-                del data['fingerprint']
-
-        if 'platform' not in data or data['platform'] not in VALID_PLATFORMS:
-            data['platform'] = 'other'
-
-        if data.get('modules') and type(data['modules']) != dict:
-            self.log.debug(
-                'Discarded invalid type for modules: %s', type(data['modules']))
-            data['errors'].append(
-                {
-                    'type': EventError.INVALID_DATA,
-                    'name': 'modules',
-                    'value': data['modules'],
-                }
-            )
-            del data['modules']
-
-        if data.get('extra') is not None and type(data['extra']) != dict:
-            self.log.debug('Discarded invalid type for extra: %s',
-                           type(data['extra']))
-            data['errors'].append(
-                {
-                    'type': EventError.INVALID_DATA,
-                    'name': 'extra',
-                    'value': data['extra'],
-                }
-            )
-            del data['extra']
-
-        if data.get('tags') is not None:
-            if type(data['tags']) == dict:
-                data['tags'] = list(data['tags'].items())
-            elif not isinstance(data['tags'], (list, tuple)):
-                self.log.debug(
-                    'Discarded invalid type for tags: %s', type(data['tags']))
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'tags',
-                        'value': data['tags'],
-                    }
-                )
-                del data['tags']
-
-        if data.get('tags'):
-            # remove any values which are over 32 characters
-            tags = []
-            for pair in data['tags']:
-                try:
-                    k, v = pair
-                except ValueError:
-                    self.log.debug('Discarded invalid tag value: %r', pair)
-                    data['errors'].append(
-                        {
-                            'type': EventError.INVALID_DATA,
-                            'name': 'tags',
-                            'value': pair,
-                        }
-                    )
-                    continue
-
-                if not isinstance(k, six.string_types):
-                    try:
-                        k = six.text_type(k)
-                    except Exception:
-                        self.log.debug(
-                            'Discarded invalid tag key: %r', type(k))
-                        data['errors'].append(
-                            {
-                                'type': EventError.INVALID_DATA,
-                                'name': 'tags',
-                                'value': pair,
-                            }
-                        )
-                        continue
-
-                if not isinstance(v, six.string_types):
-                    try:
-                        v = six.text_type(v)
-                    except Exception:
-                        self.log.debug(
-                            'Discarded invalid tag value: %s=%r', k, type(v))
-                        data['errors'].append(
-                            {
-                                'type': EventError.INVALID_DATA,
-                                'name': 'tags',
-                                'value': pair,
-                            }
-                        )
-                        continue
-
-                if len(k) > MAX_TAG_KEY_LENGTH or len(v) > MAX_TAG_VALUE_LENGTH:
-                    self.log.debug('Discarded invalid tag: %s=%s', k, v)
-                    data['errors'].append(
-                        {
-                            'type': EventError.INVALID_DATA,
-                            'name': 'tags',
-                            'value': pair,
-                        }
-                    )
-                    continue
-
-                # support tags with spaces by converting them
-                k = k.replace(' ', '-')
-
-                if tagstore.is_reserved_key(k):
-                    self.log.debug('Discarding reserved tag key: %s', k)
-                    data['errors'].append(
-                        {
-                            'type': EventError.INVALID_DATA,
-                            'name': 'tags',
-                            'value': pair,
-                        }
-                    )
-                    continue
-
-                if not tagstore.is_valid_key(k):
-                    self.log.debug('Discarded invalid tag key: %s', k)
-                    data['errors'].append(
-                        {
-                            'type': EventError.INVALID_DATA,
-                            'name': 'tags',
-                            'value': pair,
-                        }
-                    )
-                    continue
-
-                if not tagstore.is_valid_value(v):
-                    self.log.debug('Discard invalid tag value: %s', v)
-                    data['errors'].append(
-                        {
-                            'type': EventError.INVALID_DATA,
-                            'name': 'tags',
-                            'value': pair,
-                        }
-                    )
-                    continue
-
-                tags.append((k, v))
-            data['tags'] = tags
-
-        for k in list(iter(data)):
-            if k in CLIENT_RESERVED_ATTRS:
-                continue
-
-            value = data.pop(k)
-
-            if not value:
-                self.log.debug('Ignored empty interface value: %s', k)
-                continue
-
-            try:
-                interface = get_interface(k)
-            except ValueError:
-                self.log.debug('Ignored unknown attribute: %s', k)
-                data['errors'].append({
-                    'type': EventError.INVALID_ATTRIBUTE,
-                    'name': k,
-                })
-                continue
-
-            if type(value) != dict:
-                # HACK(dcramer): the exception/breadcrumbs interface supports a
-                # list as the value. We should change this in a new protocol
-                # version.
-                if type(value) in (list, tuple):
-                    value = {'values': value}
-                else:
-                    self.log.debug(
-                        'Invalid parameter for value: %s (%r)', k, type(value))
-                    data['errors'].append(
-                        {
-                            'type': EventError.INVALID_DATA,
-                            'name': k,
-                            'value': value,
-                        }
-                    )
-                    continue
-
-            try:
-                inst = interface.to_python(value)
-                data[inst.get_path()] = inst.to_json()
-            except Exception as e:
-                if isinstance(e, InterfaceValidationError):
-                    log = self.log.debug
-                else:
-                    log = self.log.error
-                log('Discarded invalid value for interface: %s (%r)',
-                    k, value, exc_info=True)
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': k,
-                        'value': value,
-                    }
-                )
-
-        # TODO(dcramer): ideally this logic would happen in normalize, but today
-        # we don't do "validation" there (create errors)
-
-        # message is coerced to an interface, as its used for pure
-        # index of searchable strings
-        # See GH-3248
-        message = data.pop('message', None)
-        if message:
-            if 'sentry.interfaces.Message' not in data:
-                value = {
-                    'message': message,
-                }
-            elif not data['sentry.interfaces.Message'].get('formatted'):
-                value = data['sentry.interfaces.Message']
-                value['formatted'] = message
-            else:
-                value = None
-
-            if value is not None:
-                k = 'sentry.interfaces.Message'
-                interface = get_interface(k)
-                try:
-                    inst = interface.to_python(value)
-                    data[inst.get_path()] = inst.to_json()
-                except Exception as e:
-                    if isinstance(e, InterfaceValidationError):
-                        log = self.log.debug
-                    else:
-                        log = self.log.error
-                    log('Discarded invalid value for interface: %s (%r)',
-                        k, value, exc_info=True)
-                    data['errors'].append(
-                        {
-                            'type': EventError.INVALID_DATA,
-                            'name': k,
-                            'value': value,
-                        }
-                    )
-
-        level = data.get('level') or DEFAULT_LOG_LEVEL
-        if isinstance(level, six.string_types) and not level.isdigit():
-            # assume it's something like 'warning'
-            try:
-                data['level'] = LOG_LEVELS_MAP[level]
-            except KeyError as e:
-                self.log.debug('Discarded invalid logger value: %s', level)
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'level',
-                        'value': level,
-                    }
-                )
-                data['level'] = LOG_LEVELS_MAP.get(
-                    DEFAULT_LOG_LEVEL, DEFAULT_LOG_LEVEL)
-
-        if data.get('release'):
-            data['release'] = six.text_type(data['release'])
-            if len(data['release']) > VERSION_LENGTH:
-                data['errors'].append(
-                    {
-                        'type': EventError.VALUE_TOO_LONG,
-                        'name': 'release',
-                        'value': data['release'],
-                    }
-                )
-                del data['release']
-
-        if data.get('dist'):
-            data['dist'] = six.text_type(data['dist']).strip()
-            if not data.get('release'):
-                data['dist'] = None
-            elif len(data['dist']) > 64:
-                data['errors'].append(
-                    {
-                        'type': EventError.VALUE_TOO_LONG,
-                        'name': 'dist',
-                        'value': data['dist'],
-                    }
-                )
-                del data['dist']
-            elif _dist_re.match(data['dist']) is None:
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'dist',
-                        'value': data['dist'],
-                    }
-                )
-                del data['dist']
-
-        if data.get('environment'):
-            data['environment'] = six.text_type(data['environment'])
-            if len(data['environment']) > 64:
-                data['errors'].append(
-                    {
-                        'type': EventError.VALUE_TOO_LONG,
-                        'name': 'environment',
-                        'value': data['environment'],
-                    }
-                )
-                del data['environment']
-
-        if data.get('time_spent'):
-            try:
-                data['time_spent'] = int(data['time_spent'])
-            except (ValueError, TypeError):
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'time_spent',
-                        'value': data['time_spent'],
-                    }
-                )
-                del data['time_spent']
-            else:
-                if data['time_spent'] > BoundedIntegerField.MAX_VALUE:
-                    data['errors'].append(
-                        {
-                            'type': EventError.VALUE_TOO_LONG,
-                            'name': 'time_spent',
-                            'value': data['time_spent'],
-                        }
-                    )
-                    del data['time_spent']
-
         return data
 
     def ensure_does_not_have_ip(self, data):
@@ -973,6 +504,7 @@ class CspApiHelper(ClientApiHelper):
             'message': inst.get_message(),
             'culprit': inst.get_culprit(),
             'release': meta.get('release'),
+            'tags': inst.get_tags(),
             inst.get_path(): inst.to_json(),
             # This is a bit weird, since we don't have nearly enough
             # information to create an Http interface, but
@@ -985,51 +517,8 @@ class CspApiHelper(ClientApiHelper):
             'sentry.interfaces.User': {
                 'ip_address': self.context.ip_address,
             },
-            'errors': [],
         }
 
-        # Copy/pasted from above in ClientApiHelper.validate_data
-        if data.get('release'):
-            data['release'] = six.text_type(data['release'])
-            if len(data['release']) > VERSION_LENGTH:
-                data['errors'].append(
-                    {
-                        'type': EventError.VALUE_TOO_LONG,
-                        'name': 'release',
-                        'value': data['release'],
-                    }
-                )
-                del data['release']
-
-        tags = []
-        for k, v in inst.get_tags():
-            if not v:
-                continue
-            if len(v) > MAX_TAG_VALUE_LENGTH:
-                self.log.debug('Discarded invalid tag: %s=%s', k, v)
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'tags',
-                        'value': (k, v),
-                    }
-                )
-                continue
-            if not tagstore.is_valid_value(v):
-                self.log.debug('Discard invalid tag value: %s', v)
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'tags',
-                        'value': (k, v),
-                    }
-                )
-                continue
-            tags.append((k, v))
-
-        if tags:
-            data['tags'] = tags
-
         return data
 
 
diff --git a/src/sentry/event_manager.py b/src/sentry/event_manager.py
index 234e8c5114..97305cef08 100644
--- a/src/sentry/event_manager.py
+++ b/src/sentry/event_manager.py
@@ -20,17 +20,19 @@ from django.utils.encoding import force_bytes, force_text
 from hashlib import md5
 from uuid import uuid4
 
-from sentry import eventtypes, features, buffer, tagstore
+from sentry import eventtypes, features, buffer
 # we need a bunch of unexposed functions from tsdb
 from sentry.tsdb import backend as tsdb
 from sentry.constants import (
-    CLIENT_RESERVED_ATTRS, LOG_LEVELS, DEFAULT_LOGGER_NAME, MAX_CULPRIT_LENGTH
+    CLIENT_RESERVED_ATTRS, LOG_LEVELS, LOG_LEVELS_MAP, DEFAULT_LOG_LEVEL,
+    DEFAULT_LOGGER_NAME, MAX_CULPRIT_LENGTH, VALID_PLATFORMS
 )
-from sentry.interfaces.base import get_interface
+from sentry.interfaces.base import get_interface, InterfaceValidationError
+from sentry.interfaces.schemas import validate_and_default_interface
 from sentry.models import (
-    Activity, Environment, Event, EventMapping, EventUser, Group, GroupHash, GroupRelease,
-    GroupResolution, GroupStatus, Project, Release, ReleaseEnvironment, ReleaseProject,
-    UserReport
+    Activity, Environment, Event, EventError, EventMapping, EventUser, Group,
+    GroupHash, GroupRelease, GroupResolution, GroupStatus, Project, Release,
+    ReleaseEnvironment, ReleaseProject, UserReport
 )
 from sentry.plugins import plugins
 from sentry.signals import event_discarded, event_saved, first_event_received, regression_signal
@@ -41,7 +43,7 @@ from sentry.utils.cache import default_cache
 from sentry.utils.db import get_db_engine
 from sentry.utils.safe import safe_execute, trim, trim_dict
 from sentry.utils.strings import truncatechars
-from sentry.utils.validators import validate_ip
+from sentry.utils.validators import is_float, validate_ip
 from sentry.stacktraces import normalize_in_app
 
 
@@ -195,6 +197,54 @@ def plugin_is_regression(group, event):
     return True
 
 
+def process_data_timestamp(data, current_datetime=None):
+    value = data['timestamp']
+    if not value:
+        del data['timestamp']
+        return data
+    data['timestamp'] = process_timestamp(data['timestamp'], current_datetime)
+    return data
+
+
+def process_timestamp(value, current_datetime=None):
+    if is_float(value):
+        try:
+            value = datetime.fromtimestamp(float(value))
+        except Exception:
+            raise InvalidTimestamp(
+                'Invalid value for timestamp: %r' % value)
+    elif not isinstance(value, datetime):
+        # all timestamps are in UTC, but the marker is optional
+        if value.endswith('Z'):
+            value = value[:-1]
+        if '.' in value:
+            # Python doesn't support long microsecond values
+            # https://github.com/getsentry/sentry/issues/1610
+            ts_bits = value.split('.', 1)
+            value = '%s.%s' % (ts_bits[0], ts_bits[1][:2])
+            fmt = '%Y-%m-%dT%H:%M:%S.%f'
+        else:
+            fmt = '%Y-%m-%dT%H:%M:%S'
+        try:
+            value = datetime.strptime(value, fmt)
+        except Exception:
+            raise InvalidTimestamp(
+                'Invalid value for timestamp: %r' % value)
+
+    if current_datetime is None:
+        current_datetime = datetime.now()
+
+    if value > current_datetime + timedelta(minutes=1):
+        raise InvalidTimestamp(
+            'Invalid value for timestamp (in future): %r' % value)
+
+    if value < current_datetime - timedelta(days=30):
+        raise InvalidTimestamp(
+            'Invalid value for timestamp (too old): %r' % value)
+
+    return float(value.strftime('%s'))
+
+
 class HashDiscarded(Exception):
     pass
 
@@ -231,6 +281,10 @@ class ScoreClause(object):
         return math.log(times_seen) * 600 + float(last_seen.strftime('%s'))
 
 
+class InvalidTimestamp(Exception):
+    pass
+
+
 class EventManager(object):
     logger = logging.getLogger('sentry.events')
 
@@ -239,32 +293,105 @@ class EventManager(object):
         self.version = version
 
     def normalize(self):
-        # TODO(dcramer): store http.env.REMOTE_ADDR as user.ip
-        # First we pull out our top-level (non-data attr) kwargs
         data = self.data
+        errors = data.get('errors', [])
+
+        # Before validating with a schema, attempt to cast values to their desired types
+        # so that the schema doesn't have to take every type variation into account.
+        text = six.text_type
+        fp_types = six.string_types + six.integer_types + (float, )
+
+        def to_values(v):
+            return {'values': v} if v and isinstance(v, (tuple, list)) else v
+
+        casts = {
+            'environment': lambda v: text(v) if v is not None else v,
+            'fingerprint': lambda v: list(map(text, v)) if isinstance(v, list) and all(isinstance(f, fp_types) for f in v) else v,
+            'release': lambda v: text(v) if v is not None else v,
+            'dist': lambda v: text(v).strip() if v is not None else v,
+            'time_spent': lambda v: int(v) if v is not None else v,
+            'tags': lambda v: [(text(v_k).replace(' ', '-').strip(), text(v_v).strip()) for (v_k, v_v) in dict(v).items()],
+            'timestamp': lambda v: process_timestamp(v),
+            'platform': lambda v: v if v in VALID_PLATFORMS else 'other',
+
+            # These can be sent as lists and need to be converted to {'values': [...]}
+            'exception': to_values,
+            'sentry.interfaces.Exception': to_values,
+            'breadcrumbs': to_values,
+            'sentry.interfaces.Breadcrumbs': to_values,
+            'threads': to_values,
+            'sentry.interfaces.Threads': to_values,
+        }
 
-        if not isinstance(data.get('level'), (six.string_types, int)):
-            data['level'] = logging.ERROR
-        elif data['level'] not in LOG_LEVELS:
-            data['level'] = logging.ERROR
+        for c in casts:
+            if c in data:
+                try:
+                    data[c] = casts[c](data[c])
+                except Exception as e:
+                    errors.append({'type': EventError.INVALID_DATA, 'name': c, 'value': data[c]})
+                    del data[c]
+
+        # raw 'message' is coerced to the Message interface, as its used for pure index of
+        # searchable strings. If both a raw 'message' and a Message interface exist, try and
+        # add the former as the 'formatted' attribute of the latter.
+        # See GH-3248
+        msg_str = data.pop('message', None)
+        if msg_str:
+            msg_if = data.setdefault('sentry.interfaces.Message', {'message': msg_str})
+            if msg_if.get('message') != msg_str:
+                msg_if.setdefault('formatted', msg_str)
+
+        # Validate main event body and tags against schema
+        is_valid, event_errors = validate_and_default_interface(data, 'event')
+        errors.extend(event_errors)
+
+        if 'tags' in data:
+            is_valid, tag_errors = validate_and_default_interface(data['tags'], 'tags', name='tags')
+            errors.extend(tag_errors)
+
+        # Validate interfaces
+        for k in list(iter(data)):
+            if k in CLIENT_RESERVED_ATTRS:
+                continue
 
-        if not data.get('logger') or not isinstance(data.get('logger'), six.string_types):
-            data['logger'] = DEFAULT_LOGGER_NAME
-        else:
-            logger = trim(data['logger'].strip(), 64)
-            if tagstore.is_valid_key(logger):
-                data['logger'] = logger
-            else:
-                data['logger'] = DEFAULT_LOGGER_NAME
+            value = data.pop(k)
 
-        if data.get('platform'):
-            data['platform'] = trim(data['platform'], 64)
+            if not value:
+                self.logger.debug('Ignored empty interface value: %s', k)
+                continue
+
+            try:
+                interface = get_interface(k)
+            except ValueError:
+                self.logger.debug('Ignored unknown attribute: %s', k)
+                errors.append({'type': EventError.INVALID_ATTRIBUTE, 'name': k})
+                continue
+
+            try:
+                inst = interface.to_python(value)
+                data[inst.get_path()] = inst.to_json()
+            except Exception as e:
+                log = self.logger.debug if isinstance(
+                    e, InterfaceValidationError) else self.logger.error
+                log('Discarded invalid value for interface: %s (%r)', k, value, exc_info=True)
+                errors.append({'type': EventError.INVALID_DATA, 'name': k, 'value': value})
+
+        level = data.get('level') or DEFAULT_LOG_LEVEL
+        if isinstance(level, int) or (isinstance(level, six.string_types) and level.isdigit()):
+            level = LOG_LEVELS.get(int(level), DEFAULT_LOG_LEVEL)
+        data['level'] = LOG_LEVELS_MAP.get(level, LOG_LEVELS_MAP[DEFAULT_LOG_LEVEL])
+
+        if data.get('dist') and not data.get('release'):
+            data['dist'] = None
 
-        current_timestamp = timezone.now()
         timestamp = data.get('timestamp')
         if not timestamp:
-            timestamp = current_timestamp
+            timestamp = timezone.now()
 
+        # TODO (alex) can this all be replaced by utcnow?
+        # it looks like the only time that this would even be hit is when timestamp
+        # is not defined, as the earlier process_timestamp already converts existing
+        # timestamps to floats.
         if isinstance(timestamp, datetime):
             # We must convert date to local time so Django doesn't mess it up
             # based on TIME_ZONE
@@ -278,9 +405,6 @@ class EventManager(object):
         data['timestamp'] = timestamp
         data['received'] = float(timezone.now().strftime('%s'))
 
-        if not data.get('event_id'):
-            data['event_id'] = uuid4().hex
-
         data.setdefault('culprit', None)
         data.setdefault('transaction', None)
         data.setdefault('server_name', None)
@@ -291,96 +415,23 @@ class EventManager(object):
         data.setdefault('dist', None)
         data.setdefault('environment', None)
         data.setdefault('extra', {})
-        data.setdefault('errors', [])
-
-        tags = data.get('tags')
-        if not tags:
-            tags = []
-        # full support for dict syntax
-        elif isinstance(tags, dict):
-            tags = list(tags.items())
-        # prevent [tag, tag, tag] (invalid) syntax
-        elif not all(len(t) == 2 for t in tags):
-            tags = []
-        else:
-            tags = list(tags)
-
-        data['tags'] = []
-        for key, value in tags:
-            key = six.text_type(key).strip()
-            value = six.text_type(value).strip()
-            if not (key and value):
-                continue
-
-            # XXX(dcramer): many legacy apps are using the environment tag
-            # rather than the key itself
-            if key == 'environment' and not data.get('environment'):
-                data['environment'] = value
-            else:
-                data['tags'].append((key, value))
-
-        if not isinstance(data['extra'], dict):
-            # throw it away
-            data['extra'] = {}
-
-        trim_dict(data['extra'], max_size=settings.SENTRY_MAX_EXTRA_VARIABLE_SIZE)
-
-        # TODO(dcramer): more of validate data needs stuffed into the manager
-        for key in list(iter(data)):
-            if key in CLIENT_RESERVED_ATTRS:
-                continue
-
-            value = data.pop(key)
-
-            try:
-                interface = get_interface(key)()
-            except ValueError:
-                continue
-
-            try:
-                inst = interface.to_python(value)
-                data[inst.get_path()] = inst.to_json()
-            except Exception:
-                # XXX: we should consider logging this.
-                pass
-
-        # TODO(dcramer): this logic is duplicated in ``validate_data`` from
-        # coreapi
-
-        # message is coerced to an interface, as its used for pure
-        # index of searchable strings
-        # See GH-3248
-        message = data.pop('message', None)
-        if message:
-            if 'sentry.interfaces.Message' not in data:
-                interface = get_interface('sentry.interfaces.Message')
-                try:
-                    inst = interface.to_python({
-                        'message': message,
-                    })
-                    data[inst.get_path()] = inst.to_json()
-                except Exception:
-                    pass
-            elif not data['sentry.interfaces.Message'].get('formatted'):
-                interface = get_interface('sentry.interfaces.Message')
-                try:
-                    inst = interface.to_python(
-                        dict(
-                            data['sentry.interfaces.Message'],
-                            formatted=message,
-                        )
-                    )
-                    data[inst.get_path()] = inst.to_json()
-                except Exception:
-                    pass
+        data.setdefault('tags', [])
+
+        # Fix case where legacy apps pass 'environment' as a tag
+        # instead of a top level key.
+        # TODO (alex) save() just reinserts the environment into the tags
+        if not data.get('environment'):
+            tagsdict = dict(data['tags'])
+            if 'environment' in tagsdict:
+                data['environment'] = tagsdict['environment']
+                del tagsdict['environment']
+                data['tags'] = tagsdict.items()
 
         # the SDKs currently do not describe event types, and we must infer
         # them from available attributes
         data['type'] = eventtypes.infer(data).key
-
         data['version'] = self.version
 
-        # TODO(dcramer): find a better place for this logic
         exception = data.get('sentry.interfaces.Exception')
         stacktrace = data.get('sentry.interfaces.Stacktrace')
         if exception and len(exception['values']) == 1 and stacktrace:
@@ -393,11 +444,20 @@ class EventManager(object):
                     data['sentry.interfaces.Http'].get('env', {}).get('REMOTE_ADDR'),
                     required=False,
                 )
+                if ip_address:
+                    data.setdefault(
+                        'sentry.interfaces.User',
+                        {}).setdefault(
+                        'ip_address',
+                        ip_address)
             except ValueError:
-                ip_address = None
-            if ip_address:
-                data.setdefault('sentry.interfaces.User', {})
-                data['sentry.interfaces.User'].setdefault('ip_address', ip_address)
+                pass
+
+        # Trim values
+        logger = data.get('logger', DEFAULT_LOGGER_NAME)
+        data['logger'] = trim(logger.strip(), 64)
+
+        trim_dict(data['extra'], max_size=settings.SENTRY_MAX_EXTRA_VARIABLE_SIZE)
 
         if data['culprit']:
             data['culprit'] = trim(data['culprit'], MAX_CULPRIT_LENGTH)
@@ -405,6 +465,8 @@ class EventManager(object):
         if data['transaction']:
             data['transaction'] = trim(data['transaction'], MAX_CULPRIT_LENGTH)
 
+        data['errors'] = errors
+
         return data
 
     def save(self, project, raw=False):
diff --git a/src/sentry/interfaces/csp.py b/src/sentry/interfaces/csp.py
index fe42e26cb0..fb109aa1bc 100644
--- a/src/sentry/interfaces/csp.py
+++ b/src/sentry/interfaces/csp.py
@@ -137,10 +137,10 @@ class Csp(Interface):
         return self._normalize_directive(self.violated_directive)
 
     def get_tags(self):
-        return (
+        return [
             ('effective-directive', self.effective_directive),
             ('blocked-uri', self.sanitized_blocked_uri()),
-        )
+        ]
 
     def sanitized_blocked_uri(self):
         # HACK: This is 100% to work around Stripe urls
diff --git a/src/sentry/interfaces/device.py b/src/sentry/interfaces/device.py
index 7cbad6f035..de2b2742f4 100644
--- a/src/sentry/interfaces/device.py
+++ b/src/sentry/interfaces/device.py
@@ -3,6 +3,7 @@ from __future__ import absolute_import
 __all__ = ('Device', )
 
 from sentry.interfaces.base import Interface, InterfaceValidationError
+from sentry.interfaces.schemas import validate_and_default_interface
 from sentry.utils.safe import trim, trim_dict
 
 
@@ -17,25 +18,19 @@ class Device(Interface):
     >>>     "arbitrary": "data"
     >>> }
     """
+    path = 'device'
 
     @classmethod
     def to_python(cls, data):
+        is_valid, errors = validate_and_default_interface(data, cls.path)
+        if not is_valid:
+            raise InterfaceValidationError("Invalid device")
+
         data = data.copy()
 
         extra_data = data.pop('data', data)
-        if not isinstance(extra_data, dict):
-            extra_data = {}
-
-        try:
-            name = trim(data.pop('name'), 64)
-        except KeyError:
-            raise InterfaceValidationError("Missing or invalid value for 'name'")
-
-        try:
-            version = trim(data.pop('version'), 64)
-        except KeyError:
-            raise InterfaceValidationError("Missing or invalid value for 'version'")
-
+        name = trim(data.pop('name'), 64)
+        version = trim(data.pop('version'), 64)
         build = trim(data.pop('build', None), 64)
 
         kwargs = {
diff --git a/src/sentry/interfaces/exception.py b/src/sentry/interfaces/exception.py
index d7476b3881..90dacd8625 100644
--- a/src/sentry/interfaces/exception.py
+++ b/src/sentry/interfaces/exception.py
@@ -16,6 +16,7 @@ import six
 from django.conf import settings
 
 from sentry.interfaces.base import Interface, InterfaceValidationError
+from sentry.interfaces.schemas import validate_and_default_interface
 from sentry.interfaces.stacktrace import Stacktrace, slim_frame_data
 from sentry.utils import json
 from sentry.utils.safe import trim
@@ -43,9 +44,14 @@ class SingleException(Interface):
     >>> }
     """
     score = 2000
+    path = 'sentry.interfaces.Exception'
 
     @classmethod
     def to_python(cls, data, slim_frames=True):
+        is_valid, errors = validate_and_default_interface(data, cls.path)
+        if not is_valid:
+            raise InterfaceValidationError("Invalid exception")
+
         if not (data.get('type') or data.get('value')):
             raise InterfaceValidationError("No 'type' or 'value' present")
 
@@ -79,8 +85,6 @@ class SingleException(Interface):
 
         mechanism = data.get('mechanism')
         if mechanism is not None:
-            if not isinstance(mechanism, dict):
-                raise InterfaceValidationError('Bad value for mechanism')
             mechanism = trim(data.get('mechanism'), 4096)
             mechanism.setdefault('type', 'generic')
 
@@ -142,7 +146,7 @@ class SingleException(Interface):
         return 'exception'
 
     def get_path(self):
-        return 'sentry.interfaces.Exception'
+        return self.path
 
     def get_hash(self, platform=None):
         output = None
diff --git a/src/sentry/interfaces/http.py b/src/sentry/interfaces/http.py
index d90866c143..a55137bdfe 100644
--- a/src/sentry/interfaces/http.py
+++ b/src/sentry/interfaces/http.py
@@ -18,6 +18,7 @@ from django.utils.translation import ugettext as _
 from six.moves.urllib.parse import parse_qsl, urlencode, urlsplit, urlunsplit
 
 from sentry.interfaces.base import Interface, InterfaceValidationError
+from sentry.interfaces.schemas import validate_and_default_interface
 from sentry.utils.safe import trim, trim_dict, trim_pairs
 from sentry.utils.http import heuristic_decode
 from sentry.web.helpers import render_to_string
@@ -116,13 +117,15 @@ class Http(Interface):
     """
     display_score = 1000
     score = 800
+    path = 'sentry.interfaces.Http'
 
     FORM_TYPE = 'application/x-www-form-urlencoded'
 
     @classmethod
     def to_python(cls, data):
-        if not data.get('url'):
-            raise InterfaceValidationError("No value for 'url'")
+        is_valid, errors = validate_and_default_interface(data, cls.path)
+        if not is_valid:
+            raise InterfaceValidationError("Invalid interface data")
 
         kwargs = {}
 
@@ -146,7 +149,6 @@ class Http(Interface):
                     [(to_bytes(k), to_bytes(v)) for k, v in query_string.items()]
                 )
             else:
-                query_string = query_string
                 if query_string[0] == '?':
                     # remove '?' prefix
                     query_string = query_string[1:]
@@ -200,7 +202,7 @@ class Http(Interface):
         return cls(**kwargs)
 
     def get_path(self):
-        return 'sentry.interfaces.Http'
+        return self.path
 
     @property
     def full_url(self):
diff --git a/src/sentry/interfaces/query.py b/src/sentry/interfaces/query.py
index 5dfde28ed5..e8282df16e 100644
--- a/src/sentry/interfaces/query.py
+++ b/src/sentry/interfaces/query.py
@@ -26,6 +26,8 @@ class Query(Interface):
 
     @classmethod
     def to_python(cls, data):
+        if not isinstance(data, dict):
+            raise InterfaceValidationError("Invalid interface data")
         if not data.get('query'):
             raise InterfaceValidationError("No 'query' value")
 
diff --git a/src/sentry/interfaces/schemas.py b/src/sentry/interfaces/schemas.py
new file mode 100644
index 0000000000..60a25bf10a
--- /dev/null
+++ b/src/sentry/interfaces/schemas.py
@@ -0,0 +1,499 @@
+"""
+sentry.interfaces.schemas
+~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2017 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import absolute_import
+
+from functools32 import lru_cache
+from itertools import groupby
+import jsonschema
+import six
+import uuid
+
+from sentry.db.models import BoundedIntegerField
+from sentry.constants import (
+    LOG_LEVELS_MAP,
+    MAX_TAG_KEY_LENGTH,
+    MAX_TAG_VALUE_LENGTH,
+    VALID_PLATFORMS,
+    VERSION_LENGTH,
+)
+from sentry.interfaces.base import InterfaceValidationError
+from sentry.models import EventError
+from sentry.tagstore.base import INTERNAL_TAG_KEYS
+
+
+def iverror(message="Invalid data"):
+    raise InterfaceValidationError(message)
+
+
+def apierror(message="Invalid data"):
+    from sentry.coreapi import APIForbidden
+    raise APIForbidden(message)
+
+PAIRS = {
+    'type': 'array',
+    'items': {
+        'type': 'array',
+        'minItems': 2,
+        'maxItems': 2,
+        'items': {'type': 'string'}
+    }
+}
+
+HTTP_INTERFACE_SCHEMA = {
+    'type': 'object',
+    'properties': {
+        'url': {
+            'type': 'string',
+            'minLength': 1,
+        },
+        'method': {'type': 'string'},
+        'query_string': {'type': ['string', 'object']},
+        'inferred_content_type': {'type': 'string'},
+        'cookies': {
+            'anyOf': [
+                {'type': ['string', 'object']},  # either a string of object
+                PAIRS,  # or a list of 2-tuples
+            ]
+        },
+        'env': {'type': 'object'},
+        'headers': {
+            'anyOf': [
+                {'type': 'object'},  # either an object
+                PAIRS,  # or a list of 2-tuples
+            ]
+        },
+        'data': {'type': ['string', 'object', 'array']},
+        'fragment': {'type': 'string'},
+    },
+    'required': ['url'],
+    'additionalProperties': True,
+}
+
+FRAME_INTERFACE_SCHEMA = {
+    'type': 'object',
+    'properties': {
+        'abs_path': {
+            'type': 'string',
+            'default': iverror,
+        },
+        'colno': {'type': ['number', 'string']},
+        'context_line': {'type': 'string'},
+        'data': {
+            'anyOf': [
+                {'type': 'object'},
+                PAIRS,
+            ]
+        },
+        'errors': {},
+        'filename': {
+            'type': 'string',
+            'default': iverror,
+        },
+        'function': {'type': 'string'},
+        'image_addr': {},
+        'in_app': {'type': 'boolean', 'default': False},
+        'instruction_addr': {},
+        'instruction_offset': {},
+        'lineno': {'type': ['number', 'string']},
+        'module': {
+            'type': 'string',
+            'default': iverror,
+        },
+        'package': {'type': 'string'},
+        'platform': {
+            'type': 'string',
+            'enum': list(VALID_PLATFORMS),
+        },
+        'post_context': {},
+        'pre_context': {},
+        'project_root': {},
+        'symbol': {'type': 'string'},
+        'symbol_addr': {},
+        'vars': {
+            'anyOf': [
+                {'type': ['object', 'array']},
+                PAIRS,
+            ]
+        },
+    },
+    # `additionalProperties: {'not': {}}` forces additional properties to
+    # individually fail with errors that identify the key, so they can be deleted.
+    'additionalProperties': {'not': {}},
+}
+
+STACKTRACE_INTERFACE_SCHEMA = {
+    'type': 'object',
+    'properties': {
+        'frames': {
+            'type': 'array',
+            # To validate individual frames use FRAME_INTERFACE_SCHEMA
+            'items': {'type': 'object'},
+            'minItems': 1,
+        },
+        'frames_omitted': {
+            'type': 'array',
+            'maxItems': 2,
+            'minItems': 2,
+            'items': {'type': 'number'},
+        },
+        'registers': {'type': 'object'},
+    },
+    'required': ['frames'],
+    # `additionalProperties: {'not': {}}` forces additional properties to
+    # individually fail with errors that identify the key, so they can be deleted.
+    'additionalProperties': {'not': {}},
+}
+
+EXCEPTION_INTERFACE_SCHEMA = {
+    'type': 'object',
+    'properties': {
+        'type': {
+            'type': 'string',
+            # 'minLength': 1,
+        },
+        'value': {
+            # 'minProperties': 1,
+            # 'minItems': 1,
+            # 'minLength': 1,
+        },
+        'module': {'type': 'string'},
+        'mechanism': {'type': 'object'},
+        'stacktrace': {
+            # To validate stacktraces use STACKTRACE_INTERFACE_SCHEMA
+            'type': 'object',
+            'properties': {
+                # The code allows for the possibility of an empty
+                # {"frames":[]} object, this sucks and should go.
+                # STACKTRACE_INTERFACE_SCHEMA enforces at least 1
+                'frames': {'type': 'array'},
+            },
+        },
+        'thread_id': {},
+        'raw_stacktrace': {
+            'type': 'object',
+            'properties': {
+                'frames': {'type': 'array'},
+            },
+        },
+    },
+    'anyOf': [  # Require at least one of these keys.
+        {'required': ['type']},
+        {'required': ['value']},
+    ],
+    # TODO should be false but allowing extra garbage for now
+    # for compatibility
+    'additionalProperties': True,
+}
+
+DEVICE_INTERFACE_SCHEMA = {
+    'type': 'object',
+    'properties': {
+        'name': {
+            'type': 'string',
+            'minLength': 1,
+        },
+        'version': {
+            'type': 'string',
+            'minLength': 1,
+        },
+        'build': {},
+        'data': {
+            'type': 'object',
+            'default': {},
+        },
+    },
+    'required': ['name', 'version'],
+}
+
+TEMPLATE_INTERFACE_SCHEMA = {'type': 'object'}  # TODO fill this out
+MESSAGE_INTERFACE_SCHEMA = {'type': 'object'}
+
+TAGS_DICT_SCHEMA = {
+    'allOf': [
+        {
+            'type': 'object',
+            # TODO with draft 6 support, we can just use propertyNames/maxLength
+            'patternProperties': {
+                '^[a-zA-Z0-9_\.:-]{1,%d}$' % MAX_TAG_KEY_LENGTH: {
+                    'type': 'string',
+                    'minLength': 1,
+                    'maxLength': MAX_TAG_VALUE_LENGTH,
+                    'pattern': '^[^\n]+\Z',  # \Z because $ matches before trailing newline
+                }
+            },
+            'additionalProperties': False,
+        },
+        {
+            # This is a negative match for all the reserved tags
+            'type': 'object',
+            'patternProperties': {
+                '^(%s)$' % '|'.join(INTERNAL_TAG_KEYS): {'not': {}}
+            },
+            'additionalProperties': True,
+        },
+    ],
+}
+
+TAGS_TUPLES_SCHEMA = {
+    'type': 'array',
+    'items': {
+        'type': 'array',
+        'minItems': 2,
+        'maxItems': 2,
+        'items': [
+            # Key
+            {
+                'type': 'string',
+                'pattern': '^[a-zA-Z0-9_\.:-]+$',
+                'minLength': 1,
+                'maxLength': MAX_TAG_KEY_LENGTH,
+                'not': {
+                    'pattern': '^(%s)$' % '|'.join(INTERNAL_TAG_KEYS),
+                },
+            },
+            # Value
+            {
+                'type': 'string',
+                'pattern': '^[^\n]*\Z',  # \Z because $ matches before a trailing newline
+                'minLength': 1,
+                'maxLength': MAX_TAG_VALUE_LENGTH,
+            },
+        ]
+    }
+}
+
+TAGS_SCHEMA = {
+    'anyOf': [TAGS_DICT_SCHEMA, TAGS_TUPLES_SCHEMA]
+}
+
+EVENT_SCHEMA = {
+    'type': 'object',
+    'properties': {
+        'type': {
+            'type': 'string',
+        },
+        'event_id': {
+            'type': 'string',
+            'pattern': '^[a-fA-F0-9]+$',
+            'maxLength': 32,
+            'minLength': 32,
+            'default': lambda: uuid.uuid4().hex,
+        },
+        'timestamp': {
+            'anyOf': [
+                {'type': 'string', 'format': 'date-time'},
+                {'type': 'number'}
+            ],
+        },
+        'logger': {
+            'type': 'string',
+            'pattern': r'^[a-zA-Z0-9_\.:-]+$',
+            'default': '',
+        },
+        'platform': {
+            'type': 'string',
+            'enum': list(VALID_PLATFORMS),
+            'default': 'other',
+        },
+        'sdk': {
+            'type': 'object',
+            'properties': {
+                'name': {'type': 'string'},
+                'version': {},
+                'integrations': {},
+            },
+            'additionalProperties': True,
+        },
+        'level': {
+            'anyOf': [
+                {'type': 'number'},
+                {
+                    'type': 'string',
+                    'pattern': '^[0-9]+$',
+                },
+                {
+                    'type': 'string',
+                    'enum': LOG_LEVELS_MAP.keys(),
+                },
+            ],
+        },
+        'culprit': {
+            'type': 'string',
+            # 'minLength': 1,
+            # 'maxLength': MAX_CULPRIT_LENGTH,
+            'default': lambda: apierror('Invalid value for culprit'),
+        },
+        'server_name': {'type': 'string'},
+        'release': {
+            'type': 'string',
+            'maxLength': VERSION_LENGTH,
+        },
+        'dist': {
+            'type': 'string',
+            'pattern': '^[a-zA-Z0-9_.-]+$',
+            'maxLength': 64,
+        },
+        'tags': {
+            # This is a loose tags schema, individual tags
+            # are also validated more in depth with TAGS_SCHEMA
+            'anyOf': [
+                {'type': 'object'},
+                PAIRS,
+            ]
+        },
+        'environment': {
+            'type': 'string',
+            'maxLength': 64,
+        },
+        'modules': {'type': 'object'},
+        'extra': {'type': 'object'},
+        'fingerprint': {
+            'type': 'array',
+            'items': {'type': 'string'},
+        },
+        'time_spent': {
+            'type': 'number',
+            'maximum': BoundedIntegerField.MAX_VALUE,
+            'minimum': 0,
+        },
+
+        # Exceptions:
+        'exception': {},  # EXCEPTION_INTERFACE_SCHEMA,
+        'sentry.interfaces.Exception': {},  # EXCEPTION_INTERFACE_SCHEMA,
+
+        # Messages:
+        # 'message' is not an alias for the sentry.interfaces.Message interface
+        # but instead is a raw string that will be wrapped in a Message interface
+        'message': {'type': 'string'},
+        'logentry': {},  # MESSAGE_INTERFACE_SCHEMA,
+        'sentry.interfaces.Message': {},  # MESSAGE_INTERFACE_SCHEMA,
+
+        # Templates:
+        'template': {},  # TEMPLATE_INTERFACE_SCHEMA,
+        'sentry.interfaces.Template': {},  # TEMPLATE_INTERFACE_SCHEMA,
+
+        # Other interfaces
+        'sentry.interfaces.User': {'type': 'object'},
+        'sentry.interfaces.Http': {},
+
+        # Other reserved keys. (some are added in processing)
+        'project': {'type': ['number', 'string']},
+        'errors': {'type': 'array'},
+        'checksum': {},
+        'site': {},
+        'received': {},
+    },
+    'required': ['platform', 'event_id'],
+    'additionalProperties': True,
+}
+"""
+Schemas for raw request data.
+
+This is to validate input data at the very first stage of ingestion. It can
+then be transformed into the requisite interface.
+"""
+INPUT_SCHEMAS = {
+}
+
+"""
+Schemas for interfaces.
+
+Data returned by interface.to_json() or passed into interface.to_python()
+should conform to these schemas. Currently this is not enforced everywhere yet.
+"""
+INTERFACE_SCHEMAS = {
+    # These should match SENTRY_INTERFACES keys
+    'sentry.interfaces.Http': HTTP_INTERFACE_SCHEMA,
+    'request': HTTP_INTERFACE_SCHEMA,
+    'exception': EXCEPTION_INTERFACE_SCHEMA,
+    'sentry.interfaces.Exception': EXCEPTION_INTERFACE_SCHEMA,
+    'stacktrace': STACKTRACE_INTERFACE_SCHEMA,
+    'sentry.interfaces.Stacktrace': STACKTRACE_INTERFACE_SCHEMA,
+    'frame': FRAME_INTERFACE_SCHEMA,  # Not listed in SENTRY_INTERFACES
+    'logentry': MESSAGE_INTERFACE_SCHEMA,
+    'sentry.interfaces.Message': MESSAGE_INTERFACE_SCHEMA,
+    'template': TEMPLATE_INTERFACE_SCHEMA,
+    'sentry.interfaces.Template': TEMPLATE_INTERFACE_SCHEMA,
+    'device': DEVICE_INTERFACE_SCHEMA,
+
+    # Not interfaces per se, but looked up as if they were.
+    'event': EVENT_SCHEMA,
+    'tags': TAGS_TUPLES_SCHEMA,
+}
+
+
+@lru_cache(maxsize=100)
+def validator_for_interface(name):
+    if name not in INTERFACE_SCHEMAS:
+        return None
+    return jsonschema.Draft4Validator(INTERFACE_SCHEMAS[name], types={'array': (list, tuple)})
+
+
+def validate_and_default_interface(data, interface, name=None,
+                                   strip_nones=True, raise_on_invalid=False):
+    """
+    Modify data to conform to named interface's schema.
+
+    Takes the object in `data` and checks it against the schema for
+    `interface`, removing or defaulting any keys that do not pass validation
+    and adding defaults for any keys that are required by (and have a default
+    value in) the schema.
+
+    Returns whether the resulting modified data is valid against the schema and
+    a list of any validation errors encountered in processing.
+    """
+    is_valid = True
+    needs_revalidation = False
+    errors = []
+
+    validator = validator_for_interface(interface)
+    if validator is None:
+        return (True, [])
+    schema = validator.schema
+
+    # Strip Nones so we don't have to take null into account for all schemas.
+    if strip_nones and isinstance(data, dict):
+        for k in data.keys():
+            if data[k] is None:
+                del data[k]
+
+    # Values that are missing entirely, but are required and should be defaulted
+    if 'properties' in schema and 'required' in schema and isinstance(data, dict):
+        for p in schema['required']:
+            if p not in data:
+                if p in schema['properties'] and 'default' in schema['properties'][p]:
+                    default = schema['properties'][p]['default']
+                    data[p] = default() if callable(default) else default
+                else:
+                    # TODO raise as shortcut?
+                    errors.append({'type': EventError.MISSING_ATTRIBUTE, 'name': p})
+
+    validator_errors = list(validator.iter_errors(data))
+    keyed_errors = [e for e in reversed(validator_errors) if len(e.path)]
+    if len(validator_errors) > len(keyed_errors):
+        needs_revalidation = True
+
+    # Values that need to be defaulted or deleted because they are not valid.
+    for key, group in groupby(keyed_errors, lambda e: e.path[0]):
+        ve = six.next(group)
+        is_max = ve.validator.startswith('max')
+        error_type = EventError.VALUE_TOO_LONG if is_max else EventError.INVALID_DATA
+        errors.append({'type': error_type, 'name': name or key, 'value': data[key]})
+
+        if 'default' in ve.schema:
+            default = ve.schema['default']
+            data[key] = default() if callable(default) else default
+        else:
+            needs_revalidation = True
+            del data[key]
+
+    if needs_revalidation:
+        is_valid = validator.is_valid(data)
+
+    return is_valid, errors
diff --git a/src/sentry/interfaces/stacktrace.py b/src/sentry/interfaces/stacktrace.py
index feabc4855d..7eea62e02b 100644
--- a/src/sentry/interfaces/stacktrace.py
+++ b/src/sentry/interfaces/stacktrace.py
@@ -20,10 +20,10 @@ from six.moves.urllib.parse import urlparse
 
 from sentry.app import env
 from sentry.interfaces.base import Interface, InterfaceValidationError
+from sentry.interfaces.schemas import validate_and_default_interface
 from sentry.models import UserOption
 from sentry.utils.safe import trim, trim_dict
 from sentry.web.helpers import render_to_string
-from sentry.constants import VALID_PLATFORMS
 
 _ruby_anon_func = re.compile(r'_\d{2,}')
 _filename_version_re = re.compile(
@@ -253,8 +253,15 @@ def handle_nan(value):
 
 
 class Frame(Interface):
+
+    path = 'frame'
+
     @classmethod
     def to_python(cls, data, raw=False):
+        is_valid, errors = validate_and_default_interface(data, cls.path)
+        if not is_valid:
+            raise InterfaceValidationError("Invalid stack frame data.")
+
         abs_path = data.get('abs_path')
         filename = data.get('filename')
         symbol = data.get('symbol')
@@ -270,11 +277,6 @@ class Frame(Interface):
         if symbol == '?':
             symbol = None
 
-        for name in ('abs_path', 'filename', 'symbol', 'function', 'module', 'package'):
-            v = data.get(name)
-            if v is not None and not isinstance(v, six.string_types):
-                raise InterfaceValidationError("Invalid value for '%s'" % name)
-
         # Some of this processing should only be done for non raw frames
         if not raw:
             # absolute path takes priority over filename
@@ -293,15 +295,12 @@ class Frame(Interface):
                 else:
                     filename = abs_path
 
-            if not (filename or function or module or package):
-                raise InterfaceValidationError(
-                    "No 'filename' or 'function' or "
-                    "'module' or 'package'"
-                )
+        if not (filename or function or module or package):
+            raise InterfaceValidationError(
+                "No 'filename' or 'function' or 'module' or 'package'"
+            )
 
         platform = data.get('platform')
-        if platform not in VALID_PLATFORMS:
-            platform = None
 
         context_locals = data.get('vars') or {}
         if isinstance(context_locals, (list, tuple)):
@@ -329,10 +328,7 @@ class Frame(Interface):
         else:
             pre_context, post_context = None, None
 
-        try:
-            in_app = validate_bool(data.get('in_app'), False)
-        except AssertionError:
-            raise InterfaceValidationError("Invalid value for 'in_app'")
+        in_app = validate_bool(data.get('in_app'), False)
 
         kwargs = {
             'abs_path': trim(abs_path, 2048),
@@ -648,17 +644,16 @@ class Stacktrace(Interface):
               to the full interface path.
     """
     score = 2000
+    path = 'sentry.interfaces.Stacktrace'
 
     def __iter__(self):
         return iter(self.frames)
 
     @classmethod
     def to_python(cls, data, slim_frames=True, raw=False):
-        if not data.get('frames'):
-            raise InterfaceValidationError("No 'frames' present")
-
-        if not isinstance(data['frames'], list):
-            raise InterfaceValidationError("Invalid value for 'frames'")
+        is_valid, errors = validate_and_default_interface(data, cls.path)
+        if not is_valid:
+            raise InterfaceValidationError("Invalid stack frame data.")
 
         frame_list = [
             # XXX(dcramer): handle PHP sending an empty array for a frame
@@ -674,8 +669,6 @@ class Stacktrace(Interface):
             kwargs['registers'] = data.get('registers')
 
         if data.get('frames_omitted'):
-            if len(data['frames_omitted']) != 2:
-                raise InterfaceValidationError("Invalid value for 'frames_omitted'")
             kwargs['frames_omitted'] = data['frames_omitted']
         else:
             kwargs['frames_omitted'] = None
@@ -721,7 +714,7 @@ class Stacktrace(Interface):
         }
 
     def get_path(self):
-        return 'sentry.interfaces.Stacktrace'
+        return self.path
 
     def compute_hashes(self, platform):
         system_hash = self.get_hash(platform, system_frames=True)
diff --git a/src/sentry/models/eventerror.py b/src/sentry/models/eventerror.py
index 6d44348c5f..b7325aff84 100644
--- a/src/sentry/models/eventerror.py
+++ b/src/sentry/models/eventerror.py
@@ -21,6 +21,7 @@ class dontexplodedict(object):
 class EventError(object):
     INVALID_DATA = 'invalid_data'
     INVALID_ATTRIBUTE = 'invalid_attribute'
+    MISSING_ATTRIBUTE = 'missing_attribute'
     VALUE_TOO_LONG = 'value_too_long'
     UNKNOWN_ERROR = 'unknown_error'
     SECURITY_VIOLATION = 'security_violation'
@@ -57,6 +58,7 @@ class EventError(object):
     _messages = {
         INVALID_DATA: u'Discarded invalid value for parameter \'{name}\'',
         INVALID_ATTRIBUTE: u'Discarded invalid parameter \'{name}\'',
+        MISSING_ATTRIBUTE: u'Missing value for required parameter \'{name}\'',
         VALUE_TOO_LONG: u'Discarded value for \'{name}\' due to exceeding maximum length',
         UNKNOWN_ERROR: u'Unknown error',
         SECURITY_VIOLATION: u'Cannot fetch resource due to security violation on {url}',
diff --git a/src/sentry/utils/json.py b/src/sentry/utils/json.py
index 8be41ce96c..ab54a3c747 100644
--- a/src/sentry/utils/json.py
+++ b/src/sentry/utils/json.py
@@ -37,6 +37,8 @@ def better_default_encoder(o):
         return list(o)
     elif isinstance(o, decimal.Decimal):
         return six.text_type(o)
+    elif callable(o):
+        return '<function>'
     raise TypeError(repr(o) + ' is not JSON serializable')
 
 
diff --git a/src/sentry/web/api.py b/src/sentry/web/api.py
index f3bfcb44c3..9dd89b2ed7 100644
--- a/src/sentry/web/api.py
+++ b/src/sentry/web/api.py
@@ -24,6 +24,7 @@ from sentry.coreapi import (
     APIError, APIForbidden, APIRateLimited, ClientApiHelper, CspApiHelper, LazyData,
     MinidumpApiHelper,
 )
+from sentry.interfaces import schemas
 from sentry.models import Project, OrganizationOption, Organization
 from sentry.signals import (
     event_accepted, event_dropped, event_filtered, event_received)
@@ -578,6 +579,11 @@ class MinidumpView(StoreView):
         )
 
 
+class StoreSchemaView(BaseView):
+    def get(self, request, **kwargs):
+        return HttpResponse(json.dumps(schemas.EVENT_SCHEMA), content_type='application/json')
+
+
 class CspReportView(StoreView):
     helper_cls = CspApiHelper
     content_types = ('application/csp-report', 'application/json')
diff --git a/src/sentry/web/urls.py b/src/sentry/web/urls.py
index 6312ffec5a..e707afcc34 100644
--- a/src/sentry/web/urls.py
+++ b/src/sentry/web/urls.py
@@ -122,6 +122,7 @@ urlpatterns += patterns(
         api.crossdomain_xml,
         name='sentry-api-crossdomain-xml'
     ),
+    url(r'^api/store/schema$', api.StoreSchemaView.as_view(), name='sentry-api-store-schema'),
 
     # The static version is either a 10 digit timestamp, a sha1, or md5 hash
     url(
diff --git a/tests/sentry/coreapi/tests.py b/tests/sentry/coreapi/tests.py
index 5e7f811d8b..83b76b99b6 100644
--- a/tests/sentry/coreapi/tests.py
+++ b/tests/sentry/coreapi/tests.py
@@ -6,7 +6,6 @@ import six
 import mock
 import pytest
 
-from datetime import datetime
 from django.core.exceptions import SuspiciousOperation
 from sentry.constants import VERSION_LENGTH
 from uuid import UUID
@@ -16,12 +15,11 @@ from sentry.coreapi import (
     APIUnauthorized,
     Auth,
     ClientApiHelper,
-    InvalidTimestamp,
-    get_interface,
     CspApiHelper,
     APIForbidden,
-    LazyData,
 )
+from sentry.event_manager import EventManager
+from sentry.interfaces.base import get_interface
 from sentry.testutils import TestCase
 
 
@@ -35,6 +33,10 @@ class BaseAPITest(TestCase):
         self.pk = self.project.key_set.get_or_create()[0]
         self.helper = self.helper_cls(agent='Awesome Browser', ip_address='198.51.100.0')
 
+    def validate_and_normalize(self, data):
+        data = self.helper.validate_data(data)
+        return EventManager(data).normalize()
+
 
 class AuthFromRequestTest(BaseAPITest):
     def test_valid(self):
@@ -123,81 +125,22 @@ class ProjectIdFromAuthTest(BaseAPITest):
         self.assertRaises(APIUnauthorized, self.helper.project_id_from_auth, auth)
 
 
-class ProcessDataTimestampTest(BaseAPITest):
-    def test_iso_timestamp(self):
-        d = datetime(2012, 1, 1, 10, 30, 45)
-        data = self.helper._process_data_timestamp(
-            {
-                'timestamp': '2012-01-01T10:30:45'
-            }, current_datetime=d
-        )
-        self.assertTrue('timestamp' in data)
-        self.assertEquals(data['timestamp'], 1325413845.0)
-
-    def test_iso_timestamp_with_ms(self):
-        d = datetime(2012, 1, 1, 10, 30, 45, 434000)
-        data = self.helper._process_data_timestamp(
-            {
-                'timestamp': '2012-01-01T10:30:45.434'
-            }, current_datetime=d
-        )
-        self.assertTrue('timestamp' in data)
-        self.assertEquals(data['timestamp'], 1325413845.0)
-
-    def test_timestamp_iso_timestamp_with_Z(self):
-        d = datetime(2012, 1, 1, 10, 30, 45)
-        data = self.helper._process_data_timestamp(
-            {
-                'timestamp': '2012-01-01T10:30:45Z'
-            }, current_datetime=d
-        )
-        self.assertTrue('timestamp' in data)
-        self.assertEquals(data['timestamp'], 1325413845.0)
-
-    def test_invalid_timestamp(self):
-        self.assertRaises(
-            InvalidTimestamp, self.helper._process_data_timestamp, {'timestamp': 'foo'}
-        )
-
-    def test_invalid_numeric_timestamp(self):
-        self.assertRaises(
-            InvalidTimestamp, self.helper._process_data_timestamp,
-            {'timestamp': '100000000000000000000.0'}
-        )
-
-    def test_future_timestamp(self):
-        self.assertRaises(
-            InvalidTimestamp, self.helper._process_data_timestamp,
-            {'timestamp': '2052-01-01T10:30:45Z'}
-        )
-
-    def test_long_microseconds_value(self):
-        d = datetime(2012, 1, 1, 10, 30, 45)
-        data = self.helper._process_data_timestamp(
-            {
-                'timestamp': '2012-01-01T10:30:45.341324Z'
-            }, current_datetime=d
-        )
-        self.assertTrue('timestamp' in data)
-        self.assertEquals(data['timestamp'], 1325413845.0)
-
-
 class ValidateDataTest(BaseAPITest):
     @mock.patch('uuid.uuid4', return_value=UUID('031667ea1758441f92c7995a428d2d14'))
     def test_empty_event_id(self, uuid4):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'event_id': '',
         })
         assert data['event_id'] == '031667ea1758441f92c7995a428d2d14'
 
     @mock.patch('uuid.uuid4', return_value=UUID('031667ea1758441f92c7995a428d2d14'))
     def test_missing_event_id(self, uuid4):
-        data = self.helper.validate_data({})
+        data = self.validate_and_normalize({})
         assert data['event_id'] == '031667ea1758441f92c7995a428d2d14'
 
     @mock.patch('uuid.uuid4', return_value=UUID('031667ea1758441f92c7995a428d2d14'))
     def test_invalid_event_id(self, uuid4):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'event_id': 'a' * 33,
         })
         assert data['event_id'] == '031667ea1758441f92c7995a428d2d14'
@@ -206,7 +149,7 @@ class ValidateDataTest(BaseAPITest):
         assert data['errors'][0]['name'] == 'event_id'
         assert data['errors'][0]['value'] == 'a' * 33
 
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'event_id': 'xyz',
         })
         assert data['event_id'] == '031667ea1758441f92c7995a428d2d14'
@@ -215,11 +158,8 @@ class ValidateDataTest(BaseAPITest):
         assert data['errors'][0]['name'] == 'event_id'
         assert data['errors'][0]['value'] == 'xyz'
 
-    def test_invalid_event_id_raises(self):
-        self.assertRaises(APIError, self.helper.validate_data, {'event_id': 1})
-
     def test_unknown_attribute(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'message': 'foo',
             'foo': 'bar',
         })
@@ -229,7 +169,7 @@ class ValidateDataTest(BaseAPITest):
         assert data['errors'][0]['name'] == 'foo'
 
     def test_invalid_interface_name(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'message': 'foo',
             'foo.baz': 'bar',
         })
@@ -239,7 +179,7 @@ class ValidateDataTest(BaseAPITest):
         assert data['errors'][0]['name'] == 'foo.baz'
 
     def test_invalid_interface_import_path(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'message': 'foo',
             'sentry.interfaces.Exception2': 'bar',
         })
@@ -249,28 +189,26 @@ class ValidateDataTest(BaseAPITest):
         assert data['errors'][0]['name'] == 'sentry.interfaces.Exception2'
 
     def test_does_expand_list(self):
-        data = self.helper.validate_data(
-            {
-                'message': 'foo',
-                'exception':
+        data = self.validate_and_normalize({
+            'message': 'foo',
+            'exception':
                 [{
                     'type': 'ValueError',
                     'value': 'hello world',
                     'module': 'foo.bar',
                 }]
-            }
-        )
+        })
         assert 'sentry.interfaces.Exception' in data
 
     def test_log_level_as_string(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'message': 'foo',
             'level': 'error',
         })
         assert data['level'] == 40
 
     def test_invalid_log_level(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'message': 'foo',
             'level': 'foobar',
         })
@@ -281,57 +219,48 @@ class ValidateDataTest(BaseAPITest):
         assert data['errors'][0]['value'] == 'foobar'
 
     def test_tags_as_string(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'message': 'foo',
             'tags': 'bar',
         })
-        assert 'tags' not in data
+        assert data['tags'] == []
 
     def test_tags_with_spaces(self):
-        data = self.helper.validate_data(
-            {
-                'message': 'foo',
-                'tags': {
-                    'foo bar': 'baz bar'
-                },
-            }
-        )
+        data = self.validate_and_normalize({
+            'message': 'foo',
+            'tags': {
+                'foo bar': 'baz bar'
+            },
+        })
         assert data['tags'] == [('foo-bar', 'baz bar')]
 
     def test_tags_out_of_bounds(self):
-        data = self.helper.validate_data(
-            {
-                'message': 'foo',
-                'tags': {
-                    'f' * 33: 'value',
-                    'foo': 'v' * 201,
-                    'bar': 'value'
-                },
-            }
-        )
+        data = self.validate_and_normalize({
+            'message': 'foo',
+            'tags': {
+                'f' * 33: 'value',
+                'foo': 'v' * 201,
+                'bar': 'value'
+            },
+        })
         assert data['tags'] == [('bar', 'value')]
         assert len(data['errors']) == 2
 
     def test_tags_as_invalid_pair(self):
-        data = self.helper.validate_data(
-            {
-                'message': 'foo',
-                'tags': [('foo', 'bar'), ('biz', 'baz', 'boz')],
-            }
-        )
-        assert data['tags'] == [('foo', 'bar')]
+        data = self.validate_and_normalize({
+            'message': 'foo',
+            'tags': [('foo', 'bar'), ('biz', 'baz', 'boz')],
+        })
         assert len(data['errors']) == 1
         assert data['errors'][0]['type'] == 'invalid_data'
         assert data['errors'][0]['name'] == 'tags'
-        assert data['errors'][0]['value'] == ('biz', 'baz', 'boz')
+        assert data['errors'][0]['value'] == [('foo', 'bar'), ('biz', 'baz', 'boz')]
 
     def test_reserved_tags(self):
-        data = self.helper.validate_data(
-            {
-                'message': 'foo',
-                'tags': [('foo', 'bar'), ('release', 'abc123')],
-            }
-        )
+        data = self.validate_and_normalize({
+            'message': 'foo',
+            'tags': [('foo', 'bar'), ('release', 'abc123')],
+        })
         assert data['tags'] == [('foo', 'bar')]
         assert len(data['errors']) == 1
         assert data['errors'][0]['type'] == 'invalid_data'
@@ -339,30 +268,25 @@ class ValidateDataTest(BaseAPITest):
         assert data['errors'][0]['value'] == ('release', 'abc123')
 
     def test_tag_value(self):
-        data = self.helper.validate_data(
-            {
-                'message': 'foo',
-                'tags': [('foo', 'bar\n'), ('biz', 'baz')],
-            }
-        )
+        data = self.validate_and_normalize({
+            'message': 'foo',
+            'tags': [('foo', 'b\nar'), ('biz', 'baz')],
+        })
         assert data['tags'] == [('biz', 'baz')]
         assert len(data['errors']) == 1
         assert data['errors'][0]['type'] == 'invalid_data'
         assert data['errors'][0]['name'] == 'tags'
-        assert data['errors'][0]['value'] == ('foo', 'bar\n')
+        assert data['errors'][0]['value'] == ('foo', 'b\nar')
 
     def test_extra_as_string(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'message': 'foo',
             'extra': 'bar',
         })
-        assert 'extra' not in data
-
-    def test_invalid_culprit_raises(self):
-        self.assertRaises(APIError, self.helper.validate_data, {'culprit': 1})
+        assert data['extra'] == {}
 
     def test_release_too_long(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'release': 'a' * (VERSION_LENGTH + 1),
         })
         assert not data.get('release')
@@ -372,13 +296,13 @@ class ValidateDataTest(BaseAPITest):
         assert data['errors'][0]['value'] == 'a' * (VERSION_LENGTH + 1)
 
     def test_release_as_non_string(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'release': 42,
         })
         assert data.get('release') == '42'
 
     def test_distribution_too_long(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'release': 'a' * 62,
             'dist': 'b' * 65,
         })
@@ -389,7 +313,7 @@ class ValidateDataTest(BaseAPITest):
         assert data['errors'][0]['value'] == 'b' * 65
 
     def test_distribution_bad_char(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'release': 'a' * 62,
             'dist': '^%',
         })
@@ -400,14 +324,14 @@ class ValidateDataTest(BaseAPITest):
         assert data['errors'][0]['value'] == '^%'
 
     def test_distribution_strip(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'release': 'a' * 62,
             'dist': ' foo ',
         })
         assert data.get('dist') == 'foo'
 
     def test_distribution_as_non_string(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'release': '42',
             'dist': 23,
         })
@@ -415,29 +339,29 @@ class ValidateDataTest(BaseAPITest):
         assert data.get('dist') == '23'
 
     def test_distribution_no_release(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'dist': 23,
         })
         assert data.get('dist') is None
 
     def test_valid_platform(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'platform': 'python',
         })
         assert data.get('platform') == 'python'
 
     def test_no_platform(self):
-        data = self.helper.validate_data({})
+        data = self.validate_and_normalize({})
         assert data.get('platform') == 'other'
 
     def test_invalid_platform(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'platform': 'foobar',
         })
         assert data.get('platform') == 'other'
 
     def test_environment_too_long(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'environment': 'a' * 65,
         })
         assert not data.get('environment')
@@ -447,13 +371,13 @@ class ValidateDataTest(BaseAPITest):
         assert data['errors'][0]['value'] == 'a' * 65
 
     def test_environment_as_non_string(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'environment': 42,
         })
         assert data.get('environment') == '42'
 
     def test_time_spent_too_large(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'time_spent': 2147483647 + 1,
         })
         assert not data.get('time_spent')
@@ -463,7 +387,7 @@ class ValidateDataTest(BaseAPITest):
         assert data['errors'][0]['value'] == 2147483647 + 1
 
     def test_time_spent_invalid(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'time_spent': 'lol',
         })
         assert not data.get('time_spent')
@@ -473,27 +397,27 @@ class ValidateDataTest(BaseAPITest):
         assert data['errors'][0]['value'] == 'lol'
 
     def test_time_spent_non_int(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'time_spent': '123',
         })
         assert data['time_spent'] == 123
 
     def test_fingerprints(self):
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'fingerprint': '2012-01-01T10:30:45',
         })
         assert not data.get('fingerprint')
         assert data['errors'][0]['type'] == 'invalid_data'
         assert data['errors'][0]['name'] == 'fingerprint'
 
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'fingerprint': ['foo', ['bar']],
         })
         assert not data.get('fingerprint')
         assert data['errors'][0]['type'] == 'invalid_data'
         assert data['errors'][0]['name'] == 'fingerprint'
 
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'fingerprint': ['{{default}}', 1, 'bar', 4.5],
         })
         assert data.get('fingerprint') == ['{{default}}', '1', 'bar', '4.5']
@@ -501,7 +425,7 @@ class ValidateDataTest(BaseAPITest):
 
     def test_messages(self):
         # Just 'message': wrap it in interface
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'message': 'foo is bar',
         })
         assert 'message' not in data
@@ -509,7 +433,7 @@ class ValidateDataTest(BaseAPITest):
 
         # both 'message' and interface with no 'formatted' value, put 'message'
         # into 'formatted'.
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'message': 'foo is bar',
             'sentry.interfaces.Message': {
                 'message': 'something else',
@@ -522,7 +446,7 @@ class ValidateDataTest(BaseAPITest):
         }
 
         # both 'message' and complete interface, 'message' is discarded
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'message': 'foo is bar',
             'sentry.interfaces.Message': {
                 'message': 'something else',
@@ -536,11 +460,12 @@ class ValidateDataTest(BaseAPITest):
             'formatted': 'something else formatted'
         }
 
+    @pytest.mark.skip(reason="Message behavior that didn't make a lot of sense.")
     def test_messages_old_behavior(self):
         # both 'message' and complete valid interface but interface has the same
         # value for both keys so the 'formatted' value is discarded and ends up
         # being replaced with 'message'
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'message': 'foo is bar',
             'sentry.interfaces.Message': {
                 'message': 'something else',
@@ -556,7 +481,7 @@ class ValidateDataTest(BaseAPITest):
 
         # interface discarded as invalid, replaced by new interface containing
         # wrapped 'message'
-        data = self.helper.validate_data({
+        data = self.validate_and_normalize({
             'message': 'foo is bar',
             'sentry.interfaces.Message': {
                 'invalid': 'invalid',
@@ -568,12 +493,6 @@ class ValidateDataTest(BaseAPITest):
             'message': 'foo is bar'
         }
 
-    def test_does_not_strip_key_id(self):
-        data = self.helper.validate_data({
-            'key_id': 12345,
-        })
-        assert data['key_id'] == 12345
-
 
 class SafelyLoadJSONStringTest(BaseAPITest):
     def test_valid_payload(self):
@@ -710,29 +629,27 @@ class CspApiHelperTest(BaseAPITest):
                 "release": "abc123",
             }
         }
-        result = self.helper.validate_data(report)
+        result = self.validate_and_normalize(report)
         assert result['logger'] == 'csp'
         assert result['release'] == 'abc123'
         assert result['errors'] == []
-        assert 'message' in result
+        assert 'sentry.interfaces.Message' in result
         assert 'culprit' in result
         assert result['tags'] == [
             ('effective-directive', 'img-src'),
             ('blocked-uri', 'http://google.com'),
         ]
         assert result['sentry.interfaces.User'] == {'ip_address': '198.51.100.0'}
-        assert result['sentry.interfaces.Http'] == {
-            'url': 'http://45.55.25.245:8123/csp',
-            'headers': {
-                'User-Agent': 'Awesome Browser',
-                'Referer': 'http://example.com'
-            }
+        assert result['sentry.interfaces.Http']['url'] == 'http://45.55.25.245:8123/csp'
+        assert dict(result['sentry.interfaces.Http']['headers']) == {
+            'User-Agent': 'Awesome Browser',
+            'Referer': 'http://example.com'
         }
 
     @mock.patch('sentry.interfaces.csp.Csp.to_python', mock.Mock(side_effect=Exception))
     def test_validate_raises_invalid_interface(self):
         with self.assertRaises(APIForbidden):
-            self.helper.validate_data({})
+            self.validate_and_normalize({})
 
     def test_tags_out_of_bounds(self):
         report = {
@@ -754,7 +671,7 @@ class CspApiHelperTest(BaseAPITest):
                 "release": "abc123",
             }
         }
-        result = self.helper.validate_data(report)
+        result = self.validate_and_normalize(report)
         assert result['tags'] == [
             ('effective-directive', 'img-src'),
         ]
@@ -773,18 +690,19 @@ class CspApiHelperTest(BaseAPITest):
             "original-policy":
             "default-src  https://45.55.25.245:8123/; child-src  https://45.55.25.245:8123/; connect-src  https://45.55.25.245:8123/; font-src  https://45.55.25.245:8123/; img-src  https://45.55.25.245:8123/; media-src  https://45.55.25.245:8123/; object-src  https://45.55.25.245:8123/; script-src  https://45.55.25.245:8123/; style-src  https://45.55.25.245:8123/; form-action  https://45.55.25.245:8123/; frame-ancestors 'none'; plugin-types 'none'; report-uri http://45.55.25.245:8123/csp-report?os=OS%20X&device=&browser_version=43.0&browser=chrome&os_version=Lion",
             "blocked-uri":
-            "http://google.com\n",
+            "http://google.com",
             "status-code":
             200,
             "_meta": {
                 "release": "abc123",
             }
         }
-        result = self.helper.validate_data(report)
+        result = self.validate_and_normalize(report)
         assert result['tags'] == [
             ('effective-directive', 'img-src'),
+            ('blocked-uri', 'http://google.com'),
         ]
-        assert len(result['errors']) == 1
+        assert len(result['errors']) == 0
 
     def test_no_tags(self):
         report = {
@@ -799,39 +717,13 @@ class CspApiHelperTest(BaseAPITest):
             "original-policy":
             "default-src  https://45.55.25.245:8123/; child-src  https://45.55.25.245:8123/; connect-src  https://45.55.25.245:8123/; font-src  https://45.55.25.245:8123/; img-src  https://45.55.25.245:8123/; media-src  https://45.55.25.245:8123/; object-src  https://45.55.25.245:8123/; script-src  https://45.55.25.245:8123/; style-src  https://45.55.25.245:8123/; form-action  https://45.55.25.245:8123/; frame-ancestors 'none'; plugin-types 'none'; report-uri http://45.55.25.245:8123/csp-report?os=OS%20X&device=&browser_version=43.0&browser=chrome&os_version=Lion",
             "blocked-uri":
-            "http://google.com\n",
+            "http://goo\ngle.com",
             "status-code":
             200,
             "_meta": {
                 "release": "abc123",
             }
         }
-        result = self.helper.validate_data(report)
-        assert 'tags' not in result
+        result = self.validate_and_normalize(report)
+        assert result['tags'] == []
         assert len(result['errors']) == 2
-
-
-class LazyDataTest(BaseAPITest):
-    def test_missing_project_id(self):
-        data = LazyData(
-            data={'message': 'foo'},
-            content_encoding='',
-            helper=self.helper,
-            project=self.project,
-            key=self.pk,
-            auth=mock.MagicMock(),
-            client_ip='',
-        )
-        assert data['project'] == self.project.id
-
-    def test_missing_key_id(self):
-        data = LazyData(
-            data={'message': 'foo'},
-            content_encoding='',
-            helper=self.helper,
-            project=self.project,
-            key=self.pk,
-            auth=mock.MagicMock(),
-            client_ip='',
-        )
-        assert data['key_id'] == self.pk.id
diff --git a/tests/sentry/interfaces/test_csp.py b/tests/sentry/interfaces/test_csp.py
index 55f4dbd304..c5c0873535 100644
--- a/tests/sentry/interfaces/test_csp.py
+++ b/tests/sentry/interfaces/test_csp.py
@@ -144,9 +144,9 @@ class CspTest(TestCase):
         assert result.get_hash() == ['img-src', 'ftp://example.com']
 
     def test_get_tags(self):
-        assert self.interface.get_tags() == (
+        assert self.interface.get_tags() == [
             ('effective-directive', 'style-src'), ('blocked-uri', 'http://example.com/lol.css'),
-        )
+        ]
 
     def test_get_tags_stripe(self):
         result = Csp.to_python(
@@ -155,10 +155,10 @@ class CspTest(TestCase):
                 effective_directive='script-src',
             )
         )
-        assert result.get_tags() == (
+        assert result.get_tags() == [
             ('effective-directive', 'script-src'),
             ('blocked-uri', 'https://api.stripe.com/v1/tokens'),
-        )
+        ]
 
     def test_get_message(self):
         result = Csp.to_python(
diff --git a/tests/sentry/test_event_manager.py b/tests/sentry/test_event_manager.py
index 8a4ce96aba..e332c91b0a 100644
--- a/tests/sentry/test_event_manager.py
+++ b/tests/sentry/test_event_manager.py
@@ -6,7 +6,7 @@ import logging
 import mock
 import pytest
 
-from datetime import timedelta
+from datetime import datetime, timedelta
 from django.conf import settings
 from django.utils import timezone
 from time import time
@@ -14,12 +14,13 @@ from time import time
 from sentry.app import tsdb
 from sentry.constants import MAX_CULPRIT_LENGTH, DEFAULT_LOGGER_NAME, VERSION_LENGTH
 from sentry.event_manager import (
-    HashDiscarded, EventManager, EventUser, get_hashes_for_event, get_hashes_from_fingerprint,
-    generate_culprit, md5_from_hash
+    HashDiscarded, EventManager, EventUser, InvalidTimestamp,
+    get_hashes_for_event, get_hashes_from_fingerprint, generate_culprit,
+    md5_from_hash, process_data_timestamp
 )
 from sentry.models import (
-    Activity, Environment, Event, Group, GroupHash, GroupRelease, GroupResolution, GroupStatus, GroupTombstone,
-    EventMapping, Release
+    Activity, Environment, Event, Group, GroupHash, GroupRelease, GroupResolution,
+    GroupStatus, GroupTombstone, EventMapping, Release
 )
 from sentry.signals import event_discarded, event_saved
 from sentry.testutils import assert_mock_called_once_with_partial, TestCase, TransactionTestCase
@@ -996,6 +997,65 @@ class EventManagerTest(TransactionTestCase):
         )
 
 
+class ProcessDataTimestampTest(TestCase):
+    def test_iso_timestamp(self):
+        d = datetime(2012, 1, 1, 10, 30, 45)
+        data = process_data_timestamp(
+            {
+                'timestamp': '2012-01-01T10:30:45'
+            }, current_datetime=d
+        )
+        self.assertTrue('timestamp' in data)
+        self.assertEquals(data['timestamp'], 1325413845.0)
+
+    def test_iso_timestamp_with_ms(self):
+        d = datetime(2012, 1, 1, 10, 30, 45, 434000)
+        data = process_data_timestamp(
+            {
+                'timestamp': '2012-01-01T10:30:45.434'
+            }, current_datetime=d
+        )
+        self.assertTrue('timestamp' in data)
+        self.assertEquals(data['timestamp'], 1325413845.0)
+
+    def test_timestamp_iso_timestamp_with_Z(self):
+        d = datetime(2012, 1, 1, 10, 30, 45)
+        data = process_data_timestamp(
+            {
+                'timestamp': '2012-01-01T10:30:45Z'
+            }, current_datetime=d
+        )
+        self.assertTrue('timestamp' in data)
+        self.assertEquals(data['timestamp'], 1325413845.0)
+
+    def test_invalid_timestamp(self):
+        self.assertRaises(
+            InvalidTimestamp, process_data_timestamp, {'timestamp': 'foo'}
+        )
+
+    def test_invalid_numeric_timestamp(self):
+        self.assertRaises(
+            InvalidTimestamp, process_data_timestamp,
+            {'timestamp': '100000000000000000000.0'}
+        )
+
+    def test_future_timestamp(self):
+        self.assertRaises(
+            InvalidTimestamp, process_data_timestamp,
+            {'timestamp': '2052-01-01T10:30:45Z'}
+        )
+
+    def test_long_microseconds_value(self):
+        d = datetime(2012, 1, 1, 10, 30, 45)
+        data = process_data_timestamp(
+            {
+                'timestamp': '2012-01-01T10:30:45.341324Z'
+            }, current_datetime=d
+        )
+        self.assertTrue('timestamp' in data)
+        self.assertEquals(data['timestamp'], 1325413845.0)
+
+
 class GetHashesFromEventTest(TestCase):
     @mock.patch('sentry.interfaces.stacktrace.Stacktrace.compute_hashes')
     @mock.patch('sentry.interfaces.http.Http.compute_hashes')

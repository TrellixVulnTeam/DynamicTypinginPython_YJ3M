commit c4a9ecbcdcbf612ae5a705120e9eb63e42583cda
Author: Armin Ronacher <armin.ronacher@active-4.com>
Date:   Fri Jan 27 13:59:37 2017 +0100

    Backed out changes to the main event manager

diff --git a/src/sentry/api/serializers/models/group.py b/src/sentry/api/serializers/models/group.py
index ee1eda7c02..4697226140 100644
--- a/src/sentry/api/serializers/models/group.py
+++ b/src/sentry/api/serializers/models/group.py
@@ -167,7 +167,6 @@ class GroupSerializer(Serializer):
     def serialize(self, obj, attrs, user):
         status = obj.status
         status_details = {}
-
         if attrs['ignore_duration']:
             if attrs['ignore_duration'] < timezone.now() and status == GroupStatus.IGNORED:
                 status = GroupStatus.UNRESOLVED
diff --git a/src/sentry/event_manager.py b/src/sentry/event_manager.py
index 517e3cbaa5..ef9fdae6c9 100644
--- a/src/sentry/event_manager.py
+++ b/src/sentry/event_manager.py
@@ -44,24 +44,6 @@ from sentry.utils.strings import truncatechars
 from sentry.utils.validators import validate_ip
 
 
-NON_STORED_DATA_KEYS = [
-    'event_id',
-    'level',
-    'culprit',
-    'logger',
-    'server_name',
-    'site',
-    'checksum',
-    'fingerprint',
-    'platform',
-    'release',
-    'environment',
-    'message',
-    'time_spent',
-    'timestamp',
-]
-
-
 def count_limit(count):
     # TODO: could we do something like num_to_store = max(math.sqrt(100*count)+59, 200) ?
     # ~ 150 * ((log(n) - 1.5) ^ 2 - 0.25)
@@ -416,32 +398,27 @@ class EventManager(object):
         from sentry.tasks.post_process import index_event_tags
 
         project = Project.objects.get_from_cache(id=project)
-        assert project is not None, 'did not get a project. this is bad'
 
         data = self.data.copy()
 
         # First we pull out our top-level (non-data attr) kwargs
-        event_id = data.get('event_id')
-        level = data.get('level')
-
-        culprit = data.get('culprit', None)
-        logger_name = data.get('logger', None)
-        server_name = data.get('server_name', None)
-        site = data.get('site', None)
-        checksum = data.get('checksum', None)
-        fingerprint = data.get('fingerprint', None)
-        platform = data.get('platform', None)
-        release = data.get('release', None)
-        environment = data.get('environment', None)
-        message = data.get('message', '')
-        time_spent = data.get('time_spent', None)
-
-        date = datetime.fromtimestamp(data.get('timestamp'))
-        date = date.replace(tzinfo=timezone.utc)
+        event_id = data.pop('event_id')
+        level = data.pop('level')
+
+        culprit = data.pop('culprit', None)
+        logger_name = data.pop('logger', None)
+        server_name = data.pop('server_name', None)
+        site = data.pop('site', None)
+        checksum = data.pop('checksum', None)
+        fingerprint = data.pop('fingerprint', None)
+        platform = data.pop('platform', None)
+        release = data.pop('release', None)
+        environment = data.pop('environment', None)
+
+        # unused
+        time_spent = data.pop('time_spent', None)
+        message = data.pop('message', '')
 
-        # Some processing for when things went well
-        for key in NON_STORED_DATA_KEYS:
-            data.pop(key, None)
         if not culprit:
             # if we generate an implicit culprit, lets not call it a
             # transaction
@@ -450,6 +427,9 @@ class EventManager(object):
         else:
             transaction_name = culprit
 
+        date = datetime.fromtimestamp(data.pop('timestamp'))
+        date = date.replace(tzinfo=timezone.utc)
+
         kwargs = {
             'platform': platform,
         }
@@ -505,6 +485,7 @@ class EventManager(object):
         # XXX(dcramer): we're relying on mutation of the data object to ensure
         # this propagates into Event
         data['tags'] = tags
+
         data['fingerprint'] = fingerprint or ['{{ default }}']
 
         for path, iface in six.iteritems(event.interfaces):
@@ -513,6 +494,22 @@ class EventManager(object):
             if iface.ephemeral:
                 data.pop(iface.get_path(), None)
 
+        # prioritize fingerprint over checksum as its likely the client defaulted
+        # a checksum whereas the fingerprint was explicit
+        if fingerprint:
+            hashes = [
+                md5_from_hash(h)
+                for h in get_hashes_from_fingerprint(event, fingerprint)
+            ]
+        elif checksum:
+            hashes = [checksum]
+            data['checksum'] = checksum
+        else:
+            hashes = [
+                md5_from_hash(h)
+                for h in get_hashes_for_event(event)
+            ]
+
         # TODO(dcramer): temp workaround for complexity
         data['message'] = message
         event_type = eventtypes.get(data.get('type', 'default'))(data)
@@ -533,22 +530,6 @@ class EventManager(object):
                     data['sentry.interfaces.Message']['message'],
                 )
 
-        # prioritize fingerprint over checksum as its likely the client defaulted
-        # a checksum whereas the fingerprint was explicit
-        if fingerprint:
-            hashes = [
-                md5_from_hash(h)
-                for h in get_hashes_from_fingerprint(event, fingerprint)
-            ]
-        elif checksum:
-            hashes = [checksum]
-            data['checksum'] = checksum
-        else:
-            hashes = [
-                md5_from_hash(h)
-                for h in get_hashes_for_event(event)
-            ]
-
         if not message:
             message = ''
         elif not isinstance(message, six.string_types):
@@ -901,8 +882,6 @@ class EventManager(object):
         if not plugin_is_regression(group, event):
             return
 
-        group_status = GroupStatus.UNRESOLVED
-
         # we now think its a regression, rely on the database to validate that
         # no one beat us to this
         date = max(event.datetime, group.last_seen)
@@ -919,11 +898,11 @@ class EventManager(object):
             # explicitly set last_seen here as ``is_resolved()`` looks
             # at the value
             last_seen=date,
-            status=group_status
+            status=GroupStatus.UNRESOLVED
         ))
 
         group.active_at = date
-        group.status = group_status
+        group.status = GroupStatus.UNRESOLVED
 
         if is_regression and release:
             # resolutions are only valid if the state of the group is still

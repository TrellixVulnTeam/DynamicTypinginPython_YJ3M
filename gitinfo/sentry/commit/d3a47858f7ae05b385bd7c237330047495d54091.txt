commit d3a47858f7ae05b385bd7c237330047495d54091
Author: David Cramer <dcramer@gmail.com>
Date:   Fri Feb 27 11:13:44 2015 -0800

    Initial work on offline SSO validation

diff --git a/src/sentry/auth/exceptions.py b/src/sentry/auth/exceptions.py
index 4a751dc41f..3393dcc21c 100644
--- a/src/sentry/auth/exceptions.py
+++ b/src/sentry/auth/exceptions.py
@@ -5,3 +5,7 @@ __all__ = ['ProviderNotRegistered']
 
 class ProviderNotRegistered(Exception):
     pass
+
+
+class IdentityNotValid(Exception):
+    pass
diff --git a/src/sentry/auth/provider.py b/src/sentry/auth/provider.py
index 942b5f5dbf..745c95be71 100644
--- a/src/sentry/auth/provider.py
+++ b/src/sentry/auth/provider.py
@@ -59,3 +59,14 @@ class Provider(object):
         The ``email`` and ``id`` keys are required, ``name`` is optional.
         """
         raise NotImplementedError
+
+    def refresh_identity(self, auth_identity):
+        """
+        Updates the AuthIdentity with any changes from upstream. The primary
+        example of a change would be signalling this identity is no longer
+        valid.
+
+        If the identity is no longer valid an ``IdentityNotValid`` error should
+        be raised.
+        """
+        raise NotImplementedError
diff --git a/src/sentry/auth/providers/dummy.py b/src/sentry/auth/providers/dummy.py
index e82f740c60..15a84e5abf 100644
--- a/src/sentry/auth/providers/dummy.py
+++ b/src/sentry/auth/providers/dummy.py
@@ -22,3 +22,6 @@ class DummyProvider(Provider):
 
     def build_identity(self, state):
         return state['email']
+
+    def refresh_identity(self, auth_identity):
+        pass
diff --git a/src/sentry/auth/providers/oauth2.py b/src/sentry/auth/providers/oauth2.py
index 7f0b497b7a..6db14a1553 100644
--- a/src/sentry/auth/providers/oauth2.py
+++ b/src/sentry/auth/providers/oauth2.py
@@ -2,10 +2,12 @@ from __future__ import absolute_import, print_function
 
 import logging
 
+from time import time
 from urllib import urlencode
 from uuid import uuid4
 
 from sentry.auth import Provider, AuthView
+from sentry.auth.exceptions import IdentityNotValid
 from sentry.http import safe_urlopen, safe_urlread
 from sentry.utils import json
 from sentry.utils.http import absolute_uri
@@ -53,7 +55,6 @@ class OAuth2Login(AuthView):
             state=state,
             redirect_uri=absolute_uri(helper.get_redirect_url()),
         )
-
         redirect_uri = '{}?{}'.format(
             self.get_authorize_url(), urlencode(params)
         )
@@ -129,3 +130,73 @@ class OAuth2Callback(AuthView):
 class OAuth2Provider(Provider):
     def get_auth_pipeline(self):
         return [OAuth2Login(), OAuth2Callback()]
+
+    def get_refresh_token_url(self):
+        raise NotImplementedError
+
+    def get_refresh_token_params(self, refresh_token):
+        return {
+            "client_id": self.client_id,
+            "client_secret": self.client_secret,
+            "grant_type": "refresh_token",
+            "refresh_token": refresh_token,
+        }
+
+    def get_oauth_data(self, payload):
+        return {
+            'access_token': payload['access_token'],
+            'refresh_token': payload.get('refresh_token'),
+            'token_type': payload['token_type'],
+            'expires': time() + payload['expires_in'],
+        }
+
+    def build_identity(self, state):
+        # data = state['data']
+        # return {
+        #     'id': '',
+        #     'email': '',
+        #     'name': '',
+        #     'data': self.get_oauth_data(data),
+        # }
+        raise NotImplementedError
+
+    def refresh_identity(self, auth_identity):
+        refresh_token = auth_identity.data.get('refresh_token')
+
+        if not refresh_token:
+            raise IdentityNotValid
+
+        data = self.get_refresh_token_params(
+            refresh_token=refresh_token,
+        )
+        req = safe_urlopen(self.get_refresh_token_url(), data=data)
+
+        try:
+            body = safe_urlread(req)
+            payload = json.loads(body)
+        except Exception:
+            payload = {}
+
+        error = payload.get('error', 'unknown_error')
+        error_description = payload.get('error_description', 'no description available')
+
+        formatted_error = 'HTTP {} ({}): {}'.format(
+            req.status_code, error, error_description
+        )
+
+        if req.status_code == 401:
+            raise IdentityNotValid(formatted_error)
+
+        if req.status_code == 400:
+            # this may not be common, but at the very least Google will return
+            # an invalid grant when a user is suspended
+            if error == 'invalid_grant':
+                raise IdentityNotValid(formatted_error)
+
+        if req.status_code != 200:
+            raise Exception(formatted_error)
+
+        auth_identity.data = self.build_oauth_data(payload)
+        auth_identity.update(data=auth_identity.data)
+
+        return True
diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index 162ee7f867..628d904829 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -370,6 +370,7 @@ CELERY_CREATE_MISSING_QUEUES = True
 CELERY_IMPORTS = (
     'sentry.tasks.beacon',
     'sentry.tasks.check_alerts',
+    'sentry.tasks.check_auth',
     'sentry.tasks.cleanup',
     'sentry.tasks.deletion',
     'sentry.tasks.email',
@@ -383,6 +384,7 @@ CELERY_IMPORTS = (
 CELERY_QUEUES = [
     Queue('default', routing_key='default'),
     Queue('alerts', routing_key='alerts'),
+    Queue('auth', routing_key='auth'),
     Queue('cleanup', routing_key='cleanup'),
     Queue('sourcemaps', routing_key='sourcemaps'),
     Queue('search', routing_key='search'),
@@ -408,6 +410,14 @@ create_partitioned_queues('triggers')
 
 
 CELERYBEAT_SCHEDULE = {
+    'check-auth': {
+        'task': 'sentry.tasks.check_auth',
+        'schedule': timedelta(minutes=1),
+        'options': {
+            'expires': 60,
+            'queue': 'auth',
+        }
+    },
     'check-alerts': {
         'task': 'sentry.tasks.check_alerts',
         'schedule': timedelta(minutes=1),
diff --git a/src/sentry/models/organizationmember.py b/src/sentry/models/organizationmember.py
index 3c9db288fb..5f9ef50df8 100644
--- a/src/sentry/models/organizationmember.py
+++ b/src/sentry/models/organizationmember.py
@@ -53,6 +53,7 @@ class OrganizationMember(Model):
     ), default=OrganizationMemberType.MEMBER)
     flags = BitField(flags=(
         ('sso:linked', 'sso:linked'),
+        ('sso:invalid', 'sso:invalid'),
     ), default=0)
     date_added = models.DateTimeField(default=timezone.now)
     has_global_access = models.BooleanField(default=True)
diff --git a/src/sentry/tasks/check_auth.py b/src/sentry/tasks/check_auth.py
new file mode 100644
index 0000000000..283cdcb044
--- /dev/null
+++ b/src/sentry/tasks/check_auth.py
@@ -0,0 +1,88 @@
+"""
+sentry.tasks.check_alerts
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import absolute_import, division
+
+import logging
+
+from datetime import timedelta
+from django.utils import timezone
+
+from sentry.auth.exceptions import IdentityNotValid
+from sentry.models import AuthIdentity, OrganizationMember
+from sentry.tasks.base import instrumented_task
+
+
+logger = logging.getLogger('auth')
+
+AUTH_CHECK_INTERVAL = 3600
+
+
+@instrumented_task(name='sentry.tasks.check_auth', queue='auth')
+def check_auth(**kwargs):
+    """
+    Iterates over all accounts which have not been verified in the required
+    interval and creates a new job to verify them.
+    """
+    # TODO(dcramer): we should remove identities if they've been inactivate
+    # for a reasonable interval
+    now = timezone.now()
+    cutoff = now - timedelta(seconds=AUTH_CHECK_INTERVAL)
+    identity_list = list(AuthIdentity.objects.filter(
+        last_verified__lte=cutoff,
+    ))
+    AuthIdentity.objects.filter(
+        id__in=[i.id for i in identity_list],
+    ).update(last_verified=now)
+    for identity in identity_list:
+        check_auth_identity.apply_async(
+            kwargs={'auth_identity_id': identity.id},
+            expires=AUTH_CHECK_INTERVAL,
+        )
+
+
+@instrumented_task(name='sentry.tasks.check_auth_identity', queue='auth')
+def check_auth_identity(auth_identity_id, **kwargs):
+    try:
+        auth_identity = AuthIdentity.objects.get(id=auth_identity_id)
+    except AuthIdentity.DoesNotExist:
+        logger.warning('AuthIdentity(id=%s) does not exist', auth_identity_id)
+        return
+
+    auth_provider = auth_identity.auth_provider
+    provider = auth_provider.get_provider()
+    try:
+        provider.refresh_identity(auth_identity)
+    except IdentityNotValid:
+        is_linked = False
+        is_valid = False
+    except Exception:
+        # to ensure security we count any kind of error as an invalidation
+        # event
+        logger.exception('AuthIdentity(id=%s) returned an error during validation', auth_identity_id)
+        is_linked = True
+        is_valid = False
+    else:
+        is_linked = True
+        is_valid = True
+
+    try:
+        om = OrganizationMember.objects.get(
+            user=auth_identity.user,
+            organization=auth_provider.organization_id,
+        )
+    except OrganizationMember.DoesNotExist:
+        logger.warning('Removing invalid AuthIdentity(id=%s) due to no organization access', auth_identity_id)
+        auth_identity.delete()
+        return
+
+    setattr(om.flags, 'sso:linked', is_linked)
+    setattr(om.flags, 'sso:invalid', not is_valid)
+    om.update(flags=om.flags)
+
+    auth_identity.update(last_verified=timezone.now())
diff --git a/tests/sentry/auth/providers/test_oauth2.py b/tests/sentry/auth/providers/test_oauth2.py
new file mode 100644
index 0000000000..ece182cb99
--- /dev/null
+++ b/tests/sentry/auth/providers/test_oauth2.py
@@ -0,0 +1,38 @@
+from __future__ import absolute_import, print_function
+
+import pytest
+
+from sentry.auth.exceptions import IdentityNotValid
+from sentry.auth.providers.oauth2 import OAuth2Provider
+from sentry.models import AuthIdentity, AuthProvider
+from sentry.testutils import TestCase
+
+
+class OAuth2ProviderTest(TestCase):
+    def setUp(self):
+        self.org = self.create_organization(owner=self.user)
+        self.user = self.create_user('foo@example.com')
+        self.auth_provider = AuthProvider.objects.create(
+            provider='oauth2',
+            organization=self.org,
+        )
+        self.provider = self.get_provider()
+        super(OAuth2ProviderTest, self).setUp()
+
+    def get_provider(self):
+        self.provider = OAuth2Provider(
+            key=self.auth_provider.provider
+        )
+
+    def test_refresh_identity_without_refresh_token(self):
+        auth_identity = AuthIdentity.objects.create(
+            auth_provider=self.auth_provider,
+            user=self.user,
+            data={
+                'access_token': 'access_token',
+            }
+        )
+
+        provider = OAuth2Provider(key=self.auth_provider.provider)
+        with pytest.raises(IdentityNotValid):
+            provider.refresh_identity(auth_identity)
diff --git a/tests/sentry/tasks/test_check_auth.py b/tests/sentry/tasks/test_check_auth.py
new file mode 100644
index 0000000000..d0cf1f88b9
--- /dev/null
+++ b/tests/sentry/tasks/test_check_auth.py
@@ -0,0 +1,81 @@
+from __future__ import absolute_import, print_function
+
+from datetime import timedelta
+from django.utils import timezone
+from mock import patch
+
+from sentry.auth.exceptions import IdentityNotValid
+from sentry.auth.providers.dummy import DummyProvider
+from sentry.models import AuthIdentity, AuthProvider, OrganizationMember
+from sentry.testutils import TestCase
+from sentry.tasks.check_auth import (
+    AUTH_CHECK_INTERVAL, check_auth, check_auth_identity
+)
+
+
+class CheckAuthTest(TestCase):
+    @patch('sentry.tasks.check_auth.check_auth_identity')
+    def test_simple(self, mock_check_auth_identity):
+        organization = self.create_organization(name='Test')
+        user = self.create_user(email='bar@example.com')
+        auth_provider = AuthProvider.objects.create(
+            organization=organization,
+            provider='dummy',
+        )
+        om = OrganizationMember.objects.create(
+            user=user,
+            organization=organization,
+            flags=getattr(OrganizationMember.flags, 'sso:linked'),
+        )
+
+        ai = AuthIdentity.objects.create(
+            auth_provider=auth_provider,
+            user=user,
+            last_verified=timezone.now() - timedelta(days=1),
+        )
+
+        check_auth()
+
+        updated_ai = AuthIdentity.objects.get(id=ai.id)
+        assert updated_ai.last_verified != ai.last_verified
+
+        mock_check_auth_identity.apply_async.assert_called_once_with(
+            kwargs={'auth_identity_id': ai.id},
+            expires=AUTH_CHECK_INTERVAL,
+        )
+
+
+class CheckAuthIdentityTest(TestCase):
+    @patch('sentry.tasks.check_auth.check_auth_identity')
+    def test_simple(self, mock_check_auth_identity):
+        organization = self.create_organization(name='Test')
+        user = self.create_user(email='bar@example.com')
+        auth_provider = AuthProvider.objects.create(
+            organization=organization,
+            provider='dummy',
+        )
+        om = OrganizationMember.objects.create(
+            user=user,
+            organization=organization,
+            flags=getattr(OrganizationMember.flags, 'sso:linked'),
+        )
+
+        ai = AuthIdentity.objects.create(
+            auth_provider=auth_provider,
+            user=user,
+            last_verified=timezone.now() - timedelta(days=1),
+        )
+
+        with patch.object(DummyProvider, 'refresh_identity') as mock_refresh_identity:
+            mock_refresh_identity.side_effect = IdentityNotValid()
+            with self.auth_provider('dummy', DummyProvider):
+                check_auth_identity(auth_identity_id=ai.id)
+            mock_refresh_identity.assert_called_once_with(ai)
+
+        # because of an error, it should become inactive
+        om = OrganizationMember.objects.get(id=om.id)
+        assert not getattr(om.flags, 'sso:linked')
+        assert getattr(om.flags, 'sso:invalid')
+
+        updated_ai = AuthIdentity.objects.get(id=ai.id)
+        assert updated_ai.last_verified != ai.last_verified

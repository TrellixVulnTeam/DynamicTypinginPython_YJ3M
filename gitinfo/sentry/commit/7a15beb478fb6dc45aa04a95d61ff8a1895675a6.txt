commit 7a15beb478fb6dc45aa04a95d61ff8a1895675a6
Author: Lyn Nagara <lyn.nagara@gmail.com>
Date:   Mon Jan 6 14:09:03 2020 -0800

    feat: Event / SnubaEvent compatibility (#16222)
    
    Make eventstore Event model compatible with SnubaEvent, which will allow
    us to deprecate SnubaEvent everywhere and move towards a single Event
    model.

diff --git a/src/sentry/eventstore/models.py b/src/sentry/eventstore/models.py
index 5be4a2173c..f54c6e225f 100644
--- a/src/sentry/eventstore/models.py
+++ b/src/sentry/eventstore/models.py
@@ -1,22 +1,30 @@
 from __future__ import absolute_import
 
+import pytz
+
 from datetime import datetime
-from django.utils import timezone
+from dateutil.parser import parse as parse_date
 
 from sentry.models import EventCommon, EventDict
 from sentry.db.models import NodeData
 
+from sentry.snuba.events import Columns
+
 
 def ref_func(x):
     return x.project_id or x.project.id
 
 
 class Event(EventCommon):
-    def __init__(self, project_id, event_id, group_id=None, data=None):
+    def __init__(
+        self, project_id, event_id, group_id=None, message=None, data=None, snuba_data=None
+    ):
         self.project_id = project_id
         self.event_id = event_id
         self.group_id = group_id
+        self.message = message
         self.data = data
+        self._snuba_data = snuba_data or {}
         super(Event, self).__init__()
 
     def __getstate__(self):
@@ -43,13 +51,152 @@ class Event(EventCommon):
             node_id, data=value, wrapper=EventDict, ref_version=2, ref_func=ref_func
         )
 
+    @property
+    def group_id(self):
+        if self._group_id:
+            return self._group_id
+
+        column = self.__get_column_name(Columns.GROUP_ID)
+
+        return self._snuba_data.get(column)
+
+    @group_id.setter
+    def group_id(self, value):
+        self._group_id = value
+
     @property
     def platform(self):
+        column = self.__get_column_name(Columns.PLATFORM)
+        if column in self._snuba_data:
+            return self._snuba_data[column]
         return self.data.get("platform", None)
 
+    @property
+    def message(self):
+        if self._message:
+            return self._message
+
+        column = self.__get_column_name(Columns.MESSAGE)
+        if column in self._snuba_data:
+            return self._snuba_data[column]
+
+        return self.data.get("message")
+
+    @message.setter
+    def message(self, value):
+        self._message = value
+
     @property
     def datetime(self):
-        recorded_timestamp = self.data.get("timestamp")
-        date = datetime.fromtimestamp(recorded_timestamp)
-        date = date.replace(tzinfo=timezone.utc)
+        column = self.__get_column_name(Columns.TIMESTAMP)
+        if column in self._snuba_data:
+            return parse_date(self._snuba_data[column]).replace(tzinfo=pytz.utc)
+
+        timestamp = self.data.get("timestamp")
+        date = datetime.fromtimestamp(timestamp)
+        date = date.replace(tzinfo=pytz.utc)
         return date
+
+    @property
+    def timestamp(self):
+        column = self.__get_column_name(Columns.TIMESTAMP)
+        if column in self._snuba_data:
+            return self._snuba_data[column]
+        return self.datetime.isoformat()
+
+    @property
+    def id(self):
+        return self.event_id
+
+    # ============================================
+    # Snuba-only implementations of properties that
+    # would otherwise require nodestore data.
+    # ============================================
+    @property
+    def tags(self):
+        """
+        Override of tags property that uses tags from snuba rather than
+        the nodestore event body. This might be useful for implementing
+        tag deletions without having to rewrite nodestore blobs.
+        """
+        tags_key_column = self.__get_column_name(Columns.TAGS_KEY)
+        tags_value_column = self.__get_column_name(Columns.TAGS_VALUE)
+
+        if tags_key_column in self._snuba_data and tags_value_column in self._snuba_data:
+            keys = self._snuba_data[tags_key_column]
+            values = self._snuba_data[tags_value_column]
+            if keys and values and len(keys) == len(values):
+                return sorted(zip(keys, values))
+            else:
+                return []
+        else:
+            return super(Event, self).tags
+
+    def get_minimal_user(self):
+        from sentry.interfaces.user import User
+
+        user_id_column = self.__get_column_name(Columns.USER_ID)
+        user_email_column = self.__get_column_name(Columns.USER_EMAIL)
+        user_username_column = self.__get_column_name(Columns.USER_USERNAME)
+        user_ip_address_column = self.__get_column_name(Columns.USER_IP_ADDRESS)
+
+        if all(
+            key in self._snuba_data
+            for key in [
+                user_id_column,
+                user_email_column,
+                user_username_column,
+                user_ip_address_column,
+            ]
+        ):
+            user_id = self._snuba_data[user_id_column]
+            email = self._snuba_data[user_email_column]
+            username = self._snuba_data[user_username_column]
+            ip_address = self._snuba_data[user_ip_address_column]
+
+            return User.to_python(
+                {"id": user_id, "email": email, "username": username, "ip_address": ip_address}
+            )
+
+        return super(Event, self).get_minimal_user()
+
+    # If the data for these is available from snuba, we assume
+    # it was already normalized on the way in and we can just return
+    # it, otherwise we defer to EventCommon implementation.
+    def get_event_type(self):
+        column = self.__get_column_name(Columns.TYPE)
+        if column in self._snuba_data:
+            return self._snuba_data[column]
+        return super(Event, self).get_event_type()
+
+    @property
+    def ip_address(self):
+        column = self.__get_column_name(Columns.USER_IP_ADDRESS)
+        if column in self._snuba_data:
+            return self._snuba_data[column]
+        return super(Event, self).ip_address
+
+    @property
+    def title(self):
+        column = self.__get_column_name(Columns.TITLE)
+        if column in self._snuba_data:
+            return self._snuba_data[column]
+        return super(Event, self).title
+
+    @property
+    def culprit(self):
+        column = self.__get_column_name(Columns.CULPRIT)
+        if column in self._snuba_data:
+            return self._snuba_data[column]
+        return super(Event, self).culprit
+
+    @property
+    def location(self):
+        column = self.__get_column_name(Columns.LOCATION)
+        if column in self._snuba_data:
+            return self._snuba_data[column]
+        return super(Event, self).location
+
+    def __get_column_name(self, column):
+        # Events are currently populated from the Events dataset
+        return column.value.event_name
diff --git a/src/sentry/eventstore/snuba/backend.py b/src/sentry/eventstore/snuba/backend.py
index 7b934d7713..586727ae74 100644
--- a/src/sentry/eventstore/snuba/backend.py
+++ b/src/sentry/eventstore/snuba/backend.py
@@ -1,14 +1,16 @@
 from __future__ import absolute_import
 
 import six
+
 from copy import deepcopy
 
 from sentry.eventstore.base import EventStorage
-from sentry.models import SnubaEvent
 from sentry.snuba.events import Columns
 from sentry.utils import snuba
 from sentry.utils.validators import normalize_event_id
 
+from ..models import Event
+
 EVENT_ID = Columns.EVENT_ID.value.alias
 PROJECT_ID = Columns.PROJECT_ID.value.alias
 TIMESTAMP = Columns.TIMESTAMP.value.alias
@@ -67,7 +69,7 @@ class SnubaEventStorage(EventStorage):
         )
 
         if "error" not in result:
-            return [SnubaEvent(evt) for evt in result["data"]]
+            return [self.__make_event(evt) for evt in result["data"]]
 
         return []
 
@@ -90,7 +92,7 @@ class SnubaEventStorage(EventStorage):
             limit=1,
         )
         if "error" not in result and len(result["data"]) == 1:
-            return SnubaEvent(result["data"][0])
+            return self.__make_event(result["data"][0])
         return None
 
     def get_earliest_event_id(self, event, filter):
@@ -177,3 +179,12 @@ class SnubaEventStorage(EventStorage):
         row = result["data"][0]
 
         return (six.text_type(row["project_id"]), six.text_type(row["event_id"]))
+
+    def __make_event(self, snuba_data):
+        event_id = snuba_data[Columns.EVENT_ID.value.event_name]
+        group_id = snuba_data[Columns.GROUP_ID.value.event_name]
+        project_id = snuba_data[Columns.PROJECT_ID.value.event_name]
+
+        return Event(
+            event_id=event_id, group_id=group_id, project_id=project_id, snuba_data=snuba_data
+        )
diff --git a/tests/sentry/eventstore/snuba/test_backend.py b/tests/sentry/eventstore/snuba/test_backend.py
index fb1efdf344..4001199c7d 100644
--- a/tests/sentry/eventstore/snuba/test_backend.py
+++ b/tests/sentry/eventstore/snuba/test_backend.py
@@ -94,7 +94,7 @@ class SnubaEventStorageTest(TestCase, SnubaTestCase):
         assert event.id == "a" * 32
         assert event.event_id == "a" * 32
         assert event.project_id == self.project1.id
-        assert len(event.snuba_data.keys()) == 4
+        assert len(event._snuba_data.keys()) == 4
 
         # Get all columns
         event = self.eventstore.get_event_by_id(
@@ -103,7 +103,7 @@ class SnubaEventStorageTest(TestCase, SnubaTestCase):
         assert event.id == "b" * 32
         assert event.event_id == "b" * 32
         assert event.project_id == self.project2.id
-        assert len(event.snuba_data.keys()) == 17
+        assert len(event._snuba_data.keys()) == 17
 
         # Get non existent event
         event = self.eventstore.get_event_by_id(self.project2.id, "f" * 32)
diff --git a/tests/sentry/eventstore/snuba_discover/test_backend.py b/tests/sentry/eventstore/snuba_discover/test_backend.py
index f73160403c..f3ba468324 100644
--- a/tests/sentry/eventstore/snuba_discover/test_backend.py
+++ b/tests/sentry/eventstore/snuba_discover/test_backend.py
@@ -98,7 +98,7 @@ class SnubaDiscoverEventStorageTest(TestCase, SnubaTestCase):
         assert event.id == "a" * 32
         assert event.event_id == "a" * 32
         assert event.project_id == self.project1.id
-        assert len(event.snuba_data.keys()) == 4
+        assert len(event._snuba_data.keys()) == 4
 
         # Get all columns
         event = self.eventstore.get_event_by_id(
@@ -107,7 +107,7 @@ class SnubaDiscoverEventStorageTest(TestCase, SnubaTestCase):
         assert event.id == "b" * 32
         assert event.event_id == "b" * 32
         assert event.project_id == self.project2.id
-        assert len(event.snuba_data.keys()) == 17
+        assert len(event._snuba_data.keys()) == 17
 
         # Get non existent event
         event = self.eventstore.get_event_by_id(self.project2.id, "f" * 32)
diff --git a/tests/sentry/eventstore/test_models.py b/tests/sentry/eventstore/test_models.py
index 99b7282d04..14166e1b78 100644
--- a/tests/sentry/eventstore/test_models.py
+++ b/tests/sentry/eventstore/test_models.py
@@ -2,14 +2,14 @@ from __future__ import absolute_import
 
 import pickle
 import pytest
-import six
 
-from sentry.api.serializers import serialize
+from sentry import eventstore
 from sentry.db.models.fields.node import NodeData
 from sentry.eventstore.models import Event
 from sentry.models import Environment
 from sentry.testutils import TestCase
 from sentry.testutils.helpers.datetime import iso_format, before_now
+from sentry.utils import snuba
 
 
 class EventTest(TestCase):
@@ -182,29 +182,50 @@ class EventTest(TestCase):
         assert event.group is None
         assert event.culprit == "app/components/events/eventEntries in map"
 
-    def test_serialize_event(self):
-        event = self.store_event(
+    def test_snuba_data(self):
+        self.store_event(
             data={
                 "event_id": "a" * 32,
                 "message": "Hello World!",
                 "tags": {"logger": "foobar", "site": "foo", "server_name": "bar"},
+                "user": {"id": "test", "email": "test@test.com"},
+                "timestamp": iso_format(before_now(seconds=1)),
             },
             project_id=self.project.id,
         )
-        group_id = event.group_id
-        serialized = serialize(event)
-        assert serialized["eventID"] == "a" * 32
-        assert serialized["projectID"] == six.text_type(self.project.id)
-        assert serialized["groupID"] == six.text_type(group_id)
-        assert serialized["message"] == "Hello World!"
-
-        # Can serialize an event by loading node data
-        event = Event(project_id=self.project.id, event_id="a" * 32, group_id=group_id)
-        serialized = serialize(event)
-        assert serialized["eventID"] == "a" * 32
-        assert serialized["projectID"] == six.text_type(self.project.id)
-        assert serialized["groupID"] == six.text_type(group_id)
-        assert serialized["message"] == "Hello World!"
+
+        event_from_nodestore = Event(project_id=self.project.id, event_id="a" * 32)
+
+        event_from_snuba = Event(
+            project_id=self.project.id,
+            event_id="a" * 32,
+            snuba_data=snuba.raw_query(
+                selected_columns=[col.value.event_name for col in eventstore.full_columns],
+                filter_keys={"project_id": [self.project.id], "event_id": ["a" * 32]},
+            )["data"][0],
+        )
+
+        assert event_from_nodestore.event_id == event_from_snuba.event_id
+        assert event_from_nodestore.project_id == event_from_snuba.project_id
+        assert event_from_nodestore.project == event_from_snuba.project
+        assert event_from_nodestore.timestamp == event_from_snuba.timestamp
+        assert event_from_nodestore.datetime == event_from_snuba.datetime
+        assert event_from_nodestore.title == event_from_snuba.title
+        assert event_from_nodestore.message["formatted"] == event_from_snuba.message
+        assert event_from_nodestore.platform == event_from_snuba.platform
+        assert event_from_nodestore.location == event_from_snuba.location
+        assert event_from_nodestore.culprit == event_from_snuba.culprit
+
+        assert event_from_nodestore.get_minimal_user() == event_from_snuba.get_minimal_user()
+        assert event_from_nodestore.ip_address == event_from_snuba.ip_address
+        assert event_from_nodestore.tags == event_from_snuba.tags
+
+        # Group ID must be fetched from Snuba since it is not present in nodestore
+        assert event_from_snuba.group_id
+        assert event_from_snuba.group
+
+        assert not event_from_nodestore.group_id
+        assert not event_from_nodestore.group
 
 
 @pytest.mark.django_db

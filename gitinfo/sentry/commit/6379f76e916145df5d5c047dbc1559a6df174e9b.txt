commit 6379f76e916145df5d5c047dbc1559a6df174e9b
Author: Markus Unterwaditzer <markus@unterwaditzer.net>
Date:   Mon Dec 9 16:27:10 2019 +0100

    feat: Ingest individual attachments (#16013)
    
    * feat: Ingest individual attachments
    
    * ref: More realistic attachment IDs in tests
    
    * fix: Differentiate between uninitialized data and missing data

diff --git a/src/sentry/attachments/base.py b/src/sentry/attachments/base.py
index 152aaf50c0..cc72f60447 100644
--- a/src/sentry/attachments/base.py
+++ b/src/sentry/attachments/base.py
@@ -11,6 +11,8 @@ ATTACHMENT_META_KEY = u"{key}:a"
 ATTACHMENT_UNCHUNKED_DATA_KEY = u"{key}:a:{id}"
 ATTACHMENT_DATA_CHUNK_KEY = u"{key}:a:{id}:{chunk_index}"
 
+UNINITIALIZED_DATA = object()
+
 
 class CachedAttachment(object):
     def __init__(
@@ -20,7 +22,7 @@ class CachedAttachment(object):
         name=None,
         content_type=None,
         type=None,
-        data=None,
+        data=UNINITIALIZED_DATA,
         chunks=None,
         cache=None,
     ):
@@ -44,12 +46,16 @@ class CachedAttachment(object):
 
     @property
     def data(self):
-        if self._data is None and self._cache is not None:
+        if self._data is UNINITIALIZED_DATA and self._cache is not None:
             self._data = self._cache.get_data(self)
-            self._cache = None
 
+        assert self._data is not UNINITIALIZED_DATA
         return self._data
 
+    def delete(self):
+        for key in self.chunk_keys:
+            self._cache.inner.delete(key)
+
     @property
     def chunk_keys(self):
         assert self.key is not None
@@ -121,6 +127,9 @@ class BaseAttachmentCache(object):
         metrics.incr("attachments.received", tags=metrics_tags, skip_internal=False)
         self.inner.set(key, compressed, timeout, raw=True)
 
+    def get_from_chunks(self, key, **attachment):
+        return CachedAttachment(key=key, cache=self, **attachment)
+
     def get(self, key):
         result = self.inner.get(ATTACHMENT_META_KEY.format(key=key), raw=False)
 
@@ -139,7 +148,6 @@ class BaseAttachmentCache(object):
 
     def delete(self, key):
         for attachment in self.get(key):
-            for k in attachment.chunk_keys:
-                self.inner.delete(k)
+            attachment.delete()
 
         self.inner.delete(ATTACHMENT_META_KEY.format(key=key))
diff --git a/src/sentry/ingest/ingest_consumer.py b/src/sentry/ingest/ingest_consumer.py
index f20cda9949..3ecee0ec97 100644
--- a/src/sentry/ingest/ingest_consumer.py
+++ b/src/sentry/ingest/ingest_consumer.py
@@ -2,13 +2,14 @@ from __future__ import absolute_import
 
 import logging
 import msgpack
+from six import BytesIO
 
 
 from django.conf import settings
 from django.core.cache import cache
 
 from sentry.cache import default_cache
-from sentry.models import Project
+from sentry.models import Project, File, EventAttachment
 from sentry.signals import event_accepted
 from sentry.tasks.store import preprocess_event
 from sentry.utils import json
@@ -137,7 +138,34 @@ def process_attachment_chunk(message):
 
 
 def process_individual_attachment(message):
-    raise RuntimeError("Not implemented yet")
+    event_id = message["event_id"]
+    project_id = message["project_id"]
+    cache_key = cache_key_for_event({"event_id": event_id, "project": project_id})
+
+    try:
+        project = Project.objects.get_from_cache(id=project_id)
+    except Project.DoesNotExist:
+        logger.error("Project for ingested event does not exist: %s", project_id)
+        return
+
+    attachment = message["attachment"]
+    attachment = attachment_cache.get_from_chunks(
+        key=cache_key, type=attachment.pop("attachment_type"), **attachment
+    )
+    assert attachment.type == "event.attachment", attachment.type
+
+    file = File.objects.create(
+        name=attachment.name,
+        type=attachment.type,
+        headers={"Content-Type": attachment.content_type},
+    )
+
+    file.putfile(BytesIO(attachment.data))
+    EventAttachment.objects.create(
+        project_id=project.id, event_id=event_id, name=attachment.name, file=file
+    )
+
+    attachment.delete()
 
 
 def get_ingest_consumer(consumer_type, once=False, **options):
diff --git a/tests/sentry/ingest/ingest_consumer/test_ingest_processing.py b/tests/sentry/ingest/ingest_consumer/test_ingest_processing.py
index 3d84980ebc..b49436cd5f 100644
--- a/tests/sentry/ingest/ingest_consumer/test_ingest_processing.py
+++ b/tests/sentry/ingest/ingest_consumer/test_ingest_processing.py
@@ -4,9 +4,14 @@ import pytest
 import time
 
 from sentry.utils import json
-from sentry.ingest.ingest_consumer import process_event, process_attachment_chunk
+from sentry.ingest.ingest_consumer import (
+    process_event,
+    process_attachment_chunk,
+    process_individual_attachment,
+)
 from sentry.attachments import attachment_cache
 from sentry.event_manager import EventManager
+from sentry.models import EventAttachment
 
 
 def get_normalized_event(data, project):
@@ -58,6 +63,7 @@ def test_deduplication_works(default_project, task_runner, monkeypatch, preproce
 def test_with_attachments(default_project, task_runner, monkeypatch, preprocess_event):
     payload = get_normalized_event({"message": "hello world"}, default_project)
     event_id = payload["event_id"]
+    attachment_id = "ca90fb45-6dd9-40a0-a18f-8693aa621abb"
     project_id = default_project.id
     start_time = time.time() - 3600
 
@@ -66,7 +72,7 @@ def test_with_attachments(default_project, task_runner, monkeypatch, preprocess_
             "payload": b"Hello ",
             "event_id": event_id,
             "project_id": project_id,
-            "id": 0,
+            "id": attachment_id,
             "chunk_index": 0,
         }
     )
@@ -76,7 +82,7 @@ def test_with_attachments(default_project, task_runner, monkeypatch, preprocess_
             "payload": b"World!",
             "event_id": event_id,
             "project_id": project_id,
-            "id": 0,
+            "id": attachment_id,
             "chunk_index": 1,
         }
     )
@@ -90,7 +96,7 @@ def test_with_attachments(default_project, task_runner, monkeypatch, preprocess_
             "remote_addr": "127.0.0.1",
             "attachments": [
                 {
-                    "id": 0,
+                    "id": attachment_id,
                     "name": "lol.txt",
                     "content_type": "text/plain",
                     "attachment_type": "custom.attachment",
@@ -115,3 +121,54 @@ def test_with_attachments(default_project, task_runner, monkeypatch, preprocess_
     assert att.name == "lol.txt"
     assert att.content_type == "text/plain"
     assert att.type == "custom.attachment"
+
+
+@pytest.mark.django_db
+def test_individual_attachments(default_project, monkeypatch):
+    event_id = "515539018c9b4260a6f999572f1661ee"
+    attachment_id = "ca90fb45-6dd9-40a0-a18f-8693aa621abb"
+    project_id = default_project.id
+
+    process_attachment_chunk(
+        {
+            "payload": b"Hello ",
+            "event_id": event_id,
+            "project_id": project_id,
+            "id": attachment_id,
+            "chunk_index": 0,
+        }
+    )
+
+    process_attachment_chunk(
+        {
+            "payload": b"World!",
+            "event_id": event_id,
+            "project_id": project_id,
+            "id": attachment_id,
+            "chunk_index": 1,
+        }
+    )
+
+    process_individual_attachment(
+        {
+            "type": "attachment",
+            "attachment": {
+                "attachment_type": "event.attachment",
+                "chunks": 2,
+                "content_type": "application/octet-stream",
+                "id": attachment_id,
+                "name": "foo.txt",
+            },
+            "event_id": event_id,
+            "project_id": project_id,
+        }
+    )
+
+    att1, = EventAttachment.objects.filter(project_id=project_id, event_id=event_id).select_related(
+        "file"
+    )
+    assert att1.file.type == "event.attachment"
+    assert att1.file.headers == {"Content-Type": "application/octet-stream"}
+    f = att1.file.getfile()
+    assert f.read() == b"Hello World!"
+    assert f.name == "foo.txt"

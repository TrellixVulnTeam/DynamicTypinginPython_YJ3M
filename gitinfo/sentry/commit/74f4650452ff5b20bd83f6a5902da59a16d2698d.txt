commit 74f4650452ff5b20bd83f6a5902da59a16d2698d
Author: David Cramer <dcramer@gmail.com>
Date:   Tue Apr 29 17:42:35 2014 -0300

    Store keys in a normalized rollup fashion
    
    This prevents the need to store the rollup as part of the key, which otherwise would lead to duplicates by using the epoch.

diff --git a/src/sentry/tsdb/base.py b/src/sentry/tsdb/base.py
index 0f675902ff..2908cf2191 100644
--- a/src/sentry/tsdb/base.py
+++ b/src/sentry/tsdb/base.py
@@ -46,6 +46,14 @@ class BaseTSDB(object):
         epoch = int(timestamp.strftime('%s'))
         return epoch - (epoch % seconds)
 
+    def normalize_to_rollup(self, timestamp, seconds):
+        """
+        Given a ``timestamp`` (datetime object) normalize the datetime object
+        ``timestamp`` to an epoch rollup (integer).
+        """
+        epoch = int(timestamp.strftime('%s'))
+        return int(epoch / seconds)
+
     def get_optimal_rollup(self, start_timestamp, end_timestamp):
         """
         Identify the lowest granularity rollup available within the given time
diff --git a/src/sentry/tsdb/redis.py b/src/sentry/tsdb/redis.py
index d0ffdf9045..178fc16b2b 100644
--- a/src/sentry/tsdb/redis.py
+++ b/src/sentry/tsdb/redis.py
@@ -9,6 +9,7 @@ from __future__ import absolute_import
 
 from binascii import crc32
 from collections import defaultdict
+from datetime import timedelta
 from django.conf import settings
 from django.utils import timezone
 from hashlib import md5
@@ -89,17 +90,17 @@ class RedisTSDB(BaseTSDB):
         >>> incr_multi([(TimeSeriesModel.project, 1), (TimeSeriesModel.group, 5)])
         """
         make_key = self.make_key
-        normalize_to_epoch = self.normalize_to_epoch
+        normalize_to_rollup = self.normalize_to_rollup
         if timestamp is None:
             timestamp = timezone.now()
 
         with self.conn.map() as conn:
             for rollup, max_values in self.rollups:
-                epoch = normalize_to_epoch(timestamp, rollup)
+                norm_epoch = normalize_to_rollup(timestamp, rollup)
 
                 for model, key in items:
                     model_key = self.get_model_key(key)
-                    hash_key = make_key(model, epoch, model_key)
+                    hash_key = make_key(model, norm_epoch, model_key)
                     conn.hincrby(hash_key, model_key, count)
                     conn.expire(hash_key, rollup * max_values)
 
@@ -113,22 +114,29 @@ class RedisTSDB(BaseTSDB):
         >>>          end=now)
         """
         normalize_to_epoch = self.normalize_to_epoch
+        normalize_to_rollup = self.normalize_to_rollup
         make_key = self.make_key
 
+        end = end + timedelta(seconds=1)
+
         if rollup is None:
             rollup = self.get_optimal_rollup(start, end)
 
-        # generate keys to fetch
-        start_epoch = normalize_to_epoch(start, rollup)
-        end_epoch = normalize_to_epoch(end, rollup)
-
         results = []
         with self.conn.map() as conn:
-            for epoch in range(start_epoch, end_epoch + 1, rollup):
+            timestamp = start
+            while timestamp < end:
+                real_epoch = normalize_to_epoch(timestamp, rollup)
+                norm_epoch = normalize_to_rollup(timestamp, rollup)
+
+                print timestamp, rollup, norm_epoch
+
                 for key in keys:
                     model_key = self.get_model_key(key)
-                    hash_key = make_key(model, epoch, model_key)
-                    results.append((epoch, key, conn.hget(hash_key, model_key)))
+                    hash_key = make_key(model, norm_epoch, model_key)
+                    results.append((real_epoch, key, conn.hget(hash_key, model_key)))
+
+                timestamp = timestamp + timedelta(seconds=rollup)
 
         results_by_key = defaultdict(dict)
         for epoch, key, count in results:
@@ -136,4 +144,4 @@ class RedisTSDB(BaseTSDB):
 
         for key, points in results_by_key.iteritems():
             results_by_key[key] = sorted(points.items())
-        return results_by_key
+        return dict(results_by_key)

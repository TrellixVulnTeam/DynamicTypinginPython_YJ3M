commit ec0298e98bac0ebbbcf1b7ca0089d41abd47096b
Author: Chris Fuller <cfuller@sentry.io>
Date:   Thu Dec 19 09:55:39 2019 -0500

    feat(incidents): Combined rules API (#16053)
    
    * v0.1 combined alert rules API
    
    * v0.2 combined alert rules API
    
    * v0.21 combined alert rules API
    
    * Cursors
    
    * Cursors
    
    * get_attrs implementation
    
    * Bulk serialize take 1
    
    * Moving serializer and added test
    
    * Switching branches for dateCreated refactor
    
    * Switching branches
    
    * Tests and ordering fixed
    
    * Adding offset test, date_added mods, and switch gte to lte after realizing its wrong. Also broke all tests
    
    * Swtiching branches
    
    * Fixing cursor bug and ordering issue
    
    * Fixing tests
    
    * -

diff --git a/src/sentry/api/serializers/models/alert_rule.py b/src/sentry/api/serializers/models/alert_rule.py
index ec127e65ab..63b8a39cb6 100644
--- a/src/sentry/api/serializers/models/alert_rule.py
+++ b/src/sentry/api/serializers/models/alert_rule.py
@@ -6,6 +6,7 @@ import six
 
 from sentry.api.serializers import register, serialize, Serializer
 from sentry.incidents.models import AlertRule, AlertRuleExcludedProjects, AlertRuleTrigger
+from sentry.models import Rule
 
 
 @register(AlertRule)
@@ -73,3 +74,29 @@ class DetailedAlertRuleSerializer(AlertRuleSerializer):
         data["projects"] = sorted(attrs["projects"])
         data["excludedProjects"] = sorted(attrs.get("excludedProjects", []))
         return data
+
+
+class CombinedRuleSerializer(Serializer):
+    def get_attrs(self, item_list, user, **kwargs):
+        results = super(CombinedRuleSerializer, self).get_attrs(item_list, user)
+
+        alert_rules = serialize([x for x in item_list if isinstance(x, AlertRule)], user=user)
+        rules = serialize([x for x in item_list if isinstance(x, Rule)], user=user)
+
+        for item in item_list:
+            if isinstance(item, AlertRule):
+                results[item] = alert_rules.pop(0)
+            elif isinstance(item, Rule):
+                results[item] = rules.pop(0)
+
+        return results
+
+    def serialize(self, obj, attrs, user, **kwargs):
+        if isinstance(obj, AlertRule):
+            attrs["type"] = "alert_rule"
+            return attrs
+        elif isinstance(obj, Rule):
+            attrs["type"] = "rule"
+            return attrs
+        else:
+            raise AssertionError("Invalid rule to serialize: %r" % type(obj))
diff --git a/src/sentry/api/urls.py b/src/sentry/api/urls.py
index fc6ad66695..ae2e401b82 100644
--- a/src/sentry/api/urls.py
+++ b/src/sentry/api/urls.py
@@ -306,7 +306,10 @@ from sentry.incidents.endpoints.organization_alert_rule_trigger_index import (
     OrganizationAlertRuleTriggerIndexEndpoint,
 )
 from sentry.incidents.endpoints.project_alert_rule_details import ProjectAlertRuleDetailsEndpoint
-from sentry.incidents.endpoints.project_alert_rule_index import ProjectAlertRuleIndexEndpoint
+from sentry.incidents.endpoints.project_alert_rule_index import (
+    ProjectAlertRuleIndexEndpoint,
+    ProjectCombinedRuleIndexEndpoint,
+)
 
 # issues endpoints are available both top level (by numerical ID) as well as coupled
 # to the organization (and queryable via short ID)
@@ -1125,6 +1128,11 @@ urlpatterns = [
                     ProjectAlertRuleIndexEndpoint.as_view(),
                     name="sentry-api-0-project-alert-rules",
                 ),
+                url(
+                    r"^(?P<organization_slug>[^\/]+)/(?P<project_slug>[^\/]+)/combined-rules/$",
+                    ProjectCombinedRuleIndexEndpoint.as_view(),
+                    name="sentry-api-0-project-combined-rules",
+                ),
                 url(
                     r"^(?P<organization_slug>[^\/]+)/(?P<project_slug>[^\/]+)/avatar/$",
                     ProjectAvatarEndpoint.as_view(),
diff --git a/src/sentry/incidents/endpoints/project_alert_rule_index.py b/src/sentry/incidents/endpoints/project_alert_rule_index.py
index 2c8916ce64..022c4f4c50 100644
--- a/src/sentry/incidents/endpoints/project_alert_rule_index.py
+++ b/src/sentry/incidents/endpoints/project_alert_rule_index.py
@@ -1,17 +1,80 @@
 from __future__ import absolute_import
 
+import six
+import time
+from datetime import datetime
 from copy import deepcopy
 
 from rest_framework import status
 from rest_framework.response import Response
 
+from django.utils import timezone
+
 from sentry import features
 from sentry.api.bases.project import ProjectEndpoint
 from sentry.api.exceptions import ResourceDoesNotExist
 from sentry.api.paginator import OffsetPaginator
-from sentry.api.serializers import serialize
-from sentry.incidents.models import AlertRule
+from sentry.api.serializers import serialize, CombinedRuleSerializer
 from sentry.incidents.endpoints.serializers import AlertRuleSerializer
+from sentry.incidents.models import AlertRule
+from sentry.models import Rule, RuleStatus
+from sentry.utils.cursors import build_cursor, Cursor
+
+
+class ProjectCombinedRuleIndexEndpoint(ProjectEndpoint):
+    def get(self, request, project):
+        """
+        Fetches alert rules and legacy rules for an organization
+        """
+        if not features.has("organizations:incidents", project.organization, actor=request.user):
+            raise ResourceDoesNotExist
+
+        cursor_string = request.GET.get(
+            "cursor", six.binary_type(int(time.time() * 1000000)) + ":0:0"
+        )
+        try:
+            limit = min(100, int(request.GET.get("limit", 25)))
+        except ValueError as e:
+            return Response(
+                {"detail": "Invalid input for `limit`. Error: %s" % six.text_type(e)}, status=400
+            )
+
+        cursor = Cursor.from_string(cursor_string)
+        cursor_date = datetime.fromtimestamp(float(cursor.value) / 1000000).replace(
+            tzinfo=timezone.utc
+        )
+
+        alert_rule_queryset = (
+            AlertRule.objects.fetch_for_project(project)
+            .filter(date_added__lte=cursor_date)
+            .order_by("-date_added")[: limit + 1]
+        )
+
+        legacy_rule_queryset = (
+            Rule.objects.filter(
+                project=project, status__in=[RuleStatus.ACTIVE, RuleStatus.INACTIVE]
+            )
+            .select_related("project")
+            .filter(date_added__lte=cursor_date)
+            .order_by("-date_added")[: (limit + 1)]
+        )
+        combined_rules = list(alert_rule_queryset) + list(legacy_rule_queryset)
+        combined_rules.sort(
+            key=lambda instance: (instance.date_added, type(instance)), reverse=True
+        )
+        combined_rules = combined_rules[cursor.offset : cursor.offset + limit + 1]
+
+        def get_item_key(item, for_prev=False):
+            return 1000000 * float(item.date_added.strftime("%s.%f"))
+
+        cursor_result = build_cursor(
+            results=combined_rules, cursor=cursor, key=get_item_key, limit=limit, is_desc=True
+        )
+        results = list(cursor_result)
+        context = serialize(results, request.user, CombinedRuleSerializer())
+        response = Response(context)
+        self.add_cursor_headers(request, response, cursor_result)
+        return response
 
 
 class ProjectAlertRuleIndexEndpoint(ProjectEndpoint):
@@ -40,7 +103,6 @@ class ProjectAlertRuleIndexEndpoint(ProjectEndpoint):
 
         data = deepcopy(request.data)
         data["projects"] = [project.slug]
-
         serializer = AlertRuleSerializer(
             context={"organization": project.organization, "access": request.access}, data=data
         )
diff --git a/src/sentry/testutils/factories.py b/src/sentry/testutils/factories.py
index 3e2aafe594..12a410ebf8 100644
--- a/src/sentry/testutils/factories.py
+++ b/src/sentry/testutils/factories.py
@@ -939,11 +939,12 @@ class Factories(object):
         threshold_period=1,
         include_all_projects=False,
         excluded_projects=None,
+        date_added=None,
     ):
         if not name:
             name = petname.Generate(2, " ", letters=10).title()
 
-        return create_alert_rule(
+        alert_rule = create_alert_rule(
             organization,
             projects,
             name,
@@ -955,6 +956,11 @@ class Factories(object):
             excluded_projects=excluded_projects,
         )
 
+        if date_added is not None:
+            alert_rule.update(date_added=date_added)
+
+        return alert_rule
+
     @staticmethod
     def create_alert_rule_trigger(
         alert_rule,
diff --git a/tests/sentry/api/serializers/test_alert_rule.py b/tests/sentry/api/serializers/test_alert_rule.py
index 7662e474d8..1f8d21ae82 100644
--- a/tests/sentry/api/serializers/test_alert_rule.py
+++ b/tests/sentry/api/serializers/test_alert_rule.py
@@ -5,15 +5,19 @@ from __future__ import absolute_import
 import six
 
 from sentry.api.serializers import serialize
-from sentry.api.serializers.models.alert_rule import DetailedAlertRuleSerializer
+from sentry.api.serializers.models.alert_rule import (
+    DetailedAlertRuleSerializer,
+    CombinedRuleSerializer,
+)
+from sentry.models import Rule
 from sentry.incidents.logic import create_alert_rule, create_alert_rule_trigger
 from sentry.incidents.models import AlertRuleThresholdType
 from sentry.snuba.models import QueryAggregations
-from sentry.testutils import TestCase
+from sentry.testutils import TestCase, APITestCase
 
 
 class BaseAlertRuleSerializerTest(object):
-    def assert_alert_rule_serialized(self, alert_rule, result):
+    def assert_alert_rule_serialized(self, alert_rule, result, skip_dates=False):
         assert result["id"] == six.text_type(alert_rule.id)
         assert result["organizationId"] == six.text_type(alert_rule.organization_id)
         assert result["name"] == alert_rule.name
@@ -27,8 +31,41 @@ class BaseAlertRuleSerializerTest(object):
         assert result["resolveThreshold"] == 0
         assert result["thresholdPeriod"] == alert_rule.threshold_period
         assert result["includeAllProjects"] == alert_rule.include_all_projects
-        assert result["dateModified"] == alert_rule.date_modified
-        assert result["dateCreated"] == alert_rule.date_added
+        if not skip_dates:
+            assert result["dateModified"] == alert_rule.date_modified
+            assert result["dateCreated"] == alert_rule.date_added
+
+    def create_issue_alert_rule(self, data):
+        """data format
+        {
+            "project": project
+            "environment": environment
+            "name": "My rule name",
+            "conditions": [],
+            "actions": [],
+            "actionMatch": "all"
+        }
+        """
+        rule = Rule()
+        rule.project = data["project"]
+        if "environment" in data:
+            environment = data["environment"]
+            rule.environment_id = int(environment) if environment else environment
+        if data.get("name"):
+            rule.label = data["name"]
+        if data.get("actionMatch"):
+            rule.data["action_match"] = data["actionMatch"]
+        if data.get("actions") is not None:
+            rule.data["actions"] = data["actions"]
+        if data.get("conditions") is not None:
+            rule.data["conditions"] = data["conditions"]
+        if data.get("frequency"):
+            rule.data["frequency"] = data["frequency"]
+        if data.get("date_added"):
+            rule.date_added = data["date_added"]
+
+        rule.save()
+        return rule
 
 
 class AlertRuleSerializerTest(BaseAlertRuleSerializerTest, TestCase):
@@ -87,3 +124,27 @@ class DetailedAlertRuleSerializerTest(BaseAlertRuleSerializerTest, TestCase):
         result = serialize([alert_rule, other_alert_rule], serializer=DetailedAlertRuleSerializer())
         assert result[0]["triggers"] == [serialize(trigger)]
         assert result[1]["triggers"] == []
+
+
+class CombinedRuleSerializerTest(BaseAlertRuleSerializerTest, APITestCase, TestCase):
+    def test_combined_serializer(self):
+        projects = [self.project, self.create_project()]
+        alert_rule = self.create_alert_rule(projects=projects)
+        issue_rule = self.create_issue_alert_rule(
+            data={
+                "project": self.project,
+                "name": "Issue Rule Test",
+                "conditions": [],
+                "actions": [],
+                "actionMatch": "all",
+            }
+        )
+        other_alert_rule = self.create_alert_rule()
+
+        result = serialize(
+            [alert_rule, issue_rule, other_alert_rule], serializer=CombinedRuleSerializer()
+        )
+
+        self.assert_alert_rule_serialized(alert_rule, result[0])
+        assert result[1]["id"] == six.text_type(issue_rule.id)
+        self.assert_alert_rule_serialized(other_alert_rule, result[2])
diff --git a/tests/sentry/incidents/endpoints/test_project_alert_rule_index.py b/tests/sentry/incidents/endpoints/test_project_alert_rule_index.py
index 0aac7e51d8..2b060752df 100644
--- a/tests/sentry/incidents/endpoints/test_project_alert_rule_index.py
+++ b/tests/sentry/incidents/endpoints/test_project_alert_rule_index.py
@@ -1,5 +1,10 @@
 from __future__ import absolute_import
 
+import six
+import json
+import requests
+import pytz
+
 from exam import fixture
 from freezegun import freeze_time
 
@@ -7,7 +12,9 @@ from sentry.api.serializers import serialize
 from sentry.incidents.logic import create_alert_rule
 from sentry.incidents.models import AlertRule
 from sentry.snuba.models import QueryAggregations
-from sentry.testutils import APITestCase
+from sentry.testutils.helpers.datetime import before_now
+from sentry.testutils import TestCase, APITestCase
+from tests.sentry.api.serializers.test_alert_rule import BaseAlertRuleSerializerTest
 
 
 class AlertRuleListEndpointTest(APITestCase):
@@ -108,3 +115,204 @@ class AlertRuleCreateEndpointTest(APITestCase):
         self.login_as(self.user)
         resp = self.get_response(self.organization.slug, self.project.slug)
         assert resp.status_code == 403
+
+
+class ProjectCombinedRuleIndexEndpointTest(BaseAlertRuleSerializerTest, APITestCase, TestCase):
+    def setup_project_and_rules(self):
+        self.org = self.create_organization(owner=self.user, name="Rowdy Tiger")
+        self.team = self.create_team(organization=self.org, name="Mariachi Band")
+        self.project = self.create_project(organization=self.org, teams=[self.team], name="Bengal")
+        self.login_as(self.user)
+        self.projects = [self.project, self.create_project()]
+        self.alert_rule = self.create_alert_rule(
+            projects=self.projects, date_added=before_now(minutes=6).replace(tzinfo=pytz.UTC)
+        )
+        self.other_alert_rule = self.create_alert_rule(
+            projects=self.projects, date_added=before_now(minutes=5).replace(tzinfo=pytz.UTC)
+        )
+        self.issue_rule = self.create_issue_alert_rule(
+            data={
+                "project": self.project,
+                "name": "Issue Rule Test",
+                "conditions": [],
+                "actions": [],
+                "actionMatch": "all",
+                "date_added": before_now(minutes=4).replace(tzinfo=pytz.UTC),
+            }
+        )
+        self.yet_another_alert_rule = self.create_alert_rule(
+            projects=self.projects, date_added=before_now(minutes=3).replace(tzinfo=pytz.UTC)
+        )
+        self.combined_rules_url = "/api/0/projects/{0}/{1}/combined-rules/".format(
+            self.org.slug, self.project.slug
+        )
+
+    def test_invalid_limit(self):
+        self.setup_project_and_rules()
+        with self.feature("organizations:incidents"):
+            request_data = {"limit": "notaninteger"}
+            response = self.client.get(
+                path=self.combined_rules_url, data=request_data, content_type="application/json"
+            )
+        assert response.status_code == 400
+
+    def test_limit_higher_than_cap(self):
+        pass  # TODO: Make limit a variable, so we can set it low for this test and avoid doing so many DB operations for a not-so-important test.
+        # self.setup_project_and_rules()
+        # for _ in range(125):
+        #     self.create_alert_rule(projects=self.projects)
+
+        # # Test limit above result cap (which is 100), no cursor.
+        # with self.feature("organizations:incidents"):
+        #     request_data = {"limit": "125"}
+        #     response = self.client.get(
+        #         path=self.combined_rules_url, data=request_data, content_type="application/json"
+        #     )
+        # assert response.status_code == 200
+        # result = json.loads(response.content)
+        # assert len(result) == 100
+
+    def test_limit_higher_than_results_no_cursor(self):
+        self.setup_project_and_rules()
+        # Test limit above result count (which is 4), no cursor.
+        with self.feature("organizations:incidents"):
+            request_data = {"limit": "5"}
+            response = self.client.get(
+                path=self.combined_rules_url, data=request_data, content_type="application/json"
+            )
+        assert response.status_code == 200
+        result = json.loads(response.content)
+        assert len(result) == 4
+        self.assert_alert_rule_serialized(self.yet_another_alert_rule, result[0], skip_dates=True)
+        assert result[1]["id"] == six.text_type(self.issue_rule.id)
+        assert result[1]["type"] == "rule"
+        self.assert_alert_rule_serialized(self.other_alert_rule, result[2], skip_dates=True)
+        self.assert_alert_rule_serialized(self.alert_rule, result[3], skip_dates=True)
+
+    def test_limit_as_1_with_paging(self):
+        self.setup_project_and_rules()
+
+        # Test Limit as 1, no cursor:
+        with self.feature("organizations:incidents"):
+            request_data = {"limit": "1"}
+            response = self.client.get(
+                path=self.combined_rules_url, data=request_data, content_type="application/json"
+            )
+        assert response.status_code == 200
+
+        result = json.loads(response.content)
+        assert len(result) == 1
+        self.assert_alert_rule_serialized(self.yet_another_alert_rule, result[0], skip_dates=True)
+
+        links = requests.utils.parse_header_links(
+            response.get("link").rstrip(">").replace(">,<", ",<")
+        )
+        next_cursor = links[1]["cursor"]
+
+        # Test Limit as 1, next page of previous request:
+        with self.feature("organizations:incidents"):
+            request_data = {"cursor": next_cursor, "limit": "1"}
+            response = self.client.get(
+                path=self.combined_rules_url, data=request_data, content_type="application/json"
+            )
+        assert response.status_code == 200
+        result = json.loads(response.content)
+        assert len(result) == 1
+        assert result[0]["id"] == six.text_type(self.issue_rule.id)
+        assert result[0]["type"] == "rule"
+
+    def test_limit_as_2_with_paging(self):
+        self.setup_project_and_rules()
+
+        # Test Limit as 2, no cursor:
+        with self.feature("organizations:incidents"):
+            request_data = {"limit": "2"}
+            response = self.client.get(
+                path=self.combined_rules_url, data=request_data, content_type="application/json"
+            )
+        assert response.status_code == 200
+
+        result = json.loads(response.content)
+        assert len(result) == 2
+        self.assert_alert_rule_serialized(self.yet_another_alert_rule, result[0], skip_dates=True)
+        assert result[1]["id"] == six.text_type(self.issue_rule.id)
+        assert result[1]["type"] == "rule"
+
+        links = requests.utils.parse_header_links(
+            response.get("link").rstrip(">").replace(">,<", ",<")
+        )
+        next_cursor = links[1]["cursor"]
+        # Test Limit 2, next page of previous request:
+        with self.feature("organizations:incidents"):
+            request_data = {"cursor": next_cursor, "limit": "2"}
+            response = self.client.get(
+                path=self.combined_rules_url, data=request_data, content_type="application/json"
+            )
+        assert response.status_code == 200
+
+        result = json.loads(response.content)
+        assert len(result) == 2
+        self.assert_alert_rule_serialized(self.other_alert_rule, result[0], skip_dates=True)
+        self.assert_alert_rule_serialized(self.alert_rule, result[1], skip_dates=True)
+
+        links = requests.utils.parse_header_links(
+            response.get("link").rstrip(">").replace(">,<", ",<")
+        )
+        next_cursor = links[1]["cursor"]
+
+        # Test Limit 2, next page of previous request - should get no results since there are only 4 total:
+        with self.feature("organizations:incidents"):
+            request_data = {"cursor": next_cursor, "limit": "2"}
+            response = self.client.get(
+                path=self.combined_rules_url, data=request_data, content_type="application/json"
+            )
+        assert response.status_code == 200
+
+        result = json.loads(response.content)
+        assert len(result) == 0
+
+    def test_offset_pagination(self):
+        self.setup_project_and_rules()
+
+        self.one_alert_rule = self.create_alert_rule(
+            projects=self.projects, date_added=before_now(minutes=2).replace(tzinfo=pytz.UTC)
+        )
+        self.two_alert_rule = self.create_alert_rule(
+            projects=self.projects, date_added=before_now(minutes=1).replace(tzinfo=pytz.UTC)
+        )
+        self.three_alert_rule = self.create_alert_rule(projects=self.projects)
+
+        # Modify 2nd rule to be date of 3rd rule. Second page offset should now be 1, or else we'll get the incorrect results (we should get one_alert_rule on the second page, but without an offset we would get two_alert_rule).
+        self.one_alert_rule.date_added = self.two_alert_rule.date_added
+        self.one_alert_rule.save()
+
+        with self.feature("organizations:incidents"):
+            request_data = {"limit": "2"}
+            response = self.client.get(
+                path=self.combined_rules_url, data=request_data, content_type="application/json"
+            )
+        assert response.status_code == 200
+
+        result = json.loads(response.content)
+        assert len(result) == 2
+        self.assert_alert_rule_serialized(self.three_alert_rule, result[0], skip_dates=True)
+        self.assert_alert_rule_serialized(self.one_alert_rule, result[1], skip_dates=True)
+
+        links = requests.utils.parse_header_links(
+            response.get("link").rstrip(">").replace(">,<", ",<")
+        )
+        next_cursor = links[1]["cursor"]
+        assert next_cursor.split(":")[1] == "1"  # Assert offset is properly calculated.
+
+        with self.feature("organizations:incidents"):
+            request_data = {"cursor": next_cursor, "limit": "2"}
+            response = self.client.get(
+                path=self.combined_rules_url, data=request_data, content_type="application/json"
+            )
+        assert response.status_code == 200
+
+        result = json.loads(response.content)
+        assert len(result) == 2
+
+        self.assert_alert_rule_serialized(self.two_alert_rule, result[0], skip_dates=True)
+        self.assert_alert_rule_serialized(self.yet_another_alert_rule, result[1], skip_dates=True)

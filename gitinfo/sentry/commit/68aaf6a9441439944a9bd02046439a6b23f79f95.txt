commit 68aaf6a9441439944a9bd02046439a6b23f79f95
Author: Chris Fuller <cfuller@sentry.io>
Date:   Wed Jan 15 11:50:31 2020 -0500

    feat(workflow): Unified Metric Rule API - POST & PUT (#16151)
    
    -Supports method to create and edit a metric alert rule with triggers + actions.

diff --git a/src/sentry/api/serializers/models/alert_rule_trigger.py b/src/sentry/api/serializers/models/alert_rule_trigger.py
index 7cfff67f54..537f244655 100644
--- a/src/sentry/api/serializers/models/alert_rule_trigger.py
+++ b/src/sentry/api/serializers/models/alert_rule_trigger.py
@@ -4,12 +4,27 @@ from collections import defaultdict
 
 import six
 
-from sentry.api.serializers import register, Serializer
-from sentry.incidents.models import AlertRuleTrigger, AlertRuleTriggerExclusion
+from sentry.api.serializers import register, serialize, Serializer
+from sentry.incidents.models import AlertRuleTrigger, AlertRuleTriggerAction, AlertRuleTriggerExclusion
 
 
 @register(AlertRuleTrigger)
 class AlertRuleTriggerSerializer(Serializer):
+    def get_attrs(self, item_list, user, **kwargs):
+
+        triggers = {item.id: item for item in item_list}
+        result = defaultdict(dict)
+
+        actions = AlertRuleTriggerAction.objects.filter(alert_rule_trigger__in=item_list).order_by("id")
+        serialized_actions = serialize(list(actions))
+        for trigger, serialized in zip(actions, serialized_actions):
+            triggers_actions = result[triggers[trigger.alert_rule_trigger_id]].setdefault(
+                "actions", []
+            )
+            triggers_actions.append(serialized)
+
+        return result
+
     def serialize(self, obj, attrs, user):
         return {
             "id": six.text_type(obj.id),
@@ -19,6 +34,7 @@ class AlertRuleTriggerSerializer(Serializer):
             "alertThreshold": obj.alert_threshold,
             "resolveThreshold": obj.resolve_threshold,
             "dateCreated": obj.date_added,
+            "actions": attrs.get("actions", []),
         }
 
 
diff --git a/src/sentry/incidents/endpoints/organization_alert_rule_details.py b/src/sentry/incidents/endpoints/organization_alert_rule_details.py
index 84b5589851..2b6d8e74ce 100644
--- a/src/sentry/incidents/endpoints/organization_alert_rule_details.py
+++ b/src/sentry/incidents/endpoints/organization_alert_rule_details.py
@@ -6,7 +6,7 @@ from rest_framework.response import Response
 from sentry.api.serializers import serialize
 from sentry.api.serializers.models.alert_rule import DetailedAlertRuleSerializer
 from sentry.incidents.endpoints.bases import OrganizationAlertRuleEndpoint
-from sentry.incidents.endpoints.serializers import AlertRuleSerializer as DrfAlertRuleSerializer
+from sentry.incidents.endpoints.serializers import UnifiedAlertRuleSerializer as DrfAlertRuleSerializer
 from sentry.incidents.logic import AlreadyDeletedError, delete_alert_rule
 
 
@@ -25,7 +25,6 @@ class OrganizationAlertRuleDetailsEndpoint(OrganizationAlertRuleEndpoint):
             context={"organization": organization, "access": request.access},
             instance=alert_rule,
             data=request.data,
-            partial=True,
         )
 
         if serializer.is_valid():
diff --git a/src/sentry/incidents/endpoints/organization_alert_rule_index.py b/src/sentry/incidents/endpoints/organization_alert_rule_index.py
index ac7bee2d4b..fcbbcc7260 100644
--- a/src/sentry/incidents/endpoints/organization_alert_rule_index.py
+++ b/src/sentry/incidents/endpoints/organization_alert_rule_index.py
@@ -9,7 +9,7 @@ from sentry.api.exceptions import ResourceDoesNotExist
 from sentry.api.paginator import OffsetPaginator
 from sentry.api.serializers import serialize
 from sentry.incidents.models import AlertRule
-from sentry.incidents.endpoints.serializers import AlertRuleSerializer
+from sentry.incidents.endpoints.serializers import UnifiedAlertRuleSerializer
 
 
 class OrganizationAlertRuleIndexEndpoint(OrganizationEndpoint):
@@ -33,10 +33,11 @@ class OrganizationAlertRuleIndexEndpoint(OrganizationEndpoint):
         """
         Create an alert rule
         """
+
         if not features.has("organizations:incidents", organization, actor=request.user):
             raise ResourceDoesNotExist
 
-        serializer = AlertRuleSerializer(
+        serializer = UnifiedAlertRuleSerializer(
             context={"organization": organization, "access": request.access}, data=request.data
         )
 
diff --git a/src/sentry/incidents/endpoints/serializers.py b/src/sentry/incidents/endpoints/serializers.py
index e8c37769e9..1dd14ac4f9 100644
--- a/src/sentry/incidents/endpoints/serializers.py
+++ b/src/sentry/incidents/endpoints/serializers.py
@@ -3,9 +3,13 @@ from __future__ import absolute_import
 from datetime import timedelta
 
 import six
+import operator
+
 from enum import Enum
 from rest_framework import serializers
 
+from django.db import transaction
+
 from sentry.api.serializers.rest_framework.base import CamelSnakeModelSerializer
 from sentry.api.serializers.rest_framework.project import ProjectField
 from sentry.incidents.logic import (
@@ -32,6 +36,204 @@ from sentry.models.user import User
 from sentry.snuba.models import QueryAggregations
 
 
+string_to_action_type = {
+    registration.slug: registration.type
+    for registration in AlertRuleTriggerAction.get_registered_types()
+}
+action_target_type_to_string = {
+    AlertRuleTriggerAction.TargetType.USER: "user",
+    AlertRuleTriggerAction.TargetType.TEAM: "team",
+    AlertRuleTriggerAction.TargetType.SPECIFIC: "specific",
+}
+string_to_action_target_type = {v: k for (k, v) in action_target_type_to_string.items()}
+
+CRITICAL_TRIGGER_LABEL = "critical"
+WARNING_TRIGGER_LABEL = "warning"
+
+
+class AlertRuleTriggerActionSerializer(CamelSnakeModelSerializer):
+    """
+    Serializer for creating/updating a trigger action. Required context:
+     - `trigger`: The trigger related to this action.
+     - `alert_rule`: The alert_rule related to this action.
+     - `organization`: The organization related to this action.
+     - `access`: An access object (from `request.access`)
+    """
+
+    id = serializers.IntegerField(required=False)
+    type = serializers.CharField()
+    target_type = serializers.CharField()
+
+    class Meta:
+        model = AlertRuleTriggerAction
+        fields = ["id", "type", "target_type", "target_identifier", "integration"]
+        extra_kwargs = {
+            "target_identifier": {"required": True},
+            "target_display": {"required": False},
+            "integration": {"required": False, "allow_null": True},
+        }
+
+    def validate_type(self, type):
+        if type not in string_to_action_type:
+            raise serializers.ValidationError(
+                "Invalid type, valid values are [%s]" % ", ".join(string_to_action_type.keys())
+            )
+        return string_to_action_type[type]
+
+    def validate_target_type(self, target_type):
+        if target_type not in string_to_action_target_type:
+            raise serializers.ValidationError(
+                "Invalid targetType, valid values are [%s]"
+                % ", ".join(string_to_action_target_type.keys())
+            )
+        return string_to_action_target_type[target_type]
+
+    def validate(self, attrs):
+        if ("type" in attrs) != ("target_type" in attrs) != ("target_identifier" in attrs):
+            raise serializers.ValidationError(
+                "type, targetType and targetIdentifier must be passed together"
+            )
+        type = attrs.get("type")
+        target_type = attrs.get("target_type")
+        access = self.context["access"]
+        identifier = attrs.get("target_identifier")
+
+        if type is not None:
+            type_info = AlertRuleTriggerAction.get_registered_type(type)
+            if target_type not in type_info.supported_target_types:
+                allowed_target_types = ",".join(
+                    [
+                        action_target_type_to_string[type_name]
+                        for type_name in type_info.supported_target_types
+                    ]
+                )
+                raise serializers.ValidationError(
+                    {
+                        "target_type": "Invalid target type for %s. Valid types are [%s]"
+                        % (type_info.slug, allowed_target_types)
+                    }
+                )
+
+        if attrs.get("type") == AlertRuleTriggerAction.Type.EMAIL:
+            if target_type == AlertRuleTriggerAction.TargetType.TEAM:
+                try:
+                    team = Team.objects.get(id=identifier)
+                except Team.DoesNotExist:
+                    raise serializers.ValidationError("Team does not exist")
+                if not access.has_team(team):
+                    raise serializers.ValidationError("Team does not exist")
+            elif target_type == AlertRuleTriggerAction.TargetType.USER:
+                try:
+                    user = User.objects.get(id=identifier)
+                except User.DoesNotExist:
+                    raise serializers.ValidationError("User does not exist")
+
+                if not OrganizationMember.objects.filter(
+                    organization=self.context["organization"], user=user
+                ).exists():
+                    raise serializers.ValidationError("User does not belong to this organization")
+        elif attrs.get("type") == AlertRuleTriggerAction.Type.SLACK:
+            if not attrs.get("integration"):
+                raise serializers.ValidationError(
+                    {"integration": "Integration must be provided for slack"}
+                )
+
+        return attrs
+
+    def create(self, validated_data):
+        return create_alert_rule_trigger_action(trigger=self.context["trigger"], **validated_data)
+
+    def _remove_unchanged_fields(self, instance, validated_data):
+        changed = False
+        if (
+            validated_data.get("type", instance.type) == AlertRuleTriggerAction.Type.SLACK.value
+            and validated_data["target_identifier"] != instance.target_display
+        ):
+            changed = True
+        for field_name, value in list(six.iteritems(validated_data)):
+            # Remove any fields that haven't actually changed
+            if isinstance(value, Enum):
+                value = value.value
+            if getattr(instance, field_name) != value:
+                changed = True
+                break
+        return validated_data if changed else {}
+
+    def update(self, instance, validated_data):
+        validated_data = self._remove_unchanged_fields(instance, validated_data)
+        return update_alert_rule_trigger_action(instance, **validated_data)
+
+
+class AlertRuleTriggerSerializer(CamelSnakeModelSerializer):
+    """
+    Serializer for creating/updating an alert rule trigger. Required context:
+     - `alert_rule`: The alert_rule related to this trigger.
+     - `organization`: The organization related to this trigger.
+     - `access`: An access object (from `request.access`)
+    """
+
+    id = serializers.IntegerField(required=False)
+
+    # TODO: These might be slow for many projects, since it will query for each
+    # individually. If we find this to be a problem then we can look into batching.
+    excluded_projects = serializers.ListField(child=ProjectField(), required=False)
+
+    actions = AlertRuleTriggerActionSerializer(many=True)
+
+    class Meta:
+        model = AlertRuleTrigger
+        fields = [
+            "id",
+            "label",
+            "threshold_type",
+            "alert_threshold",
+            "resolve_threshold",
+            "excluded_projects",
+            "actions",
+        ]
+        extra_kwargs = {"label": {"min_length": 1, "max_length": 64}}
+
+    def validate_threshold_type(self, threshold_type):
+        try:
+            return AlertRuleThresholdType(threshold_type)
+        except ValueError:
+            raise serializers.ValidationError(
+                "Invalid threshold type, valid values are %s"
+                % [item.value for item in AlertRuleThresholdType]
+            )
+
+    def create(self, validated_data):
+        try:
+            return create_alert_rule_trigger(
+                alert_rule=self.context["alert_rule"], **validated_data
+            )
+        except AlertRuleTriggerLabelAlreadyUsedError:
+            raise serializers.ValidationError("This label is already in use for this alert rule")
+
+    def _remove_unchanged_fields(self, instance, validated_data):
+        for field_name, value in list(six.iteritems(validated_data)):
+            # Remove any fields that haven't actually changed
+            if field_name == "excluded_projects":
+                excluded_slugs = [
+                    e.query_subscription.project.slug for e in instance.exclusions.all()
+                ]
+                if set(excluded_slugs) == set(project.slug for project in value):
+                    validated_data.pop(field_name)
+                continue
+            if isinstance(value, Enum):
+                value = value.value
+            if getattr(instance, field_name) == value:
+                validated_data.pop(field_name)
+        return validated_data
+
+    def update(self, instance, validated_data):
+        validated_data = self._remove_unchanged_fields(instance, validated_data)
+        try:
+            return update_alert_rule_trigger(instance, **validated_data)
+        except AlertRuleTriggerLabelAlreadyUsedError:
+            raise serializers.ValidationError("This label is already in use for this alert rule")
+
+
 class AlertRuleSerializer(CamelSnakeModelSerializer):
     """
     Serializer for creating/updating an alert rule. Required context:
@@ -97,8 +299,8 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
                 % [item.value for item in QueryAggregations]
             )
 
-    def validate(self, attrs):
-        return self._handle_old_fields_transition(attrs)
+    def validate(self, data):
+        return self._handle_old_fields_transition(data)
 
     def create(self, validated_data):
         try:
@@ -113,6 +315,9 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
     def _remove_unchanged_fields(self, instance, validated_data):
         for field_name, value in list(six.iteritems(validated_data)):
             # Remove any fields that haven't actually changed
+            if field_name == "triggers":
+                continue  # No removal for triggers
+
             if field_name == "projects":
                 project_slugs = Project.objects.filter(
                     querysubscription__alert_rules=instance
@@ -151,189 +356,171 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
         return update_alert_rule(instance, **validated_data)
 
 
-class AlertRuleTriggerSerializer(CamelSnakeModelSerializer):
-    """
-    Serializer for creating/updating an alert rule trigger. Required context:
-     - `alert_rule`: The alert_rule related to this trigger.
-     - `organization`: The organization related to this trigger.
-     - `access`: An access object (from `request.access`)
+class UnifiedAlertRuleSerializer(AlertRuleSerializer):
     """
-
-    # TODO: These might be slow for many projects, since it will query for each
-    # individually. If we find this to be a problem then we can look into batching.
-    excluded_projects = serializers.ListField(child=ProjectField(), required=False)
-
-    class Meta:
-        model = AlertRuleTrigger
-        fields = [
-            "label",
-            "threshold_type",
-            "alert_threshold",
-            "resolve_threshold",
-            "excluded_projects",
-        ]
-        extra_kwargs = {"label": {"min_length": 1, "max_length": 64}}
-
-    def validate_threshold_type(self, threshold_type):
-        try:
-            return AlertRuleThresholdType(threshold_type)
-        except ValueError:
-            raise serializers.ValidationError(
-                "Invalid threshold type, valid values are %s"
-                % [item.value for item in AlertRuleThresholdType]
-            )
-
-    def create(self, validated_data):
-        try:
-            return create_alert_rule_trigger(
-                alert_rule=self.context["alert_rule"], **validated_data
-            )
-        except AlertRuleTriggerLabelAlreadyUsedError:
-            raise serializers.ValidationError("This label is already in use for this alert rule")
-
-    def _remove_unchanged_fields(self, instance, validated_data):
-        for field_name, value in list(six.iteritems(validated_data)):
-            # Remove any fields that haven't actually changed
-            if field_name == "excluded_projects":
-                excluded_slugs = [
-                    e.query_subscription.project.slug for e in instance.exclusions.all()
-                ]
-                if set(excluded_slugs) == set(project.slug for project in value):
-                    validated_data.pop(field_name)
-                continue
-            if isinstance(value, Enum):
-                value = value.value
-            if getattr(instance, field_name) == value:
-                validated_data.pop(field_name)
-        return validated_data
-
-    def update(self, instance, validated_data):
-        validated_data = self._remove_unchanged_fields(instance, validated_data)
-        try:
-            return update_alert_rule_trigger(instance, **validated_data)
-        except AlertRuleTriggerLabelAlreadyUsedError:
-            raise serializers.ValidationError("This label is already in use for this alert rule")
-
-
-string_to_action_type = {
-    registration.slug: registration.type
-    for registration in AlertRuleTriggerAction.get_registered_types()
-}
-action_target_type_to_string = {
-    AlertRuleTriggerAction.TargetType.USER: "user",
-    AlertRuleTriggerAction.TargetType.TEAM: "team",
-    AlertRuleTriggerAction.TargetType.SPECIFIC: "specific",
-}
-string_to_action_target_type = {v: k for (k, v) in action_target_type_to_string.items()}
-
-
-class AlertRuleTriggerActionSerializer(CamelSnakeModelSerializer):
-    """
-    Serializer for creating/updating a trigger action. Required context:
-     - `trigger`: The trigger related to this action.
-     - `alert_rule`: The alert_rule related to this action.
-     - `organization`: The organization related to this action.
+    Unified Serializer for creating/updating an alert rule - accepts trigger and action data, and does validation on it.
+    Required context:
+     - `organization`: The organization related to this alert rule.
      - `access`: An access object (from `request.access`)
     """
 
-    type = serializers.CharField()
-    target_type = serializers.CharField()
-
-    class Meta:
-        model = AlertRuleTriggerAction
-        fields = ["type", "target_type", "target_identifier", "integration"]
-        extra_kwargs = {
-            "target_identifier": {"required": True},
-            "target_display": {"required": False},
-            "integration": {"required": False, "allow_null": True},
-        }
-
-    def validate_type(self, type):
-        if type not in string_to_action_type:
-            raise serializers.ValidationError(
-                "Invalid type, valid values are [%s]" % ", ".join(string_to_action_type.keys())
-            )
-        return string_to_action_type[type]
-
-    def validate_target_type(self, target_type):
-        if target_type not in string_to_action_target_type:
-            raise serializers.ValidationError(
-                "Invalid targetType, valid values are [%s]"
-                % ", ".join(string_to_action_target_type.keys())
-            )
-        return string_to_action_target_type[target_type]
-
-    def validate(self, attrs):
-        if ("type" in attrs) != ("target_type" in attrs) != ("target_identifier" in attrs):
-            raise serializers.ValidationError(
-                "type, targetType and targetIdentifier must be passed together"
-            )
-        type = attrs.get("type")
-        target_type = attrs.get("target_type")
-        access = self.context["access"]
-        identifier = attrs.get("target_identifier")
-
-        if type is not None:
-            type_info = AlertRuleTriggerAction.get_registered_type(type)
-            if target_type not in type_info.supported_target_types:
-                allowed_target_types = ",".join(
-                    [
-                        action_target_type_to_string[type_name]
-                        for type_name in type_info.supported_target_types
-                    ]
-                )
+    triggers = AlertRuleTriggerSerializer(many=True, required=True)
+
+    class Meta(AlertRuleSerializer.Meta):
+        fields = AlertRuleSerializer.Meta.fields + ["triggers"]
+
+    def validate(self, data):
+        """Performs validation on an alert rule's data
+        This includes ensuring there is either 1 or 2 triggers, which each have actions, and have proper thresholds set.
+        The critical trigger should both alert and resolve 'after' the warning trigger (whether that means > or < the value depends on threshold type).
+        """
+        triggers = data.get("triggers", [])
+        if triggers:
+            if len(triggers) == 1:
+                critical = triggers[0]
+                if critical.get("label", None) != CRITICAL_TRIGGER_LABEL:
+                    raise serializers.ValidationError(
+                        'First trigger must be labeled "%s"' % (CRITICAL_TRIGGER_LABEL)
+                    )
+                if critical["threshold_type"] == AlertRuleThresholdType.ABOVE:
+                    alert_op, trigger_error = (
+                        operator.lt,
+                        "alert threshold must be above resolution threshold",
+                    )
+                elif critical["threshold_type"] == AlertRuleThresholdType.BELOW:
+                    alert_op, trigger_error = (
+                        operator.gt,
+                        "alert threshold must be below resolution threshold",
+                    )
+
+                if alert_op(critical["alert_threshold"], critical["resolve_threshold"]):
+                    raise serializers.ValidationError("Critical " + trigger_error)
+            elif len(triggers) == 2:
+                critical = triggers[0]
+                warning = triggers[1]
+                if (
+                    critical.get("label", None) != CRITICAL_TRIGGER_LABEL
+                    or warning["label"] != WARNING_TRIGGER_LABEL
+                ):
+                    raise serializers.ValidationError(
+                        'First trigger must be labeled "%s", second trigger must be labeled "%s"'
+                        % (CRITICAL_TRIGGER_LABEL, WARNING_TRIGGER_LABEL)
+                    )
+                else:
+                    if critical["threshold_type"] != warning["threshold_type"]:
+                        raise serializers.ValidationError(
+                            "Must have matching threshold types (i.e. critical and warning triggers must both be an upper or lower bound)"
+                        )
+
+                    if critical["threshold_type"] == AlertRuleThresholdType.ABOVE:
+                        alert_op, resolve_op = operator.lt, operator.lt
+                        alert_error = (
+                            "Critical trigger must have an alert threshold above warning trigger"
+                        )
+                        resolve_error = "Critical trigger must have a resolution threshold above (or equal to) warning trigger"
+                        trigger_error = "alert threshold must be above resolution threshold"
+                    elif critical["threshold_type"] == AlertRuleThresholdType.BELOW:
+                        alert_op, resolve_op = operator.gt, operator.gt
+                        alert_error = (
+                            "Critical trigger must have an alert threshold below warning trigger"
+                        )
+                        resolve_error = "Critical trigger must have a resolution threshold below (or equal to) warning trigger"
+                        trigger_error = "alert threshold must be below resolution threshold"
+                    else:
+                        raise serializers.ValidationError(
+                            "Invalid threshold type. Valid values are %s"
+                            % [item.value for item in AlertRuleThresholdType]
+                        )
+
+                    if alert_op(critical["alert_threshold"], warning["alert_threshold"]):
+                        raise serializers.ValidationError(alert_error)
+                    elif resolve_op(critical["resolve_threshold"], warning["resolve_threshold"]):
+                        raise serializers.ValidationError(resolve_error)
+
+                    if alert_op(critical["alert_threshold"], critical["resolve_threshold"]):
+                        raise serializers.ValidationError("Critical " + trigger_error)
+                    elif alert_op(warning["alert_threshold"], warning["resolve_threshold"]):
+                        raise serializers.ValidationError("Warning " + trigger_error)
+            else:
                 raise serializers.ValidationError(
-                    {
-                        "target_type": "Invalid target type for %s. Valid types are [%s]"
-                        % (type_info.slug, allowed_target_types)
-                    }
+                    "Must send 1 or 2 triggers - A critical trigger, and an optional warning trigger"
                 )
 
-        if attrs.get("type") == AlertRuleTriggerAction.Type.EMAIL:
-            if target_type == AlertRuleTriggerAction.TargetType.TEAM:
-                try:
-                    team = Team.objects.get(id=identifier)
-                except Team.DoesNotExist:
-                    raise serializers.ValidationError("Team does not exist")
-                if not access.has_team(team):
-                    raise serializers.ValidationError("Team does not exist")
-            elif target_type == AlertRuleTriggerAction.TargetType.USER:
-                try:
-                    user = User.objects.get(id=identifier)
-                except User.DoesNotExist:
-                    raise serializers.ValidationError("User does not exist")
-
-                if not OrganizationMember.objects.filter(
-                    organization=self.context["organization"], user=user
-                ).exists():
-                    raise serializers.ValidationError("User does not belong to this organization")
-        elif attrs.get("type") == AlertRuleTriggerAction.Type.SLACK:
-            if not attrs.get("integration"):
-                raise serializers.ValidationError(
-                    {"integration": "Integration must be provided for slack"}
-                )
+            # Triggers have passed checks. Check that all triggers have at least one action now.
+            for trigger in triggers:
+                actions = trigger.get("actions", [])
+                if actions == []:
+                    raise serializers.ValidationError(
+                        '"' + trigger["label"] + '" trigger must have an action.'
+                    )
+        else:
+            raise serializers.ValidationError("Must include at least one trigger")
 
-        return attrs
+        return super(UnifiedAlertRuleSerializer, self)._handle_old_fields_transition(data)
 
     def create(self, validated_data):
-        return create_alert_rule_trigger_action(trigger=self.context["trigger"], **validated_data)
-
-    def _remove_unchanged_fields(self, instance, validated_data):
-        changed = False
-        if (
-            validated_data.get("type", instance.type) == AlertRuleTriggerAction.Type.SLACK.value
-            and validated_data["target_identifier"] != instance.target_display
-        ):
-            changed = True
-        for field_name, value in list(six.iteritems(validated_data)):
-            # Remove any fields that haven't actually changed
-            if isinstance(value, Enum):
-                value = value.value
-            if getattr(instance, field_name) != value:
-                changed = True
-                break
-        return validated_data if changed else {}
+        with transaction.atomic():
+            try:
+                # TODO: Remove this, just temporary while we're supporting both fields.
+                if "aggregation" not in validated_data:
+                    raise serializers.ValidationError("aggregation is required")
+
+                triggers_data = validated_data.pop("triggers")
+                # TODO: User super.create and don't duplicate the aggreagation + duplicate name check?
+                alert_rule = create_alert_rule(
+                    organization=self.context["organization"], **validated_data
+                )
+                for trigger_data in triggers_data:
+                    trigger_actions_data = trigger_data.pop("actions")
+                    trigger = create_alert_rule_trigger(alert_rule=alert_rule, **trigger_data)
+                    for actions_data in trigger_actions_data:
+                        create_alert_rule_trigger_action(trigger=trigger, **actions_data)
+                return alert_rule
+            except AlertRuleNameAlreadyUsedError:
+                raise serializers.ValidationError("This name is already in use for this project")
 
     def update(self, instance, validated_data):
-        validated_data = self._remove_unchanged_fields(instance, validated_data)
-        return update_alert_rule_trigger_action(instance, **validated_data)
+        with transaction.atomic():
+            validated_data = self._remove_unchanged_fields(instance, validated_data)
+            triggers_data = validated_data.pop("triggers")
+            alert_rule = update_alert_rule(instance, **validated_data)
+
+            # Delete triggers we don't have present in the updated data.
+            trigger_ids = [x["id"] for x in triggers_data]
+            AlertRuleTrigger.objects.filter(alert_rule=alert_rule).exclude(
+                id__in=trigger_ids
+            ).delete()
+
+            for trigger_data in triggers_data:
+                actions_data = trigger_data.pop("actions")
+                try:
+                    if "id" in trigger_data:
+                        trigger_instance = AlertRuleTrigger.objects.get(
+                            alert_rule=alert_rule, id=trigger_data["id"]
+                        )
+                        trigger_data.pop("id")
+                        trigger = update_alert_rule_trigger(trigger_instance, **trigger_data)
+                    else:
+                        trigger = create_alert_rule_trigger(alert_rule=alert_rule, **trigger_data)
+                except AlertRuleTriggerLabelAlreadyUsedError:
+                    raise serializers.ValidationError(
+                        "This trigger label is already in use for this alert rule"
+                    )
+
+                # Delete actions we don't have present in the updated data.
+                action_ids = [x["id"] for x in actions_data]
+                AlertRuleTriggerAction.objects.filter(alert_rule_trigger=trigger).exclude(
+                    id__in=action_ids
+                ).delete()
+
+                for action_data in actions_data:
+                    if "id" in action_data:
+                        action_instance = AlertRuleTriggerAction.objects.get(
+                            alert_rule_trigger=trigger, id=action_data["id"]
+                        )
+                        action_data.pop("id")
+                        update_alert_rule_trigger_action(action_instance, **action_data)
+                    else:
+                        create_alert_rule_trigger_action(trigger=trigger, **action_data)
+
+            return alert_rule
diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index 1933f53f0a..9cf486ea5e 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -602,6 +602,7 @@ def create_alert_rule(
     threshold_period,
     include_all_projects=False,
     excluded_projects=None,
+    triggers=None,
 ):
     """
     Creates an alert rule for an organization.
@@ -664,6 +665,7 @@ def update_alert_rule(
     threshold_period=None,
     include_all_projects=None,
     excluded_projects=None,
+    triggers=None,
 ):
     """
     Updates an alert rule.
@@ -863,6 +865,7 @@ def create_alert_rule_trigger(
     alert_threshold,
     resolve_threshold=None,
     excluded_projects=None,
+    actions=None,
 ):
     """
     Creates a new AlertRuleTrigger
@@ -908,6 +911,7 @@ def update_alert_rule_trigger(
     alert_threshold=None,
     resolve_threshold=None,
     excluded_projects=None,
+    actions=None,
 ):
     """
     :param trigger: The AlertRuleTrigger to update
diff --git a/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py b/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py
index 754c9e7521..0b15814aca 100644
--- a/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py
+++ b/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py
@@ -1,12 +1,17 @@
 from __future__ import absolute_import
 
+import six
+
+from copy import deepcopy
+
 from exam import fixture
 
+
 from sentry.api.serializers import serialize
 from sentry.api.serializers.models.alert_rule import DetailedAlertRuleSerializer
-from sentry.incidents.logic import create_alert_rule
+from sentry.auth.access import OrganizationGlobalAccess
+from sentry.incidents.endpoints.serializers import UnifiedAlertRuleSerializer
 from sentry.incidents.models import AlertRule
-from sentry.snuba.models import QueryAggregations
 from sentry.testutils import APITestCase
 
 
@@ -26,17 +31,70 @@ class AlertRuleDetailsBase(object):
         return self.create_user()
 
     @fixture
-    def alert_rule(self):
-        return create_alert_rule(
-            self.organization,
-            [self.project],
-            "hello",
-            "level:error",
-            QueryAggregations.TOTAL,
-            10,
-            1,
+    def alert_rule_dict(self):
+        return {
+            "aggregation": 0,
+            "aggregations": [0],
+            "query": "",
+            "timeWindow": "300",
+            "projects": [self.project.slug],
+            "name": "JustAValidTestRule",
+            "triggers": [
+                {
+                    "label": "critical",
+                    "alertThreshold": 200,
+                    "resolveThreshold": 100,
+                    "thresholdType": 0,
+                    "actions": [
+                        {"type": "email", "targetType": "team", "targetIdentifier": self.team.id}
+                    ],
+                },
+                {
+                    "label": "warning",
+                    "alertThreshold": 150,
+                    "resolveThreshold": 100,
+                    "thresholdType": 0,
+                    "actions": [
+                        {"type": "email", "targetType": "team", "targetIdentifier": self.team.id},
+                        {"type": "email", "targetType": "user", "targetIdentifier": self.user.id},
+                    ],
+                },
+            ],
+        }
+
+    def new_alert_rule(self, data=None):
+        if data is None:
+            data = deepcopy(self.alert_rule_dict)
+
+        serializer = UnifiedAlertRuleSerializer(
+            context={
+                "organization": self.organization,
+                "access": OrganizationGlobalAccess(self.organization),
+            },
+            data=data,
         )
 
+        assert serializer.is_valid()
+        alert_rule = serializer.save()
+        return alert_rule
+
+    def get_serialized_alert_rule(self):
+        # Only call after calling self.alert_rule to create it.
+        original_endpoint = self.endpoint
+        original_method = self.method
+        self.endpoint = "sentry-api-0-organization-alert-rules"
+        self.method = "get"
+        with self.feature("organizations:incidents"):
+            resp = self.get_valid_response(self.organization.slug)
+            serialized_alert_rule = resp.data[0]
+        self.endpoint = original_endpoint
+        self.method = original_method
+        return serialized_alert_rule
+
+    @fixture
+    def alert_rule(self):
+        return self.new_alert_rule(data=deepcopy(self.alert_rule_dict))
+
     def test_invalid_rule_id(self):
         self.create_member(
             user=self.user, organization=self.organization, role="owner", teams=[self.team]
@@ -83,11 +141,18 @@ class AlertRuleDetailsPutEndpointTest(AlertRuleDetailsBase, APITestCase):
         )
 
         self.login_as(self.user)
+        alert_rule = self.alert_rule
+        # We need the IDs to force update instead of create, so we just get the rule using our own API. Like frontend would.
+        serialized_alert_rule = self.get_serialized_alert_rule()
+        serialized_alert_rule["name"] = "what"
+
         with self.feature("organizations:incidents"):
-            resp = self.get_valid_response(self.organization.slug, self.alert_rule.id, name="what")
+            resp = self.get_valid_response(
+                self.organization.slug, alert_rule.id, **serialized_alert_rule
+            )
 
-        self.alert_rule.name = "what"
-        assert resp.data == serialize(self.alert_rule)
+        alert_rule.name = "what"
+        assert resp.data == serialize(alert_rule)
         assert resp.data["name"] == "what"
 
     def test_not_updated_fields(self):
@@ -96,9 +161,13 @@ class AlertRuleDetailsPutEndpointTest(AlertRuleDetailsBase, APITestCase):
         )
 
         self.login_as(self.user)
+        alert_rule = self.alert_rule
+        # We need the IDs to force update instead of create, so we just get the rule using our own API. Like frontend would.
+        serialized_alert_rule = self.get_serialized_alert_rule()
+
         with self.feature("organizations:incidents"):
             resp = self.get_valid_response(
-                self.organization.slug, self.alert_rule.id, aggregation=self.alert_rule.aggregation
+                self.organization.slug, alert_rule.id, **serialized_alert_rule
             )
 
         existing_sub = self.alert_rule.query_subscriptions.first()
@@ -110,6 +179,160 @@ class AlertRuleDetailsPutEndpointTest(AlertRuleDetailsBase, APITestCase):
         updated_sub = AlertRule.objects.get(id=self.alert_rule.id).query_subscriptions.first()
         assert updated_sub.subscription_id == existing_sub.subscription_id
 
+    def test_update_trigger_label_to_unallowed_value(self):
+        self.create_member(
+            user=self.user, organization=self.organization, role="owner", teams=[self.team]
+        )
+
+        self.login_as(self.user)
+
+        alert_rule = self.alert_rule
+        # We need the IDs to force update instead of create, so we just get the rule using our own API. Like frontend would.
+        serialized_alert_rule = self.get_serialized_alert_rule()
+        serialized_alert_rule["triggers"][0]["label"] = "goodbye"
+
+        with self.feature("organizations:incidents"):
+            resp = self.get_valid_response(
+                self.organization.slug, alert_rule.id, status_code=400, **serialized_alert_rule
+            )
+            assert resp.data == {
+                "nonFieldErrors": [
+                    'First trigger must be labeled "critical", second trigger must be labeled "warning"'
+                ]
+            }
+
+    def test_update_trigger_alert_threshold(self):
+        self.create_member(
+            user=self.user, organization=self.organization, role="owner", teams=[self.team]
+        )
+
+        self.login_as(self.user)
+        alert_rule = self.alert_rule
+        # We need the IDs to force update instead of create, so we just get the rule using our own API. Like frontend would.
+        serialized_alert_rule = self.get_serialized_alert_rule()
+
+        serialized_alert_rule["triggers"][1]["alertThreshold"] = 125
+        serialized_alert_rule["name"] = "AUniqueName"
+
+        with self.feature("organizations:incidents"):
+            resp = self.get_valid_response(
+                self.organization.slug, alert_rule.id, **serialized_alert_rule
+            )
+
+        assert resp.data["name"] == "AUniqueName"
+        assert resp.data["triggers"][1]["alertThreshold"] == 125
+
+    def test_delete_trigger(self):
+        self.create_member(
+            user=self.user, organization=self.organization, role="owner", teams=[self.team]
+        )
+
+        self.login_as(self.user)
+        alert_rule = self.alert_rule
+        # We need the IDs to force update instead of create, so we just get the rule using our own API. Like frontend would.
+        serialized_alert_rule = self.get_serialized_alert_rule()
+
+        serialized_alert_rule["triggers"].pop(1)
+
+        with self.feature("organizations:incidents"):
+            resp = self.get_valid_response(
+                self.organization.slug, alert_rule.id, **serialized_alert_rule
+            )
+
+        assert len(resp.data["triggers"]) == 1
+
+    def test_delete_action(self):
+        self.create_member(
+            user=self.user, organization=self.organization, role="owner", teams=[self.team]
+        )
+
+        self.login_as(self.user)
+        alert_rule = self.alert_rule
+        # We need the IDs to force update instead of create, so we just get the rule using our own API. Like frontend would.
+        serialized_alert_rule = self.get_serialized_alert_rule()
+
+        serialized_alert_rule["triggers"][1]["actions"].pop(1)
+
+        with self.feature("organizations:incidents"):
+            resp = self.get_valid_response(
+                self.organization.slug, alert_rule.id, **serialized_alert_rule
+            )
+
+        assert len(resp.data["triggers"][1]["actions"]) == 1
+
+        # Delete the last one, make sure API errors since we have to have an action.
+        serialized_alert_rule["triggers"][1]["actions"].pop()
+
+        with self.feature("organizations:incidents"):
+            resp = self.get_response(self.organization.slug, alert_rule.id, **serialized_alert_rule)
+            assert resp.status_code == 400
+
+    def test_update_trigger_action_type(self):
+        self.create_member(
+            user=self.user, organization=self.organization, role="owner", teams=[self.team]
+        )
+
+        self.login_as(self.user)
+
+        alert_rule = self.alert_rule
+        # We need the IDs to force update instead of create, so we just get the rule using our own API. Like frontend would.
+        serialized_alert_rule = self.get_serialized_alert_rule()
+
+        # Then we send it back with one of the actions changed:
+        serialized_alert_rule["triggers"][0]["actions"][0]["targetType"] = "user"
+        serialized_alert_rule["triggers"][0]["actions"][0]["targetIdentifier"] = self.user.id
+
+        with self.feature("organizations:incidents"):
+            resp = self.get_valid_response(
+                self.organization.slug, alert_rule.id, **serialized_alert_rule
+            )
+
+        # And it comes back successfully changed:
+        assert resp.data["triggers"][0]["actions"][0]["targetType"] == "user"
+        assert resp.data["triggers"][0]["actions"][0]["targetIdentifier"] == six.binary_type(
+            self.user.id
+        )
+
+        # And make sure we still only have two triggers, the first with 1 action and the second with 2 actions
+        # This is ensures they were updated and not new ones created, etc.
+        assert len(resp.data["triggers"]) == 2
+        assert len(resp.data["triggers"][0]["actions"]) == 1
+        assert len(resp.data["triggers"][1]["actions"]) == 2
+
+    def test_invalid_thresholds(self):
+        self.create_member(
+            user=self.user, organization=self.organization, role="owner", teams=[self.team]
+        )
+        self.login_as(self.user)
+        alert_rule = self.alert_rule
+        # We need the IDs to force update instead of create, so we just get the rule using our own API. Like frontend would.
+        serialized_alert_rule = self.get_serialized_alert_rule()
+
+        serialized_alert_rule["triggers"][0]["alertThreshold"] = 50  # Invalid
+        with self.feature("organizations:incidents"):
+            self.get_valid_response(
+                self.organization.slug, alert_rule.id, status_code=400, **serialized_alert_rule
+            )
+        serialized_alert_rule["triggers"][0]["alertThreshold"] = 200  # Back to normal, valid.
+
+        serialized_alert_rule["triggers"][0][
+            "resolveThreshold"
+        ] = 50  # Invalid, less than warning resolve threshold.
+        with self.feature("organizations:incidents"):
+            self.get_valid_response(
+                self.organization.slug, alert_rule.id, status_code=400, **serialized_alert_rule
+            )
+        serialized_alert_rule["triggers"][0]["resolveThreshold"] = 100  # Back to normal, valid.
+
+        serialized_alert_rule["triggers"][0][
+            "thresholdType"
+        ] = 1  # Invalid, different than other trigger.
+        with self.feature("organizations:incidents"):
+            self.get_valid_response(
+                self.organization.slug, alert_rule.id, status_code=400, **serialized_alert_rule
+            )
+        serialized_alert_rule["triggers"][0]["thresholdType"] = 0  # Back to normal, valid.
+
 
 class AlertRuleDetailsDeleteEndpointTest(AlertRuleDetailsBase, APITestCase):
     method = "delete"
diff --git a/tests/sentry/incidents/endpoints/test_organization_alert_rule_index.py b/tests/sentry/incidents/endpoints/test_organization_alert_rule_index.py
index 7ce32b3153..3dc6739ce2 100644
--- a/tests/sentry/incidents/endpoints/test_organization_alert_rule_index.py
+++ b/tests/sentry/incidents/endpoints/test_organization_alert_rule_index.py
@@ -9,6 +9,8 @@ from sentry.incidents.models import AlertRule
 from sentry.snuba.models import QueryAggregations
 from sentry.testutils import APITestCase
 
+# from sentry.incidents.endpoints.serializers import CRITICAL_TRIGGER_LABEL, WARNING_TRIGGER_LABEL
+
 
 class AlertRuleListEndpointTest(APITestCase):
     endpoint = "sentry-api-0-organization-alert-rules"
@@ -72,23 +74,186 @@ class AlertRuleCreateEndpointTest(APITestCase):
             user=self.user, organization=self.organization, role="owner", teams=[self.team]
         )
         self.login_as(self.user)
+        valid_alert_rule = {
+            "aggregation": 0,
+            "aggregations": [0],
+            "query": "",
+            "timeWindow": "300",
+            "triggers": [
+                {
+                    "label": "critical",
+                    "alertThreshold": 200,
+                    "resolveThreshold": 100,
+                    "thresholdType": 0,
+                    "actions": [
+                        {"type": "email", "targetType": "team", "targetIdentifier": self.team.id}
+                    ],
+                },
+                {
+                    "label": "warning",
+                    "alertThreshold": 150,
+                    "resolveThreshold": 100,
+                    "thresholdType": 0,
+                    "actions": [
+                        {"type": "email", "targetType": "team", "targetIdentifier": self.team.id},
+                        {"type": "email", "targetType": "user", "targetIdentifier": self.user.id},
+                    ],
+                },
+            ],
+            "projects": [self.project.slug],
+            "name": "JustAValidTestRule",
+        }
         with self.feature("organizations:incidents"):
             resp = self.get_valid_response(
-                self.organization.slug,
-                projects=[self.project.slug],
-                name="an alert",
-                thresholdType=1,
-                query="hi",
-                aggregation=0,
-                timeWindow=10,
-                alertThreshold=1000,
-                resolveThreshold=300,
-                status_code=201,
+                self.organization.slug, status_code=201, **valid_alert_rule
+            )
+        assert "id" in resp.data
+        alert_rule = AlertRule.objects.get(id=resp.data["id"])
+        assert resp.data == serialize(alert_rule, self.user)
+
+    def test_no_label(self):
+        self.create_member(
+            user=self.user, organization=self.organization, role="owner", teams=[self.team]
+        )
+        self.login_as(self.user)
+        rule_one_trigger_no_label = {
+            "aggregation": 0,
+            "aggregations": [0],
+            "query": "",
+            "timeWindow": "300",
+            "projects": [self.project.slug],
+            "name": "OneTriggerOnlyCritical",
+            "triggers": [
+                {
+                    "alertThreshold": 200,
+                    "resolveThreshold": 100,
+                    "thresholdType": 1,
+                    "actions": [
+                        {"type": "email", "targetType": "team", "targetIdentifier": self.team.id}
+                    ],
+                }
+            ],
+        }
+
+        with self.feature("organizations:incidents"):
+            self.get_valid_response(
+                self.organization.slug, status_code=400, **rule_one_trigger_no_label
+            )
+
+    def test_only_critical_trigger(self):
+        self.create_member(
+            user=self.user, organization=self.organization, role="owner", teams=[self.team]
+        )
+        self.login_as(self.user)
+        rule_one_trigger_only_critical = {
+            "aggregation": 0,
+            "aggregations": [0],
+            "query": "",
+            "timeWindow": "300",
+            "projects": [self.project.slug],
+            "name": "OneTriggerOnlyCritical",
+            "triggers": [
+                {
+                    "label": "critical",
+                    "alertThreshold": 100,
+                    "resolveThreshold": 200,
+                    "thresholdType": 1,
+                    "actions": [
+                        {"type": "email", "targetType": "team", "targetIdentifier": self.team.id}
+                    ],
+                }
+            ],
+        }
+        with self.feature("organizations:incidents"):
+            resp = self.get_valid_response(
+                self.organization.slug, status_code=201, **rule_one_trigger_only_critical
             )
         assert "id" in resp.data
         alert_rule = AlertRule.objects.get(id=resp.data["id"])
         assert resp.data == serialize(alert_rule, self.user)
 
+    def test_no_triggers(self):
+        self.create_member(
+            user=self.user, organization=self.organization, role="owner", teams=[self.team]
+        )
+        self.login_as(self.user)
+
+        rule_no_triggers = {
+            "aggregation": 0,
+            "aggregations": [0],
+            "query": "",
+            "timeWindow": "300",
+            "projects": [self.project.slug],
+            "name": "JustATestRuleWithNoTriggers",
+        }
+
+        with self.feature("organizations:incidents"):
+            resp = self.get_valid_response(
+                self.organization.slug, status_code=400, **rule_no_triggers
+            )
+            assert resp.data == {"triggers": [u"This field is required."]}
+
+    def test_no_critical_trigger(self):
+        self.create_member(
+            user=self.user, organization=self.organization, role="owner", teams=[self.team]
+        )
+        self.login_as(self.user)
+
+        rule_one_trigger_only_warning = {
+            "aggregation": 0,
+            "aggregations": [0],
+            "query": "",
+            "timeWindow": "300",
+            "projects": [self.project.slug],
+            "name": "JustATestRule",
+            "triggers": [
+                {
+                    "label": "warning",
+                    "alertThreshold": 200,
+                    "resolveThreshold": 100,
+                    "thresholdType": 1,
+                    "actions": [
+                        {"type": "email", "targetType": "team", "targetIdentifier": self.team.id}
+                    ],
+                }
+            ],
+        }
+
+        with self.feature("organizations:incidents"):
+            resp = self.get_valid_response(
+                self.organization.slug, status_code=400, **rule_one_trigger_only_warning
+            )
+            assert resp.data == {"nonFieldErrors": [u'First trigger must be labeled "critical"']}
+
+    def test_critical_trigger_no_action(self):
+        self.create_member(
+            user=self.user, organization=self.organization, role="owner", teams=[self.team]
+        )
+        self.login_as(self.user)
+
+        rule_one_trigger_only_critical_no_action = {
+            "aggregation": 0,
+            "aggregations": [0],
+            "query": "",
+            "timeWindow": "300",
+            "projects": [self.project.slug],
+            "name": "JustATestRule",
+            "triggers": [
+                {
+                    "label": "critical",
+                    "alertThreshold": 200,
+                    "resolveThreshold": 100,
+                    "thresholdType": 1,
+                }
+            ],
+        }
+
+        with self.feature("organizations:incidents"):
+            resp = self.get_valid_response(
+                self.organization.slug, status_code=400, **rule_one_trigger_only_critical_no_action
+            )
+            assert resp.data == {"triggers": [{"actions": [u"This field is required."]}]}
+
     def test_invalid_projects(self):
         self.create_member(
             user=self.user, organization=self.organization, role="owner", teams=[self.team]
@@ -97,6 +262,7 @@ class AlertRuleCreateEndpointTest(APITestCase):
         with self.feature("organizations:incidents"):
             resp = self.get_valid_response(
                 self.organization.slug,
+                status_code=400,
                 projects=[
                     self.project.slug,
                     self.create_project(organization=self.create_organization()).slug,
@@ -107,10 +273,24 @@ class AlertRuleCreateEndpointTest(APITestCase):
                 aggregation=0,
                 timeWindow=10,
                 alertThreshold=1000,
-                resolveThreshold=300,
-                status_code=400,
+                resolveThreshold=100,
+                triggers=[
+                    {
+                        "label": "critical",
+                        "alertThreshold": 200,
+                        "resolveThreshold": 100,
+                        "thresholdType": 1,
+                        "actions": [
+                            {
+                                "type": "email",
+                                "targetType": "team",
+                                "targetIdentifier": self.team.id,
+                            }
+                        ],
+                    }
+                ],
             )
-        assert resp.data == {"projects": [u"Invalid project"]}
+            assert resp.data == {"projects": [u"Invalid project"]}
 
     def test_no_feature(self):
         self.create_member(
diff --git a/tests/sentry/incidents/endpoints/test_organization_alert_rule_trigger_index.py b/tests/sentry/incidents/endpoints/test_organization_alert_rule_trigger_index.py
index bf7d752f9d..3ed548bdd1 100644
--- a/tests/sentry/incidents/endpoints/test_organization_alert_rule_trigger_index.py
+++ b/tests/sentry/incidents/endpoints/test_organization_alert_rule_trigger_index.py
@@ -78,6 +78,7 @@ class AlertRuleTriggerCreateEndpointTest(APITestCase):
                 thresholdType=1,
                 alertThreshold=1000,
                 resolveThreshold=300,
+                actions=[],
                 status_code=201,
             )
         assert "id" in resp.data
@@ -101,6 +102,7 @@ class AlertRuleTriggerCreateEndpointTest(APITestCase):
                     self.project.slug,
                     self.create_project(organization=self.create_organization()).slug,
                 ],
+                actions=[],
                 status_code=400,
             )
         assert resp.data == {"excludedProjects": [u"Invalid project"]}
diff --git a/tests/sentry/incidents/endpoints/test_serializers.py b/tests/sentry/incidents/endpoints/test_serializers.py
index bb763ac126..f438c79427 100644
--- a/tests/sentry/incidents/endpoints/test_serializers.py
+++ b/tests/sentry/incidents/endpoints/test_serializers.py
@@ -180,6 +180,7 @@ class TestAlertRuleTriggerSerializer(TestCase):
             "resolve_threshold": 1,
             "alert_threshold": 0,
             "excluded_projects": [self.project.slug],
+            "actions": [{"type": "email", "targetType": "team", "targetIdentifier": self.team.id}],
         }
 
     @fixture
@@ -209,6 +210,7 @@ class TestAlertRuleTriggerSerializer(TestCase):
             "label": field_is_required,
             "thresholdType": field_is_required,
             "alertThreshold": field_is_required,
+            "actions": field_is_required,
         }
 
     def test_threshold_type(self):

commit 4d7fbc1f064a9d7ef3a1058ec6a3dbfb59993194
Author: David Cramer <dcramer@gmail.com>
Date:   Mon Feb 11 20:04:38 2013 -0800

    Refactor Stacktrace interface so its easier to manage

diff --git a/src/sentry/coreapi.py b/src/sentry/coreapi.py
index c5e4817227..d4c87f249d 100644
--- a/src/sentry/coreapi.py
+++ b/src/sentry/coreapi.py
@@ -28,6 +28,8 @@ from sentry.utils import is_float, json
 from sentry.utils.auth import parse_auth_header
 from sentry.utils.imports import import_string
 from sentry.utils.queue import maybe_delay
+from sentry.utils.strings import decompress
+
 
 logger = logging.getLogger('sentry.coreapi.errors')
 
@@ -226,7 +228,7 @@ def project_from_id(request):
 def decode_and_decompress_data(encoded_data):
     try:
         try:
-            return base64.b64decode(encoded_data).decode('zlib')
+            return decompress(encoded_data)
         except zlib.error:
             return base64.b64decode(encoded_data)
     except Exception, e:
diff --git a/src/sentry/interfaces.py b/src/sentry/interfaces.py
index c1973aee3f..b6b802c6d2 100644
--- a/src/sentry/interfaces.py
+++ b/src/sentry/interfaces.py
@@ -11,6 +11,7 @@ validated and rendered.
 
 import itertools
 import urlparse
+import warnings
 
 from pygments import highlight
 # from pygments.lexers import get_lexer_for_filename, TextLexer, ClassNotFound
@@ -100,6 +101,11 @@ class Interface(object):
         self.attrs = kwargs.keys()
         self.__dict__.update(kwargs)
 
+    def __eq__(self, other):
+        if type(self) != type(other):
+            return False
+        return self.serialize() == other.serialize()
+
     def __setstate__(self, data):
         kwargs = self.unserialize(data)
         self.attrs = kwargs.keys()
@@ -230,6 +236,125 @@ class Query(Interface):
         }
 
 
+class Frame(object):
+    def __init__(self, abs_path=None, filename=None, lineno=None, colno=None, in_app=False,
+                 context_line=None, pre_context=(), post_context=(), vars=None,
+                 module=None, function=None, data=None):
+        self.abs_path = abs_path or filename
+        self.filename = filename or abs_path
+
+        if self.is_url():
+            urlparts = urlparse.urlparse(self.abs_path)
+            if urlparts.path:
+                self.filename = urlparts.path
+
+        self.module = module
+        self.function = function
+
+        if lineno is not None:
+            self.lineno = int(lineno)
+        else:
+            self.lineno = None
+        if colno is not None:
+            self.colno = int(colno)
+        else:
+            self.colno = None
+
+        self.in_app = bool(in_app)
+        self.context_line = context_line
+        self.pre_context = pre_context
+        self.post_context = post_context
+        self.vars = vars or {}
+        self.data = data or {}
+
+    def __getitem__(self, key):
+        warnings.warn('Frame[key] is deprecated. Use Frame.key instead.', DeprecationWarning)
+        return getattr(self, key)
+
+    def is_url(self):
+        if not self.abs_path:
+            return False
+        return is_url(self.abs_path)
+
+    def is_valid(self):
+        return self.filename or self.function or self.module
+
+    def get_hash(self):
+        output = []
+        if self.module:
+            output.append(self.module)
+        elif self.filename and not self.is_url():
+            output.append(self.filename)
+
+        if self.context_line:
+            output.append(self.context_line)
+        elif self.function:
+            output.append(self.function)
+        elif self.lineno is not None:
+            output.append(self.lineno)
+        return output
+
+    def get_context(self, event, is_public=False, **kwargs):
+        if (self.context_line and self.lineno is not None
+            and (self.pre_context or self.post_context)):
+            context = get_context(
+                lineno=self.lineno,
+                context_line=self.context_line,
+                pre_context=self.pre_context,
+                post_context=self.post_context,
+                filename=self.filename or self.module,
+                format=True,
+            )
+            start_lineno = context[0][0]
+        else:
+            context = []
+            start_lineno = None
+
+        frame_data = {
+            'abs_path': self.abs_path,
+            'filename': self.filename,
+            'module': self.module,
+            'function': self.function,
+            'start_lineno': start_lineno,
+            'lineno': self.lineno,
+            'context': context,
+            'context_line': self.context_line,
+            'in_app': self.in_app,
+            'is_url': self.is_url(),
+        }
+        if not is_public:
+            frame_data['vars'] = self.vars or {}
+
+        if event.platform == 'javascript' and self.data:
+            frame_data.update({
+                'sourcemap': self.data['sourcemap'].rsplit('/', 1)[-1],
+                'sourcemap_url': urlparse.urljoin(self.abs_path, self.data['sourcemap']),
+                'orig_function': self.data['orig_function'],
+                'orig_filename': self.data['orig_filename'],
+                'orig_lineno': self.data['orig_lineno'],
+                'orig_colno': self.data['orig_colno'],
+            })
+        return frame_data
+
+    def to_string(self):
+        result = []
+        if self.filename:
+            pieces = ['  File "%s"' % (self.filename,)]
+        elif self.module:
+            pieces = ['  Module "%s"' % (self.module,)]
+        else:
+            pieces = ['  ?']
+        if self.lineno is not None:
+            pieces.append(', line %d' % (self.lineno,))
+        if self.function:
+            pieces.append(', in %s' % (self.function,))
+
+        result = ''.join(pieces)
+        if self.context_line is not None:
+            result += '\n    %s' % (self.context_line.strip(),)
+        return result
+
+
 class Stacktrace(Interface):
     """
     A stacktrace contains a list of frames, each with various bits (most optional)
@@ -304,46 +429,16 @@ class Stacktrace(Interface):
     score = 1000
 
     def __init__(self, frames):
-        self.frames = frames
-        for frame in frames:
-            # if for some reason the user provided abs_path but not filename
-            # let it through and fix it for them
-            if 'abs_path' in frame and 'filename' not in frame:
-                frame['filename'] = frame.pop('abs_path', None)
-
-            # lineno should be an int
-            if 'lineno' in frame:
-                if frame['lineno'] is None:
-                    del frame['lineno']
-                else:
-                    frame['lineno'] = int(frame['lineno'])
-
-            # colno should be an int
-            if 'colno' in frame:
-                if frame['colno'] is None:
-                    del frame['colno']
-                else:
-                    frame['colno'] = int(frame['colno'])
-
-            # in_app should be a boolean
-            if 'in_app' in frame:
-                frame['in_app'] = bool(frame['in_app'])
-
-            abs_path = frame.get('abs_path') or frame.get('filename')
-            if abs_path and is_url(abs_path):
-                urlparts = urlparse.urlparse(abs_path)
-                if urlparts.path:
-                    frame['abs_path'] = abs_path
-                    frame['filename'] = urlparts.path
+        self.frames = [Frame(**f) for f in frames]
 
     def validate(self):
         for frame in self.frames:
             # ensure we've got the correct required values
-            assert frame.get('filename') or frame.get('function') or frame.get('module')
+            assert frame.is_valid()
 
     def serialize(self):
         return {
-            'frames': self.frames,
+            'frames': [vars(f) for f in self.frames],
         }
 
     def get_composite_hash(self, interfaces):
@@ -359,25 +454,7 @@ class Stacktrace(Interface):
     def get_hash(self):
         output = []
         for frame in self.frames:
-            output.extend(self.get_frame_hash(frame))
-        return output
-
-    def get_frame_hash(self, frame):
-        output = []
-        filename = frame.get('filename')
-        abs_path = frame.get('abs_path') or filename
-        if frame.get('module'):
-            output.append(frame['module'])
-        # We only include the filename
-        elif filename and not is_url(abs_path):
-            output.append(filename)
-
-        if frame.get('context_line'):
-            output.append(frame['context_line'])
-        elif frame.get('function'):
-            output.append(frame['function'])
-        elif frame.get('lineno'):
-            output.append(frame['lineno'])
+            output.extend(frame.get_hash())
         return output
 
     def is_newest_frame_first(self, event):
@@ -397,61 +474,6 @@ class Stacktrace(Interface):
 
         return newest_first
 
-    def get_frame_context(self, frame, event, is_public=False, **kwargs):
-        if (frame.get('context_line') and frame.get('lineno') is not None
-            and (frame.get('pre_context') or frame.get('post_context'))):
-            context = get_context(
-                lineno=frame['lineno'],
-                context_line=frame['context_line'],
-                pre_context=frame.get('pre_context'),
-                post_context=frame.get('post_context'),
-                filename=frame.get('abs_path') or frame.get('filename') or frame.get('module'),
-                format=True,
-            )
-            start_lineno = context[0][0]
-        else:
-            context = []
-            start_lineno = None
-
-        if frame.get('lineno') is not None:
-            lineno = int(frame['lineno'])
-        else:
-            lineno = None
-        if frame.get('colno') is not None:
-            colno = int(frame['colno'])
-        else:
-            colno = None
-
-        in_app = bool(frame.get('in_app', True))
-
-        frame_data = {
-            'abs_path': frame.get('abs_path'),
-            'filename': frame.get('filename'),
-            'module': frame.get('module'),
-            'function': frame.get('function'),
-            'start_lineno': start_lineno,
-            'lineno': lineno,
-            'colno': colno,
-            'context': context,
-            'context_line': frame.get('context_line'),
-            'in_app': in_app,
-            'is_url': is_url(frame.get('abs_path') or ''),
-        }
-        if not is_public:
-            frame_data['vars'] = frame.get('vars') or []
-
-        if event.platform == 'javascript' and frame.get('data'):
-            data = frame['data']
-            frame_data.update({
-                'sourcemap': data['sourcemap'].rsplit('/', 1)[-1],
-                'sourcemap_url': urlparse.urljoin(frame['abs_path'], data['sourcemap']),
-                'orig_filename': data['orig_filename'],
-                'orig_function': data['orig_function'],
-                'orig_lineno': data['orig_lineno'],
-                'orig_colno': data['orig_colno'],
-            })
-        return frame_data
-
     def to_html(self, event, is_public=False, **kwargs):
         if not self.frames:
             return ''
@@ -459,11 +481,9 @@ class Stacktrace(Interface):
         system_frames = 0
         frames = []
         for frame in self.frames:
-            frame_data = self.get_frame_context(frame, event=event, is_public=is_public)
-
-            frames.append(frame_data)
+            frames.append(frame.get_context(event=event, is_public=is_public))
 
-            if not frame.get('in_app'):
+            if not frame.in_app:
                 system_frames += 1
 
         if len(frames) == system_frames:
@@ -502,7 +522,7 @@ class Stacktrace(Interface):
         num_frames = len(frames)
 
         if not system_frames:
-            frames = [f for f in frames if f.get('in_app') is not False]
+            frames = [f for f in frames if f.in_app is not False]
             if not frames:
                 frames = self.frames
 
@@ -524,20 +544,7 @@ class Stacktrace(Interface):
             result.extend(('(%d additional frame(s) were not displayed)' % (num_frames - visible_frames,), '...'))
 
         for frame in frames[start:stop]:
-            if frame.get('filename'):
-                pieces = ['  File "%(filename)s"']
-            elif frame.get('module'):
-                pieces = ['  Module "%(module)s"']
-            else:
-                pieces = ['  ?']
-            if 'lineno' in frame:
-                pieces.append(', line %(lineno)s')
-            if 'function' in frame:
-                pieces.append(', in %(function)s')
-
-            result.append(''.join(pieces) % frame)
-            if frame.get('context_line', None) is not None:
-                result.append('    %s' % frame['context_line'].strip())
+            result.append(frame.to_string())
 
         if newest_first and visible_frames < num_frames:
             result.extend(('...', '(%d additional frame(s) were not displayed)' % (num_frames - visible_frames,)))
@@ -554,7 +561,7 @@ class Stacktrace(Interface):
 
     def get_search_context(self, event):
         return {
-            'text': list(itertools.chain(*[[f.get('filename'), f.get('function'), f.get('context_line')] for f in self.frames])),
+            'text': list(itertools.chain(*[[f.filename, f.function, f.context_line] for f in self.frames])),
         }
 
 
diff --git a/src/sentry/tasks/fetch_source.py b/src/sentry/tasks/fetch_source.py
index ca2b9bdcf2..d0cde0def0 100644
--- a/src/sentry/tasks/fetch_source.py
+++ b/src/sentry/tasks/fetch_source.py
@@ -143,16 +143,16 @@ def fetch_javascript_source(event, **kwargs):
     logger = fetch_javascript_source.get_logger()
 
     try:
-        stacktrace = event.data['sentry.interfaces.Stacktrace']
+        stacktrace = event.interfaces['sentry.interfaces.Stacktrace']
     except KeyError:
         logger.debug('No stacktrace for event %r', event.id)
         return
 
     # build list of frames that we can actually grab source for
-    frames = [f for f in stacktrace['frames']
-        if f.get('lineno') is not None
-            and f.get('context_line') is None
-            and f.get('abs_path', '').startswith(('http://', 'https://'))]
+    frames = [f for f in stacktrace.frames
+        if f.lineno is not None
+            and f.context_line is None
+            and f.is_url()]
     if not frames:
         logger.debug('Event %r has no frames with enough context to fetch remote source', event.id)
         return
@@ -163,9 +163,9 @@ def fetch_javascript_source(event, **kwargs):
     sourcemaps = {}
 
     for f in frames:
-        file_list.add(f['abs_path'])
-        if f.get('colno') is not None:
-            sourcemap_capable.add(f['abs_path'])
+        file_list.add(f.abs_path)
+        if f.colno is not None:
+            sourcemap_capable.add(f.abs_path)
 
     while file_list:
         filename = file_list.pop()
@@ -211,23 +211,23 @@ def fetch_javascript_source(event, **kwargs):
     has_changes = False
     for frame in frames:
         try:
-            source, sourcemap = source_code[frame['abs_path']]
+            source, sourcemap = source_code[frame.abs_path]
         except KeyError:
             # we must've failed pulling down the source
             continue
 
-        if frame.get('colno') and sourcemap:
-            state = find_source(sourcemaps[sourcemap], frame['lineno'], frame['colno'])
+        if frame.colno is not None and sourcemap:
+            state = find_source(sourcemaps[sourcemap], frame.lineno, frame.colno)
             # TODO: is this urljoin right? (is it relative to the sourcemap or the originating file)
             abs_path = urljoin(sourcemap, state.src)
-            logger.debug('Mapping compressed source %r to mapping in %r', frame['abs_path'], abs_path)
+            logger.debug('Mapping compressed source %r to mapping in %r', frame.abs_path, abs_path)
             try:
                 source, _ = source_code[abs_path]
             except KeyError:
                 pass
             else:
                 # Store original data in annotation
-                frame['data'] = {
+                frame.data = {
                     'orig_lineno': frame['lineno'],
                     'orig_colno': frame['colno'],
                     'orig_function': frame['function'],
@@ -237,17 +237,18 @@ def fetch_javascript_source(event, **kwargs):
                 }
 
                 # SourceMap's return zero-indexed lineno's
-                frame['lineno'] = state.src_line + 1
-                frame['colno'] = state.src_col
-                frame['function'] = state.name
-                frame['abs_path'] = abs_path
-                frame['filename'] = state.src
+                frame.lineno = state.src_line + 1
+                frame.colno = state.src_col
+                frame.function = state.name
+                frame.abs_path = abs_path
+                frame.filename = state.src
 
         has_changes = True
 
         # TODO: theoretically a minified source could point to another mapped, minified source
-        frame['pre_context'], frame['context_line'], frame['post_context'] = get_source_context(
-            source=source, lineno=int(frame['lineno']))
+        frame.pre_context, frame.context_line, frame.post_context = get_source_context(
+            source=source, lineno=frame.lineno)
 
     if has_changes:
+        event.data['sentry.interfaces.Stacktrace'] = stacktrace.serialize()
         event.update(data=event.data)
diff --git a/src/sentry/testutils.py b/src/sentry/testutils.py
index b576342c01..130a2e97f9 100644
--- a/src/sentry/testutils.py
+++ b/src/sentry/testutils.py
@@ -30,6 +30,11 @@ from django.utils.importlib import import_module
 
 from sentry.models import (Project, ProjectOption, Option, Team, Group,
     Event)
+from sentry.utils.compat import pickle
+from sentry.utils.strings import decompress
+
+# an example data blog from Sentry 5.4.1 (db level)
+LEGACY_DATA = pickle.loads(decompress("""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"""))
 
 
 def with_settings(**mapping):
@@ -126,6 +131,7 @@ class BaseTestCase(Exam):
             group=self.group,
             message='Foo bar',
             project=self.project,
+            data=LEGACY_DATA,
         )
 
     def assertRequiresAuthentication(self, path, method='GET'):
diff --git a/src/sentry/utils/models.py b/src/sentry/utils/models.py
index f27c46886a..4eb74306fa 100644
--- a/src/sentry/utils/models.py
+++ b/src/sentry/utils/models.py
@@ -6,7 +6,6 @@ sentry.utils.models
 :license: BSD, see LICENSE for more details.
 """
 
-import base64
 import hashlib
 import logging
 
@@ -18,6 +17,7 @@ from django.utils.encoding import smart_str
 from sentry.utils.cache import Lock
 from sentry.utils.compat import pickle
 from sentry.utils.db import resolve_expression_node
+from sentry.utils.strings import decompress, compress
 
 logger = logging.getLogger(__name__)
 
@@ -181,7 +181,7 @@ class GzippedDictField(models.TextField):
     def to_python(self, value):
         if isinstance(value, basestring) and value:
             try:
-                value = pickle.loads(base64.b64decode(value).decode('zlib'))
+                value = pickle.loads(decompress(value))
             except Exception, e:
                 logger.exception(e)
                 return {}
@@ -193,7 +193,7 @@ class GzippedDictField(models.TextField):
         if not value and self.null:
             # save ourselves some storage
             return None
-        return base64.b64encode(pickle.dumps(value).encode('zlib'))
+        return compress(pickle.dumps(value))
 
     def value_to_string(self, obj):
         value = self._get_val_from_obj(obj)
diff --git a/src/sentry/utils/strings.py b/src/sentry/utils/strings.py
index 583ba4ab4b..db71e63d1e 100644
--- a/src/sentry/utils/strings.py
+++ b/src/sentry/utils/strings.py
@@ -1,3 +1,7 @@
+import base64
+import zlib
+
+
 def truncatechars(value, arg):
     """
     Truncates a string after a certain number of chars.
@@ -11,3 +15,15 @@ def truncatechars(value, arg):
     if len(value) > length:
         return value[:length] + '...'
     return value
+
+
+def compress(value):
+    return base64.b64encode(zlib.compress(value))
+
+
+def decompress(value):
+    return zlib.decompress(base64.b64decode(value))
+
+
+def gunzip(value):
+    return zlib.decompress(value, 16 + zlib.MAX_WBITS)
diff --git a/tests/sentry/interfaces/stacktrace/tests.py b/tests/sentry/interfaces/stacktrace/tests.py
index 4e1775e3db..09db89f53d 100644
--- a/tests/sentry/interfaces/stacktrace/tests.py
+++ b/tests/sentry/interfaces/stacktrace/tests.py
@@ -23,6 +23,14 @@ class StacktraceTest(TestCase):
             }
         ])
 
+    def test_legacy_interface(self):
+        # Simple test to ensure legacy data works correctly with the ``Frame``
+        # objects
+        event = self.event
+        interface = Stacktrace(**event.data['sentry.interfaces.Stacktrace'])
+        assert len(interface.frames) == 5
+        assert interface == event.interfaces['sentry.interfaces.Stacktrace']
+
     def test_requires_filename(self):
         with self.assertRaises(AssertionError):
             Stacktrace(frames=[{}]).validate()
@@ -41,8 +49,8 @@ class StacktraceTest(TestCase):
             'abs_path': 'foo/bar/baz.py',
         }])
         frame = interface.frames[0]
-        assert frame['filename'] == 'foo/bar/baz.py'
-        assert frame.get('abs_path') is None
+        assert frame.filename == 'foo/bar/baz.py'
+        assert frame.abs_path == frame.filename
 
     def test_coerces_url_filenames(self):
         interface = Stacktrace(frames=[{
@@ -50,8 +58,8 @@ class StacktraceTest(TestCase):
             'filename': 'http://foo.com/foo.js',
         }])
         frame = interface.frames[0]
-        assert frame['filename'] == '/foo.js'
-        assert frame['abs_path'] == 'http://foo.com/foo.js'
+        assert frame.filename == '/foo.js'
+        assert frame.abs_path == 'http://foo.com/foo.js'
 
     def test_coerces_url_abs_paths(self):
         interface = Stacktrace(frames=[{
@@ -60,8 +68,8 @@ class StacktraceTest(TestCase):
             'abs_path': 'http://foo.com/foo.js',
         }])
         frame = interface.frames[0]
-        assert frame['filename'] == '/foo.js'
-        assert frame['abs_path'] == 'http://foo.com/foo.js'
+        assert frame.filename == '/foo.js'
+        assert frame.abs_path == 'http://foo.com/foo.js'
 
     def test_ignores_results_with_empty_path(self):
         interface = Stacktrace(frames=[{
@@ -69,8 +77,8 @@ class StacktraceTest(TestCase):
             'filename': 'http://foo.com',
         }])
         frame = interface.frames[0]
-        assert frame['filename'] == 'http://foo.com'
-        assert frame.get('abs_path') is None
+        assert frame.filename == 'http://foo.com'
+        assert frame.abs_path == frame.filename
 
     def test_serialize_returns_frames(self):
         interface = Stacktrace(frames=[{
@@ -78,7 +86,7 @@ class StacktraceTest(TestCase):
             'filename': 'foo.py',
         }])
         result = interface.serialize()
-        self.assertTrue('frames' in result)
+        assert 'frames' in result
 
     def test_get_hash_with_only_required_vars(self):
         interface = Stacktrace(frames=[{
@@ -176,14 +184,14 @@ class StacktraceTest(TestCase):
     @mock.patch('sentry.interfaces.Stacktrace.is_newest_frame_first', mock.Mock(return_value=False))
     @mock.patch('sentry.interfaces.Stacktrace.get_traceback')
     @mock.patch('sentry.interfaces.render_to_string')
-    @mock.patch('sentry.interfaces.Stacktrace.get_frame_context')
+    @mock.patch('sentry.interfaces.Frame.get_context')
     def test_to_html_render_call(self, get_frame_context, render_to_string, get_traceback):
         event = mock.Mock(spec=Event())
         get_traceback.return_value = 'bar'
         interface = Stacktrace(frames=[{'lineno': 1, 'filename': 'foo.py'}])
         result = interface.to_html(event)
         get_traceback.assert_called_once_with(event, newest_first=False)
-        get_frame_context.assert_called_once_with(interface.frames[0], event=event, is_public=False)
+        get_frame_context.assert_called_once_with(event=event, is_public=False)
         render_to_string.assert_called_once_with('sentry/partial/interfaces/stacktrace.html', {
             'event': event,
             'frames': [get_frame_context.return_value],
diff --git a/tests/sentry/interfaces/tests.py b/tests/sentry/interfaces/tests.py
index 45cefd6c3d..a0a9ae5a5b 100644
--- a/tests/sentry/interfaces/tests.py
+++ b/tests/sentry/interfaces/tests.py
@@ -5,7 +5,7 @@ from __future__ import absolute_import
 import mock
 import pickle
 
-from sentry.interfaces import Interface, Message, Query, Stacktrace, get_context
+from sentry.interfaces import Interface, Message, Query, get_context
 from sentry.models import Event
 from sentry.testutils import TestCase, fixture
 
diff --git a/tests/sentry/tasks/fetch_source/tests.py b/tests/sentry/tasks/fetch_source/tests.py
index 4f02ceaa70..5080096132 100644
--- a/tests/sentry/tasks/fetch_source/tests.py
+++ b/tests/sentry/tasks/fetch_source/tests.py
@@ -44,13 +44,13 @@ class StoreEventTest(TestCase):
         build_opener.return_value.open.return_value.read.assert_called_once_with()
         update.assert_called_once_with(data=event.data)
 
-        frame_list = event.data['sentry.interfaces.Stacktrace']['frames']
+        frame_list = event.interfaces['sentry.interfaces.Stacktrace'].frames
         frame = frame_list[0]
-        assert frame['pre_context'] == ['h', 'e', 'l']
-        assert frame['context_line'] == 'l'
-        assert frame['post_context'] == ['o', ' ', 'w', 'o', 'r']
+        assert frame.pre_context == ['h', 'e', 'l']
+        assert frame.context_line == 'l'
+        assert frame.post_context == ['o', ' ', 'w', 'o', 'r']
 
         frame = frame_list[1]
-        assert frame['pre_context'] == []
-        assert frame['context_line'] == 'h'
-        assert frame['post_context'] == ['e', 'l', 'l', 'o', ' ']
+        assert frame.pre_context == []
+        assert frame.context_line == 'h'
+        assert frame.post_context == ['e', 'l', 'l', 'o', ' ']

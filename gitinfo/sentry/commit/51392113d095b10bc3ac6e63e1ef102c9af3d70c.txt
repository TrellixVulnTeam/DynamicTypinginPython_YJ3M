commit 51392113d095b10bc3ac6e63e1ef102c9af3d70c
Author: David Cramer <dcramer@gmail.com>
Date:   Fri Oct 10 13:00:42 2014 -0700

    Migrate search to cursors

diff --git a/src/sentry/api/base.py b/src/sentry/api/base.py
index 94b284889d..9b5df2e17f 100644
--- a/src/sentry/api/base.py
+++ b/src/sentry/api/base.py
@@ -40,19 +40,18 @@ class Endpoint(APIView):
         assert per_page <= 100
 
         paginator = Paginator(**kwargs)
-        cursor = paginator.get_cursor(
+        cursor_result = paginator.get_result(
             limit=per_page,
             cursor=input_cursor,
         )
 
         # map results based on callback
-        results = on_results(cursor.results)
+        results = on_results(cursor_result.results)
 
-        links = []
-        if cursor.has_prev:
-            links.append(('previous', cursor.prev))
-        if cursor.has_next:
-            links.append(('next', cursor.next))
+        links = [
+            ('previous', str(cursor_result.prev)),
+            ('next', str(cursor_result.next)),
+        ]
 
         querystring = u'&'.join(
             u'{0}={1}'.format(quote(k), quote(v))
diff --git a/src/sentry/api/endpoints/group_events.py b/src/sentry/api/endpoints/group_events.py
index 4c02ab154b..cae3751922 100644
--- a/src/sentry/api/endpoints/group_events.py
+++ b/src/sentry/api/endpoints/group_events.py
@@ -19,6 +19,7 @@ class GroupEventsEndpoint(Endpoint):
         return self.paginate(
             request=request,
             queryset=events,
-            order_by='-datetime',
+            # TODO(dcramer): we want to sort by datetime
+            order_by='-id',
             on_results=lambda x: serialize(x, request.user),
         )
diff --git a/src/sentry/api/endpoints/group_notes.py b/src/sentry/api/endpoints/group_notes.py
index 045677779c..d70db4f2d8 100644
--- a/src/sentry/api/endpoints/group_notes.py
+++ b/src/sentry/api/endpoints/group_notes.py
@@ -31,7 +31,8 @@ class GroupNotesEndpoint(Endpoint):
         return self.paginate(
             request=request,
             queryset=notes,
-            order_by='-datetime',
+            # TODO(dcramer): we want to sort by datetime
+            order_by='-id',
             on_results=lambda x: serialize(x, request.user),
         )
 
diff --git a/src/sentry/api/endpoints/project_releases.py b/src/sentry/api/endpoints/project_releases.py
index def6df0885..ec472058e5 100644
--- a/src/sentry/api/endpoints/project_releases.py
+++ b/src/sentry/api/endpoints/project_releases.py
@@ -19,6 +19,7 @@ class ProjectReleasesEndpoint(Endpoint):
         return self.paginate(
             request=request,
             queryset=queryset,
-            order_by='-date_added',
+            # TODO(dcramer): we want to sort by date_added
+            order_by='-id',
             on_results=lambda x: serialize(x, request.user),
         )
diff --git a/src/sentry/api/paginator.py b/src/sentry/api/paginator.py
index 3ed7a864cc..fa8774beb6 100644
--- a/src/sentry/api/paginator.py
+++ b/src/sentry/api/paginator.py
@@ -1,16 +1,17 @@
-import datetime
+"""
+sentry.api.paginator
+~~~~~~~~~~~~~~~~~~~~
 
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+from __future__ import absolute_import
 
-class CursorResult(object):
-    def __init__(self, results, next, prev=None, has_prev=None, has_next=None):
-        self.next = next
-        self.prev = prev
-        self.has_next = has_next
-        self.has_prev = has_prev
-        self.results = results
+from django.db import connections
 
-    def get_response(self):
-        return self.results
+from sentry.utils.cursors import build_cursor, Cursor
+
+quote_name = connections['default'].ops.quote_name
 
 
 class Paginator(object):
@@ -21,7 +22,7 @@ class Paginator(object):
             self.key, self.desc = order_by, False
         self.queryset = queryset
 
-    def _get_results_from_qs(self, cursor_offset, is_prev):
+    def _get_results_from_qs(self, value, is_prev):
         results = self.queryset
 
         # "asc" controls whether or not we need to change the ORDER BY to
@@ -49,124 +50,50 @@ class Paginator(object):
             else:
                 results = results.order_by('-%s' % self.key)
 
-        if cursor_offset:
+        if value:
+            if self.key in results.query.extra:
+                col_query, col_params = results.query.extra[self.key]
+                col_params = col_params[:]
+            else:
+                col_query, col_params = quote_name(self.key), []
+            col_params.append(value)
+
             if asc:
-                results = results.filter(**{'%s__gte' % self.key: cursor_offset})
+                results = results.extra(
+                    where=['%s >= %%s' % (col_query,)],
+                    params=col_params,
+                )
             else:
-                results = results.filter(**{'%s__lte' % self.key: cursor_offset})
+                results = results.extra(
+                    where=['%s <= %%s' % (col_query,)],
+                    params=col_params,
+                )
 
         return results
 
-    def get_cursor(self, limit=100, cursor=None):
+    def get_result(self, limit=100, cursor=None):
         # cursors are:
-        #   (identifier(integer), row offset, is_previous)
-
-        cursor = cursor or (0, 0, 0)
-
-        if cursor:
-            cursor_offset, offset, is_prev = map(int, cursor)
-        else:
-            cursor_offset, offset, is_prev = 0, 0, 0
+        #   (identifier(integer), row offset, is_prev)
+        if cursor is None:
+            cursor = Cursor(0, 0, 0)
 
-        results = self._get_results_from_qs(cursor_offset, is_prev)
+        queryset = self._get_results_from_qs(cursor.value, cursor.is_prev)
 
-        if is_prev:
-            # this effectively gets us the before post, and the current (after) post
-            stop = offset + limit + 2
+        # this effectively gets us the before post, and the current (after) post
+        # every time
+        if cursor.is_prev:
+            stop = cursor.offset + limit + 2
         else:
-            stop = offset + limit + 1
-
-        results = list(results[offset:stop])
-
-        num_results = len(results)
-
-        if is_prev:
-            has_prev = num_results > (limit + 1)
-            results = [r for r in reversed(results[:limit + 1])]
-            num_results = len(results)
-        elif cursor_offset or offset:
-            # It's likely that there's a previous page if they passed us either offset values
-            has_prev = True
-        else:
-            # we don't know
-            has_prev = False
-
-        # Default cursor if not present
-        if is_prev:
-            next_cursor_offset = cursor_offset
-            next_offset = offset
+            stop = cursor.offset + limit + 1
 
-            # Are there more results than whats on the current page?
-            has_next = num_results > limit
-        elif num_results:
-            if not cursor_offset:
-                cursor_offset = getattr(results[0], self.key)
+        results = list(queryset[cursor.offset:stop])
 
-            # Are there more results than whats on the current page?
-            has_next = num_results > limit
-
-            # Determine what our next cursor is by ensuring we have a unique offset
-            next_cursor_offset = getattr(results[-1], self.key)
-
-            if next_cursor_offset == cursor_offset:
-                next_offset = offset + limit
-            else:
-                next_offset = 0
-
-                for result in results[1 if is_prev else 0:limit][::-1]:
-                    if getattr(result, self.key) == next_cursor_offset:
-                        next_offset += 1
-                    else:
-                        break
-        else:
-            next_cursor_offset = cursor_offset
-            next_offset = offset
-            has_next = False
-
-        # Determine what our pervious cursor is by ensuring we have a unique offset
-        if is_prev and num_results:
-            prev_cursor_offset = getattr(results[0], self.key)
-
-            if num_results > 2:
-                i = 1
-                while i < num_results and prev_cursor_offset == getattr(results[i], self.key):
-                    i += 1
-                i -= 1
-            else:
-                i = 0
-
-            # if we iterated every result and the offset didn't change, we need
-            # to simply add the current offset to our total results (visible)
-            if prev_cursor_offset == cursor_offset:
-                prev_offset = offset + i
-            else:
-                prev_offset = i
-        else:
-            # previous cursor is easy if we're paginating forward
-            prev_cursor_offset = cursor_offset
-            prev_offset = offset
-
-        # Truncate the list to our original result size now that we've determined the next page
-        results = results[:limit]
-
-        # XXX: We convert datetimes to unix_time and bump 7 decimal places so we don't
-        # have to worry about float point restrictions. This conversion is also handled
-        # in the CursorTimestamp validator
-        if isinstance(next_cursor_offset, datetime.datetime):
-            next_cursor_offset = int(float(next_cursor_offset.strftime('%s.%f')) * 1000000)
-        if isinstance(prev_cursor_offset, datetime.datetime):
-            prev_cursor_offset = int(float(prev_cursor_offset.strftime('%s.%f')) * 1000000)
-
-        next_cursor = ':'.join(map(lambda x: str(int(x)), [next_cursor_offset or 0, next_offset, 0]))
-        if has_prev:
-            prev_cursor = ':'.join(map(lambda x: str(int(x)), [prev_cursor_offset or 0, prev_offset, 1]))
-        else:
-            prev_cursor = None
+        if cursor.is_prev:
+            results = results[1:][::-1]
 
-        return CursorResult(
+        return build_cursor(
             results=results,
-            next=next_cursor,
-            prev=prev_cursor,
-            has_next=has_next,
-            has_prev=has_prev,
+            limit=limit,
+            cursor=cursor,
+            key=self.key,
         )
diff --git a/src/sentry/search/base.py b/src/sentry/search/base.py
index acafe275b7..3ea51bc3da 100644
--- a/src/sentry/search/base.py
+++ b/src/sentry/search/base.py
@@ -8,49 +8,6 @@ sentry.search.base
 
 from __future__ import absolute_import
 
-from collections import Sequence
-
-
-class SearchResult(Sequence):
-    def __init__(self, id_list=None, instances=None):
-        assert not (id_list and instances), \
-            'pass either id_list or instances, not both'
-        self._id_list = id_list
-        self._result_cache = instances
-
-    def __len__(self):
-        if self._result_cache is None:
-            self._populate_result_cache()
-        return len(self._result_cache)
-
-    def __iter__(self):
-        if self._result_cache is None:
-            self._populate_result_cache()
-        return iter(self._result_cache)
-
-    def __getitem__(self, key):
-        if self._result_cache is None:
-            self._populate_result_cache()
-        return self._result_cache[key]
-
-    def __repr__(self):
-        return '<%s: ids=%s>' % (type(self).__name__, self._id_list)
-
-    def _populate_result_cache(self):
-        from sentry.models import Group
-
-        id_list = self._id_list
-        group_map = Group.objects.in_bulk(id_list)
-
-        results = []
-        for g_id in id_list:
-            try:
-                results.append(group_map[g_id])
-            except KeyError:
-                pass
-
-        self._result_cache = results
-
 
 class SearchBackend(object):
     def __init__(self, **options):
@@ -61,8 +18,15 @@ class SearchBackend(object):
 
     def query(self, project, query=None, status=None, tags=None,
               bookmarked_by=None, assigned_to=None, sort_by='date',
-              date_filter='last_seen', date_from=None, date_to=None, offset=0,
-              limit=100):
+              date_filter='last_seen', date_from=None, date_to=None,
+              cursor=None, limit=100):
+        """
+        The return value should be a CursorResult.
+
+        The limit here is a soft input limit, which gets trimmed by the Cursor.
+        This means the backend should query limit + 2 and return that within the
+        CursorResult.
+        """
         raise NotImplementedError
 
     def upgrade(self):
diff --git a/src/sentry/search/django/backend.py b/src/sentry/search/django/backend.py
index ae8d94acb0..b45cec4b85 100644
--- a/src/sentry/search/django/backend.py
+++ b/src/sentry/search/django/backend.py
@@ -8,7 +8,8 @@ sentry.search.django.backend
 
 from __future__ import absolute_import
 
-from sentry.search.base import SearchBackend, SearchResult
+from sentry.api.paginator import Paginator
+from sentry.search.base import SearchBackend
 from sentry.search.django.constants import (
     SORT_CLAUSES, SQLITE_SORT_CLAUSES, MYSQL_SORT_CLAUSES, MSSQL_SORT_CLAUSES,
     MSSQL_ENGINES, ORACLE_SORT_CLAUSES
@@ -22,8 +23,8 @@ class DjangoSearchBackend(SearchBackend):
 
     def query(self, project, query=None, status=None, tags=None,
               bookmarked_by=None, assigned_to=None, sort_by='date',
-              date_filter='last_seen', date_from=None, date_to=None, offset=0,
-              limit=100):
+              date_filter='last_seen', date_from=None, date_to=None,
+              cursor=None, limit=100):
         from sentry.models import Group
 
         queryset = Group.objects.filter(project=project)
@@ -90,10 +91,15 @@ class DjangoSearchBackend(SearchBackend):
         elif sort_by == 'avgtime':
             queryset = queryset.filter(time_spent_count__gt=0)
 
+        queryset = queryset.extra(
+            select={'sort_value': score_clause},
+        )
+
         # HACK: don't sort by the same column twice
         if sort_by == 'date':
-            queryset = queryset.order_by('-last_seen')
+            queryset = queryset.order_by('-sort_value')
         else:
             queryset = queryset.order_by('-sort_value', '-last_seen')
 
-        return SearchResult(instances=list(queryset[offset:offset + limit]))
+        paginator = Paginator(queryset, '-sort_value')
+        return paginator.get_result(limit, cursor)
diff --git a/src/sentry/search/django/constants.py b/src/sentry/search/django/constants.py
index 4e6cd80a32..35ceafe37f 100644
--- a/src/sentry/search/django/constants.py
+++ b/src/sentry/search/django/constants.py
@@ -17,33 +17,28 @@ SORT_CLAUSES = {
     'tottime': 'sentry_groupedmessage.time_spent_total',
     'avgtime': '(sentry_groupedmessage.time_spent_total / sentry_groupedmessage.time_spent_count)',
 }
-SCORE_CLAUSES = SORT_CLAUSES.copy()
 
 SQLITE_SORT_CLAUSES = SORT_CLAUSES.copy()
 SQLITE_SORT_CLAUSES.update({
-    'date': "(julianday(sentry_groupedmessage.last_seen) - 2440587.5) * 86400.0",
-    'new': "(julianday(sentry_groupedmessage.first_seen) - 2440587.5) * 86400.0",
+    'date': "cast((julianday(sentry_groupedmessage.last_seen) - 2440587.5) * 86400.0 as INTEGER)",
+    'new': "cast((julianday(sentry_groupedmessage.first_seen) - 2440587.5) * 86400.0 as INTEGER)",
 })
-SQLITE_SCORE_CLAUSES = SQLITE_SORT_CLAUSES.copy()
 
 MYSQL_SORT_CLAUSES = SORT_CLAUSES.copy()
 MYSQL_SORT_CLAUSES.update({
     'date': 'UNIX_TIMESTAMP(sentry_groupedmessage.last_seen)',
     'new': 'UNIX_TIMESTAMP(sentry_groupedmessage.first_seen)',
 })
-MYSQL_SCORE_CLAUSES = MYSQL_SORT_CLAUSES.copy()
 
-ORACLE_SORT_CLAUSES = SCORE_CLAUSES.copy()
+ORACLE_SORT_CLAUSES = SORT_CLAUSES.copy()
 ORACLE_SORT_CLAUSES.update({
     'date': "(cast(sentry_groupedmessage.last_seen as date)-TO_DATE('01/01/1970 00:00:00', 'MM-DD-YYYY HH24:MI:SS')) * 24 * 60 * 60",
     'new': "(cast(sentry_groupedmessage.first_seen as date)-TO_DATE('01/01/1970 00:00:00', 'MM-DD-YYYY HH24:MI:SS')) * 24 * 60 * 60",
 })
-ORACLE_SCORE_CLAUSES = ORACLE_SORT_CLAUSES.copy()
 
-MSSQL_SORT_CLAUSES = SCORE_CLAUSES.copy()
+MSSQL_SORT_CLAUSES = SORT_CLAUSES.copy()
 MSSQL_SORT_CLAUSES.update({
     'date': "DATEDIFF(s, '1970-01-01T00:00:00', sentry_groupedmessage.last_seen)",
     'new': "DATEDIFF(s, '1970-01-01T00:00:00', sentry_groupedmessage.first_seen)",
 })
-MSSQL_SCORE_CLAUSES = MSSQL_SORT_CLAUSES.copy()
 MSSQL_ENGINES = set(['django_pytds', 'sqlserver_ado', 'sql_server.pyodbc'])
diff --git a/src/sentry/search/elastic_search/backend.py b/src/sentry/search/elastic_search/backend.py
index c1f02505a9..727f6ebcdd 100644
--- a/src/sentry/search/elastic_search/backend.py
+++ b/src/sentry/search/elastic_search/backend.py
@@ -37,7 +37,8 @@ from __future__ import absolute_import
 
 from elasticsearch import Elasticsearch
 
-from sentry.search.base import SearchBackend, SearchResult
+from sentry.search.base import SearchBackend
+from sentry.utils.cursors import CursorResult
 
 
 class ElasticSearchBackend(SearchBackend):
@@ -83,8 +84,8 @@ class ElasticSearchBackend(SearchBackend):
 
     def query(self, project, query=None, status=None, tags=None,
               bookmarked_by=None, assigned_to=None, sort_by='date',
-              date_filter='last_seen', date_from=None, date_to=None, offset=0,
-              limit=100):
+              date_filter='last_seen', date_from=None, date_to=None,
+              cursor=None, limit=100):
 
         query_body = {
             'filter': {
@@ -164,15 +165,24 @@ class ElasticSearchBackend(SearchBackend):
                 'query': {'filtered': query_body},
                 'sort': sort_clause,
                 'size': limit,
-                'from': offset,
+                # 'from': offset,
             },
         )
         if not results.get('hits'):
-            return SearchResult([])
+            return CursorResult(
+                results=[],
+                cursor=cursor,
+                limit=limit,
+            )
 
         instance_ids = [int(n['_id']) for n in results['hits']['hits']]
 
-        return SearchResult(instance_ids)
+        return CursorResult.from_ids(
+            id_list=instance_ids,
+            cursor=cursor,
+            limit=limit,
+            key='TODO',
+        )
 
     def upgrade(self):
         self.backend.indices.put_template(
diff --git a/src/sentry/utils/cursors.py b/src/sentry/utils/cursors.py
new file mode 100644
index 0000000000..cf223fccc6
--- /dev/null
+++ b/src/sentry/utils/cursors.py
@@ -0,0 +1,157 @@
+"""
+sentry.utils.cursors
+~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+from __future__ import absolute_import
+
+from collections import Sequence
+
+
+class Cursor(object):
+    def __init__(self, value, offset=0, is_prev=False):
+        # XXX: ceil is not entirely correct here, but it's a simple hack
+        # that solves most problems
+        self.value = long(value)
+        self.offset = int(offset)
+        self.is_prev = bool(is_prev)
+
+    def __str__(self):
+        return '%s:%s:%s' % (self.value, self.offset, int(self.is_prev))
+
+    def __repr__(self):
+        return '<%s: value=%s offset=%s is_prev=%s>' % (
+            type(self), self.value, self.offset, int(self.is_prev))
+
+
+class CursorResult(Sequence):
+    def __init__(self, results, next, prev, has_next=None, has_prev=None):
+        self.results = results
+        self.next = next
+        self.prev = prev
+        self.has_next = has_next
+        self.has_prev = has_prev
+
+    def __len__(self):
+        return len(self.results)
+
+    def __iter__(self):
+        return iter(self.results)
+
+    def __getitem__(self, key):
+        return self.results[key]
+
+    def __repr__(self):
+        return '<%s: results=%s>' % (type(self).__name__, len(self.results))
+
+    @classmethod
+    def from_ids(self, id_list, key=None, limit=100, cursor=None):
+        from sentry.models import Group
+
+        group_map = Group.objects.in_bulk(id_list)
+
+        results = []
+        for g_id in id_list:
+            try:
+                results.append(group_map[g_id])
+            except KeyError:
+                pass
+
+        return build_cursor(
+            results=results,
+            key=key,
+            cursor=cursor,
+            limit=limit,
+        )
+
+
+def build_cursor(results, key, limit=100, cursor=None):
+    if cursor is None:
+        cursor = Cursor(0, 0, 0)
+
+    value = cursor.value
+    offset = cursor.offset
+    is_prev = cursor.is_prev
+
+    num_results = len(results)
+
+    if is_prev:
+        has_prev = num_results > limit
+        num_results = len(results)
+    elif value or offset:
+        # It's likely that there's a previous page if they passed us either offset values
+        has_prev = True
+    else:
+        # we don't know
+        has_prev = False
+
+    # Default cursor if not present
+    if is_prev:
+        next_value = value
+        next_offset = offset
+        has_next = True
+    elif num_results:
+        if not value:
+            value = getattr(results[0], key)
+
+        # Are there more results than whats on the current page?
+        has_next = num_results > limit
+
+        # Determine what our next cursor is by ensuring we have a unique offset
+        next_value = getattr(results[-1], key)
+
+        if next_value == value:
+            next_offset = offset + limit
+        else:
+            next_offset = 0
+            result_iter = reversed(results)
+            # skip the last result
+            result_iter.next()
+            for result in result_iter:
+                if getattr(result, key) == next_value:
+                    next_offset += 1
+                else:
+                    break
+    else:
+        next_value = value
+        next_offset = offset
+        has_next = False
+
+    # Determine what our pervious cursor is by ensuring we have a unique offset
+    if is_prev and num_results:
+        prev_value = getattr(results[0], key)
+
+        if num_results > 2:
+            i = 1
+            while i < num_results and prev_value == getattr(results[i], key):
+                i += 1
+            i -= 1
+        else:
+            i = 0
+
+        # if we iterated every result and the offset didn't change, we need
+        # to simply add the current offset to our total results (visible)
+        if prev_value == value:
+            prev_offset = offset + i
+        else:
+            prev_offset = i
+    else:
+        # previous cursor is easy if we're paginating forward
+        prev_value = value
+        prev_offset = offset
+
+    # Truncate the list to our original result size now that we've determined the next page
+    results = results[:limit]
+
+    next_cursor = Cursor(next_value or 0, next_offset, False)
+    prev_cursor = Cursor(prev_value or 0, prev_offset, True)
+
+    return CursorResult(
+        results=results,
+        next=next_cursor,
+        prev=prev_cursor,
+        has_next=has_next,
+        has_prev=has_prev,
+    )
diff --git a/tests/sentry/api/endpoints/test_group_events.py b/tests/sentry/api/endpoints/test_group_events.py
index aa1fe81254..10d5c71bdc 100644
--- a/tests/sentry/api/endpoints/test_group_events.py
+++ b/tests/sentry/api/endpoints/test_group_events.py
@@ -2,7 +2,7 @@ from django.core.urlresolvers import reverse
 from sentry.testutils import APITestCase
 
 
-class GroupResolveTest(APITestCase):
+class GroupEventsTest(APITestCase):
     def test_simple(self):
         self.login_as(user=self.user)
 
diff --git a/tests/sentry/search/django/tests.py b/tests/sentry/search/django/tests.py
index 1a5739996f..42cd72070b 100644
--- a/tests/sentry/search/django/tests.py
+++ b/tests/sentry/search/django/tests.py
@@ -134,14 +134,16 @@ class DjangoSearchBackendTest(TestCase):
         results = self.backend.query(self.project2)
         assert len(results) == 0
 
-    def test_limit_and_offset(self):
-        results = self.backend.query(self.project1, limit=1)
+    def test_pagination(self):
+        results = self.backend.query(self.project1, limit=1, sort_by='date')
         assert len(results) == 1
+        assert results[0] == self.group1
 
-        results = self.backend.query(self.project1, offset=1, limit=1)
+        results = self.backend.query(self.project1, cursor=results.next, limit=1, sort_by='date')
         assert len(results) == 1
+        assert results[0] == self.group2
 
-        results = self.backend.query(self.project1, offset=2, limit=1)
+        results = self.backend.query(self.project1, cursor=results.next, limit=1, sort_by='date')
         assert len(results) == 0
 
     def test_first_seen_date_filter(self):

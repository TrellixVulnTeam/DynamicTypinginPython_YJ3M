commit 948ce82da47804b05beb9a40f98442355016bb43
Author: Matt Robenolt <matt@ydekproductions.com>
Date:   Thu Sep 29 16:31:58 2016 -0700

    Properly pass along auth through API client (#4237)
    
    We construct this fake WSGIRequest object and we were attempting to be
    clever by patching on request.{auth,user} to preserve these from the
    original request.
    
    In Django Rest Framework, when we get into our Endpoint.dispatch(), the
    first thing done is goes through `APIView.initialize_request()`. This
    step is transforming the normal Django request object and wrapping it as
    a Rest Framework Request object. When this happens, we lose our patched
    on `request.{auth,user}` objects, and they are replaced with DRF's
    getters for `request.{user,auth}` specifically. Otherwise, properties
    are proxied back through into the original request. The behavior of the
    getters is to actually go through the authentication flow. So it goes
    through our DEFAULT_AUTHENTICATION again. And becasue we have this mock
    object, it's not even close to being real, and we don't end up with real
    auth information coming out out.
    
    So this patch is just setting out explicit `request.{auth,user}`
    information that we intend on overriding on the correct object.

diff --git a/api-docs/generator.py b/api-docs/generator.py
index eebdeaed45..6aaf562939 100644
--- a/api-docs/generator.py
+++ b/api-docs/generator.py
@@ -183,7 +183,6 @@ def cli(output_path):
 
         vars = {
             'org': org,
-            'api_key': api_key,
             'me': user,
             'api_key': api_key,
             'teams': [{
diff --git a/src/sentry/api/base.py b/src/sentry/api/base.py
index 83961928be..5bda13eb58 100644
--- a/src/sentry/api/base.py
+++ b/src/sentry/api/base.py
@@ -129,6 +129,17 @@ class Endpoint(APIView):
 
         return entry
 
+    def initialize_request(self, request, *args, **kwargs):
+        rv = super(Endpoint, self).initialize_request(request, *args, **kwargs)
+        # If our request is being made via our internal API client, we need to
+        # stitch back on auth and user information
+        if getattr(request, '__from_api_client__', False):
+            if rv.auth is None:
+                rv.auth = getattr(request, 'auth', None)
+            if rv.user is None:
+                rv.user = getattr(request, 'user', None)
+        return rv
+
     @csrf_exempt
     def dispatch(self, request, *args, **kwargs):
         """
diff --git a/src/sentry/api/client.py b/src/sentry/api/client.py
index 69165e96e1..1ab75e90c2 100644
--- a/src/sentry/api/client.py
+++ b/src/sentry/api/client.py
@@ -44,6 +44,8 @@ class ApiClient(object):
 
         rf = APIRequestFactory()
         mock_request = getattr(rf, method.lower())(full_path, data or {})
+        # Flag to our API class that we should trust this auth passed through
+        mock_request.__from_api_client__ = True
 
         if request:
             mock_request.auth = getattr(request, 'auth', None)

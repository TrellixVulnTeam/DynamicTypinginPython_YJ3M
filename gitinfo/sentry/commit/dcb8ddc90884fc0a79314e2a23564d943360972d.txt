commit dcb8ddc90884fc0a79314e2a23564d943360972d
Author: Armin Ronacher <armin.ronacher@active-4.com>
Date:   Thu Nov 12 22:43:48 2015 +0100

    Fix setup.py for npm compile and different dists
    
    This changes setup.py for source distributions but also makes it more
    flexible for building in general as it builds in a temporary folder
    and unbreaks wheel distributions.
    
    This is the new behavior:
    
    - most builds happen in build/lib instead of the source folder
    - the exception to this is a install build which happens in the source
      folder as before. This means that nothing about setup.py install
      changes.
    - the source files are now properly added to the manifest which solves the
      problems we had with the 7.7.N releases where the build files contained
      the previous version of the build.
    - in-place build can be forced through --inplace same as with build_ext
    
    Documented the setup.py to make it clear what the hell is happening
    as setuptools can be confusing in how it works.
    
    This was originally PR #2301

diff --git a/setup.py b/setup.py
index 54b6e504ab..493a7ae73a 100755
--- a/setup.py
+++ b/setup.py
@@ -28,13 +28,14 @@ import json
 import os
 import os.path
 import sys
+import traceback
 
 from distutils import log
-from distutils.core import Command
-from setuptools.command.develop import develop
-from setuptools.command.install import install
-from setuptools.command.sdist import sdist
+from distutils.command.build import build as BuildCommand
+from setuptools.command.sdist import sdist as SDistCommand
+from setuptools.command.build_ext import build_ext as BuildExtCommand
 from setuptools import setup, find_packages
+from setuptools.dist import Distribution
 from subprocess import check_output
 
 
@@ -124,28 +125,17 @@ postgres_pypy_requires = [
 ]
 
 
-class DevelopWithBuildStatic(develop):
-    def install_for_development(self):
-        if not IS_LIGHT_BUILD:
-            self.run_command('build_static')
-        return develop.install_for_development(self)
-
-
-class SdistWithBuildStatic(sdist):
-    def make_release_tree(self, *a, **kw):
-        dist_path = self.distribution.get_fullname()
-
-        sdist.make_release_tree(self, *a, **kw)
-
-        self.reinitialize_command('build_static', work_path=dist_path,
-                                  force=True)
-        self.run_command('build_static')
+class BuildJavascriptCommand(BuildCommand):
+    description = 'build javascript support files'
 
-
-class BuildStatic(Command):
     user_options = [
         ('work-path=', 'w',
          "The working directory for source files. Defaults to ."),
+        ('build-lib=', 'b',
+         "directory for script runtime modules"),
+        ('inplace', 'i',
+         "ignore build-lib and put compiled javascript files into the source " +
+         "directory alongside your pure Python modules"),
         ('force', 'f',
          "Force rebuilding of static content. Defaults to rebuilding on version "
          "change detection."),
@@ -153,6 +143,65 @@ class BuildStatic(Command):
 
     boolean_options = ['force']
 
+    def initialize_options(self):
+        self.build_lib = None
+        self.force = None
+        self.work_path = None
+        self.inplace = None
+
+    def finalize_options(self):
+        # This requires some explanation.  Basically what we want to do
+        # here is to control if we want to build in-place or into the
+        # build-lib folder.  Traditionally this is set by the `inplace`
+        # command line flag for build_ext.  However as we are a subcommand
+        # we need to grab this information from elsewhere.
+        #
+        # An in-place build puts the files generated into the source
+        # folder, a regular build puts the files into the build-lib
+        # folder.
+        #
+        # The following situations we need to cover:
+        #
+        #   command                         default in-place
+        #   setup.py build_js               0
+        #   setup.py build_ext              value of in-place for build_ext
+        #   setup.py build_ext --inplace    1
+        #   pip install --editable .        1
+        #   setup.py install                1
+        #   setup.py sdist                  0
+        #   setup.py bdist_wheel            0
+        #
+        # The way this is achieved is that build_js is invoked by two
+        # subcommands: bdist_ext (which is in our case always executed
+        # due to a custom distribution) or sdist.
+        #
+        # To find the default value of the inplace flag we inspect the
+        # install and build_ext commands.
+        install = self.distribution.get_command_obj('install')
+        build_ext = self.get_finalized_command('build_ext')
+
+        # If we are not decided on in-place we are inplace if either
+        # build_ext is inplace or we are invoked through the install
+        # command (easiest check is to see if it's finalized).
+        if self.inplace is None:
+            self.inplace = (build_ext.inplace or install.finalized) and 1 or 0
+
+        log.info('building JavaScript support.')
+
+        # In place means build_lib is src.  We also log this.
+        if self.inplace:
+            log.info('In-place js building enabled')
+            self.build_lib = 'src'
+        # Otherwise we fetch build_lib from the build command.
+        else:
+            self.set_undefined_options('build',
+                                       ('build_lib', 'build_lib'))
+            log.info('regular js build: build path is %s' %
+                     self.build_lib)
+
+        if self.work_path is None:
+            self.work_path = ROOT
+
     def _get_package_version(self):
         """
         Attempt to get the most correct current version of Sentry.
@@ -201,14 +250,6 @@ class BuildStatic(Command):
             return True
         return False
 
-    def initialize_options(self):
-        self.work_path = None
-        self.force = None
-
-    def finalize_options(self):
-        if self.work_path is None:
-            self.work_path = ROOT
-
     def run(self):
         version_info = self._get_package_version()
         if not (self.force or self._needs_static(version_info)):
@@ -222,6 +263,7 @@ class BuildStatic(Command):
         try:
             self._build_static()
         except Exception:
+            traceback.print_exc()
             log.fatal("unable to build Sentry's static assets!\n"
                       "Hint: You might be running an invalid version of NPM.")
             sys.exit(1)
@@ -233,6 +275,14 @@ class BuildStatic(Command):
                 json.dumps(manifest, indent=2),
             ))
 
+        # if we were invoked from sdist, we need to inform sdist about
+        # which files we just generated.  Otherwise they will be missing
+        # in the manifest.  This adds the files for what webpack generates
+        # plus our own sentry-package.json file.
+        sdist = self.distribution.get_command_obj('sdist')
+        if sdist.finalized and not self.inplace:
+            self._update_sdist_manifest(sdist.filelist)
+
     def _build_static(self):
         work_path = self.work_path
 
@@ -250,8 +300,10 @@ class BuildStatic(Command):
         os.environ['NODE_ENV'] = 'production'
 
         log.info("running [webpack]")
-        check_output([os.path.join('node_modules', '.bin', 'webpack'), '-p', '--bail'],
-                     cwd=work_path)
+        env = dict(os.environ)
+        env['SENTRY_STATIC_DIST_PATH'] = self.sentry_static_dist_path
+        check_output(['node_modules/.bin/webpack', '-p', '--bail'],
+                     cwd=work_path, env=env)
 
     def _write_version_file(self, version_info):
         manifest = {
@@ -259,30 +311,60 @@ class BuildStatic(Command):
             'version': version_info['version'],
             'build': version_info['build'],
         }
-        with open(os.path.join(self.work_path, 'sentry-package.json'), 'w') as fp:
+        with open(os.path.join(self.build_lib, 'sentry-package.json'), 'w') as fp:
             json.dump(manifest, fp)
         return manifest
 
+    def _update_sdist_manifest(self, files):
+        root = self.sentry_static_dist_path
+        for dirname, dirnames, filenames in os.walk(root):
+            for filename in filenames:
+                filename = os.path.join(root, filename)
+                files.append(filename[len(root):].lstrip(os.path.sep))
+        files.append('sentry-package.json')
 
-class SmartInstall(install):
-    """
-    Installs Sentry into the Python environment.
+    @property
+    def sentry_static_dist_path(self):
+        return os.path.abspath(os.path.join(
+            self.build_lib, 'sentry/static/sentry/dist'))
+
+
+class SentrySDistCommand(SDistCommand):
+    # If we are not a light build we want to also execute build_js as
+    # part of our source build pipeline.
+    if not IS_LIGHT_BUILD:
+        sub_commands = SDistCommand.sub_commands + \
+            [('build_js', None)]
+
+
+class SentryBuildExtCommand(BuildExtCommand):
 
-    If the package indicator is missing, this will also force a run of
-    `build_static` which is required for JavaScript assets and other things.
-    """
     def run(self):
+        BuildExtCommand.run(self)
+
+        # If we are not a light build we want to also execute build_js as
+        # part of our build_ext pipeline.  Because setuptools subclasses
+        # this thing really oddly we cannot use sub_commands but have to
+        # manually invoke it here.
         if not IS_LIGHT_BUILD:
-            self.reinitialize_command('build_static')
-            self.run_command('build_static')
-        install.run(self)
+            self.run_command('build_js')
+
+
+class ExtendedDistribution(Distribution):
+
+    def has_ext_modules(self):
+        # We need to always run build_ext so that we invoke the build_js
+        # command which is attached to our own build_ext.  Otherwise
+        # distutils optimizes the invocation of build_ext and we never
+        # get the chance to run.
+        return True
 
 
 setup(
     name='sentry',
     version='8.0.0.dev0',
-    author='David Cramer',
-    author_email='dcramer@gmail.com',
+    author='Sentry',
+    author_email='hello@getsentry.com',
     url='https://getsentry.com',
     description='A realtime logging and aggregation server.',
     long_description=open(os.path.join(ROOT, 'README.rst')).read(),
@@ -297,10 +379,9 @@ setup(
         'postgres_pypy': install_requires + postgres_pypy_requires,
     },
     cmdclass={
-        'build_static': BuildStatic,
-        'develop': DevelopWithBuildStatic,
-        'sdist': SdistWithBuildStatic,
-        'install': SmartInstall,
+        'sdist': SentrySDistCommand,
+        'build_ext': SentryBuildExtCommand,
+        'build_js': BuildJavascriptCommand,
     },
     license='BSD',
     include_package_data=True,
@@ -318,4 +399,5 @@ setup(
         'Operating System :: POSIX :: Linux',
         'Topic :: Software Development'
     ],
+    distclass=ExtendedDistribution,
 )
diff --git a/webpack.config.js b/webpack.config.js
index 17a1a3451f..05a9361672 100644
--- a/webpack.config.js
+++ b/webpack.config.js
@@ -6,6 +6,11 @@ var path = require("path"),
 var staticPrefix = "src/sentry/static/sentry",
     distPath = staticPrefix + "/dist";
 
+// this is set by setup.py sdist
+if (process.env.SENTRY_STATIC_DIST_PATH) {
+    distPath = process.env.SENTRY_STATIC_DIST_PATH;
+}
+
 var config = {
   context: path.join(__dirname, staticPrefix),
   entry: {

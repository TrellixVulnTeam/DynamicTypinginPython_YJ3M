commit ffcc64e99240a2880a2bca1cb08acb8f73345a0c
Author: David Cramer <dcramer@gmail.com>
Date:   Mon Apr 28 16:32:24 2014 -0700

    First pass at Interface refactor

diff --git a/CHANGES b/CHANGES
index b18bb845fe..10eb1b0b27 100644
--- a/CHANGES
+++ b/CHANGES
@@ -9,6 +9,7 @@ Backwards Incompatible Changes
 - The ``is_rate_limited`` plugin hook has been removed in favor of singular quota managers.
 - The trends feature has been removed until it can be reimplemented in a more scalable way.
 - NodeStore.generate_id() now returns a base64-encoded UUID.
+- The API for interfaces has been rewritten.
 
 Version 6.4.0
 -------------
diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index df7c5faab3..6d6f8304ef 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -507,15 +507,21 @@ SENTRY_SMTP_HOSTNAME = 'localhost'
 SENTRY_SMTP_HOST = 'localhost'
 SENTRY_SMTP_PORT = 1025
 
-SENTRY_ALLOWED_INTERFACES = set([
-    'sentry.interfaces.Exception',
-    'sentry.interfaces.Message',
-    'sentry.interfaces.Stacktrace',
-    'sentry.interfaces.Template',
-    'sentry.interfaces.Query',
-    'sentry.interfaces.Http',
-    'sentry.interfaces.User',
-])
+SENTRY_INTERFACES = {
+    'exception': 'sentry.interfaces.exception.Exception',
+    'request': 'sentry.interfaces.http.Http',
+    'stacktrace': 'sentry.interfaces.stacktrace.Stacktrace',
+    'template': 'sentry.interfaces.template.Template',
+    'user': 'sentry.interfaces.user.User',
+
+    'sentry.interfaces.Exception': 'sentry.interfaces.exception.Exception',
+    'sentry.interfaces.Message': 'sentry.interfaces.message.Message',
+    'sentry.interfaces.Stacktrace': 'sentry.interfaces.stacktrace.Stacktrace',
+    'sentry.interfaces.Template': 'sentry.interfaces.template.Template',
+    'sentry.interfaces.Query': 'sentry.interfaces.query.Query',
+    'sentry.interfaces.Http': 'sentry.interfaces.http.Http',
+    'sentry.interfaces.User': 'sentry.interfaces.user.User',
+}
 
 # Should users without 'sentry.add_project' permissions be allowed
 # to create new projects
diff --git a/src/sentry/constants.py b/src/sentry/constants.py
index 75a71f94b1..bcdf7ddb4a 100644
--- a/src/sentry/constants.py
+++ b/src/sentry/constants.py
@@ -220,3 +220,6 @@ TAG_LABELS = {
     'url': _('URL'),
     'server_name': _('Server'),
 }
+
+# methods as defined by http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html + PATCH
+HTTP_METHODS = ('GET', 'POST', 'PUT', 'OPTIONS', 'HEAD', 'DELETE', 'TRACE', 'CONNECT', 'PATCH')
diff --git a/src/sentry/coreapi.py b/src/sentry/coreapi.py
index fe6d7961cc..0b376067b6 100644
--- a/src/sentry/coreapi.py
+++ b/src/sentry/coreapi.py
@@ -37,14 +37,6 @@ logger = logging.getLogger('sentry.coreapi.errors')
 
 LOG_LEVEL_REVERSE_MAP = dict((v, k) for k, v in LOG_LEVELS.iteritems())
 
-INTERFACE_ALIASES = {
-    'exception': 'sentry.interfaces.Exception',
-    'request': 'sentry.interfaces.Http',
-    'user': 'sentry.interfaces.User',
-    'stacktrace': 'sentry.interfaces.Stacktrace',
-    'template': 'sentry.interfaces.Template',
-}
-
 RESERVED_FIELDS = (
     'project',
     'event_id',
@@ -98,11 +90,13 @@ class APIRateLimited(APIError):
 
 
 def get_interface(name):
-    if name not in settings.SENTRY_ALLOWED_INTERFACES:
-        raise ValueError
+    try:
+        import_path = settings.SENTRY_INTERFACES[name]
+    except KeyError:
+        raise ValueError('Invalid interface name: %s' % (name,))
 
     try:
-        interface = import_string(name)
+        interface = import_string(import_path)
     except Exception:
         raise ValueError('Unable to load interface: %s' % (name,))
 
@@ -350,41 +344,31 @@ def validate_data(project, data, client=None):
         if k in RESERVED_FIELDS:
             continue
 
-        if not data[k]:
+        value = data.pop(k)
+
+        if not value:
             logger.info(
                 'Ignored empty interface value: %s', k,
                 **client_metadata(client, project))
-            del data[k]
             continue
 
-        import_path = INTERFACE_ALIASES.get(k, k)
-
-        if '.' not in import_path:
+        try:
+            interface = get_interface(k)
+        except ValueError:
             logger.info(
                 'Ignored unknown attribute: %s', k,
                 **client_metadata(client, project))
-            del data[k]
             continue
 
-        try:
-            interface = get_interface(import_path)
-        except ValueError:
+        if type(value) is not dict:
             logger.info(
-                'Invalid unknown attribute: %s', k,
-                **client_metadata(client, project))
-            del data[k]
+                'Invalid parameters for value: %s (dict expected, got %s)', k,
+                type(value), **client_metadata(client, project))
             continue
 
-        value = data.pop(k)
         try:
-            # HACK: exception allows you to pass the value as a list
-            # so let's try to actually support that
-            if isinstance(value, dict):
-                inst = interface(**value)
-            else:
-                inst = interface(value)
-            inst.validate()
-            data[import_path] = inst.serialize()
+            inst = interface.to_python(value)
+            data[k] = inst.to_json()
         except Exception as e:
             if isinstance(e, AssertionError):
                 log = logger.info
diff --git a/src/sentry/interfaces.py b/src/sentry/interfaces.py
deleted file mode 100644
index 5b9f13c704..0000000000
--- a/src/sentry/interfaces.py
+++ /dev/null
@@ -1,1305 +0,0 @@
-"""
-sentry.interfaces
-~~~~~~~~~~~~~~~~~
-
-Interfaces provide an abstraction for how structured data should be
-validated and rendered.
-
-:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-import itertools
-import re
-import urlparse
-import warnings
-
-from pygments import highlight
-# from pygments.lexers import get_lexer_for_filename, TextLexer, ClassNotFound
-from pygments.lexers import TextLexer
-from pygments.formatters import HtmlFormatter
-from urllib import urlencode
-
-from django.http import QueryDict
-from django.utils.html import escape
-from django.utils.safestring import mark_safe
-from django.utils.translation import ugettext as _
-
-from sentry.app import env
-from sentry.models import UserOption
-from sentry.utils.strings import strip
-from sentry.web.helpers import render_to_string
-
-_Exception = Exception
-_ruby_anon_func = re.compile(r'_\d{2,}')
-_filename_version_re = re.compile(r"""(?:
-    v?(?:\d+\.)*\d+|   # version numbers, v1, 1.0.0
-    [a-f0-9]{7,8}|     # short sha
-    [a-f0-9]{32}|      # md5
-    [a-f0-9]{40}       # sha1
-)/""", re.X | re.I)
-
-
-def unserialize(klass, data):
-    value = object.__new__(klass)
-    value.__setstate__(data)
-    return value
-
-
-def is_url(filename):
-    return filename.startswith(('http:', 'https:', 'file:'))
-
-
-def remove_function_outliers(function):
-    """
-    Attempt to normalize functions by removing common platform outliers.
-
-    - Ruby generates (random?) integers for various anonymous style functions
-      such as in erb and the active_support library.
-    - Block functions have metadata that we don't care about.
-    """
-    if function.startswith('block '):
-        return 'block'
-    return _ruby_anon_func.sub('_<anon>', function)
-
-
-def remove_filename_outliers(filename):
-    """
-    Attempt to normalize filenames by removing common platform outliers.
-
-    - Sometimes filename paths contain build numbers
-    """
-    return _filename_version_re.sub('<version>/', filename)
-
-
-def get_context(lineno, context_line, pre_context=None, post_context=None, filename=None,
-                format=False):
-    lineno = int(lineno)
-    context = []
-    start_lineno = lineno - len(pre_context or [])
-    if pre_context:
-        start_lineno = lineno - len(pre_context)
-        at_lineno = start_lineno
-        for line in pre_context:
-            context.append((at_lineno, line))
-            at_lineno += 1
-    else:
-        start_lineno = lineno
-        at_lineno = lineno
-
-    if start_lineno < 0:
-        start_lineno = 0
-
-    context.append((at_lineno, context_line))
-    at_lineno += 1
-
-    if post_context:
-        for line in post_context:
-            context.append((at_lineno, line))
-            at_lineno += 1
-
-    # HACK:
-    if filename and is_url(filename) and '.' not in filename.rsplit('/', 1)[-1]:
-        filename = 'index.html'
-
-    if format:
-        # try:
-        #     lexer = get_lexer_for_filename(filename)
-        # except ClassNotFound:
-        #     lexer = TextLexer()
-        lexer = TextLexer()
-
-        formatter = HtmlFormatter()
-
-        def format(line):
-            if not line:
-                return mark_safe('<pre></pre>')
-            return mark_safe(highlight(line, lexer, formatter))
-
-        context = tuple((n, format(l)) for n, l in context)
-
-    return context
-
-
-def is_newest_frame_first(event):
-    newest_first = event.platform not in ('python', None)
-
-    if env.request and env.request.user.is_authenticated():
-        display = UserOption.objects.get_value(
-            user=env.request.user,
-            project=None,
-            key='stacktrace_order',
-            default=None,
-        )
-        if display == '1':
-            newest_first = False
-        elif display == '2':
-            newest_first = True
-
-    return newest_first
-
-
-class Interface(object):
-    """
-    An interface is a structured representation of data, which may
-    render differently than the default ``extra`` metadata in an event.
-    """
-
-    score = 0
-    display_score = None
-
-    def __init__(self, **kwargs):
-        self.attrs = kwargs.keys()
-        self.__dict__.update(kwargs)
-
-    def __eq__(self, other):
-        if type(self) != type(other):
-            return False
-        return self.serialize() == other.serialize()
-
-    def __setstate__(self, data):
-        kwargs = self.unserialize(data)
-        self.attrs = kwargs.keys()
-        self.__dict__.update(kwargs)
-
-    def __getstate__(self):
-        return self.serialize()
-
-    def validate(self):
-        pass
-
-    def unserialize(self, data):
-        return data
-
-    def serialize(self):
-        return dict((k, self.__dict__[k]) for k in self.attrs)
-
-    def get_composite_hash(self, interfaces):
-        return self.get_hash()
-
-    def get_hash(self):
-        return []
-
-    def to_html(self, event, is_public=False, **kwargs):
-        return ''
-
-    def to_string(self, event, is_public=False, **kwargs):
-        return ''
-
-    def to_email_html(self, event, **kwargs):
-        body = self.to_string(event)
-        if not body:
-            return ''
-        return '<pre>%s</pre>' % (escape(body).replace('\n', '<br>'),)
-
-    def get_slug(self):
-        return type(self).__name__.lower()
-
-    def get_title(self):
-        return _(type(self).__name__)
-
-    def get_display_score(self):
-        return self.display_score or self.score
-
-    def get_score(self):
-        return self.score
-
-    def get_search_context(self, event):
-        """
-        Returns a dictionary describing the data that should be indexed
-        by the search engine. Several fields are accepted:
-
-        - text: a list of text items to index as part of the generic query
-        - filters: a map of fields which are used for precise matching
-        """
-        return {
-            # 'text': ['...'],
-            # 'filters': {
-            #     'field": ['...'],
-            # },
-        }
-
-
-class Message(Interface):
-    """
-    A standard message consisting of a ``message`` arg, and an optional
-    ``params`` arg for formatting.
-
-    If your message cannot be parameterized, then the message interface
-    will serve no benefit.
-
-    - ``message`` must be no more than 1000 characters in length.
-
-    >>> {
-    >>>     "message": "My raw message with interpreted strings like %s",
-    >>>     "params": ["this"]
-    >>> }
-    """
-    attrs = ('message', 'params')
-
-    def __init__(self, message, params=(), **kwargs):
-        self.message = message
-        self.params = params
-
-    def validate(self):
-        assert len(self.message) <= 5000
-
-    def serialize(self):
-        return {
-            'message': self.message,
-            'params': self.params,
-        }
-
-    def get_hash(self):
-        return [self.message]
-
-    def get_search_context(self, event):
-        if isinstance(self.params, (list, tuple)):
-            params = list(self.params)
-        elif isinstance(self.params, dict):
-            params = self.params.values()
-        else:
-            params = []
-        return {
-            'text': [self.message] + params,
-        }
-
-
-class Query(Interface):
-    """
-    A SQL query with an optional string describing the SQL driver, ``engine``.
-
-    >>> {
-    >>>     "query": "SELECT 1"
-    >>>     "engine": "psycopg2"
-    >>> }
-    """
-    attrs = ('query', 'engine')
-
-    def __init__(self, query, engine=None, **kwargs):
-        self.query = query
-        self.engine = engine
-
-    def get_hash(self):
-        return [self.query]
-
-    def serialize(self):
-        return {
-            'query': self.query,
-            'engine': self.engine,
-        }
-
-    def get_search_context(self, event):
-        return {
-            'text': [self.query],
-        }
-
-
-class Frame(object):
-    attrs = ('abs_path', 'filename', 'lineno', 'colno', 'in_app', 'context_line',
-             'pre_context', 'post_context', 'vars', 'module', 'function', 'data')
-
-    def __init__(self, abs_path=None, filename=None, lineno=None, colno=None,
-                 in_app=None, context_line=None, pre_context=(),
-                 post_context=(), vars=None, module=None, function=None,
-                 data=None, **kwargs):
-        self.abs_path = abs_path or filename
-        self.filename = filename or abs_path
-
-        if self.is_url():
-            urlparts = urlparse.urlparse(self.abs_path)
-            if urlparts.path:
-                self.filename = urlparts.path
-
-        self.module = module
-        self.function = function
-
-        if lineno is not None:
-            self.lineno = int(lineno)
-        else:
-            self.lineno = None
-        if colno is not None:
-            self.colno = int(colno)
-        else:
-            self.colno = None
-
-        self.in_app = in_app
-        self.context_line = context_line
-        self.pre_context = pre_context
-        self.post_context = post_context
-        if isinstance(vars, (list, tuple)):
-            vars = dict(enumerate(vars))
-        if isinstance(data, (list, tuple)):
-            data = dict(enumerate(data))
-        self.vars = vars or {}
-        self.data = data or {}
-
-    def __getitem__(self, key):
-        warnings.warn('Frame[key] is deprecated. Use Frame.key instead.', DeprecationWarning)
-        return getattr(self, key)
-
-    def is_url(self):
-        if not self.abs_path:
-            return False
-        return is_url(self.abs_path)
-
-    def is_valid(self):
-        if self.in_app not in (False, True, None):
-            return False
-        if type(self.vars) != dict:
-            return False
-        if type(self.data) != dict:
-            return False
-        return self.filename or self.function or self.module
-
-    def get_hash(self):
-        """
-        The hash of the frame varies depending on the data available.
-
-        Our ideal scenario is the module name in addition to the line of
-        context. However, in several scenarios we opt for other approaches due
-        to platform constraints.
-
-        This is one of the few areas in Sentry that isn't platform-agnostic.
-        """
-        output = []
-        if self.module:
-            output.append(self.module)
-        elif self.filename and not self.is_url():
-            output.append(remove_filename_outliers(self.filename))
-
-        if self.context_line is None:
-            can_use_context = False
-        elif len(self.context_line) > 120:
-            can_use_context = False
-        # XXX: deal with PHP anonymous functions (used for things like SQL
-        # queries and JSON data)
-        elif self.function and self.function.startswith('[Anonymous'):
-            can_use_context = True
-        else:
-            can_use_context = True
-
-        # XXX: hack around what appear to be non-useful lines of context
-        if can_use_context:
-            output.append(self.context_line)
-        elif not output:
-            # If we were unable to achieve any context at this point
-            # (likely due to a bad JavaScript error) we should just
-            # bail on recording this frame
-            return output
-        elif self.function:
-            output.append(remove_function_outliers(self.function))
-        elif self.lineno is not None:
-            output.append(self.lineno)
-        return output
-
-    def get_context(self, event, is_public=False, **kwargs):
-        if (self.context_line and self.lineno is not None
-                and (self.pre_context or self.post_context)):
-            context = get_context(
-                lineno=self.lineno,
-                context_line=self.context_line,
-                pre_context=self.pre_context,
-                post_context=self.post_context,
-                filename=self.filename or self.module,
-                format=True,
-            )
-            start_lineno = context[0][0]
-        else:
-            context = []
-            start_lineno = None
-
-        frame_data = {
-            'abs_path': self.abs_path,
-            'filename': self.filename,
-            'module': self.module,
-            'function': self.function,
-            'start_lineno': start_lineno,
-            'lineno': self.lineno,
-            'colno': self.colno,
-            'context': context,
-            'context_line': self.context_line,
-            'in_app': self.in_app,
-            'is_url': self.is_url(),
-        }
-        if not is_public:
-            frame_data['vars'] = self.vars or {}
-
-        if event.platform == 'javascript' and self.data:
-            frame_data.update({
-                'sourcemap': self.data['sourcemap'].rsplit('/', 1)[-1],
-                'sourcemap_url': urlparse.urljoin(self.abs_path, self.data['sourcemap']),
-                'orig_function': self.data.get('orig_function', '?'),
-                'orig_abs_path': self.data.get('orig_abs_path', '?'),
-                'orig_filename': self.data.get('orig_filename', '?'),
-                'orig_lineno': self.data.get('orig_lineno', '?'),
-                'orig_colno': self.data.get('orig_colno', '?'),
-            })
-        return frame_data
-
-    def to_string(self, event):
-        if event.platform is not None:
-            choices = [event.platform]
-        else:
-            choices = []
-        choices.append('default')
-        templates = [
-            'sentry/partial/frames/%s.txt' % choice
-            for choice in choices
-        ]
-        return render_to_string(templates, {
-            'abs_path': self.abs_path,
-            'filename': self.filename,
-            'function': self.function,
-            'module': self.module,
-            'lineno': self.lineno,
-            'colno': self.colno,
-            'context_line': self.context_line,
-        }).strip('\n')
-
-
-class Stacktrace(Interface):
-    """
-    A stacktrace contains a list of frames, each with various bits (most optional)
-    describing the context of that frame. Frames should be sorted from oldest
-    to newest.
-
-    The stacktrace contains an element, ``frames``, which is a list of hashes. Each
-    hash must contain **at least** the ``filename`` attribute. The rest of the values
-    are optional, but recommended.
-
-    Additionally, if the list of frames is large, you can explicitly tell the
-    system that you've omitted a range of frames. The ``frames_omitted`` must
-    be a single tuple two values: start and end. For example, if you only
-    removed the 8th frame, the value would be (8, 9), meaning it started at the
-    8th frame, and went until the 9th (the number of frames omitted is
-    end-start). The values should be based on a one-index.
-
-    The list of frames should be ordered by the oldest call first.
-
-    Each frame must contain the following attributes:
-
-    ``filename``
-      The relative filepath to the call
-
-    OR
-
-    ``function``
-      The name of the function being called
-
-    OR
-
-    ``module``
-      Platform-specific module path (e.g. sentry.interfaces.Stacktrace)
-
-    The following additional attributes are supported:
-
-    ``lineno``
-      The line number of the call
-    ``colno``
-      The column number of the call
-    ``abs_path``
-      The absolute path to filename
-    ``context_line``
-      Source code in filename at lineno
-    ``pre_context``
-      A list of source code lines before context_line (in order) -- usually [lineno - 5:lineno]
-    ``post_context``
-      A list of source code lines after context_line (in order) -- usually [lineno + 1:lineno + 5]
-    ``in_app``
-      Signifies whether this frame is related to the execution of the relevant code in this stacktrace. For example,
-      the frames that might power the framework's webserver of your app are probably not relevant, however calls to
-      the framework's library once you start handling code likely are.
-    ``vars``
-      A mapping of variables which were available within this frame (usually context-locals).
-
-    >>> {
-    >>>     "frames": [{
-    >>>         "abs_path": "/real/file/name.py"
-    >>>         "filename": "file/name.py",
-    >>>         "function": "myfunction",
-    >>>         "vars": {
-    >>>             "key": "value"
-    >>>         },
-    >>>         "pre_context": [
-    >>>             "line1",
-    >>>             "line2"
-    >>>         ],
-    >>>         "context_line": "line3",
-    >>>         "lineno": 3,
-    >>>         "in_app": true,
-    >>>         "post_context": [
-    >>>             "line4",
-    >>>             "line5"
-    >>>         ],
-    >>>     }],
-    >>>     "frames_omitted": [13, 56]
-    >>> }
-
-    .. note:: This interface can be passed as the 'stacktrace' key in addition
-              to the full interface path.
-    """
-    attrs = ('frames', 'frames_omitted')
-    score = 1000
-
-    def __init__(self, frames, **kwargs):
-        self.frames = [Frame(**f) for f in frames]
-        self.frames_omitted = kwargs.get('frames_omitted')
-
-    def __iter__(self):
-        return iter(self.frames)
-
-    def validate(self):
-        assert self.frames
-        for frame in self.frames:
-            # ensure we've got the correct required values
-            assert frame.is_valid()
-        assert self.frames_omitted is None or len(self.frames_omitted) == 2
-
-    def serialize(self):
-        frames = []
-        for f in self.frames:
-            # compatibility with old serialization
-            if isinstance(f, Frame):
-                frames.append(vars(f))
-            else:
-                frames.append(f)
-
-        return {
-            'frames': frames,
-            'frames_omitted': self.frames_omitted,
-        }
-
-    def has_app_frames(self):
-        return any(f.in_app is not None for f in self.frames)
-
-    def unserialize(self, data):
-        data['frames'] = [Frame(**f) for f in data.pop('frames', [])]
-        data['frames_omitted'] = data.pop('frames_omitted', None)
-        return data
-
-    def get_composite_hash(self, interfaces):
-        output = self.get_hash()
-        if 'sentry.interfaces.Exception' in interfaces:
-            exc = interfaces['sentry.interfaces.Exception'][0]
-            if exc.type:
-                output.append(exc.type)
-            elif not output:
-                output = exc.get_hash()
-        return output
-
-    def get_hash(self):
-        frames = self.frames
-
-        # TODO(dcramer): this should apply only to JS
-        if len(frames) == 1 and frames[0].lineno == '1' and frames[0].function in ('?', None):
-            return []
-
-        output = []
-        for frame in frames:
-            output.extend(frame.get_hash())
-        return output
-
-    def get_context(self, event, is_public=False, newest_first=None,
-                    with_stacktrace=True, **kwargs):
-        system_frames = 0
-        frames = []
-        for frame in self.frames:
-            frames.append(frame.get_context(event=event, is_public=is_public))
-
-            if not frame.in_app:
-                system_frames += 1
-
-        if len(frames) == system_frames:
-            system_frames = 0
-
-        # if theres no system frames, pretend they're all part of the app
-        if not system_frames:
-            for frame in frames:
-                frame['in_app'] = True
-
-        if newest_first is None:
-            newest_first = is_newest_frame_first(event)
-        if newest_first:
-            frames = frames[::-1]
-
-        if self.frames_omitted:
-            first_frame_omitted, last_frame_omitted = self.frames_omitted
-        else:
-            first_frame_omitted, last_frame_omitted = None, None
-
-        context = {
-            'is_public': is_public,
-            'newest_first': newest_first,
-            'system_frames': system_frames,
-            'event': event,
-            'frames': frames,
-            'stack_id': 'stacktrace_1',
-            'first_frame_omitted': first_frame_omitted,
-            'last_frame_omitted': last_frame_omitted,
-        }
-        if with_stacktrace:
-            context['stacktrace'] = self.get_traceback(event, newest_first=newest_first)
-        return context
-
-    def to_html(self, event, **kwargs):
-        context = self.get_context(
-            event=event,
-            **kwargs
-        )
-        return render_to_string('sentry/partial/interfaces/stacktrace.html', context)
-
-    def to_string(self, event, is_public=False, **kwargs):
-        return self.get_stacktrace(event, system_frames=False, max_frames=5)
-
-    def get_stacktrace(self, event, system_frames=True, newest_first=None,
-                       max_frames=None, header=True):
-        if newest_first is None:
-            newest_first = is_newest_frame_first(event)
-
-        result = []
-        if header:
-            if newest_first:
-                result.append(_('Stacktrace (most recent call first):'))
-            else:
-                result.append(_('Stacktrace (most recent call last):'))
-
-            result.append('')
-
-        frames = self.frames
-
-        num_frames = len(frames)
-
-        if not system_frames:
-            frames = [f for f in frames if f.in_app is not False]
-            if not frames:
-                frames = self.frames
-
-        if newest_first:
-            frames = frames[::-1]
-
-        if max_frames:
-            visible_frames = max_frames
-            if newest_first:
-                start, stop = None, max_frames
-            else:
-                start, stop = -max_frames, None
-
-        else:
-            visible_frames = len(frames)
-            start, stop = None, None
-
-        if not newest_first and visible_frames < num_frames:
-            result.extend(('(%d additional frame(s) were not displayed)' % (num_frames - visible_frames,), '...'))
-
-        for frame in frames[start:stop]:
-            result.append(frame.to_string(event))
-
-        if newest_first and visible_frames < num_frames:
-            result.extend(('...', '(%d additional frame(s) were not displayed)' % (num_frames - visible_frames,)))
-
-        return '\n'.join(result)
-
-    def get_traceback(self, event, newest_first=None):
-        result = [
-            event.message, '',
-            self.get_stacktrace(event, newest_first=newest_first),
-        ]
-
-        return '\n'.join(result)
-
-    def get_search_context(self, event):
-        return {
-            'text': list(itertools.chain(*[[f.filename, f.function, f.context_line] for f in self.frames])),
-        }
-
-
-class SingleException(Interface):
-    """
-    A standard exception with a mandatory ``value`` argument, and optional
-    ``type`` and``module`` argument describing the exception class type and
-    module namespace.
-
-    You can also optionally bind a stacktrace interface to an exception. The
-    spec is identical to ``sentry.interfaces.Stacktrace``.
-
-    >>>  {
-    >>>     "type": "ValueError",
-    >>>     "value": "My exception value",
-    >>>     "module": "__builtins__"
-    >>>     "stacktrace": {
-    >>>         # see sentry.interfaces.Stacktrace
-    >>>     }
-    >>> }
-    """
-    attrs = ('value', 'type', 'module', 'stacktrace')
-
-    score = 900
-    display_score = 1200
-
-    def __init__(self, value, type=None, module=None, stacktrace=None, **kwargs):
-        # A human readable value for the exception
-        self.value = value
-        # The exception type name (e.g. TypeError)
-        self.type = type
-        # Optional module of the exception type (e.g. __builtin__)
-        self.module = module
-        # Optional bound stacktrace interface
-        if stacktrace:
-            self.stacktrace = Stacktrace(**stacktrace)
-        else:
-            self.stacktrace = None
-
-    def validate(self):
-        if self.stacktrace:
-            return self.stacktrace.validate()
-
-    def serialize(self):
-        if self.stacktrace:
-            stacktrace = self.stacktrace.serialize()
-        else:
-            stacktrace = None
-
-        return {
-            'type': strip(self.type) or None,
-            'value': strip(self.value) or None,
-            'module': strip(self.module) or None,
-            'stacktrace': stacktrace,
-        }
-
-    def unserialize(self, data):
-        if data.get('stacktrace'):
-            data['stacktrace'] = unserialize(Stacktrace, data['stacktrace'])
-        else:
-            data['stacktrace'] = None
-        return data
-
-    def get_hash(self):
-        output = None
-        if self.stacktrace:
-            output = self.stacktrace.get_hash()
-            if output and self.type:
-                output.append(self.type)
-        if not output:
-            output = filter(bool, [self.type, self.value])
-        return output
-
-    def get_context(self, event, is_public=False, **kwargs):
-        last_frame = None
-        interface = event.interfaces.get('sentry.interfaces.Stacktrace')
-        if interface is not None and interface.frames:
-            last_frame = interface.frames[-1]
-
-        e_module = strip(self.module)
-        e_type = strip(self.type) or 'Exception'
-        e_value = strip(self.value)
-
-        if self.module:
-            fullname = '%s.%s' % (e_module, e_type)
-        else:
-            fullname = e_type
-
-        return {
-            'is_public': is_public,
-            'event': event,
-            'exception_value': e_value or e_type or '<empty value>',
-            'exception_type': e_type,
-            'exception_module': e_module,
-            'fullname': fullname,
-            'last_frame': last_frame
-        }
-
-    def get_search_context(self, event):
-        return {
-            'text': [self.value, self.type, self.module]
-        }
-
-
-class Exception(Interface):
-    """
-    An exception consists of a list of values. In most cases, this list
-    contains a single exception, with an optional stacktrace interface.
-
-    Each exception has a mandatory ``value`` argument and optional ``type`` and
-    ``module`` arguments describing the exception class type and module
-    namespace.
-
-    You can also optionally bind a stacktrace interface to an exception. The
-    spec is identical to ``sentry.interfaces.Stacktrace``.
-
-    >>> [{
-    >>>     "type": "ValueError",
-    >>>     "value": "My exception value",
-    >>>     "module": "__builtins__"
-    >>>     "stacktrace": {
-    >>>         # see sentry.interfaces.Stacktrace
-    >>>     }
-    >>> }]
-
-    Values should be sent oldest to newest, this includes both the stacktrace
-    and the exception itself.
-
-    .. note:: This interface can be passed as the 'exception' key in addition
-              to the full interface path.
-    """
-
-    attrs = ('values',)
-    score = 2000
-
-    def __init__(self, *args, **kwargs):
-        if 'values' in kwargs:
-            values = kwargs['values']
-        elif not kwargs and len(args) == 1 and isinstance(args[0], (list, tuple)):
-            values = args[0]
-        else:
-            values = [kwargs]
-
-        self.values = [SingleException(**e) for e in values]
-
-    def __getitem__(self, key):
-        return self.values[key]
-
-    def __iter__(self):
-        return iter(self.values)
-
-    def __len__(self):
-        return len(self.values)
-
-    def validate(self):
-        assert self.values
-        for exception in self.values:
-            # ensure we've got the correct required values
-            exception.validate()
-
-    def serialize(self):
-        return {
-            'values': [e.serialize() for e in self.values]
-        }
-
-    def unserialize(self, data):
-        if 'values' not in data:
-            data = {'values': [data]}
-        data['values'] = [unserialize(SingleException, v) for v in data['values']]
-        return data
-
-    def get_hash(self):
-        output = []
-        for value in self.values:
-            output.extend(value.get_hash())
-        return output
-
-    def get_composite_hash(self, interfaces):
-        # optimize around the fact that some exceptions might have stacktraces
-        # while others may not and we ALWAYS want stacktraces over values
-        output = []
-        for value in self.values:
-            if not value.stacktrace:
-                continue
-            stack_hash = value.stacktrace.get_hash()
-            if stack_hash:
-                output.extend(stack_hash)
-                output.append(value.type)
-
-        if not output:
-            for value in self.values:
-                output.extend(value.get_composite_hash(interfaces))
-
-        return output
-
-    def get_context(self, event, is_public=False, **kwargs):
-        newest_first = is_newest_frame_first(event)
-        context_kwargs = {
-            'event': event,
-            'is_public': is_public,
-            'newest_first': newest_first,
-        }
-
-        exceptions = []
-        last = len(self.values) - 1
-        for num, e in enumerate(self.values):
-            context = e.get_context(**context_kwargs)
-            if e.stacktrace:
-                context['stacktrace'] = e.stacktrace.get_context(
-                    with_stacktrace=False, **context_kwargs)
-            else:
-                context['stacktrace'] = {}
-            context['stack_id'] = 'exception_%d' % (num,)
-            context['is_root'] = num == last
-            exceptions.append(context)
-
-        if newest_first:
-            exceptions.reverse()
-
-        return {
-            'newest_first': newest_first,
-            'system_frames': sum(e['stacktrace'].get('system_frames', 0) for e in exceptions),
-            'exceptions': exceptions,
-            'stacktrace': self.get_stacktrace(event, newest_first=newest_first)
-        }
-
-    def to_html(self, event, **kwargs):
-        if not self.values:
-            return ''
-
-        if len(self.values) == 1 and not self.values[0].stacktrace:
-            exception = self.values[0]
-            context = exception.get_context(event=event, **kwargs)
-            return render_to_string('sentry/partial/interfaces/exception.html', context)
-
-        context = self.get_context(event=event, **kwargs)
-        return render_to_string('sentry/partial/interfaces/chained_exception.html', context)
-
-    def to_string(self, event, is_public=False, **kwargs):
-        if not self.values:
-            return ''
-
-        output = []
-        for exc in self.values:
-            output.append(u'{0}: {1}\n'.format(exc.type, exc.value))
-            if exc.stacktrace:
-                output.append(exc.stacktrace.get_stacktrace(
-                    event, system_frames=False, max_frames=5,
-                    header=False) + '\n\n')
-        return (''.join(output)).strip()
-
-    def get_search_context(self, event):
-        return self.values[0].get_search_context(event)
-
-    def get_stacktrace(self, *args, **kwargs):
-        exc = self.values[0]
-        if exc.stacktrace:
-            return exc.stacktrace.get_stacktrace(*args, **kwargs)
-        return ''
-
-
-class Http(Interface):
-    """
-    The Request information is stored in the Http interface. Two arguments
-    are required: ``url`` and ``method``.
-
-    The ``env`` variable is a compounded dictionary of HTTP headers as well
-    as environment information passed from the webserver. Sentry will explicitly
-    look for ``REMOTE_ADDR`` in ``env`` for things which require an IP address.
-
-    The ``data`` variable should only contain the request body (not the query
-    string). It can either be a dictionary (for standard HTTP requests) or a
-    raw request body.
-
-    >>>  {
-    >>>     "url": "http://absolute.uri/foo",
-    >>>     "method": "POST",
-    >>>     "data": {
-    >>>         "foo": "bar"
-    >>>     },
-    >>>     "query_string": "hello=world",
-    >>>     "cookies": "foo=bar",
-    >>>     "headers": {
-    >>>         "Content-Type": "text/html"
-    >>>     },
-    >>>     "env": {
-    >>>         "REMOTE_ADDR": "192.168.0.1"
-    >>>     }
-    >>>  }
-
-    .. note:: This interface can be passed as the 'request' key in addition
-              to the full interface path.
-    """
-    attrs = ('url', 'method', 'data', 'query_string', 'cookies', 'headers',
-             'env')
-
-    display_score = 1000
-    score = 800
-
-    # methods as defined by http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html + PATCH
-    METHODS = ('GET', 'POST', 'PUT', 'OPTIONS', 'HEAD', 'DELETE', 'TRACE', 'CONNECT', 'PATCH')
-
-    def __init__(self, url, method=None, data=None, query_string=None, cookies=None, headers=None, env=None, **kwargs):
-        if data is None:
-            data = {}
-
-        if method:
-            method = method.upper()
-
-        scheme, netloc, path, query, fragment = urlparse.urlsplit(url)
-
-        if query_string:
-            # if querystring was a dict, convert it to a string
-            if isinstance(query_string, dict):
-                query = urlencode(query_string.items())
-            else:
-                query = query_string
-                if query[0] == '?':
-                    # remove '?' prefix
-                    query = query[1:]
-
-        if isinstance(data, (list, tuple)):
-            data = dict(enumerate(data))
-
-        self.url = urlparse.urlunsplit((scheme, netloc, path, query, fragment))
-        self.method = method
-        self.data = data
-        self.query_string = query
-        self.fragment = fragment
-        if cookies:
-            self.cookies = cookies
-        else:
-            self.cookies = {}
-        # if cookies were a string, convert to a dict
-        # parse_qsl will parse both acceptable formats:
-        #  a=b&c=d
-        # and
-        #  a=b; c=d
-        if isinstance(self.cookies, basestring):
-            self.cookies = dict(urlparse.parse_qsl(self.cookies, keep_blank_values=True))
-        # if cookies were [also] included in headers we
-        # strip them out
-        if headers and 'Cookie' in headers:
-            cookies = headers.pop('Cookie')
-            if cookies:
-                self.cookies = cookies
-        self.headers = headers or {}
-        self.env = env or {}
-
-    @property
-    def short_url(self):
-        scheme, netloc, path, _, _ = urlparse.urlsplit(self.url)
-        return urlparse.urlunsplit((scheme, netloc, path, None, None))
-
-    def serialize(self):
-        return {
-            'url': self.url,
-            'method': self.method,
-            'data': self.data,
-            'query_string': self.query_string,
-            'cookies': self.cookies,
-            'headers': self.headers,
-            'env': self.env,
-        }
-
-    def to_email_html(self, event, **kwargs):
-        return render_to_string('sentry/partial/interfaces/http_email.html', {
-            'event': event,
-            'url': self.url,
-            'short_url': self.short_url,
-            'method': self.method,
-            'query_string': self.query_string,
-        })
-
-    def _to_dict(self, value):
-        if value is None:
-            value = {}
-        if isinstance(value, dict):
-            return True, value
-        try:
-            value = QueryDict(value)
-        except _Exception:
-            return False, value
-        else:
-            return True, value
-
-    def to_html(self, event, is_public=False, **kwargs):
-        data = self.data
-        headers_is_dict, headers = self._to_dict(self.headers)
-
-        # educated guess as to whether the body is normal POST data
-        if headers_is_dict and headers.get('Content-Type') == 'application/x-www-form-urlencoded' and '=' in data:
-            _, data = self._to_dict(data)
-
-        context = {
-            'is_public': is_public,
-            'event': event,
-            'url': self.url,
-            'short_url': self.short_url,
-            'method': self.method,
-            'query_string': self.query_string,
-            'fragment': self.fragment,
-            'headers': self.headers,
-        }
-        if not is_public:
-            # It's kind of silly we store this twice
-            _, cookies = self._to_dict(self.cookies)
-
-            context.update({
-                'cookies': cookies,
-                'env': self.env,
-                'data': data,
-            })
-
-        return render_to_string('sentry/partial/interfaces/http.html', context)
-
-    def get_title(self):
-        return _('Request')
-
-    def get_search_context(self, event):
-        return {
-            'filters': {
-                'url': [self.short_url],
-            }
-        }
-
-
-class Template(Interface):
-    """
-    A rendered template (generally used like a single frame in a stacktrace).
-
-    The attributes ``filename``, ``context_line``, and ``lineno`` are required.
-
-    >>>  {
-    >>>     "abs_path": "/real/file/name.html"
-    >>>     "filename": "file/name.html",
-    >>>     "pre_context": [
-    >>>         "line1",
-    >>>         "line2"
-    >>>     ],
-    >>>     "context_line": "line3",
-    >>>     "lineno": 3,
-    >>>     "post_context": [
-    >>>         "line4",
-    >>>         "line5"
-    >>>     ],
-    >>> }
-
-    .. note:: This interface can be passed as the 'template' key in addition
-              to the full interface path.
-    """
-    attrs = ('filename', 'context_line', 'lineno', 'pre_context', 'post_context',
-             'abs_path')
-    score = 1100
-
-    def __init__(self, filename, context_line, lineno, pre_context=None, post_context=None,
-                 abs_path=None, **kwargs):
-        self.abs_path = abs_path
-        self.filename = filename
-        self.context_line = context_line
-        self.lineno = int(lineno)
-        self.pre_context = pre_context
-        self.post_context = post_context
-
-    def serialize(self):
-        return {
-            'abs_path': self.abs_path,
-            'filename': self.filename,
-            'context_line': self.context_line,
-            'lineno': self.lineno,
-            'pre_context': self.pre_context,
-            'post_context': self.post_context,
-        }
-
-    def get_hash(self):
-        return [self.filename, self.context_line]
-
-    def to_string(self, event, is_public=False, **kwargs):
-        context = get_context(
-            lineno=self.lineno,
-            context_line=self.context_line,
-            pre_context=self.pre_context,
-            post_context=self.post_context,
-            filename=self.filename,
-            format=False,
-        )
-
-        result = [
-            'Stacktrace (most recent call last):', '',
-            self.get_traceback(event, context)
-        ]
-
-        return '\n'.join(result)
-
-    def to_html(self, event, is_public=False, **kwargs):
-        context = get_context(
-            lineno=self.lineno,
-            context_line=self.context_line,
-            pre_context=self.pre_context,
-            post_context=self.post_context,
-            filename=self.filename,
-            format=True,
-        )
-
-        return render_to_string('sentry/partial/interfaces/template.html', {
-            'event': event,
-            'abs_path': self.abs_path,
-            'filename': self.filename,
-            'lineno': int(self.lineno),
-            'start_lineno': context[0][0],
-            'context': context,
-            'template': self.get_traceback(event, context),
-            'is_public': is_public,
-        })
-
-    def get_traceback(self, event, context):
-        result = [
-            event.message, '',
-            'File "%s", line %s' % (self.filename, self.lineno), '',
-        ]
-        result.extend([n[1].strip('\n') for n in context])
-
-        return '\n'.join(result)
-
-    def get_search_context(self, event):
-        return {
-            'text': [self.abs_path, self.filename, self.context_line],
-        }
-
-
-class User(Interface):
-    """
-    An interface which describes the authenticated User for a request.
-
-    You should provide **at least** either an `id` (a unique identifier for
-    an authenticated user) or `ip_address` (their IP address).
-
-    All other data is.
-
-    >>> {
-    >>>     "id": "unique_id",
-    >>>     "username": "my_user",
-    >>>     "email": "foo@example.com"
-    >>>     "ip_address": "127.0.0.1"
-    >>> }
-    """
-    attrs = ('id', 'email', 'username', 'data')
-
-    def __init__(self, id=None, email=None, username=None, ip_address=None, **kwargs):
-        self.id = id
-        self.email = email
-        self.username = username
-        self.ip_address = ip_address
-        self.data = kwargs.get('data', kwargs)
-
-    def serialize(self):
-        # XXX: legacy -- delete
-        if hasattr(self, 'is_authenticated'):
-            self.data['is_authenticated'] = self.is_authenticated
-
-        return {
-            'id': self.id,
-            'username': self.username,
-            'email': self.email,
-            'ip_address': getattr(self, 'ip_address', None),
-            'data': self.data,
-        }
-
-    def get_hash(self):
-        return []
-
-    def to_html(self, event, is_public=False, **kwargs):
-        if is_public:
-            return ''
-        return render_to_string('sentry/partial/interfaces/user.html', {
-            'is_public': is_public,
-            'event': event,
-            'user_ip_address': self.ip_address,
-            'user_id': self.id,
-            'user_username': self.username,
-            'user_email': self.email,
-            'user_data': self.data,
-        })
-
-    def get_search_context(self, event):
-        tokens = filter(bool, [self.id, self.username, self.email])
-        if not tokens:
-            return {}
-
-        return {
-            'text': tokens
-        }
diff --git a/src/sentry/interfaces/__init__.py b/src/sentry/interfaces/__init__.py
new file mode 100644
index 0000000000..4cfade7f18
--- /dev/null
+++ b/src/sentry/interfaces/__init__.py
@@ -0,0 +1,8 @@
+"""
+sentry.interfaces
+~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+from __future__ import absolute_import
diff --git a/src/sentry/interfaces/base.py b/src/sentry/interfaces/base.py
new file mode 100644
index 0000000000..de3cdcec54
--- /dev/null
+++ b/src/sentry/interfaces/base.py
@@ -0,0 +1,66 @@
+from django.utils.html import escape
+from django.utils.translation import ugettext as _
+
+
+class Interface(object):
+    """
+    An interface is a structured representation of data, which may
+    render differently than the default ``extra`` metadata in an event.
+    """
+
+    score = 0
+    display_score = None
+
+    def __init__(self, **data):
+        self._data = data or {}
+
+    def __eq__(self, other):
+        if type(self) != type(other):
+            return False
+        return self._data == other._data
+
+    def __getattr__(self, name):
+        return self._data[name]
+
+    def __setattr__(self, name, value):
+        if name == '_data':
+            self.__dict__['_data'] = value
+        else:
+            self._data[name] = value
+
+    @classmethod
+    def to_python(cls, data):
+        return cls(data)
+
+    def to_json(self):
+        return self._data.copy()
+
+    def get_composite_hash(self, interfaces):
+        return self.get_hash()
+
+    def get_hash(self):
+        return []
+
+    def get_slug(self):
+        return type(self).__name__.lower()
+
+    def get_title(self):
+        return _(type(self).__name__)
+
+    def get_display_score(self):
+        return self.display_score or self.score
+
+    def get_score(self):
+        return self.score
+
+    def to_html(self, event, is_public=False, **kwargs):
+        return ''
+
+    def to_string(self, event, is_public=False, **kwargs):
+        return ''
+
+    def to_email_html(self, event, **kwargs):
+        body = self.to_string(event)
+        if not body:
+            return ''
+        return '<pre>%s</pre>' % (escape(body).replace('\n', '<br>'),)
diff --git a/src/sentry/interfaces/exception.py b/src/sentry/interfaces/exception.py
new file mode 100644
index 0000000000..69c4e931c4
--- /dev/null
+++ b/src/sentry/interfaces/exception.py
@@ -0,0 +1,248 @@
+"""
+sentry.interfaces.exception
+~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+__all__ = ('Exception',)
+
+from sentry.interfaces.base import Interface
+from sentry.interfaces.stacktrace import Stacktrace, is_newest_frame_first
+from sentry.utils.safe import trim
+from sentry.web.helpers import render_to_string
+
+
+class SingleException(Interface):
+    """
+    A standard exception with a mandatory ``value`` argument, and optional
+    ``type`` and``module`` argument describing the exception class type and
+    module namespace.
+
+    You can also optionally bind a stacktrace interface to an exception. The
+    spec is identical to ``sentry.interfaces.Stacktrace``.
+
+    >>>  {
+    >>>     "type": "ValueError",
+    >>>     "value": "My exception value",
+    >>>     "module": "__builtins__"
+    >>>     "stacktrace": {
+    >>>         # see sentry.interfaces.Stacktrace
+    >>>     }
+    >>> }
+    """
+    score = 900
+    display_score = 1200
+
+    @classmethod
+    def to_python(cls, data):
+        assert data['value']
+
+        if data.get('stacktrace'):
+            stacktrace = Stacktrace.to_python(data['stacktrace'])
+        else:
+            stacktrace = None
+
+        kwargs = {
+            'value': trim(data['value'], 256),
+            'type': trim(data.get('type'), 128),
+            'module': trim(data.get('module'), 128),
+            'stacktrace': stacktrace,
+        }
+
+        return cls(**kwargs)
+
+    def to_json(self):
+        if self.stacktrace:
+            stacktrace = self.stacktrace.to_json()
+        else:
+            stacktrace = None
+
+        return {
+            'value': self.value,
+            'type': self.type,
+            'module': self.module,
+            'stacktrace': stacktrace,
+        }
+
+    def get_hash(self):
+        output = None
+        if self.stacktrace:
+            output = self.stacktrace.get_hash()
+            if output and self.type:
+                output.append(self.type)
+        if not output:
+            output = filter(bool, [self.type, self.value])
+        return output
+
+    def get_context(self, event, is_public=False, **kwargs):
+        last_frame = None
+        interface = event.interfaces.get('sentry.interfaces.Stacktrace')
+        if interface is not None and interface.frames:
+            last_frame = interface.frames[-1]
+
+        e_module = self.module
+        e_type = self.type or 'Exception'
+        e_value = self.value
+
+        if self.module:
+            fullname = '%s.%s' % (e_module, e_type)
+        else:
+            fullname = e_type
+
+        return {
+            'is_public': is_public,
+            'event': event,
+            'exception_value': e_value or e_type or '<empty value>',
+            'exception_type': e_type,
+            'exception_module': e_module,
+            'fullname': fullname,
+            'last_frame': last_frame
+        }
+
+
+class Exception(Interface):
+    """
+    An exception consists of a list of values. In most cases, this list
+    contains a single exception, with an optional stacktrace interface.
+
+    Each exception has a mandatory ``value`` argument and optional ``type`` and
+    ``module`` arguments describing the exception class type and module
+    namespace.
+
+    You can also optionally bind a stacktrace interface to an exception. The
+    spec is identical to ``sentry.interfaces.Stacktrace``.
+
+    >>> [{
+    >>>     "type": "ValueError",
+    >>>     "value": "My exception value",
+    >>>     "module": "__builtins__"
+    >>>     "stacktrace": {
+    >>>         # see sentry.interfaces.Stacktrace
+    >>>     }
+    >>> }]
+
+    Values should be sent oldest to newest, this includes both the stacktrace
+    and the exception itself.
+
+    .. note:: This interface can be passed as the 'exception' key in addition
+              to the full interface path.
+    """
+
+    score = 2000
+
+    @classmethod
+    def to_python(cls, data):
+        if 'values' in data:
+            values = data['values']
+        else:
+            values = [data]
+
+        assert values
+
+        kwargs = {
+            'values': [SingleException.to_python(v) for v in values],
+        }
+
+        return cls(**kwargs)
+
+    def to_json(self):
+        return {
+            'values': [v.to_json() for v in self.values],
+        }
+
+    def __getitem__(self, key):
+        return self.values[key]
+
+    def __iter__(self):
+        return iter(self.values)
+
+    def __len__(self):
+        return len(self.values)
+
+    def get_hash(self):
+        output = []
+        for value in self.values:
+            output.extend(value.get_hash())
+        return output
+
+    def get_composite_hash(self, interfaces):
+        # optimize around the fact that some exceptions might have stacktraces
+        # while others may not and we ALWAYS want stacktraces over values
+        output = []
+        for value in self.values:
+            if not value.stacktrace:
+                continue
+            stack_hash = value.stacktrace.get_hash()
+            if stack_hash:
+                output.extend(stack_hash)
+                output.append(value.type)
+
+        if not output:
+            for value in self.values:
+                output.extend(value.get_composite_hash(interfaces))
+
+        return output
+
+    def get_context(self, event, is_public=False, **kwargs):
+        newest_first = is_newest_frame_first(event)
+        context_kwargs = {
+            'event': event,
+            'is_public': is_public,
+            'newest_first': newest_first,
+        }
+
+        exceptions = []
+        last = len(self.values) - 1
+        for num, e in enumerate(self.values):
+            context = e.get_context(**context_kwargs)
+            if e.stacktrace:
+                context['stacktrace'] = e.stacktrace.get_context(
+                    with_stacktrace=False, **context_kwargs)
+            else:
+                context['stacktrace'] = {}
+            context['stack_id'] = 'exception_%d' % (num,)
+            context['is_root'] = num == last
+            exceptions.append(context)
+
+        if newest_first:
+            exceptions.reverse()
+
+        return {
+            'newest_first': newest_first,
+            'system_frames': sum(e['stacktrace'].get('system_frames', 0) for e in exceptions),
+            'exceptions': exceptions,
+            'stacktrace': self.get_stacktrace(event, newest_first=newest_first)
+        }
+
+    def to_html(self, event, **kwargs):
+        if not self.values:
+            return ''
+
+        if len(self.values) == 1 and not self.values[0].stacktrace:
+            exception = self.values[0]
+            context = exception.get_context(event=event, **kwargs)
+            return render_to_string('sentry/partial/interfaces/exception.html', context)
+
+        context = self.get_context(event=event, **kwargs)
+        return render_to_string('sentry/partial/interfaces/chained_exception.html', context)
+
+    def to_string(self, event, is_public=False, **kwargs):
+        if not self.values:
+            return ''
+
+        output = []
+        for exc in self.values:
+            output.append(u'{0}: {1}\n'.format(exc.type, exc.value))
+            if exc.stacktrace:
+                output.append(exc.stacktrace.get_stacktrace(
+                    event, system_frames=False, max_frames=5,
+                    header=False) + '\n\n')
+        return (''.join(output)).strip()
+
+    def get_stacktrace(self, *args, **kwargs):
+        exc = self.values[0]
+        if exc.stacktrace:
+            return exc.stacktrace.get_stacktrace(*args, **kwargs)
+        return ''
diff --git a/src/sentry/interfaces/http.py b/src/sentry/interfaces/http.py
new file mode 100644
index 0000000000..eaf19364e5
--- /dev/null
+++ b/src/sentry/interfaces/http.py
@@ -0,0 +1,169 @@
+"""
+sentry.interfaces.http
+~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+__all__ = ('Http',)
+
+from django.utils.translation import ugettext as _
+from urllib import urlencode
+from urlparse import parse_qsl, urlsplit, urlunsplit
+
+from sentry.constants import HTTP_METHODS
+from sentry.interfaces.base import Interface
+from sentry.utils.safe import trim, trim_dict
+from sentry.web.helpers import render_to_string
+
+
+class Http(Interface):
+    """
+    The Request information is stored in the Http interface. Two arguments
+    are required: ``url`` and ``method``.
+
+    The ``env`` variable is a compounded dictionary of HTTP headers as well
+    as environment information passed from the webserver. Sentry will explicitly
+    look for ``REMOTE_ADDR`` in ``env`` for things which require an IP address.
+
+    The ``data`` variable should only contain the request body (not the query
+    string). It can either be a dictionary (for standard HTTP requests) or a
+    raw request body.
+
+    >>>  {
+    >>>     "url": "http://absolute.uri/foo",
+    >>>     "method": "POST",
+    >>>     "data": {
+    >>>         "foo": "bar"
+    >>>     },
+    >>>     "query_string": "hello=world",
+    >>>     "cookies": "foo=bar",
+    >>>     "headers": {
+    >>>         "Content-Type": "text/html"
+    >>>     },
+    >>>     "env": {
+    >>>         "REMOTE_ADDR": "192.168.0.1"
+    >>>     }
+    >>>  }
+
+    .. note:: This interface can be passed as the 'request' key in addition
+              to the full interface path.
+    """
+    display_score = 1000
+    score = 800
+
+    FORM_TYPE = 'application/x-www-form-urlencoded'
+
+    @classmethod
+    def to_python(cls, data):
+        assert data.get('url')
+
+        kwargs = {}
+
+        if data.get('method'):
+            method = data['method'].upper()
+            assert method in HTTP_METHODS
+            kwargs['method'] = method
+        else:
+            kwargs['method'] = None
+
+        scheme, netloc, path, query_bit, fragment_bit = urlsplit(data['url'])
+
+        query_string = data.get('query_string') or query_bit
+        if query_string:
+            # if querystring was a dict, convert it to a string
+            if isinstance(query_string, dict):
+                query_string = urlencode(query_string.items())
+            else:
+                query_string = query_string
+                if query_string[0] == '?':
+                    # remove '?' prefix
+                    query_string = query_string[1:]
+            kwargs['query_string'] = trim(query_string, 1024)
+        else:
+            kwargs['query_string'] = ''
+
+        fragment = data.get('fragment') or fragment_bit
+
+        cookies = data.get('cookies')
+        # if cookies were [also] included in headers we
+        # strip them out
+        headers = data.get('headers')
+        if headers:
+            if 'Cookie' in headers and not cookies:
+                cookies = headers.pop('Cookie')
+            headers = trim_dict(headers)
+        else:
+            headers = {}
+
+        body = data.get('data')
+        if isinstance(body, (list, tuple)):
+            body = trim_dict(dict(enumerate(body)))
+        elif isinstance(body, dict):
+            body = trim_dict(body)
+        else:
+            body = trim(body, 2048)
+            if headers.get('Content-Type') == cls.FORM_TYPE and '=' in body:
+                body = dict(parse_qsl(body))
+
+        # if cookies were a string, convert to a dict
+        # parse_qsl will parse both acceptable formats:
+        #  a=b&c=d
+        # and
+        #  a=b;c=d
+        if isinstance(cookies, basestring):
+            cookies = dict(parse_qsl(cookies, keep_blank_values=True))
+        elif not cookies:
+            cookies = {}
+
+        kwargs['cookies'] = trim_dict(cookies)
+        kwargs['env'] = trim_dict(data.get('env') or {})
+        kwargs['headers'] = headers
+        kwargs['data'] = body
+        kwargs['url'] = urlunsplit((scheme, netloc, path, '', ''))
+        kwargs['fragment'] = trim(fragment, 256)
+
+        return cls(**kwargs)
+
+    @property
+    def full_url(self):
+        url = self.url
+        if self.query_string:
+            url = url + '?' + self.query_string
+        if self.fragment:
+            url = url + '#' + self.fragment
+        return url
+
+    def to_email_html(self, event, **kwargs):
+        return render_to_string('sentry/partial/interfaces/http_email.html', {
+            'event': event,
+            'url': self.full_url,
+            'short_url': self.url,
+            'method': self.method,
+            'query_string': self.query_string,
+        })
+
+    def to_html(self, event, is_public=False, **kwargs):
+        context = {
+            'is_public': is_public,
+            'event': event,
+            'url': self.full_url,
+            'short_url': self.url,
+            'method': self.method,
+            'query_string': self.query_string,
+            'fragment': self.fragment,
+            'headers': self.headers,
+        }
+        if not is_public:
+            # It's kind of silly we store this twice
+            context.update({
+                'cookies': self.cookies,
+                'env': self.env,
+                'data': self.data,
+            })
+
+        return render_to_string('sentry/partial/interfaces/http.html', context)
+
+    def get_title(self):
+        return _('Request')
diff --git a/src/sentry/interfaces/message.py b/src/sentry/interfaces/message.py
new file mode 100644
index 0000000000..98999fd845
--- /dev/null
+++ b/src/sentry/interfaces/message.py
@@ -0,0 +1,46 @@
+"""
+sentry.interfaces.message
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+__all__ = ('Message',)
+
+from sentry.interfaces.base import Interface
+from sentry.utils.safe import trim
+
+
+class Message(Interface):
+    """
+    A standard message consisting of a ``message`` arg, and an optional
+    ``params`` arg for formatting.
+
+    If your message cannot be parameterized, then the message interface
+    will serve no benefit.
+
+    - ``message`` must be no more than 1000 characters in length.
+
+    >>> {
+    >>>     "message": "My raw message with interpreted strings like %s",
+    >>>     "params": ["this"]
+    >>> }
+    """
+    @classmethod
+    def to_python(cls, data):
+        assert data.get('message')
+
+        kwargs = {
+            'message': trim(data['message'], 2048)
+        }
+
+        if data.get('params'):
+            kwargs['params'] = trim(data['params'], 1024)
+        else:
+            kwargs['params'] = ()
+
+        return cls(**kwargs)
+
+    def get_hash(self):
+        return [self.message]
diff --git a/src/sentry/interfaces/query.py b/src/sentry/interfaces/query.py
new file mode 100644
index 0000000000..9f46674fb7
--- /dev/null
+++ b/src/sentry/interfaces/query.py
@@ -0,0 +1,35 @@
+"""
+sentry.interfaces.query
+~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+__all__ = ('Query',)
+
+from sentry.interfaces.base import Interface
+from sentry.utils.safe import trim
+
+
+class Query(Interface):
+    """
+    A SQL query with an optional string describing the SQL driver, ``engine``.
+
+    >>> {
+    >>>     "query": "SELECT 1"
+    >>>     "engine": "psycopg2"
+    >>> }
+    """
+    @classmethod
+    def to_python(cls, data):
+        assert data.get('query')
+
+        kwargs = {
+            'query': trim(data['query'], 1024),
+            'engine': trim(data.get('engine'), 128),
+        }
+        return cls(**kwargs)
+
+    def get_hash(self):
+        return [self.query]
diff --git a/src/sentry/interfaces/stacktrace.py b/src/sentry/interfaces/stacktrace.py
new file mode 100644
index 0000000000..ced45bbbf9
--- /dev/null
+++ b/src/sentry/interfaces/stacktrace.py
@@ -0,0 +1,549 @@
+"""
+sentry.interfaces.stacktrace
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+__all__ = ('Stacktrace',)
+
+import re
+
+from django.conf import settings
+from django.utils.translation import ugettext as _
+from urlparse import urljoin, urlparse
+
+from sentry.app import env
+from sentry.interfaces.base import Interface
+from sentry.models import UserOption
+from sentry.utils.safe import trim, trim_dict
+from sentry.web.helpers import render_to_string
+
+
+_ruby_anon_func = re.compile(r'_\d{2,}')
+_filename_version_re = re.compile(r"""(?:
+    v?(?:\d+\.)*\d+|   # version numbers, v1, 1.0.0
+    [a-f0-9]{7,8}|     # short sha
+    [a-f0-9]{32}|      # md5
+    [a-f0-9]{40}       # sha1
+)/""", re.X | re.I)
+
+
+def get_context(lineno, context_line, pre_context=None, post_context=None, filename=None):
+    lineno = int(lineno)
+    context = []
+    start_lineno = lineno - len(pre_context or [])
+    if pre_context:
+        start_lineno = lineno - len(pre_context)
+        at_lineno = start_lineno
+        for line in pre_context:
+            context.append((at_lineno, line))
+            at_lineno += 1
+    else:
+        start_lineno = lineno
+        at_lineno = lineno
+
+    if start_lineno < 0:
+        start_lineno = 0
+
+    context.append((at_lineno, context_line))
+    at_lineno += 1
+
+    if post_context:
+        for line in post_context:
+            context.append((at_lineno, line))
+            at_lineno += 1
+
+    # HACK:
+    if filename and is_url(filename) and '.' not in filename.rsplit('/', 1)[-1]:
+        filename = 'index.html'
+
+    return context
+
+
+def is_newest_frame_first(event):
+    newest_first = event.platform not in ('python', None)
+
+    if env.request and env.request.user.is_authenticated():
+        display = UserOption.objects.get_value(
+            user=env.request.user,
+            project=None,
+            key='stacktrace_order',
+            default=None,
+        )
+        if display == '1':
+            newest_first = False
+        elif display == '2':
+            newest_first = True
+
+    return newest_first
+
+
+def is_url(filename):
+    return filename.startswith(('http:', 'https:', 'file:'))
+
+
+def remove_function_outliers(function):
+    """
+    Attempt to normalize functions by removing common platform outliers.
+
+    - Ruby generates (random?) integers for various anonymous style functions
+      such as in erb and the active_support library.
+    - Block functions have metadata that we don't care about.
+    """
+    if function.startswith('block '):
+        return 'block'
+    return _ruby_anon_func.sub('_<anon>', function)
+
+
+def remove_filename_outliers(filename):
+    """
+    Attempt to normalize filenames by removing common platform outliers.
+
+    - Sometimes filename paths contain build numbers
+    """
+    return _filename_version_re.sub('<version>/', filename)
+
+
+def trim_frames(stacktrace, max_frames=settings.SENTRY_MAX_STACKTRACE_FRAMES):
+    # TODO: this doesnt account for cases where the client has already omitted
+    # frames
+    frames = stacktrace['frames']
+    frames_len = len(frames)
+
+    if frames_len <= max_frames:
+        return
+
+    half_max = max_frames / 2
+
+    stacktrace['frames_omitted'] = (half_max, frames_len - half_max)
+
+    for n in xrange(half_max, frames_len - half_max):
+        del frames[half_max]
+
+
+def validate_bool(value, required=True):
+    if required:
+        assert value in (True, False)
+    else:
+        assert value in (True, False, None)
+    return value
+
+
+class Frame(Interface):
+    @classmethod
+    def to_python(cls, data):
+        abs_path = data.get('abs_path')
+        filename = data.get('filename')
+
+        if not abs_path:
+            abs_path = filename
+
+        if not filename:
+            filename = abs_path
+
+        if abs_path and is_url(abs_path):
+            urlparts = urlparse(abs_path)
+            if urlparts.path:
+                filename = urlparts.path
+
+        assert filename or data.get('function') or data.get('module')
+
+        context_locals = data.get('vars') or {}
+        if isinstance(context_locals, (list, tuple)):
+            context_locals = dict(enumerate(context_locals))
+        context_locals = trim_dict(context_locals)
+
+        # extra data is used purely by internal systems,
+        # so we dont trim it
+        extra_data = data.get('data') or {}
+        if isinstance(extra_data, (list, tuple)):
+            extra_data = dict(enumerate(extra_data))
+
+        kwargs = {
+            'abs_path': trim(abs_path, 256),
+            'filename': trim(filename, 256),
+            'module': trim(data.get('module'), 256),
+            'function': trim(data.get('function'), 256),
+            'in_app': validate_bool(data.get('in_app'), False),
+            'context_line': trim(data.get('context_line'), 256),
+            # TODO(dcramer): trim pre/post_context
+            'pre_context': data.get('pre_context'),
+            'post_context': data.get('post_context'),
+            'vars': context_locals,
+            'data': extra_data,
+        }
+
+        if data.get('lineno') is not None:
+            kwargs['lineno'] = int(data['lineno'])
+        else:
+            kwargs['lineno'] = None
+
+        if data.get('colno') is not None:
+            kwargs['colno'] = int(data['colno'])
+        else:
+            kwargs['colno'] = None
+
+        return cls(**kwargs)
+
+    def is_url(self):
+        if not self.abs_path:
+            return False
+        return is_url(self.abs_path)
+
+    def get_hash(self):
+        """
+        The hash of the frame varies depending on the data available.
+
+        Our ideal scenario is the module name in addition to the line of
+        context. However, in several scenarios we opt for other approaches due
+        to platform constraints.
+
+        This is one of the few areas in Sentry that isn't platform-agnostic.
+        """
+        output = []
+        if self.module:
+            output.append(self.module)
+        elif self.filename and not self.is_url():
+            output.append(remove_filename_outliers(self.filename))
+
+        if self.context_line is None:
+            can_use_context = False
+        elif len(self.context_line) > 120:
+            can_use_context = False
+        # XXX: deal with PHP anonymous functions (used for things like SQL
+        # queries and JSON data)
+        elif self.function and self.function.startswith('[Anonymous'):
+            can_use_context = True
+        else:
+            can_use_context = True
+
+        # XXX: hack around what appear to be non-useful lines of context
+        if can_use_context:
+            output.append(self.context_line)
+        elif not output:
+            # If we were unable to achieve any context at this point
+            # (likely due to a bad JavaScript error) we should just
+            # bail on recording this frame
+            return output
+        elif self.function:
+            output.append(remove_function_outliers(self.function))
+        elif self.lineno is not None:
+            output.append(self.lineno)
+        return output
+
+    def get_context(self, event, is_public=False, **kwargs):
+        if (self.context_line and self.lineno is not None
+                and (self.pre_context or self.post_context)):
+            context = get_context(
+                lineno=self.lineno,
+                context_line=self.context_line,
+                pre_context=self.pre_context,
+                post_context=self.post_context,
+                filename=self.filename or self.module,
+            )
+            start_lineno = context[0][0]
+        else:
+            context = []
+            start_lineno = None
+
+        frame_data = {
+            'abs_path': self.abs_path,
+            'filename': self.filename,
+            'module': self.module,
+            'function': self.function,
+            'start_lineno': start_lineno,
+            'lineno': self.lineno,
+            'colno': self.colno,
+            'context': context,
+            'context_line': self.context_line,
+            'in_app': self.in_app,
+            'is_url': self.is_url(),
+        }
+        if not is_public:
+            frame_data['vars'] = self.vars or {}
+
+        if event.platform == 'javascript' and self.data:
+            frame_data.update({
+                'sourcemap': self.data['sourcemap'].rsplit('/', 1)[-1],
+                'sourcemap_url': urljoin(self.abs_path, self.data['sourcemap']),
+                'orig_function': self.data.get('orig_function', '?'),
+                'orig_abs_path': self.data.get('orig_abs_path', '?'),
+                'orig_filename': self.data.get('orig_filename', '?'),
+                'orig_lineno': self.data.get('orig_lineno', '?'),
+                'orig_colno': self.data.get('orig_colno', '?'),
+            })
+        return frame_data
+
+    def to_string(self, event):
+        if event.platform is not None:
+            choices = [event.platform]
+        else:
+            choices = []
+        choices.append('default')
+        templates = [
+            'sentry/partial/frames/%s.txt' % choice
+            for choice in choices
+        ]
+        return render_to_string(templates, {
+            'abs_path': self.abs_path,
+            'filename': self.filename,
+            'function': self.function,
+            'module': self.module,
+            'lineno': self.lineno,
+            'colno': self.colno,
+            'context_line': self.context_line,
+        }).strip('\n')
+
+
+class Stacktrace(Interface):
+    """
+    A stacktrace contains a list of frames, each with various bits (most optional)
+    describing the context of that frame. Frames should be sorted from oldest
+    to newest.
+
+    The stacktrace contains an element, ``frames``, which is a list of hashes. Each
+    hash must contain **at least** the ``filename`` attribute. The rest of the values
+    are optional, but recommended.
+
+    Additionally, if the list of frames is large, you can explicitly tell the
+    system that you've omitted a range of frames. The ``frames_omitted`` must
+    be a single tuple two values: start and end. For example, if you only
+    removed the 8th frame, the value would be (8, 9), meaning it started at the
+    8th frame, and went until the 9th (the number of frames omitted is
+    end-start). The values should be based on a one-index.
+
+    The list of frames should be ordered by the oldest call first.
+
+    Each frame must contain the following attributes:
+
+    ``filename``
+      The relative filepath to the call
+
+    OR
+
+    ``function``
+      The name of the function being called
+
+    OR
+
+    ``module``
+      Platform-specific module path (e.g. sentry.interfaces.Stacktrace)
+
+    The following additional attributes are supported:
+
+    ``lineno``
+      The line number of the call
+    ``colno``
+      The column number of the call
+    ``abs_path``
+      The absolute path to filename
+    ``context_line``
+      Source code in filename at lineno
+    ``pre_context``
+      A list of source code lines before context_line (in order) -- usually [lineno - 5:lineno]
+    ``post_context``
+      A list of source code lines after context_line (in order) -- usually [lineno + 1:lineno + 5]
+    ``in_app``
+      Signifies whether this frame is related to the execution of the relevant code in this stacktrace. For example,
+      the frames that might power the framework's webserver of your app are probably not relevant, however calls to
+      the framework's library once you start handling code likely are.
+    ``vars``
+      A mapping of variables which were available within this frame (usually context-locals).
+
+    >>> {
+    >>>     "frames": [{
+    >>>         "abs_path": "/real/file/name.py"
+    >>>         "filename": "file/name.py",
+    >>>         "function": "myfunction",
+    >>>         "vars": {
+    >>>             "key": "value"
+    >>>         },
+    >>>         "pre_context": [
+    >>>             "line1",
+    >>>             "line2"
+    >>>         ],
+    >>>         "context_line": "line3",
+    >>>         "lineno": 3,
+    >>>         "in_app": true,
+    >>>         "post_context": [
+    >>>             "line4",
+    >>>             "line5"
+    >>>         ],
+    >>>     }],
+    >>>     "frames_omitted": [13, 56]
+    >>> }
+
+    .. note:: This interface can be passed as the 'stacktrace' key in addition
+              to the full interface path.
+    """
+    score = 1000
+
+    def __iter__(self):
+        return iter(self.frames)
+
+    @classmethod
+    def to_python(cls, data):
+        assert data.get('frames')
+
+        trim_frames(data)
+
+        kwargs = {
+            'frames': [
+                Frame.to_python(f)
+                for f in data['frames']
+            ],
+        }
+
+        if data.get('frames_omitted'):
+            assert len(data['frames_omitted']) == 2
+            kwargs['frames_omitted'] = data['frames_omitted']
+        else:
+            kwargs['frames_omitted'] = None
+
+        return cls(**kwargs)
+
+    def to_json(self):
+        return {
+            'frames': [f.to_json() for f in self.frames],
+            'frames_omitted': self.frames_omitted,
+        }
+
+    def has_app_frames(self):
+        return any(f.in_app is not None for f in self.frames)
+
+    def unserialize(self, data):
+        data['frames'] = [Frame(**f) for f in data.pop('frames', [])]
+        data['frames_omitted'] = data.pop('frames_omitted', None)
+        return data
+
+    def get_composite_hash(self, interfaces):
+        output = self.get_hash()
+        if 'sentry.interfaces.Exception' in interfaces:
+            exc = interfaces['sentry.interfaces.Exception'][0]
+            if exc.type:
+                output.append(exc.type)
+            elif not output:
+                output = exc.get_hash()
+        return output
+
+    def get_hash(self):
+        frames = self.frames
+
+        # TODO(dcramer): this should apply only to JS
+        if len(frames) == 1 and frames[0].lineno == '1' and frames[0].function in ('?', None):
+            return []
+
+        output = []
+        for frame in frames:
+            output.extend(frame.get_hash())
+        return output
+
+    def get_context(self, event, is_public=False, newest_first=None,
+                    with_stacktrace=True, **kwargs):
+        system_frames = 0
+        frames = []
+        for frame in self.frames:
+            frames.append(frame.get_context(event=event, is_public=is_public))
+
+            if not frame.in_app:
+                system_frames += 1
+
+        if len(frames) == system_frames:
+            system_frames = 0
+
+        # if theres no system frames, pretend they're all part of the app
+        if not system_frames:
+            for frame in frames:
+                frame['in_app'] = True
+
+        if newest_first is None:
+            newest_first = is_newest_frame_first(event)
+        if newest_first:
+            frames = frames[::-1]
+
+        if self.frames_omitted:
+            first_frame_omitted, last_frame_omitted = self.frames_omitted
+        else:
+            first_frame_omitted, last_frame_omitted = None, None
+
+        context = {
+            'is_public': is_public,
+            'newest_first': newest_first,
+            'system_frames': system_frames,
+            'event': event,
+            'frames': frames,
+            'stack_id': 'stacktrace_1',
+            'first_frame_omitted': first_frame_omitted,
+            'last_frame_omitted': last_frame_omitted,
+        }
+        if with_stacktrace:
+            context['stacktrace'] = self.get_traceback(event, newest_first=newest_first)
+        return context
+
+    def to_html(self, event, **kwargs):
+        context = self.get_context(
+            event=event,
+            **kwargs
+        )
+        return render_to_string('sentry/partial/interfaces/stacktrace.html', context)
+
+    def to_string(self, event, is_public=False, **kwargs):
+        return self.get_stacktrace(event, system_frames=False, max_frames=5)
+
+    def get_stacktrace(self, event, system_frames=True, newest_first=None,
+                       max_frames=None, header=True):
+        if newest_first is None:
+            newest_first = is_newest_frame_first(event)
+
+        result = []
+        if header:
+            if newest_first:
+                result.append(_('Stacktrace (most recent call first):'))
+            else:
+                result.append(_('Stacktrace (most recent call last):'))
+
+            result.append('')
+
+        frames = self.frames
+
+        num_frames = len(frames)
+
+        if not system_frames:
+            frames = [f for f in frames if f.in_app is not False]
+            if not frames:
+                frames = self.frames
+
+        if newest_first:
+            frames = frames[::-1]
+
+        if max_frames:
+            visible_frames = max_frames
+            if newest_first:
+                start, stop = None, max_frames
+            else:
+                start, stop = -max_frames, None
+
+        else:
+            visible_frames = len(frames)
+            start, stop = None, None
+
+        if not newest_first and visible_frames < num_frames:
+            result.extend(('(%d additional frame(s) were not displayed)' % (num_frames - visible_frames,), '...'))
+
+        for frame in frames[start:stop]:
+            result.append(frame.to_string(event))
+
+        if newest_first and visible_frames < num_frames:
+            result.extend(('...', '(%d additional frame(s) were not displayed)' % (num_frames - visible_frames,)))
+
+        return '\n'.join(result)
+
+    def get_traceback(self, event, newest_first=None):
+        result = [
+            event.message, '',
+            self.get_stacktrace(event, newest_first=newest_first),
+        ]
+
+        return '\n'.join(result)
diff --git a/src/sentry/interfaces/template.py b/src/sentry/interfaces/template.py
new file mode 100644
index 0000000000..41712de268
--- /dev/null
+++ b/src/sentry/interfaces/template.py
@@ -0,0 +1,106 @@
+"""
+sentry.interfaces.template
+~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+__all__ = ('Template',)
+
+from sentry.interfaces.base import Interface
+from sentry.interfaces.stacktrace import get_context
+from sentry.utils.safe import trim
+from sentry.web.helpers import render_to_string
+
+
+class Template(Interface):
+    """
+    A rendered template (generally used like a single frame in a stacktrace).
+
+    The attributes ``filename``, ``context_line``, and ``lineno`` are required.
+
+    >>>  {
+    >>>     "abs_path": "/real/file/name.html"
+    >>>     "filename": "file/name.html",
+    >>>     "pre_context": [
+    >>>         "line1",
+    >>>         "line2"
+    >>>     ],
+    >>>     "context_line": "line3",
+    >>>     "lineno": 3,
+    >>>     "post_context": [
+    >>>         "line4",
+    >>>         "line5"
+    >>>     ],
+    >>> }
+
+    .. note:: This interface can be passed as the 'template' key in addition
+              to the full interface path.
+    """
+    score = 1100
+
+    @classmethod
+    def to_python(cls, data):
+        assert data.get('filename')
+        assert data.get('context_line')
+        assert data.get('lineno')
+
+        kwargs = {
+            'abs_path': trim(data.get('abs_path', None), 256),
+            'filename': trim(data['filename'], 256),
+            'context_line': trim(data.get('context_line', None), 256),
+            'lineno': int(data['lineno']),
+            # TODO(dcramer): trim pre/post_context
+            'pre_context': data.get('pre_context'),
+            'post_context': data.get('post_context'),
+        }
+        return cls(**kwargs)
+
+    def get_hash(self):
+        return [self.filename, self.context_line]
+
+    def to_string(self, event, is_public=False, **kwargs):
+        context = get_context(
+            lineno=self.lineno,
+            context_line=self.context_line,
+            pre_context=self.pre_context,
+            post_context=self.post_context,
+            filename=self.filename,
+        )
+
+        result = [
+            'Stacktrace (most recent call last):', '',
+            self.get_traceback(event, context)
+        ]
+
+        return '\n'.join(result)
+
+    def to_html(self, event, is_public=False, **kwargs):
+        context = get_context(
+            lineno=self.lineno,
+            context_line=self.context_line,
+            pre_context=self.pre_context,
+            post_context=self.post_context,
+            filename=self.filename,
+        )
+
+        return render_to_string('sentry/partial/interfaces/template.html', {
+            'event': event,
+            'abs_path': self.abs_path,
+            'filename': self.filename,
+            'lineno': int(self.lineno),
+            'start_lineno': context[0][0],
+            'context': context,
+            'template': self.get_traceback(event, context),
+            'is_public': is_public,
+        })
+
+    def get_traceback(self, event, context):
+        result = [
+            event.message, '',
+            'File "%s", line %s' % (self.filename, self.lineno), '',
+        ]
+        result.extend([n[1].strip('\n') for n in context])
+
+        return '\n'.join(result)
diff --git a/src/sentry/interfaces/user.py b/src/sentry/interfaces/user.py
new file mode 100644
index 0000000000..671f19579f
--- /dev/null
+++ b/src/sentry/interfaces/user.py
@@ -0,0 +1,71 @@
+"""
+sentry.interfaces.user
+~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+__all__ = ('User',)
+
+from sentry.interfaces.base import Interface
+from sentry.utils.safe import trim, trim_dict
+from sentry.web.helpers import render_to_string
+
+
+def validate_ip(value, required=True):
+    # TODO(dcramer): we should just use ipaddr here
+    if not required and not value:
+        return
+
+    assert value.count('.') == 3
+    for comp in value.split('.'):
+        assert comp.isdigit()
+        assert -1 < int(comp) <= 256
+    return value
+
+
+class User(Interface):
+    """
+    An interface which describes the authenticated User for a request.
+
+    You should provide **at least** either an `id` (a unique identifier for
+    an authenticated user) or `ip_address` (their IP address).
+
+    All other data is.
+
+    >>> {
+    >>>     "id": "unique_id",
+    >>>     "username": "my_user",
+    >>>     "email": "foo@example.com"
+    >>>     "ip_address": "127.0.0.1"
+    >>> }
+    """
+    @classmethod
+    def to_python(cls, data):
+        data = data.copy()
+
+        kwargs = {
+            'id': trim(data.pop('id', None), 128),
+            'email': trim(data.pop('email', None), 128),
+            'username': trim(data.pop('username', None), 128),
+            'ip_address': validate_ip(data.pop('ip_address', None), False),
+        }
+        kwargs['data'] = trim_dict(data.pop('data', data))
+        return cls(**kwargs)
+
+    def get_hash(self):
+        return []
+
+    def to_html(self, event, is_public=False, **kwargs):
+        if is_public:
+            return ''
+        return render_to_string('sentry/partial/interfaces/user.html', {
+            'is_public': is_public,
+            'event': event,
+            'user_ip_address': self.ip_address,
+            'user_id': self.id,
+            'user_username': self.username,
+            'user_email': self.email,
+            'user_data': self.data,
+        })
diff --git a/src/sentry/manager.py b/src/sentry/manager.py
index 9c988f9ae5..0e506152df 100644
--- a/src/sentry/manager.py
+++ b/src/sentry/manager.py
@@ -30,7 +30,7 @@ from raven.utils.encoding import to_string
 from sentry import app
 from sentry.constants import (
     STATUS_RESOLVED, STATUS_UNRESOLVED, MINUTE_NORMALIZATION,
-    LOG_LEVELS, DEFAULT_LOGGER_NAME, MAX_CULPRIT_LENGTH)
+    LOG_LEVELS, DEFAULT_LOGGER_NAME, MAX_CULPRIT_LENGTH, MAX_TAG_VALUE_LENGTH)
 from sentry.db.models import BaseManager
 from sentry.processors.base import send_group_processors
 from sentry.signals import regression_signal
@@ -38,13 +38,11 @@ from sentry.tasks.index import index_event
 from sentry.utils.cache import cache, memoize
 from sentry.utils.dates import get_sql_date_trunc, normalize_datetime
 from sentry.utils.db import get_db_engine, has_charts, attach_foreignkey
-from sentry.utils.safe import safe_execute, trim, trim_dict, trim_frames
-from sentry.utils.strings import strip
+from sentry.utils.safe import safe_execute, trim, trim_dict
 
 logger = logging.getLogger('sentry.errors')
 
 UNSAVED = dict()
-MAX_TAG_LENGTH = 200
 
 
 def get_checksum_from_event(event):
@@ -271,72 +269,23 @@ class GroupManager(BaseManager, ChartMixin):
         trim_dict(
             data['extra'], max_size=settings.SENTRY_MAX_EXTRA_VARIABLE_SIZE)
 
-        # TODO: each interface should describe its own normalization logic
+        # TODO(dcramer): find a better place for this logic
         if 'sentry.interfaces.Exception' in data:
             if 'values' not in data['sentry.interfaces.Exception']:
                 data['sentry.interfaces.Exception'] = {
                     'values': [data['sentry.interfaces.Exception']]
                 }
 
-            # convert stacktrace + exception into expanded exception
-            if 'sentry.interfaces.Stacktrace' in data:
-                data['sentry.interfaces.Exception']['values'][0]['stacktrace'] = data.pop('sentry.interfaces.Stacktrace')
-
-            for exc_data in data['sentry.interfaces.Exception']['values']:
-                for key in ('type', 'module', 'value'):
-                    value = exc_data.get(key)
-                    if value:
-                        exc_data[key] = trim(value)
-
-                if exc_data.get('stacktrace'):
-                    trim_frames(exc_data['stacktrace'])
-                    for frame in exc_data['stacktrace']['frames']:
-                        stack_vars = frame.get('vars', {})
-                        trim_dict(stack_vars)
-                        for key, value in frame.iteritems():
-                            if key not in ('vars', 'data'):
-                                frame[key] = trim(value)
-
-        if 'sentry.interfaces.Stacktrace' in data:
-            trim_frames(data['sentry.interfaces.Stacktrace'])
-            for frame in data['sentry.interfaces.Stacktrace']['frames']:
-                stack_vars = frame.get('vars', {})
-                trim_dict(stack_vars)
-                for key, value in frame.iteritems():
-                    if key not in ('vars', 'data'):
-                        frame[key] = trim(value)
-
-        if 'sentry.interfaces.Message' in data:
-            msg_data = data['sentry.interfaces.Message']
-            trim(msg_data['message'], 1024)
-            if msg_data.get('params'):
-                msg_data['params'] = trim(msg_data['params'])
-
         if 'sentry.interfaces.Http' in data:
-            http_data = data['sentry.interfaces.Http']
-            for key in ('cookies', 'querystring', 'headers', 'env', 'url'):
-                value = http_data.get(key)
-                if not value:
-                    continue
-
-                if type(value) == dict:
-                    trim_dict(value)
-                else:
-                    http_data[key] = trim(value)
-
-            value = http_data.get('data')
-            if value:
-                http_data['data'] = trim(value, 2048)
-
             # default the culprit to the url
             if not data['culprit']:
-                data['culprit'] = strip(http_data.get('url'))
+                data['culprit'] = data['sentry.interfaces.Http']['url']
 
         if data['culprit']:
-            data['culprit'] = trim(strip(data['culprit']), MAX_CULPRIT_LENGTH)
+            data['culprit'] = trim(data['culprit'], MAX_CULPRIT_LENGTH)
 
         if data['message']:
-            data['message'] = strip(data['message'])
+            data['message'] = trim(data['message'], 2048)
 
         return data
 
@@ -596,7 +545,7 @@ class GroupManager(BaseManager, ChartMixin):
                 continue
 
             value = unicode(value)
-            if len(value) > MAX_TAG_LENGTH:
+            if len(value) > MAX_TAG_VALUE_LENGTH:
                 continue
 
             app.buffer.incr(TagValue, {
diff --git a/src/sentry/models/event.py b/src/sentry/models/event.py
index c64c05cc7d..1350d42ece 100644
--- a/src/sentry/models/event.py
+++ b/src/sentry/models/event.py
@@ -7,6 +7,7 @@ sentry.models.event
 """
 import logging
 
+from django.conf import settings
 from django.db import models
 from django.utils import timezone
 from django.utils.datastructures import SortedDict
@@ -139,11 +140,13 @@ class Event(Model):
                 continue
 
             try:
-                cls = import_string(key)
+                cls = import_string(settings.SENTRY_INTERFACES[key])
+            except KeyError:
+                continue
             except ImportError:
                 continue  # suppress invalid interfaces
 
-            value = safe_execute(cls, **data)
+            value = safe_execute(cls.to_python, data)
             if not value:
                 continue
 
diff --git a/src/sentry/search/django/backend.py b/src/sentry/search/django/backend.py
index fc8abab2b7..aa9e02f866 100644
--- a/src/sentry/search/django/backend.py
+++ b/src/sentry/search/django/backend.py
@@ -73,10 +73,6 @@ class DjangoSearchBackend(SearchBackend):
             document.status = group.status
 
         context = defaultdict(list)
-        for interface in event.interfaces.itervalues():
-            for k, v in interface.get_search_context(event).iteritems():
-                context[k].extend(v)
-
         context['text'].extend([
             event.message,
             event.logger,
diff --git a/src/sentry/search/solr/backend.py b/src/sentry/search/solr/backend.py
index 9951dc040f..e508b1667d 100644
--- a/src/sentry/search/solr/backend.py
+++ b/src/sentry/search/solr/backend.py
@@ -40,13 +40,6 @@ class SolrBackend(SearchBackend):
             ],
             'filters': defaultdict(list),
         }
-        for interface in event.interfaces.itervalues():
-            for k, v in interface.get_search_context(event).iteritems():
-                if k == 'text':
-                    context[k].extend(v)
-                elif k == 'filters':
-                    for f_k, f_v in v.iteritems():
-                        context[k][f_k].extend(f_v)
 
         tags = []
         for k, v in context['filters'].iteritems():
diff --git a/src/sentry/tasks/fetch_source.py b/src/sentry/tasks/fetch_source.py
index c29c93e858..1ff8b570a5 100644
--- a/src/sentry/tasks/fetch_source.py
+++ b/src/sentry/tasks/fetch_source.py
@@ -216,11 +216,11 @@ def expand_javascript_source(data, **kwargs):
 
     Mutates the input ``data`` with expanded context if available.
     """
-    from sentry.interfaces import Stacktrace
+    from sentry.interfaces.stacktrace import Stacktrace
 
     try:
         stacktraces = [
-            Stacktrace(**e['stacktrace'])
+            Stacktrace.to_python(e['stacktrace'])
             for e in data['sentry.interfaces.Exception']['values']
             if e.get('stacktrace')
         ]
@@ -370,7 +370,7 @@ def expand_javascript_source(data, **kwargs):
     if has_changes:
         logger.debug('Updating stacktraces with expanded source context')
         for exception, stacktrace in itertools.izip(data['sentry.interfaces.Exception']['values'], stacktraces):
-            exception['stacktrace'] = stacktrace.serialize()
+            exception['stacktrace'] = stacktrace.to_json()
 
         # Attempt to fix the culrpit now that we have useful information
         culprit_frame = stacktraces[0].frames[-1]
diff --git a/src/sentry/utils/safe.py b/src/sentry/utils/safe.py
index 41f3311b6a..d79c6f0692 100644
--- a/src/sentry/utils/safe.py
+++ b/src/sentry/utils/safe.py
@@ -84,20 +84,4 @@ def trim_dict(value, max_items=settings.SENTRY_MAX_DICTIONARY_ITEMS, **kwargs):
         value[key] = trim(value[key], **kwargs)
         if idx > max_items:
             del value[key]
-
-
-def trim_frames(stacktrace, max_frames=settings.SENTRY_MAX_STACKTRACE_FRAMES):
-    # TODO: this doesnt account for cases where the client has already omitted
-    # frames
-    frames = stacktrace['frames']
-    frames_len = len(frames)
-
-    if frames_len <= max_frames:
-        return
-
-    half_max = max_frames / 2
-
-    stacktrace['frames_omitted'] = (half_max, frames_len - half_max)
-
-    for n in xrange(half_max, frames_len - half_max):
-        del frames[half_max]
+    return value
diff --git a/src/sentry/web/forms/__init__.py b/src/sentry/web/forms/__init__.py
index 66c56eda5f..3154ef8a55 100644
--- a/src/sentry/web/forms/__init__.py
+++ b/src/sentry/web/forms/__init__.py
@@ -8,14 +8,14 @@ sentry.web.forms
 from django import forms
 from django.utils.translation import ugettext_lazy as _
 
-from sentry.interfaces import Http
+from sentry.constants import HTTP_METHODS
 from sentry.models import User, Activity
 from sentry.web.forms.fields import RadioFieldRenderer
 
 
 class ReplayForm(forms.Form):
     url = forms.URLField(widget=forms.TextInput(attrs={'class': 'span8'}))
-    method = forms.ChoiceField(choices=((k, k) for k in Http.METHODS))
+    method = forms.ChoiceField(choices=((k, k) for k in HTTP_METHODS))
     data = forms.CharField(required=False, widget=forms.Textarea(attrs={'class': 'span8'}))
     headers = forms.CharField(required=False, widget=forms.Textarea(attrs={'class': 'span8'}))
 
diff --git a/tests/sentry/coreapi/tests.py b/tests/sentry/coreapi/tests.py
index 105b94fcac..bfdaab677c 100644
--- a/tests/sentry/coreapi/tests.py
+++ b/tests/sentry/coreapi/tests.py
@@ -10,7 +10,7 @@ from sentry.models import Project, User
 from sentry.exceptions import InvalidTimestamp
 from sentry.coreapi import (
     extract_auth_vars, project_from_auth_vars, APIForbidden, ensure_has_ip,
-    process_data_timestamp, validate_data, INTERFACE_ALIASES, get_interface)
+    process_data_timestamp, validate_data, get_interface)
 from sentry.testutils import TestCase
 
 
@@ -22,23 +22,6 @@ class BaseAPITest(TestCase):
         self.pk = self.project.key_set.get_or_create(user=self.user)[0]
 
 
-class InterfaceAliasesTest(BaseAPITest):
-    def test_http(self):
-        assert INTERFACE_ALIASES['request'] == 'sentry.interfaces.Http'
-
-    def test_user(self):
-        assert INTERFACE_ALIASES['user'] == 'sentry.interfaces.User'
-
-    def test_exception(self):
-        assert INTERFACE_ALIASES['exception'] == 'sentry.interfaces.Exception'
-
-    def test_stacktrace(self):
-        assert INTERFACE_ALIASES['stacktrace'] == 'sentry.interfaces.Stacktrace'
-
-    def test_template(self):
-        assert INTERFACE_ALIASES['template'] == 'sentry.interfaces.Template'
-
-
 class ExtractAuthVarsTest(BaseAPITest):
     def test_valid(self):
         request = mock.Mock()
@@ -189,22 +172,6 @@ class ValidateDataTest(BaseAPITest):
         })
         assert 'tests.manager.tests.DummyInterface' not in data
 
-    @mock.patch('sentry.coreapi.import_string')
-    def test_an_alias_maps_correctly(self, import_string):
-        alias, full_path = INTERFACE_ALIASES.items()[0]
-
-        result = validate_data(self.project, {
-            'project': self.project.id,
-            'message': 'foo',
-            alias: {'foo': 'bar'},
-        })
-        import_string.assert_called_once_with(full_path)
-        interface = import_string.return_value
-        interface.assert_called_once_with(foo='bar')
-        assert alias not in result
-        assert full_path in result
-        assert result[full_path] == interface.return_value.serialize.return_value
-
     def test_doesnt_expand_list(self):
         data = validate_data(self.project, {
             'message': 'foo',
@@ -214,7 +181,7 @@ class ValidateDataTest(BaseAPITest):
                 'module': 'foo.bar',
             }]
         })
-        assert 'sentry.interfaces.Exception' in data
+        assert 'sentry.interfaces.Exception' not in data
 
     def test_log_level_as_string(self):
         data = validate_data(self.project, {
@@ -265,9 +232,11 @@ class GetInterfaceTest(TestCase):
             get_interface('subprocess')
 
     def test_allows_http(self):
-        from sentry.interfaces import Http
+        from sentry.interfaces.http import Http
         result = get_interface('sentry.interfaces.Http')
         assert result is Http
+        result = get_interface('request')
+        assert result is Http
 
 
 class EnsureHasIpTest(TestCase):
diff --git a/tests/sentry/interfaces/message/__init__.py b/tests/sentry/interfaces/message/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/sentry/interfaces/message/tests.py b/tests/sentry/interfaces/message/tests.py
deleted file mode 100644
index c2db327ba2..0000000000
--- a/tests/sentry/interfaces/message/tests.py
+++ /dev/null
@@ -1,51 +0,0 @@
-# -*- coding: utf-8 -*-
-
-from __future__ import absolute_import
-
-from exam import fixture
-
-from sentry.testutils import TestCase
-from sentry.interfaces import Message
-
-
-class MessageTest(TestCase):
-    @fixture
-    def interface(self):
-        return Message(message='Hello there %s!', params=('world',))
-
-    def test_serialize_behavior(self):
-        assert self.interface.serialize() == {
-            'message': self.interface.message,
-            'params': self.interface.params,
-        }
-
-    def test_get_hash_uses_message(self):
-        assert self.interface.get_hash() == [self.interface.message]
-
-    def test_get_search_context_with_params_as_list(self):
-        interface = self.interface
-        interface.params = ['world']
-        assert interface.get_search_context(self.event) == {
-            'text': [interface.message] + list(interface.params)
-        }
-
-    def test_get_search_context_with_params_as_tuple(self):
-        assert self.interface.get_search_context(self.event) == {
-            'text': [self.interface.message] + list(self.interface.params)
-        }
-
-    def test_get_search_context_with_params_as_dict(self):
-        interface = self.interface
-        interface.params = {'who': 'world'}
-        interface.message = 'Hello there %(who)s!'
-        assert self.interface.get_search_context(self.event) == {
-            'text': [interface.message] + interface.params.values()
-        }
-
-    def test_get_search_context_with_unsupported_params(self):
-        interface = self.interface
-        interface.params = object()
-        interface.message = 'Hello there %(who)s!'
-        assert self.interface.get_search_context(self.event) == {
-            'text': [interface.message],
-        }
diff --git a/tests/sentry/interfaces/query/__init__.py b/tests/sentry/interfaces/query/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/sentry/interfaces/stacktrace/__init__.py b/tests/sentry/interfaces/stacktrace/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/sentry/interfaces/template/__init__.py b/tests/sentry/interfaces/template/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/sentry/interfaces/exception/__init__.py b/tests/sentry/interfaces/test_base.py
similarity index 100%
rename from tests/sentry/interfaces/exception/__init__.py
rename to tests/sentry/interfaces/test_base.py
diff --git a/tests/sentry/interfaces/exception/tests.py b/tests/sentry/interfaces/test_exception.py
similarity index 67%
rename from tests/sentry/interfaces/exception/tests.py
rename to tests/sentry/interfaces/test_exception.py
index ec3331c492..19298a78ee 100644
--- a/tests/sentry/interfaces/exception/tests.py
+++ b/tests/sentry/interfaces/test_exception.py
@@ -4,16 +4,14 @@ from __future__ import absolute_import
 
 from exam import fixture
 
+from sentry.interfaces.exception import SingleException, Exception
 from sentry.testutils import TestCase
-from sentry.interfaces import unserialize
 
 
 class ExceptionTest(TestCase):
     @fixture
     def interface(self):
-        from sentry.interfaces import Exception
-
-        return Exception([{
+        return Exception.to_python(dict(values=[{
             'type': 'ValueError',
             'value': 'hello world',
             'module': 'foo.bar',
@@ -31,38 +29,21 @@ class ExceptionTest(TestCase):
                 'lineno': 1,
                 'in_app': True,
             }]},
-        }])
-
-    def test_args_as_list(self):
-        from sentry.interfaces import SingleException, Exception
-
-        inst = Exception([{
-            'type': 'ValueError',
-            'value': 'hello world',
-            'module': 'foo.bar',
-        }])
-        assert type(inst.values[0]) is SingleException
-        assert inst.values[0].type == 'ValueError'
-        assert inst.values[0].value == 'hello world'
-        assert inst.values[0].module == 'foo.bar'
+        }]))
 
     def test_args_as_keyword_args(self):
-        from sentry.interfaces import SingleException, Exception
-
-        inst = Exception(values=[{
+        inst = Exception.to_python(dict(values=[{
             'type': 'ValueError',
             'value': 'hello world',
             'module': 'foo.bar',
-        }])
+        }]))
         assert type(inst.values[0]) is SingleException
         assert inst.values[0].type == 'ValueError'
         assert inst.values[0].value == 'hello world'
         assert inst.values[0].module == 'foo.bar'
 
     def test_args_as_old_style(self):
-        from sentry.interfaces import SingleException, Exception
-
-        inst = Exception(**{
+        inst = Exception.to_python({
             'type': 'ValueError',
             'value': 'hello world',
             'module': 'foo.bar',
@@ -73,8 +54,8 @@ class ExceptionTest(TestCase):
         assert inst.values[0].module == 'foo.bar'
 
     def test_serialize_unserialize_behavior(self):
-        result = unserialize(type(self.interface), self.interface.serialize())
-        assert self.interface.serialize() == result.serialize()
+        result = type(self.interface).to_python(self.interface.to_json())
+        assert result.to_json() == self.interface.to_json()
 
     def test_to_string(self):
         result = self.interface.to_string(self.event)
@@ -95,21 +76,18 @@ ValueError: hello world
 class SingleExceptionTest(TestCase):
     @fixture
     def interface(self):
-        from sentry.interfaces import SingleException
-
-        return SingleException(
+        return SingleException.to_python(dict(
             type='ValueError',
             value='hello world',
             module='foo.bar',
-            stacktrace={'frames': []},
-        )
+        ))
 
     def test_serialize_behavior(self):
-        assert self.interface.serialize() == {
+        assert self.interface.to_json() == {
             'type': self.interface.type,
             'value': self.interface.value,
             'module': self.interface.module,
-            'stacktrace': self.interface.stacktrace.serialize(),
+            'stacktrace': None,
         }
 
     def test_get_hash(self):
@@ -131,5 +109,5 @@ class SingleExceptionTest(TestCase):
         ]
 
     def test_serialize_unserialize_behavior(self):
-        result = unserialize(type(self.interface), self.interface.serialize())
-        assert self.interface.serialize() == result.serialize()
+        result = type(self.interface).to_python(self.interface.to_json())
+        assert result.to_json() == self.interface.to_json()
diff --git a/tests/sentry/interfaces/test_http.py b/tests/sentry/interfaces/test_http.py
new file mode 100644
index 0000000000..5f8dc825e9
--- /dev/null
+++ b/tests/sentry/interfaces/test_http.py
@@ -0,0 +1,121 @@
+# -*- coding: utf-8 -*-
+
+from __future__ import absolute_import
+
+from exam import fixture
+
+from sentry.interfaces.http import Http
+from sentry.testutils import TestCase
+
+
+class HttpTest(TestCase):
+    @fixture
+    def interface(self):
+        return Http.to_python(dict(
+            url='http://example.com',
+        ))
+
+    def test_serialize_unserialize_behavior(self):
+        result = type(self.interface).to_python(self.interface.to_json())
+        assert result.to_json() == self.interface.to_json()
+
+    def test_basic(self):
+        result = self.interface
+        assert result.url == 'http://example.com'
+        assert result.method is None
+        assert result.fragment == ''
+        assert result.query_string == ''
+        assert result.data is None
+        assert result.cookies == {}
+        assert result.headers == {}
+        assert result.env == {}
+        assert result.full_url == result.url
+
+    def test_full(self):
+        result = Http.to_python(dict(
+            method='GET',
+            url='http://example.com',
+            query_string='foo=bar',
+            fragment='foobar',
+            headers={'biz': 'baz'},
+            cookies={'foo': 'bar'},
+            env={'bing': 'bong'},
+            data='hello world',
+        ))
+        assert result.method == 'GET'
+        assert result.query_string == 'foo=bar'
+        assert result.fragment == 'foobar'
+        assert result.cookies == {'foo': 'bar'}
+        assert result.headers == {'biz': 'baz'}
+        assert result.env == {'bing': 'bong'}
+        assert result.data == 'hello world'
+
+    def test_query_string_as_dict(self):
+        result = Http.to_python(dict(
+            url='http://example.com',
+            query_string={'foo': 'bar'},
+        ))
+        assert result.query_string == 'foo=bar'
+
+    def test_data_as_dict(self):
+        result = Http.to_python(dict(
+            url='http://example.com',
+            data={'foo': 'bar'},
+        ))
+        assert result.data == {'foo': 'bar'}
+
+    def test_data_as_list(self):
+        result = Http.to_python(dict(
+            url='http://example.com',
+            data=['foo', 'bar'],
+        ))
+        assert result.data == {0: 'foo', 1: 'bar'}
+
+    def test_form_encoded_data(self):
+        result = Http.to_python(dict(
+            url='http://example.com',
+            headers={'Content-Type': 'application/x-www-form-urlencoded'},
+            data='foo=bar',
+        ))
+        assert result.data == {'foo': 'bar'}
+
+    def test_cookies_as_string(self):
+        result = Http.to_python(dict(
+            url='http://example.com',
+            cookies='a=b;c=d',
+        ))
+        assert result.cookies == {'a': 'b', 'c': 'd'}
+        result = Http.to_python(dict(
+            url='http://example.com',
+            cookies='a=b&c=d',
+        ))
+        assert result.cookies == {'a': 'b', 'c': 'd'}
+
+    def test_cookies_in_header(self):
+        result = Http.to_python(dict(
+            url='http://example.com',
+            headers={'Cookie': 'a=b;c=d'},
+        ))
+        assert result.cookies == {'a': 'b', 'c': 'd'}
+        result = Http.to_python(dict(
+            url='http://example.com',
+            headers={'Cookie': 'a=b;c=d'},
+            cookies={'foo': 'bar'},
+        ))
+        assert result.cookies == {'foo': 'bar'}
+
+    def test_query_string_and_fragment_as_params(self):
+        result = Http.to_python(dict(
+            url='http://example.com',
+            query_string='foo=bar',
+            fragment='fragment',
+        ))
+        assert result.url == 'http://example.com'
+        assert result.full_url == 'http://example.com?foo=bar#fragment'
+
+    def test_query_string_and_fragment_in_url(self):
+        result = Http.to_python(dict(
+            url='http://example.com?foo=bar#fragment',
+        ))
+        assert result.url == 'http://example.com'
+        assert result.full_url == 'http://example.com?foo=bar#fragment'
diff --git a/tests/sentry/interfaces/test_message.py b/tests/sentry/interfaces/test_message.py
new file mode 100644
index 0000000000..ff3f770045
--- /dev/null
+++ b/tests/sentry/interfaces/test_message.py
@@ -0,0 +1,30 @@
+# -*- coding: utf-8 -*-
+
+from __future__ import absolute_import
+
+from exam import fixture
+
+from sentry.testutils import TestCase
+from sentry.interfaces.message import Message
+
+
+class MessageTest(TestCase):
+    @fixture
+    def interface(self):
+        return Message.to_python(dict(
+            message='Hello there %s!',
+            params=('world',)
+        ))
+
+    def test_serialize_behavior(self):
+        assert self.interface.to_json() == {
+            'message': self.interface.message,
+            'params': self.interface.params,
+        }
+
+    def test_get_hash_uses_message(self):
+        assert self.interface.get_hash() == [self.interface.message]
+
+    def test_serialize_unserialize_behavior(self):
+        result = type(self.interface).to_python(self.interface.to_json())
+        assert result.to_json() == self.interface.to_json()
diff --git a/tests/sentry/interfaces/query/tests.py b/tests/sentry/interfaces/test_query.py
similarity index 56%
rename from tests/sentry/interfaces/query/tests.py
rename to tests/sentry/interfaces/test_query.py
index 042eeb9d8b..ebf52a9de9 100644
--- a/tests/sentry/interfaces/query/tests.py
+++ b/tests/sentry/interfaces/test_query.py
@@ -4,17 +4,17 @@ from __future__ import absolute_import
 
 from exam import fixture
 
+from sentry.interfaces.query import Query
 from sentry.testutils import TestCase
-from sentry.interfaces import Query
 
 
 class QueryTest(TestCase):
     @fixture
     def interface(self):
-        return Query(query='SELECT 1', engine='psycopg2')
+        return Query.to_python(dict(query='SELECT 1', engine='psycopg2'))
 
     def test_serialize_behavior(self):
-        assert self.interface.serialize() == {
+        assert self.interface.to_json() == {
             'query': self.interface.query,
             'engine': self.interface.engine,
         }
@@ -22,7 +22,6 @@ class QueryTest(TestCase):
     def test_get_hash_uses_query(self):
         assert self.interface.get_hash() == [self.interface.query]
 
-    def test_get_search_context(self):
-        assert self.interface.get_search_context(self.event) == {
-            'text': [self.interface.query],
-        }
+    def test_serialize_unserialize_behavior(self):
+        result = type(self.interface).to_python(self.interface.to_json())
+        assert result.to_json() == self.interface.to_json()
diff --git a/tests/sentry/interfaces/stacktrace/tests.py b/tests/sentry/interfaces/test_stacktrace.py
similarity index 67%
rename from tests/sentry/interfaces/stacktrace/tests.py
rename to tests/sentry/interfaces/test_stacktrace.py
index d9114cd7d5..5cbfc83a66 100644
--- a/tests/sentry/interfaces/stacktrace/tests.py
+++ b/tests/sentry/interfaces/test_stacktrace.py
@@ -6,15 +6,24 @@ import mock
 
 from exam import fixture
 
-from sentry.interfaces import Frame, Stacktrace, Exception
+from sentry.interfaces.exception import Exception
+from sentry.interfaces.stacktrace import (
+    Frame, Stacktrace, get_context, trim_frames
+)
 from sentry.models import Event
 from sentry.testutils import TestCase
 
 
+class GetContextTest(TestCase):
+    def test_works_with_empty_filename(self):
+        result = get_context(0, 'hello world')
+        assert result == [(0, 'hello world')]
+
+
 class StacktraceTest(TestCase):
     @fixture
     def interface(self):
-        return Stacktrace(frames=[
+        return Stacktrace.to_python(dict(frames=[
             {
                 'filename': 'foo/bar.py'
             },
@@ -23,75 +32,75 @@ class StacktraceTest(TestCase):
                 'lineno': 1,
                 'in_app': True,
             }
-        ])
+        ]))
 
     def test_legacy_interface(self):
         # Simple test to ensure legacy data works correctly with the ``Frame``
         # objects
         event = self.event
-        interface = Stacktrace(**event.data['sentry.interfaces.Stacktrace'])
+        interface = Stacktrace.to_python(event.data['sentry.interfaces.Stacktrace'])
         assert len(interface.frames) == 5
         assert interface == event.interfaces['sentry.interfaces.Stacktrace']
 
     def test_requires_filename(self):
         with self.assertRaises(AssertionError):
-            Stacktrace(frames=[{}]).validate()
+            Stacktrace.to_python(dict(frames=[{}]))
 
-        Stacktrace(frames=[{
+        Stacktrace.to_python(dict(frames=[{
             'filename': 'foo.py',
-        }]).validate()
-        Stacktrace(frames=[{
+        }]))
+        Stacktrace.to_python(dict(frames=[{
             'lineno': 1,
             'filename': 'foo.py',
-        }]).validate()
+        }]))
 
     def test_allows_abs_path_without_filename(self):
-        interface = Stacktrace(frames=[{
+        interface = Stacktrace.to_python(dict(frames=[{
             'lineno': 1,
             'abs_path': 'foo/bar/baz.py',
-        }])
+        }]))
         frame = interface.frames[0]
         assert frame.filename == 'foo/bar/baz.py'
         assert frame.abs_path == frame.filename
 
     def test_coerces_url_filenames(self):
-        interface = Stacktrace(frames=[{
+        interface = Stacktrace.to_python(dict(frames=[{
             'lineno': 1,
             'filename': 'http://foo.com/foo.js',
-        }])
+        }]))
         frame = interface.frames[0]
         assert frame.filename == '/foo.js'
         assert frame.abs_path == 'http://foo.com/foo.js'
 
     def test_coerces_url_abs_paths(self):
-        interface = Stacktrace(frames=[{
+        interface = Stacktrace.to_python(dict(frames=[{
             'lineno': 1,
             'filename': 'foo.js',
             'abs_path': 'http://foo.com/foo.js',
-        }])
+        }]))
         frame = interface.frames[0]
         assert frame.filename == '/foo.js'
         assert frame.abs_path == 'http://foo.com/foo.js'
 
     def test_ignores_results_with_empty_path(self):
-        interface = Stacktrace(frames=[{
+        interface = Stacktrace.to_python(dict(frames=[{
             'lineno': 1,
             'filename': 'http://foo.com',
-        }])
+        }]))
         frame = interface.frames[0]
         assert frame.filename == 'http://foo.com'
         assert frame.abs_path == frame.filename
 
     def test_serialize_returns_frames(self):
-        interface = Stacktrace(frames=[{
+        interface = Stacktrace.to_python(dict(frames=[{
             'lineno': 1,
             'filename': 'foo.py',
-        }])
-        result = interface.serialize()
+        }]))
+        result = interface.to_json()
         assert 'frames' in result
 
     def test_get_hash_with_only_required_vars(self):
-        interface = Frame(**{
+        interface = Frame.to_python({
             'lineno': 1,
             'filename': 'foo.py',
         })
@@ -100,7 +109,7 @@ class StacktraceTest(TestCase):
 
     def test_get_hash_sanitizes_block_functions(self):
         # This is Ruby specific
-        interface = Frame(**{
+        interface = Frame.to_python({
             'filename': 'foo.py',
             'function': 'block in _conditional_callback_around_233',
         })
@@ -109,7 +118,7 @@ class StacktraceTest(TestCase):
 
     def test_get_hash_sanitizes_versioned_filenames(self):
         # This is Ruby specific
-        interface = Frame(**{
+        interface = Frame.to_python({
             'filename': '/data/foo/releases/20140114151955/app/views/foo.html.erb',
             'context_line': '<% if @hotels.size > 0 %>',
         })
@@ -119,7 +128,7 @@ class StacktraceTest(TestCase):
             '<% if @hotels.size > 0 %>',
         ])
 
-        interface = Frame(**{
+        interface = Frame.to_python({
             'filename': '20140114151955/app/views/foo.html.erb',
             'context_line': '<% if @hotels.size > 0 %>',
         })
@@ -131,7 +140,7 @@ class StacktraceTest(TestCase):
 
     def test_get_hash_sanitizes_erb_templates(self):
         # This is Ruby specific
-        interface = Frame(**{
+        interface = Frame.to_python({
             'filename': 'foo.html.erb',
             'function': '_foo_html_erb__3327151541118998292_70361296749460',
         })
@@ -141,7 +150,7 @@ class StacktraceTest(TestCase):
         ])
 
     def test_get_hash_ignores_filename_if_http(self):
-        interface = Frame(**{
+        interface = Frame.to_python({
             'context_line': 'hello world',
             'filename': 'http://foo.com/foo.py',
         })
@@ -149,7 +158,7 @@ class StacktraceTest(TestCase):
         self.assertEquals(result, ['hello world'])
 
     def test_get_hash_ignores_filename_if_https(self):
-        interface = Frame(**{
+        interface = Frame.to_python({
             'context_line': 'hello world',
             'filename': 'https://foo.com/foo.py',
         })
@@ -157,7 +166,7 @@ class StacktraceTest(TestCase):
         self.assertEquals(result, ['hello world'])
 
     def test_get_hash_ignores_filename_if_abs_path_is_http(self):
-        interface = Frame(**{
+        interface = Frame.to_python({
             'context_line': 'hello world',
             'abs_path': 'https://foo.com/foo.py',
             'filename': 'foo.py',
@@ -166,7 +175,7 @@ class StacktraceTest(TestCase):
         self.assertEquals(result, ['hello world'])
 
     def test_get_hash_uses_module_over_filename(self):
-        interface = Frame(**{
+        interface = Frame.to_python({
             'lineno': 1,
             'filename': 'foo.py',
             'module': 'foo'
@@ -175,7 +184,7 @@ class StacktraceTest(TestCase):
         self.assertEquals(result, ['foo', 1])
 
     def test_get_hash_uses_function_over_lineno(self):
-        interface = Frame(**{
+        interface = Frame.to_python({
             'lineno': 1,
             'filename': 'foo.py',
             'function': 'bar'
@@ -184,7 +193,7 @@ class StacktraceTest(TestCase):
         self.assertEquals(result, ['foo.py', 'bar'])
 
     def test_get_hash_uses_context_line_over_function(self):
-        interface = Frame(**{
+        interface = Frame.to_python({
             'context_line': 'foo bar',
             'lineno': 1,
             'filename': 'foo.py',
@@ -194,13 +203,13 @@ class StacktraceTest(TestCase):
         self.assertEquals(result, ['foo.py', 'foo bar'])
 
     def test_get_composite_hash_uses_exception_if_present(self):
-        interface = Stacktrace(frames=[{
+        interface = Stacktrace.to_python(dict(frames=[{
             'context_line': 'foo bar',
             'lineno': 1,
             'filename': 'foo.py',
             'function': 'bar'
-        }])
-        interface_exc = Exception(type='exception', value='bar')
+        }]))
+        interface_exc = Exception.to_python(dict(type='exception', value='bar'))
         result = interface.get_composite_hash({
             'sentry.interfaces.Exception': interface_exc,
         })
@@ -208,13 +217,13 @@ class StacktraceTest(TestCase):
 
     def test_get_composite_hash_uses_exception_value_if_no_type_or_stack(self):
         interface = Stacktrace(frames=[])
-        interface_exc = Exception(value='bar')
+        interface_exc = Exception.to_python(dict(value='bar'))
         result = interface.get_composite_hash({
             'sentry.interfaces.Exception': interface_exc,
         })
         self.assertEquals(result[-1], 'bar')
 
-    @mock.patch('sentry.interfaces.Stacktrace.get_stacktrace')
+    @mock.patch('sentry.interfaces.stacktrace.Stacktrace.get_stacktrace')
     def test_to_string_returns_stacktrace(self, get_stacktrace):
         event = mock.Mock(spec=Event())
         interface = Stacktrace(frames=[])
@@ -222,25 +231,25 @@ class StacktraceTest(TestCase):
         get_stacktrace.assert_called_once_with(event, system_frames=False, max_frames=5)
         self.assertEquals(result, get_stacktrace.return_value)
 
-    @mock.patch('sentry.interfaces.is_newest_frame_first', mock.Mock(return_value=False))
-    @mock.patch('sentry.interfaces.Stacktrace.get_stacktrace')
+    @mock.patch('sentry.interfaces.stacktrace.is_newest_frame_first', mock.Mock(return_value=False))
+    @mock.patch('sentry.interfaces.stacktrace.Stacktrace.get_stacktrace')
     def test_get_traceback_response(self, get_stacktrace):
         event = mock.Mock(spec=Event())
         event.message = 'foo'
         get_stacktrace.return_value = 'bar'
-        interface = Stacktrace(frames=[{'lineno': 1, 'filename': 'foo.py'}])
+        interface = Stacktrace.to_python(dict(frames=[{'lineno': 1, 'filename': 'foo.py'}]))
         result = interface.get_traceback(event)
         get_stacktrace.assert_called_once_with(event, newest_first=None)
         self.assertEquals(result, 'foo\n\nbar')
 
-    @mock.patch('sentry.interfaces.is_newest_frame_first', mock.Mock(return_value=False))
-    @mock.patch('sentry.interfaces.Stacktrace.get_traceback')
-    @mock.patch('sentry.interfaces.render_to_string')
-    @mock.patch('sentry.interfaces.Frame.get_context')
+    @mock.patch('sentry.interfaces.stacktrace.is_newest_frame_first', mock.Mock(return_value=False))
+    @mock.patch('sentry.interfaces.stacktrace.Stacktrace.get_traceback')
+    @mock.patch('sentry.interfaces.stacktrace.render_to_string')
+    @mock.patch('sentry.interfaces.stacktrace.Frame.get_context')
     def test_to_html_render_call(self, get_frame_context, render_to_string, get_traceback):
         event = mock.Mock(spec=Event())
         get_traceback.return_value = 'bar'
-        interface = Stacktrace(frames=[{'lineno': 1, 'filename': 'foo.py'}])
+        interface = Stacktrace.to_python(dict(frames=[{'lineno': 1, 'filename': 'foo.py'}]))
         result = interface.to_html(event)
         get_traceback.assert_called_once_with(event, newest_first=False)
         get_frame_context.assert_called_once_with(event=event, is_public=False)
@@ -257,42 +266,67 @@ class StacktraceTest(TestCase):
         })
         self.assertEquals(result, render_to_string.return_value)
 
-    @mock.patch('sentry.interfaces.is_newest_frame_first', mock.Mock(return_value=False))
-    @mock.patch('sentry.interfaces.Stacktrace.get_traceback')
+    @mock.patch('sentry.interfaces.stacktrace.is_newest_frame_first', mock.Mock(return_value=False))
+    @mock.patch('sentry.interfaces.stacktrace.Stacktrace.get_traceback')
     def test_to_html_response(self, get_traceback):
         event = mock.Mock(spec=Event())
         event.message = 'foo'
         get_traceback.return_value = 'bar'
-        interface = Stacktrace(frames=[{'lineno': 1, 'filename': 'foo.py'}])
+        interface = Stacktrace.to_python(dict(frames=[{'lineno': 1, 'filename': 'foo.py'}]))
         result = interface.to_html(event)
         get_traceback.assert_called_once_with(event, newest_first=False)
         self.assertTrue('<div class="module">' in result)
 
-    @mock.patch('sentry.interfaces.is_newest_frame_first', mock.Mock(return_value=False))
+    @mock.patch('sentry.interfaces.stacktrace.is_newest_frame_first', mock.Mock(return_value=False))
     def test_get_stacktrace_with_only_filename(self):
         event = mock.Mock(spec=Event())
-        interface = Stacktrace(frames=[{'filename': 'foo'}, {'filename': 'bar'}])
+        interface = Stacktrace.to_python(dict(frames=[{'filename': 'foo'}, {'filename': 'bar'}]))
         result = interface.get_stacktrace(event)
         self.assertEquals(result, 'Stacktrace (most recent call last):\n\n  File "foo"\n  File "bar"')
 
-    @mock.patch('sentry.interfaces.is_newest_frame_first', mock.Mock(return_value=False))
+    @mock.patch('sentry.interfaces.stacktrace.is_newest_frame_first', mock.Mock(return_value=False))
     def test_get_stacktrace_with_module(self):
         event = mock.Mock(spec=Event())
-        interface = Stacktrace(frames=[{'module': 'foo'}, {'module': 'bar'}])
+        interface = Stacktrace.to_python(dict(frames=[{'module': 'foo'}, {'module': 'bar'}]))
         result = interface.get_stacktrace(event)
         self.assertEquals(result, 'Stacktrace (most recent call last):\n\n  Module "foo"\n  Module "bar"')
 
-    @mock.patch('sentry.interfaces.is_newest_frame_first', mock.Mock(return_value=False))
+    @mock.patch('sentry.interfaces.stacktrace.is_newest_frame_first', mock.Mock(return_value=False))
     def test_get_stacktrace_with_filename_and_function(self):
         event = mock.Mock(spec=Event())
-        interface = Stacktrace(frames=[{'filename': 'foo', 'function': 'biz'}, {'filename': 'bar', 'function': 'baz'}])
+        interface = Stacktrace.to_python(dict(frames=[{'filename': 'foo', 'function': 'biz'}, {'filename': 'bar', 'function': 'baz'}]))
         result = interface.get_stacktrace(event)
         self.assertEquals(result, 'Stacktrace (most recent call last):\n\n  File "foo", in biz\n  File "bar", in baz')
 
-    @mock.patch('sentry.interfaces.is_newest_frame_first', mock.Mock(return_value=False))
+    @mock.patch('sentry.interfaces.stacktrace.is_newest_frame_first', mock.Mock(return_value=False))
     def test_get_stacktrace_with_filename_function_lineno_and_context(self):
         event = mock.Mock(spec=Event())
-        interface = Stacktrace(frames=[{'filename': 'foo', 'function': 'biz', 'lineno': 3, 'context_line': '  def foo(r):'},
-            {'filename': 'bar', 'function': 'baz', 'lineno': 5, 'context_line': '    return None'}])
+        interface = Stacktrace.to_python(dict(frames=[
+            {'filename': 'foo', 'function': 'biz', 'lineno': 3, 'context_line': '  def foo(r):'},
+            {'filename': 'bar', 'function': 'baz', 'lineno': 5, 'context_line': '    return None'},
+        ]))
         result = interface.get_stacktrace(event)
         self.assertEquals(result, 'Stacktrace (most recent call last):\n\n  File "foo", line 3, in biz\n    def foo(r):\n  File "bar", line 5, in baz\n    return None')
+
+
+class TrimFramesTest(TestCase):
+    def test_under_max(self):
+        value = {'frames': [{'filename': 'foo'}]}
+        trim_frames(value)
+        assert len(value['frames']) == 1
+        assert value.get('frames_omitted') is None
+
+    def test_over_max(self):
+        values = []
+        for n in xrange(5):
+            values.append({'filename': 'frame %d' % n})
+        value = {'frames': values}
+        trim_frames(value, max_frames=4)
+
+        assert len(value['frames']) == 4
+
+        for value, num in zip(values[:2], xrange(2)):
+            assert value['filename'] == 'frame %d' % num
+
+        for value, num in zip(values[2:], xrange(3, 5)):
+            assert value['filename'] == 'frame %d' % num
diff --git a/tests/sentry/interfaces/template/tests.py b/tests/sentry/interfaces/test_template.py
similarity index 59%
rename from tests/sentry/interfaces/template/tests.py
rename to tests/sentry/interfaces/test_template.py
index ef4820d035..f7035180b6 100644
--- a/tests/sentry/interfaces/template/tests.py
+++ b/tests/sentry/interfaces/test_template.py
@@ -4,43 +4,41 @@ from __future__ import absolute_import
 
 import mock
 
-from sentry.interfaces import Template
-from sentry.models import Event
+from exam import fixture
 
+from sentry.interfaces.template import Template
+from sentry.models import Event
 from sentry.testutils import TestCase
 
 
 class TemplateTest(TestCase):
-    def test_serialize(self):
-        interface = Template(
+    @fixture
+    def interface(self):
+        return Template.to_python(dict(
             filename='foo.html',
             context_line='hello world',
             lineno=1,
-        )
-        result = interface.serialize()
+        ))
+
+    def test_serialize(self):
+        result = self.interface.to_json()
         self.assertEquals(result['filename'], 'foo.html')
         self.assertEquals(result['context_line'], 'hello world')
         self.assertEquals(result['lineno'], 1)
 
     def test_get_hash(self):
-        interface = Template(
-            filename='foo.html',
-            context_line='hello world',
-            lineno=1,
-        )
-        result = interface.get_hash()
+        result = self.interface.get_hash()
         self.assertEquals(result, ['foo.html', 'hello world'])
 
-    @mock.patch('sentry.interfaces.get_context')
-    @mock.patch('sentry.interfaces.Template.get_traceback')
+    @mock.patch('sentry.interfaces.template.get_context')
+    @mock.patch('sentry.interfaces.template.Template.get_traceback')
     def test_to_string_returns_traceback(self, get_traceback, get_context):
         get_traceback.return_value = 'traceback'
         event = mock.Mock(spec=Event)
-        interface = Template(
-            filename='foo.html',
-            context_line='hello world',
-            lineno=1,
-        )
-        result = interface.to_string(event)
+        result = self.interface.to_string(event)
         get_traceback.assert_called_once_with(event, get_context.return_value)
         self.assertEquals(result, 'Stacktrace (most recent call last):\n\ntraceback')
+
+    def test_serialize_unserialize_behavior(self):
+        result = type(self.interface).to_python(self.interface.to_json())
+        assert result.to_json() == self.interface.to_json()
diff --git a/tests/sentry/interfaces/user/tests.py b/tests/sentry/interfaces/test_user.py
similarity index 67%
rename from tests/sentry/interfaces/user/tests.py
rename to tests/sentry/interfaces/test_user.py
index de09aad150..a4647d376f 100644
--- a/tests/sentry/interfaces/user/tests.py
+++ b/tests/sentry/interfaces/test_user.py
@@ -6,7 +6,7 @@ import mock
 from exam import fixture
 
 from sentry.testutils import TestCase
-from sentry.interfaces import User
+from sentry.interfaces.user import User
 from sentry.models import Event
 
 
@@ -17,10 +17,14 @@ class UserTest(TestCase):
 
     @fixture
     def interface(self):
-        return User(id=1, email='lol@example.com', favorite_color='brown')
+        return User.to_python(dict(
+            id=1,
+            email='lol@example.com',
+            favorite_color='brown',
+        ))
 
     def test_serialize_behavior(self):
-        assert self.interface.serialize() == {
+        assert self.interface.to_json() == {
             'id': 1,
             'username': None,
             'email': 'lol@example.com',
@@ -28,10 +32,9 @@ class UserTest(TestCase):
             'data': {'favorite_color': 'brown'}
         }
 
-    @mock.patch('sentry.interfaces.render_to_string')
+    @mock.patch('sentry.interfaces.user.render_to_string')
     def test_to_html(self, render_to_string):
-        interface = User(**self.interface.serialize())
-        interface.to_html(self.event)
+        self.interface.to_html(self.event)
         render_to_string.assert_called_once_with('sentry/partial/interfaces/user.html', {
             'is_public': False,
             'event': self.event,
@@ -45,3 +48,7 @@ class UserTest(TestCase):
     def test_to_html_public(self):
         result = self.interface.to_html(self.event, is_public=True)
         assert result == ''
+
+    def test_serialize_unserialize_behavior(self):
+        result = type(self.interface).to_python(self.interface.to_json())
+        assert result.to_json() == self.interface.to_json()
diff --git a/tests/sentry/interfaces/tests.py b/tests/sentry/interfaces/tests.py
deleted file mode 100644
index edd75a8877..0000000000
--- a/tests/sentry/interfaces/tests.py
+++ /dev/null
@@ -1,57 +0,0 @@
-# -*- coding: utf-8 -*-
-
-from __future__ import absolute_import
-
-import mock
-import pickle
-
-from exam import fixture
-
-from sentry.interfaces import Interface, get_context
-from sentry.models import Event
-from sentry.testutils import TestCase
-
-
-class InterfaceBase(TestCase):
-    @fixture
-    def event(self):
-        return Event(
-            id=1,
-        )
-
-
-class InterfaceTest(InterfaceBase):
-    @fixture
-    def interface(self):
-        return Interface(foo=1)
-
-    def test_init_sets_attrs(self):
-        assert self.interface.attrs == ['foo']
-
-    def test_setstate_sets_attrs(self):
-        data = pickle.dumps(self.interface)
-        obj = pickle.loads(data)
-        assert obj.attrs == ['foo']
-
-    def test_to_html_default(self):
-        assert self.interface.to_html(self.event) == ''
-
-    def test_to_string_default(self):
-        assert self.interface.to_string(self.event) == ''
-
-    def test_get_search_context_default(self):
-        assert self.interface.get_search_context(self.event) == {}
-
-    @mock.patch('sentry.interfaces.Interface.get_hash')
-    def test_get_composite_hash_calls_get_hash(self, get_hash):
-        assert self.interface.get_composite_hash(self.event) == get_hash.return_value
-        get_hash.assert_called_once_with()
-
-    def test_validate_default(self):
-        self.interface.validate()
-
-
-class GetContextTest(TestCase):
-    def test_works_with_empty_filename(self):
-        result = get_context(0, 'hello world')
-        assert result == [(0, 'hello world')]
diff --git a/tests/sentry/interfaces/user/__init__.py b/tests/sentry/interfaces/user/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/tests/sentry/manager/tests.py b/tests/sentry/manager/tests.py
index 0d4ff68828..70b70c8afc 100644
--- a/tests/sentry/manager/tests.py
+++ b/tests/sentry/manager/tests.py
@@ -7,7 +7,6 @@ import mock
 
 from django.utils import timezone
 from sentry.constants import MEMBER_OWNER, MEMBER_USER
-from sentry.interfaces import Interface
 from sentry.manager import get_checksum_from_event
 from sentry.models import (
     Event, Group, Project, GroupCountByMinute, ProjectCountByMinute,
@@ -16,11 +15,6 @@ from sentry.models import (
 from sentry.testutils import TestCase
 
 
-class DummyInterface(Interface):
-    def __init__(self, baz):
-        self.baz = baz
-
-
 class SentryManagerTest(TestCase):
     @mock.patch('sentry.signals.regression_signal.send')
     def test_broken_regression_signal(self, send):
@@ -146,8 +140,8 @@ class SentryManagerTest(TestCase):
 
 
 class GetChecksumFromEventTest(TestCase):
-    @mock.patch('sentry.interfaces.Stacktrace.get_composite_hash')
-    @mock.patch('sentry.interfaces.Http.get_composite_hash')
+    @mock.patch('sentry.interfaces.stacktrace.Stacktrace.get_composite_hash')
+    @mock.patch('sentry.interfaces.http.Http.get_composite_hash')
     def test_stacktrace_wins_over_http(self, http_comp_hash, stack_comp_hash):
         # this was a regression, and a very important one
         http_comp_hash.return_value = ['baz']
diff --git a/tests/sentry/plugins/mail/tests.py b/tests/sentry/plugins/mail/tests.py
index 8d4e67fc96..3cea095110 100644
--- a/tests/sentry/plugins/mail/tests.py
+++ b/tests/sentry/plugins/mail/tests.py
@@ -8,7 +8,7 @@ from django.utils import timezone
 from exam import fixture
 from mock import Mock
 
-from sentry.interfaces import Stacktrace
+from sentry.interfaces.stacktrace import Stacktrace
 from sentry.models import Alert, Event, Group, AccessGroup
 from sentry.plugins.sentry_mail.models import MailPlugin
 from sentry.testutils import TestCase
diff --git a/tests/sentry/utils/safe/tests.py b/tests/sentry/utils/safe/tests.py
index 8e99eb49c3..367c424d17 100644
--- a/tests/sentry/utils/safe/tests.py
+++ b/tests/sentry/utils/safe/tests.py
@@ -1,9 +1,7 @@
 from __future__ import absolute_import
 
-import itertools
-
 from sentry.testutils import TestCase
-from sentry.utils.safe import trim, trim_dict, trim_frames
+from sentry.utils.safe import trim, trim_dict
 
 a_very_long_string = 'a' * 1024
 
@@ -23,26 +21,3 @@ class TrimDictTest(TestCase):
         value = dict((k, k) for k in xrange(500))
         trim_dict(value)
         assert len(value) == 50
-
-
-class TrimStacktraceTest(TestCase):
-    def test_under_max(self):
-        value = {'frames': [{'filename': 'foo'}]}
-        trim_frames(value)
-        assert len(value['frames']) == 1
-        assert value.get('frames_omitted') is None
-
-    def test_over_max(self):
-        values = []
-        for n in xrange(5):
-            values.append({'filename': 'frame %d' % n})
-        value = {'frames': values}
-        trim_frames(value, max_frames=4)
-
-        assert len(value['frames']) == 4
-
-        for value, num in itertools.izip(values[:2], xrange(2)):
-            assert value['filename'] == 'frame %d' % num
-
-        for value, num in itertools.izip(values[2:], xrange(3, 5)):
-            assert value['filename'] == 'frame %d' % num

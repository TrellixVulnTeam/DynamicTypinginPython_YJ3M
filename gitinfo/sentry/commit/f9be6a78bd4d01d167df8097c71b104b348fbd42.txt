commit f9be6a78bd4d01d167df8097c71b104b348fbd42
Author: David Cramer <dcramer@gmail.com>
Date:   Fri Dec 4 16:45:13 2015 -0800

    Revert offset paginator to classical paging

diff --git a/src/sentry/api/bases/organizationissues.py b/src/sentry/api/bases/organizationissues.py
index 31e62b922a..e0931434c5 100644
--- a/src/sentry/api/bases/organizationissues.py
+++ b/src/sentry/api/bases/organizationissues.py
@@ -3,7 +3,7 @@ from __future__ import absolute_import
 from rest_framework.response import Response
 
 from sentry.api.serializers import serialize, StreamGroupSerializer
-from sentry.api.paginator import DateTimePaginator
+from sentry.api.paginator import OffsetPaginator
 from sentry.models import Group, GroupStatus, OrganizationMemberTeam, Project
 
 from .organizationmember import OrganizationMemberEndpoint
@@ -51,7 +51,7 @@ class OrganizationIssuesEndpoint(OrganizationMemberEndpoint):
             request=request,
             queryset=queryset,
             order_by='-sort_by',
-            paginator_cls=DateTimePaginator,
+            paginator_cls=OffsetPaginator,
             on_results=lambda x: serialize(x, request.user, StreamGroupSerializer(
                 stats_period=stats_period,
             )),
diff --git a/src/sentry/api/paginator.py b/src/sentry/api/paginator.py
index 524fb9d273..0422e72bae 100644
--- a/src/sentry/api/paginator.py
+++ b/src/sentry/api/paginator.py
@@ -13,7 +13,7 @@ from datetime import datetime
 from django.db import connections
 from django.utils import timezone
 
-from sentry.utils.cursors import build_cursor, Cursor
+from sentry.utils.cursors import build_cursor, Cursor, CursorResult
 
 quote_name = connections['default'].ops.quote_name
 
@@ -26,8 +26,8 @@ class BasePaginator(object):
             self.key, self.desc = order_by, False
         self.queryset = queryset
 
-    def _get_results_from_qs(self, value, is_prev):
-        results = self.queryset
+    def _build_queryset(self, value, is_prev):
+        queryset = self.queryset
 
         # "asc" controls whether or not we need to change the ORDER BY to
         # ascending.  If we're sorting by DESC but we're using a previous
@@ -40,40 +40,40 @@ class BasePaginator(object):
         # We need to reverse the ORDER BY if we're using a cursor for a
         # previous page so we know exactly where we ended last page.  The
         # results will get reversed back to the requested order below.
-        if self.key in results.query.order_by:
+        if self.key in queryset.query.order_by:
             if not asc:
-                index = results.query.order_by.index(self.key)
-                results.query.order_by[index] = '-%s' % (results.query.order_by[index])
-        elif ('-%s' % self.key) in results.query.order_by:
+                index = queryset.query.order_by.index(self.key)
+                queryset.query.order_by[index] = '-%s' % (queryset.query.order_by[index])
+        elif ('-%s' % self.key) in queryset.query.order_by:
             if asc:
-                index = results.query.order_by.index('-%s' % (self.key))
-                results.query.order_by[index] = results.query.order_by[index][1:]
+                index = queryset.query.order_by.index('-%s' % (self.key))
+                queryset.query.order_by[index] = queryset.query.order_by[index][1:]
         else:
             if asc:
-                results = results.order_by(self.key)
+                queryset = queryset.order_by(self.key)
             else:
-                results = results.order_by('-%s' % self.key)
+                queryset = queryset.order_by('-%s' % self.key)
 
         if value:
-            if self.key in results.query.extra:
-                col_query, col_params = results.query.extra[self.key]
+            if self.key in queryset.query.extra:
+                col_query, col_params = queryset.query.extra[self.key]
                 col_params = col_params[:]
             else:
                 col_query, col_params = quote_name(self.key), []
             col_params.append(value)
 
             if asc:
-                results = results.extra(
-                    where=['%s.%s >= %%s' % (results.model._meta.db_table, col_query,)],
+                queryset = queryset.extra(
+                    where=['%s.%s >= %%s' % (queryset.model._meta.db_table, col_query,)],
                     params=col_params,
                 )
             else:
-                results = results.extra(
-                    where=['%s.%s <= %%s' % (results.model._meta.db_table, col_query,)],
+                queryset = queryset.extra(
+                    where=['%s.%s <= %%s' % (queryset.model._meta.db_table, col_query,)],
                     params=col_params,
                 )
 
-        return results
+        return queryset
 
     def get_item_key(self, item):
         raise NotImplementedError
@@ -92,19 +92,17 @@ class BasePaginator(object):
         else:
             cursor_value = 0
 
-        queryset = self._get_results_from_qs(cursor_value, cursor.is_prev)
+        queryset = self._build_queryset(cursor_value, cursor.is_prev)
 
-        # this effectively gets us the before post, and the current (after) post
-        # every time
+        # TODO(dcramer): this does not yet work correctly for ``is_prev`` when
+        # the key is not unique
+        offset = cursor.offset
         if cursor.is_prev:
-            stop = cursor.offset + limit + 2
-        else:
-            stop = cursor.offset + limit + 1
-
-        results = list(queryset[cursor.offset:stop])
-
+            offset += 1
+        stop = offset + limit + 1
+        results = list(queryset[offset:stop])
         if cursor.is_prev:
-            results = results[::-1]
+            results.reverse()
 
         return build_cursor(
             results=results,
@@ -141,9 +139,29 @@ class DateTimePaginator(BasePaginator):
         ).replace(tzinfo=timezone.utc)
 
 
+# TODO(dcramer): previous cursors are too complex at the moment for many things
+# and are only useful for polling situations. The OffsetPaginator ignores them
+# entirely and uses standard paging
 class OffsetPaginator(BasePaginator):
-    def get_item_key(self, item):
-        return 0
+    def get_result(self, limit=100, cursor=None):
+        # offset is page #
+        # value is page limit
+        if cursor is None:
+            cursor = Cursor(0, 0, 0)
 
-    def value_from_cursor(self, cursor):
-        return 0
+        page = cursor.offset
+        offset = cursor.offset * cursor.value
+        stop = offset + (cursor.value or limit) + 1
+
+        results = list(self.queryset[offset:stop])
+        if cursor.value != limit:
+            results = results[::-1][:limit + 1][::-1]
+
+        next_cursor = Cursor(limit, page + 1, False, len(results) > limit)
+        prev_cursor = Cursor(limit, page - 1, True, page > 0)
+
+        return CursorResult(
+            results=results[:limit],
+            next=next_cursor,
+            prev=prev_cursor,
+        )
diff --git a/tests/sentry/api/test_paginator.py b/tests/sentry/api/test_paginator.py
new file mode 100644
index 0000000000..ee430feb88
--- /dev/null
+++ b/tests/sentry/api/test_paginator.py
@@ -0,0 +1,80 @@
+from __future__ import absolute_import
+
+import pytest
+
+from sentry.api.paginator import (
+    DateTimePaginator, OffsetPaginator
+)
+from sentry.models import User
+from sentry.testutils import TestCase
+
+
+class OffsetPaginatorTest(TestCase):
+    # offset paginator does not support dynamic limits on is_prev
+    def test_simple(self):
+        res1 = self.create_user('foo@example.com')
+        res2 = self.create_user('bar@example.com')
+        res3 = self.create_user('baz@example.com')
+
+        queryset = User.objects.all()
+
+        paginator = OffsetPaginator(queryset, 'id')
+        result1 = paginator.get_result(limit=1, cursor=None)
+        assert len(result1) == 1, result1
+        assert result1[0] == res1
+        assert result1.next
+        assert not result1.prev
+
+        result2 = paginator.get_result(limit=1, cursor=result1.next)
+        assert len(result2) == 1, (result2, list(result2))
+        assert result2[0] == res2
+        assert result2.next
+        assert result2.prev
+
+        result3 = paginator.get_result(limit=1, cursor=result2.next)
+        assert len(result3) == 1, result3
+        assert result3[0] == res3
+        assert not result3.next
+        assert result3.prev
+
+        result4 = paginator.get_result(limit=1, cursor=result3.next)
+        assert len(result4) == 0, result4
+        assert not result4.next
+        assert result4.prev
+
+        result5 = paginator.get_result(limit=1, cursor=result4.prev)
+        assert len(result5) == 1, result5
+        assert result5[0] == res3
+        assert not result5.next
+        assert result5.prev
+
+
+class DateTimePaginatorTest(TestCase):
+    @pytest.mark.xfail
+    def test_simple(self):
+        res1 = self.create_user('foo@example.com')
+        res2 = self.create_user('bar@example.com')
+        res3 = self.create_user('baz@example.com')
+
+        queryset = User.objects.all()
+
+        paginator = DateTimePaginator(queryset, 'date_joined')
+        result1 = paginator.get_result(limit=1, cursor=None)
+        assert len(result1) == 1, result1
+        assert result1[0] == res1
+        assert result1.next
+        assert not result1.prev
+
+        result2 = paginator.get_result(limit=2, cursor=result1.next)
+        assert len(result2) == 2, result2
+        assert result2[0] == res2
+        assert result2[1] == res3
+        assert not result2.next
+        assert result2.prev
+
+        # this is not yet correct
+        result3 = paginator.get_result(limit=2, cursor=result2.prev)
+        assert len(result3) == 1, list(result3)
+        assert result3[0] == res1
+        assert result3.next
+        assert not result3.prev

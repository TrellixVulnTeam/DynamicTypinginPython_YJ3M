commit d30f301288823dd179431ea54ef6b6df25e2a43c
Author: David Cramer <dcramer@gmail.com>
Date:   Thu Jul 6 10:56:27 2017 -0700

    api: add X-Hits and X-Max-Hits support

diff --git a/src/sentry/api/base.py b/src/sentry/api/base.py
index 4ba157d2ae..87210389f2 100644
--- a/src/sentry/api/base.py
+++ b/src/sentry/api/base.py
@@ -221,6 +221,10 @@ class Endpoint(APIView):
             results = on_results(cursor_result.results)
 
         headers = {}
+        if cursor_result.hits is not None:
+            headers['X-Hits'] = cursor_result.hits
+        if cursor_result.max_hits is not None:
+            headers['X-Max-Hits'] = cursor_result.max_hits
         headers['Link'] = ', '.join([
             self.build_cursor_link(request, 'previous', cursor_result.prev),
             self.build_cursor_link(request, 'next', cursor_result.next),
diff --git a/src/sentry/api/paginator.py b/src/sentry/api/paginator.py
index 27201792be..ff25f08c7b 100644
--- a/src/sentry/api/paginator.py
+++ b/src/sentry/api/paginator.py
@@ -11,6 +11,7 @@ import math
 
 from datetime import datetime
 from django.db import connections
+from django.db.models.sql.datastructures import EmptyResultSet
 from django.utils import timezone
 
 from sentry.utils.cursors import build_cursor, Cursor, CursorResult
@@ -37,7 +38,7 @@ class BasePaginator(object):
         # "asc" controls whether or not we need to change the ORDER BY to
         # ascending.  If we're sorting by DESC but we're using a previous
         # page cursor, we'll change the ordering to ASC and reverse the
-        # list below (this is so we know how to get the before/after post).
+        # list below (this is so we know how to get the before/after row).
         # If we're sorting ASC _AND_ we're not using a previous page cursor,
         # then we'll need to resume using ASC.
         asc = (self.desc and is_prev) or not (self.desc or is_prev)
@@ -49,7 +50,8 @@ class BasePaginator(object):
             if self.key in queryset.query.order_by:
                 if not asc:
                     index = queryset.query.order_by.index(self.key)
-                    queryset.query.order_by[index] = '-%s' % (queryset.query.order_by[index])
+                    queryset.query.order_by[index] = '-%s' % (
+                        queryset.query.order_by[index])
             elif ('-%s' % self.key) in queryset.query.order_by:
                 if asc:
                     index = queryset.query.order_by.index('-%s' % (self.key))
@@ -71,12 +73,14 @@ class BasePaginator(object):
 
             if asc:
                 queryset = queryset.extra(
-                    where=['%s.%s >= %%s' % (queryset.model._meta.db_table, col_query,)],
+                    where=['%s.%s >= %%s' %
+                           (queryset.model._meta.db_table, col_query,)],
                     params=col_params,
                 )
             else:
                 queryset = queryset.extra(
-                    where=['%s.%s <= %%s' % (queryset.model._meta.db_table, col_query,)],
+                    where=['%s.%s <= %%s' %
+                           (queryset.model._meta.db_table, col_query,)],
                     params=col_params,
                 )
 
@@ -88,7 +92,7 @@ class BasePaginator(object):
     def value_from_cursor(self, cursor):
         raise NotImplementedError
 
-    def get_result(self, limit=100, cursor=None):
+    def get_result(self, limit=100, cursor=None, count_hits=False):
         # cursors are:
         #   (identifier(integer), row offset, is_prev)
         if cursor is None:
@@ -105,7 +109,16 @@ class BasePaginator(object):
 
         # TODO(dcramer): this does not yet work correctly for ``is_prev`` when
         # the key is not unique
+        if count_hits:
+            max_hits = 1000
+            hits = self.count_hits(max_hits)
+        else:
+            hits = None
+            max_hits = None
+
         offset = cursor.offset
+        # this effectively gets us the before row, and the current (after) row
+        # every time
         if cursor.is_prev:
             offset += 1
         stop = offset + limit + 1
@@ -116,10 +129,30 @@ class BasePaginator(object):
         return build_cursor(
             results=results,
             limit=limit,
+            hits=hits,
+            max_hits=max_hits,
             cursor=cursor,
             key=self.get_item_key,
         )
 
+    def count_hits(self, max_hits):
+        if not max_hits:
+            return 0
+        hits_query = self.queryset.values()[:max_hits].query
+        # clear out any select fields (include select_related) and pull just the id
+        hits_query.clear_select_clause()
+        hits_query.add_fields(['id'])
+        hits_query.clear_ordering(force_empty=True)
+        try:
+            h_sql, h_params = hits_query.sql_with_params()
+        except EmptyResultSet:
+            return 0
+        cursor = connections[self.queryset.db].cursor()
+        cursor.execute(u'SELECT COUNT(*) FROM ({}) as t'.format(
+            h_sql,
+        ), h_params)
+        return cursor.fetchone()[0]
+
 
 class Paginator(BasePaginator):
     def get_item_key(self, item):
diff --git a/src/sentry/search/django/backend.py b/src/sentry/search/django/backend.py
index 92ddf0d22f..9332b0e35b 100644
--- a/src/sentry/search/django/backend.py
+++ b/src/sentry/search/django/backend.py
@@ -284,6 +284,5 @@ class DjangoSearchBackend(SearchBackend):
             sort_clause = '-sort_value'
 
         queryset = queryset.order_by(sort_clause)
-
         paginator = paginator_cls(queryset, sort_clause)
         return paginator.get_result(limit, cursor)
diff --git a/src/sentry/utils/cursors.py b/src/sentry/utils/cursors.py
index c5fc299b62..c4ddd1f55f 100644
--- a/src/sentry/utils/cursors.py
+++ b/src/sentry/utils/cursors.py
@@ -44,10 +44,12 @@ class Cursor(object):
 
 
 class CursorResult(Sequence):
-    def __init__(self, results, next, prev):
+    def __init__(self, results, next, prev, hits=None, max_hits=None):
         self.results = results
         self.next = next
         self.prev = prev
+        self.hits = hits
+        self.max_hits = max_hits
 
     def __len__(self):
         return len(self.results)
@@ -82,7 +84,7 @@ class CursorResult(Sequence):
         )
 
 
-def build_cursor(results, key, limit=100, cursor=None):
+def build_cursor(results, key, limit=100, cursor=None, hits=None, max_hits=None):
     if cursor is None:
         cursor = Cursor(0, 0, 0)
 
@@ -167,4 +169,6 @@ def build_cursor(results, key, limit=100, cursor=None):
         results=results,
         next=next_cursor,
         prev=prev_cursor,
+        hits=hits,
+        max_hits=max_hits,
     )
diff --git a/tests/sentry/api/test_paginator.py b/tests/sentry/api/test_paginator.py
index 9d5b53b0ab..eb9bdcd5a7 100644
--- a/tests/sentry/api/test_paginator.py
+++ b/tests/sentry/api/test_paginator.py
@@ -27,6 +27,30 @@ class PaginatorTest(TestCase):
         result = paginator.get_result(limit=2, cursor=None)
         assert len(result) == 1
 
+    def test_count_hits(self):
+        self.create_user('foo@example.com')
+        self.create_user('bar@example.com')
+
+        queryset = User.objects.filter(email='foo@example.com')
+        paginator = self.cls(queryset, 'id')
+        result = paginator.count_hits(1000)
+        assert result == 1
+
+        queryset = User.objects.all()
+        paginator = self.cls(queryset, 'id')
+        result = paginator.count_hits(1000)
+        assert result == 2
+
+        queryset = User.objects.none()
+        paginator = self.cls(queryset, 'id')
+        result = paginator.count_hits(1000)
+        assert result == 0
+
+        queryset = User.objects.all()
+        paginator = self.cls(queryset, 'id')
+        result = paginator.count_hits(1)
+        assert result == 1
+
 
 class OffsetPaginatorTest(TestCase):
     # offset paginator does not support dynamic limits on is_prev

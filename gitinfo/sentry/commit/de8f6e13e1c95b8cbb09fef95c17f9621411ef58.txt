commit de8f6e13e1c95b8cbb09fef95c17f9621411ef58
Author: David Cramer <dcramer@gmail.com>
Date:   Mon Dec 31 14:54:49 2012 -0800

    Track attribute changes on models

diff --git a/src/sentry/manager.py b/src/sentry/manager.py
index 43dc6ad383..deeb13d841 100644
--- a/src/sentry/manager.py
+++ b/src/sentry/manager.py
@@ -988,11 +988,8 @@ class SearchDocumentManager(BaseManager):
             token_sql = ' '
 
         sql = """
-            SELECT sd.id AS id,
-                   sd.group_id AS group_id,
-                   SUM(st.times_seen) / sd.total_events as score,
-                   sd.date_changed AS date_changed,
-                   sd.date_added AS date_added
+            SELECT sd.*,
+                   SUM(st.times_seen) / sd.total_events as score
             FROM sentry_searchdocument as sd
             INNER JOIN sentry_searchtoken as st
                 ON st.document_id = sd.id
diff --git a/src/sentry/utils/models.py b/src/sentry/utils/models.py
index 4fb3fef46e..8c3b1ec336 100644
--- a/src/sentry/utils/models.py
+++ b/src/sentry/utils/models.py
@@ -73,6 +73,45 @@ class Model(models.Model):
         abstract = True
 
     update = update
+    __UNSAVED = object()
+
+    def __init__(self, *args, **kwargs):
+        super(Model, self).__init__(*args, **kwargs)
+        self._update_tracked_data()
+
+    def __get_field_value(self, field):
+        if isinstance(field, models.ForeignKey):
+            return getattr(self, field.column)
+        return getattr(self, field.name)
+
+    def _update_tracked_data(self):
+        "Updates a local copy of attributes values"
+
+        if self.id:
+            self.__data = dict((f.column, self.__get_field_value(f)) for f in self._meta.fields)
+        else:
+            self.__data = self.__UNSAVED
+
+    def has_changed(self, field_name):
+        "Returns ``True`` if ``field`` has changed since initialization."
+        if self.__data is self.__UNSAVED:
+            return False
+        field = self._meta.get_field(field_name)
+        return self.__data.get(field_name) != self.__get_field_value(field)
+
+    def old_value(self, field_name):
+        "Returns the previous value of ``field``"
+        if self.__data is self.__UNSAVED:
+            return None
+        return self.__data.get(field_name)
+
+
+def __model_post_save(instance, **kwargs):
+    if not isinstance(instance, Model):
+        return
+    instance._update_tracked_data()
+
+signals.post_save.connect(__model_post_save)
 
 
 class GzippedDictField(models.TextField):
diff --git a/tests/sentry/utils/models/__init__.py b/tests/sentry/utils/models/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/tests/sentry/utils/models/tests.py b/tests/sentry/utils/models/tests.py
new file mode 100644
index 0000000000..087c3c06de
--- /dev/null
+++ b/tests/sentry/utils/models/tests.py
@@ -0,0 +1,30 @@
+from __future__ import absolute_import
+
+from django.db import models
+from sentry.utils.models import Model
+from sentry.testutils import TestCase
+
+
+# There's a good chance this model wont get created in the db, so avoid
+# assuming it exists in these tests.
+class DummyModel(Model):
+    foo = models.CharField(max_length=32)
+
+
+class ModelTest(TestCase):
+    def test_foo_hasnt_changed_on_init(self):
+        inst = DummyModel(id=1, foo='bar')
+        self.assertFalse(inst.has_changed('foo'))
+
+    def test_foo_has_changes_before_save(self):
+        inst = DummyModel(id=1, foo='bar')
+        inst.foo = 'baz'
+        self.assertTrue(inst.has_changed('foo'))
+        self.assertEquals(inst.old_value('foo'), 'bar')
+
+    def test_foo_hasnt_changed_after_save(self):
+        inst = DummyModel(id=1, foo='bar')
+        inst.foo = 'baz'
+        self.assertTrue(inst.has_changed('foo'))
+        self.assertEquals(inst.old_value('foo'), 'bar')
+        models.signals.post_save.send(instance=inst, sender=type(inst), created=False)

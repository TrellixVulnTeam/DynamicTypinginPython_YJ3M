commit 9adc914ecc49ee38b63f6e0f3d976db52a87a198
Author: Ted Kaemming <ted@kaemming.com>
Date:   Tue Dec 1 17:20:29 2015 -0800

    Support TTL in Lua quota script.
    
    This also allows for variable interval quota windows, which is something
    we'll need for the internal implementation but isn't exposed directly
    here.

diff --git a/src/sentry/quotas/redis.py b/src/sentry/quotas/redis.py
index 154ec68ed7..cc25de9df6 100644
--- a/src/sentry/quotas/redis.py
+++ b/src/sentry/quotas/redis.py
@@ -20,18 +20,29 @@ from sentry.utils.redis import make_rb_cluster
 # Check a collection of quota counters to identify if an item should be rate
 # limited. Values provided as ``KEYS`` specify the keys of the counters to
 # check, and values provided as ``ARGV`` specify the maximum value (quota
-# limit) for the key at the same array index. (``KEYS`` and ``ARGV`` must be
-# the same length.) If all checks pass (the item is accepted), all counters are
-# incremented. If any checks fail (the item is rejected), all counters are
-# unaffected. The result is a Lua table/array (Redis multi bulk reply) that
-# specifies whether or not the item was *rejected* based on the provided limit.
+# limit) and expiration time for each key.
+#
+# For example, to check a quota ``foo`` that has a limit of 10 items and
+# expires at the Unix timestamp ``100``, as well as a quota ``bar`` that has a
+# limit of 20 items and should expire at the Unix timestamp ``200``, the
+# ``KEYS`` and ``ARGV`` values would be as follows:
+#
+#   KEYS = {"foo", "bar"}
+#   ARGV = {10, 100, 20, 100}
+#
+# If all checks pass (the item is accepted), the counters for all quotas are
+# incremented. If any checks fail (the item is rejected), the counters for all
+# quotas are unaffected. The result is a Lua table/array (Redis multi bulk
+# reply) that specifies whether or not the item was *rejected* based on the
+# provided limit.
 IS_RATE_LIMITED_SCRIPT = """\
-assert(#KEYS == #ARGV, "unequal number of keys and arguments provided")
+assert(#KEYS * 2 == #ARGV, "incorrect number of keys and arguments provided")
 
 local results = {}
 local failed = false
-for i=1,#ARGV do
-    local rejected = (redis.call('GET', KEYS[i]) or 0) + 1 > tonumber(ARGV[i])
+for i=1,#KEYS do
+    local limit = tonumber(ARGV[(i * 2) - 1])
+    local rejected = (redis.call('GET', KEYS[i]) or 0) + 1 > limit
     if rejected then
         failed = true
     end
@@ -39,8 +50,9 @@ for i=1,#ARGV do
 end
 
 if not failed then
-    for i=1,#ARGV do
+    for i=1,#KEYS do
         redis.call('INCR', KEYS[i])
+        redis.call('EXPIREAT', KEYS[i], ARGV[i * 2])
     end
 end
 
@@ -51,7 +63,13 @@ is_rate_limited = Script(None, IS_RATE_LIMITED_SCRIPT)
 
 
 class RedisQuota(Quota):
-    ttl = 60
+    #: The ``interval`` specifies the size of a quota window in seconds.
+    interval = 60
+
+    #: The ``grace`` period allows accomodating for clock drift in TTL
+    #: calculation since the clock on the Redis instance used to store quota
+    #: metrics may not be in sync with the computer running this code.
+    grace = 60
 
     def __init__(self, **options):
         if not options:
@@ -68,33 +86,45 @@ class RedisQuota(Quota):
         except Exception as e:
             raise InvalidConfiguration(unicode(e))
 
-    def _get_quotas(self, project):
+    def _get_quotas(self, project, timestamp):
         return filter(
             lambda (key, value): value > 0,  # a zero quota means "no quota"
             (
-                (self._get_project_key(project), self.get_project_quota(project)),
-                (self._get_organization_key(project.organization), self.get_organization_quota(project.organization)),
+                (self._get_project_key(project, timestamp), self.get_project_quota(project)),
+                (self._get_organization_key(project.organization, timestamp), self.get_organization_quota(project.organization)),
             )
         )
 
     def is_rate_limited(self, project):
+        timestamp = time.time()
+
         # If there are no quotas to actually check, skip the trip to the database.
-        quotas = self._get_quotas(project)
+        quotas = self._get_quotas(project, timestamp)
         if not quotas:
             return NotRateLimited
 
-        keys, args = zip(*quotas)
-        client = self.cluster.get_local_client_for_key(self._get_organization_key(project.organization))
+        # interval start + duration + grace period
+        expiry = ((timestamp // self.interval) * self.interval) + self.interval + self.grace
+
+        keys = []
+        args = []
+        for key, limit in quotas:
+            keys.append(keys)
+            args.extend((limit, expiry))
+
+        client = self.cluster.get_local_client_for_key(str(project.organization.pk))
         if any(is_rate_limited(keys, args, client=client)):
             return RateLimited(retry_after=self.get_time_remaining())
         else:
             return NotRateLimited
 
     def get_time_remaining(self):
-        return int(self.ttl - (time.time() - int(time.time() / self.ttl) * self.ttl))
+        # interval start + duration - current time
+        timestamp = time.time()
+        return ((timestamp // self.interval) * self.interval) + self.interval - timestamp
 
-    def _get_project_key(self, project):
-        return 'quota:p:%s:%s' % (project.id, int(time.time() / self.ttl))
+    def _get_project_key(self, project, timestamp):
+        return 'quota:p:%s:%s' % (project.id, timestamp // self.interval)
 
-    def _get_organization_key(self, organization):
-        return 'quota:o:%s:%s' % (organization.id, int(time.time() / self.ttl))
+    def _get_organization_key(self, organization, timestamp):
+        return 'quota:o:%s:%s' % (organization.id, timestamp // self.interval)
diff --git a/tests/sentry/quotas/redis/tests.py b/tests/sentry/quotas/redis/tests.py
index 10df573373..45873b1003 100644
--- a/tests/sentry/quotas/redis/tests.py
+++ b/tests/sentry/quotas/redis/tests.py
@@ -2,13 +2,14 @@
 
 from __future__ import absolute_import
 
-import mock
+import time
 
+import mock
+from exam import fixture, patcher
 from redis.client import (
     Script,
     StrictRedis,
 )
-from exam import fixture, patcher
 
 from sentry.quotas.redis import (
     IS_RATE_LIMITED_SCRIPT,
@@ -18,23 +19,28 @@ from sentry.testutils import TestCase
 
 
 def test_is_rate_limited_script():
+    now = int(time.time())
+
     client = StrictRedis(db=9)
     script = Script(client, IS_RATE_LIMITED_SCRIPT)
 
     # The item should not be rate limited by either key.
-    assert map(bool, script(('foo', 'bar'), (1, 2))) == [False, False]
+    assert map(bool, script(('foo', 'bar'), (1, now + 60, 2, now + 120))) == [False, False]
 
     # The item should be rate limited by the first key (1).
-    assert map(bool, script(('foo', 'bar'), (1, 2))) == [True, False]
+    assert map(bool, script(('foo', 'bar'), (1, now + 60, 2, now + 120))) == [True, False]
 
     # The item should still be rate limited by the first key (1), but *not*
     # rate limited by the second key (2) even though this is the third time
     # we've checked the quotas. This ensures items that are rejected by a lower
     # quota don't affect unrelated items that share a parent quota.
-    assert map(bool, script(('foo', 'bar'), (1, 2))) == [True, False]
+    assert map(bool, script(('foo', 'bar'), (1, now + 60, 2, now + 120))) == [True, False]
+
+    assert client.get('foo') == '1'
+    assert 59 <= client.ttl('foo') <= 60
 
-    client.get('foo') == '1'
-    client.get('bar') == '1'
+    assert client.get('bar') == '1'
+    assert 119 <= client.ttl('bar') <= 120
 
 
 class RedisQuotaTest(TestCase):
@@ -64,14 +70,15 @@ class RedisQuotaTest(TestCase):
 
     def test_skips_unset_quotas(self):
         # This assumes ``get_*_quota`` methods are mocked.
-        assert set(self.quota._get_quotas(self.project)) == set()
+        assert set(self.quota._get_quotas(self.project, time.time())) == set()
 
     def test_uses_defined_quotas(self):
+        timestamp = time.time()
         self.get_project_quota.return_value = 200
         self.get_organization_quota.return_value = 300
-        assert set(self.quota._get_quotas(self.project)) == set((
-            (self.quota._get_project_key(self.project), 200),
-            (self.quota._get_organization_key(self.project.organization), 300),
+        assert set(self.quota._get_quotas(self.project, timestamp)) == set((
+            (self.quota._get_project_key(self.project, timestamp), 200),
+            (self.quota._get_organization_key(self.project.organization, timestamp), 300),
         ))
 
     @mock.patch('sentry.quotas.redis.is_rate_limited')

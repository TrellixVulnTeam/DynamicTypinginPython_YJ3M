commit 7de36a45a39c99581517cc7c938a656139e18b42
Author: Alex Hofsteede <alex@hofsteede.com>
Date:   Thu Apr 18 14:45:25 2019 -0700

    ref: Allow loading of SnubaEvents with minimal properties. (#12838)
    
    ref: Allow loading of SnubaEvents with minimal properties.
    
    In order to cut down on duplicated work. Practicallly speaking there
    will be 2 scenarios:
    
    1. You only need a lightweight version of the event (you are using
    `SimpleEventSerializer`) so you can find/load the events from snuba
    using `SnubaEvent.selected_columns` and serialize it using
    `SimpleEventSerializer` and nodestore is never touched. This is the fast
    path.
    
    2. You know you are going to need to output the entire event body (you
    are using the default `EventSerializer`) so only load the minimal set of
    columns from snuba needed to resolve the node id, and fetch everything
    else from nodestore

diff --git a/src/sentry/api/endpoints/project_events.py b/src/sentry/api/endpoints/project_events.py
index 244df68c27..5c35cf6c17 100644
--- a/src/sentry/api/endpoints/project_events.py
+++ b/src/sentry/api/endpoints/project_events.py
@@ -71,7 +71,7 @@ class ProjectEventsEndpoint(ProjectEndpoint):
             end=now,
             conditions=conditions,
             filter_keys={'project_id': [project.id]},
-            selected_columns=SnubaEvent.selected_columns,
+            selected_columns=SnubaEvent.minimal_columns,
             orderby='-timestamp',
             referrer='api.project-events',
         )
diff --git a/src/sentry/models/event.py b/src/sentry/models/event.py
index 9370a8b3cd..ffda0c200a 100644
--- a/src/sentry/models/event.py
+++ b/src/sentry/models/event.py
@@ -80,6 +80,10 @@ class EventDict(CanonicalKeyDict):
 
 
 class EventCommon(object):
+    """
+    Methods and properties common to both Event and SnubaEvent.
+    """
+
     @classmethod
     def generate_node_id(cls, project_id, event_id):
         """
@@ -90,7 +94,7 @@ class EventCommon(object):
         """
         return md5('{}:{}'.format(project_id, event_id)).hexdigest()
 
-    # TODO (alex) We need a better way to cache these properties. functools32
+    # TODO (alex) We need a better way to cache these properties.  functools32
     # doesn't quite do the trick as there is a reference bug with unsaved
     # models. But the current _group_cache thing is also clunky because these
     # properties need to be stripped out in __getstate__.
@@ -315,7 +319,6 @@ class EventCommon(object):
 
     def get_environment(self):
         from sentry.models import Environment
-
         if not hasattr(self, '_environment_cache'):
             self._environment_cache = Environment.objects.get(
                 organization_id=self.project.organization_id,
@@ -423,29 +426,35 @@ class SnubaEvent(EventCommon):
         as a regular Event.
     """
 
-    # The list of columns that we should request from snuba to be able to fill
-    # out the object.
-    selected_columns = [
+    # The minimal list of columns we need to get from snuba to bootstrap an
+    # event. If the client is planning on loading the entire event body from
+    # nodestore anyway, we may as well only fetch the minimum from snuba to
+    # avoid duplicated work.
+    minimal_columns = [
         'event_id',
+        'group_id',
         'project_id',
+        'timestamp',
+    ]
+
+    # A list of all useful columns we can get from snuba.
+    selected_columns = minimal_columns + [
+        'culprit',
+        'location',
         'message',
+        'platform',
         'title',
         'type',
-        'location',
-        'culprit',
-        'timestamp',
-        'group_id',
-        'platform',
 
         # Required to provide snuba-only tags
         'tags.key',
         'tags.value',
 
         # Required to provide snuba-only 'user' interface
+        'email',
+        'ip_address',
         'user_id',
         'username',
-        'ip_address',
-        'email',
     ]
 
     objects = SnubaEventManager()
@@ -453,12 +462,12 @@ class SnubaEvent(EventCommon):
     __repr__ = sane_repr('project_id', 'group_id')
 
     @classmethod
-    def get_event(cls, project_id, event_id):
+    def get_event(cls, project_id, event_id, snuba_cols=selected_columns):
         from sentry.utils import snuba
         result = snuba.raw_query(
             start=datetime.utcfromtimestamp(0),  # will be clamped to project retention
             end=datetime.utcnow(),  # will be clamped to project retention
-            selected_columns=cls.selected_columns,
+            selected_columns=snuba_cols,
             filter_keys={
                 'event_id': [event_id],
                 'project_id': [project_id],
@@ -470,15 +479,42 @@ class SnubaEvent(EventCommon):
         return None
 
     def __init__(self, snuba_values):
-        assert set(snuba_values.keys()) == set(self.selected_columns)
+        """
+            When initializing a SnubaEvent, think about the attributes you
+            might need to access on it. If you only need a few properties, and
+            they are all available in snuba, then you should use
+            `SnubaEvent.selected_colums` (or a subset depending on your needs)
+            But if you know you are going to need the entire event body anyway
+            (which requires a nodestore lookup) you may as well just initialize
+            the event with `SnubaEvent.minimal_colums` and let the rest of of
+            the attributes come from nodestore.
+        """
+        assert all(k in snuba_values for k in SnubaEvent.minimal_columns)
 
-        self.__dict__ = snuba_values
+        # self.snuba_data is a dict of all the stuff we got from snuba
+        self.snuba_data = snuba_values
 
-        # This should be lazy loaded and will only be accessed if we access any
-        # properties on self.data
-        node_id = SnubaEvent.generate_node_id(self.project_id, self.event_id)
+        # self.data is a (lazy) dict of everything we got from nodestore
+        node_id = SnubaEvent.generate_node_id(
+            self.snuba_data['project_id'],
+            self.snuba_data['event_id'])
         self.data = NodeData(None, node_id, data=None)
 
+    def __getattr__(self, name):
+        """
+        Depending on what snuba data this event was initialized with, we may
+        have the data available to return, or we may have to look in the
+        `data` dict (which would force a nodestore load). All unresolved
+        self.foo type accesses will come through here.
+        """
+        if name in ('_project_cache', '_group_cache', '_environment_cache'):
+            raise AttributeError()
+
+        if name in self.snuba_data:
+            return self.snuba_data[name]
+        else:
+            return self.data[name]
+
     # ============================================
     # Snuba-only implementations of properties that
     # would otherwise require nodestore data.
@@ -490,14 +526,15 @@ class SnubaEvent(EventCommon):
         the nodestore event body. This might be useful for implementing
         tag deletions without having to rewrite nodestore blobs.
         """
-        keys = getattr(self, 'tags.key', None)
-        values = getattr(self, 'tags.value', None)
-        if keys and values and len(keys) == len(values):
-            return sorted(zip(keys, values))
-        return []
-
-    def get_event_type(self):
-        return self.__dict__.get('type', 'default')
+        if 'tags.key' in self.snuba_data and 'tags.value' in self.snuba_data:
+            keys = getattr(self, 'tags.key')
+            values = getattr(self, 'tags.value')
+            if keys and values and len(keys) == len(values):
+                return sorted(zip(keys, values))
+            else:
+                return []
+        else:
+            return super(SnubaEvent, self).tags
 
     def get_minimal_user(self):
         from sentry.interfaces.user import User
@@ -508,23 +545,37 @@ class SnubaEvent(EventCommon):
             'ip_address': self.ip_address,
         })
 
-    # These should all have been normalized to the correct values on
-    # the way in to snuba, so we should be able to just use them as is.
+    # If the data for these is availablle from snuba, we asssume
+    # it was already normalized on the way in and we can just return
+    # it, otherwise we defer to EventCommon implementation.
+    def get_event_type(self):
+        if 'type' in self.snuba_data:
+            return self.snuba_data['type']
+        return super(SnubaEvent, self).get_event_type()
+
     @property
     def ip_address(self):
-        return self.__dict__['ip_address']
+        if 'ip_address' in self.snuba_data:
+            return self.snuba_data['ip_address']
+        return super(SnubaEvent, self).ip_address
 
     @property
     def title(self):
-        return self.__dict__['title']
+        if 'title' in self.snuba_data:
+            return self.snuba_data['title']
+        return super(SnubaEvent, self).title
 
     @property
     def culprit(self):
-        return self.__dict__['culprit']
+        if 'culprit' in self.snuba_data:
+            return self.snuba_data['culprit']
+        return super(SnubaEvent, self).culprit
 
     @property
     def location(self):
-        return self.__dict__['location']
+        if 'location' in self.snuba_data:
+            return self.snuba_data['location']
+        return super(SnubaEvent, self).location
 
     # ============================================
     # Snuba implementations of django Fields
@@ -656,6 +707,7 @@ class Event(EventCommon, Model):
         # pickle a CanonicalKeyView which old sentry workers do not know
         # about
         state.pop('_project_cache', None)
+        state.pop('_environment_cache', None)
         state.pop('_group_cache', None)
         state.pop('interfaces', None)
 
diff --git a/tests/sentry/api/serializers/test_event.py b/tests/sentry/api/serializers/test_event.py
index a42130d8d6..fb4e008b3b 100644
--- a/tests/sentry/api/serializers/test_event.py
+++ b/tests/sentry/api/serializers/test_event.py
@@ -228,7 +228,7 @@ class SnubaEventSerializerTest(TestCase):
 
         # Make sure we didn't have to call out to Nodestore to get the data
         # required to serialize this event and the NodeData is still empty.
-        assert event.data._node_data is None, "Node data was populated"
+        assert event.data._node_data is None, "SimpleEventSerializer should not load Nodestore data."
 
         assert result['eventID'] == event.event_id
         assert result['projectID'] == six.text_type(event.project_id)
diff --git a/tests/snuba/models/test_event.py b/tests/snuba/models/test_event.py
index 67d8cf457b..f1693be861 100644
--- a/tests/snuba/models/test_event.py
+++ b/tests/snuba/models/test_event.py
@@ -73,7 +73,14 @@ class SnubaEventTest(TestCase, SnubaTestCase):
         assert event.event_id == self.event_id
         assert event.group.id == self.proj1group1.id
         assert event.project.id == self.proj1.id
-        # And the event data payload from nodestore
+        assert event._project_cache == self.proj1
+        # That shouldn't have triggered a nodestore load yet
+        assert event.data._node_data is None
+        # But after we ask for something that's not in snuba
+        event.get_hashes()
+        # We should have populated the NodeData
+        assert event.data._node_data is not None
+        # And the full user should be in there.
         assert event.data['user']['id'] == u'user1'
 
     def test_same(self):
@@ -92,3 +99,31 @@ class SnubaEventTest(TestCase, SnubaTestCase):
         del django_serialized['id']
         del snuba_serialized['id']
         assert django_serialized == snuba_serialized
+
+    def test_minimal(self):
+        """
+        Test that a SnubaEvent that only loads minimal data from snuba
+        can still be serialized completely by falling back to nodestore data.
+        """
+        django_event = Event.objects.get(project_id=self.proj1.id, event_id=self.event_id)
+        snuba_event = SnubaEvent.get_event(
+            self.proj1.id,
+            self.event_id,
+            snuba_cols=SnubaEvent.minimal_columns)
+
+        django_serialized = serialize(django_event)
+        snuba_serialized = serialize(snuba_event)
+        del django_serialized['id']
+        del snuba_serialized['id']
+        assert django_serialized == snuba_serialized
+
+    def test_bind_nodes(self):
+        """
+        Test that bind_nodes works on snubaevents to populate their
+        NodeDatas.
+        """
+        event = SnubaEvent.get_event(self.proj1.id, self.event_id)
+        assert event.data._node_data is None
+        Event.objects.bind_nodes([event], 'data')
+        assert event.data._node_data is not None
+        assert event.data['user']['id'] == u'user1'

commit 7abbe10307caacd8b2e7afde3ebb70ee6c558bee
Author: ted kaemming <t.kaemming+github@gmail.com>
Date:   Tue Aug 9 18:13:16 2016 -0700

    Make TSDB bounds behavior consistent across all methods. (#3860)

diff --git a/src/sentry/tsdb/base.py b/src/sentry/tsdb/base.py
index 7db54b03fb..beb38f2fbb 100644
--- a/src/sentry/tsdb/base.py
+++ b/src/sentry/tsdb/base.py
@@ -8,6 +8,7 @@ sentry.tsdb.base
 from __future__ import absolute_import
 
 import six
+from datetime import timedelta
 
 from django.conf import settings
 from django.utils import timezone
@@ -121,27 +122,42 @@ class BaseTSDB(object):
         """
         num_seconds = int(to_timestamp(end_timestamp)) - int(to_timestamp(start_timestamp))
 
-        # calculate the highest rollup within time range
+        # This loop attempts to find the smallest possible rollup that will
+        # contain both the start and end timestamps. ``self.rollups`` is
+        # ordered from the highest resolution (smallest interval) to lowest
+        # resolution (largest interval.)
+        # XXX: There is a bug here, since this function assumes that the end
+        # timestamp is always equal to or greater than the current time. If the
+        # time range is shifted far enough into the past (e.g. a 30 second
+        # window, retrieved several days after it's occurrence), this can
+        # return a rollup that has already been evicted due to TTL, even if a
+        # lower resolution representation of the range exists.
         for rollup, samples in self.rollups:
             if rollup * samples >= num_seconds:
                 return rollup
+
+        # If nothing actually matches the requested range, just return the
+        # lowest resolution interval.
         return self.rollups[-1][0]
 
     def get_optimal_rollup_series(self, start, end=None, rollup=None):
         if end is None:
             end = timezone.now()
 
-        # NOTE: "optimal" here means "able to most closely reflect the upper
-        # and lower bounds", not "able to construct the most efficient query"
         if rollup is None:
             rollup = self.get_optimal_rollup(start, end)
 
-        series = [self.normalize_to_epoch(start, rollup)]
-        end_ts = int(to_timestamp(end))
-        while series[-1] + rollup < end_ts:
-            series.append(series[-1] + rollup)
+        # This attempts to create a range with a duration as close as possible
+        # to the requested interval using the requested (or inferred) rollup
+        # resolution. This result always includes the ``end`` timestamp, but
+        # may not include the ``start`` timestamp.
+        series = []
+        timestamp = end
+        while timestamp >= start:
+            series.append(self.normalize_to_epoch(timestamp, rollup))
+            timestamp = timestamp - timedelta(seconds=rollup)
 
-        return rollup, series
+        return rollup, sorted(series)
 
     def calculate_expiry(self, rollup, samples, timestamp):
         """
@@ -175,8 +191,6 @@ class BaseTSDB(object):
         """
         To get a range of data for group ID=[1, 2, 3]:
 
-        Both ``start`` and ``end`` are inclusive.
-
         Returns a mapping of key => [(timestamp, count), ...].
 
         >>> now = timezone.now()
diff --git a/src/sentry/tsdb/inmemory.py b/src/sentry/tsdb/inmemory.py
index a8eac563c3..820e660677 100644
--- a/src/sentry/tsdb/inmemory.py
+++ b/src/sentry/tsdb/inmemory.py
@@ -10,9 +10,10 @@ from __future__ import absolute_import
 import six
 
 from collections import Counter, defaultdict
-from datetime import timedelta
+
 from django.utils import timezone
 
+from sentry.utils.dates import to_datetime, to_timestamp
 from sentry.tsdb.base import BaseTSDB
 
 
@@ -35,23 +36,15 @@ class InMemoryTSDB(BaseTSDB):
             self.data[model][key][norm_epoch] += count
 
     def get_range(self, model, keys, start, end, rollup=None):
-        normalize_to_epoch = self.normalize_to_epoch
-        normalize_to_rollup = self.normalize_to_rollup
-
-        if rollup is None:
-            rollup = self.get_optimal_rollup(start, end)
+        rollup, series = self.get_optimal_rollup_series(start, end, rollup)
 
         results = []
-        timestamp = end
-        while timestamp >= start:
-            real_epoch = normalize_to_epoch(timestamp, rollup)
-            norm_epoch = normalize_to_rollup(timestamp, rollup)
+        for timestamp in map(to_datetime, series):
+            norm_epoch = self.normalize_to_rollup(timestamp, rollup)
 
             for key in keys:
                 value = self.data[model][key][norm_epoch]
-                results.append((real_epoch, key, value))
-
-            timestamp = timestamp - timedelta(seconds=rollup)
+                results.append((to_timestamp(timestamp), key, value))
 
         results_by_key = defaultdict(dict)
         for epoch, key, count in results:
diff --git a/src/sentry/tsdb/redis.py b/src/sentry/tsdb/redis.py
index dc7a974dac..ba65094a3c 100644
--- a/src/sentry/tsdb/redis.py
+++ b/src/sentry/tsdb/redis.py
@@ -16,7 +16,7 @@ import uuid
 
 from binascii import crc32
 from collections import defaultdict, namedtuple
-from datetime import timedelta
+
 from django.utils import timezone
 from hashlib import md5
 from pkg_resources import resource_string
@@ -24,7 +24,7 @@ from redis.client import Script
 from six.moves import reduce
 
 from sentry.tsdb.base import BaseTSDB
-from sentry.utils.dates import to_timestamp
+from sentry.utils.dates import to_datetime, to_timestamp
 from sentry.utils.redis import check_cluster_versions, get_cluster_from_options
 from sentry.utils.versioning import Version
 
@@ -179,34 +179,32 @@ class RedisTSDB(BaseTSDB):
         """
         To get a range of data for group ID=[1, 2, 3]:
 
-        Start and end are both inclusive.
-
         >>> now = timezone.now()
         >>> get_keys(TimeSeriesModel.group, [1, 2, 3],
         >>>          start=now - timedelta(days=1),
         >>>          end=now)
         """
-        normalize_to_epoch = self.normalize_to_epoch
-        normalize_to_rollup = self.normalize_to_rollup
-        make_key = self.make_counter_key
-
-        if rollup is None:
-            rollup = self.get_optimal_rollup(start, end)
+        rollup, series = self.get_optimal_rollup_series(start, end, rollup)
+        series = map(to_datetime, series)
 
         results = []
-        timestamp = end
         with self.cluster.map() as client:
-            while timestamp >= start:
-                real_epoch = normalize_to_epoch(timestamp, rollup)
-                norm_epoch = normalize_to_rollup(timestamp, rollup)
-
-                for key in keys:
-                    model_key = self.get_model_key(key)
-                    hash_key = make_key(model, norm_epoch, model_key)
-                    results.append((real_epoch, key,
-                                    client.hget(hash_key, model_key)))
-
-                timestamp = timestamp - timedelta(seconds=rollup)
+            for key in keys:
+                model_key = self.get_model_key(key)
+                for timestamp in series:
+                    hash_key = self.make_counter_key(
+                        model,
+                        self.normalize_to_rollup(
+                            timestamp,
+                            rollup
+                        ),
+                        model_key,
+                    )
+                    results.append((
+                        to_timestamp(timestamp),
+                        key,
+                        client.hget(hash_key, model_key)
+                    ))
 
         results_by_key = defaultdict(dict)
         for epoch, key, count in results:
diff --git a/tests/sentry/tsdb/test_base.py b/tests/sentry/tsdb/test_base.py
index c626acdbd0..d394a042de 100644
--- a/tests/sentry/tsdb/test_base.py
+++ b/tests/sentry/tsdb/test_base.py
@@ -1,11 +1,13 @@
-from __future__ import absolute_import
+from __future__ import absolute_import, division
 
+import mock
 import pytz
 
 from datetime import datetime, timedelta
 
 from sentry.testutils import TestCase
 from sentry.tsdb.base import BaseTSDB, ONE_MINUTE, ONE_HOUR, ONE_DAY
+from sentry.utils.dates import to_timestamp
 
 
 class BaseTSDBTest(TestCase):
@@ -45,3 +47,64 @@ class BaseTSDBTest(TestCase):
         timestamp = datetime(2013, 5, 18, 15, 13, 58, 132928, tzinfo=pytz.UTC)
         result = self.tsdb.calculate_expiry(10, 30, timestamp)
         assert result == 1368890330
+
+    @mock.patch('django.utils.timezone.now')
+    def test_get_optimal_rollup_series_aligned_intervals(self, now):
+        now.return_value = datetime(2016, 8, 1, tzinfo=pytz.utc)
+
+        start = now() - timedelta(seconds=30)
+        assert self.tsdb.get_optimal_rollup_series(start) == (
+            10,
+            [to_timestamp(start + timedelta(seconds=10) * i) for i in xrange(4)],
+        )
+
+        start = now() - timedelta(minutes=30)
+        assert self.tsdb.get_optimal_rollup_series(start) == (
+            ONE_MINUTE,
+            [to_timestamp(start + timedelta(minutes=1) * i) for i in xrange(31)],
+        )
+
+        start = now() - timedelta(hours=5)
+        assert self.tsdb.get_optimal_rollup_series(start) == (
+            ONE_HOUR,
+            [to_timestamp(start + timedelta(hours=1) * i) for i in xrange(6)],
+        )
+
+        start = now() - timedelta(days=7)
+        assert self.tsdb.get_optimal_rollup_series(start) == (
+            ONE_DAY,
+            [to_timestamp(start + timedelta(hours=24) * i) for i in xrange(8)],
+        )
+
+    @mock.patch('django.utils.timezone.now')
+    def test_get_optimal_rollup_series_offset_intervals(self, now):
+        # This test is a funny one (notice it doesn't return a range that
+        # includes the start position.) This occurs because the algorithm for
+        # determining the series to be returned will attempt to return the same
+        # duration of time as represented by the start and end timestamps, but
+        # doesn't necessarily return data *from that specific interval* (the
+        # end timestamp is always included.)
+
+        now.return_value = datetime(2016, 8, 1, 0, 0, 15, tzinfo=pytz.utc)
+        start = now() - timedelta(seconds=19)
+        assert self.tsdb.get_optimal_rollup_series(start, rollup=10) == (
+            10,
+            [
+                to_timestamp(datetime(2016, 8, 1, 0, 0, 0, tzinfo=pytz.utc)),
+                to_timestamp(datetime(2016, 8, 1, 0, 0, 10, tzinfo=pytz.utc)),
+            ]
+        )
+
+        now.return_value = datetime(2016, 8, 1, 0, 0, 30, tzinfo=pytz.utc)
+        start = now() - timedelta(seconds=ONE_MINUTE - 1)
+        assert self.tsdb.get_optimal_rollup_series(start, rollup=ONE_MINUTE) == (
+            ONE_MINUTE,
+            [to_timestamp(datetime(2016, 8, 1, 0, 0, 0, tzinfo=pytz.utc))]
+        )
+
+        now.return_value = datetime(2016, 8, 1, 12, tzinfo=pytz.utc)
+        start = now() - timedelta(seconds=ONE_DAY - 1)
+        assert self.tsdb.get_optimal_rollup_series(start, rollup=ONE_DAY) == (
+            ONE_DAY,
+            [to_timestamp(datetime(2016, 8, 1, 0, tzinfo=pytz.utc))]
+        )

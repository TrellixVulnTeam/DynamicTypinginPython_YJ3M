commit 2137d40589cb3446400a271eab1fc354ddba6e97
Author: William Mak <william@wmak.io>
Date:   Thu Feb 20 19:42:30 2020 -0500

    feature(discover) - Allow multiple yaxis for event stats
    
    - This allows the event stats endpoint to return multiple axis values
    - I tried to keep the keys in the data response to match what the
      requested yAxis are.
    - This won't impact current event-stats calls at all since they will
      default to the current format since they only have one yAxis.

diff --git a/src/sentry/api/endpoints/organization_events_stats.py b/src/sentry/api/endpoints/organization_events_stats.py
index 6d2f2f5617..69dbff251b 100644
--- a/src/sentry/api/endpoints/organization_events_stats.py
+++ b/src/sentry/api/endpoints/organization_events_stats.py
@@ -8,7 +8,12 @@ from rest_framework.exceptions import ParseError
 
 from sentry import features
 from sentry.api.bases import OrganizationEventsEndpointBase, OrganizationEventsError, NoProjects
-from sentry.api.event_search import resolve_field_list, InvalidSearchQuery
+from sentry.api.event_search import (
+    resolve_field_list,
+    InvalidSearchQuery,
+    get_aggregate_alias,
+    AGGREGATE_PATTERN,
+)
 from sentry.api.serializers.snuba import SnubaTSResultSerializer
 from sentry.discover.utils import transform_aliases_and_query
 from sentry.snuba import discover
@@ -22,24 +27,23 @@ class OrganizationEventsStatsEndpoint(OrganizationEventsEndpointBase):
             return self.get_v1_results(request, organization)
 
         try:
-            column = request.GET.get("yAxis", "count()")
+            columns = request.GET.getlist("yAxis", ["count()"])
             rollup = self.get_rollup(request)
             # Backwards compatibility for incidents which uses the old
             # column aliases as it straddles both versions of events/discover.
             # We will need these aliases until discover2 flags are enabled for all
             # users.
-            if column == "user_count":
-                column = "count_unique(user)"
-            elif column == "event_count":
-                column = "count()"
-            elif column == "rpm()":
-                column = "rpm(%d)" % rollup
-            elif column == "rps()":
-                column = "rps(%d)" % rollup
+            column_map = {
+                "user_count": "count_unique(user)",
+                "event_count": "count()",
+                "rpm()": "rpm(%d)" % rollup,
+                "rps()": "rps(%d)" % rollup,
+            }
+            query_columns = [column_map.get(column, column) for column in columns]
 
             params = self.get_filter_params(request, organization)
             result = discover.timeseries_query(
-                selected_columns=[column],
+                selected_columns=query_columns,
                 query=request.GET.get("query"),
                 params=params,
                 rollup=rollup,
@@ -51,7 +55,17 @@ class OrganizationEventsStatsEndpoint(OrganizationEventsEndpointBase):
         except InvalidSearchQuery as err:
             raise ParseError(detail=six.text_type(err))
         serializer = SnubaTSResultSerializer(organization, None, request.user)
-        return Response(serializer.serialize(result), status=200)
+        if len(columns) > 1:
+            # Return with requested yAxis as the key
+            data = {
+                column: serializer.serialize(
+                    result, get_aggregate_alias(AGGREGATE_PATTERN.search(query_column))
+                )
+                for column, query_column in zip(columns, query_columns)
+            }
+        else:
+            data = serializer.serialize(result)
+        return Response(data, status=200)
 
     def get_rollup(self, request):
         interval = parse_stats_period(request.GET.get("interval", "1h"))
diff --git a/src/sentry/api/serializers/snuba.py b/src/sentry/api/serializers/snuba.py
index bceb1c78e6..24685a8f51 100644
--- a/src/sentry/api/serializers/snuba.py
+++ b/src/sentry/api/serializers/snuba.py
@@ -290,7 +290,7 @@ class SnubaTSResultSerializer(BaseSnubaSerializer):
     Serializer for time-series Snuba data.
     """
 
-    def serialize(self, result):
+    def serialize(self, result, column="count"):
         data = [
             (key, list(group))
             for key, group in itertools.groupby(result.data["data"], key=lambda r: r["time"])
@@ -303,7 +303,7 @@ class SnubaTSResultSerializer(BaseSnubaSerializer):
         for k, v in data:
             row = []
             for r in v:
-                item = {"count": r.get("count", 0)}
+                item = {"count": r.get(column, 0)}
                 if self.lookup:
                     value = value_from_row(r, self.lookup.columns)
                     item[self.lookup.name] = (attrs.get(value),)
@@ -313,6 +313,6 @@ class SnubaTSResultSerializer(BaseSnubaSerializer):
         res = {"data": zerofill(rv, result.start, result.end, result.rollup)}
 
         if result.data.get("totals"):
-            res["totals"] = {"count": result.data["totals"]["count"]}
+            res["totals"] = {"count": result.data["totals"][column]}
 
         return res
diff --git a/tests/snuba/api/endpoints/test_organization_events_stats.py b/tests/snuba/api/endpoints/test_organization_events_stats.py
index d7d228bc0a..da72bf035d 100644
--- a/tests/snuba/api/endpoints/test_organization_events_stats.py
+++ b/tests/snuba/api/endpoints/test_organization_events_stats.py
@@ -2,6 +2,7 @@ from __future__ import absolute_import
 
 import six
 import uuid
+import mock
 
 from datetime import timedelta
 
@@ -335,7 +336,9 @@ class OrganizationEventsStatsEndpointTest(APITestCase, SnubaTestCase):
                     data={
                         "event_id": six.binary_type(uuid.uuid1()),
                         "message": "very bad",
-                        "timestamp": iso_format(self.day_ago + timedelta(minutes=minute, seconds=second)),
+                        "timestamp": iso_format(
+                            self.day_ago + timedelta(minutes=minute, seconds=second)
+                        ),
                         "fingerprint": ["group1"],
                         "tags": {"sentry:user": self.user.email},
                     },
@@ -372,7 +375,9 @@ class OrganizationEventsStatsEndpointTest(APITestCase, SnubaTestCase):
                     data={
                         "event_id": six.binary_type(uuid.uuid1()),
                         "message": "very bad",
-                        "timestamp": iso_format(self.day_ago + timedelta(minutes=minute, seconds=second)),
+                        "timestamp": iso_format(
+                            self.day_ago + timedelta(minutes=minute, seconds=second)
+                        ),
                         "fingerprint": ["group1"],
                         "tags": {"sentry:user": self.user.email},
                     },
@@ -531,3 +536,44 @@ class OrganizationEventsStatsEndpointTest(APITestCase, SnubaTestCase):
                 },
             )
         assert response.status_code == 200
+
+    def test_simple_multiple_yaxis(self):
+        with self.feature("organizations:discover-basic"):
+            response = self.client.get(
+                self.url,
+                data={
+                    "start": iso_format(self.day_ago),
+                    "end": iso_format(self.day_ago + timedelta(hours=1, minutes=59)),
+                    "interval": "1h",
+                    "yAxis": ["user_count", "event_count"],
+                },
+                format="json",
+            )
+
+        assert response.status_code == 200, response.content
+        assert [attrs for time, attrs in response.data["user_count"]["data"]] == [
+            [],
+            [{"count": 1}],
+            [{"count": 1}],
+        ]
+        assert [attrs for time, attrs in response.data["event_count"]["data"]] == [
+            [],
+            [{"count": 1}],
+            [{"count": 2}],
+        ]
+
+    @mock.patch("sentry.snuba.discover.timeseries_query", return_value={})
+    def test_multiple_yaxis_only_one_query(self, mock_query):
+        with self.feature("organizations:discover-basic"):
+            self.client.get(
+                self.url,
+                data={
+                    "start": iso_format(self.day_ago),
+                    "end": iso_format(self.day_ago + timedelta(hours=1, minutes=59)),
+                    "interval": "1h",
+                    "yAxis": ["user_count", "event_count", "rpm()", "rps()"],
+                },
+                format="json",
+            )
+
+        assert mock_query.call_count == 1

commit d8b4c424bfa7a294d74bd557035393635290ae6d
Author: MeredithAnya <meredith@getsentry.com>
Date:   Fri Apr 26 14:31:55 2019 -0700

    ref(app-platform): Add ability to filter sentry apps based on status (#12879)
    
    * can filter on status for sentry apps

diff --git a/src/sentry/api/endpoints/sentry_apps.py b/src/sentry/api/endpoints/sentry_apps.py
index 420b1382fb..ea6dfa74dd 100644
--- a/src/sentry/api/endpoints/sentry_apps.py
+++ b/src/sentry/api/endpoints/sentry_apps.py
@@ -2,10 +2,12 @@ from __future__ import absolute_import
 
 from rest_framework.response import Response
 
+from sentry.auth.superuser import is_active_superuser
 from sentry.api.bases import SentryAppsBaseEndpoint
 from sentry.api.paginator import OffsetPaginator
 from sentry.api.serializers import serialize
 from sentry.api.serializers.rest_framework import SentryAppSerializer
+from sentry.constants import SentryAppStatus
 from sentry.features.helpers import requires_feature
 from sentry.mediators.sentry_apps import Creator
 from sentry.models import SentryApp
@@ -13,9 +15,30 @@ from sentry.models import SentryApp
 
 class SentryAppsEndpoint(SentryAppsBaseEndpoint):
     def get(self, request):
+        status = request.GET.get('status')
+
+        if status == 'published':
+            queryset = SentryApp.objects.filter(status=SentryAppStatus.PUBLISHED)
+
+        elif status == 'unpublished':
+            if is_active_superuser(request):
+                queryset = SentryApp.objects.filter(
+                    status=SentryAppStatus.UNPUBLISHED
+                )
+            else:
+                queryset = SentryApp.objects.filter(
+                    status=SentryAppStatus.UNPUBLISHED,
+                    owner__in=request.user.get_orgs(),
+                )
+        else:
+            if is_active_superuser(request):
+                queryset = SentryApp.objects.all()
+            else:
+                queryset = SentryApp.objects.filter(status=SentryAppStatus.PUBLISHED)
+
         return self.paginate(
             request=request,
-            queryset=SentryApp.visible_for_user(request),
+            queryset=queryset,
             order_by='-date_added',
             paginator_cls=OffsetPaginator,
             on_results=lambda x: serialize(x, request.user),
diff --git a/src/sentry/static/sentry/app/views/organizationIntegrations/index.jsx b/src/sentry/static/sentry/app/views/organizationIntegrations/index.jsx
index 250a5419ce..54dd997480 100644
--- a/src/sentry/static/sentry/app/views/organizationIntegrations/index.jsx
+++ b/src/sentry/static/sentry/app/views/organizationIntegrations/index.jsx
@@ -43,7 +43,7 @@ class OrganizationIntegrations extends AsyncComponent {
       ['integrations', `/organizations/${orgId}/integrations/`],
       ['plugins', `/organizations/${orgId}/plugins/`, {query}],
       ['orgOwnedApps', `/organizations/${orgId}/sentry-apps/`],
-      ['publishedApps', '/sentry-apps/'],
+      ['publishedApps', '/sentry-apps/', {status: 'published'}],
       ['appInstalls', `/organizations/${orgId}/sentry-app-installations/`],
     ];
   }
@@ -168,7 +168,13 @@ class OrganizationIntegrations extends AsyncComponent {
 
   renderBody() {
     const {reloading, orgOwnedApps, publishedApps, appInstalls} = this.state;
-    const applications = (publishedApps || []).concat(orgOwnedApps || []);
+    const published = publishedApps || [];
+    // we dont want the app to render twice if its the org that created
+    // the published app.
+    const orgOwned = orgOwnedApps.filter(app => {
+      return !published.find(p => p.slug == app.slug);
+    });
+    const applications = published.concat(orgOwned);
 
     const installedProviders = this.providers
       .filter(p => p.isInstalled)
diff --git a/tests/js/spec/views/settings/organizationIntegrations/index.spec.jsx b/tests/js/spec/views/settings/organizationIntegrations/index.spec.jsx
index d05965957d..7ec55c0ce3 100644
--- a/tests/js/spec/views/settings/organizationIntegrations/index.spec.jsx
+++ b/tests/js/spec/views/settings/organizationIntegrations/index.spec.jsx
@@ -246,6 +246,25 @@ describe('OrganizationIntegrations', () => {
       });
     });
 
+    describe('published and org-owned apps are consolidated', () => {
+      it('renders sentry app once', () => {
+        const publishedApp = {...sentryApp, status: 'published'};
+        Client.addMockResponse({
+          url: `/organizations/${org.slug}/sentry-apps/`,
+          body: [publishedApp],
+        });
+        Client.addMockResponse({
+          url: '/sentry-apps/',
+          body: [publishedApp],
+        });
+        wrapper = mount(
+          <OrganizationIntegrations organization={org} params={params} />,
+          routerContext
+        );
+        expect(wrapper.find('SentryAppInstallations').length).toBe(1);
+      });
+    });
+
     describe('with installed integrations', () => {
       let updatedIntegration;
 
diff --git a/tests/sentry/api/endpoints/test_sentry_apps.py b/tests/sentry/api/endpoints/test_sentry_apps.py
index 86f7845ab8..a219912daf 100644
--- a/tests/sentry/api/endpoints/test_sentry_apps.py
+++ b/tests/sentry/api/endpoints/test_sentry_apps.py
@@ -51,7 +51,6 @@ class GetSentryAppsTest(SentryAppsTest):
 
     def test_users_see_published_apps(self):
         self.login_as(user=self.user)
-
         response = self.client.get(self.url, format='json')
 
         assert response.status_code == 200
@@ -76,6 +75,90 @@ class GetSentryAppsTest(SentryAppsTest):
             }
         } in json.loads(response.content)
 
+    def test_superuser_filter_on_published(self):
+        self.login_as(user=self.superuser, superuser=True)
+        url = u'{}?status=published'.format(self.url)
+        response = self.client.get(url, format='json')
+
+        assert response.status_code == 200
+        assert {
+            'name': self.published_app.name,
+            'author': self.published_app.author,
+            'slug': self.published_app.slug,
+            'scopes': [],
+            'events': [],
+            'status': self.published_app.get_status_display(),
+            'uuid': self.published_app.uuid,
+            'webhookUrl': self.published_app.webhook_url,
+            'redirectUrl': self.published_app.redirect_url,
+            'isAlertable': self.published_app.is_alertable,
+            'clientId': self.published_app.application.client_id,
+            'clientSecret': self.published_app.application.client_secret,
+            'overview': self.published_app.overview,
+            'schema': {},
+            'owner': {
+                'id': self.org.id,
+                'slug': self.org.slug,
+            }
+        } in json.loads(response.content)
+
+        response_uuids = set(o['uuid'] for o in response.data)
+        assert self.unpublished_app.uuid not in response_uuids
+        assert self.unowned_unpublished_app.uuid not in response_uuids
+
+    def test_superuser_filter_on_unpublished(self):
+        self.login_as(user=self.superuser, superuser=True)
+        url = u'{}?status=unpublished'.format(self.url)
+        response = self.client.get(url, format='json')
+
+        assert response.status_code == 200
+        response_uuids = set(o['uuid'] for o in response.data)
+        assert self.unpublished_app.uuid in response_uuids
+        assert self.unowned_unpublished_app.uuid in response_uuids
+        assert self.published_app.uuid not in response_uuids
+
+    def test_user_filter_on_unpublished(self):
+        self.login_as(user=self.user)
+        url = u'{}?status=unpublished'.format(self.url)
+        response = self.client.get(url, format='json')
+
+        assert response.status_code == 200
+        assert {
+            'name': self.unpublished_app.name,
+            'author': self.unpublished_app.author,
+            'slug': self.unpublished_app.slug,
+            'scopes': [],
+            'events': [],
+            'status': self.unpublished_app.get_status_display(),
+            'uuid': self.unpublished_app.uuid,
+            'webhookUrl': self.unpublished_app.webhook_url,
+            'redirectUrl': self.unpublished_app.redirect_url,
+            'isAlertable': self.unpublished_app.is_alertable,
+            'clientId': self.unpublished_app.application.client_id,
+            'clientSecret': self.unpublished_app.application.client_secret,
+            'overview': self.unpublished_app.overview,
+            'schema': {},
+            'owner': {
+                'id': self.org.id,
+                'slug': self.org.slug,
+            }
+        } in json.loads(response.content)
+
+        response_uuids = set(o['uuid'] for o in response.data)
+        assert self.published_app.uuid not in response_uuids
+        assert self.unowned_unpublished_app.uuid not in response_uuids
+
+        def test_user_filter_on_published(self):
+            self.login_as(user=self.user)
+            url = u'{}?status=published'.format(self.url)
+            response = self.client.get(url, format='json')
+
+            assert response.status_code == 200
+            response_uuids = set(o['uuid'] for o in response.data)
+            assert self.published_app.uuid in response_uuids
+            assert self.unpublished_app not in response_uuids
+            assert self.unowned_unpublished_app.uuid not in response_uuids
+
     def test_users_dont_see_unpublished_apps_their_org_owns(self):
         self.login_as(user=self.user)
 

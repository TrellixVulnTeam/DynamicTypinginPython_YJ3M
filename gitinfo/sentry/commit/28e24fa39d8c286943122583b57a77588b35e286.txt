commit 28e24fa39d8c286943122583b57a77588b35e286
Author: Danny Lee <dlee@sentry.io>
Date:   Thu Aug 29 09:47:54 2019 -0700

    fix(app-platform): Fix missing firstRelease in SmartSearchBar (#14460)
    
    Previous behaviour:
    - The `SmartSearchBar` does not recognizes firstRelease.
    
    New behaviour:
    - The `SmartSearchBar` recognizes firstRelease as a valid query token and show the latest 3 Release.shortVersion as autocomplete options.
    - With subsequent keystrokes, the searchbar will query the backend to find release versions which corresponds with the search query.
    
    Additional Changes:
    - Added Reflux store for releases
    
    Ref SEN-852

diff --git a/src/sentry/static/sentry/app/actionCreators/releases.tsx b/src/sentry/static/sentry/app/actionCreators/releases.tsx
new file mode 100644
index 0000000000..6ab3c1d72d
--- /dev/null
+++ b/src/sentry/static/sentry/app/actionCreators/releases.tsx
@@ -0,0 +1,53 @@
+import ReleaseActions from 'app/actions/releaseActions';
+import {addErrorMessage} from 'app/actionCreators/indicator';
+import {t} from 'app/locale';
+import {Client} from 'app/api';
+
+/**
+ * Fetch a subset of releases for an organization or project. To fetch releases
+ * from multiple projects, leave `projectId` as undefined.
+ *
+ * TODO(leedongwei): Replace `any` types.
+ */
+export function fetchReleases(
+  api: Client,
+  orgId: string,
+  project?: string,
+  releaseVersion?: string,
+  pageSize?: number
+): Promise<any> {
+  const url = `/organizations/${orgId}/releases/`;
+  const query: {
+    [key: string]: string | number;
+  } = {};
+
+  if (project) {
+    query.project = project;
+  }
+
+  if (releaseVersion) {
+    query.query = releaseVersion;
+  }
+
+  if (pageSize) {
+    query.per_page = pageSize;
+  }
+
+  ReleaseActions.fetchReleases();
+
+  const promise = api
+    .requestPromise(url, {
+      method: 'GET',
+      query,
+    })
+    .then(resp => {
+      ReleaseActions.fetchReleasesSuccess(resp);
+      return resp;
+    })
+    .catch(err => {
+      ReleaseActions.fetchReleasesError(err);
+      addErrorMessage(t('Unable to fetch releases'));
+    });
+
+  return promise;
+}
diff --git a/src/sentry/static/sentry/app/actionCreators/savedSearches.jsx b/src/sentry/static/sentry/app/actionCreators/savedSearches.jsx
index 149b2ebb37..0ec31f60b4 100644
--- a/src/sentry/static/sentry/app/actionCreators/savedSearches.jsx
+++ b/src/sentry/static/sentry/app/actionCreators/savedSearches.jsx
@@ -1,4 +1,4 @@
-import {MAX_RECENT_SEARCHES, SEARCH_TYPES} from 'app/constants';
+import {MAX_AUTOCOMPLETE_RECENT_SEARCHES, SEARCH_TYPES} from 'app/constants';
 import {addErrorMessage} from 'app/actionCreators/indicator';
 import {t} from 'app/locale';
 import SavedSearchesActions from 'app/actions/savedSearchesActions';
@@ -109,7 +109,7 @@ export function fetchRecentSearches(api, orgId, type, query) {
     query: {
       query,
       type,
-      limit: MAX_RECENT_SEARCHES,
+      limit: MAX_AUTOCOMPLETE_RECENT_SEARCHES,
     },
   });
 
diff --git a/src/sentry/static/sentry/app/actions/releaseActions.jsx b/src/sentry/static/sentry/app/actions/releaseActions.jsx
new file mode 100644
index 0000000000..3a5de980c8
--- /dev/null
+++ b/src/sentry/static/sentry/app/actions/releaseActions.jsx
@@ -0,0 +1,7 @@
+import Reflux from 'reflux';
+
+export default Reflux.createActions([
+  'fetchReleases',
+  'fetchReleasesError',
+  'fetchReleasesSuccess',
+]);
diff --git a/src/sentry/static/sentry/app/components/smartSearchBar/index.jsx b/src/sentry/static/sentry/app/components/smartSearchBar/index.jsx
index 297f3fd571..897158fe91 100644
--- a/src/sentry/static/sentry/app/components/smartSearchBar/index.jsx
+++ b/src/sentry/static/sentry/app/components/smartSearchBar/index.jsx
@@ -7,7 +7,12 @@ import _ from 'lodash';
 import createReactClass from 'create-react-class';
 import styled, {css} from 'react-emotion';
 
-import {NEGATION_OPERATOR, SEARCH_WILDCARD} from 'app/constants';
+import {
+  DEFAULT_DEBOUNCE_DURATION,
+  MAX_AUTOCOMPLETE_RELEASES,
+  NEGATION_OPERATOR,
+  SEARCH_WILDCARD,
+} from 'app/constants';
 import {analytics} from 'app/utils/analytics';
 import {callIfFunction} from 'app/utils/callIfFunction';
 import {defined} from 'app/utils';
@@ -17,6 +22,7 @@ import {
   saveRecentSearch,
   unpinSearch,
 } from 'app/actionCreators/savedSearches';
+import {fetchReleases} from 'app/actionCreators/releases';
 import {t} from 'app/locale';
 import Button from 'app/components/button';
 import CreateSavedSearchButton from 'app/views/issueList/createSavedSearchButton';
@@ -31,21 +37,7 @@ import withOrganization from 'app/utils/withOrganization';
 
 import SearchDropdown from './searchDropdown';
 
-export function addSpace(query = '') {
-  if (query.length !== 0 && query[query.length - 1] !== ' ') {
-    return query + ' ';
-  } else {
-    return query;
-  }
-}
-
-export function removeSpace(query = '') {
-  if (query[query.length - 1] === ' ') {
-    return query.slice(0, query.length - 1);
-  } else {
-    return query;
-  }
-}
+const DROPDOWN_BLUR_DURATION = 200;
 
 const getMediaQuery = (size, type) => `
   display: ${type};
@@ -106,7 +98,6 @@ class SmartSearchBar extends React.Component {
 
     organization: SentryTypes.Organization.isRequired,
 
-    // Class name for search dropdown
     dropdownClassName: PropTypes.string,
 
     defaultQuery: PropTypes.string,
@@ -257,8 +248,6 @@ class SmartSearchBar extends React.Component {
     }
   }
 
-  DROPDOWN_BLUR_DURATION = 200;
-
   blur = () => {
     if (!this.searchInput.current) {
       return;
@@ -325,7 +314,7 @@ class SmartSearchBar extends React.Component {
       this.blurTimeout = null;
       this.setState({dropdownVisible: false});
       callIfFunction(this.props.onBlur);
-    }, this.DROPDOWN_BLUR_DURATION);
+    }, DROPDOWN_BLUR_DURATION);
   };
 
   onQueryChange = evt => {
@@ -405,7 +394,7 @@ class SmartSearchBar extends React.Component {
         return [];
       }
     },
-    300,
+    DEFAULT_DEBOUNCE_DURATION,
     {leading: true}
   );
 
@@ -434,30 +423,83 @@ class SmartSearchBar extends React.Component {
       }
 
       const fetchFn = onGetRecentSearches || this.fetchRecentSearches;
-      return fetchFn(this.state.query);
+      return await fetchFn(this.state.query);
     },
-    300,
+    DEFAULT_DEBOUNCE_DURATION,
     {leading: true}
   );
 
   fetchRecentSearches = async fullQuery => {
     const {api, organization, savedSearchType} = this.props;
 
-    const recentSearches = await fetchRecentSearches(
-      api,
-      organization.slug,
-      savedSearchType,
-      fullQuery
-    );
+    try {
+      const recentSearches = await fetchRecentSearches(
+        api,
+        organization.slug,
+        savedSearchType,
+        fullQuery
+      );
+
+      // If `recentSearches` is undefined or not an array, the function will
+      // return an array anyway
+      return recentSearches.map(searches => ({
+        desc: searches.query,
+        value: searches.query,
+        type: 'recent-search',
+      }));
+    } catch (e) {
+      Sentry.captureException(e);
+    }
+
+    return [];
+  };
+
+  getReleases = _.debounce(
+    async (tag, query) => {
+      const releasePromise = this.fetchReleases(query);
+
+      const tags = this.getPredefinedTagValues(tag, query);
+      const tagValues = tags.map(v => ({
+        ...v,
+        type: 'first-release',
+      }));
+
+      const releases = await releasePromise;
+      const releaseValues = releases.map(r => ({
+        value: r.shortVersion,
+        desc: r.shortVersion,
+        type: 'first-release',
+      }));
+
+      return [...tagValues, ...releaseValues];
+    },
+    DEFAULT_DEBOUNCE_DURATION,
+    {leading: true}
+  );
+
+  /**
+   * Fetches latest releases from a organization/project. Returns an empty array
+   * if an error is encountered.
+   */
+  fetchReleases = async query => {
+    const {api, organization} = this.props;
+    const {location} = this.context.router;
+
+    const project = location && location.query ? location.query.projectId : undefined;
 
-    return [
-      ...(recentSearches &&
-        recentSearches.map(({query}) => ({
-          desc: query,
-          value: query,
-          type: 'recent-search',
-        }))),
-    ];
+    try {
+      return await fetchReleases(
+        api,
+        organization.slug,
+        project,
+        query,
+        MAX_AUTOCOMPLETE_RELEASES
+      );
+    } catch (e) {
+      Sentry.captureException(e);
+    }
+
+    return [];
   };
 
   onInputClick = () => {
@@ -530,57 +572,60 @@ class SmartSearchBar extends React.Component {
         matchValue,
         'tag-key'
       );
-    } else {
-      const {supportedTags, prepareQuery} = this.props;
-
-      // TODO(billy): Better parsing for these examples
-      // sentry:release:
-      // url:"http://with/colon"
-      tagName = last.slice(0, index);
+      return;
+    }
 
-      // e.g. given "!gpu" we want "gpu"
-      tagName = tagName.replace(new RegExp(`^${NEGATION_OPERATOR}`), '');
-      query = last.slice(index + 1);
-      const preparedQuery =
-        typeof prepareQuery === 'function' ? prepareQuery(query) : query;
+    const {supportedTags, prepareQuery} = this.props;
 
-      // filter existing items immediately, until API can return
-      // with actual tag value results
-      const filteredSearchItems = !preparedQuery
-        ? this.state.searchItems
-        : this.state.searchItems.filter(
-            item => item.value && item.value.indexOf(preparedQuery) !== -1
-          );
+    // TODO(billy): Better parsing for these examples
+    // sentry:release:
+    // url:"http://with/colon"
+    tagName = last.slice(0, index);
+
+    // e.g. given "!gpu" we want "gpu"
+    tagName = tagName.replace(new RegExp(`^${NEGATION_OPERATOR}`), '');
+    query = last.slice(index + 1);
+    const preparedQuery =
+      typeof prepareQuery === 'function' ? prepareQuery(query) : query;
+
+    // filter existing items immediately, until API can return
+    // with actual tag value results
+    const filteredSearchItems = !preparedQuery
+      ? this.state.searchItems
+      : this.state.searchItems.filter(
+          item => item.value && item.value.indexOf(preparedQuery) !== -1
+        );
 
-      this.setState({
-        searchTerm: query,
-        searchItems: filteredSearchItems,
-      });
+    this.setState({
+      searchTerm: query,
+      searchItems: filteredSearchItems,
+    });
 
-      const tag = supportedTags[tagName];
+    const tag = supportedTags[tagName];
 
-      if (!tag) {
-        this.updateAutoCompleteState([], [], tagName, 'invalid-tag');
-        return;
-      }
+    if (!tag) {
+      this.updateAutoCompleteState([], [], tagName, 'invalid-tag');
+      return;
+    }
 
-      // Ignore the environment tag if the feature is active and excludeEnvironment = true
-      if (this.props.excludeEnvironment && tagName === 'environment') {
-        return;
-      }
+    // Ignore the environment tag if the feature is active and excludeEnvironment = true
+    if (this.props.excludeEnvironment && tagName === 'environment') {
+      return;
+    }
 
-      const fetchTagValuesFn = tag.predefined
+    const fetchTagValuesFn =
+      tag.key === 'firstRelease'
+        ? this.getReleases
+        : tag.predefined
         ? this.getPredefinedTagValues
         : this.getTagValues;
 
-      const [tagValues, recentSearches] = await Promise.all([
-        fetchTagValuesFn(tag, preparedQuery),
-        this.getRecentSearches(),
-      ]);
+    const [tagValues, recentSearches] = await Promise.all([
+      fetchTagValuesFn(tag, preparedQuery),
+      this.getRecentSearches(),
+    ]);
 
-      this.updateAutoCompleteState(tagValues, recentSearches, tag.key, 'tag-value');
-      return;
-    }
+    this.updateAutoCompleteState(tagValues, recentSearches, tag.key, 'tag-value');
     return;
   };
 
@@ -1007,6 +1052,22 @@ const SmartSearchBarContainer = withApi(
   )
 );
 
+export function addSpace(query = '') {
+  if (query.length !== 0 && query[query.length - 1] !== ' ') {
+    return query + ' ';
+  } else {
+    return query;
+  }
+}
+
+export function removeSpace(query = '') {
+  if (query[query.length - 1] === ' ') {
+    return query.slice(0, query.length - 1);
+  } else {
+    return query;
+  }
+}
+
 const Container = styled('div')`
   border: 1px solid ${p => p.theme.borderLight};
   border-radius: ${p =>
diff --git a/src/sentry/static/sentry/app/constants/index.tsx b/src/sentry/static/sentry/app/constants/index.tsx
index 71100f6db6..d5114135dc 100644
--- a/src/sentry/static/sentry/app/constants/index.tsx
+++ b/src/sentry/static/sentry/app/constants/index.tsx
@@ -98,6 +98,7 @@ export const SENTRY_APP_PERMISSIONS = [
 ];
 
 export const DEFAULT_TOAST_DURATION = 6000;
+export const DEFAULT_DEBOUNCE_DURATION = 300;
 
 declare global {
   interface Window {
@@ -156,11 +157,13 @@ export const ALGOLIA_READ_ONLY = '2d64ec1106519cbc672d863b0d200782';
 export const ALGOLIA_DOCS_INDEX = 'sentry-docs';
 export const ALGOLIA_ZENDESK_INDEX = 'zendesk_sentry_articles';
 
+// SmartSearchBar settings
 export const SEARCH_TYPES = {
   ISSUE: 0,
   EVENT: 1,
 };
-export const MAX_RECENT_SEARCHES = 3;
+export const MAX_AUTOCOMPLETE_RECENT_SEARCHES = 3;
+export const MAX_AUTOCOMPLETE_RELEASES = 5;
 
 export const DEFAULT_PER_PAGE = 50;
 
diff --git a/src/sentry/static/sentry/app/stores/releaseStore.jsx b/src/sentry/static/sentry/app/stores/releaseStore.jsx
new file mode 100644
index 0000000000..4ff35575b2
--- /dev/null
+++ b/src/sentry/static/sentry/app/stores/releaseStore.jsx
@@ -0,0 +1,24 @@
+import Reflux from 'reflux';
+
+const ReleaseStore = Reflux.createStore({
+  init() {
+    this.items = [];
+    this.loaded = false;
+  },
+
+  loadInitialData(items) {
+    this.items = items;
+    this.loaded = true;
+    this.trigger(this.items, 'initial');
+  },
+
+  reset() {
+    this.items = [];
+  },
+
+  getAll() {
+    return this.items;
+  },
+});
+
+export default ReleaseStore;
diff --git a/src/sentry/static/sentry/app/stores/tagStore.jsx b/src/sentry/static/sentry/app/stores/tagStore.jsx
index 1733be6243..e247057bb5 100644
--- a/src/sentry/static/sentry/app/stores/tagStore.jsx
+++ b/src/sentry/static/sentry/app/stores/tagStore.jsx
@@ -75,6 +75,12 @@ const TagStore = Reflux.createStore({
         values: ['-1h', '+1d', '-1w'],
         predefined: true,
       },
+      firstRelease: {
+        key: 'firstRelease',
+        name: 'First Release',
+        values: ['latest'],
+        predefined: true,
+      },
       'event.timestamp': {
         key: 'event.timestamp',
         name: 'Event Timestamp',
diff --git a/src/sentry/static/sentry/app/views/issueList/searchBar.jsx b/src/sentry/static/sentry/app/views/issueList/searchBar.jsx
index b9e881a69a..b650003a2b 100644
--- a/src/sentry/static/sentry/app/views/issueList/searchBar.jsx
+++ b/src/sentry/static/sentry/app/views/issueList/searchBar.jsx
@@ -64,6 +64,7 @@ class IssueListSearchBar extends React.Component {
   }
 
   fetchData = async () => {
+    this.props.api.clear();
     const resp = await this.getRecentSearches();
 
     this.setState({
diff --git a/tests/js/spec/components/smartSearchBar.spec.jsx b/tests/js/spec/components/smartSearchBar.spec.jsx
index 9381cea34a..c5b6fd6b5f 100644
--- a/tests/js/spec/components/smartSearchBar.spec.jsx
+++ b/tests/js/spec/components/smartSearchBar.spec.jsx
@@ -1,7 +1,7 @@
 import React from 'react';
 import {shallow, mount} from 'enzyme';
-import {Client} from 'app/api';
 
+import {Client} from 'app/api';
 import {SmartSearchBar, addSpace, removeSpace} from 'app/components/smartSearchBar';
 import TagStore from 'app/stores/tagStore';
 
@@ -42,11 +42,25 @@ describe('SmartSearchBar', function() {
     TagStore.reset();
     TagStore.onLoadTagsSuccess(TestStubs.Tags());
     tagValuesMock.mockClear();
-    supportedTags = {};
+    supportedTags = TagStore.getAllTags();
     organization = TestStubs.Organization({id: '123'});
 
-    options = TestStubs.routerContext([{organization}]);
+    const location = {
+      pathname: '/organizations/org-slug/recent-searches/',
+      query: {
+        projectId: '0',
+      },
+    };
 
+    options = TestStubs.routerContext([
+      {
+        organization,
+        location,
+        router: {location},
+      },
+    ]);
+
+    MockApiClient.clearMockResponses();
     MockApiClient.addMockResponse({
       url: '/organizations/org-slug/recent-searches/',
       body: [],
@@ -419,11 +433,46 @@ describe('SmartSearchBar', function() {
         organization,
         supportedTags,
       };
-      const searchBar = mount(<SmartSearchBar {...props} />, options).instance();
+      const searchBar = mount(
+        <SmartSearchBar {...props} api={new Client()} />,
+        options
+      ).instance();
       searchBar.updateAutoCompleteItems();
       jest.advanceTimersByTime(301);
       expect(mock).not.toHaveBeenCalled();
     });
+
+    it('requests values when tag is `firstRelease`', function() {
+      const mock = MockApiClient.addMockResponse({
+        url: '/organizations/org-slug/releases/',
+        body: [],
+      });
+      const props = {
+        orgId: 'org-slug',
+        projectId: '0',
+        query: 'firstRelease:',
+        organization,
+        supportedTags,
+      };
+
+      const searchBar = mount(
+        <SmartSearchBar {...props} api={new Client()} />,
+        options
+      ).instance();
+      searchBar.updateAutoCompleteItems();
+
+      jest.advanceTimersByTime(301);
+      expect(mock).toHaveBeenCalledWith(
+        '/organizations/org-slug/releases/',
+        expect.objectContaining({
+          method: 'GET',
+          query: {
+            project: '0',
+            per_page: 5, // Limit results to 5 for autocomplete
+          },
+        })
+      );
+    });
   });
 
   describe('onTogglePinnedSearch', function() {

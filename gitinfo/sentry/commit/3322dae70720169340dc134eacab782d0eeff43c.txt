commit 3322dae70720169340dc134eacab782d0eeff43c
Author: NisanthanNanthakumar <nisanthan.nanthakumar@sentry.io>
Date:   Mon Jan 27 09:38:28 2020 -0800

    feat: Implementation of new Integration Directory home page layout (#16624)
    
    Problem
    Implement the new Integration Directory home page frontend layout while maintaining the current Integrations page for users.
    
    Solution
    Write a component that will show the test vs current Directory based on the existence of a key/value in LocalStorage. Set "USE_INTEGRATION_DIRECTORY" to "1" to view the new version.

diff --git a/src/sentry/static/sentry/app/routes.jsx b/src/sentry/static/sentry/app/routes.jsx
index 041ef98052..748849afb8 100644
--- a/src/sentry/static/sentry/app/routes.jsx
+++ b/src/sentry/static/sentry/app/routes.jsx
@@ -833,7 +833,7 @@ function routes() {
         <IndexRoute
           componentPromise={() =>
             import(
-              /* webpackChunkName: "OrganizationIntegrations" */ 'app/views/organizationIntegrations'
+              /* webpackChunkName: "OrganizationIntegrations" */ 'app/views/organizationIntegrations/integrationViewController'
             )
           }
           component={errorHandler(LazyLoad)}
diff --git a/src/sentry/static/sentry/app/utils/integrationUtil.tsx b/src/sentry/static/sentry/app/utils/integrationUtil.tsx
index 9dc9a520c1..2f7e2d37ff 100644
--- a/src/sentry/static/sentry/app/utils/integrationUtil.tsx
+++ b/src/sentry/static/sentry/app/utils/integrationUtil.tsx
@@ -4,6 +4,7 @@ import {Organization} from 'app/types';
 import {Hooks} from 'app/types/hooks';
 
 const INTEGRATIONS_ANALYTICS_SESSION_KEY = 'integrationsAnalyticsSession';
+const USE_INTEGRATION_DIRECTORY = 'USE_INTEGRATION_DIRECTORY';
 
 export const startAnalyticsSession = () => {
   const sessionId = uniqueId();
@@ -19,6 +20,9 @@ export const getAnalyticsSessionId = () => {
   return window.sessionStorage.getItem(INTEGRATIONS_ANALYTICS_SESSION_KEY);
 };
 
+export const isIntegrationDirectoryActive = () =>
+  localStorage.getItem(USE_INTEGRATION_DIRECTORY) === '1';
+
 type ModalOpenEvent = {
   eventKey: 'integrations.install_modal_opened';
   eventName: 'Integrations: Install Modal Opened';
@@ -101,7 +105,7 @@ export const trackIntegrationEvent = (
     analytics_session_id: sessionId,
     organization_id: org?.id,
     role: org?.role,
-    integration_directory_active: false, //TODO: should be configurable
+    integration_directory_active: isIntegrationDirectoryActive(),
     ...analyticsParams,
   };
 
diff --git a/src/sentry/static/sentry/app/views/organizationIntegrations/integrationListDirectory.tsx b/src/sentry/static/sentry/app/views/organizationIntegrations/integrationListDirectory.tsx
new file mode 100644
index 0000000000..6e0c73b2ad
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/organizationIntegrations/integrationListDirectory.tsx
@@ -0,0 +1,397 @@
+import groupBy from 'lodash/groupBy';
+import keyBy from 'lodash/keyBy';
+import React from 'react';
+import styled from '@emotion/styled';
+
+import {
+  Organization,
+  Integration,
+  Plugin,
+  SentryApp,
+  IntegrationProvider,
+  SentryAppInstallation,
+  RouterProps,
+} from 'app/types';
+import {Panel, PanelBody, PanelHeader} from 'app/components/panels';
+import {RequestOptions} from 'app/api';
+import {addErrorMessage} from 'app/actionCreators/indicator';
+import {trackIntegrationEvent} from 'app/utils/integrationUtil';
+import {removeSentryApp} from 'app/actionCreators/sentryApps';
+import {sortArray} from 'app/utils';
+import {t} from 'app/locale';
+import AsyncComponent from 'app/components/asyncComponent';
+import LoadingIndicator from 'app/components/loadingIndicator';
+import MigrationWarnings from 'app/views/organizationIntegrations/migrationWarnings';
+import PermissionAlert from 'app/views/settings/organization/permissionAlert';
+import ProviderRow from 'app/views/organizationIntegrations/integrationProviderRow';
+import SentryAppInstallationDetail from 'app/views/organizationIntegrations/sentryAppInstallationDetail';
+import SentryApplicationRow from 'app/views/settings/organizationDeveloperSettings/sentryApplicationRow';
+import SentryDocumentTitle from 'app/components/sentryDocumentTitle';
+import SentryTypes from 'app/sentryTypes';
+import SettingsPageHeader from 'app/views/settings/components/settingsPageHeader';
+import space from 'app/styles/space';
+import withOrganization from 'app/utils/withOrganization';
+import SearchInput from 'app/components/forms/searchInput';
+
+type AppOrProvider = SentryApp | IntegrationProvider;
+
+type Props = RouterProps & {
+  organization: Organization;
+  hideHeader: boolean;
+};
+
+type State = {
+  integrations: Integration[];
+  newlyInstalledIntegrationId: string;
+  plugins: Plugin[];
+  appInstalls: SentryAppInstallation[];
+  orgOwnedApps: SentryApp[];
+  publishedApps: SentryApp[];
+  config: {providers: IntegrationProvider[]};
+  extraApp?: SentryApp;
+};
+
+function isSentryApp(integration: AppOrProvider): integration is SentryApp {
+  return (integration as SentryApp).uuid !== undefined;
+}
+
+class OrganizationIntegrations extends AsyncComponent<
+  Props & AsyncComponent['props'],
+  State & AsyncComponent['state']
+> {
+  // Some integrations require visiting a different website to add them. When
+  // we come back to the tab we want to show our integrations as soon as we can.
+  shouldReload = true;
+  reloadOnVisible = true;
+  shouldReloadOnVisible = true;
+
+  static propTypes = {
+    organization: SentryTypes.Organization,
+  };
+
+  onLoadAllEndpointsSuccess() {
+    //count the number of installed apps
+    const {integrations, publishedApps} = this.state;
+    const integrationsInstalled = new Set();
+    //add installed integrations
+    integrations.forEach((integration: Integration) => {
+      integrationsInstalled.add(integration.provider.key);
+    });
+    //add sentry apps
+    publishedApps.filter(this.getAppInstall).forEach((sentryApp: SentryApp) => {
+      integrationsInstalled.add(sentryApp.slug);
+    });
+    trackIntegrationEvent(
+      {
+        eventKey: 'integrations.index_viewed',
+        eventName: 'Integrations: Index Page Viewed',
+        integrations_installed: integrationsInstalled.size,
+        view: 'integrations_page',
+      },
+      this.props.organization,
+      {startSession: true}
+    );
+  }
+
+  getEndpoints(): ([string, string, any] | [string, string])[] {
+    const {orgId} = this.props.params;
+    const query = {plugins: ['vsts', 'github', 'bitbucket']};
+    const baseEndpoints: ([string, string, any] | [string, string])[] = [
+      ['config', `/organizations/${orgId}/config/integrations/`],
+      ['integrations', `/organizations/${orgId}/integrations/`],
+      ['plugins', `/organizations/${orgId}/plugins/`, {query}],
+      ['orgOwnedApps', `/organizations/${orgId}/sentry-apps/`],
+      ['publishedApps', '/sentry-apps/', {query: {status: 'published'}}],
+      ['appInstalls', `/organizations/${orgId}/sentry-app-installations/`],
+    ];
+    /**
+     * optional app to load for super users
+     * should only be done for unpublished integrations from another org
+     * but no checks are in place to ensure the above condition
+     */
+    const extraAppSlug = new URLSearchParams(this.props.location.search).get('extra_app');
+    if (extraAppSlug) {
+      baseEndpoints.push(['extraApp', `/sentry-apps/${extraAppSlug}/`]);
+    }
+
+    return baseEndpoints;
+  }
+
+  // State
+
+  get unmigratableReposByOrg() {
+    // Group by [GitHub|BitBucket|VSTS] Org name
+    return groupBy(this.state.unmigratableRepos, repo => repo.name.split('/')[0]);
+  }
+
+  get providers(): IntegrationProvider[] {
+    return this.state.config.providers;
+  }
+
+  // Actions
+
+  onInstall = (integration: Integration) => {
+    // Merge the new integration into the list. If we're updating an
+    // integration overwrite the old integration.
+    const keyedItems = keyBy(this.state.integrations, i => i.id);
+
+    // Mark this integration as newlyAdded if it didn't already exist, allowing
+    // us to animate the element in.
+    if (!keyedItems.hasOwnProperty(integration.id)) {
+      this.setState({newlyInstalledIntegrationId: integration.id});
+    }
+
+    const integrations = sortArray(
+      Object.values({...keyedItems, [integration.id]: integration}),
+      i => i.name
+    );
+    this.setState({integrations});
+  };
+
+  onRemove = (integration: Integration) => {
+    const {orgId} = this.props.params;
+
+    const origIntegrations = [...this.state.integrations];
+
+    const integrations = this.state.integrations.filter(i => i.id !== integration.id);
+    this.setState({integrations});
+
+    const options: RequestOptions = {
+      method: 'DELETE',
+      error: () => {
+        this.setState({integrations: origIntegrations});
+        addErrorMessage(t('Failed to remove Integration'));
+      },
+    };
+
+    this.api.request(`/organizations/${orgId}/integrations/${integration.id}/`, options);
+  };
+
+  onDisable = (integration: Integration) => {
+    let url: string;
+    const [domainName, orgName] = integration.domainName.split('/');
+
+    if (integration.accountType === 'User') {
+      url = `https://${domainName}/settings/installations/`;
+    } else {
+      url = `https://${domainName}/organizations/${orgName}/settings/installations/`;
+    }
+
+    window.open(url, '_blank');
+  };
+
+  handleRemoveInternalSentryApp = (app: SentryApp): void => {
+    const apps = this.state.orgOwnedApps.filter(a => a.slug !== app.slug);
+    removeSentryApp(this.api, app).then(
+      () => {
+        this.setState({orgOwnedApps: apps});
+      },
+      () => {}
+    );
+  };
+
+  handleRemoveAppInstallation = (app: SentryApp): void => {
+    const appInstalls = this.state.appInstalls.filter(i => i.app.slug !== app.slug);
+    this.setState({appInstalls});
+  };
+
+  handleAppInstallation = (install: SentryAppInstallation): void => {
+    this.setState({appInstalls: [install, ...this.state.appInstalls]});
+  };
+
+  getAppInstall = (app: SentryApp) => {
+    return this.state.appInstalls.find(i => i.app.slug === app.slug);
+  };
+
+  //Returns 0 if uninstalled, 1 if pending, and 2 if installed
+  getInstallValue(integration: AppOrProvider) {
+    const {integrations} = this.state;
+    if (isSentryApp(integration)) {
+      const install = this.getAppInstall(integration);
+      if (install) {
+        return install.status === 'pending' ? 1 : 2;
+      }
+      return 0;
+    }
+    return integrations.find(i => i.provider.key === integration.key) ? 2 : 0;
+  }
+
+  sortIntegrations(integrations: AppOrProvider[]) {
+    return integrations
+      .sort((a, b) => a.name.localeCompare(b.name))
+      .sort((a, b) => this.getInstallValue(b) - this.getInstallValue(a));
+  }
+
+  // Rendering
+  renderProvider = (provider: IntegrationProvider) => {
+    //find the integration installations for that provider
+    const integrations = this.state.integrations.filter(
+      i => i.provider.key === provider.key
+    );
+    return (
+      <ProviderRow
+        key={`row-${provider.key}`}
+        data-test-id="integration-row"
+        provider={provider}
+        orgId={this.props.params.orgId}
+        integrations={integrations}
+        onInstall={this.onInstall}
+        onRemove={this.onRemove}
+        onDisable={this.onDisable}
+        onReinstall={this.onInstall}
+        newlyInstalledIntegrationId={this.state.newlyInstalledIntegrationId}
+      />
+    );
+  };
+
+  //render either an internal or non-internal app
+  renderSentryApp = (app: SentryApp) => {
+    const {organization} = this.props;
+
+    if (app.status === 'internal') {
+      return (
+        <SentryApplicationRow
+          key={`sentry-app-row-${app.slug}`}
+          data-test-id="internal-integration-row"
+          onRemoveApp={() => this.handleRemoveInternalSentryApp(app)}
+          organization={organization}
+          install={this.getAppInstall(app)}
+          app={app}
+          isOnIntegrationPage
+        />
+      );
+    }
+
+    return (
+      <SentryAppInstallationDetail
+        key={`sentry-app-row-${app.slug}`}
+        data-test-id="integration-row"
+        api={this.api}
+        organization={organization}
+        install={this.getAppInstall(app)}
+        onAppUninstall={() => this.handleRemoveAppInstallation(app)}
+        onAppInstall={this.handleAppInstallation}
+        app={app}
+      />
+    );
+  };
+
+  renderIntegration = (integration: AppOrProvider) => {
+    if (isSentryApp(integration)) {
+      return this.renderSentryApp(integration);
+    }
+    return this.renderProvider(integration);
+  };
+
+  renderBody() {
+    const {orgId} = this.props.params;
+    const {reloading, orgOwnedApps, publishedApps, extraApp} = this.state;
+    const published = publishedApps || [];
+    // If we have an extra app in state from query parameter, add it as org owned app
+    if (extraApp) {
+      orgOwnedApps.push(extraApp);
+    }
+
+    // we dont want the app to render twice if its the org that created
+    // the published app.
+    const orgOwned = orgOwnedApps.filter(app => {
+      return !published.find(p => p.slug === app.slug);
+    });
+
+    /**
+     * We should have three sections:
+     * 1. Public apps and integrations available to everyone
+     * 2. Unpublished apps available to that org
+     * 3. Internal apps available to that org
+     */
+
+    const publicApps = published.concat(orgOwned.filter(a => a.status === 'published'));
+    const publicIntegrations = this.sortIntegrations(
+      (publicApps as AppOrProvider[]).concat(this.providers)
+    );
+
+    const title = t('Integrations');
+    const tags = [
+      'Source Control',
+      'Ticketing',
+      'Data Forwarding',
+      'Release Management',
+      'Notifications',
+    ];
+    return (
+      <React.Fragment>
+        <SentryDocumentTitle title={title} objSlug={orgId} />
+        {!this.props.hideHeader && <SettingsPageHeader title={title} />}
+        <PermissionAlert access={['org:integrations']} />
+
+        <MigrationWarnings
+          orgId={this.props.params.orgId}
+          providers={this.providers}
+          onInstall={this.onInstall}
+        />
+        <SearchInput
+          value=""
+          onChange={() => {}}
+          placeholder="Find a new integration, or one you already use."
+        />
+        <TagsContainer>
+          {tags.map(tag => (
+            <Tag key={tag}>{tag}</Tag>
+          ))}
+        </TagsContainer>
+        <Panel>
+          <PanelHeader disablePadding>
+            <Heading>{t('Integrations')}</Heading>
+            {reloading && <StyledLoadingIndicator mini />}
+          </PanelHeader>
+          <PanelBody>{publicIntegrations.map(this.renderIntegration)}</PanelBody>
+        </Panel>
+      </React.Fragment>
+    );
+  }
+}
+
+const StyledLoadingIndicator = styled(LoadingIndicator)`
+  position: absolute;
+  right: 7px;
+  top: 50%;
+  transform: translateY(-16px);
+`;
+
+const Heading = styled('div')`
+  flex: 1;
+  padding-left: ${space(2)};
+  padding-right: ${space(2)};
+`;
+
+const TagsContainer = styled('div')`
+  display: flex;
+  flex-wrap: wrap;
+  padding-top: ${space(3)};
+  padding-bottom: ${space(1)};
+`;
+
+const Tag = styled('span')`
+  transition: border-color 0.15s ease;
+  font-size: 14px;
+  line-height: 1;
+  padding: ${space(1)};
+  margin: 0 ${space(1)} ${space(1)} 0;
+  border: 1px solid ${p => p.theme.borderDark};
+  border-radius: 30px;
+  height: 28px;
+  box-shadow: inset ${p => p.theme.dropShadowLight};
+  cursor: pointer;
+
+  &:focus {
+    outline: none;
+    border: 1px solid ${p => p.theme.gray1};
+  }
+
+  &::placeholder {
+    color: ${p => p.theme.gray2};
+  }
+`;
+
+export default withOrganization(OrganizationIntegrations);
+export {OrganizationIntegrations};
diff --git a/src/sentry/static/sentry/app/views/organizationIntegrations/integrationProviderRow.tsx b/src/sentry/static/sentry/app/views/organizationIntegrations/integrationProviderRow.tsx
new file mode 100644
index 0000000000..6b8c540904
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/organizationIntegrations/integrationProviderRow.tsx
@@ -0,0 +1,190 @@
+import {withTheme} from 'emotion-theming';
+import PropTypes from 'prop-types';
+import React from 'react';
+import styled from '@emotion/styled';
+import Link from 'app/components/links/link';
+import {openIntegrationDetails} from 'app/actionCreators/modal';
+import {PanelItem} from 'app/components/panels';
+import {t} from 'app/locale';
+import Button from 'app/components/button';
+import CircleIndicator from 'app/components/circleIndicator';
+import InstalledIntegration, {
+  Props as InstalledIntegrationProps,
+} from 'app/views/organizationIntegrations/installedIntegration';
+import PluginIcon from 'app/plugins/components/pluginIcon';
+import SentryTypes from 'app/sentryTypes';
+import space from 'app/styles/space';
+import {growDown, highlight} from 'app/styles/animations';
+import {IntegrationProvider, Integration} from 'app/types';
+
+type Props = {
+  provider: IntegrationProvider;
+  orgId: string;
+  onInstall: (integration: Integration) => void;
+  onRemove: (integration: Integration) => void;
+  onDisable: (integration: Integration) => void;
+  onReinstall: (integration: Integration) => void;
+  newlyInstalledIntegrationId: string;
+  integrations: Integration[];
+};
+
+export default class ProviderRow extends React.Component<Props> {
+  static propTypes = {
+    provider: PropTypes.object.isRequired,
+    integrations: PropTypes.array.isRequired,
+    orgId: PropTypes.string.isRequired,
+    onInstall: PropTypes.func.isRequired,
+    onRemove: PropTypes.func.isRequired,
+    onDisable: PropTypes.func.isRequired,
+    onReinstall: PropTypes.func.isRequired,
+    newlyInstalledIntegrationId: PropTypes.string,
+  };
+
+  static contextTypes = {
+    organization: SentryTypes.Organization,
+  };
+
+  get integrations() {
+    return this.props.integrations;
+  }
+
+  get isEnabled() {
+    return this.integrations.length > 0;
+  }
+
+  // Actions
+
+  openModal = () => {
+    const organization = this.context.organization;
+    const provider = this.props.provider;
+    const onAddIntegration = this.props.onInstall;
+    openIntegrationDetails({
+      provider,
+      organization,
+      onAddIntegration,
+      isInstalled: this.isEnabled,
+    });
+  };
+
+  // Rendering
+
+  get buttonProps() {
+    return {
+      icon: 'icon-circle-add',
+      children: this.isEnabled ? t('Add Configuration') : t('Install'),
+    };
+  }
+
+  renderIntegrations() {
+    return this.integrations.map(integration => (
+      <StyledInstalledIntegration
+        key={integration.id}
+        organization={this.context.organization}
+        provider={this.props.provider}
+        integration={integration}
+        onRemove={this.props.onRemove}
+        onDisable={this.props.onDisable}
+        onReinstallIntegration={this.props.onReinstall}
+        data-test-id={integration.id}
+        newlyAdded={integration.id === this.props.newlyInstalledIntegrationId}
+      />
+    ));
+  }
+
+  render() {
+    return (
+      <PanelItem p={0} flexDirection="column" data-test-id={this.props.provider.key}>
+        <Flex style={{alignItems: 'center', padding: '16px'}}>
+          <PluginIcon size={36} pluginId={this.props.provider.key} />
+          <div style={{flex: '1', padding: '0 16px'}}>
+            <ProviderName>{this.props.provider.name}</ProviderName>
+            <ProviderDetails>
+              <Status enabled={this.isEnabled} />
+              <StyledLink>{`${this.props.integrations.length} Configurations`}</StyledLink>
+            </ProviderDetails>
+          </div>
+          <div>
+            <Button size="small" onClick={this.openModal} {...this.buttonProps} />
+          </div>
+        </Flex>
+      </PanelItem>
+    );
+  }
+}
+
+const Flex = styled('div')`
+  display: flex;
+`;
+
+const ProviderName = styled('div')`
+  font-weight: bold;
+`;
+
+const ProviderDetails = styled(Flex)`
+  align-items: center;
+  margin-top: 6px;
+  font-size: 0.8em;
+`;
+
+type StatusProps = {
+  enabled: boolean;
+  theme?: any; //TS complains if we don't make this optional
+};
+
+const Status = styled(
+  withTheme((props: StatusProps) => {
+    const {enabled, theme, ...p} = props;
+    return (
+      <StatusWrapper>
+        <CircleIndicator
+          enabled={enabled}
+          size={6}
+          color={enabled ? theme.success : theme.gray2}
+        />
+        <div {...p}>{enabled ? t('Installed') : t('Not Installed')}</div>
+      </StatusWrapper>
+    );
+  })
+)`
+  color: ${(p: StatusProps) => (p.enabled ? p.theme.success : p.theme.gray2)};
+  margin-left: ${space(0.5)};
+  margin-right: ${space(0.75)};
+  &:after {
+    content: '|';
+    color: ${p => p.theme.gray1};
+    margin-left: ${space(0.75)};
+    font-weight: normal;
+  }
+`;
+
+const StatusWrapper = styled('div')`
+  display: flex;
+  align-items: center;
+`;
+
+const NewInstallation = styled('div')`
+  overflow: hidden;
+  transform-origin: 0 auto;
+  animation: ${growDown('59px')} 160ms 500ms ease-in-out forwards,
+    ${p => highlight(p.theme.yellowLightest)} 1000ms 500ms ease-in-out forwards;
+`;
+
+const StyledInstalledIntegration = styled(
+  (p: InstalledIntegrationProps & {newlyAdded: boolean}) =>
+    p.newlyAdded ? (
+      <NewInstallation>
+        <InstalledIntegration {...p} />
+      </NewInstallation>
+    ) : (
+      <InstalledIntegration {...p} />
+    )
+)`
+  padding: ${space(2)};
+  padding-left: 0;
+  margin-left: 68px;
+  border-top: 1px dashed ${p => p.theme.borderLight};
+`;
+
+const StyledLink = styled(Link)`
+  color: ${p => p.theme.gray2};
+`;
diff --git a/src/sentry/static/sentry/app/views/organizationIntegrations/integrationViewController.tsx b/src/sentry/static/sentry/app/views/organizationIntegrations/integrationViewController.tsx
new file mode 100644
index 0000000000..065421eeef
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/organizationIntegrations/integrationViewController.tsx
@@ -0,0 +1,13 @@
+import React from 'react';
+
+import {isIntegrationDirectoryActive} from 'app/utils/integrationUtil.tsx';
+
+import Control from './index';
+import Test from './integrationListDirectory';
+
+export default function IntegrationViewController(props) {
+  if (isIntegrationDirectoryActive()) {
+    return <Test {...props} />;
+  }
+  return <Control {...props} />;
+}

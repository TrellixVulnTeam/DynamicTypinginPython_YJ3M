commit d7d682ad7d90c3e1b2074b4f0c2c808d85fe2627
Author: Ted Kaemming <ted@kaemming.com>
Date:   Wed Mar 23 14:51:28 2016 -0700

    Add redirect fallback path to `GroupEndpoint`.

diff --git a/src/sentry/api/bases/group.py b/src/sentry/api/bases/group.py
index c5de983ae3..7a4255e531 100644
--- a/src/sentry/api/bases/group.py
+++ b/src/sentry/api/bases/group.py
@@ -1,9 +1,14 @@
 from __future__ import absolute_import
 
+import logging
+
 from sentry.api.base import Endpoint
 from sentry.api.exceptions import ResourceDoesNotExist
 from sentry.api.bases.project import ProjectPermission
-from sentry.models import Group
+from sentry.models import Group, GroupRedirect
+
+
+logger = logging.getLogger(__name__)
 
 
 class GroupPermission(ProjectPermission):
@@ -19,18 +24,44 @@ class GroupPermission(ProjectPermission):
             request, view, group.project)
 
 
-class GroupEndpoint(Endpoint):
-    permission_classes = (GroupPermission,)
+def get_group(issue_id):
+    """
+    Retrieve a group by ID, also checking if the ID was previously used by a
+    group that was since merged.
+    """
+    queryset = Group.objects.select_related('project')
+    try:
+        group = queryset.get(id=issue_id)
+    except Group.DoesNotExist:
+        try:
+            redirect = GroupRedirect.objects.get(previous_group_id=issue_id)
+        except GroupRedirect.DoesNotExist:
+            raise ResourceDoesNotExist
 
-    def convert_args(self, request, issue_id, *args, **kwargs):
+        # TODO(tkaemming): Ideally, this would return a 302 response,
+        # rather than just returning the data that is bound to the new
+        # group. (It technically shouldn't be a 301, since the response
+        # could change again as the result of another merge operation that
+        # occurs later. This wouldn't break anything though -- it will just
+        # be a "permanent" redirect to *another* permanent redirect.) This
+        # would require rebuilding the URL in one of two ways: either by
+        # hacking it in with string replacement, or making the endpoint
+        # aware of the URL pattern that caused it to be dispatched, and
+        # reversing it with the correct `issue_id` keyword argument.
         try:
-            group = Group.objects.select_related('project').get(
-                id=issue_id,
-            )
+            group = queryset.get(id=redirect.group_id)
         except Group.DoesNotExist:
+            logger.warning('%r redirected to group that does not exist!', redirect, exc_info=True)
             raise ResourceDoesNotExist
 
-        self.check_object_permissions(request, group)
+    return group
+
 
+class GroupEndpoint(Endpoint):
+    permission_classes = (GroupPermission,)
+
+    def convert_args(self, request, issue_id, *args, **kwargs):
+        group = get_group(issue_id)
+        self.check_object_permissions(request, group)
         kwargs['group'] = group
         return (args, kwargs)
diff --git a/src/sentry/models/groupredirect.py b/src/sentry/models/groupredirect.py
index f0af689f13..1452e08dc9 100644
--- a/src/sentry/models/groupredirect.py
+++ b/src/sentry/models/groupredirect.py
@@ -1,6 +1,6 @@
 from __future__ import absolute_import
 
-from sentry.db.models import BoundedBigIntegerField, Model
+from sentry.db.models import BoundedBigIntegerField, Model, sane_repr
 
 
 class GroupRedirect(Model):
@@ -16,3 +16,5 @@ class GroupRedirect(Model):
     class Meta:
         db_table = 'sentry_groupredirect'
         app_label = 'sentry'
+
+    __repr__ = sane_repr('group_id', 'previous_group_id')
diff --git a/tests/sentry/api/bases/test_group.py b/tests/sentry/api/bases/test_group.py
new file mode 100644
index 0000000000..c7a30259d0
--- /dev/null
+++ b/tests/sentry/api/bases/test_group.py
@@ -0,0 +1,26 @@
+import pytest
+
+from sentry.api.bases.group import get_group
+from sentry.models import Group, GroupRedirect
+from sentry.testutils import TestCase
+from sentry.api.exceptions import ResourceDoesNotExist
+
+
+class GroupEndpointTestCase(TestCase):
+    def test_get_group_respects_redirect(self):
+        group = self.create_group()
+        duplicate_id = self.create_group().id
+        Group.objects.filter(id=duplicate_id).delete()
+        GroupRedirect.objects.create(
+            group_id=group.id,
+            previous_group_id=duplicate_id,
+        )
+
+        assert get_group(duplicate_id).id == group.id
+
+        # We shouldn't end up in a case where the redirect points to a bad
+        # reference, but testing this path for completeness.
+        group.delete()
+
+        with pytest.raises(ResourceDoesNotExist):
+            get_group(duplicate_id)

commit 9af36ace8281b648100789eb416cfb3e01bf268a
Author: David Cramer <dcramer@gmail.com>
Date:   Tue Feb 14 16:04:03 2017 -0800

    [api] add bulk assignedTo

diff --git a/CHANGES b/CHANGES
index bf4f0fc5b7..88f10e3fe4 100644
--- a/CHANGES
+++ b/CHANGES
@@ -9,7 +9,12 @@ Version 8.14 (Unreleased)
 - [BREAKING] Quotas must now instantiate RateLimited and NotRateLimited return values.
 - [BREAKING] Redis quota implementations now return BasicRedisQuota instead of tuples.
 - Commits using the ``Fixes SHORTID`` annotation will now be tracked appropriately.
-- Added OrganizationReleasesEndpoint
+
+API Changes
+~~~~~~~~~~~
+
+- Added OrganizationReleasesEndpoint.
+- Added ``assignedTo`` param to ``/projects/{org}/{project}/issues/``.
 
 Schema Changes
 ~~~~~~~~~~~~~~
diff --git a/src/sentry/api/endpoints/group_details.py b/src/sentry/api/endpoints/group_details.py
index eb87ed2336..8b1a9e3ba8 100644
--- a/src/sentry/api/endpoints/group_details.py
+++ b/src/sentry/api/endpoints/group_details.py
@@ -13,9 +13,8 @@ from sentry.api.fields import UserField
 from sentry.api.serializers import serialize
 from sentry.constants import STATUS_CHOICES
 from sentry.models import (
-    Activity, Group, GroupHash, GroupAssignee, GroupSeen, GroupSubscription,
-    GroupSubscriptionReason, GroupStatus, GroupTagKey, GroupTagValue, Release,
-    User, UserReport,
+    Activity, Group, GroupHash, GroupSeen, GroupStatus, GroupTagKey,
+    GroupTagValue, Release, User, UserReport,
 )
 from sentry.plugins import IssueTrackingPlugin2, plugins
 from sentry.utils.safe import safe_execute
@@ -268,26 +267,6 @@ class GroupDetailsEndpoint(GroupEndpoint):
         if not serializer.is_valid():
             return Response(serializer.errors, status=400)
 
-        result = serializer.object
-        acting_user = request.user if request.user.is_authenticated() else None
-
-        if result.get('assignedTo') and not group.project.member_set.filter(user=result['assignedTo']).exists():
-            return Response({'detail': 'Cannot assign to non-team member'}, status=400)
-
-        if 'assignedTo' in result:
-            if result['assignedTo']:
-                GroupAssignee.objects.assign(group, result['assignedTo'],
-                                             acting_user)
-
-                if 'isSubscribed' not in result or result['assignedTo'] != request.user:
-                    GroupSubscription.objects.subscribe(
-                        group=group,
-                        user=result['assignedTo'],
-                        reason=GroupSubscriptionReason.assigned,
-                    )
-            else:
-                GroupAssignee.objects.deassign(group, acting_user)
-
         response = client.put(
             path='/projects/{}/{}/issues/'.format(
                 group.project.organization.slug,
diff --git a/src/sentry/api/endpoints/project_group_index.py b/src/sentry/api/endpoints/project_group_index.py
index 54315f2285..aa204d23af 100644
--- a/src/sentry/api/endpoints/project_group_index.py
+++ b/src/sentry/api/endpoints/project_group_index.py
@@ -11,6 +11,7 @@ from rest_framework.response import Response
 
 from sentry.api.base import DocSection
 from sentry.api.bases.project import ProjectEndpoint, ProjectEventPermission
+from sentry.api.fields import UserField
 from sentry.api.serializers import serialize
 from sentry.api.serializers.models.group import (
     SUBSCRIPTION_REASON_MAP, StreamGroupSerializer
@@ -19,8 +20,8 @@ from sentry.app import search
 from sentry.constants import DEFAULT_SORT_OPTION
 from sentry.db.models.query import create_or_update
 from sentry.models import (
-    Activity, EventMapping, Group, GroupBookmark, GroupHash, GroupResolution,
-    GroupSeen, GroupSnooze, GroupStatus, GroupSubscription,
+    Activity, EventMapping, Group, GroupAssignee, GroupBookmark, GroupHash,
+    GroupResolution, GroupSeen, GroupSnooze, GroupStatus, GroupSubscription,
     GroupSubscriptionReason, Release, TagKey
 )
 from sentry.models.group import looks_like_short_id
@@ -81,7 +82,7 @@ class ValidationError(Exception):
     pass
 
 
-class GroupSerializer(serializers.Serializer):
+class GroupValidator(serializers.Serializer):
     status = serializers.ChoiceField(choices=zip(
         STATUS_CHOICES.keys(), STATUS_CHOICES.keys()
     ))
@@ -91,10 +92,17 @@ class GroupSerializer(serializers.Serializer):
     isSubscribed = serializers.BooleanField()
     merge = serializers.BooleanField()
     ignoreDuration = serializers.IntegerField()
+    assignedTo = UserField()
 
     # TODO(dcramer): remove in 9.0
     snoozeDuration = serializers.IntegerField()
 
+    def validate_assignedTo(self, attrs, source):
+        value = attrs[source]
+        if value and not self.context['project'].member_set.filter(user=value).exists():
+            raise serializers.ValidationError('Cannot assign to non-team member')
+        return attrs
+
 
 class ProjectGroupIndexEndpoint(ProjectEndpoint):
     doc_section = DocSection.EVENTS
@@ -305,6 +313,8 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
         :param int ignoreDuration: the number of minutes to ignore this issue.
         :param boolean isPublic: sets the issue to public or private.
         :param boolean merge: allows to merge or unmerge different issues.
+        :param string assignedTo: the username of the user that should be
+                                  assigned to this issue.
         :param boolean hasSeen: in case this API call is invoked with a user
                                 context this allows changing of the flag
                                 that indicates if the user has seen the
@@ -324,7 +334,11 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
         else:
             group_list = None
 
-        serializer = GroupSerializer(data=request.DATA, partial=True)
+        serializer = GroupValidator(
+            data=request.DATA,
+            partial=True,
+            context={'project': project},
+        )
         if not serializer.is_valid():
             return Response(serializer.errors, status=400)
 
@@ -523,6 +537,23 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
                             )
                         activity.send_notification()
 
+        if 'assignedTo' in result:
+            if result['assignedTo']:
+                for group in group_list:
+                    GroupAssignee.objects.assign(group, result['assignedTo'],
+                                                 acting_user)
+
+                    if 'isSubscribed' not in result or result['assignedTo'] != request.user:
+                        GroupSubscription.objects.subscribe(
+                            group=group,
+                            user=result['assignedTo'],
+                            reason=GroupSubscriptionReason.assigned,
+                        )
+                result['assignedTo'] = serialize(result['assignedTo'])
+            else:
+                for group in group_list:
+                    GroupAssignee.objects.deassign(group, acting_user)
+
         if result.get('hasSeen') and project.member_set.filter(user=acting_user).exists():
             for group in group_list:
                 instance, created = create_or_update(
diff --git a/tests/sentry/api/endpoints/test_project_group_index.py b/tests/sentry/api/endpoints/test_project_group_index.py
index 0c5f20f196..ad92cbeeb8 100644
--- a/tests/sentry/api/endpoints/test_project_group_index.py
+++ b/tests/sentry/api/endpoints/test_project_group_index.py
@@ -13,9 +13,9 @@ from exam import fixture
 from mock import patch
 
 from sentry.models import (
-    Activity, EventMapping, Group, GroupBookmark, GroupHash, GroupTagValue,
-    GroupResolution, GroupSeen, GroupSnooze, GroupStatus, GroupSubscription,
-    Release
+    Activity, EventMapping, Group, GroupAssignee, GroupBookmark, GroupHash,
+    GroupTagValue, GroupResolution, GroupSeen, GroupSnooze, GroupStatus,
+    GroupSubscription, Release
 )
 from sentry.testutils import APITestCase
 from sentry.testutils.helpers import parse_link_header
@@ -748,6 +748,69 @@ class GroupUpdateTest(APITestCase):
             transaction_id='abc123',
         )
 
+    def test_assign(self):
+        group1 = self.create_group(checksum='a' * 32, is_public=True)
+        group2 = self.create_group(checksum='b' * 32, is_public=True)
+        user = self.user
+
+        self.login_as(user=user)
+        url = '{url}?id={group1.id}'.format(
+            url=self.path,
+            group1=group1,
+        )
+        response = self.client.put(url, data={
+            'assignedTo': user.username,
+        })
+
+        assert response.status_code == 200
+        assert response.data['assignedTo']['id'] == six.text_type(user.id)
+
+        assert GroupAssignee.objects.filter(
+            group=group1, user=user
+        ).exists()
+
+        assert not GroupAssignee.objects.filter(
+            group=group2, user=user
+        ).exists()
+
+        assert Activity.objects.filter(
+            group=group1, user=user, type=Activity.ASSIGNED,
+        ).count() == 1
+
+        assert GroupSubscription.objects.filter(
+            user=user,
+            group=group1,
+            is_active=True,
+        ).exists()
+
+        response = self.client.put(url, data={
+            'assignedTo': '',
+        }, format='json')
+
+        assert response.status_code == 200, response.content
+        assert response.data['assignedTo'] is None
+
+        assert not GroupAssignee.objects.filter(
+            group=group1, user=user
+        ).exists()
+
+    def test_assign_non_member(self):
+        group = self.create_group(checksum='a' * 32, is_public=True)
+        member = self.user
+        non_member = self.create_user('bar@example.com')
+
+        self.login_as(user=member)
+
+        url = '{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(url, data={
+            'assignedTo': non_member.username,
+        }, format='json')
+
+        assert response.status_code == 400, response.content
+
 
 class GroupDeleteTest(APITestCase):
     @fixture

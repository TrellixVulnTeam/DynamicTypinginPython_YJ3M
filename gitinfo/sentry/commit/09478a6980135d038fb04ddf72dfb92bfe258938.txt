commit 09478a6980135d038fb04ddf72dfb92bfe258938
Author: Armin Ronacher <armin.ronacher@active-4.com>
Date:   Tue Sep 1 14:11:46 2015 +0200

    Added missing release documentation.

diff --git a/src/sentry/api/endpoints/project_releases.py b/src/sentry/api/endpoints/project_releases.py
index e690d7fa21..6d8670d15e 100644
--- a/src/sentry/api/endpoints/project_releases.py
+++ b/src/sentry/api/endpoints/project_releases.py
@@ -9,6 +9,29 @@ from sentry.api.base import DocSection
 from sentry.api.bases.project import ProjectEndpoint
 from sentry.api.serializers import serialize
 from sentry.models import Activity, Release
+from sentry.utils.apidocs import scenario, attach_scenarios
+
+
+@scenario('CreateNewRelease')
+def create_new_release_scenario(runner):
+    runner.request(
+        method='POST',
+        path='/projects/%s/%s/releases/' % (
+            runner.org.slug, runner.default_project.slug),
+        data={
+            'version': '2.0rc2',
+            'ref': '6ba09a7c53235ee8a8fa5ee4c1ca8ca886e7fdbb',
+        }
+    )
+
+
+@scenario('ListReleases')
+def list_releases_scenario(runner):
+    runner.request(
+        method='GET',
+        path='/projects/%s/%s/releases/' % (
+            runner.org.slug, runner.default_project.slug)
+    )
 
 
 class ReleaseSerializer(serializers.Serializer):
@@ -22,6 +45,7 @@ class ReleaseSerializer(serializers.Serializer):
 class ProjectReleasesEndpoint(ProjectEndpoint):
     doc_section = DocSection.RELEASES
 
+    @attach_scenarios([list_releases_scenario])
     def get(self, request, project):
         """
         List a Project's Releases
@@ -29,8 +53,12 @@ class ProjectReleasesEndpoint(ProjectEndpoint):
 
         Retrieve a list of releases for a given project.
 
-        To find releases for a given version the 'query' parameter may be to
-        create a "version STARTS WITH" filter.
+        :pparam string organization_slug: the slug of the organization the
+                                          release belongs to.
+        :pparam string project_slug: the slug of the project to list the
+                                     releases of.
+        :qparam string query: this parameter can beu sed to create a
+                              "starts with" filter for the version.
         """
         query = request.GET.get('query')
 
@@ -50,12 +78,37 @@ class ProjectReleasesEndpoint(ProjectEndpoint):
             on_results=lambda x: serialize(x, request.user),
         )
 
+    @attach_scenarios([create_new_release_scenario])
     def post(self, request, project):
         """
         Create a New Release
         ````````````````````
 
-        Create a new release for the given project.
+        Create a new release for the given project.  Releases are used by
+        Sentry to improve it's error reporting abilities by correlating
+        first seen events with the release that might have introduced the
+        problem.
+
+        Releases are also necessary for sourcemaps and other debug features
+        that require manual upload for functioning well.
+
+        :pparam string organization_slug: the slug of the organization the
+                                          release belongs to.
+        :pparam string project_slug: the slug of the project to create a
+                                     release for.
+        :param string version: a version identifier for this release.  Can
+                               be a version number, a commit hash etc.
+        :param string ref: an optional commit reference.  This is useful if
+                           a tagged version has been provided.
+        :param url url: a URL that points to the release.  This can be the
+                        path to an online interface to the sourcecode
+                        for instance.
+        :param datetime dateStarted: an optional date that indicates when the
+                                     release process started.
+        :param datetime dateReleased: an optional date that indicates when
+                                      the release went live.  If not provided
+                                      the current time is assumed.
+        :auth: required
         """
         serializer = ReleaseSerializer(data=request.DATA)
 
diff --git a/src/sentry/api/endpoints/release_details.py b/src/sentry/api/endpoints/release_details.py
index af08611f2d..f84918ce40 100644
--- a/src/sentry/api/endpoints/release_details.py
+++ b/src/sentry/api/endpoints/release_details.py
@@ -8,6 +8,45 @@ from sentry.api.bases.project import ProjectEndpoint
 from sentry.api.exceptions import ResourceDoesNotExist
 from sentry.api.serializers import serialize
 from sentry.models import Release, ReleaseFile
+from sentry.utils.apidocs import scenario, attach_scenarios
+
+
+@scenario('RetrieveRelease')
+def retrieve_release_scenario(runner):
+    runner.request(
+        method='GET',
+        path='/projects/%s/%s/releases/%s/' % (
+            runner.org.slug, runner.default_project.slug,
+            runner.default_release.version)
+    )
+
+
+@scenario('UpdateRelease')
+def update_release_scenario(runner):
+    release = runner.utils.create_release(runner.default_project,
+                                          runner.me, version='3000')
+    runner.request(
+        method='PUT',
+        path='/projects/%s/%s/releases/%s/' % (
+            runner.org.slug, runner.default_project.slug,
+            release.version),
+        data={
+            'url': 'https://vcshub.invalid/user/project/refs/deadbeef1337',
+            'ref': 'deadbeef1337'
+        }
+    )
+
+
+@scenario('DeleteRelease')
+def delete_release_scenario(runner):
+    release = runner.utils.create_release(runner.default_project,
+                                          runner.me, version='4000')
+    runner.request(
+        method='DELETE',
+        path='/projects/%s/%s/releases/%s/' % (
+            runner.org.slug, runner.default_project.slug,
+            release.version)
+    )
 
 
 class ReleaseSerializer(serializers.Serializer):
@@ -20,12 +59,20 @@ class ReleaseSerializer(serializers.Serializer):
 class ReleaseDetailsEndpoint(ProjectEndpoint):
     doc_section = DocSection.RELEASES
 
+    @attach_scenarios([retrieve_release_scenario])
     def get(self, request, project, version):
         """
         Retrieve a Release
         ``````````````````
 
         Return details on an individual release.
+
+        :pparam string organization_slug: the slug of the organization the
+                                          release belongs to.
+        :pparam string project_slug: the slug of the project to retrieve the
+                                     release of.
+        :pparam string version: the version identifier of the release.
+        :auth: required
         """
         try:
             release = Release.objects.get(
@@ -37,12 +84,31 @@ class ReleaseDetailsEndpoint(ProjectEndpoint):
 
         return Response(serialize(release, request.user))
 
+    @attach_scenarios([update_release_scenario])
     def put(self, request, project, version):
         """
         Update a Release
         ````````````````
 
-        Update a release.
+        Update a release.  This can change some metadata associated with
+        the release (the ref, url, and dates).
+
+        :pparam string organization_slug: the slug of the organization the
+                                          release belongs to.
+        :pparam string project_slug: the slug of the project to change the
+                                     release of.
+        :pparam string version: the version identifier of the release.
+        :param string ref: an optional commit reference.  This is useful if
+                           a tagged version has been provided.
+        :param url url: a URL that points to the release.  This can be the
+                        path to an online interface to the sourcecode
+                        for instance.
+        :param datetime dateStarted: an optional date that indicates when the
+                                     release process started.
+        :param datetime dateReleased: an optional date that indicates when
+                                      the release went live.  If not provided
+                                      the current time is assumed.
+        :auth: required
         """
         # TODO(dcramer): handle Activity creation
         try:
@@ -75,12 +141,20 @@ class ReleaseDetailsEndpoint(ProjectEndpoint):
 
         return Response(serialize(release, request.user))
 
+    @attach_scenarios([delete_release_scenario])
     def delete(self, request, project, version):
         """
         Delete a Release
         ````````````````
 
         Permanently remove a release and all of its files.
+
+        :pparam string organization_slug: the slug of the organization the
+                                          release belongs to.
+        :pparam string project_slug: the slug of the project to delete the
+                                     release of.
+        :pparam string version: the version identifier of the release.
+        :auth: required
         """
         try:
             release = Release.objects.get(
diff --git a/src/sentry/api/endpoints/release_file_details.py b/src/sentry/api/endpoints/release_file_details.py
index 9459787118..eb5981a9e0 100644
--- a/src/sentry/api/endpoints/release_file_details.py
+++ b/src/sentry/api/endpoints/release_file_details.py
@@ -7,6 +7,58 @@ from sentry.api.base import DocSection
 from sentry.api.bases.project import ProjectEndpoint
 from sentry.api.serializers import serialize
 from sentry.models import Release, ReleaseFile
+from sentry.utils.apidocs import scenario, attach_scenarios
+
+
+@scenario('RetrieveReleaseFile')
+def retrieve_file_scenario(runner):
+    rf = runner.utils.create_release_file(
+        project=runner.default_project,
+        release=runner.default_release,
+        path='/demo/readme.txt',
+        contents='Hello World!'
+    )
+    runner.request(
+        method='GET',
+        path='/projects/%s/%s/releases/%s/files/%s/' % (
+            runner.org.slug, runner.default_project.slug,
+            runner.default_release.version, rf.id)
+    )
+
+
+@scenario('UpdateReleaseFile')
+def update_file_scenario(runner):
+    rf = runner.utils.create_release_file(
+        project=runner.default_project,
+        release=runner.default_release,
+        path='/demo/hello.txt',
+        contents='Good bye World!'
+    )
+    runner.request(
+        method='PUT',
+        path='/projects/%s/%s/releases/%s/files/%s/' % (
+            runner.org.slug, runner.default_project.slug,
+            runner.default_release.version, rf.id),
+        data={
+            'name': '/demo/goodbye.txt'
+        }
+    )
+
+
+@scenario('DeleteReleaseFile')
+def delete_file_scenario(runner):
+    rf = runner.utils.create_release_file(
+        project=runner.default_project,
+        release=runner.default_release,
+        path='/demo/badfile.txt',
+        contents='Whatever!'
+    )
+    runner.request(
+        method='DELETE',
+        path='/projects/%s/%s/releases/%s/files/%s/' % (
+            runner.org.slug, runner.default_project.slug,
+            runner.default_release.version, rf.id)
+    )
 
 
 class ReleaseFileSerializer(serializers.Serializer):
@@ -16,12 +68,23 @@ class ReleaseFileSerializer(serializers.Serializer):
 class ReleaseFileDetailsEndpoint(ProjectEndpoint):
     doc_section = DocSection.RELEASES
 
+    @attach_scenarios([retrieve_file_scenario])
     def get(self, request, project, version, file_id):
         """
         Retrieve a File
         ```````````````
 
-        Return details on an individual file within a release.
+        Return details on an individual file within a release.  This does
+        not actually return the contents of the file, just the associated
+        metadata.
+
+        :pparam string organization_slug: the slug of the organization the
+                                          release belongs to.
+        :pparam string project_slug: the slug of the project to retrieve the
+                                     file of.
+        :pparam string version: the version identifier of the release.
+        :pparam string file_id: the ID of the file to retrieve.
+        :auth: required
         """
         release = Release.objects.get(
             project=project,
@@ -34,12 +97,23 @@ class ReleaseFileDetailsEndpoint(ProjectEndpoint):
 
         return Response(serialize(releasefile, request.user))
 
+    @attach_scenarios([update_file_scenario])
     def put(self, request, project, version, file_id):
         """
         Update a File
         `````````````
 
-        Update metadata about an existing file.
+        Update metadata of an existing file.  Currently only the name of
+        the file can be changed.
+
+        :pparam string organization_slug: the slug of the organization the
+                                          release belongs to.
+        :pparam string project_slug: the slug of the project to update the
+                                     file of.
+        :pparam string version: the version identifier of the release.
+        :pparam string file_id: the ID of the file to update.
+        :param string name: the new name of the file.
+        :auth: required
         """
         release = Release.objects.get(
             project=project,
@@ -62,6 +136,7 @@ class ReleaseFileDetailsEndpoint(ProjectEndpoint):
 
         return Response(serialize(releasefile, request.user))
 
+    @attach_scenarios([delete_file_scenario])
     def delete(self, request, project, version, file_id):
         """
         Delete a File
@@ -70,6 +145,14 @@ class ReleaseFileDetailsEndpoint(ProjectEndpoint):
         Permanently remove a file from a release.
 
         This will also remove the physical file from storage.
+
+        :pparam string organization_slug: the slug of the organization the
+                                          release belongs to.
+        :pparam string project_slug: the slug of the project to delete the
+                                     file of.
+        :pparam string version: the version identifier of the release.
+        :pparam string file_id: the ID of the file to delete.
+        :auth: required
         """
         release = Release.objects.get(
             project=project,
diff --git a/src/sentry/api/endpoints/release_files.py b/src/sentry/api/endpoints/release_files.py
index 4c2bf2698e..992e0ac877 100644
--- a/src/sentry/api/endpoints/release_files.py
+++ b/src/sentry/api/endpoints/release_files.py
@@ -1,5 +1,7 @@
 from __future__ import absolute_import
 
+from StringIO import StringIO
+
 from django.db import IntegrityError, transaction
 from rest_framework.negotiation import DefaultContentNegotiation
 from rest_framework.parsers import FormParser, MultiPartParser
@@ -10,6 +12,39 @@ from sentry.api.bases.project import ProjectEndpoint
 from sentry.api.exceptions import ResourceDoesNotExist
 from sentry.api.serializers import serialize
 from sentry.models import File, Release, ReleaseFile
+from sentry.utils.apidocs import scenario, attach_scenarios
+
+
+@scenario('UploadReleaseFile')
+def upload_file_scenario(runner):
+    runner.request(
+        method='POST',
+        path='/projects/%s/%s/releases/%s/files/' % (
+            runner.org.slug, runner.default_project.slug,
+            runner.default_release.version),
+        data={
+            'header': 'Content-Type:text/plain; encoding=utf-8',
+            'name': '/demo/hello.py',
+            'file': ('hello.py', StringIO('print "Hello World!"')),
+        },
+        format='multipart'
+    )
+
+
+@scenario('ListReleaseFiles')
+def list_files_scenario(runner):
+    runner.utils.create_release_file(
+        project=runner.default_project,
+        release=runner.default_release,
+        path='/demo/message-for-you.txt',
+        contents='Hello World!'
+    )
+    runner.request(
+        method='GET',
+        path='/projects/%s/%s/releases/%s/files/' % (
+            runner.org.slug, runner.default_project.slug,
+            runner.default_release.version)
+    )
 
 
 class ConditionalContentNegotiation(DefaultContentNegotiation):
@@ -30,12 +65,20 @@ class ReleaseFilesEndpoint(ProjectEndpoint):
 
     content_negotiation_class = ConditionalContentNegotiation
 
+    @attach_scenarios([list_files_scenario])
     def get(self, request, project, version):
         """
         List a Release's Files
         ``````````````````````
 
         Retrieve a list of files for a given release.
+
+        :pparam string organization_slug: the slug of the organization the
+                                          release belongs to.
+        :pparam string project_slug: the slug of the project to list the
+                                     release files of.
+        :pparam string version: the version identifier of the release.
+        :auth: required
         """
         try:
             release = Release.objects.get(
@@ -51,6 +94,7 @@ class ReleaseFilesEndpoint(ProjectEndpoint):
 
         return Response(serialize(file_list, request.user))
 
+    @attach_scenarios([upload_file_scenario])
     def post(self, request, project, version):
         """
         Upload a New File
@@ -64,6 +108,20 @@ class ReleaseFilesEndpoint(ProjectEndpoint):
         The optional 'name' attribute should reflect the absolute path
         that this file will be referenced as. For example, in the case of
         JavaScript you might specify the full web URI.
+
+        :pparam string organization_slug: the slug of the organization the
+                                          release belongs to.
+        :pparam string project_slug: the slug of the project to change the
+                                     release of.
+        :pparam string version: the version identifier of the release.
+        :param string name: the name (full path) of the file.
+        :param file file: the multipart encoded file.
+        :param string header: this parameter can be supplied multiple times
+                              to attach headers to the file.  Each header
+                              is a string in the format ``key:value``.  For
+                              instance it can be used to define a content
+                              type.
+        :auth: required
         """
         try:
             release = Release.objects.get(
diff --git a/src/sentry/utils/apidocs.py b/src/sentry/utils/apidocs.py
index 1e28408146..c57532d670 100644
--- a/src/sentry/utils/apidocs.py
+++ b/src/sentry/utils/apidocs.py
@@ -4,7 +4,9 @@ import json
 import base64
 import inspect
 import requests
+import mimetypes
 
+from StringIO import StringIO
 from pytz import utc
 from datetime import datetime, timedelta
 from random import randint
@@ -162,6 +164,8 @@ def iter_endpoints():
 
 def scenario(ident):
     def decorator(f):
+        if ident in scenarios:
+            raise RuntimeError('Scenario duplicate: %s' % ident)
         scenarios[ident] = f
         f.api_scenario_ident = ident
         return f
@@ -317,6 +321,24 @@ class MockUtils(object):
         )
         return release
 
+    def create_release_file(self, project, release, path,
+                            content_type=None, contents=None):
+        from sentry.models import File, ReleaseFile
+        if content_type is None:
+            content_type = mimetypes.guess_type(path)[0] or 'text/plain'
+            if content_type.startswith('text/'):
+                content_type += '; encoding=utf-8'
+        f = File(name=path.rsplit('/', 1)[-1], type='release.file', headers={
+            'Content-Type': content_type
+        })
+        f.putfile(StringIO(contents or ''))
+        return ReleaseFile.objects.create(
+            project=project,
+            release=release,
+            file=f,
+            name=path
+        )
+
     def create_event(self, project, release, platform='python', raw=True):
         from sentry.utils.samples import create_sample_event
         event = create_sample_event(
@@ -387,16 +409,29 @@ class Runner(object):
         finally:
             org.delete()
 
-    def request(self, method, path, headers=None, data=None, api_key=None):
+    def request(self, method, path, headers=None, data=None, api_key=None,
+                format='json'):
         if api_key is None:
             api_key = self.api_key
         path = '/api/0/' + path.lstrip('/')
         headers = dict(headers or {})
 
+        request_is_json = True
         body = None
+        files = None
+        was_multipart = False
         if data is not None:
-            body = json.dumps(data, sort_keys=True)
-            headers['Content-Type'] = 'application/json'
+            if format == 'json':
+                body = json.dumps(data, sort_keys=True)
+                headers['Content-Type'] = 'application/json'
+            elif format == 'multipart':
+                files = {}
+                for key, value in data.items():
+                    if hasattr(value, 'read') or isinstance(value, tuple):
+                        files[key] = value
+                        del data[key]
+                        was_multipart = True
+                body = data
 
         req_headers = dict(headers)
         req_headers['Host'] = 'app.getsentry.com'
@@ -408,9 +443,10 @@ class Runner(object):
             path,
         )
 
-        response = requests.request(method=method, url=url,
+        response = requests.request(method=method, url=url, files=files,
                                     headers=req_headers, data=body)
         response_headers = dict(response.headers)
+
         # Don't want those
         response_headers.pop('server', None)
         response_headers.pop('date', None)
@@ -422,12 +458,18 @@ class Runner(object):
             response_data = response.text
             is_json = False
 
+        if was_multipart:
+            headers['Content-Type'] = response.request.headers['content-type']
+            data = response.request.body
+            request_is_json = False
+
         rv = {
             'request': {
                 'method': method,
                 'path': path,
                 'headers': headers,
                 'data': data,
+                'is_json': request_is_json,
             },
             'response': {
                 'headers': response_headers,

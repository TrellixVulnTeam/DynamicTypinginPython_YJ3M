commit a4575b86875f0b1b8f914c0e44b523d361a83e44
Author: Lyn Nagara <lyn.nagara@gmail.com>
Date:   Thu Jul 12 10:51:27 2018 -0700

    feat(discover): Add order by option for aggregate functions (#9009)
    
    Allow ordering by any aggregate function present in the query

diff --git a/src/sentry/static/sentry/app/views/organizationDiscover/discover.jsx b/src/sentry/static/sentry/app/views/organizationDiscover/discover.jsx
index 44aa0c51c8..7f4df02807 100644
--- a/src/sentry/static/sentry/app/views/organizationDiscover/discover.jsx
+++ b/src/sentry/static/sentry/app/views/organizationDiscover/discover.jsx
@@ -74,11 +74,16 @@ export default class OrganizationDiscover extends React.Component {
     const columns = queryBuilder.getColumns();
     const query = queryBuilder.getInternal();
 
-    // If there are aggregations, only allow summarized fields in orderby
-    const hasAggregations = query.aggregations.length > 0;
+    // If there are valid aggregations, only allow summarized fields and aggregations in orderby
+    const validAggregations = query.aggregations.filter(agg =>
+      isValidAggregation(agg, columns)
+    );
+
+    const hasAggregations = validAggregations > 0;
+
     const hasFields = query.fields.length > 0;
 
-    return columns.reduce((acc, {name}) => {
+    const columnOptions = columns.reduce((acc, {name}) => {
       if (hasAggregations) {
         const isInvalidField = hasFields && !query.fields.includes(name);
         if (!hasFields || isInvalidField) {
@@ -92,6 +97,19 @@ export default class OrganizationDiscover extends React.Component {
         {value: `-${name}`, label: `${name} desc`},
       ];
     }, []);
+
+    const aggregationOptions = [
+      // Ensure aggregations are unique (since users might input duplicates)
+      ...new Set(validAggregations.map(aggregation => aggregation[2])),
+    ].reduce((acc, agg) => {
+      return [
+        ...acc,
+        {value: agg, label: `${agg} asc`},
+        {value: `-${agg}`, label: `${agg} desc`},
+      ];
+    }, []);
+
+    return [...columnOptions, ...aggregationOptions];
   };
 
   getSummarizePlaceholder = () => {
diff --git a/src/sentry/static/sentry/app/views/organizationDiscover/queryBuilder.jsx b/src/sentry/static/sentry/app/views/organizationDiscover/queryBuilder.jsx
index fdb8e8e3c7..4c528f6ab9 100644
--- a/src/sentry/static/sentry/app/views/organizationDiscover/queryBuilder.jsx
+++ b/src/sentry/static/sentry/app/views/organizationDiscover/queryBuilder.jsx
@@ -4,6 +4,7 @@ import moment from 'moment-timezone';
 
 import {Client} from 'app/api';
 import {COLUMNS, PROMOTED_TAGS} from './data';
+import {isValidAggregation} from './aggregations/utils';
 
 const DATE_TIME_FORMAT = 'YYYY-MM-DDTHH:mm:ss';
 
@@ -31,7 +32,8 @@ function applyDefaults(query) {
 
 /**
  * This function is responsible for storing and managing updates to query state,
- * It applies sensible defaults if query parameters are not provided on initialization.
+ * It applies sensible defaults if query parameters are not provided on
+ * initialization.
  */
 export default function createQueryBuilder(initial = {}, organization) {
   const query = applyDefaults(initial);
@@ -49,6 +51,13 @@ export default function createQueryBuilder(initial = {}, organization) {
     load,
   };
 
+  /**
+   * Loads tags keys for user's projectsand updates `tags` with the result.
+   * If the request fails updates `tags` to be the hardcoded list of predefined
+   * promoted tags.
+   *
+   * @returns {Promise<Void>}
+   */
   function load() {
     return fetch({
       projects: defaultProjects,
@@ -66,19 +75,32 @@ export default function createQueryBuilder(initial = {}, organization) {
       });
   }
 
+  /**
+   * Returns the query object (internal state of the query)
+   *
+   * @returns {Object}
+   */
   function getInternal() {
     return query;
   }
 
+  /**
+   * Returns the external representation of the query as required by Snuba.
+   * Applies default projects and fields if these properties were not specified
+   * by the user.
+   *
+   * @returns {Object}
+   */
   function getExternal() {
     // Default to all projects if none is selected
     const projects = query.projects.length ? query.projects : defaultProjects;
 
-    // Default to all fields if there are none selected, and no aggregation is specified
+    // Default to all fields if there are none selected, and no aggregation is
+    // specified
     const useDefaultFields =
       !query.fields.length && !query.aggregations.length && !query.groupby;
 
-    const fields = useDefaultFields ? COLUMNS.map(({name}) => name) : query.fields;
+    const fields = useDefaultFields ? getColumns().map(({name}) => name) : query.fields;
 
     // Remove orderby property if it is not set
     if (!query.orderby) {
@@ -92,33 +114,48 @@ export default function createQueryBuilder(initial = {}, organization) {
     };
   }
 
+  /**
+   * Updates field in query to value provided. Also updates orderby and limit
+   * parameters if this causes their values to become invalid.
+   *
+   * @param {String} field Name of field to be updated
+   * @param {*} value Value to update field to
+   * @returns {Void}
+   */
   function updateField(field, value) {
     query[field] = value;
 
-    // If there are aggregations, we need to remove or update the orderby parameter
-    // if it's not in the list of selected fields
-    const hasAggregations = query.aggregations.length > 0;
-    const hasFields = query.fields.length > 0;
+    // Ignore non valid aggregations (e.g. user halfway inputting data)
+    const validAggregations = query.aggregations.filter(agg =>
+      isValidAggregation(agg, getColumns())
+    );
+
     const orderbyField = (query.orderby || '').replace(/^-/, '');
     const hasOrderFieldInFields = query.fields.includes(orderbyField);
+    const hasOrderFieldInAggregations = query.aggregations.some(
+      agg => orderbyField === agg[2]
+    );
 
-    if (hasAggregations) {
-      // Check for invalid order by parameter
-      if (hasFields && !hasOrderFieldInFields) {
-        query.orderby = query.fields ? query.fields[0] : null;
-      }
+    const hasInvalidOrderbyField = !hasOrderFieldInFields && !hasOrderFieldInAggregations;
 
-      // Disable orderby for aggregations without any summarize fields
-      if (!hasFields) {
-        query.orderby = null;
-      }
+    // If orderby value becomes invalid, update it to the first valid aggregation
+    if (validAggregations.length > 0 && hasInvalidOrderbyField) {
+      query.orderby = validAggregations[0][2];
     }
 
+    // Snuba doesn't allow limit without orderby
     if (!query.orderby) {
       query.limit = null;
     }
   }
 
+  /**
+   * Fetches either the query provided as an argument or the current query state
+   * if this is not provided and returns the result wrapped in a promise
+   *
+   * @param {Object} [data] Optional field to provide data to fetch
+   * @returns {Promise<Object>}
+   */
   function fetch(data) {
     const api = new Client();
     const endpoint = `/organizations/${organization.slug}/discover/`;
@@ -129,7 +166,11 @@ export default function createQueryBuilder(initial = {}, organization) {
     });
   }
 
-  // Get all columns, including tags
+  /**
+   * Returns all column objects, including tags
+   *
+   * @returns {Array<{name: String, type: String}>}
+   */
   function getColumns() {
     return [...COLUMNS, ...tags];
   }
diff --git a/tests/js/spec/views/organizationDiscover/queryBuilder.spec.jsx b/tests/js/spec/views/organizationDiscover/queryBuilder.spec.jsx
index a2f5312a5b..4a9d5b63fa 100644
--- a/tests/js/spec/views/organizationDiscover/queryBuilder.spec.jsx
+++ b/tests/js/spec/views/organizationDiscover/queryBuilder.spec.jsx
@@ -1,20 +1,22 @@
 import createQueryBuilder from 'app/views/organizationDiscover/queryBuilder';
 
 describe('Query Builder', function() {
-  it('generates default query with all projects', function() {
-    const queryBuilder = createQueryBuilder(
-      {},
-      TestStubs.Organization({projects: [TestStubs.Project()]})
-    );
-    const external = queryBuilder.getExternal();
-
-    expect(external.projects).toEqual([2]);
-    expect(external.fields).toEqual(expect.arrayContaining([expect.any(String)]));
-    expect(external.fields).toHaveLength(47);
-    expect(external.conditions).toHaveLength(0);
-    expect(external.aggregations).toHaveLength(0);
-    expect(external.orderby).toBe('-timestamp');
-    expect(external.limit).toBe(1000);
+  describe('applyDefaults()', function() {
+    it('generates default query with all projects', function() {
+      const queryBuilder = createQueryBuilder(
+        {},
+        TestStubs.Organization({projects: [TestStubs.Project()]})
+      );
+      const external = queryBuilder.getExternal();
+
+      expect(external.projects).toEqual([2]);
+      expect(external.fields).toEqual(expect.arrayContaining([expect.any(String)]));
+      expect(external.fields).toHaveLength(47);
+      expect(external.conditions).toHaveLength(0);
+      expect(external.aggregations).toHaveLength(0);
+      expect(external.orderby).toBe('-timestamp');
+      expect(external.limit).toBe(1000);
+    });
   });
 
   describe('loads()', function() {
@@ -97,21 +99,11 @@ describe('Query Builder', function() {
       expect(query.conditions).toEqual([['event_id', '=', 'event1']]);
     });
 
-    it('updates orderby if there is an aggregation and value is not a summarized field', function() {
-      queryBuilder.updateField('fields', ['environment']);
-      queryBuilder.updateField('aggregations', [['count', null, 'count']]);
-
-      const query = queryBuilder.getInternal();
-      expect(query.orderby).toEqual('environment');
-    });
-
-    it('removes orderby and limit if there is aggregation but no summarize', function() {
-      queryBuilder.updateField('fields', []);
-      queryBuilder.updateField('aggregations', [['count', null, 'count']]);
+    it('updates orderby if there is an aggregation and value is not a valid field', function() {
+      queryBuilder.updateField('aggregations', [['count()', null, 'count']]);
 
       const query = queryBuilder.getInternal();
-      expect(query.orderby).toEqual(null);
-      expect(query.limit).toEqual(null);
+      expect(query.orderby).toEqual('count');
     });
   });
 });

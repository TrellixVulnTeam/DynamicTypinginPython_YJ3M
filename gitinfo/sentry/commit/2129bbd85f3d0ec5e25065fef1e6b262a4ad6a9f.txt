commit 2129bbd85f3d0ec5e25065fef1e6b262a4ad6a9f
Author: Markus Unterwaditzer <markus@unterwaditzer.net>
Date:   Fri May 24 15:44:47 2019 +0200

    ref: Remove symbolizer (#13356)
    
    * ref: Remove symbolizer
    
    * ref: Remove useless redis writes
    
    * fix: Fix imports
    
    * ref: Unindent function
    
    * ref: Move conversion func to plugin.py

diff --git a/src/sentry/coreapi.py b/src/sentry/coreapi.py
index 1838c7988e..c350bd8ce2 100644
--- a/src/sentry/coreapi.py
+++ b/src/sentry/coreapi.py
@@ -77,7 +77,8 @@ class APIRateLimited(APIError):
 
 
 class Auth(object):
-    def __init__(self, client=None, version=None, secret_key=None, public_key=None, is_public=False):
+    def __init__(self, client=None, version=None, secret_key=None,
+                 public_key=None, is_public=False):
         self.client = client
         self.version = version
         self.secret_key = secret_key
diff --git a/src/sentry/lang/native/error.py b/src/sentry/lang/native/error.py
new file mode 100644
index 0000000000..c669311a46
--- /dev/null
+++ b/src/sentry/lang/native/error.py
@@ -0,0 +1,118 @@
+from __future__ import absolute_import
+
+import logging
+import six
+
+from sentry.utils.compat import implements_to_string
+from sentry.lang.native.utils import image_name
+from sentry.models import EventError
+from sentry.reprocessing import report_processing_issue
+
+FATAL_ERRORS = (
+    EventError.NATIVE_MISSING_DSYM,
+    EventError.NATIVE_BAD_DSYM,
+    EventError.NATIVE_SYMBOLICATOR_FAILED,
+)
+
+USER_FIXABLE_ERRORS = (
+    EventError.NATIVE_MISSING_DSYM,
+    EventError.NATIVE_MISSING_OPTIONALLY_BUNDLED_DSYM,
+    EventError.NATIVE_BAD_DSYM,
+    EventError.NATIVE_MISSING_SYMBOL,
+
+    # Emitted for e.g. broken minidumps
+    EventError.NATIVE_SYMBOLICATOR_FAILED,
+
+    # We want to let the user know when calling symbolicator failed, even
+    # though it's not user fixable.
+    EventError.NATIVE_INTERNAL_FAILURE,
+)
+
+logger = logging.getLogger(__name__)
+
+
+@implements_to_string
+class SymbolicationFailed(Exception):
+    message = None
+
+    def __init__(self, message=None, type=None, obj=None):
+        Exception.__init__(self)
+        self.message = six.text_type(message)
+        self.type = type
+        self.image_name = None
+        self.image_path = None
+        if obj is not None:
+            self.image_uuid = six.text_type(obj.debug_id)
+            if obj.name:
+                self.image_path = obj.name
+                self.image_name = image_name(obj.name)
+            self.image_arch = obj.arch
+        else:
+            self.image_uuid = None
+            self.image_arch = None
+
+    @property
+    def is_user_fixable(self):
+        """These are errors that a user can fix themselves."""
+        return self.type in USER_FIXABLE_ERRORS
+
+    @property
+    def is_fatal(self):
+        """If this is true then a processing issues has to be reported."""
+        return self.type in FATAL_ERRORS
+
+    @property
+    def is_sdk_failure(self):
+        """An error that most likely happened because of a bad SDK."""
+        return self.type == EventError.NATIVE_UNKNOWN_IMAGE
+
+    def get_data(self):
+        """Returns the event data."""
+        rv = {'message': self.message, 'type': self.type}
+        if self.image_path is not None:
+            rv['image_path'] = self.image_path
+        if self.image_uuid is not None:
+            rv['image_uuid'] = self.image_uuid
+        if self.image_arch is not None:
+            rv['image_arch'] = self.image_arch
+        return rv
+
+    def __str__(self):
+        rv = []
+        if self.type is not None:
+            rv.append(u'%s: ' % self.type)
+        rv.append(self.message or 'no information available')
+        if self.image_uuid is not None:
+            rv.append(' image-uuid=%s' % self.image_uuid)
+        if self.image_name is not None:
+            rv.append(' image-name=%s' % self.image_name)
+        return u''.join(rv)
+
+
+def write_error(e, data, errors=None):
+    # User fixable but fatal errors are reported as processing
+    # issues
+    if e.is_user_fixable and e.is_fatal:
+        report_processing_issue(
+            data,
+            scope='native',
+            object='dsym:%s' % e.image_uuid,
+            type=e.type,
+            data=e.get_data()
+        )
+
+    # This in many ways currently does not really do anything.
+    # The reason is that once a processing issue is reported
+    # the event will only be stored as a raw event and no
+    # group will be generated.  As a result it also means that
+    # we will not have any user facing event or error showing
+    # up at all.  We want to keep this here though in case we
+    # do not want to report some processing issues (eg:
+    # optional difs)
+    if e.is_user_fixable or e.is_sdk_failure:
+        if errors is None:
+            errors = data.setdefault('errors', [])
+        errors.append(e.get_data())
+    else:
+        logger.debug('Failed to symbolicate with native backend',
+                     exc_info=True)
diff --git a/src/sentry/lang/native/minidump.py b/src/sentry/lang/native/minidump.py
index 462a358fbd..38c20a5c8c 100644
--- a/src/sentry/lang/native/minidump.py
+++ b/src/sentry/lang/native/minidump.py
@@ -6,9 +6,9 @@ import dateutil.parser as dp
 from msgpack import unpack, Unpacker, UnpackException, ExtraData
 
 from sentry.event_manager import validate_and_set_timestamp
-from sentry.lang.native.utils import get_sdk_from_event, handle_symbolication_failed, merge_symbolicated_frame
+from sentry.lang.native.utils import get_sdk_from_event, merge_symbolicated_frame
 from sentry.lang.native.symbolicator import merge_symbolicator_image
-from sentry.lang.native.symbolizer import SymbolicationFailed
+from sentry.lang.native.error import SymbolicationFailed, write_error
 from sentry.models.eventerror import EventError
 from sentry.attachments import attachment_cache
 from sentry.coreapi import cache_key_for_event
@@ -144,7 +144,7 @@ def merge_symbolicator_minidump_response(data, response):
         image = {}
         merge_symbolicator_image(
             image, complete_image, sdk_info,
-            lambda e: handle_symbolication_failed(e, data=data)
+            lambda e: write_error(e, data)
         )
         images.append(image)
 
@@ -164,7 +164,7 @@ def merge_symbolicator_minidump_response(data, response):
     else:
         error = SymbolicationFailed(message='minidump has no thread list',
                                     type=EventError.NATIVE_SYMBOLICATOR_FAILED)
-        handle_symbolication_failed(error, data=data)
+        write_error(error, data)
 
     for complete_stacktrace in response['stacktraces']:
         is_requesting = complete_stacktrace.get('is_requesting')
diff --git a/src/sentry/lang/native/plugin.py b/src/sentry/lang/native/plugin.py
index 4c8a301dbb..b888f540cb 100644
--- a/src/sentry/lang/native/plugin.py
+++ b/src/sentry/lang/native/plugin.py
@@ -3,24 +3,21 @@ from __future__ import absolute_import
 import uuid
 import logging
 
-from symbolic import parse_addr, find_best_instruction, arch_get_ip_reg_name, \
+from symbolic import LineInfo, parse_addr, find_best_instruction, arch_get_ip_reg_name, \
     ObjectLookup
 from symbolic.utils import make_buffered_slice_reader
 
 from sentry import options
-from sentry.cache import default_cache
-from sentry.coreapi import cache_key_for_event
 from sentry.plugins import Plugin2
+from sentry.lang.native.error import write_error
 from sentry.lang.native.minidump import get_attached_minidump, is_minidump_event, merge_symbolicator_minidump_response
-from sentry.lang.native.symbolizer import Symbolizer, SymbolicationFailed
 from sentry.lang.native.symbolicator import run_symbolicator, merge_symbolicator_image, create_minidump_task, handle_symbolicator_response_status
-from sentry.lang.native.utils import get_sdk_from_event, handle_symbolication_failed, cpu_name_from_data, \
+from sentry.lang.native.utils import get_sdk_from_event, cpu_name_from_data, \
     merge_symbolicated_frame, rebase_addr, signal_from_data
 from sentry.lang.native.systemsymbols import lookup_system_symbols
 from sentry.models import Project
-from sentry.utils import metrics
 from sentry.utils.in_app import is_known_third_party
-from sentry.utils.safe import get_path
+from sentry.utils.safe import get_path, trim
 from sentry.stacktraces.processing import StacktraceProcessor
 
 logger = logging.getLogger(__name__)
@@ -36,10 +33,6 @@ def request_id_cache_key_for_event(data):
     return u'symbolicator:{1}:{0}'.format(data['project'], data['event_id'])
 
 
-def minidump_reprocessed_cache_key_for_event(data):
-    return u'symbolicator-minidump-processed:{1}:{0}'.format(data['project'], data['event_id'])
-
-
 class NativeStacktraceProcessor(StacktraceProcessor):
     supported_platforms = ('cocoa', 'native')
     # TODO(ja): Clean up all uses of image type "apple", "uuid", "id" and "name"
@@ -52,7 +45,6 @@ class NativeStacktraceProcessor(StacktraceProcessor):
         self.signal = signal_from_data(self.data)
 
         self.sym = None
-        self.difs_referenced = set()
 
         images = get_path(self.data, 'debug_meta', 'images', default=(),
                           filter=self._is_valid_image)
@@ -76,15 +68,6 @@ class NativeStacktraceProcessor(StacktraceProcessor):
 
     def close(self):
         StacktraceProcessor.close(self)
-        if self.difs_referenced:
-            metrics.incr(
-                'dsyms.processed',
-                amount=len(self.difs_referenced),
-                skip_internal=True,
-                tags={
-                    'project_id': self.project.id,
-                },
-            )
 
     def find_best_instruction(self, processable_frame):
         """Given a frame, stacktrace info and frame index this returns the
@@ -145,7 +128,7 @@ class NativeStacktraceProcessor(StacktraceProcessor):
             'debug_id': obj.debug_id if obj is not None else None,
             'symbolserver_match': None,
 
-            # `[]` is used to indicate to the symbolizer that the symbolicator
+            # `[]` is used to indicate that the symbolicator
             # deliberately discarded this frame.
             # If the symbolicator did run and was not able to symbolize the
             # frame, this value will be a list with the raw frame as only item.
@@ -158,7 +141,7 @@ class NativeStacktraceProcessor(StacktraceProcessor):
                     FRAME_CACHE_VERSION,
                     # Because the images can move around, we want to rebase
                     # the address for the cache key to be within the image
-                    # the same way as we do it in the symbolizer.
+                    # the same way as we do it in symbolicator
                     rebase_addr(instr_addr, obj),
                     obj.debug_id,
                     obj.arch,
@@ -170,8 +153,6 @@ class NativeStacktraceProcessor(StacktraceProcessor):
         if not self.available:
             return False
 
-        self.sym = Symbolizer()
-
         if options.get('symbolserver.enabled'):
             self.fetch_ios_system_symbols(processing_task)
 
@@ -251,7 +232,7 @@ class NativeStacktraceProcessor(StacktraceProcessor):
         for image, complete_image in zip(self.images, rv['modules']):
             merge_symbolicator_image(
                 image, complete_image, self.sdk_info,
-                lambda e: handle_symbolication_failed(e, data=self.data)
+                lambda e: write_error(e, self.data)
             )
 
         assert len(stacktraces) == len(rv['stacktraces'])
@@ -308,7 +289,6 @@ class NativeStacktraceProcessor(StacktraceProcessor):
     def process_frame(self, processable_frame, processing_task):
         frame = processable_frame.frame
         raw_frame = dict(frame)
-        errors = []
 
         # Ensure that package is set in the raw frame, mapped from the
         # debug_images array in the payload. Grouping and UI can use this path
@@ -318,31 +298,21 @@ class NativeStacktraceProcessor(StacktraceProcessor):
             raw_frame['package'] = obj and obj.code_file or None
 
         if processable_frame.cache_value is None:
-            # Construct a raw frame that is used by the symbolizer
-            # backend.  We only assemble the bare minimum we need here.
-            instruction_addr = processable_frame.data['instruction_addr']
-
-            debug_id = processable_frame.data['debug_id']
-            if debug_id is not None:
-                self.difs_referenced.add(debug_id)
-
-            try:
-                symbolicated_frames = self.sym.symbolize_frame(
-                    instruction_addr,
-                    self.sdk_info,
-                    symbolserver_match=processable_frame.data['symbolserver_match'],
-                    symbolicator_match=processable_frame.data.get('symbolicator_match'),
-                    trust=raw_frame.get('trust'),
+            symbolicator_match = processable_frame.data['symbolicator_match']
+
+            if not any(x["status"] != "symbolicated" for x in symbolicator_match):
+                symbolicated_frames = symbolicator_match
+            else:
+                symbolicated_frames = convert_ios_symbolserver_match(
+                    processable_frame.data['instruction_addr'],
+                    processable_frame.data['symbolserver_match']
                 )
-                if not symbolicated_frames:
-                    if raw_frame.get('trust') == 'scan':
-                        return [], [raw_frame], []
-                    else:
-                        return None, [raw_frame], []
-            except SymbolicationFailed as e:
-                errors = []
-                handle_symbolication_failed(e, data=self.data, errors=errors)
-                return [raw_frame], [raw_frame], errors
+
+            if not symbolicated_frames:
+                if raw_frame.get('trust') == 'scan':
+                    return [], [raw_frame], []
+                else:
+                    return None, [raw_frame], []
 
             _ignored = None  # Used to be in_app
             processable_frame.set_cache_value([_ignored, symbolicated_frames])
@@ -362,10 +332,6 @@ class NativeStacktraceProcessor(StacktraceProcessor):
 def reprocess_minidump(data):
     project = Project.objects.get_from_cache(id=data['project'])
 
-    minidump_is_reprocessed_cache_key = minidump_reprocessed_cache_key_for_event(data)
-    if default_cache.get(minidump_is_reprocessed_cache_key):
-        return
-
     minidump = get_attached_minidump(data)
 
     if not minidump:
@@ -384,13 +350,40 @@ def reprocess_minidump(data):
     if handle_symbolicator_response_status(data, response):
         merge_symbolicator_minidump_response(data, response)
 
-    event_cache_key = cache_key_for_event(data)
-    default_cache.set(event_cache_key, dict(data), 3600)
-    default_cache.set(minidump_is_reprocessed_cache_key, True, 3600)
-
     return data
 
 
+def convert_ios_symbolserver_match(instruction_addr, symbolserver_match):
+    if not symbolserver_match:
+        return []
+
+    symbol = symbolserver_match['symbol']
+    if symbol[:1] == '_':
+        symbol = symbol[1:]
+
+    # We still use this construct from symbolic for demangling (at least)
+    line_info = LineInfo(
+        sym_addr=parse_addr(symbolserver_match['addr']),
+        instr_addr=parse_addr(instruction_addr),
+        line=None,
+        lang=None,
+        symbol=symbol
+    )
+
+    function = line_info.function_name
+    package = symbolserver_match['object_name']
+
+    return {
+        'sym_addr': '0x%x' % (line_info.sym_addr,),
+        'instruction_addr': '0x%x' % (line_info.instr_addr,),
+        'function': function,
+        'symbol': symbol if function != symbol else None,
+        'filename': trim(line_info.rel_path, 256),
+        'abs_path': trim(line_info.abs_path, 256),
+        'package': package,
+    }
+
+
 class NativePlugin(Plugin2):
     can_disable = False
 
diff --git a/src/sentry/lang/native/symbolicator.py b/src/sentry/lang/native/symbolicator.py
index 65e84d4eeb..2cb3e96b1a 100644
--- a/src/sentry/lang/native/symbolicator.py
+++ b/src/sentry/lang/native/symbolicator.py
@@ -13,8 +13,8 @@ from requests.exceptions import RequestException
 from sentry import options
 from sentry.auth.system import get_system_token
 from sentry.cache import default_cache
-from sentry.lang.native.symbolizer import SymbolicationFailed
-from sentry.lang.native.utils import image_name, handle_symbolication_failed
+from sentry.lang.native.error import SymbolicationFailed, write_error
+from sentry.lang.native.utils import image_name
 from sentry.models.eventerror import EventError
 from sentry.utils import json, metrics
 from sentry.utils.in_app import is_known_third_party, is_optional_package
@@ -429,7 +429,7 @@ def handle_symbolicator_response_status(event_data, response_json):
         logger.error('Unexpected symbolicator status: %s', response_json['status'])
         error = SymbolicationFailed(type=EventError.NATIVE_INTERNAL_FAILURE)
 
-    handle_symbolication_failed(error, data=event_data)
+    write_error(error, event_data)
 
 
 def _poll_symbolication_task(sess, base_url, request_id, project_id):
diff --git a/src/sentry/lang/native/symbolizer.py b/src/sentry/lang/native/symbolizer.py
deleted file mode 100644
index 0542970c25..0000000000
--- a/src/sentry/lang/native/symbolizer.py
+++ /dev/null
@@ -1,163 +0,0 @@
-from __future__ import absolute_import
-
-import six
-
-from symbolic import LineInfo, parse_addr
-
-from sentry.utils.safe import trim
-from sentry.utils.compat import implements_to_string
-from sentry.models import EventError
-from sentry.lang.native.utils import image_name
-from sentry.constants import MAX_SYM
-
-FATAL_ERRORS = (
-    EventError.NATIVE_MISSING_DSYM,
-    EventError.NATIVE_BAD_DSYM,
-    EventError.NATIVE_SYMBOLICATOR_FAILED,
-)
-
-USER_FIXABLE_ERRORS = (
-    EventError.NATIVE_MISSING_DSYM,
-    EventError.NATIVE_MISSING_OPTIONALLY_BUNDLED_DSYM,
-    EventError.NATIVE_BAD_DSYM,
-    EventError.NATIVE_MISSING_SYMBOL,
-
-    # Emitted for e.g. broken minidumps
-    EventError.NATIVE_SYMBOLICATOR_FAILED,
-
-    # We want to let the user know when calling symbolicator failed, even
-    # though it's not user fixable.
-    EventError.NATIVE_INTERNAL_FAILURE,
-)
-
-
-@implements_to_string
-class SymbolicationFailed(Exception):
-    message = None
-
-    def __init__(self, message=None, type=None, obj=None):
-        Exception.__init__(self)
-        self.message = six.text_type(message)
-        self.type = type
-        self.image_name = None
-        self.image_path = None
-        if obj is not None:
-            self.image_uuid = six.text_type(obj.debug_id)
-            if obj.name:
-                self.image_path = obj.name
-                self.image_name = image_name(obj.name)
-            self.image_arch = obj.arch
-        else:
-            self.image_uuid = None
-            self.image_arch = None
-
-    @property
-    def is_user_fixable(self):
-        """These are errors that a user can fix themselves."""
-        return self.type in USER_FIXABLE_ERRORS
-
-    @property
-    def is_fatal(self):
-        """If this is true then a processing issues has to be reported."""
-        return self.type in FATAL_ERRORS
-
-    @property
-    def is_sdk_failure(self):
-        """An error that most likely happened because of a bad SDK."""
-        return self.type == EventError.NATIVE_UNKNOWN_IMAGE
-
-    def get_data(self):
-        """Returns the event data."""
-        rv = {'message': self.message, 'type': self.type}
-        if self.image_path is not None:
-            rv['image_path'] = self.image_path
-        if self.image_uuid is not None:
-            rv['image_uuid'] = self.image_uuid
-        if self.image_arch is not None:
-            rv['image_arch'] = self.image_arch
-        return rv
-
-    def __str__(self):
-        rv = []
-        if self.type is not None:
-            rv.append(u'%s: ' % self.type)
-        rv.append(self.message or 'no information available')
-        if self.image_uuid is not None:
-            rv.append(' image-uuid=%s' % self.image_uuid)
-        if self.image_name is not None:
-            rv.append(' image-name=%s' % self.image_name)
-        return u''.join(rv)
-
-
-class Symbolizer(object):
-    """This symbolizer dispatches to both symbolicator and the system symbols
-    we have in the database and reports errors slightly differently.
-    """
-
-    def _process_frame(self, sym, package=None, addr_off=0):
-        frame = {
-            'sym_addr': '0x%x' % (sym.sym_addr + addr_off,),
-            'instruction_addr': '0x%x' % (sym.instr_addr + addr_off,),
-            'lineno': sym.line,
-        }
-
-        symbol = trim(sym.symbol, MAX_SYM)
-        function = sym.function_name
-
-        frame['function'] = function
-        if function != symbol:
-            frame['symbol'] = symbol
-        else:
-            frame['symbol'] = None
-
-        frame['filename'] = trim(sym.rel_path, 256)
-        frame['abs_path'] = trim(sym.abs_path, 256)
-        if package is not None:
-            frame['package'] = package
-
-        return frame
-
-    def _convert_symbolserver_match(self, instruction_addr, symbolserver_match):
-        """Symbolizes a frame with system symbols only."""
-        if symbolserver_match is None:
-            return []
-
-        symbol = symbolserver_match['symbol']
-        if symbol[:1] == '_':
-            symbol = symbol[1:]
-
-        return [
-            self._process_frame(LineInfo(
-                sym_addr=parse_addr(symbolserver_match['addr']),
-                instr_addr=parse_addr(instruction_addr),
-                line=None,
-                lang=None,
-                symbol=symbol,
-            ), package=symbolserver_match['object_name'])
-        ]
-
-    def symbolize_frame(self, instruction_addr, sdk_info=None,
-                        symbolserver_match=None, symbolicator_match=None,
-                        trust=None):
-        # If the symbolicator was used, trust its result. Errors that were
-        # generated during symbolication are merged into the event's error
-        # array separately and do not need to be handled here. The match
-        # returned can either be:
-        #  - empty: Symbolicator has explicitly discarded this
-        #    frame as a false positive. This happens especially when
-        #    stackwalking without CFI.
-        #  - all unsymbolicated frames:
-        #    Symbolicator was unable to resolve symbols for this frame, so we
-        #    fall back to (iOS) symbolserver (see below).
-        #  - some unsymbolicated frames:
-        #    Symbolicator was able to resolve e.g.
-        #    an inline frame but then failed to symbolicate. This is not really
-        #    that useful either.
-        #
-        # TODO: Remove this fallback once symbolicator supports iOS system
-        # symbols and fully trust the symbolicator response.
-        if all(x["status"] == "symbolicated" for x in symbolicator_match) or symbolicator_match == []:
-            return symbolicator_match
-
-        # Then we check the symbolserver for a match.
-        return self._convert_symbolserver_match(instruction_addr, symbolserver_match)
diff --git a/src/sentry/lang/native/utils.py b/src/sentry/lang/native/utils.py
index ece5802b2e..b520e01d63 100644
--- a/src/sentry/lang/native/utils.py
+++ b/src/sentry/lang/native/utils.py
@@ -9,7 +9,6 @@ from collections import namedtuple
 from symbolic import parse_addr
 
 from sentry.interfaces.contexts import DeviceContextType
-from sentry.reprocessing import report_processing_issue
 from sentry.stacktraces.functions import trim_function_name
 from sentry.utils.safe import get_path, trim
 
@@ -128,32 +127,3 @@ def merge_symbolicated_frame(new_frame, sfrm):
     if sfrm.get('status'):
         frame_meta = new_frame.setdefault('data', {})
         frame_meta['symbolicator_status'] = sfrm['status']
-
-
-def handle_symbolication_failed(e, data, errors=None):
-    # User fixable but fatal errors are reported as processing
-    # issues
-    if e.is_user_fixable and e.is_fatal:
-        report_processing_issue(
-            data,
-            scope='native',
-            object='dsym:%s' % e.image_uuid,
-            type=e.type,
-            data=e.get_data()
-        )
-
-    # This in many ways currently does not really do anything.
-    # The reason is that once a processing issue is reported
-    # the event will only be stored as a raw event and no
-    # group will be generated.  As a result it also means that
-    # we will not have any user facing event or error showing
-    # up at all.  We want to keep this here though in case we
-    # do not want to report some processing issues (eg:
-    # optional difs)
-    if e.is_user_fixable or e.is_sdk_failure:
-        if errors is None:
-            errors = data.setdefault('errors', [])
-        errors.append(e.get_data())
-    else:
-        logger.debug('Failed to symbolicate with native backend',
-                     exc_info=True)

commit fc00a9662277ee0d896f93224292feffd0e0e707
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Wed Jan 16 11:56:35 2019 -0800

    ref(charts): Make zoom reusable in charts (#11485)
    
    This allows any chart to be able to zoom

diff --git a/docs-ui/components/areaChart.stories.js b/docs-ui/components/areaChart.stories.js
index 3a260c98d4..79358ce87d 100644
--- a/docs-ui/components/areaChart.stories.js
+++ b/docs-ui/components/areaChart.stories.js
@@ -28,10 +28,12 @@ storiesOf('Charts|AreaChart', module).add(
               data: getData(7),
             },
           ]}
-          previousPeriod={{
-            seriesName: 'Previous',
-            data: getData(7),
-          }}
+          previousPeriod={[
+            {
+              seriesName: 'Previous',
+              data: getData(7),
+            },
+          ]}
         />
       </div>
     );
diff --git a/docs-ui/components/chart-utilities.stories.js b/docs-ui/components/chart-utilities.stories.js
new file mode 100644
index 0000000000..df11e3a907
--- /dev/null
+++ b/docs-ui/components/chart-utilities.stories.js
@@ -0,0 +1,79 @@
+import React from 'react';
+import {storiesOf} from '@storybook/react';
+import {action} from '@storybook/addon-actions';
+import {withInfo} from '@storybook/addon-info';
+import {number, boolean, text} from '@storybook/addon-knobs';
+
+import ChartZoom from 'app/components/charts/chartZoom';
+import LineChart from 'app/components/charts/lineChart';
+
+storiesOf('Charts|Utilities').add(
+  'Chart Zoom',
+  withInfo(`This is a strongly opinionated component that takes a render prop through "children".
+    It requires the Global Selection Header and will update the date range selector when zooming. It also
+    has specific behavior to control when the component should update, as well as opinions for
+    the time interval to use.
+      `)(() => (
+    <div style={{backgroundColor: 'white', padding: 12}}>
+      <ChartZoom onZoom={action('ChartZoom.onZoom')}>
+        {zoomRenderProps => (
+          <LineChart
+            tooltip={{
+              filter: value => value !== null,
+              truncate: 80,
+            }}
+            {...zoomRenderProps}
+            legend={{
+              data: [
+                text('Line 1 Legend (match Line 1)', 'sentry:user'),
+                text('Line 2 Legend (match Line 2)', 'environment'),
+                text('Line 3 Legend (match Line 3)', 'browser'),
+              ],
+              type: text('Legend Type', 'scroll'),
+            }}
+            height={number('height', 300)}
+            grid={{
+              top: text('grid:top', 40),
+              bottom: text('grid:bottom', 20),
+              left: text('grid:left', '10%'),
+              right: text('grid:right', '10%'),
+              containLabel: boolean('grid:containLabel', true),
+            }}
+            series={[
+              {
+                seriesName: text('Line 1', 'sentry:user'),
+                data: [
+                  {value: 18, name: 1531094400000},
+                  {value: 31, name: 1531180800000},
+                  {value: 9, name: 1532070000000},
+                  {value: 100, name: 1532156400000},
+                  {value: 12, name: 1532242800000},
+                ],
+              },
+              {
+                seriesName: text('Line 2', 'environment'),
+                data: [
+                  {value: 84, name: 1531094400000},
+                  {value: 1, name: 1531180800000},
+                  {value: 28, name: 1532070000000},
+                  {value: 1, name: 1532156400000},
+                  {value: 1, name: 1532242800000},
+                ],
+              },
+              {
+                seriesName: text('Line 3', 'browser'),
+                data: [
+                  {value: 108, name: 1531094400000},
+                  {value: 1, name: 1531180800000},
+                  {value: 36, name: 1532070000000},
+                  {value: 0, name: 1532156400000},
+                  {value: 1, name: 1532242800000},
+                ],
+              },
+            ]}
+          />
+        )}
+      </ChartZoom>
+    </div>
+  ))
+);
diff --git a/src/sentry/static/sentry/app/components/charts/chartZoom.jsx b/src/sentry/static/sentry/app/components/charts/chartZoom.jsx
new file mode 100644
index 0000000000..e40e8c3073
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/charts/chartZoom.jsx
@@ -0,0 +1,309 @@
+import {pick, isEqual} from 'lodash';
+import {withRouter} from 'react-router';
+import PropTypes from 'prop-types';
+import React from 'react';
+import moment from 'moment';
+
+import {callIfFunction} from 'app/utils/callIfFunction';
+import {getFormattedDate} from 'app/utils/dates';
+import {getInterval, useShortInterval} from 'app/components/charts/utils';
+import {isEqualWithDates} from 'app/utils/isEqualWithDates';
+import {updateParams} from 'app/actionCreators/globalSelection';
+import DataZoom from 'app/components/charts/components/dataZoom';
+import SentryTypes from 'app/sentryTypes';
+import ToolBox from 'app/components/charts/components/toolBox';
+
+const getDate = date =>
+  date ? moment.utc(date).format(moment.HTML5_FMT.DATETIME_LOCAL_SECONDS) : null;
+
+/**
+ * This is a very opinionated component that takes a render prop through `children`. It
+ * will provide props to be passed to `BaseChart` to enable support of zooming without
+ * eCharts' clunky zoom toolboxes.
+ *
+ * This also is very tightly coupled with the Global Selection Header. We can make it more
+ * generic if need be in the future.
+ *
+ * TODO(billy): If this sees extended uses, this would be better as a child of LineChart so
+ * you can enable it via a prop to `<LineChart>`
+ */
+class ChartZoom extends React.Component {
+  static propTypes = {
+    router: PropTypes.object,
+    period: PropTypes.string,
+    start: PropTypes.instanceOf(Date),
+    end: PropTypes.instanceOf(Date),
+    utc: PropTypes.bool,
+    zoom: PropTypes.bool,
+    disabled: PropTypes.bool,
+
+    xAxis: SentryTypes.EChartsXAxis,
+
+    // Callback for when chart has been zoomed
+    onZoom: PropTypes.func,
+    // Callbacks for eCharts events
+    onRestore: PropTypes.func,
+    onChartReady: PropTypes.func,
+    onDataZoom: PropTypes.func,
+    onFinished: PropTypes.func,
+  };
+
+  constructor(props) {
+    super(props);
+
+    // Zoom history
+    this.history = [];
+
+    // Initialize current period instance state for zoom history
+    this.saveCurrentPeriod(props);
+  }
+
+  // Need to be aggressive about not re-rendering because eCharts handles zoom so we
+  // don't want the component to update (unless parameters besides time period were changed)
+  shouldComponentUpdate(nextProps, nextState) {
+    if (this.props.disabled) {
+      return true;
+    }
+
+    const periodKeys = ['period', 'start', 'end'];
+    const nextPeriod = pick(nextProps, periodKeys);
+    const currentPeriod = pick(this.props, periodKeys);
+    const otherKeys = ['query', 'project', 'environment'];
+    const zoom = nextProps.zoom;
+
+    // Exception for these parameters -- needs to re-render chart
+    if (!zoom && !isEqual(pick(nextProps, otherKeys), pick(this.props, otherKeys))) {
+      return true;
+    }
+
+    if (zoom && useShortInterval(nextProps) !== useShortInterval(this.props)) {
+      return true;
+    }
+
+    // do not update if we are zooming or if period via props does not change
+    if (zoom || isEqualWithDates(currentPeriod, nextPeriod)) {
+      return false;
+    }
+
+    return true;
+  }
+
+  componentDidUpdate() {
+    if (this.props.disabled) {
+      return;
+    }
+
+    // When component updates, make sure we sync current period state
+    // for use in zoom history
+    this.saveCurrentPeriod(this.props);
+  }
+
+  /**
+   * Save current period state from period in props to be used
+   * in handling chart's zoom history state
+   */
+  saveCurrentPeriod = props => {
+    this.currentPeriod = {
+      period: props.period,
+      start: getDate(props.start),
+      end: getDate(props.end),
+    };
+  };
+
+  /**
+   * Sets the new period due to a zoom related action
+   *
+   * Saves the current period to an instance property so that we
+   * can control URL state when zoom history is being manipulated
+   * by the chart controls.
+   *
+   * Saves a callback function to be called after chart animation is completed
+   */
+  setPeriod = ({period, start, end}, saveHistory) => {
+    const startFormatted = getDate(start);
+    const endFormatted = getDate(end);
+
+    // Save period so that we can revert back to it when using echarts "back" navigation
+    if (saveHistory) {
+      this.history.push(this.currentPeriod);
+    }
+
+    // Callback to let parent component know zoom has changed
+    // This is required for some more perceived responsiveness since
+    // we delay updating URL state so that chart animation can finish
+    //
+    // Parent container can use this to change into a loading state before
+    // URL parameters are changed
+    callIfFunction(this.props.onZoom, {
+      period,
+      start: startFormatted,
+      end: endFormatted,
+    });
+
+    this.zooming = () => {
+      updateParams(
+        {
+          period,
+          start: startFormatted,
+          end: endFormatted,
+          zoom: '1',
+        },
+        this.props.router
+      );
+
+      this.saveCurrentPeriod({period, start, end});
+    };
+  };
+
+  /**
+   * Enable zoom immediately instead of having to toggle to zoom
+   */
+  handleChartReady = chart => {
+    chart.dispatchAction({
+      type: 'takeGlobalCursor',
+      key: 'dataZoomSelect',
+      dataZoomSelectActive: true,
+    });
+
+    callIfFunction(this.props.onChartReady, chart);
+  };
+
+  /**
+   * Restores the chart to initial viewport/zoom level
+   *
+   * Updates URL state to reflect initial params
+   */
+  handleZoomRestore = (evt, chart) => {
+    if (!this.history.length) {
+      return;
+    }
+
+    this.setPeriod(this.history[0]);
+
+    // reset history
+    this.history = [];
+
+    callIfFunction(this.props.onRestore, evt, chart);
+  };
+
+  handleDataZoom = (evt, chart) => {
+    const model = chart.getModel();
+    const {xAxis, series} = model.option;
+    const axis = xAxis[0];
+    const [firstSeries] = series;
+
+    // if `rangeStart` and `rangeEnd` are null, then we are going back
+    if (axis.rangeStart === null && axis.rangeEnd === null) {
+      const previousPeriod = this.history.pop();
+
+      if (!previousPeriod) {
+        return;
+      }
+
+      this.setPeriod(previousPeriod);
+    } else {
+      const start = moment.utc(firstSeries.data[axis.rangeStart][0]);
+
+      // Add a day so we go until the end of the day (e.g. next day at midnight)
+      const end = moment.utc(firstSeries.data[axis.rangeEnd][0]);
+
+      this.setPeriod({period: null, start, end}, true);
+    }
+
+    callIfFunction(this.props.onDataZoom, evt, chart);
+  };
+
+  /**
+   * Chart event when *any* rendering+animation finishes
+   *
+   * `this.zooming` acts as a callback function so that
+   * we can let the native zoom animation on the chart complete
+   * before we update URL state and re-render
+   */
+  handleChartFinished = () => {
+    if (typeof this.zooming === 'function') {
+      this.zooming();
+      this.zooming = null;
+    }
+    callIfFunction(this.props.onFinished);
+  };
+
+  render() {
+    const {
+      utc,
+      xAxis,
+      disabled,
+      children,
+
+      onZoom, // eslint-disable-line no-unused-vars
+      onRestore, // eslint-disable-line no-unused-vars
+      onChartReady, // eslint-disable-line no-unused-vars
+      onDataZoom, // eslint-disable-line no-unused-vars
+      onFinished, // eslint-disable-line no-unused-vars
+      ...props
+    } = this.props;
+
+    if (disabled) {
+      return children(props);
+    }
+
+    const hasShortInterval = useShortInterval(this.props);
+    const interval = getInterval(this.props);
+    const xAxisOptions = {
+      axisLabel: {
+        formatter: (value, index) => {
+          const firstItem = index === 0;
+          const format = hasShortInterval && !firstItem ? 'LT' : 'lll';
+          return getFormattedDate(value, format, {local: !utc});
+        },
+      },
+      ...xAxis,
+    };
+
+    const tooltip = {
+      formatAxisLabel: (value, isTimestamp, isUtc) => {
+        if (!isTimestamp) {
+          return value;
+        }
+        return getFormattedDate(value, 'lll', {local: !isUtc});
+      },
+    };
+
+    const renderProps = {
+      // Zooming only works when grouped by date
+      isGroupedByDate: true,
+      onChartReady: this.handleChartReady,
+      utc,
+      interval,
+      dataZoom: DataZoom(),
+      tooltip,
+      toolBox: ToolBox(
+        {},
+        {
+          dataZoom: {
+            title: {
+              zoom: '',
+              back: '',
+            },
+            iconStyle: {
+              borderWidth: 0,
+              color: 'transparent',
+              opacity: 0,
+            },
+          },
+        }
+      ),
+      onEvents: {
+        datazoom: this.handleDataZoom,
+        restore: this.handleZoomRestore,
+        finished: this.handleChartFinished,
+      },
+      ...props,
+      xAxis: xAxisOptions,
+    };
+
+    return children(renderProps);
+  }
+}
+
+export default withRouter(ChartZoom);
diff --git a/src/sentry/static/sentry/app/components/charts/utils.jsx b/src/sentry/static/sentry/app/components/charts/utils.jsx
index fbcf593c50..e17d390e64 100644
--- a/src/sentry/static/sentry/app/components/charts/utils.jsx
+++ b/src/sentry/static/sentry/app/components/charts/utils.jsx
@@ -1,3 +1,5 @@
+import moment from 'moment';
+
 const DEFAULT_TRUNCATE_LENGTH = 80;
 
 export function truncationFormatter(value, truncate) {
@@ -10,3 +12,20 @@ export function truncationFormatter(value, truncate) {
     ? value.substring(0, truncationLength) + '…'
     : value;
 }
+
+/**
+ * Use a shorter interval if the time difference is <= 24 hours.
+ */
+export function useShortInterval(datetimeObj) {
+  const {period, start, end} = datetimeObj;
+
+  if (typeof period === 'string') {
+    return period.endsWith('h') || period === '1d';
+  }
+
+  return moment(end).diff(start, 'hours') <= 24;
+}
+
+export function getInterval(datetimeObj) {
+  return useShortInterval(datetimeObj) ? '5m' : '30m';
+}
diff --git a/src/sentry/static/sentry/app/views/organizationEvents/eventsChart.jsx b/src/sentry/static/sentry/app/views/organizationEvents/eventsChart.jsx
index cc9662a8ad..f709f2a2e0 100644
--- a/src/sentry/static/sentry/app/views/organizationEvents/eventsChart.jsx
+++ b/src/sentry/static/sentry/app/views/organizationEvents/eventsChart.jsx
@@ -1,17 +1,9 @@
-import {pick, isEqual} from 'lodash';
-import {withRouter} from 'react-router';
 import PropTypes from 'prop-types';
 import React from 'react';
-import moment from 'moment';
 
-import {getFormattedDate} from 'app/utils/dates';
-import {isEqualWithDates} from 'app/utils/isEqualWithDates';
 import {t} from 'app/locale';
-import {updateParams} from 'app/actionCreators/globalSelection';
-import DataZoom from 'app/components/charts/components/dataZoom';
+import ChartZoom from 'app/components/charts/chartZoom';
 import LineChart from 'app/components/charts/lineChart';
-import SentryTypes from 'app/sentryTypes';
-import ToolBox from 'app/components/charts/components/toolBox';
 import withApi from 'app/utils/withApi';
 
 import EventsContext from './utils/eventsContext';
@@ -19,311 +11,68 @@ import EventsRequest from './utils/eventsRequest';
 
 const DEFAULT_GET_CATEGORY = () => t('Events');
 
-const getDate = date =>
-  date ? moment.utc(date).format(moment.HTML5_FMT.DATETIME_LOCAL_SECONDS) : null;
-
 class EventsChart extends React.Component {
   static propTypes = {
-    organization: SentryTypes.Organization,
-    router: PropTypes.object,
     period: PropTypes.string,
     query: PropTypes.string,
-    start: PropTypes.instanceOf(Date),
-    end: PropTypes.instanceOf(Date),
-    utc: PropTypes.bool,
-    zoom: PropTypes.bool,
-
-    // Callback for when chart has been zoomed
-    onZoom: PropTypes.func,
-  };
-
-  constructor(props) {
-    super(props);
-
-    // Zoom history
-    this.history = [];
-
-    // Initialize current period instance state for zoom history
-    this.saveCurrentPeriod(props);
-  }
-
-  // Need to be aggressive about not re-rendering because eCharts handles zoom so we
-  // don't want the component to update (unless parameters besides time period were changed)
-  shouldComponentUpdate(nextProps, nextState) {
-    const periodKeys = ['period', 'start', 'end'];
-    const nextPeriod = pick(nextProps, periodKeys);
-    const currentPeriod = pick(this.props, periodKeys);
-    const otherKeys = ['query', 'project', 'environment'];
-    const zoom = nextProps.zoom;
-
-    // Exception for these parameters -- needs to re-render chart
-    if (!zoom && !isEqual(pick(nextProps, otherKeys), pick(this.props, otherKeys))) {
-      return true;
-    }
-
-    if (
-      zoom &&
-      this.useHourlyInterval(nextProps) !== this.useHourlyInterval(this.props)
-    ) {
-      return true;
-    }
-
-    // do not update if we are zooming or if period via props does not change
-    if (zoom || isEqualWithDates(currentPeriod, nextPeriod)) {
-      return false;
-    }
-
-    return true;
-  }
-
-  componentDidUpdate() {
-    // When component updates, make sure we sync current period state
-    // for use in zoom history
-    this.saveCurrentPeriod(this.props);
-  }
-
-  useHourlyInterval = (props = this.props) => {
-    const {period, start, end} = props;
-
-    if (typeof period === 'string') {
-      return period.endsWith('h') || period === '1d';
-    }
-
-    return moment(end).diff(start, 'hours') <= 24;
-  };
-
-  /**
-   * Save current period state from period in props to be used
-   * in handling chart's zoom history state
-   */
-  saveCurrentPeriod = props => {
-    this.currentPeriod = {
-      period: props.period,
-      start: getDate(props.start),
-      end: getDate(props.end),
-    };
-  };
-
-  /**
-   * Sets the new period due to a zoom related action
-   *
-   * Saves the current period to an instance property so that we
-   * can control URL state when zoom history is being manipulated
-   * by the chart controls.
-   *
-   * Saves a callback function to be called after chart animation is completed
-   */
-  setPeriod = ({period, start, end}, saveHistory) => {
-    const startFormatted = getDate(start);
-    const endFormatted = getDate(end);
-
-    // Save period so that we can revert back to it when using echarts "back" navigation
-    if (saveHistory) {
-      this.history.push(this.currentPeriod);
-    }
-
-    // Callback to let parent component know zoom has changed
-    // This is required for some more perceived responsiveness since
-    // we delay updating URL state so that chart animation can finish
-    //
-    // Parent container can use this to change into a loading state before
-    // URL parameters are changed
-    if (this.props.onZoom) {
-      this.props.onZoom({
-        period,
-        start: startFormatted,
-        end: endFormatted,
-      });
-    }
-
-    this.zooming = () => {
-      updateParams(
-        {
-          period,
-          start: startFormatted,
-          end: endFormatted,
-          zoom: '1',
-        },
-        this.props.router
-      );
-
-      this.saveCurrentPeriod({period, start, end});
-    };
-  };
-
-  /**
-   * Enable zoom immediately instead of having to toggle to zoom
-   */
-  handleChartReady = chart => {
-    chart.dispatchAction({
-      type: 'takeGlobalCursor',
-      key: 'dataZoomSelect',
-      dataZoomSelectActive: true,
-    });
-  };
-
-  /**
-   * Restores the chart to initial viewport/zoom level
-   *
-   * Updates URL state to reflect initial params
-   */
-  handleZoomRestore = (evt, chart) => {
-    if (!this.history.length) {
-      return;
-    }
-
-    this.setPeriod(this.history[0]);
-
-    // reset history
-    this.history = [];
-  };
-
-  handleDataZoom = (evt, chart) => {
-    const model = chart.getModel();
-    const {xAxis, series} = model.option;
-    const axis = xAxis[0];
-    const [firstSeries] = series;
-
-    // if `rangeStart` and `rangeEnd` are null, then we are going back
-    if (axis.rangeStart === null && axis.rangeEnd === null) {
-      const previousPeriod = this.history.pop();
-
-      if (!previousPeriod) {
-        return;
-      }
-
-      this.setPeriod(previousPeriod);
-    } else {
-      const start = moment.utc(firstSeries.data[axis.rangeStart][0]);
-
-      // Add a day so we go until the end of the day (e.g. next day at midnight)
-      const end = moment.utc(firstSeries.data[axis.rangeEnd][0]);
-
-      this.setPeriod({period: null, start, end}, true);
-    }
-  };
-
-  /**
-   * Chart event when *any* rendering+animation finishes
-   *
-   * `this.zooming` acts as a callback function so that
-   * we can let the native zoom animation on the chart complete
-   * before we update URL state and re-render
-   */
-  handleChartFinished = () => {
-    if (typeof this.zooming === 'function') {
-      this.zooming();
-      this.zooming = null;
-    }
   };
 
   render() {
-    const {period, utc, query} = this.props;
-
-    const useHourly = this.useHourlyInterval();
-
-    let interval = '30m';
-    let xAxisOptions = {
-      axisLabel: {
-        formatter: (value, index, ...rest) => {
-          const firstItem = index === 0;
-          const format = useHourly && !firstItem ? 'LT' : 'lll';
-          return getFormattedDate(value, format, {local: !utc});
-        },
-      },
-    };
-
-    if (this.useHourlyInterval()) {
-      interval = '5m';
-    }
-
-    // TODO(billy): For now only include previous period when we use relative time
+    const {period, query} = this.props;
 
     return (
-      <div>
-        <EventsRequest
-          {...this.props}
-          interval={interval}
-          showLoading
-          query={query}
-          getCategory={DEFAULT_GET_CATEGORY}
-          includePrevious={!!period}
-        >
-          {({timeseriesData, previousTimeseriesData}) => {
-            return (
-              <LineChart
-                onChartReady={this.handleChartReady}
-                isGroupedByDate
-                useUtc={utc}
-                interval={interval === '1h' ? 'hour' : 'day'}
-                series={timeseriesData}
-                seriesOptions={{
-                  showSymbol: false,
-                }}
-                previousPeriod={previousTimeseriesData ? [previousTimeseriesData] : null}
-                grid={{
-                  left: '30px',
-                  right: '18px',
-                }}
-                xAxis={xAxisOptions}
-                dataZoom={DataZoom()}
-                tooltip={{
-                  formatAxisLabel: (value, isTimestamp, isUtc) => {
-                    if (!isTimestamp) {
-                      return value;
-                    }
-                    return getFormattedDate(value, 'lll', {local: !isUtc});
-                  },
-                }}
-                toolBox={ToolBox(
-                  {},
-                  {
-                    dataZoom: {
-                      title: {
-                        zoom: '',
-                        back: '',
-                      },
-                      iconStyle: {
-                        borderWidth: 0,
-                        color: 'transparent',
-                        opacity: 0,
-                      },
-                    },
+      <ChartZoom {...this.props}>
+        {({interval, ...zoomRenderProps}) => (
+          <EventsRequest
+            {...this.props}
+            interval={interval}
+            showLoading
+            query={query}
+            getCategory={DEFAULT_GET_CATEGORY}
+            includePrevious={!!period}
+          >
+            {({timeseriesData, previousTimeseriesData}) => {
+              return (
+                <LineChart
+                  {...zoomRenderProps}
+                  series={timeseriesData}
+                  seriesOptions={{
+                    showSymbol: false,
+                  }}
+                  previousPeriod={
+                    previousTimeseriesData ? [previousTimeseriesData] : null
                   }
-                )}
-                onEvents={{
-                  datazoom: this.handleDataZoom,
-                  restore: this.handleZoomRestore,
-                  finished: this.handleChartFinished,
-                }}
-              />
-            );
-          }}
-        </EventsRequest>
-      </div>
+                  grid={{
+                    left: '30px',
+                    right: '18px',
+                  }}
+                />
+              );
+            }}
+          </EventsRequest>
+        )}
+      </ChartZoom>
     );
   }
 }
 
-const EventsChartContainer = withRouter(
-  withApi(
-    class EventsChartWithParams extends React.Component {
-      render() {
-        return (
-          <EventsContext.Consumer>
-            {context => (
-              <EventsChart
-                {...context}
-                project={context.project || []}
-                environment={context.environment || []}
-                {...this.props}
-              />
-            )}
-          </EventsContext.Consumer>
-        );
-      }
+const EventsChartContainer = withApi(
+  class EventsChartWithParams extends React.Component {
+    render() {
+      return (
+        <EventsContext.Consumer>
+          {context => (
+            <EventsChart
+              {...context}
+              project={context.project || []}
+              environment={context.environment || []}
+              {...this.props}
+            />
+          )}
+        </EventsContext.Consumer>
+      );
     }
-  )
+  }
 );
 
 export default EventsChartContainer;
diff --git a/tests/js/helpers/charts.jsx b/tests/js/helpers/charts.jsx
index 98b23d814d..430b0c416a 100644
--- a/tests/js/helpers/charts.jsx
+++ b/tests/js/helpers/charts.jsx
@@ -28,8 +28,14 @@ export const chart = {
 
 // eslint-disable-next-line
 export const doZoom = (wrapper, chart = chart) => {
-  wrapper.instance().handleDataZoom({}, chart);
-  wrapper.instance().handleChartFinished();
+  wrapper
+    .find('ChartZoom')
+    .instance()
+    .handleDataZoom({}, chart);
+  wrapper
+    .find('ChartZoom')
+    .instance()
+    .handleChartFinished();
 };
 
 export const mockZoomRange = (rangeStart, rangeEnd) => {
diff --git a/tests/js/spec/components/charts/chartZoom.spec.jsx b/tests/js/spec/components/charts/chartZoom.spec.jsx
new file mode 100644
index 0000000000..e916463af3
--- /dev/null
+++ b/tests/js/spec/components/charts/chartZoom.spec.jsx
@@ -0,0 +1,130 @@
+import React from 'react';
+
+import {mount} from 'enzyme';
+import ChartZoom from 'app/components/charts/chartZoom';
+import ConfigStore from 'app/stores/configStore';
+
+describe('ChartZoom', function() {
+  let renderFunc = jest.fn(() => null);
+  let routerContext = TestStubs.routerContext();
+  let axisLabelFormatter;
+  let tooltipFormatter;
+  const timestamp = 1531094400000;
+
+  beforeAll(function() {
+    ConfigStore.loadInitialData({
+      user: {options: {timezone: 'America/Los_Angeles'}},
+    });
+  });
+
+  beforeEach(function() {
+    renderFunc.mockClear();
+  });
+
+  describe('With Period > 24h', function() {
+    describe('Local timezone', function() {
+      beforeEach(function() {
+        mount(
+          <ChartZoom period="7d" utc={false}>
+            {renderFunc}
+          </ChartZoom>,
+          routerContext
+        );
+
+        axisLabelFormatter = renderFunc.mock.calls[0][0].xAxis.axisLabel.formatter;
+        tooltipFormatter = renderFunc.mock.calls[0][0].tooltip.formatAxisLabel;
+      });
+
+      it('formats axis label for first data point', function() {
+        expect(axisLabelFormatter(timestamp, 0)).toEqual('Jul 8, 2018 5:00 PM');
+      });
+
+      it('formats axis label for second data point', function() {
+        expect(axisLabelFormatter(timestamp, 1)).toEqual('Jul 8, 2018 5:00 PM');
+      });
+
+      it('formats tooltip', function() {
+        expect(tooltipFormatter(timestamp, true, false)).toEqual('Jul 8, 2018 5:00 PM');
+      });
+    });
+
+    describe('UTC', function() {
+      beforeEach(function() {
+        mount(
+          <ChartZoom period="7d" utc={true}>
+            {renderFunc}
+          </ChartZoom>,
+          routerContext
+        );
+
+        axisLabelFormatter = renderFunc.mock.calls[0][0].xAxis.axisLabel.formatter;
+        tooltipFormatter = renderFunc.mock.calls[0][0].tooltip.formatAxisLabel;
+      });
+
+      it('formats axis label for first data point', function() {
+        expect(axisLabelFormatter(timestamp, 0)).toEqual('Jul 9, 2018 12:00 AM');
+      });
+
+      it('formats axis label for second data point', function() {
+        expect(axisLabelFormatter(timestamp, 1)).toEqual('Jul 9, 2018 12:00 AM');
+      });
+
+      it('formats tooltip', function() {
+        expect(tooltipFormatter(timestamp, true, true)).toEqual('Jul 9, 2018 12:00 AM');
+      });
+    });
+  });
+
+  describe('With Period <= 24h', function() {
+    describe('Local timezone', function() {
+      beforeEach(function() {
+        mount(
+          <ChartZoom period="24h" utc={false}>
+            {renderFunc}
+          </ChartZoom>,
+          routerContext
+        );
+
+        axisLabelFormatter = renderFunc.mock.calls[0][0].xAxis.axisLabel.formatter;
+        tooltipFormatter = renderFunc.mock.calls[0][0].tooltip.formatAxisLabel;
+      });
+      it('formats axis label for first data point', function() {
+        expect(axisLabelFormatter(timestamp, 0)).toEqual('Jul 8, 2018 5:00 PM');
+      });
+
+      it('formats axis label for second data point', function() {
+        expect(axisLabelFormatter(timestamp, 1)).toEqual('5:00 PM');
+      });
+
+      it('formats tooltip', function() {
+        expect(tooltipFormatter(timestamp, true, false)).toEqual('Jul 8, 2018 5:00 PM');
+      });
+    });
+
+    describe('UTC', function() {
+      beforeEach(function() {
+        mount(
+          <ChartZoom period="24h" utc={true}>
+            {renderFunc}
+          </ChartZoom>,
+          routerContext
+        );
+
+        axisLabelFormatter = renderFunc.mock.calls[0][0].xAxis.axisLabel.formatter;
+        tooltipFormatter = renderFunc.mock.calls[0][0].tooltip.formatAxisLabel;
+      });
+
+      it('formats axis label for first data point', function() {
+        expect(axisLabelFormatter(timestamp, 0)).toEqual('Jul 9, 2018 12:00 AM');
+      });
+
+      it('formats axis label for second data point', function() {
+        expect(axisLabelFormatter(timestamp, 1)).toEqual('12:00 AM');
+      });
+
+      it('formats tooltip', function() {
+        expect(tooltipFormatter(timestamp, true, true)).toEqual('Jul 9, 2018 12:00 AM');
+      });
+    });
+  });
+});
diff --git a/tests/js/spec/views/organizationEvents/events.spec.jsx b/tests/js/spec/views/organizationEvents/events.spec.jsx
index ea8cbdbbe5..b38270701b 100644
--- a/tests/js/spec/views/organizationEvents/events.spec.jsx
+++ b/tests/js/spec/views/organizationEvents/events.spec.jsx
@@ -1,7 +1,5 @@
 import React from 'react';
 
-import {EventsChart} from 'app/views/organizationEvents/eventsChart';
-import {EventsTable} from 'app/views/organizationEvents/eventsTable';
 import OrganizationEvents, {parseRowFromLinks} from 'app/views/organizationEvents/events';
 import {chart, doZoom} from 'app-test/helpers/charts';
 import {initializeOrg} from 'app-test/helpers/initializeOrg';
@@ -165,14 +163,7 @@ describe('OrganizationEventsErrors', function() {
     let wrapper;
     let newParams;
 
-    beforeAll(function() {
-      chartRender = jest.spyOn(EventsChart.prototype, 'render');
-      tableRender = jest.spyOn(EventsTable.prototype, 'render');
-    });
-
     beforeEach(function() {
-      chartRender.mockClear();
-      tableRender.mockClear();
       const newLocation = {
         ...router.location,
         query: {
@@ -202,6 +193,10 @@ describe('OrganizationEventsErrors', function() {
         newRouterContext
       );
       mockRouterPush(wrapper, router);
+
+      // XXX: Note this spy happens AFTER initial render!
+      chartRender = jest.spyOn(wrapper.find('ChartZoom').instance(), 'render');
+      tableRender = jest.spyOn(wrapper.find('EventsTable').instance(), 'render');
     });
 
     afterAll(function() {
@@ -210,8 +205,8 @@ describe('OrganizationEventsErrors', function() {
     });
 
     it('zooms using chart', async function() {
-      expect(tableRender).toHaveBeenCalledTimes(1);
-      expect(chartRender).toHaveBeenCalledTimes(1);
+      expect(tableRender).toHaveBeenCalledTimes(0);
+      expect(chartRender).toHaveBeenCalledTimes(0);
 
       await tick();
       wrapper.update();
@@ -221,8 +216,8 @@ describe('OrganizationEventsErrors', function() {
       wrapper.update();
 
       // After zooming, chart should not re-render, but table does
-      expect(chartRender).toHaveBeenCalledTimes(1);
-      expect(tableRender).toHaveBeenCalledTimes(4);
+      expect(chartRender).toHaveBeenCalledTimes(0);
+      expect(tableRender).toHaveBeenCalledTimes(3);
 
       newParams = {
         zoom: '1',
diff --git a/tests/js/spec/views/organizationEvents/eventsChart.spec.jsx b/tests/js/spec/views/organizationEvents/eventsChart.spec.jsx
index 42c02e8d50..7f0ed953ed 100644
--- a/tests/js/spec/views/organizationEvents/eventsChart.spec.jsx
+++ b/tests/js/spec/views/organizationEvents/eventsChart.spec.jsx
@@ -1,11 +1,10 @@
-import {mount} from 'enzyme';
 import React from 'react';
 
-import {chart, doZoom, mockZoomRange} from 'app-test/helpers/charts';
-import {initializeOrg} from 'app-test/helpers/initializeOrg';
-
 import {EventsChart} from 'app/views/organizationEvents/eventsChart';
+import {chart, doZoom, mockZoomRange} from 'app-test/helpers/charts';
 import {getLocalDateObject} from 'app/utils/dates';
+import {initializeOrg} from 'app-test/helpers/initializeOrg';
+import {mount} from 'enzyme';
 import {updateParams} from 'app/actionCreators/globalSelection';
 
 jest.mock('app/views/organizationEvents/utils/eventsRequest', () => jest.fn(() => null));
@@ -16,11 +15,11 @@ jest.mock('app/actionCreators/globalSelection', () => ({
 
 describe('EventsChart', function() {
   const {router, routerContext, org} = initializeOrg();
-  let render = jest.spyOn(EventsChart.prototype, 'render');
+  let render;
   let wrapper;
 
+  beforeAll(function() {});
   beforeEach(function() {
-    render.mockClear();
     mockZoomRange(2, 5);
     wrapper = mount(
       <EventsChart
@@ -37,31 +36,35 @@ describe('EventsChart', function() {
       />,
       routerContext
     );
+
+    // XXX: Note we spy on this AFTER it has already rendered once!
+    render = jest.spyOn(wrapper.find('ChartZoom').instance(), 'render');
   });
 
   it('renders', function() {
-    expect(render).toHaveBeenCalledTimes(1);
+    expect(render).toHaveBeenCalledTimes(0);
   });
 
   it('re-renders if period from props changes', function() {
     wrapper.setProps({period: '7d'});
     wrapper.update();
-    expect(render).toHaveBeenCalledTimes(2);
+    expect(render).toHaveBeenCalledTimes(1);
   });
 
   it('re-renders if query from props changes', function() {
     wrapper.setProps({query: 'newQuery'});
     wrapper.update();
-    expect(render).toHaveBeenCalledTimes(2);
+    expect(render).toHaveBeenCalledTimes(1);
   });
 
   it('re-renders if project from props changes', function() {
     wrapper.setProps({project: [2]});
     wrapper.update();
-    expect(render).toHaveBeenCalledTimes(2);
+    expect(render).toHaveBeenCalledTimes(1);
   });
 
   it('does not re-render if zoomed', function() {
+    expect(render).toHaveBeenCalledTimes(0);
     doZoom(wrapper, chart);
     let newParams = {
       period: null,
@@ -70,53 +73,56 @@ describe('EventsChart', function() {
       zoom: '1',
     };
     expect(updateParams).toHaveBeenCalledWith(newParams, router);
+    expect(render).toHaveBeenCalledTimes(0);
     wrapper.setProps({
       period: newParams.period,
       start: getLocalDateObject(newParams.start),
       end: getLocalDateObject(newParams.end),
       zoom: true,
     });
+    expect(render).toHaveBeenCalledTimes(0);
     wrapper.update();
 
-    expect(render).toHaveBeenCalledTimes(1);
+    expect(render).toHaveBeenCalledTimes(0);
   });
 
   it('has correct history entries when zooming', function() {
     let newParams;
+    const chartZoomInstance = wrapper.find('ChartZoom').instance();
 
     doZoom(wrapper, chart);
-    expect(wrapper.instance().history).toEqual([
+    expect(chartZoomInstance.history).toEqual([
       {
         period: '14d',
         start: null,
         end: null,
       },
     ]);
-    expect(wrapper.instance().currentPeriod.period).toEqual(null);
-    expect(wrapper.instance().currentPeriod.start).toEqual('2018-11-29T00:00:00');
-    expect(wrapper.instance().currentPeriod.end).toEqual('2018-12-02T00:00:00');
+    expect(chartZoomInstance.currentPeriod.period).toEqual(null);
+    expect(chartZoomInstance.currentPeriod.start).toEqual('2018-11-29T00:00:00');
+    expect(chartZoomInstance.currentPeriod.end).toEqual('2018-12-02T00:00:00');
 
     // Zoom again
     mockZoomRange(3, 5);
     doZoom(wrapper, chart);
-    expect(wrapper.instance().currentPeriod.period).toEqual(null);
-    expect(wrapper.instance().currentPeriod.start).toEqual('2018-11-30T00:00:00');
-    expect(wrapper.instance().currentPeriod.end).toEqual('2018-12-02T00:00:00');
+    expect(chartZoomInstance.currentPeriod.period).toEqual(null);
+    expect(chartZoomInstance.currentPeriod.start).toEqual('2018-11-30T00:00:00');
+    expect(chartZoomInstance.currentPeriod.end).toEqual('2018-12-02T00:00:00');
 
-    expect(wrapper.instance().history[0]).toEqual({
+    expect(chartZoomInstance.history[0]).toEqual({
       period: '14d',
       start: null,
       end: null,
     });
-    expect(wrapper.instance().history[1].start).toEqual('2018-11-29T00:00:00');
-    expect(wrapper.instance().history[1].end).toEqual('2018-12-02T00:00:00');
+    expect(chartZoomInstance.history[1].start).toEqual('2018-11-29T00:00:00');
+    expect(chartZoomInstance.history[1].end).toEqual('2018-12-02T00:00:00');
 
     // go back in history
     mockZoomRange(null, null);
     doZoom(wrapper, chart);
-    expect(wrapper.instance().currentPeriod.period).toEqual(null);
-    expect(wrapper.instance().currentPeriod.start).toEqual('2018-11-29T00:00:00');
-    expect(wrapper.instance().currentPeriod.end).toEqual('2018-12-02T00:00:00');
+    expect(chartZoomInstance.currentPeriod.period).toEqual(null);
+    expect(chartZoomInstance.currentPeriod.start).toEqual('2018-11-29T00:00:00');
+    expect(chartZoomInstance.currentPeriod.end).toEqual('2018-12-02T00:00:00');
     newParams = {
       period: null,
       start: '2018-11-29T00:00:00',
@@ -132,7 +138,7 @@ describe('EventsChart', function() {
     });
     wrapper.update();
 
-    expect(render).toHaveBeenCalledTimes(1);
+    expect(render).toHaveBeenCalledTimes(0);
   });
 
   it('updates url params when restoring zoom level on chart', function() {
@@ -145,12 +151,13 @@ describe('EventsChart', function() {
     mockZoomRange(4, 5);
     doZoom(wrapper, chart);
 
-    expect(wrapper.instance().history).toHaveLength(3);
+    const chartZoomInstance = wrapper.find('ChartZoom').instance();
+    expect(chartZoomInstance.history).toHaveLength(3);
 
     // Restore history
-    wrapper.instance().handleZoomRestore();
-    wrapper.instance().handleChartFinished();
-    expect(wrapper.instance().currentPeriod).toEqual({
+    chartZoomInstance.handleZoomRestore();
+    chartZoomInstance.handleChartFinished();
+    expect(chartZoomInstance.currentPeriod).toEqual({
       period: '14d',
       start: null,
       end: null,
@@ -170,7 +177,7 @@ describe('EventsChart', function() {
     });
     wrapper.update();
 
-    expect(wrapper.instance().history).toHaveLength(0);
-    expect(render).toHaveBeenCalledTimes(1);
+    expect(chartZoomInstance.history).toHaveLength(0);
+    expect(render).toHaveBeenCalledTimes(0);
   });
 });

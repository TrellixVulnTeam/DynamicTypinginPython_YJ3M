commit 75646c4dc7fb8b52e18f35ce8f20d6b67857befe
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Fri May 11 12:29:46 2018 -0700

    feat(ui): Dropdown enhancements + fix add member to team search (#8312)
    
    * feat(ui): Dropdown enhancements + fix add member to team search
    
    * DropdownAutocomplete
      * no longer hide when trying to drag scrollbar
      * fixes bug where there were two actors (button + autocomplete input),
      can now have input not be an actor. Fixes JAVASCRIPT-381
      * adds a `busy` prop to <DropdownAutoCompleteMenu> to display a loading
      indicator next to search input
    
    * Allows "Add Member to Team" dropdown to query API on every keypress
    (debounced). This fixes a bug where it was only filtering the first 100
    members only.
      * More performance optimizations need to be done here.

diff --git a/src/sentry/static/sentry/app/components/autoComplete.jsx b/src/sentry/static/sentry/app/components/autoComplete.jsx
index 13e26ffec6..056efb7c95 100644
--- a/src/sentry/static/sentry/app/components/autoComplete.jsx
+++ b/src/sentry/static/sentry/app/components/autoComplete.jsx
@@ -33,6 +33,11 @@ class AutoComplete extends React.Component {
      * Currently, this does not act as a "controlled" prop, only for initial state of dropdown
      */
     isOpen: PropTypes.bool,
+    /**
+     * If input should be considered an "actor". If there is another parent actor, then this should be `false`.
+     * e.g. You have a button that opens this <AutoComplete> in a dropdown.
+     */
+    inputIsActor: PropTypes.bool,
     onSelect: PropTypes.func,
     onOpen: PropTypes.func,
     onClose: PropTypes.func,
@@ -40,6 +45,7 @@ class AutoComplete extends React.Component {
 
   static defaultProps = {
     itemToString: i => i,
+    inputIsActor: true,
   };
 
   constructor(props) {
@@ -118,6 +124,18 @@ class AutoComplete extends React.Component {
     }, 200);
   };
 
+  // Dropdown detected click outside, we should close
+  handleClickOutside = () => {
+    // Otherwise, it's possible that this gets fired multiple times
+    // e.g. click outside triggers closeMenu and at the same time input gets blurred, so
+    // a timer is set to close the menu
+    if (this.blurTimer) {
+      clearTimeout(this.blurTimer);
+    }
+
+    this.closeMenu();
+  };
+
   handleInputKeyDown = ({onKeyDown} = {}, e) => {
     let shouldSelectWithEnter =
       e.key === 'Enter' && this.items.size && this.items.has(this.state.highlightedIndex);
@@ -151,6 +169,11 @@ class AutoComplete extends React.Component {
     callIfFunction(onClick, item, e);
   };
 
+  handleMenuMouseDown = () => {
+    // Cancel close menu from input blur (mouseDown event can occur before input blur :()
+    setTimeout(() => this.blurTimer && clearTimeout(this.blurTimer));
+  };
+
   /**
    * When an item is selected via clicking or using the keyboard (e.g. pressing "Enter")
    */
@@ -185,10 +208,11 @@ class AutoComplete extends React.Component {
    */
   openMenu = (...args) => {
     let {onOpen} = this.props;
-    if (this.isControlled() && typeof onOpen === 'function') {
-      onOpen(...args);
-      return;
-    }
+
+    callIfFunction(onOpen, ...args);
+
+    if (this.isControlled()) return;
+
     this.resetHighlightState();
     this.setState({
       isOpen: true,
@@ -202,10 +226,10 @@ class AutoComplete extends React.Component {
    */
   closeMenu = (...args) => {
     let {onClose, resetInputOnClose} = this.props;
-    if (this.isControlled() && typeof onClose === 'function') {
-      onClose(...args);
-      return;
-    }
+
+    callIfFunction(onClose, ...args);
+
+    if (this.isControlled()) return;
 
     this.setState(state => {
       return {
@@ -239,8 +263,9 @@ class AutoComplete extends React.Component {
     };
   };
 
-  getMenuProps = props => ({
-    ...props,
+  getMenuProps = menuProps => ({
+    ...menuProps,
+    onMouseDown: this.handleMenuMouseDown.bind(this, menuProps),
   });
 
   render() {
@@ -248,12 +273,20 @@ class AutoComplete extends React.Component {
     let isOpen = this.getOpenState();
 
     return (
-      <DropdownMenu isOpen={isOpen} onClickOutside={this.closeMenu}>
+      <DropdownMenu isOpen={isOpen} onClickOutside={this.handleClickOutside}>
         {dropdownMenuProps =>
           children({
             ...dropdownMenuProps,
+            getMenuProps: props =>
+              dropdownMenuProps.getMenuProps(this.getMenuProps(props)),
             getInputProps: props => {
-              return dropdownMenuProps.getActorProps(this.getInputProps(props));
+              const inputProps = this.getInputProps(props);
+
+              if (!this.props.inputIsActor) {
+                return inputProps;
+              }
+
+              return dropdownMenuProps.getActorProps(inputProps);
             },
             getItemProps: this.getItemProps,
             inputValue: this.state.inputValue,
diff --git a/src/sentry/static/sentry/app/components/dropdownAutoCompleteMenu.jsx b/src/sentry/static/sentry/app/components/dropdownAutoCompleteMenu.jsx
index 49944b3a55..fb8e6fafed 100644
--- a/src/sentry/static/sentry/app/components/dropdownAutoCompleteMenu.jsx
+++ b/src/sentry/static/sentry/app/components/dropdownAutoCompleteMenu.jsx
@@ -1,13 +1,14 @@
-import {css} from 'emotion';
+import {Flex} from 'grid-emotion';
 import PropTypes from 'prop-types';
 import React from 'react';
 import _ from 'lodash';
-import styled from 'react-emotion';
+import styled, {css} from 'react-emotion';
 
 import {t} from 'app/locale';
 import AutoComplete from 'app/components/autoComplete';
 import Input from 'app/views/settings/components/forms/controls/input';
 import space from 'app/styles/space';
+import LoadingIndicator from 'app/components/loadingIndicator';
 
 class DropdownAutoCompleteMenu extends React.Component {
   static propTypes = {
@@ -35,7 +36,17 @@ class DropdownAutoCompleteMenu extends React.Component {
       ),
     ]),
     isOpen: PropTypes.bool,
+
+    /**
+     * Show loading indicator next to input
+     */
+    busy: PropTypes.bool,
+
     onSelect: PropTypes.func,
+    /**
+     * When AutoComplete input changes
+     */
+    onChange: PropTypes.func,
 
     /**
      * Message to display when there are no items initially
@@ -66,6 +77,7 @@ class DropdownAutoCompleteMenu extends React.Component {
      * Props to pass to menu component
      */
     menuProps: PropTypes.object,
+
     css: PropTypes.object,
     style: PropTypes.object,
   };
@@ -114,6 +126,7 @@ class DropdownAutoCompleteMenu extends React.Component {
   render() {
     let {
       onSelect,
+      onChange,
       children,
       items,
       menuProps,
@@ -124,6 +137,7 @@ class DropdownAutoCompleteMenu extends React.Component {
       style,
       menuHeader,
       menuFooter,
+      busy,
       ...props
     } = this.props;
 
@@ -132,6 +146,7 @@ class DropdownAutoCompleteMenu extends React.Component {
         resetInputOnClose
         itemToString={item => ''}
         onSelect={onSelect}
+        inputIsActor={false}
         {...props}
       >
         {({
@@ -151,7 +166,9 @@ class DropdownAutoCompleteMenu extends React.Component {
             (isOpen && this.autoCompleteFilter(items, inputValue)) || [];
           let hasItems = items && !!items.length;
           let hasResults = !!autoCompleteResults.length;
-          let showNoResultsMessage = inputValue && hasItems && !hasResults;
+          let showNoItems = !busy && !inputValue && !hasItems;
+          // Results mean there was a search (i.e. inputValue)
+          let showNoResultsMessage = !busy && inputValue && !hasResults;
 
           return (
             <AutoCompleteRoot {...getRootProps()}>
@@ -167,40 +184,52 @@ class DropdownAutoCompleteMenu extends React.Component {
                   {...getMenuProps({
                     ...menuProps,
                     style,
+                    isStyled: true,
                     css: this.props.css,
                     blendCorner,
                     alignMenu,
                   })}
                 >
-                  <StyledInput
-                    autoFocus
-                    placeholder="Filter search"
-                    {...getInputProps()}
-                  />
+                  <Flex>
+                    <StyledInput
+                      autoFocus
+                      placeholder="Filter search"
+                      {...getInputProps({onChange})}
+                    />
+                    <InputLoadingWrapper>
+                      {busy && <LoadingIndicator size={16} mini />}
+                    </InputLoadingWrapper>
+                  </Flex>
                   <div>
                     {menuHeader && <StyledLabel>{menuHeader}</StyledLabel>}
 
-                    {!hasItems && <EmptyMessage>{emptyMessage}</EmptyMessage>}
+                    {showNoItems && <EmptyMessage>{emptyMessage}</EmptyMessage>}
                     {showNoResultsMessage && (
                       <EmptyMessage>
                         {noResultsMessage || `${emptyMessage} ${t('found')}`}
                       </EmptyMessage>
                     )}
-                    {autoCompleteResults.map(
-                      ({index, ...item}) =>
-                        item.groupLabel ? (
-                          <StyledLabel key={item.value}>{item.label}</StyledLabel>
-                        ) : (
-                          <AutoCompleteItem
-                            key={`${item.value}-${index}`}
-                            index={index}
-                            highlightedIndex={highlightedIndex}
-                            {...getItemProps({item, index})}
-                          >
-                            {item.label}
-                          </AutoCompleteItem>
-                        )
+                    {busy && (
+                      <Flex justify="center" p={1}>
+                        <EmptyMessage>{t('Searching...')}</EmptyMessage>
+                      </Flex>
                     )}
+                    {!busy &&
+                      autoCompleteResults.map(
+                        ({index, ...item}) =>
+                          item.groupLabel ? (
+                            <StyledLabel key={item.value}>{item.label}</StyledLabel>
+                          ) : (
+                            <AutoCompleteItem
+                              key={`${item.value}-${index}`}
+                              index={index}
+                              highlightedIndex={highlightedIndex}
+                              {...getItemProps({item, index})}
+                            >
+                              {item.label}
+                            </AutoCompleteItem>
+                          )
+                      )}
                     {menuFooter && <StyledLabel>{menuFooter}</StyledLabel>}
                   </div>
                 </StyledMenu>
@@ -240,10 +269,21 @@ const AutoCompleteRoot = styled(({isOpen, ...props}) => <div {...props} />)`
   display: inline-block;
 `;
 
+const InputLoadingWrapper = styled(Flex)`
+  align-items: center;
+  border-bottom: 1px solid ${p => p.theme.borderLight};
+  flex-shrink: 0;
+  width: 30px;
+`;
+
 const StyledInput = styled(Input)`
+  flex: 1;
+
   &,
-  &:focus {
-    border: none;
+  &:focus,
+  &:active,
+  &:hover {
+    border: 1px solid transparent;
     border-bottom: 1px solid ${p => p.theme.borderLight};
     border-radius: 0;
     box-shadow: none;
@@ -281,9 +321,7 @@ const StyledLabel = styled('div')`
   }
 `;
 
-const StyledMenu = styled(({isOpen, blendCorner, alignMenu, ...props}) => (
-  <div {...props} />
-))`
+const StyledMenu = styled('div')`
   background: #fff;
   border: 1px solid ${p => p.theme.borderLight};
   position: absolute;
diff --git a/src/sentry/static/sentry/app/components/loadingIndicator.jsx b/src/sentry/static/sentry/app/components/loadingIndicator.jsx
index a83ff746fa..094f20d63c 100644
--- a/src/sentry/static/sentry/app/components/loadingIndicator.jsx
+++ b/src/sentry/static/sentry/app/components/loadingIndicator.jsx
@@ -14,6 +14,7 @@ function LoadingIndicator(props) {
     className,
     style,
     relative,
+    size,
   } = props;
   let cx = classNames(className, {
     overlay,
@@ -29,9 +30,17 @@ function LoadingIndicator(props) {
     'load-complete': finished,
   });
 
+  let loadingStyle = {};
+  if (size) {
+    loadingStyle = {
+      width: size,
+      height: size,
+    };
+  }
+
   return (
     <div className={cx} style={style}>
-      <div className={loadingCx}>
+      <div className={loadingCx} style={loadingStyle}>
         {finished ? <div className="checkmark draw" /> : null}
       </div>
 
@@ -48,6 +57,7 @@ LoadingIndicator.propTypes = {
   finished: PropTypes.bool,
   relative: PropTypes.bool,
   hideMessage: PropTypes.bool,
+  size: PropTypes.number,
 };
 
 export default LoadingIndicator;
diff --git a/src/sentry/static/sentry/app/views/settings/team/teamMembers.jsx b/src/sentry/static/sentry/app/views/settings/team/teamMembers.jsx
index 353ebc9396..45ec4f9805 100644
--- a/src/sentry/static/sentry/app/views/settings/team/teamMembers.jsx
+++ b/src/sentry/static/sentry/app/views/settings/team/teamMembers.jsx
@@ -1,3 +1,4 @@
+import {debounce} from 'lodash';
 import React from 'react';
 import createReactClass from 'create-react-class';
 import styled from 'react-emotion';
@@ -29,6 +30,7 @@ const TeamMembers = createReactClass({
     return {
       loading: true,
       error: false,
+      dropdownBusy: false,
       teamMemberList: null,
       orgMemberList: null,
     };
@@ -54,6 +56,15 @@ const TeamMembers = createReactClass({
     }
   },
 
+  debouncedFetchMembersRequest: debounce(function(query) {
+    this.setState(
+      {
+        dropdownBusy: true,
+      },
+      () => this.fetchMembersRequest(query)
+    );
+  }, 200),
+
   removeMember(member) {
     let {params} = this.props;
     leaveTeam(
@@ -85,6 +96,29 @@ const TeamMembers = createReactClass({
     );
   },
 
+  fetchMembersRequest(query) {
+    let {orgId} = this.props.params;
+    return this.api.request(`/organizations/${orgId}/members/`, {
+      query: {
+        query,
+      },
+      success: data => {
+        this.setState({
+          orgMemberList: data,
+          dropdownBusy: false,
+        });
+      },
+      error: () => {
+        IndicatorStore.add(t('Unable to load organization members.'), 'error', {
+          duration: 2000,
+        });
+        this.setState({
+          dropdownBusy: false,
+        });
+      },
+    });
+  },
+
   fetchData() {
     let params = this.props.params;
 
@@ -104,18 +138,7 @@ const TeamMembers = createReactClass({
       },
     });
 
-    this.api.request(`/organizations/${params.orgId}/members/`, {
-      success: data => {
-        this.setState({
-          orgMemberList: data,
-        });
-      },
-      error: () => {
-        IndicatorStore.add(t('Unable to load organization members.'), 'error', {
-          duration: 2000,
-        });
-      },
-    });
+    this.fetchMembersRequest('');
   },
 
   addTeamMember(selection) {
@@ -125,6 +148,9 @@ const TeamMembers = createReactClass({
       loading: true,
     });
 
+    // Reset members list after adding member to team
+    this.debouncedFetchMembersRequest('');
+
     joinTeam(
       this.api,
       {
@@ -156,6 +182,16 @@ const TeamMembers = createReactClass({
     );
   },
 
+  /**
+ * We perform an API request to support orgs with > 100 members (since that's the max API returns)
+ *
+ * @param {Event} e React Event when member filter input changes
+ */
+  handleMemberFilterChange(e) {
+    this.setState({dropdownBusy: true});
+    this.debouncedFetchMembersRequest(e.target.value);
+  },
+
   renderDropdown(access) {
     let {params} = this.props;
 
@@ -204,6 +240,9 @@ const TeamMembers = createReactClass({
         onSelect={this.addTeamMember}
         menuHeader={menuHeader}
         emptyMessage={t('No members')}
+        onChange={this.handleMemberFilterChange}
+        busy={this.state.dropdownBusy}
+        onClose={() => this.debouncedFetchMembersRequest('')}
       >
         {({isOpen, selectedItem}) => (
           <DropdownButton isOpen={isOpen} size="xsmall">
diff --git a/tests/js/spec/components/__snapshots__/dropdownAutoCompleteMenu.spec.jsx.snap b/tests/js/spec/components/__snapshots__/dropdownAutoCompleteMenu.spec.jsx.snap
index 75484927bf..8c175d3009 100644
--- a/tests/js/spec/components/__snapshots__/dropdownAutoCompleteMenu.spec.jsx.snap
+++ b/tests/js/spec/components/__snapshots__/dropdownAutoCompleteMenu.spec.jsx.snap
@@ -2,6 +2,7 @@
 
 exports[`DropdownAutoCompleteMenu renders with a group 1`] = `
 <AutoComplete
+  inputIsActor={false}
   isOpen={true}
   itemToString={[Function]}
   onSelect={[Function]}
@@ -11,6 +12,7 @@ exports[`DropdownAutoCompleteMenu renders with a group 1`] = `
 
 exports[`DropdownAutoCompleteMenu renders without a group 1`] = `
 <AutoComplete
+  inputIsActor={false}
   isOpen={true}
   itemToString={[Function]}
   onSelect={[Function]}
diff --git a/tests/js/spec/components/autoComplete.spec.jsx b/tests/js/spec/components/autoComplete.spec.jsx
index 1c5b04f981..c8861297db 100644
--- a/tests/js/spec/components/autoComplete.spec.jsx
+++ b/tests/js/spec/components/autoComplete.spec.jsx
@@ -25,14 +25,16 @@ describe('AutoComplete', function() {
   let autoCompleteState = [];
   let mocks = {
     onSelect: jest.fn(),
+    onClose: jest.fn(),
+    onOpen: jest.fn(),
   };
 
-  beforeEach(() => {
+  const createWrapper = props => {
     autoCompleteState = [];
     Object.keys(mocks).forEach(key => mocks[key].mockReset());
 
     wrapper = mount(
-      <AutoComplete {...mocks} itemToString={item => item.name}>
+      <AutoComplete {...mocks} itemToString={item => item.name} {...props}>
         {injectedProps => {
           let {
             getRootProps,
@@ -98,178 +100,370 @@ describe('AutoComplete', function() {
     );
 
     input = wrapper.find('input');
-  });
-
-  it('shows dropdown menu when input has focus', function() {
-    input.simulate('focus');
-    expect(wrapper.state('isOpen')).toBe(true);
-    expect(wrapper.find('li')).toHaveLength(3);
-  });
-
-  it('hides dropdown menu when input is blurred', function() {
-    jest.useFakeTimers();
-    input.simulate('focus');
-    input.simulate('blur');
-    expect(wrapper.state('isOpen')).toBe(true);
-    expect(wrapper.find('li')).toHaveLength(3);
-    jest.runAllTimers();
-    wrapper.update();
-
-    expect(wrapper.state('isOpen')).toBe(false);
-    expect(wrapper.find('li')).toHaveLength(0);
-  });
-
-  it('can close dropdown menu when Escape is pressed', function() {
-    input.simulate('focus');
-    expect(wrapper.state('isOpen')).toBe(true);
-
-    input.simulate('keyDown', {key: 'Escape'});
-    expect(wrapper.state('isOpen')).toBe(false);
-  });
-
-  it('can open and close dropdown menu using injected actions', function() {
-    let [injectedProps] = autoCompleteState;
-    injectedProps.actions.open();
-    expect(wrapper.state('isOpen')).toBe(true);
-
-    injectedProps.actions.close();
-    expect(wrapper.state('isOpen')).toBe(false);
-  });
-
-  it('reopens dropdown menu after Escape is pressed and input is changed', function() {
-    input.simulate('focus');
-    expect(wrapper.state('isOpen')).toBe(true);
-
-    input.simulate('keyDown', {key: 'Escape'});
-    expect(wrapper.state('isOpen')).toBe(false);
-
-    input.simulate('change', {target: {value: 'a'}});
-    expect(wrapper.state('isOpen')).toBe(true);
-    expect(wrapper.instance().items.size).toBe(3);
-  });
-
-  it('reopens dropdown menu after item is selectted and then input is changed', function() {
-    input.simulate('focus');
-    expect(wrapper.state('isOpen')).toBe(true);
-
-    input.simulate('change', {target: {value: 'eapp'}});
-    expect(wrapper.state('isOpen')).toBe(true);
-    expect(wrapper.instance().items.size).toBe(1);
-    input.simulate('keyDown', {key: 'Enter'});
-    expect(wrapper.state('isOpen')).toBe(false);
-
-    input.simulate('change', {target: {value: 'app'}});
-    expect(wrapper.state('isOpen')).toBe(true);
-    expect(wrapper.instance().items.size).toBe(2);
-  });
-
-  it('selects dropdown item by clicking and sets input to selected value', function() {
-    input.simulate('focus');
-    expect(wrapper.state('isOpen')).toBe(true);
-    expect(wrapper.instance().items.size).toBe(3);
-
-    wrapper
-      .find('li')
-      .at(1)
-      .simulate('click');
-    expect(mocks.onSelect).toHaveBeenCalledWith(items[1]);
-
-    expect(wrapper.state('inputValue')).toBe('Pineapple');
-    expect(wrapper.instance().items.size).toBe(0);
-  });
-
-  it('can navigate dropdown items with keyboard and select with "Enter" keypress', function() {
-    input.simulate('focus');
-    expect(wrapper.state('isOpen')).toBe(true);
-    expect(wrapper.state('highlightedIndex')).toBe(0);
-
-    input.simulate('keyDown', {key: 'ArrowDown'});
-    expect(wrapper.state('highlightedIndex')).toBe(1);
-
-    input.simulate('keyDown', {key: 'ArrowDown'});
-    expect(wrapper.state('highlightedIndex')).toBe(2);
-
-    expect(wrapper.instance().items.size).toBe(3);
-    input.simulate('keyDown', {key: 'Enter'});
-
-    expect(mocks.onSelect).toHaveBeenCalledWith(items[2]);
-    expect(wrapper.instance().items.size).toBe(0);
-    expect(wrapper.state('inputValue')).toBe('Orange');
-  });
-
-  it('respects list bounds when navigating filtered items with arrow keys', function() {
-    input.simulate('focus');
-    expect(wrapper.state('isOpen')).toBe(true);
-    expect(wrapper.state('highlightedIndex')).toBe(0);
-
-    input.simulate('keyDown', {key: 'ArrowUp'});
-    expect(wrapper.state('highlightedIndex')).toBe(0);
-
-    input.simulate('keyDown', {key: 'ArrowDown'});
-    expect(wrapper.state('highlightedIndex')).toBe(1);
-
-    input.simulate('keyDown', {key: 'ArrowDown'});
-    expect(wrapper.state('highlightedIndex')).toBe(2);
-
-    input.simulate('keyDown', {key: 'ArrowDown'});
-    expect(wrapper.state('highlightedIndex')).toBe(2);
-
-    input.simulate('keyDown', {key: 'ArrowUp'});
-    expect(wrapper.state('highlightedIndex')).toBe(1);
-
-    input.simulate('keyDown', {key: 'ArrowUp'});
-    expect(wrapper.state('highlightedIndex')).toBe(0);
-
-    input.simulate('keyDown', {key: 'ArrowUp'});
-    expect(wrapper.state('highlightedIndex')).toBe(0);
-
-    expect(wrapper.instance().items.size).toBe(3);
-  });
+    return wrapper;
+  };
 
-  it('can filter items and then navigate with keyboard', function() {
-    input.simulate('focus');
-    expect(wrapper.state('isOpen')).toBe(true);
-    expect(wrapper.state('highlightedIndex')).toBe(0);
-    expect(wrapper.instance().items.size).toBe(3);
-
-    input.simulate('change', {target: {value: 'a'}});
-    expect(wrapper.state('highlightedIndex')).toBe(0);
-    expect(wrapper.state('inputValue')).toBe('a');
-    // Apple, pineapple, orange
-    expect(wrapper.instance().items.size).toBe(3);
-
-    input.simulate('change', {target: {value: 'ap'}});
-    expect(wrapper.state('highlightedIndex')).toBe(0);
-    expect(wrapper.state('inputValue')).toBe('ap');
-    expect(autoCompleteState[autoCompleteState.length - 1].inputValue).toBe('ap');
-    // Apple, pineapple
-    expect(wrapper.instance().items.size).toBe(2);
-
-    input.simulate('keyDown', {key: 'ArrowDown'});
-    expect(wrapper.state('highlightedIndex')).toBe(1);
-
-    input.simulate('keyDown', {key: 'ArrowDown'});
-    expect(wrapper.state('highlightedIndex')).toBe(1);
-    expect(wrapper.instance().items.size).toBe(2);
-
-    input.simulate('keyDown', {key: 'Enter'});
-    expect(mocks.onSelect).toHaveBeenCalledWith(items[1]);
-    expect(wrapper.instance().items.size).toBe(0);
-    expect(wrapper.state('inputValue')).toBe('Pineapple');
+  describe('Uncontrolled', function() {
+    beforeEach(() => {
+      wrapper = createWrapper();
+    });
+
+    it('shows dropdown menu when input has focus', function() {
+      input.simulate('focus');
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.find('li')).toHaveLength(3);
+    });
+
+    it('only tries to close once if input is blurred and click outside occurs', function() {
+      jest.useFakeTimers();
+      input.simulate('focus');
+      input.simulate('blur');
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.find('li')).toHaveLength(3);
+      wrapper.find('DropdownMenu').prop('onClickOutside')();
+      jest.runAllTimers();
+      wrapper.update();
+
+      expect(mocks.onClose).toHaveBeenCalledTimes(1);
+    });
+
+    it('only calls onClose dropdown menu when input is blurred', function() {
+      jest.useFakeTimers();
+      input.simulate('focus');
+      input.simulate('blur');
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.find('li')).toHaveLength(3);
+      jest.runAllTimers();
+      wrapper.update();
+
+      expect(wrapper.state('isOpen')).toBe(false);
+      expect(wrapper.find('li')).toHaveLength(0);
+      expect(mocks.onClose).toHaveBeenCalledTimes(1);
+    });
+
+    it('can close dropdown menu when Escape is pressed', function() {
+      input.simulate('focus');
+      expect(wrapper.state('isOpen')).toBe(true);
+
+      input.simulate('keyDown', {key: 'Escape'});
+      expect(wrapper.state('isOpen')).toBe(false);
+    });
+
+    it('can open and close dropdown menu using injected actions', function() {
+      let [injectedProps] = autoCompleteState;
+      injectedProps.actions.open();
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(mocks.onOpen).toHaveBeenCalledTimes(1);
+
+      injectedProps.actions.close();
+      expect(wrapper.state('isOpen')).toBe(false);
+      expect(mocks.onClose).toHaveBeenCalledTimes(1);
+    });
+
+    it('reopens dropdown menu after Escape is pressed and input is changed', function() {
+      input.simulate('focus');
+      expect(wrapper.state('isOpen')).toBe(true);
+
+      input.simulate('keyDown', {key: 'Escape'});
+      expect(wrapper.state('isOpen')).toBe(false);
+
+      input.simulate('change', {target: {value: 'a'}});
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.instance().items.size).toBe(3);
+    });
+
+    it('reopens dropdown menu after item is selected and then input is changed', function() {
+      input.simulate('focus');
+      expect(wrapper.state('isOpen')).toBe(true);
+
+      input.simulate('change', {target: {value: 'eapp'}});
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.instance().items.size).toBe(1);
+      input.simulate('keyDown', {key: 'Enter'});
+      expect(wrapper.state('isOpen')).toBe(false);
+
+      input.simulate('change', {target: {value: 'app'}});
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.instance().items.size).toBe(2);
+    });
+
+    it('selects dropdown item by clicking and sets input to selected value', function() {
+      input.simulate('focus');
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.instance().items.size).toBe(3);
+
+      wrapper
+        .find('li')
+        .at(1)
+        .simulate('click');
+      expect(mocks.onSelect).toHaveBeenCalledWith(items[1]);
+
+      expect(wrapper.state('inputValue')).toBe('Pineapple');
+      expect(wrapper.instance().items.size).toBe(0);
+    });
+
+    it('can navigate dropdown items with keyboard and select with "Enter" keypress', function() {
+      input.simulate('focus');
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+
+      input.simulate('keyDown', {key: 'ArrowDown'});
+      expect(wrapper.state('highlightedIndex')).toBe(1);
+
+      input.simulate('keyDown', {key: 'ArrowDown'});
+      expect(wrapper.state('highlightedIndex')).toBe(2);
+
+      expect(wrapper.instance().items.size).toBe(3);
+      input.simulate('keyDown', {key: 'Enter'});
+
+      expect(mocks.onSelect).toHaveBeenCalledWith(items[2]);
+      expect(wrapper.instance().items.size).toBe(0);
+      expect(wrapper.state('inputValue')).toBe('Orange');
+    });
+
+    it('respects list bounds when navigating filtered items with arrow keys', function() {
+      input.simulate('focus');
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+
+      input.simulate('keyDown', {key: 'ArrowUp'});
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+
+      input.simulate('keyDown', {key: 'ArrowDown'});
+      expect(wrapper.state('highlightedIndex')).toBe(1);
+
+      input.simulate('keyDown', {key: 'ArrowDown'});
+      expect(wrapper.state('highlightedIndex')).toBe(2);
+
+      input.simulate('keyDown', {key: 'ArrowDown'});
+      expect(wrapper.state('highlightedIndex')).toBe(2);
+
+      input.simulate('keyDown', {key: 'ArrowUp'});
+      expect(wrapper.state('highlightedIndex')).toBe(1);
+
+      input.simulate('keyDown', {key: 'ArrowUp'});
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+
+      input.simulate('keyDown', {key: 'ArrowUp'});
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+
+      expect(wrapper.instance().items.size).toBe(3);
+    });
+
+    it('can filter items and then navigate with keyboard', function() {
+      input.simulate('focus');
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+      expect(wrapper.instance().items.size).toBe(3);
+
+      input.simulate('change', {target: {value: 'a'}});
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+      expect(wrapper.state('inputValue')).toBe('a');
+      // Apple, pineapple, orange
+      expect(wrapper.instance().items.size).toBe(3);
+
+      input.simulate('change', {target: {value: 'ap'}});
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+      expect(wrapper.state('inputValue')).toBe('ap');
+      expect(autoCompleteState[autoCompleteState.length - 1].inputValue).toBe('ap');
+      // Apple, pineapple
+      expect(wrapper.instance().items.size).toBe(2);
+
+      input.simulate('keyDown', {key: 'ArrowDown'});
+      expect(wrapper.state('highlightedIndex')).toBe(1);
+
+      input.simulate('keyDown', {key: 'ArrowDown'});
+      expect(wrapper.state('highlightedIndex')).toBe(1);
+      expect(wrapper.instance().items.size).toBe(2);
+
+      input.simulate('keyDown', {key: 'Enter'});
+      expect(mocks.onSelect).toHaveBeenCalledWith(items[1]);
+      expect(wrapper.instance().items.size).toBe(0);
+      expect(wrapper.state('inputValue')).toBe('Pineapple');
+    });
+
+    it('can reset input when menu closes', function() {
+      jest.useFakeTimers();
+      wrapper.setProps({resetInputOnClose: true});
+      input.simulate('focus');
+      expect(wrapper.state('isOpen')).toBe(true);
+
+      input.simulate('change', {target: {value: 'a'}});
+      expect(wrapper.state('inputValue')).toBe('a');
+
+      input.simulate('blur');
+      jest.runAllTimers();
+      expect(wrapper.state('isOpen')).toBe(false);
+      expect(wrapper.state('inputValue')).toBe('');
+    });
   });
 
-  it('can reset input when menu closes', function() {
-    jest.useFakeTimers();
-    wrapper.setProps({resetInputOnClose: true});
-    input.simulate('focus');
-    expect(wrapper.state('isOpen')).toBe(true);
-
-    input.simulate('change', {target: {value: 'a'}});
-    expect(wrapper.state('inputValue')).toBe('a');
+  describe('Controlled', function() {
+    beforeEach(function() {
+      wrapper = createWrapper({isOpen: true});
+    });
+
+    it('has dropdown menu initially open', function() {
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.find('li')).toHaveLength(3);
+    });
+
+    it('closes when props change', function() {
+      wrapper.setProps({isOpen: false});
+      expect(wrapper.state('isOpen')).toBe(true);
+      wrapper.update();
+
+      // Menu should be closed
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.find('li')).toHaveLength(0);
+    });
+
+    it('remains closed when input is focused, but calls `onOpen`', function() {
+      wrapper = createWrapper({isOpen: false});
+      jest.useFakeTimers();
+
+      expect(wrapper.state('isOpen')).toBe(false);
+
+      input.simulate('focus');
+      jest.runAllTimers();
+      wrapper.update();
+      expect(wrapper.state('isOpen')).toBe(false);
+      expect(wrapper.find('li')).toHaveLength(0);
+
+      expect(mocks.onOpen).toHaveBeenCalledTimes(1);
+    });
+
+    it('remains open when input focus/blur events occur, but calls `onClose`', function() {
+      jest.useFakeTimers();
+      input.simulate('focus');
+      input.simulate('blur');
+      jest.runAllTimers();
+      wrapper.update();
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.find('li')).toHaveLength(3);
+
+      // This still gets called even though menu is open
+      expect(mocks.onClose).toHaveBeenCalledTimes(1);
+    });
+
+    it('calls onClose when Escape is pressed', function() {
+      expect(wrapper.state('isOpen')).toBe(true);
+
+      input.simulate('keyDown', {key: 'Escape'});
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(mocks.onClose).toHaveBeenCalledTimes(1);
+    });
+
+    it('does not open and close dropdown menu using injected actions', function() {
+      let [injectedProps] = autoCompleteState;
+      injectedProps.actions.open();
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(mocks.onOpen).toHaveBeenCalledTimes(1);
+
+      injectedProps.actions.close();
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(mocks.onClose).toHaveBeenCalledTimes(1);
+    });
+
+    it('onClose is called after item is selected', function() {
+      expect(wrapper.state('isOpen')).toBe(true);
+
+      input.simulate('change', {target: {value: 'eapp'}});
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.instance().items.size).toBe(1);
+      input.simulate('keyDown', {key: 'Enter'});
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(mocks.onClose).toHaveBeenCalledTimes(1);
+    });
+
+    it('selects dropdown item by clicking and sets input to selected value', function() {
+      expect(wrapper.instance().items.size).toBe(3);
+
+      wrapper
+        .find('li')
+        .at(1)
+        .simulate('click');
+      expect(mocks.onSelect).toHaveBeenCalledWith(items[1]);
+
+      expect(wrapper.state('inputValue')).toBe('Pineapple');
+      expect(mocks.onClose).toHaveBeenCalledTimes(1);
+    });
+
+    it('can navigate dropdown items with keyboard and select with "Enter" keypress', function() {
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+
+      input.simulate('keyDown', {key: 'ArrowDown'});
+      expect(wrapper.state('highlightedIndex')).toBe(1);
+
+      input.simulate('keyDown', {key: 'ArrowDown'});
+      expect(wrapper.state('highlightedIndex')).toBe(2);
+
+      expect(wrapper.instance().items.size).toBe(3);
+      input.simulate('keyDown', {key: 'Enter'});
+
+      expect(mocks.onSelect).toHaveBeenCalledWith(items[2]);
+      expect(mocks.onClose).toHaveBeenCalledTimes(1);
+      expect(wrapper.state('inputValue')).toBe('Orange');
+    });
+
+    it('respects list bounds when navigating filtered items with arrow keys', function() {
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+
+      input.simulate('keyDown', {key: 'ArrowUp'});
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+
+      input.simulate('keyDown', {key: 'ArrowDown'});
+      expect(wrapper.state('highlightedIndex')).toBe(1);
+
+      input.simulate('keyDown', {key: 'ArrowDown'});
+      expect(wrapper.state('highlightedIndex')).toBe(2);
+
+      input.simulate('keyDown', {key: 'ArrowDown'});
+      expect(wrapper.state('highlightedIndex')).toBe(2);
+
+      input.simulate('keyDown', {key: 'ArrowUp'});
+      expect(wrapper.state('highlightedIndex')).toBe(1);
+
+      input.simulate('keyDown', {key: 'ArrowUp'});
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+
+      input.simulate('keyDown', {key: 'ArrowUp'});
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+
+      expect(wrapper.instance().items.size).toBe(3);
+    });
+
+    it('can filter items and then navigate with keyboard', function() {
+      expect(wrapper.state('isOpen')).toBe(true);
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+      expect(wrapper.instance().items.size).toBe(3);
+
+      input.simulate('change', {target: {value: 'a'}});
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+      expect(wrapper.state('inputValue')).toBe('a');
+      // Apple, pineapple, orange
+      expect(wrapper.instance().items.size).toBe(3);
+
+      input.simulate('change', {target: {value: 'ap'}});
+      expect(wrapper.state('highlightedIndex')).toBe(0);
+      expect(wrapper.state('inputValue')).toBe('ap');
+      expect(autoCompleteState[autoCompleteState.length - 1].inputValue).toBe('ap');
+      // Apple, pineapple
+      expect(wrapper.instance().items.size).toBe(2);
+
+      input.simulate('keyDown', {key: 'ArrowDown'});
+      expect(wrapper.state('highlightedIndex')).toBe(1);
+
+      input.simulate('keyDown', {key: 'ArrowDown'});
+      expect(wrapper.state('highlightedIndex')).toBe(1);
+      expect(wrapper.instance().items.size).toBe(2);
 
-    input.simulate('blur');
-    jest.runAllTimers();
-    expect(wrapper.state('isOpen')).toBe(false);
-    expect(wrapper.state('inputValue')).toBe('');
+      input.simulate('keyDown', {key: 'Enter'});
+      expect(mocks.onSelect).toHaveBeenCalledWith(items[1]);
+      expect(mocks.onClose).toHaveBeenCalledTimes(1);
+      expect(wrapper.state('inputValue')).toBe('Pineapple');
+    });
   });
 });
diff --git a/tests/js/spec/components/dropdownAutoCompleteMenu.spec.jsx b/tests/js/spec/components/dropdownAutoCompleteMenu.spec.jsx
index 220cfbdf3f..b075e41b0b 100644
--- a/tests/js/spec/components/dropdownAutoCompleteMenu.spec.jsx
+++ b/tests/js/spec/components/dropdownAutoCompleteMenu.spec.jsx
@@ -100,9 +100,11 @@ describe('DropdownAutoCompleteMenu', function() {
     expect(wrapper.find('EmptyMessage')).toHaveLength(1);
     expect(wrapper.find('EmptyMessage').text()).toBe('No items!');
 
-    // Should still be "no items" empty message even if search results return an empty set
+    // Should be "No items! Found"  because there are no results and there is a search value
+    // This is for the case where items is an async result from an API endpoint that also does
+    // a string match query.
     wrapper.find('StyledInput').simulate('change', {target: {value: 'U-S-A'}});
-    expect(wrapper.find('EmptyMessage').text()).toBe('No items!');
+    expect(wrapper.find('EmptyMessage').text()).toBe('No items! found');
   });
 
   it('shows default empty results message when there are no items found in search', function() {
diff --git a/tests/js/spec/views/__snapshots__/organizationTeamProjects.spec.jsx.snap b/tests/js/spec/views/__snapshots__/organizationTeamProjects.spec.jsx.snap
index 73dfab2371..f71964e453 100644
--- a/tests/js/spec/views/__snapshots__/organizationTeamProjects.spec.jsx.snap
+++ b/tests/js/spec/views/__snapshots__/organizationTeamProjects.spec.jsx.snap
@@ -82,6 +82,7 @@ exports[`OrganizationTeamProjects Should render 1`] = `
                           onSelect={[Function]}
                         >
                           <AutoComplete
+                            inputIsActor={false}
                             itemToString={[Function]}
                             onSelect={[Function]}
                             resetInputOnClose={true}
diff --git a/tests/js/spec/views/__snapshots__/teamMembers.spec.jsx.snap b/tests/js/spec/views/__snapshots__/teamMembers.spec.jsx.snap
index b99291548b..7603f4cf55 100644
--- a/tests/js/spec/views/__snapshots__/teamMembers.spec.jsx.snap
+++ b/tests/js/spec/views/__snapshots__/teamMembers.spec.jsx.snap
@@ -17,6 +17,7 @@ exports[`TeamMembers renders 1`] = `
     >
       <DropdownAutoComplete
         alignMenu="right"
+        busy={false}
         emptyMessage="No members"
         items={Array []}
         menuHeader={
@@ -29,6 +30,8 @@ exports[`TeamMembers renders 1`] = `
             </StyledCreateMemberLink>
           </StyledMembersLabel>
         }
+        onChange={[Function]}
+        onClose={[Function]}
         onSelect={[Function]}
       />
     </div>

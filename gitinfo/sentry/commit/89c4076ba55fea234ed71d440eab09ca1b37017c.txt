commit 89c4076ba55fea234ed71d440eab09ca1b37017c
Author: David Cramer <dcramer@gmail.com>
Date:   Thu Jan 17 19:29:04 2013 -0800

    Initial work on task to extract source context from javascript events

diff --git a/src/sentry/tasks/__init__.py b/src/sentry/tasks/__init__.py
index c664399cfe..451d2b328e 100644
--- a/src/sentry/tasks/__init__.py
+++ b/src/sentry/tasks/__init__.py
@@ -7,5 +7,6 @@ sentry.tasks
 """
 
 import sentry.tasks.cleanup  # NOQA
+import sentry.tasks.fetch_source  # NOQA
 import sentry.tasks.index  # NOQA
 import sentry.tasks.store  # NOQA
diff --git a/src/sentry/tasks/fetch_source.py b/src/sentry/tasks/fetch_source.py
new file mode 100644
index 0000000000..8630a2d366
--- /dev/null
+++ b/src/sentry/tasks/fetch_source.py
@@ -0,0 +1,95 @@
+"""
+sentry.tasks.fetch_source
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2012 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+import urllib2
+
+from celery.task import task
+from sentry.utils.lrucache import lrucache
+
+BAD_SOURCE = -1
+
+# number of surrounding lines (on each side) to fetch
+LINES_OF_CONTEXT = 5
+
+
+@lrucache.memoize
+def fetch_url(url, logger=None):
+    try:
+        req = urllib2.urlopen(url)
+        result = req.read()
+    except Exception:
+        if logger:
+            logger.error('Unable to fetch remote source for %r', url, exc_info=True)
+        return BAD_SOURCE
+    return result
+
+
+def get_source_context(source, lineno, context=LINES_OF_CONTEXT):
+    lower_bound = max(0, lineno - context)
+    upper_bound = min(lineno + 1 + context, len(source))
+
+    try:
+        pre_context = [line.strip('\n') for line in source[lower_bound:lineno]]
+    except IndexError:
+        pre_context = []
+
+    try:
+        context_line = source[lineno].strip('\n')
+    except IndexError:
+        context_line = ''
+
+    try:
+        post_context = [line.strip('\n') for line in source[(lineno + 1):upper_bound]]
+    except IndexError:
+        post_context = []
+
+    return pre_context, context_line, post_context
+
+
+@task(ignore_result=True)
+def fetch_javascript_source(event, **kwargs):
+    from sentry.utils.cache import cache
+
+    logger = fetch_javascript_source.get_logger()
+
+    try:
+        stacktrace = event.data['sentry.interfaces.Stacktrace']
+    except KeyError:
+        logger.info('No stacktrace for event %r', event.id)
+        return
+
+    # build list of frames that we can actually grab source for
+    frames = [f for f in stacktrace['frames']
+        if f.get('lineno') is not None and f.get('abs_path', '').startswith(('http://', 'https://'))]
+    if not frames:
+        logger.info('Event %r has no frames with enough context to fetch remote source', event.id)
+        return
+
+    file_list = set((f['abs_path'] for f in frames))
+    source_code = {}
+
+    for filename in file_list:
+        cache_key = 'remotesource:%s' % filename
+        # TODO: respect headers
+        result = cache.get(cache_key)
+        if result is None:
+            result = fetch_url(filename)
+            cache.set(cache_key, result)
+
+        if result != BAD_SOURCE:
+            result = result.splitlines()
+        source_code[filename] = result
+
+    for frame in frames:
+        source = source_code[frame['abs_path']]
+        if source == BAD_SOURCE:
+            continue
+        frame['pre_context'], frame['context_line'], frame['post_context'] = get_source_context(
+            source, int(frame['lineno']))
+
+    event.save()
diff --git a/src/sentry/utils/lrucache.py b/src/sentry/utils/lrucache.py
index 9022dda90e..95a0c767e7 100644
--- a/src/sentry/utils/lrucache.py
+++ b/src/sentry/utils/lrucache.py
@@ -61,8 +61,7 @@ class LRUCache(object):
 
     def make_key(self, func, args, kwds, tuple=tuple, sorted=sorted, type=type):
         # helper function to build a cache key from positional and keyword args
-        key = [func]
-        key += args
+        key = (func,) + args
         if kwds:
             sorted_items = tuple(sorted(kwds.items()))
             key += self.kwd_mark + sorted_items
diff --git a/tests/sentry/tasks/fetch_source/__init__.py b/tests/sentry/tasks/fetch_source/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/tests/sentry/tasks/fetch_source/tests.py b/tests/sentry/tasks/fetch_source/tests.py
new file mode 100644
index 0000000000..747e6d19e1
--- /dev/null
+++ b/tests/sentry/tasks/fetch_source/tests.py
@@ -0,0 +1,53 @@
+# -*- coding: utf-8 -*-
+
+from __future__ import absolute_import
+
+import mock
+
+from celery.task import Task
+from sentry.models import Event
+from sentry.tasks.fetch_source import fetch_javascript_source
+from sentry.testutils import TestCase
+
+
+class StoreEventTest(TestCase):
+    def test_is_task(self):
+        self.assertTrue(isinstance(fetch_javascript_source, Task))
+
+    @mock.patch('sentry.models.Event.save')
+    @mock.patch('urllib2.urlopen')
+    def test_calls_from_kwargs(self, urlopen, save):
+        event = Event(data={
+            'sentry.interfaces.Stacktrace': {
+                'frames': [
+                    {
+                        'abs_path': 'http://example.com/foo.js',
+                        'filename': 'foo.js',
+                        'lineno': 4,
+                    },
+                    {
+                        'abs_path': 'http://example.com/foo.js',
+                        'filename': 'foo.js',
+                        'lineno': 1,
+                    },
+                ],
+            },
+        })
+        urlopen.return_value.read.return_value = '\n'.join('hello world')
+
+        fetch_javascript_source(event)
+
+        urlopen.assert_called_once_with('http://example.com/foo.js')
+        urlopen.return_value.read.assert_called_once_with()
+        save.assert_called_once_with()
+
+        frame_list = event.data['sentry.interfaces.Stacktrace']['frames']
+        frame = frame_list[0]
+        assert frame['pre_context'] == ['h', 'e', 'l', 'l']
+        assert frame['context_line'] == 'o'
+        assert frame['post_context'] == [' ', 'w', 'o', 'r', 'l']
+
+        frame = frame_list[1]
+        assert frame['pre_context'] == ['h']
+        assert frame['context_line'] == 'e'
+        assert frame['post_context'] == ['l', 'l', 'o', ' ', 'w']

commit 5ca1e03f994181e358873aae6fb6b3aa0a9d5637
Author: Mark Story <mark@sentry.io>
Date:   Wed Sep 4 11:16:53 2019 -0400

    feat(discover2) Auto-link first column in results. (#14562)
    
    If the query set does not contain a transaction or title field then we
    need wrap the first column in a link so that the modal view can be
    accessed. This isn't required for the preview release, but becomes
    important when we have custom queries.
    
    Refs SEN-1013

diff --git a/src/sentry/api/event_search.py b/src/sentry/api/event_search.py
index 0fa13b0ac8..d3f92e32ba 100644
--- a/src/sentry/api/event_search.py
+++ b/src/sentry/api/event_search.py
@@ -831,13 +831,21 @@ def get_reference_event_conditions(snuba_args, reference_event):
     """
     conditions = []
 
+    tags = {}
+    if "tags.key" in reference_event and "tags.value" in reference_event:
+        tags = dict(zip(reference_event["tags.key"], reference_event["tags.value"]))
+
     # If we were given an project/event to use build additional
     # conditions using that event and the non-aggregated columns
     # we received in the querystring. This lets us find the oldest/newest.
     # This only handles simple fields on the snuba_data dict.
     for field in snuba_args.get("groupby", []):
         prop = get_snuba_column_name(field)
-        value = reference_event.get(prop, None)
+        if prop.startswith("tags["):
+            value = tags.get(field, None)
+        else:
+            value = reference_event.get(prop, None)
         if value:
             conditions.append([prop, "=", value])
+
     return conditions
diff --git a/src/sentry/static/sentry/app/views/eventsV2/data.tsx b/src/sentry/static/sentry/app/views/eventsV2/data.tsx
index 51ebff3eb2..5ea671628a 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/data.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/data.tsx
@@ -183,17 +183,20 @@ type FieldFormatters = {
 
 export type FieldTypes = keyof FieldFormatters;
 
+const emptyValue = <span>{t('n/a')}</span>;
 /**
  * A mapping of field types to their rendering function.
  * This mapping is used when a field is not defined in SPECIAL_FIELDS
+ * and the field is not being coerced to a link.
+ *
  * This mapping should match the output sentry.utils.snuba:get_json_type
  */
 export const FIELD_FORMATTERS: FieldFormatters = {
   boolean: {
     sortField: true,
-    renderFunc: (field, data, {organization, location}) => {
+    renderFunc: (field, data, {location}) => {
       const target = {
-        pathname: `/organizations/${organization.slug}/events/`,
+        pathname: location.pathname,
         query: {
           ...location.query,
           query: `${field}:${data[field]}`,
@@ -207,7 +210,7 @@ export const FIELD_FORMATTERS: FieldFormatters = {
     sortField: true,
     renderFunc: (field, data) => (
       <NumberContainer>
-        {typeof data[field] === 'number' ? <Count value={data[field]} /> : null}
+        {typeof data[field] === 'number' ? <Count value={data[field]} /> : emptyValue}
       </NumberContainer>
     ),
   },
@@ -215,7 +218,7 @@ export const FIELD_FORMATTERS: FieldFormatters = {
     sortField: true,
     renderFunc: (field, data) => (
       <NumberContainer>
-        {typeof data[field] === 'number' ? <Count value={data[field]} /> : null}
+        {typeof data[field] === 'number' ? <Count value={data[field]} /> : emptyValue}
       </NumberContainer>
     ),
   },
@@ -223,22 +226,20 @@ export const FIELD_FORMATTERS: FieldFormatters = {
     sortField: true,
     renderFunc: (field, data) => (
       <Container>
-        {data[field] ? (
-          getDynamicText({
-            value: <StyledDateTime date={data[field]} />,
-            fixed: 'timestamp',
-          })
-        ) : (
-          <span>t('n/a')</span>
-        )}
+        {data[field]
+          ? getDynamicText({
+              value: <StyledDateTime date={data[field]} />,
+              fixed: 'timestamp',
+            })
+          : emptyValue}
       </Container>
     ),
   },
   string: {
     sortField: true,
-    renderFunc: (field, data, {organization, location}) => {
+    renderFunc: (field, data, {location}) => {
       const target = {
-        pathname: `/organizations/${organization.slug}/events/`,
+        pathname: location.pathname,
         query: {
           ...location.query,
           query: `${field}:${data[field]}`,
@@ -249,6 +250,69 @@ export const FIELD_FORMATTERS: FieldFormatters = {
   },
 };
 
+const eventLink = (
+  location: Location,
+  data: EventData,
+  content: string | React.ReactNode
+): React.ReactNode => {
+  const id = data.id || data.latest_event;
+  const target = {
+    pathname: location.pathname,
+    query: {
+      ...location.query,
+      eventSlug: `${data['project.name']}:${id}`,
+    },
+  };
+  return <OverflowLink to={target}>{content}</OverflowLink>;
+};
+
+type LinkFormatter = (
+  field: string,
+  data: EventData,
+  baggage: RenderFunctionBaggage
+) => React.ReactNode;
+
+type LinkFormatters = {
+  integer: LinkFormatter;
+  number: LinkFormatter;
+  date: LinkFormatter;
+  string: LinkFormatter;
+};
+
+export const LINK_FORMATTERS: LinkFormatters = {
+  string: (field, data, {location}) => {
+    return <Container>{eventLink(location, data, data[field])}</Container>;
+  },
+  number: (field, data, {location}) => {
+    return (
+      <NumberContainer>
+        {typeof data[field] === 'number'
+          ? eventLink(location, data, <Count value={data[field]} />)
+          : emptyValue}
+      </NumberContainer>
+    );
+  },
+  integer: (field, data, {location}) => {
+    return (
+      <NumberContainer>
+        {typeof data[field] === 'number'
+          ? eventLink(location, data, <Count value={data[field]} />)
+          : emptyValue}
+      </NumberContainer>
+    );
+  },
+  date: (field, data, {location}) => {
+    let content = emptyValue;
+    if (data[field]) {
+      content = getDynamicText({
+        value: <StyledDateTime date={data[field]} />,
+        fixed: <span>timestamp</span>,
+      });
+    }
+    return <Container>{eventLink(location, data, content)}</Container>;
+  },
+};
+
 type SpecialFieldRenderFunc = (
   data: EventData,
   baggage: RenderFunctionBaggage
@@ -287,9 +351,9 @@ export const SPECIAL_FIELDS: SpecialFields = {
       };
       return (
         <Container>
-          <Link css={overflowEllipsis} to={target} aria-label={data.transaction}>
+          <OverflowLink to={target} aria-label={data.transaction}>
             {data.transaction}
-          </Link>
+          </OverflowLink>
         </Container>
       );
     },
@@ -304,9 +368,9 @@ export const SPECIAL_FIELDS: SpecialFields = {
       };
       return (
         <Container>
-          <Link css={overflowEllipsis} to={target} aria-label={data.title}>
+          <OverflowLink to={target} aria-label={data.title}>
             {data.title}
-          </Link>
+          </OverflowLink>
         </Container>
       );
     },
@@ -375,20 +439,23 @@ export const SPECIAL_FIELDS: SpecialFields = {
     renderFunc: data => {
       return (
         <Container>
-          {data.last_seen ? (
-            getDynamicText({
-              value: <StyledDateTime date={data.last_seen} />,
-              fixed: 'time',
-            })
-          ) : (
-            <span>n/a</span>
-          )}
+          {data.last_seen
+            ? getDynamicText({
+                value: <StyledDateTime date={data.last_seen} />,
+                fixed: 'time',
+              })
+            : emptyValue}
         </Container>
       );
     },
   },
 };
 
+/**
+ * List of fields that have links auto-generated
+ */
+export const AUTOLINK_FIELDS: string[] = ['transaction', 'title'];
+
 const Container = styled('div')`
   padding: ${space(1)};
   ${overflowEllipsis};
@@ -404,3 +471,7 @@ const StyledDateTime = styled(DateTime)`
   color: ${p => p.theme.gray2};
   ${overflowEllipsis};
 `;
+
+const OverflowLink = styled(Link)`
+  ${overflowEllipsis};
+`;
diff --git a/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx b/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
index b761c5e5e1..f759ad101a 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
@@ -4,7 +4,7 @@ import {isString, pick} from 'lodash';
 import {EventViewv1} from 'app/types';
 import {DEFAULT_PER_PAGE} from 'app/constants';
 
-import {SPECIAL_FIELDS, FIELD_FORMATTERS} from './data';
+import {AUTOLINK_FIELDS, SPECIAL_FIELDS, FIELD_FORMATTERS} from './data';
 import {MetaType, EventQuery, getAggregateAlias} from './utils';
 
 type Descending = {
@@ -224,36 +224,45 @@ class EventView {
     });
   }
 
-  generateQueryStringObject = (): Query => {
+  generateQueryStringObject(): Query {
     return {
       field: encodeFields(this.fields),
       sort: encodeSorts(this.sorts),
       tag: this.tags,
       query: this.query,
     };
-  };
+  }
 
-  isValid = (): boolean => {
+  isValid(): boolean {
     return this.fields.length > 0;
-  };
+  }
 
-  getFieldTitles = () => {
+  getFieldTitles(): string[] {
     return this.fields.map(field => {
       return field.title;
     });
-  };
+  }
 
-  getFieldNames = () => {
+  getFieldNames(): string[] {
     return this.fields.map(field => {
       return field.field;
     });
-  };
+  }
+
+  /**
+   * Check if the field set contains no automatically linked fields
+   */
+  hasAutolinkField(): boolean {
+    return this.fields.some(field => {
+      return AUTOLINK_FIELDS.includes(field.field);
+    });
+  }
 
-  numOfColumns = (): number => {
+  numOfColumns(): number {
     return this.fields.length;
-  };
+  }
 
-  getQuery = (inputQuery: string | string[] | null | undefined): string => {
+  getQuery(inputQuery: string | string[] | null | undefined): string {
     const queryParts: Array<string> = [];
 
     if (this.query) {
@@ -277,10 +286,10 @@ class EventView {
     }
 
     return queryParts.join(' ');
-  };
+  }
 
   // Takes an EventView instance and converts it into the format required for the events API
-  getEventsAPIPayload = (location: Location): EventQuery => {
+  getEventsAPIPayload(location: Location): EventQuery {
     const query = location.query || {};
 
     type LocationQuery = {
@@ -321,17 +330,17 @@ class EventView {
     }
 
     return eventQuery;
-  };
+  }
 
-  getDefaultSort = (): string | undefined => {
+  getDefaultSort(): string | undefined {
     if (this.sorts.length <= 0) {
       return void 0;
     }
 
     return encodeSort(this.sorts[0]);
-  };
+  }
 
-  getSortKey = (fieldname: string, meta: MetaType): string | null => {
+  getSortKey(fieldname: string, meta: MetaType): string | null {
     const column = getAggregateAlias(fieldname);
     if (SPECIAL_FIELDS.hasOwnProperty(column)) {
       return SPECIAL_FIELDS[column as keyof typeof SPECIAL_FIELDS].sortField;
@@ -344,7 +353,7 @@ class EventView {
     }
 
     return null;
-  };
+  }
 }
 
 export default EventView;
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table.tsx b/src/sentry/static/sentry/app/views/eventsV2/table.tsx
index 3a0048e7cc..a9cdd04437 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table.tsx
@@ -44,6 +44,9 @@ type State = {
   dataPayload: DataPayload | null | undefined;
 };
 
+/**
+ * Container element that fetches events and handles pagination
+ */
 class Table extends React.PureComponent<Props, State> {
   state: State = {
     eventView: EventView.fromLocation(this.props.location),
@@ -137,6 +140,9 @@ type TableViewProps = {
   location: Location;
 };
 
+/**
+ * Renders the table headers and rows for the result set.
+ */
 class TableView extends React.Component<TableViewProps> {
   renderLoading = () => {
     return (
@@ -208,11 +214,8 @@ class TableView extends React.Component<TableViewProps> {
     //     </PanelGridInfo>
     //   );
     // }
-
     const lastRowIndex = dataPayload.data.length - 1;
-
-    // TODO add links to the first column even if it isn't one of our
-    // preferred link columns (title, transaction, latest_event)
+    const hasLinkField = eventView.hasAutolinkField();
     const firstCellIndex = 0;
     const lastCellIndex = fields.length - 1;
 
@@ -221,8 +224,9 @@ class TableView extends React.Component<TableViewProps> {
         <React.Fragment key={rowIndex}>
           {fields.map((field, columnIndex) => {
             const key = `${field}.${columnIndex}`;
+            const forceLinkField = !hasLinkField && columnIndex === 0;
 
-            const fieldRenderer = getFieldRenderer(field, meta);
+            const fieldRenderer = getFieldRenderer(field, meta, forceLinkField);
             return (
               <PanelItemCell
                 hideBottomBorder={rowIndex === lastRowIndex}
diff --git a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
index d564c55a8d..208764ae4b 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
@@ -6,6 +6,7 @@ import {URL_PARAM} from 'app/constants/globalSelectionHeader';
 import {
   AGGREGATE_ALIASES,
   SPECIAL_FIELDS,
+  LINK_FORMATTERS,
   FIELD_FORMATTERS,
   FieldTypes,
   FieldFormatterRenderFunctionPartial,
@@ -139,17 +140,26 @@ export type MetaType = {
  *
  * @param {String} field name
  * @param {object} metadata mapping.
+ * @param {boolean} Whether or not to coerce a field into a link.
  * @returns {Function}
  */
 export function getFieldRenderer(
   field: string,
-  meta: MetaType
+  meta: MetaType,
+  forceLink: boolean
 ): FieldFormatterRenderFunctionPartial {
   if (SPECIAL_FIELDS.hasOwnProperty(field)) {
     return SPECIAL_FIELDS[field].renderFunc;
   }
   const fieldName = getAggregateAlias(field);
   const fieldType = meta[fieldName];
+
+  // If the current field is being coerced to a link
+  // use a different formatter set based on the type.
+  if (forceLink && LINK_FORMATTERS.hasOwnProperty(fieldType)) {
+    return partial(LINK_FORMATTERS[fieldType], fieldName);
+  }
+
   if (FIELD_FORMATTERS.hasOwnProperty(fieldType)) {
     return partial(FIELD_FORMATTERS[fieldType].renderFunc, fieldName);
   }
diff --git a/tests/js/spec/views/eventsV2/utils.spec.jsx b/tests/js/spec/views/eventsV2/utils.spec.jsx
index 0a6ffc68f6..8679b184c3 100644
--- a/tests/js/spec/views/eventsV2/utils.spec.jsx
+++ b/tests/js/spec/views/eventsV2/utils.spec.jsx
@@ -1,4 +1,11 @@
-import {getAggregateAlias, getEventTagSearchUrl} from 'app/views/eventsV2/utils';
+import {mount} from 'enzyme';
+
+import {initializeOrg} from 'app-test/helpers/initializeOrg';
+import {
+  getFieldRenderer,
+  getAggregateAlias,
+  getEventTagSearchUrl,
+} from 'app/views/eventsV2/utils';
 
 describe('eventTagSearchUrl()', function() {
   let location;
@@ -50,3 +57,186 @@ describe('getAggregateAlias', function() {
     expect(getAggregateAlias('count_unique(issue.id)')).toEqual('count_unique_issue_id');
   });
 });
+
+describe('getFieldRenderer', function() {
+  let location, context, project, organization, data;
+  beforeEach(function() {
+    context = initializeOrg({
+      project: TestStubs.Project(),
+    });
+    organization = context.organization;
+    project = context.project;
+
+    location = {
+      pathname: '/events',
+      query: {},
+    };
+    data = {
+      title: 'ValueError: something bad',
+      transaction: 'api.do_things',
+      boolValue: 1,
+      numeric: 1.23,
+      createdAt: new Date(2019, 9, 3, 12, 13, 14),
+      url: '/example',
+      latest_event: 'deadbeef',
+      'project.name': project.slug,
+    };
+  });
+
+  it('can render string fields', function() {
+    const renderer = getFieldRenderer('url', {url: 'string'});
+    expect(renderer).toBeInstanceOf(Function);
+    const wrapper = mount(renderer(data, {location, organization}));
+    const link = wrapper.find('QueryLink');
+    expect(link).toHaveLength(1);
+    expect(link.props().to).toEqual({
+      pathname: location.pathname,
+      query: {query: 'url:/example'},
+    });
+    expect(link.text()).toEqual(data.url);
+  });
+
+  it('can render boolean fields', function() {
+    const renderer = getFieldRenderer('boolValue', {boolValue: 'boolean'});
+    expect(renderer).toBeInstanceOf(Function);
+    const wrapper = mount(renderer(data, {location, organization}));
+    const link = wrapper.find('QueryLink');
+    expect(link).toHaveLength(1);
+    expect(link.props().to).toEqual({
+      pathname: location.pathname,
+      query: {query: 'boolValue:1'},
+    });
+  });
+
+  it('can render integer fields', function() {
+    const renderer = getFieldRenderer('numeric', {numeric: 'integer'});
+    expect(renderer).toBeInstanceOf(Function);
+    const wrapper = mount(renderer(data, {location, organization}));
+
+    const value = wrapper.find('Count');
+    expect(value).toHaveLength(1);
+    expect(value.props().value).toEqual(data.numeric);
+  });
+
+  it('can render date fields', function() {
+    const renderer = getFieldRenderer('createdAt', {createdAt: 'date'});
+    expect(renderer).toBeInstanceOf(Function);
+    const wrapper = mount(renderer(data, {location, organization}));
+
+    const value = wrapper.find('StyledDateTime');
+    expect(value).toHaveLength(1);
+    expect(value.props().date).toEqual(data.createdAt);
+  });
+
+  it('can render null date fields', function() {
+    const renderer = getFieldRenderer('nope', {nope: 'date'});
+    expect(renderer).toBeInstanceOf(Function);
+    const wrapper = mount(renderer(data, {location, organization}));
+
+    const value = wrapper.find('StyledDateTime');
+    expect(value).toHaveLength(0);
+    expect(wrapper.text()).toEqual('n/a');
+  });
+
+  it('can render transaction as a link', function() {
+    const renderer = getFieldRenderer('transaction', {transaction: 'string'});
+    expect(renderer).toBeInstanceOf(Function);
+    const wrapper = mount(renderer(data, {location, organization}));
+
+    const value = wrapper.find('OverflowLink');
+    expect(value).toHaveLength(1);
+    expect(value.props().to).toEqual({
+      pathname: location.pathname,
+      query: {
+        eventSlug: `${project.slug}:deadbeef`,
+      },
+    });
+    expect(value.text()).toEqual(data.transaction);
+  });
+
+  it('can render title as a link', function() {
+    const renderer = getFieldRenderer('title', {title: 'string'});
+    expect(renderer).toBeInstanceOf(Function);
+    const wrapper = mount(renderer(data, {location, organization}));
+
+    const value = wrapper.find('OverflowLink');
+    expect(value).toHaveLength(1);
+    expect(value.props().to).toEqual({
+      pathname: location.pathname,
+      query: {
+        eventSlug: `${project.slug}:deadbeef`,
+      },
+    });
+    expect(value.text()).toEqual(data.title);
+  });
+
+  it('can render project as an avatar', function() {
+    const renderer = getFieldRenderer('project', {'project.name': 'string'});
+    expect(renderer).toBeInstanceOf(Function);
+    const wrapper = mount(
+      renderer(data, {location, organization}),
+      context.routerContext
+    );
+
+    const value = wrapper.find('ProjectBadge');
+    expect(value).toHaveLength(1);
+    expect(value.props().project).toEqual(project);
+  });
+
+  it('can coerce string field to a link', function() {
+    const renderer = getFieldRenderer('url', {url: 'string'}, true);
+    expect(renderer).toBeInstanceOf(Function);
+    const wrapper = mount(
+      renderer(data, {location, organization}),
+      context.routerContext
+    );
+
+    // No basic link should be present.
+    expect(wrapper.find('QueryLink')).toHaveLength(0);
+
+    const link = wrapper.find('OverflowLink');
+    expect(link.props().to).toEqual({
+      pathname: location.pathname,
+      query: {
+        eventSlug: `${project.slug}:deadbeef`,
+      },
+    });
+    expect(link.text()).toEqual('/example');
+  });
+
+  it('can coerce number field to a link', function() {
+    const renderer = getFieldRenderer('numeric', {numeric: 'number'}, true);
+    expect(renderer).toBeInstanceOf(Function);
+    const wrapper = mount(
+      renderer(data, {location, organization}),
+      context.routerContext
+    );
+
+    const link = wrapper.find('OverflowLink');
+    expect(link.props().to).toEqual({
+      pathname: location.pathname,
+      query: {
+        eventSlug: `${project.slug}:deadbeef`,
+      },
+    });
+    expect(link.find('Count').props().value).toEqual(data.numeric);
+  });
+
+  it('can coerce date field to a link', function() {
+    const renderer = getFieldRenderer('createdAt', {createdAt: 'date'}, true);
+    expect(renderer).toBeInstanceOf(Function);
+    const wrapper = mount(
+      renderer(data, {location, organization}),
+      context.routerContext
+    );
+
+    const link = wrapper.find('OverflowLink');
+    expect(link.props().to).toEqual({
+      pathname: location.pathname,
+      query: {
+        eventSlug: `${project.slug}:deadbeef`,
+      },
+    });
+    expect(link.find('StyledDateTime').props().date).toEqual(data.createdAt);
+  });
+});
diff --git a/tests/snuba/api/endpoints/test_organization_event_details.py b/tests/snuba/api/endpoints/test_organization_event_details.py
index 1f0ef4006f..b0255ce167 100644
--- a/tests/snuba/api/endpoints/test_organization_event_details.py
+++ b/tests/snuba/api/endpoints/test_organization_event_details.py
@@ -139,6 +139,56 @@ class OrganizationEventDetailsEndpointTest(OrganizationEventDetailsTestBase):
         assert response.data["oldestEventID"] == "e" * 32, "e is oldest matching message"
         assert response.data["latestEventID"] == "1" * 32, "1 is newest matching message"
 
+    def test_event_links_with_tag_fields(self):
+        # Create events that overlap with other event messages but
+        # with different tags
+        ten_sec_ago = iso_format(before_now(seconds=10))
+        self.store_event(
+            data={
+                "event_id": "2" * 32,
+                "message": "very bad",
+                "timestamp": ten_sec_ago,
+                "tags": {"important": "yes"},
+            },
+            project_id=self.project.id,
+        )
+        thirty_sec_ago = iso_format(before_now(seconds=30))
+        self.store_event(
+            data={
+                "event_id": "1" * 32,
+                "message": "very bad",
+                "timestamp": thirty_sec_ago,
+                "tags": {"important": "yes"},
+            },
+            project_id=self.project.id,
+        )
+        five_min_ago = iso_format(before_now(minutes=5))
+        self.store_event(
+            data={
+                "event_id": "d" * 32,
+                "message": "very bad",
+                "timestamp": five_min_ago,
+                "tags": {"important": "no"},
+            },
+            project_id=self.project.id,
+        )
+
+        url = reverse(
+            "sentry-api-0-organization-event-details",
+            kwargs={
+                "organization_slug": self.project.organization.slug,
+                "project_slug": self.project.slug,
+                "event_id": "1" * 32,
+            },
+        )
+        with self.feature("organizations:events-v2"):
+            response = self.client.get(url, format="json", data={"field": ["important", "count()"]})
+        assert response.data["eventID"] == "1" * 32
+        assert response.data["previousEventID"] is None, "no matching tags"
+        assert response.data["oldestEventID"] is None, "no older matching events"
+        assert response.data["nextEventID"] == "2" * 32, "2 is older and has matching tags "
+        assert response.data["latestEventID"] == "2" * 32, "2 is oldest matching message"
+
 
 class OrganizationEventDetailsLatestEndpointTest(OrganizationEventDetailsTestBase):
     def test_simple(self):

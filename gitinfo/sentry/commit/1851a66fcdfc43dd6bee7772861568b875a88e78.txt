commit 1851a66fcdfc43dd6bee7772861568b875a88e78
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Thu Apr 5 11:17:16 2018 -0700

    fix(ui+api): Fix SSO-required infinite redirect (#7912)
    
    * update response when sso is required
    * create common API exceptions

diff --git a/src/sentry/api/bases/organization.py b/src/sentry/api/bases/organization.py
index 5300afe5f3..3a229eca0a 100644
--- a/src/sentry/api/bases/organization.py
+++ b/src/sentry/api/bases/organization.py
@@ -1,9 +1,7 @@
 from __future__ import absolute_import
 
-from rest_framework.exceptions import NotAuthenticated
-
 from sentry.api.base import Endpoint, logger
-from sentry.api.exceptions import ResourceDoesNotExist
+from sentry.api.exceptions import ResourceDoesNotExist, SsoRequired, TwoFactorRequired
 from sentry.api.permissions import ScopedPermission
 from sentry.app import raven
 from sentry.auth import access
@@ -74,7 +72,8 @@ class OrganizationPermission(ScopedPermission):
                             'user_id': request.user.id,
                         }
                     )
-                    raise NotAuthenticated(detail='Must login via SSO')
+
+                    raise SsoRequired(organization)
 
                 if self.is_not_2fa_compliant(
                         request.user, organization):
@@ -85,8 +84,7 @@ class OrganizationPermission(ScopedPermission):
                             'user_id': request.user.id,
                         }
                     )
-                    raise NotAuthenticated(
-                        detail='Organization requires two-factor authentication to be enabled')
+                    raise TwoFactorRequired()
 
         allowed_scopes = set(self.scope_map.get(request.method, []))
         return any(request.access.has_scope(s) for s in allowed_scopes)
diff --git a/src/sentry/api/decorators.py b/src/sentry/api/decorators.py
index 6c83b970e2..ed4ce553e8 100644
--- a/src/sentry/api/decorators.py
+++ b/src/sentry/api/decorators.py
@@ -1,8 +1,8 @@
 from __future__ import absolute_import
 
-from rest_framework.response import Response
 from functools import wraps
 
+from sentry.api.exceptions import SudoRequired
 from sentry.models import ApiKey, ApiToken
 
 
@@ -24,12 +24,7 @@ def sudo_required(func):
         if not is_considered_sudo(request):
             # TODO(dcramer): support some kind of auth flow to allow this
             # externally
-            data = {
-                "error": "Account verification required.",
-                "sudoRequired": True,
-                "username": request.user.username,
-            }
-            return Response(data, status=401)
+            raise SudoRequired(request.user)
         return func(self, request, *args, **kwargs)
 
     return wrapped
diff --git a/src/sentry/api/endpoints/sudo.py b/src/sentry/api/endpoints/sudo.py
index 8c4a1c1a65..8968c27e12 100644
--- a/src/sentry/api/endpoints/sudo.py
+++ b/src/sentry/api/endpoints/sudo.py
@@ -40,5 +40,5 @@ class SudoEndpoint(Endpoint):
             grant_sudo_privileges(request._request)
             return Response(status=status.HTTP_204_NO_CONTENT)
 
-        return Response({'allowFail': True}, content_type="application/json",
-                        status=status.HTTP_401_UNAUTHORIZED)
+        # UI treats 401s by redirecting, this 401 should be ignored
+        return Response({'detail': {'code': 'ignore'}}, status=status.HTTP_401_UNAUTHORIZED)
diff --git a/src/sentry/api/exceptions.py b/src/sentry/api/exceptions.py
index c372adf37e..dfaccf9760 100644
--- a/src/sentry/api/exceptions.py
+++ b/src/sentry/api/exceptions.py
@@ -1,14 +1,57 @@
 from __future__ import absolute_import
 
+from django.core.urlresolvers import reverse
+from rest_framework import status
 from rest_framework.exceptions import APIException
 
 
 class ResourceDoesNotExist(APIException):
-    status_code = 404
+    status_code = status.HTTP_404_NOT_FOUND
 
 
 class ResourceMoved(APIException):
-    status_code = 301
+    status_code = status.HTTP_301_MOVED_PERMANENTLY
+
+
+class SentryAPIException(APIException):
+    code = ''
+    message = ''
+
+    def __init__(self, code=None, message=None, detail=None, **kwargs):
+        if detail is None:
+            detail = {
+                'code': code or self.code,
+                'message': message or self.message,
+                'extra': kwargs,
+            }
+
+        super(SentryAPIException, self).__init__(detail=detail)
+
+
+class SsoRequired(SentryAPIException):
+    status_code = status.HTTP_401_UNAUTHORIZED
+    code = 'sso-required'
+    message = 'Must login via SSO'
+
+    def __init__(self, organization):
+        super(SsoRequired, self).__init__(
+            loginUrl=reverse('sentry-auth-organization', args=[organization.slug])
+        )
+
+
+class SudoRequired(SentryAPIException):
+    status_code = status.HTTP_401_UNAUTHORIZED
+    code = 'sudo-required'
+    message = 'Account verification required.'
+
+    def __init__(self, user):
+        super(SudoRequired, self).__init__(username=user.username)
+
+
+class TwoFactorRequired(APIException):
+    status_code = status.HTTP_401_UNAUTHORIZED
+    code = '2fa-required'
+    message = 'Organization requires two-factor authentication to be enabled'
 
 
 class InvalidRepository(Exception):
diff --git a/src/sentry/static/sentry/app/api.jsx b/src/sentry/static/sentry/app/api.jsx
index 6bf8294a44..d830bcf2a4 100644
--- a/src/sentry/static/sentry/app/api.jsx
+++ b/src/sentry/static/sentry/app/api.jsx
@@ -71,7 +71,10 @@ export class Client {
 
   handleRequestError({id, path, requestOptions}, response, ...responseArgs) {
     let isSudoRequired =
-      response && response.responseJSON && response.responseJSON.sudoRequired;
+      response &&
+      response.responseJSON &&
+      response.responseJSON.detail &&
+      response.responseJSON.detail.code === 'sudo-required';
 
     if (isSudoRequired) {
       openSudo({
diff --git a/src/sentry/static/sentry/app/views/app.jsx b/src/sentry/static/sentry/app/views/app.jsx
index 1d1a4e547e..a269db890a 100644
--- a/src/sentry/static/sentry/app/views/app.jsx
+++ b/src/sentry/static/sentry/app/views/app.jsx
@@ -102,18 +102,31 @@ const App = createReactClass({
       // TODO: Need better way of identifying anonymous pages
       //       that don't trigger redirect
       let pageAllowsAnon = /^\/share\//.test(window.location.pathname);
+
+      // Ignore error unless it is a 401
+      if (!jqXHR || jqXHR.status !== 401 || pageAllowsAnon) return;
+
+      let response = jqXHR.responseJSON;
+
+      // 401s can also mean sudo is required or it's a request that is allowed to fail
+      // Ignore if these are the cases
       if (
-        jqXHR &&
-        jqXHR.status === 401 &&
-        !pageAllowsAnon &&
-        (!jqXHR.responseJSON ||
-          (!jqXHR.responseJSON.sudoRequired && !jqXHR.responseJSON.allowFail))
-      ) {
-        Cookies.set('session_expired', 1);
-        // User has become unauthenticated; reload URL, and let Django
-        // redirect to login page
-        window.location.reload();
+        response &&
+        response.detail &&
+        (response.detail.code === 'sudo-required' || response.detail.code === 'ignore')
+      )
+        return;
+
+      // If user must login via SSO, redirect to org login page
+      if (response && response.detail && response.detail.code === 'sso-required') {
+        window.location.assign(response.detail.extra.loginUrl);
+        return;
       }
+
+      // Otherwise, user has become unauthenticated; reload URL, and let Django
+      // redirect to login page
+      Cookies.set('session_expired', 1);
+      window.location.reload();
     });
   },
 
diff --git a/tests/js/spec/components/modals/sudoModal.spec.jsx b/tests/js/spec/components/modals/sudoModal.spec.jsx
index 28af0e86c2..61f6935bf4 100644
--- a/tests/js/spec/components/modals/sudoModal.spec.jsx
+++ b/tests/js/spec/components/modals/sudoModal.spec.jsx
@@ -4,7 +4,6 @@ import {mount} from 'enzyme';
 import {Client} from 'app/api';
 import ConfigStore from 'app/stores/configStore';
 import App from 'app/views/app';
-import {SudoModal} from 'app/components/modals/sudoModal';
 
 jest.mock('jquery');
 
@@ -32,7 +31,10 @@ describe('Sudo Modal', function() {
       method: 'DELETE',
       statusCode: 401,
       body: {
-        sudoRequired: true,
+        detail: {
+          code: 'sudo-required',
+          username: 'test@test.com',
+        },
       },
     });
     Client.addMockResponse({
@@ -46,8 +48,8 @@ describe('Sudo Modal', function() {
     ConfigStore.set('messages', []);
   });
 
-  it('can delete an org with sudo flow', function(done) {
-    mount(<App>{<div>placeholder content</div>}</App>);
+  it('can delete an org with sudo flow', async function() {
+    let wrapper = mount(<App>{<div>placeholder content</div>}</App>);
 
     let api = new Client();
     let successCb = jest.fn();
@@ -55,7 +57,7 @@ describe('Sudo Modal', function() {
     let orgDeleteMock;
 
     // No Modal
-    expect($('.modal input')).toHaveLength(0);
+    expect(wrapper.find('ModalDialog')).toHaveLength(0);
 
     // Should return w/ `sudoRequired`
     api.request('/organizations/org-slug/', {
@@ -64,69 +66,66 @@ describe('Sudo Modal', function() {
       error: errorCb,
     });
 
-    SudoModal.prototype.componentDidMount = function() {
-      try {
-        const $input = $('.modal input');
-        expect($input).toHaveLength(1);
-        // Original callbacks should not have been called
-        expect(successCb).not.toBeCalled();
-        expect(errorCb).not.toBeCalled();
-
-        // Clear mocks and allow DELETE
-        Client.clearMockResponses();
-        orgDeleteMock = Client.addMockResponse({
-          url: '/organizations/org-slug/',
-          method: 'DELETE',
-          statusCode: 200,
-        });
-        let sudoMock = Client.addMockResponse({
-          url: '/sudo/',
-          method: 'POST',
-          statusCode: 200,
-        });
-
-        expect(sudoMock).not.toHaveBeenCalled();
-
-        // "Sudo" auth
-        $input.val('password');
-
-        $('.modal form').on('submit', () => {
-          setTimeout(() => {
-            expect(sudoMock).toHaveBeenCalledWith(
-              '/sudo/',
-              expect.objectContaining({
-                method: 'POST',
-                // XXX: This doesn't submit with password in tests because modal is rendered outside of
-                // react tree. So we can't simulate react events on input
-                // data: {
-                // password: 'password',
-                // },
-              })
-            );
-
-            // Check for original API request to be retried
-            setTimeout(() => {
-              try {
-                // Retry API request
-                expect(successCb).toHaveBeenCalled();
-                expect(orgDeleteMock).toHaveBeenCalledWith(
-                  '/organizations/org-slug/',
-                  expect.objectContaining({
-                    method: 'DELETE',
-                  })
-                );
-              } catch (err) {
-                done(err);
-              }
-              done();
-            }, 1);
-          }, 1);
-        });
-
-        $('.modal [type="submit"]').click();
-      } catch (err) {
-        done(err);
-      }
-    };
+    await tick();
+    await tick();
+    wrapper.update();
+
+    // Should have Modal + input
+    expect(wrapper.find('ModalDialog input')).toHaveLength(1);
+
+    // Original callbacks should not have been called
+    expect(successCb).not.toBeCalled();
+    expect(errorCb).not.toBeCalled();
+
+    // Clear mocks and allow DELETE
+    Client.clearMockResponses();
+    orgDeleteMock = Client.addMockResponse({
+      url: '/organizations/org-slug/',
+      method: 'DELETE',
+      statusCode: 200,
+    });
+    let sudoMock = Client.addMockResponse({
+      url: '/sudo/',
+      method: 'POST',
+      statusCode: 200,
+    });
+
+    expect(sudoMock).not.toHaveBeenCalled();
+
+    // "Sudo" auth
+    wrapper
+      .find('ModalDialog input[name="password"]')
+      .simulate('change', {target: {value: 'password'}});
+
+    wrapper.find('ModalDialog form').simulate('submit');
+    wrapper.find('ModalDialog [type="submit"]').simulate('click');
+
+    await tick();
+    wrapper.update();
+
+    expect(sudoMock).toHaveBeenCalledWith(
+      '/sudo/',
+      expect.objectContaining({
+        method: 'POST',
+        data: {
+          password: 'password',
+        },
+      })
+    );
+
+    // Retry API request
+    expect(successCb).toHaveBeenCalled();
+    expect(orgDeleteMock).toHaveBeenCalledWith(
+      '/organizations/org-slug/',
+      expect.objectContaining({
+        method: 'DELETE',
+      })
+    );
+
+    await tick();
+    wrapper.update();
+
+    // Sudo Modal should be closed
+    expect(wrapper.find('ModalDialog')).toHaveLength(0);
   });
 });
diff --git a/tests/sentry/api/endpoints/test_sudo.py b/tests/sentry/api/endpoints/test_sudo.py
index a33d4b4fb6..f2e8d557fb 100644
--- a/tests/sentry/api/endpoints/test_sudo.py
+++ b/tests/sentry/api/endpoints/test_sudo.py
@@ -29,7 +29,9 @@ class SudoTest(APITestCase):
         with self.settings(MIDDLEWARE_CLASSES=tuple(middleware)):
             response = self.client.delete(url, is_sudo=False)
             assert response.status_code == 401
-            assert response.data['sudoRequired']
+            assert response.data['detail']['code'] == 'sudo-required'
+            assert response.data['detail']['message'] == 'Account verification required.'
+            assert response.data['detail']['extra']['username'] == 'foo@example.com'
 
             sudo_url = reverse('sentry-api-0-sudo', kwargs={})
             # Now try to gain sudo access

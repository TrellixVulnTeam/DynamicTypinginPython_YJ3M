commit 4e081dec1b8796a75125593bd91ea70db41e2b0c
Author: David Cramer <dcramer@gmail.com>
Date:   Fri Oct 14 12:49:14 2016 -0700

    [plugins] improve social auth behavior (#4302)
    
    - remove login flow views
    - gracefully handle errors on pipeline auth
    - change default redirects to identities page

diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index 364e31445b..d7fe450b3d 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -331,6 +331,8 @@ SOCIAL_AUTH_PIPELINE = (
     'social_auth.backends.pipeline.misc.save_status_to_session',
 )
 SOCIAL_AUTH_REVOKE_TOKENS_ON_DISCONNECT = True
+SOCIAL_AUTH_LOGIN_REDIRECT_URL = '/account/settings/identities/'
+SOCIAL_AUTH_ASSOCIATE_ERROR_URL = SOCIAL_AUTH_LOGIN_REDIRECT_URL
 
 INITIAL_CUSTOM_USER_MIGRATION = '0108_fix_user'
 
diff --git a/src/sentry/web/frontend/accounts.py b/src/sentry/web/frontend/accounts.py
index 39aef0c4a9..f527a89833 100644
--- a/src/sentry/web/frontend/accounts.py
+++ b/src/sentry/web/frontend/accounts.py
@@ -349,7 +349,7 @@ def disconnect_identity(request, identity_id):
 
     messages.add_message(
         request, messages.SUCCESS,
-        'Your {} association has been revoked.'.format(
+        'Your {} identity has been disconnected.'.format(
             settings.AUTH_PROVIDER_LABELS.get(backend_name, backend_name),
         )
     )
diff --git a/src/sentry/web/frontend/auth_login.py b/src/sentry/web/frontend/auth_login.py
index ca0a054ec8..173cda8c06 100644
--- a/src/sentry/web/frontend/auth_login.py
+++ b/src/sentry/web/frontend/auth_login.py
@@ -2,6 +2,7 @@ from __future__ import absolute_import
 
 from django.conf import settings
 from django.contrib import messages
+from django.contrib.auth import REDIRECT_FIELD_NAME
 from django.core.urlresolvers import reverse
 from django.db import transaction
 from django.http import HttpResponseRedirect
@@ -123,7 +124,7 @@ class AuthLoginView(BaseView):
     @never_cache
     @transaction.atomic
     def handle(self, request):
-        next_uri = request.GET.get('next', None)
+        next_uri = request.GET.get(REDIRECT_FIELD_NAME, None)
         if request.user.is_authenticated():
             if auth.is_valid_redirect(next_uri):
                 return self.redirect(next_uri)
diff --git a/src/sentry/web/frontend/auth_logout.py b/src/sentry/web/frontend/auth_logout.py
index c6723eae18..99f469d5ae 100644
--- a/src/sentry/web/frontend/auth_logout.py
+++ b/src/sentry/web/frontend/auth_logout.py
@@ -1,6 +1,6 @@
 from __future__ import absolute_import
 
-from django.contrib.auth import logout
+from django.contrib.auth import logout, REDIRECT_FIELD_NAME
 from django.contrib.auth.models import AnonymousUser
 
 from sentry.web.frontend.base import BaseView
@@ -11,7 +11,7 @@ class AuthLogoutView(BaseView):
     auth_required = False
 
     def handle(self, request):
-        next = request.GET.get('next', '')
+        next = request.GET.get(REDIRECT_FIELD_NAME, '')
         if not next.startswith('/'):
             next = auth.get_login_url()
         logout(request)
diff --git a/src/social_auth/views.py b/src/social_auth/views.py
index e77023f1dd..2167969fb6 100644
--- a/src/social_auth/views.py
+++ b/src/social_auth/views.py
@@ -7,15 +7,17 @@ Notes:
 """
 from __future__ import absolute_import
 
+import six
+
 from sudo.utils import is_safe_url
 from django.conf import settings
 from django.http import HttpResponseRedirect, HttpResponse
-from django.contrib.auth import login, REDIRECT_FIELD_NAME
+from django.contrib.auth import REDIRECT_FIELD_NAME
 from django.contrib.auth.decorators import login_required
 from django.contrib import messages
 from django.views.decorators.csrf import csrf_exempt
-from six.moves.urllib.parse import quote
 
+from social_auth.exceptions import AuthAlreadyAssociated, AuthException
 from social_auth.utils import (
     setting, backend_setting, clean_partial_pipeline)
 from social_auth.decorators import dsa_view
@@ -23,57 +25,12 @@ from social_auth.decorators import dsa_view
 
 DEFAULT_REDIRECT = setting('SOCIAL_AUTH_LOGIN_REDIRECT_URL',
                            setting('LOGIN_REDIRECT_URL'))
-LOGIN_ERROR_URL = setting('LOGIN_ERROR_URL', setting('LOGIN_URL'))
+ASSOCIATE_ERROR_URL = setting('SOCIAL_AUTH_ASSOCIATE_ERROR_URL')
 PIPELINE_KEY = setting('SOCIAL_AUTH_PARTIAL_PIPELINE_KEY', 'partial_pipeline')
 
 
 @dsa_view(setting('SOCIAL_AUTH_COMPLETE_URL_NAME', 'socialauth_associate_complete'))
 def auth(request, backend):
-    """Start authentication process"""
-    return auth_process(request, backend)
-
-
-@csrf_exempt
-@dsa_view()
-def complete(request, backend, *args, **kwargs):
-    """Authentication complete view, override this view if transaction
-    management doesn't suit your needs."""
-    if request.user.is_authenticated():
-        return associate_complete(request, backend, *args, **kwargs)
-    else:
-        return complete_process(request, backend, *args, **kwargs)
-
-
-@login_required
-def associate_complete(request, backend, *args, **kwargs):
-    """Authentication complete process"""
-    # pop redirect value before the session is trashed on login()
-    redirect_value = request.session.get(REDIRECT_FIELD_NAME, '')
-    user = auth_complete(request, backend, request.user, *args, **kwargs)
-
-    backend_name = backend.AUTH_BACKEND.name
-
-    messages.add_message(
-        request, messages.SUCCESS,
-        'You have linked your account with {}.'.format(
-            settings.AUTH_PROVIDER_LABELS.get(backend_name, backend_name),
-        )
-    )
-
-    if not user:
-        url = backend_setting(backend, 'LOGIN_ERROR_URL', LOGIN_ERROR_URL)
-    elif isinstance(user, HttpResponse):
-        return user
-    else:
-        url = (
-            redirect_value or
-            backend_setting(backend, 'SOCIAL_AUTH_NEW_ASSOCIATION_REDIRECT_URL') or
-            DEFAULT_REDIRECT
-        )
-    return HttpResponseRedirect(url)
-
-
-def auth_process(request, backend):
     """Authenticate using social backend"""
     data = request.POST if request.method == 'POST' else request.GET
 
@@ -103,85 +60,57 @@ def auth_process(request, backend):
                             content_type='text/html;charset=UTF-8')
 
 
-def complete_process(request, backend, *args, **kwargs):
+@csrf_exempt
+@login_required
+@dsa_view()
+def complete(request, backend, *args, **kwargs):
     """Authentication complete process"""
     # pop redirect value before the session is trashed on login()
-    redirect_value = (
-        request.session.get(REDIRECT_FIELD_NAME, '') or
-        request.REQUEST.get(REDIRECT_FIELD_NAME, '')
-    )
-    user = auth_complete(request, backend, *args, **kwargs)
+    redirect_value = request.session.get(REDIRECT_FIELD_NAME, '')
 
-    if isinstance(user, HttpResponse):
-        return user
+    backend_name = backend.AUTH_BACKEND.name
 
-    if not user and request.user.is_authenticated():
-        return HttpResponseRedirect(redirect_value)
-
-    msg = None
-    if user:
-        if getattr(user, 'is_active', True):
-            # catch is_new flag before login() might reset the instance
-            is_new = getattr(user, 'is_new', False)
-            login(request, user)
-            # user.social_user is the used UserSocialAuth instance defined
-            # in authenticate process
-            social_user = user.social_user
-            if redirect_value:
-                request.session[REDIRECT_FIELD_NAME] = (
-                    redirect_value or DEFAULT_REDIRECT)
-
-            if setting('SOCIAL_AUTH_SESSION_EXPIRATION', True):
-                # Set session expiration date if present and not disabled by
-                # setting. Use last social-auth instance for current provider,
-                # users can associate several accounts with a same provider.
-                expiration = social_user.expiration_datetime()
-                if expiration:
-                    try:
-                        request.session.set_expiry(expiration)
-                    except OverflowError:
-                        # Handle django time zone overflow, set default expiry.
-                        request.session.set_expiry(None)
-
-            # store last login backend name in session
-            request.session['social_auth_last_login_backend'] = social_user.provider
-
-            # Remove possible redirect URL from session, if this is a new
-            # account, send him to the new-users-page if defined.
-            new_user_redirect = backend_setting(
-                backend, 'SOCIAL_AUTH_NEW_USER_REDIRECT_URL')
-            if new_user_redirect and is_new:
-                url = new_user_redirect
-            else:
-                url = (
-                    redirect_value or
-                    backend_setting(backend, 'SOCIAL_AUTH_LOGIN_REDIRECT_URL') or
-                    DEFAULT_REDIRECT
-                )
-        else:
-            msg = setting('SOCIAL_AUTH_INACTIVE_USER_MESSAGE', None)
-            url = backend_setting(backend, 'SOCIAL_AUTH_INACTIVE_USER_URL',
-                                  LOGIN_ERROR_URL)
+    try:
+        user = auth_complete(request, backend, request.user, *args, **kwargs)
+    except AuthAlreadyAssociated:
+        messages.add_message(
+            request, messages.ERROR,
+            'This {} identity is already associated with another account.'.format(
+                settings.AUTH_PROVIDER_LABELS.get(backend_name, backend_name),
+            )
+        )
+    except AuthException as exc:
+        messages.add_message(
+            request, messages.ERROR,
+            six.text_type(exc)
+        )
     else:
-        msg = setting('LOGIN_ERROR_MESSAGE', None)
-        url = backend_setting(backend, 'LOGIN_ERROR_URL', LOGIN_ERROR_URL)
-    if msg:
-        messages.error(request, msg)
-
-    if redirect_value and redirect_value != url:
-        redirect_value = quote(redirect_value)
-        if '?' in url:
-            url += '&%s=%s' % (REDIRECT_FIELD_NAME, redirect_value)
-        else:
-            url += '?%s=%s' % (REDIRECT_FIELD_NAME, redirect_value)
+        messages.add_message(
+            request, messages.SUCCESS,
+            'You have linked your account with {}.'.format(
+                settings.AUTH_PROVIDER_LABELS.get(backend_name, backend_name),
+            )
+        )
+
+    if not user:
+        url = (
+            redirect_value or
+            ASSOCIATE_ERROR_URL or
+            DEFAULT_REDIRECT
+        )
+    elif isinstance(user, HttpResponse):
+        return user
+    else:
+        url = (
+            redirect_value or
+            backend_setting(backend, 'SOCIAL_AUTH_NEW_ASSOCIATION_REDIRECT_URL') or
+            DEFAULT_REDIRECT
+        )
     return HttpResponseRedirect(url)
 
 
-def auth_complete(request, backend, user=None, *args, **kwargs):
+def auth_complete(request, backend, user, *args, **kwargs):
     """Complete auth process. Return authenticated user or None."""
-    if user and not user.is_authenticated():
-        user = None
-
     if request.session.get(PIPELINE_KEY):
         data = request.session.pop(PIPELINE_KEY)
         kwargs = kwargs.copy()

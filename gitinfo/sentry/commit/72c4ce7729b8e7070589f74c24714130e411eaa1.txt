commit 72c4ce7729b8e7070589f74c24714130e411eaa1
Author: Armin Ronacher <armin.ronacher@active-4.com>
Date:   Wed Feb 8 20:15:06 2017 +0100

    Fixed various bugs with the new symbolication system

diff --git a/src/sentry/lang/native/plugin.py b/src/sentry/lang/native/plugin.py
index 55e364fe56..8b9444f565 100644
--- a/src/sentry/lang/native/plugin.py
+++ b/src/sentry/lang/native/plugin.py
@@ -424,13 +424,14 @@ class NativeStacktraceProcessor(StacktraceProcessor):
         sym_input_frame = {
             'object_name': frame.get('package'),
             'instruction_addr': self.find_best_instruction(
-                frame['instruction_addr'], stacktrace_info, idx),
+                frame, stacktrace_info, idx),
             'symbol_name': frame.get('function'),
         }
         in_app = self.sym.is_in_app(sym_input_frame)
 
         new_frames = []
         raw_frame = dict(frame)
+        raw_frame['in_app'] = in_app
 
         try:
             symbolicated_frames = self.sym.symbolize_frame(
@@ -438,7 +439,7 @@ class NativeStacktraceProcessor(StacktraceProcessor):
         except SymbolicationFailed as e:
             if e.is_user_fixable or e.is_sdk_failure:
                 errors.append({
-                    'type': EventError.NATIVE_INTERNAL_FAILURE,
+                    'type': e.type,
                     'image_uuid': e.image_uuid,
                     'image_path': e.image_path,
                     'image_arch': e.image_arch,
@@ -447,45 +448,43 @@ class NativeStacktraceProcessor(StacktraceProcessor):
             else:
                 logger.debug('Failed to symbolicate with native backend',
                              exc_info=True)
-        else:
-            for sfrm in symbolicated_frames:
-                symbol = sfrm.get('symbol_name') or \
-                    frame.get('function') or '<unknown>'
-                function = demangle_symbol(symbol, simplified=True)
-
-                new_frame = dict(frame)
-                new_frame['function'] = function
-
-                # If we demangled something, store the original in the
-                # symbol portion of the frame
-                if function != symbol:
-                    new_frame['symbol'] = symbol
-
-                new_frame['abs_path'] = sfrm.get('filename') or None
-                if new_frame['abs_path']:
-                    new_frame['filename'] = posixpath.basename(
-                        new_frame['abs_path'])
-                if sfrm.get('line') is not None:
-                    new_frame['lineno'] = sfrm['line']
-                else:
-                    new_frame['instruction_offset'] = \
-                        parse_addr(sfrm['instruction_addr']) - \
-                        parse_addr(sfrm['symbol_addr'])
-                if sfrm.get('column') is not None:
-                    new_frame['colno'] = sfrm['column']
-                new_frame['package'] = sfrm['object_name'] \
-                    or new_frame.get('package')
-                new_frame['symbol_addr'] = '0x%x' % \
+            return None, [raw_frame], errors
+
+        for sfrm in symbolicated_frames:
+            symbol = sfrm.get('symbol_name') or \
+                frame.get('function') or '<unknown>'
+            function = demangle_symbol(symbol, simplified=True)
+
+            new_frame = dict(frame)
+            new_frame['function'] = function
+
+            # If we demangled something, store the original in the
+            # symbol portion of the frame
+            if function != symbol:
+                new_frame['symbol'] = symbol
+
+            new_frame['abs_path'] = sfrm.get('filename') or None
+            if new_frame['abs_path']:
+                new_frame['filename'] = posixpath.basename(
+                    new_frame['abs_path'])
+            if sfrm.get('line') is not None:
+                new_frame['lineno'] = sfrm['line']
+            else:
+                new_frame['instruction_offset'] = \
+                    parse_addr(frame['instruction_addr']) - \
                     parse_addr(sfrm['symbol_addr'])
-                new_frame['instruction_addr'] = '0x%x' % parse_addr(
-                    sfrm['instruction_addr'])
-
-                if new_frame.get('in_app') is None:
-                    new_frame['in_app'] = in_app
-                new_frames.append(new_frame)
+            if sfrm.get('column') is not None:
+                new_frame['colno'] = sfrm['column']
+            new_frame['package'] = sfrm['object_name'] \
+                or new_frame.get('package')
+            new_frame['symbol_addr'] = '0x%x' % \
+                parse_addr(sfrm['symbol_addr'])
+            new_frame['instruction_addr'] = '0x%x' % parse_addr(
+                frame['instruction_addr'])
+
+            new_frame['in_app'] = in_app
+            new_frames.append(new_frame)
 
-        if raw_frame.get('in_app') is None:
-            raw_frame['in_app'] = in_app
         return new_frames, [raw_frame], errors
 
 
diff --git a/src/sentry/lang/native/symbolizer.py b/src/sentry/lang/native/symbolizer.py
index 8ffd9e35f3..97f655427a 100644
--- a/src/sentry/lang/native/symbolizer.py
+++ b/src/sentry/lang/native/symbolizer.py
@@ -70,7 +70,7 @@ class SymbolicationFailed(Exception):
     @property
     def is_sdk_failure(self):
         """An error that most likely happened because of a bad SDK."""
-        return self.type == 'unknown-image'
+        return self.type == EventError.NATIVE_UNKNOWN_IMAGE
 
     def __str__(self):
         rv = []
@@ -151,12 +151,23 @@ class Symbolizer(object):
             self.images[img_addr] = img
         self._image_addresses.sort()
 
+        # This should always succeed but you never quite know.
+        self.cpu_name = None
+        for img in six.itervalues(self.images.itervalues):
+            cpu_name = get_cpu_name(img['cpu_type'],
+                                    img['cpu_subtype'])
+            if self.cpu_name is None:
+                self.cpu_name = cpu_name
+            elif self.cpu_name != cpu_name:
+                self.cpu_name = None
+                break
+
     def find_best_instruction(self, frame, meta=None):
         """Finds the best instruction for a given frame."""
         if not self.images:
             return parse_addr(frame['instruction_addr'])
         return self.symsynd_symbolizer.find_best_instruction(
-            frame['instruction_addr'], meta=meta)
+            frame['instruction_addr'], cpu_name=self.cpu_name, meta=meta)
 
     def resolve_missing_vmaddrs(self):
         """When called this changes the vmaddr on all contained images from
@@ -302,6 +313,14 @@ class Symbolizer(object):
         return rv
 
     def symbolize_frame(self, frame, sdk_info=None, symbolize_inlined=False):
+        # If we do not have a CPU name we fail.  We currently only support
+        # a single cpu architecture.
+        if self.cpu_name is None:
+            raise SymbolicationFailed(
+                type=EventError.NATIVE_INTERNAL_FAILURE,
+                message='Found multiple architectures.'
+            )
+
         img = self.find_image(frame['instruction_addr'])
         if img is None:
             raise SymbolicationFailed(

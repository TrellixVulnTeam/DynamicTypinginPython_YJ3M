commit 9c7fbaea3d07495db1033f65bc80d2a5fea0b0dd
Author: Chris Fuller <cfuller@sentry.io>
Date:   Thu Apr 16 14:34:38 2020 -0400

    feat(workflow): Adding incident status async task and write to activity log  (#18242)
    
    * Adding incident status async task

diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index c0f8ebcfed..1fe2666389 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -589,7 +589,7 @@ def snapshot_alert_rule(alert_rule):
         alert_rule_snapshot.status = AlertRuleStatus.SNAPSHOT.value
         alert_rule_snapshot.save()
 
-        incidents.update(alert_rule=alert_rule_snapshot, status=IncidentStatus.CLOSED.value)
+        incidents.update(alert_rule=alert_rule_snapshot)
 
         for trigger in triggers:
             actions = AlertRuleTriggerAction.objects.filter(alert_rule_trigger=trigger)
@@ -601,6 +601,11 @@ def snapshot_alert_rule(alert_rule):
                 action.alert_rule_trigger = trigger
                 action.save()
 
+    # Change the incident status asynchronously, which could take awhile with many incidents due to snapshot creations.
+    tasks.auto_resolve_snapshot_incidents.apply_async(
+        kwargs={"alert_rule_id": alert_rule_snapshot.id}
+    )
+
 
 def update_alert_rule(
     alert_rule,
@@ -660,7 +665,6 @@ def update_alert_rule(
         incidents = Incident.objects.filter(alert_rule=alert_rule).exists()
         if incidents:
             snapshot_alert_rule(alert_rule)
-
         alert_rule.update(**updated_fields)
 
         existing_subs = []
@@ -794,11 +798,13 @@ def delete_alert_rule(alert_rule):
         bulk_delete_snuba_subscriptions(list(alert_rule.query_subscriptions.all()))
         if incidents:
             alert_rule.update(status=AlertRuleStatus.SNAPSHOT.value)
-            for incident in incidents:
-                incident.update(status=IncidentStatus.CLOSED.value)
         else:
             alert_rule.delete()
 
+    if alert_rule.id:
+        # Change the incident status asynchronously, which could take awhile with many incidents due to snapshot creations.
+        tasks.auto_resolve_snapshot_incidents.apply_async(kwargs={"alert_rule_id": alert_rule.id})
+
 
 def validate_alert_rule_query(query):
     # TODO: We should add more validation here to reject queries that include
diff --git a/src/sentry/incidents/tasks.py b/src/sentry/incidents/tasks.py
index 74c62ff071..b2a51d5c14 100644
--- a/src/sentry/incidents/tasks.py
+++ b/src/sentry/incidents/tasks.py
@@ -6,6 +6,7 @@ from six.moves.urllib.parse import urlencode
 from sentry.auth.access import from_user
 from sentry.incidents.models import (
     AlertRuleTriggerAction,
+    AlertRuleStatus,
     Incident,
     IncidentActivity,
     IncidentActivityType,
@@ -140,3 +141,41 @@ def handle_trigger_action(action_id, incident_id, project_id, method):
         )
     )
     getattr(action, method)(incident, project)
+
+
+@instrumented_task(
+    name="sentry.incidents.tasks.auto_resolve_snapshot_incidents",
+    queue="incidents",
+    default_retry_delay=60 * 5,
+    max_retries=2,
+)
+def auto_resolve_snapshot_incidents(alert_rule_id, **kwargs):
+    from sentry.incidents.models import AlertRule
+    from sentry.incidents.logic import update_incident_status
+
+    try:
+        alert_rule = AlertRule.objects_with_snapshots.get(id=alert_rule_id)
+    except AlertRule.DoesNotExist:
+        return
+
+    if alert_rule.status != AlertRuleStatus.SNAPSHOT.value:
+        return
+
+    batch_size = 50
+    incidents = Incident.objects.filter(alert_rule=alert_rule).exclude(
+        status=IncidentStatus.CLOSED.value
+    )[: batch_size + 1]
+    has_more = incidents.count() > batch_size
+    if incidents:
+        incidents = incidents[:batch_size]
+        for incident in incidents:
+            update_incident_status(
+                incident,
+                IncidentStatus.CLOSED,
+                comment="This alert has been auto-resolved because the rule that triggered it has been modified or deleted.",
+            )
+
+    if has_more:
+        auto_resolve_snapshot_incidents.apply_async(
+            kwargs={"alert_rule_id": alert_rule_id}, countdown=1
+        )
diff --git a/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py b/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py
index 0f4ca83b2d..b1f575776e 100644
--- a/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py
+++ b/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py
@@ -393,23 +393,23 @@ class AlertRuleDetailsDeleteEndpointTest(AlertRuleDetailsBase, APITestCase):
         assert not AlertRule.objects_with_snapshots.filter(id=self.alert_rule.id).exists()
 
     def test_snapshot_and_create_new_with_same_name(self):
+        with self.tasks():
+            self.create_member(
+                user=self.user, organization=self.organization, role="owner", teams=[self.team]
+            )
+            self.login_as(self.user)
 
-        self.create_member(
-            user=self.user, organization=self.organization, role="owner", teams=[self.team]
-        )
-        self.login_as(self.user)
-
-        # We attach the rule to an incident so the rule is snapshotted instead of deleted.
-        incident = self.create_incident(alert_rule=self.alert_rule)
+            # We attach the rule to an incident so the rule is snapshotted instead of deleted.
+            incident = self.create_incident(alert_rule=self.alert_rule)
 
-        with self.feature("organizations:incidents"):
-            self.get_valid_response(self.organization.slug, self.alert_rule.id, status_code=204)
+            with self.feature("organizations:incidents"):
+                self.get_valid_response(self.organization.slug, self.alert_rule.id, status_code=204)
 
-        alert_rule = AlertRule.objects_with_snapshots.get(id=self.alert_rule.id)
+            alert_rule = AlertRule.objects_with_snapshots.get(id=self.alert_rule.id)
 
-        assert not AlertRule.objects.filter(id=alert_rule.id).exists()
-        assert AlertRule.objects_with_snapshots.filter(id=alert_rule.id).exists()
-        assert alert_rule.status == AlertRuleStatus.SNAPSHOT.value
+            assert not AlertRule.objects.filter(id=alert_rule.id).exists()
+            assert AlertRule.objects_with_snapshots.filter(id=alert_rule.id).exists()
+            assert alert_rule.status == AlertRuleStatus.SNAPSHOT.value
 
-        # We also confirm that the incident is automatically resolved.
-        assert Incident.objects.get(id=incident.id).status == IncidentStatus.CLOSED.value
+            # We also confirm that the incident is automatically resolved.
+            assert Incident.objects.get(id=incident.id).status == IncidentStatus.CLOSED.value
diff --git a/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py b/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
index 6ed5a3eae8..994f271299 100644
--- a/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
+++ b/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
@@ -173,25 +173,25 @@ class AlertRuleDetailsDeleteEndpointTest(AlertRuleDetailsBase, APITestCase):
         assert not AlertRule.objects_with_snapshots.filter(id=self.alert_rule.id).exists()
 
     def test_snapshot_and_create_new_with_same_name(self):
+        with self.tasks():
+            self.create_member(
+                user=self.user, organization=self.organization, role="owner", teams=[self.team]
+            )
+            self.login_as(self.user)
 
-        self.create_member(
-            user=self.user, organization=self.organization, role="owner", teams=[self.team]
-        )
-        self.login_as(self.user)
-
-        # We attach the rule to an incident so the rule is snapshotted instead of deleted.
-        incident = self.create_incident(alert_rule=self.alert_rule)
+            # We attach the rule to an incident so the rule is snapshotted instead of deleted.
+            incident = self.create_incident(alert_rule=self.alert_rule)
 
-        with self.feature("organizations:incidents"):
-            self.get_valid_response(
-                self.organization.slug, self.project.slug, self.alert_rule.id, status_code=204
-            )
+            with self.feature("organizations:incidents"):
+                self.get_valid_response(
+                    self.organization.slug, self.project.slug, self.alert_rule.id, status_code=204
+                )
 
-        alert_rule = AlertRule.objects_with_snapshots.get(id=self.alert_rule.id)
+            alert_rule = AlertRule.objects_with_snapshots.get(id=self.alert_rule.id)
 
-        assert not AlertRule.objects.filter(id=alert_rule.id).exists()
-        assert AlertRule.objects_with_snapshots.filter(id=alert_rule.id).exists()
-        assert alert_rule.status == AlertRuleStatus.SNAPSHOT.value
+            assert not AlertRule.objects.filter(id=alert_rule.id).exists()
+            assert AlertRule.objects_with_snapshots.filter(id=alert_rule.id).exists()
+            assert alert_rule.status == AlertRuleStatus.SNAPSHOT.value
 
-        # We also confirm that the incident is automatically resolved.
-        assert Incident.objects.get(id=incident.id).status == IncidentStatus.CLOSED.value
+            # We also confirm that the incident is automatically resolved.
+            assert Incident.objects.get(id=incident.id).status == IncidentStatus.CLOSED.value
diff --git a/tests/sentry/incidents/test_logic.py b/tests/sentry/incidents/test_logic.py
index 7b9141fbdc..6794c14a4e 100644
--- a/tests/sentry/incidents/test_logic.py
+++ b/tests/sentry/incidents/test_logic.py
@@ -912,79 +912,84 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
 
     def test_with_attached_incident(self):
         # A snapshot of the pre-updated rule should be created, and the incidents should also be resolved.
-        incident = self.create_incident()
-        incident.update(alert_rule=self.alert_rule)
-        incident_2 = self.create_incident()
-        incident_2.update(alert_rule=self.alert_rule)
-
-        # Give the rule some actions and triggers so we can verify they've been snapshotted correctly.
-        trigger = create_alert_rule_trigger(
-            self.alert_rule, "hello", AlertRuleThresholdType.ABOVE, 1000, 400
-        )
-        action = create_alert_rule_trigger_action(
-            trigger,
-            AlertRuleTriggerAction.Type.EMAIL,
-            AlertRuleTriggerAction.TargetType.USER,
-            target_identifier=six.text_type(self.user.id),
-        )
-        trigger_count = AlertRuleTrigger.objects.all().count()
-        action_count = AlertRuleTriggerAction.objects.all().count()
-
-        updated_projects = [self.project, self.create_project(fire_project_created=True)]
+        with self.tasks():
+            incident = self.create_incident()
+            incident.update(alert_rule=self.alert_rule)
+            incident_2 = self.create_incident()
+            incident_2.update(alert_rule=self.alert_rule)
+
+            # Give the rule some actions and triggers so we can verify they've been snapshotted correctly.
+            trigger = create_alert_rule_trigger(
+                self.alert_rule, "hello", AlertRuleThresholdType.ABOVE, 1000, 400
+            )
+            action = create_alert_rule_trigger_action(
+                trigger,
+                AlertRuleTriggerAction.Type.EMAIL,
+                AlertRuleTriggerAction.TargetType.USER,
+                target_identifier=six.text_type(self.user.id),
+            )
+            trigger_count = AlertRuleTrigger.objects.all().count()
+            action_count = AlertRuleTriggerAction.objects.all().count()
+
+            updated_projects = [self.project, self.create_project(fire_project_created=True)]
+
+            updated_rule = update_alert_rule(
+                self.alert_rule,
+                projects=updated_projects,
+                query="level:warning",
+                aggregation=QueryAggregations.UNIQUE_USERS,
+                time_window=50,
+                threshold_period=2,
+            )
 
-        updated_rule = update_alert_rule(
-            self.alert_rule,
-            projects=updated_projects,
-            query="level:warning",
-            aggregation=QueryAggregations.UNIQUE_USERS,
-            time_window=50,
-            threshold_period=2,
-        )
-
-        incident.refresh_from_db()
-        incident_2.refresh_from_db()
-        rule_snapshot = AlertRule.objects_with_snapshots.filter(name=self.alert_rule.name).exclude(
-            id=updated_rule.id
-        )
-        assert rule_snapshot.count() == 1
-        rule_snapshot = rule_snapshot.first()
-        assert rule_snapshot.status == AlertRuleStatus.SNAPSHOT.value
-
-        # Rule snapshot should have properties of the rule before it was updated.
-        assert rule_snapshot.id != updated_rule.id
-        assert rule_snapshot.name == updated_rule.name
-        assert rule_snapshot.query == "level:error"
-        assert rule_snapshot.time_window == 10
-        assert rule_snapshot.aggregation == QueryAggregations.TOTAL.value
-        assert rule_snapshot.threshold_period == 1
-
-        for incident in (incident, incident_2):
-            # Incidents should now be pointing to the rule snapshot.
-            assert incident.alert_rule.id == rule_snapshot.id
-            assert incident.alert_rule.name == updated_rule.name
-            # Incidents should be resolved
-            assert incident.status == IncidentStatus.CLOSED.value
-
-        # Action and trigger counts should double (from 1 to 2)
-        assert AlertRuleTrigger.objects.all().count() == trigger_count * 2
-        assert AlertRuleTriggerAction.objects.all().count() == action_count * 2
-
-        # Verify actions and triggers have the same properties...and are not the same actions & triggers as the original rule.
-        assert AlertRuleTrigger.objects.filter(alert_rule=rule_snapshot).exists()
-        trigger_snapshot = AlertRuleTrigger.objects.get(alert_rule=rule_snapshot)
-        assert trigger_snapshot.id != trigger.id
-        assert trigger_snapshot.label == trigger.label
-        assert trigger_snapshot.threshold_type == trigger.threshold_type
-        assert trigger_snapshot.alert_threshold == trigger.alert_threshold
-        assert trigger_snapshot.resolve_threshold == trigger.resolve_threshold
-
-        assert AlertRuleTriggerAction.objects.filter(alert_rule_trigger=trigger_snapshot).exists()
-        action_snapshot = AlertRuleTriggerAction.objects.get(alert_rule_trigger=trigger_snapshot)
-        assert action_snapshot.id != action.id
-        assert action_snapshot.type == action.type
-        assert action_snapshot.target_type == action.target_type
-        assert action_snapshot.target_identifier == action.target_identifier
-        assert action_snapshot.target_display == action.target_display
+            incident.refresh_from_db()
+            incident_2.refresh_from_db()
+            rule_snapshot = AlertRule.objects_with_snapshots.filter(
+                name=self.alert_rule.name
+            ).exclude(id=updated_rule.id)
+            assert rule_snapshot.count() == 1
+            rule_snapshot = rule_snapshot.first()
+            assert rule_snapshot.status == AlertRuleStatus.SNAPSHOT.value
+
+            # Rule snapshot should have properties of the rule before it was updated.
+            assert rule_snapshot.id != updated_rule.id
+            assert rule_snapshot.name == updated_rule.name
+            assert rule_snapshot.query == "level:error"
+            assert rule_snapshot.time_window == 10
+            assert rule_snapshot.aggregation == QueryAggregations.TOTAL.value
+            assert rule_snapshot.threshold_period == 1
+
+            for incident in (incident, incident_2):
+                # Incidents should now be pointing to the rule snapshot.
+                assert incident.alert_rule.id == rule_snapshot.id
+                assert incident.alert_rule.name == updated_rule.name
+                # Incidents should be resolved
+                assert incident.status == IncidentStatus.CLOSED.value
+
+            # Action and trigger counts should double (from 1 to 2)
+            assert AlertRuleTrigger.objects.all().count() == trigger_count * 2
+            assert AlertRuleTriggerAction.objects.all().count() == action_count * 2
+
+            # Verify actions and triggers have the same properties...and are not the same actions & triggers as the original rule.
+            assert AlertRuleTrigger.objects.filter(alert_rule=rule_snapshot).exists()
+            trigger_snapshot = AlertRuleTrigger.objects.get(alert_rule=rule_snapshot)
+            assert trigger_snapshot.id != trigger.id
+            assert trigger_snapshot.label == trigger.label
+            assert trigger_snapshot.threshold_type == trigger.threshold_type
+            assert trigger_snapshot.alert_threshold == trigger.alert_threshold
+            assert trigger_snapshot.resolve_threshold == trigger.resolve_threshold
+
+            assert AlertRuleTriggerAction.objects.filter(
+                alert_rule_trigger=trigger_snapshot
+            ).exists()
+            action_snapshot = AlertRuleTriggerAction.objects.get(
+                alert_rule_trigger=trigger_snapshot
+            )
+            assert action_snapshot.id != action.id
+            assert action_snapshot.type == action.type
+            assert action_snapshot.target_type == action.target_type
+            assert action_snapshot.target_identifier == action.target_identifier
+            assert action_snapshot.target_display == action.target_display
 
 
 class DeleteAlertRuleTest(TestCase, BaseIncidentsTest):

commit 7af4e43be6d956c8e82f39fe58ec0fa18f7336e9
Author: Stephen Cefali <scefali@sentry.io>
Date:   Mon Apr 20 11:20:27 2020 -0700

    feat(slack): slack v2 installation/api 911 (#18317)

diff --git a/src/sentry/features/__init__.py b/src/sentry/features/__init__.py
index accb0bb9a4..0a721a83dd 100644
--- a/src/sentry/features/__init__.py
+++ b/src/sentry/features/__init__.py
@@ -74,6 +74,7 @@ default_manager.add("organizations:integrations-issue-basic", OrganizationFeatur
 default_manager.add("organizations:integrations-issue-sync", OrganizationFeature)  # NOQA
 default_manager.add("organizations:integrations-event-hooks", OrganizationFeature)  # NOQA
 default_manager.add("organizations:data-forwarding", OrganizationFeature)  # NOQA
+default_manager.add("organizations:slack-v2", OrganizationFeature)  # NOQA
 default_manager.add("organizations:internal-catchall", OrganizationFeature)  # NOQA
 default_manager.add("organizations:incidents", OrganizationFeature)  # NOQA
 default_manager.add("organizations:invite-members", OrganizationFeature)  # NOQA
diff --git a/src/sentry/identity/slack/provider.py b/src/sentry/identity/slack/provider.py
index a494796a15..60ecffea94 100644
--- a/src/sentry/identity/slack/provider.py
+++ b/src/sentry/identity/slack/provider.py
@@ -12,25 +12,42 @@ class SlackIdentityProvider(OAuth2Provider):
 
     # This identity provider is used for authorizing the Slack application
     # through their Bot token (or legacy Workspace Token if enabled) flow.
-    oauth_authorize_url = "https://slack.com/oauth/authorize"
 
     oauth_scopes = ("identity.basic", "identity.email")
 
+    def get_oauth_authorize_url(self):
+        if self.use_wst_app:
+            return "https://slack.com/oauth/authorize"
+        return "https://slack.com/oauth/v2/authorize"
+
+    @property
+    def use_slack_v2(self):
+        # need to import here because of dependency issues
+        from sentry.integrations.slack.utils import use_slack_v2
+
+        return use_slack_v2(self.pipeline)
+
+    @property
+    def use_wst_app(self):
+        return settings.SLACK_INTEGRATION_USE_WST and not self.use_slack_v2
+
     # XXX(epurkhiser): While workspace tokens _do_ support the oauth.access
     # endpoint, it will no include the authorizing_user, so we continue to use
     # the deprecated oauth.token endpoint until we are able to migrate to a bot
     # app which uses oauth.access.
     def get_oauth_access_token_url(self):
-        return (
-            "https://slack.com/api/oauth.token"
-            if settings.SLACK_INTEGRATION_USE_WST
-            else "https://slack.com/api/oauth.access"
-        )
+        if self.use_wst_app:
+            return "https://slack.com/api/oauth.token"
+        return "https://slack.com/api/oauth.v2.access"
 
     def get_oauth_client_id(self):
+        if self.use_slack_v2:
+            return options.get("slack-v2.client-id")
         return options.get("slack.client-id")
 
     def get_oauth_client_secret(self):
+        if self.use_slack_v2:
+            return options.get("slack-v2.client-secret")
         return options.get("slack.client-secret")
 
     def get_oauth_data(self, payload):
diff --git a/src/sentry/integrations/slack/event_endpoint.py b/src/sentry/integrations/slack/event_endpoint.py
index 078adc4265..698f0badc1 100644
--- a/src/sentry/integrations/slack/event_endpoint.py
+++ b/src/sentry/integrations/slack/event_endpoint.py
@@ -5,7 +5,6 @@ import re
 import six
 from collections import defaultdict
 
-from django.conf import settings
 from django.db.models import Q
 
 from sentry import http
@@ -110,10 +109,12 @@ class SlackEventEndpoint(Endpoint):
         if not results:
             return
 
-        if settings.SLACK_INTEGRATION_USE_WST:
+        # the classic bot tokens must use the user auth token for URL unfurling
+        # we stored the user_access_token there
+        # but for workspace apps and new slack bot tokens, we can just use access_token
+        access_token = integration.metadata.get("user_access_token")
+        if not access_token:
             access_token = integration.metadata["access_token"]
-        else:
-            access_token = integration.metadata["user_access_token"]
 
         payload = {
             "token": access_token,
diff --git a/src/sentry/integrations/slack/integration.py b/src/sentry/integrations/slack/integration.py
index dadfb8b614..9a8900803f 100644
--- a/src/sentry/integrations/slack/integration.py
+++ b/src/sentry/integrations/slack/integration.py
@@ -13,7 +13,7 @@ from sentry.integrations import (
 )
 from sentry.pipeline import NestedPipelineView
 from sentry.utils.http import absolute_uri
-from .utils import track_response_code
+from .utils import track_response_code, use_slack_v2
 
 DESCRIPTION = """
 Connect your Sentry organization to one or more Slack workspaces, and start
@@ -62,24 +62,46 @@ class SlackIntegrationProvider(IntegrationProvider):
     features = frozenset([IntegrationFeatures.CHAT_UNFURL, IntegrationFeatures.ALERT_RULE])
 
     # Scopes differ depending on if it's a workspace app
-    identity_oauth_scopes = (
-        frozenset(["bot", "links:read", "links:write"])
-        if not settings.SLACK_INTEGRATION_USE_WST
-        else frozenset(
-            [
-                "channels:read",
-                "groups:read",
-                "users:read",
-                "chat:write",
-                "links:read",
-                "links:write",
-                "team:read",
-            ]
-        )
+    wst_oauth_scopes = frozenset(
+        [
+            "channels:read",
+            "groups:read",
+            "users:read",
+            "chat:write",
+            "links:read",
+            "links:write",
+            "team:read",
+        ]
+    )
+
+    # some info here: https://api.slack.com/authentication/quickstart
+    bot_oauth_scopes = frozenset(
+        [
+            "channels:read",
+            "groups:read",
+            "users:read",
+            "chat:write",
+            "links:read",
+            "links:write",
+            "team:read",
+            "im:read",
+            "chat:write.public",
+            "chat:write.customize",
+        ]
     )
 
     setup_dialog_config = {"width": 600, "height": 900}
 
+    @property
+    def use_wst_app(self):
+        return settings.SLACK_INTEGRATION_USE_WST and not use_slack_v2(self.pipeline)
+
+    @property
+    def identity_oauth_scopes(self):
+        if self.use_wst_app:
+            return self.wst_oauth_scopes
+        return self.bot_oauth_scopes
+
     def get_pipeline_views(self):
         identity_pipeline_config = {
             "oauth_scopes": self.identity_oauth_scopes,
@@ -103,32 +125,28 @@ class SlackIntegrationProvider(IntegrationProvider):
         resp.raise_for_status()
         status_code = resp.status_code
         resp = resp.json()
+        # TODO: track_response_code won't hit if we have an error status code
         track_response_code(status_code, resp.get("ok"))
 
-        return resp["team"]
-
-    def get_identity(self, user_token):
-        payload = {"token": user_token}
+        # TODO: check for resp["ok"]
 
-        session = http.build_session()
-        resp = session.get("https://slack.com/api/auth.test", params=payload)
-        resp.raise_for_status()
-        status_code = resp.status_code
-        resp = resp.json()
-        track_response_code(status_code, resp.get("ok"))
-
-        return resp["user_id"]
+        return resp["team"]
 
     def build_integration(self, state):
         data = state["identity"]["data"]
         assert data["ok"]
 
-        if settings.SLACK_INTEGRATION_USE_WST:
-            access_token = data["access_token"]
+        access_token = data["access_token"]
+        # bot apps have a different response format
+        # see: https://api.slack.com/authentication/quickstart#installing
+        if self.use_wst_app:
             user_id_slack = data["authorizing_user_id"]
+            team_name = data["team_name"]
+            team_id = data["team_id"]
         else:
-            access_token = data["bot"]["bot_access_token"]
-            user_id_slack = self.get_identity(data["access_token"])
+            user_id_slack = data["authed_user"]["id"]
+            team_name = data["team"]["name"]
+            team_id = data["team"]["id"]
 
         scopes = sorted(self.identity_oauth_scopes)
         team_data = self.get_team_info(access_token)
@@ -140,14 +158,9 @@ class SlackIntegrationProvider(IntegrationProvider):
             "domain_name": team_data["domain"] + ".slack.com",
         }
 
-        # When using bot tokens, we must use the user auth token for URL
-        # unfurling
-        if not settings.SLACK_INTEGRATION_USE_WST:
-            metadata["user_access_token"] = data["access_token"]
-
         return {
-            "name": data["team_name"],
-            "external_id": data["team_id"],
+            "name": team_name,
+            "external_id": team_id,
             "metadata": metadata,
             "user_identity": {
                 "type": "slack",
diff --git a/src/sentry/integrations/slack/utils.py b/src/sentry/integrations/slack/utils.py
index 9afc8018c7..0dd2e074a4 100644
--- a/src/sentry/integrations/slack/utils.py
+++ b/src/sentry/integrations/slack/utils.py
@@ -7,8 +7,7 @@ from datetime import timedelta
 from django.core.cache import cache
 from django.core.urlresolvers import reverse
 
-from sentry import http
-from sentry import tagstore
+from sentry import http, features, tagstore
 from sentry.api.fields.actor import Actor
 from sentry.incidents.logic import get_incident_aggregates
 from sentry.incidents.models import IncidentStatus, IncidentTrigger
@@ -459,3 +458,9 @@ def send_incident_alert_notification(action, incident):
     resp.raise_for_status()
     if not response.get("ok"):
         logger.info("rule.fail.slack_post", extra={"error": response.get("error")})
+
+
+def use_slack_v2(pipeline):
+    return features.has(
+        "organizations:slack-v2", pipeline.organization, actor=pipeline.request.user
+    )
diff --git a/src/sentry/options/defaults.py b/src/sentry/options/defaults.py
index 6eded25269..077235e4ac 100644
--- a/src/sentry/options/defaults.py
+++ b/src/sentry/options/defaults.py
@@ -123,6 +123,11 @@ register("slack.client-secret", flags=FLAG_PRIORITIZE_DISK)
 register("slack.verification-token", flags=FLAG_PRIORITIZE_DISK)
 register("slack.signing-secret", flags=FLAG_PRIORITIZE_DISK)
 
+# Slack V2 Integration
+register("slack-v2.client-id", flags=FLAG_PRIORITIZE_DISK)
+register("slack-v2.client-secret", flags=FLAG_PRIORITIZE_DISK)
+# TODO: add signing secret
+
 # GitHub Integration
 register("github-app.id", default=0)
 register("github-app.name", default="")
diff --git a/tests/sentry/integrations/slack/test_event_endpoint.py b/tests/sentry/integrations/slack/test_event_endpoint.py
index 94b8e3d330..705c6325c5 100644
--- a/tests/sentry/integrations/slack/test_event_endpoint.py
+++ b/tests/sentry/integrations/slack/test_event_endpoint.py
@@ -143,3 +143,42 @@ class LinkSharedEventTest(BaseEventTest):
             issue_url: build_group_attachment(group1),
             incident_url: build_incident_attachment(incident),
         }
+        assert data["token"] == "xoxp-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx"
+
+    @responses.activate
+    def test_user_access_token(self):
+        # this test is needed to make sure that classic bots installed by on-prem users
+        # still work since they needed to use a user_access_token for unfurl
+        self.integration.metadata.update(
+            {
+                "user_access_token": "xoxt-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx",
+                "access_token": "xoxm-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx",
+            }
+        )
+        self.integration.save()
+        responses.add(responses.POST, "https://slack.com/api/chat.unfurl", json={"ok": True})
+        org2 = self.create_organization(name="biz")
+        project1 = self.create_project(organization=self.org)
+        project2 = self.create_project(organization=org2)
+        group1 = self.create_group(project=project1)
+        group2 = self.create_group(project=project2)
+        alert_rule = self.create_alert_rule()
+        incident = self.create_incident(
+            status=2, organization=self.org, projects=[project1], alert_rule=alert_rule
+        )
+        incident.update(identifier=123)
+        resp = self.post_webhook(
+            event_data=json.loads(
+                LINK_SHARED_EVENT
+                % {
+                    "group1": group1.id,
+                    "group2": group2.id,
+                    "incident": incident.identifier,
+                    "org1": self.org.slug,
+                    "org2": org2.slug,
+                }
+            )
+        )
+        assert resp.status_code == 200, resp.content
+        data = dict(parse_qsl(responses.calls[0].request.body))
+        assert data["token"] == "xoxt-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx"
diff --git a/tests/sentry/integrations/slack/test_integration.py b/tests/sentry/integrations/slack/test_integration.py
index 9f6528cbcb..27f3d0a492 100644
--- a/tests/sentry/integrations/slack/test_integration.py
+++ b/tests/sentry/integrations/slack/test_integration.py
@@ -15,6 +15,7 @@ from sentry.models import (
     OrganizationIntegration,
 )
 from sentry.testutils import IntegrationTestCase
+from sentry.testutils.helpers import override_options, with_feature
 
 
 class SlackIntegrationTest(IntegrationTestCase):
@@ -25,8 +26,9 @@ class SlackIntegrationTest(IntegrationTestCase):
         team_id="TXXXXXXX1",
         authorizing_user_id="UXXXXXXX1",
         access_token="xoxp-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx",
-        access_extras=None,
-        use_oauth_token_endpoint=True,
+        is_wst_app=True,
+        expected_client_id="slack-client-id",
+        expected_client_secret="slack-client-secret",
     ):
         responses.reset()
 
@@ -35,40 +37,38 @@ class SlackIntegrationTest(IntegrationTestCase):
         redirect = urlparse(resp["Location"])
         assert redirect.scheme == "https"
         assert redirect.netloc == "slack.com"
-        assert redirect.path == "/oauth/authorize"
+        assert redirect.path == "/oauth/authorize" if is_wst_app else "oauth/v2/authorize"
         params = parse_qs(redirect.query)
-        assert params["scope"] == [" ".join(self.provider.identity_oauth_scopes)]
+        scopes = self.provider.wst_oauth_scopes if is_wst_app else self.provider.bot_oauth_scopes
+        assert params["scope"] == [" ".join(scopes)]
         assert params["state"]
         assert params["redirect_uri"] == ["http://testserver/extensions/slack/setup/"]
         assert params["response_type"] == ["code"]
-        assert params["client_id"] == ["slack-client-id"]
+        assert params["client_id"] == [expected_client_id]
         # once we've asserted on it, switch to a singular values to make life
         # easier
         authorize_params = {k: v[0] for k, v in six.iteritems(params)}
 
-        access_json = {
-            "ok": True,
-            "access_token": access_token,
-            "team_id": team_id,
-            "team_name": "Example",
-            "authorizing_user_id": authorizing_user_id,
-        }
-
-        if access_extras is not None:
-            access_json.update(access_extras)
-
         # XXX(epurkhiser): The slack workspace token app uses oauth.token, the
-        # slack bot app uses oauth.access.
-        if use_oauth_token_endpoint:
+        # slack bot app uses oauth.v2.access.
+        if is_wst_app:
+            access_json = {
+                "ok": True,
+                "access_token": access_token,
+                "team_id": team_id,
+                "team_name": "Example",
+                "authorizing_user_id": authorizing_user_id,
+            }
             responses.add(responses.POST, "https://slack.com/api/oauth.token", json=access_json)
         else:
-            responses.add(responses.POST, "https://slack.com/api/oauth.access", json=access_json)
-
-        responses.add(
-            responses.GET,
-            "https://slack.com/api/auth.test",
-            json={"ok": True, "user_id": authorizing_user_id},
-        )
+            # TODO: make access token an input
+            access_json = {
+                "ok": True,
+                "access_token": "xoxb-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx",
+                "team": {"id": team_id, "name": "Example"},
+                "authed_user": {"id": authorizing_user_id},
+            }
+            responses.add(responses.POST, "https://slack.com/api/oauth.v2.access", json=access_json)
 
         responses.add(
             responses.GET,
@@ -94,8 +94,8 @@ class SlackIntegrationTest(IntegrationTestCase):
         assert req_params["grant_type"] == ["authorization_code"]
         assert req_params["code"] == ["oauth-code"]
         assert req_params["redirect_uri"] == ["http://testserver/extensions/slack/setup/"]
-        assert req_params["client_id"] == ["slack-client-id"]
-        assert req_params["client_secret"] == ["slack-client-secret"]
+        assert req_params["client_id"] == [expected_client_id]
+        assert req_params["client_secret"] == [expected_client_secret]
 
         assert resp.status_code == 200
         self.assertDialogSuccess(resp)
@@ -103,9 +103,7 @@ class SlackIntegrationTest(IntegrationTestCase):
     @responses.activate
     def test_bot_flow(self):
         self.assert_setup_flow(
-            use_oauth_token_endpoint=False,
-            access_token="xoxa-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx",
-            access_extras={"bot": {"bot_access_token": "xoxb-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx"}},
+            is_wst_app=False, access_token="xoxa-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx",
         )
 
         integration = Integration.objects.get(provider=self.provider.key)
@@ -113,8 +111,7 @@ class SlackIntegrationTest(IntegrationTestCase):
         assert integration.name == "Example"
         assert integration.metadata == {
             "access_token": "xoxb-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx",
-            "user_access_token": "xoxa-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx",
-            "scopes": sorted(self.provider.identity_oauth_scopes),
+            "scopes": sorted(self.provider.bot_oauth_scopes),
             "icon": "http://example.com/ws_icon.jpg",
             "domain_name": "test-slack-workspace.slack.com",
         }
@@ -141,7 +138,7 @@ class SlackIntegrationTest(IntegrationTestCase):
         assert integration.name == "Example"
         assert integration.metadata == {
             "access_token": "xoxp-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx",
-            "scopes": sorted(self.provider.identity_oauth_scopes),
+            "scopes": sorted(self.provider.wst_oauth_scopes),
             "icon": "http://example.com/ws_icon.jpg",
             "domain_name": "test-slack-workspace.slack.com",
         }
@@ -193,3 +190,16 @@ class SlackIntegrationTest(IntegrationTestCase):
         self.assert_wst_setup_flow(authorizing_user_id="UXXXXXXX2")
         identity = Identity.objects.get()
         assert identity.external_id == "UXXXXXXX2"
+
+    @responses.activate
+    @with_feature("organizations:slack-v2")
+    def test_install_v2(self):
+        with override_options(
+            {"slack-v2.client-id": "other-id", "slack-v2.client-secret": "other-secret"}
+        ):
+            self.assert_setup_flow(
+                is_wst_app=False,
+                access_token="xoxa-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx",
+                expected_client_id="other-id",
+                expected_client_secret="other-secret",
+            )

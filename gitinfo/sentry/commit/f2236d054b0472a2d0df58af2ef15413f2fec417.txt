commit f2236d054b0472a2d0df58af2ef15413f2fec417
Author: Dan Fuller <dfuller@sentry.io>
Date:   Thu May 7 11:50:18 2020 -0700

    feat(alerts): Start dual writing to new model and fields (#18646)
    
    This starts dual-writing to the new `SnubaQuery` model. This model will replace all query related
    fields on `AlertRule` and `QuerySubscription` once we're finished. Next steps are to backfill, verify
    that the data is consistent between the tables, and then finally start using these new fields.

diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index d7d0b1c4ac..dad6060da2 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -34,13 +34,14 @@ from sentry.incidents.models import (
     IncidentSubscription,
     TimeSeriesSnapshot,
 )
-from sentry.models import Environment, Integration, Project
+from sentry.models import Integration, Project
 from sentry.snuba.discover import resolve_discover_aliases
 from sentry.snuba.models import query_aggregation_to_snuba, QueryAggregations, QueryDatasets
 from sentry.snuba.subscriptions import (
     bulk_create_snuba_subscriptions,
     bulk_delete_snuba_subscriptions,
-    bulk_update_snuba_subscriptions,
+    create_snuba_query,
+    update_snuba_query,
 )
 from sentry.snuba.tasks import apply_dataset_conditions
 from sentry.utils.db import attach_foreignkey
@@ -575,8 +576,17 @@ def create_alert_rule(
     if AlertRule.objects.filter(organization=organization, name=name).exists():
         raise AlertRuleNameAlreadyUsedError()
     with transaction.atomic():
+        snuba_query = create_snuba_query(
+            dataset,
+            query,
+            aggregation,
+            timedelta(minutes=time_window),
+            timedelta(minutes=resolution),
+            environment,
+        )
         alert_rule = AlertRule.objects.create(
             organization=organization,
+            snuba_query=snuba_query,
             name=name,
             dataset=dataset.value,
             query=query,
@@ -612,9 +622,13 @@ def snapshot_alert_rule(alert_rule):
     with transaction.atomic():
         triggers = AlertRuleTrigger.objects.filter(alert_rule=alert_rule)
         incidents = Incident.objects.filter(alert_rule=alert_rule)
+        snuba_query_snapshot = deepcopy(alert_rule.snuba_query)
+        snuba_query_snapshot.id = None
+        snuba_query_snapshot.save()
         alert_rule_snapshot = deepcopy(alert_rule)
         alert_rule_snapshot.id = None
         alert_rule_snapshot.status = AlertRuleStatus.SNAPSHOT.value
+        alert_rule_snapshot.snuba_query = snuba_query_snapshot
         alert_rule_snapshot.save()
 
         incidents.update(alert_rule=alert_rule_snapshot)
@@ -635,6 +649,26 @@ def snapshot_alert_rule(alert_rule):
     )
 
 
+def convert_alert_rule_to_snuba_query(alert_rule):
+    """
+    Temporary method to convert existing alert rules to have a snuba query
+    """
+    if alert_rule.snuba_query:
+        return
+
+    with transaction.atomic():
+        snuba_query = create_snuba_query(
+            QueryDatasets(alert_rule.dataset),
+            alert_rule.query,
+            QueryAggregations(alert_rule.aggregation),
+            timedelta(minutes=alert_rule.time_window),
+            timedelta(minutes=alert_rule.resolution),
+            alert_rule.environment,
+        )
+        alert_rule.update(snuba_query=snuba_query)
+        alert_rule.query_subscriptions.all().update(snuba_query=snuba_query)
+
+
 def update_alert_rule(
     alert_rule,
     projects=None,
@@ -673,17 +707,21 @@ def update_alert_rule(
         and AlertRule.objects.filter(organization=alert_rule.organization, name=name).exists()
     ):
         raise AlertRuleNameAlreadyUsedError()
+    convert_alert_rule_to_snuba_query(alert_rule)
 
     updated_fields = {}
+    updated_query_fields = {}
     if name:
         updated_fields["name"] = name
     if query is not None:
         validate_alert_rule_query(query)
-        updated_fields["query"] = query
+        updated_query_fields["query"] = updated_fields["query"] = query
     if aggregation is not None:
         updated_fields["aggregation"] = aggregation.value
+        updated_query_fields["aggregation"] = aggregation
     if time_window:
         updated_fields["time_window"] = time_window
+        updated_query_fields["time_window"] = timedelta(minutes=time_window)
     if threshold_period:
         updated_fields["threshold_period"] = threshold_period
     if include_all_projects is not None:
@@ -695,6 +733,24 @@ def update_alert_rule(
             snapshot_alert_rule(alert_rule)
         alert_rule.update(**updated_fields)
 
+        if updated_query_fields or environment != alert_rule.snuba_query.environment:
+            snuba_query = alert_rule.snuba_query
+            updated_query_fields.setdefault("query", snuba_query.query)
+            # XXX: We use the alert rule aggregation here since currently we're
+            # expecting the enum value to be passed.
+            updated_query_fields.setdefault(
+                "aggregation", QueryAggregations(alert_rule.aggregation)
+            )
+            updated_query_fields.setdefault(
+                "time_window", timedelta(seconds=snuba_query.time_window)
+            )
+            update_snuba_query(
+                alert_rule.snuba_query,
+                resolution=timedelta(minutes=DEFAULT_ALERT_RULE_RESOLUTION),
+                environment=environment,
+                **updated_query_fields
+            )
+
         existing_subs = []
         if (
             query is not None
@@ -757,11 +813,6 @@ def update_alert_rule(
 
         if deleted_subs:
             bulk_delete_snuba_subscriptions(deleted_subs)
-            # Remove any deleted subscriptions from `existing_subscriptions`, so that
-            # if we need to update any subscriptions we don't end up doing it twice. We
-            # don't add new subscriptions here since they'll already have the updated
-            # values
-            existing_subs = [sub for sub in existing_subs if sub.id]
 
         if environment:
             # Delete rows we don't have present in the updated data.
@@ -774,25 +825,6 @@ def update_alert_rule(
         else:
             AlertRuleEnvironment.objects.filter(alert_rule=alert_rule).delete()
 
-        if existing_subs and (
-            query is not None or aggregation is not None or time_window is not None
-        ):
-            try:
-                environment = alert_rule.environment.all()[:1].get()
-            except Environment.DoesNotExist:
-                environment = None
-
-            # If updating any subscription details, update related Snuba subscriptions
-            # too
-            bulk_update_snuba_subscriptions(
-                existing_subs,
-                alert_rule.query,
-                QueryAggregations(alert_rule.aggregation),
-                timedelta(minutes=alert_rule.time_window),
-                timedelta(minutes=DEFAULT_ALERT_RULE_RESOLUTION),
-                environment,
-            )
-
     return alert_rule
 
 
@@ -801,20 +833,11 @@ def subscribe_projects_to_alert_rule(alert_rule, projects):
     Subscribes a list of projects to an alert rule
     :return: The list of created subscriptions
     """
-    try:
-        environment = alert_rule.environment.all()[:1].get()
-    except Environment.DoesNotExist:
-        environment = None
-
     subscriptions = bulk_create_snuba_subscriptions(
         projects,
         tasks.INCIDENTS_SNUBA_SUBSCRIPTION_TYPE,
-        QueryDatasets(alert_rule.dataset),
-        alert_rule.query,
+        alert_rule.snuba_query,
         QueryAggregations(alert_rule.aggregation),
-        timedelta(minutes=alert_rule.time_window),
-        timedelta(minutes=alert_rule.resolution),
-        environment,
     )
     subscription_links = [
         AlertRuleQuerySubscription(query_subscription=subscription, alert_rule=alert_rule)
diff --git a/src/sentry/snuba/subscriptions.py b/src/sentry/snuba/subscriptions.py
index 19f87602d2..c9f4caaa9a 100644
--- a/src/sentry/snuba/subscriptions.py
+++ b/src/sentry/snuba/subscriptions.py
@@ -2,7 +2,14 @@ from __future__ import absolute_import
 
 import logging
 
-from sentry.snuba.models import QuerySubscription, QuerySubscriptionEnvironment
+from django.db import transaction
+
+from sentry.snuba.models import (
+    QueryAggregations,
+    QuerySubscription,
+    QuerySubscriptionEnvironment,
+    SnubaQuery,
+)
 from sentry.snuba.tasks import (
     create_subscription_in_snuba,
     delete_subscription_from_snuba,
@@ -11,16 +18,50 @@ from sentry.snuba.tasks import (
 
 logger = logging.getLogger(__name__)
 
+aggregation_function_translations = {
+    QueryAggregations.TOTAL: "count()",
+    QueryAggregations.UNIQUE_USERS: "count_unique(user)",
+}
+
 
-def bulk_create_snuba_subscriptions(
-    projects, subscription_type, dataset, query, aggregation, time_window, resolution, environment
-):
+def translate_aggregation(aggregation):
     """
-    Creates a subscription to a snuba query for each project.
+    Temporary function to translate `QueryAggregations` into the discover aggregation
+    function format
+    :param aggregation:
+    :return: A string representing the aggregate function
+    """
+    return aggregation_function_translations[aggregation]
 
-    :param projects: The projects we're applying the query to
-    :param subscription_type: Text identifier for the subscription type this is. Used
-    to identify the registered callback associated with this subscription.
+
+def create_snuba_query(dataset, query, aggregation, time_window, resolution, environment):
+    """
+    Creates a SnubaQuery.
+
+    :param dataset: The snuba dataset to query and aggregate over
+    :param query: An event search query that we can parse and convert into a
+    set of Snuba conditions
+    :param aggregation: An aggregation to calculate over the time window
+    :param time_window: The time window to aggregate over
+    :param resolution: How often to receive updates/bucket size
+    :param environment: An optional environment to filter by
+    :return: A list of QuerySubscriptions
+    """
+    return SnubaQuery.objects.create(
+        dataset=dataset.value,
+        query=query,
+        aggregate=translate_aggregation(aggregation),
+        time_window=int(time_window.total_seconds()),
+        resolution=int(resolution.total_seconds()),
+        environment=environment,
+    )
+
+
+def update_snuba_query(snuba_query, query, aggregation, time_window, resolution, environment):
+    """
+    Updates a SnubaQuery. Triggers updates to any related QuerySubscriptions.
+
+    :param snuba_query: The `SnubaQuery` to update.
     :param dataset: The snuba dataset to query and aggregate over
     :param query: An event search query that we can parse and convert into a
     set of Snuba conditions
@@ -30,55 +71,65 @@ def bulk_create_snuba_subscriptions(
     :param environment: An optional environment to filter by
     :return: A list of QuerySubscriptions
     """
+    with transaction.atomic():
+        query_subscriptions = list(snuba_query.subscriptions.all())
+        snuba_query.update(
+            query=query,
+            aggregate=translate_aggregation(aggregation),
+            time_window=int(time_window.total_seconds()),
+            resolution=int(resolution.total_seconds()),
+            environment=environment,
+        )
+        bulk_update_snuba_subscriptions(query_subscriptions, snuba_query, aggregation)
+
+
+def bulk_create_snuba_subscriptions(projects, subscription_type, snuba_query, aggregation):
+    """
+    Creates a subscription to a snuba query for each project.
+
+    :param projects: The projects we're applying the query to
+    :param subscription_type: Text identifier for the subscription type this is. Used
+    to identify the registered callback associated with this subscription.
+    :param snuba_query: A `SnubaQuery` instance to subscribe the projects to.
+    :param aggregation: An aggregation to calculate over the time window. This will be
+    removed soon, once we're relying entirely on `snuba_query`.
+    :return: A list of QuerySubscriptions
+    """
     subscriptions = []
     # TODO: Batch this up properly once we care about multi-project rules.
     for project in projects:
         subscriptions.append(
-            create_snuba_subscription(
-                project,
-                subscription_type,
-                dataset,
-                query,
-                aggregation,
-                time_window,
-                resolution,
-                environment,
-            )
+            create_snuba_subscription(project, subscription_type, snuba_query, aggregation)
         )
     return subscriptions
 
 
-def create_snuba_subscription(
-    project, subscription_type, dataset, query, aggregation, time_window, resolution, environment
-):
+def create_snuba_subscription(project, subscription_type, snuba_query, aggregation):
     """
     Creates a subscription to a snuba query.
 
     :param project: The project we're applying the query to
     :param subscription_type: Text identifier for the subscription type this is. Used
     to identify the registered callback associated with this subscription.
-    :param dataset: The snuba dataset to query and aggregate over
-    :param query: An event search query that we can parse and convert into a
-    set of Snuba conditions
-    :param aggregation: An aggregation to calculate over the time window
-    :param time_window: The time window to aggregate over
-    :param resolution: How often to receive updates/bucket size
-    :param environment: An optional environment to filter by
+    :param snuba_query: A `SnubaQuery` instance to subscribe the project to.
+    :param aggregation: An aggregation to calculate over the time window. This will be
+    removed soon, once we're relying entirely on `snuba_query`.
     :return: The QuerySubscription representing the subscription
     """
     subscription = QuerySubscription.objects.create(
         status=QuerySubscription.Status.CREATING.value,
         project=project,
+        snuba_query=snuba_query,
         type=subscription_type,
-        dataset=dataset.value,
-        query=query,
+        dataset=snuba_query.dataset,
+        query=snuba_query.query,
         aggregation=aggregation.value,
-        time_window=int(time_window.total_seconds()),
-        resolution=int(resolution.total_seconds()),
+        time_window=snuba_query.time_window,
+        resolution=snuba_query.resolution,
     )
-    if environment:
+    if snuba_query.environment:
         QuerySubscriptionEnvironment.objects.create(
-            query_subscription=subscription, environment=environment
+            query_subscription=subscription, environment=snuba_query.environment
         )
 
     create_subscription_in_snuba.apply_async(
@@ -88,64 +139,55 @@ def create_snuba_subscription(
     return subscription
 
 
-def bulk_update_snuba_subscriptions(
-    subscriptions, query, aggregation, time_window, resolution, environment
-):
+def bulk_update_snuba_subscriptions(subscriptions, snuba_query, aggregation):
     """
     Updates a list of query subscriptions.
 
     :param subscriptions: The subscriptions we're updating
-    :param query: An event search query that we can parse and convert into a
-    set of Snuba conditions
-    :param aggregation: An aggregation to calculate over the time window
-    :param time_window: The time window to aggregate over
-    :param resolution: How often to receive updates/bucket size
-    :param environment: An optional environment to filter by
+    :param snuba_query: A `SnubaQuery` instance to subscribe the project to.
+    :param aggregation: An aggregation to calculate over the time window. This will be
+    removed soon, once we're relying entirely on `snuba_query`.
     :return: A list of QuerySubscriptions
     """
     updated_subscriptions = []
     # TODO: Batch this up properly once we care about multi-project rules.
     for subscription in subscriptions:
         updated_subscriptions.append(
-            update_snuba_subscription(
-                subscription, query, aggregation, time_window, resolution, environment
-            )
+            update_snuba_subscription(subscription, snuba_query, aggregation)
         )
     return subscriptions
 
 
-def update_snuba_subscription(
-    subscription, query, aggregation, time_window, resolution, environment
-):
+def update_snuba_subscription(subscription, snuba_query, aggregation):
     """
     Updates a subscription to a snuba query.
 
     :param query: An event search query that we can parse and convert into a
     set of Snuba conditions
-    :param aggregation: An aggregation to calculate over the time window
-    :param time_window: The time window to aggregate over
-    :param resolution: How often to receive updates/bucket size
-    :param environment: An optional environment to filter by
+    :param snuba_query: A `SnubaQuery` instance to subscribe the project to.
+    :param aggregation: An aggregation to calculate over the time window. This will be
+    removed soon, once we're relying entirely on `snuba_query`.
     :return: The QuerySubscription representing the subscription
     """
-    subscription.update(
-        status=QuerySubscription.Status.UPDATING.value,
-        query=query,
-        aggregation=aggregation.value,
-        time_window=int(time_window.total_seconds()),
-        resolution=int(resolution.total_seconds()),
-    )
-    QuerySubscriptionEnvironment.objects.filter(query_subscription=subscription).exclude(
-        environment=environment
-    ).delete()
-    if environment:
-        QuerySubscriptionEnvironment.objects.get_or_create(
-            query_subscription=subscription, environment=environment
+    with transaction.atomic():
+        subscription.update(
+            status=QuerySubscription.Status.UPDATING.value,
+            query=snuba_query.query,
+            aggregation=aggregation.value,
+            time_window=snuba_query.time_window,
+            resolution=snuba_query.resolution,
         )
+        QuerySubscriptionEnvironment.objects.filter(query_subscription=subscription).exclude(
+            environment=snuba_query.environment
+        ).delete()
+        if snuba_query.environment:
+            QuerySubscriptionEnvironment.objects.get_or_create(
+                query_subscription=subscription, environment=snuba_query.environment
+            )
 
-    update_subscription_in_snuba.apply_async(
-        kwargs={"query_subscription_id": subscription.id}, countdown=5
-    )
+        update_subscription_in_snuba.apply_async(
+            kwargs={"query_subscription_id": subscription.id}, countdown=5
+        )
 
     return subscription
 
diff --git a/tests/sentry/snuba/test_subscriptions.py b/tests/sentry/snuba/test_subscriptions.py
index b859a216e5..87e5631666 100644
--- a/tests/sentry/snuba/test_subscriptions.py
+++ b/tests/sentry/snuba/test_subscriptions.py
@@ -5,13 +5,48 @@ from datetime import timedelta
 from sentry.snuba.models import QueryAggregations, QueryDatasets, QuerySubscription
 from sentry.snuba.subscriptions import (
     bulk_delete_snuba_subscriptions,
+    create_snuba_query,
     create_snuba_subscription,
     delete_snuba_subscription,
+    translate_aggregation,
+    update_snuba_query,
     update_snuba_subscription,
 )
 from sentry.testutils import TestCase
 
 
+class CreateSnubaQueryTest(TestCase):
+    def test(self):
+        dataset = QueryDatasets.EVENTS
+        query = "level:error"
+        aggregation = QueryAggregations.TOTAL
+        time_window = timedelta(minutes=10)
+        resolution = timedelta(minutes=1)
+        snuba_query = create_snuba_query(dataset, query, aggregation, time_window, resolution, None)
+        assert snuba_query.dataset == dataset.value
+        assert snuba_query.query == query
+        assert snuba_query.aggregate == translate_aggregation(aggregation)
+        assert snuba_query.time_window == int(time_window.total_seconds())
+        assert snuba_query.resolution == int(resolution.total_seconds())
+        assert snuba_query.environment is None
+
+    def test_environment(self):
+        dataset = QueryDatasets.EVENTS
+        query = "level:error"
+        aggregation = QueryAggregations.TOTAL
+        time_window = timedelta(minutes=10)
+        resolution = timedelta(minutes=1)
+        snuba_query = create_snuba_query(
+            dataset, query, aggregation, time_window, resolution, self.environment
+        )
+        assert snuba_query.dataset == dataset.value
+        assert snuba_query.query == query
+        assert snuba_query.aggregate == translate_aggregation(aggregation)
+        assert snuba_query.time_window == int(time_window.total_seconds())
+        assert snuba_query.resolution == int(resolution.total_seconds())
+        assert snuba_query.environment == self.environment
+
+
 class CreateSnubaSubscriptionTest(TestCase):
     def test(self):
         type = "something"
@@ -20,9 +55,11 @@ class CreateSnubaSubscriptionTest(TestCase):
         aggregation = QueryAggregations.TOTAL
         time_window = timedelta(minutes=10)
         resolution = timedelta(minutes=1)
-        subscription = create_snuba_subscription(
-            self.project, type, dataset, query, aggregation, time_window, resolution, None
+        snuba_query = create_snuba_query(
+            dataset, query, aggregation, time_window, resolution, self.environment
         )
+        subscription = create_snuba_subscription(self.project, type, snuba_query, aggregation)
+
         assert subscription.status == QuerySubscription.Status.CREATING.value
         assert subscription.project == self.project
         assert subscription.type == type
@@ -41,9 +78,10 @@ class CreateSnubaSubscriptionTest(TestCase):
             aggregation = QueryAggregations.TOTAL
             time_window = timedelta(minutes=10)
             resolution = timedelta(minutes=1)
-            subscription = create_snuba_subscription(
-                self.project, type, dataset, query, aggregation, time_window, resolution, None
+            snuba_query = create_snuba_query(
+                dataset, query, aggregation, time_window, resolution, self.environment
             )
+            subscription = create_snuba_subscription(self.project, type, snuba_query, aggregation)
             subscription = QuerySubscription.objects.get(id=subscription.id)
             assert subscription.status == QuerySubscription.Status.ACTIVE.value
             assert subscription.project == self.project
@@ -62,13 +100,16 @@ class CreateSnubaSubscriptionTest(TestCase):
         aggregation = QueryAggregations.TOTAL
         time_window = timedelta(minutes=10)
         resolution = timedelta(minutes=1)
-        subscription = create_snuba_subscription(
-            self.project, type, dataset, query, aggregation, time_window, resolution, None
-        )
-        assert subscription.status == QuerySubscription.Status.CREATING.value
+        with self.tasks():
+            snuba_query = create_snuba_query(
+                dataset, query, aggregation, time_window, resolution, self.environment
+            )
+            subscription = create_snuba_subscription(self.project, type, snuba_query, aggregation)
+        subscription = QuerySubscription.objects.get(id=subscription.id)
+        assert subscription.status == QuerySubscription.Status.ACTIVE.value
         assert subscription.project == self.project
         assert subscription.type == type
-        assert subscription.subscription_id is None
+        assert subscription.subscription_id is not None
         assert subscription.dataset == dataset.value
         assert subscription.query == query
         assert subscription.aggregation == aggregation.value
@@ -76,12 +117,82 @@ class CreateSnubaSubscriptionTest(TestCase):
         assert subscription.resolution == int(resolution.total_seconds())
 
 
+class UpdateSnubaQueryTest(TestCase):
+    def test(self):
+        dataset = QueryDatasets.EVENTS
+        snuba_query = create_snuba_query(
+            dataset,
+            "hello",
+            QueryAggregations.UNIQUE_USERS,
+            timedelta(minutes=100),
+            timedelta(minutes=2),
+            self.environment,
+        )
+        query = "level:error"
+        aggregation = QueryAggregations.TOTAL
+        time_window = timedelta(minutes=10)
+        resolution = timedelta(minutes=1)
+        update_snuba_query(snuba_query, query, aggregation, time_window, resolution, None)
+        assert snuba_query.dataset == dataset.value
+        assert snuba_query.query == query
+        assert snuba_query.aggregate == translate_aggregation(aggregation)
+        assert snuba_query.time_window == int(time_window.total_seconds())
+        assert snuba_query.resolution == int(resolution.total_seconds())
+        assert snuba_query.environment is None
+
+    def test_environment(self):
+        dataset = QueryDatasets.EVENTS
+        snuba_query = create_snuba_query(
+            dataset,
+            "hello",
+            QueryAggregations.UNIQUE_USERS,
+            timedelta(minutes=100),
+            timedelta(minutes=2),
+            self.environment,
+        )
+
+        new_env = self.create_environment()
+        query = "level:error"
+        aggregation = QueryAggregations.TOTAL
+        time_window = timedelta(minutes=10)
+        resolution = timedelta(minutes=1)
+        update_snuba_query(snuba_query, query, aggregation, time_window, resolution, new_env)
+        assert snuba_query.dataset == dataset.value
+        assert snuba_query.query == query
+        assert snuba_query.aggregate == translate_aggregation(aggregation)
+        assert snuba_query.time_window == int(time_window.total_seconds())
+        assert snuba_query.resolution == int(resolution.total_seconds())
+        assert snuba_query.environment == new_env
+
+    def test_subscriptions(self):
+        dataset = QueryDatasets.EVENTS
+        snuba_query = create_snuba_query(
+            dataset,
+            "hello",
+            QueryAggregations.UNIQUE_USERS,
+            timedelta(minutes=100),
+            timedelta(minutes=2),
+            self.environment,
+        )
+        sub = create_snuba_subscription(self.project, "hi", snuba_query, QueryAggregations.TOTAL)
+
+        new_env = self.create_environment()
+        query = "level:error"
+        aggregation = QueryAggregations.TOTAL
+        time_window = timedelta(minutes=10)
+        resolution = timedelta(minutes=1)
+        update_snuba_query(snuba_query, query, aggregation, time_window, resolution, new_env)
+        sub.refresh_from_db()
+        assert sub.snuba_query == snuba_query
+        assert sub.query == query
+        assert sub.time_window == int(time_window.total_seconds())
+        assert sub.resolution == int(resolution.total_seconds())
+
+
 class UpdateSnubaSubscriptionTest(TestCase):
     def test(self):
         with self.tasks():
-            subscription = create_snuba_subscription(
-                self.project,
-                "something",
+            snuba_query = create_snuba_query(
                 QueryDatasets.EVENTS,
                 "level:error",
                 QueryAggregations.TOTAL,
@@ -89,6 +200,9 @@ class UpdateSnubaSubscriptionTest(TestCase):
                 timedelta(minutes=1),
                 None,
             )
+            subscription = create_snuba_subscription(
+                self.project, "something", snuba_query, QueryAggregations.TOTAL
+            )
 
         query = "level:warning"
         aggregation = QueryAggregations.UNIQUE_USERS
@@ -96,8 +210,14 @@ class UpdateSnubaSubscriptionTest(TestCase):
         resolution = timedelta(minutes=2)
         subscription = QuerySubscription.objects.get(id=subscription.id)
         subscription_id = subscription.subscription_id
+        snuba_query.update(
+            query=query,
+            time_window=int(time_window.total_seconds()),
+            resolution=int(resolution.total_seconds()),
+            environment=self.environment,
+        )
         assert subscription_id is not None
-        update_snuba_subscription(subscription, query, aggregation, time_window, resolution, None)
+        update_snuba_subscription(subscription, snuba_query, aggregation)
         assert subscription.status == QuerySubscription.Status.UPDATING.value
         assert subscription.subscription_id == subscription_id
         assert subscription.query == query
@@ -107,9 +227,7 @@ class UpdateSnubaSubscriptionTest(TestCase):
 
     def test_with_task(self):
         with self.tasks():
-            subscription = create_snuba_subscription(
-                self.project,
-                "something",
+            snuba_query = create_snuba_query(
                 QueryDatasets.EVENTS,
                 "level:error",
                 QueryAggregations.TOTAL,
@@ -117,6 +235,9 @@ class UpdateSnubaSubscriptionTest(TestCase):
                 timedelta(minutes=1),
                 None,
             )
+            subscription = create_snuba_subscription(
+                self.project, "something", snuba_query, QueryAggregations.TOTAL
+            )
 
             query = "level:warning"
             aggregation = QueryAggregations.UNIQUE_USERS
@@ -125,9 +246,13 @@ class UpdateSnubaSubscriptionTest(TestCase):
             subscription = QuerySubscription.objects.get(id=subscription.id)
             subscription_id = subscription.subscription_id
             assert subscription_id is not None
-            update_snuba_subscription(
-                subscription, query, aggregation, time_window, resolution, None
+            snuba_query.update(
+                query=query,
+                time_window=int(time_window.total_seconds()),
+                resolution=int(resolution.total_seconds()),
+                environment=self.environment,
             )
+            update_snuba_subscription(subscription, snuba_query, aggregation)
             subscription = QuerySubscription.objects.get(id=subscription.id)
             assert subscription.status == QuerySubscription.Status.ACTIVE.value
             assert subscription.subscription_id is not None
@@ -141,9 +266,7 @@ class UpdateSnubaSubscriptionTest(TestCase):
 class BulkDeleteSnubaSubscriptionTest(TestCase):
     def test(self):
         with self.tasks():
-            subscription = create_snuba_subscription(
-                self.project,
-                "something",
+            snuba_query = create_snuba_query(
                 QueryDatasets.EVENTS,
                 "level:error",
                 QueryAggregations.TOTAL,
@@ -151,9 +274,10 @@ class BulkDeleteSnubaSubscriptionTest(TestCase):
                 timedelta(minutes=1),
                 None,
             )
-            other_subscription = create_snuba_subscription(
-                self.create_project(organization=self.organization),
-                "something",
+            subscription = create_snuba_subscription(
+                self.project, "something", snuba_query, QueryAggregations.TOTAL
+            )
+            snuba_query = create_snuba_query(
                 QueryDatasets.EVENTS,
                 "level:error",
                 QueryAggregations.TOTAL,
@@ -161,6 +285,12 @@ class BulkDeleteSnubaSubscriptionTest(TestCase):
                 timedelta(minutes=1),
                 None,
             )
+            other_subscription = create_snuba_subscription(
+                self.create_project(organization=self.organization),
+                "something",
+                snuba_query,
+                QueryAggregations.TOTAL,
+            )
         subscription_ids = [subscription.id, other_subscription.id]
         bulk_delete_snuba_subscriptions([subscription, other_subscription])
         assert (
@@ -176,9 +306,7 @@ class BulkDeleteSnubaSubscriptionTest(TestCase):
 class DeleteSnubaSubscriptionTest(TestCase):
     def test(self):
         with self.tasks():
-            subscription = create_snuba_subscription(
-                self.project,
-                "something",
+            snuba_query = create_snuba_query(
                 QueryDatasets.EVENTS,
                 "level:error",
                 QueryAggregations.TOTAL,
@@ -186,6 +314,9 @@ class DeleteSnubaSubscriptionTest(TestCase):
                 timedelta(minutes=1),
                 None,
             )
+            subscription = create_snuba_subscription(
+                self.project, "something", snuba_query, QueryAggregations.TOTAL
+            )
         # Refetch since snuba creation happens in a task
         subscription = QuerySubscription.objects.get(id=subscription.id)
         subscription_id = subscription.subscription_id
@@ -196,9 +327,7 @@ class DeleteSnubaSubscriptionTest(TestCase):
 
     def test_with_task(self):
         with self.tasks():
-            subscription = create_snuba_subscription(
-                self.project,
-                "something",
+            snuba_query = create_snuba_query(
                 QueryDatasets.EVENTS,
                 "level:error",
                 QueryAggregations.TOTAL,
@@ -206,6 +335,9 @@ class DeleteSnubaSubscriptionTest(TestCase):
                 timedelta(minutes=1),
                 None,
             )
+            subscription = create_snuba_subscription(
+                self.project, "something", snuba_query, QueryAggregations.TOTAL
+            )
             subscription_id = subscription.id
             delete_snuba_subscription(subscription)
             assert not QuerySubscription.objects.filter(id=subscription_id).exists()

commit 580b1120e56817144fb811032d30bbd90641683d
Author: Ben Vinegar <ben@benv.ca>
Date:   Tue Apr 19 14:30:45 2016 -0700

    Fix rule editor delete button removing wrong row, resetting styles (fixes #2915)
    
    /cc @getsentry/ui

diff --git a/src/sentry/static/sentry/app/views/ruleEditor/ruleNodeList.jsx b/src/sentry/static/sentry/app/views/ruleEditor/ruleNodeList.jsx
index 0f0673679b..59d1a57830 100644
--- a/src/sentry/static/sentry/app/views/ruleEditor/ruleNodeList.jsx
+++ b/src/sentry/static/sentry/app/views/ruleEditor/ruleNodeList.jsx
@@ -10,13 +10,20 @@ const RuleNodeList = React.createClass({
   },
 
   getInitialState() {
+    let counter = 0;
+    let initialItems = (this.props.initialItems || []).map(item => {
+      return {...item, key: counter++};
+    });
+
     return {
-      items: this.props.initialItems || []
+      items: initialItems,
+      counter: counter
     };
   },
 
   componentWillMount() {
     this._nodesById = {};
+
     this.props.nodes.forEach((node) => {
       this._nodesById[node.id] = node;
     });
@@ -29,10 +36,16 @@ const RuleNodeList = React.createClass({
     sel.val('');
 
     this.state.items.push({
-      id: nodeId
+      id: nodeId,
+      // Since RuleNode item state is stored outside of React (using innerHTML),
+      // need to make sure elements aren't accidentally re-rendered. So, give each
+      // row a consistent key using a counter that initializes at 0 when RuleNodeList
+      // is mounted.
+      key: this.state.counter
     });
     this.setState({
-      items: this.state.items
+      items: this.state.items,
+      counter: this.state.counter + 1
     });
   },
 
@@ -56,7 +69,7 @@ const RuleNodeList = React.createClass({
           <tbody>
             {this.state.items.map((item, idx) => {
               return (
-                <RuleNode key={idx}
+                <RuleNode key={item.key}
                   node={this.getNode(item.id)}
                   onDelete={this.onDeleteRow.bind(this, idx)}
                   data={item} />
diff --git a/tests/js/spec/views/ruleEditor/ruleNodeList.spec.jsx b/tests/js/spec/views/ruleEditor/ruleNodeList.spec.jsx
new file mode 100644
index 0000000000..b28192bbb6
--- /dev/null
+++ b/tests/js/spec/views/ruleEditor/ruleNodeList.spec.jsx
@@ -0,0 +1,67 @@
+import React from 'react';
+import {shallow} from 'enzyme';
+
+import RuleNodeList from 'app/views/ruleEditor/ruleNodeList';
+
+describe('RuleNodeList', function() {
+
+  beforeEach(function() {
+    this.sampleNodes = [
+      {
+        id: 'sentry.rules.conditions.every_event.EveryEventCondition',
+        label: 'An event is seen',
+        html: 'An event is seen'
+      },
+      {
+        id: 'sentry.rules.conditions.event_frequency.EventFrequencyCondition',
+        label: 'An event is seen more than {value} times in {interval}',
+        html: 'An event is seen more than <input id="id_value" name="value" placeholder="100" type="number" /> times ' +
+              'in <select id="id_interval" name="interval">↵<option value="1m">one minute</option>↵<option value="1h">one hour</option>↵</select>'
+      }
+    ];
+  });
+
+  describe('getInitialItems()', function () {
+    it('should give each initial item a unique incremented key, and set state.counter', function () {
+      let initialItems = [
+        {
+          id: 'sentry.rules.conditions.event_frequency.EventFrequencyCondition',
+          value: 50,
+          interval: '1m'
+        },
+        {
+          id: 'sentry.rules.conditions.every_event.EveryEventCondition'
+        }
+      ];
+
+      let wrapper = shallow(<RuleNodeList nodes={this.sampleNodes} initialItems={initialItems}/>);
+
+      expect(wrapper.state('items')[0]).to.have.property('key', 0);
+      expect(wrapper.state('items')[1]).to.have.property('key', 1);
+      expect(wrapper.state('counter')).to.equal(2);
+    });
+  });
+
+  describe('onAddRow()', function() {
+    it('should add a new item with key value equal to state.counter, and increment state.counter', function () {
+      let wrapper = shallow(<RuleNodeList nodes={this.sampleNodes} />);
+
+      wrapper.setState({
+        counter: 5
+      });
+
+      wrapper.instance().onAddRow({
+        val: function () {
+          return 'sentry.rules.conditions.every_event.EveryEventCondition';
+        }
+      });
+
+      expect(wrapper.state('items')[0]).to.eql({
+        id: 'sentry.rules.conditions.every_event.EveryEventCondition',
+        key: 5
+      });
+      expect(wrapper.state('counter')).to.equal(6);
+    });
+  });
+});
+

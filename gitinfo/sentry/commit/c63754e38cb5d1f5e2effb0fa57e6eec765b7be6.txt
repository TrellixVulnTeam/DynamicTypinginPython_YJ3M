commit c63754e38cb5d1f5e2effb0fa57e6eec765b7be6
Author: Billy Vong <billyvg@gmail.com>
Date:   Thu Jul 27 17:36:23 2017 -0700

    Add tests for groupingStore

diff --git a/src/sentry/static/sentry/app/stores/groupingStore.jsx b/src/sentry/static/sentry/app/stores/groupingStore.jsx
index fea1b821f2..4b75a55577 100644
--- a/src/sentry/static/sentry/app/stores/groupingStore.jsx
+++ b/src/sentry/static/sentry/app/stores/groupingStore.jsx
@@ -12,41 +12,40 @@ const SIMILARITY_THRESHOLD = 50;
 // @param score: {[key: string]: number}
 const getAvgScore = score => {
   let scoreKeys = (score && Object.keys(score)) || [];
-  return (
+  return Math.round(
     scoreKeys.map(key => score[key]).reduce((acc, s) => acc + s * 100, 0) /
-    scoreKeys.length
+      scoreKeys.length
   );
 };
 
 const GroupingStore = Reflux.createStore({
   listenables: [GroupingActions],
   init() {
-    // List of merged items
-    this.mergedItems = [];
-    // List of items selected to be unmerged
-    this.unmergeList = new Set();
-    // State object for unmerged row items
-    this.unmergeState = new Map();
-    // Unmerge button state
-    this.unmergeDisabled = false;
-
-    // List of similar items above min. score index
-    this.similarItems = [];
-    // List of similar items below min. score index
-    this.filteredSimilarItems = [];
-    // Pagination for above list
-    this.similarLinks = '';
-    // State object for merged row items
-    this.mergeState = new Map();
-    // List of items selected to be merged
-    this.mergeList = new Set();
-    // Pagination for above list
-    this.mergedLinks = '';
-    // Merge button state
-    this.mergeDisabled = false;
-
-    this.loading = true;
-    this.error = false;
+    let state = this.getDefaultState();
+
+    Object.entries(state).forEach(([key, value]) => {
+      this[key] = value;
+    });
+  },
+
+  getDefaultState() {
+    return {
+      mergedItems: [],
+      unmergeList: new Set(),
+      unmergeState: new Map(),
+      unmergeDisabled: false,
+
+      similarItems: [],
+      filteredSimilarItems: [],
+      similarLinks: '',
+      mergeState: new Map(),
+      mergeList: new Set(),
+      mergedLinks: '',
+      mergeDisabled: false,
+
+      loading: true,
+      error: false
+    };
   },
 
   setStateForId(map, id, newState) {
@@ -88,7 +87,7 @@ const GroupingStore = Reflux.createStore({
       merged: item => {
         // Check for locked items
         this.setStateForId(this.unmergeState, item.id, {
-          busy: item.status === 'locked'
+          busy: item.state === 'locked'
         });
         return item;
       },
@@ -106,7 +105,11 @@ const GroupingStore = Reflux.createStore({
       }
     };
 
-    Promise.all(promises).then(
+    if (toFetchArray) {
+      this.toFetchArray = toFetchArray;
+    }
+
+    return Promise.all(promises).then(
       resultsArray => {
         resultsArray.forEach(({dataKey, data, links}) => {
           let items = data.map(responseProcessors[dataKey]);
@@ -119,115 +122,103 @@ const GroupingStore = Reflux.createStore({
         this.triggerFetchState();
       },
       () => {
+        this.loading = false;
         this.error = true;
         this.triggerFetchState();
       }
     );
-
-    if (toFetchArray) {
-      this.toFetchArray = toFetchArray;
-    }
   },
 
   // Toggle merge checkbox
   onToggleMerge(id) {
     let checked;
 
-    if (this.mergeList.has(id)) {
-      this.mergeList.delete(id);
-      checked = false;
-    } else {
-      this.mergeList.add(id);
-      checked = true;
-    }
+    // Don't do anything if item is busy
+    let state = this.mergeState.has(id) && this.mergeState.get(id);
+    if (!state || state.busy !== true) {
+      if (this.mergeList.has(id)) {
+        this.mergeList.delete(id);
+        checked = false;
+      } else {
+        this.mergeList.add(id);
+        checked = true;
+      }
 
-    this.setStateForId(this.mergeState, id, {
-      checked
-    });
+      this.setStateForId(this.mergeState, id, {
+        checked
+      });
 
-    this.triggerMergeState();
+      this.triggerMergeState();
+    }
   },
 
   // Toggle unmerge check box
   onToggleUnmerge(id) {
     let checked;
 
-    // Uncheck an item to unmerge
-    if (this.unmergeList.has(id)) {
-      this.unmergeList.delete(id);
-      checked = false;
-
-      // If there was a single unchecked item before, make sure we reset its disabled state
-      if (this.remainingItem) {
-        this.setStateForId(this.unmergeState, this.remainingItem.id, {
-          disabled: false
-        });
-        this.remainingItem = null;
-      }
-    } else {
-      // at least 1 item must be unchecked for unmerge
-      // make sure that not all events have been selected
-
-      // Account for items in unmerge queue, or "locked" items
-      let lockedItems = Array.from(this.unmergeState.values()).filter(
-        ({locked}) => locked
-      ) || [];
-
-      if (this.unmergeList.size + 1 < this.mergedItems.length - lockedItems.length) {
-        this.unmergeList.add(id);
-        checked = true;
-
-        // Check if there's only one remaining item, and make sure to disable it from being
-        // selected to unmerge
-        if (this.unmergeList.size + 1 === this.mergedItems.length - lockedItems.length) {
-          let remainingItem = this.mergedItems.find(
-            item => !this.unmergeList.has(item.id)
-          );
-          if (remainingItem) {
-            this.remainingItem = remainingItem;
-            this.setStateForId(this.unmergeState, remainingItem.id, {
-              disabled: true
+    // Uncheck an item to unmerg
+    let state = this.unmergeState.has(id) && this.unmergeState.get(id);
+    if (!state || state.busy !== true) {
+      if (this.unmergeList.has(id)) {
+        this.unmergeList.delete(id);
+        checked = false;
+
+        // If there was a single unchecked item before, make sure we reset its disabled state
+        if (this.remainingItem) {
+          this.setStateForId(this.unmergeState, this.remainingItem.id, {
+            disabled: false
+          });
+          this.remainingItem = null;
+        }
+      } else {
+        // at least 1 item must be unchecked for unmerge
+        // make sure that not all events have been selected
+
+        // Account for items in unmerge queue, or "locked" items
+        let lockedItems = Array.from(this.unmergeState.values()).filter(
+          ({busy}) => busy
+        ) || [];
+
+        if (this.unmergeList.size + 1 < this.mergedItems.length - lockedItems.length) {
+          this.unmergeList.add(id);
+          checked = true;
+
+          // Check if there's only one remaining item, and make sure to disable it from being
+          // selected to unmerge
+          if (
+            this.unmergeList.size + 1 ===
+            this.mergedItems.length - lockedItems.length
+          ) {
+            let remainingItem = this.mergedItems.find(item => {
+              let notSelected = !this.unmergeList.has(item.id);
+              let itemState =
+                this.unmergeState.has(item.id) && this.unmergeState.get(item.id);
+              return notSelected && (!itemState || !itemState.busy);
             });
+            if (remainingItem) {
+              this.remainingItem = remainingItem;
+              this.setStateForId(this.unmergeState, remainingItem.id, {
+                disabled: true
+              });
+            }
           }
         }
       }
-    }
 
-    // Update "checked" state for row
-    this.setStateForId(this.unmergeState, id, {
-      checked
-    });
+      // Update "checked" state for row
+      this.setStateForId(this.unmergeState, id, {
+        checked
+      });
 
-    this.triggerUnmergeState();
+      this.triggerUnmergeState();
+    }
   },
 
   onUnmerge({groupId, loadingMessage, successMessage, errorMessage}) {
     let ids = Array.from(this.unmergeList.values());
+
     // Disable unmerge button
     this.unmergeDisabled = true;
-
-    let loadingIndicator = IndicatorStore.add(loadingMessage);
-    api.request(`/issues/${groupId}/hashes/`, {
-      method: 'DELETE',
-      query: {
-        id: ids
-      },
-      success: (data, _, jqXHR) => {
-        IndicatorStore.add(successMessage, 'success', {
-          duration: 5000
-        });
-      },
-      error: error => {
-        IndicatorStore.remove(loadingIndicator);
-        IndicatorStore.add(errorMessage, 'error');
-      },
-      complete: () => {
-        IndicatorStore.remove(loadingIndicator);
-        this.unmergeDisabled = false;
-        this.triggerUnmergeState();
-      }
-    });
-
     // Disable rows
     ids.forEach(id => {
       this.setStateForId(this.unmergeState, id, {
@@ -235,66 +226,108 @@ const GroupingStore = Reflux.createStore({
         busy: true
       });
     });
-
-    this.unmergeList.clear();
-
     this.triggerUnmergeState();
-  },
-
-  onMerge({params, query}) {
-    let ids = Array.from(this.mergeList.values());
-    // Disable merge button
-    this.mergeDisabled = true;
+    let loadingIndicator = IndicatorStore.add(loadingMessage);
 
-    if (params) {
-      let {orgId, groupId, projectId} = params;
-      api.merge(
-        {
-          orgId,
-          projectId,
-          // parent = last element in array
-          itemIds: [...ids, groupId],
-          query
+    let promise = new Promise((resolve, reject) => {
+      api.request(`/issues/${groupId}/hashes/`, {
+        method: 'DELETE',
+        query: {
+          id: ids
         },
-        {
-          success: (data, _, jqXHR) => {
-            // Hide rows after successful merge
-            ids.forEach(id => {
-              this.setStateForId(this.mergeState, id, {
-                checked: false,
-                busy: true
-              });
+        success: (data, _, jqXHR) => {
+          IndicatorStore.remove(loadingIndicator);
+          IndicatorStore.add(successMessage, 'success', {
+            duration: 5000
+          });
+          // Busy rows after successful merge
+          ids.forEach(id => {
+            this.setStateForId(this.unmergeState, id, {
+              checked: false,
+              busy: true
             });
-            this.mergeList.clear();
-            this.triggerMergeState();
-          },
-          error: () => {
-            ids.forEach(id => {
-              this.setStateForId(this.mergeState, id, {
-                checked: true,
-                busy: false
-              });
+          });
+          this.unmergeList.clear();
+          this.unmergeDisabled = false;
+          resolve(this.triggerUnmergeState());
+        },
+        error: () => {
+          IndicatorStore.remove(loadingIndicator);
+          IndicatorStore.add(errorMessage, 'error');
+          ids.forEach(id => {
+            this.setStateForId(this.unmergeState, id, {
+              checked: true,
+              busy: false
             });
-            this.triggerMergeState();
-          },
-          complete: () => {
-            this.mergeDisabled = false;
-            this.triggerMergeState();
-          }
+          });
+          this.unmergeDisabled = false;
+          resolve(this.triggerUnmergeState());
         }
-      );
-    }
+      });
+    });
+
+    return promise;
+  },
+
+  onMerge({params, query}) {
+    let ids = Array.from(this.mergeList.values());
 
+    this.mergeDisabled = true;
     ids.forEach(id => {
       this.setStateForId(this.mergeState, id, {
         busy: true
       });
     });
     this.triggerMergeState();
+
+    let promise = new Promise((resolve, reject) => {
+      // Disable merge button
+
+      if (params) {
+        let {orgId, groupId, projectId} = params;
+        api.merge(
+          {
+            orgId,
+            projectId,
+            // parent = last element in array
+            itemIds: [...ids, groupId],
+            query
+          },
+          {
+            success: (data, _, jqXHR) => {
+              // Hide rows after successful merge
+              ids.forEach(id => {
+                this.setStateForId(this.mergeState, id, {
+                  checked: false,
+                  busy: true
+                });
+              });
+              this.mergeList.clear();
+              this.mergeDisabled = false;
+              resolve(this.triggerMergeState());
+            },
+            error: () => {
+              ids.forEach(id => {
+                this.setStateForId(this.mergeState, id, {
+                  checked: true,
+                  busy: false
+                });
+              });
+              this.mergeDisabled = false;
+              resolve(this.triggerMergeState());
+            }
+          }
+        );
+      } else {
+        resolve(null);
+      }
+    });
+
+    return promise;
   },
 
   triggerFetchState() {
-    this.trigger({
+    let state = {
       mergedItems: this.mergedItems,
       mergedLinks: this.mergedLinks,
       similarItems: this.similarItems.filter(({isBelowThreshold}) => !isBelowThreshold),
@@ -306,23 +339,29 @@ const GroupingStore = Reflux.createStore({
       unmergeState: this.unmergeState,
       loading: this.loading,
       error: this.error
-    });
+    };
+    this.trigger(state);
+    return state;
   },
 
   triggerUnmergeState() {
-    this.trigger({
+    let state = {
       unmergeDisabled: this.unmergeDisabled,
       unmergeState: this.unmergeState,
       unmergeList: this.unmergeList
-    });
+    };
+    this.trigger(state);
+    return state;
   },
 
   triggerMergeState() {
-    this.trigger({
+    let state = {
       mergeDisabled: this.mergeDisabled,
       mergeState: this.mergeState,
       mergeList: this.mergeList
-    });
+    };
+    this.trigger(state);
+    return state;
   }
 });
 
diff --git a/tests/js/spec/stores/groupingStore.spec.jsx b/tests/js/spec/stores/groupingStore.spec.jsx
new file mode 100644
index 0000000000..733b6168d2
--- /dev/null
+++ b/tests/js/spec/stores/groupingStore.spec.jsx
@@ -0,0 +1,584 @@
+0; /* eslint-env jest */
+import GroupingStore from 'app/stores/groupingStore';
+import {Client} from 'app/api';
+jest.mock('app/api');
+
+/*
+expect.extend({
+  toHaveBeenLastCalledWithMatch(received, arg) {
+    console.log(this, received, arg);
+  }
+});
+ */
+
+describe('Grouping Store', function() {
+  let trigger;
+  beforeEach(function() {
+    trigger = jest.spyOn(GroupingStore, 'trigger');
+    // this.sandbox = sinon.sandbox.create();
+    Client.clearMockResponses();
+    Client.addMockResponse({
+      url: '/issues/groupId/hashes/',
+      body: [
+        {
+          latestEvent: {
+            eventID: 'event-1'
+          },
+          state: 'locked',
+          id: '1'
+        },
+        {
+          latestEvent: {
+            eventID: 'event-2'
+          },
+          state: 'unlocked',
+          id: '2'
+        },
+        {
+          latestEvent: {
+            eventID: 'event-3'
+          },
+          state: 'unlocked',
+          id: '3'
+        },
+        {
+          latestEvent: {
+            eventID: 'event-4'
+          },
+          state: 'unlocked',
+          id: '4'
+        },
+        {
+          latestEvent: {
+            eventID: 'event-5'
+          },
+          state: 'locked',
+          id: '5'
+        }
+      ]
+    });
+    Client.addMockResponse({
+      url: '/issues/groupId/similar/',
+      body: [
+        [
+          {
+            id: '274'
+          },
+          {
+            'exception:stacktrace:pairs': 0.375,
+            'exception:stacktrace:application-chunks': 0.175,
+            'message:message:character-shingles': 0.675
+          }
+        ],
+        [
+          {
+            id: '275'
+          },
+          {'exception:stacktrace:pairs': 1.000}
+        ],
+        [
+          {
+            id: '216'
+          },
+          {
+            'exception:stacktrace:application-chunks': 0.000235,
+            'exception:stacktrace:pairs': 0.001488
+          }
+        ]
+      ]
+    });
+  });
+
+  afterEach(function() {
+    // this.sandbox.restore();
+    trigger.mockReset();
+  });
+
+  describe('onFetch()', function() {
+    it('initially gets called with correct state values', function() {
+      GroupingStore.onFetch([]);
+
+      expect(trigger).toBeCalled();
+      expect(trigger).toBeCalledWith(
+        expect.objectContaining({
+          error: false,
+          filteredSimilarItems: [],
+          loading: true,
+          mergeState: new Map(),
+          mergedItems: [],
+          mergedLinks: '',
+          similarItems: [],
+          similarLinks: '',
+          unmergeState: new Map()
+        })
+      );
+    });
+
+    it('fetches list of similar items', async function() {
+      await GroupingStore.onFetch([
+        {dataKey: 'similar', endpoint: '/issues/groupId/similar/'}
+      ]);
+
+      expect(trigger).toBeCalled();
+      let calls = trigger.mock.calls;
+      let arg = calls[calls.length - 1][0];
+
+      expect(arg.filteredSimilarItems.length).toBe(2);
+      expect(arg.similarItems.length).toBe(1);
+      expect(arg).toMatchObject({
+        loading: false,
+        error: false,
+        mergeState: new Map(),
+        mergedItems: [],
+        similarItems: [
+          {
+            avgScore: 100,
+            isBelowThreshold: false,
+            issue: {
+              id: '275'
+            }
+          }
+        ],
+        filteredSimilarItems: [
+          {
+            avgScore: 41,
+            isBelowThreshold: true,
+            issue: {
+              id: '274'
+            }
+          },
+          {
+            avgScore: 0,
+            isBelowThreshold: true,
+            issue: {
+              id: '216'
+            }
+          }
+        ],
+        unmergeState: new Map()
+      });
+    });
+
+    it('unsuccessfully fetches list of similar items', function() {
+      Client.clearMockResponses();
+      Client.addMockResponse({
+        url: '/issues/groupId/similar/',
+        statusCode: 500,
+        body: {message: 'failed'}
+      });
+
+      let promise = GroupingStore.onFetch([
+        {dataKey: 'similar', endpoint: '/issues/groupId/similar/'}
+      ]);
+
+      expect(trigger).toBeCalled();
+      let calls = trigger.mock.calls;
+      return promise.then(() => {
+        let arg = calls[calls.length - 1][0];
+        expect(arg).toMatchObject({
+          loading: false,
+          error: true,
+          mergeState: new Map(),
+          mergedItems: [],
+          unmergeState: new Map()
+        });
+      });
+    });
+
+    it('fetches list of hashes', function() {
+      let promise = GroupingStore.onFetch([
+        {dataKey: 'merged', endpoint: '/issues/groupId/hashes/'}
+      ]);
+
+      expect(trigger).toBeCalled();
+      let calls = trigger.mock.calls;
+      return promise.then(() => {
+        let arg = calls[calls.length - 1][0];
+        expect(arg.mergedItems.length).toBe(5);
+        expect(arg).toMatchObject({
+          loading: false,
+          error: false,
+          similarItems: [],
+          filteredSimilarItems: [],
+          mergeState: new Map(),
+          unmergeState: new Map([
+            ['1', {busy: true}],
+            ['2', {busy: false}],
+            ['3', {busy: false}],
+            ['4', {busy: false}],
+            ['5', {busy: true}]
+          ])
+        });
+      });
+    });
+
+    it('unsuccessfully fetches list of hashes items', function() {
+      Client.clearMockResponses();
+      Client.addMockResponse({
+        url: '/issues/groupId/hashes/',
+        statusCode: 500,
+        body: {message: 'failed'}
+      });
+
+      let promise = GroupingStore.onFetch([
+        {dataKey: 'merged', endpoint: '/issues/groupId/hashes/'}
+      ]);
+
+      expect(trigger).toBeCalled();
+      let calls = trigger.mock.calls;
+      return promise.then(() => {
+        let arg = calls[calls.length - 1][0];
+        expect(arg).toMatchObject({
+          loading: false,
+          error: true,
+          mergeState: new Map(),
+          mergedItems: [],
+          unmergeState: new Map()
+        });
+      });
+    });
+  });
+
+  describe('Similar Issues list (to be merged)', function() {
+    let mergeList;
+    let mergeState;
+
+    beforeEach(function() {
+      mergeList = new Set();
+      mergeState = new Map();
+      return GroupingStore.onFetch([
+        {dataKey: 'similar', endpoint: '/issues/groupId/similar/'}
+      ]);
+    });
+
+    describe('onToggleMerge (checkbox state)', function() {
+      // Attempt to check first item but its "locked" so should not be able to do anything
+      it('can check and uncheck item', function() {
+        GroupingStore.onToggleMerge('1');
+
+        mergeList.add('1');
+        mergeState.set('1', {checked: true});
+        expect(GroupingStore.mergeList).toEqual(mergeList);
+        expect(GroupingStore.mergeState).toEqual(mergeState);
+
+        // Uncheck
+        GroupingStore.onToggleMerge('1');
+        mergeList.delete('1');
+        mergeState.set('1', {checked: false});
+
+        // Check all
+        GroupingStore.onToggleMerge('1');
+        GroupingStore.onToggleMerge('2');
+        GroupingStore.onToggleMerge('3');
+
+        mergeList.add('1');
+        mergeList.add('2');
+        mergeList.add('3');
+        mergeState.set('1', {checked: true});
+        mergeState.set('2', {checked: true});
+        mergeState.set('3', {checked: true});
+
+        expect(GroupingStore.mergeList).toEqual(mergeList);
+        expect(GroupingStore.mergeState).toEqual(mergeState);
+
+        expect(trigger).toHaveBeenLastCalledWith({
+          mergeDisabled: false,
+          mergeList,
+          mergeState
+        });
+      });
+    });
+
+    describe('onMerge', function() {
+      beforeEach(function() {
+        jest.spyOn(Client.prototype, 'merge');
+        Client.clearMockResponses();
+        Client.addMockResponse({
+          method: 'PUT',
+          url: '/projects/orgId/projectId/issues/'
+        });
+      });
+      afterEach(function() {});
+
+      it('disables rows to be merged', async function() {
+        GroupingStore.onToggleMerge('1');
+        let promise = GroupingStore.onMerge({
+          params: {
+            orgId: 'orgId',
+            projectId: 'projectId',
+            groupId: 'groupId'
+          }
+        });
+
+        mergeList.add('1');
+        mergeState.set('1', {checked: true, busy: false});
+
+        expect(trigger).toHaveBeenCalledWith({
+          mergeDisabled: true,
+          mergeList,
+          mergeState
+        });
+
+        await promise;
+
+        expect(Client.prototype.merge).toHaveBeenCalledWith(
+          {
+            orgId: 'orgId',
+            projectId: 'projectId',
+            itemIds: ['1', 'groupId'],
+            query: undefined
+          },
+          {
+            error: expect.any(Function),
+            success: expect.any(Function)
+          }
+        );
+
+        expect(trigger).toHaveBeenLastCalledWith({
+          mergeDisabled: false,
+          mergeList,
+          mergeState
+        });
+      });
+
+      it('keeps rows in "busy" state and unchecks after successfully adding to merge queue', async function() {
+        GroupingStore.onToggleMerge('1');
+        mergeList.add('1');
+        mergeState.set('1', {checked: true, busy: false});
+
+        let promise = GroupingStore.onMerge({
+          params: {
+            orgId: 'orgId',
+            projectId: 'projectId',
+            groupId: 'groupId'
+          }
+        });
+
+        expect(trigger).toHaveBeenCalledWith({
+          mergeDisabled: true,
+          mergeList,
+          mergeState
+        });
+
+        await promise;
+
+        expect(trigger).toHaveBeenLastCalledWith({
+          mergeDisabled: false,
+          mergeList: new Set(),
+          mergeState
+        });
+      });
+
+      it('resets busy state and has same items checked after error when trying to merge', async function() {
+        Client.clearMockResponses();
+        Client.addMockResponse({
+          method: 'PUT',
+          url: '/projects/orgId/projectId/issues/',
+          statusCode: 500,
+          body: {}
+        });
+
+        GroupingStore.onToggleMerge('1');
+        mergeList.add('1');
+        mergeState.set('1', {checked: true, busy: false});
+
+        let promise = GroupingStore.onMerge({
+          params: {
+            orgId: 'orgId',
+            projectId: 'projectId',
+            groupId: 'groupId'
+          }
+        });
+
+        expect(trigger).toHaveBeenCalledWith({
+          mergeDisabled: true,
+          mergeList,
+          mergeState
+        });
+
+        await promise;
+
+        expect(trigger).toHaveBeenLastCalledWith({
+          mergeDisabled: false,
+          mergeList,
+          mergeState
+        });
+      });
+    });
+  });
+
+  describe('Hashes list (to be unmerged)', function() {
+    let unmergeList;
+    let unmergeState;
+
+    beforeEach(async function() {
+      unmergeList = new Set();
+      unmergeState = new Map();
+      await GroupingStore.onFetch([
+        {dataKey: 'merged', endpoint: '/issues/groupId/hashes/'}
+      ]);
+
+      trigger.mockClear();
+      unmergeState = new Map([...GroupingStore.unmergeState]);
+    });
+
+    describe('onToggleUnmerge (checkbox state for hashes)', function() {
+      // Attempt to check first item but its "locked" so should not be able to do anything
+      it('can not check locked item', function() {
+        GroupingStore.onToggleUnmerge('1');
+
+        expect(GroupingStore.unmergeList).toEqual(unmergeList);
+        expect(GroupingStore.unmergeState).toEqual(unmergeState);
+        expect(trigger).not.toHaveBeenCalled();
+      });
+
+      it('can check and uncheck unlocked items', function() {
+        // Check
+        GroupingStore.onToggleUnmerge('2');
+        unmergeList.add('2');
+        unmergeState.set('2', {busy: false, checked: true});
+
+        expect(GroupingStore.unmergeList).toEqual(unmergeList);
+        expect(GroupingStore.unmergeState).toEqual(unmergeState);
+
+        // Uncheck
+        GroupingStore.onToggleUnmerge('2');
+        unmergeList.delete('2');
+        unmergeState.set('2', {busy: false, checked: false});
+
+        expect(GroupingStore.unmergeList).toEqual(unmergeList);
+        expect(GroupingStore.unmergeState).toEqual(unmergeState);
+
+        // Check
+        GroupingStore.onToggleUnmerge('2');
+        unmergeList.add('2');
+        unmergeState.set('2', {busy: false, checked: true});
+
+        expect(GroupingStore.unmergeList).toEqual(unmergeList);
+        expect(GroupingStore.unmergeState).toEqual(unmergeState);
+
+        expect(trigger).toHaveBeenLastCalledWith({
+          unmergeDisabled: false,
+          unmergeList,
+          unmergeState
+        });
+      });
+
+      it('selecting the second to last available checkbox should disable the remaining checkbox and re-enable when unchecking', function() {
+        GroupingStore.onToggleUnmerge('3');
+        GroupingStore.onToggleUnmerge('4');
+        unmergeList.add('3');
+        unmergeList.add('4');
+        unmergeState.set('3', {busy: false, checked: true});
+        unmergeState.set('4', {busy: false, checked: true});
+        unmergeState.set('2', {busy: false, disabled: true});
+
+        expect(GroupingStore.remainingItem).toMatchObject({
+          id: '2'
+        });
+        expect(GroupingStore.unmergeList).toEqual(unmergeList);
+        expect(GroupingStore.unmergeState).toEqual(unmergeState);
+
+        // Unchecking
+        GroupingStore.onToggleUnmerge('4');
+        unmergeList.delete('4');
+        unmergeState.set('4', {busy: false, checked: false});
+        unmergeState.set('2', {busy: false, disabled: false});
+
+        expect(GroupingStore.remainingItem).toBe(null);
+        expect(GroupingStore.unmergeList).toEqual(unmergeList);
+        expect(GroupingStore.unmergeState).toEqual(unmergeState);
+
+        expect(trigger).toHaveBeenLastCalledWith({
+          unmergeDisabled: false,
+          unmergeList,
+          unmergeState
+        });
+      });
+    });
+
+    describe('onUnmerge', function() {
+      beforeEach(function() {
+        Client.clearMockResponses();
+        Client.addMockResponse({
+          method: 'DELETE',
+          url: '/issues/groupId/hashes/'
+        });
+      });
+      afterEach(function() {});
+
+      it('disables rows to be merged', function() {
+        GroupingStore.onToggleUnmerge('1');
+        unmergeList.add('1');
+        unmergeState.set('1', {checked: true, busy: false});
+
+        trigger.mockClear();
+        GroupingStore.onUnmerge({
+          groupId: 'groupId'
+        });
+
+        expect(trigger).toHaveBeenCalledWith({
+          unmergeDisabled: true,
+          unmergeList,
+          unmergeState
+        });
+      });
+
+      it('keeps rows in "busy" state and unchecks after successfully adding to merge queue', async function() {
+        GroupingStore.onToggleUnmerge('1');
+        unmergeList.add('1');
+        unmergeState.set('1', {checked: true, busy: false});
+
+        let promise = GroupingStore.onUnmerge({
+          groupId: 'groupId'
+        });
+
+        expect(trigger).toHaveBeenCalledWith({
+          unmergeDisabled: true,
+          unmergeList,
+          unmergeState
+        });
+
+        await promise;
+
+        expect(trigger).toHaveBeenLastCalledWith({
+          unmergeDisabled: false,
+          unmergeList: new Set(),
+          unmergeState
+        });
+      });
+
+      it('resets busy state and has same items checked after error when trying to merge', async function() {
+        Client.clearMockResponses();
+        Client.addMockResponse({
+          method: 'DELETE',
+          url: '/issues/groupId/hashes/',
+          statusCode: 500,
+          body: {}
+        });
+
+        GroupingStore.onToggleUnmerge('2');
+        unmergeList.add('1');
+        unmergeState.set('1', {checked: true, busy: false});
+
+        let promise = GroupingStore.onUnmerge({
+          groupId: 'groupId'
+        });
+
+        expect(trigger).toHaveBeenCalledWith({
+          unmergeDisabled: true,
+          unmergeList,
+          unmergeState
+        });
+
+        await promise;
+
+        expect(trigger).toHaveBeenLastCalledWith({
+          unmergeDisabled: false,
+          unmergeList,
+          unmergeState
+        });
+      });
+    });
+  });
+});
diff --git a/tests/js/spec/views/__snapshots__/groupGroupingView.spec.jsx.snap b/tests/js/spec/views/__snapshots__/groupGroupingView.spec.jsx.snap
new file mode 100644
index 0000000000..f0bd1057c6
--- /dev/null
+++ b/tests/js/spec/views/__snapshots__/groupGroupingView.spec.jsx.snap
@@ -0,0 +1,93 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`Issues Grouping View renders initially with loading component 1`] = `
+<div>
+  <div
+    className="alert alert-block alert-warning"
+  >
+    <strong>
+      Warning
+      :
+    </strong>
+     
+    This is an experimental feature. Data may not be immediately available while we process the unmerge.
+  </div>
+  <LoadingIndicator />
+</div>
+`;
+
+exports[`Issues Grouping View renders with mocked data 1`] = `
+<GroupGroupingView
+  location={Object {}}
+  params={
+    Object {
+      "groupId": "groupId",
+      "orgId": "orgId",
+      "projectId": "projectId",
+    }
+  }
+>
+  <div>
+    <div
+      className="alert alert-block alert-warning"
+    >
+      <strong>
+        Warning
+        :
+      </strong>
+       
+      This is an experimental feature. Data may not be immediately available while we process the unmerge.
+    </div>
+    <LoadingIndicator>
+      <div
+        className="loading"
+      >
+        <div
+          className="loading-indicator"
+        />
+        <div
+          className="loading-message"
+        />
+      </div>
+    </LoadingIndicator>
+  </div>
+</GroupGroupingView>
+`;
+
+exports[`Issues Grouping View renders with mocked data 2`] = `
+<GroupGroupingView
+  location={Object {}}
+  params={
+    Object {
+      "groupId": "groupId",
+      "orgId": "orgId",
+      "projectId": "projectId",
+    }
+  }
+>
+  <div>
+    <div
+      className="alert alert-block alert-warning"
+    >
+      <strong>
+        Warning
+        :
+      </strong>
+       
+      This is an experimental feature. Data may not be immediately available while we process the unmerge.
+    </div>
+    <LoadingIndicator>
+      <div
+        className="loading"
+      >
+        <div
+          className="loading-indicator"
+        />
+        <div
+          className="loading-message"
+        />
+      </div>
+    </LoadingIndicator>
+  </div>
+</GroupGroupingView>
+`;
diff --git a/tests/js/spec/views/groupGroupingView.spec.jsx b/tests/js/spec/views/groupGroupingView.spec.jsx
new file mode 100644
index 0000000000..95b3938f68
--- /dev/null
+++ b/tests/js/spec/views/groupGroupingView.spec.jsx
@@ -0,0 +1,319 @@
+/* eslint-env jest */
+import React from 'react';
+import {mount, shallow} from 'enzyme';
+import toJson from 'enzyme-to-json';
+
+import GroupGroupingView from 'app/views/groupGrouping/groupGroupingView';
+import {Client} from 'app/api';
+
+jest.mock('app/api');
+jest.mock('app/mixins/projectState', () => {
+  return {
+    getFeatures: () => new Set(['callsigns'])
+  };
+});
+
+const mockData = {
+  similar: [
+    [
+      {
+        lastSeen: '2017-07-25T02:22:19Z',
+        numComments: 0,
+        userCount: 1,
+        culprit: 'Constructor.onGroupingUpdate(app/views/groupGrouping/groupingMergedList)',
+        title: 'ReferenceError: unmergedList is not defined',
+        id: '274',
+        assignedTo: null,
+        logger: 'javascript',
+        type: 'error',
+        annotations: [],
+        metadata: {type: 'ReferenceError', value: 'unmergedList is not defined'},
+        status: 'unresolved',
+        subscriptionDetails: null,
+        isPublic: false,
+        hasSeen: false,
+        shortId: 'INTERNAL-4K',
+        shareId: '312e323734',
+        firstSeen: '2017-07-25T02:21:52Z',
+        count: '2',
+        permalink: 'http://localhost:8000/sentry/internal/issues/274/',
+        level: 'error',
+        isSubscribed: true,
+        isBookmarked: false,
+        project: {name: 'Internal', slug: 'internal'},
+        statusDetails: {}
+      },
+      {'exception:stacktrace:pairs': 0.375}
+    ],
+    [
+      {
+        lastSeen: '2017-07-25T02:20:35Z',
+        numComments: 0,
+        userCount: 1,
+        culprit: 'size(app/views/groupGrouping/groupingMergedList)',
+        title: "TypeError: Cannot read property 'size' of undefined",
+        id: '275',
+        assignedTo: null,
+        logger: 'javascript',
+        type: 'error',
+        annotations: [],
+        metadata: {type: 'TypeError', value: "Cannot read property 'size' of undefined"},
+        status: 'unresolved',
+        subscriptionDetails: null,
+        isPublic: false,
+        hasSeen: true,
+        shortId: 'INTERNAL-4M',
+        shareId: '312e323735',
+        firstSeen: '2017-07-25T02:20:35Z',
+        count: '1',
+        permalink: 'http://localhost:8000/sentry/internal/issues/275/',
+        level: 'error',
+        isSubscribed: true,
+        isBookmarked: false,
+        project: {name: 'Internal', slug: 'internal'},
+        statusDetails: {}
+      },
+      {'exception:stacktrace:pairs': 0.375}
+    ],
+    [
+      {
+        lastSeen: '2017-07-24T23:41:44Z',
+        numComments: 0,
+        userCount: 3,
+        culprit: 'length(app/views/groupGrouping/groupGroupingView)',
+        title: "TypeError: Cannot read property 'length' of undefined",
+        id: '271',
+        assignedTo: null,
+        logger: 'javascript',
+        type: 'error',
+        annotations: [],
+        metadata: {
+          type: 'TypeError',
+          value: "Cannot read property 'length' of undefined"
+        },
+        status: 'unresolved',
+        subscriptionDetails: null,
+        isPublic: false,
+        hasSeen: false,
+        shortId: 'INTERNAL-4G',
+        shareId: '312e323731',
+        firstSeen: '2017-07-10T18:32:43Z',
+        count: '90',
+        permalink: 'http://localhost:8000/sentry/internal/issues/271/',
+        level: 'error',
+        isSubscribed: true,
+        isBookmarked: false,
+        project: {name: 'Internal', slug: 'internal'},
+        statusDetails: {}
+      },
+      {'exception:stacktrace:pairs': 0.01264}
+    ],
+    [
+      {
+        lastSeen: '2017-07-25T23:21:19Z',
+        numComments: 0,
+        userCount: 1,
+        culprit: 'stale(app/views/groupDetails)',
+        title: "TypeError: Cannot read property 'stale' of undefined",
+        id: '216',
+        assignedTo: {
+          username: 'billy@sentry.io',
+          isManaged: false,
+          lastActive: '2017-07-26T18:28:19.391Z',
+          identities: [],
+          id: '1',
+          isActive: true,
+          has2fa: false,
+          name: 'billy@sentry.io',
+          avatarUrl: 'https://secure.gravatar.com/avatar/7b544e8eb9d08ed777be5aa82121155a?s=32&d=mm',
+          dateJoined: '2017-06-26T21:02:13.264Z',
+          emails: [{is_verified: false, id: '1', email: 'billy@sentry.io'}],
+          avatar: {avatarUuid: null, avatarType: 'letter_avatar'},
+          lastLogin: '2017-07-25T01:00:50.473Z',
+          email: 'billy@sentry.io'
+        },
+        logger: 'javascript',
+        type: 'error',
+        annotations: [],
+        metadata: {type: 'TypeError', value: "Cannot read property 'stale' of undefined"},
+        status: 'unresolved',
+        subscriptionDetails: {reason: 'changed_status'},
+        isPublic: false,
+        hasSeen: true,
+        shortId: 'INTERNAL-2S',
+        shareId: '312e323136',
+        firstSeen: '2017-07-25T02:20:35Z',
+        count: '15',
+        permalink: 'http://localhost:8000/sentry/internal/issues/216/',
+        level: 'error',
+        isSubscribed: true,
+        isBookmarked: false,
+        project: {name: 'Internal', slug: 'internal'},
+        statusDetails: {}
+      },
+      {
+        'exception:stacktrace:application-chunks': 0.000235,
+        'exception:stacktrace:pairs': 0.001488
+      }
+    ]
+  ],
+  merged: [
+    {
+      latestEvent: {
+        eventID: '807f0de4d8c246098f21f8e0f1684f3d',
+        packages: {},
+        dist: null,
+        tags: [
+          {value: 'Chrome 59.0.3071', key: 'browser'},
+          {value: 'Chrome', key: 'browser.name'},
+          {value: 'error', key: 'level'},
+          {value: 'javascript', key: 'logger'},
+          {value: 'Mac OS X 10.12.5', key: 'os'},
+          {value: 'Mac OS X', key: 'os.name'},
+          {value: 'd5241c9d9d2bcda918c7af72f07cea1e39a096ac', key: 'release'},
+          {
+            value: 'app/components/assigneeSelector in assignedTo',
+            key: 'transaction'
+          },
+          {
+            value: 'http://localhost:8000/sentry/internal/issues/227/grouping/',
+            key: 'url'
+          },
+          {value: 'id:1', key: 'user'}
+        ],
+        contexts: {
+          os: {version: '10.12.5', type: 'os', name: 'Mac OS X'},
+          browser: {version: '59.0.3071', type: 'browser', name: 'Chrome'}
+        },
+        dateReceived: '2017-07-26T00:34:20Z',
+        dateCreated: '2017-07-26T00:34:20Z',
+        fingerprints: [
+          '2c4887696f708c476a81ce4e834c4b02',
+          'e05da55328a860b21f62e371f0a7507d'
+        ],
+        metadata: {
+          type: 'TypeError',
+          value: "Cannot read property 'assignedTo' of undefined"
+        },
+        groupID: '268',
+        platform: 'javascript',
+        errors: [],
+        user: {ip_address: '127.0.0.1', email: 'billy@sentry.io', id: '1'},
+        context: {'session:duration': 46363},
+        entries: [],
+        message: "TypeError Cannot read property 'assignedTo' of undefined app/components/assigneeSelector in assignedTo",
+        sdk: {
+          clientIP: '127.0.0.1',
+          version: '3.16.1',
+          name: 'raven-js',
+          upstream: {
+            url: 'https://docs.sentry.io/clients/javascript/',
+            isNewer: false,
+            name: 'raven-js'
+          }
+        },
+        type: 'error',
+        id: '904',
+        size: 21896
+      },
+      state: 'unlocked',
+      id: '2c4887696f708c476a81ce4e834c4b02'
+    },
+    {
+      latestEvent: {
+        eventID: '807f0de4d8c246098f21f8e0f1684f3d',
+        packages: {},
+        dist: null,
+        tags: [
+          {value: 'Chrome 59.0.3071', key: 'browser'},
+          {value: 'Chrome', key: 'browser.name'},
+          {value: 'error', key: 'level'},
+          {value: 'javascript', key: 'logger'},
+          {value: 'Mac OS X 10.12.5', key: 'os'},
+          {value: 'Mac OS X', key: 'os.name'},
+          {value: 'd5241c9d9d2bcda918c7af72f07cea1e39a096ac', key: 'release'},
+          {
+            value: 'app/components/assigneeSelector in assignedTo',
+            key: 'transaction'
+          },
+          {
+            value: 'http://localhost:8000/sentry/internal/issues/227/grouping/',
+            key: 'url'
+          },
+          {value: 'id:1', key: 'user'}
+        ],
+        contexts: {
+          os: {version: '10.12.5', type: 'os', name: 'Mac OS X'},
+          browser: {version: '59.0.3071', type: 'browser', name: 'Chrome'}
+        },
+        dateReceived: '2017-07-26T00:34:20Z',
+        dateCreated: '2017-07-26T00:34:20Z',
+        fingerprints: [
+          '2c4887696f708c476a81ce4e834c4b02',
+          'e05da55328a860b21f62e371f0a7507d'
+        ],
+        metadata: {
+          type: 'TypeError',
+          value: "Cannot read property 'assignedTo' of undefined"
+        },
+        groupID: '268',
+        platform: 'javascript',
+        errors: [],
+        user: {ip_address: '127.0.0.1', email: 'billy@sentry.io', id: '1'},
+        context: {'session:duration': 46363},
+        entries: [],
+        message: "TypeError Cannot read property 'assignedTo' of undefined app/components/assigneeSelector in assignedTo",
+        sdk: {
+          clientIP: '127.0.0.1',
+          version: '3.16.1',
+          name: 'raven-js',
+          upstream: {
+            url: 'https://docs.sentry.io/clients/javascript/',
+            isNewer: false,
+            name: 'raven-js'
+          }
+        },
+        type: 'error',
+        id: '904',
+        size: 21896
+      },
+      state: 'unlocked',
+      id: 'e05da55328a860b21f62e371f0a7507d'
+    }
+  ]
+};
+
+describe('Issues Grouping View', function() {
+  beforeAll(function() {
+    Client.addMockResponse({
+      url: '/issues/groupId/hashes/?limit=50',
+      body: mockData.merged
+    });
+    Client.addMockResponse({
+      url: '/issues/groupId/similar/?limit=50',
+      body: mockData.similar
+    });
+  });
+
+  it('renders initially with loading component', function() {
+    let component = shallow(
+      <GroupGroupingView params={{groupId: 'groupId'}} location={{}} />
+    );
+
+    expect(toJson(component)).toMatchSnapshot();
+  });
+
+  it('renders with mocked data', function(done) {
+    let wrapper = mount(
+      <GroupGroupingView
+        params={{orgId: 'orgId', projectId: 'projectId', groupId: 'groupId'}}
+        location={{}}
+      />
+    );
+
+    wrapper.instance().componentDidUpdate = jest.fn(() => {
+      expect(toJson(wrapper)).toMatchSnapshot();
+      done();
+    });
+  });
+});

commit fdbb6bdc0fed5f607a8a6852e28238e56d8b96d8
Author: Ted Kaemming <ted@kaemming.com>
Date:   Wed Dec 2 12:39:59 2015 -0800

    Abstract script loading into something more reusable.

diff --git a/MANIFEST.in b/MANIFEST.in
index 9d0e38e339..d5ee046f75 100644
--- a/MANIFEST.in
+++ b/MANIFEST.in
@@ -4,5 +4,5 @@ recursive-include src/sentry/templates *
 recursive-include src/sentry/locale *
 recursive-include src/sentry/data *
 recursive-include src/sentry/static/sentry *
-global-include *.lua
+recursive-include src/sentry/scripts *.lua
 global-exclude *~
diff --git a/src/sentry/digests/backends/redis.py b/src/sentry/digests/backends/redis.py
index 4182c452f3..0424f85ff9 100644
--- a/src/sentry/digests/backends/redis.py
+++ b/src/sentry/digests/backends/redis.py
@@ -5,10 +5,8 @@ import logging
 import random
 import time
 from contextlib import contextmanager
-from pkg_resources import resource_string
 
 from django.conf import settings
-from redis.client import Script
 from redis.exceptions import (
     ResponseError,
     WatchError,
@@ -22,6 +20,7 @@ from sentry.digests.backends.base import Backend
 from sentry.utils.cache import Lock
 from sentry.utils.redis import (
     check_cluster_versions,
+    load_script,
     make_rb_cluster as _make_rb_cluster,
 )
 from sentry.utils.versioning import Version
@@ -72,13 +71,8 @@ def make_record_key(timeline_key, record):
     return '{0}:{1}:{2}'.format(timeline_key, TIMELINE_RECORD_PATH_COMPONENT, record)
 
 
-def load_script(name):
-    path = '/'.join(__name__.split('.')[1:-1] + [name])
-    return Script(None, resource_string('sentry', path))
-
-
-ensure_timeline_scheduled = load_script('ensure_timeline_scheduled.lua')
-truncate_timeline = load_script('truncate_timeline.lua')
+ensure_timeline_scheduled = load_script('digests/ensure_timeline_scheduled.lua')
+truncate_timeline = load_script('digests/truncate_timeline.lua')
 
 
 class RedisBackend(Backend):
@@ -189,6 +183,7 @@ class RedisBackend(Backend):
             pipeline.expire(timeline_key, self.ttl)
 
             ensure_timeline_scheduled(
+                pipeline,
                 (
                     make_schedule_key(self.namespace, SCHEDULE_STATE_WAITING),
                     make_schedule_key(self.namespace, SCHEDULE_STATE_READY),
@@ -200,15 +195,14 @@ class RedisBackend(Backend):
                     increment_delay,
                     maximum_delay,
                 ),
-                pipeline,
             )
 
             should_truncate = random.random() < self.truncation_chance
             if should_truncate:
                 truncate_timeline(
+                    pipeline,
                     (timeline_key,),
                     (self.capacity, timeline_key),
-                    pipeline,
                 )
 
             results = pipeline.execute()
@@ -502,8 +496,8 @@ class RedisBackend(Backend):
         connection = self.cluster.get_local_client_for_key(timeline_key)
         with Lock(timeline_key, nowait=True, timeout=30), \
                 connection.pipeline() as pipeline:
-            truncate_timeline((timeline_key,), (0, timeline_key), pipeline)
-            truncate_timeline((make_digest_key(timeline_key),), (0, timeline_key), pipeline)
+            truncate_timeline(pipeline, (timeline_key,), (0, timeline_key))
+            truncate_timeline(pipeline, (make_digest_key(timeline_key),), (0, timeline_key))
             pipeline.delete(make_last_processed_timestamp_key(timeline_key))
             pipeline.zrem(make_schedule_key(self.namespace, SCHEDULE_STATE_READY), key)
             pipeline.zrem(make_schedule_key(self.namespace, SCHEDULE_STATE_WAITING), key)
diff --git a/src/sentry/digests/backends/ensure_timeline_scheduled.lua b/src/sentry/scripts/digests/ensure_timeline_scheduled.lua
similarity index 100%
rename from src/sentry/digests/backends/ensure_timeline_scheduled.lua
rename to src/sentry/scripts/digests/ensure_timeline_scheduled.lua
diff --git a/src/sentry/digests/backends/truncate_timeline.lua b/src/sentry/scripts/digests/truncate_timeline.lua
similarity index 100%
rename from src/sentry/digests/backends/truncate_timeline.lua
rename to src/sentry/scripts/digests/truncate_timeline.lua
diff --git a/src/sentry/utils/redis.py b/src/sentry/utils/redis.py
index 71863eef65..7bcc587c59 100644
--- a/src/sentry/utils/redis.py
+++ b/src/sentry/utils/redis.py
@@ -1,9 +1,12 @@
 from __future__ import absolute_import
 
+import posixpath
+from pkg_resources import resource_string
 from threading import Lock
 
 import rb
 from redis.connection import ConnectionPool
+from redis.client import Script
 
 from sentry.exceptions import InvalidConfiguration
 from sentry.utils.versioning import (
@@ -63,3 +66,23 @@ def check_cluster_versions(cluster, required, recommended=Version((3, 0, 4)), la
         required,
         recommended,
     )
+
+
+def load_script(path):
+    script = Script(None, resource_string('sentry', posixpath.join('scripts', path)))
+
+    # This changes the argument order of the ``Script.__call__`` method to
+    # encourage using the script is with a specific Redis client when dealing
+    # with clusters, rather than implicitly using the first client that the
+    # script was registered with.
+    def call_script(client, keys, args):
+        """
+        Executes {!r} as a Lua script on a Redis server.
+
+        Takes the client to execute the script on as the first argument,
+        followed by the values that will be provided as ``KEYS`` and ``ARGV``
+        to the script as two sequence arguments.
+        """.format(path)
+        return script(keys, args, client)
+
+    return call_script
diff --git a/tests/sentry/digests/backends/test_redis.py b/tests/sentry/digests/backends/test_redis.py
index 6879ac0a96..02e0898ddb 100644
--- a/tests/sentry/digests/backends/test_redis.py
+++ b/tests/sentry/digests/backends/test_redis.py
@@ -69,13 +69,13 @@ class RedisScriptTestCase(BaseRedisBackendTestCase):
         # The first addition should cause the timeline to be added to the ready set.
         with self.assertChanges(ready_set_size, before=0, after=1), \
                 self.assertChanges(timeline_score_in_ready_set, before=None, after=timestamp):
-            assert ensure_timeline_scheduled(keys, (timeline, timestamp, 1, 10), client) == 1
+            assert ensure_timeline_scheduled(client, keys, (timeline, timestamp, 1, 10)) == 1
 
         # Adding it again with a timestamp in the future should not change the schedule time.
         with self.assertDoesNotChange(waiting_set_size), \
                 self.assertDoesNotChange(ready_set_size), \
                 self.assertDoesNotChange(timeline_score_in_ready_set):
-            assert ensure_timeline_scheduled(keys, (timeline, timestamp + 50, 1, 10), client) is None
+            assert ensure_timeline_scheduled(client, keys, (timeline, timestamp + 50, 1, 10)) is None
 
         # Move the timeline from the ready set to the waiting set.
         client.zrem('ready', timeline)
@@ -85,12 +85,12 @@ class RedisScriptTestCase(BaseRedisBackendTestCase):
         increment = 1
         with self.assertDoesNotChange(waiting_set_size), \
                 self.assertChanges(timeline_score_in_waiting_set, before=timestamp, after=timestamp + increment):
-            assert ensure_timeline_scheduled(keys, (timeline, timestamp, increment, 10), client) is None
+            assert ensure_timeline_scheduled(client, keys, (timeline, timestamp, increment, 10)) is None
 
         # Make sure the schedule respects the maximum value.
         with self.assertDoesNotChange(waiting_set_size), \
                 self.assertChanges(timeline_score_in_waiting_set, before=timestamp + 1, after=timestamp):
-            assert ensure_timeline_scheduled(keys, (timeline, timestamp, increment, 0), client) is None
+            assert ensure_timeline_scheduled(client, keys, (timeline, timestamp, increment, 0)) is None
 
         # Test to ensure a missing last processed timestamp can be handled
         # correctly (chooses minimum of schedule value and record timestamp.)
@@ -98,11 +98,11 @@ class RedisScriptTestCase(BaseRedisBackendTestCase):
         client.delete('last-processed')
         with self.assertDoesNotChange(waiting_set_size), \
                 self.assertDoesNotChange(timeline_score_in_waiting_set):
-            assert ensure_timeline_scheduled(keys, (timeline, timestamp + 100, increment, 10), client) is None
+            assert ensure_timeline_scheduled(client, keys, (timeline, timestamp + 100, increment, 10)) is None
 
         with self.assertDoesNotChange(waiting_set_size), \
                 self.assertChanges(timeline_score_in_waiting_set, before=timestamp, after=timestamp - 100):
-            assert ensure_timeline_scheduled(keys, (timeline, timestamp - 100, increment, 10), client) is None
+            assert ensure_timeline_scheduled(client, keys, (timeline, timestamp - 100, increment, 10)) is None
 
     def test_truncate_timeline_script(self):
         client = StrictRedis(db=9)
@@ -116,7 +116,7 @@ class RedisScriptTestCase(BaseRedisBackendTestCase):
             client.set(make_record_key(timeline, record.key), 'data')
 
         with self.assertChanges(lambda: client.zcard(timeline), before=10, after=5):
-            truncate_timeline((timeline,), (5, timeline), client)
+            truncate_timeline(client, (timeline,), (5, timeline))
 
             # Ensure the early records don't exist.
             for record in records[:5]:

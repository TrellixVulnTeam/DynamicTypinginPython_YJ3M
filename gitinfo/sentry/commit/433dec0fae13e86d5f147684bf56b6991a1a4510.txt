commit 433dec0fae13e86d5f147684bf56b6991a1a4510
Author: Jan Michael Auer <jan.auer@sentry.io>
Date:   Fri Jun 26 18:40:43 2020 +0200

    feat(store): Track ACCEPTED outcomes for attachments (#19567)
    
    Tracks `ACCEPTED` outcomes for attachments. This allows billing
    consumers to record usage for transactions. Attachments that have been
    marked as `rate_limited` by Relay will be skipped. Quota refunds will be
    handled in a follow-up.

diff --git a/src/sentry/event_manager.py b/src/sentry/event_manager.py
index feca88150d..4df9dbe52a 100644
--- a/src/sentry/event_manager.py
+++ b/src/sentry/event_manager.py
@@ -646,7 +646,7 @@ class EventManager(object):
 
         # Do this last to ensure signals get emitted even if connection to the
         # file store breaks temporarily.
-        save_attachments(attachments, job["event"])
+        save_attachments(attachments, job)
 
         metric_tags = {"from_relay": "_relay_processed" in job["data"]}
 
@@ -1286,12 +1286,18 @@ def get_attachments(cache_key, event):
     stored_reports = cached_reports
 
     for attachment in attachments:
+        # Relay can mark attachments as ``rate_limited``, in which case they
+        # should not be saved. They where only retained to allow event
+        # processing.
+        if attachment.rate_limited:
+            continue
+
         # If the attachment is a crash report (e.g. minidump), we need to honor
         # the store_crash_reports setting. Otherwise, we assume that the client
         # has already verified PII and just store the attachment.
         if attachment.type in CRASH_REPORT_TYPES:
             if crashreports_exceeded(stored_reports, max_crashreports):
-                continue
+                continue  # TODO: Refund quota
             stored_reports += 1
 
         filtered.append(attachment)
@@ -1306,13 +1312,15 @@ def get_attachments(cache_key, event):
     return filtered
 
 
-def save_attachments(attachments, event):
+def save_attachments(attachments, job):
     """
     Persists cached event attachments into the file store.
 
     :param attachments: A filtered list of attachments to save.
-    :param event:       The event model instance.
+    :param job:         The job context container.
     """
+    event = job["event"]
+
     for attachment in attachments:
         file = File.objects.create(
             name=attachment.name,
@@ -1329,6 +1337,18 @@ def save_attachments(attachments, event):
             file=file,
         )
 
+        track_outcome(
+            org_id=event.project.organization_id,
+            project_id=job["project_id"],
+            key_id=job["key_id"],
+            outcome=Outcome.ACCEPTED,
+            reason=None,
+            timestamp=to_datetime(job["start_time"]),
+            event_id=event.event_id,
+            category=DataCategory.ATTACHMENT,
+            quantity=len(attachment.data) or 1,
+        )
+
 
 def _find_hashes(project, hash_list):
     return map(
diff --git a/tests/sentry/event_manager/test_event_manager.py b/tests/sentry/event_manager/test_event_manager.py
index 4a2310f1cf..d609121e0f 100644
--- a/tests/sentry/event_manager/test_event_manager.py
+++ b/tests/sentry/event_manager/test_event_manager.py
@@ -14,7 +14,8 @@ from time import time
 
 from sentry import nodestore
 from sentry.app import tsdb
-from sentry.constants import MAX_VERSION_LENGTH
+from sentry.attachments import attachment_cache, CachedAttachment
+from sentry.constants import DataCategory, MAX_VERSION_LENGTH
 from sentry.eventstore.models import Event
 from sentry.event_manager import HashDiscarded, EventManager, EventUser
 from sentry.grouping.utils import hash_from_values
@@ -36,6 +37,7 @@ from sentry.models import (
     OrganizationIntegration,
     UserReport,
 )
+from sentry.utils.cache import cache_key_for_event
 from sentry.utils.outcomes import Outcome
 from sentry.testutils import assert_mock_called_once_with_partial, TestCase
 from sentry.utils.data_filters import FilterStatKeys
@@ -1048,7 +1050,37 @@ class EventManagerTest(TestCase):
         with mock.patch("sentry.event_manager.track_outcome", mock_track_outcome):
             manager.save(1)
 
-        assert_mock_called_once_with_partial(mock_track_outcome, outcome=Outcome.ACCEPTED)
+        assert_mock_called_once_with_partial(
+            mock_track_outcome, outcome=Outcome.ACCEPTED, category=DataCategory.DEFAULT
+        )
+
+    def test_attachment_outcomes(self):
+        manager = EventManager(make_event(message="foo"), project=self.project)
+        manager.normalize()
+
+        a1 = CachedAttachment(name="a1", data=b"hello")
+        a2 = CachedAttachment(name="a2", data=b"limited", rate_limited=True)
+        a3 = CachedAttachment(name="a3", data=b"world")
+
+        cache_key = cache_key_for_event(manager.get_data())
+        attachment_cache.set(cache_key, attachments=[a1, a2, a3])
+
+        mock_track_outcome = mock.Mock()
+        with mock.patch("sentry.event_manager.track_outcome", mock_track_outcome):
+            with self.feature("organizations:event-attachments"):
+                manager.save(1, cache_key=cache_key)
+
+        assert mock_track_outcome.call_count == 3
+
+        for o in mock_track_outcome.mock_calls:
+            assert o.kwargs["outcome"] == Outcome.ACCEPTED
+
+        for o in mock_track_outcome.mock_calls[:2]:
+            assert o.kwargs["category"] == DataCategory.ATTACHMENT
+            assert o.kwargs["quantity"] == 5
+
+        final = mock_track_outcome.mock_calls[2]
+        assert final.kwargs["category"] == DataCategory.DEFAULT
 
     def test_checksum_rehashed(self):
         checksum = "invalid checksum hash"

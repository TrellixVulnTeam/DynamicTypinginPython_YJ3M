commit 16a9e2ada17902a3c0e9d18d00f3ae9e6026f832
Author: David Cramer <dcramer@gmail.com>
Date:   Mon Oct 5 13:34:00 2015 -0700

    Correct tag handling in event pipeline
    
    - Fix issue which could have caused duplicate tags from plugins
    - Process user tag synchronously (fixes GH-2093)

diff --git a/src/sentry/event_manager.py b/src/sentry/event_manager.py
index e411fff954..37d70784b1 100644
--- a/src/sentry/event_manager.py
+++ b/src/sentry/event_manager.py
@@ -27,8 +27,8 @@ from sentry.constants import (
 )
 from sentry.interfaces.base import get_interface
 from sentry.models import (
-    Activity, Event, EventMapping, Group, GroupHash, GroupStatus, Project,
-    Release, UserReport
+    Activity, Event, EventMapping, EventUser, Group, GroupHash, GroupStatus,
+    Project, Release, UserReport
 )
 from sentry.plugins import plugins
 from sentry.signals import regression_signal
@@ -380,6 +380,11 @@ class EventManager(object):
                                       _with_transaction=False)
             if added_tags:
                 tags.extend(added_tags)
+
+        event_user = self._get_event_user(project, data)
+        if event_user:
+            tags.append(('sentry:user', event_user.tag_value))
+
         # XXX(dcramer): we're relying on mutation of the data object to ensure
         # this propagates into Event
         data['tags'] = tags
@@ -488,6 +493,30 @@ class EventManager(object):
 
         return event
 
+    def _get_event_user(self, project, data):
+        user_data = data.get('sentry.interfaces.User')
+        if not user_data:
+            return
+
+        euser = EventUser(
+            project=project,
+            ident=user_data.get('id'),
+            email=user_data.get('email'),
+            username=user_data.get('username'),
+            ip_address=user_data.get('ip_address'),
+        )
+
+        if not euser.tag_value:
+            return
+
+        try:
+            with transaction.atomic():
+                euser.save()
+        except IntegrityError:
+            return
+
+        return euser
+
     def _find_hashes(self, project, hash_list):
         matches = []
         for hash in hash_list:
diff --git a/src/sentry/tasks/post_process.py b/src/sentry/tasks/post_process.py
index b4d482720a..99358a7293 100644
--- a/src/sentry/tasks/post_process.py
+++ b/src/sentry/tasks/post_process.py
@@ -49,10 +49,6 @@ def post_process_group(event, is_new, is_regression, is_sample, **kwargs):
 
     _capture_stats(event, is_new)
 
-    record_affected_user.delay(event=event)
-
-    record_additional_tags(event=event)
-
     rp = RuleProcessor(event, is_new, is_regression, is_sample)
     # TODO(dcramer): ideally this would fanout, but serializing giant
     # objects back and forth isn't super efficient
diff --git a/tests/sentry/tasks/post_process/tests.py b/tests/sentry/tasks/post_process/tests.py
index 5af3117df3..0632925e31 100644
--- a/tests/sentry/tasks/post_process/tests.py
+++ b/tests/sentry/tasks/post_process/tests.py
@@ -4,31 +4,11 @@ from __future__ import absolute_import
 
 from mock import Mock, patch
 
-from sentry.models import EventUser, Group
 from sentry.testutils import TestCase
-from sentry.tasks.post_process import (
-    post_process_group, record_affected_user, record_additional_tags
-)
+from sentry.tasks.post_process import post_process_group
 
 
 class PostProcessGroupTest(TestCase):
-    @patch('sentry.tasks.post_process.record_affected_user')
-    @patch('sentry.rules.processor.RuleProcessor.apply', Mock(return_value=[]))
-    def test_record_affected_user(self, mock_record_affected_user):
-        group = self.create_group(project=self.project)
-        event = self.create_event(group=group)
-
-        post_process_group(
-            event=event,
-            is_new=True,
-            is_regression=False,
-            is_sample=False,
-        )
-
-        mock_record_affected_user.delay.assert_called_once_with(
-            event=event,
-        )
-
     @patch('sentry.tasks.post_process.record_affected_user', Mock())
     @patch('sentry.rules.processor.RuleProcessor')
     def test_rule_processor(self, mock_processor):
@@ -53,40 +33,3 @@ class PostProcessGroupTest(TestCase):
         mock_processor.return_value.apply.assert_called_once_with()
 
         mock_callback.assert_called_once_with(event, mock_futures)
-
-
-class RecordAffectedUserTest(TestCase):
-    def test_simple(self):
-        event = Group.objects.from_kwargs(1, message='foo', **{
-            'sentry.interfaces.User': {
-                'email': 'foo@example.com',
-            },
-        })
-
-        with patch.object(Group.objects, 'add_tags') as add_tags:
-            record_affected_user(event=event)
-
-            add_tags.assert_called_once_with(event.group, [
-                ('sentry:user', 'email:foo@example.com')
-            ])
-
-        assert EventUser.objects.filter(
-            project=1,
-            email='foo@example.com',
-        ).exists()
-
-
-class RecordAdditionalTagsTest(TestCase):
-    def test_simple(self):
-        # TODO(dcramer): this test ideally would actually test that tags get
-        # added
-        event = Group.objects.from_kwargs(1, message='foo', **{
-            'sentry.interfaces.User': {
-                'email': 'foo@example.com',
-            },
-        })
-
-        with patch.object(Group.objects, 'add_tags') as add_tags:
-            record_additional_tags(event=event)
-
-            assert not add_tags.called

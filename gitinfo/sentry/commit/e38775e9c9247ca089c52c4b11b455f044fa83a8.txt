commit e38775e9c9247ca089c52c4b11b455f044fa83a8
Author: Lauryn Brown <lauryndbrown@gmail.com>
Date:   Fri Jun 7 11:44:52 2019 -0700

    feat(event-search): Add aggregate comparisons to events v2 endpoint (#13510)
    
    * Added having functionality for events v2 endpoint
    
    * reverted change to org events v1
    
    * changed test to show that both conditions apply
    
    * caught assertion error.
    
    * Changed format of aggregate comparison queries
    
    * removed malformed input test
    
    * Added test to check that non field aggregate is added to the aggregations
    
    * Added additional tests to aggregation comparisions
    
    * fixed spelling error.

diff --git a/src/sentry/api/bases/organization_events.py b/src/sentry/api/bases/organization_events.py
index 2a5c863bb7..cee038effe 100644
--- a/src/sentry/api/bases/organization_events.py
+++ b/src/sentry/api/bases/organization_events.py
@@ -93,6 +93,22 @@ class OrganizationEventsEndpointBase(OrganizationEndpoint):
 
             snuba_args['selected_columns'] = fields
 
+        conditions = snuba_args.get('conditions')
+        # Add special fields to aggregations if missing
+        if conditions:
+            for condition in conditions:
+                field = condition[0]
+                if isinstance(field, (list, tuple)):
+                    continue
+                if field in SPECIAL_FIELDS:
+                    aggregation_included = False
+                    for aggregate in aggregations:
+                        if aggregate[2] == field:
+                            aggregation_included = True
+                            break
+                    if not aggregation_included:
+                        aggregations.extend(deepcopy(SPECIAL_FIELDS[field]).get('aggregations', []))
+
         if aggregations:
             snuba_args['aggregations'] = aggregations
 
diff --git a/src/sentry/api/event_search.py b/src/sentry/api/event_search.py
index 0f6af12cc7..c37246fff0 100644
--- a/src/sentry/api/event_search.py
+++ b/src/sentry/api/event_search.py
@@ -141,6 +141,9 @@ SEARCH_MAP = dict({
     'first_seen': 'first_seen',
     'last_seen': 'last_seen',
     'times_seen': 'times_seen',
+    # OrganizationEvents aggregations
+    'event_count': 'event_count',
+    'user_count': 'user_count',
 }, **SENTRY_SNUBA_MAP)
 no_conversion = set(['project_id', 'start', 'end'])
 
@@ -209,6 +212,8 @@ class SearchVisitor(NodeVisitor):
         'device.battery_level', 'device.charging', 'device.online',
         'device.simulator', 'error.handled', 'issue.id', 'stack.colno',
         'stack.in_app', 'stack.lineno', 'stack.stack_level',
+        # OrganizationEvents aggregations
+        'event_count', 'user_count',
 
     ])
     date_keys = set([
diff --git a/src/sentry/utils/snuba.py b/src/sentry/utils/snuba.py
index a5c10b267e..fa26ac7bc5 100644
--- a/src/sentry/utils/snuba.py
+++ b/src/sentry/utils/snuba.py
@@ -395,6 +395,7 @@ def transform_aliases_and_query(skip_conditions=False, **kwargs):
     arrayjoin = kwargs.get('arrayjoin')
     rollup = kwargs.get('rollup')
     orderby = kwargs.get('orderby')
+    having = kwargs.get('having', [])
 
     if selected_columns:
         for (idx, col) in enumerate(selected_columns):
@@ -441,8 +442,18 @@ def transform_aliases_and_query(skip_conditions=False, **kwargs):
         return cond
 
     if conditions:
-        kwargs['conditions'] = ([handle_condition(condition) for condition in conditions]
-                                if skip_conditions is False else conditions)
+        kwargs['conditions'] = []
+        for condition in conditions:
+            field = condition[0]
+            if not isinstance(field, (list, tuple)) and field in derived_columns:
+                having.append(condition)
+            elif skip_conditions:
+                kwargs['conditions'].append(condition)
+            else:
+                kwargs['conditions'].append(handle_condition(condition))
+
+    if having:
+        kwargs['having'] = having
 
     if orderby:
         order_by_column = orderby.lstrip('-')
diff --git a/tests/snuba/api/endpoints/test_organization_events_v2.py b/tests/snuba/api/endpoints/test_organization_events_v2.py
index 5298de36ba..3759f3b704 100644
--- a/tests/snuba/api/endpoints/test_organization_events_v2.py
+++ b/tests/snuba/api/endpoints/test_organization_events_v2.py
@@ -259,3 +259,235 @@ class OrganizationEventsV2EndpointTest(OrganizationEventsTestBase):
         assert response.data[1]['issue.id'] == groups[1].id
         assert response.data[1]['event_count'] == 2
         assert response.data[1]['user_count'] == 2
+
+    def test_aggregation_comparison(self):
+        self.login_as(user=self.user)
+        project = self.create_project()
+        self.store_event(
+            data={
+                'event_id': 'a' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_1'],
+                'user': {
+                    'email': 'foo@example.com',
+                },
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'b' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_2'],
+                'user': {
+                    'email': 'foo@example.com',
+                },
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'c' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_2'],
+                'user': {
+                    'email': 'bar@example.com',
+                },
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'd' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_3'],
+                'user': {
+                    'email': 'bar@example.com',
+                },
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'e' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_3'],
+                'user': {
+                    'email': 'bar@example.com',
+                },
+            },
+            project_id=project.id,
+        )
+
+        groups = Group.objects.all()
+
+        with self.feature('organizations:events-v2'):
+            response = self.client.get(
+                self.url,
+                format='json',
+                data={
+                    'field': ['issue_title', 'event_count', 'user_count'],
+                    'query': ['event_count:>1 user_count:>1'],
+                    'groupby': ['issue.id', 'project.id'],
+                    'orderby': 'issue.id'
+                },
+            )
+
+        assert response.status_code == 200, response.content
+
+        assert len(response.data) == 1
+        assert response.data[0]['issue.id'] == groups[1].id
+        assert response.data[0]['event_count'] == 2
+        assert response.data[0]['user_count'] == 2
+
+    def test_aggregation_comparison_not_displayed(self):
+        self.login_as(user=self.user)
+        project = self.create_project()
+        self.store_event(
+            data={
+                'event_id': 'a' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_1'],
+                'user': {
+                    'email': 'foo@example.com',
+                },
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'b' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_2'],
+                'user': {
+                    'email': 'foo@example.com',
+                },
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'c' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_2'],
+                'user': {
+                    'email': 'bar@example.com',
+                },
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'd' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_3'],
+                'user': {
+                    'email': 'bar@example.com',
+                },
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'e' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_3'],
+                'user': {
+                    'email': 'bar@example.com',
+                },
+            },
+            project_id=project.id,
+        )
+
+        groups = Group.objects.all()
+
+        with self.feature('organizations:events-v2'):
+            response = self.client.get(
+                self.url,
+                format='json',
+                data={
+                    'field': ['issue_title', 'event_count'],
+                    'query': ['event_count:>1 user_count:>1'],
+                    'groupby': ['issue.id', 'project.id'],
+                    'orderby': 'issue.id'
+                },
+            )
+
+        assert response.status_code == 200, response.content
+
+        assert len(response.data) == 1
+        assert response.data[0]['issue.id'] == groups[1].id
+        assert response.data[0]['event_count'] == 2
+        assert response.data[0]['user_count'] == 2
+
+    def test_aggregation_comparison_with_conditions(self):
+        self.login_as(user=self.user)
+        project = self.create_project()
+        self.store_event(
+            data={
+                'event_id': 'a' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_1'],
+                'user': {
+                    'email': 'foo@example.com',
+                },
+                'environment': 'prod',
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'b' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_2'],
+                'user': {
+                    'email': 'foo@example.com',
+                },
+                'environment': 'staging',
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'c' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_2'],
+                'user': {
+                    'email': 'foo@example.com',
+                },
+                'environment': 'prod',
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'd' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_2'],
+                'user': {
+                    'email': 'foo@example.com',
+                },
+                'environment': 'prod',
+            },
+            project_id=project.id,
+        )
+
+        groups = Group.objects.all()
+
+        with self.feature('organizations:events-v2'):
+            response = self.client.get(
+                self.url,
+                format='json',
+                data={
+                    'field': ['issue_title', 'event_count'],
+                    'query': ['event_count:>1 user.email:foo@example.com environment:prod'],
+                    'groupby': ['issue.id', 'project.id'],
+                    'orderby': 'issue.id'
+                },
+            )
+
+        assert response.status_code == 200, response.content
+
+        assert len(response.data) == 1
+        assert response.data[0]['issue.id'] == groups[1].id
+        assert response.data[0]['event_count'] == 2

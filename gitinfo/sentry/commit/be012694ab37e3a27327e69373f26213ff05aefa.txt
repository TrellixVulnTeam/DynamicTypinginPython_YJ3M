commit be012694ab37e3a27327e69373f26213ff05aefa
Author: Daniel Griesser <daniel.griesser.86@gmail.com>
Date:   Thu Feb 1 08:41:36 2018 +0100

    feat: Chunk upload endpoint (#7095)
    
    * feat: Chunk upload endpoint
    
    * fix: Remove json from request
    
    * feat: Add tests for chunk upload
    
    * ref: Use config for upload endpoint
    
    * ref: Load option on request

diff --git a/src/sentry/api/endpoints/chunk_upload.py b/src/sentry/api/endpoints/chunk_upload.py
new file mode 100644
index 0000000000..895c5bfd5f
--- /dev/null
+++ b/src/sentry/api/endpoints/chunk_upload.py
@@ -0,0 +1,64 @@
+from __future__ import absolute_import
+
+# from rest_framework.permissions import IsAuthenticated
+from rest_framework import status
+from rest_framework.response import Response
+
+from sentry import options
+from sentry.models import FileBlob
+from sentry.models.file import DEFAULT_BLOB_SIZE
+from sentry.api.base import Endpoint
+from sentry.api.bases.project import ProjectReleasePermission
+
+
+MAX_CHUNKS_PER_REQUEST = 16
+MAX_CONCURRENCY = 4
+HASH_ALGORITHM = 'sha1'
+
+
+class ChunkUploadEndpoint(Endpoint):
+    permission_classes = (ProjectReleasePermission, )
+
+    def get(self, request):
+        endpoint = options.get('system.upload-url-prefix')
+        # We fallback to default system url if config is not set
+        if len(endpoint) == 0:
+            endpoint = options.get('system.url-prefix')
+
+        return Response(
+            {
+                'url': endpoint,
+                'chunkSize': DEFAULT_BLOB_SIZE,
+                'chunksPerRequest': MAX_CHUNKS_PER_REQUEST,
+                'concurrency': MAX_CONCURRENCY,
+                'hashAlgorithm': HASH_ALGORITHM,
+            }
+        )
+
+    def post(self, request):
+        files = request.FILES.getlist('file')
+
+        if len(files) > MAX_CHUNKS_PER_REQUEST:
+            return Response({'error': 'Too many chunks'},
+                            status=status.HTTP_400_BAD_REQUEST)
+        elif len(files) == 0:
+            # No files uploaded is ok
+            return Response(status=status.HTTP_200_OK)
+
+        # Validate file size
+        checksum_list = []
+        for chunk in files:
+            if chunk._size > DEFAULT_BLOB_SIZE:
+                return Response({'error': 'Chunk size too large'},
+                                status=status.HTTP_400_BAD_REQUEST)
+            checksum_list.append(chunk._name)
+
+        for chunk in files:
+            # Here we create the actual file
+            blob = FileBlob.from_file(chunk)
+            if blob.checksum not in checksum_list:
+                # We do not clean up here since we have a cleanup job
+                return Response({'error': 'Checksum missmatch'},
+                                status=status.HTTP_400_BAD_REQUEST)
+
+        return Response(status=status.HTTP_200_OK)
diff --git a/src/sentry/api/urls.py b/src/sentry/api/urls.py
index 8fc75fc002..8c8688394e 100644
--- a/src/sentry/api/urls.py
+++ b/src/sentry/api/urls.py
@@ -10,6 +10,7 @@ from .endpoints.auth_index import AuthIndexEndpoint
 from .endpoints.authenticator_index import AuthenticatorIndexEndpoint
 from .endpoints.broadcast_index import BroadcastIndexEndpoint
 from .endpoints.catchall import CatchallEndpoint
+from .endpoints.chunk_upload import ChunkUploadEndpoint
 from .endpoints.event_details import EventDetailsEndpoint
 from .endpoints.event_apple_crash_report import EventAppleCrashReportEndpoint
 from .endpoints.group_details import GroupDetailsEndpoint
@@ -183,6 +184,12 @@ urlpatterns = patterns(
     url(r'^broadcasts/$', BroadcastIndexEndpoint.as_view(),
         name='sentry-api-0-broadcast-index'),
 
+    # Chunk upload
+    url(r'^chunk-upload/$',
+        ChunkUploadEndpoint.as_view(),
+        name='sentry-api-0-chunk-upload'
+        ),
+
     # Users
     url(r'^users/$', UserIndexEndpoint.as_view(), name='sentry-api-0-user-index'),
     url(
diff --git a/src/sentry/options/defaults.py b/src/sentry/options/defaults.py
index d91452216c..cc67e27baa 100644
--- a/src/sentry/options/defaults.py
+++ b/src/sentry/options/defaults.py
@@ -34,6 +34,8 @@ register('system.secret-key', flags=FLAG_NOSTORE)
 register('system.url-prefix', ttl=60, grace=3600, flags=FLAG_REQUIRED | FLAG_PRIORITIZE_DISK)
 register('system.root-api-key', flags=FLAG_PRIORITIZE_DISK)
 register('system.logging-format', default=LoggingFormat.HUMAN, flags=FLAG_NOSTORE)
+# This is used for the chunk upload endpoint
+register('system.upload-url-prefix', flags=FLAG_PRIORITIZE_DISK)
 
 # Redis
 register(
diff --git a/tests/sentry/api/endpoints/test_chunk_upload.py b/tests/sentry/api/endpoints/test_chunk_upload.py
new file mode 100644
index 0000000000..ba5cbc3507
--- /dev/null
+++ b/tests/sentry/api/endpoints/test_chunk_upload.py
@@ -0,0 +1,160 @@
+from __future__ import absolute_import
+
+from hashlib import sha1
+
+from django.core.urlresolvers import reverse
+from django.core.files.uploadedfile import SimpleUploadedFile
+
+from sentry import options
+from sentry.models import ApiToken, FileBlob
+from sentry.models.file import DEFAULT_BLOB_SIZE
+from sentry.testutils import APITestCase
+from sentry.api.endpoints.chunk_upload import (MAX_CHUNKS_PER_REQUEST, MAX_CONCURRENCY,
+                                               HASH_ALGORITHM)
+
+
+class ChunkUploadTest(APITestCase):
+    def test_chunk_parameters(self):
+        token = ApiToken.objects.create(
+            user=self.user,
+            scope_list=['project:releases'],
+        )
+
+        url = reverse('sentry-api-0-chunk-upload')
+        response = self.client.get(
+            url,
+            HTTP_AUTHORIZATION='Bearer {}'.format(token.token),
+            format='json'
+        )
+
+        endpoint = options.get('system.upload-url-prefix')
+        # We fallback to default system url if config is not set
+        if len(endpoint) == 0:
+            endpoint = options.get('system.url-prefix')
+
+        assert response.status_code == 200, response.content
+        assert response.data['chunkSize'] == DEFAULT_BLOB_SIZE
+        assert response.data['chunksPerRequest'] == MAX_CHUNKS_PER_REQUEST
+        assert response.data['concurrency'] == MAX_CONCURRENCY
+        assert response.data['hashAlgorithm'] == HASH_ALGORITHM
+        assert response.data['url'] == options.get('system.url-prefix')
+
+        options.set('system.upload-url-prefix', 'test')
+        response = self.client.get(
+            url,
+            HTTP_AUTHORIZATION='Bearer {}'.format(token.token),
+            format='json'
+        )
+
+        assert response.data['url'] == options.get('system.upload-url-prefix')
+
+    def test_wrong_api_token(self):
+        token = ApiToken.objects.create(
+            user=self.user,
+        )
+        url = reverse('sentry-api-0-chunk-upload')
+        response = self.client.get(
+            url,
+            HTTP_AUTHORIZATION='Bearer {}'.format(token.token),
+        )
+        assert response.status_code == 403, response.content
+
+    def test_upload(self):
+        token = ApiToken.objects.create(
+            user=self.user,
+            scope_list=['project:releases'],
+        )
+
+        string1 = '1 this is my testString'
+        string2 = '2 this is my testString'
+
+        checksum1 = sha1(string1).hexdigest()
+        checksum2 = sha1(string2).hexdigest()
+
+        url = reverse('sentry-api-0-chunk-upload')
+        response = self.client.post(
+            url,
+            data={
+                'file':
+                [
+                    SimpleUploadedFile(checksum1, string1),
+                    SimpleUploadedFile(checksum2, string2)
+                ]
+            },
+            HTTP_AUTHORIZATION='Bearer {}'.format(token.token),
+            format='multipart'
+        )
+
+        assert response.status_code == 200, response.content
+
+        file_blobs = FileBlob.objects.all()
+        assert len(file_blobs) == 2
+        assert file_blobs[0].checksum == checksum1
+        assert file_blobs[1].checksum == checksum2
+
+    def test_too_many_chunks(self):
+        token = ApiToken.objects.create(
+            user=self.user,
+            scope_list=['project:releases'],
+        )
+
+        files = []
+        for x in range(0, MAX_CHUNKS_PER_REQUEST + 1):
+            content = '%s' % x
+            files.append(SimpleUploadedFile(sha1(content).hexdigest(), content))
+
+        url = reverse('sentry-api-0-chunk-upload')
+        response = self.client.post(
+            url,
+            data={
+                'file': files
+            },
+            HTTP_AUTHORIZATION='Bearer {}'.format(token.token),
+            format='multipart'
+        )
+
+        assert response.status_code == 400, response.content
+
+    def test_too_large_chunk(self):
+        token = ApiToken.objects.create(
+            user=self.user,
+            scope_list=['project:releases'],
+        )
+
+        files = []
+        content = "x" * (DEFAULT_BLOB_SIZE + 1)
+        files.append(SimpleUploadedFile(sha1(content).hexdigest(), content))
+
+        url = reverse('sentry-api-0-chunk-upload')
+        response = self.client.post(
+            url,
+            data={
+                'file': files
+            },
+            HTTP_AUTHORIZATION='Bearer {}'.format(token.token),
+            format='multipart'
+        )
+
+        assert response.status_code == 400, response.content
+
+    def test_checksum_missmatch(self):
+        token = ApiToken.objects.create(
+            user=self.user,
+            scope_list=['project:releases'],
+        )
+
+        files = []
+        content = "x" * (DEFAULT_BLOB_SIZE + 1)
+        files.append(SimpleUploadedFile('wrong checksum', content))
+
+        url = reverse('sentry-api-0-chunk-upload')
+        response = self.client.post(
+            url,
+            data={
+                'file': files
+            },
+            HTTP_AUTHORIZATION='Bearer {}'.format(token.token),
+            format='multipart'
+        )
+
+        assert response.status_code == 400, response.content

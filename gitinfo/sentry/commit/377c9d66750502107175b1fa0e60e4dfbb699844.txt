commit 377c9d66750502107175b1fa0e60e4dfbb699844
Author: Evan Purkhiser <evanpurkhiser@gmail.com>
Date:   Tue Sep 10 16:38:04 2019 -0700

    ref(sso): Handle invite acceptance during SSO
    
    Refs: GROW-459

diff --git a/src/sentry/api/endpoints/accept_organization_invite.py b/src/sentry/api/endpoints/accept_organization_invite.py
index afb8be0c36..2b9abe77a7 100644
--- a/src/sentry/api/endpoints/accept_organization_invite.py
+++ b/src/sentry/api/endpoints/accept_organization_invite.py
@@ -18,7 +18,7 @@ class AcceptOrganizationInvite(Endpoint):
         return Response(status=status.HTTP_400_BAD_REQUEST, data={"details": "Invalid invite code"})
 
     def get_helper(self, request, member_id, token):
-        return ApiInviteHelper(instance=self, request=request, member_id=member_id, token=token)
+        return ApiInviteHelper(request=request, member_id=member_id, instance=self, token=token)
 
     def get(self, request, member_id, token):
         try:
@@ -55,10 +55,17 @@ class AcceptOrganizationInvite(Endpoint):
 
         # Allow users to register an account when accepting an invite
         if not helper.user_authenticated:
-            url = reverse("sentry-accept-invite", args=[member_id, token])
-            auth.initiate_login(self.request, next_url=url)
             request.session["can_register"] = True
 
+            # When SSO is required do *not* set a next_url to return to accept
+            # invite. The invite will be accepted after SSO is completed.
+            url = (
+                reverse("sentry-accept-invite", args=[member_id, token])
+                if not auth_provider
+                else "/"
+            )
+            auth.initiate_login(self.request, next_url=url)
+
         # If the org has SSO setup, we'll store the invite cookie to later
         # associate the org member after authentication. We can avoid needing
         # to come back to the accept invite page since 2FA will *not* be
diff --git a/src/sentry/api/invite_helper.py b/src/sentry/api/invite_helper.py
index eae937fd89..bb1aa0559c 100644
--- a/src/sentry/api/invite_helper.py
+++ b/src/sentry/api/invite_helper.py
@@ -5,6 +5,7 @@ from django.utils.crypto import constant_time_compare
 from django.core.urlresolvers import reverse
 
 from sentry.utils import metrics
+from sentry.utils.audit import create_audit_entry
 from sentry.models import AuditLogEntryEvent, Authenticator, OrganizationMember
 from sentry.signals import member_joined
 
@@ -38,17 +39,46 @@ def get_invite_cookie(request):
 
 
 class ApiInviteHelper(object):
-    def __init__(self, instance, request, member_id, token, logger=None):
+    @classmethod
+    def from_cookie_or_email(cls, request, organization, email, instance=None, logger=None):
+        """
+        Initializes the ApiInviteHelper by locating the pending organization
+        member via the currently set pending invite cookie, or via the passed
+        email if no cookie is currently set.
+        """
+        pending_invite = get_invite_cookie(request)
+
+        try:
+            if pending_invite is not None:
+                om = OrganizationMember.objects.get(
+                    id=pending_invite["memberId"], token=pending_invite["token"]
+                )
+            else:
+                om = OrganizationMember.objects.get(
+                    email=email, organization=organization, user=None
+                )
+        except OrganizationMember.DoesNotExist:
+            # Unable to locate the pending organization member. Cannot setup
+            # the invite helper.
+            return None
+
+        return cls(
+            request=request, member_id=om.id, token=om.token, instance=instance, logger=logger
+        )
+
+    def __init__(self, request, member_id, token, instance=None, logger=None):
         self.request = request
-        self.instance = instance
         self.member_id = member_id
         self.token = token
+        self.instance = instance
         self.logger = logger
         self.om = self.organization_member
 
     def handle_success(self):
         member_joined.send_robust(
-            member=self.om, organization=self.om.organization, sender=self.instance
+            member=self.om,
+            organization=self.om.organization,
+            sender=self.instance if self.instance else self,
         )
 
     def handle_member_already_exists(self):
@@ -115,8 +145,9 @@ class ApiInviteHelper(object):
             om.set_user(user)
             om.save()
 
-            self.instance.create_audit_entry(
+            create_audit_entry(
                 self.request,
+                actor=user,
                 organization=om.organization,
                 target_object=om.id,
                 target_user=user,
diff --git a/src/sentry/auth/helper.py b/src/sentry/auth/helper.py
index 3011c40345..95a094cfb1 100644
--- a/src/sentry/auth/helper.py
+++ b/src/sentry/auth/helper.py
@@ -14,6 +14,7 @@ from django.utils import timezone
 from django.utils.translation import ugettext_lazy as _
 
 from sentry.app import locks
+from sentry.api.invite_helper import ApiInviteHelper, remove_invite_cookie
 from sentry.auth.provider import MigratingIdentityId
 from sentry.auth.exceptions import IdentityNotValid
 from sentry.models import (
@@ -156,6 +157,20 @@ def handle_existing_identity(
 def handle_new_membership(auth_provider, organization, request, auth_identity):
     user = auth_identity.user
 
+    # If the user is either currently *pending* invite acceptance (as indicated
+    # from the pending-invite cookie) OR an existing invite exists on this
+    # organziation for the email provided by the identity provider.
+    invite_helper = ApiInviteHelper.from_cookie_or_email(
+        request=request, organization=organization, email=user.email
+    )
+
+    # If we are able to accept an existing invite for the user for this
+    # organization, do so, otherwise handle new membership
+    if invite_helper:
+        invite_helper.accept_invite(user)
+        return
+
+    # Otherwise create a new membership
     om = OrganizationMember.objects.create(
         organization=organization,
         role=organization.default_role,
@@ -305,6 +320,16 @@ def respond(template, organization, request, context=None, status=200):
     return render_to_response(template, default_context, request, status=status)
 
 
+def post_login_redirect(request):
+    response = HttpResponseRedirect(auth.get_login_redirect(request))
+
+    # Always remove any pending invite cookies, pending invites will have been
+    # accepted during the SSO flow.
+    remove_invite_cookie(request, response)
+
+    return response
+
+
 def handle_unknown_identity(request, organization, auth_provider, provider, state, identity):
     """
     Flow is activated upon a user logging in to where an AuthIdentity is
@@ -361,7 +386,7 @@ def handle_unknown_identity(request, organization, auth_provider, provider, stat
                 organization_id=organization.id,
             ):
                 if acting_user.has_usable_password():
-                    return HttpResponseRedirect(auth.get_login_redirect(request))
+                    return post_login_redirect(request)
                 else:
                     acting_user = None
             else:
@@ -397,7 +422,7 @@ def handle_unknown_identity(request, organization, auth_provider, provider, stat
                 after_2fa=request.build_absolute_uri(),
                 organization_id=organization.id,
             ):
-                return HttpResponseRedirect(auth.get_login_redirect(request))
+                return post_login_redirect(request)
         else:
             auth.log_auth_failure(request, request.POST.get("username"))
     else:
@@ -437,11 +462,11 @@ def handle_unknown_identity(request, organization, auth_provider, provider, stat
     if not auth.login(
         request, user, after_2fa=request.build_absolute_uri(), organization_id=organization.id
     ):
-        return HttpResponseRedirect(auth.get_login_redirect(request))
+        return post_login_redirect(request)
 
     state.clear()
 
-    return HttpResponseRedirect(auth.get_login_redirect(request))
+    return post_login_redirect(request)
 
 
 def handle_new_user(auth_provider, organization, request, identity):
@@ -466,14 +491,7 @@ def handle_new_user(auth_provider, organization, request, identity):
 
     user.send_confirm_emails(is_new_user=True)
 
-    # If the user has a pending invitation in this organization, we can
-    # immediately assocaite their user.
-    try:
-        member = OrganizationMember.objects.get(organization=organization, email=user.email)
-        member.set_user(user)
-        member.save()
-    except OrganizationMember.DoesNotExist:
-        handle_new_membership(auth_provider, organization, request, auth_identity)
+    handle_new_membership(auth_provider, organization, request, auth_identity)
 
     return auth_identity
 
diff --git a/src/sentry/utils/audit.py b/src/sentry/utils/audit.py
index 9ac78080e1..4aa757e57a 100644
--- a/src/sentry/utils/audit.py
+++ b/src/sentry/utils/audit.py
@@ -13,7 +13,7 @@ from sentry.models import (
 
 
 def create_audit_entry(request, transaction_id=None, logger=None, **kwargs):
-    user = request.user if request.user.is_authenticated() else None
+    user = kwargs.pop("actor", request.user if request.user.is_authenticated() else None)
     api_key = (
         request.auth if hasattr(request, "auth") and isinstance(request.auth, ApiKey) else None
     )
diff --git a/tests/sentry/auth/test_helper.py b/tests/sentry/auth/test_helper.py
index 4d365829ea..3138e37c1b 100644
--- a/tests/sentry/auth/test_helper.py
+++ b/tests/sentry/auth/test_helper.py
@@ -1,35 +1,68 @@
 from __future__ import absolute_import
 
-import mock
+from six.moves.urllib.parse import urlencode
+from django.test import RequestFactory
+from django.contrib.auth.models import AnonymousUser
 
 from sentry.models import AuthProvider, OrganizationMember
 from sentry.testutils import TestCase
 from sentry.auth.helper import handle_new_user
 
 
-class HandleNewuserTest(TestCase):
-    @mock.patch("sentry.auth.helper.handle_new_membership")
-    def test_simple(self, mock_handle_new_membership):
-        provider = AuthProvider.objects.create(organization=self.organization, provider="dummy")
+class HandleNewUserTest(TestCase):
+    def test_simple(self):
+        request = RequestFactory().post("/auth/sso/")
+        request.user = AnonymousUser()
 
+        provider = AuthProvider.objects.create(organization=self.organization, provider="dummy")
         identity = {"id": "1234", "email": "test@example.com", "name": "Morty"}
 
-        auth_identity = handle_new_user(provider, self.organization, None, identity)
+        auth_identity = handle_new_user(provider, self.organization, request, identity)
 
-        assert mock_handle_new_membership.called
         assert auth_identity.user.email == identity["email"]
+        assert OrganizationMember.objects.filter(
+            organization=self.organization, user=auth_identity.user
+        ).exists()
+
+    def test_associated_existing_member_invite_by_email(self):
+        request = RequestFactory().post("/auth/sso/")
+        request.user = AnonymousUser()
 
-    @mock.patch("sentry.auth.helper.handle_new_membership")
-    def test_associated_member_invite(self, mock_handle_new_membership):
         provider = AuthProvider.objects.create(organization=self.organization, provider="dummy")
+        identity = {"id": "1234", "email": "test@example.com", "name": "Morty"}
+
+        member = OrganizationMember.objects.create(
+            organization=self.organization, email=identity["email"]
+        )
+
+        auth_identity = handle_new_user(provider, self.organization, request, identity)
 
+        assigned_member = OrganizationMember.objects.get(
+            organization=self.organization, user=auth_identity.user
+        )
+
+        assert assigned_member.id == member.id
+
+    def test_associate_pending_invite(self):
+        provider = AuthProvider.objects.create(organization=self.organization, provider="dummy")
         identity = {"id": "1234", "email": "test@example.com", "name": "Morty"}
 
-        OrganizationMember.objects.create(organization=self.organization, email=identity["email"])
+        # The org member invite should have a non matching email, but the
+        # member id and token will match from the cookie, allowing association
+        member = OrganizationMember.objects.create(
+            organization=self.organization, email="different.email@example.com", token="abc"
+        )
 
-        auth_identity = handle_new_user(provider, self.organization, None, identity)
+        request = RequestFactory().post("/auth/sso/")
+        request.user = AnonymousUser()
+        request.COOKIES["pending-invite"] = urlencode(
+            {"memberId": member.id, "token": member.token, "url": ""}
+        )
 
-        assert not mock_handle_new_membership.called
-        assert OrganizationMember.objects.filter(
+        auth_identity = handle_new_user(provider, self.organization, request, identity)
+
+        assigned_member = OrganizationMember.objects.get(
             organization=self.organization, user=auth_identity.user
-        ).exists()
+        )
+
+        assert assigned_member.id == member.id

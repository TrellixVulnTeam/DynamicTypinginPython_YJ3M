commit f0e4a83b054929541d18ebb0531aa6d980c35fee
Author: Matt Robenolt <matt@ydekproductions.com>
Date:   Thu Sep 1 15:45:41 2016 -0700

    Immediately delete GroupHash when deleting a group (#4056)
    
    Since a group is deleted asynchrnously, new events will get grouped
    together with the group that's hidden in it's pending deletion state.
    
    Removing the GroupHash rows immediately means that new events can
    regroup into a new group and resurface.

diff --git a/src/sentry/api/endpoints/group_details.py b/src/sentry/api/endpoints/group_details.py
index 2dad82bb84..1afe3e2d7a 100644
--- a/src/sentry/api/endpoints/group_details.py
+++ b/src/sentry/api/endpoints/group_details.py
@@ -13,9 +13,9 @@ from sentry.api.fields import UserField
 from sentry.api.serializers import serialize
 from sentry.constants import STATUS_CHOICES
 from sentry.models import (
-    Activity, Group, GroupAssignee, GroupSeen, GroupSubscription,
+    Activity, Group, GroupHash, GroupAssignee, GroupSeen, GroupSubscription,
     GroupSubscriptionReason, GroupStatus, GroupTagKey, GroupTagValue, Release,
-    User, UserReport
+    User, UserReport,
 )
 from sentry.plugins import IssueTrackingPlugin2, plugins
 from sentry.utils.safe import safe_execute
@@ -329,6 +329,7 @@ class GroupDetailsEndpoint(GroupEndpoint):
             ]
         ).update(status=GroupStatus.PENDING_DELETION)
         if updated:
+            GroupHash.objects.filter(group=group).delete()
             delete_group.apply_async(
                 kwargs={'object_id': group.id},
                 countdown=3600,
diff --git a/src/sentry/api/endpoints/project_group_index.py b/src/sentry/api/endpoints/project_group_index.py
index e869c61772..c5932d05fd 100644
--- a/src/sentry/api/endpoints/project_group_index.py
+++ b/src/sentry/api/endpoints/project_group_index.py
@@ -16,9 +16,9 @@ from sentry.api.serializers.models.group import StreamGroupSerializer
 from sentry.constants import DEFAULT_SORT_OPTION
 from sentry.db.models.query import create_or_update
 from sentry.models import (
-    Activity, EventMapping, Group, GroupBookmark, GroupResolution, GroupSeen,
+    Activity, EventMapping, Group, GroupHash, GroupBookmark, GroupResolution, GroupSeen,
     GroupSubscription, GroupSubscriptionReason, GroupSnooze, GroupStatus,
-    Release, TagKey
+    Release, TagKey,
 )
 from sentry.models.group import looks_like_short_id
 from sentry.search.utils import parse_query
@@ -663,6 +663,7 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
                 GroupStatus.DELETION_IN_PROGRESS,
             ]
         ).update(status=GroupStatus.PENDING_DELETION)
+        GroupHash.objects.filter(group__id__in=group_ids).delete()
         for group in group_list:
             delete_group.apply_async(
                 kwargs={'object_id': group.id},
diff --git a/tests/sentry/api/endpoints/test_group_details.py b/tests/sentry/api/endpoints/test_group_details.py
index 52bbf27ba0..ea8a5f054c 100644
--- a/tests/sentry/api/endpoints/test_group_details.py
+++ b/tests/sentry/api/endpoints/test_group_details.py
@@ -6,7 +6,7 @@ from datetime import timedelta
 from django.utils import timezone
 
 from sentry.models import (
-    Activity, Group, GroupAssignee, GroupBookmark, GroupSeen, GroupSnooze,
+    Activity, Group, GroupHash, GroupAssignee, GroupBookmark, GroupSeen, GroupSnooze,
     GroupSubscription, GroupStatus, GroupTagValue, Release
 )
 from sentry.testutils import APITestCase
@@ -246,6 +246,24 @@ class GroupDeleteTest(APITestCase):
         self.login_as(user=self.user)
 
         group = self.create_group()
+        GroupHash.objects.create(
+            project=group.project,
+            hash='x' * 32,
+            group=group,
+        )
+
+        url = '/api/0/issues/{}/'.format(group.id)
+
+        response = self.client.delete(url, format='json')
+
+        assert response.status_code == 202, response.content
+
+        # Deletion was deferred, so it should still exist
+        assert Group.objects.get(id=group.id).status == GroupStatus.PENDING_DELETION
+        # BUT the hash should be gone
+        assert not GroupHash.objects.filter(group_id=group.id).exists()
+
+        Group.objects.filter(id=group.id).update(status=GroupStatus.UNRESOLVED)
 
         url = '/api/0/issues/{}/'.format(group.id)
 
@@ -254,5 +272,6 @@ class GroupDeleteTest(APITestCase):
 
         assert response.status_code == 202, response.content
 
-        group = Group.objects.filter(id=group.id).exists()
-        assert not group
+        # Now we killed everything with fire
+        assert not Group.objects.filter(id=group.id).exists()
+        assert not GroupHash.objects.filter(group_id=group.id).exists()
diff --git a/tests/sentry/api/endpoints/test_project_group_index.py b/tests/sentry/api/endpoints/test_project_group_index.py
index 4aec84b7dc..9c66a44de8 100644
--- a/tests/sentry/api/endpoints/test_project_group_index.py
+++ b/tests/sentry/api/endpoints/test_project_group_index.py
@@ -6,9 +6,10 @@ from datetime import timedelta
 from django.utils import timezone
 from exam import fixture
 from mock import patch
+from uuid import uuid4
 
 from sentry.models import (
-    Activity, EventMapping, Group, GroupBookmark, GroupResolution, GroupSeen,
+    Activity, EventMapping, Group, GroupHash, GroupBookmark, GroupResolution, GroupSeen,
     GroupSnooze, GroupSubscription, GroupStatus, Release
 )
 from sentry.testutils import APITestCase
@@ -692,6 +693,13 @@ class GroupDeleteTest(APITestCase):
             project=self.create_project(slug='foo'),
             checksum='b' * 32, status=GroupStatus.UNRESOLVED)
 
+        for g in group1, group2, group3, group4:
+            GroupHash.objects.create(
+                project=g.project,
+                hash=uuid4().hex,
+                group=g,
+            )
+
         self.login_as(user=self.user)
         url = '{url}?id={group1.id}&id={group2.id}&group4={group4.id}'.format(
             url=self.path,
@@ -700,19 +708,37 @@ class GroupDeleteTest(APITestCase):
             group4=group4,
         )
 
+        response = self.client.delete(url, format='json')
+
+        assert response.status_code == 204
+
+        assert Group.objects.get(id=group1.id).status == GroupStatus.PENDING_DELETION
+        assert not GroupHash.objects.filter(group_id=group1.id).exists()
+
+        assert Group.objects.get(id=group2.id).status == GroupStatus.PENDING_DELETION
+        assert not GroupHash.objects.filter(group_id=group2.id).exists()
+
+        assert Group.objects.get(id=group3.id).status != GroupStatus.PENDING_DELETION
+        assert GroupHash.objects.filter(group_id=group3.id).exists()
+
+        assert Group.objects.get(id=group4.id).status != GroupStatus.PENDING_DELETION
+        assert GroupHash.objects.filter(group_id=group4.id).exists()
+
+        Group.objects.filter(id__in=(group1.id, group2.id)).update(status=GroupStatus.UNRESOLVED)
+
         with self.tasks():
             response = self.client.delete(url, format='json')
 
         assert response.status_code == 204
 
-        new_group1 = Group.objects.filter(id=group1.id)
-        assert not new_group1.exists()
+        assert not Group.objects.filter(id=group1.id).exists()
+        assert not GroupHash.objects.filter(group_id=group1.id).exists()
 
-        new_group2 = Group.objects.filter(id=group2.id)
-        assert not new_group2.exists()
+        assert not Group.objects.filter(id=group2.id).exists()
+        assert not GroupHash.objects.filter(group_id=group2.id).exists()
 
-        new_group3 = Group.objects.filter(id=group3.id)
-        assert new_group3.exists()
+        assert Group.objects.filter(id=group3.id).exists()
+        assert GroupHash.objects.filter(group_id=group3.id).exists()
 
-        new_group4 = Group.objects.filter(id=group4.id)
-        assert new_group4.exists()
+        assert Group.objects.filter(id=group4.id).exists()
+        assert GroupHash.objects.filter(group_id=group4.id).exists()

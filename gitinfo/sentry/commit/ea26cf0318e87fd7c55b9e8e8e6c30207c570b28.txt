commit ea26cf0318e87fd7c55b9e8e8e6c30207c570b28
Author: Jan Michael Auer <jan.auer@sentry.io>
Date:   Mon Sep 2 10:05:27 2019 +0200

    feat(quotas): Support RedisCluster in RedisQuota (#14533)
    
    Supports regular Redis Clusters for quotas instead of RedisBlaster. Also changes the key format for clusters.

diff --git a/src/sentry/quotas/redis.py b/src/sentry/quotas/redis.py
index fdc5b8f68c..38d039db6a 100644
--- a/src/sentry/quotas/redis.py
+++ b/src/sentry/quotas/redis.py
@@ -5,18 +5,29 @@ import six
 
 from time import time
 
+from sentry import options
 from sentry.exceptions import InvalidConfiguration
 from sentry.quotas.base import NotRateLimited, Quota, RateLimited
-from sentry.utils.redis import get_cluster_from_options, load_script
+from sentry.utils.redis import get_cluster_from_options, load_script, redis_clusters
 
 is_rate_limited = load_script("quotas/is_rate_limited.lua")
 
 
+def get_dynamic_cluster_from_options(setting, config):
+    cluster_name = config.get("cluster", "default")
+    cluster_opts = options.default_manager.get("redis.clusters").get(cluster_name)
+    if cluster_opts is not None and cluster_opts.get("is_redis_cluster"):
+        return True, redis_clusters.get(cluster_name), config
+
+    return (False,) + get_cluster_from_options(setting, config)
+
+
 class BasicRedisQuota(object):
-    __slots__ = ["key", "limit", "window", "reason_code", "enforce"]
+    __slots__ = ["prefix", "subscope", "limit", "window", "reason_code", "enforce"]
 
-    def __init__(self, key, limit=0, window=60, reason_code=None, enforce=True):
-        self.key = key
+    def __init__(self, prefix, subscope=None, limit=0, window=60, reason_code=None, enforce=True):
+        self.prefix = prefix
+        self.subscope = subscope
         # maximum number of events in the given window, 0 indicates "no limit"
         self.limit = limit
         # time in seconds that this quota reflects
@@ -34,19 +45,40 @@ class RedisQuota(Quota):
     grace = 60
 
     def __init__(self, **options):
-        self.cluster, options = get_cluster_from_options("SENTRY_QUOTA_OPTIONS", options)
+        self.is_redis_cluster, self.cluster, options = get_dynamic_cluster_from_options(
+            "SENTRY_QUOTA_OPTIONS", options
+        )
+
+        # Based on the `is_redis_cluster` flag, self.cluster is set two one of
+        # the following two objects:
+        #  - false: `cluster` is a `RBCluster`. Call `get_local_client_for_key`
+        #    on the cluster to resolve a client to run a script or query a key.
+        #  - true: `cluster` is a `RedisCluster`. It automatically dispatches to
+        #    the correct node and can be used as a client directly.
+
         super(RedisQuota, self).__init__(**options)
         self.namespace = "quota"
 
     def validate(self):
         try:
-            with self.cluster.all() as client:
-                client.ping()
+            if self.is_redis_cluster:
+                self.cluster.ping()
+            else:
+                with self.cluster.all() as client:
+                    client.ping()
         except Exception as e:
             raise InvalidConfiguration(six.text_type(e))
 
-    def __get_redis_key(self, key, timestamp, interval, shift):
-        return u"{}:{}:{}".format(self.namespace, key, int((timestamp - shift) // interval))
+    def __get_redis_key(self, quota, timestamp, shift, organization_id):
+        if self.is_redis_cluster:
+            # new style redis cluster format which always has the organization id in
+            local_key = "%s{%s}%s" % (quota.prefix, organization_id, quota.subscope or "")
+        else:
+            # legacy key format
+            local_key = "%s:%s" % (quota.prefix, quota.subscope or organization_id)
+
+        interval = quota.window
+        return u"{}:{}:{}".format(self.namespace, local_key, int((timestamp - shift) // interval))
 
     def get_quotas_with_limits(self, project, key=None):
         return [
@@ -63,23 +95,20 @@ class RedisQuota(Quota):
         oquota = self.get_organization_quota(project.organization)
         results = [
             BasicRedisQuota(
-                key=u"p:{}".format(project.id),
+                prefix="p",
+                subscope=project.id,
                 limit=pquota[0],
                 window=pquota[1],
                 reason_code="project_quota",
             ),
-            BasicRedisQuota(
-                key=u"o:{}".format(project.organization_id),
-                limit=oquota[0],
-                window=oquota[1],
-                reason_code="org_quota",
-            ),
+            BasicRedisQuota(prefix="o", limit=oquota[0], window=oquota[1], reason_code="org_quota"),
         ]
         if key:
             kquota = self.get_key_quota(key)
             results.append(
                 BasicRedisQuota(
-                    key=u"k:{}".format(key.id),
+                    prefix="k",
+                    subscope=key.id,
                     limit=kquota[0],
                     window=kquota[1],
                     reason_code="key_quota",
@@ -96,7 +125,7 @@ class RedisQuota(Quota):
                 return (None, None)
 
             key = self.__get_redis_key(
-                quota.key, timestamp, quota.window, organization_id % quota.window
+                quota, timestamp, organization_id % quota.window, organization_id
             )
             refund_key = self.get_refunded_quota_key(key)
 
@@ -108,13 +137,16 @@ class RedisQuota(Quota):
 
             return int(result.value or 0) - int(refund_result.value or 0)
 
-        with self.cluster.fanout() as client:
-            results = map(
-                functools.partial(
-                    get_usage_for_quota, client.target_key(six.text_type(organization_id))
-                ),
-                quotas,
-            )
+        if self.is_redis_cluster:
+            results = map(functools.partial(get_usage_for_quota, self.cluster), quotas)
+        else:
+            with self.cluster.fanout() as client:
+                results = map(
+                    functools.partial(
+                        get_usage_for_quota, client.target_key(six.text_type(organization_id))
+                    ),
+                    quotas,
+                )
 
         return [get_value_for_result(*r) for r in results]
 
@@ -139,7 +171,7 @@ class RedisQuota(Quota):
             # sure the window is over?
             expiry = self.get_next_period_start(quota.window, shift, timestamp) + self.grace
             return_key = self.get_refunded_quota_key(
-                self.__get_redis_key(quota.key, timestamp, quota.window, shift)
+                self.__get_redis_key(quota, timestamp, shift, project.organization_id)
             )
             pipe.incr(return_key, 1)
             pipe.expireat(return_key, int(expiry))
@@ -164,14 +196,18 @@ class RedisQuota(Quota):
         args = []
         for quota in quotas:
             shift = project.organization_id % quota.window
-            key = self.__get_redis_key(quota.key, timestamp, quota.window, shift)
+            key = self.__get_redis_key(quota, timestamp, shift, project.organization_id)
             return_key = self.get_refunded_quota_key(key)
             keys.extend((key, return_key))
             expiry = self.get_next_period_start(quota.window, shift, timestamp) + self.grace
             args.extend((quota.limit, int(expiry)))
 
-        client = self.cluster.get_local_client_for_key(six.text_type(project.organization_id))
-        rejections = is_rate_limited(client, keys, args)
+        if self.is_redis_cluster:
+            rejections = is_rate_limited(self.cluster, keys, args)
+        else:
+            client = self.cluster.get_local_client_for_key(six.text_type(project.organization_id))
+            rejections = is_rate_limited(client, keys, args)
+
         if any(rejections):
             enforce = False
             worst_case = (0, None)
diff --git a/tests/sentry/quotas/redis/tests.py b/tests/sentry/quotas/redis/tests.py
index fb04fe273b..edee15d82b 100644
--- a/tests/sentry/quotas/redis/tests.py
+++ b/tests/sentry/quotas/redis/tests.py
@@ -86,10 +86,12 @@ class RedisQuotaTest(TestCase):
         self.get_project_quota.return_value = (200, 60)
         self.get_organization_quota.return_value = (300, 60)
         quotas = self.quota.get_quotas(self.project)
-        assert quotas[0].key == u"p:{}".format(self.project.id)
+        assert quotas[0].prefix == u'p'
+        assert quotas[0].subscope == self.project.id
         assert quotas[0].limit == 200
         assert quotas[0].window == 60
-        assert quotas[1].key == u"o:{}".format(self.project.organization.id)
+        assert quotas[1].prefix == u'o'
+        assert quotas[1].subscope is None
         assert quotas[1].limit == 300
         assert quotas[1].window == 60
 
@@ -117,10 +119,10 @@ class RedisQuotaTest(TestCase):
     def test_not_limited_without_enforce(self, mock_is_rate_limited, mock_get_quotas):
         mock_get_quotas.return_value = (
             BasicRedisQuota(
-                key="p:1", limit=1, window=1, reason_code="project_quota", enforce=False
+                prefix="p", subscope=1, limit=1, window=1, reason_code="project_quota", enforce=False
             ),
             BasicRedisQuota(
-                key="p:2", limit=1, window=1, reason_code="project_quota", enforce=True
+                prefix="p", subscope=2, limit=1, window=1, reason_code="project_quota", enforce=True
             ),
         )
 
@@ -131,10 +133,10 @@ class RedisQuotaTest(TestCase):
     def test_limited_without_enforce(self, mock_is_rate_limited, mock_get_quotas):
         mock_get_quotas.return_value = (
             BasicRedisQuota(
-                key="p:1", limit=1, window=1, reason_code="project_quota", enforce=False
+                prefix="p", subscope=1, limit=1, window=1, reason_code="project_quota", enforce=False
             ),
             BasicRedisQuota(
-                key="p:2", limit=1, window=1, reason_code="project_quota", enforce=True
+                prefix="p", subscope=2, limit=1, window=1, reason_code="project_quota", enforce=True
             ),
         )
 
@@ -156,8 +158,8 @@ class RedisQuotaTest(TestCase):
             self.project.organization_id,
             quotas
             + [
-                BasicRedisQuota(key="unlimited", limit=0, window=60, reason_code="unlimited"),
-                BasicRedisQuota(key="dummy", limit=10, window=60, reason_code="dummy"),
+                BasicRedisQuota(prefix="unlimited", limit=0, window=60, reason_code="unlimited"),
+                BasicRedisQuota(prefix="dummy", limit=10, window=60, reason_code="dummy"),
             ],
             timestamp=timestamp,
         ) == [n for _ in quotas] + [None, 0]
@@ -168,10 +170,10 @@ class RedisQuotaTest(TestCase):
 
         mock_get_quotas.return_value = (
             BasicRedisQuota(
-                key="p:1", limit=1, window=1, reason_code="project_quota", enforce=False
+                prefix="p", subscope=1, limit=1, window=1, reason_code="project_quota", enforce=False
             ),
             BasicRedisQuota(
-                key="p:2", limit=1, window=1, reason_code="project_quota", enforce=True
+                prefix="p", subscope=2, limit=1, window=1, reason_code="project_quota", enforce=True
             ),
         )
 
@@ -205,8 +207,8 @@ class RedisQuotaTest(TestCase):
             self.project.organization_id,
             quotas
             + [
-                BasicRedisQuota(key="unlimited", limit=0, window=60, reason_code="unlimited"),
-                BasicRedisQuota(key="dummy", limit=10, window=60, reason_code="dummy"),
+                BasicRedisQuota(prefix="unlimited", limit=0, window=60, reason_code="unlimited"),
+                BasicRedisQuota(prefix="dummy", limit=10, window=60, reason_code="dummy"),
             ],
             timestamp=timestamp,
             # the - 1 is because we refunded once

commit fe03d388e52fe7c73330857c59b0f4f3fd6104ac
Author: Matt Robenolt <matt@ydekproductions.com>
Date:   Wed May 17 11:25:05 2017 -0700

    nodestore/riak: allow passing headers and/or basic auth
    
    This allows a host config to set:
    
    ```
    [{
      'host': '127.0.0.1',
      'port': 8098,
      'basic_auth': ('foo', 'bar'),
    }]
    ```
    
    Or combine with:
    
    ```
    [{
      'host': '127.0.0.1',
      'port': 8098,
      'headers': {
        'Foo': 'bar',
      },
    }]
    ```

diff --git a/src/sentry/nodestore/riak/client.py b/src/sentry/nodestore/riak/client.py
index 7d8de5dbbe..6ccc6dbd15 100644
--- a/src/sentry/nodestore/riak/client.py
+++ b/src/sentry/nodestore/riak/client.py
@@ -11,6 +11,7 @@ from __future__ import absolute_import
 import six
 import sys
 import socket
+from base64 import b64encode
 from random import shuffle
 from six.moves.queue import Queue
 from time import time
@@ -30,6 +31,11 @@ DEFAULT_NODES = (
 )
 
 
+def encode_basic_auth(auth):
+    auth = ':'.join(auth)
+    return 'Basic ' + b64encode(auth).decode('utf-8')
+
+
 class RiakClient(object):
     """
     A thread-safe simple light-weight riak client that does only
@@ -194,7 +200,12 @@ class ConnectionManager(object):
             # block=False
             'maxsize': host.get('maxsize', 5),
             'block': False,
+            'headers': host.get('headers', {})
         }
+
+        if 'basic_auth' in host:
+            options['headers']['authorization'] = encode_basic_auth(host['basic_auth'])
+
         if self.tcp_keepalive:
             options['socket_options'] = HTTPConnection.default_socket_options + [
                 (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),
@@ -222,7 +233,7 @@ class ConnectionManager(object):
                 })
         return connection_cls(addr, port, **options)
 
-    def urlopen(self, method, path, **kwargs):
+    def urlopen(self, method, path, headers=None, **kwargs):
         """
         Make a request using the next server according to the connection
         strategy, and retries up to max_retries attempts. Ultimately,
@@ -248,8 +259,10 @@ class ConnectionManager(object):
                     self.force_revive()
 
                 conn = self.strategy.next(self.connections)  # NOQA
+                if headers is not None:
+                    headers = dict(conn.headers, **headers)
                 try:
-                    return conn.urlopen(method, path, **kwargs)
+                    return conn.urlopen(method, path, headers=headers, **kwargs)
                 except HTTPError:
                     self.mark_dead(conn)
                     last_error = sys.exc_info()

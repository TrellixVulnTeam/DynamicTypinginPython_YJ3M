commit 3f0d9d5a52d4dd6ac2edf75a449886eb0ed550fc
Author: Armin Ronacher <armin.ronacher@active-4.com>
Date:   Sun May 15 13:38:14 2016 +0200

    Moved SMS code into an utility module and documented internal OTP

diff --git a/src/sentry/models/authenticator.py b/src/sentry/models/authenticator.py
index b31cc5ac21..ebec27ad70 100644
--- a/src/sentry/models/authenticator.py
+++ b/src/sentry/models/authenticator.py
@@ -9,46 +9,65 @@ from __future__ import absolute_import
 
 import os
 import hmac
-import urllib
 import base64
 import hashlib
-import requests
 
 from django.db import models
 from django.utils import timezone
 from django.utils.translation import ugettext_lazy as _
 from django.utils.functional import cached_property
 
-from sentry import options
 from sentry.db.models import BaseManager, BaseModel, BoundedAutoField, \
     FlexibleForeignKey, BoundedPositiveIntegerField, UnicodePickledObjectField
 from sentry.utils.otp import generate_secret_key, TOTP
+from sentry.utils.sms import send_sms, sms_available
 
 
 class AuthenticatorManager(BaseManager):
 
     def all_interfaces_for_user(self, user, return_missing=False):
+        """Returns a correctly sorted list of all interfaces the user
+        has enabled.  If `return_missing` is set to `True` the return
+        value is a tuple of `(enrolled, unenrolled)` interfaces.
+        """
         _sort = lambda x: sorted(x, key=lambda x: (x.type == 0, x.type))
-        rv = [x.interface for x in Authenticator.objects.filter(user=user)]
+        rv = [x.interface for x in Authenticator.objects.filter(user=user)
+              if x.interface.is_available]
         if not return_missing:
             return _sort(rv)
         rvm = dict(AUTHENTICATOR_INTERFACES)
         for iface in rv:
             rvm.pop(iface.interface_id, None)
-        return _sort(rv), _sort([x() for x in rvm.values()])
+        others = []
+        for key, iface_cls in rvm.iteritems():
+            iface = iface_cls()
+            if iface.is_available:
+                others.append(iface)
+        return _sort(rv), _sort(others)
 
     def is_missing_backup_interfaces(self, user):
+        """This checks if the user provided should add a backup interface
+        to his account.  This returns `true` essentially if at least one
+        non backup interface was added but not a single backup interface.
+        """
         has_authenticators = False
         for authenticator in Authenticator.objects.filter(user=user):
+            if not authenticator.interface.is_available:
+                continue
             if authenticator.interface.backup_interface:
                 return False
             has_authenticators = True
         return has_authenticators
 
     def get_interface(self, user, interface_id):
+        """Looks up an interface by interface ID for a user.  If the
+        interface is not available but configured a
+        `Authenticator.DoesNotExist` will be raised just as if the
+        authenticator was not configured at all.
+        """
         interface = AUTHENTICATOR_INTERFACES.get(interface_id)
-        if interface is None:
-            raise Authenticator.DoesNotExist()
+        if interface is None or not interface.is_available:
+            raise LookupError('No such interface %r' % interface_id)
         try:
             return Authenticator.objects.get(
                 user=user,
@@ -58,14 +77,22 @@ class AuthenticatorManager(BaseManager):
             return interface()
 
     def user_has_2fa(self, user, ignore_backup=False):
+        """Checks if the user has any 2FA configured.  Optionally backup
+        interfaces can be ignored.
+        """
         if ignore_backup:
             for authenticator in Authenticator.objects.filter(user=user):
+                if not authenticator.interface.is_available:
+                    continue
                 if not authenticator.interface.backup_interface:
                     return True
             return False
         return Authenticator.objects.filter(user=user).first() is not None
 
     def validate_otp(self, user, otp):
+        """Validates an OTP response against all interfaces.  If any accepts
+        it the success is logged and `True` is returned, `False` otherwise.
+        """
         for interface in self.all_interfaces_for_user(user):
             if interface.validate_otp(otp):
                 auth = interface.authenticator
@@ -105,15 +132,26 @@ class AuthenticatorInterface(object):
 
     @property
     def is_enrolled(self):
+        """Returns `True` if the interfaces is enrolled (eg: has an
+        authenticator for a user attached).
+        """
         return self.authenticator is not None
 
     @property
-    def requires_otp_flow_activation(self):
-        return self.on_otp_flow_activation.im_func is not \
-            AuthenticatorInterface.on_otp_flow_activation.im_func
+    def requires_activation(self):
+        """If the interface has an activation method that needs to be
+        called this returns `True`.
+        """
+        return self.activate.im_func is not \
+            AuthenticatorInterface.activate.im_func
 
     @property
     def config(self):
+        """Returns the configuration dictionary for this interface.  If
+        the interface is registered with an authenticator (eg: it is
+        enrolled) then the authenticator's config is returned, otherwise
+        a new config is used on first access.
+        """
         if self.authenticator is not None:
             return self.authenticator.config
         rv = getattr(self, '_unbound_config', None)
@@ -122,12 +160,22 @@ class AuthenticatorInterface(object):
         return rv
 
     def generate_new_config(self):
+        """This method is invoked if a new config is required."""
         return {}
 
-    def on_otp_flow_activation(self, request):
+    def activate(self, request):
+        """If an authenticator overrides this then the method is called
+        when the dialog for authentication is brought up.  The returned string
+        is then rendered in the UI.
+        """
+        # This method needs to be empty for the default
+        # `requires_activation` property to make sense.
         pass
 
     def enroll(self, user):
+        """Invoked to enroll a user for this interface.  If already enrolled
+        an error is raised.
+        """
         if self.authenticator is not None:
             raise RuntimeError('Already enrolled')
         self.authenticator = Authenticator.objects.create(
@@ -137,11 +185,15 @@ class AuthenticatorInterface(object):
         )
 
     def validate_otp(self, otp):
+        """This method is invoked for an OTP response and has to return
+        `True` or `False` based on the validity of the OTP response.
+        """
         return False
 
 
 @register_authenticator
 class RecoveryCodeInterface(AuthenticatorInterface):
+    """A backup interface that is based on static recovery codes."""
     type = 0
     interface_id = 'recovery'
     name = _('Recovery Codes')
@@ -190,35 +242,49 @@ class RecoveryCodeInterface(AuthenticatorInterface):
         return rv
 
 
-@register_authenticator
-class TotpInterface(AuthenticatorInterface):
-    type = 1
-    interface_id = 'totp'
-    name = _('Authenticator App')
-    description = _('An authenticator application that supports TOTP (like '
-                    'Google Authenticator or 1Password) can be used to '
-                    'conveniently secure your account.  A new token is '
-                    'generated every 30 seconds.')
+class OtpMixin(object):
 
     def generate_new_config(self):
         return {
             'secret': generate_secret_key(),
         }
 
-    def set_secret(self, secret):
+    def _get_secret(self):
+        return self.config['secret']
+
+    def _set_secret(self, secret):
         self.config['secret'] = secret
 
+    secret = property(_get_secret, _set_secret)
+    del _get_secret, _set_secret
+
+    def make_otp(self):
+        return TOTP(self.secret)
+
     def validate_otp(self, otp):
         otp = otp.strip().replace('-', '').replace(' ', '')
-        return TOTP(self.config['secret']).verify(otp)
+        return self.make_otp().verify(otp)
+
+
+@register_authenticator
+class TotpInterface(OtpMixin, AuthenticatorInterface):
+    """This interface uses TOTP with an authenticator."""
+    type = 1
+    interface_id = 'totp'
+    name = _('Authenticator App')
+    description = _('An authenticator application that supports TOTP (like '
+                    'Google Authenticator or 1Password) can be used to '
+                    'conveniently secure your account.  A new token is '
+                    'generated every 30 seconds.')
 
     def get_provision_qrcode(self, user, issuer=None):
-        return TOTP(self.config['secret']).get_provision_qrcode(
+        return self.make_otp().get_provision_qrcode(
             user, issuer=issuer)
 
 
 @register_authenticator
-class SmsInterface(TotpInterface):
+class SmsInterface(OtpMixin, AuthenticatorInterface):
+    """This interface sends OTP codes via text messages to the user."""
     type = 2
     interface_id = 'sms'
     name = _('Text Message')
@@ -227,45 +293,37 @@ class SmsInterface(TotpInterface):
                     'or when you do not have a phone that supports '
                     'an authenticator application.')
 
+    @property
+    def is_available(self):
+        return sms_available()
+
     def generate_new_config(self):
-        return {
-            'secret': generate_secret_key(),
-            'phone_number': None
-        }
+        config = super(SmsInterface, self).generate_new_config()
+        config['phone_number'] = None
+        return config
 
-    def set_secret(self, secret):
-        self.config['secret'] = secret
+    def make_otp(self):
+        return TOTP(self.config['secret'], digits=4, interval=60)
 
-    def set_phone_number(self, number):
-        self.config['phone_number'] = number
+    def _get_phone_number(self):
+        return self.config['phone_number']
 
-    def make_totp(self):
-        return TOTP(self.config['secret'], digits=4, interval=60)
+    def _set_phone_number(self, value):
+        self.config['phone_number'] = value
 
-    def validate_otp(self, otp):
-        return self.make_totp().verify(otp)
+    phone_number = property(_get_phone_number, _set_phone_number)
+    del _get_phone_number, _set_phone_number
 
-    def on_otp_flow_activation(self, request):
-        self.send_text()
-        return _('A confirmation code was sent to your phone.')
+    def activate(self, request):
+        if self.send_text():
+            return _('A confirmation code was sent to your phone.')
+        return _('Error: we failed to send a text message to you.  You '
+                 'can try again later or sign in with a different method.')
 
     def send_text(self):
         code = self.make_totp().generate_otp()
-        number = self.config['phone_number']
-        if number is None:
-            raise RuntimeError('No phone number set')
-        account = options.get('2fa.twilio_account')
-        if account[:2] != 'AC':
-            account = 'AC' + account
-        url = 'https://api.twilio.com/2010-04-01/Accounts/%s/Messages.json' % \
-            urllib.quote(account)
-        body = 'Your Sentry authentication code is %s.' % code
-        requests.post(url, auth=(account,
-                                 options.get('2fa.twilio_token')), data={
-            'To': number,
-            'From': options.get('2fa.twilio_number'),
-            'Body': body,
-        }).raise_for_status()
+        return send_sms('Your Sentry authentication code is %s.' % code,
+                        to=self.phone_number)
 
 
 class Authenticator(BaseModel):
diff --git a/src/sentry/options/defaults.py b/src/sentry/options/defaults.py
index 3c2de0627e..d48952b984 100644
--- a/src/sentry/options/defaults.py
+++ b/src/sentry/options/defaults.py
@@ -63,7 +63,7 @@ register('mail.enable-replies', default=False, flags=FLAG_PRIORITIZE_DISK)
 register('mail.reply-hostname', default='', flags=FLAG_ALLOW_EMPTY | FLAG_PRIORITIZE_DISK)
 register('mail.mailgun-api-key', default='', flags=FLAG_ALLOW_EMPTY | FLAG_PRIORITIZE_DISK)
 
-# 2FA
-register('2fa.twilio_account', default='', flags=FLAG_ALLOW_EMPTY)
-register('2fa.twilio_token', default='', flags=FLAG_ALLOW_EMPTY)
-register('2fa.twilio_number', default='', flags=FLAG_ALLOW_EMPTY)
+# SMS
+register('sms.twilio_account', default='', flags=FLAG_ALLOW_EMPTY)
+register('sms.twilio_token', default='', flags=FLAG_ALLOW_EMPTY)
+register('sms.twilio_number', default='', flags=FLAG_ALLOW_EMPTY)
diff --git a/src/sentry/templates/sentry/account/twofactor/configure_sms.html b/src/sentry/templates/sentry/account/twofactor/configure_sms.html
index e885048960..42a29eea14 100644
--- a/src/sentry/templates/sentry/account/twofactor/configure_sms.html
+++ b/src/sentry/templates/sentry/account/twofactor/configure_sms.html
@@ -7,6 +7,6 @@
   {{ block.super }}
 
   {% if auth.is_enrolled %}
-  <p>Confirmation codes are sent to the following phone: <strong>{{ auth.config.phone_number }}</strong></p>
+  <p>Confirmation codes are sent to the following phone: <strong>{{ auth.phone_number }}</strong></p>
   {% endif %}
 {% endblock %}
diff --git a/src/sentry/templates/sentry/account/twofactor/enroll_sms.html b/src/sentry/templates/sentry/account/twofactor/enroll_sms.html
index c1e2d084ca..42d9105db7 100644
--- a/src/sentry/templates/sentry/account/twofactor/enroll_sms.html
+++ b/src/sentry/templates/sentry/account/twofactor/enroll_sms.html
@@ -20,9 +20,9 @@
         {{ field|as_crispy_field }}
       {% endfor %}
     {% elif stage == 'confirm' %}
-      <p>Sent confirmation code to <strong>{{ auth.config.phone_number }}</strong>:</p>
+      <p>Sent confirmation code to <strong>{{ auth.phone_number }}</strong>:</p>
       <input type="hidden" name="stage" value="confirm">
-      <input type="hidden" name="phone_number" value="{{ auth.config.phone_number }}">
+      <input type="hidden" name="phone_number" value="{{ auth.phone_number }}">
       {{ otp_form|as_crispy_errors }}
       {% for field in otp_form %}
         {{ field|as_crispy_field }}
@@ -34,10 +34,10 @@
       {% csrf_token %}
 
       <input type="hidden" name="enroll">
-      <input type="hidden" name="totp_secret" value="{{ auth.config.secret }}">
+      <input type="hidden" name="totp_secret" value="{{ auth.secret }}">
       <div>
         <a href="{% url 'sentry-account-settings-2fa-totp' %}" class="btn btn-default">{% trans "Cancel" %}</a>
-        {% if not auth.config.phone_number %}
+        {% if not auth.phone_number %}
         <button type="submit" class="btn btn-primary">{% trans "Send Confirmation Code" %}</button> 
         {% else %}
         <button type="submit" class="btn btn-primary">{% trans "Confirm" %}</button> 
diff --git a/src/sentry/templates/sentry/account/twofactor/enroll_totp.html b/src/sentry/templates/sentry/account/twofactor/enroll_totp.html
index 5f2253a825..df100e5e0a 100644
--- a/src/sentry/templates/sentry/account/twofactor/enroll_totp.html
+++ b/src/sentry/templates/sentry/account/twofactor/enroll_totp.html
@@ -32,7 +32,7 @@
       {% endfor %}
 
       <input type="hidden" name="enroll">
-      <input type="hidden" name="totp_secret" value="{{ auth.config.secret }}">
+      <input type="hidden" name="totp_secret" value="{{ auth.secret }}">
       <div>
         <a href="{% url 'sentry-account-settings-2fa-totp' %}" class="btn btn-default">{% trans "Cancel" %}</a>
         <button type="submit" class="btn btn-primary">{% trans "Confirm" %}</button> 
diff --git a/src/sentry/utils/sms.py b/src/sentry/utils/sms.py
new file mode 100644
index 0000000000..bafa08f7d8
--- /dev/null
+++ b/src/sentry/utils/sms.py
@@ -0,0 +1,35 @@
+from __future__ import absolute_import
+
+import urllib
+import logging
+import requests
+
+from sentry import options
+
+
+logger = logging.getLogger(__name__)
+
+
+def sms_available():
+    return bool(options.get('sms.twilio_account'))
+
+
+def send_sms(body, to, from_=None):
+    account = options.get('sms.twilio_account')
+    if not account:
+        raise RuntimeError('SMS backend is not configured.')
+    if account[:2] != 'AC':
+        account = 'AC' + account
+    url = 'https://api.twilio.com/2010-04-01/Accounts/%s/Messages.json' % \
+        urllib.quote(account)
+    rv = requests.post(url, auth=(account,
+                             options.get('sms.twilio_token')), data={
+        'To': to,
+        'From': options.get('sms.twilio_number'),
+        'Body': body,
+    })
+    if not rv.ok:
+        logging.exception('Failed to send text message to %s: (%s) %s', to,
+                          rv.status_code, rv.content)
+        return False
+    return True
diff --git a/src/sentry/web/frontend/accounts_twofactor.py b/src/sentry/web/frontend/accounts_twofactor.py
index 2ec7ad5349..e909253331 100644
--- a/src/sentry/web/frontend/accounts_twofactor.py
+++ b/src/sentry/web/frontend/accounts_twofactor.py
@@ -1,6 +1,6 @@
 from django import forms
 from django.db import transaction
-from django.http import HttpResponseRedirect
+from django.http import HttpResponseRedirect, Http404
 from django.core.urlresolvers import reverse
 from django.views.decorators.csrf import csrf_protect
 from django.views.decorators.cache import never_cache
@@ -33,8 +33,11 @@ class TwoFactorSettingsView(BaseView):
     @method_decorator(sudo_required)
     @method_decorator(transaction.atomic)
     def handle(self, request):
-        interface = Authenticator.objects.get_interface(
-            request.user, self.interface_id)
+        try:
+            interface = Authenticator.objects.get_interface(
+                request.user, self.interface_id)
+        except LookupError:
+            raise Http404
         if 'remove' in request.POST:
             return self.remove(request, interface)
         return self.configure(request, interface)
@@ -120,7 +123,7 @@ class TotpSettingsView(TwoFactorSettingsView):
     def enroll(self, request, interface, insecure=False):
         totp_secret = request.POST.get('totp_secret')
         if totp_secret is not None:
-            interface.set_secret(totp_secret)
+            interface.secret = totp_secret
 
         if 'otp' in request.POST:
             form = TwoFactorForm(request.POST)
@@ -149,11 +152,11 @@ class SmsSettingsView(TwoFactorSettingsView):
 
         totp_secret = request.POST.get('totp_secret')
         if totp_secret is not None:
-            interface.set_secret(totp_secret)
+            interface.secret = totp_secret
 
         phone_number = request.POST.get('phone_number')
         if phone_number is not None:
-            interface.set_phone_number(phone_number)
+            interface.phone_number = phone_number
 
         sms_form = SmsForm()
         otp_form = TwoFactorForm()
diff --git a/src/sentry/web/frontend/twofactor.py b/src/sentry/web/frontend/twofactor.py
index 85a20b5b50..9d2d3ad662 100644
--- a/src/sentry/web/frontend/twofactor.py
+++ b/src/sentry/web/frontend/twofactor.py
@@ -32,8 +32,7 @@ class TwoFactorAuthView(BaseView):
         for idx, interface in enumerate(all):
             if interface.interface_id == selected.interface_id:
                 continue
-            if idx == 0 or \
-               interface.requires_otp_flow_activation:
+            if idx == 0 or interface.requires_activation:
                 rv.append(interface)
         return rv
 
@@ -51,7 +50,7 @@ class TwoFactorAuthView(BaseView):
 
         interface = self.negotiate_interface(request, interfaces)
         if request.method == 'GET':
-            activation_message = interface.on_otp_flow_activation(request)
+            activation_message = interface.activate(request)
 
         otp = request.POST.get('otp')
         if otp:

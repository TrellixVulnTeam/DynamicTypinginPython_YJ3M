commit 46ac3ab245f26112c3c15a1b1091b92857fe42bb
Author: Ted Kaemming <ted@kaemming.com>
Date:   Mon Nov 30 15:49:56 2015 -0800

    Move quota checks to Lua script.

diff --git a/src/sentry/quotas/base.py b/src/sentry/quotas/base.py
index d309a7bbc0..6da343b7d1 100644
--- a/src/sentry/quotas/base.py
+++ b/src/sentry/quotas/base.py
@@ -76,8 +76,5 @@ class Quota(object):
     def get_organization_quota(self, organization):
         return self.translate_quota(
             settings.SENTRY_DEFAULT_MAX_EVENTS_PER_MINUTE,
-            self.get_system_quota()
+            settings.SENTRY_SYSTEM_MAX_EVENTS_PER_MINUTE,
         )
-
-    def get_system_quota(self):
-        return settings.SENTRY_SYSTEM_MAX_EVENTS_PER_MINUTE
diff --git a/src/sentry/quotas/redis.py b/src/sentry/quotas/redis.py
index 212eb38d0b..24ee2fa589 100644
--- a/src/sentry/quotas/redis.py
+++ b/src/sentry/quotas/redis.py
@@ -10,12 +10,46 @@ from __future__ import absolute_import
 import time
 
 from django.conf import settings
+from redis.client import Script
 
 from sentry.exceptions import InvalidConfiguration
 from sentry.quotas.base import Quota, RateLimited, NotRateLimited
 from sentry.utils.redis import make_rb_cluster
 
 
+# Check a collection of quota counters to identify if an item should be rate
+# limited. Values provided as ``KEYS`` specify the keys of the counters to
+# check, and values provided as ``ARGV`` specify the maximum value (quota
+# limit) for the key at the same array index. (``KEYS`` and ``ARGV`` must be
+# the same length.) If all checks pass (the item is accepted), all counters are
+# incremented. If any checks fail (the item is rejected), all counters are
+# unaffected. The result is a Lua table/array (Redis multi bulk reply) that
+# specifies whether or not the item was *rejected* based on the provided limit.
+IS_RATE_LIMITED_SCRIPT = """\
+assert(#KEYS == #ARGV, "unequal number of keys and arguments provided")
+
+local results = {}
+local failed = false
+for i=1,#ARGV do
+    local rejected = (redis.call('GET', KEYS[i]) or 0) + 1 > tonumber(ARGV[i])
+    if rejected then
+        failed = true
+    end
+    results[i] = rejected
+end
+
+if not failed then
+    for i=1,#ARGV do
+        redis.call('INCR', KEYS[i])
+    end
+end
+
+return results
+"""
+
+is_rate_limited = Script(None, IS_RATE_LIMITED_SCRIPT)
+
+
 class RedisQuota(Quota):
     ttl = 60
 
@@ -34,36 +68,31 @@ class RedisQuota(Quota):
         except Exception as e:
             raise InvalidConfiguration(unicode(e))
 
-    def is_rate_limited(self, project):
-        proj_quota = self.get_project_quota(project)
-        if project.team:
-            team_quota = self.get_team_quota(project.team)
-        else:
-            team_quota = 0
-        system_quota = self.get_system_quota()
+    def _get_quotas(self, project):
+        return filter(
+            lambda (key, value): value > 0,  # a zero quota means "no quota"
+            (
+                (self._get_team_key(project.team), self.get_team_quota(project.team)),
+                (self._get_project_key(project), self.get_project_quota(project)),
+                (self._get_organization_key(project.organization), self.get_organization_quota(project.organization)),
+            )
+        )
 
-        if not (proj_quota or system_quota or team_quota):
+    def is_rate_limited(self, project):
+        # If there are no quotas to actually check, skip the trip to the database.
+        quotas = self._get_quotas(project)
+        if not quotas:
             return NotRateLimited
 
-        sys_result, team_result, proj_result = self._incr_project(project)
-
-        if proj_quota and proj_result > proj_quota:
+        keys, args = zip(*quotas)
+        client = self.cluster.get_local_client_for_key(self._get_organization_key(project.organization))
+        if any(is_rate_limited(keys, args, client=client)):
             return RateLimited(retry_after=self.get_time_remaining())
-
-        if team_quota and team_result > team_quota:
-            return RateLimited(retry_after=self.get_time_remaining())
-
-        if system_quota and sys_result > system_quota:
-            return RateLimited(retry_after=self.get_time_remaining())
-
-        return NotRateLimited
+        else:
+            return NotRateLimited
 
     def get_time_remaining(self):
-        return int(self.ttl - (
-            time.time() - int(time.time() / self.ttl) * self.ttl))
-
-    def _get_system_key(self):
-        return 'quota:s:%s' % (int(time.time() / self.ttl),)
+        return int(self.ttl - (time.time() - int(time.time() / self.ttl) * self.ttl))
 
     def _get_team_key(self, team):
         return 'quota:t:%s:%s' % (team.id, int(time.time() / self.ttl))
@@ -71,26 +100,5 @@ class RedisQuota(Quota):
     def _get_project_key(self, project):
         return 'quota:p:%s:%s' % (project.id, int(time.time() / self.ttl))
 
-    def _incr_project(self, project):
-        if project.team:
-            team_key = self._get_team_key(project.team)
-        else:
-            team_key = None
-            team_result = None
-
-        proj_key = self._get_project_key(project)
-        sys_key = self._get_system_key()
-        with self.cluster.map() as client:
-            proj_result = client.incr(proj_key)
-            client.expire(proj_key, self.ttl)
-            sys_result = client.incr(sys_key)
-            client.expire(sys_key, self.ttl)
-            if team_key:
-                team_result = client.incr(team_key)
-                client.expire(team_key, self.ttl)
-
-        return (
-            int(sys_result.value),
-            int(team_result and team_result.value or 0),
-            int(proj_result.value),
-        )
+    def _get_organization_key(self, organization):
+        return 'quota:o:%s:%s' % (organization.id, int(time.time() / self.ttl))
diff --git a/src/sentry/web/frontend/project_quotas.py b/src/sentry/web/frontend/project_quotas.py
index 1957d070f0..19801643de 100644
--- a/src/sentry/web/frontend/project_quotas.py
+++ b/src/sentry/web/frontend/project_quotas.py
@@ -42,8 +42,8 @@ class ProjectQuotasView(ProjectView):
             'page': 'quotas',
             # TODO(dcramer): has_quotas is an awful hack
             'has_quotas': type(app.quotas) != Quota,
-            'system_quota': int(app.quotas.get_system_quota()),
             'team_quota': int(app.quotas.get_team_quota(project.team)),
+            'organization_quota': int(app.quotas.get_organization_quota(project.organization)),
             'project': project,
             'form': form,
         }
diff --git a/tests/sentry/quotas/redis/tests.py b/tests/sentry/quotas/redis/tests.py
index 4f333ceda2..92e35238fc 100644
--- a/tests/sentry/quotas/redis/tests.py
+++ b/tests/sentry/quotas/redis/tests.py
@@ -4,12 +4,39 @@ from __future__ import absolute_import
 
 import mock
 
+from redis.client import (
+    Script,
+    StrictRedis,
+)
 from exam import fixture, patcher
 
-from sentry.quotas.redis import RedisQuota
+from sentry.quotas.redis import (
+    IS_RATE_LIMITED_SCRIPT,
+    RedisQuota,
+)
 from sentry.testutils import TestCase
 
 
+def test_is_rate_limited_script():
+    client = StrictRedis(db=9)
+    script = Script(client, IS_RATE_LIMITED_SCRIPT)
+
+    # The item should not be rate limited by either key.
+    assert map(bool, script(('foo', 'bar'), (1, 2))) == [False, False]
+
+    # The item should be rate limited by the first key (1).
+    assert map(bool, script(('foo', 'bar'), (1, 2))) == [True, False]
+
+    # The item should still be rate limited by the first key (1), but *not*
+    # rate limited by the second key (2) even though this is the third time
+    # we've checked the quotas. This ensures items that are rejected by a lower
+    # quota don't affect unrelated items that share a parent quota.
+    assert map(bool, script(('foo', 'bar'), (1, 2))) == [True, False]
+
+    client.get('foo') == '1'
+    client.get('bar') == '1'
+
+
 class RedisQuotaTest(TestCase):
     @fixture
     def quota(self):
@@ -18,12 +45,6 @@ class RedisQuotaTest(TestCase):
         })
         return inst
 
-    @patcher.object(RedisQuota, 'get_system_quota')
-    def get_system_quota(self):
-        inst = mock.MagicMock()
-        inst.return_value = 0
-        return inst
-
     @patcher.object(RedisQuota, 'get_team_quota')
     def get_team_quota(self):
         inst = mock.MagicMock()
@@ -36,10 +57,10 @@ class RedisQuotaTest(TestCase):
         inst.return_value = 0
         return inst
 
-    @patcher.object(RedisQuota, '_incr_project')
-    def _incr_project(self):
+    @patcher.object(RedisQuota, 'get_organization_quota')
+    def get_organization_quota(self):
         inst = mock.MagicMock()
-        inst.return_value = (0, 0, 0)
+        inst.return_value = 0
         return inst
 
     def test_default_host_is_local(self):
@@ -47,52 +68,35 @@ class RedisQuotaTest(TestCase):
         self.assertEquals(len(quota.cluster.hosts), 1)
         self.assertEquals(quota.cluster.hosts[0].host, 'localhost')
 
-    def test_bails_immediately_without_any_quota(self):
-        self._incr_project.return_value = (0, 0, 0)
-
-        result = self.quota.is_rate_limited(self.project)
-
-        assert not self._incr_project.called
-        assert not result.is_limited
-
-    def test_enforces_project_quota(self):
-        self.get_project_quota.return_value = 100
-        self._incr_project.return_value = (0, 0, 101)
-
-        result = self.quota.is_rate_limited(self.project)
-
-        assert result.is_limited
-
-        self._incr_project.return_value = (0, 0, 99)
+    def test_skips_unset_quotas(self):
+        # This assumes ``get_*_quota`` methods are mocked.
+        assert set(self.quota._get_quotas(self.project)) == set()
 
-        result = self.quota.is_rate_limited(self.project)
-
-        assert not result.is_limited
-
-    def test_enforces_team_quota(self):
+    def test_uses_defined_quotas(self):
         self.get_team_quota.return_value = 100
-        self._incr_project.return_value = (0, 101, 0)
-
+        self.get_project_quota.return_value = 200
+        self.get_organization_quota.return_value = 300
+        assert set(self.quota._get_quotas(self.project)) == set((
+            (self.quota._get_team_key(self.project.team), 100),
+            (self.quota._get_project_key(self.project), 200),
+            (self.quota._get_organization_key(self.project.team), 300),
+        ))
+
+    @mock.patch('sentry.quotas.redis.is_rate_limited')
+    def test_bails_immediately_without_any_quota(self, is_rate_limited):
+        # This assumes ``get_*_quota`` methods are mocked.
         result = self.quota.is_rate_limited(self.project)
-
-        assert result.is_limited
-
-        self._incr_project.return_value = (0, 99, 0)
-
-        result = self.quota.is_rate_limited(self.project)
-
+        assert not is_rate_limited.called
         assert not result.is_limited
 
-    def test_enforces_system_quota(self):
-        self.get_system_quota.return_value = 100
-        self._incr_project.return_value = (101, 0, 0)
-
-        result = self.quota.is_rate_limited(self.project)
-
-        assert result.is_limited
-
-        self._incr_project.return_value = (99, 0, 0)
-
-        result = self.quota.is_rate_limited(self.project)
+    @mock.patch('sentry.quotas.redis.is_rate_limited', return_value=(False, False))
+    def test_is_not_limited_without_rejections(self, is_rate_limited):
+        self.get_team_quota.return_value = 100
+        self.get_project_quota.return_value = 200
+        assert not self.quota.is_rate_limited(self.project).is_limited
 
-        assert not result.is_limited
+    @mock.patch('sentry.quotas.redis.is_rate_limited', return_value=(True, False))
+    def test_is_limited_on_rejections(self, is_rate_limited):
+        self.get_team_quota.return_value = 100
+        self.get_project_quota.return_value = 200
+        assert self.quota.is_rate_limited(self.project).is_limited

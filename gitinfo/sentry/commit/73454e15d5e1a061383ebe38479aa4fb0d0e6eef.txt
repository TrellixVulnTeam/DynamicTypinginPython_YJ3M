commit 73454e15d5e1a061383ebe38479aa4fb0d0e6eef
Author: MeredithAnya <meredith.a.heller@gmail.com>
Date:   Wed Feb 5 14:32:55 2020 -0800

    fix(slack): Look up channel id async to avoid timeouts (#16738)
    
    * fix(slack): Look up channel id async to avoid timeouts

diff --git a/src/sentry/api/endpoints/project_rule_details.py b/src/sentry/api/endpoints/project_rule_details.py
index 295a2eb76f..50ea64b7b5 100644
--- a/src/sentry/api/endpoints/project_rule_details.py
+++ b/src/sentry/api/endpoints/project_rule_details.py
@@ -6,6 +6,8 @@ from rest_framework.response import Response
 from sentry.api.bases.project import ProjectEndpoint, ProjectSettingPermission
 from sentry.api.serializers import serialize
 from sentry.api.serializers.rest_framework.rule import RuleSerializer
+from sentry.integrations.slack import tasks
+from sentry.mediators import project_rules
 from sentry.models import AuditLogEntryEvent, Rule, RuleStatus
 
 
@@ -46,16 +48,36 @@ class ProjectRuleDetailsEndpoint(ProjectEndpoint):
         serializer = RuleSerializer(context={"project": project}, data=request.data, partial=True)
 
         if serializer.is_valid():
-            rule = serializer.save(rule=rule)
+            data = serializer.validated_data
+            kwargs = {
+                "name": data["name"],
+                "environment": data.get("environment"),
+                "project": project,
+                "action_match": data["actionMatch"],
+                "conditions": data["conditions"],
+                "actions": data["actions"],
+                "frequency": data.get("frequency"),
+            }
+
+            if data.get("pending_save"):
+                client = tasks.RedisRuleStatus()
+                kwargs.update({"uuid": client.uuid, "rule_id": rule.id})
+                tasks.find_channel_id_for_rule.apply_async(kwargs=kwargs)
+
+                context = {"uuid": client.uuid}
+                return Response(context, status=202)
+
+            updated_rule = project_rules.Updater.run(rule=rule, request=request, **kwargs)
+
             self.create_audit_entry(
                 request=request,
                 organization=project.organization,
-                target_object=rule.id,
+                target_object=updated_rule.id,
                 event=AuditLogEntryEvent.RULE_EDIT,
-                data=rule.get_audit_log_data(),
+                data=updated_rule.get_audit_log_data(),
             )
 
-            return Response(serialize(rule, request.user))
+            return Response(serialize(updated_rule, request.user))
 
         return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
 
diff --git a/src/sentry/api/endpoints/project_rule_task_details.py b/src/sentry/api/endpoints/project_rule_task_details.py
new file mode 100644
index 0000000000..6e77f9ae6e
--- /dev/null
+++ b/src/sentry/api/endpoints/project_rule_task_details.py
@@ -0,0 +1,46 @@
+from __future__ import absolute_import
+
+from django.http import Http404
+from rest_framework.response import Response
+
+from sentry.api.bases.project import ProjectEndpoint, ProjectSettingPermission
+from sentry.api.serializers import serialize
+from sentry.integrations.slack import tasks
+from sentry.models import Rule, RuleStatus
+
+
+class ProjectRuleTaskDetailsEndpoint(ProjectEndpoint):
+    permission_classes = [ProjectSettingPermission]
+
+    def get(self, request, project, task_uuid):
+        """
+        Retrieve the status of the async task
+
+        Return details of the rule if the task is successful
+
+        """
+        client = tasks.RedisRuleStatus(task_uuid)
+        result = client.get_value()
+
+        status = result["status"]
+        rule_id = result.get("rule_id")
+        error = result.get("error")
+
+        # if the status is "pending" we don't have a rule yet or error
+        context = {"status": status, "rule": None, "error": None}
+
+        if rule_id and status == "success":
+            try:
+                rule = Rule.objects.get(
+                    project=project,
+                    id=int(rule_id),
+                    status__in=[RuleStatus.ACTIVE, RuleStatus.INACTIVE],
+                )
+                context["rule"] = serialize(rule, request.user)
+            except Rule.DoesNotExist:
+                raise Http404
+
+        if status == "failed":
+            context["error"] = error
+
+        return Response(context, status=200)
diff --git a/src/sentry/api/endpoints/project_rules.py b/src/sentry/api/endpoints/project_rules.py
index d8d86c4122..c73d52ad2a 100644
--- a/src/sentry/api/endpoints/project_rules.py
+++ b/src/sentry/api/endpoints/project_rules.py
@@ -1,11 +1,14 @@
 from __future__ import absolute_import
 
+
 from rest_framework import status
 from rest_framework.response import Response
 
 from sentry.api.bases.project import ProjectEndpoint
 from sentry.api.serializers import serialize
 from sentry.api.serializers.rest_framework import RuleSerializer
+from sentry.integrations.slack import tasks
+from sentry.mediators import project_rules
 from sentry.models import AuditLogEntryEvent, Rule, RuleStatus
 from sentry.signals import alert_rule_created
 
@@ -49,7 +52,26 @@ class ProjectRulesEndpoint(ProjectEndpoint):
         serializer = RuleSerializer(context={"project": project}, data=request.data)
 
         if serializer.is_valid():
-            rule = serializer.save(rule=Rule())
+            data = serializer.validated_data
+            kwargs = {
+                "name": data["name"],
+                "environment": data.get("environment"),
+                "project": project,
+                "action_match": data["actionMatch"],
+                "conditions": data["conditions"],
+                "actions": data["actions"],
+                "frequency": data.get("frequency"),
+            }
+
+            if data.get("pending_save"):
+                client = tasks.RedisRuleStatus()
+                uuid_context = {"uuid": client.uuid}
+                kwargs.update(uuid_context)
+                tasks.find_channel_id_for_rule.apply_async(kwargs=kwargs)
+                return Response(uuid_context, status=202)
+
+            rule = project_rules.Creator.run(request=request, **kwargs)
+
             self.create_audit_entry(
                 request=request,
                 organization=project.organization,
diff --git a/src/sentry/api/serializers/rest_framework/rule.py b/src/sentry/api/serializers/rest_framework/rule.py
index 56f0b12510..27fb6005bb 100644
--- a/src/sentry/api/serializers/rest_framework/rule.py
+++ b/src/sentry/api/serializers/rest_framework/rule.py
@@ -56,6 +56,8 @@ class RuleNodeField(serializers.Field):
         # Update data from cleaned form values
         data.update(form.cleaned_data)
 
+        if getattr(form, "_pending_save", False):
+            data["pending_save"] = True
         return data
 
 
@@ -92,6 +94,20 @@ class RuleSerializer(serializers.Serializer):
             raise serializers.ValidationError(u"Must select an action")
         return value
 
+    def validate(self, attrs):
+        # XXX(meredith): For rules that have the Slack integration as an action
+        # we need to check if the channel_id needs to be looked up via an async task.
+        # If the "pending_save" attribute is set we want to bubble that up to the
+        # project_rule(_details) endpoints by setting it on attrs
+        actions = attrs.get("actions")
+        if actions:
+            for action in actions:
+                if action.pop("pending_save", None):
+                    attrs["pending_save"] = True
+                    break
+
+        return attrs
+
     def save(self, rule):
         rule.project = self.context["project"]
         if "environment" in self.validated_data:
diff --git a/src/sentry/api/urls.py b/src/sentry/api/urls.py
index bdcafcd720..04159f704c 100644
--- a/src/sentry/api/urls.py
+++ b/src/sentry/api/urls.py
@@ -202,6 +202,7 @@ from .endpoints.project_releases import ProjectReleasesEndpoint
 from .endpoints.project_releases_token import ProjectReleasesTokenEndpoint
 from .endpoints.project_reprocessing import ProjectReprocessingEndpoint
 from .endpoints.project_rule_details import ProjectRuleDetailsEndpoint
+from .endpoints.project_rule_task_details import ProjectRuleTaskDetailsEndpoint
 from .endpoints.project_rules import ProjectRulesEndpoint
 from .endpoints.project_rules_configuration import ProjectRulesConfigurationEndpoint
 from .endpoints.project_search_details import ProjectSearchDetailsEndpoint
@@ -1313,6 +1314,11 @@ urlpatterns = [
                     ProjectRuleDetailsEndpoint.as_view(),
                     name="sentry-api-0-project-rule-details",
                 ),
+                url(
+                    r"^(?P<organization_slug>[^\/]+)/(?P<project_slug>[^\/]+)/rule-task/(?P<task_uuid>[^\/]+)/$",
+                    ProjectRuleTaskDetailsEndpoint.as_view(),
+                    name="sentry-api-0-project-rule-task-details",
+                ),
                 url(
                     r"^(?P<organization_slug>[^\/]+)/(?P<project_slug>[^\/]+)/searches/$",
                     ProjectSearchesEndpoint.as_view(),
diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index 48e2784f18..bc5a4f9d2e 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -1049,12 +1049,10 @@ def create_alert_rule_trigger_action(
         if target_type != AlertRuleTriggerAction.TargetType.SPECIFIC:
             raise InvalidTriggerActionError("Slack action must specify channel")
 
-        channel_result = get_channel_id(
+        prefix, channel_id, _ = get_channel_id(
             trigger.alert_rule.organization, integration.id, target_identifier
         )
-        if channel_result is not None:
-            channel_id = channel_result[1]
-        else:
+        if channel_id is None:
             raise InvalidTriggerActionError(
                 "Could not find channel %s. Channel may not exist, or Sentry may not "
                 "have been granted permission to access it" % target_identifier
@@ -1101,11 +1099,11 @@ def update_alert_rule_trigger_action(
             from sentry.integrations.slack.utils import get_channel_id
 
             integration = updated_fields.get("integration", trigger_action.integration)
-            channel_id = get_channel_id(
+            prefix, channel_id, _ = get_channel_id(
                 trigger_action.alert_rule_trigger.alert_rule.organization,
                 integration.id,
                 target_identifier,
-            )[1]
+            )
             # Use the channel name for display
             updated_fields["target_display"] = target_identifier
             updated_fields["target_identifier"] = channel_id
diff --git a/src/sentry/integrations/slack/notify_action.py b/src/sentry/integrations/slack/notify_action.py
index b20c961c05..cf3be88a29 100644
--- a/src/sentry/integrations/slack/notify_action.py
+++ b/src/sentry/integrations/slack/notify_action.py
@@ -30,15 +30,25 @@ class SlackNotifyServiceForm(forms.Form):
         self.fields["workspace"].choices = workspace_list
         self.fields["workspace"].widget.choices = self.fields["workspace"].choices
 
+        # XXX(meredith): When this gets set to True, it lets the RuleSerializer
+        # know to only save if and when we have the channel_id. The rule will get saved
+        # in the task (integrations/slack/tasks.py) if the channel_id is found.
+        self._pending_save = False
+
     def clean(self):
         cleaned_data = super(SlackNotifyServiceForm, self).clean()
 
         workspace = cleaned_data.get("workspace")
         channel = cleaned_data.get("channel", "")
 
-        channel_id = self.channel_transformer(workspace, channel)
+        channel_prefix, channel_id, timed_out = self.channel_transformer(workspace, channel)
         channel = strip_channel_name(channel)
 
+        if channel_id is None and timed_out:
+            cleaned_data["channel"] = channel_prefix + channel
+            self._pending_save = True
+            return cleaned_data
+
         if channel_id is None and workspace is not None:
             params = {
                 "channel": channel,
@@ -53,7 +63,6 @@ class SlackNotifyServiceForm(forms.Form):
                 params=params,
             )
 
-        channel_prefix, channel_id = channel_id
         cleaned_data["channel"] = channel_prefix + channel
         cleaned_data["channel_id"] = channel_id
 
diff --git a/src/sentry/integrations/slack/tasks.py b/src/sentry/integrations/slack/tasks.py
new file mode 100644
index 0000000000..0866c2c21d
--- /dev/null
+++ b/src/sentry/integrations/slack/tasks.py
@@ -0,0 +1,121 @@
+from __future__ import absolute_import
+
+import six
+from uuid import uuid4
+
+from django.conf import settings
+
+from sentry.utils import json
+from sentry.tasks.base import instrumented_task
+from sentry.mediators import project_rules
+from sentry.models import Integration, Project, Rule
+from sentry.integrations.slack.utils import get_channel_id_with_timeout, strip_channel_name
+from sentry.utils.redis import redis_clusters
+
+
+class RedisRuleStatus(object):
+    def __init__(self, uuid=None):
+        self._uuid = uuid or self._generate_uuid()
+
+        cluster_id = getattr(settings, "SENTRY_RULE_TASK_REDIS_CLUSTER", "default")
+        self.client = redis_clusters.get(cluster_id)
+        self._set_inital_value()
+
+    @property
+    def uuid(self):
+        return self._uuid
+
+    def set_value(self, status, rule_id=None):
+        value = self._format_value(status, rule_id)
+        self.client.set(self._get_redis_key(), u"{}".format(value), ex=60 * 60)
+
+    def get_value(self):
+        key = self._get_redis_key()
+        value = self.client.get(key)
+        return json.loads(value)
+
+    def _generate_uuid(self):
+        return uuid4().hex
+
+    def _set_inital_value(self):
+        value = json.dumps({"status": "pending"})
+        self.client.set(self._get_redis_key(), u"{}".format(value), ex=60 * 60, nx=True)
+
+    def _get_redis_key(self):
+        return u"slack-channel-task:1:{}".format(self.uuid)
+
+    def _format_value(self, status, rule_id):
+        value = {"status": status}
+        if rule_id:
+            value["rule_id"] = six.text_type(rule_id)
+        if status == "failed":
+            value[
+                "error"
+            ] = "The slack resource does not exist or has not been granted access in that workspace."
+
+        return json.dumps(value)
+
+
+@instrumented_task(name="sentry.integrations.slack.search_channel_id", queue="integrations")
+def find_channel_id_for_rule(
+    name, environment, project, action_match, conditions, actions, frequency, uuid, rule_id=None
+):
+    redis_rule_status = RedisRuleStatus(uuid)
+
+    try:
+        project = Project.objects.get(id=project.id)
+    except Project.DoesNotExist:
+        redis_rule_status.set_value("failed")
+        return
+
+    organization = project.organization
+    integration_id = None
+    channel_name = None
+
+    for action in actions:
+        if action.get("workspace") and action.get("channel"):
+            integration_id = action["workspace"]
+            # we need to strip the prefix when searching on the channel name
+            channel_name = strip_channel_name(action["channel"])
+            break
+
+    try:
+        integration = Integration.objects.get(
+            provider="slack", organizations=organization, id=integration_id
+        )
+    except Integration.DoesNotExist:
+        redis_rule_status.set_value("failed")
+        return
+
+    # we dont' know exactly how long it will take to paginate through all of the slack
+    # endpoints but need some time limit imposed. 3 minutes should be more than enough time,
+    # we can always update later
+    (prefix, item_id, _timed_out) = get_channel_id_with_timeout(integration, channel_name, 3 * 60)
+
+    if item_id:
+        for action in actions:
+            # need to make sure we are adding back the right prefix
+            if action.get("channel") and strip_channel_name(action.get("channel")) == channel_name:
+                action["channel"] = prefix + channel_name
+                break
+
+        kwargs = {
+            "name": name,
+            "environment": environment,
+            "project": project,
+            "action_match": action_match,
+            "conditions": conditions,
+            "actions": actions,
+            "frequency": frequency,
+        }
+
+        if rule_id:
+            rule = Rule.objects.get(id=rule_id)
+            rule = project_rules.Updater.run(rule=rule, pending_save=False, **kwargs)
+        else:
+            rule = project_rules.Creator.run(pending_save=False, **kwargs)
+
+        redis_rule_status.set_value("success", rule.id)
+        return
+    # if we never find the channel name we failed :(
+    redis_rule_status.set_value("failed")
diff --git a/src/sentry/integrations/slack/utils.py b/src/sentry/integrations/slack/utils.py
index 87d05e6bd8..0e335b6d98 100644
--- a/src/sentry/integrations/slack/utils.py
+++ b/src/sentry/integrations/slack/utils.py
@@ -1,6 +1,7 @@
 from __future__ import absolute_import
 
 import logging
+import time
 
 from django.core.cache import cache
 from django.core.urlresolvers import reverse
@@ -41,6 +42,7 @@ LEVEL_TO_COLOR = {
 MEMBER_PREFIX = "@"
 CHANNEL_PREFIX = "#"
 strip_channel_chars = "".join([MEMBER_PREFIX, CHANNEL_PREFIX])
+SLACK_DEFAULT_TIMEOUT = 10
 
 
 def format_actor_option(actor):
@@ -336,13 +338,6 @@ def strip_channel_name(name):
 
 
 def get_channel_id(organization, integration_id, name):
-    """
-    Fetches the internal slack id of a channel.
-    :param organization: The organization that is using this integration
-    :param integration_id: The integration id of this slack integration
-    :param name: The name of the channel
-    :return:
-    """
     name = strip_channel_name(name)
     try:
         integration = Integration.objects.get(
@@ -351,32 +346,60 @@ def get_channel_id(organization, integration_id, name):
     except Integration.DoesNotExist:
         return None
 
+    # XXX(meredith): For large accounts that have many, many channels it's
+    # possible for us to timeout while attempting to paginate through to find the channel id
+    # This means some users are unable to create/update alert rules. To avoid this, we attempt
+    # to find the channel id asynchronously if it takes longer than a certain amount of time,
+    # which I have set as the SLACK_DEFAULT_TIMEOUT - arbitrarily - to 10 seconds.
+    return get_channel_id_with_timeout(integration, name, SLACK_DEFAULT_TIMEOUT)
+
+
+def get_channel_id_with_timeout(integration, name, timeout):
+    """
+    Fetches the internal slack id of a channel.
+    :param organization: The organization that is using this integration
+    :param integration_id: The integration id of this slack integration
+    :param name: The name of the channel
+    :return: a tuple of three values
+        1. prefix: string (`"#"` or `"@"`)
+        2. channel_id: string or `None`
+        3. timed_out: boolean (whether we hit our self-imposed time limit)
+    """
+
     token_payload = {"token": integration.metadata["access_token"]}
 
     # Look for channel ID
     payload = dict(token_payload, **{"exclude_archived": False, "exclude_members": True})
 
+    time_to_quit = time.time() + timeout
     session = http.build_session()
     for list_type, result_name, prefix in LIST_TYPES:
-        # Slack limits the response of `<list_type>.list` to 1000 channels, paginate if
-        # needed
         cursor = ""
-        while cursor is not None:
+        while True:
             items = session.get(
                 "https://slack.com/api/%s.list" % list_type,
-                params=dict(payload, **{"cursor": cursor}),
+                # Slack limits the response of `<list_type>.list` to 1000 channels
+                params=dict(payload, **{"cursor": cursor, "limit": 1000}),
             )
             items = items.json()
             if not items.get("ok"):
                 logger.info(
                     "rule.slack.%s_list_failed" % list_type, extra={"error": items.get("error")}
                 )
-                return None
+                return (prefix, None, False)
 
-            cursor = items.get("response_metadata", {}).get("next_cursor", None)
             item_id = {c["name"]: c["id"] for c in items[result_name]}.get(name)
             if item_id:
-                return prefix, item_id
+                return (prefix, item_id, False)
+
+            cursor = items.get("response_metadata", {}).get("next_cursor", None)
+            if time.time() > time_to_quit:
+                return (prefix, None, True)
+
+            if not cursor:
+                break
+
+    return (prefix, None, False)
 
 
 def send_incident_alert_notification(integration, incident, channel):
diff --git a/src/sentry/mediators/project_rules/__init__.py b/src/sentry/mediators/project_rules/__init__.py
new file mode 100644
index 0000000000..ecc4f6af1c
--- /dev/null
+++ b/src/sentry/mediators/project_rules/__init__.py
@@ -0,0 +1,4 @@
+from __future__ import absolute_import
+
+from .creator import Creator  # NOQA
+from .updater import Updater  # NOQA
diff --git a/src/sentry/mediators/project_rules/creator.py b/src/sentry/mediators/project_rules/creator.py
new file mode 100644
index 0000000000..a621473956
--- /dev/null
+++ b/src/sentry/mediators/project_rules/creator.py
@@ -0,0 +1,42 @@
+from __future__ import absolute_import
+
+import six
+
+from collections import Iterable
+from sentry.mediators import Mediator, Param
+from sentry.models import Rule
+
+
+class Creator(Mediator):
+    name = Param(six.string_types)
+    environment = Param(int, required=False)
+    project = Param("sentry.models.Project")
+    action_match = Param(six.string_types)
+    actions = Param(Iterable)
+    conditions = Param(Iterable)
+    frequency = Param(int)
+    request = Param("rest_framework.request.Request", required=False)
+
+    def call(self):
+        self.rule = self._create_rule()
+        return self.rule
+
+    def _create_rule(self):
+        kwargs = self._get_kwargs()
+        rule = Rule.objects.create(**kwargs)
+        return rule
+
+    def _get_kwargs(self):
+        data = {
+            "action_match": self.action_match,
+            "actions": self.actions,
+            "conditions": self.conditions,
+            "frequency": self.frequency,
+        }
+        _kwargs = {
+            "label": self.name,
+            "environment_id": self.environment or None,
+            "project": self.project,
+            "data": data,
+        }
+        return _kwargs
diff --git a/src/sentry/mediators/project_rules/updater.py b/src/sentry/mediators/project_rules/updater.py
new file mode 100644
index 0000000000..d40db04484
--- /dev/null
+++ b/src/sentry/mediators/project_rules/updater.py
@@ -0,0 +1,58 @@
+from __future__ import absolute_import
+
+import six
+
+from collections import Iterable
+from sentry.mediators import Mediator, Param
+from sentry.mediators.param import if_param
+
+
+class Updater(Mediator):
+    rule = Param("sentry.models.Rule")
+    name = Param(six.string_types, required=False)
+    environment = Param(int, required=False)
+    project = Param("sentry.models.Project")
+    action_match = Param(six.string_types, required=False)
+    actions = Param(Iterable, required=False)
+    conditions = Param(Iterable, required=False)
+    frequency = Param(int, required=False)
+    request = Param("rest_framework.request.Request", required=False)
+
+    def call(self):
+        self._update_name()
+        self._update_environment()
+        self._update_project()
+        self._update_actions()
+        self._update_action_match()
+        self._update_conditions()
+        self._update_frequency()
+        self.rule.save()
+        return self.rule
+
+    @if_param("name")
+    def _update_name(self):
+        self.rule.label = self.name
+
+    def _update_environment(self):
+        # environment can be None so we don't use the if_param decorator
+        self.rule.environment_id = self.environment
+
+    @if_param("project")
+    def _update_project(self):
+        self.rule.project = self.project
+
+    @if_param("actions")
+    def _update_actions(self):
+        self.rule.data["actions"] = self.actions
+
+    @if_param("action_match")
+    def _update_action_match(self):
+        self.rule.data["action_match"] = self.action_match
+
+    @if_param("conditions")
+    def _update_conditions(self):
+        self.rule.data["conditions"] = self.conditions
+
+    @if_param("frequency")
+    def _update_frequency(self):
+        self.rule.data["frequency"] = self.frequency
diff --git a/src/sentry/static/sentry/app/views/settings/projectAlerts/ruleEditor/index.jsx b/src/sentry/static/sentry/app/views/settings/projectAlerts/ruleEditor/index.jsx
index e38d2faa19..785e7d1b62 100644
--- a/src/sentry/static/sentry/app/views/settings/projectAlerts/ruleEditor/index.jsx
+++ b/src/sentry/static/sentry/app/views/settings/projectAlerts/ruleEditor/index.jsx
@@ -2,7 +2,6 @@ import $ from 'jquery';
 import {browserHistory} from 'react-router';
 import PropTypes from 'prop-types';
 import React from 'react';
-import createReactClass from 'create-react-class';
 import styled from '@emotion/styled';
 
 import {ALL_ENVIRONMENTS_KEY} from 'app/constants';
@@ -41,40 +40,42 @@ const ACTION_MATCH_CHOICES = [
   ['none', t('none')],
 ];
 
+const POLLING_MAX_TIME_LIMIT = 3 * 60000;
+
 const AlertRuleRow = styled('h6')`
   display: flex;
   align-items: center;
 `;
 
-const RuleEditor = createReactClass({
-  displayName: 'RuleEditor',
-
-  propTypes: {
+class RuleEditor extends React.Component {
+  static propTypes = {
     api: PropTypes.object,
     actions: PropTypes.array.isRequired,
     conditions: PropTypes.array.isRequired,
     project: PropTypes.object.isRequired,
     organization: PropTypes.object.isRequired,
-  },
+  };
 
-  getInitialState() {
-    return {
+  constructor(props) {
+    super(props);
+    this.state = {
       rule: null,
       loading: false,
       error: null,
       environments: [],
+      uuid: null,
     };
-  },
+  }
 
   componentDidMount() {
     this.fetchData();
-  },
+  }
 
   componentDidUpdate() {
     if (this.state.error) {
       $(document.body).scrollTop($(this.formNode).offset().top);
     }
-  },
+  }
 
   fetchData() {
     const {
@@ -101,9 +102,71 @@ const RuleEditor = createReactClass({
     Promise.all(promises).then(([environments, rule]) => {
       this.setState({environments, rule});
     });
-  },
+  }
+
+  pollHandler = async quitTime => {
+    if (Date.now() > quitTime) {
+      addErrorMessage(t('Looking for that channel took too long :('));
+      this.setState({loading: false});
+      return;
+    }
+
+    const {api, organization, project} = this.props;
+    const {uuid} = this.state;
+    const origRule = {...this.state.rule};
+    let response;
+
+    try {
+      response = await api.requestPromise(
+        `/projects/${organization.slug}/${project.slug}/rule-task/${uuid}/`
+      );
+    } catch {
+      addErrorMessage(t('An error occurred'));
+      this.setState({loading: false});
+    }
+
+    const {status, rule, error} = response;
+
+    if (status === 'pending') {
+      setTimeout(() => {
+        this.pollHandler(quitTime);
+      }, 1000);
+      return;
+    }
+
+    if (status === 'failed') {
+      this.setState({
+        error: {actions: [error]},
+        loading: false,
+      });
+      addErrorMessage(t('An error occurred'));
+    }
+    if (rule && status === 'success') {
+      const isNew = !origRule.id;
+      this.handleRuleSuccess(isNew, rule);
+    }
+  };
+
+  fetchStatus() {
+    // pollHander calls itself until it gets either a sucesss
+    // or failed status but we don't want to poll forever so we pass
+    // in a hard stop time of 3 minutes before we bail.
+    const quitTime = Date.now() + POLLING_MAX_TIME_LIMIT;
+    setTimeout(() => {
+      this.pollHandler(quitTime);
+    }, 1000);
+  }
+
+  handleRuleSuccess = (isNew, rule) => {
+    this.setState({error: null, loading: false, rule});
+    // Redirect to correct ID if /new
+    if (isNew) {
+      browserHistory.replace(recreateRoute(`${rule.id}/`, {...this.props, stepBack: -1}));
+    }
+    addSuccessMessage(isNew ? t('Created alert rule') : t('Updated alert rule'));
+  };
 
-  handleSubmit(e) {
+  handleSubmit = e => {
     e.preventDefault();
 
     const data = {...this.state.rule};
@@ -124,15 +187,16 @@ const RuleEditor = createReactClass({
     this.props.api.request(endpoint, {
       method: isNew ? 'POST' : 'PUT',
       data,
-      success: resp => {
-        this.setState({error: null, loading: false, rule: resp});
-        // Redirect to correct ID if /new
-        if (isNew) {
-          browserHistory.replace(
-            recreateRoute(`${resp.id}/`, {...this.props, stepBack: -1})
-          );
+      success: (resp, _, jqXHR) => {
+        // if we get a 202 back it means that we have an async task
+        // running to lookup and verfity the channel id for Slack.
+        if (jqXHR.status === 202) {
+          this.setState({error: null, loading: true, uuid: resp.uuid});
+          this.fetchStatus();
+          addMessage(t('Looking through all your channels...'));
+        } else {
+          this.handleRuleSuccess(isNew, resp);
         }
-        addSuccessMessage(isNew ? t('Created alert rule') : t('Updated alert rule'));
       },
       error: response => {
         this.setState({
@@ -142,7 +206,7 @@ const RuleEditor = createReactClass({
         addErrorMessage(t('An error occurred'));
       },
     });
-  },
+  };
 
   hasError(field) {
     const {error} = this.state;
@@ -150,7 +214,7 @@ const RuleEditor = createReactClass({
       return false;
     }
     return !!error[field];
-  },
+  }
 
   handleEnvironmentChange(val) {
     // If 'All Environments' is selected the value should be null
@@ -159,7 +223,7 @@ const RuleEditor = createReactClass({
     } else {
       this.handleChange('environment', val);
     }
-  },
+  }
 
   handleChange(prop, val) {
     this.setState(state => {
@@ -167,7 +231,7 @@ const RuleEditor = createReactClass({
       rule[prop] = val;
       return {rule};
     });
-  },
+  }
 
   handlePropertyChange(type) {
     return idx => {
@@ -177,7 +241,7 @@ const RuleEditor = createReactClass({
         this.setState({rule});
       };
     };
-  },
+  }
 
   handleAddRow(type) {
     return id => {
@@ -188,7 +252,7 @@ const RuleEditor = createReactClass({
         };
       });
     };
-  },
+  }
 
   handleDeleteRow(type) {
     return idx => {
@@ -199,7 +263,7 @@ const RuleEditor = createReactClass({
         };
       });
     };
-  },
+  }
 
   render() {
     const {projectId} = this.props.params;
@@ -339,8 +403,8 @@ const RuleEditor = createReactClass({
         </Panel>
       </form>
     );
-  },
-});
+  }
+}
 
 export {RuleEditor};
 
diff --git a/tests/sentry/api/endpoints/test_project_rule_task_details.py b/tests/sentry/api/endpoints/test_project_rule_task_details.py
new file mode 100644
index 0000000000..9a3244f19b
--- /dev/null
+++ b/tests/sentry/api/endpoints/test_project_rule_task_details.py
@@ -0,0 +1,62 @@
+from __future__ import absolute_import
+
+import six
+from uuid import uuid4
+
+from django.core.urlresolvers import reverse
+
+from sentry.utils.compat.mock import patch
+from sentry.testutils import APITestCase
+
+
+class ProjectRuleTaskDetailsTest(APITestCase):
+    def setUp(self):
+        self.login_as(user=self.user)
+        team = self.create_team()
+        project1 = self.create_project(teams=[team], name="foo", fire_project_created=True)
+        self.create_project(teams=[team], name="bar", fire_project_created=True)
+        self.rule = project1.rule_set.all()[0]
+        self.uuid = uuid4().hex
+        self.url = reverse(
+            "sentry-api-0-project-rule-task-details",
+            kwargs={
+                "organization_slug": project1.organization.slug,
+                "project_slug": project1.slug,
+                "task_uuid": self.uuid,
+            },
+        )
+
+    @patch("sentry.integrations.slack.tasks.RedisRuleStatus.get_value")
+    def test_status_pending(self, mock_get_value):
+        self.login_as(user=self.user)
+        mock_get_value.return_value = {"status": "pending"}
+        response = self.client.get(self.url, format="json")
+
+        assert response.status_code == 200, response.content
+        assert response.data["status"] == "pending"
+        assert response.data["rule"] is None
+
+    @patch("sentry.integrations.slack.tasks.RedisRuleStatus.get_value")
+    def test_status_failed(self, mock_get_value):
+        self.login_as(user=self.user)
+        mock_get_value.return_value = {"status": "failed", "error": "This failed"}
+        response = self.client.get(self.url, format="json")
+
+        assert response.status_code == 200, response.content
+        assert response.data["status"] == "failed"
+        assert response.data["rule"] is None
+        assert response.data["error"] == "This failed"
+
+    @patch("sentry.integrations.slack.tasks.RedisRuleStatus.get_value")
+    def test_status_success(self, mock_get_value):
+        self.login_as(user=self.user)
+        mock_get_value.return_value = {"status": "success", "rule_id": self.rule.id}
+        response = self.client.get(self.url, format="json")
+
+        assert response.status_code == 200, response.content
+        assert response.data["status"] == "success"
+
+        rule_data = response.data["rule"]
+        # TODO(meredith): shoudl I check every attribute?
+        assert rule_data["id"] == six.text_type(self.rule.id)
+        assert rule_data["name"] == self.rule.label
diff --git a/tests/sentry/integrations/slack/test_utils.py b/tests/sentry/integrations/slack/test_utils.py
index 0e54de4d11..2b2eead8d8 100644
--- a/tests/sentry/integrations/slack/test_utils.py
+++ b/tests/sentry/integrations/slack/test_utils.py
@@ -58,23 +58,23 @@ class GetChannelIdTest(TestCase):
             body=json.dumps({"ok": "true", result_name: channels}),
         )
 
-    def run_valid_test(self, channel, expected_prefix, expected_id):
-        assert (expected_prefix, expected_id) == get_channel_id(
+    def run_valid_test(self, channel, expected_prefix, expected_id, timed_out):
+        assert (expected_prefix, expected_id, timed_out) == get_channel_id(
             self.organization, self.integration.id, channel
         )
 
     def test_valid_channel_selected(self):
-        self.run_valid_test("#my-channel", CHANNEL_PREFIX, "m-c")
+        self.run_valid_test("#my-channel", CHANNEL_PREFIX, "m-c", False)
 
     def test_valid_private_channel_selected(self):
-        self.run_valid_test("#my-private-channel", CHANNEL_PREFIX, "m-p-c")
+        self.run_valid_test("#my-private-channel", CHANNEL_PREFIX, "m-p-c", False)
 
     def test_valid_member_selected(self):
-        self.run_valid_test("@morty", MEMBER_PREFIX, "m")
+        self.run_valid_test("@morty", MEMBER_PREFIX, "m", False)
 
     def test_invalid_channel_selected(self):
-        assert get_channel_id(self.organization, self.integration.id, "#fake-channel") is None
-        assert get_channel_id(self.organization, self.integration.id, "@fake-user") is None
+        assert get_channel_id(self.organization, self.integration.id, "#fake-channel")[1] is None
+        assert get_channel_id(self.organization, self.integration.id, "@fake-user")[1] is None
 
 
 class BuildIncidentAttachmentTest(TestCase):
diff --git a/tests/sentry/mediators/project_rules/test_creator.py b/tests/sentry/mediators/project_rules/test_creator.py
new file mode 100644
index 0000000000..bae7c34b07
--- /dev/null
+++ b/tests/sentry/mediators/project_rules/test_creator.py
@@ -0,0 +1,59 @@
+from __future__ import absolute_import
+
+from sentry.mediators.project_rules import Creator
+from sentry.models import Rule
+from sentry.testutils import TestCase
+
+
+class TestCreator(TestCase):
+    def setUp(self):
+        self.user = self.create_user()
+        self.org = self.create_organization(name="bloop", owner=self.user)
+        self.project = self.create_project(
+            teams=[self.create_team()], name="foo", fire_project_created=True
+        )
+        self.creator = Creator(
+            name="New Cool Rule",
+            project=self.project,
+            action_match="all",
+            conditions=[
+                {
+                    "id": "sentry.rules.conditions.first_seen_event.FirstSeenEventCondition",
+                    "key": "foo",
+                    "match": "eq",
+                    "value": "bar",
+                }
+            ],
+            actions=[
+                {
+                    "id": "sentry.rules.actions.notify_event.NotifyEventAction",
+                    "name": "Send a notification (for all legacy integrations)",
+                }
+            ],
+            frequency=5,
+        )
+
+    def test_creates_rule(self):
+        r = self.creator.call()
+        rule = Rule.objects.get(id=r.id)
+        assert rule.label == "New Cool Rule"
+        assert rule.project == self.project
+        assert rule.environment_id is None
+        assert rule.data == {
+            "actions": [
+                {
+                    "id": "sentry.rules.actions.notify_event.NotifyEventAction",
+                    "name": "Send a notification (for all legacy integrations)",
+                }
+            ],
+            "conditions": [
+                {
+                    "id": "sentry.rules.conditions.first_seen_event.FirstSeenEventCondition",
+                    "key": "foo",
+                    "match": "eq",
+                    "value": "bar",
+                }
+            ],
+            "action_match": "all",
+            "frequency": 5,
+        }
diff --git a/tests/sentry/mediators/project_rules/test_updater.py b/tests/sentry/mediators/project_rules/test_updater.py
new file mode 100644
index 0000000000..9571446e90
--- /dev/null
+++ b/tests/sentry/mediators/project_rules/test_updater.py
@@ -0,0 +1,82 @@
+from __future__ import absolute_import
+
+from sentry.mediators.project_rules import Updater
+from sentry.testutils import TestCase
+
+
+class TestUpdater(TestCase):
+    def setUp(self):
+        self.user = self.create_user()
+        self.org = self.create_organization(name="bloop", owner=self.user)
+        self.project = self.create_project(
+            teams=[self.create_team()], name="foo", fire_project_created=True
+        )
+        self.rule = self.project.rule_set.all()[0]
+        self.updater = Updater(rule=self.rule, project=self.project)
+
+    def test_update_name(self):
+        self.updater.name = "Cool New Rule"
+        self.updater.call()
+        assert self.rule.label == "Cool New Rule"
+
+    def test_update_environment(self):
+        self.updater.environment = 3
+        self.updater.call()
+        assert self.rule.environment_id == 3
+
+    def test_update_environment_when_none(self):
+        self.rule.environment_id = 3
+        self.rule.save()
+        assert self.rule.environment_id == 3
+        self.updater.call()
+        assert self.rule.environment_id is None
+
+    def test_update_project(self):
+        project2 = self.create_project(organization=self.org)
+        self.updater.project = project2
+        self.updater.call()
+        assert self.rule.project == project2
+
+    def test_update_actions(self):
+        self.updater.actions = [
+            {
+                "id": "sentry.rules.actions.notify_event.NotifyEventAction",
+                "name": "Send a notification (for all legacy integrations)",
+            }
+        ]
+        self.updater.call()
+        assert self.rule.data["actions"] == [
+            {
+                "id": "sentry.rules.actions.notify_event.NotifyEventAction",
+                "name": "Send a notification (for all legacy integrations)",
+            }
+        ]
+
+    def test_update_action_match(self):
+        self.updater.action_match = "any"
+        self.updater.call()
+        assert self.rule.data["action_match"] == "any"
+
+    def test_update_conditions(self):
+        self.updater.conditions = [
+            {
+                "id": "sentry.rules.conditions.first_seen_event.FirstSeenEventCondition",
+                "key": "foo",
+                "match": "eq",
+                "value": "bar",
+            }
+        ]
+        self.updater.call()
+        assert self.rule.data["conditions"] == [
+            {
+                "id": "sentry.rules.conditions.first_seen_event.FirstSeenEventCondition",
+                "key": "foo",
+                "match": "eq",
+                "value": "bar",
+            }
+        ]
+
+    def test_update_frequency(self):
+        self.updater.frequency = 5
+        self.updater.call()
+        assert self.rule.data["frequency"] == 5

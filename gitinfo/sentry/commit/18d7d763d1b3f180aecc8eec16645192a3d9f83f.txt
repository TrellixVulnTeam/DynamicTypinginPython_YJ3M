commit 18d7d763d1b3f180aecc8eec16645192a3d9f83f
Author: David Cramer <dcramer@gmail.com>
Date:   Fri Mar 23 10:49:16 2018 -0700

    feat(django): Adapt South to Django 1.8
    
    - Adapt South to support Django 1.6 through 1.8
    - Merged migrate/syncdb behavior into unified command which understands how to apply schema
    - Remove support for data fixtures from syncdb (loaddata/dumpdata)

diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index 12ed120060..1ea1a01a59 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -269,7 +269,7 @@ INSTALLED_APPS = (
 )
 
 import django
-if django.VERSION < (1, 7):
+if django.VERSION < (1, 9):
     INSTALLED_APPS += ('south', )
 
 STATIC_ROOT = os.path.realpath(os.path.join(PROJECT_ROOT, 'static'))
diff --git a/src/sentry/runner/commands/upgrade.py b/src/sentry/runner/commands/upgrade.py
index d9223042c1..e789af3dc0 100644
--- a/src/sentry/runner/commands/upgrade.py
+++ b/src/sentry/runner/commands/upgrade.py
@@ -13,20 +13,15 @@ from sentry.runner.decorators import configuration
 
 def _upgrade(interactive, traceback, verbosity, repair):
     from django.core.management import call_command as dj_call_command
-    dj_call_command(
-        'syncdb',
-        interactive=interactive,
-        traceback=traceback,
-        verbosity=verbosity,
-    )
 
     dj_call_command(
         'migrate',
-        merge=True,
-        ignore_ghost_migrations=True,
         interactive=interactive,
         traceback=traceback,
         verbosity=verbosity,
+        migrate=True,
+        merge=True,
+        ignore_ghost_migrations=True,
     )
 
     if repair:
diff --git a/src/south/constants.py b/src/south/constants.py
new file mode 100644
index 0000000000..eca91396bd
--- /dev/null
+++ b/src/south/constants.py
@@ -0,0 +1,8 @@
+# If we detect Django 1.8 or higher, then exit
+# Placed here so it's guaranteed to be imported on Django start
+import django
+if django.VERSION[0] > 1 or (django.VERSION[0] == 1 and django.VERSION[1] >= 9):
+    raise RuntimeError(
+        "Sentry's version of South does not support Django 1.8 or higher. Please use native Django migrations.")
+
+DJANGO_17 = django.VERSION[0] > 1 or (django.VERSION[0] == 1 and django.VERSION[1] >= 7)
diff --git a/src/south/db/__init__.py b/src/south/db/__init__.py
index cec4572651..43ea6406a3 100644
--- a/src/south/db/__init__.py
+++ b/src/south/db/__init__.py
@@ -45,6 +45,7 @@ try:
         module = __import__(module_name, {}, {}, [''])
         dbs[alias] = module.DatabaseOperations(alias)
 except ImportError:
+    raise
     # This error should only be triggered on 1.1 and below.
     sys.stderr.write(
         (
diff --git a/src/south/db/generic.py b/src/south/db/generic.py
index a1a5feb72f..64f42922c5 100644
--- a/src/south/db/generic.py
+++ b/src/south/db/generic.py
@@ -7,7 +7,10 @@ from django.core.management.color import no_style
 from django.db import transaction, models
 from django.db.utils import DatabaseError
 from django.db.backends.util import truncate_name
-from django.db.backends.creation import BaseDatabaseCreation
+try:
+    from django.db.backends.creation import BaseDatabaseCreation
+except ImportError:
+    from django.db.backends.base.creation import BaseDatabaseCreation
 from django.db.models.fields import NOT_PROVIDED
 from django.dispatch import dispatcher
 from django.conf import settings
@@ -28,6 +31,7 @@ except ImportError:
             res = instance.__dict__[self.func.__name__] = self.func(instance)
             return res
 
+from south.constants import DJANGO_17
 from south.logger import get_logger
 from south.utils.py3 import string_types, text_type
 
@@ -1012,9 +1016,10 @@ class DatabaseOperations(object):
         """
         if self.dry_run:
             self.pending_transactions += 1
-        transaction.commit_unless_managed(using=self.db_alias)
-        transaction.enter_transaction_management(using=self.db_alias)
-        transaction.managed(True, using=self.db_alias)
+        if not DJANGO_17:
+            transaction.commit_unless_managed(using=self.db_alias)
+            transaction.enter_transaction_management(using=self.db_alias)
+            transaction.managed(True, using=self.db_alias)
 
     def commit_transaction(self):
         """
@@ -1024,7 +1029,8 @@ class DatabaseOperations(object):
         if self.dry_run:
             return
         transaction.commit(using=self.db_alias)
-        transaction.leave_transaction_management(using=self.db_alias)
+        if not DJANGO_17:
+            transaction.leave_transaction_management(using=self.db_alias)
 
     def rollback_transaction(self):
         """
@@ -1034,7 +1040,8 @@ class DatabaseOperations(object):
         if self.dry_run:
             self.pending_transactions -= 1
         transaction.rollback(using=self.db_alias)
-        transaction.leave_transaction_management(using=self.db_alias)
+        if not DJANGO_17:
+            transaction.leave_transaction_management(using=self.db_alias)
 
     def rollback_transactions_dry_run(self):
         """
@@ -1044,7 +1051,7 @@ class DatabaseOperations(object):
             return
         while self.pending_transactions > 0:
             self.rollback_transaction()
-        if transaction.is_dirty(using=self.db_alias):
+        if not DJANGO_17 and transaction.is_dirty(using=self.db_alias):
             # Force an exception, if we're still in a dirty transaction.
             # This means we are missing a COMMIT/ROLLBACK.
             transaction.leave_transaction_management(using=self.db_alias)
@@ -1090,37 +1097,24 @@ class DatabaseOperations(object):
 
         created_models = []
         for model_name in model_names:
-            model = models.get_model(app_label, model_name)
-            if model:
-                created_models.append(model)
+            try:
+                model = models.get_model(app_label, model_name)
+            # Django 1.7 throws LookupError
+            except LookupError:
+                pass
+            else:
+                if model:
+                    created_models.append(model)
 
         if created_models:
-
-            if hasattr(dispatcher, "send"):
-                # Older djangos
-                dispatcher.send(signal=models.signals.post_syncdb, sender=app,
-                                app=app, created_models=created_models,
-                                verbosity=verbosity, interactive=interactive)
-            else:
-                if self._is_multidb():
-                    # Django 1.2+
-                    models.signals.post_syncdb.send(
-                        sender=app,
-                        app=app,
-                        created_models=created_models,
-                        verbosity=verbosity,
-                        interactive=interactive,
-                        db=self.db_alias,
-                    )
-                else:
-                    # Django 1.1 - 1.0
-                    models.signals.post_syncdb.send(
-                        sender=app,
-                        app=app,
-                        created_models=created_models,
-                        verbosity=verbosity,
-                        interactive=interactive,
-                    )
+            models.signals.post_syncdb.send(
+                sender=app,
+                app=app,
+                created_models=created_models,
+                verbosity=verbosity,
+                interactive=interactive,
+                db=self.db_alias,
+            )
 
     def mock_model(self, model_name, db_table, db_tablespace='',
                    pk_field_name='id', pk_field_type=models.AutoField,
diff --git a/src/south/hacks/django_1_0.py b/src/south/hacks/django_1_0.py
index 420e2b632d..2b1f900028 100644
--- a/src/south/hacks/django_1_0.py
+++ b/src/south/hacks/django_1_0.py
@@ -3,14 +3,26 @@ Hacks for the Django 1.0/1.0.2 releases.
 """
 
 import django
+import six
+
+
+from collections import defaultdict, OrderedDict
 from django.conf import settings
-from django.db.backends.creation import BaseDatabaseCreation
+try:
+    from django.db.backends.creation import BaseDatabaseCreation
+except ImportError:
+    from django.db.backends.base.creation import BaseDatabaseCreation
 from django.db.models.loading import cache
 from django.core import management
 from django.core.management.commands.flush import Command as FlushCommand
 from django.utils.datastructures import SortedDict
 
-from south.utils.py3 import string_types
+from south.constants import DJANGO_17
+
+if DJANGO_17:
+    from django.apps.registry import apps
+else:
+    apps = None
 
 
 class SkipFlushCommand(FlushCommand):
@@ -20,7 +32,6 @@ class SkipFlushCommand(FlushCommand):
 
 
 class Hacks:
-
     def set_installed_apps(self, apps):
         """
         Sets Django's INSTALLED_APPS setting to be effectively the list passed in.
@@ -65,20 +76,33 @@ class Hacks:
         Clears the contents of AppCache to a blank state, so new models
         from the ORM can be added.
         """
-        self.old_app_models, cache.app_models = cache.app_models, {}
+        # Django 1.7+ throws a runtime error in some situations due to model validation:
+        # >>> RuntimeError: Conflicting 'user' models in application 'sentry': <class 'sentry.models.user.User'> and <class 'sentry.models.User'>.
+        if DJANGO_17:
+            self.old_app_models, apps.all_models = apps.all_models, defaultdict(OrderedDict)
+            apps.clear_cache()
+        else:
+            self.old_app_models, cache.app_models = cache.app_models, {}
 
     def unclear_app_cache(self):
         """
         Reversed the effects of clear_app_cache.
         """
-        cache.app_models = self.old_app_models
-        cache._get_models_cache = {}
+        if DJANGO_17:
+            apps.all_models = self.old_app_models
+            apps.clear_cache()
+        else:
+            cache.app_models = self.old_app_models
+            cache._get_models_cache = {}
 
     def repopulate_app_cache(self):
         """
         Rebuilds AppCache with the real model definitions.
         """
-        cache._populate()
+        if DJANGO_17:
+            apps.clear_cache()
+        else:
+            cache._populate()
 
     def store_app_cache_state(self):
         self.stored_app_cache_state = dict(**cache.__dict__)
diff --git a/src/south/management/commands/__init__.py b/src/south/management/commands/__init__.py
index 9edd3c07b4..e69de29bb2 100644
--- a/src/south/management/commands/__init__.py
+++ b/src/south/management/commands/__init__.py
@@ -1,42 +0,0 @@
-
-# Common framework for syncdb actions
-
-import copy
-
-from django.core import management
-from django.conf import settings
-
-# Make sure the template loader cache is fixed _now_ (#448)
-import django.template.loaders.app_directories
-
-from south.hacks import hacks
-from south.management.commands.syncdb import Command as SyncCommand
-
-
-class MigrateAndSyncCommand(SyncCommand):
-    """Used for situations where "syncdb" is called by test frameworks."""
-
-    option_list = copy.deepcopy(SyncCommand.option_list)
-
-    for opt in option_list:
-        if "--migrate" == opt.get_opt_string():
-            opt.default = True
-            break
-
-
-def patch_for_test_db_setup():
-    # Load the commands cache
-    management.get_commands()
-    # Repoint to the correct version of syncdb
-    if hasattr(settings, "SOUTH_TESTS_MIGRATE") and not settings.SOUTH_TESTS_MIGRATE:
-        # point at the core syncdb command when creating tests
-        # tests should always be up to date with the most recent model structure
-        management._commands['syncdb'] = 'django.core'
-    else:
-        management._commands['syncdb'] = MigrateAndSyncCommand()
-        # Avoid flushing data migrations.
-        # http://code.djangoproject.com/ticket/14661 introduced change that flushed custom
-        # sql during the test database creation (thus flushing the data migrations).
-        # we patch flush to be no-op during create_test_db, but still allow flushing
-        # after each test for non-transactional backends.
-        hacks.patch_flush_during_test_db_creation()
diff --git a/src/south/management/commands/convert_to_south.py b/src/south/management/commands/convert_to_south.py
deleted file mode 100644
index e942344966..0000000000
--- a/src/south/management/commands/convert_to_south.py
+++ /dev/null
@@ -1,100 +0,0 @@
-"""
-Quick conversion command module.
-"""
-
-from __future__ import print_function
-
-from optparse import make_option
-import sys
-
-from django.core.management.base import BaseCommand
-from django.core.management.color import no_style
-from django.conf import settings
-from django.db import models
-from django.core import management
-from django.core.exceptions import ImproperlyConfigured
-
-from south.migration import Migrations
-from south.hacks import hacks
-from south.exceptions import NoMigrations
-
-
-class Command(BaseCommand):
-
-    option_list = BaseCommand.option_list
-    if '--verbosity' not in [opt.get_opt_string() for opt in BaseCommand.option_list]:
-        option_list += (
-            make_option('--verbosity', action='store', dest='verbosity', default='1',
-                        type='choice', choices=['0', '1', '2'],
-                        help='Verbosity level; 0=minimal output, 1=normal output, 2=all output'),
-        )
-    option_list += (
-        make_option('--delete-ghost-migrations', action='store_true', dest='delete_ghosts', default=False,
-                    help="Tells South to delete any 'ghost' migrations (ones in the database but not on disk)."),
-        make_option('--ignore-ghost-migrations', action='store_true', dest='ignore_ghosts', default=False,
-                    help="Tells South to ignore any 'ghost' migrations (ones in the database but not on disk) and continue to apply new migrations."),
-    )
-
-    help = "Quickly converts the named application to use South if it is currently using syncdb."
-
-    def handle(self, app=None, *args, **options):
-
-        # Make sure we have an app
-        if not app:
-            print("Please specify an app to convert.")
-            return
-
-        # See if the app exists
-        app = app.split(".")[-1]
-        try:
-            app_module = models.get_app(app)
-        except ImproperlyConfigured:
-            print("There is no enabled application matching '%s'." % app)
-            return
-
-        # Try to get its list of models
-        model_list = models.get_models(app_module)
-        if not model_list:
-            print("This application has no models; this command is for applications that already have models syncdb'd.")
-            print("Make some models, and then use ./manage.py schemamigration %s --initial instead." % app)
-            return
-
-        # Ask South if it thinks it's already got migrations
-        try:
-            Migrations(app)
-        except NoMigrations:
-            pass
-        else:
-            print("This application is already managed by South.")
-            return
-
-        # Finally! It seems we've got a candidate, so do the two-command trick
-        verbosity = int(options.get('verbosity', 0))
-        management.call_command("schemamigration", app, initial=True, verbosity=verbosity)
-
-        # Now, we need to re-clean and sanitise appcache
-        hacks.clear_app_cache()
-        hacks.repopulate_app_cache()
-
-        # And also clear our cached Migration classes
-        Migrations._clear_cache()
-
-        # Now, migrate
-        management.call_command(
-            "migrate",
-            app,
-            "0001",
-            fake=True,
-            verbosity=verbosity,
-            ignore_ghosts=options.get("ignore_ghosts", False),
-            delete_ghosts=options.get("delete_ghosts", False),
-        )
-
-        print()
-        print(
-            "App '%s' converted. Note that South assumed the application's models matched the database" %
-            app)
-        print(
-            "(i.e. you haven't changed it since last syncdb); if you have, you should delete the %s/migrations" %
-            app)
-        print("directory, revert models.py so it matches the database, and try again.")
diff --git a/src/south/management/commands/graphmigrations.py b/src/south/management/commands/graphmigrations.py
deleted file mode 100644
index 73ec81f5b8..0000000000
--- a/src/south/management/commands/graphmigrations.py
+++ /dev/null
@@ -1,64 +0,0 @@
-"""
-Outputs a graphviz dot file of the dependencies.
-"""
-
-from __future__ import print_function
-
-from optparse import make_option
-import re
-import textwrap
-
-from django.core.management.base import BaseCommand
-from django.core.management.color import no_style
-
-from south.migration import Migrations, all_migrations
-
-
-class Command(BaseCommand):
-
-    help = "Outputs a GraphViz dot file of all migration dependencies to stdout."
-
-    def handle(self, **options):
-
-        # Resolve dependencies
-        Migrations.calculate_dependencies()
-
-        colors = ['crimson', 'darkgreen', 'darkgoldenrod', 'navy',
-                  'brown', 'darkorange', 'aquamarine', 'blueviolet']
-        color_index = 0
-        wrapper = textwrap.TextWrapper(width=40)
-
-        print("digraph G {")
-
-        # Group each app in a subgraph
-        for migrations in all_migrations():
-            print("  subgraph %s {" % migrations.app_label())
-            print("    node [color=%s];" % colors[color_index])
-            for migration in migrations:
-                # Munge the label - text wrap and change _ to spaces
-                label = "%s - %s" % (
-                        migration.app_label(), migration.name())
-                label = re.sub(r"_+", " ", label)
-                label = "\\n".join(wrapper.wrap(label))
-                print('    "%s.%s" [label="%s"];' % (
-                    migration.app_label(), migration.name(), label))
-            print("  }")
-            color_index = (color_index + 1) % len(colors)
-
-        # For every migration, print its links.
-        for migrations in all_migrations():
-            for migration in migrations:
-                for other in migration.dependencies:
-                    # Added weight tends to keep migrations from the same app
-                    # in vertical alignment
-                    attrs = "[weight=2.0]"
-                    # But the more interesting edges are those between apps
-                    if other.app_label() != migration.app_label():
-                        attrs = "[style=bold]"
-                    print('  "%s.%s" -> "%s.%s" %s;' % (
-                        other.app_label(), other.name(),
-                        migration.app_label(), migration.name(),
-                        attrs
-                    ))
-
-        print("}");
diff --git a/src/south/management/commands/migrate.py b/src/south/management/commands/migrate.py
index 1aca7375e3..50a113e81a 100644
--- a/src/south/management/commands/migrate.py
+++ b/src/south/management/commands/migrate.py
@@ -1,277 +1,14 @@
-"""
-Migrate management command.
-"""
+# Mimic syncdb for Django 1.7 compatibility
+from __future__ import absolute_import
 
-from __future__ import print_function
-
-import os.path
-import re
-import sys
-from functools import reduce
+from django.core.management.commands import syncdb
 from optparse import make_option
 
-from django.core.management.base import BaseCommand
-from django.conf import settings
-from django.utils.importlib import import_module
-
-from south import migration
-from south.migration import Migrations
-from south.exceptions import NoMigrations
-from south.db import DEFAULT_DB_ALIAS
+from .syncdb import Command as SyncDbCommand  # NOQA
 
 
-class Command(BaseCommand):
-    option_list = BaseCommand.option_list + (
-        make_option('--all', action='store_true', dest='all_apps', default=False,
-                    help='Run the specified migration for all apps.'),
-        make_option('--list', action='store_true', dest='show_list', default=False,
-                    help='List migrations noting those that have been applied'),
-        make_option('--changes', action='store_true', dest='show_changes', default=False,
-                    help='List changes for migrations'),
-        make_option('--skip', action='store_true', dest='skip', default=False,
-                    help='Will skip over out-of-order missing migrations'),
-        make_option('--merge', action='store_true', dest='merge', default=False,
-                    help='Will run out-of-order missing migrations as they are - no rollbacks.'),
-        make_option('--no-initial-data', action='store_true', dest='no_initial_data', default=False,
-                    help='Skips loading initial data if specified.'),
-        make_option('--fake', action='store_true', dest='fake', default=False,
-                    help="Pretends to do the migrations, but doesn't actually execute them."),
-        make_option('--db-dry-run', action='store_true', dest='db_dry_run', default=False,
-                    help="Doesn't execute the SQL generated by the db methods, and doesn't store a record that the migration(s) occurred. Useful to test migrations before applying them."),
-        make_option('--delete-ghost-migrations', action='store_true', dest='delete_ghosts', default=False,
-                    help="Tells South to delete any 'ghost' migrations (ones in the database but not on disk)."),
-        make_option('--ignore-ghost-migrations', action='store_true', dest='ignore_ghosts', default=False,
-                    help="Tells South to ignore any 'ghost' migrations (ones in the database but not on disk) and continue to apply new migrations."),
-        make_option('--noinput', action='store_false', dest='interactive', default=True,
-                    help='Tells Django to NOT prompt the user for input of any kind.'),
-        make_option('--database', action='store', dest='database',
-                    default=DEFAULT_DB_ALIAS, help='Nominates a database to synchronize. '
-                    'Defaults to the "default" database.'),
+class Command(SyncDbCommand):
+    option_list = SyncDbCommand.option_list + (
+        make_option('--no-migrate', action='store_false', dest='migrate', default=True,
+                    help='Tells South to disable migrations after the sync. Default for during testing, and other internal calls.'),
     )
-    if '--verbosity' not in [opt.get_opt_string() for opt in BaseCommand.option_list]:
-        option_list += (
-            make_option('--verbosity', action='store', dest='verbosity', default='1',
-                        type='choice', choices=['0', '1', '2'],
-                        help='Verbosity level; 0=minimal output, 1=normal output, 2=all output'),
-        )
-    help = "Runs migrations for all apps."
-    args = "[appname] [migrationname|zero] [--all] [--list] [--skip] [--merge] [--no-initial-data] [--fake] [--db-dry-run] [--database=dbalias]"
-
-    def handle(self, app=None, target=None, skip=False, merge=False, backwards=False, fake=False, db_dry_run=False,
-               show_list=False, show_changes=False, database=DEFAULT_DB_ALIAS, delete_ghosts=False, ignore_ghosts=False, **options):
-
-        # NOTE: THIS IS DUPLICATED FROM django.core.management.commands.syncdb
-        # This code imports any module named 'management' in INSTALLED_APPS.
-        # The 'management' module is the preferred way of listening to post_syncdb
-        # signals, and since we're sending those out with create_table migrations,
-        # we need apps to behave correctly.
-        for app_name in settings.INSTALLED_APPS:
-            try:
-                import_module('.management', app_name)
-            except ImportError as exc:
-                msg = exc.args[0]
-                if not msg.startswith('No module named') or 'management' not in msg:
-                    raise
-        # END DJANGO DUPE CODE
-
-        # if all_apps flag is set, shift app over to target
-        if options.get('all_apps', False):
-            target = app
-            app = None
-
-        # Migrate each app
-        if app:
-            try:
-                apps = [Migrations(app)]
-            except NoMigrations:
-                print("The app '%s' does not appear to use migrations." % app)
-                print("./manage.py migrate " + self.args)
-                return
-        else:
-            apps = list(migration.all_migrations())
-
-        # Do we need to show the list of migrations?
-        if show_list and apps:
-            list_migrations(apps, database, **options)
-
-        if show_changes and apps:
-            show_migration_changes(apps)
-
-        if not (show_list or show_changes):
-
-            for app in apps:
-                result = migration.migrate_app(
-                    app,
-                    target_name=target,
-                    fake=fake,
-                    db_dry_run=db_dry_run,
-                    verbosity=int(options.get('verbosity', 0)),
-                    interactive=options.get('interactive', True),
-                    load_initial_data=not options.get('no_initial_data', False),
-                    merge=merge,
-                    skip=skip,
-                    database=database,
-                    delete_ghosts=delete_ghosts,
-                    ignore_ghosts=ignore_ghosts,
-                )
-                if result is False:
-                    sys.exit(1)  # Migration failed, so the command fails.
-
-
-def list_migrations(apps, database=DEFAULT_DB_ALIAS, **options):
-    """
-    Prints a list of all available migrations, and which ones are currently applied.
-    Accepts a list of Migrations instances.
-    """
-    from south.models import MigrationHistory
-    applied_migrations = MigrationHistory.objects.filter(
-        app_name__in=[app.app_label() for app in apps])
-    if database != DEFAULT_DB_ALIAS:
-        applied_migrations = applied_migrations.using(database)
-    applied_migrations_lookup = dict(('%s.%s' % (mi.app_name, mi.migration), mi)
-                                     for mi in applied_migrations)
-
-    print()
-    for app in apps:
-        print(" " + app.app_label())
-        # Get the migrations object
-        for migration in app:
-            full_name = migration.app_label() + "." + migration.name()
-            if full_name in applied_migrations_lookup:
-                applied_migration = applied_migrations_lookup[full_name]
-                print(
-                    format_migration_list_item(
-                        migration.name(),
-                        applied=applied_migration.applied,
-                        **options))
-            else:
-                print(format_migration_list_item(migration.name(), applied=False, **options))
-        print()
-
-
-def show_migration_changes(apps):
-    """
-    Prints a list of all available migrations, and which ones are currently applied.
-    Accepts a list of Migrations instances.
-
-    Much simpler, less clear, and much less robust version:
-        grep "ing " migrations/*.py
-    """
-    for app in apps:
-        print(app.app_label())
-        # Get the migrations objects
-        migrations = [migration for migration in app]
-        # we use reduce to compare models in pairs, not to generate a value
-        reduce(diff_migrations, migrations)
-
-
-def format_migration_list_item(name, applied=True, **options):
-    if applied:
-        if int(options.get('verbosity')) >= 2:
-            return '  (*) %-80s  (applied %s)' % (name, applied)
-        else:
-            return '  (*) %s' % name
-    else:
-        return '  ( ) %s' % name
-
-
-def diff_migrations(migration1, migration2):
-
-    def model_name(models, model):
-        return models[model].get('Meta', {}).get('object_name', model)
-
-    def field_name(models, model, field):
-        return '%s.%s' % (model_name(models, model), field)
-
-    print("  " + migration2.name())
-
-    models1 = migration1.migration_class().models
-    models2 = migration2.migration_class().models
-
-    # find new models
-    for model in models2.keys():
-        if not model in models1.keys():
-            print('    added model %s' % model_name(models2, model))
-
-    # find removed models
-    for model in models1.keys():
-        if not model in models2.keys():
-            print('    removed model %s' % model_name(models1, model))
-
-    # compare models
-    for model in models1:
-        if model in models2:
-
-            # find added fields
-            for field in models2[model]:
-                if not field in models1[model]:
-                    print('    added field %s' % field_name(models2, model, field))
-
-            # find removed fields
-            for field in models1[model]:
-                if not field in models2[model]:
-                    print('    removed field %s' % field_name(models1, model, field))
-
-            # compare fields
-            for field in models1[model]:
-                if field in models2[model]:
-
-                    name = field_name(models1, model, field)
-
-                    # compare field attributes
-                    field_value1 = models1[model][field]
-                    field_value2 = models2[model][field]
-
-                    # if a field has become a class, or vice versa
-                    if type(field_value1) != type(field_value2):
-                        print('    type of %s changed from %s to %s' % (
-                            name, field_value1, field_value2))
-
-                    # if class
-                    elif isinstance(field_value1, dict):
-                        # print '    %s is a class' % name
-                        pass
-
-                    # else regular field
-                    else:
-
-                        type1, attr_list1, field_attrs1 = models1[model][field]
-                        type2, attr_list2, field_attrs2 = models2[model][field]
-
-                        if type1 != type2:
-                            print('    %s type changed from %s to %s' % (
-                                name, type1, type2))
-
-                        if attr_list1 != []:
-                            print('    %s list %s is not []' % (
-                                name, attr_list1))
-                        if attr_list2 != []:
-                            print('    %s list %s is not []' % (
-                                name, attr_list2))
-                        if attr_list1 != attr_list2:
-                            print('    %s list changed from %s to %s' % (
-                                name, attr_list1, attr_list2))
-
-                        # find added field attributes
-                        for attr in field_attrs2:
-                            if not attr in field_attrs1:
-                                print('    added %s attribute %s=%s' % (
-                                    name, attr, field_attrs2[attr]))
-
-                        # find removed field attributes
-                        for attr in field_attrs1:
-                            if not attr in field_attrs2:
-                                print('    removed attribute %s(%s=%s)' % (
-                                    name, attr, field_attrs1[attr]))
-
-                        # compare field attributes
-                        for attr in field_attrs1:
-                            if attr in field_attrs2:
-
-                                value1 = field_attrs1[attr]
-                                value2 = field_attrs2[attr]
-                                if value1 != value2:
-                                    print('    %s attribute %s changed from %s to %s' % (
-                                        name, attr, value1, value2))
-
-    return migration2
diff --git a/src/south/management/commands/migrationcheck.py b/src/south/management/commands/migrationcheck.py
deleted file mode 100644
index 2c3eb036c6..0000000000
--- a/src/south/management/commands/migrationcheck.py
+++ /dev/null
@@ -1,68 +0,0 @@
-from django.core.exceptions import ImproperlyConfigured
-from django.core.management import call_command, CommandError
-from django.core.management.base import BaseCommand
-from django.conf import settings
-from django.db.models import loading
-from django.test import simple
-
-from south.migration import Migrations
-from south.exceptions import NoMigrations
-from south.hacks import hacks
-
-
-class Command(BaseCommand):
-    help = "Runs migrations for each app in turn, detecting missing depends_on values."
-    usage_str = "Usage: ./manage.py migrationcheck"
-
-    def handle(self, check_app_name=None, **options):
-        runner = simple.DjangoTestSuiteRunner(verbosity=0)
-        err_msg = "Failed to migrate %s; see output for hints at missing dependencies:\n"
-        hacks.patch_flush_during_test_db_creation()
-        failures = 0
-        if check_app_name is None:
-            app_names = settings.INSTALLED_APPS
-        else:
-            app_names = [check_app_name]
-        for app_name in app_names:
-            app_label = app_name.split(".")[-1]
-            if app_name == 'south':
-                continue
-
-            try:
-                Migrations(app_name)
-            except (NoMigrations, ImproperlyConfigured):
-                continue
-            app = loading.get_app(app_label)
-
-            verbosity = int(options.get('verbosity', 1))
-            if verbosity >= 1:
-                self.stderr.write("processing %s\n" % app_name)
-
-            old_config = runner.setup_databases()
-            try:
-                call_command('migrate', app_label, noinput=True, verbosity=verbosity)
-                for model in loading.get_models(app):
-                    dummy = model._default_manager.exists()
-            except (KeyboardInterrupt, SystemExit):
-                raise
-            except Exception as e:
-                failures += 1
-                if verbosity >= 1:
-                    self.stderr.write(err_msg % app_name)
-                    self.stderr.write("%s\n" % e)
-            finally:
-                runner.teardown_databases(old_config)
-        if failures > 0:
-            raise CommandError("Missing depends_on found in %s app(s)." % failures)
-        self.stderr.write("No missing depends_on found.\n")
-#
-# for each app:
-#    start with blank db.
-#    syncdb only south (and contrib?)
-#
-#    migrate a single app all the way up.  any errors is missing depends_on.
-#    for all models of that app, try the default manager:
-#        from django.db.models import loading
-#        for m in loading.get_models(loading.get_app('a')):
-#            m._default_manager.exists()
-#    Any error is also a missing depends on.
diff --git a/src/south/management/commands/south_migrate.py b/src/south/management/commands/south_migrate.py
new file mode 100644
index 0000000000..70699f82e3
--- /dev/null
+++ b/src/south/management/commands/south_migrate.py
@@ -0,0 +1,267 @@
+"""
+Migrate management command.
+"""
+
+from __future__ import print_function
+
+import os.path
+import re
+import sys
+from functools import reduce
+from optparse import make_option
+
+from django.core.management.base import BaseCommand
+from django.conf import settings
+from django.utils.importlib import import_module
+
+from south import migration
+from south.migration import Migrations
+from south.exceptions import NoMigrations
+from south.db import DEFAULT_DB_ALIAS
+
+
+class Command(BaseCommand):
+    option_list = BaseCommand.option_list + (
+        make_option('--all', action='store_true', dest='all_apps', default=False,
+                    help='Run the specified migration for all apps.'),
+        make_option('--list', action='store_true', dest='show_list', default=False,
+                    help='List migrations noting those that have been applied'),
+        make_option('--changes', action='store_true', dest='show_changes', default=False,
+                    help='List changes for migrations'),
+        make_option('--skip', action='store_true', dest='skip', default=False,
+                    help='Will skip over out-of-order missing migrations'),
+        make_option('--merge', action='store_true', dest='merge', default=False,
+                    help='Will run out-of-order missing migrations as they are - no rollbacks.'),
+        make_option('--fake', action='store_true', dest='fake', default=False,
+                    help="Pretends to do the migrations, but doesn't actually execute them."),
+        make_option('--db-dry-run', action='store_true', dest='db_dry_run', default=False,
+                    help="Doesn't execute the SQL generated by the db methods, and doesn't store a record that the migration(s) occurred. Useful to test migrations before applying them."),
+        make_option('--delete-ghost-migrations', action='store_true', dest='delete_ghosts', default=False,
+                    help="Tells South to delete any 'ghost' migrations (ones in the database but not on disk)."),
+        make_option('--ignore-ghost-migrations', action='store_true', dest='ignore_ghosts', default=False,
+                    help="Tells South to ignore any 'ghost' migrations (ones in the database but not on disk) and continue to apply new migrations."),
+        make_option('--noinput', action='store_false', dest='interactive', default=True,
+                    help='Tells Django to NOT prompt the user for input of any kind.'),
+        make_option('--database', action='store', dest='database',
+                    default=DEFAULT_DB_ALIAS, help='Nominates a database to synchronize. '
+                    'Defaults to the "default" database.'),
+    )
+    help = "Runs migrations for all apps."
+    args = "[appname] [migrationname|zero] [--all] [--list] [--skip] [--merge] [--no-initial-data] [--fake] [--db-dry-run] [--database=dbalias]"
+
+    def handle(self, app=None, target=None, skip=False, merge=False, backwards=False, fake=False, db_dry_run=False,
+               show_list=False, show_changes=False, database=DEFAULT_DB_ALIAS, delete_ghosts=False, ignore_ghosts=False, **options):
+
+        # NOTE: THIS IS DUPLICATED FROM django.core.management.commands.syncdb
+        # This code imports any module named 'management' in INSTALLED_APPS.
+        # The 'management' module is the preferred way of listening to post_syncdb
+        # signals, and since we're sending those out with create_table migrations,
+        # we need apps to behave correctly.
+        for app_name in settings.INSTALLED_APPS:
+            try:
+                import_module('.management', app_name)
+            except ImportError as exc:
+                msg = exc.args[0]
+                if not msg.startswith('No module named') or 'management' not in msg:
+                    raise
+        # END DJANGO DUPE CODE
+
+        # if all_apps flag is set, shift app over to target
+        if options.get('all_apps', False):
+            target = app
+            app = None
+
+        # Migrate each app
+        if app:
+            try:
+                apps = [Migrations(app)]
+            except NoMigrations:
+                print("The app '%s' does not appear to use migrations." % app)
+                print("./manage.py migrate " + self.args)
+                return
+        else:
+            apps = list(migration.all_migrations())
+
+        # Do we need to show the list of migrations?
+        if show_list and apps:
+            list_migrations(apps, database, **options)
+
+        if show_changes and apps:
+            show_migration_changes(apps)
+
+        if not (show_list or show_changes):
+            for app in apps:
+                result = migration.migrate_app(
+                    app,
+                    target_name=target,
+                    fake=fake,
+                    db_dry_run=db_dry_run,
+                    verbosity=int(options.get('verbosity', 0)),
+                    interactive=options.get('interactive', True),
+                    merge=merge,
+                    skip=skip,
+                    database=database,
+                    delete_ghosts=delete_ghosts,
+                    ignore_ghosts=ignore_ghosts,
+                )
+                if result is False:
+                    sys.exit(1)  # Migration failed, so the command fails.
+
+
+def list_migrations(apps, database=DEFAULT_DB_ALIAS, **options):
+    """
+    Prints a list of all available migrations, and which ones are currently applied.
+    Accepts a list of Migrations instances.
+    """
+    from south.models import MigrationHistory
+    applied_migrations = MigrationHistory.objects.filter(
+        app_name__in=[app.app_label() for app in apps])
+    if database != DEFAULT_DB_ALIAS:
+        applied_migrations = applied_migrations.using(database)
+    applied_migrations_lookup = dict(('%s.%s' % (mi.app_name, mi.migration), mi)
+                                     for mi in applied_migrations)
+
+    print()
+    for app in apps:
+        print(" " + app.app_label())
+        # Get the migrations object
+        for migration in app:
+            full_name = migration.app_label() + "." + migration.name()
+            if full_name in applied_migrations_lookup:
+                applied_migration = applied_migrations_lookup[full_name]
+                print(
+                    format_migration_list_item(
+                        migration.name(),
+                        applied=applied_migration.applied,
+                        **options))
+            else:
+                print(format_migration_list_item(migration.name(), applied=False, **options))
+        print()
+
+
+def show_migration_changes(apps):
+    """
+    Prints a list of all available migrations, and which ones are currently applied.
+    Accepts a list of Migrations instances.
+
+    Much simpler, less clear, and much less robust version:
+        grep "ing " migrations/*.py
+    """
+    for app in apps:
+        print(app.app_label())
+        # Get the migrations objects
+        migrations = [migration for migration in app]
+        # we use reduce to compare models in pairs, not to generate a value
+        reduce(diff_migrations, migrations)
+
+
+def format_migration_list_item(name, applied=True, **options):
+    if applied:
+        if int(options.get('verbosity')) >= 2:
+            return '  (*) %-80s  (applied %s)' % (name, applied)
+        else:
+            return '  (*) %s' % name
+    else:
+        return '  ( ) %s' % name
+
+
+def diff_migrations(migration1, migration2):
+
+    def model_name(models, model):
+        return models[model].get('Meta', {}).get('object_name', model)
+
+    def field_name(models, model, field):
+        return '%s.%s' % (model_name(models, model), field)
+
+    print("  " + migration2.name())
+
+    models1 = migration1.migration_class().models
+    models2 = migration2.migration_class().models
+
+    # find new models
+    for model in models2.keys():
+        if not model in models1.keys():
+            print('    added model %s' % model_name(models2, model))
+
+    # find removed models
+    for model in models1.keys():
+        if not model in models2.keys():
+            print('    removed model %s' % model_name(models1, model))
+
+    # compare models
+    for model in models1:
+        if model in models2:
+
+            # find added fields
+            for field in models2[model]:
+                if not field in models1[model]:
+                    print('    added field %s' % field_name(models2, model, field))
+
+            # find removed fields
+            for field in models1[model]:
+                if not field in models2[model]:
+                    print('    removed field %s' % field_name(models1, model, field))
+
+            # compare fields
+            for field in models1[model]:
+                if field in models2[model]:
+
+                    name = field_name(models1, model, field)
+
+                    # compare field attributes
+                    field_value1 = models1[model][field]
+                    field_value2 = models2[model][field]
+
+                    # if a field has become a class, or vice versa
+                    if type(field_value1) != type(field_value2):
+                        print('    type of %s changed from %s to %s' % (
+                            name, field_value1, field_value2))
+
+                    # if class
+                    elif isinstance(field_value1, dict):
+                        # print '    %s is a class' % name
+                        pass
+
+                    # else regular field
+                    else:
+
+                        type1, attr_list1, field_attrs1 = models1[model][field]
+                        type2, attr_list2, field_attrs2 = models2[model][field]
+
+                        if type1 != type2:
+                            print('    %s type changed from %s to %s' % (
+                                name, type1, type2))
+
+                        if attr_list1 != []:
+                            print('    %s list %s is not []' % (
+                                name, attr_list1))
+                        if attr_list2 != []:
+                            print('    %s list %s is not []' % (
+                                name, attr_list2))
+                        if attr_list1 != attr_list2:
+                            print('    %s list changed from %s to %s' % (
+                                name, attr_list1, attr_list2))
+
+                        # find added field attributes
+                        for attr in field_attrs2:
+                            if not attr in field_attrs1:
+                                print('    added %s attribute %s=%s' % (
+                                    name, attr, field_attrs2[attr]))
+
+                        # find removed field attributes
+                        for attr in field_attrs1:
+                            if not attr in field_attrs2:
+                                print('    removed attribute %s(%s=%s)' % (
+                                    name, attr, field_attrs1[attr]))
+
+                        # compare field attributes
+                        for attr in field_attrs1:
+                            if attr in field_attrs2:
+
+                                value1 = field_attrs1[attr]
+                                value2 = field_attrs2[attr]
+                                if value1 != value2:
+                                    print('    %s attribute %s changed from %s to %s' % (
+                                        name, attr, value1, value2))
+
+    return migration2
diff --git a/src/south/management/commands/syncdb.py b/src/south/management/commands/syncdb.py
index d2262f9c36..26a5e7ca05 100644
--- a/src/south/management/commands/syncdb.py
+++ b/src/south/management/commands/syncdb.py
@@ -5,50 +5,57 @@ Overridden syncdb command
 from __future__ import print_function
 
 import sys
+
+from importlib import import_module
 from optparse import make_option
 
-from django.core.management.base import NoArgsCommand, BaseCommand
+from django.core.management.base import NoArgsCommand, BaseCommand, CommandError
 from django.core.management.color import no_style
 from django.utils.datastructures import SortedDict
 from django.core.management.commands import syncdb
 from django.conf import settings
-from django.db import models
+from django.db import connections, models
 from django.db.models.loading import cache
 from django.core import management
 
+try:
+    from django.apps import apps
+except ImportError:
+    apps = None
+
 from south.db import dbs
 from south import migration
+from south.constants import DJANGO_17
 from south.exceptions import NoMigrations
-
-
-def get_app_label(app):
-    return '.'.join(app.__name__.split('.')[0:-1])
+from south.migration.utils import get_app_label
 
 
 class Command(NoArgsCommand):
     option_list = syncdb.Command.option_list + (
-        make_option('--migrate', action='store_true', dest='migrate', default=False,
-                    help='Tells South to also perform migrations after the sync. Default for during testing, and other internal calls.'),
-        make_option('--all', action='store_true', dest='migrate_all', default=False,
-                    help='Makes syncdb work on all apps, even migrated ones. Be careful!'),
+        make_option('--migrate', action='store_true', dest='migrate', default=True,
+                    help='Tells South to enable migrations after the sync. Default for during testing, and other internal calls.'),
+        make_option('--merge', action='store_true', dest='merge', default=True,
+                    help='Will run out-of-order missing migrations as they are - no rollbacks.'),
+        make_option('--delete-ghost-migrations', action='store_true', dest='delete_ghosts', default=False,
+                    help="Tells South to delete any 'ghost' migrations (ones in the database but not on disk)."),
+        make_option('--ignore-ghost-migrations', action='store_true', dest='ignore_ghosts', default=True,
+                    help="Tells South to ignore any 'ghost' migrations (ones in the database but not on disk) and continue to apply new migrations."),
     )
-    if '--verbosity' not in [opt.get_opt_string() for opt in syncdb.Command.option_list]:
-        option_list += (
-            make_option('--verbosity', action='store', dest='verbosity', default='1',
-                        type='choice', choices=['0', '1', '2'],
-                        help='Verbosity level; 0=minimal output, 1=normal output, 2=all output'),
-        )
     help = "Create the database tables for all apps in INSTALLED_APPS whose tables haven't already been created, except those which use migrations."
 
-    def handle_noargs(self, migrate_all=False, **options):
-
+    def handle_noargs(self, **options):
         # Import the 'management' module within each installed app, to register
         # dispatcher events.
-        # This is copied from Django, to fix bug #511.
-        try:
-            from django.utils.importlib import import_module
-        except ImportError:
-            pass  # TODO: Remove, only for Django1.0
+        if not hasattr(self, 'stdout'):
+            self.stdout = sys.stdout
+            self.stderr = sys.stderr
+        if DJANGO_17:
+            from django.apps import apps
+            from django.utils.module_loading import module_has_submodule
+
+            for app_config in apps.get_app_configs():
+                if module_has_submodule(app_config.module, "management"):
+                    import_module('.management', app_config.name)
         else:
             for app_name in settings.INSTALLED_APPS:
                 try:
@@ -61,11 +68,26 @@ class Command(NoArgsCommand):
         # Work out what uses migrations and so doesn't need syncing
         apps_needing_sync = []
         apps_migrated = []
-        for app in models.get_apps():
-            app_label = get_app_label(app)
-            if migrate_all:
-                apps_needing_sync.append(app_label)
-            else:
+        app_name_to_app_map = {}
+
+        if DJANGO_17:
+            for app_config in apps.get_app_configs():
+                if not app_config.models_module:
+                    continue
+
+                app_label = get_app_label(app_config.models_module)
+                app_name_to_app_map[app_label] = app_config
+                try:
+                    migrations = migration.Migrations(app_label)
+                except NoMigrations:
+                    # It needs syncing
+                    apps_needing_sync.append(app_label)
+                else:
+                    # This is a migrated app, leave it
+                    apps_migrated.append(app_label)
+        else:
+            for app in models.get_apps():
+                app_label = get_app_label(app)
                 try:
                     migrations = migration.Migrations(app_label)
                 except NoMigrations:
@@ -74,44 +96,82 @@ class Command(NoArgsCommand):
                 else:
                     # This is a migrated app, leave it
                     apps_migrated.append(app_label)
+
         verbosity = int(options.get('verbosity', 0))
 
         # Run syncdb on only the ones needed
         if verbosity:
-            print("Syncing...")
-
-        old_installed, settings.INSTALLED_APPS = settings.INSTALLED_APPS, apps_needing_sync
-        old_app_store, cache.app_store = cache.app_store, SortedDict([
-            (k, v) for (k, v) in cache.app_store.items()
-            if get_app_label(k) in apps_needing_sync
-        ])
+            self.stdout.write("Syncing...\n")
 
         # This will allow the setting of the MySQL storage engine, for example.
         for db in dbs.values():
             db.connection_init()
 
-        # OK, run the actual syncdb
-        syncdb.Command().execute(**options)
-
-        settings.INSTALLED_APPS = old_installed
-        cache.app_store = old_app_store
+        # In Django 1.7 we need to actually run migrations (Sentry specifically)
+        # as it creates the 'auth' table. To run migrations however we still need
+        # to create the south tables ahead of time.
+        if DJANGO_17:
+            self.sync_apps(['south'], app_name_to_app_map, options)
+            apps_needing_sync.remove('south')
+        # In 1.6 the constraints dont function/get created in the same way, and
+        # additionally contenttypes tries to apply so syncing just south isnt enough
+        else:
+            self.sync_apps(apps_needing_sync, app_name_to_app_map, options)
 
         # Migrate if needed
         if options.get('migrate', True):
             if verbosity:
-                print("Migrating...")
-            # convert from store_true to store_false
-            options['no_initial_data'] = not options.get('load_initial_data', True)
-            management.call_command('migrate', **options)
+                self.stdout.write("Migrating...\n")
+            management.call_command('south_migrate', **options)
+
+        if DJANGO_17:
+            self.sync_apps(apps_needing_sync, app_name_to_app_map, options)
 
         # Be obvious about what we did
         if verbosity:
-            print("\nSynced:\n > %s" % "\n > ".join(apps_needing_sync))
+            self.stdout.write("\nSynced:\n > {}\n".format("\n > ".join(apps_needing_sync)))
 
         if options.get('migrate', True):
             if verbosity:
-                print("\nMigrated:\n - %s" % "\n - ".join(apps_migrated))
+                self.stdout.write("\nMigrated:\n - {}\n".format("\n - ".join(apps_migrated)))
         else:
             if verbosity:
-                print("\nNot synced (use migrations):\n - %s" % "\n - ".join(apps_migrated))
-                print("(use ./manage.py migrate to migrate these)")
+                self.stdout.write(
+                    "\nNot synced (use migrations):\n - {}\n".format(
+                        "\n - ".join(apps_migrated)))
+                self.stdout.write("(use ./manage.py migrate to migrate these)\n")
+
+    def sync_apps(self, app_labels, app_name_to_app_map, options):
+        if DJANGO_17:
+            from django.db.migrations.executor import MigrationExecutor
+            from django.core.management.commands import migrate
+
+            apps_to_sync = []
+            for app_label in app_labels:
+                app_label = app_name_to_app_map[app_label].label if app_label in app_name_to_app_map else app_label
+                apps_to_sync.append(app_label)
+
+            connection = connections[options.get('database', 'default')]
+
+            cmd = migrate.Command()
+            cmd.stdout = self.stdout
+            cmd.stderr = self.stderr
+            cmd.run_syncdb = True
+            cmd.verbosity = int(options.get('verbosity'))
+            cmd.interactive = options.get('interactive')
+            cmd.show_traceback = options.get('traceback')
+            cmd.load_initial_data = options.get('load_initial_data')
+            cmd.test_database = options.get('test_database', False)
+            cmd.sync_apps(connection, apps_to_sync)
+        else:
+            old_installed, settings.INSTALLED_APPS = settings.INSTALLED_APPS, app_labels
+            old_app_store, cache.app_store = cache.app_store, SortedDict([
+                (k, v) for (k, v) in cache.app_store.items()
+                if get_app_label(k) in app_labels
+            ])
+
+            # OK, run the actual syncdb
+            syncdb.Command().execute(**options)
+
+            settings.INSTALLED_APPS = old_installed
+            cache.app_store = old_app_store
diff --git a/src/south/management/commands/test.py b/src/south/management/commands/test.py
deleted file mode 100644
index bc721bb15b..0000000000
--- a/src/south/management/commands/test.py
+++ /dev/null
@@ -1,9 +0,0 @@
-from django.core.management.commands import test
-
-from south.management.commands import patch_for_test_db_setup
-
-
-class Command(test.Command):
-    def handle(self, *args, **kwargs):
-        patch_for_test_db_setup()
-        super(Command, self).handle(*args, **kwargs)
diff --git a/src/south/migration/__init__.py b/src/south/migration/__init__.py
index 19afdbae55..ba159ba481 100644
--- a/src/south/migration/__init__.py
+++ b/src/south/migration/__init__.py
@@ -13,8 +13,7 @@ from south import exceptions
 from south.models import MigrationHistory
 from south.db import db, DEFAULT_DB_ALIAS
 from south.migration.migrators import (Backwards, Forwards,
-                                       DryRunMigrator, FakeMigrator,
-                                       LoadInitialDataMigrator)
+                                       DryRunMigrator, FakeMigrator)
 from south.migration.base import Migration, Migrations
 from south.migration.utils import SortedSet
 from south.migration.base import all_migrations
@@ -147,15 +146,13 @@ def get_direction(target, applied, migrations, verbosity, interactive):
     return direction, problems, workplan
 
 
-def get_migrator(direction, db_dry_run, fake, load_initial_data):
+def get_migrator(direction, db_dry_run, fake):
     if not direction:
         return direction
     if db_dry_run:
         direction = DryRunMigrator(migrator=direction, ignore_fail=False)
     elif fake:
         direction = FakeMigrator(migrator=direction)
-    elif load_initial_data:
-        direction = LoadInitialDataMigrator(migrator=direction)
     return direction
 
 
@@ -169,7 +166,7 @@ def get_unapplied_migrations(migrations, applied_migrations):
 
 
 def migrate_app(migrations, target_name=None, merge=False, fake=False, db_dry_run=False, yes=False, verbosity=0,
-                load_initial_data=False, skip=False, database=DEFAULT_DB_ALIAS, delete_ghosts=False, ignore_ghosts=False, interactive=False):
+                skip=False, database=DEFAULT_DB_ALIAS, delete_ghosts=False, ignore_ghosts=False, interactive=False):
     app_label = migrations.app_label()
 
     verbosity = int(verbosity)
@@ -228,7 +225,7 @@ def migrate_app(migrations, target_name=None, merge=False, fake=False, db_dry_ru
         raise exceptions.InconsistentMigrationHistory(problems)
 
     # Perform the migration
-    migrator = get_migrator(direction, db_dry_run, fake, load_initial_data)
+    migrator = get_migrator(direction, db_dry_run, fake)
     if migrator:
         migrator.print_title(target)
         success = migrator.migrate_many(target, workplan, database)
@@ -244,12 +241,6 @@ def migrate_app(migrations, target_name=None, merge=False, fake=False, db_dry_ru
         if verbosity:
             # Say there's nothing.
             print('- Nothing to migrate.')
-        # If we have initial data enabled, and we're at the most recent
-        # migration, do initial data.
-        # Note: We use a fake Forwards() migrator here. It's never used really.
-        if load_initial_data:
-            migrator = LoadInitialDataMigrator(migrator=Forwards(verbosity=verbosity))
-            migrator.load_initial_data(target, db=database)
         # Send signal.
         post_migrate.send(
             None,
diff --git a/src/south/migration/base.py b/src/south/migration/base.py
index 8614c4891d..b3f6ca3afe 100644
--- a/src/south/migration/base.py
+++ b/src/south/migration/base.py
@@ -1,23 +1,23 @@
 from __future__ import print_function
 
-from collections import deque
 import datetime
-from imp import reload
 import os
 import re
+import six
 import sys
 
+from collections import deque
 from django.core.exceptions import ImproperlyConfigured
 from django.db import models
 from django.conf import settings
 from django.utils import importlib
+from imp import reload
 
 from south import exceptions
-from south.migration.utils import depends, dfs, flatten, get_app_label
+from south.constants import DJANGO_17
+from south.migration.utils import app_label_to_app_module, depends, dfs, flatten, get_app_label
 from south.orm import FakeORM
 from south.utils import memoize, ask_for_it_by_name, datetime_utils
-from south.migration.utils import app_label_to_app_module
-from south.utils.py3 import string_types, with_metaclass
 
 
 def all_migrations(applications=None):
@@ -27,45 +27,34 @@ def all_migrations(applications=None):
     if applications is None:
         applications = models.get_apps()
     for model_module in applications:
-        # The app they've passed is the models module - go up one level
-        app_path = ".".join(model_module.__name__.split(".")[:-1])
-        app = ask_for_it_by_name(app_path)
+        app_label = get_app_label(model_module)
         try:
-            yield Migrations(app)
+            yield Migrations(app_label)
         except exceptions.NoMigrations:
             pass
 
 
-def application_to_app_label(application):
-    "Works out the app label from either the app label, the app name, or the module"
-    if isinstance(application, string_types):
-        app_label = application.split('.')[-1]
-    else:
-        app_label = application.__name__.split('.')[-1]
-    return app_label
-
-
 class MigrationsMetaclass(type):
-
     """
     Metaclass which ensures there is only one instance of a Migrations for
     any given app.
+
+    This implements an identity mapper on ``Migrations(application)`` based on the label.
     """
 
     def __init__(self, name, bases, dict):
         super(MigrationsMetaclass, self).__init__(name, bases, dict)
         self.instances = {}
 
-    def __call__(self, application, **kwds):
-
-        app_label = application_to_app_label(application)
-
-        # If we don't already have an instance, make one
+    def __call__(self, application_or_app_label, **kwds):
+        if isinstance(application_or_app_label, six.string_types):
+            app_label = application_or_app_label
+        else:
+            app_label = get_app_label(application_or_app_label)
         if app_label not in self.instances:
             self.instances[app_label] = super(
                 MigrationsMetaclass, self).__call__(
-                app_label_to_app_module(app_label), **kwds)
-
+                application_or_app_label, **kwds)
         return self.instances[app_label]
 
     def _clear_cache(self):
@@ -73,7 +62,7 @@ class MigrationsMetaclass(type):
         self.instances = {}
 
 
-class Migrations(with_metaclass(MigrationsMetaclass, list)):
+class Migrations(six.with_metaclass(MigrationsMetaclass, list)):
     """
     Holds a list of Migration objects for a particular app.
     """
@@ -91,10 +80,15 @@ class Migrations(with_metaclass(MigrationsMetaclass, list)):
                                         r'[0-9a-zA-Z_]*'
                                         r'(\.py)?$')       # Match only .py files, or module dirs
 
-    def __init__(self, application, force_creation=False, verbose_creation=True):
+    def __init__(self, application_or_app_label, force_creation=False, verbose_creation=True):
         "Constructor. Takes the module of the app, NOT its models (like get_app returns)"
         self._cache = {}
-        self.set_application(application, force_creation, verbose_creation)
+        self.set_application(application_or_app_label, force_creation, verbose_creation)
+
+    def __repr__(self):
+        return u'<Migrations: {}>'.format(
+            self.app_label(),
+        )
 
     def create_migrations_directory(self, verbose=True):
         "Given an application, ensures that the migrations directory is ready."
@@ -118,42 +112,15 @@ class Migrations(with_metaclass(MigrationsMetaclass, list)):
         If it doesn't exist yet, returns where it would exist, based on the
         app's migrations module (defaults to app.migrations)
         """
-        module_path = self.migrations_module()
-        try:
-            module = importlib.import_module(module_path)
-        except ImportError:
-            # There's no migrations module made yet; guess!
-            try:
-                parent = importlib.import_module(".".join(module_path.split(".")[:-1]))
-            except ImportError:
-                # The parent doesn't even exist, that's an issue.
-                raise exceptions.InvalidMigrationModule(
-                    application=self.application.__name__,
-                    module=module_path,
-                )
-            else:
-                # Good guess.
-                return os.path.join(os.path.dirname(parent.__file__), module_path.split(".")[-1])
-        else:
-            # Get directory directly
-            return os.path.dirname(module.__file__)
+        module = self.migrations_module()
+        return os.path.dirname(module.__file__)
 
     def migrations_module(self):
         "Returns the module name of the migrations module for this"
-        app_label = application_to_app_label(self.application)
-        if hasattr(settings, "SOUTH_MIGRATION_MODULES"):
-            if app_label in settings.SOUTH_MIGRATION_MODULES:
-                # There's an override.
-                return settings.SOUTH_MIGRATION_MODULES[app_label]
-        # We see if the south_migrations module exists first, and
-        # use that if we find it.
-        module_name = self._application.__name__ + '.south_migrations'
-        try:
-            importlib.import_module(module_name)
-        except ImportError:
-            return self._application.__name__ + '.migrations'
-        else:
-            return module_name
+        full_name = '{}.south_migrations'.format(self._application.__name__)
+        if full_name in sys.modules:
+            return sys.modules[full_name]
+        return __import__(full_name, {}, {}, ['south_migrations'], -1)
 
     def get_application(self):
         return self._application
@@ -163,22 +130,26 @@ class Migrations(with_metaclass(MigrationsMetaclass, list)):
         Called when the application for this Migrations is set.
         Imports the migrations module object, and throws a paddy if it can't.
         """
+        if isinstance(application, six.string_types):
+            if application in sys.modules:
+                application = sys.modules[application]
+            else:
+                application = app_label_to_app_module(application)
+
         self._application = application
-        if not hasattr(application, 'migrations') and not hasattr(application, 'south_migrations'):
+        if not hasattr(application, 'south_migrations'):
             try:
-                module = importlib.import_module(self.migrations_module())
-                self._migrations = application.migrations = module
+                module = self.migrations_module()
+                self._migrations = application.south_migrations = module
             except ImportError:
                 if force_creation:
                     self.create_migrations_directory(verbose_creation)
-                    module = importlib.import_module(self.migrations_module())
-                    self._migrations = application.migrations = module
+                    module = self.migrations_module()
+                    self._migrations = application.south_migrations = module
                 else:
-                    raise exceptions.NoMigrations(application)
+                    six.reraise(exceptions.NoMigrations, exceptions.NoMigrations(application))
         if hasattr(application, 'south_migrations'):
             self._load_migrations_module(application.south_migrations)
-        else:
-            self._load_migrations_module(application.migrations)
 
     application = property(get_application, set_application)
 
@@ -209,7 +180,7 @@ class Migrations(with_metaclass(MigrationsMetaclass, list)):
         return self._cache[name]
 
     def __getitem__(self, value):
-        if isinstance(value, string_types):
+        if isinstance(value, six.string_types):
             return self.migration(value)
         return super(Migrations, self).__getitem__(value)
 
@@ -232,7 +203,7 @@ class Migrations(with_metaclass(MigrationsMetaclass, list)):
             return self._guess_migration(prefix=target_name)
 
     def app_label(self):
-        return self._application.__name__.split('.')[-1]
+        return self._application.__name__
 
     def full_name(self):
         return self._migrations.__name__
diff --git a/src/south/migration/migrators.py b/src/south/migration/migrators.py
index 0f116d5d98..8d1acc3473 100644
--- a/src/south/migration/migrators.py
+++ b/src/south/migration/migrators.py
@@ -209,56 +209,6 @@ class FakeMigrator(MigratorWrapper):
         pass
 
 
-class LoadInitialDataMigrator(MigratorWrapper):
-
-    def load_initial_data(self, target, db='default'):
-        if target is None or target != target.migrations[-1]:
-            return
-        # Load initial data, if we ended up at target
-        if self.verbosity:
-            print(" - Loading initial data for %s." % target.app_label())
-        if DJANGO_VERSION < (1, 6):
-            self.pre_1_6(target, db)
-        else:
-            self.post_1_6(target, db)
-
-    def pre_1_6(self, target, db):
-        # Override Django's get_apps call temporarily to only load from the
-        # current app
-        old_get_apps = models.get_apps
-
-        def new_get_apps(): return [models.get_app(target.app_label())]
-        models.get_apps = new_get_apps
-        loaddata.get_apps = new_get_apps
-        try:
-            call_command('loaddata', 'initial_data', verbosity=self.verbosity, database=db)
-        finally:
-            models.get_apps = old_get_apps
-            loaddata.get_apps = old_get_apps
-
-    def post_1_6(self, target, db):
-        import django.db.models.loading
-        # build a new 'AppCache' object with just the app we care about.
-        old_cache = django.db.models.loading.cache
-        new_cache = django.db.models.loading.AppCache()
-        new_cache.get_apps = lambda: [new_cache.get_app(target.app_label())]
-
-        # monkeypatch
-        django.db.models.loading.cache = new_cache
-        try:
-            call_command('loaddata', 'initial_data', verbosity=self.verbosity, database=db)
-        finally:
-            # unmonkeypatch
-            django.db.models.loading.cache = old_cache
-
-    def migrate_many(self, target, migrations, database):
-        migrator = self._migrator
-        result = migrator.__class__.migrate_many(migrator, target, migrations, database)
-        if result:
-            self.load_initial_data(target, db=database)
-        return True
-
-
 class Forwards(Migrator):
     """
     Runs the specified migration forwards, in order.
diff --git a/src/south/migration/utils.py b/src/south/migration/utils.py
index c27cf16801..418bcb6600 100644
--- a/src/south/migration/utils.py
+++ b/src/south/migration/utils.py
@@ -1,10 +1,12 @@
+import six
 import sys
-from collections import deque
 
+from collections import deque
 from django.utils.datastructures import SortedDict
 from django.db import models
 
 from south import exceptions
+from south.constants import DJANGO_17
 
 
 class SortedSet(SortedDict):
@@ -24,12 +26,25 @@ class SortedSet(SortedDict):
         [self.add(k) for k in iterable]
 
 
-def get_app_label(app):
+def get_app_label(models_module):
     """
-    Returns the _internal_ app label for the given app module.
-    i.e. for <module django.contrib.auth.models> will return 'auth'
+    Works out the app label from either the app label, the app name, or the module
+
+    For example, this will convert:
+
+    >>> <module 'sentry_plugins.hipchat_ac.models'>
+
+    into:
+
+    >>> 'sentry_plugins.hipchat_ac'
     """
-    return app.__name__.split('.')[-2]
+    if isinstance(models_module, six.string_types):
+        if DJANGO_17:
+            return models_module.rsplit('.')[0]
+        return models_module.rsplit('.', 1)[0]
+    if DJANGO_17:
+        return models_module.__name__.rsplit('.', 1)[0]
+    return models_module.__name__.rsplit('.', 1)[0]
 
 
 def app_label_to_app_module(app_label):
@@ -39,11 +54,11 @@ def app_label_to_app_module(app_label):
     """
     # Get the models module
     app = models.get_app(app_label)
-    module_name = ".".join(app.__name__.split(".")[:-1])
+    module_name = app.__name__.rsplit('.', 1)[0]
     try:
         module = sys.modules[module_name]
     except KeyError:
-        __import__(module_name, {}, {}, [''])
+        __import__(module_name, {}, {}, [])
         module = sys.modules[module_name]
     return module
 
diff --git a/src/south/models.py b/src/south/models.py
index 99845d221d..6cd89044a5 100644
--- a/src/south/models.py
+++ b/src/south/models.py
@@ -1,13 +1,6 @@
 from django.db import models
 from south.db import DEFAULT_DB_ALIAS
 
-# If we detect Django 1.7 or higher, then exit
-# Placed here so it's guaranteed to be imported on Django start
-import django
-if django.VERSION[0] > 1 or (django.VERSION[0] == 1 and django.VERSION[1] > 6):
-    raise RuntimeError(
-        "South does not support Django 1.7 or higher. Please use native Django migrations.")
-
 
 class MigrationHistory(models.Model):
     app_name = models.CharField(max_length=255)
diff --git a/src/south/orm.py b/src/south/orm.py
index 705d37b199..911e179f18 100644
--- a/src/south/orm.py
+++ b/src/south/orm.py
@@ -333,17 +333,17 @@ class _FakeORM(object):
                 fields[fname] = field
 
         # Find the app in the Django core, and get its module
-        more_kwds = {}
+        more_kwds = {
+            'Meta': meta,
+        }
         try:
             app_module = models.get_app(app)
             more_kwds['__module__'] = app_module.__name__
         except ImproperlyConfigured:
-            # The app this belonged to has vanished, but thankfully we can still
+            # the app this belonged to has vanished, but thankfully we can still
             # make a mock model, so ignore the error.
             more_kwds['__module__'] = '_south_mock'
 
-        more_kwds['Meta'] = meta
-
         # Make our model
         fields.update(more_kwds)
 

commit 10380d6fe20d3a0658bc92110e9f9ac32eec43b3
Author: Yaniv Aknin <yaniv@aknin.name>
Date:   Thu Dec 29 00:32:11 2011 +0200

    break web.api to many small functions

diff --git a/sentry/web/api.py b/sentry/web/api.py
index 6358dd7cbb..3848821f3e 100644
--- a/sentry/web/api.py
+++ b/sentry/web/api.py
@@ -12,8 +12,7 @@ import logging
 import time
 import zlib
 
-from django.http import HttpResponse, HttpResponseBadRequest, \
-    HttpResponseForbidden, HttpResponseGone
+from django.http import HttpResponse
 from django.utils.encoding import smart_str
 from django.views.decorators.csrf import csrf_exempt
 from django.views.decorators.http import require_http_methods
@@ -23,117 +22,129 @@ from sentry.exceptions import InvalidData, InvalidInterface
 from sentry.models import Group, ProjectMember
 from sentry.utils import is_float, json
 from sentry.utils.auth import get_signature, parse_auth_header
-from sentry.utils.compat import pickle
 
 logger = logging.getLogger(__name__)
 
-
-@csrf_exempt
-@require_http_methods(['POST'])
-def store(request):
+class APIError(Exception):
+    http_status = 400
+    msg = 'Invalid request'
+    def __init__(self, msg=None):
+        if msg:
+            self.msg = msg
+    def as_http_response(self):
+        return HttpResponse(self.msg, status=self.http_status)
+class APIUnauthorized(APIError):
+    http_status = 401
+    msg = 'Unauthorized'
+class APIForbidden(APIError):
+    http_status = 403
+class APITimestampExpired(APIError):
+    http_status = 410
+
+def extract_auth_vars(request):
     if request.META.get('HTTP_X_SENTRY_AUTH', '').startswith('Sentry'):
         # Auth version 3.0 (same as 2.0, diff header)
-        auth_vars = parse_auth_header(request.META['HTTP_X_SENTRY_AUTH'])
+        return parse_auth_header(request.META['HTTP_X_SENTRY_AUTH'])
     elif request.META.get('HTTP_AUTHORIZATION', '').startswith('Sentry'):
         # Auth version 2.0
-        auth_vars = parse_auth_header(request.META['HTTP_AUTHORIZATION'])
+        return parse_auth_header(request.META['HTTP_AUTHORIZATION'])
     else:
-        auth_vars = None
+        return None
 
-    data = request.raw_post_data
+def project_from_auth_vars(auth_vars, data):
+    signature = auth_vars.get('sentry_signature')
+    timestamp = auth_vars.get('sentry_timestamp')
+    api_key = auth_vars.get('sentry_key')
+    if not signature or not timestamp:
+        raise APIUnauthorized()
 
-    if auth_vars:
-        signature = auth_vars.get('sentry_signature')
-        timestamp = auth_vars.get('sentry_timestamp')
-        api_key = auth_vars.get('sentry_key')
-        # version = auth_vars.get('sentry_version')
-
-        if api_key:
-            try:
-                pm = ProjectMember.objects.get(api_key=api_key)
-                if not pm.has_perm('add_message'):
-                    raise ProjectMember.DoesNotExist
-            except ProjectMember.DoesNotExist:
-                return HttpResponseForbidden('Invalid signature')
-            project = pm.project
-            secret_key = pm.secret_key
-        else:
-            project = None
-            secret_key = settings.KEY
+    if api_key:
+        try:
+            pm = ProjectMember.objects.get(api_key=api_key)
+            if not pm.has_perm('add_message'):
+                raise ProjectMember.DoesNotExist
+        except ProjectMember.DoesNotExist:
+            raise APIForbidden('Invalid signature')
+        project = pm.project
+        secret_key = pm.secret_key
+    else:
+        project = None
+        secret_key = settings.KEY
 
-        # Signed data packet
-        if signature and timestamp:
-            try:
-                timestamp_float = float(timestamp)
-            except ValueError:
-                return HttpResponseBadRequest('Invalid timestamp')
+    validate_hmac(data, signature, timestamp, secret_key)
 
-            if timestamp_float < time.time() - 3600:  # 1 hour
-                return HttpResponseGone('Message has expired')
+    return project
 
-            sig_hmac = get_signature(data, timestamp, secret_key)
-            if sig_hmac != signature:
-                return HttpResponseForbidden('Invalid signature')
-        else:
-            return HttpResponse('Unauthorized', status=401)
+def validate_hmac(message, signature, timestamp, secret_key):
+    try:
+        timestamp_float = float(timestamp)
+    except ValueError:
+        raise APIError('Invalid timestamp')
 
-    # SSL requests dont need a signature
-    elif request.GET.get('api_key') and request.GET.get('project_id'):
-        if not request.is_secure():
-            return HttpResponse('Unauthorized', status=401)
+    if timestamp_float < time.time() - 3600:  # 1 hour
+        raise APITimestampExpired('Message has expired')
 
-        api_key = request.GET['api_key']
-        project = request.GET['project_id']
+    sig_hmac = get_signature(message, timestamp, secret_key)
+    if sig_hmac != signature:
+        raise APIForbidden('Invalid signature')
 
-        try:
-            pm = ProjectMember.objects.get(api_key=api_key, project=project)
-            if not pm.has_perm('add_message'):
-                raise ProjectMember.DoesNotExist
-        except ProjectMember.DoesNotExist:
-            return HttpResponse('Unauthorized', status=401)
+def project_from_api_key_and_id(api_key, project):
+    try:
+        pm = ProjectMember.objects.get(api_key=api_key, project=project)
+    except ProjectMember.DoesNotExist:
+        raise APIUnauthorized()
 
-        project = pm.project
+    if not pm.has_perm('add_message'):
+        raise ProjectMember.DoesNotExist
 
-    # Support client side requests from our server from the authenticated user
-    elif request.GET.get('project_id') and request.user.is_authenticated():
-        try:
-            pm = ProjectMember.objects.get(user=request.user, project=request.GET['project_id'])
-            # TODO: do we need this check?
-            # if not pm.has_perm('add_message'):
-            #     raise ProjectMember.DoesNotExist
-        except ProjectMember.DoesNotExist:
-            return HttpResponse('Unauthorized', status=401)
+    return pm.project
 
-        project = pm.project
+def project_from_id(request):
+    try:
+        pm = ProjectMember.objects.get(user=request.user, project=request.GET['project_id'])
+        # TODO: do we need this check?
+        # if not pm.has_perm('add_message'):
+        #     raise ProjectMember.DoesNotExist
+    except ProjectMember.DoesNotExist:
+        raise APIUnauthorized()
 
-    else:
-        return HttpResponse('Unauthorized', status=401)
+    return pm.project
 
-    if not data.startswith('{'):
-        print "Decoding"
+def decode_and_decompress_data(encoded_data):
+    try:
         try:
-            try:
-                data = base64.b64decode(data).decode('zlib')
-            except zlib.error:
-                data = base64.b64decode(data)
-        except Exception, e:
-            # This error should be caught as it suggests that there's a
-            # bug somewhere in the client's code.
-            logger.exception('Bad data received')
-            return HttpResponseForbidden('Bad data decoding request (%s, %s)' % (e.__class__.__name__, e))
+            return base64.b64decode(encoded_data).decode('zlib')
+        except zlib.error:
+            return base64.b64decode(encoded_data)
+    except Exception, e:
+        # This error should be caught as it suggests that there's a
+        # bug somewhere in the client's code.
+        logger.exception('Bad data received')
+        raise APIForbidden('Bad data decoding request (%s, %s)' % (e.__class__.__name__, e))
 
+def safely_load_json_string(json_string):
     try:
-        data = json.loads(data)
+        obj = json.loads(json_string)
     except Exception, e:
         # This error should be caught as it suggests that there's a
         # bug somewhere in the client's code.
         logger.exception('Bad data received')
-        return HttpResponseForbidden('Bad data reconstructing object (%s, %s)' % (e.__class__.__name__, e))
+        raise APIForbidden('Bad data reconstructing object (%s, %s)' % (e.__class__.__name__, e))
 
     # XXX: ensure keys are coerced to strings
-    data = dict((smart_str(k), v) for k, v in data.iteritems())
+    return dict((smart_str(k), v) for k, v in obj.iteritems())
 
-    if 'timestamp' in data:
+
+def ensure_valid_project_id(desired_project, data):
+    # Confirm they're using either the master key, or their specified project matches with the
+    # signed project.
+    if desired_project and str(data.get('project', '')) != str(desired_project.pk):
+        raise APIForbidden('Invalid credentials')
+    elif not desired_project:
+        data['project'] = 1
+
+def insert_data_to_database(data):
+    def process_data_timestamp(data):
         if is_float(data['timestamp']):
             try:
                 data['timestamp'] = datetime.datetime.fromtimestamp(float(data['timestamp']))
@@ -153,17 +164,40 @@ def store(request):
             except:
                 logger.exception('Failed reading timestamp')
                 del data['timestamp']
-
-    # Confirm they're using either the master key, or their specified project matches with the
-    # signed project.
-    if project and str(data.get('project', '')) != str(project.pk):
-        return HttpResponseForbidden('Invalid credentials')
-    elif not project:
-        data['project'] = 1
+    if 'timestamp' in data:
+        process_data_timestamp(data)
 
     try:
         Group.objects.from_kwargs(**data)
     except (InvalidInterface, InvalidData), e:
-        return HttpResponseBadRequest(e)
+        raise APIError(e)
+
+@csrf_exempt
+@require_http_methods(['POST'])
+def store(request):
+    try:
+        auth_vars = extract_auth_vars(request)
+        data = request.raw_post_data
+
+        if auth_vars:
+            project = project_from_auth_vars(auth_vars, data)
+        elif request.GET.get('api_key') and request.GET.get('project_id') and request.is_secure():
+            # ssl requests dont have to have signature verification
+            project = project_from_api_key_and_id(request.GET['api_key'], request.GET['project_id'])
+        elif request.GET.get('project_id') and request.user.is_authenticated():
+            # authenticated users are simply trusted to provide the right id
+            project = project_from_id(request)
+        else:
+            raise APIUnauthorized()
+
+        if not data.startswith('{'):
+            data = decode_and_decompress_data(data)
+        data = safely_load_json_string(data)
+
+        ensure_valid_project_id(project, data)
 
+        insert_data_to_database(data)
+    except APIError, error:
+        return error.as_http_response()
     return HttpResponse('')
+    

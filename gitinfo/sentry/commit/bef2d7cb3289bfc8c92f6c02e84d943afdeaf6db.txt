commit bef2d7cb3289bfc8c92f6c02e84d943afdeaf6db
Author: travisoneill <travis.h.oneill@gmail.com>
Date:   Tue Mar 21 14:50:33 2017 -0700

    Improve query parsing to handle multiple spaces inside quotes and hanâ€¦ (#5100)
    
    * Improve query parsing to handle multiple spaces inside quotes and handling for colons in queries or tag values.
    
    * make syntax changes from PR comments
    
    * make syntax changes from PR comments
    
    * test suite partially complete
    
    * add test coverage for age, event.timestamp and timesSeen
    
    * add test for multiple age tags
    
    * remove re module and change to string.isspace

diff --git a/src/sentry/search/utils.py b/src/sentry/search/utils.py
index a2263f49af..d834240b8a 100644
--- a/src/sentry/search/utils.py
+++ b/src/sentry/search/utils.py
@@ -232,6 +232,7 @@ def tokenize_query(query):
     """
     Tokenizes a standard Sentry search query.
 
+    Example:
     >>> query = 'is:resolved foo bar tag:value'
     >>> tokenize_query(query)
     {
@@ -240,58 +241,94 @@ def tokenize_query(query):
         'tag': ['value'],
     }
     """
-    results = defaultdict(list)
-
-    tokens = query.split(' ')
-    tokens_iter = iter(tokens)
-    for token in tokens_iter:
-        # ignore empty tokens
-        if not token:
-            continue
-
-        if ':' not in token:
-            results['query'].append(token)
-            continue
-
-        # this handles quoted string, and is duplicated below
-        if token[0] == '"':
-            nvalue = token
-            while nvalue[-1] != '"':
-                try:
-                    nvalue = six.next(tokens_iter)
-                except StopIteration:
-                    break
-                token = '%s %s' % (token, nvalue)
-
-            if token[-1] == '"':
-                token = token[1:-1]
-            else:
-                token = token[1:]
-            results['query'].append(token)
-            continue
-
-        key, value = token.split(':', 1)
-        if not value:
-            results['query'].append(token)
-            if key in reserved_tag_names:
-                raise InvalidQuery(u"query term '{}:' found no arguments. (Terms are space delimited)".format(key))
-            continue
-
-        if value[0] == '"':
-            nvalue = value
-            while nvalue[-1] != '"':
-                try:
-                    nvalue = six.next(tokens_iter)
-                except StopIteration:
-                    break
-                value = '%s %s' % (value, nvalue)
-
-            if value[-1] == '"':
-                value = value[1:-1]
-            else:
-                value = value[1:]
-        results[key].append(value)
-    return dict(results)
+    result = defaultdict(list)
+    query_params = defaultdict(list)
+    tokens = split_query_into_tokens(query)
+    for token in tokens:
+        state = 'query'
+        for idx, char in enumerate(token):
+            next_char = token[idx + 1] if idx < len(token) - 1 else None
+            if idx == 0 and char in ('"', "'"):
+                break
+            if char == ':':
+                if next_char in (':', ' '):
+                    state = 'query'
+                else:
+                    state = 'tags'
+                break
+        query_params[state].append(token)
+
+    result['query'] = map(format_query, query_params['query'])
+    for tag in query_params['tags']:
+        key, value = format_tag(tag)
+        result[key].append(value)
+    return dict(result)
+
+
+def format_tag(tag):
+    '''
+    Splits tags on ':' and removes enclosing quotes if present and returns
+    returns both sides of the split as strings
+
+    Example:
+    >>> format_tag('user:foo')
+    'user', 'foo'
+    >>>format_tag('user:"foo bar"'')
+    'user', 'foo bar'
+    '''
+    idx = tag.index(':')
+    key = tag[:idx].strip('"')
+    value = tag[idx + 1:].strip('"')
+    return key, value
+
+
+def format_query(query):
+    '''
+    Strips enclosing quotes from queries if present.
+
+    Example:
+    >>> format_query('"user:foo bar"')
+    'user:foo bar'
+    '''
+    return query.strip('"')
+
+
+def split_query_into_tokens(query):
+    '''
+    Splits query string into tokens for parsing by 'tokenize_query'.
+    Returns list of strigs
+    Rules:
+    Split on whitespace
+        Unless
+        - inside enclosing quotes -> 'user:"foo    bar"'
+        - end of last word is a ':' -> 'user:  foo'
+
+    Example:
+    >>> split_query_into_tokens('user:foo user: bar  user"foo bar' foo  bar) =>
+    ['user:foo', 'user: bar', 'user"foo bar"', 'foo',  'bar']
+    '''
+    tokens = []
+    token = ''
+    quote_enclosed = False
+    quote_type = None
+    end_of_prev_word = None
+    for idx, char in enumerate(query):
+        next_char = query[idx + 1] if idx < len(query) - 1 else None
+        token += char
+        if next_char and not char.isspace() and next_char.isspace():
+            end_of_prev_word = char
+        if char.isspace() and not quote_enclosed and end_of_prev_word != ':':
+            if not token.isspace():
+                tokens.append(token.strip(' '))
+                token = ''
+        if char in ("'", '"'):
+            if not quote_enclosed or quote_type == char:
+                quote_enclosed = not quote_enclosed
+                if quote_enclosed:
+                    quote_type = char
+    if not token.isspace():
+        tokens.append(token.strip(' '))
+    return tokens
 
 
 def parse_query(project, query, user):
diff --git a/tests/sentry/search/test_utils.py b/tests/sentry/search/test_utils.py
index 4c53158b83..1629590740 100644
--- a/tests/sentry/search/test_utils.py
+++ b/tests/sentry/search/test_utils.py
@@ -1,7 +1,7 @@
 from __future__ import absolute_import
 
 import pytest
-
+import mock
 from datetime import datetime, timedelta
 from django.utils import timezone
 
@@ -59,6 +59,188 @@ class ParseQueryTest(TestCase):
         result = self.parse_query('foo: bar')
         assert result == {'tags': {}, 'query': 'foo: bar'}
 
+    def test_useless_prefix_with_symbol(self):
+        result = self.parse_query('foo:  @ba$r')
+        assert result == {'tags': {}, 'query': 'foo:  @ba$r'}
+
+    def test_useless_prefix_with_colon(self):
+        result = self.parse_query('foo:  :ba:r::foo:')
+        assert result == {'tags': {}, 'query': 'foo:  :ba:r::foo:'}
+
+    def test_handles_space_seperation_after_useless_prefix_exception(self):
+        result = self.parse_query('foo: bar foo:bar')
+        assert result == {'tags': {'foo': 'bar'}, 'query': 'foo: bar'}
+
+    def test_handles_period_in_tag_key(self):
+        result = self.parse_query('foo.bar:foobar')
+        assert result == {'tags': {'foo.bar': 'foobar'}, 'query': ''}
+
+    def test_handles_dash_in_tag_key(self):
+        result = self.parse_query('foo-bar:foobar')
+        assert result == {'tags': {'foo-bar': 'foobar'}, 'query': ''}
+
+    # TODO: update docs to include minutes, days, and weeks suffixes
+    @mock.patch('django.utils.timezone.now')
+    def test_age_tag_negative_value(self, now):
+        start = datetime(2016, 1, 1, tzinfo=timezone.utc)
+        now.return_value = start
+        expected = start - timedelta(hours=12)
+        result = self.parse_query('age:-12h')
+        assert result == {
+            'tags': {},
+            'query': '',
+            'age_from': expected,
+            'age_from_inclusive': True
+        }
+
+    @mock.patch('django.utils.timezone.now')
+    def test_age_tag_positive_value(self, now):
+        start = datetime(2016, 1, 1, tzinfo=timezone.utc)
+        now.return_value = start
+        expected = start - timedelta(hours=12)
+        result = self.parse_query('age:+12h')
+        assert result == {
+            'tags': {},
+            'query': '',
+            'age_to': expected,
+            'age_to_inclusive': False
+        }
+
+    @mock.patch('django.utils.timezone.now')
+    def test_age_tag_weeks(self, now):
+        start = datetime(2016, 1, 1, tzinfo=timezone.utc)
+        now.return_value = start
+        expected = start - timedelta(days=35)
+        result = self.parse_query('age:+5w')
+        assert result == {
+            'tags': {},
+            'query': '',
+            'age_to': expected,
+            'age_to_inclusive': False
+        }
+
+    @mock.patch('django.utils.timezone.now')
+    def test_age_tag_days(self, now):
+        start = datetime(2016, 1, 1, tzinfo=timezone.utc)
+        now.return_value = start
+        expected = start - timedelta(days=10)
+        result = self.parse_query('age:+10d')
+        assert result == {
+            'tags': {},
+            'query': '',
+            'age_to': expected,
+            'age_to_inclusive': False
+        }
+
+    @mock.patch('django.utils.timezone.now')
+    def test_age_tag_hours(self, now):
+        start = datetime(2016, 1, 1, tzinfo=timezone.utc)
+        now.return_value = start
+        expected = start - timedelta(hours=10)
+        result = self.parse_query('age:+10h')
+        assert result == {
+            'tags': {},
+            'query': '',
+            'age_to': expected,
+            'age_to_inclusive': False
+        }
+
+    @mock.patch('django.utils.timezone.now')
+    def test_age_tag_minutes(self, now):
+        start = datetime(2016, 1, 1, tzinfo=timezone.utc)
+        now.return_value = start
+        expected = start - timedelta(minutes=30)
+        result = self.parse_query('age:+30m')
+        assert result == {
+            'tags': {},
+            'query': '',
+            'age_to': expected,
+            'age_to_inclusive': False
+        }
+
+    @mock.patch('django.utils.timezone.now')
+    def test_two_age_tags(self, now):
+        start = datetime(2016, 1, 1, tzinfo=timezone.utc)
+        now.return_value = start
+        expected_to = start - timedelta(hours=12)
+        expected_from = start - timedelta(hours=24)
+        result = self.parse_query('age:+12h age:-24h')
+        assert result == {
+            'tags': {},
+            'query': '',
+            'age_to': expected_to,
+            'age_from': expected_from,
+            'age_to_inclusive': False,
+            'age_from_inclusive': True
+        }
+
+    def test_event_timestamp_syntax(self):
+        result = self.parse_query('event.timestamp:2016-01-02')
+        assert result == {
+            'query': '',
+            'date_from': datetime(2016, 1, 2, tzinfo=timezone.utc),
+            'date_from_inclusive': True,
+            'date_to': datetime(2016, 1, 3, tzinfo=timezone.utc),
+            'date_to_inclusive': False,
+            'tags': {}
+        }
+
+    def test_times_seen_syntax(self):
+        result = self.parse_query('timesSeen:10')
+        assert result == {'tags': {}, 'times_seen': 10, 'query': ''}
+
+    # TODO: query parser for '>' timestamp should set inclusive to False.
+    @pytest.mark.xfail
+    def test_greater_than_comparator(self):
+        result = self.parse_query('timesSeen:>10 event.timestamp:>2016-01-02')
+        assert result == {
+            'tags': {},
+            'query': '',
+            'times_seen_lower': 10,
+            'times_seen_lower_inclusive': False,
+            'date_from': datetime(2016, 1, 2, tzinfo=timezone.utc),
+            'date_from_inclusive': False
+        }
+
+    def test_greater_than_equal_comparator(self):
+        result = self.parse_query('timesSeen:>=10 event.timestamp:>=2016-01-02')
+        assert result == {
+            'tags': {},
+            'query': '',
+            'times_seen_lower': 10,
+            'times_seen_lower_inclusive': True,
+            'date_from': datetime(2016, 1, 2, tzinfo=timezone.utc),
+            'date_from_inclusive': True
+        }
+
+    def test_less_than_comparator(self):
+        result = self.parse_query('event.timestamp:<2016-01-02 timesSeen:<10')
+        assert result == {
+            'tags': {},
+            'query': '',
+            'times_seen_upper': 10,
+            'times_seen_upper_inclusive': False,
+            'date_to': datetime(2016, 1, 2, tzinfo=timezone.utc),
+            'date_to_inclusive': False
+        }
+
+    # TODO: query parser for '<=' timestamp should set inclusive to True.
+    @pytest.mark.xfail
+    def test_less_than_equal_comparator(self):
+        result = self.parse_query('event.timestamp:<=2016-01-02 timesSeen:<=10')
+        assert result == {
+            'tags': {},
+            'query': '',
+            'times_seen_upper': 10,
+            'times_seen_upper_inclusive': True,
+            'date_to': datetime(2016, 1, 2, tzinfo=timezone.utc),
+            'date_to_inclusive': True
+        }
+
+    def test_handles_underscore_in_tag_key(self):
+        result = self.parse_query('foo_bar:foobar')
+        assert result == {'tags': {'foo_bar': 'foobar'}, 'query': ''}
+
     def test_mix_tag_and_query(self):
         result = self.parse_query('foo bar key:value')
         assert result == {'tags': {'key': 'value'}, 'query': 'foo bar'}
@@ -71,6 +253,22 @@ class ParseQueryTest(TestCase):
         result = self.parse_query('url:http://example.com')
         assert result == {'tags': {'url': 'http://example.com'}, 'query': ''}
 
+    def test_single_space_in_value(self):
+        result = self.parse_query('key:"value1 value2"')
+        assert result == {'tags': {'key': 'value1 value2'}, 'query': ''}
+
+    def test_multiple_spaces_in_value(self):
+        result = self.parse_query('key:"value1  value2"')
+        assert result == {'tags': {'key': 'value1  value2'}, 'query': ''}
+
+    def test_invalid_tag_as_query(self):
+        result = self.parse_query('Resque::DirtyExit')
+        assert result == {'tags': {}, 'query': 'Resque::DirtyExit'}
+
+    def test_colons_in_tag_value(self):
+        result = self.parse_query('key:Resque::DirtyExit')
+        assert result == {'tags': {'key': 'Resque::DirtyExit'}, 'query': ''}
+
     def test_multiple_tags(self):
         result = self.parse_query('foo:bar key:value')
         assert result == {'tags': {'key': 'value', 'foo': 'bar'}, 'query': ''}
@@ -271,9 +469,3 @@ class ParseQueryTest(TestCase):
     def test_quoted_string(self):
         result = self.parse_query('"release:foo"')
         assert result == {'tags': {}, 'query': 'release:foo'}
-
-    # TODO(dcramer): it'd be nice to support this without quotes
-    @pytest.mark.xfail
-    def test_invalid_tag_as_query(self):
-        result = self.parse_query('Resque::DirtyExit')
-        assert result == {'tags': {}, 'query': 'Resque::DirtyExit'}

commit 571e422c02eb144ed49fb0f75a87fa58ffed4c1f
Author: Ted Kaemming <ted@kaemming.com>
Date:   Mon Mar 28 13:53:12 2016 -0700

    Abstract redirect-aware group retrieval away from API dependency.

diff --git a/src/sentry/api/bases/group.py b/src/sentry/api/bases/group.py
index 72657baf80..e092fed917 100644
--- a/src/sentry/api/bases/group.py
+++ b/src/sentry/api/bases/group.py
@@ -5,7 +5,7 @@ import logging
 from sentry.api.base import Endpoint
 from sentry.api.bases.project import ProjectPermission
 from sentry.api.exceptions import ResourceDoesNotExist
-from sentry.models import Group, GroupRedirect
+from sentry.models import Group, get_group_with_redirect
 
 logger = logging.getLogger(__name__)
 
@@ -23,44 +23,28 @@ class GroupPermission(ProjectPermission):
             request, view, group.project)
 
 
-def get_group(issue_id):
-    """
-    Retrieve a group by ID, also checking if the ID was previously used by a
-    group that was since merged.
-    """
-    queryset = Group.objects.select_related('project')
-    try:
-        group = queryset.get(id=issue_id)
-    except Group.DoesNotExist:
-        try:
-            redirect = GroupRedirect.objects.get(previous_group_id=issue_id)
-        except GroupRedirect.DoesNotExist:
-            raise ResourceDoesNotExist
+class GroupEndpoint(Endpoint):
+    permission_classes = (GroupPermission,)
 
-        # TODO(tkaemming): Ideally, this would return a 302 response,
-        # rather than just returning the data that is bound to the new
-        # group. (It technically shouldn't be a 301, since the response
-        # could change again as the result of another merge operation that
-        # occurs later. This wouldn't break anything though -- it will just
-        # be a "permanent" redirect to *another* permanent redirect.) This
-        # would require rebuilding the URL in one of two ways: either by
-        # hacking it in with string replacement, or making the endpoint
-        # aware of the URL pattern that caused it to be dispatched, and
-        # reversing it with the correct `issue_id` keyword argument.
+    def convert_args(self, request, issue_id, *args, **kwargs):
+        # TODO(tkaemming): Ideally, this would return a 302 response, rather
+        # than just returning the data that is bound to the new group. (It
+        # technically shouldn't be a 301, since the response could change again
+        # as the result of another merge operation that occurs later. This
+        # wouldn't break anything though -- it will just be a "permanent"
+        # redirect to *another* permanent redirect.) This would require
+        # rebuilding the URL in one of two ways: either by hacking it in with
+        # string replacement, or making the endpoint aware of the URL pattern
+        # that caused it to be dispatched, and reversing it with the correct
+        # `issue_id` keyword argument.
         try:
-            group = queryset.get(id=redirect.group_id)
+            group, _ = get_group_with_redirect(
+                issue_id,
+                queryset=Group.objects.select_related('project'),
+            )
         except Group.DoesNotExist:
-            logger.warning('%r redirected to group that does not exist!', redirect, exc_info=True)
             raise ResourceDoesNotExist
 
-    return group
-
-
-class GroupEndpoint(Endpoint):
-    permission_classes = (GroupPermission,)
-
-    def convert_args(self, request, issue_id, *args, **kwargs):
-        group = get_group(issue_id)
         self.check_object_permissions(request, group)
         kwargs['group'] = group
         return (args, kwargs)
diff --git a/src/sentry/models/group.py b/src/sentry/models/group.py
index 7ec27221b4..f399b626e2 100644
--- a/src/sentry/models/group.py
+++ b/src/sentry/models/group.py
@@ -35,6 +35,8 @@ from sentry.utils.strings import truncatechars, strip
 from sentry.utils.numbers import base32_encode, base32_decode
 
 
+logger = logging.getLogger(__name__)
+
 _short_id_re = re.compile(r'^(.*?)(?:[\s_-])([A-Za-z0-9]+)$')
 
 
@@ -52,6 +54,31 @@ class GroupStatus(object):
     PENDING_MERGE = 5
 
 
+def get_group_with_redirect(id, queryset=None):
+    """
+    Retrieve a group by ID, checking the redirect table if the requested group
+    does not exist. Returns a two-tuple of ``(object, redirected)``.
+    """
+    from sentry.models import GroupRedirect
+
+    if queryset is None:
+        queryset = Group.objects.all()
+
+    try:
+        return queryset.get(id=id), False
+    except Group.DoesNotExist as error:
+        try:
+            redirect = GroupRedirect.objects.get(previous_group_id=id)
+        except GroupRedirect.DoesNotExist:
+            raise error  # raise original `DoesNotExist`
+
+        try:
+            return queryset.get(id=redirect.group_id), True
+        except Group.DoesNotExist:
+            logger.warning('%r redirected to group that does not exist!', redirect, exc_info=True)
+            raise error  # raise original `DoesNotExist`
+
+
 class GroupManager(BaseManager):
     use_for_related_fields = True
 
diff --git a/tests/sentry/api/bases/test_group.py b/tests/sentry/api/bases/test_group.py
deleted file mode 100644
index 136e74b494..0000000000
--- a/tests/sentry/api/bases/test_group.py
+++ /dev/null
@@ -1,26 +0,0 @@
-import pytest
-
-from sentry.api.bases.group import get_group
-from sentry.api.exceptions import ResourceDoesNotExist
-from sentry.models import Group, GroupRedirect
-from sentry.testutils import TestCase
-
-
-class GroupEndpointTestCase(TestCase):
-    def test_get_group_respects_redirect(self):
-        group = self.create_group()
-        duplicate_id = self.create_group().id
-        Group.objects.filter(id=duplicate_id).delete()
-        GroupRedirect.objects.create(
-            group_id=group.id,
-            previous_group_id=duplicate_id,
-        )
-
-        assert get_group(duplicate_id).id == group.id
-
-        # We shouldn't end up in a case where the redirect points to a bad
-        # reference, but testing this path for completeness.
-        group.delete()
-
-        with pytest.raises(ResourceDoesNotExist):
-            get_group(duplicate_id)
diff --git a/tests/sentry/models/test_group.py b/tests/sentry/models/test_group.py
index ca5c64e90f..15ab5bb7eb 100644
--- a/tests/sentry/models/test_group.py
+++ b/tests/sentry/models/test_group.py
@@ -6,7 +6,7 @@ from datetime import timedelta, datetime
 from django.db.models import ProtectedError
 from django.utils import timezone
 
-from sentry.models import Group, GroupSnooze, GroupStatus, Release
+from sentry.models import Group, GroupSnooze, GroupStatus, Release, get_group_with_redirect, GroupRedirect
 from sentry.testutils import TestCase
 
 
@@ -124,3 +124,23 @@ class GroupTest(TestCase):
         assert self.create_group(message='\nfoo\n   ').message == 'foo'
         assert self.create_group(message='foo').message == 'foo'
         assert self.create_group(message='').message == ''
+
+    def test_get_group_with_redirect(self):
+        group = self.create_group()
+        assert get_group_with_redirect(group.id) == (group, False)
+
+        duplicate_id = self.create_group().id
+        Group.objects.filter(id=duplicate_id).delete()
+        GroupRedirect.objects.create(
+            group_id=group.id,
+            previous_group_id=duplicate_id,
+        )
+
+        assert get_group_with_redirect(duplicate_id) == (group, True)
+
+        # We shouldn't end up in a case where the redirect points to a bad
+        # reference, but testing this path for completeness.
+        group.delete()
+
+        with pytest.raises(Group.DoesNotExist):
+            get_group_with_redirect(duplicate_id)

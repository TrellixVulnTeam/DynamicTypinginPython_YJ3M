commit fb0d4732215ff8471c461aaf3729ace4f2f5bb86
Author: Nola Chen <chen.no@husky.neu.edu>
Date:   Thu Nov 7 10:28:28 2019 -0800

    feat(app-platform): use redis to store webhook requests (#15269)
    
    * feat(app-platform): use redis to store webhook requests
    
    * Review fixes: Make request object CamelCase, sort/truncate last 100 requests
    
    * refactor/fix tests
    
    * review fixes
    
    * use redis pipelines; move formatting logic to endpoint
    
    * fix test
    
    * fix test
    
    * don't store/display org id for internal apps; add test
    
    * expire keys after 30 days
    
    * ensure that redis keys for a sentry app are in the same hash slot
    
    * redis: Support Redis in a non-cluster non-rb mode
    
    This allows, the confunsingly named "redis_clusters" manager to support
    talking to a non-rb and non-cluster mode server. In a single Redis host.
    
    This means this gives us a working Redis implementation out of the box
    and `redis.redis_clusters.get("default")` will work. So things that rely
    on the redis-cluster/redis APIs can use a working redis without needing
    to run redis cluster locally.
    
    This also means that all the features we have that don't work without
    explicitly configuring redis cluster will be able to work against the
    default redis cluster.
    
    I know, these names are terrible and confusing until we get rid of rb.
    
    * refactor buffer code
    
    * redis: Support Redis in a non-cluster non-rb mode
    
    This allows, the confunsingly named "redis_clusters" manager to support
    talking to a non-rb and non-cluster mode server. In a single Redis host.
    
    This means this gives us a working Redis implementation out of the box
    and `redis.redis_clusters.get("default")` will work. So things that rely
    on the redis-cluster/redis APIs can use a working redis without needing
    to run redis cluster locally.
    
    This also means that all the features we have that don't work without
    explicitly configuring redis cluster will be able to work against the
    default redis cluster.
    
    I know, these names are terrible and confusing until we get rid of rb.
    
    * fix bug
    
    * get rid of buffer abstraction, use redis_clusters
    
    * review changes
    
    * review fixes

diff --git a/src/sentry/api/endpoints/sentry_app_errors.py b/src/sentry/api/endpoints/sentry_app_errors.py
deleted file mode 100644
index 2613cb9d2f..0000000000
--- a/src/sentry/api/endpoints/sentry_app_errors.py
+++ /dev/null
@@ -1,37 +0,0 @@
-from __future__ import absolute_import
-
-from rest_framework.response import Response
-
-from sentry.api.bases import SentryAppBaseEndpoint, SentryAppStatsPermission
-from sentry.api.paginator import OffsetPaginator
-from sentry.api.serializers import serialize
-from sentry.api.utils import get_date_range_from_params, InvalidParams
-from sentry.models import SentryAppWebhookError
-
-
-class SentryAppErrorsEndpoint(SentryAppBaseEndpoint):
-    permission_classes = (SentryAppStatsPermission,)
-
-    def get(self, request, sentry_app):
-        """
-        :qparam float start - optional
-        :qparam float end - optional
-        """
-        try:
-            start, end = get_date_range_from_params(request.GET, optional=True)
-        except InvalidParams as exc:
-            return Response({"detail": exc.message}, status=400)
-
-        filter_args = {"sentry_app": sentry_app.id}
-        if start is not None and end is not None:
-            filter_args["date_added__range"] = (start, end)
-
-        queryset = SentryAppWebhookError.objects.filter(**filter_args)
-
-        return self.paginate(
-            request=request,
-            queryset=queryset,
-            order_by="-date_added",
-            paginator_cls=OffsetPaginator,
-            on_results=lambda x: serialize(x, request.user),
-        )
diff --git a/src/sentry/api/endpoints/sentry_app_requests.py b/src/sentry/api/endpoints/sentry_app_requests.py
new file mode 100644
index 0000000000..ac89dd78b7
--- /dev/null
+++ b/src/sentry/api/endpoints/sentry_app_requests.py
@@ -0,0 +1,43 @@
+from __future__ import absolute_import
+
+from rest_framework.response import Response
+
+from sentry.api.bases import SentryAppBaseEndpoint, SentryAppStatsPermission
+
+from sentry.utils.sentryappwebhookrequests import SentryAppWebhookRequestsBuffer
+
+from sentry.models import Organization
+
+
+class SentryAppRequestsEndpoint(SentryAppBaseEndpoint):
+    permission_classes = (SentryAppStatsPermission,)
+
+    def format_request(self, request, sentry_app):
+        formatted_request = {
+            "webhookUrl": request.get("webhook_url"),
+            "sentryAppSlug": sentry_app.slug,
+            "eventType": request.get("event_type"),
+            "date": request.get("date"),
+            "responseCode": request.get("response_code"),
+        }
+
+        if "organization_id" in request:
+            try:
+                org = Organization.objects.get_from_cache(id=request["organization_id"])
+                formatted_request["organization"] = {"name": org.name, "slug": org.slug}
+            except Organization.DoesNotExist:
+                # If the org somehow doesn't exist, just don't add it to the result
+                pass
+
+        return formatted_request
+
+    def get(self, request, sentry_app):
+
+        # TODO add optional query params for event type
+        # for now I'm just getting all requests for all events
+
+        buffer = SentryAppWebhookRequestsBuffer(sentry_app)
+
+        formatted_requests = [self.format_request(req, sentry_app) for req in buffer.get_requests()]
+
+        return Response(formatted_requests)
diff --git a/src/sentry/api/urls.py b/src/sentry/api/urls.py
index abea471a11..02db10e46f 100644
--- a/src/sentry/api/urls.py
+++ b/src/sentry/api/urls.py
@@ -247,7 +247,7 @@ from .endpoints.sentry_app_installations import SentryAppInstallationsEndpoint
 from .endpoints.sentry_apps import SentryAppsEndpoint
 from .endpoints.sentry_apps_stats import SentryAppsStatsEndpoint
 from .endpoints.sentry_app_stats import SentryAppStatsEndpoint
-from .endpoints.sentry_app_errors import SentryAppErrorsEndpoint
+from .endpoints.sentry_app_requests import SentryAppRequestsEndpoint
 from .endpoints.sentry_app_interaction import SentryAppInteractionEndpoint
 from .endpoints.setup_wizard import SetupWizard
 from .endpoints.shared_group_details import SharedGroupDetailsEndpoint
@@ -1480,9 +1480,9 @@ urlpatterns = patterns(
         name="sentry-api-0-sentry-app-stats",
     ),
     url(
-        r"^sentry-apps/(?P<sentry_app_slug>[^\/]+)/errors/$",
-        SentryAppErrorsEndpoint.as_view(),
-        name="sentry-api-0-sentry-app-errors",
+        r"^sentry-apps/(?P<sentry_app_slug>[^\/]+)/requests/$",
+        SentryAppRequestsEndpoint.as_view(),
+        name="sentry-api-0-sentry-app-requests",
     ),
     url(
         r"^sentry-apps/(?P<sentry_app_slug>[^\/]+)/interaction/$",
diff --git a/src/sentry/static/sentry/app/types/index.tsx b/src/sentry/static/sentry/app/types/index.tsx
index b4cf5c2ecc..0a01d130d4 100644
--- a/src/sentry/static/sentry/app/types/index.tsx
+++ b/src/sentry/static/sentry/app/types/index.tsx
@@ -501,27 +501,16 @@ export type SentryAppInstallation = {
   code?: string;
 };
 
-export type SentryAppWebhookError = {
+export type SentryAppWebhookRequest = {
   webhookUrl: string;
-  app: {
-    uuid: string;
-    slug: string;
-    name: string;
-  };
-  request: {
-    body: object;
-    headers: object;
-  };
+  sentryAppSlug: string;
   eventType: string;
   date: string;
-  organization: {
+  organization?: {
     slug: string;
     name: string;
   };
-  response: {
-    body: string;
-    statusCode: number;
-  };
+  responseCode: number;
 };
 
 export type PermissionValue = 'no-access' | 'read' | 'write' | 'admin';
diff --git a/src/sentry/static/sentry/app/views/settings/organizationDeveloperSettings/sentryApplicationDashboard.tsx b/src/sentry/static/sentry/app/views/settings/organizationDeveloperSettings/sentryApplicationDashboard.tsx
index 25f5321f3d..5003970cff 100644
--- a/src/sentry/static/sentry/app/views/settings/organizationDeveloperSettings/sentryApplicationDashboard.tsx
+++ b/src/sentry/static/sentry/app/views/settings/organizationDeveloperSettings/sentryApplicationDashboard.tsx
@@ -18,7 +18,7 @@ import EmptyMessage from 'app/views/settings/components/emptyMessage';
 import Link from 'app/components/links/link';
 
 import space from 'app/styles/space';
-import {SentryApp, SentryAppWebhookError} from 'app/types';
+import {SentryApp, SentryAppWebhookRequest} from 'app/types';
 import {t} from 'app/locale';
 
 type Props = AsyncView['props'];
@@ -30,14 +30,14 @@ type State = AsyncView['state'] & {
     install_stats: [number, number][];
     uninstall_stats: [number, number][];
   };
-  errors: SentryAppWebhookError[];
+  requests: SentryAppWebhookRequest[];
   interactions: {
     component_interactions: {
       [key: string]: [number, number][];
     };
     views: [number, number][];
   };
-  app: SentryApp | null;
+  app: SentryApp;
 };
 
 export default class SentryApplicationDashboard extends AsyncView<Props, State> {
@@ -52,7 +52,7 @@ export default class SentryApplicationDashboard extends AsyncView<Props, State>
         `/sentry-apps/${appSlug}/stats/`,
         {query: {since: now - ninety_days_ago, until: now}},
       ],
-      ['errors', `/sentry-apps/${appSlug}/errors/`],
+      ['requests', `/sentry-apps/${appSlug}/requests/`],
       [
         'interactions',
         `/sentry-apps/${appSlug}/interaction/`,
@@ -128,14 +128,14 @@ export default class SentryApplicationDashboard extends AsyncView<Props, State>
     );
   }
 
-  renderErrorLog() {
-    const {errors} = this.state;
+  renderRequestLog() {
+    const {requests, app} = this.state;
     return (
       <React.Fragment>
-        <h5>{t('Error Log')}</h5>
+        <h5>{t('Request Log')}</h5>
         <p>
           {t(
-            'This log shows the errors captured from outgoing webhook requests for the following events: issue.assigned, issue.ignored, issue.resolved'
+            'This log shows outgoing webhook requests for the following events: issue.assigned, issue.ignored, issue.resolved, issue.created, error.created'
           )}
         </p>
         <Panel>
@@ -143,30 +143,30 @@ export default class SentryApplicationDashboard extends AsyncView<Props, State>
             <TableLayout>
               <div>{t('Time')}</div>
               <div>{t('Status Code')}</div>
-              <div>{t('Organization')}</div>
+              {app.status !== 'internal' && <div>{t('Organization')}</div>}
               <div>{t('Event Type')}</div>
               <div>{t('Webhook URL')}</div>
-              <div>{t('Response Body')}</div>
             </TableLayout>
           </PanelHeader>
 
           <PanelBody>
-            {errors.length > 0 ? (
-              errors.map((error, idx) => (
+            {requests.length > 0 ? (
+              requests.map((request, idx) => (
                 <PanelItem key={idx}>
                   <TableLayout>
-                    <DateTime date={error.date} />
-                    <div>{error.response.statusCode}</div>
-                    <div>{error.organization.name}</div>
-                    <div>{error.eventType}</div>
-                    <OverflowBox>{error.webhookUrl}</OverflowBox>
-                    <OverflowBox>{error.response.body}</OverflowBox>
+                    <DateTime date={request.date} />
+                    <div>{request.responseCode}</div>
+                    {app.status !== 'internal' && request.organization && (
+                      <div>{request.organization.name}</div>
+                    )}
+                    <div>{request.eventType}</div>
+                    <OverflowBox>{request.webhookUrl}</OverflowBox>
                   </TableLayout>
                 </PanelItem>
               ))
             ) : (
               <EmptyMessage icon="icon-circle-exclamation">
-                {t('No errors found.')}
+                {t('No requests found.')}
               </EmptyMessage>
             )}
           </PanelBody>
@@ -229,11 +229,11 @@ export default class SentryApplicationDashboard extends AsyncView<Props, State>
 
     return (
       <div>
-        {app && <SettingsPageHeader title={app.name} />}
-        {app && app.status === 'published' && this.renderInstallData()}
-        {this.renderErrorLog()}
-        {app && app.status === 'published' && this.renderIntegrationViews()}
-        {app && app.schema.elements && this.renderComponentInteractions()}
+        {<SettingsPageHeader title={app.name} />}
+        {app.status === 'published' && this.renderInstallData()}
+        {this.renderRequestLog()}
+        {app.status === 'published' && this.renderIntegrationViews()}
+        {app.schema.elements && this.renderComponentInteractions()}
       </div>
     );
   }
@@ -288,7 +288,7 @@ const StatsHeader = styled('h6')`
 
 const TableLayout = styled('div')`
   display: grid;
-  grid-template-columns: 1fr 0.5fr 1fr 1fr 1fr 2fr;
+  grid-template-columns: 1fr 0.5fr 1fr 1fr 1fr;
   grid-column-gap: ${space(1.5)};
   width: 100%;
   align-items: center;
diff --git a/src/sentry/tasks/sentry_apps.py b/src/sentry/tasks/sentry_apps.py
index e505783acb..ccf2c4c23e 100644
--- a/src/sentry/tasks/sentry_apps.py
+++ b/src/sentry/tasks/sentry_apps.py
@@ -6,10 +6,11 @@ from celery.task import current
 from django.core.urlresolvers import reverse
 from requests.exceptions import RequestException
 
-from sentry.http import safe_urlopen, safe_urlread
+from sentry.http import safe_urlopen
 from sentry.tasks.base import instrumented_task, retry
 from sentry.utils import metrics
 from sentry.utils.http import absolute_uri
+from sentry.utils.sentryappwebhookrequests import SentryAppWebhookRequestsBuffer
 from sentry.api.serializers import serialize, AppPlatformEvent
 from sentry.models import (
     SentryAppInstallation,
@@ -22,7 +23,6 @@ from sentry.models import (
     ServiceHookProject,
     SentryApp,
     SnubaEvent,
-    SentryAppWebhookError,
 )
 from sentry.models.sentryapp import VALID_EVENTS
 
@@ -42,14 +42,6 @@ RESOURCE_RENAMES = {"Group": "issue"}
 TYPES = {"Group": Group, "Error": SnubaEvent}
 
 
-def _save_webhook_error(**kwargs):
-    event = kwargs.get("event_type")
-
-    # Track any webhook errors for these event types
-    if event in ["issue.assigned", "issue.ignored", "issue.resolved"]:
-        SentryAppWebhookError.objects.create(**kwargs)
-
-
 def _webhook_event_data(event, group_id, project_id):
     project = Project.objects.get_from_cache(id=project_id)
     organization = Organization.objects.get_from_cache(id=project.organization_id)
@@ -282,14 +274,7 @@ def send_webhooks(installation, event, **kwargs):
 
         request_data = AppPlatformEvent(**kwargs)
 
-        potential_error_kwargs = {
-            "sentry_app_id": installation.sentry_app_id,
-            "organization_id": installation.organization_id,
-            "request_body": request_data.body,
-            "request_headers": request_data.headers,
-            "event_type": event,
-            "webhook_url": servicehook.sentry_app.webhook_url,
-        }
+        buffer = SentryAppWebhookRequestsBuffer(installation.sentry_app)
 
         try:
             resp = safe_urlopen(
@@ -298,14 +283,20 @@ def send_webhooks(installation, event, **kwargs):
                 headers=request_data.headers,
                 timeout=5,
             )
-        except RequestException as exc:
-            potential_error_kwargs["response_body"] = repr(exc)
-            _save_webhook_error(**potential_error_kwargs)
+        except RequestException:
+            # Response code of 0 represents timeout
+            buffer.add_request(
+                response_code=0,
+                org_id=installation.organization_id,
+                event=event,
+                url=servicehook.sentry_app.webhook_url,
+            )
             # Re-raise the exception because some of these tasks might retry on the exception
             raise
 
-        if not resp.ok:
-            body = safe_urlread(resp)
-            potential_error_kwargs["response_body"] = body
-            potential_error_kwargs["response_code"] = resp.status_code
-            _save_webhook_error(**potential_error_kwargs)
+        buffer.add_request(
+            response_code=resp.status_code,
+            org_id=installation.organization_id,
+            event=event,
+            url=servicehook.sentry_app.webhook_url,
+        )
diff --git a/src/sentry/utils/sentryappwebhookrequests.py b/src/sentry/utils/sentryappwebhookrequests.py
new file mode 100644
index 0000000000..60f8894055
--- /dev/null
+++ b/src/sentry/utils/sentryappwebhookrequests.py
@@ -0,0 +1,127 @@
+from __future__ import absolute_import
+
+import six
+import json
+
+from dateutil.parser import parse as parse_date
+from django.conf import settings
+from django.utils import timezone
+
+from sentry.utils import redis
+from sentry.models.sentryapp import VALID_EVENTS
+
+
+BUFFER_SIZE = 100
+KEY_EXPIRY = 60 * 60 * 24 * 30  # 30 days
+
+
+class SentryAppWebhookRequestsBuffer(object):
+    """
+    Create a data structure to store basic information about Sentry App webhook requests in Redis
+    This should store the last 100 requests and last 100 errors (in different keys) for each event type, for each Sentry App
+    """
+
+    def __init__(self, sentry_app):
+        self.sentry_app = sentry_app
+
+        cluster_id = getattr(settings, "SENTRY_WEBHOOK_LOG_REDIS_CLUSTER", "default")
+        self.client = redis.redis_clusters.get(cluster_id)
+
+    def _get_redis_key(self, event, error=False):
+        sentry_app_id = self.sentry_app.id
+
+        if error:
+            return "sentry-app-webhook-error:{{{0}}}:{1}".format(sentry_app_id, event)
+        else:
+            return "sentry-app-webhook-request:{{{0}}}:{1}".format(sentry_app_id, event)
+
+    def _convert_redis_request(self, redis_request, event):
+        """
+        Convert the request string stored in Redis to a python dict
+        Add the event type to the dict so that the request can be identified correctly
+        """
+        request = json.loads(redis_request)
+        request["event_type"] = event
+
+        return request
+
+    def _add_to_buffer_pipeline(self, buffer_key, item, pipeline):
+        """
+        Add the item to the buffer key specified, using the given pipeline.
+        This does not execute the pipeline's commands.
+        """
+
+        pipeline.lpush(buffer_key, json.dumps(item))
+        pipeline.ltrim(buffer_key, 0, BUFFER_SIZE - 1)
+        pipeline.expire(buffer_key, KEY_EXPIRY)
+
+    def _get_all_from_buffer(self, buffer_key, pipeline=None):
+        """
+        Get the list at the buffer key, using the given pipeline if available.
+        If a pipeline is provided, this does not return a value as the pipeline must still be executed.
+        """
+
+        if pipeline is not None:
+            pipeline.lrange(buffer_key, 0, BUFFER_SIZE - 1)
+        else:
+            return self.client.lrange(buffer_key, 0, BUFFER_SIZE - 1)
+
+    def _get_requests(self, event=None, error=False):
+        # If no event is specified, return the latest requests/errors for all event types
+        if event is None:
+            pipe = self.client.pipeline()
+
+            all_requests = []
+            for evt in VALID_EVENTS:
+                self._get_all_from_buffer(self._get_redis_key(evt, error=error), pipeline=pipe)
+
+            values = pipe.execute()
+
+            for idx, evt in enumerate(VALID_EVENTS):
+                event_requests = [
+                    self._convert_redis_request(request, evt) for request in values[idx]
+                ]
+                all_requests.extend(event_requests)
+
+            all_requests.sort(key=lambda x: parse_date(x["date"]), reverse=True)
+            return all_requests[0:BUFFER_SIZE]
+
+        else:
+            return [
+                self._convert_redis_request(request, event)
+                for request in self._get_all_from_buffer(self._get_redis_key(event, error=error))
+            ]
+
+    def get_errors(self, event=None):
+        return self._get_requests(event=event, error=True)
+
+    def get_requests(self, event=None):
+        return self._get_requests(event=event, error=False)
+
+    def add_request(self, response_code, org_id, event, url):
+        if event not in VALID_EVENTS:
+            return
+
+        request_key = self._get_redis_key(event)
+
+        time = timezone.now()
+        request_data = {
+            "date": six.text_type(time),
+            "response_code": response_code,
+            "webhook_url": url,
+        }
+
+        # Don't store the org id for internal apps because it will always be the org that owns the app anyway
+        if not self.sentry_app.is_internal:
+            request_data["organization_id"] = org_id
+
+        pipe = self.client.pipeline()
+
+        self._add_to_buffer_pipeline(request_key, request_data, pipe)
+
+        # If it's an error add it to the error buffer
+        if 400 <= response_code <= 599:
+            error_key = self._get_redis_key(event, error=True)
+            self._add_to_buffer_pipeline(error_key, request_data, pipe)
+
+        pipe.execute()
diff --git a/tests/js/sentry-test/fixtures/sentryAppWebhookError.js b/tests/js/sentry-test/fixtures/sentryAppWebhookError.js
deleted file mode 100644
index 20425c998d..0000000000
--- a/tests/js/sentry-test/fixtures/sentryAppWebhookError.js
+++ /dev/null
@@ -1,26 +0,0 @@
-export function SentryAppWebhookError(params = {}) {
-  return {
-    app: {
-      slug: 'sample-app',
-      name: 'Sample App',
-      uuid: 'b468fed3-afba-4917-80d6-bdac99c1ec05',
-    },
-    date: '2019-09-25T23:54:54.440Z',
-    organization: {
-      slug: 'test-org',
-      name: 'Test Org',
-    },
-    errorId: null,
-    request: {
-      body: {},
-      headers: {},
-    },
-    eventType: 'issue.assigned',
-    webhookUrl: 'https://example.com/webhook',
-    response: {
-      body: 'This is an error',
-      statusCode: 400,
-    },
-    ...params,
-  };
-}
diff --git a/tests/js/sentry-test/fixtures/sentryAppWebhookRequest.js b/tests/js/sentry-test/fixtures/sentryAppWebhookRequest.js
new file mode 100644
index 0000000000..df3a648b25
--- /dev/null
+++ b/tests/js/sentry-test/fixtures/sentryAppWebhookRequest.js
@@ -0,0 +1,15 @@
+export function SentryAppWebhookRequest(params = {}) {
+  return {
+    webhookUrl: 'https://example.com/webhook',
+    sentryAppSlug: 'sample-app',
+    eventType: 'issue.assigned',
+    date: '2019-09-25T23:54:54.440Z',
+    organization: {
+      slug: 'test-org',
+      name: 'Test Org',
+    },
+    responseCode: 400,
+
+    ...params,
+  };
+}
diff --git a/tests/js/spec/views/settings/organizationDeveloperSettings/sentryApplicationDashboard.spec.jsx b/tests/js/spec/views/settings/organizationDeveloperSettings/sentryApplicationDashboard.spec.jsx
index 6598f86bca..2c69986e21 100644
--- a/tests/js/spec/views/settings/organizationDeveloperSettings/sentryApplicationDashboard.spec.jsx
+++ b/tests/js/spec/views/settings/organizationDeveloperSettings/sentryApplicationDashboard.spec.jsx
@@ -11,7 +11,7 @@ describe('Sentry Application Dashboard', function() {
   let org;
   let orgId;
   let sentryApp;
-  let error;
+  let request;
 
   let wrapper;
 
@@ -30,7 +30,7 @@ describe('Sentry Application Dashboard', function() {
           elements: [{type: 'stacktrace-link', uri: '/test'}, {type: 'issue-link'}],
         },
       });
-      error = TestStubs.SentryAppWebhookError();
+      request = TestStubs.SentryAppWebhookRequest();
 
       Client.addMockResponse({
         url: `/sentry-apps/${sentryApp.slug}/stats/`,
@@ -43,8 +43,8 @@ describe('Sentry Application Dashboard', function() {
       });
 
       Client.addMockResponse({
-        url: `/sentry-apps/${sentryApp.slug}/errors/`,
-        body: [error],
+        url: `/sentry-apps/${sentryApp.slug}/requests/`,
+        body: [request],
       });
 
       Client.addMockResponse({
@@ -100,24 +100,23 @@ describe('Sentry Application Dashboard', function() {
       });
     });
 
-    it('shows the error log', () => {
-      const errorLog = wrapper.find('PanelBody');
-      const errorLogText = errorLog.find('PanelItem').text();
-      // The mock response has 1 error
-      expect(errorLog.find('PanelItem')).toHaveLength(1);
+    it('shows the request log', () => {
+      const requestLog = wrapper.find('PanelBody');
+      const requestLogText = requestLog.find('PanelItem').text();
+      // The mock response has 1 request
+      expect(requestLog.find('PanelItem')).toHaveLength(1);
       // Make sure that all the info is displayed
-      expect(errorLogText).toEqual(
+      expect(requestLogText).toEqual(
         expect.stringContaining('https://example.com/webhook')
       );
-      expect(errorLogText).toEqual(expect.stringContaining('This is an error'));
-      expect(errorLogText).toEqual(expect.stringContaining('400'));
-      expect(errorLogText).toEqual(expect.stringContaining('issue.assigned'));
-      expect(errorLogText).toEqual(expect.stringContaining('Test Org'));
+      expect(requestLogText).toEqual(expect.stringContaining('400'));
+      expect(requestLogText).toEqual(expect.stringContaining('issue.assigned'));
+      expect(requestLogText).toEqual(expect.stringContaining('Test Org'));
     });
 
-    it('shows an empty message if there are no errors', () => {
+    it('shows an empty message if there are no requests', () => {
       Client.addMockResponse({
-        url: `/sentry-apps/${sentryApp.slug}/errors/`,
+        url: `/sentry-apps/${sentryApp.slug}/requests/`,
         body: [],
       });
 
@@ -128,7 +127,7 @@ describe('Sentry Application Dashboard', function() {
 
       expect(wrapper.find('PanelBody').exists('PanelItem')).toBeFalsy();
       expect(wrapper.find('EmptyMessage').text()).toEqual(
-        expect.stringContaining('No errors found.')
+        expect.stringContaining('No requests found.')
       );
     });
 
@@ -172,7 +171,7 @@ describe('Sentry Application Dashboard', function() {
           elements: [{type: 'stacktrace-link', uri: '/test'}],
         },
       });
-      error = TestStubs.SentryAppWebhookError();
+      request = TestStubs.SentryAppWebhookRequest();
 
       Client.addMockResponse({
         url: `/sentry-apps/${sentryApp.slug}/stats/`,
@@ -185,8 +184,8 @@ describe('Sentry Application Dashboard', function() {
       });
 
       Client.addMockResponse({
-        url: `/sentry-apps/${sentryApp.slug}/errors/`,
-        body: [error],
+        url: `/sentry-apps/${sentryApp.slug}/requests/`,
+        body: [request],
       });
 
       Client.addMockResponse({
@@ -215,24 +214,22 @@ describe('Sentry Application Dashboard', function() {
       expect(wrapper.exists('BarChart')).toBeFalsy();
     });
 
-    it('shows the error log', () => {
-      const errorLog = wrapper.find('PanelBody');
-      const errorLogText = errorLog.find('PanelItem').text();
-      // The mock response has 1 error
-      expect(errorLog.find('PanelItem')).toHaveLength(1);
+    it('shows the request log', () => {
+      const requestLog = wrapper.find('PanelBody');
+      const requestLogText = requestLog.find('PanelItem').text();
+      // The mock response has 1 request
+      expect(requestLog.find('PanelItem')).toHaveLength(1);
       // Make sure that all the info is displayed
-      expect(errorLogText).toEqual(
+      expect(requestLogText).toEqual(
         expect.stringContaining('https://example.com/webhook')
       );
-      expect(errorLogText).toEqual(expect.stringContaining('This is an error'));
-      expect(errorLogText).toEqual(expect.stringContaining('400'));
-      expect(errorLogText).toEqual(expect.stringContaining('issue.assigned'));
-      expect(errorLogText).toEqual(expect.stringContaining('Test Org'));
+      expect(requestLogText).toEqual(expect.stringContaining('400'));
+      expect(requestLogText).toEqual(expect.stringContaining('issue.assigned'));
     });
 
-    it('shows an empty message if there are no errors', () => {
+    it('shows an empty message if there are no requests', () => {
       Client.addMockResponse({
-        url: `/sentry-apps/${sentryApp.slug}/errors/`,
+        url: `/sentry-apps/${sentryApp.slug}/requests/`,
         body: [],
       });
 
@@ -243,7 +240,7 @@ describe('Sentry Application Dashboard', function() {
 
       expect(wrapper.find('PanelBody').exists('PanelItem')).toBeFalsy();
       expect(wrapper.find('EmptyMessage').text()).toEqual(
-        expect.stringContaining('No errors found.')
+        expect.stringContaining('No requests found.')
       );
     });
 
diff --git a/tests/sentry/api/endpoints/test_sentry_app_errors.py b/tests/sentry/api/endpoints/test_sentry_app_errors.py
deleted file mode 100644
index 03eebd924e..0000000000
--- a/tests/sentry/api/endpoints/test_sentry_app_errors.py
+++ /dev/null
@@ -1,86 +0,0 @@
-from __future__ import absolute_import
-
-from django.core.urlresolvers import reverse
-
-from sentry.testutils import APITestCase
-
-
-class SentryAppErrorsTest(APITestCase):
-    def setUp(self):
-        self.superuser = self.create_user(email="superuser@example.com", is_superuser=True)
-        self.user = self.create_user(email="user@example.com")
-        self.org = self.create_organization(owner=self.user)
-        self.project = self.create_project(organization=self.org)
-
-        self.published_app = self.create_sentry_app(
-            name="Published App", organization=self.org, published=True
-        )
-        self.unowned_published_app = self.create_sentry_app(
-            name="Unowned Published App", organization=self.create_organization(), published=True
-        )
-
-        self.unpublished_app = self.create_sentry_app(name="Unpublished App", organization=self.org)
-        self.unowned_unpublished_app = self.create_sentry_app(
-            name="Unowned Unpublished App", organization=self.create_organization()
-        )
-
-        self.webhook_error1 = self.create_sentry_app_webhook_error(sentry_app=self.published_app)
-        self.webhook_error2 = self.create_sentry_app_webhook_error(
-            sentry_app=self.unowned_published_app
-        )
-
-
-class GetSentryAppErrorsTest(SentryAppErrorsTest):
-    def test_superuser_sees_unowned_published_errors(self):
-        self.login_as(user=self.superuser, superuser=True)
-
-        url = reverse("sentry-api-0-sentry-app-errors", args=[self.unowned_published_app.slug])
-        response = self.client.get(url, format="json")
-        assert response.status_code == 200
-        assert len(response.data) == 1
-        assert response.data[0]["organization"]["slug"] == self.webhook_error2.organization.slug
-        assert response.data[0]["app"]["slug"] == self.unowned_published_app.slug
-
-    def test_superuser_sees_unpublished_stats(self):
-        self.login_as(user=self.superuser, superuser=True)
-
-        url = reverse("sentry-api-0-sentry-app-errors", args=[self.unowned_unpublished_app.slug])
-        response = self.client.get(url, format="json")
-        assert response.status_code == 200
-        assert len(response.data) == 0
-
-    def test_user_sees_owned_published_errors(self):
-        self.login_as(user=self.user)
-
-        url = reverse("sentry-api-0-sentry-app-errors", args=[self.published_app.slug])
-        response = self.client.get(url, format="json")
-        assert response.status_code == 200
-        assert len(response.data) == 1
-        assert response.data[0]["organization"]["slug"] == self.webhook_error1.organization.slug
-        assert response.data[0]["app"]["slug"] == self.published_app.slug
-
-    def test_user_does_not_see_unowned_published_errors(self):
-        self.login_as(user=self.user)
-
-        url = reverse("sentry-api-0-sentry-app-errors", args=[self.unowned_published_app.slug])
-        response = self.client.get(url, format="json")
-        assert response.status_code == 403
-        assert response.data["detail"] == "You do not have permission to perform this action."
-
-    def test_user_sees_owned_unpublished_errors(self):
-        self.login_as(user=self.user)
-
-        url = reverse("sentry-api-0-sentry-app-errors", args=[self.unpublished_app.slug])
-        response = self.client.get(url, format="json")
-        assert response.status_code == 200
-        assert len(response.data) == 0
-
-    def test_invalid_date_params(self):
-        self.login_as(self.user)
-
-        url = "%s?start=1570489554&end=1562365872" % reverse(
-            "sentry-api-0-sentry-app-errors", args=[self.published_app.slug]
-        )
-        response = self.client.get(url, format="json")
-        assert response.status_code == 400
-        assert response.data["detail"] == "start must be before end"
diff --git a/tests/sentry/api/endpoints/test_sentry_app_requests.py b/tests/sentry/api/endpoints/test_sentry_app_requests.py
new file mode 100644
index 0000000000..96455c8222
--- /dev/null
+++ b/tests/sentry/api/endpoints/test_sentry_app_requests.py
@@ -0,0 +1,144 @@
+from __future__ import absolute_import
+
+from django.core.urlresolvers import reverse
+
+from sentry.testutils import APITestCase
+
+from sentry.utils.sentryappwebhookrequests import SentryAppWebhookRequestsBuffer
+
+
+class SentryAppRequestsTest(APITestCase):
+    def setUp(self):
+        self.superuser = self.create_user(email="superuser@example.com", is_superuser=True)
+        self.user = self.create_user(email="user@example.com")
+        self.org = self.create_organization(owner=self.user)
+        self.project = self.create_project(organization=self.org)
+
+        self.published_app = self.create_sentry_app(
+            name="Published App", organization=self.org, published=True
+        )
+        self.unowned_published_app = self.create_sentry_app(
+            name="Unowned Published App", organization=self.create_organization(), published=True
+        )
+
+        self.unpublished_app = self.create_sentry_app(name="Unpublished App", organization=self.org)
+        self.unowned_unpublished_app = self.create_sentry_app(
+            name="Unowned Unpublished App", organization=self.create_organization()
+        )
+
+        self.internal_app = self.create_internal_integration(
+            name="Internal app", organization=self.org
+        )
+
+
+class GetSentryAppRequestsTest(SentryAppRequestsTest):
+    def test_superuser_sees_unowned_published_requests(self):
+        self.login_as(user=self.superuser, superuser=True)
+
+        buffer = SentryAppWebhookRequestsBuffer(self.unowned_published_app)
+        buffer.add_request(
+            response_code=200,
+            org_id=self.org.id,
+            event="issue.assigned",
+            url=self.unowned_published_app.webhook_url,
+        )
+        buffer.add_request(
+            response_code=500,
+            org_id=self.org.id,
+            event="issue.assigned",
+            url=self.unowned_published_app.webhook_url,
+        )
+
+        url = reverse("sentry-api-0-sentry-app-requests", args=[self.unowned_published_app.slug])
+        response = self.client.get(url, format="json")
+        assert response.status_code == 200
+        assert len(response.data) == 2
+        assert response.data[0]["organization"]["slug"] == self.org.slug
+        assert response.data[0]["sentryAppSlug"] == self.unowned_published_app.slug
+        assert response.data[0]["responseCode"] == 500
+
+    def test_superuser_sees_unpublished_stats(self):
+        self.login_as(user=self.superuser, superuser=True)
+
+        buffer = SentryAppWebhookRequestsBuffer(self.unowned_unpublished_app)
+        buffer.add_request(
+            response_code=200,
+            org_id=self.org.id,
+            event="issue.assigned",
+            url=self.unowned_unpublished_app.webhook_url,
+        )
+
+        url = reverse("sentry-api-0-sentry-app-requests", args=[self.unowned_unpublished_app.slug])
+        response = self.client.get(url, format="json")
+        assert response.status_code == 200
+        assert len(response.data) == 1
+        assert response.data[0]["sentryAppSlug"] == self.unowned_unpublished_app.slug
+
+    def test_user_sees_owned_published_requests(self):
+        self.login_as(user=self.user)
+
+        buffer = SentryAppWebhookRequestsBuffer(self.published_app)
+        buffer.add_request(
+            response_code=200,
+            org_id=self.org.id,
+            event="issue.assigned",
+            url=self.published_app.webhook_url,
+        )
+
+        url = reverse("sentry-api-0-sentry-app-requests", args=[self.published_app.slug])
+        response = self.client.get(url, format="json")
+        assert response.status_code == 200
+        assert len(response.data) == 1
+        assert response.data[0]["organization"]["slug"] == self.org.slug
+        assert response.data[0]["sentryAppSlug"] == self.published_app.slug
+        assert response.data[0]["responseCode"] == 200
+
+    def test_user_does_not_see_unowned_published_requests(self):
+        self.login_as(user=self.user)
+
+        buffer = SentryAppWebhookRequestsBuffer(self.unowned_published_app)
+        buffer.add_request(
+            response_code=200,
+            org_id=self.org.id,
+            event="issue.assigned",
+            url=self.unowned_published_app.webhook_url,
+        )
+
+        url = reverse("sentry-api-0-sentry-app-requests", args=[self.unowned_published_app.slug])
+        response = self.client.get(url, format="json")
+        assert response.status_code == 403
+        assert response.data["detail"] == "You do not have permission to perform this action."
+
+    def test_user_sees_owned_unpublished_requests(self):
+        self.login_as(user=self.user)
+
+        buffer = SentryAppWebhookRequestsBuffer(self.unpublished_app)
+        buffer.add_request(
+            response_code=200,
+            org_id=self.org.id,
+            event="issue.assigned",
+            url=self.unpublished_app.webhook_url,
+        )
+
+        url = reverse("sentry-api-0-sentry-app-requests", args=[self.unpublished_app.slug])
+        response = self.client.get(url, format="json")
+        assert response.status_code == 200
+        assert len(response.data) == 1
+
+    def test_internal_app_requests_does_not_have_organization_field(self):
+        self.login_as(user=self.user)
+        buffer = SentryAppWebhookRequestsBuffer(self.internal_app)
+        buffer.add_request(
+            response_code=200,
+            org_id=self.org.id,
+            event="issue.assigned",
+            url=self.internal_app.webhook_url,
+        )
+
+        url = reverse("sentry-api-0-sentry-app-requests", args=[self.internal_app.slug])
+        response = self.client.get(url, format="json")
+        assert response.status_code == 200
+        assert len(response.data) == 1
+        assert "organization" not in response.data[0]
+        assert response.data[0]["sentryAppSlug"] == self.internal_app.slug
+        assert response.data[0]["responseCode"] == 200
diff --git a/tests/sentry/tasks/test_sentry_apps.py b/tests/sentry/tasks/test_sentry_apps.py
index 51b2ef3c6d..8da62075b7 100644
--- a/tests/sentry/tasks/test_sentry_apps.py
+++ b/tests/sentry/tasks/test_sentry_apps.py
@@ -8,7 +8,7 @@ from django.core.urlresolvers import reverse
 from mock import patch
 from requests.exceptions import RequestException
 
-from sentry.models import Rule, SentryApp, SentryAppInstallation, SentryAppWebhookError
+from sentry.models import Rule, SentryApp, SentryAppInstallation
 from sentry.testutils import TestCase
 from sentry.testutils.helpers import with_feature
 from sentry.testutils.helpers.faux import faux
@@ -16,6 +16,7 @@ from sentry.testutils.helpers.datetime import iso_format, before_now
 from sentry.utils.http import absolute_uri
 from sentry.receivers.sentry_apps import *  # NOQA
 from sentry.utils import json
+from sentry.utils.sentryappwebhookrequests import SentryAppWebhookRequestsBuffer
 from sentry.tasks.post_process import post_process_group
 from sentry.api.serializers import serialize
 from sentry.tasks.sentry_apps import (
@@ -328,7 +329,7 @@ class TestWorkflowNotification(TestCase):
         assert not safe_urlopen.called
 
 
-class TestWebhookErrors(TestCase):
+class TestWebhookRequests(TestCase):
     def setUp(self):
         self.project = self.create_project()
         self.user = self.create_user()
@@ -344,45 +345,37 @@ class TestWebhookErrors(TestCase):
         )
 
         self.issue = self.create_group(project=self.project)
+        self.buffer = SentryAppWebhookRequestsBuffer(self.sentry_app)
 
     @patch("sentry.tasks.sentry_apps.safe_urlopen", return_value=MockFailureResponseInstance)
-    def test_saves_error_if_workflow_webhook_request_fails(self, safe_urlopen):
+    def test_saves_error_if_webhook_request_fails(self, safe_urlopen):
         data = {"issue": serialize(self.issue)}
         send_webhooks(installation=self.install, event="issue.assigned", data=data, actor=self.user)
 
-        error_count = SentryAppWebhookError.objects.count()
-        error = SentryAppWebhookError.objects.first()
+        requests = self.buffer.get_requests()
+        requests_count = len(requests)
+        first_request = requests[0]
 
         assert safe_urlopen.called
-        assert error_count == 1
-        assert error.sentry_app.id == self.install.sentry_app.id
-        assert error.organization.id == self.install.organization.id
-        assert error.response_body == "{}"
+        assert requests_count == 1
+        assert first_request["response_code"] == 400
+        assert first_request["event_type"] == "issue.assigned"
+        assert first_request["organization_id"] == self.install.organization.id
 
-    @patch("sentry.tasks.sentry_apps.safe_urlopen", return_value=MockFailureResponseInstance)
-    def test_does_not_save_error_if_nonworkflow_request_fails(self, safe_urlopen):
-        sentry_app = self.create_sentry_app(
-            name="Test App 2",
-            organization=self.project.organization,
-            events=[
-                "issue.resolved",
-                "issue.ignored",
-                "issue.assigned",
-                "issue.created",
-                "error.created",
-            ],
-        )
-        install = self.create_sentry_app_installation(
-            organization=self.project.organization, slug=sentry_app.slug
-        )
+    @patch("sentry.tasks.sentry_apps.safe_urlopen", return_value=MockResponseInstance)
+    def test_saves_request_if_webhook_request_succeeds(self, safe_urlopen):
         data = {"issue": serialize(self.issue)}
-        send_webhooks(installation=install, event="issue.created", data=data)
-        send_webhooks(installation=install, event="error.created", data=data)
+        send_webhooks(installation=self.install, event="issue.assigned", data=data, actor=self.user)
 
-        error_count = SentryAppWebhookError.objects.count()
+        requests = self.buffer.get_requests()
+        requests_count = len(requests)
+        first_request = requests[0]
 
         assert safe_urlopen.called
-        assert error_count == 0
+        assert requests_count == 1
+        assert first_request["response_code"] == 200
+        assert first_request["event_type"] == "issue.assigned"
+        assert first_request["organization_id"] == self.install.organization.id
 
     @patch("sentry.tasks.sentry_apps.safe_urlopen", side_effect=RequestException("Timeout"))
     def test_saves_error_for_request_timeout(self, safe_urlopen):
@@ -393,11 +386,12 @@ class TestWebhookErrors(TestCase):
                 installation=self.install, event="issue.assigned", data=data, actor=self.user
             )
 
-        error_count = SentryAppWebhookError.objects.count()
-        error = SentryAppWebhookError.objects.first()
+        requests = self.buffer.get_requests()
+        requests_count = len(requests)
+        first_request = requests[0]
 
         assert safe_urlopen.called
-        assert error_count == 1
-        assert error.sentry_app.id == self.install.sentry_app.id
-        assert error.organization.id == self.install.organization.id
-        assert error.response_body == "RequestException('Timeout',)"
+        assert requests_count == 1
+        assert first_request["response_code"] == 0
+        assert first_request["event_type"] == "issue.assigned"
+        assert first_request["organization_id"] == self.install.organization.id

commit bb5056462ab093f96b8b0cf5aad57842768cfe9d
Author: Jess MacQueen <macqueen@users.noreply.github.com>
Date:   Mon Jan 28 14:54:05 2019 -0800

    feat(api): Add organization group index put method (#11732)

diff --git a/src/sentry/api/endpoints/organization_group_index.py b/src/sentry/api/endpoints/organization_group_index.py
index a7c292861a..88012afb67 100644
--- a/src/sentry/api/endpoints/organization_group_index.py
+++ b/src/sentry/api/endpoints/organization_group_index.py
@@ -8,7 +8,9 @@ from django.conf import settings
 from rest_framework.response import Response
 
 from sentry.api.bases import OrganizationEventsEndpointBase
-from sentry.api.helpers.group_index import build_query_params_from_request, get_by_short_id, ValidationError
+from sentry.api.helpers.group_index import (
+    build_query_params_from_request, get_by_short_id, update_groups, ValidationError
+)
 from sentry.api.serializers import serialize
 from sentry.api.serializers.models.group import StreamGroupSerializerSnuba
 from sentry.api.utils import get_date_range_from_params, InvalidParams
@@ -156,3 +158,77 @@ class OrganizationGroupIndexEndpoint(OrganizationEventsEndpointBase):
         # TODO(jess): add metrics that are similar to project endpoint here
 
         return response
+
+    def put(self, request, organization):
+        """
+        Bulk Mutate a List of Issues
+        ````````````````````````````
+
+        Bulk mutate various attributes on issues.  The list of issues
+        to modify is given through the `id` query parameter.  It is repeated
+        for each issue that should be modified.
+
+        - For non-status updates, the `id` query parameter is required.
+        - For status updates, the `id` query parameter may be omitted
+          for a batch "update all" query.
+        - An optional `status` query parameter may be used to restrict
+          mutations to only events with the given status.
+
+        The following attributes can be modified and are supplied as
+        JSON object in the body:
+
+        If any ids are out of scope this operation will succeed without
+        any data mutation.
+
+        :qparam int id: a list of IDs of the issues to be mutated.  This
+                        parameter shall be repeated for each issue.  It
+                        is optional only if a status is mutated in which
+                        case an implicit `update all` is assumed.
+        :qparam string status: optionally limits the query to issues of the
+                               specified status.  Valid values are
+                               ``"resolved"``, ``"unresolved"`` and
+                               ``"ignored"``.
+        :pparam string organization_slug: the slug of the organization the
+                                          issues belong to.
+        :param string status: the new status for the issues.  Valid values
+                              are ``"resolved"``, ``"resolvedInNextRelease"``,
+                              ``"unresolved"``, and ``"ignored"``. Status
+                              updates that include release data are only allowed
+                              for groups within a single project.
+        :param map statusDetails: additional details about the resolution.
+                                  Valid values are ``"inRelease"``, ``"inNextRelease"``,
+                                  ``"inCommit"``,  ``"ignoreDuration"``, ``"ignoreCount"``,
+                                  ``"ignoreWindow"``, ``"ignoreUserCount"``, and
+                                  ``"ignoreUserWindow"``. Status detail
+                                  updates that include release data are only allowed
+                                  for groups within a single project.
+        :param int ignoreDuration: the number of minutes to ignore this issue.
+        :param boolean isPublic: sets the issue to public or private.
+        :param boolean merge: allows to merge or unmerge different issues.
+        :param string assignedTo: the actor id (or username) of the user or team that should be
+                                  assigned to this issue. Bulk assigning issues
+                                  is limited to groups within a single project.
+        :param boolean hasSeen: in case this API call is invoked with a user
+                                context this allows changing of the flag
+                                that indicates if the user has seen the
+                                event.
+        :param boolean isBookmarked: in case this API call is invoked with a
+                                     user context this allows changing of
+                                     the bookmark flag.
+        :auth: required
+        """
+
+        projects = self.get_projects(request, organization)
+
+        search_fn = functools.partial(
+            self._search, request, organization, projects, self.get_environments(request, organization), {
+                'limit': 1000,
+                'paginator_options': {'max_limit': 1000},
+            }
+        )
+        return update_groups(
+            request,
+            projects,
+            organization.id,
+            search_fn,
+        )
diff --git a/src/sentry/api/helpers/group_index.py b/src/sentry/api/helpers/group_index.py
index 7f5e359b55..ccfe3b9c85 100644
--- a/src/sentry/api/helpers/group_index.py
+++ b/src/sentry/api/helpers/group_index.py
@@ -403,6 +403,10 @@ def update_groups(request, projects, organization_id, search_fn):
 
     is_bulk = len(group_ids) > 1
 
+    group_project_ids = {g.project_id for g in group_list}
+    # filter projects down to only those that have groups in the search results
+    projects = [p for p in projects if p.id in group_project_ids]
+
     queryset = Group.objects.filter(
         id__in=group_ids,
     )
diff --git a/tests/snuba/api/endpoints/test_organization_group_index.py b/tests/snuba/api/endpoints/test_organization_group_index.py
index 0e1f7dde8b..219ae7b562 100644
--- a/tests/snuba/api/endpoints/test_organization_group_index.py
+++ b/tests/snuba/api/endpoints/test_organization_group_index.py
@@ -6,8 +6,14 @@ from datetime import timedelta
 from django.core.urlresolvers import reverse
 from django.utils import timezone
 from exam import fixture
+from mock import patch, Mock
 
-from sentry.models import ApiToken, Event, EventMapping, GroupStatus, Release
+from sentry.models import (
+    Activity, ApiToken, Event, EventMapping, ExternalIssue, Group, GroupAssignee,
+    GroupBookmark, GroupHash, GroupLink, GroupSeen, GroupShare, GroupSnooze,
+    GroupStatus, GroupResolution, GroupSubscription, GroupTombstone, Integration,
+    OrganizationIntegration, UserOption, Release
+)
 from sentry.testutils import APITestCase, SnubaTestCase
 from sentry.testutils.helpers import parse_link_header
 from six.moves.urllib.parse import quote
@@ -415,3 +421,1407 @@ class GroupListTest(APITestCase, SnubaTestCase):
             )
 
             assert len(response.data) == 0
+
+
+class GroupUpdateTest(APITestCase, SnubaTestCase):
+    def setUp(self):
+        super(GroupUpdateTest, self).setUp()
+        self.min_ago = timezone.now() - timedelta(minutes=1)
+
+    @fixture
+    def path(self):
+        return reverse(
+            'sentry-api-0-organization-group-index',
+            args=[self.project.organization.slug]
+        )
+
+    def assertNoResolution(self, group):
+        assert not GroupResolution.objects.filter(
+            group=group,
+        ).exists()
+
+    def test_global_resolve(self):
+        group1 = self.create_group(checksum='a' * 32, status=GroupStatus.RESOLVED)
+        group2 = self.create_group(checksum='b' * 32, status=GroupStatus.UNRESOLVED)
+        group3 = self.create_group(checksum='c' * 32, status=GroupStatus.IGNORED)
+        group4 = self.create_group(
+            project=self.create_project(slug='foo'),
+            checksum='b' * 32,
+            status=GroupStatus.UNRESOLVED
+        )
+
+        self.login_as(user=self.user)
+        response = self.client.put(
+            u'{}?status=unresolved&project={}'.format(self.path, self.project.id),
+            data={
+                'status': 'resolved',
+            },
+            format='json',
+        )
+        assert response.status_code == 200, response.data
+        assert response.data == {
+            'status': 'resolved',
+            'statusDetails': {},
+        }
+
+        # the previously resolved entry should not be included
+        new_group1 = Group.objects.get(id=group1.id)
+        assert new_group1.status == GroupStatus.RESOLVED
+        assert new_group1.resolved_at is None
+
+        # this wont exist because it wasn't affected
+        assert not GroupSubscription.objects.filter(
+            user=self.user,
+            group=new_group1,
+        ).exists()
+
+        new_group2 = Group.objects.get(id=group2.id)
+        assert new_group2.status == GroupStatus.RESOLVED
+        assert new_group2.resolved_at is not None
+
+        assert GroupSubscription.objects.filter(
+            user=self.user,
+            group=new_group2,
+            is_active=True,
+        ).exists()
+
+        # the ignored entry should not be included
+        new_group3 = Group.objects.get(id=group3.id)
+        assert new_group3.status == GroupStatus.IGNORED
+        assert new_group3.resolved_at is None
+
+        assert not GroupSubscription.objects.filter(
+            user=self.user,
+            group=new_group3,
+        )
+
+        new_group4 = Group.objects.get(id=group4.id)
+        assert new_group4.status == GroupStatus.UNRESOLVED
+        assert new_group4.resolved_at is None
+
+        assert not GroupSubscription.objects.filter(
+            user=self.user,
+            group=new_group4,
+        )
+
+    def test_bulk_resolve(self):
+        self.login_as(user=self.user)
+
+        for i in range(200):
+            group = self.create_group(
+                status=GroupStatus.UNRESOLVED,
+                project=self.project,
+                first_seen=self.min_ago - timedelta(seconds=i),
+            )
+            self.create_event(
+                group=group,
+                data={'checksum': six.binary_type(i)},
+                datetime=self.min_ago - timedelta(seconds=i),
+            )
+
+        response = self.client.get(
+            u'{}?sort_by=date&query=is:unresolved'.format(self.path),
+            format='json',
+        )
+
+        assert len(response.data) == 100
+
+        response = self.client.put(
+            u'{}?status=unresolved'.format(self.path),
+            data={
+                'status': 'resolved',
+            },
+            format='json',
+        )
+        assert response.status_code == 200, response.data
+
+        assert response.data == {
+            'status': 'resolved',
+            'statusDetails': {},
+        }
+        response = self.client.get(
+            u'{}?sort_by=date&query=is:unresolved'.format(self.path),
+            format='json',
+        )
+
+        assert len(response.data) == 0
+
+    @patch('sentry.integrations.example.integration.ExampleIntegration.sync_status_outbound')
+    def test_resolve_with_integration(self, mock_sync_status_outbound):
+        self.login_as(user=self.user)
+
+        org = self.organization
+
+        integration = Integration.objects.create(
+            provider='example',
+            name='Example',
+        )
+        integration.add_organization(org, self.user)
+        group = self.create_group(
+            status=GroupStatus.UNRESOLVED,
+            organization=org,
+            first_seen=self.min_ago,
+        )
+        self.create_event(group=group, datetime=self.min_ago)
+
+        OrganizationIntegration.objects.filter(
+            integration_id=integration.id,
+            organization_id=group.organization.id,
+        ).update(
+            config={
+                'sync_comments': True,
+                'sync_status_outbound': True,
+                'sync_status_inbound': True,
+                'sync_assignee_outbound': True,
+                'sync_assignee_inbound': True,
+            }
+        )
+        external_issue = ExternalIssue.objects.get_or_create(
+            organization_id=org.id,
+            integration_id=integration.id,
+            key='APP-%s' % group.id,
+        )[0]
+
+        GroupLink.objects.get_or_create(
+            group_id=group.id,
+            project_id=group.project_id,
+            linked_type=GroupLink.LinkedType.issue,
+            linked_id=external_issue.id,
+            relationship=GroupLink.Relationship.references,
+        )[0]
+
+        response = self.client.get(
+            u'{}?sort_by=date&query=is:unresolved'.format(self.path),
+            format='json',
+        )
+
+        assert len(response.data) == 1
+
+        with self.tasks():
+            with self.feature({
+                'organizations:integrations-issue-sync': True,
+            }):
+                response = self.client.put(
+                    u'{}?status=unresolved'.format(self.path),
+                    data={
+                        'status': 'resolved',
+                    },
+                    format='json',
+                )
+                assert response.status_code == 200, response.data
+
+                group = Group.objects.get(id=group.id)
+                assert group.status == GroupStatus.RESOLVED
+
+                assert response.data == {
+                    'status': 'resolved',
+                    'statusDetails': {},
+                }
+                mock_sync_status_outbound.assert_called_once_with(
+                    external_issue, True, group.project_id
+                )
+
+        response = self.client.get(
+            u'{}?sort_by=date&query=is:unresolved'.format(self.path),
+            format='json',
+        )
+        assert len(response.data) == 0
+
+    @patch('sentry.integrations.example.integration.ExampleIntegration.sync_status_outbound')
+    def test_set_unresolved_with_integration(self, mock_sync_status_outbound):
+        release = self.create_release(project=self.project, version='abc')
+        group = self.create_group(checksum='a' * 32, status=GroupStatus.RESOLVED)
+        org = self.organization
+        integration = Integration.objects.create(
+            provider='example',
+            name='Example',
+        )
+        integration.add_organization(org, self.user)
+        OrganizationIntegration.objects.filter(
+            integration_id=integration.id,
+            organization_id=group.organization.id,
+        ).update(
+            config={
+                'sync_comments': True,
+                'sync_status_outbound': True,
+                'sync_status_inbound': True,
+                'sync_assignee_outbound': True,
+                'sync_assignee_inbound': True,
+            }
+        )
+        GroupResolution.objects.create(
+            group=group,
+            release=release,
+        )
+        external_issue = ExternalIssue.objects.get_or_create(
+            organization_id=org.id,
+            integration_id=integration.id,
+            key='APP-%s' % group.id,
+        )[0]
+
+        GroupLink.objects.get_or_create(
+            group_id=group.id,
+            project_id=group.project_id,
+            linked_type=GroupLink.LinkedType.issue,
+            linked_id=external_issue.id,
+            relationship=GroupLink.Relationship.references,
+        )[0]
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+
+        with self.tasks():
+            with self.feature({
+                'organizations:integrations-issue-sync': True,
+            }):
+                response = self.client.put(
+                    url, data={
+                        'status': 'unresolved',
+                    }, format='json'
+                )
+                assert response.status_code == 200
+                assert response.data == {
+                    'status': 'unresolved',
+                    'statusDetails': {},
+                }
+
+                group = Group.objects.get(id=group.id)
+                assert group.status == GroupStatus.UNRESOLVED
+
+                self.assertNoResolution(group)
+
+                assert GroupSubscription.objects.filter(
+                    user=self.user,
+                    group=group,
+                    is_active=True,
+                ).exists()
+                mock_sync_status_outbound.assert_called_once_with(
+                    external_issue, False, group.project_id
+                )
+
+    def test_self_assign_issue(self):
+        group = self.create_group(checksum='b' * 32, status=GroupStatus.UNRESOLVED)
+        user = self.user
+
+        uo1 = UserOption.objects.create(key='self_assign_issue', value='1', project=None, user=user)
+
+        self.login_as(user=user)
+        url = u'{url}?id={group.id}'.format(url=self.path, group=group)
+        response = self.client.put(
+            url,
+            data={
+                'status': 'resolved',
+            },
+            format='json',
+        )
+
+        assert response.status_code == 200, response.data
+        assert response.data['assignedTo']['id'] == six.text_type(user.id)
+        assert response.data['assignedTo']['type'] == 'user'
+        assert response.data['status'] == 'resolved'
+
+        assert GroupAssignee.objects.filter(group=group, user=user).exists()
+
+        assert GroupSubscription.objects.filter(
+            user=user,
+            group=group,
+            is_active=True,
+        ).exists()
+
+        uo1.delete()
+
+    def test_self_assign_issue_next_release(self):
+        release = Release.objects.create(organization_id=self.project.organization_id, version='a')
+        release.add_project(self.project)
+
+        group = self.create_group(
+            checksum='a' * 32,
+            status=GroupStatus.UNRESOLVED,
+        )
+
+        uo1 = UserOption.objects.create(
+            key='self_assign_issue', value='1', project=None, user=self.user
+        )
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url, data={
+                'status': 'resolvedInNextRelease',
+            }, format='json'
+        )
+        assert response.status_code == 200
+        assert response.data['status'] == 'resolved'
+        assert response.data['statusDetails']['inNextRelease']
+        assert response.data['assignedTo']['id'] == six.text_type(self.user.id)
+        assert response.data['assignedTo']['type'] == 'user'
+
+        group = Group.objects.get(id=group.id)
+        assert group.status == GroupStatus.RESOLVED
+
+        assert GroupResolution.objects.filter(
+            group=group,
+            release=release,
+        ).exists()
+
+        assert GroupSubscription.objects.filter(
+            user=self.user,
+            group=group,
+            is_active=True,
+        ).exists()
+
+        activity = Activity.objects.get(
+            group=group,
+            type=Activity.SET_RESOLVED_IN_RELEASE,
+        )
+        assert activity.data['version'] == ''
+        uo1.delete()
+
+    def test_selective_status_update(self):
+        group1 = self.create_group(checksum='a' * 32, status=GroupStatus.RESOLVED)
+        group2 = self.create_group(checksum='b' * 32, status=GroupStatus.UNRESOLVED)
+        group3 = self.create_group(checksum='c' * 32, status=GroupStatus.IGNORED)
+        group4 = self.create_group(
+            project=self.create_project(slug='foo'),
+            checksum='b' * 32,
+            status=GroupStatus.UNRESOLVED
+        )
+
+        self.login_as(user=self.user)
+        url = u'{url}?id={group1.id}&id={group2.id}&group4={group4.id}'.format(
+            url=self.path,
+            group1=group1,
+            group2=group2,
+            group4=group4,
+        )
+        response = self.client.put(
+            url, data={
+                'status': 'resolved',
+            }, format='json'
+        )
+        assert response.status_code == 200
+        assert response.data == {
+            'status': 'resolved',
+            'statusDetails': {},
+        }
+
+        new_group1 = Group.objects.get(id=group1.id)
+        assert new_group1.resolved_at is not None
+        assert new_group1.status == GroupStatus.RESOLVED
+
+        new_group2 = Group.objects.get(id=group2.id)
+        assert new_group2.resolved_at is not None
+        assert new_group2.status == GroupStatus.RESOLVED
+
+        assert GroupSubscription.objects.filter(
+            user=self.user,
+            group=new_group2,
+            is_active=True,
+        ).exists()
+
+        new_group3 = Group.objects.get(id=group3.id)
+        assert new_group3.resolved_at is None
+        assert new_group3.status == GroupStatus.IGNORED
+
+        new_group4 = Group.objects.get(id=group4.id)
+        assert new_group4.resolved_at is None
+        assert new_group4.status == GroupStatus.UNRESOLVED
+
+    def test_set_resolved_in_current_release(self):
+        release = Release.objects.create(organization_id=self.project.organization_id, version='a')
+        release.add_project(self.project)
+
+        group = self.create_group(
+            checksum='a' * 32,
+            status=GroupStatus.UNRESOLVED,
+        )
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url,
+            data={
+                'status': 'resolved',
+                'statusDetails': {
+                    'inRelease': 'latest',
+                },
+            },
+            format='json'
+        )
+        assert response.status_code == 200
+        assert response.data['status'] == 'resolved'
+        assert response.data['statusDetails']['inRelease'] == release.version
+        assert response.data['statusDetails']['actor']['id'] == six.text_type(self.user.id)
+
+        group = Group.objects.get(id=group.id)
+        assert group.status == GroupStatus.RESOLVED
+
+        resolution = GroupResolution.objects.get(
+            group=group,
+        )
+        assert resolution.release == release
+        assert resolution.type == GroupResolution.Type.in_release
+        assert resolution.status == GroupResolution.Status.resolved
+        assert resolution.actor_id == self.user.id
+
+        assert GroupSubscription.objects.filter(
+            user=self.user,
+            group=group,
+            is_active=True,
+        ).exists()
+
+        activity = Activity.objects.get(
+            group=group,
+            type=Activity.SET_RESOLVED_IN_RELEASE,
+        )
+        assert activity.data['version'] == release.version
+
+    def test_set_resolved_in_explicit_release(self):
+        release = Release.objects.create(organization_id=self.project.organization_id, version='a')
+        release.add_project(self.project)
+        release2 = Release.objects.create(organization_id=self.project.organization_id, version='b')
+        release2.add_project(self.project)
+
+        group = self.create_group(
+            checksum='a' * 32,
+            status=GroupStatus.UNRESOLVED,
+        )
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url,
+            data={
+                'status': 'resolved',
+                'statusDetails': {
+                    'inRelease': release.version,
+                },
+            },
+            format='json'
+        )
+        assert response.status_code == 200
+        assert response.data['status'] == 'resolved'
+        assert response.data['statusDetails']['inRelease'] == release.version
+        assert response.data['statusDetails']['actor']['id'] == six.text_type(self.user.id)
+
+        group = Group.objects.get(id=group.id)
+        assert group.status == GroupStatus.RESOLVED
+
+        resolution = GroupResolution.objects.get(
+            group=group,
+        )
+        assert resolution.release == release
+        assert resolution.type == GroupResolution.Type.in_release
+        assert resolution.status == GroupResolution.Status.resolved
+        assert resolution.actor_id == self.user.id
+
+        assert GroupSubscription.objects.filter(
+            user=self.user,
+            group=group,
+            is_active=True,
+        ).exists()
+
+        activity = Activity.objects.get(
+            group=group,
+            type=Activity.SET_RESOLVED_IN_RELEASE,
+        )
+        assert activity.data['version'] == release.version
+
+    def test_set_resolved_in_next_release(self):
+        release = Release.objects.create(organization_id=self.project.organization_id, version='a')
+        release.add_project(self.project)
+
+        group = self.create_group(
+            checksum='a' * 32,
+            status=GroupStatus.UNRESOLVED,
+        )
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url,
+            data={
+                'status': 'resolved',
+                'statusDetails': {
+                    'inNextRelease': True,
+                },
+            },
+            format='json'
+        )
+        assert response.status_code == 200
+        assert response.data['status'] == 'resolved'
+        assert response.data['statusDetails']['inNextRelease']
+        assert response.data['statusDetails']['actor']['id'] == six.text_type(self.user.id)
+
+        group = Group.objects.get(id=group.id)
+        assert group.status == GroupStatus.RESOLVED
+
+        resolution = GroupResolution.objects.get(
+            group=group,
+        )
+        assert resolution.release == release
+        assert resolution.type == GroupResolution.Type.in_next_release
+        assert resolution.status == GroupResolution.Status.pending
+        assert resolution.actor_id == self.user.id
+
+        assert GroupSubscription.objects.filter(
+            user=self.user,
+            group=group,
+            is_active=True,
+        ).exists()
+
+        activity = Activity.objects.get(
+            group=group,
+            type=Activity.SET_RESOLVED_IN_RELEASE,
+        )
+        assert activity.data['version'] == ''
+
+    def test_set_resolved_in_next_release_legacy(self):
+        release = Release.objects.create(organization_id=self.project.organization_id, version='a')
+        release.add_project(self.project)
+
+        group = self.create_group(
+            checksum='a' * 32,
+            status=GroupStatus.UNRESOLVED,
+        )
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url, data={
+                'status': 'resolvedInNextRelease',
+            }, format='json'
+        )
+        assert response.status_code == 200
+        assert response.data['status'] == 'resolved'
+        assert response.data['statusDetails']['inNextRelease']
+        assert response.data['statusDetails']['actor']['id'] == six.text_type(self.user.id)
+
+        group = Group.objects.get(id=group.id)
+        assert group.status == GroupStatus.RESOLVED
+
+        resolution = GroupResolution.objects.get(
+            group=group,
+        )
+        assert resolution.release == release
+        assert resolution.type == GroupResolution.Type.in_next_release
+        assert resolution.status == GroupResolution.Status.pending
+        assert resolution.actor_id == self.user.id
+
+        assert GroupSubscription.objects.filter(
+            user=self.user,
+            group=group,
+            is_active=True,
+        ).exists()
+
+        activity = Activity.objects.get(
+            group=group,
+            type=Activity.SET_RESOLVED_IN_RELEASE,
+        )
+        assert activity.data['version'] == ''
+
+    def test_set_resolved_in_explicit_commit_unreleased(self):
+        repo = self.create_repo(
+            project=self.project,
+            name=self.project.name,
+        )
+        commit = self.create_commit(
+            project=self.project,
+            repo=repo,
+        )
+        group = self.create_group(
+            checksum='a' * 32,
+            status=GroupStatus.UNRESOLVED,
+        )
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url,
+            data={
+                'status': 'resolved',
+                'statusDetails': {
+                    'inCommit': {
+                        'commit': commit.key,
+                        'repository': repo.name,
+                    },
+                },
+            },
+            format='json'
+        )
+        assert response.status_code == 200
+        assert response.data['status'] == 'resolved'
+        assert response.data['statusDetails']['inCommit']['id'] == commit.key
+        assert response.data['statusDetails']['actor']['id'] == six.text_type(self.user.id)
+
+        group = Group.objects.get(id=group.id)
+        assert group.status == GroupStatus.RESOLVED
+
+        link = GroupLink.objects.get(group_id=group.id)
+        assert link.linked_type == GroupLink.LinkedType.commit
+        assert link.relationship == GroupLink.Relationship.resolves
+        assert link.linked_id == commit.id
+
+        assert GroupSubscription.objects.filter(
+            user=self.user,
+            group=group,
+            is_active=True,
+        ).exists()
+
+        activity = Activity.objects.get(
+            group=group,
+            type=Activity.SET_RESOLVED_IN_COMMIT,
+        )
+        assert activity.data['commit'] == commit.id
+
+    def test_set_resolved_in_explicit_commit_released(self):
+        release = self.create_release(
+            project=self.project,
+        )
+        repo = self.create_repo(
+            project=self.project,
+            name=self.project.name,
+        )
+        commit = self.create_commit(
+            project=self.project,
+            repo=repo,
+            release=release,
+        )
+
+        group = self.create_group(
+            checksum='a' * 32,
+            status=GroupStatus.UNRESOLVED,
+        )
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url,
+            data={
+                'status': 'resolved',
+                'statusDetails': {
+                    'inCommit': {
+                        'commit': commit.key,
+                        'repository': repo.name,
+                    },
+                },
+            },
+            format='json'
+        )
+        assert response.status_code == 200
+        assert response.data['status'] == 'resolved'
+        assert response.data['statusDetails']['inCommit']['id'] == commit.key
+        assert response.data['statusDetails']['actor']['id'] == six.text_type(self.user.id)
+
+        group = Group.objects.get(id=group.id)
+        assert group.status == GroupStatus.RESOLVED
+
+        link = GroupLink.objects.get(group_id=group.id)
+        assert link.project_id == self.project.id
+        assert link.linked_type == GroupLink.LinkedType.commit
+        assert link.relationship == GroupLink.Relationship.resolves
+        assert link.linked_id == commit.id
+
+        assert GroupSubscription.objects.filter(
+            user=self.user,
+            group=group,
+            is_active=True,
+        ).exists()
+
+        activity = Activity.objects.get(
+            group=group,
+            type=Activity.SET_RESOLVED_IN_COMMIT,
+        )
+        assert activity.data['commit'] == commit.id
+
+        resolution = GroupResolution.objects.get(
+            group=group,
+        )
+        assert resolution.type == GroupResolution.Type.in_release
+        assert resolution.status == GroupResolution.Status.resolved
+
+    def test_set_resolved_in_explicit_commit_missing(self):
+        repo = self.create_repo(
+            project=self.project,
+            name=self.project.name,
+        )
+        group = self.create_group(
+            checksum='a' * 32,
+            status=GroupStatus.UNRESOLVED,
+        )
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url,
+            data={
+                'status': 'resolved',
+                'statusDetails': {
+                    'inCommit': {
+                        'commit': 'a' * 40,
+                        'repository': repo.name,
+                    },
+                },
+            },
+            format='json'
+        )
+        assert response.status_code == 400
+        assert response.data['statusDetails'][0]['inCommit'][0]['commit']
+
+    def test_set_unresolved(self):
+        release = self.create_release(project=self.project, version='abc')
+        group = self.create_group(checksum='a' * 32, status=GroupStatus.RESOLVED)
+        GroupResolution.objects.create(
+            group=group,
+            release=release,
+        )
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url, data={
+                'status': 'unresolved',
+            }, format='json'
+        )
+        assert response.status_code == 200
+        assert response.data == {
+            'status': 'unresolved',
+            'statusDetails': {},
+        }
+
+        group = Group.objects.get(id=group.id)
+        assert group.status == GroupStatus.UNRESOLVED
+
+        self.assertNoResolution(group)
+
+        assert GroupSubscription.objects.filter(
+            user=self.user,
+            group=group,
+            is_active=True,
+        ).exists()
+
+    def test_set_unresolved_on_snooze(self):
+        group = self.create_group(checksum='a' * 32, status=GroupStatus.IGNORED)
+
+        GroupSnooze.objects.create(
+            group=group,
+            until=timezone.now() - timedelta(days=1),
+        )
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url, data={
+                'status': 'unresolved',
+            }, format='json'
+        )
+        assert response.status_code == 200
+        assert response.data == {
+            'status': 'unresolved',
+            'statusDetails': {},
+        }
+
+        group = Group.objects.get(id=group.id)
+        assert group.status == GroupStatus.UNRESOLVED
+
+    def test_basic_ignore(self):
+        group = self.create_group(checksum='a' * 32, status=GroupStatus.RESOLVED)
+
+        snooze = GroupSnooze.objects.create(
+            group=group,
+            until=timezone.now(),
+        )
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url, data={
+                'status': 'ignored',
+            }, format='json'
+        )
+
+        assert response.status_code == 200
+
+        # existing snooze objects should be cleaned up
+        assert not GroupSnooze.objects.filter(id=snooze.id).exists()
+
+        group = Group.objects.get(id=group.id)
+        assert group.status == GroupStatus.IGNORED
+
+        assert response.data == {
+            'status': 'ignored',
+            'statusDetails': {},
+        }
+
+    def test_snooze_duration(self):
+        group = self.create_group(checksum='a' * 32, status=GroupStatus.RESOLVED)
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url, data={
+                'status': 'ignored',
+                'ignoreDuration': 30,
+            }, format='json'
+        )
+
+        assert response.status_code == 200
+
+        snooze = GroupSnooze.objects.get(group=group)
+        snooze.until = snooze.until.replace(microsecond=0)
+
+        # Drop microsecond value for MySQL
+        now = timezone.now().replace(microsecond=0)
+
+        assert snooze.count is None
+        assert snooze.until > now + timedelta(minutes=29)
+        assert snooze.until < now + timedelta(minutes=31)
+        assert snooze.user_count is None
+        assert snooze.user_window is None
+        assert snooze.window is None
+
+        # Drop microsecond value for MySQL
+        response.data['statusDetails']['ignoreUntil'] = response.data['statusDetails'
+                                                                      ]['ignoreUntil'].replace(
+                                                                          microsecond=0
+                                                                      )  # noqa
+
+        assert response.data['status'] == 'ignored'
+        assert response.data['statusDetails']['ignoreCount'] == snooze.count
+        assert response.data['statusDetails']['ignoreWindow'] == snooze.window
+        assert response.data['statusDetails']['ignoreUserCount'] == snooze.user_count
+        assert response.data['statusDetails']['ignoreUserWindow'] == snooze.user_window
+        assert response.data['statusDetails']['ignoreUntil'] == snooze.until
+        assert response.data['statusDetails']['actor']['id'] == six.text_type(self.user.id)
+
+    def test_snooze_count(self):
+        group = self.create_group(
+            checksum='a' * 32,
+            status=GroupStatus.RESOLVED,
+            times_seen=1,
+        )
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url, data={
+                'status': 'ignored',
+                'ignoreCount': 100,
+            }, format='json'
+        )
+
+        assert response.status_code == 200
+
+        snooze = GroupSnooze.objects.get(group=group)
+        assert snooze.count == 100
+        assert snooze.until is None
+        assert snooze.user_count is None
+        assert snooze.user_window is None
+        assert snooze.window is None
+        assert snooze.state['times_seen'] == 1
+
+        assert response.data['status'] == 'ignored'
+        assert response.data['statusDetails']['ignoreCount'] == snooze.count
+        assert response.data['statusDetails']['ignoreWindow'] == snooze.window
+        assert response.data['statusDetails']['ignoreUserCount'] == snooze.user_count
+        assert response.data['statusDetails']['ignoreUserWindow'] == snooze.user_window
+        assert response.data['statusDetails']['ignoreUntil'] == snooze.until
+        assert response.data['statusDetails']['actor']['id'] == six.text_type(self.user.id)
+
+    def test_snooze_user_count(self):
+        group = self.create_group(
+            checksum='a' * 32,
+            status=GroupStatus.RESOLVED,
+            first_seen=self.min_ago - timedelta(seconds=100),
+            last_seen=timezone.now(),
+        )
+        for i in range(100):
+            self.create_event(
+                group=group,
+                data={'checksum': six.binary_type(i)},
+                tags={'sentry:user': {'id': six.binary_type(i)}},
+                datetime=self.min_ago - timedelta(seconds=i),
+            )
+
+        self.login_as(user=self.user)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url, data={
+                'status': 'ignored',
+                'ignoreUserCount': 100,
+            }, format='json'
+        )
+
+        assert response.status_code == 200
+
+        snooze = GroupSnooze.objects.get(group=group)
+        assert snooze.count is None
+        assert snooze.until is None
+        assert snooze.user_count == 100
+        assert snooze.user_window is None
+        assert snooze.window is None
+        assert snooze.state['users_seen'] == 100
+
+        assert response.data['status'] == 'ignored'
+        assert response.data['statusDetails']['ignoreCount'] == snooze.count
+        assert response.data['statusDetails']['ignoreWindow'] == snooze.window
+        assert response.data['statusDetails']['ignoreUserCount'] == snooze.user_count
+        assert response.data['statusDetails']['ignoreUserWindow'] == snooze.user_window
+        assert response.data['statusDetails']['ignoreUntil'] == snooze.until
+        assert response.data['statusDetails']['actor']['id'] == six.text_type(self.user.id)
+
+    def test_set_bookmarked(self):
+        group1 = self.create_group(checksum='a' * 32, status=GroupStatus.RESOLVED)
+        group2 = self.create_group(checksum='b' * 32, status=GroupStatus.UNRESOLVED)
+        group3 = self.create_group(checksum='c' * 32, status=GroupStatus.IGNORED)
+        group4 = self.create_group(
+            project=self.create_project(slug='foo'),
+            checksum='b' * 32,
+            status=GroupStatus.UNRESOLVED
+        )
+
+        self.login_as(user=self.user)
+        url = u'{url}?id={group1.id}&id={group2.id}&group4={group4.id}'.format(
+            url=self.path,
+            group1=group1,
+            group2=group2,
+            group4=group4,
+        )
+        response = self.client.put(
+            url, data={
+                'isBookmarked': 'true',
+            }, format='json'
+        )
+        assert response.status_code == 200
+        assert response.data == {
+            'isBookmarked': True,
+        }
+
+        bookmark1 = GroupBookmark.objects.filter(group=group1, user=self.user)
+        assert bookmark1.exists()
+
+        assert GroupSubscription.objects.filter(
+            user=self.user,
+            group=group1,
+            is_active=True,
+        ).exists()
+
+        bookmark2 = GroupBookmark.objects.filter(group=group2, user=self.user)
+        assert bookmark2.exists()
+
+        assert GroupSubscription.objects.filter(
+            user=self.user,
+            group=group2,
+            is_active=True,
+        ).exists()
+
+        bookmark3 = GroupBookmark.objects.filter(group=group3, user=self.user)
+        assert not bookmark3.exists()
+
+        bookmark4 = GroupBookmark.objects.filter(group=group4, user=self.user)
+        assert not bookmark4.exists()
+
+    def test_subscription(self):
+        group1 = self.create_group(checksum='a' * 32)
+        group2 = self.create_group(checksum='b' * 32)
+        group3 = self.create_group(checksum='c' * 32)
+        group4 = self.create_group(project=self.create_project(slug='foo'), checksum='b' * 32)
+
+        self.login_as(user=self.user)
+        url = u'{url}?id={group1.id}&id={group2.id}&group4={group4.id}'.format(
+            url=self.path,
+            group1=group1,
+            group2=group2,
+            group4=group4,
+        )
+        response = self.client.put(
+            url, data={
+                'isSubscribed': 'true',
+            }, format='json'
+        )
+        assert response.status_code == 200
+        assert response.data == {
+            'isSubscribed': True,
+            'subscriptionDetails': {
+                'reason': 'unknown',
+            },
+        }
+
+        assert GroupSubscription.objects.filter(
+            group=group1,
+            user=self.user,
+            is_active=True,
+        ).exists()
+
+        assert GroupSubscription.objects.filter(
+            group=group2,
+            user=self.user,
+            is_active=True,
+        ).exists()
+
+        assert not GroupSubscription.objects.filter(
+            group=group3,
+            user=self.user,
+        ).exists()
+
+        assert not GroupSubscription.objects.filter(
+            group=group4,
+            user=self.user,
+        ).exists()
+
+    def test_set_public(self):
+        group1 = self.create_group(checksum='a' * 32)
+        group2 = self.create_group(checksum='b' * 32)
+
+        self.login_as(user=self.user)
+        url = u'{url}?id={group1.id}&id={group2.id}'.format(
+            url=self.path,
+            group1=group1,
+            group2=group2,
+        )
+        response = self.client.put(
+            url, data={
+                'isPublic': 'true',
+            }, format='json'
+        )
+        assert response.status_code == 200
+        assert response.data['isPublic'] is True
+        assert 'shareId' in response.data
+
+        new_group1 = Group.objects.get(id=group1.id)
+        assert bool(new_group1.get_share_id())
+
+        new_group2 = Group.objects.get(id=group2.id)
+        assert bool(new_group2.get_share_id())
+
+    def test_set_private(self):
+        group1 = self.create_group(checksum='a' * 32)
+        group2 = self.create_group(checksum='b' * 32)
+
+        # Manually mark them as shared
+        for g in group1, group2:
+            GroupShare.objects.create(
+                project_id=g.project_id,
+                group=g,
+            )
+            assert bool(g.get_share_id())
+
+        self.login_as(user=self.user)
+        url = u'{url}?id={group1.id}&id={group2.id}'.format(
+            url=self.path,
+            group1=group1,
+            group2=group2,
+        )
+        response = self.client.put(
+            url, data={
+                'isPublic': 'false',
+            }, format='json'
+        )
+        assert response.status_code == 200
+        assert response.data == {
+            'isPublic': False,
+        }
+
+        new_group1 = Group.objects.get(id=group1.id)
+        assert not bool(new_group1.get_share_id())
+
+        new_group2 = Group.objects.get(id=group2.id)
+        assert not bool(new_group2.get_share_id())
+
+    def test_set_has_seen(self):
+        group1 = self.create_group(checksum='a' * 32, status=GroupStatus.RESOLVED)
+        group2 = self.create_group(checksum='b' * 32, status=GroupStatus.UNRESOLVED)
+        group3 = self.create_group(checksum='c' * 32, status=GroupStatus.IGNORED)
+        group4 = self.create_group(
+            project=self.create_project(slug='foo'),
+            checksum='b' * 32,
+            status=GroupStatus.UNRESOLVED
+        )
+
+        self.login_as(user=self.user)
+        url = u'{url}?id={group1.id}&id={group2.id}&group4={group4.id}'.format(
+            url=self.path,
+            group1=group1,
+            group2=group2,
+            group4=group4,
+        )
+        response = self.client.put(
+            url, data={
+                'hasSeen': 'true',
+            }, format='json'
+        )
+        assert response.status_code == 200
+        assert response.data == {
+            'hasSeen': True,
+        }
+
+        r1 = GroupSeen.objects.filter(group=group1, user=self.user)
+        assert r1.exists()
+
+        r2 = GroupSeen.objects.filter(group=group2, user=self.user)
+        assert r2.exists()
+
+        r3 = GroupSeen.objects.filter(group=group3, user=self.user)
+        assert not r3.exists()
+
+        r4 = GroupSeen.objects.filter(group=group4, user=self.user)
+        assert not r4.exists()
+
+    @patch('sentry.api.helpers.group_index.uuid4')
+    @patch('sentry.api.helpers.group_index.merge_groups')
+    @patch('sentry.api.helpers.group_index.eventstream')
+    def test_merge(self, mock_eventstream, merge_groups, mock_uuid4):
+        eventstream_state = object()
+        mock_eventstream.start_merge = Mock(return_value=eventstream_state)
+
+        class uuid(object):
+            hex = 'abc123'
+
+        mock_uuid4.return_value = uuid
+        group1 = self.create_group(checksum='a' * 32, times_seen=1)
+        group2 = self.create_group(checksum='b' * 32, times_seen=50)
+        group3 = self.create_group(checksum='c' * 32, times_seen=2)
+        self.create_group(checksum='d' * 32)
+
+        self.login_as(user=self.user)
+        url = u'{url}?id={group1.id}&id={group2.id}&id={group3.id}'.format(
+            url=self.path,
+            group1=group1,
+            group2=group2,
+            group3=group3,
+        )
+        response = self.client.put(
+            url, data={
+                'merge': '1',
+            }, format='json'
+        )
+        assert response.status_code == 200
+        assert response.data['merge']['parent'] == six.text_type(group2.id)
+        assert sorted(response.data['merge']['children']) == sorted(
+            [
+                six.text_type(group1.id),
+                six.text_type(group3.id),
+            ]
+        )
+
+        mock_eventstream.start_merge.assert_called_once_with(
+            group1.project_id, [group3.id, group1.id], group2.id)
+
+        assert len(merge_groups.mock_calls) == 1
+        merge_groups.delay.assert_any_call(
+            from_object_ids=[group3.id, group1.id],
+            to_object_id=group2.id,
+            transaction_id='abc123',
+            eventstream_state=eventstream_state,
+        )
+
+    def test_assign(self):
+        group1 = self.create_group(checksum='a' * 32, is_public=True)
+        group2 = self.create_group(checksum='b' * 32, is_public=True)
+        user = self.user
+
+        self.login_as(user=user)
+        url = u'{url}?id={group1.id}'.format(
+            url=self.path,
+            group1=group1,
+        )
+        response = self.client.put(
+            url, data={
+                'assignedTo': user.username,
+            }
+        )
+
+        assert response.status_code == 200
+        assert response.data['assignedTo']['id'] == six.text_type(user.id)
+        assert response.data['assignedTo']['type'] == 'user'
+        assert GroupAssignee.objects.filter(group=group1, user=user).exists()
+
+        assert not GroupAssignee.objects.filter(group=group2, user=user).exists()
+
+        assert Activity.objects.filter(
+            group=group1,
+            user=user,
+            type=Activity.ASSIGNED,
+        ).count() == 1
+
+        assert GroupSubscription.objects.filter(
+            user=user,
+            group=group1,
+            is_active=True,
+        ).exists()
+
+        response = self.client.put(
+            url, data={
+                'assignedTo': '',
+            }, format='json'
+        )
+
+        assert response.status_code == 200, response.content
+        assert response.data['assignedTo'] is None
+
+        assert not GroupAssignee.objects.filter(group=group1, user=user).exists()
+
+    def test_assign_non_member(self):
+        group = self.create_group(checksum='a' * 32, is_public=True)
+        member = self.user
+        non_member = self.create_user('bar@example.com')
+
+        self.login_as(user=member)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url, data={
+                'assignedTo': non_member.username,
+            }, format='json'
+        )
+
+        assert response.status_code == 400, response.content
+
+    def test_assign_team(self):
+        self.login_as(user=self.user)
+
+        group = self.create_group()
+        other_member = self.create_user('bar@example.com')
+        team = self.create_team(
+            organization=group.project.organization, members=[
+                self.user, other_member])
+
+        group.project.add_team(team)
+
+        url = u'{url}?id={group.id}'.format(
+            url=self.path,
+            group=group,
+        )
+        response = self.client.put(
+            url, data={
+                'assignedTo': u'team:{}'.format(team.id),
+            }
+        )
+
+        assert response.status_code == 200
+        assert response.data['assignedTo']['id'] == six.text_type(team.id)
+        assert response.data['assignedTo']['type'] == 'team'
+        assert GroupAssignee.objects.filter(group=group, team=team).exists()
+
+        assert Activity.objects.filter(
+            group=group,
+            type=Activity.ASSIGNED,
+        ).count() == 1
+
+        assert GroupSubscription.objects.filter(
+            group=group,
+            is_active=True,
+        ).count() == 2
+
+        response = self.client.put(
+            url, data={
+                'assignedTo': '',
+            }, format='json'
+        )
+
+        assert response.status_code == 200, response.content
+        assert response.data['assignedTo'] is None
+
+    def test_discard(self):
+        group1 = self.create_group(checksum='a' * 32, is_public=True)
+        group2 = self.create_group(checksum='b' * 32, is_public=True)
+        group_hash = GroupHash.objects.create(
+            hash='x' * 32,
+            project=group1.project,
+            group=group1,
+        )
+        user = self.user
+
+        self.login_as(user=user)
+        url = u'{url}?id={group1.id}'.format(
+            url=self.path,
+            group1=group1,
+        )
+        with self.tasks():
+            with self.feature('projects:discard-groups'):
+                response = self.client.put(
+                    url, data={
+                        'discard': True,
+                    }
+                )
+
+        assert response.status_code == 204
+        assert not Group.objects.filter(
+            id=group1.id,
+        ).exists()
+        assert Group.objects.filter(
+            id=group2.id,
+        ).exists()
+        assert GroupHash.objects.filter(
+            id=group_hash.id,
+        ).exists()
+        tombstone = GroupTombstone.objects.get(
+            id=GroupHash.objects.get(id=group_hash.id).group_tombstone_id,
+        )
+        assert tombstone.message == group1.message
+        assert tombstone.culprit == group1.culprit
+        assert tombstone.project == group1.project
+        assert tombstone.data == group1.data

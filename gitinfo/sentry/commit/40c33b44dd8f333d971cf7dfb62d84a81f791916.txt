commit 40c33b44dd8f333d971cf7dfb62d84a81f791916
Author: Ted Kaemming <ted@kaemming.com>
Date:   Fri Oct 2 15:20:05 2015 -0700

    Add Redis version checks to TSDB backend validation.

diff --git a/src/sentry/tsdb/redis.py b/src/sentry/tsdb/redis.py
index a007dabebb..3727a273c7 100644
--- a/src/sentry/tsdb/redis.py
+++ b/src/sentry/tsdb/redis.py
@@ -7,6 +7,7 @@ sentry.tsdb.redis
 """
 from __future__ import absolute_import
 
+import logging
 import six
 
 from binascii import crc32
@@ -20,6 +21,13 @@ from rb import Cluster
 
 from sentry.exceptions import InvalidConfiguration
 from sentry.tsdb.base import BaseTSDB
+from sentry.utils.versioning import (
+    Version,
+    check_versions,
+)
+
+
+logger = logging.getLogger(__name__)
 
 
 class RedisTSDB(BaseTSDB):
@@ -61,12 +69,25 @@ class RedisTSDB(BaseTSDB):
         super(RedisTSDB, self).__init__(**kwargs)
 
     def validate(self):
+        logger.info('Validating Redis version...')
+
         try:
             with self.cluster.all() as client:
-                client.ping()
+                results = client.info()
         except Exception as e:
+            # Any connection issues should be caught here.
             raise InvalidConfiguration(unicode(e))
 
+        versions = {}
+        for id, info in results.value.items():
+            host = self.cluster.hosts[id]
+            # NOTE: This assumes there is no routing magic going on here, and
+            # all requests to this host are being served by the same database.
+            key = '{host}:{port}'.format(host=host.host, port=host.port)
+            versions[key] = Version(*map(int, info['redis_version'].split('.', 3)))
+
+        check_versions('Redis (TSDB)', versions, Version(2, 8, 9), Version(3, 0, 4))
+
     def make_key(self, model, epoch, model_key):
         if isinstance(model_key, six.integer_types):
             vnode = model_key % self.vnodes
diff --git a/src/sentry/utils/versioning.py b/src/sentry/utils/versioning.py
new file mode 100644
index 0000000000..0463396dac
--- /dev/null
+++ b/src/sentry/utils/versioning.py
@@ -0,0 +1,44 @@
+from __future__ import absolute_import
+
+import warnings
+from collections import namedtuple
+
+from sentry.exceptions import InvalidConfiguration
+
+
+class Version(namedtuple('Version', 'major minor patch')):
+    def __str__(self):
+        return '.'.join(map(str, self))
+
+
+def make_upgrade_message(service, modality, version, hosts):
+    return '{service} {modality} be upgraded to {version} on {hosts}.'.format(
+        hosts=', '.join('{0} (currently {1})'.format(*i) for i in hosts),
+        modality=modality,
+        service=service,
+        version=version,
+    )
+
+
+def check_versions(service, versions, required, recommended=None):
+    """
+    Check that all members of mapping hosts fulfill version requirements.
+
+    :param service: service label, such as ``Redis``
+    :param versions: mapping of host to ``Version``
+    :param required: lowest supported ``Version``. If any host does not fulfill
+        this requirement, an ``InvalidConfiguration`` exception is raised.
+    :param recommended: recommended version. If any host does not fulfill this
+        requirement, a ``PendingDeprecationWarning`` is raised.
+    """
+    must_upgrade = filter(lambda (host, version): required > version, versions.items())
+    if must_upgrade:
+        raise InvalidConfiguration(make_upgrade_message(service, 'must', required, must_upgrade))
+
+    if recommended:
+        should_upgrade = filter(lambda (host, version): recommended > version, versions.items())
+        if should_upgrade:
+            warnings.warn(
+                make_upgrade_message(service, 'should', recommended, should_upgrade),
+                PendingDeprecationWarning,
+            )

commit c9c95fcb4105c559efc4df2ad46a8568020b8048
Author: Armin Ronacher <armin.ronacher@active-4.com>
Date:   Wed Feb 8 13:30:58 2017 +0100

    Changed logic for symbolication to support multiple frames

diff --git a/src/sentry/lang/native/plugin.py b/src/sentry/lang/native/plugin.py
index 7870f3de46..55e364fe56 100644
--- a/src/sentry/lang/native/plugin.py
+++ b/src/sentry/lang/native/plugin.py
@@ -381,27 +381,31 @@ class NativeStacktraceProcessor(StacktraceProcessor):
         # dict.
         return self.sym.resolve_missing_vmaddrs()
 
-    def _get_frame_meta(self, stacktrace_info, idx):
-        # We only need to provide meta information for frame zero
-        if idx != 0:
-            return None
+    def find_best_instruction(self, frame, stacktrace_info, idx):
+        """Given a frame, stacktrace info and frame index this returns the
+        interpolated instruction address we then use for symbolication later.
+        """
+        meta = None
 
-        # The signal is useful information for symsynd in some situations
-        # to disambiugate the first frame.  If we can get this information
-        # from the mechanism we want to pass it onwards.
-        signal = None
-        exc = self.data.get('sentry.interfaces.Exception')
-        if exc is not None:
-            mechanism = exc['values'][0].get('mechanism')
-            if mechanism and 'posix_signal' in mechanism and \
-               'signal' in mechanism['posix_signal']:
-                signal = mechanism['posix_signal']['signal']
-
-        return {
-            'frame_number': 0,
-            'registers': stacktrace_info.stacktrace.get('registers'),
-            'signal': signal,
-        }
+        # We only need to provide meta information for frame zero
+        if idx == 0:
+            # The signal is useful information for symsynd in some situations
+            # to disambiugate the first frame.  If we can get this information
+            # from the mechanism we want to pass it onwards.
+            signal = None
+            exc = self.data.get('sentry.interfaces.Exception')
+            if exc is not None:
+                mechanism = exc['values'][0].get('mechanism')
+                if mechanism and 'posix_signal' in mechanism and \
+                   'signal' in mechanism['posix_signal']:
+                    signal = mechanism['posix_signal']['signal']
+            meta = {
+                'frame_number': 0,
+                'registers': stacktrace_info.stacktrace.get('registers'),
+                'signal': signal,
+            }
+
+        return self.sym.find_best_instruction(frame, meta=meta)
 
     def process_frame(self, frame, stacktrace_info, idx):
         # XXX: warn on missing availability?
@@ -410,30 +414,27 @@ class NativeStacktraceProcessor(StacktraceProcessor):
         # have the mandatory requirements for
         if not self.available or \
            self.get_effective_platform(frame) != 'cocoa' or \
-           'image_addr' not in frame or \
-           'instruction_addr' not in frame or \
-           'symbol_addr' not in frame:
+           'instruction_addr' not in frame:
             return None
 
         errors = []
 
         # Construct a raw frame that is used by the symbolizer
-        # backend.
-        sym_frame = {
+        # backend.  We only assemble the bare minimum we need here.
+        sym_input_frame = {
             'object_name': frame.get('package'),
-            'object_addr': frame['image_addr'],
-            'instruction_addr': frame['instruction_addr'],
+            'instruction_addr': self.find_best_instruction(
+                frame['instruction_addr'], stacktrace_info, idx),
             'symbol_name': frame.get('function'),
-            'symbol_addr': frame['symbol_addr'],
         }
-        meta = self._get_frame_meta(stacktrace_info, idx)
+        in_app = self.sym.is_in_app(sym_input_frame)
 
-        new_frame = dict(frame)
+        new_frames = []
         raw_frame = dict(frame)
 
         try:
-            sfrm = self.sym.symbolize_frame(sym_frame, self.sdk_info,
-                                            meta=meta)
+            symbolicated_frames = self.sym.symbolize_frame(
+                sym_input_frame, self.sdk_info, symbolize_inlined=True)
         except SymbolicationFailed as e:
             if e.is_user_fixable or e.is_sdk_failure:
                 errors.append({
@@ -447,39 +448,45 @@ class NativeStacktraceProcessor(StacktraceProcessor):
                 logger.debug('Failed to symbolicate with native backend',
                              exc_info=True)
         else:
-            symbol = sfrm.get('symbol_name') or \
-                new_frame.get('function') or '<unknown>'
-            function = demangle_symbol(symbol, simplified=True)
-
-            new_frame['function'] = function
-
-            # If we demangled something, store the original in the
-            # symbol portion of the frame
-            if function != symbol:
-                new_frame['symbol'] = symbol
-
-            new_frame['abs_path'] = sfrm.get('filename') or None
-            if new_frame['abs_path']:
-                new_frame['filename'] = posixpath.basename(
-                    new_frame['abs_path'])
-            if sfrm.get('line') is not None:
-                new_frame['lineno'] = sfrm['line']
-            else:
-                new_frame['instruction_offset'] = \
-                    parse_addr(sfrm['instruction_addr']) - \
+            for sfrm in symbolicated_frames:
+                symbol = sfrm.get('symbol_name') or \
+                    frame.get('function') or '<unknown>'
+                function = demangle_symbol(symbol, simplified=True)
+
+                new_frame = dict(frame)
+                new_frame['function'] = function
+
+                # If we demangled something, store the original in the
+                # symbol portion of the frame
+                if function != symbol:
+                    new_frame['symbol'] = symbol
+
+                new_frame['abs_path'] = sfrm.get('filename') or None
+                if new_frame['abs_path']:
+                    new_frame['filename'] = posixpath.basename(
+                        new_frame['abs_path'])
+                if sfrm.get('line') is not None:
+                    new_frame['lineno'] = sfrm['line']
+                else:
+                    new_frame['instruction_offset'] = \
+                        parse_addr(sfrm['instruction_addr']) - \
+                        parse_addr(sfrm['symbol_addr'])
+                if sfrm.get('column') is not None:
+                    new_frame['colno'] = sfrm['column']
+                new_frame['package'] = sfrm['object_name'] \
+                    or new_frame.get('package')
+                new_frame['symbol_addr'] = '0x%x' % \
                     parse_addr(sfrm['symbol_addr'])
-            if sfrm.get('column') is not None:
-                new_frame['colno'] = sfrm['column']
-            new_frame['package'] = sfrm['object_name'] \
-                or new_frame.get('package')
-            new_frame['symbol_addr'] = '0x%x' % \
-                parse_addr(sfrm['symbol_addr'])
-            new_frame['instruction_addr'] = '0x%x' % parse_addr(
-                sfrm['instruction_addr'])
-
-        in_app = self.sym.is_in_app(sym_frame)
-        new_frame['in_app'] = raw_frame['in_app'] = in_app
-        return [new_frame], [raw_frame], errors
+                new_frame['instruction_addr'] = '0x%x' % parse_addr(
+                    sfrm['instruction_addr'])
+
+                if new_frame.get('in_app') is None:
+                    new_frame['in_app'] = in_app
+                new_frames.append(new_frame)
+
+        if raw_frame.get('in_app') is None:
+            raw_frame['in_app'] = in_app
+        return new_frames, [raw_frame], errors
 
 
 class NativePlugin(Plugin2):
diff --git a/src/sentry/lang/native/symbolizer.py b/src/sentry/lang/native/symbolizer.py
index c3a27c3dda..ac17de9361 100644
--- a/src/sentry/lang/native/symbolizer.py
+++ b/src/sentry/lang/native/symbolizer.py
@@ -130,6 +130,9 @@ def make_symbolizer(project, binary_images, referenced_images=None):
 
 
 class Symbolizer(object):
+    """This symbolizer dispatches to both symsynd and the system symbols
+    we have in the database and reports errors slightly differently.
+    """
 
     def __init__(self, project, binary_images, referenced_images=None,
                  is_debug_build=None):
@@ -148,6 +151,13 @@ class Symbolizer(object):
             self._image_references[img_addr] = img
         self._image_addresses.sort()
 
+    def find_best_instruction(self, frame, meta=None):
+        """Finds the best instruction for a given frame."""
+        if not self.images:
+            return parse_addr(frame['instruction_addr'])
+        return self.symsynd_symbolizer.find_best_instruction(
+            frame['instruction_addr'], meta=meta)
+
     def resolve_missing_vmaddrs(self):
         """When called this changes the vmaddr on all contained images from
         the information in the dsym files (if there is no vmaddr already).
@@ -291,16 +301,8 @@ class Symbolizer(object):
             return [rv]
         return rv
 
-    def symbolize_frame(self, frame, sdk_info=None, meta=None,
-                        symbolize_inlined=False):
-        # We ask the lower level symbolizer from symsynd to find the best
-        # instruction for this frame separately.  This is done because we
-        # need this information going into either the system or app path
-        # and because we are interested in the image.
-        instruction_addr = self.symsynd_symbolizer.find_best_instruction(
-            frame['instruction_addr'], meta=meta)
-
-        img = self.find_image(instruction_addr)
+    def symbolize_frame(self, frame, sdk_info=None, symbolize_inlined=False):
+        img = self.find_image(frame['instruction_addr'])
         if img is None:
             raise SymbolicationFailed(
                 type=EventError.NATIVE_UNKNOWN_IMAGE
@@ -316,7 +318,7 @@ class Symbolizer(object):
         return self.symbolize_app_frame(frame, img, symbolize_inlined)
 
     def symbolize_backtrace(self, backtrace, sdk_info=None):
-        # TODO: kill me
+        # TODO: kill me.  This makes bad results
         rv = []
         errors = []
         idx = -1

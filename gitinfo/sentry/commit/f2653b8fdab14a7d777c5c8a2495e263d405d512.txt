commit f2653b8fdab14a7d777c5c8a2495e263d405d512
Author: Ted Kaemming <ted@kaemming.com>
Date:   Wed Dec 2 13:38:03 2015 -0800

    Use `load_script` for `is_rate_limited` implementation.

diff --git a/src/sentry/quotas/redis.py b/src/sentry/quotas/redis.py
index f3f6f626dc..6c24f871a7 100644
--- a/src/sentry/quotas/redis.py
+++ b/src/sentry/quotas/redis.py
@@ -10,56 +10,16 @@ from __future__ import absolute_import
 import time
 
 from django.conf import settings
-from redis.client import Script
 
 from sentry.exceptions import InvalidConfiguration
 from sentry.quotas.base import Quota, RateLimited, NotRateLimited
-from sentry.utils.redis import make_rb_cluster
-
-
-# Check a collection of quota counters to identify if an item should be rate
-# limited. Values provided as ``KEYS`` specify the keys of the counters to
-# check, and values provided as ``ARGV`` specify the maximum value (quota
-# limit) and expiration time for each key.
-#
-# For example, to check a quota ``foo`` that has a limit of 10 items and
-# expires at the Unix timestamp ``100``, as well as a quota ``bar`` that has a
-# limit of 20 items and should expire at the Unix timestamp ``100``, the
-# ``KEYS`` and ``ARGV`` values would be as follows:
-#
-#   KEYS = {"foo", "bar"}
-#   ARGV = {10, 100, 20, 100}
-#
-# If all checks pass (the item is accepted), the counters for all quotas are
-# incremented. If any checks fail (the item is rejected), the counters for all
-# quotas are unaffected. The result is a Lua table/array (Redis multi bulk
-# reply) that specifies whether or not the item was *rejected* based on the
-# provided limit.
-IS_RATE_LIMITED_SCRIPT = """\
-assert(#KEYS * 2 == #ARGV, "incorrect number of keys and arguments provided")
-
-local results = {}
-local failed = false
-for i=1,#KEYS do
-    local limit = tonumber(ARGV[(i * 2) - 1])
-    local rejected = (redis.call('GET', KEYS[i]) or 0) + 1 > limit
-    if rejected then
-        failed = true
-    end
-    results[i] = rejected
-end
-
-if not failed then
-    for i=1,#KEYS do
-        redis.call('INCR', KEYS[i])
-        redis.call('EXPIREAT', KEYS[i], ARGV[i * 2])
-    end
-end
-
-return results
-"""
+from sentry.utils.redis import (
+    load_script,
+    make_rb_cluster,
+)
+
 
-is_rate_limited = Script(None, IS_RATE_LIMITED_SCRIPT)
+is_rate_limited = load_script('quotas/is_rate_limited.lua')
 
 
 class RedisQuota(Quota):
@@ -114,7 +74,7 @@ class RedisQuota(Quota):
             args.extend((limit, expiry))
 
         client = self.cluster.get_local_client_for_key(str(project.organization.pk))
-        rejections = is_rate_limited(keys, args, client=client)
+        rejections = is_rate_limited(client, keys, args)
         if any(rejections):
             delay = max(get_next_period_start(interval) - timestamp for (key, limit, interval), rejected in zip(quotas, rejections) if rejected)
             return RateLimited(retry_after=delay)
diff --git a/src/sentry/scripts/quotas/is_rate_limited.lua b/src/sentry/scripts/quotas/is_rate_limited.lua
new file mode 100644
index 0000000000..e4ebcfba28
--- /dev/null
+++ b/src/sentry/scripts/quotas/is_rate_limited.lua
@@ -0,0 +1,39 @@
+-- Check a collection of quota counters to identify if an item should be rate
+-- limited. Values provided as ``KEYS`` specify the keys of the counters to
+-- check, and values provided as ``ARGV`` specify the maximum value (quota
+-- limit) and expiration time for each key.
+--
+-- For example, to check a quota ``foo`` that has a limit of 10 items and
+-- expires at the Unix timestamp ``100``, as well as a quota ``bar`` that has a
+-- limit of 20 items and should expire at the Unix timestamp ``100``, the
+-- ``KEYS`` and ``ARGV`` values would be as follows:
+--
+--   KEYS = {"foo", "bar"}
+--   ARGV = {10, 100, 20, 100}
+--
+-- If all checks pass (the item is accepted), the counters for all quotas are
+-- incremented. If any checks fail (the item is rejected), the counters for all
+-- quotas are unaffected. The result is a Lua table/array (Redis multi bulk
+-- reply) that specifies whether or not the item was *rejected* based on the
+-- provided limit.
+assert(#KEYS * 2 == #ARGV, "incorrect number of keys and arguments provided")
+
+local results = {}
+local failed = false
+for i=1,#KEYS do
+    local limit = tonumber(ARGV[(i * 2) - 1])
+    local rejected = (redis.call('GET', KEYS[i]) or 0) + 1 > limit
+    if rejected then
+        failed = true
+    end
+    results[i] = rejected
+end
+
+if not failed then
+    for i=1,#KEYS do
+        redis.call('INCR', KEYS[i])
+        redis.call('EXPIREAT', KEYS[i], ARGV[i * 2])
+    end
+end
+
+return results
diff --git a/tests/sentry/quotas/redis/tests.py b/tests/sentry/quotas/redis/tests.py
index d5e1f08d93..9f73157584 100644
--- a/tests/sentry/quotas/redis/tests.py
+++ b/tests/sentry/quotas/redis/tests.py
@@ -6,13 +6,10 @@ import time
 
 import mock
 from exam import fixture, patcher
-from redis.client import (
-    Script,
-    StrictRedis,
-)
+from redis.client import StrictRedis
 
 from sentry.quotas.redis import (
-    IS_RATE_LIMITED_SCRIPT,
+    is_rate_limited,
     RedisQuota,
 )
 from sentry.testutils import TestCase
@@ -22,19 +19,18 @@ def test_is_rate_limited_script():
     now = int(time.time())
 
     client = StrictRedis(db=9)
-    script = Script(client, IS_RATE_LIMITED_SCRIPT)
 
     # The item should not be rate limited by either key.
-    assert map(bool, script(('foo', 'bar'), (1, now + 60, 2, now + 120))) == [False, False]
+    assert map(bool, is_rate_limited(client, ('foo', 'bar'), (1, now + 60, 2, now + 120))) == [False, False]
 
     # The item should be rate limited by the first key (1).
-    assert map(bool, script(('foo', 'bar'), (1, now + 60, 2, now + 120))) == [True, False]
+    assert map(bool, is_rate_limited(client, ('foo', 'bar'), (1, now + 60, 2, now + 120))) == [True, False]
 
     # The item should still be rate limited by the first key (1), but *not*
     # rate limited by the second key (2) even though this is the third time
     # we've checked the quotas. This ensures items that are rejected by a lower
     # quota don't affect unrelated items that share a parent quota.
-    assert map(bool, script(('foo', 'bar'), (1, now + 60, 2, now + 120))) == [True, False]
+    assert map(bool, is_rate_limited(client, ('foo', 'bar'), (1, now + 60, 2, now + 120))) == [True, False]
 
     assert client.get('foo') == '1'
     assert 59 <= client.ttl('foo') <= 60

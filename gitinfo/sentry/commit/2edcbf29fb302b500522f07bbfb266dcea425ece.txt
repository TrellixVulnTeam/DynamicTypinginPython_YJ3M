commit 2edcbf29fb302b500522f07bbfb266dcea425ece
Author: David Cramer <dcramer@gmail.com>
Date:   Tue Jun 28 12:32:26 2016 -0700

    Simplify group details mutation code to utilize bulk endpoint

diff --git a/src/sentry/api/endpoints/group_details.py b/src/sentry/api/endpoints/group_details.py
index 8327b5fcf1..e839fd30df 100644
--- a/src/sentry/api/endpoints/group_details.py
+++ b/src/sentry/api/endpoints/group_details.py
@@ -6,16 +6,15 @@ from rest_framework import serializers
 from rest_framework.response import Response
 
 from sentry.app import tsdb
+from sentry.api import client
 from sentry.api.base import DocSection
 from sentry.api.bases import GroupEndpoint
 from sentry.api.fields import UserField
 from sentry.api.serializers import serialize
-from sentry.db.models.query import create_or_update
 from sentry.constants import STATUS_CHOICES
 from sentry.models import (
-    Activity, Group, GroupAssignee, GroupBookmark, GroupSeen, GroupSnooze,
-    GroupSubscription, GroupStatus, GroupTagKey, GroupTagValue, Release,
-    UserReport
+    Activity, Group, GroupAssignee, GroupSeen, GroupSubscription, GroupStatus,
+    GroupTagKey, GroupTagValue, Release, UserReport
 )
 from sentry.plugins import plugins
 from sentry.utils.safe import safe_execute
@@ -241,117 +240,18 @@ class GroupDetailsEndpoint(GroupEndpoint):
         :param boolean isSubscribed:
         :auth: required
         """
-        # TODO(dcramer): we should move all these mutations to the bulk endpoint
-        # and simply have this method internally call the other
+        # TODO(dcramer): we need to implement assignedTo in the bulk mutation
+        # endpoint
         serializer = GroupSerializer(data=request.DATA, partial=True)
         if not serializer.is_valid():
             return Response(serializer.errors, status=400)
 
         result = serializer.object
-        subscribe_user = False
         acting_user = request.user if request.user.is_authenticated() else None
 
-        # TODO(dcramer): we should allow assignment to anyone who has membership
-        # even if that membership is not SSO linked
         if result.get('assignedTo') and not group.project.member_set.filter(user=result['assignedTo']).exists():
             return Response({'detail': 'Cannot assign to non-team member'}, status=400)
 
-        if result.get('status') == 'resolved':
-            now = timezone.now()
-
-            group.resolved_at = now
-            group.status = GroupStatus.RESOLVED
-
-            happened = Group.objects.filter(
-                id=group.id,
-            ).exclude(status=GroupStatus.RESOLVED).update(
-                status=GroupStatus.RESOLVED,
-                resolved_at=now,
-            )
-
-            if happened:
-                create_or_update(
-                    Activity,
-                    project=group.project,
-                    group=group,
-                    type=Activity.SET_RESOLVED,
-                    user=acting_user,
-                )
-            subscribe_user = True
-
-        elif result.get('status'):
-            new_status = STATUS_CHOICES[result['status']]
-
-            if new_status == GroupStatus.MUTED:
-                if result.get('snoozeDuration'):
-                    snooze_until = timezone.now() + timedelta(
-                        minutes=int(result['snoozeDuration']),
-                    )
-                    GroupSnooze.objects.create_or_update(
-                        group=group,
-                        values={
-                            'until': snooze_until,
-                        }
-                    )
-                    result['snoozeUntil'] = snooze_until
-                else:
-                    GroupSnooze.objects.filter(
-                        group=group,
-                    ).delete()
-                    result['snoozeUntil'] = None
-
-            group.update(status=new_status)
-            subscribe_user = True
-
-        if result.get('hasSeen') and group.project.member_set.filter(user=request.user).exists():
-            instance, created = create_or_update(
-                GroupSeen,
-                group=group,
-                user=request.user,
-                project=group.project,
-                values={
-                    'last_seen': timezone.now(),
-                }
-            )
-        elif result.get('hasSeen') is False:
-            GroupSeen.objects.filter(
-                group=group,
-                user=request.user,
-            ).delete()
-
-        if result.get('isBookmarked'):
-            GroupBookmark.objects.get_or_create(
-                project=group.project,
-                group=group,
-                user=request.user,
-            )
-            subscribe_user = True
-
-        elif result.get('isBookmarked') is False:
-            GroupBookmark.objects.filter(
-                group=group,
-                user=request.user,
-            ).delete()
-
-        if result.get('isSubscribed'):
-            GroupSubscription.objects.create_or_update(
-                project=group.project,
-                group=group,
-                user=request.user,
-                values={
-                    'is_active': True,
-                }
-            )
-        elif result.get('isSubscribed') is False:
-            GroupSubscription.objects.create_or_update(
-                project=group.project,
-                group=group,
-                user=request.user,
-                values={
-                    'is_active': False,
-                }
-            )
-
         if 'assignedTo' in result:
             if result['assignedTo']:
                 GroupAssignee.objects.assign(group, result['assignedTo'],
@@ -365,13 +265,28 @@ class GroupDetailsEndpoint(GroupEndpoint):
             else:
                 GroupAssignee.objects.deassign(group, acting_user)
 
-        if subscribe_user:
-            GroupSubscription.objects.subscribe(
-                group=group,
-                user=request.user,
-            )
+        response = client.put(
+            path='/projects/{}/{}/issues/'.format(
+                group.project.organization.slug,
+                group.project.slug,
+            ),
+            params={
+                'id': group.id,
+            },
+            data=request.DATA,
+            request=request,
+        )
+
+        # we need to fetch the object against as the bulk mutation endpoint
+        # only returns a delta, and object mutation returns a complete updated
+        # entity.
+        # TODO(dcramer): we should update the API and have this be an explicit
+        # flag (or remove it entirely) so that delta's are the primary response
+        # for mutation.
+        group = Group.objects.get(id=group.id)
 
-        return Response(serialize(group, request.user))
+        return Response(serialize(group, request.user),
+                        status=response.status_code)
 
     @attach_scenarios([delete_aggregate_scenario])
     def delete(self, request, group):

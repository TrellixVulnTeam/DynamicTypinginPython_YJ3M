commit 88f64e94847ad1e3d8bb07a1ef27be8658877e30
Author: Matt Robenolt <matt@ydekproductions.com>
Date:   Wed Jun 22 13:44:25 2016 -0700

    Pass positional_args correctly from stdlib log handler to structlog (#3564)

diff --git a/src/sentry/logging/handlers.py b/src/sentry/logging/handlers.py
index d777c5b98c..aab9c5f433 100644
--- a/src/sentry/logging/handlers.py
+++ b/src/sentry/logging/handlers.py
@@ -11,8 +11,6 @@ import logging
 from structlog import get_logger
 from structlog.processors import _json_fallback_handler
 
-logger = get_logger()
-
 _default_encoder = JSONEncoder(
     separators=(',', ':'),
     ignore_nan=True,
@@ -32,19 +30,29 @@ class JSONRenderer(object):
 
 
 class StructLogHandler(logging.StreamHandler):
-    def emit(self, record):
+    def emit(self, record, logger=get_logger()):
         kwargs = {
             'name': record.name,
         }
         if record.exc_info:
             kwargs['exc_info'] = record.exc_info
+
         if record.args:
-            kwargs['positional_args'] = record.args
+            # record.args inside of LogRecord.__init__ gets unrolled
+            # if it's the shape `({},)`, a single item dictionary.
+            # so we need to check for this, and re-wrap it because
+            # down the line of structlog, it's expected to be this
+            # original shape.
+            if isinstance(record.args, (tuple, list)):
+                kwargs['positional_args'] = record.args
+            else:
+                kwargs['positional_args'] = (record.args,)
 
         # HACK(JTCunning): Calling structlog.log instead of the corresponding level
         # methods steps on the toes of django client loggers and their testing components.
-        log = getattr(logger, logging.getLevelName(record.levelno).lower(), None)
-        if log:
-            log(record.msg, **kwargs)
-        else:
+        try:
+            log = getattr(logger, logging.getLevelName(record.levelno).lower())
+        except AttributeError:
             super(StructLogHandler, self).emit(record)
+        else:
+            log(record.msg, **kwargs)
diff --git a/tests/sentry/logging/test_handler.py b/tests/sentry/logging/test_handler.py
new file mode 100644
index 0000000000..69afc94be7
--- /dev/null
+++ b/tests/sentry/logging/test_handler.py
@@ -0,0 +1,59 @@
+import pytest
+import logging
+import mock
+
+from sentry.logging.handlers import StructLogHandler
+
+
+@pytest.fixture
+def handler():
+    return StructLogHandler()
+
+
+@pytest.fixture
+def logger():
+    return mock.MagicMock()
+
+
+def make_logrecord(**extra):
+    kwargs = dict(
+        name='name',
+        level=logging.INFO,
+        pathname='pathname',
+        lineno=10,
+        msg='msg',
+        args=None,
+        exc_info=None,
+    )
+    kwargs.update(extra or {})
+    return logging.LogRecord(**kwargs)
+
+
+def test_emit_basic(handler, logger):
+    record = make_logrecord()
+    handler.emit(record, logger=logger)
+    logger.info.assert_called_once_with('msg', name='name')
+
+
+def test_emit_with_args(handler, logger):
+    record = make_logrecord(
+        msg='%s',
+        args=(1,),
+    )
+    handler.emit(record, logger=logger)
+    logger.info.assert_called_once_with('%s', name='name', positional_args=(1,))
+
+
+def test_emit_with_dict_arg(handler, logger):
+    record = make_logrecord(
+        msg='%s',
+        args=({'a': 1},),
+    )
+    handler.emit(record, logger=logger)
+    logger.info.assert_called_once_with('%s', name='name', positional_args=({'a': 1},))
+
+
+def test_emit_with_exc_info(handler, logger):
+    record = make_logrecord(exc_info={'a': 1})
+    handler.emit(record, logger=logger)
+    logger.info.assert_called_once_with('msg', name='name', exc_info={'a': 1})

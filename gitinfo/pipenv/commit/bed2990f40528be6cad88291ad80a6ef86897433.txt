commit bed2990f40528be6cad88291ad80a6ef86897433
Author: Dan Ryan <dan@danryan.co>
Date:   Sat Aug 25 13:00:21 2018 -0400

    Update vistir vendoring
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/vendor/vistir/LICENSE b/pipenv/vendor/vistir/LICENSE
new file mode 100644
index 00000000..e1a278e7
--- /dev/null
+++ b/pipenv/vendor/vistir/LICENSE
@@ -0,0 +1,13 @@
+Copyright (c) 2018, Dan Ryan <dan@danryan.co>
+
+Permission to use, copy, modify, and distribute this software for any
+purpose with or without fee is hereby granted, provided that the above
+copyright notice and this permission notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
diff --git a/pipenv/vendor/vistir/__init__.py b/pipenv/vendor/vistir/__init__.py
index c7f776d5..eeb8344c 100644
--- a/pipenv/vendor/vistir/__init__.py
+++ b/pipenv/vendor/vistir/__init__.py
@@ -13,7 +13,7 @@ from .misc import load_path, partialclass, run, shell_escape
 from .path import mkdir_p, rmtree
 
 
-__version__ = '0.1.0'
+__version__ = '0.1.4'
 
 
 __all__ = [
diff --git a/pipenv/vendor/vistir/compat.py b/pipenv/vendor/vistir/compat.py
index 454cc3c8..1f1b7a96 100644
--- a/pipenv/vendor/vistir/compat.py
+++ b/pipenv/vendor/vistir/compat.py
@@ -3,11 +3,12 @@ from __future__ import absolute_import, unicode_literals
 
 import os
 import sys
-
-import six
 import warnings
+
 from tempfile import mkdtemp
 
+import six
+
 
 __all__ = [
     "Path",
diff --git a/pipenv/vendor/vistir/misc.py b/pipenv/vendor/vistir/misc.py
index 5d7855aa..82bdf5ed 100644
--- a/pipenv/vendor/vistir/misc.py
+++ b/pipenv/vendor/vistir/misc.py
@@ -8,13 +8,17 @@ import subprocess
 import sys
 
 from collections import OrderedDict
+from functools import partial
+
+import six
 
 from .cmdparse import Script
-from .compat import Path, partialmethod
+from .compat import Path, fs_str, partialmethod
 
 
 __all__ = [
-    "shell_escape", "unnest", "dedup", "run", "load_path", "partialclass"
+    "shell_escape", "unnest", "dedup", "run", "load_path", "partialclass", "to_text",
+    "to_bytes", "locale_encoding"
 ]
 
 
@@ -63,18 +67,57 @@ def dedup(iterable):
     return iter(OrderedDict.fromkeys(iterable))
 
 
-def run(cmd):
+def _spawn_subprocess(script, env={}):
+    from distutils.spawn import find_executable
+    command = find_executable(script.command)
+    options = {
+        "env": env,
+        "universal_newlines": True,
+        "stdout": subprocess.PIPE,
+        "stderr": subprocess.PIPE,
+    }
+    # Command not found, maybe this is a shell built-in?
+    if not command:  # Try to use CreateProcess directly if possible.
+        return subprocess.Popen(script.cmdify(), shell=True, **options)
+    # Try to use CreateProcess directly if possible. Specifically catch
+    # Windows error 193 "Command is not a valid Win32 application" to handle
+    # a "command" that is non-executable. See pypa/pipenv#2727.
+    try:
+        return subprocess.Popen([command] + script.args, **options)
+    except WindowsError as e:
+        if e.winerror != 193:
+            raise
+    # Try shell mode to use Windows's file association for file launch.
+    return subprocess.Popen(script.cmdify(), shell=True, **options)
+
+
+def run(cmd, env={}, return_object=False):
     """Use `subprocess.Popen` to get the output of a command and decode it.
 
     :param list cmd: A list representing the command you want to run.
+    :param dict env: Additional environment settings to pass through to the subprocess.
+    :param bool return_object: When True, returns the whole subprocess instance
     :returns: A 2-tuple of (output, error)
     """
-    encoding = locale.getdefaultlocale()[1] or "utf-8"
-    c = subprocess.Popen(
-        cmd, env=os.environ.copy(), stdout=subprocess.PIPE, stderr=subprocess.PIPE
-    )
+    if six.PY2:
+        fs_encode = partial(to_bytes, encoding=locale_encoding)
+        _env = {fs_encode(k): fs_encode(v) for k, v in os.environ.items()}
+        for key, val in env.items():
+            _env[fs_encode(key)] = fs_encode(val)
+    else:
+        _env = {k: fs_str(v) for k, v in os.environ.items()}
+    if six.PY2:
+        if isinstance(cmd, six.string_types):
+            cmd = cmd.encode("utf-8")
+        elif isinstance(cmd, (list, tuple)):
+            cmd = [c.encode("utf-8") for c in cmd]
+    if not isinstance(cmd, Script):
+        cmd = Script.parse(cmd)
+    c = _spawn_subprocess(cmd, env=_env)
     out, err = c.communicate()
-    return out.decode(encoding).strip(), err.decode(encoding).strip()
+    if not return_object:
+        return out.strip(), err.strip()
+    return c
 
 
 def load_path(python):
@@ -132,3 +175,84 @@ def partialclass(cls, *args, **kwargs):
     except (AttributeError, ValueError):
         pass
     return type_
+
+
+# Borrowed from django -- force bytes and decode -- see link for details:
+# https://github.com/django/django/blob/fc6b90b/django/utils/encoding.py#L112
+def to_bytes(string, encoding="utf-8", errors="ignore"):
+    """Force a value to bytes.
+
+    :param string: Some input that can be converted to a bytes.
+    :type string: str or bytes unicode or a memoryview subclass
+    :param encoding: The encoding to use for conversions, defaults to "utf-8"
+    :param encoding: str, optional
+    :return: Corresponding byte representation (for use in filesystem operations)
+    :rtype: bytes
+    """
+
+    if not errors:
+        if encoding.lower() == "utf-8":
+            errors = "surrogateescape" if six.PY3 else "ignore"
+        else:
+            errors = "strict"
+    if isinstance(string, bytes):
+        if encoding.lower() == "utf-8":
+            return string
+        else:
+            return string.decode('utf-8').encode(encoding, errors)
+    elif isinstance(string, memoryview):
+        return bytes(string)
+    elif not isinstance(string, six.string_types):
+        try:
+            if six.PY3:
+                return six.text_type(string).encode(encoding, errors)
+            else:
+                return bytes(string)
+        except UnicodeEncodeError:
+            if isinstance(string, Exception):
+                return b' '.join(to_bytes(arg, encoding, errors) for arg in string)
+            return six.text_type(string).encode(encoding, errors)
+    else:
+        return string.encode(encoding, errors)
+
+
+def to_text(string, encoding="utf-8", errors=None):
+    """Force a value to a text-type.
+
+    :param string: Some input that can be converted to a unicode representation.
+    :type string: str or bytes unicode
+    :param encoding: The encoding to use for conversions, defaults to "utf-8"
+    :param encoding: str, optional
+    :return: The unicode representation of the string
+    :rtype: str
+    """
+
+    if not errors:
+        if encoding.lower() == "utf-8":
+            errors = "surrogateescape" if six.PY3 else "ignore"
+        else:
+            errors = "strict"
+    if issubclass(type(string), six.text_type):
+        return string
+    try:
+        if not issubclass(type(string), six.string_types):
+            if six.PY3:
+                if isinstance(string, bytes):
+                    string = six.text_type(string, encoding, errors)
+                else:
+                    string = six.text_type(string)
+            elif hasattr(string, '__unicode__'):
+                string = six.text_type(string)
+            else:
+                string = six.text_type(bytes(string), encoding, errors)
+        else:
+            string = string.decode(encoding, errors)
+    except UnicodeDecodeError as e:
+            string = ' '.join(to_text(arg, encoding, errors) for arg in string)
+    return string
+
+
+try:
+    locale_encoding = locale.getdefaultencoding()[1] or 'ascii'
+except Exception:
+    locale_encoding = 'ascii'
diff --git a/pipenv/vendor/vistir/path.py b/pipenv/vendor/vistir/path.py
index 85790244..166282e8 100644
--- a/pipenv/vendor/vistir/path.py
+++ b/pipenv/vendor/vistir/path.py
@@ -1,7 +1,9 @@
 # -*- coding=utf-8 -*-
 from __future__ import absolute_import, unicode_literals
 
+import atexit
 import errno
+import functools
 import os
 import posixpath
 import shutil
@@ -10,10 +12,11 @@ import warnings
 
 import six
 
-from six.moves.urllib import request as urllib_request
 from six.moves import urllib_parse
+from six.moves.urllib import request as urllib_request
 
-from .compat import Path, _fs_encoding
+from .compat import Path, _fs_encoding, TemporaryDirectory
+from .misc import locale_encoding, to_bytes, to_text
 
 
 __all__ = [
@@ -24,6 +27,8 @@ __all__ = [
     "is_readonly_path",
     "is_valid_url",
     "mkdir_p",
+    "ensure_mkdir_p",
+    "create_tracked_tempdir",
     "path_to_url",
     "rmtree",
     "safe_expandvars",
@@ -33,31 +38,33 @@ __all__ = [
 ]
 
 
-def _decode_path(path):
-    if not isinstance(path, six.text_type):
-        try:
-            return path.decode(_fs_encoding, 'ignore')
-        except (UnicodeError, LookupError):
-            return path.decode('utf-8', 'ignore')
+def unicode_path(path):
+    # Paths are supposed to be represented as unicode here
+    if six.PY2 and not isinstance(path, six.text_type):
+        return path.decode(_fs_encoding)
     return path
 
 
-def _encode_path(path):
-    """Transform the provided path to a text encoding."""
-    if not isinstance(path, six.string_types + (six.binary_type,)):
-        try:
-            path = getattr(path, "__fspath__")
-        except AttributeError:
-            try:
-                path = getattr(path, "as_posix")
-            except AttributeError:
-                raise RuntimeError("Failed encoding path, unknown object type: %r" % path)
-            else:
-                path()
-        else:
-            path = path()
-    path = Path(_decode_path(path))
-    return _decode_path(path.as_posix())
+def native_path(path):
+    if six.PY2 and not isinstance(path, bytes):
+        return path.encode(_fs_encoding)
+    return path
+
+
+# once again thank you django...
+# https://github.com/django/django/blob/fc6b90b/django/utils/_os.py
+if six.PY3 or os.name == 'nt':
+    abspathu = os.path.abspath
+else:
+    def abspathu(path):
+        """
+        Version of os.path.abspath that uses the unicode representation
+        of the current working directory, thus avoiding a UnicodeDecodeError
+        in join when the cwd has non-ASCII characters.
+        """
+        if not os.path.isabs(path):
+            path = os.path.join(os.getcwdu(), path)
+        return os.path.normpath(path)
 
 
 def normalize_drive(path):
@@ -75,7 +82,7 @@ def normalize_drive(path):
     if drive.islower() and len(drive) == 2 and drive[1] == ":":
         return "{}{}".format(drive.upper(), tail)
 
-    return path
+    return to_text(path, encoding="utf-8")
 
 
 def path_to_url(path):
@@ -91,8 +98,9 @@ def path_to_url(path):
 
     if not path:
         return path
-    path = _encode_path(path)
-    return Path(normalize_drive(os.path.abspath(path))).as_uri()
+    path = to_bytes(path, encoding="utf-8")
+    normalized_path = to_text(normalize_drive(os.path.abspath(path)), encoding="utf-8")
+    return to_text(Path(normalized_path).as_uri(), encoding="utf-8")
 
 
 def url_to_path(url):
@@ -107,7 +115,7 @@ def url_to_path(url):
         netloc = "\\\\" + netloc
 
     path = urllib_request.url2pathname(netloc + path)
-    return path
+    return to_bytes(path, encoding="utf-8")
 
 
 def is_valid_url(url):
@@ -127,6 +135,7 @@ def is_file_url(url):
             url = getattr(url, "url")
         except AttributeError:
             raise ValueError("Cannot parse url from unknown type: {0!r}".format(url))
+    url = to_text(url, encoding="utf-8")
     return urllib_parse.urlparse(url.lower()).scheme == "file"
 
 
@@ -135,13 +144,13 @@ def is_readonly_path(fn):
 
     Permissions check is `bool(path.stat & stat.S_IREAD)` or `not os.access(path, os.W_OK)`
     """
-    fn = _encode_path(fn)
+    fn = to_bytes(fn, encoding="utf-8")
     if os.path.exists(fn):
         return bool(os.stat(fn).st_mode & stat.S_IREAD) and not os.access(fn, os.W_OK)
     return False
 
 
-def mkdir_p(newdir):
+def mkdir_p(newdir, mode=0o777):
     """Recursively creates the target directory and all of its parents if they do not
     already exist.  Fails silently if they do.
 
@@ -149,6 +158,7 @@ def mkdir_p(newdir):
     :raises: OSError if a file is encountered along the way
     """
     # http://code.activestate.com/recipes/82465-a-friendly-mkdir/
+    newdir = abspathu(to_bytes(newdir, "utf-8"))
     if os.path.exists(newdir):
         if not os.path.isdir(newdir):
             raise OSError(
@@ -159,10 +169,51 @@ def mkdir_p(newdir):
         pass
     else:
         head, tail = os.path.split(newdir)
-        if head and not os.path.isdir(head):
-            mkdir_p(head)
-        if tail and not os.path.isdir(newdir):
-            os.mkdir(newdir)
+        # Make sure the tail doesn't point to the asame place as the head
+        tail_and_head_match = os.path.relpath(tail, start=os.path.basename(head)) == "."
+        if tail and not tail_and_head_match and not os.path.isdir(newdir):
+            target = os.path.join(head, tail)
+            if os.path.exists(target) and os.path.isfile(target):
+                raise OSError(
+                   "A file with the same name as the desired dir, '{0}', already exists.".format(
+                        newdir
+                    )
+                )
+            os.makedirs(os.path.join(head, tail), mode)
+
+
+def ensure_mkdir_p(mode=0o777):
+    """Decorator to ensure `mkdir_p` is called to the function's return value.
+    """
+    def decorator(f):
+
+        @functools.wraps(f)
+        def decorated(*args, **kwargs):
+            path = f(*args, **kwargs)
+            mkdir_p(path, mode=mode)
+            return path
+
+        return decorated
+
+    return decorator
+
+
+TRACKED_TEMPORARY_DIRECTORIES = []
+
+
+def create_tracked_tempdir(*args, **kwargs):
+    """Create a tracked temporary directory.
+
+    This uses `TemporaryDirectory`, but does not remove the directory when
+    the return value goes out of scope, instead registers a handler to cleanup
+    on program exit.
+
+    The return value is the path to the created directory.
+    """
+    tempdir = TemporaryDirectory(*args, **kwargs)
+    TRACKED_TEMPORARY_DIRECTORIES.append(tempdir)
+    atexit.register(tempdir.cleanup)
+    return tempdir.name
 
 
 def set_write_bit(fn):
@@ -172,8 +223,8 @@ def set_write_bit(fn):
     :param str fn: The target filename or path
     """
 
-    fn = _encode_path(fn)
-    if isinstance(fn, six.string_types) and not os.path.exists(fn):
+    fn = to_bytes(fn, encoding=locale_encoding)
+    if not os.path.exists(fn):
         return
     os.chmod(fn, stat.S_IWRITE | stat.S_IWUSR | stat.S_IRUSR)
 
@@ -192,7 +243,7 @@ def rmtree(directory, ignore_errors=False):
        Setting `ignore_errors=True` may cause this to silently fail to delete the path
     """
 
-    directory = _encode_path(directory)
+    directory = to_bytes(directory, encoding=locale_encoding)
     shutil.rmtree(
         directory, ignore_errors=ignore_errors, onerror=handle_remove_readonly
     )
@@ -218,6 +269,7 @@ def handle_remove_readonly(func, path, exc):
     )
     # split the initial exception out into its type, exception, and traceback
     exc_type, exc_exception, exc_tb = exc
+    path = to_bytes(path)
     if is_readonly_path(path):
         # Apply write permission and call original function
         set_write_bit(path)
@@ -225,11 +277,18 @@ def handle_remove_readonly(func, path, exc):
             func(path)
         except (OSError, IOError) as e:
             if e.errno in [errno.EACCES, errno.EPERM]:
-                warnings.warn(default_warning_message.format(path), ResourceWarning)
+                warnings.warn(
+                    default_warning_message.format(
+                        to_text(path, encoding=locale_encoding)
+                    ), ResourceWarning
+                )
                 return
 
     if exc_exception.errno in [errno.EACCES, errno.EPERM]:
-        warnings.warn(default_warning_message.format(path), ResourceWarning)
+        warnings.warn(
+            default_warning_message.format(to_text(path)),
+            ResourceWarning
+        )
         return
 
     raise
@@ -276,7 +335,7 @@ def check_for_unc_path(path):
         return False
 
 
-def get_converted_relative_path(path, relative_to=os.curdir):
+def get_converted_relative_path(path, relative_to=None):
     """Convert `path` to be relative.
 
     Given a vague relative path, return the path relative to the given
@@ -298,8 +357,13 @@ def get_converted_relative_path(path, relative_to=os.curdir):
     '.'
     """
 
-    path = _encode_path(path)
-    relative_to = _encode_path(relative_to)
+    if not relative_to:
+        relative_to = os.getcwdu() if six.PY2 else os.getcwd()
+    if six.PY2:
+        path = to_bytes(path, encoding="utf-8")
+    else:
+        path = to_text(path, encoding="utf-8")
+    relative_to = to_text(relative_to, encoding="utf-8")
     start_path = Path(relative_to)
     try:
         start = start_path.resolve()
@@ -319,9 +383,9 @@ def get_converted_relative_path(path, relative_to=os.curdir):
     if check_for_unc_path(path):
         raise ValueError("The path argument does not currently accept UNC paths")
 
-    relpath_s = _encode_path(posixpath.normpath(path.as_posix()))
-    if not (relpath_s == "." or relpath_s.startswith("./")):
-        relpath_s = posixpath.join(".", relpath_s)
+    relpath_s = to_text(posixpath.normpath(path.as_posix()))
+    if not (relpath_s == u"." or relpath_s.startswith(u"./")):
+        relpath_s = posixpath.join(u".", relpath_s)
     return relpath_s
 
 

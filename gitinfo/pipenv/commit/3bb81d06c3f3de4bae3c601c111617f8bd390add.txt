commit 3bb81d06c3f3de4bae3c601c111617f8bd390add
Author: Dan Ryan <dan@danryan.co>
Date:   Sun Jun 10 13:14:06 2018 -0400

    Update requirementslib ahead of #2158
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/vendor/requirementslib/__init__.py b/pipenv/vendor/requirementslib/__init__.py
index 7e238573..52550ba2 100644
--- a/pipenv/vendor/requirementslib/__init__.py
+++ b/pipenv/vendor/requirementslib/__init__.py
@@ -1,4 +1,6 @@
 # -*- coding=utf-8 -*-
-__version__ = "0.1.1"
+__version__ = "0.2.0"
 
-from .requirements import Requirement
+
+from .exceptions import RequirementError
+from .models import Requirement, Lockfile, Pipfile
diff --git a/pipenv/vendor/requirementslib/_compat.py b/pipenv/vendor/requirementslib/_compat.py
index 1556d72b..b4584d8e 100644
--- a/pipenv/vendor/requirementslib/_compat.py
+++ b/pipenv/vendor/requirementslib/_compat.py
@@ -1,5 +1,6 @@
 # -*- coding=utf-8 -*-
 import importlib
+import six
 
 # Use these imports as compatibility imports
 try:
@@ -12,6 +13,14 @@ try:
 except ImportError:
     from urlparse import urlparse, unquote
 
+if six.PY2:
+
+    class FileNotFoundError(IOError):
+        pass
+else:
+    class FileNotFoundError(FileNotFoundError):
+        pass
+
 
 def do_import(module_path, subimport=None, old_path=None):
     internal = "pip._internal.{0}".format(module_path)
diff --git a/pipenv/vendor/requirementslib/exceptions.py b/pipenv/vendor/requirementslib/exceptions.py
new file mode 100644
index 00000000..88738774
--- /dev/null
+++ b/pipenv/vendor/requirementslib/exceptions.py
@@ -0,0 +1,6 @@
+# -*- coding: utf-8 -*-
+from __future__ import absolute_import
+
+
+class RequirementError(Exception):
+    pass
diff --git a/pipenv/vendor/requirementslib/models/__init__.py b/pipenv/vendor/requirementslib/models/__init__.py
new file mode 100644
index 00000000..7ca16516
--- /dev/null
+++ b/pipenv/vendor/requirementslib/models/__init__.py
@@ -0,0 +1,10 @@
+# -*- coding: utf-8 -*-
+from __future__ import absolute_import
+
+
+__all__ = ["Requirement", "Lockfile", "Pipfile", "RequirementError"]
+
+
+from .requirements import Requirement
+from .lockfile import Lockfile
+from .pipfile import Pipfile
diff --git a/pipenv/vendor/requirementslib/models/baserequirement.py b/pipenv/vendor/requirementslib/models/baserequirement.py
new file mode 100644
index 00000000..0cac987a
--- /dev/null
+++ b/pipenv/vendor/requirementslib/models/baserequirement.py
@@ -0,0 +1,30 @@
+# -*- coding: utf-8 -*-
+from __future__ import absolute_import
+import abc
+import attr
+import six
+
+
+@six.add_metaclass(abc.ABCMeta)
+class BaseRequirement:
+    @classmethod
+    def from_line(cls, line):
+        """Returns a requirement from a requirements.txt or pip-compatible line"""
+        raise NotImplementedError
+
+    @abc.abstractmethod
+    def line_part(self):
+        """Returns the current requirement as a pip-compatible line"""
+
+    @classmethod
+    def from_pipfile(cls, name, pipfile):
+        """Returns a requirement from a pipfile entry"""
+        raise NotImplementedError
+
+    @abc.abstractmethod
+    def pipfile_part(self):
+        """Returns the current requirement as a pipfile entry"""
+
+    @classmethod
+    def attr_fields(cls):
+        return [field.name for field in attr.fields(cls)]
diff --git a/pipenv/vendor/requirementslib/models/lockfile.py b/pipenv/vendor/requirementslib/models/lockfile.py
new file mode 100644
index 00000000..599def41
--- /dev/null
+++ b/pipenv/vendor/requirementslib/models/lockfile.py
@@ -0,0 +1,56 @@
+# -*- coding: utf-8 -*-
+from __future__ import absolute_import
+import attr
+import json
+from .requirements import Requirement
+from .utils import (
+    optional_instance_of,
+)
+from .._compat import Path, FileNotFoundError
+
+
+@attr.s
+class Lockfile(object):
+    dev_requirements = attr.ib(default=list)
+    requirements = attr.ib(default=list)
+    path = attr.ib(default=None, validator=optional_instance_of(Path))
+    pipfile_hash = attr.ib(default=None)
+
+    @classmethod
+    def create(cls, project_path, lockfile_name="Pipfile.lock"):
+        """Create a new lockfile instance
+
+        :param project_path: Path to the project root
+        :type project_path: str or :class:`~pathlib.Path`
+        :returns: List[:class:`~requirementslib.Requirement`] objects
+        """
+
+        if not isinstance(project_path, Path):
+            project_path = Path(project_path)
+        lockfile_path = project_path / lockfile_name
+        requirements = []
+        dev_requirements = []
+        if not lockfile_path.exists():
+            raise FileNotFoundError("No such lockfile: %s" % lockfile_path)
+
+        lockfile = json.loads(lockfile_path.read_text(encoding="utf-8"))
+        for k in lockfile["develop"].keys():
+            dev_requirements.append(Requirement.from_pipfile(k, lockfile["develop"][k]))
+        for k in lockfile["default"].keys():
+            requirements.append(Requirement.from_pipfile(k, lockfile["default"][k]))
+        return cls(
+            path=lockfile_path,
+            requirements=requirements,
+            dev_requirements=dev_requirements,
+        )
+
+    def as_requirements(self, include_hashes=False, dev=False):
+        """Returns a list of requirements in pip-style format"""
+        lines = []
+        section = self.dev_requirements if dev else self.requirements
+        for req in section:
+            r = req.as_line()
+            if not include_hashes:
+                r = r.split("--hash", 1)[0]
+            lines.append(r.strip())
+        return lines
diff --git a/pipenv/vendor/requirementslib/models/markers.py b/pipenv/vendor/requirementslib/models/markers.py
new file mode 100644
index 00000000..9e22ce1b
--- /dev/null
+++ b/pipenv/vendor/requirementslib/models/markers.py
@@ -0,0 +1,90 @@
+# -*- coding: utf-8 -*-
+import attr
+import six
+from packaging.markers import Marker, InvalidMarker
+from .baserequirement import BaseRequirement
+from .utils import validate_markers, filter_none
+from ..exceptions import RequirementError
+
+
+@attr.s
+class PipenvMarkers(BaseRequirement):
+    """System-level requirements - see PEP508 for more detail"""
+
+    os_name = attr.ib(default=None, validator=attr.validators.optional(validate_markers))
+    sys_platform = attr.ib(default=None, validator=attr.validators.optional(validate_markers))
+    platform_machine = attr.ib(
+        default=None, validator=attr.validators.optional(validate_markers)
+    )
+    platform_python_implementation = attr.ib(
+        default=None, validator=attr.validators.optional(validate_markers)
+    )
+    platform_release = attr.ib(
+        default=None, validator=attr.validators.optional(validate_markers)
+    )
+    platform_system = attr.ib(
+        default=None, validator=attr.validators.optional(validate_markers)
+    )
+    platform_version = attr.ib(
+        default=None, validator=attr.validators.optional(validate_markers)
+    )
+    python_version = attr.ib(
+        default=None, validator=attr.validators.optional(validate_markers)
+    )
+    python_full_version = attr.ib(
+        default=None, validator=attr.validators.optional(validate_markers)
+    )
+    implementation_name = attr.ib(
+        default=None, validator=attr.validators.optional(validate_markers)
+    )
+    implementation_version = attr.ib(
+        default=None, validator=attr.validators.optional(validate_markers)
+    )
+
+    @property
+    def line_part(self):
+        return " and ".join(
+            [
+                "{0} {1}".format(k, v)
+                for k, v in attr.asdict(self, filter=filter_none).items()
+            ]
+        )
+
+    @property
+    def pipfile_part(self):
+        return {"markers": self.as_line}
+
+    @classmethod
+    def make_marker(cls, marker_string):
+        try:
+            marker = Marker(marker_string)
+        except InvalidMarker:
+            raise RequirementError("Invalid requirement: Invalid marker %r" % marker_string)
+        marker_dict = {}
+        for m in marker._markers:
+            if isinstance(m, six.string_types):
+                continue
+            var, op, val = m
+            if var.value in cls.attr_fields():
+                marker_dict[var.value] = '{0} "{1}"'.format(op, val)
+        return marker_dict
+
+    @classmethod
+    def from_line(cls, line):
+        if ";" in line:
+            line = line.rsplit(";", 1)[1].strip()
+        marker_dict = cls.make_marker(line)
+        return cls(**marker_dict)
+
+    @classmethod
+    def from_pipfile(cls, name, pipfile):
+        found_keys = [k for k in pipfile.keys() if k in cls.attr_fields()]
+        marker_strings = ["{0} {1}".format(k, pipfile[k]) for k in found_keys]
+        if pipfile.get("markers"):
+            marker_strings.append(pipfile.get("markers"))
+        markers = {}
+        for marker in marker_strings:
+            marker_dict = cls.make_marker(marker)
+            if marker_dict:
+                markers.update(marker_dict)
+        return cls(**markers)
diff --git a/pipenv/vendor/requirementslib/models/pipfile.py b/pipenv/vendor/requirementslib/models/pipfile.py
new file mode 100644
index 00000000..4c910ead
--- /dev/null
+++ b/pipenv/vendor/requirementslib/models/pipfile.py
@@ -0,0 +1,191 @@
+# -*- coding: utf-8 -*-
+import attr
+import contoml
+import os
+import toml
+from requirementslib._vendor import pipfile
+from .requirements import Requirement
+from .utils import optional_instance_of, filter_none
+from .._compat import Path, FileNotFoundError
+from ..exceptions import RequirementError
+
+
+@attr.s
+class Source(object):
+    #: URL to PyPI instance
+    url = attr.ib(default="pypi")
+    #: If False, skip SSL checks
+    verify_ssl = attr.ib(
+        default=True, validator=optional_instance_of(bool)
+    )
+    #: human name to refer to this source (can be referenced in packages or dev-packages)
+    name = attr.ib(default="")
+
+    def get_dict(self):
+        return attr.asdict(self)
+
+    @property
+    def expanded(self):
+        source_dict = attr.asdict(self).copy()
+        source_dict['url'] = os.path.expandvars(source_dict.get('url'))
+        return source_dict
+
+
+@attr.s
+class Section(object):
+    ALLOWED_NAMES = ('packages', 'dev-packages',)
+    #: Name of the pipfile section
+    name = attr.ib(default="packages")
+    #: A list of requirements that are contained by the section
+    requirements = attr.ib(default=list)
+
+    def get_dict(self):
+        _dict = {}
+        for req in self.requirements:
+            _dict.update(req.as_pipfile())
+        return {self.name: _dict}
+
+    @property
+    def vcs_requirements(self):
+        return [req for req in self.requirements if req.is_vcs]
+
+    @property
+    def editable_requirements(self):
+        return [req for req in self.requirements if req.editable]
+
+
+@attr.s
+class RequiresSection(object):
+    python_version = attr.ib(default=None)
+    python_full_version = attr.ib(default=None)
+
+    def get_dict(self):
+        requires = attr.asdict(self, filter=filter_none)
+        if not requires:
+            return {}
+        return {'requires': requires}
+
+
+@attr.s
+class PipenvSection(object):
+    allow_prereleases = attr.ib(default=False)
+
+    def get_dict(self):
+        if self.allow_prereleases:
+            return {'pipenv': attr.asdict(self)}
+        return {}
+
+
+@attr.s
+class Pipfile(object):
+    #: Path to the pipfile
+    path = attr.ib(default=None, converter=Path, validator=optional_instance_of(Path))
+    #: Sources listed in the pipfile
+    sources = attr.ib(default=attr.Factory(list))
+    #: Sections contained by the pipfile
+    sections = attr.ib(default=attr.Factory(list))
+    #: Scripts found in the pipfile
+    scripts = attr.ib(default=attr.Factory(dict))
+    #: This section stores information about what python version is required
+    requires = attr.ib(default=attr.Factory(RequiresSection))
+    #: This section stores information about pipenv such as prerelease requirements
+    pipenv = attr.ib(default=attr.Factory(PipenvSection))
+    #: This is the sha256 hash of the pipfile (without environment interpolation)
+    pipfile_hash = attr.ib()
+
+    @pipfile_hash.default
+    def get_hash(self):
+        p = pipfile.load(self.path.as_posix(), inject_env=False)
+        return p.hash
+
+    @property
+    def requires_python(self):
+        return self.requires.requires_python
+
+    @property
+    def allow_prereleases(self):
+        return self.pipenv.allow_prereleases
+
+    def get_sources(self):
+        """Return a dictionary with a list of dictionaries of pipfile sources"""
+        _dict = {}
+        for src in self.sources:
+            _dict.update(src.get_dict())
+        return {'source': _dict} if _dict else {}
+
+    def get_sections(self):
+        """Return a dictionary with both pipfile sections and requirements"""
+        _dict = {}
+        for section in self.sections:
+            _dict.update(section.get_dict())
+        return _dict
+
+    def get_pipenv(self):
+        pipenv_dict = self.pipenv.get_dict()
+        if pipenv_dict:
+            return pipenv_dict
+
+    def get_requires(self):
+        req_dict = self.requires.get_dict()
+        return req_dict if req_dict else {}
+
+    def get_dict(self):
+        _dict = attr.asdict(self, recurse=False)
+        for k in ['path', 'pipfile_hash', 'sources', 'sections', 'requires', 'pipenv']:
+            if k in _dict:
+                _dict.pop(k)
+        return _dict
+
+    def dump(self, to_dict=False):
+        """Dumps the pipfile to a toml string
+        """
+
+        _dict = self.get_sources()
+        _dict.update(self.get_sections())
+        _dict.update(self.get_dict())
+        _dict.update(self.get_pipenv())
+        _dict.update(self.get_requires())
+        if to_dict:
+            return _dict
+        return contoml.dumps(_dict)
+
+    @classmethod
+    def load(cls, path):
+        if not isinstance(path, Path):
+            path = Path(path)
+        pipfile_path = path / 'Pipfile'
+        if not path.exists():
+            raise FileNotFoundError("%s is not a valid project path!" % path)
+        elif not pipfile_path.exists() or not pipfile_path.is_file():
+            raise RequirementError("%s is not a valid Pipfile" % pipfile_path)
+        pipfile_dict = toml.load(pipfile_path.as_posix())
+        sections = [cls.get_section(pipfile_dict, s) for s in Section.ALLOWED_NAMES]
+        pipenv = pipfile_dict.get('pipenv', {})
+        requires = pipfile_dict.get('requires', {})
+        creation_dict = {
+            'path': pipfile_path,
+            'sources': [Source(**src) for src in pipfile_dict.get('source', [])],
+            'sections': sections,
+            'scripts': pipfile_dict.get('scripts')
+        }
+        if requires:
+            creation_dict['requires'] = RequiresSection(**requires)
+        if pipenv:
+            creation_dict['pipenv'] = PipenvSection(**pipenv)
+        return cls(**creation_dict)
+
+    @staticmethod
+    def get_section(pf_dict, section):
+        """Get section objects from a pipfile dictionary
+
+        :param pf_dict: A toml loaded pipfile dictionary
+        :type pf_dict: dict
+        :returns: Section objects
+        """
+        sect = pf_dict.get(section)
+        requirements = []
+        if section not in Section.ALLOWED_NAMES:
+            raise ValueError("Not a valid pipfile section name: %s" % section)
+        for name, pf_entry in sect.items():
+            requirements.append(Requirement.from_pipfile(name, pf_entry))
+        return Section(name=section, requirements=requirements)
diff --git a/pipenv/vendor/requirementslib/models/requirements.py b/pipenv/vendor/requirementslib/models/requirements.py
new file mode 100644
index 00000000..fd8c1a56
--- /dev/null
+++ b/pipenv/vendor/requirementslib/models/requirements.py
@@ -0,0 +1,666 @@
+# -*- coding: utf-8 -*-
+from __future__ import absolute_import
+import attr
+import hashlib
+import os
+import requirements
+from first import first
+from pkg_resources import RequirementParseError
+from .baserequirement import BaseRequirement
+from .markers import PipenvMarkers
+from .utils import (
+    HASH_STRING,
+    extras_to_string,
+    get_version,
+    specs_to_string,
+    validate_specifiers,
+    validate_path,
+    validate_vcs,
+    build_vcs_link,
+    add_ssh_scheme_to_git_uri,
+    strip_ssh_from_git_uri,
+    split_vcs_method_from_uri,
+    filter_none,
+    optional_instance_of,
+    split_markers_from_line,
+)
+from .._compat import (
+    Link,
+    path_to_url,
+    _strip_extras,
+    InstallRequirement,
+    Path,
+    urlparse,
+    unquote,
+    Wheel,
+    FileNotFoundError,
+)
+from ..exceptions import RequirementError
+from ..utils import (
+    VCS_LIST,
+    is_installable_file,
+    is_vcs,
+    is_valid_url,
+    pep423_name,
+    get_converted_relative_path,
+    multi_split,
+)
+
+
+@attr.s
+class NamedRequirement(BaseRequirement):
+    name = attr.ib()
+    version = attr.ib(validator=attr.validators.optional(validate_specifiers))
+    req = attr.ib()
+
+    @req.default
+    def get_requirement(self):
+        try:
+            req = first(requirements.parse("{0}{1}".format(self.name, self.version)))
+        except RequirementParseError:
+            raise RequirementError(
+                "Error parsing requirement: %s%s" % (self.name, self.version)
+            )
+        return req
+
+    @classmethod
+    def from_line(cls, line):
+        req = first(requirements.parse(line))
+        specifiers = None
+        if req.specifier:
+            specifiers = specs_to_string(req.specs)
+        return cls(name=req.name, version=specifiers, req=req)
+
+    @classmethod
+    def from_pipfile(cls, name, pipfile):
+        creation_args = {}
+        if hasattr(pipfile, "keys"):
+            creation_args = {k: v for k, v in pipfile.items() if k in cls.attr_fields()}
+        creation_args["name"] = name
+        version = get_version(pipfile)
+        creation_args["version"] = version
+        creation_args["req"] = first(requirements.parse("{0}{1}".format(name, version)))
+        return cls(**creation_args)
+
+    @property
+    def line_part(self):
+        return "{self.name}".format(self=self)
+
+    @property
+    def pipfile_part(self):
+        pipfile_dict = attr.asdict(self, filter=filter_none).copy()
+        if "version" not in pipfile_dict:
+            pipfile_dict["version"] = "*"
+        name = pipfile_dict.pop("name")
+        return {name: pipfile_dict}
+
+
+@attr.s
+class FileRequirement(BaseRequirement):
+    """File requirements for tar.gz installable files or wheels or setup.py
+    containing directories."""
+
+    setup_path = attr.ib(default=None)
+    path = attr.ib(default=None, validator=attr.validators.optional(validate_path))
+    # : path to hit - without any of the VCS prefixes (like git+ / http+ / etc)
+    editable = attr.ib(default=None)
+    uri = attr.ib()
+    link = attr.ib()
+    name = attr.ib()
+    req = attr.ib()
+    _has_hashed_name = False
+    _uri_scheme = None
+
+    @uri.default
+    def get_uri(self):
+        if self.path and not self.uri:
+            self._uri_scheme = "path"
+            self.uri = path_to_url(os.path.abspath(self.path))
+
+    @name.default
+    def get_name(self):
+        loc = self.path or self.uri
+        if loc:
+            self._uri_scheme = "path" if self.path else "uri"
+        name = None
+        if self.link and self.link.egg_fragment:
+            return self.link.egg_fragment
+        elif self.link and self.link.is_wheel:
+            return os.path.basename(Wheel(self.link.path).name)
+        if self._uri_scheme != "uri" and self.path and self.setup_path:
+            from distutils.core import run_setup
+
+            try:
+                dist = run_setup(self.setup_path.as_posix(), stop_after="init")
+                name = dist.get_name()
+            except (FileNotFoundError, IOError) as e:
+                dist = None
+            except (NameError, RuntimeError) as e:
+                from ._compat import InstallRequirement, make_abstract_dist
+
+                try:
+                    if not isinstance(Path, self.path):
+                        _path = Path(self.path)
+                    else:
+                        _path = self.path
+                    if self.editable:
+                        _ireq = InstallRequirement.from_editable(_path.as_uri())
+                    else:
+                        _ireq = InstallRequirement.from_line(_path.as_posix())
+                    dist = make_abstract_dist(_ireq).get_dist()
+                    name = dist.project_name
+                except (TypeError, ValueError, AttributeError) as e:
+                    dist = None
+        hashed_loc = hashlib.sha256(loc.encode("utf-8")).hexdigest()
+        hashed_name = hashed_loc[-7:]
+        if not name or name == "UNKNOWN":
+            self._has_hashed_name = True
+            name = hashed_name
+        if self.link and not self._has_hashed_name:
+            self.link = Link("{0}#egg={1}".format(self.link.url, name))
+        return name
+
+    @link.default
+    def get_link(self):
+        target = "{0}".format(self.uri)
+        if hasattr(self, "name"):
+            target = "{0}#egg={1}".format(target, self.name)
+        link = Link(target)
+        return link
+
+    @req.default
+    def get_requirement(self):
+        prefix = "-e " if self.editable else ""
+        line = "{0}{1}".format(prefix, self.link.url)
+        req = first(requirements.parse(line))
+        if self.path and self.link and self.link.scheme.startswith("file"):
+            req.local_file = True
+            req.path = self.path
+            req.uri = None
+            self._uri_scheme = "file"
+        if self.editable:
+            req.editable = True
+        req.link = self.link
+        return req
+
+    @property
+    def is_remote_artifact(self):
+        return (
+            any(
+                self.link.scheme.startswith(scheme)
+                for scheme in ("http", "https", "ftp", "ftps", "uri")
+            )
+            and (self.link.is_artifact or self.link.is_wheel)
+            and not self.req.editable
+        )
+
+    @classmethod
+    def from_line(cls, line):
+        line = line.strip('"').strip("'")
+        link = None
+        path = None
+        editable = line.startswith("-e ")
+        line = line.split(" ", 1)[1] if editable else line
+        setup_path = None
+        if not any([is_installable_file(line), is_valid_url(line)]):
+            raise RequirementError(
+                "Supplied requirement is not installable: {0!r}".format(line)
+            )
+
+        if is_valid_url(line) and not is_installable_file(line):
+            link = Link(line)
+        else:
+            if is_valid_url(line):
+                parsed = urlparse(line)
+                link = Link("{0}".format(line))
+                if parsed.scheme == "file":
+                    path = Path(parsed.path)
+                    setup_path = path / "setup.py"
+                    path = path.absolute().as_posix()
+                    if get_converted_relative_path(path) == ".":
+                        path = "."
+                    line = path
+            else:
+                _path = Path(line)
+                setup_path = _path / "setup.py"
+                link = Link(unquote(_path.absolute().as_uri()))
+                if _path.is_absolute() or _path.as_posix() == ".":
+                    path = _path.as_posix()
+                else:
+                    path = get_converted_relative_path(line)
+        arg_dict = {
+            "path": path,
+            "uri": link.url_without_fragment,
+            "link": link,
+            "editable": editable,
+            "setup_path": setup_path,
+        }
+        if link.egg_fragment:
+            arg_dict["name"] = link.egg_fragment
+        created = cls(**arg_dict)
+        return created
+
+    @classmethod
+    def from_pipfile(cls, name, pipfile):
+        uri_key = first((k for k in ["uri", "file"] if k in pipfile))
+        uri = pipfile.get(uri_key, pipfile.get("path"))
+        if not uri_key:
+            abs_path = os.path.abspath(uri)
+            uri = path_to_url(abs_path) if os.path.exists(abs_path) else None
+        link = Link(unquote(uri)) if uri else None
+        arg_dict = {
+            "name": name,
+            "path": pipfile.get("path"),
+            "uri": unquote(link.url_without_fragment if link else uri),
+            "editable": pipfile.get("editable"),
+            "link": link,
+        }
+        return cls(**arg_dict)
+
+    @property
+    def line_part(self):
+        seed = self.path or self.link.url or self.uri
+        # add egg fragments to remote artifacts (valid urls only)
+        if not self._has_hashed_name and self.is_remote_artifact:
+            seed += "#egg={0}".format(self.name)
+        editable = "-e " if self.editable else ""
+        return "{0}{1}".format(editable, seed)
+
+    @property
+    def pipfile_part(self):
+        pipfile_dict = {k: v for k, v in attr.asdict(self, filter=filter_none).items()}
+        name = pipfile_dict.pop("name")
+        if "setup_path" in pipfile_dict:
+            pipfile_dict.pop("setup_path")
+        req = self.req
+        # For local paths and remote installable artifacts (zipfiles, etc)
+        if self.is_remote_artifact:
+            dict_key = "file"
+            # Look for uri first because file is a uri format and this is designed
+            # to make sure we add file keys to the pipfile as a replacement of uri
+            target_keys = [k for k in pipfile_dict.keys() if k in ["uri", "path"]]
+            pipfile_dict[dict_key] = pipfile_dict.pop(first(target_keys))
+            if len(target_keys) > 1:
+                _ = pipfile_dict.pop(target_keys[1])
+        else:
+            collisions = [key for key in ["path", "uri", "file"] if key in pipfile_dict]
+            if len(collisions) > 1:
+                for k in collisions[1:]:
+                    pipfile_dict.pop(k)
+        return {name: pipfile_dict}
+
+
+@attr.s
+class VCSRequirement(FileRequirement):
+    editable = attr.ib(default=None)
+    uri = attr.ib(default=None)
+    path = attr.ib(default=None, validator=attr.validators.optional(validate_path))
+    vcs = attr.ib(validator=attr.validators.optional(validate_vcs), default=None)
+    # : vcs reference name (branch / commit / tag)
+    ref = attr.ib(default=None)
+    subdirectory = attr.ib(default=None)
+    name = attr.ib()
+    link = attr.ib()
+    req = attr.ib()
+    _INCLUDE_FIELDS = (
+        "editable",
+        "uri",
+        "path",
+        "vcs",
+        "ref",
+        "subdirectory",
+        "name",
+        "link",
+        "req",
+    )
+
+    @link.default
+    def get_link(self):
+        return build_vcs_link(
+            self.vcs,
+            add_ssh_scheme_to_git_uri(self.uri),
+            name=self.name,
+            ref=self.ref,
+            subdirectory=self.subdirectory,
+        )
+
+    @name.default
+    def get_name(self):
+        return (
+            self.link.egg_fragment or self.req.name
+            if self.req
+            else super(VCSRequirement, self).get_name()
+        )
+
+    @property
+    def vcs_uri(self):
+        uri = self.uri
+        if not any(uri.startswith("{0}+".format(vcs)) for vcs in VCS_LIST):
+            uri = "{0}+{1}".format(self.vcs, uri)
+        return uri
+
+    @req.default
+    def get_requirement(self):
+        prefix = "-e " if self.editable else ""
+        line = "{0}{1}".format(prefix, self.link.url)
+        req = first(requirements.parse(line))
+        if self.path and self.link and self.link.scheme.startswith("file"):
+            req.local_file = True
+            req.path = self.path
+        if self.editable:
+            req.editable = True
+        req.link = self.link
+        if (
+            self.uri != self.link.url
+            and "git+ssh://" in self.link.url
+            and "git+git@" in self.uri
+        ):
+            req.line = strip_ssh_from_git_uri(req.line)
+            req.uri = strip_ssh_from_git_uri(req.uri)
+        if not req.name:
+            raise ValueError(
+                "pipenv requires an #egg fragment for version controlled "
+                "dependencies. Please install remote dependency "
+                "in the form {0}#egg=<package-name>.".format(req.uri)
+            )
+        if self.vcs and not req.vcs:
+            req.vcs = self.vcs
+        if self.ref and not req.revision:
+            req.revision = self.ref
+        return req
+
+    @classmethod
+    def from_pipfile(cls, name, pipfile):
+        creation_args = {}
+        pipfile_keys = [
+            k
+            for k in ("ref", "vcs", "subdirectory", "path", "editable", "file", "uri")
+            + VCS_LIST
+            if k in pipfile
+        ]
+        for key in pipfile_keys:
+            if key in VCS_LIST:
+                creation_args["vcs"] = key
+                composed_uri = add_ssh_scheme_to_git_uri(
+                    "{0}+{1}".format(key, pipfile.get(key))
+                ).lstrip("{0}+".format(key))
+                is_url = is_valid_url(pipfile.get(key)) or is_valid_url(composed_uri)
+                target_key = "uri" if is_url else "path"
+                creation_args[target_key] = pipfile.get(key)
+            else:
+                creation_args[key] = pipfile.get(key)
+        creation_args["name"] = name
+        return cls(**creation_args)
+
+    @classmethod
+    def from_line(cls, line, editable=None):
+        path = None
+        if line.startswith("-e "):
+            editable = True
+            line = line.split(" ", 1)[1]
+        vcs_line = add_ssh_scheme_to_git_uri(line)
+        vcs_method, vcs_location = split_vcs_method_from_uri(vcs_line)
+        if not is_valid_url(vcs_location) and os.path.exists(vcs_location):
+            path = get_converted_relative_path(vcs_location)
+            vcs_location = path_to_url(os.path.abspath(vcs_location))
+        link = Link(vcs_line)
+        name = link.egg_fragment
+        uri = link.url_without_fragment
+        if "git+git@" in line:
+            uri = strip_ssh_from_git_uri(uri)
+        subdirectory = link.subdirectory_fragment
+        ref = None
+        if "@" in link.show_url:
+            uri, ref = uri.rsplit("@", 1)
+        return cls(
+            name=name,
+            ref=ref,
+            vcs=vcs_method,
+            subdirectory=subdirectory,
+            link=link,
+            path=path,
+            editable=editable,
+            uri=uri,
+        )
+
+    @property
+    def line_part(self):
+        """requirements.txt compatible line part sans-extras"""
+        if self.req:
+            return self.req.line
+        base = "{0}".format(self.link)
+        if self.editable:
+            base = "-e {0}".format(base)
+        return base
+
+    @staticmethod
+    def _choose_vcs_source(pipfile):
+        src_keys = [k for k in pipfile.keys() if k in ["path", "uri", "file"]]
+        if src_keys:
+            chosen_key = first(src_keys)
+            vcs_type = pipfile.pop("vcs")
+            _, pipfile_url = split_vcs_method_from_uri(pipfile.get(chosen_key))
+            pipfile[vcs_type] = pipfile_url
+            for removed in src_keys:
+                pipfile.pop(removed)
+        return pipfile
+
+    @property
+    def pipfile_part(self):
+        pipfile_dict = attr.asdict(self, filter=filter_none).copy()
+        if "vcs" in pipfile_dict:
+            pipfile_dict = self._choose_vcs_source(pipfile_dict)
+        name = pipfile_dict.pop("name")
+        return {name: pipfile_dict}
+
+
+@attr.s
+class Requirement(object):
+    name = attr.ib()
+    vcs = attr.ib(default=None, validator=attr.validators.optional(validate_vcs))
+    req = attr.ib(default=None, validator=optional_instance_of(BaseRequirement))
+    markers = attr.ib(default=None)
+    specifiers = attr.ib(validator=attr.validators.optional(validate_specifiers))
+    index = attr.ib(default=None)
+    editable = attr.ib(default=None)
+    hashes = attr.ib(default=attr.Factory(list), converter=list)
+    extras = attr.ib(default=attr.Factory(list))
+    _ireq = None
+    _INCLUDE_FIELDS = ("name", "markers", "index", "editable", "hashes", "extras")
+
+    @name.default
+    def get_name(self):
+        return self.req.name
+
+    @property
+    def requirement(self):
+        return self.req.req
+
+    @property
+    def hashes_as_pip(self):
+        if self.hashes:
+            return "".join([HASH_STRING.format(h) for h in self.hashes])
+
+        return ""
+
+    @property
+    def markers_as_pip(self):
+        if self.markers:
+            return "; {0}".format(self.markers)
+
+        return ""
+
+    @property
+    def extras_as_pip(self):
+        if self.extras:
+            return "[{0}]".format(",".join(self.extras))
+
+        return ""
+
+    @specifiers.default
+    def get_specifiers(self):
+        if self.req and self.req.req.specifier:
+            return specs_to_string(self.req.req.specs)
+        return
+
+    @property
+    def is_vcs(self):
+        return isinstance(self.req, VCSRequirement)
+
+    @property
+    def is_file_or_url(self):
+        return isinstance(self.req, FileRequirement)
+
+    @property
+    def is_named(self):
+        return isinstance(self.req, NamedRequirement)
+
+    @property
+    def normalized_name(self):
+        return pep423_name(self.name)
+
+    @classmethod
+    def from_line(cls, line):
+        hashes = None
+        if "--hash=" in line:
+            hashes = line.split(" --hash=")
+            line, hashes = hashes[0], hashes[1:]
+        editable = line.startswith("-e ")
+        line, markers = split_markers_from_line(line)
+        line, extras = _strip_extras(line)
+        stripped_line = line.split(" ", 1)[1] if editable else line
+        vcs = None
+        # Installable local files and installable non-vcs urls are handled
+        # as files, generally speaking
+        if (
+            is_installable_file(stripped_line)
+            or is_installable_file(line)
+            or (is_valid_url(stripped_line) and not is_vcs(stripped_line))
+        ):
+            r = FileRequirement.from_line(line)
+        elif is_vcs(stripped_line):
+            r = VCSRequirement.from_line(line)
+            vcs = r.vcs
+        else:
+            name = multi_split(stripped_line, "!=<>~")[0]
+            if not extras:
+                name, extras = _strip_extras(name)
+            r = NamedRequirement.from_line(stripped_line)
+        if extras:
+            extras = first(
+                requirements.parse("fakepkg{0}".format(extras_to_string(extras)))
+            ).extras
+            r.req.extras = extras
+        if markers:
+            r.req.markers = markers
+        args = {
+            "name": r.name,
+            "vcs": vcs,
+            "req": r,
+            "markers": markers,
+            "editable": editable,
+        }
+        if extras:
+            args["extras"] = extras
+        if hashes:
+            args["hashes"] = hashes
+        return cls(**args)
+
+    @classmethod
+    def from_pipfile(cls, name, pipfile):
+        _pipfile = {}
+        if hasattr(pipfile, "keys"):
+            _pipfile = dict(pipfile).copy()
+        _pipfile["version"] = get_version(pipfile)
+        vcs = first([vcs for vcs in VCS_LIST if vcs in _pipfile])
+        if vcs:
+            _pipfile["vcs"] = vcs
+            r = VCSRequirement.from_pipfile(name, pipfile)
+        elif any(key in _pipfile for key in ["path", "file", "uri"]):
+            r = FileRequirement.from_pipfile(name, pipfile)
+        else:
+            r = NamedRequirement.from_pipfile(name, pipfile)
+        args = {
+            "name": r.name,
+            "vcs": vcs,
+            "req": r,
+            "markers": PipenvMarkers.from_pipfile(name, _pipfile).line_part,
+            "extras": _pipfile.get("extras"),
+            "editable": _pipfile.get("editable", False),
+            "index": _pipfile.get("index"),
+        }
+        if any(key in _pipfile for key in ["hash", "hashes"]):
+            args["hashes"] = _pipfile.get("hashes", [pipfile.get("hash")])
+        return cls(**args)
+
+    def as_line(self, sources=None):
+        """Format this requirement as a line in requirements.txt.
+
+        If `sources` provided, it should be an sequence of mappings, containing
+        all possible sources to be used for this requirement.
+
+        If `sources` is omitted or falsy, no index information will be included
+        in the requirement line.
+        """
+        line = "{0}{1}{2}{3}{4}".format(
+            self.req.line_part,
+            self.extras_as_pip,
+            self.specifiers if self.specifiers else "",
+            self.markers_as_pip,
+            self.hashes_as_pip,
+        )
+        if sources and not (self.requirement.local_file or self.vcs):
+            from .utils import prepare_pip_source_args
+
+            if self.index:
+                sources = [s for s in sources if s.get("name") == self.index]
+            index_string = " ".join(prepare_pip_source_args(sources))
+            line = "{0} {1}".format(line, index_string)
+        return line
+
+    def as_pipfile(self):
+        good_keys = (
+            "hashes",
+            "extras",
+            "markers",
+            "editable",
+            "version",
+            "index",
+        ) + VCS_LIST
+        req_dict = {
+            k: v
+            for k, v in attr.asdict(self, recurse=False, filter=filter_none).items()
+            if k in good_keys
+        }
+        name = self.name
+        base_dict = {
+            k: v
+            for k, v in self.req.pipfile_part[name].items()
+            if k not in ["req", "link"]
+        }
+        base_dict.update(req_dict)
+        conflicting_keys = ("file", "path", "uri")
+        if "file" in base_dict and any(k in base_dict for k in conflicting_keys[1:]):
+            conflicts = [k for k in (conflicting_keys[1:],) if k in base_dict]
+            for k in conflicts:
+                base_dict.pop(k)
+        if "hashes" in base_dict and len(base_dict["hashes"]) == 1:
+            base_dict["hash"] = base_dict.pop("hashes")[0]
+        if len(base_dict.keys()) == 1 and "version" in base_dict:
+            base_dict = base_dict.get("version")
+        return {name: base_dict}
+
+    @property
+    def pipfile_entry(self):
+        return self.as_pipfile().copy().popitem()
+
+    @property
+    def ireq(self):
+        if not self._ireq:
+            ireq_line = self.as_line()
+            if ireq_line.startswith("-e "):
+                ireq_line = ireq_line[len("-e "):]
+                self._ireq = InstallRequirement.from_editable(ireq_line)
+            else:
+                self._ireq = InstallRequirement.from_line(ireq_line)
+        return self._ireq
diff --git a/pipenv/vendor/requirementslib/models/utils.py b/pipenv/vendor/requirementslib/models/utils.py
new file mode 100644
index 00000000..2336bffc
--- /dev/null
+++ b/pipenv/vendor/requirementslib/models/utils.py
@@ -0,0 +1,144 @@
+# -*- coding: utf-8 -*-
+from __future__ import absolute_import
+import os
+import six
+from attr import validators
+from first import first
+from packaging.markers import Marker, InvalidMarker
+from packaging.specifiers import SpecifierSet, InvalidSpecifier
+from .._compat import Link
+from ..utils import (
+    SCHEME_LIST,
+    VCS_LIST,
+    is_star,
+)
+
+
+HASH_STRING = " --hash={0}"
+
+
+def filter_none(k, v):
+    if v:
+        return True
+    return False
+
+
+def optional_instance_of(cls):
+    return validators.optional(validators.instance_of(cls))
+
+
+def extras_to_string(extras):
+    """Turn a list of extras into a string"""
+    if isinstance(extras, six.string_types):
+        if extras.startswith("["):
+            return extras
+
+        else:
+            extras = [extras]
+    return "[{0}]".format(",".join(extras))
+
+
+def specs_to_string(specs):
+    """Turn a list of specifier tuples into a string"""
+    if specs:
+        if isinstance(specs, six.string_types):
+            return specs
+        return ",".join(["".join(spec) for spec in specs])
+    return ""
+
+
+def build_vcs_link(vcs, uri, name=None, ref=None, subdirectory=None, extras=None):
+    if extras is None:
+        extras = []
+    vcs_start = "{0}+".format(vcs)
+    if not uri.startswith(vcs_start):
+        uri = "{0}{1}".format(vcs_start, uri)
+    uri = add_ssh_scheme_to_git_uri(uri)
+    if ref:
+        uri = "{0}@{1}".format(uri, ref)
+    if name:
+        uri = "{0}#egg={1}".format(uri, name)
+        if extras:
+            extras = extras_to_string(extras)
+            uri = "{0}{1}".format(uri, extras)
+    if subdirectory:
+        uri = "{0}&subdirectory={1}".format(uri, subdirectory)
+    return Link(uri)
+
+
+def get_version(pipfile_entry):
+    if str(pipfile_entry) == "{}" or is_star(pipfile_entry):
+        return ""
+
+    elif hasattr(pipfile_entry, "keys") and "version" in pipfile_entry:
+        if is_star(pipfile_entry.get("version")):
+            return ""
+        return pipfile_entry.get("version", "")
+
+    if isinstance(pipfile_entry, six.string_types):
+        return pipfile_entry
+    return ""
+
+
+def strip_ssh_from_git_uri(uri):
+    """Return git+ssh:// formatted URI to git+git@ format"""
+    if isinstance(uri, six.string_types):
+        uri = uri.replace("git+ssh://", "git+")
+    return uri
+
+
+def add_ssh_scheme_to_git_uri(uri):
+    """Cleans VCS uris from pip format"""
+    if isinstance(uri, six.string_types):
+        # Add scheme for parsing purposes, this is also what pip does
+        if uri.startswith("git+") and "://" not in uri:
+            uri = uri.replace("git+", "git+ssh://")
+    return uri
+
+
+def split_markers_from_line(line):
+    """Split markers from a dependency"""
+    if not any(line.startswith(uri_prefix) for uri_prefix in SCHEME_LIST):
+        marker_sep = ";"
+    else:
+        marker_sep = "; "
+    markers = None
+    if marker_sep in line:
+        line, markers = line.split(marker_sep, 1)
+        markers = markers.strip() if markers else None
+    return line, markers
+
+
+def split_vcs_method_from_uri(uri):
+    """Split a vcs+uri formatted uri into (vcs, uri)"""
+    vcs_start = "{0}+"
+    vcs = first([vcs for vcs in VCS_LIST if uri.startswith(vcs_start.format(vcs))])
+    if vcs:
+        vcs, uri = uri.split("+", 1)
+    return vcs, uri
+
+
+def validate_vcs(instance, attr_, value):
+    if value not in VCS_LIST:
+        raise ValueError("Invalid vcs {0!r}".format(value))
+
+
+def validate_path(instance, attr_, value):
+    if not os.path.exists(value):
+        raise ValueError("Invalid path {0!r}", format(value))
+
+
+def validate_markers(instance, attr_, value):
+    try:
+        Marker("{0}{1}".format(attr_.name, value))
+    except InvalidMarker:
+        raise ValueError("Invalid Marker {0}{1}".format(attr_, value))
+
+
+def validate_specifiers(instance, attr_, value):
+    if value == "":
+        return True
+    try:
+        SpecifierSet(value)
+    except (InvalidMarker, InvalidSpecifier):
+        raise ValueError("Invalid Specifiers {0}".format(value))
diff --git a/pipenv/vendor/requirementslib/utils.py b/pipenv/vendor/requirementslib/utils.py
index e820e22a..a5b15a26 100644
--- a/pipenv/vendor/requirementslib/utils.py
+++ b/pipenv/vendor/requirementslib/utils.py
@@ -19,7 +19,7 @@ SCHEME_LIST = ("http://", "https://", "ftp://", "ftps://", "file://")
 
 
 def setup_logger():
-    logger = logging.getLogger('requirementslib')
+    logger = logging.getLogger("requirementslib")
     loglevel = logging.DEBUG
     handler = logging.StreamHandler()
     handler.setLevel(loglevel)
@@ -33,7 +33,7 @@ log = setup_logger()
 
 def is_vcs(pipfile_entry):
     import requirements
-    from .requirements import _clean_git_uri
+    from .models.utils import add_ssh_scheme_to_git_uri
 
     """Determine if dictionary entry from Pipfile is for a vcs dependency."""
     if hasattr(pipfile_entry, "keys"):
@@ -41,7 +41,7 @@ def is_vcs(pipfile_entry):
 
     elif isinstance(pipfile_entry, six.string_types):
         return bool(
-            requirements.requirement.VCS_REGEX.match(_clean_git_uri(pipfile_entry))
+            requirements.requirement.VCS_REGEX.match(add_ssh_scheme_to_git_uri(pipfile_entry))
         )
 
     return False
@@ -50,7 +50,7 @@ def is_vcs(pipfile_entry):
 def get_converted_relative_path(path, relative_to=os.curdir):
     """Given a vague relative path, return the path relative to the given location"""
     relpath = os.path.relpath(path, start=relative_to)
-    if os.name == 'nt':
+    if os.name == "nt":
         return os.altsep.join([".", relpath])
     return os.path.join(".", relpath)
 
@@ -71,9 +71,8 @@ def is_installable_file(path):
     from ._compat import is_installable_dir, is_archive_file
     from packaging import specifiers
 
-    if (
-        hasattr(path, "keys")
-        and any(key for key in path.keys() if key in ["file", "path"])
+    if hasattr(path, "keys") and any(
+        key for key in path.keys() if key in ["file", "path"]
     ):
         path = urlparse(path["file"]).path if "file" in path else path["path"]
     if not isinstance(path, six.string_types) or path == "*":
@@ -91,7 +90,7 @@ def is_installable_file(path):
             return False
 
     parsed = urlparse(path)
-    if parsed.scheme == 'file':
+    if parsed.scheme == "file":
         path = parsed.path
 
     if not os.path.exists(os.path.abspath(path)):
@@ -129,25 +128,17 @@ def prepare_pip_source_args(sources, pip_args=None):
         pip_args = []
     if sources:
         # Add the source to pip9.
-        pip_args.extend(['-i', sources[0]['url']])
+        pip_args.extend(["-i", sources[0]["url"]])
         # Trust the host if it's not verified.
-        if not sources[0].get('verify_ssl', True):
+        if not sources[0].get("verify_ssl", True):
             pip_args.extend(
-                [
-                    '--trusted-host',
-                    urlparse(sources[0]['url']).netloc.split(':')[0],
-                ]
+                ["--trusted-host", urlparse(sources[0]["url"]).netloc.split(":")[0]]
             )
         # Add additional sources as extra indexes.
         if len(sources) > 1:
             for source in sources[1:]:
-                pip_args.extend(['--extra-index-url', source['url']])
+                pip_args.extend(["--extra-index-url", source["url"]])
                 # Trust the host if it's not verified.
-                if not source.get('verify_ssl', True):
-                    pip_args.extend(
-                        [
-                            '--trusted-host',
-                            urlparse(source['url']).hostname,
-                        ]
-                    )
+                if not source.get("verify_ssl", True):
+                    pip_args.extend(["--trusted-host", urlparse(source["url"]).hostname])
     return pip_args

commit 262293699e583f39e97f8e95e1215f4b257c528b
Author: Chris Miller <chris.miller@quantumblack.com>
Date:   Fri Nov 16 00:26:35 2018 -0500

    Fix race condition when installing 2+ editable non-VCS pkgs at once
    
    This regression was recently introduced, and only affects non-vcs
    packages. The effect of the race is that installations of multiple
    editable non-VCS sourced packages at once may cause some of them to be
    un-importable.
    
    The fix is to make editable package installs Blocking just like VCS
    installs are.

diff --git a/pipenv/core.py b/pipenv/core.py
index f815e5de..f9ffeba3 100644
--- a/pipenv/core.py
+++ b/pipenv/core.py
@@ -731,7 +731,7 @@ def batch_install(deps_list, procs, failed_deps_queue,
                 ignore_hashes=any([ignore_hashes, dep.editable, dep.is_vcs]),
                 allow_global=allow_global,
                 no_deps=False if is_artifact else no_deps,
-                block=any([dep.is_vcs, blocking]),
+                block=any([dep.editable, dep.is_vcs, blocking]),
                 index=index,
                 requirements_dir=requirements_dir,
                 pypi_mirror=pypi_mirror,
diff --git a/tests/integration/test_install_twists.py b/tests/integration/test_install_twists.py
index 055c39b2..6b202d4d 100644
--- a/tests/integration/test_install_twists.py
+++ b/tests/integration/test_install_twists.py
@@ -8,6 +8,7 @@ from pipenv.utils import mkdir_p, temp_environ
 import pytest
 
 from flaky import flaky
+import delegator
 
 
 @pytest.mark.extras
@@ -333,3 +334,55 @@ six = {{path = "./artifacts/{}"}}
         c = p.pipenv("install")
         assert c.return_code == 0
         assert "six" in p.lockfile["default"]
+
+
+@pytest.mark.files
+@pytest.mark.needs_internet
+@pytest.mark.install
+@pytest.mark.run
+def test_multiple_editable_packages_should_not_race(PipenvInstance, pypi, tmpdir, testsroot):
+    """Test for a race condition that can occur when installing multiple 'editable' packages at
+    once, and which causes some of them to not be importable.
+
+    This issue had been fixed for VCS packages already, but not local 'editable' packages.
+
+    So this test locally installs packages from tarballs that have already been committed in
+    the local `pypi` dir to avoid using VCS packages.
+    """
+    pkgs = {
+        "requests-2.19.1": "requests/requests-2.19.1.tar.gz",
+        "flask-0.12.2": "flask/flask-0.12.2.tar.gz",
+        "six-1.11.0": "six/six-1.11.0.tar.gz",
+        "jinja2-2.10": "jinja2/jinja2-2.10.tar.gz",
+    }
+
+    pipfile_string="""
+[packages]
+"""
+    # Unzip tarballs to known location, and update Pipfile template.
+    for pkg_name, file_name in pkgs.items():
+        source_path = os.path.abspath(os.path.join(testsroot, "pypi", file_name))
+        unzip_path = os.path.join(tmpdir, pkg_name)
+
+        import tarfile
+
+        with tarfile.open(source_path, "r:gz") as tgz:
+            tgz.extractall(path=tmpdir)
+
+        pipfile_string += '"{0}" = {{path = "{1}", editable = true}}\n'.format(pkg_name, unzip_path)
+
+    with PipenvInstance(pypi=pypi, chdir=True) as p:
+        with open(p.pipfile_path, 'w') as f:
+            f.write(pipfile_string.strip())
+
+        c = p.pipenv('install')
+        assert c.return_code == 0
+
+        c = p.pipenv('run python -c "import requests"')
+        assert c.return_code == 0
+        c = p.pipenv('run python -c "import flask"')
+        assert c.return_code == 0
+        c = p.pipenv('run python -c "import six"')
+        assert c.return_code == 0
+        c = p.pipenv('run python -c "import jinja2"')
+        assert c.return_code == 0

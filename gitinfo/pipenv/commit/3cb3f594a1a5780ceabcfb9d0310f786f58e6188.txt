commit 3cb3f594a1a5780ceabcfb9d0310f786f58e6188
Author: Dan Ryan <dan@danryan.co>
Date:   Sat Aug 25 13:15:20 2018 -0400

    Update shellingham to 1.24
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/vendor/shellingham/LICENSE b/pipenv/vendor/shellingham/LICENSE
new file mode 100644
index 00000000..b9077766
--- /dev/null
+++ b/pipenv/vendor/shellingham/LICENSE
@@ -0,0 +1,13 @@
+Copyright (c) 2018, Tzu-ping Chung <uranusjr@gmail.com>
+
+Permission to use, copy, modify, and distribute this software for any
+purpose with or without fee is hereby granted, provided that the above
+copyright notice and this permission notice appear in all copies.
+
+THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
diff --git a/pipenv/vendor/shellingham/__init__.py b/pipenv/vendor/shellingham/__init__.py
index 164f4593..a415c4a9 100644
--- a/pipenv/vendor/shellingham/__init__.py
+++ b/pipenv/vendor/shellingham/__init__.py
@@ -4,7 +4,7 @@ import os
 from ._core import ShellDetectionFailure
 
 
-__version__ = '1.2.3.dev0'
+__version__ = '1.2.4'
 
 
 def detect_shell(pid=None, max_depth=6):
diff --git a/pipenv/vendor/shellingham/_consts.py b/pipenv/vendor/shellingham/_consts.py
new file mode 100644
index 00000000..2c788fec
--- /dev/null
+++ b/pipenv/vendor/shellingham/_consts.py
@@ -0,0 +1,7 @@
+SHELL_NAMES = {
+    'sh', 'bash', 'dash',           # Bourne.
+    'csh', 'tcsh',                  # C.
+    'ksh', 'zsh', 'fish',           # Common alternatives.
+    'cmd', 'powershell', 'pwsh',    # Microsoft.
+    'elvish', 'xonsh',              # More exotic.
+}
diff --git a/pipenv/vendor/shellingham/nt.py b/pipenv/vendor/shellingham/nt.py
index 757d47b4..7b3cc6b4 100644
--- a/pipenv/vendor/shellingham/nt.py
+++ b/pipenv/vendor/shellingham/nt.py
@@ -6,7 +6,7 @@ import os
 import sys
 
 from ctypes import (
-    byref, sizeof, windll, Structure, WinError, POINTER,
+    byref, sizeof, windll, Structure, WinError,
     c_size_t, c_char, c_void_p
 )
 from ctypes.wintypes import DWORD, LONG
@@ -15,6 +15,8 @@ from ._core import SHELL_NAMES
 
 
 ERROR_NO_MORE_FILES = 18
+ERROR_INSUFFICIENT_BUFFER = 122
+
 INVALID_HANDLE_VALUE = c_void_p(-1).value
 
 
@@ -39,64 +41,45 @@ class PROCESSENTRY32(Structure):
     ]
 
 
-LPPROCESSENTRY32 = POINTER(PROCESSENTRY32)
+def _iter_process():
+    """Iterate through processes, yielding process ID and properties of each.
 
+    Example usage::
 
-def CreateToolhelp32Snapshot(dwFlags=2, th32ProcessID=0):
-    hSnapshot = windll.kernel32.CreateToolhelp32Snapshot(
-        dwFlags,
-        th32ProcessID
+        >>> for pid, info in _iter_process():
+        ...     print(pid, '->', info)
+        1509 -> {'parent_pid': 1201, 'executable': 'python.exe'}
+    """
+    # TODO: Process32{First,Next} does not return full executable path, only
+    # the name. To get the full path, Module32{First,Next} is needed, but that
+    # does not contain parent process information. We probably need to call
+    # BOTH to build the correct process tree.
+    h_process = windll.kernel32.CreateToolhelp32Snapshot(
+        2,  # dwFlags=TH32CS_SNAPPROCESS (include all processes).
+        0,  # th32ProcessID=0 (the current process).
     )
-    if hSnapshot == INVALID_HANDLE_VALUE:
+    if h_process == INVALID_HANDLE_VALUE:
         raise WinError()
-    return hSnapshot
-
-
-def Process32First(hSnapshot):
     pe = PROCESSENTRY32()
     pe.dwSize = sizeof(PROCESSENTRY32)
-    success = windll.kernel32.Process32First(hSnapshot, byref(pe))
-    if not success:
-        if windll.kernel32.GetLastError() == ERROR_NO_MORE_FILES:
-            return
-        raise WinError()
-    return pe
-
-
-def Process32Next(hSnapshot, pe=None):
-    if pe is None:
-        pe = PROCESSENTRY32()
-    pe.dwSize = sizeof(PROCESSENTRY32)
-    success = windll.kernel32.Process32Next(hSnapshot, byref(pe))
-    if not success:
-        if windll.kernel32.GetLastError() == ERROR_NO_MORE_FILES:
-            return
-        raise WinError()
-    return pe
-
-
-def get_all_processes():
-    """Return a dictionary of properties about all processes.
-    >>> get_all_processes()
-    {
-        1509: {
-            'parent_pid': 1201,
-            'executable': 'C:\\Program\\\\ Files\\Python36\\python.exe'
-        }
-    }
-    """
-    h_process = CreateToolhelp32Snapshot()
-    pids = {}
-    pe = Process32First(h_process)
-    while pe:
-        pids[pe.th32ProcessID] = {
-            'executable': str(pe.szExeFile.decode('utf-8'))
-        }
+    success = windll.kernel32.Process32First(h_process, byref(pe))
+    while True:
+        if not success:
+            errcode = windll.kernel32.GetLastError()
+            if errcode == ERROR_NO_MORE_FILES:
+                # No more processes to iterate through, we're done here.
+                return
+            elif errcode == ERROR_INSUFFICIENT_BUFFER:
+                # This is likely because the file path is longer than the
+                # Windows limit. Just ignore it, it's likely not what we're
+                # looking for. We can fix this when it actually matters. (#8)
+                continue
+            raise WinError()
+        info = {'executable': str(pe.szExeFile.decode('utf-8'))}
         if pe.th32ParentProcessID:
-            pids[pe.th32ProcessID]['parent_pid'] = pe.th32ParentProcessID
-        pe = Process32Next(h_process, pe)
-
-    return pids
+            info['parent_pid'] = pe.th32ParentProcessID
+        yield pe.th32ProcessID, info
+        success = windll.kernel32.Process32Next(h_process, byref(pe))
 
 
 def _get_executable(process_dict):
@@ -114,7 +97,7 @@ def get_shell(pid=None, max_depth=6):
     """
     if not pid:
         pid = os.getpid()
-    processes = get_all_processes()
+    processes = dict(_iter_process())
 
     def check_parent(pid, lvl=0):
         ppid = processes[pid].get('parent_pid')
diff --git a/pipenv/vendor/shellingham/posix.py b/pipenv/vendor/shellingham/posix.py
new file mode 100644
index 00000000..b25dd874
--- /dev/null
+++ b/pipenv/vendor/shellingham/posix.py
@@ -0,0 +1,56 @@
+import collections
+import os
+import shlex
+import subprocess
+import sys
+
+from ._consts import SHELL_NAMES
+
+
+Process = collections.namedtuple('Process', 'args pid ppid')
+
+
+def _get_process_mapping():
+    """Try to look up the process tree via the output of `ps`.
+    """
+    output = subprocess.check_output([
+        'ps', '-ww', '-o', 'pid=', '-o', 'ppid=', '-o', 'args=',
+    ])
+    if not isinstance(output, str):
+        output = output.decode(sys.stdout.encoding)
+    processes = {}
+    for line in output.split('\n'):
+        try:
+            pid, ppid, args = line.strip().split(maxsplit=2)
+        except ValueError:
+            continue
+        processes[pid] = Process(
+            args=tuple(shlex.split(args)), pid=pid, ppid=ppid,
+        )
+    return processes
+
+
+def get_shell(pid=None, max_depth=6):
+    """Get the shell that the supplied pid or os.getpid() is running in.
+    """
+    pid = str(pid or os.getpid())
+    mapping = _get_process_mapping()
+    login_shell = os.environ.get('SHELL', '')
+    for _ in range(max_depth):
+        try:
+            proc = mapping[pid]
+        except KeyError:
+            break
+        name = os.path.basename(proc.args[0]).lower()
+        if name in SHELL_NAMES:
+            return (name, proc.args[0])
+        elif proc.args[0].startswith('-'):
+            # This is the login shell. Use the SHELL environ if possible
+            # because it provides better information.
+            if login_shell:
+                name = login_shell.lower()
+            else:
+                name = proc.args[0][1:].lower()
+            return (os.path.basename(name), name)
+        pid = proc.ppid     # Go up one level.
+    return None
diff --git a/pipenv/vendor/shellingham/posix/_default.py b/pipenv/vendor/shellingham/posix/_default.py
new file mode 100644
index 00000000..86944276
--- /dev/null
+++ b/pipenv/vendor/shellingham/posix/_default.py
@@ -0,0 +1,27 @@
+import collections
+import shlex
+import subprocess
+import sys
+
+
+Process = collections.namedtuple('Process', 'args pid ppid')
+
+
+def get_process_mapping():
+    """Try to look up the process tree via the output of `ps`.
+    """
+    output = subprocess.check_output([
+        'ps', '-ww', '-o', 'pid=', '-o', 'ppid=', '-o', 'args=',
+    ])
+    if not isinstance(output, str):
+        output = output.decode(sys.stdout.encoding)
+    processes = {}
+    for line in output.split('\n'):
+        try:
+            pid, ppid, args = line.strip().split(None, 2)
+        except ValueError:
+            continue
+        processes[pid] = Process(
+            args=tuple(shlex.split(args)), pid=pid, ppid=ppid,
+        )
+    return processes
diff --git a/pipenv/vendor/shellingham/posix/_proc.py b/pipenv/vendor/shellingham/posix/_proc.py
new file mode 100644
index 00000000..921f2508
--- /dev/null
+++ b/pipenv/vendor/shellingham/posix/_proc.py
@@ -0,0 +1,41 @@
+import os
+import re
+
+from ._core import Process
+
+
+STAT_PPID = 3
+STAT_TTY = 6
+
+STAT_PATTERN = re.compile(r'\(.+\)|\S+')
+
+
+def _get_stat(pid):
+    with open(os.path.join('/proc', str(pid), 'stat')) as f:
+        parts = STAT_PATTERN.findall(f.read())
+        return parts[STAT_TTY], parts[STAT_PPID]
+
+
+def _get_cmdline(pid):
+    with open(os.path.join('/proc', str(pid), 'cmdline')) as f:
+        return tuple(f.read().split('\0')[:-1])
+
+
+def get_process_mapping():
+    """Try to look up the process tree via the /proc interface.
+    """
+    self_tty = _get_stat(os.getpid())[0]
+    processes = {}
+    for pid in os.listdir('/proc'):
+        if not pid.isdigit():
+            continue
+        try:
+            tty, ppid = _get_stat(pid)
+            if tty != self_tty:
+                continue
+            args = _get_cmdline(pid)
+            processes[pid] = Process(args=args, pid=pid, ppid=ppid)
+        except IOError:
+            # Process has disappeared - just ignore it.
+            continue
+    return processes
diff --git a/pipenv/vendor/shellingham/posix/_ps.py b/pipenv/vendor/shellingham/posix/_ps.py
new file mode 100644
index 00000000..e96278cf
--- /dev/null
+++ b/pipenv/vendor/shellingham/posix/_ps.py
@@ -0,0 +1,25 @@
+import shlex
+import subprocess
+import sys
+
+from ._core import Process
+
+
+def get_process_mapping():
+    """Try to look up the process tree via the output of `ps`.
+    """
+    output = subprocess.check_output([
+        'ps', '-ww', '-o', 'pid=', '-o', 'ppid=', '-o', 'args=',
+    ])
+    if not isinstance(output, str):
+        output = output.decode(sys.stdout.encoding)
+    processes = {}
+    for line in output.split('\n'):
+        try:
+            pid, ppid, args = line.strip().split(None, 2)
+        except ValueError:
+            continue
+        processes[pid] = Process(
+            args=tuple(shlex.split(args)), pid=pid, ppid=ppid,
+        )
+    return processes
diff --git a/pipenv/vendor/shellingham/posix/linux.py b/pipenv/vendor/shellingham/posix/linux.py
new file mode 100644
index 00000000..6db97834
--- /dev/null
+++ b/pipenv/vendor/shellingham/posix/linux.py
@@ -0,0 +1,35 @@
+import os
+import re
+
+from ._default import Process
+
+
+STAT_PPID = 3
+STAT_TTY = 6
+
+
+def get_process_mapping():
+    """Try to look up the process tree via Linux's /proc
+    """
+    with open('/proc/{0}/stat'.format(os.getpid())) as f:
+        self_tty = f.read().split()[STAT_TTY]
+    processes = {}
+    for pid in os.listdir('/proc'):
+        if not pid.isdigit():
+            continue
+        try:
+            stat = '/proc/{0}/stat'.format(pid)
+            cmdline = '/proc/{0}/cmdline'.format(pid)
+            with open(stat) as fstat, open(cmdline) as fcmdline:
+                stat = re.findall(r'\(.+\)|\S+', fstat.read())
+                cmd = fcmdline.read().split('\x00')[:-1]
+            ppid = stat[STAT_PPID]
+            tty = stat[STAT_TTY]
+            if tty == self_tty:
+                processes[pid] = Process(
+                    args=tuple(cmd), pid=pid, ppid=ppid,
+                )
+        except IOError:
+            # Process has disappeared - just ignore it.
+            continue
+    return processes

commit 4589727d4621d335c256183e5a14eb3dce38b7ef
Author: Dan Ryan <dan@danryan.co>
Date:   Sat Aug 25 13:58:03 2018 -0400

    Vendor modutil
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/vendor/modutil.LICENSE b/pipenv/vendor/modutil.LICENSE
new file mode 100644
index 00000000..f680f071
--- /dev/null
+++ b/pipenv/vendor/modutil.LICENSE
@@ -0,0 +1,29 @@
+BSD 3-Clause License
+
+Copyright (c) 2018, Brett Cannon
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+* Neither the name of the copyright holder nor the names of its
+  contributors may be used to endorse or promote products derived from
+  this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/pipenv/vendor/modutil.py b/pipenv/vendor/modutil.py
new file mode 100644
index 00000000..d68f4851
--- /dev/null
+++ b/pipenv/vendor/modutil.py
@@ -0,0 +1,145 @@
+"""Help for working with modules."""
+__version__ = "2.0.0"
+
+import importlib
+import importlib.machinery
+import importlib.util
+import types
+
+
+STANDARD_MODULE_ATTRS = frozenset(['__all__', '__builtins__', '__cached__',
+                                   '__doc__', '__file__', '__loader__',
+                                   '__name__', '__package__', '__spec__',
+                                   '__getattr__'])
+
+
+class ModuleAttributeError(AttributeError):
+    """An AttributeError specifically for modules.
+
+    The module_name and 'attribute' attributes are set to strings representing
+    the module the attribute was searched on and the missing attribute,
+    respectively.
+
+    """
+
+    def __init__(self, module_name, attribute):
+        self.module_name = module_name
+        self.attribute = attribute
+        super().__init__(f"module {module_name!r} has no attribute {attribute!r}")
+
+
+
+def lazy_import(module_name, to_import):
+    """Return the importing module and a callable for lazy importing.
+
+    The module named by module_name represents the module performing the
+    import to help facilitate resolving relative imports.
+
+    to_import is an iterable of the modules to be potentially imported (absolute
+    or relative). The `as` form of importing is also supported,
+    e.g. `pkg.mod as spam`.
+
+    This function returns a tuple of two items. The first is the importer
+    module for easy reference within itself. The second item is a callable to be
+    set to `__getattr__`.
+    """
+    module = importlib.import_module(module_name)
+    import_mapping = {}
+    for name in to_import:
+        importing, _, binding = name.partition(' as ')
+        if not binding:
+            _, _, binding = importing.rpartition('.')
+        import_mapping[binding] = importing
+
+    def __getattr__(name):
+        if name not in import_mapping:
+            raise ModuleAttributeError(module_name, name)
+        importing = import_mapping[name]
+        # imortlib.import_module() implicitly sets submodules on this module as
+        # appropriate for direct imports.
+        imported = importlib.import_module(importing,
+                                           module.__spec__.parent)
+        setattr(module, name, imported)
+        return imported
+
+    return module, __getattr__
+
+
+def filtered_attrs(module, *, modules=False, private=False, dunder=False,
+                   common=False):
+    """Return a collection of attributes on 'module'.
+
+    If 'modules' is false then module instances are excluded. If 'private' is
+    false then attributes starting with, but not ending in, '_' will be
+    excluded. With 'dunder' set to false then attributes starting and ending
+    with '_' are left out. The 'common' argument controls whether attributes
+    found in STANDARD_MODULE_ATTRS are returned.
+
+    """
+    attr_names = set()
+    for name, value in module.__dict__.items():
+        if not common and name in STANDARD_MODULE_ATTRS:
+            continue
+        if name.startswith('_'):
+            if name.endswith('_'):
+                if not dunder:
+                    continue
+            elif not private:
+                continue
+        if not modules and isinstance(value, types.ModuleType):
+            continue
+        attr_names.add(name)
+    return frozenset(attr_names)
+
+
+def calc___all__(module_name, **kwargs):
+    """Return a sorted list of defined attributes on 'module_name'.
+
+    All values specified in **kwargs are directly passed to filtered_attrs().
+
+    """
+    module = importlib.import_module(module_name)
+    return sorted(filtered_attrs(module, **kwargs))
+
+
+def filtered_dir(module_name, *, additions={}, **kwargs):
+    """Return a callable appropriate for __dir__().
+
+    All values specified in **kwargs get passed directly to filtered_attrs().
+    The 'additions' argument should be an iterable which is added to the final
+    results.
+
+    """
+    module = importlib.import_module(module_name)
+
+    def __dir__():
+        attr_names = set(filtered_attrs(module, **kwargs))
+        attr_names.update(additions)
+        return sorted(attr_names)
+
+    return __dir__
+
+
+def chained___getattr__(module_name, *getattrs):
+    """Create a callable which calls each __getattr__ in sequence.
+
+    Any raised ModuleAttributeError which matches module_name and the
+    attribute being searched for will be caught and the search will continue.
+    All other exceptions will be allowed to propagate. If no callable
+    successfully returns a value, ModuleAttributeError will be raised.
+
+    """
+    def __getattr__(name):
+        """Call each __getattr__ function in sequence."""
+        for getattr_ in getattrs:
+            try:
+                return getattr_(name)
+            except ModuleAttributeError as exc:
+                if exc.module_name == module_name and exc.attribute == name:
+                    continue
+                else:
+                    raise
+        else:
+            raise ModuleAttributeError(module_name, name)
+
+    return __getattr__
diff --git a/pipenv/vendor/vendor.txt b/pipenv/vendor/vendor.txt
index 170ccec8..1ff20bd4 100644
--- a/pipenv/vendor/vendor.txt
+++ b/pipenv/vendor/vendor.txt
@@ -42,4 +42,5 @@ toml==0.9.4
 cached-property==1.4.3
 vistir==0.1.4
 pip-shims==0.1.2
-ptyprocess==0.6.0
\ No newline at end of file
+ptyprocess==0.6.0
+enum34==1.1.6
diff --git a/setup.py b/setup.py
index 7c87a2d6..7e121fb7 100644
--- a/setup.py
+++ b/setup.py
@@ -29,6 +29,7 @@ required = [
     "virtualenv",
     'requests[security];python_version<"2.7"',
     'ordereddict;python_version<"2.7"',
+    'enum34; python_version<"3"'
 ]
 
 

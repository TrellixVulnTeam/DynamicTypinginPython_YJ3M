commit 204f6894e5568b3bc3d05a36dbea5e45b17dcef5
Author: Dan Ryan <dan@danryan.co>
Date:   Thu Apr 18 18:04:17 2019 -0400

    Refactor resolver into resolver file
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/resolver.py b/pipenv/resolver.py
index 4f4df8a5..fa76765e 100644
--- a/pipenv/resolver.py
+++ b/pipenv/resolver.py
@@ -783,10 +783,6 @@ def main():
         all(getattr(stream, method, None) for stream in [sys.stdout, sys.stderr] for method in ["write", "isatty"]) and
         all(stream.isatty() for stream in [sys.stdout, sys.stderr])
     ):
-        # stderr_wrapper = colorama.AnsiToWin32(sys.stderr, autoreset=False, convert=None, strip=None)
-        # stdout_wrapper = colorama.AnsiToWin32(sys.stdout, autoreset=False, convert=None, strip=None)
-        # sys.stderr = stderr_wrapper.stream
-        # sys.stdout = stdout_wrapper.stream
         colorama.init(wrap=False)
     elif os.name != "nt":
         colorama.init()
diff --git a/pipenv/utils.py b/pipenv/utils.py
index 3d526974..6174d015 100644
--- a/pipenv/utils.py
+++ b/pipenv/utils.py
@@ -911,76 +911,6 @@ def actually_resolve_deps(
         hashes = resolver.resolve_hashes()
         resolver.resolve_constraints()
         results = resolver.clean_results()
-        # constraints, skipped, index_lookup, markers_lookup = Resolver.get_metadata(
-        #     deps, index_lookup, markers_lookup, project, sources,
-        # )
-        # resolver = Resolver(constraints, req_dir, project, sources, clear=clear, pre=pre)
-        # resolved_tree = resolver.resolve()
-        # hashes = resolver.resolve_hashes()
-        # reqs = [(Requirement.from_ireq(ireq), ireq) for ireq in resolved_tree]
-        # results = {}
-        # for req, ireq in reqs:
-        #     if (req.vcs and req.editable and not req.is_direct_url):
-        #         continue
-        #     collected_hashes = resolver.collect_hashes(ireq)
-        #     if collected_hashes:
-        #         req = req.add_hashes(collected_hashes)
-        #     elif resolver._should_include_hash(ireq):
-        #         existing_hashes = hashes.get(ireq, set())
-        #         discovered_hashes = existing_hashes | resolver.get_hash(ireq)
-        #         if discovered_hashes:
-        #             req = req.add_hashes(discovered_hashes)
-        #         resolver.hashes[ireq] = discovered_hashes
-        #     if req.specifiers:
-        #         version = str(req.get_version())
-        #     else:
-        #         version = None
-        #     index = index_lookup.get(req.normalized_name)
-        #     markers = markers_lookup.get(req.normalized_name)
-        #     req.index = index
-        #     name, pf_entry = req.pipfile_entry
-        #     name = pep423_name(req.name)
-        #     entry = {}
-        #     if isinstance(pf_entry, six.string_types):
-        #         entry["version"] = pf_entry.lstrip("=")
-        #     else:
-        #         entry.update(pf_entry)
-        #         if version is not None:
-        #             entry["version"] = version
-        #         if req.line_instance.is_direct_url:
-        #             entry["file"] = req.req.uri
-        #     if collected_hashes:
-        #         entry["hashes"] = sorted(set(collected_hashes))
-        #     entry["name"] = name
-        #     if index:  # and index != next(iter(project.sources), {}).get("name"):
-        #         entry.update({"index": index})
-        #     if markers:
-        #         entry.update({"markers": markers})
-        #     entry = translate_markers(entry)
-        #     if name in results:
-        #         results[name].update(entry)
-        #     else:
-        #         results[name] = entry
-        # for k in list(skipped.keys()):
-        #     req = Requirement.from_pipfile(k, skipped[k])
-        #     ref = None
-        #     if req.is_vcs:
-        #         ref = req.commit_hash
-        #     ireq = req.as_ireq()
-        #     entry = skipped[k].copy()
-        #     entry["name"] = req.name
-        #     ref = ref if ref is not None else entry.get("ref")
-        #     if ref:
-        #         entry["ref"] = ref
-        #     if resolver._should_include_hash(ireq):
-        #         collected_hashes = resolver.collect_hashes(ireq)
-        #         if collected_hashes:
-        #             entry["hashes"] = sorted(set(collected_hashes))
-        #     if k in results:
-        #         results[k].update(entry)
-        #     else:
-        #         results[k] = entry
-        # results = list(results.values())
     for warning in warning_list:
         _show_warning(warning.message, warning.category, warning.filename, warning.lineno,
                       warning.line)

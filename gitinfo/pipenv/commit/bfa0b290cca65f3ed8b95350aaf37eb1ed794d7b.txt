commit bfa0b290cca65f3ed8b95350aaf37eb1ed794d7b
Author: Dan Ryan <dan@danryan.co>
Date:   Wed Nov 14 01:11:59 2018 -0500

    Update vendored deps
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/vendor/click_completion/__init__.py b/pipenv/vendor/click_completion/__init__.py
index b849ae23..e30cc0e3 100644
--- a/pipenv/vendor/click_completion/__init__.py
+++ b/pipenv/vendor/click_completion/__init__.py
@@ -19,7 +19,7 @@ from click_completion.core import completion_configuration, get_code, install, s
 from click_completion.lib import get_auto_shell
 from click_completion.patch import patch as _patch
 
-__version__ = '0.4.1'
+__version__ = '0.5.0'
 
 _initialized = False
 
diff --git a/pipenv/vendor/click_completion/lib.py b/pipenv/vendor/click_completion/lib.py
index cd53bc03..167ecfd8 100644
--- a/pipenv/vendor/click_completion/lib.py
+++ b/pipenv/vendor/click_completion/lib.py
@@ -59,7 +59,7 @@ def double_quote(s):
     return '"' + s.replace('"', '"\'"\'"') + '"'
 
 
-def resolve_ctx(cli, prog_name, args):
+def resolve_ctx(cli, prog_name, args, resilient_parsing=True):
     """
 
     Parameters
@@ -76,13 +76,18 @@ def resolve_ctx(cli, prog_name, args):
     click.core.Context
         A new context corresponding to the current command
     """
-    ctx = cli.make_context(prog_name, list(args), resilient_parsing=True)
+    ctx = cli.make_context(prog_name, list(args), resilient_parsing=resilient_parsing)
     while ctx.args + ctx.protected_args and isinstance(ctx.command, MultiCommand):
         a = ctx.protected_args + ctx.args
         cmd = ctx.command.get_command(ctx, a[0])
         if cmd is None:
             return None
-        ctx = cmd.make_context(a[0], a[1:], parent=ctx, resilient_parsing=True)
+        if hasattr(cmd, "no_args_is_help"):
+            no_args_is_help = cmd.no_args_is_help
+            cmd.no_args_is_help = False
+        ctx = cmd.make_context(a[0], a[1:], parent=ctx, resilient_parsing=resilient_parsing)
+        if hasattr(cmd, "no_args_is_help"):
+            cmd.no_args_is_help = no_args_is_help
     return ctx
 
 
diff --git a/pipenv/vendor/passa/cli/options.py b/pipenv/vendor/passa/cli/options.py
index da89a3b1..f8ba1fe7 100644
--- a/pipenv/vendor/passa/cli/options.py
+++ b/pipenv/vendor/passa/cli/options.py
@@ -46,9 +46,12 @@ class Option(object):
 
 
 class ArgumentGroup(object):
-    def __init__(self, name, parser=None, is_mutually_exclusive=False, required=None, options=[]):
+    def __init__(
+            self, name, parser=None,
+            is_mutually_exclusive=False,
+            required=None, options=None):
         self.name = name
-        self.options = options
+        self.options = options or []
         self.parser = parser
         self.required = required
         self.is_mutually_exclusive = is_mutually_exclusive
diff --git a/pipenv/vendor/pythonfinder/__init__.py b/pipenv/vendor/pythonfinder/__init__.py
index 85666b5c..fd9ec1be 100644
--- a/pipenv/vendor/pythonfinder/__init__.py
+++ b/pipenv/vendor/pythonfinder/__init__.py
@@ -1,6 +1,6 @@
 from __future__ import print_function, absolute_import
 
-__version__ = '1.1.8'
+__version__ = '1.1.9'
 
 # Add NullHandler to "pythonfinder" logger, because Python2's default root
 # logger has no handler and warnings like this would be reported:
diff --git a/pipenv/vendor/pythonfinder/models/python.py b/pipenv/vendor/pythonfinder/models/python.py
index 7feee84e..db7d011e 100644
--- a/pipenv/vendor/pythonfinder/models/python.py
+++ b/pipenv/vendor/pythonfinder/models/python.py
@@ -414,8 +414,8 @@ class PythonVersion(object):
         if not path.is_python and not IGNORE_UNSUPPORTED:
             raise ValueError("Not a valid python path: %s" % path.path)
             return
-        py_version = get_python_version(path.path.as_posix())
-        instance_dict = cls.parse(py_version)
+        py_version = get_python_version(path.path.absolute().as_posix())
+        instance_dict = cls.parse(py_version.strip())
         if not isinstance(instance_dict.get("version"), Version) and not IGNORE_UNSUPPORTED:
             raise ValueError("Not a valid python path: %s" % path.path)
             return
diff --git a/pipenv/vendor/pythonfinder/pythonfinder.py b/pipenv/vendor/pythonfinder/pythonfinder.py
index b3bad570..011754ea 100644
--- a/pipenv/vendor/pythonfinder/pythonfinder.py
+++ b/pipenv/vendor/pythonfinder/pythonfinder.py
@@ -9,7 +9,8 @@ from vistir.compat import lru_cache
 
 class Finder(object):
     def __init__(self, path=None, system=False, global_search=True, ignore_unsupported=True):
-        """Finder A cross-platform Finder for locating python and other executables.
+        """
+        Finder A cross-platform Finder for locating python and other executables.
 
         Searches for python and other specified binaries starting in `path`, if supplied,
         but searching the bin path of `sys.executable` if `system=True`, and then
diff --git a/pipenv/vendor/pythonfinder/utils.py b/pipenv/vendor/pythonfinder/utils.py
index a26d0548..2debd80e 100644
--- a/pipenv/vendor/pythonfinder/utils.py
+++ b/pipenv/vendor/pythonfinder/utils.py
@@ -12,17 +12,17 @@ import six
 
 import vistir
 
-from .environment import PYENV_ROOT
+from .environment import PYENV_ROOT, ASDF_DATA_DIR
 from .exceptions import InvalidPythonVersion
 
+six.add_move(six.MovedAttribute("Iterable", "collections", "collections.abc"))
+from six.moves import Iterable
+
 try:
     from functools import lru_cache
 except ImportError:
     from backports.functools_lru_cache import lru_cache
 
-six.add_move(six.MovedAttribute("Iterable", "collections", "collections.abc"))
-from six.moves import Iterable
-
 
 PYTHON_IMPLEMENTATIONS = (
     "python", "ironpython", "jython", "pypy", "anaconda", "miniconda",
@@ -52,7 +52,7 @@ def get_python_version(path):
     version_cmd = [path, "-c", "import sys; print(sys.version.split()[0])"]
     try:
         c = vistir.misc.run(version_cmd, block=True, nospin=True, return_object=True,
-                            combine_stderr=False)
+                                combine_stderr=False)
     except OSError:
         raise InvalidPythonVersion("%s is not a valid python path" % path)
     if not c.out:
@@ -64,10 +64,6 @@ def optional_instance_of(cls):
     return attr.validators.optional(attr.validators.instance_of(cls))
 
 
-def path_and_exists(path):
-    return attr.validators.instance_of(vistir.compat.Path) and path.exists()
-
-
 def path_is_executable(path):
     return os.access(str(path), os.X_OK)
 
@@ -95,7 +91,8 @@ def path_is_python(path):
 
 @lru_cache(maxsize=1024)
 def ensure_path(path):
-    """Given a path (either a string or a Path object), expand variables and return a Path object.
+    """
+    Given a path (either a string or a Path object), expand variables and return a Path object.
 
     :param path: A string or a :class:`~pathlib.Path` object.
     :type path: str or :class:`~pathlib.Path`
@@ -115,6 +112,7 @@ def _filter_none(k, v):
     return False
 
 
+# TODO: Reimplement in vistir
 def normalize_path(path):
     return os.path.normpath(os.path.normcase(
         os.path.abspath(os.path.expandvars(os.path.expanduser(str(path))))
@@ -128,9 +126,10 @@ def filter_pythons(path):
         path = vistir.compat.Path(str(path))
     if not path.is_dir():
         return path if path_is_python(path) else None
-    return filter(lambda x: path_is_python(x), path.iterdir())
+    return filter(path_is_python, path.iterdir())
 
 
+# TODO: Port to vistir
 def unnest(item):
     if isinstance(item, Iterable) and not isinstance(item, six.string_types):
         item, target = itertools.tee(item, 2)
@@ -168,5 +167,6 @@ def parse_asdf_version_order(filename=".tool-versions"):
                 return versions.split()
 
 
+# TODO: Reimplement in vistir
 def is_in_path(path, parent):
     return normalize_path(str(path)).startswith(normalize_path(str(parent)))
diff --git a/pipenv/vendor/pytoml/LICENSE b/pipenv/vendor/pytoml/LICENSE
deleted file mode 100644
index 9739fc67..00000000
--- a/pipenv/vendor/pytoml/LICENSE
+++ /dev/null
@@ -1,16 +0,0 @@
-No-notice MIT License
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
diff --git a/pipenv/vendor/pytoml/__init__.py b/pipenv/vendor/pytoml/__init__.py
deleted file mode 100644
index 8dc73155..00000000
--- a/pipenv/vendor/pytoml/__init__.py
+++ /dev/null
@@ -1,3 +0,0 @@
-from .core import TomlError
-from .parser import load, loads
-from .writer import dump, dumps
diff --git a/pipenv/vendor/pytoml/core.py b/pipenv/vendor/pytoml/core.py
deleted file mode 100644
index c182734e..00000000
--- a/pipenv/vendor/pytoml/core.py
+++ /dev/null
@@ -1,13 +0,0 @@
-class TomlError(RuntimeError):
-    def __init__(self, message, line, col, filename):
-        RuntimeError.__init__(self, message, line, col, filename)
-        self.message = message
-        self.line = line
-        self.col = col
-        self.filename = filename
-
-    def __str__(self):
-        return '{}({}, {}): {}'.format(self.filename, self.line, self.col, self.message)
-
-    def __repr__(self):
-        return 'TomlError({!r}, {!r}, {!r}, {!r})'.format(self.message, self.line, self.col, self.filename)
diff --git a/pipenv/vendor/pytoml/parser.py b/pipenv/vendor/pytoml/parser.py
deleted file mode 100644
index 9f94e923..00000000
--- a/pipenv/vendor/pytoml/parser.py
+++ /dev/null
@@ -1,374 +0,0 @@
-import string, re, sys, datetime
-from .core import TomlError
-
-if sys.version_info[0] == 2:
-    _chr = unichr
-else:
-    _chr = chr
-
-def load(fin, translate=lambda t, x, v: v, object_pairs_hook=dict):
-    return loads(fin.read(), translate=translate, object_pairs_hook=object_pairs_hook, filename=getattr(fin, 'name', repr(fin)))
-
-def loads(s, filename='<string>', translate=lambda t, x, v: v, object_pairs_hook=dict):
-    if isinstance(s, bytes):
-        s = s.decode('utf-8')
-
-    s = s.replace('\r\n', '\n')
-
-    root = object_pairs_hook()
-    tables = object_pairs_hook()
-    scope = root
-
-    src = _Source(s, filename=filename)
-    ast = _p_toml(src, object_pairs_hook=object_pairs_hook)
-
-    def error(msg):
-        raise TomlError(msg, pos[0], pos[1], filename)
-
-    def process_value(v, object_pairs_hook):
-        kind, text, value, pos = v
-        if kind == 'str' and value.startswith('\n'):
-            value = value[1:]
-        if kind == 'array':
-            if value and any(k != value[0][0] for k, t, v, p in value[1:]):
-                error('array-type-mismatch')
-            value = [process_value(item, object_pairs_hook=object_pairs_hook) for item in value]
-        elif kind == 'table':
-            value = object_pairs_hook([(k, process_value(value[k], object_pairs_hook=object_pairs_hook)) for k in value])
-        return translate(kind, text, value)
-
-    for kind, value, pos in ast:
-        if kind == 'kv':
-            k, v = value
-            if k in scope:
-                error('duplicate_keys. Key "{0}" was used more than once.'.format(k))
-            scope[k] = process_value(v, object_pairs_hook=object_pairs_hook)
-        else:
-            is_table_array = (kind == 'table_array')
-            cur = tables
-            for name in value[:-1]:
-                if isinstance(cur.get(name), list):
-                    d, cur = cur[name][-1]
-                else:
-                    d, cur = cur.setdefault(name, (None, object_pairs_hook()))
-
-            scope = object_pairs_hook()
-            name = value[-1]
-            if name not in cur:
-                if is_table_array:
-                    cur[name] = [(scope, object_pairs_hook())]
-                else:
-                    cur[name] = (scope, object_pairs_hook())
-            elif isinstance(cur[name], list):
-                if not is_table_array:
-                    error('table_type_mismatch')
-                cur[name].append((scope, object_pairs_hook()))
-            else:
-                if is_table_array:
-                    error('table_type_mismatch')
-                old_scope, next_table = cur[name]
-                if old_scope is not None:
-                    error('duplicate_tables')
-                cur[name] = (scope, next_table)
-
-    def merge_tables(scope, tables):
-        if scope is None:
-            scope = object_pairs_hook()
-        for k in tables:
-            if k in scope:
-                error('key_table_conflict')
-            v = tables[k]
-            if isinstance(v, list):
-                scope[k] = [merge_tables(sc, tbl) for sc, tbl in v]
-            else:
-                scope[k] = merge_tables(v[0], v[1])
-        return scope
-
-    return merge_tables(root, tables)
-
-class _Source:
-    def __init__(self, s, filename=None):
-        self.s = s
-        self._pos = (1, 1)
-        self._last = None
-        self._filename = filename
-        self.backtrack_stack = []
-
-    def last(self):
-        return self._last
-
-    def pos(self):
-        return self._pos
-
-    def fail(self):
-        return self._expect(None)
-
-    def consume_dot(self):
-        if self.s:
-            self._last = self.s[0]
-            self.s = self[1:]
-            self._advance(self._last)
-            return self._last
-        return None
-
-    def expect_dot(self):
-        return self._expect(self.consume_dot())
-
-    def consume_eof(self):
-        if not self.s:
-            self._last = ''
-            return True
-        return False
-
-    def expect_eof(self):
-        return self._expect(self.consume_eof())
-
-    def consume(self, s):
-        if self.s.startswith(s):
-            self.s = self.s[len(s):]
-            self._last = s
-            self._advance(s)
-            return True
-        return False
-
-    def expect(self, s):
-        return self._expect(self.consume(s))
-
-    def consume_re(self, re):
-        m = re.match(self.s)
-        if m:
-            self.s = self.s[len(m.group(0)):]
-            self._last = m
-            self._advance(m.group(0))
-            return m
-        return None
-
-    def expect_re(self, re):
-        return self._expect(self.consume_re(re))
-
-    def __enter__(self):
-        self.backtrack_stack.append((self.s, self._pos))
-
-    def __exit__(self, type, value, traceback):
-        if type is None:
-            self.backtrack_stack.pop()
-        else:
-            self.s, self._pos = self.backtrack_stack.pop()
-        return type == TomlError
-
-    def commit(self):
-        self.backtrack_stack[-1] = (self.s, self._pos)
-
-    def _expect(self, r):
-        if not r:
-            raise TomlError('msg', self._pos[0], self._pos[1], self._filename)
-        return r
-
-    def _advance(self, s):
-        suffix_pos = s.rfind('\n')
-        if suffix_pos == -1:
-            self._pos = (self._pos[0], self._pos[1] + len(s))
-        else:
-            self._pos = (self._pos[0] + s.count('\n'), len(s) - suffix_pos)
-
-_ews_re = re.compile(r'(?:[ \t]|#[^\n]*\n|#[^\n]*\Z|\n)*')
-def _p_ews(s):
-    s.expect_re(_ews_re)
-
-_ws_re = re.compile(r'[ \t]*')
-def _p_ws(s):
-    s.expect_re(_ws_re)
-
-_escapes = { 'b': '\b', 'n': '\n', 'r': '\r', 't': '\t', '"': '"', '\'': '\'',
-    '\\': '\\', '/': '/', 'f': '\f' }
-
-_basicstr_re = re.compile(r'[^"\\\000-\037]*')
-_short_uni_re = re.compile(r'u([0-9a-fA-F]{4})')
-_long_uni_re = re.compile(r'U([0-9a-fA-F]{8})')
-_escapes_re = re.compile('[bnrt"\'\\\\/f]')
-_newline_esc_re = re.compile('\n[ \t\n]*')
-def _p_basicstr_content(s, content=_basicstr_re):
-    res = []
-    while True:
-        res.append(s.expect_re(content).group(0))
-        if not s.consume('\\'):
-            break
-        if s.consume_re(_newline_esc_re):
-            pass
-        elif s.consume_re(_short_uni_re) or s.consume_re(_long_uni_re):
-            res.append(_chr(int(s.last().group(1), 16)))
-        else:
-            s.expect_re(_escapes_re)
-            res.append(_escapes[s.last().group(0)])
-    return ''.join(res)
-
-_key_re = re.compile(r'[0-9a-zA-Z-_]+')
-def _p_key(s):
-    with s:
-        s.expect('"')
-        r = _p_basicstr_content(s, _basicstr_re)
-        s.expect('"')
-        return r
-    if s.consume('\''):
-        if s.consume('\'\''):
-            r = s.expect_re(_litstr_ml_re).group(0)
-            s.expect('\'\'\'')
-        else:
-            r = s.expect_re(_litstr_re).group(0)
-            s.expect('\'')
-        return r
-    return s.expect_re(_key_re).group(0)
-
-_float_re = re.compile(r'[+-]?(?:0|[1-9](?:_?\d)*)(?:\.\d(?:_?\d)*)?(?:[eE][+-]?(?:\d(?:_?\d)*))?')
-_datetime_re = re.compile(r'(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(\.\d+)?(?:Z|([+-]\d{2}):(\d{2}))')
-
-_basicstr_ml_re = re.compile(r'(?:(?:|"|"")[^"\\\000-\011\013-\037])*')
-_litstr_re = re.compile(r"[^'\000\010\012-\037]*")
-_litstr_ml_re = re.compile(r"(?:(?:|'|'')(?:[^'\000-\010\013-\037]))*")
-def _p_value(s, object_pairs_hook):
-    pos = s.pos()
-
-    if s.consume('true'):
-        return 'bool', s.last(), True, pos
-    if s.consume('false'):
-        return 'bool', s.last(), False, pos
-
-    if s.consume('"'):
-        if s.consume('""'):
-            r = _p_basicstr_content(s, _basicstr_ml_re)
-            s.expect('"""')
-        else:
-            r = _p_basicstr_content(s, _basicstr_re)
-            s.expect('"')
-        return 'str', r, r, pos
-
-    if s.consume('\''):
-        if s.consume('\'\''):
-            r = s.expect_re(_litstr_ml_re).group(0)
-            s.expect('\'\'\'')
-        else:
-            r = s.expect_re(_litstr_re).group(0)
-            s.expect('\'')
-        return 'str', r, r, pos
-
-    if s.consume_re(_datetime_re):
-        m = s.last()
-        s0 = m.group(0)
-        r = map(int, m.groups()[:6])
-        if m.group(7):
-            micro = float(m.group(7))
-        else:
-            micro = 0
-
-        if m.group(8):
-            g = int(m.group(8), 10) * 60 + int(m.group(9), 10)
-            tz = _TimeZone(datetime.timedelta(0, g * 60))
-        else:
-            tz = _TimeZone(datetime.timedelta(0, 0))
-
-        y, m, d, H, M, S = r
-        dt = datetime.datetime(y, m, d, H, M, S, int(micro * 1000000), tz)
-        return 'datetime', s0, dt, pos
-
-    if s.consume_re(_float_re):
-        m = s.last().group(0)
-        r = m.replace('_','')
-        if '.' in m or 'e' in m or 'E' in m:
-            return 'float', m, float(r), pos
-        else:
-            return 'int', m, int(r, 10), pos
-
-    if s.consume('['):
-        items = []
-        with s:
-            while True:
-                _p_ews(s)
-                items.append(_p_value(s, object_pairs_hook=object_pairs_hook))
-                s.commit()
-                _p_ews(s)
-                s.expect(',')
-                s.commit()
-        _p_ews(s)
-        s.expect(']')
-        return 'array', None, items, pos
-
-    if s.consume('{'):
-        _p_ws(s)
-        items = object_pairs_hook()
-        if not s.consume('}'):
-            k = _p_key(s)
-            _p_ws(s)
-            s.expect('=')
-            _p_ws(s)
-            items[k] = _p_value(s, object_pairs_hook=object_pairs_hook)
-            _p_ws(s)
-            while s.consume(','):
-                _p_ws(s)
-                k = _p_key(s)
-                _p_ws(s)
-                s.expect('=')
-                _p_ws(s)
-                items[k] = _p_value(s, object_pairs_hook=object_pairs_hook)
-                _p_ws(s)
-            s.expect('}')
-        return 'table', None, items, pos
-
-    s.fail()
-
-def _p_stmt(s, object_pairs_hook):
-    pos = s.pos()
-    if s.consume(   '['):
-        is_array = s.consume('[')
-        _p_ws(s)
-        keys = [_p_key(s)]
-        _p_ws(s)
-        while s.consume('.'):
-            _p_ws(s)
-            keys.append(_p_key(s))
-            _p_ws(s)
-        s.expect(']')
-        if is_array:
-            s.expect(']')
-        return 'table_array' if is_array else 'table', keys, pos
-
-    key = _p_key(s)
-    _p_ws(s)
-    s.expect('=')
-    _p_ws(s)
-    value = _p_value(s, object_pairs_hook=object_pairs_hook)
-    return 'kv', (key, value), pos
-
-_stmtsep_re = re.compile(r'(?:[ \t]*(?:#[^\n]*)?\n)+[ \t]*')
-def _p_toml(s, object_pairs_hook):
-    stmts = []
-    _p_ews(s)
-    with s:
-        stmts.append(_p_stmt(s, object_pairs_hook=object_pairs_hook))
-        while True:
-            s.commit()
-            s.expect_re(_stmtsep_re)
-            stmts.append(_p_stmt(s, object_pairs_hook=object_pairs_hook))
-    _p_ews(s)
-    s.expect_eof()
-    return stmts
-
-class _TimeZone(datetime.tzinfo):
-    def __init__(self, offset):
-        self._offset = offset
-
-    def utcoffset(self, dt):
-        return self._offset
-
-    def dst(self, dt):
-        return None
-
-    def tzname(self, dt):
-        m = self._offset.total_seconds() // 60
-        if m < 0:
-            res = '-'
-            m = -m
-        else:
-            res = '+'
-        h = m // 60
-        m = m - h * 60
-        return '{}{:.02}{:.02}'.format(res, h, m)
diff --git a/pipenv/vendor/pytoml/writer.py b/pipenv/vendor/pytoml/writer.py
deleted file mode 100644
index 6eaf5d76..00000000
--- a/pipenv/vendor/pytoml/writer.py
+++ /dev/null
@@ -1,127 +0,0 @@
-from __future__ import unicode_literals
-import io, datetime, math, sys
-
-if sys.version_info[0] == 3:
-    long = int
-    unicode = str
-
-
-def dumps(obj, sort_keys=False):
-    fout = io.StringIO()
-    dump(obj, fout, sort_keys=sort_keys)
-    return fout.getvalue()
-
-
-_escapes = {'\n': 'n', '\r': 'r', '\\': '\\', '\t': 't', '\b': 'b', '\f': 'f', '"': '"'}
-
-
-def _escape_string(s):
-    res = []
-    start = 0
-
-    def flush():
-        if start != i:
-            res.append(s[start:i])
-        return i + 1
-
-    i = 0
-    while i < len(s):
-        c = s[i]
-        if c in '"\\\n\r\t\b\f':
-            start = flush()
-            res.append('\\' + _escapes[c])
-        elif ord(c) < 0x20:
-            start = flush()
-            res.append('\\u%04x' % ord(c))
-        i += 1
-
-    flush()
-    return '"' + ''.join(res) + '"'
-
-
-def _escape_id(s):
-    if any(not c.isalnum() and c not in '-_' for c in s):
-        return _escape_string(s)
-    return s
-
-
-def _format_list(v):
-    return '[{0}]'.format(', '.join(_format_value(obj) for obj in v))
-
-# Formula from:
-#   https://docs.python.org/2/library/datetime.html#datetime.timedelta.total_seconds
-# Once support for py26 is dropped, this can be replaced by td.total_seconds()
-def _total_seconds(td):
-    return ((td.microseconds
-             + (td.seconds + td.days * 24 * 3600) * 10**6) / 10.0**6)
-
-def _format_value(v):
-    if isinstance(v, bool):
-        return 'true' if v else 'false'
-    if isinstance(v, int) or isinstance(v, long):
-        return unicode(v)
-    if isinstance(v, float):
-        if math.isnan(v) or math.isinf(v):
-            raise ValueError("{0} is not a valid TOML value".format(v))
-        else:
-            return repr(v)
-    elif isinstance(v, unicode) or isinstance(v, bytes):
-        return _escape_string(v)
-    elif isinstance(v, datetime.datetime):
-        offs = v.utcoffset()
-        offs = _total_seconds(offs) // 60 if offs is not None else 0
-
-        if offs == 0:
-            suffix = 'Z'
-        else:
-            if offs > 0:
-                suffix = '+'
-            else:
-                suffix = '-'
-                offs = -offs
-            suffix = '{0}{1:.02}{2:.02}'.format(suffix, offs // 60, offs % 60)
-
-        if v.microsecond:
-            return v.strftime('%Y-%m-%dT%H:%M:%S.%f') + suffix
-        else:
-            return v.strftime('%Y-%m-%dT%H:%M:%S') + suffix
-    elif isinstance(v, list):
-        return _format_list(v)
-    else:
-        raise RuntimeError(v)
-
-
-def dump(obj, fout, sort_keys=False):
-    tables = [((), obj, False)]
-
-    while tables:
-        name, table, is_array = tables.pop()
-        if name:
-            section_name = '.'.join(_escape_id(c) for c in name)
-            if is_array:
-                fout.write('[[{0}]]\n'.format(section_name))
-            else:
-                fout.write('[{0}]\n'.format(section_name))
-
-        table_keys = sorted(table.keys()) if sort_keys else table.keys()
-        new_tables = []
-        has_kv = False
-        for k in table_keys:
-            v = table[k]
-            if isinstance(v, dict):
-                new_tables.append((name + (k,), v, False))
-            elif isinstance(v, list) and v and all(isinstance(o, dict) for o in v):
-                new_tables.extend((name + (k,), d, True) for d in v)
-            elif v is None:
-                # based on mojombo's comment: https://github.com/toml-lang/toml/issues/146#issuecomment-25019344
-                fout.write(
-                    '#{} = null  # To use: uncomment and replace null with value\n'.format(_escape_id(k)))
-                has_kv = True
-            else:
-                fout.write('{0} = {1}\n'.format(_escape_id(k), _format_value(v)))
-                has_kv = True
-
-        tables.extend(reversed(new_tables))
-
-        if (name or has_kv) and tables:
-            fout.write('\n')
diff --git a/pipenv/vendor/requests/__version__.py b/pipenv/vendor/requests/__version__.py
index be8a45fe..803773a0 100644
--- a/pipenv/vendor/requests/__version__.py
+++ b/pipenv/vendor/requests/__version__.py
@@ -5,8 +5,8 @@
 __title__ = 'requests'
 __description__ = 'Python HTTP for Humans.'
 __url__ = 'http://python-requests.org'
-__version__ = '2.20.0'
-__build__ = 0x022000
+__version__ = '2.20.1'
+__build__ = 0x022001
 __author__ = 'Kenneth Reitz'
 __author_email__ = 'me@kennethreitz.org'
 __license__ = 'Apache 2.0'
diff --git a/pipenv/vendor/requests/sessions.py b/pipenv/vendor/requests/sessions.py
index a448bd83..d73d700f 100644
--- a/pipenv/vendor/requests/sessions.py
+++ b/pipenv/vendor/requests/sessions.py
@@ -19,7 +19,7 @@ from .cookies import (
 from .models import Request, PreparedRequest, DEFAULT_REDIRECT_LIMIT
 from .hooks import default_hooks, dispatch_hook
 from ._internal_utils import to_native_string
-from .utils import to_key_val_list, default_headers
+from .utils import to_key_val_list, default_headers, DEFAULT_PORTS
 from .exceptions import (
     TooManyRedirects, InvalidSchema, ChunkedEncodingError, ContentDecodingError)
 
@@ -128,8 +128,17 @@ class SessionRedirectMixin(object):
         if (old_parsed.scheme == 'http' and old_parsed.port in (80, None)
                 and new_parsed.scheme == 'https' and new_parsed.port in (443, None)):
             return False
+
+        # Handle default port usage corresponding to scheme.
+        changed_port = old_parsed.port != new_parsed.port
+        changed_scheme = old_parsed.scheme != new_parsed.scheme
+        default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)
+        if (not changed_scheme and old_parsed.port in default_port
+                and new_parsed.port in default_port):
+            return False
+
         # Standard case: root URI must match
-        return old_parsed.port != new_parsed.port or old_parsed.scheme != new_parsed.scheme
+        return changed_port or changed_scheme
 
     def resolve_redirects(self, resp, req, stream=False, timeout=None,
                           verify=True, cert=None, proxies=None, yield_requests=False, **adapter_kwargs):
diff --git a/pipenv/vendor/requests/utils.py b/pipenv/vendor/requests/utils.py
index 0ce7fe11..8170a8d2 100644
--- a/pipenv/vendor/requests/utils.py
+++ b/pipenv/vendor/requests/utils.py
@@ -38,6 +38,8 @@ NETRC_FILES = ('.netrc', '_netrc')
 
 DEFAULT_CA_BUNDLE_PATH = certs.where()
 
+DEFAULT_PORTS = {'http': 80, 'https': 443}
+
 
 if sys.platform == 'win32':
     # provide a proxy_bypass version on Windows without DNS lookups
@@ -264,7 +266,7 @@ def from_key_val_list(value):
         >>> from_key_val_list([('key', 'val')])
         OrderedDict([('key', 'val')])
         >>> from_key_val_list('string')
-        ValueError: need more than 1 value to unpack
+        ValueError: cannot encode objects that are not 2-tuples
         >>> from_key_val_list({'key': 'val'})
         OrderedDict([('key', 'val')])
 
diff --git a/pipenv/vendor/requirementslib/__init__.py b/pipenv/vendor/requirementslib/__init__.py
index f6c985d3..32415c61 100644
--- a/pipenv/vendor/requirementslib/__init__.py
+++ b/pipenv/vendor/requirementslib/__init__.py
@@ -1,5 +1,5 @@
 # -*- coding=utf-8 -*-
-__version__ = '1.2.7'
+__version__ = '1.3.1'
 
 import logging
 import warnings
diff --git a/pipenv/vendor/requirementslib/exceptions.py b/pipenv/vendor/requirementslib/exceptions.py
index 23bc5e50..17b884eb 100644
--- a/pipenv/vendor/requirementslib/exceptions.py
+++ b/pipenv/vendor/requirementslib/exceptions.py
@@ -24,7 +24,7 @@ class RequirementError(Exception):
 
 class MissingParameter(Exception):
     def __init__(self, param):
-        super(Exception, self).__init__()
+        Exception.__init__(self)
         print("Missing parameter: %s" % param, file=sys.stderr, flush=True)
 
 
@@ -43,7 +43,7 @@ class FileCorruptException(OSError):
         self.path = path
         self.backup_path = backup_path
         self.show(self.path, self.backup_path)
-        super(OSError, self).__init__(path, *args, **kwargs)
+        OSError.__init__(self, path, *args, **kwargs)
 
     @classmethod
     def show(cls, path, backup_path=None):
diff --git a/pipenv/vendor/requirementslib/models/pipfile.py b/pipenv/vendor/requirementslib/models/pipfile.py
index dbb024be..0f6de6bf 100644
--- a/pipenv/vendor/requirementslib/models/pipfile.py
+++ b/pipenv/vendor/requirementslib/models/pipfile.py
@@ -53,17 +53,19 @@ class PipfileLoader(plette.pipfiles.Pipfile):
         _data["source"] = _data.get("source", []) + _data.get("sources", [])
         _data = reorder_source_keys(_data)
         if "source" not in _data:
-            # HACK: There is no good way to prepend a section to an existing
-            # TOML document, but there's no good way to copy non-structural
-            # content from one TOML document to another either. Modify the
-            # TOML content directly, and load the new in-memory document.
-            sep = "" if content.startswith("\n") else "\n"
-            content = plette.pipfiles.DEFAULT_SOURCE_TOML + sep + content
+            if "sources" in _data:
+                _data["source"] = _data["sources"]
+                content = tomlkit.dumps(_data)
+            else:
+                # HACK: There is no good way to prepend a section to an existing
+                # TOML document, but there's no good way to copy non-structural
+                # content from one TOML document to another either. Modify the
+                # TOML content directly, and load the new in-memory document.
+                sep = "" if content.startswith("\n") else "\n"
+                content = plette.pipfiles.DEFAULT_SOURCE_TOML + sep + content
         data = tomlkit.loads(content)
-        data = reorder_source_keys(data)
         instance = cls(data)
-        new_data = reorder_source_keys(instance._data)
-        instance._data = new_data
+        instance._data = dict(instance._data)
         return instance
 
     def __getattribute__(self, key):
diff --git a/pipenv/vendor/requirementslib/models/setup_info.py b/pipenv/vendor/requirementslib/models/setup_info.py
index 6107a240..006ee609 100644
--- a/pipenv/vendor/requirementslib/models/setup_info.py
+++ b/pipenv/vendor/requirementslib/models/setup_info.py
@@ -223,7 +223,6 @@ class SetupInfo(object):
         if self.setup_py is not None and self.setup_py.exists():
             target_cwd = self.setup_py.parent.as_posix()
             with cd(target_cwd), _suppress_distutils_logs():
-                from setuptools.dist import distutils
                 script_name = self.setup_py.as_posix()
                 args = ["egg_info", "--egg-base", self.base_dir]
                 g = {"__file__": script_name, "__name__": "__main__"}
@@ -306,7 +305,7 @@ class SetupInfo(object):
             if not self.requires or not self.name:
                 try:
                     self.run_setup()
-                except Exception as e:
+                except Exception:
                     self.get_egg_metadata()
                 if not self.requires or not self.name:
                     self.get_egg_metadata()
diff --git a/pipenv/vendor/requirementslib/utils.py b/pipenv/vendor/requirementslib/utils.py
index 312efbb3..f3653e32 100644
--- a/pipenv/vendor/requirementslib/utils.py
+++ b/pipenv/vendor/requirementslib/utils.py
@@ -88,7 +88,7 @@ def strip_ssh_from_git_uri(uri):
 
 
 def add_ssh_scheme_to_git_uri(uri):
-    """Cleans VCS uris from pip format"""
+    """Cleans VCS uris from pipenv.patched.notpip format"""
     if isinstance(uri, six.string_types):
         # Add scheme for parsing purposes, this is also what pip does
         if uri.startswith("git+") and "://" not in uri:
diff --git a/pipenv/vendor/vistir/__init__.py b/pipenv/vendor/vistir/__init__.py
index f3554d56..809c973c 100644
--- a/pipenv/vendor/vistir/__init__.py
+++ b/pipenv/vendor/vistir/__init__.py
@@ -31,7 +31,7 @@ from .path import mkdir_p, rmtree, create_tracked_tempdir, create_tracked_tempfi
 from .spin import VistirSpinner, create_spinner
 
 
-__version__ = "0.2.4"
+__version__ = '0.2.4'
 
 
 __all__ = [
diff --git a/pipenv/vendor/vistir/contextmanagers.py b/pipenv/vendor/vistir/contextmanagers.py
index 3f191120..0920a9c3 100644
--- a/pipenv/vendor/vistir/contextmanagers.py
+++ b/pipenv/vendor/vistir/contextmanagers.py
@@ -63,7 +63,7 @@ def cd(path):
     >>> print(os.path.abspath(os.curdir))
     '/home/user/code/myrepo'
     >>> with cd("/home/user/code/otherdir/subdir"):
-            print("Changed directory: %s" % os.path.abspath(os.curdir))
+    ...     print("Changed directory: %s" % os.path.abspath(os.curdir))
     Changed directory: /home/user/code/otherdir/subdir
     >>> print(os.path.abspath(os.curdir))
     '/home/user/code/myrepo'
diff --git a/pipenv/vendor/vistir/path.py b/pipenv/vendor/vistir/path.py
index 23ae0252..febaddbc 100644
--- a/pipenv/vendor/vistir/path.py
+++ b/pipenv/vendor/vistir/path.py
@@ -1,5 +1,5 @@
 # -*- coding=utf-8 -*-
-from __future__ import absolute_import, unicode_literals
+from __future__ import absolute_import, unicode_literals, print_function
 
 import atexit
 import errno
@@ -275,9 +275,12 @@ def set_write_bit(fn):
     file_stat = os.stat(fn).st_mode
     os.chmod(fn, file_stat | stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)
     if not os.path.isdir(fn):
-        return
+        try:
+            os.chflags(fn, 0)
+        except AttributeError:
+            pass
     for root, dirs, files in os.walk(fn, topdown=False):
-        for dir_ in [os.path.join(root, d) for d in dirs]:
+        for dir_ in [os.path.join(root,d) for d in dirs]:
             set_write_bit(dir_)
         for file_ in [os.path.join(root, f) for f in files]:
             set_write_bit(file_)

commit 6604712760ad5133b8a114defde43f143c258018
Author: Dan Ryan <dan@danryan.co>
Date:   Mon Feb 25 15:09:00 2019 -0500

    Create requirements inside spinner for better UX
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/core.py b/pipenv/core.py
index 6eaca769..a842bbc8 100644
--- a/pipenv/core.py
+++ b/pipenv/core.py
@@ -1047,12 +1047,9 @@ def do_lock(
                 err=True,
             )
 
-        deps = convert_deps_to_pip(
-            packages, project, r=False, include_index=True
-        )
         # Mutates the lockfile
         venv_resolve_deps(
-            deps,
+            packages,
             which=which,
             project=project,
             dev=is_dev,
diff --git a/pipenv/resolver.py b/pipenv/resolver.py
index 29672726..c4522780 100644
--- a/pipenv/resolver.py
+++ b/pipenv/resolver.py
@@ -345,11 +345,11 @@ class Entry(object):
             constraint.check_if_exists(False)
         except Exception:
             from pipenv.exceptions import DependencyConflict
-            msg = "Cannot resolve conflicting version {0}{1}".format(
-                self.name, self.updated_specifiers
-            )
-            msg = "{0} while {1}{2} is locked.".format(
-                self.old_name, self.old_specifiers
+            msg = (
+                "Cannot resolve conflicting version {0}{1} while {1}{2} is "
+                "locked.".format(
+                    self.name, self.updated_specifier, self.old_name, self.old_specifiers
+                )
             )
             raise DependencyConflict(msg)
         else:
@@ -358,12 +358,17 @@ class Entry(object):
                 satisfied_by = "{0}".format(self.clean_specifier(
                     str(constraint.satisfied_by.version)
                 ))
-                if self.updated_specifiers != satisfied_by:
+                if self.updated_specifier != satisfied_by:
                     self.entry_dict["version"] = satisfied_by
-                    self.entry_dict["hashes"] = []
-                    self._entry.hashes = set()
                     if self.lockfile_entry.specifiers == satisfied_by:
-                        self._entry.hashes = self.lockfile_entry.hashes
+                        if not self.lockfile_entry.hashes:
+                            hashes = self.resolver.get_hash(self.lockfile_entry.as_ireq())
+                        else:
+                            hashes = self.lockfile_entry.hashes
+                    else:
+                        hashes = self.resolver.get_hash(constraint)
+                    self.entry_dict["hashes"] = list(hashes)
+                    self._entry.hashes = frozenset(hashes)
             else:
                 # check for any parents, since they depend on this and the current
                 # installed versions are not compatible with the new version, so
@@ -436,8 +441,9 @@ def clean_outdated(results, resolver, project, dev=False):
         # TODO: Should this be the case for all locking?
         if entry.was_editable and not entry.is_editable:
             continue
+        # if the entry has not changed versions since the previous lock,
         # don't introduce new markers since that is more restrictive
-        if entry.has_markers and not entry.had_markers:
+        if entry.has_markers and not entry.had_markers and not entry.is_updated:
             del entry.entry_dict["markers"]
             entry._entry.req.req.marker = None
             entry._entry.markers = ""
diff --git a/pipenv/utils.py b/pipenv/utils.py
index 406886fe..4efc59c3 100644
--- a/pipenv/utils.py
+++ b/pipenv/utils.py
@@ -633,7 +633,9 @@ class Resolver(object):
         # The entire purpose of this approach is to include missing hashes.
         # This fixes a race condition in resolution for missing dependency caches
         # see pypa/pipenv#3289
-        if self._should_include_hash(ireq) and (
+        if not self._should_include_hash(ireq):
+            return set()
+        elif self._should_include_hash(ireq) and (
             not ireq_hashes or ireq.link.scheme == "file"
         ):
             if not ireq_hashes:
@@ -907,6 +909,7 @@ def venv_resolve_deps(
     from .vendor.vistir.compat import Path, JSONDecodeError
     from .vendor.vistir.path import create_tracked_tempdir
     from . import resolver
+    from ._compat import decode_for_output
     import json
 
     results = []
@@ -915,12 +918,7 @@ def venv_resolve_deps(
     if not deps:
         if not project.pipfile_exists:
             return None
-        # This is a requirementslib pipfile instance which provides `Requirement` instances
-        # rather than simply locked dependencies in a lockfile format
-        deps = convert_deps_to_pip(
-            project.parsed_pipfile.get(pipfile_section, {}), project=project,
-            r=False, include_index=True
-        )
+        deps = project.parsed_pipfile.get(pipfile_section, {})
     if not deps:
         return None
 
@@ -929,7 +927,6 @@ def venv_resolve_deps(
     if not lockfile:
         lockfile = project._lockfile
     req_dir = create_tracked_tempdir(prefix="pipenv", suffix="requirements")
-    constraints = set(deps)
     cmd = [
         which("python", allow_global=allow_global),
         Path(resolver.__file__.rstrip("co")).as_posix()
@@ -944,7 +941,6 @@ def venv_resolve_deps(
         cmd.append("--dev")
     with temp_environ():
         os.environ.update({fs_str(k): fs_str(val) for k, val in os.environ.items()})
-        os.environ["PIPENV_PACKAGES"] = str("\n".join(constraints))
         if pypi_mirror:
             os.environ["PIPENV_PYPI_MIRROR"] = str(pypi_mirror)
         os.environ["PIPENV_VERBOSITY"] = str(environments.PIPENV_VERBOSITY)
@@ -953,7 +949,18 @@ def venv_resolve_deps(
         os.environ["PIPENV_SITE_DIR"] = get_pipenv_sitedir()
         if keep_outdated:
             os.environ["PIPENV_KEEP_OUTDATED"] = fs_str("1")
-        with create_spinner(text=fs_str("Locking...")) as sp:
+        with create_spinner(text=decode_for_output("Locking...")) as sp:
+            # This conversion is somewhat slow on local and file-type requirements since
+            # we now download those requirements / make temporary folders to perform
+            # dependency resolution on them, so we are including this step inside the
+            # spinner context manager for the UX improvement
+            sp.write(decode_for_output("Building requirements..."))
+            deps = convert_deps_to_pip(
+                deps, project, r=False, include_index=True
+            )
+            constraints = set(deps)
+            os.environ["PIPENV_PACKAGES"] = str("\n".join(constraints))
+            sp.write(decode_for_output("Resolving dependencies..."))
             c = resolve(cmd, sp)
             results = c.out.strip()
             sp.green.ok(environments.PIPENV_SPINNER_OK_TEXT.format("Success!"))

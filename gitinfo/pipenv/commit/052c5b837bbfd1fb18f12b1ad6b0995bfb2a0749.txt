commit 052c5b837bbfd1fb18f12b1ad6b0995bfb2a0749
Author: Dan Ryan <dan@danryan.co>
Date:   Wed Nov 21 17:15:56 2018 -0500

    Create sample implementation for keep outdated functionality
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/core.py b/pipenv/core.py
index 7f488aea..e112b6fe 100644
--- a/pipenv/core.py
+++ b/pipenv/core.py
@@ -1051,7 +1051,8 @@ def do_lock(
             allow_global=system,
             pypi_mirror=pypi_mirror,
             pipfile=packages,
-            lockfile=lockfile
+            lockfile=lockfile,
+            keep_outdated=keep_outdated
         )
 
     # Support for --keep-outdatedâ€¦
@@ -1068,6 +1069,12 @@ def do_lock(
                         lockfile[section_name][canonical_name] = cached_lockfile[
                             section_name
                         ][canonical_name].copy()
+            for key in ["default", "develop"]:
+                packages = set(cached_lockfile[key].keys())
+                new_lockfile = set(lockfile[key].keys())
+                missing = packages - new_lockfile
+                for missing_pkg in missing:
+                    lockfile[key][missing_pkg] = cached_lockfile[key][missing_pkg].copy()
     # Overwrite any develop packages with default packages.
     lockfile["develop"].update(overwrite_dev(lockfile.get("default", {}), lockfile["develop"]))
     if write:
diff --git a/pipenv/environment.py b/pipenv/environment.py
index 7558f94c..2b4d0e7e 100644
--- a/pipenv/environment.py
+++ b/pipenv/environment.py
@@ -379,6 +379,47 @@ class Environment(object):
             return d
         return [aux(p) for p in nodes]
 
+    @classmethod
+    def reverse_dependency(cls, node):
+        new_node = {
+            "package_name": node["package_name"],
+            "installed_version": node["installed_version"],
+            "required_version": node["required_version"]
+        }
+        for dependency in node.get("dependencies", []):
+            for dep in cls.reverse_dependency(dependency):
+                new_dep = dep.copy()
+                new_dep["parent"] = (node["package_name"], node["installed_version"])
+                yield new_dep
+        yield new_node
+
+    def reverse_dependencies(self):
+        from vistir.misc import unnest
+        rdeps = {}
+        for req in self.get_package_requirements():
+            for d in self.reverse_dependency(req):
+                name = d["package_name"]
+                pkg = {
+                    name: {
+                        "installed": d["installed_version"],
+                        "required": d["required_version"]
+                    }
+                }
+                if d.get("parent"):
+                    pkg[name]["parents"] = list(d["parent"])
+                if rdeps.get(name):
+                    if rdeps[name].get("parents"):
+                        rdeps[name]["parents"].append(pkg[name]["parents"])
+                    else:
+                        rdeps[name].update(pkg[name])
+                else:
+                    rdeps.update(pkg)
+        for k in list(rdeps.keys()):
+            entry = rdeps[k]
+            if entry.get("parents"):
+                rdeps[k]["parents"] = set([p for p in unnest(entry["parents"])])
+        return rdeps
+
     def get_working_set(self):
         """Retrieve the working set of installed packages for the environment.
 
diff --git a/pipenv/exceptions.py b/pipenv/exceptions.py
index 62e25d53..efb784b2 100644
--- a/pipenv/exceptions.py
+++ b/pipenv/exceptions.py
@@ -273,6 +273,15 @@ class CacheError(PipenvException):
         super(PipenvException, self).__init__(message=fix_utf8(message))
 
 
+class DependencyConflict(PipenvException):
+    def __init__(self, message):
+        extra = [fix_utf8("{0} {1}".format(
+            crayons.red("ERROR:", bold=True),
+            crayons.white("A dependency conflict was detected and could not be resolved.", bold=True),
+        )),]
+        super(DependencyConflict, self).__init__(fix_utf8(message), extra=extra)
+
+
 class ResolutionFailure(PipenvException):
     def __init__(self, message, no_version_found=False):
         extra = (
diff --git a/pipenv/resolver.py b/pipenv/resolver.py
index e87f3243..4ae92b57 100644
--- a/pipenv/resolver.py
+++ b/pipenv/resolver.py
@@ -21,6 +21,7 @@ def get_parser():
     parser.add_argument("--pre", action="store_true", default=False)
     parser.add_argument("--clear", action="store_true", default=False)
     parser.add_argument("--verbose", "-v", action="count", default=False)
+    parser.add_argument("--dev", action="store_true", default=False)
     parser.add_argument("--debug", action="store_true", default=False)
     parser.add_argument("--system", action="store_true", default=False)
     parser.add_argument("--requirements-dir", metavar="requirements_dir", action="store",
@@ -45,7 +46,64 @@ def handle_parsed_args(parsed):
     return parsed
 
 
-def _main(pre, clear, verbose, system, requirements_dir, packages):
+def clean_outdated(results, resolver, project, dev=False):
+    from .vendor.requirementslib.models.requirements import Requirement
+    if not project.lockfile_exists:
+        return results
+    lockfile = project.lockfile_content
+    section = "develop" if dev else "default"
+    pipfile_section = "dev-packages" if dev else "packages"
+    overlapping_results = [r["name"] for r in results if r["name"] in lockfile[section]]
+    new_results = []
+    constraint_names = [r.name for r in constraints]
+    for result in results:
+        if result["name"] not in overlapping_results:
+            new_results.append(result)
+            continue
+
+        name = result["name"]
+        entry_dict = result.copy()
+        entry_dict["version"] = "=={0}".format(entry_dict["version"])
+        del entry_dict["name"]
+        entry = Requirement.from_pipfile(name, entry_dict)
+        lockfile_entry = Requirement.from_pipfile(name, lockfile[section][name])
+        # TODO: Should this be the case for all locking?
+        if lockfile_entry.editable and not entry.editable:
+            continue
+        # don't introduce new markers since that is more restrictive
+        if entry.markers and not lockfile_entry.markers:
+            del entry_dict["markers"]
+        if entry.specifiers != lockfile_entry.specifiers:
+            constraint = next(iter(
+                c for c in resolver.parsed_constraints if c.name == entry.name
+            ), None)
+            if constraint:
+                try:
+                    constraint.check_if_exists(False)
+                except Exception:
+                    from .exceptions import DependencyConflict
+                    msg = "Cannot resolve conflicting version {0}{1}".format(
+                        entry.name, entry.specifiers
+                    )
+                    msg = "{0} while {1}{2} is locked.".format(
+                        lockfile_entry.name, lockfile_entry.specifiers
+                    )
+                    raise DependencyConflict(msg)
+                else:
+                    entry_dict["version"] = constraint.satisfied_by.version
+        if entry.extras != entry.extras:
+            entry.req.extras.extend(lockfile_entry.req.extras)
+            entry_dict["extras"] = entry.extras
+        entry_hashes = set(entry.hashes)
+        locked_hashes = set(lockfile_entry.hashes)
+        if entry_hashes != locked_hashes:
+            entry_dict["hashes"] = list(entry_hashes | locked_hashes)
+        entry_dict["name"] = name
+        new_results.append(entry_dict)
+    return new_results
+
+
+def _main(pre, clear, verbose, system, requirements_dir, dev, packages):
     os.environ["PIP_PYTHON_VERSION"] = ".".join([str(s) for s in sys.version_info[:3]])
     os.environ["PIP_PYTHON_PATH"] = str(sys.executable)
 
@@ -75,7 +133,8 @@ def _main(pre, clear, verbose, system, requirements_dir, packages):
         if pypi_mirror_source
         else project.pipfile_sources
     )
-    results = resolve(
+    keep_outdated = os.environ.get("PIPENV_KEEP_OUTDATED", False)
+    results, resolver = resolve(
         packages,
         pre=pre,
         project=project,
@@ -84,6 +143,8 @@ def _main(pre, clear, verbose, system, requirements_dir, packages):
         system=system,
         requirements_dir=requirements_dir,
     )
+    if keep_outdated:
+        results = clean_outdated(results, resolver, project)
     print("RESULTS:")
     if results:
         print(json.dumps(results))
@@ -116,7 +177,7 @@ def main():
     # sys.argv = remaining
     parsed = handle_parsed_args(parsed)
     _main(parsed.pre, parsed.clear, parsed.verbose, parsed.system,
-          parsed.requirements_dir, parsed.packages)
+          parsed.requirements_dir, parsed.dev, parsed.packages)
 
 
 if __name__ == "__main__":
diff --git a/pipenv/utils.py b/pipenv/utils.py
index 1c3e7bf2..6fd4cf43 100644
--- a/pipenv/utils.py
+++ b/pipenv/utils.py
@@ -576,7 +576,8 @@ def venv_resolve_deps(
     pypi_mirror=None,
     dev=False,
     pipfile=None,
-    lockfile=None
+    lockfile=None,
+    keep_outdated=False
 ):
     from .vendor.vistir.misc import fs_str
     from .vendor.vistir.compat import Path, to_native_string, JSONDecodeError
@@ -620,6 +621,8 @@ def venv_resolve_deps(
         cmd.append("--clear")
     if allow_global:
         cmd.append("--system")
+    if dev:
+        cmd.append("--dev")
     with temp_environ():
         os.environ = {fs_str(k): fs_str(val) for k, val in os.environ.items()}
         os.environ["PIPENV_PACKAGES"] = str("\n".join(deps))
@@ -627,6 +630,8 @@ def venv_resolve_deps(
             os.environ["PIPENV_PYPI_MIRROR"] = str(pypi_mirror)
         os.environ["PIPENV_VERBOSITY"] = str(environments.PIPENV_VERBOSITY)
         os.environ["PIPENV_REQ_DIR"] = fs_str(req_dir)
+        if keep_outdated:
+            os.environ["PIPENV_KEEP_OUTDATED"] = fs_str("1")
         os.environ["PIP_NO_INPUT"] = fs_str("1")
         with create_spinner(text=fs_str("Locking...")) as sp:
             c = resolve(cmd, sp)
@@ -787,7 +792,7 @@ def resolve_deps(
                 entry.update({"markers": markers_lookup.get(result.name)})
             entry = translate_markers(entry)
             results.append(entry)
-    return results
+    return (results, resolver)
 
 
 def is_star(val):

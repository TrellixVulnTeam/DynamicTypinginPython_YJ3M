commit ee093c5b13af2bf145337f8eae28c47636d12d98
Author: Dan Ryan <dan.ryan@canonical.com>
Date:   Mon Mar 30 17:45:30 2020 -0400

    Update pip version-specific code
    
    - Use shimmed `InstallCommand` from `pip_shims`
    - Update `PackageFinder` usage
    - Fix attempts to stringify `Bool` instances from tomlkit
    - Add fallback for direct URL resolution
    - Update `Requirementslib` with bugfix
    
    Signed-off-by: Dan Ryan <dan.ryan@canonical.com>

diff --git a/pipenv/environment.py b/pipenv/environment.py
index b57a858a..d472e345 100644
--- a/pipenv/environment.py
+++ b/pipenv/environment.py
@@ -466,7 +466,7 @@ class Environment(object):
         ), None)
         if pip is not None:
             return parse_version(pip.version)
-        return parse_version("18.0")
+        return parse_version("19.3")
 
     def get_distributions(self):
         """
@@ -529,42 +529,21 @@ class Environment(object):
     @contextlib.contextmanager
     def get_finder(self, pre=False):
         from .vendor.pip_shims.shims import (
-            Command, cmdoptions, index_group, PackageFinder, parse_version, pip_version
+            InstallCommand, get_package_finder
         )
         from .environments import PIPENV_CACHE_DIR
-        index_urls = [source.get("url") for source in self.sources]
 
-        class PipCommand(Command):
-            name = "PipCommand"
-
-        pip_command = PipCommand()
-        index_opts = cmdoptions.make_option_group(
-            index_group, pip_command.parser
-        )
-        cmd_opts = pip_command.cmd_opts
-        pip_command.parser.insert_option_group(0, index_opts)
-        pip_command.parser.insert_option_group(0, cmd_opts)
+        pip_command = InstallCommand()
         pip_args = self._modules["pipenv"].utils.prepare_pip_source_args(self.sources)
         pip_options, _ = pip_command.parser.parse_args(pip_args)
         pip_options.cache_dir = PIPENV_CACHE_DIR
         pip_options.pre = self.pipfile.get("pre", pre)
         with pip_command._build_session(pip_options) as session:
-            finder_args = {
-                "find_links": pip_options.find_links,
-                "index_urls": index_urls,
-                "allow_all_prereleases": pip_options.pre,
-                "trusted_hosts": pip_options.trusted_hosts,
-                "session": session
-            }
-            if parse_version(pip_version) < parse_version("19.0"):
-                finder_args.update(
-                    {"process_dependency_links": pip_options.process_dependency_links}
-                )
-            finder = PackageFinder(**finder_args)
+            finder = get_package_finder(install_cmd=pip_command, options=pip_options, session=session)
             yield finder
 
     def get_package_info(self, pre=False):
-        from .vendor.pip_shims.shims import pip_version, parse_version
+        from .vendor.pip_shims.shims import pip_version, parse_version, CandidateEvaluator
         dependency_links = []
         packages = self.get_installed_packages()
         # This code is borrowed from pip's current implementation
@@ -591,9 +570,10 @@ class Environment(object):
 
                 if not all_candidates:
                     continue
-                best_candidate = max(all_candidates, key=finder._candidate_sort_key)
-                remote_version = best_candidate.version
-                if best_candidate.location.is_wheel:
+                candidate_evaluator = finder.make_candidate_evaluator(project_name=dist.key)
+                best_candidate_result = candidate_evaluator.compute_best_candidate(all_candidates)
+                remote_version = best_candidate_result.best_candidate.version
+                if best_candidate_result.best_candidate.link.is_wheel:
                     typ = 'wheel'
                 else:
                     typ = 'sdist'
diff --git a/pipenv/project.py b/pipenv/project.py
index 5b14106e..4cb2ff9c 100644
--- a/pipenv/project.py
+++ b/pipenv/project.py
@@ -723,7 +723,7 @@ class Project(object):
         if "verify_ssl" not in source:
             source["verify_ssl"] = "https://" in source["url"]
         if not isinstance(source["verify_ssl"], bool):
-            source["verify_ssl"] = source["verify_ssl"].lower() == "true"
+            source["verify_ssl"] = str(source["verify_ssl"]).lower() == "true"
         return source
 
     def get_or_create_lockfile(self, from_pipfile=False):
diff --git a/pipenv/utils.py b/pipenv/utils.py
index 680b7e21..98754f69 100644
--- a/pipenv/utils.py
+++ b/pipenv/utils.py
@@ -472,6 +472,7 @@ class Resolver(object):
     ):
         # type: (...) -> Tuple[Requirement, Dict[str, str], Dict[str, str]]
         from .vendor.requirementslib.models.requirements import Requirement
+        from .vendor.requirementslib.models.utils import DIRECT_URL_RE
         if index_lookup is None:
             index_lookup = {}
         if markers_lookup is None:
@@ -488,7 +489,15 @@ class Resolver(object):
         try:
             req = Requirement.from_line(line)
         except ValueError:
-            raise ResolutionFailure("Failed to resolve requirement from line: {0!s}".format(line))
+            direct_url = DIRECT_URL_RE.match(line)
+            if direct_url:
+                line = "{0}#egg={1}".format(line, direct_url.groupdict()["name"])
+                try:
+                    req = Requirement.from_line(line)
+                except ValueError:
+                    raise ResolutionFailure("Failed to resolve requirement from line: {0!s}".format(line))
+            else:
+                raise ResolutionFailure("Failed to resolve requirement from line: {0!s}".format(line))
         if url:
             try:
                 index_lookup[req.normalized_name] = project.get_source(
diff --git a/pipenv/vendor/requirementslib/models/setup_info.py b/pipenv/vendor/requirementslib/models/setup_info.py
index 38fffd4f..81b4b715 100644
--- a/pipenv/vendor/requirementslib/models/setup_info.py
+++ b/pipenv/vendor/requirementslib/models/setup_info.py
@@ -219,13 +219,13 @@ def setuptools_parse_setup_cfg(path):
 
     parsed = read_configuration(path)
     results = parsed.get("metadata", {})
-    results.update({parsed.get("options", {})})
+    results.update(parsed.get("options", {}))
     results["install_requires"] = make_base_requirements(
         results.get("install_requires", [])
     )
     extras = {}
-    for extras_section, extras in results.get("extras_require", {}).items():
-        new_reqs = tuple(make_base_requirements(extras))
+    for extras_section, extras_reqs in results.get("extras_require", {}).items():
+        new_reqs = tuple(make_base_requirements(extras_reqs))
         if new_reqs:
             extras[extras_section] = new_reqs
     results["extras_require"] = extras

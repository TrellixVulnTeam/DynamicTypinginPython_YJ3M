commit 573174d188dbfaa60a48bd80f1c2e88fee3842dd
Author: Dan Ryan <dan@danryan.co>
Date:   Fri Oct 12 21:46:33 2018 -0400

    Fix pipenv clean and editable installs
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/core.py b/pipenv/core.py
index 04ac5a83..37afdc59 100644
--- a/pipenv/core.py
+++ b/pipenv/core.py
@@ -1315,6 +1315,12 @@ def pip_install(
     from .vendor.urllib3.util import parse_url
 
     src = []
+    write_to_tmpfile = False
+    if requirement:
+        editable_with_markers = requirement.editable and requirement.markers
+        needs_hashes = not requirement.editable and not ignore_hashes and r is None
+        write_to_tmpfile = needs_hashes or editable_with_markers
+
     if not trusted_hosts:
         trusted_hosts = []
     trusted_hosts.extend(os.environ.get("PIP_TRUSTED_HOSTS", []))
@@ -1326,12 +1332,13 @@ def pip_install(
                 err=True,
             )
     # Create files for hash mode.
-    if requirement and not requirement.editable and (not ignore_hashes) and (r is None):
-        fd, r = tempfile.mkstemp(
-            prefix="pipenv-", suffix="-requirement.txt", dir=requirements_dir
-        )
-        with os.fdopen(fd, "w") as f:
-            f.write(requirement.as_line())
+    if write_to_tmpfile:
+        with vistir.compat.NamedTemporaryFile(
+            prefix="pipenv-", suffix="-requirement.txt", dir=requirements_dir,
+            delete=False
+        ) as f:
+            f.write(vistir.misc.to_bytes(requirement.as_line()))
+            r = f.name
     # Install dependencies when a package is a VCS dependency.
     if requirement and requirement.vcs:
         no_deps = False
@@ -1374,7 +1381,7 @@ def pip_install(
             create_mirror_source(pypi_mirror) if is_pypi_url(source["url"]) else source
             for source in sources
         ]
-    if (requirement and requirement.editable) or not r:
+    if (requirement and requirement.editable) and not r:
         install_reqs = requirement.as_line(as_list=True)
         if requirement.editable and install_reqs[0].startswith("-e "):
             req, install_reqs = install_reqs[0], install_reqs[1:]
@@ -1402,6 +1409,7 @@ def pip_install(
     install_reqs = [escape_cmd(req) for req in install_reqs]
     pip_command.extend(install_reqs)
     pip_command.extend(prepare_pip_source_args(sources))
+    print(pip_command)
     if not ignore_hashes:
         pip_command.append("--require-hashes")
 
@@ -2509,24 +2517,28 @@ def do_sync(
 
 def do_clean(ctx, three=None, python=None, dry_run=False, bare=False, pypi_mirror=None):
     # Ensure that virtualenv is available.
-
+    from packaging.utils import canonicalize_name
     ensure_project(three=three, python=python, validate=False, pypi_mirror=pypi_mirror)
     ensure_lockfile(pypi_mirror=pypi_mirror)
     installed_package_names = [
-        pkg.project_name for pkg in project.get_installed_packages()
+        canonicalize_name(pkg.project_name) for pkg in project.get_installed_packages()
     ]
     # Remove known "bad packages" from the list.
     for bad_package in BAD_PACKAGES:
-        if bad_package in installed_package_names:
+        if canonicalize_name(bad_package) in installed_package_names:
             if environments.is_verbose():
                 click.echo("Ignoring {0}.".format(repr(bad_package)), err=True)
-            del installed_package_names[installed_package_names.index(bad_package)]
+            del installed_package_names[installed_package_names.index(
+                canonicalize_name(bad_package)
+            )]
     # Intelligently detect if --dev should be used or not.
-    develop = [k.lower() for k in project.lockfile_content["develop"].keys()]
-    default = [k.lower() for k in project.lockfile_content["default"].keys()]
+    develop = [canonicalize_name(k) for k in project.lockfile_content["develop"].keys()]
+    default = [canonicalize_name(k) for k in project.lockfile_content["default"].keys()]
     for used_package in set(develop + default):
         if used_package in installed_package_names:
-            del installed_package_names[installed_package_names.index(used_package)]
+            del installed_package_names[installed_package_names.index(
+                canonicalize_name(used_package)
+            )]
     failure = False
     for apparent_bad_package in installed_package_names:
         if dry_run:

commit 68f84851a3e0a1a962eae44f50e1adaabe961aba
Author: Kenneth Reitz <me@kennethreitz.org>
Date:   Thu Sep 14 19:56:28 2017 -0400

    toml — use inline tables!!!!
    
    Fixes #193
    
    Signed-off-by: Kenneth Reitz <me@kennethreitz.org>

diff --git a/pipenv/project.py b/pipenv/project.py
index 51296122..c176de0e 100644
--- a/pipenv/project.py
+++ b/pipenv/project.py
@@ -294,7 +294,16 @@ class Project(object):
         if path is None:
             path = self.pipfile_location
 
-        formatted_data = format_toml(toml.dumps(data))
+        for section in ('packages', 'dev-packages'):
+            for package in data[section]:
+
+                # Convert things to inline tables — fancy :)
+                if hasattr(data[section][package], 'keys'):
+                    _data = data[section][package]
+                    data[section][package] = toml._get_empty_inline_table(dict)
+                    data[section][package].update(_data)
+
+        formatted_data = format_toml(toml.dumps(data, preserve=True))
         with open(path, 'w') as f:
             f.write(formatted_data)
 
diff --git a/pipenv/vendor/toml.py b/pipenv/vendor/toml.py
old mode 100644
new mode 100755
index dedddbb3..ebbaed68
--- a/pipenv/vendor/toml.py
+++ b/pipenv/vendor/toml.py
@@ -1,30 +1,56 @@
-# This software is released under the MIT license
+"""Python module which parses and emits TOML.
 
+Released under the MIT license.
+"""
 import re
+import io
 import datetime
+from os import linesep
+
+__version__ = "0.9.2"
+__spec__ = "0.4.0"
+
 
 class TomlDecodeError(Exception):
+    """Base toml Exception / Error."""
     pass
 
-class TomlTz(datetime.tzinfo):
 
+class TomlTz(datetime.tzinfo):
     def __init__(self, toml_offset):
         if toml_offset == "Z":
             self._raw_offset = "+00:00"
         else:
             self._raw_offset = toml_offset
-        self._hours = int(self._raw_offset[:3])
+        self._sign = -1 if self._raw_offset[0] == '-' else 1
+        self._hours = int(self._raw_offset[1:3])
         self._minutes = int(self._raw_offset[4:6])
 
     def tzname(self, dt):
-        return "UTC"+self._raw_offset
+        return "UTC" + self._raw_offset
 
     def utcoffset(self, dt):
-        return datetime.timedelta(hours=self._hours, minutes=self._minutes)
+        return self._sign * datetime.timedelta(hours=self._hours,
+                                               minutes=self._minutes)
 
     def dst(self, dt):
         return datetime.timedelta(0)
 
+
+class InlineTableDict(object):
+    """Sentinel subclass of dict for inline tables."""
+
+
+def _get_empty_inline_table(_dict):
+    class DynamicInlineTableDict(_dict, InlineTableDict):
+        """Concrete sentinel subclass for inline tables.
+        It is a subclass of _dict which is passed in dynamically at load time
+        It is also a subclass of InlineTableDict
+        """
+
+    return DynamicInlineTableDict()
+
+
 try:
     _range = xrange
 except NameError:
@@ -33,37 +59,85 @@ except NameError:
     basestring = str
     unichr = chr
 
+try:
+    FNFError = FileNotFoundError
+except NameError:
+    FNFError = IOError
+
+
 def load(f, _dict=dict):
-    """Returns a dictionary containing the named file parsed as toml."""
+    """Parses named file or files as toml and returns a dictionary
+
+    Args:
+        f: Path to the file to open, array of files to read into single dict
+           or a file descriptor
+        _dict: (optional) Specifies the class of the returned toml dictionary
+
+    Returns:
+        Parsed toml file represented as a dictionary
+
+    Raises:
+        TypeError -- When f is invalid type
+        TomlDecodeError: Error while decoding toml
+        IOError / FileNotFoundError -- When an array with no valid (existing)
+        (Python 2 / Python 3)          file paths is passed
+    """
+
     if isinstance(f, basestring):
-        with open(f) as ffile:
+        with io.open(f, encoding='utf-8') as ffile:
             return loads(ffile.read(), _dict)
     elif isinstance(f, list):
-        for l in f:
-            if not isinstance(l, basestring):
-                raise TypeError("Load expects a list to contain filenames only")
+        from os import path as op
+        from warnings import warn
+        if not [path for path in f if op.exists(path)]:
+            error_msg = "Load expects a list to contain filenames only."
+            error_msg += linesep
+            error_msg += ("The list needs to contain the path of at least one "
+                          "existing file.")
+            raise FNFError(error_msg)
         d = _dict()
         for l in f:
-            d.update(load(l))
+            if op.exists(l):
+                d.update(load(l))
+            else:
+                warn("Non-existent filename in list with at least one valid "
+                     "filename")
         return d
-    elif f.read:
-        return loads(f.read(), _dict)
     else:
-        raise TypeError("You can only load a file descriptor, filename or list")
+        try:
+            return loads(f.read(), _dict)
+        except AttributeError:
+            raise TypeError("You can only load a file descriptor, filename or "
+                            "list")
+
 
 _groupname_re = re.compile(r'^[A-Za-z0-9_-]+$')
 
+
 def loads(s, _dict=dict):
-    """Returns a dictionary containing s, a string, parsed as toml."""
+    """Parses string as toml
+
+    Args:
+        s: String to be parsed
+        _dict: (optional) Specifies the class of the returned toml dictionary
+
+    Returns:
+        Parsed toml file represented as a dictionary
+
+    Raises:
+        TypeError: When a non-string is passed
+        TomlDecodeError: Error while decoding toml
+    """
+
     implicitgroups = []
     retval = _dict()
     currentlevel = retval
     if not isinstance(s, basestring):
-        raise TypeError("What exactly are you trying to pull?")
-    try:
+        raise TypeError("Expecting something like a string")
+
+    if not isinstance(s, unicode):
         s = s.decode('utf8')
-    except AttributeError:
-        pass
+
     sl = list(s)
     openarr = 0
     openstring = False
@@ -73,35 +147,37 @@ def loads(s, _dict=dict):
     beginline = True
     keygroup = False
     keyname = 0
-    for i in _range(len(sl)):
-        if sl[i] == '\r' and sl[i+1] == '\n':
+    for i, item in enumerate(sl):
+        if item == '\r' and sl[i + 1] == '\n':
             sl[i] = ' '
             continue
         if keyname:
-            if sl[i] == '\n':
-                raise TomlDecodeError("Key name found without value. Reached end of line.")
+            if item == '\n':
+                raise TomlDecodeError("Key name found without value."
+                                      " Reached end of line.")
             if openstring:
-                if sl[i] == openstrchar:
+                if item == openstrchar:
                     keyname = 2
                     openstring = False
                     openstrchar = ""
                 continue
             elif keyname == 1:
-                if sl[i].isspace():
+                if item.isspace():
                     keyname = 2
                     continue
-                elif sl[i].isalnum() or sl[i] == '_' or sl[i] == '-':
+                elif item.isalnum() or item == '_' or item == '-':
                     continue
-            elif keyname == 2 and sl[i].isspace():
+            elif keyname == 2 and item.isspace():
                 continue
-            if sl[i] == '=':
+            if item == '=':
                 keyname = 0
             else:
-                raise TomlDecodeError("Found invalid character in key name: '"+sl[i]+"'. Try quoting the key name.")
-        if sl[i] == "'" and openstrchar != '"':
+                raise TomlDecodeError("Found invalid character in key name: '" +
+                                      item + "'. Try quoting the key name.")
+        if item == "'" and openstrchar != '"':
             k = 1
             try:
-                while sl[i-k] == "'":
+                while sl[i - k] == "'":
                     k += 1
                     if k == 3:
                         break
@@ -116,19 +192,20 @@ def loads(s, _dict=dict):
                 openstrchar = "'"
             else:
                 openstrchar = ""
-        if sl[i] == '"' and openstrchar != "'":
+        if item == '"' and openstrchar != "'":
             oddbackslash = False
             k = 1
             tripquote = False
             try:
-                while sl[i-k] == '"':
+                while sl[i - k] == '"':
                     k += 1
                     if k == 3:
                         tripquote = True
                         break
-                while sl[i-k] == '\\':
-                    oddbackslash = not oddbackslash
-                    k += 1
+                if k == 1 or (k == 3 and tripquote):
+                    while sl[i - k] == '\\':
+                        oddbackslash = not oddbackslash
+                        k += 1
             except IndexError:
                 pass
             if not oddbackslash:
@@ -141,8 +218,8 @@ def loads(s, _dict=dict):
                 openstrchar = '"'
             else:
                 openstrchar = ""
-        if sl[i] == '#' and not openstring and not keygroup and \
-                not arrayoftables:
+        if item == '#' and (not openstring and not keygroup and
+                            not arrayoftables):
             j = i
             try:
                 while sl[j] != '\n':
@@ -150,30 +227,32 @@ def loads(s, _dict=dict):
                     j += 1
             except IndexError:
                 break
-        if sl[i] == '[' and not openstring and not keygroup and \
-                not arrayoftables:
+        if item == '[' and (not openstring and not keygroup and
+                            not arrayoftables):
             if beginline:
-                if sl[i+1] == '[':
+                if sl[i + 1] == '[':
                     arrayoftables = True
                 else:
                     keygroup = True
             else:
                 openarr += 1
-        if sl[i] == ']' and not openstring:
+        if item == ']' and not openstring:
             if keygroup:
                 keygroup = False
             elif arrayoftables:
-                if sl[i-1] == ']':
+                if sl[i - 1] == ']':
                     arrayoftables = False
             else:
                 openarr -= 1
-        if sl[i] == '\n':
+        if item == '\n':
             if openstring or multilinestr:
                 if not multilinestr:
                     raise TomlDecodeError("Unbalanced quotes")
-                if sl[i-1] == "'" or sl[i-1] == '"':
-                    sl[i] = sl[i-1]
-                    sl[i-3] = ' '
+                if ((sl[i - 1] == "'" or sl[i - 1] == '"') and (
+                        sl[i - 2] == sl[i - 1])):
+                    sl[i] = sl[i - 1]
+                    if sl[i - 3] == sl[i - 1]:
+                        sl[i - 3] = ' '
             elif openarr:
                 sl[i] = ' '
             else:
@@ -190,8 +269,9 @@ def loads(s, _dict=dict):
     multilinestr = ""
     multibackslash = False
     for line in s:
-        line = line.strip()
-        if line == "":
+        if not multilinestr or multibackslash or '\n' not in multilinestr:
+            line = line.strip()
+        if line == "" and (not multikey or multibackslash):
             continue
         if multikey:
             if multibackslash:
@@ -199,14 +279,15 @@ def loads(s, _dict=dict):
             else:
                 multilinestr += line
             multibackslash = False
-            if len(line) > 2 and line[-1] == multilinestr[0] and \
-                    line[-2] == multilinestr[0] and line[-3] == multilinestr[0]:
-                value, vtype = _load_value(multilinestr)
+            if len(line) > 2 and (line[-1] == multilinestr[0] and
+                                  line[-2] == multilinestr[0] and
+                                  line[-3] == multilinestr[0]):
+                value, vtype = _load_value(multilinestr, _dict)
                 currentlevel[multikey] = value
                 multikey = None
                 multilinestr = ""
             else:
-                k = len(multilinestr) -1
+                k = len(multilinestr) - 1
                 while k > -1 and multilinestr[k] == '\\':
                     multibackslash = not multibackslash
                     k -= 1
@@ -230,35 +311,38 @@ def loads(s, _dict=dict):
                 groups[i] = groups[i].strip()
                 if groups[i][0] == '"' or groups[i][0] == "'":
                     groupstr = groups[i]
-                    j = i+1
+                    j = i + 1
                     while not groupstr[0] == groupstr[-1]:
                         j += 1
                         groupstr = '.'.join(groups[i:j])
                     groups[i] = groupstr[1:-1]
-                    groups[i+1:j] = []
+                    groups[i + 1:j] = []
                 else:
                     if not _groupname_re.match(groups[i]):
-                        raise TomlDecodeError("Invalid group name '"+groups[i]+"'. Try quoting it.")
+                        raise TomlDecodeError("Invalid group name '" +
+                                              groups[i] + "'. Try quoting it.")
                 i += 1
             currentlevel = retval
             for i in _range(len(groups)):
                 group = groups[i]
                 if group == "":
-                    raise TomlDecodeError("Can't have a keygroup with an empty name")
+                    raise TomlDecodeError("Can't have a keygroup with an empty "
+                                          "name")
                 try:
                     currentlevel[group]
                     if i == len(groups) - 1:
                         if group in implicitgroups:
                             implicitgroups.remove(group)
                             if arrayoftables:
-                                raise TomlDecodeError("An implicitly defined table can't be an array")
+                                raise TomlDecodeError("An implicitly defined "
+                                                      "table can't be an array")
                         elif arrayoftables:
                             currentlevel[group].append(_dict())
                         else:
-                            raise TomlDecodeError("What? "+group+" already exists?"+str(currentlevel))
+                            raise TomlDecodeError("What? " + group +
+                                                  " already exists?" +
+                                                  str(currentlevel))
                 except TypeError:
-                    if i != len(groups) - 1:
-                        implicitgroups.append(group)
                     currentlevel = currentlevel[-1]
                     try:
                         currentlevel[group]
@@ -280,45 +364,82 @@ def loads(s, _dict=dict):
                         pass
         elif line[0] == "{":
             if line[-1] != "}":
-                raise TomlDecodeError("Line breaks are not allowed in inline objects")
-            _load_inline_object(line, currentlevel, multikey, multibackslash)
+                raise TomlDecodeError("Line breaks are not allowed in inline"
+                                      "objects")
+            _load_inline_object(line, currentlevel, _dict, multikey,
+                                multibackslash)
         elif "=" in line:
-            ret = _load_line(line, currentlevel, multikey, multibackslash)
+            ret = _load_line(line, currentlevel, _dict, multikey,
+                             multibackslash)
             if ret is not None:
                 multikey, multilinestr, multibackslash = ret
     return retval
 
-def _load_inline_object(line, currentlevel, multikey=False, multibackslash=False):
+
+def _load_inline_object(line, currentlevel, _dict, multikey=False,
+                        multibackslash=False):
     candidate_groups = line[1:-1].split(",")
     groups = []
+    if len(candidate_groups) == 1 and not candidate_groups[0].strip():
+        candidate_groups.pop()
     while len(candidate_groups) > 0:
         candidate_group = candidate_groups.pop(0)
-        _, value = candidate_group.split('=', 1)
+        try:
+            _, value = candidate_group.split('=', 1)
+        except ValueError:
+            raise TomlDecodeError("Invalid inline table encountered")
         value = value.strip()
-        if (value[0] == value[-1] and value[0] in ('"', "'")) or \
-                value[0] in '0123456789' or \
-                value in ('true', 'false') or \
-                value[0] == "[" and value[-1] == "]":
+        if ((value[0] == value[-1] and value[0] in ('"', "'")) or (
+                value[0] in '-0123456789' or
+                value in ('true', 'false') or
+                (value[0] == "[" and value[-1] == "]"))):
             groups.append(candidate_group)
         else:
             candidate_groups[0] = candidate_group + "," + candidate_groups[0]
     for group in groups:
-        status = _load_line(group, currentlevel, multikey, multibackslash)
+        status = _load_line(group, currentlevel, _dict, multikey,
+                            multibackslash)
         if status is not None:
             break
 
+
 # Matches a TOML number, which allows underscores for readability
 _number_with_underscores = re.compile('([0-9])(_([0-9]))*')
 
-def _load_line(line, currentlevel, multikey, multibackslash):
+
+def _strictly_valid_num(n):
+    n = n.strip()
+    if not n:
+        return False
+    if n[0] == '_':
+        return False
+    if n[-1] == '_':
+        return False
+    if "_." in n or "._" in n:
+        return False
+    if len(n) == 1:
+        return True
+    if n[0] == '0' and n[1] != '.':
+        return False
+    if n[0] == '+' or n[0] == '-':
+        n = n[1:]
+        if n[0] == '0' and n[1] != '.':
+            return False
+    if '__' in n:
+        return False
+    return True
+
+
+def _load_line(line, currentlevel, _dict, multikey, multibackslash):
     i = 1
     pair = line.split('=', i)
+    strictly_valid = _strictly_valid_num(pair[-1])
     if _number_with_underscores.match(pair[-1]):
         pair[-1] = pair[-1].replace('_', '')
-    while pair[-1][0] != ' ' and pair[-1][0] != '\t' and \
-            pair[-1][0] != "'" and pair[-1][0] != '"' and \
-            pair[-1][0] != '[' and pair[-1] != 'true' and \
-            pair[-1] != 'false':
+    while len(pair[-1]) and (pair[-1][0] != ' ' and pair[-1][0] != '\t' and
+                             pair[-1][0] != "'" and pair[-1][0] != '"' and
+                             pair[-1][0] != '[' and pair[-1][0] != '{' and
+                             pair[-1] != 'true' and pair[-1] != 'false'):
         try:
             float(pair[-1])
             break
@@ -331,16 +452,20 @@ def _load_line(line, currentlevel, multikey, multibackslash):
         pair = line.split('=', i)
         if prev_val == pair[-1]:
             raise TomlDecodeError("Invalid date or number")
+        if strictly_valid:
+            strictly_valid = _strictly_valid_num(pair[-1])
     pair = ['='.join(pair[:-1]).strip(), pair[-1].strip()]
     if (pair[0][0] == '"' or pair[0][0] == "'") and \
             (pair[0][-1] == '"' or pair[0][-1] == "'"):
         pair[0] = pair[0][1:-1]
-    if len(pair[1]) > 2 and (pair[1][0] == '"' or pair[1][0] == "'") \
-            and pair[1][1] == pair[1][0] and pair[1][2] == pair[1][0] \
-            and not (len(pair[1]) > 5 and pair[1][-1] == pair[1][0] and \
-                         pair[1][-2] == pair[1][0] and \
-                         pair[1][-3] == pair[1][0]):
-        k = len(pair[1]) -1
+    if len(pair[1]) > 2 and ((pair[1][0] == '"' or pair[1][0] == "'") and
+                             pair[1][1] == pair[1][0] and
+                             pair[1][2] == pair[1][0] and
+                             not (len(pair[1]) > 5 and
+                                  pair[1][-1] == pair[1][0] and
+                                  pair[1][-2] == pair[1][0] and
+                                  pair[1][-3] == pair[1][0])):
+        k = len(pair[1]) - 1
         while k > -1 and pair[1][k] == '\\':
             multibackslash = not multibackslash
             k -= 1
@@ -350,7 +475,7 @@ def _load_line(line, currentlevel, multikey, multibackslash):
             multilinestr = pair[1] + "\n"
         multikey = pair[0]
     else:
-        value, vtype = _load_value(pair[1])
+        value, vtype = _load_value(pair[1], _dict, strictly_valid)
     try:
         currentlevel[pair[0]]
         raise TomlDecodeError("Duplicate keys!")
@@ -359,6 +484,9 @@ def _load_line(line, currentlevel, multikey, multibackslash):
             return multikey, multilinestr, multibackslash
         else:
             currentlevel[pair[0]] = value
+    except:
+        raise TomlDecodeError("Duplicate keys!")
+
 
 def _load_date(val):
     microsecond = 0
@@ -374,11 +502,15 @@ def _load_date(val):
     except ValueError:
         tz = None
     try:
-        d = datetime.datetime(int(val[:4]), int(val[5:7]), int(val[8:10]), int(val[11:13]), int(val[14:16]), int(val[17:19]), microsecond, tz)
+        d = datetime.datetime(
+            int(val[:4]), int(val[5:7]),
+            int(val[8:10]), int(val[11:13]),
+            int(val[14:16]), int(val[17:19]), microsecond, tz)
     except ValueError:
         return None
     return d
 
+
 def _load_unicode_escapes(v, hexbytes, prefix):
     hexchars = ['0', '1', '2', '3', '4', '5', '6', '7',
                 '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']
@@ -414,27 +546,42 @@ def _load_unicode_escapes(v, hexbytes, prefix):
         v += unicode(hx[len(hxb):])
     return v
 
+
 # Unescape TOML string values.
-_escapes = ['0', 'b', 'f', 'n', 'r', 't', '"'] # content after the \
-_escapedchars = ['\0', '\b', '\f', '\n', '\r', '\t', '\"'] # What it should be replaced by
-_escape_to_escapedchars = dict(zip(_escapes, _escapedchars)) # Used for substitution
-
-# Regexp that matches escaped value, checking the parity of the number
-# of backslashes
-_escapes_re = re.compile("""
-        (?P<prefix>([^\\\\](\\\\\\\\)*)) # Parity of the number of backslashs
-        \\\\                             # The actual backslash before the escape
-        (?P<escape>[%s])                 # The escape
-        """ % ''.join(_escapes),
-        re.VERBOSE)
+
+# content after the \
+_escapes = ['0', 'b', 'f', 'n', 'r', 't', '"']
+# What it should be replaced by
+_escapedchars = ['\0', '\b', '\f', '\n', '\r', '\t', '\"']
+# Used for substitution
+_escape_to_escapedchars = dict(zip(_escapes, _escapedchars))
+
 
 def _unescape(v):
     """Unescape characters in a TOML string."""
-    v = _escapes_re.sub(lambda match: match.group('prefix') + _escape_to_escapedchars[match.group('escape')], v)
-    v = v.replace("\\\\", "\\")
+    i = 0
+    backslash = False
+    while i < len(v):
+        if backslash:
+            backslash = False
+            if v[i] in _escapes:
+                v = v[:i - 1] + _escape_to_escapedchars[v[i]] + v[i + 1:]
+            elif v[i] == '\\':
+                v = v[:i - 1] + v[i:]
+            elif v[i] == 'u' or v[i] == 'U':
+                i += 1
+            else:
+                raise TomlDecodeError("Reserved escape sequence used")
+            continue
+        elif v[i] == '\\':
+            backslash = True
+        i += 1
     return v
 
-def _load_value(v):
+
+def _load_value(v, _dict, strictly_valid=True):
+    if not v:
+        raise TomlDecodeError("Empty value is invalid")
     if v == 'true':
         return (True, "bool")
     elif v == 'false':
@@ -469,8 +616,8 @@ def _load_value(v):
             if i == '':
                 backslash = not backslash
             else:
-                if i[0] not in _escapes and i[0] != 'u' and i[0] != 'U' and \
-                        not backslash:
+                if i[0] not in _escapes and (i[0] != 'u' and i[0] != 'U' and
+                                             not backslash):
                     raise TomlDecodeError("Reserved escape sequence used")
                 if backslash:
                     backslash = False
@@ -479,31 +626,38 @@ def _load_value(v):
                 hexbytes = v.split(prefix)
                 v = _load_unicode_escapes(hexbytes[0], hexbytes[1:], prefix)
         v = _unescape(v)
-        if v[1] == '"':
+        if v[1] == '"' and (len(v) < 3 or v[1] == v[2]):
             v = v[2:-2]
         return (v[1:-1], "str")
     elif v[0] == "'":
-        if v[1] == "'":
+        if v[1] == "'" and (len(v) < 3 or v[1] == v[2]):
             v = v[2:-2]
         return (v[1:-1], "str")
     elif v[0] == '[':
-        return (_load_array(v), "array")
+        return (_load_array(v, _dict), "array")
     elif v[0] == '{':
-        inline_object = {}
-        _load_inline_object(v, inline_object)
+        inline_object = _get_empty_inline_table(_dict)
+        _load_inline_object(v, inline_object, _dict)
         return (inline_object, "inline_object")
     else:
         parsed_date = _load_date(v)
         if parsed_date is not None:
             return (parsed_date, "date")
+        if not strictly_valid:
+            raise TomlDecodeError("Weirdness with leading zeroes or underscores"
+                                  " in your number.")
         itype = "int"
         neg = False
         if v[0] == '-':
             neg = True
             v = v[1:]
-        if '.' in v or 'e' in v:
-            if v.split('.', 1)[1] == '':
-                raise TomlDecodeError("This float is missing digits after the point")
+        elif v[0] == '+':
+            v = v[1:]
+        v = v.replace('_', '')
+        if '.' in v or 'e' in v or 'E' in v:
+            if '.' in v and v.split('.', 1)[1] == '':
+                raise TomlDecodeError("This float is missing digits after "
+                                      "the point")
             if v[0] not in '0123456789':
                 raise TomlDecodeError("This float doesn't have a leading digit")
             v = float(v)
@@ -514,48 +668,57 @@ def _load_value(v):
             return (0 - v, itype)
         return (v, itype)
 
-def _load_array(a):
+
+def _load_array(a, _dict):
     atype = None
     retval = []
     a = a.strip()
-    if '[' not in a[1:-1]:
+    if '[' not in a[1:-1] or "" != a[1:-1].split('[')[0].strip():
         strarray = False
         tmpa = a[1:-1].strip()
-        if tmpa != '' and tmpa[0] == '"':
+        if tmpa != '' and (tmpa[0] == '"' or tmpa[0] == "'"):
             strarray = True
-        if '{' not in a[1:-1]:
+        if not a[1:-1].strip().startswith('{'):
             a = a[1:-1].split(',')
         else:
-            # a is an inline object, we must find the matching parenthesis to difine groups
+            # a is an inline object, we must find the matching parenthesis
+            # to define groups
             new_a = []
             start_group_index = 1
             end_group_index = 2
             in_str = False
-            while end_group_index < len(a[1:-1]):
+            while end_group_index < len(a[1:]):
                 if a[end_group_index] == '"' or a[end_group_index] == "'":
                     in_str = not in_str
-                if a[end_group_index] == '}' and not in_str:
-                    # Increase end_group_index by 1 to get the closing bracket
-                    end_group_index += 1
-                    new_a.append(a[start_group_index:end_group_index])
-                    # The next start index is at least after the closing bracket, a closing bracket
-                    # can be followed by a comma since we are in an array.
-                    start_group_index = end_group_index + 1
-                    while a[start_group_index] != '{' and start_group_index < len(a[1:-1]):
-                        start_group_index += 1
-                    end_group_index = start_group_index + 1
-                else:
+                if in_str or a[end_group_index] != '}':
                     end_group_index += 1
+                    continue
+
+                # Increase end_group_index by 1 to get the closing bracket
+                end_group_index += 1
+                new_a.append(a[start_group_index:end_group_index])
+
+                # The next start index is at least after the closing bracket, a
+                # closing bracket can be followed by a comma since we are in
+                # an array.
+                start_group_index = end_group_index + 1
+                while (start_group_index < len(a[1:]) and
+                       a[start_group_index] != '{'):
+                    start_group_index += 1
+                end_group_index = start_group_index + 1
             a = new_a
         b = 0
         if strarray:
             while b < len(a) - 1:
-                while a[b].strip()[-1] != '"' and a[b+1].strip()[0] != '"':
-                    a[b] = a[b] + ',' + a[b+1]
+                ab = a[b].strip()
+                while ab[-1] != ab[0] or (ab[0] == ab[1] == ab[2] and
+                                          ab[-2] != ab[0] and ab[-3] != ab[0]):
+                    a[b] = a[b] + ',' + a[b + 1]
+                    ab = a[b].strip()
                     if b < len(a) - 2:
-                        a = a[:b+1] + a[b+2:]
+                        a = a[:b + 1] + a[b + 2:]
                     else:
-                        a = a[:b+1]
+                        a = a[:b + 1]
                 b += 1
     else:
         al = list(a[1:-1])
@@ -569,12 +732,12 @@ def _load_array(a):
                 openarr -= 1
             elif al[i] == ',' and not openarr:
                 a.append(''.join(al[j:i]))
-                j = i+1
+                j = i + 1
         a.append(''.join(al[j:]))
     for i in _range(len(a)):
         a[i] = a[i].strip()
         if a[i] != '':
-            nval, ntype = _load_value(a[i])
+            nval, ntype = _load_value(a[i], _dict)
             if atype:
                 if ntype != atype:
                     raise TomlDecodeError("Not a homogeneous array")
@@ -583,38 +746,68 @@ def _load_array(a):
             retval.append(nval)
     return retval
 
+
 def dump(o, f):
-    """Writes out to f the toml corresponding to o. Returns said toml."""
+    """Writes out dict as toml to a file
+
+    Args:
+        o: Object to dump into toml
+        f: File descriptor where the toml should be stored
+
+    Returns:
+        String containing the toml corresponding to dictionary
+
+    Raises:
+        TypeError: When anything other than file descriptor is passed
+    """
+
     if not f.write:
         raise TypeError("You can only dump an object to a file descriptor")
     d = dumps(o)
     f.write(d)
     return d
 
-def dumps(o):
-    """Returns a string containing the toml corresponding to o, a dictionary"""
+
+def dumps(o, preserve=False):
+    """Stringifies input dict as toml
+
+    Args:
+        o: Object to dump into toml
+
+        preserve: Boolean parameter. If true, preserve inline tables.
+
+    Returns:
+        String containing the toml corresponding to dict
+    """
+
     retval = ""
     addtoretval, sections = _dump_sections(o, "")
     retval += addtoretval
     while sections != {}:
         newsections = {}
         for section in sections:
-            addtoretval, addtosections = _dump_sections(sections[section], section)
-            if addtoretval:
-                retval += "["+section+"]\n"
-                retval += addtoretval
+            addtoretval, addtosections = _dump_sections(sections[section],
+                                                        section, preserve)
+            if addtoretval or (not addtoretval and not addtosections):
+                if retval and retval[-2:] != "\n\n":
+                    retval += "\n"
+                retval += "[" + section + "]\n"
+                if addtoretval:
+                    retval += addtoretval
             for s in addtosections:
-                newsections[section+"."+s] = addtosections[s]
+                newsections[section + "." + s] = addtosections[s]
         sections = newsections
     return retval
 
-def _dump_sections(o, sup):
+
+def _dump_sections(o, sup, preserve=False):
     retstr = ""
     if sup != "" and sup[-1] != ".":
         sup += '.'
-    retdict = {}
+    retdict = o.__class__()
     arraystr = ""
     for section in o:
+        section = str(section)
         qsection = section
         if not re.match(r'^[A-Za-z0-9_-]+$', section):
             if '"' in section:
@@ -629,9 +822,9 @@ def _dump_sections(o, sup):
                         arrayoftables = True
             if arrayoftables:
                 for a in o[section]:
-                    arraytabstr = ""
-                    arraystr += "[["+sup+qsection+"]]\n"
-                    s, d = _dump_sections(a, sup+qsection)
+                    arraytabstr = "\n"
+                    arraystr += "[[" + sup + qsection + "]]\n"
+                    s, d = _dump_sections(a, sup + qsection)
                     if s:
                         if s[0] == "[":
                             arraytabstr += s
@@ -640,55 +833,91 @@ def _dump_sections(o, sup):
                     while d != {}:
                         newd = {}
                         for dsec in d:
-                            s1, d1 = _dump_sections(d[dsec], sup+qsection+"."+dsec)
+                            s1, d1 = _dump_sections(d[dsec], sup + qsection +
+                                                    "." + dsec)
                             if s1:
-                                arraytabstr += "["+sup+qsection+"."+dsec+"]\n"
+                                arraytabstr += ("[" + sup + qsection + "." +
+                                                dsec + "]\n")
                                 arraytabstr += s1
                             for s1 in d1:
-                                newd[dsec+"."+s1] = d1[s1]
+                                newd[dsec + "." + s1] = d1[s1]
                         d = newd
                     arraystr += arraytabstr
             else:
                 if o[section] is not None:
                     retstr += (qsection + " = " +
                                str(_dump_value(o[section])) + '\n')
+        elif preserve and isinstance(o[section], InlineTableDict):
+            retstr += (section + " = " + _dump_inline_table(o[section]))
         else:
             retdict[qsection] = o[section]
     retstr += arraystr
     return (retstr, retdict)
 
-def _dump_value(v):
-    if isinstance(v, list):
-        t = []
-        retval = "["
-        for u in v:
-            t.append(_dump_value(u))
-        while t != []:
-            s = []
-            for u in t:
-                if isinstance(u, list):
-                    for r in u:
-                        s.append(r)
-                else:
-                    retval += " " + str(u) + ","
-            t = s
-        retval += "]"
+
+def _dump_inline_table(section):
+    """Preserve inline table in its compact syntax instead of expanding
+    into subsection.
+
+    https://github.com/toml-lang/toml#user-content-inline-table
+    """
+    retval = ""
+    if isinstance(section, dict):
+        val_list = []
+        for k, v in section.items():
+            val = _dump_inline_table(v)
+            val_list.append(k + " = " + val)
+        retval += "{ " + ", ".join(val_list) + " }\n"
         return retval
-    if isinstance(v, (str, unicode)):
-        v = "%r" % v
-        if v[0] == 'u':
-            v = v[1:]
-        singlequote = v[0] == "'"
-        v = v[1:-1]
-        if singlequote:
-            v = v.replace("\\'", "'")
-            v = v.replace('"', '\\"')
-        v = v.replace("\\x", "\\u00")
-        return str('"'+v+'"')
-    if isinstance(v, bool):
-        return str(v).lower()
-    if isinstance(v, datetime.datetime):
-        return v.isoformat()[:19]+'Z'
-    if isinstance(v, float):
-        return str(v)
-    return v
+    else:
+        return str(_dump_value(section))
+
+
+def _dump_value(v):
+    dump_funcs = {
+        str: lambda: _dump_str(v),
+        unicode: lambda: _dump_str(v),
+        list: lambda: _dump_list(v),
+        bool: lambda: str(v).lower(),
+        float: lambda: _dump_float(v),
+        datetime.datetime: lambda: v.isoformat(),
+    }
+    # Lookup function corresponding to v's type
+    dump_fn = dump_funcs.get(type(v))
+    # Evaluate function (if it exists) else return v
+    return dump_fn() if dump_fn is not None else v
+
+
+def _dump_str(v):
+    v = "%r" % v
+    if v[0] == 'u':
+        v = v[1:]
+    singlequote = v.startswith("'")
+    v = v[1:-1]
+    if singlequote:
+        v = v.replace("\\'", "'")
+        v = v.replace('"', '\\"')
+    v = v.replace("\\x", "\\u00")
+    return str('"' + v + '"')
+
+
+def _dump_list(v):
+    t = []
+    retval = "["
+    for u in v:
+        t.append(_dump_value(u))
+    while t != []:
+        s = []
+        for u in t:
+            if isinstance(u, list):
+                for r in u:
+                    s.append(r)
+            else:
+                retval += " " + str(u) + ","
+        t = s
+    retval += "]"
+    return retval
+
+
+def _dump_float(v):
+    return "{0:.16g}".format(v).replace("e+0", "e+").replace("e-0", "e-")

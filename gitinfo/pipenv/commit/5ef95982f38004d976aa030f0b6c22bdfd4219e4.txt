commit 5ef95982f38004d976aa030f0b6c22bdfd4219e4
Author: Dan Ryan <dan.ryan@canonical.com>
Date:   Mon Mar 30 18:41:03 2020 -0400

     Add importlib_resources package to vendored pkgs
    
    Signed-off-by: Dan Ryan <dan.ryan@canonical.com>

diff --git a/pipenv/vendor/importlib_resources/LICENSE b/pipenv/vendor/importlib_resources/LICENSE
new file mode 100644
index 00000000..378b991a
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/LICENSE
@@ -0,0 +1,13 @@
+Copyright 2017-2019 Brett Cannon, Barry Warsaw
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/pipenv/vendor/importlib_resources/__init__.py b/pipenv/vendor/importlib_resources/__init__.py
new file mode 100644
index 00000000..4bce94b0
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/__init__.py
@@ -0,0 +1,56 @@
+"""Read resources contained within a package."""
+
+import sys
+
+from ._compat import metadata
+from ._common import as_file
+
+# for compatibility. Ref #88
+__import__('importlib_resources.trees')
+
+
+__all__ = [
+    'Package',
+    'Resource',
+    'ResourceReader',
+    'as_file',
+    'contents',
+    'files',
+    'is_resource',
+    'open_binary',
+    'open_text',
+    'path',
+    'read_binary',
+    'read_text',
+    ]
+
+
+if sys.version_info >= (3,):
+    from importlib_resources._py3 import (
+        Package,
+        Resource,
+        contents,
+        files,
+        is_resource,
+        open_binary,
+        open_text,
+        path,
+        read_binary,
+        read_text,
+        )
+    from importlib_resources.abc import ResourceReader
+else:
+    from importlib_resources._py2 import (
+        contents,
+        files,
+        is_resource,
+        open_binary,
+        open_text,
+        path,
+        read_binary,
+        read_text,
+        )
+    del __all__[:3]
+
+
+__version__ = metadata.version('importlib_resources')
diff --git a/pipenv/vendor/importlib_resources/_common.py b/pipenv/vendor/importlib_resources/_common.py
new file mode 100644
index 00000000..3a5b7e44
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/_common.py
@@ -0,0 +1,76 @@
+from __future__ import absolute_import
+
+import os
+import tempfile
+import contextlib
+
+from ._compat import (
+    Path, package_spec, FileNotFoundError, ZipPath,
+    singledispatch, suppress,
+    )
+
+
+def from_package(package):
+    """
+    Return a Traversable object for the given package.
+
+    """
+    spec = package_spec(package)
+    return from_traversable_resources(spec) or fallback_resources(spec)
+
+
+def from_traversable_resources(spec):
+    """
+    If the spec.loader implements TraversableResources,
+    directly or implicitly, it will have a ``files()`` method.
+    """
+    with suppress(AttributeError):
+        return spec.loader.files()
+
+
+def fallback_resources(spec):
+    package_directory = Path(spec.origin).parent
+    try:
+        archive_path = spec.loader.archive
+        rel_path = package_directory.relative_to(archive_path)
+        return ZipPath(archive_path, str(rel_path) + '/')
+    except Exception:
+        pass
+    return package_directory
+
+
+@contextlib.contextmanager
+def _tempfile(reader, suffix=''):
+    # Not using tempfile.NamedTemporaryFile as it leads to deeper 'try'
+    # blocks due to the need to close the temporary file to work on Windows
+    # properly.
+    fd, raw_path = tempfile.mkstemp(suffix=suffix)
+    try:
+        os.write(fd, reader())
+        os.close(fd)
+        yield Path(raw_path)
+    finally:
+        try:
+            os.remove(raw_path)
+        except FileNotFoundError:
+            pass
+
+
+@singledispatch
+@contextlib.contextmanager
+def as_file(path):
+    """
+    Given a Traversable object, return that object as a
+    path on the local file system in a context manager.
+    """
+    with _tempfile(path.read_bytes, suffix=path.name) as local:
+        yield local
+
+
+@as_file.register(Path)
+@contextlib.contextmanager
+def _(path):
+    """
+    Degenerate behavior for pathlib.Path objects.
+    """
+    yield path
diff --git a/pipenv/vendor/importlib_resources/_compat.py b/pipenv/vendor/importlib_resources/_compat.py
new file mode 100644
index 00000000..48ca6afd
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/_compat.py
@@ -0,0 +1,60 @@
+from __future__ import absolute_import
+
+# flake8: noqa
+
+try:
+    from pathlib import Path, PurePath
+except ImportError:
+    from pathlib2 import Path, PurePath                         # type: ignore
+
+
+try:
+    from contextlib import suppress
+except ImportError:
+    from contextlib2 import suppress                         # type: ignore
+
+
+try:
+    from functools import singledispatch
+except ImportError:
+    from singledispatch import singledispatch                   # type: ignore
+
+
+try:
+    from abc import ABC                                         # type: ignore
+except ImportError:
+    from abc import ABCMeta
+
+    class ABC(object):                                          # type: ignore
+        __metaclass__ = ABCMeta
+
+
+try:
+    FileNotFoundError = FileNotFoundError                       # type: ignore
+except NameError:
+    FileNotFoundError = OSError                                 # type: ignore
+
+
+try:
+    from importlib import metadata
+except ImportError:
+    import importlib_metadata as metadata  # type: ignore
+
+
+try:
+    from zipfile import Path as ZipPath  # type: ignore
+except ImportError:
+    from zipp import Path as ZipPath  # type: ignore
+
+
+class PackageSpec(object):
+	def __init__(self, **kwargs):
+		vars(self).update(kwargs)
+
+
+def package_spec(package):
+	return getattr(package, '__spec__', None) or \
+		PackageSpec(
+			origin=package.__file__,
+			loader=getattr(package, '__loader__', None),
+		)
diff --git a/pipenv/vendor/importlib_resources/_py2.py b/pipenv/vendor/importlib_resources/_py2.py
new file mode 100644
index 00000000..26ce45d2
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/_py2.py
@@ -0,0 +1,142 @@
+import os
+import errno
+
+from . import _common
+from ._compat import FileNotFoundError
+from importlib import import_module
+from io import BytesIO, TextIOWrapper, open as io_open
+
+
+def _resolve(name):
+    """If name is a string, resolve to a module."""
+    if not isinstance(name, basestring):                    # noqa: F821
+        return name
+    return import_module(name)
+
+
+def _get_package(package):
+    """Normalize a path by ensuring it is a string.
+
+    If the resulting string contains path separators, an exception is raised.
+    """
+    module = _resolve(package)
+    if not hasattr(module, '__path__'):
+        raise TypeError("{!r} is not a package".format(package))
+    return module
+
+
+def _normalize_path(path):
+    """Normalize a path by ensuring it is a string.
+
+    If the resulting string contains path separators, an exception is raised.
+    """
+    str_path = str(path)
+    parent, file_name = os.path.split(str_path)
+    if parent:
+        raise ValueError("{!r} must be only a file name".format(path))
+    return file_name
+
+
+def open_binary(package, resource):
+    """Return a file-like object opened for binary reading of the resource."""
+    resource = _normalize_path(resource)
+    package = _get_package(package)
+    # Using pathlib doesn't work well here due to the lack of 'strict' argument
+    # for pathlib.Path.resolve() prior to Python 3.6.
+    package_path = os.path.dirname(package.__file__)
+    relative_path = os.path.join(package_path, resource)
+    full_path = os.path.abspath(relative_path)
+    try:
+        return io_open(full_path, 'rb')
+    except IOError:
+        # This might be a package in a zip file.  zipimport provides a loader
+        # with a functioning get_data() method, however we have to strip the
+        # archive (i.e. the .zip file's name) off the front of the path.  This
+        # is because the zipimport loader in Python 2 doesn't actually follow
+        # PEP 302.  It should allow the full path, but actually requires that
+        # the path be relative to the zip file.
+        try:
+            loader = package.__loader__
+            full_path = relative_path[len(loader.archive)+1:]
+            data = loader.get_data(full_path)
+        except (IOError, AttributeError):
+            package_name = package.__name__
+            message = '{!r} resource not found in {!r}'.format(
+                resource, package_name)
+            raise FileNotFoundError(message)
+        return BytesIO(data)
+
+
+def open_text(package, resource, encoding='utf-8', errors='strict'):
+    """Return a file-like object opened for text reading of the resource."""
+    return TextIOWrapper(
+        open_binary(package, resource), encoding=encoding, errors=errors)
+
+
+def read_binary(package, resource):
+    """Return the binary contents of the resource."""
+    with open_binary(package, resource) as fp:
+        return fp.read()
+
+
+def read_text(package, resource, encoding='utf-8', errors='strict'):
+    """Return the decoded string of the resource.
+
+    The decoding-related arguments have the same semantics as those of
+    bytes.decode().
+    """
+    with open_text(package, resource, encoding, errors) as fp:
+        return fp.read()
+
+
+def files(package):
+    return _common.from_package(_get_package(package))
+
+
+def path(package, resource):
+    """A context manager providing a file path object to the resource.
+
+    If the resource does not already exist on its own on the file system,
+    a temporary file will be created. If the file was created, the file
+    will be deleted upon exiting the context manager (no exception is
+    raised if the file was deleted prior to the context manager
+    exiting).
+    """
+    path = files(package).joinpath(_normalize_path(resource))
+    if not path.is_file():
+        raise FileNotFoundError(path)
+    return _common.as_file(path)
+
+
+def is_resource(package, name):
+    """True if name is a resource inside package.
+
+    Directories are *not* resources.
+    """
+    package = _get_package(package)
+    _normalize_path(name)
+    try:
+        package_contents = set(contents(package))
+    except OSError as error:
+        if error.errno not in (errno.ENOENT, errno.ENOTDIR):
+            # We won't hit this in the Python 2 tests, so it'll appear
+            # uncovered.  We could mock os.listdir() to return a non-ENOENT or
+            # ENOTDIR, but then we'd have to depend on another external
+            # library since Python 2 doesn't have unittest.mock.  It's not
+            # worth it.
+            raise                     # pragma: nocover
+        return False
+    if name not in package_contents:
+        return False
+    return (_common.from_package(package) / name).is_file()
+
+
+def contents(package):
+    """Return an iterable of entries in `package`.
+
+    Note that not all entries are resources.  Specifically, directories are
+    not considered resources.  Use `is_resource()` on each entry returned here
+    to check if it is a resource or not.
+    """
+    package = _get_package(package)
+    return list(item.name for item in _common.from_package(package).iterdir())
diff --git a/pipenv/vendor/importlib_resources/_py3.py b/pipenv/vendor/importlib_resources/_py3.py
new file mode 100644
index 00000000..8dedde4c
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/_py3.py
@@ -0,0 +1,203 @@
+import os
+import sys
+
+from . import abc as resources_abc
+from . import _common
+from contextlib import contextmanager, suppress
+from importlib import import_module
+from importlib.abc import ResourceLoader
+from io import BytesIO, TextIOWrapper
+from pathlib import Path
+from types import ModuleType
+from typing import Iterable, Iterator, Optional, Set, Union   # noqa: F401
+from typing import cast
+from typing.io import BinaryIO, TextIO
+
+if False:  # TYPE_CHECKING
+    from typing import ContextManager
+
+Package = Union[ModuleType, str]
+if sys.version_info >= (3, 6):
+    Resource = Union[str, os.PathLike]              # pragma: <=35
+else:
+    Resource = str                                  # pragma: >=36
+
+
+def _resolve(name) -> ModuleType:
+    """If name is a string, resolve to a module."""
+    if hasattr(name, '__spec__'):
+        return name
+    return import_module(name)
+
+
+def _get_package(package) -> ModuleType:
+    """Take a package name or module object and return the module.
+
+    If a name, the module is imported.  If the resolved module
+    object is not a package, raise an exception.
+    """
+    module = _resolve(package)
+    if module.__spec__.submodule_search_locations is None:
+        raise TypeError('{!r} is not a package'.format(package))
+    return module
+
+
+def _normalize_path(path) -> str:
+    """Normalize a path by ensuring it is a string.
+
+    If the resulting string contains path separators, an exception is raised.
+    """
+    str_path = str(path)
+    parent, file_name = os.path.split(str_path)
+    if parent:
+        raise ValueError('{!r} must be only a file name'.format(path))
+    return file_name
+
+
+def _get_resource_reader(
+        package: ModuleType) -> Optional[resources_abc.ResourceReader]:
+    # Return the package's loader if it's a ResourceReader.  We can't use
+    # a issubclass() check here because apparently abc.'s __subclasscheck__()
+    # hook wants to create a weak reference to the object, but
+    # zipimport.zipimporter does not support weak references, resulting in a
+    # TypeError.  That seems terrible.
+    spec = package.__spec__
+    reader = getattr(spec.loader, 'get_resource_reader', None)
+    if reader is None:
+        return None
+    return cast(resources_abc.ResourceReader, reader(spec.name))
+
+
+def open_binary(package: Package, resource: Resource) -> BinaryIO:
+    """Return a file-like object opened for binary reading of the resource."""
+    resource = _normalize_path(resource)
+    package = _get_package(package)
+    reader = _get_resource_reader(package)
+    if reader is not None:
+        return reader.open_resource(resource)
+    # Using pathlib doesn't work well here due to the lack of 'strict'
+    # argument for pathlib.Path.resolve() prior to Python 3.6.
+    absolute_package_path = os.path.abspath(
+        package.__spec__.origin or 'non-existent file')
+    package_path = os.path.dirname(absolute_package_path)
+    full_path = os.path.join(package_path, resource)
+    try:
+        return open(full_path, mode='rb')
+    except OSError:
+        # Just assume the loader is a resource loader; all the relevant
+        # importlib.machinery loaders are and an AttributeError for
+        # get_data() will make it clear what is needed from the loader.
+        loader = cast(ResourceLoader, package.__spec__.loader)
+        data = None
+        if hasattr(package.__spec__.loader, 'get_data'):
+            with suppress(OSError):
+                data = loader.get_data(full_path)
+        if data is None:
+            package_name = package.__spec__.name
+            message = '{!r} resource not found in {!r}'.format(
+                resource, package_name)
+            raise FileNotFoundError(message)
+        return BytesIO(data)
+
+
+def open_text(package: Package,
+              resource: Resource,
+              encoding: str = 'utf-8',
+              errors: str = 'strict') -> TextIO:
+    """Return a file-like object opened for text reading of the resource."""
+    return TextIOWrapper(
+        open_binary(package, resource), encoding=encoding, errors=errors)
+
+
+def read_binary(package: Package, resource: Resource) -> bytes:
+    """Return the binary contents of the resource."""
+    with open_binary(package, resource) as fp:
+        return fp.read()
+
+
+def read_text(package: Package,
+              resource: Resource,
+              encoding: str = 'utf-8',
+              errors: str = 'strict') -> str:
+    """Return the decoded string of the resource.
+
+    The decoding-related arguments have the same semantics as those of
+    bytes.decode().
+    """
+    with open_text(package, resource, encoding, errors) as fp:
+        return fp.read()
+
+
+def files(package: Package) -> resources_abc.Traversable:
+    """
+    Get a Traversable resource from a package
+    """
+    return _common.from_package(_get_package(package))
+
+
+def path(
+        package: Package, resource: Resource,
+        ) -> 'ContextManager[Path]':
+    """A context manager providing a file path object to the resource.
+
+    If the resource does not already exist on its own on the file system,
+    a temporary file will be created. If the file was created, the file
+    will be deleted upon exiting the context manager (no exception is
+    raised if the file was deleted prior to the context manager
+    exiting).
+    """
+    reader = _get_resource_reader(_get_package(package))
+    return (
+        _path_from_reader(reader, resource)
+        if reader else
+        _common.as_file(files(package).joinpath(_normalize_path(resource)))
+        )
+
+
+@contextmanager
+def _path_from_reader(reader, resource):
+    norm_resource = _normalize_path(resource)
+    with suppress(FileNotFoundError):
+        yield Path(reader.resource_path(norm_resource))
+        return
+    opener_reader = reader.open_resource(norm_resource)
+    with _common._tempfile(opener_reader.read, suffix=norm_resource) as res:
+        yield res
+
+
+def is_resource(package: Package, name: str) -> bool:
+    """True if `name` is a resource inside `package`.
+
+    Directories are *not* resources.
+    """
+    package = _get_package(package)
+    _normalize_path(name)
+    reader = _get_resource_reader(package)
+    if reader is not None:
+        return reader.is_resource(name)
+    package_contents = set(contents(package))
+    if name not in package_contents:
+        return False
+    return (_common.from_package(package) / name).is_file()
+
+
+def contents(package: Package) -> Iterable[str]:
+    """Return an iterable of entries in `package`.
+
+    Note that not all entries are resources.  Specifically, directories are
+    not considered resources.  Use `is_resource()` on each entry returned here
+    to check if it is a resource or not.
+    """
+    package = _get_package(package)
+    reader = _get_resource_reader(package)
+    if reader is not None:
+        return reader.contents()
+    # Is the package a namespace package?  By definition, namespace packages
+    # cannot have resources.
+    namespace = (
+        package.__spec__.origin is None or
+        package.__spec__.origin == 'namespace'
+        )
+    if namespace or not package.__spec__.has_location:
+        return ()
+    return list(item.name for item in _common.from_package(package).iterdir())
diff --git a/pipenv/vendor/importlib_resources/abc.py b/pipenv/vendor/importlib_resources/abc.py
new file mode 100644
index 00000000..28596a4a
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/abc.py
@@ -0,0 +1,134 @@
+from __future__ import absolute_import
+
+import abc
+
+from ._compat import ABC, FileNotFoundError
+
+# Use mypy's comment syntax for Python 2 compatibility
+try:
+    from typing import BinaryIO, Iterable, Text
+except ImportError:
+    pass
+
+
+class ResourceReader(ABC):
+    """Abstract base class for loaders to provide resource reading support."""
+
+    @abc.abstractmethod
+    def open_resource(self, resource):
+        # type: (Text) -> BinaryIO
+        """Return an opened, file-like object for binary reading.
+
+        The 'resource' argument is expected to represent only a file name.
+        If the resource cannot be found, FileNotFoundError is raised.
+        """
+        # This deliberately raises FileNotFoundError instead of
+        # NotImplementedError so that if this method is accidentally called,
+        # it'll still do the right thing.
+        raise FileNotFoundError
+
+    @abc.abstractmethod
+    def resource_path(self, resource):
+        # type: (Text) -> Text
+        """Return the file system path to the specified resource.
+
+        The 'resource' argument is expected to represent only a file name.
+        If the resource does not exist on the file system, raise
+        FileNotFoundError.
+        """
+        # This deliberately raises FileNotFoundError instead of
+        # NotImplementedError so that if this method is accidentally called,
+        # it'll still do the right thing.
+        raise FileNotFoundError
+
+    @abc.abstractmethod
+    def is_resource(self, path):
+        # type: (Text) -> bool
+        """Return True if the named 'path' is a resource.
+
+        Files are resources, directories are not.
+        """
+        raise FileNotFoundError
+
+    @abc.abstractmethod
+    def contents(self):
+        # type: () -> Iterable[str]
+        """Return an iterable of entries in `package`."""
+        raise FileNotFoundError
+
+
+class Traversable(ABC):
+    """
+    An object with a subset of pathlib.Path methods suitable for
+    traversing directories and opening files.
+    """
+
+    @abc.abstractmethod
+    def iterdir(self):
+        """
+        Yield Traversable objects in self
+        """
+
+    @abc.abstractmethod
+    def read_bytes(self):
+        """
+        Read contents of self as bytes
+        """
+
+    @abc.abstractmethod
+    def read_text(self, encoding=None):
+        """
+        Read contents of self as bytes
+        """
+
+    @abc.abstractmethod
+    def is_dir(self):
+        """
+        Return True if self is a dir
+        """
+
+    @abc.abstractmethod
+    def is_file(self):
+        """
+        Return True if self is a file
+        """
+
+    @abc.abstractmethod
+    def joinpath(self, child):
+        """
+        Return Traversable child in self
+        """
+
+    @abc.abstractmethod
+    def __truediv__(self, child):
+        """
+        Return Traversable child in self
+        """
+
+    @abc.abstractmethod
+    def open(self, mode='r', *args, **kwargs):
+        """
+        mode may be 'r' or 'rb' to open as text or binary. Return a handle
+        suitable for reading (same as pathlib.Path.open).
+
+        When opening as text, accepts encoding parameters such as those
+        accepted by io.TextIOWrapper.
+        """
+
+
+class TraversableResources(ResourceReader):
+    @abc.abstractmethod
+    def files(self):
+        """Return a Traversable object for the loaded package."""
+
+    def open_resource(self, resource):
+        return self.files().joinpath(resource).open('rb')
+
+    def resource_path(self, resource):
+        raise FileNotFoundError(resource)
+
+    def is_resource(self, path):
+        return self.files().joinpath(path).isfile()
+
+    def contents(self):
+        return (item.name for item in self.files().iterdir())
diff --git a/pipenv/vendor/importlib_resources/tests/__init__.py b/pipenv/vendor/importlib_resources/tests/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/pipenv/vendor/importlib_resources/tests/data01/__init__.py b/pipenv/vendor/importlib_resources/tests/data01/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/pipenv/vendor/importlib_resources/tests/data01/binary.file b/pipenv/vendor/importlib_resources/tests/data01/binary.file
new file mode 100644
index 00000000..eaf36c1d
Binary files /dev/null and b/pipenv/vendor/importlib_resources/tests/data01/binary.file differ
diff --git a/pipenv/vendor/importlib_resources/tests/data01/subdirectory/__init__.py b/pipenv/vendor/importlib_resources/tests/data01/subdirectory/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/pipenv/vendor/importlib_resources/tests/data01/subdirectory/binary.file b/pipenv/vendor/importlib_resources/tests/data01/subdirectory/binary.file
new file mode 100644
index 00000000..eaf36c1d
Binary files /dev/null and b/pipenv/vendor/importlib_resources/tests/data01/subdirectory/binary.file differ
diff --git a/pipenv/vendor/importlib_resources/tests/data01/utf-16.file b/pipenv/vendor/importlib_resources/tests/data01/utf-16.file
new file mode 100644
index 00000000..2cb77229
Binary files /dev/null and b/pipenv/vendor/importlib_resources/tests/data01/utf-16.file differ
diff --git a/pipenv/vendor/importlib_resources/tests/data01/utf-8.file b/pipenv/vendor/importlib_resources/tests/data01/utf-8.file
new file mode 100644
index 00000000..1c0132ad
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/tests/data01/utf-8.file
@@ -0,0 +1 @@
+Hello, UTF-8 world!
diff --git a/pipenv/vendor/importlib_resources/tests/data02/__init__.py b/pipenv/vendor/importlib_resources/tests/data02/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/pipenv/vendor/importlib_resources/tests/data02/one/__init__.py b/pipenv/vendor/importlib_resources/tests/data02/one/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/pipenv/vendor/importlib_resources/tests/data02/one/resource1.txt b/pipenv/vendor/importlib_resources/tests/data02/one/resource1.txt
new file mode 100644
index 00000000..61a813e4
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/tests/data02/one/resource1.txt
@@ -0,0 +1 @@
+one resource
diff --git a/pipenv/vendor/importlib_resources/tests/data02/two/__init__.py b/pipenv/vendor/importlib_resources/tests/data02/two/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/pipenv/vendor/importlib_resources/tests/data02/two/resource2.txt b/pipenv/vendor/importlib_resources/tests/data02/two/resource2.txt
new file mode 100644
index 00000000..a80ce46e
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/tests/data02/two/resource2.txt
@@ -0,0 +1 @@
+two resource
diff --git a/pipenv/vendor/importlib_resources/tests/data03/__init__.py b/pipenv/vendor/importlib_resources/tests/data03/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/pipenv/vendor/importlib_resources/tests/data03/namespace/resource1.txt b/pipenv/vendor/importlib_resources/tests/data03/namespace/resource1.txt
new file mode 100644
index 00000000..e69de29b
diff --git a/pipenv/vendor/importlib_resources/tests/test_open.py b/pipenv/vendor/importlib_resources/tests/test_open.py
new file mode 100644
index 00000000..8a3429f2
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/tests/test_open.py
@@ -0,0 +1,73 @@
+import unittest
+
+import importlib_resources as resources
+from . import data01
+from . import util
+from .._compat import FileNotFoundError
+
+
+class CommonBinaryTests(util.CommonTests, unittest.TestCase):
+    def execute(self, package, path):
+        with resources.open_binary(package, path):
+            pass
+
+
+class CommonTextTests(util.CommonTests, unittest.TestCase):
+    def execute(self, package, path):
+        with resources.open_text(package, path):
+            pass
+
+
+class OpenTests:
+    def test_open_binary(self):
+        with resources.open_binary(self.data, 'utf-8.file') as fp:
+            result = fp.read()
+            self.assertEqual(result, b'Hello, UTF-8 world!\n')
+
+    def test_open_text_default_encoding(self):
+        with resources.open_text(self.data, 'utf-8.file') as fp:
+            result = fp.read()
+            self.assertEqual(result, 'Hello, UTF-8 world!\n')
+
+    def test_open_text_given_encoding(self):
+        with resources.open_text(
+                self.data, 'utf-16.file', 'utf-16', 'strict') as fp:
+            result = fp.read()
+        self.assertEqual(result, 'Hello, UTF-16 world!\n')
+
+    def test_open_text_with_errors(self):
+        # Raises UnicodeError without the 'errors' argument.
+        with resources.open_text(
+                self.data, 'utf-16.file', 'utf-8', 'strict') as fp:
+            self.assertRaises(UnicodeError, fp.read)
+        with resources.open_text(
+                self.data, 'utf-16.file', 'utf-8', 'ignore') as fp:
+            result = fp.read()
+        self.assertEqual(
+            result,
+            'H\x00e\x00l\x00l\x00o\x00,\x00 '
+            '\x00U\x00T\x00F\x00-\x001\x006\x00 '
+            '\x00w\x00o\x00r\x00l\x00d\x00!\x00\n\x00')
+
+    def test_open_binary_FileNotFoundError(self):
+        self.assertRaises(
+            FileNotFoundError,
+            resources.open_binary, self.data, 'does-not-exist')
+
+    def test_open_text_FileNotFoundError(self):
+        self.assertRaises(
+            FileNotFoundError,
+            resources.open_text, self.data, 'does-not-exist')
+
+
+class OpenDiskTests(OpenTests, unittest.TestCase):
+    def setUp(self):
+        self.data = data01
+
+
+class OpenZipTests(OpenTests, util.ZipSetup, unittest.TestCase):
+    pass
+
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/pipenv/vendor/importlib_resources/tests/test_path.py b/pipenv/vendor/importlib_resources/tests/test_path.py
new file mode 100644
index 00000000..f6004756
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/tests/test_path.py
@@ -0,0 +1,42 @@
+import unittest
+
+import importlib_resources as resources
+from . import data01
+from . import util
+
+
+class CommonTests(util.CommonTests, unittest.TestCase):
+
+    def execute(self, package, path):
+        with resources.path(package, path):
+            pass
+
+
+class PathTests:
+
+    def test_reading(self):
+        # Path should be readable.
+        # Test also implicitly verifies the returned object is a pathlib.Path
+        # instance.
+        with resources.path(self.data, 'utf-8.file') as path:
+            self.assertTrue(path.name.endswith("utf-8.file"), repr(path))
+            # pathlib.Path.read_text() was introduced in Python 3.5.
+            with path.open('r', encoding='utf-8') as file:
+                text = file.read()
+            self.assertEqual('Hello, UTF-8 world!\n', text)
+
+
+class PathDiskTests(PathTests, unittest.TestCase):
+    data = data01
+
+
+class PathZipTests(PathTests, util.ZipSetup, unittest.TestCase):
+    def test_remove_in_context_manager(self):
+        # It is not an error if the file that was temporarily stashed on the
+        # file system is removed inside the `with` stanza.
+        with resources.path(self.data, 'utf-8.file') as path:
+            path.unlink()
+
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/pipenv/vendor/importlib_resources/tests/test_read.py b/pipenv/vendor/importlib_resources/tests/test_read.py
new file mode 100644
index 00000000..ee94d8ad
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/tests/test_read.py
@@ -0,0 +1,63 @@
+import unittest
+import importlib_resources as resources
+
+from . import data01
+from . import util
+from importlib import import_module
+
+
+class CommonBinaryTests(util.CommonTests, unittest.TestCase):
+    def execute(self, package, path):
+        resources.read_binary(package, path)
+
+
+class CommonTextTests(util.CommonTests, unittest.TestCase):
+    def execute(self, package, path):
+        resources.read_text(package, path)
+
+
+class ReadTests:
+    def test_read_binary(self):
+        result = resources.read_binary(self.data, 'binary.file')
+        self.assertEqual(result, b'\0\1\2\3')
+
+    def test_read_text_default_encoding(self):
+        result = resources.read_text(self.data, 'utf-8.file')
+        self.assertEqual(result, 'Hello, UTF-8 world!\n')
+
+    def test_read_text_given_encoding(self):
+        result = resources.read_text(
+            self.data, 'utf-16.file', encoding='utf-16')
+        self.assertEqual(result, 'Hello, UTF-16 world!\n')
+
+    def test_read_text_with_errors(self):
+        # Raises UnicodeError without the 'errors' argument.
+        self.assertRaises(
+            UnicodeError, resources.read_text, self.data, 'utf-16.file')
+        result = resources.read_text(self.data, 'utf-16.file', errors='ignore')
+        self.assertEqual(
+            result,
+            'H\x00e\x00l\x00l\x00o\x00,\x00 '
+            '\x00U\x00T\x00F\x00-\x001\x006\x00 '
+            '\x00w\x00o\x00r\x00l\x00d\x00!\x00\n\x00')
+
+
+class ReadDiskTests(ReadTests, unittest.TestCase):
+    data = data01
+
+
+class ReadZipTests(ReadTests, util.ZipSetup, unittest.TestCase):
+    def test_read_submodule_resource(self):
+        submodule = import_module('ziptestdata.subdirectory')
+        result = resources.read_binary(
+            submodule, 'binary.file')
+        self.assertEqual(result, b'\0\1\2\3')
+
+    def test_read_submodule_resource_by_name(self):
+        result = resources.read_binary(
+            'ziptestdata.subdirectory', 'binary.file')
+        self.assertEqual(result, b'\0\1\2\3')
+
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/pipenv/vendor/importlib_resources/tests/test_resource.py b/pipenv/vendor/importlib_resources/tests/test_resource.py
new file mode 100644
index 00000000..8c5a72cb
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/tests/test_resource.py
@@ -0,0 +1,170 @@
+import sys
+import unittest
+import importlib_resources as resources
+
+from . import data01
+from . import zipdata01, zipdata02
+from . import util
+from importlib import import_module
+
+
+class ResourceTests:
+    # Subclasses are expected to set the `data` attribute.
+
+    def test_is_resource_good_path(self):
+        self.assertTrue(resources.is_resource(self.data, 'binary.file'))
+
+    def test_is_resource_missing(self):
+        self.assertFalse(resources.is_resource(self.data, 'not-a-file'))
+
+    def test_is_resource_subresource_directory(self):
+        # Directories are not resources.
+        self.assertFalse(resources.is_resource(self.data, 'subdirectory'))
+
+    def test_contents(self):
+        contents = set(resources.contents(self.data))
+        # There may be cruft in the directory listing of the data directory.
+        # Under Python 3 we could have a __pycache__ directory, and under
+        # Python 2 we could have .pyc files.  These are both artifacts of the
+        # test suite importing these modules and writing these caches.  They
+        # aren't germane to this test, so just filter them out.
+        contents.discard('__pycache__')
+        contents.discard('__init__.pyc')
+        contents.discard('__init__.pyo')
+        self.assertEqual(contents, {
+            '__init__.py',
+            'subdirectory',
+            'utf-8.file',
+            'binary.file',
+            'utf-16.file',
+            })
+
+
+class ResourceDiskTests(ResourceTests, unittest.TestCase):
+    def setUp(self):
+        self.data = data01
+
+
+class ResourceZipTests(ResourceTests, util.ZipSetup, unittest.TestCase):
+    pass
+
+
+@unittest.skipIf(sys.version_info < (3,), 'No ResourceReader in Python 2')
+class ResourceLoaderTests(unittest.TestCase):
+    def test_resource_contents(self):
+        package = util.create_package(
+            file=data01, path=data01.__file__, contents=['A', 'B', 'C'])
+        self.assertEqual(
+            set(resources.contents(package)),
+            {'A', 'B', 'C'})
+
+    def test_resource_is_resource(self):
+        package = util.create_package(
+            file=data01, path=data01.__file__,
+            contents=['A', 'B', 'C', 'D/E', 'D/F'])
+        self.assertTrue(resources.is_resource(package, 'B'))
+
+    def test_resource_directory_is_not_resource(self):
+        package = util.create_package(
+            file=data01, path=data01.__file__,
+            contents=['A', 'B', 'C', 'D/E', 'D/F'])
+        self.assertFalse(resources.is_resource(package, 'D'))
+
+    def test_resource_missing_is_not_resource(self):
+        package = util.create_package(
+            file=data01, path=data01.__file__,
+            contents=['A', 'B', 'C', 'D/E', 'D/F'])
+        self.assertFalse(resources.is_resource(package, 'Z'))
+
+
+class ResourceCornerCaseTests(unittest.TestCase):
+    def test_package_has_no_reader_fallback(self):
+        # Test odd ball packages which:
+        # 1. Do not have a ResourceReader as a loader
+        # 2. Are not on the file system
+        # 3. Are not in a zip file
+        module = util.create_package(
+            file=data01, path=data01.__file__, contents=['A', 'B', 'C'])
+        # Give the module a dummy loader.
+        module.__loader__ = object()
+        # Give the module a dummy origin.
+        module.__file__ = '/path/which/shall/not/be/named'
+        if sys.version_info >= (3,):
+            module.__spec__.loader = module.__loader__
+            module.__spec__.origin = module.__file__
+        self.assertFalse(resources.is_resource(module, 'A'))
+
+
+class ResourceFromZipsTest01(util.ZipSetupBase, unittest.TestCase):
+    ZIP_MODULE = zipdata01                          # type: ignore
+
+    def test_is_submodule_resource(self):
+        submodule = import_module('ziptestdata.subdirectory')
+        self.assertTrue(
+            resources.is_resource(submodule, 'binary.file'))
+
+    def test_read_submodule_resource_by_name(self):
+        self.assertTrue(
+            resources.is_resource('ziptestdata.subdirectory', 'binary.file'))
+
+    def test_submodule_contents(self):
+        submodule = import_module('ziptestdata.subdirectory')
+        self.assertEqual(
+            set(resources.contents(submodule)),
+            {'__init__.py', 'binary.file'})
+
+    def test_submodule_contents_by_name(self):
+        self.assertEqual(
+            set(resources.contents('ziptestdata.subdirectory')),
+            {'__init__.py', 'binary.file'})
+
+
+class ResourceFromZipsTest02(util.ZipSetupBase, unittest.TestCase):
+    ZIP_MODULE = zipdata02                          # type: ignore
+
+    def test_unrelated_contents(self):
+        # https://gitlab.com/python-devs/importlib_resources/issues/44
+        #
+        # Here we have a zip file with two unrelated subpackages.  The bug
+        # reports that getting the contents of a resource returns unrelated
+        # files.
+        self.assertEqual(
+            set(resources.contents('ziptestdata.one')),
+            {'__init__.py', 'resource1.txt'})
+        self.assertEqual(
+            set(resources.contents('ziptestdata.two')),
+            {'__init__.py', 'resource2.txt'})
+
+
+@unittest.skipIf(sys.version_info < (3,), 'No namespace packages in Python 2')
+class NamespaceTest(unittest.TestCase):
+    def test_namespaces_cannot_have_resources(self):
+        contents = resources.contents(
+            'importlib_resources.tests.data03.namespace')
+        self.assertFalse(list(contents))
+        # Even though there is a file in the namespace directory, it is not
+        # considered a resource, since namespace packages can't have them.
+        self.assertFalse(resources.is_resource(
+            'importlib_resources.tests.data03.namespace',
+            'resource1.txt'))
+        # We should get an exception if we try to read it or open it.
+        self.assertRaises(
+            FileNotFoundError,
+            resources.open_text,
+            'importlib_resources.tests.data03.namespace', 'resource1.txt')
+        self.assertRaises(
+            FileNotFoundError,
+            resources.open_binary,
+            'importlib_resources.tests.data03.namespace', 'resource1.txt')
+        self.assertRaises(
+            FileNotFoundError,
+            resources.read_text,
+            'importlib_resources.tests.data03.namespace', 'resource1.txt')
+        self.assertRaises(
+            FileNotFoundError,
+            resources.read_binary,
+            'importlib_resources.tests.data03.namespace', 'resource1.txt')
+
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/pipenv/vendor/importlib_resources/tests/util.py b/pipenv/vendor/importlib_resources/tests/util.py
new file mode 100644
index 00000000..8c26496d
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/tests/util.py
@@ -0,0 +1,213 @@
+import abc
+import importlib
+import io
+import sys
+import types
+import unittest
+
+from . import data01
+from . import zipdata01
+from .._compat import ABC, Path, PurePath, FileNotFoundError
+from ..abc import ResourceReader
+
+try:
+    from test.support import modules_setup, modules_cleanup
+except ImportError:
+    # Python 2.7.
+    def modules_setup():
+        return sys.modules.copy(),
+
+    def modules_cleanup(oldmodules):
+        # Encoders/decoders are registered permanently within the internal
+        # codec cache. If we destroy the corresponding modules their
+        # globals will be set to None which will trip up the cached functions.
+        encodings = [(k, v) for k, v in sys.modules.items()
+                     if k.startswith('encodings.')]
+        sys.modules.clear()
+        sys.modules.update(encodings)
+        # XXX: This kind of problem can affect more than just encodings. In
+        # particular extension modules (such as _ssl) don't cope with reloading
+        # properly.  Really, test modules should be cleaning out the test
+        # specific modules they know they added (ala test_runpy) rather than
+        # relying on this function (as test_importhooks and test_pkg do
+        # currently).  Implicitly imported *real* modules should be left alone
+        # (see issue 10556).
+        sys.modules.update(oldmodules)
+
+
+try:
+    from importlib.machinery import ModuleSpec
+except ImportError:
+    ModuleSpec = None                               # type: ignore
+
+
+def create_package(file, path, is_package=True, contents=()):
+    class Reader(ResourceReader):
+        def get_resource_reader(self, package):
+            return self
+
+        def open_resource(self, path):
+            self._path = path
+            if isinstance(file, Exception):
+                raise file
+            else:
+                return file
+
+        def resource_path(self, path_):
+            self._path = path_
+            if isinstance(path, Exception):
+                raise path
+            else:
+                return path
+
+        def is_resource(self, path_):
+            self._path = path_
+            if isinstance(path, Exception):
+                raise path
+            for entry in contents:
+                parts = entry.split('/')
+                if len(parts) == 1 and parts[0] == path_:
+                    return True
+            return False
+
+        def contents(self):
+            if isinstance(path, Exception):
+                raise path
+            # There's no yield from in baseball, er, Python 2.
+            for entry in contents:
+                yield entry
+
+    name = 'testingpackage'
+    # Unforunately importlib.util.module_from_spec() was not introduced until
+    # Python 3.5.
+    module = types.ModuleType(name)
+    if ModuleSpec is None:
+        # Python 2.
+        module.__name__ = name
+        module.__file__ = 'does-not-exist'
+        if is_package:
+            module.__path__ = []
+    else:
+        # Python 3.
+        loader = Reader()
+        spec = ModuleSpec(
+            name, loader,
+            origin='does-not-exist',
+            is_package=is_package)
+        module.__spec__ = spec
+        module.__loader__ = loader
+    return module
+
+
+class CommonTests(ABC):
+
+    @abc.abstractmethod
+    def execute(self, package, path):
+        raise NotImplementedError
+
+    def test_package_name(self):
+        # Passing in the package name should succeed.
+        self.execute(data01.__name__, 'utf-8.file')
+
+    def test_package_object(self):
+        # Passing in the package itself should succeed.
+        self.execute(data01, 'utf-8.file')
+
+    def test_string_path(self):
+        # Passing in a string for the path should succeed.
+        path = 'utf-8.file'
+        self.execute(data01, path)
+
+    @unittest.skipIf(sys.version_info < (3, 6), 'requires os.PathLike support')
+    def test_pathlib_path(self):
+        # Passing in a pathlib.PurePath object for the path should succeed.
+        path = PurePath('utf-8.file')
+        self.execute(data01, path)
+
+    def test_absolute_path(self):
+        # An absolute path is a ValueError.
+        path = Path(__file__)
+        full_path = path.parent/'utf-8.file'
+        with self.assertRaises(ValueError):
+            self.execute(data01, full_path)
+
+    def test_relative_path(self):
+        # A reative path is a ValueError.
+        with self.assertRaises(ValueError):
+            self.execute(data01, '../data01/utf-8.file')
+
+    def test_importing_module_as_side_effect(self):
+        # The anchor package can already be imported.
+        del sys.modules[data01.__name__]
+        self.execute(data01.__name__, 'utf-8.file')
+
+    def test_non_package_by_name(self):
+        # The anchor package cannot be a module.
+        with self.assertRaises(TypeError):
+            self.execute(__name__, 'utf-8.file')
+
+    def test_non_package_by_package(self):
+        # The anchor package cannot be a module.
+        with self.assertRaises(TypeError):
+            module = sys.modules['importlib_resources.tests.util']
+            self.execute(module, 'utf-8.file')
+
+    @unittest.skipIf(sys.version_info < (3,), 'No ResourceReader in Python 2')
+    def test_resource_opener(self):
+        bytes_data = io.BytesIO(b'Hello, world!')
+        package = create_package(file=bytes_data, path=FileNotFoundError())
+        self.execute(package, 'utf-8.file')
+        self.assertEqual(package.__loader__._path, 'utf-8.file')
+
+    @unittest.skipIf(sys.version_info < (3,), 'No ResourceReader in Python 2')
+    def test_resource_path(self):
+        bytes_data = io.BytesIO(b'Hello, world!')
+        path = __file__
+        package = create_package(file=bytes_data, path=path)
+        self.execute(package, 'utf-8.file')
+        self.assertEqual(package.__loader__._path, 'utf-8.file')
+
+    def test_useless_loader(self):
+        package = create_package(file=FileNotFoundError(),
+                                 path=FileNotFoundError())
+        with self.assertRaises(FileNotFoundError):
+            self.execute(package, 'utf-8.file')
+
+
+class ZipSetupBase:
+    ZIP_MODULE = None
+
+    @classmethod
+    def setUpClass(cls):
+        data_path = Path(cls.ZIP_MODULE.__file__)
+        data_dir = data_path.parent
+        cls._zip_path = str(data_dir / 'ziptestdata.zip')
+        sys.path.append(cls._zip_path)
+        cls.data = importlib.import_module('ziptestdata')
+
+    @classmethod
+    def tearDownClass(cls):
+        try:
+            sys.path.remove(cls._zip_path)
+        except ValueError:
+            pass
+
+        try:
+            del sys.path_importer_cache[cls._zip_path]
+            del sys.modules[cls.data.__name__]
+        except KeyError:
+            pass
+
+        try:
+            del cls.data
+            del cls._zip_path
+        except AttributeError:
+            pass
+
+    def setUp(self):
+        modules = modules_setup()
+        self.addCleanup(modules_cleanup, *modules)
+
+
+class ZipSetup(ZipSetupBase):
+    ZIP_MODULE = zipdata01                          # type: ignore
diff --git a/pipenv/vendor/importlib_resources/tests/zipdata01/__init__.py b/pipenv/vendor/importlib_resources/tests/zipdata01/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/pipenv/vendor/importlib_resources/tests/zipdata01/ziptestdata.zip b/pipenv/vendor/importlib_resources/tests/zipdata01/ziptestdata.zip
new file mode 100644
index 00000000..ddcccfb3
Binary files /dev/null and b/pipenv/vendor/importlib_resources/tests/zipdata01/ziptestdata.zip differ
diff --git a/pipenv/vendor/importlib_resources/tests/zipdata02/__init__.py b/pipenv/vendor/importlib_resources/tests/zipdata02/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/pipenv/vendor/importlib_resources/tests/zipdata02/ziptestdata.zip b/pipenv/vendor/importlib_resources/tests/zipdata02/ziptestdata.zip
new file mode 100644
index 00000000..93f4ede5
Binary files /dev/null and b/pipenv/vendor/importlib_resources/tests/zipdata02/ziptestdata.zip differ
diff --git a/pipenv/vendor/importlib_resources/trees.py b/pipenv/vendor/importlib_resources/trees.py
new file mode 100644
index 00000000..ba42bb55
--- /dev/null
+++ b/pipenv/vendor/importlib_resources/trees.py
@@ -0,0 +1,6 @@
+# for compatibility with 1.1, continue to expose as_file here.
+
+from ._common import as_file
+
+
+__all__ = ['as_file']

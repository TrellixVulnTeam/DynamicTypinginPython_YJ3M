commit dc41e66df686661e20c4b6a56d8e67f9acc6bafc
Author: Dan Ryan <dan@danryan.co>
Date:   Mon Mar 4 14:33:39 2019 -0500

    Re-run vendoring script
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/patched/safety/__init__.py b/pipenv/patched/safety/__init__.py
index 56b497d2..69563274 100644
--- a/pipenv/patched/safety/__init__.py
+++ b/pipenv/patched/safety/__init__.py
@@ -2,4 +2,4 @@
 
 __author__ = """pyup.io"""
 __email__ = 'support@pyup.io'
-__version__ = '1.8.4'
+__version__ = '1.8.5'
diff --git a/pipenv/patched/safety/cli.py b/pipenv/patched/safety/cli.py
index 9ebd9e8a..2e8f88df 100644
--- a/pipenv/patched/safety/cli.py
+++ b/pipenv/patched/safety/cli.py
@@ -6,17 +6,13 @@ from safety import __version__
 from safety import safety
 from safety.formatter import report
 import itertools
-from safety.util import read_requirements
+from safety.util import read_requirements, read_vulnerabilities
 from safety.errors import DatabaseFetchError, DatabaseFileNotFoundError, InvalidKeyError
 
-
 try:
-    # pip 9
-    from pipenv.patched.notpip import get_installed_distributions
+    from json.decoder import JSONDecodeError
 except ImportError:
-    # pip 10
-    from pipenv.patched.notpip._internal.utils.misc import get_installed_distributions
-
+    JSONDecodeError = ValueError
 
 @click.group()
 @click.version_option(version=__version__)
@@ -46,10 +42,17 @@ def cli():
               help="Read input from one (or multiple) requirement files. Default: empty")
 @click.option("ignore", "--ignore", "-i", multiple=True, type=str, default=[],
               help="Ignore one (or multiple) vulnerabilities by ID. Default: empty")
-def check(key, db, json, full_report, bare, stdin, files, cache, ignore):
-
+@click.option("--output", "-o", default="",
+              help="Path to where output file will be placed. Default: empty")
+@click.option("proxyhost", "--proxy-host", "-ph", multiple=False, type=str, default=None,
+              help="Proxy host IP or DNS --proxy-host")
+@click.option("proxyport", "--proxy-port", "-pp", multiple=False, type=int, default=80,
+              help="Proxy port number --proxy-port")
+@click.option("proxyprotocol", "--proxy-protocol", "-pr", multiple=False, type=str, default='http',
+              help="Proxy protocol (https or http) --proxy-protocol")
+def check(key, db, json, full_report, bare, stdin, files, cache, ignore, output, proxyprotocol, proxyhost, proxyport):
     if files and stdin:
-        click.secho("Can't read from --stdin and --file at the same time, exiting", fg="red")
+        click.secho("Can't read from --stdin and --file at the same time, exiting", fg="red", file=sys.stderr)
         sys.exit(-1)
 
     if files:
@@ -57,33 +60,72 @@ def check(key, db, json, full_report, bare, stdin, files, cache, ignore):
     elif stdin:
         packages = list(read_requirements(sys.stdin))
     else:
-        packages = get_installed_distributions()
-
+        import pkg_resources
+        packages = [
+            d for d in pkg_resources.working_set
+            if d.key not in {"python", "wsgiref", "argparse"}
+        ]    
+    proxy_dictionary = {}
+    if proxyhost is not None:
+        if proxyprotocol in ["http", "https"]:
+            proxy_dictionary = {proxyprotocol: "{0}://{1}:{2}".format(proxyprotocol, proxyhost, str(proxyport))}
+        else:
+            click.secho("Proxy Protocol should be http or https only.", fg="red")
+            sys.exit(-1)
     try:
-        vulns = safety.check(packages=packages, key=key, db_mirror=db, cached=cache, ignore_ids=ignore)
-        click.secho(report(
-            vulns=vulns,
-            full=full_report,
-            json_report=json,
-            bare_report=bare,
-            checked_packages=len(packages),
-            db=db,
-            key=key
-            )
-        )
+        vulns = safety.check(packages=packages, key=key, db_mirror=db, cached=cache, ignore_ids=ignore, proxy=proxy_dictionary)
+        output_report = report(vulns=vulns, 
+                               full=full_report, 
+                               json_report=json, 
+                               bare_report=bare,
+                               checked_packages=len(packages), 
+                               db=db, 
+                               key=key)
+
+        if output:
+            with open(output, 'w+') as output_file:
+                output_file.write(output_report)
+        else:
+            click.secho(output_report, nl=False if bare and not vulns else True)
         sys.exit(-1 if vulns else 0)
     except InvalidKeyError:
         click.secho("Your API Key '{key}' is invalid. See {link}".format(
             key=key, link='https://goo.gl/O7Y1rS'),
-            fg="red")
+            fg="red",
+            file=sys.stderr)
         sys.exit(-1)
     except DatabaseFileNotFoundError:
-        click.secho("Unable to load vulnerability database from {db}".format(db=db), fg="red")
+        click.secho("Unable to load vulnerability database from {db}".format(db=db), fg="red", file=sys.stderr)
         sys.exit(-1)
     except DatabaseFetchError:
-        click.secho("Unable to load vulnerability database", fg="red")
+        click.secho("Unable to load vulnerability database", fg="red", file=sys.stderr)
         sys.exit(-1)
 
 
+@cli.command()
+@click.option("--full-report/--short-report", default=False,
+              help='Full reports include a security advisory (if available). Default: '
+                   '--short-report')
+@click.option("--bare/--not-bare", default=False,
+              help='Output vulnerable packages only. Useful in combination with other tools.'
+                   'Default: --not-bare')
+@click.option("file", "--file", "-f", type=click.File(), required=True,
+              help="Read input from an insecure report file. Default: empty")
+def review(full_report, bare, file):
+    if full_report and bare:
+        click.secho("Can't choose both --bare and --full-report/--short-report", fg="red")
+        sys.exit(-1)
+
+    try:
+        input_vulns = read_vulnerabilities(file)
+    except JSONDecodeError:
+        click.secho("Not a valid JSON file", fg="red")
+        sys.exit(-1)
+
+    vulns = safety.review(input_vulns)
+    output_report = report(vulns=vulns, full=full_report, bare_report=bare)
+    click.secho(output_report, nl=False if bare and not vulns else True)
+
+
 if __name__ == "__main__":
     cli()
diff --git a/pipenv/patched/safety/formatter.py b/pipenv/patched/safety/formatter.py
index 8bc57ec1..c19bff1b 100644
--- a/pipenv/patched/safety/formatter.py
+++ b/pipenv/patched/safety/formatter.py
@@ -3,6 +3,7 @@ import platform
 import sys
 import json
 import os
+import textwrap
 
 # python 2.7 compat
 try:
@@ -110,9 +111,10 @@ class SheetReport(object):
 
                     descr = get_advisory(vuln)
 
-                    for chunk in [descr[i:i + 76] for i in range(0, len(descr), 76)]:
-
-                        for line in chunk.splitlines():
+                    for pn, paragraph in enumerate(descr.replace('\r', '').split('\n\n')):
+                        if pn:
+                            table.append("│ {:76} │".format(''))
+                        for line in textwrap.wrap(paragraph, width=76):
                             try:
                                 table.append("│ {:76} │".format(line.encode('utf-8')))
                             except TypeError:
diff --git a/pipenv/patched/safety/safety.py b/pipenv/patched/safety/safety.py
index 99b99125..871bd775 100644
--- a/pipenv/patched/safety/safety.py
+++ b/pipenv/patched/safety/safety.py
@@ -9,6 +9,7 @@ import json
 import time
 import errno
 
+
 class Vulnerability(namedtuple("Vulnerability",
                                ["name", "spec", "version", "advisory", "vuln_id"])):
     pass
@@ -64,7 +65,7 @@ def write_to_cache(db_name, data):
         f.write(json.dumps(cache))
 
 
-def fetch_database_url(mirror, db_name, key, cached):
+def fetch_database_url(mirror, db_name, key, cached, proxy):
 
     headers = {}
     if key:
@@ -74,9 +75,8 @@ def fetch_database_url(mirror, db_name, key, cached):
         cached_data = get_from_cache(db_name=db_name)
         if cached_data:
             return cached_data
-
     url = mirror + db_name
-    r = requests.get(url=url, timeout=REQUEST_TIMEOUT, headers=headers)
+    r = requests.get(url=url, timeout=REQUEST_TIMEOUT, headers=headers, proxies=proxy)
     if r.status_code == 200:
         data = r.json()
         if cached:
@@ -94,7 +94,7 @@ def fetch_database_file(path, db_name):
         return json.loads(f.read())
 
 
-def fetch_database(full=False, key=False, db=False, cached=False):
+def fetch_database(full=False, key=False, db=False, cached=False, proxy={}):
 
     if db:
         mirrors = [db]
@@ -105,7 +105,7 @@ def fetch_database(full=False, key=False, db=False, cached=False):
     for mirror in mirrors:
         # mirror can either be a local path or a URL
         if mirror.startswith("http://") or mirror.startswith("https://"):
-            data = fetch_database_url(mirror, db_name=db_name, key=key, cached=cached)
+            data = fetch_database_url(mirror, db_name=db_name, key=key, cached=cached, proxy=proxy)
         else:
             data = fetch_database_file(mirror, db_name=db_name)
         if data:
@@ -120,10 +120,9 @@ def get_vulnerabilities(pkg, spec, db):
                 yield entry
 
 
-def check(packages, key, db_mirror, cached, ignore_ids):
-
+def check(packages, key, db_mirror, cached, ignore_ids, proxy):
     key = key if key else os.environ.get("SAFETY_API_KEY", False)
-    db = fetch_database(key=key, db=db_mirror, cached=cached)
+    db = fetch_database(key=key, db=db_mirror, cached=cached, proxy=proxy)
     db_full = None
     vulnerable_packages = frozenset(db.keys())
     vulnerable = []
@@ -152,3 +151,19 @@ def check(packages, key, db_mirror, cached, ignore_ids):
                                 )
                             )
     return vulnerable
+
+
+def review(vulnerabilities):
+    vulnerable = []
+    for vuln in vulnerabilities:
+        current_vuln = {
+            "name": vuln[0],
+            "spec": vuln[1],
+            "version": vuln[2],
+            "advisory": vuln[3],
+            "vuln_id": vuln[4],
+        }
+        vulnerable.append(
+            Vulnerability(**current_vuln)
+        )
+    return vulnerable
diff --git a/pipenv/patched/safety/util.py b/pipenv/patched/safety/util.py
index 2e6efaec..16062f41 100644
--- a/pipenv/patched/safety/util.py
+++ b/pipenv/patched/safety/util.py
@@ -1,11 +1,17 @@
 from dparse.parser import setuptools_parse_requirements_backport as _parse_requirements
 from collections import namedtuple
 import click
+import sys
+import json
 import os
 Package = namedtuple("Package", ["key", "version"])
 RequirementFile = namedtuple("RequirementFile", ["path"])
 
 
+def read_vulnerabilities(fh):
+    return json.load(fh)
+
+
 def iter_lines(fh, lineno=0):
     for line in fh.readlines()[lineno:]:
         yield line
@@ -85,7 +91,8 @@ def read_requirements(fh, resolve=False):
                         "Warning: unpinned requirement '{req}' found in {fname}, "
                         "unable to check.".format(req=req.name,
                                                   fname=fname),
-                        fg="yellow"
+                        fg="yellow",
+                        file=sys.stderr
                     )
             except ValueError:
                 continue
diff --git a/pipenv/vendor/attr/__init__.py b/pipenv/vendor/attr/__init__.py
index debfd57b..0ebe5197 100644
--- a/pipenv/vendor/attr/__init__.py
+++ b/pipenv/vendor/attr/__init__.py
@@ -18,7 +18,7 @@ from ._make import (
 )
 
 
-__version__ = "18.2.0"
+__version__ = "19.1.0"
 
 __title__ = "attrs"
 __description__ = "Classes Without Boilerplate"
diff --git a/pipenv/vendor/attr/__init__.pyi b/pipenv/vendor/attr/__init__.pyi
index 492fb85e..fcb93b18 100644
--- a/pipenv/vendor/attr/__init__.pyi
+++ b/pipenv/vendor/attr/__init__.pyi
@@ -23,9 +23,9 @@ from . import validators as validators
 _T = TypeVar("_T")
 _C = TypeVar("_C", bound=type)
 
-_ValidatorType = Callable[[Any, Attribute, _T], Any]
+_ValidatorType = Callable[[Any, Attribute[_T], _T], Any]
 _ConverterType = Callable[[Any], _T]
-_FilterType = Callable[[Attribute, Any], bool]
+_FilterType = Callable[[Attribute[_T], _T], bool]
 # FIXME: in reality, if multiple validators are passed they must be in a list or tuple,
 # but those are invariant and so would prevent subtypes of _ValidatorType from working
 # when passed in a list or tuple.
@@ -57,10 +57,10 @@ class Attribute(Generic[_T]):
     metadata: Dict[Any, Any]
     type: Optional[Type[_T]]
     kw_only: bool
-    def __lt__(self, x: Attribute) -> bool: ...
-    def __le__(self, x: Attribute) -> bool: ...
-    def __gt__(self, x: Attribute) -> bool: ...
-    def __ge__(self, x: Attribute) -> bool: ...
+    def __lt__(self, x: Attribute[_T]) -> bool: ...
+    def __le__(self, x: Attribute[_T]) -> bool: ...
+    def __gt__(self, x: Attribute[_T]) -> bool: ...
+    def __ge__(self, x: Attribute[_T]) -> bool: ...
 
 # NOTE: We had several choices for the annotation to use for type arg:
 # 1) Type[_T]
@@ -167,6 +167,7 @@ def attrs(
     auto_attribs: bool = ...,
     kw_only: bool = ...,
     cache_hash: bool = ...,
+    auto_exc: bool = ...,
 ) -> _C: ...
 @overload
 def attrs(
@@ -184,14 +185,15 @@ def attrs(
     auto_attribs: bool = ...,
     kw_only: bool = ...,
     cache_hash: bool = ...,
+    auto_exc: bool = ...,
 ) -> Callable[[_C], _C]: ...
 
 # TODO: add support for returning NamedTuple from the mypy plugin
-class _Fields(Tuple[Attribute, ...]):
-    def __getattr__(self, name: str) -> Attribute: ...
+class _Fields(Tuple[Attribute[Any], ...]):
+    def __getattr__(self, name: str) -> Attribute[Any]: ...
 
 def fields(cls: type) -> _Fields: ...
-def fields_dict(cls: type) -> Dict[str, Attribute]: ...
+def fields_dict(cls: type) -> Dict[str, Attribute[Any]]: ...
 def validate(inst: Any) -> None: ...
 
 # TODO: add support for returning a proper attrs class from the mypy plugin
@@ -212,6 +214,7 @@ def make_class(
     auto_attribs: bool = ...,
     kw_only: bool = ...,
     cache_hash: bool = ...,
+    auto_exc: bool = ...,
 ) -> type: ...
 
 # _funcs --
@@ -223,7 +226,7 @@ def make_class(
 def asdict(
     inst: Any,
     recurse: bool = ...,
-    filter: Optional[_FilterType] = ...,
+    filter: Optional[_FilterType[Any]] = ...,
     dict_factory: Type[Mapping[Any, Any]] = ...,
     retain_collection_types: bool = ...,
 ) -> Dict[str, Any]: ...
@@ -232,8 +235,8 @@ def asdict(
 def astuple(
     inst: Any,
     recurse: bool = ...,
-    filter: Optional[_FilterType] = ...,
-    tuple_factory: Type[Sequence] = ...,
+    filter: Optional[_FilterType[Any]] = ...,
+    tuple_factory: Type[Sequence[Any]] = ...,
     retain_collection_types: bool = ...,
 ) -> Tuple[Any, ...]: ...
 def has(cls: type) -> bool: ...
diff --git a/pipenv/vendor/attr/_compat.py b/pipenv/vendor/attr/_compat.py
index 5bb06593..9a99dcd9 100644
--- a/pipenv/vendor/attr/_compat.py
+++ b/pipenv/vendor/attr/_compat.py
@@ -20,6 +20,7 @@ else:
 
 if PY2:
     from UserDict import IterableUserDict
+    from collections import Mapping, Sequence  # noqa
 
     # We 'bundle' isclass instead of using inspect as importing inspect is
     # fairly expensive (order of 10-15 ms for a modern machine in 2016)
@@ -89,8 +90,27 @@ if PY2:
         res.data.update(d)  # We blocked update, so we have to do it like this.
         return res
 
+    def just_warn(*args, **kw):  # pragma: nocover
+        """
+        We only warn on Python 3 because we are not aware of any concrete
+        consequences of not setting the cell on Python 2.
+        """
 
-else:
+
+else:  # Python 3 and later.
+    from collections.abc import Mapping, Sequence  # noqa
+
+    def just_warn(*args, **kw):
+        """
+        We only warn on Python 3 because we are not aware of any concrete
+        consequences of not setting the cell on Python 2.
+        """
+        warnings.warn(
+            "Missing ctypes.  Some features like bare super() or accessing "
+            "__class__ will not work with slotted classes.",
+            RuntimeWarning,
+            stacklevel=2,
+        )
 
     def isclass(klass):
         return isinstance(klass, type)
@@ -113,30 +133,6 @@ def import_ctypes():
     return ctypes
 
 
-if not PY2:
-
-    def just_warn(*args, **kw):
-        """
-        We only warn on Python 3 because we are not aware of any concrete
-        consequences of not setting the cell on Python 2.
-        """
-        warnings.warn(
-            "Missing ctypes.  Some features like bare super() or accessing "
-            "__class__ will not work with slots classes.",
-            RuntimeWarning,
-            stacklevel=2,
-        )
-
-
-else:
-
-    def just_warn(*args, **kw):  # pragma: nocover
-        """
-        We only warn on Python 3 because we are not aware of any concrete
-        consequences of not setting the cell on Python 2.
-        """
-
-
 def make_set_closure_cell():
     """
     Moved into a function for testability.
diff --git a/pipenv/vendor/attr/_make.py b/pipenv/vendor/attr/_make.py
index f7fd05e7..827175a4 100644
--- a/pipenv/vendor/attr/_make.py
+++ b/pipenv/vendor/attr/_make.py
@@ -409,12 +409,11 @@ def _transform_attrs(cls, these, auto_attribs, kw_only):
             a.kw_only is False
         ):
             had_default = True
-        if was_kw_only is True and a.kw_only is False:
+        if was_kw_only is True and a.kw_only is False and a.init is True:
             raise ValueError(
                 "Non keyword-only attributes are not allowed after a "
-                "keyword-only attribute.  Attribute in question: {a!r}".format(
-                    a=a
-                )
+                "keyword-only attribute (unless they are init=False).  "
+                "Attribute in question: {a!r}".format(a=a)
             )
         if was_kw_only is False and a.init is True and a.kw_only is True:
             was_kw_only = True
@@ -454,6 +453,7 @@ class _ClassBuilder(object):
         "_has_post_init",
         "_delete_attribs",
         "_base_attr_map",
+        "_is_exc",
     )
 
     def __init__(
@@ -466,6 +466,7 @@ class _ClassBuilder(object):
         auto_attribs,
         kw_only,
         cache_hash,
+        is_exc,
     ):
         attrs, base_attrs, base_map = _transform_attrs(
             cls, these, auto_attribs, kw_only
@@ -483,6 +484,7 @@ class _ClassBuilder(object):
         self._cache_hash = cache_hash
         self._has_post_init = bool(getattr(cls, "__attrs_post_init__", False))
         self._delete_attribs = not bool(these)
+        self._is_exc = is_exc
 
         self._cls_dict["__attrs_attrs__"] = self._attrs
 
@@ -530,6 +532,26 @@ class _ClassBuilder(object):
         for name, value in self._cls_dict.items():
             setattr(cls, name, value)
 
+        # Attach __setstate__. This is necessary to clear the hash code
+        # cache on deserialization. See issue
+        # https://github.com/python-attrs/attrs/issues/482 .
+        # Note that this code only handles setstate for dict classes.
+        # For slotted classes, see similar code in _create_slots_class .
+        if self._cache_hash:
+            existing_set_state_method = getattr(cls, "__setstate__", None)
+            if existing_set_state_method:
+                raise NotImplementedError(
+                    "Currently you cannot use hash caching if "
+                    "you specify your own __setstate__ method."
+                    "See https://github.com/python-attrs/attrs/issues/494 ."
+                )
+
+            def cache_hash_set_state(chss_self, _):
+                # clear hash code cache
+                setattr(chss_self, _hash_cache_field, None)
+
+            setattr(cls, "__setstate__", cache_hash_set_state)
+
         return cls
 
     def _create_slots_class(self):
@@ -582,6 +604,8 @@ class _ClassBuilder(object):
             """
             return tuple(getattr(self, name) for name in state_attr_names)
 
+        hash_caching_enabled = self._cache_hash
+
         def slots_setstate(self, state):
             """
             Automatically created by attrs.
@@ -589,6 +613,13 @@ class _ClassBuilder(object):
             __bound_setattr = _obj_setattr.__get__(self, Attribute)
             for name, value in zip(state_attr_names, state):
                 __bound_setattr(name, value)
+            # Clearing the hash code cache on deserialization is needed
+            # because hash codes can change from run to run. See issue
+            # https://github.com/python-attrs/attrs/issues/482 .
+            # Note that this code only handles setstate for slotted classes.
+            # For dict classes, see similar code in _patch_original_class .
+            if hash_caching_enabled:
+                __bound_setattr(_hash_cache_field, None)
 
         # slots and frozen require __getstate__/__setstate__ to work
         cd["__getstate__"] = slots_getstate
@@ -660,6 +691,7 @@ class _ClassBuilder(object):
                 self._slots,
                 self._cache_hash,
                 self._base_attr_map,
+                self._is_exc,
             )
         )
 
@@ -710,6 +742,7 @@ def attrs(
     auto_attribs=False,
     kw_only=False,
     cache_hash=False,
+    auto_exc=False,
 ):
     r"""
     A class decorator that adds `dunder
@@ -815,10 +848,23 @@ def attrs(
     :param bool cache_hash: Ensure that the object's hash code is computed
         only once and stored on the object.  If this is set to ``True``,
         hashing must be either explicitly or implicitly enabled for this
-        class.  If the hash code is cached, then no attributes of this
-        class which participate in hash code computation may be mutated
-        after object creation.
-
+        class.  If the hash code is cached, avoid any reassignments of
+        fields involved in hash code computation or mutations of the objects
+        those fields point to after object creation.  If such changes occur,
+        the behavior of the object's hash code is undefined.
+    :param bool auto_exc: If the class subclasses :class:`BaseException`
+        (which implicitly includes any subclass of any exception), the
+        following happens to behave like a well-behaved Python exceptions
+        class:
+
+        - the values for *cmp* and *hash* are ignored and the instances compare
+          and hash by the instance's ids (N.B. ``attrs`` will *not* remove
+          existing implementations of ``__hash__`` or the equality methods. It
+          just won't add own ones.),
+        - all attributes that are either passed into ``__init__`` or have a
+          default value are additionally available as a tuple in the ``args``
+          attribute,
+        - the value of *str* is ignored leaving ``__str__`` to base classes.
 
     .. versionadded:: 16.0.0 *slots*
     .. versionadded:: 16.1.0 *frozen*
@@ -838,12 +884,16 @@ def attrs(
        to each other.
     .. versionadded:: 18.2.0 *kw_only*
     .. versionadded:: 18.2.0 *cache_hash*
+    .. versionadded:: 19.1.0 *auto_exc*
     """
 
     def wrap(cls):
+
         if getattr(cls, "__class__", None) is None:
             raise TypeError("attrs only works with new-style classes.")
 
+        is_exc = auto_exc is True and issubclass(cls, BaseException)
+
         builder = _ClassBuilder(
             cls,
             these,
@@ -853,13 +903,14 @@ def attrs(
             auto_attribs,
             kw_only,
             cache_hash,
+            is_exc,
         )
 
         if repr is True:
             builder.add_repr(repr_ns)
         if str is True:
             builder.add_str()
-        if cmp is True:
+        if cmp is True and not is_exc:
             builder.add_cmp()
 
         if hash is not True and hash is not False and hash is not None:
@@ -874,7 +925,11 @@ def attrs(
                     " hashing must be either explicitly or implicitly "
                     "enabled."
                 )
-        elif hash is True or (hash is None and cmp is True and frozen is True):
+        elif (
+            hash is True
+            or (hash is None and cmp is True and frozen is True)
+            and is_exc is False
+        ):
             builder.add_hash()
         else:
             if cache_hash:
@@ -1213,7 +1268,9 @@ def _add_repr(cls, ns=None, attrs=None):
     return cls
 
 
-def _make_init(attrs, post_init, frozen, slots, cache_hash, base_attr_map):
+def _make_init(
+    attrs, post_init, frozen, slots, cache_hash, base_attr_map, is_exc
+):
     attrs = [a for a in attrs if a.init or a.default is not NOTHING]
 
     # We cache the generated init methods for the same kinds of attributes.
@@ -1222,16 +1279,18 @@ def _make_init(attrs, post_init, frozen, slots, cache_hash, base_attr_map):
     unique_filename = "<attrs generated init {0}>".format(sha1.hexdigest())
 
     script, globs, annotations = _attrs_to_init_script(
-        attrs, frozen, slots, post_init, cache_hash, base_attr_map
+        attrs, frozen, slots, post_init, cache_hash, base_attr_map, is_exc
     )
     locs = {}
     bytecode = compile(script, unique_filename, "exec")
     attr_dict = dict((a.name, a) for a in attrs)
     globs.update({"NOTHING": NOTHING, "attr_dict": attr_dict})
+
     if frozen is True:
         # Save the lookup overhead in __init__ if we need to circumvent
         # immutability.
         globs["_cached_setattr"] = _obj_setattr
+
     eval(bytecode, globs, locs)
 
     # In order of debuggers like PDB being able to step through the code,
@@ -1245,22 +1304,8 @@ def _make_init(attrs, post_init, frozen, slots, cache_hash, base_attr_map):
 
     __init__ = locs["__init__"]
     __init__.__annotations__ = annotations
-    return __init__
 
-
-def _add_init(cls, frozen):
-    """
-    Add a __init__ method to *cls*.  If *frozen* is True, make it immutable.
-    """
-    cls.__init__ = _make_init(
-        cls.__attrs_attrs__,
-        getattr(cls, "__attrs_post_init__", False),
-        frozen,
-        _is_slot_cls(cls),
-        cache_hash=False,
-        base_attr_map={},
-    )
-    return cls
+    return __init__
 
 
 def fields(cls):
@@ -1348,7 +1393,7 @@ def _is_slot_attr(a_name, base_attr_map):
 
 
 def _attrs_to_init_script(
-    attrs, frozen, slots, post_init, cache_hash, base_attr_map
+    attrs, frozen, slots, post_init, cache_hash, base_attr_map, is_exc
 ):
     """
     Return a script of an initializer for *attrs* and a dict of globals.
@@ -1597,6 +1642,13 @@ def _attrs_to_init_script(
             init_hash_cache = "self.%s = %s"
         lines.append(init_hash_cache % (_hash_cache_field, "None"))
 
+    # For exceptions we rely on BaseException.__init__ for proper
+    # initialization.
+    if is_exc:
+        vals = ",".join("self." + a.name for a in attrs if a.init)
+
+        lines.append("BaseException.__init__(self, %s)" % (vals,))
+
     args = ", ".join(args)
     if kw_only_args:
         if PY2:
diff --git a/pipenv/vendor/attr/filters.pyi b/pipenv/vendor/attr/filters.pyi
index a618140c..68368fe2 100644
--- a/pipenv/vendor/attr/filters.pyi
+++ b/pipenv/vendor/attr/filters.pyi
@@ -1,5 +1,5 @@
-from typing import Union
+from typing import Union, Any
 from . import Attribute, _FilterType
 
-def include(*what: Union[type, Attribute]) -> _FilterType: ...
-def exclude(*what: Union[type, Attribute]) -> _FilterType: ...
+def include(*what: Union[type, Attribute[Any]]) -> _FilterType[Any]: ...
+def exclude(*what: Union[type, Attribute[Any]]) -> _FilterType[Any]: ...
diff --git a/pipenv/vendor/attr/validators.py b/pipenv/vendor/attr/validators.py
index f12d0aa5..7fc4446b 100644
--- a/pipenv/vendor/attr/validators.py
+++ b/pipenv/vendor/attr/validators.py
@@ -136,7 +136,7 @@ class _InValidator(object):
     def __call__(self, inst, attr, value):
         try:
             in_options = value in self.options
-        except TypeError as e:  # e.g. `1 in "abc"`
+        except TypeError:  # e.g. `1 in "abc"`
             in_options = False
 
         if not in_options:
@@ -168,3 +168,115 @@ def in_(options):
     .. versionadded:: 17.1.0
     """
     return _InValidator(options)
+
+
+@attrs(repr=False, slots=False, hash=True)
+class _IsCallableValidator(object):
+    def __call__(self, inst, attr, value):
+        """
+        We use a callable class to be able to change the ``__repr__``.
+        """
+        if not callable(value):
+            raise TypeError("'{name}' must be callable".format(name=attr.name))
+
+    def __repr__(self):
+        return "<is_callable validator>"
+
+
+def is_callable():
+    """
+    A validator that raises a :class:`TypeError` if the initializer is called
+    with a value for this particular attribute that is not callable.
+
+    .. versionadded:: 19.1.0
+
+    :raises TypeError: With a human readable error message containing the
+        attribute (of type :class:`attr.Attribute`) name.
+    """
+    return _IsCallableValidator()
+
+
+@attrs(repr=False, slots=True, hash=True)
+class _DeepIterable(object):
+    member_validator = attrib(validator=is_callable())
+    iterable_validator = attrib(
+        default=None, validator=optional(is_callable())
+    )
+
+    def __call__(self, inst, attr, value):
+        """
+        We use a callable class to be able to change the ``__repr__``.
+        """
+        if self.iterable_validator is not None:
+            self.iterable_validator(inst, attr, value)
+
+        for member in value:
+            self.member_validator(inst, attr, member)
+
+    def __repr__(self):
+        iterable_identifier = (
+            ""
+            if self.iterable_validator is None
+            else " {iterable!r}".format(iterable=self.iterable_validator)
+        )
+        return (
+            "<deep_iterable validator for{iterable_identifier}"
+            " iterables of {member!r}>"
+        ).format(
+            iterable_identifier=iterable_identifier,
+            member=self.member_validator,
+        )
+
+
+def deep_iterable(member_validator, iterable_validator=None):
+    """
+    A validator that performs deep validation of an iterable.
+
+    :param member_validator: Validator to apply to iterable members
+    :param iterable_validator: Validator to apply to iterable itself
+        (optional)
+
+    .. versionadded:: 19.1.0
+
+    :raises TypeError: if any sub-validators fail
+    """
+    return _DeepIterable(member_validator, iterable_validator)
+
+
+@attrs(repr=False, slots=True, hash=True)
+class _DeepMapping(object):
+    key_validator = attrib(validator=is_callable())
+    value_validator = attrib(validator=is_callable())
+    mapping_validator = attrib(default=None, validator=optional(is_callable()))
+
+    def __call__(self, inst, attr, value):
+        """
+        We use a callable class to be able to change the ``__repr__``.
+        """
+        if self.mapping_validator is not None:
+            self.mapping_validator(inst, attr, value)
+
+        for key in value:
+            self.key_validator(inst, attr, key)
+            self.value_validator(inst, attr, value[key])
+
+    def __repr__(self):
+        return (
+            "<deep_mapping validator for objects mapping {key!r} to {value!r}>"
+        ).format(key=self.key_validator, value=self.value_validator)
+
+
+def deep_mapping(key_validator, value_validator, mapping_validator=None):
+    """
+    A validator that performs deep validation of a dictionary.
+
+    :param key_validator: Validator to apply to dictionary keys
+    :param value_validator: Validator to apply to dictionary values
+    :param mapping_validator: Validator to apply to top-level mapping
+        attribute (optional)
+
+    .. versionadded:: 19.1.0
+
+    :raises TypeError: if any sub-validators fail
+    """
+    return _DeepMapping(key_validator, value_validator, mapping_validator)
diff --git a/pipenv/vendor/attr/validators.pyi b/pipenv/vendor/attr/validators.pyi
index abbaedf1..01af0684 100644
--- a/pipenv/vendor/attr/validators.pyi
+++ b/pipenv/vendor/attr/validators.pyi
@@ -12,3 +12,13 @@ def optional(
 ) -> _ValidatorType[Optional[_T]]: ...
 def in_(options: Container[_T]) -> _ValidatorType[_T]: ...
 def and_(*validators: _ValidatorType[_T]) -> _ValidatorType[_T]: ...
+def deep_iterable(
+    member_validator: _ValidatorType[_T],
+    iterable_validator: Optional[_ValidatorType[_T]],
+) -> _ValidatorType[_T]: ...
+def deep_mapping(
+    key_validator: _ValidatorType[_T],
+    value_validator: _ValidatorType[_T],
+    mapping_validator: Optional[_ValidatorType[_T]],
+) -> _ValidatorType[_T]: ...
+def is_callable() -> _ValidatorType[_T]: ...
diff --git a/pipenv/vendor/cursor/LICENSE b/pipenv/vendor/cursor/LICENSE
deleted file mode 100644
index 00023c80..00000000
--- a/pipenv/vendor/cursor/LICENSE
+++ /dev/null
@@ -1,5 +0,0 @@
-This work is licensed under the Creative Commons
-Attribution-ShareAlike 2.5 International License. To view a copy of 
-this license, visit http://creativecommons.org/licenses/by-sa/2.5/ or
-send a letter to Creative Commons, PO Box 1866, Mountain View, 
-CA 94042, USA.
diff --git a/pipenv/vendor/cursor/__init__.py b/pipenv/vendor/cursor/__init__.py
deleted file mode 100644
index 76a4f671..00000000
--- a/pipenv/vendor/cursor/__init__.py
+++ /dev/null
@@ -1,4 +0,0 @@
-from .cursor import hide, show, HiddenCursor
-
-__all__ = ["hide", "show", "HiddenCursor"]
-
diff --git a/pipenv/vendor/cursor/cursor.py b/pipenv/vendor/cursor/cursor.py
deleted file mode 100644
index e4407c02..00000000
--- a/pipenv/vendor/cursor/cursor.py
+++ /dev/null
@@ -1,57 +0,0 @@
-#!/usr/bin/env python2
-# -*- coding: utf-8 -*-
-
-## Author:          James Spencer: http://stackoverflow.com/users/1375885/james-spencer
-## Packager:        Gijs TImmers:  https://github.com/GijsTimmers
-
-## Based on James Spencer's answer on StackOverflow: 
-## http://stackoverflow.com/questions/5174810/how-to-turn-off-blinking-cursor-in-command-window
-
-## Licence:         CC-BY-SA-2.5
-##                  http://creativecommons.org/licenses/by-sa/2.5/
-
-## This work is licensed under the Creative Commons
-## Attribution-ShareAlike 2.5 International License. To  view a copy of
-## this license, visit http://creativecommons.org/licenses/by-sa/2.5/ or
-## send a letter to Creative Commons, PO Box 1866, Mountain View,
-## CA 94042, USA.
-
-import sys
-import os
-
-if os.name == 'nt':
-    import ctypes
-
-    class _CursorInfo(ctypes.Structure):
-        _fields_ = [("size", ctypes.c_int),
-                    ("visible", ctypes.c_byte)]
-
-def hide(stream=sys.stdout):
-    if os.name == 'nt':
-        ci = _CursorInfo()
-        handle = ctypes.windll.kernel32.GetStdHandle(-11)
-        ctypes.windll.kernel32.GetConsoleCursorInfo(handle, ctypes.byref(ci))
-        ci.visible = False
-        ctypes.windll.kernel32.SetConsoleCursorInfo(handle, ctypes.byref(ci))
-    elif os.name == 'posix':
-        stream.write("\033[?25l")
-        stream.flush()
-
-def show(stream=sys.stdout):
-    if os.name == 'nt':
-        ci = _CursorInfo()
-        handle = ctypes.windll.kernel32.GetStdHandle(-11)
-        ctypes.windll.kernel32.GetConsoleCursorInfo(handle, ctypes.byref(ci))
-        ci.visible = True
-        ctypes.windll.kernel32.SetConsoleCursorInfo(handle, ctypes.byref(ci))
-    elif os.name == 'posix':
-        stream.write("\033[?25h")
-        stream.flush()
-        
-class HiddenCursor(object):
-    def __init__(self, stream=sys.stdout):
-        self._stream = stream
-    def __enter__(self):
-        hide(stream=self._stream)
-    def __exit__(self, type, value, traceback):
-        show(stream=self._stream)
\ No newline at end of file
diff --git a/pipenv/vendor/markupsafe/LICENSE b/pipenv/vendor/markupsafe/LICENSE
deleted file mode 100644
index 5d269389..00000000
--- a/pipenv/vendor/markupsafe/LICENSE
+++ /dev/null
@@ -1,33 +0,0 @@
-Copyright (c) 2010 by Armin Ronacher and contributors.  See AUTHORS
-for more details.
-
-Some rights reserved.
-
-Redistribution and use in source and binary forms of the software as well
-as documentation, with or without modification, are permitted provided
-that the following conditions are met:
-
-* Redistributions of source code must retain the above copyright
-  notice, this list of conditions and the following disclaimer.
-
-* Redistributions in binary form must reproduce the above
-  copyright notice, this list of conditions and the following
-  disclaimer in the documentation and/or other materials provided
-  with the distribution.
-
-* The names of the contributors may not be used to endorse or
-  promote products derived from this software without specific
-  prior written permission.
-
-THIS SOFTWARE AND DOCUMENTATION IS PROVIDED BY THE COPYRIGHT HOLDERS AND
-CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
-NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
-OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE AND DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGE.
diff --git a/pipenv/vendor/markupsafe/LICENSE.rst b/pipenv/vendor/markupsafe/LICENSE.rst
new file mode 100644
index 00000000..9d227a0c
--- /dev/null
+++ b/pipenv/vendor/markupsafe/LICENSE.rst
@@ -0,0 +1,28 @@
+Copyright 2010 Pallets
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+1.  Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+
+2.  Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+
+3.  Neither the name of the copyright holder nor the names of its
+    contributors may be used to endorse or promote products derived from
+    this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/pipenv/vendor/markupsafe/__init__.py b/pipenv/vendor/markupsafe/__init__.py
index 68dc85f6..da05ed32 100644
--- a/pipenv/vendor/markupsafe/__init__.py
+++ b/pipenv/vendor/markupsafe/__init__.py
@@ -1,75 +1,74 @@
 # -*- coding: utf-8 -*-
 """
-    markupsafe
-    ~~~~~~~~~~
+markupsafe
+~~~~~~~~~~
 
-    Implements a Markup string.
+Implements an escape function and a Markup string to replace HTML
+special characters with safe representations.
 
-    :copyright: (c) 2010 by Armin Ronacher.
-    :license: BSD, see LICENSE for more details.
+:copyright: 2010 Pallets
+:license: BSD-3-Clause
 """
 import re
 import string
-from collections import Mapping
-from markupsafe._compat import text_type, string_types, int_types, \
-     unichr, iteritems, PY2
 
-__version__ = "1.0"
+from ._compat import int_types
+from ._compat import iteritems
+from ._compat import Mapping
+from ._compat import PY2
+from ._compat import string_types
+from ._compat import text_type
+from ._compat import unichr
 
-__all__ = ['Markup', 'soft_unicode', 'escape', 'escape_silent']
+__version__ = "1.1.1"
 
+__all__ = ["Markup", "soft_unicode", "escape", "escape_silent"]
 
-_striptags_re = re.compile(r'(<!--.*?-->|<[^>]*>)')
-_entity_re = re.compile(r'&([^& ;]+);')
+_striptags_re = re.compile(r"(<!--.*?-->|<[^>]*>)")
+_entity_re = re.compile(r"&([^& ;]+);")
 
 
 class Markup(text_type):
-    r"""Marks a string as being safe for inclusion in HTML/XML output without
-    needing to be escaped.  This implements the `__html__` interface a couple
-    of frameworks and web applications use.  :class:`Markup` is a direct
-    subclass of `unicode` and provides all the methods of `unicode` just that
-    it escapes arguments passed and always returns `Markup`.
-
-    The `escape` function returns markup objects so that double escaping can't
-    happen.
-
-    The constructor of the :class:`Markup` class can be used for three
-    different things:  When passed an unicode object it's assumed to be safe,
-    when passed an object with an HTML representation (has an `__html__`
-    method) that representation is used, otherwise the object passed is
-    converted into a unicode string and then assumed to be safe:
-
-    >>> Markup("Hello <em>World</em>!")
-    Markup(u'Hello <em>World</em>!')
-    >>> class Foo(object):
-    ...  def __html__(self):
-    ...   return '<a href="#">foo</a>'
+    """A string that is ready to be safely inserted into an HTML or XML
+    document, either because it was escaped or because it was marked
+    safe.
+
+    Passing an object to the constructor converts it to text and wraps
+    it to mark it safe without escaping. To escape the text, use the
+    :meth:`escape` class method instead.
+
+    >>> Markup('Hello, <em>World</em>!')
+    Markup('Hello, <em>World</em>!')
+    >>> Markup(42)
+    Markup('42')
+    >>> Markup.escape('Hello, <em>World</em>!')
+    Markup('Hello &lt;em&gt;World&lt;/em&gt;!')
+
+    This implements the ``__html__()`` interface that some frameworks
+    use. Passing an object that implements ``__html__()`` will wrap the
+    output of that method, marking it safe.
+
+    >>> class Foo:
+    ...     def __html__(self):
+    ...         return '<a href="/foo">foo</a>'
     ...
     >>> Markup(Foo())
-    Markup(u'<a href="#">foo</a>')
+    Markup('<a href="/foo">foo</a>')
 
-    If you want object passed being always treated as unsafe you can use the
-    :meth:`escape` classmethod to create a :class:`Markup` object:
+    This is a subclass of the text type (``str`` in Python 3,
+    ``unicode`` in Python 2). It has the same methods as that type, but
+    all methods escape their arguments and return a ``Markup`` instance.
 
-    >>> Markup.escape("Hello <em>World</em>!")
-    Markup(u'Hello &lt;em&gt;World&lt;/em&gt;!')
-
-    Operations on a markup string are markup aware which means that all
-    arguments are passed through the :func:`escape` function:
-
-    >>> em = Markup("<em>%s</em>")
-    >>> em % "foo & bar"
-    Markup(u'<em>foo &amp; bar</em>')
-    >>> strong = Markup("<strong>%(text)s</strong>")
-    >>> strong % {'text': '<blink>hacker here</blink>'}
-    Markup(u'<strong>&lt;blink&gt;hacker here&lt;/blink&gt;</strong>')
-    >>> Markup("<em>Hello</em> ") + "<foo>"
-    Markup(u'<em>Hello</em> &lt;foo&gt;')
+    >>> Markup('<em>%s</em>') % 'foo & bar'
+    Markup('<em>foo &amp; bar</em>')
+    >>> Markup('<em>Hello</em> ') + '<foo>'
+    Markup('<em>Hello</em> &lt;foo&gt;')
     """
+
     __slots__ = ()
 
-    def __new__(cls, base=u'', encoding=None, errors='strict'):
-        if hasattr(base, '__html__'):
+    def __new__(cls, base=u"", encoding=None, errors="strict"):
+        if hasattr(base, "__html__"):
             base = base.__html__()
         if encoding is None:
             return text_type.__new__(cls, base)
@@ -79,12 +78,12 @@ class Markup(text_type):
         return self
 
     def __add__(self, other):
-        if isinstance(other, string_types) or hasattr(other, '__html__'):
+        if isinstance(other, string_types) or hasattr(other, "__html__"):
             return self.__class__(super(Markup, self).__add__(self.escape(other)))
         return NotImplemented
 
     def __radd__(self, other):
-        if hasattr(other, '__html__') or isinstance(other, string_types):
+        if hasattr(other, "__html__") or isinstance(other, string_types):
             return self.escape(other).__add__(self)
         return NotImplemented
 
@@ -92,6 +91,7 @@ class Markup(text_type):
         if isinstance(num, int_types):
             return self.__class__(text_type.__mul__(self, num))
         return NotImplemented
+
     __rmul__ = __mul__
 
     def __mod__(self, arg):
@@ -102,115 +102,124 @@ class Markup(text_type):
         return self.__class__(text_type.__mod__(self, arg))
 
     def __repr__(self):
-        return '%s(%s)' % (
-            self.__class__.__name__,
-            text_type.__repr__(self)
-        )
+        return "%s(%s)" % (self.__class__.__name__, text_type.__repr__(self))
 
     def join(self, seq):
         return self.__class__(text_type.join(self, map(self.escape, seq)))
+
     join.__doc__ = text_type.join.__doc__
 
     def split(self, *args, **kwargs):
         return list(map(self.__class__, text_type.split(self, *args, **kwargs)))
+
     split.__doc__ = text_type.split.__doc__
 
     def rsplit(self, *args, **kwargs):
         return list(map(self.__class__, text_type.rsplit(self, *args, **kwargs)))
+
     rsplit.__doc__ = text_type.rsplit.__doc__
 
     def splitlines(self, *args, **kwargs):
-        return list(map(self.__class__, text_type.splitlines(
-            self, *args, **kwargs)))
+        return list(map(self.__class__, text_type.splitlines(self, *args, **kwargs)))
+
     splitlines.__doc__ = text_type.splitlines.__doc__
 
     def unescape(self):
-        r"""Unescape markup again into an text_type string.  This also resolves
-        known HTML4 and XHTML entities:
+        """Convert escaped markup back into a text string. This replaces
+        HTML entities with the characters they represent.
 
-        >>> Markup("Main &raquo; <em>About</em>").unescape()
-        u'Main \xbb <em>About</em>'
+        >>> Markup('Main &raquo; <em>About</em>').unescape()
+        'Main » <em>About</em>'
         """
-        from markupsafe._constants import HTML_ENTITIES
+        from ._constants import HTML_ENTITIES
+
         def handle_match(m):
             name = m.group(1)
             if name in HTML_ENTITIES:
                 return unichr(HTML_ENTITIES[name])
             try:
-                if name[:2] in ('#x', '#X'):
+                if name[:2] in ("#x", "#X"):
                     return unichr(int(name[2:], 16))
-                elif name.startswith('#'):
+                elif name.startswith("#"):
                     return unichr(int(name[1:]))
             except ValueError:
                 pass
             # Don't modify unexpected input.
             return m.group()
+
         return _entity_re.sub(handle_match, text_type(self))
 
     def striptags(self):
-        r"""Unescape markup into an text_type string and strip all tags.  This
-        also resolves known HTML4 and XHTML entities.  Whitespace is
-        normalized to one:
+        """:meth:`unescape` the markup, remove tags, and normalize
+        whitespace to single spaces.
 
-        >>> Markup("Main &raquo;  <em>About</em>").striptags()
-        u'Main \xbb About'
+        >>> Markup('Main &raquo;\t<em>About</em>').striptags()
+        'Main » About'
         """
-        stripped = u' '.join(_striptags_re.sub('', self).split())
+        stripped = u" ".join(_striptags_re.sub("", self).split())
         return Markup(stripped).unescape()
 
     @classmethod
     def escape(cls, s):
-        """Escape the string.  Works like :func:`escape` with the difference
-        that for subclasses of :class:`Markup` this function would return the
-        correct subclass.
+        """Escape a string. Calls :func:`escape` and ensures that for
+        subclasses the correct type is returned.
         """
         rv = escape(s)
         if rv.__class__ is not cls:
             return cls(rv)
         return rv
 
-    def make_simple_escaping_wrapper(name):
+    def make_simple_escaping_wrapper(name):  # noqa: B902
         orig = getattr(text_type, name)
+
         def func(self, *args, **kwargs):
             args = _escape_argspec(list(args), enumerate(args), self.escape)
             _escape_argspec(kwargs, iteritems(kwargs), self.escape)
             return self.__class__(orig(self, *args, **kwargs))
+
         func.__name__ = orig.__name__
         func.__doc__ = orig.__doc__
         return func
 
-    for method in '__getitem__', 'capitalize', \
-                  'title', 'lower', 'upper', 'replace', 'ljust', \
-                  'rjust', 'lstrip', 'rstrip', 'center', 'strip', \
-                  'translate', 'expandtabs', 'swapcase', 'zfill':
+    for method in (
+        "__getitem__",
+        "capitalize",
+        "title",
+        "lower",
+        "upper",
+        "replace",
+        "ljust",
+        "rjust",
+        "lstrip",
+        "rstrip",
+        "center",
+        "strip",
+        "translate",
+        "expandtabs",
+        "swapcase",
+        "zfill",
+    ):
         locals()[method] = make_simple_escaping_wrapper(method)
 
-    # new in python 2.5
-    if hasattr(text_type, 'partition'):
-        def partition(self, sep):
-            return tuple(map(self.__class__,
-                             text_type.partition(self, self.escape(sep))))
-        def rpartition(self, sep):
-            return tuple(map(self.__class__,
-                             text_type.rpartition(self, self.escape(sep))))
-
-    # new in python 2.6
-    if hasattr(text_type, 'format'):
-        def format(*args, **kwargs):
-            self, args = args[0], args[1:]
-            formatter = EscapeFormatter(self.escape)
-            kwargs = _MagicFormatMapping(args, kwargs)
-            return self.__class__(formatter.vformat(self, args, kwargs))
-
-        def __html_format__(self, format_spec):
-            if format_spec:
-                raise ValueError('Unsupported format specification '
-                                 'for Markup.')
-            return self
+    def partition(self, sep):
+        return tuple(map(self.__class__, text_type.partition(self, self.escape(sep))))
+
+    def rpartition(self, sep):
+        return tuple(map(self.__class__, text_type.rpartition(self, self.escape(sep))))
+
+    def format(self, *args, **kwargs):
+        formatter = EscapeFormatter(self.escape)
+        kwargs = _MagicFormatMapping(args, kwargs)
+        return self.__class__(formatter.vformat(self, args, kwargs))
+
+    def __html_format__(self, format_spec):
+        if format_spec:
+            raise ValueError("Unsupported format specification " "for Markup.")
+        return self
 
     # not in python 3
-    if hasattr(text_type, '__getslice__'):
-        __getslice__ = make_simple_escaping_wrapper('__getslice__')
+    if hasattr(text_type, "__getslice__"):
+        __getslice__ = make_simple_escaping_wrapper("__getslice__")
 
     del method, make_simple_escaping_wrapper
 
@@ -229,7 +238,7 @@ class _MagicFormatMapping(Mapping):
         self._last_index = 0
 
     def __getitem__(self, key):
-        if key == '':
+        if key == "":
             idx = self._last_index
             self._last_index += 1
             try:
@@ -246,35 +255,37 @@ class _MagicFormatMapping(Mapping):
         return len(self._kwargs)
 
 
-if hasattr(text_type, 'format'):
-    class EscapeFormatter(string.Formatter):
+if hasattr(text_type, "format"):
 
+    class EscapeFormatter(string.Formatter):
         def __init__(self, escape):
             self.escape = escape
 
         def format_field(self, value, format_spec):
-            if hasattr(value, '__html_format__'):
+            if hasattr(value, "__html_format__"):
                 rv = value.__html_format__(format_spec)
-            elif hasattr(value, '__html__'):
+            elif hasattr(value, "__html__"):
                 if format_spec:
-                    raise ValueError('No format specification allowed '
-                                     'when formatting an object with '
-                                     'its __html__ method.')
+                    raise ValueError(
+                        "Format specifier {0} given, but {1} does not"
+                        " define __html_format__. A class that defines"
+                        " __html__ must define __html_format__ to work"
+                        " with format specifiers.".format(format_spec, type(value))
+                    )
                 rv = value.__html__()
             else:
                 # We need to make sure the format spec is unicode here as
                 # otherwise the wrong callback methods are invoked.  For
                 # instance a byte string there would invoke __str__ and
                 # not __unicode__.
-                rv = string.Formatter.format_field(
-                    self, value, text_type(format_spec))
+                rv = string.Formatter.format_field(self, value, text_type(format_spec))
             return text_type(self.escape(rv))
 
 
 def _escape_argspec(obj, iterable, escape):
     """Helper for various string-wrapped functions."""
     for key, value in iterable:
-        if hasattr(value, '__html__') or isinstance(value, string_types):
+        if hasattr(value, "__html__") or isinstance(value, string_types):
             obj[key] = escape(value)
     return obj
 
@@ -286,20 +297,31 @@ class _MarkupEscapeHelper(object):
         self.obj = obj
         self.escape = escape
 
-    __getitem__ = lambda s, x: _MarkupEscapeHelper(s.obj[x], s.escape)
-    __unicode__ = __str__ = lambda s: text_type(s.escape(s.obj))
-    __repr__ = lambda s: str(s.escape(repr(s.obj)))
-    __int__ = lambda s: int(s.obj)
-    __float__ = lambda s: float(s.obj)
+    def __getitem__(self, item):
+        return _MarkupEscapeHelper(self.obj[item], self.escape)
+
+    def __str__(self):
+        return text_type(self.escape(self.obj))
+
+    __unicode__ = __str__
+
+    def __repr__(self):
+        return str(self.escape(repr(self.obj)))
+
+    def __int__(self):
+        return int(self.obj)
+
+    def __float__(self):
+        return float(self.obj)
 
 
 # we have to import it down here as the speedups and native
 # modules imports the markup type which is define above.
 try:
-    from markupsafe._speedups import escape, escape_silent, soft_unicode
+    from ._speedups import escape, escape_silent, soft_unicode
 except ImportError:
-    from markupsafe._native import escape, escape_silent, soft_unicode
+    from ._native import escape, escape_silent, soft_unicode
 
 if not PY2:
     soft_str = soft_unicode
-    __all__.append('soft_str')
+    __all__.append("soft_str")
diff --git a/pipenv/vendor/markupsafe/_compat.py b/pipenv/vendor/markupsafe/_compat.py
index 62e5632a..bc05090f 100644
--- a/pipenv/vendor/markupsafe/_compat.py
+++ b/pipenv/vendor/markupsafe/_compat.py
@@ -1,12 +1,10 @@
 # -*- coding: utf-8 -*-
 """
-    markupsafe._compat
-    ~~~~~~~~~~~~~~~~~~
+markupsafe._compat
+~~~~~~~~~~~~~~~~~~
 
-    Compatibility module for different Python versions.
-
-    :copyright: (c) 2013 by Armin Ronacher.
-    :license: BSD, see LICENSE for more details.
+:copyright: 2010 Pallets
+:license: BSD-3-Clause
 """
 import sys
 
@@ -17,10 +15,19 @@ if not PY2:
     string_types = (str,)
     unichr = chr
     int_types = (int,)
-    iteritems = lambda x: iter(x.items())
+
+    def iteritems(x):
+        return iter(x.items())
+
+    from collections.abc import Mapping
+
 else:
     text_type = unicode
     string_types = (str, unicode)
     unichr = unichr
     int_types = (int, long)
-    iteritems = lambda x: x.iteritems()
+
+    def iteritems(x):
+        return x.iteritems()
+
+    from collections import Mapping
diff --git a/pipenv/vendor/markupsafe/_constants.py b/pipenv/vendor/markupsafe/_constants.py
index 919bf03c..7c57c2d2 100644
--- a/pipenv/vendor/markupsafe/_constants.py
+++ b/pipenv/vendor/markupsafe/_constants.py
@@ -1,267 +1,264 @@
 # -*- coding: utf-8 -*-
 """
-    markupsafe._constants
-    ~~~~~~~~~~~~~~~~~~~~~
+markupsafe._constants
+~~~~~~~~~~~~~~~~~~~~~
 
-    Highlevel implementation of the Markup string.
-
-    :copyright: (c) 2010 by Armin Ronacher.
-    :license: BSD, see LICENSE for more details.
+:copyright: 2010 Pallets
+:license: BSD-3-Clause
 """
 
-
 HTML_ENTITIES = {
-    'AElig': 198,
-    'Aacute': 193,
-    'Acirc': 194,
-    'Agrave': 192,
-    'Alpha': 913,
-    'Aring': 197,
-    'Atilde': 195,
-    'Auml': 196,
-    'Beta': 914,
-    'Ccedil': 199,
-    'Chi': 935,
-    'Dagger': 8225,
-    'Delta': 916,
-    'ETH': 208,
-    'Eacute': 201,
-    'Ecirc': 202,
-    'Egrave': 200,
-    'Epsilon': 917,
-    'Eta': 919,
-    'Euml': 203,
-    'Gamma': 915,
-    'Iacute': 205,
-    'Icirc': 206,
-    'Igrave': 204,
-    'Iota': 921,
-    'Iuml': 207,
-    'Kappa': 922,
-    'Lambda': 923,
-    'Mu': 924,
-    'Ntilde': 209,
-    'Nu': 925,
-    'OElig': 338,
-    'Oacute': 211,
-    'Ocirc': 212,
-    'Ograve': 210,
-    'Omega': 937,
-    'Omicron': 927,
-    'Oslash': 216,
-    'Otilde': 213,
-    'Ouml': 214,
-    'Phi': 934,
-    'Pi': 928,
-    'Prime': 8243,
-    'Psi': 936,
-    'Rho': 929,
-    'Scaron': 352,
-    'Sigma': 931,
-    'THORN': 222,
-    'Tau': 932,
-    'Theta': 920,
-    'Uacute': 218,
-    'Ucirc': 219,
-    'Ugrave': 217,
-    'Upsilon': 933,
-    'Uuml': 220,
-    'Xi': 926,
-    'Yacute': 221,
-    'Yuml': 376,
-    'Zeta': 918,
-    'aacute': 225,
-    'acirc': 226,
-    'acute': 180,
-    'aelig': 230,
-    'agrave': 224,
-    'alefsym': 8501,
-    'alpha': 945,
-    'amp': 38,
-    'and': 8743,
-    'ang': 8736,
-    'apos': 39,
-    'aring': 229,
-    'asymp': 8776,
-    'atilde': 227,
-    'auml': 228,
-    'bdquo': 8222,
-    'beta': 946,
-    'brvbar': 166,
-    'bull': 8226,
-    'cap': 8745,
-    'ccedil': 231,
-    'cedil': 184,
-    'cent': 162,
-    'chi': 967,
-    'circ': 710,
-    'clubs': 9827,
-    'cong': 8773,
-    'copy': 169,
-    'crarr': 8629,
-    'cup': 8746,
-    'curren': 164,
-    'dArr': 8659,
-    'dagger': 8224,
-    'darr': 8595,
-    'deg': 176,
-    'delta': 948,
-    'diams': 9830,
-    'divide': 247,
-    'eacute': 233,
-    'ecirc': 234,
-    'egrave': 232,
-    'empty': 8709,
-    'emsp': 8195,
-    'ensp': 8194,
-    'epsilon': 949,
-    'equiv': 8801,
-    'eta': 951,
-    'eth': 240,
-    'euml': 235,
-    'euro': 8364,
-    'exist': 8707,
-    'fnof': 402,
-    'forall': 8704,
-    'frac12': 189,
-    'frac14': 188,
-    'frac34': 190,
-    'frasl': 8260,
-    'gamma': 947,
-    'ge': 8805,
-    'gt': 62,
-    'hArr': 8660,
-    'harr': 8596,
-    'hearts': 9829,
-    'hellip': 8230,
-    'iacute': 237,
-    'icirc': 238,
-    'iexcl': 161,
-    'igrave': 236,
-    'image': 8465,
-    'infin': 8734,
-    'int': 8747,
-    'iota': 953,
-    'iquest': 191,
-    'isin': 8712,
-    'iuml': 239,
-    'kappa': 954,
-    'lArr': 8656,
-    'lambda': 955,
-    'lang': 9001,
-    'laquo': 171,
-    'larr': 8592,
-    'lceil': 8968,
-    'ldquo': 8220,
-    'le': 8804,
-    'lfloor': 8970,
-    'lowast': 8727,
-    'loz': 9674,
-    'lrm': 8206,
-    'lsaquo': 8249,
-    'lsquo': 8216,
-    'lt': 60,
-    'macr': 175,
-    'mdash': 8212,
-    'micro': 181,
-    'middot': 183,
-    'minus': 8722,
-    'mu': 956,
-    'nabla': 8711,
-    'nbsp': 160,
-    'ndash': 8211,
-    'ne': 8800,
-    'ni': 8715,
-    'not': 172,
-    'notin': 8713,
-    'nsub': 8836,
-    'ntilde': 241,
-    'nu': 957,
-    'oacute': 243,
-    'ocirc': 244,
-    'oelig': 339,
-    'ograve': 242,
-    'oline': 8254,
-    'omega': 969,
-    'omicron': 959,
-    'oplus': 8853,
-    'or': 8744,
-    'ordf': 170,
-    'ordm': 186,
-    'oslash': 248,
-    'otilde': 245,
-    'otimes': 8855,
-    'ouml': 246,
-    'para': 182,
-    'part': 8706,
-    'permil': 8240,
-    'perp': 8869,
-    'phi': 966,
-    'pi': 960,
-    'piv': 982,
-    'plusmn': 177,
-    'pound': 163,
-    'prime': 8242,
-    'prod': 8719,
-    'prop': 8733,
-    'psi': 968,
-    'quot': 34,
-    'rArr': 8658,
-    'radic': 8730,
-    'rang': 9002,
-    'raquo': 187,
-    'rarr': 8594,
-    'rceil': 8969,
-    'rdquo': 8221,
-    'real': 8476,
-    'reg': 174,
-    'rfloor': 8971,
-    'rho': 961,
-    'rlm': 8207,
-    'rsaquo': 8250,
-    'rsquo': 8217,
-    'sbquo': 8218,
-    'scaron': 353,
-    'sdot': 8901,
-    'sect': 167,
-    'shy': 173,
-    'sigma': 963,
-    'sigmaf': 962,
-    'sim': 8764,
-    'spades': 9824,
-    'sub': 8834,
-    'sube': 8838,
-    'sum': 8721,
-    'sup': 8835,
-    'sup1': 185,
-    'sup2': 178,
-    'sup3': 179,
-    'supe': 8839,
-    'szlig': 223,
-    'tau': 964,
-    'there4': 8756,
-    'theta': 952,
-    'thetasym': 977,
-    'thinsp': 8201,
-    'thorn': 254,
-    'tilde': 732,
-    'times': 215,
-    'trade': 8482,
-    'uArr': 8657,
-    'uacute': 250,
-    'uarr': 8593,
-    'ucirc': 251,
-    'ugrave': 249,
-    'uml': 168,
-    'upsih': 978,
-    'upsilon': 965,
-    'uuml': 252,
-    'weierp': 8472,
-    'xi': 958,
-    'yacute': 253,
-    'yen': 165,
-    'yuml': 255,
-    'zeta': 950,
-    'zwj': 8205,
-    'zwnj': 8204
+    "AElig": 198,
+    "Aacute": 193,
+    "Acirc": 194,
+    "Agrave": 192,
+    "Alpha": 913,
+    "Aring": 197,
+    "Atilde": 195,
+    "Auml": 196,
+    "Beta": 914,
+    "Ccedil": 199,
+    "Chi": 935,
+    "Dagger": 8225,
+    "Delta": 916,
+    "ETH": 208,
+    "Eacute": 201,
+    "Ecirc": 202,
+    "Egrave": 200,
+    "Epsilon": 917,
+    "Eta": 919,
+    "Euml": 203,
+    "Gamma": 915,
+    "Iacute": 205,
+    "Icirc": 206,
+    "Igrave": 204,
+    "Iota": 921,
+    "Iuml": 207,
+    "Kappa": 922,
+    "Lambda": 923,
+    "Mu": 924,
+    "Ntilde": 209,
+    "Nu": 925,
+    "OElig": 338,
+    "Oacute": 211,
+    "Ocirc": 212,
+    "Ograve": 210,
+    "Omega": 937,
+    "Omicron": 927,
+    "Oslash": 216,
+    "Otilde": 213,
+    "Ouml": 214,
+    "Phi": 934,
+    "Pi": 928,
+    "Prime": 8243,
+    "Psi": 936,
+    "Rho": 929,
+    "Scaron": 352,
+    "Sigma": 931,
+    "THORN": 222,
+    "Tau": 932,
+    "Theta": 920,
+    "Uacute": 218,
+    "Ucirc": 219,
+    "Ugrave": 217,
+    "Upsilon": 933,
+    "Uuml": 220,
+    "Xi": 926,
+    "Yacute": 221,
+    "Yuml": 376,
+    "Zeta": 918,
+    "aacute": 225,
+    "acirc": 226,
+    "acute": 180,
+    "aelig": 230,
+    "agrave": 224,
+    "alefsym": 8501,
+    "alpha": 945,
+    "amp": 38,
+    "and": 8743,
+    "ang": 8736,
+    "apos": 39,
+    "aring": 229,
+    "asymp": 8776,
+    "atilde": 227,
+    "auml": 228,
+    "bdquo": 8222,
+    "beta": 946,
+    "brvbar": 166,
+    "bull": 8226,
+    "cap": 8745,
+    "ccedil": 231,
+    "cedil": 184,
+    "cent": 162,
+    "chi": 967,
+    "circ": 710,
+    "clubs": 9827,
+    "cong": 8773,
+    "copy": 169,
+    "crarr": 8629,
+    "cup": 8746,
+    "curren": 164,
+    "dArr": 8659,
+    "dagger": 8224,
+    "darr": 8595,
+    "deg": 176,
+    "delta": 948,
+    "diams": 9830,
+    "divide": 247,
+    "eacute": 233,
+    "ecirc": 234,
+    "egrave": 232,
+    "empty": 8709,
+    "emsp": 8195,
+    "ensp": 8194,
+    "epsilon": 949,
+    "equiv": 8801,
+    "eta": 951,
+    "eth": 240,
+    "euml": 235,
+    "euro": 8364,
+    "exist": 8707,
+    "fnof": 402,
+    "forall": 8704,
+    "frac12": 189,
+    "frac14": 188,
+    "frac34": 190,
+    "frasl": 8260,
+    "gamma": 947,
+    "ge": 8805,
+    "gt": 62,
+    "hArr": 8660,
+    "harr": 8596,
+    "hearts": 9829,
+    "hellip": 8230,
+    "iacute": 237,
+    "icirc": 238,
+    "iexcl": 161,
+    "igrave": 236,
+    "image": 8465,
+    "infin": 8734,
+    "int": 8747,
+    "iota": 953,
+    "iquest": 191,
+    "isin": 8712,
+    "iuml": 239,
+    "kappa": 954,
+    "lArr": 8656,
+    "lambda": 955,
+    "lang": 9001,
+    "laquo": 171,
+    "larr": 8592,
+    "lceil": 8968,
+    "ldquo": 8220,
+    "le": 8804,
+    "lfloor": 8970,
+    "lowast": 8727,
+    "loz": 9674,
+    "lrm": 8206,
+    "lsaquo": 8249,
+    "lsquo": 8216,
+    "lt": 60,
+    "macr": 175,
+    "mdash": 8212,
+    "micro": 181,
+    "middot": 183,
+    "minus": 8722,
+    "mu": 956,
+    "nabla": 8711,
+    "nbsp": 160,
+    "ndash": 8211,
+    "ne": 8800,
+    "ni": 8715,
+    "not": 172,
+    "notin": 8713,
+    "nsub": 8836,
+    "ntilde": 241,
+    "nu": 957,
+    "oacute": 243,
+    "ocirc": 244,
+    "oelig": 339,
+    "ograve": 242,
+    "oline": 8254,
+    "omega": 969,
+    "omicron": 959,
+    "oplus": 8853,
+    "or": 8744,
+    "ordf": 170,
+    "ordm": 186,
+    "oslash": 248,
+    "otilde": 245,
+    "otimes": 8855,
+    "ouml": 246,
+    "para": 182,
+    "part": 8706,
+    "permil": 8240,
+    "perp": 8869,
+    "phi": 966,
+    "pi": 960,
+    "piv": 982,
+    "plusmn": 177,
+    "pound": 163,
+    "prime": 8242,
+    "prod": 8719,
+    "prop": 8733,
+    "psi": 968,
+    "quot": 34,
+    "rArr": 8658,
+    "radic": 8730,
+    "rang": 9002,
+    "raquo": 187,
+    "rarr": 8594,
+    "rceil": 8969,
+    "rdquo": 8221,
+    "real": 8476,
+    "reg": 174,
+    "rfloor": 8971,
+    "rho": 961,
+    "rlm": 8207,
+    "rsaquo": 8250,
+    "rsquo": 8217,
+    "sbquo": 8218,
+    "scaron": 353,
+    "sdot": 8901,
+    "sect": 167,
+    "shy": 173,
+    "sigma": 963,
+    "sigmaf": 962,
+    "sim": 8764,
+    "spades": 9824,
+    "sub": 8834,
+    "sube": 8838,
+    "sum": 8721,
+    "sup": 8835,
+    "sup1": 185,
+    "sup2": 178,
+    "sup3": 179,
+    "supe": 8839,
+    "szlig": 223,
+    "tau": 964,
+    "there4": 8756,
+    "theta": 952,
+    "thetasym": 977,
+    "thinsp": 8201,
+    "thorn": 254,
+    "tilde": 732,
+    "times": 215,
+    "trade": 8482,
+    "uArr": 8657,
+    "uacute": 250,
+    "uarr": 8593,
+    "ucirc": 251,
+    "ugrave": 249,
+    "uml": 168,
+    "upsih": 978,
+    "upsilon": 965,
+    "uuml": 252,
+    "weierp": 8472,
+    "xi": 958,
+    "yacute": 253,
+    "yen": 165,
+    "yuml": 255,
+    "zeta": 950,
+    "zwj": 8205,
+    "zwnj": 8204,
 }
diff --git a/pipenv/vendor/markupsafe/_native.py b/pipenv/vendor/markupsafe/_native.py
index 5e83f10a..cd08752c 100644
--- a/pipenv/vendor/markupsafe/_native.py
+++ b/pipenv/vendor/markupsafe/_native.py
@@ -1,36 +1,49 @@
 # -*- coding: utf-8 -*-
 """
-    markupsafe._native
-    ~~~~~~~~~~~~~~~~~~
+markupsafe._native
+~~~~~~~~~~~~~~~~~~
 
-    Native Python implementation the C module is not compiled.
+Native Python implementation used when the C module is not compiled.
 
-    :copyright: (c) 2010 by Armin Ronacher.
-    :license: BSD, see LICENSE for more details.
+:copyright: 2010 Pallets
+:license: BSD-3-Clause
 """
-from markupsafe import Markup
-from markupsafe._compat import text_type
+from . import Markup
+from ._compat import text_type
 
 
 def escape(s):
-    """Convert the characters &, <, >, ' and " in string s to HTML-safe
-    sequences.  Use this if you need to display text that might contain
-    such characters in HTML.  Marks return value as markup string.
+    """Replace the characters ``&``, ``<``, ``>``, ``'``, and ``"`` in
+    the string with HTML-safe sequences. Use this if you need to display
+    text that might contain such characters in HTML.
+
+    If the object has an ``__html__`` method, it is called and the
+    return value is assumed to already be safe for HTML.
+
+    :param s: An object to be converted to a string and escaped.
+    :return: A :class:`Markup` string with the escaped text.
     """
-    if hasattr(s, '__html__'):
-        return s.__html__()
-    return Markup(text_type(s)
-        .replace('&', '&amp;')
-        .replace('>', '&gt;')
-        .replace('<', '&lt;')
-        .replace("'", '&#39;')
-        .replace('"', '&#34;')
+    if hasattr(s, "__html__"):
+        return Markup(s.__html__())
+    return Markup(
+        text_type(s)
+        .replace("&", "&amp;")
+        .replace(">", "&gt;")
+        .replace("<", "&lt;")
+        .replace("'", "&#39;")
+        .replace('"', "&#34;")
     )
 
 
 def escape_silent(s):
-    """Like :func:`escape` but converts `None` into an empty
-    markup string.
+    """Like :func:`escape` but treats ``None`` as the empty string.
+    Useful with optional values, as otherwise you get the string
+    ``'None'`` when the value is ``None``.
+
+    >>> escape(None)
+    Markup('None')
+    >>> escape_silent(None)
+    Markup('')
     """
     if s is None:
         return Markup()
@@ -38,8 +51,18 @@ def escape_silent(s):
 
 
 def soft_unicode(s):
-    """Make a string unicode if it isn't already.  That way a markup
-    string is not converted back to unicode.
+    """Convert an object to a string if it isn't already. This preserves
+    a :class:`Markup` string rather than converting it back to a basic
+    string, so it will still be marked as safe and won't be escaped
+    again.
+
+    >>> value = escape('<User 1>')
+    >>> value
+    Markup('&lt;User 1&gt;')
+    >>> escape(str(value))
+    Markup('&amp;lt;User 1&amp;gt;')
+    >>> escape(soft_unicode(value))
+    Markup('&lt;User 1&gt;')
     """
     if not isinstance(s, text_type):
         s = text_type(s)
diff --git a/pipenv/vendor/markupsafe/_speedups.c b/pipenv/vendor/markupsafe/_speedups.c
index d779a68c..12d2c4a7 100644
--- a/pipenv/vendor/markupsafe/_speedups.c
+++ b/pipenv/vendor/markupsafe/_speedups.c
@@ -2,33 +2,30 @@
  * markupsafe._speedups
  * ~~~~~~~~~~~~~~~~~~~~
  *
- * This module implements functions for automatic escaping in C for better
- * performance.
+ * C implementation of escaping for better performance. Used instead of
+ * the native Python implementation when compiled.
  *
- * :copyright: (c) 2010 by Armin Ronacher.
- * :license: BSD.
+ * :copyright: 2010 Pallets
+ * :license: BSD-3-Clause
  */
-
 #include <Python.h>
 
+#if PY_MAJOR_VERSION < 3
 #define ESCAPED_CHARS_TABLE_SIZE 63
 #define UNICHR(x) (PyUnicode_AS_UNICODE((PyUnicodeObject*)PyUnicode_DecodeASCII(x, strlen(x), NULL)));
 
-#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
-typedef int Py_ssize_t;
-#define PY_SSIZE_T_MAX INT_MAX
-#define PY_SSIZE_T_MIN INT_MIN
+static Py_ssize_t escaped_chars_delta_len[ESCAPED_CHARS_TABLE_SIZE];
+static Py_UNICODE *escaped_chars_repl[ESCAPED_CHARS_TABLE_SIZE];
 #endif
 
-
 static PyObject* markup;
-static Py_ssize_t escaped_chars_delta_len[ESCAPED_CHARS_TABLE_SIZE];
-static Py_UNICODE *escaped_chars_repl[ESCAPED_CHARS_TABLE_SIZE];
 
 static int
 init_constants(void)
 {
 	PyObject *module;
+
+#if PY_MAJOR_VERSION < 3
 	/* mapping of characters to replace */
 	escaped_chars_repl['"'] = UNICHR("&#34;");
 	escaped_chars_repl['\''] = UNICHR("&#39;");
@@ -41,6 +38,7 @@ init_constants(void)
 	escaped_chars_delta_len['"'] = escaped_chars_delta_len['\''] = \
 		escaped_chars_delta_len['&'] = 4;
 	escaped_chars_delta_len['<'] = escaped_chars_delta_len['>'] = 3;
+#endif
 
 	/* import markup type so that we can mark the return value */
 	module = PyImport_ImportModule("markupsafe");
@@ -52,6 +50,7 @@ init_constants(void)
 	return 1;
 }
 
+#if PY_MAJOR_VERSION < 3
 static PyObject*
 escape_unicode(PyUnicodeObject *in)
 {
@@ -112,13 +111,192 @@ escape_unicode(PyUnicodeObject *in)
 
 	return (PyObject*)out;
 }
+#else /* PY_MAJOR_VERSION < 3 */
+
+#define GET_DELTA(inp, inp_end, delta) \
+	while (inp < inp_end) {	 \
+		switch (*inp++) {	   \
+		case '"':			   \
+		case '\'':			  \
+		case '&':			   \
+			delta += 4;		 \
+			break;			  \
+		case '<':			   \
+		case '>':			   \
+			delta += 3;		 \
+			break;			  \
+		}					   \
+	}
+
+#define DO_ESCAPE(inp, inp_end, outp) \
+	{  \
+		Py_ssize_t ncopy = 0;  \
+		while (inp < inp_end) {  \
+			switch (*inp) {  \
+			case '"':  \
+				memcpy(outp, inp-ncopy, sizeof(*outp)*ncopy); \
+				outp += ncopy; ncopy = 0; \
+				*outp++ = '&';  \
+				*outp++ = '#';  \
+				*outp++ = '3';  \
+				*outp++ = '4';  \
+				*outp++ = ';';  \
+				break;  \
+			case '\'':  \
+				memcpy(outp, inp-ncopy, sizeof(*outp)*ncopy); \
+				outp += ncopy; ncopy = 0; \
+				*outp++ = '&';  \
+				*outp++ = '#';  \
+				*outp++ = '3';  \
+				*outp++ = '9';  \
+				*outp++ = ';';  \
+				break;  \
+			case '&':  \
+				memcpy(outp, inp-ncopy, sizeof(*outp)*ncopy); \
+				outp += ncopy; ncopy = 0; \
+				*outp++ = '&';  \
+				*outp++ = 'a';  \
+				*outp++ = 'm';  \
+				*outp++ = 'p';  \
+				*outp++ = ';';  \
+				break;  \
+			case '<':  \
+				memcpy(outp, inp-ncopy, sizeof(*outp)*ncopy); \
+				outp += ncopy; ncopy = 0; \
+				*outp++ = '&';  \
+				*outp++ = 'l';  \
+				*outp++ = 't';  \
+				*outp++ = ';';  \
+				break;  \
+			case '>':  \
+				memcpy(outp, inp-ncopy, sizeof(*outp)*ncopy); \
+				outp += ncopy; ncopy = 0; \
+				*outp++ = '&';  \
+				*outp++ = 'g';  \
+				*outp++ = 't';  \
+				*outp++ = ';';  \
+				break;  \
+			default:  \
+				ncopy++; \
+			}  \
+            inp++; \
+		}  \
+		memcpy(outp, inp-ncopy, sizeof(*outp)*ncopy); \
+	}
+
+static PyObject*
+escape_unicode_kind1(PyUnicodeObject *in)
+{
+	Py_UCS1 *inp = PyUnicode_1BYTE_DATA(in);
+	Py_UCS1 *inp_end = inp + PyUnicode_GET_LENGTH(in);
+	Py_UCS1 *outp;
+	PyObject *out;
+	Py_ssize_t delta = 0;
+
+	GET_DELTA(inp, inp_end, delta);
+	if (!delta) {
+		Py_INCREF(in);
+		return (PyObject*)in;
+	}
+
+	out = PyUnicode_New(PyUnicode_GET_LENGTH(in) + delta,
+						PyUnicode_IS_ASCII(in) ? 127 : 255);
+	if (!out)
+		return NULL;
+
+	inp = PyUnicode_1BYTE_DATA(in);
+	outp = PyUnicode_1BYTE_DATA(out);
+	DO_ESCAPE(inp, inp_end, outp);
+	return out;
+}
+
+static PyObject*
+escape_unicode_kind2(PyUnicodeObject *in)
+{
+	Py_UCS2 *inp = PyUnicode_2BYTE_DATA(in);
+	Py_UCS2 *inp_end = inp + PyUnicode_GET_LENGTH(in);
+	Py_UCS2 *outp;
+	PyObject *out;
+	Py_ssize_t delta = 0;
+
+	GET_DELTA(inp, inp_end, delta);
+	if (!delta) {
+		Py_INCREF(in);
+		return (PyObject*)in;
+	}
+
+	out = PyUnicode_New(PyUnicode_GET_LENGTH(in) + delta, 65535);
+	if (!out)
+		return NULL;
+
+	inp = PyUnicode_2BYTE_DATA(in);
+	outp = PyUnicode_2BYTE_DATA(out);
+	DO_ESCAPE(inp, inp_end, outp);
+	return out;
+}
+
+
+static PyObject*
+escape_unicode_kind4(PyUnicodeObject *in)
+{
+	Py_UCS4 *inp = PyUnicode_4BYTE_DATA(in);
+	Py_UCS4 *inp_end = inp + PyUnicode_GET_LENGTH(in);
+	Py_UCS4 *outp;
+	PyObject *out;
+	Py_ssize_t delta = 0;
+
+	GET_DELTA(inp, inp_end, delta);
+	if (!delta) {
+		Py_INCREF(in);
+		return (PyObject*)in;
+	}
+
+	out = PyUnicode_New(PyUnicode_GET_LENGTH(in) + delta, 1114111);
+	if (!out)
+		return NULL;
+
+	inp = PyUnicode_4BYTE_DATA(in);
+	outp = PyUnicode_4BYTE_DATA(out);
+	DO_ESCAPE(inp, inp_end, outp);
+	return out;
+}
 
+static PyObject*
+escape_unicode(PyUnicodeObject *in)
+{
+	if (PyUnicode_READY(in))
+		return NULL;
+
+	switch (PyUnicode_KIND(in)) {
+	case PyUnicode_1BYTE_KIND:
+		return escape_unicode_kind1(in);
+	case PyUnicode_2BYTE_KIND:
+		return escape_unicode_kind2(in);
+	case PyUnicode_4BYTE_KIND:
+		return escape_unicode_kind4(in);
+	}
+	assert(0);  /* shouldn't happen */
+	return NULL;
+}
+#endif /* PY_MAJOR_VERSION < 3 */
 
 static PyObject*
 escape(PyObject *self, PyObject *text)
 {
+	static PyObject *id_html;
 	PyObject *s = NULL, *rv = NULL, *html;
 
+	if (id_html == NULL) {
+#if PY_MAJOR_VERSION < 3
+		id_html = PyString_InternFromString("__html__");
+#else
+		id_html = PyUnicode_InternFromString("__html__");
+#endif
+		if (id_html == NULL) {
+			return NULL;
+		}
+	}
+
 	/* we don't have to escape integers, bools or floats */
 	if (PyLong_CheckExact(text) ||
 #if PY_MAJOR_VERSION < 3
@@ -129,10 +307,16 @@ escape(PyObject *self, PyObject *text)
 		return PyObject_CallFunctionObjArgs(markup, text, NULL);
 
 	/* if the object has an __html__ method that performs the escaping */
-	html = PyObject_GetAttrString(text, "__html__");
+	html = PyObject_GetAttr(text ,id_html);
 	if (html) {
-		rv = PyObject_CallObject(html, NULL);
+		s = PyObject_CallObject(html, NULL);
 		Py_DECREF(html);
+		if (s == NULL) {
+			return NULL;
+		}
+		/* Convert to Markup object */
+		rv = PyObject_CallFunctionObjArgs(markup, (PyObject*)s, NULL);
+		Py_DECREF(s);
 		return rv;
 	}
 
diff --git a/pipenv/vendor/orderedmultidict/LICENSE b/pipenv/vendor/orderedmultidict/LICENSE.md
old mode 100755
new mode 100644
similarity index 95%
rename from pipenv/vendor/orderedmultidict/LICENSE
rename to pipenv/vendor/orderedmultidict/LICENSE.md
index fd832f40..210e8658
--- a/pipenv/vendor/orderedmultidict/LICENSE
+++ b/pipenv/vendor/orderedmultidict/LICENSE.md
@@ -28,4 +28,4 @@ OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\
 WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\
 SOFTWARE.
 
-For more information, please refer to <https://unlicense.org/>
+For more information, please refer to <http://unlicense.org/>
diff --git a/pipenv/vendor/parse.py b/pipenv/vendor/parse.py
index 7f9f0786..b5d543f9 100644
--- a/pipenv/vendor/parse.py
+++ b/pipenv/vendor/parse.py
@@ -3,7 +3,7 @@ r'''Parse strings using a specification based on the Python format() syntax.
    ``parse()`` is the opposite of ``format()``
 
 The module is set up to only export ``parse()``, ``search()``, ``findall()``,
-and ``with_pattern()`` when ``import *`` is used:
+and ``with_pattern()`` when ``import \*`` is used:
 
 >>> from parse import *
 
@@ -78,9 +78,11 @@ Some simple parse() format string examples:
 {'item': 'hand grenade'}
 >>> print(r['item'])
 hand grenade
+>>> 'item' in r
+True
 
-Dotted names and indexes are possible though the application must make
-additional sense of the result:
+Note that `in` only works if you have named fields. Dotted names and indexes
+are possible though the application must make additional sense of the result:
 
 >>> r = parse("Mmm, {food.type}, I love it!", "Mmm, spam, I love it!")
 >>> print(r)
@@ -132,38 +134,39 @@ The differences between `parse()` and `format()` are:
 ===== =========================================== ========
 Type  Characters Matched                          Output
 ===== =========================================== ========
- w    Letters and underscore                      str
- W    Non-letter and underscore                   str
- s    Whitespace                                  str
- S    Non-whitespace                              str
- d    Digits (effectively integer numbers)        int
- D    Non-digit                                   str
- n    Numbers with thousands separators (, or .)  int
- %    Percentage (converted to value/100.0)       float
- f    Fixed-point numbers                         float
- F    Decimal numbers                             Decimal
- e    Floating-point numbers with exponent        float
+l     Letters (ASCII)                             str
+w     Letters, numbers and underscore             str
+W     Not letters, numbers and underscore         str
+s     Whitespace                                  str
+S     Non-whitespace                              str
+d     Digits (effectively integer numbers)        int
+D     Non-digit                                   str
+n     Numbers with thousands separators (, or .)  int
+%     Percentage (converted to value/100.0)       float
+f     Fixed-point numbers                         float
+F     Decimal numbers                             Decimal
+e     Floating-point numbers with exponent        float
       e.g. 1.1e-10, NAN (all case insensitive)
- g    General number format (either d, f or e)    float
- b    Binary numbers                              int
- o    Octal numbers                               int
- x    Hexadecimal numbers (lower and upper case)  int
- ti   ISO 8601 format date/time                   datetime
+g     General number format (either d, f or e)    float
+b     Binary numbers                              int
+o     Octal numbers                               int
+x     Hexadecimal numbers (lower and upper case)  int
+ti    ISO 8601 format date/time                   datetime
       e.g. 1972-01-20T10:21:36Z ("T" and "Z"
       optional)
- te   RFC2822 e-mail format date/time             datetime
+te    RFC2822 e-mail format date/time             datetime
       e.g. Mon, 20 Jan 1972 10:21:36 +1000
- tg   Global (day/month) format date/time         datetime
+tg    Global (day/month) format date/time         datetime
       e.g. 20/1/1972 10:21:36 AM +1:00
- ta   US (month/day) format date/time             datetime
+ta    US (month/day) format date/time             datetime
       e.g. 1/20/1972 10:21:36 PM +10:30
- tc   ctime() format date/time                    datetime
+tc    ctime() format date/time                    datetime
       e.g. Sun Sep 16 01:03:52 1973
- th   HTTP log format date/time                   datetime
+th    HTTP log format date/time                   datetime
       e.g. 21/Nov/2011:00:07:11 +0000
- ts   Linux system log format date/time           datetime
+ts    Linux system log format date/time           datetime
       e.g. Nov  9 03:37:44
- tt   Time                                        time
+tt    Time                                        time
       e.g. 10:21:36 PM -5:30
 ===== =========================================== ========
 
@@ -342,6 +345,13 @@ the pattern, the actual match represents the shortest successful match for
 
 **Version history (in brief)**:
 
+- 1.11.1 Revert having unicode char in docstring, it breaks Bamboo builds(?!)
+- 1.11.0 Implement `__contains__` for Result instances.
+- 1.10.0 Introduce a "letters" matcher, since "w" matches numbers
+  also.
+- 1.9.1 Fix deprecation warnings around backslashes in regex strings
+  (thanks Mickael Schoentgen). Also fix some documentation formatting
+  issues.
 - 1.9.0 We now honor precision and width specifiers when parsing numbers
   and strings, allowing parsing of concatenated elements of fixed width
   (thanks Julia Signell)
@@ -400,12 +410,12 @@ the pattern, the actual match represents the shortest successful match for
   and removed the restriction on mixing fixed-position and named fields
 - 1.0.0 initial release
 
-This code is copyright 2012-2017 Richard Jones <richard@python.org>
+This code is copyright 2012-2019 Richard Jones <richard@python.org>
 See the end of the source file for the license of use.
 '''
 
 from __future__ import absolute_import
-__version__ = '1.9.0'
+__version__ = '1.11.1'
 
 # yes, I now have two problems
 import re
@@ -530,9 +540,9 @@ MONTHS_MAP = dict(
     Nov=11, November=11,
     Dec=12, December=12
 )
-DAYS_PAT = '(Mon|Tue|Wed|Thu|Fri|Sat|Sun)'
-MONTHS_PAT = '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)'
-ALL_MONTHS_PAT = '(%s)' % '|'.join(MONTHS_MAP)
+DAYS_PAT = r'(Mon|Tue|Wed|Thu|Fri|Sat|Sun)'
+MONTHS_PAT = r'(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)'
+ALL_MONTHS_PAT = r'(%s)' % '|'.join(MONTHS_MAP)
 TIME_PAT = r'(\d{1,2}:\d{1,2}(:\d{1,2}(\.\d+)?)?)'
 AM_PAT = r'(\s+[AP]M)'
 TZ_PAT = r'(\s+[-+]\d\d?:?\d\d)'
@@ -550,11 +560,11 @@ def date_convert(string, match, ymd=None, mdy=None, dmy=None,
         m=groups[mm]
         d=groups[dd]
     elif ymd is not None:
-        y, m, d = re.split('[-/\s]', groups[ymd])
+        y, m, d = re.split(r'[-/\s]', groups[ymd])
     elif mdy is not None:
-        m, d, y = re.split('[-/\s]', groups[mdy])
+        m, d, y = re.split(r'[-/\s]', groups[mdy])
     elif dmy is not None:
-        d, m, y = re.split('[-/\s]', groups[dmy])
+        d, m, y = re.split(r'[-/\s]', groups[dmy])
     elif d_m_y is not None:
         d, m, y = d_m_y
         d = groups[d]
@@ -636,10 +646,10 @@ class RepeatedNameError(ValueError):
 
 # note: {} are handled separately
 # note: I don't use r'' here because Sublime Text 2 syntax highlight has a fit
-REGEX_SAFETY = re.compile('([?\\\\.[\]()*+\^$!\|])')
+REGEX_SAFETY = re.compile(r'([?\\\\.[\]()*+\^$!\|])')
 
 # allowed field types
-ALLOWED_TYPES = set(list('nbox%fFegwWdDsS') +
+ALLOWED_TYPES = set(list('nbox%fFegwWdDsSl') +
     ['t' + c for c in 'ieahgcts'])
 
 
@@ -745,7 +755,7 @@ class Parser(object):
     @property
     def _match_re(self):
         if self.__match_re is None:
-            expression = '^%s$' % self._expression
+            expression = r'^%s$' % self._expression
             try:
                 self.__match_re = re.compile(expression, self._re_flags)
             except AssertionError:
@@ -923,16 +933,16 @@ class Parser(object):
                         name, self._name_types[name]))
                 group = self._name_to_group_map[name]
                 # match previously-seen value
-                return '(?P=%s)' % group
+                return r'(?P=%s)' % group
             else:
                 group = self._to_group_name(name)
                 self._name_types[name] = format
             self._named_fields.append(group)
             # this will become a group, which must not contain dots
-            wrap = '(?P<%s>%%s)' % group
+            wrap = r'(?P<%s>%%s)' % group
         else:
             self._fixed_fields.append(self._group_index)
-            wrap = '(%s)'
+            wrap = r'(%s)'
             if ':' in field:
                 format = field[1:]
             group = self._group_index
@@ -940,7 +950,7 @@ class Parser(object):
         # simplest case: no type specifier ({} or {name})
         if not format:
             self._group_index += 1
-            return wrap % '.+?'
+            return wrap % r'.+?'
 
         # decode the format specification
         format = extract_format(format, self._extra_types)
@@ -960,19 +970,19 @@ class Parser(object):
                 return type_converter(string)
             self._type_conversions[group] = f
         elif type == 'n':
-            s = '\d{1,3}([,.]\d{3})*'
+            s = r'\d{1,3}([,.]\d{3})*'
             self._group_index += 1
             self._type_conversions[group] = int_convert(10)
         elif type == 'b':
-            s = '(0[bB])?[01]+'
+            s = r'(0[bB])?[01]+'
             self._type_conversions[group] = int_convert(2)
             self._group_index += 1
         elif type == 'o':
-            s = '(0[oO])?[0-7]+'
+            s = r'(0[oO])?[0-7]+'
             self._type_conversions[group] = int_convert(8)
             self._group_index += 1
         elif type == 'x':
-            s = '(0[xX])?[0-9a-fA-F]+'
+            s = r'(0[xX])?[0-9a-fA-F]+'
             self._type_conversions[group] = int_convert(16)
             self._group_index += 1
         elif type == '%':
@@ -994,10 +1004,10 @@ class Parser(object):
             self._type_conversions[group] = lambda s, m: float(s)
         elif type == 'd':
             if format.get('width'):
-                width = '{1,%s}' % int(format['width'])
+                width = r'{1,%s}' % int(format['width'])
             else:
                 width = '+'
-            s = '\\d{w}|0[xX][0-9a-fA-F]{w}|0[bB][01]{w}|0[oO][0-7]{w}'.format(w=width)
+            s = r'\d{w}|0[xX][0-9a-fA-F]{w}|0[bB][01]{w}|0[oO][0-7]{w}'.format(w=width)
             self._type_conversions[group] = int_convert(10)
         elif type == 'ti':
             s = r'(\d{4}-\d\d-\d\d)((\s+|T)%s)?(Z|\s*[-+]\d\d:?\d\d)?' % \
@@ -1055,18 +1065,19 @@ class Parser(object):
             self._type_conversions[group] = partial(date_convert, mm=n+1, dd=n+3,
                 hms=n + 5)
             self._group_index += 5
-
+        elif type == 'l':
+            s = r'[A-Za-z]+'
         elif type:
             s = r'\%s+' % type
         elif format.get('precision'):
             if format.get('width'):
-                s = '.{%s,%s}?' % (format['width'], format['precision'])
+                s = r'.{%s,%s}?' % (format['width'], format['precision'])
             else:
-                s = '.{1,%s}?' % format['precision']
+                s = r'.{1,%s}?' % format['precision']
         elif format.get('width'):
-            s = '.{%s,}?' % format['width']
+            s = r'.{%s,}?' % format['width']
         else:
-            s = '.+?'
+            s = r'.+?'
 
         align = format['align']
         fill = format['fill']
@@ -1079,7 +1090,7 @@ class Parser(object):
                 # configurable fill defaulting to "0"
                 if not fill:
                     fill = '0'
-                s = '%s*' % fill + s
+                s = r'%s*' % fill + s
 
             # allow numbers to be prefixed with a sign
             s = r'[-+ ]?' + s
@@ -1101,7 +1112,7 @@ class Parser(object):
             if not align:
                 align = '>'
 
-        if fill in '.\+?*[](){}^$':
+        if fill in r'.\+?*[](){}^$':
             fill = '\\' + fill
 
         # align "=" has been handled
@@ -1118,8 +1129,11 @@ class Parser(object):
 class Result(object):
     '''The result of a parse() or search().
 
-    Fixed results may be looked up using result[index]. Named results may be
-    looked up using result['name'].
+    Fixed results may be looked up using `result[index]`.
+
+    Named results may be looked up using `result['name']`.
+
+    Named results may be tested for existence using `'name' in result`.
     '''
     def __init__(self, fixed, named, spans):
         self.fixed = fixed
@@ -1135,6 +1149,9 @@ class Result(object):
         return '<%s %r %r>' % (self.__class__.__name__, self.fixed,
             self.named)
 
+    def __contains__(self, name):
+        return name in self.named
+
 
 class Match(object):
     '''The result of a parse() or search() if no results are generated.
@@ -1295,7 +1312,7 @@ def compile(format, extra_types=None, case_sensitive=False):
     return Parser(format, extra_types=extra_types)
 
 
-# Copyright (c) 2012-2013 Richard Jones <richard@python.org>
+# Copyright (c) 2012-2019 Richard Jones <richard@python.org>
 #
 # Permission is hereby granted, free of charge, to any person obtaining a copy
 # of this software and associated documentation files (the "Software"), to deal
diff --git a/pipenv/vendor/pipdeptree.py b/pipenv/vendor/pipdeptree.py
index cc15c24a..899118cc 100644
--- a/pipenv/vendor/pipdeptree.py
+++ b/pipenv/vendor/pipdeptree.py
@@ -22,7 +22,7 @@ import pkg_resources
 # from graphviz import backend, Digraph
 
 
-__version__ = '0.13.1'
+__version__ = '0.13.2'
 
 
 flatten = chain.from_iterable
@@ -127,6 +127,13 @@ def guess_version(pkg_key, default='?'):
         return getattr(m, '__version__', default)
 
 
+def frozen_req_from_dist(dist):
+    try:
+        return FrozenRequirement.from_dist(dist)
+    except TypeError:
+        return FrozenRequirement.from_dist(dist, [])
+
+
 class Package(object):
     """Abstract class for wrappers around objects that pip returns.
 
@@ -154,7 +161,7 @@ class Package(object):
 
     @staticmethod
     def frozen_repr(obj):
-        fr = FrozenRequirement.from_dist(obj, [])
+        fr = frozen_req_from_dist(obj)
         return str(fr).strip()
 
     def __getattr__(self, key):
@@ -563,7 +570,7 @@ def _get_args():
 def main():
     args = _get_args()
     pkgs = get_installed_distributions(local_only=args.local_only,
-                                           user_only=args.user_only)
+                                       user_only=args.user_only)
 
     dist_index = build_dist_index(pkgs)
     tree = construct_tree(dist_index)
diff --git a/pipenv/vendor/pythonfinder/__init__.py b/pipenv/vendor/pythonfinder/__init__.py
index 9421573d..f3a981bd 100644
--- a/pipenv/vendor/pythonfinder/__init__.py
+++ b/pipenv/vendor/pythonfinder/__init__.py
@@ -1,16 +1,19 @@
 from __future__ import absolute_import, print_function
 
-__version__ = '1.1.11'
-
 # Add NullHandler to "pythonfinder" logger, because Python2's default root
 # logger has no handler and warnings like this would be reported:
 #
 # > No handlers could be found for logger "pythonfinder.models.pyenv"
 import logging
+
+from .exceptions import InvalidPythonVersion
+from .models import SystemPath, WindowsFinder
+from .pythonfinder import Finder
+
+__version__ = "1.2.0"
+
+
 logger = logging.getLogger(__name__)
 logger.addHandler(logging.NullHandler())
 
 __all__ = ["Finder", "WindowsFinder", "SystemPath", "InvalidPythonVersion"]
-from .pythonfinder import Finder
-from .models import SystemPath, WindowsFinder
-from .exceptions import InvalidPythonVersion
diff --git a/pipenv/vendor/pythonfinder/cli.py b/pipenv/vendor/pythonfinder/cli.py
index 7dc4ebd4..eb2e603a 100644
--- a/pipenv/vendor/pythonfinder/cli.py
+++ b/pipenv/vendor/pythonfinder/cli.py
@@ -13,9 +13,7 @@ from .pythonfinder import Finder
 @click.command()
 @click.option("--find", default=False, nargs=1, help="Find a specific python version.")
 @click.option("--which", default=False, nargs=1, help="Run the which command.")
-@click.option(
-    "--findall", is_flag=True, default=False, help="Find all python versions."
-)
+@click.option("--findall", is_flag=True, default=False, help="Find all python versions.")
 @click.option(
     "--version", is_flag=True, default=False, help="Display PythonFinder version."
 )
diff --git a/pipenv/vendor/pythonfinder/environment.py b/pipenv/vendor/pythonfinder/environment.py
index ce21fb79..eb000438 100644
--- a/pipenv/vendor/pythonfinder/environment.py
+++ b/pipenv/vendor/pythonfinder/environment.py
@@ -36,6 +36,7 @@ else:
 IGNORE_UNSUPPORTED = bool(os.environ.get("PYTHONFINDER_IGNORE_UNSUPPORTED", False))
 MYPY_RUNNING = os.environ.get("MYPY_RUNNING", is_type_checking())
 
+
 def get_shim_paths():
     shim_paths = []
     if ASDF_INSTALLED:
@@ -43,4 +44,6 @@ def get_shim_paths():
     if PYENV_INSTALLED:
         shim_paths.append(os.path.join(PYENV_ROOT, "shims"))
     return [os.path.normpath(os.path.normcase(p)) for p in shim_paths]
+
+
 SHIM_PATHS = get_shim_paths()
diff --git a/pipenv/vendor/pythonfinder/models/mixins.py b/pipenv/vendor/pythonfinder/models/mixins.py
index 31c3c202..c1e7312a 100644
--- a/pipenv/vendor/pythonfinder/models/mixins.py
+++ b/pipenv/vendor/pythonfinder/models/mixins.py
@@ -3,23 +3,23 @@ from __future__ import absolute_import, unicode_literals
 
 import abc
 import operator
-
 from collections import defaultdict
 
 import attr
 import six
-
 from cached_property import cached_property
 from vistir.compat import fs_str
 
 from ..environment import MYPY_RUNNING
 from ..exceptions import InvalidPythonVersion
 from ..utils import (
-    KNOWN_EXTS, Sequence, expand_paths, looks_like_python,
-    path_is_known_executable
+    KNOWN_EXTS,
+    Sequence,
+    expand_paths,
+    looks_like_python,
+    path_is_known_executable,
 )
 
-
 if MYPY_RUNNING:
     from .path import PathEntry
     from .python import PythonVersion
@@ -48,7 +48,9 @@ class BasePath(object):
     only_python = attr.ib(default=False)  # type: bool
     name = attr.ib(type=str)
     _py_version = attr.ib(default=None)  # type: Optional[PythonVersion]
-    _pythons = attr.ib(default=attr.Factory(defaultdict))  # type: DefaultDict[str, PathEntry]
+    _pythons = attr.ib(
+        default=attr.Factory(defaultdict)
+    )  # type: DefaultDict[str, PathEntry]
 
     def __str__(self):
         # type: () -> str
@@ -197,6 +199,7 @@ class BasePath(object):
         # type: () -> DefaultDict[Union[str, Path], PathEntry]
         if not self._pythons:
             from .path import PathEntry
+
             self._pythons = defaultdict(PathEntry)
             for python in self._iter_pythons():
                 python_path = python.path.as_posix()  # type: ignore
@@ -241,17 +244,13 @@ class BasePath(object):
         :rtype: List[:class:`~pythonfinder.models.PathEntry`]
         """
 
-        call_method = (
-            "find_all_python_versions" if self.is_dir else "find_python_version"
-        )
+        call_method = "find_all_python_versions" if self.is_dir else "find_python_version"
         sub_finder = operator.methodcaller(
             call_method, major, minor, patch, pre, dev, arch, name
         )
         if not self.is_dir:
             return sub_finder(self)
-        unnested = [
-            sub_finder(path) for path in expand_paths(self)
-        ]
+        unnested = [sub_finder(path) for path in expand_paths(self)]
         version_sort = operator.attrgetter("as_python.version_sort")
         unnested = [p for p in unnested if p is not None and p.as_python is not None]
         paths = sorted(unnested, key=version_sort, reverse=True)
@@ -291,13 +290,13 @@ class BasePath(object):
         matching_pythons = [
             [entry, entry.as_python.version_sort]
             for entry in self._iter_pythons()
-            if (entry is not None and entry.as_python is not None and
-                version_matcher(entry.py_version))
+            if (
+                entry is not None
+                and entry.as_python is not None
+                and version_matcher(entry.py_version)
+            )
         ]
-        results = sorted(matching_pythons,
-            key=operator.itemgetter(1, 0),
-            reverse=True,
-        )
+        results = sorted(matching_pythons, key=operator.itemgetter(1, 0), reverse=True)
         return next(iter(r[0] for r in results if r is not None), None)
 
 
@@ -316,9 +315,8 @@ class BaseFinder(object):
         raise NotImplementedError
 
     @classmethod
-    def create(cls,  # type: Type[BaseFinderType]
-        *args,  # type: Any
-        **kwargs  # type: Any
+    def create(
+        cls, *args, **kwargs  # type: Type[BaseFinderType]  # type: Any  # type: Any
     ):
         # type: (...) -> BaseFinderType
         raise NotImplementedError
diff --git a/pipenv/vendor/pythonfinder/models/path.py b/pipenv/vendor/pythonfinder/models/path.py
index 005a17b1..9e099b59 100644
--- a/pipenv/vendor/pythonfinder/models/path.py
+++ b/pipenv/vendor/pythonfinder/models/path.py
@@ -5,60 +5,90 @@ import copy
 import operator
 import os
 import sys
-
 from collections import defaultdict
 from itertools import chain
 
 import attr
 import six
-
 from cached_property import cached_property
 from vistir.compat import Path, fs_str
 
+from .mixins import BaseFinder, BasePath
+from .python import PythonVersion
 from ..environment import (
-    ASDF_DATA_DIR, ASDF_INSTALLED, MYPY_RUNNING, PYENV_INSTALLED, PYENV_ROOT,
-    SHIM_PATHS
+    ASDF_DATA_DIR,
+    ASDF_INSTALLED,
+    MYPY_RUNNING,
+    PYENV_INSTALLED,
+    PYENV_ROOT,
+    SHIM_PATHS,
 )
 from ..exceptions import InvalidPythonVersion
 from ..utils import (
-    Iterable, Sequence, ensure_path, expand_paths, filter_pythons, is_in_path,
-    looks_like_python, normalize_path, optional_instance_of,
-    parse_asdf_version_order, parse_pyenv_version_order,
-    path_is_known_executable, unnest
+    Iterable,
+    Sequence,
+    ensure_path,
+    expand_paths,
+    filter_pythons,
+    is_in_path,
+    looks_like_python,
+    normalize_path,
+    optional_instance_of,
+    parse_asdf_version_order,
+    parse_pyenv_version_order,
+    path_is_known_executable,
+    unnest,
 )
-from .mixins import BaseFinder, BasePath
-from .python import PythonVersion
-
 
 if MYPY_RUNNING:
     from typing import (
-        Optional, Dict, DefaultDict, Iterator, List, Union, Tuple, Generator, Callable,
-        Type, Any, TypeVar
+        Optional,
+        Dict,
+        DefaultDict,
+        Iterator,
+        List,
+        Union,
+        Tuple,
+        Generator,
+        Callable,
+        Type,
+        Any,
+        TypeVar,
     )
-    from .mixins import BaseFinder
     from .python import PythonFinder
     from .windows import WindowsFinder
-    FinderType = TypeVar('FinderType', BaseFinder, PythonFinder, WindowsFinder)
-    ChildType = Union[PythonFinder, PathEntry]
-    PathType = Union[PythonFinder, PathEntry]
+
+    FinderType = TypeVar("FinderType", BaseFinder, PythonFinder, WindowsFinder)
+    ChildType = Union[PythonFinder, "PathEntry"]
+    PathType = Union[PythonFinder, "PathEntry"]
 
 
 @attr.s
 class SystemPath(object):
     global_search = attr.ib(default=True)
-    paths = attr.ib(default=attr.Factory(defaultdict))  # type: DefaultDict[str, Union[PythonFinder, PathEntry]]
+    paths = attr.ib(
+        default=attr.Factory(defaultdict)
+    )  # type: DefaultDict[str, Union[PythonFinder, PathEntry]]
     _executables = attr.ib(default=attr.Factory(list))  # type: List[PathEntry]
-    _python_executables = attr.ib(default=attr.Factory(dict))  # type: Dict[str, PathEntry]
+    _python_executables = attr.ib(
+        default=attr.Factory(dict)
+    )  # type: Dict[str, PathEntry]
     path_order = attr.ib(default=attr.Factory(list))  # type: List[str]
     python_version_dict = attr.ib()  # type: DefaultDict[Tuple, List[PythonVersion]]
     only_python = attr.ib(default=False, type=bool)
-    pyenv_finder = attr.ib(default=None, validator=optional_instance_of("PythonFinder"))  # type: Optional[PythonFinder]
+    pyenv_finder = attr.ib(
+        default=None, validator=optional_instance_of("PythonFinder")
+    )  # type: Optional[PythonFinder]
     asdf_finder = attr.ib(default=None)  # type: Optional[PythonFinder]
     system = attr.ib(default=False, type=bool)
-    _version_dict = attr.ib(default=attr.Factory(defaultdict))  # type: DefaultDict[Tuple, List[PathEntry]]
+    _version_dict = attr.ib(
+        default=attr.Factory(defaultdict)
+    )  # type: DefaultDict[Tuple, List[PathEntry]]
     ignore_unsupported = attr.ib(default=False, type=bool)
 
-    __finders = attr.ib(default=attr.Factory(dict))  # type: Dict[str, Union[WindowsFinder, PythonFinder]]
+    __finders = attr.ib(
+        default=attr.Factory(dict)
+    )  # type: Dict[str, Union[WindowsFinder, PythonFinder]]
 
     def _register_finder(self, finder_name, finder):
         # type: (str, Union[WindowsFinder, PythonFinder]) -> None
@@ -117,7 +147,9 @@ class SystemPath(object):
     @cached_property
     def version_dict(self):
         # type: () -> DefaultDict[Tuple, List[PathEntry]]
-        self._version_dict = defaultdict(list)  # type: DefaultDict[Tuple, List[PathEntry]]
+        self._version_dict = defaultdict(
+            list
+        )  # type: DefaultDict[Tuple, List[PathEntry]]
         for finder_name, finder in self.__finders.items():
             for version, entry in finder.versions.items():
                 if finder_name == "windows":
@@ -171,9 +203,7 @@ class SystemPath(object):
         reversed_paths = reversed(self.path_order)
         paths = [normalize_path(p) for p in reversed_paths]
         normalized_target = normalize_path(path)
-        last_instance = next(
-            iter(p for p in paths if normalized_target in p), None
-        )
+        last_instance = next(iter(p for p in paths if normalized_target in p), None)
         if last_instance is None:
             raise ValueError("No instance found on path for target: {0!s}".format(path))
         path_index = self.path_order.index(last_instance)
@@ -190,19 +220,14 @@ class SystemPath(object):
         else:
             before_path = self.path_order[: start_idx + 1]
             after_path = self.path_order[start_idx + 2 :]
-        self.path_order = (
-            before_path + [p.as_posix() for p in paths] + after_path
-        )
+        self.path_order = before_path + [p.as_posix() for p in paths] + after_path
 
     def _remove_path(self, path):
         # type: (str) -> None
         path_copy = [p for p in reversed(self.path_order[:])]
         new_order = []
         target = normalize_path(path)
-        path_map = {
-            normalize_path(pth): pth
-            for pth in self.paths.keys()
-        }
+        path_map = {normalize_path(pth): pth for pth in self.paths.keys()}
         if target in path_map:
             del self.paths[path_map[target]]
         for current_path in path_copy:
@@ -215,10 +240,14 @@ class SystemPath(object):
     def _setup_asdf(self):
         # type: () -> None
         from .python import PythonFinder
+
         os_path = os.environ["PATH"].split(os.pathsep)
         self.asdf_finder = PythonFinder.create(
-            root=ASDF_DATA_DIR, ignore_unsupported=True,
-            sort_function=parse_asdf_version_order, version_glob_path="installs/python/*")
+            root=ASDF_DATA_DIR,
+            ignore_unsupported=True,
+            sort_function=parse_asdf_version_order,
+            version_glob_path="installs/python/*",
+        )
         asdf_index = None
         try:
             asdf_index = self._get_last_instance(ASDF_DATA_DIR)
@@ -253,7 +282,9 @@ class SystemPath(object):
             # TODO: This is called 'reload', should we load a new finder for the first
             # time here? lets just skip that for now to avoid unallowed finders
             pass
-        if (finder_name == "pyenv" and not PYENV_INSTALLED) or (finder_name == "asdf" and not ASDF_INSTALLED):
+        if (finder_name == "pyenv" and not PYENV_INSTALLED) or (
+            finder_name == "asdf" and not ASDF_INSTALLED
+        ):
             # Don't allow loading of finders that aren't explicitly 'installed' as it were
             pass
         setattr(self, finder_attr, None)
@@ -264,10 +295,15 @@ class SystemPath(object):
     def _setup_pyenv(self):
         # type: () -> None
         from .python import PythonFinder
+
         os_path = os.environ["PATH"].split(os.pathsep)
 
         self.pyenv_finder = PythonFinder.create(
-            root=PYENV_ROOT, sort_function=parse_pyenv_version_order, version_glob_path="versions/*", ignore_unsupported=self.ignore_unsupported)
+            root=PYENV_ROOT,
+            sort_function=parse_pyenv_version_order,
+            version_glob_path="versions/*",
+            ignore_unsupported=self.ignore_unsupported,
+        )
         pyenv_index = None
         try:
             pyenv_index = self._get_last_instance(PYENV_ROOT)
@@ -469,8 +505,7 @@ class SystemPath(object):
                 name = "{0!s}".format(major)
                 major = None
         sub_finder = operator.methodcaller(
-            "find_python_version",
-            major, minor, patch, pre, dev, arch, name,
+            "find_python_version", major, minor, patch, pre, dev, arch, name
         )
         alternate_sub_finder = None
         if name and not (minor or patch or pre or dev or arch or major):
@@ -517,7 +552,9 @@ class SystemPath(object):
         :rtype: :class:`pythonfinder.models.SystemPath`
         """
 
-        path_entries = defaultdict(PathEntry)  # type: DefaultDict[str, Union[PythonFinder, PathEntry]]
+        path_entries = defaultdict(
+            PathEntry
+        )  # type: DefaultDict[str, Union[PythonFinder, PathEntry]]
         paths = []  # type: List[str]
         if ignore_unsupported:
             os.environ["PYTHONFINDER_IGNORE_UNSUPPORTED"] = fs_str("1")
@@ -567,6 +604,7 @@ class PathEntry(BasePath):
     def _gen_children(self):
         # type: () -> Iterator
         from ..environment import get_shim_paths
+
         shim_paths = get_shim_paths()
         pass_name = self.name != self.path.name
         pass_args = {"is_root": False, "only_python": self.only_python}
@@ -602,7 +640,6 @@ class PathEntry(BasePath):
             self._children = children
         return self._children
 
-
     @classmethod
     def create(cls, path, is_root=False, only_python=False, pythons=None, name=None):
         # type: (Union[str, Path], bool, bool, Dict[str, PythonVersion], Optional[str]) -> PathEntry
@@ -622,16 +659,18 @@ class PathEntry(BasePath):
         if not name:
             guessed_name = True
             name = target.name
-        creation_args = {"path": target, "is_root": is_root, "only_python": only_python, "name": name}
+        creation_args = {
+            "path": target,
+            "is_root": is_root,
+            "only_python": only_python,
+            "name": name,
+        }
         if pythons:
             creation_args["pythons"] = pythons
         _new = cls(**creation_args)
         if pythons and only_python:
             children = {}
-            child_creation_args = {
-                "is_root": False,
-                "only_python": only_python
-            }
+            child_creation_args = {"is_root": False, "only_python": only_python}
             if not guessed_name:
                 child_creation_args["name"] = _new.name  # type: ignore
             for pth, python in pythons.items():
@@ -639,9 +678,7 @@ class PathEntry(BasePath):
                     continue
                 pth = ensure_path(pth)
                 children[pth.as_posix()] = PathEntry(  # type: ignore
-                    py_version=python,
-                    path=pth,
-                    **child_creation_args
+                    py_version=python, path=pth, **child_creation_args
                 )
             _new._children = children
         return _new
@@ -658,6 +695,7 @@ class VersionPath(SystemPath):
 
         Generates the version listings for it"""
         from .path import PathEntry
+
         path = ensure_path(path)
         path_entries = defaultdict(PathEntry)
         bin_ = "{base}/bin"
diff --git a/pipenv/vendor/pythonfinder/models/python.py b/pipenv/vendor/pythonfinder/models/python.py
index 8900660e..25a12d66 100644
--- a/pipenv/vendor/pythonfinder/models/python.py
+++ b/pipenv/vendor/pythonfinder/models/python.py
@@ -6,29 +6,44 @@ import logging
 import operator
 import platform
 import sys
-
 from collections import defaultdict
 
 import attr
 import six
-
 from packaging.version import Version
 from vistir.compat import Path, lru_cache
 
+from .mixins import BaseFinder, BasePath
 from ..environment import ASDF_DATA_DIR, MYPY_RUNNING, PYENV_ROOT, SYSTEM_ARCH
 from ..exceptions import InvalidPythonVersion
 from ..utils import (
-    RE_MATCHER, _filter_none, ensure_path, get_python_version, is_in_path,
-    looks_like_python, optional_instance_of, parse_asdf_version_order,
-    parse_pyenv_version_order, parse_python_version, unnest
+    RE_MATCHER,
+    _filter_none,
+    ensure_path,
+    get_python_version,
+    is_in_path,
+    looks_like_python,
+    optional_instance_of,
+    parse_asdf_version_order,
+    parse_pyenv_version_order,
+    parse_python_version,
+    unnest,
 )
-from .mixins import BaseFinder, BasePath
-
 
 if MYPY_RUNNING:
     from typing import (
-        DefaultDict, Optional, Callable, Generator, Any, Union, Tuple, List, Dict, Type,
-        TypeVar, Iterator
+        DefaultDict,
+        Optional,
+        Callable,
+        Generator,
+        Any,
+        Union,
+        Tuple,
+        List,
+        Dict,
+        Type,
+        TypeVar,
+        Iterator,
     )
     from .path import PathEntry
     from .._vendor.pep514tools.environment import Environment
@@ -68,8 +83,7 @@ class PythonFinder(BaseFinder, BasePath):
     def expanded_paths(self):
         # type: () -> Generator
         return (
-            path for path in unnest(p for p in self.versions.values())
-            if path is not None
+            path for path in unnest(p for p in self.versions.values()) if path is not None
         )
 
     @property
@@ -85,15 +99,20 @@ class PythonFinder(BaseFinder, BasePath):
     def get_version_order(self):
         # type: () -> List[Path]
         version_paths = [
-            p for p in self.root.glob(self.version_glob_path)
+            p
+            for p in self.root.glob(self.version_glob_path)
             if not (p.parent.name == "envs" or p.name == "envs")
         ]
         versions = {v.name: v for v in version_paths}
         version_order = []  # type: List[Path]
         if self.is_pyenv:
-            version_order = [versions[v] for v in parse_pyenv_version_order() if v in versions]
+            version_order = [
+                versions[v] for v in parse_pyenv_version_order() if v in versions
+            ]
         elif self.is_asdf:
-            version_order = [versions[v] for v in parse_asdf_version_order() if v in versions]
+            version_order = [
+                versions[v] for v in parse_asdf_version_order() if v in versions
+            ]
         for version in version_order:
             version_paths.remove(version)
         if version_order:
@@ -118,12 +137,12 @@ class PythonFinder(BaseFinder, BasePath):
     def _iter_version_bases(self):
         # type: () -> Iterator[Tuple[Path, PathEntry]]
         from .path import PathEntry
+
         for p in self.get_version_order():
             bin_dir = self.get_bin_dir(p)
             if bin_dir.exists() and bin_dir.is_dir():
                 entry = PathEntry.create(
-                    path=bin_dir.absolute(), only_python=False, name=p.name,
-                    is_root=True
+                    path=bin_dir.absolute(), only_python=False, name=p.name, is_root=True
                 )
                 self.roots[p] = entry
                 yield (p, entry)
@@ -146,8 +165,11 @@ class PythonFinder(BaseFinder, BasePath):
             except Exception:
                 if not self.ignore_unsupported:
                     raise
-                logger.warning("Unsupported Python version %r, ignoring...",
-                               base_path.name, exc_info=True)
+                logger.warning(
+                    "Unsupported Python version %r, ignoring...",
+                    base_path.name,
+                    exc_info=True,
+                )
                 continue
             if version is not None:
                 version_tuple = (
@@ -190,6 +212,7 @@ class PythonFinder(BaseFinder, BasePath):
         # type: () -> DefaultDict[str, PathEntry]
         if not self._pythons:
             from .path import PathEntry
+
             self._pythons = defaultdict(PathEntry)  # type: DefaultDict[str, PathEntry]
             for python in self._iter_pythons():
                 python_path = python.path.as_posix()  # type: ignore
@@ -206,13 +229,20 @@ class PythonFinder(BaseFinder, BasePath):
         return self.pythons
 
     @classmethod
-    def create(cls, root, sort_function, version_glob_path=None, ignore_unsupported=True):  # type: ignore
+    def create(
+        cls, root, sort_function, version_glob_path=None, ignore_unsupported=True
+    ):  # type: ignore
         # type: (Type[PythonFinder], str, Callable, Optional[str], bool) -> PythonFinder
         root = ensure_path(root)
         if not version_glob_path:
             version_glob_path = "versions/*"
-        return cls(root=root, path=root, ignore_unsupported=ignore_unsupported,  # type: ignore
-                   sort_function=sort_function, version_glob_path=version_glob_path)
+        return cls(
+            root=root,
+            path=root,
+            ignore_unsupported=ignore_unsupported,  # type: ignore
+            sort_function=sort_function,
+            version_glob_path=version_glob_path,
+        )
 
     def find_all_python_versions(
         self,
@@ -239,9 +269,7 @@ class PythonFinder(BaseFinder, BasePath):
         :rtype: List[:class:`~pythonfinder.models.PathEntry`]
         """
 
-        call_method = (
-            "find_all_python_versions" if self.is_dir else "find_python_version"
-        )
+        call_method = "find_all_python_versions" if self.is_dir else "find_python_version"
         sub_finder = operator.methodcaller(
             call_method, major, minor, patch, pre, dev, arch, name
         )
@@ -251,13 +279,12 @@ class PythonFinder(BaseFinder, BasePath):
                 for _, base in self._iter_version_bases()
             ]
         else:
-            pythons = [
-                sub_finder(path) for path in self.paths
-            ]
+            pythons = [sub_finder(path) for path in self.paths]
         pythons = [p for p in pythons if p and p.is_python and p.as_python is not None]
         version_sort = operator.attrgetter("as_python.version_sort")
         paths = [
-            p for p in sorted(list(pythons), key=version_sort, reverse=True)
+            p
+            for p in sorted(list(pythons), key=version_sort, reverse=True)
             if p is not None
         ]
         return paths
@@ -292,7 +319,8 @@ class PythonFinder(BaseFinder, BasePath):
         version_sort = operator.attrgetter("as_python.version_sort")
         unnested = [sub_finder(self.roots[path]) for path in self.roots]
         unnested = [
-            p for p in unnested
+            p
+            for p in unnested
             if p is not None and p.is_python and p.as_python is not None
         ]
         paths = sorted(list(unnested), key=version_sort, reverse=True)
@@ -527,6 +555,7 @@ class PythonVersion(object):
         if not isinstance(path, PathEntry):
             path = PathEntry.create(path, is_root=False, only_python=True, name=name)
         from ..environment import IGNORE_UNSUPPORTED
+
         ignore_unsupported = ignore_unsupported or IGNORE_UNSUPPORTED
         path_name = getattr(path, "name", path.path.name)  # str
         if not path.is_python:
@@ -540,7 +569,10 @@ class PythonVersion(object):
             if instance_dict.get("minor") is None and looks_like_python(path.path.name):
                 instance_dict = cls.parse_executable(path.path.absolute().as_posix())
 
-        if not isinstance(instance_dict.get("version"), Version) and not ignore_unsupported:
+        if (
+            not isinstance(instance_dict.get("version"), Version)
+            and not ignore_unsupported
+        ):
             raise ValueError("Not a valid python path: %s" % path)
         if instance_dict.get("patch") is None:
             instance_dict = cls.parse_executable(path.path.absolute().as_posix())
@@ -596,7 +628,7 @@ class PythonVersion(object):
                     launcher_entry.info, "sys_architecture", SYSTEM_ARCH
                 ),
                 "executable": exe_path,
-                "name": name
+                "name": name,
             }
         )
         py_version = cls.create(**creation_dict)
@@ -616,7 +648,9 @@ class PythonVersion(object):
 
 @attr.s
 class VersionMap(object):
-    versions = attr.ib(factory=defaultdict)  # type: DefaultDict[Tuple[int, Optional[int], Optional[int], bool, bool, bool], List[PathEntry]]
+    versions = attr.ib(
+        factory=defaultdict
+    )  # type: DefaultDict[Tuple[int, Optional[int], Optional[int], bool, bool, bool], List[PathEntry]]
 
     def add_entry(self, entry):
         # type: (...) -> None
@@ -634,8 +668,8 @@ class VersionMap(object):
                 self.versions[version] = entries
             else:
                 current_entries = {
-                    p.path for p in
-                    self.versions[version]  # type: ignore
+                    p.path
+                    for p in self.versions[version]  # type: ignore
                     if version in self.versions
                 }
                 new_entries = {p.path for p in entries}
diff --git a/pipenv/vendor/pythonfinder/models/windows.py b/pipenv/vendor/pythonfinder/models/windows.py
index 5d446339..e96e1081 100644
--- a/pipenv/vendor/pythonfinder/models/windows.py
+++ b/pipenv/vendor/pythonfinder/models/windows.py
@@ -2,22 +2,21 @@
 from __future__ import absolute_import, print_function
 
 import operator
-
 from collections import defaultdict
 
 import attr
 
-from ..environment import MYPY_RUNNING
-from ..exceptions import InvalidPythonVersion
-from ..utils import ensure_path
 from .mixins import BaseFinder
 from .path import PathEntry
 from .python import PythonVersion, VersionMap
-
+from ..environment import MYPY_RUNNING
+from ..exceptions import InvalidPythonVersion
+from ..utils import ensure_path
 
 if MYPY_RUNNING:
     from typing import DefaultDict, Tuple, List, Optional, Union, TypeVar, Type, Any
-    FinderType = TypeVar('FinderType')
+
+    FinderType = TypeVar("FinderType")
 
 
 @attr.s
@@ -41,9 +40,7 @@ class WindowsFinder(BaseFinder):
         version_matcher = operator.methodcaller(
             "matches", major, minor, patch, pre, dev, arch, python_name=name
         )
-        pythons = [
-            py for py in self.version_list if version_matcher(py)
-        ]
+        pythons = [py for py in self.version_list if version_matcher(py)]
         version_sort = operator.attrgetter("version_sort")
         return [c.comes_from for c in sorted(pythons, key=version_sort, reverse=True)]
 
@@ -58,15 +55,20 @@ class WindowsFinder(BaseFinder):
         name=None,  # type: Optional[str]
     ):
         # type: (...) -> Optional[PathEntry]
-        return next(iter(v for v in self.find_all_python_versions(
-            major=major,
-            minor=minor,
-            patch=patch,
-            pre=pre,
-            dev=dev,
-            arch=arch,
-            name=name,
-            )), None
+        return next(
+            iter(
+                v
+                for v in self.find_all_python_versions(
+                    major=major,
+                    minor=minor,
+                    patch=patch,
+                    pre=pre,
+                    dev=dev,
+                    arch=arch,
+                    name=name,
+                )
+            ),
+            None,
         )
 
     @_versions.default
@@ -92,13 +94,14 @@ class WindowsFinder(BaseFinder):
             if py_version is None:
                 continue
             self.version_list.append(py_version)
-            python_path = py_version.comes_from.path if py_version.comes_from else py_version.executable
+            python_path = (
+                py_version.comes_from.path
+                if py_version.comes_from
+                else py_version.executable
+            )
             python_kwargs = {python_path: py_version} if python_path is not None else {}
             base_dir = PathEntry.create(
-                path,
-                is_root=True,
-                only_python=True,
-                pythons=python_kwargs,
+                path, is_root=True, only_python=True, pythons=python_kwargs
             )
             versions[py_version.version_tuple[:5]] = base_dir
             self.paths.append(base_dir)
diff --git a/pipenv/vendor/pythonfinder/pythonfinder.py b/pipenv/vendor/pythonfinder/pythonfinder.py
index 63f63c74..d5f38fb4 100644
--- a/pipenv/vendor/pythonfinder/pythonfinder.py
+++ b/pipenv/vendor/pythonfinder/pythonfinder.py
@@ -5,16 +5,14 @@ import operator
 import os
 
 import six
-
 from click import secho
 from vistir.compat import lru_cache
 
 from . import environment
 from .exceptions import InvalidPythonVersion
-from .models import path
+from .models import path as pyfinder_path
 from .utils import Iterable, filter_pythons, version_re
 
-
 if environment.MYPY_RUNNING:
     from typing import Optional, Dict, Any, Union, List, Iterator
     from .models.path import Path, PathEntry
@@ -34,7 +32,9 @@ class Finder(object):
     *path* and *system*.
     """
 
-    def __init__(self, path=None, system=False, global_search=True, ignore_unsupported=True):
+    def __init__(
+        self, path=None, system=False, global_search=True, ignore_unsupported=True
+    ):
         # type: (Optional[str], bool, bool, bool) -> None
         """Create a new :class:`~pythonfinder.pythonfinder.Finder` instance.
 
@@ -68,9 +68,11 @@ class Finder(object):
 
     def create_system_path(self):
         # type: () -> SystemPath
-        return path.SystemPath.create(
-            path=self.path_prepend, system=self.system, global_search=self.global_search,
-            ignore_unsupported=self.ignore_unsupported
+        return pyfinder_path.SystemPath.create(
+            path=self.path_prepend,
+            system=self.system,
+            global_search=self.global_search,
+            ignore_unsupported=self.ignore_unsupported,
         )
 
     def reload_system_path(self):
@@ -84,7 +86,7 @@ class Finder(object):
         if self._system_path is not None:
             self._system_path.clear_caches()
         self._system_path = None
-        six.moves.reload_module(path)
+        six.moves.reload_module(pyfinder_path)
         self._system_path = self.create_system_path()
 
     def rehash(self):
@@ -136,12 +138,13 @@ class Finder(object):
         """
 
         from .models import PythonVersion
+
         minor = int(minor) if minor is not None else minor
         patch = int(patch) if patch is not None else patch
 
         version_dict = {
             "minor": minor,
-            "patch": patch
+            "patch": patch,
         }  # type: Dict[str, Union[str, int, Any]]
 
         if (
@@ -177,7 +180,9 @@ class Finder(object):
                 if "." in major and all(part.isdigit() for part in major.split(".")[:2]):
                     match = version_re.match(major)
                     version_dict = match.groupdict()
-                    version_dict["is_prerelease"] = bool(version_dict.get("prerel", False))
+                    version_dict["is_prerelease"] = bool(
+                        version_dict.get("prerel", False)
+                    )
                     version_dict["is_devrelease"] = bool(version_dict.get("dev", False))
                 else:
                     version_dict = {
@@ -186,7 +191,7 @@ class Finder(object):
                         "patch": patch,
                         "pre": pre,
                         "dev": dev,
-                        "arch": arch
+                        "arch": arch,
                     }
             if version_dict.get("minor") is not None:
                 minor = int(version_dict["minor"])
@@ -198,10 +203,18 @@ class Finder(object):
             pre = bool(_pre) if _pre is not None else pre
             _dev = version_dict.get("is_devrelease", dev)
             dev = bool(_dev) if _dev is not None else dev
-            arch = version_dict.get("architecture", None) if arch is None else arch  # type: ignore
+            arch = (
+                version_dict.get("architecture", None) if arch is None else arch
+            )  # type: ignore
         if os.name == "nt" and self.windows_finder is not None:
             match = self.windows_finder.find_python_version(
-                major=major, minor=minor, patch=patch, pre=pre, dev=dev, arch=arch, name=name
+                major=major,
+                minor=minor,
+                patch=patch,
+                pre=pre,
+                dev=dev,
+                arch=arch,
+                name=name,
             )
             if match:
                 return match
@@ -218,10 +231,10 @@ class Finder(object):
         python_version_dict = getattr(self.system_path, "python_version_dict")
         if python_version_dict:
             paths = (
-                    path
-                    for version in python_version_dict.values()
-                    for path in version
-                    if path is not None and path.as_python
+                path
+                for version in python_version_dict.values()
+                for path in version
+                if path is not None and path.as_python
             )
             path_list = sorted(paths, key=version_sort, reverse=True)
             return path_list
@@ -229,7 +242,7 @@ class Finder(object):
             major=major, minor=minor, patch=patch, pre=pre, dev=dev, arch=arch, name=name
         )
         if not isinstance(versions, Iterable):
-            versions = [versions,]
+            versions = [versions]
         path_list = sorted(versions, key=version_sort, reverse=True)
         path_map = {}  # type: Dict[str, PathEntry]
         for path in path_list:
diff --git a/pipenv/vendor/pythonfinder/utils.py b/pipenv/vendor/pythonfinder/utils.py
index 24ffdea0..a82654f3 100644
--- a/pipenv/vendor/pythonfinder/utils.py
+++ b/pipenv/vendor/pythonfinder/utils.py
@@ -5,23 +5,26 @@ import io
 import itertools
 import os
 import re
-
 from fnmatch import fnmatch
 
 import attr
 import six
 import vistir
-
 from packaging.version import LegacyVersion, Version
 
 from .environment import MYPY_RUNNING, PYENV_ROOT
 from .exceptions import InvalidPythonVersion
 
-
-six.add_move(six.MovedAttribute("Iterable", "collections", "collections.abc"))  # type: ignore  # noqa
-six.add_move(six.MovedAttribute("Sequence", "collections", "collections.abc"))  # type: ignore  # noqa
-from six.moves import Iterable  # type: ignore  # noqa
-from six.moves import Sequence  # type: ignore  # noqa
+six.add_move(
+    six.MovedAttribute("Iterable", "collections", "collections.abc")
+)  # type: ignore  # noqa
+six.add_move(
+    six.MovedAttribute("Sequence", "collections", "collections.abc")
+)  # type: ignore  # noqa
+# fmt: off
+from six.moves import Iterable  # type: ignore  # noqa  # isort:skip
+from six.moves import Sequence  # type: ignore  # noqa  # isort:skip
+# fmt: on
 
 try:
     from functools import lru_cache
@@ -29,27 +32,42 @@ except ImportError:
     from backports.functools_lru_cache import lru_cache  # type: ignore  # noqa
 
 if MYPY_RUNNING:
-    from typing import (
-        Any, Union, List, Callable, Iterable, Set, Tuple, Dict, Optional, Iterator
-    )
+    from typing import Any, Union, List, Callable, Set, Tuple, Dict, Optional, Iterator
     from attr.validators import _OptionalValidator  # type: ignore
     from .models.path import PathEntry
 
 
-version_re = re.compile(r"(?P<major>\d+)(?:\.(?P<minor>\d+))?(?:\.(?P<patch>(?<=\.)[0-9]+))?\.?"
-                        r"(?:(?P<prerel>[abc]|rc|dev)(?:(?P<prerelversion>\d+(?:\.\d+)*))?)"
-                        r"?(?P<postdev>(\.post(?P<post>\d+))?(\.dev(?P<dev>\d+))?)?")
+version_re = re.compile(
+    r"(?P<major>\d+)(?:\.(?P<minor>\d+))?(?:\.(?P<patch>(?<=\.)[0-9]+))?\.?"
+    r"(?:(?P<prerel>[abc]|rc|dev)(?:(?P<prerelversion>\d+(?:\.\d+)*))?)"
+    r"?(?P<postdev>(\.post(?P<post>\d+))?(\.dev(?P<dev>\d+))?)?"
+)
 
 
 PYTHON_IMPLEMENTATIONS = (
-    "python", "ironpython", "jython", "pypy", "anaconda", "miniconda",
-    "stackless", "activepython", "micropython"
+    "python",
+    "ironpython",
+    "jython",
+    "pypy",
+    "anaconda",
+    "miniconda",
+    "stackless",
+    "activepython",
+    "micropython",
+)
+RE_MATCHER = re.compile(
+    r"(({0})(?:\d?(?:\.\d[cpm]{{0,3}}))?(?:-?[\d\.]+)*[^z])".format(
+        "|".join(PYTHON_IMPLEMENTATIONS)
+    )
 )
-RE_MATCHER = re.compile(r"(({0})(?:\d?(?:\.\d[cpm]{{0,3}}))?(?:-?[\d\.]+)*[^z])".format(
-    "|".join(PYTHON_IMPLEMENTATIONS)
-))
 RULES_BASE = [
-    "*{0}", "*{0}?", "*{0}?.?", "*{0}?.?m", "{0}?-?.?", "{0}?-?.?.?", "{0}?.?-?.?.?"
+    "*{0}",
+    "*{0}?",
+    "*{0}?.?",
+    "*{0}?.?m",
+    "{0}?-?.?",
+    "{0}?-?.?.?",
+    "{0}?.?-?.?.?",
 ]
 RULES = [rule.format(impl) for impl in PYTHON_IMPLEMENTATIONS for rule in RULES_BASE]
 
@@ -61,10 +79,7 @@ KNOWN_EXTS = KNOWN_EXTS | set(
 MATCH_RULES = []
 for rule in RULES:
     MATCH_RULES.extend(
-        [
-            "{0}.{1}".format(rule, ext) if ext else "{0}".format(rule)
-            for ext in KNOWN_EXTS
-        ]
+        ["{0}.{1}".format(rule, ext) if ext else "{0}".format(rule) for ext in KNOWN_EXTS]
     )
 
 
@@ -74,8 +89,14 @@ def get_python_version(path):
     """Get python version string using subprocess from a given path."""
     version_cmd = [path, "-c", "import sys; print(sys.version.split()[0])"]
     try:
-        c = vistir.misc.run(version_cmd, block=True, nospin=True, return_object=True,
-                            combine_stderr=False, write_to_stdout=False)
+        c = vistir.misc.run(
+            version_cmd,
+            block=True,
+            nospin=True,
+            return_object=True,
+            combine_stderr=False,
+            write_to_stdout=False,
+        )
     except OSError:
         raise InvalidPythonVersion("%s is not a valid python path" % path)
     if not c.out:
@@ -87,6 +108,7 @@ def get_python_version(path):
 def parse_python_version(version_str):
     # type: (str) -> Dict[str, Union[str, int, Version]]
     from packaging.version import parse as parse_version
+
     is_debug = False
     if version_str.endswith("-debug"):
         is_debug = True
@@ -127,7 +149,7 @@ def parse_python_version(version_str):
         "is_prerelease": is_prerelease,
         "is_devrelease": is_devrelease,
         "is_debug": is_debug,
-        "version": version
+        "version": version,
     }
 
 
@@ -237,9 +259,11 @@ def _filter_none(k, v):
 # TODO: Reimplement in vistir
 def normalize_path(path):
     # type: (str) -> str
-    return os.path.normpath(os.path.normcase(
-        os.path.abspath(os.path.expandvars(os.path.expanduser(str(path))))
-    ))
+    return os.path.normpath(
+        os.path.normcase(
+            os.path.abspath(os.path.expandvars(os.path.expanduser(str(path))))
+        )
+    )
 
 
 @lru_cache(maxsize=1024)
@@ -290,9 +314,10 @@ def parse_asdf_version_order(filename=".tool-versions"):
     if os.path.exists(version_order_file) and os.path.isfile(version_order_file):
         with io.open(version_order_file, encoding="utf-8") as fh:
             contents = fh.read()
-        python_section = next(iter(
-            line for line in contents.splitlines() if line.startswith("python")
-        ), None)
+        python_section = next(
+            iter(line for line in contents.splitlines() if line.startswith("python")),
+            None,
+        )
         if python_section:
             # python_key, _, versions
             _, _, versions = python_section.partition(" ")
@@ -317,8 +342,10 @@ def expand_paths(path, only_python=True):
     :rtype: Iterator[PathEntry]
     """
 
-    if path is not None and (isinstance(path, Sequence) and
-            not getattr(path.__class__, "__name__", "") == "PathEntry"):
+    if path is not None and (
+        isinstance(path, Sequence)
+        and not getattr(path.__class__, "__name__", "") == "PathEntry"
+    ):
         for p in unnest(path):
             if p is None:
                 continue
diff --git a/pipenv/vendor/pytoml/LICENSE b/pipenv/vendor/pytoml/LICENSE
new file mode 100644
index 00000000..9739fc67
--- /dev/null
+++ b/pipenv/vendor/pytoml/LICENSE
@@ -0,0 +1,16 @@
+No-notice MIT License
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
diff --git a/pipenv/vendor/requirementslib/__init__.py b/pipenv/vendor/requirementslib/__init__.py
index 54e71e8d..c3e237ac 100644
--- a/pipenv/vendor/requirementslib/__init__.py
+++ b/pipenv/vendor/requirementslib/__init__.py
@@ -1,17 +1,21 @@
 # -*- coding=utf-8 -*-
 from __future__ import absolute_import, print_function
-__version__ = '1.4.2'
 
 import logging
 import warnings
+
 from vistir.compat import ResourceWarning
 
+from .models.lockfile import Lockfile
+from .models.pipfile import Pipfile
+from .models.requirements import Requirement
+
+__version__ = "1.4.2"
+
+
 logger = logging.getLogger(__name__)
 logger.addHandler(logging.NullHandler())
 warnings.filterwarnings("ignore", category=ResourceWarning)
 
-from .models.requirements import Requirement
-from .models.lockfile import Lockfile
-from .models.pipfile import Pipfile
 
 __all__ = ["Lockfile", "Pipfile", "Requirement"]
diff --git a/pipenv/vendor/requirementslib/models/dependencies.py b/pipenv/vendor/requirementslib/models/dependencies.py
index f87fd585..44f34edb 100644
--- a/pipenv/vendor/requirementslib/models/dependencies.py
+++ b/pipenv/vendor/requirementslib/models/dependencies.py
@@ -20,6 +20,7 @@ from vistir.contextmanagers import cd, temp_environ
 from vistir.misc import partialclass
 from vistir.path import create_tracked_tempdir
 
+from ..environment import MYPY_RUNNING
 from ..utils import prepare_pip_source_args, _ensure_dir
 from .cache import CACHE_DIR, DependencyCache
 from .utils import (
@@ -29,6 +30,17 @@ from .utils import (
 )
 
 
+if MYPY_RUNNING:
+    from typing import Any, Dict, List, Generator, Optional, Union, Tuple, TypeVar, Text, Set, AnyStr
+    from pip_shims.shims import InstallRequirement, InstallationCandidate, PackageFinder, Command
+    from packaging.requirements import Requirement as PackagingRequirement
+    TRequirement = TypeVar("TRequirement")
+    RequirementType = TypeVar('RequirementType', covariant=True, bound=PackagingRequirement)
+    MarkerType = TypeVar('MarkerType', covariant=True, bound=Marker)
+    STRING_TYPE = Union[str, bytes, Text]
+    S = TypeVar("S", bytes, str, Text)
+
+
 PKGS_DOWNLOAD_DIR = fs_str(os.path.join(CACHE_DIR, "pkgs"))
 WHEEL_DOWNLOAD_DIR = fs_str(os.path.join(CACHE_DIR, "wheels"))
 
@@ -43,6 +55,7 @@ def _get_filtered_versions(ireq, versions, prereleases):
 
 
 def find_all_matches(finder, ireq, pre=False):
+    # type: (PackageFinder, InstallRequirement, bool) -> List[InstallationCandidate]
     """Find all matching dependencies using the supplied finder and the
     given ireq.
 
@@ -65,6 +78,7 @@ def find_all_matches(finder, ireq, pre=False):
 
 
 def get_pip_command():
+    # type: () -> Command
     # Use pip's parser for pip.conf management and defaults.
     # General options (find_links, index_url, extra_index_url, trusted_host,
     # and pre) are defered to pip.
@@ -89,7 +103,7 @@ def get_pip_command():
 
 @attr.s
 class AbstractDependency(object):
-    name = attr.ib()
+    name = attr.ib()  # type: STRING_TYPE
     specifiers = attr.ib()
     markers = attr.ib()
     candidates = attr.ib()
@@ -284,6 +298,7 @@ def get_abstract_dependencies(reqs, sources=None, parent=None):
 
 
 def get_dependencies(ireq, sources=None, parent=None):
+    # type: (Union[InstallRequirement, InstallationCandidate], Optional[List[Dict[S, Union[S, bool]]]], Optional[AbstractDependency]) -> Set[S, ...]
     """Get all dependencies for a given install requirement.
 
     :param ireq: A single InstallRequirement
@@ -556,6 +571,7 @@ def get_pip_options(args=[], sources=None, pip_command=None):
 
 
 def get_finder(sources=None, pip_command=None, pip_options=None):
+    # type: (List[Dict[S, Union[S, bool]]], Optional[Command], Any) -> PackageFinder
     """Get a package finder for looking up candidates to install
 
     :param sources: A list of pipfile-formatted sources, defaults to None
diff --git a/pipenv/vendor/requirementslib/utils.py b/pipenv/vendor/requirementslib/utils.py
index 0aba3a43..515f9a88 100644
--- a/pipenv/vendor/requirementslib/utils.py
+++ b/pipenv/vendor/requirementslib/utils.py
@@ -132,7 +132,7 @@ def strip_ssh_from_git_uri(uri):
 
 def add_ssh_scheme_to_git_uri(uri):
     # type: (S) -> S
-    """Cleans VCS uris from pip format"""
+    """Cleans VCS uris from pipenv.patched.notpip format"""
     if isinstance(uri, six.string_types):
         # Add scheme for parsing purposes, this is also what pip does
         if uri.startswith("git+") and "://" not in uri:
diff --git a/pipenv/vendor/vistir/__init__.py b/pipenv/vendor/vistir/__init__.py
index ecc67c1a..5be3b747 100644
--- a/pipenv/vendor/vistir/__init__.py
+++ b/pipenv/vendor/vistir/__init__.py
@@ -3,40 +3,39 @@ from __future__ import absolute_import, unicode_literals
 
 from .compat import (
     NamedTemporaryFile,
+    StringIO,
     TemporaryDirectory,
     partialmethod,
     to_native_string,
-    StringIO,
 )
 from .contextmanagers import (
     atomic_open_for_write,
     cd,
     open_file,
+    replaced_stream,
+    spinner,
     temp_environ,
     temp_path,
-    spinner,
-    replaced_stream
 )
-from .cursor import show_cursor, hide_cursor
+from .cursor import hide_cursor, show_cursor
 from .misc import (
+    StreamWrapper,
+    chunked,
+    decode_for_output,
+    divide,
+    get_wrapped_stream,
     load_path,
     partialclass,
     run,
     shell_escape,
-    decode_for_output,
-    to_text,
-    to_bytes,
     take,
-    chunked,
-    divide,
-    get_wrapped_stream,
-    StreamWrapper
+    to_bytes,
+    to_text,
 )
-from .path import mkdir_p, rmtree, create_tracked_tempdir, create_tracked_tempfile
+from .path import create_tracked_tempdir, create_tracked_tempfile, mkdir_p, rmtree
 from .spin import create_spinner
 
-
-__version__ = '0.3.1'
+__version__ = "0.3.1"
 
 
 __all__ = [
@@ -70,5 +69,5 @@ __all__ = [
     "StreamWrapper",
     "replaced_stream",
     "show_cursor",
-    "hide_cursor"
+    "hide_cursor",
 ]
diff --git a/pipenv/vendor/vistir/backports/__init__.py b/pipenv/vendor/vistir/backports/__init__.py
index 0bdac1ea..03859e4f 100644
--- a/pipenv/vendor/vistir/backports/__init__.py
+++ b/pipenv/vendor/vistir/backports/__init__.py
@@ -4,8 +4,4 @@ from __future__ import absolute_import, unicode_literals
 from .functools import partialmethod
 from .tempfile import NamedTemporaryFile
 
-
-__all__ = [
-    "NamedTemporaryFile",
-    "partialmethod"
-]
+__all__ = ["NamedTemporaryFile", "partialmethod"]
diff --git a/pipenv/vendor/vistir/backports/functools.py b/pipenv/vendor/vistir/backports/functools.py
index 8060d183..5d98f41a 100644
--- a/pipenv/vendor/vistir/backports/functools.py
+++ b/pipenv/vendor/vistir/backports/functools.py
@@ -3,8 +3,7 @@ from __future__ import absolute_import, unicode_literals
 
 from functools import partial
 
-
-__all__ = ["partialmethod",]
+__all__ = ["partialmethod"]
 
 
 class partialmethod(object):
@@ -16,8 +15,7 @@ class partialmethod(object):
 
     def __init__(self, func, *args, **keywords):
         if not callable(func) and not hasattr(func, "__get__"):
-            raise TypeError("{!r} is not callable or a descriptor"
-                                .format(func))
+            raise TypeError("{!r} is not callable or a descriptor".format(func))
 
         # func could be a descriptor like classmethod which isn't callable,
         # so we can't inherit from partial (it verifies func is callable)
@@ -36,26 +34,28 @@ class partialmethod(object):
 
     def __repr__(self):
         args = ", ".join(map(repr, self.args))
-        keywords = ", ".join("{}={!r}".format(k, v)
-                                for k, v in self.keywords.items())
+        keywords = ", ".join("{}={!r}".format(k, v) for k, v in self.keywords.items())
         format_string = "{module}.{cls}({func}, {args}, {keywords})"
-        return format_string.format(module=self.__class__.__module__,
-                                    cls=self.__class__.__qualname__,
-                                    func=self.func,
-                                    args=args,
-                                    keywords=keywords)
+        return format_string.format(
+            module=self.__class__.__module__,
+            cls=self.__class__.__qualname__,
+            func=self.func,
+            args=args,
+            keywords=keywords,
+        )
 
     def _make_unbound_method(self):
         def _method(*args, **keywords):
             call_keywords = self.keywords.copy()
             call_keywords.update(keywords)
             if len(args) > 1:
-                cls_or_self, rest = args[0], tuple(args[1:],)
+                cls_or_self, rest = args[0], tuple(args[1:])
             else:
                 cls_or_self = args[0]
                 rest = tuple()
             call_args = (cls_or_self,) + self.args + tuple(rest)
             return self.func(*call_args, **call_keywords)
+
         _method.__isabstractmethod__ = self.__isabstractmethod__
         _method._partialmethod = self
         return _method
diff --git a/pipenv/vendor/vistir/backports/tempfile.py b/pipenv/vendor/vistir/backports/tempfile.py
index fb044acf..ce66138b 100644
--- a/pipenv/vendor/vistir/backports/tempfile.py
+++ b/pipenv/vendor/vistir/backports/tempfile.py
@@ -5,7 +5,6 @@ import functools
 import io
 import os
 import sys
-
 from tempfile import _bin_openflags, _mkstemp_inner, gettempdir
 
 import six
@@ -175,7 +174,7 @@ def NamedTemporaryFile(
     prefix=None,
     dir=None,
     delete=True,
-    wrapper_class_override=None
+    wrapper_class_override=None,
 ):
     """Create and return a temporary file.
     Arguments:
@@ -203,13 +202,11 @@ def NamedTemporaryFile(
     else:
         (fd, name) = _mkstemp_inner(dir, prefix, suffix, flags, output_type)
     try:
-        file = io.open(
-            fd, mode, buffering=buffering, newline=newline, encoding=encoding
-        )
+        file = io.open(fd, mode, buffering=buffering, newline=newline, encoding=encoding)
         if wrapper_class_override is not None:
-            return type(
-                str("_TempFileWrapper"), (wrapper_class_override, object), {}
-            )(file, name, delete)
+            return type(str("_TempFileWrapper"), (wrapper_class_override, object), {})(
+                file, name, delete
+            )
         else:
             return _TemporaryFileWrapper(file, name, delete)
 
diff --git a/pipenv/vendor/vistir/cmdparse.py b/pipenv/vendor/vistir/cmdparse.py
index 5a307f24..664ae7df 100644
--- a/pipenv/vendor/vistir/cmdparse.py
+++ b/pipenv/vendor/vistir/cmdparse.py
@@ -7,7 +7,6 @@ import shlex
 
 import six
 
-
 __all__ = ["ScriptEmptyError", "Script"]
 
 
@@ -78,7 +77,9 @@ class Script(object):
 
         See also: https://docs.python.org/3/library/subprocess.html#converting-argument-sequence
         """
-        return " ".join(itertools.chain(
-            [_quote_if_contains(self.command, r'[\s^()]')],
-            (_quote_if_contains(arg, r'[\s^]') for arg in self.args),
-        ))
+        return " ".join(
+            itertools.chain(
+                [_quote_if_contains(self.command, r"[\s^()]")],
+                (_quote_if_contains(arg, r"[\s^]") for arg in self.args),
+            )
+        )
diff --git a/pipenv/vendor/vistir/compat.py b/pipenv/vendor/vistir/compat.py
index 260959e1..e8688d89 100644
--- a/pipenv/vendor/vistir/compat.py
+++ b/pipenv/vendor/vistir/compat.py
@@ -6,11 +6,11 @@ import errno
 import os
 import sys
 import warnings
-
 from tempfile import mkdtemp
 
 import six
 
+from .backports.tempfile import NamedTemporaryFile as _NamedTemporaryFile
 
 __all__ = [
     "Path",
@@ -35,19 +35,20 @@ __all__ = [
     "fs_encode",
     "fs_decode",
     "_fs_encode_errors",
-    "_fs_decode_errors"
+    "_fs_decode_errors",
 ]
 
 if sys.version_info >= (3, 5):
     from pathlib import Path
     from functools import lru_cache
 else:
-    from pathlib2 import Path
+    from pipenv.vendor.pathlib2 import Path
     from pipenv.vendor.backports.functools_lru_cache import lru_cache
 
-from .backports.tempfile import NamedTemporaryFile as _NamedTemporaryFile
+
 if sys.version_info < (3, 3):
     from pipenv.vendor.backports.shutil_get_terminal_size import get_terminal_size
+
     NamedTemporaryFile = _NamedTemporaryFile
 else:
     from tempfile import NamedTemporaryFile
@@ -89,6 +90,7 @@ if six.PY2:
 
     class IsADirectoryError(OSError):
         """The command does not work on directories"""
+
         pass
 
     class FileExistsError(OSError):
@@ -96,19 +98,35 @@ if six.PY2:
             self.errno = errno.EEXIST
             super(FileExistsError, self).__init__(*args, **kwargs)
 
+
 else:
     from builtins import (
-        ResourceWarning, FileNotFoundError, PermissionError, IsADirectoryError,
-        FileExistsError
+        ResourceWarning,
+        FileNotFoundError,
+        PermissionError,
+        IsADirectoryError,
+        FileExistsError,
     )
     from io import StringIO
 
-six.add_move(six.MovedAttribute("Iterable", "collections", "collections.abc"))  # type: ignore
-six.add_move(six.MovedAttribute("Mapping", "collections", "collections.abc"))  # type: ignore
-six.add_move(six.MovedAttribute("Sequence", "collections", "collections.abc"))  # type: ignore
+six.add_move(
+    six.MovedAttribute("Iterable", "collections", "collections.abc")
+)  # type: ignore
+six.add_move(
+    six.MovedAttribute("Mapping", "collections", "collections.abc")
+)  # type: ignore
+six.add_move(
+    six.MovedAttribute("Sequence", "collections", "collections.abc")
+)  # type: ignore
 six.add_move(six.MovedAttribute("Set", "collections", "collections.abc"))  # type: ignore
-six.add_move(six.MovedAttribute("ItemsView", "collections", "collections.abc"))  # type: ignore
-from six.moves import Iterable, Mapping, Sequence, Set, ItemsView  # type: ignore  # noqa
+six.add_move(
+    six.MovedAttribute("ItemsView", "collections", "collections.abc")
+)  # type: ignore
+
+# fmt: off
+from six.moves import ItemsView, Iterable, Mapping, Sequence, Set  # type: ignore  # noqa  # isort:skip
+# fmt: on
+
 
 if not sys.warnoptions:
     warnings.simplefilter("default", ResourceWarning)
@@ -282,6 +300,7 @@ else:
 
 def to_native_string(string):
     from .misc import to_text, to_bytes
+
     if six.PY2:
         return to_bytes(string)
     return to_text(string)
diff --git a/pipenv/vendor/vistir/contextmanagers.py b/pipenv/vendor/vistir/contextmanagers.py
index b2627d2d..d9223b66 100644
--- a/pipenv/vendor/vistir/contextmanagers.py
+++ b/pipenv/vendor/vistir/contextmanagers.py
@@ -1,11 +1,10 @@
 # -*- coding=utf-8 -*-
-from __future__ import absolute_import, unicode_literals, print_function
+from __future__ import absolute_import, print_function, unicode_literals
 
 import io
 import os
 import stat
 import sys
-
 from contextlib import contextmanager
 
 import six
@@ -13,10 +12,15 @@ import six
 from .compat import NamedTemporaryFile, Path
 from .path import is_file_url, is_valid_url, path_to_url, url_to_path
 
-
 __all__ = [
-    "temp_environ", "temp_path", "cd", "atomic_open_for_write", "open_file", "spinner",
-    "dummy_spinner", "replaced_stream"
+    "temp_environ",
+    "temp_path",
+    "cd",
+    "atomic_open_for_write",
+    "open_file",
+    "spinner",
+    "dummy_spinner",
+    "replaced_stream",
 ]
 
 
@@ -104,7 +108,13 @@ def dummy_spinner(spin_type, text, **kwargs):
 
 
 @contextmanager
-def spinner(spinner_name=None, start_text=None, handler_map=None, nospin=False, write_to_stdout=True):
+def spinner(
+    spinner_name=None,
+    start_text=None,
+    handler_map=None,
+    nospin=False,
+    write_to_stdout=True,
+):
     """Get a spinner object or a dummy spinner to wrap a context.
 
     :param str spinner_name: A spinner type e.g. "dots" or "bouncingBar" (default: {"bouncingBar"})
@@ -120,6 +130,7 @@ def spinner(spinner_name=None, start_text=None, handler_map=None, nospin=False,
     """
 
     from .spin import create_spinner
+
     has_yaspin = None
     try:
         import yaspin
@@ -146,7 +157,7 @@ def spinner(spinner_name=None, start_text=None, handler_map=None, nospin=False,
         handler_map=handler_map,
         nospin=nospin,
         use_yaspin=use_yaspin,
-        write_to_stdout=write_to_stdout
+        write_to_stdout=write_to_stdout,
     ) as _spinner:
         yield _spinner
 
@@ -267,8 +278,8 @@ def open_file(link, session=None, stream=True):
         if os.path.isdir(local_path):
             raise ValueError("Cannot open directory for read: {}".format(link))
         else:
-                with io.open(local_path, "rb") as local_file:
-                    yield local_file
+            with io.open(local_path, "rb") as local_file:
+                yield local_file
     else:
         # Remote URL
         headers = {"Accept-Encoding": "identity"}
diff --git a/pipenv/vendor/vistir/cursor.py b/pipenv/vendor/vistir/cursor.py
index ce998f51..22d643e1 100644
--- a/pipenv/vendor/vistir/cursor.py
+++ b/pipenv/vendor/vistir/cursor.py
@@ -5,13 +5,11 @@ import ctypes
 import os
 import sys
 
-
 __all__ = ["hide_cursor", "show_cursor"]
 
 
 class CONSOLE_CURSOR_INFO(ctypes.Structure):
-    _fields_ = [('dwSize', ctypes.c_int),
-                ('bVisible', ctypes.c_int)]
+    _fields_ = [("dwSize", ctypes.c_int), ("bVisible", ctypes.c_int)]
 
 
 WIN_STDERR_HANDLE_ID = ctypes.c_ulong(-12)
@@ -29,6 +27,7 @@ def get_stream_handle(stream=sys.stdout):
     handle = stream
     if os.name == "nt":
         from ctypes import windll
+
         handle_id = WIN_STDOUT_HANDLE_ID
         handle = windll.kernel32.GetStdHandle(handle_id)
     return handle
@@ -46,6 +45,7 @@ def hide_cursor(stream=sys.stdout):
     handle = get_stream_handle(stream=stream)
     if os.name == "nt":
         from ctypes import windll
+
         cursor_info = CONSOLE_CURSOR_INFO()
         windll.kernel32.GetConsoleCursorInfo(handle, ctypes.byref(cursor_info))
         cursor_info.visible = False
@@ -67,6 +67,7 @@ def show_cursor(stream=sys.stdout):
     handle = get_stream_handle(stream=stream)
     if os.name == "nt":
         from ctypes import windll
+
         cursor_info = CONSOLE_CURSOR_INFO()
         windll.kernel32.GetConsoleCursorInfo(handle, ctypes.byref(cursor_info))
         cursor_info.visible = True
diff --git a/pipenv/vendor/vistir/misc.py b/pipenv/vendor/vistir/misc.py
index cf301233..42067b2d 100644
--- a/pipenv/vendor/vistir/misc.py
+++ b/pipenv/vendor/vistir/misc.py
@@ -1,14 +1,13 @@
 # -*- coding=utf-8 -*-
-from __future__ import absolute_import, unicode_literals, print_function
+from __future__ import absolute_import, print_function, unicode_literals
 
 import io
 import json
-import logging
 import locale
+import logging
 import os
 import subprocess
 import sys
-
 from collections import OrderedDict
 from functools import partial
 from itertools import islice, tee
@@ -16,10 +15,11 @@ from itertools import islice, tee
 import six
 
 from .cmdparse import Script
-from .compat import Path, fs_str, partialmethod, to_native_string, Iterable, StringIO
+from .compat import Iterable, Path, StringIO, fs_str, partialmethod, to_native_string
 from .contextmanagers import spinner as spinner
 
 if os.name != "nt":
+
     class WindowsError(OSError):
         pass
 
@@ -144,6 +144,55 @@ def _spawn_subprocess(script, env=None, block=True, cwd=None, combine_stderr=Tru
     return subprocess.Popen(script.cmdify(), **options)
 
 
+def _read_streams(stream_dict):
+    results = {}
+    for outstream in stream_dict.keys():
+        stream = stream_dict[outstream]
+        if not stream:
+            results[outstream] = None
+            continue
+        line = to_text(stream.readline())
+        if not line:
+            results[outstream] = None
+            continue
+        line = to_text("{0}".format(line.rstrip()))
+        results[outstream] = line
+    return results
+
+
+def get_stream_results(cmd_instance, verbose, maxlen, spinner=None, stdout_allowed=False):
+    stream_results = {"stdout": [], "stderr": []}
+    streams = {"stderr": cmd_instance.stderr, "stdout": cmd_instance.stdout}
+    while True:
+        stream_contents = _read_streams(streams)
+        stdout_line = stream_contents["stdout"]
+        stderr_line = stream_contents["stderr"]
+        if not (stdout_line or stderr_line):
+            break
+        for stream_name in stream_contents.keys():
+            if stream_contents[stream_name] and stream_name in stream_results:
+                line = stream_contents[stream_name]
+                stream_results[stream_name].append(line)
+                display_line = fs_str("{0}".format(line))
+                if len(display_line) > maxlen:
+                    display_line = "{0}...".format(display_line[:maxlen])
+                if verbose:
+                    use_stderr = not stdout_allowed or stream_name != "stdout"
+                    if spinner:
+                        target = spinner.stderr if use_stderr else spinner.stdout
+                        spinner.hide_and_write(display_line, target=target)
+                    else:
+                        target = sys.stderr if use_stderr else sys.stdout
+                        target.write(display_line)
+                        target.flush()
+                if spinner:
+                    spinner.text = to_native_string(
+                        "{0} {1}".format(spinner.text, display_line)
+                    )
+                    continue
+    return stream_results
+
+
 def _create_subprocess(
     cmd,
     env=None,
@@ -155,74 +204,35 @@ def _create_subprocess(
     combine_stderr=False,
     display_limit=200,
     start_text="",
-    write_to_stdout=True
+    write_to_stdout=True,
 ):
     if not env:
         env = os.environ.copy()
     try:
-        c = _spawn_subprocess(cmd, env=env, block=block, cwd=cwd,
-                              combine_stderr=combine_stderr)
-    except Exception as exc:
+        c = _spawn_subprocess(
+            cmd, env=env, block=block, cwd=cwd, combine_stderr=combine_stderr
+        )
+    except Exception:
         import traceback
+
         formatted_tb = "".join(traceback.format_exception(*sys.exc_info()))
         sys.stderr.write("Error while executing command %s:" % " ".join(cmd._parts))
         sys.stderr.write(formatted_tb)
         raise
     if not block:
         c.stdin.close()
-        output = []
-        err = []
-        spinner_orig_text = None
-        if spinner:
-            spinner_orig_text = getattr(spinner, "text", None)
-        if spinner_orig_text is None:
-            spinner_orig_text = start_text if start_text is not None else ""
-        streams = {
-            "stdout": c.stdout,
-            "stderr": c.stderr
-        }
-        while True:
-            stdout_line = None
-            stderr_line = None
-            for outstream in streams.keys():
-                stream = streams[outstream]
-                if not stream:
-                    continue
-                line = to_text(stream.readline())
-                if not line:
-                    continue
-                line = to_text("{0}".format(line.rstrip()))
-                if outstream == "stderr":
-                    stderr_line = line
-                else:
-                    stdout_line = line
-            if not (stdout_line or stderr_line):
-                break
-            if stderr_line is not None:
-                err.append(stderr_line)
-                err_line = fs_str("{0}".format(stderr_line))
-                if verbose and err_line is not None:
-                    if spinner:
-                        spinner.hide_and_write(err_line, target=spinner.stderr)
-                    else:
-                        sys.stderr.write(err_line)
-                        sys.stderr.flush()
-            if stdout_line is not None:
-                output.append(stdout_line)
-                display_line = fs_str("{0}".format(stdout_line))
-                if len(stdout_line) > display_limit:
-                    display_line = "{0}...".format(stdout_line[:display_limit])
-                if verbose and display_line is not None:
-                    if spinner:
-                        target = spinner.stdout if write_to_stdout else spinner.stderr
-                        spinner.hide_and_write(display_line, target=target)
-                    else:
-                        target = sys.stdout if write_to_stdout else sys.stderr
-                        target.write(display_line)
-                        target.flush()
-                if spinner:
-                    spinner.text = to_native_string("{0} {1}".format(spinner_orig_text, display_line))
-                continue
+        spinner_orig_text = ""
+        if spinner and getattr(spinner, "text", None) is not None:
+            spinner_orig_text = spinner.text
+        if not spinner_orig_text and start_text is not None:
+            spinner_orig_text = start_text
+        stream_results = get_stream_results(
+            c,
+            verbose=verbose,
+            maxlen=display_limit,
+            spinner=spinner,
+            stdout_allowed=write_to_stdout,
+        )
         try:
             c.wait()
         finally:
@@ -237,6 +247,8 @@ def _create_subprocess(
                 spinner.ok(to_native_string("✔ Complete"))
             else:
                 spinner.ok(to_native_string("Complete"))
+        output = stream_results["stdout"]
+        err = stream_results["stderr"]
         c.out = "\n".join(output) if output else ""
         c.err = "\n".join(err) if err else ""
     else:
@@ -261,7 +273,7 @@ def run(
     spinner_name=None,
     combine_stderr=True,
     display_limit=200,
-    write_to_stdout=True
+    write_to_stdout=True,
 ):
     """Use `subprocess.Popen` to get the output of a command and decode it.
 
@@ -303,8 +315,12 @@ def run(
     if block or not return_object:
         combine_stderr = False
     start_text = ""
-    with spinner(spinner_name=spinner_name, start_text=start_text, nospin=nospin,
-                 write_to_stdout=write_to_stdout) as sp:
+    with spinner(
+        spinner_name=spinner_name,
+        start_text=start_text,
+        nospin=nospin,
+        write_to_stdout=write_to_stdout,
+    ) as sp:
         return _create_subprocess(
             cmd,
             env=_env,
@@ -315,7 +331,7 @@ def run(
             spinner=sp,
             combine_stderr=combine_stderr,
             start_text=start_text,
-            write_to_stdout=True
+            write_to_stdout=True,
         )
 
 
@@ -331,8 +347,9 @@ def load_path(python):
     """
 
     python = Path(python).as_posix()
-    out, err = run([python, "-c", "import json, sys; print(json.dumps(sys.path))"],
-                   nospin=True)
+    out, err = run(
+        [python, "-c", "import json, sys; print(json.dumps(sys.path))"], nospin=True
+    )
     if out:
         return json.loads(out)
     else:
@@ -445,7 +462,7 @@ def to_text(string, encoding="utf-8", errors=None):
                 string = six.text_type(bytes(string), encoding, errors)
         else:
             string = string.decode(encoding, errors)
-    except UnicodeDecodeError as e:
+    except UnicodeDecodeError:
         string = " ".join(to_text(arg, encoding, errors) for arg in string)
     return string
 
@@ -528,8 +545,8 @@ def get_output_encoding(source_encoding):
     """
 
     if source_encoding is not None:
-        if get_canonical_encoding_name(source_encoding) == 'ascii':
-            return 'utf-8'
+        if get_canonical_encoding_name(source_encoding) == "ascii":
+            return "utf-8"
         return get_canonical_encoding_name(source_encoding)
     return get_canonical_encoding_name(PREFERRED_ENCODING)
 
@@ -542,7 +559,7 @@ def _encode(output, encoding=None, errors=None, translation_map=None):
     except (UnicodeDecodeError, UnicodeEncodeError):
         if translation_map is not None:
             if six.PY2:
-                output = unicode.translate(
+                output = unicode.translate(  # noqa: F821
                     to_text(output, encoding=encoding, errors=errors), translation_map
                 )
             else:
@@ -573,8 +590,9 @@ def decode_for_output(output, target_stream=None, translation_map=None):
     try:
         output = _encode(output, encoding=encoding, translation_map=translation_map)
     except (UnicodeDecodeError, UnicodeEncodeError):
-        output = _encode(output, encoding=encoding, errors="replace",
-                         translation_map=translation_map)
+        output = _encode(
+            output, encoding=encoding, errors="replace", translation_map=translation_map
+        )
     return to_text(output, encoding=encoding, errors="replace")
 
 
@@ -589,6 +607,7 @@ def get_canonical_encoding_name(name):
     """
 
     import codecs
+
     try:
         codec = codecs.lookup(name)
     except LookupError:
@@ -629,8 +648,9 @@ class StreamWrapper(io.TextIOWrapper):
     # borrowed from click's implementation of stream wrappers, see
     # https://github.com/pallets/click/blob/6cafd32/click/_compat.py#L64
     if six.PY2:
+
         def write(self, x):
-            if isinstance(x, (str, buffer, bytearray)):
+            if isinstance(x, (str, buffer, bytearray)):  # noqa: F821
                 try:
                     self.flush()
                 except Exception:
diff --git a/pipenv/vendor/vistir/path.py b/pipenv/vendor/vistir/path.py
index d3c8befe..d551aac7 100644
--- a/pipenv/vendor/vistir/path.py
+++ b/pipenv/vendor/vistir/path.py
@@ -1,5 +1,5 @@
 # -*- coding=utf-8 -*-
-from __future__ import absolute_import, unicode_literals, print_function
+from __future__ import absolute_import, print_function, unicode_literals
 
 import atexit
 import errno
@@ -11,23 +11,21 @@ import stat
 import warnings
 
 import six
-
 from six.moves import urllib_parse
 from six.moves.urllib import request as urllib_request
 
 from .backports.tempfile import _TemporaryFileWrapper
 from .compat import (
-    _NamedTemporaryFile,
     Path,
     ResourceWarning,
     TemporaryDirectory,
     _fs_encoding,
+    _NamedTemporaryFile,
     finalize,
     fs_decode,
-    fs_encode
+    fs_encode,
 )
 
-
 __all__ = [
     "check_for_unc_path",
     "get_converted_relative_path",
@@ -51,7 +49,11 @@ __all__ = [
 
 
 if os.name == "nt":
-    warnings.filterwarnings("ignore", category=DeprecationWarning, message="The Windows bytes API has been deprecated.*")
+    warnings.filterwarnings(
+        "ignore",
+        category=DeprecationWarning,
+        message="The Windows bytes API has been deprecated.*",
+    )
 
 
 def unicode_path(path):
@@ -93,9 +95,11 @@ def normalize_path(path):
     :rtype: str
     """
 
-    return os.path.normpath(os.path.normcase(
-        os.path.abspath(os.path.expandvars(os.path.expanduser(str(path))))
-    ))
+    return os.path.normpath(
+        os.path.normcase(
+            os.path.abspath(os.path.expandvars(os.path.expanduser(str(path))))
+        )
+    )
 
 
 def is_in_path(path, parent):
@@ -233,7 +237,7 @@ def mkdir_p(newdir, mode=0o777):
             target = os.path.join(head, tail)
             if os.path.exists(target) and os.path.isfile(target):
                 raise OSError(
-                   "A file with the same name as the desired dir, '{0}', already exists.".format(
+                    "A file with the same name as the desired dir, '{0}', already exists.".format(
                         fs_decode(newdir)
                     )
                 )
@@ -307,7 +311,7 @@ def set_write_bit(fn):
         except AttributeError:
             pass
     for root, dirs, files in os.walk(fn, topdown=False):
-        for dir_ in [os.path.join(root,d) for d in dirs]:
+        for dir_ in [os.path.join(root, d) for d in dirs]:
             set_write_bit(dir_)
         for file_ in [os.path.join(root, f) for f in files]:
             set_write_bit(file_)
@@ -332,9 +336,7 @@ def rmtree(directory, ignore_errors=False, onerror=None):
     if onerror is None:
         onerror = handle_remove_readonly
     try:
-        shutil.rmtree(
-            directory, ignore_errors=ignore_errors, onerror=onerror
-        )
+        shutil.rmtree(directory, ignore_errors=ignore_errors, onerror=onerror)
     except (IOError, OSError, FileNotFoundError) as exc:
         # Ignore removal failures where the file doesn't exist
         if exc.errno != errno.ENOENT:
@@ -355,14 +357,10 @@ def handle_remove_readonly(func, path, exc):
     :func:`set_write_bit` on the target path and try again.
     """
     # Check for read-only attribute
-    from .compat import (
-        ResourceWarning, FileNotFoundError, PermissionError
-    )
+    from .compat import ResourceWarning, FileNotFoundError, PermissionError
 
     PERM_ERRORS = (errno.EACCES, errno.EPERM, errno.ENOENT)
-    default_warning_message = (
-        "Unable to remove file due to permissions restriction: {!r}"
-    )
+    default_warning_message = "Unable to remove file due to permissions restriction: {!r}"
     # split the initial exception out into its type, exception, and traceback
     exc_type, exc_exception, exc_tb = exc
     if is_readonly_path(path):
@@ -488,8 +486,8 @@ def get_converted_relative_path(path, relative_to=None):
         raise ValueError("The path argument does not currently accept UNC paths")
 
     relpath_s = to_text(posixpath.normpath(path.as_posix()))
-    if not (relpath_s == u"." or relpath_s.startswith(u"./")):
-        relpath_s = posixpath.join(u".", relpath_s)
+    if not (relpath_s == "." or relpath_s.startswith("./")):
+        relpath_s = posixpath.join(".", relpath_s)
     return relpath_s
 
 
diff --git a/pipenv/vendor/vistir/spin.py b/pipenv/vendor/vistir/spin.py
index 81ae3014..40dfff96 100644
--- a/pipenv/vendor/vistir/spin.py
+++ b/pipenv/vendor/vistir/spin.py
@@ -7,15 +7,15 @@ import signal
 import sys
 import threading
 import time
+from io import StringIO
 
 import colorama
 import six
 
 from .compat import to_native_string
 from .cursor import hide_cursor, show_cursor
-from .termcolors import COLOR_MAP, COLORS, colored, DISABLE_COLORS
 from .misc import decode_for_output
-from io import StringIO
+from .termcolors import COLOR_MAP, COLORS, DISABLE_COLORS, colored
 
 try:
     import yaspin
@@ -26,10 +26,12 @@ except ImportError:
 else:
     import yaspin.spinners
     import yaspin.core
+
     Spinners = yaspin.spinners.Spinners
     SpinBase = yaspin.core.Yaspin
 
 if os.name == "nt":
+
     def handler(signum, frame, spinner):
         """Signal handler, used to gracefully shut down the ``spinner`` instance
         when specified signal is received by the process running the ``spinner``.
@@ -41,7 +43,9 @@ if os.name == "nt":
         spinner.stop()
         sys.exit(0)
 
+
 else:
+
     def handler(signum, frame, spinner):
         """Signal handler, used to gracefully shut down the ``spinner`` instance
         when specified signal is received by the process running the ``spinner``.
@@ -53,12 +57,10 @@ else:
         spinner.stop()
         sys.exit(0)
 
+
 CLEAR_LINE = chr(27) + "[K"
 
-TRANSLATION_MAP = {
-    10004: u"OK",
-    10008: u"x",
-}
+TRANSLATION_MAP = {10004: u"OK", 10008: u"x"}
 
 
 decode_output = functools.partial(decode_for_output, translation_map=TRANSLATION_MAP)
@@ -84,6 +86,7 @@ class DummySpinner(object):
     def __exit__(self, exc_type, exc_val, tb):
         if exc_type:
             import traceback
+
             formatted_tb = traceback.format_exception(exc_type, exc_val, tb)
             self.write_err("".join(formatted_tb))
         self._close_output_buffer()
@@ -197,10 +200,7 @@ class VistirSpinner(SpinBase):
         colorama.init()
         sigmap = {}
         if handler:
-            sigmap.update({
-                signal.SIGINT: handler,
-                signal.SIGTERM: handler
-            })
+            sigmap.update({signal.SIGINT: handler, signal.SIGTERM: handler})
         handler_map = kwargs.pop("handler_map", {})
         if os.name == "nt":
             sigmap[signal.SIGBREAK] = handler
@@ -332,10 +332,7 @@ class VistirSpinner(SpinBase):
 
     def _compose_color_func(self):
         fn = functools.partial(
-            colored,
-            color=self._color,
-            on_color=self._on_color,
-            attrs=list(self._attrs),
+            colored, color=self._color, on_color=self._on_color, attrs=list(self._attrs)
         )
         return fn
 
diff --git a/pipenv/vendor/vistir/termcolors.py b/pipenv/vendor/vistir/termcolors.py
index d72e8ebe..6aecec88 100644
--- a/pipenv/vendor/vistir/termcolors.py
+++ b/pipenv/vendor/vistir/termcolors.py
@@ -1,62 +1,55 @@
 # -*- coding=utf-8 -*-
 from __future__ import absolute_import, print_function, unicode_literals
-import colorama
+
 import os
-from .compat import to_native_string
 
+import colorama
+
+from .compat import to_native_string
 
-DISABLE_COLORS = os.getenv("CI", False) or os.getenv("ANSI_COLORS_DISABLED",
-    os.getenv("VISTIR_DISABLE_COLORS", False)
+DISABLE_COLORS = os.getenv("CI", False) or os.getenv(
+    "ANSI_COLORS_DISABLED", os.getenv("VISTIR_DISABLE_COLORS", False)
 )
 
 
 ATTRIBUTES = dict(
-        list(zip([
-            'bold',
-            'dark',
-            '',
-            'underline',
-            'blink',
-            '',
-            'reverse',
-            'concealed'
-            ],
-            list(range(1, 9))
-            ))
+    list(
+        zip(
+            ["bold", "dark", "", "underline", "blink", "", "reverse", "concealed"],
+            list(range(1, 9)),
         )
-del ATTRIBUTES['']
+    )
+)
+del ATTRIBUTES[""]
 
 
 HIGHLIGHTS = dict(
-        list(zip([
-            'on_grey',
-            'on_red',
-            'on_green',
-            'on_yellow',
-            'on_blue',
-            'on_magenta',
-            'on_cyan',
-            'on_white'
+    list(
+        zip(
+            [
+                "on_grey",
+                "on_red",
+                "on_green",
+                "on_yellow",
+                "on_blue",
+                "on_magenta",
+                "on_cyan",
+                "on_white",
             ],
-            list(range(40, 48))
-            ))
+            list(range(40, 48)),
         )
+    )
+)
 
 
 COLORS = dict(
-        list(zip([
-            'grey',
-            'red',
-            'green',
-            'yellow',
-            'blue',
-            'magenta',
-            'cyan',
-            'white',
-            ],
-            list(range(30, 38))
-            ))
+    list(
+        zip(
+            ["grey", "red", "green", "yellow", "blue", "magenta", "cyan", "white"],
+            list(range(30, 38)),
         )
+    )
+)
 
 
 COLOR_MAP = {
@@ -106,11 +99,11 @@ def colored(text, color=None, on_color=None, attrs=None):
         colored('Hello, World!', 'red', 'on_grey', ['blue', 'blink'])
         colored('Hello, World!', 'green')
     """
-    if os.getenv('ANSI_COLORS_DISABLED') is None:
+    if os.getenv("ANSI_COLORS_DISABLED") is None:
         style = "NORMAL"
-        if 'bold' in attrs:
+        if "bold" in attrs:
             style = "BRIGHT"
-            attrs.remove('bold')
+            attrs.remove("bold")
         if color is not None:
             color = color.upper()
             text = to_native_string("%s%s%s%s%s") % (
@@ -131,10 +124,7 @@ def colored(text, color=None, on_color=None, attrs=None):
             )
 
         if attrs is not None:
-            fmt_str = to_native_string("%s[%%dm%%s%s[9m") % (
-                chr(27),
-                chr(27)
-            )
+            fmt_str = to_native_string("%s[%%dm%%s%s[9m") % (chr(27), chr(27))
             for attr in attrs:
                 text = fmt_str % (ATTRIBUTES[attr], text)
 
diff --git a/pipenv/vendor/yaspin/__version__.py b/pipenv/vendor/yaspin/__version__.py
index 9e78220f..f075dd36 100644
--- a/pipenv/vendor/yaspin/__version__.py
+++ b/pipenv/vendor/yaspin/__version__.py
@@ -1 +1 @@
-__version__ = "0.14.0"
+__version__ = "0.14.1"
diff --git a/pipenv/vendor/yaspin/api.py b/pipenv/vendor/yaspin/api.py
index 156630db..f59ce002 100644
--- a/pipenv/vendor/yaspin/api.py
+++ b/pipenv/vendor/yaspin/api.py
@@ -84,5 +84,7 @@ def kbi_safe_yaspin(*args, **kwargs):
     return Yaspin(*args, **kwargs)
 
 
-_kbi_safe_doc = yaspin.__doc__.replace("yaspin", "kbi_safe_yaspin")
-kbi_safe_yaspin.__doc__ = _kbi_safe_doc
+# Handle PYTHONOPTIMIZE=2 case, when docstrings are set to None.
+if yaspin.__doc__:
+    _kbi_safe_doc = yaspin.__doc__.replace("yaspin", "kbi_safe_yaspin")
+    kbi_safe_yaspin.__doc__ = _kbi_safe_doc

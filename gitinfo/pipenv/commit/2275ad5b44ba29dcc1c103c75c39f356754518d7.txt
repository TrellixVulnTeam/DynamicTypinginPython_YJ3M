commit 2275ad5b44ba29dcc1c103c75c39f356754518d7
Author: Erin O'Connell <erin@omega-prime.sparkle>
Date:   Wed Nov 15 22:47:59 2017 -0700

    kenneth is awesome

diff --git a/pipenv/utils.py b/pipenv/utils.py
index 4cf25120..d4b7e973 100644
--- a/pipenv/utils.py
+++ b/pipenv/utils.py
@@ -272,7 +272,7 @@ packages = [
 
 def get_requirement(dep):
     """Pre-clean requirement strings passed to the requirements parser.
-    
+
     Ensures that we can accept both local and relative paths, file and VCS URIs,
     remote URIs, and package names, and that we pass only valid requirement strings
     to the requirements parser. Performs necessary modifications to requirements
@@ -430,86 +430,112 @@ def prepare_pip_source_args(sources, pip_args=None):
     return pip_args
 
 
-def resolve_deps(deps, which, which_pip, project, sources=None, verbose=False, python=False, clear=False, pre=False):
-    """Given a list of dependencies, return a resolved list of dependencies,
-    using pip-tools -- and their hashes, using the warehouse API / pip.
-    """
+def actually_resolve_reps(deps, index_lookup, markers_lookup, project, sources, verbose, clear, pre):
 
-    index_lookup = {}
-    markers_lookup = {}
+    class PipCommand(pip.basecommand.Command):
+        """Needed for pip-tools."""
+        name = 'PipCommand'
 
-    python_path = which('python')
+    constraints = []
 
-    with HackedPythonVersion(python_version=python, python_path=python_path):
+    for dep in deps:
+        t = tempfile.mkstemp(prefix='pipenv-', suffix='-requirement.txt')[1]
+        with open(t, 'w') as f:
+            f.write(dep)
 
-        class PipCommand(pip.basecommand.Command):
-            """Needed for pip-tools."""
-            name = 'PipCommand'
+        if dep.startswith('-e '):
+            constraint = pip.req.InstallRequirement.from_editable(dep[len('-e '):])
+        else:
+            constraint = [c for c in pip.req.parse_requirements(t, session=pip._vendor.requests)][0]
+            # extra_constraints = []
 
-        constraints = []
+        if ' -i ' in dep:
+            index_lookup[constraint.name] = project.get_source(url=dep.split(' -i ')[1]).get('name')
 
-        for dep in deps:
-            t = tempfile.mkstemp(prefix='pipenv-', suffix='-requirement.txt')[1]
-            with open(t, 'w') as f:
-                f.write(dep)
+        if constraint.markers:
+            markers_lookup[constraint.name] = str(constraint.markers).replace('"', "'")
 
-            if dep.startswith('-e '):
-                constraint = pip.req.InstallRequirement.from_editable(dep[len('-e '):])
-            else:
-                constraint = [c for c in pip.req.parse_requirements(t, session=pip._vendor.requests)][0]
-                # extra_constraints = []
+        constraints.append(constraint)
 
-            if ' -i ' in dep:
-                index_lookup[constraint.name] = project.get_source(url=dep.split(' -i ')[1]).get('name')
+    pip_command = get_pip_command()
 
-            if constraint.markers:
-                markers_lookup[constraint.name] = str(constraint.markers).replace('"', "'")
+    pip_args = []
 
-            constraints.append(constraint)
+    if sources:
+        pip_args = prepare_pip_source_args(sources, pip_args)
 
-        pip_command = get_pip_command()
+    if verbose:
+        print('Using pip: {0}'.format(' '.join(pip_args)))
 
-        pip_args = []
+    pip_options, _ = pip_command.parse_args(pip_args)
+
+    session = pip_command._build_session(pip_options)
+    pypi = PyPIRepository(pip_options=pip_options, session=session)
+
+    if verbose:
+        logging.log.verbose = True
+
+
+    resolved_tree = set()
 
-        if sources:
-            pip_args = prepare_pip_source_args(sources, pip_args)
+    resolver = Resolver(constraints=constraints, repository=pypi, clear_caches=clear, prereleases=pre)
+    # pre-resolve instead of iterating to avoid asking pypi for hashes of editable packages
+    try:
+        resolved_tree.update(resolver.resolve(max_rounds=PIPENV_MAX_ROUNDS))
+    except (NoCandidateFound, DistributionNotFound, HTTPError) as e:
+        click.echo(
+            '{0}: Your dependencies could not be resolved. You likely have a mismatch in your sub-dependencies.\n  '
+            'You can use {1} to bypass this mechanism, then run {2} to inspect the situation.'
+            ''.format(
+                crayons.red('Warning', bold=True),
+                crayons.red('$ pipenv install --skip-lock'),
+                crayons.red('$ pipenv graph')
+            ),
+            err=True)
 
-        if verbose:
-            print('Using pip: {0}'.format(' '.join(pip_args)))
+        click.echo(crayons.blue(e))
 
-        pip_options, _ = pip_command.parse_args(pip_args)
+        if 'no version found at all' in str(e):
+            click.echo(crayons.blue('Please check your version specifier and version number. See PEP440 for more information.'))
 
-        session = pip_command._build_session(pip_options)
-        pypi = PyPIRepository(pip_options=pip_options, session=session)
+        raise RuntimeError
 
-        if verbose:
-            logging.log.verbose = True
+    return resolved_tree
 
-        results = []
-        resolved_tree = set()
+def resolve_deps(deps, which, which_pip, project, sources=None, verbose=False, python=False, clear=False, pre=False):
+    """Given a list of dependencies, return a resolved list of dependencies,
+    using pip-tools -- and their hashes, using the warehouse API / pip.
+    """
+
+    index_lookup = {}
+    markers_lookup = {}
+
+    python_path = which('python')
+    backup_python_path = sys.executable
+
+    results = []
+
+    # First (proper) attempt:
+    with HackedPythonVersion(python_version=python, python_path=python_path):
 
-        resolver = Resolver(constraints=constraints, repository=pypi, clear_caches=clear, prereleases=pre)
-        # pre-resolve instead of iterating to avoid asking pypi for hashes of editable packages
         try:
-            resolved_tree.update(resolver.resolve(max_rounds=PIPENV_MAX_ROUNDS))
-        except (NoCandidateFound, DistributionNotFound, HTTPError) as e:
-            click.echo(
-                '{0}: Your dependencies could not be resolved. You likely have a mismatch in your sub-dependencies.\n  '
-                'You can use {1} to bypass this mechanism, then run {2} to inspect the situation.'
-                ''.format(
-                    crayons.red('Warning', bold=True),
-                    crayons.red('$ pipenv install --skip-lock'),
-                    crayons.red('$ pipenv graph')
-                ),
-                err=True)
-
-            click.echo(crayons.blue(e))
-
-            if 'no version found at all' in str(e):
-                click.echo(crayons.blue('Please check your version specifier and version number. See PEP440 for more information.'))
+            resolved_tree = actually_resolve_reps(deps, index_lookup, markers_lookup, project, sources, verbose, clear, pre)
+        except RuntimeError:
+            # Don't exit here, like usual.
+            pass
 
+    # Second (last-resort) attempt:
+    with HackedPythonVersion(python_version=''.join([str(s) for s in sys.version_info[:3]]), python_path=backup_python_path):
+
+        try:
+            # Attempt to resolve again, with different Python version information,
+            # particularly for particularly particular packages.
+            resolved_tree = actually_resolve_reps(deps, index_lookup, markers_lookup, project, sources, verbose, clear, pre)
+        except RuntimeError:
             sys.exit(1)
 
+
+
     for result in resolved_tree:
         if not result.editable:
             name = pep423_name(result.name)

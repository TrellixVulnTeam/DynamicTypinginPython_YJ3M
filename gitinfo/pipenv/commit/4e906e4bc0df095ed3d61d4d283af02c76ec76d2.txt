commit 4e906e4bc0df095ed3d61d4d283af02c76ec76d2
Author: Kenneth Reitz <me@kennethreitz.org>
Date:   Sun Mar 11 11:32:18 2018 -0400

    bam #1667

diff --git a/pipenv/patched/notpip/index.py b/pipenv/patched/notpip/index.py
index 7af4f403..85601124 100644
--- a/pipenv/patched/notpip/index.py
+++ b/pipenv/patched/notpip/index.py
@@ -28,12 +28,12 @@ from pip.exceptions import (
     UnsupportedWheel,
 )
 from pip.download import HAS_TLS, is_url, path_to_url, url_to_path
-from pip.wheel import Wheel, wheel_ext
+from notpip.wheel import Wheel, wheel_ext
 from pip.pep425tags import get_supported
 from notpip._vendor import html5lib, requests, six
 from pip._vendor.packaging.version import parse as parse_version
 from pip._vendor.packaging.utils import canonicalize_name
-from pip._vendor.packaging import specifiers
+from notpip._vendor.packaging import specifiers
 from pip._vendor.requests.exceptions import SSLError
 from pip._vendor.distlib.compat import unescape
 
@@ -280,7 +280,7 @@ class PackageFinder(object):
 
         return files, urls
 
-    def _candidate_sort_key(self, candidate):
+    def _candidate_sort_key(self, candidate, ignore_compatibility=True):
         """
         Function used to generate link sort key for link tuples.
         The greater the return value, the more preferred it is.
@@ -297,12 +297,17 @@ class PackageFinder(object):
         if candidate.location.is_wheel:
             # can raise InvalidWheelFilename
             wheel = Wheel(candidate.location.filename)
-            if not wheel.supported(self.valid_tags):
+            if not wheel.supported(self.valid_tags) and not ignore_compatibility:
                 raise UnsupportedWheel(
                     "%s is not a supported wheel for this platform. It "
                     "can't be sorted." % wheel.filename
                 )
-            pri = -(wheel.support_index_min(self.valid_tags))
+
+            tags = self.valid_tags if not ignore_compatibility else None
+            try:
+                pri = -(wheel.support_index_min(tags=tags))
+            except TypeError:
+                pri = -(support_num)
         else:  # sdist
             pri = -(support_num)
         return (candidate.version, pri)
@@ -483,7 +488,7 @@ class PackageFinder(object):
             dependency_versions
         )
 
-    def find_requirement(self, req, upgrade):
+    def find_requirement(self, req, upgrade, ignore_compatibility=True):
         """Try to find a Link matching req
 
         Expects req, an InstallRequirement and upgrade, a boolean
@@ -493,22 +498,26 @@ class PackageFinder(object):
         all_candidates = self.find_all_candidates(req.name)
 
         # Filter out anything which doesn't match our specifier
-        compatible_versions = set(
-            req.specifier.filter(
-                # We turn the version object into a str here because otherwise
-                # when we're debundled but setuptools isn't, Python will see
-                # packaging.version.Version and
-                # pkg_resources._vendor.packaging.version.Version as different
-                # types. This way we'll use a str as a common data interchange
-                # format. If we stop using the pkg_resources provided specifier
-                # and start using our own, we can drop the cast to str().
-                [str(c.version) for c in all_candidates],
-                prereleases=(
-                    self.allow_all_prereleases
-                    if self.allow_all_prereleases else None
-                ),
+        if not ignore_compatibility:
+            compatible_versions = set(
+                req.specifier.filter(
+                    # We turn the version object into a str here because otherwise
+                    # when we're debundled but setuptools isn't, Python will see
+                    # packaging.version.Version and
+                    # pkg_resources._vendor.packaging.version.Version as different
+                    # types. This way we'll use a str as a common data interchange
+                    # format. If we stop using the pkg_resources provided specifier
+                    # and start using our own, we can drop the cast to str().
+                    [str(c.version) for c in all_candidates],
+                    prereleases=(
+                        self.allow_all_prereleases
+                        if self.allow_all_prereleases else None
+                    ),
+                )
             )
-        )
+        else:
+            compatible_versions = [str(c.version) for c in all_candidates]
+
         applicable_candidates = [
             # Again, converting to str to deal with debundling.
             c for c in all_candidates if str(c.version) in compatible_versions
@@ -630,7 +639,7 @@ class PackageFinder(object):
             logger.debug('Skipping link %s; %s', link, reason)
             self.logged_links.add(link)
 
-    def _link_package_versions(self, link, search, ignore_requires_python=True):
+    def _link_package_versions(self, link, search, ignore_compatibility=True):
         """Return an InstallationCandidate or None"""
         version = None
         if link.egg_fragment:
@@ -641,15 +650,15 @@ class PackageFinder(object):
             if not ext:
                 self._log_skipped_link(link, 'not a file')
                 return
-            if ext not in SUPPORTED_EXTENSIONS:
+            if ext not in SUPPORTED_EXTENSIONS and not ignore_compatibility:
                 self._log_skipped_link(
                     link, 'unsupported archive format: %s' % ext)
                 return
-            if "binary" not in search.formats and ext == wheel_ext:
+            if "binary" not in search.formats and ext == wheel_ext and not ignore_compatibility:
                 self._log_skipped_link(
                     link, 'No binaries permitted for %s' % search.supplied)
                 return
-            if "macosx10" in link.path and ext == '.zip':
+            if "macosx10" in link.path and ext == '.zip' and not ignore_compatibility:
                 self._log_skipped_link(link, 'macosx10 one')
                 return
             if ext == wheel_ext:
@@ -663,7 +672,7 @@ class PackageFinder(object):
                         link, 'wrong project name (not %s)' % search.supplied)
                     return
 
-                if not wheel.supported(self.valid_tags):
+                if not wheel.supported(self.valid_tags) and not ignore_compatibility:
                     self._log_skipped_link(
                         link, 'it is not compatible with this Python')
                     return
diff --git a/pipenv/patched/notpip/req/req_set.py b/pipenv/patched/notpip/req/req_set.py
index b76dd591..92f51596 100644
--- a/pipenv/patched/notpip/req/req_set.py
+++ b/pipenv/patched/notpip/req/req_set.py
@@ -152,7 +152,7 @@ class RequirementSet(object):
                  force_reinstall=False, use_user_site=False, session=None,
                  pycompile=True, isolated=False, wheel_download_dir=None,
                  wheel_cache=None, require_hashes=False,
-                 ignore_requires_python=False):
+                 ignore_compatibility=True):
         """Create a RequirementSet.
 
         :param wheel_download_dir: Where still-packed .whl files should be
@@ -186,7 +186,7 @@ class RequirementSet(object):
         self.requirement_aliases = {}
         self.unnamed_requirements = []
         self.ignore_dependencies = ignore_dependencies
-        self.ignore_requires_python = ignore_requires_python
+        self.ignore_compatibility = ignore_compatibility
         self.successfully_downloaded = []
         self.successfully_installed = []
         self.reqs_to_cleanup = []
@@ -244,7 +244,7 @@ class RequirementSet(object):
         # environment markers.
         if install_req.link and install_req.link.is_wheel:
             wheel = Wheel(install_req.link.filename)
-            if not wheel.supported():
+            if not wheel.supported() and not self.ignore_compatibility:
                 raise InstallationError(
                     "%s is not a supported wheel on this platform." %
                     wheel.filename
diff --git a/pipenv/patched/notpip/wheel.py b/pipenv/patched/notpip/wheel.py
index 72c34877..bf424635 100644
--- a/pipenv/patched/notpip/wheel.py
+++ b/pipenv/patched/notpip/wheel.py
@@ -29,7 +29,7 @@ from pip.download import path_to_url, unpack_url
 from pip.exceptions import (
     InstallationError, InvalidWheelFilename, UnsupportedWheel)
 from pip.locations import distutils_scheme, PIP_DELETE_MARKER_FILENAME
-from pip import pep425tags
+from notpip import pep425tags
 from pip.utils import (
     call_subprocess, ensure_dir, captured_stdout, rmtree, read_chunks,
 )
diff --git a/pipenv/patched/piptools/repositories/pypi.py b/pipenv/patched/piptools/repositories/pypi.py
index e637e6e3..1576fa0d 100755
--- a/pipenv/patched/piptools/repositories/pypi.py
+++ b/pipenv/patched/piptools/repositories/pypi.py
@@ -201,7 +201,7 @@ class PyPIRepository(BaseRepository):
                                     wheel_download_dir=self._wheel_download_dir,
                                     session=self.session,
                                     ignore_installed=True,
-                                    ignore_requires_python=True
+                                    ignore_compatibility=True
                                     )
             result = reqset._prepare_file(self.finder, ireq, ignore_requires_python=True)
             if reqset.requires_python:
@@ -231,7 +231,6 @@ class PyPIRepository(BaseRepository):
         matching_versions = list(
             ireq.specifier.filter((candidate.version for candidate in all_candidates)))
         matching_candidates = candidates_by_version[matching_versions[0]]
-
         return {
             self._get_file_hash(candidate.location)
             for candidate in matching_candidates

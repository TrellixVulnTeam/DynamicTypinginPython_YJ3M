commit 5b2eddcc6534ec77c4d3228d555f9b707ab1b50d
Author: Dan Ryan <dan.ryan@canonical.com>
Date:   Tue Apr 28 14:28:21 2020 -0400

    Add build dir even though it's in gitignore
    
    Signed-off-by: Dan Ryan <dan.ryan@canonical.com>

diff --git a/pipenv/patched/notpip/_internal/operations/build/__init__.py b/pipenv/patched/notpip/_internal/operations/build/__init__.py
new file mode 100644
index 00000000..e69de29b
diff --git a/pipenv/patched/notpip/_internal/operations/build/metadata.py b/pipenv/patched/notpip/_internal/operations/build/metadata.py
new file mode 100644
index 00000000..b3ad90c6
--- /dev/null
+++ b/pipenv/patched/notpip/_internal/operations/build/metadata.py
@@ -0,0 +1,40 @@
+"""Metadata generation logic for source distributions.
+"""
+
+import logging
+import os
+
+from pipenv.patched.notpip._internal.utils.subprocess import runner_with_spinner_message
+from pipenv.patched.notpip._internal.utils.temp_dir import TempDirectory
+from pipenv.patched.notpip._internal.utils.typing import MYPY_CHECK_RUNNING
+
+if MYPY_CHECK_RUNNING:
+    from pipenv.patched.notpip._internal.build_env import BuildEnvironment
+    from pipenv.patched.notpip._vendor.pep517.wrappers import Pep517HookCaller
+
+logger = logging.getLogger(__name__)
+
+
+def generate_metadata(build_env, backend):
+    # type: (BuildEnvironment, Pep517HookCaller) -> str
+    """Generate metadata using mechanisms described in PEP 517.
+
+    Returns the generated metadata directory.
+    """
+    metadata_tmpdir = TempDirectory(
+        kind="modern-metadata", globally_managed=True
+    )
+
+    metadata_dir = metadata_tmpdir.path
+
+    with build_env:
+        # Note that Pep517HookCaller implements a fallback for
+        # prepare_metadata_for_build_wheel, so we don't have to
+        # consider the possibility that this hook doesn't exist.
+        runner = runner_with_spinner_message("Preparing wheel metadata")
+        with backend.subprocess_runner(runner):
+            distinfo_dir = backend.prepare_metadata_for_build_wheel(
+                metadata_dir
+            )
+
+    return os.path.join(metadata_dir, distinfo_dir)
diff --git a/pipenv/patched/notpip/_internal/operations/build/metadata_legacy.py b/pipenv/patched/notpip/_internal/operations/build/metadata_legacy.py
new file mode 100644
index 00000000..9c84151d
--- /dev/null
+++ b/pipenv/patched/notpip/_internal/operations/build/metadata_legacy.py
@@ -0,0 +1,122 @@
+"""Metadata generation logic for legacy source distributions.
+"""
+
+import logging
+import os
+
+from pipenv.patched.notpip._internal.exceptions import InstallationError
+from pipenv.patched.notpip._internal.utils.misc import ensure_dir
+from pipenv.patched.notpip._internal.utils.setuptools_build import make_setuptools_egg_info_args
+from pipenv.patched.notpip._internal.utils.subprocess import call_subprocess
+from pipenv.patched.notpip._internal.utils.typing import MYPY_CHECK_RUNNING
+from pipenv.patched.notpip._internal.vcs import vcs
+
+if MYPY_CHECK_RUNNING:
+    from typing import List, Optional
+
+    from pipenv.patched.notpip._internal.build_env import BuildEnvironment
+
+logger = logging.getLogger(__name__)
+
+
+def _find_egg_info(source_directory, is_editable):
+    # type: (str, bool) -> str
+    """Find an .egg-info in `source_directory`, based on `is_editable`.
+    """
+
+    def looks_like_virtual_env(path):
+        # type: (str) -> bool
+        return (
+            os.path.lexists(os.path.join(path, 'bin', 'python')) or
+            os.path.exists(os.path.join(path, 'Scripts', 'Python.exe'))
+        )
+
+    def locate_editable_egg_info(base):
+        # type: (str) -> List[str]
+        candidates = []  # type: List[str]
+        for root, dirs, files in os.walk(base):
+            for dir_ in vcs.dirnames:
+                if dir_ in dirs:
+                    dirs.remove(dir_)
+            # Iterate over a copy of ``dirs``, since mutating
+            # a list while iterating over it can cause trouble.
+            # (See https://github.com/pypa/pip/pull/462.)
+            for dir_ in list(dirs):
+                if looks_like_virtual_env(os.path.join(root, dir_)):
+                    dirs.remove(dir_)
+                # Also don't search through tests
+                elif dir_ == 'test' or dir_ == 'tests':
+                    dirs.remove(dir_)
+            candidates.extend(os.path.join(root, dir_) for dir_ in dirs)
+        return [f for f in candidates if f.endswith('.egg-info')]
+
+    def depth_of_directory(dir_):
+        # type: (str) -> int
+        return (
+            dir_.count(os.path.sep) +
+            (os.path.altsep and dir_.count(os.path.altsep) or 0)
+        )
+
+    base = source_directory
+    if is_editable:
+        filenames = locate_editable_egg_info(base)
+    else:
+        base = os.path.join(base, 'pip-egg-info')
+        filenames = os.listdir(base)
+
+    if not filenames:
+        raise InstallationError(
+            "Files/directories not found in {}".format(base)
+        )
+
+    # If we have more than one match, we pick the toplevel one.  This
+    # can easily be the case if there is a dist folder which contains
+    # an extracted tarball for testing purposes.
+    if len(filenames) > 1:
+        filenames.sort(key=depth_of_directory)
+
+    return os.path.join(base, filenames[0])
+
+
+def generate_metadata(
+    build_env,  # type: BuildEnvironment
+    setup_py_path,  # type: str
+    source_dir,  # type: str
+    editable,  # type: bool
+    isolated,  # type: bool
+    details,  # type: str
+):
+    # type: (...) -> str
+    """Generate metadata using setup.py-based defacto mechanisms.
+
+    Returns the generated metadata directory.
+    """
+    logger.debug(
+        'Running setup.py (path:%s) egg_info for package %s',
+        setup_py_path, details,
+    )
+
+    egg_info_dir = None  # type: Optional[str]
+    # For non-editable installs, don't put the .egg-info files at the root,
+    # to avoid confusion due to the source code being considered an installed
+    # egg.
+    if not editable:
+        egg_info_dir = os.path.join(source_dir, 'pip-egg-info')
+        # setuptools complains if the target directory does not exist.
+        ensure_dir(egg_info_dir)
+
+    args = make_setuptools_egg_info_args(
+        setup_py_path,
+        egg_info_dir=egg_info_dir,
+        no_user_config=isolated,
+    )
+
+    with build_env:
+        call_subprocess(
+            args,
+            cwd=source_dir,
+            command_desc='python setup.py egg_info',
+        )
+
+    # Return the .egg-info directory.
+    return _find_egg_info(source_dir, editable)
diff --git a/pipenv/patched/notpip/_internal/operations/build/wheel.py b/pipenv/patched/notpip/_internal/operations/build/wheel.py
new file mode 100644
index 00000000..39e97d52
--- /dev/null
+++ b/pipenv/patched/notpip/_internal/operations/build/wheel.py
@@ -0,0 +1,46 @@
+import logging
+import os
+
+from pipenv.patched.notpip._internal.utils.subprocess import runner_with_spinner_message
+from pipenv.patched.notpip._internal.utils.typing import MYPY_CHECK_RUNNING
+
+if MYPY_CHECK_RUNNING:
+    from typing import List, Optional
+    from pipenv.patched.notpip._vendor.pep517.wrappers import Pep517HookCaller
+
+logger = logging.getLogger(__name__)
+
+
+def build_wheel_pep517(
+    name,  # type: str
+    backend,  # type: Pep517HookCaller
+    metadata_directory,  # type: str
+    build_options,  # type: List[str]
+    tempd,  # type: str
+):
+    # type: (...) -> Optional[str]
+    """Build one InstallRequirement using the PEP 517 build process.
+
+    Returns path to wheel if successfully built. Otherwise, returns None.
+    """
+    assert metadata_directory is not None
+    if build_options:
+        # PEP 517 does not support --build-options
+        logger.error('Cannot build wheel for %s using PEP 517 when '
+                     '--build-option is present' % (name,))
+        return None
+    try:
+        logger.debug('Destination directory: %s', tempd)
+
+        runner = runner_with_spinner_message(
+            'Building wheel for {} (PEP 517)'.format(name)
+        )
+        with backend.subprocess_runner(runner):
+            wheel_name = backend.build_wheel(
+                tempd,
+                metadata_directory=metadata_directory,
+            )
+    except Exception:
+        logger.error('Failed building wheel for %s', name)
+        return None
+    return os.path.join(tempd, wheel_name)
diff --git a/pipenv/patched/notpip/_internal/operations/build/wheel_legacy.py b/pipenv/patched/notpip/_internal/operations/build/wheel_legacy.py
new file mode 100644
index 00000000..0d6183af
--- /dev/null
+++ b/pipenv/patched/notpip/_internal/operations/build/wheel_legacy.py
@@ -0,0 +1,115 @@
+import logging
+import os.path
+
+from pipenv.patched.notpip._internal.utils.setuptools_build import (
+    make_setuptools_bdist_wheel_args,
+)
+from pipenv.patched.notpip._internal.utils.subprocess import (
+    LOG_DIVIDER,
+    call_subprocess,
+    format_command_args,
+)
+from pipenv.patched.notpip._internal.utils.typing import MYPY_CHECK_RUNNING
+from pipenv.patched.notpip._internal.utils.ui import open_spinner
+
+if MYPY_CHECK_RUNNING:
+    from typing import List, Optional, Text
+
+logger = logging.getLogger(__name__)
+
+
+def format_command_result(
+    command_args,  # type: List[str]
+    command_output,  # type: Text
+):
+    # type: (...) -> str
+    """Format command information for logging."""
+    command_desc = format_command_args(command_args)
+    text = 'Command arguments: {}\n'.format(command_desc)
+
+    if not command_output:
+        text += 'Command output: None'
+    elif logger.getEffectiveLevel() > logging.DEBUG:
+        text += 'Command output: [use --verbose to show]'
+    else:
+        if not command_output.endswith('\n'):
+            command_output += '\n'
+        text += 'Command output:\n{}{}'.format(command_output, LOG_DIVIDER)
+
+    return text
+
+
+def get_legacy_build_wheel_path(
+    names,  # type: List[str]
+    temp_dir,  # type: str
+    name,  # type: str
+    command_args,  # type: List[str]
+    command_output,  # type: Text
+):
+    # type: (...) -> Optional[str]
+    """Return the path to the wheel in the temporary build directory."""
+    # Sort for determinism.
+    names = sorted(names)
+    if not names:
+        msg = (
+            'Legacy build of wheel for {!r} created no files.\n'
+        ).format(name)
+        msg += format_command_result(command_args, command_output)
+        logger.warning(msg)
+        return None
+
+    if len(names) > 1:
+        msg = (
+            'Legacy build of wheel for {!r} created more than one file.\n'
+            'Filenames (choosing first): {}\n'
+        ).format(name, names)
+        msg += format_command_result(command_args, command_output)
+        logger.warning(msg)
+
+    return os.path.join(temp_dir, names[0])
+
+
+def build_wheel_legacy(
+    name,  # type: str
+    setup_py_path,  # type: str
+    source_dir,  # type: str
+    global_options,  # type: List[str]
+    build_options,  # type: List[str]
+    tempd,  # type: str
+):
+    # type: (...) -> Optional[str]
+    """Build one unpacked package using the "legacy" build process.
+
+    Returns path to wheel if successfully built. Otherwise, returns None.
+    """
+    wheel_args = make_setuptools_bdist_wheel_args(
+        setup_py_path,
+        global_options=global_options,
+        build_options=build_options,
+        destination_dir=tempd,
+    )
+
+    spin_message = 'Building wheel for %s (setup.py)' % (name,)
+    with open_spinner(spin_message) as spinner:
+        logger.debug('Destination directory: %s', tempd)
+
+        try:
+            output = call_subprocess(
+                wheel_args,
+                cwd=source_dir,
+                spinner=spinner,
+            )
+        except Exception:
+            spinner.finish("error")
+            logger.error('Failed building wheel for %s', name)
+            return None
+
+        names = os.listdir(tempd)
+        wheel_path = get_legacy_build_wheel_path(
+            names=names,
+            temp_dir=tempd,
+            name=name,
+            command_args=wheel_args,
+            command_output=output,
+        )
+        return wheel_path

commit 51e2be70ca66dceaa3f22406385a673a488f0f35
Author: Dan Ryan <dan@danryan.co>
Date:   Mon May 27 02:38:54 2019 -0400

    Update requirementslib to fix recursion error
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/utils.py b/pipenv/utils.py
index 61d771ce..b73b7fa7 100644
--- a/pipenv/utils.py
+++ b/pipenv/utils.py
@@ -985,8 +985,8 @@ def resolve(cmd, sp):
             _out = decode_output("{0}\n".format(_out))
             out += _out
             sp.text = to_native_string("{0}".format(_out[:100]))
-            # if environments.is_verbose():
-            #     sp.hide_and_write(_out.rstrip())
+            if environments.is_verbose():
+                sp.hide_and_write(_out.rstrip())
         _out = to_native_string("")
         if not result and not _out:
             break
@@ -2019,7 +2019,7 @@ def find_python(finder, line=None):
         )
     if line and os.path.isabs(line):
         if os.name == "nt":
-            line = posixpath.join(*line.split(os.path.sep))
+            line = make_posix(line)
         return line
     if not finder:
         from pipenv.vendor.pythonfinder import Finder
diff --git a/pipenv/vendor/requirementslib/models/requirements.py b/pipenv/vendor/requirementslib/models/requirements.py
index b8534c69..559ab424 100644
--- a/pipenv/vendor/requirementslib/models/requirements.py
+++ b/pipenv/vendor/requirementslib/models/requirements.py
@@ -814,14 +814,14 @@ class Line(object):
     @cached_property
     def metadata(self):
         # type: () -> Dict[Any, Any]
-        if self.is_local and is_installable_dir(self.path):
+        if self.is_local and self.path and is_installable_dir(self.path):
             return get_metadata(self.path)
         return {}
 
     @cached_property
     def parsed_setup_cfg(self):
         # type: () -> Dict[Any, Any]
-        if self.is_local and is_installable_dir(self.path):
+        if self.is_local and self.path and is_installable_dir(self.path):
             if self.setup_cfg:
                 return parse_setup_cfg(self.setup_cfg)
         return {}
@@ -829,7 +829,7 @@ class Line(object):
     @cached_property
     def parsed_setup_py(self):
         # type: () -> Dict[Any, Any]
-        if self.is_local and is_installable_dir(self.path):
+        if self.is_local and self.path and is_installable_dir(self.path):
             if self.setup_py:
                 return ast_parse_setup_py(self.setup_py)
         return {}
diff --git a/pipenv/vendor/requirementslib/models/setup_info.py b/pipenv/vendor/requirementslib/models/setup_info.py
index 8b41ecac..0dd5b3c8 100644
--- a/pipenv/vendor/requirementslib/models/setup_info.py
+++ b/pipenv/vendor/requirementslib/models/setup_info.py
@@ -660,7 +660,7 @@ class Analyzer(ast.NodeVisitor):
 
 def ast_unparse(item, initial_mapping=False, analyzer=None, recurse=True):  # noqa:C901
     # type: (Any, bool, Optional[Analyzer], bool) -> Union[List[Any], Dict[Any, Any], Tuple[Any, ...], STRING_TYPE]
-    unparse = partial(ast_unparse, initial_mapping=initial_mapping, analyzer=analyzer)
+    unparse = partial(ast_unparse, initial_mapping=initial_mapping, analyzer=analyzer, recurse=recurse)
     if isinstance(item, ast.Dict):
         unparsed = dict(zip(unparse(item.keys), unparse(item.values)))
     elif isinstance(item, ast.List):
@@ -690,18 +690,22 @@ def ast_unparse(item, initial_mapping=False, analyzer=None, recurse=True):  # no
     elif isinstance(item, ast.Attribute):
         attr_name = getattr(item, "value", None)
         attr_attr = getattr(item, "attr", None)
-        name = unparse(attr_name) if attr_name is not None else attr_attr
+        name = None
         if initial_mapping:
             unparsed = item
-        elif name and attr_attr:
+        elif attr_name and not recurse:
+            name = attr_name
+        else:
+            name = unparse(attr_name) if attr_name is not None else attr_attr
+        if name and attr_attr:
             if not initial_mapping and isinstance(name, six.string_types):
                 unparsed = ".".join([item for item in (name, attr_attr) if item])
             else:
                 unparsed = item
-        elif attr_attr and not name:
+        elif attr_attr and not name and not initial_mapping:
             unparsed = attr_attr
         else:
-            unparsed = name
+            unparsed = name if not unparsed else unparsed
     elif isinstance(item, ast.Call):
         unparsed = {}
         if isinstance(item.func, ast.Name):
@@ -721,7 +725,7 @@ def ast_unparse(item, initial_mapping=False, analyzer=None, recurse=True):  # no
         # XXX: Original reference
         if not initial_mapping:
             target = unparse(next(iter(item.targets)), recurse=False)
-            val = unparse(item.value)
+            val = unparse(item.value, recurse=False)
             if isinstance(target, (tuple, set, list)):
                 unparsed = dict(zip(target, val))
             else:

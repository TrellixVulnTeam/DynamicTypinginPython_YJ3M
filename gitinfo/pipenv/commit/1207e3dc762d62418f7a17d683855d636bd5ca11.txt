commit 1207e3dc762d62418f7a17d683855d636bd5ca11
Author: Dan Ryan <dan@danryan.co>
Date:   Tue Feb 26 01:06:44 2019 -0500

    Update keep outdated implementation with new pipenv code
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/Pipfile b/Pipfile
index a8ddd5e6..8de9428f 100644
--- a/Pipfile
+++ b/Pipfile
@@ -5,7 +5,7 @@ sphinx = "<=1.5.5"
 twine = "*"
 sphinx-click = "*"
 click = "*"
-pytest-pypi = {path = "./tests/pytest-pypi", editable = true}
+pytest_pypi = {path = "./tests/pytest-pypi", editable = true}
 stdeb = {version="*", markers="sys_platform == 'linux'"}
 black = {version="*", markers="python_version >= '3.6'"}
 pytz = "*"
diff --git a/pipenv/core.py b/pipenv/core.py
index a842bbc8..bad27704 100644
--- a/pipenv/core.py
+++ b/pipenv/core.py
@@ -745,8 +745,8 @@ def batch_install(deps_list, procs, failed_deps_queue,
                 extra_indexes=extra_indexes,
                 use_pep517=not retry,
             )
-            if dep.is_vcs or dep.editable:
-                c.block()
+            # if dep.is_vcs or dep.editable:
+            #     c.block()
             if procs.qsize() < nprocs:
                 c.dep = dep
                 procs.put(c)
@@ -1300,6 +1300,10 @@ def pip_install(
                 crayons.normal("Installing {0!r}".format(requirement.name), bold=True),
                 err=True,
             )
+
+    if requirement:
+        ignore_hashes = True if not requirement.hashes else ignore_hashes
+
     # Create files for hash mode.
     if write_to_tmpfile:
         if not requirements_dir:
@@ -1309,14 +1313,13 @@ def pip_install(
             prefix="pipenv-", suffix="-requirement.txt", dir=requirements_dir,
             delete=False
         )
-        f.write(vistir.misc.to_bytes(requirement.as_line()))
+        line = requirement.as_line(include_hashes=not ignore_hashes)
+        f.write(vistir.misc.to_bytes(line))
         r = f.name
         f.close()
 
     if requirement and requirement.vcs:
         # Install dependencies when a package is a non-editable VCS dependency.
-        if not requirement.editable:
-            no_deps = False
         # Don't specify a source directory when using --system.
         if not allow_global and ("PIP_SRC" not in os.environ):
             src.extend(["--src", "{0}".format(project.virtualenv_src_location)])
@@ -1367,6 +1370,7 @@ def pip_install(
 
     # Install dependencies when a package is a VCS dependency.
     if requirement and requirement.vcs:
+        ignore_hashes = True
         # Don't specify a source directory when using --system.
         src_dir = None
         if "PIP_SRC" in os.environ:
@@ -1425,17 +1429,23 @@ def pip_install(
         install_reqs = requirement.as_line(**line_kwargs)
         if requirement.editable and install_reqs[0].startswith("-e "):
             req, install_reqs = install_reqs[0], install_reqs[1:]
+            possible_hashes = install_reqs[:]
             editable_opt, req = req.split(" ", 1)
             install_reqs = [editable_opt, req] + install_reqs
-        if not any(item.startswith("--hash") for item in install_reqs):
-            ignore_hashes = True
+        # hashes must be passed via a file
+        ignore_hashes = True
+        # if possible_hashes and not any(
+        #     item.startswith("--hash") for item in possible_hashes.split()
+        # ):
+        #     ignore_hashes = True
     elif r:
         install_reqs = ["-r", r]
         with open(r) as f:
             if "--hash" not in f.read():
                 ignore_hashes = True
     else:
-        ignore_hashes = True if not requirement.hashes else False
+        # hashes need to be passed via a file
+        ignore_hashes = True
         install_reqs = requirement.as_line(as_list=True, include_hashes=not ignore_hashes)
         if not requirement.markers:
             install_reqs = [escape_cmd(r) for r in install_reqs]
@@ -1458,8 +1468,10 @@ def pip_install(
     if not ignore_hashes:
         pip_command.append("--require-hashes")
     if not use_pep517:
+        from .vendor.packaging.version import parse as parse_version
         pip_command.append("--no-build-isolation")
-        pip_command.append("--no-use-pep517")
+        if project.environment.pip_version >= parse_version("19.0"):
+            pip_command.append("--no-use-pep517")
     if environments.is_verbose():
         click.echo("$ {0}".format(pip_command), err=True)
     cache_dir = vistir.compat.Path(PIPENV_CACHE_DIR)
diff --git a/pipenv/environment.py b/pipenv/environment.py
index f13fbc37..6a24d5e1 100644
--- a/pipenv/environment.py
+++ b/pipenv/environment.py
@@ -206,7 +206,8 @@ class Environment(object):
 
     @cached_property
     def sys_prefix(self):
-        """The prefix run inside the context of the environment
+        """
+        The prefix run inside the context of the environment
 
         :return: The python prefix inside the environment
         :rtype: :data:`sys.prefix`
@@ -241,8 +242,23 @@ class Environment(object):
             return "purelib", purelib
         return "platlib", self.paths["platlib"]
 
+    @property
+    def pip_version(self):
+        """
+        Get the pip version in the environment.  Useful for knowing which args we can use
+        when installing.
+        """
+        pip = next(iter(
+            pkg for pkg in self.get_installed_packages() if pkg.key == "pip"
+        ), None)
+        if pip is not None:
+            from .vendor.packaging.version import parse as parse_version
+            pip_version = parse_version(pip.version)
+        return parse_version("18.0")
+
     def get_distributions(self):
-        """Retrives the distributions installed on the library path of the environment
+        """
+        Retrives the distributions installed on the library path of the environment
 
         :return: A set of distributions found on the library path
         :rtype: iterator
diff --git a/pipenv/project.py b/pipenv/project.py
index 8e209638..4ce10740 100644
--- a/pipenv/project.py
+++ b/pipenv/project.py
@@ -537,7 +537,7 @@ class Project(object):
 
     @property
     def build_requires(self):
-        return self._build_system.get("requires", [])
+        return self._build_system.get("requires", ["setuptools>=40.8.0", "wheel"])
 
     @property
     def build_backend(self):
diff --git a/pipenv/utils.py b/pipenv/utils.py
index 8bbb3409..4b3281ea 100644
--- a/pipenv/utils.py
+++ b/pipenv/utils.py
@@ -342,13 +342,18 @@ class Resolver(object):
         if indexes:
             url = indexes[0]
         line = " ".join(remainder)
+        req = None  # type: Requirement
         req = Requirement.from_line(line)
         if url:
             try:
                 index_lookup[req.normalized_name] = project.get_source(
                     url=url, refresh=True).get("name")
             except TypeError:
-                raise RequirementError(req=req)
+                pass
+        try:
+            req.normalized_name
+        except TypeError:
+            raise RequirementError(req=req)
         # strip the marker and re-add it later after resolution
         # but we will need a fallback in case resolution fails
         # eg pypiwin32
diff --git a/pipenv/vendor/requirementslib/models/pipfile.py b/pipenv/vendor/requirementslib/models/pipfile.py
index ba7eeed5..22eee048 100644
--- a/pipenv/vendor/requirementslib/models/pipfile.py
+++ b/pipenv/vendor/requirementslib/models/pipfile.py
@@ -22,7 +22,7 @@ from .utils import optional_instance_of, get_url_name
 
 from ..environment import MYPY_RUNNING
 if MYPY_RUNNING:
-    from typing import Union, Any, Dict, Iterable, Sequence, Mapping, List, NoReturn, Text
+    from typing import Union, Any, Dict, Iterable, Mapping, List, Text
     package_type = Dict[Text, Dict[Text, Union[List[Text], Text]]]
     source_type = Dict[Text, Union[Text, bool]]
     sources_type = Iterable[source_type]
@@ -264,7 +264,8 @@ class Pipfile(object):
     @classmethod
     def load_projectfile(cls, path, create=False):
         # type: (Text, bool) -> ProjectFile
-        """Given a path, load or create the necessary pipfile.
+        """
+        Given a path, load or create the necessary pipfile.
 
         :param Text path: Path to the project root or pipfile
         :param bool create: Whether to create the pipfile if not found, defaults to True
@@ -289,7 +290,8 @@ class Pipfile(object):
     @classmethod
     def load(cls, path, create=False):
         # type: (Text, bool) -> Pipfile
-        """Given a path, load or create the necessary pipfile.
+        """
+        Given a path, load or create the necessary pipfile.
 
         :param Text path: Path to the project root or pipfile
         :param bool create: Whether to create the pipfile if not found, defaults to True
diff --git a/pipenv/vendor/requirementslib/models/requirements.py b/pipenv/vendor/requirementslib/models/requirements.py
index 18b83195..5d3f6c5b 100644
--- a/pipenv/vendor/requirementslib/models/requirements.py
+++ b/pipenv/vendor/requirementslib/models/requirements.py
@@ -77,7 +77,7 @@ from .utils import (
 from ..environment import MYPY_RUNNING
 
 if MYPY_RUNNING:
-    from typing import Optional, TypeVar, List, Dict, Union, Any, Tuple, Generator, Set, Text
+    from typing import Optional, TypeVar, List, Dict, Union, Any, Tuple, Set, Text
     from pip_shims.shims import Link, InstallRequirement
     RequirementType = TypeVar('RequirementType', covariant=True, bound=PackagingRequirement)
     from six.moves.urllib.parse import SplitResult
@@ -320,8 +320,8 @@ class Line(object):
     @specifiers.setter
     def specifiers(self, specifiers):
         # type: (Union[Text, SpecifierSet]) -> None
-        if type(specifiers) is not SpecifierSet:
-            if type(specifiers) in six.string_types:
+        if not isinstance(specifiers, SpecifierSet):
+            if isinstance(specifiers, six.string_types):
                 specifiers = SpecifierSet(specifiers)
             else:
                 raise TypeError("Must pass a string or a SpecifierSet")
@@ -739,7 +739,7 @@ class Line(object):
         wheel_kwargs = self.wheel_kwargs.copy()
         wheel_kwargs["src_dir"] = repo.checkout_directory
         ireq.source_dir = wheel_kwargs["src_dir"]
-        build_dir = ireq.build_location(wheel_kwargs["build_dir"])
+        ireq.build_location(wheel_kwargs["build_dir"])
         ireq._temp_build_dir.path = wheel_kwargs["build_dir"]
         with temp_path():
             sys.path = [repo.checkout_directory, "", ".", get_python_lib(plat_specific=0)]
@@ -1789,7 +1789,7 @@ class FileRequirement(object):
                     line = "{0}{1}".format(line, extras_to_string(extras))
             if "subdirectory" in pipfile:
                 arg_dict["subdirectory"] = pipfile["subdirectory"]
-                line = "{0}&subdirectory={1}".format(pipfile["subdirectory"])
+                line = "{0}&subdirectory={1}".format(line, pipfile["subdirectory"])
         if pipfile.get("editable", False):
             line = "-e {0}".format(line)
         arg_dict["line"] = line
@@ -2602,7 +2602,7 @@ class Requirement(object):
                 r.req.extras = args["extras"]
         if parsed_line.hashes:
             args["hashes"] = tuple(parsed_line.hashes)  # type: ignore
-        cls_inst = cls(**args)
+        cls_inst = cls(**args)  # type: ignore
         return cls_inst
 
     @classmethod
diff --git a/pipenv/vendor/requirementslib/models/setup_info.py b/pipenv/vendor/requirementslib/models/setup_info.py
index b0b55d47..e599f6f7 100644
--- a/pipenv/vendor/requirementslib/models/setup_info.py
+++ b/pipenv/vendor/requirementslib/models/setup_info.py
@@ -15,7 +15,6 @@ import pep517.envbuild
 import pep517.wrappers
 import six
 from appdirs import user_cache_dir
-from cached_property import cached_property
 from distlib.wheel import Wheel
 from packaging.markers import Marker
 from six.moves import configparser
@@ -303,8 +302,8 @@ def get_metadata_from_wheel(wheel_path):
     name = metadata.name
     version = metadata.version
     requires = []
-    extras_keys = getattr(metadata, "extras", None)
-    extras = {}
+    extras_keys = getattr(metadata, "extras", [])
+    extras = {k: [] for k in extras_keys}
     for req in getattr(metadata, "run_requires", []):
         parsed_req = init_requirement(req)
         parsed_marker = parsed_req.marker
@@ -652,6 +651,7 @@ build-backend = "{1}"
             dist_type="wheel"
         )
 
+    # noinspection PyPackageRequirements
     def build_sdist(self):
         # type: () -> Text
         if not self.pyproject.exists():
@@ -718,7 +718,7 @@ build-backend = "{1}"
             get_metadata(d, pkg_name=self.name, metadata_type=metadata_type)
             for d in metadata_dirs if os.path.exists(d)
         ]
-        metadata = next(iter(d for d in metadata if d is not None), None)
+        metadata = next(iter(d for d in metadata if d), None)
         if metadata is not None:
             self.populate_metadata(metadata)
 
@@ -839,7 +839,7 @@ build-backend = "{1}"
             from .dependencies import get_finder
 
             finder = get_finder()
-        vcs_method, uri = split_vcs_method_from_uri(unquote(ireq.link.url_without_fragment))
+        _, uri = split_vcs_method_from_uri(unquote(ireq.link.url_without_fragment))
         parsed = urlparse(uri)
         if "file" in parsed.scheme:
             url_path = parsed.path
@@ -870,7 +870,7 @@ build-backend = "{1}"
                 "The file URL points to a directory not installable: {}"
                 .format(ireq.link)
             )
-        build_dir = ireq.build_location(kwargs["build_dir"])
+        ireq.build_location(kwargs["build_dir"])
         src_dir = ireq.ensure_has_source_dir(kwargs["src_dir"])
         ireq._temp_build_dir.path = kwargs["build_dir"]
 
diff --git a/pipenv/vendor/requirementslib/models/utils.py b/pipenv/vendor/requirementslib/models/utils.py
index 6ad4972d..387997f3 100644
--- a/pipenv/vendor/requirementslib/models/utils.py
+++ b/pipenv/vendor/requirementslib/models/utils.py
@@ -295,9 +295,11 @@ def strip_extras_markers_from_requirement(req):
         raise TypeError("Must pass in a valid requirement, received {0!r}".format(req))
     if getattr(req, "marker", None) is not None:
         marker = req.marker  # type: TMarker
-        req.marker._markers = _strip_extras_markers(req.marker._markers)
-        if not req.marker._markers:
+        marker._markers = _strip_extras_markers(marker._markers)
+        if not marker._markers:
             req.marker = None
+        else:
+            req.marker = marker
     return req
 
 
@@ -354,9 +356,9 @@ def get_pyproject(path):
     :rtype: Tuple[List[Text], Text]
     """
 
-    from vistir.compat import Path
     if not path:
         return
+    from vistir.compat import Path
     if not isinstance(path, Path):
         path = Path(path)
     if not path.is_dir():

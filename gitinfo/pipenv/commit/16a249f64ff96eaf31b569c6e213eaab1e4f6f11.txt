commit 16a249f64ff96eaf31b569c6e213eaab1e4f6f11
Author: Dan Ryan <dan@danryan.co>
Date:   Wed Feb 20 17:52:04 2019 -0500

    Fix installed package discovery on windows
    
    - Fix prefix formatting
    - Add posix formatting function
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/environment.py b/pipenv/environment.py
index 5e2ec3f5..d06bae8e 100644
--- a/pipenv/environment.py
+++ b/pipenv/environment.py
@@ -19,7 +19,7 @@ import pipenv
 
 from cached_property import cached_property
 
-from .utils import normalize_path
+from .utils import normalize_path, make_posix
 
 
 BASE_WORKING_SET = pkg_resources.WorkingSet(sys.path)
@@ -145,7 +145,7 @@ class Environment(object):
         'stdlib': '/home/hawk/.pyenv/versions/3.7.1/lib/python3.7'}
         """
 
-        prefix = self.prefix.as_posix()
+        prefix = make_posix(self.prefix.as_posix())
         install_scheme = 'nt' if (os.name == 'nt') else 'posix_prefix'
         paths = get_paths(install_scheme, vars={
             'base': prefix,
@@ -154,8 +154,8 @@ class Environment(object):
         paths["PATH"] = paths["scripts"] + os.pathsep + os.defpath
         if "prefix" not in paths:
             paths["prefix"] = prefix
-        purelib = get_python_lib(plat_specific=0, prefix=prefix)
-        platlib = get_python_lib(plat_specific=1, prefix=prefix)
+        purelib = make_posix(get_python_lib(plat_specific=0, prefix=prefix))
+        platlib = make_posix(get_python_lib(plat_specific=1, prefix=prefix))
         if purelib == platlib:
             lib_dirs = purelib
         else:
@@ -272,13 +272,14 @@ class Environment(object):
         """Determine whether the supplied distribution is in the environment."""
         from .project import _normalized
         prefixes = [
-            _normalized(prefix) for prefix in self.base_paths["libdirs"]
-            if _normalized(self.prefix).startswith(_normalized(prefix))
+            _normalized(prefix) for prefix in self.base_paths["libdirs"].split(os.pathsep)
+            if _normalized(prefix).startswith(_normalized(self.prefix.as_posix()))
         ]
         location = self.locate_dist(dist)
         if not location:
             return False
-        return any(_normalized(location).startswith(prefix) for prefix in prefixes)
+        location = _normalized(make_posix(location))
+        return any(location.startswith(prefix) for prefix in prefixes)
 
     def get_installed_packages(self):
         """Returns all of the installed packages in a given environment"""
diff --git a/pipenv/project.py b/pipenv/project.py
index 68ec4666..7d359a8e 100644
--- a/pipenv/project.py
+++ b/pipenv/project.py
@@ -525,8 +525,8 @@ class Project(object):
             if not os.path.exists(self.path_to("setup.py")):
                 if not build_system or not build_system.get("requires"):
                     build_system = {
-                        "requires": ["setuptools>=38.2.5", "wheel"],
-                        "build-backend": "setuptools.build_meta",
+                        "requires": ["setuptools>=40.8.0", "wheel"],
+                        "build-backend": "setuptools.build_meta:__legacy__",
                     }
                 self._build_system = build_system
 
@@ -603,10 +603,8 @@ class Project(object):
 
     def _get_editable_packages(self, dev=False):
         section = "dev-packages" if dev else "packages"
-        # section = "{0}-editable".format(section)
         packages = {
             k: v
-            # for k, v in self._pipfile[section].items()
             for k, v in self.parsed_pipfile.get(section, {}).items()
             if is_editable(k) or is_editable(v)
         }
@@ -615,10 +613,8 @@ class Project(object):
     def _get_vcs_packages(self, dev=False):
         from pipenv.vendor.requirementslib.utils import is_vcs
         section = "dev-packages" if dev else "packages"
-        # section = "{0}-vcs".format(section)
         packages = {
             k: v
-            # for k, v in self._pipfile[section].items()
             for k, v in self.parsed_pipfile.get(section, {}).items()
             if is_vcs(v) or is_vcs(k)
         }
diff --git a/pipenv/utils.py b/pipenv/utils.py
index d7093495..f2f7704e 100644
--- a/pipenv/utils.py
+++ b/pipenv/utils.py
@@ -3,6 +3,7 @@ import contextlib
 import errno
 import logging
 import os
+import posixpath
 import re
 import shutil
 import stat
@@ -1769,7 +1770,22 @@ def add_to_set(original_set, element):
 
 def is_url_equal(url, other_url):
     # type: (str, str) -> bool
-    """Compare two urls by scheme, host, and path, ignoring auth"""
+    """
+    Compare two urls by scheme, host, and path, ignoring auth
+
+    :param str url: The initial URL to compare
+    :param str url: Second url to compare to the first
+    :return: Whether the URLs are equal without **auth**, **query**, and **fragment**
+    :rtype: bool
+
+    >>> is_url_equal("https://user:pass@mydomain.com/some/path?some_query",
+                     "https://user2:pass2@mydomain.com/some/path")
+    True
+
+    >>> is_url_equal("https://user:pass@mydomain.com/some/path?some_query",
+                 "https://mydomain.com/some?some_query")
+    False
+    """
     if not isinstance(url, six.string_types):
         raise TypeError("Expected string for url, received {0!r}".format(url))
     if not isinstance(other_url, six.string_types):
@@ -1779,3 +1795,28 @@ def is_url_equal(url, other_url):
     unparsed = parsed_url._replace(auth=None, query=None, fragment=None).url
     unparsed_other = parsed_other_url._replace(auth=None, query=None, fragment=None).url
     return unparsed == unparsed_other
+
+
+@lru_cache()
+def make_posix(path):
+    # type: (str) -> str
+    """
+    Convert a path with possible windows-style separators to a posix-style path
+    (with **/** separators instead of **\\** separators).
+
+    :param Text path: A path to convert.
+    :return: A converted posix-style path
+    :rtype: Text
+
+    >>> make_posix("c:/users/user/venvs/some_venv\\Lib\\site-packages")
+    "c:/users/user/venvs/some_venv/Lib/site-packages"
+
+    >>> make_posix("c:\\users\\user\\venvs\\some_venv")
+    "c:/users/user/venvs/some_venv"
+    """
+    if not isinstance(path, six.string_types):
+        raise TypeError("Expected a string for path, received {0!r}...".format(path))
+    separated = normalize_path(path).split(os.path.sep)
+    if isinstance(separated, (list, tuple)):
+        path = posixpath.join(*separated)
+    return path

commit f494571183eaa55da58e27e5881b8299f37e9ccc
Author: Dan Ryan <dan@danryan.co>
Date:   Tue Nov 13 18:07:48 2018 -0500

    Code cleanup -- unused functions
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/_compat.py b/pipenv/_compat.py
index fb2c0147..1dc52d5f 100644
--- a/pipenv/_compat.py
+++ b/pipenv/_compat.py
@@ -4,6 +4,7 @@
 Exposes a standard API that enables compatibility across python versions,
 operating systems, etc.
 """
+
 import functools
 import importlib
 import io
@@ -66,21 +67,10 @@ from vistir.compat import ResourceWarning
 warnings.filterwarnings("ignore", category=ResourceWarning)
 
 
-def pip_import(module_path, subimport=None, old_path=None):
-    internal = "pip._internal.{0}".format(module_path)
-    old_path = old_path or module_path
-    pip9 = "pip.{0}".format(old_path)
-    try:
-        _tmp = importlib.import_module(internal)
-    except ImportError:
-        _tmp = importlib.import_module(pip9)
-    if subimport:
-        return getattr(_tmp, subimport, _tmp)
-    return _tmp
-
-
 class TemporaryDirectory(object):
-    """Create and return a temporary directory.  This has the same
+
+    """
+    Create and return a temporary directory.  This has the same
     behavior as mkdtemp but can be used as a context manager.  For
     example:
 
@@ -146,9 +136,11 @@ def _sanitize_params(prefix, suffix, dir):
 
 
 class _TemporaryFileCloser:
-    """A separate object allowing proper closing of a temporary file's
+    """
+    A separate object allowing proper closing of a temporary file's
     underlying file object, without adding a __del__ method to the
-    temporary file."""
+    temporary file.
+    """
 
     file = None  # Set here since __del__ checks it
     close_called = False
@@ -192,7 +184,9 @@ class _TemporaryFileCloser:
 
 
 class _TemporaryFileWrapper:
-    """Temporary file wrapper
+
+    """
+    Temporary file wrapper
     This class provides a wrapper around files opened for
     temporary use.  In particular, it seeks to automatically
     remove the file when it is no longer needed.
@@ -268,7 +262,8 @@ def NamedTemporaryFile(
     dir=None,
     delete=True,
 ):
-    """Create and return a temporary file.
+    """
+    Create and return a temporary file.
     Arguments:
     'prefix', 'suffix', 'dir' -- as for mkstemp.
     'mode' -- the mode argument to io.open (default "w+b").
diff --git a/pipenv/utils.py b/pipenv/utils.py
index 2f48905a..9f62e2b2 100644
--- a/pipenv/utils.py
+++ b/pipenv/utils.py
@@ -778,13 +778,6 @@ def resolve_deps(
     return results
 
 
-def multi_split(s, split):
-    """Splits on multiple given separators."""
-    for r in split:
-        s = s.replace(r, "|")
-    return [i for i in s.split("|") if len(i) > 0]
-
-
 def is_star(val):
     return isinstance(val, six.string_types) and val == "*"
 
@@ -855,22 +848,6 @@ def is_required_version(version, specified_version):
     return True
 
 
-def strip_ssh_from_git_uri(uri):
-    """Return git+ssh:// formatted URI to git+git@ format"""
-    if isinstance(uri, six.string_types):
-        uri = uri.replace("git+ssh://", "git+")
-    return uri
-
-
-def clean_git_uri(uri):
-    """Cleans VCS uris from pip format"""
-    if isinstance(uri, six.string_types):
-        # Add scheme for parsing purposes, this is also what pip does
-        if uri.startswith("git+") and "://" not in uri:
-            uri = uri.replace("git+", "git+ssh://")
-    return uri
-
-
 def is_editable(pipfile_entry):
     if hasattr(pipfile_entry, "get"):
         return pipfile_entry.get("editable", False) and any(
@@ -1013,94 +990,6 @@ def split_section(input_file, section_suffix, test_function):
     return input_file
 
 
-def split_file(file_dict):
-    """Split VCS and editable dependencies out from file."""
-    from .vendor.requirementslib.utils import is_vcs
-    sections = {
-        "vcs": is_vcs,
-        "editable": lambda x: hasattr(x, "keys") and x.get("editable"),
-    }
-    for k, func in sections.items():
-        file_dict = split_section(file_dict, k, func)
-    return file_dict
-
-
-def merge_deps(
-    file_dict,
-    project,
-    dev=False,
-    requirements=False,
-    ignore_hashes=False,
-    blocking=False,
-    only=False,
-):
-    """
-    Given a file_dict, merges dependencies and converts them to pip dependency lists.
-        :param dict file_dict: The result of calling :func:`pipenv.utils.split_file`
-        :param :class:`pipenv.project.Project` project: Pipenv project
-        :param bool dev=False: Flag indicating whether dev dependencies are to be installed
-        :param bool requirements=False: Flag indicating whether to use a requirements file
-        :param bool ignore_hashes=False:
-        :param bool blocking=False:
-        :param bool only=False:
-        :return: Pip-converted 3-tuples of [deps, requirements_deps]
-    """
-    deps = []
-    requirements_deps = []
-    for section in list(file_dict.keys()):
-        # Turn develop-vcs into ['develop', 'vcs']
-        section_name, suffix = (
-            section.rsplit("-", 1)
-            if "-" in section and not section == "dev-packages"
-            else (section, None)
-        )
-        if not file_dict[section] or section_name not in (
-            "dev-packages",
-            "packages",
-            "default",
-            "develop",
-        ):
-            continue
-
-        is_dev = section_name in ("dev-packages", "develop")
-        if is_dev and not dev:
-            continue
-
-        if ignore_hashes:
-            for k, v in file_dict[section]:
-                if "hash" in v:
-                    del v["hash"]
-        # Block and ignore hashes for all suffixed sections (vcs/editable)
-        no_hashes = True if suffix else ignore_hashes
-        block = True if suffix else blocking
-        include_index = True if not suffix else False
-        converted = convert_deps_to_pip(
-            file_dict[section], project, r=False, include_index=include_index
-        )
-        deps.extend((d, no_hashes, block) for d in converted)
-        if dev and is_dev and requirements:
-            requirements_deps.extend((d, no_hashes, block) for d in converted)
-    return deps, requirements_deps
-
-
-def recase_file(file_dict):
-    """Recase file before writing to output."""
-    if "packages" in file_dict or "dev-packages" in file_dict:
-        sections = ("packages", "dev-packages")
-    elif "default" in file_dict or "develop" in file_dict:
-        sections = ("default", "develop")
-    for section in sections:
-        file_section = file_dict.get(section, {})
-        # Try to properly case each key if we can.
-        for key in list(file_section.keys()):
-            try:
-                cased_key = proper_case(key)
-            except IOError:
-                cased_key = key
-            file_section[cased_key] = file_section.pop(key)
-    return file_dict
-
-
 def get_windows_path(*args):
     """Sanitize a path for windows environments
 
@@ -1355,13 +1244,6 @@ def safe_expandvars(value):
     return value
 
 
-def extract_uri_from_vcs_dep(dep):
-    valid_keys = VCS_LIST + ("uri", "file")
-    if hasattr(dep, "keys"):
-        return first(dep[k] for k in valid_keys if k in dep) or None
-    return None
-
-
 def get_vcs_deps(
     project,
     which=None,
@@ -1570,46 +1452,6 @@ def parse_indexes(line):
     return indexes, trusted_hosts, remainder
 
 
-def fix_venv_site(venv_lib_dir):
-    # From https://github.com/pypa/pip/blob/master/tests/lib/venv.py#L84
-    # Prevent accidental inclusions of site packages during virtualenv operations
-    from .vendor.vistir.compat import Path
-    import compileall
-    site_py = Path(venv_lib_dir).joinpath('site.py').as_posix()
-    with open(site_py) as fp:
-        site_contents = fp.read()
-    for pattern, replace in (
-        (
-            # Ensure enabling user site does not result in adding
-            # the real site-packages' directory to `sys.path`.
-            (
-                '\ndef virtual_addsitepackages(known_paths):\n'
-            ),
-            (
-                '\ndef virtual_addsitepackages(known_paths):\n'
-                '    return known_paths\n'
-            ),
-        ),
-        (
-            # Fix sites ordering: user site must be added before system.
-            (
-                '\n    paths_in_sys = addsitepackages(paths_in_sys)'
-                '\n    paths_in_sys = addusersitepackages(paths_in_sys)\n'
-            ),
-            (
-                '\n    paths_in_sys = addusersitepackages(paths_in_sys)'
-                '\n    paths_in_sys = addsitepackages(paths_in_sys)\n'
-            ),
-        ),
-    ):
-        if pattern in site_contents and replace not in site_contents:
-            site_contents = site_contents.replace(pattern, replace)
-    with open(site_py, 'w') as fp:
-        fp.write(site_contents)
-    # Make sure bytecode is up-to-date too.
-    assert compileall.compile_file(str(site_py), quiet=1, force=True)
-
-
 @contextmanager
 def sys_version(version_tuple):
     """

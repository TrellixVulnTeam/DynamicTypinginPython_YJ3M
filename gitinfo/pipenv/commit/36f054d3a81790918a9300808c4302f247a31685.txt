commit 36f054d3a81790918a9300808c4302f247a31685
Author: Dan Ryan <dan@danryan.co>
Date:   Thu Nov 8 04:47:26 2018 -0500

    Grab updates from latest vendored changes
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/vendor/pythonfinder/__init__.py b/pipenv/vendor/pythonfinder/__init__.py
index 0b22546a..85666b5c 100644
--- a/pipenv/vendor/pythonfinder/__init__.py
+++ b/pipenv/vendor/pythonfinder/__init__.py
@@ -1,6 +1,6 @@
 from __future__ import print_function, absolute_import
 
-__version__ = '1.1.7'
+__version__ = '1.1.8'
 
 # Add NullHandler to "pythonfinder" logger, because Python2's default root
 # logger has no handler and warnings like this would be reported:
diff --git a/pipenv/vendor/pythonfinder/models/pyenv.py b/pipenv/vendor/pythonfinder/models/pyenv.py
index 4a8dfc65..ac7f8588 100644
--- a/pipenv/vendor/pythonfinder/models/pyenv.py
+++ b/pipenv/vendor/pythonfinder/models/pyenv.py
@@ -45,13 +45,16 @@ class PyenvFinder(BaseFinder, BasePath):
         )
 
     def get_version_order(self):
-        version_order_file = self.root.joinpath("version").read_text(encoding="utf-8")
+        version_order_file, version_order_lines = self.root.joinpath("version"), []
+        if version_order_file.exists():
+            version_order_lines = version_order_file.read_text(encoding="utf-8").splitlines()
+
         version_paths = [
             p for p in self.root.glob("versions/*")
             if not (p.parent.name == "envs" or p.name == "envs")
         ]
         versions = {v.name: v for v in version_paths}
-        version_order = [versions[v] for v in version_order_file.splitlines() if v in versions]
+        version_order = [versions[v] for v in version_order_lines if v in versions]
         for version in version_order:
             version_paths.remove(version)
         version_order += version_paths
diff --git a/pipenv/vendor/pythonfinder/models/python.py b/pipenv/vendor/pythonfinder/models/python.py
index ec99afe7..24d520b6 100644
--- a/pipenv/vendor/pythonfinder/models/python.py
+++ b/pipenv/vendor/pythonfinder/models/python.py
@@ -173,7 +173,7 @@ class PythonVersion(object):
     def get_architecture(self):
         if self.architecture:
             return self.architecture
-        arch, _ = platform.architecture(path.path.as_posix())
+        arch, _ = platform.architecture(self.comes_from.path.as_posix())
         self.architecture = arch
         return self.architecture
 
diff --git a/pipenv/vendor/requirementslib/__init__.py b/pipenv/vendor/requirementslib/__init__.py
index ba0ce9ae..edbab5bc 100644
--- a/pipenv/vendor/requirementslib/__init__.py
+++ b/pipenv/vendor/requirementslib/__init__.py
@@ -1,5 +1,5 @@
 # -*- coding=utf-8 -*-
-__version__ = '1.2.5'
+__version__ = '1.2.6'
 
 import logging
 
diff --git a/pipenv/vendor/requirementslib/models/baserequirement.py b/pipenv/vendor/requirementslib/models/baserequirement.py
deleted file mode 100644
index b97dee40..00000000
--- a/pipenv/vendor/requirementslib/models/baserequirement.py
+++ /dev/null
@@ -1,37 +0,0 @@
-# -*- coding: utf-8 -*-
-from __future__ import absolute_import
-import abc
-import attr
-import six
-
-
-@six.add_metaclass(abc.ABCMeta)
-class BaseRequirement:
-    @classmethod
-    def from_line(cls, line):
-        """Returns a requirement from a requirements.txt or pip-compatible line"""
-        raise NotImplementedError
-
-    @abc.abstractmethod
-    def line_part(self):
-        """Returns the current requirement as a pip-compatible line"""
-
-    @classmethod
-    def from_pipfile(cls, name, pipfile):
-        """Returns a requirement from a pipfile entry"""
-        raise NotImplementedError
-
-    @abc.abstractmethod
-    def pipfile_part(self):
-        """Returns the current requirement as a pipfile entry"""
-
-    @classmethod
-    def attr_fields(cls):
-        return [field.name for field in attr.fields(cls)]
-
-    @property
-    def extras_as_pip(self):
-        if self.extras:
-            return "[{0}]".format(",".join(self.extras))
-
-        return ""
diff --git a/pipenv/vendor/requirementslib/models/markers.py b/pipenv/vendor/requirementslib/models/markers.py
index 83b44b63..70fe3bc0 100644
--- a/pipenv/vendor/requirementslib/models/markers.py
+++ b/pipenv/vendor/requirementslib/models/markers.py
@@ -4,12 +4,11 @@ import attr
 from packaging.markers import InvalidMarker, Marker
 
 from ..exceptions import RequirementError
-from .baserequirement import BaseRequirement
 from .utils import filter_none, validate_markers
 
 
 @attr.s
-class PipenvMarkers(BaseRequirement):
+class PipenvMarkers(object):
     """System-level requirements - see PEP508 for more detail"""
 
     os_name = attr.ib(
@@ -78,7 +77,8 @@ class PipenvMarkers(BaseRequirement):
 
     @classmethod
     def from_pipfile(cls, name, pipfile):
-        found_keys = [k for k in pipfile.keys() if k in cls.attr_fields()]
+        attr_fields = [field.name for field in attr.fields(cls)]
+        found_keys = [k for k in pipfile.keys() if k in attr_fields]
         marker_strings = ["{0} {1}".format(k, pipfile[k]) for k in found_keys]
         if pipfile.get("markers"):
             marker_strings.append(pipfile.get("markers"))
diff --git a/pipenv/vendor/requirementslib/models/pipfile.py b/pipenv/vendor/requirementslib/models/pipfile.py
index fe7743c2..58d54055 100644
--- a/pipenv/vendor/requirementslib/models/pipfile.py
+++ b/pipenv/vendor/requirementslib/models/pipfile.py
@@ -38,12 +38,16 @@ class PipfileLoader(plette.pipfiles.Pipfile):
             content = content.decode(encoding)
         _data = tomlkit.loads(content)
         if "source" not in _data:
-            # HACK: There is no good way to prepend a section to an existing
-            # TOML document, but there's no good way to copy non-structural
-            # content from one TOML document to another either. Modify the
-            # TOML content directly, and load the new in-memory document.
-            sep = "" if content.startswith("\n") else "\n"
-            content = plette.pipfiles.DEFAULT_SOURCE_TOML + sep + content
+            if "sources" in _data:
+                _data["source"] = _data["sources"]
+                content = tomlkit.dumps(_data)
+            else:
+                # HACK: There is no good way to prepend a section to an existing
+                # TOML document, but there's no good way to copy non-structural
+                # content from one TOML document to another either. Modify the
+                # TOML content directly, and load the new in-memory document.
+                sep = "" if content.startswith("\n") else "\n"
+                content = plette.pipfiles.DEFAULT_SOURCE_TOML + sep + content
         data = tomlkit.loads(content)
         return cls(data)
 
@@ -53,6 +57,8 @@ class Pipfile(object):
     path = attr.ib(validator=is_path, type=Path)
     projectfile = attr.ib(validator=is_projectfile, type=ProjectFile)
     _pipfile = attr.ib(type=plette.pipfiles.Pipfile)
+    _pyproject = attr.ib(default=attr.Factory(tomlkit.document), type=tomlkit.toml_document.TOMLDocument)
+    build_system = attr.ib(default=attr.Factory(dict), type=dict)
     requirements = attr.ib(default=attr.Factory(list), type=list)
     dev_requirements = attr.ib(default=attr.Factory(list), type=list)
 
@@ -212,3 +218,24 @@ class Pipfile(object):
         if as_requirements:
             return self.requirements
         return self._pipfile.get('packages', {})
+
+    def _read_pyproject(self):
+        pyproject = self.path.parent.joinpath("pyproject.toml")
+        if pyproject.exists():
+            self._pyproject = tomlkit.load(pyproject)
+            build_system = self._pyproject.get("build-system", None)
+            if not os.path.exists(self.path_to("setup.py")):
+                if not build_system or not build_system.get("requires"):
+                    build_system = {
+                        "requires": ["setuptools>=38.2.5", "wheel"],
+                        "build-backend": "setuptools.build_meta",
+                    }
+                self._build_system = build_system
+
+    @property
+    def build_requires(self):
+        return self.build_system.get("requires", [])
+
+    @property
+    def build_backend(self):
+        return self.build_system.get("build-backend", None)
diff --git a/pipenv/vendor/requirementslib/models/requirements.py b/pipenv/vendor/requirementslib/models/requirements.py
index 8d087d23..ce2b0927 100644
--- a/pipenv/vendor/requirementslib/models/requirements.py
+++ b/pipenv/vendor/requirementslib/models/requirements.py
@@ -36,7 +36,6 @@ from ..utils import (
     add_ssh_scheme_to_git_uri,
     strip_ssh_from_git_uri,
 )
-from .baserequirement import BaseRequirement
 from .utils import (
     HASH_STRING,
     build_vcs_link,
@@ -61,7 +60,7 @@ from .utils import (
 
 
 @attr.s(slots=True)
-class NamedRequirement(BaseRequirement):
+class NamedRequirement(object):
     name = attr.ib()
     version = attr.ib(validator=attr.validators.optional(validate_specifiers))
     req = attr.ib()
@@ -98,7 +97,8 @@ class NamedRequirement(BaseRequirement):
     def from_pipfile(cls, name, pipfile):
         creation_args = {}
         if hasattr(pipfile, "keys"):
-            creation_args = {k: v for k, v in pipfile.items() if k in cls.attr_fields()}
+            attr_fields = [field.name for field in attr.fields(cls)]
+            creation_args = {k: v for k, v in pipfile.items() if k in attr_fields}
         creation_args["name"] = name
         version = get_version(pipfile)
         extras = creation_args.get("extras", None)
@@ -131,7 +131,7 @@ LinkInfo = collections.namedtuple(
 
 
 @attr.s(slots=True)
-class FileRequirement(BaseRequirement):
+class FileRequirement(object):
     """File requirements for tar.gz installable files or wheels or setup.py
     containing directories."""
 
@@ -152,6 +152,8 @@ class FileRequirement(BaseRequirement):
     name = attr.ib()
     #: A :class:`~pkg_resources.Requirement` isntance
     req = attr.ib()
+    #: Whether this is a direct url requirement
+    is_direct = attr.ib(default=False)
     _uri_scheme = attr.ib(default=None)
 
     @classmethod
@@ -256,11 +258,17 @@ class FileRequirement(BaseRequirement):
 
         return LinkInfo(vcs_type, prefer, relpath, path, uri, link)
 
+    def __attrs_post_init__(self):
+        if self.req and getattr(self.req, "url"):
+            self.uri = self.req.url
+
     @uri.default
     def get_uri(self):
         if self.path and not self.uri:
             self._uri_scheme = "path"
             self.uri = pip_shims.shims.path_to_url(os.path.abspath(self.path))
+        elif self.req and getattr(self.req, "url"):
+            self.uri = self.req.url
 
     @name.default
     def get_name(self):
@@ -268,6 +276,8 @@ class FileRequirement(BaseRequirement):
         if loc:
             self._uri_scheme = "path" if self.path else "uri"
         name = None
+        if self.req and getattr(self.req, "name"):
+            return self.req.name
         if self.link and self.link.egg_fragment:
             return self.link.egg_fragment
         elif self.link and self.link.is_wheel:
@@ -326,9 +336,18 @@ class FileRequirement(BaseRequirement):
 
     @req.default
     def get_requirement(self):
-        req = init_requirement(normalize_name(self.name))
-        req.editable = False
-        req.line = self.link.url_without_fragment
+        if self.link.is_artifact and not self.editable:
+            if self._uri_scheme == "uri":
+                if self.name:
+                    req_str = "{0} @{1}".format(self.name, self.link.url_without_fragment)
+                else:
+                    req_str = "{0}".format(self.link.url_without_fragment)
+                req = init_requirement(req_str)
+                req.line = req_str
+        else:
+            req = init_requirement(normalize_name(self.name))
+            req.editable = False
+            req.line = self.link.url_without_fragment
         if self.path and self.link and self.link.scheme.startswith("file"):
             req.local_file = True
             req.path = self.path
@@ -337,7 +356,8 @@ class FileRequirement(BaseRequirement):
         else:
             req.local_file = False
             req.path = None
-            req.url = self.link.url_without_fragment
+            if not getattr(req, "url", None):
+                req.url = self.link.url_without_fragment
         if self.editable:
             req.editable = True
         req.link = self.link
@@ -351,9 +371,13 @@ class FileRequirement(BaseRequirement):
                 for scheme in ("http", "https", "ftp", "ftps", "uri")
             )
             and (self.link.is_artifact or self.link.is_wheel)
-            and not self.req.editable
+            and not self.editable
         )
 
+    @property
+    def is_direct_url(self):
+        return self.is_remote_artifact
+
     @property
     def formatted_path(self):
         if self.path:
@@ -371,10 +395,18 @@ class FileRequirement(BaseRequirement):
         editable = line.startswith("-e ")
         line = line.split(" ", 1)[1] if editable else line
         setup_path = None
+        name = None
+        req = None
         if not any([is_installable_file(line), is_valid_url(line), is_file_url(line)]):
-            raise RequirementError(
-                "Supplied requirement is not installable: {0!r}".format(line)
-            )
+            try:
+                req = init_requirement(line)
+            except Exception:
+                raise RequirementError(
+                    "Supplied requirement is not installable: {0!r}".format(line)
+                )
+            else:
+                name = getattr(req, "name", None)
+                line = getattr(req, "url", None)
         vcs_type, prefer, relpath, path, uri, link = cls.get_link_from_line(line)
         setup_path = Path(path) / "setup.py" if path else None
         arg_dict = {
@@ -389,8 +421,12 @@ class FileRequirement(BaseRequirement):
             from pip_shims import Wheel
 
             arg_dict["name"] = Wheel(link.filename).name
+        elif name:
+            arg_dict["name"] = name
         elif link.egg_fragment:
             arg_dict["name"] = link.egg_fragment
+        if req:
+            arg_dict["req"] = req
         created = cls(**arg_dict)
         return created
 
@@ -428,7 +464,9 @@ class FileRequirement(BaseRequirement):
         if not uri:
             uri = pip_shims.shims.path_to_url(path)
         link = create_link(uri)
-
+        req = None
+        if link.is_artifact and not link.is_wheel and not link.scheme.startswith("file"):
+            req = init_requirement("{0}@{1}".format(name, uri))
         arg_dict = {
             "name": name,
             "path": path,
@@ -437,6 +475,8 @@ class FileRequirement(BaseRequirement):
             "link": link,
             "uri_scheme": uri_scheme,
         }
+        if req:
+            arg_dict["req"] = req
         return cls(**arg_dict)
 
     @property
@@ -449,7 +489,10 @@ class FileRequirement(BaseRequirement):
             seed = unquote(self.link.url_without_fragment) or self.uri
         # add egg fragments to remote artifacts (valid urls only)
         if not self._has_hashed_name and self.is_remote_artifact:
-            seed += "#egg={0}".format(self.name)
+            if not self.link.is_wheel and self.link.is_artifact:
+                seed = "{0}@{1}".format(self.name, seed)
+            else:
+                seed += "#egg={0}".format(self.name)
         editable = "-e " if self.editable else ""
         return "{0}{1}".format(editable, seed)
 
@@ -575,7 +618,8 @@ class VCSRequirement(FileRequirement):
             )
         req = init_requirement(canonicalize_name(self.name))
         req.editable = self.editable
-        req.url = self.uri
+        if not getattr(req, "url") and self.uri:
+            req.url = self.uri
         req.line = self.link.url
         if self.ref:
             req.revision = self.ref
@@ -813,7 +857,7 @@ class VCSRequirement(FileRequirement):
 class Requirement(object):
     name = attr.ib()
     vcs = attr.ib(default=None, validator=attr.validators.optional(validate_vcs))
-    req = attr.ib(default=None, validator=optional_instance_of(BaseRequirement))
+    req = attr.ib(default=None)
     markers = attr.ib(default=None)
     specifiers = attr.ib(validator=attr.validators.optional(validate_specifiers))
     index = attr.ib(default=None)
@@ -915,8 +959,11 @@ class Requirement(object):
         # Installable local files and installable non-vcs urls are handled
         # as files, generally speaking
         line_is_vcs = is_vcs(line)
+        # check for pep-508 compatible requirements
+        name, _, possible_url = line.partition("@")
         if is_installable_file(line) or (
-            (is_file_url(line) or is_valid_url(line)) and not line_is_vcs
+            (is_valid_url(possible_url) or is_file_url(line) or is_valid_url(line)) and
+            not (line_is_vcs or is_vcs(possible_url))
         ):
             r = FileRequirement.from_line(line_with_prefix)
         elif line_is_vcs:
diff --git a/pipenv/vendor/requirementslib/models/utils.py b/pipenv/vendor/requirementslib/models/utils.py
index fbaaf1a4..aa7ffd68 100644
--- a/pipenv/vendor/requirementslib/models/utils.py
+++ b/pipenv/vendor/requirementslib/models/utils.py
@@ -424,17 +424,18 @@ def make_install_requirement(name, version, extras, markers, constraint=False):
     """
 
     # If no extras are specified, the extras string is blank
+    from pip_shims.shims import install_req_from_line
     extras_string = ""
     if extras:
         # Sort extras for stability
         extras_string = "[{}]".format(",".join(sorted(extras)))
 
     if not markers:
-        return ireq_from_line(
+        return install_req_from_line(
             str('{}{}=={}'.format(name, extras_string, version)),
             constraint=constraint)
     else:
-        return ireq_from_line(
+        return install_req_from_line(
             str('{}{}=={}; {}'.format(name, extras_string, version, str(markers))),
             constraint=constraint)
 
diff --git a/pipenv/vendor/vistir/spin.py b/pipenv/vendor/vistir/spin.py
index f8c4e009..f0d9e77f 100644
--- a/pipenv/vendor/vistir/spin.py
+++ b/pipenv/vendor/vistir/spin.py
@@ -153,6 +153,7 @@ class VistirSpinner(base_obj):
 
     def ok(self, text="OK"):
         """Set Ok (success) finalizer to a spinner."""
+        # Do not display spin text for ok state
         self._text = None
 
         _text = text if text else "OK"
@@ -160,6 +161,7 @@ class VistirSpinner(base_obj):
 
     def fail(self, text="FAIL"):
         """Set fail finalizer to a spinner."""
+        # Do not display spin text for fail state
         self._text = None
 
         _text = text if text else "FAIL"

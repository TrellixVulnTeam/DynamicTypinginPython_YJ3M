commit 888884653aa343a7029e55db4cc2a7905eea3c69
Author: Dan Ryan <dan@danryan.co>
Date:   Sun Nov 4 01:20:26 2018 -0500

    Refactor Resolver into class and allow CI auto-cache-clear
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/exceptions.py b/pipenv/exceptions.py
index 86643c8a..95feb859 100644
--- a/pipenv/exceptions.py
+++ b/pipenv/exceptions.py
@@ -84,7 +84,7 @@ class PipenvUsageError(UsageError):
         message = formatted_message.format(msg_prefix, crayons.white(message, bold=True))
         self.message = message
         extra = kwargs.pop("extra", [])
-        UsageError.__init__(self, message, ctx)
+        UsageError.__init__(self, fix_utf8(message), ctx)
         self.extra = extra
 
     def show(self, file=None):
@@ -98,8 +98,8 @@ class PipenvUsageError(UsageError):
                 self.extra = [self.extra,]
             for extra in self.extra:
                 if color:
-                    extra = getattr(crayons, color, "normal")
-                click_echo(extra, file=file)
+                    extra = getattr(crayons, color, "blue")(extra)
+                click_echo(fix_utf8(extra), file=file)
         hint = ''
         if (self.cmd is not None and
                 self.cmd.get_help_option(self.ctx) is not None):
@@ -123,7 +123,7 @@ class PipenvFileError(FileError):
             crayons.white("{0} not found!".format(filename), bold=True),
             message
         )
-        FileError.__init__(self, filename=filename, hint=message, **kwargs)
+        FileError.__init__(self, filename=filename, hint=fix_utf8(message), **kwargs)
         self.extra = extra
 
     def show(self, file=None):
@@ -133,20 +133,20 @@ class PipenvFileError(FileError):
             if isinstance(self.extra, six.string_types):
                 self.extra = [self.extra,]
             for extra in self.extra:
-                click_echo(extra, file=file)
+                click_echo(fix_utf8(extra), file=file)
         click_echo(self.message, file=file)
 
 
 class PipfileNotFound(PipenvFileError):
     def __init__(self, filename="Pipfile", extra=None, **kwargs):
         extra = kwargs.pop("extra", [])
-        message = ("{0}. {1}".format(
+        message = ("{0} {1}".format(
                 crayons.red("Aborting!", bold=True),
                 crayons.white("Please ensure that the file exists and is located in your"
                                 " project root directory.", bold=True)
             )
         )
-        super(PipfileNotFound, self).__init__(filename, message=message, extra=extra, **kwargs)
+        super(PipfileNotFound, self).__init__(filename, message=fix_utf8(message), extra=extra, **kwargs)
 
 
 class LockfileNotFound(PipenvFileError):
@@ -157,7 +157,7 @@ class LockfileNotFound(PipenvFileError):
             crayons.red("$ pipenv lock", bold=True),
             crayons.white("before you can continue.", bold=True)
         )
-        super(LockfileNotFound, self).__init__(filename, message=message, extra=extra, **kwargs)
+        super(LockfileNotFound, self).__init__(filename, message=fix_utf8(message), extra=extra, **kwargs)
 
 
 class DeployException(PipenvUsageError):
@@ -165,13 +165,13 @@ class DeployException(PipenvUsageError):
         if not message:
             message = crayons.normal("Aborting deploy", bold=True)
         extra = kwargs.pop("extra", [])
-        PipenvUsageError.__init__(message=message, extra=extra, **kwargs)
+        PipenvUsageError.__init__(message=fix_utf8(message), extra=extra, **kwargs)
 
 
 class PipenvOptionsError(PipenvUsageError):
     def __init__(self, option_name, message=None, ctx=None, **kwargs):
         extra = kwargs.pop("extra", [])
-        PipenvUsageError.__init__(self, message=message, ctx=ctx, **kwargs)
+        PipenvUsageError.__init__(self, message=fix_utf8(message), ctx=ctx, **kwargs)
         self.extra = extra
         self.option_name = option_name
 
@@ -184,7 +184,7 @@ class PipfileException(PipenvFileError):
             hint = "{0} {1}".format(crayons.red("ERROR (PACKAGE NOT INSTALLED):"), hint)
         filename = project.pipfile_location
         extra = kwargs.pop("extra", [])
-        PipenvFileError.__init__(self, filename, hint, extra=extra, **kwargs)
+        PipenvFileError.__init__(self, filename, fix_utf8(hint), extra=extra, **kwargs)
 
 
 class SetupException(PipenvException):
@@ -200,7 +200,7 @@ class VirtualenvException(PipenvException):
                 "There was an unexpected error while activating your virtualenv. "
                 "Continuing anyway..."
             )
-        PipenvException.__init__(self, message, **kwargs)
+        PipenvException.__init__(self, fix_utf8(message), **kwargs)
 
 
 class VirtualenvActivationException(VirtualenvException):
@@ -211,7 +211,7 @@ class VirtualenvActivationException(VirtualenvException):
                 "not activated. Continuing anywayâ€¦"
             )
         self.message = message
-        VirtualenvException.__init__(self, message, **kwargs)
+        VirtualenvException.__init__(self, fix_utf8(message), **kwargs)
 
 
 class VirtualenvCreationException(VirtualenvException):
@@ -219,7 +219,7 @@ class VirtualenvCreationException(VirtualenvException):
         if not message:
             message = "Failed to create virtual environment."
         self.message = message
-        VirtualenvException.__init__(self, message, **kwargs)
+        VirtualenvException.__init__(self, fix_utf8(message), **kwargs)
 
 
 class UninstallError(PipenvException):
@@ -235,5 +235,49 @@ class UninstallError(PipenvException):
             crayons.yellow(package, bold=True)
         )
         self.exit_code = return_code
-        PipenvException.__init__(self, message=message, extra=extra)
+        PipenvException.__init__(self, message=fix_utf8(message), extra=extra)
         self.extra = extra
+
+
+class CacheError(PipenvException):
+    def __init__(self, path, **kwargs):
+        message = "{0} {1} {2}\n{0}".format(
+            crayons.red("ERROR:", bold=True),
+            crayons.blue("Corrupt cache file"),
+            crayons.white(path),
+            crayons.white('Consider trying "pipenv lock --clear" to clear the cache.')
+        )
+        super(PipenvException, self).__init__(message=fix_utf8(message))
+
+
+class ResolutionFailure(PipenvException):
+    def __init__(self, message, no_version_found=False):
+        extra = (
+            "{0}: Your dependencies could not be resolved. You likely have a "
+            "mismatch in your sub-dependencies.\n  "
+            "First try clearing your dependency cache with {1}, then try the original command again.\n "
+            "Alternatively, you can use {2} to bypass this mechanism, then run "
+            "{3} to inspect the situation.\n  "
+            "Hint: try {4} if it is a pre-release dependency."
+            "".format(
+                crayons.red("Warning", bold=True),
+                crayons.red("$ pipenv lock --clear"),
+                crayons.red("$ pipenv install --skip-lock"),
+                crayons.red("$ pipenv graph"),
+                crayons.red("$ pipenv lock --pre"),
+            ),
+        )
+        if "no version found at all" in message:
+            no_version_found = True
+        message = "{0} {1}".format(
+            crayons.red("ERROR:", bold=True), crayons.yellow(message)
+        )
+        if no_version_found:
+            messsage = "{0}\n{1}".format(
+                message,
+                crayons.blue(
+                    "Please check your version specifier and version number. "
+                    "See PEP440 for more information."
+                )
+            )
+        super(ResolutionFailure, self).__init__(fix_utf8(message), extra=extra)
diff --git a/pipenv/utils.py b/pipenv/utils.py
index dd107db0..c0d5a356 100644
--- a/pipenv/utils.py
+++ b/pipenv/utils.py
@@ -201,40 +201,9 @@ def prepare_pip_source_args(sources, pip_args=None):
     return pip_args
 
 
-def actually_resolve_deps(
-    deps,
-    index_lookup,
-    markers_lookup,
-    project,
-    sources,
-    clear,
-    pre,
-    req_dir=None,
-):
-    from .vendor.pip_shims.shims import (
-        Command, parse_requirements, DistributionNotFound
-    )
-    from .vendor.requests.exceptions import HTTPError
-    from pipenv.patched.piptools.resolver import Resolver
-    from pipenv.patched.piptools.repositories.pypi import PyPIRepository
-    from pipenv.patched.piptools.scripts.compile import get_pip_command
-    from pipenv.patched.piptools import logging as piptools_logging
-    from pipenv.patched.piptools.exceptions import NoCandidateFound
+def get_resolver_metadata(deps, index_lookup, markers_lookup, project, sources):
     from .vendor.requirementslib.models.requirements import Requirement
-    from .vendor.vistir.path import (
-        create_tracked_tempdir, create_tracked_tempfile, url_to_path,
-    )
-    from .vendor.vistir.compat import Path, to_native_string
-
-    class PipCommand(Command):
-        """Needed for pip-tools."""
-
-        name = "PipCommand"
-
     constraints = []
-    needs_hash = []
-    if not req_dir:
-        req_dir = create_tracked_tempdir(suffix="-requirements", prefix="pipenv-")
     for dep in deps:
         if not dep:
             continue
@@ -244,11 +213,7 @@ def actually_resolve_deps(
             url = indexes[0]
         dep = " ".join(remainder)
         req = Requirement.from_line(dep)
-        new_ireq = req.as_ireq()
-        if getattr(new_ireq, "link", None) and new_ireq.link.is_wheel and new_ireq.link.scheme == 'file':
-            needs_hash.append(new_ireq)
-
-        # extra_constraints = []
+        constraints.append(req.constraint_line)
 
         if url:
             index_lookup[req.name] = project.get_source(url=url).get("name")
@@ -257,86 +222,218 @@ def actually_resolve_deps(
         # eg pypiwin32
         if req.markers:
             markers_lookup[req.name] = req.markers.replace('"', "'")
-        constraints.append(req.constraint_line)
+    return constraints
+
+
+class Resolver(object):
+    def __init__(self, constraints, req_dir, project, sources, clear=False, pre=False):
+        from pipenv.patched.piptools import logging as piptools_logging
+        if environments.is_verbose():
+            logging.log.verbose = True
+            piptools_logging.log.verbose = True
+        self.initial_constraints = constraints
+        self.req_dir = req_dir
+        self.project = project
+        self.sources = sources
+        self.resolved_tree = set()
+        self.hashes = {}
+        self.clear = clear
+        self.pre = pre
+        self.results = None
+        self._pip_args = None
+        self._constraints = None
+        self._parsed_constraints = None
+        self._resolver = None
+        self._repository = None
+        self._session = None
+        self._constraint_file = None
+        self._pip_options = None
+        self._pip_command = None
+        self._retry_attempts = 0
+
+    def __repr__(self):
+        return (
+            "<Resolver (constraints={self.initial_constraints}, req_dir={self.req_dir}, "
+            "sources={self.sources})>".format(self=self)
+        )
 
-    pip_command = get_pip_command()
-    constraints_file = None
-    pip_args = []
-    if sources:
-        pip_args = prepare_pip_source_args(sources, pip_args)
-    if environments.is_verbose():
-        click_echo(crayons.blue("Using pip: {0}".format(" ".join(pip_args))), err=True)
-    constraints_file = create_tracked_tempfile(
-        mode="w",
-        prefix="pipenv-",
-        suffix="-constraints.txt",
-        dir=req_dir,
-        delete=False,
-    )
-    if sources:
-        requirementstxt_sources = " ".join(pip_args) if pip_args else ""
-        requirementstxt_sources = requirementstxt_sources.replace(" --", "\n--")
-    constraints_file.write(u"{0}\n".format(requirementstxt_sources))
-    constraints_file.write(u"\n".join([_constraint for _constraint in constraints]))
-    constraints_file.close()
-    pip_options, _ = pip_command.parser.parse_args(pip_args)
-    pip_options.cache_dir = environments.PIPENV_CACHE_DIR
-    session = pip_command._build_session(pip_options)
-    pypi = PyPIRepository(pip_options=pip_options, use_json=False, session=session)
-    constraints = parse_requirements(
-        constraints_file.name, finder=pypi.finder, session=pypi.session, options=pip_options
-    )
-    constraints = [c for c in constraints]
-    if environments.is_verbose():
-        logging.log.verbose = True
-        piptools_logging.log.verbose = True
-    resolved_tree = set()
-    resolver = Resolver(
-        constraints=constraints, repository=pypi, clear_caches=clear, prereleases=pre
-    )
-    # pre-resolve instead of iterating to avoid asking pypi for hashes of editable packages
-    hashes = {
-        ireq: pypi._hash_cache.get_hash(ireq.link)
-        for ireq in constraints if (getattr(ireq, "link", None)
-        # We can only hash artifacts, but we don't want normal pypi artifcats since the
-        # normal resolver handles those
-        and ireq.link.is_artifact and not (is_pypi_url(ireq.link.url) or
-        # We also don't want to try to hash directories as this will fail (editable deps)
-        (ireq.link.scheme == "file" and Path(to_native_string(url_to_path(ireq.link.url))).is_dir())))
-    }
-    try:
-        results = resolver.resolve(max_rounds=environments.PIPENV_MAX_ROUNDS)
-        resolved_tree.update(results)
-    except (NoCandidateFound, DistributionNotFound, HTTPError) as e:
-        click_echo(
-            "{0}: Your dependencies could not be resolved. You likely have a "
-            "mismatch in your sub-dependencies.\n  "
-            "First try clearing your dependency cache with {1}, then try the original command again.\n "
-            "Alternatively, you can use {2} to bypass this mechanism, then run "
-            "{3} to inspect the situation.\n  "
-            "Hint: try {4} if it is a pre-release dependency."
-            "".format(
-                crayons.red("Warning", bold=True),
-                crayons.red("$ pipenv lock --clear"),
-                crayons.red("$ pipenv install --skip-lock"),
-                crayons.red("$ pipenv graph"),
-                crayons.red("$ pipenv lock --pre"),
-            ),
-            err=True,
+    def _get_pip_command(self):
+        from pip_shims.shims import Command
+
+        class PipCommand(Command):
+            """Needed for pip-tools."""
+
+            name = "PipCommand"
+
+        from pipenv.patched.piptools.scripts.compile import get_pip_command
+        return get_pip_command()
+
+    @property
+    def pip_command(self):
+        if self._pip_command is None:
+            self._pip_command = self._get_pip_command()
+        return self._pip_command
+
+    def prepare_pip_args(self):
+        pip_args = []
+        if self.sources:
+            pip_args = prepare_pip_source_args(self.sources, pip_args)
+        return pip_args
+
+    @property
+    def pip_args(self):
+        if self._pip_args is None:
+            self._pip_args = self.prepare_pip_args()
+        return self._pip_args
+
+    def prepare_constraint_file(self):
+        from pipenv.vendor.vistir.path import create_tracked_tempfile
+        constraints_file = create_tracked_tempfile(
+            mode="w",
+            prefix="pipenv-",
+            suffix="-constraints.txt",
+            dir=self.req_dir,
+            delete=False,
         )
-        click_echo(crayons.blue(str(e)), err=True)
-        if "no version found at all" in str(e):
+        if self.sources:
+            requirementstxt_sources = " ".join(self.pip_args) if self.pip_args else ""
+            requirementstxt_sources = requirementstxt_sources.replace(" --", "\n--")
+        constraints_file.write(u"{0}\n".format(requirementstxt_sources))
+        constraints = self.initial_constraints
+        constraints_file.write(u"\n".join([c for c in constraints]))
+        constraints_file.close()
+        return constraints_file.name
+
+    @property
+    def constraint_file(self):
+        if self._constraint_file is None:
+            self._constraint_file = self.prepare_constraint_file()
+        return self._constraint_file
+
+    @property
+    def pip_options(self):
+        if self._pip_options is None:
+            pip_options, _ = self.pip_command.parser.parse_args(self.pip_args)
+            pip_options.cache_dir = environments.PIPENV_CACHE_DIR
+            self._pip_options = pip_options
+        if environments.is_verbose():
             click_echo(
-                crayons.blue(
-                    "Please check your version specifier and version number. See PEP440 for more information."
-                ), err=True
+                crayons.blue("Using pip: {0}".format(" ".join(self.pip_args))), err=True
             )
-        raise RuntimeError
-    else:
-        resolved_hashes = resolver.resolve_hashes(results)
-        for ireq, ireq_hashes in resolved_hashes.items():
-            if ireq not in hashes:
-                hashes[ireq] = ireq_hashes
+        return self._pip_options
+
+    @property
+    def session(self):
+        if self._session is None:
+            self._session = self.pip_command._build_session(self.pip_options)
+        return self._session
+
+    @property
+    def repository(self):
+        if self._repository is None:
+            from pipenv.patched.piptools.repositories.pypi import PyPIRepository
+            self._repository = PyPIRepository(
+                pip_options=self.pip_options, use_json=False, session=self.session
+            )
+        return self._repository
+
+    @property
+    def constraints(self):
+        if self._constraints is None:
+            from pip_shims.shims import parse_requirements
+            self._constraints = parse_requirements(
+                self.constraint_file, finder=self.repository.finder, session=self.session,
+                options=self.pip_options
+            )
+        return self._constraints
+
+    @property
+    def parsed_constraints(self):
+        if self._parsed_constraints is None:
+            self._parsed_constraints = [c for c in self.constraints]
+        return self._parsed_constraints
+
+    def get_resolver(self, clear=False, pre=False):
+        from pipenv.patched.piptools.resolver import Resolver
+        self._resolver = Resolver(
+            constraints=self.parsed_constraints, repository=self.repository,
+            clear_caches=clear, prereleases=pre,
+        )
+
+    def populate_file_hashes(self):
+        from pipenv.vendor.vistir.compat import Path, to_native_string
+        from pipenv.vendor.vistir.path import url_to_path
+        self.hashes.update({
+            ireq: self.resolver._hash_cache.get_hash(ireq.link)
+            for ireq in self.parsed_constraints if (getattr(ireq, "link", None)
+            # We can only hash artifacts, but we don't want normal pypi artifcats since the
+            # normal resolver handles those
+            and ireq.link.is_artifact and not (is_pypi_url(ireq.link.url) or (
+                # We also don't want to try to hash directories as this will fail
+                # as these are editable deps and are not hashable
+                ireq.link.scheme == "file" and
+                Path(to_native_string(url_to_path(ireq.link.url))).is_dir()
+            )))
+        })
+
+    @property
+    def resolver(self):
+        if self._resolver is None:
+            self.get_resolver(clear=self.clear, pre=self.pre)
+        return self._resolver
+
+    def resolve(self):
+        from pipenv.vendor.pip_shims.shims import DistributionNotFound
+        from pipenv.vendor.requests.exceptions import HTTPError
+        from pipenv.patched.piptools.exceptions import NoCandidateFound
+        from pipenv.patched.piptools.cache import CorruptCacheError
+        from .exceptions import CacheError, ResolutionFailure
+        try:
+            results = self.resolver.resolve(max_rounds=environments.PIPENV_MAX_ROUNDS)
+        except CorruptCacheError as e:
+            if environments.PIPENV_IS_CI or self.clear:
+                if self._retry_attempts < 3:
+                    self.get_resolver(clear=True, pre=self.pre)
+                    self._retry_attempts += 1
+                    self.resolve()
+            else:
+                raise CacheError(e.path)
+        except (NoCandidateFound, DistributionNotFound, HTTPError) as e:
+            raise ResolutionFailure(message=str(e))
+        else:
+            self.results = results
+            self.resolved_tree.update(results)
+            return self.resolved_tree
+
+    def resolve_hashes(self):
+        if self.results is not None:
+            resolved_hashes = self.resolver.resolve_hashes(self.results)
+            for ireq, ireq_hashes in resolved_hashes.items():
+                if ireq not in self.hashes:
+                    self.hashes[ireq] = ireq_hashes
+            return self.hashes
+
+
+def actually_resolve_deps(
+    deps,
+    index_lookup,
+    markers_lookup,
+    project,
+    sources,
+    clear,
+    pre,
+    req_dir=None,
+):
+    from pipenv.vendor.vistir.path import create_tracked_tempdir
+
+    if not req_dir:
+        req_dir = create_tracked_tempdir(suffix="-requirements", prefix="pipenv-")
+    constraints = get_resolver_metadata(deps, index_lookup, markers_lookup, project,
+                                            sources)
+    resolver = Resolver(constraints, req_dir, project, sources, clear=clear, pre=pre)
+    resolved_tree = resolver.resolve()
+    hashes = resolver.resolve_hashes()
+
     return (resolved_tree, hashes, markers_lookup, resolver)
 
 

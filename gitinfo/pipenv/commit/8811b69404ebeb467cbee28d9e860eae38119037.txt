commit 8811b69404ebeb467cbee28d9e860eae38119037
Author: Dan Ryan <dan@danryan.co>
Date:   Fri Sep 7 01:59:40 2018 -0400

    Vendor yaspin, update vistir, add pip18 patch
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/vendor/vendor.txt b/pipenv/vendor/vendor.txt
index d1667eeb..52d52ec6 100644
--- a/pipenv/vendor/vendor.txt
+++ b/pipenv/vendor/vendor.txt
@@ -41,8 +41,10 @@ semver==2.8.1
 shutilwhich==1.1.0
 toml==0.9.4
 cached-property==1.4.3
-vistir==0.1.4
+vistir==git+https://github.com/sarugaku/vistir.git@e50a767497a059cdd727583448b77c694374fa38#egg=vistir
 pip-shims==0.1.2
     modutil==2.0.0
 ptyprocess==0.6.0
 enum34==1.1.6
+yaspin==0.14.0
+passa==git+https://github.com/sarugaku/passa.git@master#egg=passa
diff --git a/pipenv/vendor/vendor_pip.txt b/pipenv/vendor/vendor_pip.txt
index 3994e709..b9854e9a 100644
--- a/pipenv/vendor/vendor_pip.txt
+++ b/pipenv/vendor/vendor_pip.txt
@@ -1,22 +1,22 @@
 appdirs==1.4.3
 distlib==0.2.7
-distro==1.2.0
+distro==1.3.0
 html5lib==1.0.1
 six==1.11.0
 colorama==0.3.9
-CacheControl==0.12.4
+CacheControl==0.12.5
 msgpack-python==0.5.6
 lockfile==0.12.2
-progress==1.3
-ipaddress==1.0.19  # Only needed on 2.6 and 2.7
+progress==1.4
+ipaddress==1.0.22  # Only needed on 2.6 and 2.7
 packaging==17.1
 pyparsing==2.2.0
-pytoml==0.1.14
+pytoml==0.1.16
 retrying==1.3.3
-requests==2.18.4
+requests==2.19.1
     chardet==3.0.4
-    idna==2.6
-    urllib3==1.22
-    certifi==2018.1.18
-setuptools==39.1.0
+    idna==2.7
+    urllib3==1.23
+    certifi==2018.4.16
+setuptools==39.2.0
 webencodings==0.5.1
diff --git a/pipenv/vendor/vistir/__init__.py b/pipenv/vendor/vistir/__init__.py
index eeb8344c..94079aa5 100644
--- a/pipenv/vendor/vistir/__init__.py
+++ b/pipenv/vendor/vistir/__init__.py
@@ -13,7 +13,7 @@ from .misc import load_path, partialclass, run, shell_escape
 from .path import mkdir_p, rmtree
 
 
-__version__ = '0.1.4'
+__version__ = '0.1.5.dev0'
 
 
 __all__ = [
diff --git a/pipenv/vendor/vistir/misc.py b/pipenv/vendor/vistir/misc.py
index 82bdf5ed..98ebe502 100644
--- a/pipenv/vendor/vistir/misc.py
+++ b/pipenv/vendor/vistir/misc.py
@@ -8,10 +8,13 @@ import subprocess
 import sys
 
 from collections import OrderedDict
+from contextlib import contextmanager
 from functools import partial
 
 import six
 
+from yaspin import yaspin, spinners
+
 from .cmdparse import Script
 from .compat import Path, fs_str, partialmethod
 
@@ -67,37 +70,87 @@ def dedup(iterable):
     return iter(OrderedDict.fromkeys(iterable))
 
 
-def _spawn_subprocess(script, env={}):
+def _spawn_subprocess(script, env={}, block=True, cwd=None):
     from distutils.spawn import find_executable
     command = find_executable(script.command)
     options = {
         "env": env,
         "universal_newlines": True,
         "stdout": subprocess.PIPE,
-        "stderr": subprocess.PIPE,
+        "stderr": subprocess.PIPE if block else subprocess.STDOUT,
+        "stdin": None if block else subprocess.PIPE,
+        "shell": False
     }
+    if cwd:
+        options["cwd"] = cwd
     # Command not found, maybe this is a shell built-in?
+    cmd = [command] + script.args
     if not command:  # Try to use CreateProcess directly if possible.
-        return subprocess.Popen(script.cmdify(), shell=True, **options)
+        cmd = script.cmdify()
+        options["shell"] = True
+
     # Try to use CreateProcess directly if possible. Specifically catch
     # Windows error 193 "Command is not a valid Win32 application" to handle
     # a "command" that is non-executable. See pypa/pipenv#2727.
     try:
-        return subprocess.Popen([command] + script.args, **options)
+        return subprocess.Popen(cmd, **options)
     except WindowsError as e:
         if e.winerror != 193:
             raise
+    options["shell"] = True
     # Try shell mode to use Windows's file association for file launch.
-    return subprocess.Popen(script.cmdify(), shell=True, **options)
+    return subprocess.Popen(script.cmdify(), **options)
 
 
-def run(cmd, env={}, return_object=False):
+def _create_subprocess(cmd, env={}, block=True, return_object=False, cwd=os.curdir, verbose=False, spinner=None):
+    try:
+        c = _spawn_subprocess(cmd, env=env, block=block, cwd=cwd)
+    except Exception as exc:
+        print(
+            "Error %s while executing command %s", exc, " ".join(cmd._parts)
+        )
+        raise
+    if not block:
+        c.stdin.close()
+        output = []
+        if c.stdout is not None:
+            while True:
+                line = to_text(c.stdout.readline())
+                if not line:
+                    break
+                line = line.rstrip()
+                output.append(line)
+                if verbose:
+                    print(line + "\n")
+                elif spinner:
+                    spinner.text = line
+                else:
+                    continue
+        try:
+            c.wait()
+        finally:
+            if c.stdout:
+                c.stdout.close()
+        c.out = "".join(output)
+        c.err = ""
+    else:
+        c.out, c.err = c.communicate()
+    if not return_object:
+        return c.out.strip(), c.err.strip()
+    return c
+
+
+def run(cmd, env={}, return_object=False, block=True, cwd=None, verbose=False, nospin=False,):
     """Use `subprocess.Popen` to get the output of a command and decode it.
 
     :param list cmd: A list representing the command you want to run.
     :param dict env: Additional environment settings to pass through to the subprocess.
     :param bool return_object: When True, returns the whole subprocess instance
-    :returns: A 2-tuple of (output, error)
+    :param bool block: When False, returns a potentially still-running :class:`subprocess.Popen` instance
+    :param str cwd: Current working directory contect to use for spawning the subprocess.
+    :param bool verbose: Whether to print stdout in real time when non-blocking.
+    :param bool nospin: Whether to disable the cli spinner.
+    :returns: A 2-tuple of (output, error) or a :class:`subprocess.Popen` object.
     """
     if six.PY2:
         fs_encode = partial(to_bytes, encoding=locale_encoding)
@@ -113,11 +166,17 @@ def run(cmd, env={}, return_object=False):
             cmd = [c.encode("utf-8") for c in cmd]
     if not isinstance(cmd, Script):
         cmd = Script.parse(cmd)
-    c = _spawn_subprocess(cmd, env=_env)
-    out, err = c.communicate()
-    if not return_object:
-        return out.strip(), err.strip()
-    return c
+    spinner = yaspin
+    if nospin:
+        @contextmanager
+        def spinner(spin_type):
+            class FakeClass(object):
+                def __init__(self):
+                    self.text = ""
+            myobj = FakeClass()
+            yield myobj
+    with spinner(spinners.Spinners.bouncingBar) as sp:
+        return _create_subprocess(cmd, env=_env, return_object=return_object, block=block, cwd=cwd, verbose=verbose, spinner=sp)
 
 
 def load_path(python):
diff --git a/tasks/vendoring/patches/patched/pip18.patch b/tasks/vendoring/patches/patched/pip18.patch
new file mode 100644
index 00000000..bdb82b3c
--- /dev/null
+++ b/tasks/vendoring/patches/patched/pip18.patch
@@ -0,0 +1,495 @@
+diff --git a/pipenv/patched/_internal/download.py b/pipenv/patched/_internal/download.py
+index 96f3b65c..3fb4ebef 100644
+--- a/pipenv/patched/_internal/download.py
++++ b/pipenv/patched/_internal/download.py
+@@ -19,6 +19,7 @@ from pip._vendor.lockfile import LockError
+ from pip._vendor.requests.adapters import BaseAdapter, HTTPAdapter
+ from pip._vendor.requests.auth import AuthBase, HTTPBasicAuth
+ from pip._vendor.requests.models import CONTENT_CHUNK_SIZE, Response
++from pip._vendor.requests.sessions import Session
+ from pip._vendor.requests.structures import CaseInsensitiveDict
+ from pip._vendor.requests.utils import get_netrc_auth
+ # NOTE: XMLRPC Client is not annotated in typeshed as on 2017-07-17, which is
+@@ -69,7 +70,7 @@ def user_agent():
+     Return a string representing the user agent.
+     """
+     data = {
+-        "installer": {"name": "pip", "version": pip.__version__},
++        "installer": {"name": "pip", "version": pipenv.patched.notpip.__version__},
+         "python": platform.python_version(),
+         "implementation": {
+             "name": platform.python_implementation(),
+@@ -322,7 +323,7 @@ class InsecureHTTPAdapter(HTTPAdapter):
+         conn.ca_certs = None
+ 
+ 
+-class PipSession(requests.Session):
++class PipSession(Session):
+ 
+     timeout = None
+ 
+@@ -752,7 +753,7 @@ def _copy_dist_from_dir(link_path, location):
+ 
+     # build an sdist
+     setup_py = 'setup.py'
+-    sdist_args = [sys.executable]
++    sdist_args = [os.environ.get('PIP_PYTHON_PATH', sys.executable)]
+     sdist_args.append('-c')
+     sdist_args.append(SETUPTOOLS_SHIM % setup_py)
+     sdist_args.append('sdist')
+diff --git a/pipenv/patched/_internal/index.py b/pipenv/patched/_internal/index.py
+index 8c0ec82c..ad00ba04 100644
+--- a/pipenv/patched/_internal/index.py
++++ b/pipenv/patched/_internal/index.py
+@@ -58,11 +58,12 @@ logger = logging.getLogger(__name__)
+ 
+ class InstallationCandidate(object):
+ 
+-    def __init__(self, project, version, location):
++    def __init__(self, project, version, location, requires_python=None):
+         self.project = project
+         self.version = parse_version(version)
+         self.location = location
+         self._key = (self.project, self.version, self.location)
++        self.requires_python = requires_python
+ 
+     def __repr__(self):
+         return "<InstallationCandidate({!r}, {!r}, {!r})>".format(
+@@ -168,6 +169,9 @@ class PackageFinder(object):
+         # The Session we'll use to make requests
+         self.session = session
+ 
++        # Kenneth's Hack
++        self.extra = None
++
+         # The valid tags to check potential found wheel candidates against
+         self.valid_tags = get_supported(
+             versions=versions,
+@@ -220,6 +224,24 @@ class PackageFinder(object):
+             )
+             self.dependency_links.extend(links)
+ 
++    @staticmethod
++    def get_extras_links(links):
++        requires = []
++        extras = {}
++
++        current_list = requires
++
++        for link in links:
++            if not link:
++                current_list = requires
++            if link.startswith('['):
++                current_list = []
++                extras[link[1:-1]] = current_list
++            else:
++                current_list.append(link)
++
++        return extras
++
+     @staticmethod
+     def _sort_locations(locations, expand_dir=False):
+         """
+@@ -272,7 +294,7 @@ class PackageFinder(object):
+ 
+         return files, urls
+ 
+-    def _candidate_sort_key(self, candidate):
++    def _candidate_sort_key(self, candidate, ignore_compatibility=False):
+         """
+         Function used to generate link sort key for link tuples.
+         The greater the return value, the more preferred it is.
+@@ -292,14 +314,19 @@ class PackageFinder(object):
+         if candidate.location.is_wheel:
+             # can raise InvalidWheelFilename
+             wheel = Wheel(candidate.location.filename)
+-            if not wheel.supported(self.valid_tags):
++            if not wheel.supported(self.valid_tags) and not ignore_compatibility:
+                 raise UnsupportedWheel(
+                     "%s is not a supported wheel for this platform. It "
+                     "can't be sorted." % wheel.filename
+                 )
+             if self.prefer_binary:
+                 binary_preference = 1
+-            pri = -(wheel.support_index_min(self.valid_tags))
++            tags = self.valid_tags if not ignore_compatibility else None
++            try:
++                pri = -(wheel.support_index_min(tags=tags))
++            except TypeError:
++                pri = -(support_num)
++
+             if wheel.build_tag is not None:
+                 match = re.match(r'^(\d+)(.*)$', wheel.build_tag)
+                 build_tag_groups = match.groups()
+@@ -484,7 +511,7 @@ class PackageFinder(object):
+             dependency_versions
+         )
+ 
+-    def find_requirement(self, req, upgrade):
++    def find_requirement(self, req, upgrade, ignore_compatibility=False):
+         """Try to find a Link matching req
+ 
+         Expects req, an InstallRequirement and upgrade, a boolean
+@@ -594,8 +621,9 @@ class PackageFinder(object):
+                 continue
+             seen.add(location)
+ 
+-            page = self._get_page(location)
+-            if page is None:
++            try:
++                page = self._get_page(location)
++            except requests.HTTPError as e:
+                 continue
+ 
+             yield page
+@@ -631,7 +659,7 @@ class PackageFinder(object):
+             logger.debug('Skipping link %s; %s', link, reason)
+             self.logged_links.add(link)
+ 
+-    def _link_package_versions(self, link, search):
++    def _link_package_versions(self, link, search, ignore_compatibility=True):
+         """Return an InstallationCandidate or None"""
+         version = None
+         if link.egg_fragment:
+@@ -647,12 +675,12 @@ class PackageFinder(object):
+                     link, 'unsupported archive format: %s' % ext,
+                 )
+                 return
+-            if "binary" not in search.formats and ext == wheel_ext:
++            if "binary" not in search.formats and ext == wheel_ext and not ignore_compatibility:
+                 self._log_skipped_link(
+                     link, 'No binaries permitted for %s' % search.supplied,
+                 )
+                 return
+-            if "macosx10" in link.path and ext == '.zip':
++            if "macosx10" in link.path and ext == '.zip' and not ignore_compatibility:
+                 self._log_skipped_link(link, 'macosx10 one')
+                 return
+             if ext == wheel_ext:
+@@ -666,7 +694,7 @@ class PackageFinder(object):
+                         link, 'wrong project name (not %s)' % search.supplied)
+                     return
+ 
+-                if not wheel.supported(self.valid_tags):
++                if not wheel.supported(self.valid_tags) and not ignore_compatibility:
+                     self._log_skipped_link(
+                         link, 'it is not compatible with this Python')
+                     return
+@@ -702,14 +730,14 @@ class PackageFinder(object):
+                          link.filename, link.requires_python)
+             support_this_python = True
+ 
+-        if not support_this_python:
++        if not support_this_python and not ignore_compatibility:
+             logger.debug("The package %s is incompatible with the python"
+                          "version in use. Acceptable python versions are:%s",
+                          link, link.requires_python)
+             return
+         logger.debug('Found link %s, version: %s', link, version)
+ 
+-        return InstallationCandidate(search.supplied, version, link)
++        return InstallationCandidate(search.supplied, version, link, link.requires_python)
+ 
+     def _get_page(self, link):
+         return HTMLPage.get_page(link, session=self.session)
+diff --git a/pipenv/patched/_internal/operations/prepare.py b/pipenv/patched/_internal/operations/prepare.py
+index 7740c284..b6e946d8 100644
+--- a/pipenv/patched/_internal/operations/prepare.py
++++ b/pipenv/patched/_internal/operations/prepare.py
+@@ -17,7 +17,7 @@ from pip._internal.exceptions import (
+ )
+ from pip._internal.utils.hashes import MissingHashes
+ from pip._internal.utils.logging import indent_log
+-from pip._internal.utils.misc import display_path, normalize_path
++from pip._internal.utils.misc import display_path, normalize_path, rmtree
+ from pip._internal.vcs import vcs
+ 
+ logger = logging.getLogger(__name__)
+@@ -123,7 +123,11 @@ class IsSDist(DistAbstraction):
+                 "Installing build dependencies"
+             )
+ 
+-        self.req.run_egg_info()
++        try:
++            self.req.run_egg_info()
++        except (OSError, TypeError):
++            self.req._correct_build_location()
++            self.req.run_egg_info()
+         self.req.assert_source_matches_version()
+ 
+ 
+@@ -205,16 +209,8 @@ class RequirementPreparer(object):
+             # installation.
+             # FIXME: this won't upgrade when there's an existing
+             # package unpacked in `req.source_dir`
+-            # package unpacked in `req.source_dir`
+             if os.path.exists(os.path.join(req.source_dir, 'setup.py')):
+-                raise PreviousBuildDirError(
+-                    "pip can't proceed with requirements '%s' due to a"
+-                    " pre-existing build directory (%s). This is "
+-                    "likely due to a previous installation that failed"
+-                    ". pip is being responsible and not assuming it "
+-                    "can delete this. Please delete it and try again."
+-                    % (req, req.source_dir)
+-                )
++                rmtree(req.source_dir)
+             req.populate_link(finder, upgrade_allowed, require_hashes)
+ 
+             # We can't hit this spot and have populate_link return None.
+diff --git a/pipenv/patched/_internal/pep425tags.py b/pipenv/patched/_internal/pep425tags.py
+index 0b5c7832..bea31585 100644
+--- a/pipenv/patched/_internal/pep425tags.py
++++ b/pipenv/patched/_internal/pep425tags.py
+@@ -10,7 +10,10 @@ import sysconfig
+ import warnings
+ from collections import OrderedDict
+ 
+-import pip._internal.utils.glibc
++try:
++    import pip._internal.utils.glibc
++except ImportError:
++    import pip.utils.glibc
+ 
+ logger = logging.getLogger(__name__)
+ 
+diff --git a/pipenv/patched/_internal/req/req_install.py b/pipenv/patched/_internal/req/req_install.py
+index 462c80aa..d039adc8 100644
+--- a/pipenv/patched/_internal/req/req_install.py
++++ b/pipenv/patched/_internal/req/req_install.py
+@@ -615,7 +615,7 @@ class InstallRequirement(object):
+ 
+         with indent_log():
+             script = SETUPTOOLS_SHIM % self.setup_py
+-            base_cmd = [sys.executable, '-c', script]
++            base_cmd = [os.environ.get('PIP_PYTHON_PATH', sys.executable), '-c', script]
+             if self.isolated:
+                 base_cmd += ["--no-user-cfg"]
+             egg_info_cmd = base_cmd + ['egg_info']
+@@ -797,7 +797,7 @@ class InstallRequirement(object):
+             with self.build_env:
+                 call_subprocess(
+                     [
+-                        sys.executable,
++                        os.environ.get('PIP_PYTHON_PATH', sys.executable),
+                         '-c',
+                         SETUPTOOLS_SHIM % self.setup_py
+                     ] +
+@@ -1015,7 +1015,7 @@ class InstallRequirement(object):
+ 
+     def get_install_args(self, global_options, record_filename, root, prefix,
+                          pycompile):
+-        install_args = [sys.executable, "-u"]
++        install_args = [os.environ.get('PIP_PYTHON_PATH', sys.executable), "-u"]
+         install_args.append('-c')
+         install_args.append(SETUPTOOLS_SHIM % self.setup_py)
+         install_args += list(global_options) + \
+diff --git a/pipenv/patched/_internal/req/req_set.py b/pipenv/patched/_internal/req/req_set.py
+index 2bc6b745..e552afc1 100644
+--- a/pipenv/patched/_internal/req/req_set.py
++++ b/pipenv/patched/_internal/req/req_set.py
+@@ -12,7 +12,7 @@ logger = logging.getLogger(__name__)
+ 
+ class RequirementSet(object):
+ 
+-    def __init__(self, require_hashes=False):
++    def __init__(self, require_hashes=False, ignore_compatibility=True):
+         """Create a RequirementSet.
+         """
+ 
+@@ -24,6 +24,7 @@ class RequirementSet(object):
+         self.unnamed_requirements = []
+         self.successfully_downloaded = []
+         self.reqs_to_cleanup = []
++        self.ignore_compatibility = ignore_compatibility
+ 
+     def __str__(self):
+         reqs = [req for req in self.requirements.values()
+@@ -65,7 +66,7 @@ class RequirementSet(object):
+         # environment markers.
+         if install_req.link and install_req.link.is_wheel:
+             wheel = Wheel(install_req.link.filename)
+-            if not wheel.supported():
++            if not wheel.supported() and not self.ignore_compatibility:
+                 raise InstallationError(
+                     "%s is not a supported wheel on this platform." %
+                     wheel.filename
+@@ -151,7 +152,7 @@ class RequirementSet(object):
+                 return self.requirements[name]
+             if name in self.requirement_aliases:
+                 return self.requirements[self.requirement_aliases[name]]
+-        raise KeyError("No project with the name %r" % project_name)
++        # raise KeyError("No project with the name %r" % project_name)
+ 
+     def cleanup_files(self):
+         """Clean up files, remove builds."""
+diff --git a/pipenv/patched/_internal/resolve.py b/pipenv/patched/_internal/resolve.py
+index 8480e48c..ffc4aa7d 100644
+--- a/pipenv/patched/_internal/resolve.py
++++ b/pipenv/patched/_internal/resolve.py
+@@ -35,7 +35,7 @@ class Resolver(object):
+ 
+     def __init__(self, preparer, session, finder, wheel_cache, use_user_site,
+                  ignore_dependencies, ignore_installed, ignore_requires_python,
+-                 force_reinstall, isolated, upgrade_strategy):
++                 force_reinstall, isolated, upgrade_strategy, ignore_compatibility=False):
+         super(Resolver, self).__init__()
+         assert upgrade_strategy in self._allowed_strategies
+ 
+@@ -55,7 +55,11 @@ class Resolver(object):
+         self.ignore_dependencies = ignore_dependencies
+         self.ignore_installed = ignore_installed
+         self.ignore_requires_python = ignore_requires_python
++        self.ignore_compatibility = ignore_compatibility
+         self.use_user_site = use_user_site
++        self.requires_python = None
++        if self.ignore_compatibility:
++            self.ignore_requires_python = True
+ 
+         self._discovered_dependencies = defaultdict(list)
+ 
+@@ -237,7 +241,7 @@ class Resolver(object):
+ 
+         return abstract_dist
+ 
+-    def _resolve_one(self, requirement_set, req_to_install):
++    def _resolve_one(self, requirement_set, req_to_install, ignore_requires_python=False):
+         """Prepare a single requirements file.
+ 
+         :return: A list of additional InstallRequirements to also install.
+@@ -245,6 +249,9 @@ class Resolver(object):
+         # Tell user what we are doing for this requirement:
+         # obtain (editable), skipping, processing (local url), collecting
+         # (remote url or package name)
++        if ignore_requires_python or self.ignore_requires_python:
++            self.ignore_compatibility = True
++
+         if req_to_install.constraint or req_to_install.prepared:
+             return []
+ 
+@@ -260,11 +267,17 @@ class Resolver(object):
+         try:
+             check_dist_requires_python(dist)
+         except UnsupportedPythonVersion as err:
+-            if self.ignore_requires_python:
++            if self.ignore_compatibility:
+                 logger.warning(err.args[0])
+             else:
+                 raise
+ 
++        # A huge hack, by Kenneth Reitz.
++        try:
++            self.requires_python = check_dist_requires_python(dist, absorb=False)
++        except TypeError:
++            self.requires_python = None
++
+         more_reqs = []
+ 
+         def add_req(subreq, extras_requested):
+@@ -290,10 +303,14 @@ class Resolver(object):
+             # We add req_to_install before its dependencies, so that we
+             # can refer to it when adding dependencies.
+             if not requirement_set.has_requirement(req_to_install.name):
++                available_requested = sorted(
++                    set(dist.extras) & set(req_to_install.extras)
++                )
+                 # 'unnamed' requirements will get added here
+                 req_to_install.is_direct = True
+                 requirement_set.add_requirement(
+                     req_to_install, parent_req_name=None,
++                    extras_requested=available_requested,
+                 )
+ 
+             if not self.ignore_dependencies:
+@@ -317,6 +334,19 @@ class Resolver(object):
+                 for subreq in dist.requires(available_requested):
+                     add_req(subreq, extras_requested=available_requested)
+ 
++                # Hack for deep-resolving extras.
++                for available in available_requested:
++                    if hasattr(dist, '_DistInfoDistribution__dep_map'):
++                        for req in dist._DistInfoDistribution__dep_map[available]:
++                            req = InstallRequirement.from_req(
++                                str(req),
++                                req_to_install,
++                                isolated=self.isolated,
++                                wheel_cache=self.wheel_cache,
++                            )
++
++                            more_reqs.append(req)
++
+             if not req_to_install.editable and not req_to_install.satisfied_by:
+                 # XXX: --no-install leads this to report 'Successfully
+                 # downloaded' for only non-editable reqs, even though we took
+diff --git a/pipenv/patched/_internal/utils/misc.py b/pipenv/patched/_internal/utils/misc.py
+index 3236af63..439a831d 100644
+--- a/pipenv/patched/_internal/utils/misc.py
++++ b/pipenv/patched/_internal/utils/misc.py
+@@ -96,7 +96,7 @@ def get_prog():
+     try:
+         prog = os.path.basename(sys.argv[0])
+         if prog in ('__main__.py', '-c'):
+-            return "%s -m pip" % sys.executable
++            return "%s -m pip" % os.environ.get('PIP_PYTHON_PATH', sys.executable)
+         else:
+             return prog
+     except (AttributeError, TypeError, IndexError):
+diff --git a/pipenv/patched/_internal/utils/packaging.py b/pipenv/patched/_internal/utils/packaging.py
+index 5f9bb93d..276a9ccc 100644
+--- a/pipenv/patched/_internal/utils/packaging.py
++++ b/pipenv/patched/_internal/utils/packaging.py
+@@ -28,7 +28,7 @@ def check_requires_python(requires_python):
+     requires_python_specifier = specifiers.SpecifierSet(requires_python)
+ 
+     # We only use major.minor.micro
+-    python_version = version.parse('.'.join(map(str, sys.version_info[:3])))
++    python_version = version.parse('{0}.{1}.{2}'.format(*sys.version_info[:3]))
+     return python_version in requires_python_specifier
+ 
+ 
+@@ -40,20 +40,17 @@ def get_metadata(dist):
+         return dist.get_metadata('PKG-INFO')
+ 
+ 
+-def check_dist_requires_python(dist):
++def check_dist_requires_python(dist, absorb=True):
+     metadata = get_metadata(dist)
+     feed_parser = FeedParser()
+     feed_parser.feed(metadata)
+     pkg_info_dict = feed_parser.close()
+     requires_python = pkg_info_dict.get('Requires-Python')
++    if not absorb:
++        return requires_python
+     try:
+         if not check_requires_python(requires_python):
+-            raise exceptions.UnsupportedPythonVersion(
+-                "%s requires Python '%s' but the running Python is %s" % (
+-                    dist.project_name,
+-                    requires_python,
+-                    '.'.join(map(str, sys.version_info[:3])),)
+-            )
++            return requires_python
+     except specifiers.InvalidSpecifier as e:
+         logger.warning(
+             "Package %s has an invalid Requires-Python entry %s - %s",
+diff --git a/pipenv/patched/_internal/wheel.py b/pipenv/patched/_internal/wheel.py
+index fcf9d3d3..d8aff848 100644
+--- a/pipenv/patched/_internal/wheel.py
++++ b/pipenv/patched/_internal/wheel.py
+@@ -83,7 +83,7 @@ def fix_script(path):
+             firstline = script.readline()
+             if not firstline.startswith(b'#!python'):
+                 return False
+-            exename = sys.executable.encode(sys.getfilesystemencoding())
++            exename = os.environ.get('PIP_PYTHON_PATH', sys.executable).encode(sys.getfilesystemencoding())
+             firstline = b'#!' + exename + os.linesep.encode("ascii")
+             rest = script.read()
+         with open(path, 'wb') as script:
+@@ -665,7 +665,7 @@ class WheelBuilder(object):
+         # relies on site.py to find parts of the standard library outside the
+         # virtualenv.
+         return [
+-            sys.executable, '-u', '-c',
++            os.environ.get('PIP_PYTHON_PATH', sys.executable), '-u', '-c',
+             SETUPTOOLS_SHIM % req.setup_py
+         ] + list(self.global_options)
+ 

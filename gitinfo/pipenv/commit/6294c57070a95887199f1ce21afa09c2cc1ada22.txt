commit 6294c57070a95887199f1ce21afa09c2cc1ada22
Author: Dan Ryan <dan@danryan.co>
Date:   Thu Oct 25 01:23:41 2018 -0400

    Update pythonfinder
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    More debugging info
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    Fix stdout write bugs
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    Fix spinner invocations
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    Create missing directory
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    Filesystem encode envvars
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    convert envvars to strings
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    Update encodings
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    Update vistir to init colorama
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    Update vistir version number
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    add some debugging and vsts changes
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    fix delegator mod
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    Log to stderr so we can see it
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    Log to stderr so we can see it
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    Try importing colorama...
    
    Signed-off-by: Dan Ryan <dan@danryan.co>
    
    change variable setting syntax
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/.vsts-ci/phases/run-tests.yml b/.vsts-ci/phases/run-tests.yml
index 81f02875..daf23e6a 100644
--- a/.vsts-ci/phases/run-tests.yml
+++ b/.vsts-ci/phases/run-tests.yml
@@ -11,8 +11,8 @@ steps:
    mkdir -p "$AGENT_HOMEDIRECTORY/.virtualenvs"
    mkdir -p "$WORKON_HOME"
    pip install certifi
-   export GIT_SSL_CAINFO=$(python -m certifi)
-   export LANG=C.UTF-8
+   export GIT_SSL_CAINFO="$(python -m certifi)"
+   export LANG="C.UTF-8"
    export PIP_PROCESS_DEPENDENCY_LINKS="1"
    echo "Path: $PATH"
    echo "Installing Pipenv…"
@@ -23,8 +23,8 @@ steps:
 
 - script: |
     # Fix Git SSL errors
-    export GIT_SSL_CAINFO=$(python -m certifi)
-    export LANG=C.UTF-8
+    export GIT_SSL_CAINFO="$(python -m certifi)"
+    export LANG="C.UTF-8"
     export PIP_PROCESS_DEPENDENCY_LINKS="1"
     pipenv run pytest --junitxml=test-results.xml
   displayName: Run integration tests
diff --git a/.vsts-ci/steps/run-tests.yml b/.vsts-ci/steps/run-tests.yml
index cb24b092..d893ccf9 100644
--- a/.vsts-ci/steps/run-tests.yml
+++ b/.vsts-ci/steps/run-tests.yml
@@ -3,13 +3,14 @@ steps:
     # Fix Git SSL errors
     pip install certifi
     python -m certifi > cacert.txt
-    $env:GIT_SSL_CAINFO = $(Get-Content cacert.txt)
+    Write-Host "##vso[task.setvariable variable=GIT_SSL_CAINFO]"$(Get-Content cacert.txt)"
     # Shorten paths to get under MAX_PATH or else integration tests will fail
     # https://bugs.python.org/issue18199
-    subst T: $env:TEMP
-    $env:TEMP = "T:\"
-    $env:TMP = "T:\"
-    D:\.venv\Scripts\pipenv run pytest -n 4 --ignore=pipenv\patched --ignore=pipenv\vendor --junitxml=test-results.xml tests
+    subst T: "$env:TEMP"
+    Write-Host "##vso[task.setvariable variable=TEMP]"T:\"
+    Write-Host "##vso[task.setvariable variable=TMP]"T:\"
+    Get-ChildItem Env
+    D:\.venv\Scripts\pipenv run pytest -n 4 -ra --ignore=pipenv\patched --ignore=pipenv\vendor --junitxml=test-results.xml tests
   displayName: Run integration tests
 
 - task: PublishTestResults@2
diff --git a/pipenv/__init__.py b/pipenv/__init__.py
index 1fea44d5..8c6cec19 100644
--- a/pipenv/__init__.py
+++ b/pipenv/__init__.py
@@ -6,7 +6,6 @@ import os
 import sys
 from .__version__ import __version__
 
-
 PIPENV_ROOT = os.path.dirname(os.path.realpath(__file__))
 PIPENV_VENDOR = os.sep.join([PIPENV_ROOT, "vendor"])
 PIPENV_PATCHED = os.sep.join([PIPENV_ROOT, "patched"])
@@ -14,7 +13,8 @@ PIPENV_PATCHED = os.sep.join([PIPENV_ROOT, "patched"])
 sys.path.insert(0, PIPENV_VENDOR)
 # Inject patched directory into system path.
 sys.path.insert(0, PIPENV_PATCHED)
-os.environ["PIP_DISABLE_PIP_VERSION_CHECK"] = "1"
+from vistir.compat import fs_str
+os.environ["PIP_DISABLE_PIP_VERSION_CHECK"] = fs_str("1")
 # Hack to make things work better.
 try:
     if "concurrency" in sys.modules:
diff --git a/pipenv/core.py b/pipenv/core.py
index 82c11f1d..64f486d7 100644
--- a/pipenv/core.py
+++ b/pipenv/core.py
@@ -17,6 +17,7 @@ import warnings
 import six
 
 import urllib3.util as urllib3_util
+from functools import partial
 
 from .cmdparse import Script
 from .project import Project, SourceNotFound
@@ -110,7 +111,7 @@ def fix_utf8(text):
 
 
 @contextlib.contextmanager
-def spinner(text=None, nospin=None, spinner_name=None):
+def _spinner(text=None, nospin=None, spinner_name=None):
     if not text:
         text = "Running..."
     if not spinner_name:
@@ -125,6 +126,10 @@ def spinner(text=None, nospin=None, spinner_name=None):
         yield sp
 
 
+spinner = partial(_spinner, text="Running...", nospin=environments.PIPENV_NOSPIN,
+                        spinner_name=environments.PIPENV_SPINNER)
+
+
 def which(command, location=None, allow_global=False):
     if not allow_global and location is None:
         if project.virtualenv_exists:
@@ -322,9 +327,16 @@ def ensure_pipfile(validate=True, skip_requirements=False, system=False):
             )
             # Create a Pipfile…
             project.create_pipfile(python=python)
-            with spinner():
+            with spinner(text=vistir.compat.fs_str("Importing requirements..."),
+                    spinner_name=environments.PIPENV_SPINNER,
+                    nospin=environments.PIPENV_NOSPIN) as sp:
                 # Import requirements.txt.
-                import_requirements()
+                try:
+                    import_requirements()
+                except Exception:
+                    sp.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format("Failed..."))
+                else:
+                    sp.ok(environments.PIPENV_SPINNER_FAIL_TEXT.format("Success!"))
             # Warn the user of side-effects.
             click.echo(
                 u"{0}: Your {1} now contains pinned versions, if your {2} did. \n"
@@ -467,14 +479,21 @@ def ensure_python(three=None, python=None):
                             crayons.normal(fix_utf8("…"), bold=True),
                         )
                     )
-                    with spinner():
+                    with spinner(text=vistir.compat.fs_str("Installing python..."),
+                                    spinner_name=environments.PIPENV_SPINNER,
+                                    nospin=environments.PIPENV_NOSPIN) as sp:
                         try:
                             c = pyenv.install(version)
                         except PyenvError as e:
-                            click.echo(fix_utf8("Something went wrong…"))
+                            sp.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(
+                                "Failed...")
+                            )
+                            click.echo(fix_utf8("Something went wrong…"), err=True)
                             click.echo(crayons.blue(e.err), err=True)
+                        else:
+                            environments.PIPENV_SPINNER_OK_TEXT.format("Success!")
                         # Print the results, in a beautiful blue…
-                        click.echo(crayons.blue(c.out), err=True)
+                            click.echo(crayons.blue(c.out), err=True)
                     # Find the newly installed Python, hopefully.
                     version = str(version)
                     path_to_python = find_a_system_python(version)
@@ -756,7 +775,6 @@ def do_install_dependencies(
 
     deps_list_bar = progress.bar(deps_list, width=32,
                                     label=INSTALL_LABEL if os.name != "nt" else "")
-
     indexes = []
     for dep in deps_list_bar:
         index = None
@@ -845,13 +863,14 @@ def do_install_dependencies(
                     # Return the subprocess' return code.
                     sys.exit(c.return_code)
                 else:
-                    click.echo(
-                        "{0} {1}{2}".format(
-                            crayons.green("Success installing"),
-                            crayons.green(dep.name),
-                            crayons.green("!"),
+                    if environments.is_verbose():
+                        click.echo(
+                            "{0} {1}{2}".format(
+                                crayons.green("Success installing"),
+                                crayons.green(dep.as_line(include_hashes=False)),
+                                crayons.green("!"),
+                            ),
                         )
-                    )
 
 
 def convert_three_to_python(three, python):
@@ -1014,9 +1033,6 @@ def do_lock(
         if dev_package in project.packages:
             dev_packages[dev_package] = project.packages[dev_package]
     # Resolve dev-package dependencies, with pip-tools.
-    pip_freeze = delegator.run(
-        "{0} freeze".format(escape_grouped_arguments(which_pip(allow_global=system)))
-    ).out
     sections = {
         "dev": {
             "packages": project.dev_packages,
@@ -1072,7 +1088,6 @@ def do_lock(
         # TODO: be smarter about this.
         vcs_reqs, vcs_lockfile = get_vcs_deps(
             project,
-            pip_freeze,
             which=which,
             clear=clear,
             pre=pre,
@@ -2185,6 +2200,10 @@ def _launch_windows_subprocess(script):
 
     command = system_which(script.command)
     options = {"universal_newlines": True}
+    env_strings = [
+        vistir.compat.to_native_string("{0}: {1}".format(k, v)) for k, v in os.environ.items()
+    ]
+    click.echo(vistir.compat.to_native_string("\n".join(env_strings)), err=True)
 
     # Command not found, maybe this is a shell built-in?
     if not command:
@@ -2204,6 +2223,7 @@ def _launch_windows_subprocess(script):
 
 
 def do_run_nt(script):
+    os.environ = {k: vistir.compat.fs_str(val) for k, val in os.environ.items()}
     p = _launch_windows_subprocess(script)
     p.communicate()
     sys.exit(p.returncode)
diff --git a/pipenv/resolver.py b/pipenv/resolver.py
index 2854a93a..b82088a2 100644
--- a/pipenv/resolver.py
+++ b/pipenv/resolver.py
@@ -3,7 +3,7 @@ import sys
 import json
 import logging
 
-os.environ["PIP_PYTHON_PATH"] = sys.executable
+os.environ["PIP_PYTHON_PATH"] = str(sys.executable)
 
 
 def _patch_path():
@@ -17,7 +17,7 @@ def _patch_path():
 
 def get_parser():
     from argparse import ArgumentParser
-    parser = ArgumentParser("pipenvresolver")
+    parser = ArgumentParser("pipenv-resolver")
     parser.add_argument("--pre", action="store_true", default=False)
     parser.add_argument("--clear", action="store_true", default=False)
     parser.add_argument("--verbose", "-v", action="count", default=False)
@@ -41,17 +41,13 @@ def handle_parsed_args(parsed):
     elif parsed.verbose > 0:
         logging.getLogger("notpip").setLevel(logging.INFO)
     if "PIPENV_PACKAGES" in os.environ:
-        parsed.packages += os.environ["PIPENV_PACKAGES"].strip().split("\n")
+        parsed.packages += os.environ.get("PIPENV_PACKAGES", "").strip().split("\n")
     return parsed
 
 
-def main(pre, clear, verbose, system, requirements_dir, packages):
+def _main(pre, clear, verbose, system, requirements_dir, packages):
     os.environ["PIP_PYTHON_VERSION"] = ".".join([str(s) for s in sys.version_info[:3]])
-    os.environ["PIP_PYTHON_PATH"] = sys.executable
-
-    import warnings
-    from pipenv.vendor.vistir.compat import ResourceWarning
-    warnings.filterwarnings("ignore", category=ResourceWarning)
+    os.environ["PIP_PYTHON_PATH"] = str(sys.executable)
 
     from pipenv.utils import create_mirror_source, resolve_deps, replace_pypi_sources
 
@@ -91,22 +87,27 @@ def main(pre, clear, verbose, system, requirements_dir, packages):
     )
     print("RESULTS:")
     if results:
-        import traceback
-        if isinstance(results, (Exception, traceback.types.TracebackType)):
-            sys.stderr.write(traceback.print_tb(results))
-            sys.stderr.write(sys.exc_value())
-        else:
-            print(json.dumps(results))
+        print(json.dumps(results))
     else:
         print(json.dumps([]))
 
 
-if __name__ == "__main__":
-    os.environ["PIP_DISABLE_PIP_VERSION_CHECK"] = "1"
+def main():
     _patch_path()
+    import warnings
+    from pipenv.vendor.vistir.compat import ResourceWarning
+    warnings.simplefilter("ignore", category=ResourceWarning)
+    from pipenv.vendor import colorama
+    colorama.init()
+    os.environ["PIP_DISABLE_PIP_VERSION_CHECK"] = str("1")
     parser = get_parser()
-    parsed, remaining = parser.parse_known_intermixed_args()
-    sys.argv = remaining
+    parsed, remaining = parser.parse_known_args()
+    # sys.argv = remaining
     parsed = handle_parsed_args(parsed)
-    main(parsed.pre, parsed.clear, parsed.verbose, parsed.system, parsed.requirements_dir,
+    _main(parsed.pre, parsed.clear, parsed.verbose, parsed.system, parsed.requirements_dir,
             parsed.packages)
+
+
+if __name__ == "__main__":
+    _patch_path()
+    main()
diff --git a/pipenv/test_script.py b/pipenv/test_script.py
new file mode 100644
index 00000000..d599ded6
--- /dev/null
+++ b/pipenv/test_script.py
@@ -0,0 +1,32 @@
+# -*- coding=utf-8 -*-
+
+import os
+import sys
+
+
+def _patch_path():
+    import site
+    pipenv_libdir = os.path.dirname(os.path.abspath(__file__))
+    pipenv_site_dir = os.path.dirname(pipenv_libdir)
+    site.addsitedir(pipenv_site_dir)
+    for _dir in ("vendor", "patched"):
+        sys.path.insert(0, os.path.join(pipenv_libdir, _dir))
+
+
+def test_install():
+    from pipenv.vendor.vistir.contextmanagers import cd
+    from pipenv.vendor.click.testing import CliRunner
+    runner = CliRunner()
+    with cd("/tmp/test"):
+        from pipenv.core import do_lock
+        locked = do_lock(system=False, clear=False, pre=False, keep_outdated=False,
+                            write=True, pypi_mirror=None)
+        # result = runner.invoke(cli, ["lock", "--verbose"])
+        # print(result.output)
+        # print(result.exit_code)
+        print(locked)
+
+
+if __name__ == "__main__":
+    _patch_path()
+    test_install()
diff --git a/pipenv/utils.py b/pipenv/utils.py
index d8f2432b..7c78de34 100644
--- a/pipenv/utils.py
+++ b/pipenv/utils.py
@@ -258,7 +258,7 @@ def actually_resolve_deps(
     if sources:
         pip_args = prepare_pip_source_args(sources, pip_args)
     if environments.is_verbose():
-        click_echo(crayons.blue("Using pip: {0}".format(" ".join(pip_args))))
+        click_echo(crayons.blue("Using pip: {0}".format(" ".join(pip_args))), err=True)
     constraints_file = create_tracked_tempfile(
         mode="w",
         prefix="pipenv-",
@@ -315,7 +315,7 @@ def actually_resolve_deps(
             click_echo(
                 crayons.blue(
                     "Please check your version specifier and version number. See PEP440 for more information."
-                )
+                ), err=True
             )
         raise RuntimeError
     return (resolved_tree, hashes, markers_lookup, resolver)
@@ -330,12 +330,12 @@ def venv_resolve_deps(
     allow_global=False,
     pypi_mirror=None,
 ):
-    from .vendor.vistir.misc import fs_str, run
-    from .vendor.vistir.compat import Path
+    from .vendor.vistir.misc import fs_str
+    from .vendor.vistir.compat import Path, to_native_string
     from .vendor.vistir.path import create_tracked_tempdir
     from .cmdparse import Script
     from .core import spinner
-    from .vendor.pexpect.exceptions import EOF
+    from .vendor.pexpect.exceptions import EOF, TIMEOUT
     from .vendor import delegator
     from . import resolver
     import json
@@ -364,26 +364,36 @@ def venv_resolve_deps(
         os.environ["PIPENV_REQ_DIR"] = fs_str(req_dir)
         os.environ["PIP_NO_INPUT"] = fs_str("1")
 
-        out = ""
+        out = to_native_string("")
         EOF.__module__ = "pexpect.exceptions"
         with spinner(text=fs_str("Locking..."), spinner_name=environments.PIPENV_SPINNER,
                 nospin=environments.PIPENV_NOSPIN) as sp:
             c = delegator.run(Script.parse(cmd).cmdify(), block=False, env=os.environ.copy())
-            _out = u""
+            _out = to_native_string("")
+            result = None
             while True:
-                result = c.expect(u"\n", timeout=-1)
-                if result is EOF or result is None:
+                try:
+                    result = c.expect(u"\n", timeout=-1)
+                except (EOF, TIMEOUT):
+                    pass
+                if result is None:
                     break
-                _out = c.out
-                out += _out
-                sp.text = fs_str("Locking... {0}".format(_out[:100]))
+                _out = c.subprocess.before
+                if _out is not None:
+                    _out = to_native_string("{0}".format(_out))
+                    out += _out
+                    sp.text = to_native_string("Locking... {0}".format(_out[:100]))
             if environments.is_verbose():
-                sp.write_err(_out.rstrip())
+                if _out is not None:
+                    sp._hide_cursor()
+                    sp.write(_out.rstrip())
+                    sp._show_cursor()
             c.block()
             if c.return_code != 0:
                 sp.red.fail(environments.PIPENV_SPINNER_FAIL_TEXT.format(
                     "Locking Failed!"
                 ))
+                click_echo(c.out.strip(), err=True)
                 click_echo(c.err.strip(), err=True)
                 sys.exit(c.return_code)
             else:
@@ -394,7 +404,7 @@ def venv_resolve_deps(
         return json.loads(c.out.split("RESULTS:")[1].strip())
 
     except IndexError:
-        click_echo(c.out.strip())
+        click_echo(c.out.strip(), err=True)
         click_echo(c.err.strip(), err=True)
         raise RuntimeError("There was a problem with locking.")
 
@@ -496,7 +506,7 @@ def resolve_deps(
                         click_echo(
                             "{0}: Error generating hash for {1}".format(
                                 crayons.red("Warning", bold=True), name
-                            )
+                            ), err=True
                         )
             # # Collect un-collectable hashes (should work with devpi).
             # try:
@@ -1088,7 +1098,6 @@ def extract_uri_from_vcs_dep(dep):
 
 def get_vcs_deps(
     project,
-    pip_freeze=None,
     which=None,
     clear=False,
     pre=False,
diff --git a/pipenv/vendor/backports/shutil_get_terminal_size/__init__.py b/pipenv/vendor/backports/shutil_get_terminal_size/__init__.py
index fa12816e..cfcbdf66 100644
--- a/pipenv/vendor/backports/shutil_get_terminal_size/__init__.py
+++ b/pipenv/vendor/backports/shutil_get_terminal_size/__init__.py
@@ -1,9 +1,11 @@
-__title__ = "shutil_backports"
-__version__ = "0.1.0"
+"""A backport of the get_terminal_size function from Python 3.3's shutil."""
+
+__title__ = "backports.shutil_get_terminal_size"
+__version__ = "1.0.0"
 __license__ = "MIT"
 __author__ = "Christopher Rosell"
 __copyright__ = "Copyright 2014 Christopher Rosell"
 
 __all__ = ["get_terminal_size"]
 
-from .get_terminal_size import *
+from .get_terminal_size import get_terminal_size
diff --git a/pipenv/vendor/backports/shutil_get_terminal_size/get_terminal_size.py b/pipenv/vendor/backports/shutil_get_terminal_size/get_terminal_size.py
index f1336e58..28c96da8 100644
--- a/pipenv/vendor/backports/shutil_get_terminal_size/get_terminal_size.py
+++ b/pipenv/vendor/backports/shutil_get_terminal_size/get_terminal_size.py
@@ -39,7 +39,7 @@ try:
         except Exception:
             pass
 
-        return columns, lines
+        return terminal_size(columns, lines)
 
 except ImportError:
     import fcntl
@@ -52,7 +52,7 @@ except ImportError:
         except Exception:
             columns = lines = 0
 
-        return columns, lines
+        return terminal_size(columns, lines)
 
 
 def get_terminal_size(fallback=(80, 24)):
@@ -74,7 +74,7 @@ def get_terminal_size(fallback=(80, 24)):
 
     The value returned is a named tuple of type os.terminal_size.
     """
-    # Attempt to use the environment first
+    # Try the environment first
     try:
         columns = int(os.environ["COLUMNS"])
     except (KeyError, ValueError):
@@ -88,13 +88,14 @@ def get_terminal_size(fallback=(80, 24)):
     # Only query if necessary
     if columns <= 0 or lines <= 0:
         try:
-            columns, lines = _get_terminal_size(sys.__stdout__.fileno())
+            size = _get_terminal_size(sys.__stdout__.fileno())
         except (NameError, OSError):
-            pass
+            size = terminal_size(*fallback)
 
-    # Use fallback as last resort
-    if columns <= 0 and lines <= 0:
-        columns, lines = fallback
+        if columns <= 0:
+            columns = size.columns
+        if lines <= 0:
+            lines = size.lines
 
     return terminal_size(columns, lines)
 
diff --git a/pipenv/vendor/delegator.py b/pipenv/vendor/delegator.py
index 56d12458..cf6f91c8 100644
--- a/pipenv/vendor/delegator.py
+++ b/pipenv/vendor/delegator.py
@@ -113,7 +113,10 @@ class Command(object):
             result += self.subprocess.before
 
         if self.subprocess.after and self.subprocess.after is not pexpect.EOF:
-            result += self.subprocess.after
+            try:
+                result += self.subprocess.after
+            except (pexpect.EOF, pexpect.TIMEOUT):
+                pass
 
         result += self.subprocess.read()
         return result
diff --git a/pipenv/vendor/dotenv/main.py b/pipenv/vendor/dotenv/main.py
index 6ba28bbb..4bf72946 100644
--- a/pipenv/vendor/dotenv/main.py
+++ b/pipenv/vendor/dotenv/main.py
@@ -95,13 +95,6 @@ class DotEnv():
         for k, v in self.dict().items():
             if k in os.environ and not override:
                 continue
-            # With Python 2 on Windows, ensuree environment variables are
-            # system strings to avoid "TypeError: environment can only contain
-            # strings" in Python's subprocess module.
-            if sys.version_info.major < 3 and sys.platform == 'win32':
-                from pipenv.utils import fs_str
-                k = fs_str(k)
-                v = fs_str(v)
             os.environ[k] = v
 
         return True
diff --git a/pipenv/vendor/passa/internals/dependencies.py b/pipenv/vendor/passa/internals/dependencies.py
index 53b19b17..6ce97aad 100644
--- a/pipenv/vendor/passa/internals/dependencies.py
+++ b/pipenv/vendor/passa/internals/dependencies.py
@@ -154,6 +154,7 @@ def _get_dependencies_from_json(ireq, sources):
                 return dependencies
         except Exception as e:
             print("unable to read dependencies via {0} ({1})".format(url, e))
+    session.close()
     return
 
 
@@ -215,7 +216,7 @@ def _read_requires_python(metadata):
 
 
 def _get_dependencies_from_pip(ireq, sources):
-    """Retrieves dependencies for the requirement from pipenv.patched.notpip internals.
+    """Retrieves dependencies for the requirement from pip internals.
 
     The current strategy is to try the followings in order, returning the
     first successful result.
diff --git a/pipenv/vendor/pythonfinder/__init__.py b/pipenv/vendor/pythonfinder/__init__.py
index 91e9cabb..d800f926 100644
--- a/pipenv/vendor/pythonfinder/__init__.py
+++ b/pipenv/vendor/pythonfinder/__init__.py
@@ -1,6 +1,6 @@
 from __future__ import print_function, absolute_import
 
-__version__ = '1.1.3.post1'
+__version__ = '1.1.5'
 
 # Add NullHandler to "pythonfinder" logger, because Python2's default root
 # logger has no handler and warnings like this would be reported:
diff --git a/pipenv/vendor/pythonfinder/cli.py b/pipenv/vendor/pythonfinder/cli.py
index 1757c081..6e7980fe 100644
--- a/pipenv/vendor/pythonfinder/cli.py
+++ b/pipenv/vendor/pythonfinder/cli.py
@@ -30,17 +30,23 @@ def cli(ctx, find=False, which=False, findall=False, version=False, ignore_unsup
         sys.exit(0)
     finder = Finder(ignore_unsupported=ignore_unsupported)
     if findall:
-        versions = finder.find_all_python_versions()
+        versions = [v for v in finder.find_all_python_versions()]
         if versions:
             click.secho("Found python at the following locations:", fg="green")
             for v in versions:
                 py = v.py_version
+                comes_from = getattr(py, "comes_from", None)
+                if comes_from is not None:
+                    comes_from_path = getattr(comes_from, "path", v.path)
+                else:
+                    comes_from_path = v.path
                 click.secho(
-                    "{py.name!s}: {py.version!s} ({py.architecture!s}) @ {py.comes_from.path!s}".format(
-                        py=py
+                    "{py.name!s}: {py.version!s} ({py.architecture!s}) @ {comes_from!s}".format(
+                        py=py, comes_from=comes_from_path
                     ),
                     fg="yellow",
                 )
+            sys.exit(0)
         else:
             click.secho(
                 "ERROR: No valid python versions found! Check your path and try again.",
diff --git a/pipenv/vendor/pythonfinder/models/path.py b/pipenv/vendor/pythonfinder/models/path.py
index f39299a3..4a4c50da 100644
--- a/pipenv/vendor/pythonfinder/models/path.py
+++ b/pipenv/vendor/pythonfinder/models/path.py
@@ -27,7 +27,6 @@ from ..utils import (
     path_is_known_executable,
     unnest,
 )
-from .python import PythonVersion
 
 
 @attr.s
@@ -504,7 +503,6 @@ class PathEntry(BasePath):
             children = {}
             child_creation_args = {
                 "is_root": False,
-                "py_version": python,
                 "only_python": only_python
             }
             if not guessed_name:
@@ -512,6 +510,7 @@ class PathEntry(BasePath):
             for pth, python in pythons.items():
                 pth = ensure_path(pth)
                 children[pth.as_posix()] = PathEntry(
+                    py_version=python,
                     path=pth,
                     **child_creation_args
                 )
diff --git a/pipenv/vendor/pythonfinder/models/pyenv.py b/pipenv/vendor/pythonfinder/models/pyenv.py
index 1595a963..a9d6105b 100644
--- a/pipenv/vendor/pythonfinder/models/pyenv.py
+++ b/pipenv/vendor/pythonfinder/models/pyenv.py
@@ -14,8 +14,6 @@ from vistir.compat import Path
 from ..utils import (
     ensure_path,
     optional_instance_of,
-    get_python_version,
-    filter_pythons,
     unnest,
 )
 from .mixins import BaseFinder, BasePath
diff --git a/pipenv/vendor/pythonfinder/pythonfinder.py b/pipenv/vendor/pythonfinder/pythonfinder.py
index 19a52e0a..854cc8e7 100644
--- a/pipenv/vendor/pythonfinder/pythonfinder.py
+++ b/pipenv/vendor/pythonfinder/pythonfinder.py
@@ -4,6 +4,7 @@ import os
 import six
 import operator
 from .models import SystemPath
+from vistir.compat import lru_cache
 
 
 class Finder(object):
@@ -34,6 +35,14 @@ class Finder(object):
         self._system_path = None
         self._windows_finder = None
 
+    def __hash__(self):
+        return hash(
+            (self.path_prepend, self.system, self.global_search, self.ignore_unsupported)
+        )
+
+    def __eq__(self, other):
+        return self.__hash__() == other.__hash__()
+
     @property
     def system_path(self):
         if not self._system_path:
@@ -56,6 +65,7 @@ class Finder(object):
     def which(self, exe):
         return self.system_path.which(exe)
 
+    @lru_cache(maxsize=128)
     def find_python_version(
         self, major=None, minor=None, patch=None, pre=None, dev=None, arch=None, name=None
     ):
@@ -103,6 +113,7 @@ class Finder(object):
             major=major, minor=minor, patch=patch, pre=pre, dev=dev, arch=arch, name=name
         )
 
+    @lru_cache(maxsize=128)
     def find_all_python_versions(
         self, major=None, minor=None, patch=None, pre=None, dev=None, arch=None, name=None
     ):
diff --git a/pipenv/vendor/pythonfinder/utils.py b/pipenv/vendor/pythonfinder/utils.py
index 2f5a860d..fd5ac99d 100644
--- a/pipenv/vendor/pythonfinder/utils.py
+++ b/pipenv/vendor/pythonfinder/utils.py
@@ -49,12 +49,13 @@ def get_python_version(path):
     """Get python version string using subprocess from a given path."""
     version_cmd = [path, "-c", "import sys; print(sys.version.split()[0])"]
     try:
-        out, _ = vistir.misc.run(version_cmd, block=True, nospin=True)
+        c = vistir.misc.run(version_cmd, block=True, nospin=True, return_object=True,
+                                combine_stderr=False)
     except OSError:
         raise InvalidPythonVersion("%s is not a valid python path" % path)
-    if not out:
+    if not c.out:
         raise InvalidPythonVersion("%s is not a valid python path" % path)
-    return out.strip()
+    return c.out.strip()
 
 
 def optional_instance_of(cls):
diff --git a/pipenv/vendor/requirementslib/__init__.py b/pipenv/vendor/requirementslib/__init__.py
index 7b4b6376..ba40e5f5 100644
--- a/pipenv/vendor/requirementslib/__init__.py
+++ b/pipenv/vendor/requirementslib/__init__.py
@@ -1,9 +1,13 @@
 # -*- coding=utf-8 -*-
-__version__ = '1.2.0'
+__version__ = '1.2.1'
+
+import logging
+
+logger = logging.getLogger(__name__)
+logger.addHandler(logging.NullHandler())
 
 from .models.requirements import Requirement
 from .models.lockfile import Lockfile
 from .models.pipfile import Pipfile
 
-
 __all__ = ["Lockfile", "Pipfile", "Requirement"]
diff --git a/pipenv/vendor/requirementslib/models/__init__.py b/pipenv/vendor/requirementslib/models/__init__.py
index 8d12da45..99e519d6 100644
--- a/pipenv/vendor/requirementslib/models/__init__.py
+++ b/pipenv/vendor/requirementslib/models/__init__.py
@@ -2,10 +2,9 @@
 from __future__ import absolute_import
 
 
-__all__ = ["Requirement", "Lockfile", "Pipfile", "DependencyResolver"]
+__all__ = ["Requirement", "Lockfile", "Pipfile"]
 
 
 from .requirements import Requirement
 from .lockfile import Lockfile
 from .pipfile import Pipfile
-from .resolvers import DependencyResolver
diff --git a/pipenv/vendor/requirementslib/models/dependencies.py b/pipenv/vendor/requirementslib/models/dependencies.py
index d9f1b653..c3df222f 100644
--- a/pipenv/vendor/requirementslib/models/dependencies.py
+++ b/pipenv/vendor/requirementslib/models/dependencies.py
@@ -9,6 +9,7 @@ import attr
 import packaging.markers
 import packaging.version
 import requests
+import warnings
 
 from first import first
 from packaging.utils import canonicalize_name
@@ -17,7 +18,7 @@ from pip_shims import (
     FormatControl, InstallRequirement, PackageFinder, RequirementPreparer,
     RequirementSet, RequirementTracker, Resolver, WheelCache, pip_version
 )
-from vistir.compat import JSONDecodeError, fs_str
+from vistir.compat import JSONDecodeError, fs_str, ResourceWarning
 from vistir.contextmanagers import cd, temp_environ
 from vistir.misc import partialclass
 from vistir.path import create_tracked_tempdir
@@ -53,6 +54,8 @@ def find_all_matches(finder, ireq, pre=False):
     :return: A list of matching candidates.
     :rtype: list[:class:`~pip._internal.index.InstallationCandidate`]
     """
+
+
     candidates = clean_requires_python(finder.find_all_candidates(ireq.name))
     versions = {candidate.version for candidate in candidates}
     allowed_versions = _get_filtered_versions(ireq, versions, pre)
@@ -341,9 +344,12 @@ def get_dependencies_from_json(ireq):
 
     def gen(ireq):
         info = None
-        info = session.get(
-            "https://pypi.org/pypi/{0}/{1}/json".format(ireq.req.name, version)
-        ).json()["info"]
+        try:
+            info = session.get(
+                "https://pypi.org/pypi/{0}/{1}/json".format(ireq.req.name, version)
+            ).json()["info"]
+        finally:
+            session.close()
         requires_dist = info.get("requires_dist", info.get("requires"))
         if not requires_dist:   # The API can return None for this.
             return
@@ -605,13 +611,16 @@ def start_resolver(finder=None, wheel_cache=None):
         wheel_cache=wheel_cache,
         use_user_site=False,
     )
-    if packaging.version.parse(pip_version) >= packaging.version.parse('18'):
-        with RequirementTracker() as req_tracker:
-            preparer = preparer(req_tracker=req_tracker)
+    try:
+        if packaging.version.parse(pip_version) >= packaging.version.parse('18'):
+            with RequirementTracker() as req_tracker:
+                preparer = preparer(req_tracker=req_tracker)
+                yield resolver(preparer=preparer)
+        else:
+            preparer = preparer()
             yield resolver(preparer=preparer)
-    else:
-        preparer = preparer()
-        yield resolver(preparer=preparer)
+    finally:
+        finder.session.close()
 
 
 def get_grouped_dependencies(constraints):
diff --git a/pipenv/vendor/requirementslib/utils.py b/pipenv/vendor/requirementslib/utils.py
index 085f3241..75a05ce0 100644
--- a/pipenv/vendor/requirementslib/utils.py
+++ b/pipenv/vendor/requirementslib/utils.py
@@ -6,6 +6,7 @@ import logging
 import os
 
 import six
+import sys
 import tomlkit
 
 six.add_move(six.MovedAttribute("Mapping", "collections", "collections.abc"))
@@ -23,8 +24,6 @@ from vistir.compat import Path
 from vistir.path import is_valid_url, ensure_mkdir_p, create_tracked_tempdir
 
 
-
-
 VCS_LIST = ("git", "svn", "hg", "bzr")
 VCS_SCHEMES = []
 SCHEME_LIST = ("http://", "https://", "ftp://", "ftps://", "file://")
@@ -38,7 +37,7 @@ if not VCS_SCHEMES:
 def setup_logger():
     logger = logging.getLogger("requirementslib")
     loglevel = logging.DEBUG
-    handler = logging.StreamHandler()
+    handler = logging.StreamHandler(stream=sys.stderr)
     handler.setLevel(loglevel)
     logger.addHandler(handler)
     logger.setLevel(loglevel)
diff --git a/pipenv/vendor/resolvelib/__init__.py b/pipenv/vendor/resolvelib/__init__.py
new file mode 100644
index 00000000..e0e37434
--- /dev/null
+++ b/pipenv/vendor/resolvelib/__init__.py
@@ -0,0 +1,16 @@
+__all__ = [
+    '__version__',
+    'AbstractProvider', 'BaseReporter', 'Resolver',
+    'NoVersionsAvailable', 'RequirementsConflicted',
+    'ResolutionError', 'ResolutionImpossible', 'ResolutionTooDeep',
+]
+
+__version__ = '0.2.2'
+
+
+from .providers import AbstractProvider
+from .reporters import BaseReporter
+from .resolvers import (
+    NoVersionsAvailable, RequirementsConflicted,
+    Resolver, ResolutionError, ResolutionImpossible, ResolutionTooDeep,
+)
diff --git a/pipenv/vendor/resolvelib/providers.py b/pipenv/vendor/resolvelib/providers.py
new file mode 100644
index 00000000..515c0db4
--- /dev/null
+++ b/pipenv/vendor/resolvelib/providers.py
@@ -0,0 +1,78 @@
+class AbstractProvider(object):
+    """Delegate class to provide requirment interface for the resolver.
+    """
+    def identify(self, dependency):
+        """Given a dependency, return an identifier for it.
+
+        This is used in many places to identify the dependency, e.g. whether
+        two requirements should have their specifier parts merged, whether
+        two specifications would conflict with each other (because they the
+        same name but different versions).
+        """
+        raise NotImplementedError
+
+    def get_preference(self, resolution, candidates, information):
+        """Produce a sort key for given specification based on preference.
+
+        The preference is defined as "I think this requirement should be
+        resolved first". The lower the return value is, the more preferred
+        this group of arguments is.
+
+        :param resolution: Currently pinned candidate, or `None`.
+        :param candidates: A list of possible candidates.
+        :param information: A list of requirement information.
+
+        Each information instance is a named tuple with two entries:
+
+        * `requirement` specifies a requirement contributing to the current
+          candidate list
+        * `parent` specifies the candidate that provids (dependend on) the
+          requirement, or `None` to indicate a root requirement.
+
+        The preference could depend on a various of issues, including (not
+        necessarily in this order):
+
+        * Is this package pinned in the current resolution result?
+        * How relaxed is the requirement? Stricter ones should probably be
+          worked on first? (I don't know, actually.)
+        * How many possibilities are there to satisfy this requirement? Those
+          with few left should likely be worked on first, I guess?
+        * Are there any known conflicts for this requirement? We should
+          probably work on those with the most known conflicts.
+
+        A sortable value should be returned (this will be used as the `key`
+        parameter of the built-in sorting function). The smaller the value is,
+        the more preferred this specification is (i.e. the sorting function
+        is called with `reverse=False`).
+        """
+        raise NotImplementedError
+
+    def find_matches(self, requirement):
+        """Find all possible candidates that satisfy a requirement.
+
+        This should try to get candidates based on the requirement's type.
+        For VCS, local, and archive requirements, the one-and-only match is
+        returned, and for a "named" requirement, the index(es) should be
+        consulted to find concrete candidates for this requirement.
+
+        The returned candidates should be sorted by reversed preference, e.g.
+        the latest should be LAST. This is done so list-popping can be as
+        efficient as possible.
+        """
+        raise NotImplementedError
+
+    def is_satisfied_by(self, requirement, candidate):
+        """Whether the given requirement can be satisfied by a candidate.
+
+        A boolean should be retuened to indicate whether `candidate` is a
+        viable solution to the requirement.
+        """
+        raise NotImplementedError
+
+    def get_dependencies(self, candidate):
+        """Get dependencies of a candidate.
+
+        This should return a collection of requirements that `candidate`
+        specifies as its dependencies.
+        """
+        raise NotImplementedError
diff --git a/pipenv/vendor/resolvelib/reporters.py b/pipenv/vendor/resolvelib/reporters.py
new file mode 100644
index 00000000..c723031f
--- /dev/null
+++ b/pipenv/vendor/resolvelib/reporters.py
@@ -0,0 +1,23 @@
+class BaseReporter(object):
+    """Delegate class to provider progress reporting for the resolver.
+    """
+    def starting(self):
+        """Called before the resolution actually starts.
+        """
+
+    def starting_round(self, index):
+        """Called before each round of resolution starts.
+
+        The index is zero-based.
+        """
+
+    def ending_round(self, index, state):
+        """Called before each round of resolution ends.
+
+        This is NOT called if the resolution ends at this round. Use `ending`
+        if you want to report finalization. The index is zero-based.
+        """
+
+    def ending(self, state):
+        """Called before the resolution ends successfully.
+        """
diff --git a/pipenv/vendor/resolvelib/resolvers.py b/pipenv/vendor/resolvelib/resolvers.py
new file mode 100644
index 00000000..9c69628e
--- /dev/null
+++ b/pipenv/vendor/resolvelib/resolvers.py
@@ -0,0 +1,287 @@
+import collections
+
+from .structs import DirectedGraph
+
+
+RequirementInformation = collections.namedtuple('RequirementInformation', [
+    'requirement', 'parent',
+])
+
+
+class NoVersionsAvailable(Exception):
+    def __init__(self, requirement, parent):
+        super(NoVersionsAvailable, self).__init__()
+        self.requirement = requirement
+        self.parent = parent
+
+
+class RequirementsConflicted(Exception):
+    def __init__(self, criterion):
+        super(RequirementsConflicted, self).__init__()
+        self.criterion = criterion
+
+
+class Criterion(object):
+    """Internal representation of possible resolution results of a package.
+
+    This holds two attributes:
+
+    * `information` is a collection of `RequirementInformation` pairs. Each
+      pair is a requirement contributing to this criterion, and the candidate
+      that provides the requirement.
+    * `candidates` is a collection containing all possible candidates deducted
+      from the union of contributing requirements. It should never be empty.
+    """
+    def __init__(self, candidates, information):
+        self.candidates = candidates
+        self.information = information
+
+    @classmethod
+    def from_requirement(cls, provider, requirement, parent):
+        """Build an instance from a requirement.
+        """
+        candidates = provider.find_matches(requirement)
+        if not candidates:
+            raise NoVersionsAvailable(requirement, parent)
+        return cls(
+            candidates=candidates,
+            information=[RequirementInformation(requirement, parent)],
+        )
+
+    def iter_requirement(self):
+        return (i.requirement for i in self.information)
+
+    def iter_parent(self):
+        return (i.parent for i in self.information)
+
+    def merged_with(self, provider, requirement, parent):
+        """Build a new instance from this and a new requirement.
+        """
+        infos = list(self.information)
+        infos.append(RequirementInformation(requirement, parent))
+        candidates = [
+            c for c in self.candidates
+            if provider.is_satisfied_by(requirement, c)
+        ]
+        if not candidates:
+            raise RequirementsConflicted(self)
+        return type(self)(candidates, infos)
+
+
+class ResolutionError(Exception):
+    pass
+
+
+class ResolutionImpossible(ResolutionError):
+    def __init__(self, requirements):
+        super(ResolutionImpossible, self).__init__()
+        self.requirements = requirements
+
+
+class ResolutionTooDeep(ResolutionError):
+    def __init__(self, round_count):
+        super(ResolutionTooDeep, self).__init__(round_count)
+        self.round_count = round_count
+
+
+# Resolution state in a round.
+State = collections.namedtuple('State', 'mapping graph')
+
+
+class Resolution(object):
+    """Stateful resolution object.
+
+    This is designed as a one-off object that holds information to kick start
+    the resolution process, and holds the results afterwards.
+    """
+    def __init__(self, provider, reporter):
+        self._p = provider
+        self._r = reporter
+        self._criteria = {}
+        self._states = []
+
+    @property
+    def state(self):
+        try:
+            return self._states[-1]
+        except IndexError:
+            raise AttributeError('state')
+
+    def _push_new_state(self):
+        """Push a new state into history.
+
+        This new state will be used to hold resolution results of the next
+        coming round.
+        """
+        try:
+            base = self._states[-1]
+        except IndexError:
+            graph = DirectedGraph()
+            graph.add(None)     # Sentinel as root dependencies' parent.
+            state = State(mapping={}, graph=graph)
+        else:
+            state = State(
+                mapping=base.mapping.copy(),
+                graph=base.graph.copy(),
+            )
+        self._states.append(state)
+
+    def _contribute_to_criteria(self, name, requirement, parent):
+        try:
+            crit = self._criteria[name]
+        except KeyError:
+            crit = Criterion.from_requirement(self._p, requirement, parent)
+        else:
+            crit = crit.merged_with(self._p, requirement, parent)
+        self._criteria[name] = crit
+
+    def _get_criterion_item_preference(self, item):
+        name, criterion = item
+        try:
+            pinned = self.state.mapping[name]
+        except (IndexError, KeyError):
+            pinned = None
+        return self._p.get_preference(
+            pinned, criterion.candidates, criterion.information,
+        )
+
+    def _is_current_pin_satisfying(self, name, criterion):
+        try:
+            current_pin = self.state.mapping[name]
+        except KeyError:
+            return False
+        return all(
+            self._p.is_satisfied_by(r, current_pin)
+            for r in criterion.iter_requirement()
+        )
+
+    def _check_pinnability(self, candidate, dependencies):
+        backup = self._criteria.copy()
+        contributed = set()
+        try:
+            for subdep in dependencies:
+                key = self._p.identify(subdep)
+                self._contribute_to_criteria(key, subdep, parent=candidate)
+                contributed.add(key)
+        except RequirementsConflicted:
+            self._criteria = backup
+            return None
+        return contributed
+
+    def _pin_candidate(self, name, criterion, candidate, child_names):
+        try:
+            self.state.graph.remove(name)
+        except KeyError:
+            pass
+        self.state.mapping[name] = candidate
+        self.state.graph.add(name)
+        for parent in criterion.iter_parent():
+            parent_name = None if parent is None else self._p.identify(parent)
+            try:
+                self.state.graph.connect(parent_name, name)
+            except KeyError:
+                # Parent is not yet pinned. Skip now; this edge will be
+                # connected when the parent is being pinned.
+                pass
+        for child_name in child_names:
+            try:
+                self.state.graph.connect(name, child_name)
+            except KeyError:
+                # Child is not yet pinned. Skip now; this edge will be
+                # connected when the child is being pinned.
+                pass
+
+    def _pin_criteria(self):
+        criterion_names = [name for name, _ in sorted(
+            self._criteria.items(),
+            key=self._get_criterion_item_preference,
+        )]
+        for name in criterion_names:
+            # Any pin may modify any criterion during the loop. Criteria are
+            # replaced, not updated in-place, so we need to read this value
+            # in the loop instead of outside. (sarugaku/resolvelib#5)
+            criterion = self._criteria[name]
+
+            if self._is_current_pin_satisfying(name, criterion):
+                # If the current pin already works, just use it.
+                continue
+            candidates = list(criterion.candidates)
+            while candidates:
+                candidate = candidates.pop()
+                dependencies = self._p.get_dependencies(candidate)
+                child_names = self._check_pinnability(candidate, dependencies)
+                if child_names is None:
+                    continue
+                self._pin_candidate(name, criterion, candidate, child_names)
+                break
+            else:   # All candidates tried, nothing works. Give up. (?)
+                raise ResolutionImpossible(list(criterion.iter_requirement()))
+
+    def resolve(self, requirements, max_rounds):
+        if self._states:
+            raise RuntimeError('already resolved')
+
+        for requirement in requirements:
+            try:
+                name = self._p.identify(requirement)
+                self._contribute_to_criteria(name, requirement, parent=None)
+            except RequirementsConflicted as e:
+                # If initial requirements conflict, nothing would ever work.
+                raise ResolutionImpossible(e.requirements + [requirement])
+
+        last = None
+        self._r.starting()
+
+        for round_index in range(max_rounds):
+            self._r.starting_round(round_index)
+
+            self._push_new_state()
+            self._pin_criteria()
+
+            curr = self.state
+            if last is not None and len(curr.mapping) == len(last.mapping):
+                # Nothing new added. Done! Remove the duplicated entry.
+                del self._states[-1]
+                self._r.ending(last)
+                return
+            last = curr
+
+            self._r.ending_round(round_index, curr)
+
+        raise ResolutionTooDeep(max_rounds)
+
+
+class Resolver(object):
+    """The thing that performs the actual resolution work.
+    """
+    def __init__(self, provider, reporter):
+        self.provider = provider
+        self.reporter = reporter
+
+    def resolve(self, requirements, max_rounds=20):
+        """Take a collection of constraints, spit out the resolution result.
+
+        The return value is a representation to the final resolution result. It
+        is a tuple subclass with two public members:
+
+        * `mapping`: A dict of resolved candidates. Each key is an identifier
+            of a requirement (as returned by the provider's `identify` method),
+            and the value is the resolved candidate.
+        * `graph`: A `DirectedGraph` instance representing the dependency tree.
+            The vertices are keys of `mapping`, and each edge represents *why*
+            a particular package is included. A special vertex `None` is
+            included to represent parents of user-supplied requirements.
+
+        The following exceptions may be raised if a resolution cannot be found:
+
+        * `NoVersionsAvailable`: A requirement has no available candidates.
+        * `ResolutionImpossible`: A resolution cannot be found for the given
+            combination of requirements.
+        * `ResolutionTooDeep`: The dependency tree is too deeply nested and
+            the resolver gave up. This is usually caused by a circular
+            dependency, but you can try to resolve this by increasing the
+            `max_rounds` argument.
+        """
+        resolution = Resolution(self.provider, self.reporter)
+        resolution.resolve(requirements, max_rounds=max_rounds)
+        return resolution.state
diff --git a/pipenv/vendor/resolvelib/structs.py b/pipenv/vendor/resolvelib/structs.py
new file mode 100644
index 00000000..97bd0095
--- /dev/null
+++ b/pipenv/vendor/resolvelib/structs.py
@@ -0,0 +1,67 @@
+class DirectedGraph(object):
+    """A graph structure with directed edges.
+    """
+    def __init__(self):
+        self._vertices = set()
+        self._forwards = {}     # <key> -> Set[<key>]
+        self._backwards = {}    # <key> -> Set[<key>]
+
+    def __iter__(self):
+        return iter(self._vertices)
+
+    def __len__(self):
+        return len(self._vertices)
+
+    def __contains__(self, key):
+        return key in self._vertices
+
+    def copy(self):
+        """Return a shallow copy of this graph.
+        """
+        other = DirectedGraph()
+        other._vertices = set(self._vertices)
+        other._forwards = {k: set(v) for k, v in self._forwards.items()}
+        other._backwards = {k: set(v) for k, v in self._backwards.items()}
+        return other
+
+    def add(self, key):
+        """Add a new vertex to the graph.
+        """
+        if key in self._vertices:
+            raise ValueError('vertex exists')
+        self._vertices.add(key)
+        self._forwards[key] = set()
+        self._backwards[key] = set()
+
+    def remove(self, key):
+        """Remove a vertex from the graph, disconnecting all edges from/to it.
+        """
+        self._vertices.remove(key)
+        for f in self._forwards.pop(key):
+            self._backwards[f].remove(key)
+        for t in self._backwards.pop(key):
+            self._forwards[t].remove(key)
+
+    def connected(self, f, t):
+        return f in self._backwards[t] and t in self._forwards[f]
+
+    def connect(self, f, t):
+        """Connect two existing vertices.
+
+        Nothing happens if the vertices are already connected.
+        """
+        if t not in self._vertices:
+            raise KeyError(t)
+        self._forwards[f].add(t)
+        self._backwards[t].add(f)
+
+    def iter_edges(self):
+        for f, children in self._forwards.items():
+            for t in children:
+                yield f, t
+
+    def iter_children(self, key):
+        return iter(self._forwards[key])
+
+    def iter_parents(self, key):
+        return iter(self._backwards[key])
diff --git a/pipenv/vendor/shutil_backports/__init__.py b/pipenv/vendor/shutil_backports/__init__.py
new file mode 100644
index 00000000..fa12816e
--- /dev/null
+++ b/pipenv/vendor/shutil_backports/__init__.py
@@ -0,0 +1,9 @@
+__title__ = "shutil_backports"
+__version__ = "0.1.0"
+__license__ = "MIT"
+__author__ = "Christopher Rosell"
+__copyright__ = "Copyright 2014 Christopher Rosell"
+
+__all__ = ["get_terminal_size"]
+
+from .get_terminal_size import *
diff --git a/pipenv/vendor/shutil_backports/get_terminal_size.py b/pipenv/vendor/shutil_backports/get_terminal_size.py
new file mode 100644
index 00000000..f1336e58
--- /dev/null
+++ b/pipenv/vendor/shutil_backports/get_terminal_size.py
@@ -0,0 +1,100 @@
+"""This is a backport of shutil.get_terminal_size from Python 3.3.
+
+The original implementation is in C, but here we use the ctypes and
+fcntl modules to create a pure Python version of os.get_terminal_size.
+"""
+
+import os
+import struct
+import sys
+
+from collections import namedtuple
+
+__all__ = ["get_terminal_size"]
+
+
+terminal_size = namedtuple("terminal_size", "columns lines")
+
+try:
+    from ctypes import windll, create_string_buffer
+
+    _handles = {
+        0: windll.kernel32.GetStdHandle(-10),
+        1: windll.kernel32.GetStdHandle(-11),
+        2: windll.kernel32.GetStdHandle(-12),
+    }
+
+    def _get_terminal_size(fd):
+        columns = lines = 0
+
+        try:
+            handle = _handles[fd]
+            csbi = create_string_buffer(22)
+            res = windll.kernel32.GetConsoleScreenBufferInfo(handle, csbi)
+            if res:
+                res = struct.unpack("hhhhHhhhhhh", csbi.raw)
+                left, top, right, bottom = res[5:9]
+                columns = right - left + 1
+                lines = bottom - top + 1
+        except Exception:
+            pass
+
+        return columns, lines
+
+except ImportError:
+    import fcntl
+    import termios
+
+    def _get_terminal_size(fd):
+        try:
+            res = fcntl.ioctl(fd, termios.TIOCGWINSZ, b"\x00" * 4)
+            lines, columns = struct.unpack("hh", res)
+        except Exception:
+            columns = lines = 0
+
+        return columns, lines
+
+
+def get_terminal_size(fallback=(80, 24)):
+    """Get the size of the terminal window.
+
+    For each of the two dimensions, the environment variable, COLUMNS
+    and LINES respectively, is checked. If the variable is defined and
+    the value is a positive integer, it is used.
+
+    When COLUMNS or LINES is not defined, which is the common case,
+    the terminal connected to sys.__stdout__ is queried
+    by invoking os.get_terminal_size.
+
+    If the terminal size cannot be successfully queried, either because
+    the system doesn't support querying, or because we are not
+    connected to a terminal, the value given in fallback parameter
+    is used. Fallback defaults to (80, 24) which is the default
+    size used by many terminal emulators.
+
+    The value returned is a named tuple of type os.terminal_size.
+    """
+    # Attempt to use the environment first
+    try:
+        columns = int(os.environ["COLUMNS"])
+    except (KeyError, ValueError):
+        columns = 0
+
+    try:
+        lines = int(os.environ["LINES"])
+    except (KeyError, ValueError):
+        lines = 0
+
+    # Only query if necessary
+    if columns <= 0 or lines <= 0:
+        try:
+            columns, lines = _get_terminal_size(sys.__stdout__.fileno())
+        except (NameError, OSError):
+            pass
+
+    # Use fallback as last resort
+    if columns <= 0 and lines <= 0:
+        columns, lines = fallback
+
+    return terminal_size(columns, lines)
+
diff --git a/pipenv/vendor/vendor.txt b/pipenv/vendor/vendor.txt
index 741ae319..091f27d8 100644
--- a/pipenv/vendor/vendor.txt
+++ b/pipenv/vendor/vendor.txt
@@ -21,13 +21,13 @@ pipdeptree==0.13.0
 pipreqs==0.4.9
     docopt==0.6.2
     yarg==0.1.9
-pythonfinder==1.1.3.post1
+pythonfinder==1.1.6
 requests==2.20.0
     chardet==3.0.4
     idna==2.7
     urllib3==1.24
     certifi==2018.10.15
-requirementslib==1.2.0
+requirementslib==1.2.1
     attrs==18.2.0
     distlib==0.2.8
     packaging==18.0
@@ -41,7 +41,7 @@ semver==2.8.1
 shutilwhich==1.1.0
 toml==0.10.0
 cached-property==1.4.3
-vistir==0.2.0
+vistir==0.2.2
 pip-shims==0.3.1
 ptyprocess==0.6.0
 enum34==1.1.6
diff --git a/pipenv/vendor/vistir/__init__.py b/pipenv/vendor/vistir/__init__.py
index c8b253b8..912ab0a4 100644
--- a/pipenv/vendor/vistir/__init__.py
+++ b/pipenv/vendor/vistir/__init__.py
@@ -1,7 +1,7 @@
 # -*- coding=utf-8 -*-
 from __future__ import absolute_import, unicode_literals
 
-from .compat import NamedTemporaryFile, TemporaryDirectory, partialmethod
+from .compat import NamedTemporaryFile, TemporaryDirectory, partialmethod, to_native_string
 from .contextmanagers import (
     atomic_open_for_write,
     cd,
@@ -15,7 +15,7 @@ from .path import mkdir_p, rmtree, create_tracked_tempdir, create_tracked_tempfi
 from .spin import VistirSpinner, create_spinner
 
 
-__version__ = '0.2.0'
+__version__ = '0.2.2'
 
 
 __all__ = [
@@ -38,4 +38,5 @@ __all__ = [
     "create_spinner",
     "create_tracked_tempdir",
     "create_tracked_tempfile",
+    "to_native_string"
 ]
diff --git a/pipenv/vendor/vistir/backports/tempfile.py b/pipenv/vendor/vistir/backports/tempfile.py
index 7b8066ee..fb044acf 100644
--- a/pipenv/vendor/vistir/backports/tempfile.py
+++ b/pipenv/vendor/vistir/backports/tempfile.py
@@ -194,6 +194,8 @@ def NamedTemporaryFile(
     flags = _bin_openflags
     # Setting O_TEMPORARY in the flags causes the OS to delete
     # the file when it is closed.  This is only supported by Windows.
+    if not wrapper_class_override:
+        wrapper_class_override = _TemporaryFileWrapper
     if os.name == "nt" and delete:
         flags |= os.O_TEMPORARY
     if sys.version_info < (3, 5):
@@ -205,7 +207,9 @@ def NamedTemporaryFile(
             fd, mode, buffering=buffering, newline=newline, encoding=encoding
         )
         if wrapper_class_override is not None:
-            return wrapper_class_override(file, name, delete)
+            return type(
+                str("_TempFileWrapper"), (wrapper_class_override, object), {}
+            )(file, name, delete)
         else:
             return _TemporaryFileWrapper(file, name, delete)
 
diff --git a/pipenv/vendor/vistir/compat.py b/pipenv/vendor/vistir/compat.py
index ec3b65cb..d6e8578a 100644
--- a/pipenv/vendor/vistir/compat.py
+++ b/pipenv/vendor/vistir/compat.py
@@ -24,6 +24,7 @@ __all__ = [
     "lru_cache",
     "TemporaryDirectory",
     "NamedTemporaryFile",
+    "to_native_string",
 ]
 
 if sys.version_info >= (3, 5):
@@ -142,3 +143,10 @@ def fs_str(string):
 
 
 _fs_encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
+
+
+def to_native_string(string):
+    from .misc import to_text, to_bytes
+    if six.PY2:
+        return to_bytes(string)
+    return to_text(string)
diff --git a/pipenv/vendor/vistir/contextmanagers.py b/pipenv/vendor/vistir/contextmanagers.py
index bcbf7541..4d8a3191 100644
--- a/pipenv/vendor/vistir/contextmanagers.py
+++ b/pipenv/vendor/vistir/contextmanagers.py
@@ -118,7 +118,6 @@ def spinner(spinner_name=None, start_text=None, handler_map=None, nospin=False):
     """
 
     from .spin import create_spinner
-    spinner_func = create_spinner
     if nospin is False:
         try:
             import yaspin
@@ -128,10 +127,10 @@ def spinner(spinner_name=None, start_text=None, handler_map=None, nospin=False):
                 " pip install --upgrade vistir[spinner]"
             )
     else:
-        spinner_name = None
+        spinner_name = ""
     if not start_text and nospin is False:
         start_text = "Running..."
-    with spinner_func(
+    with create_spinner(
         spinner_name=spinner_name,
         text=start_text,
         handler_map=handler_map,
@@ -271,8 +270,8 @@ def open_file(link, session=None, stream=True):
                 result = raw if raw else resp
                 yield result
             finally:
-                result.close()
                 if raw:
                     conn = getattr(raw, "_connection")
                     if conn is not None:
                         conn.close()
+                result.close()
diff --git a/pipenv/vendor/vistir/misc.py b/pipenv/vendor/vistir/misc.py
index 26382419..7d400a4c 100644
--- a/pipenv/vendor/vistir/misc.py
+++ b/pipenv/vendor/vistir/misc.py
@@ -15,7 +15,7 @@ from itertools import islice
 import six
 
 from .cmdparse import Script
-from .compat import Path, fs_str, partialmethod
+from .compat import Path, fs_str, partialmethod, to_native_string
 from .contextmanagers import spinner as spinner
 
 if os.name != "nt":
@@ -145,7 +145,8 @@ def _create_subprocess(
     verbose=False,
     spinner=None,
     combine_stderr=False,
-    display_limit=200
+    display_limit=200,
+    start_text=""
 ):
     if not env:
         env = {}
@@ -157,13 +158,13 @@ def _create_subprocess(
         raise
     if not block:
         c.stdin.close()
-        log_level = "DEBUG" if verbose else "ERROR"
-        logger = _get_logger(cmd._parts[0], level=log_level)
         output = []
         err = []
-        spinner_orig_text = ""
+        spinner_orig_text = None
         if spinner:
-            spinner_orig_text = getattr(spinner, "text", "")
+            spinner_orig_text = getattr(spinner, "text", None)
+        if spinner_orig_text is None:
+            spinner_orig_text = start_text if start_text is not None else ""
         streams = {
             "stdout": c.stdout,
             "stderr": c.stderr
@@ -185,25 +186,32 @@ def _create_subprocess(
                     stdout_line = line
             if not (stdout_line or stderr_line):
                 break
-            if stderr_line:
+            if stderr_line is not None:
                 err.append(stderr_line)
-                if verbose:
+                err_line = fs_str("{0}".format(stderr_line))
+                if verbose and err_line is not None:
                     if spinner:
-                        spinner.write_err(fs_str(stderr_line))
+                        spinner._hide_cursor()
+                        spinner.write_err(err_line)
+                        spinner._show_cursor()
                     else:
-                        logger.error(stderr_line)
-            if stdout_line:
+                        sys.stderr.write(err_line)
+                        sys.stderr.flush()
+            if stdout_line is not None:
                 output.append(stdout_line)
-                display_line = stdout_line
+                display_line = fs_str("{0}".format(stdout_line))
                 if len(stdout_line) > display_limit:
                     display_line = "{0}...".format(stdout_line[:display_limit])
-                if verbose:
+                if verbose and display_line is not None:
                     if spinner:
-                        spinner.write_err(fs_str(display_line))
+                        spinner._hide_cursor()
+                        spinner.write_err(display_line)
+                        spinner._show_cursor()
                     else:
-                        logger.debug(display_line)
+                        sys.stderr.write(display_line)
+                        sys.stderr.flush()
                 if spinner:
-                    spinner.text = fs_str("{0} {1}".format(spinner_orig_text, display_line))
+                    spinner.text = to_native_string("{0} {1}".format(spinner_orig_text, display_line))
                 continue
         try:
             c.wait()
@@ -214,21 +222,19 @@ def _create_subprocess(
                 c.stderr.close()
         if spinner:
             if c.returncode > 0:
-                spinner.fail("Failed...cleaning up...")
-            else:
-                spinner.text = "Complete!"
+                spinner.fail(to_native_string("Failed...cleaning up..."))
             if not os.name == "nt":
-                spinner.ok("✔")
+                spinner.ok(to_native_string("✔ Complete"))
             else:
-                spinner.ok()
-        c.out = "\n".join(output)
+                spinner.ok(to_native_string("Complete"))
+        c.out = "\n".join(output) if output else ""
         c.err = "\n".join(err) if err else ""
     else:
         c.out, c.err = c.communicate()
     if not block:
         c.wait()
-    c.out = fs_str("{0}".format(c.out)) if c.out else fs_str("")
-    c.err = fs_str("{0}".format(c.err)) if c.err else fs_str("")
+    c.out = to_text("{0}".format(c.out)) if c.out else fs_str("")
+    c.err = to_text("{0}".format(c.err)) if c.err else fs_str("")
     if not return_object:
         return c.out.strip(), c.err.strip()
     return c
@@ -287,9 +293,7 @@ def run(
         cmd = Script.parse(cmd)
     if block or not return_object:
         combine_stderr = False
-    start_text = "Running..."
-    if nospin:
-        start_text = None
+    start_text = ""
     with spinner(spinner_name=spinner_name, start_text=start_text, nospin=nospin) as sp:
         return _create_subprocess(
             cmd,
@@ -299,7 +303,8 @@ def run(
             cwd=cwd,
             verbose=verbose,
             spinner=sp,
-            combine_stderr=combine_stderr
+            combine_stderr=combine_stderr,
+            start_text=start_text
         )
 
 
diff --git a/pipenv/vendor/vistir/path.py b/pipenv/vendor/vistir/path.py
index d580aba2..68e6d464 100644
--- a/pipenv/vendor/vistir/path.py
+++ b/pipenv/vendor/vistir/path.py
@@ -46,7 +46,7 @@ __all__ = [
 ]
 
 
-if os.name == "nt" and six.PY34:
+if os.name == "nt":
     warnings.filterwarnings("ignore", category=DeprecationWarning, message="The Windows bytes API has been deprecated.*")
 
 
@@ -215,7 +215,6 @@ def ensure_mkdir_p(mode=0o777):
     """
 
     def decorator(f):
-
         @functools.wraps(f)
         def decorated(*args, **kwargs):
             path = f(*args, **kwargs)
@@ -316,10 +315,8 @@ def handle_remove_readonly(func, path, exc):
     This function will call check :func:`is_readonly_path` before attempting to call
     :func:`set_write_bit` on the target path and try again.
     """
-
     # Check for read-only attribute
-    if six.PY2:
-        from .compat import ResourceWarning
+    from .compat import ResourceWarning
     from .misc import to_bytes
 
     PERM_ERRORS = (errno.EACCES, errno.EPERM)
@@ -460,7 +457,7 @@ def safe_expandvars(value):
     return value
 
 
-class _TrackedTempfileWrapper(_TemporaryFileWrapper):
+class _TrackedTempfileWrapper(_TemporaryFileWrapper, object):
     def __init__(self, *args, **kwargs):
         super(_TrackedTempfileWrapper, self).__init__(*args, **kwargs)
         self._finalizer = finalize(self, self.cleanup)
diff --git a/pipenv/vendor/vistir/spin.py b/pipenv/vendor/vistir/spin.py
index e4b4ba66..57a90277 100644
--- a/pipenv/vendor/vistir/spin.py
+++ b/pipenv/vendor/vistir/spin.py
@@ -1,13 +1,18 @@
 # -*- coding=utf-8 -*-
+
+import functools
 import os
 import signal
 import sys
 
-from .termcolors import colored, COLORS
-from .compat import fs_str
-
+import colorama
 import cursor
-import functools
+import six
+
+from .compat import to_native_string
+from .termcolors import COLOR_MAP, COLORS, colored
+from io import StringIO
+
 try:
     import yaspin
 except ImportError:
@@ -15,7 +20,6 @@ except ImportError:
     Spinners = None
 else:
     from yaspin.spinners import Spinners
-    from yaspin.constants import COLOR_MAP
 
 handler = None
 if yaspin and os.name == "nt":
@@ -28,16 +32,20 @@ CLEAR_LINE = chr(27) + "[K"
 
 class DummySpinner(object):
     def __init__(self, text="", **kwargs):
-        self.text = text
+        colorama.init()
+        self.text = to_native_string(text)
+        self.stdout = kwargs.get("stdout", sys.stdout)
+        self.stderr = kwargs.get("stderr", sys.stderr)
+        self.out_buff = StringIO()
 
     def __enter__(self):
-        if self.text:
-            self.write(self.text)
+        if self.text and self.text != "None":
+            self.write_err(self.text)
         return self
 
     def __exit__(self, exc_type, exc_val, traceback):
         if not exc_type:
-            self.ok()
+            self.ok(text=None)
         else:
             self.write_err(traceback)
         return False
@@ -52,25 +60,43 @@ class DummySpinner(object):
         else:
             return retval
 
-    def fail(self, exitcode=1, text=None):
-        if text:
+    def fail(self, exitcode=1, text="FAIL"):
+        if text and text != "None":
             self.write_err(text)
+        if self.out_buff:
+            self.out_buff.close()
         raise SystemExit(exitcode, text)
 
-    def ok(self, text=None):
-        if text:
-            self.write(self.text)
+    def ok(self, text="OK"):
+        if text and text != "None":
+            self.stderr.write(self.text)
+        if self.out_buff:
+            self.out_buff.close()
         return 0
 
     def write(self, text=None):
-        if text:
-            line = fs_str("{0}\n".format(text))
-            sys.stdout.write(line)
+        if text is None or isinstance(text, six.string_types) and text == "None":
+            pass
+        self.stdout.write(to_native_string("\r"))
+        line = to_native_string("{0}\n".format(text))
+        self.stdout.write(line)
+        self.stdout.write(CLEAR_LINE)
 
     def write_err(self, text=None):
-        if text:
-            line = fs_str("{0}\n".format(text))
-            sys.stderr.write(line)
+        if text is None or isinstance(text, six.string_types) and text == "None":
+            pass
+        self.stderr.write(to_native_string("\r"))
+        line = to_native_string("{0}\n".format(text))
+        self.stderr.write(line)
+        self.stderr.write(CLEAR_LINE)
+
+    @staticmethod
+    def _hide_cursor():
+        pass
+
+    @staticmethod
+    def _show_cursor():
+        pass
 
 
 base_obj = yaspin.core.Yaspin if yaspin is not None else DummySpinner
@@ -88,6 +114,7 @@ class VistirSpinner(base_obj):
         """
 
         self.handler = handler
+        colorama.init()
         sigmap = {}
         if handler:
             sigmap.update({
@@ -102,30 +129,68 @@ class VistirSpinner(base_obj):
         if handler_map:
             sigmap.update(handler_map)
         spinner_name = kwargs.pop("spinner_name", "bouncingBar")
-        text = kwargs.pop("start_text", "") + " " + kwargs.pop("text", "")
-        if not text:
-            text = "Running..."
+        start_text = kwargs.pop("start_text", None)
+        _text = kwargs.pop("text", "Running...")
+        kwargs["text"] = start_text if start_text is not None else _text
         kwargs["sigmap"] = sigmap
-        kwargs["spinner"] = getattr(Spinners, spinner_name, Spinners.bouncingBar)
+        kwargs["spinner"] = getattr(Spinners, spinner_name, "")
+        self.stdout = kwargs.pop("stdout", sys.stdout)
+        self.stderr = kwargs.pop("stderr", sys.stderr)
+        self.out_buff = StringIO()
         super(VistirSpinner, self).__init__(*args, **kwargs)
         self.is_dummy = bool(yaspin is None)
 
-    def fail(self, exitcode=1, *args, **kwargs):
-        super(VistirSpinner, self).fail(**kwargs)
-
-    def ok(self, *args, **kwargs):
-        super(VistirSpinner, self).ok(*args, **kwargs)
-
-    def write(self, *args, **kwargs):
-        super(VistirSpinner, self).write(*args, **kwargs)
+    def ok(self, text="OK"):
+        """Set Ok (success) finalizer to a spinner."""
+        _text = text if text else "OK"
+        self._freeze(_text)
+
+    def fail(self, text="FAIL"):
+        """Set fail finalizer to a spinner."""
+        _text = text if text else "FAIL"
+        self._freeze(_text)
+
+    def write(self, text):
+        from .misc import to_text
+        sys.stdout.write("\r")
+        self.stdout.write(CLEAR_LINE)
+        if text is None:
+            text = ""
+        text = to_native_string("{0}\n".format(text))
+        sys.stdout.write(text)
+        self.out_buff.write(to_text(text))
 
     def write_err(self, text):
         """Write error text in the terminal without breaking the spinner."""
-
-        sys.stderr.write("\r")
-        self._clear_err()
-        text = fs_str("{0}\n".format(text))
-        sys.stderr.write(text)
+        from .misc import to_text
+
+        self.stderr.write("\r")
+        self.stderr.write(CLEAR_LINE)
+        if text is None:
+            text = ""
+        text = to_native_string("{0}\n".format(text))
+        self.stderr.write(text)
+        self.out_buff.write(to_text(text))
+
+    def _freeze(self, final_text):
+        """Stop spinner, compose last frame and 'freeze' it."""
+        if not final_text:
+            final_text = ""
+        text = to_native_string(final_text)
+        self._last_frame = self._compose_out(text, mode="last")
+
+        # Should be stopped here, otherwise prints after
+        # self._freeze call will mess up the spinner
+        self.stop()
+        self.stdout.write(self._last_frame)
+
+    def stop(self, *args, **kwargs):
+        if self.stderr and self.stderr != sys.stderr:
+            self.stderr.close()
+        if self.stdout and self.stdout != sys.stdout:
+            self.stdout.close()
+        self.out_buff.close()
+        super(VistirSpinner, self).stop(*args, **kwargs)
 
     def _compose_color_func(self):
         fn = functools.partial(
@@ -136,6 +201,24 @@ class VistirSpinner(base_obj):
         )
         return fn
 
+    def _compose_out(self, frame, mode=None):
+        # Ensure Unicode input
+
+        frame = to_native_string(frame)
+        if self._text is None:
+            self._text = ""
+        text = to_native_string(self._text)
+        if self._color_func is not None:
+            frame = self._color_func(frame)
+        if self._side == "right":
+            frame, text = text, frame
+        # Mode
+        if not mode:
+            out = to_native_string("\r{0} {1}".format(frame, text))
+        else:
+            out = to_native_string("{0} {1}\n".format(frame, text))
+        return out
+
     def _register_signal_handlers(self):
         # SIGKILL cannot be caught or ignored, and the receiving
         # process cannot perform any clean-up upon receiving this
@@ -191,6 +274,7 @@ class VistirSpinner(base_obj):
 
 def create_spinner(*args, **kwargs):
     nospin = kwargs.pop("nospin", False)
+    use_yaspin = kwargs.pop("use_yaspin", nospin)
     if nospin:
         return DummySpinner(*args, **kwargs)
     return VistirSpinner(*args, **kwargs)
diff --git a/pipenv/vendor/vistir/termcolors.py b/pipenv/vendor/vistir/termcolors.py
index b8ccda8e..8395d97d 100644
--- a/pipenv/vendor/vistir/termcolors.py
+++ b/pipenv/vendor/vistir/termcolors.py
@@ -2,6 +2,7 @@
 from __future__ import absolute_import, print_function, unicode_literals
 import colorama
 import os
+from .compat import to_native_string
 
 
 ATTRIBUTES = dict(
@@ -53,6 +54,33 @@ COLORS = dict(
         )
 
 
+COLOR_MAP = {
+    # name: type
+    "blink": "attrs",
+    "bold": "attrs",
+    "concealed": "attrs",
+    "dark": "attrs",
+    "reverse": "attrs",
+    "underline": "attrs",
+    "blue": "color",
+    "cyan": "color",
+    "green": "color",
+    "magenta": "color",
+    "red": "color",
+    "white": "color",
+    "yellow": "color",
+    "on_blue": "on_color",
+    "on_cyan": "on_color",
+    "on_green": "on_color",
+    "on_grey": "on_color",
+    "on_magenta": "on_color",
+    "on_red": "on_color",
+    "on_white": "on_color",
+    "on_yellow": "on_color",
+}
+COLOR_ATTRS = COLOR_MAP.keys()
+
+
 RESET = colorama.Style.RESET_ALL
 
 
@@ -80,25 +108,25 @@ def colored(text, color=None, on_color=None, attrs=None):
             attrs.remove('bold')
         if color is not None:
             color = color.upper()
-            text = text = "%s%s%s%s%s" % (
-                getattr(colorama.Fore, color),
-                getattr(colorama.Style, style),
-                text,
-                colorama.Fore.RESET,
-                colorama.Style.NORMAL,
+            text = to_native_string("%s%s%s%s%s") % (
+                to_native_string(getattr(colorama.Fore, color)),
+                to_native_string(getattr(colorama.Style, style)),
+                to_native_string(text),
+                to_native_string(colorama.Fore.RESET),
+                to_native_string(colorama.Style.NORMAL),
             )
 
         if on_color is not None:
             on_color = on_color.upper()
-            text = "%s%s%s%s" % (
-                getattr(colorama.Back, on_color),
-                text,
-                colorama.Back.RESET,
-                colorama.Style.NORMAL,
+            text = to_native_string("%s%s%s%s") % (
+                to_native_string(getattr(colorama.Back, on_color)),
+                to_native_string(text),
+                to_native_string(colorama.Back.RESET),
+                to_native_string(colorama.Style.NORMAL),
             )
 
         if attrs is not None:
-            fmt_str = "%s[%%dm%%s%s[9m" % (
+            fmt_str = to_native_string("%s[%%dm%%s%s[9m") % (
                 chr(27),
                 chr(27)
             )
diff --git a/pipenv/vendor/yaspin/core.py b/pipenv/vendor/yaspin/core.py
index 06b8b621..d01fb98e 100644
--- a/pipenv/vendor/yaspin/core.py
+++ b/pipenv/vendor/yaspin/core.py
@@ -16,9 +16,6 @@ import sys
 import threading
 import time
 
-import colorama
-import cursor
-
 from .base_spinner import default_spinner
 from .compat import PY2, basestring, builtin_str, bytes, iteritems, str
 from .constants import COLOR_ATTRS, COLOR_MAP, ENCODING, SPINNER_ATTRS
@@ -26,9 +23,6 @@ from .helpers import to_unicode
 from .termcolor import colored
 
 
-colorama.init()
-
-
 class Yaspin(object):
     """Implements a context manager that spawns a thread
     to write spinner frames into a tty (stdout) during
@@ -375,14 +369,11 @@ class Yaspin(object):
         # SIGKILL cannot be caught or ignored, and the receiving
         # process cannot perform any clean-up upon receiving this
         # signal.
-        try:
-            if signal.SIGKILL in self._sigmap.keys():
-                raise ValueError(
-                    "Trying to set handler for SIGKILL signal. "
-                    "SIGKILL cannot be cought or ignored in POSIX systems."
-                )
-        except AttributeError:
-            pass
+        if signal.SIGKILL in self._sigmap.keys():
+            raise ValueError(
+                "Trying to set handler for SIGKILL signal. "
+                "SIGKILL cannot be cought or ignored in POSIX systems."
+            )
 
         for sig, sig_handler in iteritems(self._sigmap):
             # A handler for a particular signal, once set, remains
@@ -530,12 +521,14 @@ class Yaspin(object):
 
     @staticmethod
     def _hide_cursor():
-        cursor.hide()
+        sys.stdout.write("\033[?25l")
+        sys.stdout.flush()
 
     @staticmethod
     def _show_cursor():
-        cursor.show()
+        sys.stdout.write("\033[?25h")
+        sys.stdout.flush()
 
     @staticmethod
     def _clear_line():
-        sys.stdout.write(chr(27) + "[K")
+        sys.stdout.write("\033[K")
diff --git a/tasks/vendoring/patches/vendor/delegator-close-filehandles.patch b/tasks/vendoring/patches/vendor/delegator-close-filehandles.patch
index 175efaa1..ae0bf088 100644
--- a/tasks/vendoring/patches/vendor/delegator-close-filehandles.patch
+++ b/tasks/vendoring/patches/vendor/delegator-close-filehandles.patch
@@ -1,8 +1,8 @@
-diff --git a/pipenv/vendor/delegator.py b/pipenv/vendor/delegator.py
-index d15aeb97..56d12458 100644
---- a/pipenv/vendor/delegator.py
-+++ b/pipenv/vendor/delegator.py
-@@ -7,6 +7,8 @@ import locale
+diff --git a/delegator.py b/delegator.py
+index 25d21f0..582f4fe 100644
+--- a/delegator.py
++++ b/delegator.py
+@@ -7,15 +7,18 @@ import locale
  import errno
  
  from pexpect.popen_spawn import PopenSpawn
@@ -11,26 +11,150 @@ index d15aeb97..56d12458 100644
  
  # Include `unicode` in STR_TYPES for Python 2.X
  try:
-@@ -110,7 +112,7 @@ class Command(object):
+     STR_TYPES = (str, unicode)
+ except NameError:
+-    STR_TYPES = (str, )
++    STR_TYPES = (str,)
+ 
+ TIMEOUT = 30
+ 
++
+ def pid_exists(pid):
+     """Check whether pid exists in the current process table."""
+     if pid == 0:
+@@ -43,8 +46,8 @@ def pid_exists(pid):
+     else:
+         return True
+ 
+-class Command(object):
+ 
++class Command(object):
+     def __init__(self, cmd, timeout=TIMEOUT):
+         super(Command, self).__init__()
+         self.cmd = cmd
+@@ -56,7 +59,7 @@ class Command(object):
+         self.__err = None
+ 
+     def __repr__(self):
+-        return '<Command {!r}>'.format(self.cmd)
++        return "<Command {!r}>".format(self.cmd)
+ 
+     @property
+     def _popen_args(self):
+@@ -65,27 +68,23 @@ class Command(object):
+     @property
+     def _default_popen_kwargs(self):
+         return {
+-            'env': os.environ.copy(),
+-            'stdin': subprocess.PIPE,
+-            'stdout': subprocess.PIPE,
+-            'stderr': subprocess.PIPE,
+-            'shell': True,
+-            'universal_newlines': True,
+-            'bufsize': 0
++            "env": os.environ.copy(),
++            "stdin": subprocess.PIPE,
++            "stdout": subprocess.PIPE,
++            "stderr": subprocess.PIPE,
++            "shell": True,
++            "universal_newlines": True,
++            "bufsize": 0,
+         }
+ 
+     @property
+     def _default_pexpect_kwargs(self):
+-        encoding = 'utf-8'
+-        if sys.platform == 'win32':
++        encoding = "utf-8"
++        if sys.platform == "win32":
+             default_encoding = locale.getdefaultlocale()[1]
+             if default_encoding is not None:
+                 encoding = default_encoding
+-        return {
+-            'env': os.environ.copy(),
+-            'encoding': encoding,
+-            'timeout': self.timeout
+-        }
++        return {"env": os.environ.copy(), "encoding": encoding, "timeout": self.timeout}
+ 
+     @property
+     def _uses_subprocess(self):
+@@ -99,18 +98,25 @@ class Command(object):
+     def std_out(self):
+         return self.subprocess.stdout
+ 
++    @property
++    def ok(self):
++        return self.return_code == 0
++
+     @property
+     def _pexpect_out(self):
+         if self.subprocess.encoding:
+-            result = ''
++            result = ""
+         else:
+-            result = b''
++            result = b""
+ 
          if self.subprocess.before:
              result += self.subprocess.before
  
--        if self.subprocess.after:
-+        if self.subprocess.after and self.subprocess.after is not pexpect.EOF:
-             result += self.subprocess.after
+         if self.subprocess.after:
+-            result += self.subprocess.after
++            try:
++                result += self.subprocess.after
++            except (pexpect.EOF, pexpect.TIMEOUT):
++                pass
  
          result += self.subprocess.read()
-@@ -178,6 +180,7 @@ class Command(object):
+         return result
+@@ -148,7 +154,7 @@ class Command(object):
+     def pid(self):
+         """The process' PID."""
+         # Support for pexpect's functionality.
+-        if hasattr(self.subprocess, 'proc'):
++        if hasattr(self.subprocess, "proc"):
+             return self.subprocess.proc.pid
+         # Standard subprocess method.
+         return self.subprocess.pid
+@@ -177,23 +183,24 @@ class Command(object):
          # Use subprocess.
          if self.blocking:
              popen_kwargs = self._default_popen_kwargs.copy()
+-            popen_kwargs['universal_newlines'] = not binary
 +            del popen_kwargs["stdin"]
-             popen_kwargs["universal_newlines"] = not binary
++            popen_kwargs["universal_newlines"] = not binary
+             if cwd:
+-                popen_kwargs['cwd'] = cwd
++                popen_kwargs["cwd"] = cwd
+             if env:
+-                popen_kwargs['env'].update(env)
++                popen_kwargs["env"].update(env)
+             s = subprocess.Popen(self._popen_args, **popen_kwargs)
+         # Otherwise, use pexpect.
+         else:
+             pexpect_kwargs = self._default_pexpect_kwargs.copy()
+             if binary:
+-                pexpect_kwargs['encoding'] = None
++                pexpect_kwargs["encoding"] = None
              if cwd:
-                 popen_kwargs["cwd"] = cwd
-@@ -205,7 +208,10 @@ class Command(object):
+-                pexpect_kwargs['cwd'] = cwd
++                pexpect_kwargs["cwd"] = cwd
+             if env:
+-                pexpect_kwargs['env'].update(env)
++                pexpect_kwargs["env"].update(env)
+             # Enable Python subprocesses to work with expect functionality.
+-            pexpect_kwargs['env']['PYTHONUNBUFFERED'] = '1'
++            pexpect_kwargs["env"]["PYTHONUNBUFFERED"] = "1"
+             s = PopenSpawn(self._popen_args, **pexpect_kwargs)
+         self.subprocess = s
+         self.was_run = True
+@@ -202,15 +209,18 @@ class Command(object):
+         """Waits on the given pattern to appear in std_out"""
+ 
          if self.blocking:
-             raise RuntimeError("expect can only be used on non-blocking commands.")
+-            raise RuntimeError('expect can only be used on non-blocking commands.')
++            raise RuntimeError("expect can only be used on non-blocking commands.")
  
 -        self.subprocess.expect(pattern=pattern, timeout=timeout)
 +        try:
@@ -40,7 +164,14 @@ index d15aeb97..56d12458 100644
  
      def send(self, s, end=os.linesep, signal=False):
          """Sends the given string or signal to std_in."""
-@@ -234,14 +240,25 @@ class Command(object):
+ 
+         if self.blocking:
+-            raise RuntimeError('send can only be used on non-blocking commands.')
++            raise RuntimeError("send can only be used on non-blocking commands.")
+ 
+         if not signal:
+             if self._uses_subprocess:
+@@ -233,14 +243,25 @@ class Command(object):
          """Blocks until process is complete."""
          if self._uses_subprocess:
              # consume stdout and stderr
@@ -73,7 +204,7 @@ index d15aeb97..56d12458 100644
  
      def pipe(self, command, timeout=None, cwd=None):
          """Runs the current command and passes its output to the next
-@@ -263,7 +280,6 @@ class Command(object):
+@@ -262,7 +283,6 @@ class Command(object):
          c.run(block=False, cwd=cwd)
          if data:
              c.send(data)
@@ -81,3 +212,24 @@ index d15aeb97..56d12458 100644
          c.block()
          return c
  
+@@ -273,12 +293,12 @@ def _expand_args(command):
+     # Prepare arguments.
+     if isinstance(command, STR_TYPES):
+         if sys.version_info[0] == 2:
+-            splitter = shlex.shlex(command.encode('utf-8'))
++            splitter = shlex.shlex(command.encode("utf-8"))
+         elif sys.version_info[0] == 3:
+             splitter = shlex.shlex(command)
+         else:
+-            splitter = shlex.shlex(command.encode('utf-8'))
+-        splitter.whitespace = '|'
++            splitter = shlex.shlex(command.encode("utf-8"))
++        splitter.whitespace = "|"
+         splitter.whitespace_split = True
+         command = []
+ 
+@@ -319,4 +339,3 @@ def run(command, block=True, binary=False, timeout=TIMEOUT, cwd=None, env=None):
+         c.block()
+ 
+     return c
+-
diff --git a/tests/integration/conftest.py b/tests/integration/conftest.py
index 7f797f99..5f5c1930 100644
--- a/tests/integration/conftest.py
+++ b/tests/integration/conftest.py
@@ -10,10 +10,11 @@ from pipenv.vendor import delegator
 from pipenv.vendor import requests
 from pipenv.vendor import toml
 from pytest_pypi.app import prepare_packages as prepare_pypi_packages
-from vistir.compat import ResourceWarning
+from vistir.compat import ResourceWarning, fs_str
+from vistir.path import mkdir_p
 
 
-warnings.filterwarnings("default", category=ResourceWarning)
+warnings.simplefilter("default", category=ResourceWarning)
 
 
 HAS_WARNED_GITHUB = False
@@ -85,83 +86,32 @@ def isolate(pathlib_tmpdir):
     We use an autouse function scoped fixture because we want to ensure that
     every test has it's own isolated home directory.
     """
-    warnings.filterwarnings("ignore", category=ResourceWarning)
-    warnings.filterwarnings("ignore", category=ResourceWarning, message="unclosed.*<ssl.SSLSocket.*>")
-
 
     # Create a directory to use as our home location.
     home_dir = os.path.join(str(pathlib_tmpdir), "home")
-    os.environ["PIPENV_NOSPIN"] = "1"
     os.makedirs(home_dir)
-
-    # Create a directory to use as a fake root
-    fake_root = os.path.join(str(pathlib_tmpdir), "fake-root")
-    os.makedirs(fake_root)
-
-    # if sys.platform == 'win32':
-    #     # Note: this will only take effect in subprocesses...
-    #     home_drive, home_path = os.path.splitdrive(home_dir)
-    #     os.environ.update({
-    #         'USERPROFILE': home_dir,
-    #         'HOMEDRIVE': home_drive,
-    #         'HOMEPATH': home_path,
-    #     })
-    #     for env_var, sub_path in (
-    #         ('APPDATA', 'AppData/Roaming'),
-    #         ('LOCALAPPDATA', 'AppData/Local'),
-    #     ):
-    #         path = os.path.join(home_dir, *sub_path.split('/'))
-    #         os.environ[env_var] = path
-    #         os.makedirs(path)
-    # else:
-    #     # Set our home directory to our temporary directory, this should force
-    #     # all of our relative configuration files to be read from here instead
-    #     # of the user's actual $HOME directory.
-    #     os.environ["HOME"] = home_dir
-    #     # Isolate ourselves from XDG directories
-    #     os.environ["XDG_DATA_HOME"] = os.path.join(home_dir, ".local", "share")
-    #     os.environ["XDG_CONFIG_HOME"] = os.path.join(home_dir, ".config")
-    #     os.environ["XDG_CACHE_HOME"] = os.path.join(home_dir, ".cache")
-    #     os.environ["XDG_RUNTIME_DIR"] = os.path.join(home_dir, ".runtime")
-    #     os.environ["XDG_DATA_DIRS"] = ":".join([
-    #         os.path.join(fake_root, "usr", "local", "share"),
-    #         os.path.join(fake_root, "usr", "share"),
-    #     ])
-    #     os.environ["XDG_CONFIG_DIRS"] = os.path.join(fake_root, "etc", "xdg")
-
-    # Configure git, because without an author name/email git will complain
-    # and cause test failures.
-    os.environ["GIT_CONFIG_NOSYSTEM"] = "1"
-    os.environ["GIT_AUTHOR_NAME"] = "pipenv"
-    os.environ["GIT_AUTHOR_EMAIL"] = "pipenv@pipenv.org"
-
-    # We want to disable the version check from running in the tests
-    os.environ["PIP_DISABLE_PIP_VERSION_CHECK"] = "true"
-    workon_home = os.path.join(home_dir, ".virtualenvs")
-    os.makedirs(workon_home)
-    os.environ["WORKON_HOME"] = workon_home
-    project_dir = os.path.join(home_dir, "pipenv_project")
-    os.makedirs(project_dir)
-    os.environ["PIPENV_PROJECT_DIR"] = project_dir
-    os.environ["CI"] = "1"
-
-    # Make sure tests don't share a requirements tracker.
-    os.environ.pop('PIP_REQ_TRACKER', None)
-
-    # FIXME: Windows...
-    os.makedirs(os.path.join(home_dir, ".config", "git"))
+    mkdir_p(os.path.join(home_dir, ".config", "git"))
     with open(os.path.join(home_dir, ".config", "git", "config"), "wb") as fp:
         fp.write(
             b"[user]\n\tname = pipenv\n\temail = pipenv@pipenv.org\n"
         )
+    os.environ["GIT_CONFIG_NOSYSTEM"] = fs_str("1")
+    os.environ["GIT_AUTHOR_NAME"] = fs_str("pipenv")
+    os.environ["GIT_AUTHOR_EMAIL"] = fs_str("pipenv@pipenv.org")
+    mkdir_p(os.path.join(home_dir, ".virtualenvs"))
+    os.environ["WORKON_HOME"] = fs_str(os.path.join(home_dir, ".virtualenvs"))
 
 
 class _PipenvInstance(object):
     """An instance of a Pipenv Project..."""
-    def __init__(self, pypi=None, pipfile=True, chdir=False, path=None):
+    def __init__(self, pypi=None, pipfile=True, chdir=False, path=None, home_dir=None):
         self.pypi = pypi
         self.original_umask = os.umask(0o007)
         self.original_dir = os.path.abspath(os.curdir)
+        os.environ["PIPENV_NOSPIN"] = fs_str("1")
+        os.environ["CI"] = fs_str("1")
+        warnings.simplefilter("ignore", category=ResourceWarning)
+        warnings.filterwarnings("ignore", category=ResourceWarning, message="unclosed.*<ssl.SSLSocket.*>")
         path = os.environ.get("PIPENV_PROJECT_DIR", None)
         if not path:
             self._path = TemporaryDirectory(suffix='-project', prefix='pipenv-')
@@ -178,7 +128,7 @@ class _PipenvInstance(object):
         self.chdir = chdir
 
         if self.pypi:
-            os.environ['PIPENV_TEST_INDEX'] = '{0}/simple'.format(self.pypi.url)
+            os.environ['PIPENV_TEST_INDEX'] = fs_str('{0}/simple'.format(self.pypi.url))
 
         if pipfile:
             p_path = os.sep.join([self.path, 'Pipfile'])
@@ -189,10 +139,10 @@ class _PipenvInstance(object):
             self.pipfile_path = p_path
 
     def __enter__(self):
-        os.environ['PIPENV_DONT_USE_PYENV'] = '1'
-        os.environ['PIPENV_IGNORE_VIRTUALENVS'] = '1'
-        os.environ['PIPENV_VENV_IN_PROJECT'] = '1'
-        os.environ['PIPENV_NOSPIN'] = '1'
+        os.environ['PIPENV_DONT_USE_PYENV'] = fs_str('1')
+        os.environ['PIPENV_IGNORE_VIRTUALENVS'] = fs_str('1')
+        os.environ['PIPENV_VENV_IN_PROJECT'] = fs_str('1')
+        os.environ['PIPENV_NOSPIN'] = fs_str('1')
         if self.chdir:
             os.chdir(self.path)
         return self
@@ -212,11 +162,11 @@ class _PipenvInstance(object):
 
     def pipenv(self, cmd, block=True):
         if self.pipfile_path:
-            os.environ['PIPENV_PIPFILE'] = self.pipfile_path
+            os.environ['PIPENV_PIPFILE'] = fs_str(self.pipfile_path)
         # a bit of a hack to make sure the virtualenv is created
 
         with TemporaryDirectory(prefix='pipenv-', suffix='-cache') as tempdir:
-            os.environ['PIPENV_CACHE_DIR'] = tempdir.name
+            os.environ['PIPENV_CACHE_DIR'] = fs_str(tempdir.name)
             c = delegator.run('pipenv {0}'.format(cmd), block=block)
             if 'PIPENV_CACHE_DIR' in os.environ:
                 del os.environ['PIPENV_CACHE_DIR']
@@ -261,11 +211,11 @@ def PipenvInstance():
 def pip_src_dir(request):
     old_src_dir = os.environ.get('PIP_SRC', '')
     new_src_dir = TemporaryDirectory(prefix='pipenv-', suffix='-testsrc')
-    os.environ['PIP_SRC'] = new_src_dir.name
+    os.environ['PIP_SRC'] = fs_str(new_src_dir.name)
 
     def finalize():
         new_src_dir.cleanup()
-        os.environ['PIP_SRC'] = old_src_dir
+        os.environ['PIP_SRC'] = fs_str(old_src_dir)
 
     request.addfinalizer(finalize)
     return request

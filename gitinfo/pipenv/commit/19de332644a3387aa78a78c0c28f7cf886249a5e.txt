commit 19de332644a3387aa78a78c0c28f7cf886249a5e
Author: Dan Ryan <dan@danryan.co>
Date:   Wed Jan 24 03:33:29 2018 -0500

    Broad fixes to testing infrastructure
    
    - Add custom rmtree function to handle windows rms
    - Only warn on failure to remove a tree
    - This should mitigate a large portion of our windows test failures
    - After sufficiently substantial time investment I am currently of the
    opinion that there is no real elegant way to handle this (I have tried
    programmatically finding all processes with open file handles,
    terminating them with a 500ms retry and a 15s timeout)
    - Close and handle tempfiles in resolvers
    - Only create tempfiles for non-editable deps
    - set umask and `PIP_SRC` for test context
    - Warn instead of throwing exceptions
    - Backport TemporaryDirectory for python2/3 compatibility and reliance
    on custom rmtree error handling
    - Vendor backport of `weakref.finalize` for
    `TemporaryDirectory.cleanup()`
    - Add PyTest fixtures to wrap and cleanup `PIP_SRC` directory at the module level to avoid permissions errors on appveyor
    - Add resource warnings for PY2 compat
    Lock instead of installing complex resolver test
    - Add a special condition for allowing access errors

diff --git a/pipenv/core.py b/pipenv/core.py
index b13cece9..bb99a14b 100644
--- a/pipenv/core.py
+++ b/pipenv/core.py
@@ -1341,9 +1341,9 @@ def pip_install(
         pip.logger.setLevel(logging.INFO)
 
     # Create files for hash mode.
-    if (not ignore_hashes) and (r is None):
-        r = tempfile.mkstemp(prefix='pipenv-', suffix='-requirement.txt')[1]
-        with open(r, 'w') as f:
+    if not package_name.startswith('-e ') and (not ignore_hashes) and (r is None):
+        fd, r = tempfile.mkstemp(prefix='pipenv-', suffix='-requirement.txt')
+        with os.fdopen(fd, 'w') as f:
             f.write(package_name)
 
     # Install dependencies when a package is a VCS dependency.
@@ -1380,10 +1380,10 @@ def pip_install(
         sources = project.sources
 
     for source in sources:
-        if r:
-            install_reqs = ' -r {0}'.format(r)
-        elif package_name.startswith('-e '):
+        if package_name.startswith('-e '):
             install_reqs = ' -e "{0}"'.format(package_name.split('-e ')[1])
+        elif r:
+            install_reqs = ' -r {0}'.format(r)
         else:
             install_reqs = ' "{0}"'.format(package_name)
 
diff --git a/pipenv/utils.py b/pipenv/utils.py
index e7323824..ebe1d939 100644
--- a/pipenv/utils.py
+++ b/pipenv/utils.py
@@ -6,13 +6,19 @@ import tempfile
 import sys
 import shutil
 import logging
-
+import errno
 import click
 import crayons
 import delegator
 import parse
 import requests
 import six
+import stat
+import warnings
+try:
+    from weakref import finalize
+except ImportError:
+    from backports.weakref import finalize
 from time import time
 
 logging.basicConfig(level=logging.ERROR)
@@ -41,6 +47,10 @@ from requests.exceptions import HTTPError, ConnectionError
 from .pep508checker import lookup
 from .environments import SESSION_IS_INTERACTIVE, PIPENV_MAX_ROUNDS, PIPENV_CACHE_DIR
 
+if six.PY2:
+    class ResourceWarning(Warning):
+        pass
+
 specifiers = [k for k in lookup.keys()]
 
 # List of version control systems we support.
@@ -255,14 +265,15 @@ def actually_resolve_reps(deps, index_lookup, markers_lookup, project, sources,
 
     constraints = []
 
+    req_dir = tempfile.mkdtemp(prefix='pipenv-', suffix='-requirements')
     for dep in deps:
-        t = tempfile.mkstemp(prefix='pipenv-', suffix='-requirement.txt')[1]
-        with open(t, 'w') as f:
-            f.write(dep)
-
         if dep.startswith('-e '):
             constraint = pip.req.InstallRequirement.from_editable(dep[len('-e '):])
         else:
+            fd, t = tempfile.mkstemp(prefix='pipenv-', suffix='-requirement.txt', dir=req_dir)
+            with os.fdopen(fd, 'w') as f:
+                f.write(dep)
+
             constraint = [c for c in pip.req.parse_requirements(t, session=pip._vendor.requests)][0]
             # extra_constraints = []
 
@@ -274,6 +285,8 @@ def actually_resolve_reps(deps, index_lookup, markers_lookup, project, sources,
 
         constraints.append(constraint)
 
+    rmtree(req_dir)
+
     pip_command = get_pip_command()
 
     pip_args = []
@@ -611,6 +624,7 @@ def convert_deps_to_pip(deps, project=None, r=True, include_index=False):
     # Write requirements.txt to tmp directory.
     f = tempfile.NamedTemporaryFile(suffix='-requirements.txt', delete=False)
     f.write('\n'.join(dependencies).encode('utf-8'))
+    f.close()
     return f.name
 
 
@@ -955,6 +969,7 @@ def temp_environ():
         os.environ.clear()
         os.environ.update(environ)
 
+
 def is_valid_url(url):
     """Checks if a given string is an url"""
     pieces = urlparse(url)
@@ -1011,3 +1026,84 @@ def normalize_drive(path):
     if drive.islower() and len(drive) == 2 and drive[1] == ':':
         return '{}{}'.format(drive.upper(), tail)
     return path
+
+
+def is_readonly_path(fn):
+    """Check if a provided path exists and is readonly.
+
+    Permissions check is `bool(path.stat & stat.S_IREAD)` or `not os.access(path, os.W_OK)`
+    """
+    if os.path.exists(fn):
+        return (os.stat(fn).st_mode & stat.S_IREAD) or not os.access(fn, os.W_OK)
+    return False
+
+
+def set_write_bit(fn):
+    if os.path.exists(fn):
+        os.chmod(fn, stat.S_IWRITE | stat.S_IWUSR)
+    return
+
+
+def rmtree(directory, ignore_errors=False):
+    shutil.rmtree(directory, ignore_errors=ignore_errors, onerror=handle_remove_readonly)
+
+
+def handle_remove_readonly(func, path, exc):
+    """Error handler for shutil.rmtree.
+
+    Windows source repo folders are read-only by default, so this error handler
+    attempts to set them as writeable and then proceed with deletion."""
+    # Check for read-only attribute
+    default_warning_message = 'Unable to remove file due to permissions restriction: {!r}'
+    # split the initial exception out into its type, exception, and traceback
+    exc_type, exc_exception, exc_tb = exc
+    if is_readonly_path(path):
+        # Apply write permission and call original function
+        set_write_bit(path)
+        try:
+            func(path)
+        except (OSError, IOError) as e:
+            if e.errno in [errno.EACCES, errno.EPERM]:
+                warnings.warn(default_warning_message.format(path), ResourceWarning)
+                return
+    if exc_exception.errno in [errno.EACCES, errno.EPERM]:
+        warnings.warn(default_warning_message.format(path), ResourceWarning)
+        return
+    raise
+
+
+class TemporaryDirectory(object):
+    """Create and return a temporary directory.  This has the same
+    behavior as mkdtemp but can be used as a context manager.  For
+    example:
+
+        with TemporaryDirectory() as tmpdir:
+            ...
+
+    Upon exiting the context, the directory and everything contained
+    in it are removed.
+    """
+
+    def __init__(self, suffix=None, prefix=None, dir=None):
+        self.name = tempfile.mkdtemp(suffix, prefix, dir)
+        self._finalizer = finalize(
+            self, self._cleanup, self.name,
+            warn_message="Implicitly cleaning up {!r}".format(self))
+
+    @classmethod
+    def _cleanup(cls, name, warn_message):
+        rmtree(name)
+        warnings.warn(warn_message, ResourceWarning)
+
+    def __repr__(self):
+        return "<{} {!r}>".format(self.__class__.__name__, self.name)
+
+    def __enter__(self):
+        return self.name
+
+    def __exit__(self, exc, value, tb):
+        self.cleanup()
+
+    def cleanup(self):
+        if self._finalizer.detach():
+            rmtree(self.name)
diff --git a/pipenv/vendor/backports/weakref/__init__.py b/pipenv/vendor/backports/weakref/__init__.py
new file mode 100644
index 00000000..815bcb4c
--- /dev/null
+++ b/pipenv/vendor/backports/weakref/__init__.py
@@ -0,0 +1,10 @@
+"""
+Partial backport of Python 3.6's weakref module:
+
+    finalize (new in Python 3.4)
+
+Backport modifications are marked with "XXX backport".
+"""
+__all__ = ["finalize"]
+
+from .weakref import finalize
diff --git a/pipenv/vendor/backports/weakref/weakref.py b/pipenv/vendor/backports/weakref/weakref.py
new file mode 100644
index 00000000..de6193bd
--- /dev/null
+++ b/pipenv/vendor/backports/weakref/weakref.py
@@ -0,0 +1,151 @@
+"""
+Partial backport of Python 3.6's weakref module:
+
+    finalize (new in Python 3.4)
+
+Backport modifications are marked with "XXX backport".
+"""
+from __future__ import absolute_import
+
+import itertools
+import sys
+from weakref import ref
+
+__all__ = ['finalize']
+
+
+class finalize(object):
+    """Class for finalization of weakrefable objects
+
+    finalize(obj, func, *args, **kwargs) returns a callable finalizer
+    object which will be called when obj is garbage collected. The
+    first time the finalizer is called it evaluates func(*arg, **kwargs)
+    and returns the result. After this the finalizer is dead, and
+    calling it just returns None.
+
+    When the program exits any remaining finalizers for which the
+    atexit attribute is true will be run in reverse order of creation.
+    By default atexit is true.
+    """
+
+    # Finalizer objects don't have any state of their own.  They are
+    # just used as keys to lookup _Info objects in the registry.  This
+    # ensures that they cannot be part of a ref-cycle.
+
+    __slots__ = ()
+    _registry = {}
+    _shutdown = False
+    _index_iter = itertools.count()
+    _dirty = False
+    _registered_with_atexit = False
+
+    class _Info(object):
+        __slots__ = ("weakref", "func", "args", "kwargs", "atexit", "index")
+
+    def __init__(self, obj, func, *args, **kwargs):
+        if not self._registered_with_atexit:
+            # We may register the exit function more than once because
+            # of a thread race, but that is harmless
+            import atexit
+            atexit.register(self._exitfunc)
+            finalize._registered_with_atexit = True
+        info = self._Info()
+        info.weakref = ref(obj, self)
+        info.func = func
+        info.args = args
+        info.kwargs = kwargs or None
+        info.atexit = True
+        info.index = next(self._index_iter)
+        self._registry[self] = info
+        finalize._dirty = True
+
+    def __call__(self, _=None):
+        """If alive then mark as dead and return func(*args, **kwargs);
+        otherwise return None"""
+        info = self._registry.pop(self, None)
+        if info and not self._shutdown:
+            return info.func(*info.args, **(info.kwargs or {}))
+
+    def detach(self):
+        """If alive then mark as dead and return (obj, func, args, kwargs);
+        otherwise return None"""
+        info = self._registry.get(self)
+        obj = info and info.weakref()
+        if obj is not None and self._registry.pop(self, None):
+            return (obj, info.func, info.args, info.kwargs or {})
+
+    def peek(self):
+        """If alive then return (obj, func, args, kwargs);
+        otherwise return None"""
+        info = self._registry.get(self)
+        obj = info and info.weakref()
+        if obj is not None:
+            return (obj, info.func, info.args, info.kwargs or {})
+
+    @property
+    def alive(self):
+        """Whether finalizer is alive"""
+        return self in self._registry
+
+    @property
+    def atexit(self):
+        """Whether finalizer should be called at exit"""
+        info = self._registry.get(self)
+        return bool(info) and info.atexit
+
+    @atexit.setter
+    def atexit(self, value):
+        info = self._registry.get(self)
+        if info:
+            info.atexit = bool(value)
+
+    def __repr__(self):
+        info = self._registry.get(self)
+        obj = info and info.weakref()
+        if obj is None:
+            return '<%s object at %#x; dead>' % (type(self).__name__, id(self))
+        else:
+            return '<%s object at %#x; for %r at %#x>' % \
+                (type(self).__name__, id(self), type(obj).__name__, id(obj))
+
+    @classmethod
+    def _select_for_exit(cls):
+        # Return live finalizers marked for exit, oldest first
+        L = [(f,i) for (f,i) in cls._registry.items() if i.atexit]
+        L.sort(key=lambda item:item[1].index)
+        return [f for (f,i) in L]
+
+    @classmethod
+    def _exitfunc(cls):
+        # At shutdown invoke finalizers for which atexit is true.
+        # This is called once all other non-daemonic threads have been
+        # joined.
+        reenable_gc = False
+        try:
+            if cls._registry:
+                import gc
+                if gc.isenabled():
+                    reenable_gc = True
+                    gc.disable()
+                pending = None
+                while True:
+                    if pending is None or finalize._dirty:
+                        pending = cls._select_for_exit()
+                        finalize._dirty = False
+                    if not pending:
+                        break
+                    f = pending.pop()
+                    try:
+                        # gc is disabled, so (assuming no daemonic
+                        # threads) the following is the only line in
+                        # this function which might trigger creation
+                        # of a new finalizer
+                        f()
+                    except Exception:
+                        sys.excepthook(*sys.exc_info())
+                    assert f not in cls._registry
+        finally:
+            # prevent any more finalizers from executing during shutdown
+            finalize._shutdown = True
+            if reenable_gc:
+                gc.enable()
diff --git a/tests/test_pipenv.py b/tests/test_pipenv.py
index 4bf0d98d..6e92fed1 100644
--- a/tests/test_pipenv.py
+++ b/tests/test_pipenv.py
@@ -4,27 +4,49 @@ import re
 import tempfile
 import shutil
 import json
-
 import pytest
-
+import warnings
 from pipenv.core import activate_virtualenv
-from pipenv.utils import temp_environ, get_windows_path, mkdir_p, normalize_drive
+from pipenv.utils import (
+    temp_environ, get_windows_path, mkdir_p, normalize_drive, rmtree, TemporaryDirectory
+)
 from pipenv.vendor import toml
 from pipenv.vendor import delegator
 from pipenv.project import Project
+from pipenv.vendor.six import PY2
+if PY2:
+    class ResourceWarning(Warning):
+        pass
+
 try:
     from pathlib import Path
 except:
     from pipenv.vendor.pathlib2 import Path
 
 os.environ['PIPENV_DONT_USE_PYENV'] = '1'
+os.environ['PIPENV_IGNORE_VIRTUALENVS'] = '1'
+
+
+@pytest.fixture(scope='module')
+def pip_src_dir(request):
+    old_src_dir = os.environ.get('PIP_SRC', '')
+    new_src_dir = TemporaryDirectory(prefix='pipenv-', suffix='-testsrc')
+    os.environ['PIP_SRC'] = new_src_dir.name
+    def finalize():
+        new_src_dir.cleanup()
+        os.environ['PIP_SRC'] = old_src_dir
+    request.addfinalizer(finalize)
+    return request
 
 
 class PipenvInstance():
     """An instance of a Pipenv Project..."""
     def __init__(self, pipfile=True, chdir=False):
+        self.original_umask = os.umask(0o007)
         self.original_dir = os.path.abspath(os.curdir)
-        self.path = tempfile.mkdtemp(suffix='project', prefix='pipenv')
+        self._path = TemporaryDirectory(suffix='project', prefix='pipenv')
+        self.path = self._path.name
+        # set file creation perms
         self.pipfile_path = None
         self.chdir = chdir
 
@@ -42,10 +64,17 @@ class PipenvInstance():
         return self
 
     def __exit__(self, *args):
+        warn_msg = 'Failed to remove resource: {!r}'
         if self.chdir:
             os.chdir(self.original_dir)
-
-        shutil.rmtree(self.path)
+        self.path = None
+        try:
+            self._path.cleanup()
+        except OSError as e:
+            _warn_msg = warn_msg.format(e)
+            warnings.warn(_warn_msg, ResourceWarning)
+        finally:
+            os.umask(self.original_umask)
 
     def pipenv(self, cmd, block=True):
         if self.pipfile_path:
@@ -149,11 +178,6 @@ class TestPipenv:
         with PipenvInstance() as p:
             assert p.pipenv('--envs').out
 
-    @pytest.mark.cli
-    def test_venv_jumbotron(self):
-        with PipenvInstance() as p:
-            assert p.pipenv('--jumbotron').out
-
     @pytest.mark.cli
     def test_bare_output(self):
         with PipenvInstance() as p:
@@ -411,7 +435,7 @@ setup(
     @pytest.mark.e
     @pytest.mark.vcs
     @pytest.mark.install
-    def test_editable_vcs_install(self):
+    def test_editable_vcs_install(self, pip_src_dir):
         with PipenvInstance() as p:
             c = p.pipenv('install -e git+https://github.com/requests/requests.git#egg=requests')
             assert c.return_code == 0
@@ -585,7 +609,7 @@ requests = {version = "*", os_name = "== 'splashwear'"}
     @pytest.mark.install
     @pytest.mark.vcs
     @pytest.mark.tablib
-    def test_install_editable_git_tag(self):
+    def test_install_editable_git_tag(self, pip_src_dir):
         with PipenvInstance() as p:
             c = p.pipenv('install -e git+https://github.com/kennethreitz/tablib.git@v0.12.1#egg=tablib')
             assert c.return_code == 0
@@ -701,7 +725,7 @@ requests = {version = "*"}
     @pytest.mark.e
     @pytest.mark.install
     @pytest.mark.skip(reason="this doesn't work on windows")
-    def test_e_dot(self):
+    def test_e_dot(self, pip_src_dir):
 
         with PipenvInstance() as p:
             path = os.path.abspath(os.path.sep.join([os.path.dirname(__file__), '..']))
@@ -732,20 +756,23 @@ requests = {version = "*"}
     def test_check_unused(self):
 
         with PipenvInstance() as p:
-
             with PipenvInstance(chdir=True) as p:
-                with open('t.py', 'w') as f:
-                    f.write('import git')
-
+                with open('__init__.py', 'w') as f:
+                    contents = """
+import tablib
+import records
+                    """.strip()
+                    f.write(contents)
                 p.pipenv('install GitPython')
                 p.pipenv('install requests')
                 p.pipenv('install tablib')
+                p.pipenv('install records')
 
-                assert 'requests' in p.pipfile['packages']
+                assert all(pkg in p.pipfile['packages'] for pkg in ['requests', 'tablib', 'records', 'gitpython'])
 
                 c = p.pipenv('check --unused .')
-                assert 'GitPython' not in c.out
-                assert 'tablib' in c.out
+                assert 'gitpython' in c.out
+                assert 'tablib' not in c.out
 
     @pytest.mark.extras
     @pytest.mark.install
@@ -815,7 +842,7 @@ pytest = "==3.1.1"
 
     @pytest.mark.lock
     @pytest.mark.complex
-    def test_complex_lock_with_vcs_deps(self):
+    def test_complex_lock_with_vcs_deps(self, pip_src_dir):
 
         with PipenvInstance() as p:
             with open(p.pipfile_path, 'w') as f:
@@ -959,7 +986,7 @@ requests = "==2.14.0"
     @pytest.mark.install
     @pytest.mark.files
     @pytest.mark.resolver
-    def test_local_package(self):
+    def test_local_package(self, pip_src_dir):
         """This test ensures that local packages (directories with a setup.py)
         installed in editable mode have their dependencies resolved as well"""
         file_name = 'tablib-0.12.1.tar.gz'

commit 0f5b365f84ba236156f47184641eaa13a8606024
Author: Dan Ryan <dan@danryan.co>
Date:   Sat Nov 3 20:02:32 2018 -0400

    Performance fixes and updates
    
    - Cuts runtime of normal commands by about 2/3
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/news/3158.feature.rst b/news/3158.feature.rst
new file mode 100644
index 00000000..08113e54
--- /dev/null
+++ b/news/3158.feature.rst
@@ -0,0 +1 @@
+Improved runtime performance of no-op commands such as ``pipenv --venv`` by around 2/3.
diff --git a/pipenv/project.py b/pipenv/project.py
index 0b32811d..c03a0e83 100644
--- a/pipenv/project.py
+++ b/pipenv/project.py
@@ -6,7 +6,6 @@ import re
 import sys
 import glob
 import base64
-import itertools
 import fnmatch
 import hashlib
 import contoml
@@ -47,7 +46,6 @@ from .environments import (
     PIPENV_DEFAULT_PYTHON_VERSION,
     PIPENV_CACHE_DIR
 )
-from requirementslib.utils import is_vcs
 
 
 def _normalized(p):
@@ -173,6 +171,7 @@ class Project(object):
 
     def _build_package_list(self, package_section):
         """Returns a list of packages for pip-tools to consume."""
+        from pipenv.vendor.requirementslib.utils import is_vcs
         ps = {}
         # TODO: Separate the logic for showing packages from the filters for supplying pip-tools
         for k, v in self.parsed_pipfile.get(package_section, {}).items():
@@ -670,11 +669,12 @@ class Project(object):
         packages = {
             k: v
             for k, v in self.parsed_pipfile.get(section, {}).items()
-            if is_editable(v)
+            if is_editable(k) or is_editable(v)
         }
         return packages
 
     def _get_vcs_packages(self, dev=False):
+        from pipenv.vendor.requirementslib.utils import is_vcs
         section = "dev-packages" if dev else "packages"
         packages = {
             k: v
@@ -1132,42 +1132,22 @@ class Project(object):
         prefix = vistir.compat.Path(location)
         import importlib
         py_version = tuple([int(v) for v in self.py_version.split(".")])
+        py_version_short = ".".join([str(v) for v in py_version[:2]])
+        running_version = ".".join([str(v) for v in sys.version_info[:2]])
         try:
-            with sys_version(py_version):
-                _virtualenv = importlib.import_module("virtualenv")
-        except ImportError:
+            _virtualenv = importlib.import_module("virtualenv")
+        except (ImportError, AttributeError):
             with vistir.contextmanagers.temp_path():
-                from string import Formatter
-                formatter = Formatter()
-                import sysconfig
-                if getattr(sys, "real_prefix", None):
-                    scheme = sysconfig._get_default_scheme()
-                    sysconfig._INSTALL_SCHEMES["posix_prefix"]["purelib"]
-                    if not scheme:
-                        scheme = "posix_prefix" if not sys.platform == "win32" else "nt"
-                    is_purelib = "purelib" in sysconfig._INSTALL_SCHEMES[scheme]
-                    lib_key = "purelib" if is_purelib else "platlib"
-                    lib = sysconfig._INSTALL_SCHEMES[scheme][lib_key]
-                    fields = [field for _, field, _, _ in formatter.parse() if field]
-                    config = {
-                        "py_version_short": self._pyversion,
-                    }
-                    for field in fields:
-                        if field not in config:
-                            config[field] = prefix
-                    sys.path = [
-                        os.path.join(sysconfig._INSTALL_SCHEMES[scheme][lib_key], "site-packages"),
-                    ] + sys.path
-                    with sys_version(py_version):
-                        six.reload_module(importlib)
-                        _virtualenv = importlib.import_module("virtualenv")
+                sys.path = vistir.misc.load_path(self.which("python"))
+                six.moves.reload_module(importlib)
+                _virtualenv = importlib.import_module("virtualenv")
         with sys_version(py_version):
             home, lib, inc, bin_ = _virtualenv.path_locations(prefix.absolute().as_posix())
         paths = {
-            "lib": lib,
-            "include": inc,
+            "lib": lib.replace(running_version, py_version_short),
+            "include": inc.replace(running_version, py_version_short),
             "scripts": bin_,
-            "purelib": lib,
+            "purelib": lib.replace(running_version, py_version_short),
             "prefix": home,
             "base": home
         }
diff --git a/pipenv/vendor/requirementslib/models/__init__.py b/pipenv/vendor/requirementslib/models/__init__.py
index 99e519d6..e819cdd5 100644
--- a/pipenv/vendor/requirementslib/models/__init__.py
+++ b/pipenv/vendor/requirementslib/models/__init__.py
@@ -1,10 +1,2 @@
 # -*- coding: utf-8 -*-
-from __future__ import absolute_import
-
-
-__all__ = ["Requirement", "Lockfile", "Pipfile"]
-
-
-from .requirements import Requirement
-from .lockfile import Lockfile
-from .pipfile import Pipfile
+# This is intentionally left blank
diff --git a/pipenv/vendor/requirementslib/models/cache.py b/pipenv/vendor/requirementslib/models/cache.py
index 71701090..0b8c47b1 100644
--- a/pipenv/vendor/requirementslib/models/cache.py
+++ b/pipenv/vendor/requirementslib/models/cache.py
@@ -7,7 +7,6 @@ import json
 import os
 import sys
 
-import requests
 import vistir
 
 from appdirs import user_cache_dir
@@ -17,7 +16,6 @@ from packaging.requirements import Requirement
 from .utils import as_tuple, key_from_req, lookup_table, get_pinned_version
 
 from ..exceptions import FileExistsError
-from ..utils import VCS_SUPPORT
 
 
 CACHE_DIR = os.environ.get("PIPENV_CACHE_DIR", user_cache_dir("pipenv"))
@@ -195,16 +193,20 @@ class HashCache(SafeFileCache):
     avoid ssues where the location on the server changes.
     """
     def __init__(self, *args, **kwargs):
-        session = kwargs.pop('session', requests.session())
+        session = kwargs.pop("session", None)
+        if not session:
+            import requests
+            session = requests.session()
         cache_dir = kwargs.pop('cache_dir', CACHE_DIR)
         self.session = session
         kwargs.setdefault('directory', os.path.join(cache_dir, 'hash-cache'))
         super(HashCache, self).__init__(*args, **kwargs)
 
     def get_hash(self, location):
+        from pip_shims import VcsSupport
         # if there is no location hash (i.e., md5 / sha256 / etc) we on't want to store it
         hash_value = None
-        vcs = VCS_SUPPORT
+        vcs = VcsSupport()
         orig_scheme = location.scheme
         new_location = copy.deepcopy(location)
         if orig_scheme in vcs.all_schemes:
diff --git a/pipenv/vendor/requirementslib/models/dependencies.py b/pipenv/vendor/requirementslib/models/dependencies.py
index c3df222f..48e84d0f 100644
--- a/pipenv/vendor/requirementslib/models/dependencies.py
+++ b/pipenv/vendor/requirementslib/models/dependencies.py
@@ -9,21 +9,17 @@ import attr
 import packaging.markers
 import packaging.version
 import requests
-import warnings
 
 from first import first
 from packaging.utils import canonicalize_name
 
-from pip_shims import (
-    FormatControl, InstallRequirement, PackageFinder, RequirementPreparer,
-    RequirementSet, RequirementTracker, Resolver, WheelCache, pip_version
-)
+import pip_shims.shims
 from vistir.compat import JSONDecodeError, fs_str, ResourceWarning
 from vistir.contextmanagers import cd, temp_environ
 from vistir.misc import partialclass
 from vistir.path import create_tracked_tempdir
 
-from ..utils import get_pip_command, prepare_pip_source_args, _ensure_dir
+from ..utils import prepare_pip_source_args, _ensure_dir
 from .cache import CACHE_DIR, DependencyCache
 from .utils import (
     clean_requires_python, fix_requires_python_marker, format_requirement,
@@ -36,7 +32,9 @@ PKGS_DOWNLOAD_DIR = fs_str(os.path.join(CACHE_DIR, "pkgs"))
 WHEEL_DOWNLOAD_DIR = fs_str(os.path.join(CACHE_DIR, "wheels"))
 
 DEPENDENCY_CACHE = DependencyCache()
-WHEEL_CACHE = WheelCache(CACHE_DIR, FormatControl(set(), set()))
+WHEEL_CACHE = pip_shims.shims.WheelCache(
+    CACHE_DIR, pip_shims.shims.FormatControl(set(), set())
+)
 
 
 def _get_filtered_versions(ireq, versions, prereleases):
@@ -65,6 +63,29 @@ def find_all_matches(finder, ireq, pre=False):
     return candidates
 
 
+def get_pip_command():
+    # Use pip's parser for pip.conf management and defaults.
+    # General options (find_links, index_url, extra_index_url, trusted_host,
+    # and pre) are defered to pip.
+    import optparse
+
+    class PipCommand(pip_shims.shims.Command):
+        name = "PipCommand"
+
+    pip_command = PipCommand()
+    pip_command.parser.add_option(pip_shims.shims.cmdoptions.no_binary())
+    pip_command.parser.add_option(pip_shims.shims.cmdoptions.only_binary())
+    index_opts = pip_shims.shims.cmdoptions.make_option_group(
+        pip_shims.shims.cmdoptions.index_group, pip_command.parser
+    )
+    pip_command.parser.insert_option_group(0, index_opts)
+    pip_command.parser.add_option(
+        optparse.Option("--pre", action="store_true", default=False)
+    )
+
+    return pip_command
+
+
 @attr.s
 class AbstractDependency(object):
     name = attr.ib()
@@ -242,7 +263,7 @@ def get_abstract_dependencies(reqs, sources=None, parent=None):
     from .requirements import Requirement
 
     for req in reqs:
-        if isinstance(req, InstallRequirement):
+        if isinstance(req, pip_shims.shims.InstallRequirement):
             requirement = Requirement.from_line(
                 "{0}{1}".format(req.name, req.specifier)
             )
@@ -273,16 +294,16 @@ def get_dependencies(ireq, sources=None, parent=None):
     :return: A set of dependency lines for generating new InstallRequirements.
     :rtype: set(str)
     """
-    if not isinstance(ireq, InstallRequirement):
+    if not isinstance(ireq, pip_shims.shims.InstallRequirement):
         name = getattr(
             ireq, "project_name",
             getattr(ireq, "project", ireq.name),
         )
         version = getattr(ireq, "version", None)
         if not version:
-            ireq = InstallRequirement.from_line("{0}".format(name))
+            ireq = pip_shims.shims.InstallRequirement.from_line("{0}".format(name))
         else:
-            ireq = InstallRequirement.from_line("{0}=={1}".format(name, version))
+            ireq = pip_shims.shims.InstallRequirement.from_line("{0}=={1}".format(name, version))
     pip_options = get_pip_options(sources=sources)
     getters = [
         get_dependencies_from_cache,
@@ -354,7 +375,7 @@ def get_dependencies_from_json(ireq):
         if not requires_dist:   # The API can return None for this.
             return
         for requires in requires_dist:
-            i = InstallRequirement.from_line(requires)
+            i = pip_shims.shims.InstallRequirement.from_line(requires)
             # See above, we don't handle requirements with extras.
             if not _marker_contains_extra(i):
                 yield format_requirement(i)
@@ -389,7 +410,7 @@ def get_dependencies_from_cache(ireq):
     try:
         broken = False
         for line in cached:
-            dep_ireq = InstallRequirement.from_line(line)
+            dep_ireq = pip_shims.shims.InstallRequirement.from_line(line)
             name = canonicalize_name(dep_ireq.name)
             if _marker_contains_extra(dep_ireq):
                 broken = True   # The "extra =" marker breaks everything.
@@ -426,7 +447,7 @@ def get_dependencies_from_index(dep, sources=None, pip_options=None, wheel_cache
     if not wheel_cache:
         wheel_cache = WHEEL_CACHE
     dep.is_direct = True
-    reqset = RequirementSet()
+    reqset = pip_shims.shims.RequirementSet()
     reqset.add_requirement(dep)
     requirements = None
     setup_requires = {}
@@ -554,7 +575,7 @@ def get_finder(sources=None, pip_command=None, pip_options=None):
     if not pip_options:
         pip_options = get_pip_options(sources=sources, pip_command=pip_command)
     session = pip_command._build_session(pip_options)
-    finder = PackageFinder(
+    finder = pip_shims.shims.PackageFinder(
         find_links=[],
         index_urls=[s.get("url") for s in sources],
         trusted_hosts=[],
@@ -590,7 +611,7 @@ def start_resolver(finder=None, wheel_cache=None):
     _build_dir = create_tracked_tempdir(fs_str("build"))
     _source_dir = create_tracked_tempdir(fs_str("source"))
     preparer = partialclass(
-        RequirementPreparer,
+        pip_shims.shims.RequirementPreparer,
         build_dir=_build_dir,
         src_dir=_source_dir,
         download_dir=download_dir,
@@ -599,7 +620,7 @@ def start_resolver(finder=None, wheel_cache=None):
         build_isolation=False,
     )
     resolver = partialclass(
-        Resolver,
+        pip_shims.shims.Resolver,
         finder=finder,
         session=finder.session,
         upgrade_strategy="to-satisfy-only",
@@ -612,8 +633,8 @@ def start_resolver(finder=None, wheel_cache=None):
         use_user_site=False,
     )
     try:
-        if packaging.version.parse(pip_version) >= packaging.version.parse('18'):
-            with RequirementTracker() as req_tracker:
+        if packaging.version.parse(pip_shims.shims.pip_version) >= packaging.version.parse('18'):
+            with pip_shims.shims.RequirementTracker() as req_tracker:
                 preparer = preparer(req_tracker=req_tracker)
                 yield resolver(preparer=preparer)
         else:
diff --git a/pipenv/vendor/requirementslib/models/requirements.py b/pipenv/vendor/requirementslib/models/requirements.py
index 112791ab..e1a1e6eb 100644
--- a/pipenv/vendor/requirementslib/models/requirements.py
+++ b/pipenv/vendor/requirementslib/models/requirements.py
@@ -9,35 +9,54 @@ import os
 from contextlib import contextmanager
 
 import attr
-import six
+import pip_shims
 
 from first import first
 from packaging.markers import Marker
 from packaging.requirements import Requirement as PackagingRequirement
 from packaging.specifiers import Specifier, SpecifierSet
 from packaging.utils import canonicalize_name
-from pip_shims.shims import _strip_extras, parse_version, path_to_url, url_to_path, Link
 from six.moves.urllib import parse as urllib_parse
 from six.moves.urllib.parse import unquote
 from vistir.compat import FileNotFoundError, Path
 from vistir.misc import dedup
 from vistir.path import (
-    create_tracked_tempdir, get_converted_relative_path, is_file_url,
-    is_valid_url
+    create_tracked_tempdir,
+    get_converted_relative_path,
+    is_file_url,
+    is_valid_url,
 )
 
 from ..exceptions import RequirementError
-from ..utils import VCS_LIST, is_installable_file, is_vcs, ensure_setup_py
+from ..utils import (
+    VCS_LIST,
+    is_installable_file,
+    is_vcs,
+    ensure_setup_py,
+    add_ssh_scheme_to_git_uri,
+    strip_ssh_from_git_uri,
+)
 from .baserequirement import BaseRequirement
-from .markers import PipenvMarkers
 from .utils import (
-    HASH_STRING, add_ssh_scheme_to_git_uri, build_vcs_link, extras_to_string,
-    filter_none, format_requirement, get_version, init_requirement,
-    is_pinned_requirement, make_install_requirement, optional_instance_of, parse_extras,
-    specs_to_string, split_markers_from_line, ireq_from_editable, ireq_from_line,
-    split_vcs_method_from_uri, strip_ssh_from_git_uri, validate_path,
-    validate_specifiers, validate_vcs, normalize_name, create_link,
-    Requirement as PkgResourcesRequirement
+    HASH_STRING,
+    build_vcs_link,
+    extras_to_string,
+    filter_none,
+    format_requirement,
+    get_version,
+    init_requirement,
+    is_pinned_requirement,
+    make_install_requirement,
+    optional_instance_of,
+    parse_extras,
+    specs_to_string,
+    split_markers_from_line,
+    split_vcs_method_from_uri,
+    validate_path,
+    validate_specifiers,
+    validate_vcs,
+    normalize_name,
+    create_link,
 )
 
 
@@ -45,13 +64,15 @@ from .utils import (
 class NamedRequirement(BaseRequirement):
     name = attr.ib()
     version = attr.ib(validator=attr.validators.optional(validate_specifiers))
-    req = attr.ib(type=PkgResourcesRequirement)
+    req = attr.ib()
     extras = attr.ib(default=attr.Factory(list))
     editable = attr.ib(default=False)
 
     @req.default
     def get_requirement(self):
-        req = init_requirement("{0}{1}".format(canonicalize_name(self.name), self.version))
+        req = init_requirement(
+            "{0}{1}".format(canonicalize_name(self.name), self.version)
+        )
         return req
 
     @classmethod
@@ -84,7 +105,7 @@ class NamedRequirement(BaseRequirement):
         creation_args["version"] = version
         req = init_requirement("{0}{1}".format(name, version))
         if extras:
-            req.extras += tuple(extras,)
+            req.extras += tuple(extras)
         creation_args["req"] = req
         return cls(**creation_args)
 
@@ -187,9 +208,9 @@ class FileRequirement(BaseRequirement):
 
         parsed_url = urllib_parse.urlsplit(fixed_line)
         original_url = parsed_url._replace()
-        if added_ssh_scheme and ':' in parsed_url.netloc:
-            original_netloc, original_path_start = parsed_url.netloc.rsplit(':', 1)
-            uri_path = '/{0}{1}'.format(original_path_start, parsed_url.path)
+        if added_ssh_scheme and ":" in parsed_url.netloc:
+            original_netloc, original_path_start = parsed_url.netloc.rsplit(":", 1)
+            uri_path = "/{0}{1}".format(original_path_start, parsed_url.path)
             parsed_url = original_url._replace(netloc=original_netloc, path=uri_path)
 
         # Split the VCS part out if needed.
@@ -205,12 +226,14 @@ class FileRequirement(BaseRequirement):
         if parsed_url.scheme == "file" and parsed_url.path:
             # This is a "file://" URI. Use url_to_path and path_to_url to
             # ensure the path is absolute. Also we need to build relpath.
-            path = Path(url_to_path(urllib_parse.urlunsplit(parsed_url))).as_posix()
+            path = Path(
+                pip_shims.shims.url_to_path(urllib_parse.urlunsplit(parsed_url))
+            ).as_posix()
             try:
                 relpath = get_converted_relative_path(path)
             except ValueError:
                 relpath = None
-            uri = path_to_url(path)
+            uri = pip_shims.shims.path_to_url(path)
         else:
             # This is a remote URI. Simply use it.
             path = None
@@ -221,7 +244,9 @@ class FileRequirement(BaseRequirement):
             )
 
         if added_ssh_scheme:
-            original_uri = urllib_parse.urlunsplit(original_url._replace(scheme=original_scheme, fragment=""))
+            original_uri = urllib_parse.urlunsplit(
+                original_url._replace(scheme=original_scheme, fragment="")
+            )
             uri = strip_ssh_from_git_uri(original_uri)
 
         # Re-attach VCS prefix to build a Link.
@@ -235,7 +260,7 @@ class FileRequirement(BaseRequirement):
     def get_uri(self):
         if self.path and not self.uri:
             self._uri_scheme = "path"
-            self.uri = path_to_url(os.path.abspath(self.path))
+            self.uri = pip_shims.shims.path_to_url(os.path.abspath(self.path))
 
     @name.default
     def get_name(self):
@@ -247,6 +272,7 @@ class FileRequirement(BaseRequirement):
             return self.link.egg_fragment
         elif self.link and self.link.is_wheel:
             from pip_shims import Wheel
+
             return Wheel(self.link.filename).name
         if (
             self._uri_scheme != "uri"
@@ -272,9 +298,9 @@ class FileRequirement(BaseRequirement):
                     else:
                         _path = self.path
                     if self.editable:
-                        _ireq = ireq_from_editable(_path.as_uri())
+                        _ireq = pip_shims.shims.ireq_from_editable(_path.as_uri())
                     else:
-                        _ireq = ireq_from_line(_path.as_posix())
+                        _ireq = pip_shims.shims.ireq_from_line(_path.as_posix())
                     dist = make_abstract_dist(_ireq).get_dist()
                     name = dist.project_name
                 except (TypeError, ValueError, AttributeError) as e:
@@ -361,6 +387,7 @@ class FileRequirement(BaseRequirement):
         }
         if link and link.is_wheel:
             from pip_shims import Wheel
+
             arg_dict["name"] = Wheel(link.filename).name
         elif link.egg_fragment:
             arg_dict["name"] = link.egg_fragment
@@ -399,7 +426,7 @@ class FileRequirement(BaseRequirement):
             uri_scheme = "file"
 
         if not uri:
-            uri = path_to_url(path)
+            uri = pip_shims.shims.path_to_url(path)
         link = create_link(uri)
 
         arg_dict = {
@@ -414,12 +441,10 @@ class FileRequirement(BaseRequirement):
 
     @property
     def line_part(self):
-        if self._uri_scheme and self._uri_scheme == 'path':
+        if self._uri_scheme and self._uri_scheme == "path":
             seed = self.path or unquote(self.link.url_without_fragment) or self.uri
-        elif (
-            (self._uri_scheme and self._uri_scheme == "file")
-            or ((self.link.is_artifact or self.link.is_wheel)
-            and self.link.url)
+        elif (self._uri_scheme and self._uri_scheme == "file") or (
+            (self.link.is_artifact or self.link.is_wheel) and self.link.url
         ):
             seed = unquote(self.link.url_without_fragment) or self.uri
         # add egg fragments to remote artifacts (valid urls only)
@@ -500,7 +525,7 @@ class VCSRequirement(FileRequirement):
     def __attrs_post_init__(self):
         if not self.uri:
             if self.path:
-                self.uri = path_to_url(self.path)
+                self.uri = pip_shims.shims.path_to_url(self.path)
         split = urllib_parse.urlsplit(self.uri)
         scheme, rest = split[0], split[1:]
         vcs_type = ""
@@ -513,14 +538,14 @@ class VCSRequirement(FileRequirement):
 
     @link.default
     def get_link(self):
-        uri = self.uri if self.uri else path_to_url(self.path)
+        uri = self.uri if self.uri else pip_shims.shims.path_to_url(self.path)
         return build_vcs_link(
             self.vcs,
             add_ssh_scheme_to_git_uri(uri),
             name=self.name,
             ref=self.ref,
             subdirectory=self.subdirectory,
-            extras=self.extras
+            extras=self.extras,
         )
 
     @name.default
@@ -583,12 +608,12 @@ class VCSRequirement(FileRequirement):
         return self._repo
 
     def get_checkout_dir(self, src_dir=None):
-        src_dir = os.environ.get('PIP_SRC', None) if not src_dir else src_dir
+        src_dir = os.environ.get("PIP_SRC", None) if not src_dir else src_dir
         checkout_dir = None
         if self.is_local:
             path = self.path
             if not path:
-                path = url_to_path(self.uri)
+                path = pip_shims.shims.url_to_path(self.uri)
             if path and os.path.exists(path):
                 checkout_dir = os.path.abspath(path)
                 return checkout_dir
@@ -596,6 +621,7 @@ class VCSRequirement(FileRequirement):
 
     def get_vcs_repo(self, src_dir=None):
         from .vcs import VCSRepository
+
         checkout_dir = self.get_checkout_dir(src_dir=src_dir)
         link = build_vcs_link(
             self.vcs,
@@ -603,7 +629,7 @@ class VCSRequirement(FileRequirement):
             name=self.name,
             ref=self.ref,
             subdirectory=self.subdirectory,
-            extras=self.extras
+            extras=self.extras,
         )
         vcsrepo = VCSRepository(
             url=link.url,
@@ -611,7 +637,7 @@ class VCSRequirement(FileRequirement):
             ref=self.ref if self.ref else None,
             checkout_directory=checkout_dir,
             vcs_type=self.vcs,
-            subdirectory=self.subdirectory
+            subdirectory=self.subdirectory,
         )
         if not self.is_local:
             vcsrepo.obtain()
@@ -661,7 +687,16 @@ class VCSRequirement(FileRequirement):
         creation_args = {}
         pipfile_keys = [
             k
-            for k in ("ref", "vcs", "subdirectory", "path", "editable", "file", "uri", "extras")
+            for k in (
+                "ref",
+                "vcs",
+                "subdirectory",
+                "path",
+                "editable",
+                "file",
+                "uri",
+                "extras",
+            )
             + VCS_LIST
             if k in pipfile
         ]
@@ -674,13 +709,20 @@ class VCSRequirement(FileRequirement):
                 creation_args["vcs"] = key
                 target = pipfile.get(key)
                 drive, path = os.path.splitdrive(target)
-                if not drive and not os.path.exists(target) and (is_valid_url(target) or
-                        is_file_url(target) or target.startswith('git@')):
+                if (
+                    not drive
+                    and not os.path.exists(target)
+                    and (
+                        is_valid_url(target)
+                        or is_file_url(target)
+                        or target.startswith("git@")
+                    )
+                ):
                     creation_args["uri"] = target
                 else:
                     creation_args["path"] = target
                     if os.path.isabs(target):
-                        creation_args["uri"] = path_to_url(target)
+                        creation_args["uri"] = pip_shims.shims.path_to_url(target)
             else:
                 creation_args[key] = pipfile.get(key)
         creation_args["name"] = name
@@ -694,7 +736,7 @@ class VCSRequirement(FileRequirement):
             line = line.split(" ", 1)[1]
         vcs_type, prefer, relpath, path, uri, link = cls.get_link_from_line(line)
         if not extras and link.egg_fragment:
-            name, extras = _strip_extras(link.egg_fragment)
+            name, extras = pip_shims.shims._strip_extras(link.egg_fragment)
             if extras:
                 extras = parse_extras(extras)
         else:
@@ -715,7 +757,7 @@ class VCSRequirement(FileRequirement):
             editable=editable,
             uri=uri,
             extras=extras,
-            base_line=line
+            base_line=line,
         )
 
     @property
@@ -725,7 +767,11 @@ class VCSRequirement(FileRequirement):
             base_link = self.link
             if not self.link:
                 base_link = self.get_link()
-            final_format = "{{0}}#egg={0}".format(base_link.egg_fragment) if base_link.egg_fragment else "{0}"
+            final_format = (
+                "{{0}}#egg={0}".format(base_link.egg_fragment)
+                if base_link.egg_fragment
+                else "{0}"
+            )
             base = final_format.format(self.vcs_uri)
         elif self._base_line:
             base = self._base_line
@@ -759,7 +805,7 @@ class VCSRequirement(FileRequirement):
         pipfile_dict = attr.asdict(self, filter=filter_func).copy()
         if "vcs" in pipfile_dict:
             pipfile_dict = self._choose_vcs_source(pipfile_dict)
-        name, _ = _strip_extras(pipfile_dict.pop("name"))
+        name, _ = pip_shims.shims._strip_extras(pipfile_dict.pop("name"))
         return {name: pipfile_dict}
 
 
@@ -806,7 +852,9 @@ class Requirement(object):
     @property
     def extras_as_pip(self):
         if self.extras:
-            return "[{0}]".format(",".join(sorted([extra.lower() for extra in self.extras])))
+            return "[{0}]".format(
+                ",".join(sorted([extra.lower() for extra in self.extras]))
+            )
 
         return ""
 
@@ -847,6 +895,7 @@ class Requirement(object):
     @classmethod
     def from_line(cls, line):
         from pip_shims import InstallRequirement
+
         if isinstance(line, InstallRequirement):
             line = format_requirement(line)
         hashes = None
@@ -856,8 +905,8 @@ class Requirement(object):
         editable = line.startswith("-e ")
         line = line.split(" ", 1)[1] if editable else line
         line, markers = split_markers_from_line(line)
-        line, extras = _strip_extras(line)
-        specifiers = ''
+        line, extras = pip_shims.shims._strip_extras(line)
+        specifiers = ""
         if extras:
             extras = parse_extras(extras)
         line = line.strip('"').strip("'").strip()
@@ -866,7 +915,9 @@ class Requirement(object):
         # Installable local files and installable non-vcs urls are handled
         # as files, generally speaking
         line_is_vcs = is_vcs(line)
-        if is_installable_file(line) or ((is_file_url(line) or is_valid_url(line)) and not line_is_vcs):
+        if is_installable_file(line) or (
+            (is_file_url(line) or is_valid_url(line)) and not line_is_vcs
+        ):
             r = FileRequirement.from_line(line_with_prefix)
         elif line_is_vcs:
             r = VCSRequirement.from_line(line_with_prefix, extras=extras)
@@ -886,7 +937,7 @@ class Requirement(object):
                 version = line[spec_idx:]
                 specifiers = version
             if not extras:
-                name, extras = _strip_extras(name)
+                name, extras = pip_shims.shims._strip_extras(name)
                 if extras:
                     extras = parse_extras(extras)
             if version:
@@ -929,12 +980,14 @@ class Requirement(object):
 
     @classmethod
     def from_metadata(cls, name, version, extras, markers):
-        return cls.from_ireq(make_install_requirement(
-            name, version, extras=extras, markers=markers,
-        ))
+        return cls.from_ireq(
+            make_install_requirement(name, version, extras=extras, markers=markers)
+        )
 
     @classmethod
     def from_pipfile(cls, name, pipfile):
+        from .markers import PipenvMarkers
+
         _pipfile = {}
         if hasattr(pipfile, "keys"):
             _pipfile = dict(pipfile).copy()
@@ -955,7 +1008,9 @@ class Requirement(object):
         r.req.marker = getattr(req_markers, "marker", None)
         r.req.specifier = SpecifierSet(_pipfile["version"])
         extras = _pipfile.get("extras")
-        r.req.extras = sorted(dedup([extra.lower() for extra in extras])) if extras else []
+        r.req.extras = (
+            sorted(dedup([extra.lower() for extra in extras])) if extras else []
+        )
         args = {
             "name": r.name,
             "vcs": vcs,
@@ -972,8 +1027,14 @@ class Requirement(object):
             cls_inst.req.req.line = cls_inst.as_line()
         return cls_inst
 
-    def as_line(self, sources=None, include_hashes=True, include_extras=True,
-                                                    include_markers=True, as_list=False):
+    def as_line(
+        self,
+        sources=None,
+        include_hashes=True,
+        include_extras=True,
+        include_markers=True,
+        as_list=False,
+    ):
         """Format this requirement as a line in requirements.txt.
 
         If ``sources`` provided, it should be an sequence of mappings, containing
@@ -1022,7 +1083,7 @@ class Requirement(object):
     def get_markers(self):
         markers = self.markers
         if markers:
-            fake_pkg = PackagingRequirement('fakepkg; {0}'.format(markers))
+            fake_pkg = PackagingRequirement("fakepkg; {0}".format(markers))
             markers = fake_pkg.markers
         return markers
 
@@ -1030,15 +1091,15 @@ class Requirement(object):
         return Specifier(self.specifiers)
 
     def get_version(self):
-        return parse_version(self.get_specifier().version)
+        return pip_shims.shims.parse_version(self.get_specifier().version)
 
     def get_requirement(self):
         req_line = self.req.req.line
-        if req_line.startswith('-e '):
+        if req_line.startswith("-e "):
             _, req_line = req_line.split(" ", 1)
         req = init_requirement(self.name)
         req.line = req_line
-        req.specifier = SpecifierSet(self.specifiers if self.specifiers else '')
+        req.specifier = SpecifierSet(self.specifiers if self.specifiers else "")
         if self.is_vcs or self.is_file_or_url:
             req.url = self.req.link.url_without_fragment
         req.marker = self.get_markers()
@@ -1064,8 +1125,8 @@ class Requirement(object):
             if k in good_keys
         }
         name = self.name
-        if 'markers' in req_dict and req_dict['markers']:
-            req_dict['markers'] = req_dict['markers'].replace('"', "'")
+        if "markers" in req_dict and req_dict["markers"]:
+            req_dict["markers"] = req_dict["markers"].replace('"', "'")
         base_dict = {
             k: v
             for k, v in self.req.pipfile_part[name].items()
@@ -1094,11 +1155,11 @@ class Requirement(object):
         ireq_line = self.as_line(include_hashes=False)
         if self.editable or self.req.editable:
             if ireq_line.startswith("-e "):
-                ireq_line = ireq_line[len("-e "):]
+                ireq_line = ireq_line[len("-e ") :]
             with ensure_setup_py(self.req.setup_path):
-                ireq = ireq_from_editable(ireq_line)
+                ireq = pip_shims.shims.ireq_from_editable(ireq_line)
         else:
-            ireq = ireq_from_line(ireq_line)
+            ireq = pip_shims.shims.ireq_from_line(ireq_line)
         if not getattr(ireq, "req", None):
             ireq.req = self.req.req
         else:
@@ -1127,12 +1188,11 @@ class Requirement(object):
         """
 
         from .dependencies import get_dependencies
+
         if not sources:
-            sources = [{
-                'name': 'pypi',
-                'url': 'https://pypi.org/simple',
-                'verify_ssl': True,
-            }]
+            sources = [
+                {"name": "pypi", "url": "https://pypi.org/simple", "verify_ssl": True}
+            ]
         return get_dependencies(self.as_ireq(), sources=sources)
 
     def get_abstract_dependencies(self, sources=None):
@@ -1146,18 +1206,27 @@ class Requirement(object):
         :rtype: list[ :class:`~requirementslib.models.dependency.AbstractDependency` ]
         """
 
-        from .dependencies import AbstractDependency, get_dependencies, get_abstract_dependencies
+        from .dependencies import (
+            AbstractDependency,
+            get_dependencies,
+            get_abstract_dependencies,
+        )
+
         if not self.abstract_dep:
-            parent = getattr(self, 'parent', None)
+            parent = getattr(self, "parent", None)
             self.abstract_dep = AbstractDependency.from_requirement(self, parent=parent)
         if not sources:
-            sources = [{'url': 'https://pypi.org/simple', 'name': 'pypi', 'verify_ssl': True},]
+            sources = [
+                {"url": "https://pypi.org/simple", "name": "pypi", "verify_ssl": True}
+            ]
         if is_pinned_requirement(self.ireq):
             deps = self.get_dependencies()
         else:
             ireq = sorted(self.find_all_matches(), key=lambda k: k.version)
             deps = get_dependencies(ireq.pop(), sources=sources)
-        return get_abstract_dependencies(deps, sources=sources, parent=self.abstract_dep)
+        return get_abstract_dependencies(
+            deps, sources=sources, parent=self.abstract_dep
+        )
 
     def find_all_matches(self, sources=None, finder=None):
         """Find all matching candidates for the current requirement.
@@ -1171,6 +1240,7 @@ class Requirement(object):
         """
 
         from .dependencies import get_finder, find_all_matches
+
         if not finder:
             finder = get_finder(sources=sources)
         return find_all_matches(finder, self.as_ireq())
diff --git a/pipenv/vendor/requirementslib/models/resolvers.py b/pipenv/vendor/requirementslib/models/resolvers.py
index 1a239390..bd773ba6 100644
--- a/pipenv/vendor/requirementslib/models/resolvers.py
+++ b/pipenv/vendor/requirementslib/models/resolvers.py
@@ -6,7 +6,6 @@ import six
 
 from pip_shims.shims import Wheel
 
-from ..utils import log, VCS_SUPPORT
 from .cache import HashCache
 from .utils import format_requirement, is_pinned_requirement, version_from_ireq
 
@@ -141,6 +140,7 @@ class DependencyResolver(object):
         # Coerce input into AbstractDependency instances.
         # We accept str, Requirement, and AbstractDependency as input.
         from .dependencies import AbstractDependency
+        from ..utils import log
         for dep in root_nodes:
             if isinstance(dep, six.string_types):
                 dep = AbstractDependency.from_string(dep)
@@ -193,7 +193,8 @@ class DependencyResolver(object):
         if ireq.editable:
             return set()
 
-        vcs = VCS_SUPPORT
+        from pip_shims import VcsSupport
+        vcs = VcsSupport()
         if ireq.link and ireq.link.scheme in vcs.all_schemes and 'ssh' in ireq.link.scheme:
             return set()
 
diff --git a/pipenv/vendor/requirementslib/models/utils.py b/pipenv/vendor/requirementslib/models/utils.py
index d72542c4..fbaaf1a4 100644
--- a/pipenv/vendor/requirementslib/models/utils.py
+++ b/pipenv/vendor/requirementslib/models/utils.py
@@ -14,14 +14,10 @@ from attr import validators
 from first import first
 from packaging.markers import InvalidMarker, Marker, Op, Value, Variable
 from packaging.specifiers import InvalidSpecifier, Specifier, SpecifierSet
-from packaging.version import parse as parse_version
-from packaging.requirements import Requirement as PackagingRequirement
-from pkg_resources import Requirement
-
 from vistir.misc import dedup
 
 
-from ..utils import SCHEME_LIST, VCS_LIST, is_star
+from ..utils import SCHEME_LIST, VCS_LIST, is_star, strip_ssh_from_git_uri, add_ssh_scheme_to_git_uri
 
 
 HASH_STRING = " --hash={0}"
@@ -42,17 +38,8 @@ def create_link(link):
     return Link(link)
 
 
-def ireq_from_line(ireq):
-    from pip_shims import InstallRequirement
-    return InstallRequirement.from_line(ireq)
-
-
-def ireq_from_editable(ireq):
-    from pip_shims import InstallRequirement
-    return InstallRequirement.from_editable(ireq)
-
-
 def init_requirement(name):
+    from pkg_resources import Requirement
     req = Requirement.parse(name)
     req.vcs = None
     req.local_file = None
@@ -74,6 +61,7 @@ def extras_to_string(extras):
 
 def parse_extras(extras_str):
     """Turn a string of extras into a parsed extras list"""
+    from pkg_resources import Requirement
     extras = Requirement.parse("fakepkg{0}".format(extras_to_string(extras_str))).extras
     return sorted(dedup([extra.lower() for extra in extras]))
 
@@ -124,22 +112,6 @@ def get_version(pipfile_entry):
     return ""
 
 
-def strip_ssh_from_git_uri(uri):
-    """Return git+ssh:// formatted URI to git+git@ format"""
-    if isinstance(uri, six.string_types):
-        uri = uri.replace("git+ssh://", "git+", 1)
-    return uri
-
-
-def add_ssh_scheme_to_git_uri(uri):
-    """Cleans VCS uris from pipenv.patched.notpip format"""
-    if isinstance(uri, six.string_types):
-        # Add scheme for parsing purposes, this is also what pip does
-        if uri.startswith("git+") and "://" not in uri:
-            uri = uri.replace("git+", "git+ssh://", 1)
-    return uri
-
-
 def split_markers_from_line(line):
     """Split markers from a dependency"""
     if not any(line.startswith(uri_prefix) for uri_prefix in SCHEME_LIST):
@@ -483,6 +455,7 @@ def clean_requires_python(candidates):
     """Get a cleaned list of all the candidates with valid specifiers in the `requires_python` attributes."""
     all_candidates = []
     sys_version = '.'.join(map(str, sys.version_info[:3]))
+    from packaging.version import parse as parse_version
     py_version = parse_version(os.environ.get('PIP_PYTHON_VERSION', sys_version))
     for c in candidates:
         from_location = attrgetter("location.requires_python")
@@ -504,6 +477,7 @@ def clean_requires_python(candidates):
 
 
 def fix_requires_python_marker(requires_python):
+    from packaging.requirements import Requirement as PackagingRequirement
     marker_str = ''
     if any(requires_python.startswith(op) for op in Specifier._operators.keys()):
         spec_dict = defaultdict(set)
diff --git a/pipenv/vendor/requirementslib/models/vcs.py b/pipenv/vendor/requirementslib/models/vcs.py
index 4efb9bd3..dd8cc3a4 100644
--- a/pipenv/vendor/requirementslib/models/vcs.py
+++ b/pipenv/vendor/requirementslib/models/vcs.py
@@ -1,11 +1,9 @@
 # -*- coding=utf-8 -*-
 import attr
-from pip_shims import VcsSupport, parse_version, pip_version
 import os
+import pip_shims
 
 
-VCS_SUPPORT = VcsSupport()
-
 
 @attr.s
 class VCSRepository(object):
@@ -20,6 +18,8 @@ class VCSRepository(object):
 
     @repo_instance.default
     def get_repo_instance(self):
+        from pip_shims import VcsSupport
+        VCS_SUPPORT = VcsSupport()
         backend = VCS_SUPPORT._registry.get(self.vcs_type)
         return backend(url=self.url)
 
@@ -51,7 +51,7 @@ class VCSRepository(object):
 
     def update(self, ref):
         target_ref = self.repo_instance.make_rev_options(ref)
-        if parse_version(pip_version) > parse_version("18.0"):
+        if pip_shims.parse_version(pip_shims.pip_version) > pip_shims.parse_version("18.0"):
             self.repo_instance.update(self.checkout_directory, self.url, target_ref)
         else:
             self.repo_instance.update(self.checkout_directory, target_ref)
diff --git a/pipenv/vendor/requirementslib/utils.py b/pipenv/vendor/requirementslib/utils.py
index 291c30ae..312efbb3 100644
--- a/pipenv/vendor/requirementslib/utils.py
+++ b/pipenv/vendor/requirementslib/utils.py
@@ -16,22 +16,12 @@ six.add_move(six.MovedAttribute("ItemsView", "collections", "collections.abc"))
 from six.moves import Mapping, Sequence, Set, ItemsView
 from six.moves.urllib.parse import urlparse, urlsplit
 
-from pip_shims.shims import (
-    Command, VcsSupport, cmdoptions, is_archive_file,
-    is_installable_dir as _is_installable_dir
-)
+import pip_shims.shims
 from vistir.compat import Path
 from vistir.path import is_valid_url, ensure_mkdir_p, create_tracked_tempdir
 
 
 VCS_LIST = ("git", "svn", "hg", "bzr")
-VCS_SCHEMES = []
-SCHEME_LIST = ("http://", "https://", "ftp://", "ftps://", "file://")
-
-VCS_SUPPORT = VcsSupport()
-
-if not VCS_SCHEMES:
-    VCS_SCHEMES = VCS_SUPPORT.all_schemes
 
 
 def setup_logger():
@@ -47,8 +37,38 @@ def setup_logger():
 log = setup_logger()
 
 
+SCHEME_LIST = ("http://", "https://", "ftp://", "ftps://", "file://")
+
+
+VCS_SCHEMES = [
+    "git",
+    "git+http",
+    "git+https",
+    "git+ssh",
+    "git+git",
+    "git+file",
+    "hg",
+    "hg+http",
+    "hg+https",
+    "hg+ssh",
+    "hg+static-http",
+    "svn",
+    "svn+ssh",
+    "svn+http",
+    "svn+https",
+    "svn+svn",
+    "bzr",
+    "bzr+http",
+    "bzr+https",
+    "bzr+ssh",
+    "bzr+sftp",
+    "bzr+ftp",
+    "bzr+lp",
+]
+
+
 def is_installable_dir(path):
-    if _is_installable_dir(path):
+    if pip_shims.shims.is_installable_dir(path):
         return True
     path = Path(path)
     pyproject = path.joinpath("pyproject.toml")
@@ -60,15 +80,31 @@ def is_installable_dir(path):
     return False
 
 
+def strip_ssh_from_git_uri(uri):
+    """Return git+ssh:// formatted URI to git+git@ format"""
+    if isinstance(uri, six.string_types):
+        uri = uri.replace("git+ssh://", "git+", 1)
+    return uri
+
+
+def add_ssh_scheme_to_git_uri(uri):
+    """Cleans VCS uris from pip format"""
+    if isinstance(uri, six.string_types):
+        # Add scheme for parsing purposes, this is also what pip does
+        if uri.startswith("git+") and "://" not in uri:
+            uri = uri.replace("git+", "git+ssh://", 1)
+    return uri
+
+
 def is_vcs(pipfile_entry):
     """Determine if dictionary entry from Pipfile is for a vcs dependency."""
-    if hasattr(pipfile_entry, "keys"):
+    if isinstance(pipfile_entry, Mapping):
         return any(key for key in pipfile_entry.keys() if key in VCS_LIST)
 
     elif isinstance(pipfile_entry, six.string_types):
         if not is_valid_url(pipfile_entry) and pipfile_entry.startswith("git+"):
-            from .models.utils import add_ssh_scheme_to_git_uri
             pipfile_entry = add_ssh_scheme_to_git_uri(pipfile_entry)
+
         parsed_entry = urlsplit(pipfile_entry)
         return parsed_entry.scheme in VCS_SCHEMES
     return False
@@ -88,7 +124,9 @@ def multi_split(s, split):
 
 
 def is_star(val):
-    return isinstance(val, six.string_types) and val == "*"
+    return (isinstance(val, six.string_types) and val == "*") or (
+        isinstance(val, Mapping) and val.get("version", "") == "*"
+    )
 
 
 def is_installable_file(path):
@@ -125,7 +163,7 @@ def is_installable_file(path):
     if lookup_path.is_dir() and is_installable_dir(absolute_path):
         return True
 
-    elif lookup_path.is_file() and is_archive_file(absolute_path):
+    elif lookup_path.is_file() and pip_shims.shims.is_archive_file(absolute_path):
         return True
 
     return False
@@ -139,9 +177,7 @@ def prepare_pip_source_args(sources, pip_args=None):
         pip_args.extend(["-i", sources[0]["url"]])
         # Trust the host if it's not verified.
         if not sources[0].get("verify_ssl", True):
-            pip_args.extend(
-                ["--trusted-host", urlparse(sources[0]["url"]).hostname]
-            )
+            pip_args.extend(["--trusted-host", urlparse(sources[0]["url"]).hostname])
         # Add additional sources as extra indexes.
         if len(sources) > 1:
             for source in sources[1:]:
@@ -154,28 +190,6 @@ def prepare_pip_source_args(sources, pip_args=None):
     return pip_args
 
 
-class PipCommand(Command):
-    name = 'PipCommand'
-
-
-def get_pip_command():
-    # Use pip's parser for pip.conf management and defaults.
-    # General options (find_links, index_url, extra_index_url, trusted_host,
-    # and pre) are defered to pip.
-    import optparse
-    pip_command = PipCommand()
-    pip_command.parser.add_option(cmdoptions.no_binary())
-    pip_command.parser.add_option(cmdoptions.only_binary())
-    index_opts = cmdoptions.make_option_group(
-        cmdoptions.index_group,
-        pip_command.parser,
-    )
-    pip_command.parser.insert_option_group(0, index_opts)
-    pip_command.parser.add_option(optparse.Option('--pre', action='store_true', default=False))
-
-    return pip_command
-
-
 @ensure_mkdir_p(mode=0o777)
 def _ensure_dir(path):
     return path
@@ -204,7 +218,6 @@ def ensure_setup_py(base_dir):
             setup_py.unlink()
 
 
-
 _UNSET = object()
 _REMAP_EXIT = object()
 
@@ -251,6 +264,7 @@ class PathAccessError(KeyError, IndexError, TypeError):
     representing what can occur when looking up a path in a nested
     object.
     """
+
     def __init__(self, exc, seg, path):
         self.exc = exc
         self.seg = seg
@@ -258,11 +272,14 @@ class PathAccessError(KeyError, IndexError, TypeError):
 
     def __repr__(self):
         cn = self.__class__.__name__
-        return '%s(%r, %r, %r)' % (cn, self.exc, self.seg, self.path)
+        return "%s(%r, %r, %r)" % (cn, self.exc, self.seg, self.path)
 
     def __str__(self):
-        return ('could not access %r from path %r, got error: %r'
-                % (self.seg, self.path, self.exc))
+        return "could not access %r from path %r, got error: %r" % (
+            self.seg,
+            self.path,
+            self.exc,
+        )
 
 
 def get_path(root, path, default=_UNSET):
@@ -292,7 +309,7 @@ def get_path(root, path, default=_UNSET):
           ``PathAccessError`` exceptions be raised.
     """
     if isinstance(path, six.string_types):
-        path = path.split('.')
+        path = path.split(".")
     cur = root
     try:
         for seg in path:
@@ -308,8 +325,9 @@ def get_path(root, path, default=_UNSET):
                     cur = cur[seg]
                 except (ValueError, KeyError, IndexError, TypeError):
                     if not getattr(cur, "__iter__", None):
-                        exc = TypeError('%r object is not indexable'
-                                        % type(cur).__name__)
+                        exc = TypeError(
+                            "%r object is not indexable" % type(cur).__name__
+                        )
                     raise PathAccessError(exc, seg, path)
     except PathAccessError:
         if default is _UNSET:
@@ -373,12 +391,13 @@ def dict_path_exit(path, key, old_parent, new_parent, new_items):
         except AttributeError:
             ret = new_parent.__class__(vals)  # frozensets
     else:
-        raise RuntimeError('unexpected iterable type: %r' % type(new_parent))
+        raise RuntimeError("unexpected iterable type: %r" % type(new_parent))
     return ret
 
 
-def remap(root, visit=default_visit, enter=dict_path_enter, exit=dict_path_exit,
-          **kwargs):
+def remap(
+    root, visit=default_visit, enter=dict_path_enter, exit=dict_path_exit, **kwargs
+):
     """The remap ("recursive map") function is used to traverse and
     transform nested structures. Lists, tuples, sets, and dictionaries
     are just a few of the data structures nested into heterogenous
@@ -462,14 +481,14 @@ def remap(root, visit=default_visit, enter=dict_path_enter, exit=dict_path_exit,
     # TODO: improve argument formatting in sphinx doc
     # TODO: enter() return (False, items) to continue traverse but cancel copy?
     if not callable(visit):
-        raise TypeError('visit expected callable, not: %r' % visit)
+        raise TypeError("visit expected callable, not: %r" % visit)
     if not callable(enter):
-        raise TypeError('enter expected callable, not: %r' % enter)
+        raise TypeError("enter expected callable, not: %r" % enter)
     if not callable(exit):
-        raise TypeError('exit expected callable, not: %r' % exit)
-    reraise_visit = kwargs.pop('reraise_visit', True)
+        raise TypeError("exit expected callable, not: %r" % exit)
+    reraise_visit = kwargs.pop("reraise_visit", True)
     if kwargs:
-        raise TypeError('unexpected keyword arguments: %r' % kwargs.keys())
+        raise TypeError("unexpected keyword arguments: %r" % kwargs.keys())
 
     path, registry, stack = (), {}, [(None, root)]
     new_items_stack = []
@@ -492,8 +511,10 @@ def remap(root, visit=default_visit, enter=dict_path_enter, exit=dict_path_exit,
                 new_parent, new_items = res
             except TypeError:
                 # TODO: handle False?
-                raise TypeError('enter should return a tuple of (new_parent,'
-                                ' items_iterator), not: %r' % res)
+                raise TypeError(
+                    "enter should return a tuple of (new_parent,"
+                    " items_iterator), not: %r" % res
+                )
             if new_items is not False:
                 # traverse unless False is explicitly passed
                 registry[id_value] = new_parent
@@ -524,7 +545,7 @@ def remap(root, visit=default_visit, enter=dict_path_enter, exit=dict_path_exit,
         try:
             new_items_stack[-1][1].append(visited_item)
         except IndexError:
-            raise TypeError('expected remappable root, not: %r' % root)
+            raise TypeError("expected remappable root, not: %r" % root)
     return value
 
 
@@ -554,14 +575,15 @@ def merge_items(target_list, sourced=False):
 
     for t_name, target in target_list:
         if sourced:
+
             def remerge_visit(path, key, value):
                 source_map[path + (key,)] = t_name
                 return True
+
         else:
             remerge_visit = default_visit
 
-        ret = remap(target, enter=remerge_enter, visit=remerge_visit,
-                    exit=remerge_exit)
+        ret = remap(target, enter=remerge_enter, visit=remerge_visit, exit=remerge_exit)
 
     if not sourced:
         return ret

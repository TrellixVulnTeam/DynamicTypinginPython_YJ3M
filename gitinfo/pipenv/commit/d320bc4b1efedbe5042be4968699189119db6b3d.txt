commit d320bc4b1efedbe5042be4968699189119db6b3d
Author: Dan Ryan <dan@danryan.co>
Date:   Tue Oct 24 22:42:43 2017 -0400

    Fix local and relative path installation
    
    Summary of squashed commits:
    * Handle relative paths more elegantly
    * Wrapper around requirements.parse() for filesystem paths
    * Undo previous hacks for simplicity
    * Vendor pathlib2 for backwards compatibility
    * Resolve relative paths for parsing, keep them relative in pipfile
    * Add checks for empty req names and remote uris
    * Add tests for local paths
    * Fix test paramaterization
    * Bugfixes for python27 and windows paths
    * Fix windows tests
    * Fix windows tests for python27 path encoding
    * Re-vendor pathlib2 correctly
    * Fix tests for windows paths
    * Fix file and path checking
    * Fix SCHEME_LIST rename
    * Fix path resolution to check existence first
    * Catch OSErrors for unpinned dependencies
    * Last holdout of FILE_LIST conversion
    * Fix for path resolution for unpinned packages
    * Dont do path conversions on dictionaries
    * Update docstring and comments
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/cli.py b/pipenv/cli.py
index e72faa4b..88d706be 100644
--- a/pipenv/cli.py
+++ b/pipenv/cli.py
@@ -36,7 +36,7 @@ from .utils import (
     proper_case, pep423_name, split_vcs, resolve_deps, shellquote, is_vcs,
     python_version, suggest_package, find_windows_executable, is_file,
     prepare_pip_source_args, temp_environ, is_valid_url, download_file,
-    need_update_check, touch_update_stamp
+    get_requirement, need_update_check, touch_update_stamp
 )
 from .__version__ import __version__
 from . import pep508checker, progress
@@ -1352,7 +1352,7 @@ def pip_install(
             f.write(package_name)
 
     # Install dependencies when a package is a VCS dependency.
-    if [x for x in requirements.parse(package_name.split('--hash')[0].split('--trusted-host')[0])][0].vcs:
+    if get_requirement(package_name.split('--hash')[0].split('--trusted-host')[0]).vcs:
         no_deps = False
 
         # Don't specify a source directory when using --system.
@@ -1872,18 +1872,16 @@ def install(
 
         # pip install:
         with spinner():
-            # So that we still write the provided path to the pipfile but convert for installing
-            pip_dep_name = package_name
-            if is_file(package_name):
-                pip_dep_name = convert_path_to_uri(package_name)
-            c = pip_install(pip_dep_name, ignore_hashes=True, allow_global=system, no_deps=False, verbose=verbose, pre=pre)
+
+            c = pip_install(package_name, ignore_hashes=True, allow_global=system, no_deps=False, verbose=verbose, pre=pre)
 
             # Warn if --editable wasn't passed.
             try:
-                converted = convert_deps_from_pip(pip_dep_name)
+                converted = convert_deps_from_pip(package_name)
             except ValueError as e:
                 click.echo('{0}: {1}'.format(crayons.red('WARNING'), e))
                 sys.exit(1)
+
             key = [k for k in converted.keys()][0]
             if is_vcs(key) or is_vcs(converted[key]) and not converted[key].get('editable'):
                 click.echo(
diff --git a/pipenv/project.py b/pipenv/project.py
index 9d90f557..5cfd1321 100644
--- a/pipenv/project.py
+++ b/pipenv/project.py
@@ -14,7 +14,7 @@ import toml
 from .utils import (
     mkdir_p, convert_deps_from_pip, pep423_name, recase_file,
     find_requirements, is_file, is_vcs, python_version, cleanup_toml,
-    convert_path_to_uri, convert_file_uri_to_path
+    is_installable_file, is_valid_url
 )
 from .environments import PIPENV_MAX_DEPTH, PIPENV_VENV_IN_PROJECT
 from .environments import PIPENV_VIRTUALENV, PIPENV_PIPFILE
@@ -67,10 +67,13 @@ class Project(object):
                     else:
                         ps.update({k: v})
                 else:
-                    if not is_file(v) and not is_file(k):
+                    if not (is_installable_file(k) or is_installable_file(v) or
+                            any(file_prefix in v for file_prefix in ['path', 'file'])):
                         ps.update({k: v})
             else:
-                if not is_vcs(k) and not is_file(k) and not is_vcs(v):
+                if not (any(is_vcs(i) for i in [k, v]) or
+                        any(is_installable_file(i) for i in [k, v]) or
+                        any(is_valid_url(i) for i in [k, v])):
                     ps.update({k: v})
         return ps
 
@@ -461,18 +464,8 @@ class Project(object):
         # Read and append Pipfile.
         p = self._pipfile
 
-        # Always use file:// URIs for local path installation
-        # But allow local relpaths in pipfile
-        pip_dep_name = package_name
-        pipfile_package_path = None
-        if is_file(package_name) and not package_name.startswith('file://'):
-            pip_dep_name = convert_path_to_uri(package_name)
-            pipfile_package_path = os.path.join('.', os.path.relpath(
-                convert_file_uri_to_path(pip_dep_name), start=self.project_directory)
-            )
-
         # Don't re-capitalize file URLs or VCSs.
-        converted = convert_deps_from_pip(pip_dep_name)
+        converted = convert_deps_from_pip(package_name)
         converted = converted[[k for k in converted.keys()][0]]
 
         if not (is_file(package_name) or is_vcs(converted) or 'path' in converted):
@@ -484,13 +477,10 @@ class Project(object):
         if key not in p:
             p[key] = {}
 
-        package = convert_deps_from_pip(pip_dep_name)
+        package = convert_deps_from_pip(package_name)
         package_name = [k for k in package.keys()][0]
 
         # Add the package to the group.
-        if pipfile_package_path and 'file' in package[package_name]:
-            del package[package_name]['file']
-            package[package_name]['path'] = pipfile_package_path
         p[key][package_name] = package[package_name]
 
         # Write Pipfile.
diff --git a/pipenv/utils.py b/pipenv/utils.py
index fc65932d..4cf25120 100644
--- a/pipenv/utils.py
+++ b/pipenv/utils.py
@@ -23,6 +23,10 @@ try:
     from urllib.parse import urlparse
 except ImportError:
     from urlparse import urlparse
+try:
+    from pathlib import Path
+except ImportError:
+    from pathlib2 import Path
 
 from distutils.spawn import find_executable
 from contextlib import contextmanager
@@ -41,7 +45,7 @@ specifiers = [k for k in lookup.keys()]
 
 # List of version control systems we support.
 VCS_LIST = ('git', 'svn', 'hg', 'bzr')
-SCHEME_LIST = ('http://', 'https://', 'ftp://', 'file:///')
+SCHEME_LIST = ('http://', 'https://', 'ftp://', 'file://')
 
 requests = requests.Session()
 
@@ -266,6 +270,35 @@ packages = [
 ]
 
 
+def get_requirement(dep):
+    """Pre-clean requirement strings passed to the requirements parser.
+    
+    Ensures that we can accept both local and relative paths, file and VCS URIs,
+    remote URIs, and package names, and that we pass only valid requirement strings
+    to the requirements parser. Performs necessary modifications to requirements
+    object if the user input was a local relative path.
+    """
+    path = None
+    # Only operate on local, existing, non-URI formatted paths
+    if (is_file(dep) and isinstance(dep, six.string_types) and
+            not any(dep.startswith(uri_prefix) for uri_prefix in SCHEME_LIST)):
+        dep_path = Path(dep)
+        # Only parse if it is a file or an installable dir
+        if dep_path.is_file() or (dep_path.is_dir() and pip.utils.is_installable_dir(dep)):
+            if dep_path.is_absolute():
+                path = dep
+            else:
+                path = get_converted_relative_path(dep)
+            dep = dep_path.resolve().as_uri()
+    req = [r for r in requirements.parse(dep)][0]
+    # If the result is a local file with a URI and we have a local path, unset the URI
+    # and set the path instead
+    if req.local_file and req.uri and not req.path and path:
+        req.path = path
+        req.uri = None
+    return req
+
+
 def cleanup_toml(tml):
     toml = tml.split('\n')
     new_toml = []
@@ -539,12 +572,11 @@ def convert_deps_from_pip(dep):
 
     dependency = {}
 
-    req = [r for r in requirements.parse(dep)][0]
+    req = get_requirement(dep)
     extras = {'extras': req.extras}
 
     # File installs.
-    if (req.uri or (os.path.isfile(req.path) if req.path else False) or
-            os.path.isfile(req.name)) and not req.vcs:
+    if (req.uri or req.path or (os.path.isfile(req.name) if req.name else False)) and not req.vcs:
         # Assign a package name to the file, last 7 of it's sha256 hex digest.
         if not req.uri and not req.path:
             req.path = os.path.abspath(req.name)
@@ -778,6 +810,17 @@ def is_vcs(pipfile_entry):
     return False
 
 
+def is_installable_file(path):
+    """Determine if a path can potentially be installed"""
+    if hasattr(path, 'keys') and any(key for key in path.keys() if key in ['file', 'path']):
+        path = urlparse(path['file']).path if 'file' in path else path['path']
+    if not isinstance(path, six.string_types) or path == '*':
+        return False
+    lookup_path = Path(path)
+    return lookup_path.is_file() or (lookup_path.is_dir() and
+            pip.utils.is_installable_dir(lookup_path.resolve().as_posix()))
+
+
 def is_file(package):
     """Determine if a package name is for a File dependency."""
     if hasattr(package, 'keys'):
@@ -885,21 +928,9 @@ def find_windows_executable(bin_path, exe_name):
     return find_executable(exe_name)
 
 
-def convert_path_to_uri(path):
-    """Given a path, return a file:// URI pointer"""
-    # Adapted and borrowed from pip
-    drive, path = os.path.splitdrive(os.path.abspath(path))
-    filepath = path.split(os.path.sep)
-    url = '/'.join(filepath)
-    if drive:
-        return 'file:///' + drive + url
-    return 'file://' + url
-
-
-def convert_file_uri_to_path(uri):
-    """Given a URI, return an OS path"""
-    path = urlparse(uri)
-    return os.path.abspath(os.path.join(path.netloc, path.path))
+def get_converted_relative_path(path, relative_to=os.curdir):
+    """Given a vague relative path, return the path relative to the given location"""
+    return os.path.join('.', os.path.relpath(path, start=relative_to))
 
 
 def walk_up(bottom):
diff --git a/pipenv/vendor/pathlib2.py b/pipenv/vendor/pathlib2.py
new file mode 100644
index 00000000..b67649c6
--- /dev/null
+++ b/pipenv/vendor/pathlib2.py
@@ -0,0 +1,1669 @@
+# Copyright (c) 2014-2017 Matthias C. M. Troffaes
+# Copyright (c) 2012-2014 Antoine Pitrou and contributors
+# Distributed under the terms of the MIT License.
+
+import ctypes
+import fnmatch
+import functools
+import io
+import ntpath
+import os
+import posixpath
+import re
+import six
+import sys
+from collections import Sequence
+from errno import EINVAL, ENOENT, ENOTDIR, EEXIST, EPERM, EACCES
+from operator import attrgetter
+from stat import (
+    S_ISDIR, S_ISLNK, S_ISREG, S_ISSOCK, S_ISBLK, S_ISCHR, S_ISFIFO)
+try:
+    from urllib import quote as urlquote_from_bytes
+except ImportError:
+    from urllib.parse import quote_from_bytes as urlquote_from_bytes
+
+
+try:
+    intern = intern
+except NameError:
+    intern = sys.intern
+
+supports_symlinks = True
+if os.name == 'nt':
+    import nt
+    if sys.getwindowsversion()[:2] >= (6, 0) and sys.version_info >= (3, 2):
+        from nt import _getfinalpathname
+    else:
+        supports_symlinks = False
+        _getfinalpathname = None
+else:
+    nt = None
+
+try:
+    from os import scandir as os_scandir
+except ImportError:
+    from scandir import scandir as os_scandir
+
+__all__ = [
+    "PurePath", "PurePosixPath", "PureWindowsPath",
+    "Path", "PosixPath", "WindowsPath",
+    ]
+
+#
+# Internals
+#
+
+
+def _py2_fsencode(parts):
+    # py2 => minimal unicode support
+    assert six.PY2
+    return [part.encode('ascii') if isinstance(part, six.text_type)
+            else part for part in parts]
+
+
+def _try_except_fileexistserror(try_func, except_func, else_func=None):
+    if sys.version_info >= (3, 3):
+        try:
+            try_func()
+        except FileExistsError as exc:
+            except_func(exc)
+        else:
+            if else_func is not None:
+                else_func()
+    else:
+        try:
+            try_func()
+        except EnvironmentError as exc:
+            if exc.errno != EEXIST:
+                raise
+            else:
+                except_func(exc)
+        else:
+            if else_func is not None:
+                else_func()
+
+
+def _try_except_filenotfounderror(try_func, except_func):
+    if sys.version_info >= (3, 3):
+        try:
+            try_func()
+        except FileNotFoundError as exc:
+            except_func(exc)
+    else:
+        try:
+            try_func()
+        except EnvironmentError as exc:
+            if exc.errno != ENOENT:
+                raise
+            else:
+                except_func(exc)
+
+
+def _try_except_permissionerror_iter(try_iter, except_iter):
+    if sys.version_info >= (3, 3):
+        try:
+            for x in try_iter():
+                yield x
+        except PermissionError as exc:
+            for x in except_iter(exc):
+                yield x
+    else:
+        try:
+            for x in try_iter():
+                yield x
+        except EnvironmentError as exc:
+            if exc.errno not in (EPERM, EACCES):
+                raise
+            else:
+                for x in except_iter(exc):
+                    yield x
+
+
+def _win32_get_unique_path_id(path):
+    # get file information, needed for samefile on older Python versions
+    # see http://timgolden.me.uk/python/win32_how_do_i/
+    # see_if_two_files_are_the_same_file.html
+    from ctypes import POINTER, Structure, WinError
+    from ctypes.wintypes import DWORD, HANDLE, BOOL
+
+    class FILETIME(Structure):
+        _fields_ = [("datetime_lo", DWORD),
+                    ("datetime_hi", DWORD),
+                    ]
+
+    class BY_HANDLE_FILE_INFORMATION(Structure):
+        _fields_ = [("attributes", DWORD),
+                    ("created_at", FILETIME),
+                    ("accessed_at", FILETIME),
+                    ("written_at", FILETIME),
+                    ("volume", DWORD),
+                    ("file_hi", DWORD),
+                    ("file_lo", DWORD),
+                    ("n_links", DWORD),
+                    ("index_hi", DWORD),
+                    ("index_lo", DWORD),
+                    ]
+
+    CreateFile = ctypes.windll.kernel32.CreateFileW
+    CreateFile.argtypes = [ctypes.c_wchar_p, DWORD, DWORD, ctypes.c_void_p,
+                           DWORD, DWORD, HANDLE]
+    CreateFile.restype = HANDLE
+    GetFileInformationByHandle = (
+        ctypes.windll.kernel32.GetFileInformationByHandle)
+    GetFileInformationByHandle.argtypes = [
+        HANDLE, POINTER(BY_HANDLE_FILE_INFORMATION)]
+    GetFileInformationByHandle.restype = BOOL
+    CloseHandle = ctypes.windll.kernel32.CloseHandle
+    CloseHandle.argtypes = [HANDLE]
+    CloseHandle.restype = BOOL
+    GENERIC_READ = 0x80000000
+    FILE_SHARE_READ = 0x00000001
+    FILE_FLAG_BACKUP_SEMANTICS = 0x02000000
+    OPEN_EXISTING = 3
+    if os.path.isdir(path):
+        flags = FILE_FLAG_BACKUP_SEMANTICS
+    else:
+        flags = 0
+    hfile = CreateFile(path, GENERIC_READ, FILE_SHARE_READ,
+                       None, OPEN_EXISTING, flags, None)
+    if hfile == 0xffffffff:
+        if sys.version_info >= (3, 3):
+            raise FileNotFoundError(path)
+        else:
+            exc = OSError("file not found: path")
+            exc.errno = ENOENT
+            raise exc
+    info = BY_HANDLE_FILE_INFORMATION()
+    success = GetFileInformationByHandle(hfile, info)
+    CloseHandle(hfile)
+    if success == 0:
+        raise WinError()
+    return info.volume, info.index_hi, info.index_lo
+
+
+def _is_wildcard_pattern(pat):
+    # Whether this pattern needs actual matching using fnmatch, or can
+    # be looked up directly as a file.
+    return "*" in pat or "?" in pat or "[" in pat
+
+
+class _Flavour(object):
+
+    """A flavour implements a particular (platform-specific) set of path
+    semantics."""
+
+    def __init__(self):
+        self.join = self.sep.join
+
+    def parse_parts(self, parts):
+        if six.PY2:
+            parts = _py2_fsencode(parts)
+        parsed = []
+        sep = self.sep
+        altsep = self.altsep
+        drv = root = ''
+        it = reversed(parts)
+        for part in it:
+            if not part:
+                continue
+            if altsep:
+                part = part.replace(altsep, sep)
+            drv, root, rel = self.splitroot(part)
+            if sep in rel:
+                for x in reversed(rel.split(sep)):
+                    if x and x != '.':
+                        parsed.append(intern(x))
+            else:
+                if rel and rel != '.':
+                    parsed.append(intern(rel))
+            if drv or root:
+                if not drv:
+                    # If no drive is present, try to find one in the previous
+                    # parts. This makes the result of parsing e.g.
+                    # ("C:", "/", "a") reasonably intuitive.
+                    for part in it:
+                        if not part:
+                            continue
+                        if altsep:
+                            part = part.replace(altsep, sep)
+                        drv = self.splitroot(part)[0]
+                        if drv:
+                            break
+                break
+        if drv or root:
+            parsed.append(drv + root)
+        parsed.reverse()
+        return drv, root, parsed
+
+    def join_parsed_parts(self, drv, root, parts, drv2, root2, parts2):
+        """
+        Join the two paths represented by the respective
+        (drive, root, parts) tuples.  Return a new (drive, root, parts) tuple.
+        """
+        if root2:
+            if not drv2 and drv:
+                return drv, root2, [drv + root2] + parts2[1:]
+        elif drv2:
+            if drv2 == drv or self.casefold(drv2) == self.casefold(drv):
+                # Same drive => second path is relative to the first
+                return drv, root, parts + parts2[1:]
+        else:
+            # Second path is non-anchored (common case)
+            return drv, root, parts + parts2
+        return drv2, root2, parts2
+
+
+class _WindowsFlavour(_Flavour):
+    # Reference for Windows paths can be found at
+    # http://msdn.microsoft.com/en-us/library/aa365247%28v=vs.85%29.aspx
+
+    sep = '\\'
+    altsep = '/'
+    has_drv = True
+    pathmod = ntpath
+
+    is_supported = (os.name == 'nt')
+
+    drive_letters = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
+    ext_namespace_prefix = '\\\\?\\'
+
+    reserved_names = (
+        set(['CON', 'PRN', 'AUX', 'NUL']) |
+        set(['COM%d' % i for i in range(1, 10)]) |
+        set(['LPT%d' % i for i in range(1, 10)])
+        )
+
+    # Interesting findings about extended paths:
+    # - '\\?\c:\a', '//?/c:\a' and '//?/c:/a' are all supported
+    #   but '\\?\c:/a' is not
+    # - extended paths are always absolute; "relative" extended paths will
+    #   fail.
+
+    def splitroot(self, part, sep=sep):
+        first = part[0:1]
+        second = part[1:2]
+        if (second == sep and first == sep):
+            # XXX extended paths should also disable the collapsing of "."
+            # components (according to MSDN docs).
+            prefix, part = self._split_extended_path(part)
+            first = part[0:1]
+            second = part[1:2]
+        else:
+            prefix = ''
+        third = part[2:3]
+        if (second == sep and first == sep and third != sep):
+            # is a UNC path:
+            # vvvvvvvvvvvvvvvvvvvvv root
+            # \\machine\mountpoint\directory\etc\...
+            #            directory ^^^^^^^^^^^^^^
+            index = part.find(sep, 2)
+            if index != -1:
+                index2 = part.find(sep, index + 1)
+                # a UNC path can't have two slashes in a row
+                # (after the initial two)
+                if index2 != index + 1:
+                    if index2 == -1:
+                        index2 = len(part)
+                    if prefix:
+                        return prefix + part[1:index2], sep, part[index2 + 1:]
+                    else:
+                        return part[:index2], sep, part[index2 + 1:]
+        drv = root = ''
+        if second == ':' and first in self.drive_letters:
+            drv = part[:2]
+            part = part[2:]
+            first = third
+        if first == sep:
+            root = first
+            part = part.lstrip(sep)
+        return prefix + drv, root, part
+
+    def casefold(self, s):
+        return s.lower()
+
+    def casefold_parts(self, parts):
+        return [p.lower() for p in parts]
+
+    def resolve(self, path, strict=False):
+        s = str(path)
+        if not s:
+            return os.getcwd()
+        previous_s = None
+        if _getfinalpathname is not None:
+            if strict:
+                return self._ext_to_normal(_getfinalpathname(s))
+            else:
+                # End of the path after the first one not found
+                tail_parts = []
+                while True:
+                    try:
+                        s = self._ext_to_normal(_getfinalpathname(s))
+                    except FileNotFoundError:
+                        previous_s = s
+                        s, tail = os.path.split(s)
+                        tail_parts.append(tail)
+                        if previous_s == s:
+                            return path
+                    else:
+                        return os.path.join(s, *reversed(tail_parts))
+        # Means fallback on absolute
+        return None
+
+    def _split_extended_path(self, s, ext_prefix=ext_namespace_prefix):
+        prefix = ''
+        if s.startswith(ext_prefix):
+            prefix = s[:4]
+            s = s[4:]
+            if s.startswith('UNC\\'):
+                prefix += s[:3]
+                s = '\\' + s[3:]
+        return prefix, s
+
+    def _ext_to_normal(self, s):
+        # Turn back an extended path into a normal DOS-like path
+        return self._split_extended_path(s)[1]
+
+    def is_reserved(self, parts):
+        # NOTE: the rules for reserved names seem somewhat complicated
+        # (e.g. r"..\NUL" is reserved but not r"foo\NUL").
+        # We err on the side of caution and return True for paths which are
+        # not considered reserved by Windows.
+        if not parts:
+            return False
+        if parts[0].startswith('\\\\'):
+            # UNC paths are never reserved
+            return False
+        return parts[-1].partition('.')[0].upper() in self.reserved_names
+
+    def make_uri(self, path):
+        # Under Windows, file URIs use the UTF-8 encoding.
+        drive = path.drive
+        if len(drive) == 2 and drive[1] == ':':
+            # It's a path on a local drive => 'file:///c:/a/b'
+            rest = path.as_posix()[2:].lstrip('/')
+            return 'file:///%s/%s' % (
+                drive, urlquote_from_bytes(rest.encode('utf-8')))
+        else:
+            # It's a path on a network drive => 'file://host/share/a/b'
+            return 'file:' + urlquote_from_bytes(
+                path.as_posix().encode('utf-8'))
+
+    def gethomedir(self, username):
+        if 'HOME' in os.environ:
+            userhome = os.environ['HOME']
+        elif 'USERPROFILE' in os.environ:
+            userhome = os.environ['USERPROFILE']
+        elif 'HOMEPATH' in os.environ:
+            try:
+                drv = os.environ['HOMEDRIVE']
+            except KeyError:
+                drv = ''
+            userhome = drv + os.environ['HOMEPATH']
+        else:
+            raise RuntimeError("Can't determine home directory")
+
+        if username:
+            # Try to guess user home directory.  By default all users
+            # directories are located in the same place and are named by
+            # corresponding usernames.  If current user home directory points
+            # to nonstandard place, this guess is likely wrong.
+            if os.environ['USERNAME'] != username:
+                drv, root, parts = self.parse_parts((userhome,))
+                if parts[-1] != os.environ['USERNAME']:
+                    raise RuntimeError("Can't determine home directory "
+                                       "for %r" % username)
+                parts[-1] = username
+                if drv or root:
+                    userhome = drv + root + self.join(parts[1:])
+                else:
+                    userhome = self.join(parts)
+        return userhome
+
+
+class _PosixFlavour(_Flavour):
+    sep = '/'
+    altsep = ''
+    has_drv = False
+    pathmod = posixpath
+
+    is_supported = (os.name != 'nt')
+
+    def splitroot(self, part, sep=sep):
+        if part and part[0] == sep:
+            stripped_part = part.lstrip(sep)
+            # According to POSIX path resolution:
+            # http://pubs.opengroup.org/onlinepubs/009695399/basedefs/
+            # xbd_chap04.html#tag_04_11
+            # "A pathname that begins with two successive slashes may be
+            # interpreted in an implementation-defined manner, although more
+            # than two leading slashes shall be treated as a single slash".
+            if len(part) - len(stripped_part) == 2:
+                return '', sep * 2, stripped_part
+            else:
+                return '', sep, stripped_part
+        else:
+            return '', '', part
+
+    def casefold(self, s):
+        return s
+
+    def casefold_parts(self, parts):
+        return parts
+
+    def resolve(self, path, strict=False):
+        sep = self.sep
+        accessor = path._accessor
+        seen = {}
+
+        def _resolve(path, rest):
+            if rest.startswith(sep):
+                path = ''
+
+            for name in rest.split(sep):
+                if not name or name == '.':
+                    # current dir
+                    continue
+                if name == '..':
+                    # parent dir
+                    path, _, _ = path.rpartition(sep)
+                    continue
+                newpath = path + sep + name
+                if newpath in seen:
+                    # Already seen this path
+                    path = seen[newpath]
+                    if path is not None:
+                        # use cached value
+                        continue
+                    # The symlink is not resolved, so we must have a symlink
+                    # loop.
+                    raise RuntimeError("Symlink loop from %r" % newpath)
+                # Resolve the symbolic link
+                try:
+                    target = accessor.readlink(newpath)
+                except OSError as e:
+                    if e.errno != EINVAL and strict:
+                        raise
+                    # Not a symlink, or non-strict mode. We just leave the path
+                    # untouched.
+                    path = newpath
+                else:
+                    seen[newpath] = None  # not resolved symlink
+                    path = _resolve(path, target)
+                    seen[newpath] = path  # resolved symlink
+
+            return path
+        # NOTE: according to POSIX, getcwd() cannot contain path components
+        # which are symlinks.
+        base = '' if path.is_absolute() else os.getcwd()
+        return _resolve(base, str(path)) or sep
+
+    def is_reserved(self, parts):
+        return False
+
+    def make_uri(self, path):
+        # We represent the path using the local filesystem encoding,
+        # for portability to other applications.
+        bpath = bytes(path)
+        return 'file://' + urlquote_from_bytes(bpath)
+
+    def gethomedir(self, username):
+        if not username:
+            try:
+                return os.environ['HOME']
+            except KeyError:
+                import pwd
+                return pwd.getpwuid(os.getuid()).pw_dir
+        else:
+            import pwd
+            try:
+                return pwd.getpwnam(username).pw_dir
+            except KeyError:
+                raise RuntimeError("Can't determine home directory "
+                                   "for %r" % username)
+
+
+_windows_flavour = _WindowsFlavour()
+_posix_flavour = _PosixFlavour()
+
+
+class _Accessor:
+
+    """An accessor implements a particular (system-specific or not) way of
+    accessing paths on the filesystem."""
+
+
+class _NormalAccessor(_Accessor):
+
+    def _wrap_strfunc(strfunc):
+        @functools.wraps(strfunc)
+        def wrapped(pathobj, *args):
+            return strfunc(str(pathobj), *args)
+        return staticmethod(wrapped)
+
+    def _wrap_binary_strfunc(strfunc):
+        @functools.wraps(strfunc)
+        def wrapped(pathobjA, pathobjB, *args):
+            return strfunc(str(pathobjA), str(pathobjB), *args)
+        return staticmethod(wrapped)
+
+    stat = _wrap_strfunc(os.stat)
+
+    lstat = _wrap_strfunc(os.lstat)
+
+    open = _wrap_strfunc(os.open)
+
+    listdir = _wrap_strfunc(os.listdir)
+
+    scandir = _wrap_strfunc(os_scandir)
+
+    chmod = _wrap_strfunc(os.chmod)
+
+    if hasattr(os, "lchmod"):
+        lchmod = _wrap_strfunc(os.lchmod)
+    else:
+        def lchmod(self, pathobj, mode):
+            raise NotImplementedError("lchmod() not available on this system")
+
+    mkdir = _wrap_strfunc(os.mkdir)
+
+    unlink = _wrap_strfunc(os.unlink)
+
+    rmdir = _wrap_strfunc(os.rmdir)
+
+    rename = _wrap_binary_strfunc(os.rename)
+
+    if sys.version_info >= (3, 3):
+        replace = _wrap_binary_strfunc(os.replace)
+
+    if nt:
+        if supports_symlinks:
+            symlink = _wrap_binary_strfunc(os.symlink)
+        else:
+            def symlink(a, b, target_is_directory):
+                raise NotImplementedError(
+                    "symlink() not available on this system")
+    else:
+        # Under POSIX, os.symlink() takes two args
+        @staticmethod
+        def symlink(a, b, target_is_directory):
+            return os.symlink(str(a), str(b))
+
+    utime = _wrap_strfunc(os.utime)
+
+    # Helper for resolve()
+    def readlink(self, path):
+        return os.readlink(path)
+
+
+_normal_accessor = _NormalAccessor()
+
+
+#
+# Globbing helpers
+#
+
+def _make_selector(pattern_parts):
+    pat = pattern_parts[0]
+    child_parts = pattern_parts[1:]
+    if pat == '**':
+        cls = _RecursiveWildcardSelector
+    elif '**' in pat:
+        raise ValueError(
+            "Invalid pattern: '**' can only be an entire path component")
+    elif _is_wildcard_pattern(pat):
+        cls = _WildcardSelector
+    else:
+        cls = _PreciseSelector
+    return cls(pat, child_parts)
+
+
+if hasattr(functools, "lru_cache"):
+    _make_selector = functools.lru_cache()(_make_selector)
+
+
+class _Selector:
+
+    """A selector matches a specific glob pattern part against the children
+    of a given path."""
+
+    def __init__(self, child_parts):
+        self.child_parts = child_parts
+        if child_parts:
+            self.successor = _make_selector(child_parts)
+            self.dironly = True
+        else:
+            self.successor = _TerminatingSelector()
+            self.dironly = False
+
+    def select_from(self, parent_path):
+        """Iterate over all child paths of `parent_path` matched by this
+        selector.  This can contain parent_path itself."""
+        path_cls = type(parent_path)
+        is_dir = path_cls.is_dir
+        exists = path_cls.exists
+        scandir = parent_path._accessor.scandir
+        if not is_dir(parent_path):
+            return iter([])
+        return self._select_from(parent_path, is_dir, exists, scandir)
+
+
+class _TerminatingSelector:
+
+    def _select_from(self, parent_path, is_dir, exists, scandir):
+        yield parent_path
+
+
+class _PreciseSelector(_Selector):
+
+    def __init__(self, name, child_parts):
+        self.name = name
+        _Selector.__init__(self, child_parts)
+
+    def _select_from(self, parent_path, is_dir, exists, scandir):
+        def try_iter():
+            path = parent_path._make_child_relpath(self.name)
+            if (is_dir if self.dironly else exists)(path):
+                for p in self.successor._select_from(
+                        path, is_dir, exists, scandir):
+                    yield p
+
+        def except_iter(exc):
+            return
+            yield
+
+        for x in _try_except_permissionerror_iter(try_iter, except_iter):
+            yield x
+
+
+class _WildcardSelector(_Selector):
+
+    def __init__(self, pat, child_parts):
+        self.pat = re.compile(fnmatch.translate(pat))
+        _Selector.__init__(self, child_parts)
+
+    def _select_from(self, parent_path, is_dir, exists, scandir):
+        def try_iter():
+            cf = parent_path._flavour.casefold
+            entries = list(scandir(parent_path))
+            for entry in entries:
+                if not self.dironly or entry.is_dir():
+                    name = entry.name
+                    casefolded = cf(name)
+                    if self.pat.match(casefolded):
+                        path = parent_path._make_child_relpath(name)
+                        for p in self.successor._select_from(
+                                path, is_dir, exists, scandir):
+                            yield p
+
+        def except_iter(exc):
+            return
+            yield
+
+        for x in _try_except_permissionerror_iter(try_iter, except_iter):
+            yield x
+
+
+class _RecursiveWildcardSelector(_Selector):
+
+    def __init__(self, pat, child_parts):
+        _Selector.__init__(self, child_parts)
+
+    def _iterate_directories(self, parent_path, is_dir, scandir):
+        yield parent_path
+
+        def try_iter():
+            entries = list(scandir(parent_path))
+            for entry in entries:
+                if entry.is_dir() and not entry.is_symlink():
+                    path = parent_path._make_child_relpath(entry.name)
+                    for p in self._iterate_directories(path, is_dir, scandir):
+                        yield p
+
+        def except_iter(exc):
+            return
+            yield
+
+        for x in _try_except_permissionerror_iter(try_iter, except_iter):
+            yield x
+
+    def _select_from(self, parent_path, is_dir, exists, scandir):
+        def try_iter():
+            yielded = set()
+            try:
+                successor_select = self.successor._select_from
+                for starting_point in self._iterate_directories(
+                        parent_path, is_dir, scandir):
+                    for p in successor_select(
+                            starting_point, is_dir, exists, scandir):
+                        if p not in yielded:
+                            yield p
+                            yielded.add(p)
+            finally:
+                yielded.clear()
+
+        def except_iter(exc):
+            return
+            yield
+
+        for x in _try_except_permissionerror_iter(try_iter, except_iter):
+            yield x
+
+
+#
+# Public API
+#
+
+class _PathParents(Sequence):
+
+    """This object provides sequence-like access to the logical ancestors
+    of a path.  Don't try to construct it yourself."""
+    __slots__ = ('_pathcls', '_drv', '_root', '_parts')
+
+    def __init__(self, path):
+        # We don't store the instance to avoid reference cycles
+        self._pathcls = type(path)
+        self._drv = path._drv
+        self._root = path._root
+        self._parts = path._parts
+
+    def __len__(self):
+        if self._drv or self._root:
+            return len(self._parts) - 1
+        else:
+            return len(self._parts)
+
+    def __getitem__(self, idx):
+        if idx < 0 or idx >= len(self):
+            raise IndexError(idx)
+        return self._pathcls._from_parsed_parts(self._drv, self._root,
+                                                self._parts[:-idx - 1])
+
+    def __repr__(self):
+        return "<{0}.parents>".format(self._pathcls.__name__)
+
+
+class PurePath(object):
+
+    """PurePath represents a filesystem path and offers operations which
+    don't imply any actual filesystem I/O.  Depending on your system,
+    instantiating a PurePath will return either a PurePosixPath or a
+    PureWindowsPath object.  You can also instantiate either of these classes
+    directly, regardless of your system.
+    """
+    __slots__ = (
+        '_drv', '_root', '_parts',
+        '_str', '_hash', '_pparts', '_cached_cparts',
+    )
+
+    def __new__(cls, *args):
+        """Construct a PurePath from one or several strings and or existing
+        PurePath objects.  The strings and path objects are combined so as
+        to yield a canonicalized path, which is incorporated into the
+        new PurePath object.
+        """
+        if cls is PurePath:
+            cls = PureWindowsPath if os.name == 'nt' else PurePosixPath
+        return cls._from_parts(args)
+
+    def __reduce__(self):
+        # Using the parts tuple helps share interned path parts
+        # when pickling related paths.
+        return (self.__class__, tuple(self._parts))
+
+    @classmethod
+    def _parse_args(cls, args):
+        # This is useful when you don't want to create an instance, just
+        # canonicalize some constructor arguments.
+        parts = []
+        for a in args:
+            if isinstance(a, PurePath):
+                parts += a._parts
+            else:
+                if sys.version_info >= (3, 6):
+                    a = os.fspath(a)
+                else:
+                    # duck typing for older Python versions
+                    if hasattr(a, "__fspath__"):
+                        a = a.__fspath__()
+                if isinstance(a, str):
+                    # Force-cast str subclasses to str (issue #21127)
+                    parts.append(str(a))
+                # also handle unicode for PY2 (six.text_type = unicode)
+                elif six.PY2 and isinstance(a, six.text_type):
+                    # cast to str using filesystem encoding
+                    parts.append(a.encode(sys.getfilesystemencoding()))
+                else:
+                    raise TypeError(
+                        "argument should be a str object or an os.PathLike "
+                        "object returning str, not %r"
+                        % type(a))
+        return cls._flavour.parse_parts(parts)
+
+    @classmethod
+    def _from_parts(cls, args, init=True):
+        # We need to call _parse_args on the instance, so as to get the
+        # right flavour.
+        self = object.__new__(cls)
+        drv, root, parts = self._parse_args(args)
+        self._drv = drv
+        self._root = root
+        self._parts = parts
+        if init:
+            self._init()
+        return self
+
+    @classmethod
+    def _from_parsed_parts(cls, drv, root, parts, init=True):
+        self = object.__new__(cls)
+        self._drv = drv
+        self._root = root
+        self._parts = parts
+        if init:
+            self._init()
+        return self
+
+    @classmethod
+    def _format_parsed_parts(cls, drv, root, parts):
+        if drv or root:
+            return drv + root + cls._flavour.join(parts[1:])
+        else:
+            return cls._flavour.join(parts)
+
+    def _init(self):
+        # Overridden in concrete Path
+        pass
+
+    def _make_child(self, args):
+        drv, root, parts = self._parse_args(args)
+        drv, root, parts = self._flavour.join_parsed_parts(
+            self._drv, self._root, self._parts, drv, root, parts)
+        return self._from_parsed_parts(drv, root, parts)
+
+    def __str__(self):
+        """Return the string representation of the path, suitable for
+        passing to system calls."""
+        try:
+            return self._str
+        except AttributeError:
+            self._str = self._format_parsed_parts(self._drv, self._root,
+                                                  self._parts) or '.'
+            return self._str
+
+    def __fspath__(self):
+        return str(self)
+
+    def as_posix(self):
+        """Return the string representation of the path with forward (/)
+        slashes."""
+        f = self._flavour
+        return str(self).replace(f.sep, '/')
+
+    def __bytes__(self):
+        """Return the bytes representation of the path.  This is only
+        recommended to use under Unix."""
+        if sys.version_info < (3, 2):
+            raise NotImplementedError("needs Python 3.2 or later")
+        return os.fsencode(str(self))
+
+    def __repr__(self):
+        return "{0}({1!r})".format(self.__class__.__name__, self.as_posix())
+
+    def as_uri(self):
+        """Return the path as a 'file' URI."""
+        if not self.is_absolute():
+            raise ValueError("relative path can't be expressed as a file URI")
+        return self._flavour.make_uri(self)
+
+    @property
+    def _cparts(self):
+        # Cached casefolded parts, for hashing and comparison
+        try:
+            return self._cached_cparts
+        except AttributeError:
+            self._cached_cparts = self._flavour.casefold_parts(self._parts)
+            return self._cached_cparts
+
+    def __eq__(self, other):
+        if not isinstance(other, PurePath):
+            return NotImplemented
+        return (
+            self._cparts == other._cparts
+            and self._flavour is other._flavour)
+
+    def __ne__(self, other):
+        return not self == other
+
+    def __hash__(self):
+        try:
+            return self._hash
+        except AttributeError:
+            self._hash = hash(tuple(self._cparts))
+            return self._hash
+
+    def __lt__(self, other):
+        if (not isinstance(other, PurePath)
+                or self._flavour is not other._flavour):
+            return NotImplemented
+        return self._cparts < other._cparts
+
+    def __le__(self, other):
+        if (not isinstance(other, PurePath)
+                or self._flavour is not other._flavour):
+            return NotImplemented
+        return self._cparts <= other._cparts
+
+    def __gt__(self, other):
+        if (not isinstance(other, PurePath)
+                or self._flavour is not other._flavour):
+            return NotImplemented
+        return self._cparts > other._cparts
+
+    def __ge__(self, other):
+        if (not isinstance(other, PurePath)
+                or self._flavour is not other._flavour):
+            return NotImplemented
+        return self._cparts >= other._cparts
+
+    drive = property(attrgetter('_drv'),
+                     doc="""The drive prefix (letter or UNC path), if any.""")
+
+    root = property(attrgetter('_root'),
+                    doc="""The root of the path, if any.""")
+
+    @property
+    def anchor(self):
+        """The concatenation of the drive and root, or ''."""
+        anchor = self._drv + self._root
+        return anchor
+
+    @property
+    def name(self):
+        """The final path component, if any."""
+        parts = self._parts
+        if len(parts) == (1 if (self._drv or self._root) else 0):
+            return ''
+        return parts[-1]
+
+    @property
+    def suffix(self):
+        """The final component's last suffix, if any."""
+        name = self.name
+        i = name.rfind('.')
+        if 0 < i < len(name) - 1:
+            return name[i:]
+        else:
+            return ''
+
+    @property
+    def suffixes(self):
+        """A list of the final component's suffixes, if any."""
+        name = self.name
+        if name.endswith('.'):
+            return []
+        name = name.lstrip('.')
+        return ['.' + suffix for suffix in name.split('.')[1:]]
+
+    @property
+    def stem(self):
+        """The final path component, minus its last suffix."""
+        name = self.name
+        i = name.rfind('.')
+        if 0 < i < len(name) - 1:
+            return name[:i]
+        else:
+            return name
+
+    def with_name(self, name):
+        """Return a new path with the file name changed."""
+        if not self.name:
+            raise ValueError("%r has an empty name" % (self,))
+        drv, root, parts = self._flavour.parse_parts((name,))
+        if (not name or name[-1] in [self._flavour.sep, self._flavour.altsep]
+                or drv or root or len(parts) != 1):
+            raise ValueError("Invalid name %r" % (name))
+        return self._from_parsed_parts(self._drv, self._root,
+                                       self._parts[:-1] + [name])
+
+    def with_suffix(self, suffix):
+        """Return a new path with the file suffix changed (or added, if
+        none).
+        """
+        # XXX if suffix is None, should the current suffix be removed?
+        f = self._flavour
+        if f.sep in suffix or f.altsep and f.altsep in suffix:
+            raise ValueError("Invalid suffix %r" % (suffix))
+        if suffix and not suffix.startswith('.') or suffix == '.':
+            raise ValueError("Invalid suffix %r" % (suffix))
+        name = self.name
+        if not name:
+            raise ValueError("%r has an empty name" % (self,))
+        old_suffix = self.suffix
+        if not old_suffix:
+            name = name + suffix
+        else:
+            name = name[:-len(old_suffix)] + suffix
+        return self._from_parsed_parts(self._drv, self._root,
+                                       self._parts[:-1] + [name])
+
+    def relative_to(self, *other):
+        """Return the relative path to another path identified by the passed
+        arguments.  If the operation is not possible (because this is not
+        a subpath of the other path), raise ValueError.
+        """
+        # For the purpose of this method, drive and root are considered
+        # separate parts, i.e.:
+        #   Path('c:/').relative_to('c:')  gives Path('/')
+        #   Path('c:/').relative_to('/')   raise ValueError
+        if not other:
+            raise TypeError("need at least one argument")
+        parts = self._parts
+        drv = self._drv
+        root = self._root
+        if root:
+            abs_parts = [drv, root] + parts[1:]
+        else:
+            abs_parts = parts
+        to_drv, to_root, to_parts = self._parse_args(other)
+        if to_root:
+            to_abs_parts = [to_drv, to_root] + to_parts[1:]
+        else:
+            to_abs_parts = to_parts
+        n = len(to_abs_parts)
+        cf = self._flavour.casefold_parts
+        if (root or drv) if n == 0 else cf(abs_parts[:n]) != cf(to_abs_parts):
+            formatted = self._format_parsed_parts(to_drv, to_root, to_parts)
+            raise ValueError("{0!r} does not start with {1!r}"
+                             .format(str(self), str(formatted)))
+        return self._from_parsed_parts('', root if n == 1 else '',
+                                       abs_parts[n:])
+
+    @property
+    def parts(self):
+        """An object providing sequence-like access to the
+        components in the filesystem path."""
+        # We cache the tuple to avoid building a new one each time .parts
+        # is accessed.  XXX is this necessary?
+        try:
+            return self._pparts
+        except AttributeError:
+            self._pparts = tuple(self._parts)
+            return self._pparts
+
+    def joinpath(self, *args):
+        """Combine this path with one or several arguments, and return a
+        new path representing either a subpath (if all arguments are relative
+        paths) or a totally different path (if one of the arguments is
+        anchored).
+        """
+        return self._make_child(args)
+
+    def __truediv__(self, key):
+        return self._make_child((key,))
+
+    def __rtruediv__(self, key):
+        return self._from_parts([key] + self._parts)
+
+    if six.PY2:
+        __div__ = __truediv__
+        __rdiv__ = __rtruediv__
+
+    @property
+    def parent(self):
+        """The logical parent of the path."""
+        drv = self._drv
+        root = self._root
+        parts = self._parts
+        if len(parts) == 1 and (drv or root):
+            return self
+        return self._from_parsed_parts(drv, root, parts[:-1])
+
+    @property
+    def parents(self):
+        """A sequence of this path's logical parents."""
+        return _PathParents(self)
+
+    def is_absolute(self):
+        """True if the path is absolute (has both a root and, if applicable,
+        a drive)."""
+        if not self._root:
+            return False
+        return not self._flavour.has_drv or bool(self._drv)
+
+    def is_reserved(self):
+        """Return True if the path contains one of the special names reserved
+        by the system, if any."""
+        return self._flavour.is_reserved(self._parts)
+
+    def match(self, path_pattern):
+        """
+        Return True if this path matches the given pattern.
+        """
+        cf = self._flavour.casefold
+        path_pattern = cf(path_pattern)
+        drv, root, pat_parts = self._flavour.parse_parts((path_pattern,))
+        if not pat_parts:
+            raise ValueError("empty pattern")
+        if drv and drv != cf(self._drv):
+            return False
+        if root and root != cf(self._root):
+            return False
+        parts = self._cparts
+        if drv or root:
+            if len(pat_parts) != len(parts):
+                return False
+            pat_parts = pat_parts[1:]
+        elif len(pat_parts) > len(parts):
+            return False
+        for part, pat in zip(reversed(parts), reversed(pat_parts)):
+            if not fnmatch.fnmatchcase(part, pat):
+                return False
+        return True
+
+
+# Can't subclass os.PathLike from PurePath and keep the constructor
+# optimizations in PurePath._parse_args().
+if sys.version_info >= (3, 6):
+    os.PathLike.register(PurePath)
+
+
+class PurePosixPath(PurePath):
+    _flavour = _posix_flavour
+    __slots__ = ()
+
+
+class PureWindowsPath(PurePath):
+    _flavour = _windows_flavour
+    __slots__ = ()
+
+
+# Filesystem-accessing classes
+
+
+class Path(PurePath):
+    __slots__ = (
+        '_accessor',
+        '_closed',
+    )
+
+    def __new__(cls, *args, **kwargs):
+        if cls is Path:
+            cls = WindowsPath if os.name == 'nt' else PosixPath
+        self = cls._from_parts(args, init=False)
+        if not self._flavour.is_supported:
+            raise NotImplementedError("cannot instantiate %r on your system"
+                                      % (cls.__name__,))
+        self._init()
+        return self
+
+    def _init(self,
+              # Private non-constructor arguments
+              template=None,
+              ):
+        self._closed = False
+        if template is not None:
+            self._accessor = template._accessor
+        else:
+            self._accessor = _normal_accessor
+
+    def _make_child_relpath(self, part):
+        # This is an optimization used for dir walking.  `part` must be
+        # a single part relative to this path.
+        parts = self._parts + [part]
+        return self._from_parsed_parts(self._drv, self._root, parts)
+
+    def __enter__(self):
+        if self._closed:
+            self._raise_closed()
+        return self
+
+    def __exit__(self, t, v, tb):
+        self._closed = True
+
+    def _raise_closed(self):
+        raise ValueError("I/O operation on closed path")
+
+    def _opener(self, name, flags, mode=0o666):
+        # A stub for the opener argument to built-in open()
+        return self._accessor.open(self, flags, mode)
+
+    def _raw_open(self, flags, mode=0o777):
+        """
+        Open the file pointed by this path and return a file descriptor,
+        as os.open() does.
+        """
+        if self._closed:
+            self._raise_closed()
+        return self._accessor.open(self, flags, mode)
+
+    # Public API
+
+    @classmethod
+    def cwd(cls):
+        """Return a new path pointing to the current working directory
+        (as returned by os.getcwd()).
+        """
+        return cls(os.getcwd())
+
+    @classmethod
+    def home(cls):
+        """Return a new path pointing to the user's home directory (as
+        returned by os.path.expanduser('~')).
+        """
+        return cls(cls()._flavour.gethomedir(None))
+
+    def samefile(self, other_path):
+        """Return whether other_path is the same or not as this file
+        (as returned by os.path.samefile()).
+        """
+        if hasattr(os.path, "samestat"):
+            st = self.stat()
+            try:
+                other_st = other_path.stat()
+            except AttributeError:
+                other_st = os.stat(other_path)
+            return os.path.samestat(st, other_st)
+        else:
+            filename1 = six.text_type(self)
+            filename2 = six.text_type(other_path)
+            st1 = _win32_get_unique_path_id(filename1)
+            st2 = _win32_get_unique_path_id(filename2)
+            return st1 == st2
+
+    def iterdir(self):
+        """Iterate over the files in this directory.  Does not yield any
+        result for the special paths '.' and '..'.
+        """
+        if self._closed:
+            self._raise_closed()
+        for name in self._accessor.listdir(self):
+            if name in ('.', '..'):
+                # Yielding a path object for these makes little sense
+                continue
+            yield self._make_child_relpath(name)
+            if self._closed:
+                self._raise_closed()
+
+    def glob(self, pattern):
+        """Iterate over this subtree and yield all existing files (of any
+        kind, including directories) matching the given pattern.
+        """
+        if not pattern:
+            raise ValueError("Unacceptable pattern: {0!r}".format(pattern))
+        pattern = self._flavour.casefold(pattern)
+        drv, root, pattern_parts = self._flavour.parse_parts((pattern,))
+        if drv or root:
+            raise NotImplementedError("Non-relative patterns are unsupported")
+        selector = _make_selector(tuple(pattern_parts))
+        for p in selector.select_from(self):
+            yield p
+
+    def rglob(self, pattern):
+        """Recursively yield all existing files (of any kind, including
+        directories) matching the given pattern, anywhere in this subtree.
+        """
+        pattern = self._flavour.casefold(pattern)
+        drv, root, pattern_parts = self._flavour.parse_parts((pattern,))
+        if drv or root:
+            raise NotImplementedError("Non-relative patterns are unsupported")
+        selector = _make_selector(("**",) + tuple(pattern_parts))
+        for p in selector.select_from(self):
+            yield p
+
+    def absolute(self):
+        """Return an absolute version of this path.  This function works
+        even if the path doesn't point to anything.
+
+        No normalization is done, i.e. all '.' and '..' will be kept along.
+        Use resolve() to get the canonical path to a file.
+        """
+        # XXX untested yet!
+        if self._closed:
+            self._raise_closed()
+        if self.is_absolute():
+            return self
+        # FIXME this must defer to the specific flavour (and, under Windows,
+        # use nt._getfullpathname())
+        obj = self._from_parts([os.getcwd()] + self._parts, init=False)
+        obj._init(template=self)
+        return obj
+
+    def resolve(self, strict=False):
+        """
+        Make the path absolute, resolving all symlinks on the way and also
+        normalizing it (for example turning slashes into backslashes under
+        Windows).
+        """
+        if self._closed:
+            self._raise_closed()
+        s = self._flavour.resolve(self, strict=strict)
+        if s is None:
+            # No symlink resolution => for consistency, raise an error if
+            # the path doesn't exist or is forbidden
+            self.stat()
+            s = str(self.absolute())
+        # Now we have no symlinks in the path, it's safe to normalize it.
+        normed = self._flavour.pathmod.normpath(s)
+        obj = self._from_parts((normed,), init=False)
+        obj._init(template=self)
+        return obj
+
+    def stat(self):
+        """
+        Return the result of the stat() system call on this path, like
+        os.stat() does.
+        """
+        return self._accessor.stat(self)
+
+    def owner(self):
+        """
+        Return the login name of the file owner.
+        """
+        import pwd
+        return pwd.getpwuid(self.stat().st_uid).pw_name
+
+    def group(self):
+        """
+        Return the group name of the file gid.
+        """
+        import grp
+        return grp.getgrgid(self.stat().st_gid).gr_name
+
+    def open(self, mode='r', buffering=-1, encoding=None,
+             errors=None, newline=None):
+        """
+        Open the file pointed by this path and return a file object, as
+        the built-in open() function does.
+        """
+        if self._closed:
+            self._raise_closed()
+        if sys.version_info >= (3, 3):
+            return io.open(
+                str(self), mode, buffering, encoding, errors, newline,
+                opener=self._opener)
+        else:
+            return io.open(str(self), mode, buffering,
+                           encoding, errors, newline)
+
+    def read_bytes(self):
+        """
+        Open the file in bytes mode, read it, and close the file.
+        """
+        with self.open(mode='rb') as f:
+            return f.read()
+
+    def read_text(self, encoding=None, errors=None):
+        """
+        Open the file in text mode, read it, and close the file.
+        """
+        with self.open(mode='r', encoding=encoding, errors=errors) as f:
+            return f.read()
+
+    def write_bytes(self, data):
+        """
+        Open the file in bytes mode, write to it, and close the file.
+        """
+        if not isinstance(data, six.binary_type):
+            raise TypeError(
+                'data must be %s, not %s' %
+                (six.binary_type.__name__, data.__class__.__name__))
+        with self.open(mode='wb') as f:
+            return f.write(data)
+
+    def write_text(self, data, encoding=None, errors=None):
+        """
+        Open the file in text mode, write to it, and close the file.
+        """
+        if not isinstance(data, six.text_type):
+            raise TypeError(
+                'data must be %s, not %s' %
+                (six.text_type.__name__, data.__class__.__name__))
+        with self.open(mode='w', encoding=encoding, errors=errors) as f:
+            return f.write(data)
+
+    def touch(self, mode=0o666, exist_ok=True):
+        """
+        Create this file with the given access mode, if it doesn't exist.
+        """
+        if self._closed:
+            self._raise_closed()
+        if exist_ok:
+            # First try to bump modification time
+            # Implementation note: GNU touch uses the UTIME_NOW option of
+            # the utimensat() / futimens() functions.
+            try:
+                self._accessor.utime(self, None)
+            except OSError:
+                # Avoid exception chaining
+                pass
+            else:
+                return
+        flags = os.O_CREAT | os.O_WRONLY
+        if not exist_ok:
+            flags |= os.O_EXCL
+        fd = self._raw_open(flags, mode)
+        os.close(fd)
+
+    def mkdir(self, mode=0o777, parents=False, exist_ok=False):
+        """
+        Create a new directory at this given path.
+        """
+        if self._closed:
+            self._raise_closed()
+
+        def _try_func():
+            self._accessor.mkdir(self, mode)
+
+        def _exc_func(exc):
+            if not parents or self.parent == self:
+                raise exc
+            self.parent.mkdir(parents=True, exist_ok=True)
+            self.mkdir(mode, parents=False, exist_ok=exist_ok)
+
+        try:
+            _try_except_filenotfounderror(_try_func, _exc_func)
+        except OSError:
+            if not exist_ok or not self.is_dir():
+                raise
+
+    def chmod(self, mode):
+        """
+        Change the permissions of the path, like os.chmod().
+        """
+        if self._closed:
+            self._raise_closed()
+        self._accessor.chmod(self, mode)
+
+    def lchmod(self, mode):
+        """
+        Like chmod(), except if the path points to a symlink, the symlink's
+        permissions are changed, rather than its target's.
+        """
+        if self._closed:
+            self._raise_closed()
+        self._accessor.lchmod(self, mode)
+
+    def unlink(self):
+        """
+        Remove this file or link.
+        If the path is a directory, use rmdir() instead.
+        """
+        if self._closed:
+            self._raise_closed()
+        self._accessor.unlink(self)
+
+    def rmdir(self):
+        """
+        Remove this directory.  The directory must be empty.
+        """
+        if self._closed:
+            self._raise_closed()
+        self._accessor.rmdir(self)
+
+    def lstat(self):
+        """
+        Like stat(), except if the path points to a symlink, the symlink's
+        status information is returned, rather than its target's.
+        """
+        if self._closed:
+            self._raise_closed()
+        return self._accessor.lstat(self)
+
+    def rename(self, target):
+        """
+        Rename this path to the given path.
+        """
+        if self._closed:
+            self._raise_closed()
+        self._accessor.rename(self, target)
+
+    def replace(self, target):
+        """
+        Rename this path to the given path, clobbering the existing
+        destination if it exists.
+        """
+        if sys.version_info < (3, 3):
+            raise NotImplementedError("replace() is only available "
+                                      "with Python 3.3 and later")
+        if self._closed:
+            self._raise_closed()
+        self._accessor.replace(self, target)
+
+    def symlink_to(self, target, target_is_directory=False):
+        """
+        Make this path a symlink pointing to the given path.
+        Note the order of arguments (self, target) is the reverse of
+        os.symlink's.
+        """
+        if self._closed:
+            self._raise_closed()
+        self._accessor.symlink(target, self, target_is_directory)
+
+    # Convenience functions for querying the stat results
+
+    def exists(self):
+        """
+        Whether this path exists.
+        """
+        try:
+            self.stat()
+        except OSError as e:
+            if e.errno not in (ENOENT, ENOTDIR):
+                raise
+            return False
+        return True
+
+    def is_dir(self):
+        """
+        Whether this path is a directory.
+        """
+        try:
+            return S_ISDIR(self.stat().st_mode)
+        except OSError as e:
+            if e.errno not in (ENOENT, ENOTDIR):
+                raise
+            # Path doesn't exist or is a broken symlink
+            # (see https://bitbucket.org/pitrou/pathlib/issue/12/)
+            return False
+
+    def is_file(self):
+        """
+        Whether this path is a regular file (also True for symlinks pointing
+        to regular files).
+        """
+        try:
+            return S_ISREG(self.stat().st_mode)
+        except OSError as e:
+            if e.errno not in (ENOENT, ENOTDIR):
+                raise
+            # Path doesn't exist or is a broken symlink
+            # (see https://bitbucket.org/pitrou/pathlib/issue/12/)
+            return False
+
+    def is_symlink(self):
+        """
+        Whether this path is a symbolic link.
+        """
+        try:
+            return S_ISLNK(self.lstat().st_mode)
+        except OSError as e:
+            if e.errno not in (ENOENT, ENOTDIR):
+                raise
+            # Path doesn't exist
+            return False
+
+    def is_block_device(self):
+        """
+        Whether this path is a block device.
+        """
+        try:
+            return S_ISBLK(self.stat().st_mode)
+        except OSError as e:
+            if e.errno not in (ENOENT, ENOTDIR):
+                raise
+            # Path doesn't exist or is a broken symlink
+            # (see https://bitbucket.org/pitrou/pathlib/issue/12/)
+            return False
+
+    def is_char_device(self):
+        """
+        Whether this path is a character device.
+        """
+        try:
+            return S_ISCHR(self.stat().st_mode)
+        except OSError as e:
+            if e.errno not in (ENOENT, ENOTDIR):
+                raise
+            # Path doesn't exist or is a broken symlink
+            # (see https://bitbucket.org/pitrou/pathlib/issue/12/)
+            return False
+
+    def is_fifo(self):
+        """
+        Whether this path is a FIFO.
+        """
+        try:
+            return S_ISFIFO(self.stat().st_mode)
+        except OSError as e:
+            if e.errno not in (ENOENT, ENOTDIR):
+                raise
+            # Path doesn't exist or is a broken symlink
+            # (see https://bitbucket.org/pitrou/pathlib/issue/12/)
+            return False
+
+    def is_socket(self):
+        """
+        Whether this path is a socket.
+        """
+        try:
+            return S_ISSOCK(self.stat().st_mode)
+        except OSError as e:
+            if e.errno not in (ENOENT, ENOTDIR):
+                raise
+            # Path doesn't exist or is a broken symlink
+            # (see https://bitbucket.org/pitrou/pathlib/issue/12/)
+            return False
+
+    def expanduser(self):
+        """ Return a new path with expanded ~ and ~user constructs
+        (as returned by os.path.expanduser)
+        """
+        if (not (self._drv or self._root)
+                and self._parts and self._parts[0][:1] == '~'):
+            homedir = self._flavour.gethomedir(self._parts[0][1:])
+            return self._from_parts([homedir] + self._parts[1:])
+
+        return self
+
+
+class PosixPath(Path, PurePosixPath):
+    __slots__ = ()
+
+
+class WindowsPath(Path, PureWindowsPath):
+    __slots__ = ()
+
+    def owner(self):
+        raise NotImplementedError("Path.owner() is unsupported on this system")
+
+    def group(self):
+        raise NotImplementedError("Path.group() is unsupported on this system")
diff --git a/tests/test_pipenv.py b/tests/test_pipenv.py
index cd0321b1..4b67530f 100644
--- a/tests/test_pipenv.py
+++ b/tests/test_pipenv.py
@@ -7,7 +7,7 @@ import json
 import pytest
 
 from pipenv.cli import activate_virtualenv
-from pipenv.utils import temp_environ, get_windows_path
+from pipenv.utils import temp_environ, get_windows_path, mkdir_p
 from pipenv.vendor import toml
 from pipenv.vendor import delegator
 from pipenv.project import Project
@@ -843,6 +843,7 @@ requests = "==2.14.0"
 
             assert 'file' in dep or 'path' in dep
 
+
     @pytest.mark.install
     @pytest.mark.files
     @pytest.mark.urls
@@ -861,3 +862,25 @@ requests = "==2.14.0"
             # check Pipfile.lock
             assert 'requests' in p.lockfile['default']
             assert 'records' in p.lockfile['default']
+
+
+    @pytest.mark.install
+    @pytest.mark.files
+    def test_relative_paths(self):
+        file_name = 'tablib-0.12.1.tar.gz'
+        test_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)))
+        source_path = os.path.abspath(os.path.join(test_dir, 'test_artifacts', file_name))
+        
+        with PipenvInstance() as p:
+            artifact_dir = 'artifacts'
+            artifact_path = os.path.join(p.path, artifact_dir)
+            mkdir_p(artifact_path)
+            shutil.copy(source_path, os.path.join(artifact_path, file_name))
+            # Test installing a relative path in a subdirectory
+            c = p.pipenv('install {}/{}'.format(artifact_dir, file_name))
+            key = [k for k in p.pipfile['packages'].keys()][0]
+            dep = p.pipfile['packages'][key]
+
+            assert 'path' in dep
+            assert u'{}'.format(os.path.join('.', artifact_dir, file_name)) == u'{}'.format(dep['path'])
+            assert c.return_code == 0
diff --git a/tests/test_utils.py b/tests/test_utils.py
index 4ca48f08..303c45aa 100644
--- a/tests/test_utils.py
+++ b/tests/test_utils.py
@@ -182,6 +182,24 @@ class TestUtils:
         assert pipenv.utils.is_valid_url(url)
         assert pipenv.utils.is_valid_url(not_url) is False
 
+    @pytest.mark.parametrize('input_path, expected', [
+        ('artifacts/file.zip', './artifacts/file.zip'),
+        ('./artifacts/file.zip', './artifacts/file.zip'),
+        ('../otherproject/file.zip', './../otherproject/file.zip')
+    ])
+    @pytest.mark.skipif(os.name == 'nt', reason='Nix-based file paths tested')
+    def test_nix_converted_relative_path(self, input_path, expected):
+        assert pipenv.utils.get_converted_relative_path(input_path) == expected
+
+    @pytest.mark.parametrize('input_path, expected', [
+        ('artifacts/file.zip', '.\\artifacts\\file.zip'),
+        ('./artifacts/file.zip', '.\\artifacts\\file.zip'),
+        ('../otherproject/file.zip', '.\\..\\otherproject\\file.zip')
+    ])
+    @pytest.mark.skipif(os.name != 'nt', reason='Windows-based file paths tested')
+    def test_win_converted_relative_path(self, input_path, expected):
+        assert pipenv.utils.get_converted_relative_path(input_path) == expected
+
     def test_download_file(self):
         url = "https://github.com/kennethreitz/pipenv/blob/master/README.rst"
         output = "test_download.rst"

commit 703776fc929ca7a6936d2a35250d3dbc3b7ac39a
Author: Dan Ryan <dan@danryan.co>
Date:   Tue Apr 3 14:27:23 2018 -0400

    Fix tests and requirements parsing
    
    - Fix zip urls and markers
    - Mock maya dependencies
    
    Signed-off-by: Dan Ryan <dan@danryan.co>

diff --git a/pipenv/requirements.py b/pipenv/requirements.py
index 5a998d0c..6b413235 100644
--- a/pipenv/requirements.py
+++ b/pipenv/requirements.py
@@ -1,5 +1,6 @@
 # -*- coding=utf-8 -*-
 from __future__ import absolute_import
+import abc
 import sys
 from pipenv import PIPENV_VENDOR, PIPENV_PATCHED
 
@@ -11,24 +12,49 @@ import requirements
 import six
 import attr
 from attr import attrs, attrib, Factory, validators
-from collections import defaultdict
 from pip9.index import Link
-from pip9.download import path_to_url, url_to_path
+from pip9.download import path_to_url
 from pip9.req.req_install import _strip_extras
 from pip9._vendor.distlib.markers import Evaluator
 from pip9._vendor.packaging.markers import Marker, InvalidMarker
 from pip9._vendor.packaging.specifiers import SpecifierSet, InvalidSpecifier
-from pipenv.utils import SCHEME_LIST, VCS_LIST, is_installable_file, is_vcs, multi_split, get_converted_relative_path, is_star, is_pinned, is_valid_url
+from pipenv.utils import SCHEME_LIST, VCS_LIST, is_installable_file, is_vcs, multi_split, get_converted_relative_path, is_star, is_valid_url
 from first import first
 
 try:
     from pathlib import Path
 except ImportError:
     from pathlib2 import Path
-
 HASH_STRING = ' --hash={0}'
 
 
+def _strip_ssh_from_git_uri(uri):
+    """Return git+ssh:// formatted URI to git+git@ format"""
+    if isinstance(uri, six.string_types):
+        uri = uri.replace('git+ssh://', 'git+')
+    return uri
+
+
+def _clean_git_uri(uri):
+    """Cleans VCS uris from pip9 format"""
+    if isinstance(uri, six.string_types):
+        # Add scheme for parsing purposes, this is also what pip does
+        if uri.startswith('git+') and '://' not in uri:
+            uri = uri.replace('git+', 'git+ssh://')
+    return uri
+
+
+def _split_vcs_method(uri):
+    """Split a vcs+uri formatted uri into (vcs, uri)"""
+    vcs_start = '{0}+'
+    vcs = first(
+        [vcs for vcs in VCS_LIST if uri.startswith(vcs_start.format(vcs))]
+    )
+    if vcs:
+        vcs, uri = uri.split('+', 1)
+    return vcs, uri
+
+
 def _validate_vcs(instance, attr_, value):
     if value not in VCS_LIST:
         raise ValueError('Invalid vcs {0!r}'.format(value))
@@ -36,7 +62,7 @@ def _validate_vcs(instance, attr_, value):
 
 def _validate_path(instance, attr_, value):
     if not os.path.exists(value):
-        raise ValueError('Invalid path {0!r}',format(value))
+        raise ValueError('Invalid path {0!r}', format(value))
 
 
 def _validate_markers(instance, attr_, value):
@@ -59,32 +85,80 @@ def _optional_instance_of(cls):
 
 @attrs
 class Source(object):
-    #: URL to PyPI instance
+    # : URL to PyPI instance
     url = attrib(default='')
-    #: If False, skip SSL checks
-    verify_ssl = attrib(default=True, validator=validators.optional(validators.instance_of(bool)))
-    #: human name to refer to this source (can be referenced in packages or dev-packages)
+    # : If False, skip SSL checks
+    verify_ssl = attrib(
+        default=True,
+        validator=validators.optional(validators.instance_of(bool)),
+    )
+    # : human name to refer to this source (can be referenced in packages or dev-packages)
     name = attrib(default='')
 
 
+class BaseRequirement(abc.ABCMeta):
+
+    @classmethod
+    def from_line(cls, line):
+        """Returns a requirement from a requirements.txt or pip-compatible line"""
+        raise NotImplementedError
+
+    @abc.abstractmethod
+    def as_line(self):
+        """Returns the current requirement as a pip-compatible line"""
+
+    @classmethod
+    def from_pipfile(cls, name, pipfile):
+        """Returns a requirement from a pipfile entry"""
+        raise NotImplementedError
+
+    @abc.abstractmethod
+    def pipfile_part(self):
+        """Returns the current requirement as a pipfile entry"""
+
+
 @attrs
-class PipenvMarkers(object):
+class PipenvMarkers(BaseRequirement):
     """System-level requirements - see PEP508 for more detail"""
-    os_name = attrib(default=None, validator=_validate_markers)
-    sys_platform = attrib(default=None, validator=_validate_markers)
-    platform_machine = attrib(default=None, validator=_validate_markers)
-    platform_python_implementation = attrib(default=None, validator=_validate_markers)
-    platform_release = attrib(default=None, validator=_validate_markers)
-    platform_system = attrib(default=None, validator=_validate_markers)
-    platform_version = attrib(default=None, validator=_validate_markers)
-    python_version = attrib(default=None, validator=_validate_markers)
-    python_full_version = attrib(default=None, validator=_validate_markers)
-    implementation_name = attrib(default=None, validator=_validate_markers)
-    implementation_version = attrib(default=None, validator=_validate_markers)
+    os_name = attrib(
+        default=None, validator=validators.optional(_validate_markers)
+    )
+    sys_platform = attrib(
+        default=None, validator=validators.optional(_validate_markers)
+    )
+    platform_machine = attrib(
+        default=None, validator=validators.optional(_validate_markers)
+    )
+    platform_python_implementation = attrib(
+        default=None, validator=validators.optional(_validate_markers)
+    )
+    platform_release = attrib(
+        default=None, validator=validators.optional(_validate_markers)
+    )
+    platform_system = attrib(
+        default=None, validator=validators.optional(_validate_markers)
+    )
+    platform_version = attrib(
+        default=None, validator=validators.optional(_validate_markers)
+    )
+    python_version = attrib(
+        default=None, validator=validators.optional(_validate_markers)
+    )
+    python_full_version = attrib(
+        default=None, validator=validators.optional(_validate_markers)
+    )
+    implementation_name = attrib(
+        default=None, validator=validators.optional(_validate_markers)
+    )
+    implementation_version = attrib(
+        default=None, validator=validators.optional(_validate_markers)
+    )
 
     @property
     def line_part(self):
-        return ' and '.join(['{0} {1}'.format(k, v) for k, v in self.__dict__.items() if v])
+        return ' and '.join(
+            ['{0} {1}'.format(k, v) for k, v in self.__dict__.items() if v]
+        )
 
     @property
     def pipfile_part(self):
@@ -92,16 +166,27 @@ class PipenvMarkers(object):
 
 
 @attrs
-class NamedRequirement(object):
+class NamedRequirement(BaseRequirement):
     name = attrib()
     version = attrib(validator=_validate_specifiers)
     req = attrib(default=None)
 
+    @req.default
+    def get_requirement(self):
+        return requirements.parse('{0}'.format(self.line_part))
+
     @classmethod
     def from_line(cls, line):
         req = requirements.parse(line)
         return cls(name=req.name, version=req.specifier, req=req)
 
+    @classmethod
+    def from_pipfile(cls, name, pipfile):
+        creation_args = {k: v for k, v in pipfile.items()}
+        creation_args['name'] = name
+        creation_args['version'] = _get_version(pipfile)
+        return cls(**creation_args)
+
     @property
     def line_part(self):
         return '{self.name}{self.version}'.format(self=self)
@@ -114,11 +199,11 @@ class NamedRequirement(object):
 
 
 @attrs
-class FileRequirement(object):
+class FileRequirement(BaseRequirement):
     """File requirements for tar.gz installable files or wheels or setup.py
     containing directories."""
-    path = attrib(default=None, validator=_validate_path)
-    #: path to hit - without any of the VCS prefixes (like git+ / http+ / etc)
+    path = attrib(default=None, validator=validators.optional(_validate_path))
+    # : path to hit - without any of the VCS prefixes (like git+ / http+ / etc)
     uri = attrib()
     name = attrib()
     link = attrib()
@@ -137,18 +222,59 @@ class FileRequirement(object):
         hash_fragment = hashed_loc[-7:]
         return hash_fragment
 
-    @req.default
-    def get_requirement(self):
-        base = '{0}'.format(self.link)
-        if self.editable:
-            base = '-e {0}'.format(base)
-        return first(requirements.parse(base))
-
     @link.default
     def get_link(self):
         target = '{0}#egg={1}'.format(self.uri, self.name)
         return Link(self.uri)
 
+    @classmethod
+    def from_line(cls, line):
+        link = None
+        path = None
+        editable = line.startswith('-e ')
+        line = line.split(' ', 1)[1] if editable else line
+        if not any([is_installable_file(line), is_valid_url(line)]):
+            raise ValueError(
+                'Supplied requirement is not installable: {0!r}'.format(line)
+            )
+
+        if is_valid_url(line):
+            link = Link(line)
+        else:
+            _path = Path(line)
+            link = Link(_path.absolute().as_uri())
+            if _path.is_absolute() or _path.as_posix() == '.':
+                path = _path.as_posix()
+            else:
+                path = get_converted_relative_path(line)
+        return cls(
+            name=link.egg_fragment,
+            path=path,
+            uri=link.url_without_fragment,
+            link=link,
+            editable=editable,
+        )
+
+    @classmethod
+    def from_pipfile(cls, name, pipfile):
+        path = pipfile.get('path')
+        uri = pipfile.get('uri')
+        editable = pipfile.get('editable')
+        return cls(name=name, path=path, uri=uri, editable=editable)
+
+    @req.default
+    def get_requirement(self):
+        base = '{0}'.format(self.link)
+        req = first(requirements.parse(base))
+        if self.editable:
+            req.editable = True
+        if self.link and self.link.scheme.startswith('file') and self.path:
+            req.path = self.path
+            req.local_file = True
+            req.uri = None
+        req.link = self.link
+        return req
+
     @property
     def line_part(self):
         seed = self.path or self.link.url or self.uri
@@ -166,19 +292,22 @@ class FileRequirement(object):
 
 @attrs
 class VCSRequirement(FileRequirement):
-    #: vcs reference name (branch / commit / tag)
+    link = attrib()
+    name = attrib()
+    req = attrib()
+    # : vcs reference name (branch / commit / tag)
     ref = attrib(default=None)
     subdirectory = attrib(default=None)
     vcs = attrib(validator=validators.optional(_validate_vcs), default=None)
-    uri = attrib(converter=_clean_git_uri)
+    uri = attrib(default=None)
 
     @link.default
     def get_link(self):
-        return build_vcs_link(self.vcs, self.uri, self.name, self.subdirectory)
+        return build_vcs_link(self.vcs, _clean_git_uri(self.uri), self.name, self.subdirectory)
 
     @name.default
     def get_name(self):
-        return self.link.egg_fragment or self.link.filename
+        return self.link.egg_fragment or self.req.name if self.req else self.link.filename
 
     @property
     def vcs_uri(self):
@@ -189,7 +318,33 @@ class VCSRequirement(FileRequirement):
 
     @req.default
     def get_requirement(self):
-        return first(requirements.parse(self.line_part))
+        req = first(requirements.parse(self.line_part))
+        if self.path and self.link and self.link.scheme.startswith('file'):
+            req.local_file = True
+            req.path = self.path
+        if self.editable:
+            req.editable = True
+        req.link = self.link
+        if self.uri != self.link.url and 'git+ssh://' in self.link.url and 'git+git@' in self.uri:
+            req.line = _strip_ssh_from_git_uri(req.line)
+            req.uri = _strip_ssh_from_git_uri(req.uri)
+        return req
+
+    @classmethod
+    def from_pipfile(cls, name, pipfile):
+        creation_args = {}
+        pipfile_keys = [
+            k
+            for k in (
+                'ref', 'vcs', 'subdirectory', 'path', 'editable', 'file', 'uri'
+            ) +
+            VCS_LIST
+            if k in pipfile
+        ]
+        for key in pipfile_keys:
+            creation_args[key] = pipfile.get(key)
+        creation_args['name'] = name
+        return cls(**creation_args)
 
     @classmethod
     def from_line(cls, line, editable=None):
@@ -201,12 +356,21 @@ class VCSRequirement(FileRequirement):
         link = Link(line)
         name = link.egg_fragment
         uri = link.url_without_fragment
-        subdirectory =  link.subdirectory_fragment
+        subdirectory = link.subdirectory_fragment
         vcs, uri = _split_vcs_method(uri)
         ref = None
         if '@' in uri:
             uri, ref = uri.rsplit('@', 1)
-        return cls(name=name, ref=ref, vcs=vcs, subdirectory=subdirectory, link=link, path=path, editable=editable)
+        return cls(
+            name=name,
+            ref=ref,
+            vcs=vcs,
+            subdirectory=subdirectory,
+            link=link,
+            path=path,
+            editable=editable,
+            uri=uri,
+        )
 
     @property
     def line_part(self):
@@ -229,13 +393,50 @@ class VCSRequirement(FileRequirement):
 class NewRequirement(object):
     name = attrib(default='')
     vcs = attrib(default=None, validator=validators.optional(_validate_vcs))
-    req = attrib(default=None, validator=_optional_instance_of(FileRequirement))
+    req = attrib(
+        default=None, validator=_optional_instance_of(BaseRequirement)
+    )
     markers = attrib(default=None)
-    specifiers = attrib(default=None, validator=_validate_specifiers)
+    specifiers = attrib(validator=validators.optional(_validate_specifiers))
     index = attrib(default=None)
     editable = attrib(default=None)
+    hashes = attrib(default=None, converter=list)
     extras = attrib(default=Factory(list))
-    hashes = attrib(default=Factory(list))
+
+    @name.default
+    def get_name(self):
+        return self.req.name
+
+    @property
+    def requirement(self):
+        return self.req.req
+
+    @property
+    def hashes_as_pip(self):
+        if self.hashes:
+            return ''.join([HASH_STRING.format(h) for h in self.hashes])
+
+        return ''
+
+    @property
+    def markers_as_pip(self):
+        if self.markers:
+            return '; {0}'.format(self.markers)
+
+        return ''
+
+    @property
+    def extras_as_pip(self):
+        if self.extras:
+            return '[{0}]'.format(','.join(self.extras))
+
+        return ''
+
+    @specifiers.default
+    def get_specifiers(self):
+        if self.req and self.req.req.specifier:
+            return self.req.req.specifier
+        return
 
     @classmethod
     def from_line(cls, line):
@@ -255,12 +456,45 @@ class NewRequirement(object):
             r = VCSRequirement.from_line(line)
         else:
             r = NamedRequirement.from_line(line)
+        r.extras = first(
+            requirements.parse('fakepkg{0}'.format(_extras_to_string(extras)))
+        )
+        return cls(
+            name=r.req.name,
+            vcs=vcs,
+            req=r,
+            markers=markers,
+            extras=extras,
+            editable=editable,
+            hashes=hashes,
+        )
+
+    @property
+    def as_line(self):
+        return '{0}{1}{2}{3}{4} {5}'.format(
+            self.req.line_part,
+            self.extras_as_pip,
+            self.requirement.specs,
+            self.markers_as_pip,
+            self.hashes_as_pip,
+            self.index,
+        )
+
+    @property
+    def as_pipfile(self):
+        good_keys = ('hashes', 'path', 'uri', 'file', 'extras', 'markers', 'editable', 'vcs', 'version', 'index', 'ref', 'subdirectory') + VCS_LIST
+        req_dict = attr.asdict(self, recurse=False)
+        name = first(self.req.pipfile_part.keys())
+        base_dict = self.req.pipfile_part['name'].copy()
+        base_dict.update({k: v for k, v in req_dict if k in good_keys and v is not None})
+        return {name: base_dict}
 
 
 @attrs
 class PipfileRequirement(object):
     path = attrib(default=None)
     uri = attrib(default=None)
+    file = attrib(default=None)
     name = attrib(default=None)
     extras = attrib(default=Factory(list))
     markers = attrib(default='')
@@ -314,7 +548,9 @@ class PipfileRequirement(object):
         if _pipfile_vcs_key and not _pipfile.get(_pipfile_vcs_key):
             _pipfile[_pipfile_vcs_key] = vcs
         markers = _pipfile.get('markers')
-        _extra_markers = [k for k in _pipfile.keys() if k in Evaluator.allowed_values.keys()]
+        _extra_markers = [
+            k for k in _pipfile.keys() if k in Evaluator.allowed_values.keys()
+        ]
         if _extra_markers:
             markers = list(markers) if markers else []
             for marker in _extra_markers:
@@ -347,7 +583,9 @@ class PipfileRequirement(object):
         req_uri = self.uri
         if self.path and not self.uri:
             req_uri = path_to_url(os.path.abspath(self.path))
-        line = self._link.url if self._link else (req_uri if req_uri else self.pip_version)
+        line = self._link.url if self._link else (
+            req_uri if req_uri else self.pip_version
+        )
         return PipenvRequirement._create_requirement(
             name=self.pip_version,
             path=self.path,
@@ -560,7 +798,8 @@ class PipenvRequirement(object):
         req_dict = {}
         req = self.requirement
         req_dict = {}
-        if req.local_file:
+        # hash paths of local files or remote zip/tarballs in non-editable mode
+        if req.local_file or (req.uri and not any([req.vcs, req.name, req.link])):
             hashable_path = req.uri or req.path
             dict_key = 'file' if req.uri else 'path'
             hashed_path = hashlib.sha256(
@@ -706,10 +945,10 @@ class PipenvRequirement(object):
         _line = line or uri or path or name
         # We don't want to only use the name on properly
         # formatted VCS inputs
-        if link:
+        if link and not vcs:
             _line = link.url
         elif vcs or is_vcs(_line):
-            _line = uri or path or line
+            _line = uri or path or line or _clean_git_uri(link.url)
             _line = '{0}{1}'.format(_editable, _line)
         req = first(requirements.parse(_line))
         req.line = line or path or uri or getattr(link, 'url', req.line)
@@ -718,7 +957,7 @@ class PipenvRequirement(object):
         if req.name and not any(
             getattr(req, prop) for prop in ['uri', 'path']
         ):
-        ### This is the stuff I still need to reimplement
+            ### This is the stuff I still need to reimplement
             if link and link.scheme.startswith('file') and path:
                 req.path = path
                 req.local_file = True
diff --git a/tests/pypi/humanize/humanize-0.5.1.tar.gz b/tests/pypi/humanize/humanize-0.5.1.tar.gz
new file mode 100644
index 00000000..b293ff05
Binary files /dev/null and b/tests/pypi/humanize/humanize-0.5.1.tar.gz differ
diff --git a/tests/pypi/maya/maya-0.3.4-py2.py3-none-any.whl b/tests/pypi/maya/maya-0.3.4-py2.py3-none-any.whl
new file mode 100644
index 00000000..7dcd32bd
Binary files /dev/null and b/tests/pypi/maya/maya-0.3.4-py2.py3-none-any.whl differ
diff --git a/tests/pypi/maya/maya-0.3.4.tar.gz b/tests/pypi/maya/maya-0.3.4.tar.gz
new file mode 100644
index 00000000..8a20fb58
Binary files /dev/null and b/tests/pypi/maya/maya-0.3.4.tar.gz differ
diff --git a/tests/pypi/pendulum/pendulum-1.4.4-cp27-cp27m-manylinux1_x86_64.whl b/tests/pypi/pendulum/pendulum-1.4.4-cp27-cp27m-manylinux1_x86_64.whl
new file mode 100644
index 00000000..b38c9d13
Binary files /dev/null and b/tests/pypi/pendulum/pendulum-1.4.4-cp27-cp27m-manylinux1_x86_64.whl differ
diff --git a/tests/pypi/pendulum/pendulum-1.4.4-cp36-cp36m-macosx_10_13_x86_64.whl b/tests/pypi/pendulum/pendulum-1.4.4-cp36-cp36m-macosx_10_13_x86_64.whl
new file mode 100644
index 00000000..72ef97b4
Binary files /dev/null and b/tests/pypi/pendulum/pendulum-1.4.4-cp36-cp36m-macosx_10_13_x86_64.whl differ
diff --git a/tests/pypi/pendulum/pendulum-1.4.4-cp36-cp36m-manylinux1_x86_64.whl b/tests/pypi/pendulum/pendulum-1.4.4-cp36-cp36m-manylinux1_x86_64.whl
new file mode 100644
index 00000000..31d50199
Binary files /dev/null and b/tests/pypi/pendulum/pendulum-1.4.4-cp36-cp36m-manylinux1_x86_64.whl differ
diff --git a/tests/pypi/pendulum/pendulum-1.4.4.tar.gz b/tests/pypi/pendulum/pendulum-1.4.4.tar.gz
new file mode 100644
index 00000000..826bc090
Binary files /dev/null and b/tests/pypi/pendulum/pendulum-1.4.4.tar.gz differ
diff --git a/tests/pypi/pytzdata/pytzdata-2018.3-py2.py3-none-any.whl b/tests/pypi/pytzdata/pytzdata-2018.3-py2.py3-none-any.whl
new file mode 100644
index 00000000..af5f8bf7
Binary files /dev/null and b/tests/pypi/pytzdata/pytzdata-2018.3-py2.py3-none-any.whl differ
diff --git a/tests/pypi/pytzdata/pytzdata-2018.3.tar.gz b/tests/pypi/pytzdata/pytzdata-2018.3.tar.gz
new file mode 100644
index 00000000..fd4e397d
Binary files /dev/null and b/tests/pypi/pytzdata/pytzdata-2018.3.tar.gz differ
diff --git a/tests/pypi/ruamel.ordereddict/ruamel.ordereddict-0.4.9-cp27-cp27m-manylinux1_x86_64.whl b/tests/pypi/ruamel.ordereddict/ruamel.ordereddict-0.4.9-cp27-cp27m-manylinux1_x86_64.whl
new file mode 100644
index 00000000..d6919701
Binary files /dev/null and b/tests/pypi/ruamel.ordereddict/ruamel.ordereddict-0.4.9-cp27-cp27m-manylinux1_x86_64.whl differ
diff --git a/tests/pypi/ruamel.ordereddict/ruamel.ordereddict-0.4.9-cp27-none-win_amd64.whl b/tests/pypi/ruamel.ordereddict/ruamel.ordereddict-0.4.9-cp27-none-win_amd64.whl
new file mode 100644
index 00000000..b2b6bcd4
Binary files /dev/null and b/tests/pypi/ruamel.ordereddict/ruamel.ordereddict-0.4.9-cp27-none-win_amd64.whl differ
diff --git a/tests/pypi/ruamel.ordereddict/ruamel.ordereddict-0.4.9.tar.gz b/tests/pypi/ruamel.ordereddict/ruamel.ordereddict-0.4.9.tar.gz
new file mode 100644
index 00000000..0a6b0769
Binary files /dev/null and b/tests/pypi/ruamel.ordereddict/ruamel.ordereddict-0.4.9.tar.gz differ
diff --git a/tests/pypi/ruamel.yaml/ruamel.yaml-0.15.9-cp27-cp27m-manylinux1_x86_64.whl b/tests/pypi/ruamel.yaml/ruamel.yaml-0.15.9-cp27-cp27m-manylinux1_x86_64.whl
new file mode 100644
index 00000000..26694f18
Binary files /dev/null and b/tests/pypi/ruamel.yaml/ruamel.yaml-0.15.9-cp27-cp27m-manylinux1_x86_64.whl differ
diff --git a/tests/pypi/ruamel.yaml/ruamel.yaml-0.15.9-cp27-cp27mu-manylinux1_x86_64.whl b/tests/pypi/ruamel.yaml/ruamel.yaml-0.15.9-cp27-cp27mu-manylinux1_x86_64.whl
new file mode 100644
index 00000000..362db9cb
Binary files /dev/null and b/tests/pypi/ruamel.yaml/ruamel.yaml-0.15.9-cp27-cp27mu-manylinux1_x86_64.whl differ
diff --git a/tests/pypi/ruamel.yaml/ruamel.yaml-0.15.9-cp36-cp36m-manylinux1_x86_64.whl b/tests/pypi/ruamel.yaml/ruamel.yaml-0.15.9-cp36-cp36m-manylinux1_x86_64.whl
new file mode 100644
index 00000000..73912720
Binary files /dev/null and b/tests/pypi/ruamel.yaml/ruamel.yaml-0.15.9-cp36-cp36m-manylinux1_x86_64.whl differ
diff --git a/tests/pypi/ruamel.yaml/ruamel.yaml-0.15.9.tar.gz b/tests/pypi/ruamel.yaml/ruamel.yaml-0.15.9.tar.gz
new file mode 100644
index 00000000..9e607d32
Binary files /dev/null and b/tests/pypi/ruamel.yaml/ruamel.yaml-0.15.9.tar.gz differ
diff --git a/tests/test_pipenv.py b/tests/test_pipenv.py
index cede5455..7fe953ab 100644
--- a/tests/test_pipenv.py
+++ b/tests/test_pipenv.py
@@ -1008,9 +1008,9 @@ allow_prereleases = true
     @pytest.mark.complex
     @pytest.mark.maya
     @needs_internet
-    def test_complex_deps_lock_and_install_properly(self):
+    def test_complex_deps_lock_and_install_properly(self, pip_src_dir, pypi):
         # This uses the real PyPI because Maya has too many dependencies...
-        with PipenvInstance() as p:
+        with PipenvInstance(chdir=True, pypi=pypi) as p:
             with open(p.pipfile_path, 'w') as f:
                 contents = """
 [packages]
@@ -1079,9 +1079,9 @@ requests = "==2.14.0"
     @pytest.mark.files
     @pytest.mark.urls
     @needs_internet
-    def test_urls_work(self, pypi):
+    def test_urls_work(self):
 
-        with PipenvInstance(pypi=pypi) as p:
+        with PipenvInstance(chdir=True) as p:
 
             c = p.pipenv('install https://github.com/divio/django-cms/archive/release/3.4.x.zip')
             assert c.return_code == 0

commit be80898920eab8f740cf61019327621a75d73947
Author: Thomas Kluyver <takowl@gmail.com>
Date:   Mon Nov 18 17:14:34 2013 -0800

    Truncate repr by default rather than changing to info view.
    
    Truncate wide HTML repr rather than changing format.
    
    Truncate HTML repr for DataFrames with MultiIndex-es
    
    Add tests for long & wide Dataframe HTML reprs
    
    Remove now-dead code for info display in HTML repr.
    
    Fix HTML repr of wide tables with named indices
    
    Make plain text repr follow HTML repr, truncating large DataFrames
    
    Fix up tests for string repr
    
    Update docs for DataFrame reprs
    
    Add an option to switch back to info repr for large DataFrames

diff --git a/doc/source/dsintro.rst b/doc/source/dsintro.rst
index 08ef25b17..828797def 100644
--- a/doc/source/dsintro.rst
+++ b/doc/source/dsintro.rst
@@ -573,8 +573,9 @@ indexing semantics are quite different in places from a matrix.
 Console display
 ~~~~~~~~~~~~~~~
 
-For very large DataFrame objects, only a summary will be printed to the console
-(here I am reading a CSV version of the **baseball** dataset from the **plyr**
+Very large DataFrames will be truncated to display them in the console.
+You can also get a summary using :meth:`~pandas.DataFrame.info`.
+(Here I am reading a CSV version of the **baseball** dataset from the **plyr**
 R package):
 
 .. ipython:: python
@@ -587,6 +588,7 @@ R package):
 
    baseball = read_csv('data/baseball.csv')
    print(baseball)
+   baseball.info()
 
 .. ipython:: python
    :suppress:
@@ -622,19 +624,8 @@ option:
 
    reset_option('line_width')
 
-You can also disable this feature via the ``expand_frame_repr`` option:
-
-.. ipython:: python
-
-   set_option('expand_frame_repr', False)
-
-   DataFrame(randn(3, 12))
-
-.. ipython:: python
-   :suppress:
-
-   reset_option('expand_frame_repr')
-
+You can also disable this feature via the ``expand_frame_repr`` option.
+This will print the table in one block.
 
 DataFrame column attribute access and IPython completion
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff --git a/doc/source/v0.13.0.txt b/doc/source/v0.13.0.txt
index 207281caa..8bf4ee0dc 100644
--- a/doc/source/v0.13.0.txt
+++ b/doc/source/v0.13.0.txt
@@ -607,6 +607,12 @@ Enhancements
   output datetime objects should be formatted. Datetimes encountered in the
   index, columns, and values will all have this formatting applied. (:issue:`4313`)
 - ``DataFrame.plot`` will scatter plot x versus y by passing ``kind='scatter'`` (:issue:`2215`)
+- The HTML and plain text representations of :class:`DataFrame` now show
+  a truncated view of the table once it exceeds a certain size, rather
+  than switching to the short info view (:issue:`4886`, :issue:`5550`).
+  This makes the representation more consistent as small DataFrames get
+  larger. To get the info view, call :meth:`DataFrame.info`, or restore
+  the old behaviour with ``set_option('display.large_repr', 'info')``.
 
 .. _whatsnew_0130.experimental:
 
diff --git a/pandas/core/config_init.py b/pandas/core/config_init.py
index 5502dc94e..b7ec76522 100644
--- a/pandas/core/config_init.py
+++ b/pandas/core/config_init.py
@@ -166,13 +166,19 @@ pc_max_seq_items = """
 
 pc_max_info_rows_doc = """
 : int or None
-    max_info_rows is the maximum number of rows for which a frame will
-    perform a null check on its columns when repr'ing To a console.
-    The default is 1,000,000 rows. So, if a DataFrame has more
-    1,000,000 rows there will be no null check performed on the
-    columns and thus the representation will take much less time to
-    display in an interactive session. A value of None means always
-    perform a null check when repr'ing.
+    Deprecated.
+"""
+
+pc_max_info_rows_deprecation_warning = """\
+max_info_rows has been deprecated, as reprs no longer use the info view.
+"""
+
+pc_large_repr_doc = """
+: 'truncate'/'info'
+
+    For DataFrames exceeding max_rows/max_cols, the repr (and HTML repr) can
+    show a truncated table (the default from 0.13), or switch to the view from
+    df.info() (the behaviour in earlier versions of pandas).
 """
 
 pc_mpl_style_doc = """
@@ -220,6 +226,8 @@ with cf.config_prefix('display'):
     cf.register_option('max_colwidth', 50, max_colwidth_doc, validator=is_int)
     cf.register_option('max_columns', 20, pc_max_cols_doc,
                        validator=is_instance_factory([type(None), int]))
+    cf.register_option('large_repr', 'truncate', pc_large_repr_doc,
+                       validator=is_one_of_factory(['truncate', 'info']))
     cf.register_option('max_info_columns', 100, pc_max_info_cols_doc,
                        validator=is_int)
     cf.register_option('colheader_justify', 'right', colheader_justify_doc,
@@ -258,6 +266,9 @@ cf.deprecate_option('display.height',
                     msg=pc_height_deprecation_warning,
                     rkey='display.max_rows')
 
+cf.deprecate_option('display.max_info_rows',
+                    msg=pc_max_info_rows_deprecation_warning)
+
 tc_sim_interactive_doc = """
 : boolean
     Whether to simulate interactive mode for purposes of testing
diff --git a/pandas/core/format.py b/pandas/core/format.py
index 7354600c7..49f64088b 100644
--- a/pandas/core/format.py
+++ b/pandas/core/format.py
@@ -263,7 +263,8 @@ class DataFrameFormatter(TableFormatter):
     def __init__(self, frame, buf=None, columns=None, col_space=None,
                  header=True, index=True, na_rep='NaN', formatters=None,
                  justify=None, float_format=None, sparsify=None,
-                 index_names=True, line_width=None, **kwds):
+                 index_names=True, line_width=None, max_rows=None, max_cols=None,
+                 **kwds):
         self.frame = frame
         self.buf = buf if buf is not None else StringIO()
         self.show_index_names = index_names
@@ -280,6 +281,8 @@ class DataFrameFormatter(TableFormatter):
         self.header = header
         self.index = index
         self.line_width = line_width
+        self.max_rows = max_rows
+        self.max_cols = max_cols
 
         if justify is None:
             self.justify = get_option("display.colheader_justify")
@@ -303,12 +306,19 @@ class DataFrameFormatter(TableFormatter):
         str_index = self._get_formatted_index()
         str_columns = self._get_formatted_column_labels()
 
-        stringified = []
-
         _strlen = _strlen_func()
 
-        for i, c in enumerate(self.columns):
-            if self.header:
+        cols_to_show = self.columns[:self.max_cols]
+        truncate_h = self.max_cols and (len(self.columns) > self.max_cols)
+        truncate_v = self.max_rows and (len(self.frame) > self.max_rows)
+        if truncate_h:
+            cols_to_show = self.columns[:self.max_cols]
+        else:
+            cols_to_show = self.columns
+
+        if self.header:
+            stringified = []
+            for i, c in enumerate(cols_to_show):
                 fmt_values = self._format_col(i)
                 cheader = str_columns[i]
 
@@ -316,7 +326,7 @@ class DataFrameFormatter(TableFormatter):
                                    *(_strlen(x) for x in cheader))
 
                 fmt_values = _make_fixed_width(fmt_values, self.justify,
-                                               minimum=max_colwidth)
+                                   minimum=max_colwidth, truncated=truncate_v)
 
                 max_len = max(np.max([_strlen(x) for x in fmt_values]),
                               max_colwidth)
@@ -326,14 +336,17 @@ class DataFrameFormatter(TableFormatter):
                     cheader = [x.rjust(max_len) for x in cheader]
 
                 stringified.append(cheader + fmt_values)
-            else:
-                stringified = [_make_fixed_width(self._format_col(i),
-                                                 self.justify)
-                               for i, c in enumerate(self.columns)]
+        else:
+            stringified = [_make_fixed_width(self._format_col(i), self.justify,
+                                             truncated=truncate_v)
+                           for i, c in enumerate(cols_to_show)]
 
         strcols = stringified
         if self.index:
             strcols.insert(0, str_index)
+        if truncate_h:
+            strcols.append(([''] * len(str_columns[-1])) \
+                            + (['...'] * min(len(self.frame), self.max_rows)) )
 
         return strcols
 
@@ -378,6 +391,11 @@ class DataFrameFormatter(TableFormatter):
         col_bins = _binify(col_widths, lwidth)
         nbins = len(col_bins)
 
+        if self.max_rows and len(self.frame) > self.max_rows:
+            nrows = self.max_rows + 1
+        else:
+            nrows = len(self.frame)
+
         str_lst = []
         st = 0
         for i, ed in enumerate(col_bins):
@@ -385,9 +403,9 @@ class DataFrameFormatter(TableFormatter):
             row.insert(0, idx)
             if nbins > 1:
                 if ed <= len(strcols) and i < nbins - 1:
-                    row.append([' \\'] + ['  '] * (len(self.frame) - 1))
+                    row.append([' \\'] + ['  '] * (nrows - 1))
                 else:
-                    row.append([' '] * len(self.frame))
+                    row.append([' '] * nrows)
 
             str_lst.append(adjoin(adjoin_width, *row))
             st = ed
@@ -458,8 +476,8 @@ class DataFrameFormatter(TableFormatter):
 
     def _format_col(self, i):
         formatter = self._get_formatter(i)
-        return format_array(self.frame.icol(i).get_values(), formatter,
-                            float_format=self.float_format,
+        return format_array(self.frame.icol(i)[:self.max_rows].get_values(),
+                            formatter, float_format=self.float_format,
                             na_rep=self.na_rep,
                             space=self.col_space)
 
@@ -467,7 +485,9 @@ class DataFrameFormatter(TableFormatter):
         """
         Render a DataFrame to a html table.
         """
-        html_renderer = HTMLFormatter(self, classes=classes)
+        html_renderer = HTMLFormatter(self, classes=classes,
+                                      max_rows=self.max_rows,
+                                      max_cols=self.max_cols)
         if hasattr(self.buf, 'write'):
             html_renderer.write_result(self.buf)
         elif isinstance(self.buf, compat.string_types):
@@ -483,8 +503,13 @@ class DataFrameFormatter(TableFormatter):
         def is_numeric_dtype(dtype):
             return issubclass(dtype.type, np.number)
 
-        if isinstance(self.columns, MultiIndex):
-            fmt_columns = self.columns.format(sparsify=False, adjoin=False)
+        if self.max_cols:
+            columns = self.columns[:self.max_cols]
+        else:
+            columns = self.columns
+
+        if isinstance(columns, MultiIndex):
+            fmt_columns = columns.format(sparsify=False, adjoin=False)
             fmt_columns = lzip(*fmt_columns)
             dtypes = self.frame.dtypes.values
             need_leadsp = dict(zip(fmt_columns, map(is_numeric_dtype, dtypes)))
@@ -496,14 +521,14 @@ class DataFrameFormatter(TableFormatter):
 
             str_columns = [list(x) for x in zip(*str_columns)]
         else:
-            fmt_columns = self.columns.format()
+            fmt_columns = columns.format()
             dtypes = self.frame.dtypes
             need_leadsp = dict(zip(fmt_columns, map(is_numeric_dtype, dtypes)))
             str_columns = [[' ' + x
                             if not self._get_formatter(i) and need_leadsp[x]
                             else x]
                            for i, (col, x) in
-                           enumerate(zip(self.columns, fmt_columns))]
+                           enumerate(zip(columns, fmt_columns))]
 
         if self.show_index_names and self.has_index_names:
             for x in str_columns:
@@ -521,7 +546,10 @@ class DataFrameFormatter(TableFormatter):
 
     def _get_formatted_index(self):
         # Note: this is only used by to_string(), not by to_html().
-        index = self.frame.index
+        if self.max_rows:
+            index = self.frame.index[:self.max_rows]
+        else:
+            index = self.frame.index
         columns = self.frame.columns
 
         show_index_names = self.show_index_names and self.has_index_names
@@ -564,7 +592,7 @@ class HTMLFormatter(TableFormatter):
 
     indent_delta = 2
 
-    def __init__(self, formatter, classes=None):
+    def __init__(self, formatter, classes=None, max_rows=None, max_cols=None):
         self.fmt = formatter
         self.classes = classes
 
@@ -574,6 +602,9 @@ class HTMLFormatter(TableFormatter):
         self.bold_rows = self.fmt.kwds.get('bold_rows', False)
         self.escape = self.fmt.kwds.get('escape', True)
 
+        self.max_rows = max_rows or len(self.fmt.frame)
+        self.max_cols = max_cols or len(self.fmt.columns)
+
     def write(self, s, indent=0):
         rs = com.pprint_thing(s)
         self.elements.append(' ' * indent + rs)
@@ -680,7 +711,9 @@ class HTMLFormatter(TableFormatter):
             else:
                 if self.fmt.index:
                     row.append(self.columns.name or '')
-                row.extend(self.columns)
+                row.extend(self.columns[:self.max_cols])
+                if len(self.columns) > self.max_cols:
+                    row.append('')
             return row
 
         self.write('<thead>', indent)
@@ -695,6 +728,13 @@ class HTMLFormatter(TableFormatter):
             sentinal = com.sentinal_factory()
             levels = self.columns.format(sparsify=sentinal, adjoin=False,
                                          names=False)
+            # Truncate column names
+            if len(levels[0]) > self.max_cols:
+                levels = [lev[:self.max_cols] for lev in levels]
+                truncated = True
+            else:
+                truncated = False
+
             level_lengths = _get_level_lengths(levels, sentinal)
 
             row_levels = self.frame.index.nlevels
@@ -716,6 +756,9 @@ class HTMLFormatter(TableFormatter):
                     j += 1
                     row.append(v)
 
+                if truncated:
+                    row.append('')
+
                 self.write_tr(row, indent, self.indent_delta, tags=tags,
                               header=True)
         else:
@@ -726,8 +769,8 @@ class HTMLFormatter(TableFormatter):
                           align=align)
 
         if self.fmt.has_index_names:
-            row = [x if x is not None else ''
-                   for x in self.frame.index.names] + [''] * len(self.columns)
+            row = [x if x is not None else '' for x in self.frame.index.names] \
+                            + [''] * min(len(self.columns), self.max_cols)
             self.write_tr(row, indent, self.indent_delta, header=True)
 
         indent -= self.indent_delta
@@ -740,15 +783,16 @@ class HTMLFormatter(TableFormatter):
         indent += self.indent_delta
 
         fmt_values = {}
-        for i in range(len(self.columns)):
+        for i in range(min(len(self.columns), self.max_cols)):
             fmt_values[i] = self.fmt._format_col(i)
+        truncated = (len(self.columns) > self.max_cols)
 
         # write values
         if self.fmt.index:
             if isinstance(self.frame.index, MultiIndex):
                 self._write_hierarchical_rows(fmt_values, indent)
             else:
-                self._write_regular_rows(fmt_values, indent)
+                self._write_regular_rows(fmt_values, indent, truncated)
         else:
             for i in range(len(self.frame)):
                 row = [fmt_values[j][i] for j in range(len(self.columns))]
@@ -760,8 +804,8 @@ class HTMLFormatter(TableFormatter):
 
         return indent
 
-    def _write_regular_rows(self, fmt_values, indent):
-        ncols = len(self.columns)
+    def _write_regular_rows(self, fmt_values, indent, truncated):
+        ncols = min(len(self.columns), self.max_cols)
 
         fmt = self.fmt._get_formatter('__index__')
         if fmt is not None:
@@ -769,10 +813,17 @@ class HTMLFormatter(TableFormatter):
         else:
             index_values = self.frame.index.format()
 
-        for i in range(len(self.frame)):
+        for i in range(min(len(self.frame), self.max_rows)):
             row = []
             row.append(index_values[i])
             row.extend(fmt_values[j][i] for j in range(ncols))
+            if truncated:
+                row.append('...')
+            self.write_tr(row, indent, self.indent_delta, tags=None,
+                          nindex_levels=1)
+
+        if len(self.frame) > self.max_rows:
+            row = [''] + (['...'] * ncols)
             self.write_tr(row, indent, self.indent_delta, tags=None,
                           nindex_levels=1)
 
@@ -780,7 +831,8 @@ class HTMLFormatter(TableFormatter):
         template = 'rowspan="%d" valign="top"'
 
         frame = self.frame
-        ncols = len(self.columns)
+        ncols = min(len(self.columns), self.max_cols)
+        truncate = (len(frame) > self.max_rows)
 
         idx_values = frame.index.format(sparsify=False, adjoin=False,
                                         names=False)
@@ -792,9 +844,13 @@ class HTMLFormatter(TableFormatter):
             sentinal = com.sentinal_factory()
             levels = frame.index.format(sparsify=sentinal, adjoin=False,
                                         names=False)
+            # Truncate row names
+            if truncate:
+                levels = [lev[:self.max_rows] for lev in levels]
+
             level_lengths = _get_level_lengths(levels, sentinal)
 
-            for i in range(len(frame)):
+            for i in range(min(len(frame), self.max_rows)):
                 row = []
                 tags = {}
 
@@ -825,6 +881,11 @@ class HTMLFormatter(TableFormatter):
                 self.write_tr(row, indent, self.indent_delta, tags=None,
                               nindex_levels=frame.index.nlevels)
 
+        # Truncation markers (...)
+        if truncate:
+            row = ([''] * frame.index.nlevels) + (['...'] * ncols)
+            self.write_tr(row, indent, self.indent_delta, tags=None)
+
 
 def _get_level_lengths(levels, sentinal=''):
     from itertools import groupby
@@ -1708,7 +1769,7 @@ def _format_timedelta64(x):
     return lib.repr_timedelta64(x)
 
 
-def _make_fixed_width(strings, justify='right', minimum=None):
+def _make_fixed_width(strings, justify='right', minimum=None, truncated=False):
     if len(strings) == 0:
         return strings
 
@@ -1737,7 +1798,12 @@ def _make_fixed_width(strings, justify='right', minimum=None):
 
         return justfunc(x, eff_len)
 
-    return [just(x) for x in strings]
+    result = [just(x) for x in strings]
+
+    if truncated:
+        result.append(justfunc('...'[:max_len], max_len))
+
+    return result
 
 
 def _trim_zeros(str_floats, na_rep='NaN'):
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index e1dafc60e..dca6c2250 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -429,6 +429,12 @@ class DataFrame(NDFrame):
 
         return repr_width < width
 
+    def _info_repr(self):
+        """True if the repr should show the info view."""
+        info_repr_option = (get_option("display.large_repr") == "info")
+        return info_repr_option and not \
+                (self._repr_fits_horizontal_() and self._repr_fits_vertical_())
+
     def __unicode__(self):
         """
         Return a string representation for a particular DataFrame
@@ -437,30 +443,18 @@ class DataFrame(NDFrame):
         py2/py3.
         """
         buf = StringIO(u(""))
-        fits_vertical = self._repr_fits_vertical_()
-        fits_horizontal = False
-        if fits_vertical:
-            # This needs to compute the entire repr
-            # so don't do it unless rownum is bounded
-            fits_horizontal = self._repr_fits_horizontal_()
-
-        if fits_vertical and fits_horizontal:
-            self.to_string(buf=buf)
-        else:
+        if self._info_repr():
+            self.info(buf=buf)
+            return buf.getvalue()
+
+        max_rows = get_option("display.max_rows")
+        max_cols = get_option("display.max_columns")
+        if get_option("display.expand_frame_repr"):
             width, _ = fmt.get_console_size()
-            max_columns = get_option("display.max_columns")
-            expand_repr = get_option("display.expand_frame_repr")
-            # within max_cols and max_rows, but cols exceed width
-            # of terminal, then use expand_repr
-            if (fits_vertical and
-                expand_repr and
-                    len(self.columns) <= max_columns):
-                self.to_string(buf=buf, line_width=width)
-            else:
-                max_info_rows = get_option('display.max_info_rows')
-                verbose = (max_info_rows is None or
-                           self.shape[0] <= max_info_rows)
-                self.info(buf=buf, verbose=verbose)
+        else:
+            width = None
+        self.to_string(buf=buf, max_rows=max_rows, max_cols=max_cols,
+                       line_width=width)
 
         return buf.getvalue()
 
@@ -480,28 +474,19 @@ class DataFrame(NDFrame):
         if com.in_qtconsole():
             raise ValueError('Disable HTML output in QtConsole')
 
+        if self._info_repr():
+            buf = StringIO(u(""))
+            self.info(buf=buf)
+            return '<pre>' + buf.getvalue() + '</pre>'
+
         if get_option("display.notebook_repr_html"):
-            fits_vertical = self._repr_fits_vertical_()
-            fits_horizontal = False
-            if fits_vertical:
-                fits_horizontal = self._repr_fits_horizontal_(
-                    ignore_width=ipnbh)
-
-            if fits_horizontal and fits_vertical:
-                return ('<div style="max-height:1000px;'
-                        'max-width:1500px;overflow:auto;">\n' +
-                        self.to_html() + '\n</div>')
-            else:
-                buf = StringIO(u(""))
-                max_info_rows = get_option('display.max_info_rows')
-                verbose = (max_info_rows is None or
-                           self.shape[0] <= max_info_rows)
-                self.info(buf=buf, verbose=verbose)
-                info = buf.getvalue()
-                info = info.replace('&', r'&amp;')
-                info = info.replace('<', r'&lt;')
-                info = info.replace('>', r'&gt;')
-                return ('<pre>\n' + info + '\n</pre>')
+            max_rows = get_option("display.max_rows")
+            max_cols = get_option("display.max_columns")
+
+            return ('<div style="max-height:1000px;'
+                    'max-width:1500px;overflow:auto;">\n' +
+                    self.to_html(max_rows=max_rows, max_cols=max_cols) \
+                    + '\n</div>')
         else:
             return None
 
@@ -1269,7 +1254,7 @@ class DataFrame(NDFrame):
                   header=True, index=True, na_rep='NaN', formatters=None,
                   float_format=None, sparsify=None, nanRep=None,
                   index_names=True, justify=None, force_unicode=None,
-                  line_width=None):
+                  line_width=None, max_rows=None, max_cols=None):
         """
         Render a DataFrame to a console-friendly tabular output.
         """
@@ -1295,7 +1280,8 @@ class DataFrame(NDFrame):
                                            justify=justify,
                                            index_names=index_names,
                                            header=header, index=index,
-                                           line_width=line_width)
+                                           line_width=line_width,
+                                           max_rows=max_rows, max_cols=max_cols)
         formatter.to_string()
 
         if buf is None:
@@ -1307,7 +1293,7 @@ class DataFrame(NDFrame):
                 header=True, index=True, na_rep='NaN', formatters=None,
                 float_format=None, sparsify=None, index_names=True,
                 justify=None, force_unicode=None, bold_rows=True,
-                classes=None, escape=True):
+                classes=None, escape=True, max_rows=None, max_cols=None):
         """
         Render a DataFrame as an HTML table.
 
@@ -1318,7 +1304,12 @@ class DataFrame(NDFrame):
         classes : str or list or tuple, default None
             CSS class(es) to apply to the resulting html table
         escape : boolean, default True
-            Convert the characters <, >, and & to HTML-safe sequences.
+            Convert the characters <, >, and & to HTML-safe sequences.=
+        max_rows : int, optional
+            Maximum number of rows to show before truncating. If None, show all.
+        max_cols : int, optional
+            Maximum number of columns to show before truncating. If None, show
+            all.
 
         """
 
@@ -1340,7 +1331,8 @@ class DataFrame(NDFrame):
                                            index_names=index_names,
                                            header=header, index=index,
                                            bold_rows=bold_rows,
-                                           escape=escape)
+                                           escape=escape,
+                                           max_rows=max_rows, max_cols=max_cols)
         formatter.to_html(classes=classes)
 
         if buf is None:
@@ -1386,7 +1378,7 @@ class DataFrame(NDFrame):
 
     def info(self, verbose=True, buf=None, max_cols=None):
         """
-        Concise summary of a DataFrame, used in __repr__ when very large.
+        Concise summary of a DataFrame.
 
         Parameters
         ----------
diff --git a/pandas/tests/test_format.py b/pandas/tests/test_format.py
index d9bf8adb7..e5cd8af31 100644
--- a/pandas/tests/test_format.py
+++ b/pandas/tests/test_format.py
@@ -3,6 +3,7 @@ from __future__ import print_function
 
 from pandas.compat import range, zip, lrange, StringIO, PY3, lzip, u
 import pandas.compat as compat
+import itertools
 import os
 import sys
 import unittest
@@ -34,6 +35,20 @@ def has_info_repr(df):
     r = repr(df)
     return r.split('\n')[0].startswith("<class")
 
+def has_horizontally_truncated_repr(df):
+    r = repr(df)
+    return any(l.strip().endswith('...') for l in r.splitlines())
+
+def has_vertically_truncated_repr(df):
+    r = repr(df)
+    return '..' in r.splitlines()[-1]
+
+def has_truncated_repr(df):
+    return has_horizontally_truncated_repr(df) or has_vertically_truncated_repr(df)
+
+def has_doubly_truncated_repr(df):
+    return has_horizontally_truncated_repr(df) and has_vertically_truncated_repr(df)
+
 def has_expanded_repr(df):
     r = repr(df)
     for line in r.split('\n'):
@@ -172,19 +187,19 @@ class TestDataFrameFormatting(unittest.TestCase):
                                 'display.width',20,
                                 'display.max_rows', 20):
                 with option_context('display.expand_frame_repr', True):
-                    self.assertFalse(has_info_repr(df_small))
+                    self.assertFalse(has_truncated_repr(df_small))
                     self.assertFalse(has_expanded_repr(df_small))
-                    self.assertFalse(has_info_repr(df_wide))
+                    self.assertFalse(has_truncated_repr(df_wide))
                     self.assertTrue(has_expanded_repr(df_wide))
-                    self.assertTrue(has_info_repr(df_tall))
-                    self.assertFalse(has_expanded_repr(df_tall))
+                    self.assertTrue(has_vertically_truncated_repr(df_tall))
+                    self.assertTrue(has_expanded_repr(df_tall))
 
                 with option_context('display.expand_frame_repr', False):
-                    self.assertFalse(has_info_repr(df_small))
+                    self.assertFalse(has_truncated_repr(df_small))
                     self.assertFalse(has_expanded_repr(df_small))
-                    self.assertTrue(has_info_repr(df_wide))
+                    self.assertFalse(has_horizontally_truncated_repr(df_wide))
                     self.assertFalse(has_expanded_repr(df_wide))
-                    self.assertTrue(has_info_repr(df_tall))
+                    self.assertTrue(has_vertically_truncated_repr(df_tall))
                     self.assertFalse(has_expanded_repr(df_tall))
 
     def test_repr_non_interactive(self):
@@ -196,7 +211,7 @@ class TestDataFrameFormatting(unittest.TestCase):
                             'display.width', 0,
                             'display.height', 0,
                             'display.max_rows',5000):
-            self.assertFalse(has_info_repr(df))
+            self.assertFalse(has_truncated_repr(df))
             self.assertFalse(has_expanded_repr(df))
 
     def test_repr_max_columns_max_rows(self):
@@ -218,20 +233,20 @@ class TestDataFrameFormatting(unittest.TestCase):
                     self.assertFalse(has_expanded_repr(mkframe(4)))
                     self.assertFalse(has_expanded_repr(mkframe(5)))
                     self.assertFalse(has_expanded_repr(df6))
-                    self.assertTrue(has_info_repr(df6))
+                    self.assertTrue(has_doubly_truncated_repr(df6))
 
                 with option_context('display.max_rows', 20,
                                     'display.max_columns', 10):
                     # Out off max_columns boundary, but no extending
                     # since not exceeding width
                     self.assertFalse(has_expanded_repr(df6))
-                    self.assertFalse(has_info_repr(df6))
+                    self.assertFalse(has_truncated_repr(df6))
 
                 with option_context('display.max_rows', 9,
                                     'display.max_columns', 10):
                     # out vertical bounds can not result in exanded repr
                     self.assertFalse(has_expanded_repr(df10))
-                    self.assertTrue(has_info_repr(df10))
+                    self.assertTrue(has_vertically_truncated_repr(df10))
 
             # width=None in terminal, auto detection
             with option_context('display.max_columns', 100,
@@ -723,45 +738,6 @@ class TestDataFrameFormatting(unittest.TestCase):
         repr(df.T)
         fmt.set_option('display.max_rows', 200)
 
-    def test_large_frame_repr(self):
-        def wrap_rows_options(f):
-            def _f(*args, **kwargs):
-                old_max_rows = pd.get_option('display.max_rows')
-                old_max_info_rows = pd.get_option('display.max_info_rows')
-                o = f(*args, **kwargs)
-                pd.set_option('display.max_rows', old_max_rows)
-                pd.set_option('display.max_info_rows', old_max_info_rows)
-                return o
-            return _f
-
-        @wrap_rows_options
-        def test_setting(value, nrows=3, ncols=2):
-            if value is None:
-                expected_difference = 0
-            elif isinstance(value, int):
-                expected_difference = ncols
-            else:
-                raise ValueError("'value' must be int or None")
-
-            with option_context('mode.sim_interactive', True):
-                pd.set_option('display.max_rows', nrows - 1)
-                pd.set_option('display.max_info_rows', value)
-
-                smallx = DataFrame(np.random.rand(nrows, ncols))
-                repr_small = repr(smallx)
-
-                bigx = DataFrame(np.random.rand(nrows + 1, ncols))
-                repr_big = repr(bigx)
-
-                diff = len(repr_small.splitlines()) - len(repr_big.splitlines())
-
-                # the difference in line count is the number of columns
-                self.assertEqual(diff, expected_difference)
-
-        test_setting(None)
-        test_setting(3)
-        self.assertRaises(ValueError, test_setting, 'string')
-
     def test_pprint_thing(self):
         import nose
         from pandas.core.common import pprint_thing as pp_t
@@ -1433,6 +1409,112 @@ c  10  11  12  13  14\
 
         fmt.reset_option('^display.')
 
+    def test_repr_html_wide(self):
+        row = lambda l, k: [tm.rands(k) for _ in range(l)]
+        max_cols = get_option('display.max_columns')
+        df = DataFrame([row(max_cols-1, 25) for _ in range(10)])
+        reg_repr = df._repr_html_()
+        assert "..." not in reg_repr
+
+        wide_df = DataFrame([row(max_cols+1, 25) for _ in range(10)])
+        wide_repr = wide_df._repr_html_()
+        assert "..." in wide_repr
+
+    def test_repr_html_wide_multiindex_cols(self):
+        row = lambda l, k: [tm.rands(k) for _ in range(l)]
+        max_cols = get_option('display.max_columns')
+
+        tuples = list(itertools.product(np.arange(max_cols//2), ['foo', 'bar']))
+        mcols = pandas.MultiIndex.from_tuples(tuples, names=['first', 'second'])
+        df = DataFrame([row(len(mcols), 25) for _ in range(10)], columns=mcols)
+        reg_repr = df._repr_html_()
+        assert '...' not in reg_repr
+
+
+        tuples = list(itertools.product(np.arange(1+(max_cols//2)), ['foo', 'bar']))
+        mcols = pandas.MultiIndex.from_tuples(tuples, names=['first', 'second'])
+        df = DataFrame([row(len(mcols), 25) for _ in range(10)], columns=mcols)
+        wide_repr = df._repr_html_()
+        assert '...' in wide_repr
+
+    def test_repr_html_long(self):
+        max_rows = get_option('display.max_rows')
+        h = max_rows - 1
+        df = pandas.DataFrame({'A':np.arange(1,1+h), 'B':np.arange(41, 41+h)})
+        reg_repr = df._repr_html_()
+        assert '...' not in reg_repr
+        assert str(40 + h) in reg_repr
+
+        h = max_rows + 1
+        df = pandas.DataFrame({'A':np.arange(1,1+h), 'B':np.arange(41, 41+h)})
+        long_repr = df._repr_html_()
+        assert '...' in long_repr
+        assert str(40 + h) not in long_repr
+
+    def test_repr_html_long_multiindex(self):
+        max_rows = get_option('display.max_rows')
+        max_L1 = max_rows//2
+
+        tuples = list(itertools.product(np.arange(max_L1), ['foo', 'bar']))
+        idx = pandas.MultiIndex.from_tuples(tuples, names=['first', 'second'])
+        df = DataFrame(np.random.randn(max_L1*2, 2), index=idx,
+                       columns=['A', 'B'])
+        reg_repr = df._repr_html_()
+        assert '...' not in reg_repr
+
+        tuples = list(itertools.product(np.arange(max_L1+1), ['foo', 'bar']))
+        idx = pandas.MultiIndex.from_tuples(tuples, names=['first', 'second'])
+        df = DataFrame(np.random.randn((max_L1+1)*2, 2), index=idx,
+                       columns=['A', 'B'])
+        long_repr = df._repr_html_()
+        assert '...' in long_repr
+
+    def test_repr_html_long_and_wide(self):
+        max_cols = get_option('display.max_columns')
+        max_rows = get_option('display.max_rows')
+
+        h, w = max_rows-1, max_cols-1
+        df = pandas.DataFrame(dict((k,np.arange(1,1+h)) for k in np.arange(w)))
+        assert '...'  not in df._repr_html_()
+
+        h, w = max_rows+1, max_cols+1
+        df = pandas.DataFrame(dict((k,np.arange(1,1+h)) for k in np.arange(w)))
+        assert '...'  in df._repr_html_()
+
+    def test_info_repr(self):
+        max_rows = get_option('display.max_rows')
+        max_cols = get_option('display.max_columns')
+        # Long
+        h, w = max_rows+1, max_cols-1
+        df = pandas.DataFrame(dict((k,np.arange(1,1+h)) for k in np.arange(w)))
+        assert has_vertically_truncated_repr(df)
+        with option_context('display.large_repr', 'info'):
+            assert has_info_repr(df)
+
+        # Wide
+        h, w = max_rows-1, max_cols+1
+        df = pandas.DataFrame(dict((k,np.arange(1,1+h)) for k in np.arange(w)))
+        assert has_vertically_truncated_repr(df)
+        with option_context('display.large_repr', 'info'):
+            assert has_info_repr(df)
+
+    def test_info_repr_html(self):
+        max_rows = get_option('display.max_rows')
+        max_cols = get_option('display.max_columns')
+        # Long
+        h, w = max_rows+1, max_cols-1
+        df = pandas.DataFrame(dict((k,np.arange(1,1+h)) for k in np.arange(w)))
+        assert '<class' not in df._repr_html_()
+        with option_context('display.large_repr', 'info'):
+            assert '<class' in df._repr_html_()
+
+        # Wide
+        h, w = max_rows-1, max_cols+1
+        df = pandas.DataFrame(dict((k,np.arange(1,1+h)) for k in np.arange(w)))
+        assert '<class' not in df._repr_html_()
+        with option_context('display.large_repr', 'info'):
+            assert '<class' in df._repr_html_()
+
     def test_fake_qtconsole_repr_html(self):
         def get_ipython():
             return {'config':

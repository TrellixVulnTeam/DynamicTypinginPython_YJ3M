commit 2134ded168d91461ccb96f66cd674d2f59048d74
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Jul 23 18:00:40 2011 -0400

    ENH: working on generic python multi-groupby generator

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 822843f82..705a8b9da 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -874,7 +874,7 @@ class DataFrame(NDFrame):
         return self._constructor(new_data)
 
     def _reindex_columns(self, new_columns):
-        new_data = self._data.reindex_items(new_columns)
+        new_data = self._data.reindex_axis(new_columns, axis=0)
         return self._constructor(new_data)
 
     def reindex_like(self, other, method=None):
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index f882e1997..c581ab7d1 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -128,15 +128,21 @@ class GroupBy(object):
         # TODO: make NaN-friendly
         return self.aggregate(np.sum)
 
-def _get_groupings(obj, grouper, axis=0):
-    pass
 
-def _group_reorder(values, label_list):
-    indexer = np.lexsort(label_list[::-1])
+def labelize(*key_arrays):
+    idicts = []
+    shape = []
+    labels = []
+    for arr in key_arrays:
+        ids, lab, counts  = _tseries.group_labels(arr)
+        shape.append(len(ids))
+        labels.append(lab)
+        idicts.append(ids)
 
-    sorted_labels = [labels.take(indexer) for labels in label_list]
-    sorted_values = values.take(indexer)
-    return sorted_values, sorted_labels
+    return tuple(shape), labels, idicts
+
+def _get_groupings(obj, grouper, axis=0):
+    pass
 
 def _convert_strings(obj, groupers):
     def _convert(arg):
@@ -427,3 +433,51 @@ class WidePanelGroupBy(GroupBy):
 class LongPanelGroupBy(GroupBy):
     pass
 
+#-------------------------------------------------------------------------------
+# Grouping generator for BlockManager
+
+def generate_groups(data, label_list, shape, axis=0):
+    """
+    Parameters
+    ----------
+    data : BlockManager
+
+    Returns
+    -------
+    generator
+    """
+    sorted_data, sorted_labels = _group_reorder(data, label_list, axis=axis)
+    return _generate_groups(sorted_data, sorted_labels, shape,
+                            0, len(label_list[0]), axis=axis, which=0)
+
+def _group_reorder(data, label_list, axis=0):
+    indexer = np.lexsort(label_list[::-1])
+    sorted_labels = [labels.take(indexer) for labels in label_list]
+
+    # this is sort of wasteful but...
+    sorted_axis = data.axes[axis].take(indexer)
+    sorted_data = data.reindex_axis(sorted_axis, axis=axis)
+
+    return sorted_data, sorted_labels
+
+def _generate_groups(data, labels, shape, start, end, axis=0, which=0):
+    axis_labels = labels[which][start:end]
+    edges = axis_labels.searchsorted(np.arange(1, shape[which] + 1),
+                                     side='left')
+
+    # time to actually aggregate
+    if which == len(labels) - 1:
+        pass
+    else:
+        stride = np.prod(shape[which+1:])
+        # get group counts on axisp
+        edges = axis_labels.searchsorted(np.arange(1, shape[which] + 1),
+                                         side='left')
+        # print edges, axis
+        start = 0
+
+        # yield subgenerators, yikes
+        for i, end in enumerate(edges):
+            yield i, _generate_groups(sorted_data, sorted_labels, shape,
+                                      start, end, axis=axis, which=which + 1)
+            start = end
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index a02a6a3b7..420be9181 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -540,6 +540,10 @@ class BlockManager(object):
             raise KeyError('no item named %s' % item)
 
     def reindex_axis(self, new_axis, method=None, axis=0):
+        if axis == 0:
+            assert(method is None)
+            return self.reindex_items(new_axis)
+
         new_axis = _ensure_index(new_axis)
         cur_axis = self.axes[axis]
 
diff --git a/pandas/src/groupby.pyx b/pandas/src/groupby.pyx
index d2b4b207e..b61017281 100644
--- a/pandas/src/groupby.pyx
+++ b/pandas/src/groupby.pyx
@@ -112,6 +112,12 @@ def groupby_indices(ndarray values):
 
 @cython.boundscheck(False)
 def group_labels(ndarray[object] values):
+    '''
+    Compute label vector from input values and associated useful data
+
+    Returns
+    -------
+    '''
     cdef:
         Py_ssize_t i, n = len(values)
         ndarray[int32_t] labels = np.empty(n, dtype=np.int32)
@@ -142,18 +148,6 @@ def group_labels(ndarray[object] values):
 
     return reverse, labels, counts[:count].copy()
 
-def labelize(*key_arrays):
-    idicts = []
-    shape = []
-    labels = []
-    for arr in key_arrays:
-        ids, lab, counts  = group_labels(arr)
-        shape.append(len(ids))
-        labels.append(lab)
-        idicts.append(ids)
-
-    return tuple(shape), labels, idicts
-
 ctypedef double_t (* agg_func)(double_t *out, double_t *values, int32_t *labels,
                                int start, int end, Py_ssize_t offset)
 
@@ -190,54 +184,10 @@ cdef void _aggregate_group(double_t *out, double_t *values,
         ndarray[int32_t] axis
         cdef Py_ssize_t stride
 
-    axis = labels[which]
-
-    # time to actually aggregate
-    if which == len(labels) - 1:
-        # print axis, start, end
-        func(out, values, <int32_t*> axis.data, start, end, offset)
-    else:
-        stride = np.prod(shape[which+1:])
-        # get group counts on axisp
-        edges = axis.searchsorted(np.arange(1, shape[which] + 1), side='left')
-        # print edges, axis
-        start = 0
-        # aggregate each subgroup
-        for end in edges:
-            _aggregate_group(out, values, labels, start, end,
-                             shape, which + 1, offset, func)
-            offset += stride
-            start = end
-
-def group_aggregate_generic(ndarray[double_t] values, list label_list,
-                            object shape, object func):
-    cdef:
-        list sorted_labels
-        ndarray result
-        agg_func func
-
-    values, sorted_labels = _group_reorder(values, label_list)
-    result = np.empty(shape, dtype=np.float64)
-    result.fill(nan)
-
-    _aggregate_group_generic(<double_t*> result.data, <double_t*> values.data,
-                             sorted_labels, 0, len(values), shape, 0, 0, func)
-
-    return result, sorted_labels
-
-cpdef _aggregate_group_generic(double_t *out, double_t *values,
-                               list labels, int start, int end, tuple shape,
-                               Py_ssize_t which, Py_ssize_t offset,
-                               object func):
-    cdef:
-        ndarray[int32_t] axis
-        cdef Py_ssize_t stride
-
-    axis = labels[which]
-
     # time to actually aggregate
     if which == len(labels) - 1:
         # print axis, start, end
+        axis = labels[which]
         func(out, values, <int32_t*> axis.data, start, end, offset)
     else:
         stride = np.prod(shape[which+1:])

commit a523e5874a4ff1466df37b38c1ea2f57b95b81ba
Author: Adam Klein <adamklein@gmail.com>
Date:   Sat Feb 18 17:45:12 2012 -0500

    ENH: made DatetimeIndex pickle-able

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index 2994ec887..0aba7aea1 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -160,6 +160,9 @@ class DateRange(DatetimeIndex):
         if offset is None:
             raise Exception('Must provide a DateOffset!')
 
+        if time_rule is None:
+            time_rule = datetools._offsetMap[offset]
+
         if offset not in _daterange_cache:
             xdr = generate_range(_CACHE_START, _CACHE_END, offset=offset)
             arr = np.array(_dt_unbox_array(list(xdr)),
@@ -203,6 +206,9 @@ class DateRange(DatetimeIndex):
 
         indexSlice = cachedRange[startLoc:endLoc]
         indexSlice.name = name
+        indexSlice.freq = time_rule
+        indexSlice.regular = True
+
         return indexSlice
 
     def __array_finalize__(self, obj):
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 2ab76ad6d..600f720d4 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1171,6 +1171,7 @@ class DatetimeIndex(Int64Index):
         subarr.freq = None
         subarr.name = name
         subarr.offset = None
+        subarr.regular = False
 
         if freq is not None:
             failure, regular = lib.conformity_check(subarr.asi8, freq)
@@ -1192,6 +1193,10 @@ class DatetimeIndex(Int64Index):
         if last > len(cache):
             raise ValueError('Fell outside freq cache (last)')
 
+        if cache is None:
+            tcache = lib.get_tcache(freq)
+            cache = tcache.cache()
+
         subarr = cache[first:last]
 
         newdti = subarr.view(cls)
@@ -1221,6 +1226,28 @@ class DatetimeIndex(Int64Index):
             newdti.regular = regular
         return newdti
 
+    def __reduce__(self):
+        """Necessary for making this object picklable"""
+        object_state = list(np.ndarray.__reduce__(self))
+        subclass_state = self.name, self.freq, self.offset, self.regular
+        object_state[2] = (object_state[2], subclass_state)
+        return tuple(object_state)
+
+    def __setstate__(self, state):
+        """Necessary for making this object picklable"""
+        if len(state) == 2:
+            nd_state, own_state = state
+            np.ndarray.__setstate__(self, nd_state)
+            self.name = own_state[0]
+            self.freq = own_state[1]
+            self.offset = own_state[2]
+            self.regular = own_state[3]
+            if self.freq is not None:
+                tcache = lib.get_tcache(self.freq)
+                self.cache = tcache.cache()
+        else:  # pragma: no cover
+            np.ndarray.__setstate__(self, state)
+
     @property
     def asi8(self):
         # to do: cache me?
@@ -1262,7 +1289,7 @@ class DatetimeIndex(Int64Index):
             if offset is None or offset == _offsetMap[self.freq]:
                 return self.fshift(n)
 
-        return super(DatetimeIndex, self).shift(n, offset) 
+        return super(DatetimeIndex, self).shift(n, offset)
 
     def fshift(self, n=1):
         """

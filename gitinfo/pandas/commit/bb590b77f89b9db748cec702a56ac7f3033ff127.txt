commit bb590b77f89b9db748cec702a56ac7f3033ff127
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jan 2 18:37:43 2012 -0500

    DOC: new merge docs, change default merge type to inner

diff --git a/doc/source/api.rst b/doc/source/api.rst
index 7a1e7ebb4..73366f49a 100644
--- a/doc/source/api.rst
+++ b/doc/source/api.rst
@@ -399,6 +399,7 @@ Combining / joining / merging
    :toctree: generated/
 
    DataFrame.join
+   DataFrame.merge
    DataFrame.append
 
 Time series-related
diff --git a/doc/source/merging.rst b/doc/source/merging.rst
index cd022e898..0e22a9edf 100644
--- a/doc/source/merging.rst
+++ b/doc/source/merging.rst
@@ -14,99 +14,163 @@
 Merging / Joining data sets
 ***************************
 
-.. _merging.append:
-
-Appending DataFrame objects
----------------------------
-
-Series and DataFrame have an ``append`` method which will glue together objects
-each of whose ``index`` (Series labels or DataFrame rows) is mutually
-exclusive.
-
-.. ipython:: python
-
-   s = Series(randn(10), index=np.arange(10))
-   s1 = s[:5]
-   s2 = s[-5:]
-   s1.append(s2)
-
-In the case of DataFrame, the indexes must be disjoint but the columns do not need to be:
+pandas has full-featured, **high performance** in-memory join operations
+idiomatically very similar to relational databases like SQL. These methods
+perform significantly better (in some cases well over an order of magnitude
+better) than other open source implementations (like ``base::merge.data.frame``
+in R). The reason for this is careful algorithmic design and internal layout of
+the data in DataFrame.
+
+.. _merging.join:
+
+Database-style DataFrame joining/merging
+----------------------------------------
+
+pandas provides a single function, ``merge``, as the entry point for all
+standard database join operations between DataFrame objects:
+
+::
+
+    merge(left, right, how='left', on=None, left_on=None, right_on=None,
+          left_index=False, right_index=False, sort=True,
+          suffixes=('.x', '.y'), copy=True)
+
+Here's a description of what each argument is for:
+
+  - ``left``: A DataFrame object
+  - ``right``: Another DataFrame object
+  - ``on``: Columns (names) to join on. Must be found in both the left and
+    right DataFrame objects. If not passed and ``left_index`` and
+    ``right_index`` are ``False``, the intersectino of the columns in the
+    DataFrames will be inferred to be the join keys
+  - ``left_on``: Columns from the left DataFrame to use as keys. Can either be
+    column names or arrays with length equal to the length of the DataFrame
+  - ``right_on``: Columns from the left DataFrame to use as keys. Can either be
+    column names or arrays with length equal to the length of the DataFrame
+  - ``left_index``: If ``True``, use the index (row labels) from the left
+    DataFrame as its join key(s). In the case of a DataFrame with a MultiIndex
+    (hierarchical), the number of levels must match the number of join keys
+    from the right DataFrame
+  - ``right_index``: Same usage as ``left_index`` for the right DataFrame
+  - ``how``: One of ``'left'``, ``'right'``, ``'outer'``, ``'inner'``. Defaults
+    to ``inner``. See below for more detailed description of each method
+  - ``sort``: Sort the result DataFrame by the join keys in lexicographical
+    order. Defaults to ``True``, setting to ``False`` will improve performance
+    substantially in many cases
+  - ``suffixes``: A tuple of string suffixes to apply to overlapping
+    columns. Defaults to ``('.x', '.y')``.
+  - ``copy``: Always copy data (default ``True``) from the passed DataFrame
+    objects, even when reindexing is not necessary. Cannot be avoided in many
+    cases but may improve performance / memory usage. The cases where copying
+    can be avoided are somewhat pathological but this option is provided
+    nonetheless.
+
+``merge`` is a function in the pandas namespace, and it is also available as a
+DataFrame instance method, with the calling DataFrame being implicitly
+considered the left object in the join.
+
+The related ``DataFrame.join``, uses ``merge`` internally for the
+index-on-index and index-on-column(s) joins, but *joins on indexes* by default
+rather than trying to join on common columns (the default behavior for
+``merge``). If you are joining on index, you may wish to use ``DataFrame.join``
+to save yourself some typing.
+
+Brief primer on merge methods (relational algebra)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Experienced users of relational databases like SQL will be familiar with the
+terminology used to describe join operations between two SQL-table like
+structures (DataFrame objects). There are several cases to consider which are
+very important to understand:
+
+  - **one-to-one** joins: for example when joining two DataFrame objects on
+    their indexes (which must contain unique values)
+  - **many-to-one** joins: for example when joining an index (unique) to one or
+    more columns in a DataFrame
+  - **many-to-many** joins: joining columns on columns.
+
+.. note::
+
+   When joining columns on columns (potentially a many-to-many join), any
+   indexes on the passed DataFrame objects **will be discarded**.
+
+
+It is worth spending some time understanding the result of the **many-to-many**
+join case. In SQL / standard relational algebra, if a key combination appears
+more than once in both tables, the resulting table will have the **Cartesian
+product** of the associated data. Here is a very basic example with one unique
+key combination:
 
 .. ipython:: python
 
-   df = DataFrame(randn(6, 4), index=DateRange('1/1/2000', periods=6),
-                  columns=['A', 'B', 'C', 'D'])
-   df1 = df.ix[:3]
-   df2 = df.ix[3:, :3]
-   df1
-   df2
-   df1.append(df2)
-
-Appending record-array like DataFrames
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-For DataFrames which don't have a meaningful index, you may wish to append them
-and ignore the fact that they may have overlapping indexes:
-
-.. ipython:: python
-
-   df1 = DataFrame(randn(6, 4), columns=['A', 'B', 'C', 'D'])
-   df2 = DataFrame(randn(3, 4), columns=['A', 'B', 'C', 'D'])
-
-   df1
-   df2
+   left = DataFrame({'key': ['foo', 'foo'], 'lval': [1, 2]})
+   right = DataFrame({'key': ['foo', 'foo'], 'rval': [4, 5]})
+   left
+   right
+   merge(left, right, on='key')
 
-.. _merging.ignore_index:
-
-To do this, use the ``ignore_index`` argument:
+Here is a more complicated example with multiple join keys:
 
 .. ipython:: python
 
-   df1.append(df2, ignore_index=True)
-
-.. _merging.append.row:
-
-Appending single rows to a DataFrame
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+   left = DataFrame({'key1': ['foo', 'foo', 'bar'],
+                     'key2': ['one', 'two', 'one'],
+                     'lval': [1, 2, 3]})
+   right = DataFrame({'key1': ['foo', 'foo', 'bar', 'bar'],
+                      'key2': ['one', 'one', 'one', 'two'],
+                      'rval': [4, 5, 6, 7]})
+   merge(left, right, how='outer')
+   merge(left, right, how='inner')
+
+The ``how`` argument to ``merge`` specifies how to determine which keys are to
+be included in the resulting table. If a key combination **does not appear** in
+either the left or right tables, the values in the joined table will be
+``NA``. Here is a summary of the ``how`` options and their SQL equivalent names:
+
+.. csv-table::
+    :header: "Merge method", "SQL Join Name", "Description"
+    :widths: 20, 20, 60
+
+    ``left``, ``LEFT OUTER JOIN``, Use keys from left frame only
+    ``right``, ``RIGHT OUTER JOIN``, Use keys from right frame only
+    ``outer``, ``FULL OUTER JOIN``, Use union of keys from both frames
+    ``inner``, ``INNER JOIN``, Use intersection of keys from both frames
+
+Note that if using the index from either the left or right DataFrame (or both)
+using the ``left_index`` / ``right_index`` options, the join operation is no
+longer a many-to-many join by construction, as the index values are necessarily
+unique. There will be some examples of this below.
+
+.. _merging.join.index:
+
+Joining on index
+~~~~~~~~~~~~~~~~
 
-While not especially efficient (since a new object must be created), you can
-append a row to a DataFrame by passing a Series to ``append``, which returns a
-new DataFrame as above:
+``DataFrame.join`` is a convenient method for combining the columns of two
+potentially differently-indexed DataFrames into a single result DataFrame. Here
+is a very basic example:
 
 .. ipython:: python
 
    df = DataFrame(np.random.randn(8, 4), columns=['A','B','C','D'])
-   df
-   s = df.xs(3)
-   df.append(s, ignore_index=True)
-
-
-Joining / merging DataFrames
-----------------------------
-
-The ``join`` method on DataFrame combines objects with **disjoint columns** by
-lining up the rows based on some logic. The default alignment matches ``index``
-on ``index``, with a ``how`` argument with the following options:
-
-  - ``how='left'``: use the calling DataFrame's index
-  - ``how='right'``: use the index of the DataFrame passed to ``join``
-  - ``how='inner'``: intersect the indexes
-  - ``how='outer'``: take the union of the indexes
-
-Here are some examples:
-
-.. ipython:: python
-
    df1 = df.ix[1:, ['A', 'B']]
    df2 = df.ix[:5, ['C', 'D']]
    df1
    df2
-   df1.join(df2) # defaults to how='left'
+   df1.join(df2)
    df1.join(df2, how='outer')
    df1.join(df2, how='inner')
 
-Joining on a key
-~~~~~~~~~~~~~~~~
+The data alignment here is on the indexes (row labels). This same behavior can
+be achieved using ``merge`` plus additional arguments instructing it to use the
+indexes:
+
+.. ipython:: python
+
+   merge(df1, df2, left_index=True, right_index=True, how='outer')
+
+Joining key columns on an index
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 ``join`` takes an optional ``on`` argument which should be a column name in the
 calling DataFrame which will be used to "align" the passed DataFrame. The
@@ -164,12 +228,86 @@ inner join is also supported:
 
 This drops any rows where there was no match.
 
-Merging ordered records
-~~~~~~~~~~~~~~~~~~~~~~~
+Overlapping value columns
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The merge ``suffixes`` argument takes a tuple of list of strings to append to
+overlapping column names in the input DataFrames to disambiguate the result
+columns:
 
-This has not been implemented yet
+   left = DataFrame({'key': ['foo', 'foo'], 'value': [1, 2]})
+   right = DataFrame({'key': ['foo', 'foo'], 'value': [4, 5]})
+   merge(left, right, on='key', suffixes=['_left', '_right'])
+
+``DataFrame.join`` has ``lsuffix`` and ``rsuffix`` arguments
 
 Joining multiple DataFrame objects at once
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 This has not been implemented yet, but is due to be implemented soon.
+
+.. _merging.append:
+
+Appending DataFrame objects
+---------------------------
+
+Series and DataFrame have an ``append`` method which will glue together objects
+each of whose ``index`` (Series labels or DataFrame rows) is mutually
+exclusive.
+
+.. ipython:: python
+
+   s = Series(randn(10), index=np.arange(10))
+   s1 = s[:5]
+   s2 = s[-5:]
+   s1.append(s2)
+
+In the case of DataFrame, the indexes must be disjoint but the columns do not need to be:
+
+.. ipython:: python
+
+   df = DataFrame(randn(6, 4), index=DateRange('1/1/2000', periods=6),
+                  columns=['A', 'B', 'C', 'D'])
+   df1 = df.ix[:3]
+   df2 = df.ix[3:, :3]
+   df1
+   df2
+   df1.append(df2)
+
+Appending record-array like DataFrames
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+For DataFrames which don't have a meaningful index, you may wish to append them
+and ignore the fact that they may have overlapping indexes:
+
+.. ipython:: python
+
+   df1 = DataFrame(randn(6, 4), columns=['A', 'B', 'C', 'D'])
+   df2 = DataFrame(randn(3, 4), columns=['A', 'B', 'C', 'D'])
+
+   df1
+   df2
+
+.. _merging.ignore_index:
+
+To do this, use the ``ignore_index`` argument:
+
+.. ipython:: python
+
+   df1.append(df2, ignore_index=True)
+
+.. _merging.append.row:
+
+Appending single rows to a DataFrame
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+While not especially efficient (since a new object must be created), you can
+append a row to a DataFrame by passing a Series to ``append``, which returns a
+new DataFrame as above:
+
+.. ipython:: python
+
+   df = DataFrame(np.random.randn(8, 4), columns=['A','B','C','D'])
+   df
+   s = df.xs(3)
+   df.append(s, ignore_index=True)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index fdcf72964..a8cc4f153 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -106,7 +106,7 @@ columns, the index will be passed on.
 Parameters
 ----------%s
 right : DataFrame
-how : {'left', 'right', 'outer', 'inner'}, default 'left'
+how : {'left', 'right', 'outer', 'inner'}, default 'inner'
     * left: use only keys from left frame (SQL: left outer join)
     * right: use only keys from right frame (SQL: right outer join)
     * outer: use union of keys from both frames (SQL: full outer join)
@@ -138,16 +138,21 @@ copy : boolean, default True
 Examples
 --------
 
-A                  B
-
+>>> A              >>> B
     lkey value         rkey value
 0   foo  1         0   foo  5
 1   bar  2         1   bar  6
 2   baz  3         2   qux  7
-3   foo  4
-
-merge(A, B, left_on='lkey', right_on='rkey', how='outer')
+3   foo  4         3   bar  8
 
+>>> merge(A, B, left_on='lkey', right_on='rkey', how='outer')
+   lkey  value.x  rkey  value.y
+0  bar   2        bar   6
+1  bar   2        bar   8
+2  baz   3        NaN   NaN
+3  foo   1        foo   5
+4  foo   4        foo   5
+5  NaN   NaN      qux   7
 
 Returns
 -------
@@ -2837,7 +2842,7 @@ class DataFrame(NDFrame):
                      left_index=on is None, right_index=True,
                      suffixes=(lsuffix, rsuffix))
 
-    def merge(self, right, how='left', on=None, left_on=None, right_on=None,
+    def merge(self, right, how='inner', on=None, left_on=None, right_on=None,
               left_index=False, right_index=False, sort=True,
               suffixes=('.x', '.y'), copy=True):
         from pandas.tools.merge import merge
diff --git a/pandas/tests/test_graphics.py b/pandas/tests/test_graphics.py
index b299b21be..8ac07220e 100644
--- a/pandas/tests/test_graphics.py
+++ b/pandas/tests/test_graphics.py
@@ -36,7 +36,7 @@ class TestSeriesPlots(unittest.TestCase):
         _check_plot_works(self.ts.plot, label='foo')
         _check_plot_works(self.ts.plot, use_index=False)
         _check_plot_works(self.ts.plot, rot=0)
-        _check_plot_works(self.ts.plot, style='.')
+        _check_plot_works(self.ts.plot, style='.', logy=True)
         _check_plot_works(self.ts[:10].plot, kind='bar')
         _check_plot_works(self.series[:5].plot, kind='bar')
 
diff --git a/pandas/tools/merge.py b/pandas/tools/merge.py
index 2fa0b7826..d477260e2 100644
--- a/pandas/tools/merge.py
+++ b/pandas/tools/merge.py
@@ -14,7 +14,7 @@ import pandas.core.common as com
 
 import pandas._tseries as lib
 
-def merge(left, right, how='left', on=None, left_on=None, right_on=None,
+def merge(left, right, how='inner', on=None, left_on=None, right_on=None,
           left_index=False, right_index=False, sort=True,
           suffixes=('.x', '.y'), copy=True):
     op = _MergeOperation(left, right, how=how, on=on, left_on=left_on,
diff --git a/vb_suite/join_merge.py b/vb_suite/join_merge.py
index 759ac758b..450566e02 100644
--- a/vb_suite/join_merge.py
+++ b/vb_suite/join_merge.py
@@ -57,7 +57,7 @@ join_dataframe_index_single_key_bigger = \
 join_dataframe_index_multi = \
     Benchmark("df.join(df_multi, on=['key1', 'key2'])", setup,
               name='join_dataframe_index_multi',
-              start_date=datetime(2011, 9, 1))
+              start_date=datetime(2011, 10, 20))
 
 #----------------------------------------------------------------------
 # DataFrame joins on index

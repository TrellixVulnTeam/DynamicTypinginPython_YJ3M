commit bd8daeda32e9ae37ab1eec00b8bf6c77fadc2511
Author: jreback <jeff@reback.net>
Date:   Sun Sep 29 17:08:32 2013 -0400

    CLN: pytables cleanup added functiones (previously deleted/moved to computation/pytables.py)

diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 42a434c00..ff0e1b08d 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -3966,227 +3966,6 @@ def _need_convert(kind):
         return True
     return False
 
-
-class Coordinates(object):
-
-    """ holds a returned coordinates list, useful to select the same rows from different tables
-
-    coordinates : holds the array of coordinates
-    group       : the source group
-    where       : the source where
-    """
-
-    _ops = ['<=', '<', '>=', '>', '!=', '==', '=']
-    _search = re.compile(
-        "^\s*(?P<field>\w+)\s*(?P<op>%s)\s*(?P<value>.+)\s*$" % '|'.join(_ops))
-    _max_selectors = 31
-
-    def __init__(self, field, op=None, value=None, queryables=None, encoding=None):
-        self.field = None
-        self.op = None
-        self.value = None
-        self.q = queryables or dict()
-        self.filter = None
-        self.condition = None
-        self.encoding = encoding
-
-        # unpack lists/tuples in field
-        while(isinstance(field, (tuple, list))):
-            f = field
-            field = f[0]
-            if len(f) > 1:
-                op = f[1]
-            if len(f) > 2:
-                value = f[2]
-
-        # backwards compatible
-        if isinstance(field, dict):
-            self.field = field.get('field')
-            self.op = field.get('op') or '=='
-            self.value = field.get('value')
-
-        # passed a term
-        elif isinstance(field, Term):
-            self.field = field.field
-            self.op = field.op
-            self.value = field.value
-
-        # a string expression (or just the field)
-        elif isinstance(field, compat.string_types):
-
-            # is a term is passed
-            s = self._search.match(field)
-            if s is not None:
-                self.field = s.group('field')
-                self.op = s.group('op')
-                self.value = s.group('value')
-
-            else:
-                self.field = field
-
-                # is an op passed?
-                if isinstance(op, compat.string_types) and op in self._ops:
-                    self.op = op
-                    self.value = value
-                else:
-                    self.op = '=='
-                    self.value = op
-
-        else:
-            raise ValueError(
-                "Term does not understand the supplied field [%s]" % field)
-
-        # we have valid fields
-        if self.field is None or self.op is None or self.value is None:
-            raise ValueError("Could not create this term [%s]" % str(self))
-
-         # = vs ==
-        if self.op == '=':
-            self.op = '=='
-
-        # we have valid conditions
-        if self.op in ['>', '>=', '<', '<=']:
-            if hasattr(self.value, '__iter__') and len(self.value) > 1 and not isinstance(self.value, compat.string_types):
-                raise ValueError(
-                    "an inequality condition cannot have multiple values [%s]" % str(self))
-
-        if not is_list_like(self.value):
-            self.value = [self.value]
-
-        if len(self.q):
-            self.eval()
-
-    def __unicode__(self):
-        attrs = lmap(pprint_thing, (self.field, self.op, self.value))
-        return "field->%s,op->%s,value->%s" % tuple(attrs)
-
-    @property
-    def is_valid(self):
-        """ return True if this is a valid field """
-        return self.field in self.q
-
-    @property
-    def is_in_table(self):
-        """ return True if this is a valid column name for generation (e.g. an actual column in the table) """
-        return self.q.get(self.field) is not None
-
-    @property
-    def kind(self):
-        """ the kind of my field """
-        return self.q.get(self.field)
-
-    def generate(self, v):
-        """ create and return the op string for this TermValue """
-        val = v.tostring(self.encoding)
-        return "(%s %s %s)" % (self.field, self.op, val)
-
-    def eval(self):
-        """ set the numexpr expression for this term """
-
-        if not self.is_valid:
-            raise ValueError("query term is not valid [{0}]\n"
-                             "  all queries terms must include a reference to\n"
-                             "  either an axis (e.g. index or column), or a data_columns\n".format(str(self)))
-
-        # convert values if we are in the table
-        if self.is_in_table:
-            values = [self.convert_value(v) for v in self.value]
-        else:
-            values = [TermValue(v, v, self.kind) for v in self.value]
-
-        # equality conditions
-        if self.op in ['==', '!=']:
-
-            # our filter op expression
-            if self.op == '!=':
-                filter_op = lambda axis, vals: not axis.isin(vals)
-            else:
-                filter_op = lambda axis, vals: axis.isin(vals)
-
-            if self.is_in_table:
-
-                # too many values to create the expression?
-                if len(values) <= self._max_selectors:
-                    vs = [self.generate(v) for v in values]
-                    self.condition = "(%s)" % ' | '.join(vs)
-
-                # use a filter after reading
-                else:
-                    self.filter = (
-                        self.field, filter_op, Index([v.value for v in values]))
-
-            else:
-
-                self.filter = (
-                    self.field, filter_op, Index([v.value for v in values]))
-
-        else:
-
-            if self.is_in_table:
-
-                self.condition = self.generate(values[0])
-
-            else:
-
-                raise TypeError(
-                    "passing a filterable condition to a Fixed format indexer [%s]" % str(self))
-
-    def convert_value(self, v):
-        """ convert the expression that is in the term to something that is accepted by pytables """
-
-        def stringify(value):
-            value = str(value)
-            if self.encoding is not None:
-                value = value.encode(self.encoding)
-            return value
-
-        kind = _ensure_decoded(self.kind)
-        if kind == u('datetime64') or kind == u('datetime'):
-            v = lib.Timestamp(v)
-            if v.tz is not None:
-                v = v.tz_convert('UTC')
-            return TermValue(v, v.value, kind)
-        elif kind == u('timedelta64') or kind == u('timedelta'):
-            v = _coerce_scalar_to_timedelta_type(v,unit='s').item()
-            return TermValue(int(v), v, kind)
-        elif (isinstance(v, datetime) or hasattr(v, 'timetuple')):
-            v = time.mktime(v.timetuple())
-            return TermValue(v, Timestamp(v), kind)
-        elif kind == u('date'):
-            v = v.toordinal()
-            return TermValue(v, Timestamp.fromordinal(v), kind)
-        elif kind == u('integer'):
-            v = int(float(v))
-            return TermValue(v, v, kind)
-        elif kind == u('float'):
-            v = float(v)
-            return TermValue(v, v, kind)
-        elif kind == u('bool'):
-            if isinstance(v, compat.string_types):
-                poss_vals = [u('false'), u('f'), u('no'),
-                             u('n'), u('none'), u('0'),
-                             u('[]'), u('{}'), u('')]
-                v = not v.strip().lower() in poss_vals
-            else:
-                v = bool(v)
-            return TermValue(v, v, kind)
-        elif not isinstance(v, compat.string_types):
-            v = stringify(v)
-            return TermValue(v, stringify(v), u('string'))
-
-        # string quoting
-        return TermValue(v, stringify(v), u('string'))
-
-
-
-    def __len__(self):
-        return len(self.values)
-
-    def __getitem__(self, key):
-        """ return a new coordinates object, sliced by the key """
-        return Coordinates(self.values[key], self.group, self.where)
-
-
 class Selection(object):
 
     """

commit 69f4c70fd551a4d1bbdcf490109b999cc97e4ce5
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Feb 25 12:40:23 2020 -0800

    REF/TST: method-specific files for DataFrame timeseries methods (#32230)

diff --git a/pandas/tests/frame/conftest.py b/pandas/tests/frame/conftest.py
index 774eb443c..03598b6bb 100644
--- a/pandas/tests/frame/conftest.py
+++ b/pandas/tests/frame/conftest.py
@@ -1,3 +1,5 @@
+from itertools import product
+
 import numpy as np
 import pytest
 
@@ -5,6 +7,11 @@ from pandas import DataFrame, NaT, date_range
 import pandas._testing as tm
 
 
+@pytest.fixture(params=product([True, False], [True, False]))
+def close_open_fixture(request):
+    return request.param
+
+
 @pytest.fixture
 def float_frame_with_na():
     """
diff --git a/pandas/tests/frame/methods/test_asfreq.py b/pandas/tests/frame/methods/test_asfreq.py
new file mode 100644
index 000000000..40b0ec0c0
--- /dev/null
+++ b/pandas/tests/frame/methods/test_asfreq.py
@@ -0,0 +1,58 @@
+from datetime import datetime
+
+import numpy as np
+
+from pandas import DataFrame, DatetimeIndex, Series, date_range
+import pandas._testing as tm
+
+from pandas.tseries import offsets
+
+
+class TestAsFreq:
+    def test_asfreq(self, datetime_frame):
+        offset_monthly = datetime_frame.asfreq(offsets.BMonthEnd())
+        rule_monthly = datetime_frame.asfreq("BM")
+
+        tm.assert_almost_equal(offset_monthly["A"], rule_monthly["A"])
+
+        filled = rule_monthly.asfreq("B", method="pad")  # noqa
+        # TODO: actually check that this worked.
+
+        # don't forget!
+        filled_dep = rule_monthly.asfreq("B", method="pad")  # noqa
+
+        # test does not blow up on length-0 DataFrame
+        zero_length = datetime_frame.reindex([])
+        result = zero_length.asfreq("BM")
+        assert result is not zero_length
+
+    def test_asfreq_datetimeindex(self):
+        df = DataFrame(
+            {"A": [1, 2, 3]},
+            index=[datetime(2011, 11, 1), datetime(2011, 11, 2), datetime(2011, 11, 3)],
+        )
+        df = df.asfreq("B")
+        assert isinstance(df.index, DatetimeIndex)
+
+        ts = df["A"].asfreq("B")
+        assert isinstance(ts.index, DatetimeIndex)
+
+    def test_asfreq_fillvalue(self):
+        # test for fill value during upsampling, related to issue 3715
+
+        # setup
+        rng = date_range("1/1/2016", periods=10, freq="2S")
+        ts = Series(np.arange(len(rng)), index=rng)
+        df = DataFrame({"one": ts})
+
+        # insert pre-existing missing value
+        df.loc["2016-01-01 00:00:08", "one"] = None
+
+        actual_df = df.asfreq(freq="1S", fill_value=9.0)
+        expected_df = df.asfreq(freq="1S").fillna(9.0)
+        expected_df.loc["2016-01-01 00:00:08", "one"] = None
+        tm.assert_frame_equal(expected_df, actual_df)
+
+        expected_series = ts.asfreq(freq="1S").fillna(9.0)
+        actual_series = ts.asfreq(freq="1S", fill_value=9.0)
+        tm.assert_series_equal(expected_series, actual_series)
diff --git a/pandas/tests/frame/methods/test_at_time.py b/pandas/tests/frame/methods/test_at_time.py
new file mode 100644
index 000000000..108bbbfa1
--- /dev/null
+++ b/pandas/tests/frame/methods/test_at_time.py
@@ -0,0 +1,86 @@
+from datetime import time
+
+import numpy as np
+import pytest
+import pytz
+
+from pandas import DataFrame, date_range
+import pandas._testing as tm
+
+
+class TestAtTime:
+    def test_at_time(self):
+        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
+        ts = DataFrame(np.random.randn(len(rng), 2), index=rng)
+        rs = ts.at_time(rng[1])
+        assert (rs.index.hour == rng[1].hour).all()
+        assert (rs.index.minute == rng[1].minute).all()
+        assert (rs.index.second == rng[1].second).all()
+
+        result = ts.at_time("9:30")
+        expected = ts.at_time(time(9, 30))
+        tm.assert_frame_equal(result, expected)
+
+        result = ts.loc[time(9, 30)]
+        expected = ts.loc[(rng.hour == 9) & (rng.minute == 30)]
+
+        tm.assert_frame_equal(result, expected)
+
+        # midnight, everything
+        rng = date_range("1/1/2000", "1/31/2000")
+        ts = DataFrame(np.random.randn(len(rng), 3), index=rng)
+
+        result = ts.at_time(time(0, 0))
+        tm.assert_frame_equal(result, ts)
+
+        # time doesn't exist
+        rng = date_range("1/1/2012", freq="23Min", periods=384)
+        ts = DataFrame(np.random.randn(len(rng), 2), rng)
+        rs = ts.at_time("16:00")
+        assert len(rs) == 0
+
+    @pytest.mark.parametrize(
+        "hour", ["1:00", "1:00AM", time(1), time(1, tzinfo=pytz.UTC)]
+    )
+    def test_at_time_errors(self, hour):
+        # GH#24043
+        dti = date_range("2018", periods=3, freq="H")
+        df = DataFrame(list(range(len(dti))), index=dti)
+        if getattr(hour, "tzinfo", None) is None:
+            result = df.at_time(hour)
+            expected = df.iloc[1:2]
+            tm.assert_frame_equal(result, expected)
+        else:
+            with pytest.raises(ValueError, match="Index must be timezone"):
+                df.at_time(hour)
+
+    def test_at_time_tz(self):
+        # GH#24043
+        dti = date_range("2018", periods=3, freq="H", tz="US/Pacific")
+        df = DataFrame(list(range(len(dti))), index=dti)
+        result = df.at_time(time(4, tzinfo=pytz.timezone("US/Eastern")))
+        expected = df.iloc[1:2]
+        tm.assert_frame_equal(result, expected)
+
+    def test_at_time_raises(self):
+        # GH#20725
+        df = DataFrame([[1, 2, 3], [4, 5, 6]])
+        with pytest.raises(TypeError):  # index is not a DatetimeIndex
+            df.at_time("00:00")
+
+    @pytest.mark.parametrize("axis", ["index", "columns", 0, 1])
+    def test_at_time_axis(self, axis):
+        # issue 8839
+        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
+        ts = DataFrame(np.random.randn(len(rng), len(rng)))
+        ts.index, ts.columns = rng, rng
+
+        indices = rng[(rng.hour == 9) & (rng.minute == 30) & (rng.second == 0)]
+
+        if axis in ["index", 0]:
+            expected = ts.loc[indices, :]
+        elif axis in ["columns", 1]:
+            expected = ts.loc[:, indices]
+
+        result = ts.at_time("9:30", axis=axis)
+        tm.assert_frame_equal(result, expected)
diff --git a/pandas/tests/frame/methods/test_between_time.py b/pandas/tests/frame/methods/test_between_time.py
new file mode 100644
index 000000000..b40604b4f
--- /dev/null
+++ b/pandas/tests/frame/methods/test_between_time.py
@@ -0,0 +1,110 @@
+from datetime import time
+
+import numpy as np
+import pytest
+
+from pandas import DataFrame, date_range
+import pandas._testing as tm
+
+
+class TestBetweenTime:
+    def test_between_time(self, close_open_fixture):
+        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
+        ts = DataFrame(np.random.randn(len(rng), 2), index=rng)
+        stime = time(0, 0)
+        etime = time(1, 0)
+        inc_start, inc_end = close_open_fixture
+
+        filtered = ts.between_time(stime, etime, inc_start, inc_end)
+        exp_len = 13 * 4 + 1
+        if not inc_start:
+            exp_len -= 5
+        if not inc_end:
+            exp_len -= 4
+
+        assert len(filtered) == exp_len
+        for rs in filtered.index:
+            t = rs.time()
+            if inc_start:
+                assert t >= stime
+            else:
+                assert t > stime
+
+            if inc_end:
+                assert t <= etime
+            else:
+                assert t < etime
+
+        result = ts.between_time("00:00", "01:00")
+        expected = ts.between_time(stime, etime)
+        tm.assert_frame_equal(result, expected)
+
+        # across midnight
+        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
+        ts = DataFrame(np.random.randn(len(rng), 2), index=rng)
+        stime = time(22, 0)
+        etime = time(9, 0)
+
+        filtered = ts.between_time(stime, etime, inc_start, inc_end)
+        exp_len = (12 * 11 + 1) * 4 + 1
+        if not inc_start:
+            exp_len -= 4
+        if not inc_end:
+            exp_len -= 4
+
+        assert len(filtered) == exp_len
+        for rs in filtered.index:
+            t = rs.time()
+            if inc_start:
+                assert (t >= stime) or (t <= etime)
+            else:
+                assert (t > stime) or (t <= etime)
+
+            if inc_end:
+                assert (t <= etime) or (t >= stime)
+            else:
+                assert (t < etime) or (t >= stime)
+
+    def test_between_time_raises(self):
+        # GH#20725
+        df = DataFrame([[1, 2, 3], [4, 5, 6]])
+        with pytest.raises(TypeError):  # index is not a DatetimeIndex
+            df.between_time(start_time="00:00", end_time="12:00")
+
+    def test_between_time_axis(self, axis):
+        # GH#8839
+        rng = date_range("1/1/2000", periods=100, freq="10min")
+        ts = DataFrame(np.random.randn(len(rng), len(rng)))
+        stime, etime = ("08:00:00", "09:00:00")
+        exp_len = 7
+
+        if axis in ["index", 0]:
+            ts.index = rng
+            assert len(ts.between_time(stime, etime)) == exp_len
+            assert len(ts.between_time(stime, etime, axis=0)) == exp_len
+
+        if axis in ["columns", 1]:
+            ts.columns = rng
+            selected = ts.between_time(stime, etime, axis=1).columns
+            assert len(selected) == exp_len
+
+    def test_between_time_axis_raises(self, axis):
+        # issue 8839
+        rng = date_range("1/1/2000", periods=100, freq="10min")
+        mask = np.arange(0, len(rng))
+        rand_data = np.random.randn(len(rng), len(rng))
+        ts = DataFrame(rand_data, index=rng, columns=rng)
+        stime, etime = ("08:00:00", "09:00:00")
+
+        msg = "Index must be DatetimeIndex"
+        if axis in ["columns", 1]:
+            ts.index = mask
+            with pytest.raises(TypeError, match=msg):
+                ts.between_time(stime, etime)
+            with pytest.raises(TypeError, match=msg):
+                ts.between_time(stime, etime, axis=0)
+
+        if axis in ["index", 0]:
+            ts.columns = mask
+            with pytest.raises(TypeError, match=msg):
+                ts.between_time(stime, etime, axis=1)
diff --git a/pandas/tests/frame/methods/test_to_period.py b/pandas/tests/frame/methods/test_to_period.py
new file mode 100644
index 000000000..eac78e611
--- /dev/null
+++ b/pandas/tests/frame/methods/test_to_period.py
@@ -0,0 +1,36 @@
+import numpy as np
+import pytest
+
+from pandas import DataFrame, date_range, period_range
+import pandas._testing as tm
+
+
+class TestToPeriod:
+    def test_frame_to_period(self):
+        K = 5
+
+        dr = date_range("1/1/2000", "1/1/2001")
+        pr = period_range("1/1/2000", "1/1/2001")
+        df = DataFrame(np.random.randn(len(dr), K), index=dr)
+        df["mix"] = "a"
+
+        pts = df.to_period()
+        exp = df.copy()
+        exp.index = pr
+        tm.assert_frame_equal(pts, exp)
+
+        pts = df.to_period("M")
+        tm.assert_index_equal(pts.index, exp.index.asfreq("M"))
+
+        df = df.T
+        pts = df.to_period(axis=1)
+        exp = df.copy()
+        exp.columns = pr
+        tm.assert_frame_equal(pts, exp)
+
+        pts = df.to_period("M", axis=1)
+        tm.assert_index_equal(pts.columns, exp.columns.asfreq("M"))
+
+        msg = "No axis named 2 for object type <class 'pandas.core.frame.DataFrame'>"
+        with pytest.raises(ValueError, match=msg):
+            df.to_period(axis=2)
diff --git a/pandas/tests/frame/methods/test_tz_convert.py b/pandas/tests/frame/methods/test_tz_convert.py
new file mode 100644
index 000000000..ea8c4b885
--- /dev/null
+++ b/pandas/tests/frame/methods/test_tz_convert.py
@@ -0,0 +1,84 @@
+import numpy as np
+import pytest
+
+from pandas import DataFrame, Index, MultiIndex, date_range
+import pandas._testing as tm
+
+
+class TestTZConvert:
+    def test_frame_tz_convert(self):
+        rng = date_range("1/1/2011", periods=200, freq="D", tz="US/Eastern")
+
+        df = DataFrame({"a": 1}, index=rng)
+        result = df.tz_convert("Europe/Berlin")
+        expected = DataFrame({"a": 1}, rng.tz_convert("Europe/Berlin"))
+        assert result.index.tz.zone == "Europe/Berlin"
+        tm.assert_frame_equal(result, expected)
+
+        df = df.T
+        result = df.tz_convert("Europe/Berlin", axis=1)
+        assert result.columns.tz.zone == "Europe/Berlin"
+        tm.assert_frame_equal(result, expected.T)
+
+    @pytest.mark.parametrize("fn", ["tz_localize", "tz_convert"])
+    def test_tz_convert_and_localize(self, fn):
+        l0 = date_range("20140701", periods=5, freq="D")
+        l1 = date_range("20140701", periods=5, freq="D")
+
+        int_idx = Index(range(5))
+
+        if fn == "tz_convert":
+            l0 = l0.tz_localize("UTC")
+            l1 = l1.tz_localize("UTC")
+
+        for idx in [l0, l1]:
+
+            l0_expected = getattr(idx, fn)("US/Pacific")
+            l1_expected = getattr(idx, fn)("US/Pacific")
+
+            df1 = DataFrame(np.ones(5), index=l0)
+            df1 = getattr(df1, fn)("US/Pacific")
+            tm.assert_index_equal(df1.index, l0_expected)
+
+            # MultiIndex
+            # GH7846
+            df2 = DataFrame(np.ones(5), MultiIndex.from_arrays([l0, l1]))
+
+            df3 = getattr(df2, fn)("US/Pacific", level=0)
+            assert not df3.index.levels[0].equals(l0)
+            tm.assert_index_equal(df3.index.levels[0], l0_expected)
+            tm.assert_index_equal(df3.index.levels[1], l1)
+            assert not df3.index.levels[1].equals(l1_expected)
+
+            df3 = getattr(df2, fn)("US/Pacific", level=1)
+            tm.assert_index_equal(df3.index.levels[0], l0)
+            assert not df3.index.levels[0].equals(l0_expected)
+            tm.assert_index_equal(df3.index.levels[1], l1_expected)
+            assert not df3.index.levels[1].equals(l1)
+
+            df4 = DataFrame(np.ones(5), MultiIndex.from_arrays([int_idx, l0]))
+
+            # TODO: untested
+            df5 = getattr(df4, fn)("US/Pacific", level=1)  # noqa
+
+            tm.assert_index_equal(df3.index.levels[0], l0)
+            assert not df3.index.levels[0].equals(l0_expected)
+            tm.assert_index_equal(df3.index.levels[1], l1_expected)
+            assert not df3.index.levels[1].equals(l1)
+
+        # Bad Inputs
+
+        # Not DatetimeIndex / PeriodIndex
+        with pytest.raises(TypeError, match="DatetimeIndex"):
+            df = DataFrame(index=int_idx)
+            df = getattr(df, fn)("US/Pacific")
+
+        # Not DatetimeIndex / PeriodIndex
+        with pytest.raises(TypeError, match="DatetimeIndex"):
+            df = DataFrame(np.ones(5), MultiIndex.from_arrays([int_idx, l0]))
+            df = getattr(df, fn)("US/Pacific", level=0)
+
+        # Invalid level
+        with pytest.raises(ValueError, match="not valid"):
+            df = DataFrame(index=l0)
+            df = getattr(df, fn)("US/Pacific", level=1)
diff --git a/pandas/tests/frame/methods/test_tz_localize.py b/pandas/tests/frame/methods/test_tz_localize.py
new file mode 100644
index 000000000..1d4e26a69
--- /dev/null
+++ b/pandas/tests/frame/methods/test_tz_localize.py
@@ -0,0 +1,21 @@
+from pandas import DataFrame, date_range
+import pandas._testing as tm
+
+
+class TestTZLocalize:
+    # See also:
+    # test_tz_convert_and_localize in test_tz_convert
+
+    def test_frame_tz_localize(self):
+        rng = date_range("1/1/2011", periods=100, freq="H")
+
+        df = DataFrame({"a": 1}, index=rng)
+        result = df.tz_localize("utc")
+        expected = DataFrame({"a": 1}, rng.tz_localize("UTC"))
+        assert result.index.tz.zone == "UTC"
+        tm.assert_frame_equal(result, expected)
+
+        df = df.T
+        result = df.tz_localize("utc", axis=1)
+        assert result.columns.tz.zone == "UTC"
+        tm.assert_frame_equal(result, expected.T)
diff --git a/pandas/tests/frame/test_timeseries.py b/pandas/tests/frame/test_timeseries.py
index 5e06b6402..b713af92e 100644
--- a/pandas/tests/frame/test_timeseries.py
+++ b/pandas/tests/frame/test_timeseries.py
@@ -1,30 +1,10 @@
-from datetime import datetime, time
-from itertools import product
-
 import numpy as np
 import pytest
-import pytz
 
 import pandas as pd
-from pandas import (
-    DataFrame,
-    DatetimeIndex,
-    Index,
-    MultiIndex,
-    Series,
-    date_range,
-    period_range,
-    to_datetime,
-)
+from pandas import DataFrame, Series, date_range, to_datetime
 import pandas._testing as tm
 
-import pandas.tseries.offsets as offsets
-
-
-@pytest.fixture(params=product([True, False], [True, False]))
-def close_open_fixture(request):
-    return request.param
-
 
 class TestDataFrameTimeSeriesMethods:
     def test_frame_ctor_datetime64_column(self):
@@ -80,54 +60,6 @@ class TestDataFrameTimeSeriesMethods:
 
             assert (tmp["dates"].values == ex_vals).all()
 
-    def test_asfreq(self, datetime_frame):
-        offset_monthly = datetime_frame.asfreq(offsets.BMonthEnd())
-        rule_monthly = datetime_frame.asfreq("BM")
-
-        tm.assert_almost_equal(offset_monthly["A"], rule_monthly["A"])
-
-        filled = rule_monthly.asfreq("B", method="pad")  # noqa
-        # TODO: actually check that this worked.
-
-        # don't forget!
-        filled_dep = rule_monthly.asfreq("B", method="pad")  # noqa
-
-        # test does not blow up on length-0 DataFrame
-        zero_length = datetime_frame.reindex([])
-        result = zero_length.asfreq("BM")
-        assert result is not zero_length
-
-    def test_asfreq_datetimeindex(self):
-        df = DataFrame(
-            {"A": [1, 2, 3]},
-            index=[datetime(2011, 11, 1), datetime(2011, 11, 2), datetime(2011, 11, 3)],
-        )
-        df = df.asfreq("B")
-        assert isinstance(df.index, DatetimeIndex)
-
-        ts = df["A"].asfreq("B")
-        assert isinstance(ts.index, DatetimeIndex)
-
-    def test_asfreq_fillvalue(self):
-        # test for fill value during upsampling, related to issue 3715
-
-        # setup
-        rng = pd.date_range("1/1/2016", periods=10, freq="2S")
-        ts = pd.Series(np.arange(len(rng)), index=rng)
-        df = pd.DataFrame({"one": ts})
-
-        # insert pre-existing missing value
-        df.loc["2016-01-01 00:00:08", "one"] = None
-
-        actual_df = df.asfreq(freq="1S", fill_value=9.0)
-        expected_df = df.asfreq(freq="1S").fillna(9.0)
-        expected_df.loc["2016-01-01 00:00:08", "one"] = None
-        tm.assert_frame_equal(expected_df, actual_df)
-
-        expected_series = ts.asfreq(freq="1S").fillna(9.0)
-        actual_series = ts.asfreq(freq="1S", fill_value=9.0)
-        tm.assert_series_equal(expected_series, actual_series)
-
     @pytest.mark.parametrize(
         "data,idx,expected_first,expected_last",
         [
@@ -239,183 +171,6 @@ class TestDataFrameTimeSeriesMethods:
         with pytest.raises(TypeError):  # index is not a DatetimeIndex
             df.last("1D")
 
-    def test_at_time(self):
-        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
-        ts = DataFrame(np.random.randn(len(rng), 2), index=rng)
-        rs = ts.at_time(rng[1])
-        assert (rs.index.hour == rng[1].hour).all()
-        assert (rs.index.minute == rng[1].minute).all()
-        assert (rs.index.second == rng[1].second).all()
-
-        result = ts.at_time("9:30")
-        expected = ts.at_time(time(9, 30))
-        tm.assert_frame_equal(result, expected)
-
-        result = ts.loc[time(9, 30)]
-        expected = ts.loc[(rng.hour == 9) & (rng.minute == 30)]
-
-        tm.assert_frame_equal(result, expected)
-
-        # midnight, everything
-        rng = date_range("1/1/2000", "1/31/2000")
-        ts = DataFrame(np.random.randn(len(rng), 3), index=rng)
-
-        result = ts.at_time(time(0, 0))
-        tm.assert_frame_equal(result, ts)
-
-        # time doesn't exist
-        rng = date_range("1/1/2012", freq="23Min", periods=384)
-        ts = DataFrame(np.random.randn(len(rng), 2), rng)
-        rs = ts.at_time("16:00")
-        assert len(rs) == 0
-
-    @pytest.mark.parametrize(
-        "hour", ["1:00", "1:00AM", time(1), time(1, tzinfo=pytz.UTC)]
-    )
-    def test_at_time_errors(self, hour):
-        # GH 24043
-        dti = pd.date_range("2018", periods=3, freq="H")
-        df = pd.DataFrame(list(range(len(dti))), index=dti)
-        if getattr(hour, "tzinfo", None) is None:
-            result = df.at_time(hour)
-            expected = df.iloc[1:2]
-            tm.assert_frame_equal(result, expected)
-        else:
-            with pytest.raises(ValueError, match="Index must be timezone"):
-                df.at_time(hour)
-
-    def test_at_time_tz(self):
-        # GH 24043
-        dti = pd.date_range("2018", periods=3, freq="H", tz="US/Pacific")
-        df = pd.DataFrame(list(range(len(dti))), index=dti)
-        result = df.at_time(time(4, tzinfo=pytz.timezone("US/Eastern")))
-        expected = df.iloc[1:2]
-        tm.assert_frame_equal(result, expected)
-
-    def test_at_time_raises(self):
-        # GH20725
-        df = pd.DataFrame([[1, 2, 3], [4, 5, 6]])
-        with pytest.raises(TypeError):  # index is not a DatetimeIndex
-            df.at_time("00:00")
-
-    @pytest.mark.parametrize("axis", ["index", "columns", 0, 1])
-    def test_at_time_axis(self, axis):
-        # issue 8839
-        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
-        ts = DataFrame(np.random.randn(len(rng), len(rng)))
-        ts.index, ts.columns = rng, rng
-
-        indices = rng[(rng.hour == 9) & (rng.minute == 30) & (rng.second == 0)]
-
-        if axis in ["index", 0]:
-            expected = ts.loc[indices, :]
-        elif axis in ["columns", 1]:
-            expected = ts.loc[:, indices]
-
-        result = ts.at_time("9:30", axis=axis)
-        tm.assert_frame_equal(result, expected)
-
-    def test_between_time(self, close_open_fixture):
-        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
-        ts = DataFrame(np.random.randn(len(rng), 2), index=rng)
-        stime = time(0, 0)
-        etime = time(1, 0)
-        inc_start, inc_end = close_open_fixture
-
-        filtered = ts.between_time(stime, etime, inc_start, inc_end)
-        exp_len = 13 * 4 + 1
-        if not inc_start:
-            exp_len -= 5
-        if not inc_end:
-            exp_len -= 4
-
-        assert len(filtered) == exp_len
-        for rs in filtered.index:
-            t = rs.time()
-            if inc_start:
-                assert t >= stime
-            else:
-                assert t > stime
-
-            if inc_end:
-                assert t <= etime
-            else:
-                assert t < etime
-
-        result = ts.between_time("00:00", "01:00")
-        expected = ts.between_time(stime, etime)
-        tm.assert_frame_equal(result, expected)
-
-        # across midnight
-        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
-        ts = DataFrame(np.random.randn(len(rng), 2), index=rng)
-        stime = time(22, 0)
-        etime = time(9, 0)
-
-        filtered = ts.between_time(stime, etime, inc_start, inc_end)
-        exp_len = (12 * 11 + 1) * 4 + 1
-        if not inc_start:
-            exp_len -= 4
-        if not inc_end:
-            exp_len -= 4
-
-        assert len(filtered) == exp_len
-        for rs in filtered.index:
-            t = rs.time()
-            if inc_start:
-                assert (t >= stime) or (t <= etime)
-            else:
-                assert (t > stime) or (t <= etime)
-
-            if inc_end:
-                assert (t <= etime) or (t >= stime)
-            else:
-                assert (t < etime) or (t >= stime)
-
-    def test_between_time_raises(self):
-        # GH20725
-        df = pd.DataFrame([[1, 2, 3], [4, 5, 6]])
-        with pytest.raises(TypeError):  # index is not a DatetimeIndex
-            df.between_time(start_time="00:00", end_time="12:00")
-
-    def test_between_time_axis(self, axis):
-        # issue 8839
-        rng = date_range("1/1/2000", periods=100, freq="10min")
-        ts = DataFrame(np.random.randn(len(rng), len(rng)))
-        stime, etime = ("08:00:00", "09:00:00")
-        exp_len = 7
-
-        if axis in ["index", 0]:
-            ts.index = rng
-            assert len(ts.between_time(stime, etime)) == exp_len
-            assert len(ts.between_time(stime, etime, axis=0)) == exp_len
-
-        if axis in ["columns", 1]:
-            ts.columns = rng
-            selected = ts.between_time(stime, etime, axis=1).columns
-            assert len(selected) == exp_len
-
-    def test_between_time_axis_raises(self, axis):
-        # issue 8839
-        rng = date_range("1/1/2000", periods=100, freq="10min")
-        mask = np.arange(0, len(rng))
-        rand_data = np.random.randn(len(rng), len(rng))
-        ts = DataFrame(rand_data, index=rng, columns=rng)
-        stime, etime = ("08:00:00", "09:00:00")
-
-        msg = "Index must be DatetimeIndex"
-        if axis in ["columns", 1]:
-            ts.index = mask
-            with pytest.raises(TypeError, match=msg):
-                ts.between_time(stime, etime)
-            with pytest.raises(TypeError, match=msg):
-                ts.between_time(stime, etime, axis=0)
-
-        if axis in ["index", 0]:
-            ts.columns = mask
-            with pytest.raises(TypeError, match=msg):
-                ts.between_time(stime, etime, axis=1)
-
     def test_operation_on_NaT(self):
         # Both NaT and Timestamp are in DataFrame.
         df = pd.DataFrame({"foo": [pd.NaT, pd.NaT, pd.Timestamp("2012-05-01")]})
@@ -455,95 +210,3 @@ class TestDataFrameTimeSeriesMethods:
             {0: [1, None], "new": [1e9, None]}, dtype="datetime64[ns]"
         )
         tm.assert_frame_equal(result, expected)
-
-    def test_frame_to_period(self):
-        K = 5
-
-        dr = date_range("1/1/2000", "1/1/2001")
-        pr = period_range("1/1/2000", "1/1/2001")
-        df = DataFrame(np.random.randn(len(dr), K), index=dr)
-        df["mix"] = "a"
-
-        pts = df.to_period()
-        exp = df.copy()
-        exp.index = pr
-        tm.assert_frame_equal(pts, exp)
-
-        pts = df.to_period("M")
-        tm.assert_index_equal(pts.index, exp.index.asfreq("M"))
-
-        df = df.T
-        pts = df.to_period(axis=1)
-        exp = df.copy()
-        exp.columns = pr
-        tm.assert_frame_equal(pts, exp)
-
-        pts = df.to_period("M", axis=1)
-        tm.assert_index_equal(pts.columns, exp.columns.asfreq("M"))
-
-        msg = "No axis named 2 for object type <class 'pandas.core.frame.DataFrame'>"
-        with pytest.raises(ValueError, match=msg):
-            df.to_period(axis=2)
-
-    @pytest.mark.parametrize("fn", ["tz_localize", "tz_convert"])
-    def test_tz_convert_and_localize(self, fn):
-        l0 = date_range("20140701", periods=5, freq="D")
-        l1 = date_range("20140701", periods=5, freq="D")
-
-        int_idx = Index(range(5))
-
-        if fn == "tz_convert":
-            l0 = l0.tz_localize("UTC")
-            l1 = l1.tz_localize("UTC")
-
-        for idx in [l0, l1]:
-
-            l0_expected = getattr(idx, fn)("US/Pacific")
-            l1_expected = getattr(idx, fn)("US/Pacific")
-
-            df1 = DataFrame(np.ones(5), index=l0)
-            df1 = getattr(df1, fn)("US/Pacific")
-            tm.assert_index_equal(df1.index, l0_expected)
-
-            # MultiIndex
-            # GH7846
-            df2 = DataFrame(np.ones(5), MultiIndex.from_arrays([l0, l1]))
-
-            df3 = getattr(df2, fn)("US/Pacific", level=0)
-            assert not df3.index.levels[0].equals(l0)
-            tm.assert_index_equal(df3.index.levels[0], l0_expected)
-            tm.assert_index_equal(df3.index.levels[1], l1)
-            assert not df3.index.levels[1].equals(l1_expected)
-
-            df3 = getattr(df2, fn)("US/Pacific", level=1)
-            tm.assert_index_equal(df3.index.levels[0], l0)
-            assert not df3.index.levels[0].equals(l0_expected)
-            tm.assert_index_equal(df3.index.levels[1], l1_expected)
-            assert not df3.index.levels[1].equals(l1)
-
-            df4 = DataFrame(np.ones(5), MultiIndex.from_arrays([int_idx, l0]))
-
-            # TODO: untested
-            df5 = getattr(df4, fn)("US/Pacific", level=1)  # noqa
-
-            tm.assert_index_equal(df3.index.levels[0], l0)
-            assert not df3.index.levels[0].equals(l0_expected)
-            tm.assert_index_equal(df3.index.levels[1], l1_expected)
-            assert not df3.index.levels[1].equals(l1)
-
-        # Bad Inputs
-
-        # Not DatetimeIndex / PeriodIndex
-        with pytest.raises(TypeError, match="DatetimeIndex"):
-            df = DataFrame(index=int_idx)
-            df = getattr(df, fn)("US/Pacific")
-
-        # Not DatetimeIndex / PeriodIndex
-        with pytest.raises(TypeError, match="DatetimeIndex"):
-            df = DataFrame(np.ones(5), MultiIndex.from_arrays([int_idx, l0]))
-            df = getattr(df, fn)("US/Pacific", level=0)
-
-        # Invalid level
-        with pytest.raises(ValueError, match="not valid"):
-            df = DataFrame(index=l0)
-            df = getattr(df, fn)("US/Pacific", level=1)
diff --git a/pandas/tests/frame/test_timezones.py b/pandas/tests/frame/test_timezones.py
index b60f2052a..62e8a4b47 100644
--- a/pandas/tests/frame/test_timezones.py
+++ b/pandas/tests/frame/test_timezones.py
@@ -59,34 +59,6 @@ class TestDataFrameTimezones:
         # it works
         DataFrame.from_records([rec], index="begin_time")
 
-    def test_frame_tz_localize(self):
-        rng = date_range("1/1/2011", periods=100, freq="H")
-
-        df = DataFrame({"a": 1}, index=rng)
-        result = df.tz_localize("utc")
-        expected = DataFrame({"a": 1}, rng.tz_localize("UTC"))
-        assert result.index.tz.zone == "UTC"
-        tm.assert_frame_equal(result, expected)
-
-        df = df.T
-        result = df.tz_localize("utc", axis=1)
-        assert result.columns.tz.zone == "UTC"
-        tm.assert_frame_equal(result, expected.T)
-
-    def test_frame_tz_convert(self):
-        rng = date_range("1/1/2011", periods=200, freq="D", tz="US/Eastern")
-
-        df = DataFrame({"a": 1}, index=rng)
-        result = df.tz_convert("Europe/Berlin")
-        expected = DataFrame({"a": 1}, rng.tz_convert("Europe/Berlin"))
-        assert result.index.tz.zone == "Europe/Berlin"
-        tm.assert_frame_equal(result, expected)
-
-        df = df.T
-        result = df.tz_convert("Europe/Berlin", axis=1)
-        assert result.columns.tz.zone == "Europe/Berlin"
-        tm.assert_frame_equal(result, expected.T)
-
     def test_frame_join_tzaware(self):
         test1 = DataFrame(
             np.zeros((6, 3)),

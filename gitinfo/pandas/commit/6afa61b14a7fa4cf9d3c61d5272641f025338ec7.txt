commit 6afa61b14a7fa4cf9d3c61d5272641f025338ec7
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Jun 2 14:45:19 2012 -0400

    BUG: cast other datetime64 units to nanoseconds for storage in DataFrame BlockManager, close #1379

diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index edf72d837..6538b5670 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -380,9 +380,19 @@ class ObjectBlock(Block):
                               (np.integer, np.floating, np.complexfloating,
                                np.bool_))
 
+_NS_DTYPE = np.dtype('M8[ns]')
+
 class DatetimeBlock(Block):
     _can_hold_na = True
 
+    def __init__(self, values, items, ref_items, ndim=2,
+                 do_integrity_check=False):
+        if values.dtype != _NS_DTYPE:
+            values = lib.cast_to_nanoseconds(values)
+
+        Block.__init__(self, values, items, ref_items, ndim=ndim,
+                       do_integrity_check=do_integrity_check)
+
     def _can_hold_element(self, element):
         return com.is_integer(element) or isinstance(element, datetime)
 
@@ -395,6 +405,21 @@ class DatetimeBlock(Block):
     def should_store(self, value):
         return issubclass(value.dtype.type, np.datetime64)
 
+    def set(self, item, value):
+        """
+        Modify Block in-place with new item value
+
+        Returns
+        -------
+        None
+        """
+        loc = self.items.get_loc(item)
+
+        if value.dtype != _NS_DTYPE:
+            value = lib.cast_to_nanoseconds(value)
+
+        self.values[loc] = value
+
     def get_values(self, dtype):
         if dtype == object:
             flat_i8 = self.values.ravel().view(np.int64)
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 3577680d1..e920b5430 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -926,10 +926,10 @@ cdef inline _get_datetime64_nanos(object val):
 
     unit = get_datetime64_unit(val)
     if numpy_16:
-        if unit == 4:
+        if unit == 3:
             raise ValueError('NumPy 1.6.1 business freq not supported')
 
-        if unit > 4:
+        if unit > 3:
             unit = <PANDAS_DATETIMEUNIT> ((<int>unit) - 1)
 
     ival = get_datetime64_value(val)
@@ -940,6 +940,35 @@ cdef inline _get_datetime64_nanos(object val):
     else:
         return ival
 
+
+def cast_to_nanoseconds(ndarray arr):
+    cdef:
+        Py_ssize_t i, n = arr.size
+        ndarray[int64_t] ivalues, iresult
+        PANDAS_DATETIMEUNIT unit
+        pandas_datetimestruct dts
+
+    shape = (<object> arr).shape
+
+    ivalues = arr.view(np.int64).ravel()
+
+    result = np.empty(shape, dtype='M8[ns]')
+    iresult = result.ravel().view(np.int64)
+
+    unit = get_datetime64_unit(arr.flat[0])
+    if numpy_16:
+        if unit == 3:
+            raise ValueError('NumPy 1.6.1 business freq not supported')
+
+        if unit > 3:
+            unit = <PANDAS_DATETIMEUNIT> ((<int>unit) - 1)
+
+    for i in range(n):
+        pandas_datetime_to_datetimestruct(ivalues[i], unit, &dts)
+        iresult[i] = pandas_datetimestruct_to_datetime(PANDAS_FR_ns, &dts)
+
+    return result
+
 #----------------------------------------------------------------------
 # Conversion routines
 
diff --git a/pandas/tools/tile.py b/pandas/tools/tile.py
index afa143229..96f9c7417 100644
--- a/pandas/tools/tile.py
+++ b/pandas/tools/tile.py
@@ -8,6 +8,7 @@ import pandas.core.nanops as nanops
 
 import numpy as np
 
+
 def cut(x, bins, right=True, labels=None, retbins=False, precision=3):
     """
     Return indices of half-open bins to which each value of `x` belongs.
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 9a0d6e649..433d350fa 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -321,6 +321,41 @@ class TestTimeSeries(unittest.TestCase):
         df['A'] = rng
         self.assert_(np.issubdtype(df['A'].dtype, np.dtype('M8[ns]')))
 
+    def test_frame_add_datetime64_col_other_units(self):
+        n = 100
+
+        units = ['h', 'm', 's', 'ms', 'D', 'M', 'Y']
+
+        ns_dtype = np.dtype('M8[ns]')
+
+        for unit in units:
+            dtype = np.dtype('M8[%s]' % unit)
+            vals = np.arange(n, dtype=dtype)
+
+            df = DataFrame({'ints' : np.arange(n)}, index=np.arange(n))
+            df[unit] = vals
+
+            ex_vals = to_datetime(vals.astype('O'))
+
+            self.assert_(df[unit].dtype == ns_dtype)
+            self.assert_((df[unit].values == ex_vals).all())
+
+        # Test insertion into existing datetime64 column
+        df = DataFrame({'ints' : np.arange(n)}, index=np.arange(n))
+        df['dates'] = np.arange(n, dtype=ns_dtype)
+
+        for unit in units:
+            dtype = np.dtype('M8[%s]' % unit)
+            vals = np.arange(n, dtype=dtype)
+
+            tmp = df.copy()
+
+            tmp['dates'] = vals
+            ex_vals = to_datetime(vals.astype('O'))
+
+            self.assert_((tmp['dates'].values == ex_vals).all())
+
+
     def test_series_ctor_datetime64(self):
         rng = date_range('1/1/2000 00:00:00', '1/1/2000 1:59:50',
                          freq='10s')

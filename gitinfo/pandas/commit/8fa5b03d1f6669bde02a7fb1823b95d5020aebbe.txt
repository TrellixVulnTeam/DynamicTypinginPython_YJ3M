commit 8fa5b03d1f6669bde02a7fb1823b95d5020aebbe
Author: jreback <jeff@reback.net>
Date:   Sat Sep 28 20:50:45 2013 -0400

    CLN: refactor all numeric type stats methods to core/generic.py
         from the object level modules (e.g. mean/sum/min/max....)

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 39dc5d192..fe3fb726d 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -348,6 +348,8 @@ See :ref:`Internal Refactoring<whatsnew_0130.refactoring>`
   etc.) into a separate, cleaned up wrapper class. (:issue:`4613`)
 - Complex compat for ``Series`` with ``ndarray``. (:issue:`4819`)
 - Removed unnecessary ``rwproperty`` from codebase in favor of builtin property. (:issue:`4843`)
+- Refactor object level numeric methods (mean/sum/min/max...) from object level modules to
+  ``core/generic.py``(:issue:`4435`)
 
 .. _release.bug_fixes-0.13.0:
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 44bb1ce19..935dff44a 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -63,28 +63,6 @@ from pandas.core.config import get_option
 # Docstring templates
 
 
-_stat_doc = """
-Return %(name)s over requested axis.
-%(na_action)s
-
-Parameters
-----------
-axis : {0, 1}
-    0 for row-wise, 1 for column-wise
-skipna : boolean, default True
-    Exclude NA/null values. If an entire row/column is NA, the result
-    will be NA
-level : int, default None
-    If the axis is a MultiIndex (hierarchical), count along a
-    particular level, collapsing into a DataFrame
-%(extras)s
-Returns
--------
-%(shortname)s : Series (or DataFrame if level specified)
-"""
-
-_doc_exclude_na = "NA/null values are excluded"
-
 _numeric_only_doc = """numeric_only : boolean, default None
     Include only float, int, boolean data. If None, will attempt to use
     everything, then use only numeric data
@@ -3929,185 +3907,6 @@ class DataFrame(NDFrame):
         return self._reduce(nanops.nanall, axis=axis, skipna=skipna,
                             numeric_only=bool_only, filter_type='bool')
 
-    @Substitution(name='sum', shortname='sum', na_action=_doc_exclude_na,
-                  extras=_numeric_only_doc)
-    @Appender(_stat_doc)
-    def sum(self, axis=None, numeric_only=None, skipna=True, level=None, **kwargs):
-        if axis is None:
-            axis = self._stat_axis_number
-        if level is not None:
-            return self._agg_by_level('sum', axis=axis, level=level,
-                                      skipna=skipna)
-        return self._reduce(nanops.nansum, axis=axis, skipna=skipna,
-                            numeric_only=numeric_only)
-
-    @Substitution(name='mean', shortname='mean', na_action=_doc_exclude_na,
-                  extras='')
-    @Appender(_stat_doc)
-    def mean(self, axis=None, skipna=True, level=None, **kwargs):
-        if axis is None:
-            axis = self._stat_axis_number
-        if level is not None:
-            return self._agg_by_level('mean', axis=axis, level=level,
-                                      skipna=skipna)
-        return self._reduce(nanops.nanmean, axis=axis, skipna=skipna,
-                            numeric_only=None)
-
-    @Substitution(name='minimum', shortname='min', na_action=_doc_exclude_na,
-                  extras='')
-    @Appender(_stat_doc)
-    def min(self, axis=None, skipna=True, level=None, **kwargs):
-        """
-        Notes
-        -----
-        This method returns the minimum of the values in the DataFrame. If you
-        want the *index* of the minimum, use ``DataFrame.idxmin``. This is the
-        equivalent of the ``numpy.ndarray`` method ``argmin``.
-
-        See Also
-        --------
-        DataFrame.idxmin
-        Series.idxmin
-        """
-        if axis is None:
-            axis = self._stat_axis_number
-        if level is not None:
-            return self._agg_by_level('min', axis=axis, level=level,
-                                      skipna=skipna)
-        return self._reduce(nanops.nanmin, axis=axis, skipna=skipna,
-                            numeric_only=None)
-
-    @Substitution(name='maximum', shortname='max', na_action=_doc_exclude_na,
-                  extras='')
-    @Appender(_stat_doc)
-    def max(self, axis=None, skipna=True, level=None, **kwargs):
-        """
-        Notes
-        -----
-        This method returns the maximum of the values in the DataFrame. If you
-        want the *index* of the maximum, use ``DataFrame.idxmax``. This is the
-        equivalent of the ``numpy.ndarray`` method ``argmax``.
-
-        See Also
-        --------
-        DataFrame.idxmax
-        Series.idxmax
-        """
-        if axis is None:
-            axis = self._stat_axis_number
-        if level is not None:
-            return self._agg_by_level('max', axis=axis, level=level,
-                                      skipna=skipna)
-        return self._reduce(nanops.nanmax, axis=axis, skipna=skipna,
-                            numeric_only=None)
-
-    @Substitution(name='product', shortname='product',
-                  na_action='NA/null values are treated as 1', extras='')
-    @Appender(_stat_doc)
-    def prod(self, axis=None, skipna=True, level=None, **kwargs):
-        if axis is None:
-            axis = self._stat_axis_number
-        if level is not None:
-            return self._agg_by_level('prod', axis=axis, level=level,
-                                      skipna=skipna)
-        return self._reduce(nanops.nanprod, axis=axis, skipna=skipna,
-                            numeric_only=None)
-
-    product = prod
-
-    @Substitution(name='median', shortname='median', na_action=_doc_exclude_na,
-                  extras='')
-    @Appender(_stat_doc)
-    def median(self, axis=None, skipna=True, level=None, **kwargs):
-        if axis is None:
-            axis = self._stat_axis_number
-        if level is not None:
-            return self._agg_by_level('median', axis=axis, level=level,
-                                      skipna=skipna)
-        return self._reduce(nanops.nanmedian, axis=axis, skipna=skipna,
-                            numeric_only=None)
-
-    @Substitution(name='mean absolute deviation', shortname='mad',
-                  na_action=_doc_exclude_na, extras='')
-    @Appender(_stat_doc)
-    def mad(self, axis=None, skipna=True, level=None, **kwargs):
-        if axis is None:
-            axis = self._stat_axis_number
-        if level is not None:
-            return self._agg_by_level('mad', axis=axis, level=level,
-                                      skipna=skipna)
-
-        frame = self._get_numeric_data()
-
-        axis = self._get_axis_number(axis)
-        if axis == 0:
-            demeaned = frame - frame.mean(axis=0)
-        else:
-            demeaned = frame.sub(frame.mean(axis=1), axis=0)
-        return np.abs(demeaned).mean(axis=axis, skipna=skipna)
-
-    @Substitution(name='variance', shortname='var',
-                  na_action=_doc_exclude_na, extras='')
-    @Appender(_stat_doc +
-              """
-        Normalized by N-1 (unbiased estimator).
-        """)
-    def var(self, axis=None, skipna=True, level=None, ddof=1, **kwargs):
-        if axis is None:
-            axis = self._stat_axis_number
-        if level is not None:
-            return self._agg_by_level('var', axis=axis, level=level,
-                                      skipna=skipna, ddof=ddof)
-        return self._reduce(nanops.nanvar, axis=axis, skipna=skipna,
-                            numeric_only=None, ddof=ddof)
-
-    @Substitution(name='standard deviation', shortname='std',
-                  na_action=_doc_exclude_na, extras='')
-    @Appender(_stat_doc +
-              """
-        Normalized by N-1 (unbiased estimator).
-        """)
-    def std(self, axis=None, skipna=True, level=None, ddof=1, **kwargs):
-        if axis is None:
-            axis = self._stat_axis_number
-        if level is not None:
-            return self._agg_by_level('std', axis=axis, level=level,
-                                      skipna=skipna, ddof=ddof)
-        return np.sqrt(self.var(axis=axis, skipna=skipna, ddof=ddof))
-
-    @Substitution(name='unbiased skewness', shortname='skew',
-                  na_action=_doc_exclude_na, extras='')
-    @Appender(_stat_doc)
-    def skew(self, axis=None, skipna=True, level=None, **kwargs):
-        if axis is None:
-            axis = self._stat_axis_number
-        if level is not None:
-            return self._agg_by_level('skew', axis=axis, level=level,
-                                      skipna=skipna)
-        return self._reduce(nanops.nanskew, axis=axis, skipna=skipna,
-                            numeric_only=None)
-
-    @Substitution(name='unbiased kurtosis', shortname='kurt',
-                  na_action=_doc_exclude_na, extras='')
-    @Appender(_stat_doc)
-    def kurt(self, axis=None, skipna=True, level=None, **kwargs):
-        if axis is None:
-            axis = self._stat_axis_number
-        if level is not None:
-            return self._agg_by_level('kurt', axis=axis, level=level,
-                                      skipna=skipna)
-        return self._reduce(nanops.nankurt, axis=axis, skipna=skipna,
-                            numeric_only=None)
-
-    def _agg_by_level(self, name, axis=0, level=0, skipna=True, **kwds):
-        grouped = self.groupby(level=level, axis=axis)
-        if hasattr(grouped, name) and skipna:
-            return getattr(grouped, name)(**kwds)
-        axis = self._get_axis_number(axis)
-        method = getattr(type(self), name)
-        applyf = lambda x: method(x, axis=axis, skipna=skipna, **kwds)
-        return grouped.aggregate(applyf)
-
     def _reduce(self, op, axis=0, skipna=True, numeric_only=None,
                 filter_type=None, **kwds):
         axis = self._get_axis_number(axis)
@@ -4466,7 +4265,7 @@ class DataFrame(NDFrame):
 
 DataFrame._setup_axes(
     ['index', 'columns'], info_axis=1, stat_axis=0, axes_are_reversed=True)
-
+DataFrame._add_numeric_operations()
 
 _EMPTY_SERIES = Series([])
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 060873e72..6c7165abe 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -21,6 +21,8 @@ from pandas.core.common import (isnull, notnull, is_list_like,
                                 _values_from_object,
                                 _infer_dtype_from_scalar, _maybe_promote,
                                 ABCSeries)
+import pandas.core.nanops as nanops
+from pandas.util.decorators import Appender, Substitution
 
 def is_dictlike(x):
     return isinstance(x, (dict, com.ABCSeries))
@@ -2731,7 +2733,6 @@ class NDFrame(PandasObject):
 
     #----------------------------------------------------------------------
     # Numeric Methods
-
     def abs(self):
         """
         Return an object with absolute value taken. Only applicable to objects
@@ -2789,6 +2790,217 @@ class NDFrame(PandasObject):
             np.putmask(rs.values, mask, np.nan)
         return rs
 
+    def _agg_by_level(self, name, axis=0, level=0, skipna=True, **kwds):
+        grouped = self.groupby(level=level, axis=axis)
+        if hasattr(grouped, name) and skipna:
+            return getattr(grouped, name)(**kwds)
+        axis = self._get_axis_number(axis)
+        method = getattr(type(self), name)
+        applyf = lambda x: method(x, axis=axis, skipna=skipna, **kwds)
+        return grouped.aggregate(applyf)
+
+    @classmethod
+    def _add_numeric_operations(cls):
+        """ add the operations to the cls; evaluate the doc strings again """
+
+        axis_descr = "{" + ', '.join([ "{0} ({1})".format(a,i) for i, a in enumerate(cls._AXIS_ORDERS)]) + "}"
+        name = cls._constructor_sliced.__name__ if cls._AXIS_LEN > 1 else 'scalar'
+        _num_doc = """
+
+Parameters
+----------
+axis : """ + axis_descr + """
+skipna : boolean, default True
+    Exclude NA/null values. If an entire row/column is NA, the result
+    will be NA
+level : int, default None
+        If the axis is a MultiIndex (hierarchical), count along a
+        particular level, collapsing into a """ + name + """
+
+Returns
+-------
+%(outname)s : """ + name + "\n"
+
+        @Substitution(outname='sum')
+        @Appender(_num_doc)
+        def sum(self, axis=None, skipna=True, level=None, numeric_only=None,
+                **kwargs):
+            """ Return sum over requested axis """
+
+            if axis is None:
+                axis = self._stat_axis_number
+            if level is not None:
+                return self._agg_by_level('sum', axis=axis, level=level,
+                                          skipna=skipna)
+            return self._reduce(nanops.nansum, axis=axis,
+                                skipna=skipna, numeric_only=numeric_only)
+        cls.sum = sum
+
+        @Substitution(outname='mad')
+        @Appender(_num_doc)
+        def mad(self,  axis=None, skipna=True, level=None, **kwargs):
+            """ Return the mean absolute deviation of the values for the requested axis """
+            if axis is None:
+                axis = self._stat_axis_number
+            if level is not None:
+                return self._agg_by_level('mad', axis=axis, level=level,
+                                          skipna=skipna)
+
+            data = self._get_numeric_data()
+            if axis == 0:
+                demeaned = data - data.mean(axis=0)
+            else:
+                demeaned = data.sub(data.mean(axis=1), axis=0)
+            return np.abs(demeaned).mean(axis=axis, skipna=skipna)
+        cls.mad = mad
+
+        @Substitution(outname='mean')
+        @Appender(_num_doc)
+        def mean(self, axis=None, skipna=True, level=None, numeric_only=None, **kwargs):
+            """ Return mean over requested axis """
+
+            if axis is None:
+                axis = self._stat_axis_number
+            if level is not None:
+                return self._agg_by_level('mean', axis=axis, level=level,
+                                          skipna=skipna)
+            return self._reduce(nanops.nanmean, axis=axis,
+                                skipna=skipna, numeric_only=numeric_only)
+        cls.mean = mean
+
+        @Substitution(outname='variance')
+        @Appender(_num_doc)
+        def var(self, axis=None, skipna=True, level=None, ddof=1, **kwargs):
+            """
+            Return unbiased variance over requested axis
+            Normalized by N-1 (unbiased estimator).
+            """
+            if axis is None:
+                axis = self._stat_axis_number
+            if level is not None:
+                return self._agg_by_level('var', axis=axis, level=level,
+                                          skipna=skipna, ddof=ddof)
+
+            return self._reduce(nanops.nanvar, axis=axis, skipna=skipna, ddof=ddof)
+        cls.var = var
+
+        @Substitution(outname='stdev')
+        @Appender(_num_doc)
+        def std(self, axis=None, skipna=True, level=None, ddof=1, **kwargs):
+            """
+            Return unbiased standard deviation over requested axis
+            Normalized by N-1 (unbiased estimator).
+            """
+            if axis is None:
+                axis = self._stat_axis_number
+            if level is not None:
+                return self._agg_by_level('std', axis=axis, level=level,
+                                          skipna=skipna, ddof=ddof)
+            result = self.var(axis=axis, skipna=skipna, ddof=ddof)
+            if getattr(result,'ndim',0) > 0:
+                return result.apply(np.sqrt)
+            return np.sqrt(result)
+        cls.std = std
+
+        @Substitution(outname='skew')
+        @Appender(_num_doc)
+        def skew(self, axis=None, skipna=True, level=None, **wwargs):
+            """
+            Return unbiased standard skewness over requested axis
+            Normalized by N-1 (unbiased estimator).
+            """
+            if axis is None:
+                axis = self._stat_axis_number
+            if level is not None:
+                return self._agg_by_level('skew', axis=axis, level=level,
+                                          skipna=skipna)
+            return self._reduce(nanops.nanskew, axis=axis, skipna=skipna)
+        cls.skew = skew
+
+        @Substitution(outname='kurt')
+        @Appender(_num_doc)
+        def kurt(self, axis=None, skipna=True, level=None, **kwargs):
+            """
+            Return unbiased standard kurtosis over requested axis
+            Normalized by N-1 (unbiased estimator).
+            """
+            if axis is None:
+                axis = self._stat_axis_number
+            if level is not None:
+                return self._agg_by_level('kurt', axis=axis, level=level,
+                                          skipna=skipna)
+            return self._reduce(nanops.nankurt, axis=axis, skipna=skipna,
+                                numeric_only=None)
+        cls.kurt = kurt
+
+        @Substitution(outname='prod')
+        @Appender(_num_doc)
+        def prod(self, axis=None, skipna=True, level=None, **kwargs):
+            """
+            Return product of the values over requested axis
+            """
+            if axis is None:
+                axis = self._stat_axis_number
+            if level is not None:
+                return self._agg_by_level('prod', axis=axis, level=level,
+                                          skipna=skipna)
+            return self._reduce(nanops.nanprod, axis=axis, skipna=skipna)
+        cls.prod = prod
+        cls.product = prod
+
+        @Substitution(outname='compounded')
+        @Appender(_num_doc)
+        def compound(self, axis=None, skipna=True, level=None, **kwargs):
+            """ return the compound percentage of the values for the requested axis """
+            return (1 + self).prod(axis=axis, skipna=skipna, level=level) - 1
+        cls.compound = compound
+
+        @Substitution(outname='median')
+        @Appender(_num_doc)
+        def median(self, axis=None, skipna=True, level=None, **kwargs):
+            """
+            Return median of the values over requested axis
+            """
+            if axis is None:
+                axis = self._stat_axis_number
+            if level is not None:
+                return self._agg_by_level('median', axis=axis, level=level,
+                                          skipna=skipna)
+            return self._reduce(nanops.nanmedian, axis=axis, skipna=skipna)
+        cls.median = median
+
+        @Substitution(outname='maximum')
+        @Appender(_num_doc)
+        def max(self, axis=None, skipna=True, level=None, **kwargs):
+            """
+            This method returns the maximum of the values in the objec. If you
+            want the *index* of the maximum, use ``idxmax``. This is the
+            equivalent of the ``numpy.ndarray`` method ``argmax``.
+            """
+            if axis is None:
+                axis = self._stat_axis_number
+            if level is not None:
+                return self._agg_by_level('max', axis=axis, level=level,
+                                          skipna=skipna)
+            return self._reduce(nanops.nanmax, axis=axis, skipna=skipna)
+        cls.max = max
+
+        @Substitution(outname='minimum')
+        @Appender(_num_doc)
+        def min(self, axis=None, skipna=True, level=None, **kwargs):
+            """
+            This method returns the minimum of the values in the object. If you
+            want the *index* of the minimum, use ``idxmin``. This is the
+            equivalent of the ``numpy.ndarray`` method ``argmin``.
+            """
+            if axis is None:
+                axis = self._stat_axis_number
+            if level is not None:
+                return self._agg_by_level('min', axis=axis, level=level,
+                                          skipna=skipna)
+            return self._reduce(nanops.nanmin, axis=axis, skipna=skipna)
+        cls.min = min
+
     def cumsum(self, axis=None, skipna=True, **kwargs):
         """
         Return DataFrame of cumulative sums over requested axis.
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index b4748c86a..f0bad6b79 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -831,10 +831,11 @@ class Panel(NDFrame):
         result = np.apply_along_axis(func, i, self.values)
         return self._wrap_result(result, axis=axis)
 
-    def _reduce(self, op, axis=0, skipna=True):
+    def _reduce(self, op, axis=0, skipna=True, numeric_only=None,
+                filter_type=None, **kwds):
         axis_name = self._get_axis_name(axis)
         axis_number = self._get_axis_number(axis_name)
-        f = lambda x: op(x, axis=axis_number, skipna=skipna)
+        f = lambda x: op(x, axis=axis_number, skipna=skipna, **kwds)
 
         result = f(self.values)
 
@@ -1207,109 +1208,11 @@ Returns
                 return self._combine(other, na_op, axis=axis)
             f.__name__ = name
             return f
+
         # add `div`, `mul`, `pow`, etc..
         ops.add_flex_arithmetic_methods(cls, _panel_arith_method,
                                         use_numexpr=use_numexpr,
                                         flex_comp_method=ops._comp_method_PANEL)
-        _agg_doc = """
-Return %(desc)s over requested axis
-
-Parameters
-----------
-axis : {""" + ', '.join(cls._AXIS_ORDERS) + "} or {" \
-            + ', '.join([str(i) for i in range(cls._AXIS_LEN)]) + """}
-skipna : boolean, default True
-    Exclude NA/null values. If an entire row/column is NA, the result
-    will be NA
-
-Returns
--------
-%(outname)s : """ + cls._constructor_sliced.__name__ + "\n"
-
-        _na_info = """
-
-NA/null values are %s.
-If all values are NA, result will be NA"""
-
-        @Substitution(desc='sum', outname='sum')
-        @Appender(_agg_doc)
-        def sum(self, axis=None, skipna=True, **kwargs):
-            if axis is None:
-                axis = self._stat_axis_number
-            return self._reduce(nanops.nansum, axis=axis, skipna=skipna)
-        cls.sum = sum
-
-        @Substitution(desc='mean', outname='mean')
-        @Appender(_agg_doc)
-        def mean(self, axis=None, skipna=True, **kwargs):
-            if axis is None:
-                axis = self._stat_axis_number
-            return self._reduce(nanops.nanmean, axis=axis, skipna=skipna)
-        cls.mean = mean
-
-        @Substitution(desc='unbiased variance', outname='variance')
-        @Appender(_agg_doc)
-        def var(self, axis=None, skipna=True, **kwargs):
-            if axis is None:
-                axis = self._stat_axis_number
-            return self._reduce(nanops.nanvar, axis=axis, skipna=skipna)
-        cls.var = var
-
-        @Substitution(desc='unbiased standard deviation', outname='stdev')
-        @Appender(_agg_doc)
-        def std(self, axis=None, skipna=True, **kwargs):
-            if axis is None:
-                axis = self._stat_axis_number
-            return self.var(axis=axis, skipna=skipna).apply(np.sqrt)
-        cls.std = std
-
-        @Substitution(desc='unbiased skewness', outname='skew')
-        @Appender(_agg_doc)
-        def skew(self, axis=None, skipna=True, **wwargs):
-            if axis is None:
-                axis = self._stat_axis_number
-            return self._reduce(nanops.nanskew, axis=axis, skipna=skipna)
-        cls.skew = skew
-
-        @Substitution(desc='product', outname='prod')
-        @Appender(_agg_doc)
-        def prod(self, axis=None, skipna=True, **kwargs):
-            if axis is None:
-                axis = self._stat_axis_number
-            return self._reduce(nanops.nanprod, axis=axis, skipna=skipna)
-        cls.prod = prod
-
-        @Substitution(desc='compounded percentage', outname='compounded')
-        @Appender(_agg_doc)
-        def compound(self, axis=None, skipna=True, **kwargs):
-            if axis is None:
-                axis = self._stat_axis_number
-            return (1 + self).prod(axis=axis, skipna=skipna) - 1
-        cls.compound = compound
-
-        @Substitution(desc='median', outname='median')
-        @Appender(_agg_doc)
-        def median(self, axis=None, skipna=True, **kwargs):
-            if axis is None:
-                axis = self._stat_axis_number
-            return self._reduce(nanops.nanmedian, axis=axis, skipna=skipna)
-        cls.median = median
-
-        @Substitution(desc='maximum', outname='maximum')
-        @Appender(_agg_doc)
-        def max(self, axis=None, skipna=True, **kwargs):
-            if axis is None:
-                axis = self._stat_axis_number
-            return self._reduce(nanops.nanmax, axis=axis, skipna=skipna)
-        cls.max = max
-
-        @Substitution(desc='minimum', outname='minimum')
-        @Appender(_agg_doc)
-        def min(self, axis=None, skipna=True, **kwargs):
-            if axis is None:
-                axis = self._stat_axis_number
-            return self._reduce(nanops.nanmin, axis=axis, skipna=skipna)
-        cls.min = min
 
 Panel._setup_axes(axes=['items', 'major_axis', 'minor_axis'],
                   info_axis=0,
@@ -1321,6 +1224,7 @@ Panel._setup_axes(axes=['items', 'major_axis', 'minor_axis'],
 
 ops.add_special_arithmetic_methods(Panel, **ops.panel_special_funcs)
 Panel._add_aggregate_operations()
+Panel._add_numeric_operations()
 
 WidePanel = Panel
 LongPanel = DataFrame
diff --git a/pandas/core/panelnd.py b/pandas/core/panelnd.py
index 8f427568a..9ccce1edc 100644
--- a/pandas/core/panelnd.py
+++ b/pandas/core/panelnd.py
@@ -108,5 +108,6 @@ def create_nd_panel_factory(klass_name, orders, slices, slicer, aliases=None, st
 
     # add the aggregate operations
     klass._add_aggregate_operations()
+    klass._add_numeric_operations()
 
     return klass
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 972f654fe..01a11ed6d 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -77,40 +77,6 @@ def _unbox(func):
     f.__name__ = func.__name__
     return f
 
-_stat_doc = """
-Return %(name)s of values
-%(na_action)s
-
-Parameters
-----------
-skipna : boolean, default True
-    Exclude NA/null values
-level : int, default None
-    If the axis is a MultiIndex (hierarchical), count along a
-    particular level, collapsing into a smaller Series
-%(extras)s
-Returns
--------
-%(shortname)s : float (or Series if level specified)
-"""
-_doc_exclude_na = "NA/null values are excluded"
-_doc_ndarray_interface = ("Extra parameters are to preserve ndarray"
-                          "interface.\n")
-
-
-def _make_stat_func(nanop, name, shortname, na_action=_doc_exclude_na,
-                    extras=_doc_ndarray_interface):
-
-    @Substitution(name=name, shortname=shortname,
-                  na_action=na_action, extras=extras)
-    @Appender(_stat_doc)
-    def f(self, axis=0, dtype=None, out=None, skipna=True, level=None, **kwargs):
-        if level is not None:
-            return self._agg_by_level(shortname, level=level, skipna=skipna)
-        return nanop(_values_from_object(self), skipna=skipna)
-    f.__name__ = shortname
-    return f
-
 #----------------------------------------------------------------------
 # Series class
 
@@ -1194,113 +1160,6 @@ class Series(generic.NDFrame):
         duplicated = lib.duplicated(keys, take_last=take_last)
         return self._constructor(duplicated, index=self.index, name=self.name)
 
-    sum = _make_stat_func(nanops.nansum, 'sum', 'sum')
-    mean = _make_stat_func(nanops.nanmean, 'mean', 'mean')
-    median = _make_stat_func(nanops.nanmedian, 'median', 'median', extras='')
-    prod = _make_stat_func(nanops.nanprod, 'product', 'prod', extras='')
-
-    @Substitution(name='mean absolute deviation', shortname='mad',
-                  na_action=_doc_exclude_na, extras='')
-    @Appender(_stat_doc)
-    def mad(self, skipna=True, level=None, **kwargs):
-        if level is not None:
-            return self._agg_by_level('mad', level=level, skipna=skipna)
-
-        demeaned = self - self.mean(skipna=skipna)
-        return np.abs(demeaned).mean(skipna=skipna)
-
-    @Substitution(name='minimum', shortname='min',
-                  na_action=_doc_exclude_na, extras='')
-    @Appender(_stat_doc)
-    def min(self, axis=None, out=None, skipna=True, level=None, **kwargs):
-        """
-        Notes
-        -----
-        This method returns the minimum of the values in the Series. If you
-        want the *index* of the minimum, use ``Series.idxmin``. This is the
-        equivalent of the ``numpy.ndarray`` method ``argmin``.
-
-        See Also
-        --------
-        Series.idxmin
-        DataFrame.idxmin
-        """
-        if level is not None:
-            return self._agg_by_level('min', level=level, skipna=skipna)
-        return nanops.nanmin(_values_from_object(self), skipna=skipna)
-
-    @Substitution(name='maximum', shortname='max',
-                  na_action=_doc_exclude_na, extras='')
-    @Appender(_stat_doc)
-    def max(self, axis=None, out=None, skipna=True, level=None, **kwargs):
-        """
-        Notes
-        -----
-        This method returns the maximum of the values in the Series. If you
-        want the *index* of the maximum, use ``Series.idxmax``. This is the
-        equivalent of the ``numpy.ndarray`` method ``argmax``.
-
-        See Also
-        --------
-        Series.idxmax
-        DataFrame.idxmax
-        """
-        if level is not None:
-            return self._agg_by_level('max', level=level, skipna=skipna)
-        return nanops.nanmax(_values_from_object(self), skipna=skipna)
-
-    @Substitution(name='standard deviation', shortname='stdev',
-                  na_action=_doc_exclude_na, extras='')
-    @Appender(_stat_doc +
-              """
-        Normalized by N-1 (unbiased estimator).
-        """)
-    def std(self, axis=None, dtype=None, out=None, ddof=1, skipna=True,
-            level=None, **kwargs):
-        if level is not None:
-            return self._agg_by_level('std', level=level, skipna=skipna,
-                                      ddof=ddof)
-        return np.sqrt(nanops.nanvar(_values_from_object(self), skipna=skipna, ddof=ddof))
-
-    @Substitution(name='variance', shortname='var',
-                  na_action=_doc_exclude_na, extras='')
-    @Appender(_stat_doc +
-              """
-        Normalized by N-1 (unbiased estimator).
-        """)
-    def var(self, axis=None, dtype=None, out=None, ddof=1, skipna=True,
-            level=None, **kwargs):
-        if level is not None:
-            return self._agg_by_level('var', level=level, skipna=skipna,
-                                      ddof=ddof)
-        return nanops.nanvar(_values_from_object(self), skipna=skipna, ddof=ddof)
-
-    @Substitution(name='unbiased skewness', shortname='skew',
-                  na_action=_doc_exclude_na, extras='')
-    @Appender(_stat_doc)
-    def skew(self, skipna=True, level=None, **kwargs):
-        if level is not None:
-            return self._agg_by_level('skew', level=level, skipna=skipna)
-
-        return nanops.nanskew(_values_from_object(self), skipna=skipna)
-
-    @Substitution(name='unbiased kurtosis', shortname='kurt',
-                  na_action=_doc_exclude_na, extras='')
-    @Appender(_stat_doc)
-    def kurt(self, skipna=True, level=None, **kwargs):
-        if level is not None:
-            return self._agg_by_level('kurt', level=level, skipna=skipna)
-
-        return nanops.nankurt(_values_from_object(self), skipna=skipna)
-
-    def _agg_by_level(self, name, level=0, skipna=True, **kwds):
-        grouped = self.groupby(level=level)
-        if hasattr(grouped, name) and skipna:
-            return getattr(grouped, name)(**kwds)
-        method = getattr(type(self), name)
-        applyf = lambda x: method(x, skipna=skipna, **kwds)
-        return grouped.aggregate(applyf)
-
     def idxmin(self, axis=None, out=None, skipna=True):
         """
         Index of first occurrence of minimum of values.
@@ -2208,6 +2067,11 @@ class Series(generic.NDFrame):
         else:
             return self._constructor(mapped, index=self.index, name=self.name)
 
+    def _reduce(self, op, axis=0, skipna=True, numeric_only=None,
+                filter_type=None, **kwds):
+        """ perform a reduction operation """
+        return op(_values_from_object(self), skipna=skipna, **kwds)
+
     def _reindex_indexer(self, new_index, indexer, copy):
         if indexer is None:
             if copy:
@@ -2647,7 +2511,8 @@ class Series(generic.NDFrame):
         new_index = self.index.to_period(freq=freq)
         return self._constructor(new_values, index=new_index, name=self.name)
 
-Series._setup_axes(['index'], info_axis=0)
+Series._setup_axes(['index'], info_axis=0, stat_axis=0)
+Series._add_numeric_operations()
 _INDEX_TYPES = ndarray, Index, list, tuple
 
 # reinstall the SeriesIndexer

commit 68b12566a058bbf546adada236de73bd03caaa36
Author: immerrr <immerrr@gmail.com>
Date:   Wed Mar 12 14:40:26 2014 +0400

    BUG/CLN: fix iloc when positional indexer matched Int64Index keys
    
    Also, drop takeable parameter from reindex(...) function family.

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 226fce52d..6f83bea6a 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -231,6 +231,8 @@ Bug Fixes
 - Bug in fillna with method = 'bfill/ffill' and ``datetime64[ns]`` dtype (:issue:`6587`)
 - Bug in sql writing with mixed dtypes possibly leading to data loss (:issue:`6509`)
 - Bug in popping from a Series (:issue:`6600`)
+- Bug in ``iloc`` indexing when positional indexer matched Int64Index of corresponding axis no reordering happened (:issue:`6612`)
+
 
 pandas 0.13.1
 -------------
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 6a8786229..e6e275a5f 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1613,10 +1613,8 @@ class DataFrame(NDFrame):
             else:
                 label = self.index[i]
                 if isinstance(label, Index):
-
                     # a location index by definition
-                    i = _maybe_convert_indices(i, len(self._get_axis(axis)))
-                    result = self.reindex(i, takeable=True)
+                    result = self.take(i, axis=axis)
                     copy=True
                 else:
                     new_values, copy = self._data.fast_xs(i, copy=copy)
@@ -2124,41 +2122,38 @@ class DataFrame(NDFrame):
     #----------------------------------------------------------------------
     # Reindexing and alignment
 
-    def _reindex_axes(self, axes, level, limit, method, fill_value, copy,
-                      takeable=False):
+    def _reindex_axes(self, axes, level, limit, method, fill_value, copy):
         frame = self
 
         columns = axes['columns']
         if columns is not None:
             frame = frame._reindex_columns(columns, copy, level, fill_value,
-                                           limit, takeable=takeable)
+                                           limit)
 
         index = axes['index']
         if index is not None:
             frame = frame._reindex_index(index, method, copy, level,
-                                         fill_value, limit, takeable=takeable)
+                                         fill_value, limit)
 
         return frame
 
     def _reindex_index(self, new_index, method, copy, level, fill_value=NA,
-                       limit=None, takeable=False):
+                       limit=None):
         new_index, indexer = self.index.reindex(new_index, method, level,
                                                 limit=limit,
-                                                copy_if_needed=True,
-                                                takeable=takeable)
+                                                copy_if_needed=True)
         return self._reindex_with_indexers({0: [new_index, indexer]},
                                            copy=copy, fill_value=fill_value,
-                                           allow_dups=takeable)
+                                           allow_dups=False)
 
     def _reindex_columns(self, new_columns, copy, level, fill_value=NA,
-                         limit=None, takeable=False):
+                         limit=None):
         new_columns, indexer = self.columns.reindex(new_columns, level=level,
                                                     limit=limit,
-                                                    copy_if_needed=True,
-                                                    takeable=takeable)
+                                                    copy_if_needed=True)
         return self._reindex_with_indexers({1: [new_columns, indexer]},
                                            copy=copy, fill_value=fill_value,
-                                           allow_dups=takeable)
+                                           allow_dups=False)
 
     def _reindex_multi(self, axes, copy, fill_value):
         """ we are guaranteed non-Nones in the axes! """
@@ -2689,10 +2684,9 @@ class DataFrame(NDFrame):
             ax = 'index' if axis == 0 else 'columns'
 
             if new_axis.is_unique:
-                d = {ax: new_axis}
+                return self.reindex(**{ax: new_axis})
             else:
-                d = {ax: indexer, 'takeable': True}
-            return self.reindex(**d)
+                return self.take(indexer, axis=axis, convert=False)
 
         if inplace:
             if axis == 1:
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 120e03e99..678578a19 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -1546,8 +1546,6 @@ class NDFrame(PandasObject):
             "compatible" value
         limit : int, default None
             Maximum size gap to forward or backward fill
-        takeable : boolean, default False
-            treat the passed as positional values
 
         Examples
         --------
@@ -1570,7 +1568,6 @@ class NDFrame(PandasObject):
         copy = kwargs.get('copy', True)
         limit = kwargs.get('limit')
         fill_value = kwargs.get('fill_value', np.nan)
-        takeable = kwargs.get('takeable', False)
 
         self._consolidate_inplace()
 
@@ -1591,11 +1588,9 @@ class NDFrame(PandasObject):
 
         # perform the reindex on the axes
         return self._reindex_axes(axes, level, limit,
-                                  method, fill_value, copy,
-                                  takeable=takeable).__finalize__(self)
+                                  method, fill_value, copy).__finalize__(self)
 
-    def _reindex_axes(self, axes, level, limit, method, fill_value, copy,
-                      takeable=False):
+    def _reindex_axes(self, axes, level, limit, method, fill_value, copy):
         """ perform the reinxed for all the axes """
         obj = self
         for a in self._AXIS_ORDERS:
@@ -1610,13 +1605,12 @@ class NDFrame(PandasObject):
             axis = self._get_axis_number(a)
             ax = self._get_axis(a)
             new_index, indexer = ax.reindex(
-                labels, level=level, limit=limit, method=method,
-                takeable=takeable)
+                labels, level=level, limit=limit, method=method)
 
             obj = obj._reindex_with_indexers(
                 {axis: [new_index, indexer]}, method=method,
                 fill_value=fill_value, limit=limit, copy=copy,
-                allow_dups=takeable)
+                allow_dups=False)
 
         return obj
 
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 3bc3783ff..0343475be 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1308,7 +1308,7 @@ class Index(IndexOpsMixin, FrozenNDArray):
         return aliases.get(method, method)
 
     def reindex(self, target, method=None, level=None, limit=None,
-                copy_if_needed=False, takeable=False):
+                copy_if_needed=False):
         """
         For Index, simply returns the new index and the results of
         get_indexer. Provided here to enable an interface that is amenable for
@@ -1336,13 +1336,6 @@ class Index(IndexOpsMixin, FrozenNDArray):
                         target = self.copy()
 
             else:
-
-                if takeable:
-                    if method is not None or limit is not None:
-                        raise ValueError("cannot do a takeable reindex with "
-                                         "with a method or limit")
-                    return self[target], target
-
                 if self.is_unique:
                     indexer = self.get_indexer(target, method=method,
                                                limit=limit)
@@ -3113,7 +3106,7 @@ class MultiIndex(Index):
         return com._ensure_platform_int(indexer)
 
     def reindex(self, target, method=None, level=None, limit=None,
-                copy_if_needed=False, takeable=False):
+                copy_if_needed=False):
         """
         Performs any necessary conversion on the input index and calls
         get_indexer. This method is here so MultiIndex and an Index of
@@ -3124,10 +3117,6 @@ class MultiIndex(Index):
         (new_index, indexer, mask) : (MultiIndex, ndarray, ndarray)
         """
 
-        # a direct takeable
-        if takeable:
-            return self.take(target), target
-
         if level is not None:
             if method is not None:
                 raise TypeError('Fill method not supported if level passed')
@@ -3142,14 +3131,8 @@ class MultiIndex(Index):
                     indexer = self.get_indexer(target, method=method,
                                                limit=limit)
                 else:
-                    if takeable:
-                        if method is not None or limit is not None:
-                            raise ValueError("cannot do a takeable reindex "
-                                             "with a method or limit")
-                        return self[target], target
-
                     raise Exception(
-                        "cannot handle a non-takeable non-unique multi-index!")
+                        "cannot handle a non-unique multi-index!")
 
         if not isinstance(target, MultiIndex):
             if indexer is None:
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 409bbf601..bc5566ce4 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -460,8 +460,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
             else:
                 label = self.index[i]
                 if isinstance(label, Index):
-                    i = _maybe_convert_indices(i, len(self))
-                    return self.reindex(i, takeable=True)
+                    return self.take(i, axis=axis, convert=True)
                 else:
                     return _index.get_value_at(self, i)
 

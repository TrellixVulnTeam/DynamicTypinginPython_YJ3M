commit e28903c248b2a4f71fd04163ea5b083bbbcc369a
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Nov 28 00:42:28 2012 -0500

    ENH: configurability of boolean value indicators. true_values/false_values arguments to read_csv/table. close #2360

diff --git a/RELEASE.rst b/RELEASE.rst
index 8b5243e76..46e7b420f 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -38,6 +38,8 @@ pandas 0.10.0
 
 **API Changes**
 
+  - ``pandas.merge`` will now default to ``sort=False``. For many use cases
+    sorting the join keys is not necessary, and doing it by default is wasteful
   - ``names`` handling in file parsing: if explicit column `names` passed,
     `header` argument will be respected. If there is an existing header column,
     this can rename the columns. To fix legacy code, put ``header=None`` when
@@ -45,6 +47,9 @@ pandas 0.10.0
   - DataFrame selection using a boolean frame now preserves input shape
   - If function passed to Series.apply yields a Series, result will be a
     DataFrame (#2316)
+  - Values like YES/NO/yes/no will not be considered as boolean by default any
+    longer in the file parsers. This can be customized using the new
+    ``true_values`` and ``false_values`` options (#2360)
 
 **Improvements to existing features**
 
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index 2c000ad5f..f4aaff9a0 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -54,6 +54,10 @@ names : array-like
 na_values : list-like or dict, default None
     Additional strings to recognize as NA/NaN. If dict passed, specific
     per-column NA values
+true_values : list
+    Values to consider as True
+false_values : list
+    Values to consider as False
 keep_default_na : bool, default True
     If na_values are specified and keep_default_na is False the default NaN
     values are overridden, otherwise they're appended to
@@ -200,6 +204,8 @@ _parser_defaults = {
     'names': None,
     'skiprows': None,
     'na_values': None,
+    'true_values': None,
+    'false_values': None,
     'skip_footer': 0,
     'converters': None,
 
@@ -268,6 +274,8 @@ def _make_parser_function(name, sep=','):
                  skipfooter=None,
                  skip_footer=0,
                  na_values=None,
+                 true_values=None,
+                 false_values=None,
                  delimiter=None,
                  converters=None,
                  dtype=None,
@@ -322,6 +330,8 @@ def _make_parser_function(name, sep=','):
                     names=names,
                     skiprows=skiprows,
                     na_values=na_values,
+                    true_values=true_values,
+                    false_values=false_values,
                     keep_default_na=keep_default_na,
                     thousands=thousands,
                     comment=comment,
@@ -619,6 +629,8 @@ class ParserBase(object):
         self.keep_date_col = kwds.pop('keep_date_col', False)
 
         self.na_values = kwds.get('na_values')
+        self.true_values = kwds.get('true_values')
+        self.false_values = kwds.get('false_values')
 
         self._date_conv = _make_date_converter(date_parser=self.date_parser,
                                                dayfirst=self.dayfirst)
@@ -733,13 +745,59 @@ class ParserBase(object):
                     col_na_values = _get_na_values(col_name,
                                                    self.na_values)
 
-            arr, _ = _convert_types(arr, col_na_values)
+            arr, _ = self._convert_types(arr, col_na_values)
             arrays.append(arr)
 
         index = MultiIndex.from_arrays(arrays, names=self.index_names)
 
         return index
 
+
+    def _convert_to_ndarrays(self, dct, na_values, verbose=False,
+                             converters=None):
+        result = {}
+        for c, values in dct.iteritems():
+            conv_f = None if converters is None else converters.get(c, None)
+            col_na_values = _get_na_values(c, na_values)
+            coerce_type = True
+            if conv_f is not None:
+                values = lib.map_infer(values, conv_f)
+                coerce_type = False
+            cvals, na_count = self._convert_types(values, col_na_values,
+                                                  coerce_type)
+            result[c] = cvals
+            if verbose and na_count:
+                print 'Filled %d NA values in column %s' % (na_count, str(c))
+        return result
+
+    def _convert_types(self, values, na_values, try_num_bool=True):
+        na_count = 0
+        if issubclass(values.dtype.type, (np.number, np.bool_)):
+            mask = lib.ismember(values, na_values)
+            na_count = mask.sum()
+            if na_count > 0:
+                if com.is_integer_dtype(values):
+                    values = values.astype(np.float64)
+                np.putmask(values, mask, np.nan)
+            return values, na_count
+
+        if try_num_bool:
+            try:
+                result = lib.maybe_convert_numeric(values, na_values, False)
+            except Exception:
+                na_count = lib.sanitize_objects(values, na_values, False)
+                result = values
+        else:
+            na_count = lib.sanitize_objects(values, na_values, False)
+            result = values
+
+        if result.dtype == np.object_ and try_num_bool:
+            result = lib.maybe_convert_bool(values,
+                                            true_values=self.true_values,
+                                            false_values=self.false_values)
+
+        return result, na_count
+
     def _do_date_conversions(self, names, data):
         # returns data, columns
         if self.parse_dates is not None:
@@ -1121,8 +1179,8 @@ class PythonParser(ParserBase):
                 col = self.orig_names[col]
             clean_conv[col] = f
 
-        return _convert_to_ndarrays(data, self.na_values, self.verbose,
-                                    clean_conv)
+        return self._convert_to_ndarrays(data, self.na_values, self.verbose,
+                                         clean_conv)
 
     def _infer_columns(self):
         names = self.names
@@ -1539,49 +1597,6 @@ def _get_na_values(col, na_values):
         return na_values
 
 
-def _convert_to_ndarrays(dct, na_values, verbose=False, converters=None):
-    result = {}
-    for c, values in dct.iteritems():
-        conv_f = None if converters is None else converters.get(c, None)
-        col_na_values = _get_na_values(c, na_values)
-        coerce_type = True
-        if conv_f is not None:
-            values = lib.map_infer(values, conv_f)
-            coerce_type = False
-        cvals, na_count = _convert_types(values, col_na_values, coerce_type)
-        result[c] = cvals
-        if verbose and na_count:
-            print 'Filled %d NA values in column %s' % (na_count, str(c))
-    return result
-
-
-def _convert_types(values, na_values, try_num_bool=True):
-    na_count = 0
-    if issubclass(values.dtype.type, (np.number, np.bool_)):
-        mask = lib.ismember(values, na_values)
-        na_count = mask.sum()
-        if na_count > 0:
-            if com.is_integer_dtype(values):
-                values = values.astype(np.float64)
-            np.putmask(values, mask, np.nan)
-        return values, na_count
-
-    if try_num_bool:
-        try:
-            result = lib.maybe_convert_numeric(values, na_values, False)
-        except Exception:
-            na_count = lib.sanitize_objects(values, na_values, False)
-            result = values
-    else:
-        na_count = lib.sanitize_objects(values, na_values, False)
-        result = values
-
-    if result.dtype == np.object_ and try_num_bool:
-        result = lib.maybe_convert_bool(values)
-
-    return result, na_count
-
-
 
 def _get_col_names(colspec, columns):
     colset = set(columns)
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index 7b5c59b71..2ae655ed7 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -865,7 +865,9 @@ yes,3
 No,3
 Yes,3
 """
-        data = self.read_csv(StringIO(data))
+        data = self.read_csv(StringIO(data),
+                             true_values=['yes', 'Yes', 'YES'],
+                             false_values=['no', 'NO', 'No'])
         self.assert_(data['A'].dtype == np.bool_)
 
         data = """A,B
@@ -876,6 +878,14 @@ TRUE,3
         data = self.read_csv(StringIO(data))
         self.assert_(data['A'].dtype == np.bool_)
 
+        data = """A,B
+foo,bar
+bar,foo"""
+        result = self.read_csv(StringIO(data), true_values=['foo'],
+                               false_values=['bar'])
+        expected = DataFrame({'A': [True, False], 'B': [False, True]})
+        tm.assert_frame_equal(result, expected)
+
     def test_int_conversion(self):
         data = """A,B
 1.0,1
diff --git a/pandas/src/inference.pyx b/pandas/src/inference.pyx
index 8e8b2d15a..7337d572f 100644
--- a/pandas/src/inference.pyx
+++ b/pandas/src/inference.pyx
@@ -679,7 +679,8 @@ def sanitize_objects(ndarray[object] values, set na_values,
 
     return na_count
 
-def maybe_convert_bool(ndarray[object] arr):
+def maybe_convert_bool(ndarray[object] arr,
+                       true_values=None, false_values=None):
     cdef:
         Py_ssize_t i, n
         ndarray[uint8_t] result
@@ -690,8 +691,15 @@ def maybe_convert_bool(ndarray[object] arr):
     n = len(arr)
     result = np.empty(n, dtype=np.uint8)
 
-    true_vals = set(('True', 'TRUE', 'true', 'Yes', 'YES', 'yes'))
-    false_vals = set(('False', 'FALSE', 'false', 'No', 'NO', 'no'))
+    # the defaults
+    true_vals = set(('True', 'TRUE', 'true'))
+    false_vals = set(('False', 'FALSE', 'false'))
+
+    if true_values is not None:
+        true_vals = true_vals | set(true_values)
+
+    if false_values is not None:
+        false_vals = false_vals | set(false_values)
 
     for i from 0 <= i < n:
         val = arr[i]
diff --git a/pandas/src/parser.pyx b/pandas/src/parser.pyx
index d708ef286..de4cabfac 100644
--- a/pandas/src/parser.pyx
+++ b/pandas/src/parser.pyx
@@ -234,7 +234,8 @@ cdef class TextReader:
 
     cdef public:
         int leading_cols, table_width, skip_footer, buffer_lines
-        object delimiter, na_values, converters, delim_whitespace
+        object delimiter, converters, delim_whitespace
+        object na_values, true_values, false_values
         object memory_map
         object as_recarray
         object header, names
@@ -281,6 +282,9 @@ cdef class TextReader:
 
                   na_filter=True,
                   na_values=None,
+                  true_values=None,
+                  false_values=None,
+
                   compact_ints=False,
                   use_unsigned=False,
                   low_memory=False,
@@ -364,6 +368,9 @@ cdef class TextReader:
         self.delim_whitespace = delim_whitespace
 
         self.na_values = na_values
+        self.true_values = true_values
+        self.false_values = false_values
+
         self.converters = converters
 
         self.na_filter = na_filter
@@ -857,6 +864,7 @@ cdef class TextReader:
     cdef _convert_with_dtype(self, object dtype, Py_ssize_t i,
                              int start, int end,
                              bint na_filter, kh_str_t *na_hashset):
+        cdef kh_str_t *true_set, *false_set
 
         if dtype[1] == 'i' or dtype[1] == 'u':
             result, na_count = _try_int64(self.parser, i, start, end,
@@ -878,8 +886,18 @@ cdef class TextReader:
             return result, na_count
 
         elif dtype[1] == 'b':
-            result, na_count = _try_bool(self.parser, i, start, end,
-                                         na_filter, na_hashset)
+            if self.true_values is not None or self.false_values is not None:
+
+                true_set = _get_true_set(self.true_values)
+                false_set = _get_false_set(self.false_values)
+                result, na_count = _try_bool_flex(self.parser, i, start, end,
+                                                  na_filter, na_hashset,
+                                                  true_set, false_set)
+                kh_destroy_str(true_set)
+                kh_destroy_str(false_set)
+            else:
+                result, na_count = _try_bool(self.parser, i, start, end,
+                                             na_filter, na_hashset)
             return result, na_count
         elif dtype[1] == 'c':
             raise NotImplementedError
@@ -976,6 +994,25 @@ class CParserError(Exception):
 class OverflowError(ValueError):
     pass
 
+cdef object _true_values = ['True', 'TRUE', 'true']
+cdef object _false_values = ['False', 'FALSE', 'false']
+
+cdef kh_str_t* _get_true_set(object values):
+    if values is None:
+        values = []
+    elif not isinstance(values, list):
+        values = list(values)
+
+    return kset_from_list(values + _true_values)
+
+cdef kh_str_t* _get_false_set(object values):
+    if values is None:
+        values = []
+    elif not isinstance(values, list):
+        values = list(values)
+
+    return kset_from_list(values + _false_values)
+
 
 def _ensure_encoded(list lst):
     cdef list result = []
@@ -1311,6 +1348,7 @@ cdef _try_int64(parser_t *parser, int col, int line_start, int line_end,
 
     return result, na_count
 
+
 cdef _try_bool(parser_t *parser, int col, int line_start, int line_end,
                bint na_filter, kh_str_t *na_hashset):
     cdef:
@@ -1356,6 +1394,77 @@ cdef _try_bool(parser_t *parser, int col, int line_start, int line_end,
 
     return result.view(np.bool_), na_count
 
+
+cdef _try_bool_flex(parser_t *parser, int col, int line_start, int line_end,
+                    bint na_filter, kh_str_t *na_hashset,
+                    kh_str_t *true_hashset, kh_str_t *false_hashset):
+    cdef:
+        int error, na_count = 0
+        size_t i, lines
+        coliter_t it
+        char *word
+        uint8_t *data
+        ndarray result
+
+        uint8_t NA = na_values[np.bool_]
+        khiter_t k
+
+    lines = line_end - line_start
+    result = np.empty(lines, dtype=np.uint8)
+    data = <uint8_t *> result.data
+    coliter_setup(&it, parser, col, line_start)
+
+    if na_filter:
+        for i in range(lines):
+            word = COLITER_NEXT(it)
+
+            k = kh_get_str(na_hashset, word)
+            # in the hash table
+            if k != na_hashset.n_buckets:
+                na_count += 1
+                data[0] = NA
+                data += 1
+                continue
+
+            k = kh_get_str(true_hashset, word)
+            if k != true_hashset.n_buckets:
+                data[0] = 1
+                data += 1
+                continue
+
+            k = kh_get_str(false_hashset, word)
+            if k != false_hashset.n_buckets:
+                data[0] = 0
+                data += 1
+                continue
+
+            error = to_boolean(word, data)
+            if error != 0:
+                return None, None
+            data += 1
+    else:
+        for i in range(lines):
+            word = COLITER_NEXT(it)
+
+            k = kh_get_str(true_hashset, word)
+            if k != true_hashset.n_buckets:
+                data[0] = 1
+                data += 1
+                continue
+
+            k = kh_get_str(false_hashset, word)
+            if k != false_hashset.n_buckets:
+                data[0] = 0
+                data += 1
+                continue
+
+            error = to_boolean(word, data)
+            if error != 0:
+                return None, None
+            data += 1
+
+    return result.view(np.bool_), na_count
+
 cdef _get_na_mask(parser_t *parser, int col, int line_start, int line_end,
                   kh_str_t *na_hashset):
     cdef:
diff --git a/pandas/src/parser/tokenizer.c b/pandas/src/parser/tokenizer.c
index 9b777823a..06493f457 100644
--- a/pandas/src/parser/tokenizer.c
+++ b/pandas/src/parser/tokenizer.c
@@ -1498,14 +1498,14 @@ int to_boolean(char *item, uint8_t *val) {
     char *tmp;
     int i, status = 0;
 
-    static const char *tstrs[2] = {"TRUE", "YES"};
-    static const char *fstrs[2] = {"FALSE", "NO"};
+    static const char *tstrs[1] = {"TRUE"};
+    static const char *fstrs[1] = {"FALSE"};
 
     tmp = malloc(sizeof(char) * (strlen(item) + 1));
     strcpy(tmp, item);
     uppercase(tmp);
 
-    for (i = 0; i < 2; ++i)
+    for (i = 0; i < 1; ++i)
     {
         if (strcmp(tmp, tstrs[i]) == 0) {
             *val = 1;
@@ -1513,7 +1513,7 @@ int to_boolean(char *item, uint8_t *val) {
         }
     }
 
-    for (i = 0; i < 2; ++i)
+    for (i = 0; i < 1; ++i)
     {
         if (strcmp(tmp, fstrs[i]) == 0) {
             *val = 0;

commit fbcd5abcadb37c612804aefc5255e2e99b009444
Author: jreback <jeff@reback.net>
Date:   Wed Jun 12 09:04:55 2013 -0400

    BUG: make sure that nan/none like values to Timestamp are returned as NaT

diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 88dee987f..ac02dee33 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -38,6 +38,7 @@ from pandas.util.testing import assert_frame_equal
 import pandas.util.py3compat as py3compat
 from pandas.core.datetools import BDay
 import pandas.core.common as com
+from pandas import concat
 
 from numpy.testing.decorators import slow
 
@@ -171,7 +172,6 @@ class TestTimeSeriesDuplicates(unittest.TestCase):
     def test_indexing_unordered(self):
 
         # GH 2437
-        from pandas import concat
         rng = date_range(start='2011-01-01', end='2011-01-15')
         ts  = Series(randn(len(rng)), index=rng)
         ts2 = concat([ts[0:4],ts[-4:],ts[4:-4]])
@@ -601,6 +601,26 @@ class TestTimeSeries(unittest.TestCase):
         expected = Series([ Timestamp('2013-06-09 02:42:28') + timedelta(seconds=t) for t in range(20) ])
         assert_series_equal(result,expected)
 
+        s = Series([ epoch + t for t in range(20) ]).astype(float)
+        result = to_datetime(s,unit='s')
+        expected = Series([ Timestamp('2013-06-09 02:42:28') + timedelta(seconds=t) for t in range(20) ])
+        assert_series_equal(result,expected)
+
+        s = Series([ epoch + t for t in range(20) ] + [iNaT])
+        result = to_datetime(s,unit='s')
+        expected = Series([ Timestamp('2013-06-09 02:42:28') + timedelta(seconds=t) for t in range(20) ] + [NaT])
+        assert_series_equal(result,expected)
+
+        s = Series([ epoch + t for t in range(20) ] + [iNaT]).astype(float)
+        result = to_datetime(s,unit='s')
+        expected = Series([ Timestamp('2013-06-09 02:42:28') + timedelta(seconds=t) for t in range(20) ] + [NaT])
+        assert_series_equal(result,expected)
+
+        s = concat([Series([ epoch + t for t in range(20) ]).astype(float),Series([np.nan])],ignore_index=True)
+        result = to_datetime(s,unit='s')
+        expected = Series([ Timestamp('2013-06-09 02:42:28') + timedelta(seconds=t) for t in range(20) ] + [NaT])
+        assert_series_equal(result,expected)
+
     def test_series_ctor_datetime64(self):
         rng = date_range('1/1/2000 00:00:00', '1/1/2000 1:59:50',
                          freq='10s')
@@ -2741,6 +2761,19 @@ class TestTimestamp(unittest.TestCase):
         check(val/1000000.0 + 0.005,unit='ms',us=5)
         check(val/1000000000.0 + 0.5,unit='s',us=500000)
 
+        # nan
+        result = Timestamp(np.nan)
+        self.assert_(result is NaT)
+        
+        result = Timestamp(None)
+        self.assert_(result is NaT)
+        
+        result = Timestamp(iNaT)
+        self.assert_(result is NaT)
+
+        result = Timestamp(NaT)
+        self.assert_(result is NaT)
+
     def test_comparison(self):
         # 5-18-2012 00:00:00.000
         stamp = 1337299200000000000L
diff --git a/pandas/tslib.pyx b/pandas/tslib.pyx
index c2a3f429e..ec11de739 100644
--- a/pandas/tslib.pyx
+++ b/pandas/tslib.pyx
@@ -640,17 +640,25 @@ cdef convert_to_tsobject(object ts, object tz, object unit):
 
     obj = _TSObject()
 
-    if is_datetime64_object(ts):
+    if ts is None or ts is NaT:
+        obj.value = NPY_NAT
+    elif is_datetime64_object(ts):
         obj.value = _get_datetime64_nanos(ts)
         pandas_datetime_to_datetimestruct(obj.value, PANDAS_FR_ns, &obj.dts)
     elif is_integer_object(ts):
-        ts = ts * cast_from_unit(unit,None)
-        obj.value = ts
-        pandas_datetime_to_datetimestruct(ts, PANDAS_FR_ns, &obj.dts)
+        if ts == NPY_NAT:
+            obj.value = NPY_NAT
+        else:
+            ts = ts * cast_from_unit(unit,None)
+            obj.value = ts
+            pandas_datetime_to_datetimestruct(ts, PANDAS_FR_ns, &obj.dts)
     elif util.is_float_object(ts):
-        ts = cast_from_unit(unit,ts)
-        obj.value = ts
-        pandas_datetime_to_datetimestruct(ts, PANDAS_FR_ns, &obj.dts)
+        if ts != ts or ts == NPY_NAT:
+            obj.value = NPY_NAT
+        else:
+            ts = cast_from_unit(unit,ts)
+            obj.value = ts
+            pandas_datetime_to_datetimestruct(ts, PANDAS_FR_ns, &obj.dts)
     elif util.is_string_object(ts):
         if ts in _nat_strings:
             obj.value = NPY_NAT
@@ -864,9 +872,15 @@ def array_to_datetime(ndarray[object] values, raise_=False, dayfirst=False,
 
             # if we are coercing, dont' allow integers
             elif util.is_integer_object(val) and not coerce:
-                iresult[i] = val*m
+                if val == iNaT:
+                    iresult[i] = iNaT
+                else:
+                    iresult[i] = val*m
             elif util.is_float_object(val) and not coerce:
-                iresult[i] = cast_from_unit(unit,val)
+                if val != val or val == iNaT:
+                    iresult[i] = iNaT
+                else:
+                    iresult[i] = cast_from_unit(unit,val)
             else:
                 try:
                     if len(val) == 0:

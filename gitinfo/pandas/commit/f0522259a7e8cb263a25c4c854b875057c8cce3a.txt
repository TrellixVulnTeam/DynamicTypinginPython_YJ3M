commit f0522259a7e8cb263a25c4c854b875057c8cce3a
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Oct 31 18:19:38 2017 -0700

    Separate out arithmetic tests for datetimelike indexes (#18049)

diff --git a/pandas/tests/indexes/datetimes/test_arithmetic.py b/pandas/tests/indexes/datetimes/test_arithmetic.py
new file mode 100644
index 000000000..2f3d56759
--- /dev/null
+++ b/pandas/tests/indexes/datetimes/test_arithmetic.py
@@ -0,0 +1,335 @@
+# -*- coding: utf-8 -*-
+import warnings
+from datetime import datetime, timedelta
+
+import pytest
+
+import numpy as np
+
+import pandas as pd
+import pandas.util.testing as tm
+from pandas.errors import PerformanceWarning
+from pandas import (Timestamp, Timedelta, Series,
+                    DatetimeIndex, TimedeltaIndex,
+                    date_range)
+
+
+class TestDatetimeIndexArithmetic(object):
+    tz = [None, 'UTC', 'Asia/Tokyo', 'US/Eastern', 'dateutil/Asia/Singapore',
+          'dateutil/US/Pacific']
+
+    def test_add_iadd(self):
+        for tz in self.tz:
+
+            # offset
+            offsets = [pd.offsets.Hour(2), timedelta(hours=2),
+                       np.timedelta64(2, 'h'), Timedelta(hours=2)]
+
+            for delta in offsets:
+                rng = pd.date_range('2000-01-01', '2000-02-01', tz=tz)
+                result = rng + delta
+                expected = pd.date_range('2000-01-01 02:00',
+                                         '2000-02-01 02:00', tz=tz)
+                tm.assert_index_equal(result, expected)
+                rng += delta
+                tm.assert_index_equal(rng, expected)
+
+            # int
+            rng = pd.date_range('2000-01-01 09:00', freq='H', periods=10,
+                                tz=tz)
+            result = rng + 1
+            expected = pd.date_range('2000-01-01 10:00', freq='H', periods=10,
+                                     tz=tz)
+            tm.assert_index_equal(result, expected)
+            rng += 1
+            tm.assert_index_equal(rng, expected)
+
+        idx = DatetimeIndex(['2011-01-01', '2011-01-02'])
+        msg = "cannot add DatetimeIndex and Timestamp"
+        with tm.assert_raises_regex(TypeError, msg):
+            idx + Timestamp('2011-01-01')
+
+        with tm.assert_raises_regex(TypeError, msg):
+            Timestamp('2011-01-01') + idx
+
+    def test_sub_isub(self):
+        for tz in self.tz:
+
+            # offset
+            offsets = [pd.offsets.Hour(2), timedelta(hours=2),
+                       np.timedelta64(2, 'h'), Timedelta(hours=2)]
+
+            for delta in offsets:
+                rng = pd.date_range('2000-01-01', '2000-02-01', tz=tz)
+                expected = pd.date_range('1999-12-31 22:00',
+                                         '2000-01-31 22:00', tz=tz)
+
+                result = rng - delta
+                tm.assert_index_equal(result, expected)
+                rng -= delta
+                tm.assert_index_equal(rng, expected)
+
+            # int
+            rng = pd.date_range('2000-01-01 09:00', freq='H', periods=10,
+                                tz=tz)
+            result = rng - 1
+            expected = pd.date_range('2000-01-01 08:00', freq='H', periods=10,
+                                     tz=tz)
+            tm.assert_index_equal(result, expected)
+            rng -= 1
+            tm.assert_index_equal(rng, expected)
+
+    @pytest.mark.parametrize('addend', [
+        datetime(2011, 1, 1),
+        DatetimeIndex(['2011-01-01', '2011-01-02']),
+        DatetimeIndex(['2011-01-01', '2011-01-02']).tz_localize('US/Eastern'),
+        np.datetime64('2011-01-01'),
+        Timestamp('2011-01-01')])
+    def test_add_datetimelike_and_dti(self, addend):
+        # GH#9631
+        dti = DatetimeIndex(['2011-01-01', '2011-01-02'])
+        msg = 'cannot add DatetimeIndex and {0}'.format(
+            type(addend).__name__)
+        with tm.assert_raises_regex(TypeError, msg):
+            dti + addend
+        with tm.assert_raises_regex(TypeError, msg):
+            addend + dti
+
+    @pytest.mark.parametrize('addend', [
+        datetime(2011, 1, 1),
+        DatetimeIndex(['2011-01-01', '2011-01-02']),
+        DatetimeIndex(['2011-01-01', '2011-01-02']).tz_localize('US/Eastern'),
+        np.datetime64('2011-01-01'),
+        Timestamp('2011-01-01')])
+    def test_add_datetimelike_and_dti_tz(self, addend):
+        # GH#9631
+        dti_tz = DatetimeIndex(['2011-01-01',
+                                '2011-01-02']).tz_localize('US/Eastern')
+        msg = 'cannot add DatetimeIndex and {0}'.format(
+            type(addend).__name__)
+        with tm.assert_raises_regex(TypeError, msg):
+            dti_tz + addend
+        with tm.assert_raises_regex(TypeError, msg):
+            addend + dti_tz
+
+    def test_sub_dti_dti(self):
+        # previously performed setop (deprecated in 0.16.0), now changed to
+        # return subtraction -> TimeDeltaIndex (GH ...)
+
+        dti = date_range('20130101', periods=3)
+        dti_tz = date_range('20130101', periods=3).tz_localize('US/Eastern')
+        dti_tz2 = date_range('20130101', periods=3).tz_localize('UTC')
+        expected = TimedeltaIndex([0, 0, 0])
+
+        result = dti - dti
+        tm.assert_index_equal(result, expected)
+
+        result = dti_tz - dti_tz
+        tm.assert_index_equal(result, expected)
+
+        with pytest.raises(TypeError):
+            dti_tz - dti
+
+        with pytest.raises(TypeError):
+            dti - dti_tz
+
+        with pytest.raises(TypeError):
+            dti_tz - dti_tz2
+
+        # isub
+        dti -= dti
+        tm.assert_index_equal(dti, expected)
+
+        # different length raises ValueError
+        dti1 = date_range('20130101', periods=3)
+        dti2 = date_range('20130101', periods=4)
+        with pytest.raises(ValueError):
+            dti1 - dti2
+
+        # NaN propagation
+        dti1 = DatetimeIndex(['2012-01-01', np.nan, '2012-01-03'])
+        dti2 = DatetimeIndex(['2012-01-02', '2012-01-03', np.nan])
+        expected = TimedeltaIndex(['1 days', np.nan, np.nan])
+        result = dti2 - dti1
+        tm.assert_index_equal(result, expected)
+
+    def test_sub_period(self):
+        # GH 13078
+        # not supported, check TypeError
+        p = pd.Period('2011-01-01', freq='D')
+
+        for freq in [None, 'D']:
+            idx = pd.DatetimeIndex(['2011-01-01', '2011-01-02'], freq=freq)
+
+            with pytest.raises(TypeError):
+                idx - p
+
+            with pytest.raises(TypeError):
+                p - idx
+
+    def test_ufunc_coercions(self):
+        idx = date_range('2011-01-01', periods=3, freq='2D', name='x')
+
+        delta = np.timedelta64(1, 'D')
+        for result in [idx + delta, np.add(idx, delta)]:
+            assert isinstance(result, DatetimeIndex)
+            exp = date_range('2011-01-02', periods=3, freq='2D', name='x')
+            tm.assert_index_equal(result, exp)
+            assert result.freq == '2D'
+
+        for result in [idx - delta, np.subtract(idx, delta)]:
+            assert isinstance(result, DatetimeIndex)
+            exp = date_range('2010-12-31', periods=3, freq='2D', name='x')
+            tm.assert_index_equal(result, exp)
+            assert result.freq == '2D'
+
+        delta = np.array([np.timedelta64(1, 'D'), np.timedelta64(2, 'D'),
+                          np.timedelta64(3, 'D')])
+        for result in [idx + delta, np.add(idx, delta)]:
+            assert isinstance(result, DatetimeIndex)
+            exp = DatetimeIndex(['2011-01-02', '2011-01-05', '2011-01-08'],
+                                freq='3D', name='x')
+            tm.assert_index_equal(result, exp)
+            assert result.freq == '3D'
+
+        for result in [idx - delta, np.subtract(idx, delta)]:
+            assert isinstance(result, DatetimeIndex)
+            exp = DatetimeIndex(['2010-12-31', '2011-01-01', '2011-01-02'],
+                                freq='D', name='x')
+            tm.assert_index_equal(result, exp)
+            assert result.freq == 'D'
+
+    def test_overflow_offset(self):
+        # xref https://github.com/statsmodels/statsmodels/issues/3374
+        # ends up multiplying really large numbers which overflow
+
+        t = Timestamp('2017-01-13 00:00:00', freq='D')
+        offset = 20169940 * pd.offsets.Day(1)
+
+        def f():
+            t + offset
+        pytest.raises(OverflowError, f)
+
+        def f():
+            offset + t
+        pytest.raises(OverflowError, f)
+
+        def f():
+            t - offset
+        pytest.raises(OverflowError, f)
+
+
+# GH 10699
+@pytest.mark.parametrize('klass,assert_func', zip([Series, DatetimeIndex],
+                                                  [tm.assert_series_equal,
+                                                   tm.assert_index_equal]))
+def test_datetime64_with_DateOffset(klass, assert_func):
+    s = klass(date_range('2000-01-01', '2000-01-31'), name='a')
+    result = s + pd.DateOffset(years=1)
+    result2 = pd.DateOffset(years=1) + s
+    exp = klass(date_range('2001-01-01', '2001-01-31'), name='a')
+    assert_func(result, exp)
+    assert_func(result2, exp)
+
+    result = s - pd.DateOffset(years=1)
+    exp = klass(date_range('1999-01-01', '1999-01-31'), name='a')
+    assert_func(result, exp)
+
+    s = klass([Timestamp('2000-01-15 00:15:00', tz='US/Central'),
+               pd.Timestamp('2000-02-15', tz='US/Central')], name='a')
+    result = s + pd.offsets.Day()
+    result2 = pd.offsets.Day() + s
+    exp = klass([Timestamp('2000-01-16 00:15:00', tz='US/Central'),
+                 Timestamp('2000-02-16', tz='US/Central')], name='a')
+    assert_func(result, exp)
+    assert_func(result2, exp)
+
+    s = klass([Timestamp('2000-01-15 00:15:00', tz='US/Central'),
+               pd.Timestamp('2000-02-15', tz='US/Central')], name='a')
+    result = s + pd.offsets.MonthEnd()
+    result2 = pd.offsets.MonthEnd() + s
+    exp = klass([Timestamp('2000-01-31 00:15:00', tz='US/Central'),
+                 Timestamp('2000-02-29', tz='US/Central')], name='a')
+    assert_func(result, exp)
+    assert_func(result2, exp)
+
+    # array of offsets - valid for Series only
+    if klass is Series:
+        with tm.assert_produces_warning(PerformanceWarning):
+            s = klass([Timestamp('2000-1-1'), Timestamp('2000-2-1')])
+            result = s + Series([pd.offsets.DateOffset(years=1),
+                                 pd.offsets.MonthEnd()])
+            exp = klass([Timestamp('2001-1-1'), Timestamp('2000-2-29')
+                         ])
+            assert_func(result, exp)
+
+            # same offset
+            result = s + Series([pd.offsets.DateOffset(years=1),
+                                 pd.offsets.DateOffset(years=1)])
+            exp = klass([Timestamp('2001-1-1'), Timestamp('2001-2-1')])
+            assert_func(result, exp)
+
+    s = klass([Timestamp('2000-01-05 00:15:00'),
+               Timestamp('2000-01-31 00:23:00'),
+               Timestamp('2000-01-01'),
+               Timestamp('2000-03-31'),
+               Timestamp('2000-02-29'),
+               Timestamp('2000-12-31'),
+               Timestamp('2000-05-15'),
+               Timestamp('2001-06-15')])
+
+    # DateOffset relativedelta fastpath
+    relative_kwargs = [('years', 2), ('months', 5), ('days', 3),
+                       ('hours', 5), ('minutes', 10), ('seconds', 2),
+                       ('microseconds', 5)]
+    for i, kwd in enumerate(relative_kwargs):
+        op = pd.DateOffset(**dict([kwd]))
+        assert_func(klass([x + op for x in s]), s + op)
+        assert_func(klass([x - op for x in s]), s - op)
+        op = pd.DateOffset(**dict(relative_kwargs[:i + 1]))
+        assert_func(klass([x + op for x in s]), s + op)
+        assert_func(klass([x - op for x in s]), s - op)
+
+    # assert these are equal on a piecewise basis
+    offsets = ['YearBegin', ('YearBegin', {'month': 5}),
+               'YearEnd', ('YearEnd', {'month': 5}),
+               'MonthBegin', 'MonthEnd',
+               'SemiMonthEnd', 'SemiMonthBegin',
+               'Week', ('Week', {'weekday': 3}),
+               'BusinessDay', 'BDay', 'QuarterEnd', 'QuarterBegin',
+               'CustomBusinessDay', 'CDay', 'CBMonthEnd',
+               'CBMonthBegin', 'BMonthBegin', 'BMonthEnd',
+               'BusinessHour', 'BYearBegin', 'BYearEnd',
+               'BQuarterBegin', ('LastWeekOfMonth', {'weekday': 2}),
+               ('FY5253Quarter', {'qtr_with_extra_week': 1,
+                                  'startingMonth': 1,
+                                  'weekday': 2,
+                                  'variation': 'nearest'}),
+               ('FY5253', {'weekday': 0,
+                           'startingMonth': 2,
+                           'variation':
+                           'nearest'}),
+               ('WeekOfMonth', {'weekday': 2,
+                                'week': 2}),
+               'Easter', ('DateOffset', {'day': 4}),
+               ('DateOffset', {'month': 5})]
+
+    with warnings.catch_warnings(record=True):
+        for normalize in (True, False):
+            for do in offsets:
+                if isinstance(do, tuple):
+                    do, kwargs = do
+                else:
+                    do = do
+                    kwargs = {}
+
+                    for n in [0, 5]:
+                        if (do in ['WeekOfMonth', 'LastWeekOfMonth',
+                                   'FY5253Quarter', 'FY5253'] and n == 0):
+                            continue
+                    op = getattr(pd.offsets, do)(n,
+                                                 normalize=normalize,
+                                                 **kwargs)
+                    assert_func(klass([x + op for x in s]), s + op)
+                    assert_func(klass([x - op for x in s]), s - op)
+                    assert_func(klass([op + x for x in s]), op + s)
diff --git a/pandas/tests/indexes/datetimes/test_datetime.py b/pandas/tests/indexes/datetimes/test_datetime.py
index 8d9ac59cf..88bf8a402 100644
--- a/pandas/tests/indexes/datetimes/test_datetime.py
+++ b/pandas/tests/indexes/datetimes/test_datetime.py
@@ -179,38 +179,6 @@ class TestDatetimeIndex(object):
     def test_nat(self):
         assert DatetimeIndex([np.nan])[0] is pd.NaT
 
-    def test_ufunc_coercions(self):
-        idx = date_range('2011-01-01', periods=3, freq='2D', name='x')
-
-        delta = np.timedelta64(1, 'D')
-        for result in [idx + delta, np.add(idx, delta)]:
-            assert isinstance(result, DatetimeIndex)
-            exp = date_range('2011-01-02', periods=3, freq='2D', name='x')
-            tm.assert_index_equal(result, exp)
-            assert result.freq == '2D'
-
-        for result in [idx - delta, np.subtract(idx, delta)]:
-            assert isinstance(result, DatetimeIndex)
-            exp = date_range('2010-12-31', periods=3, freq='2D', name='x')
-            tm.assert_index_equal(result, exp)
-            assert result.freq == '2D'
-
-        delta = np.array([np.timedelta64(1, 'D'), np.timedelta64(2, 'D'),
-                          np.timedelta64(3, 'D')])
-        for result in [idx + delta, np.add(idx, delta)]:
-            assert isinstance(result, DatetimeIndex)
-            exp = DatetimeIndex(['2011-01-02', '2011-01-05', '2011-01-08'],
-                                freq='3D', name='x')
-            tm.assert_index_equal(result, exp)
-            assert result.freq == '3D'
-
-        for result in [idx - delta, np.subtract(idx, delta)]:
-            assert isinstance(result, DatetimeIndex)
-            exp = DatetimeIndex(['2010-12-31', '2011-01-01', '2011-01-02'],
-                                freq='D', name='x')
-            tm.assert_index_equal(result, exp)
-            assert result.freq == 'D'
-
     def test_week_of_month_frequency(self):
         # GH 5348: "ValueError: Could not evaluate WOM-1SUN" shouldn't raise
         d1 = date(2002, 9, 1)
@@ -428,25 +396,6 @@ class TestDatetimeIndex(object):
         result = df.T['1/3/2000']
         assert result.name == df.index[2]
 
-    def test_overflow_offset(self):
-        # xref https://github.com/statsmodels/statsmodels/issues/3374
-        # ends up multiplying really large numbers which overflow
-
-        t = Timestamp('2017-01-13 00:00:00', freq='D')
-        offset = 20169940 * pd.offsets.Day(1)
-
-        def f():
-            t + offset
-        pytest.raises(OverflowError, f)
-
-        def f():
-            offset + t
-        pytest.raises(OverflowError, f)
-
-        def f():
-            t - offset
-        pytest.raises(OverflowError, f)
-
     def test_get_duplicates(self):
         idx = DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-02',
                              '2000-01-03', '2000-01-03', '2000-01-04'])
diff --git a/pandas/tests/indexes/datetimes/test_ops.py b/pandas/tests/indexes/datetimes/test_ops.py
index b65d467db..14217ae29 100644
--- a/pandas/tests/indexes/datetimes/test_ops.py
+++ b/pandas/tests/indexes/datetimes/test_ops.py
@@ -3,15 +3,14 @@ import pytest
 import dateutil
 import warnings
 import numpy as np
-from datetime import timedelta, datetime
+from datetime import datetime
 
 from itertools import product
 import pandas as pd
 import pandas._libs.tslib as tslib
 import pandas.util.testing as tm
-from pandas.errors import PerformanceWarning
-from pandas import (DatetimeIndex, PeriodIndex, Series, Timestamp, Timedelta,
-                    date_range, TimedeltaIndex, _np_version_under1p10, Index,
+from pandas import (DatetimeIndex, PeriodIndex, Series, Timestamp,
+                    date_range, _np_version_under1p10, Index,
                     bdate_range)
 from pandas.tseries.offsets import BMonthEnd, CDay, BDay
 from pandas.tests.test_base import Ops
@@ -303,31 +302,31 @@ class TestDatetimeIndexOps(Ops):
 
         exp1 = """Series([], dtype: datetime64[ns])"""
 
-        exp2 = """0   2011-01-01
-dtype: datetime64[ns]"""
+        exp2 = ("0   2011-01-01\n"
+                "dtype: datetime64[ns]")
 
-        exp3 = """0   2011-01-01
-1   2011-01-02
-dtype: datetime64[ns]"""
+        exp3 = ("0   2011-01-01\n"
+                "1   2011-01-02\n"
+                "dtype: datetime64[ns]")
 
-        exp4 = """0   2011-01-01
-1   2011-01-02
-2   2011-01-03
-dtype: datetime64[ns]"""
+        exp4 = ("0   2011-01-01\n"
+                "1   2011-01-02\n"
+                "2   2011-01-03\n"
+                "dtype: datetime64[ns]")
 
-        exp5 = """0   2011-01-01 09:00:00+09:00
-1   2011-01-01 10:00:00+09:00
-2   2011-01-01 11:00:00+09:00
-dtype: datetime64[ns, Asia/Tokyo]"""
+        exp5 = ("0   2011-01-01 09:00:00+09:00\n"
+                "1   2011-01-01 10:00:00+09:00\n"
+                "2   2011-01-01 11:00:00+09:00\n"
+                "dtype: datetime64[ns, Asia/Tokyo]")
 
-        exp6 = """0   2011-01-01 09:00:00-05:00
-1   2011-01-01 10:00:00-05:00
-2                         NaT
-dtype: datetime64[ns, US/Eastern]"""
+        exp6 = ("0   2011-01-01 09:00:00-05:00\n"
+                "1   2011-01-01 10:00:00-05:00\n"
+                "2                         NaT\n"
+                "dtype: datetime64[ns, US/Eastern]")
 
-        exp7 = """0   2011-01-01 09:00:00
-1   2011-01-02 10:15:00
-dtype: datetime64[ns]"""
+        exp7 = ("0   2011-01-01 09:00:00\n"
+                "1   2011-01-02 10:15:00\n"
+                "dtype: datetime64[ns]")
 
         with pd.option_context('display.width', 300):
             for idx, expected in zip([idx1, idx2, idx3, idx4,
@@ -350,17 +349,17 @@ dtype: datetime64[ns]"""
         idx6 = DatetimeIndex(['2011-01-01 09:00', '2011-01-01 10:00', pd.NaT],
                              tz='US/Eastern')
 
-        exp1 = """DatetimeIndex: 0 entries
-Freq: D"""
+        exp1 = ("DatetimeIndex: 0 entries\n"
+                "Freq: D")
 
-        exp2 = """DatetimeIndex: 1 entries, 2011-01-01 to 2011-01-01
-Freq: D"""
+        exp2 = ("DatetimeIndex: 1 entries, 2011-01-01 to 2011-01-01\n"
+                "Freq: D")
 
-        exp3 = """DatetimeIndex: 2 entries, 2011-01-01 to 2011-01-02
-Freq: D"""
+        exp3 = ("DatetimeIndex: 2 entries, 2011-01-01 to 2011-01-02\n"
+                "Freq: D")
 
-        exp4 = """DatetimeIndex: 3 entries, 2011-01-01 to 2011-01-03
-Freq: D"""
+        exp4 = ("DatetimeIndex: 3 entries, 2011-01-01 to 2011-01-03\n"
+                "Freq: D")
 
         exp5 = ("DatetimeIndex: 3 entries, 2011-01-01 09:00:00+09:00 "
                 "to 2011-01-01 11:00:00+09:00\n"
@@ -406,79 +405,6 @@ Freq: D"""
                 result_union = rng.union(other)
                 tm.assert_index_equal(result_union, expected)
 
-    def test_add_iadd(self):
-        for tz in self.tz:
-
-            # offset
-            offsets = [pd.offsets.Hour(2), timedelta(hours=2),
-                       np.timedelta64(2, 'h'), Timedelta(hours=2)]
-
-            for delta in offsets:
-                rng = pd.date_range('2000-01-01', '2000-02-01', tz=tz)
-                result = rng + delta
-                expected = pd.date_range('2000-01-01 02:00',
-                                         '2000-02-01 02:00', tz=tz)
-                tm.assert_index_equal(result, expected)
-                rng += delta
-                tm.assert_index_equal(rng, expected)
-
-            # int
-            rng = pd.date_range('2000-01-01 09:00', freq='H', periods=10,
-                                tz=tz)
-            result = rng + 1
-            expected = pd.date_range('2000-01-01 10:00', freq='H', periods=10,
-                                     tz=tz)
-            tm.assert_index_equal(result, expected)
-            rng += 1
-            tm.assert_index_equal(rng, expected)
-
-        idx = DatetimeIndex(['2011-01-01', '2011-01-02'])
-        msg = "cannot add DatetimeIndex and Timestamp"
-        with tm.assert_raises_regex(TypeError, msg):
-            idx + Timestamp('2011-01-01')
-
-        with tm.assert_raises_regex(TypeError, msg):
-            Timestamp('2011-01-01') + idx
-
-    @pytest.mark.parametrize('addend', [
-        datetime(2011, 1, 1),
-        DatetimeIndex(['2011-01-01', '2011-01-02']),
-        DatetimeIndex(['2011-01-01', '2011-01-02'])
-                .tz_localize('US/Eastern'),
-        np.datetime64('2011-01-01'),
-        Timestamp('2011-01-01'),
-    ])
-    def test_add_datetimelike_and_dti(self, addend):
-        # issue #9631
-
-        dti = DatetimeIndex(['2011-01-01', '2011-01-02'])
-        msg = 'cannot add DatetimeIndex and {0}'.format(
-            type(addend).__name__)
-        with tm.assert_raises_regex(TypeError, msg):
-            dti + addend
-        with tm.assert_raises_regex(TypeError, msg):
-            addend + dti
-
-    @pytest.mark.parametrize('addend', [
-        datetime(2011, 1, 1),
-        DatetimeIndex(['2011-01-01', '2011-01-02']),
-        DatetimeIndex(['2011-01-01', '2011-01-02'])
-                .tz_localize('US/Eastern'),
-        np.datetime64('2011-01-01'),
-        Timestamp('2011-01-01'),
-    ])
-    def test_add_datetimelike_and_dti_tz(self, addend):
-        # issue #9631
-
-        dti_tz = DatetimeIndex(['2011-01-01', '2011-01-02']) \
-            .tz_localize('US/Eastern')
-        msg = 'cannot add DatetimeIndex and {0}'.format(
-            type(addend).__name__)
-        with tm.assert_raises_regex(TypeError, msg):
-            dti_tz + addend
-        with tm.assert_raises_regex(TypeError, msg):
-            addend + dti_tz
-
     def test_difference(self):
         for tz in self.tz:
             # diff
@@ -500,88 +426,6 @@ Freq: D"""
                 result_diff = rng.difference(other)
                 tm.assert_index_equal(result_diff, expected)
 
-    def test_sub_isub(self):
-        for tz in self.tz:
-
-            # offset
-            offsets = [pd.offsets.Hour(2), timedelta(hours=2),
-                       np.timedelta64(2, 'h'), Timedelta(hours=2)]
-
-            for delta in offsets:
-                rng = pd.date_range('2000-01-01', '2000-02-01', tz=tz)
-                expected = pd.date_range('1999-12-31 22:00',
-                                         '2000-01-31 22:00', tz=tz)
-
-                result = rng - delta
-                tm.assert_index_equal(result, expected)
-                rng -= delta
-                tm.assert_index_equal(rng, expected)
-
-            # int
-            rng = pd.date_range('2000-01-01 09:00', freq='H', periods=10,
-                                tz=tz)
-            result = rng - 1
-            expected = pd.date_range('2000-01-01 08:00', freq='H', periods=10,
-                                     tz=tz)
-            tm.assert_index_equal(result, expected)
-            rng -= 1
-            tm.assert_index_equal(rng, expected)
-
-    def test_sub_dti_dti(self):
-        # previously performed setop (deprecated in 0.16.0), now changed to
-        # return subtraction -> TimeDeltaIndex (GH ...)
-
-        dti = date_range('20130101', periods=3)
-        dti_tz = date_range('20130101', periods=3).tz_localize('US/Eastern')
-        dti_tz2 = date_range('20130101', periods=3).tz_localize('UTC')
-        expected = TimedeltaIndex([0, 0, 0])
-
-        result = dti - dti
-        tm.assert_index_equal(result, expected)
-
-        result = dti_tz - dti_tz
-        tm.assert_index_equal(result, expected)
-
-        with pytest.raises(TypeError):
-            dti_tz - dti
-
-        with pytest.raises(TypeError):
-            dti - dti_tz
-
-        with pytest.raises(TypeError):
-            dti_tz - dti_tz2
-
-        # isub
-        dti -= dti
-        tm.assert_index_equal(dti, expected)
-
-        # different length raises ValueError
-        dti1 = date_range('20130101', periods=3)
-        dti2 = date_range('20130101', periods=4)
-        with pytest.raises(ValueError):
-            dti1 - dti2
-
-        # NaN propagation
-        dti1 = DatetimeIndex(['2012-01-01', np.nan, '2012-01-03'])
-        dti2 = DatetimeIndex(['2012-01-02', '2012-01-03', np.nan])
-        expected = TimedeltaIndex(['1 days', np.nan, np.nan])
-        result = dti2 - dti1
-        tm.assert_index_equal(result, expected)
-
-    def test_sub_period(self):
-        # GH 13078
-        # not supported, check TypeError
-        p = pd.Period('2011-01-01', freq='D')
-
-        for freq in [None, 'D']:
-            idx = pd.DatetimeIndex(['2011-01-01', '2011-01-02'], freq=freq)
-
-            with pytest.raises(TypeError):
-                idx - p
-
-            with pytest.raises(TypeError):
-                p - idx
-
     def test_comp_nat(self):
         left = pd.DatetimeIndex([pd.Timestamp('2011-01-01'), pd.NaT,
                                  pd.Timestamp('2011-01-03')])
@@ -952,122 +796,6 @@ Freq: D"""
             assert not idx.equals(pd.Series(idx3))
 
 
-# GH 10699
-@pytest.mark.parametrize('klass,assert_func', zip([Series, DatetimeIndex],
-                                                  [tm.assert_series_equal,
-                                                   tm.assert_index_equal]))
-def test_datetime64_with_DateOffset(klass, assert_func):
-    s = klass(date_range('2000-01-01', '2000-01-31'), name='a')
-    result = s + pd.DateOffset(years=1)
-    result2 = pd.DateOffset(years=1) + s
-    exp = klass(date_range('2001-01-01', '2001-01-31'), name='a')
-    assert_func(result, exp)
-    assert_func(result2, exp)
-
-    result = s - pd.DateOffset(years=1)
-    exp = klass(date_range('1999-01-01', '1999-01-31'), name='a')
-    assert_func(result, exp)
-
-    s = klass([Timestamp('2000-01-15 00:15:00', tz='US/Central'),
-               pd.Timestamp('2000-02-15', tz='US/Central')], name='a')
-    result = s + pd.offsets.Day()
-    result2 = pd.offsets.Day() + s
-    exp = klass([Timestamp('2000-01-16 00:15:00', tz='US/Central'),
-                 Timestamp('2000-02-16', tz='US/Central')], name='a')
-    assert_func(result, exp)
-    assert_func(result2, exp)
-
-    s = klass([Timestamp('2000-01-15 00:15:00', tz='US/Central'),
-               pd.Timestamp('2000-02-15', tz='US/Central')], name='a')
-    result = s + pd.offsets.MonthEnd()
-    result2 = pd.offsets.MonthEnd() + s
-    exp = klass([Timestamp('2000-01-31 00:15:00', tz='US/Central'),
-                 Timestamp('2000-02-29', tz='US/Central')], name='a')
-    assert_func(result, exp)
-    assert_func(result2, exp)
-
-    # array of offsets - valid for Series only
-    if klass is Series:
-        with tm.assert_produces_warning(PerformanceWarning):
-            s = klass([Timestamp('2000-1-1'), Timestamp('2000-2-1')])
-            result = s + Series([pd.offsets.DateOffset(years=1),
-                                 pd.offsets.MonthEnd()])
-            exp = klass([Timestamp('2001-1-1'), Timestamp('2000-2-29')
-                         ])
-            assert_func(result, exp)
-
-            # same offset
-            result = s + Series([pd.offsets.DateOffset(years=1),
-                                 pd.offsets.DateOffset(years=1)])
-            exp = klass([Timestamp('2001-1-1'), Timestamp('2001-2-1')])
-            assert_func(result, exp)
-
-    s = klass([Timestamp('2000-01-05 00:15:00'),
-               Timestamp('2000-01-31 00:23:00'),
-               Timestamp('2000-01-01'),
-               Timestamp('2000-03-31'),
-               Timestamp('2000-02-29'),
-               Timestamp('2000-12-31'),
-               Timestamp('2000-05-15'),
-               Timestamp('2001-06-15')])
-
-    # DateOffset relativedelta fastpath
-    relative_kwargs = [('years', 2), ('months', 5), ('days', 3),
-                       ('hours', 5), ('minutes', 10), ('seconds', 2),
-                       ('microseconds', 5)]
-    for i, kwd in enumerate(relative_kwargs):
-        op = pd.DateOffset(**dict([kwd]))
-        assert_func(klass([x + op for x in s]), s + op)
-        assert_func(klass([x - op for x in s]), s - op)
-        op = pd.DateOffset(**dict(relative_kwargs[:i + 1]))
-        assert_func(klass([x + op for x in s]), s + op)
-        assert_func(klass([x - op for x in s]), s - op)
-
-    # assert these are equal on a piecewise basis
-    offsets = ['YearBegin', ('YearBegin', {'month': 5}),
-               'YearEnd', ('YearEnd', {'month': 5}),
-               'MonthBegin', 'MonthEnd',
-               'SemiMonthEnd', 'SemiMonthBegin',
-               'Week', ('Week', {'weekday': 3}),
-               'BusinessDay', 'BDay', 'QuarterEnd', 'QuarterBegin',
-               'CustomBusinessDay', 'CDay', 'CBMonthEnd',
-               'CBMonthBegin', 'BMonthBegin', 'BMonthEnd',
-               'BusinessHour', 'BYearBegin', 'BYearEnd',
-               'BQuarterBegin', ('LastWeekOfMonth', {'weekday': 2}),
-               ('FY5253Quarter', {'qtr_with_extra_week': 1,
-                                  'startingMonth': 1,
-                                  'weekday': 2,
-                                  'variation': 'nearest'}),
-               ('FY5253', {'weekday': 0,
-                           'startingMonth': 2,
-                           'variation':
-                           'nearest'}),
-               ('WeekOfMonth', {'weekday': 2,
-                                'week': 2}),
-               'Easter', ('DateOffset', {'day': 4}),
-               ('DateOffset', {'month': 5})]
-
-    with warnings.catch_warnings(record=True):
-        for normalize in (True, False):
-            for do in offsets:
-                if isinstance(do, tuple):
-                    do, kwargs = do
-                else:
-                    do = do
-                    kwargs = {}
-
-                    for n in [0, 5]:
-                        if (do in ['WeekOfMonth', 'LastWeekOfMonth',
-                                   'FY5253Quarter', 'FY5253'] and n == 0):
-                            continue
-                    op = getattr(pd.offsets, do)(n,
-                                                 normalize=normalize,
-                                                 **kwargs)
-                    assert_func(klass([x + op for x in s]), s + op)
-                    assert_func(klass([x - op for x in s]), s - op)
-                    assert_func(klass([op + x for x in s]), op + s)
-
-
 @pytest.mark.parametrize('years,months', product([-1, 0, 1], [-2, 0, 2]))
 def test_shift_months(years, months):
     s = DatetimeIndex([Timestamp('2000-01-05 00:15:00'),
diff --git a/pandas/tests/indexes/period/test_arithmetic.py b/pandas/tests/indexes/period/test_arithmetic.py
new file mode 100644
index 000000000..66aa5d2db
--- /dev/null
+++ b/pandas/tests/indexes/period/test_arithmetic.py
@@ -0,0 +1,435 @@
+# -*- coding: utf-8 -*-
+from datetime import timedelta
+import pytest
+import numpy as np
+
+import pandas as pd
+import pandas.util.testing as tm
+from pandas import (Timedelta,
+                    period_range, Period, PeriodIndex,
+                    _np_version_under1p10)
+import pandas.core.indexes.period as period
+
+
+class TestPeriodIndexArithmetic(object):
+    def test_add_iadd(self):
+        rng = pd.period_range('1/1/2000', freq='D', periods=5)
+        other = pd.period_range('1/6/2000', freq='D', periods=5)
+
+        # previously performed setop union, now raises TypeError (GH14164)
+        with pytest.raises(TypeError):
+            rng + other
+
+        with pytest.raises(TypeError):
+            rng += other
+
+        # offset
+        # DateOffset
+        rng = pd.period_range('2014', '2024', freq='A')
+        result = rng + pd.offsets.YearEnd(5)
+        expected = pd.period_range('2019', '2029', freq='A')
+        tm.assert_index_equal(result, expected)
+        rng += pd.offsets.YearEnd(5)
+        tm.assert_index_equal(rng, expected)
+
+        for o in [pd.offsets.YearBegin(2), pd.offsets.MonthBegin(1),
+                  pd.offsets.Minute(), np.timedelta64(365, 'D'),
+                  timedelta(365), Timedelta(days=365)]:
+            msg = ('Input has different freq(=.+)? '
+                   'from PeriodIndex\\(freq=A-DEC\\)')
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                rng + o
+
+        rng = pd.period_range('2014-01', '2016-12', freq='M')
+        result = rng + pd.offsets.MonthEnd(5)
+        expected = pd.period_range('2014-06', '2017-05', freq='M')
+        tm.assert_index_equal(result, expected)
+        rng += pd.offsets.MonthEnd(5)
+        tm.assert_index_equal(rng, expected)
+
+        for o in [pd.offsets.YearBegin(2), pd.offsets.MonthBegin(1),
+                  pd.offsets.Minute(), np.timedelta64(365, 'D'),
+                  timedelta(365), Timedelta(days=365)]:
+            rng = pd.period_range('2014-01', '2016-12', freq='M')
+            msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=M\\)'
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                rng + o
+
+        # Tick
+        offsets = [pd.offsets.Day(3), timedelta(days=3),
+                   np.timedelta64(3, 'D'), pd.offsets.Hour(72),
+                   timedelta(minutes=60 * 24 * 3), np.timedelta64(72, 'h'),
+                   Timedelta('72:00:00')]
+        for delta in offsets:
+            rng = pd.period_range('2014-05-01', '2014-05-15', freq='D')
+            result = rng + delta
+            expected = pd.period_range('2014-05-04', '2014-05-18', freq='D')
+            tm.assert_index_equal(result, expected)
+            rng += delta
+            tm.assert_index_equal(rng, expected)
+
+        for o in [pd.offsets.YearBegin(2), pd.offsets.MonthBegin(1),
+                  pd.offsets.Minute(), np.timedelta64(4, 'h'),
+                  timedelta(hours=23), Timedelta('23:00:00')]:
+            rng = pd.period_range('2014-05-01', '2014-05-15', freq='D')
+            msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=D\\)'
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                rng + o
+
+        offsets = [pd.offsets.Hour(2), timedelta(hours=2),
+                   np.timedelta64(2, 'h'), pd.offsets.Minute(120),
+                   timedelta(minutes=120), np.timedelta64(120, 'm'),
+                   Timedelta(minutes=120)]
+        for delta in offsets:
+            rng = pd.period_range('2014-01-01 10:00', '2014-01-05 10:00',
+                                  freq='H')
+            result = rng + delta
+            expected = pd.period_range('2014-01-01 12:00', '2014-01-05 12:00',
+                                       freq='H')
+            tm.assert_index_equal(result, expected)
+            rng += delta
+            tm.assert_index_equal(rng, expected)
+
+        for delta in [pd.offsets.YearBegin(2), timedelta(minutes=30),
+                      np.timedelta64(30, 's'), Timedelta(seconds=30)]:
+            rng = pd.period_range('2014-01-01 10:00', '2014-01-05 10:00',
+                                  freq='H')
+            msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=H\\)'
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                rng + delta
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                rng += delta
+
+        # int
+        rng = pd.period_range('2000-01-01 09:00', freq='H', periods=10)
+        result = rng + 1
+        expected = pd.period_range('2000-01-01 10:00', freq='H', periods=10)
+        tm.assert_index_equal(result, expected)
+        rng += 1
+        tm.assert_index_equal(rng, expected)
+
+    def test_sub(self):
+        rng = period_range('2007-01', periods=50)
+
+        result = rng - 5
+        exp = rng + (-5)
+        tm.assert_index_equal(result, exp)
+
+    def test_sub_isub(self):
+
+        # previously performed setop, now raises TypeError (GH14164)
+        # TODO needs to wait on #13077 for decision on result type
+        rng = pd.period_range('1/1/2000', freq='D', periods=5)
+        other = pd.period_range('1/6/2000', freq='D', periods=5)
+
+        with pytest.raises(TypeError):
+            rng - other
+
+        with pytest.raises(TypeError):
+            rng -= other
+
+        # offset
+        # DateOffset
+        rng = pd.period_range('2014', '2024', freq='A')
+        result = rng - pd.offsets.YearEnd(5)
+        expected = pd.period_range('2009', '2019', freq='A')
+        tm.assert_index_equal(result, expected)
+        rng -= pd.offsets.YearEnd(5)
+        tm.assert_index_equal(rng, expected)
+
+        for o in [pd.offsets.YearBegin(2), pd.offsets.MonthBegin(1),
+                  pd.offsets.Minute(), np.timedelta64(365, 'D'),
+                  timedelta(365)]:
+            rng = pd.period_range('2014', '2024', freq='A')
+            msg = ('Input has different freq(=.+)? '
+                   'from PeriodIndex\\(freq=A-DEC\\)')
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                rng - o
+
+        rng = pd.period_range('2014-01', '2016-12', freq='M')
+        result = rng - pd.offsets.MonthEnd(5)
+        expected = pd.period_range('2013-08', '2016-07', freq='M')
+        tm.assert_index_equal(result, expected)
+        rng -= pd.offsets.MonthEnd(5)
+        tm.assert_index_equal(rng, expected)
+
+        for o in [pd.offsets.YearBegin(2), pd.offsets.MonthBegin(1),
+                  pd.offsets.Minute(), np.timedelta64(365, 'D'),
+                  timedelta(365)]:
+            rng = pd.period_range('2014-01', '2016-12', freq='M')
+            msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=M\\)'
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                rng - o
+
+        # Tick
+        offsets = [pd.offsets.Day(3), timedelta(days=3),
+                   np.timedelta64(3, 'D'), pd.offsets.Hour(72),
+                   timedelta(minutes=60 * 24 * 3), np.timedelta64(72, 'h')]
+        for delta in offsets:
+            rng = pd.period_range('2014-05-01', '2014-05-15', freq='D')
+            result = rng - delta
+            expected = pd.period_range('2014-04-28', '2014-05-12', freq='D')
+            tm.assert_index_equal(result, expected)
+            rng -= delta
+            tm.assert_index_equal(rng, expected)
+
+        for o in [pd.offsets.YearBegin(2), pd.offsets.MonthBegin(1),
+                  pd.offsets.Minute(), np.timedelta64(4, 'h'),
+                  timedelta(hours=23)]:
+            rng = pd.period_range('2014-05-01', '2014-05-15', freq='D')
+            msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=D\\)'
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                rng - o
+
+        offsets = [pd.offsets.Hour(2), timedelta(hours=2),
+                   np.timedelta64(2, 'h'), pd.offsets.Minute(120),
+                   timedelta(minutes=120), np.timedelta64(120, 'm')]
+        for delta in offsets:
+            rng = pd.period_range('2014-01-01 10:00', '2014-01-05 10:00',
+                                  freq='H')
+            result = rng - delta
+            expected = pd.period_range('2014-01-01 08:00', '2014-01-05 08:00',
+                                       freq='H')
+            tm.assert_index_equal(result, expected)
+            rng -= delta
+            tm.assert_index_equal(rng, expected)
+
+        for delta in [pd.offsets.YearBegin(2), timedelta(minutes=30),
+                      np.timedelta64(30, 's')]:
+            rng = pd.period_range('2014-01-01 10:00', '2014-01-05 10:00',
+                                  freq='H')
+            msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=H\\)'
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                rng + delta
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                rng += delta
+
+        # int
+        rng = pd.period_range('2000-01-01 09:00', freq='H', periods=10)
+        result = rng - 1
+        expected = pd.period_range('2000-01-01 08:00', freq='H', periods=10)
+        tm.assert_index_equal(result, expected)
+        rng -= 1
+        tm.assert_index_equal(rng, expected)
+
+
+class TestPeriodIndexSeriesMethods(object):
+    """ Test PeriodIndex and Period Series Ops consistency """
+
+    def _check(self, values, func, expected):
+        idx = pd.PeriodIndex(values)
+        result = func(idx)
+        if isinstance(expected, pd.Index):
+            tm.assert_index_equal(result, expected)
+        else:
+            # comp op results in bool
+            tm.assert_numpy_array_equal(result, expected)
+
+        s = pd.Series(values)
+        result = func(s)
+
+        exp = pd.Series(expected, name=values.name)
+        tm.assert_series_equal(result, exp)
+
+    def test_pi_ops(self):
+        idx = PeriodIndex(['2011-01', '2011-02', '2011-03',
+                           '2011-04'], freq='M', name='idx')
+
+        expected = PeriodIndex(['2011-03', '2011-04',
+                                '2011-05', '2011-06'], freq='M', name='idx')
+        self._check(idx, lambda x: x + 2, expected)
+        self._check(idx, lambda x: 2 + x, expected)
+
+        self._check(idx + 2, lambda x: x - 2, idx)
+        result = idx - Period('2011-01', freq='M')
+        exp = pd.Index([0, 1, 2, 3], name='idx')
+        tm.assert_index_equal(result, exp)
+
+        result = Period('2011-01', freq='M') - idx
+        exp = pd.Index([0, -1, -2, -3], name='idx')
+        tm.assert_index_equal(result, exp)
+
+    def test_pi_ops_errors(self):
+        idx = PeriodIndex(['2011-01', '2011-02', '2011-03',
+                           '2011-04'], freq='M', name='idx')
+        s = pd.Series(idx)
+
+        msg = r"unsupported operand type\(s\)"
+
+        for obj in [idx, s]:
+            for ng in ["str", 1.5]:
+                with tm.assert_raises_regex(TypeError, msg):
+                    obj + ng
+
+                with pytest.raises(TypeError):
+                    # error message differs between PY2 and 3
+                    ng + obj
+
+                with tm.assert_raises_regex(TypeError, msg):
+                    obj - ng
+
+                with pytest.raises(TypeError):
+                    np.add(obj, ng)
+
+                if _np_version_under1p10:
+                    assert np.add(ng, obj) is NotImplemented
+                else:
+                    with pytest.raises(TypeError):
+                        np.add(ng, obj)
+
+                with pytest.raises(TypeError):
+                    np.subtract(obj, ng)
+
+                if _np_version_under1p10:
+                    assert np.subtract(ng, obj) is NotImplemented
+                else:
+                    with pytest.raises(TypeError):
+                        np.subtract(ng, obj)
+
+    def test_pi_ops_nat(self):
+        idx = PeriodIndex(['2011-01', '2011-02', 'NaT',
+                           '2011-04'], freq='M', name='idx')
+        expected = PeriodIndex(['2011-03', '2011-04',
+                                'NaT', '2011-06'], freq='M', name='idx')
+        self._check(idx, lambda x: x + 2, expected)
+        self._check(idx, lambda x: 2 + x, expected)
+        self._check(idx, lambda x: np.add(x, 2), expected)
+
+        self._check(idx + 2, lambda x: x - 2, idx)
+        self._check(idx + 2, lambda x: np.subtract(x, 2), idx)
+
+        # freq with mult
+        idx = PeriodIndex(['2011-01', '2011-02', 'NaT',
+                           '2011-04'], freq='2M', name='idx')
+        expected = PeriodIndex(['2011-07', '2011-08',
+                                'NaT', '2011-10'], freq='2M', name='idx')
+        self._check(idx, lambda x: x + 3, expected)
+        self._check(idx, lambda x: 3 + x, expected)
+        self._check(idx, lambda x: np.add(x, 3), expected)
+
+        self._check(idx + 3, lambda x: x - 3, idx)
+        self._check(idx + 3, lambda x: np.subtract(x, 3), idx)
+
+    def test_pi_ops_array_int(self):
+        idx = PeriodIndex(['2011-01', '2011-02', 'NaT',
+                           '2011-04'], freq='M', name='idx')
+        f = lambda x: x + np.array([1, 2, 3, 4])
+        exp = PeriodIndex(['2011-02', '2011-04', 'NaT',
+                           '2011-08'], freq='M', name='idx')
+        self._check(idx, f, exp)
+
+        f = lambda x: np.add(x, np.array([4, -1, 1, 2]))
+        exp = PeriodIndex(['2011-05', '2011-01', 'NaT',
+                           '2011-06'], freq='M', name='idx')
+        self._check(idx, f, exp)
+
+        f = lambda x: x - np.array([1, 2, 3, 4])
+        exp = PeriodIndex(['2010-12', '2010-12', 'NaT',
+                           '2010-12'], freq='M', name='idx')
+        self._check(idx, f, exp)
+
+        f = lambda x: np.subtract(x, np.array([3, 2, 3, -2]))
+        exp = PeriodIndex(['2010-10', '2010-12', 'NaT',
+                           '2011-06'], freq='M', name='idx')
+        self._check(idx, f, exp)
+
+    def test_pi_ops_offset(self):
+        idx = PeriodIndex(['2011-01-01', '2011-02-01', '2011-03-01',
+                           '2011-04-01'], freq='D', name='idx')
+        f = lambda x: x + pd.offsets.Day()
+        exp = PeriodIndex(['2011-01-02', '2011-02-02', '2011-03-02',
+                           '2011-04-02'], freq='D', name='idx')
+        self._check(idx, f, exp)
+
+        f = lambda x: x + pd.offsets.Day(2)
+        exp = PeriodIndex(['2011-01-03', '2011-02-03', '2011-03-03',
+                           '2011-04-03'], freq='D', name='idx')
+        self._check(idx, f, exp)
+
+        f = lambda x: x - pd.offsets.Day(2)
+        exp = PeriodIndex(['2010-12-30', '2011-01-30', '2011-02-27',
+                           '2011-03-30'], freq='D', name='idx')
+        self._check(idx, f, exp)
+
+    def test_pi_offset_errors(self):
+        idx = PeriodIndex(['2011-01-01', '2011-02-01', '2011-03-01',
+                           '2011-04-01'], freq='D', name='idx')
+        s = pd.Series(idx)
+
+        # Series op is applied per Period instance, thus error is raised
+        # from Period
+        msg_idx = r"Input has different freq from PeriodIndex\(freq=D\)"
+        msg_s = r"Input cannot be converted to Period\(freq=D\)"
+        for obj, msg in [(idx, msg_idx), (s, msg_s)]:
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                obj + pd.offsets.Hour(2)
+
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                pd.offsets.Hour(2) + obj
+
+            with tm.assert_raises_regex(
+                    period.IncompatibleFrequency, msg):
+                obj - pd.offsets.Hour(2)
+
+    def test_pi_sub_period(self):
+        # GH 13071
+        idx = PeriodIndex(['2011-01', '2011-02', '2011-03',
+                           '2011-04'], freq='M', name='idx')
+
+        result = idx - pd.Period('2012-01', freq='M')
+        exp = pd.Index([-12, -11, -10, -9], name='idx')
+        tm.assert_index_equal(result, exp)
+
+        result = np.subtract(idx, pd.Period('2012-01', freq='M'))
+        tm.assert_index_equal(result, exp)
+
+        result = pd.Period('2012-01', freq='M') - idx
+        exp = pd.Index([12, 11, 10, 9], name='idx')
+        tm.assert_index_equal(result, exp)
+
+        result = np.subtract(pd.Period('2012-01', freq='M'), idx)
+        if _np_version_under1p10:
+            assert result is NotImplemented
+        else:
+            tm.assert_index_equal(result, exp)
+
+        exp = pd.TimedeltaIndex([np.nan, np.nan, np.nan, np.nan], name='idx')
+        tm.assert_index_equal(idx - pd.Period('NaT', freq='M'), exp)
+        tm.assert_index_equal(pd.Period('NaT', freq='M') - idx, exp)
+
+    def test_pi_sub_pdnat(self):
+        # GH 13071
+        idx = PeriodIndex(['2011-01', '2011-02', 'NaT',
+                           '2011-04'], freq='M', name='idx')
+        exp = pd.TimedeltaIndex([pd.NaT] * 4, name='idx')
+        tm.assert_index_equal(pd.NaT - idx, exp)
+        tm.assert_index_equal(idx - pd.NaT, exp)
+
+    def test_pi_sub_period_nat(self):
+        # GH 13071
+        idx = PeriodIndex(['2011-01', 'NaT', '2011-03',
+                           '2011-04'], freq='M', name='idx')
+
+        result = idx - pd.Period('2012-01', freq='M')
+        exp = pd.Index([-12, np.nan, -10, -9], name='idx')
+        tm.assert_index_equal(result, exp)
+
+        result = pd.Period('2012-01', freq='M') - idx
+        exp = pd.Index([12, np.nan, 10, 9], name='idx')
+        tm.assert_index_equal(result, exp)
+
+        exp = pd.TimedeltaIndex([np.nan, np.nan, np.nan, np.nan], name='idx')
+        tm.assert_index_equal(idx - pd.Period('NaT', freq='M'), exp)
+        tm.assert_index_equal(pd.Period('NaT', freq='M') - idx, exp)
diff --git a/pandas/tests/indexes/period/test_ops.py b/pandas/tests/indexes/period/test_ops.py
index 7acc335c3..1d77de0d2 100644
--- a/pandas/tests/indexes/period/test_ops.py
+++ b/pandas/tests/indexes/period/test_ops.py
@@ -1,14 +1,13 @@
 import pytest
 
 import numpy as np
-from datetime import timedelta
 
 import pandas as pd
 import pandas._libs.tslib as tslib
 import pandas.util.testing as tm
 import pandas.core.indexes.period as period
 from pandas import (DatetimeIndex, PeriodIndex, period_range, Series, Period,
-                    _np_version_under1p10, Index, Timedelta, offsets)
+                    _np_version_under1p10, Index)
 
 from pandas.tests.test_base import Ops
 
@@ -286,216 +285,6 @@ Freq: Q-DEC"""
             idx = pd.period_range(start='2013-04-01', periods=30, freq=freq)
             assert idx.resolution == expected
 
-    def test_add_iadd(self):
-        rng = pd.period_range('1/1/2000', freq='D', periods=5)
-        other = pd.period_range('1/6/2000', freq='D', periods=5)
-
-        # previously performed setop union, now raises TypeError (GH14164)
-        with pytest.raises(TypeError):
-            rng + other
-
-        with pytest.raises(TypeError):
-            rng += other
-
-        # offset
-        # DateOffset
-        rng = pd.period_range('2014', '2024', freq='A')
-        result = rng + pd.offsets.YearEnd(5)
-        expected = pd.period_range('2019', '2029', freq='A')
-        tm.assert_index_equal(result, expected)
-        rng += pd.offsets.YearEnd(5)
-        tm.assert_index_equal(rng, expected)
-
-        for o in [pd.offsets.YearBegin(2), pd.offsets.MonthBegin(1),
-                  pd.offsets.Minute(), np.timedelta64(365, 'D'),
-                  timedelta(365), Timedelta(days=365)]:
-            msg = ('Input has different freq(=.+)? '
-                   'from PeriodIndex\\(freq=A-DEC\\)')
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                rng + o
-
-        rng = pd.period_range('2014-01', '2016-12', freq='M')
-        result = rng + pd.offsets.MonthEnd(5)
-        expected = pd.period_range('2014-06', '2017-05', freq='M')
-        tm.assert_index_equal(result, expected)
-        rng += pd.offsets.MonthEnd(5)
-        tm.assert_index_equal(rng, expected)
-
-        for o in [pd.offsets.YearBegin(2), pd.offsets.MonthBegin(1),
-                  pd.offsets.Minute(), np.timedelta64(365, 'D'),
-                  timedelta(365), Timedelta(days=365)]:
-            rng = pd.period_range('2014-01', '2016-12', freq='M')
-            msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=M\\)'
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                rng + o
-
-        # Tick
-        offsets = [pd.offsets.Day(3), timedelta(days=3),
-                   np.timedelta64(3, 'D'), pd.offsets.Hour(72),
-                   timedelta(minutes=60 * 24 * 3), np.timedelta64(72, 'h'),
-                   Timedelta('72:00:00')]
-        for delta in offsets:
-            rng = pd.period_range('2014-05-01', '2014-05-15', freq='D')
-            result = rng + delta
-            expected = pd.period_range('2014-05-04', '2014-05-18', freq='D')
-            tm.assert_index_equal(result, expected)
-            rng += delta
-            tm.assert_index_equal(rng, expected)
-
-        for o in [pd.offsets.YearBegin(2), pd.offsets.MonthBegin(1),
-                  pd.offsets.Minute(), np.timedelta64(4, 'h'),
-                  timedelta(hours=23), Timedelta('23:00:00')]:
-            rng = pd.period_range('2014-05-01', '2014-05-15', freq='D')
-            msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=D\\)'
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                rng + o
-
-        offsets = [pd.offsets.Hour(2), timedelta(hours=2),
-                   np.timedelta64(2, 'h'), pd.offsets.Minute(120),
-                   timedelta(minutes=120), np.timedelta64(120, 'm'),
-                   Timedelta(minutes=120)]
-        for delta in offsets:
-            rng = pd.period_range('2014-01-01 10:00', '2014-01-05 10:00',
-                                  freq='H')
-            result = rng + delta
-            expected = pd.period_range('2014-01-01 12:00', '2014-01-05 12:00',
-                                       freq='H')
-            tm.assert_index_equal(result, expected)
-            rng += delta
-            tm.assert_index_equal(rng, expected)
-
-        for delta in [pd.offsets.YearBegin(2), timedelta(minutes=30),
-                      np.timedelta64(30, 's'), Timedelta(seconds=30)]:
-            rng = pd.period_range('2014-01-01 10:00', '2014-01-05 10:00',
-                                  freq='H')
-            msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=H\\)'
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                rng + delta
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                rng += delta
-
-        # int
-        rng = pd.period_range('2000-01-01 09:00', freq='H', periods=10)
-        result = rng + 1
-        expected = pd.period_range('2000-01-01 10:00', freq='H', periods=10)
-        tm.assert_index_equal(result, expected)
-        rng += 1
-        tm.assert_index_equal(rng, expected)
-
-    def test_sub(self):
-        rng = period_range('2007-01', periods=50)
-
-        result = rng - 5
-        exp = rng + (-5)
-        tm.assert_index_equal(result, exp)
-
-    def test_sub_isub(self):
-
-        # previously performed setop, now raises TypeError (GH14164)
-        # TODO needs to wait on #13077 for decision on result type
-        rng = pd.period_range('1/1/2000', freq='D', periods=5)
-        other = pd.period_range('1/6/2000', freq='D', periods=5)
-
-        with pytest.raises(TypeError):
-            rng - other
-
-        with pytest.raises(TypeError):
-            rng -= other
-
-        # offset
-        # DateOffset
-        rng = pd.period_range('2014', '2024', freq='A')
-        result = rng - pd.offsets.YearEnd(5)
-        expected = pd.period_range('2009', '2019', freq='A')
-        tm.assert_index_equal(result, expected)
-        rng -= pd.offsets.YearEnd(5)
-        tm.assert_index_equal(rng, expected)
-
-        for o in [pd.offsets.YearBegin(2), pd.offsets.MonthBegin(1),
-                  pd.offsets.Minute(), np.timedelta64(365, 'D'),
-                  timedelta(365)]:
-            rng = pd.period_range('2014', '2024', freq='A')
-            msg = ('Input has different freq(=.+)? '
-                   'from PeriodIndex\\(freq=A-DEC\\)')
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                rng - o
-
-        rng = pd.period_range('2014-01', '2016-12', freq='M')
-        result = rng - pd.offsets.MonthEnd(5)
-        expected = pd.period_range('2013-08', '2016-07', freq='M')
-        tm.assert_index_equal(result, expected)
-        rng -= pd.offsets.MonthEnd(5)
-        tm.assert_index_equal(rng, expected)
-
-        for o in [pd.offsets.YearBegin(2), pd.offsets.MonthBegin(1),
-                  pd.offsets.Minute(), np.timedelta64(365, 'D'),
-                  timedelta(365)]:
-            rng = pd.period_range('2014-01', '2016-12', freq='M')
-            msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=M\\)'
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                rng - o
-
-        # Tick
-        offsets = [pd.offsets.Day(3), timedelta(days=3),
-                   np.timedelta64(3, 'D'), pd.offsets.Hour(72),
-                   timedelta(minutes=60 * 24 * 3), np.timedelta64(72, 'h')]
-        for delta in offsets:
-            rng = pd.period_range('2014-05-01', '2014-05-15', freq='D')
-            result = rng - delta
-            expected = pd.period_range('2014-04-28', '2014-05-12', freq='D')
-            tm.assert_index_equal(result, expected)
-            rng -= delta
-            tm.assert_index_equal(rng, expected)
-
-        for o in [pd.offsets.YearBegin(2), pd.offsets.MonthBegin(1),
-                  pd.offsets.Minute(), np.timedelta64(4, 'h'),
-                  timedelta(hours=23)]:
-            rng = pd.period_range('2014-05-01', '2014-05-15', freq='D')
-            msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=D\\)'
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                rng - o
-
-        offsets = [pd.offsets.Hour(2), timedelta(hours=2),
-                   np.timedelta64(2, 'h'), pd.offsets.Minute(120),
-                   timedelta(minutes=120), np.timedelta64(120, 'm')]
-        for delta in offsets:
-            rng = pd.period_range('2014-01-01 10:00', '2014-01-05 10:00',
-                                  freq='H')
-            result = rng - delta
-            expected = pd.period_range('2014-01-01 08:00', '2014-01-05 08:00',
-                                       freq='H')
-            tm.assert_index_equal(result, expected)
-            rng -= delta
-            tm.assert_index_equal(rng, expected)
-
-        for delta in [pd.offsets.YearBegin(2), timedelta(minutes=30),
-                      np.timedelta64(30, 's')]:
-            rng = pd.period_range('2014-01-01 10:00', '2014-01-05 10:00',
-                                  freq='H')
-            msg = 'Input has different freq(=.+)? from PeriodIndex\\(freq=H\\)'
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                rng + delta
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                rng += delta
-
-        # int
-        rng = pd.period_range('2000-01-01 09:00', freq='H', periods=10)
-        result = rng - 1
-        expected = pd.period_range('2000-01-01 08:00', freq='H', periods=10)
-        tm.assert_index_equal(result, expected)
-        rng -= 1
-        tm.assert_index_equal(rng, expected)
-
     def test_comp_nat(self):
         left = pd.PeriodIndex([pd.Period('2011-01-01'), pd.NaT,
                                pd.Period('2011-01-03')])
@@ -869,199 +658,6 @@ class TestPeriodIndexSeriesMethods(object):
         exp = pd.Series(expected, name=values.name)
         tm.assert_series_equal(result, exp)
 
-    def test_pi_ops(self):
-        idx = PeriodIndex(['2011-01', '2011-02', '2011-03',
-                           '2011-04'], freq='M', name='idx')
-
-        expected = PeriodIndex(['2011-03', '2011-04',
-                                '2011-05', '2011-06'], freq='M', name='idx')
-        self._check(idx, lambda x: x + 2, expected)
-        self._check(idx, lambda x: 2 + x, expected)
-
-        self._check(idx + 2, lambda x: x - 2, idx)
-        result = idx - Period('2011-01', freq='M')
-        exp = pd.Index([0, 1, 2, 3], name='idx')
-        tm.assert_index_equal(result, exp)
-
-        result = Period('2011-01', freq='M') - idx
-        exp = pd.Index([0, -1, -2, -3], name='idx')
-        tm.assert_index_equal(result, exp)
-
-    def test_pi_ops_errors(self):
-        idx = PeriodIndex(['2011-01', '2011-02', '2011-03',
-                           '2011-04'], freq='M', name='idx')
-        s = pd.Series(idx)
-
-        msg = r"unsupported operand type\(s\)"
-
-        for obj in [idx, s]:
-            for ng in ["str", 1.5]:
-                with tm.assert_raises_regex(TypeError, msg):
-                    obj + ng
-
-                with pytest.raises(TypeError):
-                    # error message differs between PY2 and 3
-                    ng + obj
-
-                with tm.assert_raises_regex(TypeError, msg):
-                    obj - ng
-
-                with pytest.raises(TypeError):
-                    np.add(obj, ng)
-
-                if _np_version_under1p10:
-                    assert np.add(ng, obj) is NotImplemented
-                else:
-                    with pytest.raises(TypeError):
-                        np.add(ng, obj)
-
-                with pytest.raises(TypeError):
-                    np.subtract(obj, ng)
-
-                if _np_version_under1p10:
-                    assert np.subtract(ng, obj) is NotImplemented
-                else:
-                    with pytest.raises(TypeError):
-                        np.subtract(ng, obj)
-
-    def test_pi_ops_nat(self):
-        idx = PeriodIndex(['2011-01', '2011-02', 'NaT',
-                           '2011-04'], freq='M', name='idx')
-        expected = PeriodIndex(['2011-03', '2011-04',
-                                'NaT', '2011-06'], freq='M', name='idx')
-        self._check(idx, lambda x: x + 2, expected)
-        self._check(idx, lambda x: 2 + x, expected)
-        self._check(idx, lambda x: np.add(x, 2), expected)
-
-        self._check(idx + 2, lambda x: x - 2, idx)
-        self._check(idx + 2, lambda x: np.subtract(x, 2), idx)
-
-        # freq with mult
-        idx = PeriodIndex(['2011-01', '2011-02', 'NaT',
-                           '2011-04'], freq='2M', name='idx')
-        expected = PeriodIndex(['2011-07', '2011-08',
-                                'NaT', '2011-10'], freq='2M', name='idx')
-        self._check(idx, lambda x: x + 3, expected)
-        self._check(idx, lambda x: 3 + x, expected)
-        self._check(idx, lambda x: np.add(x, 3), expected)
-
-        self._check(idx + 3, lambda x: x - 3, idx)
-        self._check(idx + 3, lambda x: np.subtract(x, 3), idx)
-
-    def test_pi_ops_array_int(self):
-        idx = PeriodIndex(['2011-01', '2011-02', 'NaT',
-                           '2011-04'], freq='M', name='idx')
-        f = lambda x: x + np.array([1, 2, 3, 4])
-        exp = PeriodIndex(['2011-02', '2011-04', 'NaT',
-                           '2011-08'], freq='M', name='idx')
-        self._check(idx, f, exp)
-
-        f = lambda x: np.add(x, np.array([4, -1, 1, 2]))
-        exp = PeriodIndex(['2011-05', '2011-01', 'NaT',
-                           '2011-06'], freq='M', name='idx')
-        self._check(idx, f, exp)
-
-        f = lambda x: x - np.array([1, 2, 3, 4])
-        exp = PeriodIndex(['2010-12', '2010-12', 'NaT',
-                           '2010-12'], freq='M', name='idx')
-        self._check(idx, f, exp)
-
-        f = lambda x: np.subtract(x, np.array([3, 2, 3, -2]))
-        exp = PeriodIndex(['2010-10', '2010-12', 'NaT',
-                           '2011-06'], freq='M', name='idx')
-        self._check(idx, f, exp)
-
-    def test_pi_ops_offset(self):
-        idx = PeriodIndex(['2011-01-01', '2011-02-01', '2011-03-01',
-                           '2011-04-01'], freq='D', name='idx')
-        f = lambda x: x + offsets.Day()
-        exp = PeriodIndex(['2011-01-02', '2011-02-02', '2011-03-02',
-                           '2011-04-02'], freq='D', name='idx')
-        self._check(idx, f, exp)
-
-        f = lambda x: x + offsets.Day(2)
-        exp = PeriodIndex(['2011-01-03', '2011-02-03', '2011-03-03',
-                           '2011-04-03'], freq='D', name='idx')
-        self._check(idx, f, exp)
-
-        f = lambda x: x - offsets.Day(2)
-        exp = PeriodIndex(['2010-12-30', '2011-01-30', '2011-02-27',
-                           '2011-03-30'], freq='D', name='idx')
-        self._check(idx, f, exp)
-
-    def test_pi_offset_errors(self):
-        idx = PeriodIndex(['2011-01-01', '2011-02-01', '2011-03-01',
-                           '2011-04-01'], freq='D', name='idx')
-        s = pd.Series(idx)
-
-        # Series op is applied per Period instance, thus error is raised
-        # from Period
-        msg_idx = r"Input has different freq from PeriodIndex\(freq=D\)"
-        msg_s = r"Input cannot be converted to Period\(freq=D\)"
-        for obj, msg in [(idx, msg_idx), (s, msg_s)]:
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                obj + offsets.Hour(2)
-
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                offsets.Hour(2) + obj
-
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                obj - offsets.Hour(2)
-
-    def test_pi_sub_period(self):
-        # GH 13071
-        idx = PeriodIndex(['2011-01', '2011-02', '2011-03',
-                           '2011-04'], freq='M', name='idx')
-
-        result = idx - pd.Period('2012-01', freq='M')
-        exp = pd.Index([-12, -11, -10, -9], name='idx')
-        tm.assert_index_equal(result, exp)
-
-        result = np.subtract(idx, pd.Period('2012-01', freq='M'))
-        tm.assert_index_equal(result, exp)
-
-        result = pd.Period('2012-01', freq='M') - idx
-        exp = pd.Index([12, 11, 10, 9], name='idx')
-        tm.assert_index_equal(result, exp)
-
-        result = np.subtract(pd.Period('2012-01', freq='M'), idx)
-        if _np_version_under1p10:
-            assert result is NotImplemented
-        else:
-            tm.assert_index_equal(result, exp)
-
-        exp = pd.TimedeltaIndex([np.nan, np.nan, np.nan, np.nan], name='idx')
-        tm.assert_index_equal(idx - pd.Period('NaT', freq='M'), exp)
-        tm.assert_index_equal(pd.Period('NaT', freq='M') - idx, exp)
-
-    def test_pi_sub_pdnat(self):
-        # GH 13071
-        idx = PeriodIndex(['2011-01', '2011-02', 'NaT',
-                           '2011-04'], freq='M', name='idx')
-        exp = pd.TimedeltaIndex([pd.NaT] * 4, name='idx')
-        tm.assert_index_equal(pd.NaT - idx, exp)
-        tm.assert_index_equal(idx - pd.NaT, exp)
-
-    def test_pi_sub_period_nat(self):
-        # GH 13071
-        idx = PeriodIndex(['2011-01', 'NaT', '2011-03',
-                           '2011-04'], freq='M', name='idx')
-
-        result = idx - pd.Period('2012-01', freq='M')
-        exp = pd.Index([-12, np.nan, -10, -9], name='idx')
-        tm.assert_index_equal(result, exp)
-
-        result = pd.Period('2012-01', freq='M') - idx
-        exp = pd.Index([12, np.nan, 10, 9], name='idx')
-        tm.assert_index_equal(result, exp)
-
-        exp = pd.TimedeltaIndex([np.nan, np.nan, np.nan, np.nan], name='idx')
-        tm.assert_index_equal(idx - pd.Period('NaT', freq='M'), exp)
-        tm.assert_index_equal(pd.Period('NaT', freq='M') - idx, exp)
-
     def test_pi_comp_period(self):
         idx = PeriodIndex(['2011-01', '2011-02', '2011-03',
                            '2011-04'], freq='M', name='idx')
diff --git a/pandas/tests/indexes/timedeltas/test_arithmetic.py b/pandas/tests/indexes/timedeltas/test_arithmetic.py
new file mode 100644
index 000000000..9341cf220
--- /dev/null
+++ b/pandas/tests/indexes/timedeltas/test_arithmetic.py
@@ -0,0 +1,770 @@
+# -*- coding: utf-8 -*-
+import pytest
+import numpy as np
+from datetime import timedelta
+from distutils.version import LooseVersion
+
+import pandas as pd
+import pandas.util.testing as tm
+from pandas import (DatetimeIndex, TimedeltaIndex, Float64Index, Int64Index,
+                    to_timedelta, timedelta_range, date_range,
+                    Series,
+                    Timestamp, Timedelta)
+
+
+class TestTimedeltaIndexArithmetic(object):
+    _holder = TimedeltaIndex
+    _multiprocess_can_split_ = True
+
+    # TODO: Split by ops, better name
+    def test_numeric_compat(self):
+        idx = self._holder(np.arange(5, dtype='int64'))
+        didx = self._holder(np.arange(5, dtype='int64') ** 2)
+        result = idx * 1
+        tm.assert_index_equal(result, idx)
+
+        result = 1 * idx
+        tm.assert_index_equal(result, idx)
+
+        result = idx / 1
+        tm.assert_index_equal(result, idx)
+
+        result = idx // 1
+        tm.assert_index_equal(result, idx)
+
+        result = idx * np.array(5, dtype='int64')
+        tm.assert_index_equal(result,
+                              self._holder(np.arange(5, dtype='int64') * 5))
+
+        result = idx * np.arange(5, dtype='int64')
+        tm.assert_index_equal(result, didx)
+
+        result = idx * Series(np.arange(5, dtype='int64'))
+        tm.assert_index_equal(result, didx)
+
+        result = idx * Series(np.arange(5, dtype='float64') + 0.1)
+        tm.assert_index_equal(result, self._holder(np.arange(
+            5, dtype='float64') * (np.arange(5, dtype='float64') + 0.1)))
+
+        # invalid
+        pytest.raises(TypeError, lambda: idx * idx)
+        pytest.raises(ValueError, lambda: idx * self._holder(np.arange(3)))
+        pytest.raises(ValueError, lambda: idx * np.array([1, 2]))
+
+    # FIXME: duplicate.  This came from `test_timedelta`, whereas the
+    # version above came from `test_astype`.  Make sure there aren't more
+    # duplicates.
+    def test_numeric_compat__(self):
+
+        idx = self._holder(np.arange(5, dtype='int64'))
+        didx = self._holder(np.arange(5, dtype='int64') ** 2)
+        result = idx * 1
+        tm.assert_index_equal(result, idx)
+
+        result = 1 * idx
+        tm.assert_index_equal(result, idx)
+
+        result = idx / 1
+        tm.assert_index_equal(result, idx)
+
+        result = idx // 1
+        tm.assert_index_equal(result, idx)
+
+        result = idx * np.array(5, dtype='int64')
+        tm.assert_index_equal(result,
+                              self._holder(np.arange(5, dtype='int64') * 5))
+
+        result = idx * np.arange(5, dtype='int64')
+        tm.assert_index_equal(result, didx)
+
+        result = idx * Series(np.arange(5, dtype='int64'))
+        tm.assert_index_equal(result, didx)
+
+        result = idx * Series(np.arange(5, dtype='float64') + 0.1)
+        tm.assert_index_equal(result, self._holder(np.arange(
+            5, dtype='float64') * (np.arange(5, dtype='float64') + 0.1)))
+
+        # invalid
+        pytest.raises(TypeError, lambda: idx * idx)
+        pytest.raises(ValueError, lambda: idx * self._holder(np.arange(3)))
+        pytest.raises(ValueError, lambda: idx * np.array([1, 2]))
+
+    def test_ufunc_coercions(self):
+        # normal ops are also tested in tseries/test_timedeltas.py
+        idx = TimedeltaIndex(['2H', '4H', '6H', '8H', '10H'],
+                             freq='2H', name='x')
+
+        for result in [idx * 2, np.multiply(idx, 2)]:
+            assert isinstance(result, TimedeltaIndex)
+            exp = TimedeltaIndex(['4H', '8H', '12H', '16H', '20H'],
+                                 freq='4H', name='x')
+            tm.assert_index_equal(result, exp)
+            assert result.freq == '4H'
+
+        for result in [idx / 2, np.divide(idx, 2)]:
+            assert isinstance(result, TimedeltaIndex)
+            exp = TimedeltaIndex(['1H', '2H', '3H', '4H', '5H'],
+                                 freq='H', name='x')
+            tm.assert_index_equal(result, exp)
+            assert result.freq == 'H'
+
+        idx = TimedeltaIndex(['2H', '4H', '6H', '8H', '10H'],
+                             freq='2H', name='x')
+        for result in [-idx, np.negative(idx)]:
+            assert isinstance(result, TimedeltaIndex)
+            exp = TimedeltaIndex(['-2H', '-4H', '-6H', '-8H', '-10H'],
+                                 freq='-2H', name='x')
+            tm.assert_index_equal(result, exp)
+            assert result.freq == '-2H'
+
+        idx = TimedeltaIndex(['-2H', '-1H', '0H', '1H', '2H'],
+                             freq='H', name='x')
+        for result in [abs(idx), np.absolute(idx)]:
+            assert isinstance(result, TimedeltaIndex)
+            exp = TimedeltaIndex(['2H', '1H', '0H', '1H', '2H'],
+                                 freq=None, name='x')
+            tm.assert_index_equal(result, exp)
+            assert result.freq is None
+
+    def test_add_iadd(self):
+        # only test adding/sub offsets as + is now numeric
+
+        # offset
+        offsets = [pd.offsets.Hour(2), timedelta(hours=2),
+                   np.timedelta64(2, 'h'), Timedelta(hours=2)]
+
+        for delta in offsets:
+            rng = timedelta_range('1 days', '10 days')
+            result = rng + delta
+            expected = timedelta_range('1 days 02:00:00', '10 days 02:00:00',
+                                       freq='D')
+            tm.assert_index_equal(result, expected)
+            rng += delta
+            tm.assert_index_equal(rng, expected)
+
+        # int
+        rng = timedelta_range('1 days 09:00:00', freq='H', periods=10)
+        result = rng + 1
+        expected = timedelta_range('1 days 10:00:00', freq='H', periods=10)
+        tm.assert_index_equal(result, expected)
+        rng += 1
+        tm.assert_index_equal(rng, expected)
+
+    def test_sub_isub(self):
+        # only test adding/sub offsets as - is now numeric
+
+        # offset
+        offsets = [pd.offsets.Hour(2), timedelta(hours=2),
+                   np.timedelta64(2, 'h'), Timedelta(hours=2)]
+
+        for delta in offsets:
+            rng = timedelta_range('1 days', '10 days')
+            result = rng - delta
+            expected = timedelta_range('0 days 22:00:00', '9 days 22:00:00')
+            tm.assert_index_equal(result, expected)
+            rng -= delta
+            tm.assert_index_equal(rng, expected)
+
+        # int
+        rng = timedelta_range('1 days 09:00:00', freq='H', periods=10)
+        result = rng - 1
+        expected = timedelta_range('1 days 08:00:00', freq='H', periods=10)
+        tm.assert_index_equal(result, expected)
+        rng -= 1
+        tm.assert_index_equal(rng, expected)
+
+        idx = TimedeltaIndex(['1 day', '2 day'])
+        msg = "cannot subtract a datelike from a TimedeltaIndex"
+        with tm.assert_raises_regex(TypeError, msg):
+            idx - Timestamp('2011-01-01')
+
+        result = Timestamp('2011-01-01') + idx
+        expected = DatetimeIndex(['2011-01-02', '2011-01-03'])
+        tm.assert_index_equal(result, expected)
+
+    # TODO: Split by operation, better name
+    def test_ops_compat(self):
+
+        offsets = [pd.offsets.Hour(2), timedelta(hours=2),
+                   np.timedelta64(2, 'h'), Timedelta(hours=2)]
+
+        rng = timedelta_range('1 days', '10 days', name='foo')
+
+        # multiply
+        for offset in offsets:
+            pytest.raises(TypeError, lambda: rng * offset)
+
+        # divide
+        expected = Int64Index((np.arange(10) + 1) * 12, name='foo')
+        for offset in offsets:
+            result = rng / offset
+            tm.assert_index_equal(result, expected, exact=False)
+
+        # floor divide
+        expected = Int64Index((np.arange(10) + 1) * 12, name='foo')
+        for offset in offsets:
+            result = rng // offset
+            tm.assert_index_equal(result, expected, exact=False)
+
+        # divide with nats
+        rng = TimedeltaIndex(['1 days', pd.NaT, '2 days'], name='foo')
+        expected = Float64Index([12, np.nan, 24], name='foo')
+        for offset in offsets:
+            result = rng / offset
+            tm.assert_index_equal(result, expected)
+
+        # don't allow division by NaT (make could in the future)
+        pytest.raises(TypeError, lambda: rng / pd.NaT)
+
+    def test_subtraction_ops(self):
+        # with datetimes/timedelta and tdi/dti
+        tdi = TimedeltaIndex(['1 days', pd.NaT, '2 days'], name='foo')
+        dti = date_range('20130101', periods=3, name='bar')
+        td = Timedelta('1 days')
+        dt = Timestamp('20130101')
+
+        pytest.raises(TypeError, lambda: tdi - dt)
+        pytest.raises(TypeError, lambda: tdi - dti)
+        pytest.raises(TypeError, lambda: td - dt)
+        pytest.raises(TypeError, lambda: td - dti)
+
+        result = dt - dti
+        expected = TimedeltaIndex(['0 days', '-1 days', '-2 days'], name='bar')
+        tm.assert_index_equal(result, expected)
+
+        result = dti - dt
+        expected = TimedeltaIndex(['0 days', '1 days', '2 days'], name='bar')
+        tm.assert_index_equal(result, expected)
+
+        result = tdi - td
+        expected = TimedeltaIndex(['0 days', pd.NaT, '1 days'], name='foo')
+        tm.assert_index_equal(result, expected, check_names=False)
+
+        result = td - tdi
+        expected = TimedeltaIndex(['0 days', pd.NaT, '-1 days'], name='foo')
+        tm.assert_index_equal(result, expected, check_names=False)
+
+        result = dti - td
+        expected = DatetimeIndex(
+            ['20121231', '20130101', '20130102'], name='bar')
+        tm.assert_index_equal(result, expected, check_names=False)
+
+        result = dt - tdi
+        expected = DatetimeIndex(['20121231', pd.NaT, '20121230'], name='foo')
+        tm.assert_index_equal(result, expected)
+
+    def test_subtraction_ops_with_tz(self):
+
+        # check that dt/dti subtraction ops with tz are validated
+        dti = date_range('20130101', periods=3)
+        ts = Timestamp('20130101')
+        dt = ts.to_pydatetime()
+        dti_tz = date_range('20130101', periods=3).tz_localize('US/Eastern')
+        ts_tz = Timestamp('20130101').tz_localize('US/Eastern')
+        ts_tz2 = Timestamp('20130101').tz_localize('CET')
+        dt_tz = ts_tz.to_pydatetime()
+        td = Timedelta('1 days')
+
+        def _check(result, expected):
+            assert result == expected
+            assert isinstance(result, Timedelta)
+
+        # scalars
+        result = ts - ts
+        expected = Timedelta('0 days')
+        _check(result, expected)
+
+        result = dt_tz - ts_tz
+        expected = Timedelta('0 days')
+        _check(result, expected)
+
+        result = ts_tz - dt_tz
+        expected = Timedelta('0 days')
+        _check(result, expected)
+
+        # tz mismatches
+        pytest.raises(TypeError, lambda: dt_tz - ts)
+        pytest.raises(TypeError, lambda: dt_tz - dt)
+        pytest.raises(TypeError, lambda: dt_tz - ts_tz2)
+        pytest.raises(TypeError, lambda: dt - dt_tz)
+        pytest.raises(TypeError, lambda: ts - dt_tz)
+        pytest.raises(TypeError, lambda: ts_tz2 - ts)
+        pytest.raises(TypeError, lambda: ts_tz2 - dt)
+        pytest.raises(TypeError, lambda: ts_tz - ts_tz2)
+
+        # with dti
+        pytest.raises(TypeError, lambda: dti - ts_tz)
+        pytest.raises(TypeError, lambda: dti_tz - ts)
+        pytest.raises(TypeError, lambda: dti_tz - ts_tz2)
+
+        result = dti_tz - dt_tz
+        expected = TimedeltaIndex(['0 days', '1 days', '2 days'])
+        tm.assert_index_equal(result, expected)
+
+        result = dt_tz - dti_tz
+        expected = TimedeltaIndex(['0 days', '-1 days', '-2 days'])
+        tm.assert_index_equal(result, expected)
+
+        result = dti_tz - ts_tz
+        expected = TimedeltaIndex(['0 days', '1 days', '2 days'])
+        tm.assert_index_equal(result, expected)
+
+        result = ts_tz - dti_tz
+        expected = TimedeltaIndex(['0 days', '-1 days', '-2 days'])
+        tm.assert_index_equal(result, expected)
+
+        result = td - td
+        expected = Timedelta('0 days')
+        _check(result, expected)
+
+        result = dti_tz - td
+        expected = DatetimeIndex(
+            ['20121231', '20130101', '20130102'], tz='US/Eastern')
+        tm.assert_index_equal(result, expected)
+
+    def test_dti_tdi_numeric_ops(self):
+        # These are normally union/diff set-like ops
+        tdi = TimedeltaIndex(['1 days', pd.NaT, '2 days'], name='foo')
+        dti = date_range('20130101', periods=3, name='bar')
+
+        # TODO(wesm): unused?
+        # td = Timedelta('1 days')
+        # dt = Timestamp('20130101')
+
+        result = tdi - tdi
+        expected = TimedeltaIndex(['0 days', pd.NaT, '0 days'], name='foo')
+        tm.assert_index_equal(result, expected)
+
+        result = tdi + tdi
+        expected = TimedeltaIndex(['2 days', pd.NaT, '4 days'], name='foo')
+        tm.assert_index_equal(result, expected)
+
+        result = dti - tdi  # name will be reset
+        expected = DatetimeIndex(['20121231', pd.NaT, '20130101'])
+        tm.assert_index_equal(result, expected)
+
+    def test_sub_period(self):
+        # GH 13078
+        # not supported, check TypeError
+        p = pd.Period('2011-01-01', freq='D')
+
+        for freq in [None, 'H']:
+            idx = pd.TimedeltaIndex(['1 hours', '2 hours'], freq=freq)
+
+            with pytest.raises(TypeError):
+                idx - p
+
+            with pytest.raises(TypeError):
+                p - idx
+
+    def test_addition_ops(self):
+        # with datetimes/timedelta and tdi/dti
+        tdi = TimedeltaIndex(['1 days', pd.NaT, '2 days'], name='foo')
+        dti = date_range('20130101', periods=3, name='bar')
+        td = Timedelta('1 days')
+        dt = Timestamp('20130101')
+
+        result = tdi + dt
+        expected = DatetimeIndex(['20130102', pd.NaT, '20130103'], name='foo')
+        tm.assert_index_equal(result, expected)
+
+        result = dt + tdi
+        expected = DatetimeIndex(['20130102', pd.NaT, '20130103'], name='foo')
+        tm.assert_index_equal(result, expected)
+
+        result = td + tdi
+        expected = TimedeltaIndex(['2 days', pd.NaT, '3 days'], name='foo')
+        tm.assert_index_equal(result, expected)
+
+        result = tdi + td
+        expected = TimedeltaIndex(['2 days', pd.NaT, '3 days'], name='foo')
+        tm.assert_index_equal(result, expected)
+
+        # unequal length
+        pytest.raises(ValueError, lambda: tdi + dti[0:1])
+        pytest.raises(ValueError, lambda: tdi[0:1] + dti)
+
+        # random indexes
+        pytest.raises(TypeError, lambda: tdi + Int64Index([1, 2, 3]))
+
+        # this is a union!
+        # pytest.raises(TypeError, lambda : Int64Index([1,2,3]) + tdi)
+
+        result = tdi + dti  # name will be reset
+        expected = DatetimeIndex(['20130102', pd.NaT, '20130105'])
+        tm.assert_index_equal(result, expected)
+
+        result = dti + tdi  # name will be reset
+        expected = DatetimeIndex(['20130102', pd.NaT, '20130105'])
+        tm.assert_index_equal(result, expected)
+
+        result = dt + td
+        expected = Timestamp('20130102')
+        assert result == expected
+
+        result = td + dt
+        expected = Timestamp('20130102')
+        assert result == expected
+
+    # TODO: Split by op, better name
+    def test_ops(self):
+        td = Timedelta(10, unit='d')
+        assert -td == Timedelta(-10, unit='d')
+        assert +td == Timedelta(10, unit='d')
+        assert td - td == Timedelta(0, unit='ns')
+        assert (td - pd.NaT) is pd.NaT
+        assert td + td == Timedelta(20, unit='d')
+        assert (td + pd.NaT) is pd.NaT
+        assert td * 2 == Timedelta(20, unit='d')
+        assert (td * pd.NaT) is pd.NaT
+        assert td / 2 == Timedelta(5, unit='d')
+        assert td // 2 == Timedelta(5, unit='d')
+        assert abs(td) == td
+        assert abs(-td) == td
+        assert td / td == 1
+        assert (td / pd.NaT) is np.nan
+        assert (td // pd.NaT) is np.nan
+
+        # invert
+        assert -td == Timedelta('-10d')
+        assert td * -1 == Timedelta('-10d')
+        assert -1 * td == Timedelta('-10d')
+        assert abs(-td) == Timedelta('10d')
+
+        # invalid multiply with another timedelta
+        pytest.raises(TypeError, lambda: td * td)
+
+        # can't operate with integers
+        pytest.raises(TypeError, lambda: td + 2)
+        pytest.raises(TypeError, lambda: td - 2)
+
+    def test_ops_offsets(self):
+        td = Timedelta(10, unit='d')
+        assert Timedelta(241, unit='h') == td + pd.offsets.Hour(1)
+        assert Timedelta(241, unit='h') == pd.offsets.Hour(1) + td
+        assert 240 == td / pd.offsets.Hour(1)
+        assert 1 / 240.0 == pd.offsets.Hour(1) / td
+        assert Timedelta(239, unit='h') == td - pd.offsets.Hour(1)
+        assert Timedelta(-239, unit='h') == pd.offsets.Hour(1) - td
+
+    def test_ops_ndarray(self):
+        td = Timedelta('1 day')
+
+        # timedelta, timedelta
+        other = pd.to_timedelta(['1 day']).values
+        expected = pd.to_timedelta(['2 days']).values
+        tm.assert_numpy_array_equal(td + other, expected)
+        if LooseVersion(np.__version__) >= '1.8':
+            tm.assert_numpy_array_equal(other + td, expected)
+        pytest.raises(TypeError, lambda: td + np.array([1]))
+        pytest.raises(TypeError, lambda: np.array([1]) + td)
+
+        expected = pd.to_timedelta(['0 days']).values
+        tm.assert_numpy_array_equal(td - other, expected)
+        if LooseVersion(np.__version__) >= '1.8':
+            tm.assert_numpy_array_equal(-other + td, expected)
+        pytest.raises(TypeError, lambda: td - np.array([1]))
+        pytest.raises(TypeError, lambda: np.array([1]) - td)
+
+        expected = pd.to_timedelta(['2 days']).values
+        tm.assert_numpy_array_equal(td * np.array([2]), expected)
+        tm.assert_numpy_array_equal(np.array([2]) * td, expected)
+        pytest.raises(TypeError, lambda: td * other)
+        pytest.raises(TypeError, lambda: other * td)
+
+        tm.assert_numpy_array_equal(td / other,
+                                    np.array([1], dtype=np.float64))
+        if LooseVersion(np.__version__) >= '1.8':
+            tm.assert_numpy_array_equal(other / td,
+                                        np.array([1], dtype=np.float64))
+
+        # timedelta, datetime
+        other = pd.to_datetime(['2000-01-01']).values
+        expected = pd.to_datetime(['2000-01-02']).values
+        tm.assert_numpy_array_equal(td + other, expected)
+        if LooseVersion(np.__version__) >= '1.8':
+            tm.assert_numpy_array_equal(other + td, expected)
+
+        expected = pd.to_datetime(['1999-12-31']).values
+        tm.assert_numpy_array_equal(-td + other, expected)
+        if LooseVersion(np.__version__) >= '1.8':
+            tm.assert_numpy_array_equal(other - td, expected)
+
+    def test_ops_series(self):
+        # regression test for GH8813
+        td = Timedelta('1 day')
+        other = pd.Series([1, 2])
+        expected = pd.Series(pd.to_timedelta(['1 day', '2 days']))
+        tm.assert_series_equal(expected, td * other)
+        tm.assert_series_equal(expected, other * td)
+
+    def test_ops_series_object(self):
+        # GH 13043
+        s = pd.Series([pd.Timestamp('2015-01-01', tz='US/Eastern'),
+                       pd.Timestamp('2015-01-01', tz='Asia/Tokyo')],
+                      name='xxx')
+        assert s.dtype == object
+
+        exp = pd.Series([pd.Timestamp('2015-01-02', tz='US/Eastern'),
+                         pd.Timestamp('2015-01-02', tz='Asia/Tokyo')],
+                        name='xxx')
+        tm.assert_series_equal(s + pd.Timedelta('1 days'), exp)
+        tm.assert_series_equal(pd.Timedelta('1 days') + s, exp)
+
+        # object series & object series
+        s2 = pd.Series([pd.Timestamp('2015-01-03', tz='US/Eastern'),
+                        pd.Timestamp('2015-01-05', tz='Asia/Tokyo')],
+                       name='xxx')
+        assert s2.dtype == object
+        exp = pd.Series([pd.Timedelta('2 days'), pd.Timedelta('4 days')],
+                        name='xxx')
+        tm.assert_series_equal(s2 - s, exp)
+        tm.assert_series_equal(s - s2, -exp)
+
+        s = pd.Series([pd.Timedelta('01:00:00'), pd.Timedelta('02:00:00')],
+                      name='xxx', dtype=object)
+        assert s.dtype == object
+
+        exp = pd.Series([pd.Timedelta('01:30:00'), pd.Timedelta('02:30:00')],
+                        name='xxx')
+        tm.assert_series_equal(s + pd.Timedelta('00:30:00'), exp)
+        tm.assert_series_equal(pd.Timedelta('00:30:00') + s, exp)
+
+    def test_ops_notimplemented(self):
+        class Other:
+            pass
+
+        other = Other()
+
+        td = Timedelta('1 day')
+        assert td.__add__(other) is NotImplemented
+        assert td.__sub__(other) is NotImplemented
+        assert td.__truediv__(other) is NotImplemented
+        assert td.__mul__(other) is NotImplemented
+        assert td.__floordiv__(other) is NotImplemented
+
+    def test_timedelta_ops_scalar(self):
+        # GH 6808
+        base = pd.to_datetime('20130101 09:01:12.123456')
+        expected_add = pd.to_datetime('20130101 09:01:22.123456')
+        expected_sub = pd.to_datetime('20130101 09:01:02.123456')
+
+        for offset in [pd.to_timedelta(10, unit='s'), timedelta(seconds=10),
+                       np.timedelta64(10, 's'),
+                       np.timedelta64(10000000000, 'ns'),
+                       pd.offsets.Second(10)]:
+            result = base + offset
+            assert result == expected_add
+
+            result = base - offset
+            assert result == expected_sub
+
+        base = pd.to_datetime('20130102 09:01:12.123456')
+        expected_add = pd.to_datetime('20130103 09:01:22.123456')
+        expected_sub = pd.to_datetime('20130101 09:01:02.123456')
+
+        for offset in [pd.to_timedelta('1 day, 00:00:10'),
+                       pd.to_timedelta('1 days, 00:00:10'),
+                       timedelta(days=1, seconds=10),
+                       np.timedelta64(1, 'D') + np.timedelta64(10, 's'),
+                       pd.offsets.Day() + pd.offsets.Second(10)]:
+            result = base + offset
+            assert result == expected_add
+
+            result = base - offset
+            assert result == expected_sub
+
+    def test_timedelta_ops_with_missing_values(self):
+        # setup
+        s1 = pd.to_timedelta(Series(['00:00:01']))
+        s2 = pd.to_timedelta(Series(['00:00:02']))
+        sn = pd.to_timedelta(Series([pd.NaT]))
+        df1 = pd.DataFrame(['00:00:01']).apply(pd.to_timedelta)
+        df2 = pd.DataFrame(['00:00:02']).apply(pd.to_timedelta)
+        dfn = pd.DataFrame([pd.NaT]).apply(pd.to_timedelta)
+        scalar1 = pd.to_timedelta('00:00:01')
+        scalar2 = pd.to_timedelta('00:00:02')
+        timedelta_NaT = pd.to_timedelta('NaT')
+        NA = np.nan
+
+        actual = scalar1 + scalar1
+        assert actual == scalar2
+        actual = scalar2 - scalar1
+        assert actual == scalar1
+
+        actual = s1 + s1
+        tm.assert_series_equal(actual, s2)
+        actual = s2 - s1
+        tm.assert_series_equal(actual, s1)
+
+        actual = s1 + scalar1
+        tm.assert_series_equal(actual, s2)
+        actual = scalar1 + s1
+        tm.assert_series_equal(actual, s2)
+        actual = s2 - scalar1
+        tm.assert_series_equal(actual, s1)
+        actual = -scalar1 + s2
+        tm.assert_series_equal(actual, s1)
+
+        actual = s1 + timedelta_NaT
+        tm.assert_series_equal(actual, sn)
+        actual = timedelta_NaT + s1
+        tm.assert_series_equal(actual, sn)
+        actual = s1 - timedelta_NaT
+        tm.assert_series_equal(actual, sn)
+        actual = -timedelta_NaT + s1
+        tm.assert_series_equal(actual, sn)
+
+        actual = s1 + NA
+        tm.assert_series_equal(actual, sn)
+        actual = NA + s1
+        tm.assert_series_equal(actual, sn)
+        actual = s1 - NA
+        tm.assert_series_equal(actual, sn)
+        actual = -NA + s1
+        tm.assert_series_equal(actual, sn)
+
+        actual = s1 + pd.NaT
+        tm.assert_series_equal(actual, sn)
+        actual = s2 - pd.NaT
+        tm.assert_series_equal(actual, sn)
+
+        actual = s1 + df1
+        tm.assert_frame_equal(actual, df2)
+        actual = s2 - df1
+        tm.assert_frame_equal(actual, df1)
+        actual = df1 + s1
+        tm.assert_frame_equal(actual, df2)
+        actual = df2 - s1
+        tm.assert_frame_equal(actual, df1)
+
+        actual = df1 + df1
+        tm.assert_frame_equal(actual, df2)
+        actual = df2 - df1
+        tm.assert_frame_equal(actual, df1)
+
+        actual = df1 + scalar1
+        tm.assert_frame_equal(actual, df2)
+        actual = df2 - scalar1
+        tm.assert_frame_equal(actual, df1)
+
+        actual = df1 + timedelta_NaT
+        tm.assert_frame_equal(actual, dfn)
+        actual = df1 - timedelta_NaT
+        tm.assert_frame_equal(actual, dfn)
+
+        actual = df1 + NA
+        tm.assert_frame_equal(actual, dfn)
+        actual = df1 - NA
+        tm.assert_frame_equal(actual, dfn)
+
+        actual = df1 + pd.NaT  # NaT is datetime, not timedelta
+        tm.assert_frame_equal(actual, dfn)
+        actual = df1 - pd.NaT
+        tm.assert_frame_equal(actual, dfn)
+
+    def test_add_overflow(self):
+        # see gh-14068
+        msg = "too (big|large) to convert"
+        with tm.assert_raises_regex(OverflowError, msg):
+            to_timedelta(106580, 'D') + Timestamp('2000')
+        with tm.assert_raises_regex(OverflowError, msg):
+            Timestamp('2000') + to_timedelta(106580, 'D')
+
+        _NaT = int(pd.NaT) + 1
+        msg = "Overflow in int64 addition"
+        with tm.assert_raises_regex(OverflowError, msg):
+            to_timedelta([106580], 'D') + Timestamp('2000')
+        with tm.assert_raises_regex(OverflowError, msg):
+            Timestamp('2000') + to_timedelta([106580], 'D')
+        with tm.assert_raises_regex(OverflowError, msg):
+            to_timedelta([_NaT]) - Timedelta('1 days')
+        with tm.assert_raises_regex(OverflowError, msg):
+            to_timedelta(['5 days', _NaT]) - Timedelta('1 days')
+        with tm.assert_raises_regex(OverflowError, msg):
+            (to_timedelta([_NaT, '5 days', '1 hours']) -
+             to_timedelta(['7 seconds', _NaT, '4 hours']))
+
+        # These should not overflow!
+        exp = TimedeltaIndex([pd.NaT])
+        result = to_timedelta([pd.NaT]) - Timedelta('1 days')
+        tm.assert_index_equal(result, exp)
+
+        exp = TimedeltaIndex(['4 days', pd.NaT])
+        result = to_timedelta(['5 days', pd.NaT]) - Timedelta('1 days')
+        tm.assert_index_equal(result, exp)
+
+        exp = TimedeltaIndex([pd.NaT, pd.NaT, '5 hours'])
+        result = (to_timedelta([pd.NaT, '5 days', '1 hours']) +
+                  to_timedelta(['7 seconds', pd.NaT, '4 hours']))
+        tm.assert_index_equal(result, exp)
+
+    def test_tdi_ops_attributes(self):
+        rng = timedelta_range('2 days', periods=5, freq='2D', name='x')
+
+        result = rng + 1
+        exp = timedelta_range('4 days', periods=5, freq='2D', name='x')
+        tm.assert_index_equal(result, exp)
+        assert result.freq == '2D'
+
+        result = rng - 2
+        exp = timedelta_range('-2 days', periods=5, freq='2D', name='x')
+        tm.assert_index_equal(result, exp)
+        assert result.freq == '2D'
+
+        result = rng * 2
+        exp = timedelta_range('4 days', periods=5, freq='4D', name='x')
+        tm.assert_index_equal(result, exp)
+        assert result.freq == '4D'
+
+        result = rng / 2
+        exp = timedelta_range('1 days', periods=5, freq='D', name='x')
+        tm.assert_index_equal(result, exp)
+        assert result.freq == 'D'
+
+        result = -rng
+        exp = timedelta_range('-2 days', periods=5, freq='-2D', name='x')
+        tm.assert_index_equal(result, exp)
+        assert result.freq == '-2D'
+
+        rng = pd.timedelta_range('-2 days', periods=5, freq='D', name='x')
+
+        result = abs(rng)
+        exp = TimedeltaIndex(['2 days', '1 days', '0 days', '1 days',
+                              '2 days'], name='x')
+        tm.assert_index_equal(result, exp)
+        assert result.freq is None
+
+    # TODO: Needs more informative name, probably split up into
+    # more targeted tests
+    @pytest.mark.parametrize('freq', ['B', 'D'])
+    def test_timedelta(self, freq):
+        index = date_range('1/1/2000', periods=50, freq=freq)
+
+        shifted = index + timedelta(1)
+        back = shifted + timedelta(-1)
+        tm.assert_index_equal(index, back)
+
+        if freq == 'D':
+            expected = pd.tseries.offsets.Day(1)
+            assert index.freq == expected
+            assert shifted.freq == expected
+            assert back.freq == expected
+        else:  # freq == 'B'
+            assert index.freq == pd.tseries.offsets.BusinessDay(1)
+            assert shifted.freq is None
+            assert back.freq == pd.tseries.offsets.BusinessDay(1)
+
+        result = index - timedelta(1)
+        expected = index + timedelta(-1)
+        tm.assert_index_equal(result, expected)
+
+        # GH4134, buggy with timedeltas
+        rng = date_range('2013', '2014')
+        s = Series(rng)
+        result1 = rng - pd.offsets.Hour(1)
+        result2 = DatetimeIndex(s - np.timedelta64(100000000))
+        result3 = rng - np.timedelta64(100000000)
+        result4 = DatetimeIndex(s - pd.offsets.Hour(1))
+        tm.assert_index_equal(result1, result4)
+        tm.assert_index_equal(result2, result3)
diff --git a/pandas/tests/indexes/timedeltas/test_astype.py b/pandas/tests/indexes/timedeltas/test_astype.py
index 586b96f98..7a761cfe3 100644
--- a/pandas/tests/indexes/timedeltas/test_astype.py
+++ b/pandas/tests/indexes/timedeltas/test_astype.py
@@ -5,7 +5,7 @@ import numpy as np
 import pandas as pd
 import pandas.util.testing as tm
 from pandas import (TimedeltaIndex, timedelta_range, Int64Index, Float64Index,
-                    Index, Timedelta, Series)
+                    Index, Timedelta)
 
 from ..datetimelike import DatetimeLike
 
@@ -14,6 +14,11 @@ class TestTimedeltaIndex(DatetimeLike):
     _holder = TimedeltaIndex
     _multiprocess_can_split_ = True
 
+    def test_numeric_compat(self):
+        # Dummy method to override super's version; this test is now done
+        # in test_arithmetic.py
+        pass
+
     def setup_method(self, method):
         self.indices = dict(index=tm.makeTimedeltaIndex(10))
         self.setup_indices()
@@ -86,38 +91,3 @@ class TestTimedeltaIndex(DatetimeLike):
                                    '8 days 01:00:03', '9 days 01:00:03',
                                    '10 days 01:00:03'], freq='D')
         tm.assert_index_equal(result, expected)
-
-    def test_numeric_compat(self):
-
-        idx = self._holder(np.arange(5, dtype='int64'))
-        didx = self._holder(np.arange(5, dtype='int64') ** 2)
-        result = idx * 1
-        tm.assert_index_equal(result, idx)
-
-        result = 1 * idx
-        tm.assert_index_equal(result, idx)
-
-        result = idx / 1
-        tm.assert_index_equal(result, idx)
-
-        result = idx // 1
-        tm.assert_index_equal(result, idx)
-
-        result = idx * np.array(5, dtype='int64')
-        tm.assert_index_equal(result,
-                              self._holder(np.arange(5, dtype='int64') * 5))
-
-        result = idx * np.arange(5, dtype='int64')
-        tm.assert_index_equal(result, didx)
-
-        result = idx * Series(np.arange(5, dtype='int64'))
-        tm.assert_index_equal(result, didx)
-
-        result = idx * Series(np.arange(5, dtype='float64') + 0.1)
-        tm.assert_index_equal(result, self._holder(np.arange(
-            5, dtype='float64') * (np.arange(5, dtype='float64') + 0.1)))
-
-        # invalid
-        pytest.raises(TypeError, lambda: idx * idx)
-        pytest.raises(ValueError, lambda: idx * self._holder(np.arange(3)))
-        pytest.raises(ValueError, lambda: idx * np.array([1, 2]))
diff --git a/pandas/tests/indexes/timedeltas/test_ops.py b/pandas/tests/indexes/timedeltas/test_ops.py
index f4f669ee1..ff52afea2 100644
--- a/pandas/tests/indexes/timedeltas/test_ops.py
+++ b/pandas/tests/indexes/timedeltas/test_ops.py
@@ -2,15 +2,13 @@ import pytest
 
 import numpy as np
 from datetime import timedelta
-from distutils.version import LooseVersion
 
 import pandas as pd
 import pandas.util.testing as tm
 from pandas import to_timedelta
-from pandas.util.testing import assert_series_equal, assert_frame_equal
-from pandas import (Series, Timedelta, DataFrame, Timestamp, TimedeltaIndex,
-                    timedelta_range, date_range, DatetimeIndex, Int64Index,
-                    _np_version_under1p10, Float64Index, Index)
+from pandas import (Series, Timedelta, Timestamp, TimedeltaIndex,
+                    timedelta_range,
+                    _np_version_under1p10, Index)
 from pandas._libs.tslib import iNaT
 from pandas.tests.test_base import Ops
 
@@ -194,17 +192,17 @@ dtype: timedelta64[ns]"""
         idx4 = TimedeltaIndex(['1 days', '2 days', '3 days'], freq='D')
         idx5 = TimedeltaIndex(['1 days 00:00:01', '2 days', '3 days'])
 
-        exp1 = """TimedeltaIndex: 0 entries
-Freq: D"""
+        exp1 = ("TimedeltaIndex: 0 entries\n"
+                "Freq: D")
 
-        exp2 = """TimedeltaIndex: 1 entries, 1 days to 1 days
-Freq: D"""
+        exp2 = ("TimedeltaIndex: 1 entries, 1 days to 1 days\n"
+                "Freq: D")
 
-        exp3 = """TimedeltaIndex: 2 entries, 1 days to 2 days
-Freq: D"""
+        exp3 = ("TimedeltaIndex: 2 entries, 1 days to 2 days\n"
+                "Freq: D")
 
-        exp4 = """TimedeltaIndex: 3 entries, 1 days to 3 days
-Freq: D"""
+        exp4 = ("TimedeltaIndex: 3 entries, 1 days to 3 days\n"
+                "Freq: D")
 
         exp5 = ("TimedeltaIndex: 3 entries, 1 days 00:00:01 to 3 days "
                 "00:00:00")
@@ -214,289 +212,6 @@ Freq: D"""
             result = idx.summary()
             assert result == expected
 
-    def test_add_iadd(self):
-
-        # only test adding/sub offsets as + is now numeric
-
-        # offset
-        offsets = [pd.offsets.Hour(2), timedelta(hours=2),
-                   np.timedelta64(2, 'h'), Timedelta(hours=2)]
-
-        for delta in offsets:
-            rng = timedelta_range('1 days', '10 days')
-            result = rng + delta
-            expected = timedelta_range('1 days 02:00:00', '10 days 02:00:00',
-                                       freq='D')
-            tm.assert_index_equal(result, expected)
-            rng += delta
-            tm.assert_index_equal(rng, expected)
-
-        # int
-        rng = timedelta_range('1 days 09:00:00', freq='H', periods=10)
-        result = rng + 1
-        expected = timedelta_range('1 days 10:00:00', freq='H', periods=10)
-        tm.assert_index_equal(result, expected)
-        rng += 1
-        tm.assert_index_equal(rng, expected)
-
-    def test_sub_isub(self):
-        # only test adding/sub offsets as - is now numeric
-
-        # offset
-        offsets = [pd.offsets.Hour(2), timedelta(hours=2),
-                   np.timedelta64(2, 'h'), Timedelta(hours=2)]
-
-        for delta in offsets:
-            rng = timedelta_range('1 days', '10 days')
-            result = rng - delta
-            expected = timedelta_range('0 days 22:00:00', '9 days 22:00:00')
-            tm.assert_index_equal(result, expected)
-            rng -= delta
-            tm.assert_index_equal(rng, expected)
-
-        # int
-        rng = timedelta_range('1 days 09:00:00', freq='H', periods=10)
-        result = rng - 1
-        expected = timedelta_range('1 days 08:00:00', freq='H', periods=10)
-        tm.assert_index_equal(result, expected)
-        rng -= 1
-        tm.assert_index_equal(rng, expected)
-
-        idx = TimedeltaIndex(['1 day', '2 day'])
-        msg = "cannot subtract a datelike from a TimedeltaIndex"
-        with tm.assert_raises_regex(TypeError, msg):
-            idx - Timestamp('2011-01-01')
-
-        result = Timestamp('2011-01-01') + idx
-        expected = DatetimeIndex(['2011-01-02', '2011-01-03'])
-        tm.assert_index_equal(result, expected)
-
-    def test_ops_compat(self):
-
-        offsets = [pd.offsets.Hour(2), timedelta(hours=2),
-                   np.timedelta64(2, 'h'), Timedelta(hours=2)]
-
-        rng = timedelta_range('1 days', '10 days', name='foo')
-
-        # multiply
-        for offset in offsets:
-            pytest.raises(TypeError, lambda: rng * offset)
-
-        # divide
-        expected = Int64Index((np.arange(10) + 1) * 12, name='foo')
-        for offset in offsets:
-            result = rng / offset
-            tm.assert_index_equal(result, expected, exact=False)
-
-        # floor divide
-        expected = Int64Index((np.arange(10) + 1) * 12, name='foo')
-        for offset in offsets:
-            result = rng // offset
-            tm.assert_index_equal(result, expected, exact=False)
-
-        # divide with nats
-        rng = TimedeltaIndex(['1 days', pd.NaT, '2 days'], name='foo')
-        expected = Float64Index([12, np.nan, 24], name='foo')
-        for offset in offsets:
-            result = rng / offset
-            tm.assert_index_equal(result, expected)
-
-        # don't allow division by NaT (make could in the future)
-        pytest.raises(TypeError, lambda: rng / pd.NaT)
-
-    def test_subtraction_ops(self):
-
-        # with datetimes/timedelta and tdi/dti
-        tdi = TimedeltaIndex(['1 days', pd.NaT, '2 days'], name='foo')
-        dti = date_range('20130101', periods=3, name='bar')
-        td = Timedelta('1 days')
-        dt = Timestamp('20130101')
-
-        pytest.raises(TypeError, lambda: tdi - dt)
-        pytest.raises(TypeError, lambda: tdi - dti)
-        pytest.raises(TypeError, lambda: td - dt)
-        pytest.raises(TypeError, lambda: td - dti)
-
-        result = dt - dti
-        expected = TimedeltaIndex(['0 days', '-1 days', '-2 days'], name='bar')
-        tm.assert_index_equal(result, expected)
-
-        result = dti - dt
-        expected = TimedeltaIndex(['0 days', '1 days', '2 days'], name='bar')
-        tm.assert_index_equal(result, expected)
-
-        result = tdi - td
-        expected = TimedeltaIndex(['0 days', pd.NaT, '1 days'], name='foo')
-        tm.assert_index_equal(result, expected, check_names=False)
-
-        result = td - tdi
-        expected = TimedeltaIndex(['0 days', pd.NaT, '-1 days'], name='foo')
-        tm.assert_index_equal(result, expected, check_names=False)
-
-        result = dti - td
-        expected = DatetimeIndex(
-            ['20121231', '20130101', '20130102'], name='bar')
-        tm.assert_index_equal(result, expected, check_names=False)
-
-        result = dt - tdi
-        expected = DatetimeIndex(['20121231', pd.NaT, '20121230'], name='foo')
-        tm.assert_index_equal(result, expected)
-
-    def test_subtraction_ops_with_tz(self):
-
-        # check that dt/dti subtraction ops with tz are validated
-        dti = date_range('20130101', periods=3)
-        ts = Timestamp('20130101')
-        dt = ts.to_pydatetime()
-        dti_tz = date_range('20130101', periods=3).tz_localize('US/Eastern')
-        ts_tz = Timestamp('20130101').tz_localize('US/Eastern')
-        ts_tz2 = Timestamp('20130101').tz_localize('CET')
-        dt_tz = ts_tz.to_pydatetime()
-        td = Timedelta('1 days')
-
-        def _check(result, expected):
-            assert result == expected
-            assert isinstance(result, Timedelta)
-
-        # scalars
-        result = ts - ts
-        expected = Timedelta('0 days')
-        _check(result, expected)
-
-        result = dt_tz - ts_tz
-        expected = Timedelta('0 days')
-        _check(result, expected)
-
-        result = ts_tz - dt_tz
-        expected = Timedelta('0 days')
-        _check(result, expected)
-
-        # tz mismatches
-        pytest.raises(TypeError, lambda: dt_tz - ts)
-        pytest.raises(TypeError, lambda: dt_tz - dt)
-        pytest.raises(TypeError, lambda: dt_tz - ts_tz2)
-        pytest.raises(TypeError, lambda: dt - dt_tz)
-        pytest.raises(TypeError, lambda: ts - dt_tz)
-        pytest.raises(TypeError, lambda: ts_tz2 - ts)
-        pytest.raises(TypeError, lambda: ts_tz2 - dt)
-        pytest.raises(TypeError, lambda: ts_tz - ts_tz2)
-
-        # with dti
-        pytest.raises(TypeError, lambda: dti - ts_tz)
-        pytest.raises(TypeError, lambda: dti_tz - ts)
-        pytest.raises(TypeError, lambda: dti_tz - ts_tz2)
-
-        result = dti_tz - dt_tz
-        expected = TimedeltaIndex(['0 days', '1 days', '2 days'])
-        tm.assert_index_equal(result, expected)
-
-        result = dt_tz - dti_tz
-        expected = TimedeltaIndex(['0 days', '-1 days', '-2 days'])
-        tm.assert_index_equal(result, expected)
-
-        result = dti_tz - ts_tz
-        expected = TimedeltaIndex(['0 days', '1 days', '2 days'])
-        tm.assert_index_equal(result, expected)
-
-        result = ts_tz - dti_tz
-        expected = TimedeltaIndex(['0 days', '-1 days', '-2 days'])
-        tm.assert_index_equal(result, expected)
-
-        result = td - td
-        expected = Timedelta('0 days')
-        _check(result, expected)
-
-        result = dti_tz - td
-        expected = DatetimeIndex(
-            ['20121231', '20130101', '20130102'], tz='US/Eastern')
-        tm.assert_index_equal(result, expected)
-
-    def test_dti_tdi_numeric_ops(self):
-
-        # These are normally union/diff set-like ops
-        tdi = TimedeltaIndex(['1 days', pd.NaT, '2 days'], name='foo')
-        dti = date_range('20130101', periods=3, name='bar')
-
-        # TODO(wesm): unused?
-        # td = Timedelta('1 days')
-        # dt = Timestamp('20130101')
-
-        result = tdi - tdi
-        expected = TimedeltaIndex(['0 days', pd.NaT, '0 days'], name='foo')
-        tm.assert_index_equal(result, expected)
-
-        result = tdi + tdi
-        expected = TimedeltaIndex(['2 days', pd.NaT, '4 days'], name='foo')
-        tm.assert_index_equal(result, expected)
-
-        result = dti - tdi  # name will be reset
-        expected = DatetimeIndex(['20121231', pd.NaT, '20130101'])
-        tm.assert_index_equal(result, expected)
-
-    def test_sub_period(self):
-        # GH 13078
-        # not supported, check TypeError
-        p = pd.Period('2011-01-01', freq='D')
-
-        for freq in [None, 'H']:
-            idx = pd.TimedeltaIndex(['1 hours', '2 hours'], freq=freq)
-
-            with pytest.raises(TypeError):
-                idx - p
-
-            with pytest.raises(TypeError):
-                p - idx
-
-    def test_addition_ops(self):
-
-        # with datetimes/timedelta and tdi/dti
-        tdi = TimedeltaIndex(['1 days', pd.NaT, '2 days'], name='foo')
-        dti = date_range('20130101', periods=3, name='bar')
-        td = Timedelta('1 days')
-        dt = Timestamp('20130101')
-
-        result = tdi + dt
-        expected = DatetimeIndex(['20130102', pd.NaT, '20130103'], name='foo')
-        tm.assert_index_equal(result, expected)
-
-        result = dt + tdi
-        expected = DatetimeIndex(['20130102', pd.NaT, '20130103'], name='foo')
-        tm.assert_index_equal(result, expected)
-
-        result = td + tdi
-        expected = TimedeltaIndex(['2 days', pd.NaT, '3 days'], name='foo')
-        tm.assert_index_equal(result, expected)
-
-        result = tdi + td
-        expected = TimedeltaIndex(['2 days', pd.NaT, '3 days'], name='foo')
-        tm.assert_index_equal(result, expected)
-
-        # unequal length
-        pytest.raises(ValueError, lambda: tdi + dti[0:1])
-        pytest.raises(ValueError, lambda: tdi[0:1] + dti)
-
-        # random indexes
-        pytest.raises(TypeError, lambda: tdi + Int64Index([1, 2, 3]))
-
-        # this is a union!
-        # pytest.raises(TypeError, lambda : Int64Index([1,2,3]) + tdi)
-
-        result = tdi + dti  # name will be reset
-        expected = DatetimeIndex(['20130102', pd.NaT, '20130105'])
-        tm.assert_index_equal(result, expected)
-
-        result = dti + tdi  # name will be reset
-        expected = DatetimeIndex(['20130102', pd.NaT, '20130105'])
-        tm.assert_index_equal(result, expected)
-
-        result = dt + td
-        expected = Timestamp('20130102')
-        assert result == expected
-
-        result = td + dt
-        expected = Timestamp('20130102')
-        assert result == expected
-
     def test_comp_nat(self):
         left = pd.TimedeltaIndex([pd.Timedelta('1 days'), pd.NaT,
                                   pd.Timedelta('3 days')])
@@ -864,143 +579,6 @@ Freq: D"""
 class TestTimedeltas(object):
     _multiprocess_can_split_ = True
 
-    def test_ops(self):
-
-        td = Timedelta(10, unit='d')
-        assert -td == Timedelta(-10, unit='d')
-        assert +td == Timedelta(10, unit='d')
-        assert td - td == Timedelta(0, unit='ns')
-        assert (td - pd.NaT) is pd.NaT
-        assert td + td == Timedelta(20, unit='d')
-        assert (td + pd.NaT) is pd.NaT
-        assert td * 2 == Timedelta(20, unit='d')
-        assert (td * pd.NaT) is pd.NaT
-        assert td / 2 == Timedelta(5, unit='d')
-        assert td // 2 == Timedelta(5, unit='d')
-        assert abs(td) == td
-        assert abs(-td) == td
-        assert td / td == 1
-        assert (td / pd.NaT) is np.nan
-        assert (td // pd.NaT) is np.nan
-
-        # invert
-        assert -td == Timedelta('-10d')
-        assert td * -1 == Timedelta('-10d')
-        assert -1 * td == Timedelta('-10d')
-        assert abs(-td) == Timedelta('10d')
-
-        # invalid multiply with another timedelta
-        pytest.raises(TypeError, lambda: td * td)
-
-        # can't operate with integers
-        pytest.raises(TypeError, lambda: td + 2)
-        pytest.raises(TypeError, lambda: td - 2)
-
-    def test_ops_offsets(self):
-        td = Timedelta(10, unit='d')
-        assert Timedelta(241, unit='h') == td + pd.offsets.Hour(1)
-        assert Timedelta(241, unit='h') == pd.offsets.Hour(1) + td
-        assert 240 == td / pd.offsets.Hour(1)
-        assert 1 / 240.0 == pd.offsets.Hour(1) / td
-        assert Timedelta(239, unit='h') == td - pd.offsets.Hour(1)
-        assert Timedelta(-239, unit='h') == pd.offsets.Hour(1) - td
-
-    def test_ops_ndarray(self):
-        td = Timedelta('1 day')
-
-        # timedelta, timedelta
-        other = pd.to_timedelta(['1 day']).values
-        expected = pd.to_timedelta(['2 days']).values
-        tm.assert_numpy_array_equal(td + other, expected)
-        if LooseVersion(np.__version__) >= '1.8':
-            tm.assert_numpy_array_equal(other + td, expected)
-        pytest.raises(TypeError, lambda: td + np.array([1]))
-        pytest.raises(TypeError, lambda: np.array([1]) + td)
-
-        expected = pd.to_timedelta(['0 days']).values
-        tm.assert_numpy_array_equal(td - other, expected)
-        if LooseVersion(np.__version__) >= '1.8':
-            tm.assert_numpy_array_equal(-other + td, expected)
-        pytest.raises(TypeError, lambda: td - np.array([1]))
-        pytest.raises(TypeError, lambda: np.array([1]) - td)
-
-        expected = pd.to_timedelta(['2 days']).values
-        tm.assert_numpy_array_equal(td * np.array([2]), expected)
-        tm.assert_numpy_array_equal(np.array([2]) * td, expected)
-        pytest.raises(TypeError, lambda: td * other)
-        pytest.raises(TypeError, lambda: other * td)
-
-        tm.assert_numpy_array_equal(td / other,
-                                    np.array([1], dtype=np.float64))
-        if LooseVersion(np.__version__) >= '1.8':
-            tm.assert_numpy_array_equal(other / td,
-                                        np.array([1], dtype=np.float64))
-
-        # timedelta, datetime
-        other = pd.to_datetime(['2000-01-01']).values
-        expected = pd.to_datetime(['2000-01-02']).values
-        tm.assert_numpy_array_equal(td + other, expected)
-        if LooseVersion(np.__version__) >= '1.8':
-            tm.assert_numpy_array_equal(other + td, expected)
-
-        expected = pd.to_datetime(['1999-12-31']).values
-        tm.assert_numpy_array_equal(-td + other, expected)
-        if LooseVersion(np.__version__) >= '1.8':
-            tm.assert_numpy_array_equal(other - td, expected)
-
-    def test_ops_series(self):
-        # regression test for GH8813
-        td = Timedelta('1 day')
-        other = pd.Series([1, 2])
-        expected = pd.Series(pd.to_timedelta(['1 day', '2 days']))
-        tm.assert_series_equal(expected, td * other)
-        tm.assert_series_equal(expected, other * td)
-
-    def test_ops_series_object(self):
-        # GH 13043
-        s = pd.Series([pd.Timestamp('2015-01-01', tz='US/Eastern'),
-                       pd.Timestamp('2015-01-01', tz='Asia/Tokyo')],
-                      name='xxx')
-        assert s.dtype == object
-
-        exp = pd.Series([pd.Timestamp('2015-01-02', tz='US/Eastern'),
-                         pd.Timestamp('2015-01-02', tz='Asia/Tokyo')],
-                        name='xxx')
-        tm.assert_series_equal(s + pd.Timedelta('1 days'), exp)
-        tm.assert_series_equal(pd.Timedelta('1 days') + s, exp)
-
-        # object series & object series
-        s2 = pd.Series([pd.Timestamp('2015-01-03', tz='US/Eastern'),
-                        pd.Timestamp('2015-01-05', tz='Asia/Tokyo')],
-                       name='xxx')
-        assert s2.dtype == object
-        exp = pd.Series([pd.Timedelta('2 days'), pd.Timedelta('4 days')],
-                        name='xxx')
-        tm.assert_series_equal(s2 - s, exp)
-        tm.assert_series_equal(s - s2, -exp)
-
-        s = pd.Series([pd.Timedelta('01:00:00'), pd.Timedelta('02:00:00')],
-                      name='xxx', dtype=object)
-        assert s.dtype == object
-
-        exp = pd.Series([pd.Timedelta('01:30:00'), pd.Timedelta('02:30:00')],
-                        name='xxx')
-        tm.assert_series_equal(s + pd.Timedelta('00:30:00'), exp)
-        tm.assert_series_equal(pd.Timedelta('00:30:00') + s, exp)
-
-    def test_ops_notimplemented(self):
-        class Other:
-            pass
-
-        other = Other()
-
-        td = Timedelta('1 day')
-        assert td.__add__(other) is NotImplemented
-        assert td.__sub__(other) is NotImplemented
-        assert td.__truediv__(other) is NotImplemented
-        assert td.__mul__(other) is NotImplemented
-        assert td.__floordiv__(other) is NotImplemented
-
     def test_ops_error_str(self):
         # GH 13624
         tdi = TimedeltaIndex(['1 day', '2 days'])
@@ -1073,126 +651,6 @@ class TestTimedeltas(object):
                     Timestamp('2015-02-15')])
         assert s.diff().median() == timedelta(days=6)
 
-    def test_timedelta_ops_scalar(self):
-        # GH 6808
-        base = pd.to_datetime('20130101 09:01:12.123456')
-        expected_add = pd.to_datetime('20130101 09:01:22.123456')
-        expected_sub = pd.to_datetime('20130101 09:01:02.123456')
-
-        for offset in [pd.to_timedelta(10, unit='s'), timedelta(seconds=10),
-                       np.timedelta64(10, 's'),
-                       np.timedelta64(10000000000, 'ns'),
-                       pd.offsets.Second(10)]:
-            result = base + offset
-            assert result == expected_add
-
-            result = base - offset
-            assert result == expected_sub
-
-        base = pd.to_datetime('20130102 09:01:12.123456')
-        expected_add = pd.to_datetime('20130103 09:01:22.123456')
-        expected_sub = pd.to_datetime('20130101 09:01:02.123456')
-
-        for offset in [pd.to_timedelta('1 day, 00:00:10'),
-                       pd.to_timedelta('1 days, 00:00:10'),
-                       timedelta(days=1, seconds=10),
-                       np.timedelta64(1, 'D') + np.timedelta64(10, 's'),
-                       pd.offsets.Day() + pd.offsets.Second(10)]:
-            result = base + offset
-            assert result == expected_add
-
-            result = base - offset
-            assert result == expected_sub
-
-    def test_timedelta_ops_with_missing_values(self):
-        # setup
-        s1 = pd.to_timedelta(Series(['00:00:01']))
-        s2 = pd.to_timedelta(Series(['00:00:02']))
-        sn = pd.to_timedelta(Series([pd.NaT]))
-        df1 = DataFrame(['00:00:01']).apply(pd.to_timedelta)
-        df2 = DataFrame(['00:00:02']).apply(pd.to_timedelta)
-        dfn = DataFrame([pd.NaT]).apply(pd.to_timedelta)
-        scalar1 = pd.to_timedelta('00:00:01')
-        scalar2 = pd.to_timedelta('00:00:02')
-        timedelta_NaT = pd.to_timedelta('NaT')
-        NA = np.nan
-
-        actual = scalar1 + scalar1
-        assert actual == scalar2
-        actual = scalar2 - scalar1
-        assert actual == scalar1
-
-        actual = s1 + s1
-        assert_series_equal(actual, s2)
-        actual = s2 - s1
-        assert_series_equal(actual, s1)
-
-        actual = s1 + scalar1
-        assert_series_equal(actual, s2)
-        actual = scalar1 + s1
-        assert_series_equal(actual, s2)
-        actual = s2 - scalar1
-        assert_series_equal(actual, s1)
-        actual = -scalar1 + s2
-        assert_series_equal(actual, s1)
-
-        actual = s1 + timedelta_NaT
-        assert_series_equal(actual, sn)
-        actual = timedelta_NaT + s1
-        assert_series_equal(actual, sn)
-        actual = s1 - timedelta_NaT
-        assert_series_equal(actual, sn)
-        actual = -timedelta_NaT + s1
-        assert_series_equal(actual, sn)
-
-        actual = s1 + NA
-        assert_series_equal(actual, sn)
-        actual = NA + s1
-        assert_series_equal(actual, sn)
-        actual = s1 - NA
-        assert_series_equal(actual, sn)
-        actual = -NA + s1
-        assert_series_equal(actual, sn)
-
-        actual = s1 + pd.NaT
-        assert_series_equal(actual, sn)
-        actual = s2 - pd.NaT
-        assert_series_equal(actual, sn)
-
-        actual = s1 + df1
-        assert_frame_equal(actual, df2)
-        actual = s2 - df1
-        assert_frame_equal(actual, df1)
-        actual = df1 + s1
-        assert_frame_equal(actual, df2)
-        actual = df2 - s1
-        assert_frame_equal(actual, df1)
-
-        actual = df1 + df1
-        assert_frame_equal(actual, df2)
-        actual = df2 - df1
-        assert_frame_equal(actual, df1)
-
-        actual = df1 + scalar1
-        assert_frame_equal(actual, df2)
-        actual = df2 - scalar1
-        assert_frame_equal(actual, df1)
-
-        actual = df1 + timedelta_NaT
-        assert_frame_equal(actual, dfn)
-        actual = df1 - timedelta_NaT
-        assert_frame_equal(actual, dfn)
-
-        actual = df1 + NA
-        assert_frame_equal(actual, dfn)
-        actual = df1 - NA
-        assert_frame_equal(actual, dfn)
-
-        actual = df1 + pd.NaT  # NaT is datetime, not timedelta
-        assert_frame_equal(actual, dfn)
-        actual = df1 - pd.NaT
-        assert_frame_equal(actual, dfn)
-
     def test_compare_timedelta_series(self):
         # regresssion test for GH5963
         s = pd.Series([timedelta(days=1), timedelta(days=2)])
@@ -1207,78 +665,3 @@ class TestTimedeltas(object):
         result = arr[0] > arr
         expected = np.array([False, False])
         tm.assert_numpy_array_equal(result, expected)
-
-
-class TestSlicing(object):
-
-    def test_tdi_ops_attributes(self):
-        rng = timedelta_range('2 days', periods=5, freq='2D', name='x')
-
-        result = rng + 1
-        exp = timedelta_range('4 days', periods=5, freq='2D', name='x')
-        tm.assert_index_equal(result, exp)
-        assert result.freq == '2D'
-
-        result = rng - 2
-        exp = timedelta_range('-2 days', periods=5, freq='2D', name='x')
-        tm.assert_index_equal(result, exp)
-        assert result.freq == '2D'
-
-        result = rng * 2
-        exp = timedelta_range('4 days', periods=5, freq='4D', name='x')
-        tm.assert_index_equal(result, exp)
-        assert result.freq == '4D'
-
-        result = rng / 2
-        exp = timedelta_range('1 days', periods=5, freq='D', name='x')
-        tm.assert_index_equal(result, exp)
-        assert result.freq == 'D'
-
-        result = -rng
-        exp = timedelta_range('-2 days', periods=5, freq='-2D', name='x')
-        tm.assert_index_equal(result, exp)
-        assert result.freq == '-2D'
-
-        rng = pd.timedelta_range('-2 days', periods=5, freq='D', name='x')
-
-        result = abs(rng)
-        exp = TimedeltaIndex(['2 days', '1 days', '0 days', '1 days',
-                              '2 days'], name='x')
-        tm.assert_index_equal(result, exp)
-        assert result.freq is None
-
-    def test_add_overflow(self):
-        # see gh-14068
-        msg = "too (big|large) to convert"
-        with tm.assert_raises_regex(OverflowError, msg):
-            to_timedelta(106580, 'D') + Timestamp('2000')
-        with tm.assert_raises_regex(OverflowError, msg):
-            Timestamp('2000') + to_timedelta(106580, 'D')
-
-        _NaT = int(pd.NaT) + 1
-        msg = "Overflow in int64 addition"
-        with tm.assert_raises_regex(OverflowError, msg):
-            to_timedelta([106580], 'D') + Timestamp('2000')
-        with tm.assert_raises_regex(OverflowError, msg):
-            Timestamp('2000') + to_timedelta([106580], 'D')
-        with tm.assert_raises_regex(OverflowError, msg):
-            to_timedelta([_NaT]) - Timedelta('1 days')
-        with tm.assert_raises_regex(OverflowError, msg):
-            to_timedelta(['5 days', _NaT]) - Timedelta('1 days')
-        with tm.assert_raises_regex(OverflowError, msg):
-            (to_timedelta([_NaT, '5 days', '1 hours']) -
-             to_timedelta(['7 seconds', _NaT, '4 hours']))
-
-        # These should not overflow!
-        exp = TimedeltaIndex([pd.NaT])
-        result = to_timedelta([pd.NaT]) - Timedelta('1 days')
-        tm.assert_index_equal(result, exp)
-
-        exp = TimedeltaIndex(['4 days', pd.NaT])
-        result = to_timedelta(['5 days', pd.NaT]) - Timedelta('1 days')
-        tm.assert_index_equal(result, exp)
-
-        exp = TimedeltaIndex([pd.NaT, pd.NaT, '5 hours'])
-        result = (to_timedelta([pd.NaT, '5 days', '1 hours']) +
-                  to_timedelta(['7 seconds', pd.NaT, '4 hours']))
-        tm.assert_index_equal(result, exp)
diff --git a/pandas/tests/indexes/timedeltas/test_timedelta.py b/pandas/tests/indexes/timedeltas/test_timedelta.py
index 0a09199ec..2683110f2 100644
--- a/pandas/tests/indexes/timedeltas/test_timedelta.py
+++ b/pandas/tests/indexes/timedeltas/test_timedelta.py
@@ -6,7 +6,7 @@ from datetime import timedelta
 import pandas as pd
 import pandas.util.testing as tm
 from pandas import (timedelta_range, date_range, Series, Timedelta,
-                    DatetimeIndex, TimedeltaIndex, Index, DataFrame,
+                    TimedeltaIndex, Index, DataFrame,
                     Int64Index)
 from pandas.util.testing import (assert_almost_equal, assert_series_equal,
                                  assert_index_equal)
@@ -27,6 +27,11 @@ class TestTimedeltaIndex(DatetimeLike):
     def create_index(self):
         return pd.to_timedelta(range(5), unit='d') + pd.offsets.Hour(1)
 
+    def test_numeric_compat(self):
+        # Dummy method to override super's version; this test is now done
+        # in test_arithmetic.py
+        pass
+
     def test_shift(self):
         # test shift for TimedeltaIndex
         # err8083
@@ -105,81 +110,9 @@ class TestTimedeltaIndex(DatetimeLike):
                               tolerance=pd.Timedelta('1 hour'))
         tm.assert_numpy_array_equal(res, np.array([0, -1, 1], dtype=np.intp))
 
-    def test_numeric_compat(self):
-
-        idx = self._holder(np.arange(5, dtype='int64'))
-        didx = self._holder(np.arange(5, dtype='int64') ** 2)
-        result = idx * 1
-        tm.assert_index_equal(result, idx)
-
-        result = 1 * idx
-        tm.assert_index_equal(result, idx)
-
-        result = idx / 1
-        tm.assert_index_equal(result, idx)
-
-        result = idx // 1
-        tm.assert_index_equal(result, idx)
-
-        result = idx * np.array(5, dtype='int64')
-        tm.assert_index_equal(result,
-                              self._holder(np.arange(5, dtype='int64') * 5))
-
-        result = idx * np.arange(5, dtype='int64')
-        tm.assert_index_equal(result, didx)
-
-        result = idx * Series(np.arange(5, dtype='int64'))
-        tm.assert_index_equal(result, didx)
-
-        result = idx * Series(np.arange(5, dtype='float64') + 0.1)
-        tm.assert_index_equal(result, self._holder(np.arange(
-            5, dtype='float64') * (np.arange(5, dtype='float64') + 0.1)))
-
-        # invalid
-        pytest.raises(TypeError, lambda: idx * idx)
-        pytest.raises(ValueError, lambda: idx * self._holder(np.arange(3)))
-        pytest.raises(ValueError, lambda: idx * np.array([1, 2]))
-
     def test_pickle_compat_construction(self):
         pass
 
-    def test_ufunc_coercions(self):
-        # normal ops are also tested in tseries/test_timedeltas.py
-        idx = TimedeltaIndex(['2H', '4H', '6H', '8H', '10H'],
-                             freq='2H', name='x')
-
-        for result in [idx * 2, np.multiply(idx, 2)]:
-            assert isinstance(result, TimedeltaIndex)
-            exp = TimedeltaIndex(['4H', '8H', '12H', '16H', '20H'],
-                                 freq='4H', name='x')
-            tm.assert_index_equal(result, exp)
-            assert result.freq == '4H'
-
-        for result in [idx / 2, np.divide(idx, 2)]:
-            assert isinstance(result, TimedeltaIndex)
-            exp = TimedeltaIndex(['1H', '2H', '3H', '4H', '5H'],
-                                 freq='H', name='x')
-            tm.assert_index_equal(result, exp)
-            assert result.freq == 'H'
-
-        idx = TimedeltaIndex(['2H', '4H', '6H', '8H', '10H'],
-                             freq='2H', name='x')
-        for result in [-idx, np.negative(idx)]:
-            assert isinstance(result, TimedeltaIndex)
-            exp = TimedeltaIndex(['-2H', '-4H', '-6H', '-8H', '-10H'],
-                                 freq='-2H', name='x')
-            tm.assert_index_equal(result, exp)
-            assert result.freq == '-2H'
-
-        idx = TimedeltaIndex(['-2H', '-1H', '0H', '1H', '2H'],
-                             freq='H', name='x')
-        for result in [abs(idx), np.absolute(idx)]:
-            assert isinstance(result, TimedeltaIndex)
-            exp = TimedeltaIndex(['2H', '1H', '0H', '1H', '2H'],
-                                 freq=None, name='x')
-            tm.assert_index_equal(result, exp)
-            assert result.freq is None
-
     def test_fillna_timedelta(self):
         # GH 11343
         idx = pd.TimedeltaIndex(['1 day', pd.NaT, '3 day'])
@@ -573,40 +506,6 @@ class TestTimedeltaIndex(DatetimeLike):
         assert_index_equal(result, expected)
 
 
-class TestSlicing(object):
-    @pytest.mark.parametrize('freq', ['B', 'D'])
-    def test_timedelta(self, freq):
-        index = date_range('1/1/2000', periods=50, freq=freq)
-
-        shifted = index + timedelta(1)
-        back = shifted + timedelta(-1)
-        tm.assert_index_equal(index, back)
-
-        if freq == 'D':
-            expected = pd.tseries.offsets.Day(1)
-            assert index.freq == expected
-            assert shifted.freq == expected
-            assert back.freq == expected
-        else:  # freq == 'B'
-            assert index.freq == pd.tseries.offsets.BusinessDay(1)
-            assert shifted.freq is None
-            assert back.freq == pd.tseries.offsets.BusinessDay(1)
-
-        result = index - timedelta(1)
-        expected = index + timedelta(-1)
-        tm.assert_index_equal(result, expected)
-
-        # GH4134, buggy with timedeltas
-        rng = date_range('2013', '2014')
-        s = Series(rng)
-        result1 = rng - pd.offsets.Hour(1)
-        result2 = DatetimeIndex(s - np.timedelta64(100000000))
-        result3 = rng - np.timedelta64(100000000)
-        result4 = DatetimeIndex(s - pd.offsets.Hour(1))
-        tm.assert_index_equal(result1, result4)
-        tm.assert_index_equal(result2, result3)
-
-
 class TestTimeSeries(object):
     _multiprocess_can_split_ = True
 
diff --git a/pandas/tests/indexes/timedeltas/test_tools.py b/pandas/tests/indexes/timedeltas/test_tools.py
index 1a4d1b1d7..b4ad28eea 100644
--- a/pandas/tests/indexes/timedeltas/test_tools.py
+++ b/pandas/tests/indexes/timedeltas/test_tools.py
@@ -6,8 +6,7 @@ import numpy as np
 import pandas as pd
 import pandas.util.testing as tm
 from pandas.util.testing import assert_series_equal
-from pandas import (Series, Timedelta, to_timedelta, isna,
-                    TimedeltaIndex)
+from pandas import Series, to_timedelta, isna, TimedeltaIndex
 from pandas._libs.tslib import iNaT
 
 
@@ -174,28 +173,3 @@ class TestTimedeltas(object):
 
         actual = pd.to_timedelta(pd.NaT)
         assert actual.value == timedelta_NaT.astype('int64')
-
-    def test_to_timedelta_on_nanoseconds(self):
-        # GH 9273
-        result = Timedelta(nanoseconds=100)
-        expected = Timedelta('100ns')
-        assert result == expected
-
-        result = Timedelta(days=1, hours=1, minutes=1, weeks=1, seconds=1,
-                           milliseconds=1, microseconds=1, nanoseconds=1)
-        expected = Timedelta(694861001001001)
-        assert result == expected
-
-        result = Timedelta(microseconds=1) + Timedelta(nanoseconds=1)
-        expected = Timedelta('1us1ns')
-        assert result == expected
-
-        result = Timedelta(microseconds=1) - Timedelta(nanoseconds=1)
-        expected = Timedelta('999ns')
-        assert result == expected
-
-        result = Timedelta(microseconds=1) + 5 * Timedelta(nanoseconds=-2)
-        expected = Timedelta('990ns')
-        assert result == expected
-
-        pytest.raises(TypeError, lambda: Timedelta(nanoseconds='abc'))
diff --git a/pandas/tests/scalar/test_timedelta.py b/pandas/tests/scalar/test_timedelta.py
index b5a8ce24f..d4434b3af 100644
--- a/pandas/tests/scalar/test_timedelta.py
+++ b/pandas/tests/scalar/test_timedelta.py
@@ -12,6 +12,35 @@ from pandas import (Timedelta, TimedeltaIndex, timedelta_range, Series,
 from pandas._libs.tslib import iNaT, NaT
 
 
+class TestTimedeltaArithmetic(object):
+    _multiprocess_can_split_ = True
+
+    def test_to_timedelta_on_nanoseconds(self):
+        # GH 9273
+        result = Timedelta(nanoseconds=100)
+        expected = Timedelta('100ns')
+        assert result == expected
+
+        result = Timedelta(days=1, hours=1, minutes=1, weeks=1, seconds=1,
+                           milliseconds=1, microseconds=1, nanoseconds=1)
+        expected = Timedelta(694861001001001)
+        assert result == expected
+
+        result = Timedelta(microseconds=1) + Timedelta(nanoseconds=1)
+        expected = Timedelta('1us1ns')
+        assert result == expected
+
+        result = Timedelta(microseconds=1) - Timedelta(nanoseconds=1)
+        expected = Timedelta('999ns')
+        assert result == expected
+
+        result = Timedelta(microseconds=1) + 5 * Timedelta(nanoseconds=-2)
+        expected = Timedelta('990ns')
+        assert result == expected
+
+        pytest.raises(TypeError, lambda: Timedelta(nanoseconds='abc'))
+
+
 class TestTimedeltas(object):
     _multiprocess_can_split_ = True
 

commit 776530cc62d3d0f58c20a95b79776d9c69a2dbf2
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Feb 5 19:47:25 2019 -0800

    DEPR: remove PanelGroupBy, disable DataFrame.to_panel (#25047)

diff --git a/doc/source/whatsnew/v0.25.0.rst b/doc/source/whatsnew/v0.25.0.rst
index 09626be71..a3fb1c575 100644
--- a/doc/source/whatsnew/v0.25.0.rst
+++ b/doc/source/whatsnew/v0.25.0.rst
@@ -51,7 +51,7 @@ Deprecations
 
 Removal of prior version deprecations/changes
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
+- Removed (parts of) :class:`Panel` (:issue:`25047`)
 -
 -
 -
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 098e65718..0c160d1a2 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1974,45 +1974,7 @@ class DataFrame(NDFrame):
         -------
         panel : Panel
         """
-        # only support this kind for now
-        if (not isinstance(self.index, MultiIndex) or  # pragma: no cover
-                len(self.index.levels) != 2):
-            raise NotImplementedError('Only 2-level MultiIndex are supported.')
-
-        if not self.index.is_unique:
-            raise ValueError("Can't convert non-uniquely indexed "
-                             "DataFrame to Panel")
-
-        self._consolidate_inplace()
-
-        # minor axis must be sorted
-        if self.index.lexsort_depth < 2:
-            selfsorted = self.sort_index(level=0)
-        else:
-            selfsorted = self
-
-        major_axis, minor_axis = selfsorted.index.levels
-        major_codes, minor_codes = selfsorted.index.codes
-        shape = len(major_axis), len(minor_axis)
-
-        # preserve names, if any
-        major_axis = major_axis.copy()
-        major_axis.name = self.index.names[0]
-
-        minor_axis = minor_axis.copy()
-        minor_axis.name = self.index.names[1]
-
-        # create new axes
-        new_axes = [selfsorted.columns, major_axis, minor_axis]
-
-        # create new manager
-        new_mgr = selfsorted._data.reshape_nd(axes=new_axes,
-                                              labels=[major_codes,
-                                                      minor_codes],
-                                              shape=shape,
-                                              ref_items=selfsorted.columns)
-
-        return self._constructor_expanddim(new_mgr)
+        raise NotImplementedError("Panel is being removed in pandas 0.25.0.")
 
     @deprecate_kwarg(old_arg_name='encoding', new_arg_name=None)
     def to_stata(self, fname, convert_dates=None, write_index=True,
diff --git a/pandas/core/groupby/__init__.py b/pandas/core/groupby/__init__.py
index 9c15a5ebf..ac35f3825 100644
--- a/pandas/core/groupby/__init__.py
+++ b/pandas/core/groupby/__init__.py
@@ -1,4 +1,4 @@
 from pandas.core.groupby.groupby import GroupBy  # noqa: F401
 from pandas.core.groupby.generic import (  # noqa: F401
-    SeriesGroupBy, DataFrameGroupBy, PanelGroupBy)
+    SeriesGroupBy, DataFrameGroupBy)
 from pandas.core.groupby.grouper import Grouper  # noqa: F401
diff --git a/pandas/core/groupby/generic.py b/pandas/core/groupby/generic.py
index 78aa6d13a..c8ea9ce68 100644
--- a/pandas/core/groupby/generic.py
+++ b/pandas/core/groupby/generic.py
@@ -1,5 +1,5 @@
 """
-Define the SeriesGroupBy, DataFrameGroupBy, and PanelGroupBy
+Define the SeriesGroupBy and DataFrameGroupBy
 classes that hold the groupby interfaces (and some implementations).
 
 These are user facing as the result of the ``df.groupby(...)`` operations,
@@ -39,7 +39,6 @@ from pandas.core.groupby.groupby import (
 from pandas.core.index import CategoricalIndex, Index, MultiIndex
 import pandas.core.indexes.base as ibase
 from pandas.core.internals import BlockManager, make_block
-from pandas.core.panel import Panel
 from pandas.core.series import Series
 
 from pandas.plotting._core import boxplot_frame_groupby
@@ -1586,90 +1585,3 @@ class DataFrameGroupBy(NDFrameGroupBy):
         return results
 
     boxplot = boxplot_frame_groupby
-
-
-class PanelGroupBy(NDFrameGroupBy):
-
-    def aggregate(self, arg, *args, **kwargs):
-        return super(PanelGroupBy, self).aggregate(arg, *args, **kwargs)
-
-    agg = aggregate
-
-    def _iterate_slices(self):
-        if self.axis == 0:
-            # kludge
-            if self._selection is None:
-                slice_axis = self._selected_obj.items
-            else:
-                slice_axis = self._selection_list
-            slicer = lambda x: self._selected_obj[x]
-        else:
-            raise NotImplementedError("axis other than 0 is not supported")
-
-        for val in slice_axis:
-            if val in self.exclusions:
-                continue
-
-            yield val, slicer(val)
-
-    def aggregate(self, arg, *args, **kwargs):
-        """
-        Aggregate using input function or dict of {column -> function}
-
-        Parameters
-        ----------
-        arg : function or dict
-            Function to use for aggregating groups. If a function, must either
-            work when passed a Panel or when passed to Panel.apply. If
-            pass a dict, the keys must be DataFrame column names
-
-        Returns
-        -------
-        aggregated : Panel
-        """
-        if isinstance(arg, compat.string_types):
-            return getattr(self, arg)(*args, **kwargs)
-
-        return self._aggregate_generic(arg, *args, **kwargs)
-
-    def _wrap_generic_output(self, result, obj):
-        if self.axis == 0:
-            new_axes = list(obj.axes)
-            new_axes[0] = self.grouper.result_index
-        elif self.axis == 1:
-            x, y, z = obj.axes
-            new_axes = [self.grouper.result_index, z, x]
-        else:
-            x, y, z = obj.axes
-            new_axes = [self.grouper.result_index, y, x]
-
-        result = Panel._from_axes(result, new_axes)
-
-        if self.axis == 1:
-            result = result.swapaxes(0, 1).swapaxes(0, 2)
-        elif self.axis == 2:
-            result = result.swapaxes(0, 2)
-
-        return result
-
-    def _aggregate_item_by_item(self, func, *args, **kwargs):
-        obj = self._obj_with_exclusions
-        result = {}
-
-        if self.axis > 0:
-            for item in obj:
-                try:
-                    itemg = DataFrameGroupBy(obj[item],
-                                             axis=self.axis - 1,
-                                             grouper=self.grouper)
-                    result[item] = itemg.aggregate(func, *args, **kwargs)
-                except (ValueError, TypeError):
-                    raise
-            new_axes = list(obj.axes)
-            new_axes[self.axis] = self.grouper.result_index
-            return Panel._from_axes(result, new_axes)
-        else:
-            raise ValueError("axis value must be greater than 0")
-
-    def _wrap_aggregated_output(self, output, names=None):
-        raise AbstractMethodError(self)
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index c8afafde4..de535eeea 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -917,9 +917,7 @@ class Panel(NDFrame):
         -------
         grouped : PanelGroupBy
         """
-        from pandas.core.groupby import PanelGroupBy
-        axis = self._get_axis_number(axis)
-        return PanelGroupBy(self, function, axis=axis)
+        raise NotImplementedError("Panel is removed in pandas 0.25.0")
 
     def to_frame(self, filter_observations=True):
         """
diff --git a/pandas/core/resample.py b/pandas/core/resample.py
index a7204fcd9..fbddc9ff2 100644
--- a/pandas/core/resample.py
+++ b/pandas/core/resample.py
@@ -20,7 +20,7 @@ import pandas as pd
 import pandas.core.algorithms as algos
 from pandas.core.generic import _shared_docs
 from pandas.core.groupby.base import GroupByMixin
-from pandas.core.groupby.generic import PanelGroupBy, SeriesGroupBy
+from pandas.core.groupby.generic import SeriesGroupBy
 from pandas.core.groupby.groupby import (
     GroupBy, _GroupBy, _pipe_template, groupby)
 from pandas.core.groupby.grouper import Grouper
@@ -340,12 +340,7 @@ class Resampler(_GroupBy):
 
         obj = self._selected_obj
 
-        try:
-            grouped = groupby(obj, by=None, grouper=grouper, axis=self.axis)
-        except TypeError:
-
-            # panel grouper
-            grouped = PanelGroupBy(obj, grouper=grouper, axis=self.axis)
+        grouped = groupby(obj, by=None, grouper=grouper, axis=self.axis)
 
         try:
             if isinstance(obj, ABCDataFrame) and compat.callable(how):
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 2ab6ddb5b..00fa01bb2 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -31,7 +31,7 @@ from pandas import (
     PeriodIndex, Series, SparseDataFrame, SparseSeries, TimedeltaIndex, compat,
     concat, isna, to_datetime)
 from pandas.core import config
-from pandas.core.algorithms import match, unique
+from pandas.core.algorithms import unique
 from pandas.core.arrays.categorical import (
     Categorical, _factorize_from_iterables)
 from pandas.core.arrays.sparse import BlockIndex, IntIndex
@@ -3944,29 +3944,7 @@ class LegacyTable(Table):
                 objs.append(obj)
 
         else:
-            warnings.warn(duplicate_doc, DuplicateWarning, stacklevel=5)
-
-            # reconstruct
-            long_index = MultiIndex.from_arrays(
-                [i.values for i in self.index_axes])
-
-            for c in self.values_axes:
-                lp = DataFrame(c.data, index=long_index, columns=c.values)
-
-                # need a better algorithm
-                tuple_index = long_index.values
-
-                unique_tuples = unique(tuple_index)
-                unique_tuples = com.asarray_tuplesafe(unique_tuples)
-
-                indexer = match(unique_tuples, tuple_index)
-                indexer = ensure_platform_int(indexer)
-
-                new_index = long_index.take(indexer)
-                new_values = lp.values.take(indexer, axis=0)
-
-                lp = DataFrame(new_values, index=new_index, columns=lp.columns)
-                objs.append(lp.to_panel())
+            raise NotImplementedError("Panel is removed in pandas 0.25.0")
 
         # create the composite object
         if len(objs) == 1:
@@ -4875,16 +4853,3 @@ class Selection(object):
             return self.coordinates
 
         return np.arange(start, stop)
-
-# utilities ###
-
-
-def timeit(key, df, fn=None, remove=True, **kwargs):
-    if fn is None:
-        fn = 'timeit.h5'
-    store = HDFStore(fn, mode='w')
-    store.append(key, df, **kwargs)
-    store.close()
-
-    if remove:
-        os.remove(fn)
diff --git a/pandas/tests/dtypes/test_generic.py b/pandas/tests/dtypes/test_generic.py
index 1622088d0..2bb3559d5 100644
--- a/pandas/tests/dtypes/test_generic.py
+++ b/pandas/tests/dtypes/test_generic.py
@@ -1,6 +1,6 @@
 # -*- coding: utf-8 -*-
 
-from warnings import catch_warnings, simplefilter
+from warnings import catch_warnings
 
 import numpy as np
 
@@ -39,9 +39,6 @@ class TestABCClasses(object):
         assert isinstance(pd.Int64Index([1, 2, 3]), gt.ABCIndexClass)
         assert isinstance(pd.Series([1, 2, 3]), gt.ABCSeries)
         assert isinstance(self.df, gt.ABCDataFrame)
-        with catch_warnings(record=True):
-            simplefilter('ignore', FutureWarning)
-            assert isinstance(self.df.to_panel(), gt.ABCPanel)
         assert isinstance(self.sparse_series, gt.ABCSparseSeries)
         assert isinstance(self.sparse_array, gt.ABCSparseArray)
         assert isinstance(self.sparse_frame, gt.ABCSparseDataFrame)
diff --git a/pandas/tests/frame/test_subclass.py b/pandas/tests/frame/test_subclass.py
index 4f0747c0d..2e3696e7e 100644
--- a/pandas/tests/frame/test_subclass.py
+++ b/pandas/tests/frame/test_subclass.py
@@ -6,7 +6,7 @@ import numpy as np
 import pytest
 
 import pandas as pd
-from pandas import DataFrame, Index, MultiIndex, Panel, Series
+from pandas import DataFrame, Index, MultiIndex, Series
 from pandas.tests.frame.common import TestData
 import pandas.util.testing as tm
 
@@ -125,29 +125,6 @@ class TestDataFrameSubclassing(TestData):
         tm.assert_series_equal(res, exp)
         assert isinstance(res, tm.SubclassedSeries)
 
-    @pytest.mark.filterwarnings("ignore:\\nPanel:FutureWarning")
-    def test_to_panel_expanddim(self):
-        # GH 9762
-
-        class SubclassedFrame(DataFrame):
-
-            @property
-            def _constructor_expanddim(self):
-                return SubclassedPanel
-
-        class SubclassedPanel(Panel):
-            pass
-
-        index = MultiIndex.from_tuples([(0, 0), (0, 1), (0, 2)])
-        df = SubclassedFrame({'X': [1, 2, 3], 'Y': [4, 5, 6]}, index=index)
-        result = df.to_panel()
-        assert isinstance(result, SubclassedPanel)
-        expected = SubclassedPanel([[[1, 2, 3]], [[4, 5, 6]]],
-                                   items=['X', 'Y'], major_axis=[0],
-                                   minor_axis=[0, 1, 2],
-                                   dtype='int64')
-        tm.assert_panel_equal(result, expected)
-
     def test_subclass_attr_err_propagation(self):
         # GH 11808
         class A(DataFrame):
diff --git a/pandas/tests/groupby/test_groupby.py b/pandas/tests/groupby/test_groupby.py
index 98c917a6e..0bfc7abab 100644
--- a/pandas/tests/groupby/test_groupby.py
+++ b/pandas/tests/groupby/test_groupby.py
@@ -1239,31 +1239,6 @@ def test_sparse_friendly(df):
     # _check_work(panel.groupby(lambda x: x.month, axis=1))
 
 
-@pytest.mark.filterwarnings("ignore:\\nPanel:FutureWarning")
-def test_panel_groupby():
-    panel = tm.makePanel()
-    tm.add_nans(panel)
-    grouped = panel.groupby({'ItemA': 0, 'ItemB': 0, 'ItemC': 1},
-                            axis='items')
-    agged = grouped.mean()
-    agged2 = grouped.agg(lambda x: x.mean('items'))
-
-    tm.assert_panel_equal(agged, agged2)
-
-    tm.assert_index_equal(agged.items, Index([0, 1]))
-
-    grouped = panel.groupby(lambda x: x.month, axis='major')
-    agged = grouped.mean()
-
-    exp = Index(sorted(list(set(panel.major_axis.month))))
-    tm.assert_index_equal(agged.major_axis, exp)
-
-    grouped = panel.groupby({'A': 0, 'B': 0, 'C': 1, 'D': 1},
-                            axis='minor')
-    agged = grouped.mean()
-    tm.assert_index_equal(agged.minor_axis, Index([0, 1]))
-
-
 def test_groupby_2d_malformed():
     d = DataFrame(index=lrange(2))
     d['group'] = ['g1', 'g2']
diff --git a/pandas/tests/groupby/test_grouping.py b/pandas/tests/groupby/test_grouping.py
index a509a7cb5..44b5bd5f1 100644
--- a/pandas/tests/groupby/test_grouping.py
+++ b/pandas/tests/groupby/test_grouping.py
@@ -14,8 +14,7 @@ from pandas import (
 from pandas.core.groupby.grouper import Grouping
 import pandas.util.testing as tm
 from pandas.util.testing import (
-    assert_almost_equal, assert_frame_equal, assert_panel_equal,
-    assert_series_equal)
+    assert_almost_equal, assert_frame_equal, assert_series_equal)
 
 # selection
 # --------------------------------
@@ -563,17 +562,7 @@ class TestGrouping():
 # --------------------------------
 
 class TestGetGroup():
-
-    @pytest.mark.filterwarnings("ignore:\\nPanel:FutureWarning")
     def test_get_group(self):
-        wp = tm.makePanel()
-        grouped = wp.groupby(lambda x: x.month, axis='major')
-
-        gp = grouped.get_group(1)
-        expected = wp.reindex(
-            major=[x for x in wp.major_axis if x.month == 1])
-        assert_panel_equal(gp, expected)
-
         # GH 5267
         # be datelike friendly
         df = DataFrame({'DATE': pd.to_datetime(
@@ -755,19 +744,6 @@ class TestIteration():
         for key, group in grouped:
             pass
 
-    @pytest.mark.filterwarnings("ignore:\\nPanel:FutureWarning")
-    def test_multi_iter_panel(self):
-        wp = tm.makePanel()
-        grouped = wp.groupby([lambda x: x.month, lambda x: x.weekday()],
-                             axis=1)
-
-        for (month, wd), group in grouped:
-            exp_axis = [x
-                        for x in wp.major_axis
-                        if x.month == month and x.weekday() == wd]
-            expected = wp.reindex(major=exp_axis)
-            assert_panel_equal(group, expected)
-
     def test_dictify(self, df):
         dict(iter(df.groupby('A')))
         dict(iter(df.groupby(['A', 'B'])))
diff --git a/pandas/tests/io/test_pytables.py b/pandas/tests/io/test_pytables.py
index 943001128..c339c3375 100644
--- a/pandas/tests/io/test_pytables.py
+++ b/pandas/tests/io/test_pytables.py
@@ -3050,29 +3050,6 @@ class TestHDFStore(Base):
             result = store.select('df', columns=['B', 'A'])
             assert_frame_equal(result, expected, by_blocks=True)
 
-    @pytest.mark.filterwarnings(
-        "ignore:\\nduplicate:pandas.io.pytables.DuplicateWarning"
-    )
-    def test_wide_table_dups(self):
-        with ensure_clean_store(self.path) as store:
-            with catch_warnings(record=True):
-
-                wp = tm.makePanel()
-                store.put('panel', wp, format='table')
-                store.put('panel', wp, format='table', append=True)
-
-                recons = store['panel']
-
-                assert_panel_equal(recons, wp)
-
-    def test_long(self):
-        def _check(left, right):
-            assert_panel_equal(left.to_panel(), right.to_panel())
-
-        with catch_warnings(record=True):
-            wp = tm.makePanel()
-            self._check_roundtrip(wp.to_frame(), _check)
-
     def test_overwrite_node(self):
 
         with ensure_clean_store(self.path) as store:
diff --git a/pandas/tests/resample/test_datetime_index.py b/pandas/tests/resample/test_datetime_index.py
index 856c4df53..ceccb4819 100644
--- a/pandas/tests/resample/test_datetime_index.py
+++ b/pandas/tests/resample/test_datetime_index.py
@@ -1,6 +1,5 @@
 from datetime import datetime, timedelta
 from functools import partial
-from warnings import catch_warnings, simplefilter
 
 import numpy as np
 import pytest
@@ -10,7 +9,7 @@ from pandas.compat import StringIO, range
 from pandas.errors import UnsupportedFunctionCall
 
 import pandas as pd
-from pandas import DataFrame, Panel, Series, Timedelta, Timestamp, isna, notna
+from pandas import DataFrame, Series, Timedelta, Timestamp, isna, notna
 from pandas.core.indexes.datetimes import date_range
 from pandas.core.indexes.period import Period, period_range
 from pandas.core.resample import (
@@ -692,56 +691,6 @@ def test_resample_axis1():
     tm.assert_frame_equal(result, expected)
 
 
-def test_resample_panel():
-    rng = date_range('1/1/2000', '6/30/2000')
-    n = len(rng)
-
-    with catch_warnings(record=True):
-        simplefilter("ignore", FutureWarning)
-        panel = Panel(np.random.randn(3, n, 5),
-                      items=['one', 'two', 'three'],
-                      major_axis=rng,
-                      minor_axis=['a', 'b', 'c', 'd', 'e'])
-
-        result = panel.resample('M', axis=1).mean()
-
-        def p_apply(panel, f):
-            result = {}
-            for item in panel.items:
-                result[item] = f(panel[item])
-            return Panel(result, items=panel.items)
-
-        expected = p_apply(panel, lambda x: x.resample('M').mean())
-        tm.assert_panel_equal(result, expected)
-
-        panel2 = panel.swapaxes(1, 2)
-        result = panel2.resample('M', axis=2).mean()
-        expected = p_apply(panel2,
-                           lambda x: x.resample('M', axis=1).mean())
-        tm.assert_panel_equal(result, expected)
-
-
-@pytest.mark.filterwarnings("ignore:\\nPanel:FutureWarning")
-def test_resample_panel_numpy():
-    rng = date_range('1/1/2000', '6/30/2000')
-    n = len(rng)
-
-    with catch_warnings(record=True):
-        panel = Panel(np.random.randn(3, n, 5),
-                      items=['one', 'two', 'three'],
-                      major_axis=rng,
-                      minor_axis=['a', 'b', 'c', 'd', 'e'])
-
-        result = panel.resample('M', axis=1).apply(lambda x: x.mean(1))
-        expected = panel.resample('M', axis=1).mean()
-        tm.assert_panel_equal(result, expected)
-
-        panel = panel.swapaxes(1, 2)
-        result = panel.resample('M', axis=2).apply(lambda x: x.mean(2))
-        expected = panel.resample('M', axis=2).mean()
-        tm.assert_panel_equal(result, expected)
-
-
 def test_resample_anchored_ticks():
     # If a fixed delta (5 minute, 4 hour) evenly divides a day, we should
     # "anchor" the origin at midnight so we get regular intervals rather
diff --git a/pandas/tests/resample/test_time_grouper.py b/pandas/tests/resample/test_time_grouper.py
index a4eb79337..2f330d1f2 100644
--- a/pandas/tests/resample/test_time_grouper.py
+++ b/pandas/tests/resample/test_time_grouper.py
@@ -5,7 +5,7 @@ import numpy as np
 import pytest
 
 import pandas as pd
-from pandas import DataFrame, Panel, Series
+from pandas import DataFrame, Series
 from pandas.core.indexes.datetimes import date_range
 from pandas.core.resample import TimeGrouper
 import pandas.util.testing as tm
@@ -79,27 +79,6 @@ def test_apply_iteration():
     tm.assert_index_equal(result.index, df.index)
 
 
-@pytest.mark.filterwarnings("ignore:\\nPanel:FutureWarning")
-def test_panel_aggregation():
-    ind = pd.date_range('1/1/2000', periods=100)
-    data = np.random.randn(2, len(ind), 4)
-
-    wp = Panel(data, items=['Item1', 'Item2'], major_axis=ind,
-               minor_axis=['A', 'B', 'C', 'D'])
-
-    tg = TimeGrouper('M', axis=1)
-    _, grouper, _ = tg._get_grouper(wp)
-    bingrouped = wp.groupby(grouper)
-    binagg = bingrouped.mean()
-
-    def f(x):
-        assert (isinstance(x, Panel))
-        return x.mean(1)
-
-    result = bingrouped.agg(f)
-    tm.assert_panel_equal(result, binagg)
-
-
 @pytest.mark.parametrize('name, func', [
     ('Int64Index', tm.makeIntIndex),
     ('Index', tm.makeUnicodeIndex),
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index ba0ad72e6..6b20acc84 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -1653,61 +1653,6 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
         panel.values[0, 1, 1] = np.nan
         assert notna(result.values[1, 0, 1])
 
-    def test_to_frame(self):
-        # filtered
-        filtered = self.panel.to_frame()
-        expected = self.panel.to_frame().dropna(how='any')
-        assert_frame_equal(filtered, expected)
-
-        # unfiltered
-        unfiltered = self.panel.to_frame(filter_observations=False)
-        assert_panel_equal(unfiltered.to_panel(), self.panel)
-
-        # names
-        assert unfiltered.index.names == ('major', 'minor')
-
-        # unsorted, round trip
-        df = self.panel.to_frame(filter_observations=False)
-        unsorted = df.take(np.random.permutation(len(df)))
-        pan = unsorted.to_panel()
-        assert_panel_equal(pan, self.panel)
-
-        # preserve original index names
-        df = DataFrame(np.random.randn(6, 2),
-                       index=[['a', 'a', 'b', 'b', 'c', 'c'],
-                              [0, 1, 0, 1, 0, 1]],
-                       columns=['one', 'two'])
-        df.index.names = ['foo', 'bar']
-        df.columns.name = 'baz'
-
-        rdf = df.to_panel().to_frame()
-        assert rdf.index.names == df.index.names
-        assert rdf.columns.names == df.columns.names
-
-    def test_to_frame_mixed(self):
-        panel = self.panel.fillna(0)
-        panel['str'] = 'foo'
-        panel['bool'] = panel['ItemA'] > 0
-
-        lp = panel.to_frame()
-        wp = lp.to_panel()
-        assert wp['bool'].values.dtype == np.bool_
-        # Previously, this was mutating the underlying
-        # index and changing its name
-        assert_frame_equal(wp['bool'], panel['bool'], check_names=False)
-
-        # GH 8704
-        # with categorical
-        df = panel.to_frame()
-        df['category'] = df['str'].astype('category')
-
-        # to_panel
-        # TODO: this converts back to object
-        p = df.to_panel()
-        expected = panel.copy()
-        expected['category'] = 'foo'
-        assert_panel_equal(p, expected)
-
     def test_to_frame_multi_major(self):
         idx = MultiIndex.from_tuples(
             [(1, 'one'), (1, 'two'), (2, 'one'), (2, 'two')])
@@ -1808,22 +1753,6 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
         expected = DataFrame({'i1': [1., 2], 'i2': [1., 2]}, index=exp_idx)
         assert_frame_equal(result, expected)
 
-    def test_to_panel_na_handling(self):
-        df = DataFrame(np.random.randint(0, 10, size=20).reshape((10, 2)),
-                       index=[[0, 0, 0, 0, 0, 0, 1, 1, 1, 1],
-                              [0, 1, 2, 3, 4, 5, 2, 3, 4, 5]])
-
-        panel = df.to_panel()
-        assert isna(panel[0].loc[1, [0, 1]]).all()
-
-    def test_to_panel_duplicates(self):
-        # #2441
-        df = DataFrame({'a': [0, 0, 1], 'b': [1, 1, 1], 'c': [1, 2, 3]})
-        idf = df.set_index(['a', 'b'])
-
-        with pytest.raises(ValueError, match='non-uniquely indexed'):
-            idf.to_panel()
-
     def test_panel_dups(self):
 
         # GH 4960
@@ -2121,14 +2050,6 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
         self.panel['i'] = self.panel['ItemA']
         assert_frame_equal(self.panel['i'], self.panel.i)
 
-    def test_from_frame_level1_unsorted(self):
-        tuples = [('MSFT', 3), ('MSFT', 2), ('AAPL', 2), ('AAPL', 1),
-                  ('MSFT', 1)]
-        midx = MultiIndex.from_tuples(tuples)
-        df = DataFrame(np.random.rand(5, 4), index=midx)
-        p = df.to_panel()
-        assert_frame_equal(p.minor_xs(2), df.xs(2, level=1).sort_index())
-
     def test_to_excel(self):
         try:
             import xlwt  # noqa
@@ -2404,40 +2325,11 @@ class TestPanelFrame(object):
         self.panel = panel.to_frame()
         self.unfiltered_panel = panel.to_frame(filter_observations=False)
 
-    def test_ops_differently_indexed(self):
-        # trying to set non-identically indexed panel
-        wp = self.panel.to_panel()
-        wp2 = wp.reindex(major=wp.major_axis[:-1])
-        lp2 = wp2.to_frame()
-
-        result = self.panel + lp2
-        assert_frame_equal(result.reindex(lp2.index), lp2 * 2)
-
-        # careful, mutation
-        self.panel['foo'] = lp2['ItemA']
-        assert_series_equal(self.panel['foo'].reindex(lp2.index),
-                            lp2['ItemA'],
-                            check_names=False)
-
     def test_ops_scalar(self):
         result = self.panel.mul(2)
         expected = DataFrame.__mul__(self.panel, 2)
         assert_frame_equal(result, expected)
 
-    def test_combineFrame(self):
-        wp = self.panel.to_panel()
-        result = self.panel.add(wp['ItemA'].stack(), axis=0)
-        assert_frame_equal(result.to_panel()['ItemA'], wp['ItemA'] * 2)
-
-    def test_combinePanel(self):
-        wp = self.panel.to_panel()
-        result = self.panel.add(self.panel)
-        wide_result = result.to_panel()
-        assert_frame_equal(wp['ItemA'] * 2, wide_result['ItemA'])
-
-        # one item
-        result = self.panel.add(self.panel.filter(['ItemA']))
-
     def test_combine_scalar(self):
         result = self.panel.mul(2)
         expected = DataFrame(self.panel._data) * 2
@@ -2454,34 +2346,6 @@ class TestPanelFrame(object):
         expected = DataFrame.add(self.panel, s, axis=1)
         assert_frame_equal(result, expected)
 
-    def test_operators(self):
-        wp = self.panel.to_panel()
-        result = (self.panel + 1).to_panel()
-        assert_frame_equal(wp['ItemA'] + 1, result['ItemA'])
-
-    def test_arith_flex_panel(self):
-        ops = ['add', 'sub', 'mul', 'div',
-               'truediv', 'pow', 'floordiv', 'mod']
-        if not compat.PY3:
-            aliases = {}
-        else:
-            aliases = {'div': 'truediv'}
-        self.panel = self.panel.to_panel()
-
-        for n in [np.random.randint(-50, -1), np.random.randint(1, 50), 0]:
-            for op in ops:
-                alias = aliases.get(op, op)
-                f = getattr(operator, alias)
-                exp = f(self.panel, n)
-                result = getattr(self.panel, op)(n)
-                assert_panel_equal(result, exp, check_panel_type=True)
-
-                # rops
-                r_f = lambda x, y: f(y, x)
-                exp = r_f(self.panel, n)
-                result = getattr(self.panel, 'r' + op)(n)
-                assert_panel_equal(result, exp)
-
     def test_sort(self):
         def is_sorted(arr):
             return (arr[1:] > arr[:-1]).any()
@@ -2502,45 +2366,6 @@ class TestPanelFrame(object):
             with pytest.raises(NotImplementedError, match=msg):
                 self.panel.to_sparse
 
-    def test_truncate(self):
-        dates = self.panel.index.levels[0]
-        start, end = dates[1], dates[5]
-
-        trunced = self.panel.truncate(start, end).to_panel()
-        expected = self.panel.to_panel()['ItemA'].truncate(start, end)
-
-        # TODO truncate drops index.names
-        assert_frame_equal(trunced['ItemA'], expected, check_names=False)
-
-        trunced = self.panel.truncate(before=start).to_panel()
-        expected = self.panel.to_panel()['ItemA'].truncate(before=start)
-
-        # TODO truncate drops index.names
-        assert_frame_equal(trunced['ItemA'], expected, check_names=False)
-
-        trunced = self.panel.truncate(after=end).to_panel()
-        expected = self.panel.to_panel()['ItemA'].truncate(after=end)
-
-        # TODO truncate drops index.names
-        assert_frame_equal(trunced['ItemA'], expected, check_names=False)
-
-        # truncate on dates that aren't in there
-        wp = self.panel.to_panel()
-        new_index = wp.major_axis[::5]
-
-        wp2 = wp.reindex(major=new_index)
-
-        lp2 = wp2.to_frame()
-        lp_trunc = lp2.truncate(wp.major_axis[2], wp.major_axis[-2])
-
-        wp_trunc = wp2.truncate(wp.major_axis[2], wp.major_axis[-2])
-
-        assert_panel_equal(wp_trunc, lp_trunc.to_panel())
-
-        # throw proper exception
-        pytest.raises(Exception, lp2.truncate, wp.major_axis[-2],
-                      wp.major_axis[2])
-
     def test_axis_dummies(self):
         from pandas.core.reshape.reshape import make_axis_dummies
 
@@ -2567,20 +2392,6 @@ class TestPanelFrame(object):
         dummies = get_dummies(self.panel['Label'])
         tm.assert_numpy_array_equal(dummies.values, minor_dummies.values)
 
-    def test_mean(self):
-        means = self.panel.mean(level='minor')
-
-        # test versus Panel version
-        wide_means = self.panel.to_panel().mean('major')
-        assert_frame_equal(means, wide_means)
-
-    def test_sum(self):
-        sums = self.panel.sum(level='minor')
-
-        # test versus Panel version
-        wide_sums = self.panel.to_panel().sum('major')
-        assert_frame_equal(sums, wide_sums)
-
     def test_count(self):
         index = self.panel.index
 

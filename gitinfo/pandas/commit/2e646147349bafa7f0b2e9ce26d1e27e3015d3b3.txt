commit 2e646147349bafa7f0b2e9ce26d1e27e3015d3b3
Author: Jeff Reback <jeff@reback.net>
Date:   Tue Mar 28 18:42:31 2017 -0400

    COMPAT: Fix indent level bug preventing wrapper function rename
    
    Original code intends to rename the wrapper function f using the
    provided name, but this isn't happening because code is incorrectly
    indented an extra level.
    
    from pandas.core.groupby import GroupBy
    GroupBy.sum.__name__
    Should be 'sum'.
    
    Author: Jeff Reback <jeff@reback.net>
    Author: Matt Hagy <matt@liveramp.com>
    Author: Matt Hagy <hagy@gatech.edu>
    
    Closes #14620 from matthagy/patch-1 and squashes the following commits:
    
    db3c6e4 [Jeff Reback] clean/reorg tests
    205489b [Jeff Reback] doc
    8b185b4 [Jeff Reback] PEP
    781b9b3 [Jeff Reback] Move _groupby_function inside GroupBy
    68013bf [Matt Hagy] Added a test for known inconsistent attribute/method names
    3bf8993 [Matt Hagy] Revise attribute/method consistency check to skip known inconsistencies
    033e42d [Matt Hagy] Test for consistency of attribute and method names
    2a54b77 [Matt Hagy] Test renaming of _groupby_function wrapper function
    a492b5a [Matt Hagy] Fix indent level bug preventing wrapper function rename

diff --git a/doc/source/whatsnew/v0.20.0.txt b/doc/source/whatsnew/v0.20.0.txt
index 638044cee..787857095 100644
--- a/doc/source/whatsnew/v0.20.0.txt
+++ b/doc/source/whatsnew/v0.20.0.txt
@@ -887,6 +887,7 @@ Bug Fixes
 
 - Compat for 32-bit platforms for ``.qcut/cut``; bins will now be ``int64`` dtype (:issue:`14866`)
 
+- Properly set ``__name__`` and ``__qualname__`` for ``Groupby.*`` functions (:issue:`14620`)
 - Bug in ``.at`` when selecting from a tz-aware column (:issue:`15822`)
 - Bug in the display of ``.info()`` where a qualifier (+) would always be displayed with a ``MultiIndex`` that contains only non-strings (:issue:`15245`)
 - Bug in ``.replace()`` may result in incorrect dtypes. (:issue:`12747`, :issue:`15765`)
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 2cc68bcab..fe764a099 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -12,8 +12,8 @@ from pandas.compat import (
 )
 
 from pandas import compat
-from pandas.compat.numpy import function as nv
-from pandas.compat.numpy import _np_version_under1p8
+from pandas.compat.numpy import function as nv, _np_version_under1p8
+from pandas.compat import set_function_name
 
 from pandas.types.common import (is_numeric_dtype,
                                  is_timedelta64_dtype, is_datetime64_dtype,
@@ -172,64 +172,6 @@ _cython_transforms = frozenset(['cumprod', 'cumsum', 'shift',
                                 'cummin', 'cummax'])
 
 
-def _groupby_function(name, alias, npfunc, numeric_only=True,
-                      _convert=False):
-
-    _local_template = "Compute %(f)s of group values"
-
-    @Substitution(name='groupby', f=name)
-    @Appender(_doc_template)
-    @Appender(_local_template)
-    def f(self, **kwargs):
-        if 'numeric_only' not in kwargs:
-            kwargs['numeric_only'] = numeric_only
-        self._set_group_selection()
-        try:
-            return self._cython_agg_general(alias, alt=npfunc, **kwargs)
-        except AssertionError as e:
-            raise SpecificationError(str(e))
-        except Exception:
-            result = self.aggregate(lambda x: npfunc(x, axis=self.axis))
-            if _convert:
-                result = result._convert(datetime=True)
-            return result
-
-        f.__name__ = name
-
-    return f
-
-
-def _first_compat(x, axis=0):
-
-    def _first(x):
-
-        x = np.asarray(x)
-        x = x[notnull(x)]
-        if len(x) == 0:
-            return np.nan
-        return x[0]
-
-    if isinstance(x, DataFrame):
-        return x.apply(_first, axis=axis)
-    else:
-        return _first(x)
-
-
-def _last_compat(x, axis=0):
-    def _last(x):
-
-        x = np.asarray(x)
-        x = x[notnull(x)]
-        if len(x) == 0:
-            return np.nan
-        return x[-1]
-
-    if isinstance(x, DataFrame):
-        return x.apply(_last, axis=axis)
-    else:
-        return _last(x)
-
-
 class Grouper(object):
     """
     A Grouper allows the user to specify a groupby instruction for a target
@@ -1184,14 +1126,76 @@ class GroupBy(_GroupBy):
             result.name = getattr(self, 'name', None)
         return result
 
-    sum = _groupby_function('sum', 'add', np.sum)
-    prod = _groupby_function('prod', 'prod', np.prod)
-    min = _groupby_function('min', 'min', np.min, numeric_only=False)
-    max = _groupby_function('max', 'max', np.max, numeric_only=False)
-    first = _groupby_function('first', 'first', _first_compat,
-                              numeric_only=False, _convert=True)
-    last = _groupby_function('last', 'last', _last_compat, numeric_only=False,
-                             _convert=True)
+    @classmethod
+    def _add_numeric_operations(cls):
+        """ add numeric operations to the GroupBy generically """
+
+        def groupby_function(name, alias, npfunc,
+                             numeric_only=True, _convert=False):
+
+            _local_template = "Compute %(f)s of group values"
+
+            @Substitution(name='groupby', f=name)
+            @Appender(_doc_template)
+            @Appender(_local_template)
+            def f(self, **kwargs):
+                if 'numeric_only' not in kwargs:
+                    kwargs['numeric_only'] = numeric_only
+                self._set_group_selection()
+                try:
+                    return self._cython_agg_general(
+                        alias, alt=npfunc, **kwargs)
+                except AssertionError as e:
+                    raise SpecificationError(str(e))
+                except Exception:
+                    result = self.aggregate(
+                        lambda x: npfunc(x, axis=self.axis))
+                    if _convert:
+                        result = result._convert(datetime=True)
+                    return result
+
+            set_function_name(f, name, cls)
+
+            return f
+
+        def first_compat(x, axis=0):
+
+            def first(x):
+
+                x = np.asarray(x)
+                x = x[notnull(x)]
+                if len(x) == 0:
+                    return np.nan
+                return x[0]
+
+            if isinstance(x, DataFrame):
+                return x.apply(first, axis=axis)
+            else:
+                return first(x)
+
+        def last_compat(x, axis=0):
+
+            def last(x):
+
+                x = np.asarray(x)
+                x = x[notnull(x)]
+                if len(x) == 0:
+                    return np.nan
+                return x[-1]
+
+            if isinstance(x, DataFrame):
+                return x.apply(last, axis=axis)
+            else:
+                return last(x)
+
+        cls.sum = groupby_function('sum', 'add', np.sum)
+        cls.prod = groupby_function('prod', 'prod', np.prod)
+        cls.min = groupby_function('min', 'min', np.min, numeric_only=False)
+        cls.max = groupby_function('max', 'max', np.max, numeric_only=False)
+        cls.first = groupby_function('first', 'first', first_compat,
+                                     numeric_only=False, _convert=True)
+        cls.last = groupby_function('last', 'last', last_compat,
+                                    numeric_only=False, _convert=True)
 
     @Substitution(name='groupby')
     @Appender(_doc_template)
@@ -1604,6 +1608,9 @@ class GroupBy(_GroupBy):
         return self._selected_obj[mask]
 
 
+GroupBy._add_numeric_operations()
+
+
 @Appender(GroupBy.__doc__)
 def groupby(obj, by, **kwds):
     if isinstance(obj, Series):
diff --git a/pandas/tests/groupby/common.py b/pandas/tests/groupby/common.py
index 8a70777d0..f3dccf473 100644
--- a/pandas/tests/groupby/common.py
+++ b/pandas/tests/groupby/common.py
@@ -1,10 +1,31 @@
 """ Base setup """
 
+import pytest
 import numpy as np
 from pandas.util import testing as tm
 from pandas import DataFrame, MultiIndex
 
 
+@pytest.fixture
+def mframe():
+    index = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux'], ['one', 'two',
+                                                              'three']],
+                       labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3],
+                               [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],
+                       names=['first', 'second'])
+    return DataFrame(np.random.randn(10, 3), index=index,
+                     columns=['A', 'B', 'C'])
+
+
+@pytest.fixture
+def df():
+    return DataFrame(
+        {'A': ['foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'foo'],
+         'B': ['one', 'one', 'two', 'three', 'two', 'two', 'one', 'three'],
+         'C': np.random.randn(8),
+         'D': np.random.randn(8)})
+
+
 class MixIn(object):
 
     def setUp(self):
@@ -15,12 +36,7 @@ class MixIn(object):
         self.frame = DataFrame(self.seriesd)
         self.tsframe = DataFrame(self.tsd)
 
-        self.df = DataFrame(
-            {'A': ['foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'foo'],
-             'B': ['one', 'one', 'two', 'three', 'two', 'two', 'one', 'three'],
-             'C': np.random.randn(8),
-             'D': np.random.randn(8)})
-
+        self.df = df()
         self.df_mixed_floats = DataFrame(
             {'A': ['foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'foo'],
              'B': ['one', 'one', 'two', 'three', 'two', 'two', 'one', 'three'],
@@ -28,13 +44,7 @@ class MixIn(object):
              'D': np.array(
                  np.random.randn(8), dtype='float32')})
 
-        index = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux'], ['one', 'two',
-                                                                  'three']],
-                           labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3],
-                                   [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],
-                           names=['first', 'second'])
-        self.mframe = DataFrame(np.random.randn(10, 3), index=index,
-                                columns=['A', 'B', 'C'])
+        self.mframe = mframe()
 
         self.three_group = DataFrame(
             {'A': ['foo', 'foo', 'foo', 'foo', 'bar', 'bar', 'bar', 'bar',
diff --git a/pandas/tests/groupby/test_groupby.py b/pandas/tests/groupby/test_groupby.py
index 9f5a7f404..83502434e 100644
--- a/pandas/tests/groupby/test_groupby.py
+++ b/pandas/tests/groupby/test_groupby.py
@@ -3706,229 +3706,6 @@ class TestGroupBy(MixIn, tm.TestCase):
         expected = ser.take([1, 3, 4])
         assert_series_equal(actual, expected)
 
-    def test_groupby_selection_with_methods(self):
-        # some methods which require DatetimeIndex
-        rng = pd.date_range('2014', periods=len(self.df))
-        self.df.index = rng
-
-        g = self.df.groupby(['A'])[['C']]
-        g_exp = self.df[['C']].groupby(self.df['A'])
-        # TODO check groupby with > 1 col ?
-
-        # methods which are called as .foo()
-        methods = ['count',
-                   'corr',
-                   'cummax',
-                   'cummin',
-                   'cumprod',
-                   'describe',
-                   'rank',
-                   'quantile',
-                   'diff',
-                   'shift',
-                   'all',
-                   'any',
-                   'idxmin',
-                   'idxmax',
-                   'ffill',
-                   'bfill',
-                   'pct_change',
-                   'tshift']
-
-        for m in methods:
-            res = getattr(g, m)()
-            exp = getattr(g_exp, m)()
-            assert_frame_equal(res, exp)  # should always be frames!
-
-        # methods which aren't just .foo()
-        assert_frame_equal(g.fillna(0), g_exp.fillna(0))
-        assert_frame_equal(g.dtypes, g_exp.dtypes)
-        assert_frame_equal(g.apply(lambda x: x.sum()),
-                           g_exp.apply(lambda x: x.sum()))
-
-        assert_frame_equal(g.resample('D').mean(), g_exp.resample('D').mean())
-        assert_frame_equal(g.resample('D').ohlc(),
-                           g_exp.resample('D').ohlc())
-
-        assert_frame_equal(g.filter(lambda x: len(x) == 3),
-                           g_exp.filter(lambda x: len(x) == 3))
-
-    def test_groupby_whitelist(self):
-        from string import ascii_lowercase
-        letters = np.array(list(ascii_lowercase))
-        N = 10
-        random_letters = letters.take(np.random.randint(0, 26, N))
-        df = DataFrame({'floats': N / 10 * Series(np.random.random(N)),
-                        'letters': Series(random_letters)})
-        s = df.floats
-
-        df_whitelist = frozenset([
-            'last',
-            'first',
-            'mean',
-            'sum',
-            'min',
-            'max',
-            'head',
-            'tail',
-            'cumcount',
-            'resample',
-            'rank',
-            'quantile',
-            'fillna',
-            'mad',
-            'any',
-            'all',
-            'take',
-            'idxmax',
-            'idxmin',
-            'shift',
-            'tshift',
-            'ffill',
-            'bfill',
-            'pct_change',
-            'skew',
-            'plot',
-            'boxplot',
-            'hist',
-            'median',
-            'dtypes',
-            'corrwith',
-            'corr',
-            'cov',
-            'diff',
-        ])
-        s_whitelist = frozenset([
-            'last',
-            'first',
-            'mean',
-            'sum',
-            'min',
-            'max',
-            'head',
-            'tail',
-            'cumcount',
-            'resample',
-            'rank',
-            'quantile',
-            'fillna',
-            'mad',
-            'any',
-            'all',
-            'take',
-            'idxmax',
-            'idxmin',
-            'shift',
-            'tshift',
-            'ffill',
-            'bfill',
-            'pct_change',
-            'skew',
-            'plot',
-            'hist',
-            'median',
-            'dtype',
-            'corr',
-            'cov',
-            'diff',
-            'unique',
-            'nlargest',
-            'nsmallest',
-        ])
-
-        for obj, whitelist in zip((df, s), (df_whitelist, s_whitelist)):
-            gb = obj.groupby(df.letters)
-            self.assertEqual(whitelist, gb._apply_whitelist)
-            for m in whitelist:
-                getattr(type(gb), m)
-
-    AGG_FUNCTIONS = ['sum', 'prod', 'min', 'max', 'median', 'mean', 'skew',
-                     'mad', 'std', 'var', 'sem']
-    AGG_FUNCTIONS_WITH_SKIPNA = ['skew', 'mad']
-
-    def test_regression_whitelist_methods(self):
-
-        # GH6944
-        # explicity test the whitelest methods
-        index = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux'], ['one', 'two',
-                                                                  'three']],
-                           labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3],
-                                   [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],
-                           names=['first', 'second'])
-        raw_frame = DataFrame(np.random.randn(10, 3), index=index,
-                              columns=Index(['A', 'B', 'C'], name='exp'))
-        raw_frame.iloc[1, [1, 2]] = np.nan
-        raw_frame.iloc[7, [0, 1]] = np.nan
-
-        for op, level, axis, skipna in cart_product(self.AGG_FUNCTIONS,
-                                                    lrange(2), lrange(2),
-                                                    [True, False]):
-
-            if axis == 0:
-                frame = raw_frame
-            else:
-                frame = raw_frame.T
-
-            if op in self.AGG_FUNCTIONS_WITH_SKIPNA:
-                grouped = frame.groupby(level=level, axis=axis)
-                result = getattr(grouped, op)(skipna=skipna)
-                expected = getattr(frame, op)(level=level, axis=axis,
-                                              skipna=skipna)
-                assert_frame_equal(result, expected)
-            else:
-                grouped = frame.groupby(level=level, axis=axis)
-                result = getattr(grouped, op)()
-                expected = getattr(frame, op)(level=level, axis=axis)
-                assert_frame_equal(result, expected)
-
-    def test_groupby_blacklist(self):
-        from string import ascii_lowercase
-        letters = np.array(list(ascii_lowercase))
-        N = 10
-        random_letters = letters.take(np.random.randint(0, 26, N))
-        df = DataFrame({'floats': N / 10 * Series(np.random.random(N)),
-                        'letters': Series(random_letters)})
-        s = df.floats
-
-        blacklist = [
-            'eval', 'query', 'abs', 'where',
-            'mask', 'align', 'groupby', 'clip', 'astype',
-            'at', 'combine', 'consolidate', 'convert_objects',
-        ]
-        to_methods = [method for method in dir(df) if method.startswith('to_')]
-
-        blacklist.extend(to_methods)
-
-        # e.g., to_csv
-        defined_but_not_allowed = ("(?:^Cannot.+{0!r}.+{1!r}.+try using the "
-                                   "'apply' method$)")
-
-        # e.g., query, eval
-        not_defined = "(?:^{1!r} object has no attribute {0!r}$)"
-        fmt = defined_but_not_allowed + '|' + not_defined
-        for bl in blacklist:
-            for obj in (df, s):
-                gb = obj.groupby(df.letters)
-                msg = fmt.format(bl, type(gb).__name__)
-                with tm.assertRaisesRegexp(AttributeError, msg):
-                    getattr(gb, bl)
-
-    def test_tab_completion(self):
-        grp = self.mframe.groupby(level='second')
-        results = set([v for v in dir(grp) if not v.startswith('_')])
-        expected = set(
-            ['A', 'B', 'C', 'agg', 'aggregate', 'apply', 'boxplot', 'filter',
-             'first', 'get_group', 'groups', 'hist', 'indices', 'last', 'max',
-             'mean', 'median', 'min', 'name', 'ngroups', 'nth', 'ohlc', 'plot',
-             'prod', 'size', 'std', 'sum', 'transform', 'var', 'sem', 'count',
-             'nunique', 'head', 'describe', 'cummax', 'quantile',
-             'rank', 'cumprod', 'tail', 'resample', 'cummin', 'fillna',
-             'cumsum', 'cumcount', 'all', 'shift', 'skew', 'bfill', 'ffill',
-             'take', 'tshift', 'pct_change', 'any', 'mad', 'corr', 'corrwith',
-             'cov', 'dtypes', 'ndim', 'diff', 'idxmax', 'idxmin',
-             'ffill', 'bfill', 'pad', 'backfill', 'rolling', 'expanding'])
-        self.assertEqual(results, expected)
-
     def test_lower_int_prec_count(self):
         df = DataFrame({'a': np.array(
             [0, 1, 2, 100], np.int8),
diff --git a/pandas/tests/groupby/test_whitelist.py b/pandas/tests/groupby/test_whitelist.py
new file mode 100644
index 000000000..d566f34b7
--- /dev/null
+++ b/pandas/tests/groupby/test_whitelist.py
@@ -0,0 +1,301 @@
+"""
+test methods relating to generic function evaluation
+the so-called white/black lists
+"""
+
+import pytest
+from string import ascii_lowercase
+import numpy as np
+from pandas import DataFrame, Series, compat, date_range, Index, MultiIndex
+from pandas.util import testing as tm
+from pandas.compat import lrange, product
+
+AGG_FUNCTIONS = ['sum', 'prod', 'min', 'max', 'median', 'mean', 'skew',
+                 'mad', 'std', 'var', 'sem']
+AGG_FUNCTIONS_WITH_SKIPNA = ['skew', 'mad']
+
+df_whitelist = frozenset([
+    'last',
+    'first',
+    'mean',
+    'sum',
+    'min',
+    'max',
+    'head',
+    'tail',
+    'cumcount',
+    'resample',
+    'rank',
+    'quantile',
+    'fillna',
+    'mad',
+    'any',
+    'all',
+    'take',
+    'idxmax',
+    'idxmin',
+    'shift',
+    'tshift',
+    'ffill',
+    'bfill',
+    'pct_change',
+    'skew',
+    'plot',
+    'boxplot',
+    'hist',
+    'median',
+    'dtypes',
+    'corrwith',
+    'corr',
+    'cov',
+    'diff',
+])
+
+s_whitelist = frozenset([
+    'last',
+    'first',
+    'mean',
+    'sum',
+    'min',
+    'max',
+    'head',
+    'tail',
+    'cumcount',
+    'resample',
+    'rank',
+    'quantile',
+    'fillna',
+    'mad',
+    'any',
+    'all',
+    'take',
+    'idxmax',
+    'idxmin',
+    'shift',
+    'tshift',
+    'ffill',
+    'bfill',
+    'pct_change',
+    'skew',
+    'plot',
+    'hist',
+    'median',
+    'dtype',
+    'corr',
+    'cov',
+    'diff',
+    'unique',
+    'nlargest',
+    'nsmallest',
+])
+
+
+@pytest.fixture
+def mframe():
+    index = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux'], ['one', 'two',
+                                                              'three']],
+                       labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3],
+                               [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],
+                       names=['first', 'second'])
+    return DataFrame(np.random.randn(10, 3), index=index,
+                     columns=['A', 'B', 'C'])
+
+
+@pytest.fixture
+def df():
+    return DataFrame(
+        {'A': ['foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'foo'],
+         'B': ['one', 'one', 'two', 'three', 'two', 'two', 'one', 'three'],
+         'C': np.random.randn(8),
+         'D': np.random.randn(8)})
+
+
+@pytest.fixture
+def df_letters():
+    letters = np.array(list(ascii_lowercase))
+    N = 10
+    random_letters = letters.take(np.random.randint(0, 26, N))
+    df = DataFrame({'floats': N / 10 * Series(np.random.random(N)),
+                    'letters': Series(random_letters)})
+    return df
+
+
+@pytest.mark.parametrize(
+    "obj, whitelist", zip((df_letters(), df_letters().floats),
+                          (df_whitelist, s_whitelist)))
+def test_groupby_whitelist(df_letters, obj, whitelist):
+    df = df_letters
+
+    # these are aliases so ok to have the alias __name__
+    alias = {'bfill': 'backfill',
+             'ffill': 'pad',
+             'boxplot': None}
+
+    gb = obj.groupby(df.letters)
+
+    assert whitelist == gb._apply_whitelist
+    for m in whitelist:
+
+        m = alias.get(m, m)
+        if m is None:
+            continue
+
+        f = getattr(type(gb), m)
+
+        # name
+        try:
+            n = f.__name__
+        except AttributeError:
+            continue
+        assert n == m
+
+        # qualname
+        if compat.PY3:
+            try:
+                n = f.__qualname__
+            except AttributeError:
+                continue
+            assert n.endswith(m)
+
+
+@pytest.fixture
+def raw_frame():
+    index = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux'], ['one', 'two',
+                                                              'three']],
+                       labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3],
+                               [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],
+                       names=['first', 'second'])
+    raw_frame = DataFrame(np.random.randn(10, 3), index=index,
+                          columns=Index(['A', 'B', 'C'], name='exp'))
+    raw_frame.iloc[1, [1, 2]] = np.nan
+    raw_frame.iloc[7, [0, 1]] = np.nan
+    return raw_frame
+
+
+@pytest.mark.parametrize(
+    "op, level, axis, skipna",
+    product(AGG_FUNCTIONS,
+            lrange(2), lrange(2),
+            [True, False]))
+def test_regression_whitelist_methods(raw_frame, op, level, axis, skipna):
+    # GH6944
+    # explicity test the whitelest methods
+
+    if axis == 0:
+        frame = raw_frame
+    else:
+        frame = raw_frame.T
+
+    if op in AGG_FUNCTIONS_WITH_SKIPNA:
+        grouped = frame.groupby(level=level, axis=axis)
+        result = getattr(grouped, op)(skipna=skipna)
+        expected = getattr(frame, op)(level=level, axis=axis,
+                                      skipna=skipna)
+        tm.assert_frame_equal(result, expected)
+    else:
+        grouped = frame.groupby(level=level, axis=axis)
+        result = getattr(grouped, op)()
+        expected = getattr(frame, op)(level=level, axis=axis)
+        tm.assert_frame_equal(result, expected)
+
+
+def test_groupby_blacklist(df_letters):
+    df = df_letters
+    s = df_letters.floats
+
+    blacklist = [
+        'eval', 'query', 'abs', 'where',
+        'mask', 'align', 'groupby', 'clip', 'astype',
+        'at', 'combine', 'consolidate', 'convert_objects',
+    ]
+    to_methods = [method for method in dir(df) if method.startswith('to_')]
+
+    blacklist.extend(to_methods)
+
+    # e.g., to_csv
+    defined_but_not_allowed = ("(?:^Cannot.+{0!r}.+{1!r}.+try using the "
+                               "'apply' method$)")
+
+    # e.g., query, eval
+    not_defined = "(?:^{1!r} object has no attribute {0!r}$)"
+    fmt = defined_but_not_allowed + '|' + not_defined
+    for bl in blacklist:
+        for obj in (df, s):
+            gb = obj.groupby(df.letters)
+            msg = fmt.format(bl, type(gb).__name__)
+            with tm.assertRaisesRegexp(AttributeError, msg):
+                getattr(gb, bl)
+
+
+def test_tab_completion(mframe):
+    grp = mframe.groupby(level='second')
+    results = set([v for v in dir(grp) if not v.startswith('_')])
+    expected = set(
+        ['A', 'B', 'C', 'agg', 'aggregate', 'apply', 'boxplot', 'filter',
+         'first', 'get_group', 'groups', 'hist', 'indices', 'last', 'max',
+         'mean', 'median', 'min', 'name', 'ngroups', 'nth', 'ohlc', 'plot',
+         'prod', 'size', 'std', 'sum', 'transform', 'var', 'sem', 'count',
+         'nunique', 'head', 'describe', 'cummax', 'quantile',
+         'rank', 'cumprod', 'tail', 'resample', 'cummin', 'fillna',
+         'cumsum', 'cumcount', 'all', 'shift', 'skew',
+         'take', 'tshift', 'pct_change', 'any', 'mad', 'corr', 'corrwith',
+         'cov', 'dtypes', 'ndim', 'diff', 'idxmax', 'idxmin',
+         'ffill', 'bfill', 'pad', 'backfill', 'rolling', 'expanding'])
+    assert results == expected
+
+
+def test_groupby_function_rename(mframe):
+    grp = mframe.groupby(level='second')
+    for name in ['sum', 'prod', 'min', 'max', 'first', 'last']:
+        f = getattr(grp, name)
+        assert f.__name__ == name
+
+
+def test_groupby_selection_with_methods(df):
+    # some methods which require DatetimeIndex
+    rng = date_range('2014', periods=len(df))
+    df.index = rng
+
+    g = df.groupby(['A'])[['C']]
+    g_exp = df[['C']].groupby(df['A'])
+    # TODO check groupby with > 1 col ?
+
+    # methods which are called as .foo()
+    methods = ['count',
+               'corr',
+               'cummax',
+               'cummin',
+               'cumprod',
+               'describe',
+               'rank',
+               'quantile',
+               'diff',
+               'shift',
+               'all',
+               'any',
+               'idxmin',
+               'idxmax',
+               'ffill',
+               'bfill',
+               'pct_change',
+               'tshift']
+
+    for m in methods:
+        res = getattr(g, m)()
+        exp = getattr(g_exp, m)()
+
+        # should always be frames!
+        tm.assert_frame_equal(res, exp)
+
+    # methods which aren't just .foo()
+    tm.assert_frame_equal(g.fillna(0), g_exp.fillna(0))
+    tm.assert_frame_equal(g.dtypes, g_exp.dtypes)
+    tm.assert_frame_equal(g.apply(lambda x: x.sum()),
+                          g_exp.apply(lambda x: x.sum()))
+
+    tm.assert_frame_equal(g.resample('D').mean(), g_exp.resample('D').mean())
+    tm.assert_frame_equal(g.resample('D').ohlc(),
+                          g_exp.resample('D').ohlc())
+
+    tm.assert_frame_equal(g.filter(lambda x: len(x) == 3),
+                          g_exp.filter(lambda x: len(x) == 3))

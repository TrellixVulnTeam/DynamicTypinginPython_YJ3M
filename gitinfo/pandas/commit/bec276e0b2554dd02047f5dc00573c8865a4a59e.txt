commit bec276e0b2554dd02047f5dc00573c8865a4a59e
Author: Thomas Kluyver <takowl@gmail.com>
Date:   Sun Jan 29 13:36:35 2012 +0000

    Prototype vectorised string functions.

diff --git a/pandas/core/strings.py b/pandas/core/strings.py
new file mode 100644
index 000000000..14939e3eb
--- /dev/null
+++ b/pandas/core/strings.py
@@ -0,0 +1,31 @@
+import numpy as np
+from pandas.util.map import mapwrap, auto_map
+import re
+
+startswith = mapwrap(str.startswith)
+contains = mapwrap(str.__contains__)
+upper = mapwrap(str.upper)
+lower = mapwrap(str.lower)
+
+def _re_get_groups(pattern, n):
+    def inner(s, *groups):
+        m = pattern.search(s)
+        if m:
+            return m.group(*[int(g) for g in groups])
+        return np.nan if n == 1 else [np.nan] * n
+    
+    return inner
+
+def search_re(arr, pattern, groups=(0,)):
+    if isinstance(pattern, str):
+        pattern = re.compile(pattern)
+    
+    if isinstance(groups, np.ndarray):
+        if groups.ndim == 1:
+            n_groups = 1
+        else:
+            n_groups = groups.shape[1]
+    else:
+        n_groups = len(groups)
+    
+    return auto_map(arr, _re_get_groups(pattern, n_groups), (groups,), n_results=n_groups)
diff --git a/pandas/util/map.py b/pandas/util/map.py
new file mode 100644
index 000000000..0a1e2d16a
--- /dev/null
+++ b/pandas/util/map.py
@@ -0,0 +1,68 @@
+import numpy as np
+from pandas import _tseries as lib
+from pandas import notnull, Series
+from functools import wraps
+
+class repeat(object):
+    def __init__(self, obj):
+        self.obj = obj
+    
+    def __getitem__(self, i):
+        return self.obj
+
+class azip(object):
+    def __init__(self, *args):
+        self.cols = []
+        for a in args:
+            if np.isscalar(a):
+                self.cols.append(repeat(a))
+            else:
+                self.cols.append(a)
+    
+    def __getitem__(self, i):
+        return [col[i] for col in self.cols]
+
+def map_iter_args(arr, f, otherargs, n_otherargs, required, n_results):
+    '''
+    Substitute for np.vectorize with pandas-friendly dtype inference
+
+    Parameters
+    ----------
+    arr : ndarray
+    f : function
+
+    Returns
+    -------
+    mapped : ndarray
+    '''
+    n = len(arr)
+    result = np.empty((n, n_results), dtype=object)
+    for i, val in enumerate(arr):
+        args = otherargs[i]
+        if notnull(val) and all(notnull(args[r]) for r in required):
+            result[i] = f(val, *args)
+        else:
+            result[i] = [np.nan] * n_results
+
+    return [lib.maybe_convert_objects(col, try_float=0) for col in result.T]
+    
+def auto_map(arr, f, otherargs, n_results=1, required='all'):
+    if all(np.isscalar(a) for a in otherargs):
+        return lib.map_infer(arr, lambda v: f(v, *otherargs))
+    
+    n_otherargs = len(otherargs)
+    if required == 'all':
+        required = list(range(n_otherargs))
+    res = map_iter_args(arr, f, azip(*otherargs), n_otherargs, required, n_results)
+    res = [Series(col, index=arr.index, copy=False) for col in res]
+    if n_results == 1:
+        return res[0]
+    return res
+
+def mapwrap(f, n_results_default=1, required='all'):
+    @wraps(f)
+    def wrapped(arr, otherargs=(), n_results=None):
+        n_results = n_results or n_results_default
+        return auto_map(arr, f, otherargs, n_results, required)
+    
+    return wrapped

commit 4c9983c708a3d4a19963de91fbeab386f554dd43
Author: jreback <jeff@reback.net>
Date:   Mon Jan 6 18:36:46 2014 -0500

    BUG: bug in `o_datetime when passed a np.nan or integer datelike and a format string (GH5863)

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 9a3e101fc..4dbb450c8 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -79,6 +79,7 @@ Bug Fixes
   - Bug in selection with missing values via ``.ix`` from a duplicate indexed DataFrame failing (:issue:`5835`)
   - Fix issue of boolean comparison on empty DataFrames (:issue:`5808`)
   - Bug in isnull handling ``NaT`` in an object array (:issue:`5443`)
+  - Bug in ``to_datetime`` when passed a ``np.nan`` or integer datelike and a format string (:issue:`5863`)
 
 pandas 0.13.0
 -------------
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index f4dcdb7a4..4fb8bc7de 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -804,6 +804,31 @@ class TestTimeSeries(tm.TestCase):
         xp = datetime(2001, 1, 1)
         self.assert_(rs, xp)
 
+
+    def test_to_datetime_mixed(self):
+
+        # 5863
+        # passing a string format with embedded np.nan
+
+        ts = Series([np.nan, '2013-04-08 00:00:00.000', '9999-12-31 00:00:00.000'])
+        expected = Series([NaT,Timestamp('20130408'),NaT])
+
+        result = to_datetime(ts, format='%Y-%m-%d %H:%M:%S.%f')
+        assert_series_equal(result, ts)
+
+        # raises if specified
+        self.assertRaises(pd.tslib.OutOfBoundsDatetime, to_datetime, ts, format='%Y-%m-%d %H:%M:%S.%f', errors='raise')
+
+        result = to_datetime(ts, format='%Y-%m-%d %H:%M:%S.%f',coerce=True)
+        expected = Series([NaT,Timestamp('20130408'),NaT])
+        assert_series_equal(result,expected)
+
+        # passing integers
+        ts = Series([np.nan, 20130408, '20130409'])
+        result = to_datetime(ts, format='%Y%m%d')
+        expected = Series([NaT,Timestamp('20130408'),Timestamp('20130409')])
+        assert_series_equal(result,expected)
+
     def test_dayfirst(self):
 
         # GH 3341
diff --git a/pandas/tseries/tools.py b/pandas/tseries/tools.py
index af1a31bce..d3c686cbf 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/tseries/tools.py
@@ -112,7 +112,12 @@ def to_datetime(arg, errors='ignore', dayfirst=False, utc=None, box=True,
 
                 # fallback
                 if result is None:
-                    result = tslib.array_strptime(arg, format, coerce=coerce)
+                    try:
+                        result = tslib.array_strptime(arg, format, coerce=coerce)
+                    except (tslib.OutOfBoundsDatetime):
+                        if errors == 'raise':
+                            raise
+                        result = arg
             else:
                 result = tslib.array_to_datetime(arg, raise_=errors == 'raise',
                                                  utc=utc, dayfirst=dayfirst,
diff --git a/pandas/tslib.pyx b/pandas/tslib.pyx
index 96391f703..bda6625f3 100644
--- a/pandas/tslib.pyx
+++ b/pandas/tslib.pyx
@@ -1197,6 +1197,7 @@ def array_strptime(ndarray[object] values, object fmt, coerce=False):
         pandas_datetimestruct dts
         ndarray[int64_t] iresult
         int year, month, day, minute, hour, second, fraction, weekday, julian
+        object val
 
     global _TimeRE_cache, _regex_cache
     with _cache_lock:
@@ -1252,14 +1253,26 @@ def array_strptime(ndarray[object] values, object fmt, coerce=False):
     cdef int parse_code
 
     for i in range(n):
-        found = format_regex.match(values[i])
+        val = values[i]
+        if util.is_string_object(val):
+            if val in _nat_strings:
+                iresult[i] = iNaT
+                continue
+        else:
+            if util._checknull(val) or val is NaT:
+                iresult[i] = iNaT
+                continue
+            else:
+                val = str(val)
+
+        found = format_regex.match(val)
         if not found:
             if coerce:
                 iresult[i] = iNaT
                 continue
             raise ValueError("time data %r does not match format %r" %
                              (values[i], fmt))
-        if len(values[i]) != found.end():
+        if len(val) != found.end():
             if coerce:
                 iresult[i] = iNaT
                 continue
@@ -1402,7 +1415,13 @@ def array_strptime(ndarray[object] values, object fmt, coerce=False):
         dts.us = fraction
 
         iresult[i] = pandas_datetimestruct_to_datetime(PANDAS_FR_ns, &dts)
-        _check_dts_bounds(&dts)
+        try:
+            _check_dts_bounds(&dts)
+        except ValueError:
+            if coerce:
+                iresult[i] = iNaT
+                continue
+            raise
 
     return result
 

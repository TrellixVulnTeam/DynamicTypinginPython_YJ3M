commit 33620e2a1e5091f1138a0bb490a5f15f17f786c6
Author: Chang She <chang@lambdafoundry.com>
Date:   Wed May 2 19:18:08 2012 -0400

    API: ordinal keyword in Period constructor. BUG: Period parsing monthly short string. GH #1170

diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index e8af7a6ec..2ee02d22b 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -256,12 +256,12 @@ class DatetimeIndex(Int64Index):
 
             # try a few ways to make it datetime64
             if lib.is_string_array(data):
-                data = _str_to_dt_array(data)
+                data = _str_to_dt_array(data, offset)
             else:
                 data = np.asarray(data, dtype='M8[us]')
 
         if issubclass(data.dtype.type, basestring):
-            subarr = _str_to_dt_array(data)
+            subarr = _str_to_dt_array(data, offset)
         elif issubclass(data.dtype.type, np.datetime64):
             if isinstance(data, DatetimeIndex):
                 subarr = data.values
@@ -786,7 +786,9 @@ class DatetimeIndex(Int64Index):
         except KeyError:
 
             try:
-                asdt, parsed, reso = parse_time_string(key)
+                freq = getattr(self, 'freq', getattr(self, 'inferred_freq',
+                                                     None))
+                asdt, parsed, reso = parse_time_string(key, freq)
                 key = asdt
                 loc = self._partial_date_slice(reso, parsed)
                 return series[loc]
@@ -838,7 +840,8 @@ class DatetimeIndex(Int64Index):
         return com._ensure_platform_int(indexer)
 
     def _get_string_slice(self, key):
-        asdt, parsed, reso = parse_time_string(key)
+        freq = getattr(self, 'freq', getattr(self, 'inferred_freq', None))
+        asdt, parsed, reso = parse_time_string(key, freq)
         key = asdt
         loc = self._partial_date_slice(reso, parsed)
         return loc
@@ -1198,9 +1201,9 @@ def _to_m8_array(arr):
     return np.frompyfunc(_to_m8, 1, 1)(arr)
 
 
-def _str_to_dt_array(arr):
+def _str_to_dt_array(arr, offset=None):
     def parser(x):
-        result = parse_time_string(x)
+        result = parse_time_string(x, offset)
         return result[0]
 
     p_ufunc = np.frompyfunc(parser, 1, 1)
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index 8d39555c8..4b74cd9c8 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -51,7 +51,7 @@ def to_period(arg, freq=None):
 
 class Period(object):
 
-    def __init__(self, value=None, freq=None,
+    def __init__(self, value=None, freq=None, ordinal=None,
                  year=None, month=1, quarter=None, day=1,
                  hour=0, minute=0, second=0):
         """
@@ -78,10 +78,21 @@ class Period(object):
         self.freq = None
 
         # ordinal is the period offset from the gregorian proleptic epoch
-
         self.ordinal = None
 
-        if value is None:
+        if ordinal is not None and value is not None:
+            raise ValueError(("Only value or ordinal but not both should be "
+                              "given but not both"))
+        elif ordinal is not None:
+            if not com.is_integer(ordinal):
+                raise ValueError("Ordinal must be an integer")
+            if ordinal <= 0:
+                raise ValueError("Ordinal must be positive")
+            if freq is None:
+                raise ValueError('Must supply freq for ordinal value')
+            self.ordinal = ordinal
+
+        elif value is None:
             if freq is None:
                 raise ValueError("If value is None, freq cannot be None")
 
@@ -105,9 +116,14 @@ class Period(object):
                 converted = other.asfreq(freq)
                 self.ordinal = converted.ordinal
 
-        elif isinstance(value, basestring):
+        elif isinstance(value, basestring) or com.is_integer(value):
+            if com.is_integer(value):
+                if value <= 0:
+                    raise ValueError('Value must be greater than 0')
+                value = str(value)
+
             value = value.upper()
-            dt, parsed, reso = parse_time_string(value)
+            dt, parsed, reso = parse_time_string(value, freq)
 
             if freq is None:
                 if reso == 'year':
@@ -131,12 +147,6 @@ class Period(object):
             dt = value
             if freq is None:
                 raise ValueError('Must supply freq for datetime value')
-        elif com.is_integer(value):
-            if value <= 0:
-                raise ValueError("Value must be positive")
-            self.ordinal = value
-            if freq is None:
-                raise ValueError('Must supply freq for ordinal value')
         else:
             msg = "Value must be Period, string, integer, or datetime"
             raise ValueError(msg)
@@ -160,12 +170,12 @@ class Period(object):
 
     def __add__(self, other):
         if isinstance(other, (int, long)):
-            return Period(self.ordinal + other, self.freq)
+            return Period(ordinal=self.ordinal + other, freq=self.freq)
         raise ValueError("Cannot add with non-integer value")
 
     def __sub__(self, other):
         if isinstance(other, (int, long)):
-            return Period(self.ordinal - other, self.freq)
+            return Period(ordinal=self.ordinal - other, freq=self.freq)
         if isinstance(other, Period):
             if other.freq != self.freq:
                 raise ValueError("Cannot do arithmetic with "
@@ -192,7 +202,7 @@ class Period(object):
         new_ordinal = lib.period_asfreq(self.ordinal, base1, mult1,
                                         base2, mult2, py3compat.str_to_bytes(how))
 
-        return Period(new_ordinal, (base2, mult2))
+        return Period(ordinal=new_ordinal, freq=(base2, mult2))
 
     @property
     def start_time(self):
@@ -427,7 +437,7 @@ def _period_box_array(arr, freq):
     if not isinstance(arr, np.ndarray):
         return arr
 
-    boxfunc = lambda x: Period(x, freq)
+    boxfunc = lambda x: Period(ordinal=x, freq=freq)
     boxer = np.frompyfunc(boxfunc, 1, 1)
     return boxer(arr)
 
@@ -567,7 +577,7 @@ class PeriodIndex(Int64Index):
 
     def __iter__(self):
         for val in self.values:
-            yield Period(val, freq=self.freq)
+            yield Period(ordinal=val, freq=self.freq)
 
     @property
     def is_all_dates(self):
@@ -693,7 +703,7 @@ class PeriodIndex(Int64Index):
             return super(PeriodIndex, self).get_value(series, key)
         except KeyError:
             try:
-                asdt, parsed, reso = parse_time_string(key)
+                asdt, parsed, reso = parse_time_string(key, self.freq)
                 grp = _freq_mod._infer_period_group(reso)
                 freqn = _freq_mod._period_group(self.freq)
 
@@ -706,8 +716,8 @@ class PeriodIndex(Int64Index):
                     key = slice(pos[0], pos[1]+1)
                     return series[key]
                 else:
-                    key = to_period(asdt, freq=self.freq).ordinal
-                    return self._engine.get_value(series, key)
+                    key = to_period(asdt, freq=self.freq)
+                    return self._engine.get_value(series, key.ordinal)
             except TypeError:
                 pass
             except KeyError:
@@ -716,8 +726,8 @@ class PeriodIndex(Int64Index):
                 ival = Period(key, freq=self.freq)
                 raise IndexError("%s is out of bounds" % ival)
 
-            key = to_period(key, self.freq).ordinal
-            return self._engine.get_value(series, key)
+            key = to_period(key, self.freq)
+            return self._engine.get_value(series, key.ordinal)
 
     def get_loc(self, key):
         """
@@ -731,7 +741,7 @@ class PeriodIndex(Int64Index):
             return self._engine.get_loc(key)
         except KeyError:
             try:
-                asdt, parsed, reso = parse_time_string(key)
+                asdt, parsed, reso = parse_time_string(key, self.freq)
                 key = asdt
             except TypeError:
                 pass
@@ -780,7 +790,7 @@ class PeriodIndex(Int64Index):
         arr_idx = self.view(np.ndarray)
         if np.isscalar(key):
             val = arr_idx[key]
-            return Period(val, freq=self.freq)
+            return Period(ordinal=val, freq=self.freq)
         else:
             if com._is_bool_indexer(key):
                 key = np.asarray(key)
diff --git a/pandas/tseries/plotting.py b/pandas/tseries/plotting.py
index d37e1900d..8dd1bab1a 100644
--- a/pandas/tseries/plotting.py
+++ b/pandas/tseries/plotting.py
@@ -316,8 +316,8 @@ def _daily_finder(vmin, vmax, freq):
     # save this for later usage
     vmin_orig = vmin
 
-    (vmin, vmax) = (Period(value=int(vmin), freq=freq),
-                    Period(value=int(vmax), freq=freq))
+    (vmin, vmax) = (Period(ordinal=int(vmin), freq=freq),
+                    Period(ordinal=int(vmax), freq=freq))
     span = vmax.ordinal - vmin.ordinal + 1
     dates_ = PeriodIndex(start=vmin, end=vmax, freq=freq)
     # Initialize the output
@@ -803,7 +803,7 @@ class TimeSeries_DateFormatter(Formatter):
             return ''
         else:
             fmt = self.formatdict.pop(x, '')
-            return Period(int(x), self.freq).strftime(fmt)
+            return Period(ordinal=int(x), freq=self.freq).strftime(fmt)
 
 # Patch methods for subplot. Only format_dateaxis is currently used.
 # Do we need the rest for convenience?
diff --git a/pandas/tseries/tests/test_period.py b/pandas/tseries/tests/test_period.py
index 2ef7e68a8..cb62eb210 100644
--- a/pandas/tseries/tests/test_period.py
+++ b/pandas/tseries/tests/test_period.py
@@ -113,6 +113,21 @@ class TestPeriodProperties(TestCase):
         i2 = Period('1982', freq=('Min', 1))
         self.assertEquals(i1, i2)
 
+        expected = Period('2007-01', freq='M')
+        i1 = Period('200701', freq='M')
+        self.assertEqual(i1, expected)
+
+        i1 = Period('200701', freq='M')
+        self.assertEqual(i1, expected)
+
+        i1 = Period(200701, freq='M')
+        self.assertEqual(i1, expected)
+
+        i1 = Period(ordinal=200701, freq='M')
+        self.assertEqual(i1.year, 16726)
+
+        self.assertRaises(ValueError, Period, ordinal=200701)
+
     def test_freq_str(self):
         i1 = Period('1982', freq='Min')
         self.assert_(i1.freq[0] != '1')
diff --git a/pandas/tseries/tools.py b/pandas/tseries/tools.py
index 26eb71276..bfeec9e80 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/tseries/tools.py
@@ -118,7 +118,7 @@ qpat1 = re.compile(r'(\d)Q(\d\d)')
 qpat2 = re.compile(r'(\d\d)Q(\d)')
 
 
-def parse_time_string(arg):
+def parse_time_string(arg, freq=None):
     """
     Try hard to parse datetime string, leveraging dateutil plus some extra
     goodies like quarter recognition.
@@ -126,12 +126,15 @@ def parse_time_string(arg):
     Parameters
     ----------
     arg : basestring
+    freq : str or DateOffset, default None
+        Helps with interpreting time string if supplied
 
     Returns
     -------
     datetime, datetime/dateutil.parser._result, str
     """
     from pandas.core.format import print_config
+    from pandas.tseries.offsets import DateOffset
 
     if not isinstance(arg, basestring):
         return arg
@@ -165,6 +168,17 @@ def parse_time_string(arg):
                     ret = default.replace(year=y, month=(q-1)*3+1)
                     return ret, ret, 'quarter'
 
+            is_mo_str = freq is not None and freq == 'M'
+            is_mo_off = getattr(freq, 'rule_code', None) == 'M'
+            is_monthly = is_mo_str or is_mo_off
+            if len(arg) == 6 and is_monthly:
+                try:
+                    ret = _try_parse_monthly(arg)
+                    if ret is not None:
+                        return ret, ret, 'month'
+                except Exception:
+                    pass
+
         dayfirst = print_config.date_dayfirst
         yearfirst = print_config.date_yearfirst
 
@@ -192,6 +206,24 @@ def parse_time_string(arg):
     except Exception, e:
         raise DateParseError(e)
 
+def _try_parse_monthly(arg):
+    base = 2000
+    add_base = False
+    default = datetime(1, 1, 1).replace(hour=0, minute=0, second=0,
+                                        microsecond=0)
+
+    if len(arg) == 4:
+        add_base = True
+        y = int(arg[:2])
+        m = int(arg[2:4])
+    elif len(arg) >= 6: # 201201
+        y = int(arg[:4])
+        m = int(arg[4:6])
+    if add_base:
+        y += base
+    ret = default.replace(year=y, month=m)
+    return ret
+
 def normalize_date(dt):
     if isinstance(dt, np.datetime64):
         dt = lib.Timestamp(dt)

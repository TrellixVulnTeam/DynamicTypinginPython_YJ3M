commit fc44ada5339d49e6e4ff00fd7b5aa3a6a0f6ca65
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Oct 31 09:20:24 2012 -0400

    REF: accept any object with read(size) method in c-parser

diff --git a/pandas/io/tests/test_cparser.py b/pandas/io/tests/test_cparser.py
index 82734fbe3..bd137151d 100644
--- a/pandas/io/tests/test_cparser.py
+++ b/pandas/io/tests/test_cparser.py
@@ -65,7 +65,8 @@ class TestCParser(unittest.TestCase):
 
     def test_StringIO(self):
         text = open(self.csv1, 'rb').read()
-        reader = TextReader(BytesIO(text), header=None)
+        src = BytesIO(text)
+        reader = TextReader(src, header=None)
         result = reader.read()
 
     def test_string_factorize(self):
diff --git a/pandas/src/parser.pyx b/pandas/src/parser.pyx
index d66d59620..78b76a8af 100644
--- a/pandas/src/parser.pyx
+++ b/pandas/src/parser.pyx
@@ -1,6 +1,7 @@
 # Copyright (c) 2012, Lambda Foundry, Inc.
 # See LICENSE for the license
 
+from libc.stdio cimport fopen, fclose
 from libc.stdlib cimport malloc, free
 from libc.string cimport strncpy, strlen
 
@@ -8,13 +9,15 @@ from cpython cimport (PyObject, PyBytes_FromString,
                       PyBytes_AsString, PyBytes_Check,
                       PyUnicode_Check)
 
+
 cdef extern from "Python.h":
+    ctypedef struct FILE
+
     object PyUnicode_FromString(char *v)
 
     object PyUnicode_Decode(char *v, Py_ssize_t size, char *encoding,
                             char *errors)
 
-
 cdef extern from "stdlib.h":
     void memcpy(void *dst, void *src, size_t n)
 
@@ -60,21 +63,6 @@ try:
 except NameError:
     basestring = str
 
-cdef extern from "Python.h":
-    ctypedef struct FILE
-    FILE* PyFile_AsFile(object)
-
-cdef extern from "parser/conversions.h":
-    inline int to_double(char *item, double *p_value,
-                         char sci, char decimal)
-    inline int to_complex(char *item, double *p_real,
-                          double *p_imag, char sci, char decimal)
-    inline int to_longlong(char *item, long long *p_value)
-    inline int to_longlong_thousands(char *item, long long *p_value,
-                                     char tsep)
-    inline int to_boolean(char *item, uint8_t *val)
-
-
 cdef extern from "parser/parser.h":
 
     ctypedef enum ParserState:
@@ -89,10 +77,6 @@ cdef extern from "parser/parser.h":
         EAT_WHITESPACE
         FINISHED
 
-    ctypedef struct table_chunk:
-        void **columns
-        int ncols
-
     ctypedef struct parser_t:
         void *source
         char sourcetype   # 'M' for mmap, 'F' for FILE, 'A' for array
@@ -156,12 +140,6 @@ cdef extern from "parser/parser.h":
         void *skipset
         int skip_footer
 
-        table_chunk *chunks
-        int nchunks
-
-        void **columns
-        int ncols
-
         #  error handling
         char *error_msg
 
@@ -183,7 +161,7 @@ cdef extern from "parser/parser.h":
 
     int parser_file_source_init(parser_t *self, FILE* fp)
     int parser_mmap_init(parser_t *self, FILE* fp)
-    int parser_array_source_init(parser_t *self, char *bytes, size_t length)
+    int parser_rd_source_init(parser_t *self, object source)
 
     int parser_consume_rows(parser_t *self, size_t nrows)
 
@@ -198,6 +176,14 @@ cdef extern from "parser/parser.h":
                          int64_t int_max, int *error, char tsep)
     uint64_t str_to_uint64(char *p_item, uint64_t uint_max, int *error)
 
+    inline int to_double(char *item, double *p_value,
+                         char sci, char decimal)
+    inline int to_complex(char *item, double *p_real,
+                          double *p_imag, char sci, char decimal)
+    inline int to_longlong(char *item, long long *p_value)
+    inline int to_longlong_thousands(char *item, long long *p_value,
+                                     char tsep)
+    inline int to_boolean(char *item, uint8_t *val)
 
 
 DEFAULT_CHUNKSIZE = 1024 * 1024
@@ -224,6 +210,7 @@ cdef class TextReader:
         int parser_start
         list clocks
         char *c_encoding
+        FILE *fp
 
     cdef public:
         int leading_cols, table_width, skip_footer, buffer_lines
@@ -417,7 +404,7 @@ cdef class TextReader:
 
     def __del__(self):
         if self.should_close:
-            self.file_handle.close()
+            fclose(self.fp)
 
     def set_error_bad_lines(self, int status):
         self.parser.error_bad_lines = status
@@ -433,38 +420,32 @@ cdef class TextReader:
         cdef:
             int status
 
-        if _is_file_like(source):
-            if isinstance(source, basestring):
-                source = open(source, 'rb')
-                self.should_close = True
+        self.fp = NULL
+
+        if isinstance(source, basestring):
+            if not isinstance(source, bytes):
+                source = source.encode('utf-8')
 
-            self.file_handle = source
+            self.should_close = True
+            self.fp = fopen(source, b'rb')
 
             if self.memory_map:
-                status = parser_mmap_init(self.parser,
-                                          PyFile_AsFile(source))
+                status = parser_mmap_init(self.parser, self.fp)
             else:
-                status = parser_file_source_init(self.parser,
-                                                 PyFile_AsFile(source))
+                status = parser_file_source_init(self.parser, self.fp)
 
             if status != 0:
                 raise Exception('Initializing from file failed')
-
         elif hasattr(source, 'read'):
             # e.g., StringIO
 
-            bytes = source.read()
-
-            # TODO: unicode
-            if isinstance(bytes, unicode):
-                raise ValueError('Only ascii/bytes supported at the moment')
-
-            status = parser_array_source_init(self.parser,
-                                              PyBytes_AsString(bytes),
-                                              len(bytes))
+            status = parser_rd_source_init(self.parser, source)
             if status != 0:
                 raise Exception('Initializing parser from file-like '
                                 'object failed')
+        else:
+            raise Exception('Expected file path name or file-like object,'
+                            ' got %s type' % type(source))
 
     cdef _get_header(self):
         cdef:
diff --git a/pandas/src/parser/conversions.c b/pandas/src/parser/conversions.c
deleted file mode 100644
index b1223c046..000000000
--- a/pandas/src/parser/conversions.c
+++ /dev/null
@@ -1,386 +0,0 @@
-
-#include <string.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <errno.h>
-#include <ctype.h>
-#include <math.h>
-#include <float.h>
-
-#include "parser.h"
-
-// forward declaration
-double inline xstrtod(const char *p, char **q, char decimal, char sci, int skip_trailing);
-
-
-inline void lowercase(char *p) {
-    for ( ; *p; ++p) *p = tolower(*p);
-}
-
-inline void uppercase(char *p) {
-    for ( ; *p; ++p) *p = toupper(*p);
-}
-
-
-/*
- *  `item` must be the nul-terminated string that is to be
- *  converted to a double.
- *
- *  To be successful, to_double() must use *all* the characters
- *  in `item`.  E.g. "1.q25" will fail.  Leading and trailing
- *  spaces are allowed.
- *
- *  `sci` is the scientific notation exponent character, usually
- *  either 'E' or 'D'.  Case is ignored.
- *
- *  `decimal` is the decimal point character, usually either
- *  '.' or ','.
- *
- */
-
-int inline to_double(char *item, double *p_value, char sci, char decimal)
-{
-    char *p_end;
-
-    *p_value = xstrtod(item, &p_end, decimal, sci, TRUE);
-
-    return (errno == 0) && (!*p_end);
-}
-
-
-int inline to_complex(char *item, double *p_real, double *p_imag, char sci, char decimal)
-{
-    char *p_end;
-
-    *p_real = xstrtod(item, &p_end, decimal, sci, FALSE);
-    if (*p_end == '\0') {
-        *p_imag = 0.0;
-        return errno == 0;
-    }
-    if (*p_end == 'i' || *p_end == 'j') {
-        *p_imag = *p_real;
-        *p_real = 0.0;
-        ++p_end;
-    }
-    else {
-        if (*p_end == '+') {
-            ++p_end;
-        }
-        *p_imag = xstrtod(p_end, &p_end, decimal, sci, FALSE);
-        if (errno || ((*p_end != 'i') && (*p_end != 'j'))) {
-            return FALSE;
-        }
-        ++p_end;
-    }
-    while(*p_end == ' ') {
-        ++p_end;
-    }
-    return *p_end == '\0';
-}
-
-
-int inline to_longlong(char *item, long long *p_value)
-{
-    char *p_end;
-
-    // Try integer conversion.  We explicitly give the base to be 10. If
-    // we used 0, strtoll() would convert '012' to 10, because the leading 0 in
-    // '012' signals an octal number in C.  For a general purpose reader, that
-    // would be a bug, not a feature.
-    *p_value = strtoll(item, &p_end, 10);
-
-    // Allow trailing spaces.
-    while (isspace(*p_end)) ++p_end;
-
-    return (errno == 0) && (!*p_end);
-}
-
-int inline to_longlong_thousands(char *item, long long *p_value, char tsep)
-{
-	int i, pos, status, n = strlen(item), count = 0;
-	char *tmp;
-    char *p_end;
-
-	for (i = 0; i < n; ++i)
-	{
-		if (*(item + i) == tsep) {
-			count++;
-		}
-	}
-
-	if (count == 0) {
-		return to_longlong(item, p_value);
-	}
-
-	tmp = (char*) malloc((n - count + 1) * sizeof(char));
-	if (tmp == NULL) {
-		return 0;
-	}
-
-	pos = 0;
-	for (i = 0; i < n; ++i)
-	{
-		if (item[i] != tsep)
-			tmp[pos++] = item[i];
-	}
-
-	tmp[pos] = '\0';
-
-	status = to_longlong(tmp, p_value);
-	free(tmp);
-
-	return status;
-}
-
-int inline to_boolean(char *item, uint8_t *val) {
-	char *tmp;
-	int i, status = 0;
-
-    static const char *tstrs[2] = {"TRUE", "YES"};
-    static const char *fstrs[2] = {"FALSE", "NO"};
-
-	tmp = malloc(sizeof(char) * (strlen(item) + 1));
-	strcpy(tmp, item);
-	uppercase(tmp);
-
-    for (i = 0; i < 2; ++i)
-    {
-        if (strcmp(tmp, tstrs[i]) == 0) {
-            *val = 1;
-            goto done;
-        }
-    }
-
-    for (i = 0; i < 2; ++i)
-    {
-        if (strcmp(tmp, fstrs[i]) == 0) {
-            *val = 0;
-            goto done;
-        }
-    }
-
-    status = -1;
-
-done:
-	free(tmp);
-	return status;
-}
-
-// #define TEST
-
-#ifdef TEST
-
-int main(int argc, char *argv[])
-{
-    double x, y;
-	long long xi;
-    int status;
-    char *s;
-
-    //s = "0.10e-3-+5.5e2i";
-    // s = "1-0j";
-    // status = to_complex(s, &x, &y, 'e', '.');
-	s = "123,789";
-	status = to_longlong_thousands(s, &xi, ',');
-    printf("s = '%s'\n", s);
-    printf("status = %d\n", status);
-    printf("x = %d\n", (int) xi);
-
-    // printf("x = %lg,  y = %lg\n", x, y);
-
-    return 0;
-}
-#endif
-
-// ---------------------------------------------------------------------------
-// Implementation of xstrtod
-
-//
-// strtod.c
-//
-// Convert string to double
-//
-// Copyright (C) 2002 Michael Ringgaard. All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-//
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. Neither the name of the project nor the names of its contributors
-//    may be used to endorse or promote products derived from this software
-//    without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
-// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-// SUCH DAMAGE.
-//
-// -----------------------------------------------------------------------
-// Modifications by Warren Weckesser, March 2011:
-// * Rename strtod() to xstrtod().
-// * Added decimal and sci arguments.
-// * Skip trailing spaces.
-// * Commented out the other functions.
-//
-
-double inline xstrtod(const char *str, char **endptr, char decimal,
-					  char sci, int skip_trailing)
-{
-  double number;
-  int exponent;
-  int negative;
-  char *p = (char *) str;
-  double p10;
-  int n;
-  int num_digits;
-  int num_decimals;
-
-  errno = 0;
-
-  // Skip leading whitespace
-  while (isspace(*p)) p++;
-
-  // Handle optional sign
-  negative = 0;
-  switch (*p)
-  {
-    case '-': negative = 1; // Fall through to increment position
-    case '+': p++;
-  }
-
-  number = 0.;
-  exponent = 0;
-  num_digits = 0;
-  num_decimals = 0;
-
-  // Process string of digits
-  while (isdigit(*p))
-  {
-    number = number * 10. + (*p - '0');
-    p++;
-    num_digits++;
-  }
-
-  // Process decimal part
-  if (*p == decimal)
-  {
-    p++;
-
-    while (isdigit(*p))
-    {
-      number = number * 10. + (*p - '0');
-      p++;
-      num_digits++;
-      num_decimals++;
-    }
-
-    exponent -= num_decimals;
-  }
-
-  if (num_digits == 0)
-  {
-    errno = ERANGE;
-    return 0.0;
-  }
-
-  // Correct for sign
-  if (negative) number = -number;
-
-  // Process an exponent string
-  if (toupper(*p) == toupper(sci))
-  {
-    // Handle optional sign
-    negative = 0;
-    switch (*++p)
-    {
-      case '-': negative = 1;   // Fall through to increment pos
-      case '+': p++;
-    }
-
-    // Process string of digits
-    n = 0;
-    while (isdigit(*p))
-    {
-      n = n * 10 + (*p - '0');
-      p++;
-    }
-
-    if (negative)
-      exponent -= n;
-    else
-      exponent += n;
-  }
-
-
-  if (exponent < DBL_MIN_EXP  || exponent > DBL_MAX_EXP)
-  {
-
-    errno = ERANGE;
-    return HUGE_VAL;
-  }
-
-  // Scale the result
-  p10 = 10.;
-  n = exponent;
-  if (n < 0) n = -n;
-  while (n)
-  {
-    if (n & 1)
-    {
-      if (exponent < 0)
-        number /= p10;
-      else
-        number *= p10;
-    }
-    n >>= 1;
-    p10 *= p10;
-  }
-
-
-  if (number == HUGE_VAL) {
-	  errno = ERANGE;
-  }
-
-  if (skip_trailing) {
-      // Skip trailing whitespace
-      while (isspace(*p)) p++;
-  }
-
-  if (endptr) *endptr = p;
-
-
-  return number;
-}
-
-/*
-float strtof(const char *str, char **endptr)
-{
-  return (float) strtod(str, endptr);
-}
-
-
-long double strtold(const char *str, char **endptr)
-{
-  return strtod(str, endptr);
-}
-
-double atof(const char *str)
-{
-  return strtod(str, NULL);
-}
-*/
-
-// End of xstrtod code
-// ---------------------------------------------------------------------------
diff --git a/pandas/src/parser/conversions.h b/pandas/src/parser/conversions.h
deleted file mode 100644
index 470bc9077..000000000
--- a/pandas/src/parser/conversions.h
+++ /dev/null
@@ -1,5 +0,0 @@
-int inline to_double(char *item, double *p_value, char sci, char decimal);
-int inline to_complex(char *item, double *p_real, double *p_imag, char sci, char decimal);
-int inline to_longlong(char *item, long long *p_value);
-int inline to_longlong_thousands(char *item, long long *p_value, char tsep);
-int inline to_boolean(char *item, uint8_t *val);
diff --git a/pandas/src/parser/parser.c b/pandas/src/parser/parser.c
index 4ed348f73..617a8e2ef 100644
--- a/pandas/src/parser/parser.c
+++ b/pandas/src/parser/parser.c
@@ -7,44 +7,45 @@ See LICENSE for the license
 */
 
  /*
-   Low-level ascii-file processing for pandas. Combines some elements from
+n   Low-level ascii-file processing for pandas. Combines some elements from
    Python's built-in csv module and Warren Weckesser's textreader project on
    GitHub. See Python Software Foundation License and BSD licenses for these.
 
   */
 
 
- #include "Python.h"
- #include "structmember.h"
+#include "parser.h"
 
- #include "parser.h"
- #include "conversions.h"
+#include <ctype.h>
+#include <math.h>
+#include <float.h>
 
- #define READ_ERROR_OUT_OF_MEMORY   1
 
- #define REACHED_EOF 1
+#define READ_ERROR_OUT_OF_MEMORY   1
 
- #define HAVE_MEMMAP
- #define HAVE_GZIP
+#define REACHED_EOF 1
 
- #define FB_EOF   -1
- #define FB_ERROR -2
+#define HAVE_MEMMAP
+#define HAVE_GZIP
 
- /*
-  * restore:
-  *  RESTORE_NOT     (0):
-  *      Free memory, but leave the file position wherever it
-  *      happend to be.
-  *  RESTORE_INITIAL (1):
-  *      Restore the file position to the location at which
-  *      the file_buffer was created.
-  *  RESTORE_FINAL   (2):
-  *      Put the file position at the next byte after the
-  *      data read from the file_buffer.
-  */
- #define RESTORE_NOT     0
- #define RESTORE_INITIAL 1
- #define RESTORE_FINAL   2
+#define FB_EOF   -1
+#define FB_ERROR -2
+
+/*
+* restore:
+*  RESTORE_NOT     (0):
+*      Free memory, but leave the file position wherever it
+*      happend to be.
+*  RESTORE_INITIAL (1):
+*      Restore the file position to the location at which
+*      the file_buffer was created.
+*  RESTORE_FINAL   (2):
+*      Put the file position at the next byte after the
+*      data read from the file_buffer.
+*/
+#define RESTORE_NOT     0
+#define RESTORE_INITIAL 1
+#define RESTORE_FINAL   2
 
 
 
@@ -174,34 +175,6 @@ int parser_file_source_init(parser_t *self, FILE* fp) {
   */
 
 
- typedef struct _array_source {
-     char *data;
-     size_t position, length;
- } array_source;
-
- #define ARS(source) ((array_source *)source)
-
-
- void *new_array_source(char *data, size_t length) {
-     array_source *ars = (array_source *) malloc(sizeof(array_source));
-
-     // to be safe, copy the data from the Python string
-     ars->data = malloc(sizeof(char) * (length + 1));
-     strcpy(ars->data, data);
-
-     ars->position = 0;
-     ars->length = length;
-
-     return (void *) ars;
- }
-
- void del_array_source(void *ars) {
-     // I made a copy
-     free(ARS(ars)->data);
-
-     free(ars);
- }
-
  /*
 
    Parser / tokenizer
@@ -397,9 +370,36 @@ int parser_gzip_source_init(parser_t *self, FILE* fp) {
     return 0;
 }
 
-int parser_array_source_init(parser_t *self, char *bytes, size_t length) {
-    self->sourcetype = 'A';
-    self->source = new_array_source(bytes, length);
+
+typedef struct _rd_source {
+    PyObject* obj;
+    PyObject* buffer;
+    size_t position;
+} rd_source;
+
+#define RDS(source) ((rd_source *)source)
+
+rd_source* new_rd_source(PyObject *obj) {
+    rd_source *rds = (rd_source *) malloc(sizeof(rd_source));
+
+    /* hold on to this object */
+    Py_INCREF(obj);
+    rds->obj = obj;
+    rds->buffer = NULL;
+    rds->position = 0;
+
+    return rds;
+}
+
+void del_rd_source(void *rds) {
+    Py_XDECREF(RDS(rds)->obj);
+    Py_XDECREF(RDS(rds)->buffer);
+    free(rds);
+}
+
+int parser_rd_source_init(parser_t *self, PyObject *source) {
+    self->sourcetype = 'R';
+    self->source = new_rd_source(source);
     return 0;
 }
 
@@ -411,8 +411,8 @@ int parser_cleanup_filebuffers(parser_t *self) {
             del_file_source(self->source);
             break;
 
-        case 'A': // in-memory bytes (e.g. from StringIO)
-            del_array_source(self->source);
+        case 'R': // Readable PyObject*
+            del_rd_source(self->source);
             break;
 
 #ifdef HAVE_MEMMAP
@@ -752,27 +752,46 @@ int parser_add_skiprow(parser_t *self, int64_t row) {
     return 0;
 }
 
-int _buffer_array_bytes(parser_t *self, size_t nbytes) {
-    array_source *src = ARS(self->source);
+int _buffer_rd_bytes(parser_t *self, size_t nbytes) {
+    PyGILState_STATE state;
+    PyObject *result, *func, *args, *i;
+    size_t length;
+    rd_source *src = RDS(self->source);
 
-    if (src->position == src->length) {
-        self->datalen = 0;
-        return REACHED_EOF;
-    }
+    /* delete old object */
+    Py_XDECREF(src->buffer);
+    args = Py_BuildValue("(i)", nbytes);
+    /* printf("%s\n", PyBytes_AsString(PyObject_Repr(args))); */
 
-    self->data = src->data + src->position;
+    func = PyObject_GetAttrString(src->obj, "read");
 
-    if (src->position + nbytes > src->length) {
-        // fewer than nbytes remaining
-        self->datalen = src->length - src->position;
-    } else {
-        self->datalen = nbytes;
-    }
+    state = PyGILState_Ensure();
+    result = PyObject_CallObject(func, args);
+    PyGILState_Release(state);
+
+    Py_XDECREF(args);
+    Py_XDECREF(func);
+
+    /* TODO: more error handling */
+    length = PySequence_Length(result);
+    self->datalen = length;
+    self->data = PyBytes_AsString(result);
+    src->buffer = result;
 
     src->position += self->datalen;
 
-    TRACE(("datalen: %d\n", self->datalen));
+    if (!PyBytes_Check(result)) {
+        self->error_msg = (char*) malloc(100);
+        sprintf(self->error_msg, ("File-like object must be in binary "
+                                  "(bytes) mode"));
+        return -1;
+    }
 
+    if (length == 0) {
+        return REACHED_EOF;
+    }
+
+    TRACE(("datalen: %d\n", self->datalen));
     TRACE(("pos: %d, length: %d", (int) src->position, (int) src->length));
     return 0;
 }
@@ -804,9 +823,9 @@ int parser_buffer_bytes(parser_t *self, size_t nbytes) {
             }
             break;
 
-        case 'A': // in-memory bytes (e.g. from StringIO)
+        case 'R': // in-memory bytes (e.g. from StringIO)
             // ew, side effects
-            status = _buffer_array_bytes(self, nbytes);
+            status = _buffer_rd_bytes(self, nbytes);
             break;
 
 #ifdef HAVE_MEMMAP
@@ -1519,6 +1538,8 @@ int _tokenize_helper(parser_t *self, size_t nrows, int all) {
                 status = parser_handle_eof(self);
                 self->state = FINISHED;
                 break;
+            } else if (status != 0) {
+                return status;
             }
         }
 
@@ -1754,3 +1775,380 @@ int main(int argc, char *argv[])
 
     return 0;
 }
+
+
+// forward declaration
+double inline xstrtod(const char *p, char **q, char decimal, char sci, int skip_trailing);
+
+
+inline void lowercase(char *p) {
+    for ( ; *p; ++p) *p = tolower(*p);
+}
+
+inline void uppercase(char *p) {
+    for ( ; *p; ++p) *p = toupper(*p);
+}
+
+
+/*
+ *  `item` must be the nul-terminated string that is to be
+ *  converted to a double.
+ *
+ *  To be successful, to_double() must use *all* the characters
+ *  in `item`.  E.g. "1.q25" will fail.  Leading and trailing
+ *  spaces are allowed.
+ *
+ *  `sci` is the scientific notation exponent character, usually
+ *  either 'E' or 'D'.  Case is ignored.
+ *
+ *  `decimal` is the decimal point character, usually either
+ *  '.' or ','.
+ *
+ */
+
+int inline to_double(char *item, double *p_value, char sci, char decimal)
+{
+    char *p_end;
+
+    *p_value = xstrtod(item, &p_end, decimal, sci, TRUE);
+
+    return (errno == 0) && (!*p_end);
+}
+
+
+int inline to_complex(char *item, double *p_real, double *p_imag, char sci, char decimal)
+{
+    char *p_end;
+
+    *p_real = xstrtod(item, &p_end, decimal, sci, FALSE);
+    if (*p_end == '\0') {
+        *p_imag = 0.0;
+        return errno == 0;
+    }
+    if (*p_end == 'i' || *p_end == 'j') {
+        *p_imag = *p_real;
+        *p_real = 0.0;
+        ++p_end;
+    }
+    else {
+        if (*p_end == '+') {
+            ++p_end;
+        }
+        *p_imag = xstrtod(p_end, &p_end, decimal, sci, FALSE);
+        if (errno || ((*p_end != 'i') && (*p_end != 'j'))) {
+            return FALSE;
+        }
+        ++p_end;
+    }
+    while(*p_end == ' ') {
+        ++p_end;
+    }
+    return *p_end == '\0';
+}
+
+
+int inline to_longlong(char *item, long long *p_value)
+{
+    char *p_end;
+
+    // Try integer conversion.  We explicitly give the base to be 10. If
+    // we used 0, strtoll() would convert '012' to 10, because the leading 0 in
+    // '012' signals an octal number in C.  For a general purpose reader, that
+    // would be a bug, not a feature.
+    *p_value = strtoll(item, &p_end, 10);
+
+    // Allow trailing spaces.
+    while (isspace(*p_end)) ++p_end;
+
+    return (errno == 0) && (!*p_end);
+}
+
+int inline to_longlong_thousands(char *item, long long *p_value, char tsep)
+{
+	int i, pos, status, n = strlen(item), count = 0;
+	char *tmp;
+    char *p_end;
+
+	for (i = 0; i < n; ++i)
+	{
+		if (*(item + i) == tsep) {
+			count++;
+		}
+	}
+
+	if (count == 0) {
+		return to_longlong(item, p_value);
+	}
+
+	tmp = (char*) malloc((n - count + 1) * sizeof(char));
+	if (tmp == NULL) {
+		return 0;
+	}
+
+	pos = 0;
+	for (i = 0; i < n; ++i)
+	{
+		if (item[i] != tsep)
+			tmp[pos++] = item[i];
+	}
+
+	tmp[pos] = '\0';
+
+	status = to_longlong(tmp, p_value);
+	free(tmp);
+
+	return status;
+}
+
+int inline to_boolean(char *item, uint8_t *val) {
+	char *tmp;
+	int i, status = 0;
+
+    static const char *tstrs[2] = {"TRUE", "YES"};
+    static const char *fstrs[2] = {"FALSE", "NO"};
+
+	tmp = malloc(sizeof(char) * (strlen(item) + 1));
+	strcpy(tmp, item);
+	uppercase(tmp);
+
+    for (i = 0; i < 2; ++i)
+    {
+        if (strcmp(tmp, tstrs[i]) == 0) {
+            *val = 1;
+            goto done;
+        }
+    }
+
+    for (i = 0; i < 2; ++i)
+    {
+        if (strcmp(tmp, fstrs[i]) == 0) {
+            *val = 0;
+            goto done;
+        }
+    }
+
+    status = -1;
+
+done:
+	free(tmp);
+	return status;
+}
+
+// #define TEST
+
+#ifdef TEST
+
+int main(int argc, char *argv[])
+{
+    double x, y;
+	long long xi;
+    int status;
+    char *s;
+
+    //s = "0.10e-3-+5.5e2i";
+    // s = "1-0j";
+    // status = to_complex(s, &x, &y, 'e', '.');
+	s = "123,789";
+	status = to_longlong_thousands(s, &xi, ',');
+    printf("s = '%s'\n", s);
+    printf("status = %d\n", status);
+    printf("x = %d\n", (int) xi);
+
+    // printf("x = %lg,  y = %lg\n", x, y);
+
+    return 0;
+}
+#endif
+
+// ---------------------------------------------------------------------------
+// Implementation of xstrtod
+
+//
+// strtod.c
+//
+// Convert string to double
+//
+// Copyright (C) 2002 Michael Ringgaard. All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+//
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. Neither the name of the project nor the names of its contributors
+//    may be used to endorse or promote products derived from this software
+//    without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+// SUCH DAMAGE.
+//
+// -----------------------------------------------------------------------
+// Modifications by Warren Weckesser, March 2011:
+// * Rename strtod() to xstrtod().
+// * Added decimal and sci arguments.
+// * Skip trailing spaces.
+// * Commented out the other functions.
+//
+
+double inline xstrtod(const char *str, char **endptr, char decimal,
+					  char sci, int skip_trailing)
+{
+  double number;
+  int exponent;
+  int negative;
+  char *p = (char *) str;
+  double p10;
+  int n;
+  int num_digits;
+  int num_decimals;
+
+  errno = 0;
+
+  // Skip leading whitespace
+  while (isspace(*p)) p++;
+
+  // Handle optional sign
+  negative = 0;
+  switch (*p)
+  {
+    case '-': negative = 1; // Fall through to increment position
+    case '+': p++;
+  }
+
+  number = 0.;
+  exponent = 0;
+  num_digits = 0;
+  num_decimals = 0;
+
+  // Process string of digits
+  while (isdigit(*p))
+  {
+    number = number * 10. + (*p - '0');
+    p++;
+    num_digits++;
+  }
+
+  // Process decimal part
+  if (*p == decimal)
+  {
+    p++;
+
+    while (isdigit(*p))
+    {
+      number = number * 10. + (*p - '0');
+      p++;
+      num_digits++;
+      num_decimals++;
+    }
+
+    exponent -= num_decimals;
+  }
+
+  if (num_digits == 0)
+  {
+    errno = ERANGE;
+    return 0.0;
+  }
+
+  // Correct for sign
+  if (negative) number = -number;
+
+  // Process an exponent string
+  if (toupper(*p) == toupper(sci))
+  {
+    // Handle optional sign
+    negative = 0;
+    switch (*++p)
+    {
+      case '-': negative = 1;   // Fall through to increment pos
+      case '+': p++;
+    }
+
+    // Process string of digits
+    n = 0;
+    while (isdigit(*p))
+    {
+      n = n * 10 + (*p - '0');
+      p++;
+    }
+
+    if (negative)
+      exponent -= n;
+    else
+      exponent += n;
+  }
+
+
+  if (exponent < DBL_MIN_EXP  || exponent > DBL_MAX_EXP)
+  {
+
+    errno = ERANGE;
+    return HUGE_VAL;
+  }
+
+  // Scale the result
+  p10 = 10.;
+  n = exponent;
+  if (n < 0) n = -n;
+  while (n)
+  {
+    if (n & 1)
+    {
+      if (exponent < 0)
+        number /= p10;
+      else
+        number *= p10;
+    }
+    n >>= 1;
+    p10 *= p10;
+  }
+
+
+  if (number == HUGE_VAL) {
+	  errno = ERANGE;
+  }
+
+  if (skip_trailing) {
+      // Skip trailing whitespace
+      while (isspace(*p)) p++;
+  }
+
+  if (endptr) *endptr = p;
+
+
+  return number;
+}
+
+/*
+float strtof(const char *str, char **endptr)
+{
+  return (float) strtod(str, endptr);
+}
+
+
+long double strtold(const char *str, char **endptr)
+{
+  return strtod(str, endptr);
+}
+
+double atof(const char *str)
+{
+  return strtod(str, NULL);
+}
+*/
+
+// End of xstrtod code
+// ---------------------------------------------------------------------------
diff --git a/pandas/src/parser/parser.h b/pandas/src/parser/parser.h
index bf185e428..367fe1ca9 100644
--- a/pandas/src/parser/parser.h
+++ b/pandas/src/parser/parser.h
@@ -9,6 +9,8 @@ See LICENSE for the license
 #ifndef _PARSER_COMMON_H_
 #define _PARSER_COMMON_H_
 
+#include "Python.h"
+/* #include "structmember.h" */
 
 #include <stdio.h>
 #include <string.h>
@@ -102,13 +104,6 @@ typedef enum {
     QUOTE_MINIMAL, QUOTE_ALL, QUOTE_NONNUMERIC, QUOTE_NONE
 } QuoteStyle;
 
-typedef struct _table_chunk {
-    void **columns;
-    int ncols;
-} table_chunk;
-
-
-
 
 typedef struct parser_t {
     void *source;
@@ -173,12 +168,6 @@ typedef struct parser_t {
     void *skipset;
     int skip_footer;
 
-    table_chunk *chunks;
-    int nchunks;
-
-    void **columns;
-    int ncols;
-
     // error handling
     char *error_msg;
 } parser_t;
@@ -209,7 +198,7 @@ int parser_file_source_init(parser_t *self, FILE *fp);
 
 int parser_mmap_init(parser_t *self, FILE *fp);
 
-int parser_array_source_init(parser_t *self, char *bytes, size_t length);
+int parser_rd_source_init(parser_t *self, PyObject *source);
 
 int parser_gzip_source_init(parser_t *self, FILE *fp);
 
@@ -241,4 +230,10 @@ int64_t str_to_int64(const char *p_item, int64_t int_min,
                      int64_t int_max, int *error, char tsep);
 uint64_t str_to_uint64(const char *p_item, uint64_t uint_max, int *error);
 
+int inline to_double(char *item, double *p_value, char sci, char decimal);
+int inline to_complex(char *item, double *p_real, double *p_imag, char sci, char decimal);
+int inline to_longlong(char *item, long long *p_value);
+int inline to_longlong_thousands(char *item, long long *p_value, char tsep);
+int inline to_boolean(char *item, uint8_t *val);
+
 #endif // _PARSER_COMMON_H_
diff --git a/setup.py b/setup.py
index f736aa5be..7ab6bd2da 100755
--- a/setup.py
+++ b/setup.py
@@ -259,7 +259,6 @@ class CleanCommand(Command):
                                'np_datetime_strings.c',
                                'period.c',
                                'parser.c',
-                               'conversions.c',
                                'str_to.c']
 
         for root, dirs, files in list(os.walk('pandas')):
@@ -612,7 +611,6 @@ parser_ext = Extension('pandas._parser',
                                 'pandas/src/numpy_helper.h'],
                        sources=[srcpath('parser', suffix=suffix),
                                 'pandas/src/parser/parser.c',
-                                'pandas/src/parser/conversions.c',
                                 'pandas/src/parser/str_to.c',
                                 ],
                        include_dirs=common_include)

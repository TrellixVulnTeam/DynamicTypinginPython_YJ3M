commit 5866b2c1f803d5974632beb9f9d3a7833db17d19
Author: Ka Wo Chen <kawoc@tepper.cmu.edu>
Date:   Mon Jan 4 18:04:32 2016 -0500

    BUG: GH11853 where comparison of Timedelta array caused infinite recursion

diff --git a/doc/source/whatsnew/v0.18.0.txt b/doc/source/whatsnew/v0.18.0.txt
index af3c3dc01..2bdcd9e5a 100644
--- a/doc/source/whatsnew/v0.18.0.txt
+++ b/doc/source/whatsnew/v0.18.0.txt
@@ -476,6 +476,7 @@ Bug Fixes
 
 - Bug in ``.style.bar`` may not rendered properly using specific browser (:issue:`11678`)
 
+- Bug in rich comparison of ``Timedelta`` with a ``numpy.array`` of ``Timedelta``s that caused an infinite recursion (:issue:`11835`)
 
 - Bug in ``df.replace`` while replacing value in mixed dtype ``Dataframe`` (:issue:`11698`)
 
diff --git a/pandas/tseries/tests/test_timedeltas.py b/pandas/tseries/tests/test_timedeltas.py
index cb050f258..21f0c4478 100644
--- a/pandas/tseries/tests/test_timedeltas.py
+++ b/pandas/tseries/tests/test_timedeltas.py
@@ -363,6 +363,14 @@ class TestTimedeltas(tm.TestCase):
         expected = pd.Series([False, True])
         tm.assert_series_equal(actual, expected)
 
+    def test_compare_timedelta_ndarray(self):
+        # GH11835
+        periods = [Timedelta('0 days 01:00:00'), Timedelta('0 days 01:00:00')]
+        arr = np.array(periods)
+        result = arr[0] > arr
+        expected = np.array([False, False])
+        self.assert_numpy_array_equal(result, expected)
+
     def test_ops_notimplemented(self):
         class Other:
             pass
diff --git a/pandas/tslib.pyx b/pandas/tslib.pyx
index 43f3c3add..45dc42f5c 100644
--- a/pandas/tslib.pyx
+++ b/pandas/tslib.pyx
@@ -2184,6 +2184,8 @@ cdef class _Timedelta(timedelta):
                         raise TypeError('Cannot compare type %r with type %r' %
                                         (type(self).__name__,
                                          type(other).__name__))
+                if isinstance(other, np.ndarray):
+                    return PyObject_RichCompare(np.array([self]), other, op)
                 return PyObject_RichCompare(other, self, _reverse_ops[op])
             else:
                 if op == Py_EQ:

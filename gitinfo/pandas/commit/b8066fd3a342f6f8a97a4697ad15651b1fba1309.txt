commit b8066fd3a342f6f8a97a4697ad15651b1fba1309
Author: Adam Klein <adamklein@gmail.com>
Date:   Tue Feb 14 20:06:03 2012 -0500

    Enhanced datetime to allow non-contiguous freq data

diff --git a/pandas/core/index.py b/pandas/core/index.py
index 3999e6afa..723a28703 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1093,10 +1093,11 @@ class DatetimeIndex(Int64Index):
         subarr.name = name
 
         if freq is not None:
-            failure = lib.conformity_check(subarr.asi8, freq)
+            failure, contiguous = lib.conformity_check(subarr.asi8, freq)
             if failure is not None:
                 raise ValueError("%s does not satisfy frequency %s"
                                   % (np.datetime64(failure), freq))
+            subarr.contiguous = contiguous
 
         return subarr
 
@@ -1118,9 +1119,19 @@ class DatetimeIndex(Int64Index):
 
         newdti.first = first
         newdti.last = last
+        newdti.contiguous = True
 
         return newdti
 
+    @classmethod
+    def _quickbuilder(cls, name, freq, data, first):
+        newdti = data.view(cls)
+        newdti.name = name
+        newdti.freq = freq
+        newdti.first = first
+        newdti.contiguous = False
+        return newdti
+
     @property
     def asi8(self):
         # to do: cache me?
@@ -1130,8 +1141,13 @@ class DatetimeIndex(Int64Index):
         if self.freq is None:
             raise ValueError("Cannot shift, frequency of index is empty")
 
-        return self._construct_from_cache(self.name, self.freq, self.cache,
-                                          self.first+n, self.last+n)
+        if self.contiguous:
+            return self._construct_from_cache(self.name, self.freq, self.cache,
+                                              self.first+n, self.last+n)
+        else:
+            data = lib.fast_shift(self.asi8, self.freq, n)
+            return DatetimeIndex._quickbuilder(self.name, self.freq, data,
+                                               self.first)
 
     def __getitem__(self, key):
         """Override numpy.ndarray's __getitem__ method to work as desired"""
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index ae72c8573..b46413831 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -81,7 +81,7 @@ cdef class _Timestamp(datetime):
             else:
                 dtcache = _tcaches[self.freq]
                 buf = dtcache.get_cache()
-                idx = dtcache.lookup(self.value)
+                idx = dtcache._lookup(self.value)
                 return Timestamp(buf[idx + other])
         else:
             return super(_Timestamp, self).__add__(other)
@@ -314,10 +314,13 @@ cdef class YearOffset(_Offset):
     cdef:
         int64_t y, ly
 
-    def __init__(self, int64_t dayoffset=0, int64_t biz=0):
+    def __init__(self, int64_t dayoffset=0, int64_t biz=0, object anchor=None):
         self.dayoffset = dayoffset
         self.biz = biz
 
+        if anchor is not None:
+            self.anchor(anchor)
+
     cdef _setup(self):
         cdef _TSObject ts = self.ts
 
@@ -369,7 +372,7 @@ cdef class MonthOffset(_Offset):
         int64_t y
 
     def __init__(self, int64_t dayoffset=0, Py_ssize_t stride=1,
-                 int64_t biz=0):
+                 int64_t biz=0, object anchor=None):
         self.dayoffset = dayoffset
         self.stride = stride
         self.biz = biz
@@ -377,6 +380,9 @@ cdef class MonthOffset(_Offset):
         if stride <= 0:
             raise ValueError("Stride must be positive")
 
+        if anchor is not None:
+            self.anchor(anchor)
+
     cdef _setup(self):
         cdef _TSObject ts = self.ts
 
@@ -416,12 +422,12 @@ cdef class MonthOffset(_Offset):
 
         days = 0
         for j in range(0, self.stride):
+            self.m -= 1
             if self.m < 0:
                 self.m += 12
                 self.y -= 1
                 self.ly = is_leapyear(self.y)
             days += _days_per_month_table[self.ly][self.m]
-            self.m -= 1
 
         self.t -= days * us_in_day
 
@@ -443,13 +449,16 @@ cdef class DayOfMonthOffset(_Offset):
         Py_ssize_t ly, m
         int64_t y, day, week
 
-    def __init__(self, int64_t week=0, int64_t day=0):
+    def __init__(self, int64_t week=0, int64_t day=0, object anchor=None):
         self.week = week
         self.day = day
 
         if self.day < 0 or self.day > 6:
             raise ValueError("Day offset must be 0 to 6")
 
+        if anchor is not None:
+            self.anchor(anchor)
+
     cdef _setup(self):
         cdef _TSObject ts = self.ts
 
@@ -490,10 +499,12 @@ cdef class DayOfMonthOffset(_Offset):
             self.y -= 1
             self.ly = is_leapyear(self.y)
 
-    property ts:
-        def __get__(self):
-            cdef int64_t adj = (self.week * 7) + (self.day - self.dow) % 7
-            return self.t + us_in_day * adj
+    cdef int64_t _ts(self):
+        """
+        Overwrite default adjustment
+        """
+        cdef int64_t adj = (self.week * 7) + (self.day - self.dow) % 7
+        return self.t + us_in_day * adj
 
 cdef class DayOffset(_Offset):
     """
@@ -508,13 +519,16 @@ cdef class DayOffset(_Offset):
     cdef:
         Py_ssize_t stride
 
-    def __init__(self, int64_t stride=1, int64_t biz=0):
+    def __init__(self, int64_t stride=1, int64_t biz=0, object anchor=None):
         self.stride = stride
         self.biz = biz
 
         if self.stride <= 0:
             raise ValueError("Stride must be positive")
 
+        if anchor is not None:
+            self.anchor(anchor)
+
     cdef _setup(self):
         cdef _TSObject ts = self.ts
         self.t = ts.value
@@ -576,7 +590,7 @@ cdef int64_t _count_range(_Offset offset, object end):
 cdef class DatetimeCache:
     """
     Holds a contiguous array of datetimes according to some offset rule, along
-    with a int64=>Py_ssize_t hashtable to discover offsets in that array quickly.
+    with a int64=>Py_ssize_t hashtable to discover offsets quickly.
     """
     cdef:
         object start
@@ -647,14 +661,14 @@ cdef class DatetimeCache:
         self.generator.anchor(self.start)
         return _count_range(self.generator, self.end)
 
-    cpdef lookup(self, object tslike):
-        cdef:
-            _TSObject ts
+    cdef Py_ssize_t _lookup(self, int64_t val):
+        return self.indexer.get_item(val)
 
-        ts = convert_to_tsobject(tslike)
-        return self.indexer.get_item(ts.value)
+    cpdef Py_ssize_t lookup(self, object tslike):
+        cdef _TSObject ts = convert_to_tsobject(tslike)
+        return self._lookup(ts.value)
 
-    cpdef get_cache(self):
+    cpdef ndarray[int64_t] get_cache(self):
         return self.cache
 
 _DEFAULT_BEGIN = Timestamp(datetime(1850, 1, 1))
@@ -778,31 +792,60 @@ def get_dtcache_freq(freq, start=None, end=None, n=None):
         tc.rebuild()
 
     if n is not None:
-        idx = tc.lookup(start.value)
+        idx = tc._lookup(start.value)
         if idx + n > tc.count():
             tc.set_periods(idx + n)
             tc.rebuild()
 
     return tc
 
+@cython.wraparound(False)
 def conformity_check(ndarray[int64_t] data, object freq):
     cdef:
         Py_ssize_t i
+        int idx, previdx
+        object contiguous
+        DatetimeCache cache
+
+    contiguous = True
 
     if len(data) == 0:
-        return None
+        return None, contiguous
+
+    cache = get_dtcache_freq(freq)
+
+    previdx = -1
+    # fix me - keyerror ignored
+    try:
+        previdx = cache._lookup(data[0])
+        i = 1 
+        while i < len(data):
+            idx = cache._lookup(data[i])
+            if previdx != (idx - 1):
+                contiguous = False
+            i += 1
+    except KeyError:
+        return data[i], False
+
+    return None, contiguous
+
+@cython.wraparound(False)
+def fast_shift(ndarray[int64_t] data, object freq, int64_t n):
+    cdef:
+        DatetimeCache tc
+        ndarray[int64_t] result, cache
+        Py_ssize_t i, l, idx
 
-    cache = get_dtcache_freq(freq, data[0], n=len(data))
+    l = len(data)
 
-    i = 0
-    while i < len(data):
-        try:
-            cache.lookup(data[i])
-        except KeyError:
-            return data[i]
-        i += 1
+    tc = get_dtcache_freq(freq, data[0], data[l-1])
 
-    return None
+    result = np.empty(l, dtype='i8')
+    cache  = tc.get_cache()
+    for i in range(l):
+        idx = tc._lookup(data[i])
+        result[i] = cache[idx + n]
+    return result
 
 
 # The following is derived from relativedelta.py in dateutil package
diff --git a/pandas/tests/test_daterange.py b/pandas/tests/test_daterange.py
index b3761fd78..8914f2d26 100644
--- a/pandas/tests/test_daterange.py
+++ b/pandas/tests/test_daterange.py
@@ -356,161 +356,194 @@ class TestDateRange(unittest.TestCase):
 class TestDatetimePyx(unittest.TestCase):
 
     def test_yearoffset(self):
-        do  = lib.YearOffset(dayoffset=0, biz=0)
-        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
-        rng.rebuild()
-        buf = rng.get_cache()
+        off = lib.YearOffset(dayoffset=0, biz=0, anchor=datetime(2002,1,1))
 
-        self.assert_(len(buf) == 12)
+        for i in range(500):
+            t = lib.Timestamp(off.ts)
+            self.assert_(t.day == 1)
+            self.assert_(t.month == 1)
+            self.assert_(t.year == 2002 + i)
+            off.next()
 
-        for i, t in enumerate(buf):
-            t = lib.Timestamp(t)
+        for i in range(499, -1, -1):
+            off.prev()
+            t = lib.Timestamp(off.ts)
             self.assert_(t.day == 1)
             self.assert_(t.month == 1)
             self.assert_(t.year == 2002 + i)
 
-        do  = lib.YearOffset(dayoffset=-1, biz=0)
-        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
-        rng.rebuild()
-        buf = rng.get_cache()
+        off = lib.YearOffset(dayoffset=-1, biz=0, anchor=datetime(2002,1,1))
 
-        for i, t in enumerate(buf):
-            t = lib.Timestamp(t)
+        for i in range(500):
+            t = lib.Timestamp(off.ts)
+            self.assert_(t.month == 12)
             self.assert_(t.day == 31)
+            self.assert_(t.year == 2001 + i)
+            off.next()
+
+        for i in range(499, -1, -1):
+            off.prev()
+            t = lib.Timestamp(off.ts)
             self.assert_(t.month == 12)
+            self.assert_(t.day == 31)
             self.assert_(t.year == 2001 + i)
 
-        do  = lib.YearOffset(dayoffset=-1, biz=-1)
-        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
-        rng.rebuild()
-        buf = rng.get_cache()
+        off = lib.YearOffset(dayoffset=-1, biz=-1, anchor=datetime(2002,1,1))
 
-        for i, t in enumerate(buf):
-            t = lib.Timestamp(t)
-            self.assert_(t.weekday() < 5)
+        stack = []
 
-        do  = lib.YearOffset(dayoffset=0, biz=1)
-        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
-        rng.rebuild()
-        buf = rng.get_cache()
+        for i in range(500):
+            t = lib.Timestamp(off.ts)
+            stack.append(t)
+            self.assert_(t.month == 12)
+            self.assert_(t.day == 31 or t.day == 30 or t.day == 29)
+            self.assert_(t.year == 2001 + i)
+            self.assert_(t.weekday() < 5)
+            off.next()
 
-        for i, t in enumerate(buf):
-            t = lib.Timestamp(t)
+        for i in range(499, -1, -1):
+            off.prev()
+            t = lib.Timestamp(off.ts)
+            self.assert_(t == stack.pop())
+            self.assert_(t.month == 12)
+            self.assert_(t.day == 31 or t.day == 30 or t.day == 29)
+            self.assert_(t.year == 2001 + i)
             self.assert_(t.weekday() < 5)
 
     def test_monthoffset(self):
-        do  = lib.MonthOffset(dayoffset=0, biz=0)
-        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
-        rng.rebuild()
-        buf = rng.get_cache()
+        off = lib.MonthOffset(dayoffset=0, biz=0, anchor=datetime(2002,1,1))
 
-        self.assert_(len(buf) == 12)
+        for i in range(12):
+            t = lib.Timestamp(off.ts)
+            self.assert_(t.day == 1)
+            self.assert_(t.month == 1 + i)
+            self.assert_(t.year == 2002)
+            off.next()
 
-        for i, t in enumerate(buf):
-            t = lib.Timestamp(t)
+        for i in range(11, -1, -1):
+            off.prev()
+            t = lib.Timestamp(off.ts)
             self.assert_(t.day == 1)
             self.assert_(t.month == 1 + i)
             self.assert_(t.year == 2002)
 
-        do  = lib.MonthOffset(dayoffset=-1, biz=0)
-        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
-        rng.rebuild()
-        buf = rng.get_cache()
+        off = lib.MonthOffset(dayoffset=-1, biz=0, anchor=datetime(2002,1,1))
 
-        for i, t in enumerate(buf):
-            t = lib.Timestamp(t)
+        for i in range(12):
+            t = lib.Timestamp(off.ts)
             self.assert_(t.day >= 28)
             self.assert_(t.month == (12 if i == 0 else i))
             self.assert_(t.year == 2001 + (i != 0))
+            off.next()
 
-        do  = lib.MonthOffset(dayoffset=0, biz=-1)
-        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
-        rng.rebuild()
-        buf = rng.get_cache()
+        for i in range(11, -1, -1):
+            off.prev()
+            t = lib.Timestamp(off.ts)
+            self.assert_(t.day >= 28)
+            self.assert_(t.month == (12 if i == 0 else i))
+            self.assert_(t.year == 2001 + (i != 0))
 
-        for i, t in enumerate(buf):
-            t = lib.Timestamp(t)
-            self.assert_(t.weekday() < 5)
+        off = lib.MonthOffset(dayoffset=-1, biz=-1, anchor=datetime(2002,1,1))
 
-        do  = lib.MonthOffset(dayoffset=0, biz=1)
-        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
-        rng.rebuild()
-        buf = rng.get_cache()
+        stack = []
 
-        for i, t in enumerate(buf):
-            t = lib.Timestamp(t)
+        for i in range(500):
+            t = lib.Timestamp(off.ts)
+            stack.append(t)
+            if t.month != 2:
+                self.assert_(t.day >= 28)
+            else:
+                self.assert_(t.day >= 26)
+            self.assert_(t.weekday() < 5)
+            off.next()
+
+        for i in range(499, -1, -1):
+            off.prev()
+            t = lib.Timestamp(off.ts)
+            self.assert_(t == stack.pop())
+            if t.month != 2:
+                self.assert_(t.day >= 28)
+            else:
+                self.assert_(t.day >= 26)
             self.assert_(t.weekday() < 5)
 
         for i in (-2, -1, 1, 2):
             for j in (-1, 0, 1):
-                do1 = lib.MonthOffset(dayoffset=i, biz=j, stride=12)
-                do2 = lib.YearOffset(dayoffset=i, biz=j)
-                rng1 = lib.DatetimeCache(do1, start=datetime(2002,1,1), 
-                                         periods=12)
-                rng2 = lib.DatetimeCache(do2, start=datetime(2002,1,1), 
-                                         periods=12)
-                rng1.rebuild()
-                rng2.rebuild()
+                off1 = lib.MonthOffset(dayoffset=i, biz=j, stride=12,
+                                       anchor=datetime(2002,1,1))
+                off2 = lib.YearOffset(dayoffset=i, biz=j,
+                                      anchor=datetime(2002,1,1))
 
-                buf1 = rng1.get_cache()
-                buf2 = rng2.get_cache()
+                for k in range(500):
+                    self.assert_(off1.ts == off2.ts)
+                    off1.next()
+                    off2.next()
 
-                self.assert_((buf1 == buf2).all())
+                for k in range(500):
+                    self.assert_(off1.ts == off2.ts)
+                    off1.prev()
+                    off2.prev()
 
     def test_dayoffset(self):
-        do  = lib.DayOffset(biz=0)
-        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=365)
-        rng.rebuild()
-        buf = rng.get_cache()
-
-        self.assert_(len(buf) == 365)
-
-        ts = lib.Timestamp(buf[-1])
-        self.assert_(ts.day == 31)
-        self.assert_(ts.month == 12)
-        self.assert_(ts.year == 2002)
-
-        do  = lib.DayOffset(biz=0)
-        rng = lib.DatetimeCache(do, start=datetime(2004,1,1), periods=366)
-        rng.rebuild()
-        buf = rng.get_cache()
-
-        ts = lib.Timestamp(buf[-1])
-        self.assert_(ts.day == 31)
-        self.assert_(ts.month == 12)
-        self.assert_(ts.year == 2004)
-
-        do  = lib.DayOffset(biz=1)
-        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=365)
-        rng.rebuild()
-        buf = rng.get_cache()
-
-        for i, t in enumerate(buf):
-            t = lib.Timestamp(t)
-            self.assert_(t.weekday() < 5)
+        off = lib.DayOffset(biz=0, anchor=datetime(2002,1,1))
+
+        us_in_day = 1e6 * 60 * 60 * 24
+
+        t0 = lib.Timestamp(off.ts)
+        for i in range(500):
+            off.next()
+            t1 = lib.Timestamp(off.ts)
+            self.assert_(t1.value - t0.value == us_in_day)
+            t0 = t1
+
+        t0 = lib.Timestamp(off.ts)
+        for i in range(499, -1, -1):
+            off.prev()
+            t1 = lib.Timestamp(off.ts)
+            self.assert_(t0.value - t1.value == us_in_day)
+            t0 = t1
+
+        off = lib.DayOffset(biz=1, anchor=datetime(2002,1,1))
+
+        t0 = lib.Timestamp(off.ts)
+        for i in range(500):
+            off.next()
+            t1 = lib.Timestamp(off.ts)
+            self.assert_(t1.weekday() < 5)
+            self.assert_(t1.value - t0.value == us_in_day or
+                         t1.value - t0.value == 3 * us_in_day)
+            t0 = t1
+
+        t0 = lib.Timestamp(off.ts)
+        for i in range(499, -1, -1):
+            off.prev()
+            t1 = lib.Timestamp(off.ts)
+            self.assert_(t1.weekday() < 5)
+            self.assert_(t0.value - t1.value == us_in_day or
+                         t0.value - t1.value == 3 * us_in_day)
+            t0 = t1
 
-    def test_dayofmonthoffset(self):
-        do  = lib.DayOfMonthOffset(week=-1, day=4)
-        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=40)
-        rng.rebuild()
-        buf = rng.get_cache()
 
-        self.assert_(len(buf) == 40)
+    def test_dayofmonthoffset(self):
+        for week in (-1, 0, 1):
+            for day in (0, 2, 4):
+                off = lib.DayOfMonthOffset(week=-1, day=day, 
+                                           anchor=datetime(2002,1,1))
 
-        for i, t in enumerate(buf):
-            t = lib.Timestamp(t)
-            self.assert_(t.weekday() == 4)
+                stack = []
 
-        do  = lib.DayOfMonthOffset(week=2, day=2)
-        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=40)
-        rng.rebuild()
-        buf = rng.get_cache()
+                for i in range(500):
+                    t = lib.Timestamp(off.ts)
+                    stack.append(t)
+                    self.assert_(t.weekday() == day) 
+                    off.next()
 
-        self.assert_(len(buf) == 40)
+                for i in range(499, -1, -1):
+                    off.prev()
+                    t = lib.Timestamp(off.ts)
+                    self.assert_(t == stack.pop())
+                    self.assert_(t.weekday() == day)
 
-        for i, t in enumerate(buf):
-            t = lib.Timestamp(t)
-            self.assert_(t.weekday() == 2)
 
 if tm.PERFORM_DATETIME64_TESTS:
     class TestDatetime64Range(TestDateRange):

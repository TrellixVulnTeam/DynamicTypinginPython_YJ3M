commit 0f5972938a229b4ebf92ba00dcc26ba123398293
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Aug 13 20:11:45 2011 -0400

    ENH: AmbiguousIndexError not raised anymore, prefer label-based indexing, other multi-lev compat

diff --git a/pandas/core/common.py b/pandas/core/common.py
index b50d9c27a..6235601a5 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -200,6 +200,13 @@ def _pfixed(s, space, nanRep=None, float_format=None):
     else:
         return (' %s' % s)[:space].ljust(space)
 
+def _stringify(col):
+    # unicode workaround
+    if isinstance(col, tuple):
+        return str(col)
+    else:
+        return '%s' % col
+
 def _format(s, nanRep=None, float_format=None):
     if isinstance(s, float):
         if nanRep is not None and isnull(s):
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index d2ed9da22..fbe8db519 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -22,10 +22,11 @@ import numpy as np
 
 from pandas.core.common import (isnull, notnull, PandasError, _ensure_index,
                                 _try_sort, _pfixed, _default_index,
-                                _infer_dtype)
+                                _infer_dtype, _stringify)
 from pandas.core.daterange import DateRange
 from pandas.core.generic import AxisProperty, NDFrame
 from pandas.core.index import Index, MultiIndex, NULL_INDEX
+from pandas.core.indexing import _DataFrameIndexer, _maybe_droplevels
 from pandas.core.internals import BlockManager, make_block, form_blocks
 from pandas.core.series import Series, _is_bool_indexer
 import pandas.core.common as common
@@ -242,6 +243,15 @@ class DataFrame(NDFrame):
     def _constructor(self):
         return DataFrame
 
+    # Fancy indexing
+    _ix = None
+    @property
+    def ix(self):
+        if self._ix is None:
+            self._ix = _DataFrameIndexer(self)
+
+        return self._ix
+
     #----------------------------------------------------------------------
     # Class behavior
 
@@ -502,7 +512,7 @@ class DataFrame(NDFrame):
         if formatters is None:
             formatters = {}
 
-        def _stringify(col):
+        def _format_col(col):
             formatter = formatters.get(col, _myformat)
             return [formatter(x) for x in self[col]]
 
@@ -519,7 +529,7 @@ class DataFrame(NDFrame):
         else:
             (str_index,
              str_columns) = self._get_formatted_labels(sparsify=sparsify)
-            stringified = [str_columns[i] + _stringify(c)
+            stringified = [str_columns[i] + _format_col(c)
                            for i, c in enumerate(columns)]
             to_write.append(adjoin(1, str_index, *stringified))
 
@@ -567,13 +577,6 @@ class DataFrame(NDFrame):
 
         cols = self.columns
 
-        def _stringify(col):
-            # unicode workaround
-            if isinstance(col, tuple):
-                return str(col)
-            else:
-                return '%s' % col
-
         if verbose:
             print >> buf, unicode('Data columns:')
             space = max([len(_stringify(k)) for k in self.columns]) + 4
@@ -728,9 +731,7 @@ class DataFrame(NDFrame):
         Examples
         --------
         column = dm['A']
-
         dmSlice = dm[:20] # First 20 rows
-
         dmSelect = dm[dm.count(axis=1) > 10]
 
         Notes
@@ -752,27 +753,21 @@ class DataFrame(NDFrame):
             new_index = self.index[key]
             return self.reindex(new_index)
         elif isinstance(self.columns, MultiIndex):
-            loc = self.columns.get_loc(key)
-            if isinstance(loc, slice):
-                new_columns = self.columns[loc]
-                result = self.reindex(columns=new_columns)
-
-                # drop levels
-                if isinstance(key, tuple):
-                    for _ in key:
-                        new_columns = new_columns.droplevel(0)
-                else:
-                    new_columns = new_columns.droplevel(0)
-
-                result.columns = new_columns
-                return result
-            else:
-                return self._getitem_single(key)
+            return self._getitem_multilevel(key)
         else:
             return self._getitem_single(key)
 
     def _getitem_multilevel(self, key):
-        pass
+        loc = self.columns.get_loc(key)
+        if isinstance(loc, slice):
+            new_columns = self.columns[loc]
+            result = self.reindex(columns=new_columns)
+
+            # HACK: need a more general way of addressing this problem
+            result.columns = _maybe_droplevels(new_columns, key)
+            return result
+        else:
+            return self._getitem_single(key)
 
     def _getitem_single(self, key):
         values = self._data.get(key)
@@ -907,7 +902,9 @@ class DataFrame(NDFrame):
         if new_data.ndim == 1:
             return Series(new_data.as_matrix(), index=self.columns)
         else:
-            return DataFrame(new_data)
+            result = DataFrame(new_data)
+            result.index = _maybe_droplevels(result.index, key)
+            return result
 
     #----------------------------------------------------------------------
     # Reindexing
@@ -2714,18 +2711,6 @@ class DataFrame(NDFrame):
         else:
             return self.dropna(axis=0, subset=specificColumns, thresh=minObs)
 
-    #----------------------------------------------------------------------
-    # Fancy indexing
-
-    _ix = None
-    @property
-    def ix(self):
-        from pandas.core.indexing import _DataFrameIndexer
-        if self._ix is None:
-            self._ix = _DataFrameIndexer(self)
-
-        return self._ix
-
 
 def group_agg(values, bounds, f):
     """
@@ -2807,7 +2792,7 @@ def extract_index(data):
             index = index.union(new_index)
         return index
 
-    def _get_index(obj):
+    def _get_index(v):
         if isinstance(v, Series):
             return v.index
         elif isinstance(v, dict):
@@ -2871,7 +2856,6 @@ def _prep_ndarray(values, copy=True):
 
     return values
 
-
 def _rec_to_dict(arr):
     columns = list(arr.dtype.names)
     sdict = dict((k, arr[k]) for k in columns)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 3122b11be..a03f184c7 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -5,7 +5,7 @@ from itertools import izip
 
 import numpy as np
 
-from pandas.core.common import (_format, adjoin as _adjoin,
+from pandas.core.common import (_format, adjoin as _adjoin, _stringify,
                                 _ensure_index, _is_bool_indexer)
 import pandas.core.common as common
 import pandas._tseries as _tseries
@@ -47,9 +47,6 @@ class Index(np.ndarray):
         else:
             subarr = np.empty(len(data), dtype=dtype)
             subarr[:] = data
-
-        # assert(subarr.ndim == 1)
-
         return subarr.view(cls)
 
     def summary(self):
@@ -59,19 +56,21 @@ class Index(np.ndarray):
             index_summary = ''
         return 'Index: %s entries%s' % (len(self), index_summary)
 
+    _indexMap = None
     @property
     def indexMap(self):
-        if not hasattr(self, '_cache_indexMap'):
-            self._cache_indexMap = _tseries.map_indices_buf(self)
+        if self._indexMap is None:
+            self._indexMap = _tseries.map_indices_buf(self)
             self._verify_integrity()
 
-        return self._cache_indexMap
+        return self._indexMap
 
+    _allDates = None
     def is_all_dates(self):
-        if not hasattr(self, '_cache_allDates'):
-            self._cache_allDates = _tseries.isAllDates(self)
+        if self._allDates is None:
+            self._allDates = _tseries.isAllDates(self)
 
-        return self._cache_allDates
+        return self._allDates
 
     def _verify_integrity(self):
         if len(self.indexMap) < len(self):
@@ -128,7 +127,7 @@ class Index(np.ndarray):
                 to_join.append(dt.strftime("%Y-%m-%d"))
             return to_join
 
-        return ['%s' % x for x in self]
+        return [_stringify(x) for x in self]
 
     def equals(self, other):
         """
@@ -425,12 +424,12 @@ class MultiIndex(Index):
 
     @property
     def indexMap(self):
-        if not hasattr(self, '_cache_indexMap'):
+        if self._indexMap is None:
             zipped = zip(*self.labels)
-            self._cache_indexMap = _tseries.map_indices_list(zipped)
+            self._indexMap = _tseries.map_indices_list(zipped)
             self._verify_integrity()
 
-        return self._cache_indexMap
+        return self._indexMap
 
     @property
     def nlevels(self):
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index dfcd59818..8f0227ecb 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -1,8 +1,5 @@
 import numpy as np
 
-from pandas.core.frame import DataFrame
-from pandas.core.series import Series
-
 class _SeriesIndexer(object):
     """
     Class to support fancy indexing, potentially using labels
@@ -33,6 +30,8 @@ class _SeriesIndexer(object):
         op()
 
     def _fancy_index(self, key, value=None, operation='get'):
+        from pandas.core.series import Series
+
         # going to great lengths to avoid code dup
         series = self.series
 
@@ -134,7 +133,7 @@ class _DataFrameIndexer(object):
         Going by Zen of Python?
         "In the face of ambiguity, refuse the temptation to guess."
         raise AmbiguousIndexError with integer labels?
-
+        - No, prefer label-based indexing
         """
         index = self.frame._get_axis(axis)
         is_int_index = _is_integer_index(index)
@@ -145,29 +144,25 @@ class _DataFrameIndexer(object):
             else:
                 return obj
         elif _is_list_like(obj):
-            objarr = np.asarray(obj)
+            objarr = _asarray_tuplesafe(obj)
 
-            if _is_integer_dtype(objarr):
-                if is_int_index:
-                    raise AmbiguousIndexError('integer labels')
-
-                # retrieve the indices corresponding
-                return objarr
-            elif objarr.dtype == np.bool_:
+            if objarr.dtype == np.bool_:
                 if not obj.index.equals(index):
                     raise Exception('Cannot use boolean index with misaligned '
                                     'or unequal labels')
                 return objarr
             else:
+                # If have integer labels, defer to label-based indexing
+                if _is_integer_dtype(objarr) and not is_int_index:
+                    return objarr
+
                 indexer, mask = index.get_indexer(objarr)
                 if not mask.all():
                     raise KeyError('%s not in index' % objarr[-mask])
 
                 return indexer
         else:
-            if _is_int_like(obj):
-                if is_int_index:
-                    raise AmbiguousIndexError('integer labels')
+            if _is_int_like(obj) and not is_int_index:
                 return obj
             return index.get_loc(obj)
 
@@ -189,43 +184,41 @@ class _DataFrameIndexer(object):
         elif _is_list_like(key):
             return self._fancy_getitem(key, axis=axis)
         elif axis == 0:
-            idx = key
-            if isinstance(key, int):
-                if _is_integer_index(self.frame.index):
-                    raise AmbiguousIndexError('integer labels')
+            is_int_index = _is_integer_index(self.frame.index)
 
+            idx = key
+            if _is_int_like(key) and not is_int_index:
                 idx = self.frame.index[key]
 
             if self.frame._is_mixed_type:
                 return self.frame.xs(idx)
             else:
+                # get a view if possible
                 return self.frame.xs(idx, copy=False)
         else:
             col = key
-            if isinstance(key, int):
-                if _is_integer_index(self.frame.columns):
-                    raise AmbiguousIndexError('integer labels')
+            if _is_int_like(key) and not _is_integer_index(self.frame.columns):
                 col = self.frame.columns[key]
-
             return self.frame[col]
 
     def _fancy_getitem(self, key, axis=0):
+        from pandas.core.series import Series
+
         labels = self.frame._get_axis(axis)
         axis_name = self.frame._get_axis_name(axis)
 
-        keyarr = np.asarray(key)
-
         # asarray can be unsafe, NumPy strings are weird
-        isbool = keyarr.dtype == np.bool_
-        if isbool:
+        keyarr = _asarray_tuplesafe(key)
+
+        if keyarr.dtype == np.bool_:
             if isinstance(key, Series):
                 if not key.index.equals(labels):
                     raise Exception('Cannot use boolean index with misaligned '
                                     'or unequal labels')
             return self.frame.reindex(**{axis_name : labels[np.asarray(key)]})
         else:
-            if _is_integer_dtype(keyarr) and _is_integer_index(labels):
-                raise AmbiguousIndexError('integer labels')
+            if _is_integer_dtype(keyarr) and not _is_integer_index(labels):
+                key = labels.take(keyarr)
 
             return self.frame.reindex(**{axis_name : key})
 
@@ -298,4 +291,24 @@ def _is_label_slice(labels, obj):
 def _need_slice(obj):
     return obj.start is not None or obj.stop is not None
 
+def _maybe_droplevels(index, key):
+    # drop levels
+    if isinstance(key, tuple):
+        for _ in key:
+            index = index.droplevel(0)
+    else:
+        index = index.droplevel(0)
+
+    return index
+
+def _asarray_tuplesafe(values):
+    result = np.asarray(values)
+
+    if result.ndim == 2:
+        result = np.empty(len(values), dtype=object)
+        result[:] = values
+
+    return result
+
 _isboolarr = lambda x: np.asarray(x).dtype == np.bool_
+
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 5338535a1..e3870da3a 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -309,12 +309,7 @@ class Series(np.ndarray, PandasObject):
             if isinstance(loc, slice):
                 # TODO: what if a level contains tuples??
                 new_index = self.index[loc]
-                if isinstance(key, tuple):
-                    for _ in key:
-                        new_index = new_index.droplevel(0)
-                else:
-                    new_index = new_index.droplevel(0)
-
+                new_index = _maybe_droplevels(new_index, key)
                 return Series(values[loc], index=new_index)
             else:
                 return values[loc]
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 0f817a958..f40315b93 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -323,30 +323,54 @@ class CheckIndexing(object):
         frame.ix[:, 'B':'C'] = 4.
         assert_frame_equal(frame, expected)
 
-    def test_fancy_index_corner(self):
-        from pandas.core.indexing import AmbiguousIndexError
-
-        # ambiguous
-
-        df = DataFrame(np.random.randn(10, 5))
-        self.assertRaises(AmbiguousIndexError,
-                          df.ix.__setitem__,
-                          ([0, 1, 2], [4, 5, 6]), 5)
-        self.assertRaises(AmbiguousIndexError,
-                          df.ix.__setitem__, [0, 1, 2], 5)
-        self.assertRaises(AmbiguousIndexError,
-                          df.ix.__setitem__, 0, 5)
-        self.assertRaises(AmbiguousIndexError,
-                          df.ix.__setitem__, (slice(None, None), 0), 5)
-
-        self.assertRaises(AmbiguousIndexError,
-                          df.ix.__getitem__, ([0, 1, 2], [4, 5, 6]))
-        self.assertRaises(AmbiguousIndexError,
-                          df.ix.__getitem__, [0, 1, 2])
-        self.assertRaises(AmbiguousIndexError,
-                          df.ix.__getitem__, 0)
-        self.assertRaises(AmbiguousIndexError,
-                          df.ix.__getitem__, (slice(None, None), 0))
+    def test_fancy_setitem_int_labels(self):
+        # integer index defers to label-based indexing
+
+        df = DataFrame(np.random.randn(10, 5), index=np.arange(0, 20, 2))
+
+        tmp = df.copy()
+        exp = df.copy()
+        tmp.ix[[0, 2, 4]] = 5
+        exp.values[:3] = 5
+        assert_frame_equal(tmp, exp)
+
+        tmp = df.copy()
+        exp = df.copy()
+        tmp.ix[6] = 5
+        exp.values[3] = 5
+        assert_frame_equal(tmp, exp)
+
+        tmp = df.copy()
+        exp = df.copy()
+        tmp.ix[:, 2] = 5
+        exp.values[:, 2] = 5
+        assert_frame_equal(tmp, exp)
+
+    def test_fancy_getitem_int_labels(self):
+        df = DataFrame(np.random.randn(10, 5), index=np.arange(0, 20, 2))
+
+        result = df.ix[[4, 2, 0], [2, 0]]
+        expected = df.reindex(index=[4, 2, 0], columns=[2, 0])
+        assert_frame_equal(result, expected)
+
+        result = df.ix[[4, 2, 0]]
+        expected = df.reindex(index=[4, 2, 0])
+        assert_frame_equal(result, expected)
+
+        result = df.ix[4]
+        expected = df.xs(4)
+        assert_series_equal(result, expected)
+
+        result = df.ix[:, 3]
+        expected = df[3]
+        assert_series_equal(result, expected)
+
+    def test_fancy_index_int_labels_exceptions(self):
+        df = DataFrame(np.random.randn(10, 5), index=np.arange(0, 20, 2))
+
+        # labels that aren't contained
+        self.assertRaises(KeyError, df.ix.__setitem__,
+                          ([0, 1, 2], [2, 3, 4]), 5)
 
         # try to set indices not contained in frame
         self.assertRaises(KeyError,
@@ -517,6 +541,15 @@ class CheckIndexing(object):
         expected.values[mask, :2] = 0.
         assert_frame_equal(frame, expected)
 
+    def test_getitem_fancy_ints(self):
+        result = self.frame.ix[[1,4,7]]
+        expected = self.frame.ix[self.frame.index[[1,4,7]]]
+        assert_frame_equal(result, expected)
+
+        result = self.frame.ix[:, [2, 0, 1]]
+        expected = self.frame.ix[:, self.frame.columns[[2, 0, 1]]]
+        assert_frame_equal(result, expected)
+
     def test_getitem_setitem_fancy_exceptions(self):
         ix = self.frame.ix
         self.assertRaises(Exception, ix.__getitem__,
@@ -528,10 +561,6 @@ class CheckIndexing(object):
                            slice(None, None, None),
                            slice(None, None, None)), 1)
 
-        # Anything wrong with this?
-        # self.assertRaises(Exception, ix.__getitem__, slice(None, None, 2))
-        # self.assertRaises(Exception, ix.__setitem__, slice(None, None, 2), 1.)
-
         # boolean index misaligned labels
         mask = self.frame['A'][::-1] > 1
         self.assertRaises(Exception, ix.__getitem__, mask)
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index a11069273..c594f6c3f 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -634,6 +634,6 @@ class TestFactor(unittest.TestCase):
 
 if __name__ == '__main__':
     import nose
-    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure',#]
-                         '--with-coverage', '--cover-package=pandas.core'],
+    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
+                         # '--with-coverage', '--cover-package=pandas.core'],
                    exit=False)
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 60204e77a..e44298ea6 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -48,28 +48,37 @@ class TestDataFrameMultiLevel(unittest.TestCase):
 
     def test_xs(self):
         xs = self.frame.xs(('bar', 'two'))
+        xs2 = self.frame.ix[('bar', 'two')]
+
+        assert_series_equal(xs, xs2)
         assert_almost_equal(xs.values, self.frame.values[4])
 
     def test_xs_partial(self):
         result = self.frame.xs('foo')
+        result2 = self.frame.ix['foo']
         expected = self.frame.T['foo'].T
         assert_frame_equal(result, expected)
+        assert_frame_equal(result, result2)
 
     def test_getitem_toplevel(self):
         df = self.frame.T
 
         result = df['foo']
         expected = df.reindex(columns=df.columns[:3])
+        expected.columns = expected.columns.droplevel(0)
         assert_frame_equal(result, expected)
 
         result = df['bar']
         expected = df.reindex(columns=df.columns[3:5])
+        expected.columns = expected.columns.droplevel(0)
         assert_frame_equal(result, expected)
 
     def test_getitem_partial(self):
         ymd = self.ymd.T
         result = ymd[2000, 2]
+
         expected = ymd.reindex(columns=ymd.columns[ymd.columns.labels[1] == 1])
+        expected.columns = expected.columns.droplevel(0).droplevel(0)
         assert_frame_equal(result, expected)
 
     def test_fancy_slice_partial(self):

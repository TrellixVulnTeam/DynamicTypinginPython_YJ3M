commit d8280c12a3449b66beaf0459bf86e71e99a44b2b
Author: jreback <jeff@reback.net>
Date:   Thu Sep 12 07:41:47 2013 -0400

    CLN: refactored locations of timedeltas to core/tseries/timedeltas (from a series of functions in core/common)

diff --git a/pandas/__init__.py b/pandas/__init__.py
index a0edb397c..03681d3fa 100644
--- a/pandas/__init__.py
+++ b/pandas/__init__.py
@@ -18,6 +18,19 @@ except Exception:  # pragma: no cover
 from datetime import datetime
 import numpy as np
 
+# XXX: HACK for NumPy 1.5.1 to suppress warnings
+try:
+    np.seterr(all='ignore')
+    # np.set_printoptions(suppress=True)
+except Exception:  # pragma: no cover
+    pass
+
+# numpy versioning
+from distutils.version import LooseVersion
+_np_version = np.version.short_version
+_np_version_under1p6 = LooseVersion(_np_version) < '1.6'
+_np_version_under1p7 = LooseVersion(_np_version) < '1.7'
+
 from pandas.version import version as __version__
 from pandas.info import __doc__
 
diff --git a/pandas/core/common.py b/pandas/core/common.py
index 2f153e88f..b58bd92a4 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -11,7 +11,6 @@ import numpy as np
 import pandas.algos as algos
 import pandas.lib as lib
 import pandas.tslib as tslib
-from distutils.version import LooseVersion
 from pandas import compat
 from pandas.compat import StringIO, BytesIO, range, long, u, zip, map
 from datetime import timedelta
@@ -19,14 +18,6 @@ from datetime import timedelta
 from pandas.core.config import get_option
 from pandas.core import array as pa
 
-# XXX: HACK for NumPy 1.5.1 to suppress warnings
-try:
-    np.seterr(all='ignore')
-    # np.set_printoptions(suppress=True)
-except Exception:  # pragma: no cover
-    pass
-
-
 class PandasError(Exception):
     pass
 
@@ -34,11 +25,6 @@ class PandasError(Exception):
 class AmbiguousIndexError(PandasError, KeyError):
     pass
 
-# versioning
-_np_version = np.version.short_version
-_np_version_under1p6 = LooseVersion(_np_version) < '1.6'
-_np_version_under1p7 = LooseVersion(_np_version) < '1.7'
-
 _POSSIBLY_CAST_DTYPES = set([np.dtype(t)
                             for t in ['M8[ns]', 'm8[ns]', 'O', 'int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32', 'int64', 'uint64']])
 
@@ -703,50 +689,13 @@ def diff(arr, n, axis=0):
 
     return out_arr
 
-timedelta_search = re.compile(
-    "^(?P<value>-?\d*\.?\d*)(?P<unit>D|s|ms|us|ns)?$")
-
-def _coerce_scalar_to_timedelta_type(r, unit='ns'):
-    # kludgy here until we have a timedelta scalar
-    # handle the numpy < 1.7 case
-
-    if isinstance(r, compat.string_types):
-        m = timedelta_search.search(r)
-        if m:
-            r = float(m.groupdict()['value'])
-            u = m.groupdict().get('unit')
-            if u is not None:
-                unit = u
-        else:
-            raise ValueError("cannot convert timedelta scalar value!")
-
-        r = tslib.cast_from_unit(unit, r)
-        r = timedelta(microseconds=int(r)/1000)
-
-    if is_integer(r):
-        r = tslib.cast_from_unit(unit, r)
-        r = timedelta(microseconds=int(r)/1000)
-
-    if _np_version_under1p7:
-        if not isinstance(r, timedelta):
-            raise AssertionError("Invalid type for timedelta scalar: %s" % type(r))
-        if compat.PY3:
-            # convert to microseconds in timedelta64
-            r = np.timedelta64(int(r.total_seconds()*1e9 + r.microseconds*1000))
-        else:
-            return r
-
-    if isinstance(r, timedelta):
-        r = np.timedelta64(r)
-    elif not isinstance(r, np.timedelta64):
-        raise AssertionError("Invalid type for timedelta scalar: %s" % type(r))
-    return r.astype('timedelta64[ns]')
-
 def _coerce_to_dtypes(result, dtypes):
     """ given a dtypes and a result set, coerce the result elements to the dtypes """
     if len(result) != len(dtypes):
         raise AssertionError("_coerce_to_dtypes requires equal len arrays")
 
+    from pandas.tseries.timedeltas import _coerce_scalar_to_timedelta_type
+
     def conv(r,dtype):
         try:
             if isnull(r):
@@ -1339,68 +1288,6 @@ def _possibly_convert_platform(values):
 
     return values
 
-
-def _possibly_cast_to_timedelta(value, coerce=True):
-    """ try to cast to timedelta64, if already a timedeltalike, then make
-        sure that we are [ns] (as numpy 1.6.2 is very buggy in this regards,
-        don't force the conversion unless coerce is True
-
-        if coerce='compat' force a compatibilty coercerion (to timedeltas) if needeed
-        """
-
-    # coercion compatability
-    if coerce == 'compat' and _np_version_under1p7:
-
-        def convert(td, dtype):
-
-            # we have an array with a non-object dtype
-            if hasattr(td,'item'):
-                td = td.astype(np.int64).item()
-                if td == tslib.iNaT:
-                    return td
-                if dtype == 'm8[us]':
-                    td *= 1000
-                return td
-
-            if td == tslib.compat_NaT:
-                return tslib.iNaT
-
-            # convert td value to a nanosecond value
-            d = td.days
-            s = td.seconds
-            us = td.microseconds
-
-            if dtype == 'object' or dtype == 'm8[ns]':
-                td = 1000*us + (s + d * 24 * 3600) * 10 ** 9
-            else:
-                raise ValueError("invalid conversion of dtype in np < 1.7 [%s]" % dtype)
-
-            return td
-
-        # < 1.7 coercion
-        if not is_list_like(value):
-            value = np.array([ value ])
-
-        dtype = value.dtype
-        return np.array([ convert(v,dtype) for v in value ], dtype='m8[ns]')
-
-    # deal with numpy not being able to handle certain timedelta operations
-    if isinstance(value, (ABCSeries, np.ndarray)) and value.dtype.kind == 'm':
-        if value.dtype != 'timedelta64[ns]':
-            value = value.astype('timedelta64[ns]')
-        return value
-
-    # we don't have a timedelta, but we want to try to convert to one (but
-    # don't force it)
-    if coerce:
-        new_value = tslib.array_to_timedelta64(
-            _values_from_object(value).astype(object), coerce=False)
-        if new_value.dtype == 'i8':
-            value = np.array(new_value, dtype='timedelta64[ns]')
-
-    return value
-
-
 def _possibly_cast_to_datetime(value, dtype, coerce=False):
     """ try to cast the array/value to a datetimelike dtype, converting float nan to iNaT """
 
@@ -1438,6 +1325,7 @@ def _possibly_cast_to_datetime(value, dtype, coerce=False):
                             from pandas.tseries.tools import to_datetime
                             value = to_datetime(value, coerce=coerce).values
                         elif is_timedelta64:
+                            from pandas.tseries.timedeltas import _possibly_cast_to_timedelta
                             value = _possibly_cast_to_timedelta(value)
                     except:
                         pass
@@ -1463,6 +1351,7 @@ def _possibly_cast_to_datetime(value, dtype, coerce=False):
                     except:
                         pass
                 elif inferred_type in ['timedelta', 'timedelta64']:
+                    from pandas.tseries.timedeltas import _possibly_cast_to_timedelta
                     value = _possibly_cast_to_timedelta(value)
 
     return value
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 212e2bad5..b9ffe788d 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -13,7 +13,7 @@ from pandas.core.indexing import _maybe_convert_indices
 from pandas.tseries.index import DatetimeIndex
 from pandas.core.internals import BlockManager
 import pandas.core.common as com
-from pandas import compat
+from pandas import compat, _np_version_under1p7
 from pandas.compat import map, zip, lrange
 from pandas.core.common import (isnull, notnull, is_list_like,
                                 _values_from_object,
@@ -1908,7 +1908,7 @@ class NDFrame(PandasObject):
         obj = np.abs(self)
 
         # suprimo numpy 1.6 hacking
-        if com._np_version_under1p7:
+        if _np_version_under1p7:
             if self.ndim == 1:
                 if obj.dtype == 'm8[us]':
                     obj = obj.astype('m8[ns]')
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 4516fcfba..8d6591c3a 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -19,6 +19,7 @@ from pandas.core.common import (isnull, notnull, _is_bool_indexer,
                                 _asarray_tuplesafe, is_integer_dtype,
                                 _NS_DTYPE, _TD_DTYPE,
                                 _infer_dtype_from_scalar, is_list_like, _values_from_object,
+                                _possibly_cast_to_datetime, _possibly_castable, _possibly_convert_platform,
                                 ABCSparseArray)
 from pandas.core.index import (Index, MultiIndex, InvalidIndexError,
                                _ensure_index, _handle_legacy_indexes)
@@ -32,6 +33,7 @@ import pandas.core.expressions as expressions
 from pandas.tseries.index import DatetimeIndex
 from pandas.tseries.period import PeriodIndex, Period
 from pandas.tseries.offsets import DateOffset
+from pandas.tseries.timedeltas import _possibly_cast_to_timedelta
 from pandas import compat
 from pandas.util.terminal import get_terminal_size
 from pandas.compat import zip, lzip, u, OrderedDict
@@ -142,7 +144,7 @@ class _TimeOp(object):
                 values = values.to_series()
         elif inferred_type in ('timedelta', 'timedelta64'):
             # have a timedelta, convert to to ns here
-            values = com._possibly_cast_to_timedelta(values, coerce=coerce)
+            values = _possibly_cast_to_timedelta(values, coerce=coerce)
         elif inferred_type == 'integer':
             # py3 compat where dtype is 'm' but is an integer
             if values.dtype.kind == 'm':
@@ -160,7 +162,7 @@ class _TimeOp(object):
                 raise TypeError("cannot use a non-absolute DateOffset in "
                                 "datetime/timedelta operations [{0}]".format(
                                     ','.join([ com.pprint_thing(v) for v in values[mask] ])))
-            values = com._possibly_cast_to_timedelta(os, coerce=coerce)
+            values = _possibly_cast_to_timedelta(os, coerce=coerce)
         else:
             raise TypeError("incompatible type [{0}] for a datetime/timedelta operation".format(pa.array(values).dtype))
 
@@ -3215,11 +3217,11 @@ def _sanitize_array(data, index, dtype=None, copy=False,
 
         # perf shortcut as this is the most common case
         if take_fast_path:
-            if com._possibly_castable(arr) and not copy and dtype is None:
+            if _possibly_castable(arr) and not copy and dtype is None:
                 return arr
 
         try:
-            arr = com._possibly_cast_to_datetime(arr, dtype)
+            arr = _possibly_cast_to_datetime(arr, dtype)
             subarr = pa.array(arr, dtype=dtype, copy=copy)
         except (ValueError, TypeError):
             if dtype is not None and raise_cast_failure:
@@ -3266,9 +3268,9 @@ def _sanitize_array(data, index, dtype=None, copy=False,
                 subarr = lib.maybe_convert_objects(subarr)
 
         else:
-            subarr = com._possibly_convert_platform(data)
+            subarr = _possibly_convert_platform(data)
 
-        subarr = com._possibly_cast_to_datetime(subarr, dtype)
+        subarr = _possibly_cast_to_datetime(subarr, dtype)
 
     else:
         subarr = _try_cast(data, False)
@@ -3285,7 +3287,7 @@ def _sanitize_array(data, index, dtype=None, copy=False,
                 dtype, value = _infer_dtype_from_scalar(value)
             else:
                 # need to possibly convert the value here
-                value = com._possibly_cast_to_datetime(value, dtype)
+                value = _possibly_cast_to_datetime(value, dtype)
 
             subarr = pa.empty(len(index), dtype=dtype)
             subarr.fill(value)
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index bf45fbf96..9b6a230f6 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -17,7 +17,7 @@ import warnings
 import numpy as np
 import pandas
 from pandas import (Series, TimeSeries, DataFrame, Panel, Panel4D, Index,
-                    MultiIndex, Int64Index, Timestamp)
+                    MultiIndex, Int64Index, Timestamp, _np_version_under1p7)
 from pandas.sparse.api import SparseSeries, SparseDataFrame, SparsePanel
 from pandas.sparse.array import BlockIndex, IntIndex
 from pandas.tseries.api import PeriodIndex, DatetimeIndex
@@ -25,10 +25,11 @@ from pandas.core.base import StringMixin
 from pandas.core.common import adjoin, is_list_like, pprint_thing
 from pandas.core.algorithms import match, unique
 from pandas.core.categorical import Categorical
-from pandas.core.common import _asarray_tuplesafe, _np_version_under1p7
+from pandas.core.common import _asarray_tuplesafe
 from pandas.core.internals import BlockManager, make_block
 from pandas.core.reshape import block2d_to_blocknd, factor_indexer
 from pandas.core.index import _ensure_index
+from pandas.tseries.timedeltas import _coerce_scalar_to_timedelta_type
 import pandas.core.common as com
 from pandas.tools.merge import concat
 from pandas import compat
@@ -4093,7 +4094,7 @@ class Term(StringMixin):
                 v = v.tz_convert('UTC')
             return TermValue(v, v.value, kind)
         elif kind == u('timedelta64') or kind == u('timedelta'):
-            v = com._coerce_scalar_to_timedelta_type(v,unit='s').item()
+            v = _coerce_scalar_to_timedelta_type(v,unit='s').item()
             return TermValue(int(v), v, kind)
         elif (isinstance(v, datetime) or hasattr(v, 'timetuple')
               or kind == u('date')):
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index 3667dff99..3f4ce7219 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -22,7 +22,7 @@ from pandas.util.testing import (assert_panel4d_equal,
                                  assert_frame_equal,
                                  assert_series_equal)
 from pandas import concat, Timestamp
-from pandas import compat
+from pandas import compat, _np_version_under1p7
 from pandas.core import common as com
 
 from numpy.testing.decorators import slow
@@ -1800,7 +1800,7 @@ class TestHDFStore(unittest.TestCase):
             assert_frame_equal(result,df)
 
     def test_append_with_timedelta(self):
-        if com._np_version_under1p7:
+        if _np_version_under1p7:
             raise nose.SkipTest("requires numpy >= 1.7")
 
         # GH 3577
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 723810a19..c5af0b0d4 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -3248,9 +3248,10 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         mixed['F'] = Timestamp('20130101')
 
         # results in an object array
+        from pandas.tseries.timedeltas import _coerce_scalar_to_timedelta_type
         result = mixed.min()
-        expected = Series([com._coerce_scalar_to_timedelta_type(timedelta(seconds=5*60+5)),
-                           com._coerce_scalar_to_timedelta_type(timedelta(days=-1)),
+        expected = Series([_coerce_scalar_to_timedelta_type(timedelta(seconds=5*60+5)),
+                           _coerce_scalar_to_timedelta_type(timedelta(days=-1)),
                            'foo',
                            1,
                            1.0,
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 1f0083547..7a993cbcf 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -14,7 +14,7 @@ import numpy.ma as ma
 import pandas as pd
 
 from pandas import (Index, Series, DataFrame, isnull, notnull,
-                    bdate_range, date_range)
+                    bdate_range, date_range, _np_version_under1p7)
 from pandas.core.index import MultiIndex
 from pandas.tseries.index import Timestamp, DatetimeIndex
 import pandas.core.config as cf
@@ -2188,7 +2188,7 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
             [Timestamp('20130101 9:06:00.005'), Timestamp('20130101 9:07:00.005')])
         assert_series_equal(result, expected)
 
-        if not com._np_version_under1p7:
+        if not _np_version_under1p7:
 
             # operate with np.timedelta64 correctly
             result = s + np.timedelta64(1, 's')
@@ -2292,7 +2292,7 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
                 self.assertRaises(TypeError, sop, s2.values)
 
     def test_timedelta64_conversions(self):
-        if com._np_version_under1p7:
+        if _np_version_under1p7:
             raise nose.SkipTest("cannot use 2 argument form of timedelta64 conversions with numpy < 1.7")
 
         startdate = Series(date_range('2013-01-01', '2013-01-03'))
@@ -2317,7 +2317,7 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
                           'm': 60 * 1000000, 's': 1000000, 'us': 1}
 
         def timedelta64(*args):
-            if com._np_version_under1p7:
+            if _np_version_under1p7:
                 coeffs = np.array(args)
                 terms = np.array([npy16_mappings[interval]
                                   for interval in intervals])
@@ -2426,7 +2426,7 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         assert_series_equal(result, expected)
 
     def test_timedelta_fillna(self):
-        if com._np_version_under1p7:
+        if _np_version_under1p7:
             raise nose.SkipTest("timedelta broken in np 1.6.1")
 
         #GH 3371
@@ -2498,12 +2498,12 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         assert_series_equal(result,expected)
 
     def test_sub_of_datetime_from_TimeSeries(self):
-        from pandas.core import common as com
+        from pandas.tseries.timedeltas import _possibly_cast_to_timedelta
         from datetime import datetime
         a = Timestamp(datetime(1993, 0o1, 0o7, 13, 30, 00))
         b = datetime(1993, 6, 22, 13, 30)
         a = Series([a])
-        result = com._possibly_cast_to_timedelta(np.abs(a - b))
+        result = _possibly_cast_to_timedelta(np.abs(a - b))
         self.assert_(result.dtype == 'timedelta64[ns]')
 
     def test_datetime64_with_index(self):
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index e91cad62e..1572ca481 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -7,8 +7,7 @@ from datetime import timedelta
 import numpy as np
 
 from pandas.core.common import (isnull, _NS_DTYPE, _INT64_DTYPE,
-                                is_list_like,_possibly_cast_to_timedelta,
-                                _values_from_object, _maybe_box)
+                                is_list_like,_values_from_object, _maybe_box)
 from pandas.core.index import Index, Int64Index
 import pandas.compat as compat
 from pandas.compat import u
diff --git a/pandas/tseries/timedeltas.py b/pandas/tseries/timedeltas.py
new file mode 100644
index 000000000..990dd9c35
--- /dev/null
+++ b/pandas/tseries/timedeltas.py
@@ -0,0 +1,111 @@
+"""
+timedelta support tools
+"""
+
+import re
+from datetime import timedelta
+
+import numpy as np
+import pandas.tslib as tslib
+from pandas import compat, _np_version_under1p7
+from pandas.core.common import ABCSeries, is_integer, _values_from_object
+
+timedelta_search = re.compile(
+    "^(?P<value>-?\d*\.?\d*)(?P<unit>D|s|ms|us|ns)?$")
+
+def _coerce_scalar_to_timedelta_type(r, unit='ns'):
+    # kludgy here until we have a timedelta scalar
+    # handle the numpy < 1.7 case
+
+    if isinstance(r, compat.string_types):
+        m = timedelta_search.search(r)
+        if m:
+            r = float(m.groupdict()['value'])
+            u = m.groupdict().get('unit')
+            if u is not None:
+                unit = u
+        else:
+            raise ValueError("cannot convert timedelta scalar value!")
+
+        r = tslib.cast_from_unit(unit, r)
+        r = timedelta(microseconds=int(r)/1000)
+
+    if is_integer(r):
+        r = tslib.cast_from_unit(unit, r)
+        r = timedelta(microseconds=int(r)/1000)
+
+    if _np_version_under1p7:
+        if not isinstance(r, timedelta):
+            raise AssertionError("Invalid type for timedelta scalar: %s" % type(r))
+        if compat.PY3:
+            # convert to microseconds in timedelta64
+            r = np.timedelta64(int(r.total_seconds()*1e9 + r.microseconds*1000))
+        else:
+            return r
+
+    if isinstance(r, timedelta):
+        r = np.timedelta64(r)
+    elif not isinstance(r, np.timedelta64):
+        raise AssertionError("Invalid type for timedelta scalar: %s" % type(r))
+    return r.astype('timedelta64[ns]')
+
+def _possibly_cast_to_timedelta(value, coerce=True):
+    """ try to cast to timedelta64, if already a timedeltalike, then make
+        sure that we are [ns] (as numpy 1.6.2 is very buggy in this regards,
+        don't force the conversion unless coerce is True
+
+        if coerce='compat' force a compatibilty coercerion (to timedeltas) if needeed
+        """
+
+    # coercion compatability
+    if coerce == 'compat' and _np_version_under1p7:
+
+        def convert(td, dtype):
+
+            # we have an array with a non-object dtype
+            if hasattr(td,'item'):
+                td = td.astype(np.int64).item()
+                if td == tslib.iNaT:
+                    return td
+                if dtype == 'm8[us]':
+                    td *= 1000
+                return td
+
+            if td == tslib.compat_NaT:
+                return tslib.iNaT
+
+            # convert td value to a nanosecond value
+            d = td.days
+            s = td.seconds
+            us = td.microseconds
+
+            if dtype == 'object' or dtype == 'm8[ns]':
+                td = 1000*us + (s + d * 24 * 3600) * 10 ** 9
+            else:
+                raise ValueError("invalid conversion of dtype in np < 1.7 [%s]" % dtype)
+
+            return td
+
+        # < 1.7 coercion
+        if not is_list_like(value):
+            value = np.array([ value ])
+
+        dtype = value.dtype
+        return np.array([ convert(v,dtype) for v in value ], dtype='m8[ns]')
+
+    # deal with numpy not being able to handle certain timedelta operations
+    if isinstance(value, (ABCSeries, np.ndarray)) and value.dtype.kind == 'm':
+        if value.dtype != 'timedelta64[ns]':
+            value = value.astype('timedelta64[ns]')
+        return value
+
+    # we don't have a timedelta, but we want to try to convert to one (but
+    # don't force it)
+    if coerce:
+        new_value = tslib.array_to_timedelta64(
+            _values_from_object(value).astype(object), coerce=False)
+        if new_value.dtype == 'i8':
+            value = np.array(new_value, dtype='timedelta64[ns]')
+
+    return value
+

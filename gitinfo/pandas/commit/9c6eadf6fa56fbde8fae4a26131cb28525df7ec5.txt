commit 9c6eadf6fa56fbde8fae4a26131cb28525df7ec5
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Jul 11 15:39:37 2012 -0400

    BUG: tweaks to radviz method, add integer indexing docs close #1607

diff --git a/doc/data/iris.data b/doc/data/iris.data
index 2953c6b56..c19b9c368 100644
--- a/doc/data/iris.data
+++ b/doc/data/iris.data
@@ -148,5 +148,4 @@ SepalLength,SepalWidth,PetalLength,PetalWidth,Name
 6.3,2.5,5.0,1.9,Iris-virginica
 6.5,3.0,5.2,2.0,Iris-virginica
 6.2,3.4,5.4,2.3,Iris-virginica
-5.9,3.0,5.1,1.8,Iris-virginica
-
+5.9,3.0,5.1,1.8,Iris-virginica
\ No newline at end of file
diff --git a/doc/source/gotchas.rst b/doc/source/gotchas.rst
index f4c0eae4c..a86c2b405 100644
--- a/doc/source/gotchas.rst
+++ b/doc/source/gotchas.rst
@@ -118,6 +118,25 @@ integer arrays to floating when NAs must be introduced.
 Integer indexing
 ----------------
 
+Label-based indexing with integer axis labels is a thorny topic. It has been
+discussed heavily on mailing lists and among various members of the scientific
+Python community. In pandas, our general viewpoint is that labels matter more
+than integer locations. Therefore, with an integer axis index *only*
+label-based indexing is possible with the standard tools like ``.ix``. The
+following code will generate exceptions:
+
+.. code-block:: python
+
+   s = Series(range(5))
+   s[-1]
+   df = DataFrame(np.random.randn(5, 4))
+   df
+   df.ix[-2:]
+
+This deliberate decision was made to prevent ambiguities and subtle bugs (many
+users reported finding bugs when the API change was made to stop "falling back"
+on position-based indexing).
+
 Label-based slicing conventions
 -------------------------------
 
diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index c2ef0d74c..9dc87edbe 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -475,12 +475,24 @@ numpy array.  For instance,
 
 Advanced indexing with integer labels
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
 Label-based indexing with integer axis labels is a thorny topic. It has been
 discussed heavily on mailing lists and among various members of the scientific
 Python community. In pandas, our general viewpoint is that labels matter more
-than integer locations. Therefore, advanced indexing with ``.ix`` will always
-attempt label-based indexing, before falling back on integer-based indexing.
+than integer locations. Therefore, with an integer axis index *only*
+label-based indexing is possible with the standard tools like ``.ix``. The
+following code will generate exceptions:
+
+.. code-block:: python
+
+   s = Series(range(5))
+   s[-1]
+   df = DataFrame(np.random.randn(5, 4))
+   df
+   df.ix[-2:]
+
+This deliberate decision was made to prevent ambiguities and subtle bugs (many
+users reported finding bugs when the API change was made to stop "falling back"
+on position-based indexing).
 
 Setting values in mixed-type DataFrame
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff --git a/pandas/tools/plotting.py b/pandas/tools/plotting.py
index dec3a979d..0bedf26ec 100644
--- a/pandas/tools/plotting.py
+++ b/pandas/tools/plotting.py
@@ -165,44 +165,69 @@ def radviz(frame, class_column, ax=None, **kwds):
     import matplotlib.patches as patches
     import matplotlib.text as text
     import random
+
     def random_color(column):
         random.seed(column)
         return [random.random() for _ in range(3)]
+
     def normalize(series):
         a = min(series)
         b = max(series)
         return (series - a) / (b - a)
-    column_names = [column_name for column_name in frame.columns if column_name != class_column]
-    columns = [normalize(frame[column_name]) for column_name in column_names]
-    if ax == None:
+
+    column_names = [column_name for column_name in frame.columns
+                    if column_name != class_column]
+
+    df = frame[column_names].apply(normalize)
+
+    if ax is None:
         ax = plt.gca(xlim=[-1, 1], ylim=[-1, 1])
+
     classes = set(frame[class_column])
     to_plot = {}
+
     for class_ in classes:
         to_plot[class_] = [[], []]
+
     n = len(frame.columns) - 1
-    s = np.array([(np.cos(t), np.sin(t)) for t in [2.0 * np.pi * (i / float(n)) for i in range(n)]])
+    s = np.array([(np.cos(t), np.sin(t))
+                  for t in [2.0 * np.pi * (i / float(n))
+                            for i in range(n)]])
+
     for i in range(len(frame)):
-        row = np.array([column[i] for column in columns])
+        row = df.irow(i).values
         row_ = np.repeat(np.expand_dims(row, axis=1), 2, axis=1)
         y = (s * row_).sum(axis=0) / row.sum()
-        class_name = frame[class_column][i]
+        class_name = frame[class_column].iget(i)
         to_plot[class_name][0].append(y[0])
         to_plot[class_name][1].append(y[1])
+
     for class_ in classes:
-        ax.scatter(to_plot[class_][0], to_plot[class_][1], color=random_color(class_), label=str(class_), **kwds)
+        line = ax.scatter(to_plot[class_][0],
+                          to_plot[class_][1],
+                          color=random_color(class_),
+                          label=str(class_), **kwds)
+    ax.legend()
+
     ax.add_patch(patches.Circle((0.0, 0.0), radius=1.0, facecolor='none'))
+
     for xy, name in zip(s, column_names):
+
         ax.add_patch(patches.Circle(xy, radius=0.025, facecolor='gray'))
+
         if xy[0] < 0.0 and xy[1] < 0.0:
-            ax.text(xy[0] - 0.025, xy[1] - 0.025, name, ha='right', va='top', size='small')
+            ax.text(xy[0] - 0.025, xy[1] - 0.025, name,
+                    ha='right', va='top', size='small')
         elif xy[0] < 0.0 and xy[1] >= 0.0:
-            ax.text(xy[0] - 0.025, xy[1] + 0.025, name, ha='right', va='bottom', size='small')
+            ax.text(xy[0] - 0.025, xy[1] + 0.025, name,
+                    ha='right', va='bottom', size='small')
         elif xy[0] >= 0.0 and xy[1] < 0.0:
-            ax.text(xy[0] + 0.025, xy[1] - 0.025, name, ha='left', va='top', size='small')
+            ax.text(xy[0] + 0.025, xy[1] - 0.025, name,
+                    ha='left', va='top', size='small')
         elif xy[0] >= 0.0 and xy[1] >= 0.0:
-            ax.text(xy[0] + 0.025, xy[1] + 0.025, name, ha='left', va='bottom', size='small')
-    ax.legend(loc='upper right')
+            ax.text(xy[0] + 0.025, xy[1] + 0.025, name,
+                    ha='left', va='bottom', size='small')
+
     ax.axis('equal')
     return ax
 

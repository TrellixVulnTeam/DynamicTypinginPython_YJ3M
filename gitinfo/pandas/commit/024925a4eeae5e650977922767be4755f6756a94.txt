commit 024925a4eeae5e650977922767be4755f6756a94
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sat Jan 18 08:03:17 2020 -0800

    REF: handle searchsorted casting within DatetimeLikeArray (#30950)

diff --git a/doc/source/whatsnew/v1.1.0.rst b/doc/source/whatsnew/v1.1.0.rst
index b5106a1b1..82a3aa6e0 100644
--- a/doc/source/whatsnew/v1.1.0.rst
+++ b/doc/source/whatsnew/v1.1.0.rst
@@ -60,7 +60,7 @@ Categorical
 Datetimelike
 ^^^^^^^^^^^^
 - Bug in :class:`Timestamp` where constructing :class:`Timestamp` from ambiguous epoch time and calling constructor again changed :meth:`Timestamp.value` property (:issue:`24329`)
--
+- :meth:`DatetimeArray.searchsorted`, :meth:`TimedeltaArray.searchsorted`, :meth:`PeriodArray.searchsorted` not recognizing non-pandas scalars and incorrectly raising ``ValueError`` instead of ``TypeError`` (:issue:`30950`)
 -
 
 Timedelta
diff --git a/pandas/core/arrays/datetimelike.py b/pandas/core/arrays/datetimelike.py
index d7c508c89..70637026c 100644
--- a/pandas/core/arrays/datetimelike.py
+++ b/pandas/core/arrays/datetimelike.py
@@ -743,17 +743,36 @@ class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)
             Array of insertion points with the same shape as `value`.
         """
         if isinstance(value, str):
-            value = self._scalar_from_string(value)
+            try:
+                value = self._scalar_from_string(value)
+            except ValueError:
+                raise TypeError("searchsorted requires compatible dtype or scalar")
+
+        elif is_valid_nat_for_dtype(value, self.dtype):
+            value = NaT
+
+        elif isinstance(value, self._recognized_scalars):
+            value = self._scalar_type(value)
+
+        elif isinstance(value, np.ndarray):
+            if not type(self)._is_recognized_dtype(value):
+                raise TypeError(
+                    "searchsorted requires compatible dtype or scalar, "
+                    f"not {type(value).__name__}"
+                )
+            value = type(self)(value)
+            self._check_compatible_with(value)
 
-        if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):
-            raise ValueError(f"Unexpected type for 'value': {type(value)}")
+        if not (isinstance(value, (self._scalar_type, type(self))) or (value is NaT)):
+            raise TypeError(f"Unexpected type for 'value': {type(value)}")
 
-        self._check_compatible_with(value)
         if isinstance(value, type(self)):
+            self._check_compatible_with(value)
             value = value.asi8
         else:
             value = self._unbox_scalar(value)
 
+        # TODO: Use datetime64 semantics for sorting, xref GH#29844
         return self.asi8.searchsorted(value, side=side, sorter=sorter)
 
     def repeat(self, repeats, *args, **kwargs):
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index 8dc9ff869..e8935950c 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -833,24 +833,13 @@ class DatetimeIndex(DatetimeTimedeltaMixin, DatetimeDelegateMixin):
     @Substitution(klass="DatetimeIndex")
     @Appender(_shared_docs["searchsorted"])
     def searchsorted(self, value, side="left", sorter=None):
-        if isinstance(value, (np.ndarray, Index)):
-            if not type(self._data)._is_recognized_dtype(value):
-                raise TypeError(
-                    "searchsorted requires compatible dtype or scalar, "
-                    f"not {type(value).__name__}"
-                )
-            value = type(self._data)(value)
-            self._data._check_compatible_with(value)
-
-        elif isinstance(value, self._data._recognized_scalars):
-            self._data._check_compatible_with(value)
-            value = self._data._scalar_type(value)
-
-        elif not isinstance(value, DatetimeArray):
+        if isinstance(value, str):
             raise TypeError(
                 "searchsorted requires compatible dtype or scalar, "
                 f"not {type(value).__name__}"
             )
+        if isinstance(value, Index):
+            value = value._data
 
         return self._data.searchsorted(value, side=side)
 
diff --git a/pandas/core/indexes/period.py b/pandas/core/indexes/period.py
index a54d09e8b..bb7f6fb65 100644
--- a/pandas/core/indexes/period.py
+++ b/pandas/core/indexes/period.py
@@ -470,18 +470,6 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index, PeriodDelegateMixin):
     @Substitution(klass="PeriodIndex")
     @Appender(_shared_docs["searchsorted"])
     def searchsorted(self, value, side="left", sorter=None):
-        if isinstance(value, Period) or value is NaT:
-            self._data._check_compatible_with(value)
-        elif isinstance(value, str):
-            try:
-                value = Period(value, freq=self.freq)
-            except DateParseError:
-                raise KeyError(f"Cannot interpret '{value}' as period")
-        elif not isinstance(value, PeriodArray):
-            raise TypeError(
-                "PeriodIndex.searchsorted requires either a Period or PeriodArray"
-            )
-
         return self._data.searchsorted(value, side=side, sorter=sorter)
 
     @property
diff --git a/pandas/core/indexes/timedeltas.py b/pandas/core/indexes/timedeltas.py
index 9dba87f67..41ade4d2f 100644
--- a/pandas/core/indexes/timedeltas.py
+++ b/pandas/core/indexes/timedeltas.py
@@ -347,24 +347,13 @@ class TimedeltaIndex(
     @Substitution(klass="TimedeltaIndex")
     @Appender(_shared_docs["searchsorted"])
     def searchsorted(self, value, side="left", sorter=None):
-        if isinstance(value, (np.ndarray, Index)):
-            if not type(self._data)._is_recognized_dtype(value):
-                raise TypeError(
-                    "searchsorted requires compatible dtype or scalar, "
-                    f"not {type(value).__name__}"
-                )
-            value = type(self._data)(value)
-            self._data._check_compatible_with(value)
-
-        elif isinstance(value, self._data._recognized_scalars):
-            self._data._check_compatible_with(value)
-            value = self._data._scalar_type(value)
-
-        elif not isinstance(value, TimedeltaArray):
+        if isinstance(value, str):
             raise TypeError(
                 "searchsorted requires compatible dtype or scalar, "
                 f"not {type(value).__name__}"
             )
+        if isinstance(value, Index):
+            value = value._data
 
         return self._data.searchsorted(value, side=side, sorter=sorter)
 
diff --git a/pandas/tests/arrays/test_datetimes.py b/pandas/tests/arrays/test_datetimes.py
index 5608ab5fb..a59ed429c 100644
--- a/pandas/tests/arrays/test_datetimes.py
+++ b/pandas/tests/arrays/test_datetimes.py
@@ -331,25 +331,19 @@ class TestDatetimeArray:
             pd.Timestamp.now().to_period("D"),
         ],
     )
-    @pytest.mark.parametrize(
-        "index",
-        [
-            True,
-            pytest.param(
-                False,
-                marks=pytest.mark.xfail(
-                    reason="Raises ValueError instead of TypeError", raises=ValueError
-                ),
-            ),
-        ],
-    )
+    @pytest.mark.parametrize("index", [True, False])
     def test_searchsorted_invalid_types(self, other, index):
         data = np.arange(10, dtype="i8") * 24 * 3600 * 10 ** 9
         arr = DatetimeArray(data, freq="D")
         if index:
             arr = pd.Index(arr)
 
-        msg = "searchsorted requires compatible dtype or scalar"
+        msg = "|".join(
+            [
+                "searchsorted requires compatible dtype or scalar",
+                "Unexpected type for 'value'",
+            ]
+        )
         with pytest.raises(TypeError, match=msg):
             arr.searchsorted(other)
 
diff --git a/pandas/tests/arrays/test_timedeltas.py b/pandas/tests/arrays/test_timedeltas.py
index 62cb47661..c86b4f71e 100644
--- a/pandas/tests/arrays/test_timedeltas.py
+++ b/pandas/tests/arrays/test_timedeltas.py
@@ -154,25 +154,19 @@ class TestTimedeltaArray:
             pd.Timestamp.now().to_period("D"),
         ],
     )
-    @pytest.mark.parametrize(
-        "index",
-        [
-            True,
-            pytest.param(
-                False,
-                marks=pytest.mark.xfail(
-                    reason="Raises ValueError instead of TypeError", raises=ValueError
-                ),
-            ),
-        ],
-    )
+    @pytest.mark.parametrize("index", [True, False])
     def test_searchsorted_invalid_types(self, other, index):
         data = np.arange(10, dtype="i8") * 24 * 3600 * 10 ** 9
         arr = TimedeltaArray(data, freq="D")
         if index:
             arr = pd.Index(arr)
 
-        msg = "searchsorted requires compatible dtype or scalar"
+        msg = "|".join(
+            [
+                "searchsorted requires compatible dtype or scalar",
+                "Unexpected type for 'value'",
+            ]
+        )
         with pytest.raises(TypeError, match=msg):
             arr.searchsorted(other)
 
diff --git a/pandas/tests/indexes/period/test_tools.py b/pandas/tests/indexes/period/test_tools.py
index 28ab14af7..23350fdff 100644
--- a/pandas/tests/indexes/period/test_tools.py
+++ b/pandas/tests/indexes/period/test_tools.py
@@ -249,7 +249,12 @@ class TestPeriodIndex:
 
         other = np.array([0, 1], dtype=np.int64)
 
-        msg = "requires either a Period or PeriodArray"
+        msg = "|".join(
+            [
+                "searchsorted requires compatible dtype or scalar",
+                "Unexpected type for 'value'",
+            ]
+        )
         with pytest.raises(TypeError, match=msg):
             pidx.searchsorted(other)
 

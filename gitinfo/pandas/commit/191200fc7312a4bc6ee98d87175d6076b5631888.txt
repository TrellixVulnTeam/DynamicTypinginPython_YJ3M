commit 191200fc7312a4bc6ee98d87175d6076b5631888
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Oct 1 16:29:28 2011 -0400

    ENH: fast DateRange.intersection in some cases and sped up DateRange.union in some cases. address GH #178

diff --git a/RELEASE.rst b/RELEASE.rst
index 73b04aeac..38d3f65b6 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -53,6 +53,8 @@ This is an incremental bug fix and performance enhancement release
   - Throw exception when step specified in label-based slice (GH #185)
   - Fix isnull to correctly work with np.float32. Fix upstream bug described in
     GH #182
+  - Finish implementation of as_index=False in groupby for DataFrame
+    aggregation (GH #181)
 
 pandas 0.4.1
 ============
diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index 4b23ec2bf..8d3e1d51a 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -66,9 +66,7 @@ class DateRange(Index):
         end = datetools.to_datetime(end)
 
         # inside cache range. Handle UTC case
-
-        useCache = (offset.isAnchored() and
-                    isinstance(offset, datetools.CacheableOffset))
+        useCache = _will_use_cache(offset)
 
         start, end, tzinfo = _figure_out_timezone(start, end, tzinfo)
         useCache = useCache and _naive_in_cache_range(start, end)
@@ -285,16 +283,72 @@ class DateRange(Index):
         else:
             left, right = other, self
 
-        left_start, left_end = left[0], left[-1]
-        right_start, right_end = right[0], right[-1]
+        left_end = left[-1]
+        right_start = right[0]
 
         # Only need to "adjoin", not overlap
         if (left_end + offset) >= right_start:
-            return DateRange(left_start, max(left_end, right_end),
-                             offset=offset)
+            return left._fast_union(right)
         else:
             return Index.union(self, other)
 
+    def intersection(self, other):
+        """
+        Specialized intersection for DateRange objects. May be much faster than
+        Index.union
+
+        Parameters
+        ----------
+        other : DateRange or array-like
+
+        Returns
+        -------
+        y : Index or DateRange
+        """
+        if not isinstance(other, DateRange) or other.offset != self.offset:
+            return Index.intersection(self.view(Index), other)
+
+        # to make our life easier, "sort" the two ranges
+        if self[0] <= other[0]:
+            left, right = self, other
+        else:
+            left, right = other, self
+
+        left_end = left[-1]
+        right_start = right[0]
+
+        if left_end < right_start:
+            return Index([])
+        else:
+            lslice = slice(*left.slice_locs(right_start, None))
+            left_chunk = left.values[lslice]
+            return self._view_like(left_chunk)
+
+    def _fast_union(self, other):
+        left, right = self, other
+
+        left_start, left_end = left[0], left[-1]
+        right_end = right[-1]
+
+        if not _will_use_cache(self.offset):
+            # concatenate dates
+            if left_end < right_end:
+                loc = right.searchsorted(left_end, side='right')
+                right_chunk = right.values[loc:]
+                dates = np.concatenate((left.values, right_chunk))
+                return self._view_like(dates)
+            else:
+                return left
+        else:
+            return DateRange(left_start, max(left_end, right_end),
+                             offset=left.offset)
+
+    def _view_like(self, ndarray):
+        result = ndarray.view(DateRange)
+        result.offset = self.offset
+        result.tzinfo = self.tzinfo
+        return result
+
     def _wrap_union_result(self, other, result):
         return Index(result)
 
@@ -484,6 +538,11 @@ def _infer_tzinfo(start, end):
         tz = _infer(end, start)
     return tz
 
+def _will_use_cache(offset):
+    return (offset.isAnchored() and
+            isinstance(offset, datetools.CacheableOffset))
+
+
 if __name__ == '__main__':
     import pytz
     # just want it to work
diff --git a/pandas/tests/test_daterange.py b/pandas/tests/test_daterange.py
index b3c4651b0..02ced4f5e 100644
--- a/pandas/tests/test_daterange.py
+++ b/pandas/tests/test_daterange.py
@@ -162,6 +162,37 @@ class TestDateRange(unittest.TestCase):
         the_union = self.rng.union(rng)
         self.assert_(not isinstance(the_union, DateRange))
 
+    def test_union_not_cacheable(self):
+        rng = DateRange('1/1/2000', periods=50, offset=datetools.Minute())
+        rng1 = rng[10:]
+        rng2 = rng[:25]
+        the_union = rng1.union(rng2)
+        self.assert_(the_union.equals(rng))
+
+        rng1 = rng[10:]
+        rng2 = rng[15:35]
+        the_union = rng1.union(rng2)
+        expected = rng[10:]
+        self.assert_(the_union.equals(expected))
+
+    def test_intersection(self):
+        rng = DateRange('1/1/2000', periods=50, offset=datetools.Minute())
+        rng1 = rng[10:]
+        rng2 = rng[:25]
+        the_int = rng1.intersection(rng2)
+        expected = rng[10:25]
+        self.assert_(the_int.equals(expected))
+        self.assert_(isinstance(the_int, DateRange))
+        self.assert_(the_int.offset == rng.offset)
+
+        the_int = rng1.intersection(rng2.view(Index))
+        self.assert_(the_int.equals(expected))
+
+        # non-overlapping
+        the_int = rng[:10].intersection(rng[10:])
+        expected = Index([])
+        self.assert_(the_int.equals(expected))
+
     def test_with_tzinfo(self):
         _skip_if_no_pytz()
         tz = pytz.timezone('US/Central')

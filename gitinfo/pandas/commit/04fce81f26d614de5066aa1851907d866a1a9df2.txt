commit 04fce81f26d614de5066aa1851907d866a1a9df2
Author: Soyoun Kim <makeajourney@gmail.com>
Date:   Sun Dec 15 21:35:22 2019 +0900

    CLN: changed .format to f-string in pandas/core/indexes (#30273)

diff --git a/pandas/core/indexes/accessors.py b/pandas/core/indexes/accessors.py
index e8d2ba85e..ae27aad3d 100644
--- a/pandas/core/indexes/accessors.py
+++ b/pandas/core/indexes/accessors.py
@@ -26,8 +26,8 @@ class Properties(PandasDelegate, PandasObject, NoNewAttributesMixin):
     def __init__(self, data, orig):
         if not isinstance(data, ABCSeries):
             raise TypeError(
-                "cannot convert an object of type {0} to a "
-                "datetimelike index".format(type(data))
+                f"cannot convert an object of type {type(data)} to a "
+                "datetimelike index"
             )
 
         self._parent = data
@@ -54,8 +54,7 @@ class Properties(PandasDelegate, PandasObject, NoNewAttributesMixin):
                 return DatetimeIndex(data, copy=False, name=self.name)
 
         raise TypeError(
-            "cannot convert an object of type {0} to a "
-            "datetimelike index".format(type(data))
+            f"cannot convert an object of type {type(data)} to a datetimelike index"
         )
 
     def _delegate_property_get(self, name):
@@ -315,8 +314,8 @@ class CombinedDatetimelikeProperties(
 
         if not isinstance(data, ABCSeries):
             raise TypeError(
-                "cannot convert an object of type {0} to a "
-                "datetimelike index".format(type(data))
+                f"cannot convert an object of type {type(data)} to a "
+                "datetimelike index"
             )
 
         orig = data if is_categorical_dtype(data) else None
diff --git a/pandas/core/indexes/category.py b/pandas/core/indexes/category.py
index dc1cbb601..44478d00d 100644
--- a/pandas/core/indexes/category.py
+++ b/pandas/core/indexes/category.py
@@ -893,7 +893,7 @@ class CategoricalIndex(Index, accessor.PandasDelegate):
         """ add in comparison methods """
 
         def _make_compare(op):
-            opname = "__{op}__".format(op=op.__name__)
+            opname = f"__{op.__name__}__"
 
             def _evaluate_compare(self, other):
                 with np.errstate(all="ignore"):
diff --git a/pandas/core/indexes/datetimelike.py b/pandas/core/indexes/datetimelike.py
index eb3728c1e..50dbddec5 100644
--- a/pandas/core/indexes/datetimelike.py
+++ b/pandas/core/indexes/datetimelike.py
@@ -137,7 +137,7 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
             return result
 
         wrapper.__doc__ = op.__doc__
-        wrapper.__name__ = "__{}__".format(op.__name__)
+        wrapper.__name__ = f"__{op.__name__}__"
         return wrapper
 
     @property
@@ -677,7 +677,7 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
             name = type(self).__name__
         result = f"{name}: {len(self)} entries{index_summary}"
         if self.freq:
-            result += "\nFreq: %s" % self.freqstr
+            result += f"\nFreq: {self.freqstr}"
 
         # display as values, not quoted
         result = result.replace("'", "")
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index cafa2e03f..523c434cb 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -247,10 +247,8 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index, DatetimeDelegateMixin):
 
         if is_scalar(data):
             raise TypeError(
-                "{cls}() must be called with a "
-                "collection of some kind, {data} was passed".format(
-                    cls=cls.__name__, data=repr(data)
-                )
+                f"{cls.__name__}() must be called with a "
+                f"collection of some kind, {repr(data)} was passed"
             )
 
         # - Cases checked above all return/raise before reaching here - #
@@ -973,9 +971,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index, DatetimeDelegateMixin):
         elif isinstance(key, timedelta):
             # GH#20464
             raise TypeError(
-                "Cannot index {cls} with {other}".format(
-                    cls=type(self).__name__, other=type(key).__name__
-                )
+                f"Cannot index {type(self).__name__} with {type(key).__name__}"
             )
 
         if isinstance(key, time):
@@ -1577,13 +1573,13 @@ def bdate_range(
             weekmask = weekmask or "Mon Tue Wed Thu Fri"
             freq = prefix_mapping[freq](holidays=holidays, weekmask=weekmask)
         except (KeyError, TypeError):
-            msg = "invalid custom frequency string: {freq}".format(freq=freq)
+            msg = f"invalid custom frequency string: {freq}"
             raise ValueError(msg)
     elif holidays or weekmask:
         msg = (
             "a custom frequency string is required when holidays or "
-            "weekmask are passed, got frequency {freq}"
-        ).format(freq=freq)
+            f"weekmask are passed, got frequency {freq}"
+        )
         raise ValueError(msg)
 
     return date_range(
diff --git a/pandas/core/indexes/frozen.py b/pandas/core/indexes/frozen.py
index 27f88933f..fd8ab74ed 100644
--- a/pandas/core/indexes/frozen.py
+++ b/pandas/core/indexes/frozen.py
@@ -93,11 +93,7 @@ class FrozenList(PandasObject, list):
 
     def _disabled(self, *args, **kwargs):
         """This method will not function because object is immutable."""
-        raise TypeError(
-            "'{cls}' does not support mutable operations.".format(
-                cls=type(self).__name__
-            )
-        )
+        raise TypeError(f"'{type(self).__name__}' does not support mutable operations.")
 
     def __str__(self) -> str:
         return pprint_thing(self, quote_strings=True, escape_chars=("\t", "\r", "\n"))
diff --git a/pandas/core/indexes/interval.py b/pandas/core/indexes/interval.py
index b1f67eeab..f046f0d89 100644
--- a/pandas/core/indexes/interval.py
+++ b/pandas/core/indexes/interval.py
@@ -154,10 +154,10 @@ class SetopCheck:
             common_subtype = find_common_type(subtypes)
             if is_object_dtype(common_subtype):
                 msg = (
-                    "can only do {op} between two IntervalIndex "
+                    f"can only do {self.op_name} between two IntervalIndex "
                     "objects that have compatible dtypes"
                 )
-                raise TypeError(msg.format(op=self.op_name))
+                raise TypeError(msg)
 
             return setop(intvidx_self, other, sort)
 
@@ -432,8 +432,7 @@ class IntervalIndex(IntervalMixin, Index):
     )
     def set_closed(self, closed):
         if closed not in _VALID_CLOSED:
-            msg = "invalid option for 'closed': {closed}"
-            raise ValueError(msg.format(closed=closed))
+            raise ValueError(f"invalid option for 'closed': {closed}")
 
         # return self._shallow_copy(closed=closed)
         array = self._data.set_closed(closed)
@@ -762,12 +761,12 @@ class IntervalIndex(IntervalMixin, Index):
 
         # ensure consistency with IntervalIndex subtype
         subtype = self.dtype.subtype
-        msg = (
-            "Cannot index an IntervalIndex of subtype {subtype} with "
-            "values of dtype {other}"
-        )
+
         if not is_dtype_equal(subtype, key_dtype):
-            raise ValueError(msg.format(subtype=subtype, other=key_dtype))
+            raise ValueError(
+                f"Cannot index an IntervalIndex of subtype {subtype} with "
+                f"values of dtype {key_dtype}"
+            )
 
         return key_i8
 
@@ -776,8 +775,8 @@ class IntervalIndex(IntervalMixin, Index):
             return
 
         if method in ["bfill", "backfill", "pad", "ffill", "nearest"]:
-            msg = "method {method} not yet implemented for IntervalIndex"
-            raise NotImplementedError(msg.format(method=method))
+            msg = f"method {method} not yet implemented for IntervalIndex"
+            raise NotImplementedError(msg)
 
         raise ValueError("Invalid fill method")
 
@@ -1165,23 +1164,21 @@ class IntervalIndex(IntervalMixin, Index):
             summary = "[]"
         elif n == 1:
             first = formatter(self[0])
-            summary = "[{first}]".format(first=first)
+            summary = f"[{first}]"
         elif n == 2:
             first = formatter(self[0])
             last = formatter(self[-1])
-            summary = "[{first}, {last}]".format(first=first, last=last)
+            summary = f"[{first}, {last}]"
         else:
 
             if n > max_seq_items:
                 n = min(max_seq_items // 2, 10)
                 head = [formatter(x) for x in self[:n]]
                 tail = [formatter(x) for x in self[-n:]]
-                summary = "[{head} ... {tail}]".format(
-                    head=", ".join(head), tail=", ".join(tail)
-                )
+                summary = f"[{', '.join(head)} ... {', '.join(tail)}]"
             else:
                 tail = [formatter(x) for x in self]
-                summary = "[{tail}]".format(tail=", ".join(tail))
+                summary = f"[{', '.join(tail)}]"
 
         return summary + "," + self._format_space()
 
@@ -1189,12 +1186,12 @@ class IntervalIndex(IntervalMixin, Index):
         attrs = [("closed", repr(self.closed))]
         if self.name is not None:
             attrs.append(("name", default_pprint(self.name)))
-        attrs.append(("dtype", "'{dtype}'".format(dtype=self.dtype)))
+        attrs.append(("dtype", f"'{self.dtype}'"))
         return attrs
 
     def _format_space(self):
         space = " " * (len(type(self).__name__) + 1)
-        return "\n{space}".format(space=space)
+        return f"\n{space}"
 
     # --------------------------------------------------------------------
 
@@ -1490,25 +1487,21 @@ def interval_range(
         )
 
     if not _is_valid_endpoint(start):
-        msg = "start must be numeric or datetime-like, got {start}"
-        raise ValueError(msg.format(start=start))
+        raise ValueError(f"start must be numeric or datetime-like, got {start}")
     elif not _is_valid_endpoint(end):
-        msg = "end must be numeric or datetime-like, got {end}"
-        raise ValueError(msg.format(end=end))
+        raise ValueError(f"end must be numeric or datetime-like, got {end}")
 
     if is_float(periods):
         periods = int(periods)
     elif not is_integer(periods) and periods is not None:
-        msg = "periods must be a number, got {periods}"
-        raise TypeError(msg.format(periods=periods))
+        raise TypeError(f"periods must be a number, got {periods}")
 
     if freq is not None and not is_number(freq):
         try:
             freq = to_offset(freq)
         except ValueError:
             raise ValueError(
-                "freq must be numeric or convertible to "
-                "DateOffset, got {freq}".format(freq=freq)
+                f"freq must be numeric or convertible to DateOffset, got {freq}"
             )
 
     # verify type compatibility
diff --git a/pandas/core/indexes/multi.py b/pandas/core/indexes/multi.py
index 7b0cc871c..459d1fd19 100644
--- a/pandas/core/indexes/multi.py
+++ b/pandas/core/indexes/multi.py
@@ -343,35 +343,26 @@ class MultiIndex(Index):
         for i, (level, level_codes) in enumerate(zip(levels, codes)):
             if len(level_codes) != codes_length:
                 raise ValueError(
-                    "Unequal code lengths: %s" % ([len(code_) for code_ in codes])
+                    f"Unequal code lengths: {[len(code_) for code_ in codes]}"
                 )
             if len(level_codes) and level_codes.max() >= len(level):
-                msg = (
-                    "On level {level}, code max ({max_code}) >= length of "
-                    "level ({level_len}). NOTE: this index is in an "
-                    "inconsistent state".format(
-                        level=i, max_code=level_codes.max(), level_len=len(level)
-                    )
-                )
-                raise ValueError(msg)
-            if len(level_codes) and level_codes.min() < -1:
                 raise ValueError(
-                    "On level {level}, code value ({code})"
-                    " < -1".format(level=i, code=level_codes.min())
+                    f"On level {i}, code max ({level_codes.max()}) >= length of "
+                    f"level ({len(level)}). NOTE: this index is in an "
+                    "inconsistent state"
                 )
+            if len(level_codes) and level_codes.min() < -1:
+                raise ValueError(f"On level {i}, code value ({level_codes.min()}) < -1")
             if not level.is_unique:
                 raise ValueError(
-                    "Level values must be unique: {values} on "
-                    "level {level}".format(values=list(level), level=i)
+                    f"Level values must be unique: {list(level)} on level {i}"
                 )
         if self.sortorder is not None:
             if self.sortorder > self._lexsort_depth():
                 raise ValueError(
-                    "Value for sortorder must be inferior or equal "
-                    "to actual lexsort_depth: "
-                    "sortorder {sortorder} with lexsort_depth {lexsort_depth}".format(
-                        sortorder=self.sortorder, lexsort_depth=self._lexsort_depth()
-                    )
+                    "Value for sortorder must be inferior or equal to actual "
+                    f"lexsort_depth: sortorder {self.sortorder} "
+                    f"with lexsort_depth {self._lexsort_depth()}"
                 )
 
         codes = [
@@ -1241,7 +1232,7 @@ class MultiIndex(Index):
                 # All items in 'names' need to be hashable:
                 if not is_hashable(name):
                     raise TypeError(
-                        "{}.name must be a hashable type".format(type(self).__name__)
+                        f"{type(self).__name__}.name must be a hashable type"
                     )
             self._names[lev] = name
 
@@ -1312,8 +1303,8 @@ class MultiIndex(Index):
             # Note: levels are zero-based
             elif level >= self.nlevels:
                 raise IndexError(
-                    "Too many levels: Index has only %d levels, "
-                    "not %d" % (self.nlevels, level + 1)
+                    f"Too many levels: Index has only {self.nlevels} levels, "
+                    f"not {level + 1}"
                 )
         return level
 
@@ -1465,7 +1456,7 @@ class MultiIndex(Index):
         elif how == "all":
             indexer = np.all(nans, axis=0)
         else:
-            raise ValueError("invalid how option: {0}".format(how))
+            raise ValueError(f"invalid how option: {how}")
 
         new_codes = [level_codes[~indexer] for level_codes in self.codes]
         return self.copy(codes=new_codes, deep=True)
@@ -2103,7 +2094,7 @@ class MultiIndex(Index):
                     loc = loc.nonzero()[0]
                     inds.extend(loc)
                 else:
-                    msg = "unsupported indexer of type {}".format(type(loc))
+                    msg = f"unsupported indexer of type {type(loc)}"
                     raise AssertionError(msg)
             except KeyError:
                 if errors != "ignore":
@@ -2330,7 +2321,7 @@ class MultiIndex(Index):
             check = self.levels[0].get_indexer(keyarr)
             mask = check == -1
             if mask.any():
-                raise KeyError("%s not in index" % keyarr[mask])
+                raise KeyError(f"{keyarr[mask]} not in index")
 
         return indexer, keyarr
 
@@ -2600,8 +2591,7 @@ class MultiIndex(Index):
         keylen = len(key)
         if self.nlevels < keylen:
             raise KeyError(
-                "Key length ({0}) exceeds index depth ({1})"
-                "".format(keylen, self.nlevels)
+                f"Key length ({keylen}) exceeds index depth ({self.nlevels})"
             )
 
         if keylen == self.nlevels and self.is_unique:
@@ -2917,9 +2907,8 @@ class MultiIndex(Index):
         true_slices = [i for (i, s) in enumerate(com.is_true_slices(seq)) if s]
         if true_slices and true_slices[-1] >= self.lexsort_depth:
             raise UnsortedIndexError(
-                "MultiIndex slicing requires the index "
-                "to be lexsorted: slicing on levels {0}, "
-                "lexsort depth {1}".format(true_slices, self.lexsort_depth)
+                "MultiIndex slicing requires the index to be lexsorted: slicing "
+                f"on levels {true_slices}, lexsort depth {self.lexsort_depth}"
             )
         # indexer
         # this is the list of all values that we want to select
@@ -3261,10 +3250,10 @@ class MultiIndex(Index):
             msg = "> 1 ndim Categorical are not supported at this time"
             raise NotImplementedError(msg)
         elif not is_object_dtype(dtype):
-            msg = (
-                "Setting {cls} dtype to anything other than object is not supported"
-            ).format(cls=type(self))
-            raise TypeError(msg)
+            raise TypeError(
+                f"Setting {type(self)} dtype to anything other "
+                "than object is not supported"
+            )
         elif copy is True:
             return self._shallow_copy()
         return self
diff --git a/pandas/core/indexes/numeric.py b/pandas/core/indexes/numeric.py
index 536a1fb6a..048bff467 100644
--- a/pandas/core/indexes/numeric.py
+++ b/pandas/core/indexes/numeric.py
@@ -381,11 +381,10 @@ class Float64Index(NumericIndex):
     def astype(self, dtype, copy=True):
         dtype = pandas_dtype(dtype)
         if needs_i8_conversion(dtype):
-            msg = (
-                "Cannot convert Float64Index to dtype {dtype}; integer "
+            raise TypeError(
+                f"Cannot convert Float64Index to dtype {dtype}; integer "
                 "values are required for conversion"
-            ).format(dtype=dtype)
-            raise TypeError(msg)
+            )
         elif is_integer_dtype(dtype) and not is_extension_array_dtype(dtype):
             # TODO(jreback); this can change once we have an EA Index type
             # GH 13149
diff --git a/pandas/core/indexes/period.py b/pandas/core/indexes/period.py
index 15639d443..979ab275f 100644
--- a/pandas/core/indexes/period.py
+++ b/pandas/core/indexes/period.py
@@ -182,11 +182,8 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index, PeriodDelegateMixin):
         }
 
         if not set(fields).issubset(valid_field_set):
-            raise TypeError(
-                "__new__() got an unexpected keyword argument {}".format(
-                    list(set(fields) - valid_field_set)[0]
-                )
-            )
+            argument = list(set(fields) - valid_field_set)[0]
+            raise TypeError(f"__new__() got an unexpected keyword argument {argument}")
 
         if name is None and hasattr(data, "name"):
             name = data.name
@@ -445,10 +442,10 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index, PeriodDelegateMixin):
                     return Index(result, name=name)
             elif isinstance(func, np.ufunc):
                 if "M->M" not in func.types:
-                    msg = "ufunc '{0}' not supported for the PeriodIndex"
+                    msg = f"ufunc '{func.__name__}' not supported for the PeriodIndex"
                     # This should be TypeError, but TypeError cannot be raised
                     # from here because numpy catches.
-                    raise ValueError(msg.format(func.__name__))
+                    raise ValueError(msg)
 
         if is_bool_dtype(result):
             return result
@@ -508,7 +505,7 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index, PeriodDelegateMixin):
             try:
                 value = Period(value, freq=self.freq).ordinal
             except DateParseError:
-                raise KeyError("Cannot interpret '{}' as period".format(value))
+                raise KeyError(f"Cannot interpret '{value}' as period")
 
         return self._ndarray_values.searchsorted(value, side=side, sorter=sorter)
 
@@ -656,7 +653,7 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index, PeriodDelegateMixin):
                 pass
             except DateParseError:
                 # A string with invalid format
-                raise KeyError("Cannot interpret '{}' as period".format(key))
+                raise KeyError(f"Cannot interpret '{key}' as period")
 
             try:
                 key = Period(key, freq=self.freq)
diff --git a/pandas/core/indexes/range.py b/pandas/core/indexes/range.py
index f300cde3b..6ad70841a 100644
--- a/pandas/core/indexes/range.py
+++ b/pandas/core/indexes/range.py
@@ -121,8 +121,8 @@ class RangeIndex(Int64Index):
         """
         if not isinstance(data, range):
             raise TypeError(
-                "{0}(...) must be called with object coercible to a "
-                "range, {1} was passed".format(cls.__name__, repr(data))
+                f"{cls.__name__}(...) must be called with object coercible to a "
+                f"range, {repr(data)} was passed"
             )
 
         cls._validate_dtype(dtype)
@@ -695,8 +695,7 @@ class RangeIndex(Int64Index):
                 return self._range[new_key]
             except IndexError:
                 raise IndexError(
-                    "index {key} is out of bounds for axis 0 "
-                    "with size {size}".format(key=key, size=len(self))
+                    f"index {key} is out of bounds for axis 0 with size {len(self)}"
                 )
         elif is_scalar(key):
             raise IndexError(
@@ -796,7 +795,7 @@ class RangeIndex(Int64Index):
                     return op(self._int64index, other)
                     # TODO: Do attrs get handled reliably?
 
-            name = "__{name}__".format(name=op.__name__)
+            name = f"__{op.__name__}__"
             return compat.set_function_name(_evaluate_numeric_binop, name, cls)
 
         cls.__add__ = _make_evaluate_binop(operator.add)
diff --git a/pandas/core/indexes/timedeltas.py b/pandas/core/indexes/timedeltas.py
index 16db41065..889075ebe 100644
--- a/pandas/core/indexes/timedeltas.py
+++ b/pandas/core/indexes/timedeltas.py
@@ -166,10 +166,8 @@ class TimedeltaIndex(
 
         if is_scalar(data):
             raise TypeError(
-                "{cls}() must be called with a "
-                "collection of some kind, {data} was passed".format(
-                    cls=cls.__name__, data=repr(data)
-                )
+                f"{cls.__name__}() must be called with a "
+                f"collection of some kind, {repr(data)} was passed"
             )
 
         if unit in {"Y", "y", "M"}:

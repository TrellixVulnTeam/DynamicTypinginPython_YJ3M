commit 185e829e1998623b6fd7bedeeabdebd505dbdeed
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri May 6 16:06:00 2011 -0400

    unit tests

diff --git a/pandas/core/series.py b/pandas/core/series.py
index bdef633a8..e8ec8b1ab 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -302,10 +302,14 @@ class Series(np.ndarray, Picklable, Groupable):
         y : scalar
         """
         if key in self.index:
-            return ndarray.__getitem__(self, self.index.indexMap[key])
+            return self._get_val_at(self.index.indexMap[key])
         else:
             return default
 
+    # help out SparseSeries
+    def _get_val_at(self, i):
+        return _ndgi(self, i)
+
     def __getslice__(self, i, j):
         """
         Returns a slice of the Series.
@@ -319,9 +323,6 @@ class Series(np.ndarray, Picklable, Groupable):
         return Series(self.values[i:j].copy(), index=self.index[i:j])
 
     def __setitem__(self, key, value):
-        """
-        If this series is mutable, set specified indices equal to given values.
-        """
         try:
             loc = self.index.indexMap[key]
             ndarray.__setitem__(self, loc, value)
@@ -1287,6 +1288,8 @@ class TimeSeries(Series):
 #-------------------------------------------------------------------------------
 # Supplementary functions
 
+_ndgi = ndarray.__getitem__
+
 def remove_na(arr):
     """
     Return array containing only true/non-NaN values, possibly empty.
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index 150541b80..45c5e71eb 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -154,6 +154,12 @@ class SparseSeries(Series):
     kind : {'block', 'integer'}
     fill_value : float
         Defaults to NaN (code for missing)
+
+    Notes
+    -----
+    SparseSeries objects are immutable via the typical Python means. If you must
+    change values, convert to dense, make your changes, then convert back to
+    sparse
     """
     sp_index = None
     fill_value = None
@@ -281,6 +287,18 @@ class SparseSeries(Series):
     __idiv__ = __div__
     __ipow__ = __pow__
 
+    @property
+    def values(self):
+        output = np.empty(len(self), dtype=np.float64)
+        int_index = self.sp_index.to_int_index()
+        output.fill(self.fill_value)
+        output.put(int_index.indices, self)
+        return output
+
+    @property
+    def sp_values(self):
+        return np.asarray(self)
+
     def __getitem__(self, key):
         """
 
@@ -321,53 +339,11 @@ class SparseSeries(Series):
     def __getslice__(self, i, j):
         return self._constructor(self.values[i:j], index=self.index[i:j])
 
-    def get(self, key, default=None):
-        """
-        Returns value occupying requested index, default to specified
-        missing value if not present
-
-        Parameters
-        ----------
-        key : object
-            Index value looking for
-        default : object, optional
-            Value to return if key not in index
-
-        Returns
-        -------
-        y : scalar
-        """
-        if key in self.index:
-            return ndarray.__getitem__(self, self.index.indexMap[key])
-        else:
-            return default
-
     def __setitem__(self, key, value):
-        """
-        If this series is mutable, set specified indices equal to given values.
-        """
-        try:
-            loc = self.index.indexMap[key]
-            ndarray.__setitem__(self, loc, value)
-        except Exception:
-            values = self.values
-            values[key] = value
+        raise Exception('SparseSeries objects are immutable')
 
     def __setslice__(self, i, j, value):
-        """Set slice equal to given value(s)"""
-        ndarray.__setslice__(self, i, j, value)
-
-    @property
-    def values(self):
-        output = np.empty(len(self), dtype=np.float64)
-        int_index = self.sp_index.to_int_index()
-        output.fill(self.fill_value)
-        output.put(int_index.indices, self)
-        return output
-
-    @property
-    def sp_values(self):
-        return np.asarray(self)
+        raise Exception('SparseSeries objects are immutable')
 
     def to_dense(self, sparse_only=False):
         """
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
index 894c4c3d8..7e36ee978 100644
--- a/pandas/core/tests/test_series.py
+++ b/pandas/core/tests/test_series.py
@@ -885,5 +885,9 @@ class TestSeries(unittest.TestCase):
                 self.assertEqual(transformed[idx], mean)
 
 
+
 if __name__ == '__main__':
-    unittest.main()
+    import nose
+    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
+                   exit=False)
+
diff --git a/pandas/core/tests/test_sparse.py b/pandas/core/tests/test_sparse.py
index 8218e5454..9b63181b4 100644
--- a/pandas/core/tests/test_sparse.py
+++ b/pandas/core/tests/test_sparse.py
@@ -211,6 +211,7 @@ class TestSparseSeries(TestCase):
             pickled = pickle.dumps(series)
             unpickled = pickle.loads(pickled)
             assert_sp_series_equal(series, unpickled)
+            assert_series_equal(series.to_dense(), unpickled.to_dense())
 
         _test_roundtrip(self.bseries)
         _test_roundtrip(self.iseries)
@@ -218,19 +219,23 @@ class TestSparseSeries(TestCase):
         _test_roundtrip(self.ziseries)
 
     def test_getitem(self):
-        def _check_indexing(sp, dense):
+        def _check_getitem(sp, dense):
             for idx, val in dense.iteritems():
                 assert_almost_equal(val, sp[idx])
 
             for i in xrange(len(dense)):
                 assert_almost_equal(sp[i], dense[i])
 
-        _check_indexing(self.bseries, self.bseries.to_dense())
-        _check_indexing(self.btseries, self.btseries.to_dense())
+            # negative getitem works
+            for i in xrange(len(dense)):
+                assert_almost_equal(sp[-i], dense[-i])
+
+        _check_getitem(self.bseries, self.bseries.to_dense())
+        _check_getitem(self.btseries, self.btseries.to_dense())
 
-        _check_indexing(self.zbseries, self.zbseries.to_dense())
-        _check_indexing(self.iseries, self.iseries.to_dense())
-        _check_indexing(self.ziseries, self.ziseries.to_dense())
+        _check_getitem(self.zbseries, self.zbseries.to_dense())
+        _check_getitem(self.iseries, self.iseries.to_dense())
+        _check_getitem(self.ziseries, self.ziseries.to_dense())
 
         # exception handling
         self.assertRaises(Exception, self.bseries.__getitem__,
@@ -240,6 +245,10 @@ class TestSparseSeries(TestCase):
         self.assertRaises(Exception, self.btseries.__getitem__,
                           self.btseries.index[-1] + BDay())
 
+    def test_get(self):
+        assert_almost_equal(self.bseries.get(10), self.bseries[10])
+        self.assert_(self.bseries.get(len(self.bseries) + 1) is None)
+
     def test_getitem_fancy_index(self):
         idx = self.bseries.index
         res = self.bseries[::2]
@@ -253,17 +262,15 @@ class TestSparseSeries(TestCase):
         res = self.bseries[5:]
         assert_sp_series_equal(res, self.bseries.reindex(idx[5:]))
 
-    def test_setitem(self):
+    def test_getslice(self):
         pass
 
-    def test_slice(self):
-        pass
+    def test_setitem(self):
+        self.assertRaises(Exception, self.bseries.__setitem__, 5, 7.)
+        self.assertRaises(Exception, self.iseries.__setitem__, 5, 7.)
 
     def test_setslice(self):
-        pass
-
-    def test_serialize(self):
-        pass
+        self.assertRaises(Exception, lambda: eval('self.bseries[5:10] = 10'))
 
     def test_operators(self):
         def _check_op(a, b, op):

commit 4f4c3db67aa755ec7945ed4c247af1245a49c5c3
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Apr 4 20:14:30 2012 -0400

    ENH: preserve DatetimeIndex frequency in boolean arrays with single contigous chunk, close #791

diff --git a/pandas/core/index.py b/pandas/core/index.py
index 69997c05b..134aa3650 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1702,16 +1702,17 @@ class DatetimeIndex(Int64Index):
             val = arr_idx[key]
             return _dt_box(val, offset=self.offset, tz=self.tz)
         else:
+            if com._is_bool_indexer(key):
+                key = np.asarray(key)
+                key = lib.maybe_booleans_to_slice(key)
+
             new_offset = None
-            if (type(key) == slice):
+            if isinstance(key, slice):
                 if self.offset is not None and key.step is not None:
                     new_offset = key.step * self.offset
                 else:
                     new_offset = self.offset
 
-            if com._is_bool_indexer(key):
-                key = np.asarray(key)
-
             result = arr_idx[key]
             if result.ndim > 1:
                 return result
diff --git a/pandas/src/tseries.pyx b/pandas/src/tseries.pyx
index 2f71c103d..4aa1b9b25 100644
--- a/pandas/src/tseries.pyx
+++ b/pandas/src/tseries.pyx
@@ -427,6 +427,30 @@ def convert_timestamps(ndarray values):
 
     return out
 
+def maybe_booleans_to_slice(ndarray[uint8_t, cast=True] mask):
+    cdef:
+        Py_ssize_t i, n = len(mask)
+        Py_ssize_t start, end
+        bint started = 0, finished = 0
+
+    for i in range(n):
+        if mask[i]:
+            if finished:
+                return mask
+            if not started:
+                started = 1
+                start = i
+        else:
+            if finished:
+                continue
+
+            if started:
+                end = i
+                finished = 1
+
+    return slice(start, end)
+
+
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def scalar_compare(ndarray[object] values, object val, object op):
diff --git a/pandas/tests/test_datetime64.py b/pandas/tests/test_datetime64.py
index 742e97dbb..3c2b9c9fa 100644
--- a/pandas/tests/test_datetime64.py
+++ b/pandas/tests/test_datetime64.py
@@ -569,26 +569,6 @@ class TestDatetime64(unittest.TestCase):
         self.assertEquals(idx1.offset, idx2.offset)
 
 
-    def test_dti_slicing(self):
-        dti = DatetimeIndex(start='1/1/2005', end='12/1/2005', freq='M')
-        dti2 = dti[[1,3,5]]
-
-        v1 = dti2[0]
-        v2 = dti2[1]
-        v3 = dti2[2]
-
-        self.assertEquals(v1, Timestamp('2/28/2005'))
-        self.assertEquals(v2, Timestamp('4/30/2005'))
-        self.assertEquals(v3, Timestamp('6/30/2005'))
-
-        # don't carry freq through irregular slicing
-        self.assertEquals(dti2.freq, None)
-
-        # don't carry freq through boolean slicing
-        dti2 = dti[[True]*len(dti)]
-        self.assertEquals(len(dti2), len(dti))
-        self.assertEquals(dti2.freq, None)
-
     def test_dti_snap(self):
         dti = DatetimeIndex(['1/1/2002', '1/2/2002', '1/3/2002', '1/4/2002',
                              '1/5/2002', '1/6/2002', '1/7/2002'], freq='D')
diff --git a/pandas/tests/test_timeseries.py b/pandas/tests/test_timeseries.py
index 0a3c3cb9a..898a9d4d6 100644
--- a/pandas/tests/test_timeseries.py
+++ b/pandas/tests/test_timeseries.py
@@ -13,7 +13,7 @@ import numpy as np
 import numpy.ma as ma
 
 from pandas import (Index, Series, TimeSeries, DataFrame, isnull, notnull,
-                    date_range)
+                    date_range, Timestamp)
 from pandas.core.index import MultiIndex
 
 from pandas import DatetimeIndex
@@ -73,6 +73,45 @@ class TestTimeSeriesDuplicates(unittest.TestCase):
         self.assertRaises(KeyError, ts.__getitem__, datetime(2000, 1, 6))
         self.assertRaises(KeyError, ts.__setitem__, datetime(2000, 1, 6), 0)
 
+
+def assert_range_equal(left, right):
+    assert(left.equals(right))
+    assert(left.freq == right.freq)
+    assert(left.tz == right.tz)
+
+
+class TestTimeSeries(unittest.TestCase):
+
+    def test_dti_slicing(self):
+        dti = DatetimeIndex(start='1/1/2005', end='12/1/2005', freq='M')
+        dti2 = dti[[1,3,5]]
+
+        v1 = dti2[0]
+        v2 = dti2[1]
+        v3 = dti2[2]
+
+        self.assertEquals(v1, Timestamp('2/28/2005'))
+        self.assertEquals(v2, Timestamp('4/30/2005'))
+        self.assertEquals(v3, Timestamp('6/30/2005'))
+
+        # don't carry freq through irregular slicing
+        self.assert_(dti2.freq is None)
+
+    def test_contiguous_boolean_preserve_freq(self):
+        rng = date_range('1/1/2000', '3/1/2000', freq='B')
+
+        mask = np.zeros(len(rng), dtype=bool)
+        mask[10:20] = True
+
+        masked = rng[mask]
+        expected = rng[10:20]
+        self.assert_(expected.freq is not None)
+        assert_range_equal(masked, expected)
+
+        mask[22] = True
+        masked = rng[mask]
+        self.assert_(masked.freq is None)
+
     def test_getitem_median_slice_bug(self):
         index = date_range('20090415', '20090519', freq='2B')
         s = Series(np.random.randn(13), index=index)

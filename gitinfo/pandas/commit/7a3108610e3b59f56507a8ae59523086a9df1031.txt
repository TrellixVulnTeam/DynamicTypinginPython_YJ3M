commit 7a3108610e3b59f56507a8ae59523086a9df1031
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri May 20 16:39:49 2011 -0400

    unit test coverage right about 100% for sparse data structures, yes \!

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index dbdd808c6..0c4cc2942 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -965,7 +965,7 @@ class DataFrame(Picklable, Groupable):
 
     def copy(self):
         """
-        Make a deep copy of this frame
+        Make a shallow copy of this frame
         """
         return DataFrame(self._series, index=self.index,
                          columns=self.columns)
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index bd513c3c5..de10380e0 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -137,7 +137,7 @@ class Panel(Picklable):
         return iter(self.items)
 
     def iteritems(self):
-        for item in self:
+        for item in self.items:
             yield item, self[item]
 
     @property
@@ -960,7 +960,6 @@ class WidePanel(Panel, Groupable):
         return WidePanel(values=values, items=items, major_axis=major_axis,
                          minor_axis=minor_axis)
 
-
     def truncate(self, before=None, after=None, axis='major'):
         """Function truncates a sorted Panel before and/or after
         some particular dates
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index 1eb8162b0..cab09f03a 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -13,6 +13,7 @@ from pandas.core.index import Index, NULL_INDEX
 from pandas.core.series import Series, TimeSeries, _ensure_index
 from pandas.core.frame import DataFrame, extract_index, try_sort
 from pandas.core.matrix import DataMatrix
+from pandas.core.panel import Panel, WidePanel, LongPanelIndex, LongPanel
 import pandas.core.common as common
 
 from pandas.lib.sparse import BlockIndex, IntIndex
@@ -65,6 +66,34 @@ _MIRROR_OPS = {
     'mul' : '__rmul__',
 }
 
+def _sparse_series_op(left, right, op, name):
+    if np.isnan(left.fill_value):
+        sparse_op = lambda a, b: _sparse_nanop(a, b, name)
+    else:
+        sparse_op = lambda a, b: _sparse_fillop(a, b, name)
+
+    new_index = left.index + right.index
+    if not left.index.equals(new_index):
+        left = left.reindex(new_index)
+
+    if not right.index.equals(new_index):
+        right = right.reindex(new_index)
+
+    if left.sp_index.equals(right.sp_index):
+        result = op(left.sp_values, right.sp_values)
+        result_index = left.sp_index
+    else:
+        result, result_index = sparse_op(left, right)
+
+    try:
+        fill_value = op(left.fill_value, right.fill_value)
+    except ZeroDivisionError:
+        fill_value = nan
+
+    return SparseSeries(result, index=new_index,
+                        sparse_index=result_index,
+                        fill_value=fill_value)
+
 def _sparse_op_wrap(op, name):
     """
     Wrapper function for Series arithmetic operations, to avoid
@@ -72,35 +101,7 @@ def _sparse_op_wrap(op, name):
     """
     def wrapper(self, other):
         if isinstance(other, SparseSeries):
-            if np.isnan(self.fill_value):
-                sparse_op = lambda a, b: _sparse_nanop(a, b, name)
-            else:
-                sparse_op = lambda a, b: _sparse_fillop(a, b, name)
-
-            new_index = self.index + other.index
-            if self.index.equals(new_index):
-                this = self
-            else:
-                this = self.reindex(new_index)
-
-            if not other.index.equals(new_index):
-                other = other.reindex(new_index)
-
-            if self.sp_index.equals(other.sp_index):
-                result = op(this.sp_values, other.sp_values)
-                result_index = self.sp_index
-            else:
-                result, result_index = sparse_op(this, other)
-
-            try:
-                fill_value = op(this.fill_value, other.fill_value)
-            except ZeroDivisionError:
-                fill_value = nan
-
-            return SparseSeries(result, index=new_index,
-                                sparse_index=result_index,
-                                fill_value=fill_value)
-
+            return _sparse_series_op(self, other, op, name)
         elif isinstance(other, SparseDataFrame):
             reverse_op = _MIRROR_OPS.get(name)
             if reverse_op is None: # pragma: no cover
@@ -150,6 +151,9 @@ Notes.
 - Will need to "disable" a number of methods?
 """
 
+# from line_profiler import LineProfiler
+# prof = LineProfiler()
+
 class SparseSeries(Series):
     """
     Data structure for labeled, sparse floating point data
@@ -232,11 +236,12 @@ class SparseSeries(Series):
             cls = SparseTimeSeries
 
         # Change the class of the array to be the subclass type.
-        subarr = subarr.view(cls)
-        subarr.sp_index = sparse_index
-        subarr.fill_value = fill_value
-        subarr.index = index
-        return subarr
+        output = subarr.view(cls)
+        output._sp_values = subarr
+        output.sp_index = sparse_index
+        output.fill_value = fill_value
+        output.index = index
+        return output
 
     @property
     def _constructor(self):
@@ -323,7 +328,11 @@ class SparseSeries(Series):
 
     @property
     def sp_values(self):
-        return np.asarray(self)
+        try:
+            return self._sp_values
+        except AttributeError:
+            self._sp_values = ret = np.asarray(self)
+            return ret
 
     def __getitem__(self, key):
         """
@@ -576,8 +585,9 @@ class SparseDataFrame(DataFrame):
         sdict = {}
         for k, v in data.iteritems():
             if isinstance(v, Series):
-                # Forces alignment and copies data
-                v = v.reindex(index)
+                # Force alignment, no copy necessary
+                if not v.index.equals(index):
+                    v = v.reindex(index)
 
                 if not isinstance(v, SparseSeries):
                     v = sp_maker(v)
@@ -739,17 +749,10 @@ class SparseDataFrame(DataFrame):
         return SparseDataFrame(sdict, index=self.index, columns=columns,
                                default_fill_value=self.default_fill_value)
 
-from pandas.core.panel import WidePanel
-
-# from line_profiler import LineProfiler
-# prof = LineProfiler()
-
 def stack_sparse_frame(frame):
     """
     Only makes sense when fill_value is NaN
     """
-    from pandas.core.panel import LongPanelIndex, LongPanel
-
     lengths = [s.sp_index.npoints for _, s in frame.iteritems()]
     nobs = sum(lengths)
 
@@ -973,7 +976,9 @@ class SparseWidePanel(WidePanel):
         -------
         lp : LongPanel
         """
-        from pandas.core.panel import LongPanelIndex, LongPanel
+        if not filter_observations:
+            raise Exception('filter_observations=False not supported for '
+                            'SparseWidePanel.to_long')
 
         I, N, K = self.shape
         counts = np.zeros(N * K, dtype=int)
@@ -993,7 +998,11 @@ class SparseWidePanel(WidePanel):
             d_values[item] = values
             d_indexer[item] = indexer
 
+        # have full set of observations for each item
         mask = counts == I
+
+        # for each item, take mask values at index locations for those sparse
+        # values, and use that to select values
         values = np.column_stack([d_values[item][mask.take(d_indexer[item])]
                                   for item in self.items])
 
@@ -1042,16 +1051,38 @@ class SparseWidePanel(WidePanel):
                                default_fill_value=self.default_fill_value,
                                default_kind=self.default_kind)
 
+    def truncate(self, before=None, after=None, axis='major'):
+        """Function truncates a sorted Panel before and/or after
+        some particular dates
+
+        Parameters
+        ----------
+        before : date
+            Left boundary
+        after : date
+            Right boundary
+
+        Returns
+        -------
+        WidePanel
+        """
+        axis = self._get_axis_name(axis)
+        index = self._get_axis(axis)
+
+        beg_slice, end_slice = self._getIndices(before, after, axis=axis)
+        new_index = index[beg_slice:end_slice]
+
+        return self.reindex(**{axis : new_index})
+
     def _combine(self, other, func, axis=0):
         if isinstance(other, DataFrame):
             return self._combineFrame(other, func, axis=axis)
         elif isinstance(other, Panel):
             return self._combinePanel(other, func)
         elif np.isscalar(other):
-            newValues = func(self.values, other)
-
-            return WidePanel(newValues, self.items, self.major_axis,
-                             self.minor_axis)
+            new_frames = dict((k, func(v, other))
+                              for k, v in self.iteritems())
+            return self._new_like(new_frames)
 
     def _combineFrame(self, other, func, axis=0):
         index, columns = self._get_plane_axes(axis)
@@ -1060,21 +1091,37 @@ class SparseWidePanel(WidePanel):
         other = other.reindex(index=index, columns=columns)
 
         if axis == 0:
-            newValues = func(self.values, other.values)
+            new_values = func(self.values, other.values)
         elif axis == 1:
-            newValues = func(self.values.swapaxes(0, 1), other.values.T)
-            newValues = newValues.swapaxes(0, 1)
+            new_values = func(self.values.swapaxes(0, 1), other.values.T)
+            new_values = new_values.swapaxes(0, 1)
         elif axis == 2:
-            newValues = func(self.values.swapaxes(0, 2), other.values)
-            newValues = newValues.swapaxes(0, 2)
-
-        return WidePanel(newValues, self.items, self.major_axis,
-                         self.minor_axis)
+            new_values = func(self.values.swapaxes(0, 2), other.values)
+            new_values = new_values.swapaxes(0, 2)
+
+        # TODO: make faster!
+        new_frames = {}
+        for item, item_slice in zip(self.items, new_values):
+            old_frame = self[item]
+            ofv = old_frame.default_fill_value
+            ok = old_frame.default_kind
+            new_frames[item] = SparseDataFrame(item_slice,
+                                               index=self.major_axis,
+                                               columns=self.minor_axis,
+                                               default_fill_value=ofv,
+                                               default_kind=ok)
+
+        return self._new_like(new_frames)
+
+    def _new_like(self, new_frames):
+        return SparseWidePanel(new_frames, self.items, self.major_axis,
+                               self.minor_axis,
+                               default_fill_value=self.default_fill_value,
+                               default_kind=self.default_kind)
 
     def _combinePanel(self, other, func):
-        if isinstance(other, LongPanel):
-            other = other.to_wide()
-
+        # if isinstance(other, LongPanel):
+        #     other = other.to_wide()
         items = self.items + other.items
         major = self.major_axis + other.major_axis
         minor = self.minor_axis + other.minor_axis
@@ -1084,9 +1131,17 @@ class SparseWidePanel(WidePanel):
         this = self.reindex(items=items, major=major, minor=minor)
         other = other.reindex(items=items, major=major, minor=minor)
 
-        result_values = func(this.values, other.values)
+        new_frames = {}
+        for item in items:
+            new_frames[item] = func(this[item], other[item])
+
+        # maybe unnecessary
+        new_default_fill = func(self.default_fill_value,
+                                other.default_fill_value)
 
-        return WidePanel(result_values, items, major, minor)
+        return SparseWidePanel(new_frames, items, major, minor,
+                               default_fill_value=new_default_fill,
+                               default_kind=self.default_kind)
 
     def major_xs(self, key):
         """
@@ -1127,7 +1182,6 @@ class SparseWidePanel(WidePanel):
 
 def _convert_frames(frames, index, columns, fill_value=nan, kind='block'):
     from pandas.core.panel import _get_combined_index, _get_combined_columns
-
     output = {}
     for item, df in frames.iteritems():
         if not isinstance(df, SparseDataFrame):
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index 94beff3fc..c4334725e 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -826,7 +826,9 @@ class TestDataFrame(unittest.TestCase):
             self.assertNotEqual(self.frame['A'][idx], value)
 
     def test_copy(self):
-        pass
+        cop = self.frame.copy()
+        cop['E'] = cop['A']
+        self.assert_('E' not in self.frame)
 
     def test_corr(self):
         self.frame['A'][:5] = np.NaN
diff --git a/pandas/core/tests/test_panel.py b/pandas/core/tests/test_panel.py
index 6b0fd854c..c7cc21afc 100644
--- a/pandas/core/tests/test_panel.py
+++ b/pandas/core/tests/test_panel.py
@@ -158,7 +158,30 @@ class PanelTests(object):
 
         assert_frame_equal(cumsum['ItemA'], self.panel['ItemA'].cumsum())
 
-class TestWidePanel(unittest.TestCase, PanelTests):
+class SafeForSparseTests(object):
+
+    def test_truncate(self):
+        dates = self.panel.major_axis
+        start, end = dates[1], dates[5]
+
+        trunced = self.panel.truncate(start, end, axis='major')
+        expected = self.panel['ItemA'].truncate(start, end)
+
+        assert_frame_equal(trunced['ItemA'], expected)
+
+        trunced = self.panel.truncate(before=start, axis='major')
+        expected = self.panel['ItemA'].truncate(before=start)
+
+        assert_frame_equal(trunced['ItemA'], expected)
+
+        trunced = self.panel.truncate(after=end, axis='major')
+        expected = self.panel['ItemA'].truncate(after=end)
+
+        assert_frame_equal(trunced['ItemA'], expected)
+
+        # XXX test other axes
+
+class TestWidePanel(unittest.TestCase, PanelTests, SafeForSparseTests):
 
     def setUp(self):
         self.panel = common.makeWidePanel()
@@ -513,27 +536,6 @@ class TestWidePanel(unittest.TestCase, PanelTests):
 
         self.assertRaises(Exception, self.panel.shift, 1, axis='items')
 
-    def test_truncate(self):
-        dates = self.panel.major_axis
-        start, end = dates[1], dates[5]
-
-        trunced = self.panel.truncate(start, end, axis='major')
-        expected = self.panel['ItemA'].truncate(start, end)
-
-        assert_frame_equal(trunced['ItemA'], expected)
-
-        trunced = self.panel.truncate(before=start, axis='major')
-        expected = self.panel['ItemA'].truncate(before=start)
-
-        assert_frame_equal(trunced['ItemA'], expected)
-
-        trunced = self.panel.truncate(after=end, axis='major')
-        expected = self.panel['ItemA'].truncate(after=end)
-
-        assert_frame_equal(trunced['ItemA'], expected)
-
-        # XXX test other axes
-
 class TestLongPanelIndex(unittest.TestCase):
 
     def setUp(self):
diff --git a/pandas/core/tests/test_sparse.py b/pandas/core/tests/test_sparse.py
index 2adb51f11..ba79abfe9 100644
--- a/pandas/core/tests/test_sparse.py
+++ b/pandas/core/tests/test_sparse.py
@@ -595,6 +595,15 @@ class TestSparseDataFrame(TestCase):
 
         # TODO: test data is copied from inputs
 
+        # init dict with different index
+        idx = self.frame.index[:5]
+        cons = SparseDataFrame(self.frame._series, index=idx,
+                               columns=self.frame.columns,
+                               default_fill_value=self.frame.default_fill_value,
+                               default_kind=self.frame.default_kind)
+        reindexed = self.frame.reindex(idx)
+        assert_sp_frame_equal(cons, reindexed)
+
     def test_array_interface(self):
         res = np.sqrt(self.frame)
         dres = np.sqrt(self.frame.to_dense())
@@ -857,19 +866,22 @@ def panel_data3():
         'd' : [nan, 0, 1, nan, 2, 3, 4, 5, 6, nan]
         }, index=index)
 
-class TestSparseWidePanel(TestCase):
+import test_panel
+
+class TestSparseWidePanel(TestCase, test_panel.SafeForSparseTests):
 
     def setUp(self):
         self.data_dict = {
-            'item1' : panel_data1(),
-            'item2' : panel_data2(),
-            'item3' : panel_data3()
+            'ItemA' : panel_data1(),
+            'ItemB' : panel_data2(),
+            'ItemC' : panel_data3(),
+            'ItemD' : panel_data1(),
         }
         self.panel = SparseWidePanel(self.data_dict)
 
     def test_constructor(self):
         self.assertRaises(Exception, SparseWidePanel, self.data_dict,
-                          items=['item0', 'item1', 'item2'])
+                          items=['Item0', 'ItemA', 'ItemB'])
 
     def test_from_dict(self):
         fd = SparseWidePanel.from_dict(self.data_dict)
@@ -900,11 +912,14 @@ class TestSparseWidePanel(TestCase):
                                         dlp.index.minor_labels))
 
         _compare_with_dense(self.panel)
-        _compare_with_dense(self.panel.reindex(items=['item1']))
+        _compare_with_dense(self.panel.reindex(items=['ItemA']))
 
         zero_panel = SparseWidePanel(self.data_dict, default_fill_value=0)
         self.assertRaises(Exception, zero_panel.to_long)
 
+        self.assertRaises(Exception, self.panel.to_long,
+                          filter_observations=False)
+
     def test_long_to_wide_sparse(self):
         pass
 
@@ -915,25 +930,25 @@ class TestSparseWidePanel(TestCase):
         pass
 
     def test_setitem(self):
-        self.panel['item4'] = self.panel['item3']
-        self.panel['item5'] = self.panel['item3'].to_dense()
+        self.panel['ItemE'] = self.panel['ItemC']
+        self.panel['ItemF'] = self.panel['ItemC'].to_dense()
 
-        assert_sp_frame_equal(self.panel['item4'], self.panel['item3'])
-        assert_sp_frame_equal(self.panel['item5'], self.panel['item3'])
-        assert_almost_equal(self.panel.items, ['item1', 'item2', 'item3',
-                                               'item4', 'item5'])
+        assert_sp_frame_equal(self.panel['ItemE'], self.panel['ItemC'])
+        assert_sp_frame_equal(self.panel['ItemF'], self.panel['ItemC'])
+        assert_almost_equal(self.panel.items, ['ItemA', 'ItemB', 'ItemC',
+                                               'ItemD', 'ItemE', 'ItemF'])
 
         self.assertRaises(Exception, self.panel.__setitem__, 'item6', 1)
 
     def test_delitem_pop(self):
-        del self.panel['item2']
-        assert_almost_equal(self.panel.items, ['item1', 'item3'])
-        crackle = self.panel['item3']
-        pop = self.panel.pop('item3')
+        del self.panel['ItemB']
+        assert_almost_equal(self.panel.items, ['ItemA', 'ItemC', 'ItemD'])
+        crackle = self.panel['ItemC']
+        pop = self.panel.pop('ItemC')
         self.assert_(pop is crackle)
-        assert_almost_equal(self.panel.items, ['item1'])
+        assert_almost_equal(self.panel.items, ['ItemA', 'ItemD'])
 
-        self.assertRaises(KeyError, self.panel.__delitem__, 'item3')
+        self.assertRaises(KeyError, self.panel.__delitem__, 'ItemC')
 
     def test_pickle(self):
         pickled = pickle.dumps(self.panel)
@@ -963,13 +978,33 @@ class TestSparseWidePanel(TestCase):
 
         # TODO: do something about this later...
         self.assertRaises(Exception, self.panel.reindex,
-                          items=['item0', 'item1', 'item2'])
+                          items=['item0', 'ItemA', 'ItemB'])
 
     def test_operators(self):
-        pass
-
-    def test_truncate(self):
-        pass
+        def _check_ops(panel):
+            def _dense_comp(op):
+                dense = panel.to_dense()
+                sparse_result = op(panel)
+                dense_result = op(dense)
+                assert_panel_equal(sparse_result.to_dense(), dense_result)
+
+            op1 = lambda x: x + 2
+
+            _dense_comp(op1)
+            op2 = lambda x: x.add(x.reindex(major=x.major_axis[::2]))
+            _dense_comp(op2)
+            op3 = lambda x: x.subtract(x.mean(0), axis=0)
+            _dense_comp(op3)
+            op4 = lambda x: x.subtract(x.mean(1), axis=1)
+            _dense_comp(op4)
+            op5 = lambda x: x.subtract(x.mean(2), axis=2)
+            _dense_comp(op5)
+
+            # TODO: this case not yet supported!
+            # op6 = lambda x: x.add(x.to_long())
+            # _dense_comp(op6)
+
+        _check_ops(self.panel)
 
     def test_major_xs(self):
         def _dense_comp(sparse):

commit 2612e80569fb16ae3e4c7704830eecbcd363c26d
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jan 9 18:21:23 2012 -0500

    ENH: can pass a dict of objects, #600

diff --git a/pandas/tools/merge.py b/pandas/tools/merge.py
index a77f17ca7..5b0916905 100644
--- a/pandas/tools/merge.py
+++ b/pandas/tools/merge.py
@@ -598,7 +598,10 @@ def concat(objs, axis=0, join='outer', join_axes=None, ignore_index=False,
 
     Parameters
     ----------
-    objs : list of DataFrame (or other pandas) objects
+    objs : list or dict of Series, DataFrame, or Panel objects
+        If a dict is passed, the sorted keys will be used as the `keys`
+        argument, unless it is passed, in which case the values will be
+        selected (see below)
     axis : {0, 1, ...}, default 0
         The axis to concatenate along
     join : {'inner', 'outer'}, default 'outer'
@@ -608,7 +611,8 @@ def concat(objs, axis=0, join='outer', join_axes=None, ignore_index=False,
         Check whether the new concatenated axis contains duplicates. This can
         be very expensive relative to the actual data concatenation
     keys : sequence, default None
-        If multiple levels passed, should contain tuples
+        If multiple levels passed, should contain tuples. Construct
+        hierarchical index using the passed keys as the outermost level
     levels : list of sequences, default None
         Specific levels (unique values) to use for constructing a
         MultiIndex. Otherwise they will be inferred from the keys
@@ -647,6 +651,11 @@ class _Concatenator(object):
             raise ValueError('Only can inner (intersect) or outer (union) join '
                              'the other axis')
 
+        if isinstance(objs, dict):
+            if keys is None:
+                keys = sorted(objs)
+            objs = [objs[k] for k in keys]
+
         # consolidate data
         for obj in objs:
             obj.consolidate(inplace=True)
@@ -739,8 +748,8 @@ class _Concatenator(object):
         else:
             all_items = [b.items for b in blocks]
             if self.axis == 0 and self.keys is not None:
-                offsets = np.r_[0, [len(x._data.axes[self.axis]) for
-                                    x in self.objs]]
+                offsets = np.r_[0, np.cumsum([len(x._data.axes[self.axis]) for
+                                              x in self.objs])]
                 indexer = np.concatenate([offsets[i] + b.ref_locs
                                           for i, b in enumerate(blocks)])
                 concat_items = self.new_axes[0].take(indexer)
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index e9daab035..1642cdef7 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -777,6 +777,28 @@ class TestConcatenate(unittest.TestCase):
                              columns=exp_index2)
         tm.assert_frame_equal(result, expected)
 
+    def test_concat_dict(self):
+        frames = {'foo' : DataFrame(np.random.randn(4, 3)),
+                  'bar' : DataFrame(np.random.randn(4, 3)),
+                  'baz' : DataFrame(np.random.randn(4, 3)),
+                  'qux' : DataFrame(np.random.randn(4, 3))}
+
+        sorted_keys = sorted(frames)
+
+        result = concat(frames)
+        expected = concat([frames[k] for k in sorted_keys], keys=sorted_keys)
+        tm.assert_frame_equal(result, expected)
+
+        result = concat(frames, axis=1)
+        expected = concat([frames[k] for k in sorted_keys], keys=sorted_keys,
+                          axis=1)
+        tm.assert_frame_equal(result, expected)
+
+        keys = ['baz', 'foo', 'bar']
+        result = concat(frames, keys=keys)
+        expected = concat([frames[k] for k in keys], keys=keys)
+        tm.assert_frame_equal(result, expected)
+
     def test_concat_keys_and_levels(self):
         df = DataFrame(np.random.randn(1, 3))
         df2 = DataFrame(np.random.randn(1, 4))

commit 08a98fd5aae48d404496b571e0ffe55228f7d11c
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Oct 11 22:55:24 2011 -0400

    ENH: working on possibly faster xs function. new Cython put functions

diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index a420cc1e6..6d29ae56d 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -485,8 +485,9 @@ class BlockManager(object):
             raise Exception('cannot get view of mixed-type or '
                             'non-consolidated DataFrame')
 
-        items = self.items
         dtype = _interleaved_dtype(self.blocks)
+
+        items = self.items
         n = len(items)
         result = np.empty(n, dtype=dtype)
         for blk in self.blocks:
@@ -497,6 +498,37 @@ class BlockManager(object):
 
         return result
 
+    # def fast_2d_xs2(self, loc, copy=False):
+    #     """
+
+    #     """
+    #     if len(self.blocks) == 1:
+    #         result = self.blocks[0].values[:, loc]
+    #         if copy:
+    #             result = result.copy()
+    #         return result
+
+    #     if not copy:
+    #         raise Exception('cannot get view of mixed-type or '
+    #                         'non-consolidated DataFrame')
+
+    #     def _get_put_function(source_dtype, out_dtype):
+    #         src = source_dtype.name
+    #         dst = out_dtype.name
+    #         return getattr(lib, 'put2d_%s_%s' % (src, dst))
+
+    #     out_dtype = np.dtype(_interleaved_dtype(self.blocks))
+
+    #     items = self.items
+    #     n = len(items)
+    #     out = np.empty(n, dtype=out_dtype)
+    #     for blk in self.blocks:
+    #         values = blk.values
+    #         indexer = lib.merge_indexer_object(blk.items, items.indexMap)
+    #         putf = _get_put_function(values.dtype, out_dtype)
+    #         putf(values, indexer, loc, out)
+    #     return out
+
     def consolidate(self):
         """
         Join together blocks having same dtype
@@ -904,7 +936,7 @@ def _interleaved_dtype(blocks):
     elif have_bool:
         return np.bool_
     elif have_int and not have_float:
-        return np.int_
+        return np.int64
     else:
         return np.float64
 
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index 381a040e1..48d17b75b 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -558,6 +558,45 @@ def outer_join_indexer_%(name)s(ndarray[%(c_type)s] left,
 
 """
 
+#----------------------------------------------------------------------
+# Fast "put" logic for speeding up interleaving logic
+
+put2d_template = """
+def put2d_%(name)s_%(dest_type)s(ndarray[%(c_type)s, ndim=2, cast=True] values,
+                              ndarray[int32_t] indexer, Py_ssize_t loc,
+                              ndarray[%(dest_type2)s] out):
+    cdef:
+        Py_ssize_t i, j, k
+
+    k = len(values)
+    for j from 0 <= j < k:
+        i = indexer[j]
+        out[i] = values[j, loc]
+"""
+
+def generate_put_functions():
+    function_list = [
+        ('float64', 'float64_t', 'object'),
+        ('float64', 'float64_t', 'float64_t'),
+        ('object', 'object', 'object'),
+        ('int32', 'int32_t', 'int64_t'),
+        ('int32', 'int32_t', 'float64_t'),
+        ('int32', 'int32_t', 'object'),
+        ('int64', 'int64_t', 'int64_t'),
+        ('int64', 'int64_t', 'float64_t'),
+        ('int64', 'int64_t', 'object'),
+        ('bool', 'uint8_t', 'uint8_t'),
+        ('bool', 'uint8_t', 'object')
+    ]
+
+    output = StringIO()
+    for name, c_type, dest_type in function_list:
+        func = put2d_template % {'name' : name, 'c_type' : c_type,
+                                 'dest_type' : dest_type.replace('_t', ''),
+                                 'dest_type2' : dest_type}
+        output.write(func)
+    return output.getvalue()
+
 # name, ctype, capable of holding NA
 function_list = [
     ('float64', 'float64_t', 'np.float64', True),
@@ -567,10 +606,10 @@ function_list = [
     ('bool', 'uint8_t', 'np.bool', False)
 ]
 
-def generate_from_template(template, ndim=1, subset=None):
+def generate_from_template(template, ndim=1, exclude=None):
     output = StringIO()
     for name, c_type, dtype, can_hold_na in function_list:
-        if subset is not None and name not in subset:
+        if exclude is not None and name in exclude:
             continue
 
         if ndim == 1:
@@ -582,25 +621,34 @@ def generate_from_template(template, ndim=1, subset=None):
         output.write(func)
     return output.getvalue()
 
+templates_1d = [map_indices_template,
+                merge_indexer_template,
+                pad_template,
+                backfill_template,
+                take_1d_template,
+                is_monotonic_template,
+                groupby_template,
+                arrmap_template]
+
+nobool_1d_templates = [left_join_template,
+                       outer_join_template,
+                       inner_join_template]
+
+templates_2d = [take_2d_axis0_template,
+                take_2d_axis1_template]
+
 def generate_take_cython_file(path='generated.pyx'):
     with open(path, 'w') as f:
-        print >> f, generate_from_template(map_indices_template)
-        print >> f, generate_from_template(merge_indexer_template)
-        print >> f, generate_from_template(pad_template)
-        print >> f, generate_from_template(backfill_template)
-        print >> f, generate_from_template(take_1d_template)
-        print >> f, generate_from_template(take_2d_axis0_template, ndim=2)
-        print >> f, generate_from_template(take_2d_axis1_template, ndim=2)
-        print >> f, generate_from_template(is_monotonic_template)
-        print >> f, generate_from_template(groupby_template)
-        print >> f, generate_from_template(arrmap_template)
-
-        print >> f, generate_from_template(left_join_template,
-                                           subset=['object', 'int64'])
-        print >> f, generate_from_template(outer_join_template,
-                                           subset=['object', 'int64'])
-        print >> f, generate_from_template(inner_join_template,
-                                           subset=['object', 'int64'])
+        for template in templates_1d:
+            print >> f, generate_from_template(template)
+
+        for template in templates_2d:
+            print >> f, generate_from_template(template, ndim=2)
+
+        for template in nobool_1d_templates:
+            print >> f, generate_from_template(template, exclude=['bool'])
+
+        # print >> f, generate_put_functions()
 
 if __name__ == '__main__':
     generate_take_cython_file()
diff --git a/pandas/src/generated.pyx b/pandas/src/generated.pyx
index 860806410..2bdf65f09 100644
--- a/pandas/src/generated.pyx
+++ b/pandas/src/generated.pyx
@@ -833,430 +833,158 @@ def take_1d_bool(ndarray[uint8_t] values, ndarray[int32_t] indexer,
             outbuf[i] = values[idx]
 
 
-@cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_float64(ndarray[float64_t, ndim=2] values,
-                           ndarray[int32_t] indexer,
-                           out=None):
+@cython.wraparound(False)
+def is_monotonic_float64(ndarray[float64_t] arr):
     cdef:
-        Py_ssize_t i, j, k, n, idx
-        ndarray[float64_t, ndim=2] outbuf
-
-    n = len(indexer)
-    k = values.shape[1]
+        Py_ssize_t i, n
+        float64_t prev, cur
 
-    if out is None:
-        outbuf = np.empty((n, k), dtype=values.dtype)
-    else:
-        outbuf = out
+    n = len(arr)
 
-    for i from 0 <= i < n:
-        idx = indexer[i]
+    if n < 2:
+        return True
 
-        if idx == -1:
-            for j from 0 <= j < k:
-                outbuf[i, j] = NaN
-        else:
-            for j from 0 <= j < k:
-                outbuf[i, j] = values[idx, j]
+    prev = arr[0]
+    for i from 1 <= i < n:
+        cur = arr[i]
+        if cur < prev:
+            return False
+        prev = cur
+    return True
 
-@cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_object(ndarray[object, ndim=2] values,
-                           ndarray[int32_t] indexer,
-                           out=None):
+@cython.wraparound(False)
+def is_monotonic_object(ndarray[object] arr):
     cdef:
-        Py_ssize_t i, j, k, n, idx
-        ndarray[object, ndim=2] outbuf
-
-    n = len(indexer)
-    k = values.shape[1]
+        Py_ssize_t i, n
+        object prev, cur
 
-    if out is None:
-        outbuf = np.empty((n, k), dtype=values.dtype)
-    else:
-        outbuf = out
+    n = len(arr)
 
-    for i from 0 <= i < n:
-        idx = indexer[i]
+    if n < 2:
+        return True
 
-        if idx == -1:
-            for j from 0 <= j < k:
-                outbuf[i, j] = NaN
-        else:
-            for j from 0 <= j < k:
-                outbuf[i, j] = values[idx, j]
+    prev = arr[0]
+    for i from 1 <= i < n:
+        cur = arr[i]
+        if cur < prev:
+            return False
+        prev = cur
+    return True
 
-@cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int32(ndarray[int32_t, ndim=2] values,
-                           ndarray[int32_t] indexer,
-                           out=None):
+@cython.wraparound(False)
+def is_monotonic_int32(ndarray[int32_t] arr):
     cdef:
-        Py_ssize_t i, j, k, n, idx
-        ndarray[int32_t, ndim=2] outbuf
-
-    n = len(indexer)
-    k = values.shape[1]
+        Py_ssize_t i, n
+        int32_t prev, cur
 
-    if out is None:
-        outbuf = np.empty((n, k), dtype=values.dtype)
-    else:
-        outbuf = out
+    n = len(arr)
 
-    for i from 0 <= i < n:
-        idx = indexer[i]
+    if n < 2:
+        return True
 
-        if idx == -1:
-            for j from 0 <= j < k:
-                raise ValueError('No NA values allowed')
-        else:
-            for j from 0 <= j < k:
-                outbuf[i, j] = values[idx, j]
+    prev = arr[0]
+    for i from 1 <= i < n:
+        cur = arr[i]
+        if cur < prev:
+            return False
+        prev = cur
+    return True
 
-@cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_int64(ndarray[int64_t, ndim=2] values,
-                           ndarray[int32_t] indexer,
-                           out=None):
+@cython.wraparound(False)
+def is_monotonic_int64(ndarray[int64_t] arr):
     cdef:
-        Py_ssize_t i, j, k, n, idx
-        ndarray[int64_t, ndim=2] outbuf
-
-    n = len(indexer)
-    k = values.shape[1]
+        Py_ssize_t i, n
+        int64_t prev, cur
 
-    if out is None:
-        outbuf = np.empty((n, k), dtype=values.dtype)
-    else:
-        outbuf = out
+    n = len(arr)
 
-    for i from 0 <= i < n:
-        idx = indexer[i]
+    if n < 2:
+        return True
 
-        if idx == -1:
-            for j from 0 <= j < k:
-                raise ValueError('No NA values allowed')
-        else:
-            for j from 0 <= j < k:
-                outbuf[i, j] = values[idx, j]
+    prev = arr[0]
+    for i from 1 <= i < n:
+        cur = arr[i]
+        if cur < prev:
+            return False
+        prev = cur
+    return True
 
-@cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis0_bool(ndarray[uint8_t, ndim=2] values,
-                           ndarray[int32_t] indexer,
-                           out=None):
+@cython.wraparound(False)
+def is_monotonic_bool(ndarray[uint8_t] arr):
     cdef:
-        Py_ssize_t i, j, k, n, idx
-        ndarray[uint8_t, ndim=2] outbuf
-
-    n = len(indexer)
-    k = values.shape[1]
+        Py_ssize_t i, n
+        uint8_t prev, cur
 
-    if out is None:
-        outbuf = np.empty((n, k), dtype=values.dtype)
-    else:
-        outbuf = out
+    n = len(arr)
 
-    for i from 0 <= i < n:
-        idx = indexer[i]
+    if n < 2:
+        return True
 
-        if idx == -1:
-            for j from 0 <= j < k:
-                raise ValueError('No NA values allowed')
-        else:
-            for j from 0 <= j < k:
-                outbuf[i, j] = values[idx, j]
+    prev = arr[0]
+    for i from 1 <= i < n:
+        cur = arr[i]
+        if cur < prev:
+            return False
+        prev = cur
+    return True
 
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_float64(ndarray[float64_t, ndim=2] values,
-                           ndarray[int32_t] indexer,
-                           out=None):
-    cdef:
-        Py_ssize_t i, j, k, n, idx
-        ndarray[float64_t, ndim=2] outbuf
-
-    n = len(values)
-    k = len(indexer)
+def groupby_float64(ndarray[float64_t] index, ndarray[object] labels):
+    cdef dict result = {}
+    cdef ndarray[int8_t] mask
+    cdef int i, length
+    cdef list members
+    cdef object idx, key
 
-    if out is None:
-        outbuf = np.empty((n, k), dtype=values.dtype)
-    else:
-        outbuf = out
+    length = len(index)
+    mask = isnullobj(labels)
 
-    for j from 0 <= j < k:
-        idx = indexer[j]
+    for i from 0 <= i < length:
+        if mask[i]:
+            continue
 
-        if idx == -1:
-            for i from 0 <= i < n:
-                outbuf[i, j] = NaN
+        key = labels[i]
+        idx = index[i]
+        if key in result:
+            members = result[key]
+            members.append(idx)
         else:
-            for i from 0 <= i < n:
-                outbuf[i, j] = values[i, idx]
+            result[key] = [idx]
+
+    return result
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_2d_axis1_object(ndarray[object, ndim=2] values,
-                           ndarray[int32_t] indexer,
-                           out=None):
-    cdef:
-        Py_ssize_t i, j, k, n, idx
-        ndarray[object, ndim=2] outbuf
-
-    n = len(values)
-    k = len(indexer)
+def groupby_object(ndarray[object] index, ndarray[object] labels):
+    cdef dict result = {}
+    cdef ndarray[int8_t] mask
+    cdef int i, length
+    cdef list members
+    cdef object idx, key
 
-    if out is None:
-        outbuf = np.empty((n, k), dtype=values.dtype)
-    else:
-        outbuf = out
+    length = len(index)
+    mask = isnullobj(labels)
 
-    for j from 0 <= j < k:
-        idx = indexer[j]
+    for i from 0 <= i < length:
+        if mask[i]:
+            continue
 
-        if idx == -1:
-            for i from 0 <= i < n:
-                outbuf[i, j] = NaN
+        key = labels[i]
+        idx = index[i]
+        if key in result:
+            members = result[key]
+            members.append(idx)
         else:
-            for i from 0 <= i < n:
-                outbuf[i, j] = values[i, idx]
-
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def take_2d_axis1_int32(ndarray[int32_t, ndim=2] values,
-                           ndarray[int32_t] indexer,
-                           out=None):
-    cdef:
-        Py_ssize_t i, j, k, n, idx
-        ndarray[int32_t, ndim=2] outbuf
-
-    n = len(values)
-    k = len(indexer)
-
-    if out is None:
-        outbuf = np.empty((n, k), dtype=values.dtype)
-    else:
-        outbuf = out
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-
-        if idx == -1:
-            for i from 0 <= i < n:
-                raise ValueError('No NA values allowed')
-        else:
-            for i from 0 <= i < n:
-                outbuf[i, j] = values[i, idx]
-
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def take_2d_axis1_int64(ndarray[int64_t, ndim=2] values,
-                           ndarray[int32_t] indexer,
-                           out=None):
-    cdef:
-        Py_ssize_t i, j, k, n, idx
-        ndarray[int64_t, ndim=2] outbuf
-
-    n = len(values)
-    k = len(indexer)
-
-    if out is None:
-        outbuf = np.empty((n, k), dtype=values.dtype)
-    else:
-        outbuf = out
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-
-        if idx == -1:
-            for i from 0 <= i < n:
-                raise ValueError('No NA values allowed')
-        else:
-            for i from 0 <= i < n:
-                outbuf[i, j] = values[i, idx]
-
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def take_2d_axis1_bool(ndarray[uint8_t, ndim=2] values,
-                           ndarray[int32_t] indexer,
-                           out=None):
-    cdef:
-        Py_ssize_t i, j, k, n, idx
-        ndarray[uint8_t, ndim=2] outbuf
-
-    n = len(values)
-    k = len(indexer)
-
-    if out is None:
-        outbuf = np.empty((n, k), dtype=values.dtype)
-    else:
-        outbuf = out
-
-    for j from 0 <= j < k:
-        idx = indexer[j]
-
-        if idx == -1:
-            for i from 0 <= i < n:
-                raise ValueError('No NA values allowed')
-        else:
-            for i from 0 <= i < n:
-                outbuf[i, j] = values[i, idx]
-
-
-@cython.boundscheck(False)
-@cython.wraparound(False)
-def is_monotonic_float64(ndarray[float64_t] arr):
-    cdef:
-        Py_ssize_t i, n
-        float64_t prev, cur
-
-    n = len(arr)
-
-    if n < 2:
-        return True
-
-    prev = arr[0]
-    for i from 1 <= i < n:
-        cur = arr[i]
-        if cur < prev:
-            return False
-        prev = cur
-    return True
-
-@cython.boundscheck(False)
-@cython.wraparound(False)
-def is_monotonic_object(ndarray[object] arr):
-    cdef:
-        Py_ssize_t i, n
-        object prev, cur
-
-    n = len(arr)
-
-    if n < 2:
-        return True
-
-    prev = arr[0]
-    for i from 1 <= i < n:
-        cur = arr[i]
-        if cur < prev:
-            return False
-        prev = cur
-    return True
-
-@cython.boundscheck(False)
-@cython.wraparound(False)
-def is_monotonic_int32(ndarray[int32_t] arr):
-    cdef:
-        Py_ssize_t i, n
-        int32_t prev, cur
-
-    n = len(arr)
-
-    if n < 2:
-        return True
-
-    prev = arr[0]
-    for i from 1 <= i < n:
-        cur = arr[i]
-        if cur < prev:
-            return False
-        prev = cur
-    return True
-
-@cython.boundscheck(False)
-@cython.wraparound(False)
-def is_monotonic_int64(ndarray[int64_t] arr):
-    cdef:
-        Py_ssize_t i, n
-        int64_t prev, cur
-
-    n = len(arr)
-
-    if n < 2:
-        return True
-
-    prev = arr[0]
-    for i from 1 <= i < n:
-        cur = arr[i]
-        if cur < prev:
-            return False
-        prev = cur
-    return True
-
-@cython.boundscheck(False)
-@cython.wraparound(False)
-def is_monotonic_bool(ndarray[uint8_t] arr):
-    cdef:
-        Py_ssize_t i, n
-        uint8_t prev, cur
-
-    n = len(arr)
-
-    if n < 2:
-        return True
-
-    prev = arr[0]
-    for i from 1 <= i < n:
-        cur = arr[i]
-        if cur < prev:
-            return False
-        prev = cur
-    return True
-
-
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def groupby_float64(ndarray[float64_t] index, ndarray[object] labels):
-    cdef dict result = {}
-    cdef ndarray[int8_t] mask
-    cdef int i, length
-    cdef list members
-    cdef object idx, key
-
-    length = len(index)
-    mask = isnullobj(labels)
-
-    for i from 0 <= i < length:
-        if mask[i]:
-            continue
-
-        key = labels[i]
-        idx = index[i]
-        if key in result:
-            members = result[key]
-            members.append(idx)
-        else:
-            result[key] = [idx]
-
-    return result
-
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def groupby_object(ndarray[object] index, ndarray[object] labels):
-    cdef dict result = {}
-    cdef ndarray[int8_t] mask
-    cdef int i, length
-    cdef list members
-    cdef object idx, key
-
-    length = len(index)
-    mask = isnullobj(labels)
-
-    for i from 0 <= i < length:
-        if mask[i]:
-            continue
-
-        key = labels[i]
-        idx = index[i]
-        if key in result:
-            members = result[key]
-            members.append(idx)
-        else:
-            result[key] = [idx]
-
-    return result
+            result[key] = [idx]
+
+    return result
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -1400,97 +1128,639 @@ def arrmap_bool(ndarray[uint8_t] index, object func):
     for i from 0 <= i < length:
         result[i] = func(index[i])
 
-    return result
+    return result
+
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis0_float64(ndarray[float64_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[float64_t, ndim=2] outbuf
+
+    n = len(indexer)
+    k = values.shape[1]
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = NaN
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis0_object(ndarray[object, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[object, ndim=2] outbuf
+
+    n = len(indexer)
+    k = values.shape[1]
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = NaN
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis0_int32(ndarray[int32_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[int32_t, ndim=2] outbuf
+
+    n = len(indexer)
+    k = values.shape[1]
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+
+        if idx == -1:
+            for j from 0 <= j < k:
+                raise ValueError('No NA values allowed')
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis0_int64(ndarray[int64_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[int64_t, ndim=2] outbuf
+
+    n = len(indexer)
+    k = values.shape[1]
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+
+        if idx == -1:
+            for j from 0 <= j < k:
+                raise ValueError('No NA values allowed')
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis0_bool(ndarray[uint8_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[uint8_t, ndim=2] outbuf
+
+    n = len(indexer)
+    k = values.shape[1]
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for i from 0 <= i < n:
+        idx = indexer[i]
+
+        if idx == -1:
+            for j from 0 <= j < k:
+                raise ValueError('No NA values allowed')
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
+
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis1_float64(ndarray[float64_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[float64_t, ndim=2] outbuf
+
+    n = len(values)
+    k = len(indexer)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for j from 0 <= j < k:
+        idx = indexer[j]
+
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = NaN
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis1_object(ndarray[object, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[object, ndim=2] outbuf
+
+    n = len(values)
+    k = len(indexer)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for j from 0 <= j < k:
+        idx = indexer[j]
+
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = NaN
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis1_int32(ndarray[int32_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[int32_t, ndim=2] outbuf
+
+    n = len(values)
+    k = len(indexer)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for j from 0 <= j < k:
+        idx = indexer[j]
+
+        if idx == -1:
+            for i from 0 <= i < n:
+                raise ValueError('No NA values allowed')
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis1_int64(ndarray[int64_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[int64_t, ndim=2] outbuf
+
+    n = len(values)
+    k = len(indexer)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for j from 0 <= j < k:
+        idx = indexer[j]
+
+        if idx == -1:
+            for i from 0 <= i < n:
+                raise ValueError('No NA values allowed')
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_axis1_bool(ndarray[uint8_t, ndim=2] values,
+                           ndarray[int32_t] indexer,
+                           out=None):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[uint8_t, ndim=2] outbuf
+
+    n = len(values)
+    k = len(indexer)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+    for j from 0 <= j < k:
+        idx = indexer[j]
+
+        if idx == -1:
+            for i from 0 <= i < n:
+                raise ValueError('No NA values allowed')
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
+
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def left_join_indexer_float64(ndarray[float64_t] left,
+                             ndarray[float64_t] right):
+    cdef:
+        Py_ssize_t i, j, nleft, nright
+        ndarray[int32_t] indexer
+        float64_t lval, rval
+
+    i = 0
+    j = 0
+    nleft = len(left)
+    nright = len(right)
+
+    indexer = np.empty(nleft, dtype=np.int32)
+    while True:
+        if i == nleft:
+            break
+
+        if j == nright:
+            indexer[i] = -1
+            i += 1
+            continue
+
+        lval = left[i]
+        rval = right[j]
+
+        if lval == right[j]:
+            indexer[i] = j
+            i += 1
+            j += 1
+        elif lval > rval:
+            indexer[i] = -1
+            j += 1
+        else:
+            indexer[i] = -1
+            i += 1
+    return indexer
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def left_join_indexer_object(ndarray[object] left,
+                             ndarray[object] right):
+    cdef:
+        Py_ssize_t i, j, nleft, nright
+        ndarray[int32_t] indexer
+        object lval, rval
+
+    i = 0
+    j = 0
+    nleft = len(left)
+    nright = len(right)
+
+    indexer = np.empty(nleft, dtype=np.int32)
+    while True:
+        if i == nleft:
+            break
+
+        if j == nright:
+            indexer[i] = -1
+            i += 1
+            continue
+
+        lval = left[i]
+        rval = right[j]
+
+        if lval == right[j]:
+            indexer[i] = j
+            i += 1
+            j += 1
+        elif lval > rval:
+            indexer[i] = -1
+            j += 1
+        else:
+            indexer[i] = -1
+            i += 1
+    return indexer
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def left_join_indexer_int32(ndarray[int32_t] left,
+                             ndarray[int32_t] right):
+    cdef:
+        Py_ssize_t i, j, nleft, nright
+        ndarray[int32_t] indexer
+        int32_t lval, rval
+
+    i = 0
+    j = 0
+    nleft = len(left)
+    nright = len(right)
+
+    indexer = np.empty(nleft, dtype=np.int32)
+    while True:
+        if i == nleft:
+            break
+
+        if j == nright:
+            indexer[i] = -1
+            i += 1
+            continue
+
+        lval = left[i]
+        rval = right[j]
+
+        if lval == right[j]:
+            indexer[i] = j
+            i += 1
+            j += 1
+        elif lval > rval:
+            indexer[i] = -1
+            j += 1
+        else:
+            indexer[i] = -1
+            i += 1
+    return indexer
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def left_join_indexer_int64(ndarray[int64_t] left,
+                             ndarray[int64_t] right):
+    cdef:
+        Py_ssize_t i, j, nleft, nright
+        ndarray[int32_t] indexer
+        int64_t lval, rval
+
+    i = 0
+    j = 0
+    nleft = len(left)
+    nright = len(right)
+
+    indexer = np.empty(nleft, dtype=np.int32)
+    while True:
+        if i == nleft:
+            break
+
+        if j == nright:
+            indexer[i] = -1
+            i += 1
+            continue
+
+        lval = left[i]
+        rval = right[j]
+
+        if lval == right[j]:
+            indexer[i] = j
+            i += 1
+            j += 1
+        elif lval > rval:
+            indexer[i] = -1
+            j += 1
+        else:
+            indexer[i] = -1
+            i += 1
+    return indexer
+
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def outer_join_indexer_float64(ndarray[float64_t] left,
+                                ndarray[float64_t] right):
+    cdef:
+        Py_ssize_t i, j, nright, nleft, count
+        float64_t lval, rval
+        ndarray[int32_t] lindexer, rindexer
+        ndarray[float64_t] result
+
+    nleft = len(left)
+    nright = len(right)
+
+    i = 0
+    j = 0
+    count = 0
+    while True:
+        if i == nleft:
+            if j == nright:
+                # we are done
+                break
+            else:
+                while j < nright:
+                    j += 1
+                    count += 1
+                break
+        elif j == nright:
+            while i < nleft:
+                i += 1
+                count += 1
+            break
+        else:
+            if left[i] == right[j]:
+                i += 1
+                j += 1
+            elif left[i] < right[j]:
+                i += 1
+            else:
+                j += 1
+
+            count += 1
+
+    lindexer = np.empty(count, dtype=np.int32)
+    rindexer = np.empty(count, dtype=np.int32)
+    result = np.empty(count, dtype=np.float64)
+
+    # do it again, but populate the indexers / result
+
+    i = 0
+    j = 0
+    count = 0
+    while True:
+        if i == nleft:
+            if j == nright:
+                # we are done
+                break
+            else:
+                while j < nright:
+                    lindexer[count] = -1
+                    rindexer[count] = j
+                    result[count] = right[j]
+                    j += 1
+                    count += 1
+                break
+        elif j == nright:
+            while i < nleft:
+                lindexer[count] = i
+                rindexer[count] = -1
+                result[count] = left[i]
+                i += 1
+                count += 1
+            break
+        else:
+            lval = left[i]
+            rval = right[j]
+            if lval == rval:
+                lindexer[count] = i
+                rindexer[count] = j
+                result[count] = lval
+                i += 1
+                j += 1
+            elif lval < rval:
+                lindexer[count] = i
+                rindexer[count] = -1
+                result[count] = lval
+                i += 1
+            else:
+                lindexer[count] = -1
+                rindexer[count] = j
+                result[count] = rval
+                j += 1
+
+            count += 1
 
+    return result, lindexer, rindexer
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def left_join_indexer_object(ndarray[object] left,
-                             ndarray[object] right):
+def outer_join_indexer_object(ndarray[object] left,
+                                ndarray[object] right):
     cdef:
-        Py_ssize_t i, j, nleft, nright
-        ndarray[int32_t] indexer
+        Py_ssize_t i, j, nright, nleft, count
         object lval, rval
+        ndarray[int32_t] lindexer, rindexer
+        ndarray[object] result
 
-    i = 0
-    j = 0
     nleft = len(left)
     nright = len(right)
 
-    indexer = np.empty(nleft, dtype=np.int32)
+    i = 0
+    j = 0
+    count = 0
     while True:
         if i == nleft:
+            if j == nright:
+                # we are done
+                break
+            else:
+                while j < nright:
+                    j += 1
+                    count += 1
+                break
+        elif j == nright:
+            while i < nleft:
+                i += 1
+                count += 1
             break
+        else:
+            if left[i] == right[j]:
+                i += 1
+                j += 1
+            elif left[i] < right[j]:
+                i += 1
+            else:
+                j += 1
 
-        if j == nright:
-            indexer[i] = -1
-            i += 1
-            continue
-
-        lval = left[i]
-        rval = right[j]
+            count += 1
 
-        if lval == right[j]:
-            indexer[i] = j
-            i += 1
-            j += 1
-        elif lval > rval:
-            indexer[i] = -1
-            j += 1
-        else:
-            indexer[i] = -1
-            i += 1
-    return indexer
+    lindexer = np.empty(count, dtype=np.int32)
+    rindexer = np.empty(count, dtype=np.int32)
+    result = np.empty(count, dtype=object)
 
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def left_join_indexer_int64(ndarray[int64_t] left,
-                             ndarray[int64_t] right):
-    cdef:
-        Py_ssize_t i, j, nleft, nright
-        ndarray[int32_t] indexer
-        int64_t lval, rval
+    # do it again, but populate the indexers / result
 
     i = 0
     j = 0
-    nleft = len(left)
-    nright = len(right)
-
-    indexer = np.empty(nleft, dtype=np.int32)
+    count = 0
     while True:
         if i == nleft:
+            if j == nright:
+                # we are done
+                break
+            else:
+                while j < nright:
+                    lindexer[count] = -1
+                    rindexer[count] = j
+                    result[count] = right[j]
+                    j += 1
+                    count += 1
+                break
+        elif j == nright:
+            while i < nleft:
+                lindexer[count] = i
+                rindexer[count] = -1
+                result[count] = left[i]
+                i += 1
+                count += 1
             break
-
-        if j == nright:
-            indexer[i] = -1
-            i += 1
-            continue
-
-        lval = left[i]
-        rval = right[j]
-
-        if lval == right[j]:
-            indexer[i] = j
-            i += 1
-            j += 1
-        elif lval > rval:
-            indexer[i] = -1
-            j += 1
         else:
-            indexer[i] = -1
-            i += 1
-    return indexer
+            lval = left[i]
+            rval = right[j]
+            if lval == rval:
+                lindexer[count] = i
+                rindexer[count] = j
+                result[count] = lval
+                i += 1
+                j += 1
+            elif lval < rval:
+                lindexer[count] = i
+                rindexer[count] = -1
+                result[count] = lval
+                i += 1
+            else:
+                lindexer[count] = -1
+                rindexer[count] = j
+                result[count] = rval
+                j += 1
 
+            count += 1
+
+    return result, lindexer, rindexer
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def outer_join_indexer_object(ndarray[object] left,
-                                ndarray[object] right):
+def outer_join_indexer_int32(ndarray[int32_t] left,
+                                ndarray[int32_t] right):
     cdef:
         Py_ssize_t i, j, nright, nleft, count
-        object lval, rval
+        int32_t lval, rval
         ndarray[int32_t] lindexer, rindexer
-        ndarray[object] result
+        ndarray[int32_t] result
 
     nleft = len(left)
     nright = len(right)
@@ -1526,7 +1796,7 @@ def outer_join_indexer_object(ndarray[object] left,
 
     lindexer = np.empty(count, dtype=np.int32)
     rindexer = np.empty(count, dtype=np.int32)
-    result = np.empty(count, dtype=object)
+    result = np.empty(count, dtype=np.int32)
 
     # do it again, but populate the indexers / result
 
@@ -1675,6 +1945,69 @@ def outer_join_indexer_int64(ndarray[int64_t] left,
     return result, lindexer, rindexer
 
 
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def inner_join_indexer_float64(ndarray[float64_t] left,
+                              ndarray[float64_t] right):
+    '''
+    Two-pass algorithm?
+    '''
+    cdef:
+        Py_ssize_t i, j, k, nright, nleft, count
+        float64_t lval, rval
+        ndarray[int32_t] lindexer, rindexer
+        ndarray[float64_t] result
+
+    nleft = len(left)
+    nright = len(right)
+
+    i = 0
+    j = 0
+    count = 0
+    while True:
+        if i == nleft or j == nright:
+             break
+        else:
+            lval = left[i]
+            rval = right[j]
+            if lval == rval:
+                i += 1
+                j += 1
+                count += 1
+            elif lval < rval:
+                i += 1
+            else:
+                j += 1
+
+    # do it again now that result size is known
+
+    lindexer = np.empty(count, dtype=np.int32)
+    rindexer = np.empty(count, dtype=np.int32)
+    result = np.empty(count, dtype=np.float64)
+
+    i = 0
+    j = 0
+    count = 0
+    while True:
+        if i == nleft or j == nright:
+             break
+        else:
+            lval = left[i]
+            rval = right[j]
+            if lval == rval:
+                lindexer[count] = i
+                rindexer[count] = j
+                result[count] = lval
+                i += 1
+                j += 1
+                count += 1
+            elif lval < rval:
+                i += 1
+            else:
+                j += 1
+
+    return result, lindexer, rindexer
+
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def inner_join_indexer_object(ndarray[object] left,
@@ -1738,6 +2071,69 @@ def inner_join_indexer_object(ndarray[object] left,
 
     return result, lindexer, rindexer
 
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def inner_join_indexer_int32(ndarray[int32_t] left,
+                              ndarray[int32_t] right):
+    '''
+    Two-pass algorithm?
+    '''
+    cdef:
+        Py_ssize_t i, j, k, nright, nleft, count
+        int32_t lval, rval
+        ndarray[int32_t] lindexer, rindexer
+        ndarray[int32_t] result
+
+    nleft = len(left)
+    nright = len(right)
+
+    i = 0
+    j = 0
+    count = 0
+    while True:
+        if i == nleft or j == nright:
+             break
+        else:
+            lval = left[i]
+            rval = right[j]
+            if lval == rval:
+                i += 1
+                j += 1
+                count += 1
+            elif lval < rval:
+                i += 1
+            else:
+                j += 1
+
+    # do it again now that result size is known
+
+    lindexer = np.empty(count, dtype=np.int32)
+    rindexer = np.empty(count, dtype=np.int32)
+    result = np.empty(count, dtype=np.int32)
+
+    i = 0
+    j = 0
+    count = 0
+    while True:
+        if i == nleft or j == nright:
+             break
+        else:
+            lval = left[i]
+            rval = right[j]
+            if lval == rval:
+                lindexer[count] = i
+                rindexer[count] = j
+                result[count] = lval
+                i += 1
+                j += 1
+                count += 1
+            elif lval < rval:
+                i += 1
+            else:
+                j += 1
+
+    return result, lindexer, rindexer
+
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def inner_join_indexer_int64(ndarray[int64_t] left,
diff --git a/pandas/src/reindex.pyx b/pandas/src/reindex.pyx
index f1b5a91c2..97e20f391 100644
--- a/pandas/src/reindex.pyx
+++ b/pandas/src/reindex.pyx
@@ -224,3 +224,4 @@ def take_join_contiguous(ndarray[float64_t, ndim=2] lvalues,
             for j from 0 <= j < rk:
                 outbuf[0] = rvalues[ridx, j]
                 outbuf = outbuf + 1
+

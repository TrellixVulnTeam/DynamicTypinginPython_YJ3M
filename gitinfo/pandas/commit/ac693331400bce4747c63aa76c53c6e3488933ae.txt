commit ac693331400bce4747c63aa76c53c6e3488933ae
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon Aug 5 08:52:44 2019 -0700

    CLN: collected cleanups from other branches (#27723)

diff --git a/pandas/_libs/index.pyx b/pandas/_libs/index.pyx
index f704ceffa..7424c4ddc 100644
--- a/pandas/_libs/index.pyx
+++ b/pandas/_libs/index.pyx
@@ -47,10 +47,6 @@ cpdef get_value_at(ndarray arr, object loc, object tz=None):
     return util.get_value_at(arr, loc)
 
 
-def get_value_box(arr: ndarray, loc: object) -> object:
-    return get_value_at(arr, loc, tz=None)
-
-
 # Don't populate hash tables in monotonic indexes larger than this
 _SIZE_CUTOFF = 1000000
 
diff --git a/pandas/core/arrays/numpy_.py b/pandas/core/arrays/numpy_.py
index 39529177b..667fb4501 100644
--- a/pandas/core/arrays/numpy_.py
+++ b/pandas/core/arrays/numpy_.py
@@ -125,7 +125,11 @@ class PandasArray(ExtensionArray, ExtensionOpsMixin, NDArrayOperatorsMixin):
         if isinstance(values, type(self)):
             values = values._ndarray
         if not isinstance(values, np.ndarray):
-            raise ValueError("'values' must be a NumPy array.")
+            raise ValueError(
+                "'values' must be a NumPy array, not {typ}".format(
+                    typ=type(values).__name__
+                )
+            )
 
         if values.ndim != 1:
             raise ValueError("PandasArray must be 1-dimensional.")
diff --git a/pandas/core/arrays/timedeltas.py b/pandas/core/arrays/timedeltas.py
index 94dd561fc..6899e4704 100644
--- a/pandas/core/arrays/timedeltas.py
+++ b/pandas/core/arrays/timedeltas.py
@@ -173,8 +173,8 @@ class TimedeltaArray(dtl.DatetimeLikeArrayMixin, dtl.TimelikeOps):
         "ceil",
     ]
 
-    # Needed so that NaT.__richcmp__(DateTimeArray) operates pointwise
-    ndim = 1
+    # Note: ndim must be defined to ensure NaT.__richcmp(TimedeltaArray)
+    #  operates pointwise.
 
     @property
     def _box_func(self):
diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index 57e84282a..356ae20b2 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -4714,7 +4714,7 @@ class Index(IndexOpsMixin, PandasObject):
                 raise
 
             try:
-                return libindex.get_value_box(s, key)
+                return libindex.get_value_at(s, key)
             except IndexError:
                 raise
             except TypeError:
diff --git a/pandas/core/internals/blocks.py b/pandas/core/internals/blocks.py
index 6a2aebe5d..9f3aa699c 100644
--- a/pandas/core/internals/blocks.py
+++ b/pandas/core/internals/blocks.py
@@ -434,7 +434,7 @@ class Block(PandasObject):
 
         return self.split_and_operate(mask, f, inplace)
 
-    def split_and_operate(self, mask, f, inplace):
+    def split_and_operate(self, mask, f, inplace: bool):
         """
         split the block per-column, and apply the callable f
         per-column, return a new block for each. Handle
@@ -493,17 +493,15 @@ class Block(PandasObject):
 
         return new_blocks
 
-    def _maybe_downcast(self, blocks, downcast=None):
+    def _maybe_downcast(self, blocks: List["Block"], downcast=None) -> List["Block"]:
 
         # no need to downcast our float
         # unless indicated
-        if downcast is None and self.is_float:
-            return blocks
-        elif downcast is None and (self.is_timedelta or self.is_datetime):
+        if downcast is None and (
+            self.is_float or self.is_timedelta or self.is_datetime
+        ):
             return blocks
 
-        if not isinstance(blocks, list):
-            blocks = [blocks]
         return _extend_blocks([b.downcast(downcast) for b in blocks])
 
     def downcast(self, dtypes=None):
@@ -1343,7 +1341,15 @@ class Block(PandasObject):
 
         return [self.make_block(new_values)]
 
-    def where(self, other, cond, align=True, errors="raise", try_cast=False, axis=0):
+    def where(
+        self,
+        other,
+        cond,
+        align=True,
+        errors="raise",
+        try_cast: bool = False,
+        axis: int = 0,
+    ) -> List["Block"]:
         """
         evaluate the block; return result block(s) from the result
 
@@ -1442,7 +1448,7 @@ class Block(PandasObject):
             if try_cast:
                 result = self._try_cast_result(result)
 
-            return self.make_block(result)
+            return [self.make_block(result)]
 
         # might need to separate out blocks
         axis = cond.ndim - 1
@@ -1474,9 +1480,9 @@ class Block(PandasObject):
         new_columns : Index
             All columns of the unstacked BlockManager.
         n_rows : int
-            Only used in ExtensionBlock.unstack
+            Only used in ExtensionBlock._unstack
         fill_value : int
-            Only used in ExtensionBlock.unstack
+            Only used in ExtensionBlock._unstack
 
         Returns
         -------
@@ -1550,7 +1556,7 @@ class Block(PandasObject):
             result = result[..., 0]
             result = lib.item_from_zerodim(result)
 
-        ndim = getattr(result, "ndim", None) or 0
+        ndim = np.ndim(result)
         return make_block(result, placement=np.arange(len(result)), ndim=ndim)
 
     def _replace_coerce(
@@ -1923,7 +1929,15 @@ class ExtensionBlock(NonConsolidatableMixIn, Block):
             )
         ]
 
-    def where(self, other, cond, align=True, errors="raise", try_cast=False, axis=0):
+    def where(
+        self,
+        other,
+        cond,
+        align=True,
+        errors="raise",
+        try_cast: bool = False,
+        axis: int = 0,
+    ) -> List["Block"]:
         if isinstance(other, ABCDataFrame):
             # ExtensionArrays are 1-D, so if we get here then
             # `other` should be a DataFrame with a single column.
@@ -1968,7 +1982,7 @@ class ExtensionBlock(NonConsolidatableMixIn, Block):
                 np.where(cond, self.values, other), dtype=dtype
             )
 
-        return self.make_block_same_class(result, placement=self.mgr_locs)
+        return [self.make_block_same_class(result, placement=self.mgr_locs)]
 
     @property
     def _ftype(self):
@@ -2706,7 +2720,7 @@ class ObjectBlock(Block):
 
         return blocks
 
-    def _maybe_downcast(self, blocks, downcast=None):
+    def _maybe_downcast(self, blocks: List["Block"], downcast=None) -> List["Block"]:
 
         if downcast is not None:
             return blocks
@@ -3031,7 +3045,15 @@ class CategoricalBlock(ExtensionBlock):
             values, placement=placement or slice(0, len(values), 1), ndim=self.ndim
         )
 
-    def where(self, other, cond, align=True, errors="raise", try_cast=False, axis=0):
+    def where(
+        self,
+        other,
+        cond,
+        align=True,
+        errors="raise",
+        try_cast: bool = False,
+        axis: int = 0,
+    ) -> List["Block"]:
         # TODO(CategoricalBlock.where):
         # This can all be deleted in favor of ExtensionBlock.where once
         # we enforce the deprecation.
diff --git a/pandas/core/internals/managers.py b/pandas/core/internals/managers.py
index e5acd23b7..b30ddbc38 100644
--- a/pandas/core/internals/managers.py
+++ b/pandas/core/internals/managers.py
@@ -1823,7 +1823,7 @@ def _simple_blockify(tuples, dtype):
     """
     values, placement = _stack_arrays(tuples, dtype)
 
-    # CHECK DTYPE?
+    # TODO: CHECK DTYPE?
     if dtype is not None and values.dtype != dtype:  # pragma: no cover
         values = values.astype(dtype)
 
diff --git a/pandas/core/resample.py b/pandas/core/resample.py
index 66878c3b1..a5d0e2cb3 100644
--- a/pandas/core/resample.py
+++ b/pandas/core/resample.py
@@ -1630,15 +1630,14 @@ class TimeGrouper(Grouper):
 
 
 def _take_new_index(obj, indexer, new_index, axis=0):
-    from pandas.core.api import Series, DataFrame
 
-    if isinstance(obj, Series):
+    if isinstance(obj, ABCSeries):
         new_values = algos.take_1d(obj.values, indexer)
-        return Series(new_values, index=new_index, name=obj.name)
-    elif isinstance(obj, DataFrame):
+        return obj._constructor(new_values, index=new_index, name=obj.name)
+    elif isinstance(obj, ABCDataFrame):
         if axis == 1:
             raise NotImplementedError("axis 1 is not supported")
-        return DataFrame(
+        return obj._constructor(
             obj._data.reindex_indexer(new_axis=new_index, indexer=indexer, axis=1)
         )
     else:
diff --git a/pandas/core/window.py b/pandas/core/window.py
index 4b6a1cf2e..a7425bc14 100644
--- a/pandas/core/window.py
+++ b/pandas/core/window.py
@@ -265,6 +265,8 @@ class _Window(PandasObject, SelectionMixin):
             # coerce if necessary
             if block is not None:
                 if is_timedelta64_dtype(block.values.dtype):
+                    # TODO: do we know what result.dtype is at this point?
+                    #  i.e. can we just do an astype?
                     from pandas import to_timedelta
 
                     result = to_timedelta(result.ravel(), unit="ns").values.reshape(
diff --git a/pandas/tests/groupby/test_categorical.py b/pandas/tests/groupby/test_categorical.py
index 9b8c8e6d8..ce724f5a6 100644
--- a/pandas/tests/groupby/test_categorical.py
+++ b/pandas/tests/groupby/test_categorical.py
@@ -506,7 +506,7 @@ def test_datetime():
     desc_result = grouped.describe()
 
     idx = cats.codes.argsort()
-    ord_labels = cats.take_nd(idx)
+    ord_labels = cats.take(idx)
     ord_data = data.take(idx)
     expected = ord_data.groupby(ord_labels, observed=False).describe()
     assert_frame_equal(desc_result, expected)

commit e03c77e9c0ca2ae917575641b820571532c16255
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Sep 9 12:45:29 2011 -0400

    ENH: add omitna option to Series stat methods and fix up unit tests

diff --git a/pandas/core/series.py b/pandas/core/series.py
index 88beb40eb..297eab784 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -518,111 +518,214 @@ copy : boolean, default False
 
         return Series(result, index=level_index)
 
-    def sum(self, axis=0, dtype=None, out=None):
+    def sum(self, axis=0, dtype=None, out=None, omitna=True):
         """
-        Sum of non-NA/null values
+        Sum of values
+
+        Parameters
+        ----------
+        omitna : boolean, default True
+            Exclude NA/null values
 
         Returns
         -------
         sum : float
         """
         values = self.values.copy()
-        mask = isnull(values)
-        if mask.all():
-            return np.nan
 
-        np.putmask(values, mask, 0)
+        if omitna:
+            mask = isnull(values)
+            if mask.all():
+                return np.nan
+            np.putmask(values, mask, 0)
+
         return values.sum()
 
-    def mean(self, axis=0, dtype=None, out=None):
+    def mean(self, axis=0, dtype=None, out=None, omitna=True):
         """
-        Mean of non-NA/null values
+        Mean of values
+
+        Parameters
+        ----------
+        omitna : boolean, default True
+            Exclude NA/null values
 
         Returns
         -------
         mean : float
         """
-        return self._ndarray_statistic('mean', dtype=dtype)
+        return self._ndarray_statistic('mean', dtype=dtype, omitna=omitna)
 
-    def prod(self, axis=0, dtype=None, out=None):
+    def median(self, omitna=True):
         """
-        Product of non-NA/null values
+        Compute median of values
+
+        Parameters
+        ----------
+        omitna : boolean, default True
+            Exclude NA/null values
+
+        Returns
+        -------
+        median : float
+        """
+        arr = self.values
+        if arr.dtype != np.float_:
+            arr = arr.astype(float)
+        mask = notnull(arr)
+
+        if omitna:
+            arr = arr[mask]
+        else:
+            if not mask.all():
+                return np.nan
+
+        return _tseries.median(arr)
+
+    def prod(self, axis=0, dtype=None, out=None, omitna=True):
+        """
+        Product of all values
+
+        Parameters
+        ----------
+        omitna : boolean, default True
+            Exclude NA/null values
 
         Returns
         -------
         product : float
         """
-        return self._ndarray_statistic('prod', dtype=dtype)
+        return self._ndarray_statistic('prod', dtype=dtype, omitna=omitna)
 
-    def min(self, axis=None, out=None):
+    def min(self, axis=None, out=None, omitna=True):
         """
-        Minimum of non-NA/null values
+        Minimum of values
+
+        Parameters
+        ----------
+        omitna : boolean, default True
+            Exclude NA/null values
 
         Returns
         -------
         min : float
         """
         arr = self.values.copy()
-        if not issubclass(arr.dtype.type, np.int_):
-            np.putmask(arr, isnull(arr), np.inf)
+        if omitna:
+            if not issubclass(arr.dtype.type, np.int_):
+                np.putmask(arr, isnull(arr), np.inf)
         return arr.min()
 
-    def max(self, axis=None, out=None):
+    def max(self, axis=None, out=None, omitna=True):
         """
-        Maximum of non-NA/null values
+        Maximum of values
+
+        Parameters
+        ----------
+        omitna : boolean, default True
+            Exclude NA/null values
 
         Returns
         -------
         max : float
         """
         arr = self.values.copy()
-        if not issubclass(arr.dtype.type, np.int_):
-            np.putmask(arr, isnull(arr), -np.inf)
+        if omitna:
+            if not issubclass(arr.dtype.type, np.int_):
+                np.putmask(arr, isnull(arr), -np.inf)
         return arr.max()
 
-    def std(self, axis=None, dtype=None, out=None, ddof=1):
+    def std(self, axis=None, dtype=None, out=None, ddof=1, omitna=True):
         """
-        Unbiased standard deviation of non-NA/null values
+        Unbiased standard deviation of values
 
         Extra parameters are to preserve ndarray interface.
 
+        Parameters
+        ----------
+        omitna : boolean, default True
+            Exclude NA/null values
+
         Returns
         -------
         stdev : float
         """
-        nona = remove_na(self.values)
-        if len(nona) < 2:
-            return nan
-        return ndarray.std(nona, axis, dtype, out, ddof)
+        if omitna:
+            nona = remove_na(self.values)
+            if len(nona) < 2:
+                return nan
+            return ndarray.std(nona, axis, dtype, out, ddof)
+        else:
+            return self.values.std(axis, dtype, out, ddof)
 
-    def var(self, axis=None, dtype=None, out=None, ddof=1):
+    def var(self, axis=None, dtype=None, out=None, ddof=1, omitna=True):
         """
         Unbiased variance of non-NA/null values
 
         Extra parameters are to preserve ndarray interface.
 
+        Parameters
+        ----------
+        omitna : boolean, default True
+            Exclude NA/null values
+
         Returns
         -------
         var : float
         """
-        nona = remove_na(self.values)
-        if len(nona) < 2:
-            return nan
-        return ndarray.var(nona, axis, dtype, out, ddof)
+        if omitna:
+            nona = remove_na(self.values)
+            if len(nona) < 2:
+                return nan
+            return ndarray.var(nona, axis, dtype, out, ddof)
+        else:
+            return self.values.var(axis, dtype, out, ddof)
 
-    def cumsum(self, axis=0, dtype=None, out=None):
+    def skew(self, omitna=True):
+        """
+        Unbiased skewness of the non-NA/null values
+
+        Parameters
+        ----------
+        omitna : boolean, default True
+            Exclude NA/null values
+
+        Returns
+        -------
+        skew : float
+        """
+        y = np.array(self.values)
+        mask = notnull(y)
+        count = mask.sum()
+
+        if count < len(self) and not omitna:
+            return np.nan
+
+        np.putmask(y, -mask, 0)
+        A = y.sum() / count
+        B = (y**2).sum() / count  - A**2
+        C = (y**3).sum() / count - A**3 - 3*A*B
+
+        return (np.sqrt((count**2-count))*C) / ((count-2)*np.sqrt(B)**3)
+
+    def cumsum(self, axis=0, dtype=None, out=None, omitna=True):
         """
         Cumulative sum of values. Preserves locations of NaN values
 
         Extra parameters are to preserve ndarray interface.
 
+        Parameters
+        ----------
+        omitna : boolean, default True
+            Exclude NA/null values
+
         Returns
         -------
         cumsum : Series
         """
         arr = self.values.copy()
 
-        do_mask = not issubclass(self.dtype.type, np.int_)
+        do_mask = omitna and not issubclass(self.dtype.type, np.int_)
         if do_mask:
             mask = isnull(arr)
             np.putmask(arr, mask, 0.)
@@ -634,19 +737,24 @@ copy : boolean, default False
 
         return Series(result, index=self.index)
 
-    def cumprod(self, axis=0, dtype=None, out=None):
+    def cumprod(self, axis=0, dtype=None, out=None, omitna=True):
         """
         Cumulative product of values. Preserves locations of NaN values
 
         Extra parameters are to preserve ndarray interface.
 
+        Parameters
+        ----------
+        omitna : boolean, default True
+            Exclude NA/null values
+
         Returns
         -------
         cumprod : Series
         """
         arr = self.values.copy()
 
-        do_mask = not issubclass(self.dtype.type, np.int_)
+        do_mask = omitna and not issubclass(self.dtype.type, np.int_)
         if do_mask:
             mask = isnull(arr)
             np.putmask(arr, mask, 1.)
@@ -658,27 +766,11 @@ copy : boolean, default False
 
         return Series(result, index=self.index)
 
-    def median(self):
-        """
-        Compute median value of non-NA/null values
-
-        Returns
-        -------
-        median : float
-        """
-        arr = self.values
-
-        if arr.dtype != np.float_:
-            arr = arr.astype(float)
-
-        arr = arr[notnull(arr)]
-        return _tseries.median(arr)
-
-    def _ndarray_statistic(self, funcname, dtype=None):
+    def _ndarray_statistic(self, funcname, dtype=None, omitna=True):
         arr = self.values
         retVal = getattr(arr, funcname)(dtype=dtype)
 
-        if isnull(retVal):
+        if omitna and isnull(retVal):
             arr = remove_na(arr)
             if len(arr) == 0:
                 return np.nan
@@ -701,7 +793,7 @@ copy : boolean, default False
         quantile : float
         """
         from scipy.stats import scoreatpercentile
-        return scoreatpercentile(self.valid().values, q * 100)
+        return scoreatpercentile(self.dropna().values, q * 100)
 
     def describe(self):
         """
@@ -722,25 +814,6 @@ copy : boolean, default False
 
         return Series(data, index=names)
 
-    def skew(self):
-        """
-        Unbiased skewness of the non-NA/null values
-
-        Returns
-        -------
-        skew : float
-        """
-        y = np.array(self.values)
-        mask = notnull(y)
-        count = mask.sum()
-        np.putmask(y, -mask, 0)
-
-        A = y.sum() / count
-        B = (y**2).sum() / count  - A**2
-        C = (y**3).sum() / count - A**3 - 3*A*B
-
-        return (np.sqrt((count**2-count))*C) / ((count-2)*np.sqrt(B)**3)
-
     def corr(self, other):
         """
         Compute correlation two Series, excluding missing values
@@ -753,7 +826,7 @@ copy : boolean, default False
         -------
         correlation : float
         """
-        commonIdx = self.valid().index.intersection(other.valid().index)
+        commonIdx = self.dropna().index.intersection(other.dropna().index)
 
         if len(commonIdx) == 0:
             return nan
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index b00f127b3..cdccade85 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -8,7 +8,7 @@ import unittest
 from numpy import nan
 import numpy as np
 
-from pandas import Index, Series, TimeSeries, DataFrame, isnull
+from pandas import Index, Series, TimeSeries, DataFrame, isnull, notnull
 from pandas.core.index import MultiIndex
 import pandas.core.datetools as datetools
 from pandas.util.testing import assert_series_equal, assert_almost_equal
@@ -361,43 +361,81 @@ class TestSeries(unittest.TestCase):
         for idx, val in self.ts.iteritems():
             self.assertEqual(val, self.ts[idx])
 
-    def test_stats(self):
+    def test_sum(self):
+        self._check_stat_op('sum', np.sum)
+
+    def test_mean(self):
+        self._check_stat_op('mean', np.mean)
+
+    def test_median(self):
+        self._check_stat_op('median', np.median)
+
+        # test with integers, test failure
+        int_ts = TimeSeries(np.ones(10, dtype=int), index=range(10))
+        self.assertAlmostEqual(np.median(int_ts), int_ts.median())
+
+    def test_prod(self):
+        self._check_stat_op('prod', np.prod)
+
+    def test_min(self):
+        self._check_stat_op('min', np.min)
+
+    def test_max(self):
+        self._check_stat_op('max', np.max)
+
+    def test_std(self):
+        alt = lambda x: np.std(x, ddof=1)
+        self._check_stat_op('std', alt)
+
+    def test_var(self):
+        alt = lambda x: np.var(x, ddof=1)
+        self._check_stat_op('var', alt)
+
+    def test_skew(self):
+        from scipy.stats import skew
+        alt =lambda x: skew(x, bias=False)
+        self._check_stat_op('skew', alt)
+
+    def test_argsort(self):
+        self._check_accum_op('argsort')
+        argsorted = self.ts.argsort()
+        self.assert_(issubclass(argsorted.dtype.type, np.integer))
+
+    def test_cumsum(self):
+        self._check_accum_op('cumsum')
+
+    def test_cumprod(self):
+        self._check_accum_op('cumprod')
+
+    def _check_stat_op(self, name, alternate):
+        f = getattr(Series, name)
+
+        # add some NaNs
         self.series[5:15] = np.NaN
 
-        s1 = np.array(self.series)
-        s1 = s1[-np.isnan(s1)]
-
-        self.assertEquals(np.min(s1), self.series.min())
-        self.assertEquals(np.max(s1), self.series.max())
-        self.assertEquals(np.sum(s1), self.series.sum())
-        self.assertEquals(np.mean(s1), self.series.mean())
-        self.assertEquals(np.std(s1, ddof=1), self.series.std())
-        self.assertEquals(np.var(s1, ddof=1), self.series.var())
-
-        try:
-            from scipy.stats import skew
-            common.assert_almost_equal(skew(s1, bias=False),
-                                       self.series.skew())
-        except ImportError:
-            pass
-
-        self.assert_(not np.isnan(np.sum(self.series)))
-        self.assert_(not np.isnan(np.mean(self.series)))
-        self.assert_(not np.isnan(np.std(self.series)))
-        self.assert_(not np.isnan(np.var(self.series)))
-        self.assert_(not np.isnan(np.min(self.series)))
-        self.assert_(not np.isnan(np.max(self.series)))
-
-        self.assert_(np.isnan(Series([1.], index=[1]).std()))
-        self.assert_(np.isnan(Series([1.], index=[1]).var()))
-        self.assert_(np.isnan(Series([1.], index=[1]).skew()))
-
-        # all NA
+        # omitna or no
+        self.assert_(notnull(f(self.series)))
+        self.assert_(isnull(f(self.series, omitna=False)))
+
+        # check the result is correct
+        nona = self.series.dropna()
+        assert_almost_equal(f(nona), alternate(nona))
+
         allna = self.series * nan
-        self.assert_(np.isnan(allna.sum()))
-        self.assert_(np.isnan(allna.mean()))
-        self.assert_(np.isnan(allna.std()))
-        self.assert_(np.isnan(allna.skew()))
+        self.assert_(isnull(f(allna)))
+
+    def _check_accum_op(self, name):
+        func = getattr(np, name)
+        self.assert_(np.array_equal(func(self.ts), func(np.array(self.ts))))
+
+        # with missing values
+        ts = self.ts.copy()
+        ts[::2] = np.NaN
+
+        result = func(ts)[1::2]
+        expected = func(np.array(ts.valid()))
+
+        self.assert_(np.array_equal(result, expected))
 
     def test_prod_numpy16_bug(self):
         s = Series([1., 1., 1.] , index=range(3))
@@ -590,38 +628,6 @@ class TestSeries(unittest.TestCase):
         result = s.combine_first(Series([], index=[]))
         assert_series_equal(s, result)
 
-    def test_overloads(self):
-        methods = ['argsort', 'cumsum', 'cumprod']
-
-        for method in methods:
-            func = getattr(np, method)
-
-            self.assert_(np.array_equal(func(self.ts), func(np.array(self.ts))))
-
-            # with missing values
-            ts = self.ts.copy()
-            ts[::2] = np.NaN
-
-            result = func(ts)[1::2]
-            expected = func(np.array(ts.valid()))
-
-            self.assert_(np.array_equal(result, expected))
-
-        argsorted = self.ts.argsort()
-        self.assert_(issubclass(argsorted.dtype.type, np.integer))
-
-    def test_median(self):
-        self.assertAlmostEqual(np.median(self.ts), self.ts.median())
-
-        ts = self.ts.copy()
-        ts[::2] = np.NaN
-
-        self.assertAlmostEqual(np.median(ts.valid()), ts.median())
-
-        # test with integers, test failure
-        int_ts = TimeSeries(np.ones(10, dtype=int), index=range(10))
-        self.assertAlmostEqual(np.median(int_ts), int_ts.median())
-
     def test_corr(self):
         # full overlap
         self.assertAlmostEqual(self.ts.corr(self.ts), 1)

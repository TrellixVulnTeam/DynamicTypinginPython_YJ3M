commit 63e8f67d661261edd85b674b1f60a2599f926df5
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Sep 7 15:56:29 2011 -0400

    DOC: plotting function enhancements and plotting / stats docs

diff --git a/doc/plots/stats/moments_ewma.py b/doc/plots/stats/moments_ewma.py
index 2919b05fa..3e521ed60 100644
--- a/doc/plots/stats/moments_ewma.py
+++ b/doc/plots/stats/moments_ewma.py
@@ -12,3 +12,4 @@ f = plt.gcf()
 f.autofmt_xdate()
 
 plt.show()
+plt.close('all')
diff --git a/doc/plots/stats/moments_ewmvol.py b/doc/plots/stats/moments_ewmvol.py
index e1ba12289..093f62868 100644
--- a/doc/plots/stats/moments_ewmvol.py
+++ b/doc/plots/stats/moments_ewmvol.py
@@ -20,3 +20,4 @@ f = plt.gcf()
 f.autofmt_xdate()
 
 plt.show()
+plt.close('all')
diff --git a/doc/plots/stats/moments_expw.py b/doc/plots/stats/moments_expw.py
index 4ef856a3e..699b6cce7 100644
--- a/doc/plots/stats/moments_expw.py
+++ b/doc/plots/stats/moments_expw.py
@@ -30,3 +30,4 @@ fig.autofmt_xdate()
 fig.subplots_adjust(bottom=0.10, top=0.95)
 
 plt.show()
+plt.close('all')
diff --git a/doc/plots/stats/moments_rolling.py b/doc/plots/stats/moments_rolling.py
index 05ed70ccc..30a6c5f53 100644
--- a/doc/plots/stats/moments_rolling.py
+++ b/doc/plots/stats/moments_rolling.py
@@ -21,3 +21,4 @@ plot_timeseries(s,
                         'rolling_skew',
                         'rolling_kurt'))
 plt.show()
+plt.close('all')
diff --git a/doc/plots/stats/moments_rolling_binary.py b/doc/plots/stats/moments_rolling_binary.py
index 928b0544e..ab6b7b1c8 100644
--- a/doc/plots/stats/moments_rolling_binary.py
+++ b/doc/plots/stats/moments_rolling_binary.py
@@ -27,3 +27,4 @@ fig.autofmt_xdate()
 fig.subplots_adjust(bottom=0.10, top=0.95)
 
 plt.show()
+plt.close('all')
diff --git a/doc/source/basics.rst b/doc/source/basics.rst
index 5efd514c0..a5c514884 100644
--- a/doc/source/basics.rst
+++ b/doc/source/basics.rst
@@ -1,15 +1,6 @@
 .. currentmodule:: pandas
 .. _basics:
 
-*************
-pandas basics
-*************
-
-We'll start with a quick, non-comprehensive overview of the fundamental data
-structures in pandas to get you started. The fundamental behavior about data
-types, indexing, and axis labeling / alignment apply across all of the
-objects. To get started, import numpy and load pandas into your namespace:
-
 .. ipython:: python
    :suppress:
 
@@ -18,522 +9,23 @@ objects. To get started, import numpy and load pandas into your namespace:
    randn = np.random.randn
    np.set_printoptions(precision=4, suppress=True)
 
-.. ipython:: python
-
-   import numpy as np
-   # will use a lot in examples
-   randn = np.random.randn
-   from pandas import *
-
-Here is a basic tenet to keep in mind: **data alignment is intrinsic**. Link
-between labels and data will not be broken unless done so explicitly by you.
-
-We'll give a brief intro to the data structures, then consider all of the broad
-categories of functionality and methods in separate sections.
-
-.. _basics.series:
-
-Series
-------
-
-:class:`Series` is a one-dimensional labeled array (technically a subclass of
-ndarray) capable of holding any data type (integers, strings, floating point
-numbers, Python objects, etc.). The axis labels are collectively referred to as
-the **index**. The basic method to create a Series is to call:
-
-::
-
-    >>> s = Series(data, index=index)
-
-Here, ``data`` can be many different things:
-
- - a Python dict
- - an ndarray
- - a scalar value (like 5)
-
-The passed **index** is a list of axis labels. Thus, this separates into a few
-cases depending on what **data is**:
-
-**From ndarray**
-
-If ``data`` is an ndarray, **index** must be the same length as **data**. If no
-index is passed, one will be created having values ``[0, ..., len(data) - 1]``.
-
-.. ipython:: python
-
-   s = Series(randn(5), index=['a', 'b', 'c', 'd', 'e'])
-   s
-   s.index
-
-   Series(randn(5))
-
-.. note::
-
-    The values in the index must be unique. If they are not, an exception will
-    **not** be raised immediately, but attempting any operation involving the
-    index will later result in an exception. In other words, the Index object
-    containing the labels "lazily" checks whether the values are unique. The
-    reason for being lazy is nearly all performance-based (there are many
-    instances in computations, like parts of GroupBy, where the index is not
-    used).
-
-**From dict**
-
-If ``data`` is a dict, if **index** is passed the values in data corresponding
-to the labels in the index will be pulled out. Otherwise, an index will be
-constructed from the sorted keys of the dict, if possible.
-
-.. ipython:: python
-
-   d = {'a' : 0., 'b' : 1., 'c' : 2.}
-   Series(d)
-   Series(d, index=['b', 'c', 'd', 'a'])
-
-.. note::
-
-    NaN (not a number) is the standard missing data marker used in pandas
-
-**From scalar value** If ``data`` is a scalar value, an index must be
-provided. The value will be repeated to match the length of **index**
-
-.. ipython:: python
-
-   Series(5., index=['a', 'b', 'c', 'd', 'e'])
-
-Series is ndarray-like
-~~~~~~~~~~~~~~~~~~~~~~
-
-As a subclass of ndarray, Series is a valid argument to most NumPy functions
-and behaves similarly to a NumPy array. However, things like slicing also slice
-the index.
-
-.. ipython :: python
-
-    s[0]
-    s[:3]
-    s[s > s.median()]
-    s[[4, 3, 1]]
-    np.exp(s)
-
-We will address array-based indexing in a separate :ref:`section <indexing>`.
-
-Series is dict-like
-~~~~~~~~~~~~~~~~~~~
-
-A Series is alike a fixed-size dict in that you can get and set values by index
-label:
-
-.. ipython :: python
-
-    s['a']
-    s['e'] = 12.
-    s
-    'e' in s
-    'f' in s
-
-If a label is not contained, an exception
-
-.. code-block:: python
-
-    >>> s['f']
-    KeyError: 'f'
-
-    >>> s.get('f')
-    nan
-
-Vectorized operations and label alignment with Series
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-When doing data analysis, as with raw NumPy arrays looping through Series
-value-by-value is usually not necessary. Series can be also be passed into most
-NumPy methods expecting an ndarray.
-
-
-.. ipython:: python
-
-    s + s
-    s * 2
-    np.exp(s)
-
-A key difference between Series and ndarray is that operations between Series
-automatically align the data based on label. Thus, you can write computations
-without giving consideration to whether the Series involved have the same
-labels.
-
-.. ipython:: python
-
-    s[1:] + s[:-1]
-
-The result of an operation between unaligned Series will have the **union** of
-the indexes involved. If a label is not found in one Series or the other, the
-result will be marked as missing (NaN). Being able to write code without doing
-any explicit data alignment grants immense freedom and flexibility in
-interactive data analysis and research. The integrated data alignment features
-of the pandas data structures set pandas apart from the majority of related
-tools for working with labeled data.
-
-.. note::
-
-    In general, we chose to make the default result of operations between
-    differently indexed objects yield the **union** of the indexes in order to
-    avoid loss of information. Having an index label, though the data is
-    missing, is typically important information as part of a computation. You
-    of course have the option of dropping labels with missing data via the
-    **dropna** function.
-
-.. _basics.dataframe:
-
-DataFrame
----------
-
-**DataFrame** is a 2-dimensional labeled data structure with columns of
-potentially different types. You can think of it like a spreadsheet or SQL
-table, or a dict of Series objects. It is generally the most commonly used
-pandas object. Like Series, DataFrame accepts many different kinds of input:
-
- - Dict of 1D ndarrays, lists, dicts, or Series
- - 2-D numpy.ndarray
- - `Structured or record
-   <http://docs.scipy.org/doc/numpy/user/basics.rec.html>`__ ndarray
- - Another DataFrame
-
-Along with the data, you can optionally pass **index** (row labels) and
-**columns** (column labels) arguments. If you pass an index and / or columns,
-pyou are guaranteeing the index and / or columns of the resulting
-DataFrame. Thus, a dict of Series plus a specific index will discard all data
-not matching up to the passed index.
-
-If axis labels are not passed, they will be constructed from the input data
-based on common sense rules.
-
-**From dict of Series or dicts**
-
-the result **index** will be the **union** of the indexes of the various
-Series. If there are any nested dicts, these will be first converted to
-Series. If no columns are passed, the columns will be the sorted list of dict
-keys.
-
-.. ipython:: python
-
-    d = {'one' : Series([1., 2., 3.], index=['a', 'b', 'c']),
-         'two' : Series([1., 2., 3., 4.], index=['a', 'b', 'c', 'd'])}
-    df = DataFrame(d)
-    df
-
-    DataFrame(d, index=['d', 'b', 'a'])
-    DataFrame(d, index=['d', 'b', 'a'], columns=['two', 'three'])
-
-The row and column labels can be accessed respectively by accessing the
-**index** and **columns** attributes:
-
-.. note::
-
-   When a particular set of columns is passed along with a dict of data, the
-   passed columns override the keys in the dict.
-
-.. ipython:: python
-
-   df.index
-   df.columns
-
-**From dict of ndarrays / lists**
-
-The ndarrays must all be the same length. If an index is passed, it must
-clearly also be the same length as the arrays. If no index is passed, the
-result will be ``range(n)``, where ``n`` is the array length.
-
-.. ipython:: python
-
-   d = {'one' : [1., 2., 3., 4.],
-        'two' : [4., 3., 2., 1.]}
-   DataFrame(d)
-   DataFrame(d, index=['a', 'b', 'c', 'd'])
-
-**From structured or record array**
-
-This case is handled identically to a dict of arrays.
-
-.. ipython:: python
-
-   data = np.zeros((2,),dtype=[('A', 'i4'),('B', 'f4'),('C', 'a10')])
-   data[:] = [(1,2.,'Hello'),(2,3.,"World")]
-
-   DataFrame(data)
-   DataFrame(data, index=['first', 'second'])
-   DataFrame(data, columns=['C', 'A', 'B'])
-
-.. note::
-
-    DataFrame is not intended to work exactly like a 2-dimensional NumPy
-    ndarray.
-
-Column selection, addition, deletion
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-You can treat a DataFrame semantically like a dict of like-indexed Series
-objects. Getting, setting, and deleting columns works with the same syntax as
-the analogous dict operations:
-
-.. ipython:: python
-
-   df['one']
-   df['three'] = df['one'] * df['two']
-   df['flag'] = df['one'] > 2
-   df
+*****************************
+Essential basic functionality
+*****************************
 
-Columns can be deleted or popped like with a dict:
-
-.. ipython:: python
-
-   del df['two']
-   three = df.pop('three')
-   df
-
-When inserting a scalar value, it will naturally be propagated to fill the
-column:
-
-.. ipython:: python
-
-   df['foo'] = 'bar'
-   df
-
-When inserting a Series that does not have the same index as the DataFrame, it
-will be conformed to the DataFrame's index:
-
-.. ipython:: python
-
-   df['one_trunc'] = df['one'][:2]
-   df
-
-You can insert raw ndarrays but their length must match the length of the
-DataFrame's index.
-
-By default, columns get inserted at the end. The ``insert`` function is
-available to insert at a particular location in the columns:
-
-.. ipython:: python
-
-   df.insert(1, 'bar', df['one'])
-   df
-
-Indexing / Selection
-~~~~~~~~~~~~~~~~~~~~
-The basics of indexing are as follows:
-
-.. csv-table::
-    :header: "Operation", "Syntax", "Result"
-    :widths: 30, 20, 10
-
-    Select column, ``df[col]``, Series
-    Select row by label, ``df.xs(label)`` or ``df.ix[label]``, Series
-    Select row by location (int), ``df.ix[loc]``, Series
-    Slice rows, ``df[5:10]``, DataFrame
-    Select rows by boolean vector, ``df[bool_vec]``, DataFrame
-
-Row selection, for example, returns a Series whose index is the columns of the
-DataFrame:
-
-.. ipython:: python
-
-   df.xs('b')
-   df.ix[2]
-
-Note if a DataFrame contains columns of multiple dtypes, the dtype of the row
-will be chosen to accommodate all of the data types (dtype=object is the most
-general).
-
-For a more exhaustive treatment of more sophisticated label-based indexing and
-slicing, see the :ref:`section on indexing <indexing>`. We will address the
-fundamentals of reindexing / conforming to new sets of lables in the
-:ref:`section on reindexing <basics.reindexing>`.
-
-Data alignment and arithmetic
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Data alignment between DataFrame objects automatically align on **both the
-columns and the index (row labels)**. Again, the resulting object will have the
-union of the column and row labels.
-
-.. ipython:: python
-
-    df = DataFrame(randn(10, 4), columns=['A', 'B', 'C', 'D'])
-    df2 = DataFrame(randn(7, 3), columns=['A', 'B', 'C'])
-    df + df2
-
-When doing an operation between DataFrame and Series, the default behavior is
-to align the Series **index** on the DataFrame **columns**, thus `broadcasting
-<http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html>`__
-row-wise. For example:
-
-.. ipython:: python
-
-   df - df.ix[0]
-
-In the special case of working with time series data, if the Series is a
-TimeSeries (which it will be automatically if the index contains datetime
-objects), and the DataFrame index also contains dates, the broadcasting will be
-column-wise:
+Here we discuss a lot of the essential functionality common to the pandas data
+structures. Here's how to create some of the objects used in the examples from
+the previous section:
 
 .. ipython:: python
 
    index = DateRange('1/1/2000', periods=8)
+   s = Series(randn(5), index=['a', 'b', 'c', 'd', 'e'])
    df = DataFrame(randn(8, 3), index=index,
                   columns=['A', 'B', 'C'])
-   df
-   type(df['A'])
-   df - df['A']
-
-Technical purity aside, this case is so common in practice that supporting the
-special case is preferable to the alternative of forcing the user to transpose
-and do column-based alignment like so:
-
-.. ipython:: python
-
-   (df.T - df['A']).T
-
-For explicit control over the matching and broadcasting behavior, see the
-section on :ref:`flexible binary operations <basics.binop>`.
-
-Operations with scalars are just as you would expect:
-
-.. ipython:: python
-
-   df * 5 + 2
-   1 / df
-   df ** 4
-
-Transposing
-~~~~~~~~~~~
-
-To transpose, access the ``T`` attribute (also the ``transpose`` function),
-similar to an ndarray:
-
-.. ipython:: python
-
-   # only show the first 5 rows
-   df[:5].T
-
-DataFrame interoperability with NumPy functions
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Elementwise NumPy ufuncs (log, exp, sqrt, ...) and various other NumPy functions
-can be used with no issues on DataFrame, assuming the data within are numeric:
-
-.. ipython:: python
-
-   np.exp(df)
-   np.asarray(df)
-
-DataFrame is not intended to be a drop-in replacement for ndarray as its
-indexing semantics are quite different in places from a matrix.
-
-Console display
-~~~~~~~~~~~~~~~
-
-For very large DataFrame objects, only a summary will be printed to the console
-(here I am reading a CSV version of the **baseball** dataset from the **plyr**
-R package):
-
-.. ipython:: python
-
-   baseball = read_csv('baseball.csv')
-   baseball
-
-However, using ``to_string`` will display any DataFrame in tabular form, though
-it won't always fit the console width:
-
-.. ipython:: python
-
-   baseball.ix[-20:, :12].to_string()
-
-.. _basics.panel:
-
-Panel
------
-
-Panel is a somewhat less-used, but still important container for 3-dimensional
-data. The term `panel data <http://en.wikipedia.org/wiki/Panel_data>`__ is
-derived from econometrics and is partially responsible for the name pandas:
-pan(el)-da(ta)-s. The names for the 3 axes are intended to give some semantic
-meaning to describing operations involving panel data and, in particular,
-econometric analysis of panel data. However, for the strict purposes of slicing
-and dicing a collection of DataFrame objects, you may find the axis names
-slightly arbitrary:
-
-  - **items**: axis 0, each item corresponds to a DataFrame contained inside
-  - **major_axis**: axis 1, it is the **index** (rows) of each of the
-    DataFrames
-  - **minor_axis**: axis 2, it is the **columns** of each of the DataFrames
-
-Construction of Panels works about like you would expect:
-
-**3D ndarray with optional axis labels**
-
-.. ipython:: python
-
    wp = Panel(randn(2, 5, 4), items=['Item1', 'Item2'],
               major_axis=DateRange('1/1/2000', periods=5),
               minor_axis=['A', 'B', 'C', 'D'])
-   wp
-
-
-**dict of DataFrame objects**
-
-.. ipython:: python
-
-   data = {'Item1' : DataFrame(randn(4, 3)),
-           'Item2' : DataFrame(randn(4, 2))}
-   Panel(data)
-
-Note that the values in the dict need only be **convertible to
-DataFrame**. Thus, they can be any of the other valid inputs to DataFrame as
-per above.
-
-.. note::
-
-   Unfortunately Panel, being less commonly used than Series and DataFrame,
-   has been slightly neglected feature-wise. A number of methods and options
-   available in DataFrame are not available in Panel. This will get worked
-   on, of course, in future releases. And faster if you join me in working on
-   the codebase.
-
-Item selection / addition / deletion
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Similar to DataFrame functioning as a dict of Series, Panel is like a dict
-of DataFrames:
-
-.. ipython:: python
-
-   wp['Item1']
-   wp['Item3'] = wp['Item1'] / wp['Item2']
-
-The API for insertion and deletion is the same as for DataFrame.
-
-Indexing / Selection
-~~~~~~~~~~~~~~~~~~~~
-
-As of this writing, indexing with Panel is a bit more restrictive than in
-DataFrame. Notably, :ref:`advanced indexing <indexing>` via the **ix** property
-has not yet been integrated in Panel. This will be done, however, in a
-future release.
-
-.. csv-table::
-    :header: "Operation", "Syntax", "Result"
-    :widths: 30, 20, 10
-
-    Select item, ``wp[item]``, DataFrame
-    Get slice at major_axis label, ``wp.major_xs(val)``, DataFrame
-    Get slice at minor_axis label, ``wp.minor_xs(val)``, DataFrame
-
-For example, using the earlier example data, we could do:
-
-.. ipython:: python
-
-    wp['Item1']
-    wp.major_xs(wp.major_axis[2])
-    wp.minor_axis
-    wp.minor_xs('C')
 
 .. _basics.attrs:
 
@@ -579,7 +71,6 @@ unlike the axis labels, cannot be assigned to.
     strings are involved, the result will be of object dtype. If there are only
     floats and integers, the resulting array will be of float dtype.
 
-
 .. _basics.binop:
 
 Flexible binary operations
diff --git a/doc/source/dsintro.rst b/doc/source/dsintro.rst
new file mode 100644
index 000000000..190238492
--- /dev/null
+++ b/doc/source/dsintro.rst
@@ -0,0 +1,536 @@
+.. currentmodule:: pandas
+.. _dsintro:
+
+************************
+Intro to Data Structures
+************************
+
+We'll start with a quick, non-comprehensive overview of the fundamental data
+structures in pandas to get you started. The fundamental behavior about data
+types, indexing, and axis labeling / alignment apply across all of the
+objects. To get started, import numpy and load pandas into your namespace:
+
+.. ipython:: python
+   :suppress:
+
+   import numpy as np
+   from pandas import *
+   randn = np.random.randn
+   np.set_printoptions(precision=4, suppress=True)
+
+.. ipython:: python
+
+   import numpy as np
+   # will use a lot in examples
+   randn = np.random.randn
+   from pandas import *
+
+Here is a basic tenet to keep in mind: **data alignment is intrinsic**. Link
+between labels and data will not be broken unless done so explicitly by you.
+
+We'll give a brief intro to the data structures, then consider all of the broad
+categories of functionality and methods in separate sections.
+
+.. _basics.series:
+
+Series
+------
+
+:class:`Series` is a one-dimensional labeled array (technically a subclass of
+ndarray) capable of holding any data type (integers, strings, floating point
+numbers, Python objects, etc.). The axis labels are collectively referred to as
+the **index**. The basic method to create a Series is to call:
+
+::
+
+    >>> s = Series(data, index=index)
+
+Here, ``data`` can be many different things:
+
+ - a Python dict
+ - an ndarray
+ - a scalar value (like 5)
+
+The passed **index** is a list of axis labels. Thus, this separates into a few
+cases depending on what **data is**:
+
+**From ndarray**
+
+If ``data`` is an ndarray, **index** must be the same length as **data**. If no
+index is passed, one will be created having values ``[0, ..., len(data) - 1]``.
+
+.. ipython:: python
+
+   s = Series(randn(5), index=['a', 'b', 'c', 'd', 'e'])
+   s
+   s.index
+
+   Series(randn(5))
+
+.. note::
+
+    The values in the index must be unique. If they are not, an exception will
+    **not** be raised immediately, but attempting any operation involving the
+    index will later result in an exception. In other words, the Index object
+    containing the labels "lazily" checks whether the values are unique. The
+    reason for being lazy is nearly all performance-based (there are many
+    instances in computations, like parts of GroupBy, where the index is not
+    used).
+
+**From dict**
+
+If ``data`` is a dict, if **index** is passed the values in data corresponding
+to the labels in the index will be pulled out. Otherwise, an index will be
+constructed from the sorted keys of the dict, if possible.
+
+.. ipython:: python
+
+   d = {'a' : 0., 'b' : 1., 'c' : 2.}
+   Series(d)
+   Series(d, index=['b', 'c', 'd', 'a'])
+
+.. note::
+
+    NaN (not a number) is the standard missing data marker used in pandas
+
+**From scalar value** If ``data`` is a scalar value, an index must be
+provided. The value will be repeated to match the length of **index**
+
+.. ipython:: python
+
+   Series(5., index=['a', 'b', 'c', 'd', 'e'])
+
+Series is ndarray-like
+~~~~~~~~~~~~~~~~~~~~~~
+
+As a subclass of ndarray, Series is a valid argument to most NumPy functions
+and behaves similarly to a NumPy array. However, things like slicing also slice
+the index.
+
+.. ipython :: python
+
+    s[0]
+    s[:3]
+    s[s > s.median()]
+    s[[4, 3, 1]]
+    np.exp(s)
+
+We will address array-based indexing in a separate :ref:`section <indexing>`.
+
+Series is dict-like
+~~~~~~~~~~~~~~~~~~~
+
+A Series is alike a fixed-size dict in that you can get and set values by index
+label:
+
+.. ipython :: python
+
+    s['a']
+    s['e'] = 12.
+    s
+    'e' in s
+    'f' in s
+
+If a label is not contained, an exception
+
+.. code-block:: python
+
+    >>> s['f']
+    KeyError: 'f'
+
+    >>> s.get('f')
+    nan
+
+Vectorized operations and label alignment with Series
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+When doing data analysis, as with raw NumPy arrays looping through Series
+value-by-value is usually not necessary. Series can be also be passed into most
+NumPy methods expecting an ndarray.
+
+
+.. ipython:: python
+
+    s + s
+    s * 2
+    np.exp(s)
+
+A key difference between Series and ndarray is that operations between Series
+automatically align the data based on label. Thus, you can write computations
+without giving consideration to whether the Series involved have the same
+labels.
+
+.. ipython:: python
+
+    s[1:] + s[:-1]
+
+The result of an operation between unaligned Series will have the **union** of
+the indexes involved. If a label is not found in one Series or the other, the
+result will be marked as missing (NaN). Being able to write code without doing
+any explicit data alignment grants immense freedom and flexibility in
+interactive data analysis and research. The integrated data alignment features
+of the pandas data structures set pandas apart from the majority of related
+tools for working with labeled data.
+
+.. note::
+
+    In general, we chose to make the default result of operations between
+    differently indexed objects yield the **union** of the indexes in order to
+    avoid loss of information. Having an index label, though the data is
+    missing, is typically important information as part of a computation. You
+    of course have the option of dropping labels with missing data via the
+    **dropna** function.
+
+.. _basics.dataframe:
+
+DataFrame
+---------
+
+**DataFrame** is a 2-dimensional labeled data structure with columns of
+potentially different types. You can think of it like a spreadsheet or SQL
+table, or a dict of Series objects. It is generally the most commonly used
+pandas object. Like Series, DataFrame accepts many different kinds of input:
+
+ - Dict of 1D ndarrays, lists, dicts, or Series
+ - 2-D numpy.ndarray
+ - `Structured or record
+   <http://docs.scipy.org/doc/numpy/user/basics.rec.html>`__ ndarray
+ - Another DataFrame
+
+Along with the data, you can optionally pass **index** (row labels) and
+**columns** (column labels) arguments. If you pass an index and / or columns,
+pyou are guaranteeing the index and / or columns of the resulting
+DataFrame. Thus, a dict of Series plus a specific index will discard all data
+not matching up to the passed index.
+
+If axis labels are not passed, they will be constructed from the input data
+based on common sense rules.
+
+**From dict of Series or dicts**
+
+the result **index** will be the **union** of the indexes of the various
+Series. If there are any nested dicts, these will be first converted to
+Series. If no columns are passed, the columns will be the sorted list of dict
+keys.
+
+.. ipython:: python
+
+    d = {'one' : Series([1., 2., 3.], index=['a', 'b', 'c']),
+         'two' : Series([1., 2., 3., 4.], index=['a', 'b', 'c', 'd'])}
+    df = DataFrame(d)
+    df
+
+    DataFrame(d, index=['d', 'b', 'a'])
+    DataFrame(d, index=['d', 'b', 'a'], columns=['two', 'three'])
+
+The row and column labels can be accessed respectively by accessing the
+**index** and **columns** attributes:
+
+.. note::
+
+   When a particular set of columns is passed along with a dict of data, the
+   passed columns override the keys in the dict.
+
+.. ipython:: python
+
+   df.index
+   df.columns
+
+**From dict of ndarrays / lists**
+
+The ndarrays must all be the same length. If an index is passed, it must
+clearly also be the same length as the arrays. If no index is passed, the
+result will be ``range(n)``, where ``n`` is the array length.
+
+.. ipython:: python
+
+   d = {'one' : [1., 2., 3., 4.],
+        'two' : [4., 3., 2., 1.]}
+   DataFrame(d)
+   DataFrame(d, index=['a', 'b', 'c', 'd'])
+
+**From structured or record array**
+
+This case is handled identically to a dict of arrays.
+
+.. ipython:: python
+
+   data = np.zeros((2,),dtype=[('A', 'i4'),('B', 'f4'),('C', 'a10')])
+   data[:] = [(1,2.,'Hello'),(2,3.,"World")]
+
+   DataFrame(data)
+   DataFrame(data, index=['first', 'second'])
+   DataFrame(data, columns=['C', 'A', 'B'])
+
+.. note::
+
+    DataFrame is not intended to work exactly like a 2-dimensional NumPy
+    ndarray.
+
+Column selection, addition, deletion
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+You can treat a DataFrame semantically like a dict of like-indexed Series
+objects. Getting, setting, and deleting columns works with the same syntax as
+the analogous dict operations:
+
+.. ipython:: python
+
+   df['one']
+   df['three'] = df['one'] * df['two']
+   df['flag'] = df['one'] > 2
+   df
+
+Columns can be deleted or popped like with a dict:
+
+.. ipython:: python
+
+   del df['two']
+   three = df.pop('three')
+   df
+
+When inserting a scalar value, it will naturally be propagated to fill the
+column:
+
+.. ipython:: python
+
+   df['foo'] = 'bar'
+   df
+
+When inserting a Series that does not have the same index as the DataFrame, it
+will be conformed to the DataFrame's index:
+
+.. ipython:: python
+
+   df['one_trunc'] = df['one'][:2]
+   df
+
+You can insert raw ndarrays but their length must match the length of the
+DataFrame's index.
+
+By default, columns get inserted at the end. The ``insert`` function is
+available to insert at a particular location in the columns:
+
+.. ipython:: python
+
+   df.insert(1, 'bar', df['one'])
+   df
+
+Indexing / Selection
+~~~~~~~~~~~~~~~~~~~~
+The basics of indexing are as follows:
+
+.. csv-table::
+    :header: "Operation", "Syntax", "Result"
+    :widths: 30, 20, 10
+
+    Select column, ``df[col]``, Series
+    Select row by label, ``df.xs(label)`` or ``df.ix[label]``, Series
+    Select row by location (int), ``df.ix[loc]``, Series
+    Slice rows, ``df[5:10]``, DataFrame
+    Select rows by boolean vector, ``df[bool_vec]``, DataFrame
+
+Row selection, for example, returns a Series whose index is the columns of the
+DataFrame:
+
+.. ipython:: python
+
+   df.xs('b')
+   df.ix[2]
+
+Note if a DataFrame contains columns of multiple dtypes, the dtype of the row
+will be chosen to accommodate all of the data types (dtype=object is the most
+general).
+
+For a more exhaustive treatment of more sophisticated label-based indexing and
+slicing, see the :ref:`section on indexing <indexing>`. We will address the
+fundamentals of reindexing / conforming to new sets of lables in the
+:ref:`section on reindexing <basics.reindexing>`.
+
+Data alignment and arithmetic
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Data alignment between DataFrame objects automatically align on **both the
+columns and the index (row labels)**. Again, the resulting object will have the
+union of the column and row labels.
+
+.. ipython:: python
+
+    df = DataFrame(randn(10, 4), columns=['A', 'B', 'C', 'D'])
+    df2 = DataFrame(randn(7, 3), columns=['A', 'B', 'C'])
+    df + df2
+
+When doing an operation between DataFrame and Series, the default behavior is
+to align the Series **index** on the DataFrame **columns**, thus `broadcasting
+<http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html>`__
+row-wise. For example:
+
+.. ipython:: python
+
+   df - df.ix[0]
+
+In the special case of working with time series data, if the Series is a
+TimeSeries (which it will be automatically if the index contains datetime
+objects), and the DataFrame index also contains dates, the broadcasting will be
+column-wise:
+
+.. ipython:: python
+
+   index = DateRange('1/1/2000', periods=8)
+   df = DataFrame(randn(8, 3), index=index,
+                  columns=['A', 'B', 'C'])
+   df
+   type(df['A'])
+   df - df['A']
+
+Technical purity aside, this case is so common in practice that supporting the
+special case is preferable to the alternative of forcing the user to transpose
+and do column-based alignment like so:
+
+.. ipython:: python
+
+   (df.T - df['A']).T
+
+For explicit control over the matching and broadcasting behavior, see the
+section on :ref:`flexible binary operations <basics.binop>`.
+
+Operations with scalars are just as you would expect:
+
+.. ipython:: python
+
+   df * 5 + 2
+   1 / df
+   df ** 4
+
+Transposing
+~~~~~~~~~~~
+
+To transpose, access the ``T`` attribute (also the ``transpose`` function),
+similar to an ndarray:
+
+.. ipython:: python
+
+   # only show the first 5 rows
+   df[:5].T
+
+DataFrame interoperability with NumPy functions
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Elementwise NumPy ufuncs (log, exp, sqrt, ...) and various other NumPy functions
+can be used with no issues on DataFrame, assuming the data within are numeric:
+
+.. ipython:: python
+
+   np.exp(df)
+   np.asarray(df)
+
+DataFrame is not intended to be a drop-in replacement for ndarray as its
+indexing semantics are quite different in places from a matrix.
+
+Console display
+~~~~~~~~~~~~~~~
+
+For very large DataFrame objects, only a summary will be printed to the console
+(here I am reading a CSV version of the **baseball** dataset from the **plyr**
+R package):
+
+.. ipython:: python
+
+   baseball = read_csv('baseball.csv')
+   baseball
+
+However, using ``to_string`` will display any DataFrame in tabular form, though
+it won't always fit the console width:
+
+.. ipython:: python
+
+   baseball.ix[-20:, :12].to_string()
+
+.. _basics.panel:
+
+Panel
+-----
+
+Panel is a somewhat less-used, but still important container for 3-dimensional
+data. The term `panel data <http://en.wikipedia.org/wiki/Panel_data>`__ is
+derived from econometrics and is partially responsible for the name pandas:
+pan(el)-da(ta)-s. The names for the 3 axes are intended to give some semantic
+meaning to describing operations involving panel data and, in particular,
+econometric analysis of panel data. However, for the strict purposes of slicing
+and dicing a collection of DataFrame objects, you may find the axis names
+slightly arbitrary:
+
+  - **items**: axis 0, each item corresponds to a DataFrame contained inside
+  - **major_axis**: axis 1, it is the **index** (rows) of each of the
+    DataFrames
+  - **minor_axis**: axis 2, it is the **columns** of each of the DataFrames
+
+Construction of Panels works about like you would expect:
+
+**3D ndarray with optional axis labels**
+
+.. ipython:: python
+
+   wp = Panel(randn(2, 5, 4), items=['Item1', 'Item2'],
+              major_axis=DateRange('1/1/2000', periods=5),
+              minor_axis=['A', 'B', 'C', 'D'])
+   wp
+
+
+**dict of DataFrame objects**
+
+.. ipython:: python
+
+   data = {'Item1' : DataFrame(randn(4, 3)),
+           'Item2' : DataFrame(randn(4, 2))}
+   Panel(data)
+
+Note that the values in the dict need only be **convertible to
+DataFrame**. Thus, they can be any of the other valid inputs to DataFrame as
+per above.
+
+.. note::
+
+   Unfortunately Panel, being less commonly used than Series and DataFrame,
+   has been slightly neglected feature-wise. A number of methods and options
+   available in DataFrame are not available in Panel. This will get worked
+   on, of course, in future releases. And faster if you join me in working on
+   the codebase.
+
+Item selection / addition / deletion
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Similar to DataFrame functioning as a dict of Series, Panel is like a dict
+of DataFrames:
+
+.. ipython:: python
+
+   wp['Item1']
+   wp['Item3'] = wp['Item1'] / wp['Item2']
+
+The API for insertion and deletion is the same as for DataFrame.
+
+Indexing / Selection
+~~~~~~~~~~~~~~~~~~~~
+
+As of this writing, indexing with Panel is a bit more restrictive than in
+DataFrame. Notably, :ref:`advanced indexing <indexing>` via the **ix** property
+has not yet been integrated in Panel. This will be done, however, in a
+future release.
+
+.. csv-table::
+    :header: "Operation", "Syntax", "Result"
+    :widths: 30, 20, 10
+
+    Select item, ``wp[item]``, DataFrame
+    Get slice at major_axis label, ``wp.major_xs(val)``, DataFrame
+    Get slice at minor_axis label, ``wp.minor_xs(val)``, DataFrame
+
+For example, using the earlier example data, we could do:
+
+.. ipython:: python
+
+    wp['Item1']
+    wp.major_xs(wp.major_axis[2])
+    wp.minor_axis
+    wp.minor_xs('C')
diff --git a/doc/source/index.rst b/doc/source/index.rst
index c05a23064..64d1cde50 100755
--- a/doc/source/index.rst
+++ b/doc/source/index.rst
@@ -107,11 +107,12 @@ See the package overview for more detail about what's in the library.
 
 .. toctree::
     :hidden:
-    :maxdepth: 2
+    :maxdepth: 3
 
     install
     faq
     overview
+    dsintro
     basics
     indexing
     missing_data
diff --git a/doc/source/missing_data.rst b/doc/source/missing_data.rst
index 184350a49..c4df50b16 100644
--- a/doc/source/missing_data.rst
+++ b/doc/source/missing_data.rst
@@ -215,6 +215,8 @@ for interpolation methods outside of the filling methods described above.
    @savefig series_interpolate.png width=6in
    axes[1].set_title('Interpolated')
 
+   plt.close('all')
+
 Missing data casting rules and indexing
 ---------------------------------------
 
diff --git a/doc/source/stats.rst b/doc/source/stats.rst
index cce96a3bd..e1caa6138 100755
--- a/doc/source/stats.rst
+++ b/doc/source/stats.rst
@@ -2,6 +2,17 @@
 
 .. _stats:
 
+.. ipython:: python
+   :suppress:
+
+   import numpy as np
+   np.random.seed(123456)
+   from pandas import *
+   import pandas.util.testing as tm
+   randn = np.random.randn
+   np.set_printoptions(precision=4, suppress=True)
+   import matplotlib.pyplot as plt
+
 **********************************
 Built-in statistical functionality
 **********************************
@@ -15,129 +26,78 @@ Built-in statistical functionality
 Moving (rolling) statistics / moments
 -------------------------------------
 
-For working with time series data, a number of functions are provided
-for computing common *moving* or *rolling* statistics. Among these are
-count, sum, mean, median, correlation, variance, covariance, standard
-deviation, skewness, and kurtosis. All of these methods are in the
-:mod:`pandas` namespace, but otherwise they can be found in
-:mod:`pandas.stats.moments`.
-
-Each of these methods observes the same interface (with relevant
-methods accepting two Series arguments instead of one):
-
-.. function:: Unary moment functions
-
-   :Parameters:
-       **arg** : ndarray, Series, DataFrame, etc.
-	       If a DataFrame is passed, function will be applied to **columns**
-
-       **window** : int
-           Number of periods to include in window
-
-       **min_periods** : int or None
-	       Number of periods to require to compute a value (defaults to
-	       **window**)
-
-       **time_rule** : string or DateOffset
-            Frequency to pre-convert data to
-
-.. function:: Binary moment functions
-
-   :Parameters:
-       **arg1** : ndarray, Series
-	       If a DataFrame is passed, function will be applied to **columns**
-
-       **arg2** : ndarray, Series
-	       Must be same type as **arg1**
-
-       **window** : int
-           Number of periods to include in window
-
-       **min_periods** : int or None
-	       Number of periods to require to compute a value (defaults to
-	       **window**)
-
-       **time_rule** : string or DateOffset
-            Frequency to pre-convert data to
-
-::
-
-    >>> ts
-    2000-01-31 00:00:00    -0.550139282247
-    2000-02-01 00:00:00    0.0950636484432
-    2000-02-02 00:00:00    0.0621763420914
-    2000-02-03 00:00:00    0.125698607137
-    2000-02-04 00:00:00    0.222288320816
-    2000-02-07 00:00:00    0.903314747152
-    2000-02-08 00:00:00    -0.391449402196
-    2000-02-09 00:00:00    -0.726137553115
-    2000-02-10 00:00:00    -0.89302167539
-    2000-02-11 00:00:00    0.228509179513
-
-    >>> rolling_sum(ts, 5, min_periods=3)
-    2000-01-31 00:00:00    NaN
-    2000-02-01 00:00:00    NaN
-    2000-02-02 00:00:00    -0.0913037710365
-    2000-02-03 00:00:00    0.798752592168
-    2000-02-04 00:00:00    1.39432346651
-    2000-02-07 00:00:00    2.44074916551
-    2000-02-08 00:00:00    2.77458564938
-    2000-02-09 00:00:00    1.87181399193
-    2000-02-10 00:00:00    2.48549563273
-    2000-02-11 00:00:00    1.81285272663
-
-If passing a DataFrame argument, the statistics will be applied independently to
-the columns:
-
-::
-
-    >>> df
-			   A              B              C              D
-    2000-01-31 00:00:00    NaN            NaN            0.03752        -0.3952
-    2000-02-01 00:00:00    NaN            NaN            -1.511         -0.1126
-    2000-02-02 00:00:00    1.136          NaN            0.777          -0.3502
-    2000-02-03 00:00:00    0.8901         NaN            1.196          0.7456
-    2000-02-04 00:00:00    0.5956         0.7684         0.9042         0.4984
-    2000-02-07 00:00:00    -0.3502        1.015          0.5366         0.6628
-    2000-02-08 00:00:00    0.5036         1.825          0.8682         -1.69
-    2000-02-09 00:00:00    0.2327         -0.3899        0.4493         -0.1267
-    2000-02-10 00:00:00    1.504          0.3904         -0.06148       1.717
-    2000-02-11 00:00:00    -0.07707       0.2286         -1.039         0.1438
-
-    >>> rolling_mean(df, 5, min_periods=3)
-			   A              B              C              D
-    2000-01-31 00:00:00    NaN            NaN            NaN            NaN
-    2000-02-01 00:00:00    NaN            NaN            NaN            NaN
-    2000-02-02 00:00:00    NaN            NaN            -0.2321        -0.286
-    2000-02-03 00:00:00    NaN            NaN            0.125          -0.02811
-    2000-02-04 00:00:00    0.8737         NaN            0.2809         0.07718
-    2000-02-07 00:00:00    0.5677         NaN            0.3807         0.2888
-    2000-02-08 00:00:00    0.5549         1.203          0.8565         -0.0267
-    2000-02-09 00:00:00    0.3744         0.8047         0.7909         0.018
-    2000-02-10 00:00:00    0.4971         0.7219         0.5394         0.2123
-    2000-02-11 00:00:00    0.3626         0.6139         0.1507         0.1414
-
-Each of these methods can optionally accept a **time_rule** argument
-(see :ref:`time rules <datetools.timerules>`) which is provided as a
-convenience when the user wishes to guarantee that the window of the
-statistic.
-
-Here are some plots of the unary moment functions:
-
-.. plot:: plots/stats/moments_rolling.py
-
-And the binary moment functions:
-
-.. plot:: plots/stats/moments_rolling_binary.py
+For working with time series data, a number of functions are provided for
+computing common *moving* or *rolling* statistics. Among these are count, sum,
+mean, median, correlation, variance, covariance, standard deviation, skewness,
+and kurtosis. All of these methods are in the :mod:`pandas` namespace, but
+otherwise they can be found in :mod:`pandas.stats.moments`.
+
+.. csv-table::
+    :header: "Function", "Description"
+    :widths: 20, 80
+
+    ``rolling_count``, Number of non-null observations
+    ``rolling_sum``, Sum of values
+    ``rolling_mean``, Mean of values
+    ``rolling_median``, Arithmetic median of values
+    ``rolling_min``, Minimum
+    ``rolling_max``, Maximum
+    ``rolling_std``, Unbiased standard deviation
+    ``rolling_var``, Unbiased variance
+    ``rolling_skew``, Unbiased skewness (3rd moment)
+    ``rolling_kurt``, Unbiased kurtosis (4th moment)
+    ``rolling_quantile``, Sample quantile (value at %)
+    ``rolling_apply``, Generic apply
+    ``rolling_cov``, Unbiased covariance (binary)
+    ``rolling_corr``, Correlation (binary)
+
+Generally these methods all have the same interface. The binary operators
+(e.g. ``rolling_corr``) take two Series or DataFrames. Otherwise, they all
+accept the following arguments:
+
+  - ``window``: size of moving window
+  - ``min_periods``: threshold of non-null data points to require (otherwise
+    result is NA)
+  - ``time_rule``: optionally specify a :ref:`time rule <timeseries.timerule>`
+    to pre-conform the data to
+
+These functions can be applied to ndarrays or Series objects:
+
+.. ipython:: python
+
+   ts = Series(randn(1000), index=DateRange('1/1/2000', periods=1000))
+   ts = ts.cumsum()
+
+   ts.plot(style='k--')
+
+   @savefig rolling_mean_ex.png width=4.5in
+   rolling_mean(ts, 60).plot(style='k')
+
+They can also be applied to DataFrame objects. This is really just syntactic
+sugar for applying the moving window operator to all of the DataFrame's columns:
+
+.. ipython:: python
+   :suppress:
+
+   plt.close('all')
+
+.. ipython:: python
+
+   df = DataFrame(randn(1000, 4), index=ts.index,
+                  columns=['A', 'B', 'C', 'D'])
+   df = df.cumsum()
+
+   @savefig rolling_mean_frame.png width=4.5in
+   rolling_sum(df, 60).plot(subplots=True)
 
 Exponentially weighted moment functions
 ---------------------------------------
 
-It's also quite common to want to do non-equally weighted moving statistics,
-such as exponentially weighted (EW) moving average or EW moving standard
-deviation. A number of EW functions are provided using the blending method. For
-example, where :math:`y_t` is the result and :math:`x_t` the input, we compute
-an exponentially weighted moving average as
+A related set of functions are exponentially weighted versions of many of the
+above statistics. A number of EW (exponentially weighted) functions are
+provided using the blending method. For example, where :math:`y_t` is the
+result and :math:`x_t` the input, we compute an exponentially weighted moving
+average as
 
 .. math::
 
@@ -158,22 +118,86 @@ directly, it's easier to think about either the **span** or **center of mass
 You can pass one or the other to these functions but not both. **Span**
 corresponds to what is commonly called a "20-day EW moving average" for
 example. **Center of mass** has a more physical interpretation. For example,
-**span** = 20 corresponds to **com** = 9.5.
+**span** = 20 corresponds to **com** = 9.5. Here is the list of functions
+available:
+
+.. csv-table::
+    :header: "Function", "Description"
+    :widths: 20, 80
 
-Here are some examples for a univariate time series:
+    ``ewma``, EW moving average
+    ``ewvar``, EW moving variance
+    ``ewstd``, EW moving standard deviation
+    ``ewmcorr``, EW moving correlation
+    ``ewmcov``, EW moving covariance
 
-.. plot:: plots/stats/moments_expw.py
+Here are an example for a univariate time series:
 
-The binary `emwcov` and `ewmcorr` are similar to their equal-weighted
-counterparts above.
+.. ipython:: python
 
-.. autofunction:: pandas.stats.moments.ewma
+   plt.close('all')
+   ts.plot(style='k--')
 
+   @savefig ewma_ex.png width=4.5in
+   ewma(ts, span=20).plot(style='k')
 
 .. _stats.ols:
 
 Linear and panel regression
 ---------------------------
 
-.. automodule:: pandas.stats.interface
-   :members:
+.. note::
+
+   We plan to move this functionality to `statsmodels
+   <http://statsmodels.sourceforge.net>`__ for the next release. Some of the
+   result attributes may change names in order to foster naming consistency
+   with the rest of statsmodels. We will provide every effort to provide
+   compatibility with older versions of pandas, however.
+
+We have implemented a very fast set of *moving-window linear regression*
+classes in pandas. Two different types of regressions are supported:
+
+  - Standard ordinary least squares (OLS) multiple regression
+  - Multiple regression (OLS-based) on `panel data
+    <http://en.wikipedia.org/wiki/Panel_data>`__ including with fixed-effects
+    (also known as entity or individual effects) or time-effects.
+
+Both kinds of linear models are accessed through the ``ols`` function in the
+pandas namespace. They all take the following arguments to specify either a
+static (full sample) or dynamic (moving window) regression:
+
+  - ``window_type``: ``'full sample'`` (default), ``'expanding'``, or
+    ``rolling``
+  - ``window``: size of the moving window in the ``window_type='rolling'``
+    case. If ``window`` is specified, ``window_type`` will be automatically set
+    to ``'rolling'``
+  - ``min_periods``: minimum number of time periods to require to compute the
+    regression coefficients
+
+Generally speaking, the ``ols`` works by being given a ``y`` (response) object
+and an ``x`` (predictors) object. These can take many forms:
+
+  - ``y``: a Series, ndarray, or DataFrame (panel model)
+  - ``x``: Series, DataFrame, dict of Series, dict of DataFrame, Panel,
+    LongPanel
+
+Based on the types of ``y`` and ``x``, the model will be inferred to either a
+panel model or a regular linear model. If the ``y`` variable is a DataFrame,
+the result will be a panel model. In this case, the ``x`` variable must either
+be a Panel, LongPanel, or a dict of DataFrame (which will be coerced into a
+Panel).
+
+Standard OLS regression
+~~~~~~~~~~~~~~~~~~~~~~~
+
+Let's create some sample
+
+.. ipython:: python
+
+
+Panel regression
+~~~~~~~~~~~~~~~~
+
+We've implemented moving window panel regression on potentially unbalanced
+panel data (see the linked Wikipedia article above if this means nothing to
+you).
diff --git a/doc/source/timeseries.rst b/doc/source/timeseries.rst
index ac9581c03..7c9038ce1 100644
--- a/doc/source/timeseries.rst
+++ b/doc/source/timeseries.rst
@@ -324,7 +324,7 @@ Here is a fully-worked example:
    grouped = ts.groupby(hourly.asof)
    grouped.mean()
 
-Some things to note:
+Some things to note about this method:
 
   - This is rather inefficient because we haven't exploited the orderedness of
     the data at all. Calling the ``asof`` function on every date in the
diff --git a/doc/source/visualization.rst b/doc/source/visualization.rst
index d519a6599..c17165b00 100644
--- a/doc/source/visualization.rst
+++ b/doc/source/visualization.rst
@@ -1,7 +1,117 @@
 .. currentmodule:: pandas
 .. _visualization:
 
+.. ipython:: python
+   :suppress:
+
+   import numpy as np
+   np.random.seed(123456)
+   from pandas import *
+   import pandas.util.testing as tm
+   randn = np.random.randn
+   np.set_printoptions(precision=4, suppress=True)
+
 ************************
 Plotting with matplotlib
 ************************
 
+.. note::
+
+    We intend to build more plotting integration with :ref:`matplotlib
+    <http://matplotlib.sourceforge.net>` as time goes on.
+
+We use the standard convention for referencing the matplotlib API:
+
+.. ipython:: python
+
+   import matplotlib.pyplot as plt
+
+Basic plotting: ``plot``
+------------------------
+
+The ``plot`` method on Series and DataFrame is just a simple wrapper around
+``plt.plot``:
+
+.. ipython:: python
+
+   ts = Series(randn(1000), index=DateRange('1/1/2000', periods=1000))
+   ts = ts.cumsum()
+
+   @savefig series_plot_basic.png width=4.5in
+   ts.plot()
+
+If the index consists of dates, it calls ``gca().autofmt_xdate()`` to try to
+format the x-axis nicely as per above. THe method takes a number of arguments
+for controlling the look of the plot:
+
+.. ipython:: python
+
+   @savefig series_plot_basic2.png width=4.5in
+   plt.figure(); ts.plot(style='k--', label='Series'); plt.legend()
+
+On DataFrame, ``plot`` is a convenience to plot all of the columns with labels:
+
+.. ipython:: python
+
+   df = DataFrame(randn(1000, 4), index=ts.index,
+                  columns=['A', 'B', 'C', 'D'])
+   df = df.cumsum()
+
+   @savefig frame_plot_basic.png width=4.5in
+   plt.figure(); df.plot(); plt.legend(loc='best')
+
+Some other options are available, like plotting each Series on a different axis:
+
+.. ipython:: python
+
+   @savefig frame_plot_subplots.png width=4.5in
+   df.plot(subplots=True, figsize=(8, 8)); plt.legend(loc='best')
+
+Targeting different subplots
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+You can pass an ``ax`` argument to ``Series.plot`` to plot on a particular axis:
+
+.. ipython:: python
+
+   fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(8, 5))
+   df['A'].plot(ax=axes[0][0]); axes[0][0].set_title('A')
+   df['B'].plot(ax=axes[0][1]); axes[0][1].set_title('B')
+   df['C'].plot(ax=axes[1][0]); axes[1][0].set_title('C')
+
+   @savefig series_plot_multi.png width=4.5in
+   df['D'].plot(ax=axes[1][1]); axes[1][1].set_title('D')
+
+Other plotting features
+-----------------------
+
+Plotting non-time series data
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+For labeled, non-time series data, you may wish to produce a bar plot:
+
+.. ipython:: python
+
+   plt.figure();
+
+   @savefig bar_plot_ex.png width=4.5in
+   df.ix[5].plot(kind='bar'); plt.axhline(0, color='k')
+
+Histogramming
+~~~~~~~~~~~~~
+.. ipython:: python
+
+   plt.figure();
+
+   @savefig hist_plot_ex.png width=4.5in
+   df['A'].diff().hist()
+
+For a DataFrame, ``hist`` plots the histograms of the columns on multiple
+subplots:
+
+.. ipython:: python
+
+   plt.figure()
+
+   @savefig frame_hist_ex.png width=4.5in
+   df.diff().hist(color='k', alpha=0.5, bins=50)
diff --git a/doc/sphinxext/ipython_directive.py b/doc/sphinxext/ipython_directive.py
index 85b199f40..2f60b1733 100644
--- a/doc/sphinxext/ipython_directive.py
+++ b/doc/sphinxext/ipython_directive.py
@@ -396,7 +396,8 @@ class EmbeddedSphinxShell(object):
         Saves the image file to disk.
         """
         self.ensure_pyplot()
-        command = 'plt.gcf().savefig("%s", bbox_inches="tight", dpi=150)'%image_file
+        command = ('plt.gcf().savefig("%s", bbox_inches="tight", '
+                   'dpi=100)' % image_file)
         #print 'SAVEFIG', command  # dbg
         self.process_input_line('bookmark ipy_thisdir', store_history=False)
         self.process_input_line('cd -b ipy_savedir', store_history=False)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 04ab47ebe..3db69760d 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2646,8 +2646,8 @@ class DataFrame(NDFrame):
     #----------------------------------------------------------------------
     # Plotting
 
-    def plot(self, subplots=False, sharex=True,
-             sharey=False, use_index=True, **kwds):  # pragma: no cover
+    def plot(self, subplots=False, sharex=True, sharey=False, use_index=True,
+             figsize=None, grid=True, **kwds):  # pragma: no cover
         """
         Make line plot of DataFrame's series with the index on the x-axis using
         matplotlib / pylab.
@@ -2674,9 +2674,10 @@ class DataFrame(NDFrame):
 
         if subplots:
             _, axes = plt.subplots(nrows=len(self.columns),
-                                   sharex=sharex, sharey=sharey)
+                                   sharex=sharex, sharey=sharey,
+                                   figsize=figsize)
         else:
-            fig = plt.figure()
+            fig = plt.figure(figsize=figsize)
             ax = fig.add_subplot(111)
 
         if use_index:
@@ -2692,7 +2693,18 @@ class DataFrame(NDFrame):
             else:
                 ax.plot(x, self[col].values, label=col, **kwds)
 
-    def hist(self, **kwds):  # pragma: no cover
+            ax.grid(grid)
+
+        # try to make things prettier
+        try:
+            fig = plt.gcf()
+            fig.autofmt_xdate()
+        except Exception:
+            pass
+
+        plt.draw_if_interactive()
+
+    def hist(self, grid=True, **kwds):  # pragma: no cover
         """
         Draw Histogram the DataFrame's series using matplotlib / pylab.
 
@@ -2711,8 +2723,9 @@ class DataFrame(NDFrame):
 
         for i, col in enumerate(_try_sort(self.columns)):
             ax = axes[i / k][i % k]
-            ax.hist(self[col].values, **kwds)
+            ax.hist(self[col].dropna().values, **kwds)
             ax.set_title(col)
+            ax.grid(grid)
 
     #----------------------------------------------------------------------
     # Deprecated stuff
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 98c2bedab..45ba7ff0d 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1335,7 +1335,7 @@ copy : boolean, default False
 # Miscellaneous
 
     def plot(self, label=None, kind='line', use_index=True, rot=30, ax=None,
-             style='-', **kwds):  # pragma: no cover
+             style='-', grid=True, **kwds):  # pragma: no cover
         """
         Plot the input series with the index on the x-axis using matplotlib
 
@@ -1390,6 +1390,8 @@ copy : boolean, default False
             ax.set_xticks(xinds + 0.25)
             ax.set_xticklabels(self.index, rotation=rot, fontsize=fontsize)
 
+        ax.grid(grid)
+
         # try to make things prettier
         try:
             fig = plt.gcf()
@@ -1399,7 +1401,7 @@ copy : boolean, default False
 
         plt.draw_if_interactive()
 
-    def hist(self, ax=None, **kwds):  # pragma: no cover
+    def hist(self, ax=None, grid=True, **kwds):  # pragma: no cover
         """
         Draw histogram of the input series using matplotlib
 
@@ -1420,7 +1422,10 @@ copy : boolean, default False
         if ax is None:
             ax = plt.gca()
 
-        ax.hist(self.values)
+        values = self.dropna().values
+
+        ax.hist(values)
+        ax.grid(grid)
 
     def to_csv(self, path):
         """

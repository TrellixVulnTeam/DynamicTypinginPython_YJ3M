commit 32f572f9a58abec83214d6c2ae9c87d10f1cb7e3
Author: ganevgv <ganevgv@users.noreply.github.com>
Date:   Sat Dec 7 16:31:52 2019 +0000

    CLN: f-string in pandas/core/accessor.py and pandas/core/algorithms.py (#30120)

diff --git a/pandas/core/accessor.py b/pandas/core/accessor.py
index 963c9c65c..da4566937 100644
--- a/pandas/core/accessor.py
+++ b/pandas/core/accessor.py
@@ -49,13 +49,13 @@ class PandasDelegate:
     """
 
     def _delegate_property_get(self, name, *args, **kwargs):
-        raise TypeError("You cannot access the property {name}".format(name=name))
+        raise TypeError(f"You cannot access the property {name}")
 
     def _delegate_property_set(self, name, value, *args, **kwargs):
-        raise TypeError("The property {name} cannot be set".format(name=name))
+        raise TypeError(f"The property {name} cannot be set")
 
     def _delegate_method(self, name, *args, **kwargs):
-        raise TypeError("You cannot call method {name}".format(name=name))
+        raise TypeError(f"You cannot call method {name}")
 
     @classmethod
     def _add_delegate_accessors(
diff --git a/pandas/core/algorithms.py b/pandas/core/algorithms.py
index 75d2bfc24..6ccd71a56 100644
--- a/pandas/core/algorithms.py
+++ b/pandas/core/algorithms.py
@@ -395,16 +395,12 @@ def isin(comps, values) -> np.ndarray:
     if not is_list_like(comps):
         raise TypeError(
             "only list-like objects are allowed to be passed"
-            " to isin(), you passed a [{comps_type}]".format(
-                comps_type=type(comps).__name__
-            )
+            f" to isin(), you passed a [{type(comps).__name__}]"
         )
     if not is_list_like(values):
         raise TypeError(
             "only list-like objects are allowed to be passed"
-            " to isin(), you passed a [{values_type}]".format(
-                values_type=type(values).__name__
-            )
+            f" to isin(), you passed a [{type(values).__name__}]"
         )
 
     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):
@@ -601,7 +597,7 @@ _shared_docs[
 )
 @Appender(_shared_docs["factorize"])
 def factorize(
-    values, sort: bool = False, na_sentinel: int = -1, size_hint: Optional[int] = None,
+    values, sort: bool = False, na_sentinel: int = -1, size_hint: Optional[int] = None
 ) -> Tuple[np.ndarray, Union[np.ndarray, ABCIndex]]:
     # Implementation notes: This method is responsible for 3 things
     # 1.) coercing data to array-like (ndarray, Index, extension array)
@@ -758,7 +754,7 @@ def _value_counts_arraylike(values, dropna: bool):
         # ndarray like
 
         # TODO: handle uint8
-        f = getattr(htable, "value_count_{dtype}".format(dtype=ndtype))
+        f = getattr(htable, f"value_count_{ndtype}")
         keys, counts = f(values, dropna)
 
         mask = isna(values)
@@ -794,7 +790,7 @@ def duplicated(values, keep="first") -> np.ndarray:
 
     values, _ = _ensure_data(values)
     ndtype = values.dtype.name
-    f = getattr(htable, "duplicated_{dtype}".format(dtype=ndtype))
+    f = getattr(htable, f"duplicated_{ndtype}")
     return f(values, keep=keep)
 
 
@@ -833,12 +829,12 @@ def mode(values, dropna: bool = True) -> ABCSeries:
     values, _ = _ensure_data(values)
     ndtype = values.dtype.name
 
-    f = getattr(htable, "mode_{dtype}".format(dtype=ndtype))
+    f = getattr(htable, f"mode_{ndtype}")
     result = f(values, dropna=dropna)
     try:
         result = np.sort(result)
     except TypeError as e:
-        warn("Unable to sort modes: {error}".format(error=e))
+        warn(f"Unable to sort modes: {e}")
 
     result = _reconstruct_data(result, original.dtype, original)
     return Series(result)
@@ -1110,10 +1106,7 @@ class SelectNSeries(SelectN):
         n = self.n
         dtype = self.obj.dtype
         if not self.is_valid_dtype_n_method(dtype):
-            raise TypeError(
-                "Cannot use method '{method}' with "
-                "dtype {dtype}".format(method=method, dtype=dtype)
-            )
+            raise TypeError(f"Cannot use method '{method}' with dtype {dtype}")
 
         if n <= 0:
             return self.obj[[]]

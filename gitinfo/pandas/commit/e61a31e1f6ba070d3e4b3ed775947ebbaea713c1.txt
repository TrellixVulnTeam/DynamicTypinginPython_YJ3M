commit e61a31e1f6ba070d3e4b3ed775947ebbaea713c1
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jun 27 19:41:47 2011 -0400

    groupby now excludes NA values just like R does. avoids NA-handling issues

diff --git a/Makefile b/Makefile
index 96317215c..a4a700a81 100644
--- a/Makefile
+++ b/Makefile
@@ -1,12 +1,12 @@
 clean:
 	-rm -rf build dist
 
-tseries: pandas/lib/src/tseries.pyx
-	touch pandas/lib/src/tseries.pyx
-	python build_cython.py build_ext --inplace
+tseries: pandas/src/tseries.pyx
+	touch pandas/src/tseries.pyx
+	python setup.py build_ext --inplace
 
-sparse: pandas/lib/src/sparse.pyx
-	-python build_cython.py build_ext --inplace
+sparse: pandas/src/sparse.pyx
+	-python setup.py build_ext --inplace
 
 test: sparse
-	-python pandas/lib/tests/test_libsparse.py
\ No newline at end of file
+	-python pandas/tests/test_libsparse.py
\ No newline at end of file
diff --git a/build_cython.py b/build_cython.py
deleted file mode 100755
index 365196129..000000000
--- a/build_cython.py
+++ /dev/null
@@ -1,18 +0,0 @@
-#/usr/bin/env python
-
-from distutils.extension import Extension
-from numpy.distutils.core import setup
-import numpy
-from Cython.Distutils import build_ext
-
-pyx_ext = Extension('pandas.lib.tseries', ['pandas/lib/src/tseries.pyx'],
-                    include_dirs=[numpy.get_include()])
-
-sparse_ext = Extension('pandas.lib.sparse', ['pandas/lib/src/sparse.pyx'],
-                       include_dirs=[numpy.get_include()])
-
-setup(name='pandas.lib.tseries', description='Nothing',
-      ext_modules=[pyx_ext, sparse_ext],
-      cmdclass = {
-          'build_ext' : build_ext
-      })
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 38b441547..77e8ec3b5 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -407,14 +407,14 @@ class DataFrame(PandasGeneric):
 
         if index_col is not None:
             field = data.dtype.names[index_col]
-            df = cls.fromRecords(data, indexField=field)
+            df = cls.from_records(data, indexField=field)
 
             # have dates?
             test_val = datetools.to_datetime(df.index[0])
             if isinstance(test_val, datetime):
                 df = df.rename(index=datetools.to_datetime)
         else:
-            df = cls.fromRecords(data, indexField=None)
+            df = cls.from_records(data, indexField=None)
 
         return df
 
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 068e0f9fa..50d0b719e 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -5,7 +5,6 @@ from cStringIO import StringIO
 from pandas.core.frame import DataFrame
 from pandas.core.series import Series
 from pandas.core.panel import WidePanel
-import pandas.core.common as common
 import pandas._tseries as _tseries
 
 class GroupDict(dict):
@@ -48,30 +47,30 @@ class GroupBy(object):
     _groups = None
     _group_indices = None
 
-    def __init__(self, obj, grouper):
+    def __init__(self, obj, grouper, axis=0):
         self.obj = obj
         if hasattr(grouper, 'get'):
             grouper = grouper.get
         self.grouper = grouper
-        axis = self._group_axis
-        self.groups = _tseries.groupby(axis, self.grouper,
-                                      output=GroupDict())
-
-    @property
-    def group_indices(self):
-        if self._group_indices is None:
-            axis = self._group_axis
-            self._group_indices = _tseries.groupby_indices(axis, self.grouper)
 
-        return self._group_indices
+        self.axis = axis
+        self._group_axis = obj._get_axis(axis)
+        self._group_axis_name = obj._get_axis_name(axis)
+        self.group_indices = _tseries.groupby_indices(self._group_axis,
+                                                      self.grouper)
 
     @property
-    def _group_axis(self):
-        # default
-        return self.obj.index
+    def groups(self):
+        if self._groups is None:
+            axis = self._group_axis
+            self._groups = _tseries.groupby(axis, self.grouper,
+                                            output=GroupDict())
+        return self._groups
 
-    def getGroup(self, groupList):
-        return self.obj.reindex(groupList)
+    def getGroup(self, indices):
+        labels = np.asarray(self._group_axis)
+        group_labels = labels.take(indices)
+        return self.obj.reindex(**{self._group_axis_name : group_labels})
 
     def __iter__(self):
         """
@@ -82,13 +81,14 @@ class GroupBy(object):
         Generator yielding sequence of (groupName, subsetted object)
         for each group
         """
+        groups = self.group_indices.keys()
         try:
-            groupNames = sorted(self.groups)
+            groupNames = sorted(groups)
         except Exception: # pragma: no cover
-            groupNames = self.groups.keys()
+            pass
 
-        for groupName in groupNames:
-            yield groupName, self[groupName]
+        for name in groups:
+            yield name, self[name]
 
     def aggregate(self, func):
         raise NotImplementedError
@@ -96,11 +96,10 @@ class GroupBy(object):
     def agg(self, func):
         return self.aggregate(func)
 
-    def _aggregate_generic(self, getter, agger, axis=0):
+    def _aggregate_generic(self, agger, axis=0):
         result = {}
-        for name, group in self.groups.iteritems():
-            data = getter(self.obj, group)
-
+        for name, inds in self.group_indices.iteritems():
+            data = self.getGroup(inds)
             try:
                 result[name] = agger(data)
             except Exception:
@@ -125,7 +124,7 @@ class GroupBy(object):
         return self.aggregate(np.sum)
 
     def __getitem__(self, key):
-        return self.getGroup(self.groups[key])
+        return self.getGroup(self.group_indices[key])
 
 class SeriesGroupBy(GroupBy):
 
@@ -182,16 +181,16 @@ class SeriesGroupBy(GroupBy):
 
     def _aggregate_named(self, applyfunc):
         result = {}
-        for groupName in self.groups:
-            grp = self[groupName]
-            grp.groupName = groupName
+        for k, v in self.group_indices.iteritems():
+            grp = self[k]
+            grp.groupName = k
             output = applyfunc(grp)
 
             if isinstance(output, Series):
                 raise Exception('Given applyfunc did not return a '
                                 'value from the subseries as expected!')
 
-            result[groupName] = output
+            result[k] = output
 
         return result
 
@@ -242,20 +241,7 @@ class DataFrameGroupBy(GroupBy):
     def __init__(self, obj, grouper, axis=0):
         if isinstance(grouper, basestring):
             grouper = obj[grouper].get
-
-        self.axis = axis
-
-        if axis not in (0, 1): # pragma: no cover
-            raise Exception('invalid axis')
-
-        GroupBy.__init__(self, obj, grouper)
-
-    @property
-    def _group_axis(self):
-        if self.axis == 0:
-            return self.obj.index
-        else:
-            return self.obj.columns
+        GroupBy.__init__(self, obj, grouper, axis=axis)
 
     def aggregate(self, applyfunc):
         """
@@ -268,7 +254,7 @@ class DataFrameGroupBy(GroupBy):
         ----------
         mapper : function, dict-like, or string
             Mapping or mapping function. If string given, must be a column
-            name in the frame
+            name in the framep
         applyfunc : function
             Function to use for aggregating groups
 
@@ -277,24 +263,12 @@ class DataFrameGroupBy(GroupBy):
 
         Optional: provide set mapping as dictionary
         """
-        axis_name = 'columns' if self.axis else 'index'
-        getter = lambda df, group: df.reindex(**{axis_name : group})
-        result_d = self._aggregate_generic(getter, applyfunc,
-                                           axis=self.axis)
-
+        result_d = self._aggregate_generic(applyfunc, axis=self.axis)
         result = DataFrame(result_d)
-
         if self.axis == 0:
             result = result.T
-
         return result
 
-    def getGroup(self, groupList):
-        if self.axis == 0:
-            return self.obj.reindex(groupList)
-        else:
-            return self.obj.reindex(columns=groupList)
-
     def transform(self, func):
         """
         For given DataFrame, group index by given mapper function or dict, take
@@ -362,16 +336,7 @@ class DataFrameGroupBy(GroupBy):
 class WidePanelGroupBy(GroupBy):
 
     def __init__(self, obj, grouper, axis=0):
-        self.axis = axis
-
-        if axis not in (0, 1, 2): # pragma: no cover
-            raise ValueError('invalid axis')
-
-        GroupBy.__init__(self, obj, grouper)
-
-    @property
-    def _group_axis(self):
-        return self.obj._get_axis(self.axis)
+        GroupBy.__init__(self, obj, grouper, axis=axis)
 
     def aggregate(self, func):
         """
@@ -394,10 +359,7 @@ class WidePanelGroupBy(GroupBy):
         Optional: provide set mapping as dictionary
         """
         axis_name = self.obj._get_axis_name(self.axis)
-        getter = lambda p, group: p.reindex(**{axis_name : group})
-        result_d = self._aggregate_generic(getter, func,
-                                           axis=self.axis)
-
+        result_d = self._aggregate_generic(func, axis=self.axis)
         result = WidePanel.fromDict(result_d, intersect=False)
 
         if self.axis > 0:
diff --git a/pandas/src/groupby.pyx b/pandas/src/groupby.pyx
index 7cdfb06a2..02cbde4b7 100644
--- a/pandas/src/groupby.pyx
+++ b/pandas/src/groupby.pyx
@@ -37,9 +37,10 @@ def groupby(object index, object mapper, output=None):
     index_buf = np.asarray(index)
     mapped_index = arrmap(index_buf, mapper)
     mask = isnullobj(mapped_index)
-    nullkeys = index_buf[mask.astype(bool)]
-    if len(nullkeys) > 0:
-        result[np.NaN] = nullkeys
+
+    # nullkeys = index_buf[mask.astype(bool)]
+    # if len(nullkeys) > 0:
+    #     result[np.NaN] = nullkeys
 
     for i from 0 <= i < length:
         if mask[i]:
@@ -69,16 +70,11 @@ def groupby_indices(object index, object mapper):
     result = {}
     index = np.asarray(index)
     mapped_index = arrmap(index, mapper)
-
     mask = isnullobj(mapped_index)
-
-    if mask.astype(bool).any():
-        null_list = []
-        result[np.NaN] = null_list
-
     for i from 0 <= i < length:
         if mask[i]:
-            null_list.append(i)
+            continue
+
         key = mapped_index[i]
         if key in result:
             (<list> result[key]).append(i)
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index c0b089b25..37ff39c6e 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -821,21 +821,21 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
             for k2, v2 in v.iteritems():
                 self.assertEqual(v2, recons_data[k][k2])
 
-    def test_fromRecords(self):
+    def test_from_records(self):
         # from numpy documentation
         arr = np.zeros((2,),dtype=('i4,f4,a10'))
         arr[:] = [(1,2.,'Hello'),(2,3.,"World")]
 
-        frame = self.klass.fromRecords(arr)
-        indexed_frame = self.klass.fromRecords(arr, indexField='f1')
+        frame = self.klass.from_records(arr)
+        indexed_frame = self.klass.from_records(arr, indexField='f1')
 
-        self.assertRaises(Exception, self.klass.fromRecords, np.zeros((2, 3)))
+        self.assertRaises(Exception, self.klass.from_records, np.zeros((2, 3)))
 
         # what to do?
-        records = indexed_frame.toRecords()
+        records = indexed_frame.to_records()
         self.assertEqual(len(records.dtype.names), 3)
 
-        records = indexed_frame.toRecords(index=False)
+        records = indexed_frame.to_records(index=False)
         self.assertEqual(len(records.dtype.names), 2)
         self.assert_('index' not in records.dtype.names)
 
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index cf403de81..a1395f013 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -1061,6 +1061,17 @@ class TestSeries(unittest.TestCase):
             for idx in group.index:
                 self.assertEqual(transformed[idx], mean)
 
+    def test_groupby_with_na(self):
+        index = Index(np.arange(10))
+        values = Series(np.ones(10), index)
+        labels = Series([nan, 'foo', 'bar', 'bar', nan, nan, 'bar',
+                         'bar', nan, 'foo'], index=index)
+
+        grouped = values.groupby(labels)
+        agged = grouped.agg(len)
+        expected = Series([4, 2], index=['bar', 'foo'])
+        assert_series_equal(agged, expected)
+
     def test_select(self):
         n = len(self.ts)
         result = self.ts.select(lambda x: x >= self.ts.index[n // 2])

commit ca215aed7e4567d988908d9d00e1a7841268cb7f
Author: jreback <jeff@reback.net>
Date:   Sun Jun 16 21:33:37 2013 -0400

    BUG: (GH3925) Indexing with a string with seconds resolution not selecting from a time index

diff --git a/RELEASE.rst b/RELEASE.rst
index 500ba2df1..4e5d340c9 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -254,6 +254,7 @@ pandas 0.11.1
     in the ``to_replace`` argument wasn't working (GH3907_)
   - Fixed ``__truediv__`` in Python 2.7 with ``numexpr`` installed to actually do true division when dividing
     two integer arrays with at least 10000 cells total (GH3764_)
+  - Indexing with a string with seconds resolution not selecting from a time index (GH3925_)
 
 .. _GH3164: https://github.com/pydata/pandas/issues/3164
 .. _GH2786: https://github.com/pydata/pandas/issues/2786
@@ -355,9 +356,13 @@ pandas 0.11.1
 .. _GH3907: https://github.com/pydata/pandas/issues/3907
 .. _GH3911: https://github.com/pydata/pandas/issues/3911
 .. _GH3912: https://github.com/pydata/pandas/issues/3912
+<<<<<<< HEAD
 .. _GH3764: https://github.com/pydata/pandas/issues/3764
 .. _GH3888: https://github.com/pydata/pandas/issues/3888
 
+=======
+.. _GH3925: https://github.com/pydata/pandas/issues/3925
+>>>>>>> BUG: (GH3925) Indexing with a string with seconds resolution not selecting from a time index
 
 pandas 0.11.0
 =============
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 7a7210c47..33f72a0d1 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -1,5 +1,6 @@
 # pylint: disable=W0223
 
+from datetime import datetime
 from pandas.core.common import _asarray_tuplesafe
 from pandas.core.index import Index, MultiIndex, _ensure_index
 import pandas.core.common as com
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 1cb986ee6..109ceced4 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -1102,6 +1102,13 @@ class DatetimeIndex(Int64Index):
             t1 = Timestamp(st, tz=self.tz)
             t2 = Timestamp(Timestamp(st + offsets.Minute(),
                                      tz=self.tz).value - 1)
+        elif (reso == 'second' and (
+                self._resolution == Resolution.RESO_SEC or not is_monotonic)):
+            st = datetime(parsed.year, parsed.month, parsed.day,
+                          hour=parsed.hour, minute=parsed.minute, second=parsed.second)
+            t1 = Timestamp(st, tz=self.tz)
+            t2 = Timestamp(Timestamp(st + offsets.Second(),
+                                     tz=self.tz).value - 1)
         else:
             raise KeyError
 
@@ -1110,9 +1117,16 @@ class DatetimeIndex(Int64Index):
 
         if is_monotonic:
 
+            # we are out of range
+            if len(stamps) and (
+                (use_lhs and t1.value < stamps[0] and t2.value < stamps[0]) or (
+                (use_rhs and t1.value > stamps[-1] and t2.value > stamps[-1]))):
+                raise KeyError
+
             # a monotonic (sorted) series can be sliced
             left = stamps.searchsorted(t1.value, side='left') if use_lhs else None
             right = stamps.searchsorted(t2.value, side='right') if use_rhs else None
+
             return slice(left, right)
 
         lhs_mask = (stamps>=t1.value) if use_lhs else True
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 51097cd15..08bcd9cfa 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -251,6 +251,15 @@ class TestTimeSeriesDuplicates(unittest.TestCase):
         expected = ts['2013']
         assert_series_equal(expected,ts)
 
+        # GH 3925, indexing with a seconds resolution string / datetime object
+        df = DataFrame(randn(5,5),columns=['open','high','low','close','volume'],index=date_range('2012-01-02 18:01:00',periods=5,tz='US/Central',freq='s'))
+        expected = df.loc[[df.index[2]]]
+        result = df['2012-01-02 18:01:02']
+        self.assert_(result == expected)
+
+        # this is a single date, so will raise
+        self.assertRaises(KeyError, df.__getitem__, df.index[2],)
+
 def assert_range_equal(left, right):
     assert(left.equals(right))
     assert(left.freq == right.freq)

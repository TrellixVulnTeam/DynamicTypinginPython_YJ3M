commit 3cf1757a9aff41d7fe5d3f47a18701ce93feaaf6
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Wed Sep 11 05:21:42 2019 -0700

    CLN: small ops cleanup (#28379)

diff --git a/pandas/core/ops/__init__.py b/pandas/core/ops/__init__.py
index 0b85c94f4..90fb3b868 100644
--- a/pandas/core/ops/__init__.py
+++ b/pandas/core/ops/__init__.py
@@ -18,7 +18,6 @@ from pandas.core.dtypes.common import (
     ensure_object,
     is_bool_dtype,
     is_datetime64_dtype,
-    is_datetimelike_v_numeric,
     is_extension_array_dtype,
     is_integer_dtype,
     is_list_like,
@@ -672,9 +671,6 @@ def _comp_method_SERIES(cls, op, special):
         if is_object_dtype(x.dtype):
             result = comp_method_OBJECT_ARRAY(op, x, y)
 
-        elif is_datetimelike_v_numeric(x, y):
-            return invalid_comparison(x, y, op)
-
         else:
             method = getattr(x, op_name)
             with np.errstate(all="ignore"):
diff --git a/pandas/core/ops/missing.py b/pandas/core/ops/missing.py
index 45fa6a283..4fe69f64b 100644
--- a/pandas/core/ops/missing.py
+++ b/pandas/core/ops/missing.py
@@ -30,22 +30,19 @@ from pandas.core.dtypes.common import is_float_dtype, is_integer_dtype, is_scala
 from .roperator import rdivmod, rfloordiv, rmod
 
 
-def fill_zeros(result, x, y, name, fill):
+def fill_zeros(result, x, y):
     """
     If this is a reversed op, then flip x,y
 
     If we have an integer value (or array in y)
-    and we have 0's, fill them with the fill,
+    and we have 0's, fill them with np.nan,
     return the result.
 
     Mask the nan's from x.
     """
-    if fill is None or is_float_dtype(result.dtype):
+    if is_float_dtype(result.dtype):
         return result
 
-    if name.startswith(("r", "__r")):
-        x, y = y, x
-
     is_variable_type = hasattr(y, "dtype") or hasattr(y, "type")
     is_scalar_type = is_scalar(y)
 
@@ -66,19 +63,7 @@ def fill_zeros(result, x, y, name, fill):
             shape = result.shape
             result = result.astype("float64", copy=False).ravel()
 
-            np.putmask(result, mask, fill)
-
-            # if we have a fill of inf, then sign it correctly
-            # (GH#6178 and GH#9308)
-            if np.isinf(fill):
-                signs = y if name.startswith(("r", "__r")) else x
-                signs = np.sign(signs.astype("float", copy=False))
-                negative_inf_mask = (signs.ravel() < 0) & mask
-                np.putmask(result, negative_inf_mask, -fill)
-
-            if "floordiv" in name:  # (GH#9308)
-                nan_mask = ((y == 0) & (x == 0)).ravel()
-                np.putmask(result, nan_mask, np.nan)
+            np.putmask(result, mask, np.nan)
 
             result = result.reshape(shape)
 
@@ -172,12 +157,12 @@ def dispatch_fill_zeros(op, left, right, result):
     if op is divmod:
         result = (
             mask_zero_div_zero(left, right, result[0]),
-            fill_zeros(result[1], left, right, "__mod__", np.nan),
+            fill_zeros(result[1], left, right),
         )
     elif op is rdivmod:
         result = (
             mask_zero_div_zero(right, left, result[0]),
-            fill_zeros(result[1], left, right, "__rmod__", np.nan),
+            fill_zeros(result[1], right, left),
         )
     elif op is operator.floordiv:
         # Note: no need to do this for truediv; in py3 numpy behaves the way
@@ -188,7 +173,7 @@ def dispatch_fill_zeros(op, left, right, result):
         #  we want.
         result = mask_zero_div_zero(right, left, result)
     elif op is operator.mod:
-        result = fill_zeros(result, left, right, "__mod__", np.nan)
+        result = fill_zeros(result, left, right)
     elif op is rmod:
-        result = fill_zeros(result, left, right, "__rmod__", np.nan)
+        result = fill_zeros(result, right, left)
     return result

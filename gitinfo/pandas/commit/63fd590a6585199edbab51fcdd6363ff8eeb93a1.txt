commit 63fd590a6585199edbab51fcdd6363ff8eeb93a1
Author: William Ayd <william.ayd@gmail.com>
Date:   Wed Nov 20 04:58:14 2019 -0800

    Assorted io extension cleanups (#29704)

diff --git a/pandas/_libs/src/parser/io.c b/pandas/_libs/src/parser/io.c
index aecd4e036..1e3295fcb 100644
--- a/pandas/_libs/src/parser/io.c
+++ b/pandas/_libs/src/parser/io.c
@@ -9,7 +9,6 @@ The full license is in the LICENSE file, distributed with this software.
 
 #include "io.h"
 
-#include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 
diff --git a/pandas/_libs/src/parser/tokenizer.c b/pandas/_libs/src/parser/tokenizer.c
index 83869a1d9..578f72112 100644
--- a/pandas/_libs/src/parser/tokenizer.c
+++ b/pandas/_libs/src/parser/tokenizer.c
@@ -25,19 +25,6 @@ GitHub. See Python Software Foundation License and BSD licenses for these.
 
 #include "../headers/portable.h"
 
-static void *safe_realloc(void *buffer, size_t size) {
-    void *result;
-    // OSX is weird.
-    // http://stackoverflow.com/questions/9560609/
-    // different-realloc-behaviour-in-linux-and-osx
-
-    result = realloc(buffer, size);
-    TRACE(("safe_realloc: buffer = %p, size = %zu, result = %p\n", buffer, size,
-           result))
-
-    return result;
-}
-
 void coliter_setup(coliter_t *self, parser_t *parser, int i, int start) {
     // column i, starting at 0
     self->words = parser->words;
@@ -45,18 +32,6 @@ void coliter_setup(coliter_t *self, parser_t *parser, int i, int start) {
     self->line_start = parser->line_start + start;
 }
 
-coliter_t *coliter_new(parser_t *self, int i) {
-    // column i, starting at 0
-    coliter_t *iter = (coliter_t *)malloc(sizeof(coliter_t));
-
-    if (NULL == iter) {
-        return NULL;
-    }
-
-    coliter_setup(iter, self, i, 0);
-    return iter;
-}
-
 static void free_if_not_null(void **ptr) {
     TRACE(("free_if_not_null %p\n", *ptr))
     if (*ptr != NULL) {
@@ -80,7 +55,7 @@ static void *grow_buffer(void *buffer, uint64_t length, uint64_t *capacity,
     while ((length + space >= cap) && (newbuffer != NULL)) {
         cap = cap ? cap << 1 : 2;
         buffer = newbuffer;
-        newbuffer = safe_realloc(newbuffer, elsize * cap);
+        newbuffer = realloc(newbuffer, elsize * cap);
     }
 
     if (newbuffer == NULL) {
@@ -321,8 +296,8 @@ static int make_stream_space(parser_t *self, size_t nbytes) {
             ("make_stream_space: cap != self->words_cap, nbytes = %d, "
              "self->words_cap=%d\n",
              nbytes, self->words_cap))
-        newptr = safe_realloc((void *)self->word_starts,
-                              sizeof(int64_t) * self->words_cap);
+        newptr = realloc((void *)self->word_starts,
+                         sizeof(int64_t) * self->words_cap);
         if (newptr == NULL) {
             return PARSER_OUT_OF_MEMORY;
         } else {
@@ -349,8 +324,8 @@ static int make_stream_space(parser_t *self, size_t nbytes) {
     if (cap != self->lines_cap) {
         TRACE(("make_stream_space: cap != self->lines_cap, nbytes = %d\n",
                nbytes))
-        newptr = safe_realloc((void *)self->line_fields,
-                              sizeof(int64_t) * self->lines_cap);
+        newptr = realloc((void *)self->line_fields,
+                         sizeof(int64_t) * self->lines_cap);
         if (newptr == NULL) {
             return PARSER_OUT_OF_MEMORY;
         } else {
@@ -427,7 +402,7 @@ static void append_warning(parser_t *self, const char *msg) {
         snprintf(self->warn_msg, length + 1, "%s", msg);
     } else {
         ex_length = strlen(self->warn_msg);
-        newptr = safe_realloc(self->warn_msg, ex_length + length + 1);
+        newptr = realloc(self->warn_msg, ex_length + length + 1);
         if (newptr != NULL) {
             self->warn_msg = (char *)newptr;
             snprintf(self->warn_msg + ex_length, length + 1, "%s", msg);
@@ -1290,13 +1265,13 @@ int parser_trim_buffers(parser_t *self) {
     new_cap = _next_pow2(self->words_len) + 1;
     if (new_cap < self->words_cap) {
         TRACE(("parser_trim_buffers: new_cap < self->words_cap\n"));
-        newptr = safe_realloc((void *)self->words, new_cap * sizeof(char *));
+        newptr = realloc((void *)self->words, new_cap * sizeof(char *));
         if (newptr == NULL) {
             return PARSER_OUT_OF_MEMORY;
         } else {
             self->words = (char **)newptr;
         }
-        newptr = safe_realloc((void *)self->word_starts,
+        newptr = realloc((void *)self->word_starts,
                               new_cap * sizeof(int64_t));
         if (newptr == NULL) {
             return PARSER_OUT_OF_MEMORY;
@@ -1315,13 +1290,13 @@ int parser_trim_buffers(parser_t *self) {
     if (new_cap < self->stream_cap) {
         TRACE(
             ("parser_trim_buffers: new_cap < self->stream_cap, calling "
-             "safe_realloc\n"));
-        newptr = safe_realloc((void *)self->stream, new_cap);
+             "realloc\n"));
+        newptr = realloc((void *)self->stream, new_cap);
         if (newptr == NULL) {
             return PARSER_OUT_OF_MEMORY;
         } else {
             // Update the pointers in the self->words array (char **) if
-            // `safe_realloc`
+            // `realloc`
             //  moved the `self->stream` buffer. This block mirrors a similar
             //  block in
             //  `make_stream_space`.
@@ -1342,14 +1317,14 @@ int parser_trim_buffers(parser_t *self) {
     new_cap = _next_pow2(self->lines) + 1;
     if (new_cap < self->lines_cap) {
         TRACE(("parser_trim_buffers: new_cap < self->lines_cap\n"));
-        newptr = safe_realloc((void *)self->line_start,
+        newptr = realloc((void *)self->line_start,
                               new_cap * sizeof(int64_t));
         if (newptr == NULL) {
             return PARSER_OUT_OF_MEMORY;
         } else {
             self->line_start = (int64_t *)newptr;
         }
-        newptr = safe_realloc((void *)self->line_fields,
+        newptr = realloc((void *)self->line_fields,
                               new_cap * sizeof(int64_t));
         if (newptr == NULL) {
             return PARSER_OUT_OF_MEMORY;
diff --git a/pandas/_libs/src/parser/tokenizer.h b/pandas/_libs/src/parser/tokenizer.h
index 4903e936d..b37de4766 100644
--- a/pandas/_libs/src/parser/tokenizer.h
+++ b/pandas/_libs/src/parser/tokenizer.h
@@ -15,7 +15,6 @@ See LICENSE for the license
 #define PY_SSIZE_T_CLEAN
 #include <Python.h>
 
-#define ERROR_OK 0
 #define ERROR_NO_DIGITS 1
 #define ERROR_OVERFLOW 2
 #define ERROR_INVALID_CHARS 3
@@ -32,10 +31,6 @@ See LICENSE for the license
 #define CALLING_READ_FAILED 2
 
 
-#if defined(_MSC_VER)
-#define strtoll _strtoi64
-#endif  // _MSC_VER
-
 /*
 
   C flat file parsing low level code for pandas / NumPy
@@ -180,7 +175,6 @@ typedef struct coliter_t {
 } coliter_t;
 
 void coliter_setup(coliter_t *self, parser_t *parser, int i, int start);
-coliter_t *coliter_new(parser_t *self, int i);
 
 #define COLITER_NEXT(iter, word)                           \
     do {                                                   \

commit 266a2e3700c64a9a432fe476857945ad332d4886
Author: Jeff Tratner <jeffrey.tratner@gmail.com>
Date:   Wed Oct 30 20:59:51 2013 -0400

    CLN: Minor touchups to docstrings + use assert_produces_warning

diff --git a/pandas/core/strings.py b/pandas/core/strings.py
index e5e3f9866..c1bd36968 100644
--- a/pandas/core/strings.py
+++ b/pandas/core/strings.py
@@ -170,8 +170,8 @@ def str_contains(arr, pat, case=True, flags=0, na=np.nan):
     regex = re.compile(pat, flags=flags)
 
     if regex.groups > 0:
-        warnings.warn("""This pattern has match groups. To actually get the 
-groups, use str.extract.""", UserWarning)
+        warnings.warn("This pattern has match groups. To actually get the"
+                      " groups, use str.extract.", UserWarning)
 
     f = lambda x: bool(regex.search(x))
     return _na_map(f, arr, na)
@@ -329,7 +329,7 @@ def str_match(arr, pat, case=True, flags=0, na=np.nan, as_indexer=False):
     -------
     matches : boolean array (if as_indexer=True)
     matches : array of tuples (if as_indexer=False, default but deprecated)
-    
+
     Note
     ----
     To extract matched groups, which is the deprecated behavior of match, use
@@ -344,12 +344,12 @@ def str_match(arr, pat, case=True, flags=0, na=np.nan, as_indexer=False):
     if (not as_indexer) and regex.groups > 0:
         # Do this first, to make sure it happens even if the re.compile
         # raises below.
-        warnings.warn("""In future versions of pandas, match will change 
-to always return a bool indexer.""", UserWarning)
+        warnings.warn("In future versions of pandas, match will change to"
+                      " always return a bool indexer.""", UserWarning)
 
     if as_indexer and regex.groups > 0:
-        warnings.warn("""This pattern has match groups. To actually get the 
-groups, use str.extract.""", UserWarning)
+        warnings.warn("This pattern has match groups. To actually get the"
+                      " groups, use str.extract.""", UserWarning)
 
     # If not as_indexer and regex.groups == 0, this returns empty lists
     # and is basically useless, so we will not warn.
diff --git a/pandas/tests/test_strings.py b/pandas/tests/test_strings.py
index 29bdffd86..c75fec44c 100644
--- a/pandas/tests/test_strings.py
+++ b/pandas/tests/test_strings.py
@@ -397,10 +397,8 @@ class TestStringMethods(unittest.TestCase):
         # Old match behavior, deprecated (but still default) in 0.13
         values = Series(['fooBAD__barBAD', NA, 'foo'])
 
-        with warnings.catch_warnings(record=True) as w:
-            warnings.simplefilter('always')
+        with tm.assert_produces_warning():
             result = values.str.match('.*(BAD[_]+).*(BAD)')
-            assert issubclass(w[-1].category, UserWarning)
         exp = Series([('BAD__', 'BAD'), NA, []])
         tm.assert_series_equal(result, exp)
 
@@ -408,10 +406,8 @@ class TestStringMethods(unittest.TestCase):
         mixed = Series(['aBAD_BAD', NA, 'BAD_b_BAD', True, datetime.today(),
                         'foo', None, 1, 2.])
 
-        with warnings.catch_warnings(record=True) as w:
-            warnings.simplefilter('always')
+        with tm.assert_produces_warning():
             rs = Series(mixed).str.match('.*(BAD[_]+).*(BAD)')
-            assert issubclass(w[-1].category, UserWarning)
         xp = [('BAD_', 'BAD'), NA, ('BAD_', 'BAD'), NA, NA, [], NA, NA, NA]
         tm.assert_isinstance(rs, Series)
         tm.assert_almost_equal(rs, xp)
@@ -419,20 +415,16 @@ class TestStringMethods(unittest.TestCase):
         # unicode
         values = Series([u('fooBAD__barBAD'), NA, u('foo')])
 
-        with warnings.catch_warnings(record=True) as w:
-            warnings.simplefilter('always')
+        with tm.assert_produces_warning():
             result = values.str.match('.*(BAD[_]+).*(BAD)')
-            assert issubclass(w[-1].category, UserWarning)
         exp = Series([(u('BAD__'), u('BAD')), NA, []])
         tm.assert_series_equal(result, exp)
 
     def test_match(self):
         # New match behavior introduced in 0.13
         values = Series(['fooBAD__barBAD', NA, 'foo'])
-        with warnings.catch_warnings(record=True) as w:
-            warnings.simplefilter('always')
+        with tm.assert_produces_warning():
             result = values.str.match('.*(BAD[_]+).*(BAD)', as_indexer=True)
-            assert issubclass(w[-1].category, UserWarning)
         exp = Series([True, NA, False])
         tm.assert_series_equal(result, exp)
 
@@ -447,10 +439,8 @@ class TestStringMethods(unittest.TestCase):
         mixed = Series(['aBAD_BAD', NA, 'BAD_b_BAD', True, datetime.today(),
                         'foo', None, 1, 2.])
 
-        with warnings.catch_warnings(record=True) as w:
-            warnings.simplefilter('always')
+        with tm.assert_produces_warning():
             rs = Series(mixed).str.match('.*(BAD[_]+).*(BAD)', as_indexer=True)
-            assert issubclass(w[-1].category, UserWarning)
         xp = [True, NA, True, NA, NA, False, NA, NA, NA]
         tm.assert_isinstance(rs, Series)
         tm.assert_almost_equal(rs, xp)
@@ -458,10 +448,8 @@ class TestStringMethods(unittest.TestCase):
         # unicode
         values = Series([u('fooBAD__barBAD'), NA, u('foo')])
 
-        with warnings.catch_warnings(record=True) as w:
-            warnings.simplefilter('always')
+        with tm.assert_produces_warning():
             result = values.str.match('.*(BAD[_]+).*(BAD)', as_indexer=True)
-            assert issubclass(w[-1].category, UserWarning)
         exp = Series([True, NA, False])
         tm.assert_series_equal(result, exp)
 

commit 6552a237837894f6f244b5fa022cae90343508cd
Author: Jeff Reback <jeff@reback.net>
Date:   Tue Feb 7 17:58:45 2017 -0500

    TST: more tseries/tests reorg

diff --git a/pandas/tests/indexes/datetimes/test_date_range.py b/pandas/tests/indexes/datetimes/test_date_range.py
index 8dab10269..80664ce24 100644
--- a/pandas/tests/indexes/datetimes/test_date_range.py
+++ b/pandas/tests/indexes/datetimes/test_date_range.py
@@ -1,22 +1,30 @@
+"""
+test date_range, bdate_range, cdate_range
+construction from the convenience range functions
+"""
+
 import numpy as np
 from datetime import datetime, timedelta, time
 
 import pandas as pd
 import pandas.util.testing as tm
 from pandas import compat
-from pandas.core import common as com
-from pandas.util.testing import assertRaisesRegexp
 from pandas.tseries.index import bdate_range, cdate_range
-from pandas import date_range, offsets, DatetimeIndex, Timestamp, Index
-from pandas.tseries.offsets import (generate_range, CDay, BDay, Minute,
-                                    BMonthEnd, DateOffset, MonthEnd)
+from pandas import date_range, offsets, DatetimeIndex, Timestamp
+from pandas.tseries.offsets import (generate_range, CDay, BDay,
+                                    DateOffset, MonthEnd)
 
 from pandas.tests.series.common import TestData
 
 START, END = datetime(2009, 1, 1), datetime(2010, 1, 1)
 
 
-class TestTimeSeries(TestData, tm.TestCase):
+def eq_gen_range(kwargs, expected):
+    rng = generate_range(**kwargs)
+    assert (np.array_equal(list(rng), expected))
+
+
+class TestDateRanges(TestData, tm.TestCase):
 
     def test_date_range_gen_error(self):
         rng = date_range('1/1/2000 00:00', '1/1/2000 00:18', freq='5min')
@@ -137,11 +145,6 @@ class TestTimeSeries(TestData, tm.TestCase):
                           datetime(2011, 11, 12), freq=offset)
 
 
-def eq_gen_range(kwargs, expected):
-    rng = generate_range(**kwargs)
-    assert (np.array_equal(list(rng), expected))
-
-
 class TestGenRangeGeneration(tm.TestCase):
 
     def test_generate(self):
@@ -191,7 +194,8 @@ class TestGenRangeGeneration(tm.TestCase):
         self.assert_index_equal(result2, expected2)
 
 
-class TestDateRange(tm.TestCase):
+class TestBusinessDateRange(tm.TestCase):
+
     def setUp(self):
         self.rng = bdate_range(START, END)
 
@@ -206,28 +210,31 @@ class TestDateRange(tm.TestCase):
         naive = bdate_range(START, END, freq=BDay(), tz=None)
         aware = bdate_range(START, END, freq=BDay(),
                             tz="Asia/Hong_Kong")
-        assertRaisesRegexp(TypeError, "tz-naive.*tz-aware", naive.join, aware)
-        assertRaisesRegexp(TypeError, "tz-naive.*tz-aware", aware.join, naive)
+        self.assertRaisesRegexp(TypeError, "tz-naive.*tz-aware",
+                                naive.join, aware)
+        self.assertRaisesRegexp(TypeError, "tz-naive.*tz-aware",
+                                aware.join, naive)
 
     def test_cached_range(self):
         DatetimeIndex._cached_range(START, END, offset=BDay())
         DatetimeIndex._cached_range(START, periods=20, offset=BDay())
         DatetimeIndex._cached_range(end=START, periods=20, offset=BDay())
 
-        assertRaisesRegexp(TypeError, "offset", DatetimeIndex._cached_range,
-                           START, END)
+        self.assertRaisesRegexp(TypeError, "offset",
+                                DatetimeIndex._cached_range,
+                                START, END)
 
-        assertRaisesRegexp(TypeError, "specify period",
-                           DatetimeIndex._cached_range, START,
-                           offset=BDay())
+        self.assertRaisesRegexp(TypeError, "specify period",
+                                DatetimeIndex._cached_range, START,
+                                offset=BDay())
 
-        assertRaisesRegexp(TypeError, "specify period",
-                           DatetimeIndex._cached_range, end=END,
-                           offset=BDay())
+        self.assertRaisesRegexp(TypeError, "specify period",
+                                DatetimeIndex._cached_range, end=END,
+                                offset=BDay())
 
-        assertRaisesRegexp(TypeError, "start or end",
-                           DatetimeIndex._cached_range, periods=20,
-                           offset=BDay())
+        self.assertRaisesRegexp(TypeError, "start or end",
+                                DatetimeIndex._cached_range, periods=20,
+                                offset=BDay())
 
     def test_cached_range_bug(self):
         rng = date_range('2010-09-01 05:00:00', periods=50,
@@ -236,192 +243,16 @@ class TestDateRange(tm.TestCase):
         self.assertEqual(rng[0], datetime(2010, 9, 1, 5))
 
     def test_timezone_comparaison_bug(self):
+        # smoke test
         start = Timestamp('20130220 10:00', tz='US/Eastern')
-        try:
-            date_range(start, periods=2, tz='US/Eastern')
-        except AssertionError:
-            self.fail()
+        result = date_range(start, periods=2, tz='US/Eastern')
+        self.assertEqual(len(result), 2)
 
     def test_timezone_comparaison_assert(self):
         start = Timestamp('20130220 10:00', tz='US/Eastern')
         self.assertRaises(AssertionError, date_range, start, periods=2,
                           tz='Europe/Berlin')
 
-    def test_comparison(self):
-        d = self.rng[10]
-
-        comp = self.rng > d
-        self.assertTrue(comp[11])
-        self.assertFalse(comp[9])
-
-    def test_copy(self):
-        cp = self.rng.copy()
-        repr(cp)
-        self.assert_index_equal(cp, self.rng)
-
-    def test_repr(self):
-        # only really care that it works
-        repr(self.rng)
-
-    def test_getitem(self):
-        smaller = self.rng[:5]
-        exp = DatetimeIndex(self.rng.view(np.ndarray)[:5])
-        self.assert_index_equal(smaller, exp)
-
-        self.assertEqual(smaller.offset, self.rng.offset)
-
-        sliced = self.rng[::5]
-        self.assertEqual(sliced.offset, BDay() * 5)
-
-        fancy_indexed = self.rng[[4, 3, 2, 1, 0]]
-        self.assertEqual(len(fancy_indexed), 5)
-        tm.assertIsInstance(fancy_indexed, DatetimeIndex)
-        self.assertIsNone(fancy_indexed.freq)
-
-        # 32-bit vs. 64-bit platforms
-        self.assertEqual(self.rng[4], self.rng[np.int_(4)])
-
-    def test_getitem_matplotlib_hackaround(self):
-        values = self.rng[:, None]
-        expected = self.rng.values[:, None]
-        self.assert_numpy_array_equal(values, expected)
-
-    def test_shift(self):
-        shifted = self.rng.shift(5)
-        self.assertEqual(shifted[0], self.rng[5])
-        self.assertEqual(shifted.offset, self.rng.offset)
-
-        shifted = self.rng.shift(-5)
-        self.assertEqual(shifted[5], self.rng[0])
-        self.assertEqual(shifted.offset, self.rng.offset)
-
-        shifted = self.rng.shift(0)
-        self.assertEqual(shifted[0], self.rng[0])
-        self.assertEqual(shifted.offset, self.rng.offset)
-
-        rng = date_range(START, END, freq=BMonthEnd())
-        shifted = rng.shift(1, freq=BDay())
-        self.assertEqual(shifted[0], rng[0] + BDay())
-
-    def test_pickle_unpickle(self):
-        unpickled = self.round_trip_pickle(self.rng)
-        self.assertIsNotNone(unpickled.offset)
-
-    def test_union(self):
-        # overlapping
-        left = self.rng[:10]
-        right = self.rng[5:10]
-
-        the_union = left.union(right)
-        tm.assertIsInstance(the_union, DatetimeIndex)
-
-        # non-overlapping, gap in middle
-        left = self.rng[:5]
-        right = self.rng[10:]
-
-        the_union = left.union(right)
-        tm.assertIsInstance(the_union, Index)
-
-        # non-overlapping, no gap
-        left = self.rng[:5]
-        right = self.rng[5:10]
-
-        the_union = left.union(right)
-        tm.assertIsInstance(the_union, DatetimeIndex)
-
-        # order does not matter
-        tm.assert_index_equal(right.union(left), the_union)
-
-        # overlapping, but different offset
-        rng = date_range(START, END, freq=BMonthEnd())
-
-        the_union = self.rng.union(rng)
-        tm.assertIsInstance(the_union, DatetimeIndex)
-
-    def test_outer_join(self):
-        # should just behave as union
-
-        # overlapping
-        left = self.rng[:10]
-        right = self.rng[5:10]
-
-        the_join = left.join(right, how='outer')
-        tm.assertIsInstance(the_join, DatetimeIndex)
-
-        # non-overlapping, gap in middle
-        left = self.rng[:5]
-        right = self.rng[10:]
-
-        the_join = left.join(right, how='outer')
-        tm.assertIsInstance(the_join, DatetimeIndex)
-        self.assertIsNone(the_join.freq)
-
-        # non-overlapping, no gap
-        left = self.rng[:5]
-        right = self.rng[5:10]
-
-        the_join = left.join(right, how='outer')
-        tm.assertIsInstance(the_join, DatetimeIndex)
-
-        # overlapping, but different offset
-        rng = date_range(START, END, freq=BMonthEnd())
-
-        the_join = self.rng.join(rng, how='outer')
-        tm.assertIsInstance(the_join, DatetimeIndex)
-        self.assertIsNone(the_join.freq)
-
-    def test_union_not_cacheable(self):
-        rng = date_range('1/1/2000', periods=50, freq=Minute())
-        rng1 = rng[10:]
-        rng2 = rng[:25]
-        the_union = rng1.union(rng2)
-        self.assert_index_equal(the_union, rng)
-
-        rng1 = rng[10:]
-        rng2 = rng[15:35]
-        the_union = rng1.union(rng2)
-        expected = rng[10:]
-        self.assert_index_equal(the_union, expected)
-
-    def test_intersection(self):
-        rng = date_range('1/1/2000', periods=50, freq=Minute())
-        rng1 = rng[10:]
-        rng2 = rng[:25]
-        the_int = rng1.intersection(rng2)
-        expected = rng[10:25]
-        self.assert_index_equal(the_int, expected)
-        tm.assertIsInstance(the_int, DatetimeIndex)
-        self.assertEqual(the_int.offset, rng.offset)
-
-        the_int = rng1.intersection(rng2.view(DatetimeIndex))
-        self.assert_index_equal(the_int, expected)
-
-        # non-overlapping
-        the_int = rng[:10].intersection(rng[10:])
-        expected = DatetimeIndex([])
-        self.assert_index_equal(the_int, expected)
-
-    def test_intersection_bug(self):
-        # GH #771
-        a = bdate_range('11/30/2011', '12/31/2011')
-        b = bdate_range('12/10/2011', '12/20/2011')
-        result = a.intersection(b)
-        self.assert_index_equal(result, b)
-
-    def test_summary(self):
-        self.rng.summary()
-        self.rng[2:2].summary()
-
-    def test_summary_pytz(self):
-        tm._skip_if_no_pytz()
-        import pytz
-        bdate_range('1/1/2005', '1/1/2009', tz=pytz.utc).summary()
-
-    def test_summary_dateutil(self):
-        tm._skip_if_no_dateutil()
-        import dateutil
-        bdate_range('1/1/2005', '1/1/2009', tz=dateutil.tz.tzutc()).summary()
-
     def test_misc(self):
         end = datetime(2009, 5, 13)
         dr = bdate_range(end=end, periods=20)
@@ -443,26 +274,6 @@ class TestDateRange(tm.TestCase):
         self.assertRaises(ValueError, bdate_range, badly_formed_date,
                           badly_formed_date)
 
-    def test_equals(self):
-        self.assertFalse(self.rng.equals(list(self.rng)))
-
-    def test_identical(self):
-        t1 = self.rng.copy()
-        t2 = self.rng.copy()
-        self.assertTrue(t1.identical(t2))
-
-        # name
-        t1 = t1.rename('foo')
-        self.assertTrue(t1.equals(t2))
-        self.assertFalse(t1.identical(t2))
-        t2 = t2.rename('foo')
-        self.assertTrue(t1.identical(t2))
-
-        # freq
-        t2v = Index(t2.values)
-        self.assertTrue(t1.equals(t2v))
-        self.assertFalse(t1.identical(t2v))
-
     def test_daterange_bug_456(self):
         # GH #456
         rng1 = bdate_range('12/5/2011', '12/5/2011')
@@ -560,43 +371,6 @@ class TestDateRange(tm.TestCase):
         self.assertTrue(dr[0] == start)
         self.assertTrue(dr[2] == end)
 
-    def test_month_range_union_tz_pytz(self):
-        tm._skip_if_no_pytz()
-        from pytz import timezone
-        tz = timezone('US/Eastern')
-
-        early_start = datetime(2011, 1, 1)
-        early_end = datetime(2011, 3, 1)
-
-        late_start = datetime(2011, 3, 1)
-        late_end = datetime(2011, 5, 1)
-
-        early_dr = date_range(start=early_start, end=early_end, tz=tz,
-                              freq=MonthEnd())
-        late_dr = date_range(start=late_start, end=late_end, tz=tz,
-                             freq=MonthEnd())
-
-        early_dr.union(late_dr)
-
-    def test_month_range_union_tz_dateutil(self):
-        tm._skip_if_windows_python_3()
-        tm._skip_if_no_dateutil()
-        from pandas.tslib import _dateutil_gettz as timezone
-        tz = timezone('US/Eastern')
-
-        early_start = datetime(2011, 1, 1)
-        early_end = datetime(2011, 3, 1)
-
-        late_start = datetime(2011, 3, 1)
-        late_end = datetime(2011, 5, 1)
-
-        early_dr = date_range(start=early_start, end=early_end, tz=tz,
-                              freq=MonthEnd())
-        late_dr = date_range(start=late_start, end=late_end, tz=tz,
-                             freq=MonthEnd())
-
-        early_dr.union(late_dr)
-
     def test_range_closed(self):
         begin = datetime(2011, 1, 1)
         end = datetime(2014, 1, 1)
@@ -735,151 +509,6 @@ class TestCustomDateRange(tm.TestCase):
         self.assertRaises(Exception, DatetimeIndex._cached_range, periods=20,
                           freq=CDay())
 
-    def test_comparison(self):
-        d = self.rng[10]
-
-        comp = self.rng > d
-        self.assertTrue(comp[11])
-        self.assertFalse(comp[9])
-
-    def test_copy(self):
-        cp = self.rng.copy()
-        repr(cp)
-        self.assert_index_equal(cp, self.rng)
-
-    def test_repr(self):
-        # only really care that it works
-        repr(self.rng)
-
-    def test_getitem(self):
-        smaller = self.rng[:5]
-        exp = DatetimeIndex(self.rng.view(np.ndarray)[:5])
-        self.assert_index_equal(smaller, exp)
-        self.assertEqual(smaller.offset, self.rng.offset)
-
-        sliced = self.rng[::5]
-        self.assertEqual(sliced.offset, CDay() * 5)
-
-        fancy_indexed = self.rng[[4, 3, 2, 1, 0]]
-        self.assertEqual(len(fancy_indexed), 5)
-        tm.assertIsInstance(fancy_indexed, DatetimeIndex)
-        self.assertIsNone(fancy_indexed.freq)
-
-        # 32-bit vs. 64-bit platforms
-        self.assertEqual(self.rng[4], self.rng[np.int_(4)])
-
-    def test_getitem_matplotlib_hackaround(self):
-        values = self.rng[:, None]
-        expected = self.rng.values[:, None]
-        self.assert_numpy_array_equal(values, expected)
-
-    def test_shift(self):
-
-        shifted = self.rng.shift(5)
-        self.assertEqual(shifted[0], self.rng[5])
-        self.assertEqual(shifted.offset, self.rng.offset)
-
-        shifted = self.rng.shift(-5)
-        self.assertEqual(shifted[5], self.rng[0])
-        self.assertEqual(shifted.offset, self.rng.offset)
-
-        shifted = self.rng.shift(0)
-        self.assertEqual(shifted[0], self.rng[0])
-        self.assertEqual(shifted.offset, self.rng.offset)
-
-        with tm.assert_produces_warning(com.PerformanceWarning):
-            rng = date_range(START, END, freq=BMonthEnd())
-            shifted = rng.shift(1, freq=CDay())
-            self.assertEqual(shifted[0], rng[0] + CDay())
-
-    def test_pickle_unpickle(self):
-        unpickled = self.round_trip_pickle(self.rng)
-        self.assertIsNotNone(unpickled.offset)
-
-    def test_union(self):
-        # overlapping
-        left = self.rng[:10]
-        right = self.rng[5:10]
-
-        the_union = left.union(right)
-        tm.assertIsInstance(the_union, DatetimeIndex)
-
-        # non-overlapping, gap in middle
-        left = self.rng[:5]
-        right = self.rng[10:]
-
-        the_union = left.union(right)
-        tm.assertIsInstance(the_union, Index)
-
-        # non-overlapping, no gap
-        left = self.rng[:5]
-        right = self.rng[5:10]
-
-        the_union = left.union(right)
-        tm.assertIsInstance(the_union, DatetimeIndex)
-
-        # order does not matter
-        self.assert_index_equal(right.union(left), the_union)
-
-        # overlapping, but different offset
-        rng = date_range(START, END, freq=BMonthEnd())
-
-        the_union = self.rng.union(rng)
-        tm.assertIsInstance(the_union, DatetimeIndex)
-
-    def test_outer_join(self):
-        # should just behave as union
-
-        # overlapping
-        left = self.rng[:10]
-        right = self.rng[5:10]
-
-        the_join = left.join(right, how='outer')
-        tm.assertIsInstance(the_join, DatetimeIndex)
-
-        # non-overlapping, gap in middle
-        left = self.rng[:5]
-        right = self.rng[10:]
-
-        the_join = left.join(right, how='outer')
-        tm.assertIsInstance(the_join, DatetimeIndex)
-        self.assertIsNone(the_join.freq)
-
-        # non-overlapping, no gap
-        left = self.rng[:5]
-        right = self.rng[5:10]
-
-        the_join = left.join(right, how='outer')
-        tm.assertIsInstance(the_join, DatetimeIndex)
-
-        # overlapping, but different offset
-        rng = date_range(START, END, freq=BMonthEnd())
-
-        the_join = self.rng.join(rng, how='outer')
-        tm.assertIsInstance(the_join, DatetimeIndex)
-        self.assertIsNone(the_join.freq)
-
-    def test_intersection_bug(self):
-        # GH #771
-        a = cdate_range('11/30/2011', '12/31/2011')
-        b = cdate_range('12/10/2011', '12/20/2011')
-        result = a.intersection(b)
-        self.assert_index_equal(result, b)
-
-    def test_summary(self):
-        self.rng.summary()
-        self.rng[2:2].summary()
-
-    def test_summary_pytz(self):
-        tm._skip_if_no_pytz()
-        import pytz
-        cdate_range('1/1/2005', '1/1/2009', tz=pytz.utc).summary()
-
-    def test_summary_dateutil(self):
-        tm._skip_if_no_dateutil()
-        import dateutil
-        cdate_range('1/1/2005', '1/1/2009', tz=dateutil.tz.tzutc()).summary()
-
     def test_misc(self):
         end = datetime(2009, 5, 13)
         dr = cdate_range(end=end, periods=20)
@@ -901,9 +530,6 @@ class TestCustomDateRange(tm.TestCase):
         self.assertRaises(ValueError, cdate_range, badly_formed_date,
                           badly_formed_date)
 
-    def test_equals(self):
-        self.assertFalse(self.rng.equals(list(self.rng)))
-
     def test_daterange_bug_456(self):
         # GH #456
         rng1 = cdate_range('12/5/2011', '12/5/2011')
diff --git a/pandas/tests/indexes/datetimes/test_ops.py b/pandas/tests/indexes/datetimes/test_ops.py
index c7cdcd931..63bf07ec0 100644
--- a/pandas/tests/indexes/datetimes/test_ops.py
+++ b/pandas/tests/indexes/datetimes/test_ops.py
@@ -6,13 +6,17 @@ import pandas as pd
 import pandas.tslib as tslib
 import pandas.util.testing as tm
 from pandas.core.common import PerformanceWarning
+from pandas.tseries.index import cdate_range
 from pandas import (DatetimeIndex, PeriodIndex, Series, Timestamp, Timedelta,
                     date_range, TimedeltaIndex, _np_version_under1p10, Index,
-                    datetime, Float64Index, offsets)
-
+                    datetime, Float64Index, offsets, bdate_range)
+from pandas.tseries.offsets import BMonthEnd, CDay, BDay
 from pandas.tests.test_base import Ops
 
 
+START, END = datetime(2009, 1, 1), datetime(2010, 1, 1)
+
+
 class TestDatetimeIndexOps(Ops):
     tz = [None, 'UTC', 'Asia/Tokyo', 'US/Eastern', 'dateutil/Asia/Singapore',
           'dateutil/US/Pacific']
@@ -1071,9 +1075,6 @@ class TestDatetimeIndex(tm.TestCase):
                             assert_func(klass([x - op for x in s]), s - op)
                             assert_func(klass([op + x for x in s]), op + s)
 
-
-class TestTslib(tm.TestCase):
-
     def test_shift_months(self):
         s = DatetimeIndex([Timestamp('2000-01-05 00:15:00'), Timestamp(
             '2000-01-31 00:23:00'), Timestamp('2000-01-01'), Timestamp(
@@ -1085,3 +1086,187 @@ class TestTslib(tm.TestCase):
                 expected = DatetimeIndex([x + offsets.DateOffset(
                     years=years, months=months) for x in s])
                 tm.assert_index_equal(actual, expected)
+
+
+class TestBusinessDatetimeIndex(tm.TestCase):
+
+    def setUp(self):
+        self.rng = bdate_range(START, END)
+
+    def test_comparison(self):
+        d = self.rng[10]
+
+        comp = self.rng > d
+        self.assertTrue(comp[11])
+        self.assertFalse(comp[9])
+
+    def test_pickle_unpickle(self):
+        unpickled = self.round_trip_pickle(self.rng)
+        self.assertIsNotNone(unpickled.offset)
+
+    def test_copy(self):
+        cp = self.rng.copy()
+        repr(cp)
+        self.assert_index_equal(cp, self.rng)
+
+    def test_repr(self):
+        # only really care that it works
+        repr(self.rng)
+
+    def test_getitem(self):
+        smaller = self.rng[:5]
+        exp = DatetimeIndex(self.rng.view(np.ndarray)[:5])
+        self.assert_index_equal(smaller, exp)
+
+        self.assertEqual(smaller.offset, self.rng.offset)
+
+        sliced = self.rng[::5]
+        self.assertEqual(sliced.offset, BDay() * 5)
+
+        fancy_indexed = self.rng[[4, 3, 2, 1, 0]]
+        self.assertEqual(len(fancy_indexed), 5)
+        tm.assertIsInstance(fancy_indexed, DatetimeIndex)
+        self.assertIsNone(fancy_indexed.freq)
+
+        # 32-bit vs. 64-bit platforms
+        self.assertEqual(self.rng[4], self.rng[np.int_(4)])
+
+    def test_getitem_matplotlib_hackaround(self):
+        values = self.rng[:, None]
+        expected = self.rng.values[:, None]
+        self.assert_numpy_array_equal(values, expected)
+
+    def test_shift(self):
+        shifted = self.rng.shift(5)
+        self.assertEqual(shifted[0], self.rng[5])
+        self.assertEqual(shifted.offset, self.rng.offset)
+
+        shifted = self.rng.shift(-5)
+        self.assertEqual(shifted[5], self.rng[0])
+        self.assertEqual(shifted.offset, self.rng.offset)
+
+        shifted = self.rng.shift(0)
+        self.assertEqual(shifted[0], self.rng[0])
+        self.assertEqual(shifted.offset, self.rng.offset)
+
+        rng = date_range(START, END, freq=BMonthEnd())
+        shifted = rng.shift(1, freq=BDay())
+        self.assertEqual(shifted[0], rng[0] + BDay())
+
+    def test_summary(self):
+        self.rng.summary()
+        self.rng[2:2].summary()
+
+    def test_summary_pytz(self):
+        tm._skip_if_no_pytz()
+        import pytz
+        bdate_range('1/1/2005', '1/1/2009', tz=pytz.utc).summary()
+
+    def test_summary_dateutil(self):
+        tm._skip_if_no_dateutil()
+        import dateutil
+        bdate_range('1/1/2005', '1/1/2009', tz=dateutil.tz.tzutc()).summary()
+
+    def test_equals(self):
+        self.assertFalse(self.rng.equals(list(self.rng)))
+
+    def test_identical(self):
+        t1 = self.rng.copy()
+        t2 = self.rng.copy()
+        self.assertTrue(t1.identical(t2))
+
+        # name
+        t1 = t1.rename('foo')
+        self.assertTrue(t1.equals(t2))
+        self.assertFalse(t1.identical(t2))
+        t2 = t2.rename('foo')
+        self.assertTrue(t1.identical(t2))
+
+        # freq
+        t2v = Index(t2.values)
+        self.assertTrue(t1.equals(t2v))
+        self.assertFalse(t1.identical(t2v))
+
+
+class TestCustomDatetimeIndex(tm.TestCase):
+
+    def setUp(self):
+        self.rng = cdate_range(START, END)
+
+    def test_comparison(self):
+        d = self.rng[10]
+
+        comp = self.rng > d
+        self.assertTrue(comp[11])
+        self.assertFalse(comp[9])
+
+    def test_copy(self):
+        cp = self.rng.copy()
+        repr(cp)
+        self.assert_index_equal(cp, self.rng)
+
+    def test_repr(self):
+        # only really care that it works
+        repr(self.rng)
+
+    def test_getitem(self):
+        smaller = self.rng[:5]
+        exp = DatetimeIndex(self.rng.view(np.ndarray)[:5])
+        self.assert_index_equal(smaller, exp)
+        self.assertEqual(smaller.offset, self.rng.offset)
+
+        sliced = self.rng[::5]
+        self.assertEqual(sliced.offset, CDay() * 5)
+
+        fancy_indexed = self.rng[[4, 3, 2, 1, 0]]
+        self.assertEqual(len(fancy_indexed), 5)
+        tm.assertIsInstance(fancy_indexed, DatetimeIndex)
+        self.assertIsNone(fancy_indexed.freq)
+
+        # 32-bit vs. 64-bit platforms
+        self.assertEqual(self.rng[4], self.rng[np.int_(4)])
+
+    def test_getitem_matplotlib_hackaround(self):
+        values = self.rng[:, None]
+        expected = self.rng.values[:, None]
+        self.assert_numpy_array_equal(values, expected)
+
+    def test_shift(self):
+
+        shifted = self.rng.shift(5)
+        self.assertEqual(shifted[0], self.rng[5])
+        self.assertEqual(shifted.offset, self.rng.offset)
+
+        shifted = self.rng.shift(-5)
+        self.assertEqual(shifted[5], self.rng[0])
+        self.assertEqual(shifted.offset, self.rng.offset)
+
+        shifted = self.rng.shift(0)
+        self.assertEqual(shifted[0], self.rng[0])
+        self.assertEqual(shifted.offset, self.rng.offset)
+
+        with tm.assert_produces_warning(PerformanceWarning):
+            rng = date_range(START, END, freq=BMonthEnd())
+            shifted = rng.shift(1, freq=CDay())
+            self.assertEqual(shifted[0], rng[0] + CDay())
+
+    def test_pickle_unpickle(self):
+        unpickled = self.round_trip_pickle(self.rng)
+        self.assertIsNotNone(unpickled.offset)
+
+    def test_summary(self):
+        self.rng.summary()
+        self.rng[2:2].summary()
+
+    def test_summary_pytz(self):
+        tm._skip_if_no_pytz()
+        import pytz
+        cdate_range('1/1/2005', '1/1/2009', tz=pytz.utc).summary()
+
+    def test_summary_dateutil(self):
+        tm._skip_if_no_dateutil()
+        import dateutil
+        cdate_range('1/1/2005', '1/1/2009', tz=dateutil.tz.tzutc()).summary()
+
+    def test_equals(self):
+        self.assertFalse(self.rng.equals(list(self.rng)))
diff --git a/pandas/tests/indexes/datetimes/test_setops.py b/pandas/tests/indexes/datetimes/test_setops.py
index 7777de869..7da660a95 100644
--- a/pandas/tests/indexes/datetimes/test_setops.py
+++ b/pandas/tests/indexes/datetimes/test_setops.py
@@ -4,8 +4,12 @@ import numpy as np
 
 import pandas as pd
 import pandas.util.testing as tm
+from pandas.tseries.index import cdate_range
 from pandas import (DatetimeIndex, date_range, Series, bdate_range, DataFrame,
                     Int64Index, Index)
+from pandas.tseries.offsets import Minute, BMonthEnd, MonthEnd
+
+START, END = datetime(2009, 1, 1), datetime(2010, 1, 1)
 
 
 class TestDatetimeIndex(tm.TestCase):
@@ -185,3 +189,223 @@ class TestDatetimeIndex(tm.TestCase):
 
         result = dti.join(empty)
         tm.assertIsInstance(result, DatetimeIndex)
+
+
+class TestBusinessDatetimeIndex(tm.TestCase):
+
+    def setUp(self):
+        self.rng = bdate_range(START, END)
+
+    def test_union(self):
+        # overlapping
+        left = self.rng[:10]
+        right = self.rng[5:10]
+
+        the_union = left.union(right)
+        tm.assertIsInstance(the_union, DatetimeIndex)
+
+        # non-overlapping, gap in middle
+        left = self.rng[:5]
+        right = self.rng[10:]
+
+        the_union = left.union(right)
+        tm.assertIsInstance(the_union, Index)
+
+        # non-overlapping, no gap
+        left = self.rng[:5]
+        right = self.rng[5:10]
+
+        the_union = left.union(right)
+        tm.assertIsInstance(the_union, DatetimeIndex)
+
+        # order does not matter
+        tm.assert_index_equal(right.union(left), the_union)
+
+        # overlapping, but different offset
+        rng = date_range(START, END, freq=BMonthEnd())
+
+        the_union = self.rng.union(rng)
+        tm.assertIsInstance(the_union, DatetimeIndex)
+
+    def test_outer_join(self):
+        # should just behave as union
+
+        # overlapping
+        left = self.rng[:10]
+        right = self.rng[5:10]
+
+        the_join = left.join(right, how='outer')
+        tm.assertIsInstance(the_join, DatetimeIndex)
+
+        # non-overlapping, gap in middle
+        left = self.rng[:5]
+        right = self.rng[10:]
+
+        the_join = left.join(right, how='outer')
+        tm.assertIsInstance(the_join, DatetimeIndex)
+        self.assertIsNone(the_join.freq)
+
+        # non-overlapping, no gap
+        left = self.rng[:5]
+        right = self.rng[5:10]
+
+        the_join = left.join(right, how='outer')
+        tm.assertIsInstance(the_join, DatetimeIndex)
+
+        # overlapping, but different offset
+        rng = date_range(START, END, freq=BMonthEnd())
+
+        the_join = self.rng.join(rng, how='outer')
+        tm.assertIsInstance(the_join, DatetimeIndex)
+        self.assertIsNone(the_join.freq)
+
+    def test_union_not_cacheable(self):
+        rng = date_range('1/1/2000', periods=50, freq=Minute())
+        rng1 = rng[10:]
+        rng2 = rng[:25]
+        the_union = rng1.union(rng2)
+        self.assert_index_equal(the_union, rng)
+
+        rng1 = rng[10:]
+        rng2 = rng[15:35]
+        the_union = rng1.union(rng2)
+        expected = rng[10:]
+        self.assert_index_equal(the_union, expected)
+
+    def test_intersection(self):
+        rng = date_range('1/1/2000', periods=50, freq=Minute())
+        rng1 = rng[10:]
+        rng2 = rng[:25]
+        the_int = rng1.intersection(rng2)
+        expected = rng[10:25]
+        self.assert_index_equal(the_int, expected)
+        tm.assertIsInstance(the_int, DatetimeIndex)
+        self.assertEqual(the_int.offset, rng.offset)
+
+        the_int = rng1.intersection(rng2.view(DatetimeIndex))
+        self.assert_index_equal(the_int, expected)
+
+        # non-overlapping
+        the_int = rng[:10].intersection(rng[10:])
+        expected = DatetimeIndex([])
+        self.assert_index_equal(the_int, expected)
+
+    def test_intersection_bug(self):
+        # GH #771
+        a = bdate_range('11/30/2011', '12/31/2011')
+        b = bdate_range('12/10/2011', '12/20/2011')
+        result = a.intersection(b)
+        self.assert_index_equal(result, b)
+
+    def test_month_range_union_tz_pytz(self):
+        tm._skip_if_no_pytz()
+        from pytz import timezone
+        tz = timezone('US/Eastern')
+
+        early_start = datetime(2011, 1, 1)
+        early_end = datetime(2011, 3, 1)
+
+        late_start = datetime(2011, 3, 1)
+        late_end = datetime(2011, 5, 1)
+
+        early_dr = date_range(start=early_start, end=early_end, tz=tz,
+                              freq=MonthEnd())
+        late_dr = date_range(start=late_start, end=late_end, tz=tz,
+                             freq=MonthEnd())
+
+        early_dr.union(late_dr)
+
+    def test_month_range_union_tz_dateutil(self):
+        tm._skip_if_windows_python_3()
+        tm._skip_if_no_dateutil()
+        from pandas.tslib import _dateutil_gettz as timezone
+        tz = timezone('US/Eastern')
+
+        early_start = datetime(2011, 1, 1)
+        early_end = datetime(2011, 3, 1)
+
+        late_start = datetime(2011, 3, 1)
+        late_end = datetime(2011, 5, 1)
+
+        early_dr = date_range(start=early_start, end=early_end, tz=tz,
+                              freq=MonthEnd())
+        late_dr = date_range(start=late_start, end=late_end, tz=tz,
+                             freq=MonthEnd())
+
+        early_dr.union(late_dr)
+
+
+class TestCustomDatetimeIndex(tm.TestCase):
+
+    def setUp(self):
+        self.rng = cdate_range(START, END)
+
+    def test_union(self):
+        # overlapping
+        left = self.rng[:10]
+        right = self.rng[5:10]
+
+        the_union = left.union(right)
+        tm.assertIsInstance(the_union, DatetimeIndex)
+
+        # non-overlapping, gap in middle
+        left = self.rng[:5]
+        right = self.rng[10:]
+
+        the_union = left.union(right)
+        tm.assertIsInstance(the_union, Index)
+
+        # non-overlapping, no gap
+        left = self.rng[:5]
+        right = self.rng[5:10]
+
+        the_union = left.union(right)
+        tm.assertIsInstance(the_union, DatetimeIndex)
+
+        # order does not matter
+        self.assert_index_equal(right.union(left), the_union)
+
+        # overlapping, but different offset
+        rng = date_range(START, END, freq=BMonthEnd())
+
+        the_union = self.rng.union(rng)
+        tm.assertIsInstance(the_union, DatetimeIndex)
+
+    def test_outer_join(self):
+        # should just behave as union
+
+        # overlapping
+        left = self.rng[:10]
+        right = self.rng[5:10]
+
+        the_join = left.join(right, how='outer')
+        tm.assertIsInstance(the_join, DatetimeIndex)
+
+        # non-overlapping, gap in middle
+        left = self.rng[:5]
+        right = self.rng[10:]
+
+        the_join = left.join(right, how='outer')
+        tm.assertIsInstance(the_join, DatetimeIndex)
+        self.assertIsNone(the_join.freq)
+
+        # non-overlapping, no gap
+        left = self.rng[:5]
+        right = self.rng[5:10]
+
+        the_join = left.join(right, how='outer')
+        tm.assertIsInstance(the_join, DatetimeIndex)
+
+        # overlapping, but different offset
+        rng = date_range(START, END, freq=BMonthEnd())
+
+        the_join = self.rng.join(rng, how='outer')
+        tm.assertIsInstance(the_join, DatetimeIndex)
+        self.assertIsNone(the_join.freq)
+
+    def test_intersection_bug(self):
+        # GH #771
+        a = cdate_range('11/30/2011', '12/31/2011')
+        b = cdate_range('12/10/2011', '12/20/2011')
+        result = a.intersection(b)
+        self.assert_index_equal(result, b)
diff --git a/pandas/tests/indexes/datetimes/test_tools.py b/pandas/tests/indexes/datetimes/test_tools.py
index bf1f82b90..af7499631 100644
--- a/pandas/tests/indexes/datetimes/test_tools.py
+++ b/pandas/tests/indexes/datetimes/test_tools.py
@@ -12,7 +12,6 @@ import pandas as pd
 from pandas import tslib
 from pandas.tseries import tools
 from pandas.tseries.tools import normalize_date
-from pandas.tseries.util import pivot_annual, isleapyear
 from pandas.compat import lmap
 from pandas.compat.numpy import np_array_datetime64_compat
 from pandas.types.common import is_datetime64_ns_dtype
@@ -1382,7 +1381,7 @@ class TestDatetimeParsingWrappers(tm.TestCase):
                 raise Exception(date_str)
 
 
-class TestTsUtil(tm.TestCase):
+class TestArrayToDatetime(tm.TestCase):
 
     def test_try_parse_dates(self):
         from dateutil.parser import parse
@@ -1392,8 +1391,6 @@ class TestTsUtil(tm.TestCase):
         expected = [parse(d, dayfirst=True) for d in arr]
         self.assertTrue(np.array_equal(result, expected))
 
-
-class TestArrayToDatetime(tm.TestCase):
     def test_parsing_valid_dates(self):
         arr = np.array(['01-01-2013', '01-02-2013'], dtype=object)
         self.assert_numpy_array_equal(
@@ -1508,109 +1505,6 @@ class TestArrayToDatetime(tm.TestCase):
         )
 
 
-class TestPivotAnnual(tm.TestCase):
-    """
-    New pandas of scikits.timeseries pivot_annual
-    """
-
-    def test_daily(self):
-        rng = date_range('1/1/2000', '12/31/2004', freq='D')
-        ts = Series(np.random.randn(len(rng)), index=rng)
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            annual = pivot_annual(ts, 'D')
-
-        doy = ts.index.dayofyear
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            doy[(~isleapyear(ts.index.year)) & (doy >= 60)] += 1
-
-        for i in range(1, 367):
-            subset = ts[doy == i]
-            subset.index = [x.year for x in subset.index]
-
-            result = annual[i].dropna()
-            tm.assert_series_equal(result, subset, check_names=False)
-            self.assertEqual(result.name, i)
-
-        # check leap days
-        leaps = ts[(ts.index.month == 2) & (ts.index.day == 29)]
-        day = leaps.index.dayofyear[0]
-        leaps.index = leaps.index.year
-        leaps.name = 60
-        tm.assert_series_equal(annual[day].dropna(), leaps)
-
-    def test_hourly(self):
-        rng_hourly = date_range('1/1/1994', periods=(18 * 8760 + 4 * 24),
-                                freq='H')
-        data_hourly = np.random.randint(100, 350, rng_hourly.size)
-        ts_hourly = Series(data_hourly, index=rng_hourly)
-
-        grouped = ts_hourly.groupby(ts_hourly.index.year)
-        hoy = grouped.apply(lambda x: x.reset_index(drop=True))
-        hoy = hoy.index.droplevel(0).values
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            hoy[~isleapyear(ts_hourly.index.year) & (hoy >= 1416)] += 24
-        hoy += 1
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            annual = pivot_annual(ts_hourly)
-
-        ts_hourly = ts_hourly.astype(float)
-        for i in [1, 1416, 1417, 1418, 1439, 1440, 1441, 8784]:
-            subset = ts_hourly[hoy == i]
-            subset.index = [x.year for x in subset.index]
-
-            result = annual[i].dropna()
-            tm.assert_series_equal(result, subset, check_names=False)
-            self.assertEqual(result.name, i)
-
-        leaps = ts_hourly[(ts_hourly.index.month == 2) & (
-            ts_hourly.index.day == 29) & (ts_hourly.index.hour == 0)]
-        hour = leaps.index.dayofyear[0] * 24 - 23
-        leaps.index = leaps.index.year
-        leaps.name = 1417
-        tm.assert_series_equal(annual[hour].dropna(), leaps)
-
-    def test_weekly(self):
-        pass
-
-    def test_monthly(self):
-        rng = date_range('1/1/2000', '12/31/2004', freq='M')
-        ts = Series(np.random.randn(len(rng)), index=rng)
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            annual = pivot_annual(ts, 'M')
-
-        month = ts.index.month
-        for i in range(1, 13):
-            subset = ts[month == i]
-            subset.index = [x.year for x in subset.index]
-            result = annual[i].dropna()
-            tm.assert_series_equal(result, subset, check_names=False)
-            self.assertEqual(result.name, i)
-
-    def test_period_monthly(self):
-        pass
-
-    def test_period_daily(self):
-        pass
-
-    def test_period_weekly(self):
-        pass
-
-    def test_isleapyear_deprecate(self):
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            self.assertTrue(isleapyear(2000))
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            self.assertFalse(isleapyear(2001))
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            self.assertTrue(isleapyear(2004))
-
-
 def test_normalize_date():
     value = date(2012, 9, 7)
 
diff --git a/pandas/tools/tests/test_pivot.py b/pandas/tools/tests/test_pivot.py
index 40b46c541..7f2bb7e72 100644
--- a/pandas/tools/tests/test_pivot.py
+++ b/pandas/tools/tests/test_pivot.py
@@ -3,11 +3,12 @@ from datetime import datetime, date, timedelta
 import numpy as np
 
 import pandas as pd
-from pandas import DataFrame, Series, Index, MultiIndex, Grouper
+from pandas import DataFrame, Series, Index, MultiIndex, Grouper, date_range
 from pandas.tools.merge import concat
 from pandas.tools.pivot import pivot_table, crosstab
 from pandas.compat import range, product
 import pandas.util.testing as tm
+from pandas.tseries.util import pivot_annual, isleapyear
 
 
 class TestPivotTable(tm.TestCase):
@@ -1319,3 +1320,106 @@ class TestCrosstab(tm.TestCase):
                                 index=expected_index,
                                 columns=expected_column)
         tm.assert_frame_equal(result, expected)
+
+
+class TestPivotAnnual(tm.TestCase):
+    """
+    New pandas of scikits.timeseries pivot_annual
+    """
+
+    def test_daily(self):
+        rng = date_range('1/1/2000', '12/31/2004', freq='D')
+        ts = Series(np.random.randn(len(rng)), index=rng)
+
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            annual = pivot_annual(ts, 'D')
+
+        doy = ts.index.dayofyear
+
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            doy[(~isleapyear(ts.index.year)) & (doy >= 60)] += 1
+
+        for i in range(1, 367):
+            subset = ts[doy == i]
+            subset.index = [x.year for x in subset.index]
+
+            result = annual[i].dropna()
+            tm.assert_series_equal(result, subset, check_names=False)
+            self.assertEqual(result.name, i)
+
+        # check leap days
+        leaps = ts[(ts.index.month == 2) & (ts.index.day == 29)]
+        day = leaps.index.dayofyear[0]
+        leaps.index = leaps.index.year
+        leaps.name = 60
+        tm.assert_series_equal(annual[day].dropna(), leaps)
+
+    def test_hourly(self):
+        rng_hourly = date_range('1/1/1994', periods=(18 * 8760 + 4 * 24),
+                                freq='H')
+        data_hourly = np.random.randint(100, 350, rng_hourly.size)
+        ts_hourly = Series(data_hourly, index=rng_hourly)
+
+        grouped = ts_hourly.groupby(ts_hourly.index.year)
+        hoy = grouped.apply(lambda x: x.reset_index(drop=True))
+        hoy = hoy.index.droplevel(0).values
+
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            hoy[~isleapyear(ts_hourly.index.year) & (hoy >= 1416)] += 24
+        hoy += 1
+
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            annual = pivot_annual(ts_hourly)
+
+        ts_hourly = ts_hourly.astype(float)
+        for i in [1, 1416, 1417, 1418, 1439, 1440, 1441, 8784]:
+            subset = ts_hourly[hoy == i]
+            subset.index = [x.year for x in subset.index]
+
+            result = annual[i].dropna()
+            tm.assert_series_equal(result, subset, check_names=False)
+            self.assertEqual(result.name, i)
+
+        leaps = ts_hourly[(ts_hourly.index.month == 2) & (
+            ts_hourly.index.day == 29) & (ts_hourly.index.hour == 0)]
+        hour = leaps.index.dayofyear[0] * 24 - 23
+        leaps.index = leaps.index.year
+        leaps.name = 1417
+        tm.assert_series_equal(annual[hour].dropna(), leaps)
+
+    def test_weekly(self):
+        pass
+
+    def test_monthly(self):
+        rng = date_range('1/1/2000', '12/31/2004', freq='M')
+        ts = Series(np.random.randn(len(rng)), index=rng)
+
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            annual = pivot_annual(ts, 'M')
+
+        month = ts.index.month
+        for i in range(1, 13):
+            subset = ts[month == i]
+            subset.index = [x.year for x in subset.index]
+            result = annual[i].dropna()
+            tm.assert_series_equal(result, subset, check_names=False)
+            self.assertEqual(result.name, i)
+
+    def test_period_monthly(self):
+        pass
+
+    def test_period_daily(self):
+        pass
+
+    def test_period_weekly(self):
+        pass
+
+    def test_isleapyear_deprecate(self):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            self.assertTrue(isleapyear(2000))
+
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            self.assertFalse(isleapyear(2001))
+
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            self.assertTrue(isleapyear(2004))
diff --git a/setup.py b/setup.py
index 4d6bb76fd..3c2617da1 100755
--- a/setup.py
+++ b/setup.py
@@ -642,6 +642,8 @@ setup(name=DISTNAME,
                 'pandas.tests.frame',
                 'pandas.tests.indexes',
                 'pandas.tests.indexes.datetimes',
+                'pandas.tests.indexes.timedeltas',
+                'pandas.tests.indexes.period',
                 'pandas.tests.groupby',
                 'pandas.tests.series',
                 'pandas.tests.formats',

commit 0940b78a0568020ca08ef02131f57e3b6285cf3d
Author: Chang She <chang@lambdafoundry.com>
Date:   Sun Jun 24 14:36:31 2012 -0400

    BUG: plot mixed frequencies #1517

diff --git a/pandas/tools/plotting.py b/pandas/tools/plotting.py
index 8cf584155..30505cfc4 100644
--- a/pandas/tools/plotting.py
+++ b/pandas/tools/plotting.py
@@ -485,13 +485,16 @@ class MPLPlot(object):
 
     _need_to_set_index = False
 
-    def _get_xticks(self):
+    def _get_xticks(self, convert_period=False):
         index = self.data.index
         is_datetype = index.inferred_type in ('datetime', 'date',
                                               'datetime64')
 
         if self.use_index:
-            if index.is_numeric() or is_datetype:
+            if convert_period and isinstance(index, PeriodIndex):
+                index = index.to_timestamp()
+                x = index._mpl_repr()
+            elif index.is_numeric() or is_datetype:
                 """
                 Matplotlib supports numeric values or datetime objects as
                 xaxis values. Taking LBYL approach here, by the time
@@ -594,19 +597,14 @@ class LinePlot(MPLPlot):
     def __init__(self, data, **kwargs):
         MPLPlot.__init__(self, data, **kwargs)
 
-    @property
-    def has_ts_index(self):
-        # TODO refactor this whole regular/irregular kludge
+    def _index_freq(self):
         from pandas.core.frame import DataFrame
         if isinstance(self.data, (Series, DataFrame)):
-            ax, _ = self._get_ax_and_style(0)
             freq = (getattr(self.data.index, 'freq', None)
-                    or getattr(self.data.index, 'inferred_freq', None)
-                    or getattr(ax, 'freq', None))
-            return (freq is not None) and  self._has_dynamic_index_freq(freq)
-        return False
+                    or getattr(self.data.index, 'inferred_freq', None))
+            return freq
 
-    def _has_dynamic_index_freq(self, freq):
+    def _is_dynamic_freq(self, freq):
         if isinstance(freq, DateOffset):
             freq = freq.rule_code
         else:
@@ -614,13 +612,26 @@ class LinePlot(MPLPlot):
         freq = get_period_alias(freq)
         return freq is not None
 
+    def _use_dynamic_x(self):
+        freq = self._index_freq()
+
+        ax, _ = self._get_ax_and_style(0)
+        ax_freq = getattr(ax, 'freq', None)
+        if freq is None: # convert irregular if axes has freq info
+            freq = ax_freq
+        else: # do not use tsplot if irregular was plotted first
+            if (ax_freq is None) and (len(ax.get_lines()) > 0):
+                return False
+
+        return (freq is not None) and self._is_dynamic_freq(freq)
+
     def _make_plot(self):
         # this is slightly deceptive
-        if self.use_index and self.has_ts_index:
+        if self.use_index and self._use_dynamic_x():
             data = self._maybe_convert_index(self.data)
             self._make_ts_plot(data)
         else:
-            x = self._get_xticks()
+            x = self._get_xticks(convert_period=True)
 
             plotf = self._get_plot_function()
 
@@ -649,6 +660,8 @@ class LinePlot(MPLPlot):
         if (isinstance(data.index, DatetimeIndex) and
             isinstance(data, DataFrame)):
             freq = getattr(data.index, 'freqstr', None)
+            if isinstance(freq, DateOffset):
+                freq = freq.rule_code
 
             freq = get_period_alias(freq)
 
@@ -659,9 +672,6 @@ class LinePlot(MPLPlot):
                 ax, _ = self._get_ax_and_style(0)
                 freq = getattr(ax, 'freq', None)
 
-            if isinstance(freq, DateOffset):
-                freq = freq.rule_code
-
             data = DataFrame(data.values,
                              index=data.index.to_period(freq=freq),
                              columns=data.columns)
@@ -699,7 +709,7 @@ class LinePlot(MPLPlot):
             else:
                 self.axes[0].legend(loc='best')
 
-        condition = (not self.has_ts_index
+        condition = (not self._use_dynamic_x
                      and df.index.is_all_dates
                      and not self.subplots
                      or (self.subplots and self.sharex))
diff --git a/pandas/tseries/plotting.py b/pandas/tseries/plotting.py
index 7f4b4e513..2e0506e6c 100644
--- a/pandas/tseries/plotting.py
+++ b/pandas/tseries/plotting.py
@@ -43,32 +43,30 @@ def tsplot(series, plotf, **kwargs):
 
     """
     # Used inferred freq is possible, need a test case for inferred
-    freq = getattr(series.index, 'freq', None)
-    if freq is None:
-        freq = getattr(series.index, 'inferred_freq', None)
-
     if 'ax' in kwargs:
         ax = kwargs.pop('ax')
     else:
         import matplotlib.pyplot as plt
         ax = plt.gca()
 
-    if freq is None:
-        freq = getattr(ax, 'freq', None)
-
-    if isinstance(freq, DateOffset):
-        freq = freq.rule_code
+    freq = _get_freq(ax, series)
+    # resample against axes freq if necessary
+    if freq is None: # pragma: no cover
+        raise ValueError('Cannot use dynamic axis without frequency info')
     else:
-        freq = frequencies.get_base_alias(freq)
+        ax_freq = getattr(ax, 'freq', None)
+        if (ax_freq is not None) and (freq != ax_freq):
+            if frequencies.is_subperiod(freq, ax_freq): # downsample
+                how = kwargs.pop('how', 'first')
+                series = series.resample(ax_freq, how=how)
+            elif frequencies.is_superperiod(freq, ax_freq):
+                series = series.resample(ax_freq)
+            freq = ax_freq
 
-    freq = frequencies.get_period_alias(freq)
     # Convert DatetimeIndex to PeriodIndex
     if isinstance(series.index, DatetimeIndex):
         series = series.to_period(freq=freq)
 
-    if freq != series.index.freq:
-        series = series.asfreq(freq)
-
     style = kwargs.pop('style', None)
 
     # Specialized ts plotting attributes for Axes
@@ -81,13 +79,7 @@ def tsplot(series, plotf, **kwargs):
     ax.date_axis_info = None
 
     # format args and lot
-    mask = isnull(series)
-    if mask.any():
-        masked_array = np.ma.array(series.values)
-        masked_array = np.ma.masked_where(mask, masked_array)
-        args = [series.index, masked_array]
-    else:
-        args = [series.index, series]
+    args = _maybe_mask(series)
 
     if style is not None:
         args.append(style)
@@ -101,6 +93,38 @@ def tsplot(series, plotf, **kwargs):
 
     return ax
 
+def _maybe_mask(series):
+    mask = isnull(series)
+    if mask.any():
+        masked_array = np.ma.array(series.values)
+        masked_array = np.ma.masked_where(mask, masked_array)
+        args = [series.index, masked_array]
+    else:
+        args = [series.index, series]
+    return args
+
+def _get_freq(ax, series):
+    # get frequency from data
+    freq = getattr(series.index, 'freq', None)
+    if freq is None:
+        freq = getattr(series.index, 'inferred_freq', None)
+
+    ax_freq = getattr(ax, 'freq', None)
+
+    # use axes freq if no data freq
+    if freq is None:
+        freq = ax_freq
+
+    # get the period frequency
+    if isinstance(freq, DateOffset):
+        freq = freq.rule_code
+    else:
+        freq = frequencies.get_base_alias(freq)
+
+    freq = frequencies.get_period_alias(freq)
+
+    return freq
+
 def _get_xlim(lines):
     left, right = np.inf, -np.inf
     for l in lines:
diff --git a/pandas/tseries/tests/test_plotting.py b/pandas/tseries/tests/test_plotting.py
index 9331d79ef..e0a8acacf 100644
--- a/pandas/tseries/tests/test_plotting.py
+++ b/pandas/tseries/tests/test_plotting.py
@@ -6,6 +6,7 @@ import nose
 
 import numpy as np
 from numpy.testing.decorators import slow
+from numpy.testing import assert_array_equal
 
 from pandas import Index, Series, DataFrame, isnull, notnull
 
@@ -52,17 +53,22 @@ class TestTSPlot(unittest.TestCase):
     def test_tsplot(self):
         from pandas.tseries.plotting import tsplot
         import matplotlib.pyplot as plt
+        plt.close('all')
+
         ax = plt.gca()
         ts = tm.makeTimeSeries()
         plot_ax = tsplot(ts, plt.Axes.plot)
         self.assert_(plot_ax == ax)
 
         f = lambda *args, **kwds: tsplot(s, plt.Axes.plot, *args, **kwds)
+        plt.close('all')
 
         for s in self.period_ser:
             _check_plot_works(f, s.index.freq, ax=ax, series=s)
+            plt.close('all')
         for s in self.datetime_ser:
             _check_plot_works(f, s.index.freq.rule_code, ax=ax, series=s)
+            plt.close('all')
 
         plt.close('all')
         ax = ts.plot(style='k')
@@ -442,7 +448,7 @@ class TestTSPlot(unittest.TestCase):
         self.assert_(axes[2].get_yaxis().get_ticks_position() == 'right')
 
     @slow
-    def test_mixed_freq(self):
+    def test_mixed_freq_regular_first(self):
         import matplotlib.pyplot as plt
         plt.close('all')
         s1 = tm.makeTimeSeries()
@@ -458,6 +464,58 @@ class TestTSPlot(unittest.TestCase):
         pidx = s1.index.to_period()
         self.assert_(left == pidx[0].ordinal)
         self.assert_(right == pidx[-1].ordinal)
+        plt.close('all')
+
+    @slow
+    def test_mixed_freq_irregular_first(self):
+        import matplotlib.pyplot as plt
+        plt.close('all')
+        s1 = tm.makeTimeSeries()
+        s2 = s1[[0, 5, 10, 11, 12, 13, 14, 15]]
+        s2.plot(style='g')
+        ax = s1.plot()
+        self.assert_(not hasattr(ax, 'freq'))
+        lines = ax.get_lines()
+        x1 = lines[0].get_xdata()
+        assert_array_equal(x1, s2.index.asobject.values)
+        x2 = lines[1].get_xdata()
+        assert_array_equal(x2, s1.index.asobject.values)
+        plt.close('all')
+
+    @slow
+    def test_mixed_freq_hf_first(self):
+        import matplotlib.pyplot as plt
+        plt.close('all')
+        idxh = date_range('1/1/1999', periods=365, freq='D')
+        idxl = date_range('1/1/1999', periods=12, freq='M')
+        high = Series(np.random.randn(len(idxh)), idxh)
+        low = Series(np.random.randn(len(idxl)), idxl)
+        high.plot()
+        ax = low.plot()
+        for l in ax.get_lines():
+            self.assert_(l.get_xdata().freq == 'D')
+
+    @slow
+    def test_mixed_freq_lf_first(self):
+        import matplotlib.pyplot as plt
+        plt.close('all')
+        idxh = date_range('1/1/1999', periods=365, freq='D')
+        idxl = date_range('1/1/1999', periods=12, freq='M')
+        high = Series(np.random.randn(len(idxh)), idxh)
+        low = Series(np.random.randn(len(idxl)), idxl)
+        low.plot()
+        ax = high.plot()
+        for l in ax.get_lines():
+            self.assert_(l.get_xdata().freq == 'M')
+
+    @slow
+    def test_mixed_freq_irreg_period(self):
+        ts = tm.makeTimeSeries()
+        irreg = ts[[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 16, 17, 18, 29]]
+        rng = period_range('1/3/2000', periods=30, freq='B')
+        ps = Series(np.random.randn(len(rng)), rng)
+        irreg.plot()
+        ps.plot()
 
 PNG_PATH = 'tmp.png'
 def _check_plot_works(f, freq=None, series=None, *args, **kwargs):
@@ -466,19 +524,22 @@ def _check_plot_works(f, freq=None, series=None, *args, **kwargs):
     fig = plt.gcf()
     plt.clf()
     ax = fig.add_subplot(211)
+    orig_ax = kwargs.pop('ax', plt.gca())
+    orig_axfreq = getattr(orig_ax, 'freq', None)
+
     ret = f(*args, **kwargs)
     assert(ret is not None)  # do something more intelligent
 
-    orig_ax = kwargs.pop('ax', plt.gca())
-    if series is not None: # non-business
+    ax = kwargs.pop('ax', plt.gca())
+    if series is not None:
         dfreq = series.index.freq
         if isinstance(dfreq, DateOffset):
             dfreq = dfreq.rule_code
-        #dfreq = frequencies.offset_to_period_alias(dfreq)
-        assert(orig_ax.freq == dfreq)
+        if orig_axfreq is None:
+            assert(ax.freq == dfreq)
 
-    if freq is not None:
-        assert(orig_ax.freq == freq)
+    if freq is not None and orig_axfreq is None:
+        assert(ax.freq == freq)
 
     ax = fig.add_subplot(212)
     try:

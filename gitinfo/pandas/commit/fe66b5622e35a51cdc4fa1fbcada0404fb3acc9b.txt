commit fe66b5622e35a51cdc4fa1fbcada0404fb3acc9b
Author: Paul Reidy <paul_reidy@outlook.com>
Date:   Sun Jan 7 15:27:16 2018 +0000

    BUG: show time values in repr of high precision DatetimeIndex (#19109)

diff --git a/doc/source/whatsnew/v0.23.0.txt b/doc/source/whatsnew/v0.23.0.txt
index 711b75aa9..07e633ded 100644
--- a/doc/source/whatsnew/v0.23.0.txt
+++ b/doc/source/whatsnew/v0.23.0.txt
@@ -375,7 +375,8 @@ Conversion
 - Bug in :class:`TimedeltaIndex` where division by a ``Series`` would return a ``TimedeltaIndex`` instead of a ``Series`` (issue:`19042`)
 - Bug in :class:`Series` with ``dtype='timedelta64[ns]`` where addition or subtraction of ``TimedeltaIndex`` could return a ``Series`` with an incorrect name (issue:`19043`)
 - Fixed bug where comparing :class:`DatetimeIndex` failed to raise ``TypeError`` when attempting to compare timezone-aware and timezone-naive datetimelike objects (:issue:`18162`)
--
+- Bug in :class:`DatetimeIndex` where the repr was not showing high-precision time values at the end of a day (e.g., 23:59:59.999999999) (:issue:`19030`)
+
 
 Indexing
 ^^^^^^^^
diff --git a/pandas/io/formats/format.py b/pandas/io/formats/format.py
index a4678e5b4..886a88756 100644
--- a/pandas/io/formats/format.py
+++ b/pandas/io/formats/format.py
@@ -2188,7 +2188,7 @@ def _is_dates_only(values):
     consider_values = values_int != iNaT
     one_day_nanos = (86400 * 1e9)
     even_days = np.logical_and(consider_values,
-                               values_int % one_day_nanos != 0).sum() == 0
+                               values_int % int(one_day_nanos) != 0).sum() == 0
     if even_days:
         return True
     return False
diff --git a/pandas/tests/io/formats/test_format.py b/pandas/tests/io/formats/test_format.py
index 23b42b612..b277d8256 100644
--- a/pandas/tests/io/formats/test_format.py
+++ b/pandas/tests/io/formats/test_format.py
@@ -883,6 +883,29 @@ class TestDataFrameFormatting(object):
                         '[10 rows x 2 columns]')
             assert repr(df) == expected
 
+    @pytest.mark.parametrize('start_date', [
+        '2017-01-01 23:59:59.999999999',
+        '2017-01-01 23:59:59.99999999',
+        '2017-01-01 23:59:59.9999999',
+        '2017-01-01 23:59:59.999999',
+        '2017-01-01 23:59:59.99999',
+        '2017-01-01 23:59:59.9999',
+    ])
+    def test_datetimeindex_highprecision(self, start_date):
+        # GH19030
+        # Check that high-precision time values for the end of day are
+        # included in repr for DatetimeIndex
+        df = DataFrame({'A': date_range(start=start_date,
+                                        freq='D', periods=5)})
+        result = str(df)
+        assert start_date in result
+
+        dti = date_range(start=start_date,
+                         freq='D', periods=5)
+        df = DataFrame({'A': range(5)}, index=dti)
+        result = str(df.index)
+        assert start_date in result
+
     def test_nonunicode_nonascii_alignment(self):
         df = DataFrame([["aa\xc3\xa4\xc3\xa4", 1], ["bbbb", 2]])
         rep_str = df.to_string()
@@ -1914,6 +1937,27 @@ class TestSeriesFormatting(object):
         result = str(s2.index)
         assert 'NaT' in result
 
+    @pytest.mark.parametrize('start_date', [
+        '2017-01-01 23:59:59.999999999',
+        '2017-01-01 23:59:59.99999999',
+        '2017-01-01 23:59:59.9999999',
+        '2017-01-01 23:59:59.999999',
+        '2017-01-01 23:59:59.99999',
+        '2017-01-01 23:59:59.9999'
+    ])
+    def test_datetimeindex_highprecision(self, start_date):
+        # GH19030
+        # Check that high-precision time values for the end of day are
+        # included in repr for DatetimeIndex
+        s1 = Series(date_range(start=start_date, freq='D', periods=5))
+        result = str(s1)
+        assert start_date in result
+
+        dti = date_range(start=start_date, freq='D', periods=5)
+        s2 = Series(3, index=dti)
+        result = str(s2.index)
+        assert start_date in result
+
     def test_timedelta64(self):
 
         from datetime import datetime, timedelta

commit 2098376f8b1fd5937d0a94aefed899b0aa46d9cf
Author: Adam Klein <adamklein@gmail.com>
Date:   Mon Jan 23 20:00:38 2012 -0500

    additional parsing, accessors, Instant->Timestamp

diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index 6173bdbc6..e8641544f 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -9,6 +9,8 @@ cdef extern from "datetime.h":
         # cdef char hastzinfo
         pass
 
+    void PyDateTime_IMPORT()
+
     int PyDateTime_GET_YEAR(datetime o)
     int PyDateTime_GET_MONTH(datetime o)
     int PyDateTime_GET_DAY(datetime o)
@@ -21,7 +23,6 @@ cdef extern from "datetime.h":
     int PyDateTime_TIME_GET_SECOND(datetime o)
     int PyDateTime_TIME_GET_MICROSECOND(datetime o)
     bint PyDateTime_Check(object o)
-    void PyDateTime_IMPORT()
     PyObject *PyDateTime_FromDateAndTime(int year, int month, int day, int hour,
                                          int minute, int second, int us)
 
@@ -50,6 +51,13 @@ cdef extern from "numpy/ndarrayobject.h":
         #NPY_FR_fs
         #NPY_FR_as
 
+    ctypedef enum NPY_CASTING:
+            NPY_NO_CASTING
+            NPY_EQUIV_CASTING
+            NPY_SAFE_CASTING
+            NPY_SAME_KIND_CASTING
+            NPY_UNSAFE_CASTING
+
     npy_datetime PyArray_DatetimeStructToDatetime(NPY_DATETIMEUNIT fr,
                                                   npy_datetimestruct *d)
 
@@ -57,6 +65,10 @@ cdef extern from "numpy/ndarrayobject.h":
                                           NPY_DATETIMEUNIT fr,
                                           npy_datetimestruct *result)
 
+cdef extern from "numpy/npy_common.h":
+
+    ctypedef unsigned char npy_bool
+
 cdef extern from "np_datetime.h":
 
     int convert_pydatetime_to_datetimestruct(PyObject *obj, npy_datetimestruct *out,
@@ -64,3 +76,17 @@ cdef extern from "np_datetime.h":
                                              int apply_tzinfo)
 
     int is_leapyear(int64_t year)
+
+
+cdef extern from "np_datetime_strings.h":
+
+    int parse_iso_8601_datetime(char *str, int len, NPY_DATETIMEUNIT unit,
+                                NPY_CASTING casting, npy_datetimestruct *out,
+                                npy_bool *out_local, NPY_DATETIMEUNIT *out_bestunit,
+                                npy_bool *out_special)
+
+    int make_iso_8601_datetime(npy_datetimestruct *dts, char *outstr, int outlen,
+                               int local, NPY_DATETIMEUNIT base, int tzoffset,
+                               NPY_CASTING casting)
+
+    int get_datetime_iso_8601_strlen(int local, NPY_DATETIMEUNIT base)
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index fde944e97..6f8135546 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -3,53 +3,107 @@ import numpy as np
 
 from numpy cimport int32_t, int64_t, import_array, ndarray
 from cpython cimport *
+from libc.stdlib cimport malloc, free
 
 # this is our datetime.pxd
 from datetime cimport *
+from util cimport is_integer_object
+
+# initialize numpy
+np.import_array()
+np.import_ufunc()
 
 # import datetime C API
 PyDateTime_IMPORT
 
-# initialize numpy
-import_array()
-
 # in numpy 1.7, will prob need this
 # numpy_pydatetime_import
 
 # Objects to support date/time arithmetic, inspired by the architecture of the
-# lubridate R package, to eventually replace most of pandas/core/datetools.py
+# lubridate R package, to eventually handle all datetime logic in pandas.
 # --------------------------------------------------------------------------------
 
-cdef class Instant:
+cdef class Timestamp:
     '''
     A timestamp (absolute moment in time) to microsecond resolution, in UTC.
     '''
     cdef:
-        int64_t timestamp
+        int64_t value
         npy_datetimestruct dts
 
-    def __init__(self, int64_t ts):
-        self.timestamp = ts
-
-        # decompose datetime64 to components
-        PyArray_DatetimeToDatetimeStruct(ts, NPY_FR_us, &self.dts)
+    def __init__(self, object ts):
+        """
+        Construct a timestamp that is datetime64-compatible from any of:
+            - int64 pyarray scalar object
+            - python int or long object
+            - iso8601 string object
+            - python datetime object
+        """
+        cdef:
+            Py_ssize_t strlen
+            npy_bool islocal, special
+            NPY_DATETIMEUNIT out_bestunit
+
+        if is_integer_object(ts) or PyInt_Check(ts) or PyLong_Check(ts):
+            self.value = ts
+            PyArray_DatetimeToDatetimeStruct(self.value, NPY_FR_us, &self.dts)
+        elif PyString_Check(ts):
+            parse_iso_8601_datetime(ts, len(ts), NPY_FR_us, NPY_UNSAFE_CASTING,
+                                    &self.dts, &islocal, &out_bestunit, &special)
+            self.value = PyArray_DatetimeStructToDatetime(NPY_FR_us, &self.dts)
+        elif PyDateTime_Check(ts):
+            convert_pydatetime_to_datetimestruct(<PyObject *>ts, &self.dts, 
+                                                 &out_bestunit, 1)
+            self.value = PyArray_DatetimeStructToDatetime(out_bestunit, &self.dts)
+        else:
+            raise ValueError("Could not construct Timestamp from argument")
 
     def __sub__(self, object other):
-        if isinstance(other, Instant):
-            if other.timestamp > self.timestamp:
-                return Interval(self.timestamp, other.timestamp)
+        ''' 
+        Subtract two timestamps, results in an interval with the start being
+        the earlier of the two timestamps. 
+        '''
+        if isinstance(other, Timestamp):
+            if other.value > self.value:
+                return Interval(self.value, other.value)
             else:
-                return Interval(other.timestamp, self.timestamp)
+                return Interval(other.value, self.value)
 
     def __add__(self, object other):
+        '''
+        Add an Interval, Duration, or Period to the Timestamp, resulting in 
+        new Timestamp.
+        '''
         if isinstance(other, Interval):
-            return Instant(self.timestamp + other.dur.length)
+            return Timestamp(self.value + other.dur.length)
         elif isinstance(other, Duration):
-            return Instant(self.timestamp + other.length)
+            return Timestamp(self.value + other.length)
+        elif isinstance(other, Period):
+            # TODO: fix me
+            raise ValueError("TODO: Period needs to be implemented")
+
+    def __str__(self):
+        '''
+        Output ISO8601 format string representation of timestamp.
+        '''
+        cdef:
+            int outlen
+            char *isostr
+            bytes py_str
+
+        outlen = get_datetime_iso_8601_strlen(0, NPY_FR_us)
+
+        isostr = <char *>malloc(outlen)
+        make_iso_8601_datetime(&self.dts, isostr, outlen, 0, NPY_FR_us, 
+                               0, NPY_UNSAFE_CASTING)
+        py_str = isostr
+        free(isostr)
 
-    property timestamp:
+        return py_str
+
+    property value:
         def __get__(self):
-            return self.timestamp
+            return self.value
 
     property year:
         def __get__(self):
@@ -77,7 +131,7 @@ cdef class Instant:
 
     property ms:
         def __get__(self):
-            return self.dts.us / 1000.
+            return self.dts.us // 1000.
 
     property us:
         def __get__(self):
@@ -85,13 +139,13 @@ cdef class Instant:
 
 cdef class Interval:
     '''
-    An absolute time span, from one instant to another
+    An absolute time span, from one timestamp to another
     '''
     cdef:
-        int64_t start
-        int64_t end
+        Timestamp start
+        Timestamp end
 
-    def __init__(self, int64_t start, int64_t end):
+    def __init__(self, Timestamp start, Timestamp end):
         self.start = start
         self.end = end
 
@@ -103,9 +157,17 @@ cdef class Interval:
         def __get__(self):
             return self.end
 
-    property dur:
+    property us:
+        def __get__(self):
+            return Duration(self.end - self.start).us
+
+    property ms:
         def __get__(self):
-            return Duration(self.end - self.start)
+            return Duration(self.end - self.start).ms
+
+    property secs:
+        def __get__(self):
+            return Duration(self.end - self.start).secs
 
 cdef class Duration:
     '''
@@ -125,11 +187,11 @@ cdef class Duration:
 
     property ms:
         def __get__(self):
-            return self.length / 1000.
+            return self.length // 1000
 
     property secs:
         def __get__(self):
-            return self.length / 1000000.
+            return self.length // 1000000
 
 cdef class Period:
     '''
@@ -156,7 +218,7 @@ cdef class Period:
                           hours = self.hours + other.hours,
                           mins = self.mins + other.mins,
                           secs = self.secs + other.secs)
-        raise ValueError("Could not add operand to Period")
+        raise ValueError("Could not add Period to operand")
 
     def __str__(self):
         strbuf = ""
@@ -250,6 +312,7 @@ def quarters(int count):
 def years(int count):
     return Period(years = count)
 
+
 # Conversion routines
 # ------------------------------------------------------------------------------
 
@@ -348,7 +411,7 @@ def fast_field_accessor(ndarray[int64_t] dtindex, object field):
     else:
         raise ValueError("Field %s not supported; not in (Y,M,D,h,m,s,us)" % field)
 
-# Some general helper functions we need
+# Some general helper functions
 # ------------------------------------------------------------------------------
 
 def isleapyear(int64_t year):
diff --git a/pandas/src/np_datetime.c b/pandas/src/np_datetime.c
index ed1e81277..89e72a415 100644
--- a/pandas/src/np_datetime.c
+++ b/pandas/src/np_datetime.c
@@ -10,7 +10,7 @@
 #include <time.h>
 
 #include <numpy/arrayobject.h>
-//#include "numpy/npy_3kcompat.h"
+#include <numpy/ndarrayobject.h>
 
 #include "numpy/arrayscalars.h"
 #include "np_datetime.h"
@@ -49,6 +49,121 @@ int is_leapyear(npy_int64 year)
             (year % 400) == 0);
 }
 
+/*
+ * Adjusts a datetimestruct based on a minutes offset. Assumes
+ * the current values are valid.
+ */
+void
+add_minutes_to_datetimestruct(npy_datetimestruct *dts, int minutes)
+{
+    int isleap;
+
+    /* MINUTES */
+    dts->min += minutes;
+    while (dts->min < 0) {
+        dts->min += 60;
+        dts->hour--;
+    }
+    while (dts->min >= 60) {
+        dts->min -= 60;
+        dts->hour++;
+    }
+
+    /* HOURS */
+    while (dts->hour < 0) {
+        dts->hour += 24;
+        dts->day--;
+    }
+    while (dts->hour >= 24) {
+        dts->hour -= 24;
+        dts->day++;
+    }
+
+    /* DAYS */
+    if (dts->day < 1) {
+        dts->month--;
+        if (dts->month < 1) {
+            dts->year--;
+            dts->month = 12;
+        }
+        isleap = is_leapyear(dts->year);
+        dts->day += _days_per_month_table[isleap][dts->month-1];
+    }
+    else if (dts->day > 28) {
+        isleap = is_leapyear(dts->year);
+        if (dts->day > _days_per_month_table[isleap][dts->month-1]) {
+            dts->day -= _days_per_month_table[isleap][dts->month-1];
+            dts->month++;
+            if (dts->month > 12) {
+                dts->year++;
+                dts->month = 1;
+            }
+        }
+    }
+}
+
+/*
+ * Calculates the days offset from the 1970 epoch.
+ */
+npy_int64
+get_datetimestruct_days(const npy_datetimestruct *dts)
+{
+    int i, month;
+    npy_int64 year, days = 0;
+    int *month_lengths;
+
+    year = dts->year - 1970;
+    days = year * 365;
+
+    /* Adjust for leap years */
+    if (days >= 0) {
+        /*
+         * 1968 is the closest leap year before 1970.
+         * Exclude the current year, so add 1.
+         */
+        year += 1;
+        /* Add one day for each 4 years */
+        days += year / 4;
+        /* 1900 is the closest previous year divisible by 100 */
+        year += 68;
+        /* Subtract one day for each 100 years */
+        days -= year / 100;
+        /* 1600 is the closest previous year divisible by 400 */
+        year += 300;
+        /* Add one day for each 400 years */
+        days += year / 400;
+    }
+    else {
+        /*
+         * 1972 is the closest later year after 1970.
+         * Include the current year, so subtract 2.
+         */
+        year -= 2;
+        /* Subtract one day for each 4 years */
+        days += year / 4;
+        /* 2000 is the closest later year divisible by 100 */
+        year -= 28;
+        /* Add one day for each 100 years */
+        days -= year / 100;
+        /* 2000 is also the closest later year divisible by 400 */
+        /* Subtract one day for each 400 years */
+        days += year / 400;
+    }
+
+    month_lengths = _days_per_month_table[is_leapyear(dts->year)];
+    month = dts->month - 1;
+
+    /* Add the months */
+    for (i = 0; i < month; ++i) {
+        days += month_lengths[i];
+    }
+
+    /* Add the days */
+    days += dts->day - 1;
+
+    return days;
+}
+
 /*
  * Modifies '*days_' to be the day offset within the year,
  * and returns the year.
@@ -142,59 +257,6 @@ set_datetimestruct_days(npy_int64 days, npy_datetimestruct *dts)
     }
 }
 
-/*
- * Adjusts a datetimestruct based on a minutes offset. Assumes
- * the current values are valid.
- */
-void
-add_minutes_to_datetimestruct(npy_datetimestruct *dts, int minutes)
-{
-    int isleap;
-
-    /* MINUTES */
-    dts->min += minutes;
-    while (dts->min < 0) {
-        dts->min += 60;
-        dts->hour--;
-    }
-    while (dts->min >= 60) {
-        dts->min -= 60;
-        dts->hour++;
-    }
-
-    /* HOURS */
-    while (dts->hour < 0) {
-        dts->hour += 24;
-        dts->day--;
-    }
-    while (dts->hour >= 24) {
-        dts->hour -= 24;
-        dts->day++;
-    }
-
-    /* DAYS */
-    if (dts->day < 1) {
-        dts->month--;
-        if (dts->month < 1) {
-            dts->year--;
-            dts->month = 12;
-        }
-        isleap = is_leapyear(dts->year);
-        dts->day += _days_per_month_table[isleap][dts->month-1];
-    }
-    else if (dts->day > 28) {
-        isleap = is_leapyear(dts->year);
-        if (dts->day > _days_per_month_table[isleap][dts->month-1]) {
-            dts->day -= _days_per_month_table[isleap][dts->month-1];
-            dts->month++;
-            if (dts->month > 12) {
-                dts->year++;
-                dts->month = 1;
-            }
-        }
-    }
-}
-
 /*
  *
  * Tests for and converts a Python datetime.datetime or datetime.date
@@ -540,67 +602,6 @@ convert_datetimestruct_to_datetime(PyArray_DatetimeMetaData *meta,
     return 0;
 }
 
-/*
- * Calculates the days offset from the 1970 epoch.
- */
-npy_int64
-get_datetimestruct_days(const npy_datetimestruct *dts)
-{
-    int i, month;
-    npy_int64 year, days = 0;
-    int *month_lengths;
-
-    year = dts->year - 1970;
-    days = year * 365;
-
-    /* Adjust for leap years */
-    if (days >= 0) {
-        /*
-         * 1968 is the closest leap year before 1970.
-         * Exclude the current year, so add 1.
-         */
-        year += 1;
-        /* Add one day for each 4 years */
-        days += year / 4;
-        /* 1900 is the closest previous year divisible by 100 */
-        year += 68;
-        /* Subtract one day for each 100 years */
-        days -= year / 100;
-        /* 1600 is the closest previous year divisible by 400 */
-        year += 300;
-        /* Add one day for each 400 years */
-        days += year / 400;
-    }
-    else {
-        /*
-         * 1972 is the closest later year after 1970.
-         * Include the current year, so subtract 2.
-         */
-        year -= 2;
-        /* Subtract one day for each 4 years */
-        days += year / 4;
-        /* 2000 is the closest later year divisible by 100 */
-        year -= 28;
-        /* Add one day for each 100 years */
-        days -= year / 100;
-        /* 2000 is also the closest later year divisible by 400 */
-        /* Subtract one day for each 400 years */
-        days += year / 400;
-    }
-
-    month_lengths = _days_per_month_table[is_leapyear(dts->year)];
-    month = dts->month - 1;
-
-    /* Add the months */
-    for (i = 0; i < month; ++i) {
-        days += month_lengths[i];
-    }
-
-    /* Add the days */
-    days += dts->day - 1;
-
-    return days;
-}
 
 /*
  * This provides the casting rules for the TIMEDELTA data type units.
diff --git a/pandas/src/np_datetime.h b/pandas/src/np_datetime.h
index 49a225ff5..d06fee460 100644
--- a/pandas/src/np_datetime.h
+++ b/pandas/src/np_datetime.h
@@ -17,7 +17,7 @@ int convert_pydatetime_to_datetimestruct(PyObject *obj, npy_datetimestruct *out,
 
 int is_leapyear(npy_int64 year);
 
-// stuff numpy needs
+// stuff numpy needs in header
 // ----------------------------------------------------------------------------
 
 char *_datetime_strings[NPY_DATETIME_NUMUNITS];

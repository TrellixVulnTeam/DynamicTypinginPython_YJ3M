commit ea958565fcce64447fff19a19476d06942e92e08
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Oct 15 14:04:23 2010 -0400

    misc cleanup in rolling moments, work on var.py

diff --git a/pandas/stats/moments.py b/pandas/stats/moments.py
index 05e37e022..30396df45 100644
--- a/pandas/stats/moments.py
+++ b/pandas/stats/moments.py
@@ -153,52 +153,6 @@ def _process_data_structure(arg, kill_inf=True):
 #-------------------------------------------------------------------------------
 # Exponential moving moments
 
-def _ewmoment(values, func, min_periods=None, bias_adj=None):
-    """
-    Generic rolling exponential moment function using blended accumulator
-    method.
-
-    Parameters
-    ----------
-    values : ndarray or Series
-    func : function
-        taking previous value and next value
-
-    bias_adj : float
-        Optional bias correction
-
-    min_periods : int, optional
-        require a particular number of periods "in window" to compute statistic
-        If provided, overrides the minPct argument
-
-    Returns
-    -------
-    Same type and length as values argument
-    """
-    okLocs = notnull(values)
-
-    cleanValues = values[okLocs]
-
-    result = np.frompyfunc(func, 2, 1).accumulate(cleanValues)
-    result = result.astype(float)
-
-    if min_periods is not None:
-        if min_periods < 0:
-            raise Exception('min_periods cannot be less than 0!')
-
-        result[:min_periods] = np.NaN
-
-    output = values.copy()
-    output[okLocs] = result
-
-    if bias_adj is not None:
-        if bias_adj <= 0:
-            raise Exception('Bias correction cannot be negative!')
-
-        output *= bias_adj
-
-    return output
-
 def _get_center_of_mass(com, span):
     if span is not None:
         if com is not None:
@@ -287,7 +241,8 @@ ewmvar.__doc__ = _ewm_doc % ("Moving exponentially-weighted moving variance",
                              _bias_doc)
 
 def ewmvol(arg, com=None, span=None, min_periods=0, bias=False):
-    result = ewmvar(arg, com=com, min_periods=min_periods, bias=bias)
+    result = ewmvar(arg, com=com, span=span,
+                    min_periods=min_periods, bias=bias)
     return np.sqrt(result)
 ewmvol.__doc__ = _ewm_doc % ("Moving exponentially-weighted moving std",
                              _bias_doc)
diff --git a/pandas/stats/tests/test_moments.py b/pandas/stats/tests/test_moments.py
index 8175d66cb..91b2c1029 100644
--- a/pandas/stats/tests/test_moments.py
+++ b/pandas/stats/tests/test_moments.py
@@ -182,7 +182,7 @@ class TestMoments(unittest.TestCase):
     def test_ewmvar(self):
         self._check_ew(moments.ewmvar)
 
-    def test_ewmvar(self):
+    def test_ewmvol(self):
         self._check_ew(moments.ewmvol)
 
     def test_ewma_span_com(self):
@@ -190,6 +190,8 @@ class TestMoments(unittest.TestCase):
         B = moments.ewma(self.arr, span=20)
         assert_almost_equal(A, B)
 
+        self.assertRaises(Exception, moments.ewma, com=9.5, span=20)
+
     def _check_ew(self, func):
         self._check_ew_ndarray(func)
         self._check_ew_structures(func)
diff --git a/pandas/stats/tests/test_var.py b/pandas/stats/tests/test_var.py
index 8c8d34fd0..0fb822de6 100644
--- a/pandas/stats/tests/test_var.py
+++ b/pandas/stats/tests/test_var.py
@@ -1,14 +1,93 @@
+from numpy.testing import run_module_suite, assert_equal, TestCase
 
-import rpy2.robjects as robj
-from rpy2.robjects import r
-from rpy2.robjects.packages import importr
-import pandas.rpy.common as rpy
+from pandas.util.testing import assert_almost_equal
+
+import nose
+import unittest
 
 import scikits.statsmodels.tsa.var as sm_var
-import pandas.stats.var as pvar
+import scikits.statsmodels as sm
+
+import pandas.stats.var as _pvar
+reload(_pvar)
+from pandas.stats.var import VAR
+
+try:
+    import rpy2.robjects as robj
+    from rpy2.robjects import r
+    from rpy2.robjects.packages import importr
+    import pandas.rpy.common as rpy
+    vars = importr('vars')
+    urca = importr('urca')
+except ImportError:
+    pass
+
+DECIMAL_6 = 6
+DECIMAL_5 = 5
+DECIMAL_4 = 4
+DECIMAL_3 = 3
+DECIMAL_2 = 2
+
+class CheckVAR(object):
+    def test_params(self):
+        assert_almost_equal(self.res1.params, self.res2.params, DECIMAL_3)
+
+    def test_neqs(self):
+        assert_equal(self.res1.neqs, self.res2.neqs)
+
+    def test_nobs(self):
+        assert_equal(self.res1.avobs, self.res2.nobs)
+
+    def test_df_eq(self):
+        assert_equal(self.res1.df_eq, self.res2.df_eq)
+
+    def test_rmse(self):
+        results = self.res1.results
+        for i in range(len(results)):
+            assert_almost_equal(results[i].mse_resid**.5,
+                    eval('self.res2.rmse_'+str(i+1)), DECIMAL_6)
+
+    def test_rsquared(self):
+        results = self.res1.results
+        for i in range(len(results)):
+            assert_almost_equal(results[i].rsquared,
+                    eval('self.res2.rsquared_'+str(i+1)), DECIMAL_3)
+
+    def test_llf(self):
+        results = self.res1.results
+        assert_almost_equal(self.res1.llf, self.res2.llf, DECIMAL_2)
+        for i in range(len(results)):
+            assert_almost_equal(results[i].llf,
+                    eval('self.res2.llf_'+str(i+1)), DECIMAL_2)
+
+    def test_aic(self):
+        assert_almost_equal(self.res1.aic, self.res2.aic)
+
+    def test_bic(self):
+        assert_almost_equal(self.res1.bic, self.res2.bic)
+
+    def test_hqic(self):
+        assert_almost_equal(self.res1.hqic, self.res2.hqic)
+
+    def test_fpe(self):
+        assert_almost_equal(self.res1.fpe, self.res2.fpe)
+
+    def test_detsig(self):
+        assert_almost_equal(self.res1.detomega, self.res2.detsig)
+
+    def test_bse(self):
+        assert_almost_equal(self.res1.bse, self.res2.bse, DECIMAL_4)
+
+
+class Foo(object):
+    def __init__(self):
+        data = sm.datasets.macrodata.load()
+        data = data.data[['realinv','realgdp','realcons']].view((float,3))
+        data = diff(log(data),axis=0)
+        self.res1 = VAR2(endog=data).fit(maxlag=2)
+        from results import results_var
+        self.res2 = results_var.MacrodataResults()
 
-vars = importr('vars')
-urca = importr('urca')
 
 class RVAR(object):
     """
@@ -21,11 +100,21 @@ class RVAR(object):
         self.type = type
 
         self.pydata = rpy.convert_robj(data)
-
         self._estimate = None
-
         self.estimate()
 
+    @property
+    def aic(self):
+        pass
+
+    @property
+    def bic(self):
+        pass
+
+    @property
+    def beta(self):
+        return rpy.convert_robj(r.coef(self._estimate))
+
     def summary(self, equation=None):
         print r.summary(self._estimate, equation=equation)
 
@@ -46,21 +135,34 @@ class RVAR(object):
 
         return test
 
-    @property
-    def beta(self):
-        return rpy.convert_robj(r.coef(self._estimate))
-
     def data_summary(self):
         print r.summary(self.rdata)
 
+class TestVAR(TestCase):
+
+    def setUp(self):
+        try:
+            import rpy2
+        except ImportError:
+            raise nose.SkipTest("No rpy2")
+
+        self.rdata = rpy.load_data('Canada', package='vars', convert=False)
+        self.data = rpy.load_data('Canada', package='vars', convert=True)
+
+        self.res = VAR(self.data)
+        self.ref = RVAR(self.rdata)
+
+    def test_foo(self):
+        pass
+
 if __name__ == '__main__':
-    canada = rpy.load_data('Canada', package='vars', convert=False)
+    # canada = rpy.load_data('Canada', package='vars', convert=False)
 
-    model = RVAR(canada, p=1)
+    # model = RVAR(canada, p=1)
 
     # summary(Canada)
 
-    # plot(Canada, nc=2, xlab="")
+    # plot(Canada, nc=2, xlab="")ppp
 
     # adf1 <- summary(ur.df(Canada[, "prod"], type = "trend", lags = 2))
     # adf1
@@ -78,3 +180,5 @@ if __name__ == '__main__':
     # coefs <- coef(p1ct)
     # class(coefs)
 
+    # run_module_suite()
+    unittest.main()
diff --git a/pandas/stats/var.py b/pandas/stats/var.py
index e271f781c..4ff6133aa 100644
--- a/pandas/stats/var.py
+++ b/pandas/stats/var.py
@@ -11,9 +11,22 @@ from pandas.stats.math import chain_dot, inv
 from pandas.stats.ols import _combine_rhs
 
 class VAR(object):
-    def __init__(self, data, lags, intercept=True):
+    """
+    Estimates VAR(p) regression on multivariate time series data
+    presented in pandas data structures.
+
+    Parameters
+    ----------
+    data : DataFrame or dict of Series
+    p : lags to include
+
+    """
+
+    def __init__(self, data, p=1, intercept=True):
+        import scikits.statsmodels.tsa.var as sm_var
+
         self._data = DataFrame(_combine_rhs(data))
-        self._p = lags
+        self._p = p
 
         self._columns = self._data.columns
         self._index = self._data.index
@@ -464,6 +477,24 @@ BIC:                            %(bic).3f
     def __repr__(self):
         return self.summary
 
+def lag_select(data, max_lags=5, ic=None):
+    """
+    Select number of lags based on a variety of information criteria
+
+    Parameters
+    ----------
+    data : DataFrame-like
+    max_lags : int
+        Maximum number of lags to evaluate
+    ic : {None, 'aic', 'bic', ...}
+        Choosing None will just display the results
+
+    Returns
+    -------
+    None
+    """
+    pass
+
 class PanelVAR(VAR):
     """
     Performs Vector Autoregression on panel data.
@@ -474,7 +505,7 @@ class PanelVAR(VAR):
     lags: int
     """
     def __init__(self, data, lags, intercept=True):
-        self._data = PanelVAR._prepare_data(data)
+        self._data = _prep_panel_data(data)
         self._p = lags
         self._intercept = intercept
 
@@ -486,14 +517,6 @@ class PanelVAR(VAR):
         _, timesteps, entities = self._data.values.shape
         return (timesteps - self._p) * entities
 
-    @staticmethod
-    def _prepare_data(data):
-        """Converts the given data into a WidePanel."""
-        if isinstance(data, WidePanel):
-            return data
-
-        return WidePanel.fromDict(data)
-
     @cache_readonly
     def _rss(self):
         """Returns the sum of the squares of the residuals."""
@@ -535,6 +558,14 @@ class PanelVAR(VAR):
         n = len(resid)
         return np.dot(resid.T, resid) / (n - k)
 
+
+def _prep_panel_data(data):
+    """Converts the given data into a WidePanel."""
+    if isinstance(data, WidePanel):
+        return data
+
+    return WidePanel.fromDict(data)
+
 def _drop_incomplete_rows(array):
     mask = np.isfinite(array).all(1)
     indices = np.arange(len(array))[mask]

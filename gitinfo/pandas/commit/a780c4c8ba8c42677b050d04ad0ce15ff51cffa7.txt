commit a780c4c8ba8c42677b050d04ad0ce15ff51cffa7
Author: jreback <jeff@reback.net>
Date:   Fri Dec 21 09:03:33 2012 -0500

    BUG: reworked versioning to only act on specific version

diff --git a/RELEASE.rst b/RELEASE.rst
index 1df9d7115..a182f5a7f 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -45,7 +45,7 @@ pandas 0.10.1
   - ``HDFStore``
     - correctly handle ``nan`` elements in string columns; serialize via the ``nan_rep`` keyword to append
     - raise correctly on non-implemented column types (unicode/datetime64/date)
-    - handle correctly ``Term`` passed types (e.g. ``index<1000``, when index is ``Int64``), closes (GH512_)
+    - handle correctly ``Term`` passed types (e.g. ``index<1000``, when index is ``Int64``), (closes GH512_)
 
 .. _GH512: https://github.com/pydata/pandas/issues/512
 .. _GH1277: https://github.com/pydata/pandas/issues/1277
diff --git a/doc/source/io.rst b/doc/source/io.rst
index 00e6519d5..bc710f933 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -1208,21 +1208,22 @@ You can designate (and index) certain columns that you want to be able to perfor
 
 .. ipython:: python
 
-   df['string'] = 'foo'
-   df.ix[4:6,'string'] = np.nan
-   df.ix[7:9,'string'] = 'bar'
-   df['string2'] = 'cool'
-   df
+   df_dc = df.copy()
+   df_dc['string'] = 'foo'
+   df_dc.ix[4:6,'string'] = np.nan
+   df_dc.ix[7:9,'string'] = 'bar'
+   df_dc['string2'] = 'cool'
+   df_dc
 
    # on-disk operations
-   store.append('df_dc', df, columns = ['B','C','string','string2'])
+   store.append('df_dc', df_dc, columns = ['B','C','string','string2'])
    store.select('df_dc',[ Term('B>0') ])
 
    # getting creative
    store.select('df_dc',[ Term('B>0'), Term('C>0'), Term('string=foo') ])
 
    # this is in-memory version of this type of selection
-   df[(df.B > 0) & (df.C > 0) & (df.string == 'foo')]
+   df_dc[(df_dc.B > 0) & (df_dc.C > 0) & (df_dc.string == 'foo')]
 
    # we have automagically created this index and that the B/string columns are stored separately as ``PyTables`` columns
    store.root.df_dc.table
@@ -1232,7 +1233,7 @@ There is some performance degredation by making lots of columns into `data colum
 Advanced Queries
 ~~~~~~~~~~~~~~~~
 
-``not`` and ``or`` conditions are unsupported at this time; however, ``or`` operations are easy to replicate. Repately apply the criteria to the table and concat.
+``not`` and ``or`` conditions are unsupported at this time; however, ``or`` operations are easy to replicate, by repeately applying the criteria to the table, and then ``concat`` the results.
 
 .. ipython:: python
 
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 8147c9d5e..38eb22310 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -36,7 +36,7 @@ import pandas.tslib as tslib
 from contextlib import contextmanager
 
 # versioning attribute
-_version = '0.11'
+_version = '0.10.1'
 
 class IncompatibilityWarning(Warning): pass
 
@@ -529,9 +529,9 @@ class HDFStore(object):
             handler = self._get_handler(op='write', kind=kind)
             wrapper = lambda value: handler(group, value)
 
-        wrapper(value)
         group._v_attrs.pandas_type = kind
         group._v_attrs.pandas_version = _version
+        wrapper(value)
 
     def _write_series(self, group, series):
         self._write_index(group, 'index', series.index)
@@ -1080,18 +1080,23 @@ class DataCol(IndexCol):
     is_searchable     = False
 
     @classmethod
-    def create_for_block(cls, i = None, name = None, cname = None, **kwargs):
+    def create_for_block(cls, i = None, name = None, cname = None, version = None, **kwargs):
         """ return a new datacol with the block i """
 
-        # a little hacky here, to avoid a backwards compability issue
-        #   columns in the table are named like: values_block_0...., but there name is values_0 (for kind attributes)
         if cname is None:
             cname = name or 'values_block_%d' % i
         if name is None:
             name  = cname
-        m = re.search("values_block_(\d+)",name)
-        if m:
-            name = "values_%s" % m.groups()[0]
+
+        # prior to 0.10.1, we named values blocks like: values_block_0 an the name values_0
+        try:
+            if version[0] == 0 and version[1] <= 10 and version[2] == 0:
+                m = re.search("values_block_(\d+)",name)
+                if m:
+                    name = "values_%s" % m.groups()[0]
+        except:
+            pass
+
         return cls(name = name, cname = cname, **kwargs)
 
     def __init__(self, values = None, kind = None, typ = None, cname = None, data = None, block = None, **kwargs):
@@ -1282,7 +1287,16 @@ class Table(object):
     def __init__(self, parent, group, **kwargs):
         self.parent      = parent
         self.group       = group
-        self.version     = getattr(group._v_attrs,'pandas_version',None)
+
+        # compute our version
+        version = getattr(group._v_attrs,'pandas_version',None)
+        try:
+            self.version = tuple([ int(x) for x in version.split('.') ])
+            if len(self.version) == 2:
+                self.version = tuple(self.version + [0])
+        except:
+            self.version = (0,0,0)
+            
         self.index_axes     = []
         self.non_index_axes = []
         self.values_axes    = []
@@ -1409,8 +1423,8 @@ class Table(object):
     def validate_version(self, where = None):
         """ are we trying to operate on an old version? """
         if where is not None:
-            if self.version is None or float(self.version) < 0.1:
-                warnings.warn("where criteria is being ignored as we this version is too old (or not-defined) [%s]" % self.version, IncompatibilityWarning)
+            if self.version[0] <= 0 and self.version[1] <= 10 and self.version[2] < 1:
+                warnings.warn("where criteria is being ignored as we this version is too old (or not-defined) [%s]" % '.'.join([ str(x) for x in self.version ]), IncompatibilityWarning)
 
     @property
     def indexables(self):
@@ -1430,7 +1444,7 @@ class Table(object):
                 klass = DataCol
                 if c in dc:
                     klass = DataIndexableCol
-                return klass.create_for_block(i = i, name = c, pos = base_pos + i ) 
+                return klass.create_for_block(i = i, name = c, pos = base_pos + i, version = self.version) 
 
             self._indexables.extend([ f(i,c) for i, c in enumerate(self.attrs.values_cols) ])
 
@@ -1646,7 +1660,7 @@ class Table(object):
             try:
                 existing_col = existing_table.values_axes[i] if existing_table is not None and validate else None
 
-                col = klass.create_for_block(i = i, name = name)
+                col = klass.create_for_block(i = i, name = name, version = self.version)
                 col.set_atom(block          = b, 
                              existing_col   = existing_col,
                              min_itemsize   = min_itemsize,
diff --git a/pandas/io/tests/legacy_table.h5 b/pandas/io/tests/legacy_table.h5
index 1c90382d9..5f4089efc 100644
Binary files a/pandas/io/tests/legacy_table.h5 and b/pandas/io/tests/legacy_table.h5 differ
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index 51c5680c9..d76800e5a 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -93,16 +93,17 @@ class TestHDFStore(unittest.TestCase):
         self.store.remove('df1')
         self.store.append('df1', df[:10])
         self.store.append('df1', df[10:])
-        self.assert_(self.store.root.a._v_attrs.pandas_version == '0.11')
-        self.assert_(self.store.root.b._v_attrs.pandas_version == '0.11')
-        self.assert_(self.store.root.df1._v_attrs.pandas_version == '0.11')
+        self.assert_(self.store.root.a._v_attrs.pandas_version == '0.10.1')
+        self.assert_(self.store.root.b._v_attrs.pandas_version == '0.10.1')
+        self.assert_(self.store.root.df1._v_attrs.pandas_version == '0.10.1')
 
         # write a file and wipe its versioning
         self.store.remove('df2')
         self.store.append('df2', df)
+
+        # this is an error because its table_type is appendable, but no version info
         self.store.get_node('df2')._v_attrs.pandas_version = None
-        self.store.select('df2')
-        self.store.select('df2', [ Term('index','>',df.index[2]) ])
+        self.assertRaises(Exception, self.store.select,'df2')
 
     def test_meta(self):
         raise nose.SkipTest('no meta')
@@ -1310,6 +1311,11 @@ class TestHDFStore(unittest.TestCase):
         self.store.append('df_float', df)
         self.store.select('df_float', [ Term("index<10.0"), Term("columns", "=", ["A"]) ])
 
+        # invalid terms
+        df = tm.makeTimeDataFrame()
+        self.store.append('df_time', df)
+        self.assertRaises(Exception, self.store.select, 'df_time', [ Term("index>0") ])
+
         # can't select if not written as table
         #self.store['frame'] = df
         #self.assertRaises(Exception, self.store.select,
@@ -1401,10 +1407,13 @@ class TestHDFStore(unittest.TestCase):
         # force the frame
         store.select('df2', typ = 'legacy_frame')
 
-        # old version (this still throws an exception though)
+        self.assertRaises(Exception, store.select, 'wp1', Term('minor_axis','=','B'))
+
+        # old version warning
         import warnings
         warnings.filterwarnings('ignore', category=IncompatibilityWarning)
-        self.assertRaises(Exception, store.select, 'wp1', Term('minor_axis','=','B'))
+        df2 = store.select('df2')
+        store.select('df2', Term('index', '>', df2.index[2]))
         warnings.filterwarnings('always', category=IncompatibilityWarning)
 
         store.close()

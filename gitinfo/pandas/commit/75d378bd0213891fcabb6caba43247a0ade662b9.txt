commit 75d378bd0213891fcabb6caba43247a0ade662b9
Author: jreback <jeff@reback.net>
Date:   Sat Sep 7 16:08:51 2013 -0400

    TST: add append/join tests for merging dup columns
    BUG: join on dup columns (internally) failing

diff --git a/pandas/tools/merge.py b/pandas/tools/merge.py
index 077a3fe62..d7fedecdb 100644
--- a/pandas/tools/merge.py
+++ b/pandas/tools/merge.py
@@ -649,6 +649,7 @@ class _BlockJoinOperation(object):
         for data, indexer in zip(data_list, indexers):
             if not data.is_consolidated():
                 data = data.consolidate()
+            data._set_ref_locs()
             self.units.append(_JoinUnit(data.blocks, indexer))
 
         self.join_index = join_index
@@ -682,7 +683,6 @@ class _BlockJoinOperation(object):
         blockmaps = self._prepare_blocks()
         kinds = _get_merge_block_kinds(blockmaps)
 
-        result_is_unique = self.result_axes[0].is_unique
         result_blocks = []
 
         # maybe want to enable flexible copying <-- what did I mean?
@@ -692,23 +692,28 @@ class _BlockJoinOperation(object):
                 if klass in mapping:
                     klass_blocks.extend((unit, b) for b in mapping[klass])
             res_blk = self._get_merged_block(klass_blocks)
-
-            # if we have a unique result index, need to clear the _ref_locs
-            # a non-unique is set as we are creating
-            if result_is_unique:
-                res_blk.set_ref_locs(None)
-
             result_blocks.append(res_blk)
 
         return BlockManager(result_blocks, self.result_axes)
 
     def _get_merged_block(self, to_merge):
         if len(to_merge) > 1:
+
+            # placement set here
             return self._merge_blocks(to_merge)
         else:
             unit, block = to_merge[0]
-            return unit.reindex_block(block, self.axis,
-                                      self.result_items, copy=self.copy)
+            blk = unit.reindex_block(block, self.axis,
+                                     self.result_items, copy=self.copy)
+
+            # set placement / invalidate on a unique result
+            if self.result_items.is_unique and blk._ref_locs is not None:
+                if not self.copy:
+                    blk = blk.copy()
+                blk.set_ref_locs(None)
+
+            return blk
+
 
     def _merge_blocks(self, merge_chunks):
         """
@@ -736,7 +741,18 @@ class _BlockJoinOperation(object):
 
         # does not sort
         new_block_items = _concat_indexes([b.items for _, b in merge_chunks])
-        return make_block(out, new_block_items, self.result_items)
+
+        # need to set placement if we have a non-unique result
+        # calculate by the existing placement plus the offset in the result set
+        placement = None
+        if not self.result_items.is_unique:
+            nchunks = len(merge_chunks)
+            offsets = np.array([0] + [ len(self.result_items) / nchunks ] * (nchunks-1)).cumsum()
+            placement = []
+            for (unit, blk), offset in zip(merge_chunks,offsets):
+                placement.extend(blk.ref_locs+offset)
+
+        return make_block(out, new_block_items, self.result_items, placement=placement)
 
 
 class _JoinUnit(object):
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index fde6eb59d..f7eb3c125 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -1423,6 +1423,27 @@ class TestConcatenate(unittest.TestCase):
         assert_frame_equal(result.iloc[:10],df)
         assert_frame_equal(result.iloc[10:],df)
 
+        # append
+        result = df.iloc[0:8,:].append(df.iloc[8:])
+        assert_frame_equal(result, df)
+
+        result = df.iloc[0:8,:].append(df.iloc[8:9]).append(df.iloc[9:10])
+        assert_frame_equal(result, df)
+
+        expected = concat([df,df],axis=0)
+        result = df.append(df)
+        assert_frame_equal(result, expected)
+
+    def test_join_dups(self):
+        df = concat([DataFrame(np.random.randn(10,4),columns=['A','A','B','B']),
+                     DataFrame(np.random.randint(0,10,size=20).reshape(10,2),columns=['A','C'])],
+                    axis=1)
+
+        expected = concat([df,df],axis=1)
+        result = df.join(df,rsuffix='_2')
+        result.columns = expected.columns
+        assert_frame_equal(result, expected)
+
     def test_handle_empty_objects(self):
         df = DataFrame(np.random.randn(10, 4), columns=list('abcd'))
 

commit 8e2d4900621e7f14b42e630d1a7c5d9575b53b24
Author: jreback <jeff@reback.net>
Date:   Sat Jun 1 16:26:31 2013 -0400

    BUG: _interleave now returns an lcd of int64 or 2 x the intsize if
    
         uints are seen

diff --git a/RELEASE.rst b/RELEASE.rst
index 35741f7eb..4573b45cc 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -76,6 +76,7 @@ pandas 0.11.1
     GH3572_). This happens before any drawing takes place which elimnates any
     spurious plots from showing up.
   - Added Faq section on repr display options, to help users customize their setup.
+  - ``where`` operations that result in block splitting are much faster (GH3733_)
 
 **API Changes**
 
@@ -116,6 +117,8 @@ pandas 0.11.1
   - the ``method`` and ``axis`` arguments of ``DataFrame.replace()`` are
     deprecated
   - Implement ``__nonzero__`` for ``NDFrame`` objects (GH3691_, GH3696_)
+  - ``as_matrix`` with mixed signed and unsigned dtypes will result in 2 x the lcd of the unsigned
+    as an int, maxing with ``int64``, to avoid precision issues (GH3733_)
 
 **Bug Fixes**
 
@@ -273,6 +276,7 @@ pandas 0.11.1
 .. _GH3691: https://github.com/pydata/pandas/issues/3691
 .. _GH3696: https://github.com/pydata/pandas/issues/3696
 .. _GH3667: https://github.com/pydata/pandas/issues/3667
+.. _GH3733: https://github.com/pydata/pandas/issues/3733
 
 pandas 0.11.0
 =============
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 1ee2f7a44..af1543dad 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -579,25 +579,15 @@ class Block(object):
         axis = cond.ndim-1
         cond = cond.swapaxes(axis,0)
         mask = np.array([ cond[i].all() for i in enumerate(range(cond.shape[0]))],dtype=bool)
-        result_blocks = []
 
-        # can do the mask=true as a single block
-        if mask.any():
-            items = self.items[mask]
-            locs  = self.items.get_indexer(items)
-            slices = [slice(None)] * cond.ndim
-            slices[axis] = locs
-            r = self._try_cast_result(result[slices])
-            result_blocks.append(make_block(r.T, items, self.ref_items))
-
-        # and mask=false as a single block
-        if (~mask).any():
-            items = self.items[~mask]
-            locs  = self.items.get_indexer(items)
-            slices = [slice(None)] * cond.ndim
-            slices[axis] = locs
-            r = self._try_cast_result(result[slices])
-            result_blocks.append(make_block(r.T, items, self.ref_items))
+        result_blocks = []
+        for m in [mask, ~mask]:
+            if m.any():
+                items = self.items[m]
+                slices = [slice(None)] * cond.ndim
+                slices[axis] = self.items.get_indexer(items)
+                r = self._try_cast_result(result[slices])
+                result_blocks.append(make_block(r.T, items, self.ref_items))
 
         return result_blocks
 
@@ -2435,7 +2425,22 @@ def _interleaved_dtype(blocks):
     elif have_bool:
         return np.dtype(bool)
     elif have_int and not have_float and not have_complex:
-        return _lcd_dtype(counts[IntBlock])
+
+        # if we are mixing unsigned and signed, then return
+        # the next biggest int type (if we can)
+        lcd = _lcd_dtype(counts[IntBlock])
+        kinds = set([ i.dtype.kind for i in counts[IntBlock] ])
+        if len(kinds) == 1:
+            return lcd
+
+        if lcd == 'uint64' or lcd == 'int64':
+            return np.dtype('int64')
+
+        # return 1 bigger on the itemsize if unsinged
+        if lcd.kind == 'u':
+            return np.dtype('int%s' % (lcd.itemsize*8*2))
+        return lcd
+    
     elif have_dt64 and not have_float and not have_complex:
         return np.dtype('M8[ns]')
     elif have_complex:
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index db9efce36..8964b2175 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -273,7 +273,7 @@ class CheckIndexing(object):
 
         # where dtype conversions
         # GH 3733
-        df = DataFrame(data = np.random.randn(1000, 500))
+        df = DataFrame(data = np.random.randn(100, 50))
         df = df.where(df > 0) # create nans
         bools = df > 0
         mask = isnull(df)
@@ -7578,8 +7578,10 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
 
         def _safe_add(df):
             # only add to the numeric items
-            return DataFrame(dict([ (c,s+1) if issubclass(s.dtype.type, (np.integer,np.floating)) else (c,s) for c, s in df.iteritems() ]))
-
+            def is_ok(s):
+                return issubclass(s.dtype.type, (np.integer,np.floating)) and s.dtype != 'uint8'
+            return DataFrame(dict([ (c,s+1) if is_ok(s) else (c,s) for c, s in df.iteritems() ]))
+        
         def _check_get(df, cond, check_dtypes = True):
             other1 = _safe_add(df)
             rs = df.where(cond, other1)
@@ -7615,7 +7617,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         def _check_align(df, cond, other, check_dtypes = True):
             rs = df.where(cond, other)
             for i, k in enumerate(rs.columns):
-                v = rs[k]
+                result = rs[k]
                 d = df[k].values
                 c = cond[k].reindex(df[k].index).fillna(False).values
 
@@ -7623,12 +7625,16 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
                     o = other
                 else:
                     if isinstance(other,np.ndarray):
-                        o = Series(other[:,i],index=v.index).values
+                        o = Series(other[:,i],index=result.index).values
                     else:
                         o = other[k].values
 
                 new_values = d if c.all() else np.where(c, d, o)
-                assert_series_equal(v, Series(new_values,index=v.index))
+                expected = Series(new_values,index=result.index)
+
+                # since we can't always have the correct numpy dtype
+                # as numpy doesn't know how to downcast, don't check
+                assert_series_equal(result, expected, check_dtype=False)
 
             # dtypes
             # can't check dtype when other is an ndarray
@@ -9904,14 +9910,14 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         self.assert_(values.dtype == np.float16)
 
         values = self.mixed_int.as_matrix(['A','B','C','D'])
-        self.assert_(values.dtype == np.uint64)
+        self.assert_(values.dtype == np.int64)
 
         values = self.mixed_int.as_matrix(['A','D'])
         self.assert_(values.dtype == np.int64)
 
         # guess all ints are cast to uints....
         values = self.mixed_int.as_matrix(['A','B','C'])
-        self.assert_(values.dtype == np.uint64)
+        self.assert_(values.dtype == np.int64)
 
         values = self.mixed_int.as_matrix(['A','C'])
         self.assert_(values.dtype == np.int32)
diff --git a/vb_suite/suite.py b/vb_suite/suite.py
index 339ba8e6d..905c43718 100644
--- a/vb_suite/suite.py
+++ b/vb_suite/suite.py
@@ -3,27 +3,27 @@ from datetime import datetime
 
 import os
 
-modules = [#'attrs_caching',
-           #'binary_ops',
-           #'ctors',
-           #'frame_ctor',
+modules = ['attrs_caching',
+           'binary_ops',
+           'ctors',
+           'frame_ctor',
            'frame_methods',
-           #'groupby',
-           #'index_object',
-           #'indexing',
-           #'io_bench',
-           #'hdfstore_bench',
-           #'join_merge',
-           #'miscellaneous',
-           #'panel_ctor',
-           #'parser',
-           #'reindex',
-           #'replace',
-           #'sparse',
-           #'reshape',
-           #'stat_ops',
-           #'timeseries']
-]
+           'groupby',
+           'index_object',
+           'indexing',
+           'io_bench',
+           'hdfstore_bench',
+           'join_merge',
+           'miscellaneous',
+           'panel_ctor',
+           'parser',
+           'reindex',
+           'replace',
+           'sparse',
+           'reshape',
+           'stat_ops',
+           'timeseries']
+
 by_module = {}
 benchmarks = []
 

commit 1c07c6b0ce8ee83767e6e0120458fabcd2109db6
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Dec 23 23:20:20 2011 -0500

    ENH: more tinkering with khash.h for strings and pyobjects

diff --git a/bench/bench_groupby.py b/bench/bench_groupby.py
index 16a7432a1..724a1e1e7 100644
--- a/bench/bench_groupby.py
+++ b/bench/bench_groupby.py
@@ -1,4 +1,5 @@
 from pandas import *
+from pandas.util.testing import rands
 
 import string
 import random
@@ -6,8 +7,7 @@ import random
 k = 200
 n = 1000
 
-
-foo = np.tile(list(range(k)), n)
+foo = np.tile(np.array([rands(10) for _ in xrange(k)], dtype='O'), n)
 foo2 = list(foo)
 random.shuffle(foo)
 random.shuffle(foo2)
@@ -16,7 +16,15 @@ df = DataFrame({'A' : foo,
                 'B' : foo2,
                 'C' : np.random.randn(n * k)})
 
+import pandas._sandbox as sbx
+
+def f():
+    table = sbx.StringHashTable(len(df))
+    ret = table.factorize(['A'])
+    return ret
+ret = f()
 
+"""
 import pandas._tseries as lib
 
 f = np.std
@@ -45,3 +53,4 @@ grouper = lib.Grouper(df['C'], np.ndarray.std, group_index, ngroups)
 result = grouper.get_result()
 
 expected = grouped.std()
+"""
diff --git a/pandas/src/khash.h b/pandas/src/khash.h
index c11708355..fcad76c82 100644
--- a/pandas/src/khash.h
+++ b/pandas/src/khash.h
@@ -564,7 +564,7 @@ typedef const char *kh_cstr_t;
 #include <Python.h>
 
 #define kh_python_hash_func(key) (PyObject_Hash(key))
-#define kh_python_hash_equal(a, b) (PyObject_RichCompareBool(a, b, Py_EQ))
+#define kh_python_hash_equal(a, b) ((a == b) || PyObject_RichCompareBool(a, b, Py_EQ))
 
 
 // Python object
diff --git a/pandas/src/sandbox.pyx b/pandas/src/sandbox.pyx
index 183629d77..ccc57a606 100644
--- a/pandas/src/sandbox.pyx
+++ b/pandas/src/sandbox.pyx
@@ -1,4 +1,4 @@
-from numpy cimport ndarray, int64_t
+from numpy cimport *
 cimport numpy as cnp
 import numpy as np
 
@@ -231,3 +231,165 @@ def int64_unique(ndarray[int64_t] arr):
     kh_destroy_int64(table)
 
     return np.sort(uniques[:j])
+
+from cpython cimport PyString_Check, PyString_AsString
+
+cdef class StringHashTable:
+
+    cdef:
+        kh_str_t *table
+
+    def __init__(self, size_hint=1):
+        if size_hint is not None:
+            kh_resize_str(self.table, size_hint)
+
+    def __cinit__(self):
+        self.table = kh_init_str()
+
+    def __dealloc__(self):
+        kh_destroy_str(self.table)
+
+    cdef inline int check_type(self, object val):
+        return PyString_Check(val)
+
+    cpdef get_item(self, object val):
+        cdef khiter_t k
+        k = kh_get_str(self.table, PyString_AsString(val))
+        if k != self.table.n_buckets:
+            return self.table.vals[k]
+        else:
+            raise KeyError(val)
+
+    def get_iter_test(self, object key, Py_ssize_t iterations):
+        cdef Py_ssize_t i, val
+        for i in range(iterations):
+            k = kh_get_str(self.table, PyString_AsString(key))
+            if k != self.table.n_buckets:
+                val = self.table.vals[k]
+
+    cpdef set_item(self, object key, Py_ssize_t val):
+        cdef:
+            khiter_t k
+            int ret
+            char* buf
+
+        buf = PyString_AsString(key)
+
+        k = kh_put_str(self.table, buf, &ret)
+        self.table.keys[k] = key
+        if kh_exist_str(self.table, k):
+            self.table.vals[k] = val
+        else:
+            raise KeyError(key)
+
+    def factorize(self, ndarray[object] values):
+        cdef:
+            Py_ssize_t i, n = len(values)
+            ndarray[int32_t] labels = np.empty(n, dtype=np.int32)
+            ndarray[int32_t] counts = np.empty(n, dtype=np.int32)
+            dict reverse = {}
+            Py_ssize_t idx, count = 0
+            int ret
+            object val
+            char *buf
+            khiter_t k
+
+        for i in range(n):
+            val = values[i]
+            buf = PyString_AsString(val)
+            k = kh_get_str(self.table, buf)
+            if k != self.table.n_buckets:
+                idx = self.table.vals[k]
+                labels[i] = idx
+                counts[idx] = counts[idx] + 1
+            else:
+                k = kh_put_str(self.table, buf, &ret)
+                # print 'putting %s, %s' % (val, count)
+                if not ret:
+                    kh_del_str(self.table, k)
+
+                self.table.vals[k] = count
+                reverse[count] = val
+                labels[i] = count
+                counts[count] = 1
+                count += 1
+
+        # return None
+        return reverse, labels, counts[:count].copy()
+
+cdef class PyObjectHashTable:
+
+    cdef:
+        kh_pymap_t *table
+
+    def __init__(self, size_hint=1):
+        if size_hint is not None:
+            kh_resize_pymap(self.table, size_hint)
+
+    def __cinit__(self):
+        self.table = kh_init_pymap()
+
+    def __dealloc__(self):
+        kh_destroy_pymap(self.table)
+
+    cpdef get_item(self, object val):
+        cdef khiter_t k
+        k = kh_get_pymap(self.table, <PyObject*>val)
+        if k != self.table.n_buckets:
+            return self.table.vals[k]
+        else:
+            raise KeyError(val)
+
+    def get_iter_test(self, object key, Py_ssize_t iterations):
+        cdef Py_ssize_t i, val
+        for i in range(iterations):
+            k = kh_get_pymap(self.table, <PyObject*>key)
+            if k != self.table.n_buckets:
+                val = self.table.vals[k]
+
+    cpdef set_item(self, object key, Py_ssize_t val):
+        cdef:
+            khiter_t k
+            int ret
+            char* buf
+
+        k = kh_put_pymap(self.table, <PyObject*>key, &ret)
+        # self.table.keys[k] = key
+        if kh_exist_pymap(self.table, k):
+            self.table.vals[k] = val
+        else:
+            raise KeyError(key)
+
+    def factorize(self, ndarray[object] values):
+        cdef:
+            Py_ssize_t i, n = len(values)
+            ndarray[int32_t] labels = np.empty(n, dtype=np.int32)
+            ndarray[int32_t] counts = np.empty(n, dtype=np.int32)
+            dict reverse = {}
+            Py_ssize_t idx, count = 0
+            int ret
+            object val
+            khiter_t k
+
+        for i in range(n):
+            val = values[i]
+            k = kh_get_pymap(self.table, <PyObject*>val)
+            if k != self.table.n_buckets:
+                idx = self.table.vals[k]
+                labels[i] = idx
+                counts[idx] = counts[idx] + 1
+            else:
+                k = kh_put_pymap(self.table, <PyObject*>val, &ret)
+                # print 'putting %s, %s' % (val, count)
+                if not ret:
+                    kh_del_pymap(self.table, k)
+
+                self.table.vals[k] = count
+                reverse[count] = val
+                labels[i] = count
+                counts[count] = 1
+                count += 1
+
+        # return None
+        return reverse, labels, counts[:count].copy()
+

commit 04c3d5110c4a21e412daeddc4b12f63c028acbcb
Author: MomIsBestFriend <50263213+MomIsBestFriend@users.noreply.github.com>
Date:   Mon Jan 6 19:24:22 2020 +0200

    STY: Spaces over concat strings - batch 1 (#30707)

diff --git a/pandas/_libs/tslib.pyx b/pandas/_libs/tslib.pyx
index e0a2b987c..53e3354ca 100644
--- a/pandas/_libs/tslib.pyx
+++ b/pandas/_libs/tslib.pyx
@@ -120,8 +120,7 @@ def ints_to_pydatetime(const int64_t[:] arr, object tz=None, object freq=None,
     elif box == "datetime":
         func_create = create_datetime_from_ts
     else:
-        raise ValueError("box must be one of 'datetime', 'date', 'time' or"
-                         " 'timestamp'")
+        raise ValueError("box must be one of 'datetime', 'date', 'time' or 'timestamp'")
 
     if is_utc(tz) or tz is None:
         for i in range(n):
diff --git a/pandas/_libs/tslibs/strptime.pyx b/pandas/_libs/tslibs/strptime.pyx
index 742403883..5508b208d 100644
--- a/pandas/_libs/tslibs/strptime.pyx
+++ b/pandas/_libs/tslibs/strptime.pyx
@@ -278,8 +278,8 @@ def array_strptime(object[:] values, object fmt,
                                  "the ISO year directive '%G' and a weekday "
                                  "directive '%A', '%a', '%w', or '%u'.")
             else:
-                raise ValueError("ISO week directive '%V' is incompatible with"
-                                 " the year directive '%Y'. Use the ISO year "
+                raise ValueError("ISO week directive '%V' is incompatible with "
+                                 "the year directive '%Y'. Use the ISO year "
                                  "'%G' instead.")
 
         # If we know the wk of the year and what day of that wk, we can figure
diff --git a/pandas/_libs/tslibs/timestamps.pyx b/pandas/_libs/tslibs/timestamps.pyx
index 86a9d0537..abe7f9e5b 100644
--- a/pandas/_libs/tslibs/timestamps.pyx
+++ b/pandas/_libs/tslibs/timestamps.pyx
@@ -814,9 +814,9 @@ default 'raise'
                                'shift_backward')
         if nonexistent not in nonexistent_options and not isinstance(
             nonexistent, timedelta):
-            raise ValueError("The nonexistent argument must be one of 'raise',"
-                             " 'NaT', 'shift_forward', 'shift_backward' or"
-                             " a timedelta object")
+            raise ValueError("The nonexistent argument must be one of 'raise', "
+                             "'NaT', 'shift_forward', 'shift_backward' or "
+                             "a timedelta object")
 
         if self.tzinfo is None:
             # tz naive, localize
diff --git a/pandas/core/arrays/datetimes.py b/pandas/core/arrays/datetimes.py
index 6aa910c0f..0c530729c 100644
--- a/pandas/core/arrays/datetimes.py
+++ b/pandas/core/arrays/datetimes.py
@@ -333,8 +333,7 @@ class DatetimeArray(dtl.DatetimeLikeArrayMixin, dtl.TimelikeOps, dtl.DatelikeOps
         if not isinstance(values, np.ndarray):
             msg = (
                 f"Unexpected type '{type(values).__name__}'. 'values' must be "
-                "a DatetimeArray ndarray, or Series or Index containing one of"
-                " those."
+                "a DatetimeArray ndarray, or Series or Index containing one of those."
             )
             raise ValueError(msg)
         if values.ndim not in [1, 2]:
diff --git a/pandas/core/arrays/timedeltas.py b/pandas/core/arrays/timedeltas.py
index 953a24238..3bfd27e8c 100644
--- a/pandas/core/arrays/timedeltas.py
+++ b/pandas/core/arrays/timedeltas.py
@@ -238,8 +238,8 @@ class TimedeltaArray(dtl.DatetimeLikeArrayMixin, dtl.TimelikeOps):
 
         if not isinstance(values, np.ndarray):
             msg = (
-                f"Unexpected type '{type(values).__name__}'. 'values' must be a"
-                " TimedeltaArray ndarray, or Series or Index containing one of those."
+                f"Unexpected type '{type(values).__name__}'. 'values' must be a "
+                "TimedeltaArray ndarray, or Series or Index containing one of those."
             )
             raise ValueError(msg)
         if values.ndim not in [1, 2]:
diff --git a/pandas/core/computation/eval.py b/pandas/core/computation/eval.py
index 5c3200427..72a0fda90 100644
--- a/pandas/core/computation/eval.py
+++ b/pandas/core/computation/eval.py
@@ -339,8 +339,8 @@ def eval(
         if parsed_expr.assigner is None:
             if multi_line:
                 raise ValueError(
-                    "Multi-line expressions are only valid"
-                    " if all expressions contain an assignment"
+                    "Multi-line expressions are only valid "
+                    "if all expressions contain an assignment"
                 )
             elif inplace:
                 raise ValueError("Cannot operate inplace if there is no assignment")
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index ba0c0e7d6..3636712f9 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -7000,8 +7000,8 @@ Wild         185.0
                 other = Series(other)
             if other.name is None and not ignore_index:
                 raise TypeError(
-                    "Can only append a Series if ignore_index=True"
-                    " or if the Series has a name"
+                    "Can only append a Series if ignore_index=True "
+                    "or if the Series has a name"
                 )
 
             index = Index([other.name], name=self.index.name)
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index bf183523b..1edcf581c 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -6440,8 +6440,8 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
             if not is_dict_like(to_replace):
                 if not is_dict_like(regex):
                     raise TypeError(
-                        'If "to_replace" and "value" are both None'
-                        ' and "to_replace" is not a list, then '
+                        'If "to_replace" and "value" are both None '
+                        'and "to_replace" is not a list, then '
                         "regex must be a mapping"
                     )
                 to_replace = regex
@@ -6455,9 +6455,8 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
             if any(are_mappings):
                 if not all(are_mappings):
                     raise TypeError(
-                        "If a nested mapping is passed, all values"
-                        " of the top level mapping must be "
-                        "mappings"
+                        "If a nested mapping is passed, all values "
+                        "of the top level mapping must be mappings"
                     )
                 # passed a nested dict/Series
                 to_rep_dict = {}
diff --git a/pandas/core/groupby/groupby.py b/pandas/core/groupby/groupby.py
index 1ba4938d4..233bdd11b 100644
--- a/pandas/core/groupby/groupby.py
+++ b/pandas/core/groupby/groupby.py
@@ -485,8 +485,8 @@ class _GroupBy(PandasObject, SelectionMixin):
                 except KeyError:
                     # turns out it wasn't a tuple
                     msg = (
-                        "must supply a same-length tuple to get_group"
-                        " with multiple grouping keys"
+                        "must supply a same-length tuple to get_group "
+                        "with multiple grouping keys"
                     )
                     raise ValueError(msg)
 
diff --git a/pandas/core/groupby/grouper.py b/pandas/core/groupby/grouper.py
index 543610154..0b89e702c 100644
--- a/pandas/core/groupby/grouper.py
+++ b/pandas/core/groupby/grouper.py
@@ -605,8 +605,8 @@ def get_grouper(
 
         if is_categorical_dtype(gpr) and len(gpr) != obj.shape[axis]:
             raise ValueError(
-                f"Length of grouper ({len(gpr)}) and axis ({obj.shape[axis]})"
-                " must be same length"
+                f"Length of grouper ({len(gpr)}) and axis ({obj.shape[axis]}) "
+                "must be same length"
             )
 
         # create the Grouping
diff --git a/pandas/core/indexes/multi.py b/pandas/core/indexes/multi.py
index d9e68b64f..1f0aff660 100644
--- a/pandas/core/indexes/multi.py
+++ b/pandas/core/indexes/multi.py
@@ -2073,9 +2073,8 @@ class MultiIndex(Index):
                 elif com.is_bool_indexer(loc):
                     if self.lexsort_depth == 0:
                         warnings.warn(
-                            "dropping on a non-lexsorted multi-index"
-                            " without a level parameter may impact "
-                            "performance.",
+                            "dropping on a non-lexsorted multi-index "
+                            "without a level parameter may impact performance.",
                             PerformanceWarning,
                             stacklevel=3,
                         )
diff --git a/pandas/core/resample.py b/pandas/core/resample.py
index 931653b63..056ba73ed 100644
--- a/pandas/core/resample.py
+++ b/pandas/core/resample.py
@@ -1076,10 +1076,9 @@ class DatetimeIndexResampler(Resampler):
             raise AssertionError("axis must be 0")
         if self._from_selection:
             raise ValueError(
-                "Upsampling from level= or on= selection"
-                " is not supported, use .set_index(...)"
-                " to explicitly set index to"
-                " datetime-like"
+                "Upsampling from level= or on= selection "
+                "is not supported, use .set_index(...) "
+                "to explicitly set index to datetime-like"
             )
 
         ax = self.ax
@@ -1135,9 +1134,9 @@ class PeriodIndexResampler(DatetimeIndexResampler):
         if self._from_selection:
             # see GH 14008, GH 12871
             msg = (
-                "Resampling from level= or on= selection"
-                " with a PeriodIndex is not currently supported,"
-                " use .set_index(...) to explicitly set index"
+                "Resampling from level= or on= selection "
+                "with a PeriodIndex is not currently supported, "
+                "use .set_index(...) to explicitly set index"
             )
             raise NotImplementedError(msg)
 
diff --git a/pandas/core/reshape/concat.py b/pandas/core/reshape/concat.py
index 2007f6aa3..ff7b7580e 100644
--- a/pandas/core/reshape/concat.py
+++ b/pandas/core/reshape/concat.py
@@ -351,8 +351,8 @@ class _Concatenator:
         for obj in objs:
             if not isinstance(obj, (Series, DataFrame)):
                 msg = (
-                    "cannot concatenate object of type '{typ}';"
-                    " only Series and DataFrame objs are valid".format(typ=type(obj))
+                    "cannot concatenate object of type '{typ}'; "
+                    "only Series and DataFrame objs are valid".format(typ=type(obj))
                 )
                 raise TypeError(msg)
 
@@ -402,8 +402,8 @@ class _Concatenator:
         self._is_series = isinstance(sample, Series)
         if not 0 <= axis <= sample.ndim:
             raise AssertionError(
-                "axis must be between 0 and {ndim}, input was"
-                " {axis}".format(ndim=sample.ndim, axis=axis)
+                "axis must be between 0 and {ndim}, input was "
+                "{axis}".format(ndim=sample.ndim, axis=axis)
             )
 
         # if we have mixed ndims, then convert to highest ndim
@@ -648,8 +648,8 @@ def _make_concat_multiindex(indexes, keys, levels=None, names=None) -> MultiInde
             # make sure that all of the passed indices have the same nlevels
             if not len({idx.nlevels for idx in indexes}) == 1:
                 raise AssertionError(
-                    "Cannot concat indices that do"
-                    " not have the same number of levels"
+                    "Cannot concat indices that do "
+                    "not have the same number of levels"
                 )
 
             # also copies
diff --git a/pandas/core/reshape/melt.py b/pandas/core/reshape/melt.py
index 722dd8751..d4ccb19fc 100644
--- a/pandas/core/reshape/melt.py
+++ b/pandas/core/reshape/melt.py
@@ -51,8 +51,8 @@ def melt(
             missing = Index(com.flatten(id_vars)).difference(cols)
             if not missing.empty:
                 raise KeyError(
-                    "The following 'id_vars' are not present"
-                    " in the DataFrame: {missing}"
+                    "The following 'id_vars' are not present "
+                    "in the DataFrame: {missing}"
                     "".format(missing=list(missing))
                 )
     else:
@@ -73,8 +73,8 @@ def melt(
             missing = Index(com.flatten(value_vars)).difference(cols)
             if not missing.empty:
                 raise KeyError(
-                    "The following 'value_vars' are not present in"
-                    " the DataFrame: {missing}"
+                    "The following 'value_vars' are not present in "
+                    "the DataFrame: {missing}"
                     "".format(missing=list(missing))
                 )
         frame = frame.loc[:, id_vars + value_vars]
diff --git a/pandas/core/reshape/merge.py b/pandas/core/reshape/merge.py
index 6fe228792..5f92e4a88 100644
--- a/pandas/core/reshape/merge.py
+++ b/pandas/core/reshape/merge.py
@@ -1246,32 +1246,32 @@ class _MergeOperation:
         if validate in ["one_to_one", "1:1"]:
             if not left_unique and not right_unique:
                 raise MergeError(
-                    "Merge keys are not unique in either left"
-                    " or right dataset; not a one-to-one merge"
+                    "Merge keys are not unique in either left "
+                    "or right dataset; not a one-to-one merge"
                 )
             elif not left_unique:
                 raise MergeError(
-                    "Merge keys are not unique in left dataset;"
-                    " not a one-to-one merge"
+                    "Merge keys are not unique in left dataset; "
+                    "not a one-to-one merge"
                 )
             elif not right_unique:
                 raise MergeError(
-                    "Merge keys are not unique in right dataset;"
-                    " not a one-to-one merge"
+                    "Merge keys are not unique in right dataset; "
+                    "not a one-to-one merge"
                 )
 
         elif validate in ["one_to_many", "1:m"]:
             if not left_unique:
                 raise MergeError(
-                    "Merge keys are not unique in left dataset;"
-                    " not a one-to-many merge"
+                    "Merge keys are not unique in left dataset; "
+                    "not a one-to-many merge"
                 )
 
         elif validate in ["many_to_one", "m:1"]:
             if not right_unique:
                 raise MergeError(
-                    "Merge keys are not unique in right dataset;"
-                    " not a many-to-one merge"
+                    "Merge keys are not unique in right dataset; "
+                    "not a many-to-one merge"
                 )
 
         elif validate in ["many_to_many", "m:m"]:
diff --git a/pandas/core/strings.py b/pandas/core/strings.py
index 02f4eb47b..f8d9eeb21 100644
--- a/pandas/core/strings.py
+++ b/pandas/core/strings.py
@@ -438,8 +438,8 @@ def str_contains(arr, pat, case=True, flags=0, na=np.nan, regex=True):
 
         if regex.groups > 0:
             warnings.warn(
-                "This pattern has match groups. To actually get the"
-                " groups, use str.extract.",
+                "This pattern has match groups. To actually get the "
+                "groups, use str.extract.",
                 UserWarning,
                 stacklevel=3,
             )
diff --git a/pandas/io/clipboards.py b/pandas/io/clipboards.py
index 518b940ec..34e8e03d8 100644
--- a/pandas/io/clipboards.py
+++ b/pandas/io/clipboards.py
@@ -69,8 +69,8 @@ def read_clipboard(sep=r"\s+", **kwargs):  # pragma: no cover
         kwargs["engine"] = "python"
     elif len(sep) > 1 and kwargs.get("engine") == "c":
         warnings.warn(
-            "read_clipboard with regex separator does not work"
-            " properly with c engine"
+            "read_clipboard with regex separator does not work "
+            "properly with c engine"
         )
 
     return read_csv(StringIO(text), sep=sep, **kwargs)
diff --git a/pandas/io/excel/_util.py b/pandas/io/excel/_util.py
index 8cd4b2012..a084be54d 100644
--- a/pandas/io/excel/_util.py
+++ b/pandas/io/excel/_util.py
@@ -154,8 +154,8 @@ def _validate_freeze_panes(freeze_panes):
             return True
 
         raise ValueError(
-            "freeze_panes must be of form (row, column)"
-            " where row and column are integers"
+            "freeze_panes must be of form (row, column) "
+            "where row and column are integers"
         )
 
     # freeze_panes wasn't specified, return False so it won't be applied
diff --git a/pandas/io/formats/format.py b/pandas/io/formats/format.py
index 3020ac421..5c4b7d103 100644
--- a/pandas/io/formats/format.py
+++ b/pandas/io/formats/format.py
@@ -579,8 +579,8 @@ class DataFrameFormatter(TableFormatter):
         else:
             raise ValueError(
                 (
-                    "Formatters length({flen}) should match"
-                    " DataFrame number of columns({dlen})"
+                    "Formatters length({flen}) should match "
+                    "DataFrame number of columns({dlen})"
                 ).format(flen=len(formatters), dlen=len(frame.columns))
             )
         self.na_rep = na_rep
diff --git a/pandas/io/formats/style.py b/pandas/io/formats/style.py
index 0c9d2d54d..30d850fad 100644
--- a/pandas/io/formats/style.py
+++ b/pandas/io/formats/style.py
@@ -1272,9 +1272,9 @@ class Styler:
             color = [color[0], color[0]]
         elif len(color) > 2:
             raise ValueError(
-                "`color` must be string or a list-like"
-                " of length 2: [`color_neg`, `color_pos`]"
-                " (eg: color=['#d65f5f', '#5fba7d'])"
+                "`color` must be string or a list-like "
+                "of length 2: [`color_neg`, `color_pos`] "
+                "(eg: color=['#d65f5f', '#5fba7d'])"
             )
 
         subset = _maybe_numeric_slice(self.data, subset)
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index ee4932b4f..21e1ef98f 100755
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -612,9 +612,9 @@ def _make_parser_function(name, default_sep=","):
 
         if delim_whitespace and delimiter != default_sep:
             raise ValueError(
-                "Specified a delimiter with both sep and"
-                " delim_whitespace=True; you can only"
-                " specify one."
+                "Specified a delimiter with both sep and "
+                "delim_whitespace=True; you can only "
+                "specify one."
             )
 
         if engine is not None:
@@ -956,8 +956,8 @@ class TextFileReader(abc.Iterator):
         if sep is None and not delim_whitespace:
             if engine == "c":
                 fallback_reason = (
-                    "the 'c' engine does not support"
-                    " sep=None with delim_whitespace=False"
+                    "the 'c' engine does not support "
+                    "sep=None with delim_whitespace=False"
                 )
                 engine = "python"
         elif sep is not None and len(sep) > 1:
@@ -1120,9 +1120,9 @@ class TextFileReader(abc.Iterator):
                 klass = FixedWidthFieldParser
             else:
                 raise ValueError(
-                    f"Unknown engine: {engine} (valid options are"
-                    ' "c", "python", or'
-                    ' "python-fwf")'
+                    f"Unknown engine: {engine} (valid options are "
+                    '"c", "python", or '
+                    '"python-fwf")'
                 )
             self._engine = klass(self.f, **self.options)
 
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 3d2c2159b..d61d1cf7f 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -1215,9 +1215,8 @@ class HDFStore:
         """
         if axes is not None:
             raise TypeError(
-                "axes is currently not accepted as a parameter to"
-                " append_to_multiple; you can create the "
-                "tables independently instead"
+                "axes is currently not accepted as a parameter to append_to_multiple; "
+                "you can create the tables independently instead"
             )
 
         if not isinstance(d, dict):
@@ -3548,9 +3547,8 @@ class Table(Fixed):
                 if not v.is_indexed:
                     if v.type.startswith("complex"):
                         raise TypeError(
-                            "Columns containing complex values can be stored "
-                            "but cannot"
-                            " be indexed when using table format. Either use "
+                            "Columns containing complex values can be stored but "
+                            "cannot be indexed when using table format. Either use "
                             "fixed format, set index=False, or do not include "
                             "the columns containing complex values to "
                             "data_columns when initializing the table."
diff --git a/pandas/plotting/_matplotlib/core.py b/pandas/plotting/_matplotlib/core.py
index 609da140a..2d68bb46a 100644
--- a/pandas/plotting/_matplotlib/core.py
+++ b/pandas/plotting/_matplotlib/core.py
@@ -229,10 +229,9 @@ class MPLPlot:
                 for char in s:
                     if char in matplotlib.colors.BASE_COLORS:
                         raise ValueError(
-                            "Cannot pass 'style' string with a color "
-                            "symbol and 'color' keyword argument. Please"
-                            " use one or the other or pass 'style' "
-                            "without a color symbol"
+                            "Cannot pass 'style' string with a color symbol and "
+                            "'color' keyword argument. Please use one or the other or "
+                            "pass 'style' without a color symbol"
                         )
 
     def _iter_data(self, data=None, keep_index=False, fillna=None):
diff --git a/pandas/tests/computation/test_eval.py b/pandas/tests/computation/test_eval.py
index 886c43f84..7f68abb92 100644
--- a/pandas/tests/computation/test_eval.py
+++ b/pandas/tests/computation/test_eval.py
@@ -339,8 +339,8 @@ class TestEvalNumexprPandas:
             self.check_equal(res, expected)
         else:
             msg = (
-                r"unsupported operand type\(s\) for //: 'VariableNode' and"
-                " 'VariableNode'"
+                r"unsupported operand type\(s\) for //: 'VariableNode' and "
+                "'VariableNode'"
             )
             with pytest.raises(TypeError, match=msg):
                 pd.eval(
diff --git a/pandas/tests/indexing/test_categorical.py b/pandas/tests/indexing/test_categorical.py
index 4a33dbd8f..8c8dece53 100644
--- a/pandas/tests/indexing/test_categorical.py
+++ b/pandas/tests/indexing/test_categorical.py
@@ -74,8 +74,8 @@ class TestCategoricalIndex:
             df.loc["d"] = 10
 
         msg = (
-            "cannot insert an item into a CategoricalIndex that is not"
-            " already an existing category"
+            "cannot insert an item into a CategoricalIndex that is not "
+            "already an existing category"
         )
         with pytest.raises(TypeError, match=msg):
             df.loc["d", "A"] = 10
@@ -365,8 +365,9 @@ class TestCategoricalIndex:
         # not all labels in the categories
         with pytest.raises(
             KeyError,
-            match="'a list-indexer must only include values that are in the"
-            " categories'",
+            match=(
+                "'a list-indexer must only include values that are in the categories'"
+            ),
         ):
             self.df2.loc[["a", "d"]]
 
diff --git a/pandas/tests/indexing/test_floats.py b/pandas/tests/indexing/test_floats.py
index 75bf23b39..2cc823256 100644
--- a/pandas/tests/indexing/test_floats.py
+++ b/pandas/tests/indexing/test_floats.py
@@ -90,11 +90,11 @@ class TestFloatIndexers:
                     else:
                         error = TypeError
                         msg = (
-                            r"cannot do (label|index|positional) indexing"
-                            r" on {klass} with these indexers \[3\.0\] of"
-                            r" {kind}|"
-                            "Cannot index by location index with a"
-                            " non-integer key".format(klass=type(i), kind=str(float))
+                            r"cannot do (label|index|positional) indexing "
+                            r"on {klass} with these indexers \[3\.0\] of "
+                            r"{kind}|"
+                            "Cannot index by location index with a "
+                            "non-integer key".format(klass=type(i), kind=str(float))
                         )
                     with pytest.raises(error, match=msg):
                         idxr(s)[3.0]
@@ -111,9 +111,9 @@ class TestFloatIndexers:
                 else:
                     error = TypeError
                     msg = (
-                        r"cannot do (label|index) indexing"
-                        r" on {klass} with these indexers \[3\.0\] of"
-                        r" {kind}".format(klass=type(i), kind=str(float))
+                        r"cannot do (label|index) indexing "
+                        r"on {klass} with these indexers \[3\.0\] of "
+                        r"{kind}".format(klass=type(i), kind=str(float))
                     )
                 with pytest.raises(error, match=msg):
                     s.loc[3.0]
@@ -344,9 +344,9 @@ class TestFloatIndexers:
                 for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:
 
                     msg = (
-                        "cannot do slice indexing"
-                        r" on {klass} with these indexers \[(3|4)\.0\] of"
-                        " {kind}".format(klass=type(index), kind=str(float))
+                        "cannot do slice indexing "
+                        r"on {klass} with these indexers \[(3|4)\.0\] of "
+                        "{kind}".format(klass=type(index), kind=str(float))
                     )
                     with pytest.raises(TypeError, match=msg):
                         s.iloc[l]
@@ -354,10 +354,10 @@ class TestFloatIndexers:
                     for idxr in [lambda x: x.loc, lambda x: x.iloc, lambda x: x]:
 
                         msg = (
-                            "cannot do slice indexing"
-                            r" on {klass} with these indexers"
-                            r" \[(3|4)(\.0)?\]"
-                            r" of ({kind_float}|{kind_int})".format(
+                            "cannot do slice indexing "
+                            r"on {klass} with these indexers "
+                            r"\[(3|4)(\.0)?\] "
+                            r"of ({kind_float}|{kind_int})".format(
                                 klass=type(index),
                                 kind_float=str(float),
                                 kind_int=str(int),
@@ -370,9 +370,9 @@ class TestFloatIndexers:
                 for l in [slice(3.0, 4), slice(3, 4.0), slice(3.0, 4.0)]:
 
                     msg = (
-                        "cannot do slice indexing"
-                        r" on {klass} with these indexers \[(3|4)\.0\] of"
-                        " {kind}".format(klass=type(index), kind=str(float))
+                        "cannot do slice indexing "
+                        r"on {klass} with these indexers \[(3|4)\.0\] of "
+                        "{kind}".format(klass=type(index), kind=str(float))
                     )
                     with pytest.raises(TypeError, match=msg):
                         s.iloc[l] = 0
@@ -424,9 +424,9 @@ class TestFloatIndexers:
 
                 # positional indexing
                 msg = (
-                    "cannot do slice indexing"
-                    r" on {klass} with these indexers \[(3|4)\.0\] of"
-                    " {kind}".format(klass=type(index), kind=str(float))
+                    "cannot do slice indexing "
+                    r"on {klass} with these indexers \[(3|4)\.0\] of "
+                    "{kind}".format(klass=type(index), kind=str(float))
                 )
                 with pytest.raises(TypeError, match=msg):
                     s[l]
@@ -448,9 +448,9 @@ class TestFloatIndexers:
 
             # positional indexing
             msg = (
-                "cannot do slice indexing"
-                r" on {klass} with these indexers \[-6\.0\] of"
-                " {kind}".format(klass=type(index), kind=str(float))
+                "cannot do slice indexing "
+                r"on {klass} with these indexers \[-6\.0\] of "
+                "{kind}".format(klass=type(index), kind=str(float))
             )
             with pytest.raises(TypeError, match=msg):
                 s[slice(-6.0, 6.0)]
@@ -474,9 +474,9 @@ class TestFloatIndexers:
 
                 # positional indexing
                 msg = (
-                    "cannot do slice indexing"
-                    r" on {klass} with these indexers \[(2|3)\.5\] of"
-                    " {kind}".format(klass=type(index), kind=str(float))
+                    "cannot do slice indexing "
+                    r"on {klass} with these indexers \[(2|3)\.5\] of "
+                    "{kind}".format(klass=type(index), kind=str(float))
                 )
                 with pytest.raises(TypeError, match=msg):
                     s[l]
@@ -492,9 +492,9 @@ class TestFloatIndexers:
 
                 # positional indexing
                 msg = (
-                    "cannot do slice indexing"
-                    r" on {klass} with these indexers \[(3|4)\.0\] of"
-                    " {kind}".format(klass=type(index), kind=str(float))
+                    "cannot do slice indexing "
+                    r"on {klass} with these indexers \[(3|4)\.0\] of "
+                    "{kind}".format(klass=type(index), kind=str(float))
                 )
                 with pytest.raises(TypeError, match=msg):
                     s[l] = 0
@@ -515,9 +515,9 @@ class TestFloatIndexers:
 
                 klass = RangeIndex
                 msg = (
-                    "cannot do slice indexing"
-                    r" on {klass} with these indexers \[(2|4)\.0\] of"
-                    " {kind}".format(klass=str(klass), kind=str(float))
+                    "cannot do slice indexing "
+                    r"on {klass} with these indexers \[(2|4)\.0\] of "
+                    "{kind}".format(klass=str(klass), kind=str(float))
                 )
                 with pytest.raises(TypeError, match=msg):
                     idxr(s)[l]
@@ -540,9 +540,9 @@ class TestFloatIndexers:
 
                     # positional indexing
                     msg = (
-                        "cannot do slice indexing"
-                        r" on {klass} with these indexers \[(0|1)\.0\] of"
-                        " {kind}".format(klass=type(index), kind=str(float))
+                        "cannot do slice indexing "
+                        r"on {klass} with these indexers \[(0|1)\.0\] of "
+                        "{kind}".format(klass=type(index), kind=str(float))
                     )
                     with pytest.raises(TypeError, match=msg):
                         s[l]
@@ -555,9 +555,9 @@ class TestFloatIndexers:
 
                 # positional indexing
                 msg = (
-                    "cannot do slice indexing"
-                    r" on {klass} with these indexers \[-10\.0\] of"
-                    " {kind}".format(klass=type(index), kind=str(float))
+                    "cannot do slice indexing "
+                    r"on {klass} with these indexers \[-10\.0\] of "
+                    "{kind}".format(klass=type(index), kind=str(float))
                 )
                 with pytest.raises(TypeError, match=msg):
                     s[slice(-10.0, 10.0)]
@@ -574,9 +574,9 @@ class TestFloatIndexers:
 
                     # positional indexing
                     msg = (
-                        "cannot do slice indexing"
-                        r" on {klass} with these indexers \[0\.5\] of"
-                        " {kind}".format(klass=type(index), kind=str(float))
+                        "cannot do slice indexing "
+                        r"on {klass} with these indexers \[0\.5\] of "
+                        "{kind}".format(klass=type(index), kind=str(float))
                     )
                     with pytest.raises(TypeError, match=msg):
                         s[l]
@@ -591,9 +591,9 @@ class TestFloatIndexers:
 
                     # positional indexing
                     msg = (
-                        "cannot do slice indexing"
-                        r" on {klass} with these indexers \[(3|4)\.0\] of"
-                        " {kind}".format(klass=type(index), kind=str(float))
+                        "cannot do slice indexing "
+                        r"on {klass} with these indexers \[(3|4)\.0\] of "
+                        "{kind}".format(klass=type(index), kind=str(float))
                     )
                     with pytest.raises(TypeError, match=msg):
                         s[l] = 0
diff --git a/pandas/tests/indexing/test_indexing.py b/pandas/tests/indexing/test_indexing.py
index be921c813..ea4d8edd2 100644
--- a/pandas/tests/indexing/test_indexing.py
+++ b/pandas/tests/indexing/test_indexing.py
@@ -83,8 +83,8 @@ class TestFancy(Base):
         msg = (
             r"Buffer has wrong number of dimensions \(expected 1,"
             r" got 3\)|"
-            "The truth value of an array with more than one element is"
-            " ambiguous|"
+            "The truth value of an array with more than one element is "
+            "ambiguous|"
             "Cannot index with multidimensional key|"
             r"Wrong number of dimensions. values.ndim != ndim \[3 != 1\]|"
             "No matching signature found|"  # TypeError
@@ -146,13 +146,13 @@ class TestFancy(Base):
         nd3 = np.random.randint(5, size=(2, 2, 2))
 
         msg = (
-            r"Buffer has wrong number of dimensions \(expected 1,"
-            r" got 3\)|"
-            "The truth value of an array with more than one element is"
-            " ambiguous|"
+            r"Buffer has wrong number of dimensions \(expected 1, "
+            r"got 3\)|"
+            "The truth value of an array with more than one element is "
+            "ambiguous|"
             "Only 1-dimensional input arrays are supported|"
-            "'pandas._libs.interval.IntervalTree' object has no attribute"
-            " 'set_value'|"  # AttributeError
+            "'pandas._libs.interval.IntervalTree' object has no attribute "
+            "'set_value'|"  # AttributeError
             "unhashable type: 'numpy.ndarray'|"  # TypeError
             "No matching signature found|"  # TypeError
             r"^\[\[\["  # pandas.core.indexing.IndexingError
diff --git a/pandas/tests/indexing/test_scalar.py b/pandas/tests/indexing/test_scalar.py
index 362a2c00e..a567fb9b8 100644
--- a/pandas/tests/indexing/test_scalar.py
+++ b/pandas/tests/indexing/test_scalar.py
@@ -132,8 +132,8 @@ class TestScalar(Base):
         result = s.at["a"]
         assert result == 1
         msg = (
-            "At based indexing on an non-integer index can only have"
-            " non-integer indexers"
+            "At based indexing on an non-integer index can only have "
+            "non-integer indexers"
         )
         with pytest.raises(ValueError, match=msg):
             s.at[0]
diff --git a/pandas/tests/resample/test_base.py b/pandas/tests/resample/test_base.py
index 476643bb3..f8a1810e6 100644
--- a/pandas/tests/resample/test_base.py
+++ b/pandas/tests/resample/test_base.py
@@ -84,8 +84,8 @@ def test_raises_on_non_datetimelike_index():
     # this is a non datetimelike index
     xp = DataFrame()
     msg = (
-        "Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex,"
-        " but got an instance of 'Index'"
+        "Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex, "
+        "but got an instance of 'Index'"
     )
     with pytest.raises(TypeError, match=msg):
         xp.resample("A").mean()
diff --git a/pandas/tests/resample/test_period_index.py b/pandas/tests/resample/test_period_index.py
index 40226ab2f..955f8c748 100644
--- a/pandas/tests/resample/test_period_index.py
+++ b/pandas/tests/resample/test_period_index.py
@@ -82,9 +82,9 @@ class TestPeriodIndex:
             index=pd.MultiIndex.from_arrays([rng, index], names=["v", "d"]),
         )
         msg = (
-            "Resampling from level= or on= selection with a PeriodIndex is"
-            r" not currently supported, use \.set_index\(\.\.\.\) to"
-            " explicitly set index"
+            "Resampling from level= or on= selection with a PeriodIndex is "
+            r"not currently supported, use \.set_index\(\.\.\.\) to "
+            "explicitly set index"
         )
         with pytest.raises(NotImplementedError, match=msg):
             df.resample(freq, kind=kind, **kwargs)
@@ -130,8 +130,8 @@ class TestPeriodIndex:
         # These are incompatible period rules for resampling
         ts = simple_period_range_series("1/1/1990", "6/30/1995", freq="w-wed")
         msg = (
-            "Frequency <Week: weekday=2> cannot be resampled to {}, as they"
-            " are not sub or super periods"
+            "Frequency <Week: weekday=2> cannot be resampled to {}, as they "
+            "are not sub or super periods"
         ).format(expected_error_msg)
         with pytest.raises(IncompatibleFrequency, match=msg):
             ts.resample(rule).mean()
@@ -236,8 +236,8 @@ class TestPeriodIndex:
 
     def test_resample_incompat_freq(self):
         msg = (
-            "Frequency <MonthEnd> cannot be resampled to <Week: weekday=6>,"
-            " as they are not sub or super periods"
+            "Frequency <MonthEnd> cannot be resampled to <Week: weekday=6>, "
+            "as they are not sub or super periods"
         )
         with pytest.raises(IncompatibleFrequency, match=msg):
             Series(
diff --git a/pandas/tests/resample/test_resample_api.py b/pandas/tests/resample/test_resample_api.py
index bc2d6df37..170201b4f 100644
--- a/pandas/tests/resample/test_resample_api.py
+++ b/pandas/tests/resample/test_resample_api.py
@@ -519,8 +519,8 @@ def test_selection_api_validation():
 
     # non DatetimeIndex
     msg = (
-        "Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex,"
-        " but got an instance of 'Int64Index'"
+        "Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex, "
+        "but got an instance of 'Int64Index'"
     )
     with pytest.raises(TypeError, match=msg):
         df.resample("2D", level="v")
@@ -539,8 +539,8 @@ def test_selection_api_validation():
 
     # upsampling not allowed
     msg = (
-        "Upsampling from level= or on= selection is not supported, use"
-        r" \.set_index\(\.\.\.\) to explicitly set index to datetime-like"
+        "Upsampling from level= or on= selection is not supported, use "
+        r"\.set_index\(\.\.\.\) to explicitly set index to datetime-like"
     )
     with pytest.raises(ValueError, match=msg):
         df.resample("2D", level="d").asfreq()
diff --git a/pandas/tests/tseries/offsets/test_offsets.py b/pandas/tests/tseries/offsets/test_offsets.py
index e98699f6b..c8b322b3c 100644
--- a/pandas/tests/tseries/offsets/test_offsets.py
+++ b/pandas/tests/tseries/offsets/test_offsets.py
@@ -2792,8 +2792,8 @@ class TestCustomBusinessDay(Base):
 
     def test_apply_corner(self):
         msg = (
-            "Only know how to combine trading day with datetime, datetime64"
-            " or timedelta"
+            "Only know how to combine trading day "
+            "with datetime, datetime64 or timedelta"
         )
         with pytest.raises(ApplyTypeError, match=msg):
             CDay().apply(BMonthEnd())
diff --git a/pandas/tests/window/moments/test_moments_rolling.py b/pandas/tests/window/moments/test_moments_rolling.py
index 9495d2bc7..9acb4ffcb 100644
--- a/pandas/tests/window/moments/test_moments_rolling.py
+++ b/pandas/tests/window/moments/test_moments_rolling.py
@@ -1128,8 +1128,8 @@ class TestRollingMomentsConsistency(ConsistencyBase):
         # GH3155
         # don't blow the stack
         msg = (
-            "arguments to moment function must be of type"
-            " np.ndarray/Series/DataFrame"
+            "arguments to moment function must be of type "
+            "np.ndarray/Series/DataFrame"
         )
         with pytest.raises(TypeError, match=msg):
             _flex_binary_moment(5, 6, None)

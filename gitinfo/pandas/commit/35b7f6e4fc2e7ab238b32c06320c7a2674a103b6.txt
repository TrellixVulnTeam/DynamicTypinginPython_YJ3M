commit 35b7f6e4fc2e7ab238b32c06320c7a2674a103b6
Author: Chang She <changshe@gmail.com>
Date:   Fri Nov 30 18:16:24 2012 -0500

    TST: multiprocessing tests

diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index ca2ea2e70..600e3b04b 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -450,7 +450,7 @@ class TestHDFStore(unittest.TestCase):
 
     def test_sparse_panel(self):
         items = ['x', 'y', 'z']
-        p = Panel(dict((i, tm.makeDataFrame()) for i in items))
+        p = Panel(dict((i, tm.makeDataFrame().ix[:2, :2]) for i in items))
         sp = p.to_sparse()
 
         self._check_double_roundtrip(sp, tm.assert_panel_equal,
diff --git a/pandas/io/tests/test_sql.py b/pandas/io/tests/test_sql.py
index df0188a18..a828c9466 100644
--- a/pandas/io/tests/test_sql.py
+++ b/pandas/io/tests/test_sql.py
@@ -10,14 +10,14 @@ import pandas.util.testing as tm
 from pandas import Series, Index, DataFrame
 
 class TestSQLite(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         self.db = sqlite3.connect(':memory:')
 
     def test_basic(self):
         frame = tm.makeTimeDataFrame()
         self._check_roundtrip(frame)
-    
+
     def test_write_row_by_row(self):
         frame = tm.makeTimeDataFrame()
         frame.ix[0, 0] = np.nan
@@ -177,7 +177,7 @@ class TestSQLite(unittest.TestCase):
         df = DataFrame({'From':np.ones(5)})
         #print sql.get_sqlite_schema(df, 'testkeywords')
         sql.write_frame(df, con = self.db, name = 'testkeywords')
-        
+
 if __name__ == '__main__':
     # unittest.main()
     import nose
diff --git a/pandas/io/tests/test_yahoo.py b/pandas/io/tests/test_yahoo.py
index fab15ef6e..9b15e19dd 100644
--- a/pandas/io/tests/test_yahoo.py
+++ b/pandas/io/tests/test_yahoo.py
@@ -8,10 +8,12 @@ import unittest
 import pandas.io.data as pd
 import nose
 from pandas.util.testing import network
+from numpy.testing.decorators import slow
 import urllib2
 
 class TestYahoo(unittest.TestCase):
 
+    @slow
     @network
     def test_yahoo(self):
         # asserts that yahoo is minimally working and that it throws
diff --git a/pandas/sparse/tests/test_array.py b/pandas/sparse/tests/test_array.py
index 459732147..48bd49257 100644
--- a/pandas/sparse/tests/test_array.py
+++ b/pandas/sparse/tests/test_array.py
@@ -20,7 +20,7 @@ def assert_sp_array_equal(left, right):
 
 
 class TestSparseArray(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         self.arr_data = np.array([nan, nan, 1, 2, 3, nan, 4, 5, nan, 6])
         self.arr = SparseArray(self.arr_data)
diff --git a/pandas/sparse/tests/test_list.py b/pandas/sparse/tests/test_list.py
index 2b061bada..18a0a55c2 100644
--- a/pandas/sparse/tests/test_list.py
+++ b/pandas/sparse/tests/test_list.py
@@ -14,6 +14,8 @@ def assert_sp_list_equal(left, right):
 
 class TestSparseList(unittest.TestCase):
 
+    _multiprocess_can_split_ = True
+
     def setUp(self):
         self.na_data = np.array([nan, nan, 1, 2, 3, nan, 4, 5, nan, 6])
         self.zero_data = np.array([0, 0, 1, 2, 3, 0, 4, 5, 0, 6])
diff --git a/pandas/sparse/tests/test_sparse.py b/pandas/sparse/tests/test_sparse.py
index b96719227..eeadcbea0 100644
--- a/pandas/sparse/tests/test_sparse.py
+++ b/pandas/sparse/tests/test_sparse.py
@@ -110,7 +110,7 @@ def assert_sp_panel_equal(left, right, exact_indices=True):
 
 class TestSparseSeries(TestCase,
                        test_series.CheckNameIntegration):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         arr, index = _test_data1()
 
@@ -686,7 +686,7 @@ class TestSparseTimeSeries(TestCase):
 
 class TestSparseDataFrame(TestCase, test_frame.SafeForSparse):
     klass = SparseDataFrame
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         self.data = {'A' : [nan, nan, nan, 0, 1, 2, 3, 4, 5, 6],
                      'B' : [0, 1, 2, nan, nan, nan, 3, 4, 5, 6],
@@ -851,7 +851,37 @@ class TestSparseDataFrame(TestCase, test_frame.SafeForSparse):
         tmp = sys.stderr
         sys.stderr = buf
         try:
-            self._check_all(self._check_frame_ops)
+            self._check_frame_ops(self.frame)
+        finally:
+            sys.stderr = tmp
+
+    def test_sparse_series_ops_i(self):
+        import sys
+        buf = StringIO()
+        tmp = sys.stderr
+        sys.stderr = buf
+        try:
+            self._check_frame_ops(self.iframe)
+        finally:
+            sys.stderr = tmp
+
+    def test_sparse_series_ops_z(self):
+        import sys
+        buf = StringIO()
+        tmp = sys.stderr
+        sys.stderr = buf
+        try:
+            self._check_frame_ops(self.zframe)
+        finally:
+            sys.stderr = tmp
+
+    def test_sparse_series_ops_fill(self):
+        import sys
+        buf = StringIO()
+        tmp = sys.stderr
+        sys.stderr = buf
+        try:
+            self._check_frame_ops(self.fill_frame)
         finally:
             sys.stderr = tmp
 
@@ -1406,7 +1436,7 @@ def panel_data3():
 class TestSparsePanel(TestCase,
                       test_panel.SafeForLongAndSparse,
                       test_panel.SafeForSparse):
-
+    _multiprocess_can_split_ = True
     @classmethod
     def assert_panel_equal(cls, x, y):
         assert_sp_panel_equal(x, y)
diff --git a/pandas/tests/test_algos.py b/pandas/tests/test_algos.py
index eb397a069..3bf64e5d3 100644
--- a/pandas/tests/test_algos.py
+++ b/pandas/tests/test_algos.py
@@ -10,7 +10,7 @@ import pandas.util.testing as tm
 
 
 class TestMatch(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def test_ints(self):
         values = np.array([0, 2, 1])
         to_match = np.array([0, 1, 2, 2, 0, 1, 3, 0])
@@ -29,7 +29,7 @@ class TestMatch(unittest.TestCase):
 
 
 class TestUnique(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def test_ints(self):
         arr = np.random.randint(0, 100, size=50)
 
@@ -70,4 +70,3 @@ if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)
-
diff --git a/pandas/tests/test_common.py b/pandas/tests/test_common.py
index b9d495af1..21ab77585 100644
--- a/pandas/tests/test_common.py
+++ b/pandas/tests/test_common.py
@@ -14,6 +14,8 @@ import numpy as np
 from pandas.tslib import iNaT
 from pandas.util import py3compat
 
+_multiprocess_can_split_ = True
+
 def test_is_sequence():
     is_seq=com._is_sequence
     assert(is_seq((1,2)))
@@ -246,6 +248,8 @@ def test_pprint_thing():
 
 class TestTake(unittest.TestCase):
 
+    _multiprocess_can_split_ = True
+
     def test_1d_with_out(self):
         def _test_dtype(dtype):
             out = np.empty(5, dtype=dtype)
diff --git a/pandas/tests/test_config.py b/pandas/tests/test_config.py
index 6b91fa1e7..5c1309218 100644
--- a/pandas/tests/test_config.py
+++ b/pandas/tests/test_config.py
@@ -7,7 +7,7 @@ import warnings
 import nose
 
 class TestConfig(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def __init__(self,*args):
         super(TestConfig,self).__init__(*args)
 
diff --git a/pandas/tests/test_factor.py b/pandas/tests/test_factor.py
index 863eaf19f..550225318 100644
--- a/pandas/tests/test_factor.py
+++ b/pandas/tests/test_factor.py
@@ -16,7 +16,7 @@ import pandas.util.testing as tm
 
 
 class TestCategorical(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         self.factor = Categorical.from_array(['a', 'b', 'b', 'a',
                                          'a', 'c', 'c', 'c'])
@@ -115,5 +115,3 @@ if __name__ == '__main__':
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                          # '--with-coverage', '--cover-package=pandas.core'],
                    exit=False)
-
-
diff --git a/pandas/tests/test_format.py b/pandas/tests/test_format.py
index 1379615e9..8baf34b5d 100644
--- a/pandas/tests/test_format.py
+++ b/pandas/tests/test_format.py
@@ -28,7 +28,7 @@ def curpath():
     return pth
 
 class TestDataFrameFormatting(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         self.frame = _frame.copy()
 
@@ -843,7 +843,7 @@ class TestDataFrameFormatting(unittest.TestCase):
         self.frame.to_latex()
 
 class TestSeriesFormatting(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         self.ts = tm.makeTimeSeries()
 
@@ -958,7 +958,7 @@ class TestSeriesFormatting(unittest.TestCase):
         self.assertTrue('2012-01-01' in result)
 
 class TestEngFormatter(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def test_eng_float_formatter(self):
         df = DataFrame({'A' : [1.41, 141., 14100, 1410000.]})
 
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 675b2c750..d13a9b837 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -32,6 +32,8 @@ from pandas.util import py3compat
 import pandas.util.testing as tm
 import pandas.lib as lib
 
+from numpy.testing.decorators import slow
+
 def _skip_if_no_scipy():
     try:
         import scipy.stats
@@ -45,6 +47,8 @@ JOIN_TYPES = ['inner', 'outer', 'left', 'right']
 
 class CheckIndexing(object):
 
+    _multiprocess_can_split_ = True
+
     def test_getitem(self):
         # slicing
 
@@ -1370,6 +1374,8 @@ _mixed_frame['foo'] = 'bar'
 
 class SafeForSparse(object):
 
+    _multiprocess_can_split_ = True
+
     def test_getitem_pop_assign_name(self):
         s = self.frame['A']
         self.assertEqual(s.name, 'A')
@@ -1493,6 +1499,8 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
                     SafeForSparse):
     klass = DataFrame
 
+    _multiprocess_can_split_ = True
+
     def setUp(self):
         self.frame = _frame.copy()
         self.frame2 = _frame2.copy()
@@ -2868,7 +2876,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         del df['A']
         self.assertFalse(df.empty)
 
-    def test_repr(self):
+    def test_repr_empty(self):
         buf = StringIO()
 
         # empty
@@ -2878,23 +2886,15 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         frame = DataFrame(index=np.arange(1000))
         foo = repr(frame)
 
-        # small one
-        foo = repr(self.frame)
-        self.frame.info(verbose=False, buf=buf)
-
-        # even smaller
-        self.frame.reindex(columns=['A']).info(verbose=False, buf=buf)
-        self.frame.reindex(columns=['A', 'B']).info(verbose=False, buf=buf)
-
-        # big one
-        biggie = DataFrame(np.zeros((200, 4)), columns=range(4),
-                            index=range(200))
-        foo = repr(biggie)
+    def test_repr_mixed(self):
+        buf = StringIO()
 
         # mixed
         foo = repr(self.mixed_frame)
         self.mixed_frame.info(verbose=False, buf=buf)
 
+    @slow
+    def test_repr_mixed_big(self):
         # big mixed
         biggie = DataFrame({'A' : randn(200),
                              'B' : tm.makeStringIndex(200)},
@@ -2904,6 +2904,17 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
 
         foo = repr(biggie)
 
+    def test_repr(self):
+        buf = StringIO()
+
+        # small one
+        foo = repr(self.frame)
+        self.frame.info(verbose=False, buf=buf)
+
+        # even smaller
+        self.frame.reindex(columns=['A']).info(verbose=False, buf=buf)
+        self.frame.reindex(columns=['A', 'B']).info(verbose=False, buf=buf)
+
         # exhausting cases in DataFrame.info
 
         # columns but no index
@@ -2913,6 +2924,16 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         # no columns or index
         self.empty.info(buf=buf)
 
+    @slow
+    def test_repr_big(self):
+        buf = StringIO()
+
+        # big one
+        biggie = DataFrame(np.zeros((200, 4)), columns=range(4),
+                           index=range(200))
+        foo = repr(biggie)
+
+    def test_repr_unsortable(self):
         # columns are not sortable
 
         unsortable = DataFrame({'foo' : [1] * 50,
@@ -3599,7 +3620,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         self.assertRaises(TypeError, df.__eq__, None)
 
     def test_to_csv_from_csv(self):
-        path = '__tmp__'
+        path = '__tmp_to_csv_from_csv__'
 
         self.frame['A'][:5] = nan
 
@@ -3663,7 +3684,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         os.remove(path)
 
     def test_to_csv_multiindex(self):
-        path = '__tmp__'
+        path = '__tmp_to_csv_multiindex__'
 
         frame = self.frame
         old_index = frame.index
@@ -3713,11 +3734,13 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         self.assert_(recons.columns.equals(exp.columns))
         self.assert_(len(recons) == 0)
 
+        os.remove(path)
+
     def test_to_csv_float32_nanrep(self):
         df = DataFrame(np.random.randn(1, 4).astype(np.float32))
         df[1] = np.nan
 
-        pth = '__tmp__.csv'
+        pth = '__tmp_to_csv_float32_nanrep__.csv'
         df.to_csv(pth, na_rep=999)
 
         lines = open(pth).readlines()
@@ -3726,7 +3749,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
 
     def test_to_csv_withcommas(self):
 
-        path = '__tmp__'
+        path = '__tmp_to_csv_withcommas__'
         # Commas inside fields should be correctly escaped when saving as CSV.
 
         df = DataFrame({'A':[1,2,3], 'B':['5,6','7,8','9,0']})
@@ -3737,7 +3760,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         os.remove(path)
 
     def test_to_csv_bug(self):
-        path = '__tmp__.csv'
+        path = '__tmp_to_csv_bug__.csv'
         f1 = StringIO('a,1.0\nb,2.0')
         df = DataFrame.from_csv(f1,header=None)
         newdf = DataFrame({'t': df[df.columns[0]]})
@@ -3749,7 +3772,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         os.remove(path)
 
     def test_to_csv_unicode(self):
-        path = '__tmp__.csv'
+        path = '__tmp_to_csv_unicode__.csv'
         df = DataFrame({u'c/\u03c3':[1,2,3]})
         df.to_csv(path, encoding='UTF-8')
         df2 = pan.read_csv(path, index_col=0, encoding='UTF-8')
@@ -3781,7 +3804,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         assert_frame_equal(recons, self.frame)
 
     def test_to_csv_float_format(self):
-        filename = '__tmp__.csv'
+        filename = '__tmp_to_csv_float_format__.csv'
         df = DataFrame([[0.123456, 0.234567, 0.567567],
                         [12.32112, 123123.2, 321321.2]],
                        index=['A', 'B'], columns=['X', 'Y', 'Z'])
@@ -3860,9 +3883,17 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         self.assertEqual(buf.getvalue(), expected)
 
 
+    def test_excel_roundtrip_xls(self):
+        try:
+            import xlwt
+            import xlrd
+            import openpyxl
+        except ImportError:
+            raise nose.SkipTest
 
+        self._check_extension('xls')
 
-    def test_to_excel_from_excel(self):
+    def test_excel_roundtrip_xlsx(self):
         try:
             import xlwt
             import xlrd
@@ -3870,124 +3901,326 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         except ImportError:
             raise nose.SkipTest
 
-        for ext in ['xls', 'xlsx']:
-            path = '__tmp__.' + ext
+        self._check_extension('xlsx')
 
-            self.frame['A'][:5] = nan
+    def _check_extension(self, ext):
+        path = '__tmp_to_excel_from_excel__.' + ext
 
-            self.frame.to_excel(path,'test1')
-            self.frame.to_excel(path,'test1', cols=['A', 'B'])
-            self.frame.to_excel(path,'test1', header=False)
-            self.frame.to_excel(path,'test1', index=False)
+        self.frame['A'][:5] = nan
 
-            # test roundtrip
-            self.frame.to_excel(path,'test1')
-            reader = ExcelFile(path)
-            recons = reader.parse('test1', index_col=0, has_index_names=True)
-            assert_frame_equal(self.frame, recons)
+        self.frame.to_excel(path,'test1')
+        self.frame.to_excel(path,'test1', cols=['A', 'B'])
+        self.frame.to_excel(path,'test1', header=False)
+        self.frame.to_excel(path,'test1', index=False)
 
-            self.frame.to_excel(path,'test1', index=False)
-            reader = ExcelFile(path)
-            recons = reader.parse('test1', index_col=None)
-            recons.index = self.frame.index
-            assert_frame_equal(self.frame, recons)
+        # test roundtrip
+        self.frame.to_excel(path,'test1')
+        reader = ExcelFile(path)
+        recons = reader.parse('test1', index_col=0, has_index_names=True)
+        assert_frame_equal(self.frame, recons)
 
-            # self.frame.to_excel(path,'test1')
-            # reader = ExcelFile(path)
-            # recons = reader.parse('test1', index_col=0, skiprows=[2], has_index_names=True)
-            # assert_frame_equal(self.frame.ix[1:], recons)
+        self.frame.to_excel(path,'test1', index=False)
+        reader = ExcelFile(path)
+        recons = reader.parse('test1', index_col=None)
+        recons.index = self.frame.index
+        assert_frame_equal(self.frame, recons)
 
-            self.frame.to_excel(path,'test1',na_rep='NA')
-            reader = ExcelFile(path)
-            recons = reader.parse('test1', index_col=0, na_values=['NA'], has_index_names=True)
-            assert_frame_equal(self.frame, recons)
+        self.frame.to_excel(path,'test1',na_rep='NA')
+        reader = ExcelFile(path)
+        recons = reader.parse('test1', index_col=0, na_values=['NA'],
+                              has_index_names=True)
+        assert_frame_equal(self.frame, recons)
 
-            self.mixed_frame.to_excel(path,'test1')
-            reader = ExcelFile(path)
-            recons = reader.parse('test1', index_col=0, has_index_names=True)
-            assert_frame_equal(self.mixed_frame, recons)
+        os.remove(path)
 
-            self.tsframe.to_excel(path, 'test1')
-            reader = ExcelFile(path)
-            recons = reader.parse('test1')
-            assert_frame_equal(self.tsframe, recons)
+    def test_excel_roundtrip_xls_mixed(self):
+        try:
+            import xlwt
+            import xlrd
+        except ImportError:
+            raise nose.SkipTest
 
-            #Test np.int64, values read come back as float
-            frame = DataFrame(np.random.randint(-10,10,size=(10,2)))
-            frame.to_excel(path,'test1')
-            reader = ExcelFile(path)
-            recons = reader.parse('test1').astype(np.int64)
-            assert_frame_equal(frame, recons)
+        self._check_extension_mixed('xls')
 
-            #Test reading/writing np.bool8, roundtrip only works for xlsx
-            frame = (DataFrame(np.random.randn(10,2)) >= 0)
-            frame.to_excel(path,'test1')
-            reader = ExcelFile(path)
-            recons = reader.parse('test1').astype(np.bool8)
-            assert_frame_equal(frame, recons)
-
-            # Test writing to separate sheets
-            writer = ExcelWriter(path)
-            self.frame.to_excel(writer,'test1')
-            self.tsframe.to_excel(writer,'test2')
-            writer.save()
-            reader = ExcelFile(path)
-            recons = reader.parse('test1',index_col=0, has_index_names=True)
-            assert_frame_equal(self.frame, recons)
-            recons = reader.parse('test2',index_col=0)
-            assert_frame_equal(self.tsframe, recons)
-            np.testing.assert_equal(2, len(reader.sheet_names))
-            np.testing.assert_equal('test1', reader.sheet_names[0])
-            np.testing.assert_equal('test2', reader.sheet_names[1])
-
-            # column aliases
-            col_aliases = Index(['AA', 'X', 'Y', 'Z'])
-            self.frame2.to_excel(path, 'test1', header=col_aliases)
-            reader = ExcelFile(path)
-            rs = reader.parse('test1', index_col=0, has_index_names=True)
-            xp = self.frame2.copy()
-            xp.columns = col_aliases
-            assert_frame_equal(xp, rs)
-
-            # test index_label
-            frame = (DataFrame(np.random.randn(10,2)) >= 0)
-            frame.to_excel(path, 'test1', index_label=['test'])
-            reader = ExcelFile(path)
-            recons = reader.parse('test1', index_col=0, has_index_names=True).astype(np.int64)
-            frame.index.names = ['test']
-            self.assertEqual(frame.index.names, recons.index.names)
+    def test_excel_roundtrip_xlsx_mixed(self):
+        try:
+            import openpyxl
+        except ImportError:
+            raise nose.SkipTest
 
-            frame = (DataFrame(np.random.randn(10,2)) >= 0)
-            frame.to_excel(path, 'test1', index_label=['test', 'dummy', 'dummy2'])
-            reader = ExcelFile(path)
-            recons = reader.parse('test1', index_col=0, has_index_names=True).astype(np.int64)
-            frame.index.names = ['test']
-            self.assertEqual(frame.index.names, recons.index.names)
+        self._check_extension_mixed('xlsx')
 
-            frame = (DataFrame(np.random.randn(10,2)) >= 0)
-            frame.to_excel(path, 'test1', index_label='test')
-            reader = ExcelFile(path)
-            recons = reader.parse('test1', index_col=0, has_index_names=True).astype(np.int64)
-            frame.index.names = ['test']
-            self.assertEqual(frame.index.names, recons.index.names)
+    def _check_extension_mixed(self, ext):
+        path = '__tmp_to_excel_from_excel_mixed__.' + ext
+
+        self.mixed_frame.to_excel(path,'test1')
+        reader = ExcelFile(path)
+        recons = reader.parse('test1', index_col=0, has_index_names=True)
+        assert_frame_equal(self.mixed_frame, recons)
+
+        os.remove(path)
 
-            #test index_labels in same row as column names
-            self.frame.to_excel('/tmp/tests.xls', 'test1', cols=['A', 'B', 'C', 'D'], index=False)
-            #take 'A' and 'B' as indexes (they are in same row as cols 'C', 'D')
-            df = self.frame.copy()
-            df = df.set_index(['A', 'B'])
+    def test_excel_roundtrip_xls_tsframe(self):
+        try:
+            import xlwt
+            import xlrd
+        except ImportError:
+            raise nose.SkipTest
 
+        self._check_extension_tsframe('xls')
 
-            reader = ExcelFile('/tmp/tests.xls')
-            recons = reader.parse('test1', index_col=[0, 1])
-            assert_frame_equal(df, recons)
+    def test_excel_roundtrip_xlsx_tsframe(self):
+        try:
+            import openpyxl
+        except ImportError:
+            raise nose.SkipTest
 
+        self._check_extension_tsframe('xlsx')
 
+    def _check_extension_tsframe(self, ext):
+        path = '__tmp_to_excel_from_excel_tsframe__.' + ext
 
-            os.remove(path)
+        self.tsframe.to_excel(path, 'test1')
+        reader = ExcelFile(path)
+        recons = reader.parse('test1')
+        assert_frame_equal(self.tsframe, recons)
+
+        os.remove(path)
+
+    def test_excel_roundtrip_xls_int64(self):
+        try:
+            import xlwt
+            import xlrd
+            import openpyxl
+        except ImportError:
+            raise nose.SkipTest
 
+        self._check_extension_int64('xls')
+
+    def test_excel_roundtrip_xlsx_int64(self):
+        try:
+            import xlwt
+            import xlrd
+            import openpyxl
+        except ImportError:
+            raise nose.SkipTest
+
+        self._check_extension_int64('xlsx')
+
+    def _check_extension_int64(self, ext):
+        path = '__tmp_to_excel_from_excel_int64__.' + ext
+
+        self.frame['A'][:5] = nan
+
+        self.frame.to_excel(path,'test1')
+        self.frame.to_excel(path,'test1', cols=['A', 'B'])
+        self.frame.to_excel(path,'test1', header=False)
+        self.frame.to_excel(path,'test1', index=False)
+
+        #Test np.int64, values read come back as float
+        frame = DataFrame(np.random.randint(-10,10,size=(10,2)))
+        frame.to_excel(path,'test1')
+        reader = ExcelFile(path)
+        recons = reader.parse('test1').astype(np.int64)
+        assert_frame_equal(frame, recons)
+
+        os.remove(path)
+
+    def test_excel_roundtrip_xls_bool(self):
+        try:
+            import xlwt
+            import xlrd
+            import openpyxl
+        except ImportError:
+            raise nose.SkipTest
+
+        self._check_extension_bool('xls')
+
+    def test_excel_roundtrip_xlsx_bool(self):
+        try:
+            import xlwt
+            import xlrd
+            import openpyxl
+        except ImportError:
+            raise nose.SkipTest
+
+        self._check_extension_bool('xlsx')
+
+
+    def _check_extension_bool(self, ext):
+        path = '__tmp_to_excel_from_excel_bool__.' + ext
+
+        self.frame['A'][:5] = nan
+
+        self.frame.to_excel(path,'test1')
+        self.frame.to_excel(path,'test1', cols=['A', 'B'])
+        self.frame.to_excel(path,'test1', header=False)
+        self.frame.to_excel(path,'test1', index=False)
+
+        #Test reading/writing np.bool8, roundtrip only works for xlsx
+        frame = (DataFrame(np.random.randn(10,2)) >= 0)
+        frame.to_excel(path,'test1')
+        reader = ExcelFile(path)
+        recons = reader.parse('test1').astype(np.bool8)
+        assert_frame_equal(frame, recons)
+
+        os.remove(path)
+
+    def test_excel_roundtrip_xls_sheets(self):
+        try:
+            import xlwt
+            import xlrd
+            import openpyxl
+        except ImportError:
+            raise nose.SkipTest
+
+        self._check_extension_sheets('xls')
+
+    def test_excel_roundtrip_xlsx_sheets(self):
+        try:
+            import xlwt
+            import xlrd
+            import openpyxl
+        except ImportError:
+            raise nose.SkipTest
+
+        self._check_extension_sheets('xlsx')
+
+
+    def _check_extension_sheets(self, ext):
+        path = '__tmp_to_excel_from_excel_sheets__.' + ext
+
+        self.frame['A'][:5] = nan
+
+        self.frame.to_excel(path,'test1')
+        self.frame.to_excel(path,'test1', cols=['A', 'B'])
+        self.frame.to_excel(path,'test1', header=False)
+        self.frame.to_excel(path,'test1', index=False)
+
+        # Test writing to separate sheets
+        writer = ExcelWriter(path)
+        self.frame.to_excel(writer,'test1')
+        self.tsframe.to_excel(writer,'test2')
+        writer.save()
+        reader = ExcelFile(path)
+        recons = reader.parse('test1',index_col=0, has_index_names=True)
+        assert_frame_equal(self.frame, recons)
+        recons = reader.parse('test2',index_col=0)
+        assert_frame_equal(self.tsframe, recons)
+        np.testing.assert_equal(2, len(reader.sheet_names))
+        np.testing.assert_equal('test1', reader.sheet_names[0])
+        np.testing.assert_equal('test2', reader.sheet_names[1])
+
+        os.remove(path)
+
+    def test_excel_roundtrip_xls_colaliases(self):
+        try:
+            import xlwt
+            import xlrd
+            import openpyxl
+        except ImportError:
+            raise nose.SkipTest
+
+        self._check_extension_colaliases('xls')
+
+    def test_excel_roundtrip_xlsx_colaliases(self):
+        try:
+            import xlwt
+            import xlrd
+            import openpyxl
+        except ImportError:
+            raise nose.SkipTest
+
+        self._check_extension_colaliases('xlsx')
+
+    def _check_extension_colaliases(self, ext):
+        path = '__tmp_to_excel_from_excel_aliases__.' + ext
+
+        self.frame['A'][:5] = nan
+
+        self.frame.to_excel(path,'test1')
+        self.frame.to_excel(path,'test1', cols=['A', 'B'])
+        self.frame.to_excel(path,'test1', header=False)
+        self.frame.to_excel(path,'test1', index=False)
+
+        # column aliases
+        col_aliases = Index(['AA', 'X', 'Y', 'Z'])
+        self.frame2.to_excel(path, 'test1', header=col_aliases)
+        reader = ExcelFile(path)
+        rs = reader.parse('test1', index_col=0, has_index_names=True)
+        xp = self.frame2.copy()
+        xp.columns = col_aliases
+        assert_frame_equal(xp, rs)
+
+        os.remove(path)
+
+    def test_excel_roundtrip_xls_indexlabels(self):
+        try:
+            import xlwt
+            import xlrd
+            import openpyxl
+        except ImportError:
+            raise nose.SkipTest
+
+        self._check_extension_indexlabels('xls')
+
+    def test_excel_roundtrip_xlsx_indexlabels(self):
+        try:
+            import xlwt
+            import xlrd
+            import openpyxl
+        except ImportError:
+            raise nose.SkipTest
+
+        self._check_extension_indexlabels('xlsx')
+
+    def _check_extension_indexlabels(self, ext):
+        path = '__tmp_to_excel_from_excel_indexlabels__.' + ext
+
+        self.frame['A'][:5] = nan
+
+        self.frame.to_excel(path,'test1')
+        self.frame.to_excel(path,'test1', cols=['A', 'B'])
+        self.frame.to_excel(path,'test1', header=False)
+        self.frame.to_excel(path,'test1', index=False)
+
+        # test index_label
+        frame = (DataFrame(np.random.randn(10,2)) >= 0)
+        frame.to_excel(path, 'test1', index_label=['test'])
+        reader = ExcelFile(path)
+        recons = reader.parse('test1', index_col=0, has_index_names=True).astype(np.int64)
+        frame.index.names = ['test']
+        self.assertEqual(frame.index.names, recons.index.names)
+
+        frame = (DataFrame(np.random.randn(10,2)) >= 0)
+        frame.to_excel(path, 'test1', index_label=['test', 'dummy', 'dummy2'])
+        reader = ExcelFile(path)
+        recons = reader.parse('test1', index_col=0, has_index_names=True).astype(np.int64)
+        frame.index.names = ['test']
+        self.assertEqual(frame.index.names, recons.index.names)
+
+        frame = (DataFrame(np.random.randn(10,2)) >= 0)
+        frame.to_excel(path, 'test1', index_label='test')
+        reader = ExcelFile(path)
+        recons = reader.parse('test1', index_col=0, has_index_names=True).astype(np.int64)
+        frame.index.names = ['test']
+        self.assertEqual(frame.index.names, recons.index.names)
+
+        #test index_labels in same row as column names
+        self.frame.to_excel('/tmp/tests.xls', 'test1', cols=['A', 'B', 'C', 'D'], index=False)
+        #take 'A' and 'B' as indexes (they are in same row as cols 'C', 'D')
+        df = self.frame.copy()
+        df = df.set_index(['A', 'B'])
+
+        reader = ExcelFile('/tmp/tests.xls')
+        recons = reader.parse('test1', index_col=[0, 1])
+        assert_frame_equal(df, recons)
+
+        os.remove(path)
+
+    def test_excel_roundtrip_datetime(self):
         # datetime.date, not sure what to test here exactly
-        path = '__tmp__.xls'
+        path = '__tmp_excel_roundtrip_datetime__.xls'
         tsf = self.tsframe.copy()
         tsf.index = [x.date() for x in self.tsframe.index]
         tsf.to_excel(path, 'test1')
@@ -3996,8 +4229,9 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         assert_frame_equal(self.tsframe, recons)
         os.remove(path)
 
+    def test_excel_roundtrip_bool(self):
         #Test roundtrip np.bool8, does not seem to work for xls
-        path = '__tmp__.xlsx'
+        path = '__tmp_excel_roundtrip_bool__.xlsx'
         frame = (DataFrame(np.random.randn(10,2)) >= 0)
         frame.to_excel(path,'test1')
         reader = ExcelFile(path)
@@ -4014,7 +4248,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
             raise nose.SkipTest
 
         for ext in ['xls', 'xlsx']:
-            path = '__tmp__.' + ext
+            path = '__tmp_to_excel_periodindex__.' + ext
             frame = self.tsframe
             xp = frame.resample('M', kind='period')
             xp.to_excel(path, 'sht1')
@@ -4028,76 +4262,81 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         try:
             import xlwt
             import xlrd
+        except ImportError:
+            raise nose.SkipTest
+
+        self._check_excel_multiindex('xls')
+
+    def test_to_excel_multiindex_xlsx(self):
+        try:
             import openpyxl
         except ImportError:
             raise nose.SkipTest
 
-        for ext in ['xls', 'xlsx']:
-            path = '__tmp__.' + ext
+        self._check_excel_multiindex('xlsx')
 
-            frame = self.frame
-            old_index = frame.index
-            arrays = np.arange(len(old_index)*2).reshape(2,-1)
-            new_index = MultiIndex.from_arrays(arrays,
-                                               names=['first', 'second'])
-            frame.index = new_index
-            frame.to_excel(path, 'test1', header=False)
-            frame.to_excel(path, 'test1', cols=['A', 'B'])
-
-            # round trip
-            frame.to_excel(path, 'test1')
-            reader = ExcelFile(path)
-            df = reader.parse('test1', index_col=[0,1], parse_dates=False, has_index_names=True)
-            assert_frame_equal(frame, df)
-            self.assertEqual(frame.index.names, df.index.names)
-            self.frame.index = old_index # needed if setUP becomes a classmethod
-
-            # try multiindex with dates
-            tsframe = self.tsframe
-            old_index = tsframe.index
-            new_index = [old_index, np.arange(len(old_index))]
-            tsframe.index = MultiIndex.from_arrays(new_index)
-
-            tsframe.to_excel(path, 'test1', index_label = ['time','foo'])
-            reader = ExcelFile(path)
-            recons = reader.parse('test1', index_col=[0,1], has_index_names=True)
-            assert_frame_equal(tsframe, recons)
+    def _check_excel_multiindex(self, ext):
+        path = '__tmp_to_excel_multiindex__' + ext + '__.'+ext
 
-            # infer index
-            tsframe.to_excel(path, 'test1')
-            reader = ExcelFile(path)
-            recons = reader.parse('test1')
-            assert_frame_equal(tsframe, recons)
+        frame = self.frame
+        old_index = frame.index
+        arrays = np.arange(len(old_index)*2).reshape(2,-1)
+        new_index = MultiIndex.from_arrays(arrays,
+                                           names=['first', 'second'])
+        frame.index = new_index
+        frame.to_excel(path, 'test1', header=False)
+        frame.to_excel(path, 'test1', cols=['A', 'B'])
+
+        # round trip
+        frame.to_excel(path, 'test1')
+        reader = ExcelFile(path)
+        df = reader.parse('test1', index_col=[0,1], parse_dates=False, has_index_names=True)
+        assert_frame_equal(frame, df)
+        self.assertEqual(frame.index.names, df.index.names)
+        self.frame.index = old_index # needed if setUP becomes a classmethod
+
+        os.remove(path)
+
+    def test_to_excel_multiindex_dates(self):
+        try:
+            import xlwt
+            import xlrd
+        except ImportError:
+            raise nose.SkipTest
+
+        self._check_excel_multiindex_dates('xls')
 
+    def test_to_excel_multiindex_xlsx_dates(self):
+        try:
+            import openpyxl
+        except ImportError:
+            raise nose.SkipTest
 
-            # no index
-            #TODO : mention this does not make sence anymore
-            #with  the new formatting as we are not alligning colnames and indexlabels
-            #on the same row
+        self._check_excel_multiindex_dates('xlsx')
 
-            # tsframe.index.names = ['first', 'second']
-            # tsframe.to_excel(path, 'test1')
-            # reader = ExcelFile(path)
-            # recons = reader.parse('test1')
-            # assert_almost_equal(tsframe.values,
-            #                     recons.ix[:, tsframe.columns].values)
-            # self.assertEqual(len(tsframe.columns) + 2, len(recons.columns))
+    def _check_excel_multiindex_dates(self, ext):
+        path = '__tmp_to_excel_multiindex_dates__' + ext + '__.' + ext
 
-            # tsframe.index.names = [None, None]
+        # try multiindex with dates
+        tsframe = self.tsframe
+        old_index = tsframe.index
+        new_index = [old_index, np.arange(len(old_index))]
+        tsframe.index = MultiIndex.from_arrays(new_index)
 
-            # # no index
-            # tsframe.to_excel(path, 'test1', index=False)
-            # reader = ExcelFile(path)
-            # recons = reader.parse('test1', index_col=None)
-            # assert_almost_equal(recons.values, self.tsframe.values)
+        tsframe.to_excel(path, 'test1', index_label = ['time','foo'])
+        reader = ExcelFile(path)
+        recons = reader.parse('test1', index_col=[0,1], has_index_names=True)
+        assert_frame_equal(tsframe, recons)
 
-            self.tsframe.index = old_index # needed if setUP becomes classmethod
+        # infer index
+        tsframe.to_excel(path, 'test1')
+        reader = ExcelFile(path)
+        recons = reader.parse('test1')
+        assert_frame_equal(tsframe, recons)
 
-            # write a big DataFrame
-            df = DataFrame(np.random.randn(1005, 1))
-            df.to_excel(path, 'test1')
+        self.tsframe.index = old_index # needed if setUP becomes classmethod
 
-            os.remove(path)
+        os.remove(path)
 
     def test_to_excel_float_format(self):
         try:
@@ -4108,7 +4347,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
             raise nose.SkipTest
 
         for ext in ['xls', 'xlsx']:
-            filename = '__tmp__.' + ext
+            filename = '__tmp_to_excel_float_format__.' + ext
             df = DataFrame([[0.123456, 0.234567, 0.567567],
                             [12.32112, 123123.2, 321321.2]],
                            index=['A', 'B'], columns=['X', 'Y', 'Z'])
@@ -4215,7 +4454,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         except ImportError:
             raise nose.SkipTest
 
-        filename = '__tmp__.xls'
+        filename = '__tmp_to_excel_header_styling_xls__.xls'
         pdf.to_excel(filename, 'test1')
 
 
@@ -4271,7 +4510,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
             raise nose.SkipTest
 
         # test xlsx_styling
-        filename = '__tmp__.xlsx'
+        filename = '__tmp_to_excel_header_styling_xlsx__.xlsx'
         pdf.to_excel(filename, 'test1')
 
         wbk = openpyxl.load_workbook(filename)
@@ -4485,30 +4724,50 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
 
     #     self.assert_(self.frame.columns.name is None)
 
-    def test_corr(self):
+    def _check_method(self, method='pearson', check_minp=False):
+        if not check_minp:
+            correls = self.frame.corr(method=method)
+            exp = self.frame['A'].corr(self.frame['C'], method=method)
+            assert_almost_equal(correls['A']['C'], exp)
+        else:
+            result = self.frame.corr(min_periods=len(self.frame) - 8)
+            expected = self.frame.corr()
+            expected.ix['A', 'B'] = expected.ix['B', 'A'] = nan
+
+    def test_corr_pearson(self):
         _skip_if_no_scipy()
         self.frame['A'][:5] = nan
         self.frame['B'][5:10] = nan
 
-        def _check_method(method='pearson', check_minp=False):
-            if not check_minp:
-                correls = self.frame.corr(method=method)
-                exp = self.frame['A'].corr(self.frame['C'], method=method)
-                assert_almost_equal(correls['A']['C'], exp)
-            else:
-                result = self.frame.corr(min_periods=len(self.frame) - 8)
-                expected = self.frame.corr()
-                expected.ix['A', 'B'] = expected.ix['B', 'A'] = nan
+        self._check_method('pearson')
+
+    def test_corr_kendall(self):
+        _skip_if_no_scipy()
+        self.frame['A'][:5] = nan
+        self.frame['B'][5:10] = nan
+
+        self._check_method('kendall')
+
+    def test_corr_spearman(self):
+        _skip_if_no_scipy()
+        self.frame['A'][:5] = nan
+        self.frame['B'][5:10] = nan
+
+        self._check_method('spearman')
 
-        _check_method('pearson')
-        _check_method('kendall')
-        _check_method('spearman')
+    def test_corr_non_numeric(self):
+        _skip_if_no_scipy()
+        self.frame['A'][:5] = nan
+        self.frame['B'][5:10] = nan
 
         # exclude non-numeric types
         result = self.mixed_frame.corr()
         expected = self.mixed_frame.ix[:, ['A', 'B', 'C', 'D']].corr()
         assert_frame_equal(result, expected)
 
+    def test_corr_nooverlap(self):
+        _skip_if_no_scipy()
+
         # nothing in common
         for meth in ['pearson', 'kendall', 'spearman']:
             df = DataFrame({'A': [1, 1.5, 1, np.nan, np.nan, np.nan],
@@ -4519,6 +4778,9 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
             self.assert_(rs.ix['A', 'A'] == 1)
             self.assert_(rs.ix['B', 'B'] == 1)
 
+    def test_corr_constant(self):
+        _skip_if_no_scipy()
+
         # constant --> all NA
 
         for meth in ['pearson', 'spearman']:
@@ -4527,6 +4789,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
             rs = df.corr(meth)
             self.assert_(isnull(rs.values).all())
 
+    def test_corr_int(self):
         # dtypes other than float64 #1761
         df3 = DataFrame({"a":[1,2,3,4], "b":[1,2,3,4]})
 
@@ -5562,61 +5825,80 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         self.assertRaises(ValueError, self.frame.align, af.ix[0,:3],
                           join='inner', axis=2)
 
-    def test_align_fill_method(self):
-        def _check_align(a, b, axis, fill_axis, how, method, limit=None):
-            aa, ab = a.align(b, axis=axis, join=how, method=method, limit=limit,
-                             fill_axis=fill_axis)
-
-            join_index, join_columns = None, None
-
-            ea, eb = a, b
-            if axis is None or axis == 0:
-                join_index = a.index.join(b.index, how=how)
-                ea = ea.reindex(index=join_index)
-                eb = eb.reindex(index=join_index)
-
-            if axis is None or axis == 1:
-                join_columns  = a.columns.join(b.columns, how=how)
-                ea = ea.reindex(columns=join_columns)
-                eb = eb.reindex(columns=join_columns)
-
-            ea = ea.fillna(axis=fill_axis, method=method, limit=limit)
-            eb = eb.fillna(axis=fill_axis, method=method, limit=limit)
-
-            assert_frame_equal(aa, ea)
-            assert_frame_equal(ab, eb)
-
-        for kind in JOIN_TYPES:
-            for meth in ['pad', 'bfill']:
-                for ax in [0, 1, None]:
-                    for fax in [0, 1]:
-                        left = self.frame.ix[0:4, :10]
-                        right = self.frame.ix[2:, 6:]
-                        empty = self.frame.ix[:0, :0]
-
-                        _check_align(left, right, axis=ax, fill_axis=fax,
-                                     how=kind, method=meth)
-                        _check_align(left, right, axis=ax, fill_axis=fax,
-                                     how=kind, method=meth, limit=1)
-
-                        # empty left
-                        _check_align(empty, right, axis=ax, fill_axis=fax,
-                                     how=kind, method=meth)
-                        _check_align(empty, right, axis=ax, fill_axis=fax,
-                                     how=kind, method=meth, limit=1)
-
-
-                        # empty right
-                        _check_align(left, empty, axis=ax, fill_axis=fax,
-                                     how=kind, method=meth)
-                        _check_align(left, empty, axis=ax, fill_axis=fax,
-                                     how=kind, method=meth, limit=1)
-
-                        # both empty
-                        _check_align(empty, empty, axis=ax, fill_axis=fax,
-                                     how=kind, method=meth)
-                        _check_align(empty, empty, axis=ax, fill_axis=fax,
-                                     how=kind, method=meth, limit=1)
+    def _check_align(self, a, b, axis, fill_axis, how, method, limit=None):
+        aa, ab = a.align(b, axis=axis, join=how, method=method, limit=limit,
+                         fill_axis=fill_axis)
+
+        join_index, join_columns = None, None
+
+        ea, eb = a, b
+        if axis is None or axis == 0:
+            join_index = a.index.join(b.index, how=how)
+            ea = ea.reindex(index=join_index)
+            eb = eb.reindex(index=join_index)
+
+        if axis is None or axis == 1:
+            join_columns  = a.columns.join(b.columns, how=how)
+            ea = ea.reindex(columns=join_columns)
+            eb = eb.reindex(columns=join_columns)
+
+        ea = ea.fillna(axis=fill_axis, method=method, limit=limit)
+        eb = eb.fillna(axis=fill_axis, method=method, limit=limit)
+
+        assert_frame_equal(aa, ea)
+        assert_frame_equal(ab, eb)
+
+    def test_align_fill_method_inner(self):
+        for meth in ['pad', 'bfill']:
+            for ax in [0, 1, None]:
+                for fax in [0, 1]:
+                    self._check_align_fill('inner', meth, ax, fax)
+
+    def test_align_fill_method_outer(self):
+        for meth in ['pad', 'bfill']:
+            for ax in [0, 1, None]:
+                for fax in [0, 1]:
+                    self._check_align_fill('outer', meth, ax, fax)
+
+    def test_align_fill_method_left(self):
+        for meth in ['pad', 'bfill']:
+            for ax in [0, 1, None]:
+                for fax in [0, 1]:
+                    self._check_align_fill('left', meth, ax, fax)
+
+    def test_align_fill_method_right(self):
+        for meth in ['pad', 'bfill']:
+            for ax in [0, 1, None]:
+                for fax in [0, 1]:
+                    self._check_align_fill('right', meth, ax, fax)
+
+    def _check_align_fill(self, kind, meth, ax, fax):
+        left = self.frame.ix[0:4, :10]
+        right = self.frame.ix[2:, 6:]
+        empty = self.frame.ix[:0, :0]
+
+        self._check_align(left, right, axis=ax, fill_axis=fax,
+                          how=kind, method=meth)
+        self._check_align(left, right, axis=ax, fill_axis=fax,
+                          how=kind, method=meth, limit=1)
+
+        # empty left
+        self._check_align(empty, right, axis=ax, fill_axis=fax,
+                          how=kind, method=meth)
+        self._check_align(empty, right, axis=ax, fill_axis=fax,
+                          how=kind, method=meth, limit=1)
+
+        # empty right
+        self._check_align(left, empty, axis=ax, fill_axis=fax,
+                          how=kind, method=meth)
+        self._check_align(left, empty, axis=ax, fill_axis=fax,
+                          how=kind, method=meth, limit=1)
+
+        # both empty
+        self._check_align(empty, empty, axis=ax, fill_axis=fax,
+                          how=kind, method=meth)
+        self._check_align(empty, empty, axis=ax, fill_axis=fax,
+                          how=kind, method=meth, limit=1)
 
 
     def test_align_int_fill_bug(self):
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index 1a7e38b4f..5015d833a 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -43,6 +43,8 @@ def commonSetUp(self):
 
 class TestGroupBy(unittest.TestCase):
 
+    _multiprocess_can_split_ = True
+
     def setUp(self):
         self.ts = tm.makeTimeSeries()
 
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 8e65b9362..aece98445 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -25,7 +25,7 @@ import pandas as pd
 from pandas.lib import Timestamp
 
 class TestIndex(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         self.unicodeIndex = tm.makeUnicodeIndex(100)
         self.strIndex = tm.makeStringIndex(100)
@@ -509,7 +509,7 @@ class TestIndex(unittest.TestCase):
         self.assert_(not isinstance(res, Index))
 
 class TestInt64Index(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         self.index = Int64Index(np.arange(0, 20, 2))
 
@@ -872,7 +872,7 @@ class TestInt64Index(unittest.TestCase):
             str(idx)
 
 class TestMultiIndex(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         major_axis = Index(['foo', 'bar', 'baz', 'qux'])
         minor_axis = Index(['one', 'two'])
diff --git a/pandas/tests/test_internals.py b/pandas/tests/test_internals.py
index 31ffcc583..6078201d6 100644
--- a/pandas/tests/test_internals.py
+++ b/pandas/tests/test_internals.py
@@ -55,6 +55,8 @@ def get_dt_ex(cols=['h']):
 
 class TestBlock(unittest.TestCase):
 
+    _multiprocess_can_split_ = True
+
     def setUp(self):
         self.fblock = get_float_ex()
         self.cblock = get_complex_ex()
@@ -194,6 +196,8 @@ class TestBlock(unittest.TestCase):
 
 class TestBlockManager(unittest.TestCase):
 
+    _multiprocess_can_split_ = True
+
     def setUp(self):
         self.blocks = [get_float_ex(),
                        get_obj_ex(),
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 53b3c2ade..4a2717c2e 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -21,6 +21,8 @@ import pandas.index as _index
 
 class TestMultiLevel(unittest.TestCase):
 
+    _multiprocess_can_split_ = True
+
     def setUp(self):
         index = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux'],
                                    ['one', 'two', 'three']],
diff --git a/pandas/tests/test_ndframe.py b/pandas/tests/test_ndframe.py
index 70a5d79d2..c1fd16f5b 100644
--- a/pandas/tests/test_ndframe.py
+++ b/pandas/tests/test_ndframe.py
@@ -7,6 +7,8 @@ import pandas.util.testing as t
 
 class TestNDFrame(unittest.TestCase):
 
+    _multiprocess_can_split_ = True
+
     def setUp(self):
         tdf = t.makeTimeDataFrame()
         self.ndf = NDFrame(tdf._data)
@@ -27,4 +29,3 @@ if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)
-
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index 5cc3d4db5..c7a9ddd3e 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -36,7 +36,7 @@ class PanelTests(object):
         assert_frame_equal(cumsum['ItemA'], self.panel['ItemA'].cumsum())
 
 class SafeForLongAndSparse(object):
-
+    _multiprocess_can_split_ = True
     def test_repr(self):
         foo = repr(self.panel)
 
@@ -143,7 +143,7 @@ class SafeForLongAndSparse(object):
         self.assertRaises(Exception, f, axis=obj.ndim)
 
 class SafeForSparse(object):
-
+    _multiprocess_can_split_ = True
     @classmethod
     def assert_panel_equal(cls, x, y):
         assert_panel_equal(x, y)
@@ -346,7 +346,7 @@ class SafeForSparse(object):
 
 class CheckIndexing(object):
 
-
+    _multiprocess_can_split_ = True
     def test_getitem(self):
         self.assertRaises(Exception, self.panel.__getitem__, 'ItemQ')
 
@@ -662,7 +662,7 @@ class CheckIndexing(object):
 class TestPanel(unittest.TestCase, PanelTests, CheckIndexing,
                 SafeForLongAndSparse,
                 SafeForSparse):
-
+    _multiprocess_can_split_ = True
     @classmethod
     def assert_panel_equal(cls,x, y):
         assert_panel_equal(x, y)
@@ -1353,7 +1353,7 @@ class TestLongPanel(unittest.TestCase):
     """
     LongPanel no longer exists, but...
     """
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         panel = tm.makePanel()
         tm.add_nans(panel)
diff --git a/pandas/tests/test_reshape.py b/pandas/tests/test_reshape.py
index 3cb600ff6..ee6bf7bb0 100644
--- a/pandas/tests/test_reshape.py
+++ b/pandas/tests/test_reshape.py
@@ -17,6 +17,8 @@ import numpy as np
 from pandas.core.reshape import melt, convert_dummies, lreshape
 import pandas.util.testing as tm
 
+_multiprocess_can_split_ = True
+
 def test_melt():
     df = tm.makeTimeDataFrame()[:10]
     df['id1'] = (df['A'] > 0).astype(int)
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index df489e92e..f78a119d4 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -40,6 +40,8 @@ JOIN_TYPES = ['inner', 'outer', 'left', 'right']
 
 class CheckNameIntegration(object):
 
+    _multiprocess_can_split_ = True
+
     def test_scalarop_preserve_name(self):
         result = self.ts * 2
         self.assertEquals(result.name, self.ts.name)
@@ -150,13 +152,13 @@ class CheckNameIntegration(object):
         self.assert_(not "Name:" in repr(s))
 
     def test_pickle_preserve_name(self):
-        unpickled = self._pickle_roundtrip(self.ts)
+        unpickled = self._pickle_roundtrip_name(self.ts)
         self.assertEquals(unpickled.name, self.ts.name)
 
-    def _pickle_roundtrip(self, obj):
-        obj.save('__tmp__')
-        unpickled = Series.load('__tmp__')
-        os.remove('__tmp__')
+    def _pickle_roundtrip_name(self, obj):
+        obj.save('__tmp_name__')
+        unpickled = Series.load('__tmp_name__')
+        os.remove('__tmp_name__')
         return unpickled
 
     def test_argsort_preserve_name(self):
@@ -173,6 +175,8 @@ class CheckNameIntegration(object):
 
 class TestNanops(unittest.TestCase):
 
+    _multiprocess_can_split_ = True
+
     def test_comparisons(self):
         left = np.random.randn(10)
         right = np.random.randn(10)
@@ -220,6 +224,8 @@ class SafeForSparse(object):
 
 class TestSeries(unittest.TestCase, CheckNameIntegration):
 
+    _multiprocess_can_split_ = True
+
     def setUp(self):
         self.ts = tm.makeTimeSeries()
         self.ts.name = 'ts'
@@ -492,9 +498,9 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         assert_series_equal(unp_ts, self.ts)
 
     def _pickle_roundtrip(self, obj):
-        obj.save('__tmp__')
-        unpickled = Series.load('__tmp__')
-        os.remove('__tmp__')
+        obj.save('__tmp_pickle_roundtrip__')
+        unpickled = Series.load('__tmp_pickle_roundtrip__')
+        os.remove('__tmp_pickle_roundtrip__')
         return unpickled
 
     def test_getitem_get(self):
@@ -2128,28 +2134,29 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         assert_series_equal(iranks, exp)
 
     def test_from_csv(self):
-        self.ts.to_csv('_foo')
-        ts = Series.from_csv('_foo')
+        path = '_foo_from_csv'
+        self.ts.to_csv(path)
+        ts = Series.from_csv(path)
         assert_series_equal(self.ts, ts)
 
-        self.series.to_csv('_foo')
-        series = Series.from_csv('_foo')
+        self.series.to_csv(path)
+        series = Series.from_csv(path)
         self.assert_(series.name is None)
         self.assert_(series.index.name is None)
         assert_series_equal(self.series, series)
 
-        outfile = open('_foo', 'w')
+        outfile = open(path, 'w')
         outfile.write('1998-01-01|1.0\n1999-01-01|2.0')
         outfile.close()
-        series = Series.from_csv('_foo',sep='|')
+        series = Series.from_csv(path, sep='|')
         checkseries = Series({datetime(1998,1,1): 1.0, datetime(1999,1,1): 2.0})
         assert_series_equal(checkseries, series)
 
-        series = Series.from_csv('_foo',sep='|',parse_dates=False)
+        series = Series.from_csv(path, sep='|',parse_dates=False)
         checkseries = Series({'1998-01-01': 1.0, '1999-01-01': 2.0})
         assert_series_equal(checkseries, series)
 
-        os.remove('_foo')
+        os.remove(path)
 
     def test_to_csv(self):
         self.ts.to_csv('_foo')
@@ -3220,6 +3227,8 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
 
 class TestSeriesNonUnique(unittest.TestCase):
 
+    _multiprocess_can_split_ = True
+
     def setUp(self):
         pass
 
diff --git a/pandas/tests/test_stats.py b/pandas/tests/test_stats.py
index 9d6f12288..ba37355af 100644
--- a/pandas/tests/test_stats.py
+++ b/pandas/tests/test_stats.py
@@ -12,7 +12,7 @@ from pandas.util.testing import (assert_frame_equal,
                                  assert_almost_equal)
 
 class TestRank(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     s = Series([1, 3, 4, 2, nan, 2, 1, 5, nan, 3])
     df = DataFrame({'A': s, 'B': s})
 
@@ -115,4 +115,3 @@ class TestRank(unittest.TestCase):
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)
-
diff --git a/pandas/tests/test_strings.py b/pandas/tests/test_strings.py
index 9972d0b3b..beebb22c1 100644
--- a/pandas/tests/test_strings.py
+++ b/pandas/tests/test_strings.py
@@ -22,6 +22,8 @@ import pandas.core.strings as strings
 
 class TestStringMethods(unittest.TestCase):
 
+    _multiprocess_can_split_ = True
+
     def test_cat(self):
         one = ['a', 'a', 'b', 'b', 'c', NA]
         two = ['a', NA, 'b', 'd', 'foo', NA]
diff --git a/pandas/tests/test_tseries.py b/pandas/tests/test_tseries.py
index 69941e9f6..aecb1ca22 100644
--- a/pandas/tests/test_tseries.py
+++ b/pandas/tests/test_tseries.py
@@ -10,7 +10,7 @@ import pandas.algos as algos
 from datetime import datetime
 
 class TestTseriesUtil(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def test_combineFunc(self):
         pass
 
@@ -387,7 +387,7 @@ def test_series_bin_grouper():
     assert_almost_equal(counts, exp_counts)
 
 class TestBinGroupers(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         self.obj = np.random.randn(10, 1)
         self.labels = np.array([0, 0, 0, 1, 1, 1, 2, 2, 2, 2], dtype=np.int64)
@@ -511,7 +511,7 @@ def test_try_parse_dates():
 
 
 class TestTypeInference(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def test_length_zero(self):
         result = lib.infer_dtype(np.array([], dtype='i4'))
         self.assertEqual(result, 'empty')
@@ -636,4 +636,3 @@ if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)
-
diff --git a/pandas/tseries/tests/test_offsets.py b/pandas/tseries/tests/test_offsets.py
index 6506e7ab4..7a368a261 100644
--- a/pandas/tseries/tests/test_offsets.py
+++ b/pandas/tseries/tests/test_offsets.py
@@ -21,6 +21,8 @@ from nose.tools import assert_raises
 from pandas.tslib import monthrange
 from pandas.lib import Timestamp
 
+_multiprocess_can_split_ = True
+
 def test_monthrange():
     import calendar
     for y in range(2000,2013):
@@ -72,7 +74,7 @@ def test_to_m8():
 #####
 
 class TestDateOffset(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         self.d = Timestamp(datetime(2008, 1, 2))
 
@@ -110,7 +112,7 @@ class TestDateOffset(unittest.TestCase):
         self.assert_(not (offset1 == offset2))
 
 class TestBusinessDay(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         self.d = datetime(2008, 1, 1)
 
@@ -1474,4 +1476,3 @@ if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)
-
diff --git a/pandas/tseries/tests/test_resample.py b/pandas/tseries/tests/test_resample.py
index 1512bfc91..5e9541791 100644
--- a/pandas/tseries/tests/test_resample.py
+++ b/pandas/tseries/tests/test_resample.py
@@ -30,7 +30,7 @@ def _skip_if_no_pytz():
 
 
 class TestResample(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         dti = DatetimeIndex(start=datetime(2005,1,1),
                             end=datetime(2005,1,10), freq='Min')
@@ -587,7 +587,7 @@ from pandas.util.compat import product
 
 
 class TestResamplePeriodIndex(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def test_basic_downsample(self):
         ts = _simple_pts('1/1/1990', '6/30/1995', freq='M')
         result = ts.resample('a-dec')
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 140b01604..75f9b8aec 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -42,7 +42,7 @@ from numpy.testing.decorators import slow
 
 
 class TestTimeSeriesDuplicates(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         dates = [datetime(2000, 1, 2), datetime(2000, 1, 2),
                  datetime(2000, 1, 2), datetime(2000, 1, 3),
@@ -164,7 +164,7 @@ def _skip_if_no_pytz():
 
 
 class TestTimeSeries(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def test_dti_slicing(self):
         dti = DatetimeIndex(start='1/1/2005', end='12/1/2005', freq='M')
         dti2 = dti[[1,3,5]]
@@ -1372,7 +1372,7 @@ def _simple_ts(start, end, freq='D'):
 
 
 class TestDatetimeIndex(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def test_append_join_nondatetimeindex(self):
         rng = date_range('1/1/2000', periods=10)
         idx = Index(['a', 'b', 'c', 'd'])
@@ -1618,7 +1618,7 @@ class TestDatetimeIndex(unittest.TestCase):
         i2.union(i1) # Fails with "AttributeError: can't set attribute"
 
 class TestLegacySupport(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     @classmethod
     def setUpClass(cls):
         if py3compat.PY3:
diff --git a/pandas/tseries/tests/test_timezones.py b/pandas/tseries/tests/test_timezones.py
index 29fd76d39..85f9d2b48 100644
--- a/pandas/tseries/tests/test_timezones.py
+++ b/pandas/tseries/tests/test_timezones.py
@@ -62,7 +62,7 @@ class FixedOffset(tzinfo):
 fixed_off = FixedOffset(-420, '-07:00')
 
 class TestTimeZoneSupport(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         _skip_if_no_pytz()
 
@@ -540,7 +540,7 @@ class TestTimeZoneSupport(unittest.TestCase):
         self.assertEquals(series.index.tz, tzinfo)
 
 class TestTimeZones(unittest.TestCase):
-
+    _multiprocess_can_split_ = True
     def setUp(self):
         _skip_if_no_pytz()
 
diff --git a/test_fast.sh b/test_fast.sh
index 830443dcd..1dc164429 100755
--- a/test_fast.sh
+++ b/test_fast.sh
@@ -1 +1 @@
-nosetests -A "not slow" pandas $*
\ No newline at end of file
+nosetests -A "not slow" pandas $*

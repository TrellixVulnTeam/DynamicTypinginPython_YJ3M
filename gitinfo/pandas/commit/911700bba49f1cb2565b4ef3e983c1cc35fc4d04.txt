commit 911700bba49f1cb2565b4ef3e983c1cc35fc4d04
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Sep 10 18:59:07 2011 -0400

    TST: Panel.join unit tests and misc panel test coverage

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 964ab68d1..a8e3d1d9c 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1407,36 +1407,6 @@ class DataFrame(NDFrame):
         self._data = self._data.rename_items(mapper)
         self._series_cache.clear()
 
-    def add_prefix(self, prefix):
-        """
-        Concatenate prefix string with panel items names.
-
-        Parameters
-        ----------
-        prefix : string
-
-        Returns
-        -------
-        LongPanel
-        """
-        new_data = self._data.add_prefix(prefix)
-        return self._constructor(new_data)
-
-    def add_suffix(self, suffix):
-        """
-        Concatenate suffix string with panel items names
-
-        Parameters
-        ----------
-        suffix : string
-
-        Returns
-        -------
-        with_suffix : DataFrame
-        """
-        new_data = self._data.add_suffix(suffix)
-        return self._constructor(new_data)
-
     #----------------------------------------------------------------------
     # Arithmetic / combination related
 
@@ -2115,22 +2085,18 @@ class DataFrame(NDFrame):
         if len(other.index) == 0:
             return self
 
-        if on not in self:
-            raise Exception('%s column not contained in this frame!' % on)
-
-        this, other = self._maybe_rename_join(other, lsuffix, rsuffix)
-        new_data = this._data.join_on(other._data, this[on], axis=1)
-        return this._constructor(new_data)
+        new_data = self._data.join_on(other._data, self[on], axis=1,
+                                      lsuffix=lsuffix, rsuffix=rsuffix)
+        return self._constructor(new_data)
 
     def _join_index(self, other, how, lsuffix, rsuffix):
         join_index = self._get_join_index(other, how)
 
         this = self.reindex(join_index)
         other = other.reindex(join_index)
-        this, other = this._maybe_rename_join(other, lsuffix, rsuffix)
 
         # merge blocks
-        merged_data = this._data.merge(other._data)
+        merged_data = this._data.merge(other._data, lsuffix, rsuffix)
         return self._constructor(merged_data)
 
     def _get_join_index(self, other, how):
@@ -2147,30 +2113,6 @@ class DataFrame(NDFrame):
 
         return join_index
 
-    def _maybe_rename_join(self, other, lsuffix, rsuffix):
-        intersection = self.columns.intersection(other.columns)
-
-        if len(intersection) > 0:
-            if not lsuffix and not rsuffix:
-                raise Exception('columns overlap: %s' % intersection)
-
-            def lrenamer(x):
-                if x in intersection:
-                    return '%s%s' % (x, lsuffix)
-                return x
-
-            def rrenamer(x):
-                if x in intersection:
-                    return '%s%s' % (x, rsuffix)
-                return x
-
-            this = self.rename(columns=lrenamer)
-            other = other.rename(columns=rrenamer)
-        else:
-            this = self
-
-        return this, other
-
     #----------------------------------------------------------------------
     # Statistical methods, etc.
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index f40b1b973..74eb9449e 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -414,3 +414,33 @@ class NDFrame(PandasObject):
         labels = result._data.axes[axis]
         result._data.set_axis(axis, labels.swaplevel(i, j))
         return result
+
+    def add_prefix(self, prefix):
+        """
+        Concatenate prefix string with panel items names.
+
+        Parameters
+        ----------
+        prefix : string
+
+        Returns
+        -------
+        with_prefix : type of caller
+        """
+        new_data = self._data.add_prefix(prefix)
+        return self._constructor(new_data)
+
+    def add_suffix(self, suffix):
+        """
+        Concatenate suffix string with panel items names
+
+        Parameters
+        ----------
+        suffix : string
+
+        Returns
+        -------
+        with_suffix : type of caller
+        """
+        new_data = self._data.add_suffix(suffix)
+        return self._constructor(new_data)
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index aa4b5b8df..158409400 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -605,23 +605,43 @@ class BlockManager(object):
 
         return BlockManager(new_blocks, new_axes)
 
-    def merge(self, other):
+    def merge(self, other, lsuffix=None, rsuffix=None):
         assert(self._is_indexed_like(other))
 
-        intersection = self.items.intersection(other.items)
-        try:
-            assert(len(intersection) == 0)
-        except AssertionError:
-            raise Exception('items overlap: %s' % intersection)
+        this, other = self._maybe_rename_join(other, lsuffix, rsuffix)
 
-        cons_items = self.items + other.items
-        consolidated = _consolidate(self.blocks + other.blocks, cons_items)
+        cons_items = this.items + other.items
+        consolidated = _consolidate(this.blocks + other.blocks, cons_items)
 
-        new_axes = list(self.axes)
+        new_axes = list(this.axes)
         new_axes[0] = cons_items
 
         return BlockManager(consolidated, new_axes)
 
+    def _maybe_rename_join(self, other, lsuffix, rsuffix):
+        intersection = self.items.intersection(other.items)
+
+        if len(intersection) > 0:
+            if not lsuffix and not rsuffix:
+                raise Exception('columns overlap: %s' % intersection)
+
+            def lrenamer(x):
+                if x in intersection:
+                    return '%s%s' % (x, lsuffix)
+                return x
+
+            def rrenamer(x):
+                if x in intersection:
+                    return '%s%s' % (x, rsuffix)
+                return x
+
+            this = self.rename_items(lrenamer)
+            other = other.rename_items(rrenamer)
+        else:
+            this = self
+
+        return this, other
+
     def _is_indexed_like(self, other):
         """
         Check all axes except items
@@ -632,7 +652,9 @@ class BlockManager(object):
                 return False
         return True
 
-    def join_on(self, other, on, axis=1):
+    def join_on(self, other, on, axis=1, lsuffix=None, rsuffix=None):
+        this, other = self._maybe_rename_join(other, lsuffix, rsuffix)
+
         other_axis = other.axes[axis]
         indexer, mask = _tseries.getMergeVec(on.astype(object),
                                              other_axis.indexMap)
@@ -642,13 +664,14 @@ class BlockManager(object):
         needs_masking = len(on) > 0 and notmask.any()
         other_blocks = []
         for block in other.blocks:
-            newb = block.reindex_axis(indexer, notmask, needs_masking, axis=axis)
+            newb = block.reindex_axis(indexer, notmask, needs_masking,
+                                      axis=axis)
             other_blocks.append(newb)
 
-        cons_items = self.items + other.items
-        consolidated = _consolidate(self.blocks + other_blocks, cons_items)
+        cons_items = this.items + other.items
+        consolidated = _consolidate(this.blocks + other_blocks, cons_items)
 
-        new_axes = list(self.axes)
+        new_axes = list(this.axes)
         new_axes[0] = cons_items
         return BlockManager(consolidated, new_axes)
 
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 6c751573d..8f9218b05 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -624,7 +624,7 @@ class Panel(NDFrame):
         """
         return self.xs(key, axis=2, copy=copy)
 
-    def xs(self, key, axis=1, copy=False):
+    def xs(self, key, axis=1, copy=True):
         """
         Return slice of panel along selected axis
 
@@ -632,7 +632,7 @@ class Panel(NDFrame):
         ----------
         key : object
             Label
-        axis : {'items', 'major', 'minor}
+        axis : {'items', 'major', 'minor}, default 1/'major'
 
         Returns
         -------
@@ -984,33 +984,15 @@ class Panel(NDFrame):
         -------
         joined : Panel
         """
-        #if on is not None:
-        #    if how is not None:
-        #        raise Exception('how parameter is not valid when '
-        #                        'on specified')
-        #    return self._join_on(other, on, lsuffix, rsuffix)
-        #else:
         if how is None:
-             how = 'left'
+            how = 'left'
         return self._join_index(other, how, lsuffix, rsuffix)
 
-    #NOTE: I don't think is setup for multi-indices?
-    #def _join_on(self, other, on, lsuffix, rsuffix):
-    #    if len(other.major_axis) == 0 and len(other.minor_axis) == 0:
-    #        return self
-
-    #    if on not in self:
-    #        raise Exception("%s column not contained in this panel" % s)
-
-    #    this, other = self._maybe_rename_join(other, lsuffix, rsuffix)
-    #    new_data = this._data.join_on(other._data, this[on], axis=0)
-
     def _join_index(self, other, how, lsuffix, rsuffix):
         join_major, join_minor = self._get_join_index(other, how)
         this = self.reindex(major=join_major, minor=join_minor)
         other = other.reindex(major=join_major, minor=join_minor)
-        #this, other = this._maybe_rename_join(other, lsuffix, rsuffix)
-        merged_data = this._data.merge(other._data)
+        merged_data = this._data.merge(other._data, lsuffix, rsuffix)
         return self._constructor(merged_data)
 
     def _get_join_index(self, other, how):
@@ -1026,31 +1008,6 @@ class Panel(NDFrame):
             join_minor = self.minor_axis.union(other.minor_axis)
         return join_major, join_minor
 
-    def _maybe_rename_join(self, other, lsuffix, rsuffix):
-        intersection = self.items.intersection(other.items)
-
-        if len(intersection) > 0:
-            if not lsuffix and not rsuffix:
-                raise Exception('items overlap: %s' % intersection)
-
-            def lrenamer(x):
-                if x in intersection:
-                    return '%s%s' % (x, lsuffix)
-                return x
-
-            def rrenamer(x):
-                if x in intersection:
-                    return '%s%s' % (x, rsuffix)
-                return x
-
-            #TODO: is this good enough?
-            self.items = Index(lrenamer)
-            other.items = Index(rrenamer)
-        else:
-            this = self
-
-        return this, other
-
     #----------------------------------------------------------------------
     # Deprecated stuff
 
@@ -1147,15 +1104,15 @@ class LongPanel(DataFrame):
         return self.index.labels[1]
 
     def _combine(self, other, func, axis='items'):
-        if isinstance(other, Panel):
-            return self._combine_panel(other, func)
-        elif isinstance(other, LongPanel):
+        if isinstance(other, LongPanel):
             return self._combine_frame(other, func)
         elif isinstance(other, DataFrame):
             return self._combine_panel_frame(other, func, axis=axis)
         elif np.isscalar(other):
             return LongPanel(func(self.values, other), columns=self.items,
                              index=self.index)
+        else:  # pragma: no cover
+            raise Exception('type %s not supported' % type(other))
 
     def _combine_panel_frame(self, other, func, axis='items'):
         """
@@ -1175,22 +1132,6 @@ class LongPanel(DataFrame):
         result = wide._combine_frame(other, func, axis=axis)
         return result.to_long()
 
-    def _combine_panel(self, other, func):
-        """
-        Arithmetic operation between panels
-        """
-        if self.index is not other.index:
-            raise ValueError("Can only combine identically-indexed "
-                            "panels for now")
-
-        if len(other.items) == 1:
-            new_values = func(self.values, other.values)
-        else:
-            new_values = func(self.values, other.values)
-
-        return LongPanel(new_values, columns=self.items,
-                         index=self.index)
-
     add = _panel_arith_method(operator.add, 'add')
     subtract = _panel_arith_method(operator.sub, 'subtract')
     divide = _panel_arith_method(operator.div, 'divide')
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index fe89634f0..1f63ada70 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -1074,6 +1074,30 @@ class SparseDataFrame(DataFrame):
 
         return self._constructor(result_series, index=join_index)
 
+    def _maybe_rename_join(self, other, lsuffix, rsuffix):
+        intersection = self.columns.intersection(other.columns)
+
+        if len(intersection) > 0:
+            if not lsuffix and not rsuffix:
+                raise Exception('columns overlap: %s' % intersection)
+
+            def lrenamer(x):
+                if x in intersection:
+                    return '%s%s' % (x, lsuffix)
+                return x
+
+            def rrenamer(x):
+                if x in intersection:
+                    return '%s%s' % (x, rsuffix)
+                return x
+
+            this = self.rename(columns=lrenamer)
+            other = other.rename(columns=rrenamer)
+        else:
+            this = self
+
+        return this, other
+
     def transpose(self):
         """
         Returns a DataFrame with the rows/columns switched.
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index c03760498..31421aacc 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -399,6 +399,20 @@ class CheckIndexing(object):
         self.assert_(xs['ItemA'].dtype == np.float64)
         self.assert_(xs['ItemD'].dtype == np.object_)
 
+    def test_xs(self):
+        itemA = self.panel.xs('ItemA', axis=0)
+        expected = self.panel['ItemA']
+        assert_frame_equal(itemA, expected)
+
+        # not view by default
+        itemA.values[:] = np.nan
+        self.assert_(not np.isnan(self.panel['ItemA'].values).all())
+
+        # but can get view
+        itemA_view = self.panel.xs('ItemA', axis=0, copy=False)
+        itemA_view.values[:] = np.nan
+        self.assert_(np.isnan(self.panel['ItemA'].values).all())
+
     def test_getitem_fancy_labels(self):
         p = self.panel
 
@@ -758,6 +772,48 @@ class TestPanel(unittest.TestCase, PanelTests, CheckIndexing,
 
         self.assertRaises(Exception, self.panel.shift, 1, axis='items')
 
+    def test_join(self):
+        p1 = self.panel.ix[:2, :10, :3]
+        p2 = self.panel.ix[2:, 5:, 2:]
+
+        # left join
+        result = p1.join(p2)
+        expected = p1.copy()
+        expected['ItemC'] = p2['ItemC']
+        assert_panel_equal(result, expected)
+
+        # right join
+        result = p1.join(p2, how='right')
+        expected = p2.copy()
+        expected['ItemA'] = p1['ItemA']
+        expected['ItemB'] = p1['ItemB']
+        expected = expected.reindex(items=['ItemA', 'ItemB', 'ItemC'])
+        assert_panel_equal(result, expected)
+
+        # inner join
+        result = p1.join(p2, how='inner')
+        expected = self.panel.ix[:, 5:10, 2:3]
+        assert_panel_equal(result, expected)
+
+        # outer join
+        result = p1.join(p2, how='outer')
+        expected = p1.reindex(major=self.panel.major_axis,
+                              minor=self.panel.minor_axis)
+        expected = expected.join(p2.reindex(major=self.panel.major_axis,
+                                            minor=self.panel.minor_axis))
+        assert_panel_equal(result, expected)
+
+    def test_join_overlap(self):
+        p1 = self.panel.ix[['ItemA', 'ItemB', 'ItemC']]
+        p2 = self.panel.ix[['ItemB', 'ItemC']]
+
+        joined = p1.join(p2, lsuffix='_p1', rsuffix='_p2')
+        p1_suf = p1.ix[['ItemB', 'ItemC']].add_suffix('_p1')
+        p2_suf = p2.ix[['ItemB', 'ItemC']].add_suffix('_p2')
+        no_overlap = self.panel.ix[['ItemA']]
+        expected = p1_suf.join(p2_suf).join(no_overlap)
+        assert_panel_equal(joined, expected)
+
 class TestLongPanel(unittest.TestCase):
 
     def setUp(self):
@@ -883,6 +939,11 @@ class TestLongPanel(unittest.TestCase):
         # one item
         result = self.panel.add(self.panel.filter(['ItemA']))
 
+    def test_combine_scalar(self):
+        result = self.panel.mul(2)
+        expected = DataFrame(self.panel._data) * 2
+        assert_frame_equal(result, expected)
+
     def test_operators(self):
         wp = self.panel.to_wide()
         result = (self.panel + 1).to_wide()

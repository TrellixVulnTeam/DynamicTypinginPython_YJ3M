commit 1543761e1a573284000a4ac6b517c60019608ce0
Author: topper-123 <terji78@gmail.com>
Date:   Wed Nov 22 00:07:05 2017 +0000

    CLN: remove tseries.util.pivot_annual/isleapyear (#18370)

diff --git a/doc/source/whatsnew/v0.22.0.txt b/doc/source/whatsnew/v0.22.0.txt
index c27a68498..54cc59917 100644
--- a/doc/source/whatsnew/v0.22.0.txt
+++ b/doc/source/whatsnew/v0.22.0.txt
@@ -76,7 +76,8 @@ Removal of prior version deprecations/changes
 
 - Warnings against the obsolete usage ``Categorical(codes, categories)``, which were emitted for instance when the first two arguments to ``Categorical()`` had different dtypes, and recommended the use of ``Categorical.from_codes``, have now been removed (:issue:`8074`)
 - The ``levels`` and ``labels`` attributes of a ``MultiIndex`` can no longer be set directly (:issue:`4039`).
--
+- ``pd.tseries.util.pivot_annual`` has been  removed (deprecated since v0.19). Use ``pivot_table`` instead (:issue:`18370`)
+- ``pd.tseries.util.isleapyear`` has been removed (deprecated since v0.19). Use ``.is_leap_year`` property in Datetime-likes instead (:issue:`18370`)
 
 .. _whatsnew_0220.performance:
 
diff --git a/pandas/tests/reshape/test_pivot.py b/pandas/tests/reshape/test_pivot.py
index e3951634b..857116c8f 100644
--- a/pandas/tests/reshape/test_pivot.py
+++ b/pandas/tests/reshape/test_pivot.py
@@ -13,7 +13,6 @@ from pandas import (DataFrame, Series, Index, MultiIndex,
 from pandas.core.reshape.pivot import pivot_table, crosstab
 from pandas.compat import range, product
 import pandas.util.testing as tm
-from pandas.tseries.util import pivot_annual, isleapyear
 from pandas.api.types import CategoricalDtype as CDT
 
 
@@ -891,6 +890,40 @@ class TestPivotTable(object):
                              index=['X', 'Y'], columns=exp_col)
         tm.assert_frame_equal(result, expected)
 
+    def test_daily(self):
+        rng = date_range('1/1/2000', '12/31/2004', freq='D')
+        ts = Series(np.random.randn(len(rng)), index=rng)
+
+        annual = pivot_table(DataFrame(ts), index=ts.index.year,
+                             columns=ts.index.dayofyear)
+        annual.columns = annual.columns.droplevel(0)
+
+        doy = np.asarray(ts.index.dayofyear)
+
+        for i in range(1, 367):
+            subset = ts[doy == i]
+            subset.index = subset.index.year
+
+            result = annual[i].dropna()
+            tm.assert_series_equal(result, subset, check_names=False)
+            assert result.name == i
+
+    def test_monthly(self):
+        rng = date_range('1/1/2000', '12/31/2004', freq='M')
+        ts = Series(np.random.randn(len(rng)), index=rng)
+
+        annual = pivot_table(pd.DataFrame(ts), index=ts.index.year,
+                             columns=ts.index.month)
+        annual.columns = annual.columns.droplevel(0)
+
+        month = ts.index.month
+        for i in range(1, 13):
+            subset = ts[month == i]
+            subset.index = subset.index.year
+            result = annual[i].dropna()
+            tm.assert_series_equal(result, subset, check_names=False)
+            assert result.name == i
+
     def test_pivot_table_with_iterator_values(self):
         # GH 12017
         aggs = {'D': 'sum', 'E': 'mean'}
@@ -1048,6 +1081,16 @@ class TestPivotTable(object):
 
         tm.assert_frame_equal(result, expected)
 
+    def test_pivot_margins_name_unicode(self):
+        # issue #13292
+        greek = u'\u0394\u03bf\u03ba\u03b9\u03bc\u03ae'
+        frame = pd.DataFrame({'foo': [1, 2, 3]})
+        table = pd.pivot_table(frame, index=['foo'], aggfunc=len, margins=True,
+                               margins_name=greek)
+        index = pd.Index([1, 2, 3, greek], dtype='object', name='foo')
+        expected = pd.DataFrame(index=index)
+        tm.assert_frame_equal(table, expected)
+
 
 class TestCrosstab(object):
 
@@ -1525,116 +1568,3 @@ class TestCrosstab(object):
                                 index=expected_index,
                                 columns=expected_index)
         tm.assert_frame_equal(result, expected)
-
-
-class TestPivotAnnual(object):
-    """
-    New pandas of scikits.timeseries pivot_annual
-    """
-
-    def test_daily(self):
-        rng = date_range('1/1/2000', '12/31/2004', freq='D')
-        ts = Series(np.random.randn(len(rng)), index=rng)
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            annual = pivot_annual(ts, 'D')
-
-        doy = np.asarray(ts.index.dayofyear)
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            doy[(~isleapyear(ts.index.year)) & (doy >= 60)] += 1
-
-        for i in range(1, 367):
-            subset = ts[doy == i]
-            subset.index = [x.year for x in subset.index]
-
-            result = annual[i].dropna()
-            tm.assert_series_equal(result, subset, check_names=False)
-            assert result.name == i
-
-        # check leap days
-        leaps = ts[(ts.index.month == 2) & (ts.index.day == 29)]
-        day = leaps.index.dayofyear[0]
-        leaps.index = leaps.index.year
-        leaps.name = 60
-        tm.assert_series_equal(annual[day].dropna(), leaps)
-
-    def test_hourly(self):
-        rng_hourly = date_range('1/1/1994', periods=(18 * 8760 + 4 * 24),
-                                freq='H')
-        data_hourly = np.random.randint(100, 350, rng_hourly.size)
-        ts_hourly = Series(data_hourly, index=rng_hourly)
-
-        grouped = ts_hourly.groupby(ts_hourly.index.year)
-        hoy = grouped.apply(lambda x: x.reset_index(drop=True))
-        hoy = hoy.index.droplevel(0).values
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            hoy[~isleapyear(ts_hourly.index.year) & (hoy >= 1416)] += 24
-        hoy += 1
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            annual = pivot_annual(ts_hourly)
-
-        ts_hourly = ts_hourly.astype(float)
-        for i in [1, 1416, 1417, 1418, 1439, 1440, 1441, 8784]:
-            subset = ts_hourly[hoy == i]
-            subset.index = [x.year for x in subset.index]
-
-            result = annual[i].dropna()
-            tm.assert_series_equal(result, subset, check_names=False)
-            assert result.name == i
-
-        leaps = ts_hourly[(ts_hourly.index.month == 2) & (
-            ts_hourly.index.day == 29) & (ts_hourly.index.hour == 0)]
-        hour = leaps.index.dayofyear[0] * 24 - 23
-        leaps.index = leaps.index.year
-        leaps.name = 1417
-        tm.assert_series_equal(annual[hour].dropna(), leaps)
-
-    def test_weekly(self):
-        pass
-
-    def test_monthly(self):
-        rng = date_range('1/1/2000', '12/31/2004', freq='M')
-        ts = Series(np.random.randn(len(rng)), index=rng)
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            annual = pivot_annual(ts, 'M')
-
-        month = ts.index.month
-        for i in range(1, 13):
-            subset = ts[month == i]
-            subset.index = [x.year for x in subset.index]
-            result = annual[i].dropna()
-            tm.assert_series_equal(result, subset, check_names=False)
-            assert result.name == i
-
-    def test_period_monthly(self):
-        pass
-
-    def test_period_daily(self):
-        pass
-
-    def test_period_weekly(self):
-        pass
-
-    def test_isleapyear_deprecate(self):
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            assert isleapyear(2000)
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            assert not isleapyear(2001)
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            assert isleapyear(2004)
-
-    def test_pivot_margins_name_unicode(self):
-        # issue #13292
-        greek = u'\u0394\u03bf\u03ba\u03b9\u03bc\u03ae'
-        frame = pd.DataFrame({'foo': [1, 2, 3]})
-        table = pd.pivot_table(frame, index=['foo'], aggfunc=len, margins=True,
-                               margins_name=greek)
-        index = pd.Index([1, 2, 3, greek], dtype='object', name='foo')
-        expected = pd.DataFrame(index=index)
-        tm.assert_frame_equal(table, expected)
diff --git a/pandas/tseries/util.py b/pandas/tseries/util.py
deleted file mode 100644
index dc8a41215..000000000
--- a/pandas/tseries/util.py
+++ /dev/null
@@ -1,104 +0,0 @@
-import warnings
-
-from pandas.compat import lrange
-import numpy as np
-from pandas.core.dtypes.common import _ensure_platform_int
-from pandas.core.frame import DataFrame
-import pandas.core.algorithms as algorithms
-
-
-def pivot_annual(series, freq=None):
-    """
-    Deprecated. Use ``pivot_table`` instead.
-
-    Group a series by years, taking leap years into account.
-
-    The output has as many rows as distinct years in the original series,
-    and as many columns as the length of a leap year in the units corresponding
-    to the original frequency (366 for daily frequency, 366*24 for hourly...).
-    The first column of the output corresponds to Jan. 1st, 00:00:00,
-    while the last column corresponds to Dec, 31st, 23:59:59.
-    Entries corresponding to Feb. 29th are masked for non-leap years.
-
-    For example, if the initial series has a daily frequency, the 59th column
-    of the output always corresponds to Feb. 28th, the 61st column to Mar. 1st,
-    and the 60th column is masked for non-leap years.
-    With a hourly initial frequency, the (59*24)th column of the output always
-    correspond to Feb. 28th 23:00, the (61*24)th column to Mar. 1st, 00:00, and
-    the 24 columns between (59*24) and (61*24) are masked.
-
-    If the original frequency is less than daily, the output is equivalent to
-    ``series.convert('A', func=None)``.
-
-    Parameters
-    ----------
-    series : Series
-    freq : string or None, default None
-
-    Returns
-    -------
-    annual : DataFrame
-    """
-
-    msg = "pivot_annual is deprecated. Use pivot_table instead"
-    warnings.warn(msg, FutureWarning)
-
-    index = series.index
-    year = index.year
-    years = algorithms.unique1d(year)
-
-    if freq is not None:
-        freq = freq.upper()
-    else:
-        freq = series.index.freq
-
-    if freq == 'D':
-        width = 366
-        offset = np.asarray(index.dayofyear) - 1
-
-        # adjust for leap year
-        offset[(~isleapyear(year)) & (offset >= 59)] += 1
-
-        columns = lrange(1, 367)
-        # todo: strings like 1/1, 1/25, etc.?
-    elif freq in ('M', 'BM'):
-        width = 12
-        offset = np.asarray(index.month) - 1
-        columns = lrange(1, 13)
-    elif freq == 'H':
-        width = 8784
-        grouped = series.groupby(series.index.year)
-        defaulted = grouped.apply(lambda x: x.reset_index(drop=True))
-        defaulted.index = defaulted.index.droplevel(0)
-        offset = np.asarray(defaulted.index)
-        offset[~isleapyear(year) & (offset >= 1416)] += 24
-        columns = lrange(1, 8785)
-    else:
-        raise NotImplementedError(freq)
-
-    flat_index = (year - years.min()) * width + offset
-    flat_index = _ensure_platform_int(flat_index)
-
-    values = np.empty((len(years), width))
-    values.fill(np.nan)
-    values.put(flat_index, series.values)
-
-    return DataFrame(values, index=years, columns=columns)
-
-
-def isleapyear(year):
-    """
-    Returns true if year is a leap year.
-
-    Parameters
-    ----------
-    year : integer / sequence
-        A given (list of) year(s).
-    """
-
-    msg = "isleapyear is deprecated. Use .is_leap_year property instead"
-    warnings.warn(msg, FutureWarning)
-
-    year = np.asarray(year)
-    return np.logical_or(year % 400 == 0,
-                         np.logical_and(year % 4 == 0, year % 100 > 0))

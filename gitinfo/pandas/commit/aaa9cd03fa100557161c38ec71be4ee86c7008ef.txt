commit aaa9cd03fa100557161c38ec71be4ee86c7008ef
Author: Lucca Delchiaro Costabile <luccadelchiaro@gmail.com>
Date:   Fri Jun 19 19:33:20 2020 -0300

    GH34529 (#34812)

diff --git a/doc/source/whatsnew/v1.1.0.rst b/doc/source/whatsnew/v1.1.0.rst
index a27e6e843..f6ad3a800 100644
--- a/doc/source/whatsnew/v1.1.0.rst
+++ b/doc/source/whatsnew/v1.1.0.rst
@@ -1058,6 +1058,7 @@ Reshaping
 - Bug in :func:`Dataframe.aggregate` and :func:`Series.aggregate` was causing recursive loop in some cases (:issue:`34224`)
 - Fixed bug in :func:`melt` where melting MultiIndex columns with ``col_level`` > 0 would raise a ``KeyError`` on ``id_vars`` (:issue:`34129`)
 - Bug in :meth:`Series.where` with an empty Series and empty ``cond`` having non-bool dtype (:issue:`34592`)
+- Fixed regression where :meth:`DataFrame.apply` would raise ``ValueError`` for elements whth ``S`` dtype (:issue:`34529`)
 
 Sparse
 ^^^^^^
diff --git a/pandas/core/dtypes/cast.py b/pandas/core/dtypes/cast.py
index e69e3bab1..d0417d51d 100644
--- a/pandas/core/dtypes/cast.py
+++ b/pandas/core/dtypes/cast.py
@@ -1608,7 +1608,7 @@ def construct_1d_ndarray_preserving_na(
     """
     subarr = np.array(values, dtype=dtype, copy=copy)
 
-    if dtype is not None and dtype.kind in ("U", "S"):
+    if dtype is not None and dtype.kind == "U":
         # GH-21083
         # We can't just return np.array(subarr, dtype='str') since
         # NumPy will convert the non-string objects into strings
diff --git a/pandas/tests/frame/test_apply.py b/pandas/tests/frame/test_apply.py
index d12699397..48a141a65 100644
--- a/pandas/tests/frame/test_apply.py
+++ b/pandas/tests/frame/test_apply.py
@@ -785,6 +785,17 @@ class TestDataFrameApply:
             df.applymap(func)
             assert values == df.a.to_list()
 
+    def test_apply_with_byte_string(self):
+        # GH 34529
+        df = pd.DataFrame(np.array([b"abcd", b"efgh"]), columns=["col"])
+        expected = pd.DataFrame(
+            np.array([b"abcd", b"efgh"]), columns=["col"], dtype=object
+        )
+        # After we make the aply we exect a dataframe just
+        # like the original but with the object datatype
+        result = df.apply(lambda x: x.astype("object"))
+        tm.assert_frame_equal(result, expected)
+
 
 class TestInferOutputShape:
     # the user has supplied an opaque UDF where

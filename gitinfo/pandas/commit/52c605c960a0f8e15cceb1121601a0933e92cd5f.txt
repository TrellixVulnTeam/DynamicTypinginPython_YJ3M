commit 52c605c960a0f8e15cceb1121601a0933e92cd5f
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Jan 10 02:47:58 2010 +0000

    added more statistical methods to WidePanel and finally grinding out unit tests for Panel classes
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@112 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 346bc5d00..bdc11001b 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1588,11 +1588,14 @@ class DataFrame(Picklable, Groupable):
         -------
         Series or TimeSeries
         """
+        def f(arr):
+            return tseries.median(arr[notnull(arr)])
+
         if axis == 0:
-            med = [np.median(self[col].valid()) for col in self.columns]
+            med = [f(self[col].values()) for col in self.columns]
             return Series(med, index=self.columns)
         elif axis == 1:
-            med = [np.median(self.getXS(k).valid()) for k in self.index]
+            med = [f(self.getXS(k).values()) for k in self.index]
             return Series(med, index=self.index)
         else:
             raise Exception('Must have 0<= axis <= 1')
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index ebe16dae2..bc8f97bd8 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -19,6 +19,7 @@ from pandas.core.index import Index
 from pandas.core.frame import DataFrame
 from pandas.core.matrix import DataMatrix
 from pandas.core.mixins import Picklable
+from pandas.lib.tseries import notnull
 import pandas.lib.tseries as tseries
 
 class PanelError(Exception):
@@ -108,17 +109,6 @@ class Panel(Picklable):
 
     minor_axis = property(fget=_get_minor_axis, fset=_set_minor_axis)
 
-    def _get_values(self):
-        return self._values
-
-    def _set_values(self, values):
-        if not values.flags.contiguous:
-            values = values.copy()
-
-        self._values = values
-
-    values = property(fget=_get_values, fset=_set_values)
-
     @property
     def dims(self):
         return len(self.items), len(self.major_axis), len(self.minor_axis)
@@ -192,6 +182,17 @@ class WidePanel(Panel):
 
         return index, columns
 
+    def copy(self):
+        """
+        Return a copy of WidePanel (only values ndarray copied)
+
+        Returns
+        -------
+        y : WidePanel
+        """
+        return WidePanel(self.values.copy(), self.items, self.major_axis,
+                         self.minor_axis)
+
     @classmethod
     def fromDict(cls, data, intersect=True, dtype=float):
         """
@@ -247,9 +248,6 @@ class WidePanel(Panel):
         return DataMatrix(mat, index=self.major_axis, columns=self.minor_axis)
 
     def __setitem__(self, key, value):
-        """
-        Insert item at end of items for now
-        """
         _, N, K = self.dims
 
         # XXX
@@ -269,8 +267,14 @@ class WidePanel(Panel):
             mat = np.empty((1, N, K), dtype=float)
             mat.fill(value)
 
-        self.items = Index(list(self.items) + [key])
-        self.values = np.row_stack((self.values, mat))
+        if key in self.items:
+            loc = self.items.indexMap[key]
+            self.values[loc] = mat
+        else:
+            self.items = Index(list(self.items) + [key])
+
+            # Insert item at end of items for now
+            self.values = np.row_stack((self.values, mat))
 
     def __getstate__(self):
         "Returned pickled representation of the panel"
@@ -309,15 +313,15 @@ class WidePanel(Panel):
 
         return frame.reindex(index=index, columns=columns)
 
-    def reindex(self, new_index, axis='major', fill_method=None):
+    def reindex(self, major=None, items=None, minor=None, fill_method=None):
         """
-        Conform
+        Conform panel to new axis or axes
 
         Parameters
         ----------
-        new_index : Index or sequence
-        axis : {'items', 'major', 'minor'}
-            Axis to reindex
+        major : Index or sequence, default None
+        items : Index or sequence, default None
+        minor : Index or sequence, default None
         fill_method : {'backfill', 'pad', 'interpolate', None}
             Method to use for filling holes in reindexed panel
 
@@ -325,56 +329,64 @@ class WidePanel(Panel):
         -------
         WidePanel (new object)
         """
+        result = self
+
+        if major is not None:
+            result = result._reindex_major(major, fill_method)
+
+        if minor is not None:
+            result = result._reindex_minor(minor, fill_method)
 
-        axis_i = self._wide_axis_number(axis)
-        current_axis = self._get_axis(axis)
+        if items is not None:
+            result = result._reindex_items(items, fill_method)
 
-        if new_index.equals(current_axis):
+        if result is self:
+            raise Exception('Must specify at least one axis')
+
+        return result
+
+    def _reindex_items(self, new_index, fill_method):
+        if self.items.equals(new_index):
             return self.copy()
 
         if not isinstance(new_index, Index):
             new_index = Index(new_index)
 
-        if not fill_method:
-            fill_method = ''
+        indexer, mask = _get_indexer(self.items, new_index, fill_method)
+
+        new_values = self.values.take(indexer, axis=0)
+        new_values[-mask] = np.NaN
 
-        fill_method = fill_method.upper()
+        return WidePanel(new_values, new_index, self.major_axis,
+                         self.minor_axis)
 
-        if fill_method not in ['BACKFILL', 'PAD', '']:
-            raise Exception("Don't recognize fill_method: %s" % fill_method)
+    def _reindex_major(self, new_index, fill_method):
+        if self.major_axis.equals(new_index):
+            return self.copy()
 
-        indexer, mask = tseries.getFillVec(current_axis, new_index,
-                                           current_axis.indexMap,
-                                           new_index.indexMap, fill_method)
+        if not isinstance(new_index, Index):
+            new_index = Index(new_index)
 
-        new_values = self.values.take(indexer, axis=axis_i)
+        indexer, mask = _get_indexer(self.major_axis, new_index, fill_method)
 
-        new_items = self.items
-        new_major = self.major_axis
-        new_minor = self.minor_axis
-#        new_factors = dict((k, v.take(indexer))
-#                           for k, v in self.factors.iteritems())
+        new_values = self.values.take(indexer, axis=1)
+        new_values[:, -mask, :] = np.NaN
 
-        if axis_i == 0:
-            new_values[-mask] = np.NaN
-            new_items = new_index
-        elif axis_i == 1:
-            new_values[:, -mask, :] = np.NaN
-            new_major = new_index
-        else:
-            new_values[:, :, -mask] = np.NaN
-            new_minor = new_index
+        return WidePanel(new_values, self.items, new_index, self.minor_axis)
 
-        return WidePanel(new_values, new_items, new_major, new_minor)
+    def _reindex_minor(self, new_index, fill_method):
+        if self.minor_axis.equals(new_index):
+            return self.copy()
 
-    def _reindex_items(self, new_items):
-        pass
+        if not isinstance(new_index, Index):
+            new_index = Index(new_index)
 
-    def _reindex_major(self, new_major):
-        pass
+        indexer, mask = _get_indexer(self.minor_axis, new_index, fill_method)
 
-    def _reindex_minor(self, new_minor):
-        pass
+        new_values = self.values.take(indexer, axis=2)
+        new_values[:, :, -mask] = np.NaN
+
+        return WidePanel(new_values, self.items, self.major_axis, new_index)
 
     def _combine(self, other, func, axis=0):
         if isinstance(other, DataFrame):
@@ -420,7 +432,6 @@ class WidePanel(Panel):
     def _combinePanel(self, other, func):
         pass
 
-
     def add(self, other, axis='major'):
         """
 
@@ -575,8 +586,10 @@ class WidePanel(Panel):
         return WidePanel(new_values, intersection, self.major_axis,
                          self.minor_axis)
 
-    def _apply(self, func, axis='major', fill_value=None):
+    def apply(self, func, axis='major'):
         """
+        Apply
+
         Parameters
         ----------
         func : numpy function
@@ -587,12 +600,15 @@ class WidePanel(Panel):
 
         Returns
         -------
-        DataMatrix
+        result : DataMatrix or WidePanel
         """
-
         i = self._wide_axis_number(axis)
-        index, columns = self._get_plane_axes(axis)
 
+        result = np.apply_along_axis(func, i, self.values)
+
+        return self._wrap_result(result, axis=axis)
+
+    def _values_aggregate(self, func, axis, fill_value):
         values = self.values
         mask = np.isfinite(values)
 
@@ -600,18 +616,31 @@ class WidePanel(Panel):
             values = values.copy()
             values[-mask] = fill_value
 
-        result = func(values, axis=i)
-        count = mask.sum(axis=i)
+        result = func(values, axis=axis)
+        count = mask.sum(axis=axis)
 
         result[count == 0] = np.NaN
 
-        if axis != 'items':
-            result = result.T
+        return result
 
-        if not result.ndim == 2:
-            raise Exception('function %s incompatible' % func)
+    def _array_method(self, func, axis='major', fill_value=None):
+        """
+        Parameters
+        ----------
+        func : numpy function
+            Signature should match numpy.{sum, mean, var, std} etc.
+        axis : {'major', 'minor', 'items'}
+        fill_value : boolean, default True
+            Replace NaN values with specified first
+
+        Returns
+        -------
+        DataMatrix
+        """
+        i = self._wide_axis_number(axis)
 
-        return DataMatrix(result, index=index, columns=columns)
+        result = self._values_aggregate(func, i, fill_value)
+        return self._wrap_result(result, axis=axis)
 
     def count(self, axis='major'):
         """
@@ -622,17 +651,12 @@ class WidePanel(Panel):
         y : DataMatrix
         """
         i = self._wide_axis_number(axis)
-        index, columns = self._get_plane_axes(axis)
 
         values = self.values
         mask = np.isfinite(values)
-
         result = mask.sum(axis=i)
 
-        if axis != 'items':
-            result = result.T
-
-        return DataMatrix(result, index=index, columns=columns)
+        return self._wrap_result(result, axis)
 
     def sum(self, axis='major'):
         """
@@ -641,7 +665,7 @@ class WidePanel(Panel):
         -------
         y : DataMatrix
         """
-        return self._apply(np.sum, axis=axis, fill_value=0)
+        return self._array_method(np.sum, axis=axis, fill_value=0)
 
     def cumsum(self, axis='major'):
         """
@@ -650,7 +674,7 @@ class WidePanel(Panel):
         -------
         y : WidePanel
         """
-        return self._apply(np.cumsum, axis=axis, fill_value=0)
+        return self._array_method(np.cumsum, axis=axis, fill_value=0)
 
     def mean(self, axis='major'):
         """
@@ -682,10 +706,7 @@ class WidePanel(Panel):
 
         theVar = (XX - X**2 / count) / (count - 1)
 
-        if axis != 'items':
-            theVar = theVar.T
-
-        return DataMatrix(theVar, index=index, columns=columns)
+        return self._wrap_result(theVar, axis)
 
     def std(self, axis='major'):
         """
@@ -706,7 +727,7 @@ class WidePanel(Panel):
         -------
         y : DataMatrix
         """
-        return self._apply(np.prod, axis=axis, fill_value=1)
+        return self._array_method(np.prod, axis=axis, fill_value=1)
 
     def compound(self, axis='major'):
         """
@@ -717,6 +738,74 @@ class WidePanel(Panel):
         """
         return (1 + self).prod(axis=axis) - 1
 
+    def median(self, axis='major'):
+        """
+
+        Returns
+        -------
+        y : DataMatrix
+        """
+        def f(arr):
+            return tseries.median(arr[notnull(arr)])
+
+        return self.apply(f, axis=axis)
+
+    def max(self, axis='major'):
+        """
+
+        Returns
+        -------
+        y : DataMatrix
+        """
+        i = self._wide_axis_number(axis)
+
+        y = np.array(self.values)
+        mask = np.isfinite(y)
+
+        fill_value = y.flat[mask.ravel()].min() - 1
+
+        y[-mask] = fill_value
+
+        result = y.max(axis=i)
+        result[result == fill_value] = np.NaN
+
+        return self._wrap_result(result, axis)
+
+    def min(self, axis='major'):
+        """
+
+        Returns
+        -------
+        y : DataMatrix
+        """
+        i = self._wide_axis_number(axis)
+
+        y = np.array(self.values)
+        mask = np.isfinite(y)
+
+        fill_value = y.flat[mask.ravel()].max() + 1
+
+        y[-mask] = fill_value
+
+        result = y.min(axis=i)
+        result[result == fill_value] = np.NaN
+
+        return self._wrap_result(result, axis)
+
+    def _wrap_result(self, result, axis):
+        axis = self._wide_axis_name(axis)
+
+        if result.ndim == 2:
+            index, columns = self._get_plane_axes(axis)
+
+            if axis != 'items':
+                result = result.T
+
+            return DataMatrix(result, index=index, columns=columns)
+        else:
+            return WidePanel(result, self.items, self.major_axis,
+                             self.minor_axis)
+
     def shift(self, lags, axis='major'):
         values = self.values
         items = self.items
@@ -764,8 +853,8 @@ class LongPanelIndex(object):
         self.major_axis = _unpickle_array(major)
         self.minor_axis = _unpickle_array(minor)
 
-        self.major_axis = _unpickle_array(major_labels)
-        self.minor_axis = _unpickle_array(minor_labels)
+        self.major_labels = _unpickle_array(major_labels)
+        self.minor_labels = _unpickle_array(minor_labels)
 
     def isConsistent(self):
         offset = max(len(self.major_axis), len(self.minor_axis))
@@ -1517,6 +1606,19 @@ class Factor(object):
             new_labels = self.labels[key]
             return Factor(new_labels, self.levels)
 
+def _get_indexer(source, target, fill_method):
+    if not fill_method:
+        fill_method = ''
+
+    fill_method = fill_method.upper()
+
+    if fill_method not in ['BACKFILL', 'PAD', '']:
+        raise Exception("Don't recognize fill_method: %s" % fill_method)
+
+    indexer, mask = tseries.getFillVec(source, target, source.indexMap,
+                                       target.indexMap, fill_method)
+
+    return indexer, mask
 
 def _makeItemName(item, prefix=None):
     if prefix is None:
@@ -1681,49 +1783,3 @@ class WidePanelGroupBy(GroupBy):
 
 class LongPanelGroupBy(GroupBy):
     pass
-
-if __name__ == '__main__':
-    from datetime import datetime
-    import string
-
-    import numpy as np
-
-    from pandas.core.api import DataMatrix, DateRange
-
-    N = 50
-    K = 4
-
-    start = datetime(2009, 9, 2)
-    dateRange = DateRange(start, periods=N)
-
-    cols = ['Col' + c for c in string.ascii_uppercase[:K]]
-
-    def makeDataMatrix():
-        data = DataMatrix(np.random.randn(N, K),
-                          columns=cols,
-                          index=dateRange)
-
-        return data
-
-    def makeDataMatrixForWeekday():
-        values = [d.weekday() for d in dateRange]
-        data = DataMatrix(dict((k, values) for k in cols),
-                          index=dateRange)
-
-        return data
-
-    data = {
-        'ItemA' : makeDataMatrix(),
-        'ItemB' : makeDataMatrix(),
-        'ItemC' : makeDataMatrix(),
-#        'ItemD' : makeDataMatrixForWeekday(),
-    }
-
-    Y = makeDataMatrix()
-
-    data['ItemA']['ColA'][:10] = np.NaN
-
-    panel = WidePanel.fromDict(data)
-
-    longPanel = panel.toLong(filter_observations=True)
-    widePanel = longPanel.toWide()
diff --git a/pandas/core/tests/common.py b/pandas/core/tests/common.py
index 9ed3bd947..543990f30 100644
--- a/pandas/core/tests/common.py
+++ b/pandas/core/tests/common.py
@@ -7,7 +7,8 @@ import string
 from numpy.random import randn
 import numpy as np
 
-from pandas.core.api import DateRange, Index, Series, DataFrame, DataMatrix
+from pandas.core.api import (DateRange, Index, Series, DataFrame,
+                             DataMatrix, WidePanel)
 
 N = 30
 K = 4
@@ -142,3 +143,21 @@ def makeDataMatrix():
 def makeTimeDataMatrix():
     data = getTimeSeriesData()
     return DataMatrix(data)
+
+def makeWidePanel():
+    cols = ['Item' + c for c in string.ascii_uppercase[:K - 1]]
+    data = dict((c, makeTimeDataMatrix()) for c in cols)
+    return WidePanel.fromDict(data)
+
+def add_nans(panel):
+    I, J, N = panel.dims
+    for i, item in enumerate(panel.items):
+        dm = panel[item]
+        for j, col in enumerate(dm.columns):
+            dm[col][:i + j] = np.NaN
+
+def makeLongPanel():
+    wp = makeWidePanel()
+    add_nans(wp)
+
+    return wp.toLong()
diff --git a/pandas/core/tests/test_panel.py b/pandas/core/tests/test_panel.py
index be167625b..8dc6bbb13 100644
--- a/pandas/core/tests/test_panel.py
+++ b/pandas/core/tests/test_panel.py
@@ -1,27 +1,212 @@
 import unittest
+import operator
 
+import numpy as np
+
+from pandas.core.api import notnull
+from pandas.core.datetools import bday
 from pandas.core.panel import WidePanel, LongPanel
+from pandas.core.tests.common import (assert_frame_equal,
+                                      assert_series_equal,
+                                      assert_almost_equal)
 import pandas.core.tests.common as common
 
-class TestWidePanel(unittest.TestCase):
+class PanelTests(object):
+
+    def test_iter(self):
+        common.equalContents(list(self.panel), self.panel.items)
+
+    def test_pickle(self):
+        import cPickle
+
+        pickled = cPickle.dumps(self.panel)
+        unpickled = cPickle.loads(pickled)
+
+        assert_frame_equal(unpickled['ItemA'], self.panel['ItemA'])
+
+    def test_repr(self):
+        foo = repr(self.panel)
+
+    def test_set_values(self):
+        self.panel.values = np.array(self.panel.values, order='F')
+
+        assert(self.panel.values.flags.contiguous)
+
+    def _check_statistic(self, frame, name, alternative):
+        f = getattr(frame, name)
+
+        for i, ax in enumerate(['items', 'major', 'minor']):
+            result = f(axis=i)
+            assert_frame_equal(result, frame.apply(alternative, axis=ax))
+
+    def test_count(self):
+        f = lambda s: notnull(s).sum()
+
+        self._check_statistic(self.panel, 'count', f)
+
+    def test_sum(self):
+        def f(x):
+            x = np.asarray(x)
+            nona = x[notnull(x)]
+
+            if len(nona) == 0:
+                return np.NaN
+            else:
+                return nona.sum()
+
+        self._check_statistic(self.panel, 'sum', f)
+
+    def test_prod(self):
+        def f(x):
+            x = np.asarray(x)
+            nona = x[notnull(x)]
+
+            if len(nona) == 0:
+                return np.NaN
+            else:
+                return np.prod(nona)
+
+        self._check_statistic(self.panel, 'prod', f)
+
+    def test_mean(self):
+        def f(x):
+            x = np.asarray(x)
+            return x[notnull(x)].mean()
+
+        self._check_statistic(self.panel, 'mean', f)
+
+    def test_median(self):
+        def f(x):
+            x = np.asarray(x)
+            return np.median(x[notnull(x)])
+
+        self._check_statistic(self.panel, 'median', f)
+
+    def test_min(self):
+        def f(x):
+            x = np.asarray(x)
+            nona = x[notnull(x)]
+
+            if len(nona) == 0:
+                return np.NaN
+            else:
+                return nona.min()
+
+        self._check_statistic(self.panel, 'min', f)
+
+    def test_max(self):
+        def f(x):
+            x = np.asarray(x)
+            nona = x[notnull(x)]
+
+            if len(nona) == 0:
+                return np.NaN
+            else:
+                return nona.max()
+
+        self._check_statistic(self.panel, 'max', f)
+
+    def test_var(self):
+        def f(x):
+            x = np.asarray(x)
+            nona = x[notnull(x)]
+
+            if len(nona) < 2:
+                return np.NaN
+            else:
+                return nona.var(ddof=1)
+
+        self._check_statistic(self.panel, 'var', f)
+
+    def test_std(self):
+        def f(x):
+            x = np.asarray(x)
+            nona = x[notnull(x)]
+
+            if len(nona) < 2:
+                return np.NaN
+            else:
+                return nona.std(ddof=1)
+
+        self._check_statistic(self.panel, 'std', f)
+
+    def test_skew(self):
+        return
+        from scipy.stats import skew
+        def f(x):
+            x = np.asarray(x)
+            return skew(x[notnull(x)], bias=False)
+
+        self._check_statistic(self.panel, 'skew', f)
+
+    def test_cumsum(self):
+        cumsum = self.panel.cumsum()
+
+        assert_frame_equal(cumsum['ItemA'], self.panel['ItemA'].cumsum())
+
+class TestWidePanel(unittest.TestCase, PanelTests):
+
+    def setUp(self):
+        self.panel = common.makeWidePanel()
+
+        common.add_nans(self.panel)
+
+    def test_get_axis(self):
+        assert(self.panel._get_axis(0) is self.panel.items)
+        assert(self.panel._get_axis(1) is self.panel.major_axis)
+        assert(self.panel._get_axis(2) is self.panel.minor_axis)
 
     def test_wide_axis_number(self):
-        pass
+        assert(self.panel._wide_axis_number('items'), 0)
+        assert(self.panel._wide_axis_number('major'), 1)
+        assert(self.panel._wide_axis_number('minor'), 2)
 
     def test_wide_axis_name(self):
-        pass
+        assert(self.panel._wide_axis_name(0), 'items')
+        assert(self.panel._wide_axis_name(1), 'major')
+        assert(self.panel._wide_axis_name(2), 'minor')
 
     def test_get_plane_axes(self):
-        pass
+        # what to do here?
+
+        index, columns = self.panel._get_plane_axes('items')
+        index, columns = self.panel._get_plane_axes('major')
+        index, columns = self.panel._get_plane_axes('minor')
+
+        index, columns = self.panel._get_plane_axes(0)
+
+    def test_arith(self):
+        def test_op(panel, op):
+            result = op(panel, 1)
+            assert_frame_equal(result['ItemA'], op(panel['ItemA'], 1))
+
+        test_op(self.panel, operator.add)
+        test_op(self.panel, operator.sub)
+        test_op(self.panel, operator.mul)
+        test_op(self.panel, operator.div)
+        test_op(self.panel, operator.pow)
+
+        test_op(self.panel, lambda x, y: y + x)
+        test_op(self.panel, lambda x, y: y - x)
+        test_op(self.panel, lambda x, y: y * x)
+        test_op(self.panel, lambda x, y: y / x)
+        test_op(self.panel, lambda x, y: y ** x)
+
+        self.assertRaises(Exception, self.panel.__add__, self.panel['ItemA'])
 
     def test_fromDict(self):
         pass
 
     def test_keys(self):
-        pass
+        common.equalContents(self.panel.keys(), self.panel.items)
 
     def test_iteritems(self):
-        pass
+        # just test that it works
+        for k, v in self.panel.iteritems():
+            pass
+
+        self.assertEqual(len(list(self.panel.iteritems())),
+                         len(self.panel.items))
 
     def test_values(self):
         pass
@@ -30,19 +215,106 @@ class TestWidePanel(unittest.TestCase):
         pass
 
     def test_setitem(self):
-        pass
 
-    def test_pickle(self):
-        pass
+        # LongPanel with one item
+        lp = self.panel.filterItems(['ItemA']).toLong()
+        self.panel['ItemE'] = lp
+
+        lp = self.panel.filterItems(['ItemA', 'ItemB']).toLong()
+        self.assertRaises(Exception, self.panel.__setitem__,
+                          'ItemE', lp)
+
+        # DataFrame
+        df = self.panel['ItemA'][2:].filter(items=['A', 'B'])
+        self.panel['ItemF'] = df
+        self.panel['ItemE'] = df
+
+        df2 = self.panel['ItemF']
+
+        assert_frame_equal(df, df2.reindex(index=df.index,
+                                           columns=df.columns))
+
+        # scalar
+        self.panel['ItemG'] = 1
+        self.panel['ItemE'] = 1
 
     def test_conform(self):
-        pass
+        df = self.panel['ItemA'][:-5].filter(items=['A', 'B'])
+        conformed = self.panel.conform(df)
+
+        assert(conformed.index.equals(self.panel.major_axis))
+        assert(conformed.columns.equals(self.panel.minor_axis))
 
     def test_reindex(self):
-        pass
+        ref = self.panel['ItemB']
+
+        # items
+        result = self.panel.reindex(items=['ItemA', 'ItemB'])
+        assert_frame_equal(result['ItemB'], ref)
+
+        # major
+        new_major = self.panel.major_axis[:10]
+        result = self.panel.reindex(major=new_major)
+        assert_frame_equal(result['ItemB'], ref.reindex(index=new_major))
+
+        # minor
+        new_minor = self.panel.minor_axis[:2]
+        result = self.panel.reindex(minor=new_minor)
+        assert_frame_equal(result['ItemB'], ref.reindex(columns=new_minor))
+
+        result = self.panel.reindex(items=self.panel.items,
+                                    major=self.panel.major_axis,
+                                    minor=self.panel.minor_axis)
+
+        assert(result.items is self.panel.items)
+        assert(result.major_axis is self.panel.major_axis)
+        assert(result.minor_axis is self.panel.minor_axis)
+
+        self.assertRaises(Exception, self.panel.reindex)
+
+        # with filling
+        smaller_major = self.panel.major_axis[::5]
+        smaller = self.panel.reindex(major=smaller_major)
+
+        larger = smaller.reindex(major=self.panel.major_axis,
+                                 fill_method='pad')
+
+        assert_frame_equal(larger.getMajorXS(self.panel.major_axis[1]),
+                           smaller.getMajorXS(smaller_major[0]))
 
     def test_combineFrame(self):
-        pass
+        def check_op(op, name):
+            # items
+            df = self.panel['ItemA']
+
+            func = getattr(self.panel, name)
+
+            result = func(df, axis='items')
+
+            assert_frame_equal(result['ItemB'], op(self.panel['ItemB'], df))
+
+            # major
+            xs = self.panel.getMajorXS(self.panel.major_axis[0])
+            result = func(xs, axis='major')
+
+            idx = self.panel.major_axis[1]
+
+            assert_frame_equal(result.getMajorXS(idx),
+                               op(self.panel.getMajorXS(idx), xs))
+
+            # minor
+            xs = self.panel.getMinorXS(self.panel.minor_axis[0])
+            result = func(xs, axis='minor')
+
+            idx = self.panel.minor_axis[1]
+
+            assert_frame_equal(result.getMinorXS(idx),
+                               op(self.panel.getMinorXS(idx), xs))
+
+        check_op(operator.add, 'add')
+        check_op(operator.sub, 'subtract')
+        check_op(operator.mul, 'multiply')
+        check_op(operator.div, 'divide')
 
     def test_combinePanel(self):
         pass
@@ -51,10 +323,27 @@ class TestWidePanel(unittest.TestCase):
         pass
 
     def test_getMajorXS(self):
-        pass
+        ref = self.panel['ItemA']
+
+        idx = self.panel.major_axis[5]
+        xs = self.panel.getMajorXS(idx)
+
+        assert_series_equal(xs['ItemA'], ref.getXS(idx))
+
+        # not contained
+        idx = self.panel.major_axis[0] - bday
+        self.assertRaises(Exception, self.panel.getMajorXS, idx)
 
     def test_getMinorXS(self):
-        pass
+        ref = self.panel['ItemA']
+
+        idx = self.panel.minor_axis[1]
+        xs = self.panel.getMinorXS(idx)
+
+        assert_series_equal(xs['ItemA'], ref[idx])
+
+        # not contained
+        self.assertRaises(Exception, self.panel.getMinorXS, 'E')
 
     def test_groupby(self):
         pass
@@ -63,7 +352,12 @@ class TestWidePanel(unittest.TestCase):
         pass
 
     def test_toLong(self):
-        pass
+        # filtered
+        filtered = self.panel.toLong()
+
+        # unfiltered
+        unfiltered = self.panel.toLong(filter_observations=False)
+
 
     def test_filterItems(self):
         pass
@@ -72,11 +366,44 @@ class TestWidePanel(unittest.TestCase):
         pass
 
     def test_shift(self):
-        pass
+        # major
+        idx = self.panel.major_axis[0]
+        idx_lag = self.panel.major_axis[1]
+
+        shifted = self.panel.shift(1)
+
+        assert_frame_equal(self.panel.getMajorXS(idx),
+                           shifted.getMajorXS(idx_lag))
+
+        # minor
+        idx = self.panel.minor_axis[0]
+        idx_lag = self.panel.minor_axis[1]
+
+        shifted = self.panel.shift(1, axis='minor')
 
+        assert_frame_equal(self.panel.getMinorXS(idx),
+                           shifted.getMinorXS(idx_lag))
+
+        self.assertRaises(Exception, self.panel.shift, axis='items')
 
 class TestLongPanelIndex(unittest.TestCase):
 
+    def setUp(self):
+        panel = common.makeWidePanel()
+        common.add_nans(panel)
+
+        self.panel = panel.toLong()
+        self.unfiltered_panel = panel.toLong(filter_observations=False)
+
+    def test_pickle(self):
+        import cPickle
+
+        pickled = cPickle.dumps(self.panel)
+        unpickled = cPickle.loads(pickled)
+
+        assert_almost_equal(unpickled['ItemA'].values,
+                            self.panel['ItemA'].values)
+
     def test_constructor(self):
         pass
 

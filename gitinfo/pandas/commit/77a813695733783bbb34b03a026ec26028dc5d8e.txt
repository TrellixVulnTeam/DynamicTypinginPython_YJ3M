commit 77a813695733783bbb34b03a026ec26028dc5d8e
Author: jreback <jeff@reback.net>
Date:   Tue Jan 21 08:51:30 2014 -0500

    BUG: Regression in Series with a multi-index via ix (GH6018)
    CLN: Remove references to _SeriesIndexer (vestigial)

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 94652eb48..d1928a954 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -126,8 +126,9 @@ Bug Fixes
     of pandas in QTConsole, now fixed. If you're using an older version and
     need to supress the warnings, see (:issue:`5922`).
   - Bug in merging ``timedelta`` dtypes (:issue:`5695`)
-  - Bug in plotting.scatter_matrix function. Wrong alignment among diagonal 
+  - Bug in plotting.scatter_matrix function. Wrong alignment among diagonal
     and off-diagonal plots, see (:issue:`5497`).
+  - Regression in Series with a multi-index via ix (:issue:`6018`)
 
 pandas 0.13.0
 -------------
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 751c020fe..474b5ae3a 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -57,7 +57,9 @@ class _NDFrameIndexer(object):
 
     def _get_label(self, label, axis=0):
         # ueber-hack
-        if (isinstance(label, tuple) and
+        if self.ndim == 1:
+            return self.obj[label]
+        elif (isinstance(label, tuple) and
                 isinstance(label[axis], slice)):
 
             raise IndexingError('no slices here')
@@ -1364,46 +1366,6 @@ def _is_index_slice(obj):
     return not both_none and (_crit(obj.start) and _crit(obj.stop))
 
 
-class _SeriesIndexer(_IXIndexer):
-
-    """
-    Class to support fancy indexing, potentially using labels
-
-    Notes
-    -----
-    Indexing based on labels is INCLUSIVE
-    Slicing uses PYTHON SEMANTICS (endpoint is excluded)
-
-    If Index contains int labels, these will be used rather than the locations,
-    so be very careful (ambiguous).
-
-    Examples
-    --------
-    >>> ts.ix[5:10] # equivalent to ts[5:10]
-    >>> ts.ix[[date1, date2, date3]]
-    >>> ts.ix[date1:date2] = 0
-    """
-
-    def _get_label(self, key, axis=0):
-        return self.obj[key]
-
-    def _get_loc(self, key, axis=0):
-        return self.obj.values[key]
-
-    def _slice(self, indexer, axis=0, typ=None):
-        return self.obj._get_values(indexer)
-
-    def _setitem_with_indexer(self, indexer, value):
-
-        # need to delegate to the super setter
-        if isinstance(indexer, dict):
-            return super(_SeriesIndexer, self)._setitem_with_indexer(indexer,
-                                                                     value)
-
-        # fast access
-        self.obj._set_values(indexer, value)
-
-
 def _check_bool_indexer(ax, key):
     # boolean indexing, need to check that the data are aligned, otherwise
     # disallowed
diff --git a/pandas/core/series.py b/pandas/core/series.py
index a5459bfb2..2702e0be4 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -28,7 +28,7 @@ from pandas.core.common import (isnull, notnull, _is_bool_indexer,
 from pandas.core.index import (Index, MultiIndex, InvalidIndexError,
                                _ensure_index, _handle_legacy_indexes)
 from pandas.core.indexing import (
-    _SeriesIndexer, _check_bool_indexer, _check_slice_bounds,
+    _check_bool_indexer, _check_slice_bounds,
     _is_index_slice, _maybe_convert_indices)
 from pandas.core import generic
 from pandas.core.internals import SingleBlockManager
@@ -2473,10 +2473,6 @@ Series._setup_axes(['index'], info_axis=0, stat_axis=0,
 Series._add_numeric_operations()
 _INDEX_TYPES = ndarray, Index, list, tuple
 
-# reinstall the SeriesIndexer
-# defined in indexing.py; pylint: disable=E0203
-Series._create_indexer('ix', _SeriesIndexer)
-
 #------------------------------------------------------------------------------
 # Supplementary functions
 
diff --git a/pandas/tests/test_indexing.py b/pandas/tests/test_indexing.py
index 8f3f122fe..48521e06e 100644
--- a/pandas/tests/test_indexing.py
+++ b/pandas/tests/test_indexing.py
@@ -832,6 +832,22 @@ class TestIndexing(tm.TestCase):
         xp = mi_int.ix[4]
         assert_frame_equal(rs,xp)
 
+    def test_series_getitem_multiindex(self):
+
+        # GH 6018
+        # series regression getitem with a multi-index
+
+        s = Series([1,2,3])
+        s.index = MultiIndex.from_tuples([(0,0),(1,1), (2,1)])
+
+        result = s[:,0]
+        expected = Series([1],index=[0])
+        assert_series_equal(result,expected)
+
+        result = s.ix[:,1]
+        expected = Series([2,3],index=[1,2])
+        assert_series_equal(result,expected)
+
     def test_ix_general(self):
 
         # ix general issues

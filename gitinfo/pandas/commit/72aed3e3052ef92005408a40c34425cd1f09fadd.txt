commit 72aed3e3052ef92005408a40c34425cd1f09fadd
Author: William Ayd <will_ayd@innobi.io>
Date:   Wed Jun 17 10:26:56 2020 -0700

    Replaced numpy type aliases; fix CI failure (#34835)

diff --git a/asv_bench/benchmarks/pandas_vb_common.py b/asv_bench/benchmarks/pandas_vb_common.py
index fd1770df8..23286343d 100644
--- a/asv_bench/benchmarks/pandas_vb_common.py
+++ b/asv_bench/benchmarks/pandas_vb_common.py
@@ -33,7 +33,7 @@ numeric_dtypes = [
     np.uint8,
 ]
 datetime_dtypes = [np.datetime64, np.timedelta64]
-string_dtypes = [np.object]
+string_dtypes = [object]
 try:
     extension_dtypes = [
         pd.Int8Dtype,
diff --git a/asv_bench/benchmarks/series_methods.py b/asv_bench/benchmarks/series_methods.py
index d78419c12..258c29c14 100644
--- a/asv_bench/benchmarks/series_methods.py
+++ b/asv_bench/benchmarks/series_methods.py
@@ -58,17 +58,15 @@ class IsInFloat64:
 
 class IsInForObjects:
     def setup(self):
-        self.s_nans = Series(np.full(10 ** 4, np.nan)).astype(np.object)
-        self.vals_nans = np.full(10 ** 4, np.nan).astype(np.object)
-        self.s_short = Series(np.arange(2)).astype(np.object)
-        self.s_long = Series(np.arange(10 ** 5)).astype(np.object)
-        self.vals_short = np.arange(2).astype(np.object)
-        self.vals_long = np.arange(10 ** 5).astype(np.object)
+        self.s_nans = Series(np.full(10 ** 4, np.nan)).astype(object)
+        self.vals_nans = np.full(10 ** 4, np.nan).astype(object)
+        self.s_short = Series(np.arange(2)).astype(object)
+        self.s_long = Series(np.arange(10 ** 5)).astype(object)
+        self.vals_short = np.arange(2).astype(object)
+        self.vals_long = np.arange(10 ** 5).astype(object)
         # because of nans floats are special:
-        self.s_long_floats = Series(np.arange(10 ** 5, dtype=np.float)).astype(
-            np.object
-        )
-        self.vals_long_floats = np.arange(10 ** 5, dtype=np.float).astype(np.object)
+        self.s_long_floats = Series(np.arange(10 ** 5, dtype=np.float)).astype(object)
+        self.vals_long_floats = np.arange(10 ** 5, dtype=np.float).astype(object)
 
     def time_isin_nans(self):
         # if nan-objects are different objects,
diff --git a/asv_bench/benchmarks/sparse.py b/asv_bench/benchmarks/sparse.py
index d6aa41a7e..28ceb25ee 100644
--- a/asv_bench/benchmarks/sparse.py
+++ b/asv_bench/benchmarks/sparse.py
@@ -32,7 +32,7 @@ class SparseSeriesToFrame:
 
 class SparseArrayConstructor:
 
-    params = ([0.1, 0.01], [0, np.nan], [np.int64, np.float64, np.object])
+    params = ([0.1, 0.01], [0, np.nan], [np.int64, np.float64, object])
     param_names = ["dense_proportion", "fill_value", "dtype"]
 
     def setup(self, dense_proportion, fill_value, dtype):
diff --git a/doc/source/user_guide/io.rst b/doc/source/user_guide/io.rst
index df6b44ac6..d4be9d802 100644
--- a/doc/source/user_guide/io.rst
+++ b/doc/source/user_guide/io.rst
@@ -1884,7 +1884,7 @@ Fallback behavior
 If the JSON serializer cannot handle the container contents directly it will
 fall back in the following manner:
 
-* if the dtype is unsupported (e.g. ``np.complex``) then the ``default_handler``, if provided, will be called
+* if the dtype is unsupported (e.g. ``np.complex_``) then the ``default_handler``, if provided, will be called
   for each value, otherwise an exception is raised.
 
 * if an object is unsupported it will attempt the following:
diff --git a/pandas/_libs/hashtable_class_helper.pxi.in b/pandas/_libs/hashtable_class_helper.pxi.in
index ad65f9707..e0e026fe7 100644
--- a/pandas/_libs/hashtable_class_helper.pxi.in
+++ b/pandas/_libs/hashtable_class_helper.pxi.in
@@ -178,7 +178,7 @@ cdef class StringVector:
             Py_ssize_t n
             object val
 
-        ao = np.empty(self.data.n, dtype=np.object)
+        ao = np.empty(self.data.n, dtype=object)
         for i in range(self.data.n):
             val = self.data.data[i]
             ao[i] = val
diff --git a/pandas/_libs/hashtable_func_helper.pxi.in b/pandas/_libs/hashtable_func_helper.pxi.in
index 326ae36c6..0cc0a6b19 100644
--- a/pandas/_libs/hashtable_func_helper.pxi.in
+++ b/pandas/_libs/hashtable_func_helper.pxi.in
@@ -94,7 +94,7 @@ cpdef value_count_{{dtype}}({{c_type}}[:] values, bint dropna):
     build_count_table_{{dtype}}(values, table, dropna)
     {{endif}}
 
-    result_keys = np.empty(table.n_occupied, dtype=np.{{dtype}})
+    result_keys = np.empty(table.n_occupied, '{{dtype}}')
     result_counts = np.zeros(table.n_occupied, dtype=np.int64)
 
     {{if dtype == 'object'}}
diff --git a/pandas/_libs/parsers.pyx b/pandas/_libs/parsers.pyx
index 461419239..6ffb036e0 100644
--- a/pandas/_libs/parsers.pyx
+++ b/pandas/_libs/parsers.pyx
@@ -2037,7 +2037,7 @@ def _concatenate_chunks(list chunks):
         numpy_dtypes = {x for x in dtypes if not is_categorical_dtype(x)}
         if len(numpy_dtypes) > 1:
             common_type = np.find_common_type(numpy_dtypes, [])
-            if common_type == np.object:
+            if common_type == object:
                 warning_columns.append(str(name))
 
         dtype = dtypes.pop()
diff --git a/pandas/_libs/sparse.pyx b/pandas/_libs/sparse.pyx
index d853ddf3d..7c9575d92 100644
--- a/pandas/_libs/sparse.pyx
+++ b/pandas/_libs/sparse.pyx
@@ -791,4 +791,4 @@ def make_mask_object_ndarray(ndarray[object, ndim=1] arr, object fill_value):
         if value == fill_value and type(value) == type(fill_value):
             mask[i] = 0
 
-    return mask.view(dtype=np.bool)
+    return mask.view(dtype=bool)
diff --git a/pandas/_libs/testing.pyx b/pandas/_libs/testing.pyx
index 9d3959d0a..ca18afebf 100644
--- a/pandas/_libs/testing.pyx
+++ b/pandas/_libs/testing.pyx
@@ -11,7 +11,7 @@ cdef NUMERIC_TYPES = (
     bool,
     int,
     float,
-    np.bool,
+    np.bool_,
     np.int8,
     np.int16,
     np.int32,
diff --git a/pandas/core/algorithms.py b/pandas/core/algorithms.py
index d270a6431..dcf201524 100644
--- a/pandas/core/algorithms.py
+++ b/pandas/core/algorithms.py
@@ -171,7 +171,7 @@ def _ensure_data(
         return values, dtype
 
     # we have failed, return object
-    values = np.asarray(values, dtype=np.object)
+    values = np.asarray(values, dtype=object)
     return ensure_object(values), np.dtype("object")
 
 
diff --git a/pandas/core/arrays/sparse/array.py b/pandas/core/arrays/sparse/array.py
index 9b89ec99e..4996a1000 100644
--- a/pandas/core/arrays/sparse/array.py
+++ b/pandas/core/arrays/sparse/array.py
@@ -150,7 +150,7 @@ def _sparse_array_op(
             # to make template simple, cast here
             left_sp_values = left.sp_values.view(np.uint8)
             right_sp_values = right.sp_values.view(np.uint8)
-            result_dtype = np.bool
+            result_dtype = bool
         else:
             opname = f"sparse_{name}_{dtype}"
             left_sp_values = left.sp_values
@@ -183,7 +183,7 @@ def _wrap_result(name, data, sparse_index, fill_value, dtype=None):
         name = name[2:-2]
 
     if name in ("eq", "ne", "lt", "gt", "le", "ge"):
-        dtype = np.bool
+        dtype = bool
 
     fill_value = lib.item_from_zerodim(fill_value)
 
diff --git a/pandas/core/base.py b/pandas/core/base.py
index bb1afc8f8..e790b1d7f 100644
--- a/pandas/core/base.py
+++ b/pandas/core/base.py
@@ -1520,7 +1520,7 @@ class IndexOpsMixin:
     def duplicated(self, keep="first"):
         if isinstance(self, ABCIndexClass):
             if self.is_unique:
-                return np.zeros(len(self), dtype=np.bool)
+                return np.zeros(len(self), dtype=bool)
             return duplicated(self, keep=keep)
         else:
             return self._constructor(
diff --git a/pandas/core/dtypes/cast.py b/pandas/core/dtypes/cast.py
index 2a47a03b8..e69e3bab1 100644
--- a/pandas/core/dtypes/cast.py
+++ b/pandas/core/dtypes/cast.py
@@ -225,7 +225,7 @@ def maybe_downcast_numeric(result, dtype, do_round: bool = False):
             # if we have any nulls, then we are done
             return result
 
-        elif not isinstance(r[0], (np.integer, np.floating, np.bool, int, float, bool)):
+        elif not isinstance(r[0], (np.integer, np.floating, int, float, bool)):
             # a comparable, e.g. a Decimal may slip in here
             return result
 
@@ -315,7 +315,7 @@ def maybe_cast_result_dtype(dtype: DtypeObj, how: str) -> DtypeObj:
     from pandas.core.arrays.boolean import BooleanDtype
     from pandas.core.arrays.integer import Int64Dtype
 
-    if how in ["add", "cumsum", "sum"] and (dtype == np.dtype(np.bool)):
+    if how in ["add", "cumsum", "sum"] and (dtype == np.dtype(bool)):
         return np.dtype(np.int64)
     elif how in ["add", "cumsum", "sum"] and isinstance(dtype, BooleanDtype):
         return Int64Dtype()
@@ -597,7 +597,7 @@ def _ensure_dtype_type(value, dtype):
     """
     Ensure that the given value is an instance of the given dtype.
 
-    e.g. if out dtype is np.complex64, we should have an instance of that
+    e.g. if out dtype is np.complex64_, we should have an instance of that
     as opposed to a python complex object.
 
     Parameters
@@ -1483,7 +1483,7 @@ def find_common_type(types: List[DtypeObj]) -> DtypeObj:
     if has_bools:
         for t in types:
             if is_integer_dtype(t) or is_float_dtype(t) or is_complex_dtype(t):
-                return np.object
+                return object
 
     return np.find_common_type(types, [])
 
@@ -1742,7 +1742,7 @@ def validate_numeric_casting(dtype: np.dtype, value):
         if is_float(value) and np.isnan(value):
             raise ValueError("Cannot assign nan to integer series")
 
-    if issubclass(dtype.type, (np.integer, np.floating, np.complex)) and not issubclass(
+    if issubclass(dtype.type, (np.integer, np.floating, complex)) and not issubclass(
         dtype.type, np.bool_
     ):
         if is_bool(value):
diff --git a/pandas/core/dtypes/common.py b/pandas/core/dtypes/common.py
index a4a5ae1bf..9e960375e 100644
--- a/pandas/core/dtypes/common.py
+++ b/pandas/core/dtypes/common.py
@@ -1354,7 +1354,7 @@ def is_bool_dtype(arr_or_dtype) -> bool:
     False
     >>> is_bool_dtype(bool)
     True
-    >>> is_bool_dtype(np.bool)
+    >>> is_bool_dtype(np.bool_)
     True
     >>> is_bool_dtype(np.array(['a', 'b']))
     False
@@ -1526,7 +1526,7 @@ def is_complex_dtype(arr_or_dtype) -> bool:
     False
     >>> is_complex_dtype(int)
     False
-    >>> is_complex_dtype(np.complex)
+    >>> is_complex_dtype(np.complex_)
     True
     >>> is_complex_dtype(np.array(['a', 'b']))
     False
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 9014e576e..26770efb5 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -10024,7 +10024,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
 
         Including only string columns in a ``DataFrame`` description.
 
-        >>> df.describe(include=[np.object])  # doctest: +SKIP
+        >>> df.describe(include=[object])  # doctest: +SKIP
                object
         count       3
         unique      3
@@ -10051,7 +10051,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
 
         Excluding object columns from a ``DataFrame`` description.
 
-        >>> df.describe(exclude=[np.object])  # doctest: +SKIP
+        >>> df.describe(exclude=[object])  # doctest: +SKIP
                categorical  numeric
         count            3      3.0
         unique           3      NaN
diff --git a/pandas/core/groupby/groupby.py b/pandas/core/groupby/groupby.py
index 904049923..48fdb14eb 100644
--- a/pandas/core/groupby/groupby.py
+++ b/pandas/core/groupby/groupby.py
@@ -1267,9 +1267,9 @@ class GroupBy(_GroupBy[FrameOrSeries]):
             if is_object_dtype(vals):
                 vals = np.array([bool(x) for x in vals])
             else:
-                vals = vals.astype(np.bool)
+                vals = vals.astype(bool)
 
-            return vals.view(np.uint8), np.bool
+            return vals.view(np.uint8), bool
 
         def result_to_bool(result: np.ndarray, inference: Type) -> np.ndarray:
             return result.astype(inference, copy=False)
@@ -2059,7 +2059,7 @@ class GroupBy(_GroupBy[FrameOrSeries]):
                 vals = vals.to_numpy(dtype=float, na_value=np.nan)
             elif is_datetime64_dtype(vals.dtype):
                 inference = "datetime64[ns]"
-                vals = np.asarray(vals).astype(np.float)
+                vals = np.asarray(vals).astype(float)
 
             return vals, inference
 
diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index c046d6465..057adceda 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -374,7 +374,7 @@ class Index(IndexOpsMixin, PandasObject):
                 return UInt64Index(data, copy=copy, dtype=dtype, name=name)
             elif is_float_dtype(data.dtype):
                 return Float64Index(data, copy=copy, dtype=dtype, name=name)
-            elif issubclass(data.dtype.type, np.bool) or is_bool_dtype(data):
+            elif issubclass(data.dtype.type, bool) or is_bool_dtype(data):
                 subarr = data.astype("object")
             else:
                 subarr = com.asarray_tuplesafe(data, dtype=object)
diff --git a/pandas/core/internals/managers.py b/pandas/core/internals/managers.py
index e496694ee..eaf590512 100644
--- a/pandas/core/internals/managers.py
+++ b/pandas/core/internals/managers.py
@@ -1951,7 +1951,7 @@ def _compare_or_regex_search(
     if isinstance(result, np.ndarray):
         # The shape of the mask can differ to that of the result
         # since we may compare only a subset of a's or b's elements
-        tmp = np.zeros(mask.shape, dtype=np.bool)
+        tmp = np.zeros(mask.shape, dtype=np.bool_)
         tmp[mask] = result
         result = tmp
 
diff --git a/pandas/core/util/hashing.py b/pandas/core/util/hashing.py
index 1d6e02254..1b56b6d5a 100644
--- a/pandas/core/util/hashing.py
+++ b/pandas/core/util/hashing.py
@@ -264,7 +264,7 @@ def hash_array(
 
     # First, turn whatever array this is into unsigned 64-bit ints, if we can
     # manage it.
-    elif isinstance(dtype, np.bool):
+    elif isinstance(dtype, bool):
         vals = vals.astype("u8")
     elif issubclass(dtype.type, (np.datetime64, np.timedelta64)):
         vals = vals.view("i8").astype("u8", copy=False)
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index c54e264fa..679cf4c2d 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -3476,13 +3476,13 @@ def _get_empty_meta(columns, index_col, index_names, dtype=None):
     # This will enable us to write `dtype[col_name]`
     # without worrying about KeyError issues later on.
     if not isinstance(dtype, dict):
-        # if dtype == None, default will be np.object.
-        default_dtype = dtype or np.object
+        # if dtype == None, default will be object.
+        default_dtype = dtype or object
         dtype = defaultdict(lambda: default_dtype)
     else:
         # Save a copy of the dictionary.
         _dtype = dtype.copy()
-        dtype = defaultdict(lambda: np.object)
+        dtype = defaultdict(lambda: object)
 
         # Convert column indexes to column names.
         for k, v in _dtype.items():
diff --git a/pandas/io/sas/sas7bdat.py b/pandas/io/sas/sas7bdat.py
index c8f1336bc..3d9be7c15 100644
--- a/pandas/io/sas/sas7bdat.py
+++ b/pandas/io/sas/sas7bdat.py
@@ -685,7 +685,7 @@ class SAS7BDATReader(ReaderBase, abc.Iterator):
         nd = self._column_types.count(b"d")
         ns = self._column_types.count(b"s")
 
-        self._string_chunk = np.empty((ns, nrows), dtype=np.object)
+        self._string_chunk = np.empty((ns, nrows), dtype=object)
         self._byte_chunk = np.zeros((nd, 8 * nrows), dtype=np.uint8)
 
         self._current_row_in_chunk_index = 0
diff --git a/pandas/io/stata.py b/pandas/io/stata.py
index e9adf5292..7677d8a94 100644
--- a/pandas/io/stata.py
+++ b/pandas/io/stata.py
@@ -322,7 +322,7 @@ def _stata_elapsed_date_to_datetime_vec(dates, fmt) -> Series:
     elif fmt.startswith(("%tC", "tC")):
 
         warnings.warn("Encountered %tC format. Leaving in Stata Internal Format.")
-        conv_dates = Series(dates, dtype=np.object)
+        conv_dates = Series(dates, dtype=object)
         if has_bad_values:
             conv_dates[bad_locs] = NaT
         return conv_dates
@@ -451,7 +451,7 @@ def _datetime_to_stata_elapsed_vec(dates: Series, fmt: str) -> Series:
         conv_dates = 4 * (d.year - stata_epoch.year) + (d.month - 1) // 3
     elif fmt in ["%th", "th"]:
         d = parse_dates_safe(dates, year=True)
-        conv_dates = 2 * (d.year - stata_epoch.year) + (d.month > 6).astype(np.int)
+        conv_dates = 2 * (d.year - stata_epoch.year) + (d.month > 6).astype(int)
     elif fmt in ["%ty", "ty"]:
         d = parse_dates_safe(dates, year=True)
         conv_dates = d.year
@@ -553,7 +553,7 @@ def _cast_to_stata_types(data: DataFrame) -> DataFrame:
     ws = ""
     #                  original, if small, if large
     conversion_data = (
-        (np.bool, np.int8, np.int8),
+        (np.bool_, np.int8, np.int8),
         (np.uint8, np.int8, np.int16),
         (np.uint16, np.int16, np.int32),
         (np.uint32, np.int32, np.int64),
@@ -1725,7 +1725,7 @@ the string values returned are correct."""
             if convert_missing:  # Replacement follows Stata notation
                 missing_loc = np.nonzero(np.asarray(missing))[0]
                 umissing, umissing_loc = np.unique(series[missing], return_inverse=True)
-                replacement = Series(series, dtype=np.object)
+                replacement = Series(series, dtype=object)
                 for j, um in enumerate(umissing):
                     missing_value = StataMissingValue(um)
 
diff --git a/pandas/plotting/_matplotlib/tools.py b/pandas/plotting/_matplotlib/tools.py
index ef8376bfe..caf2f27de 100644
--- a/pandas/plotting/_matplotlib/tools.py
+++ b/pandas/plotting/_matplotlib/tools.py
@@ -301,7 +301,7 @@ def _handle_shared_axes(axarr, nplots, naxes, nrows, ncols, sharex, sharey):
             try:
                 # first find out the ax layout,
                 # so that we can correctly handle 'gaps"
-                layout = np.zeros((nrows + 1, ncols + 1), dtype=np.bool)
+                layout = np.zeros((nrows + 1, ncols + 1), dtype=np.bool_)
                 for ax in axarr:
                     layout[row_num(ax), col_num(ax)] = ax.get_visible()
 
diff --git a/pandas/tests/arithmetic/test_period.py b/pandas/tests/arithmetic/test_period.py
index ccd03e841..6c7b989bb 100644
--- a/pandas/tests/arithmetic/test_period.py
+++ b/pandas/tests/arithmetic/test_period.py
@@ -457,27 +457,27 @@ class TestPeriodIndexSeriesComparisonConsistency:
         )
 
         f = lambda x: x == pd.Period("2011-03", freq="M")
-        exp = np.array([False, False, True, False], dtype=np.bool)
+        exp = np.array([False, False, True, False], dtype=np.bool_)
         self._check(idx, f, exp)
         f = lambda x: pd.Period("2011-03", freq="M") == x
         self._check(idx, f, exp)
 
         f = lambda x: x != pd.Period("2011-03", freq="M")
-        exp = np.array([True, True, False, True], dtype=np.bool)
+        exp = np.array([True, True, False, True], dtype=np.bool_)
         self._check(idx, f, exp)
         f = lambda x: pd.Period("2011-03", freq="M") != x
         self._check(idx, f, exp)
 
         f = lambda x: pd.Period("2011-03", freq="M") >= x
-        exp = np.array([True, True, True, False], dtype=np.bool)
+        exp = np.array([True, True, True, False], dtype=np.bool_)
         self._check(idx, f, exp)
 
         f = lambda x: x > pd.Period("2011-03", freq="M")
-        exp = np.array([False, False, False, True], dtype=np.bool)
+        exp = np.array([False, False, False, True], dtype=np.bool_)
         self._check(idx, f, exp)
 
         f = lambda x: pd.Period("2011-03", freq="M") >= x
-        exp = np.array([True, True, True, False], dtype=np.bool)
+        exp = np.array([True, True, True, False], dtype=np.bool_)
         self._check(idx, f, exp)
 
     def test_pi_comp_period_nat(self):
@@ -486,43 +486,43 @@ class TestPeriodIndexSeriesComparisonConsistency:
         )
 
         f = lambda x: x == pd.Period("2011-03", freq="M")
-        exp = np.array([False, False, True, False], dtype=np.bool)
+        exp = np.array([False, False, True, False], dtype=np.bool_)
         self._check(idx, f, exp)
         f = lambda x: pd.Period("2011-03", freq="M") == x
         self._check(idx, f, exp)
 
         f = lambda x: x == pd.NaT
-        exp = np.array([False, False, False, False], dtype=np.bool)
+        exp = np.array([False, False, False, False], dtype=np.bool_)
         self._check(idx, f, exp)
         f = lambda x: pd.NaT == x
         self._check(idx, f, exp)
 
         f = lambda x: x != pd.Period("2011-03", freq="M")
-        exp = np.array([True, True, False, True], dtype=np.bool)
+        exp = np.array([True, True, False, True], dtype=np.bool_)
         self._check(idx, f, exp)
         f = lambda x: pd.Period("2011-03", freq="M") != x
         self._check(idx, f, exp)
 
         f = lambda x: x != pd.NaT
-        exp = np.array([True, True, True, True], dtype=np.bool)
+        exp = np.array([True, True, True, True], dtype=np.bool_)
         self._check(idx, f, exp)
         f = lambda x: pd.NaT != x
         self._check(idx, f, exp)
 
         f = lambda x: pd.Period("2011-03", freq="M") >= x
-        exp = np.array([True, False, True, False], dtype=np.bool)
+        exp = np.array([True, False, True, False], dtype=np.bool_)
         self._check(idx, f, exp)
 
         f = lambda x: x < pd.Period("2011-03", freq="M")
-        exp = np.array([True, False, False, False], dtype=np.bool)
+        exp = np.array([True, False, False, False], dtype=np.bool_)
         self._check(idx, f, exp)
 
         f = lambda x: x > pd.NaT
-        exp = np.array([False, False, False, False], dtype=np.bool)
+        exp = np.array([False, False, False, False], dtype=np.bool_)
         self._check(idx, f, exp)
 
         f = lambda x: pd.NaT >= x
-        exp = np.array([False, False, False, False], dtype=np.bool)
+        exp = np.array([False, False, False, False], dtype=np.bool_)
         self._check(idx, f, exp)
 
 
diff --git a/pandas/tests/arrays/boolean/test_logical.py b/pandas/tests/arrays/boolean/test_logical.py
index bf4775bbd..e79262e1b 100644
--- a/pandas/tests/arrays/boolean/test_logical.py
+++ b/pandas/tests/arrays/boolean/test_logical.py
@@ -14,8 +14,8 @@ class TestLogicalOps(BaseOpsUtil):
         a = pd.array([True, False, None], dtype="boolean")
         op = getattr(a, all_logical_operators)
 
-        tm.assert_extension_array_equal(op(True), op(np.bool(True)))
-        tm.assert_extension_array_equal(op(False), op(np.bool(False)))
+        tm.assert_extension_array_equal(op(True), op(np.bool_(True)))
+        tm.assert_extension_array_equal(op(False), op(np.bool_(False)))
 
     def get_op_from_name(self, op_name):
         short_opname = op_name.strip("_")
diff --git a/pandas/tests/arrays/categorical/test_dtypes.py b/pandas/tests/arrays/categorical/test_dtypes.py
index 9922a8863..47ce9cb40 100644
--- a/pandas/tests/arrays/categorical/test_dtypes.py
+++ b/pandas/tests/arrays/categorical/test_dtypes.py
@@ -127,11 +127,11 @@ class TestCategoricalDtypes:
         tm.assert_numpy_array_equal(result, expected)
 
         result = cat.astype(int)
-        expected = np.array(cat, dtype=np.int)
+        expected = np.array(cat, dtype=int)
         tm.assert_numpy_array_equal(result, expected)
 
         result = cat.astype(float)
-        expected = np.array(cat, dtype=np.float)
+        expected = np.array(cat, dtype=float)
         tm.assert_numpy_array_equal(result, expected)
 
     @pytest.mark.parametrize("dtype_ordered", [True, False])
diff --git a/pandas/tests/arrays/sparse/test_arithmetics.py b/pandas/tests/arrays/sparse/test_arithmetics.py
index 4ae1c1e6b..c9f1dd7f5 100644
--- a/pandas/tests/arrays/sparse/test_arithmetics.py
+++ b/pandas/tests/arrays/sparse/test_arithmetics.py
@@ -53,7 +53,7 @@ class TestSparseArrayArithmetics:
     def _check_bool_result(self, res):
         assert isinstance(res, self._klass)
         assert isinstance(res.dtype, SparseDtype)
-        assert res.dtype.subtype == np.bool
+        assert res.dtype.subtype == np.bool_
         assert isinstance(res.fill_value, bool)
 
     def _check_comparison_ops(self, a, b, a_dense, b_dense):
@@ -306,22 +306,22 @@ class TestSparseArrayArithmetics:
     def test_bool_same_index(self, kind, fill_value):
         # GH 14000
         # when sp_index are the same
-        values = self._base([True, False, True, True], dtype=np.bool)
-        rvalues = self._base([True, False, True, True], dtype=np.bool)
+        values = self._base([True, False, True, True], dtype=np.bool_)
+        rvalues = self._base([True, False, True, True], dtype=np.bool_)
 
-        a = self._klass(values, kind=kind, dtype=np.bool, fill_value=fill_value)
-        b = self._klass(rvalues, kind=kind, dtype=np.bool, fill_value=fill_value)
+        a = self._klass(values, kind=kind, dtype=np.bool_, fill_value=fill_value)
+        b = self._klass(rvalues, kind=kind, dtype=np.bool_, fill_value=fill_value)
         self._check_logical_ops(a, b, values, rvalues)
 
     @pytest.mark.parametrize("fill_value", [True, False, np.nan])
     def test_bool_array_logical(self, kind, fill_value):
         # GH 14000
         # when sp_index are the same
-        values = self._base([True, False, True, False, True, True], dtype=np.bool)
-        rvalues = self._base([True, False, False, True, False, True], dtype=np.bool)
+        values = self._base([True, False, True, False, True, True], dtype=np.bool_)
+        rvalues = self._base([True, False, False, True, False, True], dtype=np.bool_)
 
-        a = self._klass(values, kind=kind, dtype=np.bool, fill_value=fill_value)
-        b = self._klass(rvalues, kind=kind, dtype=np.bool, fill_value=fill_value)
+        a = self._klass(values, kind=kind, dtype=np.bool_, fill_value=fill_value)
+        b = self._klass(rvalues, kind=kind, dtype=np.bool_, fill_value=fill_value)
         self._check_logical_ops(a, b, values, rvalues)
 
     def test_mixed_array_float_int(self, kind, mix, all_arithmetic_functions):
diff --git a/pandas/tests/arrays/sparse/test_array.py b/pandas/tests/arrays/sparse/test_array.py
index 8450253f8..2f2907fba 100644
--- a/pandas/tests/arrays/sparse/test_array.py
+++ b/pandas/tests/arrays/sparse/test_array.py
@@ -74,22 +74,22 @@ class TestSparseArray:
 
     def test_constructor_object_dtype(self):
         # GH 11856
-        arr = SparseArray(["A", "A", np.nan, "B"], dtype=np.object)
-        assert arr.dtype == SparseDtype(np.object)
+        arr = SparseArray(["A", "A", np.nan, "B"], dtype=object)
+        assert arr.dtype == SparseDtype(object)
         assert np.isnan(arr.fill_value)
 
-        arr = SparseArray(["A", "A", np.nan, "B"], dtype=np.object, fill_value="A")
-        assert arr.dtype == SparseDtype(np.object, "A")
+        arr = SparseArray(["A", "A", np.nan, "B"], dtype=object, fill_value="A")
+        assert arr.dtype == SparseDtype(object, "A")
         assert arr.fill_value == "A"
 
         # GH 17574
         data = [False, 0, 100.0, 0.0]
-        arr = SparseArray(data, dtype=np.object, fill_value=False)
-        assert arr.dtype == SparseDtype(np.object, False)
+        arr = SparseArray(data, dtype=object, fill_value=False)
+        assert arr.dtype == SparseDtype(object, False)
         assert arr.fill_value is False
-        arr_expected = np.array(data, dtype=np.object)
+        arr_expected = np.array(data, dtype=object)
         it = (type(x) == type(y) and x == y for x, y in zip(arr, arr_expected))
-        assert np.fromiter(it, dtype=np.bool).all()
+        assert np.fromiter(it, dtype=np.bool_).all()
 
     @pytest.mark.parametrize("dtype", [SparseDtype(int, 0), int])
     def test_constructor_na_dtype(self, dtype):
@@ -445,15 +445,15 @@ class TestSparseArray:
 
     def test_constructor_bool_fill_value(self):
         arr = SparseArray([True, False, True], dtype=None)
-        assert arr.dtype == SparseDtype(np.bool)
+        assert arr.dtype == SparseDtype(np.bool_)
         assert not arr.fill_value
 
-        arr = SparseArray([True, False, True], dtype=np.bool)
-        assert arr.dtype == SparseDtype(np.bool)
+        arr = SparseArray([True, False, True], dtype=np.bool_)
+        assert arr.dtype == SparseDtype(np.bool_)
         assert not arr.fill_value
 
-        arr = SparseArray([True, False, True], dtype=np.bool, fill_value=True)
-        assert arr.dtype == SparseDtype(np.bool, True)
+        arr = SparseArray([True, False, True], dtype=np.bool_, fill_value=True)
+        assert arr.dtype == SparseDtype(np.bool_, True)
         assert arr.fill_value
 
     def test_constructor_float32(self):
@@ -588,7 +588,7 @@ class TestSparseArray:
         arr.fill_value = np.nan
         assert np.isnan(arr.fill_value)
 
-        arr = SparseArray([True, False, True], fill_value=False, dtype=np.bool)
+        arr = SparseArray([True, False, True], fill_value=False, dtype=np.bool_)
         arr.fill_value = True
         assert arr.fill_value
 
@@ -605,7 +605,7 @@ class TestSparseArray:
 
     @pytest.mark.parametrize("val", [[1, 2, 3], np.array([1, 2]), (1, 2, 3)])
     def test_set_fill_invalid_non_scalar(self, val):
-        arr = SparseArray([True, False, True], fill_value=False, dtype=np.bool)
+        arr = SparseArray([True, False, True], fill_value=False, dtype=np.bool_)
         msg = "fill_value must be a scalar"
 
         with pytest.raises(ValueError, match=msg):
@@ -625,7 +625,7 @@ class TestSparseArray:
             ([0, 0, 0, 0, 0], (5,), None),
             ([], (0,), None),
             ([0], (1,), None),
-            (["A", "A", np.nan, "B"], (4,), np.object),
+            (["A", "A", np.nan, "B"], (4,), object),
         ],
     )
     def test_shape(self, data, shape, dtype):
diff --git a/pandas/tests/dtypes/cast/test_find_common_type.py b/pandas/tests/dtypes/cast/test_find_common_type.py
index ac7a5221d..8dac92f46 100644
--- a/pandas/tests/dtypes/cast/test_find_common_type.py
+++ b/pandas/tests/dtypes/cast/test_find_common_type.py
@@ -11,7 +11,7 @@ from pandas.core.dtypes.dtypes import CategoricalDtype, DatetimeTZDtype, PeriodD
         ((np.int64,), np.int64),
         ((np.uint64,), np.uint64),
         ((np.float32,), np.float32),
-        ((np.object,), np.object),
+        ((object,), object),
         # Into ints.
         ((np.int16, np.int64), np.int64),
         ((np.int32, np.uint32), np.int64),
@@ -25,20 +25,20 @@ from pandas.core.dtypes.dtypes import CategoricalDtype, DatetimeTZDtype, PeriodD
         ((np.float16, np.int64), np.float64),
         # Into others.
         ((np.complex128, np.int32), np.complex128),
-        ((np.object, np.float32), np.object),
-        ((np.object, np.int16), np.object),
+        ((object, np.float32), object),
+        ((object, np.int16), object),
         # Bool with int.
-        ((np.dtype("bool"), np.int64), np.object),
-        ((np.dtype("bool"), np.int32), np.object),
-        ((np.dtype("bool"), np.int16), np.object),
-        ((np.dtype("bool"), np.int8), np.object),
-        ((np.dtype("bool"), np.uint64), np.object),
-        ((np.dtype("bool"), np.uint32), np.object),
-        ((np.dtype("bool"), np.uint16), np.object),
-        ((np.dtype("bool"), np.uint8), np.object),
+        ((np.dtype("bool"), np.int64), object),
+        ((np.dtype("bool"), np.int32), object),
+        ((np.dtype("bool"), np.int16), object),
+        ((np.dtype("bool"), np.int8), object),
+        ((np.dtype("bool"), np.uint64), object),
+        ((np.dtype("bool"), np.uint32), object),
+        ((np.dtype("bool"), np.uint16), object),
+        ((np.dtype("bool"), np.uint8), object),
         # Bool with float.
-        ((np.dtype("bool"), np.float64), np.object),
-        ((np.dtype("bool"), np.float32), np.object),
+        ((np.dtype("bool"), np.float64), object),
+        ((np.dtype("bool"), np.float32), object),
         (
             (np.dtype("datetime64[ns]"), np.dtype("datetime64[ns]")),
             np.dtype("datetime64[ns]"),
@@ -55,8 +55,8 @@ from pandas.core.dtypes.dtypes import CategoricalDtype, DatetimeTZDtype, PeriodD
             (np.dtype("timedelta64[ms]"), np.dtype("timedelta64[ns]")),
             np.dtype("timedelta64[ns]"),
         ),
-        ((np.dtype("datetime64[ns]"), np.dtype("timedelta64[ns]")), np.object),
-        ((np.dtype("datetime64[ns]"), np.int64), np.object),
+        ((np.dtype("datetime64[ns]"), np.dtype("timedelta64[ns]")), object),
+        ((np.dtype("datetime64[ns]"), np.int64), object),
     ],
 )
 def test_numpy_dtypes(source_dtypes, expected_common_dtype):
@@ -72,7 +72,7 @@ def test_raises_empty_input():
     "dtypes,exp_type",
     [
         ([CategoricalDtype()], "category"),
-        ([np.object, CategoricalDtype()], np.object),
+        ([object, CategoricalDtype()], object),
         ([CategoricalDtype(), CategoricalDtype()], "category"),
     ],
 )
@@ -90,14 +90,14 @@ def test_datetimetz_dtype_match():
     [
         DatetimeTZDtype(unit="ns", tz="Asia/Tokyo"),
         np.dtype("datetime64[ns]"),
-        np.object,
+        object,
         np.int64,
     ],
 )
 def test_datetimetz_dtype_mismatch(dtype2):
     dtype = DatetimeTZDtype(unit="ns", tz="US/Eastern")
-    assert find_common_type([dtype, dtype2]) == np.object
-    assert find_common_type([dtype2, dtype]) == np.object
+    assert find_common_type([dtype, dtype2]) == object
+    assert find_common_type([dtype2, dtype]) == object
 
 
 def test_period_dtype_match():
@@ -112,11 +112,11 @@ def test_period_dtype_match():
         PeriodDtype(freq="2D"),
         PeriodDtype(freq="H"),
         np.dtype("datetime64[ns]"),
-        np.object,
+        object,
         np.int64,
     ],
 )
 def test_period_dtype_mismatch(dtype2):
     dtype = PeriodDtype(freq="D")
-    assert find_common_type([dtype, dtype2]) == np.object
-    assert find_common_type([dtype2, dtype]) == np.object
+    assert find_common_type([dtype, dtype2]) == object
+    assert find_common_type([dtype2, dtype]) == object
diff --git a/pandas/tests/dtypes/cast/test_infer_dtype.py b/pandas/tests/dtypes/cast/test_infer_dtype.py
index 2744cfa8d..70d38aad9 100644
--- a/pandas/tests/dtypes/cast/test_infer_dtype.py
+++ b/pandas/tests/dtypes/cast/test_infer_dtype.py
@@ -43,7 +43,9 @@ def test_infer_dtype_from_float_scalar(float_dtype):
     assert dtype == float_dtype
 
 
-@pytest.mark.parametrize("data,exp_dtype", [(12, np.int64), (np.float(12), np.float64)])
+@pytest.mark.parametrize(
+    "data,exp_dtype", [(12, np.int64), (np.float_(12), np.float64)]
+)
 def test_infer_dtype_from_python_scalar(data, exp_dtype):
     dtype, val = infer_dtype_from_scalar(data)
     assert dtype == exp_dtype
@@ -184,8 +186,8 @@ def test_infer_dtype_from_array(arr, expected, pandas_dtype):
         (1, np.int64),
         (1.1, np.float64),
         (Timestamp("2011-01-01"), "datetime64[ns]"),
-        (Timestamp("2011-01-01", tz="US/Eastern"), np.object),
-        (Period("2011-01-01", freq="D"), np.object),
+        (Timestamp("2011-01-01", tz="US/Eastern"), object),
+        (Period("2011-01-01", freq="D"), object),
     ],
 )
 def test_cast_scalar_to_array(obj, dtype):
diff --git a/pandas/tests/dtypes/test_common.py b/pandas/tests/dtypes/test_common.py
index 1708139a3..ce12718e4 100644
--- a/pandas/tests/dtypes/test_common.py
+++ b/pandas/tests/dtypes/test_common.py
@@ -112,7 +112,7 @@ dtypes = dict(
     period=PeriodDtype("D"),
     integer=np.dtype(np.int64),
     float=np.dtype(np.float64),
-    object=np.dtype(np.object),
+    object=np.dtype(object),
     category=com.pandas_dtype("category"),
 )
 
@@ -547,7 +547,7 @@ def test_is_bool_dtype():
     assert not com.is_bool_dtype(pd.Index(["a", "b"]))
 
     assert com.is_bool_dtype(bool)
-    assert com.is_bool_dtype(np.bool)
+    assert com.is_bool_dtype(np.bool_)
     assert com.is_bool_dtype(np.array([True, False]))
     assert com.is_bool_dtype(pd.Index([True, False]))
 
@@ -615,7 +615,8 @@ def test_is_complex_dtype():
     assert not com.is_complex_dtype(pd.Series([1, 2]))
     assert not com.is_complex_dtype(np.array(["a", "b"]))
 
-    assert com.is_complex_dtype(np.complex)
+    assert com.is_complex_dtype(np.complex_)
+    assert com.is_complex_dtype(complex)
     assert com.is_complex_dtype(np.array([1 + 1j, 5]))
 
 
diff --git a/pandas/tests/dtypes/test_dtypes.py b/pandas/tests/dtypes/test_dtypes.py
index 3b9d3dc0b..b1fe673e9 100644
--- a/pandas/tests/dtypes/test_dtypes.py
+++ b/pandas/tests/dtypes/test_dtypes.py
@@ -951,7 +951,7 @@ def test_registry_find(dtype, expected):
         (str, False),
         (int, False),
         (bool, True),
-        (np.bool, True),
+        (np.bool_, True),
         (np.array(["a", "b"]), False),
         (pd.Series([1, 2]), False),
         (np.array([True, False]), True),
diff --git a/pandas/tests/dtypes/test_inference.py b/pandas/tests/dtypes/test_inference.py
index e97716f7a..e40a12f7b 100644
--- a/pandas/tests/dtypes/test_inference.py
+++ b/pandas/tests/dtypes/test_inference.py
@@ -1246,7 +1246,6 @@ class TestNumberScalar:
         assert is_number(1)
         assert is_number(1.1)
         assert is_number(1 + 3j)
-        assert is_number(np.bool(False))
         assert is_number(np.int64(1))
         assert is_number(np.float64(1.1))
         assert is_number(np.complex128(1 + 3j))
@@ -1267,7 +1266,7 @@ class TestNumberScalar:
 
     def test_is_bool(self):
         assert is_bool(True)
-        assert is_bool(np.bool(False))
+        assert is_bool(False)
         assert is_bool(np.bool_(False))
 
         assert not is_bool(1)
@@ -1294,7 +1293,7 @@ class TestNumberScalar:
         assert not is_integer(True)
         assert not is_integer(1.1)
         assert not is_integer(1 + 3j)
-        assert not is_integer(np.bool(False))
+        assert not is_integer(False)
         assert not is_integer(np.bool_(False))
         assert not is_integer(np.float64(1.1))
         assert not is_integer(np.complex128(1 + 3j))
@@ -1317,7 +1316,7 @@ class TestNumberScalar:
         assert not is_float(True)
         assert not is_float(1)
         assert not is_float(1 + 3j)
-        assert not is_float(np.bool(False))
+        assert not is_float(False)
         assert not is_float(np.bool_(False))
         assert not is_float(np.int64(1))
         assert not is_float(np.complex128(1 + 3j))
diff --git a/pandas/tests/extension/base/setitem.py b/pandas/tests/extension/base/setitem.py
index eed9a584c..bfa53ad02 100644
--- a/pandas/tests/extension/base/setitem.py
+++ b/pandas/tests/extension/base/setitem.py
@@ -319,13 +319,13 @@ class BaseSetitemTests(BaseExtensionTests):
     def test_setitem_series_with_index(self, data):
         # https://github.com/pandas-dev/pandas/issues/32395
         ser = expected = pd.Series(data, name="data")
-        result = pd.Series(index=ser.index, dtype=np.object, name="data")
+        result = pd.Series(index=ser.index, dtype=object, name="data")
         result.loc[ser.index] = ser
         self.assert_series_equal(result, expected)
 
     def test_setitem_series_without_index(self, data):
         # https://github.com/pandas-dev/pandas/issues/32395
         ser = expected = pd.Series(data, name="data")
-        result = pd.Series(index=ser.index, dtype=np.object, name="data")
+        result = pd.Series(index=ser.index, dtype=object, name="data")
         result.loc[:] = ser
         self.assert_series_equal(result, expected)
diff --git a/pandas/tests/frame/methods/test_duplicated.py b/pandas/tests/frame/methods/test_duplicated.py
index 82fd6d88b..7a1c16adc 100644
--- a/pandas/tests/frame/methods/test_duplicated.py
+++ b/pandas/tests/frame/methods/test_duplicated.py
@@ -30,7 +30,7 @@ def test_duplicated_do_not_fail_on_wide_dataframes():
     # calculation. Actual values doesn't matter here, though usually it's all
     # False in this case
     assert isinstance(result, Series)
-    assert result.dtype == np.bool
+    assert result.dtype == np.bool_
 
 
 @pytest.mark.parametrize(
diff --git a/pandas/tests/frame/methods/test_isin.py b/pandas/tests/frame/methods/test_isin.py
index 630773802..79ea70a38 100644
--- a/pandas/tests/frame/methods/test_isin.py
+++ b/pandas/tests/frame/methods/test_isin.py
@@ -164,7 +164,7 @@ class TestDataFrameIsIn:
         tm.assert_frame_equal(result, expected)
 
         df2.index = idx
-        expected = df2.values.astype(np.bool)
+        expected = df2.values.astype(bool)
         expected[:, 1] = ~expected[:, 1]
         expected = DataFrame(expected, columns=["A", "B"], index=idx)
 
diff --git a/pandas/tests/frame/methods/test_to_records.py b/pandas/tests/frame/methods/test_to_records.py
index 34b323e55..d9c999c91 100644
--- a/pandas/tests/frame/methods/test_to_records.py
+++ b/pandas/tests/frame/methods/test_to_records.py
@@ -163,7 +163,7 @@ class TestDataFrameToRecords:
             ),
             # Pass in a type instance.
             (
-                dict(column_dtypes=np.unicode),
+                dict(column_dtypes=str),
                 np.rec.array(
                     [("0", "1", "0.2", "a"), ("1", "2", "1.5", "bc")],
                     dtype=[("index", "<i8"), ("A", "<U"), ("B", "<U"), ("C", "<U")],
diff --git a/pandas/tests/frame/test_analytics.py b/pandas/tests/frame/test_analytics.py
index b4842e8d5..db21161f8 100644
--- a/pandas/tests/frame/test_analytics.py
+++ b/pandas/tests/frame/test_analytics.py
@@ -1021,7 +1021,7 @@ class TestDataFrameAnalytics:
         )
 
         result = df.all(bool_only=True)
-        expected = Series(dtype=np.bool)
+        expected = Series(dtype=np.bool_)
         tm.assert_series_equal(result, expected)
 
         df = DataFrame(
diff --git a/pandas/tests/frame/test_dtypes.py b/pandas/tests/frame/test_dtypes.py
index 9d0c22192..9c415564f 100644
--- a/pandas/tests/frame/test_dtypes.py
+++ b/pandas/tests/frame/test_dtypes.py
@@ -37,15 +37,13 @@ class TestDataFrameDataTypes:
 
     def test_empty_frame_dtypes(self):
         empty_df = pd.DataFrame()
-        tm.assert_series_equal(empty_df.dtypes, pd.Series(dtype=np.object))
+        tm.assert_series_equal(empty_df.dtypes, pd.Series(dtype=object))
 
         nocols_df = pd.DataFrame(index=[1, 2, 3])
-        tm.assert_series_equal(nocols_df.dtypes, pd.Series(dtype=np.object))
+        tm.assert_series_equal(nocols_df.dtypes, pd.Series(dtype=object))
 
         norows_df = pd.DataFrame(columns=list("abc"))
-        tm.assert_series_equal(
-            norows_df.dtypes, pd.Series(np.object, index=list("abc"))
-        )
+        tm.assert_series_equal(norows_df.dtypes, pd.Series(object, index=list("abc")))
 
         norows_int_df = pd.DataFrame(columns=list("abc")).astype(np.int32)
         tm.assert_series_equal(
@@ -55,7 +53,7 @@ class TestDataFrameDataTypes:
         odict = OrderedDict
         df = pd.DataFrame(odict([("a", 1), ("b", True), ("c", 1.0)]), index=[1, 2, 3])
         ex_dtypes = pd.Series(
-            odict([("a", np.int64), ("b", np.bool), ("c", np.float64)])
+            odict([("a", np.int64), ("b", np.bool_), ("c", np.float64)])
         )
         tm.assert_series_equal(df.dtypes, ex_dtypes)
 
diff --git a/pandas/tests/frame/test_reshape.py b/pandas/tests/frame/test_reshape.py
index a6c4089dc..1634baacf 100644
--- a/pandas/tests/frame/test_reshape.py
+++ b/pandas/tests/frame/test_reshape.py
@@ -171,7 +171,7 @@ class TestDataFrameReshape:
         # From a series with incorrect data type for fill_value
         result = data.unstack(fill_value=0.5)
         expected = DataFrame(
-            {"a": [1, 0.5, 5], "b": [2, 4, 0.5]}, index=["x", "y", "z"], dtype=np.float
+            {"a": [1, 0.5, 5], "b": [2, 4, 0.5]}, index=["x", "y", "z"], dtype=float
         )
         tm.assert_frame_equal(result, expected)
 
@@ -229,7 +229,7 @@ class TestDataFrameReshape:
         result = df.unstack(fill_value=0.5)
 
         rows = [[1, 3, 2, 4], [0.5, 5, 0.5, 6], [7, 0.5, 8, 0.5]]
-        expected = DataFrame(rows, index=list("xyz"), dtype=np.float)
+        expected = DataFrame(rows, index=list("xyz"), dtype=float)
         expected.columns = MultiIndex.from_tuples(
             [("A", "a"), ("A", "b"), ("B", "a"), ("B", "b")]
         )
diff --git a/pandas/tests/frame/test_to_csv.py b/pandas/tests/frame/test_to_csv.py
index 9c656dd69..2b7b3af8f 100644
--- a/pandas/tests/frame/test_to_csv.py
+++ b/pandas/tests/frame/test_to_csv.py
@@ -771,8 +771,8 @@ class TestDataFrameToCSV:
         for n, dtype in [
             ("float", np.float64),
             ("int", np.int64),
-            ("bool", np.bool),
-            ("object", np.object),
+            ("bool", np.bool_),
+            ("object", object),
         ]:
             for c in create_cols(n):
                 dtypes[c] = dtype
diff --git a/pandas/tests/generic/test_finalize.py b/pandas/tests/generic/test_finalize.py
index a152bc203..4d0f1a326 100644
--- a/pandas/tests/generic/test_finalize.py
+++ b/pandas/tests/generic/test_finalize.py
@@ -700,8 +700,6 @@ def test_datetime_method(method):
         "second",
         "microsecond",
         "nanosecond",
-        "week",
-        "weekofyear",
         "dayofweek",
         "dayofyear",
         "quarter",
diff --git a/pandas/tests/groupby/aggregate/test_aggregate.py b/pandas/tests/groupby/aggregate/test_aggregate.py
index 1b726860e..96db51957 100644
--- a/pandas/tests/groupby/aggregate/test_aggregate.py
+++ b/pandas/tests/groupby/aggregate/test_aggregate.py
@@ -232,7 +232,7 @@ def test_wrap_agg_out(three_group):
     grouped = three_group.groupby(["A", "B"])
 
     def func(ser):
-        if ser.dtype == np.object:
+        if ser.dtype == object:
             raise TypeError
         else:
             return ser.sum()
diff --git a/pandas/tests/groupby/test_apply.py b/pandas/tests/groupby/test_apply.py
index 8468a2190..d03b03b3f 100644
--- a/pandas/tests/groupby/test_apply.py
+++ b/pandas/tests/groupby/test_apply.py
@@ -868,7 +868,7 @@ def test_groupby_apply_datetime_result_dtypes():
     )
     result = data.groupby("color").apply(lambda g: g.iloc[0]).dtypes
     expected = Series(
-        [np.dtype("datetime64[ns]"), np.object, np.object, np.int64, np.object],
+        [np.dtype("datetime64[ns]"), object, object, np.int64, object],
         index=["observation", "color", "mood", "intensity", "score"],
     )
     tm.assert_series_equal(result, expected)
diff --git a/pandas/tests/indexes/categorical/test_category.py b/pandas/tests/indexes/categorical/test_category.py
index 8a84090ea..7a1ccba08 100644
--- a/pandas/tests/indexes/categorical/test_category.py
+++ b/pandas/tests/indexes/categorical/test_category.py
@@ -270,9 +270,9 @@ class TestCategoricalIndex(Base):
                 [2, "a", "b"],
                 list("abc"),
                 {
-                    "first": np.zeros(shape=(3), dtype=np.bool),
-                    "last": np.zeros(shape=(3), dtype=np.bool),
-                    False: np.zeros(shape=(3), dtype=np.bool),
+                    "first": np.zeros(shape=(3), dtype=np.bool_),
+                    "last": np.zeros(shape=(3), dtype=np.bool_),
+                    False: np.zeros(shape=(3), dtype=np.bool_),
                 },
             ),
             (
diff --git a/pandas/tests/indexes/common.py b/pandas/tests/indexes/common.py
index 37ff97f02..ae297bf10 100644
--- a/pandas/tests/indexes/common.py
+++ b/pandas/tests/indexes/common.py
@@ -795,10 +795,10 @@ class Base:
 
         msg = "putmask: mask and data must be the same size"
         with pytest.raises(ValueError, match=msg):
-            index.putmask(np.ones(len(index) + 1, np.bool), 1)
+            index.putmask(np.ones(len(index) + 1, np.bool_), 1)
 
         with pytest.raises(ValueError, match=msg):
-            index.putmask(np.ones(len(index) - 1, np.bool), 1)
+            index.putmask(np.ones(len(index) - 1, np.bool_), 1)
 
         with pytest.raises(ValueError, match=msg):
             index.putmask("foo", 1)
diff --git a/pandas/tests/indexes/multi/test_indexing.py b/pandas/tests/indexes/multi/test_indexing.py
index 03ae2ae6a..6b27682ed 100644
--- a/pandas/tests/indexes/multi/test_indexing.py
+++ b/pandas/tests/indexes/multi/test_indexing.py
@@ -132,10 +132,10 @@ def test_putmask_with_wrong_mask(idx):
 
     msg = "putmask: mask and data must be the same size"
     with pytest.raises(ValueError, match=msg):
-        idx.putmask(np.ones(len(idx) + 1, np.bool), 1)
+        idx.putmask(np.ones(len(idx) + 1, np.bool_), 1)
 
     with pytest.raises(ValueError, match=msg):
-        idx.putmask(np.ones(len(idx) - 1, np.bool), 1)
+        idx.putmask(np.ones(len(idx) - 1, np.bool_), 1)
 
     with pytest.raises(ValueError, match=msg):
         idx.putmask("foo", 1)
diff --git a/pandas/tests/indexes/period/test_period.py b/pandas/tests/indexes/period/test_period.py
index 47617802b..8d767663f 100644
--- a/pandas/tests/indexes/period/test_period.py
+++ b/pandas/tests/indexes/period/test_period.py
@@ -121,7 +121,7 @@ class TestPeriodIndex(DatetimeLike):
     def test_values(self):
         idx = PeriodIndex([], freq="M")
 
-        exp = np.array([], dtype=np.object)
+        exp = np.array([], dtype=object)
         tm.assert_numpy_array_equal(idx.values, exp)
         tm.assert_numpy_array_equal(idx.to_numpy(), exp)
 
diff --git a/pandas/tests/indexes/test_base.py b/pandas/tests/indexes/test_base.py
index 466b491eb..f31b49ab8 100644
--- a/pandas/tests/indexes/test_base.py
+++ b/pandas/tests/indexes/test_base.py
@@ -1375,8 +1375,8 @@ class TestIndex(Base):
         # is mangled
         if unique_nulls_fixture is unique_nulls_fixture2:
             return  # skip it, values are not unique
-        arr = np.array([unique_nulls_fixture, unique_nulls_fixture2], dtype=np.object)
-        index = pd.Index(arr, dtype=np.object)
+        arr = np.array([unique_nulls_fixture, unique_nulls_fixture2], dtype=object)
+        index = pd.Index(arr, dtype=object)
         result = index.get_indexer(
             [unique_nulls_fixture, unique_nulls_fixture2, "Unknown"]
         )
diff --git a/pandas/tests/indexing/test_coercion.py b/pandas/tests/indexing/test_coercion.py
index 8c528a521..1512c88a6 100644
--- a/pandas/tests/indexing/test_coercion.py
+++ b/pandas/tests/indexing/test_coercion.py
@@ -87,19 +87,18 @@ class TestSetitemCoercion(CoercionBase):
         # tm.assert_series_equal(temp, expected_series)
 
     @pytest.mark.parametrize(
-        "val,exp_dtype",
-        [(1, np.object), (1.1, np.object), (1 + 1j, np.object), (True, np.object)],
+        "val,exp_dtype", [(1, object), (1.1, object), (1 + 1j, object), (True, object)],
     )
     def test_setitem_series_object(self, val, exp_dtype):
         obj = pd.Series(list("abcd"))
-        assert obj.dtype == np.object
+        assert obj.dtype == object
 
         exp = pd.Series(["a", val, "c", "d"])
         self._assert_setitem_series_conversion(obj, val, exp, exp_dtype)
 
     @pytest.mark.parametrize(
         "val,exp_dtype",
-        [(1, np.int64), (1.1, np.float64), (1 + 1j, np.complex128), (True, np.object)],
+        [(1, np.int64), (1.1, np.float64), (1 + 1j, np.complex128), (True, object)],
     )
     def test_setitem_series_int64(self, val, exp_dtype, request):
         obj = pd.Series([1, 2, 3, 4])
@@ -134,12 +133,7 @@ class TestSetitemCoercion(CoercionBase):
 
     @pytest.mark.parametrize(
         "val,exp_dtype",
-        [
-            (1, np.float64),
-            (1.1, np.float64),
-            (1 + 1j, np.complex128),
-            (True, np.object),
-        ],
+        [(1, np.float64), (1.1, np.float64), (1 + 1j, np.complex128), (True, object)],
     )
     def test_setitem_series_float64(self, val, exp_dtype):
         obj = pd.Series([1.1, 2.2, 3.3, 4.4])
@@ -154,7 +148,7 @@ class TestSetitemCoercion(CoercionBase):
             (1, np.complex128),
             (1.1, np.complex128),
             (1 + 1j, np.complex128),
-            (True, np.object),
+            (True, object),
         ],
     )
     def test_setitem_series_complex128(self, val, exp_dtype):
@@ -171,25 +165,25 @@ class TestSetitemCoercion(CoercionBase):
             (3, np.int64),
             (1.1, np.float64),
             (1 + 1j, np.complex128),
-            (True, np.bool),
+            (True, np.bool_),
         ],
     )
     def test_setitem_series_bool(self, val, exp_dtype, request):
         obj = pd.Series([True, False, True, False])
-        assert obj.dtype == np.bool
+        assert obj.dtype == np.bool_
 
         mark = None
         if exp_dtype is np.int64:
             exp = pd.Series([True, True, True, False])
-            self._assert_setitem_series_conversion(obj, val, exp, np.bool)
+            self._assert_setitem_series_conversion(obj, val, exp, np.bool_)
             mark = pytest.mark.xfail(reason="TODO_GH12747 The result must be int")
         elif exp_dtype is np.float64:
             exp = pd.Series([True, True, True, False])
-            self._assert_setitem_series_conversion(obj, val, exp, np.bool)
+            self._assert_setitem_series_conversion(obj, val, exp, np.bool_)
             mark = pytest.mark.xfail(reason="TODO_GH12747 The result must be float")
         elif exp_dtype is np.complex128:
             exp = pd.Series([True, True, True, False])
-            self._assert_setitem_series_conversion(obj, val, exp, np.bool)
+            self._assert_setitem_series_conversion(obj, val, exp, np.bool_)
             mark = pytest.mark.xfail(reason="TODO_GH12747 The result must be complex")
         if mark is not None:
             request.node.add_marker(mark)
@@ -199,11 +193,7 @@ class TestSetitemCoercion(CoercionBase):
 
     @pytest.mark.parametrize(
         "val,exp_dtype",
-        [
-            (pd.Timestamp("2012-01-01"), "datetime64[ns]"),
-            (1, np.object),
-            ("x", np.object),
-        ],
+        [(pd.Timestamp("2012-01-01"), "datetime64[ns]"), (1, object), ("x", object)],
     )
     def test_setitem_series_datetime64(self, val, exp_dtype):
         obj = pd.Series(
@@ -230,9 +220,9 @@ class TestSetitemCoercion(CoercionBase):
         "val,exp_dtype",
         [
             (pd.Timestamp("2012-01-01", tz="US/Eastern"), "datetime64[ns, US/Eastern]"),
-            (pd.Timestamp("2012-01-01", tz="US/Pacific"), np.object),
-            (pd.Timestamp("2012-01-01"), np.object),
-            (1, np.object),
+            (pd.Timestamp("2012-01-01", tz="US/Pacific"), object),
+            (pd.Timestamp("2012-01-01"), object),
+            (1, object),
         ],
     )
     def test_setitem_series_datetime64tz(self, val, exp_dtype):
@@ -259,7 +249,7 @@ class TestSetitemCoercion(CoercionBase):
 
     @pytest.mark.parametrize(
         "val,exp_dtype",
-        [(pd.Timedelta("12 day"), "timedelta64[ns]"), (1, np.object), ("x", np.object)],
+        [(pd.Timedelta("12 day"), "timedelta64[ns]"), (1, object), ("x", object)],
     )
     def test_setitem_series_timedelta64(self, val, exp_dtype):
         obj = pd.Series(
@@ -296,11 +286,11 @@ class TestSetitemCoercion(CoercionBase):
         assert temp.index.dtype == expected_dtype
 
     @pytest.mark.parametrize(
-        "val,exp_dtype", [("x", np.object), (5, IndexError), (1.1, np.object)]
+        "val,exp_dtype", [("x", object), (5, IndexError), (1.1, object)]
     )
     def test_setitem_index_object(self, val, exp_dtype):
         obj = pd.Series([1, 2, 3, 4], index=list("abcd"))
-        assert obj.index.dtype == np.object
+        assert obj.index.dtype == object
 
         if exp_dtype is IndexError:
             temp = obj.copy()
@@ -312,7 +302,7 @@ class TestSetitemCoercion(CoercionBase):
             self._assert_setitem_index_conversion(obj, val, exp_index, exp_dtype)
 
     @pytest.mark.parametrize(
-        "val,exp_dtype", [(5, np.int64), (1.1, np.float64), ("x", np.object)]
+        "val,exp_dtype", [(5, np.int64), (1.1, np.float64), ("x", object)]
     )
     def test_setitem_index_int64(self, val, exp_dtype):
         obj = pd.Series([1, 2, 3, 4])
@@ -322,7 +312,7 @@ class TestSetitemCoercion(CoercionBase):
         self._assert_setitem_index_conversion(obj, val, exp_index, exp_dtype)
 
     @pytest.mark.parametrize(
-        "val,exp_dtype", [(5, IndexError), (5.1, np.float64), ("x", np.object)]
+        "val,exp_dtype", [(5, IndexError), (5.1, np.float64), ("x", object)]
     )
     def test_setitem_index_float64(self, val, exp_dtype, request):
         obj = pd.Series([1, 2, 3, 4], index=[1.1, 2.1, 3.1, 4.1])
@@ -375,15 +365,15 @@ class TestInsertIndexCoercion(CoercionBase):
     @pytest.mark.parametrize(
         "insert, coerced_val, coerced_dtype",
         [
-            (1, 1, np.object),
-            (1.1, 1.1, np.object),
-            (False, False, np.object),
-            ("x", "x", np.object),
+            (1, 1, object),
+            (1.1, 1.1, object),
+            (False, False, object),
+            ("x", "x", object),
         ],
     )
     def test_insert_index_object(self, insert, coerced_val, coerced_dtype):
         obj = pd.Index(list("abcd"))
-        assert obj.dtype == np.object
+        assert obj.dtype == object
 
         exp = pd.Index(["a", coerced_val, "b", "c", "d"])
         self._assert_insert_conversion(obj, insert, exp, coerced_dtype)
@@ -394,7 +384,7 @@ class TestInsertIndexCoercion(CoercionBase):
             (1, 1, np.int64),
             (1.1, 1.1, np.float64),
             (False, 0, np.int64),
-            ("x", "x", np.object),
+            ("x", "x", object),
         ],
     )
     def test_insert_index_int64(self, insert, coerced_val, coerced_dtype):
@@ -410,7 +400,7 @@ class TestInsertIndexCoercion(CoercionBase):
             (1, 1.0, np.float64),
             (1.1, 1.1, np.float64),
             (False, 0.0, np.float64),
-            ("x", "x", np.object),
+            ("x", "x", object),
         ],
     )
     def test_insert_index_float64(self, insert, coerced_val, coerced_dtype):
@@ -484,9 +474,9 @@ class TestInsertIndexCoercion(CoercionBase):
         "insert, coerced_val, coerced_dtype",
         [
             (pd.Period("2012-01", freq="M"), "2012-01", "period[M]"),
-            (pd.Timestamp("2012-01-01"), pd.Timestamp("2012-01-01"), np.object),
-            (1, 1, np.object),
-            ("x", "x", np.object),
+            (pd.Timestamp("2012-01-01"), pd.Timestamp("2012-01-01"), object),
+            (1, 1, object),
+            ("x", "x", object),
         ],
     )
     def test_insert_index_period(self, insert, coerced_val, coerced_dtype):
@@ -529,12 +519,12 @@ class TestWhereCoercion(CoercionBase):
 
     @pytest.mark.parametrize(
         "fill_val,exp_dtype",
-        [(1, np.object), (1.1, np.object), (1 + 1j, np.object), (True, np.object)],
+        [(1, object), (1.1, object), (1 + 1j, object), (True, object)],
     )
     def test_where_object(self, index_or_series, fill_val, exp_dtype):
         klass = index_or_series
         obj = klass(list("abcd"))
-        assert obj.dtype == np.object
+        assert obj.dtype == object
         cond = klass([True, False, True, False])
 
         if fill_val is True and klass is pd.Series:
@@ -555,7 +545,7 @@ class TestWhereCoercion(CoercionBase):
 
     @pytest.mark.parametrize(
         "fill_val,exp_dtype",
-        [(1, np.int64), (1.1, np.float64), (1 + 1j, np.complex128), (True, np.object)],
+        [(1, np.int64), (1.1, np.float64), (1 + 1j, np.complex128), (True, object)],
     )
     def test_where_int64(self, index_or_series, fill_val, exp_dtype):
         klass = index_or_series
@@ -577,12 +567,7 @@ class TestWhereCoercion(CoercionBase):
 
     @pytest.mark.parametrize(
         "fill_val, exp_dtype",
-        [
-            (1, np.float64),
-            (1.1, np.float64),
-            (1 + 1j, np.complex128),
-            (True, np.object),
-        ],
+        [(1, np.float64), (1.1, np.float64), (1 + 1j, np.complex128), (True, object)],
     )
     def test_where_float64(self, index_or_series, fill_val, exp_dtype):
         klass = index_or_series
@@ -608,7 +593,7 @@ class TestWhereCoercion(CoercionBase):
             (1, np.complex128),
             (1.1, np.complex128),
             (1 + 1j, np.complex128),
-            (True, np.object),
+            (True, object),
         ],
     )
     def test_where_series_complex128(self, fill_val, exp_dtype):
@@ -628,12 +613,12 @@ class TestWhereCoercion(CoercionBase):
 
     @pytest.mark.parametrize(
         "fill_val,exp_dtype",
-        [(1, np.object), (1.1, np.object), (1 + 1j, np.object), (True, np.bool)],
+        [(1, object), (1.1, object), (1 + 1j, object), (True, np.bool_)],
     )
     def test_where_series_bool(self, fill_val, exp_dtype):
 
         obj = pd.Series([True, False, True, False])
-        assert obj.dtype == np.bool
+        assert obj.dtype == np.bool_
         cond = pd.Series([True, False, True, False])
 
         exp = pd.Series([True, fill_val, True, fill_val])
@@ -650,7 +635,7 @@ class TestWhereCoercion(CoercionBase):
         "fill_val,exp_dtype",
         [
             (pd.Timestamp("2012-01-01"), "datetime64[ns]"),
-            (pd.Timestamp("2012-01-01", tz="US/Eastern"), np.object),
+            (pd.Timestamp("2012-01-01", tz="US/Eastern"), object),
         ],
         ids=["datetime64", "datetime64tz"],
     )
@@ -733,7 +718,7 @@ class TestWhereCoercion(CoercionBase):
     @pytest.mark.xfail(reason="GH 22839: do not ignore timezone, must be object")
     def test_where_index_datetime64tz(self):
         fill_val = pd.Timestamp("2012-01-01", tz="US/Eastern")
-        exp_dtype = np.object
+        exp_dtype = object
         obj = pd.Index(
             [
                 pd.Timestamp("2011-01-01"),
@@ -834,24 +819,19 @@ class TestFillnaSeriesCoercion(CoercionBase):
 
     @pytest.mark.parametrize(
         "fill_val, fill_dtype",
-        [(1, np.object), (1.1, np.object), (1 + 1j, np.object), (True, np.object)],
+        [(1, object), (1.1, object), (1 + 1j, object), (True, object)],
     )
     def test_fillna_object(self, index_or_series, fill_val, fill_dtype):
         klass = index_or_series
         obj = klass(["a", np.nan, "c", "d"])
-        assert obj.dtype == np.object
+        assert obj.dtype == object
 
         exp = klass(["a", fill_val, "c", "d"])
         self._assert_fillna_conversion(obj, fill_val, exp, fill_dtype)
 
     @pytest.mark.parametrize(
         "fill_val,fill_dtype",
-        [
-            (1, np.float64),
-            (1.1, np.float64),
-            (1 + 1j, np.complex128),
-            (True, np.object),
-        ],
+        [(1, np.float64), (1.1, np.float64), (1 + 1j, np.complex128), (True, object)],
     )
     def test_fillna_float64(self, index_or_series, fill_val, fill_dtype):
         klass = index_or_series
@@ -863,7 +843,7 @@ class TestFillnaSeriesCoercion(CoercionBase):
         # complex for Series,
         # object for Index
         if fill_dtype == np.complex128 and klass == pd.Index:
-            fill_dtype = np.object
+            fill_dtype = object
         self._assert_fillna_conversion(obj, fill_val, exp, fill_dtype)
 
     @pytest.mark.parametrize(
@@ -872,7 +852,7 @@ class TestFillnaSeriesCoercion(CoercionBase):
             (1, np.complex128),
             (1.1, np.complex128),
             (1 + 1j, np.complex128),
-            (True, np.object),
+            (True, object),
         ],
     )
     def test_fillna_series_complex128(self, fill_val, fill_dtype):
@@ -886,9 +866,9 @@ class TestFillnaSeriesCoercion(CoercionBase):
         "fill_val,fill_dtype",
         [
             (pd.Timestamp("2012-01-01"), "datetime64[ns]"),
-            (pd.Timestamp("2012-01-01", tz="US/Eastern"), np.object),
-            (1, np.object),
-            ("x", np.object),
+            (pd.Timestamp("2012-01-01", tz="US/Eastern"), object),
+            (1, object),
+            ("x", object),
         ],
         ids=["datetime64", "datetime64tz", "object", "object"],
     )
@@ -918,10 +898,10 @@ class TestFillnaSeriesCoercion(CoercionBase):
         "fill_val,fill_dtype",
         [
             (pd.Timestamp("2012-01-01", tz="US/Eastern"), "datetime64[ns, US/Eastern]"),
-            (pd.Timestamp("2012-01-01"), np.object),
-            (pd.Timestamp("2012-01-01", tz="Asia/Tokyo"), np.object),
-            (1, np.object),
-            ("x", np.object),
+            (pd.Timestamp("2012-01-01"), object),
+            (pd.Timestamp("2012-01-01", tz="Asia/Tokyo"), object),
+            (1, object),
+            ("x", object),
         ],
     )
     def test_fillna_datetime64tz(self, index_or_series, fill_val, fill_dtype):
diff --git a/pandas/tests/indexing/test_indexing.py b/pandas/tests/indexing/test_indexing.py
index 51a7aa9bb..dd63a26f1 100644
--- a/pandas/tests/indexing/test_indexing.py
+++ b/pandas/tests/indexing/test_indexing.py
@@ -28,7 +28,7 @@ class TestFancy:
         # len of indexer vs length of the 1d ndarray
         df = DataFrame(index=Index(np.arange(1, 11)))
         df["foo"] = np.zeros(10, dtype=np.float64)
-        df["bar"] = np.zeros(10, dtype=np.complex)
+        df["bar"] = np.zeros(10, dtype=complex)
 
         # invalid
         with pytest.raises(ValueError):
@@ -46,7 +46,7 @@ class TestFancy:
         # dtype getting changed?
         df = DataFrame(index=Index(np.arange(1, 11)))
         df["foo"] = np.zeros(10, dtype=np.float64)
-        df["bar"] = np.zeros(10, dtype=np.complex)
+        df["bar"] = np.zeros(10, dtype=complex)
 
         with pytest.raises(ValueError):
             df[2:5] = np.arange(1, 4) * 1j
diff --git a/pandas/tests/indexing/test_loc.py b/pandas/tests/indexing/test_loc.py
index 30416985f..47980e88f 100644
--- a/pandas/tests/indexing/test_loc.py
+++ b/pandas/tests/indexing/test_loc.py
@@ -925,7 +925,7 @@ Region_1,Site_2,3977723089,A,5/20/2015 8:33,5/20/2015 9:09,Yes,No"""
 
         # only appends one value
         expected = DataFrame({"x": [1.0], "y": [np.nan]})
-        df = DataFrame(columns=["x", "y"], dtype=np.float)
+        df = DataFrame(columns=["x", "y"], dtype=float)
         df.loc[0, "x"] = expected.loc[0, "x"]
         tm.assert_frame_equal(df, expected)
 
diff --git a/pandas/tests/io/formats/test_format.py b/pandas/tests/io/formats/test_format.py
index c18508269..23cad043f 100644
--- a/pandas/tests/io/formats/test_format.py
+++ b/pandas/tests/io/formats/test_format.py
@@ -2813,7 +2813,7 @@ class TestSeriesFormatting:
 class TestGenericArrayFormatter:
     def test_1d_array(self):
         # GenericArrayFormatter is used on types for which there isn't a dedicated
-        # formatter. np.bool is one of those types.
+        # formatter. np.bool_ is one of those types.
         obj = fmt.GenericArrayFormatter(np.array([True, False]))
         res = obj.get_result()
         assert len(res) == 2
diff --git a/pandas/tests/io/json/test_json_table_schema.py b/pandas/tests/io/json/test_json_table_schema.py
index 0437052e2..df64af6ac 100644
--- a/pandas/tests/io/json/test_json_table_schema.py
+++ b/pandas/tests/io/json/test_json_table_schema.py
@@ -100,21 +100,19 @@ class TestBuildSchema:
 
 
 class TestTableSchemaType:
-    @pytest.mark.parametrize("int_type", [np.int, np.int16, np.int32, np.int64])
+    @pytest.mark.parametrize("int_type", [int, np.int16, np.int32, np.int64])
     def test_as_json_table_type_int_data(self, int_type):
         int_data = [1, 2, 3]
         assert as_json_table_type(np.array(int_data, dtype=int_type).dtype) == "integer"
 
-    @pytest.mark.parametrize(
-        "float_type", [np.float, np.float16, np.float32, np.float64]
-    )
+    @pytest.mark.parametrize("float_type", [float, np.float16, np.float32, np.float64])
     def test_as_json_table_type_float_data(self, float_type):
         float_data = [1.0, 2.0, 3.0]
         assert (
             as_json_table_type(np.array(float_data, dtype=float_type).dtype) == "number"
         )
 
-    @pytest.mark.parametrize("bool_type", [bool, np.bool])
+    @pytest.mark.parametrize("bool_type", [bool, np.bool_])
     def test_as_json_table_type_bool_data(self, bool_type):
         bool_data = [True, False]
         assert (
@@ -154,17 +152,15 @@ class TestTableSchemaType:
     # ------
     # dtypes
     # ------
-    @pytest.mark.parametrize("int_dtype", [np.int, np.int16, np.int32, np.int64])
+    @pytest.mark.parametrize("int_dtype", [int, np.int16, np.int32, np.int64])
     def test_as_json_table_type_int_dtypes(self, int_dtype):
         assert as_json_table_type(int_dtype) == "integer"
 
-    @pytest.mark.parametrize(
-        "float_dtype", [np.float, np.float16, np.float32, np.float64]
-    )
+    @pytest.mark.parametrize("float_dtype", [float, np.float16, np.float32, np.float64])
     def test_as_json_table_type_float_dtypes(self, float_dtype):
         assert as_json_table_type(float_dtype) == "number"
 
-    @pytest.mark.parametrize("bool_dtype", [bool, np.bool])
+    @pytest.mark.parametrize("bool_dtype", [bool, np.bool_])
     def test_as_json_table_type_bool_dtypes(self, bool_dtype):
         assert as_json_table_type(bool_dtype) == "boolean"
 
diff --git a/pandas/tests/io/json/test_pandas.py b/pandas/tests/io/json/test_pandas.py
index 137e4c991..56b854bee 100644
--- a/pandas/tests/io/json/test_pandas.py
+++ b/pandas/tests/io/json/test_pandas.py
@@ -159,7 +159,7 @@ class TestPandasContainer:
 
         assert_json_roundtrip_equal(result, expected, orient)
 
-    @pytest.mark.parametrize("dtype", [None, np.float64, np.int, "U3"])
+    @pytest.mark.parametrize("dtype", [None, np.float64, int, "U3"])
     @pytest.mark.parametrize("convert_axes", [True, False])
     @pytest.mark.parametrize("numpy", [True, False])
     def test_roundtrip_str_axes(self, orient, convert_axes, numpy, dtype):
@@ -673,7 +673,7 @@ class TestPandasContainer:
 
         tm.assert_series_equal(result, expected)
 
-    @pytest.mark.parametrize("dtype", [np.float64, np.int])
+    @pytest.mark.parametrize("dtype", [np.float64, int])
     @pytest.mark.parametrize("numpy", [True, False])
     def test_series_roundtrip_numeric(self, orient, numpy, dtype):
         s = Series(range(6), index=["a", "b", "c", "d", "e", "f"])
diff --git a/pandas/tests/io/json/test_ujson.py b/pandas/tests/io/json/test_ujson.py
index 28b043e65..7dc73d5be 100644
--- a/pandas/tests/io/json/test_ujson.py
+++ b/pandas/tests/io/json/test_ujson.py
@@ -676,14 +676,14 @@ class TestUltraJSONTests:
 class TestNumpyJSONTests:
     @pytest.mark.parametrize("bool_input", [True, False])
     def test_bool(self, bool_input):
-        b = np.bool(bool_input)
+        b = bool(bool_input)
         assert ujson.decode(ujson.encode(b)) == b
 
     def test_bool_array(self):
         bool_array = np.array(
-            [True, False, True, True, False, True, False, False], dtype=np.bool
+            [True, False, True, True, False, True, False, False], dtype=bool
         )
-        output = np.array(ujson.decode(ujson.encode(bool_array)), dtype=np.bool)
+        output = np.array(ujson.decode(ujson.encode(bool_array)), dtype=bool)
         tm.assert_numpy_array_equal(bool_array, output)
 
     def test_int(self, any_int_dtype):
@@ -693,7 +693,7 @@ class TestNumpyJSONTests:
         assert klass(ujson.decode(ujson.encode(num))) == num
 
     def test_int_array(self, any_int_dtype):
-        arr = np.arange(100, dtype=np.int)
+        arr = np.arange(100, dtype=int)
         arr_input = arr.astype(any_int_dtype)
 
         arr_output = np.array(
@@ -723,7 +723,7 @@ class TestNumpyJSONTests:
         assert klass(ujson.decode(ujson.encode(num))) == num
 
     def test_float_array(self, float_dtype):
-        arr = np.arange(12.5, 185.72, 1.7322, dtype=np.float)
+        arr = np.arange(12.5, 185.72, 1.7322, dtype=float)
         float_input = arr.astype(float_dtype)
 
         float_output = np.array(
@@ -901,7 +901,7 @@ class TestPandasJSONTests:
             [[1, 2, 3], [4, 5, 6]],
             index=["a", "b"],
             columns=["x", "y", "z"],
-            dtype=np.int,
+            dtype=int,
         )
         kwargs = {} if orient is None else dict(orient=orient)
 
diff --git a/pandas/tests/io/parser/test_c_parser_only.py b/pandas/tests/io/parser/test_c_parser_only.py
index 5bbabc8e1..d76d01904 100644
--- a/pandas/tests/io/parser/test_c_parser_only.py
+++ b/pandas/tests/io/parser/test_c_parser_only.py
@@ -207,8 +207,8 @@ def test_usecols_dtypes(c_parser_only):
         dtype={"b": int, "c": float},
     )
 
-    assert (result.dtypes == [object, np.int, np.float]).all()
-    assert (result2.dtypes == [object, np.float]).all()
+    assert (result.dtypes == [object, int, float]).all()
+    assert (result2.dtypes == [object, float]).all()
 
 
 def test_disable_bool_parsing(c_parser_only):
diff --git a/pandas/tests/io/parser/test_common.py b/pandas/tests/io/parser/test_common.py
index 55256499c..e38fcf138 100644
--- a/pandas/tests/io/parser/test_common.py
+++ b/pandas/tests/io/parser/test_common.py
@@ -1147,7 +1147,7 @@ def test_chunks_have_consistent_numerical_type(all_parsers):
         result = parser.read_csv(StringIO(data))
 
     assert type(result.a[0]) is np.float64
-    assert result.a.dtype == np.float
+    assert result.a.dtype == float
 
 
 def test_warn_if_chunks_have_mismatched_type(all_parsers):
@@ -1163,7 +1163,7 @@ def test_warn_if_chunks_have_mismatched_type(all_parsers):
 
     with tm.assert_produces_warning(warning_type):
         df = parser.read_csv(StringIO(data))
-    assert df.a.dtype == np.object
+    assert df.a.dtype == object
 
 
 @pytest.mark.parametrize("sep", [" ", r"\s+"])
diff --git a/pandas/tests/io/parser/test_dtypes.py b/pandas/tests/io/parser/test_dtypes.py
index d1ed85cc6..6298d1e54 100644
--- a/pandas/tests/io/parser/test_dtypes.py
+++ b/pandas/tests/io/parser/test_dtypes.py
@@ -368,7 +368,7 @@ def test_empty_pass_dtype(all_parsers):
     result = parser.read_csv(StringIO(data), dtype={"one": "u1"})
 
     expected = DataFrame(
-        {"one": np.empty(0, dtype="u1"), "two": np.empty(0, dtype=np.object)},
+        {"one": np.empty(0, dtype="u1"), "two": np.empty(0, dtype=object)},
         index=Index([], dtype=object),
     )
     tm.assert_frame_equal(result, expected)
@@ -399,7 +399,7 @@ def test_empty_with_multi_index_pass_dtype(all_parsers):
     exp_idx = MultiIndex.from_arrays(
         [np.empty(0, dtype="u1"), np.empty(0, dtype=np.float64)], names=["one", "two"]
     )
-    expected = DataFrame({"three": np.empty(0, dtype=np.object)}, index=exp_idx)
+    expected = DataFrame({"three": np.empty(0, dtype=object)}, index=exp_idx)
     tm.assert_frame_equal(result, expected)
 
 
diff --git a/pandas/tests/io/pytables/test_store.py b/pandas/tests/io/pytables/test_store.py
index 30b64b175..524e9f41a 100644
--- a/pandas/tests/io/pytables/test_store.py
+++ b/pandas/tests/io/pytables/test_store.py
@@ -2493,7 +2493,7 @@ class TestHDFStore:
 
     @td.xfail_non_writeable
     @pytest.mark.parametrize(
-        "dtype", [np.int64, np.float64, np.object, "m8[ns]", "M8[ns]"]
+        "dtype", [np.int64, np.float64, object, "m8[ns]", "M8[ns]"]
     )
     def test_empty_series(self, dtype, setup_path):
         s = Series(dtype=dtype)
diff --git a/pandas/tests/io/test_sql.py b/pandas/tests/io/test_sql.py
index 7d4716e1b..fa04eabb7 100644
--- a/pandas/tests/io/test_sql.py
+++ b/pandas/tests/io/test_sql.py
@@ -1364,7 +1364,7 @@ class _TestSQLAlchemy(SQLAlchemyMixIn, PandasSQLTest):
         # Int column with NA values stays as float
         assert issubclass(df.IntColWithNull.dtype.type, np.floating)
         # Bool column with NA values becomes object
-        assert issubclass(df.BoolColWithNull.dtype.type, np.object)
+        assert issubclass(df.BoolColWithNull.dtype.type, object)
 
     def test_bigint(self):
         # int64 should be converted to BigInteger, GH7433
diff --git a/pandas/tests/io/test_stata.py b/pandas/tests/io/test_stata.py
index aa3aa61bb..6d7fec803 100644
--- a/pandas/tests/io/test_stata.py
+++ b/pandas/tests/io/test_stata.py
@@ -689,7 +689,7 @@ class TestStata:
     @pytest.mark.parametrize("version", [114, 117, 118, 119, None])
     @pytest.mark.parametrize("byteorder", [">", "<"])
     def test_bool_uint(self, byteorder, version):
-        s0 = Series([0, 1, True], dtype=np.bool)
+        s0 = Series([0, 1, True], dtype=np.bool_)
         s1 = Series([0, 1, 100], dtype=np.uint8)
         s2 = Series([0, 1, 255], dtype=np.uint8)
         s3 = Series([0, 1, 2 ** 15 - 100], dtype=np.uint16)
@@ -855,7 +855,7 @@ class TestStata:
         expected[5][2] = expected[5][3] = expected[5][4] = datetime(1677, 10, 1)
         expected[5][5] = expected[5][6] = datetime(1678, 1, 1)
 
-        expected = DataFrame(expected, columns=columns, dtype=np.object)
+        expected = DataFrame(expected, columns=columns, dtype=object)
         parsed_115 = read_stata(self.dta18_115)
         parsed_117 = read_stata(self.dta18_117)
         tm.assert_frame_equal(expected, parsed_115, check_datetimelike_compat=True)
diff --git a/pandas/tests/plotting/test_hist_method.py b/pandas/tests/plotting/test_hist_method.py
index 5a30e9fbb..0d3425d00 100644
--- a/pandas/tests/plotting/test_hist_method.py
+++ b/pandas/tests/plotting/test_hist_method.py
@@ -205,7 +205,7 @@ class TestDataFramePlots(TestPlotBase):
     def test_hist_non_numerical_raises(self):
         # gh-10444
         df = DataFrame(np.random.rand(10, 2))
-        df_o = df.astype(np.object)
+        df_o = df.astype(object)
 
         msg = "hist method requires numerical columns, nothing to plot."
         with pytest.raises(ValueError, match=msg):
diff --git a/pandas/tests/plotting/test_series.py b/pandas/tests/plotting/test_series.py
index 5341878d4..6da892c15 100644
--- a/pandas/tests/plotting/test_series.py
+++ b/pandas/tests/plotting/test_series.py
@@ -617,7 +617,7 @@ class TestSeriesPlots(TestPlotBase):
         sample_points = np.linspace(-100, 100, 20)
         _check_plot_works(self.ts.plot.kde, bw_method="scott", ind=20)
         _check_plot_works(self.ts.plot.kde, bw_method=None, ind=20)
-        _check_plot_works(self.ts.plot.kde, bw_method=None, ind=np.int(20))
+        _check_plot_works(self.ts.plot.kde, bw_method=None, ind=np.int_(20))
         _check_plot_works(self.ts.plot.kde, bw_method=0.5, ind=sample_points)
         _check_plot_works(self.ts.plot.density, bw_method=0.5, ind=sample_points)
         _, ax = self.plt.subplots()
diff --git a/pandas/tests/resample/test_base.py b/pandas/tests/resample/test_base.py
index 485535bec..28d33ebb2 100644
--- a/pandas/tests/resample/test_base.py
+++ b/pandas/tests/resample/test_base.py
@@ -180,7 +180,7 @@ def test_resample_size_empty_dataframe(freq, empty_frame_dti):
 
 
 @pytest.mark.parametrize("index", tm.all_timeseries_index_generator(0))
-@pytest.mark.parametrize("dtype", [np.float, np.int, np.object, "datetime64[ns]"])
+@pytest.mark.parametrize("dtype", [float, int, object, "datetime64[ns]"])
 def test_resample_empty_dtypes(index, dtype, resample_method):
     # Empty series were sometimes causing a segfault (for the functions
     # with Cython bounds-checking disabled) or an IndexError.  We just run
diff --git a/pandas/tests/reshape/test_concat.py b/pandas/tests/reshape/test_concat.py
index 19fd8db53..1c9d00a4b 100644
--- a/pandas/tests/reshape/test_concat.py
+++ b/pandas/tests/reshape/test_concat.py
@@ -2759,8 +2759,8 @@ def test_concat_sparse():
 
 def test_concat_dense_sparse():
     # GH 30668
-    a = pd.Series(pd.arrays.SparseArray([1, None]), dtype=np.float)
-    b = pd.Series([1], dtype=np.float)
+    a = pd.Series(pd.arrays.SparseArray([1, None]), dtype=float)
+    b = pd.Series([1], dtype=float)
     expected = pd.Series(data=[1, None, 1], index=[0, 1, 0]).astype(
         pd.SparseDtype(np.float64, None)
     )
diff --git a/pandas/tests/series/indexing/test_where.py b/pandas/tests/series/indexing/test_where.py
index 8daea8449..3f85abb4b 100644
--- a/pandas/tests/series/indexing/test_where.py
+++ b/pandas/tests/series/indexing/test_where.py
@@ -278,7 +278,7 @@ def test_where_setitem_invalid():
     "mask", [[True, False, False, False, False], [True, False], [False]]
 )
 @pytest.mark.parametrize(
-    "item", [2.0, np.nan, np.finfo(np.float).max, np.finfo(np.float).min]
+    "item", [2.0, np.nan, np.finfo(float).max, np.finfo(float).min]
 )
 # Test numpy arrays, lists and tuples as the input to be
 # broadcast
diff --git a/pandas/tests/series/test_apply.py b/pandas/tests/series/test_apply.py
index e6f86dda0..d51dceae5 100644
--- a/pandas/tests/series/test_apply.py
+++ b/pandas/tests/series/test_apply.py
@@ -180,7 +180,7 @@ class TestSeriesApply:
         result = ser.apply(lambda x: "A")
         exp = pd.Series(["A"] * 7, name="XX", index=list("abcdefg"))
         tm.assert_series_equal(result, exp)
-        assert result.dtype == np.object
+        assert result.dtype == object
 
     @pytest.mark.parametrize("series", [["1-1", "1-1", np.NaN], ["1-1", "1-2", np.NaN]])
     def test_apply_categorical_with_nan_values(self, series):
@@ -717,7 +717,7 @@ class TestSeriesMap:
         result = s.map(lambda x: "A")
         exp = pd.Series(["A"] * 7, name="XX", index=list("abcdefg"))
         tm.assert_series_equal(result, exp)
-        assert result.dtype == np.object
+        assert result.dtype == object
 
         with pytest.raises(NotImplementedError):
             s.map(lambda x: x, na_action="ignore")
diff --git a/pandas/tests/series/test_combine_concat.py b/pandas/tests/series/test_combine_concat.py
index 0766bfc37..95eba6ccc 100644
--- a/pandas/tests/series/test_combine_concat.py
+++ b/pandas/tests/series/test_combine_concat.py
@@ -68,9 +68,9 @@ class TestSeriesConcat:
             (np.bool_, np.int32, np.int32),
             (np.bool_, np.float32, np.object_),
             # datetime-like
-            ("m8[ns]", np.bool, np.object_),
+            ("m8[ns]", np.bool_, np.object_),
             ("m8[ns]", np.int64, np.object_),
-            ("M8[ns]", np.bool, np.object_),
+            ("M8[ns]", np.bool_, np.object_),
             ("M8[ns]", np.int64, np.object_),
             # categorical
             ("category", "category", "category"),
diff --git a/pandas/tests/test_algos.py b/pandas/tests/test_algos.py
index ff5f890cc..44a845296 100644
--- a/pandas/tests/test_algos.py
+++ b/pandas/tests/test_algos.py
@@ -713,7 +713,7 @@ class TestUnique:
         NAN2 = struct.unpack("d", struct.pack("=Q", bits_for_nan2))[0]
         assert NAN1 != NAN1
         assert NAN2 != NAN2
-        for el_type in [np.float64, np.object]:
+        for el_type in [np.float64, object]:
             a = np.array([NAN1, NAN2], dtype=el_type)
             result = pd.unique(a)
             assert result.size == 1
@@ -725,7 +725,7 @@ class TestUnique:
         # GH 22295
         if unique_nulls_fixture is unique_nulls_fixture2:
             return  # skip it, values not unique
-        a = np.array([unique_nulls_fixture, unique_nulls_fixture2], dtype=np.object)
+        a = np.array([unique_nulls_fixture, unique_nulls_fixture2], dtype=object)
         result = pd.unique(a)
         assert result.size == 2
         assert a[0] is unique_nulls_fixture
@@ -886,7 +886,7 @@ class TestIsin:
 
         # as object-array:
         result = algos.isin(
-            np.asarray(comps, dtype=np.object), np.asarray(values, dtype=np.object)
+            np.asarray(comps, dtype=object), np.asarray(values, dtype=object)
         )
         tm.assert_numpy_array_equal(np.array([True]), result)
 
@@ -916,8 +916,8 @@ class TestIsin:
 
     def test_different_nan_objects(self):
         # GH 22119
-        comps = np.array(["nan", np.nan * 1j, float("nan")], dtype=np.object)
-        vals = np.array([float("nan")], dtype=np.object)
+        comps = np.array(["nan", np.nan * 1j, float("nan")], dtype=object)
+        vals = np.array([float("nan")], dtype=object)
         expected = np.array([False, False, True])
         result = algos.isin(comps, vals)
         tm.assert_numpy_array_equal(expected, result)
@@ -1157,7 +1157,7 @@ class TestValueCounts:
     def test_value_counts_normalized(self):
         # GH12558
         s = Series([1, 2, np.nan, np.nan, np.nan])
-        dtypes = (np.float64, np.object, "M8[ns]")
+        dtypes = (np.float64, object, "M8[ns]")
         for t in dtypes:
             s_typed = s.astype(t)
             result = s_typed.value_counts(normalize=True, dropna=False)
@@ -2290,10 +2290,10 @@ class TestMode:
             exp = Series(exp_multi, dtype=dt)
             tm.assert_series_equal(algos.mode(s), exp)
 
-        exp = Series([1], dtype=np.int)
+        exp = Series([1], dtype=int)
         tm.assert_series_equal(algos.mode([1]), exp)
 
-        exp = Series(["a", "b", "c"], dtype=np.object)
+        exp = Series(["a", "b", "c"], dtype=object)
         tm.assert_series_equal(algos.mode(["a", "b", "c"]), exp)
 
     def test_number_mode(self):
diff --git a/pandas/tests/test_take.py b/pandas/tests/test_take.py
index 2a42eb5d7..9f0632917 100644
--- a/pandas/tests/test_take.py
+++ b/pandas/tests/test_take.py
@@ -31,7 +31,7 @@ def writeable(request):
         (np.int16, False),
         (np.int8, False),
         (np.object_, True),
-        (np.bool, False),
+        (np.bool_, False),
     ]
 )
 def dtype_can_hold_na(request):
diff --git a/pandas/tests/tslibs/test_fields.py b/pandas/tests/tslibs/test_fields.py
index 943f4207d..a45fcab56 100644
--- a/pandas/tests/tslibs/test_fields.py
+++ b/pandas/tests/tslibs/test_fields.py
@@ -12,9 +12,7 @@ def test_fields_readonly():
     dtindex.flags.writeable = False
 
     result = fields.get_date_name_field(dtindex, "month_name")
-    expected = np.array(
-        ["January", "February", "March", "April", "May"], dtype=np.object
-    )
+    expected = np.array(["January", "February", "March", "April", "May"], dtype=object)
     tm.assert_numpy_array_equal(result, expected)
 
     result = fields.get_date_field(dtindex, "Y")
diff --git a/pandas/tests/window/moments/test_moments_rolling.py b/pandas/tests/window/moments/test_moments_rolling.py
index 3e5475e6b..f6e283496 100644
--- a/pandas/tests/window/moments/test_moments_rolling.py
+++ b/pandas/tests/window/moments/test_moments_rolling.py
@@ -515,7 +515,7 @@ def test_cmov_window_regular(win_types):
 @td.skip_if_no_scipy
 def test_cmov_window_regular_linear_range(win_types):
     # GH 8238
-    vals = np.array(range(10), dtype=np.float)
+    vals = np.array(range(10), dtype=float)
     xp = vals.copy()
     xp[:2] = np.nan
     xp[-2:] = np.nan
@@ -718,7 +718,7 @@ def test_cmov_window_special_linear_range(win_types_special):
         "exponential": {"tau": 10},
     }
 
-    vals = np.array(range(10), dtype=np.float)
+    vals = np.array(range(10), dtype=float)
     xp = vals.copy()
     xp[:2] = np.nan
     xp[-2:] = np.nan

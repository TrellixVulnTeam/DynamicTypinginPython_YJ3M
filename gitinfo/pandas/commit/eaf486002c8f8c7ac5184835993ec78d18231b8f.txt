commit eaf486002c8f8c7ac5184835993ec78d18231b8f
Author: MomIsBestFriend <50263213+MomIsBestFriend@users.noreply.github.com>
Date:   Fri Nov 29 18:41:14 2019 +0200

    STY: x.__class__ to type(x) #batch-2 (#29893)

diff --git a/pandas/core/dtypes/dtypes.py b/pandas/core/dtypes/dtypes.py
index 2c601b01d..fb3097684 100644
--- a/pandas/core/dtypes/dtypes.py
+++ b/pandas/core/dtypes/dtypes.py
@@ -420,7 +420,7 @@ class CategoricalDtype(PandasExtensionDtype, ExtensionDtype):
         if self.categories is None:
             data = "None, "
         else:
-            data = self.categories._format_data(name=self.__class__.__name__)
+            data = self.categories._format_data(name=type(self).__name__)
         return tpl.format(data=data, ordered=self._ordered)
 
     @staticmethod
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 29eeb5999..b13aee238 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -251,7 +251,7 @@ class NDFrame(PandasObject, SelectionMixin):
             if dtype.kind == "V":
                 raise NotImplementedError(
                     "compound dtypes are not implemented"
-                    " in the {0} constructor".format(self.__class__.__name__)
+                    " in the {0} constructor".format(type(self).__name__)
                 )
 
         return dtype
@@ -1534,7 +1534,7 @@ class NDFrame(PandasObject, SelectionMixin):
         raise ValueError(
             "The truth value of a {0} is ambiguous. "
             "Use a.empty, a.bool(), a.item(), a.any() or a.all().".format(
-                self.__class__.__name__
+                type(self).__name__
             )
         )
 
@@ -1559,7 +1559,7 @@ class NDFrame(PandasObject, SelectionMixin):
         elif is_scalar(v):
             raise ValueError(
                 "bool cannot act on a non-boolean single element "
-                "{0}".format(self.__class__.__name__)
+                "{0}".format(type(self).__name__)
             )
 
         self.__nonzero__()
@@ -1865,7 +1865,7 @@ class NDFrame(PandasObject, SelectionMixin):
     def __hash__(self):
         raise TypeError(
             "{0!r} objects are mutable, thus they cannot be"
-            " hashed".format(self.__class__.__name__)
+            " hashed".format(type(self).__name__)
         )
 
     def __iter__(self):
@@ -2059,7 +2059,7 @@ class NDFrame(PandasObject, SelectionMixin):
         # string representation based upon iterating over self
         # (since, by definition, `PandasContainers` are iterable)
         prepr = "[%s]" % ",".join(map(pprint_thing, self))
-        return f"{self.__class__.__name__}({prepr})"
+        return f"{type(self).__name__}({prepr})"
 
     def _repr_latex_(self):
         """
diff --git a/pandas/core/groupby/base.py b/pandas/core/groupby/base.py
index 407cd8342..e088400b2 100644
--- a/pandas/core/groupby/base.py
+++ b/pandas/core/groupby/base.py
@@ -41,7 +41,7 @@ class GroupByMixin:
         except IndexError:
             groupby = self._groupby
 
-        self = self.__class__(subset, groupby=groupby, parent=self, **kwargs)
+        self = type(self)(subset, groupby=groupby, parent=self, **kwargs)
         self._reset_cache()
         if subset.ndim == 2:
             if is_scalar(key) and key in subset or is_list_like(key):
diff --git a/pandas/core/groupby/generic.py b/pandas/core/groupby/generic.py
index 99ef281e8..4726cdfb0 100644
--- a/pandas/core/groupby/generic.py
+++ b/pandas/core/groupby/generic.py
@@ -473,7 +473,7 @@ class SeriesGroupBy(GroupBy):
         """
         Transform with a non-str `func`.
         """
-        klass = self._selected_obj.__class__
+        klass = type(self._selected_obj)
 
         results = []
         for name, group in self:
diff --git a/pandas/core/groupby/grouper.py b/pandas/core/groupby/grouper.py
index dc924455b..9b2f43d8d 100644
--- a/pandas/core/groupby/grouper.py
+++ b/pandas/core/groupby/grouper.py
@@ -211,7 +211,7 @@ class Grouper:
             if getattr(self, attr_name) is not None
         )
         attrs = ", ".join(attrs_list)
-        cls_name = self.__class__.__name__
+        cls_name = type(self).__name__
         return f"{cls_name}({attrs})"
 
 
diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index 486cc0cd9..4a3fa26c3 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -815,7 +815,7 @@ class Index(IndexOpsMixin, PandasObject):
         else:
             if allow_fill and fill_value is not None:
                 msg = "Unable to fill values because {0} cannot contain NA"
-                raise ValueError(msg.format(self.__class__.__name__))
+                raise ValueError(msg.format(type(self).__name__))
             taken = self.values.take(indices)
         return self._shallow_copy(taken)
 
@@ -948,7 +948,7 @@ class Index(IndexOpsMixin, PandasObject):
         """
         Return a string representation for this object.
         """
-        klass = self.__class__.__name__
+        klass_name = type(self).__name__
         data = self._format_data()
         attrs = self._format_attrs()
         space = self._format_space()
@@ -959,7 +959,7 @@ class Index(IndexOpsMixin, PandasObject):
         if data is None:
             data = ""
 
-        res = f"{klass}({data}{prepr})"
+        res = f"{klass_name}({data}{prepr})"
 
         return res
 
@@ -1287,7 +1287,7 @@ class Index(IndexOpsMixin, PandasObject):
         for name in values:
             if not is_hashable(name):
                 raise TypeError(
-                    "{}.name must be a hashable type".format(self.__class__.__name__)
+                    "{}.name must be a hashable type".format(type(self).__name__)
                 )
         self.name = values[0]
 
@@ -1794,7 +1794,7 @@ class Index(IndexOpsMixin, PandasObject):
     def __reduce__(self):
         d = dict(data=self._data)
         d.update(self._get_attributes_dict())
-        return _new_Index, (self.__class__, d), None
+        return _new_Index, (type(self), d), None
 
     def __setstate__(self, state):
         """
@@ -2290,7 +2290,7 @@ class Index(IndexOpsMixin, PandasObject):
         raise ValueError(
             "The truth value of a {0} is ambiguous. "
             "Use a.empty, a.bool(), a.item(), a.any() or a.all().".format(
-                self.__class__.__name__
+                type(self).__name__
             )
         )
 
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index ab9f57ff9..0d368845e 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -423,7 +423,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index, DatetimeDelegateMixin):
 
         d = dict(data=self._data)
         d.update(self._get_attributes_dict())
-        return _new_DatetimeIndex, (self.__class__, d), None
+        return _new_DatetimeIndex, (type(self), d), None
 
     def __setstate__(self, state):
         """Necessary for making this object picklable"""
diff --git a/pandas/core/indexes/frozen.py b/pandas/core/indexes/frozen.py
index 13c386187..ab9852157 100644
--- a/pandas/core/indexes/frozen.py
+++ b/pandas/core/indexes/frozen.py
@@ -69,13 +69,13 @@ class FrozenList(PandasObject, list):
 
     def __getitem__(self, n):
         if isinstance(n, slice):
-            return self.__class__(super().__getitem__(n))
+            return type(self)(super().__getitem__(n))
         return super().__getitem__(n)
 
     def __radd__(self, other):
         if isinstance(other, tuple):
             other = list(other)
-        return self.__class__(other + list(self))
+        return type(self)(other + list(self))
 
     def __eq__(self, other) -> bool:
         if isinstance(other, (tuple, FrozenList)):
@@ -85,12 +85,12 @@ class FrozenList(PandasObject, list):
     __req__ = __eq__
 
     def __mul__(self, other):
-        return self.__class__(super().__mul__(other))
+        return type(self)(super().__mul__(other))
 
     __imul__ = __mul__
 
     def __reduce__(self):
-        return self.__class__, (list(self),)
+        return type(self), (list(self),)
 
     def __hash__(self):
         return hash(tuple(self))
@@ -99,7 +99,7 @@ class FrozenList(PandasObject, list):
         """This method will not function because object is immutable."""
         raise TypeError(
             "'{cls}' does not support mutable operations.".format(
-                cls=self.__class__.__name__
+                cls=type(self).__name__
             )
         )
 
@@ -107,7 +107,7 @@ class FrozenList(PandasObject, list):
         return pprint_thing(self, quote_strings=True, escape_chars=("\t", "\r", "\n"))
 
     def __repr__(self) -> str:
-        return f"{self.__class__.__name__}({str(self)})"
+        return f"{type(self).__name__}({str(self)})"
 
     __setitem__ = __setslice__ = __delitem__ = __delslice__ = _disabled
     pop = append = extend = remove = sort = insert = _disabled
@@ -132,7 +132,7 @@ class FrozenNDArray(PandasObject, np.ndarray):
     def _disabled(self, *args, **kwargs):
         """This method will not function because object is immutable."""
         raise TypeError(
-            "'{cls}' does not support mutable operations.".format(cls=self.__class__)
+            "'{cls}' does not support mutable operations.".format(cls=type(self))
         )
 
     __setitem__ = __setslice__ = __delitem__ = __delslice__ = _disabled
diff --git a/pandas/core/indexes/interval.py b/pandas/core/indexes/interval.py
index 35e8405e0..a9e119f3c 100644
--- a/pandas/core/indexes/interval.py
+++ b/pandas/core/indexes/interval.py
@@ -497,7 +497,7 @@ class IntervalIndex(IntervalMixin, Index):
     def __reduce__(self):
         d = dict(left=self.left, right=self.right)
         d.update(self._get_attributes_dict())
-        return _new_IntervalIndex, (self.__class__, d), None
+        return _new_IntervalIndex, (type(self), d), None
 
     @Appender(_index_shared_docs["copy"])
     def copy(self, deep=False, name=None):
@@ -512,7 +512,7 @@ class IntervalIndex(IntervalMixin, Index):
 
     @Appender(_index_shared_docs["astype"])
     def astype(self, dtype, copy=True):
-        with rewrite_exception("IntervalArray", self.__class__.__name__):
+        with rewrite_exception("IntervalArray", type(self).__name__):
             new_values = self.values.astype(dtype, copy=copy)
         if is_interval_dtype(new_values):
             return self._shallow_copy(new_values.left, new_values.right)
@@ -1205,7 +1205,7 @@ class IntervalIndex(IntervalMixin, Index):
         return attrs
 
     def _format_space(self):
-        space = " " * (len(self.__class__.__name__) + 1)
+        space = " " * (len(type(self).__name__) + 1)
         return "\n{space}".format(space=space)
 
     # --------------------------------------------------------------------
diff --git a/pandas/core/indexes/multi.py b/pandas/core/indexes/multi.py
index 048112cbf..d151fb726 100644
--- a/pandas/core/indexes/multi.py
+++ b/pandas/core/indexes/multi.py
@@ -1245,9 +1245,7 @@ class MultiIndex(Index):
                 # All items in 'names' need to be hashable:
                 if not is_hashable(name):
                     raise TypeError(
-                        "{}.name must be a hashable type".format(
-                            self.__class__.__name__
-                        )
+                        "{}.name must be a hashable type".format(type(self).__name__)
                     )
             self._names[lev] = name
 
@@ -1911,7 +1909,7 @@ class MultiIndex(Index):
             sortorder=self.sortorder,
             names=list(self.names),
         )
-        return ibase._new_Index, (self.__class__, d), None
+        return ibase._new_Index, (type(self), d), None
 
     def __setstate__(self, state):
         """Necessary for making this object picklable"""
@@ -3264,7 +3262,7 @@ class MultiIndex(Index):
         elif not is_object_dtype(dtype):
             msg = (
                 "Setting {cls} dtype to anything other than object is not supported"
-            ).format(cls=self.__class__)
+            ).format(cls=type(self))
             raise TypeError(msg)
         elif copy is True:
             return self._shallow_copy()
diff --git a/pandas/core/indexes/range.py b/pandas/core/indexes/range.py
index f7bbbee46..f300cde3b 100644
--- a/pandas/core/indexes/range.py
+++ b/pandas/core/indexes/range.py
@@ -179,7 +179,7 @@ class RangeIndex(Int64Index):
     def __reduce__(self):
         d = self._get_attributes_dict()
         d.update(dict(self._get_data_as_items()))
-        return ibase._new_Index, (self.__class__, d), None
+        return ibase._new_Index, (type(self), d), None
 
     # --------------------------------------------------------------------
     # Rendering Methods
@@ -592,27 +592,27 @@ class RangeIndex(Int64Index):
                     and (start_s - end_o) <= step_s
                     and (start_o - end_s) <= step_s
                 ):
-                    return self.__class__(start_r, end_r + step_s, step_s)
+                    return type(self)(start_r, end_r + step_s, step_s)
                 if (
                     (step_s % 2 == 0)
                     and (abs(start_s - start_o) <= step_s / 2)
                     and (abs(end_s - end_o) <= step_s / 2)
                 ):
-                    return self.__class__(start_r, end_r + step_s / 2, step_s / 2)
+                    return type(self)(start_r, end_r + step_s / 2, step_s / 2)
             elif step_o % step_s == 0:
                 if (
                     (start_o - start_s) % step_s == 0
                     and (start_o + step_s >= start_s)
                     and (end_o - step_s <= end_s)
                 ):
-                    return self.__class__(start_r, end_r + step_s, step_s)
+                    return type(self)(start_r, end_r + step_s, step_s)
             elif step_s % step_o == 0:
                 if (
                     (start_s - start_o) % step_o == 0
                     and (start_s + step_o >= start_o)
                     and (end_s - step_o <= end_o)
                 ):
-                    return self.__class__(start_r, end_r + step_o, step_o)
+                    return type(self)(start_r, end_r + step_o, step_o)
         return self._int64index._union(other, sort=sort)
 
     @Appender(_index_shared_docs["join"])
@@ -781,7 +781,7 @@ class RangeIndex(Int64Index):
                         rstart = op(left.start, right)
                         rstop = op(left.stop, right)
 
-                    result = self.__class__(rstart, rstop, rstep, **attrs)
+                    result = type(self)(rstart, rstop, rstep, **attrs)
 
                     # for compat with numpy / Int64Index
                     # even if we can represent as a RangeIndex, return

commit 524979e070ec1eb0c1bb49bc6d23acd1ebf9657c
Author: Adam Klein <adamklein@gmail.com>
Date:   Sun Feb 5 17:33:35 2012 -0500

    working on box type craziness

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index 7c728c72b..dcf58dcd8 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -174,14 +174,14 @@ class DateRange(DatetimeIndex):
             if periods is None:
                 raise Exception('Must provide number of periods!')
 
-            assert(isinstance(end, datetime))
+            assert(isinstance(end, (datetime, Timestamp)))
 
             end = offset.rollback(end)
 
             endLoc = cachedRange.get_loc(end) + 1
             startLoc = endLoc - periods
         elif end is None:
-            assert(isinstance(start, datetime))
+            assert(isinstance(start, (datetime, Timestamp)))
             start = offset.rollforward(start)
 
             startLoc = cachedRange.get_loc(start)
@@ -557,13 +557,13 @@ def generate_range(start=None, end=None, periods=None,
 
 def _in_range(start, end, rng_start, rng_end):
     if isinstance(rng_start, datetime):
-        rng_start = np.datetime64(rng_start)
+        rng_start = Timestamp(rng_start)
     if isinstance(rng_end, datetime):
-        rng_end = np.datetime64(rng_end)
+        rng_end = Timestamp(rng_end)
     if isinstance(start, datetime):
-        start = np.datetime64(start)
+        start = Timestamp(start)
     if isinstance(end, datetime):
-        end = np.datetime64(end)
+        end = Timestamp(end)
 
     return start > rng_start and end < rng_end
 
diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 2ec113085..b5231d4c8 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -270,7 +270,9 @@ class DateOffset(object):
         # Default (slow) method for determining if some date is a
         # member of the DateRange generated by this offset. Subclasses
         # may have this re-implemented in a nicer way.
-        return someDate == ((someDate + self) - self)
+        a = lib.Timestamp(someDate) 
+        b = lib.Timestamp(((someDate + self) - self))
+        return a == b
 
 
 class BDay(DateOffset, CacheableOffset):
@@ -478,12 +480,12 @@ class WeekOfMonth(DateOffset, CacheableOffset):
 
         one_month = relativedelta(months=1, day=1)
 
-        if other < offsetOfMonth:
+        if offsetOfMonth > other:
             if self.n > 0:
                 months = self.n - 1
             else:
                 months = self.n
-        elif other == offsetOfMonth:
+        elif offsetOfMonth == other:
             months = self.n
         else:
             if self.n > 0:
@@ -505,7 +507,7 @@ class WeekOfMonth(DateOffset, CacheableOffset):
         return d
 
     def onOffset(self, someDate):
-        return someDate == self.getOffsetOfMonth(someDate)
+        return lib.Timestamp(someDate) == self.getOffsetOfMonth(someDate)
 
 class BQuarterEnd(DateOffset, CacheableOffset):
     """DateOffset increments between business Quarter dates
@@ -776,7 +778,7 @@ def inferTimeRule(index):
 
     first, second, third = index[:3]
     for rule, offset in _offsetMap.iteritems():
-        if second == (first + offset) and third == (second + offset):
+        if (first + offset) == second and (second + offset) == third:
             return rule
 
     raise Exception('Could not infer time rule from data!')
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index 58ade4383..f2052f261 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -15,6 +15,7 @@ from pandas import DataFrame, Index
 from pandas.io.parsers import read_csv, read_table, ExcelFile, TextParser
 from pandas.util.testing import assert_almost_equal, assert_frame_equal
 import pandas._tseries as lib
+from pandas._tseries import Timestamp
 
 class TestParsers(unittest.TestCase):
     data1 = """index,A,B,C,D
@@ -156,7 +157,7 @@ c,4,5
 """
         df = read_csv(StringIO(data), parse_dates=True)
         expected = read_csv(StringIO(data), index_col=0, parse_dates=True)
-        self.assert_(isinstance(df.index[0], (datetime, np.datetime64)))
+        self.assert_(isinstance(df.index[0], (datetime, np.datetime64, Timestamp)))
         assert_frame_equal(df, expected)
 
     def test_no_header(self):
@@ -196,7 +197,7 @@ baz,7,8,9
         df2 = read_table(self.csv1, sep=',', index_col=0, parse_dates=True)
         self.assert_(np.array_equal(df.columns, ['A', 'B', 'C', 'D']))
         self.assert_(df.index.name == 'index')
-        self.assert_(isinstance(df.index[0], (datetime, np.datetime64)))
+        self.assert_(isinstance(df.index[0], (datetime, np.datetime64, Timestamp)))
         self.assert_(df.values.dtype == np.float64)
         assert_frame_equal(df, df2)
 
@@ -204,7 +205,7 @@ baz,7,8,9
         df = read_csv(self.csv2, index_col=0, parse_dates=True)
         df2 = read_table(self.csv2, sep=',', index_col=0, parse_dates=True)
         self.assert_(np.array_equal(df.columns, ['A', 'B', 'C', 'D', 'E']))
-        self.assert_(isinstance(df.index[0], (datetime, np.datetime64)))
+        self.assert_(isinstance(df.index[0], (datetime, np.datetime64, Timestamp)))
         self.assert_(df.ix[:, ['A', 'B', 'C', 'D']].values.dtype == np.float64)
         assert_frame_equal(df, df2)
 
@@ -425,12 +426,12 @@ bar,two,12,13,14,15
 """
         df = read_csv(StringIO(data), index_col=[0, 1], parse_dates=True)
         self.assert_(isinstance(df.index.levels[0][0],
-                     (datetime, np.datetime64)))
+                     (datetime, np.datetime64, Timestamp)))
 
         # specify columns out of order!
         df2 = read_csv(StringIO(data), index_col=[1, 0], parse_dates=True)
         self.assert_(isinstance(df2.index.levels[1][0],
-                     (datetime, np.datetime64)))
+                     (datetime, np.datetime64, Timestamp)))
 
     def test_skip_footer(self):
         data = """A,B,C
@@ -470,7 +471,7 @@ c,4,5,01/03/2009
         expected = read_csv(StringIO(data))
         expected['D'] = expected['D'].map(parser.parse)
 
-        self.assert_(isinstance(result['D'][0], datetime))
+        self.assert_(isinstance(result['D'][0], (datetime, Timestamp)))
         assert_frame_equal(result, expected)
         assert_frame_equal(result2, expected)
 
diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index 3faa370b4..10da34170 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -9,6 +9,12 @@ cdef extern from "datetime.h":
         # cdef char hastzinfo
         pass
 
+    ctypedef class datetime.timedelta [object PyDateTime_Delta]:
+        # cdef int *data
+        # cdef long hashcode
+        # cdef char hastzinfo
+        pass
+
     void PyDateTime_IMPORT()
 
     int PyDateTime_GET_YEAR(datetime o)
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 959e36535..3e178e3bb 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -105,6 +105,19 @@ cdef class Timestamp(object):
             self.value = tmp.value
             self.dtval = tmp.dtval
             self.freq = tmp.freq
+        elif isinstance(ts, Delta):
+            dts.year = ts.year
+            dts.month = ts.month
+            dts.day = ts.day
+            dts.hour = ts.hour
+            dts.min = ts.minute
+            dts.sec = ts.second
+            dts.us = ts.microsecond
+            self.dtval = <object>PyDateTime_FromDateAndTime(
+                                dts.year, dts.month,
+                                dts.day, dts.hour,
+                                dts.min, dts.sec, dts.us)
+            self.value = PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts)
         else:
             raise ValueError("Could not construct Timestamp from argument %s" % type(ts))
 
@@ -175,30 +188,26 @@ cdef class Timestamp(object):
         raise NotImplementedError("Op %d not recognized" % op)
 
     def __add__(self, other):
-        cdef:
-            Timestamp tmp
+        cdef Timestamp ts
 
-        if isinstance(self, Timestamp):
-            tmp = self
-            result = tmp.dtval + other
-        else:
+        if not isinstance(self, Timestamp):
             tmp = other
-            result = tmp.dtval + self
+            other = self
+            self = tmp
 
-        return Timestamp(result)
+        ts = self
+        return Timestamp(ts.dtval + other)
 
     def __sub__(self, other):
-        cdef:
-            Timestamp tmp
+        cdef Timestamp ts
 
-        if isinstance(self, Timestamp):
-            tmp = self
-            result = tmp.dtval - other
-        else:
+        if not isinstance(self, Timestamp):
             tmp = other
-            result = tmp.dtval - self
+            other = self
+            self = tmp
 
-        return Timestamp(result)
+        ts = self
+        return Timestamp(ts.dtval - other)
 
     def __hash__(Timestamp self):
         return self.value
@@ -215,55 +224,6 @@ cdef class Timestamp(object):
     def weekday(Timestamp self):
         return dayofweek(self.dtval.year, self.dtval.month, self.dtval.day)
 
-cdef class Duration:
-    """
-    Absolute length of time, similar to timedelta
-    """
-    cdef:
-        int64_t length, days, seconds, microseconds
-
-    def __init__(self, int64_t days = 0,
-                       int64_t seconds = 0,
-                       int64_t microseconds = 0,
-                       int64_t milliseconds = 0,
-                       int64_t minutes = 0,
-                       int64_t hours = 0,
-                       int64_t weeks = 0):
-
-        self.days = days
-        self.seconds = seconds
-        self.microseconds = microseconds
-        self.length = (microseconds + 1000 * (milliseconds
-                                    + 1000 * (seconds
-                                    + 60   * (minutes
-                                    + 60   * (hours
-                                    + 24   * (days
-                                    +  7   * weeks))))))
-
-    @staticmethod
-    def from_micros(int64_t length):
-        return Duration(microseconds = length)
-
-    property length:
-        def __get__(self):
-            return self.length
-
-    property microseconds:
-        def __get__(self):
-            return self.microseconds # length % 1000000
-
-    property seconds:
-        def __get__(self):
-            return self.seconds      # (length // 1000000) % 86400
-
-    property days:
-        def __get__(self):
-            return self.days         # (self.length // 1000000) // 86400
-
-    def __repr__(self):
-        return "Duration(%d, %d, %d)" % (self.days, self.seconds, self.microseconds)
-
-
 cdef convert_to_res(object res):
     if res == 'microsecond':
         return r_microsecond
@@ -590,12 +550,20 @@ cdef class Delta:
             self.years = 0
 
     def __add__(self, other):
+        if not isinstance(self, Delta):
+            tmp = self
+            self = other
+            other = tmp
+
         if isinstance(other, Delta):
             return self._add_delta(other)
 
         if isinstance(other, Timestamp):
             return self._add_timestamp(other)
 
+        if isinstance(other, datetime):
+            return self._add_timestamp(Timestamp(other))
+
         raise ValueError("Cannot add to Delta")
 
     def _add_timestamp(self, other):
@@ -622,11 +590,11 @@ cdef class Delta:
         if self.leapdays and month > 2 and isleapyear(year):
             days += self.leapdays
         ret = (other.replace(**repl)
-               + Duration(days=days,
-                          hours=self.hours,
-                          minutes=self.minutes,
-                          seconds=self.seconds,
-                          microseconds=self.microseconds))
+               + timedelta(days=days,
+                           hours=self.hours,
+                           minutes=self.minutes,
+                           seconds=self.seconds,
+                           microseconds=self.microseconds))
         if self.weekday:
             weekday, nth = self.weekday.weekday, (self.weekday.n or 1)
 
@@ -636,11 +604,47 @@ cdef class Delta:
             else:
                 jumpdays += (ret.weekday()-weekday)%7
                 jumpdays *= -1
-            ret += Duration(days=jumpdays)
+            ret += timedelta(days=jumpdays)
 
         return ret
 
+    def __richcmp__(self, other, op):
+        if op == 3:
+            return not (self == other)
+        elif op == 2:
+            if not isinstance(other, Delta):
+                return False
+            if self.weekday or other.weekday:
+                if not self.weekday or not other.weekday:
+                    return False
+                if self.weekday.weekday != other.weekday.weekday:
+                    return False
+                n1, n2 = self.weekday.n, other.weekday.n
+                if n1 != n2 and not ((not n1 or n1 == 1) and (not n2 or n2 == 1)):
+                    return False
+            return (self.years == other.years and
+                    self.months == other.months and
+                    self.days == other.days and
+                    self.hours == other.hours and
+                    self.minutes == other.minutes and
+                    self.seconds == other.seconds and
+                    self.leapdays == other.leapdays and
+                    self.year == other.year and
+                    self.month == other.month and
+                    self.day == other.day and
+                    self.hour == other.hour and
+                    self.minute == other.minute and
+                    self.second == other.second and
+                    self.microsecond == other.microsecond)
+        else:
+            raise NotImplementedError("Delta doesn't implement that comparison")
+
     def _add_delta(self, other):
+        if not isinstance(self, Delta):
+            tmp = self
+            self = other
+            other = tmp
+
         return Delta(years=other.years+self.years,
                     months=other.months+self.months,
                     days=other.days+self.days,
@@ -661,6 +665,11 @@ cdef class Delta:
 
 
     def __sub__(self, other):
+        if not isinstance(self, Delta):
+            tmp = self
+            self = other
+            other = tmp
+
         if isinstance(other, Delta):
             return self._sub_delta(other)
         else:
@@ -704,7 +713,16 @@ cdef class Delta:
                      microsecond=self.microsecond)
 
 
-    def __mul__(self, int f):
+    def __mul__(self, v):
+        cdef int64_t f
+
+        if not isinstance(self, Delta):
+            tmp = self
+            self = v 
+            v = tmp
+
+        f = v
+
         return Delta(years=self.years*f,
                      months=self.months*f,
                      days=self.days*f,
diff --git a/pandas/src/np_datetime.c b/pandas/src/np_datetime.c
index a191b5df5..fefe29567 100644
--- a/pandas/src/np_datetime.c
+++ b/pandas/src/np_datetime.c
@@ -15,14 +15,8 @@
 #include "numpy/arrayscalars.h"
 #include "np_datetime.h"
 
-/* Days per month, regular year and leap year */
-int _days_per_month_table[2][12] = {
-    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
-    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
-};
-
 /* Exported as DATETIMEUNITS in multiarraymodule.c */
-char *_datetime_strings[NPY_DATETIME_NUMUNITS] = {
+static char *_datetime_strings[NPY_DATETIME_NUMUNITS] = {
     NPY_STR_Y,
     NPY_STR_M,
     NPY_STR_W,
diff --git a/pandas/src/np_datetime.h b/pandas/src/np_datetime.h
index e4533990e..a6e4a9b30 100644
--- a/pandas/src/np_datetime.h
+++ b/pandas/src/np_datetime.h
@@ -18,14 +18,18 @@ int convert_pydatetime_to_datetimestruct(PyObject *obj, npy_datetimestruct *out,
 
 int dayofweek(int y, int m, int d);
 
+/* Days per month, regular year and leap year */
+static int _days_per_month_table[2][12] = {
+    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
+    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
+};
+
 // stuff numpy needs in header
 // ----------------------------------------------------------------------------
 
 int is_leapyear(npy_int64 year);
 
-char *_datetime_strings[NPY_DATETIME_NUMUNITS];
-
-int _days_per_month_table[2][12];
+static char *_datetime_strings[NPY_DATETIME_NUMUNITS];
 
 /*
  * Converts a datetime from a datetimestruct to a datetime based
diff --git a/pandas/tests/test_datetools.py b/pandas/tests/test_datetools.py
index 9073d030e..a10d90d5d 100644
--- a/pandas/tests/test_datetools.py
+++ b/pandas/tests/test_datetools.py
@@ -12,6 +12,7 @@ from pandas.core.datetools import (
 from nose.tools import assert_raises
 
 import pandas._tseries as lib
+from pandas._tseries import Timestamp, Delta
 
 def test_monthrange():
     import calendar
@@ -67,7 +68,7 @@ def test_datetime64_unbox():
 class TestDateOffset(unittest.TestCase):
 
     def setUp(self):
-        self.d = datetime(2008, 1, 2)
+        self.d = Timestamp(datetime(2008, 1, 2))
 
     def test_repr(self):
         repr(DateOffset())

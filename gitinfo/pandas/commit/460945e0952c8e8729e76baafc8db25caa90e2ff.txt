commit 460945e0952c8e8729e76baafc8db25caa90e2ff
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sun Dec 30 10:40:05 2018 -0800

    Misc separable pieces of #24024 (#24488)

diff --git a/pandas/core/arrays/datetimelike.py b/pandas/core/arrays/datetimelike.py
index 992410232..5de9fd9bb 100644
--- a/pandas/core/arrays/datetimelike.py
+++ b/pandas/core/arrays/datetimelike.py
@@ -15,7 +15,7 @@ import pandas.compat as compat
 from pandas.compat.numpy import function as nv
 from pandas.errors import (
     AbstractMethodError, NullFrequencyError, PerformanceWarning)
-from pandas.util._decorators import Appender, Substitution, deprecate_kwarg
+from pandas.util._decorators import Appender, Substitution
 
 from pandas.core.dtypes.common import (
     is_bool_dtype, is_categorical_dtype, is_datetime64_any_dtype,
@@ -1078,39 +1078,6 @@ class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin):
             return type(self)(res_values, freq='infer')
         return self._from_sequence(res_values)
 
-    @deprecate_kwarg(old_arg_name='n', new_arg_name='periods')
-    def shift(self, periods, freq=None):
-        """
-        Shift index by desired number of time frequency increments.
-
-        This method is for shifting the values of datetime-like indexes
-        by a specified time increment a given number of times.
-
-        Parameters
-        ----------
-        periods : int
-            Number of periods (or increments) to shift by,
-            can be positive or negative.
-
-            .. versionchanged:: 0.24.0
-
-        freq : pandas.DateOffset, pandas.Timedelta or string, optional
-            Frequency increment to shift by.
-            If None, the index is shifted by its own `freq` attribute.
-            Offset aliases are valid strings, e.g., 'D', 'W', 'M' etc.
-
-        Returns
-        -------
-        pandas.DatetimeIndex
-            Shifted index.
-
-        See Also
-        --------
-        Index.shift : Shift values of Index.
-        PeriodIndex.shift : Shift values of PeriodIndex.
-        """
-        return self._time_shift(periods=periods, freq=freq)
-
     def _time_shift(self, periods, freq=None):
         """
         Shift each value by `periods`.
diff --git a/pandas/core/arrays/period.py b/pandas/core/arrays/period.py
index 5ff244b5f..3cd8b4834 100644
--- a/pandas/core/arrays/period.py
+++ b/pandas/core/arrays/period.py
@@ -435,33 +435,6 @@ class PeriodArray(dtl.DatetimeLikeArrayMixin,
 
     # --------------------------------------------------------------------
 
-    def shift(self, periods=1, fill_value=None):
-        """
-        Shift values by desired number.
-
-        Newly introduced missing values are filled with
-        ``self.dtype.na_value``.
-
-        .. versionadded:: 0.24.0
-
-        Parameters
-        ----------
-        periods : int, default 1
-            The number of periods to shift. Negative values are allowed
-            for shifting backwards.
-        fill_value : optional, default NaT
-
-            .. versionadded:: 0.24.0
-
-        Returns
-        -------
-        shifted : PeriodArray
-        """
-        # TODO(DatetimeArray): remove
-        # The semantics for Index.shift differ from EA.shift
-        # then just call super.
-        return ExtensionArray.shift(self, periods, fill_value=fill_value)
-
     def _time_shift(self, n, freq=None):
         """
         Shift each value by `periods`.
diff --git a/pandas/core/groupby/groupby.py b/pandas/core/groupby/groupby.py
index 60b6c8434..6a8221ce4 100644
--- a/pandas/core/groupby/groupby.py
+++ b/pandas/core/groupby/groupby.py
@@ -759,7 +759,7 @@ b  2""")
 
         """
         if obj.ndim > 1:
-            dtype = obj.values.dtype
+            dtype = obj._values.dtype
         else:
             dtype = obj.dtype
 
@@ -768,7 +768,7 @@ b  2""")
                 # The function can return something of any type, so check
                 # if the type is compatible with the calling EA.
                 try:
-                    result = obj.values._from_sequence(result)
+                    result = obj._values._from_sequence(result, dtype=dtype)
                 except Exception:
                     # https://github.com/pandas-dev/pandas/issues/22850
                     # pandas has no control over what 3rd-party ExtensionArrays
diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index 36bf4ba5d..07aec6a0d 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -602,36 +602,6 @@ class Index(IndexOpsMixin, PandasObject):
                 pass
         return Index(values, **attributes)
 
-    def _deepcopy_if_needed(self, orig, copy=False):
-        """
-        Make a copy of self if data coincides (in memory) with orig.
-        Subclasses should override this if self._base is not an ndarray.
-
-        .. versionadded:: 0.19.0
-
-        Parameters
-        ----------
-        orig : ndarray
-            other ndarray to compare self._data against
-        copy : boolean, default False
-            when False, do not run any check, just return self
-
-        Returns
-        -------
-        A copy of self if needed, otherwise self : Index
-        """
-        if copy:
-            # Retrieve the "base objects", i.e. the original memory allocations
-            if not isinstance(orig, np.ndarray):
-                # orig is a DatetimeIndex
-                orig = orig.values
-            orig = orig if orig.base is None else orig.base
-            new = self._data if self._data.base is None else self._data.base
-            if orig is new:
-                return self.copy(deep=True)
-
-        return self
-
     def _update_inplace(self, result, **kwargs):
         # guard when called from IndexOpsMixin
         raise TypeError("Index can't be updated inplace")
diff --git a/pandas/core/indexes/datetimelike.py b/pandas/core/indexes/datetimelike.py
index d090d0e7d..3b6e10de1 100644
--- a/pandas/core/indexes/datetimelike.py
+++ b/pandas/core/indexes/datetimelike.py
@@ -603,9 +603,37 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
         return type(self)(result, name=self.name)
 
     @deprecate_kwarg(old_arg_name='n', new_arg_name='periods')
-    @Appender(DatetimeLikeArrayMixin.shift.__doc__)
     def shift(self, periods, freq=None):
-        result = self._eadata.shift(periods, freq=freq)
+        """
+        Shift index by desired number of time frequency increments.
+
+        This method is for shifting the values of datetime-like indexes
+        by a specified time increment a given number of times.
+
+        Parameters
+        ----------
+        periods : int
+            Number of periods (or increments) to shift by,
+            can be positive or negative.
+
+            .. versionchanged:: 0.24.0
+
+        freq : pandas.DateOffset, pandas.Timedelta or string, optional
+            Frequency increment to shift by.
+            If None, the index is shifted by its own `freq` attribute.
+            Offset aliases are valid strings, e.g., 'D', 'W', 'M' etc.
+
+        Returns
+        -------
+        pandas.DatetimeIndex
+            Shifted index.
+
+        See Also
+        --------
+        Index.shift : Shift values of Index.
+        PeriodIndex.shift : Shift values of PeriodIndex.
+        """
+        result = self._eadata._time_shift(periods, freq=freq)
         return type(self)(result, name=self.name)
 
 
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index a8651a25e..ffee263c0 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -299,12 +299,6 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index, DatetimeDelegateMixin):
 
         # - Cases checked above all return/raise before reaching here - #
 
-        # This allows to later ensure that the 'copy' parameter is honored:
-        if isinstance(data, Index):
-            ref_to_data = data._data
-        else:
-            ref_to_data = data
-
         if name is None and hasattr(data, 'name'):
             name = data.name
 
@@ -314,8 +308,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index, DatetimeDelegateMixin):
 
         subarr = cls._simple_new(dtarr._data, name=name,
                                  freq=dtarr.freq, tz=dtarr.tz)
-
-        return subarr._deepcopy_if_needed(ref_to_data, copy)
+        return subarr
 
     @classmethod
     def _simple_new(cls, values, name=None, freq=None, tz=None, dtype=None):
diff --git a/pandas/tests/arithmetic/test_datetime64.py b/pandas/tests/arithmetic/test_datetime64.py
index 44817467b..d4e82fe26 100644
--- a/pandas/tests/arithmetic/test_datetime64.py
+++ b/pandas/tests/arithmetic/test_datetime64.py
@@ -1596,6 +1596,8 @@ class TestTimestampSeriesArithmetic(object):
             # with 'operate' (from core/ops.py) for the ops that are not
             # defined
             op = getattr(get_ser, op_str, None)
+            # Previously, _validate_for_numeric_binop in core/indexes/base.py
+            # did this for us.
             with pytest.raises(TypeError,
                                match='operate|[cC]annot|unsupported operand'):
                 op(test_ser)
diff --git a/pandas/tests/indexes/timedeltas/test_astype.py b/pandas/tests/indexes/timedeltas/test_astype.py
index 088322d9f..0085b704f 100644
--- a/pandas/tests/indexes/timedeltas/test_astype.py
+++ b/pandas/tests/indexes/timedeltas/test_astype.py
@@ -88,12 +88,12 @@ class TestTimedeltaIndex(object):
         with pytest.raises(TypeError, match=msg):
             idx.astype(dtype)
 
-    @pytest.mark.parametrize('tz', [None, 'US/Central'])
-    def test_astype_category(self, tz):
-        obj = pd.date_range("2000", periods=2, tz=tz)
+    def test_astype_category(self):
+        obj = pd.timedelta_range("1H", periods=2, freq='H')
+
         result = obj.astype('category')
-        expected = pd.CategoricalIndex([pd.Timestamp('2000-01-01', tz=tz),
-                                        pd.Timestamp('2000-01-02', tz=tz)])
+        expected = pd.CategoricalIndex([pd.Timedelta('1H'),
+                                        pd.Timedelta('2H')])
         tm.assert_index_equal(result, expected)
 
         # TODO: Use \._data following composition changeover

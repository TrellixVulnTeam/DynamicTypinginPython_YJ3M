commit 6f8e09e8b2e16c8f2a908912df17240fd8513d8b
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Sep 5 23:17:46 2011 -0400

    DOC: reshape docs. man that is cool

diff --git a/doc/source/groupby.rst b/doc/source/groupby.rst
index 597bf38ac..0913c4fdc 100644
--- a/doc/source/groupby.rst
+++ b/doc/source/groupby.rst
@@ -246,6 +246,13 @@ changed by using the ``as_index`` option:
    grouped = df.groupby(['A', 'B'], as_index=False)
    grouped.aggregate(np.sum)
 
+Note that you could use the ``delevel`` DataFrame function to achieve the same
+result as the column names are stored in the resulting ``MultiIndex``:
+
+.. ipython:: python
+
+   df.groupby(['A', 'B']).sum().delevel()
+
 Applying multiple functions at once
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index d3dd30f52..bfb8b361b 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -379,6 +379,18 @@ can find yourself working with hierarchically-indexed data without creating a
 ``MultiIndex`` explicitly yourself. However, when loading data from a file, you
 may wish to generate your own ``MultiIndex`` when preparing the data set.
 
+Level names
+~~~~~~~~~~~
+
+All of the ``MultiIndex`` constructors accept a ``names`` argument which stores
+string names for the levels themselves. This will get increasingly integrated
+in to groupby and reshaping routines. If no names are provided, some arbitrary
+ones will be assigned:
+
+.. ipython:: python
+
+   index.names
+
 Basic indexing on axis with MultiIndex
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
@@ -511,6 +523,23 @@ However:
    >>> s.ix[('a', 'b'):('b', 'a')]
    Exception: MultiIndex lexsort depth 1, key was length 2
 
+The ``delevel`` DataFrame function
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+As a convenience, there is a new function on DataFrame called ``delevel`` which
+takes a ``MultiIndex`` on the rows and turns the levels into columns of the
+DataFrame:
+
+.. ipython:: python
+
+   df
+   df.delevel()
+
+The output is more similar to a SQL table or a record array. The names for the
+columns derived from the ``MultiIndex`` are the ones stored in the ``names``
+attribute. These will get automatically assigned in various places where
+``MultiIndex`` is created, for example :ref:`GroupBy <groupby>`.
+
 Some gory internal details
 ~~~~~~~~~~~~~~~~~~~~~~~~~~
 
diff --git a/doc/source/reshaping.rst b/doc/source/reshaping.rst
index 896e40b02..c395416ca 100644
--- a/doc/source/reshaping.rst
+++ b/doc/source/reshaping.rst
@@ -110,4 +110,69 @@ essentially what these functions do:
   - ``unstack``: inverse operation from ``stack``; "pivot" index level to
     produce reshaped DataFrame
 
-Actually very hard to explain in words; the clearest way is by example.
+Actually very hard to explain in words; the clearest way is by example. Let's
+take a prior example data set from the hierarchical indexing section:
+
+.. ipython:: python
+
+   tuples = zip(*[['bar', 'bar', 'baz', 'baz',
+                   'foo', 'foo', 'qux', 'qux'],
+                  ['one', 'two', 'one', 'two',
+                   'one', 'two', 'one', 'two']])
+   index = MultiIndex.from_tuples(tuples)
+   df = DataFrame(randn(8, 2), index=index, columns=['A', 'B'])
+   df2 = df[:4]
+   df2
+
+The ``stack`` function "compresses" a level in the DataFrame's columns to
+produce either:
+
+  - A Series, in the case of a simple column Index
+  - A DataFrame, in the case of a ``MultiIndex`` in the columns
+
+If the columns have a ``MultiIndex``, you can choose which level to stack. The
+stacked level becomes the new lowest level in a ``MultiIndex`` on the columns:
+
+.. ipython:: python
+
+   stacked = df2.stack()
+   stacked
+
+With a "stacked" DataFrame or Series (having a ``MultiIndex`` as the
+``index``), the inverse operation of ``stack`` is ``unstack``, which by default
+unstacks the **last level**:
+
+.. ipython:: python
+
+   stacked.unstack()
+   stacked.unstack(1)
+   stacked.unstack(0)
+
+These functions are very intelligent about handling missing data and do not
+expect each subgroup within the hierarchical index to have the same set of
+labels. They also can handle the index being unsorted (but you can make it
+sorted by calling ``sortlevel``, of course). Here is a more complex example:
+
+.. ipython:: python
+
+   columns = MultiIndex.from_tuples([('A', 'cat'), ('B', 'dog'),
+                                     ('B', 'cat'), ('A', 'dog')])
+   df = DataFrame(randn(8, 4), index=index, columns=columns)
+   df2 = df.ix[[0, 1, 2, 4, 5, 7]]
+   df2
+
+As mentioned above, ``stack`` can be called with a ``level`` argument to select
+which level in the columns to stack:
+
+.. ipython:: python
+
+   df2.stack(1)
+   df2.stack(0)
+
+Unstacking when the columns are a ``MultiIndex`` is also careful about doing
+the right thing:
+
+.. ipython:: python
+
+   df[:3].unstack(0)
+   df2.unstack(1)

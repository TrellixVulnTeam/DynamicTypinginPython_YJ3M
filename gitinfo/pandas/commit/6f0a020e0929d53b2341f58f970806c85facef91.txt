commit 6f0a020e0929d53b2341f58f970806c85facef91
Author: Sinhrks <sinhrks@gmail.com>
Date:   Thu Jul 14 17:15:23 2016 +0900

    TST: reorganize tools.tests (#13619)

diff --git a/pandas/tools/tests/test_concat.py b/pandas/tools/tests/test_concat.py
index a8c86657a..568cf63c0 100644
--- a/pandas/tools/tests/test_concat.py
+++ b/pandas/tools/tests/test_concat.py
@@ -17,7 +17,7 @@ from pandas.util.testing import (assert_frame_equal,
                                  assert_almost_equal)
 
 
-class TestConcatenate(tm.TestCase):
+class ConcatenateBase(tm.TestCase):
 
     _multiprocess_can_split_ = True
 
@@ -26,6 +26,9 @@ class TestConcatenate(tm.TestCase):
         self.mixed_frame = self.frame.copy()
         self.mixed_frame['foo'] = 'bar'
 
+
+class TestAppend(ConcatenateBase):
+
     def test_append(self):
         begin_index = self.frame.index[:5]
         end_index = self.frame.index[5:]
@@ -142,42 +145,32 @@ class TestConcatenate(tm.TestCase):
         result = df1.append(df2)
         self.assertEqual(result.index.name, 'A')
 
-    def test_join_many(self):
-        df = DataFrame(np.random.randn(10, 6), columns=list('abcdef'))
-        df_list = [df[['a', 'b']], df[['c', 'd']], df[['e', 'f']]]
-
-        joined = df_list[0].join(df_list[1:])
-        tm.assert_frame_equal(joined, df)
-
-        df_list = [df[['a', 'b']][:-2],
-                   df[['c', 'd']][2:], df[['e', 'f']][1:9]]
-
-        def _check_diff_index(df_list, result, exp_index):
-            reindexed = [x.reindex(exp_index) for x in df_list]
-            expected = reindexed[0].join(reindexed[1:])
-            tm.assert_frame_equal(result, expected)
-
-        # different join types
-        joined = df_list[0].join(df_list[1:], how='outer')
-        _check_diff_index(df_list, joined, df.index)
-
-        joined = df_list[0].join(df_list[1:])
-        _check_diff_index(df_list, joined, df_list[0].index)
-
-        joined = df_list[0].join(df_list[1:], how='inner')
-        _check_diff_index(df_list, joined, df.index[2:8])
-
-        self.assertRaises(ValueError, df_list[0].join, df_list[1:], on='a')
-
-    def test_join_many_mixed(self):
-        df = DataFrame(np.random.randn(8, 4), columns=['A', 'B', 'C', 'D'])
-        df['key'] = ['foo', 'bar'] * 4
-        df1 = df.ix[:, ['A', 'B']]
-        df2 = df.ix[:, ['C', 'D']]
-        df3 = df.ix[:, ['key']]
-
-        result = df1.join([df2, df3])
-        assert_frame_equal(result, df)
+    def test_append_dtype_coerce(self):
+
+        # GH 4993
+        # appending with datetime will incorrectly convert datetime64
+        import datetime as dt
+        from pandas import NaT
+
+        df1 = DataFrame(index=[1, 2], data=[dt.datetime(2013, 1, 1, 0, 0),
+                                            dt.datetime(2013, 1, 2, 0, 0)],
+                        columns=['start_time'])
+        df2 = DataFrame(index=[4, 5], data=[[dt.datetime(2013, 1, 3, 0, 0),
+                                             dt.datetime(2013, 1, 3, 6, 10)],
+                                            [dt.datetime(2013, 1, 4, 0, 0),
+                                             dt.datetime(2013, 1, 4, 7, 10)]],
+                        columns=['start_time', 'end_time'])
+
+        expected = concat([Series([NaT, NaT, dt.datetime(2013, 1, 3, 6, 10),
+                                   dt.datetime(2013, 1, 4, 7, 10)],
+                                  name='end_time'),
+                           Series([dt.datetime(2013, 1, 1, 0, 0),
+                                   dt.datetime(2013, 1, 2, 0, 0),
+                                   dt.datetime(2013, 1, 3, 0, 0),
+                                   dt.datetime(2013, 1, 4, 0, 0)],
+                                  name='start_time')], axis=1)
+        result = df1.append(df2, ignore_index=True)
+        assert_frame_equal(result, expected)
 
     def test_append_missing_column_proper_upcast(self):
         df1 = DataFrame({'A': np.array([1, 2, 3, 4], dtype='i8')})
@@ -188,6 +181,9 @@ class TestConcatenate(tm.TestCase):
         self.assertEqual(appended['A'].dtype, 'f8')
         self.assertEqual(appended['B'].dtype, 'O')
 
+
+class TestConcatenate(ConcatenateBase):
+
     def test_concat_copy(self):
 
         df = DataFrame(np.random.randn(4, 3))
@@ -524,35 +520,6 @@ class TestConcatenate(tm.TestCase):
         # it works
         concat([df1, df2])
 
-    def test_join_dups(self):
-
-        # joining dups
-        df = concat([DataFrame(np.random.randn(10, 4),
-                               columns=['A', 'A', 'B', 'B']),
-                     DataFrame(np.random.randint(0, 10, size=20)
-                               .reshape(10, 2),
-                               columns=['A', 'C'])],
-                    axis=1)
-
-        expected = concat([df, df], axis=1)
-        result = df.join(df, rsuffix='_2')
-        result.columns = expected.columns
-        assert_frame_equal(result, expected)
-
-        # GH 4975, invalid join on dups
-        w = DataFrame(np.random.randn(4, 2), columns=["x", "y"])
-        x = DataFrame(np.random.randn(4, 2), columns=["x", "y"])
-        y = DataFrame(np.random.randn(4, 2), columns=["x", "y"])
-        z = DataFrame(np.random.randn(4, 2), columns=["x", "y"])
-
-        dta = x.merge(y, left_index=True, right_index=True).merge(
-            z, left_index=True, right_index=True, how="outer")
-        dta = dta.merge(w, left_index=True, right_index=True)
-        expected = concat([x, y, z, w], axis=1)
-        expected.columns = ['x_x', 'y_x', 'x_y',
-                            'y_y', 'x_x', 'y_x', 'x_y', 'y_y']
-        assert_frame_equal(dta, expected)
-
     def test_handle_empty_objects(self):
         df = DataFrame(np.random.randn(10, 4), columns=list('abcd'))
 
@@ -649,86 +616,40 @@ class TestConcatenate(tm.TestCase):
         panel = tm.makePanel()
         self.assertRaises(ValueError, lambda: concat([panel, s1], axis=1))
 
-    def test_panel_join(self):
-        panel = tm.makePanel()
-        tm.add_nans(panel)
-
-        p1 = panel.ix[:2, :10, :3]
-        p2 = panel.ix[2:, 5:, 2:]
-
-        # left join
-        result = p1.join(p2)
-        expected = p1.copy()
-        expected['ItemC'] = p2['ItemC']
-        tm.assert_panel_equal(result, expected)
-
-        # right join
-        result = p1.join(p2, how='right')
-        expected = p2.copy()
-        expected['ItemA'] = p1['ItemA']
-        expected['ItemB'] = p1['ItemB']
-        expected = expected.reindex(items=['ItemA', 'ItemB', 'ItemC'])
-        tm.assert_panel_equal(result, expected)
-
-        # inner join
-        result = p1.join(p2, how='inner')
-        expected = panel.ix[:, 5:10, 2:3]
-        tm.assert_panel_equal(result, expected)
-
-        # outer join
-        result = p1.join(p2, how='outer')
-        expected = p1.reindex(major=panel.major_axis,
-                              minor=panel.minor_axis)
-        expected = expected.join(p2.reindex(major=panel.major_axis,
-                                            minor=panel.minor_axis))
-        tm.assert_panel_equal(result, expected)
-
-    def test_panel_join_overlap(self):
-        panel = tm.makePanel()
-        tm.add_nans(panel)
-
-        p1 = panel.ix[['ItemA', 'ItemB', 'ItemC']]
-        p2 = panel.ix[['ItemB', 'ItemC']]
-
-        # Expected index is
-        #
-        # ItemA, ItemB_p1, ItemC_p1, ItemB_p2, ItemC_p2
-        joined = p1.join(p2, lsuffix='_p1', rsuffix='_p2')
-        p1_suf = p1.ix[['ItemB', 'ItemC']].add_suffix('_p1')
-        p2_suf = p2.ix[['ItemB', 'ItemC']].add_suffix('_p2')
-        no_overlap = panel.ix[['ItemA']]
-        expected = no_overlap.join(p1_suf.join(p2_suf))
-        tm.assert_panel_equal(joined, expected)
-
-    def test_panel_join_many(self):
-        tm.K = 10
-        panel = tm.makePanel()
-        tm.K = 4
+    def test_empty_dtype_coerce(self):
 
-        panels = [panel.ix[:2], panel.ix[2:6], panel.ix[6:]]
+        # xref to #12411
+        # xref to #12045
+        # xref to #11594
+        # see below
 
-        joined = panels[0].join(panels[1:])
-        tm.assert_panel_equal(joined, panel)
+        # 10571
+        df1 = DataFrame(data=[[1, None], [2, None]], columns=['a', 'b'])
+        df2 = DataFrame(data=[[3, None], [4, None]], columns=['a', 'b'])
+        result = concat([df1, df2])
+        expected = df1.dtypes
+        tm.assert_series_equal(result.dtypes, expected)
 
-        panels = [panel.ix[:2, :-5], panel.ix[2:6, 2:], panel.ix[6:, 5:-7]]
+    def test_dtype_coerceion(self):
 
-        data_dict = {}
-        for p in panels:
-            data_dict.update(p.iteritems())
+        # 12411
+        df = DataFrame({'date': [pd.Timestamp('20130101').tz_localize('UTC'),
+                                 pd.NaT]})
 
-        joined = panels[0].join(panels[1:], how='inner')
-        expected = Panel.from_dict(data_dict, intersect=True)
-        tm.assert_panel_equal(joined, expected)
+        result = concat([df.iloc[[0]], df.iloc[[1]]])
+        tm.assert_series_equal(result.dtypes, df.dtypes)
 
-        joined = panels[0].join(panels[1:], how='outer')
-        expected = Panel.from_dict(data_dict, intersect=False)
-        tm.assert_panel_equal(joined, expected)
+        # 12045
+        import datetime
+        df = DataFrame({'date': [datetime.datetime(2012, 1, 1),
+                                 datetime.datetime(1012, 1, 2)]})
+        result = concat([df.iloc[[0]], df.iloc[[1]]])
+        tm.assert_series_equal(result.dtypes, df.dtypes)
 
-        # edge cases
-        self.assertRaises(ValueError, panels[0].join, panels[1:],
-                          how='outer', lsuffix='foo', rsuffix='bar')
-        self.assertRaises(ValueError, panels[0].join, panels[1:],
-                          how='right')
+        # 11594
+        df = DataFrame({'text': ['some words'] + [None] * 9})
+        result = concat([df.iloc[[0]], df.iloc[[1]]])
+        tm.assert_series_equal(result.dtypes, df.dtypes)
 
     def test_panel_concat_other_axes(self):
         panel = tm.makePanel()
@@ -1080,6 +1001,239 @@ bar2,12,13,14,15
         expected = read_csv(StringIO(data))
         assert_frame_equal(result, expected)
 
+    def test_concat_NaT_series(self):
+        # GH 11693
+        # test for merging NaT series with datetime series.
+        x = Series(date_range('20151124 08:00', '20151124 09:00',
+                              freq='1h', tz='US/Eastern'))
+        y = Series(pd.NaT, index=[0, 1], dtype='datetime64[ns, US/Eastern]')
+        expected = Series([x[0], x[1], pd.NaT, pd.NaT])
+
+        result = concat([x, y], ignore_index=True)
+        tm.assert_series_equal(result, expected)
+
+        # all NaT with tz
+        expected = Series(pd.NaT, index=range(4),
+                          dtype='datetime64[ns, US/Eastern]')
+        result = pd.concat([y, y], ignore_index=True)
+        tm.assert_series_equal(result, expected)
+
+        # without tz
+        x = pd.Series(pd.date_range('20151124 08:00',
+                                    '20151124 09:00', freq='1h'))
+        y = pd.Series(pd.date_range('20151124 10:00',
+                                    '20151124 11:00', freq='1h'))
+        y[:] = pd.NaT
+        expected = pd.Series([x[0], x[1], pd.NaT, pd.NaT])
+        result = pd.concat([x, y], ignore_index=True)
+        tm.assert_series_equal(result, expected)
+
+        # all NaT without tz
+        x[:] = pd.NaT
+        expected = pd.Series(pd.NaT, index=range(4),
+                             dtype='datetime64[ns]')
+        result = pd.concat([x, y], ignore_index=True)
+        tm.assert_series_equal(result, expected)
+
+    def test_concat_tz_frame(self):
+        df2 = DataFrame(dict(A=pd.Timestamp('20130102', tz='US/Eastern'),
+                             B=pd.Timestamp('20130603', tz='CET')),
+                        index=range(5))
+
+        # concat
+        df3 = pd.concat([df2.A.to_frame(), df2.B.to_frame()], axis=1)
+        assert_frame_equal(df2, df3)
+
+    def test_concat_tz_series(self):
+        # GH 11755
+        # tz and no tz
+        x = Series(date_range('20151124 08:00',
+                              '20151124 09:00',
+                              freq='1h', tz='UTC'))
+        y = Series(date_range('2012-01-01', '2012-01-02'))
+        expected = Series([x[0], x[1], y[0], y[1]],
+                          dtype='object')
+        result = concat([x, y], ignore_index=True)
+        tm.assert_series_equal(result, expected)
+
+        # GH 11887
+        # concat tz and object
+        x = Series(date_range('20151124 08:00',
+                              '20151124 09:00',
+                              freq='1h', tz='UTC'))
+        y = Series(['a', 'b'])
+        expected = Series([x[0], x[1], y[0], y[1]],
+                          dtype='object')
+        result = concat([x, y], ignore_index=True)
+        tm.assert_series_equal(result, expected)
+
+        # 12217
+        # 12306 fixed I think
+
+        # Concat'ing two UTC times
+        first = pd.DataFrame([[datetime(2016, 1, 1)]])
+        first[0] = first[0].dt.tz_localize('UTC')
+
+        second = pd.DataFrame([[datetime(2016, 1, 2)]])
+        second[0] = second[0].dt.tz_localize('UTC')
+
+        result = pd.concat([first, second])
+        self.assertEqual(result[0].dtype, 'datetime64[ns, UTC]')
+
+        # Concat'ing two London times
+        first = pd.DataFrame([[datetime(2016, 1, 1)]])
+        first[0] = first[0].dt.tz_localize('Europe/London')
+
+        second = pd.DataFrame([[datetime(2016, 1, 2)]])
+        second[0] = second[0].dt.tz_localize('Europe/London')
+
+        result = pd.concat([first, second])
+        self.assertEqual(result[0].dtype, 'datetime64[ns, Europe/London]')
+
+        # Concat'ing 2+1 London times
+        first = pd.DataFrame([[datetime(2016, 1, 1)], [datetime(2016, 1, 2)]])
+        first[0] = first[0].dt.tz_localize('Europe/London')
+
+        second = pd.DataFrame([[datetime(2016, 1, 3)]])
+        second[0] = second[0].dt.tz_localize('Europe/London')
+
+        result = pd.concat([first, second])
+        self.assertEqual(result[0].dtype, 'datetime64[ns, Europe/London]')
+
+        # Concat'ing 1+2 London times
+        first = pd.DataFrame([[datetime(2016, 1, 1)]])
+        first[0] = first[0].dt.tz_localize('Europe/London')
+
+        second = pd.DataFrame([[datetime(2016, 1, 2)], [datetime(2016, 1, 3)]])
+        second[0] = second[0].dt.tz_localize('Europe/London')
+
+        result = pd.concat([first, second])
+        self.assertEqual(result[0].dtype, 'datetime64[ns, Europe/London]')
+
+    def test_concat_tz_series_with_datetimelike(self):
+        # GH 12620
+        # tz and timedelta
+        x = [pd.Timestamp('2011-01-01', tz='US/Eastern'),
+             pd.Timestamp('2011-02-01', tz='US/Eastern')]
+        y = [pd.Timedelta('1 day'), pd.Timedelta('2 day')]
+        result = concat([pd.Series(x), pd.Series(y)], ignore_index=True)
+        tm.assert_series_equal(result, pd.Series(x + y, dtype='object'))
+
+        # tz and period
+        y = [pd.Period('2011-03', freq='M'), pd.Period('2011-04', freq='M')]
+        result = concat([pd.Series(x), pd.Series(y)], ignore_index=True)
+        tm.assert_series_equal(result, pd.Series(x + y, dtype='object'))
+
+    def test_concat_tz_series_tzlocal(self):
+        # GH 13583
+        tm._skip_if_no_dateutil()
+        import dateutil
+        x = [pd.Timestamp('2011-01-01', tz=dateutil.tz.tzlocal()),
+             pd.Timestamp('2011-02-01', tz=dateutil.tz.tzlocal())]
+        y = [pd.Timestamp('2012-01-01', tz=dateutil.tz.tzlocal()),
+             pd.Timestamp('2012-02-01', tz=dateutil.tz.tzlocal())]
+        result = concat([pd.Series(x), pd.Series(y)], ignore_index=True)
+        tm.assert_series_equal(result, pd.Series(x + y))
+        self.assertEqual(result.dtype, 'datetime64[ns, tzlocal()]')
+
+    def test_concat_period_series(self):
+        x = Series(pd.PeriodIndex(['2015-11-01', '2015-12-01'], freq='D'))
+        y = Series(pd.PeriodIndex(['2015-10-01', '2016-01-01'], freq='D'))
+        expected = Series([x[0], x[1], y[0], y[1]], dtype='object')
+        result = concat([x, y], ignore_index=True)
+        tm.assert_series_equal(result, expected)
+        self.assertEqual(result.dtype, 'object')
+
+        # different freq
+        x = Series(pd.PeriodIndex(['2015-11-01', '2015-12-01'], freq='D'))
+        y = Series(pd.PeriodIndex(['2015-10-01', '2016-01-01'], freq='M'))
+        expected = Series([x[0], x[1], y[0], y[1]], dtype='object')
+        result = concat([x, y], ignore_index=True)
+        tm.assert_series_equal(result, expected)
+        self.assertEqual(result.dtype, 'object')
+
+        x = Series(pd.PeriodIndex(['2015-11-01', '2015-12-01'], freq='D'))
+        y = Series(pd.PeriodIndex(['2015-11-01', '2015-12-01'], freq='M'))
+        expected = Series([x[0], x[1], y[0], y[1]], dtype='object')
+        result = concat([x, y], ignore_index=True)
+        tm.assert_series_equal(result, expected)
+        self.assertEqual(result.dtype, 'object')
+
+        # non-period
+        x = Series(pd.PeriodIndex(['2015-11-01', '2015-12-01'], freq='D'))
+        y = Series(pd.DatetimeIndex(['2015-11-01', '2015-12-01']))
+        expected = Series([x[0], x[1], y[0], y[1]], dtype='object')
+        result = concat([x, y], ignore_index=True)
+        tm.assert_series_equal(result, expected)
+        self.assertEqual(result.dtype, 'object')
+
+        x = Series(pd.PeriodIndex(['2015-11-01', '2015-12-01'], freq='D'))
+        y = Series(['A', 'B'])
+        expected = Series([x[0], x[1], y[0], y[1]], dtype='object')
+        result = concat([x, y], ignore_index=True)
+        tm.assert_series_equal(result, expected)
+        self.assertEqual(result.dtype, 'object')
+
+    def test_concat_empty_series(self):
+        # GH 11082
+        s1 = pd.Series([1, 2, 3], name='x')
+        s2 = pd.Series(name='y')
+        res = pd.concat([s1, s2], axis=1)
+        exp = pd.DataFrame({'x': [1, 2, 3], 'y': [np.nan, np.nan, np.nan]})
+        tm.assert_frame_equal(res, exp)
+
+        s1 = pd.Series([1, 2, 3], name='x')
+        s2 = pd.Series(name='y')
+        res = pd.concat([s1, s2], axis=0)
+        # name will be reset
+        exp = pd.Series([1, 2, 3])
+        tm.assert_series_equal(res, exp)
+
+        # empty Series with no name
+        s1 = pd.Series([1, 2, 3], name='x')
+        s2 = pd.Series(name=None)
+        res = pd.concat([s1, s2], axis=1)
+        exp = pd.DataFrame({'x': [1, 2, 3], 0: [np.nan, np.nan, np.nan]},
+                           columns=['x', 0])
+        tm.assert_frame_equal(res, exp)
+
+    def test_default_index(self):
+        # is_series and ignore_index
+        s1 = pd.Series([1, 2, 3], name='x')
+        s2 = pd.Series([4, 5, 6], name='y')
+        res = pd.concat([s1, s2], axis=1, ignore_index=True)
+        self.assertIsInstance(res.columns, pd.RangeIndex)
+        exp = pd.DataFrame([[1, 4], [2, 5], [3, 6]])
+        # use check_index_type=True to check the result have
+        # RangeIndex (default index)
+        tm.assert_frame_equal(res, exp, check_index_type=True,
+                              check_column_type=True)
+
+        # is_series and all inputs have no names
+        s1 = pd.Series([1, 2, 3])
+        s2 = pd.Series([4, 5, 6])
+        res = pd.concat([s1, s2], axis=1, ignore_index=False)
+        self.assertIsInstance(res.columns, pd.RangeIndex)
+        exp = pd.DataFrame([[1, 4], [2, 5], [3, 6]])
+        exp.columns = pd.RangeIndex(2)
+        tm.assert_frame_equal(res, exp, check_index_type=True,
+                              check_column_type=True)
+
+        # is_dataframe and ignore_index
+        df1 = pd.DataFrame({'A': [1, 2], 'B': [5, 6]})
+        df2 = pd.DataFrame({'A': [3, 4], 'B': [7, 8]})
+
+        res = pd.concat([df1, df2], axis=0, ignore_index=True)
+        exp = pd.DataFrame([[1, 5], [2, 6], [3, 7], [4, 8]],
+                           columns=['A', 'B'])
+        tm.assert_frame_equal(res, exp, check_index_type=True,
+                              check_column_type=True)
+
+        res = pd.concat([df1, df2], axis=1, ignore_index=True)
+        exp = pd.DataFrame([[1, 5, 3, 7], [2, 6, 4, 8]])
+        tm.assert_frame_equal(res, exp, check_index_type=True,
+                              check_column_type=True)
+
 
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
diff --git a/pandas/tools/tests/test_join.py b/pandas/tools/tests/test_join.py
new file mode 100644
index 000000000..86aee0b4a
--- /dev/null
+++ b/pandas/tools/tests/test_join.py
@@ -0,0 +1,787 @@
+# pylint: disable=E1103
+
+import nose
+
+from numpy.random import randn
+import numpy as np
+
+import pandas as pd
+from pandas.compat import lrange
+import pandas.compat as compat
+from pandas.tools.merge import merge, concat
+from pandas.util.testing import assert_frame_equal
+from pandas import DataFrame, MultiIndex, Series
+
+import pandas.algos as algos
+import pandas.util.testing as tm
+from pandas.tools.tests.test_merge import get_test_data, N, NGROUPS
+
+
+a_ = np.array
+
+
+class TestJoin(tm.TestCase):
+
+    _multiprocess_can_split_ = True
+
+    def setUp(self):
+        # aggregate multiple columns
+        self.df = DataFrame({'key1': get_test_data(),
+                             'key2': get_test_data(),
+                             'data1': np.random.randn(N),
+                             'data2': np.random.randn(N)})
+
+        # exclude a couple keys for fun
+        self.df = self.df[self.df['key2'] > 1]
+
+        self.df2 = DataFrame({'key1': get_test_data(n=N // 5),
+                              'key2': get_test_data(ngroups=NGROUPS // 2,
+                                                    n=N // 5),
+                              'value': np.random.randn(N // 5)})
+
+        index, data = tm.getMixedTypeDict()
+        self.target = DataFrame(data, index=index)
+
+        # Join on string value
+        self.source = DataFrame({'MergedA': data['A'], 'MergedD': data['D']},
+                                index=data['C'])
+
+    def test_cython_left_outer_join(self):
+        left = a_([0, 1, 2, 1, 2, 0, 0, 1, 2, 3, 3], dtype=np.int64)
+        right = a_([1, 1, 0, 4, 2, 2, 1], dtype=np.int64)
+        max_group = 5
+
+        ls, rs = algos.left_outer_join(left, right, max_group)
+
+        exp_ls = left.argsort(kind='mergesort')
+        exp_rs = right.argsort(kind='mergesort')
+
+        exp_li = a_([0, 1, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5,
+                     6, 6, 7, 7, 8, 8, 9, 10])
+        exp_ri = a_([0, 0, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3,
+                     4, 5, 4, 5, 4, 5, -1, -1])
+
+        exp_ls = exp_ls.take(exp_li)
+        exp_ls[exp_li == -1] = -1
+
+        exp_rs = exp_rs.take(exp_ri)
+        exp_rs[exp_ri == -1] = -1
+
+        self.assert_numpy_array_equal(ls, exp_ls, check_dtype=False)
+        self.assert_numpy_array_equal(rs, exp_rs, check_dtype=False)
+
+    def test_cython_right_outer_join(self):
+        left = a_([0, 1, 2, 1, 2, 0, 0, 1, 2, 3, 3], dtype=np.int64)
+        right = a_([1, 1, 0, 4, 2, 2, 1], dtype=np.int64)
+        max_group = 5
+
+        rs, ls = algos.left_outer_join(right, left, max_group)
+
+        exp_ls = left.argsort(kind='mergesort')
+        exp_rs = right.argsort(kind='mergesort')
+
+        #            0        1        1        1
+        exp_li = a_([0, 1, 2, 3, 4, 5, 3, 4, 5, 3, 4, 5,
+                     #            2        2        4
+                     6, 7, 8, 6, 7, 8, -1])
+        exp_ri = a_([0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3,
+                     4, 4, 4, 5, 5, 5, 6])
+
+        exp_ls = exp_ls.take(exp_li)
+        exp_ls[exp_li == -1] = -1
+
+        exp_rs = exp_rs.take(exp_ri)
+        exp_rs[exp_ri == -1] = -1
+
+        self.assert_numpy_array_equal(ls, exp_ls, check_dtype=False)
+        self.assert_numpy_array_equal(rs, exp_rs, check_dtype=False)
+
+    def test_cython_inner_join(self):
+        left = a_([0, 1, 2, 1, 2, 0, 0, 1, 2, 3, 3], dtype=np.int64)
+        right = a_([1, 1, 0, 4, 2, 2, 1, 4], dtype=np.int64)
+        max_group = 5
+
+        ls, rs = algos.inner_join(left, right, max_group)
+
+        exp_ls = left.argsort(kind='mergesort')
+        exp_rs = right.argsort(kind='mergesort')
+
+        exp_li = a_([0, 1, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5,
+                     6, 6, 7, 7, 8, 8])
+        exp_ri = a_([0, 0, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3,
+                     4, 5, 4, 5, 4, 5])
+
+        exp_ls = exp_ls.take(exp_li)
+        exp_ls[exp_li == -1] = -1
+
+        exp_rs = exp_rs.take(exp_ri)
+        exp_rs[exp_ri == -1] = -1
+
+        self.assert_numpy_array_equal(ls, exp_ls, check_dtype=False)
+        self.assert_numpy_array_equal(rs, exp_rs, check_dtype=False)
+
+    def test_left_outer_join(self):
+        joined_key2 = merge(self.df, self.df2, on='key2')
+        _check_join(self.df, self.df2, joined_key2, ['key2'], how='left')
+
+        joined_both = merge(self.df, self.df2)
+        _check_join(self.df, self.df2, joined_both, ['key1', 'key2'],
+                    how='left')
+
+    def test_right_outer_join(self):
+        joined_key2 = merge(self.df, self.df2, on='key2', how='right')
+        _check_join(self.df, self.df2, joined_key2, ['key2'], how='right')
+
+        joined_both = merge(self.df, self.df2, how='right')
+        _check_join(self.df, self.df2, joined_both, ['key1', 'key2'],
+                    how='right')
+
+    def test_full_outer_join(self):
+        joined_key2 = merge(self.df, self.df2, on='key2', how='outer')
+        _check_join(self.df, self.df2, joined_key2, ['key2'], how='outer')
+
+        joined_both = merge(self.df, self.df2, how='outer')
+        _check_join(self.df, self.df2, joined_both, ['key1', 'key2'],
+                    how='outer')
+
+    def test_inner_join(self):
+        joined_key2 = merge(self.df, self.df2, on='key2', how='inner')
+        _check_join(self.df, self.df2, joined_key2, ['key2'], how='inner')
+
+        joined_both = merge(self.df, self.df2, how='inner')
+        _check_join(self.df, self.df2, joined_both, ['key1', 'key2'],
+                    how='inner')
+
+    def test_handle_overlap(self):
+        joined = merge(self.df, self.df2, on='key2',
+                       suffixes=['.foo', '.bar'])
+
+        self.assertIn('key1.foo', joined)
+        self.assertIn('key1.bar', joined)
+
+    def test_handle_overlap_arbitrary_key(self):
+        joined = merge(self.df, self.df2,
+                       left_on='key2', right_on='key1',
+                       suffixes=['.foo', '.bar'])
+        self.assertIn('key1.foo', joined)
+        self.assertIn('key2.bar', joined)
+
+    def test_join_on(self):
+        target = self.target
+        source = self.source
+
+        merged = target.join(source, on='C')
+        self.assert_series_equal(merged['MergedA'], target['A'],
+                                 check_names=False)
+        self.assert_series_equal(merged['MergedD'], target['D'],
+                                 check_names=False)
+
+        # join with duplicates (fix regression from DataFrame/Matrix merge)
+        df = DataFrame({'key': ['a', 'a', 'b', 'b', 'c']})
+        df2 = DataFrame({'value': [0, 1, 2]}, index=['a', 'b', 'c'])
+        joined = df.join(df2, on='key')
+        expected = DataFrame({'key': ['a', 'a', 'b', 'b', 'c'],
+                              'value': [0, 0, 1, 1, 2]})
+        assert_frame_equal(joined, expected)
+
+        # Test when some are missing
+        df_a = DataFrame([[1], [2], [3]], index=['a', 'b', 'c'],
+                         columns=['one'])
+        df_b = DataFrame([['foo'], ['bar']], index=[1, 2],
+                         columns=['two'])
+        df_c = DataFrame([[1], [2]], index=[1, 2],
+                         columns=['three'])
+        joined = df_a.join(df_b, on='one')
+        joined = joined.join(df_c, on='one')
+        self.assertTrue(np.isnan(joined['two']['c']))
+        self.assertTrue(np.isnan(joined['three']['c']))
+
+        # merge column not p resent
+        self.assertRaises(KeyError, target.join, source, on='E')
+
+        # overlap
+        source_copy = source.copy()
+        source_copy['A'] = 0
+        self.assertRaises(ValueError, target.join, source_copy, on='A')
+
+    def test_join_on_fails_with_different_right_index(self):
+        with tm.assertRaises(ValueError):
+            df = DataFrame({'a': np.random.choice(['m', 'f'], size=3),
+                            'b': np.random.randn(3)})
+            df2 = DataFrame({'a': np.random.choice(['m', 'f'], size=10),
+                             'b': np.random.randn(10)},
+                            index=tm.makeCustomIndex(10, 2))
+            merge(df, df2, left_on='a', right_index=True)
+
+    def test_join_on_fails_with_different_left_index(self):
+        with tm.assertRaises(ValueError):
+            df = DataFrame({'a': np.random.choice(['m', 'f'], size=3),
+                            'b': np.random.randn(3)},
+                           index=tm.makeCustomIndex(10, 2))
+            df2 = DataFrame({'a': np.random.choice(['m', 'f'], size=10),
+                             'b': np.random.randn(10)})
+            merge(df, df2, right_on='b', left_index=True)
+
+    def test_join_on_fails_with_different_column_counts(self):
+        with tm.assertRaises(ValueError):
+            df = DataFrame({'a': np.random.choice(['m', 'f'], size=3),
+                            'b': np.random.randn(3)})
+            df2 = DataFrame({'a': np.random.choice(['m', 'f'], size=10),
+                             'b': np.random.randn(10)},
+                            index=tm.makeCustomIndex(10, 2))
+            merge(df, df2, right_on='a', left_on=['a', 'b'])
+
+    def test_join_on_fails_with_wrong_object_type(self):
+        # GH12081
+        wrongly_typed = [Series([0, 1]), 2, 'str', None, np.array([0, 1])]
+        df = DataFrame({'a': [1, 1]})
+
+        for obj in wrongly_typed:
+            with tm.assertRaisesRegexp(ValueError, str(type(obj))):
+                merge(obj, df, left_on='a', right_on='a')
+            with tm.assertRaisesRegexp(ValueError, str(type(obj))):
+                merge(df, obj, left_on='a', right_on='a')
+
+    def test_join_on_pass_vector(self):
+        expected = self.target.join(self.source, on='C')
+        del expected['C']
+
+        join_col = self.target.pop('C')
+        result = self.target.join(self.source, on=join_col)
+        assert_frame_equal(result, expected)
+
+    def test_join_with_len0(self):
+        # nothing to merge
+        merged = self.target.join(self.source.reindex([]), on='C')
+        for col in self.source:
+            self.assertIn(col, merged)
+            self.assertTrue(merged[col].isnull().all())
+
+        merged2 = self.target.join(self.source.reindex([]), on='C',
+                                   how='inner')
+        self.assert_index_equal(merged2.columns, merged.columns)
+        self.assertEqual(len(merged2), 0)
+
+    def test_join_on_inner(self):
+        df = DataFrame({'key': ['a', 'a', 'd', 'b', 'b', 'c']})
+        df2 = DataFrame({'value': [0, 1]}, index=['a', 'b'])
+
+        joined = df.join(df2, on='key', how='inner')
+
+        expected = df.join(df2, on='key')
+        expected = expected[expected['value'].notnull()]
+        self.assert_series_equal(joined['key'], expected['key'],
+                                 check_dtype=False)
+        self.assert_series_equal(joined['value'], expected['value'],
+                                 check_dtype=False)
+        self.assert_index_equal(joined.index, expected.index)
+
+    def test_join_on_singlekey_list(self):
+        df = DataFrame({'key': ['a', 'a', 'b', 'b', 'c']})
+        df2 = DataFrame({'value': [0, 1, 2]}, index=['a', 'b', 'c'])
+
+        # corner cases
+        joined = df.join(df2, on=['key'])
+        expected = df.join(df2, on='key')
+
+        assert_frame_equal(joined, expected)
+
+    def test_join_on_series(self):
+        result = self.target.join(self.source['MergedA'], on='C')
+        expected = self.target.join(self.source[['MergedA']], on='C')
+        assert_frame_equal(result, expected)
+
+    def test_join_on_series_buglet(self):
+        # GH #638
+        df = DataFrame({'a': [1, 1]})
+        ds = Series([2], index=[1], name='b')
+        result = df.join(ds, on='a')
+        expected = DataFrame({'a': [1, 1],
+                              'b': [2, 2]}, index=df.index)
+        tm.assert_frame_equal(result, expected)
+
+    def test_join_index_mixed(self):
+        df1 = DataFrame({'A': 1., 'B': 2, 'C': 'foo', 'D': True},
+                        index=np.arange(10),
+                        columns=['A', 'B', 'C', 'D'])
+        self.assertEqual(df1['B'].dtype, np.int64)
+        self.assertEqual(df1['D'].dtype, np.bool_)
+
+        df2 = DataFrame({'A': 1., 'B': 2, 'C': 'foo', 'D': True},
+                        index=np.arange(0, 10, 2),
+                        columns=['A', 'B', 'C', 'D'])
+
+        # overlap
+        joined = df1.join(df2, lsuffix='_one', rsuffix='_two')
+        expected_columns = ['A_one', 'B_one', 'C_one', 'D_one',
+                            'A_two', 'B_two', 'C_two', 'D_two']
+        df1.columns = expected_columns[:4]
+        df2.columns = expected_columns[4:]
+        expected = _join_by_hand(df1, df2)
+        assert_frame_equal(joined, expected)
+
+        # no overlapping blocks
+        df1 = DataFrame(index=np.arange(10))
+        df1['bool'] = True
+        df1['string'] = 'foo'
+
+        df2 = DataFrame(index=np.arange(5, 15))
+        df2['int'] = 1
+        df2['float'] = 1.
+
+        for kind in ['inner', 'outer', 'left', 'right']:
+
+            joined = df1.join(df2, how=kind)
+            expected = _join_by_hand(df1, df2, how=kind)
+            assert_frame_equal(joined, expected)
+
+            joined = df2.join(df1, how=kind)
+            expected = _join_by_hand(df2, df1, how=kind)
+            assert_frame_equal(joined, expected)
+
+    def test_join_empty_bug(self):
+        # generated an exception in 0.4.3
+        x = DataFrame()
+        x.join(DataFrame([3], index=[0], columns=['A']), how='outer')
+
+    def test_join_unconsolidated(self):
+        # GH #331
+        a = DataFrame(randn(30, 2), columns=['a', 'b'])
+        c = Series(randn(30))
+        a['c'] = c
+        d = DataFrame(randn(30, 1), columns=['q'])
+
+        # it works!
+        a.join(d)
+        d.join(a)
+
+    def test_join_multiindex(self):
+        index1 = MultiIndex.from_arrays([['a', 'a', 'a', 'b', 'b', 'b'],
+                                         [1, 2, 3, 1, 2, 3]],
+                                        names=['first', 'second'])
+
+        index2 = MultiIndex.from_arrays([['b', 'b', 'b', 'c', 'c', 'c'],
+                                         [1, 2, 3, 1, 2, 3]],
+                                        names=['first', 'second'])
+
+        df1 = DataFrame(data=np.random.randn(6), index=index1,
+                        columns=['var X'])
+        df2 = DataFrame(data=np.random.randn(6), index=index2,
+                        columns=['var Y'])
+
+        df1 = df1.sortlevel(0)
+        df2 = df2.sortlevel(0)
+
+        joined = df1.join(df2, how='outer')
+        ex_index = index1._tuple_index.union(index2._tuple_index)
+        expected = df1.reindex(ex_index).join(df2.reindex(ex_index))
+        expected.index.names = index1.names
+        assert_frame_equal(joined, expected)
+        self.assertEqual(joined.index.names, index1.names)
+
+        df1 = df1.sortlevel(1)
+        df2 = df2.sortlevel(1)
+
+        joined = df1.join(df2, how='outer').sortlevel(0)
+        ex_index = index1._tuple_index.union(index2._tuple_index)
+        expected = df1.reindex(ex_index).join(df2.reindex(ex_index))
+        expected.index.names = index1.names
+
+        assert_frame_equal(joined, expected)
+        self.assertEqual(joined.index.names, index1.names)
+
+    def test_join_inner_multiindex(self):
+        key1 = ['bar', 'bar', 'bar', 'foo', 'foo', 'baz', 'baz', 'qux',
+                'qux', 'snap']
+        key2 = ['two', 'one', 'three', 'one', 'two', 'one', 'two', 'two',
+                'three', 'one']
+
+        data = np.random.randn(len(key1))
+        data = DataFrame({'key1': key1, 'key2': key2,
+                          'data': data})
+
+        index = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux'],
+                                   ['one', 'two', 'three']],
+                           labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3],
+                                   [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],
+                           names=['first', 'second'])
+        to_join = DataFrame(np.random.randn(10, 3), index=index,
+                            columns=['j_one', 'j_two', 'j_three'])
+
+        joined = data.join(to_join, on=['key1', 'key2'], how='inner')
+        expected = merge(data, to_join.reset_index(),
+                         left_on=['key1', 'key2'],
+                         right_on=['first', 'second'], how='inner',
+                         sort=False)
+
+        expected2 = merge(to_join, data,
+                          right_on=['key1', 'key2'], left_index=True,
+                          how='inner', sort=False)
+        assert_frame_equal(joined, expected2.reindex_like(joined))
+
+        expected2 = merge(to_join, data, right_on=['key1', 'key2'],
+                          left_index=True, how='inner', sort=False)
+
+        expected = expected.drop(['first', 'second'], axis=1)
+        expected.index = joined.index
+
+        self.assertTrue(joined.index.is_monotonic)
+        assert_frame_equal(joined, expected)
+
+        # _assert_same_contents(expected, expected2.ix[:, expected.columns])
+
+    def test_join_hierarchical_mixed(self):
+        # GH 2024
+        df = DataFrame([(1, 2, 3), (4, 5, 6)], columns=['a', 'b', 'c'])
+        new_df = df.groupby(['a']).agg({'b': [np.mean, np.sum]})
+        other_df = DataFrame(
+            [(1, 2, 3), (7, 10, 6)], columns=['a', 'b', 'd'])
+        other_df.set_index('a', inplace=True)
+        # GH 9455, 12219
+        with tm.assert_produces_warning(UserWarning):
+            result = merge(new_df, other_df, left_index=True, right_index=True)
+        self.assertTrue(('b', 'mean') in result)
+        self.assertTrue('b' in result)
+
+    def test_join_float64_float32(self):
+
+        a = DataFrame(randn(10, 2), columns=['a', 'b'], dtype=np.float64)
+        b = DataFrame(randn(10, 1), columns=['c'], dtype=np.float32)
+        joined = a.join(b)
+        self.assertEqual(joined.dtypes['a'], 'float64')
+        self.assertEqual(joined.dtypes['b'], 'float64')
+        self.assertEqual(joined.dtypes['c'], 'float32')
+
+        a = np.random.randint(0, 5, 100).astype('int64')
+        b = np.random.random(100).astype('float64')
+        c = np.random.random(100).astype('float32')
+        df = DataFrame({'a': a, 'b': b, 'c': c})
+        xpdf = DataFrame({'a': a, 'b': b, 'c': c})
+        s = DataFrame(np.random.random(5).astype('float32'), columns=['md'])
+        rs = df.merge(s, left_on='a', right_index=True)
+        self.assertEqual(rs.dtypes['a'], 'int64')
+        self.assertEqual(rs.dtypes['b'], 'float64')
+        self.assertEqual(rs.dtypes['c'], 'float32')
+        self.assertEqual(rs.dtypes['md'], 'float32')
+
+        xp = xpdf.merge(s, left_on='a', right_index=True)
+        assert_frame_equal(rs, xp)
+
+    def test_join_many_non_unique_index(self):
+        df1 = DataFrame({"a": [1, 1], "b": [1, 1], "c": [10, 20]})
+        df2 = DataFrame({"a": [1, 1], "b": [1, 2], "d": [100, 200]})
+        df3 = DataFrame({"a": [1, 1], "b": [1, 2], "e": [1000, 2000]})
+        idf1 = df1.set_index(["a", "b"])
+        idf2 = df2.set_index(["a", "b"])
+        idf3 = df3.set_index(["a", "b"])
+
+        result = idf1.join([idf2, idf3], how='outer')
+
+        df_partially_merged = merge(df1, df2, on=['a', 'b'], how='outer')
+        expected = merge(df_partially_merged, df3, on=['a', 'b'], how='outer')
+
+        result = result.reset_index()
+        expected = expected[result.columns]
+        expected['a'] = expected.a.astype('int64')
+        expected['b'] = expected.b.astype('int64')
+        assert_frame_equal(result, expected)
+
+        df1 = DataFrame({"a": [1, 1, 1], "b": [1, 1, 1], "c": [10, 20, 30]})
+        df2 = DataFrame({"a": [1, 1, 1], "b": [1, 1, 2], "d": [100, 200, 300]})
+        df3 = DataFrame(
+            {"a": [1, 1, 1], "b": [1, 1, 2], "e": [1000, 2000, 3000]})
+        idf1 = df1.set_index(["a", "b"])
+        idf2 = df2.set_index(["a", "b"])
+        idf3 = df3.set_index(["a", "b"])
+        result = idf1.join([idf2, idf3], how='inner')
+
+        df_partially_merged = merge(df1, df2, on=['a', 'b'], how='inner')
+        expected = merge(df_partially_merged, df3, on=['a', 'b'], how='inner')
+
+        result = result.reset_index()
+
+        assert_frame_equal(result, expected.ix[:, result.columns])
+
+        # GH 11519
+        df = DataFrame({'A': ['foo', 'bar', 'foo', 'bar',
+                              'foo', 'bar', 'foo', 'foo'],
+                        'B': ['one', 'one', 'two', 'three',
+                              'two', 'two', 'one', 'three'],
+                        'C': np.random.randn(8),
+                        'D': np.random.randn(8)})
+        s = Series(np.repeat(np.arange(8), 2),
+                   index=np.repeat(np.arange(8), 2), name='TEST')
+        inner = df.join(s, how='inner')
+        outer = df.join(s, how='outer')
+        left = df.join(s, how='left')
+        right = df.join(s, how='right')
+        assert_frame_equal(inner, outer)
+        assert_frame_equal(inner, left)
+        assert_frame_equal(inner, right)
+
+    def test_join_sort(self):
+        left = DataFrame({'key': ['foo', 'bar', 'baz', 'foo'],
+                          'value': [1, 2, 3, 4]})
+        right = DataFrame({'value2': ['a', 'b', 'c']},
+                          index=['bar', 'baz', 'foo'])
+
+        joined = left.join(right, on='key', sort=True)
+        expected = DataFrame({'key': ['bar', 'baz', 'foo', 'foo'],
+                              'value': [2, 3, 1, 4],
+                              'value2': ['a', 'b', 'c', 'c']},
+                             index=[1, 2, 0, 3])
+        assert_frame_equal(joined, expected)
+
+        # smoke test
+        joined = left.join(right, on='key', sort=False)
+        self.assert_index_equal(joined.index, pd.Index(lrange(4)))
+
+    def test_mixed_type_join_with_suffix(self):
+        # GH #916
+        df = DataFrame(np.random.randn(20, 6),
+                       columns=['a', 'b', 'c', 'd', 'e', 'f'])
+        df.insert(0, 'id', 0)
+        df.insert(5, 'dt', 'foo')
+
+        grouped = df.groupby('id')
+        mn = grouped.mean()
+        cn = grouped.count()
+
+        # it works!
+        mn.join(cn, rsuffix='_right')
+
+    def test_join_many(self):
+        df = DataFrame(np.random.randn(10, 6), columns=list('abcdef'))
+        df_list = [df[['a', 'b']], df[['c', 'd']], df[['e', 'f']]]
+
+        joined = df_list[0].join(df_list[1:])
+        tm.assert_frame_equal(joined, df)
+
+        df_list = [df[['a', 'b']][:-2],
+                   df[['c', 'd']][2:], df[['e', 'f']][1:9]]
+
+        def _check_diff_index(df_list, result, exp_index):
+            reindexed = [x.reindex(exp_index) for x in df_list]
+            expected = reindexed[0].join(reindexed[1:])
+            tm.assert_frame_equal(result, expected)
+
+        # different join types
+        joined = df_list[0].join(df_list[1:], how='outer')
+        _check_diff_index(df_list, joined, df.index)
+
+        joined = df_list[0].join(df_list[1:])
+        _check_diff_index(df_list, joined, df_list[0].index)
+
+        joined = df_list[0].join(df_list[1:], how='inner')
+        _check_diff_index(df_list, joined, df.index[2:8])
+
+        self.assertRaises(ValueError, df_list[0].join, df_list[1:], on='a')
+
+    def test_join_many_mixed(self):
+        df = DataFrame(np.random.randn(8, 4), columns=['A', 'B', 'C', 'D'])
+        df['key'] = ['foo', 'bar'] * 4
+        df1 = df.ix[:, ['A', 'B']]
+        df2 = df.ix[:, ['C', 'D']]
+        df3 = df.ix[:, ['key']]
+
+        result = df1.join([df2, df3])
+        assert_frame_equal(result, df)
+
+    def test_join_dups(self):
+
+        # joining dups
+        df = concat([DataFrame(np.random.randn(10, 4),
+                               columns=['A', 'A', 'B', 'B']),
+                     DataFrame(np.random.randint(0, 10, size=20)
+                               .reshape(10, 2),
+                               columns=['A', 'C'])],
+                    axis=1)
+
+        expected = concat([df, df], axis=1)
+        result = df.join(df, rsuffix='_2')
+        result.columns = expected.columns
+        assert_frame_equal(result, expected)
+
+        # GH 4975, invalid join on dups
+        w = DataFrame(np.random.randn(4, 2), columns=["x", "y"])
+        x = DataFrame(np.random.randn(4, 2), columns=["x", "y"])
+        y = DataFrame(np.random.randn(4, 2), columns=["x", "y"])
+        z = DataFrame(np.random.randn(4, 2), columns=["x", "y"])
+
+        dta = x.merge(y, left_index=True, right_index=True).merge(
+            z, left_index=True, right_index=True, how="outer")
+        dta = dta.merge(w, left_index=True, right_index=True)
+        expected = concat([x, y, z, w], axis=1)
+        expected.columns = ['x_x', 'y_x', 'x_y',
+                            'y_y', 'x_x', 'y_x', 'x_y', 'y_y']
+        assert_frame_equal(dta, expected)
+
+    def test_panel_join(self):
+        panel = tm.makePanel()
+        tm.add_nans(panel)
+
+        p1 = panel.ix[:2, :10, :3]
+        p2 = panel.ix[2:, 5:, 2:]
+
+        # left join
+        result = p1.join(p2)
+        expected = p1.copy()
+        expected['ItemC'] = p2['ItemC']
+        tm.assert_panel_equal(result, expected)
+
+        # right join
+        result = p1.join(p2, how='right')
+        expected = p2.copy()
+        expected['ItemA'] = p1['ItemA']
+        expected['ItemB'] = p1['ItemB']
+        expected = expected.reindex(items=['ItemA', 'ItemB', 'ItemC'])
+        tm.assert_panel_equal(result, expected)
+
+        # inner join
+        result = p1.join(p2, how='inner')
+        expected = panel.ix[:, 5:10, 2:3]
+        tm.assert_panel_equal(result, expected)
+
+        # outer join
+        result = p1.join(p2, how='outer')
+        expected = p1.reindex(major=panel.major_axis,
+                              minor=panel.minor_axis)
+        expected = expected.join(p2.reindex(major=panel.major_axis,
+                                            minor=panel.minor_axis))
+        tm.assert_panel_equal(result, expected)
+
+    def test_panel_join_overlap(self):
+        panel = tm.makePanel()
+        tm.add_nans(panel)
+
+        p1 = panel.ix[['ItemA', 'ItemB', 'ItemC']]
+        p2 = panel.ix[['ItemB', 'ItemC']]
+
+        # Expected index is
+        #
+        # ItemA, ItemB_p1, ItemC_p1, ItemB_p2, ItemC_p2
+        joined = p1.join(p2, lsuffix='_p1', rsuffix='_p2')
+        p1_suf = p1.ix[['ItemB', 'ItemC']].add_suffix('_p1')
+        p2_suf = p2.ix[['ItemB', 'ItemC']].add_suffix('_p2')
+        no_overlap = panel.ix[['ItemA']]
+        expected = no_overlap.join(p1_suf.join(p2_suf))
+        tm.assert_panel_equal(joined, expected)
+
+    def test_panel_join_many(self):
+        tm.K = 10
+        panel = tm.makePanel()
+        tm.K = 4
+
+        panels = [panel.ix[:2], panel.ix[2:6], panel.ix[6:]]
+
+        joined = panels[0].join(panels[1:])
+        tm.assert_panel_equal(joined, panel)
+
+        panels = [panel.ix[:2, :-5], panel.ix[2:6, 2:], panel.ix[6:, 5:-7]]
+
+        data_dict = {}
+        for p in panels:
+            data_dict.update(p.iteritems())
+
+        joined = panels[0].join(panels[1:], how='inner')
+        expected = pd.Panel.from_dict(data_dict, intersect=True)
+        tm.assert_panel_equal(joined, expected)
+
+        joined = panels[0].join(panels[1:], how='outer')
+        expected = pd.Panel.from_dict(data_dict, intersect=False)
+        tm.assert_panel_equal(joined, expected)
+
+        # edge cases
+        self.assertRaises(ValueError, panels[0].join, panels[1:],
+                          how='outer', lsuffix='foo', rsuffix='bar')
+        self.assertRaises(ValueError, panels[0].join, panels[1:],
+                          how='right')
+
+
+def _check_join(left, right, result, join_col, how='left',
+                lsuffix='_x', rsuffix='_y'):
+
+    # some smoke tests
+    for c in join_col:
+        assert(result[c].notnull().all())
+
+    left_grouped = left.groupby(join_col)
+    right_grouped = right.groupby(join_col)
+
+    for group_key, group in result.groupby(join_col):
+        l_joined = _restrict_to_columns(group, left.columns, lsuffix)
+        r_joined = _restrict_to_columns(group, right.columns, rsuffix)
+
+        try:
+            lgroup = left_grouped.get_group(group_key)
+        except KeyError:
+            if how in ('left', 'inner'):
+                raise AssertionError('key %s should not have been in the join'
+                                     % str(group_key))
+
+            _assert_all_na(l_joined, left.columns, join_col)
+        else:
+            _assert_same_contents(l_joined, lgroup)
+
+        try:
+            rgroup = right_grouped.get_group(group_key)
+        except KeyError:
+            if how in ('right', 'inner'):
+                raise AssertionError('key %s should not have been in the join'
+                                     % str(group_key))
+
+            _assert_all_na(r_joined, right.columns, join_col)
+        else:
+            _assert_same_contents(r_joined, rgroup)
+
+
+def _restrict_to_columns(group, columns, suffix):
+    found = [c for c in group.columns
+             if c in columns or c.replace(suffix, '') in columns]
+
+    # filter
+    group = group.ix[:, found]
+
+    # get rid of suffixes, if any
+    group = group.rename(columns=lambda x: x.replace(suffix, ''))
+
+    # put in the right order...
+    group = group.ix[:, columns]
+
+    return group
+
+
+def _assert_same_contents(join_chunk, source):
+    NA_SENTINEL = -1234567  # drop_duplicates not so NA-friendly...
+
+    jvalues = join_chunk.fillna(NA_SENTINEL).drop_duplicates().values
+    svalues = source.fillna(NA_SENTINEL).drop_duplicates().values
+
+    rows = set(tuple(row) for row in jvalues)
+    assert(len(rows) == len(source))
+    assert(all(tuple(row) in rows for row in svalues))
+
+
+def _assert_all_na(join_chunk, source_columns, join_col):
+    for c in source_columns:
+        if c in join_col:
+            continue
+        assert(join_chunk[c].isnull().all())
+
+
+def _join_by_hand(a, b, how='left'):
+    join_index = a.index.join(b.index, how=how)
+
+    a_re = a.reindex(join_index)
+    b_re = b.reindex(join_index)
+
+    result_columns = a.columns.append(b.columns)
+
+    for col, s in compat.iteritems(b_re):
+        a_re[col] = s
+    return a_re.reindex(columns=result_columns)
+
+
+if __name__ == '__main__':
+    nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
+                   exit=False)
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index 6c448de74..396b095fa 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -9,23 +9,17 @@ import numpy as np
 import random
 
 import pandas as pd
-from pandas.compat import range, lrange, lzip
+from pandas.compat import lrange, lzip
 from pandas.tools.merge import merge, concat, MergeError
 from pandas.util.testing import (assert_frame_equal,
                                  assert_series_equal,
                                  slow)
-from pandas import (DataFrame, Index, MultiIndex,
-                    Series, date_range, Categorical,
-                    compat)
-import pandas.algos as algos
+from pandas import DataFrame, Index, MultiIndex, Series, Categorical
 import pandas.util.testing as tm
 
 
-a_ = np.array
-
 N = 50
 NGROUPS = 8
-JOIN_TYPES = ['inner', 'outer', 'left', 'right']
 
 
 def get_test_data(ngroups=NGROUPS, n=N):
@@ -58,496 +52,16 @@ class TestMerge(tm.TestCase):
                                                     n=N // 5),
                               'value': np.random.randn(N // 5)})
 
-        index, data = tm.getMixedTypeDict()
-        self.target = DataFrame(data, index=index)
-
-        # Join on string value
-        self.source = DataFrame({'MergedA': data['A'], 'MergedD': data['D']},
-                                index=data['C'])
-
         self.left = DataFrame({'key': ['a', 'b', 'c', 'd', 'e', 'e', 'a'],
                                'v1': np.random.randn(7)})
         self.right = DataFrame({'v2': np.random.randn(4)},
                                index=['d', 'b', 'c', 'a'])
 
-    def test_cython_left_outer_join(self):
-        left = a_([0, 1, 2, 1, 2, 0, 0, 1, 2, 3, 3], dtype=np.int64)
-        right = a_([1, 1, 0, 4, 2, 2, 1], dtype=np.int64)
-        max_group = 5
-
-        ls, rs = algos.left_outer_join(left, right, max_group)
-
-        exp_ls = left.argsort(kind='mergesort')
-        exp_rs = right.argsort(kind='mergesort')
-
-        exp_li = a_([0, 1, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5,
-                     6, 6, 7, 7, 8, 8, 9, 10])
-        exp_ri = a_([0, 0, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3,
-                     4, 5, 4, 5, 4, 5, -1, -1])
-
-        exp_ls = exp_ls.take(exp_li)
-        exp_ls[exp_li == -1] = -1
-
-        exp_rs = exp_rs.take(exp_ri)
-        exp_rs[exp_ri == -1] = -1
-
-        self.assert_numpy_array_equal(ls, exp_ls, check_dtype=False)
-        self.assert_numpy_array_equal(rs, exp_rs, check_dtype=False)
-
-    def test_cython_right_outer_join(self):
-        left = a_([0, 1, 2, 1, 2, 0, 0, 1, 2, 3, 3], dtype=np.int64)
-        right = a_([1, 1, 0, 4, 2, 2, 1], dtype=np.int64)
-        max_group = 5
-
-        rs, ls = algos.left_outer_join(right, left, max_group)
-
-        exp_ls = left.argsort(kind='mergesort')
-        exp_rs = right.argsort(kind='mergesort')
-
-        #            0        1        1        1
-        exp_li = a_([0, 1, 2, 3, 4, 5, 3, 4, 5, 3, 4, 5,
-                     #            2        2        4
-                     6, 7, 8, 6, 7, 8, -1])
-        exp_ri = a_([0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3,
-                     4, 4, 4, 5, 5, 5, 6])
-
-        exp_ls = exp_ls.take(exp_li)
-        exp_ls[exp_li == -1] = -1
-
-        exp_rs = exp_rs.take(exp_ri)
-        exp_rs[exp_ri == -1] = -1
-
-        self.assert_numpy_array_equal(ls, exp_ls, check_dtype=False)
-        self.assert_numpy_array_equal(rs, exp_rs, check_dtype=False)
-
-    def test_cython_inner_join(self):
-        left = a_([0, 1, 2, 1, 2, 0, 0, 1, 2, 3, 3], dtype=np.int64)
-        right = a_([1, 1, 0, 4, 2, 2, 1, 4], dtype=np.int64)
-        max_group = 5
-
-        ls, rs = algos.inner_join(left, right, max_group)
-
-        exp_ls = left.argsort(kind='mergesort')
-        exp_rs = right.argsort(kind='mergesort')
-
-        exp_li = a_([0, 1, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5,
-                     6, 6, 7, 7, 8, 8])
-        exp_ri = a_([0, 0, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3,
-                     4, 5, 4, 5, 4, 5])
-
-        exp_ls = exp_ls.take(exp_li)
-        exp_ls[exp_li == -1] = -1
-
-        exp_rs = exp_rs.take(exp_ri)
-        exp_rs[exp_ri == -1] = -1
-
-        self.assert_numpy_array_equal(ls, exp_ls, check_dtype=False)
-        self.assert_numpy_array_equal(rs, exp_rs, check_dtype=False)
-
-    def test_left_outer_join(self):
-        joined_key2 = merge(self.df, self.df2, on='key2')
-        _check_join(self.df, self.df2, joined_key2, ['key2'], how='left')
-
-        joined_both = merge(self.df, self.df2)
-        _check_join(self.df, self.df2, joined_both, ['key1', 'key2'],
-                    how='left')
-
-    def test_right_outer_join(self):
-        joined_key2 = merge(self.df, self.df2, on='key2', how='right')
-        _check_join(self.df, self.df2, joined_key2, ['key2'], how='right')
-
-        joined_both = merge(self.df, self.df2, how='right')
-        _check_join(self.df, self.df2, joined_both, ['key1', 'key2'],
-                    how='right')
-
-    def test_full_outer_join(self):
-        joined_key2 = merge(self.df, self.df2, on='key2', how='outer')
-        _check_join(self.df, self.df2, joined_key2, ['key2'], how='outer')
-
-        joined_both = merge(self.df, self.df2, how='outer')
-        _check_join(self.df, self.df2, joined_both, ['key1', 'key2'],
-                    how='outer')
-
-    def test_inner_join(self):
-        joined_key2 = merge(self.df, self.df2, on='key2', how='inner')
-        _check_join(self.df, self.df2, joined_key2, ['key2'], how='inner')
-
-        joined_both = merge(self.df, self.df2, how='inner')
-        _check_join(self.df, self.df2, joined_both, ['key1', 'key2'],
-                    how='inner')
-
-    def test_handle_overlap(self):
-        joined = merge(self.df, self.df2, on='key2',
-                       suffixes=['.foo', '.bar'])
-
-        self.assertIn('key1.foo', joined)
-        self.assertIn('key1.bar', joined)
-
-    def test_handle_overlap_arbitrary_key(self):
-        joined = merge(self.df, self.df2,
-                       left_on='key2', right_on='key1',
-                       suffixes=['.foo', '.bar'])
-        self.assertIn('key1.foo', joined)
-        self.assertIn('key2.bar', joined)
-
     def test_merge_common(self):
         joined = merge(self.df, self.df2)
         exp = merge(self.df, self.df2, on=['key1', 'key2'])
         tm.assert_frame_equal(joined, exp)
 
-    def test_join_on(self):
-        target = self.target
-        source = self.source
-
-        merged = target.join(source, on='C')
-        self.assert_series_equal(merged['MergedA'], target['A'],
-                                 check_names=False)
-        self.assert_series_equal(merged['MergedD'], target['D'],
-                                 check_names=False)
-
-        # join with duplicates (fix regression from DataFrame/Matrix merge)
-        df = DataFrame({'key': ['a', 'a', 'b', 'b', 'c']})
-        df2 = DataFrame({'value': [0, 1, 2]}, index=['a', 'b', 'c'])
-        joined = df.join(df2, on='key')
-        expected = DataFrame({'key': ['a', 'a', 'b', 'b', 'c'],
-                              'value': [0, 0, 1, 1, 2]})
-        assert_frame_equal(joined, expected)
-
-        # Test when some are missing
-        df_a = DataFrame([[1], [2], [3]], index=['a', 'b', 'c'],
-                         columns=['one'])
-        df_b = DataFrame([['foo'], ['bar']], index=[1, 2],
-                         columns=['two'])
-        df_c = DataFrame([[1], [2]], index=[1, 2],
-                         columns=['three'])
-        joined = df_a.join(df_b, on='one')
-        joined = joined.join(df_c, on='one')
-        self.assertTrue(np.isnan(joined['two']['c']))
-        self.assertTrue(np.isnan(joined['three']['c']))
-
-        # merge column not p resent
-        self.assertRaises(KeyError, target.join, source, on='E')
-
-        # overlap
-        source_copy = source.copy()
-        source_copy['A'] = 0
-        self.assertRaises(ValueError, target.join, source_copy, on='A')
-
-    def test_join_on_fails_with_different_right_index(self):
-        with tm.assertRaises(ValueError):
-            df = DataFrame({'a': np.random.choice(['m', 'f'], size=3),
-                            'b': np.random.randn(3)})
-            df2 = DataFrame({'a': np.random.choice(['m', 'f'], size=10),
-                             'b': np.random.randn(10)},
-                            index=tm.makeCustomIndex(10, 2))
-            merge(df, df2, left_on='a', right_index=True)
-
-    def test_join_on_fails_with_different_left_index(self):
-        with tm.assertRaises(ValueError):
-            df = DataFrame({'a': np.random.choice(['m', 'f'], size=3),
-                            'b': np.random.randn(3)},
-                           index=tm.makeCustomIndex(10, 2))
-            df2 = DataFrame({'a': np.random.choice(['m', 'f'], size=10),
-                             'b': np.random.randn(10)})
-            merge(df, df2, right_on='b', left_index=True)
-
-    def test_join_on_fails_with_different_column_counts(self):
-        with tm.assertRaises(ValueError):
-            df = DataFrame({'a': np.random.choice(['m', 'f'], size=3),
-                            'b': np.random.randn(3)})
-            df2 = DataFrame({'a': np.random.choice(['m', 'f'], size=10),
-                             'b': np.random.randn(10)},
-                            index=tm.makeCustomIndex(10, 2))
-            merge(df, df2, right_on='a', left_on=['a', 'b'])
-
-    def test_join_on_fails_with_wrong_object_type(self):
-        # GH12081
-        wrongly_typed = [Series([0, 1]), 2, 'str', None, np.array([0, 1])]
-        df = DataFrame({'a': [1, 1]})
-
-        for obj in wrongly_typed:
-            with tm.assertRaisesRegexp(ValueError, str(type(obj))):
-                merge(obj, df, left_on='a', right_on='a')
-            with tm.assertRaisesRegexp(ValueError, str(type(obj))):
-                merge(df, obj, left_on='a', right_on='a')
-
-    def test_join_on_pass_vector(self):
-        expected = self.target.join(self.source, on='C')
-        del expected['C']
-
-        join_col = self.target.pop('C')
-        result = self.target.join(self.source, on=join_col)
-        assert_frame_equal(result, expected)
-
-    def test_join_with_len0(self):
-        # nothing to merge
-        merged = self.target.join(self.source.reindex([]), on='C')
-        for col in self.source:
-            self.assertIn(col, merged)
-            self.assertTrue(merged[col].isnull().all())
-
-        merged2 = self.target.join(self.source.reindex([]), on='C',
-                                   how='inner')
-        self.assert_index_equal(merged2.columns, merged.columns)
-        self.assertEqual(len(merged2), 0)
-
-    def test_join_on_inner(self):
-        df = DataFrame({'key': ['a', 'a', 'd', 'b', 'b', 'c']})
-        df2 = DataFrame({'value': [0, 1]}, index=['a', 'b'])
-
-        joined = df.join(df2, on='key', how='inner')
-
-        expected = df.join(df2, on='key')
-        expected = expected[expected['value'].notnull()]
-        self.assert_series_equal(joined['key'], expected['key'],
-                                 check_dtype=False)
-        self.assert_series_equal(joined['value'], expected['value'],
-                                 check_dtype=False)
-        self.assert_index_equal(joined.index, expected.index)
-
-    def test_join_on_singlekey_list(self):
-        df = DataFrame({'key': ['a', 'a', 'b', 'b', 'c']})
-        df2 = DataFrame({'value': [0, 1, 2]}, index=['a', 'b', 'c'])
-
-        # corner cases
-        joined = df.join(df2, on=['key'])
-        expected = df.join(df2, on='key')
-
-        assert_frame_equal(joined, expected)
-
-    def test_join_on_series(self):
-        result = self.target.join(self.source['MergedA'], on='C')
-        expected = self.target.join(self.source[['MergedA']], on='C')
-        assert_frame_equal(result, expected)
-
-    def test_join_on_series_buglet(self):
-        # GH #638
-        df = DataFrame({'a': [1, 1]})
-        ds = Series([2], index=[1], name='b')
-        result = df.join(ds, on='a')
-        expected = DataFrame({'a': [1, 1],
-                              'b': [2, 2]}, index=df.index)
-        tm.assert_frame_equal(result, expected)
-
-    def test_join_index_mixed(self):
-        df1 = DataFrame({'A': 1., 'B': 2, 'C': 'foo', 'D': True},
-                        index=np.arange(10),
-                        columns=['A', 'B', 'C', 'D'])
-        self.assertEqual(df1['B'].dtype, np.int64)
-        self.assertEqual(df1['D'].dtype, np.bool_)
-
-        df2 = DataFrame({'A': 1., 'B': 2, 'C': 'foo', 'D': True},
-                        index=np.arange(0, 10, 2),
-                        columns=['A', 'B', 'C', 'D'])
-
-        # overlap
-        joined = df1.join(df2, lsuffix='_one', rsuffix='_two')
-        expected_columns = ['A_one', 'B_one', 'C_one', 'D_one',
-                            'A_two', 'B_two', 'C_two', 'D_two']
-        df1.columns = expected_columns[:4]
-        df2.columns = expected_columns[4:]
-        expected = _join_by_hand(df1, df2)
-        assert_frame_equal(joined, expected)
-
-        # no overlapping blocks
-        df1 = DataFrame(index=np.arange(10))
-        df1['bool'] = True
-        df1['string'] = 'foo'
-
-        df2 = DataFrame(index=np.arange(5, 15))
-        df2['int'] = 1
-        df2['float'] = 1.
-
-        for kind in JOIN_TYPES:
-
-            joined = df1.join(df2, how=kind)
-            expected = _join_by_hand(df1, df2, how=kind)
-            assert_frame_equal(joined, expected)
-
-            joined = df2.join(df1, how=kind)
-            expected = _join_by_hand(df2, df1, how=kind)
-            assert_frame_equal(joined, expected)
-
-    def test_join_empty_bug(self):
-        # generated an exception in 0.4.3
-        x = DataFrame()
-        x.join(DataFrame([3], index=[0], columns=['A']), how='outer')
-
-    def test_join_unconsolidated(self):
-        # GH #331
-        a = DataFrame(randn(30, 2), columns=['a', 'b'])
-        c = Series(randn(30))
-        a['c'] = c
-        d = DataFrame(randn(30, 1), columns=['q'])
-
-        # it works!
-        a.join(d)
-        d.join(a)
-
-    def test_join_multiindex(self):
-        index1 = MultiIndex.from_arrays([['a', 'a', 'a', 'b', 'b', 'b'],
-                                         [1, 2, 3, 1, 2, 3]],
-                                        names=['first', 'second'])
-
-        index2 = MultiIndex.from_arrays([['b', 'b', 'b', 'c', 'c', 'c'],
-                                         [1, 2, 3, 1, 2, 3]],
-                                        names=['first', 'second'])
-
-        df1 = DataFrame(data=np.random.randn(6), index=index1,
-                        columns=['var X'])
-        df2 = DataFrame(data=np.random.randn(6), index=index2,
-                        columns=['var Y'])
-
-        df1 = df1.sortlevel(0)
-        df2 = df2.sortlevel(0)
-
-        joined = df1.join(df2, how='outer')
-        ex_index = index1._tuple_index.union(index2._tuple_index)
-        expected = df1.reindex(ex_index).join(df2.reindex(ex_index))
-        expected.index.names = index1.names
-        assert_frame_equal(joined, expected)
-        self.assertEqual(joined.index.names, index1.names)
-
-        df1 = df1.sortlevel(1)
-        df2 = df2.sortlevel(1)
-
-        joined = df1.join(df2, how='outer').sortlevel(0)
-        ex_index = index1._tuple_index.union(index2._tuple_index)
-        expected = df1.reindex(ex_index).join(df2.reindex(ex_index))
-        expected.index.names = index1.names
-
-        assert_frame_equal(joined, expected)
-        self.assertEqual(joined.index.names, index1.names)
-
-    def test_join_inner_multiindex(self):
-        key1 = ['bar', 'bar', 'bar', 'foo', 'foo', 'baz', 'baz', 'qux',
-                'qux', 'snap']
-        key2 = ['two', 'one', 'three', 'one', 'two', 'one', 'two', 'two',
-                'three', 'one']
-
-        data = np.random.randn(len(key1))
-        data = DataFrame({'key1': key1, 'key2': key2,
-                          'data': data})
-
-        index = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux'],
-                                   ['one', 'two', 'three']],
-                           labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3],
-                                   [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],
-                           names=['first', 'second'])
-        to_join = DataFrame(np.random.randn(10, 3), index=index,
-                            columns=['j_one', 'j_two', 'j_three'])
-
-        joined = data.join(to_join, on=['key1', 'key2'], how='inner')
-        expected = merge(data, to_join.reset_index(),
-                         left_on=['key1', 'key2'],
-                         right_on=['first', 'second'], how='inner',
-                         sort=False)
-
-        expected2 = merge(to_join, data,
-                          right_on=['key1', 'key2'], left_index=True,
-                          how='inner', sort=False)
-        assert_frame_equal(joined, expected2.reindex_like(joined))
-
-        expected2 = merge(to_join, data, right_on=['key1', 'key2'],
-                          left_index=True, how='inner', sort=False)
-
-        expected = expected.drop(['first', 'second'], axis=1)
-        expected.index = joined.index
-
-        self.assertTrue(joined.index.is_monotonic)
-        assert_frame_equal(joined, expected)
-
-        # _assert_same_contents(expected, expected2.ix[:, expected.columns])
-
-    def test_join_hierarchical_mixed(self):
-        # GH 2024
-        df = DataFrame([(1, 2, 3), (4, 5, 6)], columns=['a', 'b', 'c'])
-        new_df = df.groupby(['a']).agg({'b': [np.mean, np.sum]})
-        other_df = DataFrame(
-            [(1, 2, 3), (7, 10, 6)], columns=['a', 'b', 'd'])
-        other_df.set_index('a', inplace=True)
-        # GH 9455, 12219
-        with tm.assert_produces_warning(UserWarning):
-            result = merge(new_df, other_df, left_index=True, right_index=True)
-        self.assertTrue(('b', 'mean') in result)
-        self.assertTrue('b' in result)
-
-    def test_join_float64_float32(self):
-
-        a = DataFrame(randn(10, 2), columns=['a', 'b'], dtype=np.float64)
-        b = DataFrame(randn(10, 1), columns=['c'], dtype=np.float32)
-        joined = a.join(b)
-        self.assertEqual(joined.dtypes['a'], 'float64')
-        self.assertEqual(joined.dtypes['b'], 'float64')
-        self.assertEqual(joined.dtypes['c'], 'float32')
-
-        a = np.random.randint(0, 5, 100).astype('int64')
-        b = np.random.random(100).astype('float64')
-        c = np.random.random(100).astype('float32')
-        df = DataFrame({'a': a, 'b': b, 'c': c})
-        xpdf = DataFrame({'a': a, 'b': b, 'c': c})
-        s = DataFrame(np.random.random(5).astype('float32'), columns=['md'])
-        rs = df.merge(s, left_on='a', right_index=True)
-        self.assertEqual(rs.dtypes['a'], 'int64')
-        self.assertEqual(rs.dtypes['b'], 'float64')
-        self.assertEqual(rs.dtypes['c'], 'float32')
-        self.assertEqual(rs.dtypes['md'], 'float32')
-
-        xp = xpdf.merge(s, left_on='a', right_index=True)
-        assert_frame_equal(rs, xp)
-
-    def test_join_many_non_unique_index(self):
-        df1 = DataFrame({"a": [1, 1], "b": [1, 1], "c": [10, 20]})
-        df2 = DataFrame({"a": [1, 1], "b": [1, 2], "d": [100, 200]})
-        df3 = DataFrame({"a": [1, 1], "b": [1, 2], "e": [1000, 2000]})
-        idf1 = df1.set_index(["a", "b"])
-        idf2 = df2.set_index(["a", "b"])
-        idf3 = df3.set_index(["a", "b"])
-
-        result = idf1.join([idf2, idf3], how='outer')
-
-        df_partially_merged = merge(df1, df2, on=['a', 'b'], how='outer')
-        expected = merge(df_partially_merged, df3, on=['a', 'b'], how='outer')
-
-        result = result.reset_index()
-        expected = expected[result.columns]
-        expected['a'] = expected.a.astype('int64')
-        expected['b'] = expected.b.astype('int64')
-        assert_frame_equal(result, expected)
-
-        df1 = DataFrame({"a": [1, 1, 1], "b": [1, 1, 1], "c": [10, 20, 30]})
-        df2 = DataFrame({"a": [1, 1, 1], "b": [1, 1, 2], "d": [100, 200, 300]})
-        df3 = DataFrame(
-            {"a": [1, 1, 1], "b": [1, 1, 2], "e": [1000, 2000, 3000]})
-        idf1 = df1.set_index(["a", "b"])
-        idf2 = df2.set_index(["a", "b"])
-        idf3 = df3.set_index(["a", "b"])
-        result = idf1.join([idf2, idf3], how='inner')
-
-        df_partially_merged = merge(df1, df2, on=['a', 'b'], how='inner')
-        expected = merge(df_partially_merged, df3, on=['a', 'b'], how='inner')
-
-        result = result.reset_index()
-
-        assert_frame_equal(result, expected.ix[:, result.columns])
-
-        # GH 11519
-        df = DataFrame({'A': ['foo', 'bar', 'foo', 'bar',
-                              'foo', 'bar', 'foo', 'foo'],
-                        'B': ['one', 'one', 'two', 'three',
-                              'two', 'two', 'one', 'three'],
-                        'C': np.random.randn(8),
-                        'D': np.random.randn(8)})
-        s = Series(np.repeat(np.arange(8), 2),
-                   index=np.repeat(np.arange(8), 2), name='TEST')
-        inner = df.join(s, how='inner')
-        outer = df.join(s, how='outer')
-        left = df.join(s, how='left')
-        right = df.join(s, how='right')
-        assert_frame_equal(inner, outer)
-        assert_frame_equal(inner, left)
-        assert_frame_equal(inner, right)
-
     def test_merge_index_singlekey_right_vs_left(self):
         left = DataFrame({'key': ['a', 'b', 'c', 'd', 'e', 'e', 'a'],
                           'v1': np.random.randn(7)})
@@ -651,23 +165,6 @@ class TestMerge(tm.TestCase):
         merged['d'] = 'peekaboo'
         self.assertTrue((right['d'] == 'peekaboo').all())
 
-    def test_join_sort(self):
-        left = DataFrame({'key': ['foo', 'bar', 'baz', 'foo'],
-                          'value': [1, 2, 3, 4]})
-        right = DataFrame({'value2': ['a', 'b', 'c']},
-                          index=['bar', 'baz', 'foo'])
-
-        joined = left.join(right, on='key', sort=True)
-        expected = DataFrame({'key': ['bar', 'baz', 'foo', 'foo'],
-                              'value': [2, 3, 1, 4],
-                              'value2': ['a', 'b', 'c', 'c']},
-                             index=[1, 2, 0, 3])
-        assert_frame_equal(joined, expected)
-
-        # smoke test
-        joined = left.join(right, on='key', sort=False)
-        self.assert_index_equal(joined.index, pd.Index(lrange(4)))
-
     def test_intelligently_handle_join_key(self):
         # #733, be a bit more 1337 about not returning unconsolidated DataFrame
 
@@ -737,20 +234,6 @@ class TestMerge(tm.TestCase):
         merged = merge(left, right, left_index=True, right_on=key, how='outer')
         self.assert_series_equal(merged['key_0'], Series(key, name='key_0'))
 
-    def test_mixed_type_join_with_suffix(self):
-        # GH #916
-        df = DataFrame(np.random.randn(20, 6),
-                       columns=['a', 'b', 'c', 'd', 'e', 'f'])
-        df.insert(0, 'id', 0)
-        df.insert(5, 'dt', 'foo')
-
-        grouped = df.groupby('id')
-        mn = grouped.mean()
-        cn = grouped.count()
-
-        # it works!
-        mn.join(cn, rsuffix='_right')
-
     def test_no_overlap_more_informative_error(self):
         dt = datetime.now()
         df1 = DataFrame({'x': ['a']}, index=[dt])
@@ -963,68 +446,6 @@ class TestMerge(tm.TestCase):
 
         tm.assertIsInstance(result, NotADataFrame)
 
-    def test_empty_dtype_coerce(self):
-
-        # xref to #12411
-        # xref to #12045
-        # xref to #11594
-        # see below
-
-        # 10571
-        df1 = DataFrame(data=[[1, None], [2, None]], columns=['a', 'b'])
-        df2 = DataFrame(data=[[3, None], [4, None]], columns=['a', 'b'])
-        result = concat([df1, df2])
-        expected = df1.dtypes
-        assert_series_equal(result.dtypes, expected)
-
-    def test_dtype_coerceion(self):
-
-        # 12411
-        df = DataFrame({'date': [pd.Timestamp('20130101').tz_localize('UTC'),
-                                 pd.NaT]})
-
-        result = concat([df.iloc[[0]], df.iloc[[1]]])
-        assert_series_equal(result.dtypes, df.dtypes)
-
-        # 12045
-        import datetime
-        df = DataFrame({'date': [datetime.datetime(2012, 1, 1),
-                                 datetime.datetime(1012, 1, 2)]})
-        result = concat([df.iloc[[0]], df.iloc[[1]]])
-        assert_series_equal(result.dtypes, df.dtypes)
-
-        # 11594
-        df = DataFrame({'text': ['some words'] + [None] * 9})
-        result = concat([df.iloc[[0]], df.iloc[[1]]])
-        assert_series_equal(result.dtypes, df.dtypes)
-
-    def test_append_dtype_coerce(self):
-
-        # GH 4993
-        # appending with datetime will incorrectly convert datetime64
-        import datetime as dt
-        from pandas import NaT
-
-        df1 = DataFrame(index=[1, 2], data=[dt.datetime(2013, 1, 1, 0, 0),
-                                            dt.datetime(2013, 1, 2, 0, 0)],
-                        columns=['start_time'])
-        df2 = DataFrame(index=[4, 5], data=[[dt.datetime(2013, 1, 3, 0, 0),
-                                             dt.datetime(2013, 1, 3, 6, 10)],
-                                            [dt.datetime(2013, 1, 4, 0, 0),
-                                             dt.datetime(2013, 1, 4, 7, 10)]],
-                        columns=['start_time', 'end_time'])
-
-        expected = concat([Series([NaT, NaT, dt.datetime(2013, 1, 3, 6, 10),
-                                   dt.datetime(2013, 1, 4, 7, 10)],
-                                  name='end_time'),
-                           Series([dt.datetime(2013, 1, 1, 0, 0),
-                                   dt.datetime(2013, 1, 2, 0, 0),
-                                   dt.datetime(2013, 1, 3, 0, 0),
-                                   dt.datetime(2013, 1, 4, 0, 0)],
-                                  name='start_time')], axis=1)
-        result = df1.append(df2, ignore_index=True)
-        assert_frame_equal(result, expected)
-
     def test_join_append_timedeltas(self):
 
         import datetime as dt
@@ -1140,239 +561,6 @@ class TestMerge(tm.TestCase):
         self.assertEqual(result['value_x'].dtype, 'object')
         self.assertEqual(result['value_y'].dtype, 'object')
 
-    def test_concat_NaT_series(self):
-        # GH 11693
-        # test for merging NaT series with datetime series.
-        x = Series(date_range('20151124 08:00', '20151124 09:00',
-                              freq='1h', tz='US/Eastern'))
-        y = Series(pd.NaT, index=[0, 1], dtype='datetime64[ns, US/Eastern]')
-        expected = Series([x[0], x[1], pd.NaT, pd.NaT])
-
-        result = concat([x, y], ignore_index=True)
-        tm.assert_series_equal(result, expected)
-
-        # all NaT with tz
-        expected = Series(pd.NaT, index=range(4),
-                          dtype='datetime64[ns, US/Eastern]')
-        result = pd.concat([y, y], ignore_index=True)
-        tm.assert_series_equal(result, expected)
-
-        # without tz
-        x = pd.Series(pd.date_range('20151124 08:00',
-                                    '20151124 09:00', freq='1h'))
-        y = pd.Series(pd.date_range('20151124 10:00',
-                                    '20151124 11:00', freq='1h'))
-        y[:] = pd.NaT
-        expected = pd.Series([x[0], x[1], pd.NaT, pd.NaT])
-        result = pd.concat([x, y], ignore_index=True)
-        tm.assert_series_equal(result, expected)
-
-        # all NaT without tz
-        x[:] = pd.NaT
-        expected = pd.Series(pd.NaT, index=range(4),
-                             dtype='datetime64[ns]')
-        result = pd.concat([x, y], ignore_index=True)
-        tm.assert_series_equal(result, expected)
-
-    def test_concat_tz_frame(self):
-        df2 = DataFrame(dict(A=pd.Timestamp('20130102', tz='US/Eastern'),
-                             B=pd.Timestamp('20130603', tz='CET')),
-                        index=range(5))
-
-        # concat
-        df3 = pd.concat([df2.A.to_frame(), df2.B.to_frame()], axis=1)
-        assert_frame_equal(df2, df3)
-
-    def test_concat_tz_series(self):
-        # GH 11755
-        # tz and no tz
-        x = Series(date_range('20151124 08:00',
-                              '20151124 09:00',
-                              freq='1h', tz='UTC'))
-        y = Series(date_range('2012-01-01', '2012-01-02'))
-        expected = Series([x[0], x[1], y[0], y[1]],
-                          dtype='object')
-        result = concat([x, y], ignore_index=True)
-        tm.assert_series_equal(result, expected)
-
-        # GH 11887
-        # concat tz and object
-        x = Series(date_range('20151124 08:00',
-                              '20151124 09:00',
-                              freq='1h', tz='UTC'))
-        y = Series(['a', 'b'])
-        expected = Series([x[0], x[1], y[0], y[1]],
-                          dtype='object')
-        result = concat([x, y], ignore_index=True)
-        tm.assert_series_equal(result, expected)
-
-        # 12217
-        # 12306 fixed I think
-
-        # Concat'ing two UTC times
-        first = pd.DataFrame([[datetime(2016, 1, 1)]])
-        first[0] = first[0].dt.tz_localize('UTC')
-
-        second = pd.DataFrame([[datetime(2016, 1, 2)]])
-        second[0] = second[0].dt.tz_localize('UTC')
-
-        result = pd.concat([first, second])
-        self.assertEqual(result[0].dtype, 'datetime64[ns, UTC]')
-
-        # Concat'ing two London times
-        first = pd.DataFrame([[datetime(2016, 1, 1)]])
-        first[0] = first[0].dt.tz_localize('Europe/London')
-
-        second = pd.DataFrame([[datetime(2016, 1, 2)]])
-        second[0] = second[0].dt.tz_localize('Europe/London')
-
-        result = pd.concat([first, second])
-        self.assertEqual(result[0].dtype, 'datetime64[ns, Europe/London]')
-
-        # Concat'ing 2+1 London times
-        first = pd.DataFrame([[datetime(2016, 1, 1)], [datetime(2016, 1, 2)]])
-        first[0] = first[0].dt.tz_localize('Europe/London')
-
-        second = pd.DataFrame([[datetime(2016, 1, 3)]])
-        second[0] = second[0].dt.tz_localize('Europe/London')
-
-        result = pd.concat([first, second])
-        self.assertEqual(result[0].dtype, 'datetime64[ns, Europe/London]')
-
-        # Concat'ing 1+2 London times
-        first = pd.DataFrame([[datetime(2016, 1, 1)]])
-        first[0] = first[0].dt.tz_localize('Europe/London')
-
-        second = pd.DataFrame([[datetime(2016, 1, 2)], [datetime(2016, 1, 3)]])
-        second[0] = second[0].dt.tz_localize('Europe/London')
-
-        result = pd.concat([first, second])
-        self.assertEqual(result[0].dtype, 'datetime64[ns, Europe/London]')
-
-    def test_concat_tz_series_with_datetimelike(self):
-        # GH 12620
-        # tz and timedelta
-        x = [pd.Timestamp('2011-01-01', tz='US/Eastern'),
-             pd.Timestamp('2011-02-01', tz='US/Eastern')]
-        y = [pd.Timedelta('1 day'), pd.Timedelta('2 day')]
-        result = concat([pd.Series(x), pd.Series(y)], ignore_index=True)
-        tm.assert_series_equal(result, pd.Series(x + y, dtype='object'))
-
-        # tz and period
-        y = [pd.Period('2011-03', freq='M'), pd.Period('2011-04', freq='M')]
-        result = concat([pd.Series(x), pd.Series(y)], ignore_index=True)
-        tm.assert_series_equal(result, pd.Series(x + y, dtype='object'))
-
-    def test_concat_tz_series_tzlocal(self):
-        # GH 13583
-        tm._skip_if_no_dateutil()
-        import dateutil
-        x = [pd.Timestamp('2011-01-01', tz=dateutil.tz.tzlocal()),
-             pd.Timestamp('2011-02-01', tz=dateutil.tz.tzlocal())]
-        y = [pd.Timestamp('2012-01-01', tz=dateutil.tz.tzlocal()),
-             pd.Timestamp('2012-02-01', tz=dateutil.tz.tzlocal())]
-        result = concat([pd.Series(x), pd.Series(y)], ignore_index=True)
-        tm.assert_series_equal(result, pd.Series(x + y))
-        self.assertEqual(result.dtype, 'datetime64[ns, tzlocal()]')
-
-    def test_concat_period_series(self):
-        x = Series(pd.PeriodIndex(['2015-11-01', '2015-12-01'], freq='D'))
-        y = Series(pd.PeriodIndex(['2015-10-01', '2016-01-01'], freq='D'))
-        expected = Series([x[0], x[1], y[0], y[1]], dtype='object')
-        result = concat([x, y], ignore_index=True)
-        tm.assert_series_equal(result, expected)
-        self.assertEqual(result.dtype, 'object')
-
-        # different freq
-        x = Series(pd.PeriodIndex(['2015-11-01', '2015-12-01'], freq='D'))
-        y = Series(pd.PeriodIndex(['2015-10-01', '2016-01-01'], freq='M'))
-        expected = Series([x[0], x[1], y[0], y[1]], dtype='object')
-        result = concat([x, y], ignore_index=True)
-        tm.assert_series_equal(result, expected)
-        self.assertEqual(result.dtype, 'object')
-
-        x = Series(pd.PeriodIndex(['2015-11-01', '2015-12-01'], freq='D'))
-        y = Series(pd.PeriodIndex(['2015-11-01', '2015-12-01'], freq='M'))
-        expected = Series([x[0], x[1], y[0], y[1]], dtype='object')
-        result = concat([x, y], ignore_index=True)
-        tm.assert_series_equal(result, expected)
-        self.assertEqual(result.dtype, 'object')
-
-        # non-period
-        x = Series(pd.PeriodIndex(['2015-11-01', '2015-12-01'], freq='D'))
-        y = Series(pd.DatetimeIndex(['2015-11-01', '2015-12-01']))
-        expected = Series([x[0], x[1], y[0], y[1]], dtype='object')
-        result = concat([x, y], ignore_index=True)
-        tm.assert_series_equal(result, expected)
-        self.assertEqual(result.dtype, 'object')
-
-        x = Series(pd.PeriodIndex(['2015-11-01', '2015-12-01'], freq='D'))
-        y = Series(['A', 'B'])
-        expected = Series([x[0], x[1], y[0], y[1]], dtype='object')
-        result = concat([x, y], ignore_index=True)
-        tm.assert_series_equal(result, expected)
-        self.assertEqual(result.dtype, 'object')
-
-    def test_concat_empty_series(self):
-        # GH 11082
-        s1 = pd.Series([1, 2, 3], name='x')
-        s2 = pd.Series(name='y')
-        res = pd.concat([s1, s2], axis=1)
-        exp = pd.DataFrame({'x': [1, 2, 3], 'y': [np.nan, np.nan, np.nan]})
-        tm.assert_frame_equal(res, exp)
-
-        s1 = pd.Series([1, 2, 3], name='x')
-        s2 = pd.Series(name='y')
-        res = pd.concat([s1, s2], axis=0)
-        # name will be reset
-        exp = pd.Series([1, 2, 3])
-        tm.assert_series_equal(res, exp)
-
-        # empty Series with no name
-        s1 = pd.Series([1, 2, 3], name='x')
-        s2 = pd.Series(name=None)
-        res = pd.concat([s1, s2], axis=1)
-        exp = pd.DataFrame({'x': [1, 2, 3], 0: [np.nan, np.nan, np.nan]},
-                           columns=['x', 0])
-        tm.assert_frame_equal(res, exp)
-
-    def test_default_index(self):
-        # is_series and ignore_index
-        s1 = pd.Series([1, 2, 3], name='x')
-        s2 = pd.Series([4, 5, 6], name='y')
-        res = pd.concat([s1, s2], axis=1, ignore_index=True)
-        self.assertIsInstance(res.columns, pd.RangeIndex)
-        exp = pd.DataFrame([[1, 4], [2, 5], [3, 6]])
-        # use check_index_type=True to check the result have
-        # RangeIndex (default index)
-        tm.assert_frame_equal(res, exp, check_index_type=True,
-                              check_column_type=True)
-
-        # is_series and all inputs have no names
-        s1 = pd.Series([1, 2, 3])
-        s2 = pd.Series([4, 5, 6])
-        res = pd.concat([s1, s2], axis=1, ignore_index=False)
-        self.assertIsInstance(res.columns, pd.RangeIndex)
-        exp = pd.DataFrame([[1, 4], [2, 5], [3, 6]])
-        exp.columns = pd.RangeIndex(2)
-        tm.assert_frame_equal(res, exp, check_index_type=True,
-                              check_column_type=True)
-
-        # is_dataframe and ignore_index
-        df1 = pd.DataFrame({'A': [1, 2], 'B': [5, 6]})
-        df2 = pd.DataFrame({'A': [3, 4], 'B': [7, 8]})
-
-        res = pd.concat([df1, df2], axis=0, ignore_index=True)
-        exp = pd.DataFrame([[1, 5], [2, 6], [3, 7], [4, 8]],
-                           columns=['A', 'B'])
-        tm.assert_frame_equal(res, exp, check_index_type=True,
-                              check_column_type=True)
-
-        res = pd.concat([df1, df2], axis=1, ignore_index=True)
-        exp = pd.DataFrame([[1, 5, 3, 7], [2, 6, 4, 8]])
-        tm.assert_frame_equal(res, exp, check_index_type=True,
-                              check_column_type=True)
-
     def test_indicator(self):
         # PR #10054. xref #7412 and closes #8790.
         df1 = DataFrame({'col1': [0, 1], 'col_left': [
@@ -2134,90 +1322,6 @@ class TestMergeMulti(tm.TestCase):
         self.assertRaises(NotImplementedError, f)
 
 
-def _check_join(left, right, result, join_col, how='left',
-                lsuffix='_x', rsuffix='_y'):
-
-    # some smoke tests
-    for c in join_col:
-        assert(result[c].notnull().all())
-
-    left_grouped = left.groupby(join_col)
-    right_grouped = right.groupby(join_col)
-
-    for group_key, group in result.groupby(join_col):
-        l_joined = _restrict_to_columns(group, left.columns, lsuffix)
-        r_joined = _restrict_to_columns(group, right.columns, rsuffix)
-
-        try:
-            lgroup = left_grouped.get_group(group_key)
-        except KeyError:
-            if how in ('left', 'inner'):
-                raise AssertionError('key %s should not have been in the join'
-                                     % str(group_key))
-
-            _assert_all_na(l_joined, left.columns, join_col)
-        else:
-            _assert_same_contents(l_joined, lgroup)
-
-        try:
-            rgroup = right_grouped.get_group(group_key)
-        except KeyError:
-            if how in ('right', 'inner'):
-                raise AssertionError('key %s should not have been in the join'
-                                     % str(group_key))
-
-            _assert_all_na(r_joined, right.columns, join_col)
-        else:
-            _assert_same_contents(r_joined, rgroup)
-
-
-def _restrict_to_columns(group, columns, suffix):
-    found = [c for c in group.columns
-             if c in columns or c.replace(suffix, '') in columns]
-
-    # filter
-    group = group.ix[:, found]
-
-    # get rid of suffixes, if any
-    group = group.rename(columns=lambda x: x.replace(suffix, ''))
-
-    # put in the right order...
-    group = group.ix[:, columns]
-
-    return group
-
-
-def _assert_same_contents(join_chunk, source):
-    NA_SENTINEL = -1234567  # drop_duplicates not so NA-friendly...
-
-    jvalues = join_chunk.fillna(NA_SENTINEL).drop_duplicates().values
-    svalues = source.fillna(NA_SENTINEL).drop_duplicates().values
-
-    rows = set(tuple(row) for row in jvalues)
-    assert(len(rows) == len(source))
-    assert(all(tuple(row) in rows for row in svalues))
-
-
-def _assert_all_na(join_chunk, source_columns, join_col):
-    for c in source_columns:
-        if c in join_col:
-            continue
-        assert(join_chunk[c].isnull().all())
-
-
-def _join_by_hand(a, b, how='left'):
-    join_index = a.index.join(b.index, how=how)
-
-    a_re = a.reindex(join_index)
-    b_re = b.reindex(join_index)
-
-    result_columns = a.columns.append(b.columns)
-
-    for col, s in compat.iteritems(b_re):
-        a_re[col] = s
-    return a_re.reindex(columns=result_columns)
-
-
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
                    exit=False)

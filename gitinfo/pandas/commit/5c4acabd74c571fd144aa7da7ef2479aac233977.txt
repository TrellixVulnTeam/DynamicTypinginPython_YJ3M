commit 5c4acabd74c571fd144aa7da7ef2479aac233977
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Apr 4 12:08:46 2012 -0400

    BUG: temporary hack around TypeError in PyObjectHashTable

diff --git a/pandas/core/index.py b/pandas/core/index.py
index d58262a12..557290c7c 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -251,6 +251,8 @@ class Index(np.ndarray):
         return self
 
     def __contains__(self, key):
+        hash(key)
+        # work around some kind of odd cython bug
         try:
             return key in self._engine
         except TypeError:
@@ -1653,14 +1655,13 @@ class DatetimeIndex(Int64Index):
         try:
             return Index.get_value(self, series, key)
         except KeyError:
+
             try:
                 asdt, parsed, reso = datetools.parse_time_string(key)
                 key = asdt
                 loc = self._partial_date_slice(reso, parsed)
                 return series[loc]
-            except TypeError:
-                pass
-            except KeyError:
+            except (TypeError, ValueError, KeyError):
                 pass
 
             return self._engine.get_value(series, to_timestamp(key))
diff --git a/pandas/src/engines.pyx b/pandas/src/engines.pyx
index bda919a10..b3d9856ff 100644
--- a/pandas/src/engines.pyx
+++ b/pandas/src/engines.pyx
@@ -59,6 +59,7 @@ cdef class IndexEngine:
 
     def __contains__(self, object val):
         self._ensure_mapping_populated()
+        hash(val)
         return val in self.mapping
 
     cpdef get_value(self, ndarray arr, object key):
@@ -135,8 +136,12 @@ cdef class IndexEngine:
         try:
             return self.mapping.get_item(val)
         except TypeError:
+            self._check_type(val)
             raise KeyError(val)
 
+    cdef inline _check_type(self, object val):
+        hash(val)
+
     cdef inline _ensure_mapping_populated(self):
         if not self.initialized:
             self.initialize()
@@ -259,14 +264,19 @@ cdef class DatetimeEngine(IndexEngine):
 
         if util.is_datetime64_object(val):
             val = val.view('i8')
-
-        if PyDateTime_Check(val):
+        elif PyDateTime_Check(val):
             val = np.datetime64(val)
             val = val.view('i8')
 
         try:
             return self.mapping.get_item(val)
         except TypeError:
+            self._check_type(val)
+            raise KeyError(val)
+
+    cdef inline _check_type(self, object val):
+        hash(val)
+        if not util.is_integer_object(val):
             raise KeyError(val)
 
     def get_indexer(self, values):
diff --git a/pandas/src/hashtable.pyx b/pandas/src/hashtable.pyx
index 338ccf60a..40c31acd9 100644
--- a/pandas/src/hashtable.pyx
+++ b/pandas/src/hashtable.pyx
@@ -626,6 +626,7 @@ cdef class PyObjectHashTable(HashTable):
 
     def __contains__(self, object key):
         cdef khiter_t k
+        hash(key)
         k = kh_get_pymap(self.table, <PyObject*>key)
         return k != self.table.n_buckets
 
@@ -654,6 +655,7 @@ cdef class PyObjectHashTable(HashTable):
             int ret = 0
             char* buf
 
+        hash(key)
         k = kh_put_pymap(self.table, <PyObject*>key, &ret)
         # self.table.keys[k] = key
         if kh_exist_pymap(self.table, k):
@@ -670,6 +672,7 @@ cdef class PyObjectHashTable(HashTable):
 
         for i in range(n):
             val = values[i]
+            hash(val)
             k = kh_put_pymap(self.table, <PyObject*>val, &ret)
             self.table.vals[k] = i
 
@@ -683,6 +686,7 @@ cdef class PyObjectHashTable(HashTable):
 
         for i in range(n):
             val = values[i]
+            hash(val)
             k = kh_get_pymap(self.table, <PyObject*>val)
             if k != self.table.n_buckets:
                 locs[i] = self.table.vals[k]
@@ -719,7 +723,7 @@ cdef class PyObjectHashTable(HashTable):
 
         for i in range(n):
             val = values[i]
-
+            hash(val)
             if not _checknan(val):
                 k = kh_get_pymap(self.table, <PyObject*>val)
                 if k == self.table.n_buckets:
@@ -747,6 +751,7 @@ cdef class PyObjectHashTable(HashTable):
 
         for i in range(n):
             val = values[i]
+            hash(val)
 
             if val != val or val is None:
                 labels[i] = na_sentinel
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 4bfcc10ab..8b7c3f50b 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -1191,6 +1191,12 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         self.assertRaises(Exception, setattr, self.mixed_frame, 'columns',
                           cols[::2])
 
+    def test_column_contains_typeerror(self):
+        try:
+            self.frame.columns in self.frame
+        except TypeError:
+            pass
+
     def test_constructor(self):
         df = DataFrame()
         self.assert_(len(df.index) == 0)
diff --git a/pandas/tests/test_timeseries.py b/pandas/tests/test_timeseries.py
index f773e3e75..150dba32f 100644
--- a/pandas/tests/test_timeseries.py
+++ b/pandas/tests/test_timeseries.py
@@ -12,7 +12,8 @@ from numpy import nan
 import numpy as np
 import numpy.ma as ma
 
-from pandas import Index, Series, TimeSeries, DataFrame, isnull, notnull
+from pandas import (Index, Series, TimeSeries, DataFrame, isnull, notnull,
+                    date_range)
 from pandas.core.index import MultiIndex
 
 from pandas import DatetimeIndex
@@ -66,6 +67,15 @@ class TestTimeSeriesDuplicates(unittest.TestCase):
         self.assertRaises(KeyError, ts.__getitem__, datetime(2000, 1, 6))
         self.assertRaises(KeyError, ts.__setitem__, datetime(2000, 1, 6), 0)
 
+    def test_getitem_median_slice_bug(self):
+        index = date_range('20090415', '20090519', freq='2B')
+        s = Series(np.random.randn(13), index=index)
+
+        indexer = [slice(6, 7, None)]
+        result = s[indexer]
+        expected = s[indexer[0]]
+        assert_series_equal(result, expected)
+
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)

commit a7c65ed6b74227a9d4a49097d2da28c876e85c1f
Author: Jan Schulz <jasc@gmx.net>
Date:   Mon Nov 16 16:33:18 2015 +0100

    Make .dt available for Series of type category with datetimes
    
    If a series is a type category and the underlying Categorical has
    categories of type datetime, then make it possible to use the .dt
    assessor on such a series.
    
    The string methods work on the categories (and therefore fast if we have
    only a few categories), but return a Series with a dtype other than
    category (integer,...), so that it is no different if we use
    .dt on a series of type datetime or of type category.

diff --git a/pandas/tests/test_categorical.py b/pandas/tests/test_categorical.py
index beab5754d..ac2f9e77c 100755
--- a/pandas/tests/test_categorical.py
+++ b/pandas/tests/test_categorical.py
@@ -3712,6 +3712,81 @@ Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01
             invalid.str
         self.assertFalse(hasattr(invalid, 'str'))
 
+    def test_dt_accessor_api_for_categorical(self):
+        # https://github.com/pydata/pandas/issues/10661
+        from pandas.tseries.common import Properties
+        from pandas.tseries.index import date_range, DatetimeIndex
+        from pandas.tseries.period import period_range, PeriodIndex
+        from pandas.tseries.tdi import timedelta_range, TimedeltaIndex
+
+        s_dr = Series(date_range('1/1/2015', periods=5, tz="MET"))
+        c_dr = s_dr.astype("category")
+
+        s_pr = Series(period_range('1/1/2015', freq='D', periods=5))
+        c_pr = s_pr.astype("category")
+
+        s_tdr = Series(timedelta_range('1 days','10 days'))
+        c_tdr = s_tdr.astype("category")
+
+        test_data = [
+            ("Datetime", DatetimeIndex._datetimelike_ops, s_dr, c_dr),
+            ("Period", PeriodIndex._datetimelike_ops, s_pr, c_pr),
+            ("Timedelta", TimedeltaIndex._datetimelike_ops, s_tdr, c_tdr)]
+
+        self.assertIsInstance(c_dr.dt, Properties)
+
+        special_func_defs = [
+            ('strftime', ("%Y-%m-%d",), {}),
+            ('tz_convert', ("EST",), {}),
+            #('tz_localize', ("UTC",), {}),
+        ]
+        _special_func_names = [f[0] for f in special_func_defs]
+
+        # the series is already localized
+        _ignore_names = ['tz_localize']
+
+        for name, attr_names, s, c in test_data:
+            func_names = [f for f in dir(s.dt) if not (f.startswith("_") or
+                                                       f in attr_names or
+                                                       f in _special_func_names or
+                                                       f in _ignore_names)]
+
+            func_defs = [(f, (), {}) for f in func_names]
+            for f_def in special_func_defs:
+                if f_def[0] in dir(s.dt):
+                    func_defs.append(f_def)
+
+            for func, args, kwargs in func_defs:
+                res = getattr(c.dt, func)(*args, **kwargs)
+                exp = getattr(s.dt, func)(*args, **kwargs)
+
+                if isinstance(res, pd.DataFrame):
+                    tm.assert_frame_equal(res, exp)
+                elif isinstance(res, pd.Series):
+                    tm.assert_series_equal(res, exp)
+                else:
+                    tm.assert_numpy_array_equal(res, exp)
+
+            for attr in attr_names:
+                try:
+                    res = getattr(c.dt, attr)
+                    exp = getattr(s.dt, attr)
+                except Exception as e:
+                    print(name, attr)
+                    raise e
+
+            if isinstance(res, pd.DataFrame):
+                tm.assert_frame_equal(res, exp)
+            elif isinstance(res, pd.Series):
+                tm.assert_series_equal(res, exp)
+            else:
+                tm.assert_numpy_array_equal(res, exp)
+
+        invalid = Series([1,2,3]).astype('category')
+        with tm.assertRaisesRegexp(AttributeError, "Can only use .dt accessor with datetimelike"):
+            invalid.dt
+        self.assertFalse(hasattr(invalid, 'str'))
+
     def test_pickle_v0_14_1(self):
 
         # we have the name warning
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index f30481ee1..9be0784c7 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -362,12 +362,20 @@ class CheckNameIntegration(object):
         self.assertTrue('str' not in dir(s))
         self.assertTrue('cat' not in dir(s))
 
-        # similiarly for .cat
+        # similiarly for .cat, but with the twist that str and dt should be there
+        # if the categories are of that type
+        # first cat and str
         s = Series(list('abbcd'), dtype="category")
         self.assertTrue('cat' in dir(s))
-        self.assertTrue('str' not in dir(s))
+        self.assertTrue('str' in dir(s)) # as it is a string categorical
         self.assertTrue('dt' not in dir(s))
 
+        # similar to cat and str
+        s = Series(date_range('1/1/2015', periods=5)).astype("category")
+        self.assertTrue('cat' in dir(s))
+        self.assertTrue('str' not in dir(s))
+        self.assertTrue('dt' in dir(s)) # as it is a datetime categorical
+
     def test_binop_maybe_preserve_name(self):
         # names match, preserve
         result = self.ts * self.ts
diff --git a/pandas/tseries/common.py b/pandas/tseries/common.py
index 171f72d37..31b5281aa 100644
--- a/pandas/tseries/common.py
+++ b/pandas/tseries/common.py
@@ -10,8 +10,8 @@ from pandas import tslib
 from pandas.core.common import (_NS_DTYPE, _TD_DTYPE, is_period_arraylike,
                                 is_datetime_arraylike, is_integer_dtype, is_list_like,
                                 is_datetime64_dtype, is_datetime64tz_dtype,
-                                is_timedelta64_dtype,
-                                get_dtype_kinds)
+                                is_timedelta64_dtype, is_categorical_dtype,
+                                get_dtype_kinds, take_1d)
 
 def is_datetimelike(data):
     """ return a boolean if we can be successfully converted to a datetimelike """
@@ -45,26 +45,36 @@ def maybe_to_datetimelike(data, copy=False):
         raise TypeError("cannot convert an object of type {0} to a datetimelike index".format(type(data)))
 
     index = data.index
+    name = data.name
+    orig = data if is_categorical_dtype(data) else None
+    if orig is not None:
+        data = orig.values.categories
+
     if is_datetime64_dtype(data.dtype):
-        return DatetimeProperties(DatetimeIndex(data, copy=copy, freq='infer'), index, name=data.name)
+        return DatetimeProperties(DatetimeIndex(data, copy=copy, freq='infer'), index, name=name,
+                                                orig=orig)
     elif is_datetime64tz_dtype(data.dtype):
-        return DatetimeProperties(DatetimeIndex(data, copy=copy, freq='infer', ambiguous='infer'), index, name=data.name)
+        return DatetimeProperties(DatetimeIndex(data, copy=copy, freq='infer', ambiguous='infer'),
+                                  index, data.name, orig=orig)
     elif is_timedelta64_dtype(data.dtype):
-        return TimedeltaProperties(TimedeltaIndex(data, copy=copy, freq='infer'), index, name=data.name)
+        return TimedeltaProperties(TimedeltaIndex(data, copy=copy, freq='infer'), index,
+                                   name=name, orig=orig)
     else:
         if is_period_arraylike(data):
-            return PeriodProperties(PeriodIndex(data, copy=copy), index, name=data.name)
+            return PeriodProperties(PeriodIndex(data, copy=copy), index, name=name, orig=orig)
         if is_datetime_arraylike(data):
-            return DatetimeProperties(DatetimeIndex(data, copy=copy, freq='infer'), index, name=data.name)
+            return DatetimeProperties(DatetimeIndex(data, copy=copy, freq='infer'), index,
+                                      name=name, orig=orig)
 
     raise TypeError("cannot convert an object of type {0} to a datetimelike index".format(type(data)))
 
 class Properties(PandasDelegate, NoNewAttributesMixin):
 
-    def __init__(self, values, index, name):
+    def __init__(self, values, index, name, orig=None):
         self.values = values
         self.index = index
         self.name = name
+        self.orig = orig
         self._freeze()
 
     def _delegate_property_get(self, name):
@@ -79,6 +89,10 @@ class Properties(PandasDelegate, NoNewAttributesMixin):
         elif not is_list_like(result):
             return result
 
+        # blow up if we operate on categories
+        if self.orig is not None:
+            result = take_1d(result, self.orig.cat.codes)
+
         # return the result as a Series, which is by definition a copy
         result = Series(result, index=self.index, name=self.name)
 

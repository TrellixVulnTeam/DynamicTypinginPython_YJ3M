commit 2450678841270685646830621122c5ec09b2a563
Author: Phillip Cloud <cpcloud@gmail.com>
Date:   Sat Feb 15 20:28:22 2014 -0500

    ENH/CLN: track scope instead of hard coding minimal stack level

diff --git a/pandas/computation/engines.py b/pandas/computation/engines.py
index 936f8313c..120e19073 100644
--- a/pandas/computation/engines.py
+++ b/pandas/computation/engines.py
@@ -4,10 +4,34 @@
 import abc
 
 from pandas import compat
-from pandas.compat import DeepChainMap
+from pandas.compat import DeepChainMap, map
 from pandas.core import common as com
 from pandas.computation.align import _align, _reconstruct_object
-from pandas.computation.ops import UndefinedVariableError
+from pandas.computation.ops import UndefinedVariableError, _mathops, _reductions
+
+
+_ne_builtins = frozenset(_mathops + _reductions)
+
+
+class NumExprClobberingError(NameError):
+    pass
+
+
+def _check_ne_builtin_clash(expr):
+    """Attempt to prevent foot-shooting in a helpful way.
+
+    Parameters
+    ----------
+    terms : Term
+        Terms can contain
+    """
+    names = expr.names
+    overlap = names & _ne_builtins
+
+    if overlap:
+        s = ', '.join(map(repr, overlap))
+        raise NumExprClobberingError('Variables in expression "%s" overlap with '
+                                     'numexpr builtins: (%s)' % (expr, s))
 
 
 class AbstractEngine(object):
@@ -89,9 +113,10 @@ class NumExprEngine(AbstractEngine):
 
         try:
             env = self.expr.env
-            full_scope = DeepChainMap(*(env.resolvers.maps + env.scope.maps))
-            return ne.evaluate(s, local_dict=full_scope,
-                               truediv=env.scope['truediv'])
+            scope = env.full_scope
+            truediv = scope['truediv']
+            _check_ne_builtin_clash(self.expr)
+            return ne.evaluate(s, local_dict=scope, truediv=truediv)
         except KeyError as e:
             # python 3 compat kludge
             try:
@@ -101,6 +126,7 @@ class NumExprEngine(AbstractEngine):
             raise UndefinedVariableError(msg)
 
 
+
 class PythonEngine(AbstractEngine):
 
     """Evaluate an expression in Python space.
diff --git a/pandas/computation/pytables.py b/pandas/computation/pytables.py
index c5b0785fe..f27156ced 100644
--- a/pandas/computation/pytables.py
+++ b/pandas/computation/pytables.py
@@ -7,25 +7,24 @@ from functools import partial
 from datetime import datetime, timedelta
 import numpy as np
 import pandas as pd
-from pandas.compat import u, string_types, PY3
+from pandas.compat import u, string_types, PY3, DeepChainMap
 from pandas.core.base import StringMixin
 import pandas.core.common as com
 from pandas.computation import expr, ops
 from pandas.computation.ops import is_term
+from pandas.computation.scope import _ensure_scope
 from pandas.computation.expr import BaseExprVisitor
 from pandas.computation.common import _ensure_decoded
 from pandas.tseries.timedeltas import _coerce_scalar_to_timedelta_type
 
 
 class Scope(expr.Scope):
-    __slots__ = 'globals', 'locals', 'queryables'
-
-    def __init__(self, gbls=None, lcls=None, queryables=None, level=1):
-        super(
-            Scope,
-            self).__init__(gbls=gbls,
-                           lcls=lcls,
-                           level=level)
+    __slots__ = 'queryables',
+
+    def __init__(self, level, global_dict=None, local_dict=None,
+                 queryables=None):
+        super(Scope, self).__init__(level + 1, global_dict=global_dict,
+                                    local_dict=local_dict)
         self.queryables = queryables or dict()
 
 
@@ -48,9 +47,8 @@ class Term(ops.Term):
                 raise NameError('name {0!r} is not defined'.format(self.name))
             return self.name
 
-        # resolve the rhs (and allow to be None)
-        return self.env.locals.get(self.name,
-                                   self.env.globals.get(self.name, self.name))
+        # resolve the rhs (and allow it to be None)
+        return self.env.resolve(self.name, is_local=False)
 
     @property
     def value(self):
@@ -478,7 +476,7 @@ class Expr(expr.Expr):
     """
 
     def __init__(self, where, op=None, value=None, queryables=None,
-                 encoding=None, scope_level=None):
+                 encoding=None, scope_level=0):
 
         # try to be back compat
         where = self.parse_back_compat(where, op, value)
@@ -488,25 +486,25 @@ class Expr(expr.Expr):
         self.filter = None
         self.terms = None
         self._visitor = None
-        # capture the environement if needed
-        lcls = dict()
-        if isinstance(where, Expr):
 
-            lcls.update(where.env.locals)
+        # capture the environment if needed
+        local_dict = dict()
+
+        if isinstance(where, Expr):
+            local_dict.update(where.env.scope)
             where = where.expr
 
         elif isinstance(where, (list, tuple)):
             for idx, w in enumerate(where):
                 if isinstance(w, Expr):
-                    lcls.update(w.env.locals)
+                    local_dict.update(w.env.scope)
                 else:
                     w = self.parse_back_compat(w)
                     where[idx] = w
             where = ' & ' .join(["(%s)" % w for w in where])
 
         self.expr = where
-        self.env = Scope(lcls=lcls)
-        self.env.update(scope_level)
+        self.env = Scope(scope_level + 1, local_dict=local_dict)
 
         if queryables is not None and isinstance(self.expr, string_types):
             self.env.queryables.update(queryables)
@@ -535,7 +533,7 @@ class Expr(expr.Expr):
             warnings.warn("passing a tuple into Expr is deprecated, "
                           "pass the where as a single string",
                           DeprecationWarning)
-                
+
         if op is not None:
             if not isinstance(w, string_types):
                 raise TypeError(
diff --git a/pandas/computation/scope.py b/pandas/computation/scope.py
index 9f0c69319..298ab6b9d 100644
--- a/pandas/computation/scope.py
+++ b/pandas/computation/scope.py
@@ -13,18 +13,18 @@ import pandas as pd
 from pandas.compat import DeepChainMap, map
 from pandas.core import common as com
 from pandas.core.base import StringMixin
-from pandas.computation.ops import UndefinedVariableError
+from pandas.computation.ops import UndefinedVariableError, _LOCAL_TAG
 
 
 def _ensure_scope(level, global_dict=None, local_dict=None, resolvers=(),
                   target=None, **kwargs):
     """Ensure that we are grabbing the correct scope."""
-    return Scope(level + 1, gbls=global_dict, lcls=local_dict,
+    return Scope(level + 1, global_dict=global_dict, local_dict=local_dict,
                  resolvers=resolvers, target=target)
 
 
-def _replacer(x, pad_size):
-    """Replace a number with its padded hexadecimal representation. Used to tag
+def _replacer(x):
+    """Replace a number with its hexadecimal representation. Used to tag
     temporary variables with their calling scope's id.
     """
     # get the hex repr of the binary char and remove 0x and pad by pad_size
@@ -35,14 +35,14 @@ def _replacer(x, pad_size):
         # bytes literals masquerade as ints when iterating in py3
         hexin = x
 
-    return hex(hexin).replace('0x', '').rjust(pad_size, '0')
+    return hex(hexin)
 
 
-def _raw_hex_id(obj, pad_size=2):
+def _raw_hex_id(obj):
     """Return the padded hexadecimal id of ``obj``."""
     # interpret as a pointer since that's what really what id returns
     packed = struct.pack('@P', id(obj))
-    return ''.join(_replacer(x, pad_size) for x in packed)
+    return ''.join(map(_replacer, packed))
 
 
 
@@ -56,11 +56,19 @@ _DEFAULT_GLOBALS = {
 }
 
 
-def _is_resolver(x):
-    return isinstance(x, Resolver)
+def _get_pretty_string(obj):
+    """Return a prettier version of obj
 
+    Parameters
+    ----------
+    obj : object
+        Object to pretty print
 
-def _get_pretty_string(obj):
+    Returns
+    -------
+    s : str
+        Pretty print object repr
+    """
     sio = StringIO()
     pprint.pprint(obj, stream=sio)
     return sio.getvalue()
@@ -69,39 +77,39 @@ def _get_pretty_string(obj):
 class Scope(StringMixin):
 
     """Object to hold scope, with a few bells to deal with some custom syntax
-    added by pandas.
+    and contexts added by pandas.
 
     Parameters
     ----------
-    gbls : dict or None, optional, default None
-    lcls : dict or Scope or None, optional, default None
-    level : int, optional, default 1
+    level : int
+    global_dict : dict or None, optional, default None
+    local_dict : dict or Scope or None, optional, default None
     resolvers : list-like or None, optional, default None
+    target : object
 
     Attributes
     ----------
-    globals : dict
-    locals : dict
     level : int
-    resolvers : tuple
-    resolver_keys : frozenset
+    scope : DeepChainMap
+    target : object
+    temps : dict
     """
-    __slots__ = 'level', 'scope', 'target', 'ntemps'
+    __slots__ = 'level', 'scope', 'target', 'temps'
 
-    def __init__(self, level, gbls=None, lcls=None, resolvers=(), target=None):
+    def __init__(self, level, global_dict=None, local_dict=None, resolvers=(),
+                 target=None):
         self.level = level + 1
 
         # shallow copy because we don't want to keep filling this up with what
         # was there before if there are multiple calls to Scope/_ensure_scope
         self.scope = DeepChainMap(_DEFAULT_GLOBALS.copy())
         self.target = target
-        self.ntemps = 0  # number of temporary variables in this scope
 
-        if isinstance(lcls, Scope):
-            self.scope.update(lcls.scope)
-            if lcls.target is not None:
-                self.target = lcls.target
-            self.update(lcls.level)
+        if isinstance(local_dict, Scope):
+            self.scope.update(local_dict.scope)
+            if local_dict.target is not None:
+                self.target = local_dict.target
+            self.update(local_dict.level)
 
         frame = sys._getframe(self.level)
 
@@ -109,29 +117,38 @@ class Scope(StringMixin):
             # shallow copy here because we don't want to replace what's in
             # scope when we align terms (alignment accesses the underlying
             # numpy array of pandas objects)
-            if not isinstance(lcls, Scope):
-                self.scope = self.scope.new_child((lcls or frame.f_locals).copy())
-            self.scope = self.scope.new_child((gbls or frame.f_globals).copy())
+            if not isinstance(local_dict, Scope):
+                self.scope = self.scope.new_child((local_dict or
+                                                   frame.f_locals).copy())
+            self.scope = self.scope.new_child((global_dict or
+                                               frame.f_globals).copy())
         finally:
             del frame
 
         # assumes that resolvers are going from outermost scope to inner
-        if isinstance(lcls, Scope):
-            resolvers += tuple(lcls.resolvers.maps)
+        if isinstance(local_dict, Scope):
+            resolvers += tuple(local_dict.resolvers.maps)
         self.resolvers = DeepChainMap(*resolvers)
+        self.temps = {}
 
     def __unicode__(self):
         scope_keys = _get_pretty_string(self.scope.keys())
         res_keys = _get_pretty_string(self.resolvers.keys())
-        return 'Scope(scope=%s, resolvers=%s)' % (scope_keys, res_keys)
+        return '%s(scope=%s, resolvers=%s)' % (type(self).__name__, scope_keys,
+                                               res_keys)
 
     @property
     def has_resolvers(self):
-        return bool(self.nresolvers)
+        """Return whether we have any extra scope.
 
-    @property
-    def nresolvers(self):
-        return len(self.resolvers)
+        For example, DataFrames pass Their columns as resolvers during calls to
+        ``DataFrame.eval()`` and ``DataFrame.query()``.
+
+        Returns
+        -------
+        hr : bool
+        """
+        return bool(len(self.resolvers))
 
     def resolve(self, key, is_local):
         """Resolve a variable name in a possibly local context
@@ -163,14 +180,33 @@ class Scope(StringMixin):
             assert not is_local and not self.has_resolvers
             return self.scope[key]
         except KeyError:
-            raise UndefinedVariableError(key)
+            try:
+                # last ditch effort we look in temporaries
+                # these are created when parsing indexing expressions
+                # e.g., df[df > 0]
+                return self.temps[key]
+            except KeyError:
+                raise UndefinedVariableError(key)
 
     def swapkey(self, old_key, new_key, new_value=None):
+        """Replace a variable name, with a potentially new value.
+
+        Parameters
+        ----------
+        old_key : str
+            Current variable name to replace
+        new_key : str
+            New variable name to replace `old_key` with
+        new_value : object
+            Value to be replaced along with the possible renaming
+        """
         if self.has_resolvers:
             maps = self.resolvers.maps + self.scope.maps
         else:
             maps = self.scope.maps
 
+        maps.append(self.temps)
+
         for mapping in maps:
             if old_key in mapping:
                 if new_value is None:
@@ -181,6 +217,16 @@ class Scope(StringMixin):
         raise KeyError(old_key)
 
     def _get_vars(self, stack, scopes):
+        """Get specifically scoped variables from a list of stack frames.
+
+        Parameters
+        ----------
+        stack : list
+            A list of stack frames as returned by ``inspect.stack()``
+        scopes : sequence of strings
+            A sequence containing valid stack frame attribute names that
+            evaluate to a dictionary. For example, ('locals', 'globals')
+        """
         variables = itertools.product(scopes, stack)
         for scope, (frame, _, _, _, _, _) in variables:
             try:
@@ -224,17 +270,41 @@ class Scope(StringMixin):
         name : basestring
             The name of the temporary variable created.
         """
-        name = 'tmp_var_{0}_{1}_{2}'.format(type(value).__name__, self.ntemps,
-                                            _raw_hex_id(self))
+        name = '{0}_{1}_{2}'.format(type(value).__name__, self.ntemps,
+                                    _raw_hex_id(self))
 
         # add to inner most scope
-        assert name not in self.scope.maps[0]
-        self.scope.maps[0][name] = value
+        assert name not in self.temps
+        self.temps[name] = value
+        assert name in self.temps
 
         # only increment if the variable gets put in the scope
-        self.ntemps += 1
         return name
 
     def remove_tmp(self, name):
-        del self.scope[name]
-        self.ntemps -= 1
+        """Remove a temporary variable from this scope
+
+        Parameters
+        ----------
+        name : str
+            The name of a temporary to be removed
+        """
+        del self.temps[name]
+
+    @property
+    def ntemps(self):
+        """The number of temporary variables in this scope"""
+        return len(self.temps)
+
+    @property
+    def full_scope(self):
+        """Return the full scope for use with passing to engines transparently
+        as a mapping.
+
+        Returns
+        -------
+        vars : DeepChainMap
+            All variables in this scope.
+        """
+        maps = [self.temps] + self.resolvers.maps + self.scope.maps
+        return DeepChainMap(*maps)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index e448c9668..a48bbbd8f 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -36,7 +36,7 @@ from pandas.core.internals import (BlockManager,
 from pandas.core.series import Series
 import pandas.computation.expressions as expressions
 from pandas.computation.eval import eval as _eval
-from pandas.computation.expr import _ensure_scope
+from pandas.computation.scope import _ensure_scope
 from pandas.compat.scipy import scoreatpercentile as _quantile
 from pandas.compat import(range, zip, lrange, lmap, lzip, StringIO, u,
                           OrderedDict, raise_with_traceback)
@@ -1803,12 +1803,7 @@ class DataFrame(NDFrame):
         # 2 self.eval
         # 1 self.query
         # 0 self.query caller (implicit)
-        level = kwargs.setdefault('level', 4)
-        if level < 4:
-            raise ValueError("Going up fewer than 4 stack frames will not"
-                             " capture the necessary variable scope for a "
-                             "query expression")
-
+        kwargs['level'] = kwargs.pop('level', 0) + 1
         res = self.eval(expr, **kwargs)
 
         try:
@@ -1852,14 +1847,15 @@ class DataFrame(NDFrame):
         >>> from pandas import DataFrame
         >>> df = DataFrame(randn(10, 2), columns=list('ab'))
         >>> df.eval('a + b')
-        >>> df.eval('c=a + b')
+        >>> df.eval('c = a + b')
         """
         resolvers = kwargs.pop('resolvers', None)
+        kwargs['level'] = kwargs.pop('level', 0) + 1
         if resolvers is None:
-            index_resolvers = self._get_resolvers()
-            resolvers = [self, index_resolvers]
-        kwargs['local_dict'] = _ensure_scope(resolvers=resolvers, **kwargs)
+            index_resolvers = self._get_index_resolvers()
+            resolvers = index_resolvers, dict(self.iteritems())
         kwargs['target'] = self
+        kwargs['resolvers'] = kwargs.get('resolvers', ()) + resolvers
         return _eval(expr, **kwargs)
 
     def _slice(self, slobj, axis=0, raise_on_error=False, typ=None):
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 85a9cf4ea..32a3a1ab7 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -66,7 +66,7 @@ def _ensure_encoding(encoding):
 Term = Expr
 
 
-def _ensure_term(where):
+def _ensure_term(where, scope_level):
     """
     ensure that the where is a Term or a list of Term
     this makes sure that we are capturing the scope of variables
@@ -76,11 +76,12 @@ def _ensure_term(where):
 
     # only consider list/tuple here as an ndarray is automaticaly a coordinate
     # list
+    level = scope_level + 1
     if isinstance(where, (list, tuple)):
-        where = [w if not maybe_expression(w) else Term(w, scope_level=2)
+        where = [w if not maybe_expression(w) else Term(w, scope_level=level)
                  for w in where if w is not None]
     elif maybe_expression(where):
-        where = Term(where, scope_level=2)
+        where = Term(where, level)
     return where
 
 
@@ -311,7 +312,7 @@ def read_hdf(path_or_buf, key, **kwargs):
 
     # grab the scope
     if 'where' in kwargs:
-        kwargs['where'] = _ensure_term(kwargs['where'])
+        kwargs['where'] = _ensure_term(kwargs['where'], scope_level=1)
 
     f = lambda store, auto_close: store.select(
         key, auto_close=auto_close, **kwargs)
@@ -643,7 +644,7 @@ class HDFStore(StringMixin):
             raise KeyError('No object named %s in the file' % key)
 
         # create the storer and axes
-        where = _ensure_term(where)
+        where = _ensure_term(where, scope_level=1)
         s = self._create_storer(group)
         s.infer_axes()
 
@@ -675,7 +676,7 @@ class HDFStore(StringMixin):
         start : integer (defaults to None), row number to start selection
         stop  : integer (defaults to None), row number to stop selection
         """
-        where = _ensure_term(where)
+        where = _ensure_term(where, scope_level=1)
         return self.get_storer(key).read_coordinates(where=where, start=start,
                                                      stop=stop, **kwargs)
 
@@ -730,7 +731,7 @@ class HDFStore(StringMixin):
         """
 
         # default to single select
-        where = _ensure_term(where)
+        where = _ensure_term(where, scope_level=1)
         if isinstance(keys, (list, tuple)) and len(keys) == 1:
             keys = keys[0]
         if isinstance(keys, string_types):
@@ -776,8 +777,8 @@ class HDFStore(StringMixin):
                 c = s.read_coordinates(where=where, start=_start, stop=_stop, **kwargs)
             else:
                 c = None
-                
-            objs = [t.read(where=c, start=_start, stop=_stop, 
+
+            objs = [t.read(where=c, start=_start, stop=_stop,
                            columns=columns, **kwargs) for t in tbls]
 
             # concat and return
@@ -838,7 +839,7 @@ class HDFStore(StringMixin):
         raises KeyError if key is not a valid store
 
         """
-        where = _ensure_term(where)
+        where = _ensure_term(where, scope_level=1)
         try:
             s = self.get_storer(key)
         except:
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index af7dc780e..7a3a64271 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -12325,6 +12325,7 @@ class TestDataFrameQueryWithMultiIndex(object):
         df = DataFrame(randn(10, 2), index=index)
         ind = Series(df.index.get_level_values(0).values, index=index)
 
+        #import ipdb; ipdb.set_trace()
         res1 = df.query('ilevel_0 == "red"', parser=parser, engine=engine)
         res2 = df.query('"red" == ilevel_0', parser=parser, engine=engine)
         exp = df[ind == 'red']
@@ -12448,7 +12449,7 @@ class TestDataFrameQueryWithMultiIndex(object):
 
     def check_query_multiindex_get_index_resolvers(self, parser, engine):
         df = mkdf(10, 3, r_idx_nlevels=2, r_idx_names=['spam', 'eggs'])
-        resolvers = df._get_resolvers()
+        resolvers = df._get_index_resolvers()
 
         def to_series(mi, level):
             level_values = mi.get_level_values(level)
@@ -12508,17 +12509,29 @@ class TestDataFrameQueryNumExprPandas(tm.TestCase):
         super(TestDataFrameQueryNumExprPandas, cls).tearDownClass()
         del cls.engine, cls.parser
 
-    def test_date_query_method(self):
+    def test_date_query_with_attribute_access(self):
         engine, parser = self.engine, self.parser
+        skip_if_no_pandas_parser(parser)
         df = DataFrame(randn(5, 3))
         df['dates1'] = date_range('1/1/2012', periods=5)
         df['dates2'] = date_range('1/1/2013', periods=5)
         df['dates3'] = date_range('1/1/2014', periods=5)
-        res = df.query('dates1 < 20130101 < dates3', engine=engine,
+        res = df.query('@df.dates1 < 20130101 < @df.dates3', engine=engine,
                        parser=parser)
         expec = df[(df.dates1 < '20130101') & ('20130101' < df.dates3)]
         assert_frame_equal(res, expec)
 
+    def test_date_query_no_attribute_access(self):
+        engine, parser = self.engine, self.parser
+        df = DataFrame(randn(5, 3))
+        df['dates1'] = date_range('1/1/2012', periods=5)
+        df['dates2'] = date_range('1/1/2013', periods=5)
+        df['dates3'] = date_range('1/1/2014', periods=5)
+        res = df.query('dates1 < 20130101 < dates3', engine=engine,
+                       parser=parser)
+        expec = df[(df.dates1 < '20130101') & ('20130101' < df.dates3)]
+        tm.assert_frame_equal(res, expec)
+
     def test_date_query_with_NaT(self):
         engine, parser = self.engine, self.parser
         n = 10
@@ -12576,7 +12589,7 @@ class TestDataFrameQueryNumExprPandas(tm.TestCase):
 
         n = 10
         df = DataFrame({'dates': date_range('1/1/2012', periods=n),
-             'nondate': np.arange(n)})
+                        'nondate': np.arange(n)})
 
         ops = '==', '!=', '<', '>', '<=', '>='
 
@@ -12584,32 +12597,61 @@ class TestDataFrameQueryNumExprPandas(tm.TestCase):
             with tm.assertRaises(TypeError):
                 df.query('dates %s nondate' % op, parser=parser, engine=engine)
 
-    def test_query_scope(self):
+    def test_query_syntax_error(self):
         engine, parser = self.engine, self.parser
-        from pandas.computation.common import NameResolutionError
-
         df = DataFrame({"i": lrange(10), "+": lrange(3, 13),
                         "r": lrange(4, 14)})
-        i, s = 5, 6
-        self.assertRaises(NameResolutionError, df.query, 'i < 5',
-                          engine=engine, parser=parser, local_dict={'i': i})
-        self.assertRaises(SyntaxError, df.query, 'i - +', engine=engine,
-                          parser=parser)
-        self.assertRaises(NameResolutionError, df.query, 'i == s',
-                          engine=engine, parser=parser, local_dict={'i': i,
-                                                                    's': s})
-
-    def test_query_scope_index(self):
+        with tm.assertRaises(SyntaxError):
+            df.query('i - +', engine=engine, parser=parser)
+
+    def test_query_scope(self):
+        from pandas.computation.ops import UndefinedVariableError
         engine, parser = self.engine, self.parser
-        from pandas.computation.common import NameResolutionError
-        df = DataFrame(np.random.randint(10, size=(10, 3)),
-                       index=Index(range(10), name='blob'),
-                       columns=['a', 'b', 'c'])
+        skip_if_no_pandas_parser(parser)
+
+        df = DataFrame(np.random.randn(20, 2), columns=list('ab'))
+
+        a, b = 1, 2
+        res = df.query('a > b', engine=engine, parser=parser)
+        expected = df[df.a > df.b]
+        tm.assert_frame_equal(res, expected)
+
+        res = df.query('@a > b', engine=engine, parser=parser)
+        expected = df[a > df.b]
+        tm.assert_frame_equal(res, expected)
+
+        # no local variable c
+        with tm.assertRaises(UndefinedVariableError):
+            df.query('@a > b > @c', engine=engine, parser=parser)
+
+        # no column named 'c'
+        with tm.assertRaises(UndefinedVariableError):
+            df.query('@a > b > c', engine=engine, parser=parser)
+
+    def test_query_doesnt_pickup_local(self):
+        from pandas.computation.ops import UndefinedVariableError
+
+        engine, parser = self.engine, self.parser
+        n = m = 10
+        df = DataFrame(np.random.randint(m, size=(n, 3)), columns=list('abc'))
+
         from numpy import sin
+
+        # we don't pick up the local 'sin'
+        with tm.assertRaises(UndefinedVariableError):
+            df.query('sin > 5', engine=engine, parser=parser)
+
+    def test_query_builtin(self):
+        from pandas.computation.engines import NumExprClobberingError
+        engine, parser = self.engine, self.parser
+
+        n = m = 10
+        df = DataFrame(np.random.randint(m, size=(n, 3)), columns=list('abc'))
+
         df.index.name = 'sin'
-        self.assertRaises(NameResolutionError, df.query, 'sin > 5',
-                          engine=engine, parser=parser, local_dict={'sin':
-                                                                    sin})
+        with tm.assertRaisesRegexp(NumExprClobberingError,
+                                  'Variables in expression.+'):
+            df.query('sin > 5', engine=engine, parser=parser)
 
     def test_query(self):
         engine, parser = self.engine, self.parser
@@ -12621,16 +12663,6 @@ class TestDataFrameQueryNumExprPandas(tm.TestCase):
                                     parser=parser),
                            df[df.a + df.b > df.b * df.c])
 
-        local_dict = dict(df.iteritems())
-        local_dict.update({'df': df})
-        self.assertRaises(NameError, df.query, 'a < d & b < f',
-                          local_dict=local_dict, engine=engine, parser=parser)
-
-        # make sure that it's not just because we didn't pass the locals in
-        self.assertRaises(AssertionError, self.assertRaises, NameError,
-                          df.query, 'a < b', local_dict={'df': df},
-                          engine=engine, parser=parser)
-
     def test_query_index_with_name(self):
         engine, parser = self.engine, self.parser
         df = DataFrame(np.random.randint(10, size=(10, 3)),
@@ -12663,36 +12695,41 @@ class TestDataFrameQueryNumExprPandas(tm.TestCase):
     def test_nested_scope(self):
         engine = self.engine
         parser = self.parser
-        # smoke test
-        x = 1
-        result = pd.eval('x + 1', engine=engine, parser=parser)
-        self.assertEqual(result, 2)
 
-        df  = DataFrame(np.random.randn(5, 3))
+        skip_if_no_pandas_parser(parser)
+
+        df = DataFrame(np.random.randn(5, 3))
         df2 = DataFrame(np.random.randn(5, 3))
-        expected = df[(df>0) & (df2>0)]
+        expected = df[(df > 0) & (df2 > 0)]
 
-        result = df.query('(df>0) & (df2>0)', engine=engine, parser=parser)
+        result = df.query('(@df > 0) & (@df2 > 0)', engine=engine, parser=parser)
         assert_frame_equal(result, expected)
 
-        result = pd.eval('df[(df > 0) and (df2 > 0)]', engine=engine,
+        result = pd.eval('@df[@df > 0 and @df2 > 0]', engine=engine,
                          parser=parser)
         assert_frame_equal(result, expected)
 
-        result = pd.eval('df[(df > 0) and (df2 > 0) and df[df > 0] > 0]',
+        result = pd.eval('@df[@df > 0 and @df2 > 0 and @df[@df > 0] > 0]',
                          engine=engine, parser=parser)
         expected = df[(df > 0) & (df2 > 0) & (df[df > 0] > 0)]
         assert_frame_equal(result, expected)
 
-        result = pd.eval('df[(df>0) & (df2>0)]', engine=engine, parser=parser)
-        expected = df.query('(df>0) & (df2>0)', engine=engine, parser=parser)
+        result = pd.eval('@df[(@df>0) & (@df2>0)]', engine=engine, parser=parser)
+        expected = df.query('(@df>0) & (@df2>0)', engine=engine, parser=parser)
         assert_frame_equal(result, expected)
 
+    def test_nested_raises_on_local_self_reference(self):
+        from pandas.computation.ops import UndefinedVariableError
+
+        df = DataFrame(np.random.randn(5, 3))
+
+        # can't reference ourself b/c we're a local so @ is necessary
+        with tm.assertRaises(UndefinedVariableError):
+            df.query('df > 0', engine=self.engine, parser=self.parser)
+
     def test_local_syntax(self):
         skip_if_no_pandas_parser(self.parser)
 
-        from pandas.computation.common import NameResolutionError
-
         engine, parser = self.engine, self.parser
         df = DataFrame(randn(100, 10), columns=list('abcdefghij'))
         b = 1
@@ -12700,13 +12737,6 @@ class TestDataFrameQueryNumExprPandas(tm.TestCase):
         result = df.query('a < @b', engine=engine, parser=parser)
         assert_frame_equal(result, expect)
 
-        # scope issue with self.assertRaises so just catch it and let it pass
-        try:
-            df.query('a < @b', engine=engine, parser=parser)
-        except NameResolutionError:
-            pass
-
-        del b
         expect = df[df.a < df.b]
         result = df.query('a < b', engine=engine, parser=parser)
         assert_frame_equal(result, expect)
@@ -12733,17 +12763,16 @@ class TestDataFrameQueryNumExprPython(TestDataFrameQueryNumExprPandas):
         tm.skip_if_no_ne(cls.engine)
         cls.frame = _frame.copy()
 
-    def test_date_query_method(self):
+    def test_date_query_no_attribute_access(self):
         engine, parser = self.engine, self.parser
         df = DataFrame(randn(5, 3))
         df['dates1'] = date_range('1/1/2012', periods=5)
         df['dates2'] = date_range('1/1/2013', periods=5)
         df['dates3'] = date_range('1/1/2014', periods=5)
-        res = df.query('(df.dates1 < 20130101) & (20130101 < df.dates3)',
+        res = df.query('(dates1 < 20130101) & (20130101 < dates3)',
                        engine=engine, parser=parser)
         expec = df[(df.dates1 < '20130101') & ('20130101' < df.dates3)]
-        assert_frame_equal(res, expec)
-
+        tm.assert_frame_equal(res, expec)
     def test_date_query_with_NaT(self):
         engine, parser = self.engine, self.parser
         n = 10
@@ -12792,10 +12821,10 @@ class TestDataFrameQueryNumExprPython(TestDataFrameQueryNumExprPandas):
         df.loc[np.random.rand(n) > 0.5, 'dates1'] = pd.NaT
         df.set_index('dates1', inplace=True, drop=True)
         with tm.assertRaises(NotImplementedError):
-            res = df.query('index < 20130101 < dates3', engine=engine,
-                           parser=parser)
+            df.query('index < 20130101 < dates3', engine=engine, parser=parser)
 
     def test_nested_scope(self):
+        from pandas.computation.ops import UndefinedVariableError
         engine = self.engine
         parser = self.parser
         # smoke test
@@ -12805,23 +12834,23 @@ class TestDataFrameQueryNumExprPython(TestDataFrameQueryNumExprPandas):
 
         df  = DataFrame(np.random.randn(5, 3))
         df2 = DataFrame(np.random.randn(5, 3))
-        expected = df[(df>0) & (df2>0)]
 
-        result = df.query('(df>0) & (df2>0)', engine=engine, parser=parser)
-        assert_frame_equal(result, expected)
+        # don't have the pandas parser
+        with tm.assertRaises(SyntaxError):
+            df.query('(@df>0) & (@df2>0)', engine=engine, parser=parser)
 
+        with tm.assertRaises(UndefinedVariableError):
+            df.query('(df>0) & (df2>0)', engine=engine, parser=parser)
+
+        expected = df[(df > 0) & (df2 > 0)]
         result = pd.eval('df[(df > 0) & (df2 > 0)]', engine=engine,
                          parser=parser)
-        assert_frame_equal(result, expected)
+        tm.assert_frame_equal(expected, result)
 
+        expected = df[(df > 0) & (df2 > 0) & (df[df > 0] > 0)]
         result = pd.eval('df[(df > 0) & (df2 > 0) & (df[df > 0] > 0)]',
                          engine=engine, parser=parser)
-        expected = df[(df > 0) & (df2 > 0) & (df[df > 0] > 0)]
-        assert_frame_equal(result, expected)
-
-        result = pd.eval('df[(df>0) & (df2>0)]', engine=engine, parser=parser)
-        expected = df.query('(df>0) & (df2>0)', engine=engine, parser=parser)
-        assert_frame_equal(result, expected)
+        tm.assert_frame_equal(expected, result)
 
 
 class TestDataFrameQueryPythonPandas(TestDataFrameQueryNumExprPandas):
@@ -12833,6 +12862,17 @@ class TestDataFrameQueryPythonPandas(TestDataFrameQueryNumExprPandas):
         cls.parser = 'pandas'
         cls.frame = _frame.copy()
 
+    def test_query_builtin(self):
+        from pandas.computation.engines import NumExprClobberingError
+        engine, parser = self.engine, self.parser
+
+        n = m = 10
+        df = DataFrame(np.random.randint(m, size=(n, 3)), columns=list('abc'))
+
+        df.index.name = 'sin'
+        expected = df[df.index > 5]
+        result = df.query('sin > 5', engine=engine, parser=parser)
+        tm.assert_frame_equal(expected, result)
 
 class TestDataFrameQueryPythonPython(TestDataFrameQueryNumExprPython):
 
@@ -12842,6 +12882,17 @@ class TestDataFrameQueryPythonPython(TestDataFrameQueryNumExprPython):
         cls.engine = cls.parser = 'python'
         cls.frame = _frame.copy()
 
+    def test_query_builtin(self):
+        from pandas.computation.engines import NumExprClobberingError
+        engine, parser = self.engine, self.parser
+
+        n = m = 10
+        df = DataFrame(np.random.randint(m, size=(n, 3)), columns=list('abc'))
+
+        df.index.name = 'sin'
+        expected = df[df.index > 5]
+        result = df.query('sin > 5', engine=engine, parser=parser)
+        tm.assert_frame_equal(expected, result)
 
 PARSERS = 'python', 'pandas'
 ENGINES = 'python', 'numexpr'
@@ -12910,8 +12961,8 @@ class TestDataFrameQueryStrings(object):
 
             for lhs, op, rhs in zip(lhs, ops, rhs):
                 ex = '{lhs} {op} {rhs}'.format(lhs=lhs, op=op, rhs=rhs)
-                assertRaises(NotImplementedError, df.query, ex, engine=engine,
-                             parser=parser, local_dict={'strings': df.strings})
+                with tm.assertRaises(NotImplementedError):
+                    df.query(ex, engine=engine, parser=parser)
         else:
             res = df.query('strings == ["a", "b"]', engine=engine,
                            parser=parser)

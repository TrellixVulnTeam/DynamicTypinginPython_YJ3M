commit 9125abcf3c3fbb26d7eb753f81b521f80177f195
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jun 13 21:58:50 2011 -0400

    some consolidation, deprecations, cleanup

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index fb6e81bed..547a1c85f 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -168,8 +168,9 @@ class DataFrame(PandasGeneric):
         # segregates dtypes and forms blocks matching to columns
         blocks, columns = form_blocks(homogenized, index, columns)
 
-        # TODO: need consolidate here?
-        return BlockManager(blocks, index, columns).consolidate()
+        # consolidate for now
+        mgr = BlockManager(blocks, index, columns)
+        return mgr.consolidate()
 
     def _init_matrix(self, values, index, columns, dtype=None,
                      copy=True):
@@ -598,6 +599,7 @@ class DataFrame(PandasGeneric):
         Columns are presented in sorted order unless a specific list
         of columns is provided.
         """
+        self._consolidate_inplace()
         return self._data.as_matrix(columns)
 
     def transpose(self):
@@ -785,6 +787,9 @@ class DataFrame(PandasGeneric):
         if mask.dtype != np.bool_:
             raise Exception('Must pass DataFrame with boolean values only')
 
+        if self._data.is_mixed_dtype():
+            raise Exception('Boolean setting not possible on mixed-type frame')
+
         self.values[mask] = value
 
     def _insert_item(self, key, value):
@@ -1042,8 +1047,22 @@ class DataFrame(PandasGeneric):
     # Sorting
 
     def sort(self, column=None, ascending=True):
+        """
+        Sort DataFrame either by index (default) by the values in a column
+
+        Parameters
+        ----------
+        columns : object
+            Column name in frame
+        ascending : boolean, default True
+            Sort ascending vs. descending
+
+        Returns
+        -------
+        sorted : DataFrame
+        """
         if column:
-            series = self[column].order(missingAtEnd=False)
+            series = self[column].order(na_last=False)
             sort_index = series.index
         else:
             index = np.asarray(self.index)
@@ -1132,6 +1151,8 @@ class DataFrame(PandasGeneric):
         if index is None and columns is None:
             raise Exception('must pass either index or columns')
 
+        self._consolidate_inplace()
+
         result = self.copy()
 
         if index is not None:
@@ -1377,10 +1398,6 @@ class DataFrame(PandasGeneric):
     def last_valid_index(self):
         return self.index[self.count(1) > 0][-1]
 
-    # to avoid API breakage
-    _firstTimeWithValue = first_valid_index
-    _lastTimeWithValue = last_valid_index
-
     def head(self):
         return self[:5]
 
@@ -2391,6 +2408,16 @@ class DataFrame(PandasGeneric):
                       "instead", FutureWarning)
         return self.as_matrix(*args, **kwargs)
 
+    def _firstTimeWithValue(self): # pragma: no cover
+        warnings.warn("_firstTimeWithValue is deprecated. Use "
+                      "first_valid_index instead", FutureWarning)
+        return self.first_valid_index()
+
+    def _lastTimeWithValue(self): # pragma: no cover
+        warnings.warn("_firstTimeWithValue is deprecated. Use "
+                      "last_valid_index instead", FutureWarning)
+        return self.last_valid_index()
+
     #----------------------------------------------------------------------
     # Fancy indexing
 
@@ -2577,17 +2604,13 @@ def _homogenize_series(data, index, dtype=None):
                 v = [v.get(i, nan) for i in index]
             else:
                 assert(len(v) == len(index))
+
+            # only *attempt* to cast to dtype
             try:
                 v = Series(v, dtype=dtype, index=index)
             except Exception:
                 v = Series(v, index=index)
 
-        # # OK, I will relent for now.
-        # if not issubclass(v.dtype.type, (float, int)):
-        # #     v = v.astype(np.float64)
-        # # else:
-        #     v = v.astype(object)
-
         homogenized[k] = v
 
     return homogenized
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 88d546dfb..bd481eab0 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -231,6 +231,14 @@ class BlockManager(object):
         if not skip_integrity_check:
             self._verify_integrity()
 
+    def is_mixed_dtype(self):
+        counts = set()
+        for block in self.blocks:
+            counts.add(block.dtype)
+            if len(counts) > 1:
+                return True
+        return False
+
     _columns = None
     def _set_columns(self, value):
         self._columns = _ensure_index(value)
@@ -344,7 +352,8 @@ class BlockManager(object):
 
         if len(self.blocks) > 1:
             if not copy:
-                raise Exception('cannot get view of mixed-type DataFrame')
+                raise Exception('cannot get view of mixed-type or '
+                                'non-consolidated DataFrame')
             vals = np.concatenate([b.values[i] for b in self.blocks])
             cols = np.concatenate([b.columns for b in self.blocks])
             xs = Series(vals, index=cols).reindex(self.columns)
diff --git a/pandas/core/series.py b/pandas/core/series.py
index f14063ca1..b49f216e6 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -233,13 +233,6 @@ class Series(np.ndarray, PandasGeneric):
         from pandas.core.sparse import SparseSeries
         return SparseSeries(self, kind=kind, fill_value=fill_value)
 
-    @classmethod
-    def fromValue(cls, value=np.NaN, index=None, dtype=None): # pragma: no cover
-        warnings.warn("'fromValue', can call Series(value, index=index) now",
-                      FutureWarning)
-
-        return Series(value, index=index, dtype=dtype)
-
     def __contains__(self, key):
         return key in self.index
 
@@ -786,7 +779,7 @@ class Series(np.ndarray, PandasGeneric):
         """
         Overridden NumPy sort, taking care with missing values
         """
-        sortedSeries = self.order(missingAtEnd=True)
+        sortedSeries = self.order(na_last=True)
         self[:] = sortedSeries
         self.index = sortedSeries.index
 
@@ -805,21 +798,18 @@ class Series(np.ndarray, PandasGeneric):
         else:
             return Series(np.argsort(values), index=self.index)
 
-    def order(self, missingAtEnd=True):
+    def order(self, na_last=True, **kwds):
         """
         Sorts Series object, by value, maintaining index-value object
 
         Parameters
         ----------
-        missingAtEnd : boolean (optional, default=True)
+        na_last : boolean (optional, default=True)
             Put NaN's at beginning or end
 
-        In general, AVOID sorting Series unless you absolutely need to.
-
         Returns
         -------
         y : Series
-            sorted by values
         """
         def _try_mergesort(arr):
             # easier to ask forgiveness than permission
@@ -829,6 +819,9 @@ class Series(np.ndarray, PandasGeneric):
                 # stable sort not available for object dtype
                 return arr.argsort()
 
+        if 'missingAtEnd' in kwds:
+            na_last = kwds['missingAtEnd']
+
         arr = self.values
         sortedIdx = np.empty(len(self), dtype=np.int32)
 
@@ -836,7 +829,7 @@ class Series(np.ndarray, PandasGeneric):
 
         good = -bad
         idx = np.arange(len(self))
-        if missingAtEnd:
+        if na_last:
             n = sum(good)
             sortedIdx[:n] = idx[good][_try_mergesort(arr[good])]
             sortedIdx[n:] = idx[bad]
@@ -941,6 +934,21 @@ class Series(np.ndarray, PandasGeneric):
 
         return Series(new_values, index=index)
 
+    def select(self, crit):
+        """
+        Return data corresponding to index values matching criteria
+
+        Parameters
+        ----------
+        crit : function
+            To be called on each index (label). Should return True or False
+
+        Returns
+        -------
+        selection : Series
+        """
+        return self._select_generic(crit, axis=0)
+
     def reindex_like(self, other, method=None):
         """
         Reindex Series to match index of another Series
@@ -1105,21 +1113,27 @@ class Series(np.ndarray, PandasGeneric):
         """
         return remove_na(self)
 
-    def _firstTimeWithValue(self):
-        noNA = remove_na(self)
+    def first_valid_index(self):
+        if len(self) == 0:
+            return None
 
-        if len(noNA) > 0:
-            return noNA.index[0]
-        else:
+        mask = isnull(self.values)
+        i = mask.argmin()
+        if mask[i]:
             return None
+        else:
+            return self.index[i]
 
-    def _lastTimeWithValue(self):
-        noNA = remove_na(self)
+    def last_valid_index(self):
+        if len(self) == 0:
+            return None
 
-        if len(noNA) > 0:
-            return noNA.index[-1]
-        else:
+        mask = isnull(self.values[::-1])
+        i = mask.argmin()
+        if mask[i]:
             return None
+        else:
+            return self.index[len(self) - i - 1]
 
 #-------------------------------------------------------------------------------
 # Time series-oriented methods
@@ -1317,20 +1331,25 @@ class Series(np.ndarray, PandasGeneric):
         return Series([d.weekday() for d in self.index],
                       index=self.index)
 
-    def select(self, crit):
-        """
-        Return data corresponding to index values matching criteria
+    #----------------------------------------------------------------------
+    # Deprecated stuff
 
-        Parameters
-        ----------
-        crit : function
-            To be called on each index (label). Should return True or False
+    @classmethod
+    def fromValue(cls, value=np.NaN, index=None, dtype=None): # pragma: no cover
+        warnings.warn("'fromValue', can call Series(value, index=index) now",
+                      FutureWarning)
 
-        Returns
-        -------
-        selection : Series
-        """
-        return self._select_generic(crit, axis=0)
+        return Series(value, index=index, dtype=dtype)
+
+    def _firstTimeWithValue(self): # pragma: no cover
+        warnings.warn("_firstTimeWithValue is deprecated. Use "
+                      "first_valid_index instead", FutureWarning)
+        return self.first_valid_index()
+
+    def _lastTimeWithValue(self): # pragma: no cover
+        warnings.warn("_firstTimeWithValue is deprecated. Use "
+                      "last_valid_index instead", FutureWarning)
+        return self.last_valid_index()
 
     _ix = None
     @property
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index 152663f11..7b56218bb 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -760,18 +760,18 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         # what to do?
         assert_frame_equal(-self.frame, -1 * self.frame)
 
-    def test_firstLastValid(self):
+    def test_first_last_valid(self):
         N = len(self.frame.index)
         mat = randn(N)
         mat[:5] = np.NaN
         mat[-5:] = np.NaN
 
         frame = self.klass({'foo' : mat}, index=self.frame.index)
-        index = frame._firstTimeWithValue()
+        index = frame.first_valid_index()
 
         self.assert_(index == frame.index[5])
 
-        index = frame._lastTimeWithValue()
+        index = frame.last_valid_index()
         self.assert_(index == frame.index[-6])
 
     def test_arith_flex_frame(self):
@@ -2088,6 +2088,12 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         self.assert_(recons is not consolidated)
         assert_frame_equal(recons, consolidated)
 
+    def test_as_matrix_consolidate(self):
+        self.frame['E'] = 7.
+        self.assert_(not self.frame._data.is_consolidated())
+        _ = self.frame.as_matrix()
+        self.assert_(self.frame._data.is_consolidated())
+
     def test_modify_values(self):
         self.frame.values[5] = 5
         self.assert_((self.frame.values[5] == 5).all())
@@ -2106,6 +2112,10 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         self.frame[self.frame > 1] = 2
         assert_almost_equal(expected, self.frame.values)
 
+    def test_boolean_set_mixed_type(self):
+        bools = self.mixed_frame.applymap(lambda x: x != 2).astype(bool)
+        self.assertRaises(Exception, self.mixed_frame.__setitem__, bools, 2)
+
     def test_xs_view(self):
         dm = DataFrame(np.arange(20.).reshape(4, 5),
                        index=range(4), columns=range(5))
diff --git a/pandas/core/tests/test_internals.py b/pandas/core/tests/test_internals.py
index 05124c6ce..5a42cf159 100644
--- a/pandas/core/tests/test_internals.py
+++ b/pandas/core/tests/test_internals.py
@@ -174,6 +174,13 @@ class TestBlockManager(unittest.TestCase):
         self.assertEquals(self.mgr.nblocks, len(self.mgr.blocks))
         self.assertEquals(len(self.mgr), len(self.mgr.index))
 
+    def test_is_mixed_dtype(self):
+        self.assert_(self.mgr.is_mixed_dtype())
+
+        blocks = [get_bool_ex(['a']), get_bool_ex(['b'])]
+        mgr = BlockManager.from_blocks(blocks, np.arange(N))
+        self.assert_(not mgr.is_mixed_dtype())
+
     def test_block_id_vector(self):
         expected = [0, 1, 0, 1, 0, 2, 3]
         result = self.mgr.block_id_vector
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
index 2feebe4e4..90ae0fb44 100644
--- a/pandas/core/tests/test_series.py
+++ b/pandas/core/tests/test_series.py
@@ -559,10 +559,13 @@ class TestSeries(unittest.TestCase):
         self.assert_(np.isnan(result[-5:]).all())
         self.assert_(np.array_equal(result[:-5], np.sort(vals[5:])))
 
-        result = ts.order(missingAtEnd=False)
+        result = ts.order(na_last=False)
         self.assert_(np.isnan(result[:5]).all())
         self.assert_(np.array_equal(result[5:], np.sort(vals[5:])))
 
+        # just want to make sure it works
+        result = ts.order(missingAtEnd=False)
+
         # something object-type
         ser = Series(['A', 'B'], [1, 2])
         # no failure
@@ -910,23 +913,24 @@ class TestSeries(unittest.TestCase):
         # Just run the function
         self.ts.autocorr()
 
-    def test_firstValid(self):
+    def test_first_last_valid(self):
         ts = self.ts.copy()
         ts[:5] = np.NaN
 
-        index = ts._firstTimeWithValue()
+        index = ts.first_valid_index()
         self.assertEqual(index, ts.index[5])
 
         ts[-5:] = np.NaN
-        index = ts._lastTimeWithValue()
+        index = ts.last_valid_index()
         self.assertEqual(index, ts.index[-6])
 
-        ser = Series([], index=[])
-        self.assert_(ser._lastTimeWithValue() is None)
-        self.assert_(ser._firstTimeWithValue() is None)
+        ts[:] = np.nan
+        self.assert_(ts.last_valid_index() is None)
+        self.assert_(ts.first_valid_index() is None)
 
-    def test_lastValid(self):
-        pass
+        ser = Series([], index=[])
+        self.assert_(ser.last_valid_index() is None)
+        self.assert_(ser.first_valid_index() is None)
 
 #-------------------------------------------------------------------------------
 # GroupBy
diff --git a/refactor_notes.txt b/refactor_notes.txt
index 20b9d9620..43c362e31 100644
--- a/refactor_notes.txt
+++ b/refactor_notes.txt
@@ -1,29 +1,30 @@
-
-- Do blocks care about dtype?
-  - No, I guess
-- C-contiguousness
-  - Get C-contiguousness right this time!
-- Series homogenization
+- NOT DOING ANYTHING C-contiguousness
+  - Get C-contiguousness right this time?
+- OK Series homogenization
   - when does casting fail?
-- Deal with emptiness: empty index and / or columns
-- Transpose: float casted to string??
-- Casting, want to continue to support?
-- Column ordering during consolidation
-- Different index passed with BlockManager
-- Set values attribute? Way to hack it? Should I?
+- OK Deal with emptiness: empty index and / or columns
+- OK Transpose: float casted to string??
+- YES Casting, want to continue to support?
+- OK Column ordering during consolidation
+- OK Different index passed with BlockManager
+- NO Set values attribute? Way to hack it? Should I?
 
-- Need sparse internal data structure
+- TODO Need sparse internal data structure
 
-Insertion at location...ugh
+NO SUPPORT YET Insertion at location...ugh
 - Currently not supported?
 
-- Empty columns as result of reindex?
+- YES Empty columns as result of reindex?
   - Empty columns -> floats
 
 When do consolidations happen?
 ------------------------------
-- Before reindex
-- Before column deletion?
+- YES Before reindex
+- NO Before column deletion?
+- NO Before / after column insertion
+- YES Before joining
+- YES Before xs
+- YES Before as_matrix
 
 TODO
 ----

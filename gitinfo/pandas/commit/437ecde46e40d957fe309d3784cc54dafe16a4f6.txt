commit 437ecde46e40d957fe309d3784cc54dafe16a4f6
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Jul 3 18:04:42 2011 -0400

    removed core/setup.py and test coverage for internals

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index c2633e2f3..380da4b22 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -180,7 +180,7 @@ class DataFrame(PandasGeneric):
         blocks, columns = form_blocks(homogenized, index, columns)
 
         # consolidate for now
-        mgr = BlockManager(blocks, [columns, index], ndim=2)
+        mgr = BlockManager(blocks, [columns, index])
         return mgr.consolidate()
 
     def _init_matrix(self, values, index, columns, dtype=None,
@@ -203,7 +203,7 @@ class DataFrame(PandasGeneric):
 
         columns = _ensure_index(columns)
         block = make_block(values.T, columns, columns)
-        return BlockManager([block], [columns, index], ndim=2)
+        return BlockManager([block], [columns, index])
 
     def astype(self, dtype):
         """
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 46ec9224a..d2760c979 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -17,8 +17,6 @@ class Block(object):
     Index-ignorant; let the container take care of that
     """
     def __init__(self, values, items, ref_items, ndim=2):
-        # values = _convert_if_1d(values)
-
         if issubclass(values.dtype.type, basestring):
             values = np.array(values, dtype=object)
 
@@ -161,12 +159,6 @@ def _cast_if_bool_int(values):
         values = values.astype(object)
     return values
 
-def _convert_if_1d(values):
-    if values.ndim == 1:
-        values = np.atleast_2d(values)
-
-    return values
-
 #-------------------------------------------------------------------------------
 # Is this even possible?
 
@@ -224,17 +216,13 @@ class BlockManager(object):
     -----
     This is *not* a public API class
     """
-    def __init__(self, blocks, axes, skip_integrity_check=False, ndim=None):
+    def __init__(self, blocks, axes, skip_integrity_check=False):
         self.axes = [_ensure_index(ax) for ax in axes]
         self.blocks = blocks
 
-        if ndim is None and len(blocks) == 0:
-            raise ValueError('must specify dimension if no input blocks')
-        elif ndim is None:
-            ndim = blocks[0].ndim
-        else:
-            for block in blocks:
-                assert(ndim == block.values.ndim)
+        ndim = len(axes)
+        for block in blocks:
+            assert(ndim == block.values.ndim)
 
         self.ndim = ndim
 
@@ -325,7 +313,7 @@ class BlockManager(object):
                               block.ref_items)
             new_blocks.append(newb)
 
-        new_mgr = BlockManager(new_blocks, self.axes, ndim=self.ndim)
+        new_mgr = BlockManager(new_blocks, self.axes)
         return new_mgr.consolidate()
 
     def is_consolidated(self):
@@ -340,7 +328,7 @@ class BlockManager(object):
 
         new_axes = list(self.axes)
         new_axes[axis] = new_axes[axis][slice_obj]
-        return BlockManager(new_blocks, new_axes, ndim=self.ndim)
+        return BlockManager(new_blocks, new_axes)
 
     def _slice_blocks(self, slice_obj, axis):
         new_blocks = []
@@ -364,7 +352,7 @@ class BlockManager(object):
         # also checks for overlap
         items = _union_block_items(blocks)
         ndim = blocks[0].ndim
-        return BlockManager(blocks, [items, index], ndim=ndim)
+        return BlockManager(blocks, [items, index])
 
     def __contains__(self, item):
         return item in self.items
@@ -375,7 +363,7 @@ class BlockManager(object):
 
     def copy(self):
         copy_blocks = [block.copy() for block in self.blocks]
-        return BlockManager(copy_blocks, self.axes, ndim=self.ndim)
+        return BlockManager(copy_blocks, self.axes)
 
     def as_matrix(self, items=None):
         if len(self.blocks) == 0:
@@ -530,7 +518,7 @@ class BlockManager(object):
 
         new_axes = list(self.axes)
         new_axes[axis] = new_axis
-        return BlockManager(new_blocks, new_axes, ndim=self.ndim)
+        return BlockManager(new_blocks, new_axes)
 
     def reindex_items(self, new_items):
         """
@@ -566,7 +554,7 @@ class BlockManager(object):
         new_axes = list(self.axes)
         new_axes[0] = new_items
 
-        return BlockManager(new_blocks, new_axes, ndim=self.ndim)
+        return BlockManager(new_blocks, new_axes)
 
     def merge(self, other):
         assert(self._is_indexed_like(other))
@@ -677,8 +665,6 @@ def form_blocks(data, index, items):
 
     blocks = []
 
-    ndim = 2
-
     if len(num_dict) > 0:
         num_dtypes = set(v.dtype for v in num_dict.values())
         if len(num_dtypes) > 1:
@@ -688,15 +674,15 @@ def form_blocks(data, index, items):
 
         # TODO: find corner cases
         # TODO: check type inference
-        num_block = _simple_blockify(num_dict, items, num_dtype, ndim)
+        num_block = _simple_blockify(num_dict, items, num_dtype)
         blocks.append(num_block)
 
     if len(bool_dict):
-        bool_block = _simple_blockify(bool_dict, items, np.bool_, ndim)
+        bool_block = _simple_blockify(bool_dict, items, np.bool_)
         blocks.append(bool_block)
 
     if len(object_dict) > 0:
-        object_block = _simple_blockify(object_dict, items, np.object_, ndim)
+        object_block = _simple_blockify(object_dict, items, np.object_)
         blocks.append(object_block)
 
     if len(extra_items):
@@ -709,10 +695,10 @@ def form_blocks(data, index, items):
 
     return blocks, items
 
-def _simple_blockify(dct, ref_items, dtype, ndim):
+def _simple_blockify(dct, ref_items, dtype):
     block_items, values = _stack_dict(dct)
     # CHECK DTYPE?
-    if values.dtype != dtype:
+    if values.dtype != dtype: # pragma: no cover
         values = values.astype(dtype)
 
     return make_block(values, block_items, ref_items)
@@ -732,26 +718,6 @@ def _blocks_to_series_dict(blocks, index=None):
             series_dict[item] = Series(vec, index=index)
     return series_dict
 
-def _interleave(blocks, items):
-    """
-    Return ndarray from blocks with specified item order
-    Items must be contained in the blocks
-    """
-    dtype = _interleaved_dtype(blocks)
-    items = _ensure_index(items)
-
-    result = np.empty((len(blocks[0]), len(items)), dtype=dtype)
-    itemmask = np.zeros(len(items), dtype=bool)
-
-    # By construction, all of the item should be covered by one of the blocks
-    for block in blocks:
-        indexer, mask = items.get_indexer(block.items)
-        assert(mask.all())
-        result[:, indexer] = block.values
-        itemmask[indexer] = 1
-    assert(itemmask.all())
-    return result
-
 def _interleaved_dtype(blocks):
     have_int = False
     have_bool = False
diff --git a/pandas/core/setup.py b/pandas/core/setup.py
deleted file mode 100644
index ecb8da63e..000000000
--- a/pandas/core/setup.py
+++ /dev/null
@@ -1,11 +0,0 @@
-#!/usr/bin/env python
-
-def configuration(parent_package='',top_path=None):
-    from numpy.distutils.misc_util import Configuration
-    config = Configuration('core', parent_package, top_path)
-    config.add_data_dir('tests')
-    return config
-
-if __name__ == '__main__':
-    print('This is the wrong setup.py file to run')
-
diff --git a/pandas/tests/test_internals.py b/pandas/tests/test_internals.py
index f2d3bd7fb..c6479b420 100644
--- a/pandas/tests/test_internals.py
+++ b/pandas/tests/test_internals.py
@@ -67,6 +67,7 @@ class TestBlock(unittest.TestCase):
     def test_attrs(self):
         self.assert_(self.fblock.shape == self.fblock.values.shape)
         self.assert_(self.fblock.dtype == self.fblock.values.dtype)
+        self.assert_(len(self.fblock) == len(self.fblock.values))
 
     def test_merge(self):
         avals = randn(2, 10)
@@ -170,6 +171,9 @@ class TestBlockManager(unittest.TestCase):
                        get_int_ex()]
         self.mgr = BlockManager.from_blocks(self.blocks, np.arange(N))
 
+    def test_constructor_corner(self):
+        pass
+
     def test_attrs(self):
         self.assertEquals(self.mgr.nblocks, len(self.mgr.blocks))
         self.assertEquals(len(self.mgr), len(self.mgr.items))
@@ -181,6 +185,11 @@ class TestBlockManager(unittest.TestCase):
         mgr = BlockManager.from_blocks(blocks, np.arange(N))
         self.assert_(not mgr.is_mixed_dtype())
 
+    def test_is_indexed_like(self):
+        self.assert_(self.mgr._is_indexed_like(self.mgr))
+        mgr2 = self.mgr.reindex_axis(np.arange(N - 1), axis=1)
+        self.assert_(not self.mgr._is_indexed_like(mgr2))
+
     def test_block_id_vector(self):
         expected = [0, 1, 0, 1, 0, 2, 3]
         result = self.mgr.block_id_vector

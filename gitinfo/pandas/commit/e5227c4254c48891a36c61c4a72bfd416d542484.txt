commit e5227c4254c48891a36c61c4a72bfd416d542484
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Thu Jan 23 19:28:41 2020 -0800

    TYP: annotations in indexes (#31181)

diff --git a/pandas/core/base.py b/pandas/core/base.py
index 109979938..6ad237cbc 100644
--- a/pandas/core/base.py
+++ b/pandas/core/base.py
@@ -3,7 +3,7 @@ Base and utility classes for pandas objects.
 """
 import builtins
 import textwrap
-from typing import Dict, FrozenSet, List, Optional
+from typing import Dict, FrozenSet, List, Optional, Union
 
 import numpy as np
 
@@ -110,7 +110,7 @@ class NoNewAttributesMixin:
         object.__setattr__(self, "__frozen", True)
 
     # prevent adding any attribute via s.xxx.new_attribute = ...
-    def __setattr__(self, key, value):
+    def __setattr__(self, key: str, value):
         # _cache is used by a decorator
         # We need to check both 1.) cls.__dict__ and 2.) getattr(self, key)
         # because
@@ -239,7 +239,7 @@ class SelectionMixin:
                 raise KeyError(f"Column not found: {key}")
             return self._gotitem(key, ndim=1)
 
-    def _gotitem(self, key, ndim, subset=None):
+    def _gotitem(self, key, ndim: int, subset=None):
         """
         sub-classes to define
         return a sliced object
@@ -605,6 +605,11 @@ class IndexOpsMixin:
         ["tolist"]  # tolist is not deprecated, just suppressed in the __dir__
     )
 
+    @property
+    def _values(self) -> Union[ExtensionArray, np.ndarray]:
+        # must be defined here as a property for mypy
+        raise AbstractMethodError(self)
+
     def transpose(self, *args, **kwargs):
         """
         Return the transpose, which is by definition self.
@@ -630,6 +635,10 @@ class IndexOpsMixin:
         """
         return self._values.shape
 
+    def __len__(self) -> int:
+        # We need this defined here for mypy
+        raise AbstractMethodError(self)
+
     @property
     def ndim(self) -> int:
         """
@@ -664,14 +673,14 @@ class IndexOpsMixin:
             raise ValueError("can only convert an array of size 1 to a Python scalar")
 
     @property
-    def nbytes(self):
+    def nbytes(self) -> int:
         """
         Return the number of bytes in the underlying data.
         """
         return self._values.nbytes
 
     @property
-    def size(self):
+    def size(self) -> int:
         """
         Return the number of elements in the underlying data.
         """
@@ -1058,7 +1067,14 @@ class IndexOpsMixin:
         return bool(isna(self).any())
 
     def _reduce(
-        self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds
+        self,
+        op,
+        name: str,
+        axis=0,
+        skipna=True,
+        numeric_only=None,
+        filter_type=None,
+        **kwds,
     ):
         """ perform the reduction type operation if we can """
         func = getattr(self, name, None)
@@ -1254,7 +1270,7 @@ class IndexOpsMixin:
 
         return result
 
-    def nunique(self, dropna=True):
+    def nunique(self, dropna: bool = True) -> int:
         """
         Return number of unique elements in the object.
 
@@ -1295,7 +1311,7 @@ class IndexOpsMixin:
         return n
 
     @property
-    def is_unique(self):
+    def is_unique(self) -> bool:
         """
         Return boolean if values in the object are unique.
 
@@ -1306,7 +1322,7 @@ class IndexOpsMixin:
         return self.nunique(dropna=False) == len(self)
 
     @property
-    def is_monotonic(self):
+    def is_monotonic(self) -> bool:
         """
         Return boolean if values in the object are
         monotonic_increasing.
@@ -1319,7 +1335,11 @@ class IndexOpsMixin:
 
         return Index(self).is_monotonic
 
-    is_monotonic_increasing = is_monotonic
+    @property
+    def is_monotonic_increasing(self) -> bool:
+        """alias for is_monotonic"""
+        # mypy complains if we alias directly
+        return self.is_monotonic
 
     @property
     def is_monotonic_decreasing(self) -> bool:
@@ -1472,7 +1492,7 @@ class IndexOpsMixin:
 
     @Substitution(klass="Index")
     @Appender(_shared_docs["searchsorted"])
-    def searchsorted(self, value, side="left", sorter=None):
+    def searchsorted(self, value, side="left", sorter=None) -> np.ndarray:
         return algorithms.searchsorted(self._values, value, side=side, sorter=sorter)
 
     def drop_duplicates(self, keep="first", inplace=False):
diff --git a/pandas/core/common.py b/pandas/core/common.py
index f0fcb7365..c883ec9fa 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -178,35 +178,35 @@ def not_none(*args):
     return (arg for arg in args if arg is not None)
 
 
-def any_none(*args):
+def any_none(*args) -> bool:
     """
     Returns a boolean indicating if any argument is None.
     """
     return any(arg is None for arg in args)
 
 
-def all_none(*args):
+def all_none(*args) -> bool:
     """
     Returns a boolean indicating if all arguments are None.
     """
     return all(arg is None for arg in args)
 
 
-def any_not_none(*args):
+def any_not_none(*args) -> bool:
     """
     Returns a boolean indicating if any argument is not None.
     """
     return any(arg is not None for arg in args)
 
 
-def all_not_none(*args):
+def all_not_none(*args) -> bool:
     """
     Returns a boolean indicating if all arguments are not None.
     """
     return all(arg is not None for arg in args)
 
 
-def count_not_none(*args):
+def count_not_none(*args) -> int:
     """
     Returns the count of arguments that are not None.
     """
@@ -286,7 +286,7 @@ def maybe_iterable_to_list(obj: Union[Iterable[T], T]) -> Union[Collection[T], T
     return obj
 
 
-def is_null_slice(obj):
+def is_null_slice(obj) -> bool:
     """
     We have a null slice.
     """
@@ -306,7 +306,7 @@ def is_true_slices(l):
 
 
 # TODO: used only once in indexing; belongs elsewhere?
-def is_full_slice(obj, l):
+def is_full_slice(obj, l) -> bool:
     """
     We have a full length slice.
     """
diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index 1f4e5b49c..bab3d2d1b 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -51,7 +51,6 @@ from pandas.core.dtypes.generic import (
     ABCCategorical,
     ABCDataFrame,
     ABCDatetimeIndex,
-    ABCIndexClass,
     ABCIntervalIndex,
     ABCMultiIndex,
     ABCPandasArray,
@@ -511,7 +510,7 @@ class Index(IndexOpsMixin, PandasObject):
         if not len(values) and "dtype" not in kwargs:
             attributes["dtype"] = self.dtype
 
-        # _simple_new expects an the type of self._data
+        # _simple_new expects the type of self._data
         values = getattr(values, "_values", values)
 
         return self._simple_new(values, **attributes)
@@ -533,6 +532,7 @@ class Index(IndexOpsMixin, PandasObject):
         attributes.update(kwargs)
         attributes["copy"] = False
         if not len(values) and "dtype" not in kwargs:
+            # TODO: what if hasattr(values, "dtype")?
             attributes["dtype"] = self.dtype
         if self._infer_as_myclass:
             try:
@@ -860,7 +860,7 @@ class Index(IndexOpsMixin, PandasObject):
     # --------------------------------------------------------------------
     # Rendering Methods
 
-    def __repr__(self):
+    def __repr__(self) -> str_t:
         """
         Return a string representation for this object.
         """
@@ -879,7 +879,7 @@ class Index(IndexOpsMixin, PandasObject):
 
         return res
 
-    def _format_space(self):
+    def _format_space(self) -> str_t:
 
         # using space here controls if the attributes
         # are line separated or not (the default)
@@ -896,18 +896,19 @@ class Index(IndexOpsMixin, PandasObject):
         """
         return default_pprint
 
-    def _format_data(self, name=None):
+    def _format_data(self, name=None) -> str_t:
         """
         Return the formatted data as a unicode string.
         """
 
         # do we want to justify (only do so for non-objects)
-        is_justify = not (
-            self.inferred_type in ("string")
-            or (
-                self.inferred_type == "categorical" and is_object_dtype(self.categories)
-            )
-        )
+        is_justify = True
+
+        if self.inferred_type == "string":
+            is_justify = False
+        elif self.inferred_type == "categorical":
+            if is_object_dtype(self.categories):  # type: ignore
+                is_justify = False
 
         return format_object_summary(
             self, self._formatter_func, is_justify=is_justify, name=name
@@ -923,7 +924,7 @@ class Index(IndexOpsMixin, PandasObject):
         # how to represent ourselves to matplotlib
         return self.values
 
-    def format(self, name=False, formatter=None, **kwargs):
+    def format(self, name: bool = False, formatter=None, **kwargs):
         """
         Render a string representation of the Index.
         """
@@ -1009,7 +1010,7 @@ class Index(IndexOpsMixin, PandasObject):
         values[mask] = na_rep
         return values
 
-    def _summary(self, name=None):
+    def _summary(self, name=None) -> str_t:
         """
         Return a summarized representation.
 
@@ -1089,7 +1090,7 @@ class Index(IndexOpsMixin, PandasObject):
 
         return Series(self.values.copy(), index=index, name=name)
 
-    def to_frame(self, index=True, name=None):
+    def to_frame(self, index: bool = True, name=None):
         """
         Create a DataFrame with a column containing the Index.
 
@@ -1172,7 +1173,7 @@ class Index(IndexOpsMixin, PandasObject):
         maybe_extract_name(value, None, type(self))
         self._name = value
 
-    def _validate_names(self, name=None, names=None, deep=False):
+    def _validate_names(self, name=None, names=None, deep: bool = False):
         """
         Handles the quirks of having a singular 'name' parameter for general
         Index and plural 'names' parameter for MultiIndex.
@@ -1225,7 +1226,7 @@ class Index(IndexOpsMixin, PandasObject):
 
     names = property(fset=_set_names, fget=_get_names)
 
-    def set_names(self, names, level=None, inplace=False):
+    def set_names(self, names, level=None, inplace: bool = False):
         """
         Set Index or MultiIndex name.
 
@@ -1394,7 +1395,7 @@ class Index(IndexOpsMixin, PandasObject):
                 f"Requested level ({level}) does not match index name ({self.name})"
             )
 
-    def _get_level_number(self, level):
+    def _get_level_number(self, level) -> int:
         self._validate_index_level(level)
         return 0
 
@@ -1564,7 +1565,7 @@ class Index(IndexOpsMixin, PandasObject):
         return self.is_monotonic_increasing
 
     @property
-    def is_monotonic_increasing(self):
+    def is_monotonic_increasing(self) -> bool:
         """
         Return if the index is monotonic increasing (only equal or
         increasing) values.
@@ -1973,14 +1974,14 @@ class Index(IndexOpsMixin, PandasObject):
         """
         return self.inferred_type in ["mixed"]
 
-    def holds_integer(self):
+    def holds_integer(self) -> bool:
         """
         Whether the type is an integer type.
         """
         return self.inferred_type in ["integer", "mixed-integer"]
 
     @cache_readonly
-    def inferred_type(self):
+    def inferred_type(self) -> str_t:
         """
         Return a string of the type inferred from the values.
         """
@@ -2028,7 +2029,7 @@ class Index(IndexOpsMixin, PandasObject):
             return np.array([], dtype=np.int64)
 
     @cache_readonly
-    def hasnans(self):
+    def hasnans(self) -> bool:
         """
         Return if I have any nans; enables various perf speedups.
         """
@@ -2333,13 +2334,13 @@ class Index(IndexOpsMixin, PandasObject):
         """
         return super().duplicated(keep=keep)
 
-    def _get_unique_index(self, dropna=False):
+    def _get_unique_index(self, dropna: bool = False):
         """
         Returns an index containing unique values.
 
         Parameters
         ----------
-        dropna : bool
+        dropna : bool, default False
             If True, NaN values are dropped.
 
         Returns
@@ -2446,7 +2447,7 @@ class Index(IndexOpsMixin, PandasObject):
         other = Index(other).astype(object, copy=False)
         return Index.union(this, other, sort=sort).astype(object, copy=False)
 
-    def _is_compatible_with_other(self, other):
+    def _is_compatible_with_other(self, other) -> bool:
         """
         Check whether this and the other dtype are compatible with each other.
         Meaning a union can be formed between them without needing to be cast
@@ -3296,7 +3297,7 @@ class Index(IndexOpsMixin, PandasObject):
         ----------
         keyarr : Index (or sub-class)
             Indexer to convert.
-        kind : iloc, ix, loc, optional
+        kind : iloc, loc, optional
 
         Returns
         -------
@@ -3309,7 +3310,6 @@ class Index(IndexOpsMixin, PandasObject):
             kind in [None, "iloc"]
             and is_integer_dtype(keyarr)
             and not self.is_floating()
-            and not isinstance(keyarr, ABCPeriodIndex)
         ):
 
             if self.inferred_type == "mixed-integer":
@@ -3902,7 +3902,7 @@ class Index(IndexOpsMixin, PandasObject):
     # Uncategorized Methods
 
     @property
-    def values(self):
+    def values(self) -> np.ndarray:
         """
         Return an array representing the data in the Index.
 
@@ -3934,7 +3934,7 @@ class Index(IndexOpsMixin, PandasObject):
         return array
 
     @property
-    def _values(self) -> Union[ExtensionArray, ABCIndexClass, np.ndarray]:
+    def _values(self) -> Union[ExtensionArray, np.ndarray]:
         """
         The best array representation.
 
@@ -3964,7 +3964,7 @@ class Index(IndexOpsMixin, PandasObject):
         """
         return self._data
 
-    def _internal_get_values(self):
+    def _internal_get_values(self) -> np.ndarray:
         """
         Return `Index` data as an `numpy.ndarray`.
 
@@ -4009,7 +4009,7 @@ class Index(IndexOpsMixin, PandasObject):
         return self.values
 
     @Appender(IndexOpsMixin.memory_usage.__doc__)
-    def memory_usage(self, deep=False):
+    def memory_usage(self, deep: bool = False) -> int:
         result = super().memory_usage(deep=deep)
 
         # include our engine hashtable
@@ -4458,7 +4458,7 @@ class Index(IndexOpsMixin, PandasObject):
 
         return result
 
-    def sort_values(self, return_indexer=False, ascending=True):
+    def sort_values(self, return_indexer: bool = False, ascending: bool = True):
         """
         Return a sorted copy of the index.
 
@@ -4981,7 +4981,7 @@ class Index(IndexOpsMixin, PandasObject):
                 pass
         return key
 
-    def _validate_indexer(self, form, key, kind):
+    def _validate_indexer(self, form, key, kind: str_t):
         """
         If we are positional indexer, validate that we have appropriate
         typed bounds must be an integer.
diff --git a/pandas/core/indexes/datetimelike.py b/pandas/core/indexes/datetimelike.py
index e50d752f9..b87dd0f02 100644
--- a/pandas/core/indexes/datetimelike.py
+++ b/pandas/core/indexes/datetimelike.py
@@ -610,8 +610,6 @@ class DatetimeTimedeltaMixin(DatetimeIndexOpsMixin, Int64Index):
     def _shallow_copy(self, values=None, **kwargs):
         if values is None:
             values = self._data
-        if isinstance(values, type(self)):
-            values = values._data
 
         attributes = self._get_attributes_dict()
 
diff --git a/pandas/core/indexes/numeric.py b/pandas/core/indexes/numeric.py
index 14cb061aa..aece294ed 100644
--- a/pandas/core/indexes/numeric.py
+++ b/pandas/core/indexes/numeric.py
@@ -288,9 +288,9 @@ class Int64Index(IntegerIndex):
             if not np.array_equal(data, subarr):
                 raise TypeError("Unsafe NumPy casting, you must explicitly cast")
 
-    def _is_compatible_with_other(self, other):
+    def _is_compatible_with_other(self, other) -> bool:
         return super()._is_compatible_with_other(other) or all(
-            isinstance(type(obj), (ABCInt64Index, ABCFloat64Index, ABCRangeIndex))
+            isinstance(obj, (ABCInt64Index, ABCFloat64Index, ABCRangeIndex))
             for obj in [self, other]
         )
 
@@ -345,10 +345,9 @@ class UInt64Index(IntegerIndex):
             if not np.array_equal(data, subarr):
                 raise TypeError("Unsafe NumPy casting, you must explicitly cast")
 
-    def _is_compatible_with_other(self, other):
+    def _is_compatible_with_other(self, other) -> bool:
         return super()._is_compatible_with_other(other) or all(
-            isinstance(type(obj), (ABCUInt64Index, ABCFloat64Index))
-            for obj in [self, other]
+            isinstance(obj, (ABCUInt64Index, ABCFloat64Index)) for obj in [self, other]
         )
 
 
@@ -399,10 +398,7 @@ class Float64Index(NumericIndex):
         return key
 
     @Appender(_index_shared_docs["_convert_slice_indexer"])
-    def _convert_slice_indexer(self, key, kind=None):
-        # if we are not a slice, then we are done
-        if not isinstance(key, slice):
-            return key
+    def _convert_slice_indexer(self, key: slice, kind=None):
 
         if kind == "iloc":
             return super()._convert_slice_indexer(key, kind=kind)
@@ -490,11 +486,10 @@ class Float64Index(NumericIndex):
             self._validate_index_level(level)
         return algorithms.isin(np.array(self), values)
 
-    def _is_compatible_with_other(self, other):
+    def _is_compatible_with_other(self, other) -> bool:
         return super()._is_compatible_with_other(other) or all(
             isinstance(
-                type(obj),
-                (ABCInt64Index, ABCFloat64Index, ABCUInt64Index, ABCRangeIndex),
+                obj, (ABCInt64Index, ABCFloat64Index, ABCUInt64Index, ABCRangeIndex),
             )
             for obj in [self, other]
         )

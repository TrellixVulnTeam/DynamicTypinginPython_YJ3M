commit b8692f7c612f1e0b9df6cf8fe03c92392f10c82d
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Jul 17 12:35:32 2011 -0400

    REF: removed pytools and test_pytools
    FIX: {Series, DataFrame}.truncate copy as before internals redesign

diff --git a/RELEASE.rst b/RELEASE.rst
index 104c1ddc0..b4a78cf35 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -149,6 +149,8 @@ Release notes
 * Removed `parseText`, `parseCSV` and `parseExcel` from pandas namespace
 * `Series.combineFunc` renamed to `Series.combine` and made a bit more general
   with a `fill_value` keyword argument defaulting to NaN
+* Removed `pandas.core.pytools` module. Code has been moved to
+  `pandas.core.common`
 
 **Bug fixes**
 
diff --git a/pandas/core/common.py b/pandas/core/common.py
index c734d950e..4288d6c24 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -3,6 +3,7 @@ Misc tools for implementing data structures
 """
 
 from cStringIO import StringIO
+import itertools
 
 from numpy.lib.format import read_array, write_array
 import numpy as np
@@ -210,3 +211,105 @@ def _format(s, nanRep=None, float_format=None):
     else:
         return ' %s' % s
 
+#-------------------------------------------------------------------------------
+# miscellaneous python tools
+
+def rands(n):
+    """Generates a random alphanumeric string of length *n*"""
+    from random import Random
+    import string
+    return ''.join(Random().sample(string.letters+string.digits, n))
+
+def adjoin(space, *lists):
+    """
+    Glues together two sets of strings using the amount of space requested.
+    The idea is to prettify.
+    """
+    outLines = []
+    newLists = []
+    lengths = [max(map(len, x)) + space for x in lists[:-1]]
+
+    # not the last one
+    lengths.append(max(map(len, lists[-1])))
+
+    maxLen = max(map(len, lists))
+    for i, lst in enumerate(lists):
+        nl = [x.ljust(lengths[i]) for x in lst]
+        nl.extend([' ' * lengths[i]] * (maxLen - len(lst)))
+        newLists.append(nl)
+    toJoin = zip(*newLists)
+    for lines in toJoin:
+        outLines.append(''.join(lines))
+    return '\n'.join(outLines)
+
+def iterpairs(seq):
+    """
+    Parameters
+    ----------
+    seq: sequence
+
+    Returns
+    -------
+    iterator returning overlapping pairs of elements
+
+    Example
+    -------
+    >>> iterpairs([1, 2, 3, 4])
+    [(1, 2), (2, 3), (3, 4)
+    """
+    # input may not be sliceable
+    seq_it = iter(seq)
+    seq_it_next = iter(seq)
+    _ = seq_it_next.next()
+
+    return itertools.izip(seq_it, seq_it_next)
+
+def indent(string, spaces=4):
+    dent = ' ' * spaces
+    return '\n'.join([dent + x for x in string.split('\n')])
+
+def banner(message):
+    """
+    Return 80-char width message declaration with = bars on top and bottom.
+    """
+    bar = '=' * 80
+    return '%s\n%s\n%s' % (bar, message, bar)
+
+class groupby(dict):
+    """
+    A simple groupby different from the one in itertools.
+
+    Does not require the sequence elements to be sorted by keys,
+    however it is slower.
+    """
+    def __init__(self, seq, key=lambda x:x):
+        for value in seq:
+            k = key(value)
+            self.setdefault(k, []).append(value)
+    __iter__ = dict.iteritems
+
+def map_indices_py(arr):
+    """
+    Returns a dictionary with (element, index) pairs for each element in the
+    given array/list
+    """
+    return dict([(x, i) for i, x in enumerate(arr)])
+
+def union(*seqs):
+    result = set([])
+    for seq in seqs:
+        if not isinstance(seq, set):
+            seq = set(seq)
+        result |= seq
+    return type(seqs[0])(list(result))
+
+def difference(a, b):
+    return type(a)(list(set(a) - set(b)))
+
+def intersection(*seqs):
+    result = set(seqs[0])
+    for seq in seqs:
+        if not isinstance(seq, set):
+            seq = set(seq)
+        result &= seq
+    return type(seqs[0])(list(result))
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 58aa1c8a5..012034ca1 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -470,8 +470,7 @@ class DataFrame(PandasGeneric):
 
     def toString(self, buf=sys.stdout, columns=None, colSpace=None,
                  nanRep='NaN', formatters=None, float_format=None):
-        from pandas.core.pytools import adjoin
-        from pandas.core.common import _format
+        from pandas.core.common import _format, adjoin
 
         if colSpace is None:
             def _myformat(v):
@@ -1494,25 +1493,6 @@ class DataFrame(PandasGeneric):
 
         return indexer
 
-    def truncate(self, before=None, after=None):
-        """Function truncate a sorted DataFrame before and/or after
-        some particular dates.
-
-        Parameters
-        ----------
-        before : date
-            Truncate before date
-        after : date
-            Truncate after date
-
-        Returns
-        -------
-        DataFrame
-        """
-        before = datetools.to_datetime(before)
-        after = datetools.to_datetime(after)
-        return self.ix[before:after]
-
     #----------------------------------------------------------------------
     # Function application
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 9f964d7ec..d8501acef 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -1,6 +1,8 @@
 import numpy as np
 import cPickle
 
+import pandas.core.datetools as datetools
+
 #-------------------------------------------------------------------------------
 # Picklable mixin
 
@@ -166,3 +168,23 @@ class PandasGeneric(Picklable):
             new_data = self._data.reindex_axis(new_index, axis=axis,
                                                method=fill_method)
         return type(self)(new_data)
+
+    def truncate(self, before=None, after=None):
+        """Function truncate a sorted DataFrame / Series before and/or after
+        some particular dates.
+
+        Parameters
+        ----------
+        before : date
+            Truncate before date
+        after : date
+            Truncate after date
+
+        Returns
+        -------
+        truncated : type of caller
+        """
+        before = datetools.to_datetime(before)
+        after = datetools.to_datetime(after)
+        # returns view, want to copy
+        return self.ix[before:after].copy()
diff --git a/pandas/core/pytools.py b/pandas/core/pytools.py
deleted file mode 100644
index e04c1eddb..000000000
--- a/pandas/core/pytools.py
+++ /dev/null
@@ -1,110 +0,0 @@
-"""A collection of tools for various purely Python operations"""
-from random import Random
-import itertools
-import string
-
-# In theory should be few to no imports outside perhaps stdlib here
-
-def rands(n):
-    """Generates a random alphanumeric string of length *n*"""
-    return ''.join(Random().sample(string.letters+string.digits, n))
-
-def adjoin(space, *lists):
-    """
-    Glues together two sets of strings using the amount of space requested.
-    The idea is to prettify.
-    """
-    outLines = []
-    newLists = []
-    lengths = [max(map(len, x)) + space for x in lists[:-1]]
-
-    # not the last one
-    lengths.append(max(map(len, lists[-1])))
-
-    maxLen = max(map(len, lists))
-    for i, lst in enumerate(lists):
-        nl = [x.ljust(lengths[i]) for x in lst]
-        nl.extend([' ' * lengths[i]] * (maxLen - len(lst)))
-        newLists.append(nl)
-    toJoin = zip(*newLists)
-    for lines in toJoin:
-        outLines.append(''.join(lines))
-    return '\n'.join(outLines)
-
-
-def iterpairs(seq):
-    """
-    Parameters
-    ----------
-    seq: sequence
-
-    Returns
-    -------
-    iterator returning overlapping pairs of elements
-
-    Example
-    -------
-    >>> iterpairs([1, 2, 3, 4])
-    [(1, 2), (2, 3), (3, 4)
-    """
-    # input may not be sliceable
-    seq_it = iter(seq)
-    seq_it_next = iter(seq)
-    _ = seq_it_next.next()
-
-    return itertools.izip(seq_it, seq_it_next)
-
-def indent(string, spaces=4):
-    dent = ' ' * spaces
-    return '\n'.join([dent + x for x in string.split('\n')])
-
-def banner(message):
-    """
-    Return 80-char width message declaration with = bars on top and bottom.
-    """
-    bar = '=' * 80
-    return '%s\n%s\n%s' % (bar, message, bar)
-
-class groupby(dict):
-    """
-    A simple groupby different from the one in itertools.
-
-    Does not require the sequence elements to be sorted by keys,
-    however it is slower.
-    """
-    def __init__(self, seq, key=lambda x:x):
-        for value in seq:
-            k = key(value)
-            self.setdefault(k, []).append(value)
-    __iter__ = dict.iteritems
-
-
-def map_indices_py(arr):
-    """
-    Returns a dictionary with (element, index) pairs for each element in the
-    given array/list
-    """
-    return dict([(x, i) for i, x in enumerate(arr)])
-
-#===============================================================================
-# Set operations
-#===============================================================================
-
-def union(*seqs):
-    result = set([])
-    for seq in seqs:
-        if not isinstance(seq, set):
-            seq = set(seq)
-        result |= seq
-    return type(seqs[0])(list(result))
-
-def difference(a, b):
-    return type(a)(list(set(a) - set(b)))
-
-def intersection(*seqs):
-    result = set(seqs[0])
-    for seq in seqs:
-        if not isinstance(seq, set):
-            seq = set(seq)
-        result &= seq
-    return type(seqs[0])(list(result))
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 0f32730c3..f7d5dfdd9 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1255,30 +1255,6 @@ class Series(np.ndarray, PandasGeneric):
         else:
             return Series(self, index=self.index.shift(periods, offset))
 
-    def truncate(self, before=None, after=None):
-        """Function truncate a sorted TimeSeries before and/or after
-        some particular dates.
-
-        Parameters
-        ----------
-        before : date
-            Truncate before date
-        after : date
-            Truncate after date
-
-        Notes
-        -----
-        If TimeSeries is contained in a DataFrame, consider using the version
-        of the function there.
-
-        Returns
-        -------
-        TimeSeries
-        """
-        before = datetools.to_datetime(before)
-        after = datetools.to_datetime(after)
-        return self.ix[before:after]
-
     def asOf(self, date):
         """
         Return last good (non-NaN) value in TimeSeries if value is NaN for
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index b709ffcc1..1df66714a 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -11,7 +11,7 @@ import time
 import numpy as np
 from pandas import (Series, TimeSeries, DataFrame, DataMatrix, WidePanel,
                     LongPanel)
-from pandas.core.pytools import adjoin
+from pandas.core.common import adjoin
 import pandas.core.internals as internals
 import pandas._tseries as _tseries
 
diff --git a/pandas/tests/test_common.py b/pandas/tests/test_common.py
index 381857b00..82f0dad64 100644
--- a/pandas/tests/test_common.py
+++ b/pandas/tests/test_common.py
@@ -26,6 +26,72 @@ def test_all_not_none():
     assert(not common._all_not_none(1, 2, 3, None))
     assert(not common._all_not_none(None, None, None, None))
 
+def test_rands():
+    r = common.rands(10)
+    assert(len(r) == 10)
+
+def test_adjoin():
+    data = [['a', 'b', 'c'],
+            ['dd', 'ee', 'ff'],
+            ['ggg', 'hhh', 'iii']]
+    expected = 'a  dd  ggg\nb  ee  hhh\nc  ff  iii'
+
+    adjoined = common.adjoin(2, *data)
+
+    assert(adjoined == expected)
+
+def test_iterpairs():
+    data = [1, 2, 3, 4]
+    expected = [(1, 2),
+                (2, 3),
+                (3, 4)]
+
+    result = list(common.iterpairs(data))
+
+    assert(result == expected)
+
+def test_indent():
+    s = 'a b c\nd e f'
+    result = common.indent(s, spaces=6)
+
+    assert(result == '      a b c\n      d e f')
+
+def test_banner():
+    ban = common.banner('hi')
+    assert(ban == ('%s\nhi\n%s' % ('=' * 80, '=' * 80)))
+
+def test_map_indices_py():
+    data = [4, 3, 2, 1]
+    expected = {4 : 0, 3 : 1, 2 : 2, 1 : 3}
+
+    result = common.map_indices_py(data)
+
+    assert(result == expected)
+
+def test_union():
+    a = [1, 2, 3]
+    b = [4, 5, 6]
+
+    union = sorted(common.union(a, b))
+
+    assert((a + b) == union)
+
+def test_difference():
+    a = [1, 2, 3]
+    b = [1, 2, 3, 4, 5, 6]
+
+    inter = sorted(common.difference(b, a))
+
+    assert([4, 5, 6] == inter)
+
+def test_intersection():
+    a = [1, 2, 3]
+    b = [1, 2, 3, 4, 5, 6]
+
+    inter = sorted(common.intersection(a, b))
+
+    assert(a == inter)
+
 if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 811c4a1bb..54a5be5fb 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -1450,6 +1450,12 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         truncated = ts.truncate(after=end_missing)
         assert_frame_equal(truncated, expected)
 
+    def test_truncate_copy(self):
+        index = self.tsframe.index
+        truncated = self.tsframe.truncate(index[5], index[10])
+        truncated.values[:] = 5.
+        self.assert_(not (self.tsframe.values[5:11] == 5).any())
+
     def test_xs(self):
         idx = self.frame.index[5]
         xs = self.frame.xs(idx)
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index 66b7ec814..6c8ebb335 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -2,7 +2,7 @@ import unittest
 
 from pandas.core.daterange import DateRange
 from pandas.core.index import Index
-from pandas.core.pytools import rands, groupby
+from pandas.core.common import rands, groupby
 from pandas.core.frame import DataFrame
 from pandas.core.series import Series
 import pandas.core.datetools as dt
diff --git a/pandas/tests/test_pytools.py b/pandas/tests/test_pytools.py
deleted file mode 100644
index 196e420c8..000000000
--- a/pandas/tests/test_pytools.py
+++ /dev/null
@@ -1,68 +0,0 @@
-import pandas.core.pytools as pytools
-
-def test_rands():
-    r = pytools.rands(10)
-    assert(len(r) == 10)
-
-def test_adjoin():
-    data = [['a', 'b', 'c'],
-            ['dd', 'ee', 'ff'],
-            ['ggg', 'hhh', 'iii']]
-    expected = 'a  dd  ggg\nb  ee  hhh\nc  ff  iii'
-
-    adjoined = pytools.adjoin(2, *data)
-
-    assert(adjoined == expected)
-
-def test_iterpairs():
-    data = [1, 2, 3, 4]
-    expected = [(1, 2),
-                (2, 3),
-                (3, 4)]
-
-    result = list(pytools.iterpairs(data))
-
-    assert(result == expected)
-
-def test_indent():
-    s = 'a b c\nd e f'
-    result = pytools.indent(s, spaces=6)
-
-    assert(result == '      a b c\n      d e f')
-
-def test_banner():
-    ban = pytools.banner('hi')
-    assert(ban == ('%s\nhi\n%s' % ('=' * 80, '=' * 80)))
-
-def test_map_indices_py():
-    data = [4, 3, 2, 1]
-    expected = {4 : 0, 3 : 1, 2 : 2, 1 : 3}
-
-    result = pytools.map_indices_py(data)
-
-    assert(result == expected)
-
-def test_union():
-    a = [1, 2, 3]
-    b = [4, 5, 6]
-
-    union = sorted(pytools.union(a, b))
-
-    assert((a + b) == union)
-
-def test_difference():
-    a = [1, 2, 3]
-    b = [1, 2, 3, 4, 5, 6]
-
-    inter = sorted(pytools.difference(b, a))
-
-    assert([4, 5, 6] == inter)
-
-def test_intersection():
-    a = [1, 2, 3]
-    b = [1, 2, 3, 4, 5, 6]
-
-    inter = sorted(pytools.intersection(a, b))
-
-    assert(a == inter)
-

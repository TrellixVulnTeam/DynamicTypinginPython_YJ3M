commit 53f022a28690259f596d3783f033367101c622c7
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Feb 5 20:41:51 2010 +0000

    miscellaneous changes to codebase, docs in flux
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@123 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/doc/source/conf.py b/doc/source/conf.py
index d6ad23939..8aa3090db 100644
--- a/doc/source/conf.py
+++ b/doc/source/conf.py
@@ -58,7 +58,9 @@ copyright = u'2008-2010, AQR Capital Management, LLC'
 #
 # The short X.Y version.
 import pandas
-version = pandas.__version__
+# version = pandas.__version__
+version = 0.2
+
 # The full version, including alpha/beta/rc tags.
 release = version
 
diff --git a/doc/source/dataframe.rst b/doc/source/dataframe.rst
index f6556335a..cbe7b6fe6 100644
--- a/doc/source/dataframe.rst
+++ b/doc/source/dataframe.rst
@@ -1,14 +1,26 @@
 .. _dataframe:
 
+.. currentmodule:: pandas
+
 ************************
 DataFrame and DataMatrix
 ************************
 
+.. class:: DataFrame
+
+   :Parameters:
+       **data** : dict
+           * a sequence of objects (numbers, characters, objects)
+           * an :class:`~numpy.ndarray` or one of its subclass.
+
+       **index** : {array_like}
+
+   .. seealso::
+       :func:`DataFrame.fromDict`
+
 Basics
 ------
 
-.. currentmodule:: pandas
-
 **DataFrame** is a both 2D-matrix- and dict-like object implementing a
 named collection of identically-indexed Series objects. There is
 another important class called **DataMatrix** which has almost
@@ -105,7 +117,7 @@ There are several ways to create a DataFrame:
 .. autosummary::
    :toctree: generated/
 
-   DataFrame
+   DataFrame.__init__
    DataFrame.fromDict
    DataFrame.fromMatrix
    DataFrame.fromRecords
diff --git a/doc/source/index.rst b/doc/source/index.rst
index 4e2f97c37..d4555bfc9 100755
--- a/doc/source/index.rst
+++ b/doc/source/index.rst
@@ -60,19 +60,19 @@ User manual
     datetools
     stats
 
-Quick Reference
----------------
+.. Quick Reference
+.. ---------------
 
-.. autosummary::
-   :toctree: generated/
+.. .. autosummary::
+..    :toctree: generated/
 
-   Index
-   Series
-   TimeSeries
-   DataFrame
-   DataMatrix
-   WidePanel
-   LongPanel
+..    Index
+..    Series
+..    TimeSeries
+..    DataFrame
+..    DataMatrix
+..    WidePanel
+..    LongPanel
 
 Indices and tables
 ------------------
@@ -85,4 +85,4 @@ Contact
 -------
 
 Please feel free to send comments or questions directly to
-wesmckinn@gmail.com or the pystatsmodels mailing list.
\ No newline at end of file
+wesmckinn@gmail.com or the pystatsmodels mailing list.
diff --git a/doc/source/series.rst b/doc/source/series.rst
index 54cb63719..7ab9b66c5 100644
--- a/doc/source/series.rst
+++ b/doc/source/series.rst
@@ -16,6 +16,25 @@ different-sized Series by matching index values.
 Because Series is an ndarray, it can be used interchangeably in
 NumPy-based functions expecting one-dimensional ndarrays.
 
+.. class:: Series
+
+   A subclass of :class:`~numpy.ndarray` designed for labeled
+   1-dimensional data.
+
+   :Parameters:
+       **data** : {array_like}
+           Data portion of the array. Any data that is valid for
+           constructing a :class:`~numpy.ndarray` can be used here:
+
+           * a sequence of objects (numbers, characters, objects)
+           * an :class:`~numpy.ndarray` or one of its subclass.
+
+       **index** : {array_like}
+           A :class:`DateArray` instance storing the date information.
+
+   .. seealso::
+       :func:`Series.fromDict`
+
 .. note::
 
     The basic concepts presented here apply to the higher dimensional
@@ -102,7 +121,7 @@ Summary of constructors
 .. autosummary::
    :toctree: generated/
 
-   Series
+   Series.__new__
    Series.fromDict
    Series.fromValue
 
diff --git a/doc/source/stats.plm.rst b/doc/source/stats.plm.rst
index 3b3b72130..45f481090 100644
--- a/doc/source/stats.plm.rst
+++ b/doc/source/stats.plm.rst
@@ -2,6 +2,6 @@ OLS Panel regression
 --------------------
 
 .. automodule:: pandas.stats.plm
-   :members:
-   :undoc-members:
-   :show-inheritance:
+   .. :members:
+   .. :undoc-members:
+   .. :show-inheritance:
diff --git a/doc/source/stats.rst b/doc/source/stats.rst
index 01d144b37..b54146ba1 100755
--- a/doc/source/stats.rst
+++ b/doc/source/stats.rst
@@ -14,22 +14,22 @@ Least-squares entry-point
 
    ols
 
-Class reference
----------------
+.. Class reference
+.. ---------------
 
-.. currentmodule:: pandas.stats.ols
+.. .. currentmodule:: pandas.stats.ols
 
-.. autosummary::
-   :toctree: generated/
+.. .. autosummary::
+..    :toctree: generated/
 
-   OLS
-   MovingOLS
+..    OLS
+..    MovingOLS
 
-.. currentmodule:: pandas.stats.plm
+.. .. currentmodule:: pandas.stats.plm
 
-.. autosummary::
-   :toctree: generated/
+.. .. autosummary::
+..    :toctree: generated/
 
-   PanelOLS
-   MovingPanelOLS
+..    PanelOLS
+..    MovingPanelOLS
 
diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index 3c583cceb..55a155ed1 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -133,9 +133,21 @@ class DateRange(Index):
             if not periods:
                 periods = kwds.get('nPeriods')
 
-            if offset.isAnchored() and not isinstance(offset, datetools.Tick):
+            fromDate = datetools.to_datetime(fromDate)
+            toDate = datetools.to_datetime(toDate)
+
+            # inside cache range
+            fromInside = fromDate is not None and fromDate > CACHE_START
+            toInside = toDate is not None and toDate < CACHE_END
+
+            useCache = fromInside and toInside
+
+            if (useCache and offset.isAnchored() and
+                not isinstance(offset, datetools.Tick)):
+
                 index = cls.getCachedRange(fromDate, toDate, periods=periods,
                                            offset=offset, timeRule=timeRule)
+
             else:
                 xdr = XDateRange(fromDate=fromDate, toDate=toDate,
                                  nPeriods=periods, offset=offset,
@@ -162,9 +174,6 @@ class DateRange(Index):
         if offset is None:
             raise Exception('Must provide a DateOffset!')
 
-        start = datetools.to_datetime(start)
-        end = datetools.to_datetime(end)
-
         if start is not None and not isinstance(start, datetime):
             raise Exception('%s is not a valid date!' % start)
 
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index aa45128e4..695b62fa8 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -143,14 +143,14 @@ class WidePanel(Panel):
         self.values = values
 
     @classmethod
-    def _wide_axis_number(cls, axis):
+    def _get_axis_number(cls, axis):
         if axis in (0, 1, 2):
             return axis
         else:
             return _WIDE_AXIS_NUMBERS[axis]
 
     @classmethod
-    def _wide_axis_name(cls, axis):
+    def _get_axis_name(cls, axis):
         if axis in _WIDE_AXIS_NUMBERS:
             return axis
         else:
@@ -163,13 +163,13 @@ class WidePanel(Panel):
             2 : self.minor_axis
         }
 
-        return results[self._wide_axis_number(axis)]
+        return results[self._get_axis_number(axis)]
 
     def _get_plane_axes(self, axis):
         """
 
         """
-        axis = self._wide_axis_name(axis)
+        axis = self._get_axis_name(axis)
 
         if axis == 'major':
             index = self.minor_axis
@@ -450,9 +450,13 @@ class WidePanel(Panel):
     __rdiv__ = _arith_method(lambda x, y: y / x, '__rdiv__')
     __rpow__ = _arith_method(lambda x, y: y ** x, '__rpow__')
 
+    def __neg__(self):
+        return WidePanel(-self.values, self.items, self.major_axis,
+                          self.minor_axis)
+
     def _combineFrame(self, other, func, axis=0):
         index, columns = self._get_plane_axes(axis)
-        axis = self._wide_axis_number(axis)
+        axis = self._get_axis_number(axis)
 
         other = other.reindex(index=index, columns=columns)
 
@@ -469,7 +473,21 @@ class WidePanel(Panel):
                          self.minor_axis)
 
     def _combinePanel(self, other, func):
-        pass
+        if isinstance(other, LongPanel):
+            other = other.toWide()
+
+        items = self.items + other.items
+        major = self.major_axis + other.major_axis
+        minor = self.minor_axis + other.minor_axis
+
+        # could check that everything's the same size, but forget it
+
+        this = self.reindex(items=items, major=major, minor=minor)
+        other = other.reindex(items=items, major=major, minor=minor)
+
+        result_values = func(this.values, other.values)
+
+        return WidePanel(result_values, items, major, minor)
 
     def add(self, other, axis='major'):
         """
@@ -553,8 +571,8 @@ class WidePanel(Panel):
         -------
         y : WidePanel (new object)
         """
-        i = self._wide_axis_number(axis1)
-        j = self._wide_axis_number(axis2)
+        i = self._get_axis_number(axis1)
+        j = self._get_axis_number(axis2)
 
         if i == j:
             raise Exception('Cannot specify the same axis')
@@ -651,7 +669,7 @@ class WidePanel(Panel):
         -------
         result : DataMatrix or WidePanel
         """
-        i = self._wide_axis_number(axis)
+        i = self._get_axis_number(axis)
 
         result = np.apply_along_axis(func, i, self.values)
 
@@ -686,7 +704,7 @@ class WidePanel(Panel):
         -------
         y : DataMatrix
         """
-        i = self._wide_axis_number(axis)
+        i = self._get_axis_number(axis)
 
         result = self._values_aggregate(func, i, fill_value)
         return self._wrap_result(result, axis=axis)
@@ -699,7 +717,7 @@ class WidePanel(Panel):
         -------
         y : DataMatrix
         """
-        i = self._wide_axis_number(axis)
+        i = self._get_axis_number(axis)
 
         values = self.values
         mask = np.isfinite(values)
@@ -741,7 +759,7 @@ class WidePanel(Panel):
         -------
         y : DataMatrix
         """
-        i = self._wide_axis_number(axis)
+        i = self._get_axis_number(axis)
         index, columns = self._get_plane_axes(axis)
 
         y = np.array(self.values)
@@ -806,7 +824,7 @@ class WidePanel(Panel):
         -------
         y : DataMatrix
         """
-        i = self._wide_axis_number(axis)
+        i = self._get_axis_number(axis)
 
         y = np.array(self.values)
         mask = np.isfinite(y)
@@ -827,7 +845,7 @@ class WidePanel(Panel):
         -------
         y : DataMatrix
         """
-        i = self._wide_axis_number(axis)
+        i = self._get_axis_number(axis)
 
         y = np.array(self.values)
         mask = np.isfinite(y)
@@ -842,7 +860,7 @@ class WidePanel(Panel):
         return self._wrap_result(result, axis)
 
     def _wrap_result(self, result, axis):
-        axis = self._wide_axis_name(axis)
+        axis = self._get_axis_name(axis)
 
         if result.ndim == 2:
             index, columns = self._get_plane_axes(axis)
@@ -879,172 +897,57 @@ class WidePanel(Panel):
         return WidePanel(values=values, items=items, major_axis=major_axis,
                          minor_axis=minor_axis)
 
-class LongPanelIndex(object):
-    """
-    Parameters
-    ----------
 
-    """
-    def __init__(self, major_axis, minor_axis, major_labels,
-                 minor_labels, mask=None):
-
-        self.major_axis = major_axis
-        self.minor_axis = minor_axis
-
-        assert(len(minor_labels) == len(major_labels))
-
-        self.major_labels = major_labels
-        self.minor_labels = minor_labels
-
-        self._mask = mask
-
-    def __getstate__(self):
-        return (_pickle_array(self.major_axis),
-                _pickle_array(self.minor_axis),
-                _pickle_array(self.major_labels),
-                _pickle_array(self.minor_labels))
-
-    def __setstate__(self, state):
-        major, minor, major_labels, minor_labels = state
-
-        self.major_axis = _unpickle_array(major)
-        self.minor_axis = _unpickle_array(minor)
-
-        self.major_labels = _unpickle_array(major_labels)
-        self.minor_labels = _unpickle_array(minor_labels)
-
-    def isConsistent(self):
-        offset = max(len(self.major_axis), len(self.minor_axis))
-
-        # overflow risk
-        if (offset + 1) ** 2 > 2**32:
-            keys = (self.major_labels.astype(np.int64) * offset +
-                    self.minor_labels.astype(np.int64))
-        else:
-            keys = self.major_labels * offset + self.minor_labels
-
-        unique_keys = np.unique(keys)
-
-        if len(unique_keys) < len(keys):
-            return False
-
-        return True
-
-    def truncate(self, before=None, after=None):
-        """
-        Slice index between two major axis values, return new
-        LongPanelIndex
+    def truncate(self, before=None, after=None, axis='major'):
+        """Function truncate a sorted DataFrame before and/or after
+        some particular dates.
 
         Parameters
         ----------
-        before : type of major_axis values or None, default None
-            None defaults to start of panel
-
-        after : type of major_axis values or None, default None
-            None defaults to after of panel
+        before : date
+            Truncate before date
+        after : date
+            Truncate after date
 
         Returns
         -------
-        LongPanelIndex
+        DataFrame
         """
-        i, j = self._getAxisBounds(before, after)
-        left, right = self._getLabelBounds(i, j)
+        axis = self._get_axis_name(axis)
+        index = self._get_axis(axis)
 
-        return LongPanelIndex(self.major_axis[i : j],
-                              self.minor_axis,
-                              self.major_labels[left : right] - i,
-                              self.minor_labels[left : right])
+        beg_slice, end_slice = self._getIndices(before, after, axis=axis)
+        new_index = index[beg_slice:end_slice]
 
-    def getMajorBounds(self, begin=None, end=None):
-        """
-        Return index bounds for slicing LongPanel labels and / or
-        values
+        return self.reindex(**{axis : new_index})
 
-        Parameters
-        ----------
-        begin : axis value or None
-        end : axis value or None
+    def _getIndices(self, before, after, axis='major'):
+        index = self._get_axis(axis)
 
-        Returns
-        -------
-        y : tuple
-            (left, right) absolute bounds on LongPanel values
-        """
-        i, j = self._getAxisBounds(begin, end)
-        left, right = self._getLabelBounds(i, j)
-
-        return left, right
-
-    def _getAxisBounds(self, begin, end):
-        """
-        Return major axis locations corresponding to interval values
-        """
-        if begin is not None:
-            i = self.major_axis.indexMap.get(begin)
-            if i is None:
-                i = self.major_axis.searchsorted(begin, side='right')
-        else:
-            i = 0
-
-        if end is not None:
-            j = self.major_axis.indexMap.get(end)
-            if j is None:
-                j = self.major_axis.searchsorted(end)
-            else:
-                j = j + 1
-        else:
-            j = len(self.major_axis)
-
-        if i > j:
-            raise Exception('Must have begin <= end!')
-
-        return i, j
-
-    def _getLabelBounds(self, i, j):
-        "Return slice points between two major axis locations"
-
-        left = self._bounds[i]
-
-        if j >= len(self.major_axis):
-            right = len(self.major_labels)
-        else:
-            right = self._bounds[j]
-
-        return left, right
-
-    __bounds = None
-    @property
-    def _bounds(self):
-        "Return or compute and return slice points for major axis"
-        if self.__bounds is None:
-            inds = np.arange(len(self.major_axis))
-            self.__bounds = self.major_labels.searchsorted(inds)
+        if before is None:
+            before = index[0]
+        elif before not in index:
+            loc = index.searchsorted(before, side='left')
+            before = index[loc]
 
-        return self.__bounds
+        if after is None:
+            after = index[-1]
+        elif after not in index:
+            loc = index.searchsorted(after, side='right') - 1
 
-    @property
-    def mask(self):
-        if self._mask is None:
-            self._mask = self._makeMask()
+            if loc >= len(index):
+                loc = -1
 
-        return self._mask
+            after = index[loc]
 
-    def _makeMask(self):
-        """
-        Create observation selection vector using major and minor
-        labels, for converting to wide format.
-        """
-        N, K = self.dims
-        selector = self.minor_labels + K * self.major_labels
+        beg_slice = index.indexMap[before]
+        end_slice = index.indexMap[after] + 1
 
-        mask = np.zeros(N * K, dtype=bool)
-        mask[selector] = True
+        return beg_slice, end_slice
 
-        return mask
 
-    @property
-    def dims(self):
-        return len(self.major_axis), len(self.minor_axis)
+#-------------------------------------------------------------------------------
+# LongPanel and friends
 
 
 class LongPanel(Panel):
@@ -1664,6 +1567,174 @@ class LongPanel(Panel):
         return LongPanel(self.values, new_items, self.index)
 
 
+class LongPanelIndex(object):
+    """
+    Parameters
+    ----------
+
+    """
+    def __init__(self, major_axis, minor_axis, major_labels,
+                 minor_labels, mask=None):
+
+        self.major_axis = major_axis
+        self.minor_axis = minor_axis
+
+        assert(len(minor_labels) == len(major_labels))
+
+        self.major_labels = major_labels
+        self.minor_labels = minor_labels
+
+        self._mask = mask
+
+    def __getstate__(self):
+        return (_pickle_array(self.major_axis),
+                _pickle_array(self.minor_axis),
+                _pickle_array(self.major_labels),
+                _pickle_array(self.minor_labels))
+
+    def __setstate__(self, state):
+        major, minor, major_labels, minor_labels = state
+
+        self.major_axis = _unpickle_array(major)
+        self.minor_axis = _unpickle_array(minor)
+
+        self.major_labels = _unpickle_array(major_labels)
+        self.minor_labels = _unpickle_array(minor_labels)
+
+    def isConsistent(self):
+        offset = max(len(self.major_axis), len(self.minor_axis))
+
+        # overflow risk
+        if (offset + 1) ** 2 > 2**32:
+            keys = (self.major_labels.astype(np.int64) * offset +
+                    self.minor_labels.astype(np.int64))
+        else:
+            keys = self.major_labels * offset + self.minor_labels
+
+        unique_keys = np.unique(keys)
+
+        if len(unique_keys) < len(keys):
+            return False
+
+        return True
+
+    def truncate(self, before=None, after=None):
+        """
+        Slice index between two major axis values, return new
+        LongPanelIndex
+
+        Parameters
+        ----------
+        before : type of major_axis values or None, default None
+            None defaults to start of panel
+
+        after : type of major_axis values or None, default None
+            None defaults to after of panel
+
+        Returns
+        -------
+        LongPanelIndex
+        """
+        i, j = self._getAxisBounds(before, after)
+        left, right = self._getLabelBounds(i, j)
+
+        return LongPanelIndex(self.major_axis[i : j],
+                              self.minor_axis,
+                              self.major_labels[left : right] - i,
+                              self.minor_labels[left : right])
+
+    def getMajorBounds(self, begin=None, end=None):
+        """
+        Return index bounds for slicing LongPanel labels and / or
+        values
+
+        Parameters
+        ----------
+        begin : axis value or None
+        end : axis value or None
+
+        Returns
+        -------
+        y : tuple
+            (left, right) absolute bounds on LongPanel values
+        """
+        i, j = self._getAxisBounds(begin, end)
+        left, right = self._getLabelBounds(i, j)
+
+        return left, right
+
+    def _getAxisBounds(self, begin, end):
+        """
+        Return major axis locations corresponding to interval values
+        """
+        if begin is not None:
+            i = self.major_axis.indexMap.get(begin)
+            if i is None:
+                i = self.major_axis.searchsorted(begin, side='right')
+        else:
+            i = 0
+
+        if end is not None:
+            j = self.major_axis.indexMap.get(end)
+            if j is None:
+                j = self.major_axis.searchsorted(end)
+            else:
+                j = j + 1
+        else:
+            j = len(self.major_axis)
+
+        if i > j:
+            raise Exception('Must have begin <= end!')
+
+        return i, j
+
+    def _getLabelBounds(self, i, j):
+        "Return slice points between two major axis locations"
+
+        left = self._bounds[i]
+
+        if j >= len(self.major_axis):
+            right = len(self.major_labels)
+        else:
+            right = self._bounds[j]
+
+        return left, right
+
+    __bounds = None
+    @property
+    def _bounds(self):
+        "Return or compute and return slice points for major axis"
+        if self.__bounds is None:
+            inds = np.arange(len(self.major_axis))
+            self.__bounds = self.major_labels.searchsorted(inds)
+
+        return self.__bounds
+
+    @property
+    def mask(self):
+        if self._mask is None:
+            self._mask = self._makeMask()
+
+        return self._mask
+
+    def _makeMask(self):
+        """
+        Create observation selection vector using major and minor
+        labels, for converting to wide format.
+        """
+        N, K = self.dims
+        selector = self.minor_labels + K * self.major_labels
+
+        mask = np.zeros(N * K, dtype=bool)
+        mask[selector] = True
+
+        return mask
+
+    @property
+    def dims(self):
+        return len(self.major_axis), len(self.minor_axis)
+
+
 class Factor(object):
     """
     Represents a categorical variable in classic R / S+ fashion
diff --git a/pandas/stats/common.py b/pandas/stats/common.py
index bfab8429a..75b93c3ae 100644
--- a/pandas/stats/common.py
+++ b/pandas/stats/common.py
@@ -6,8 +6,9 @@ TIME = 0
 ENTITY = 1
 
 def _get_cluster_type(cluster_type):
-    if cluster_type in (TIME, ENTITY):
+    if cluster_type in (TIME, ENTITY, None):
         return cluster_type
+
     elif isinstance(cluster_type, basestring):
         cluster_type_up = cluster_type.upper()
 
diff --git a/pandas/stats/interface.py b/pandas/stats/interface.py
index 05ea3f76e..7a2f7218a 100644
--- a/pandas/stats/interface.py
+++ b/pandas/stats/interface.py
@@ -43,8 +43,8 @@ def ols(**kwargs):
             For entity fixed effects, key equals 'entity'.
 
             By default, the first dummy is dropped if no dummy is specified.
-        cluster: int
-            ENTITY or TIME, indicating entity/time clustering
+        cluster: {'time', 'entity'}
+            cluster variances
 
     Returns
     -------
diff --git a/pandas/stats/plm.py b/pandas/stats/plm.py
index 88f707c43..a1037e965 100644
--- a/pandas/stats/plm.py
+++ b/pandas/stats/plm.py
@@ -69,7 +69,7 @@ class PanelOLS(OLS):
         self._time_effects = time_effects
         self._x_effects = x_effects
         self._dropped_dummies = dropped_dummies or {}
-        self._cluster = cluster
+        self._cluster = common._get_cluster_type(cluster)
         self._verbose = verbose
 
         (self._x, self._x_trans,

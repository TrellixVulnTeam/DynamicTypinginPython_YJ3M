commit 57869f18af54697b1f25b6ef9e3372a7c1650cd6
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Dec 14 23:20:58 2011 -0500

    BUG: handle datetime.datetime in nanmin/nanmax, on Python 2 at least, GH #487

diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index b1f90b4ce..e304504e7 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -1,3 +1,5 @@
+import sys
+
 import numpy as np
 
 from pandas.core.common import isnull, notnull
@@ -112,10 +114,14 @@ def nanmin(values, axis=None, skipna=True, copy=True):
             values = values.copy()
         np.putmask(values, mask, np.inf)
     # numpy 1.6.1 workaround in Python 3.x
-    if values.dtype == np.object_:  # pragma: no cover
+    if (values.dtype == np.object_
+        and sys.version_info[0] >= 3):  # pragma: no cover
         import __builtin__
-        apply_ax = axis if axis is not None else 0
-        result = np.apply_along_axis(__builtin__.min, apply_ax, values)
+        if values.ndim > 1:
+            apply_ax = axis if axis is not None else 0
+            result = np.apply_along_axis(__builtin__.min, apply_ax, values)
+        else:
+            result = __builtin__.min(values)
     else:
         result = values.min(axis)
 
@@ -128,10 +134,15 @@ def nanmax(values, axis=None, skipna=True, copy=True):
             values = values.copy()
         np.putmask(values, mask, -np.inf)
     # numpy 1.6.1 workaround in Python 3.x
-    if values.dtype == np.object_:  # pragma: no cover
+    if (values.dtype == np.object_
+        and sys.version_info[0] >= 3):  # pragma: no cover
         import __builtin__
-        apply_ax = axis if axis is not None else 0
-        result = np.apply_along_axis(__builtin__.max, apply_ax, values)
+
+        if values.ndim > 1:
+            apply_ax = axis if axis is not None else 0
+            result = np.apply_along_axis(__builtin__.max, apply_ax, values)
+        else:
+            result = __builtin__.max(values)
     else:
         result = values.max(axis)
     return _maybe_null_out(result, axis, mask)
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index cc08aa2f7..91c417a8e 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -575,10 +575,10 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self._check_stat_op('prod', np.prod)
 
     def test_min(self):
-        self._check_stat_op('min', np.min)
+        self._check_stat_op('min', np.min, check_objects=True)
 
     def test_max(self):
-        self._check_stat_op('max', np.max)
+        self._check_stat_op('max', np.max, check_objects=True)
 
     def test_std(self):
         alt = lambda x: np.std(x, ddof=1)
@@ -604,7 +604,9 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
     def test_cumprod(self):
         self._check_accum_op('cumprod')
 
-    def _check_stat_op(self, name, alternate):
+    def _check_stat_op(self, name, alternate, check_objects=False):
+        from pandas import DateRange
+
         f = getattr(Series, name)
 
         # add some NaNs
@@ -625,6 +627,13 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         s = Series([1, 2, 3, None, 5])
         f(s)
 
+        # check DateRange
+        if check_objects:
+            s = Series(DateRange('1/1/2000', periods=10))
+            res = f(s)
+            exp = alternate(s)
+            self.assertEqual(res, exp)
+
     def _check_accum_op(self, name):
         func = getattr(np, name)
         self.assert_(np.array_equal(func(self.ts), func(np.array(self.ts))))

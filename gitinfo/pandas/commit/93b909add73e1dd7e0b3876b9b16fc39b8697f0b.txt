commit 93b909add73e1dd7e0b3876b9b16fc39b8697f0b
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Nov 23 21:10:06 2011 -0500

    BUG: handle Index name in pickling, indexing test and bugfix, GH #408

diff --git a/RELEASE.rst b/RELEASE.rst
index 71ff6a544..c4a7ebdc8 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -158,6 +158,9 @@ pandas 0.6.0
     information (GH #403)
   - Fix integer name formatting bug in Index.format and in Series.__repr__
   - Handle label types other than string passed to groupby (GH #405)
+  - Fix bug in .ix-based indexing with partial retrieval when a label is not
+    contained in a level
+  - Index name was not being pickled (GH #408)
 
 Thanks
 ------
diff --git a/pandas/core/format.py b/pandas/core/format.py
index b26512e7b..0b1905a91 100644
--- a/pandas/core/format.py
+++ b/pandas/core/format.py
@@ -84,20 +84,6 @@ class DataFrameFormatter(object):
             indent -= indent_delta
             write(buf, '</tr>', indent)
 
-        def single_column_table(column):
-            table = '<table><tbody>'
-            for i in column:
-                table += ('<tr><td>%s</td></tr>' % str(i))
-            table += '</tbody></table>'
-            return table
-
-        def single_row_table(row):
-            table = '<table><tbody><tr>'
-            for i in row:
-                table += ('<td>%s</td>' % str(i))
-            table += '</tr></tbody></table>'
-            return table
-
         indent = 0
         indent_delta = 2
         frame = self.frame
@@ -243,6 +229,21 @@ class DataFrameFormatter(object):
             names.append('' if columns.name is None else columns.name)
         return names
 
+
+def single_column_table(column):
+    table = '<table><tbody>'
+    for i in column:
+        table += ('<tr><td>%s</td></tr>' % str(i))
+    table += '</tbody></table>'
+    return table
+
+def single_row_table(row):  # pragma: no cover
+    table = '<table><tbody><tr>'
+    for i in row:
+        table += ('<td>%s</td>' % str(i))
+    table += '</tr></tbody></table>'
+    return table
+
 def _has_names(index):
     if isinstance(index, MultiIndex):
         return any([x is not None for x in index.names])
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 0258e5bf3..1ad42b3ae 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2892,23 +2892,6 @@ class DataFrame(NDFrame):
         applyf = lambda x: method(x, axis=axis, skipna=skipna)
         return self.groupby(level=level, axis=axis).aggregate(applyf)
 
-    def _get_agg_data(self, axis, numeric_only=True, copy=True):
-        num_cols = self._get_numeric_columns()
-
-        if len(num_cols) < len(self.columns) and numeric_only:
-            y = self.as_matrix(num_cols)
-            if axis == 0:
-                axis_labels = num_cols
-            else:
-                axis_labels = self.index
-        else:
-            y = self.values
-            if copy:
-                y = y.copy()
-            axis_labels = self._get_agg_axis(axis)
-
-        return y, axis_labels
-
     def _get_agg_axis(self, axis_num):
         if axis_num == 0:
             return self.columns
diff --git a/pandas/core/index.py b/pandas/core/index.py
index adb886a02..545c9707b 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -143,9 +143,21 @@ class Index(np.ndarray):
     def __iter__(self):
         return iter(self.values)
 
+    def __reduce__(self):
+        """Necessary for making this object picklable"""
+        object_state = list(np.ndarray.__reduce__(self))
+        subclass_state = self.name,
+        object_state[2] = (object_state[2], subclass_state)
+        return tuple(object_state)
+
     def __setstate__(self, state):
         """Necessary for making this object picklable"""
-        np.ndarray.__setstate__(self, state)
+        if len(state) == 2:
+            nd_state, own_state = state
+            np.ndarray.__setstate__(self, nd_state)
+            self.name = own_state[0]
+        else:  # pragma: no cover
+            np.ndarray.__setstate__(self, state)
 
     def __deepcopy__(self, memo={}):
         """
@@ -1331,7 +1343,7 @@ class MultiIndex(Index):
         """
         return Index(list(self))
 
-    def slice_locs(self, start=None, end=None):
+    def slice_locs(self, start=None, end=None, strict=False):
         """
         For an ordered MultiIndex, compute the slice locations for input
         labels. They can tuples representing partial levels, e.g. for a
@@ -1344,6 +1356,7 @@ class MultiIndex(Index):
             If None, defaults to the beginning
         end : label or tuple
             If None, defaults to the end
+        strict : boolean,
 
         Returns
         -------
@@ -1383,7 +1396,7 @@ class MultiIndex(Index):
             if lab not in lev:
                 # short circuit
                 loc = lev.searchsorted(lab, side=side)
-                if side == 'right' and loc > 0:
+                if side == 'right' and loc >= 0:
                     loc -= 1
                 return start + section.searchsorted(loc, side=side)
 
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 86be20d3d..532e51e10 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -317,8 +317,7 @@ class _SeriesIndexer(_NDFrameIndexer):
         elif isinstance(key, slice):
             key = self._convert_slice(key)
         elif _is_list_like(key):
-            self._set_list_like(key, value)
-            return
+            return self._set_list_like(key, value)
         return self._set_default(key, value)
 
     def _check_boolean_key(self, key):
diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index 25b0083dd..46b710a40 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -6,7 +6,7 @@ import pandas._tseries as lib
 try:
     import bottleneck as bn
     _USE_BOTTLENECK = True
-except ImportError:
+except ImportError:  # pragma: no cover
     _USE_BOTTLENECK = False
 
 def nansum(values, axis=None, skipna=True, copy=True):
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 855ddf0e8..c8ad273a4 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -3063,10 +3063,10 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
 
     def test_count(self):
         f = lambda s: notnull(s).sum()
-        self._check_stat_op('count', f, has_skipna=False)
+        self._check_stat_op('count', f, has_skipna=False,
+                            has_numeric_only=True)
 
         # corner case
-
         frame = DataFrame()
         ct1 = frame.count(1)
         self.assert_(isinstance(ct1, Series))
@@ -3075,7 +3075,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         self.assert_(isinstance(ct2, Series))
 
     def test_sum(self):
-        self._check_stat_op('sum', np.sum)
+        self._check_stat_op('sum', np.sum, has_numeric_only=True)
 
     def test_stat_ops_attempt_obj_array(self):
         data = {
@@ -3139,7 +3139,8 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
 
         self._check_stat_op('skew', alt)
 
-    def _check_stat_op(self, name, alternative, frame=None, has_skipna=True):
+    def _check_stat_op(self, name, alternative, frame=None, has_skipna=True,
+                       has_numeric_only=False):
         if frame is None:
             frame = self.frame
             # set some NAs
@@ -3181,6 +3182,12 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         getattr(self.mixed_frame, name)(axis=0)
         getattr(self.mixed_frame, name)(axis=1)
 
+        if has_numeric_only:
+            getattr(self.mixed_frame, name)(axis=0, numeric_only=True)
+            getattr(self.mixed_frame, name)(axis=1, numeric_only=True)
+            getattr(self.frame, name)(axis=0, numeric_only=False)
+            getattr(self.frame, name)(axis=1, numeric_only=False)
+
         # all NA case
         if has_skipna:
             all_na = self.frame * np.NaN
@@ -3432,6 +3439,13 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
             name = names[i]
             assert_almost_equal(values, deleveled[name])
 
+        stacked.index.names = [None, None]
+        deleveled2 = stacked.delevel()
+        self.assert_(np.array_equal(deleveled['first'],
+                                    deleveled2['level_0']))
+        self.assert_(np.array_equal(deleveled['second'],
+                                    deleveled2['level_1']))
+
         # exception if no name
         self.assertRaises(Exception, self.frame.delevel)
 
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 09ca7179d..c27357fe1 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -224,10 +224,14 @@ class TestIndex(unittest.TestCase):
 
             self.assert_(isinstance(unpickled, Index))
             self.assert_(np.array_equal(unpickled, index))
+            self.assertEquals(unpickled.name, index.name)
 
             tm.assert_dict_equal(unpickled.indexMap, index.indexMap)
 
         testit(self.strIndex)
+        self.strIndex.name = 'foo'
+        testit(self.strIndex)
+
         testit(self.dateIndex)
 
     # def test_always_get_null_index(self):
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 76045b862..800237e21 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -689,6 +689,24 @@ class TestMultiLevel(unittest.TestCase):
         self.assert_(unstacked['E', 1].dtype == np.object_)
         self.assert_(unstacked['F', 1].dtype == np.float64)
 
+    def test_partial_ix_missing(self):
+        result = self.ymd.ix[2000, 0]
+        expected = self.ymd.ix[2000]['A']
+        assert_series_equal(result, expected)
+
+        # need to put in some work here
+
+        # self.ymd.ix[2000, 0] = 0
+        # self.assert_((self.ymd.ix[2000]['A'] == 0).all())
+
+        self.assertRaises(Exception, self.ymd.ix.__getitem__, (2000, 6))
+        self.assertRaises(Exception, self.ymd.ix.__getitem__, (2000, 6), 0)
+
+    def test_to_html(self):
+        self.ymd.columns.name = 'foo'
+        self.ymd.to_html()
+        self.ymd.T.to_html()
+
 if __name__ == '__main__':
 
     # unittest.main()

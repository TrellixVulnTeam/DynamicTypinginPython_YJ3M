commit 79dfede32fca59b984cf57d37784831edcf54605
Author: Adam Klein <adamklein@gmail.com>
Date:   Wed Jan 25 19:48:41 2012 -0500

    Ripped timeseries code from scikits.timeseries, got it to compile

diff --git a/.gitignore b/.gitignore
index 84bcf6f93..041495819 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,6 +7,7 @@ MANIFEST
 *.c
 !np_datetime.c
 !np_datetime_strings.c
+!pandas/src/timeseries/*.c
 *.cpp
 *.so
 *.pyd
diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index bdc8acec0..f0ccb2d9a 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -94,7 +94,7 @@ class DateRange(DatetimeIndex):
                                  offset=offset, time_rule=time_rule)
             index = list(xdr)
 
-        if tzinfo is not None:
+        if tzinfa is not None:
             index = [d.replace(tzinfo=tzinfo) for d in index]
 
         index = np.array(index, dtype='M8[us]', copy=False)
diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index ca42f34fe..ccb0d00ec 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -75,9 +75,9 @@ cdef extern from "np_datetime.h":
                                              NPY_DATETIMEUNIT *out_bestunit,
                                              int apply_tzinfo)
 
-    int is_leapyear(int64_t year)
     int _days_per_month_table[2][12]
     int dayofweek(int y, int m, int d)
+    int is_leapyear(int64_t year)
 
 cdef extern from "np_datetime_strings.h":
 
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 19dba462e..0aa6083ec 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -21,15 +21,27 @@ PyDateTime_IMPORT
 # in numpy 1.7, will prob need this
 # numpy_pydatetime_import
 
+ctypedef enum time_res:
+    r_min = 0
+    r_microsecond
+    r_second
+    r_minute
+    r_hour
+    r_day
+    r_month
+    r_year
+    r_max = 98
+    r_invalid = 99
+
 # Objects to support date/time arithmetic
 # --------------------------------------------------------------------------------
 
 cdef class Timestamp:
-    '''
+    """
     A timestamp (absolute moment in time) to microsecond resolution; number of
     microseconds since the POSIX epoch, ignoring leap seconds (thereby different
     from UTC).
-    '''
+    """
     cdef:
         int64_t value
         npy_datetimestruct dts
@@ -63,10 +75,10 @@ cdef class Timestamp:
             raise ValueError("Could not construct Timestamp from argument")
 
     def __sub__(self, object other):
-        '''
+        """
         Subtract two timestamps, results in an interval with the start being
         the earlier of the two timestamps.
-        '''
+        """
         if isinstance(other, Timestamp):
             return Interval(self, other)
         elif isinstance(other, Delta):
@@ -94,10 +106,10 @@ cdef class Timestamp:
         raise NotImplementedError("Op %d not recognized" % op)
 
     def __add__(self, object other):
-        '''
+        """
         Add an Interval, Duration, or Period to the Timestamp, resulting in 
         new Timestamp.
-        '''
+        """
         if isinstance(other, (Interval, Duration)):
             return Timestamp(self.asint + other.length)
         elif isinstance(other, Delta):
@@ -106,9 +118,9 @@ cdef class Timestamp:
             raise NotImplementedError("Add operation not supported")
 
     def __str__(self):
-        '''
+        """
         Output ISO8601 format string representation of timestamp.
-        '''
+        """
         cdef:
             int outlen
             char *isostr
@@ -148,6 +160,29 @@ cdef class Timestamp:
 
         return Timestamp(PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts))
 
+    cdef normalize(self, time_res res):
+        cdef:
+            npy_datetimestruct dts
+
+        dts = self.dts
+
+        if res > r_microsecond:
+            dts.us = 0
+        if res > r_second:
+            dts.sec = 0
+        if res > r_minute:
+            dts.min = 0
+        if res > r_hour:
+            dts.hour = 0
+        if res > r_day:
+            dts.day = 1
+        if res > r_month:
+            dts.month = 1
+        if res > r_year:
+            raise ValueError("Invalid resolution")
+
+        return Timestamp(PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts))
+
     property asint:
         def __get__(self):
             return self.value
@@ -185,10 +220,10 @@ cdef class Timestamp:
 
 
 cdef class Interval:
-    '''
+    """
     An absolute time span, from one timestamp to another. Normalized
     to seconds, microseconds, and days.
-    '''
+    """
     cdef:
         Timestamp start
         Timestamp end
@@ -230,9 +265,9 @@ cdef class Interval:
 
 
 cdef class Duration:
-    '''
+    """
     Absolute length of time, similar to timedelta (but faster!)
-    '''
+    """
     cdef int64_t length
 
     def __init__(self, int64_t days = 0,
@@ -277,6 +312,173 @@ cdef class Duration:
         return "Duration(%d, %d, %d)" % (self.days, self.seconds, self.microseconds)
 
 
+cdef convert_to_res(object res):
+    if res == 'microsecond':
+        return r_microsecond
+    if res == 'second':
+        return r_second
+    if res == 'minute':
+        return r_minute
+    if res == 'hour':
+        return r_hour
+    if res == 'day':
+        return r_day
+    if res == 'month':
+        return r_month
+    if res == 'year':
+        return r_year
+    return r_invalid
+
+cdef conversion_factor(time_res res1, time_res res2):
+    cdef:
+        time_res min_res, max_res
+        int64_t factor
+
+    min_res = min(res1, res2)
+    max_res = max(res1, res2)
+    factor = 1
+
+    if min_res == max_res:
+        return factor
+
+    while min_res < max_res:
+        if min_res < r_microsecond:
+            raise "Cannot convert from less than us"
+        elif min_res == r_microsecond:
+            factor *= 1000000
+            min_res = r_second
+        elif min_res == r_second:
+            factor *= 60
+            min_res = r_minute
+        elif min_res == r_minute:
+            factor *= 60
+            min_res = r_hour
+        elif min_res == r_hour:
+            factor *= 24
+            min_res = r_day
+        else:
+            raise "Cannot convert to month or year"
+
+    return factor
+
+# This is all garbage :(
+# Let's try to hack around in scikits.timeseries next...
+# -----------------------------------------
+
+#if offsets.ndim:
+#    assert(len(offsets) > 1 and self.basis == r_microsecond,
+#           "Resolution higher than us not supported")
+
+#    if self.basis == r_year:
+#        assert((offsets >= 1).all() and (offsets <= 12).all(),
+#               "Invalid day offset")
+#    elif self.basis == r_month:
+#        assert((offsets >= 1).all() and (offsets <= 31).all(),
+#               "Invalid day offset")
+#    elif self.basis == r_day:
+#        assert((offsets >= 0).all() and (offsets <= 24).all(),
+#               "Invalid hour offset")
+#    elif self.basis in (r_hour, r_minute):
+#        assert((offsets >= 0).all() and (offsets <= 60).all(),
+#               "Invalid min or sec offset")
+#    elif self.basis == r_second:
+#        assert((offsets >= 0).all() and (offsets <= 999999).all(),
+#               "Invalid microsec offset")
+
+#cdef class Filter:
+#    """
+#    Whether a given timestamp is valid
+#    """
+#    cdef is_valid(Filter self, int64_t ts):
+#        return 1
+
+#cdef class Bday(Filter):
+#    pass
+
+#cdef class Frequency:
+#    """
+#    A frequency is composed of two parts:
+
+#    - resolution: the smallest duration of observation
+#    - filter: observations which are considered valid
+
+#    For two time indexes to be compatible, they must have equivalent
+#    resolution.  This necessitates up/down sampling policies.
+
+#    We also need a conversion policy for the filters. For example, we may
+#    have W@FRI and W@MON filters.  How to reindex?
+#    """
+#    cdef:
+#        time_res res
+#        Filter tfilter
+
+#    def __init__(self, object resolution, Filter tfilter = Filter()):
+
+#        self.res = convert_to_res(resolution)
+
+#        if r_invalid == self.res:
+#            raise ValueError("'%s' not a recognized resolution" % resolution)
+
+#        self.tfilter = tfilter
+
+#    def numticks(Frequency self, Interval ival):
+#        """
+#        Return number of valid ticks within an interval
+#        """
+#        cdef:
+#            Timestamp start, end, tmpts
+#            int64_t tmp, factor, numticks
+#            npy_datetimestruct dts
+
+#        start = ival.start.normalize(self.res)
+#        end = ival.end.normalize(self.res)
+
+#        if end.value < start.value:
+#            tmpts = start
+#            start = end
+#            end   = tmpts
+
+#        tmp = start.value
+#        dts = start.dts
+
+#        factor = 1
+#        numticks = 0
+#        if self.res < r_month:
+#            factor = conversion_factor(r_microsecond, self.res)
+#            while tmp <= end.value:
+#                if self.is_valid_tick(tmp):
+#                    numticks += 1
+#                tmp += factor
+#        else:
+#            if self.res == r_month:
+#                while tmp <= end.value:
+#                    if self.is_valid_tick(tmp):
+#                        numticks += 1
+#                    factor, dts.month = divmod(start.dts.month + 1, 12)
+#                    dts.year += factor
+#                    tmp = PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts)
+#            elif self.res == r_year:
+#                while tmp <= end.value:
+#                    if self.is_valid_tick(tmp):
+#                        numticks += 1
+#                    dts.year += 1
+#                    tmp = PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts)
+
+#        return numticks
+
+#    cdef is_valid_tick(Frequency self, int64_t tick):
+#        return self.tfilter.is_valid(tick)
+
+#    def rollforward(self, Timestamp ts):
+#        pass
+
+#    def rollback(self, Timestamp):
+#        pass
+
+#    def offset(self, Timestamp ts, int nobs):
+#        pass
+
+
 # The following is derived from relativedelta.py in dateutil package
 # ------------------------------------------------------------------------------
 # Copyright (c) 2003-2010  Gustavo Niemeyer <gustavo@niemeyer.net>
@@ -883,5 +1085,3 @@ def monthrange(int64_t year, int64_t month):
 
     return (dayofweek(year, month, 1), days)
 
-
-
diff --git a/pandas/src/np_datetime.h b/pandas/src/np_datetime.h
index 97587aebd..e4533990e 100644
--- a/pandas/src/np_datetime.h
+++ b/pandas/src/np_datetime.h
@@ -15,13 +15,14 @@ int convert_pydatetime_to_datetimestruct(PyObject *obj, npy_datetimestruct *out,
                                          NPY_DATETIMEUNIT *out_bestunit,
                                          int apply_tzinfo);
 
-int is_leapyear(npy_int64 year);
 
 int dayofweek(int y, int m, int d);
 
 // stuff numpy needs in header
 // ----------------------------------------------------------------------------
 
+int is_leapyear(npy_int64 year);
+
 char *_datetime_strings[NPY_DATETIME_NUMUNITS];
 
 int _days_per_month_table[2][12];
diff --git a/pandas/src/timeseries/c_convert.c b/pandas/src/timeseries/c_convert.c
new file mode 100644
index 000000000..e778f421a
--- /dev/null
+++ b/pandas/src/timeseries/c_convert.c
@@ -0,0 +1,749 @@
+#include "c_lib.h"
+#include "c_types.h"
+#include "c_freqs.h"
+#include "c_convert.h"
+
+#include <Python.h>
+// #include <datetime.h>
+#include <time.h>
+
+
+/* ---------------------------------------------------------------------------
+ * Normalization utilities (from Python/datetime.c).
+ */
+
+/* Compute Python divmod(x, y), returning the quotient and storing the
+ * remainder into *r.  The quotient is the floor of x/y, and that's
+ * the real point of this.  C will probably truncate instead (C99
+ * requires truncation; C89 left it implementation-defined).
+ * Simplification:  we *require* that y > 0 here.  That's appropriate
+ * for all the uses made of it.  This simplifies the code and makes
+ * the overflow case impossible (divmod(LONG_MIN, -1) is the only
+ * overflow case).
+ */
+static npy_int64
+divmod(npy_int64 x, npy_int64 y, npy_int64 *r)
+{
+    npy_int64 quo;
+
+    assert(y > 0);
+    quo = x / y;
+    *r = x - quo * y;
+    if (*r < 0) {
+        --quo;
+        *r += y;
+    }
+    assert(0 <= *r && *r < y);
+    return quo;
+}
+/* Modified in order to deal with negative seconds higher than -day
+ */
+static void
+normalize_pair(npy_int64 *hi, npy_int64 *lo, int factor)
+{
+    assert(factor > 0);
+    assert(lo != hi);
+    if (*lo <= -factor || *lo >= factor) {
+        const npy_int64 num_hi = divmod(*lo, factor, lo);
+        const npy_int64 new_hi = *hi + num_hi;
+        assert(! SIGNED_ADD_OVERFLOWED(new_hi, *hi, num_hi));
+        *hi = new_hi;
+    }
+    assert(-factor < *lo && *lo < factor);
+}
+
+
+
+
+/* Return the number of high unit periods per day*/
+npy_int64 highunits_per_day(int freq){
+    switch(freq)
+    {
+        case FR_DAY:
+            return 1;
+        case FR_HR:
+            return 24;
+        case FR_MIN:
+            return 24*60;
+        case FR_SEC:
+            return 24*60*60;
+        default:
+            return 24*60*60 - 1;
+    };
+}
+
+npy_int64 secs_per_highunits(int freq, npy_int64 multiplier)
+{
+    switch(freq)
+    {
+    case FR_SEC:
+        return multiplier;
+    case FR_MIN:
+        return 60 * multiplier;
+    case FR_HR:
+        return 3600 * multiplier;
+    case FR_DAY:
+        return 86400 * multiplier;
+    default:
+        return 0;
+    }
+}
+
+npy_int64 seconds_per_period(int freq, npy_int64 multiplier)
+{
+    switch(freq)
+    {
+        case FR_DAY:
+            return multiplier * 86400;
+        case FR_HR:
+             return multiplier * 3600;
+        case FR_MIN:
+            return multiplier * 60;
+        case FR_SEC:
+             return multiplier;
+    };
+	return -1;
+}
+
+
+
+/* Returns the quarter */
+#define month_to_quarter(month) (((month)-1)/3 + 1)
+#define quarter_to_month(quarter) (((quarter)-1)*3 + 1)
+
+
+
+/*
+    Functions in the following section are borrowed from mx.DateTime version
+    2.0.6, and hence this code is subject to the terms of the egenix public
+    license version 1.0.0
+*/
+
+#define SECONDS_PER_DAY ((double) 86400.0)
+
+
+/* Table with day offsets for each month (0-based, without and with leap) */
+static int month_offset[2][13] = {
+    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
+    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
+};
+
+/* Table of number of days in a month (0-based, without and with leap) */
+static int days_in_month[2][12] = {
+    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
+    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
+};
+
+
+
+/* Return the day of the week for the given absolute date. */
+int day_of_week(npy_int64 absdate) {
+    int day_of_week;
+    if (absdate >= 1) {
+        day_of_week = (absdate - 1) % 7;
+    }
+    else {
+        day_of_week = 6 - ((-absdate) % 7);
+    }
+    return day_of_week;
+}
+
+/* Return the year offset, that is the absolute date of the day
+   31.12.(year-1) in the given calendar.
+
+   Note:
+   For the Julian calendar we shift the absdate (which is measured
+   using the Gregorian Epoch) value by two days because the Epoch
+   (0001-01-01) in the Julian calendar lies 2 days before the Epoch in
+   the Gregorian calendar. */
+npy_int64
+year_offset(npy_int64 year, int calendar)
+{
+    year--;
+    if (calendar == GREGORIAN_CALENDAR) {
+        if (year >= 0 || -1/4 == -1)
+            return year*365 + year/4 - year/100 + year/400;
+        else
+            return year*365 + (year-3)/4 - (year-99)/100 + (year-399)/400;
+    }
+    else if (calendar == JULIAN_CALENDAR) {
+        if (year >= 0 || -1/4 == -1)
+            return year*365 + year/4 - 2;
+        else
+            return year*365 + (year-3)/4 - 2;
+    }
+//    Py_Error(DateCalc_Error, "unknown calendar");
+// onError:
+    return -1;
+}
+
+
+
+/* Set the instance's value using the given date and time. calendar
+   may be set to the flags: GREGORIAN_CALENDAR,
+   JULIAN_CALENDAR to indicate the calendar to be used. */
+
+npy_int64
+days_from_ymdc(int year, int month, int day, int calendar)
+{
+    int leap;
+    npy_int64 yearoffset, absdate;
+
+    /* Range check */
+    Py_AssertWithArg(year > -(INT_MAX / 366) && year < (INT_MAX / 366),
+                     DateCalc_RangeError,
+                     "year out of range: %i",
+                     year);
+
+    /* Is it a leap year ? */
+    leap = is_leapyear(year);
+
+    /* Negative month values indicate months relative to the years end */
+    if (month < 0) month += 13;
+    Py_AssertWithArg(month >= 1 && month <= 12,
+                     DateCalc_RangeError,
+                     "month out of range (1-12): %i",
+                     month);
+
+    /* Negative values indicate days relative to the months end */
+    if (day < 0) day += days_in_month[leap][month - 1] + 1;
+    Py_AssertWithArg(day >= 1 && day <= days_in_month[leap][month - 1],
+                     DateCalc_RangeError,
+                     "day out of range: %i",
+                     day);
+
+    /* Nb of days between Dec. 31 (YYYY - 1) and Dec. 31 1969 */
+    yearoffset = year_offset(year,calendar);
+    if (PyErr_Occurred()) goto onError;
+
+    absdate = day + month_offset[leap][month - 1] + yearoffset;
+    return absdate;
+
+ onError:
+    return -1;
+    /* return 0; That's what numpy uses */
+}
+
+#define days_from_ymd(year, month, day) (days_from_ymdc((year), (month), (day), GREGORIAN_CALENDAR))
+
+
+double
+secs_from_ranged_hms(int hour, int minute, double second)
+{
+    Py_AssertWithArg(hour >= 0 && hour <= 23,
+                     DateCalc_RangeError,
+                     "hour out of range (0-23): %i",
+                     hour);
+    Py_AssertWithArg(minute >= 0 && minute <= 59,
+                     DateCalc_RangeError,
+                     "minute out of range (0-59): %i",
+                     minute);
+    Py_AssertWithArg(second >= (double)0.0 &&
+                     (second < (double)60.0 ||
+                     (hour == 23 && minute == 59 && second < (double)61.0)),
+                     DateCalc_RangeError,
+                     "second out of range (0.0 - <60.0; <61.0 for 23:59): %f",
+                     second);
+    return secs_from_hms(hour, minute, second, 1);
+
+ onError:
+    return -1;
+    /* return 0; (the numpy way) */
+}
+
+
+/* from numpy/datetime.c (reference: 1CE) */
+//static
+ymdstruct
+days_to_ymdstruct(npy_int64 absdate, int calendar)
+{
+    ymdstruct ymd;
+    npy_int64 year;
+    npy_int64 yearoffset;
+    int leap, dayoffset;
+    int month = 1, day = 1;
+    int *monthoffset;
+
+    /* Approximate year */
+    if (calendar == JULIAN_CALENDAR) {
+        year = absdate / 365.25;
+    } else {
+        year = absdate / 365.2425;
+    };
+    if (absdate > 0) year++;
+
+    /* Apply corrections to reach the correct year */
+    while (1) {
+        /* Calculate the year offset */
+        yearoffset = year_offset(year, calendar);
+        /*
+         * Backward correction: absdate must be greater than the
+         * yearoffset
+         */
+        if (yearoffset >= absdate) {
+            year--;
+            continue;
+        }
+        leap = is_leapyear(year);
+
+        dayoffset = absdate - yearoffset;
+        /* Forward correction: non leap years only have 365 days */
+        if (dayoffset > 365 && !leap) {
+            year++;
+            continue;
+        }
+        break;
+    }
+
+    /* Now iterate to find the month */
+    monthoffset = month_offset[leap];
+    for (month = 1; month < 13; month++) {
+        if (monthoffset[month] >= dayoffset)
+            break;
+    }
+    day = dayoffset - month_offset[leap][month-1];
+
+    ymd.year  = year;
+    ymd.month = month;
+    ymd.day   = day;
+    ymd.day_of_year = dayoffset;
+
+    return ymd;
+};
+
+
+static int
+isoweek_from_ymdc(int year, int month, int day, int calendar)
+{
+    int week;
+    npy_int64 yearoffset = year_offset(year, calendar);
+    npy_int64 absdate = days_from_ymdc(year, month, day, calendar);
+    npy_int64 dayofweek = day_of_week(absdate);
+
+    /* Estimate*/
+    week = (absdate - yearoffset - 1) - dayofweek + 3;
+    if (week >= 0)
+        week = week / 7 + 1;
+
+    /* Verify */
+    if (week < 0){
+        /* The day lies in last week of the previous year */
+        if ((week > -2) ||
+            (week == -2 && is_leapyear(year-1)))
+            week = 53;
+        else
+            week = 52;
+    }
+    else if (week == 53) {
+        /* Check if the week belongs to year or year+1 */
+        if (31 - day + dayofweek < 3)
+            week = 1;
+    }
+    return week;
+};
+
+int isoweek_from_datetimestruct(ts_datetimestruct *dinfo)
+{
+	return isoweek_from_ymdc(dinfo->year,
+                             dinfo->month,
+                             dinfo->day,
+                             GREGORIAN_CALENDAR);
+}
+
+
+
+hmsstruct
+seconds_to_hmsstruct(npy_int64 abstime)
+{
+    int hour, minute, second;
+    hmsstruct hms;
+
+    hour   = abstime / 3600;
+    minute = (abstime % 3600) / 60;
+    second = abstime - (hour*3600 + minute*60);
+
+    hms.hour   = hour;
+    hms.min = minute;
+    hms.sec = second;
+
+    return hms;
+};
+
+
+void set_datetimestruct_from_days(ts_datetimestruct *info, npy_int64 days)
+{
+    ymdstruct ymd = days_to_ymdstruct(days, GREGORIAN_CALENDAR);
+    info->year = ymd.year;
+    info->month = ymd.month;
+    info->day = ymd.day;
+    info->day_of_year = ymd.day_of_year;
+}
+
+void set_datetimestruct_from_secs(ts_datetimestruct *info, npy_int64 secs)
+{
+    hmsstruct hms = seconds_to_hmsstruct(secs);
+    info->hour = hms.hour;
+    info->min = hms.min;
+    info->sec = hms.sec;
+}
+
+void set_datetimestruct_from_days_and_secs(ts_datetimestruct *info,
+                                           npy_int64 days,
+                                           npy_int64 secs)
+{
+    set_datetimestruct_from_days(info, days);
+    set_datetimestruct_from_secs(info, secs);
+}
+
+
+
+
+
+/* Helpers for frequency conversion routines */
+#define _days_to_bus_weekday(days) ((((days)/ 7) * 5) + (absdate) % 7)
+
+static long _days_to_bus_weekend_to_monday(long absdate, int day_of_week) 
+{
+    if (day_of_week > 4) {
+        //change to Monday after weekend
+        absdate += (7 - day_of_week);
+    };
+    return _days_to_bus_weekday(absdate);
+};
+
+static long _days_to_bus_weekend_to_friday(long absdate, int day_of_week) 
+{
+    if (day_of_week > 4) {
+        //change to friday before weekend
+        absdate -= (day_of_week - 4);
+    };
+    return _days_to_bus_weekday(absdate);
+};
+
+
+/* --- Conversion routines                                                  */
+
+static npy_int64
+missing_convert(npy_int64 indate, ts_metadata *meta) { return -1;}
+
+static npy_int64
+no_convert(npy_int64 indate, ts_metadata *meta) { return indate;}
+
+
+/* From days to other units ................................................*/
+
+/* Returns the month ending the current annual/quarterly freq */
+int ending_month(ts_metadata *meta)
+{
+    int end = ((meta->unit < FR_MTH) * (meta->period_end_at)) % 12;
+    return (end == 0 ? 12: end);
+}
+/* Returns the day ending the current weekly freq */
+int ending_day(ts_metadata *meta) {
+    return (meta->unit == FR_WK) * (meta->period_end_at);
+}
+
+static npy_int64
+_days_to_years(npy_int64 indate, ts_metadata *meta)
+{
+    ymdstruct ymd = days_to_ymdstruct(indate, GREGORIAN_CALENDAR);
+    int end_month = ending_month(meta);
+    return (ymd.month > end_month ? ymd.year + 1: ymd.year);
+}
+
+static npy_int64
+_days_to_quarters(npy_int64 indate, ts_metadata *meta)
+{
+    ymdstruct ymd = days_to_ymdstruct(indate, GREGORIAN_CALENDAR);
+    int end_month = ending_month(meta);
+    int year = ymd.year;
+    int month = ymd.month;
+    if (end_month != 12){
+        month -= end_month;
+        if (month <= 0)
+            month += 12;
+        else
+            year += 1;
+    }
+    int quarter = month_to_quarter(month);
+    return (year - 1) * 4 + quarter;
+}
+
+static npy_int64
+_days_to_months(npy_int64 indate, ts_metadata *meta)
+{
+    ymdstruct ymd = days_to_ymdstruct(indate, GREGORIAN_CALENDAR);
+    return (ymd.year - 1) * 12 + ymd.month;
+}
+
+static npy_int64
+_days_to_weeks(npy_int64 indate, ts_metadata *meta)
+{
+//    ymdstruct ymd = days_to_ymdstruct(indate, GREGORIAN_CALENDAR);
+    int weekend = ending_day(meta);
+    return (indate - (1 + weekend))/7 + 1;
+}
+
+static npy_int64
+_days_to_bus(npy_int64 indate, ts_metadata *meta)
+{
+    int dayofweek = day_of_week(indate);
+    if (meta->convert_to_start)
+        return _days_to_bus_weekend_to_friday(indate, dayofweek);
+    else
+        return _days_to_bus_weekend_to_monday(indate, dayofweek);
+}
+
+static npy_int64
+_days_to_bus_batch(npy_int64 indate, ts_metadata *meta)
+{
+    int dayofweek = day_of_week(indate);
+    if (dayofweek > 4)
+        return -1;
+    else if (meta->convert_to_start)
+        return _days_to_bus_weekend_to_friday(indate, dayofweek);
+    else
+        return _days_to_bus_weekend_to_monday(indate, dayofweek);
+};
+
+
+static npy_int64
+_days_to_days(npy_int64 indate, ts_metadata *meta)
+{
+    return indate;
+}
+
+static npy_int64
+_days_to_highfreq(npy_int64 indate, ts_metadata *meta)
+{
+npy_int64 periods_per_day = meta->periods_per_day;
+    if (meta->convert_to_start)
+        return (indate - HIGHFREQ_ORIG) * periods_per_day;
+    else
+        return (indate - HIGHFREQ_ORIG + 1) * periods_per_day - 1;
+}
+
+conversion_function get_converter_from_days(int fromunit, int inbatch)
+{
+    int ubase = get_base_unit(fromunit);
+    
+    if (ubase == FR_ANN)
+        return &_days_to_years;
+    else if (ubase == FR_QTR)
+        return &_days_to_quarters;
+    else if (ubase == FR_MTH)
+        return &_days_to_months;
+    else if (ubase == FR_WK)
+        return &_days_to_weeks;
+    else if (ubase == FR_BUS)
+        if (inbatch)
+            return &_days_to_bus_batch;
+        else
+            return &_days_to_bus;
+    else if ((ubase == FR_DAY) || (ubase == FR_UND))
+        return &_days_to_days;
+    else if (ubase > FR_DAY)
+        return &_days_to_highfreq;
+    return &missing_convert;
+}
+
+
+
+
+static npy_int64
+_days_from_years(npy_int64 indate, ts_metadata *meta)
+{
+    npy_int64 absdate, year;
+    int final_adj;
+    int end_month = ending_month(meta);
+    int month = end_month % 12;
+    month = (month == 0 ? 1 : month+1);
+
+    if (meta->convert_to_start){
+        year = (end_month == 12 ? indate: indate-1);
+        final_adj = 0;
+    }
+    else {
+        year = (end_month == 12 ? indate+1: indate);
+        final_adj = -1;
+    }
+    absdate = days_from_ymd(year, month, 1);
+    if (absdate  == INT_ERR_CODE)
+        return INT_ERR_CODE;
+    return absdate + final_adj;
+}
+
+static npy_int64
+_days_from_quarters(npy_int64 indate, ts_metadata *meta)
+{
+    npy_int64 absdate;
+    int year, month, final_adj;
+    int end_month = ending_month(meta);
+
+    if (meta->convert_to_start) {
+        year = (indate - 1)/4 + 1;
+        month = (indate + 4)*3 - 12*year -2;
+        final_adj = 0;
+    }
+    else {
+        year = indate/4 + 1;
+        month = (indate + 5)*3 - 12*year -2;
+        final_adj = -1;
+    };
+    if (end_month != 12){
+        month += end_month;
+        if (month > 12)
+            month -= 12;
+        else
+            year -= 1;
+    }
+    absdate = days_from_ymd(year, month, 1);
+    if (absdate  == INT_ERR_CODE) return INT_ERR_CODE;
+    return absdate + final_adj;
+}
+
+static npy_int64
+_days_from_months(npy_int64 indate, ts_metadata *meta)
+{
+    npy_int64 absdate;
+    int year, month, final_adj;
+
+    if (meta->convert_to_start){
+        year = (indate - 1)/12 + 1;
+        month = indate - 12*year - 1;
+        final_adj = 0;
+    }
+    else {
+        year = indate/12 + 1;
+        month = indate - 12*year;
+        final_adj = -1;
+    }
+    absdate = days_from_ymd(year, month, 1);
+    if (absdate  == INT_ERR_CODE) return INT_ERR_CODE;
+    return absdate + final_adj;
+}
+
+
+static npy_int64
+_days_from_weeks(npy_int64 indate, ts_metadata *meta)
+{
+    int weekend = meta->period_end_at;
+    if (meta->convert_to_start)
+        return indate*7 - 6 + weekend;
+    else
+        return indate*7 + weekend;
+}
+
+static npy_int64
+_days_from_busdays(npy_int64 indate, ts_metadata *meta)
+{
+    return ((indate-1)/5)*7 + (indate-1)%5 + 1;
+}
+
+npy_int64
+_days_from_highfreq(npy_int64 indate, ts_metadata *meta)
+{
+    npy_int64 periods_per_day = meta->periods_per_day;
+    if (indate < 0)
+        return (indate + 1)/periods_per_day + HIGHFREQ_ORIG - 1;
+    else
+        return indate/periods_per_day + HIGHFREQ_ORIG;
+}
+
+conversion_function get_converter_to_days(int fromunit, int inbatch)
+{
+//    int ubase = get_base_unit(fromunit);
+    if (fromunit == FR_ANN)
+        return &_days_from_years;
+    else if (fromunit == FR_QTR)
+        return &_days_from_quarters;
+    else if (fromunit == FR_MTH)
+        return &_days_from_months;
+    else if (fromunit == FR_WK)
+        return &_days_from_weeks;
+    else if (fromunit == FR_BUS)
+        return &_days_from_busdays;
+    else if ((fromunit == FR_DAY) || (fromunit == FR_UND))
+        return &no_convert;
+    else if (fromunit > FR_DAY)
+        return &_days_from_highfreq;
+    return &missing_convert;
+}
+
+
+
+
+/* From seconds */
+
+npy_int64
+_secs_from_highfreq(npy_int64 indate, ts_metadata *meta)
+{
+    npy_int64 secs_per_period = meta->secs_per_period;
+    if (meta->convert_to_start)
+        return indate*secs_per_period;
+    else
+        return (indate + 1)*secs_per_period - 1;
+}
+
+npy_int64
+_secs_from_midnight(npy_int64 indate, int unit)
+{
+    npy_int64 secs, secs_per_period;
+    unit = (unit/1000)*1000;
+    if (unit > FR_DAY)
+        secs_per_period = secs_per_highunits(unit, 1);
+    else
+        secs_per_period = 0;
+    secs=(indate * secs_per_period) % 86400;
+    if (secs < 0)
+        secs += 86400;
+    return secs;
+}
+
+npy_int64
+_secs_to_highfreq(npy_int64 indate, ts_metadata *meta)
+{
+    npy_int64 secs_per_period = meta->secs_per_period;
+    if (indate < 0)
+        return (indate + 1)/secs_per_period - 1;
+    else
+        return indate/secs_per_period;
+}
+
+
+
+conversion_function convert_to_mediator(int fromunit, int tounit, int inbatch)
+{
+    if ((fromunit > FR_DAY) && (tounit > FR_DAY))
+        return &_secs_from_highfreq;
+    else
+        return *get_converter_to_days(fromunit, inbatch);
+}
+
+conversion_function convert_from_mediator(int fromunit, int tounit, int inbatch)
+{
+    if ((tounit == FR_DAY) || (tounit == FR_UND))
+        return &no_convert;
+    else if (tounit > FR_DAY)
+        if (fromunit <= FR_DAY)
+            return *get_converter_from_days(tounit, 0);
+        else
+            return &_secs_to_highfreq;
+    else
+        return *get_converter_from_days(tounit, 0);
+}
+
+
+
+void normalize_days_secs(npy_int64 *d, npy_int64 *s)
+{
+    if (*s <= -86400 || *s >= 86400)
+        normalize_pair(d, s, 86400);
+}
+void normalize_years_months(npy_int64 *y, npy_int64 *m)
+{
+    normalize_pair(y, m, 12);
+    m += 1;
+}
+
+
diff --git a/pandas/src/timeseries/c_datearray.c b/pandas/src/timeseries/c_datearray.c
new file mode 100644
index 000000000..e4cf50e92
--- /dev/null
+++ b/pandas/src/timeseries/c_datearray.c
@@ -0,0 +1,1462 @@
+#include "c_freqs.h"
+#include "c_convert.h"
+#include "c_dates.h"
+#include "c_datearray.h"
+#include <datetime.h>
+#include <time.h>
+
+#include "c_lib.h"
+
+
+static PyTypeObject DatetimeArray_Type;
+
+int PyArray_TS_DATETIME;
+
+#define TS_METADATA_DTSTR "timeunit"
+
+typedef struct {
+   PyObject_HEAD;
+   ts_datetime obval;
+   ts_metadata obmeta;
+} DatetimeScalarObject;
+
+//NPY_NO_EXPORT PyTypeObject DatetimeArrType_Type = {
+//#if defined(NPY_PY3K)
+//    PyVarObject_HEAD_INIT(NULL, 0)
+//#else
+//    PyObject_HEAD_INIT(NULL)
+//    0,                                          /* ob_size */
+//#endif
+////    "timeseries.datetime" _THIS_SIZE,                  /* tp_name*/
+//    "timeseries.datetime",                  /* tp_name*/
+//    sizeof(DatetimeScalarObject),               /* tp_basicsize*/
+//    0,                                          /* tp_itemsize */
+//    0,                                          /* tp_dealloc */
+//    0,                                          /* tp_print */
+//    0,                                          /* tp_getattr */
+//    0,                                          /* tp_setattr */
+//#if defined(NPY_PY3K)
+//    0,                                          /* tp_reserved */
+//#else
+//    0,                                          /* tp_compare */
+//#endif
+//    0,                                          /* tp_repr */
+//    0,                                          /* tp_as_number */
+//    0,                                          /* tp_as_sequence */
+//    0,                                          /* tp_as_mapping */
+//    0,                                          /* tp_hash */
+//    0,                                          /* tp_call */
+//    0,                                          /* tp_str */
+//    0,                                          /* tp_getattro */
+//    0,                                          /* tp_setattro */
+//    0,                                          /* tp_as_buffer */
+//    0,                                          /* tp_flags */
+//    0,                                          /* tp_doc */
+//    0,                                          /* tp_traverse */
+//    0,                                          /* tp_clear */
+//    0,                                          /* tp_richcompare */
+//    0,                                          /* tp_weaklistoffset */
+//    0,                                          /* tp_iter */
+//    0,                                          /* tp_iternext */
+//    0,                                          /* tp_methods */
+//    0,                                          /* tp_members */
+//    0,                                          /* tp_getset */
+//    0,                                          /* tp_base */
+//    0,                                          /* tp_dict */
+//    0,                                          /* tp_descr_get */
+//    0,                                          /* tp_descr_set */
+//    0,                                          /* tp_dictoffset */
+//    0,                                          /* tp_init */
+//    0,                                          /* tp_alloc */
+//    0,                                          /* tp_new */
+//    0,                                          /* tp_free */
+//    0,                                          /* tp_is_gc */
+//    0,                                          /* tp_bases */
+//    0,                                          /* tp_mro */
+//    0,                                          /* tp_cache */
+//    0,                                          /* tp_subclasses */
+//    0,                                          /* tp_weaklist */
+//    0,                                          /* tp_del */
+//#if PY_VERSION_HEX >= 0x02060000
+//    0,                                          /* tp_version_tag */
+//#endif
+//};
+//
+//#undef _THIS_SIZE
+///**/
+
+
+
+
+#if PY_VERSION_HEX >= 0x02070000
+#define get_metadata_from_descr(descr)  \
+    ((descr->metadata == NULL) ? \
+     NULL :                                       \
+    ((ts_metadata *)(PyCapsule_GetPointer(                   \
+                     PyDict_GetItemString(descr->metadata, TS_METADATA_DTSTR), \
+                     NULL))))
+#else
+#define get_metadata_from_descr(descr)  \
+    ((descr->metadata == NULL) ? \
+     NULL :                                       \
+     ((ts_metadata *)(PyCObject_AsVoidPtr(                    \
+                      PyDict_GetItemString(descr->metadata, TS_METADATA_DTSTR)))))
+#endif
+
+#define asarray(self) ( ((PyArrayObject *)self) )
+#define get_base(self) ( ((PyArrayObject *)self)->base )
+#define asndarray(self) ( asarray(get_base(self)) )
+#define get_descr(self) ( ((PyArrayObject *)self)->descr )
+#define get_metadata_from_array(self) (get_metadata_from_descr(get_descr(self)))
+//#define get_timestep(self) (get_metadata_from_array(self)->timestep)
+
+
+#define TS_METADATA_DTSTR "timeunit"
+
+//----------------------------------------------------------------------------
+/* from private/npy_3kcompat.h */
+#if PY_VERSION_HEX >= 0x02070000
+
+static NPY_INLINE PyObject *
+NpyCapsule_FromVoidPtr(void *ptr, void (*dtor)(PyObject *))
+{
+    PyObject *ret = PyCapsule_New(ptr, NULL, dtor);
+    if (ret == NULL) {
+        PyErr_Clear();
+    }
+    return ret;
+}
+
+static void
+simple_capsule_dtor(PyObject *cap)
+{
+    PyArray_free(PyCapsule_GetPointer(cap, NULL));
+}
+
+#else
+
+static NPY_INLINE PyObject *
+NpyCapsule_FromVoidPtr(void *ptr, void (*dtor)(void *))
+{
+    return PyCObject_FromVoidPtr(ptr, dtor);
+}
+
+static void
+simple_capsule_dtor(void *ptr)
+{
+    PyArray_free(ptr);
+}
+
+#endif
+/**/
+
+
+#include "numpy/noprefix.h"
+
+static void
+init_descr_metadata(PyArray_Descr *descr)
+{
+    ts_metadata *dt_data;
+    PyObject *cobj;
+
+    dt_data = _pya_malloc(sizeof(ts_metadata));
+    dt_data->unit = FR_UND;
+    dt_data->timestep = 1;
+    dt_data->period_end_at = 0;
+    dt_data->periods_per_day = -1;
+    dt_data->secs_per_period = -1;
+    dt_data->convert_to_start = 0;
+
+/* FIXME
+ * There is no error check here and no way to indicate an error
+ * until the metadata turns up NULL.
+ */
+    cobj = NpyCapsule_FromVoidPtr((void *)dt_data, simple_capsule_dtor);
+    descr->metadata = PyDict_New();
+    PyDict_SetItemString(descr->metadata, TS_METADATA_DTSTR, cobj);
+    Py_DECREF(cobj);
+
+}
+
+static void
+update_descr_metadata(PyArray_Descr *descr, ts_metadata *meta) {
+    PyObject *cobj;
+    cobj = NpyCapsule_FromVoidPtr((void *)meta, simple_capsule_dtor);
+    descr->metadata = PyDict_New();
+    PyDict_SetItemString(descr->metadata, TS_METADATA_DTSTR, cobj);
+    Py_DECREF(cobj);
+}
+
+
+//-----------------------------------------------------------------------------
+
+static PyObject *
+DatetimeArray_new(PyTypeObject *cls, PyObject *args, PyObject *kw)
+{
+    static char *kwlist[] = {"object", "unit", "timestep", "freq", NULL};
+
+    PyObject *obj;
+    PyArrayObject *arr = NULL;
+    PyObject *unit = NULL, *freq=NULL;
+    int timestep = 1;
+    DatetimeArrayObject *self;
+    PyArray_Descr *descr;
+
+    if(!PyArg_ParseTupleAndKeywords(args, kw,"O|OiO",kwlist,
+                                    &obj,
+                                    &unit, &timestep, &freq))
+        return NULL;
+
+    arr = (PyArrayObject *)PyArray_FROM_O(obj);
+    if(arr == NULL)
+        return NULL;
+//    DEBUGPRINTF("We have an array...");
+
+    descr = PyArray_DescrNewFromType(PyArray_INT64);
+    if (descr == NULL)
+        return NULL;
+    Py_INCREF(descr);
+    init_descr_metadata(descr);
+
+    self = (DatetimeArrayObject *)PyArray_NewFromDescr(&DatetimeArray_Type,
+                                                       descr,
+                                                       arr->nd, arr->dimensions,
+                                                       arr->strides,
+                                                       arr->data,
+                                                       arr->flags,
+                                                       (PyObject *)arr);
+    if(self == NULL)
+        return NULL;
+    Py_INCREF(arr);
+    PyArray_BASE(self) = (PyObject *)arr;
+
+    if (PyObject_SetAttrString((PyObject *)self, "dtype", (PyObject *)descr) < 0) {
+        goto fail;
+    }
+
+    ts_metadata *obmeta = get_metadata_from_descr(descr);
+
+    if (unit == NULL){
+        if (freq == NULL)
+            freq = PyInt_FromLong(FR_UND);
+        unit = freq;
+    }
+    int u = check_freq(unit);
+    if (u == -1)
+        goto fail;
+    init_metadata_from_unit(obmeta, u);
+
+    obmeta->timestep = timestep;
+
+    return (PyObject *)self;
+
+ fail:
+    DEBUGPRINTF("Dropping it..");
+    Py_XDECREF(unit);
+    Py_XDECREF((PyObject*)self);
+    return NULL;
+}
+
+static DatetimeArrayObject *
+DatetimeArray_new_from_array_and_unit(PyArrayObject *data, int unit)
+{
+    DatetimeArrayObject *self;
+    PyArray_Descr *descr;
+    ts_metadata *obmeta;
+
+    descr = PyArray_DescrNewFromType(PyArray_INT64);
+    if (descr == NULL)
+        return NULL;
+    Py_INCREF(descr);
+    init_descr_metadata(descr);
+    obmeta = get_metadata_from_descr(descr);
+    init_metadata_from_unit(obmeta, unit);
+
+    self = (DatetimeArrayObject *)PyArray_NewFromDescr(&DatetimeArray_Type,
+                                                       descr,
+                                                       data->nd,
+                                                       data->dimensions,
+                                                       data->strides,
+                                                       data->data,
+                                                       data->flags,
+                                                       (PyObject *)data);
+    Py_INCREF(data);
+    PyArray_BASE(self) = (PyObject *)data;
+    return self;
+}
+
+static void
+DatetimeArray_dealloc(DatetimeArrayObject *self)
+{
+//    DEBUGPRINTF("Dropping cache");
+//    Py_XDECREF(self->cached_vals);
+    DEBUGPRINTF("Dropping object");
+    self->base.ob_type->tp_free((PyObject*)self);
+}
+
+static PyObject*
+DatetimeArray_finalize(DatetimeArrayObject *self, PyObject *args)
+{
+    DatetimeArrayObject *context;
+    if(PyArg_ParseTuple(args, "O", &context))
+    {
+        if (DatetimeArray_Check(context)){
+            DEBUGPRINTF("in context from DTA");
+            PyArray_Descr *descr = get_descr(self);
+            Py_INCREF(descr);
+            ts_metadata *meta_context = get_metadata_from_array(context);
+            update_descr_metadata(descr, meta_context);
+        } else {
+            DEBUGPRINTF("in context from scratch");
+            init_descr_metadata(get_descr(self));
+        };
+        ts_timestatus default_status = {-1, -1, -1};
+        self->status = default_status;
+    }
+    PyErr_Clear();
+    DEBUGPRINTF("Returning w/ base unit %i...", get_metadata_from_array(self)->unit);
+    Py_RETURN_NONE;
+}
+
+
+
+static int
+_get_unit_from_descr(PyArray_Descr *descr) {
+    ts_metadata *meta = get_metadata_from_descr(descr);
+    return meta->unit + meta->period_end_at;
+}
+static int
+_get_unit_from_array(DatetimeArrayObject *self) {
+    ts_metadata *meta = get_metadata_from_descr(((PyArrayObject *)self)->descr);
+    return meta->unit + meta->period_end_at;
+}
+static PyObject *
+DatetimeArray_unit(DatetimeArrayObject *self){
+    int unit = _get_unit_from_array(self);
+    return PyInt_FromLong(unit);
+}
+static PyObject *
+DatetimeArray_timestep(DatetimeArrayObject *self){
+    ts_metadata *meta = get_metadata_from_descr(((PyArrayObject *)self)->descr);
+    return PyInt_FromLong(meta->timestep);
+}
+static PyObject *
+DatetimeArray_freqstr(DatetimeArrayObject *self) {
+    PyObject *key = DatetimeArray_unit(self);
+    PyObject *freq_aliases = PyDict_GetItem(freq_dict, key);
+    PyObject *main_alias = PyTuple_GET_ITEM(freq_aliases, 0);
+    Py_DECREF(key);
+    return main_alias;
+}
+
+static PyObject *
+DatetimeArray_steps(DatetimeArrayObject *self){
+    PyArrayObject *steps=NULL;
+    PyArrayIterObject *self_iter=NULL, *steps_iter=NULL;
+    npy_intp size = PyArray_SIZE(self) - 1;
+
+    steps = (PyArrayObject*)PyArray_ZEROS(1,
+                                          &size,
+                                          PyArray_INT64, 0);
+    if (steps == NULL)
+        goto fail;
+
+    steps_iter = (PyArrayIterObject *)PyArray_IterNew((PyObject *)steps);
+    if (steps_iter == NULL)
+        goto fail;
+    self_iter = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
+    if (self_iter == NULL)
+        goto fail;
+
+    PyObject *val=NULL, *prev=NULL, *diff=NULL;
+    prev = PyArray_GETITEM(self, self_iter->dataptr);
+    PyArray_ITER_NEXT(self_iter);
+    while (steps_iter->index < steps_iter->size) {
+        val = PyArray_GETITEM(self, self_iter->dataptr);
+        diff = PyNumber_Subtract(val, prev);
+        PyArray_SETITEM(steps, steps_iter->dataptr, diff);
+        PyArray_ITER_NEXT(self_iter);
+        PyArray_ITER_NEXT(steps_iter);
+        prev = val;
+    };
+    Py_DECREF(self_iter);
+    Py_DECREF(steps_iter);
+    Py_XDECREF(prev);
+    Py_XDECREF(val);
+    Py_XDECREF(diff);
+    return (PyObject *)steps;
+
+ fail:
+    DEBUGPRINTF("DatetimeArray.steps: Oops...");
+    Py_XDECREF(steps);
+    Py_XDECREF(steps_iter);
+    Py_XDECREF(self_iter);
+    return NULL;
+}
+
+
+
+static int
+DatetimeArray_check_status(DatetimeArrayObject *self)
+{
+    PyArrayIterObject *self_iter=NULL;
+    npy_int64 timestep, diff;
+    int is_chrono = 1, has_dups=0, has_missing=0;
+
+    timestep = get_metadata_from_array(self)->timestep;
+    self_iter = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
+    if (self_iter == NULL) {
+        Py_XDECREF(self_iter);
+        return -1;
+    }
+
+    PyObject *val=NULL, *prev=NULL, *odiff=NULL;
+    prev = PyArray_GETITEM(self, self_iter->dataptr);
+    PyArray_ITER_NEXT(self_iter);
+    while (self_iter->index < self_iter->size) {
+        val = PyArray_GETITEM(self, self_iter->dataptr);
+        odiff = PyNumber_Subtract(val, prev);
+        diff = PyInt_AsLong(odiff);
+        if (diff < 0)
+            is_chrono = 0;
+        else if (diff == 0)
+            has_dups = 1;
+        else if (diff > timestep)
+            has_missing = 1;
+        if (has_dups && has_missing)
+            break;
+        PyArray_ITER_NEXT(self_iter);
+        prev = val;
+    }
+    Py_XDECREF(self_iter);
+    Py_XDECREF(odiff);
+    Py_XDECREF(prev);
+    Py_XDECREF(val);
+    // Set the status
+//    self->status.has_dups = has_dups;
+//    self->status.has_missing = has_missing;
+//    self->status.is_chrono = is_chrono;
+    ts_timestatus status = {has_dups, has_missing, is_chrono};
+    self->status = status;
+    return 0;
+}
+static PyObject *
+DatetimeArray_has_dups(DatetimeArrayObject *self)
+{
+    if (self->status.has_dups == -1)
+        if (DatetimeArray_check_status(self) < 0)
+            return NULL;
+    if (self->status.has_dups == 0)
+        Py_RETURN_FALSE;
+    Py_RETURN_TRUE;
+}
+static PyObject *
+DatetimeArray_has_missing(DatetimeArrayObject *self)
+{
+    if (self->status.has_missing == -1)
+        if (DatetimeArray_check_status(self) < 0)
+            return NULL;
+    if (self->status.has_missing == 0)
+        Py_RETURN_FALSE;
+    Py_RETURN_TRUE;
+}
+static PyObject *
+DatetimeArray_is_chrono(DatetimeArrayObject *self)
+{
+    if (self->status.is_chrono == -1)
+        if (DatetimeArray_check_status(self) < 0)
+            return NULL;
+    if (self->status.is_chrono == 0)
+        Py_RETURN_FALSE;
+    Py_RETURN_TRUE;
+}
+static PyObject *
+DatetimeArray_is_full(DatetimeArrayObject *self)
+{
+    if (self->status.has_dups == -1)
+        if (DatetimeArray_check_status(self) < 0)
+            return NULL;
+    if (self->status.has_dups)
+        Py_RETURN_FALSE;
+    if (self->status.has_missing)
+        Py_RETURN_FALSE;
+    Py_RETURN_TRUE;
+}
+static PyObject *
+DatetimeArray_is_valid(DatetimeArrayObject *self)
+{
+    ts_timestatus status = self->status;
+    if (status.has_dups == -1)
+        if (DatetimeArray_check_status(self) < 0)
+            return NULL;
+    if (status.has_missing)
+        Py_RETURN_FALSE;
+    if (status.has_dups)
+        Py_RETURN_FALSE;
+    if (! status.is_chrono)
+        Py_RETURN_FALSE;
+    Py_RETURN_TRUE;
+}
+
+static PyMemberDef DatetimeArray_members[] = {
+//     {"cached_vals", T_OBJECT_EX, offsetof(DateTimeArray, cached_vals), 0,
+//      "cached_values"},
+    {NULL}  /* Sentinel */
+};
+
+
+static char *
+DEBUGGETTYPE(PyObject *obj){
+    char *type_str;
+    PyObject *type_repr, *obj_type;
+    obj_type = PyObject_Type(obj);
+    type_repr = PyObject_Repr(obj_type);
+    type_str = PyString_AsString(type_repr);
+//    DEBUGPRINTF("get_tsdatetime_from_object got %s [%i]", type_str, meta->unit);
+    Py_DECREF(obj_type);
+    Py_DECREF(type_repr);
+    return type_str;
+}
+
+
+static ts_datetime
+get_tsdatetime_from_object(ts_metadata *meta, PyObject *date){
+    ts_datetime value;
+    //
+    if (PyString_Check(date)) {
+        value = PyString_to_tsdatetime(meta, date);
+//        DEBUGPRINTF("get_tsdatetime_from_object.from string: %ld", value);
+    }
+    else if (PyDateTime_Check(date) || PyDate_Check(date)) {
+        value = PyDatetime_to_tsdatetime(meta, date);
+//        DEBUGPRINTF("get_tsdatetime_from_object.from datetime.datetime: %ld", value);
+    }
+    else if (DatetimeObject_Check(date)) {
+        value = ((DatetimeObject *)date)->obval;
+//        DEBUGPRINTF("get_tsdatetime_from_object.from tsdatetime: %ld", value);
+    }
+    else if (PyInt_Check(date) || PyLong_Check(date) || PyFloat_Check(date)) {
+        value = (ts_datetime)PyInt_AsLong(date);
+//        DEBUGPRINTF("get_tsdatetime_from_object.from number: %ld", value);
+    }
+    else {
+        value = -1;
+    }
+    return value;
+}
+
+
+
+static PyObject *
+DatetimeArray_single_date_to_index(DatetimeArrayObject *self, PyObject *date){
+    intp count=0, i, size;
+    int nd = ((PyArrayObject *)self)->nd, j, comparison;
+
+    PyArrayIterObject *itr = NULL;
+    PyObject *result = NULL, *item;
+    intp *dptr[MAX_DIMS];
+
+    itr = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
+    if (itr == NULL)
+        return NULL;
+
+    ts_metadata *meta = get_metadata_from_array(self);
+    ts_datetime value = get_tsdatetime_from_object(meta, date);
+    if (value < 0) {
+        goto fail;
+    }
+
+    PyArray_CompareFunc *cmprf = ((PyArrayObject *)self)->descr->f->compare;
+
+    /*Count the valid elements*/
+    size = itr->size;
+    for (i = 0; i < size; i++) {
+        comparison = cmprf(itr->dataptr, &value, self);
+        if (comparison == 0)
+            count++;
+        PyArray_ITER_NEXT(itr);
+    }
+
+    PyArray_ITER_RESET(itr);
+    result = PyTuple_New(nd);
+    if (result == NULL)
+        goto fail;
+    for (j = 0; j < nd; j++) {
+        item = PyArray_New(Py_TYPE(self), 1, &count,
+                           PyArray_INTP, NULL, NULL, 0, 0,
+                           (PyObject *)self);
+        if (item == NULL)
+            goto fail;
+        PyTuple_SET_ITEM(result, j, item);
+        dptr[j] = (intp *)PyArray_DATA(item);
+    }
+    if (nd == 1) {
+        for (i = 0; i < size; i++){
+            comparison = cmprf(itr->dataptr, &value, self);
+            if (comparison == 0)
+                *(dptr[0])++ = i;
+            PyArray_ITER_NEXT(itr);
+        }
+    }
+    else {
+        itr->contiguous = 0;
+        for (i = 0; i < size; i++){
+            comparison = cmprf(itr->dataptr, &value, self);
+            if (comparison == 0) {
+                for (j = 0; j < nd; j++)
+                    *(dptr[j])++ = itr->coordinates[j];
+            }
+            PyArray_ITER_NEXT(itr);
+        }
+    }
+    Py_DECREF(itr);
+    return result;
+ fail:
+    Py_XDECREF(result);
+    Py_XDECREF(itr);
+    return NULL;
+}
+
+
+
+static PyObject *
+DatetimeArray_date_to_index(DatetimeArrayObject *self, PyObject *dateargs){
+    PyObject *result=NULL, *date=NULL;
+    ts_datetime value;
+    Py_ssize_t i;
+
+    /* Make sure we have at least 1 argument */
+    Py_ssize_t nbargs = PyObject_Length(dateargs);
+    if (nbargs < 1) {
+        PyErr_SetString(PyExc_ValueError, "there should be at least one argument");
+        goto fail;
+    }
+
+    ts_metadata *meta = get_metadata_from_array(self);
+//    ts_timestatus status = self->status;
+//    int is_valid = ((! status.has_missing) && (! status.has_dups) && (status.is_chrono));
+
+    result = PyList_New(0);
+    if (result == NULL)
+        goto fail;
+
+    PyArrayIterObject *itr = NULL;
+    PyObject *indexlist = NULL;
+    int comparison, empty;
+
+    for (i=0; i < nbargs; i++){
+        date = PyTuple_GetItem(dateargs, i);
+        value = get_tsdatetime_from_object(meta, date);
+        if (value < 0) {
+            PyErr_SetString(PyExc_ValueError, "unable to retrieve date");
+            Py_XDECREF(itr);
+            Py_XDECREF(indexlist);
+            goto fail;
+        }
+
+        indexlist = PyList_New(0);
+        if (indexlist == NULL) {
+            Py_XDECREF(itr);
+            Py_XDECREF(indexlist);
+            goto fail;
+        }
+        itr = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
+        if (itr == NULL) {
+            Py_XDECREF(itr);
+            Py_XDECREF(indexlist);
+            goto fail;
+        }
+        PyArray_CompareFunc *cmprf = ((PyArrayObject *)self)->descr->f->compare;
+        while (itr->index < itr->size) {
+            comparison = cmprf(itr->dataptr, &value, self);
+            if (comparison == 0) {
+                PyObject *coords = PyObject_GetAttrString((PyObject *)itr, "coords");
+                PyList_Append(indexlist, coords);
+                empty = 0;
+            }
+            PyArray_ITER_NEXT(itr);
+        };
+        if (empty) {
+            indexlist = Py_None;
+        };
+        PyList_Append(result, indexlist);
+    };
+    Py_DECREF(itr);
+    Py_DECREF(indexlist);
+
+    if (nbargs == 1)
+        return PyList_GetItem(result, 0);
+    return result;
+
+ fail:
+    Py_XDECREF(result);
+    Py_XDECREF(date);
+    return NULL;
+}
+
+
+
+
+
+static PyObject *
+DatetimeArray_getitem(DatetimeArrayObject *self, PyObject *op)
+{
+//    int reset_full=1, keep_chrono=0;
+//    DEBUGPRINTF("in __getitem__ w %s", DEBUGGETTYPE(op));
+    PyObject *idx;
+
+    if (DatetimeObject_Check(op) || PyString_Check(op) || PyDateTime_Check(op)) {
+        if (DatetimeObject_Check(op)) {
+            DEBUGPRINTF("index is Date");
+        }
+        else if (PyString_Check(op)) {
+            DEBUGPRINTF("index is string");
+        }
+        else if (PyDateTime_Check(op)) {
+            DEBUGPRINTF("index is datetime");
+        };
+        idx = DatetimeArray_single_date_to_index(self, op);
+        if (idx == NULL) {
+            PyErr_SetString(PyExc_IndexError, "date out of bounds");
+            return NULL;
+        }
+    }
+    else {
+        idx = op;
+    }
+
+    PyObject *r, *result;
+    r = ((PyArrayObject *)self)->ob_type->tp_base->tp_as_mapping->mp_subscript((PyObject *)self, idx);
+    if (r == NULL) {
+        return NULL;
+    }
+//    DEBUGPRINTF("r is %s", DEBUGGETTYPE(r));
+    ts_datetime obval;
+    if (PyArray_IsScalar(r, Integer)) {
+        int unit = _get_unit_from_descr(get_descr(self));
+
+        obval = (ts_datetime)(PyInt_AsLong(r));
+        result = (PyObject *)DatetimeObject_FromFreqAndValue(unit, PyInt_AsLong(r));
+        Py_DECREF(r);
+    }
+    else {
+        result = r;
+        ((DatetimeArrayObject *)r)->status.is_chrono = self->status.is_chrono;
+    }
+    Py_DECREF(idx);
+    return result;
+}
+
+
+
+NPY_NO_EXPORT PyMappingMethods DatetimeArray_as_mapping = {
+    NULL,              /*mp_length*/
+    (binaryfunc)&DatetimeArray_getitem,        /*mp_subscript*/
+    NULL, /*mp_ass_subscript*/
+};
+
+
+
+
+
+/* Date & Time Information */
+PyObject *
+DatetimeArray_getdateinfo(DatetimeArrayObject *self, char *infochar)
+{
+    int skip_periods, counter=1, val_changed=0;
+
+    PyObject *prev_val=NULL;
+    PyArrayObject *output=NULL;
+    PyArrayIterObject *iterin=NULL, *iterout=NULL;
+
+
+    ts_metadata *meta = get_metadata_from_array(self);
+    int unit = meta->unit;
+    ts_timestatus status = self->status;
+    int is_valid = ((! status.has_missing) && (! status.has_dups) && (status.is_chrono));
+
+    output = (PyArrayObject *)PyArray_SimpleNew(((PyArrayObject *)self)->nd,
+                                                 ((PyArrayObject *)self)->dimensions,
+                                                 NPY_INT);
+
+
+    conversion_function todays = get_converter_to_days(unit, 1);
+    init_metadata_from_unit(meta, unit);
+    meta->convert_to_start = 0;
+    ts_datetimestruct dinfo;
+
+
+    iterin = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
+    iterout = (PyArrayIterObject *)PyArray_IterNew((PyObject *)output);
+
+    PyObject* (*getdateparam)(npy_int64, int,
+                              conversion_function, ts_metadata*,
+                              ts_datetimestruct*) = NULL;
+    switch(*infochar)
+    {
+        case 'Y': //year
+            getdateparam = &_loop_get_year;
+            skip_periods = __skip_periods_year(unit);
+            break;
+        case 'F': //"fiscal" year
+            if (unit == FR_QTR)
+                getdateparam = &_loop_get_qyear_from_qtr;
+            else
+                getdateparam = &_loop_get_qyear;
+            skip_periods = __skip_periods_year(unit);
+            break;
+        case 'Q': //quarter
+            if (unit == FR_QTR)
+                getdateparam = &_loop_get_quarter_from_qtr;
+            else
+                getdateparam = &_loop_get_quarter;
+            skip_periods = __skip_periods_quarter(unit);
+            break;
+        case 'M': //month
+            getdateparam = &_loop_get_month;
+            skip_periods = __skip_periods_month(unit);
+            break;
+        case 'D': //day
+            getdateparam = &_loop_get_day;
+            skip_periods = __skip_periods_day(unit);
+            break;
+        case 'R': //day of year
+            getdateparam = &_loop_get_day_of_year;
+            skip_periods = __skip_periods_day(unit);
+            break;
+        case 'W': //day of week
+            getdateparam = &_loop_get_day_of_week;
+            skip_periods = __skip_periods_day(unit);
+            break;
+        case 'I': //week of year
+            getdateparam = &_loop_get_week;
+            skip_periods = __skip_periods_week(unit);
+            break;
+        case 'H': //hour
+            getdateparam = &_loop_get_hour;
+            skip_periods = __skip_periods_hour(unit);
+            break;
+        case 'T': //minute
+            getdateparam = &_loop_get_minute;
+            skip_periods = __skip_periods_minute(unit);
+            break;
+        case 'S': //second
+            getdateparam = &_loop_get_second;
+            skip_periods = 1;
+            break;
+        case 'O': //toordinal
+            getdateparam = &_loop_get_ordinal;
+            skip_periods = __skip_periods_day(unit);
+            break;
+        default:
+            return NULL;
+    }
+
+    {
+    PyObject *val, *result=NULL;
+    while (iterin->index < iterin->size) {
+
+        if ((val_changed == 0) ||
+            (is_valid == 0) ||
+            (prev_val == NULL) ||
+            (counter >= skip_periods)) {
+
+               val = PyArray_GETITEM(self, iterin->dataptr);
+               result = getdateparam(PyInt_AsLong(val), unit,
+                                     todays, meta, &dinfo);
+
+               if ((prev_val != NULL) &&
+                   (PyLong_AsLong(prev_val) != PyLong_AsLong(result))) {
+                   val_changed = 1;
+                   counter = 0;
+               }
+               Py_DECREF(val);
+               if (prev_val != NULL) {
+                   Py_DECREF(prev_val);
+               }
+               prev_val = result;
+        }
+        PyArray_SETITEM(output, iterout->dataptr, result);
+
+        PyArray_ITER_NEXT(iterin);
+        PyArray_ITER_NEXT(iterout);
+        counter++;
+        }
+    }
+    if (prev_val != NULL) {
+        Py_DECREF(prev_val);
+    }
+    Py_DECREF(iterin);
+    Py_DECREF(iterout);
+    return (PyObject *) output;
+}
+PyObject *
+DatetimeArray_year(DatetimeArrayObject *self){
+    char infochar = 'Y';
+    return DatetimeArray_getdateinfo(self, &infochar);
+}
+PyObject *
+DatetimeArray_qyear(DatetimeArrayObject *self){
+     char infochar = 'F';
+     return DatetimeArray_getdateinfo(self, &infochar);
+}
+PyObject *
+DatetimeArray_quarter(DatetimeArrayObject *self){
+     char infochar = 'Q';
+     return DatetimeArray_getdateinfo(self, &infochar);
+}
+PyObject *
+DatetimeArray_month(DatetimeArrayObject *self){
+     char infochar = 'M';
+     return DatetimeArray_getdateinfo(self, &infochar);
+}
+PyObject *
+DatetimeArray_week(DatetimeArrayObject *self){
+     char infochar = 'I';
+     return DatetimeArray_getdateinfo(self, &infochar);
+}
+PyObject *
+DatetimeArray_day(DatetimeArrayObject *self){
+     char infochar = 'D';
+     return DatetimeArray_getdateinfo(self, &infochar);
+}
+PyObject *
+DatetimeArray_day_of_week(DatetimeArrayObject *self){
+     char infochar = 'W';
+     return DatetimeArray_getdateinfo(self, &infochar);
+}
+PyObject *
+DatetimeArray_day_of_year(DatetimeArrayObject *self){
+     char infochar = 'R';
+     return DatetimeArray_getdateinfo(self, &infochar);
+}
+PyObject *
+DatetimeArray_hour(DatetimeArrayObject *self){
+     char infochar = 'H';
+     return DatetimeArray_getdateinfo(self, &infochar);
+}
+PyObject *
+DatetimeArray_minute(DatetimeArrayObject *self){
+     char infochar = 'T';
+     return DatetimeArray_getdateinfo(self, &infochar);
+}
+PyObject *
+DatetimeArray_second(DatetimeArrayObject *self){
+     char infochar = 'S';
+     return DatetimeArray_getdateinfo(self, &infochar);
+}
+PyObject *
+DatetimeArray_ordinal(DatetimeArrayObject *self){
+    char infochar = 'O';
+    return DatetimeArray_getdateinfo(self, &infochar);
+}
+
+
+PyObject *
+DatetimeArray_datetime(DatetimeArrayObject *self)
+{
+    PyArrayObject *output=NULL;
+    PyArrayIterObject *iterin=NULL, *iterout=NULL;
+
+    ts_metadata *meta = get_metadata_from_array(self);
+    int unit = meta->unit;
+
+    output = (PyArrayObject *)PyArray_SimpleNew(((PyArrayObject *)self)->nd,
+                                                ((PyArrayObject *)self)->dimensions,
+                                                NPY_OBJECT);
+
+    conversion_function todays = get_converter_to_days(unit, 1);
+    meta->convert_to_start = 1;
+    ts_datetimestruct dinfo;
+
+    iterin = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
+    iterout = (PyArrayIterObject *)PyArray_IterNew((PyObject *)output);
+
+    {
+    PyObject *val, *result=NULL;
+    while (iterin->index < iterin->size) {
+        val = PyArray_GETITEM(self, iterin->dataptr);
+        result = _loop_get_datetime(PyInt_AsLong(val), unit,
+                                    todays, meta, &dinfo);
+        PyArray_SETITEM(output, iterout->dataptr, result);
+        PyArray_ITER_NEXT(iterin);
+        PyArray_ITER_NEXT(iterout);
+        }
+    }
+    Py_DECREF(iterin);
+    Py_DECREF(iterout);
+    return (PyObject *) output;
+}
+
+static PyObject *
+DatetimeArray_start_date(DatetimeArrayObject *self) {
+    PyObject *minobj, *result=NULL;
+    minobj = PyArray_Min(asndarray(self), MAX_DIMS, NULL);
+    ts_datetime val = PyInt_AsLong(minobj);
+    int unit = _get_unit_from_descr(get_descr(self));
+    result = (PyObject *)DatetimeObject_FromFreqAndValue(unit, val);
+    Py_DECREF(minobj);
+    return result;
+}
+static PyObject *
+DatetimeArray_end_date(DatetimeArrayObject *self) {
+    PyObject *maxobj, *result=NULL;
+    maxobj = PyArray_Max(asndarray(self), MAX_DIMS, NULL);
+    ts_datetime val = PyInt_AsLong(maxobj);
+    int unit = _get_unit_from_descr(get_descr(self));
+    result = (PyObject *)DatetimeObject_FromFreqAndValue(unit, val);
+    Py_DECREF(maxobj);
+    return result;
+}
+
+
+static PyObject *
+DatetimeArray_tovalues(DatetimeArrayObject *self) {
+    return get_base(self);
+}
+static PyObject *
+DatetimeArray_toordinals(DatetimeArrayObject *self) {
+    char infochar = 'O';
+    return DatetimeArray_getdateinfo(self, &infochar);
+}
+static PyObject *
+DatetimeArray_tolist(DatetimeArrayObject *self)
+{
+    PyObject *dtarray=NULL, *output=NULL;
+    dtarray = DatetimeArray_datetime(self);
+    output = PyArray_ToList((PyArrayObject *)self);
+    Py_DECREF(dtarray);
+    return output;
+}
+
+
+/*
+ * PROPERTIES
+ */
+
+static int
+DatetimeArray_ReadOnlyErr(DatetimeArrayObject *self, PyObject *value, void *closure) {
+   PyErr_SetString(PyExc_AttributeError, "Cannot set read-only property");
+   return -1;
+};
+
+static PyGetSetDef DatetimeArray_getseters[] = {
+    {"unit", (getter)DatetimeArray_unit, (setter)DatetimeArray_ReadOnlyErr,
+     "Returns the frequency.", NULL},
+    {"timestep", (getter)DatetimeArray_timestep, (setter)DatetimeArray_ReadOnlyErr,
+     "", NULL},
+    {"freqstr", (getter)DatetimeArray_freqstr, (setter)DatetimeArray_ReadOnlyErr,
+     "Returns the string representation of frequency.", NULL},
+    {"steps", (getter)DatetimeArray_steps, (setter)DatetimeArray_ReadOnlyErr,
+     "time steps", NULL},
+    {"year", (getter)DatetimeArray_year, (setter)DatetimeArray_ReadOnlyErr,
+     "time steps", NULL},
+    {"qyear", (getter)DatetimeArray_qyear, (setter)DatetimeArray_ReadOnlyErr,
+     "time steps", NULL},
+    {"quarter", (getter)DatetimeArray_quarter, (setter)DatetimeArray_ReadOnlyErr,
+     "time steps", NULL},
+    {"month", (getter)DatetimeArray_month, (setter)DatetimeArray_ReadOnlyErr,
+     "time steps", NULL},
+    {"week", (getter)DatetimeArray_week, (setter)DatetimeArray_ReadOnlyErr,
+     "time steps", NULL},
+    {"day", (getter)DatetimeArray_day, (setter)DatetimeArray_ReadOnlyErr,
+     "time steps", NULL},
+    {"day_of_week", (getter)DatetimeArray_day_of_week, (setter)DatetimeArray_ReadOnlyErr,
+     "time steps", NULL},
+    {"day_of_year", (getter)DatetimeArray_day_of_year, (setter)DatetimeArray_ReadOnlyErr,
+     "time steps", NULL},
+    {"hour", (getter)DatetimeArray_hour, (setter)DatetimeArray_ReadOnlyErr,
+     "time steps", NULL},
+    {"minute", (getter)DatetimeArray_minute, (setter)DatetimeArray_ReadOnlyErr,
+     "time steps", NULL},
+    {"second", (getter)DatetimeArray_second, (setter)DatetimeArray_ReadOnlyErr,
+     "time steps", NULL},
+    {"datetime", (getter)DatetimeArray_datetime, (setter)DatetimeArray_ReadOnlyErr,
+     "time steps", NULL},
+     {"start_date", (getter)DatetimeArray_start_date, (setter)DatetimeArray_ReadOnlyErr,
+      "time steps", NULL},
+     {"end_date", (getter)DatetimeArray_end_date, (setter)DatetimeArray_ReadOnlyErr,
+      "time steps", NULL},
+    {NULL, NULL, NULL, NULL, NULL}  /* Sentinel */
+};
+
+/*
+ * METHODS
+ */
+
+
+
+static PyObject *
+DatetimeArray_convert(DatetimeArrayObject *self,
+                      PyObject *args, PyObject *kwds)
+{
+    DatetimeArrayObject *output=NULL;
+    PyObject *freq=NULL;
+    char *relation_raw=NULL, *relation_uc;
+    conversion_function converterfrom, converterto;
+    int fromfreq, tofreq;
+
+    PyArray_Descr *indescr, *outdescr;
+    ts_metadata *metafrom, *metato;
+
+    indescr = get_descr(self);
+    metafrom = get_metadata_from_descr(indescr);
+    fromfreq = _get_unit_from_descr(indescr);
+
+    /* Get the arguments */
+    static char *kwlist[] = {"freq", "relation", NULL};
+    if (! PyArg_ParseTupleAndKeywords(args, kwds, "O|s", kwlist,
+                                      &freq, &relation_raw))
+        return NULL;
+
+    /* Check the conversion frequency */
+    if ((tofreq = check_freq(freq)) == INT_ERR_CODE)
+        return NULL;
+
+
+    /* Initialize the output */
+    outdescr = PyArray_DescrNewFromType(PyArray_INT64);
+    if (outdescr == NULL)
+        return NULL;
+    Py_INCREF(outdescr);
+    output = (DatetimeArrayObject *)PyArray_NewFromDescr(&DatetimeArray_Type,
+                                                         outdescr,
+                                                         asarray(self)->nd,
+                                                         asarray(self)->dimensions,
+                                                         NULL,
+                                                         NULL,
+                                                         asarray(self)->flags,
+                                                         NULL);
+    if (output == NULL)
+        return NULL;
+    metato = get_metadata_from_descr(outdescr);
+    init_metadata_from_unit(metato, tofreq);
+
+
+    /* Update the convert_to_start from the relational argument */
+    if(relation_raw) {
+        if (strlen(relation_raw) > 0) {
+            if ((relation_uc = str_uppercase(relation_raw)) == NULL)
+                return PyErr_NoMemory();
+            // 'BEFORE' and 'AFTER' values for this parameter are deprecated
+            if ((relation_uc[0] == 'E') || (relation_uc[0] == 'A'))
+                metafrom->convert_to_start = 0;
+            else if ((relation_uc[0] == 'S') || (relation_uc[0] == 'B'))
+                metafrom->convert_to_start = 1;
+            else {
+                PyErr_SetString(PyExc_ValueError,"Invalid relation specification");
+                free(relation_uc);
+                return NULL;
+            }
+            free(relation_uc);
+        }
+        else {
+            metafrom->convert_to_start = 0;
+        };
+    }
+    else {
+        metafrom->convert_to_start = 0;
+    }
+    metato->convert_to_start = metafrom->convert_to_start;
+    /* Correction for business days */
+    if ((tofreq == FR_BUS) && (fromfreq < FR_DAY))
+        metato->convert_to_start = 1;
+
+
+    PyArrayIterObject *iterfrom, *iterto;
+    iterfrom = (PyArrayIterObject *)PyArray_IterNew((PyObject *)get_base(self));
+    iterto = (PyArrayIterObject *)PyArray_IterNew((PyObject *)output);
+    if ((iterfrom == NULL) || (iterto == NULL)) {
+        Py_XDECREF(iterfrom);
+        Py_XDECREF(iterto);
+        Py_XDECREF(output);
+        return NULL;
+    }
+
+    PyObject *fromdateobj=NULL, *todateobj=NULL;
+    PyArray_GetItemFunc *getitem = indescr->f->getitem;
+
+    if (tofreq == fromfreq) {
+        while (iterfrom->index < iterfrom->size) {
+            fromdateobj = getitem(iterfrom->dataptr, self);
+            PyArray_SETITEM(output, iterto->dataptr, fromdateobj);
+            Py_DECREF(fromdateobj);
+            PyArray_ITER_NEXT(iterfrom);
+            PyArray_ITER_NEXT(iterto);
+        }
+    }
+    else {
+        ts_datetime fromdateval, todateval;
+        converterfrom = convert_to_mediator(metafrom->unit, metato->unit, 0);
+        converterto = convert_from_mediator(metafrom->unit, metato->unit, 0);
+        while (iterfrom->index < iterfrom->size) {
+            fromdateobj = getitem(iterfrom->dataptr, self);
+            fromdateval = PyInt_AsLong(fromdateobj);
+            todateval = converterto(converterfrom(fromdateval, metafrom), metato);
+            todateobj = PyInt_FromLong(todateval);
+
+            PyArray_SETITEM(output, iterto->dataptr, todateobj);
+            Py_DECREF(fromdateobj);
+            Py_DECREF(todateobj);
+
+            PyArray_ITER_NEXT(iterfrom);
+            PyArray_ITER_NEXT(iterto);
+        }
+    }
+    Py_DECREF(iterfrom);
+    Py_DECREF(iterto);
+    return (PyObject *)output;
+
+}
+
+
+static PyObject *
+DatetimeArray_fill_missing_dates(DatetimeArrayObject *self,
+                                 PyObject *args, PyObject *kwds)
+{
+    DatetimeArrayObject *output=NULL;
+    PyObject *base=NULL, *result=NULL;
+    PyArray_Descr *descr = get_descr(self);
+
+    int output_mask = 0;
+    static char *kwlist[] = {"output_mask", NULL};
+    if (!PyArg_ParseTupleAndKeywords(args, kwds, "|i", kwlist,
+                                     &output_mask))
+        return NULL;
+
+    ts_metadata *meta = get_metadata_from_descr(descr);
+    ts_timestatus status = self->status;
+
+    if (status.has_dups) {
+        PyErr_SetString(PyExc_ValueError, "duplicated dates are not allowed");
+        goto fail;
+    }
+    if (! status.is_chrono) {
+        PyErr_SetString(PyExc_ValueError, "series must be in chronological order");
+        goto fail;
+    }
+    if (! status.has_missing) {
+        DEBUGPRINTF("fill_missing_dates : no missing");
+        base = PyArray_Copy(asndarray(self));
+    }
+    else {
+        DEBUGPRINTF("fill_missing_dates : w/ missing");
+        PyObject *start=NULL, *end=NULL;
+        start = PyArray_Min(asndarray(self), MAX_DIMS, NULL);
+        end = PyArray_Max(asndarray(self), MAX_DIMS, NULL);
+        if ((start == NULL) || (end == NULL)) {
+            Py_XDECREF(start);
+            Py_XDECREF(end);
+            goto fail;
+        }
+        PyObject *pystep = PyInt_FromLong(meta->timestep);
+        base = PyArray_ArangeObj(start, PyNumber_Add(end, pystep), pystep,
+                                 descr);
+        Py_DECREF(pystep);
+        Py_XDECREF(start);
+        Py_XDECREF(end);
+    }
+    DEBUGPRINTF("initializing the output");
+    output = (DatetimeArrayObject *)PyArray_View(asarray(base), descr, Py_TYPE(self));
+    if (output == NULL) {
+        goto fail;
+    }
+    update_descr_metadata(get_descr(output), meta);
+    ts_timestatus newstatus = {0, 0, 1};
+    output->status = newstatus;
+
+    if (output_mask) {
+        npy_intp size = PyArray_SIZE(output);
+        PyObject *mask = PyArray_ZEROS(1, &size, NPY_BOOL, 0);
+        DEBUGPRINTF("mask initialized");
+        if (status.has_missing) {
+            PyArray_CompareFunc *cmprf = ((PyArrayObject *)self)->descr->f->compare;
+            PyArrayIterObject *iself=NULL, *ifill=NULL, *imask=NULL;
+            iself = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
+            ifill = (PyArrayIterObject *)PyArray_IterNew((PyObject *)output);
+            imask = (PyArrayIterObject *)PyArray_IterNew((PyObject *)mask);
+            while (iself->index < iself->size) {
+                while (cmprf(iself->dataptr, ifill->dataptr, self) == 1) {
+                    PyArray_SETITEM(mask, imask->dataptr, PyInt_FromLong(1));
+                    PyArray_ITER_NEXT(ifill);
+                    PyArray_ITER_NEXT(imask);
+                }
+                PyArray_ITER_NEXT(iself);
+                PyArray_ITER_NEXT(ifill);
+                PyArray_ITER_NEXT(imask);
+            }
+            Py_XDECREF(iself);
+            Py_XDECREF(ifill);
+            Py_XDECREF(imask);
+        }
+        DEBUGPRINTF("all ok");
+        result = Py_BuildValue("(OO)", output, mask);
+    }
+    else
+        result = Py_BuildValue("O", output);
+
+    return result;
+
+ fail:
+    Py_XDECREF(output);
+    Py_XDECREF(base);
+    return NULL;
+}
+
+static PyObject *
+DatetimeArray_get_missing_dates_mask(DatetimeArrayObject *self)
+{
+    PyObject *mask = NULL;
+
+    ts_timestatus status = self->status;
+    int is_valid = ((! status.has_missing) && (! status.has_dups) && (status.is_chrono));
+
+    if (is_valid) {
+        npy_intp size = PyArray_SIZE(self);
+        mask = PyArray_ZEROS(1, &size, NPY_BOOL, 0);
+        if (mask == NULL)
+            goto fail;
+    }
+    else {
+        PyObject *filled = DatetimeArray_fill_missing_dates(self, NULL, NULL);
+        if (filled == NULL) {
+            DEBUGPRINTF("FSCK");
+            Py_XDECREF(filled);
+            Py_XDECREF(mask);
+            return NULL;
+        }
+        npy_intp size = PyArray_SIZE(get_base(filled));
+        mask = PyArray_ZEROS(1, &size, NPY_BOOL, 0);
+        if (mask == NULL)
+            goto fail;
+
+        DEBUGPRINTF("mask initialized");
+        PyArray_CompareFunc *cmprf = ((PyArrayObject *)self)->descr->f->compare;
+        PyArrayIterObject *iself=NULL, *ifill=NULL, *imask=NULL;
+        iself = (PyArrayIterObject *)PyArray_IterNew((PyObject *)self);
+        ifill = (PyArrayIterObject *)PyArray_IterNew((PyObject *)filled);
+        imask = (PyArrayIterObject *)PyArray_IterNew((PyObject *)mask);
+        int i=0;
+        while (iself->index < iself->size) {
+            DEBUGPRINTF("ini got %ld", PyInt_AsLong(PyArray_GETITEM(self,iself->dataptr)));
+            DEBUGPRINTF("fld got 1 at %ld", PyInt_AsLong(PyArray_GETITEM(self,ifill->dataptr)));
+            DEBUGPRINTF("[%i]", cmprf(iself->dataptr, ifill->dataptr, self));
+            while (cmprf(iself->dataptr, ifill->dataptr, self) == 1) {
+                i++;
+                DEBUGPRINTF("Add 1 at %i", i);
+//                DEBUGPRINTF("fld got 1 at %ld", PyInt_AsLong(PyArray_GETITEM(self,ifill->dataptr)));
+                PyArray_SETITEM(mask, imask->dataptr, PyInt_FromLong(1));
+                PyArray_ITER_NEXT(ifill);
+                PyArray_ITER_NEXT(imask);
+            }
+            PyArray_ITER_NEXT(iself);
+            PyArray_ITER_NEXT(ifill);
+            PyArray_ITER_NEXT(imask);
+        }
+        Py_XDECREF(iself);
+        Py_XDECREF(ifill);
+        Py_XDECREF(imask);
+        Py_DECREF(filled);
+    }
+    return (PyObject *)mask;
+
+ fail:
+    DEBUGPRINTF("FSCK");
+    Py_XDECREF(mask);
+    return NULL;
+}
+
+
+static PyMethodDef DatetimeArray_methods[] = {
+    { "__array_finalize__", (PyCFunction)DatetimeArray_finalize, METH_VARARGS,
+      ""},
+//    {"__getitem__", (PyCFunction)DatetimeArray_getitem, METH_VARARGS, ""},
+    {"has_dups", (PyCFunction)DatetimeArray_has_dups, METH_VARARGS, ""},
+    {"has_missing", (PyCFunction)DatetimeArray_has_missing, METH_VARARGS, ""},
+    {"is_chrono", (PyCFunction)DatetimeArray_is_chrono, METH_VARARGS, ""},
+    {"is_full", (PyCFunction)DatetimeArray_is_full, METH_VARARGS, ""},
+    {"is_valid", (PyCFunction)DatetimeArray_is_valid, METH_VARARGS, ""},
+    {"date_to_index", (PyCFunction)DatetimeArray_date_to_index, METH_VARARGS, ""},
+    {"tovalues", (PyCFunction)DatetimeArray_tovalues, METH_VARARGS, ""},
+    {"toordinals", (PyCFunction)DatetimeArray_toordinals, METH_VARARGS, ""},
+    {"tolist", (PyCFunction)DatetimeArray_tolist, METH_VARARGS, ""},
+    {"fill_missing_dates", (PyCFunction)DatetimeArray_fill_missing_dates, METH_KEYWORDS, ""},
+    {"get_missing_dates_mask", (PyCFunction)DatetimeArray_get_missing_dates_mask, METH_VARARGS, ""},
+    {"convert", (PyCFunction)DatetimeArray_convert, METH_KEYWORDS, ""},
+    {0}
+};
+
+
+static PyTypeObject DatetimeArray_Type = {
+    PyObject_HEAD_INIT(NULL)
+    0,                                        /* ob_size */
+    "timeseries.DatetimeArray",                      /* tp_name */
+    sizeof(DatetimeArrayObject),              /* tp_basicsize */
+    0,                                        /* tp_itemsize */
+    (destructor)DatetimeArray_dealloc,          /* tp_dealloc */
+    0,                                        /* tp_print */
+    0,                                        /* tp_getattr */
+    0,                                        /* tp_setattr */
+    0,                                        /* tp_compare */
+    0,                                        /* tp_repr */
+    0,                                        /* tp_as_number */
+    0,                                        /* tp_as_sequence */
+    &DatetimeArray_as_mapping,                 /* tp_as_mapping */
+    0,                                        /* tp_hash */
+    0,                                        /* tp_call */
+    0,                                        /* tp_str */
+    0,                                        /* tp_getattro */
+    0,                                        /* tp_setattro */
+    0,                                        /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
+    "DatetimeArray",                          /* tp_doc */
+    0,                                        /* tp_traverse */
+    0,                                        /* tp_clear */
+    0,     /* tp_richcompare */
+    0,                                        /* tp_weaklistoffset */
+    0,                                        /* tp_iter */
+    0,                                        /* tp_iternext */
+    DatetimeArray_methods,                    /* tp_methods */
+    DatetimeArray_members,                    /* tp_members */
+    DatetimeArray_getseters,                  /* tp_getset */
+    0,                            /* tp_base */
+    0,                                        /* tp_dict */
+    0,                                        /* tp_descr_get */
+    0,                                        /* tp_descr_set */
+    0,                                        /* tp_dictoffset */
+    0,                                        /* tp_init */
+    0,                                        /* tp_alloc */
+    DatetimeArray_new,                        /* tp_new */
+};
+
+
+
+
+
+
+/*
+ * */
+void import_c_datearray(PyObject *m)
+{
+    import_array();
+    PyDateTime_IMPORT;
+
+    DatetimeArray_Type.tp_base = &PyArray_Type;
+    if (PyType_Ready(&DatetimeArray_Type) < 0)
+        return;
+    Py_INCREF(&DatetimeArray_Type);
+    PyModule_AddObject(m, "DatetimeArray", (PyObject *)(&DatetimeArray_Type));
+    
+//    PyArray_TS_DATETIME = PyArray_RegisterDataType(&TS_DATETIME_Descr);
+//    if (PyArray_TS_DATETIME < 0) {
+//        DEBUGPRINTF("Could not import the TS_DATETIME description.");
+//        return;
+//    };
+//    TS_DATETIME_Descr.ob_type = &PyArrayDescr_Type;
+//    Py_INCREF(&TS_DATETIME_Descr);
+
+    // PyModule_AddObject(m, "Datetime", (PyObject *)(&TS_DATETIME_Descr));
+
+}
+
+
diff --git a/pandas/src/timeseries/c_dates.c b/pandas/src/timeseries/c_dates.c
new file mode 100644
index 000000000..49cdd424d
--- /dev/null
+++ b/pandas/src/timeseries/c_dates.c
@@ -0,0 +1,2691 @@
+#include "c_dates.h"
+#include "c_freqs.h"
+#include "c_convert.h"
+#include "c_types.h"
+
+#include <datetime.h>
+#include <time.h>
+
+
+
+#define INIT_ERR(errortype, errmsg) PyErr_SetString(errortype,errmsg);return -1
+
+
+/*********************************************************
+** Python callbacks. These functions must be called by  **
+** the module __init__ script                           **
+*********************************************************/
+
+static PyObject *DateFromString = NULL;
+PyObject *
+set_callback_DateFromString(PyObject *dummy, PyObject *args) {
+    return set_callback(args, &DateFromString);
+}
+static PyObject *DateTimeFromString = NULL;
+PyObject *
+set_callback_DateTimeFromString(PyObject *dummy, PyObject *args) {
+    return set_callback(args, &DateTimeFromString);
+}
+
+
+
+/* Returns absolute seconds from an hour, minute, and second
+ */
+#define secs_from_hms(hour, min, sec, multiplier) (\
+  ((hour)*3600 + (min)*60 + (sec)) * (npy_int64)(multiplier)\
+)
+
+/* Returns the quarter */
+#define month_to_quarter(month) (((month)-1)/3 + 1)
+#define quarter_to_month(quarter) (((quarter)-1)*3 + 1)
+
+
+
+/*
+====================================================
+== End of section borrowed from mx.DateTime       ==
+====================================================
+*/
+
+void
+init_metadata_from_unit(ts_metadata *meta, int unit) {
+    meta->unit = (unit/1000)*1000;
+    if (unit > FR_DAY) {
+        meta->periods_per_day = highunits_per_day(unit);
+        meta->secs_per_period = secs_per_highunits(unit, 1);
+        meta->period_end_at = -1;
+    }
+    else {
+        meta->periods_per_day = -1;
+        meta->secs_per_period = -1;
+        meta->period_end_at = unit - meta->unit;
+    }
+    meta->convert_to_start = 0;
+    meta->timestep = 1;
+}
+
+
+
+// NPY_NO_EXPORT
+ts_datetime
+datetimestruct_to_tsdatetime(ts_metadata *meta, ts_datetimestruct *d)
+{
+    ts_datetime val;
+    npy_int64 days=0;
+
+    int unit = meta->unit;
+    int period_end_at = meta->period_end_at;
+
+    if ((unit > FR_MTH) || (unit == FR_UND)) {
+        days = days_from_ymd(d->year, d->month, d->day);
+        if (unit >= FR_HR){
+            days -= HIGHFREQ_ORIG;
+        };
+    };
+    if (unit == FR_ANN) {
+        val = d->year;
+    }
+    else if (unit == FR_QTR) {
+        npy_int64 quarter = ((d->month - 1)/3) + 1;
+        if (period_end_at > 12) {
+            // quarterly frequency with year determined by ending period
+            val = d->year*4 + quarter;
+        }
+        else {
+            /* quarterly frequency with year determined by ending period
+                           or has December year end*/
+            val = (d->year - 1)*4 + quarter;
+        };
+    }
+    else if (unit == FR_MTH) {
+        val = (d->year-1)*12 + d->month;
+    }
+    else if (unit == FR_WK) {
+        ts_datetime end_week_day, adj_day;
+        end_week_day = (7 - period_end_at) % 7;
+        adj_day = days + ((7 - end_week_day) - days % 7) % 7;
+        val = adj_day / 7;
+    }
+    else if (unit == FR_BUS) {
+        npy_int64 weeks = days/7;
+        val = days - weeks * 2;
+        /*
+        int dotw = day_of_week(days);
+        if (dotw > 4){
+            // Invalid business day
+            val = 0;
+        }
+        else {
+            npy_int64 x = days -2;
+            val = 2 + (x/7)*5 + x%7;
+        }
+        */
+    }
+    else if ((unit == FR_DAY) || (unit==FR_UND)){
+        val = days;
+    }
+    else if (unit == FR_HR) {
+        val = days * 24 + d->hour;
+    }
+    else if (unit == FR_MIN){
+        val = days * 1440 + d->hour * 60 + d->min;
+    }
+    else if (unit == FR_SEC){
+        val = days *  (npy_int64)(86400)
+            + secs_from_hms(d->hour, d->min, d->sec, 1);
+    }
+    else {
+        /* Shouldn't get here */
+        PyErr_SetString(PyExc_ValueError, "invalid internal frequency");
+        val = -1;
+    }
+    return val;
+}
+
+
+
+// NPY_NO_EXPORT
+ts_datetime
+PyDatetime_to_tsdatetime(ts_metadata *meta, PyObject *datetime)
+{
+    ts_datetimestruct dinfo;
+    ts_datetime val;
+
+    if (!PyDateTime_Check(datetime) && !PyDate_Check(datetime)){
+        PyObject *err_msg, *_type;
+        _type = PyObject_Type(datetime);
+        err_msg = PyString_FromString("Expected a datetime.date(time) object, received: ");
+        PyString_ConcatAndDel(&err_msg, PyObject_Str(_type));
+        PyErr_SetString(PyExc_TypeError, PyString_AsString(err_msg));
+        Py_DECREF(_type);
+        Py_DECREF(err_msg);
+        val = -1;
+    }
+    else {
+        dinfo.year = (npy_int64)PyDateTime_GET_YEAR(datetime);
+        dinfo.month = PyDateTime_GET_MONTH(datetime);
+        dinfo.day = (int)PyDateTime_GET_DAY(datetime);
+        dinfo.hour = (int)PyDateTime_DATE_GET_HOUR(datetime);
+        dinfo.min = (int)PyDateTime_DATE_GET_MINUTE(datetime);
+        dinfo.sec = (int)PyDateTime_DATE_GET_SECOND(datetime);
+        //
+        val = datetimestruct_to_tsdatetime(meta, &dinfo);
+    }
+    return val;
+}
+
+
+
+// NPY_NO_EXPORT
+ts_datetime
+PyString_to_tsdatetime(ts_metadata *meta, PyObject *string)
+{
+    ts_datetime val;
+    PyObject *pydatetime;
+    PyObject *string_arg = PyTuple_New(1);
+
+    PyTuple_SET_ITEM(string_arg, 0, string);
+    Py_INCREF(string);
+    if (meta->unit > FR_DAY) {
+        pydatetime = PyEval_CallObject(DateTimeFromString, string_arg);
+    } else {
+        pydatetime = PyEval_CallObject(DateFromString, string_arg);
+    };
+    Py_DECREF(string_arg);
+    val = PyDatetime_to_tsdatetime(meta, pydatetime);
+    Py_DECREF(pydatetime);
+    return val;
+}
+
+
+
+PyObject *
+PyDateTime_FromFreqAndValue(ts_datetime val, ts_metadata *meta)
+{
+    PyObject *pydatetime;
+    npy_int64 absdate, abstime=0;
+    int hour=0, minute=0, second=0;
+    ts_datetimestruct dinfo;
+
+    int unit = meta->unit;
+
+    conversion_function todays = get_converter_to_days(unit, 0);
+    meta->convert_to_start = 0;
+
+    absdate = todays(val, meta);
+    if (unit > FR_DAY)
+        abstime = _secs_from_midnight(val, unit);
+    set_datetimestruct_from_days_and_secs(&dinfo, absdate, abstime);
+
+    switch(unit) {
+        case FR_HR:
+            hour = dinfo.hour;
+            break;
+        case FR_MIN:
+            hour = dinfo.hour;
+            minute = dinfo.min;
+            break;
+        case FR_SEC:
+            hour = dinfo.hour;
+            minute = dinfo.min;
+            second = (int)dinfo.sec;
+            break;
+    }
+    pydatetime = PyDateTime_FromDateAndTime(dinfo.year, dinfo.month, dinfo.day,
+                                            hour, minute, second, 0);
+    return pydatetime;
+}
+
+
+
+
+
+/************************************************************
+** Date type definition
+************************************************************/
+
+static void
+DatetimeObject_dealloc(DatetimeObject* self) {
+    self->ob_type->tp_free((PyObject*)self);
+}
+
+
+static PyObject *
+DatetimeObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
+    DatetimeObject *self;
+    self = (DatetimeObject*)type->tp_alloc(type, 0);
+
+    // Initialize the metadata
+    ts_metadata meta = {FR_UND, 1, 0, -1, -1, 0};
+
+    if (self != NULL) {
+        // initialize attributes that need initializing in here
+        self->obval = -1;
+        self->obmeta = meta;
+    }
+    return (PyObject *)self;
+}
+
+
+/* for use in C code */
+static DatetimeObject *
+DatetimeObject_New(void) {
+    PyObject *dummy=NULL;
+    return (DatetimeObject*)DatetimeObject_new(&DatetimeObject_Type, dummy, dummy);
+}
+
+
+
+static int
+DatetimeObject_init(DatetimeObject *self, PyObject *args, PyObject *kwds) {
+
+    PyObject *freq=NULL, *value=NULL, *datetime=NULL, *string=NULL;
+    char *INSUFFICIENT_MSG = "insufficient parameters to initialize Date";
+
+    int def_info=INT_ERR_CODE;
+
+    int year=def_info, month=def_info, day=def_info, quarter=def_info,
+        hour=def_info, minute=def_info, second=def_info;
+    int unit;
+
+    static char *kwlist[] = {"freq", "value", "string",
+                             "year", "month", "day", "quarter",
+                             "hour", "minute", "second",
+                             "datetime", NULL};
+
+    if (! PyArg_ParseTupleAndKeywords(args, kwds, "O|OOiiiiiiiO", kwlist,
+                                      &freq, &value, &string,
+                                      &year, &month, &day, &quarter,
+                                      &hour, &minute, &second,
+                                      &datetime)) {
+        return -1;
+    }
+
+    if (PyObject_HasAttrString(freq, "unit")) {
+        PyObject *freq_attr = PyObject_GetAttrString(freq, "unit");
+        unit = PyInt_AS_LONG(freq_attr);
+        Py_DECREF(freq_attr);
+    } else {
+        if((unit = check_freq(freq)) == INT_ERR_CODE) return -1;
+    }
+    init_metadata_from_unit(&self->obmeta, unit);
+    unit = self->obmeta.unit;
+
+    // The input value is a date string...
+    if ((value && PyString_Check(value)) || string) {
+        if (!string)
+            string = value;
+        self->obval = PyString_to_tsdatetime(&(self->obmeta), string);
+    }
+    // The input is a datetime.date(time) object:
+    else if ((value && (PyDateTime_Check(value) || PyDate_Check(value))) ||
+             datetime) {
+        if (!datetime)
+            datetime = value;
+        self->obval = PyDatetime_to_tsdatetime(&(self->obmeta), datetime);
+    }
+    // The input is a value
+    else if (value) {
+        self->obval = PyInt_AsLong(value);
+    }
+    // The input is a list of arguments
+    else {
+        // We always must have a year defined
+        if (year == def_info) {
+            INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+        };
+        // For weekly to daily (undefined) units, we need month and day
+        if (unit == FR_BUS || unit == FR_DAY || unit == FR_WK || unit == FR_UND) {
+            if (month == def_info || day == def_info) {
+                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+            };
+                // if FR_BUS, check for week day
+        }
+        // Need a month for monthly
+        else if (unit == FR_MTH) {
+            if (month == def_info) {
+                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+            }
+        }
+        else if (unit == FR_QTR) {
+            if (quarter == def_info) {
+                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+            }
+            month = (quarter-1) * 3 + 1;
+        }
+        else if (unit == FR_SEC) {
+            if (month == def_info || day == def_info || second == def_info) {
+                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+            }
+            if (hour == def_info) {
+                hour = second/3600;
+                minute = (second % 3600)/60;
+                second = second % 60;
+            }
+            else if (minute == def_info) {
+                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+            }
+        }
+        else if (unit == FR_MIN) {
+            if (month == def_info || day == def_info || minute == def_info) {
+                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+            }
+            if (hour == def_info) {
+                hour = minute/60;
+                minute = minute % 60;
+            }
+        }
+        else if (unit == FR_HR) {
+            if (month == def_info || day == def_info || hour == def_info) {
+                INIT_ERR(PyExc_ValueError, INSUFFICIENT_MSG);
+            }
+        };
+        /*Fill the structure from the input, and get the corresponding datetime*/
+        ts_datetimestruct dinfo;
+        dinfo.year = year;
+        dinfo.month = month;
+        dinfo.day = day;
+        dinfo.hour = hour;
+        dinfo.min = minute;
+        dinfo.sec = second;
+        self->obval = datetimestruct_to_tsdatetime(&(self->obmeta), &dinfo);
+    }
+    return 0;
+}
+
+
+static PyMemberDef DatetimeObject_members[] = {
+    {"value", T_INT, offsetof(DatetimeObject, obval), 0,
+     "integer representation of the Date"},
+    {NULL}  /* Sentinel */
+};
+
+
+
+typedef struct {
+    PyObject_HEAD;
+    int unit; /* frequency of date */
+    int freq;
+    long years;
+    long months;
+    long days;
+    long seconds;
+//    PyObject* cached_vals;
+} TimeDeltaObject;
+
+/* Forward declarations */
+static PyTypeObject TimeDeltaType;
+#define TimeDelta_Check(op) PyObject_TypeCheck(op, &TimeDeltaType)
+
+static void
+TimeDeltaObject_dealloc(TimeDeltaObject* self) {
+//    Py_XDECREF(self->cached_vals);
+    self->ob_type->tp_free((PyObject*)self);
+}
+
+
+static PyObject *
+TimeDeltaObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {
+    TimeDeltaObject *self;
+    self = (TimeDeltaObject*)type->tp_alloc(type, 0);
+    if (self != NULL) {
+        // initialize attributes that need initializing in here
+        self->unit = FR_UND;
+        self->freq = self->unit;
+        self->months = 0;
+        self->days = 0;
+        self->seconds = 0;
+    }
+    return (PyObject *)self;
+}
+
+
+static TimeDeltaObject *
+TimeDeltaObject_New(void) {
+    PyObject *dummy=NULL;
+    return (TimeDeltaObject*)TimeDeltaObject_new(&TimeDeltaType, dummy, dummy);
+}
+
+
+#define INIT_ERR(errortype, errmsg) PyErr_SetString(errortype,errmsg);return -1
+
+#define get_timedelta_months(o)  (((TimeDeltaObject *)(o))->months)
+#define get_timedelta_days(o)    (((TimeDeltaObject *)(o))->days)
+#define get_timedelta_seconds(o) (((TimeDeltaObject *)(o))->seconds)
+
+
+
+static int
+TimeDeltaObject_init(TimeDeltaObject *self, PyObject *args, PyObject *kwds) {
+
+    PyObject *unit=NULL, *freq=NULL, *value=NULL, *delta=NULL;
+    PyObject *py_years=NULL, *py_months=NULL, *py_days=NULL, *py_quarters=NULL;
+    PyObject *py_hours=NULL, *py_minutes=NULL, *py_seconds=NULL;
+    npy_int64 months=0, days=0, seconds=0;
+
+    int fr_group;
+    int free_dt=0;
+
+    static char *kwlist[] = {"unit", "value",
+                             "years", "months", "days", "quarters",
+                             "hours", "minutes", "seconds",
+                             "timedelta", "freq", NULL};
+
+    // Check the parameters
+    if (! PyArg_ParseTupleAndKeywords(args, kwds, "O|OOOOOOOOO:__new__", kwlist,
+                                      &unit, &value,
+                                      &py_years, &py_months, &py_days, &py_quarters,
+                                      &py_hours, &py_minutes, &py_seconds,
+                                      &delta, &freq)) {
+        return -1;
+    }
+
+    // If `freq` is defined, then overwrite `unit`
+    if (freq){
+        value = unit;
+        unit = freq;
+        freq = NULL;
+    }
+
+    // Process `unit`
+    if (PyObject_HasAttrString(unit, "unit")) {
+        PyObject *unit_attr = PyObject_GetAttrString(unit, "unit");
+        self->unit = PyInt_AS_LONG(unit_attr);
+        Py_DECREF(unit_attr);
+    }
+    else if (PyObject_HasAttrString(unit, "freq")) {
+        PyObject *unit_attr = PyObject_GetAttrString(unit, "freq");
+        self->unit = PyInt_AS_LONG(unit_attr);
+        Py_DECREF(unit_attr);
+    }
+    else {
+        if ((self->unit = check_freq(unit)) == INT_ERR_CODE)
+            return -1;
+    };
+    self->freq = self->unit;
+    fr_group = get_base_unit(self->unit);
+
+    if (value && PyDelta_Check(value)) {
+        if (!delta) delta = value;
+        value = NULL;
+    }; // datetime = (datetime||value), value = NULL
+
+    if (value) {
+        if (fr_group == FR_ANN)
+            months = PyInt_AsLong(value) * 12;
+        else if (fr_group == FR_QTR)
+            months = PyInt_AsLong(value) * 3;
+        else if (fr_group == FR_MTH)
+            months = PyInt_AsLong(value);
+        else if (fr_group == FR_WK)
+            days = PyInt_AsLong(value) * 7;
+        else if ((fr_group == FR_BUS) || (fr_group == FR_DAY) || (fr_group == FR_UND))
+            days = PyInt_AsLong(value);
+        else if (fr_group == FR_HR)
+            seconds = PyInt_AsLong(value) * 3600;
+        else if (fr_group == FR_MIN)
+            seconds = PyInt_AsLong(value) * 60;
+        else if (fr_group == FR_SEC)
+            seconds = PyInt_AsLong(value);
+        else
+            days = PyInt_AsLong(value);
+        Py_DECREF(value);
+    };
+    if (delta) {
+        if (PyDelta_Check(delta)){
+            self->days = ((PyDateTime_Delta *)(delta))->days;
+            self->seconds = ((PyDateTime_Delta *)(delta))->seconds + \
+                            ((PyDateTime_Delta *)(delta))->microseconds/1000000;
+//            free_dt = 1;
+        }
+        else {
+            PyObject *err_msg, *_type;
+            _type = PyObject_Type(delta);
+            err_msg = PyString_FromString("Expected timedelta object, received: ");
+            PyString_ConcatAndDel(&err_msg, PyObject_Str(_type));
+            PyErr_SetString(PyExc_TypeError, PyString_AsString(err_msg));
+            Py_DECREF(_type);
+            Py_DECREF(err_msg);
+            return -1;
+        }
+    } else {
+        if (py_years){
+            months += PyInt_AsLong(py_years)*12;
+//            Py_DECREF(py_years);
+        };
+        if (py_quarters){
+            months += PyInt_AsLong(py_quarters)*3;
+//            Py_DECREF(py_quarters);
+        };
+        if (py_months){
+            months += PyInt_AsLong(py_months);
+//            Py_DECREF(py_months);
+        };
+        if (py_days){
+            days += PyInt_AsLong(py_days);
+//            Py_DECREF(py_days);
+        };
+        if (py_hours){
+            seconds += PyInt_AsLong(py_hours) * 3600;
+//            Py_DECREF(py_hours);
+        };
+        if (py_minutes){
+            seconds += PyInt_AsLong(py_minutes) * 60;
+//            Py_DECREF(py_minutes);
+        };
+        if (py_seconds){
+            seconds += PyInt_AsLong(py_seconds);
+//            Py_DECREF(py_seconds);
+        };
+        normalize_days_secs(&days, &seconds);
+
+        self->months = months;
+        self->days = days;
+        self->seconds = seconds;
+        };
+
+    if (free_dt) { Py_DECREF(delta); }
+    return 0;
+}
+
+
+
+static PyMemberDef TimeDeltaObject_members[] = {
+    {"unit", T_INT, offsetof(TimeDeltaObject, unit), 0,
+     "frequency"},
+    {"freq", T_INT, offsetof(TimeDeltaObject, freq), 0,
+     "frequency"},
+    {"months", T_INT, offsetof(TimeDeltaObject, months), 0,
+     "months"},
+    {"days", T_INT, offsetof(TimeDeltaObject, days), 0,
+     "days"},
+    {"seconds", T_INT, offsetof(TimeDeltaObject, seconds), 0,
+     "seconds"},
+    {NULL}  /* Sentinel */
+};
+
+
+
+static char DatetimeObject_toordinal_doc[] =
+"Returns the proleptic Gregorian ordinal of the date, as an integer.\n"
+"This corresponds to the number of days since Jan., 1st, 1AD.\n\n"
+"When the instance has a frequency less than daily, the proleptic date \n"
+"is calculated for the last day of the period.\n\n"
+"   >>> ts.Date('D', '2001-01-01').toordinal()\n"
+"   730486\n"
+"   >>> ts.Date('H', '2001-01-01 18:00').toordinal()\n"
+"   730486\n"
+"   >>> ts.Date('M', '2001-01-01').toordinal()\n"
+"   730516\n"
+"   >>> # Note that 730516 = 730486 + 31 - 1\n"
+"   >>> ts.Date('Y', '2001-01-01').toordinal()\n"
+"   730850\n"
+"   >>> # Note that 730850 = 730486 + 365 - 1\n";
+static PyObject *
+DatetimeObject_toordinal(DatetimeObject *self)
+{
+    conversion_function todays = get_converter_to_days(self->obmeta.unit, 0);
+    return PyInt_FromLong(todays(self->obval, &(self->obmeta)));
+};
+
+
+
+static char DatetimeObject_asfreq_doc[] =
+"   asfreq(freq, relation='END')\n"
+"\n"
+"   Returns a :class:`Date` object converted to a specified frequency.\n"
+"\n"
+"   :Parameters:\n"
+"\n"
+"      **freq** : {string, integer}\n"
+"         Frequency to convert the instance to. Accepts any valid frequency\n"
+"         specification (string or integer).\n"
+"\n"
+"      **relation** : {'END', 'START'} (optional)\n"
+"         Applies only when converting a :class:`Date` to a higher frequency,\n"
+"         or when converting a weekend Date to a business frequency Date.\n"
+"         Valid values are 'START' and 'END'.\n"
+"         For example, when converting a monthly :class:`Date` to the daily\n"
+"         frequency, ``relation='START'`` gives the first day of the month\n"
+"         while ``relation='END'`` gives the last day of the month.\n"
+"\n"
+"   .. warning::\n"
+"\n"
+"      Some information will be lost when a :class:`Date` is converted to \n"
+"      a lower frequency and then back to the original one.\n"
+"      For example, if a daily :class:`Date` is converted to monthly and \n"
+"      then back to a daily one, the :attr:`day` information is lost::\n"
+"\n"
+"         >>> D = ts.Date('D', year=2007, month=12, day=15)\n"
+"         >>> D.asfreq('M')\n"
+"         <M: Dec-2007>\n"
+"         >>> D.asfreq('M').asfreq('D', relation='START')\n"
+"         <D: 01-Dec-2007>\n"
+"         >>> D.asfreq('M').asfreq('D', relation=\"END\")\n"
+"         <D: 31-Dec-2007>\n"
+"\n";
+
+
+static PyObject*
+DatetimeObject_convert(DatetimeObject *self, PyObject *args, PyObject *kwds)
+{
+    PyObject *freq=NULL;
+    char *relation_raw=NULL;
+    char *relation_uc;
+    conversion_function tomediator, frommediator;
+    char relation;
+    int invalid_relation=0;
+    int tofreq;
+
+    static char *kwlist[] = {"freq", "relation", NULL};
+
+    if (! PyArg_ParseTupleAndKeywords(args, kwds, "O|s", kwlist,
+                                      &freq, &relation_raw)) return NULL;
+
+    if(relation_raw) {
+        if (strlen(relation_raw) > 0) {
+            if ((relation_uc = str_uppercase(relation_raw)) == NULL)
+                return PyErr_NoMemory();
+            // 'BEFORE' and 'AFTER' values for this parameter are deprecated
+            if (strcmp(relation_uc, "END") == 0 ||
+                strcmp(relation_uc, "E") == 0 ||
+                strcmp(relation_uc, "START") == 0 ||
+                strcmp(relation_uc, "S") == 0 ||
+                strcmp(relation_uc, "BEFORE") == 0 ||
+                strcmp(relation_uc, "B") == 0 ||
+                strcmp(relation_uc, "AFTER") == 0 ||
+                strcmp(relation_uc, "A") == 0) {
+                 if (relation_uc[0] == 'E' || relation_uc[0] == 'A')
+                     relation = 'E';
+                 else
+                     relation = 'S';
+            } else { invalid_relation=1; }
+            free(relation_uc);
+        } else {
+            invalid_relation=1;
+        }
+        if (invalid_relation) {
+            PyErr_SetString(PyExc_ValueError,"Invalid relation specification");
+            return NULL;
+        }
+    } else {
+        relation = 'E';
+    }
+
+    if (relation == 'S')
+        self->obmeta.convert_to_start = 1;
+    else
+        self->obmeta.convert_to_start = 0;
+
+    if ((tofreq = check_freq(freq)) == INT_ERR_CODE)
+        return NULL;
+
+    DatetimeObject *result = DatetimeObject_New();
+
+    init_metadata_from_unit(&result->obmeta, tofreq);
+    result->obmeta.convert_to_start = self->obmeta.convert_to_start;
+
+    int fromfreq = self->obmeta.unit;
+    if (tofreq == fromfreq) {
+        result->obval = self->obval;
+        return (PyObject*)result;
+    }
+
+    /* Correction for business days */
+    if ((tofreq == FR_BUS) && (fromfreq < FR_DAY))
+        result->obmeta.convert_to_start = 1;
+
+    tomediator = convert_to_mediator(fromfreq, tofreq, 1);
+    frommediator = convert_from_mediator(fromfreq, tofreq, 1);
+    result->obval = frommediator(tomediator(self->obval, &(self->obmeta)), &(result->obmeta));
+    return (PyObject *)result;
+}
+
+
+
+static char DatetimeObject_strfmt_doc[] =
+"Deprecated alias for strftime method";
+
+static char DatetimeObject_strftime_doc[] =
+"\n"
+"   Returns the string representation of the :class:`Date`, \n"
+"   depending on the selected :keyword:`format`.\n"
+"   :keyword:`format` must be a string containing one or several directives.\n"
+"   The method recognizes the same directives as the :func:`time.strftime` \n"
+"   function of the standard Python distribution, as well as the specific \n"
+"   additional directives ``%f``, ``%F``, ``%q``.\n"
+"\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | Directive | Meaning                        | Notes |\n"
+"   +===========+================================+=======+\n"
+"   | ``%a``    | Locale's abbreviated weekday   |       |\n"
+"   |           | name.                          |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%A``    | Locale's full weekday name.    |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%b``    | Locale's abbreviated month     |       |\n"
+"   |           | name.                          |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%B``    | Locale's full month name.      |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%c``    | Locale's appropriate date and  |       |\n"
+"   |           | time representation.           |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%d``    | Day of the month as a decimal  |       |\n"
+"   |           | number [01,31].                |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%f``    | 'Fiscal' year without a        | \(1)  |\n"
+"   |           | century  as a decimal number   |       |\n"
+"   |           | [00,99]                        |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%F``    | 'Fiscal' year with a century   | \(2)  |\n"
+"   |           | as a decimal number            |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%H``    | Hour (24-hour clock) as a      |       |\n"
+"   |           | decimal number [00,23].        |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%I``    | Hour (12-hour clock) as a      |       |\n"
+"   |           | decimal number [01,12].        |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%j``    | Day of the year as a decimal   |       |\n"
+"   |           | number [001,366].              |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%m``    | Month as a decimal number      |       |\n"
+"   |           | [01,12].                       |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%M``    | Minute as a decimal number     |       |\n"
+"   |           | [00,59].                       |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%p``    | Locale's equivalent of either  | \(3)  |\n"
+"   |           | AM or PM.                      |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%q``    | Quarter as a decimal number    |       |\n"
+"   |           | [01,04]                        |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%S``    | Second as a decimal number     | \(4)  |\n"
+"   |           | [00,61].                       |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%U``    | Week number of the year        | \(5)  |\n"
+"   |           | (Sunday as the first day of    |       |\n"
+"   |           | the week) as a decimal number  |       |\n"
+"   |           | [00,53].  All days in a new    |       |\n"
+"   |           | year preceding the first       |       |\n"
+"   |           | Sunday are considered to be in |       |\n"
+"   |           | week 0.                        |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%w``    | Weekday as a decimal number    |       |\n"
+"   |           | [0(Sunday),6].                 |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%W``    | Week number of the year        | \(5)  |\n"
+"   |           | (Monday as the first day of    |       |\n"
+"   |           | the week) as a decimal number  |       |\n"
+"   |           | [00,53].  All days in a new    |       |\n"
+"   |           | year preceding the first       |       |\n"
+"   |           | Monday are considered to be in |       |\n"
+"   |           | week 0.                        |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%x``    | Locale's appropriate date      |       |\n"
+"   |           | representation.                |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%X``    | Locale's appropriate time      |       |\n"
+"   |           | representation.                |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%y``    | Year without century as a      |       |\n"
+"   |           | decimal number [00,99].        |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%Y``    | Year with century as a decimal |       |\n"
+"   |           | number.                        |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%Z``    | Time zone name (no characters  |       |\n"
+"   |           | if no time zone exists).       |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"   | ``%%``    | A literal ``'%'`` character.   |       |\n"
+"   +-----------+--------------------------------+-------+\n"
+"\n"
+"   .. note::\n"
+"\n"
+"      (1)\n"
+"         The ``%f`` directive is the same as ``%y`` if the frequency is \n"
+"         not quarterly.\n"
+"         Otherwise, it corresponds to the 'fiscal' year, as defined by \n"
+"         the :attr:`qyear` attribute.\n"
+"\n"
+"      (2)\n"
+"         The ``%F`` directive is the same as ``%Y`` if the frequency is \n"
+"         not quarterly.\n"
+"         Otherwise, it corresponds to the 'fiscal' year, as defined by \n"
+"         the :attr:`qyear` attribute.\n"
+"\n"
+"      (3)\n"
+"         The ``%p`` directive only affects the output hour field \n"
+"         if the ``%I`` directive is used to parse the hour.\n"
+"\n"
+"      (4)\n"
+"         The range really is ``0`` to ``61``; this accounts for leap seconds \n"
+"         and the (very rare) double leap seconds.\n"
+"\n"
+"      (5)\n"
+"         The ``%U`` and ``%W`` directives are only used in calculations \n"
+"         when the day of the week and the year are specified.\n"
+"\n"
+"\n"
+"   .. rubric::  Examples\n"
+"\n"
+"   >>> a = ts.Date(freq='q-jul', year=2006, quarter=1)\n"
+"   >>> a.strftime('%F-Q%q')\n"
+"   '2006-Q1'\n"
+"   >>> # Output the last month in the quarter of this date\n"
+"   >>> a.strftime('%b-%Y')\n"
+"   'Oct-2005'\n"
+"   >>> \n"
+"   >>> a = ts.Date(freq='d', year=2001, month=1, day=1)\n"
+"   >>> a.strftime('%d-%b-%Y')\n"
+"   '01-Jan-2006'\n"
+"   >>> a.strftime('%b. %d, %Y was a %A')\n"
+"   'Jan. 01, 2001 was a Monday'\n";
+static PyObject *
+DatetimeObject_strftime(DatetimeObject *self, PyObject *args)
+{
+    char *orig_fmt_str, *fmt_str;
+    char *result;
+
+    int num_extra_fmts = 3;
+    char extra_fmts[3][2][10] = {{"%q", "^`AB`^"},
+                                 {"%f", "^`CD`^"},
+                                 {"%F", "^`EF`^"}};
+    int extra_fmts_found[3] = {0,0,0};
+    int extra_fmts_found_one = 0;
+    struct tm c_date;
+    ymdstruct ymd;
+    hmsstruct hms;
+    npy_int64 absdate;
+    double abstime;
+    int i, result_len;
+    PyObject *py_result;
+
+    ts_metadata meta = self->obmeta;
+
+    if (!PyArg_ParseTuple(args, "s:strftime(fmt)", &orig_fmt_str))
+        return NULL;
+
+    conversion_function convert_to_days = get_converter_to_days(meta.unit, 0);
+    meta.convert_to_start = 0;
+
+    absdate = convert_to_days(self->obval, &meta);
+    ymd = days_to_ymdstruct(absdate, GREGORIAN_CALENDAR);
+    abstime = _secs_from_midnight(self->obval, meta.unit);
+    hms = seconds_to_hmsstruct(abstime);
+
+    /* Populate standard C date struct with info from our date_info struct */
+    c_date.tm_sec = hms.sec;
+    c_date.tm_min = hms.min;
+    c_date.tm_hour = hms.hour;
+    c_date.tm_mday = ymd.day;
+    c_date.tm_mon = ymd.month - 1;
+    c_date.tm_year = ymd.year - 1900;
+    // c_date.tm_wday = (tempDate.day_of_week + 1) % 7;
+    // c_date.tm_yday = tempDate.day_of_year - 1;
+    c_date.tm_isdst = -1;
+
+    result_len = strlen(orig_fmt_str) + 50;
+    if ((result = PyArray_malloc(result_len * sizeof(char))) == NULL)
+        return PyErr_NoMemory();
+
+    fmt_str = orig_fmt_str;
+
+    // replace any special format characters with their place holder
+    for(i=0; i < num_extra_fmts; i++) {
+        char *special_loc;
+        if ((special_loc = strstr(fmt_str,extra_fmts[i][0])) != NULL) {
+            char *tmp_str = fmt_str;
+            fmt_str = str_replace(fmt_str, extra_fmts[i][0],
+                                           extra_fmts[i][1]);
+            /* only free the previous loop value if this is not the first
+               special format string found */
+            if (extra_fmts_found_one)
+                free(tmp_str);
+
+            if (fmt_str == NULL)
+                return NULL;
+
+            extra_fmts_found[i] = 1;
+            extra_fmts_found_one = 1;
+        }
+    }
+
+    strftime(result, result_len, fmt_str, &c_date);
+    if (extra_fmts_found_one)
+        free(fmt_str);
+
+    // replace any place holders with the appropriate value
+    for(i=0; i < num_extra_fmts; i++) {
+        if (extra_fmts_found[i]) {
+            char *tmp_str = result;
+            char *extra_str;
+
+            if (strcmp(extra_fmts[i][0], "%q") == 0 ||
+                strcmp(extra_fmts[i][0], "%f") == 0 ||
+                strcmp(extra_fmts[i][0], "%F") == 0) {
+
+                ts_metadata meta_qtr;
+                if (self->obmeta.unit == FR_QTR)
+                    meta_qtr = self->obmeta;
+                else
+                    init_metadata_from_unit(&meta_qtr, FR_QTR);
+
+                int year, quarter, qvals, year_len;
+                meta_qtr.convert_to_start = 0;
+//                conversion_info qtr_info;
+//                metadata_to_conversioninfo(&meta_qtr, &qtr_info);
+//                set_conversion_info(qtr_freq, 'E', &qtr_info);
+
+                qvals = (*get_converter_from_days(meta_qtr.unit, 0))(absdate, &meta_qtr);
+                quarter = qvals % 4;
+                quarter = (quarter == 0 ? 4 : quarter);
+                year = (qvals - quarter)/4 + 1;
+
+                if(strcmp(extra_fmts[i][0], "%q") == 0) {
+                    if ((extra_str = PyArray_malloc(2 * sizeof(char))) == NULL) {
+                        free(tmp_str);
+                        return PyErr_NoMemory();
+                    }
+                    sprintf(extra_str, "%i", quarter);
+                } else {
+                    if (meta_qtr.period_end_at > 12)
+                        year -= 1;
+
+                    if (strcmp(extra_fmts[i][0], "%f") == 0) {
+                        year_len = 2;
+                        year = year % 100;
+                    }
+                    else
+                        year_len = 4;
+
+                    if ((extra_str = PyArray_malloc((year_len+1) * sizeof(char))) == NULL) {
+                        free(tmp_str);
+                        return PyErr_NoMemory();
+                    }
+
+                    if (year_len == 2 && year < 10)
+                        sprintf(extra_str, "0%i", year);
+                    else
+                        sprintf(extra_str, "%i", year);
+                }
+            }
+            else {
+                PyErr_SetString(PyExc_RuntimeError,"Unrecognized format string");
+                return NULL;
+            }
+
+            result = str_replace(result, extra_fmts[i][1], extra_str);
+            free(tmp_str);
+            free(extra_str);
+            if (result == NULL) { return NULL; }
+        }
+    }
+    py_result = PyString_FromString(result);
+    free(result);
+    return py_result;
+}
+
+
+static PyObject *
+DatetimeObject___str__(DatetimeObject* self)
+{
+    int unit = self->obmeta.unit;
+    PyObject *string_arg, *retval;
+
+    string_arg = NULL;
+    if (unit == FR_UND) {
+        retval = PyString_FromFormat("%ld", (long)(self->obval));
+        return retval;
+        }
+    else if (unit == FR_ANN) { string_arg = Py_BuildValue("(s)", "%Y"); }
+    else if (unit == FR_QTR) { string_arg = Py_BuildValue("(s)", "%FQ%q"); }
+    else if (unit == FR_MTH) { string_arg = Py_BuildValue("(s)", "%b-%Y"); }
+    else if (unit == FR_DAY ||
+             unit == FR_BUS ||
+             unit == FR_WK) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y"); }
+    else if (unit == FR_HR) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y %H:00"); }
+    else if (unit == FR_MIN) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y %H:%M"); }
+    else if (unit == FR_SEC) { string_arg = Py_BuildValue("(s)", "%d-%b-%Y %H:%M:%S"); }
+
+    if (string_arg == NULL) { return NULL; }
+    retval = DatetimeObject_strftime(self, string_arg);
+    Py_DECREF(string_arg);
+    return retval;
+}
+static PyObject *
+timedelta___str__(TimeDeltaObject* self)
+{
+    PyObject  *py_str;
+    long months=get_timedelta_months(self);
+    long days=get_timedelta_days(self);
+    long seconds=get_timedelta_seconds(self);
+
+    py_str = PyString_FromFormat("%ldm, %ldd, %lds",
+                                  months, days, seconds);
+    return py_str;
+}
+
+
+
+static PyObject *
+DatetimeObject_freqstr(DatetimeObject *self, void *closure) {
+    PyObject *key = PyInt_FromLong(self->obmeta.unit);
+    PyObject *freq_aliases = PyDict_GetItem(freq_dict, key);
+    PyObject *main_alias = PyTuple_GET_ITEM(freq_aliases, 0);
+    Py_DECREF(key);
+    Py_INCREF(main_alias);
+    return main_alias;
+}
+static PyObject *
+timedelta_freqstr(TimeDeltaObject *self, void *closure) {
+    PyObject *key = PyInt_FromLong(self->unit);
+    PyObject *freq_aliases = PyDict_GetItem(freq_dict, key);
+    PyObject *main_alias = PyTuple_GET_ITEM(freq_aliases, 0);
+    Py_DECREF(key);
+    Py_INCREF(main_alias);
+    return main_alias;
+}
+
+
+
+static PyObject *
+DatetimeObject___repr__(DatetimeObject* self)
+{
+    PyObject *py_str_rep, *py_freqstr, *py_repr;
+    char *str_rep, *freqstr, *repr;
+    int repr_len;
+
+    py_str_rep = DatetimeObject___str__(self);
+    if (py_str_rep == NULL) return NULL;
+    str_rep = PyString_AsString(py_str_rep);
+
+    py_freqstr = DatetimeObject_freqstr(self, NULL);
+    freqstr = PyString_AsString(py_freqstr);
+
+    repr_len = strlen(str_rep) + strlen(freqstr) + 6;
+    MEM_CHECK((repr = PyArray_malloc((repr_len + 1) * sizeof(char))));
+
+    strcpy(repr, "<");
+    strcat(repr, freqstr);
+    strcat(repr, " : ");
+    strcat(repr, str_rep);
+    strcat(repr, ">");
+
+    py_repr = PyString_FromString(repr);
+    Py_DECREF(py_str_rep);
+    Py_DECREF(py_freqstr);
+    free(repr);
+    return py_repr;
+}
+
+static PyObject *
+timedelta___repr__(TimeDeltaObject* self)
+{
+    PyObject *py_freqstr, *py_repr;
+    char *freqstr;
+    py_freqstr = timedelta_freqstr(self, NULL);
+    freqstr = PyString_AsString(py_freqstr);
+
+    if (get_timedelta_seconds(self) != 0){
+        py_repr = PyString_FromFormat("%s(%ld, %ld, %ld)[%s]",
+                                      self->ob_type->tp_name,
+                                      self->months,
+                                      self->days,
+                                      self->seconds,
+                                      freqstr);
+        }
+    else if (self->days != 0){
+        py_repr = PyString_FromFormat("%s(%ld, %ld)[%s]",
+                                      self->ob_type->tp_name,
+                                      self->months,
+                                      self->days,
+                                      freqstr);
+        }
+    else {
+        py_repr = PyString_FromFormat("%s(%ld)[%s]",
+                                      self->ob_type->tp_name,
+                                      self->months,
+                                      freqstr);
+    }
+    Py_DECREF(py_freqstr);
+    return py_repr;
+}
+
+/******************************
+   These methods seem rather useless. May or may not implement them.
+fromordinal(self, ordinal):
+    return Date(self.freq, datetime=dt.datetime.fromordinal(ordinal))
+tostring(self):
+    return str(self)
+toobject(self):
+    return self
+isvalid(self):
+    return True
+*******************************/
+
+
+DatetimeObject *
+DatetimeObject_FromFreqAndValue(int freq, npy_int64 value) {
+    DatetimeObject *result = DatetimeObject_New();
+    init_metadata_from_unit(&result->obmeta, freq);
+    result->obval = value;
+    return result;
+}
+
+
+static TimeDeltaObject *
+timedelta_fromMDS(int unit,
+                  npy_int64 months, npy_int64 days, npy_int64 seconds)
+{
+    TimeDeltaObject *result = TimeDeltaObject_New();
+    normalize_days_secs(&days, &seconds);
+    result->unit = unit;
+    result->months = months;
+    result->days = days;
+    result->seconds = seconds;
+    return result;
+}
+
+
+
+static PyObject *
+DatetimeObject_date_plus_int(PyObject *date, PyObject *pyint) {
+    DatetimeObject *dateobj = (DatetimeObject*)date;
+    if (!PyInt_Check(pyint) && !PyObject_HasAttrString(pyint, "__int__")) {
+        return Py_NotImplemented;
+    }
+    DatetimeObject *result = DatetimeObject_New();
+    result->obmeta = dateobj->obmeta;
+    result->obval = dateobj->obval + PyInt_AsLong(pyint);
+    return (PyObject*)result;
+}
+
+
+static PyObject *
+date_plus_timedelta(PyObject *datearg, PyObject *deltaarg){
+    DatetimeObject *date = (DatetimeObject*)datearg;
+    TimeDeltaObject *delta = (TimeDeltaObject*)deltaarg;
+    DatetimeObject *result;
+
+    ts_datetimestruct dtinfo;
+    npy_int64 seconds, days, months, years=0, absdate, abstime=0;
+    // Get the info from the delta
+    seconds = delta->seconds;
+    days = delta->days;
+    months = delta->months;
+
+    if (date->obmeta.unit > FR_DAY) {
+        abstime = _secs_from_midnight(date->obval, date->obmeta.unit);
+        // Update the days and secs from the seconds since midnight
+        seconds += abstime;
+    }
+    // Make sure the seconds are between -86400 and +86400
+    normalize_days_secs(&days, &seconds);
+    set_datetimestruct_from_secs(&dtinfo, seconds);
+
+    // Convert the current date to days and set the datetimestruct
+    conversion_function todays = get_converter_to_days(date->obmeta.unit, 0);
+    date->obmeta.convert_to_start = 1;
+    absdate = todays(date->obval, &(date->obmeta));
+    set_datetimestruct_from_days(&dtinfo, absdate + days);
+
+    // Update the datetime info with the months and normalize the months
+    years = dtinfo.year;
+    months += dtinfo.month;
+    normalize_years_months(&years, &months);
+
+    // Update the structure
+    dtinfo.year = years;
+    dtinfo.month = months;
+
+    // Convert to datetime
+    result = DatetimeObject_New();
+    result->obmeta = date->obmeta;
+    result->obval = datetimestruct_to_tsdatetime(&(date->obmeta), &dtinfo);
+    return (PyObject*)result;
+
+};
+
+static PyObject *
+date_plus_delta(PyObject *datearg, PyObject *deltaarg){
+    DatetimeObject *date = (DatetimeObject*)datearg;
+    PyDateTime_Delta *delta = (PyDateTime_Delta*)deltaarg;
+    PyObject *timedelta=NULL;
+    timedelta = (PyObject*)timedelta_fromMDS(date->obmeta.unit,
+                                             0, delta->days, delta->seconds);
+    PyObject *result=NULL;
+    result = (PyObject *)date_plus_timedelta(datearg, timedelta);
+    Py_DECREF(timedelta);
+    return result;
+}
+
+
+
+static PyObject *
+DatetimeObject___add__(PyObject *left, PyObject *right)
+{
+    if (DatetimeObject_Check(left) && DatetimeObject_Check(right)) {
+        PyErr_SetString(PyExc_TypeError, "Cannot add Date to Date");
+        return NULL;
+    }
+    PyObject *result = Py_NotImplemented;
+
+    if (DatetimeObject_Check(left)) {
+        if (TimeDelta_Check(right)){
+            result = date_plus_timedelta(left, right);
+        } else if (PyDelta_Check(right)) {
+            result = date_plus_delta(left,right);
+        } else {
+            result = DatetimeObject_date_plus_int(left, right);
+        };
+    } else {
+        if (TimeDelta_Check(left)){
+            result = date_plus_timedelta(right, left);
+        } else {
+            result = DatetimeObject_date_plus_int(right, left);
+        };
+    };
+    if (result == Py_NotImplemented)
+        Py_INCREF(result);
+    return result;
+};
+
+
+static PyObject *
+DatetimeObject___subtract__(PyObject *left, PyObject *right)
+{
+    PyObject *result = Py_NotImplemented;
+
+    DatetimeObject *dleft;
+    if (!DatetimeObject_Check(left)) {
+        PyErr_SetString(PyExc_ValueError, "Cannot subtract a Date from a non-Date object.");
+        return NULL;
+    }
+    dleft = (DatetimeObject*)left;
+    if (DatetimeObject_Check(right)) {
+        DatetimeObject *dright = (DatetimeObject*)right;
+        if (dleft->obmeta.unit != dright->obmeta.unit) {
+            PyErr_SetString(PyExc_ValueError, "Cannot subtract Date objects with different frequencies.");
+            result = NULL;
+        }
+        result = PyInt_FromLong(dleft->obval - dright->obval);
+    }
+    else if (PyDate_Check(right) || PyDateTime_Check(right)) {
+        DatetimeObject *dright=DatetimeObject_New();
+        PyObject *args = PyTuple_New(0);
+        PyObject *kw = PyDict_New();
+        PyObject *py_unit = PyInt_FromLong(dleft->obmeta.unit);
+        PyDict_SetItemString(kw, "freq", py_unit);
+        PyDict_SetItemString(kw, "datetime", right);
+        Py_DECREF(py_unit);
+        ///
+        DatetimeObject_init(dright, args, kw);
+        Py_DECREF(args);
+        Py_DECREF(kw);
+        result = PyInt_FromLong(dleft->obval - dright->obval);
+        Py_DECREF(dright);
+    }
+    else if (TimeDelta_Check(right)){
+        PyObject *minus_right = PyNumber_Negative(right);
+        if (minus_right){
+            result = date_plus_timedelta(left, minus_right);
+            Py_DECREF(minus_right);
+        } else {
+            result = NULL;
+        }
+    }
+    else {
+        DatetimeObject *dtresult = DatetimeObject_New();
+        dtresult->obmeta = dleft->obmeta;
+        dtresult->obval = dleft->obval - PyLong_AsLong(right);
+        result = (PyObject *)dtresult;
+    }
+
+    if (result == Py_NotImplemented)
+        Py_INCREF(result);
+    return result;
+}
+
+static PyObject *
+timedelta_negative(TimeDeltaObject *self){
+    TimeDeltaObject *result = TimeDeltaObject_New();
+    result->unit = self->unit;
+    result->months = -get_timedelta_months(self);
+    result->days = -get_timedelta_days(self);
+    result->seconds = -get_timedelta_seconds(self);
+    return (PyObject *)result;
+}
+
+
+static PyObject *
+timedelta_plus_timedelta(PyObject *tdaobj, PyObject *tdbobj) {
+    TimeDeltaObject *tda = (TimeDeltaObject*)tdaobj;
+    TimeDeltaObject *tdb = (TimeDeltaObject*)tdbobj;
+    npy_int64 months = get_timedelta_months(tda) + get_timedelta_months(tdb);
+    npy_int64 days = get_timedelta_days(tda) + get_timedelta_days(tdb);
+    npy_int64 seconds = get_timedelta_seconds(tda) + get_timedelta_seconds(tdb);
+    normalize_days_secs(&days, &seconds);
+    //
+    return (PyObject*)timedelta_fromMDS(tda->unit, months, days, seconds);
+
+};
+
+
+static PyObject *
+timedelta_plus_int(PyObject *timedelta, PyObject *pyint) {
+    TimeDeltaObject *deltaobj = (TimeDeltaObject*)timedelta;
+    if (!PyInt_Check(pyint) && !PyObject_HasAttrString(pyint, "__int__")) {
+        // invalid type for addition
+        char *err_str, *type_str;
+        PyObject *type_repr, *obj_type;
+        obj_type = PyObject_Type(pyint);
+        type_repr = PyObject_Repr(obj_type);
+        type_str = PyString_AsString(type_repr);
+        if ((err_str = PyArray_malloc(255 * sizeof(char))) == NULL) {
+            return PyErr_NoMemory();
+        }
+        sprintf(err_str, "Cannot add TimeDelta and %s", type_str);
+        Py_DECREF(obj_type);
+        Py_DECREF(type_repr);
+        PyErr_SetString(PyExc_TypeError, err_str);
+        free(err_str);
+        return NULL;
+    }
+    int freq_group = get_base_unit(deltaobj->unit);
+    long years=0, months=0, days=0, seconds=0;
+    switch(freq_group){
+        case FR_ANN:
+            years = PyInt_AsLong(pyint);
+            break;
+        case FR_QTR:
+            months = PyInt_AsLong(pyint);
+            months *= 3;
+            break;
+        case FR_MTH:
+            months = PyInt_AsLong(pyint);
+            break;
+        case FR_WK:
+            days = PyInt_AsLong(pyint);
+            days *= 7;
+            break;
+        case FR_BUS:
+            days = PyInt_AsLong(pyint);
+            break;
+        case FR_DAY:
+            days = PyInt_AsLong(pyint);
+            break;
+        case FR_HR:
+            seconds = PyInt_AsLong(pyint);
+            seconds *= 3600;
+            break;
+        case FR_MIN:
+            seconds = PyInt_AsLong(pyint);
+            seconds *= 60;
+            break;
+        case FR_SEC:
+            seconds = PyInt_AsLong(pyint);
+            break;
+        default:
+            days = PyInt_AsLong(pyint);
+            break;
+    }
+    return (PyObject*)timedelta_fromMDS(deltaobj->unit,
+                                        deltaobj->months+months+12*years,
+                                        deltaobj->days+days,
+                                        deltaobj->seconds+seconds);
+};
+
+static PyObject *
+timedelta_plus_delta(PyObject *left, PyObject *right){
+    TimeDeltaObject *oleft = (TimeDeltaObject*)left;
+    PyDateTime_Delta *oright = (PyDateTime_Delta*)right;
+    PyObject *result=NULL;
+    npy_int64 days = oleft->days + oright->days;
+    npy_int64 seconds = oleft->seconds + oright->seconds;
+    normalize_days_secs(&days, &seconds);
+    result = (PyObject*)timedelta_fromMDS(oleft->unit,
+                                          oleft->months, days, seconds);
+    return result;
+}
+
+
+static PyObject *
+timedelta_add(PyObject *left, PyObject *right)
+{
+    PyObject *result = Py_NotImplemented;
+
+    if (TimeDelta_Check(left)) {
+        if (TimeDelta_Check(right))
+            result = timedelta_plus_timedelta(left, right);
+        else if (PyDelta_Check(right))
+            result = timedelta_plus_delta(left, right);
+        else if (PyInt_Check(right) || PyLong_Check(right))
+            result = timedelta_plus_int(left, right);
+        }
+    else if (PyDelta_Check(left))
+        result = timedelta_plus_delta(right, left);
+    else if (PyInt_Check(left) || PyLong_Check(left))
+        result = timedelta_plus_int(right,left);
+
+    if (result == Py_NotImplemented)
+        Py_INCREF(result);
+    return result;
+};
+
+
+static PyObject *
+timedelta_subtract(PyObject *left, PyObject *right)
+{
+    PyObject *result = Py_NotImplemented;
+
+    if (!TimeDelta_Check(left))
+        PyErr_SetString(PyExc_ValueError, "Cannot subtract a TimeDelta from a non-TimeDelta object.");
+
+    if (TimeDelta_Check(right)) {
+        PyObject *minus_right = PyNumber_Negative(right);
+        result = timedelta_plus_timedelta(left, minus_right);
+    }
+    else {
+        PyObject *minus_right = PyNumber_Negative(right);
+        if (minus_right) {
+            if (PyDelta_Check(right))
+                result = timedelta_plus_delta(left, minus_right);
+            else if (TimeDelta_Check(right))
+                result = timedelta_plus_timedelta(left, minus_right);
+            else
+                result = timedelta_plus_int(left, minus_right);
+            Py_DECREF(minus_right);
+        }
+        else {
+            result = NULL;
+        };
+    };
+    if (result == Py_NotImplemented)
+        Py_INCREF(result);
+    return result;
+}
+
+
+static PyObject *
+timedelta_times_int(PyObject *delta, PyObject *py_int)
+{
+    TimeDeltaObject *deltaobj = (TimeDeltaObject*)delta;
+    TimeDeltaObject *result = TimeDeltaObject_New();
+    long factor = PyInt_AsLong(py_int);
+    result->unit = deltaobj->unit;
+    result->months = get_timedelta_months(deltaobj) * factor;
+    result->days = get_timedelta_days(deltaobj) * factor;
+    result->seconds = get_timedelta_seconds(deltaobj) * factor;
+    return (PyObject *)result;
+};
+
+
+#define NUM_CHECK(o) (PyInt_Check(o) || PyLong_Check(o) || PyFloat_Check(o))
+
+
+static PyObject *
+timedelta_multiply(PyObject *left, PyObject *right) {
+    PyObject *result = Py_NotImplemented;
+
+    if (TimeDelta_Check(left)) {
+        if (NUM_CHECK(right))
+            result = timedelta_times_int(left, right);
+    }
+    else if (NUM_CHECK(left)) {
+        result = timedelta_times_int(right, left);
+    };
+    if (result == Py_NotImplemented)
+        Py_INCREF(result);
+    return result;
+}
+
+
+
+
+static int
+DatetimeObject___compare__(DatetimeObject * obj1, DatetimeObject * obj2)
+{
+    if (obj1->obmeta.unit != obj2->obmeta.unit) {
+        PyErr_SetString(PyExc_ValueError,
+                        "Cannot compare Date objects with different frequencies.");
+        return -1;
+    }
+    if (obj1->obval < obj2->obval) return -1;
+    if (obj1->obval > obj2->obval) return 1;
+    if (obj1->obval == obj2->obval) return 0;
+    return -1;
+}
+
+static int
+TimeDeltaObject___compare__(TimeDeltaObject * obj1, TimeDeltaObject * obj2)
+{
+//    if (obj1->unit != obj2->unit) {
+//        PyErr_SetString(PyExc_ValueError,
+//                        "Cannot compare Date objects with different frequencies.");
+//        return -1;
+//    }
+//    if (obj1->value < obj2->value) return -1;
+//    if (obj1->value > obj2->value) return 1;
+//    if (obj1->value == obj2->value) return 0;
+//    return -1;
+    return -1;
+}
+
+
+
+static long
+DatetimeObject___hash__(DatetimeObject *self)
+{
+    /* within a given frequency, hash values are guaranteed to be unique
+       for different dates. For different frequencies, we make a reasonable
+       effort to ensure hash values will be unique, but it is not guaranteed */
+    if (self->obmeta.unit == FR_BUS) {
+        return self->obval + 10000000;
+    } else if (self->obmeta.unit == FR_WK) {
+        return self->obval + 100000000;
+    } else {
+        return self->obval;
+    };
+}
+static long
+TimeDeltaObject___hash__(TimeDeltaObject *self)
+{
+//    register int freq_group = get_base_unit(self->freq);
+//    /* within a given frequency, hash values are guaranteed to be unique
+//       for different dates. For different frequencies, we make a reasonable
+//       effort to ensure hash values will be unique, but it is not guaranteed */
+//    if (freq_group == FR_BUS) {
+//        return self->value + 10000000;
+//    } else if (freq_group == FR_WK) {
+//        return self->value + 100000000;
+//    } else {
+//        return self->value;
+//    };
+    return -1;
+}
+
+
+static PyObject *
+DatetimeObject_toint(DatetimeObject *self) {
+    return PyInt_FromLong(self->obval);
+}
+
+static PyObject *
+DatetimeObject_tofloat(DatetimeObject *self) {
+    return PyFloat_FromDouble((double)(self->obval));
+}
+
+static PyObject *
+DatetimeObject_tolong(DatetimeObject *self) {
+    return PyLong_FromLong(self->obval);
+}
+
+
+
+/***************************************************
+           ====== Date Properties ======
+****************************************************/
+
+static PyObject *
+DatetimeObject_unit(DatetimeObject *self) {
+    int unit = self->obmeta.unit;
+    int period_end_at = self->obmeta.period_end_at;
+    if (period_end_at > 0)
+        return PyInt_FromLong(unit + period_end_at);
+    return PyInt_FromLong(unit);
+}
+static PyObject *
+DatetimeObject_timestep(DatetimeObject *self) {
+    return PyInt_FromLong(self->obmeta.timestep);
+}
+
+
+// helper function for date property funcs
+static int
+DatetimeObject_set_datestruct(DatetimeObject *self, ts_datetimestruct *dinfo) {
+    conversion_function todays = get_converter_to_days(self->obmeta.unit, 0);
+    self->obmeta.convert_to_start = 0;
+    npy_int64 days = todays(self->obval, &(self->obmeta));
+    set_datetimestruct_from_days(dinfo, days);
+    return 0;
+}
+
+// helper function for date property funcs
+static int
+DatetimeObject_set_datetimestruct(DatetimeObject *self, ts_datetimestruct *dinfo) {
+    conversion_function todays = get_converter_to_days(self->obmeta.unit, 0);
+    self->obmeta.convert_to_start = 0;
+    npy_int64 absdate = todays(self->obval, &(self->obmeta));
+    npy_int64 abstime = _secs_from_midnight(self->obval, self->obmeta.unit);
+    set_datetimestruct_from_days_and_secs(dinfo, absdate, abstime);
+    return 0;
+}
+
+
+static PyObject *
+DatetimeObject_year(DatetimeObject *self, void *closure) {
+    ts_datetimestruct dinfo;
+    DatetimeObject_set_datestruct(self, &dinfo);
+    return PyInt_FromLong(dinfo.year);
+}
+PyObject *
+_loop_get_year(npy_int64 value, int unit,
+               conversion_function todays, ts_metadata *meta,
+               ts_datetimestruct *dinfo)
+{
+    npy_int64 absdate = (*todays)(value, meta);
+    set_datetimestruct_from_days(dinfo, absdate);
+    return PyInt_FromLong(dinfo->year);
+}
+
+
+static PyObject *
+DatetimeObject_qyear(DatetimeObject *self, void *closure) {
+    ts_datetimestruct dinfo;
+    DatetimeObject_set_datestruct(self, &dinfo);
+    int year = dinfo.year;
+
+    if (self->obmeta.unit == FR_QTR) {
+        int end_month = self->obmeta.period_end_at;
+        if (end_month == 0)
+            end_month = 12;
+        else if (end_month > 12) {
+            end_month -= 12;
+            year -= 1;
+        }
+        if (dinfo.month > end_month)
+            year += 1;
+    }
+    return PyInt_FromLong(year);
+}
+PyObject *
+_loop_get_qyear(npy_int64 value, int unit,
+                conversion_function todays, ts_metadata *meta,
+                ts_datetimestruct *dinfo)
+{
+    npy_int64 absdate = (*todays)(value, meta);
+    set_datetimestruct_from_days(dinfo, absdate);
+    return PyInt_FromLong(dinfo->year);
+}
+PyObject *
+_loop_get_qyear_from_qtr(npy_int64 value, int unit,
+                         conversion_function todays, ts_metadata *meta,
+                         ts_datetimestruct *dinfo)
+{
+    int ending_month = meta->period_end_at;
+    if (ending_month == 0)
+        ending_month = 12;
+    npy_int64 absdate = (*todays)(value, meta);
+    set_datetimestruct_from_days(dinfo, absdate);
+    if (dinfo->month > ending_month)
+        return PyInt_FromLong(dinfo->year+1);
+    return PyInt_FromLong(dinfo->year);
+}
+
+
+static PyObject *
+DatetimeObject_quarter(DatetimeObject *self, void *closure) {
+    ts_datetimestruct dinfo;
+    DatetimeObject_set_datestruct(self, &dinfo);
+    int month = dinfo.month;
+    int end_month = ending_month(&(self->obmeta));
+
+    if (self->obmeta.unit == FR_QTR)
+        month = dinfo.month - end_month;
+        if (month <= 0)
+            month += 12;
+    return PyInt_FromLong(month_to_quarter(month));
+}
+PyObject *
+_loop_get_quarter(npy_int64 value, int unit,
+                  conversion_function todays, ts_metadata *meta,
+                  ts_datetimestruct *dinfo)
+{
+    npy_int64 absdate = (*todays)(value, meta);
+    set_datetimestruct_from_days(dinfo, absdate);
+    return PyInt_FromLong(month_to_quarter(dinfo->month));
+}
+PyObject *
+_loop_get_quarter_from_qtr(npy_int64 value, int unit,
+                           conversion_function todays, ts_metadata *meta,
+                           ts_datetimestruct *dinfo)
+{
+    npy_int64 absdate = (*todays)(value, meta);
+    set_datetimestruct_from_days(dinfo, absdate);
+    int month = dinfo->month - ending_month(meta);
+    if (month <= 0)
+        month += 12;
+    return PyInt_FromLong(month_to_quarter(month));
+}
+
+
+static PyObject *
+DatetimeObject_month(DatetimeObject *self, void *closure) {
+    ts_datetimestruct dinfo;
+    if(DatetimeObject_set_datestruct(self, &dinfo) == -1) return NULL;
+    return PyInt_FromLong(dinfo.month);
+}
+PyObject *
+_loop_get_month(npy_int64 value, int unit,
+                conversion_function todays, ts_metadata *meta,
+                ts_datetimestruct *dinfo)
+{
+    npy_int64 absdate = (*todays)(value, meta);
+    set_datetimestruct_from_days(dinfo, absdate);
+    return PyInt_FromLong(dinfo->month);
+}
+
+static PyObject *
+DatetimeObject_day(DatetimeObject *self, void *closure) {
+    ts_datetimestruct dinfo;
+    if(DatetimeObject_set_datestruct(self, &dinfo) == -1) return NULL;
+    return PyInt_FromLong(dinfo.day);
+}
+PyObject *
+_loop_get_day(npy_int64 value, int unit,
+              conversion_function todays, ts_metadata *meta,
+              ts_datetimestruct *dinfo)
+{
+    npy_int64 absdate = (*todays)(value, meta);
+    set_datetimestruct_from_days(dinfo, absdate);
+    return PyInt_FromLong(dinfo->day);
+}
+
+
+static PyObject *
+DatetimeObject_day_of_week(DatetimeObject *self, void *closure) {
+    PyObject *daily_obj;
+    daily_obj = DatetimeObject_toordinal(self);
+    npy_int64 absdate = PyInt_AsLong(daily_obj);
+    Py_DECREF(daily_obj);
+    return PyInt_FromLong(day_of_week(absdate));
+}
+static PyObject *
+DatetimeObject_weekday(DatetimeObject *self, void *closure) {
+    return DatetimeObject_day_of_week(self, closure);
+}
+PyObject *
+_loop_get_day_of_week(npy_int64 value, int unit,
+                      conversion_function todays, ts_metadata *meta,
+                      ts_datetimestruct *dinfo)
+{
+    npy_int64 absdate = (*todays)(value, meta);
+    return PyInt_FromLong(day_of_week(absdate));
+}
+
+
+static PyObject *
+DatetimeObject_day_of_year(DatetimeObject *self, void *closure) {
+    ts_datetimestruct dinfo;
+    if(DatetimeObject_set_datestruct(self, &dinfo) == -1)
+        return NULL;
+    return PyInt_FromLong(dinfo.day_of_year);
+}
+PyObject *
+_loop_get_day_of_year(npy_int64 value, int unit,
+                      conversion_function todays, ts_metadata *meta,
+                      ts_datetimestruct *dinfo)
+{
+    npy_int64 absdate = (*todays)(value, meta);
+    set_datetimestruct_from_days(dinfo, absdate);
+    return PyInt_FromLong(dinfo->day_of_year);
+}
+
+
+static PyObject *
+DatetimeObject_week(DatetimeObject *self, void *closure) {
+    ts_datetimestruct dinfo;
+    if(DatetimeObject_set_datestruct(self, &dinfo) == -1)
+        return NULL;
+    return PyInt_FromLong(isoweek_from_datetimestruct(&dinfo));
+}
+PyObject *
+_loop_get_week(npy_int64 value, int unit,
+               conversion_function todays, ts_metadata *meta,
+               ts_datetimestruct *dinfo)
+{
+    npy_int64 absdate = (*todays)(value, meta);
+    set_datetimestruct_from_days(dinfo, absdate);
+    return PyInt_FromLong(isoweek_from_datetimestruct(dinfo));
+}
+
+
+static PyObject *
+DatetimeObject_hour(DatetimeObject *self, void *closure) {
+    ts_datetimestruct dinfo;
+    if(DatetimeObject_set_datetimestruct(self, &dinfo) == -1)
+        return NULL;
+    return PyInt_FromLong(dinfo.hour);
+}
+PyObject *
+_loop_get_hour(npy_int64 value, int unit,
+               conversion_function todays, ts_metadata *meta,
+               ts_datetimestruct *dinfo)
+{
+    npy_int64 absdate = (*todays)(value, meta);
+    npy_int64 abstime = _secs_from_highfreq(value, meta) % 86400;
+    set_datetimestruct_from_days_and_secs(dinfo, absdate, abstime);
+    return PyInt_FromLong(dinfo->hour);
+}
+
+
+static PyObject *
+DatetimeObject_minute(DatetimeObject *self, void *closure) {
+    ts_datetimestruct dinfo;
+    if(DatetimeObject_set_datetimestruct(self, &dinfo) == -1)
+        return NULL;
+    return PyInt_FromLong(dinfo.min);
+}
+PyObject *
+_loop_get_minute(npy_int64 value, int unit,
+                 conversion_function todays, ts_metadata *meta,
+                 ts_datetimestruct *dinfo)
+{
+    npy_int64 absdate = (*todays)(value, meta);
+    npy_int64 abstime = _secs_from_highfreq(value, meta) % 86400;
+    set_datetimestruct_from_days_and_secs(dinfo, absdate, abstime);
+    return PyInt_FromLong(dinfo->min);
+}
+
+
+static PyObject *
+DatetimeObject_second(DatetimeObject *self, void *closure) {
+    ts_datetimestruct dinfo;
+    if(DatetimeObject_set_datetimestruct(self, &dinfo) == -1) return NULL;
+    return PyInt_FromLong(dinfo.sec);
+}
+PyObject *
+_loop_get_second(npy_int64 value, int unit,
+                 conversion_function todays, ts_metadata *meta,
+                 ts_datetimestruct *dinfo)
+{
+    npy_int64 absdate = (*todays)(value, meta);
+    npy_int64 abstime = _secs_from_highfreq(value, meta) % 86400;
+    set_datetimestruct_from_days_and_secs(dinfo, absdate, abstime);
+    return PyInt_FromLong(dinfo->sec);
+}
+
+
+//static PyObject *
+//DatetimeObject_ordinal(DatetimeObject *self, void *closure){
+//    return PyInt_FromLong((long)DatetimeObject_toordinal(self));
+//}
+PyObject *
+_loop_get_ordinal(npy_int64 value, int unit,
+                  conversion_function todays, ts_metadata *meta,
+                  ts_datetimestruct *dinfo)
+{
+    npy_int64 absdate = (*todays)(value, meta);
+    return PyInt_FromLong(absdate);
+}
+
+
+static PyObject *
+DatetimeObject_datetime(DatetimeObject *self, void *closure) {
+    PyObject *datetime;
+    int hour=0, minute=0, second=0;
+    int unit;
+    ts_datetimestruct dinfo;
+
+    if(DatetimeObject_set_datetimestruct(self, &dinfo) == -1) return NULL;
+    unit = self->obmeta.unit;
+
+    switch(unit) {
+        case FR_HR:
+            hour = dinfo.hour;
+            break;
+        case FR_MIN:
+            hour = dinfo.hour;
+            minute = dinfo.min;
+            break;
+        case FR_SEC:
+            hour = dinfo.hour;
+            minute = dinfo.min;
+            second = (int)dinfo.sec;
+            break;
+    }
+    datetime = PyDateTime_FromDateAndTime(
+                dinfo.year, dinfo.month, dinfo.day, hour, minute, second, 0);
+    return datetime;
+}
+PyObject *
+_loop_get_datetime(npy_int64 value, int unit,
+                   conversion_function todays, ts_metadata *meta,
+                   ts_datetimestruct *dinfo)
+{
+    npy_int64 absdate = (*todays)(value, meta);
+    npy_int64 abstime = 0;
+    if (unit > FR_DAY)
+        abstime = _secs_from_midnight(value, unit);
+    set_datetimestruct_from_days_and_secs(dinfo, absdate, abstime);
+    return PyDateTime_FromDateAndTime(dinfo->year, dinfo->month, dinfo->day,
+                                      dinfo->hour, dinfo->min, dinfo->sec, 0);
+}
+
+
+
+static PyObject *
+TimeDeltaObject_timedelta(TimeDeltaObject *self, void *closure) {
+    PyObject *timedelta;
+    npy_int64 days = 30.4375 * get_timedelta_months(self);
+    days += get_timedelta_days(self);
+    npy_int64 seconds=self->seconds;
+    timedelta = PyDelta_FromDSU(days, seconds, 0);
+    return timedelta;
+}
+
+
+
+static int
+DatetimeObject_ReadOnlyErr(DatetimeObject *self, PyObject *value, void *closure) {
+   PyErr_SetString(PyExc_AttributeError, "Cannot set read-only property");
+   return -1;
+}
+static int
+TimeDeltaObject_ReadOnlyErr(TimeDeltaObject *self, PyObject *value, void *closure) {
+   PyErr_SetString(PyExc_AttributeError, "Cannot set read-only property");
+   return -1;
+}
+
+static PyGetSetDef DatetimeObject_getseters[] = {
+    {"unit", (getter)DatetimeObject_unit, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the unit.", NULL},
+    {"freq", (getter)DatetimeObject_unit, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the unit.", NULL},
+    {"timestep", (getter)DatetimeObject_timestep, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the timestep.", NULL},
+    {"year", (getter)DatetimeObject_year, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the year.", NULL},
+    {"qyear", (getter)DatetimeObject_qyear, (setter)DatetimeObject_ReadOnlyErr,
+            "For quarterly frequency dates, returns the year corresponding to the\n"
+            "year end (start) month. When using QTR or QTR-E based quarterly\n"
+            "frequencies, this is the fiscal year in a financial context.\n\n"
+            "For non-quarterly dates, this simply returns the year of the date.",
+            NULL},
+    {"quarter", (getter)DatetimeObject_quarter, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the quarter.", NULL},
+    {"month", (getter)DatetimeObject_month, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the month.", NULL},
+    {"week", (getter)DatetimeObject_week, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the week.", NULL},
+    {"day", (getter)DatetimeObject_day, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the day of month.", NULL},
+    {"weekday", (getter)DatetimeObject_weekday, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the day of week.", NULL},
+    // deprecated alias for weekday property
+    {"day_of_week", (getter)DatetimeObject_weekday, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the day of week.", NULL},
+    {"day_of_year", (getter)DatetimeObject_day_of_year, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the day of year.", NULL},
+    {"second", (getter)DatetimeObject_second, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the second.", NULL},
+    {"minute", (getter)DatetimeObject_minute, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the minute.", NULL},
+    {"hour", (getter)DatetimeObject_hour, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the hour.", NULL},
+    {"freqstr", (getter)DatetimeObject_freqstr, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the string representation of frequency.", NULL},
+    {"datetime", (getter)DatetimeObject_datetime, (setter)DatetimeObject_ReadOnlyErr,
+            "Returns the Date object converted to standard python datetime object",
+            NULL},
+    {NULL}  /* Sentinel */
+};
+static PyGetSetDef TimeDeltaObject_getseters[] = {
+//    {"year", (getter)DeltaObject_year, (setter)DeltaObject_ReadOnlyErr,
+//            "Returns the year.", NULL},
+//    {"quarter", (getter)DeltaObject_quarter, (setter)DeltaObject_ReadOnlyErr,
+//            "Returns the quarter.", NULL},
+//    {"month", (getter)DeltaObject_month, (setter)DeltaObject_ReadOnlyErr,
+//            "Returns the month.", NULL},
+//    {"week", (getter)DeltaObject_week, (setter)DeltaObject_ReadOnlyErr,
+//            "Returns the week.", NULL},
+//    // deprecated alias for weekday property
+//    {"minute", (getter)DeltaObject_minute, (setter)DeltaObject_ReadOnlyErr,
+//            "Returns the minute.", NULL},
+//    {"hour", (getter)DeltaObject_hour, (setter)DeltaObject_ReadOnlyErr,
+//            "Returns the hour.", NULL},
+    {"freqstr", (getter)timedelta_freqstr, (setter)TimeDeltaObject_ReadOnlyErr,
+            "Returns the string representation of frequency.", NULL},
+    {"timedelta", (getter)TimeDeltaObject_timedelta, (setter)TimeDeltaObject_ReadOnlyErr,
+            "Returns the Delta object converted to standard python timedelta object",
+            NULL},
+    {NULL}  /* Sentinel */
+};
+
+
+
+
+static PyNumberMethods DatetimeObject_as_number = {
+    (binaryfunc)DatetimeObject___add__,      /* nb_add */
+    (binaryfunc)DatetimeObject___subtract__, /* nb_subtract */
+    0,                                   /* nb_multiply */
+    0,                                   /* nb_divide */
+    0,                                   /* nb_remainder */
+    0,                                   /* nb_divmod */
+    0,                                   /* nb_power */
+    0,                                   /* nb_negative */
+    0,                                   /* nb_positive */
+    0,                                   /* nb_absolute */
+    0,                                   /* nb_nonzero */
+    0,                                   /* nb_invert */
+    0,                                   /* nb_lshift */
+    0,                                   /* nb_rshift */
+    0,                                   /* nb_and */
+    0,                                   /* nb_xor */
+    0,                                   /* nb_or */
+    0,                                   /* nb_coerce */
+    (unaryfunc)DatetimeObject_toint,       /* nb_int */
+    (unaryfunc)DatetimeObject_tolong,      /* nb_long */
+    (unaryfunc)DatetimeObject_tofloat,     /* nb_float */
+    (unaryfunc)0,                        /* nb_oct */
+    (unaryfunc)0,                        /* nb_hex */
+};
+static PyNumberMethods TimeDeltaObject_as_number = {
+    (binaryfunc)timedelta_add,       /* nb_add */
+    (binaryfunc)timedelta_subtract,  /* nb_subtract */
+    (binaryfunc)timedelta_multiply,  /* nb_multiply */
+    0,                               /* nb_divide */
+    0,                               /* nb_remainder */
+    0,                               /* nb_divmod */
+    0,                               /* nb_power */
+    (unaryfunc)timedelta_negative,   /* nb_negative */
+    0,                               /* nb_positive */
+    0,                               /* nb_absolute */
+    0,                               /* nb_nonzero */
+    0,                               /* nb_invert */
+    0,                               /* nb_lshift */
+    0,                               /* nb_rshift */
+    0,                               /* nb_and */
+    0,                               /* nb_xor */
+    0,                               /* nb_or */
+    0,                               /* nb_coerce */
+    0,                               /* nb_int */
+    0,                               /* nb_long */
+    0,                               /* nb_float */
+    (unaryfunc)0,                    /* nb_oct */
+    (unaryfunc)0,                    /* nb_hex */
+};
+
+
+
+static PyMethodDef DatetimeObject_methods[] = {
+    {"toordinal", (PyCFunction)DatetimeObject_toordinal, METH_NOARGS,
+     DatetimeObject_toordinal_doc},
+    {"strftime", (PyCFunction)DatetimeObject_strftime, METH_VARARGS,
+     DatetimeObject_strftime_doc},
+    // deprecated alias for strftime
+    {"strfmt", (PyCFunction)DatetimeObject_strftime, METH_VARARGS,
+     DatetimeObject_strfmt_doc},
+    {"asfreq", (PyCFunction)DatetimeObject_convert, METH_VARARGS | METH_KEYWORDS,
+     DatetimeObject_asfreq_doc},
+    {"convert", (PyCFunction)DatetimeObject_convert, METH_VARARGS | METH_KEYWORDS,
+     DatetimeObject_asfreq_doc},
+    {NULL}  /* Sentinel */
+};
+//static PyMethodDef TimeDeltaObject_methods[] = {
+////    {"toordinal", (PyCFunction)DeltaObject_toordinal, METH_NOARGS,
+////     DeltaObject_toordinal_doc},
+//    {NULL}  /* Sentinel */
+//};
+
+
+
+PyTypeObject DatetimeObject_Type = {
+    PyObject_HEAD_INIT(NULL)
+    0,                               /* ob_size */
+    "timeseries.Date",               /* tp_name */
+    sizeof(DatetimeObject),              /* tp_basicsize */
+    0,                               /* tp_itemsize */
+    (destructor)DatetimeObject_dealloc,  /* tp_dealloc */
+    0,                               /* tp_print */
+    0,                               /* tp_getattr */
+    0,                               /* tp_setattr */
+    (cmpfunc)DatetimeObject___compare__, /* tp_compare */
+    (reprfunc)DatetimeObject___repr__,   /* tp_repr */
+    &DatetimeObject_as_number,           /* tp_as_number */
+    0,                               /* tp_as_sequence */
+    0,                               /* tp_as_mapping */
+    (hashfunc)DatetimeObject___hash__,   /* tp_hash */
+    0,                               /* tp_call*/
+    (reprfunc)DatetimeObject___str__,    /* tp_str */
+    0,                               /* tp_getattro */
+    0,                               /* tp_setattro */
+    0,                               /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT |             /* tp_flags */
+    Py_TPFLAGS_CHECKTYPES |
+    Py_TPFLAGS_BASETYPE,
+    "Defines a Date object, as the combination of a date and a frequency.\n"
+    "Several options are available to construct a Date object explicitly:\n\n"
+    "- Give appropriate values to the `year`, `month`, `day`, `quarter`, `hours`,\n"
+    "  `minutes`, `seconds` arguments.\n\n"
+    "  >>> td.Date(freq='Q',year=2004,quarter=3)\n"
+    "  >>> td.Date(freq='D',year=2001,month=1,day=1)\n\n"
+    "- Use the `string` keyword. This method uses a modified version of the\n"
+    "  mx.DateTime parser submodule. More information is available in its\n"
+    "  documentation.\n\n"
+    "  >>> ts.Date('D', '2007-01-01')\n\n"
+    "- Use the `datetime` keyword with an existing datetime.datetime object.\n\n"
+    "  >>> td.Date('D', datetime=datetime.datetime.now())",  /* tp_doc */
+    0,                               /* tp_traverse */
+    0,                               /* tp_clear */
+    0,                               /* tp_richcompare */
+    0,                               /* tp_weaklistoffset */
+    0,                               /* tp_iter */
+    0,                               /* tp_iternext */
+    DatetimeObject_methods,              /* tp_methods */
+    DatetimeObject_members,              /* tp_members */
+    DatetimeObject_getseters,            /* tp_getset */
+    0,                               /* tp_base */
+    0,                               /* tp_dict */
+    0,                               /* tp_descr_get */
+    0,                               /* tp_descr_set */
+    0,                               /* tp_dictoffset */
+    (initproc)DatetimeObject_init,       /* tp_init */
+    0,                               /* tp_alloc */
+    DatetimeObject_new,                  /* tp_new */
+};
+
+static PyTypeObject TimeDeltaType = {
+    PyObject_HEAD_INIT(NULL)
+    0,                                    /* ob_size */
+    "timeseries.TimeDelta",               /* tp_name */
+    sizeof(TimeDeltaObject),              /* tp_basicsize */
+    0,                                    /* tp_itemsize */
+    (destructor)TimeDeltaObject_dealloc,  /* tp_dealloc */
+    0,                                    /* tp_print */
+    0,                                    /* tp_getattr */
+    0,                                    /* tp_setattr */
+    (cmpfunc)TimeDeltaObject___compare__, /* tp_compare */
+    (reprfunc)timedelta___repr__,   /* tp_repr */
+    &TimeDeltaObject_as_number,           /* tp_as_number */
+    0,                                    /* tp_as_sequence */
+    0,                                    /* tp_as_mapping */
+    (hashfunc)TimeDeltaObject___hash__,   /* tp_hash */
+    0,                                    /* tp_call*/
+    (reprfunc)timedelta___str__,    /* tp_str */
+    0,                                    /* tp_getattro */
+    0,                                    /* tp_setattro */
+    0,                                    /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT |                  /* tp_flags */
+    Py_TPFLAGS_CHECKTYPES |
+    Py_TPFLAGS_BASETYPE,
+    "Defines a Delta object, as the combination of a date and a frequency.\n",  /* tp_doc */
+    0,                                /* tp_traverse */
+    0,                                /* tp_clear */
+    0,                                /* tp_richcompare */
+    0,                                /* tp_weaklistoffset */
+    0,                                /* tp_iter */
+    0,                                /* tp_iternext */
+    0,              /* tp_methods */
+//    DeltaObject_methods,              /* tp_methods */
+    TimeDeltaObject_members,              /* tp_members */
+    TimeDeltaObject_getseters,            /* tp_getset */
+    0,                                /* tp_base */
+    0,                                /* tp_dict */
+    0,                                /* tp_descr_get */
+    0,                                /* tp_descr_set */
+    0,                                /* tp_dictoffset */
+    (initproc)TimeDeltaObject_init,       /* tp_init */
+    0,                                    /* tp_alloc */
+    TimeDeltaObject_new,                  /* tp_new */
+};
+
+
+
+///////////////////////////////////////////////////////////////////////
+#define DICT_SETINT_STRKEY(dict, key, val) {\
+        PyObject *pyval = PyInt_FromLong(val); \
+        PyDict_SetItemString(dict, key, pyval); \
+        Py_DECREF(pyval); }
+
+
+PyObject *
+c_dates_now(PyObject *self, PyObject *args) {
+
+    PyObject *freq; //, *init_args, *init_kwargs;
+    struct tm *timeinfo;
+    ts_datetimestruct dinfo;
+    int freq_val;
+    DatetimeObject *date;
+
+
+#ifdef WIN32
+    __time64_t rawtime;
+#else
+    time_t rawtime;
+#endif
+
+    if (!PyArg_ParseTuple(args, "O:now(freq)", &freq)) return NULL;
+
+    if ((freq_val = check_freq(freq)) == INT_ERR_CODE) return NULL;
+#ifdef WIN32
+    _time64(&rawtime);
+#else
+    time(&rawtime);
+#endif
+
+
+#ifdef WIN32
+    timeinfo = _localtime64(&rawtime);
+#else
+    timeinfo = localtime(&rawtime);
+#endif
+
+    //
+    dinfo.year = timeinfo->tm_year + 1900;
+    dinfo.month = timeinfo->tm_mon + 1;
+    dinfo.day = timeinfo->tm_mday;
+    dinfo.hour = timeinfo->tm_hour;
+    dinfo.min = timeinfo->tm_min;
+    dinfo.sec = timeinfo->tm_sec;
+
+    date = DatetimeObject_New();
+    init_metadata_from_unit(&date->obmeta, freq_val);
+    date->obval = datetimestruct_to_tsdatetime(&(date->obmeta), &dinfo);
+    return (PyObject*)date;
+}
+
+
+
+PyObject *
+DateArray_asfreq(PyObject *self, PyObject *args)
+{
+    PyArrayObject *fromDates, *toDates;
+    PyArrayIterObject *iterFrom, *iterTo;
+    PyObject *fromDateObj, *toDateObj;
+    char *relation;
+    char relation_from, relation_to;
+    conversion_function converterfrom, converterto;
+//    conversion_info infofrom, infoto;
+    int fromfreq, tofreq;
+    npy_int64 fromDate, toDate, tmpDate;
+
+    ts_metadata input_meta, output_meta;
+
+    if (!PyArg_ParseTuple(args,
+                "Oiis:asfreq(fromDates, fromfreq, tofreq, relation)",
+                &fromDates, &fromfreq, &tofreq, &relation)) return NULL;
+
+    relation_from = relation[0];
+    if ((tofreq == FR_BUS) && (fromfreq < FR_DAY))
+        relation_to = 'S';
+    else
+        relation_to = relation_from;
+
+    toDates = (PyArrayObject *)PyArray_Copy(fromDates);
+
+    iterFrom = (PyArrayIterObject *)PyArray_IterNew((PyObject *)fromDates);
+    if (iterFrom == NULL)
+        return NULL;
+
+    iterTo = (PyArrayIterObject *)PyArray_IterNew((PyObject *)toDates);
+    if (iterTo == NULL)
+        return NULL;
+
+    init_metadata_from_unit(&input_meta, fromfreq);
+    if (relation_from == 'S')
+        input_meta.convert_to_start = 1;
+    fromfreq = input_meta.unit;
+    converterfrom = convert_to_mediator(fromfreq, tofreq, 0);
+
+    init_metadata_from_unit(&output_meta, tofreq);
+    if (relation_to == 'S')
+        output_meta.convert_to_start = 1;
+    tofreq = output_meta.unit;
+    converterto = convert_from_mediator(fromfreq, tofreq, 0);
+
+
+    while (iterFrom->index < iterFrom->size) {
+
+        fromDateObj = PyArray_GETITEM(fromDates, iterFrom->dataptr);
+        fromDate = PyInt_AsLong(fromDateObj);
+        tmpDate = converterfrom(fromDate, &input_meta);
+        toDate = converterto(tmpDate, &output_meta);
+        // ERR_CHECK(toDate = asfreq_main(fromDate, relation[0], &af_info));
+        toDateObj = PyInt_FromLong(toDate);
+
+        PyArray_SETITEM(toDates, iterTo->dataptr, toDateObj);
+        Py_DECREF(fromDateObj);
+        Py_DECREF(toDateObj);
+
+        PyArray_ITER_NEXT(iterFrom);
+        PyArray_ITER_NEXT(iterTo);
+    }
+    Py_DECREF(iterFrom);
+    Py_DECREF(iterTo);
+
+    return (PyObject *)toDates;
+
+}
+
+/**************************************************************
+** The following functions are used by DateArray_getDateInfo **
+** to determine how many consecutive periods will have the   **
+** same result                                               **
+**************************************************************/
+
+// also used for qyear
+int __skip_periods_year(int freq) {
+    int freq_group = get_base_unit(freq);
+    switch(freq_group)
+    {
+        case FR_QTR:
+            return 4;
+        case FR_MTH:
+            return 12;
+        case FR_WK:
+            return 51;
+        case FR_BUS:
+            return 260;
+        case FR_DAY:
+            return 365;
+        case FR_HR:
+            return 365*24;
+        case FR_MIN:
+            return 365*24*60;
+        case FR_SEC:
+            return 365*24*60*60;
+        default:
+            return 1;
+    }
+}
+int __skip_periods_quarter(int freq) {
+    int freq_group = get_base_unit(freq);
+    switch(freq_group)
+    {
+        case FR_MTH:
+            return 3;
+        case FR_WK:
+            return 12;
+        case FR_BUS:
+            return 64;
+        case FR_DAY:
+            return 90;
+        case FR_HR:
+            return 90*24;
+        case FR_MIN:
+            return 90*24*60;
+        case FR_SEC:
+            return 90*24*60*60;
+        default:
+            return 1;
+    }
+}
+int __skip_periods_month(int freq) {
+    int freq_group = get_base_unit(freq);
+    switch(freq_group)
+    {
+        case FR_WK:
+            return 3;
+        case FR_BUS:
+            return 20;
+        case FR_DAY:
+            return 28;
+        case FR_HR:
+            return 28*24;
+        case FR_MIN:
+            return 28*24*60;
+        case FR_SEC:
+            return 28*24*60*60;
+        default:
+            return 1;
+    }
+}
+// also used for day_of_year, day_of_week
+int __skip_periods_day(int freq) {
+    switch(freq)
+    {
+        case FR_HR:
+            return 24;
+        case FR_MIN:
+            return 24*60;
+        case FR_SEC:
+            return 24*60*60;
+        default:
+            return 1;
+    }
+}
+int __skip_periods_week(int freq) {
+    switch(freq)
+    {
+        case FR_BUS:
+            return 5;
+        case FR_DAY:
+            return 7;
+        case FR_HR:
+            return 7*24;
+        case FR_MIN:
+            return 7*24*60;
+        case FR_SEC:
+            return 7*24*60*60;
+        default:
+            return 1;
+    }
+}
+int __skip_periods_hour(int freq) {
+    switch(freq)
+    {
+        case FR_MIN:
+            return 60;
+        case FR_SEC:
+            return 60*60;
+        default:
+            return 1;
+    }
+}
+int __skip_periods_minute(int freq) {
+    switch(freq)
+    {
+        case FR_SEC:
+            return 60;
+        default:
+            return 1;
+    }
+}
+
+
+PyObject *
+DateArray_getdateinfo(PyObject *self, PyObject *args)
+{
+    int freq, is_full, skip_periods, counter=1, val_changed=0;
+    char *infochar;
+
+    ts_metadata meta;
+
+    PyObject *prev_val=NULL;
+    PyArrayObject *input, *output;
+    PyArrayIterObject *iterin, *iterout;
+
+//    PyObject* (*getdateparam)(DatetimeObject*, void*) = NULL;
+    PyObject* (*getdateparam)(npy_int64, int,
+                              conversion_function, ts_metadata*,
+                              ts_datetimestruct*) = NULL;
+
+    if (!PyArg_ParseTuple(args,
+                          "Oisi:getDateInfo(array, freq, info, is_full)",
+                          &input, &freq, &infochar, &is_full))
+        return NULL;
+    if (*infochar == 'P') {
+        output = (PyArrayObject *)PyArray_SimpleNew(input->nd, input->dimensions, NPY_OBJECT);
+    }
+    else {
+        output = (PyArrayObject *)PyArray_Copy(input);
+    };
+
+    conversion_function todays = get_converter_to_days(freq, 1);
+    init_metadata_from_unit(&meta, freq);
+    meta.convert_to_start = 0;
+    ts_datetimestruct dinfo;
+
+
+    iterin = (PyArrayIterObject *)PyArray_IterNew((PyObject *)input);
+    iterout = (PyArrayIterObject *)PyArray_IterNew((PyObject *)output);
+
+    switch(*infochar)
+    {
+        case 'Y': //year
+            getdateparam = &_loop_get_year;
+            skip_periods = __skip_periods_year(freq);
+            break;
+        case 'F': //"fiscal" year
+            if (get_base_unit(freq) == FR_QTR)
+                getdateparam = &_loop_get_qyear_from_qtr;
+            else
+                getdateparam = &_loop_get_qyear;
+            skip_periods = __skip_periods_year(freq);
+            break;
+        case 'Q': //quarter
+            if (get_base_unit(freq) == FR_QTR)
+                getdateparam = &_loop_get_quarter_from_qtr;
+            else
+                getdateparam = &_loop_get_quarter;
+            skip_periods = __skip_periods_quarter(freq);
+            break;
+        case 'M': //month
+            getdateparam = &_loop_get_month;
+            skip_periods = __skip_periods_month(freq);
+            break;
+        case 'D': //day
+            getdateparam = &_loop_get_day;
+            skip_periods = __skip_periods_day(freq);
+            break;
+        case 'R': //day of year
+            getdateparam = &_loop_get_day_of_year;
+            skip_periods = __skip_periods_day(freq);
+            break;
+        case 'W': //day of week
+            getdateparam = &_loop_get_day_of_week;
+            skip_periods = __skip_periods_day(freq);
+            break;
+        case 'I': //week of year
+            getdateparam = &_loop_get_week;
+            skip_periods = __skip_periods_week(freq);
+            break;
+        case 'H': //hour
+            getdateparam = &_loop_get_hour;
+            skip_periods = __skip_periods_hour(freq);
+            break;
+        case 'T': //minute
+            getdateparam = &_loop_get_minute;
+            skip_periods = __skip_periods_minute(freq);
+            break;
+        case 'S': //second
+            getdateparam = &_loop_get_second;
+            skip_periods = 1;
+            break;
+        case 'O': //toordinal
+            getdateparam = &_loop_get_ordinal;
+            skip_periods = __skip_periods_day(freq);
+            break;
+        default:
+            return NULL;
+    }
+
+    {
+        PyObject *val, *result=NULL;
+        while (iterin->index < iterin->size) {
+
+            if ((val_changed == 0) ||
+                (is_full == 0) ||
+                (prev_val == NULL) ||
+                (counter >= skip_periods)) {
+
+                   val = PyArray_GETITEM(input, iterin->dataptr);
+                   result = getdateparam(PyInt_AsLong(val), freq,
+                                         todays, &meta, &dinfo);
+
+                   if ((prev_val != NULL) &&
+                       (PyLong_AsLong(prev_val) != PyLong_AsLong(result))) {
+                       val_changed = 1;
+                       counter = 0;
+                   }
+                   Py_DECREF(val);
+//                   Py_DECREF(curr_date);
+                   if (prev_val != NULL) {
+                       Py_DECREF(prev_val);
+                   }
+                   prev_val = result;
+            }
+
+            PyArray_SETITEM(output, iterout->dataptr, result);
+
+            PyArray_ITER_NEXT(iterin);
+            PyArray_ITER_NEXT(iterout);
+
+            counter += 1;
+        }
+    }
+    if (prev_val != NULL) {
+        Py_DECREF(prev_val);
+    }
+    Py_DECREF(iterin);
+    Py_DECREF(iterout);
+    return (PyObject *) output;
+}
+
+
+PyObject *
+DateArray_getdatetime(PyObject *self, PyObject *args)
+{
+    int freq;
+
+    PyArrayObject *input, *output;
+    PyArrayIterObject *iterin, *iterout;
+
+    if (!PyArg_ParseTuple(args,
+                          "Oi:getdatetime(array, freq)", &input, &freq))
+        return NULL;
+    output = (PyArrayObject *)PyArray_SimpleNew(input->nd, input->dimensions, NPY_OBJECT);
+
+    conversion_function todays = get_converter_to_days(freq, 1);
+    ts_metadata meta = ((DatetimeObject *)self)->obmeta;
+    meta.convert_to_start = 1;
+    ts_datetimestruct dinfo;
+
+    iterin = (PyArrayIterObject *)PyArray_IterNew((PyObject *)input);
+    iterout = (PyArrayIterObject *)PyArray_IterNew((PyObject *)output);
+
+    {
+    PyObject *val, *result=NULL;
+    while (iterin->index < iterin->size) {
+        val = PyArray_GETITEM(input, iterin->dataptr);
+        result = _loop_get_datetime(PyInt_AsLong(val), freq,
+                                    todays, &meta, &dinfo);
+        PyArray_SETITEM(output, iterout->dataptr, result);
+        PyArray_ITER_NEXT(iterin);
+        PyArray_ITER_NEXT(iterout);
+        }
+    }
+    Py_DECREF(iterin);
+    Py_DECREF(iterout);
+    return (PyObject *) output;
+}
+
+
+
+
+void import_c_dates(PyObject *m)
+{
+
+    if (PyType_Ready(&DatetimeObject_Type) < 0) return;
+    if (PyType_Ready(&TimeDeltaType) < 0) return;
+
+    DateCalc_Error = PyErr_NewException("c_dates.DateCalc_Error", NULL, NULL);
+    DateCalc_RangeError = PyErr_NewException("c_dates.DateCalc_RangeError",
+                                             NULL, NULL);
+
+    import_array();
+    PyDateTime_IMPORT;
+
+    Py_INCREF(&DatetimeObject_Type);
+    PyModule_AddObject(m, "Date", (PyObject *)(&DatetimeObject_Type));
+    Py_INCREF(&TimeDeltaType);
+    PyModule_AddObject(m, "TimeDelta", (PyObject *)(&TimeDeltaType));
+
+    PyModule_AddObject(m, "DateCalc_Error", DateCalc_Error);
+    PyModule_AddObject(m, "DateCalc_RangeError", DateCalc_RangeError);
+
+}
diff --git a/pandas/src/timeseries/c_freqs.c b/pandas/src/timeseries/c_freqs.c
new file mode 100644
index 000000000..ebe61292b
--- /dev/null
+++ b/pandas/src/timeseries/c_freqs.c
@@ -0,0 +1,343 @@
+#include "c_freqs.h"
+
+
+
+//static PyObject *freq_dict, *freq_dict_rev, *freq_constants;
+
+#define DICT_SETINT_STRKEY(dict, key, val) {\
+        PyObject *pyval = PyInt_FromLong(val); \
+        PyDict_SetItemString(dict, key, pyval); \
+        Py_DECREF(pyval); }
+
+#define ADD_FREQ_CONSTANT(const_name, val) \
+    DICT_SETINT_STRKEY(freq_constants, const_name, val)
+
+#define INIT_FREQ(const_name, key, aliases) \
+    {PyObject *pykey = PyInt_FromLong(key); \
+     PyDict_SetItem(freq_dict, pykey, aliases); \
+     PyDict_SetItemString(freq_constants, const_name, pykey); \
+     Py_DECREF(pykey); \
+     Py_DECREF(aliases); }
+
+
+
+
+static int init_freq_group(int num_items, int num_roots, int base_const,
+                           char item_abbrevs[][2][10], char group_prefixes[][15],
+                           char item_const_names[][15]) {
+    int i;
+
+    for (i = 0; i < num_items; i++) {
+
+        PyObject *aliases;
+        int j, size, k;
+
+        if (i == 0) { k = 3; } else { k = 2; }
+
+        size = num_roots * k;
+
+        aliases = PyTuple_New(size);
+
+        for (j = 0; j < num_roots; j++) {
+            PyObject *alias_v1, *alias_v2;
+            char *root, *alt;
+
+            if ((root = PyArray_malloc((30) * sizeof(char))) == NULL) return INT_ERR_CODE;
+            if ((alt = PyArray_malloc((30) * sizeof(char))) == NULL) return INT_ERR_CODE;
+
+            strcpy(root, group_prefixes[j]);
+            strcpy(alt, group_prefixes[j]);
+
+            if (i == 0) {
+                PyObject *alias = PyString_FromString(root);
+                PyTuple_SET_ITEM(aliases, j*k + 2, alias);
+            }
+
+            strcat(root, "-");
+            strcat(root, item_abbrevs[i][0]);
+            strcat(alt, "-");
+            strcat(alt, item_abbrevs[i][1]);
+
+            alias_v1 = PyString_FromString(root);
+            alias_v2 = PyString_FromString(alt);
+
+            free(root);
+            free(alt);
+
+            PyTuple_SET_ITEM(aliases, j*k, alias_v1);
+            PyTuple_SET_ITEM(aliases, j*k + 1, alias_v2);
+        }
+
+        INIT_FREQ(item_const_names[i], base_const+i, aliases);
+    }
+
+    return 0;
+}
+
+/* take a dictionary with integer keys and tuples of strings for values,
+   and populate a dictionary with all the strings as keys and integers
+   for values */
+static int reverse_dict(PyObject *source, PyObject *dest) {
+    PyObject *key, *value;
+    Py_ssize_t pos = 0;
+
+    while (PyDict_Next(source, &pos, &key, &value)) {
+        PyObject *tuple_iter;
+        PyObject *item;
+
+        if((tuple_iter = PyObject_GetIter(value)) == NULL) return INT_ERR_CODE;
+
+        while ((item = PyIter_Next(tuple_iter)) != NULL) {
+            PyDict_SetItem(dest, item, key);
+            Py_DECREF(item);
+        }
+        Py_DECREF(tuple_iter);
+    }
+    return 0;
+}
+
+
+
+static int build_freq_dict(void) {
+
+    char ANN_prefixes[8][15] = { "A", "Y", "ANN", "ANNUAL", "ANNUALLY",
+                                 "YR", "YEAR", "YEARLY" };
+
+    char QTRE_prefixes[8][15] = { "Q", "QTR", "QUARTER", "QUARTERLY", "Q-E",
+                                  "QTR-E", "QUARTER-E", "QUARTERLY-E"};
+    char QTRS_prefixes[4][15] = { "Q-S", "QTR-S", "QUARTER-S", "QUARTERLY-S" };
+
+    char WK_prefixes[4][15] =  { "W", "WK", "WEEK", "WEEKLY" };
+
+    /* Note: order of this array must match up with how the Annual
+       frequency constants are lined up */
+    char month_names[12][2][10] = {
+        { "DEC", "DECEMBER" },
+        { "JAN", "JANUARY" },
+        { "FEB", "FEBRUARY" },
+        { "MAR", "MARCH" },
+        { "APR", "APRIL" },
+        { "MAY", "MAY" },
+        { "JUN", "JUNE" },
+        { "JUL", "JULY" },
+        { "AUG", "AUGUST" },
+        { "SEP", "SEPTEMBER" },
+        { "OCT", "OCTOBER" },
+        { "NOV", "NOVEMBER" }};
+
+    char day_names[7][2][10] = {
+        { "SUN", "SUNDAY" },
+        { "MON", "MONDAY" },
+        { "TUE", "TUESDAY" },
+        { "WED", "WEDNESDAY" },
+        { "THU", "THURSDAY" },
+        { "FRI", "FRIDAY" },
+        { "SAT", "SATURDAY" }};
+
+    char ANN_const_names[12][15] = {
+        "FR_ANNDEC",
+        "FR_ANNJAN",
+        "FR_ANNFEB",
+        "FR_ANNMAR",
+        "FR_ANNAPR",
+        "FR_ANNMAY",
+        "FR_ANNJUN",
+        "FR_ANNJUL",
+        "FR_ANNAUG",
+        "FR_ANNSEP",
+        "FR_ANNOCT",
+        "FR_ANNNOV"};
+
+    char QTRE_const_names[12][15] = {
+        "FR_QTREDEC",
+        "FR_QTREJAN",
+        "FR_QTREFEB",
+        "FR_QTREMAR",
+        "FR_QTREAPR",
+        "FR_QTREMAY",
+        "FR_QTREJUN",
+        "FR_QTREJUL",
+        "FR_QTREAUG",
+        "FR_QTRESEP",
+        "FR_QTREOCT",
+        "FR_QTRENOV"};
+
+    char QTRS_const_names[12][15] = {
+        "FR_QTRSDEC",
+        "FR_QTRSJAN",
+        "FR_QTRSFEB",
+        "FR_QTRSMAR",
+        "FR_QTRSAPR",
+        "FR_QTRSMAY",
+        "FR_QTRSJUN",
+        "FR_QTRSJUL",
+        "FR_QTRSAUG",
+        "FR_QTRSSEP",
+        "FR_QTRSOCT",
+        "FR_QTRSNOV"};
+
+    char WK_const_names[7][15] = {
+        "FR_WKSUN",
+        "FR_WKMON",
+        "FR_WKTUE",
+        "FR_WKWED",
+        "FR_WKTHU",
+        "FR_WKFRI",
+        "FR_WKSAT"};
+
+    PyObject *aliases;
+
+    freq_dict = PyDict_New();
+    freq_dict_rev = PyDict_New();
+    freq_constants = PyDict_New();
+
+    aliases = Py_BuildValue("(ssss)", "M", "MTH", "MONTH", "MONTHLY");
+    INIT_FREQ("FR_MTH", FR_MTH, aliases);
+
+    aliases = Py_BuildValue("(ssss)", "B", "BUS", "BUSINESS", "BUSINESSLY");
+    INIT_FREQ("FR_BUS", FR_BUS, aliases);
+
+    aliases = Py_BuildValue("(ssss)", "D", "DAY", "DLY", "DAILY");
+    INIT_FREQ("FR_DAY", FR_DAY, aliases);
+
+    aliases = Py_BuildValue("(sssss)", "H", "HR", "HOUR", "HRLY", "HOURLY");
+    INIT_FREQ("FR_HR", FR_HR, aliases);
+
+    aliases = Py_BuildValue("(ssss)", "T", "MIN", "MINUTE", "MINUTELY");
+    INIT_FREQ("FR_MIN", FR_MIN, aliases);
+
+    aliases = Py_BuildValue("(ssss)", "S", "SEC", "SECOND", "SECONDLY");
+    INIT_FREQ("FR_SEC", FR_SEC, aliases);
+
+    aliases = Py_BuildValue("(ssss)", "U", "UND", "UNDEF", "UNDEFINED");
+    INIT_FREQ("FR_UND", FR_UND, aliases);
+
+    ADD_FREQ_CONSTANT("FR_ANN", FR_ANN);
+
+    if(init_freq_group(12, 8, FR_ANN,
+        month_names, ANN_prefixes, ANN_const_names) == INT_ERR_CODE) {
+            return INT_ERR_CODE;
+    }
+
+    ADD_FREQ_CONSTANT("FR_QTR", FR_QTR);
+
+    if(init_freq_group(12, 8, FR_QTREDEC,
+        month_names, QTRE_prefixes, QTRE_const_names) == INT_ERR_CODE) {
+            return INT_ERR_CODE;
+    }
+
+    if(init_freq_group(12, 4, FR_QTRSDEC,
+        month_names, QTRS_prefixes, QTRS_const_names) == INT_ERR_CODE) {
+            return INT_ERR_CODE;
+    }
+
+    ADD_FREQ_CONSTANT("FR_WK", FR_WK);
+
+    if(init_freq_group(7, 4, FR_WK,
+                    day_names, WK_prefixes, WK_const_names) == INT_ERR_CODE) {
+            return INT_ERR_CODE;
+    }
+
+    if(reverse_dict(freq_dict, freq_dict_rev) == INT_ERR_CODE) {
+        return INT_ERR_CODE;
+    }
+
+    return 0;
+}
+
+
+/* take user specified frequency and convert to int representation
+   of the frequency */
+int check_freq(PyObject *freq_spec) {
+
+    if (PyInt_Check(freq_spec)) {
+        return (int)PyInt_AsLong(freq_spec);
+    } else if (PyString_Check(freq_spec)) {
+        char *freq_str, *freq_str_uc;
+        PyObject *freq_val;
+
+        freq_str = PyString_AsString(freq_spec);
+        if((freq_str_uc = str_uppercase(freq_str)) == NULL) {return INT_ERR_CODE;}
+
+        freq_val = PyDict_GetItemString(freq_dict_rev, freq_str_uc);
+
+        free(freq_str_uc);
+
+        if (freq_val == NULL) {
+            PyErr_SetString(PyExc_ValueError, "invalid frequency specification");
+            return INT_ERR_CODE;
+        } else {
+            int ret_val = (int)PyInt_AsLong(freq_val);
+            return ret_val;
+        }
+    } else if (freq_spec == Py_None) {
+        return FR_UND;
+    } else {
+        int retval = (int)PyInt_AsLong(freq_spec);
+        if (PyErr_Occurred()) {
+            PyErr_SetString(PyExc_ValueError, "invalid frequency specification");
+            return INT_ERR_CODE;
+        } else {
+            return retval; }
+    }
+
+}
+
+
+
+
+PyObject *
+c_freqs_check_freq(PyObject *self, PyObject *args) {
+    PyObject *freq;
+    int freq_val;
+
+    if (!PyArg_ParseTuple(args, "O:check_freq(freq)", &freq)) 
+        return NULL;
+    if ((freq_val = check_freq(freq)) == INT_ERR_CODE) 
+        return NULL;
+    return PyInt_FromLong(freq_val);
+}
+
+
+PyObject *
+c_freqs_check_freq_str(PyObject *self, PyObject *args) {
+    PyObject *alias_tuple, *result, *freq_key;
+
+    if ((freq_key = c_freqs_check_freq(self, args)) == NULL) 
+        return NULL;
+
+    alias_tuple = PyDict_GetItem(freq_dict, freq_key);
+    result = PyTuple_GET_ITEM(alias_tuple, 0);
+
+    Py_INCREF(result);
+    Py_DECREF(freq_key);
+
+    return result;
+}
+
+PyObject *
+c_freqs_get_freq_group(PyObject *self, PyObject *args) {
+    PyObject *freq;
+    int freq_val;
+    if (!PyArg_ParseTuple(args, "O:get_freq_group(freq)", &freq)) 
+        return NULL;
+    if ((freq_val = check_freq(freq)) == INT_ERR_CODE) 
+        return NULL;
+    return PyInt_FromLong(get_base_unit(freq_val));
+}
+
+
+void import_c_freqs(PyObject *m)
+{
+    if(build_freq_dict() == INT_ERR_CODE) {
+        PyErr_SetString(PyExc_ImportError,              \
+                        "initialization of module timeseries.c_dates failed");
+        return;
+    };
+
+    PyModule_AddObject(m, "freq_dict", freq_dict);
+    PyModule_AddObject(m, "freq_dict_rev", freq_dict_rev);
+    PyModule_AddObject(m, "freq_constants", freq_constants);
+
+}
+
diff --git a/pandas/src/timeseries/c_lib.c b/pandas/src/timeseries/c_lib.c
new file mode 100644
index 000000000..dc631d92c
--- /dev/null
+++ b/pandas/src/timeseries/c_lib.c
@@ -0,0 +1,221 @@
+#include "c_lib.h"
+#include "numpy/arrayobject.h"
+
+// Numpy UFUNCS
+static PyObject *NP_ADD, *NP_MULTIPLY, *NP_SUBTRACT, *NP_SQRT,
+                *NP_GREATER, *NP_GREATER_EQUAL;
+
+/*********************************************************
+** Convenience wrappers for numpy UFUNCS                **
+*********************************************************/
+PyObject*
+np_add(PyObject *left_val, PyObject *right_val) {
+
+    PyObject *result;
+
+    result = PyObject_CallFunction(
+                         NP_ADD, "OO",
+                         (PyArrayObject*)left_val,
+                         right_val);
+    return result;
+}
+
+
+
+PyObject*
+np_subtract(PyObject *left_val, PyObject *right_val) {
+
+    PyObject *result;
+
+    result = PyObject_CallFunction(
+                         NP_SUBTRACT, "OO",
+                         (PyArrayObject*)left_val,
+                         right_val);
+    return result;
+}
+
+
+
+PyObject*
+np_multiply(PyObject *left_val, PyObject *right_val) {
+
+    PyObject *result;
+
+    result = PyObject_CallFunction(
+                         NP_MULTIPLY, "OO",
+                         (PyArrayObject*)left_val,
+                         right_val);
+    return result;
+}
+
+
+
+PyObject*
+np_sqrt(PyObject *val) {
+    return PyObject_CallFunction(NP_SQRT, "(O)", val);
+}
+
+
+
+int np_greater(PyObject *left_val, PyObject *right_val) {
+
+    PyObject *temp;
+    int result;
+
+    temp = PyObject_CallFunction(
+                         NP_GREATER, "OO",
+                         (PyArrayObject*)left_val,
+                         right_val);
+
+    result = (int)PyInt_AsLong(temp);
+    Py_DECREF(temp);
+    return result;
+}
+
+
+
+int np_greater_equal(PyObject *left_val, PyObject *right_val) {
+
+    PyObject *temp;
+    int result;
+
+    temp = PyObject_CallFunction(
+                         NP_GREATER_EQUAL, "OO",
+                         (PyArrayObject*)left_val,
+                         right_val);
+
+    result = (int)PyInt_AsLong(temp);
+    Py_DECREF(temp);
+    return result;
+}
+
+
+
+char *str_uppercase(char *str) {
+    if (str) {
+        int i, len=strlen(str);
+        char *result;
+        if((result = PyArray_malloc((len + 1)*sizeof(char))) == NULL) {
+            return (char *)PyErr_NoMemory();
+        }
+        strcpy(result, str);
+
+        for (i=0;i<len;i++) {
+            switch(result[i])
+            {
+                case 'a': { result[i]='A'; break; }
+                case 'b': { result[i]='B'; break; }
+                case 'c': { result[i]='C'; break; }
+                case 'd': { result[i]='D'; break; }
+                case 'e': { result[i]='E'; break; }
+                case 'f': { result[i]='F'; break; }
+                case 'g': { result[i]='G'; break; }
+                case 'h': { result[i]='H'; break; }
+                case 'i': { result[i]='I'; break; }
+                case 'j': { result[i]='J'; break; }
+                case 'k': { result[i]='K'; break; }
+                case 'l': { result[i]='L'; break; }
+                case 'm': { result[i]='M'; break; }
+                case 'n': { result[i]='N'; break; }
+                case 'o': { result[i]='O'; break; }
+                case 'p': { result[i]='P'; break; }
+                case 'q': { result[i]='Q'; break; }
+                case 'r': { result[i]='R'; break; }
+                case 's': { result[i]='S'; break; }
+                case 't': { result[i]='T'; break; }
+                case 'u': { result[i]='U'; break; }
+                case 'v': { result[i]='V'; break; }
+                case 'w': { result[i]='W'; break; }
+                case 'x': { result[i]='X'; break; }
+                case 'y': { result[i]='Y'; break; }
+                case 'z': { result[i]='Z'; break; }
+            }
+        }
+
+        return result;
+    } else { return NULL; }
+}
+
+
+
+char *str_replace(const char *s, const char *old, const char *new) {
+    char *ret;
+    int i, count = 0;
+    size_t newlen = strlen(new);
+    size_t oldlen = strlen(old);
+
+    for (i = 0; s[i] != '\0'; i++) {
+        if (strstr(&s[i], old) == &s[i]) {
+           count++;
+           i += oldlen - 1;
+        }
+    }
+
+    ret = PyArray_malloc(i + 1 + count * (newlen - oldlen));
+    if (ret == NULL) {return (char *)PyErr_NoMemory();}
+
+    i = 0;
+    while (*s) {
+        if (strstr(s, old) == s) {
+            strcpy(&ret[i], new);
+            i += newlen;
+            s += oldlen;
+        } else {
+            ret[i++] = *s++;
+        }
+    }
+    ret[i] = '\0';
+
+    return ret;
+}
+
+
+
+PyObject *
+set_callback(PyObject *args, PyObject **callback)
+{
+    PyObject *result = NULL;
+    PyObject *temp;
+
+    if (PyArg_ParseTuple(args, "O:set_callback", &temp)) {
+
+        if (!PyCallable_Check(temp)) {
+            PyErr_SetString(PyExc_TypeError, "parameter must be callable");
+            return NULL;
+        }
+
+        Py_XINCREF(temp);        // Add a reference to new callback
+        Py_XDECREF(*callback);  // Dispose of previous callback
+        *callback = temp;       // Remember new callback
+        // Boilerplate to return "None"
+        Py_INCREF(Py_None);
+        result = Py_None;
+    }
+    return result;
+}
+
+
+
+void import_c_lib(PyObject *m) {
+    PyObject *ops_dict;
+
+    import_array();
+
+    ops_dict = PyArray_GetNumericOps();
+
+    NP_ADD = PyDict_GetItemString(ops_dict, "add");
+    NP_MULTIPLY = PyDict_GetItemString(ops_dict, "multiply");
+    NP_SUBTRACT = PyDict_GetItemString(ops_dict, "subtract");
+    NP_SQRT = PyDict_GetItemString(ops_dict, "sqrt");
+    NP_GREATER = PyDict_GetItemString(ops_dict, "greater");
+    NP_GREATER_EQUAL = PyDict_GetItemString(ops_dict, "greater_equal");
+
+    Py_INCREF(NP_ADD);
+    Py_INCREF(NP_MULTIPLY);
+    Py_INCREF(NP_SUBTRACT);
+    Py_INCREF(NP_SQRT);
+    Py_INCREF(NP_GREATER);
+    Py_INCREF(NP_GREATER_EQUAL);
+
+    Py_DECREF(ops_dict);
+}
diff --git a/pandas/src/timeseries/c_tseries.c b/pandas/src/timeseries/c_tseries.c
new file mode 100644
index 000000000..befea75e3
--- /dev/null
+++ b/pandas/src/timeseries/c_tseries.c
@@ -0,0 +1,999 @@
+#include "c_freqs.h"
+#include "c_convert.h"
+#include "c_dates.h"
+#include "c_tseries.h"
+
+/* Helper function for TimeSeries_convert:
+    determine the size of the second dimension for the resulting
+    converted array */
+static long get_width(int fromFreq, int toFreq) {
+
+    int maxBusDaysPerYear = 262;
+    int maxBusDaysPerQuarter = 66;
+    int maxBusDaysPerMonth = 23;
+
+    int maxDaysPerYear = 366;
+    int maxDaysPerQuarter = 92;
+    int maxDaysPerMonth = 31;
+
+    int fromGroup = get_base_unit(fromFreq);
+    int toGroup = get_base_unit(toFreq);
+
+    if (fromGroup == FR_UND) { fromGroup = FR_DAY; }
+
+    switch(fromGroup)
+    {
+        case FR_ANN: return 1;
+        case FR_QTR:
+            switch(toGroup)
+            {
+                case FR_ANN: return 4;
+                default: return 1;
+            }
+        case FR_MTH: //monthly
+            switch(toGroup)
+            {
+                case FR_ANN: return 12;
+                case FR_QTR: return 3;
+                default: return 1;
+            }
+        case FR_WK: //weekly
+            switch(toGroup)
+            {
+                case FR_ANN: return 53;
+                case FR_QTR: return 13;
+                case FR_MTH: return 4;
+                default: return 1;
+            }
+        case FR_BUS: //business
+            switch(toGroup)
+            {
+                case FR_ANN: return maxBusDaysPerYear;;
+                case FR_QTR: return maxBusDaysPerQuarter;
+                case FR_MTH: return maxBusDaysPerMonth;
+                case FR_WK: return 5;
+                default: return 1;
+            }
+        case FR_DAY: //daily
+            switch(toGroup)
+            {
+                case FR_ANN: return maxDaysPerYear;;
+                case FR_QTR: return maxDaysPerQuarter;
+                case FR_MTH: return maxDaysPerMonth;
+                case FR_WK: return 7;
+                default: return 1;
+            }
+        case FR_HR: //hourly
+            switch(toGroup)
+            {
+                case FR_ANN: return 24 * maxDaysPerYear;;
+                case FR_QTR: return 24 * maxDaysPerQuarter;
+                case FR_MTH: return 24 * maxDaysPerMonth;
+                case FR_WK: return 24 * 7;
+                case FR_DAY: return 24;
+                case FR_BUS: return 24;
+                default: return 1;
+            }
+        case FR_MIN: //minutely
+            switch(toGroup)
+            {
+                case FR_ANN: return 24 * 60 * maxDaysPerYear;;
+                case FR_QTR: return 24 * 60 * maxDaysPerQuarter;
+                case FR_MTH: return 24 * 60 * maxDaysPerMonth;
+                case FR_WK: return 24 * 60 * 7;
+                case FR_DAY: return 24 * 60;
+                case FR_BUS: return 24 * 60;
+                case FR_HR: return 60;
+                default: return 1;
+            }
+        case FR_SEC: //minutely
+            switch(toGroup)
+            {
+                case FR_ANN: return 24 * 60 * 60 * maxDaysPerYear;
+                case FR_QTR: return 24 * 60 * 60 * maxDaysPerQuarter;
+                case FR_MTH: return 24 * 60 * 60 * maxDaysPerMonth;
+                case FR_WK: return 24 * 60 * 60 * 7;
+                case FR_DAY: return 24 * 60 * 60;
+                case FR_BUS: return 24 * 60 * 60;
+                case FR_HR: return 60 * 60;
+                case FR_MIN: return 60;
+                default: return 1;
+            }
+        default: return 1;
+    }
+}
+
+PyObject *
+TimeSeries_convert(PyObject *self, PyObject *args)
+{
+    PyObject *arrayTest;
+    PyArrayObject *array, *newArray;
+    PyArrayObject *mask, *newMask;
+
+    PyObject *returnVal = NULL;
+    PyObject *start_index_retval;
+
+    long period;
+    long startIndex, endIndex;
+    npy_int64 newStart, newStartTemp;
+    npy_int64 newEnd, newEndTemp;
+    long newLen, newWidth;
+    long currIndex, prevIndex;
+    long nd;
+    npy_intp *dim, *newIdx;
+    long currPerLen=0;
+    char *position;
+    PyObject *fromFreq_arg, *toFreq_arg;
+    int fromFreq, toFreq;
+    char relation_from, relation_to;
+    int i;
+    conversion_function totmp, fromtmp;
+    ts_metadata metato, metafrom;
+
+    PyObject *val, *valMask;
+
+    // long (*asfreq_main)(long, char, asfreq_info*) = NULL;
+    // long (*asfreq_endpoints)(long, char, asfreq_info*) = NULL;
+    // long (*asfreq_reverse)(long, char, asfreq_info*) = NULL;
+
+    returnVal = PyDict_New();
+
+    if (!PyArg_ParseTuple(args,
+        "OOlOslO:convert(array, fromfreq, period, tofreq, position, startindex, mask)",
+        &array, &fromFreq_arg, &period, &toFreq_arg,
+        &position, &startIndex, &mask)) return NULL;
+
+    if((fromFreq = check_freq(fromFreq_arg)) == INT_ERR_CODE)
+        return NULL;
+    if((toFreq = check_freq(toFreq_arg)) == INT_ERR_CODE)
+        return NULL;
+
+    if (toFreq == fromFreq) {
+        PyObject *sidx;
+        newArray = (PyArrayObject *)PyArray_Copy(array);
+        newMask = (PyArrayObject *)PyArray_Copy(mask);
+        sidx = PyInt_FromLong(startIndex);
+
+        PyDict_SetItemString(returnVal, "values", (PyObject*)newArray);
+        PyDict_SetItemString(returnVal, "mask", (PyObject*)newMask);
+        PyDict_SetItemString(returnVal, "startindex", sidx);
+
+        Py_DECREF(newArray);
+        Py_DECREF(newMask);
+        Py_DECREF(sidx);
+
+        return returnVal;
+    }
+
+    switch(position[0])
+    {
+        case 'S':
+            // start -> before
+            relation_to = 'S';
+            break;
+        case 'E':
+            // end -> after
+            relation_to = 'E';
+            break;
+        default:
+            return NULL;
+            break;
+    }
+    if ((toFreq == FR_BUS) && (fromFreq < FR_DAY))
+        relation_from = 'S';
+    else
+        relation_from = relation_to;
+
+    totmp = convert_to_mediator(fromFreq, toFreq, 1);
+    init_metadata_from_unit(&metato, fromFreq);
+    metato.convert_to_start = 1;
+//    set_conversion_info(fromFreq, 'S', &infoto);
+    fromtmp = convert_from_mediator(fromFreq, toFreq, 1);
+    init_metadata_from_unit(&metafrom, toFreq);
+    metafrom.convert_to_start = 1;
+//    set_conversion_info(toFreq, 'S', &infofrom);
+
+
+
+    // get_asfreq_info(fromFreq, toFreq, &af_info);
+
+    // asfreq_main = get_asfreq_func(fromFreq, toFreq, 1);
+    // asfreq_endpoints = get_asfreq_func(fromFreq, toFreq, 0);
+
+    //convert start index to new frequency
+    ERR_CHECK(newStartTemp = fromtmp(totmp(startIndex, &metato), &metafrom));
+// asfreq_main(startIndex, 'S', &af_info));
+    newStart = newStartTemp;
+//    if (newStartTemp < 1) {
+//        ERR_CHECK(newStart = asfreq_endpoints(startIndex, 'E', &af_info));
+//    } else {
+//        newStart = newStartTemp;
+//    };
+//    if (newStart < 1) {
+//        PyErr_SetString(PyExc_ValueError,
+//                        "start_date outside allowable range for destination frequency");
+//        return NULL;
+//    };
+
+    //convert end index to new frequency
+    endIndex = startIndex + (array->dimensions[0] - 1)*period;
+
+    metato.convert_to_start = (int)0;
+    metafrom.convert_to_start = (int)0;
+    ERR_CHECK(newEndTemp = fromtmp(totmp(endIndex, &metato), &metafrom));
+    // ERR_CHECK(newEndTemp = asfreq_main(endIndex, 'E', &af_info));
+//    if (newEndTemp < 1) {
+//        ERR_CHECK(newEnd = asfreq_endpoints(endIndex, 'S', &af_info));
+//    } else { newEnd = newEndTemp; }
+    newEnd = newEndTemp;
+    newLen = newEnd - newStart + 1;
+    newWidth = get_width(fromFreq, toFreq);
+    if (newWidth % period > 0){
+        newWidth = newWidth / period + 1;
+    } else {
+        newWidth /= period;
+    }
+
+    if (newWidth > 1) {
+        long tempval;
+        conversion_function totmprev, fromtmprev;
+        ts_metadata metatorev, metafromrev;
+
+
+        // get_asfreq_info(toFreq, fromFreq, &af_info_rev);
+        // asfreq_reverse = get_asfreq_func(toFreq, fromFreq, 0);
+        totmprev = convert_to_mediator(toFreq, fromFreq, 0);
+        init_metadata_from_unit(&metatorev, toFreq);
+        metatorev.convert_to_start = 1;
+//        set_conversion_info(toFreq, 'S', &metatorev);
+        fromtmprev = convert_from_mediator(toFreq, fromFreq, 0);
+//        set_conversion_info(fromFreq, 'S', &infofromrev);
+        init_metadata_from_unit(&metafromrev, fromFreq);
+        metafromrev.convert_to_start = 1;
+
+        // ERR_CHECK(tempval = asfreq_reverse(newStart, 'S', &af_info_rev));
+        ERR_CHECK(tempval = fromtmprev(totmprev(newStart, &metatorev), &metafromrev));
+        currPerLen = startIndex - tempval;
+
+        nd = 2;
+        dim = PyDimMem_NEW(nd);
+        dim[0] = (npy_intp)newLen;
+        dim[1] = (npy_intp)newWidth;
+    } else {
+        nd = 1;
+        dim = PyDimMem_NEW(nd);
+        dim[0] = (npy_intp)newLen;
+    }
+
+    newIdx = PyDimMem_NEW(nd);
+    arrayTest = PyArray_SimpleNew(nd, dim, array->descr->type_num);
+    if (arrayTest == NULL) { return NULL; }
+    newArray = (PyArrayObject*)arrayTest;
+    newMask  = (PyArrayObject*)PyArray_SimpleNew(nd, dim, mask->descr->type_num);
+
+    PyDimMem_FREE(dim);
+
+    PyArray_FILLWBYTE(newArray,0);
+    PyArray_FILLWBYTE(newMask,1);
+
+    prevIndex = newStart;
+
+    metafrom.convert_to_start = (relation_from == 'S');
+    metato.convert_to_start = (relation_to == 'S');
+
+
+    //set values in the new array
+
+    for (i = 0; i < array->dimensions[0]; i++) {
+
+        npy_intp idx = (npy_intp)i;
+
+        val = PyArray_GETITEM(array, PyArray_GetPtr(array, &idx));
+        valMask = PyArray_GETITEM(mask, PyArray_GetPtr(mask, &idx));
+
+        // ERR_CHECK(currIndex = asfreq_main(startIndex + i*period, relation, &af_info));
+        ERR_CHECK(currIndex = fromtmp(totmp(startIndex + i*period, &metato), &metafrom));
+
+        newIdx[0] = (npy_intp)(currIndex-newStart);
+
+        if (newWidth > 1) {
+            if (currIndex != prevIndex) {
+                //reset period length
+                currPerLen = 0;
+                prevIndex = currIndex;
+            }
+            newIdx[1] = (npy_intp)currPerLen;
+            currPerLen++;
+        }
+
+        if (newIdx[0] > -1) {
+            PyArray_SETITEM(newArray, PyArray_GetPtr(newArray, newIdx), val);
+            PyArray_SETITEM(newMask, PyArray_GetPtr(newMask, newIdx), valMask);
+        }
+
+        Py_DECREF(val);
+        Py_DECREF(valMask);
+
+    }
+
+    PyDimMem_FREE(newIdx);
+
+    start_index_retval = (PyObject*)PyInt_FromLong(newStart);
+
+    PyDict_SetItemString(returnVal, "values", (PyObject*)newArray);
+    PyDict_SetItemString(returnVal, "mask", (PyObject*)newMask);
+    PyDict_SetItemString(returnVal, "startindex", start_index_retval);
+
+    Py_DECREF(newArray);
+    Py_DECREF(newMask);
+    Py_DECREF(start_index_retval);
+
+    return returnVal;
+}
+
+
+/* This function is directly copied from the numpy source  */
+/* Return typenumber from dtype2 unless it is NULL, then return
+   NPY_DOUBLE if dtype1->type_num is integer or bool
+   and dtype1->type_num otherwise.
+*/
+static int
+_get_type_num_double(PyArray_Descr *dtype1, PyArray_Descr *dtype2)
+{
+    if (dtype2 != NULL) {
+        return dtype2->type_num;
+    }
+
+    /* For integer or bool data-types */
+    if (dtype1->type_num < NPY_FLOAT) {
+        return NPY_DOUBLE;
+    }
+    else {
+        return dtype1->type_num;
+    }
+}
+
+static int
+_get_type_num(PyArray_Descr *dtype1, PyArray_Descr *dtype2)
+{
+    if (dtype2 != NULL) {
+        return dtype2->type_num;
+    } else {
+        return dtype1->type_num;
+    }
+}
+
+
+/* validates the standard arguments to moving functions and set the original
+   mask, original ndarray, and mask for the result */
+static PyObject *
+check_mov_args(
+    PyObject *orig_arrayobj, int span, int min_win_size,
+    PyObject **orig_ndarray, PyObject **orig_mask, PyObject **result_mask
+) {
+
+    PyArrayObject **orig_ndarray_tmp, **result_mask_tmp;
+    int *raw_result_mask;
+
+    if (!PyArray_Check(orig_arrayobj)) {
+        PyErr_SetString(PyExc_ValueError, "array must be a valid subtype of ndarray");
+        return NULL;
+    }
+
+    // check if array has a mask, and if that mask is an array
+    if (PyObject_HasAttrString(orig_arrayobj, "_mask")) {
+        PyObject *tempMask = PyObject_GetAttrString(orig_arrayobj, "_mask");
+        if (PyArray_Check(tempMask)) {
+            *orig_mask = PyArray_EnsureArray(tempMask);
+        } else {
+            Py_DECREF(tempMask);
+        }
+    }
+
+    *orig_ndarray = PyArray_EnsureArray(orig_arrayobj);
+    orig_ndarray_tmp = (PyArrayObject**)orig_ndarray;
+
+    if ((*orig_ndarray_tmp)->nd != 1) {
+        PyErr_SetString(PyExc_ValueError, "array must be 1 dimensional");
+        return NULL;
+    }
+
+    if (span < min_win_size) {
+        char *error_str;
+        error_str = PyArray_malloc(60 * sizeof(char));
+        MEM_CHECK(error_str);
+        sprintf(error_str,
+                "span must be greater than or equal to %i",
+                min_win_size);
+        PyErr_SetString(PyExc_ValueError, error_str);
+        free(error_str);
+        return NULL;
+    }
+
+    raw_result_mask = PyArray_malloc((*orig_ndarray_tmp)->dimensions[0] * sizeof(int));
+    MEM_CHECK(raw_result_mask);
+
+    {
+        PyArrayObject *orig_mask_tmp;
+        int i, valid_points=0, is_masked;
+
+        orig_mask_tmp = (PyArrayObject*)(*orig_mask);
+
+        for (i=0; i<((*orig_ndarray_tmp)->dimensions[0]); i++) {
+
+            npy_intp idx = (npy_intp)i;
+            is_masked=0;
+
+            if (*orig_mask != NULL) {
+                PyObject *valMask;
+                valMask = PyArray_GETITEM(orig_mask_tmp,
+                                          PyArray_GetPtr(orig_mask_tmp, &idx));
+                is_masked = (int)PyInt_AsLong(valMask);
+                Py_DECREF(valMask);
+            }
+
+            if (is_masked) {
+                valid_points=0;
+            } else {
+                if (valid_points < span) { valid_points += 1; }
+                if (valid_points < span) { is_masked = 1; }
+            }
+
+            raw_result_mask[i] = is_masked;
+        }
+    }
+
+    *result_mask = PyArray_SimpleNewFromData(
+                             1, (*orig_ndarray_tmp)->dimensions,
+                             PyArray_INT32, raw_result_mask);
+    MEM_CHECK(*result_mask);
+    result_mask_tmp = (PyArrayObject**)result_mask;
+    (*result_mask_tmp)->flags = ((*result_mask_tmp)->flags) | NPY_OWNDATA;
+    return 0;
+}
+
+// check if value at specified index is masked
+static int
+_is_masked(PyArrayObject *mask, npy_intp idx) {
+
+    if (mask != NULL) {
+        PyObject *val_mask;
+        int is_masked;
+
+        val_mask = PyArray_GETITEM(mask, PyArray_GetPtr(mask, &idx));
+        is_masked = (int)PyInt_AsLong(val_mask);
+        Py_DECREF(val_mask);
+        return is_masked;
+    } else {
+        return 0;
+    }
+
+}
+
+/* computation portion of moving sum. Appropriate mask is overlayed on top
+   afterwards */
+static PyObject*
+calc_mov_sum(
+    PyArrayObject *orig_ndarray, PyArrayObject *orig_mask, int span, int rtype)
+{
+    PyArrayObject *result_ndarray=NULL;
+    int i=0, non_masked=0;
+
+    result_ndarray = (PyArrayObject*)PyArray_ZEROS(
+                                       orig_ndarray->nd,
+                                       orig_ndarray->dimensions,
+                                       rtype, 0);
+    NULL_CHECK(result_ndarray);
+
+    for (i=0; i<orig_ndarray->dimensions[0]; i++) {
+
+        PyObject *val=NULL, *mov_sum_val=NULL;
+        npy_intp idx = (npy_intp)i;
+        int curr_val_masked;
+
+        curr_val_masked = _is_masked(orig_mask, idx);
+
+        val = PyArray_GETITEM(
+            orig_ndarray, PyArray_GetPtr(orig_ndarray, &idx));
+
+        if (curr_val_masked == 0) {
+            non_masked += 1;
+        } else {
+            non_masked = 0;
+        }
+
+        if (
+            ((i == 0) || (curr_val_masked == 1)) ||
+            ((i > 0) && (_is_masked(orig_mask, i-1) == 1))
+        ) {
+            // if current or previous value is masked, reset moving sum
+            mov_sum_val = val;
+        } else {
+            PyObject *mov_sum_prevval;
+
+            idx = (npy_intp)(i-1);
+            mov_sum_prevval= PyArray_GETITEM(result_ndarray,
+                                   PyArray_GetPtr(result_ndarray, &idx));
+            mov_sum_val = np_add(val, mov_sum_prevval);
+            Py_DECREF(mov_sum_prevval);
+            NULL_CHECK(mov_sum_val);
+
+            if (non_masked > span) {
+                PyObject *temp_val, *rem_val;
+                idx = (npy_intp)(i-span);
+
+                if (_is_masked(orig_mask, idx) == 0) {
+                    // don't subtract off old value if it was masked because it
+                    // is not included in moving sum
+
+                    temp_val = mov_sum_val;
+                    rem_val = PyArray_GETITEM(orig_ndarray,
+                                       PyArray_GetPtr(orig_ndarray, &idx));
+
+                    mov_sum_val = np_subtract(temp_val, rem_val);
+                    NULL_CHECK(mov_sum_val);
+
+                    Py_DECREF(temp_val);
+                    Py_DECREF(rem_val);
+                }
+            }
+        }
+
+        idx = (npy_intp)i;
+
+        PyArray_SETITEM(result_ndarray,
+                        PyArray_GetPtr(result_ndarray, &idx),
+                        mov_sum_val);
+
+        if (mov_sum_val != val) { Py_DECREF(val); }
+
+        Py_DECREF(mov_sum_val);
+    }
+
+    return (PyObject*)result_ndarray;
+
+}
+
+PyObject *
+MaskedArray_mov_sum(PyObject *self, PyObject *args, PyObject *kwds)
+{
+    PyObject *orig_arrayobj=NULL, *orig_ndarray=NULL, *orig_mask=NULL,
+             *result_ndarray=NULL, *result_mask=NULL,
+             *result_dict=NULL;
+    PyArray_Descr *dtype=NULL;
+
+    int rtype, span, type_num_double;
+
+    static char *kwlist[] = {"array", "span", "type_num_double", "dtype", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwds,
+                "Oii|O&:mov_sum(array, span, type_num_double , dtype)", kwlist,
+                &orig_arrayobj, &span, &type_num_double,
+                PyArray_DescrConverter2, &dtype)) return NULL;
+
+    check_mov_args(orig_arrayobj, span, 1,
+                   &orig_ndarray, &orig_mask, &result_mask);
+
+    if (type_num_double) {
+        /* if the moving sum is being used as an intermediate step in something
+        like a standard deviation calculation, etc... then _get_type_num_double
+        should be used to determine the appropriate return type. */
+        rtype = _get_type_num_double(((PyArrayObject*)orig_ndarray)->descr, dtype);
+    } else {
+        rtype = _get_type_num(((PyArrayObject*)orig_ndarray)->descr, dtype);
+    }
+
+    result_ndarray = calc_mov_sum(
+        (PyArrayObject*)orig_ndarray, (PyArrayObject*)orig_mask,
+        span, rtype
+    );
+    NULL_CHECK(result_ndarray);
+
+    result_dict = PyDict_New();
+    MEM_CHECK(result_dict);
+    PyDict_SetItemString(result_dict, "array", result_ndarray);
+    PyDict_SetItemString(result_dict, "mask", result_mask);
+
+    Py_DECREF(result_ndarray);
+    Py_DECREF(result_mask);
+    return result_dict;
+}
+
+PyObject*
+calc_mov_ranked(PyArrayObject *orig_ndarray, int span, int rtype, char rank_type)
+{
+    PyArrayObject *result_ndarray=NULL;
+    PyObject **result_array, **ref_array, **even_array=NULL;
+    PyObject *new_val, *old_val;
+    PyObject *temp_add, *one_half;
+    int a, i, k, R, arr_size, z;
+    int *r;
+    npy_intp idx;
+
+    arr_size = (int)(orig_ndarray->dimensions[0]);
+
+    result_ndarray = (PyArrayObject*)PyArray_ZEROS(
+                                       orig_ndarray->nd,
+                                       orig_ndarray->dimensions,
+                                       rtype, 0);
+    NULL_CHECK(result_ndarray);
+
+    if (arr_size >= span) {
+        result_array = calloc(arr_size, sizeof(PyObject*));
+        MEM_CHECK(result_array);
+
+        /* this array will be used for quick access to the data in the original
+           array (so PyArray_GETITEM doesn't have to be used over and over in the
+           main loop) */
+        ref_array = PyArray_malloc(arr_size * sizeof(PyObject*));
+        MEM_CHECK(ref_array);
+
+        for (i=0; i<arr_size; i++) {
+            idx = (npy_intp)i;
+            ref_array[i] = PyArray_GETITEM(orig_ndarray, PyArray_GetPtr(orig_ndarray, &idx));
+        }
+
+        /* this array wll be used for keeping track of the "ranks" of the values
+           in the current window */
+        r = PyArray_malloc(span * sizeof(int));
+        MEM_CHECK(r);
+
+        for (i=0; i < span; i++) {
+            r[i] = 1;
+        }
+
+        if (rank_type == 'E' && ((span % 2) == 0)) {
+            // array to store two median values when span is an even #
+            even_array = calloc(2, sizeof(PyObject*));
+            MEM_CHECK(even_array);
+        }
+
+        switch(rank_type) {
+            case 'E': // median
+                R = (span + 1)/2;
+                break;
+            case 'I': // min
+                R = 1;
+                break;
+            case 'A': // max
+                R = span;
+                break;
+            default:
+            {
+                PyErr_SetString(PyExc_RuntimeError, "unexpected rank type");
+                return NULL;
+            }
+        }
+
+        one_half = PyFloat_FromDouble(0.5);
+
+        z = arr_size - span;
+
+        /* Calculate initial ranks "r" */
+        for (i=0; i < span; i++) {
+
+            for (k=0;   k < i;  k++) {
+                if (np_greater_equal(ref_array[z+i], ref_array[z+k])) {
+                    r[i]++;
+                }
+            }
+            for (k=i+1; k < span; k++) {
+                if (np_greater(ref_array[z+i], ref_array[z+k])) {
+                    r[i]++;
+                }
+            }
+
+            /* If rank=R, this is the median */
+            if (even_array != NULL) {
+                if (r[i]==R) {
+                    even_array[0] = ref_array[z+i];
+                } else if (r[i] == (R+1)) {
+                    even_array[1] = ref_array[z+i];
+                }
+            } else {
+                if (r[i]==R) {
+                    result_array[arr_size-1] = ref_array[z+i];
+                }
+            }
+        }
+
+        if (even_array != NULL) {
+            temp_add = np_add(even_array[0], even_array[1]);
+            result_array[arr_size-1] = np_multiply(temp_add, one_half);
+            Py_DECREF(temp_add);
+        }
+
+        for (i=arr_size-2; i >= span-1; i--) {
+            a = span;
+            z = i - span + 1;
+            old_val = ref_array[i+1];
+            new_val = ref_array[i-span+1];
+
+            for (k=span-1; k > 0; k--) {
+                r[k] = r[k-1]; /* Shift previous iteration's ranks */
+                if (np_greater_equal(ref_array[z+k], new_val)) {r[k]++; a--;}
+                if (np_greater(ref_array[z+k], old_val)) {r[k]--;}
+
+                if (r[k]==R) {
+                    result_array[i] = ref_array[z+k];
+                }
+
+                if (even_array != NULL) {
+                    if (r[k]==R) {
+                        even_array[0] = ref_array[z+k];
+                    } else if (r[k] == (R+1)) {
+                        even_array[1] = ref_array[z+k];
+                    }
+                } else {
+                    if (r[k]==R) {
+                        result_array[i] = ref_array[z+k];
+                    }
+                }
+
+            }
+
+            r[0] = a;
+
+            if (even_array != NULL) {
+                if (a==R) {
+                    even_array[0] = new_val;
+                } else if (a == (R+1)) {
+                    even_array[1] = new_val;
+                }
+
+                temp_add = np_add(even_array[0], even_array[1]);
+                result_array[i] = np_multiply(temp_add, one_half);;
+                Py_DECREF(temp_add);
+
+            } else {
+                if (a==R) {
+                    result_array[i] = new_val;
+                }
+            }
+
+        }
+
+        Py_DECREF(one_half);
+
+        for (i=span-1; i<arr_size; i++) {
+            idx = (npy_intp)i;
+            PyArray_SETITEM(result_ndarray,
+                            PyArray_GetPtr(result_ndarray, &idx),
+                            result_array[i]);
+        }
+
+        for (i=0; i<arr_size; i++) {
+            Py_DECREF(ref_array[i]);
+        }
+
+        if (even_array != NULL) {
+            for (i=span-1; i<arr_size; i++) {
+                Py_DECREF(result_array[i]);
+            }
+        }
+
+        free(ref_array);
+        free(result_array);
+    }
+
+    return (PyObject*)result_ndarray;
+
+}
+
+PyObject *
+MaskedArray_mov_median(PyObject *self, PyObject *args, PyObject *kwds)
+{
+    PyObject *orig_arrayobj=NULL, *orig_ndarray=NULL, *orig_mask=NULL,
+             *result_ndarray=NULL, *result_mask=NULL, *result_dict=NULL;
+    PyArray_Descr *dtype=NULL;
+
+    int rtype, span;
+
+    static char *kwlist[] = {"array", "span", "dtype", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwds,
+                "Oi|O&:mov_median(array, span, dtype)", kwlist,
+                &orig_arrayobj, &span,
+                PyArray_DescrConverter2, &dtype)) return NULL;
+
+    check_mov_args(orig_arrayobj, span, 1,
+                   &orig_ndarray, &orig_mask, &result_mask);
+
+    if ((span % 2) == 0) {
+        rtype = _get_type_num_double(((PyArrayObject*)orig_ndarray)->descr, dtype);
+    } else {
+        rtype = _get_type_num(((PyArrayObject*)orig_ndarray)->descr, dtype);
+    }
+
+    result_ndarray = calc_mov_ranked((PyArrayObject*)orig_ndarray,
+                                     span, rtype, 'E');
+    NULL_CHECK(result_ndarray);
+
+    result_dict = PyDict_New();
+    MEM_CHECK(result_dict);
+    PyDict_SetItemString(result_dict, "array", result_ndarray);
+    PyDict_SetItemString(result_dict, "mask", result_mask);
+
+    Py_DECREF(result_ndarray);
+    Py_DECREF(result_mask);
+    return result_dict;
+}
+
+PyObject *
+MaskedArray_mov_min(PyObject *self, PyObject *args, PyObject *kwds)
+{
+    PyObject *orig_arrayobj=NULL, *orig_ndarray=NULL, *orig_mask=NULL,
+             *result_ndarray=NULL, *result_mask=NULL, *result_dict=NULL;
+    PyArray_Descr *dtype=NULL;
+
+    int rtype, span;
+
+    static char *kwlist[] = {"array", "span", "dtype", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwds,
+                "Oi|O&:mov_min(array, span, dtype)", kwlist,
+                &orig_arrayobj, &span,
+                PyArray_DescrConverter2, &dtype)) return NULL;
+
+    check_mov_args(orig_arrayobj, span, 1,
+                   &orig_ndarray, &orig_mask, &result_mask);
+
+    rtype = _get_type_num(((PyArrayObject*)orig_ndarray)->descr, dtype);
+
+    result_ndarray = calc_mov_ranked((PyArrayObject*)orig_ndarray,
+                                     span, rtype, 'I');
+    NULL_CHECK(result_ndarray);
+
+    result_dict = PyDict_New();
+    MEM_CHECK(result_dict);
+    PyDict_SetItemString(result_dict, "array", result_ndarray);
+    PyDict_SetItemString(result_dict, "mask", result_mask);
+
+    Py_DECREF(result_ndarray);
+    Py_DECREF(result_mask);
+    return result_dict;
+}
+
+PyObject *
+MaskedArray_mov_max(PyObject *self, PyObject *args, PyObject *kwds)
+{
+    PyObject *orig_arrayobj=NULL, *orig_ndarray=NULL, *orig_mask=NULL,
+             *result_ndarray=NULL, *result_mask=NULL, *result_dict=NULL;
+    PyArray_Descr *dtype=NULL;
+
+    int rtype, span;
+
+    static char *kwlist[] = {"array", "span", "dtype", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwds,
+                "Oi|O&:mov_max(array, span, dtype)", kwlist,
+                &orig_arrayobj, &span,
+                PyArray_DescrConverter2, &dtype)) return NULL;
+
+    check_mov_args(orig_arrayobj, span, 1,
+                   &orig_ndarray, &orig_mask, &result_mask);
+
+    rtype = _get_type_num(((PyArrayObject*)orig_ndarray)->descr, dtype);
+
+    result_ndarray = calc_mov_ranked((PyArrayObject*)orig_ndarray,
+                                     span, rtype, 'A');
+    NULL_CHECK(result_ndarray);
+
+    result_dict = PyDict_New();
+    MEM_CHECK(result_dict);
+    PyDict_SetItemString(result_dict, "array", result_ndarray);
+    PyDict_SetItemString(result_dict, "mask", result_mask);
+
+    Py_DECREF(result_ndarray);
+    Py_DECREF(result_mask);
+    return result_dict;
+}
+
+/* computation portion of exponentially weighted moving average. Appropriate
+   mask is overlayed on top afterwards */
+static PyObject*
+calc_mov_average_expw(
+    PyArrayObject *orig_ndarray, PyArrayObject *orig_mask, int span, int rtype)
+{
+    PyArrayObject *result_ndarray=NULL;
+    PyObject *decay_factor=NULL;
+    int i=0, initialized=0;
+
+    result_ndarray = (PyArrayObject*)PyArray_ZEROS(
+                                       orig_ndarray->nd,
+                                       orig_ndarray->dimensions,
+                                       rtype, 0);
+    NULL_CHECK(result_ndarray);
+
+    decay_factor = PyFloat_FromDouble(2.0/((double)(span + 1)));
+
+    for (i=0; i<orig_ndarray->dimensions[0]; i++) {
+
+        PyObject *val=NULL, *mov_avg_val=NULL;
+        npy_intp idx = (npy_intp)i;
+        int curr_val_masked;
+
+        curr_val_masked = _is_masked(orig_mask, idx);
+
+        val = PyArray_GETITEM(
+            orig_ndarray, PyArray_GetPtr(orig_ndarray, &idx));
+
+        if (initialized == 0) {
+            mov_avg_val = val;
+            if (curr_val_masked == 0) {
+                initialized = 1;
+            }
+        } else {
+            PyObject *mov_avg_prevval, *temp_val_a, *temp_val_b;
+            idx = (npy_intp)(i-1);
+            mov_avg_prevval = PyArray_GETITEM(result_ndarray,
+                               PyArray_GetPtr(result_ndarray, &idx));
+
+            if (curr_val_masked == 0) {
+                temp_val_a = np_subtract(val, mov_avg_prevval);
+                temp_val_b = np_multiply(decay_factor, temp_val_a);
+                mov_avg_val = np_add(mov_avg_prevval, temp_val_b);
+
+                Py_DECREF(mov_avg_prevval);
+                Py_DECREF(temp_val_a);
+                Py_DECREF(temp_val_b);
+                NULL_CHECK(mov_avg_val);
+            } else {
+                mov_avg_val = mov_avg_prevval;
+            }
+        }
+
+        idx = (npy_intp)i;
+
+        PyArray_SETITEM(result_ndarray,
+                        PyArray_GetPtr(result_ndarray, &idx),
+                        mov_avg_val);
+
+        if (mov_avg_val != val) { Py_DECREF(val); }
+
+        Py_DECREF(mov_avg_val);
+    }
+
+    return (PyObject*)result_ndarray;
+
+}
+
+PyObject *
+MaskedArray_mov_average_expw(PyObject *self, PyObject *args, PyObject *kwds)
+{
+    PyObject *orig_arrayobj=NULL, *orig_ndarray=NULL, *orig_mask=NULL,
+             *result_ndarray=NULL, *result_mask=NULL,
+             *result_dict=NULL;
+    PyArray_Descr *dtype=NULL;
+
+    int rtype, span;
+
+    static char *kwlist[] = {"array", "span", "dtype", NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwds,
+                "Oi|O&:mov_average_expw(array, span, dtype)", kwlist,
+                &orig_arrayobj, &span,
+                PyArray_DescrConverter2, &dtype)) return NULL;
+
+    // note: we do not actually use the "result_mask" in this case
+    check_mov_args(orig_arrayobj, span, 1,
+                   &orig_ndarray, &orig_mask, &result_mask);
+
+    rtype = _get_type_num_double(((PyArrayObject*)orig_ndarray)->descr, dtype);
+
+    result_ndarray = calc_mov_average_expw(
+        (PyArrayObject*)orig_ndarray, (PyArrayObject*)orig_mask,
+        span, rtype
+    );
+    NULL_CHECK(result_ndarray);
+
+    result_dict = PyDict_New();
+    MEM_CHECK(result_dict);
+    PyDict_SetItemString(result_dict, "array", result_ndarray);
+
+    Py_DECREF(result_ndarray);
+    Py_DECREF(result_mask);
+    return result_dict;
+}
+
+void import_c_tseries(PyObject *m) { import_array(); }
diff --git a/pandas/src/timeseries/cseries.c b/pandas/src/timeseries/cseries.c
new file mode 100644
index 000000000..1205d34c6
--- /dev/null
+++ b/pandas/src/timeseries/cseries.c
@@ -0,0 +1,81 @@
+#include "c_lib.h"
+#include "c_types.h"
+#include "c_freqs.h"
+#include "c_convert.h"
+#include "c_dates.h"
+#include "c_datearray.h"
+#include "c_tseries.h"
+
+static PyMethodDef cseries_methods[] = {
+
+    {"MA_mov_sum", (PyCFunction)MaskedArray_mov_sum,
+     METH_VARARGS | METH_KEYWORDS, ""},
+    {"MA_mov_median", (PyCFunction)MaskedArray_mov_median,
+     METH_VARARGS | METH_KEYWORDS, ""},
+    {"MA_mov_min", (PyCFunction)MaskedArray_mov_min,
+     METH_VARARGS | METH_KEYWORDS, ""},
+    {"MA_mov_max", (PyCFunction)MaskedArray_mov_max,
+     METH_VARARGS | METH_KEYWORDS, ""},
+    {"MA_mov_average_expw", (PyCFunction)MaskedArray_mov_average_expw,
+     METH_VARARGS | METH_KEYWORDS, ""},
+
+    {"TS_convert", (PyCFunction)TimeSeries_convert,
+     METH_VARARGS, ""},
+
+    {"DateArray_asfreq", (PyCFunction)DateArray_asfreq,
+     METH_VARARGS, ""},
+    {"DateArray_getdateinfo", (PyCFunction)DateArray_getdateinfo,
+     METH_VARARGS, ""},
+    {"DateArray_getdatetime", (PyCFunction)DateArray_getdatetime,
+     METH_VARARGS, ""},
+
+
+    {"now", (PyCFunction)c_dates_now,
+     METH_VARARGS,
+        "now(freq)\n"
+        "\n"
+        "Returns the current date/time, at the given frequency\n"
+        "\n"
+        "Parameters\n"
+        "----------\n"
+        "freq : {freq_spec}\n"
+        "   Frequency to convert the Date to. Accepts any valid frequency\n"
+        "   specification (string or integer)\n"},
+
+    {"check_freq", (PyCFunction)c_freqs_check_freq,
+     METH_VARARGS,
+        "Translates a user specified frequency into the corresponding frequency constant"},
+
+    {"check_freq_str", (PyCFunction)c_freqs_check_freq_str,
+     METH_VARARGS,
+        "Translates a user specified frequency into standard string representation"},
+
+    {"get_freq_group", (PyCFunction)c_freqs_get_freq_group,
+     METH_VARARGS,
+        "translate user specified frequency into frequency group constant"},
+
+
+    {"set_callback_DateFromString", (PyCFunction)set_callback_DateFromString,
+     METH_VARARGS, ""},
+    {"set_callback_DateTimeFromString", (PyCFunction)set_callback_DateTimeFromString,
+     METH_VARARGS, ""},
+
+    {NULL, NULL}
+};
+
+PyMODINIT_FUNC
+initcseries(void)
+{
+    PyObject *m;
+
+    m = Py_InitModule("cseries", cseries_methods);
+    if (m == NULL)
+      return;
+
+    import_c_lib(m);
+    import_c_freqs(m);
+    import_c_dates(m);
+    import_c_datearray(m);
+    import_c_tseries(m);
+
+}
diff --git a/setup.py b/setup.py
index a80c9b0a7..d974e9fcd 100755
--- a/setup.py
+++ b/setup.py
@@ -207,7 +207,16 @@ class CleanCommand(Command):
         self.all = True
         self._clean_me = []
         self._clean_trees = []
-        self._clean_exclude = ['np_datetime.c', 'np_datetime_strings.c']
+        self._clean_exclude = ['np_datetime.c',
+                               'np_datetime_strings.c',
+                               # scikits.timeseries code
+                               'cseries.c',
+                               'c_convert.c',
+                               'c_datearray.c',
+                               'c_dates.c',
+                               'c_freqs.c',
+                               'c_lib.c',
+                               'c_tseries.c']
 
         for root, dirs, files in list(os.walk('pandas')):
             for f in files:
@@ -361,7 +370,15 @@ sandbox_ext = Extension('pandas._sandbox',
 datetime_ext = Extension('pandas._datetime',
                          sources=[srcpath('datetime', suffix=suffix),
                                           'pandas/src/np_datetime.c',
-                                          'pandas/src/np_datetime_strings.c'],
+                                          'pandas/src/np_datetime_strings.c',
+                                           # scikits.timeseries code
+                                          'pandas/src/timeseries/cseries.c',
+                                          'pandas/src/timeseries/c_convert.c',
+                                          'pandas/src/timeseries/c_datearray.c',
+                                          'pandas/src/timeseries/c_dates.c',
+                                          'pandas/src/timeseries/c_freqs.c',
+                                          'pandas/src/timeseries/c_lib.c',
+                                          'pandas/src/timeseries/c_tseries.c'],
                          include_dirs=[np.get_include()])
 
 cppsandbox_ext = Extension('pandas._cppsandbox',

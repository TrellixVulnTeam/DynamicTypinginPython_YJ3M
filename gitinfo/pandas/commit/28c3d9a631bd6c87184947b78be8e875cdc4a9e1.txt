commit 28c3d9a631bd6c87184947b78be8e875cdc4a9e1
Author: jreback <jeff@reback.net>
Date:   Thu Feb 28 10:03:52 2013 -0500

    DOC/TST: revised indexing section in docs
             updated whatsnew
             all tests work
    
    DOC: changes suggested by Jan Schulz
         revised whatsnew to include mostly references to new indexing

diff --git a/RELEASE.rst b/RELEASE.rst
index 32cbddf6b..e4e708777 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -35,7 +35,12 @@ pandas 0.11.0
     Yahoo! finance (GH2795_)
   - Add ``squeeze`` function to reduce dimensionality of 1-len objects
   - Support slicing with time objects (GH2681_)
-  - Add ``.iloc`` attribute, to support location-based indexing, analagous to ``.ix``
+  - Added ``.iloc`` attribute, to support strict integer based indexing, analagous to ``.ix`` (GH2922_)
+  - Added ``.loc``  attribute, to support strict label based indexing, analagous to ``.ix``
+  - Added ``.iat``  attribute, to support fast scalar access via integers (replaces ``iget_value/iset_value``)
+  - Added ``.at``   attribute, to support fast scalar access via labels (replaces ``get_value/set_value``)
+  - Moved functionaility from ``irow,icol,iget_value/iset_value`` to ``.iloc`` indexer 
+    (via ``_ixs`` methods in each object)
 
 **Improvements to existing features**
 
@@ -52,6 +57,7 @@ pandas 0.11.0
   - ``describe_option()`` now reports the default and current value of options.
   - Add ``format`` option to ``pandas.to_datetime`` with faster conversion of
     strings that can be parsed with datetime.strptime
+  - Add ``axes`` property to ``Series`` for compatibility 
 
 **API Changes**
 
@@ -129,6 +135,7 @@ pandas 0.11.0
   - Bug in argsort of ``datetime64[ns]`` Series with ``NaT`` (GH2967_)
   - Bug in idxmin/idxmax of ``datetime64[ns]`` Series with ``NaT`` (GH2982__)
   - ``icol`` with negative indicies was return ``nan`` (see GH2922_)
+  - Bug in ``icol`` with negative indicies was incorrect producing incorrect return values (see GH2922_)
 
 .. _GH622: https://github.com/pydata/pandas/issues/622
 .. _GH797: https://github.com/pydata/pandas/issues/797
diff --git a/doc/source/conf.py b/doc/source/conf.py
index 43b7df6af..76093d83b 100644
--- a/doc/source/conf.py
+++ b/doc/source/conf.py
@@ -17,7 +17,6 @@ import os
 # add these directories to sys.path here. If the directory is relative to the
 # documentation root, use os.path.abspath to make it absolute, like shown here.
 # sys.path.append(os.path.abspath('.'))
-sys.path.insert(0,'/home/jreback/pandas')
 sys.path.insert(0, os.path.abspath('../sphinxext'))
 
 sys.path.extend([
diff --git a/doc/source/dsintro.rst b/doc/source/dsintro.rst
index 45fabb551..83f2de013 100644
--- a/doc/source/dsintro.rst
+++ b/doc/source/dsintro.rst
@@ -437,8 +437,8 @@ The basics of indexing are as follows:
     :widths: 30, 20, 10
 
     Select column, ``df[col]``, Series
-    Select row by label, ``df.xs(label)`` or ``df.ix[label]``, Series
-    Select row by location (int), ``df.ix[loc]``, Series
+    Select row by label, ``df.loc[label]``, Series
+    Select row by integer location, ``df.iloc[loc]``, Series
     Slice rows, ``df[5:10]``, DataFrame
     Select rows by boolean vector, ``df[bool_vec]``, DataFrame
 
@@ -447,8 +447,8 @@ DataFrame:
 
 .. ipython:: python
 
-   df.xs('b')
-   df.ix[2]
+   df.loc('b')
+   df.iloc[2]
 
 For a more exhaustive treatment of more sophisticated label-based indexing and
 slicing, see the :ref:`section on indexing <indexing>`. We will address the
@@ -475,7 +475,7 @@ row-wise. For example:
 
 .. ipython:: python
 
-   df - df.ix[0]
+   df - df.iloc[0]
 
 In the special case of working with time series data, if the Series is a
 TimeSeries (which it will be automatically if the index contains datetime
@@ -592,7 +592,7 @@ DataFrame in tabular form, though it won't always fit the console width:
 
 .. ipython:: python
 
-   print baseball.ix[-20:, :12].to_string()
+   print baseball.iloc[-20:, :12].to_string()
 
 New since 0.10.0, wide DataFrames will now be printed across multiple rows by
 default:
diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index 11708f68d..75fa4803f 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -32,6 +32,78 @@ attention in this area. Expect more work to be invested higher-dimensional data
 structures (including Panel) in the future, especially in label-based advanced
 indexing.
 
+Choice
+------
+
+Starting in 0.11.0, object selection has had a number of user-requested additions in
+order to support more explicit location based indexing. Pandas now supports
+three types of multi-axis indexing.
+
+  - ``.loc`` is strictly label based, will raise ``KeyError`` when the items are not found,
+    allowed inputs are:
+
+    - A single label, e.g. ``5`` or ``'a'``
+
+      (note that ``5`` when used as a *label* of an integer based index)
+    - A list or array of labels ``['a', 'b', 'c']``
+    - A slice object with labels ``'a':'f'``
+
+      (note that contrary to usual python slices, **both** the start and the stop are included!)
+    - A boolean array
+
+    See more at :ref:`Label indexing <indexing.label>`
+
+  - ``.iloc`` is strictly integer position based (from 0 to length-1 of the axis), will 
+    raise ``IndexError`` when the requested indicies are out of bounds. Allowed inputs are:
+
+    - An integer e.g. ``5``
+    - A list or array of integers ``[4, 3, 0]``
+    - A slice object with ints ``1:7``
+    - A boolean array
+
+    See more at :ref:`Integer indexing <indexing.integer>` 
+
+  - ``.ix`` supports mixed integer and label based access. It is primarily label based, but
+    will fallback to integer positional access. ``.ix`` is the most general and will support 
+    any of the inputsx to ``.loc`` and ``.iloc``, as well as support for floating point label schemes.
+    As using integer slices with ``.ix`` have different behavior depending on whether the slice 
+    is interpreted as integer location based or label position based, it's usually better to be 
+    explicit and use ``.iloc`` (integer location) or ``.loc`` (label location).
+
+    See more at :ref:`Advanced indexing <indexing.advanced>`
+
+Getting values from object with multi-axes uses the following notation (using ``.loc`` as an 
+example, but applies to ``.iloc`` and ``.ix`` as well) Any of the axes accessors may be the null 
+slice ``:``. Axes left out of the specification are assumed to be ``:``.
+(e.g. ``p.loc['a']`` is equiv to ``p.loc['a',:,:]``)
+
+.. csv-table::
+    :header: "Object Type", "Indexers"
+    :widths: 30, 50
+    :delim: ;
+
+    Series; ``s.loc[indexer]``
+    DataFrame; ``df.loc[row_indexer,column_indexer]``
+    Panel; ``p.loc[item_indexer,major_indexer,minor_indexer]``
+
+Indexing Deprecations
+~~~~~~~~~~~~~~~~~~~~~
+
+Starting in version 0.11.0, the methods may be deprecated in future versions.
+
+  - ``irow``
+  - ``icol``
+  - ``iget_value``
+
+See the section :ref:`Integer indexing <indexing.integer>` for substitutes.
+
+.. _indexing.xs:
+
+Cross-sectional slices on non-hierarchical indices are now easily
+performed using ``.loc`` and/or ``.loc``. The methods ``xs`` (for DataFrame),
+``minor_xs`` and ``major_xs`` (for Panel), exist primarily for backward
+compatibility.
+
 .. _indexing.basics:
 
 Basics
@@ -72,39 +144,6 @@ Thus, as per above, we have the most basic indexing using ``[]``:
    s[dates[5]]
    panel['two']
 
-
-.. _indexing.basics.get_value:
-
-Fast scalar value getting and setting
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-Since indexing with ``[]`` must handle a lot of cases (single-label access,
-slicing, boolean indexing, etc.), it has a bit of overhead in order to figure
-out what you're asking for. If you only want to access a scalar value, the
-fastest way is to use the ``at`` and ``iat`` methods, which are implemented on all of
-the data structures.
-
-Similary to ``loc`` and ``at`` provides **label** based lookups, while, ``iat`` provides
-**integer** based lookups analagously to ``iloc``
-
-.. ipython:: python
-
-   type(dates[5])
-   dates[5]
-   s.at[dates[5]]
-   s.iat[5]
-   df.at[dates[5], 'A']
-   df.iat[3, 0]
-
-You can also set using these same indexers. These have the additional capability
-of enlarging an object. This method *always* returns a reference to the object
-it modified, which in the case of enlargement, will be a **new object**:
-
-.. ipython:: python
-
-   df.at[dates[5], 'E'] = 7
-   df.iat[3, 0] = 7
-
 Additional Column Access
 ~~~~~~~~~~~~~~~~~~~~~~~~
 
@@ -134,30 +173,12 @@ raised. Multiple columns can also be set in this manner:
 You may find this useful for applying a transform (in-place) to a subset of the
 columns.
 
-Data slices on other axes
-~~~~~~~~~~~~~~~~~~~~~~~~~
-
-It's certainly possible to retrieve data slices along the other axes of a
-DataFrame or Panel. We tend to refer to these slices as
-*cross-sections*. DataFrame has the ``xs`` function for retrieving rows as
-Series and Panel has the analogous ``major_xs`` and ``minor_xs`` functions for
-retrieving slices as DataFrames for a given ``major_axis`` or ``minor_axis``
-label, respectively.
-
-.. ipython:: python
-
-   date = dates[5]
-   df.xs(date)
-   panel.major_xs(date)
-   panel.minor_xs('A')
-
-
 Slicing ranges
 ~~~~~~~~~~~~~~
 
 The most robust and consistent way of slicing ranges along arbitrary axes is
-described in the :ref:`Advanced indexing <indexing.advanced>` section detailing
-the ``.ix`` method. For now, we explain the semantics of slicing using the
+described in the :ref:`Integer indexing <indexing.integer>` section detailing
+the ``.iloc`` method. For now, we explain the semantics of slicing using the
 ``[]`` operator.
 
 With Series, the syntax works exactly as with an ndarray, returning a slice of
@@ -185,19 +206,31 @@ largely as a convenience since it is such a common operation.
    df[:3]
    df[::-1]
 
+.. _indexing.label:
+
 Label Based Indexing
 ~~~~~~~~~~~~~~~~~~~~
 
-Pandas provides a suite of methods in order to get **purely label based indexing**. 
+Pandas provides a suite of methods in order to have **purely label based indexing**. 
 This is a strict inclusion based protocol. **ALL** of the labels for which you ask,
-must be in the index or a KeyError will be raised! When slicing, the start bounds is 
-*included*, **AND** the upper bound is *included*. Invalid selections will raise with 
-an ``KeyError``. Integers are valid indicies (and labels), but standard semantics
-**DO NOT APPLY**, labels must be **INCLUSIVE**. Valid selection include: *label, listlike 
-of labels, boolean indexers, and label slices*
+must be in the index or a ``KeyError`` will be raised!
+
+When slicing, the start bound is *included*, **AND** the stop bound is *included*.
+Integers are valid labels, but they refer to the label *and not the position*.
 
 The ``.loc`` attribute is the primary access method.
 
+The following are valid inputs:
+
+    - A single label, e.g. ``5`` or ``'a'``
+
+      (note that ``5`` when used as a *label* of an integer based index)
+    - A list or array of labels ``['a', 'b', 'c']``
+    - A slice object with labels ``'a':'f'``
+
+      (note that contrary to usual python slices, **both** the start and the stop are included!)
+    - A boolean array
+
 .. ipython:: python
 
    s1 = Series(np.random.randn(6),index=list('abcdef'))
@@ -216,36 +249,50 @@ With a DataFrame
 
 .. ipython:: python
 
-   df1 = DataFrame(np.random.randn(6,4),index=list('abcdef'),columns=range(4))
+   df1 = DataFrame(np.random.randn(6,4),index=list('abcdef'),columns=list('ABCD'))
    df1
    df1.loc[['a','b','d'],:]
 
-   # slices (this is an ok integer slice because it encompasses all of the labels)
-   df1.loc['d':,1:3]
+   # slices
+   df1.loc['d':,'A':'C']
+
+For getting a cross section using a label (equiv to deprecated ``df.xs('a')``)
+
+.. ipython:: python
+
+   df1.loc['a']
 
    # boolean
-   df1.loc[:,[True,True,False,False]]
+   df1.loc['a']>0
+   df1.loc[:,df1.loc['a']>0]
 
-For getting a value explicity.
+For getting a value explicity (equiv to deprecated ``df.get_value('a','A')``)
 
 .. ipython:: python
 
-   # this is equivalent to ``df1.at['a',1]``
-   df1.loc['a',1]
+   # this is also equivalent to ``df1.at['a','A']``
+   df1.loc['a','A']
 
+.. _indexing.integer:
 
 Integer Based Indexing
 ~~~~~~~~~~~~~~~~~~~~~~
 
 Pandas provides a suite of methods in order to get **purely integer based indexing**. 
 The semantics follow closely python and numpy slicing. These are ``0-based`` indexing.
+
 When slicing, the start bounds is *included*, while the upper bound is *excluded*.
-Invalid selections will raise with an ``IndexError``. Trying to use a non-integer,
-even a **valid** label will raise a ``ValueError``. Integers, lists of integers, and slices
-are allowed indexers.
+Trying to use a non-integer, even a **valid** label will raise a ``IndexError``.
 
 The ``.iloc`` attribute is the primary access method .
 
+The following are valid inputs:
+
+   - An integer e.g. ``5``
+   - A list or array of integers ``[4, 3, 0]``
+   - A slice object with ints ``1:7``
+   - A boolean array
+
 .. ipython:: python
 
    s1 = Series(np.random.randn(5),index=range(0,10,2))
@@ -277,25 +324,34 @@ With a DataFrame
    # integer lists
    df1.iloc[[1,3,5],[1,3]]
 
-For slicing rows explicitly.
+   # boolean
+   df1.iloc[:,df1.iloc[0]>0]
+
+For slicing rows explicitly (equiv to deprecated ``df.irow(slice(1,3))``).
 
 .. ipython:: python
 
    df1.iloc[1:3,:]
 
-For slicing columns explicitly.
+For slicing columns explicitly (equiv to deprecated ``df.icol(slice(1,3))``).
 
 .. ipython:: python
 
    df1.iloc[:,1:3]
 
-For getting a value explicity.
+For getting a value explicity (equiv to deprecated ``df.get_value(1,1)``)
 
 .. ipython:: python
 
-   # this is equivalent to ``df1.iat[1,1]``
+   # this is also equivalent to ``df1.iat[1,1]``
    df1.iloc[1,1]
 
+For getting a cross section using an integer position (equiv to deprecated ``df.xs(1)``)
+
+.. ipython:: python
+
+   df1.iloc[1]
+
 There is one signficant departure from standard python/numpy slicing semantics.
 python/numpy allow slicing past the end of an array without an associated error.
 
@@ -306,11 +362,41 @@ python/numpy allow slicing past the end of an array without an associated error.
     x[4:10]
     x[8:10]
 
+Pandas will detect this and raise ``IndexError``, rather than return an empty structure.
+
 ::
 
     >>> df.iloc[:,3:6]
     IndexError: out-of-bounds on slice (end)
 
+.. _indexing.basics.get_value:
+
+Fast scalar value getting and setting
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Since indexing with ``[]`` must handle a lot of cases (single-label access,
+slicing, boolean indexing, etc.), it has a bit of overhead in order to figure
+out what you're asking for. If you only want to access a scalar value, the
+fastest way is to use the ``at`` and ``iat`` methods, which are implemented on all of
+the data structures.
+
+Similary to ``loc``, ``at`` provides **label** based scalar lookups, while, ``iat`` provides
+**integer** based lookups analagously to ``iloc``
+
+.. ipython:: python
+
+   s.iat[5]
+   df.at[dates[5], 'A']
+   df.iat[3, 0]
+
+You can also set using these same indexers. These have the additional capability
+of enlarging an object. This method *always* returns a reference to the object
+it modified, which in the case of enlargement, will be a **new object**:
+
+.. ipython:: python
+
+   df.at[dates[5], 'E'] = 7
+   df.iat[3, 0] = 7
 
 Boolean indexing
 ~~~~~~~~~~~~~~~~
@@ -363,8 +449,8 @@ more complex criteria:
    df2[criterion & (df2['b'] == 'x')]
 
 
-Note, with the :ref:`advanced indexing <indexing.advanced>` ``ix`` method, you
-may select along more than one axis using boolean vectors combined with other
+Note, with the choice methods :ref:`Label indexing <indexing.label>`, :ref:`Integer indexing <indexing.integer>`,
+and :ref:`Advanced indexing <indexing.advanced>` may select along more than one axis using boolean vectors combined with other
 indexing expressions.
 
 Where and Masking
@@ -548,20 +634,21 @@ default value.
 
 .. _indexing.advanced:
 
-Advanced indexing with labels
------------------------------
+Advanced Indexing with ``.ix``
+------------------------------
+
+.. note::
 
-We have avoided excessively overloading the ``[]`` / ``__getitem__`` operator
-to keep the basic functionality of the pandas objects straightforward and
-simple. However, there are often times when you may wish get a subset (or
-analogously set a subset) of the data in a way that is not straightforward
-using the combination of ``reindex`` and ``[]``. Complicated setting operations
-are actually quite difficult because ``reindex`` usually returns a copy.
+   The recent addition of ``.loc`` and ``.iloc`` have enabled users to be quite
+   explicit about indexing choices. ``.ix`` allows a great flexibility to specify
+   indexing locations by *label* an/or *integer position*. Pandas will attempt
+   to use any passed *integer* as *label* locations first (like what ``.loc``
+   would do, then to fall back on *positional* indexing, like what ``.iloc`` would do).
 
-By *advanced* indexing we are referring to a special ``.ix`` attribute on
-pandas objects which enable you to do getting/setting operations on a
-DataFrame, for example, with matrix/ndarray-like semantics. Thus you can
-combine the following kinds of indexing:
+The syntax of using ``.ix`` is identical to ``.loc``, in :ref:`Label indexing <indexing.label>`,
+and ``.iloc`` in :ref:`Integer indexing <indexing.integer>`.
+
+The ``.ix`` attribute takes the following inputs:
 
   - An integer or single label, e.g. ``5`` or ``'a'``
   - A list or array of labels ``['a', 'b', 'c']`` or integers ``[4, 3, 0]``
@@ -664,27 +751,6 @@ numpy array.  For instance,
   dflookup.lookup(xrange(0,10,2), ['B','C','A','B','D'])
 
 
-Advanced indexing with integer labels
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-Label-based indexing with integer axis labels is a thorny topic. It has been
-discussed heavily on mailing lists and among various members of the scientific
-Python community. In pandas, our general viewpoint is that labels matter more
-than integer locations. Therefore, with an integer axis index *only*
-label-based indexing is possible with the standard tools like ``.ix``. The
-following code will generate exceptions:
-
-.. code-block:: python
-
-   s = Series(range(5))
-   s[-1]
-   df = DataFrame(np.random.randn(5, 4))
-   df
-   df.ix[-2:]
-
-This deliberate decision was made to prevent ambiguities and subtle bugs (many
-users reported finding bugs when the API change was made to stop "falling back"
-on position-based indexing).
-
 Setting values in mixed-type DataFrame
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
@@ -953,8 +1019,6 @@ but as you use it you may uncover corner cases or unintuitive behavior. If you
 do find something like this, do not hesitate to report the issue or ask on the
 mailing list.
 
-.. _indexing.xs:
-
 Cross-section with hierarchical index
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
diff --git a/doc/source/v0.10.1.txt b/doc/source/v0.10.1.txt
index 4c7369c27..e8435df7b 100644
--- a/doc/source/v0.10.1.txt
+++ b/doc/source/v0.10.1.txt
@@ -232,4 +232,5 @@ on GitHub for a complete list.
 .. _GH2626: https://github.com/pydata/pandas/issues/2626
 .. _GH2613: https://github.com/pydata/pandas/issues/2613
 .. _GH2602: https://github.com/pydata/pandas/issues/2602
+.. _GH2687: https://github.com/pydata/pandas/issues/2687
 .. _GH2563: https://github.com/pydata/pandas/issues/2563
diff --git a/doc/source/v0.11.0.txt b/doc/source/v0.11.0.txt
index 76f7ffae7..8ea49d107 100644
--- a/doc/source/v0.11.0.txt
+++ b/doc/source/v0.11.0.txt
@@ -11,65 +11,66 @@ to.
 API changes
 ~~~~~~~~~~~
 
-Location Based Indexing
-~~~~~~~~~~~~~~~~~~~~~~~
+Indexing Choice
+~~~~~~~~~~~~~~~
 
-Pandas provides a suite of methods in order to get **purely integer based indexing**. 
-The semantics follow closely python and numpy slicing. These are ``0-based`` indexing.
-When slicing, the start bounds is *included*, while the upper bound is *excluded*.
-Invalid selections will raise with an ``IndexError``. Trying to use a non-integer,
-even a **valid** label will raise a ``ValueError``. Integers, lists of integers, and slices
-are allowed indexers.
+Starting in 0.11.0, object selection has had a number of user-requested additions in
+order to support more explicit location based indexing. Pandas now supports
+three types of multi-axis indexing.
 
-The ``.iloc`` attribute is the primary access method .
+  - ``.loc`` is strictly label based, will raise ``KeyError`` when the items are not found,
+    allowed inputs are:
 
-.. ipython:: python
+    - A single label, e.g. ``5`` or ``'a'``
 
-   s1 = Series(np.random.randn(5),index=range(0,10,2))
-   s1
-   s1.iloc[:3]
-   s1.iloc[3]
+      (note that ``5`` when used as a *label* of an integer based index)
+    - A list or array of labels ``['a', 'b', 'c']``
+    - A slice object with labels ``'a':'f'``
 
-Note that setting works as well:
+      (note that contrary to usual python slices, **both** the start and the stop are included!)
+    - A boolean array
 
-.. ipython:: python
+    See more at :ref:`Label indexing <indexing.label>`
 
-   s1.iloc[:3] = 0
-   s1
+  - ``.iloc`` is strictly integer position based (from 0 to length-1 of the axis), will 
+    raise ``IndexError`` when the requested indicies are out of bounds. Allowed inputs are:
 
-With a DataFrame
+    - An integer e.g. ``5``
+    - A list or array of integers ``[4, 3, 0]``
+    - A slice object with ints ``1:7``
+    - A boolean array
 
-.. ipython:: python
+    See more at :ref:`Integer indexing <indexing.integer>` 
 
-   df1 = DataFrame(np.random.randn(8,4),index=range(0,16,2),columns=range(0,8,2))
+  - ``.ix`` supports mixed integer and label based access. It is primarily label based, but
+    will fallback to integer positional access. ``.ix`` is the most general and will support 
+    any of the inputsx to ``.loc`` and ``.iloc``, as well as support for floating point label schemes.
+    As using integer slices with ``.ix`` have different behavior depending on whether the slice 
+    is interpreted as integer location based or label position based, it's usually better to be 
+    explicit and use ``.iloc`` (integer location) or ``.loc`` (label location).
 
-   # integer access
-   df1.iloc[5,2]
+    See more at :ref:`Advanced indexing <indexing.advanced>`
 
-   # slices
-   df1.iloc[:3]
-   df1.iloc[1:5,2:4]
 
-   # integer lists
-   df1.iloc[[1,3,5],[1,3]]
+Indexing Deprecations
+~~~~~~~~~~~~~~~~~~~~~
 
-There is one signficant departure from standard python/numpy slicing semantics.
-python/numpy allow slicing past the end of an array without an associated error.
+Starting in version 0.11.0, the methods may be deprecated in future versions.
 
-.. ipython:: python
+  - ``irow``
+  - ``icol``
+  - ``iget_value``
 
-    # these are allowed in python/numpy.
-    x = list('abcdef')
-    x[4:10]
-    x[8:10]
+See the section :ref:`Integer indexing <indexing.integer>` for substitutes.
 
-::
+Cross-sectional slices on non-hierarchical indices are now easily
+performed using ``.loc`` and/or ``.loc``. The methods ``xs`` (for DataFrame),
+``minor_xs`` and ``major_xs`` (for Panel), exist primarily for backward
+compatibility
 
-    >>> df.iloc[:,3:6]
-    IndexError: out-of-bounds on slice (end)
 
-Dtype Specification
-~~~~~~~~~~~~~~~~~~~
+Dtypes
+~~~~~~
 
 Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passed (either directly via the ``dtype`` keyword, a passed ``ndarray``, or a passed ``Series``, then it will be preserved in DataFrame operations. Furthermore, different numeric dtypes will **NOT** be combined. The following example will give you a taste.
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index b3770cb79..3a7da212d 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1884,94 +1884,71 @@ class DataFrame(NDFrame):
             return result.set_value(index, col, value)
 
     def irow(self, i, copy=False):
-        """
-        Retrieve the i-th row or rows of the DataFrame by location
-
-        Parameters
-        ----------
-        i : int, slice, or sequence of integers
+        return self._ixs(i,axis=0)
 
-        Notes
-        -----
-        If slice passed, the resulting data will be a view
+    def icol(self, i):
+        return self._ixs(i,axis=1)
 
-        Returns
-        -------
-        row : Series (int) or DataFrame (slice, sequence)
+    def _ixs(self, i, axis=0, copy=False):
+        """ 
+        i : int, slice, or sequence of integers
+        axis : int
         """
-        if isinstance(i, slice):
-            return self[i]
-        else:
-            label = self.index[i]
-            if isinstance(label, Index):
-                return self.reindex(label)
-            else:
-                try:
-                    new_values = self._data.fast_2d_xs(i, copy=copy)
-                except:
-                    new_values = self._data.fast_2d_xs(i, copy=True)
-                return Series(new_values, index=self.columns,
-                              name=self.index[i])
 
-    def icol(self, i):
-        """
-        Retrieve the i-th column or columns of the DataFrame by location
+        # irow
+        if axis == 0:
 
-        Parameters
-        ----------
-        i : int, slice, or sequence of integers
+            """
+            Notes
+            -----
+            If slice passed, the resulting data will be a view
+            """
 
-        Notes
-        -----
-        If slice passed, the resulting data will be a view
+            if isinstance(i, slice):
+                return self[i]
+            else:
+                label = self.index[i]
+                if isinstance(label, Index):
+                    return self.reindex(label)
+                else:
+                    try:
+                        new_values = self._data.fast_2d_xs(i, copy=copy)
+                    except:
+                        new_values = self._data.fast_2d_xs(i, copy=True)
+                    return Series(new_values, index=self.columns,
+                                  name=self.index[i])
 
-        Returns
-        -------
-        column : Series (int) or DataFrame (slice, sequence)
-        """
-        label = self.columns[i]
-        if isinstance(i, slice):
-            # need to return view
-            lab_slice = slice(label[0], label[-1])
-            return self.ix[:, lab_slice]
+        # icol
         else:
-            label = self.columns[i]
-            if isinstance(label, Index):
 
-                # if we have negative indicies, translate to postive here 
-                # (take doesen't deal properly with these)
-                l = len(self.columns)
-                i = [ v if v >= 0 else l+v for v in i ]
+            """ 
+            Notes
+            -----
+            If slice passed, the resulting data will be a view
+            """
 
-                return self.take(i, axis=1)
+            label = self.columns[i]
+            if isinstance(i, slice):
+                # need to return view
+                lab_slice = slice(label[0], label[-1])
+                return self.ix[:, lab_slice]
+            else:
+                label = self.columns[i]
+                if isinstance(label, Index):
 
-            values = self._data.iget(i)
-            return self._col_klass.from_array(values, index=self.index,
-                                              name=label)
+                    # if we have negative indicies, translate to postive here 
+                    # (take doesen't deal properly with these)
+                    l = len(self.columns)
+                    i = [ v if v >= 0 else l+v for v in i ]
+                    
+                    return self.take(i, axis=1)
 
-    def _ixs(self, i, axis=0):
-        if axis == 0:
-            return self.irow(i)
-        else:
-            return self.icol(i)
+                values = self._data.iget(i)
+                return self._col_klass.from_array(values, index=self.index,
+                                                  name=label)
 
     def iget_value(self, i, j):
-        """
-        Return scalar value stored at row i and column j, where i and j are
-        integers
-
-        Parameters
-        ----------
-        i : int
-        j : int
-
-        Returns
-        -------
-        value : scalar value
-        """
-        row = self.index[i]
-        col = self.columns[j]
-        return self.get_value(row, col)
+        return self.iat[i,j]
 
     def __getitem__(self, key):
         if isinstance(key, slice):
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index e21405b77..0b4474f7a 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -320,8 +320,12 @@ class _NDFrameIndexer(object):
             if _is_label_like(key) or isinstance(key, tuple):
                 section = self._getitem_axis(key, axis=i)
 
+                # we have yielded a scalar ?
+                if not _is_list_like(section):
+                    return section
+
                 # might have been a MultiIndex
-                if section.ndim == self.ndim:
+                elif section.ndim == self.ndim:
                     new_key = tup[:i] + (_NS,) + tup[i + 1:]
                     # new_key = tup[:i] + tup[i+1:]
                 else:
@@ -639,7 +643,7 @@ class _LocationIndexer(_NDFrameIndexer):
 
 class _LocIndexer(_LocationIndexer):
     """ purely label based location based indexing """
-    _valid_types = "labels (MUST BE INCLUSIVE), slices of labels, slices of integers if the index is integers, boolean"
+    _valid_types = "labels (MUST BE INCLUSIVE), slices of labels (BOTH endpoints included! Can be slices of integers if the index is integers), listlike of labels, boolean"
     _exception   = KeyError
 
     def _has_valid_type(self, key, axis):
@@ -652,10 +656,15 @@ class _LocIndexer(_LocationIndexer):
 
         if isinstance(key, slice):
 
-            if key.start is not None and key.start not in ax:
-                raise KeyError
-            if key.stop is not None and key.stop-1 not in ax:
-                raise KeyError
+            if key.start is not None:
+                if key.start not in ax:
+                    raise KeyError("start bound [%s] is not the [%s]" % (key.start,self.obj._get_axis_name(axis)))
+            if key.stop is not None:
+                stop = key.stop
+                if com.is_integer(stop):
+                    stop -= 1
+                if stop not in ax:
+                    raise KeyError("stop bound [%s] is not in the [%s]" % (stop,self.obj._get_axis_name(axis)))
 
         elif com._is_bool_indexer(key):
                 return True
@@ -665,7 +674,7 @@ class _LocIndexer(_LocationIndexer):
             # require all elements in the index
             idx = _ensure_index(key)
             if not idx.isin(ax).all():
-                raise KeyError
+                raise KeyError("[%s] are not in ALL in the [%s]" % (key,self.obj._get_axis_name(axis)))
 
             return True
 
@@ -673,10 +682,10 @@ class _LocIndexer(_LocationIndexer):
 
             # if its empty we want a KeyError here
             if not len(ax):
-                raise KeyError
+                raise KeyError("The [%s] axis is empty" % self.obj._get_axis_name(axis))
 
             if not key in ax:
-                raise KeyError
+                raise KeyError("the label [%s] is not in the [%s]" % (key,self.obj._get_axis_name(axis)))
 
         return True
 
@@ -684,6 +693,9 @@ class _LocIndexer(_LocationIndexer):
         labels = self.obj._get_axis(axis)
 
         if isinstance(key, slice):
+            ltype = labels.inferred_type
+            if ltype == 'mixed-integer-float' or ltype == 'mixed-integer':
+                raise ValueError('cannot slice with a non-single type label array')
             return self._get_slice_axis(key, axis=axis)
         elif com._is_bool_indexer(key):
             return self._getbool_axis(key, axis=axis)
@@ -703,7 +715,7 @@ class _LocIndexer(_LocationIndexer):
 
 class _iLocIndexer(_LocationIndexer):
     """ purely integer based location based indexing """
-    _valid_types = "integer, integer slice, listlike of integers, boolean array"
+    _valid_types = "integer, integer slice (START point is INCLUDED, END point is EXCLUDED), listlike of integers, boolean array"
     _exception   = IndexError
 
     def _has_valid_type(self, key, axis):
@@ -763,7 +775,13 @@ class _ScalarAccessIndexer(_NDFrameIndexer):
 
     def __getitem__(self, key):
         if not isinstance(key, tuple):
-            raise ValueError('Invalid call for scalar access (getting)!')
+            
+            # we could have a convertible item here (e.g. Timestamp)
+            if not _is_list_like(key):
+                key = tuple([ key ])
+            else:
+                raise ValueError('Invalid call for scalar access (getting)!')
+
         if len(key) != self.obj.ndim:
             raise ValueError('Not enough indexers for scalar access (getting)!')
         key = self._convert_key(key)
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 3968371f8..d8dd2e8c6 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -1451,108 +1451,6 @@ class CheckIndexing(object):
         result = self.frame.ix[self.frame.index[5], 'E']
         self.assert_(com.is_integer(result))
 
-    def test_iloc_getitem(self):
-        df = DataFrame(np.random.randn(10, 4), index=range(0, 20, 2), columns=range(0,8,2))
-
-        result = df.iloc[2]
-        exp = df.ix[4]
-        assert_series_equal(result, exp)
-
-        result = df.iloc[2,2]
-        exp = df.ix[4,4]
-        self.assert_(result == exp)
-
-        # slice
-        result = df.iloc[4:8]
-        expected = df.ix[8:14]
-        assert_frame_equal(result, expected)
-
-        result = df.iloc[:,2:3]
-        expected = df.ix[:,4:5]
-        assert_frame_equal(result, expected)
-
-        # list of integers
-        result = df.iloc[[0,1,3]]
-        expected = df.ix[[0,2,6]]
-        assert_frame_equal(result, expected)
-
-        result = df.iloc[[0,1,3],[0,1]]
-        expected = df.ix[[0,2,6],[0,2]]
-        assert_frame_equal(result, expected)
-
-        # neg indicies
-        result = df.iloc[[-1,1,3],[-1,1]]
-        expected = df.ix[[18,2,6],[6,2]]
-        assert_frame_equal(result, expected)
-
-        # dups indicies
-        result = df.iloc[[-1,-1,1,3],[-1,1]]
-        expected = df.ix[[18,18,2,6],[6,2]]
-        assert_frame_equal(result, expected)
-
-        # with index-like
-        s = Series(index=range(1,5))
-        result = df.iloc[s.index]
-        expected = df.ix[[2,4,6,8]]
-        assert_frame_equal(result, expected)
-        
-        # out-of-bounds slice
-        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([slice(None),slice(1,5,None)]))
-        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([slice(None),slice(-5,3,None)]))
-        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([slice(1,11,None)]))
-        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([slice(-11,3,None)]))
-
-        # try with labelled frame
-        df = DataFrame(np.random.randn(10, 4), index=list('abcdefghij'), columns=list('ABCD'))
-
-        result = df.iloc[1,1]
-        exp = df.ix['b','B']
-        self.assert_(result == exp)
-
-        result = df.iloc[:,2:3]
-        expected = df.ix[:,['C']]
-        assert_frame_equal(result, expected)
-
-        # negative indexing
-        result = df.iloc[-1,-1]
-        exp = df.ix['j','D']
-        self.assert_(result == exp)
-
-        # out-of-bounds exception
-        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([10,5]))
-
-        # trying to use a label
-        self.assertRaises(ValueError, df.iloc.__getitem__, tuple(['j','D']))
-
-    def test_iloc_setitem(self):
-        df = DataFrame(np.random.randn(10, 4), index=list('abcdefghij'), columns=list('ABCD'))
-
-        df.iloc[1,1] = 1
-        result = df.iloc[1,1]
-        self.assert_(result == 1)
-
-        df.iloc[:,2:3] = 0
-        expected = df.iloc[:,2:3]
-        result = df.iloc[:,2:3]
-        assert_frame_equal(result, expected)
-
-    def test_iloc_multiindex(self):
-        df = DataFrame(np.random.randn(3, 3), 
-                       columns=[[2,2,4],[6,8,10]],
-                       index=[[4,4,8],[8,10,12]])
-
-        rs = df.iloc[2]
-        xp = df.irow(2)
-        assert_series_equal(rs, xp)
-
-        rs = df.iloc[:,2]
-        xp = df.icol(2)
-        assert_series_equal(rs, xp)
-
-        rs = df.iloc[2,2]
-        xp = df.values[2,2]
-        self.assert_(rs == xp)
-
     def test_irow(self):
         df = DataFrame(np.random.randn(10, 4), index=range(0, 20, 2))
 
diff --git a/pandas/tests/test_indexing.py b/pandas/tests/test_indexing.py
index 105a12dd0..c219c6fef 100644
--- a/pandas/tests/test_indexing.py
+++ b/pandas/tests/test_indexing.py
@@ -18,10 +18,10 @@ from pandas.util import py3compat
 
 import pandas.util.testing as tm
 import pandas.lib as lib
-
+from pandas import date_range
 from numpy.testing.decorators import slow
 
-_verbose = True
+_verbose = False
 
 #-------------------------------------------------------------------------------
 # Indexing test cases
@@ -93,8 +93,6 @@ class TestIndexing(unittest.TestCase):
         import warnings
         warnings.filterwarnings(action='ignore', category=FutureWarning)
 
-        from pandas import date_range
-
         self.series_ints   = Series(np.random.rand(4), index=range(0,8,2))
         self.frame_ints    = DataFrame(np.random.randn(4, 4), index=range(0, 8, 2), columns=range(0,12,3))
         self.panel_ints    = Panel(np.random.rand(4,4,4), items=range(0,8,2),major_axis=range(0,12,3),minor_axis=range(0,16,4))
@@ -157,11 +155,11 @@ class TestIndexing(unittest.TestCase):
             if a is not None and a > obj.ndim-1:
                 return
 
-            def _print(result, show = True,error = None):
+            def _print(result, error = None):
                 if error is not None:
                     error = str(error)
                 v = "%-16.16s [%-16.16s]: [typ->%-8.8s,obj->%-8.8s,key1->(%-4.4s),key2->(%-4.4s),axis->%s] %s" % (name,result,t,o,method1,method2,a,error or '')
-                if show:
+                if _verbose:
                     print(v)
 
             try:
@@ -200,8 +198,7 @@ class TestIndexing(unittest.TestCase):
                 if not result.startswith('ok'):
                     raise AssertionError(_print(result))
 
-                if _verbose:
-                    _print(result)
+                _print(result)
 
             except (AssertionError):
                 raise
@@ -303,7 +300,21 @@ class TestIndexing(unittest.TestCase):
             _check(d['labels'],'at')
             _check(d['ts'],    'at')
             _check(d['floats'],'at')
+
+    def test_at_timestamp(self):
             
+        # as timestamp is not a tuple!
+        dates = date_range('1/1/2000', periods=8)
+        df = DataFrame(randn(8, 4), index=dates, columns=['A', 'B', 'C', 'D'])
+        s = df['A']
+        
+        result = s.at[dates[5]]
+        xp     = s.values[5]
+        self.assert_(result == xp)
+
+    def test_iat_invalid_args(self):
+        pass
+
     def test_iloc_getitem_int(self):
 
         # integer
@@ -457,17 +468,33 @@ class TestIndexing(unittest.TestCase):
         self.check_result('lab slice', 'loc', slice('W','Z'), 'ix', slice('W','Z'), typs = ['labels'], axes=2)
 
         self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=0)
-        self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=1)
-        self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=2)
+        self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=1, fails=KeyError)
+        self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=2, fails=KeyError)
+
+        self.check_result('mixed slice', 'loc', slice(2,8), 'ix', slice(2,8), typs = ['mixed'], axes=0, fails=KeyError)
+        self.check_result('mixed slice', 'loc', slice(2,8), 'ix', slice(2,8), typs = ['mixed'], axes=1, fails=KeyError)
+        self.check_result('mixed slice', 'loc', slice(2,8), 'ix', slice(2,8), typs = ['mixed'], axes=2, fails=KeyError)
 
-        self.check_result('ts  slice', 'loc', slice(2,6), 'ix', slice(2,6), typs = ['mixed'], axes=0)
-        self.check_result('ts  slice', 'loc', slice(2,6), 'ix', slice(2,6), typs = ['mixed'], axes=1)
-        self.check_result('ts  slice', 'loc', slice(2,6), 'ix', slice(2,6), typs = ['mixed'], axes=2)
+        # you would think this would work, but we don't have an ordering, so fail
+        self.check_result('mixed slice', 'loc', slice(2,5,2), 'ix', slice(2,4,2), typs = ['mixed'], axes=0, fails=ValueError)
 
-    def test_loc_setitem(self):
+    def test_loc_general(self):
+
+        # GH 2922 (these are fails)
+        df = DataFrame(np.random.rand(4,4),columns=['A','B','C','D'])
+        self.assertRaises(KeyError, df.loc.__getitem__, tuple([slice(0,2),slice(0,2)]))
+
+        df = DataFrame(np.random.rand(4,4),columns=['A','B','C','D'], index=['A','B','C','D'])
+        self.assertRaises(KeyError, df.loc.__getitem__, tuple([slice(0,2),df.columns[0:2]]))
+
+        # want this to work
+        result = df.loc[:,"A":"B"].iloc[0:2,:]
+        self.assert_((result.columns == ['A','B']).all() == True)
+        self.assert_((result.index == ['A','B']).all() == True)
+
+    def test_loc_setitem_frame(self):
         df = self.frame_labels
 
-        import pdb; pdb.set_trace()
         result = df.iloc[0,0]
 
         df.loc['a','A'] = 1
@@ -479,9 +506,126 @@ class TestIndexing(unittest.TestCase):
 
         df.loc[:,'B':'D'] = 0
         expected = df.loc[:,'B':'D']
-        result = df.ix[:,2:3]
+        result = df.ix[:,1:]
+        assert_frame_equal(result, expected)
+
+    def test_iloc_getitem_frame(self):
+        """ originally from test_frame.py"""
+        df = DataFrame(np.random.randn(10, 4), index=range(0, 20, 2), columns=range(0,8,2))
+
+        result = df.iloc[2]
+        exp = df.ix[4]
+        assert_series_equal(result, exp)
+
+        result = df.iloc[2,2]
+        exp = df.ix[4,4]
+        self.assert_(result == exp)
+
+        # slice
+        result = df.iloc[4:8]
+        expected = df.ix[8:14]
         assert_frame_equal(result, expected)
 
+        result = df.iloc[:,2:3]
+        expected = df.ix[:,4:5]
+        assert_frame_equal(result, expected)
+
+        # list of integers
+        result = df.iloc[[0,1,3]]
+        expected = df.ix[[0,2,6]]
+        assert_frame_equal(result, expected)
+
+        result = df.iloc[[0,1,3],[0,1]]
+        expected = df.ix[[0,2,6],[0,2]]
+        assert_frame_equal(result, expected)
+
+        # neg indicies
+        result = df.iloc[[-1,1,3],[-1,1]]
+        expected = df.ix[[18,2,6],[6,2]]
+        assert_frame_equal(result, expected)
+
+        # dups indicies
+        result = df.iloc[[-1,-1,1,3],[-1,1]]
+        expected = df.ix[[18,18,2,6],[6,2]]
+        assert_frame_equal(result, expected)
+
+        # with index-like
+        s = Series(index=range(1,5))
+        result = df.iloc[s.index]
+        expected = df.ix[[2,4,6,8]]
+        assert_frame_equal(result, expected)
+        
+        # out-of-bounds slice
+        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([slice(None),slice(1,5,None)]))
+        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([slice(None),slice(-5,3,None)]))
+        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([slice(1,11,None)]))
+        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([slice(-11,3,None)]))
+
+        # try with labelled frame
+        df = DataFrame(np.random.randn(10, 4), index=list('abcdefghij'), columns=list('ABCD'))
+
+        result = df.iloc[1,1]
+        exp = df.ix['b','B']
+        self.assert_(result == exp)
+
+        result = df.iloc[:,2:3]
+        expected = df.ix[:,['C']]
+        assert_frame_equal(result, expected)
+
+        # negative indexing
+        result = df.iloc[-1,-1]
+        exp = df.ix['j','D']
+        self.assert_(result == exp)
+
+        # out-of-bounds exception
+        self.assertRaises(IndexError, df.iloc.__getitem__, tuple([10,5]))
+
+        # trying to use a label
+        self.assertRaises(ValueError, df.iloc.__getitem__, tuple(['j','D']))
+
+    def test_iloc_setitem_series(self):
+        """ originally from test_series.py """
+        df = DataFrame(np.random.randn(10, 4), index=list('abcdefghij'), columns=list('ABCD'))
+
+        df.iloc[1,1] = 1
+        result = df.iloc[1,1]
+        self.assert_(result == 1)
+
+        df.iloc[:,2:3] = 0
+        expected = df.iloc[:,2:3]
+        result = df.iloc[:,2:3]
+        assert_frame_equal(result, expected)
+
+    def test_iloc_setitem_series(self):
+        s = Series(np.random.randn(10), index=range(0,20,2))
+
+        s.iloc[1] = 1
+        result = s.iloc[1]
+        self.assert_(result == 1)
+
+        s.iloc[:4] = 0
+        expected = s.iloc[:4]
+        result = s.iloc[:4]
+        assert_series_equal(result, expected)
+
+    def test_iloc_multiindex(self):
+        df = DataFrame(np.random.randn(3, 3), 
+                       columns=[[2,2,4],[6,8,10]],
+                       index=[[4,4,8],[8,10,12]])
+
+        rs = df.iloc[2]
+        xp = df.irow(2)
+        assert_series_equal(rs, xp)
+
+        rs = df.iloc[:,2]
+        xp = df.icol(2)
+        assert_series_equal(rs, xp)
+
+        rs = df.iloc[2,2]
+        xp = df.values[2,2]
+        self.assert_(rs == xp)
+
+
 if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index eab956fb5..ee288fda1 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -1000,40 +1000,6 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self.assertRaises(Exception, s.__setitem__, inds_notfound, 0)
         self.assertRaises(Exception, s.__setitem__, arr_inds_notfound, 0)
 
-    def test_iloc_getitem(self):
-        s = Series(np.random.randn(10), index=list('abcdefghij'))
-
-        result = s.iloc[1]
-        exp = s.ix['b']
-        self.assert_(result == exp)
-
-        result = s.iloc[2:4]
-        expected = s.ix['c':'d']
-        assert_series_equal(result, expected)
-
-        # negative indexing
-        result = s.iloc[-1]
-        exp = s.ix['j']
-        self.assert_(result == exp)
-
-        # out-of-bounds exception
-        self.assertRaises(IndexError, s.iloc.__getitem__, tuple([12]))
-
-        # trying to use a label
-        self.assertRaises(ValueError, s.iloc.__getitem__, tuple(['j']))
-
-    def test_iloc_setitem(self):
-        s = Series(np.random.randn(10), index=range(0,20,2))
-
-        s.iloc[1] = 1
-        result = s.iloc[1]
-        self.assert_(result == 1)
-
-        s.iloc[:4] = 0
-        expected = s.iloc[:4]
-        result = s.iloc[:4]
-        assert_series_equal(result, expected)
-
     def test_ix_getitem(self):
         inds = self.series.index[[3, 4, 7]]
         assert_series_equal(self.series.ix[inds], self.series.reindex(inds))

commit 5a20717ddc58c4d961227a482fa88f905f159bab
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Wed Feb 14 03:26:51 2018 -0800

    tests for tslibs.conversion and tslibs.timezones (#19642)

diff --git a/pandas/tests/tseries/test_timezones.py b/pandas/tests/tseries/test_timezones.py
index 565e735c1..97326dc04 100644
--- a/pandas/tests/tseries/test_timezones.py
+++ b/pandas/tests/tseries/test_timezones.py
@@ -2,15 +2,10 @@
 import pytest
 
 import pytz
-import dateutil
-import numpy as np
 
 from datetime import datetime
 
-import pandas.util.testing as tm
-from pandas.core.indexes.datetimes import date_range
-from pandas._libs import tslib
-from pandas._libs.tslibs import timezones, conversion
+from pandas._libs.tslibs import timezones
 from pandas import Timestamp
 
 
@@ -111,82 +106,3 @@ class TestTimeZoneSupportDateutil(TestTimeZoneSupportPytz):
     def normalize(self, ts):
         # no-op for dateutil
         return ts
-
-    def test_tzlocal(self):
-        # GH 13583
-        ts = Timestamp('2011-01-01', tz=dateutil.tz.tzlocal())
-        assert ts.tz == dateutil.tz.tzlocal()
-        assert "tz='tzlocal()')" in repr(ts)
-
-        tz = timezones.maybe_get_tz('tzlocal()')
-        assert tz == dateutil.tz.tzlocal()
-
-        # get offset using normal datetime for test
-        offset = dateutil.tz.tzlocal().utcoffset(datetime(2011, 1, 1))
-        offset = offset.total_seconds() * 1000000000
-        assert ts.value + offset == Timestamp('2011-01-01').value
-
-
-class TestTimeZoneCacheKey(object):
-
-    @pytest.mark.parametrize('tz_name', list(pytz.common_timezones))
-    def test_cache_keys_are_distinct_for_pytz_vs_dateutil(self, tz_name):
-        if tz_name == 'UTC':
-            # skip utc as it's a special case in dateutil
-            return
-        tz_p = timezones.maybe_get_tz(tz_name)
-        tz_d = timezones.maybe_get_tz('dateutil/' + tz_name)
-        if tz_d is None:
-            # skip timezones that dateutil doesn't know about.
-            return
-        assert (timezones._p_tz_cache_key(tz_p) !=
-                timezones._p_tz_cache_key(tz_d))
-
-
-class TestTslib(object):
-
-    def test_tslib_tz_convert(self):
-        def compare_utc_to_local(tz_didx, utc_didx):
-            f = lambda x: conversion.tz_convert_single(x, 'UTC', tz_didx.tz)
-            result = conversion.tz_convert(tz_didx.asi8, 'UTC', tz_didx.tz)
-            result_single = np.vectorize(f)(tz_didx.asi8)
-            tm.assert_numpy_array_equal(result, result_single)
-
-        def compare_local_to_utc(tz_didx, utc_didx):
-            f = lambda x: conversion.tz_convert_single(x, tz_didx.tz, 'UTC')
-            result = conversion.tz_convert(utc_didx.asi8, tz_didx.tz, 'UTC')
-            result_single = np.vectorize(f)(utc_didx.asi8)
-            tm.assert_numpy_array_equal(result, result_single)
-
-        for tz in ['UTC', 'Asia/Tokyo', 'US/Eastern', 'Europe/Moscow']:
-            # US: 2014-03-09 - 2014-11-11
-            # MOSCOW: 2014-10-26  /  2014-12-31
-            tz_didx = date_range('2014-03-01', '2015-01-10', freq='H', tz=tz)
-            utc_didx = date_range('2014-03-01', '2015-01-10', freq='H')
-            compare_utc_to_local(tz_didx, utc_didx)
-            # local tz to UTC can be differ in hourly (or higher) freqs because
-            # of DST
-            compare_local_to_utc(tz_didx, utc_didx)
-
-            tz_didx = date_range('2000-01-01', '2020-01-01', freq='D', tz=tz)
-            utc_didx = date_range('2000-01-01', '2020-01-01', freq='D')
-            compare_utc_to_local(tz_didx, utc_didx)
-            compare_local_to_utc(tz_didx, utc_didx)
-
-            tz_didx = date_range('2000-01-01', '2100-01-01', freq='A', tz=tz)
-            utc_didx = date_range('2000-01-01', '2100-01-01', freq='A')
-            compare_utc_to_local(tz_didx, utc_didx)
-            compare_local_to_utc(tz_didx, utc_didx)
-
-        # Check empty array
-        result = conversion.tz_convert(np.array([], dtype=np.int64),
-                                       timezones.maybe_get_tz('US/Eastern'),
-                                       timezones.maybe_get_tz('Asia/Tokyo'))
-        tm.assert_numpy_array_equal(result, np.array([], dtype=np.int64))
-
-        # Check all-NaT array
-        result = conversion.tz_convert(np.array([tslib.iNaT], dtype=np.int64),
-                                       timezones.maybe_get_tz('US/Eastern'),
-                                       timezones.maybe_get_tz('Asia/Tokyo'))
-        tm.assert_numpy_array_equal(result, np.array(
-            [tslib.iNaT], dtype=np.int64))
diff --git a/pandas/tests/tslibs/test_conversion.py b/pandas/tests/tslibs/test_conversion.py
new file mode 100644
index 000000000..76038136c
--- /dev/null
+++ b/pandas/tests/tslibs/test_conversion.py
@@ -0,0 +1,57 @@
+# -*- coding: utf-8 -*-
+
+import numpy as np
+import pytest
+
+import pandas.util.testing as tm
+from pandas import date_range
+from pandas._libs.tslib import iNaT
+from pandas._libs.tslibs import conversion, timezones
+
+
+def compare_utc_to_local(tz_didx, utc_didx):
+    f = lambda x: conversion.tz_convert_single(x, 'UTC', tz_didx.tz)
+    result = conversion.tz_convert(tz_didx.asi8, 'UTC', tz_didx.tz)
+    result_single = np.vectorize(f)(tz_didx.asi8)
+    tm.assert_numpy_array_equal(result, result_single)
+
+
+def compare_local_to_utc(tz_didx, utc_didx):
+    f = lambda x: conversion.tz_convert_single(x, tz_didx.tz, 'UTC')
+    result = conversion.tz_convert(utc_didx.asi8, tz_didx.tz, 'UTC')
+    result_single = np.vectorize(f)(utc_didx.asi8)
+    tm.assert_numpy_array_equal(result, result_single)
+
+
+class TestTZConvert(object):
+
+    @pytest.mark.parametrize('tz', ['UTC', 'Asia/Tokyo',
+                                    'US/Eastern', 'Europe/Moscow'])
+    def test_tz_convert_single_matches_tz_convert_hourly(self, tz):
+        # US: 2014-03-09 - 2014-11-11
+        # MOSCOW: 2014-10-26  /  2014-12-31
+        tz_didx = date_range('2014-03-01', '2015-01-10', freq='H', tz=tz)
+        utc_didx = date_range('2014-03-01', '2015-01-10', freq='H')
+        compare_utc_to_local(tz_didx, utc_didx)
+
+        # local tz to UTC can be differ in hourly (or higher) freqs because
+        # of DST
+        compare_local_to_utc(tz_didx, utc_didx)
+
+    @pytest.mark.parametrize('tz', ['UTC', 'Asia/Tokyo',
+                                    'US/Eastern', 'Europe/Moscow'])
+    @pytest.mark.parametrize('freq', ['D', 'A'])
+    def test_tz_convert_single_matches_tz_convert(self, tz, freq):
+        tz_didx = date_range('2000-01-01', '2020-01-01', freq=freq, tz=tz)
+        utc_didx = date_range('2000-01-01', '2020-01-01', freq=freq)
+        compare_utc_to_local(tz_didx, utc_didx)
+        compare_local_to_utc(tz_didx, utc_didx)
+
+    @pytest.mark.parametrize('arr', [
+        pytest.param(np.array([], dtype=np.int64), id='empty'),
+        pytest.param(np.array([iNaT], dtype=np.int64), id='all_nat')])
+    def test_tz_convert_corner(self, arr):
+        result = conversion.tz_convert(arr,
+                                       timezones.maybe_get_tz('US/Eastern'),
+                                       timezones.maybe_get_tz('Asia/Tokyo'))
+        tm.assert_numpy_array_equal(result, arr)
diff --git a/pandas/tests/tslibs/test_timezones.py b/pandas/tests/tslibs/test_timezones.py
new file mode 100644
index 000000000..603c5e3fe
--- /dev/null
+++ b/pandas/tests/tslibs/test_timezones.py
@@ -0,0 +1,37 @@
+# -*- coding: utf-8 -*-
+from datetime import datetime
+
+import pytest
+import pytz
+import dateutil.tz
+
+from pandas._libs.tslibs import timezones
+from pandas import Timestamp
+
+
+@pytest.mark.parametrize('tz_name', list(pytz.common_timezones))
+def test_cache_keys_are_distinct_for_pytz_vs_dateutil(tz_name):
+    if tz_name == 'UTC':
+        # skip utc as it's a special case in dateutil
+        return
+    tz_p = timezones.maybe_get_tz(tz_name)
+    tz_d = timezones.maybe_get_tz('dateutil/' + tz_name)
+    if tz_d is None:
+        # skip timezones that dateutil doesn't know about.
+        return
+    assert timezones._p_tz_cache_key(tz_p) != timezones._p_tz_cache_key(tz_d)
+
+
+def test_tzlocal():
+    # GH#13583
+    ts = Timestamp('2011-01-01', tz=dateutil.tz.tzlocal())
+    assert ts.tz == dateutil.tz.tzlocal()
+    assert "tz='tzlocal()')" in repr(ts)
+
+    tz = timezones.maybe_get_tz('tzlocal()')
+    assert tz == dateutil.tz.tzlocal()
+
+    # get offset using normal datetime for test
+    offset = dateutil.tz.tzlocal().utcoffset(datetime(2011, 1, 1))
+    offset = offset.total_seconds() * 1000000000
+    assert ts.value + offset == Timestamp('2011-01-01').value

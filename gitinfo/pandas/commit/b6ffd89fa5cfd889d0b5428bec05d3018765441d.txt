commit b6ffd89fa5cfd889d0b5428bec05d3018765441d
Author: Jeff Reback <jeff@reback.net>
Date:   Thu Nov 17 20:34:45 2016 -0500

    ERR: more informative message on invalid Timestamp input
    
    TST: fix unordable error message
    
    xref #14679
    
    TST: handle unorderable exceptions in indexing
    
    closes #14684

diff --git a/doc/source/whatsnew/v0.19.2.txt b/doc/source/whatsnew/v0.19.2.txt
index f4a45a693..499a7e734 100644
--- a/doc/source/whatsnew/v0.19.2.txt
+++ b/doc/source/whatsnew/v0.19.2.txt
@@ -41,5 +41,11 @@ Bug Fixes
 - Bug in not propogating exceptions in parsing invalid datetimes, noted in python 3.6 (:issue:`14561`)
 
 
+- Compat with python 3.6 for pickling of some offsets (:issue:`14685`)
+- Compat with python 3.6 for some indexing exception types (:issue:`14684`)
+- Compat with python 3.6 for deprecation warnings in the test suite (:issue:`14681`)
+
+
+
 
 - Explicit check in ``to_stata`` and ``StataWriter`` for out-of-range values when writing doubles (:issue:`14618`)
diff --git a/pandas/compat/__init__.py b/pandas/compat/__init__.py
index 1b8930dca..532f96046 100644
--- a/pandas/compat/__init__.py
+++ b/pandas/compat/__init__.py
@@ -41,6 +41,7 @@ from collections import namedtuple
 PY2 = sys.version_info[0] == 2
 PY3 = (sys.version_info[0] >= 3)
 PY35 = (sys.version_info >= (3, 5))
+PY36 = (sys.version_info >= (3, 6))
 
 try:
     import __builtin__ as builtins
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 35fcf0d49..660e8c944 100755
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -11,6 +11,7 @@ from pandas.types.common import (is_integer_dtype,
                                  is_sequence,
                                  is_scalar,
                                  is_sparse,
+                                 _is_unorderable_exception,
                                  _ensure_platform_int)
 from pandas.types.missing import isnull, _infer_fill_value
 
@@ -1411,7 +1412,7 @@ class _LocIndexer(_LocationIndexer):
             except TypeError as e:
 
                 # python 3 type errors should be raised
-                if 'unorderable' in str(e):  # pragma: no cover
+                if _is_unorderable_exception(e):
                     error()
                 raise
             except:
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 2310e75f3..105e39562 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -25,6 +25,7 @@ from pandas.types.common import (_coerce_to_dtype, is_categorical_dtype,
                                  is_iterator,
                                  is_dict_like,
                                  is_scalar,
+                                 _is_unorderable_exception,
                                  _ensure_platform_int)
 from pandas.types.generic import ABCSparseArray, ABCDataFrame
 from pandas.types.cast import (_maybe_upcast, _infer_dtype_from_scalar,
@@ -753,7 +754,7 @@ class Series(base.IndexOpsMixin, strings.StringAccessorMixin,
                     raise ValueError("Can only tuple-index with a MultiIndex")
 
                 # python 3 type errors should be raised
-                if 'unorderable' in str(e):  # pragma: no cover
+                if _is_unorderable_exception(e):
                     raise IndexError(key)
 
             if com.is_bool_indexer(key):
diff --git a/pandas/tests/indexes/test_base.py b/pandas/tests/indexes/test_base.py
index ad7e3890b..329e85d82 100644
--- a/pandas/tests/indexes/test_base.py
+++ b/pandas/tests/indexes/test_base.py
@@ -7,7 +7,7 @@ from pandas.indexes.api import Index, MultiIndex
 from .common import Base
 
 from pandas.compat import (is_platform_windows, range, lrange, lzip, u,
-                           zip, PY3)
+                           zip, PY3, PY36)
 import operator
 import os
 
@@ -1774,7 +1774,12 @@ class TestMixedIntIndex(Base, tm.TestCase):
     def test_order(self):
         idx = self.create_index()
         # 9816 deprecated
-        if PY3:
+        if PY36:
+            with tm.assertRaisesRegexp(TypeError, "'>' not supported "
+                                       "between instances of 'str' and 'int'"):
+                with tm.assert_produces_warning(FutureWarning):
+                    idx.order()
+        elif PY3:
             with tm.assertRaisesRegexp(TypeError, "unorderable types"):
                 with tm.assert_produces_warning(FutureWarning):
                     idx.order()
@@ -1784,7 +1789,11 @@ class TestMixedIntIndex(Base, tm.TestCase):
 
     def test_argsort(self):
         idx = self.create_index()
-        if PY3:
+        if PY36:
+            with tm.assertRaisesRegexp(TypeError, "'>' not supported "
+                                       "between instances of 'str' and 'int'"):
+                result = idx.argsort()
+        elif PY3:
             with tm.assertRaisesRegexp(TypeError, "unorderable types"):
                 result = idx.argsort()
         else:
@@ -1794,7 +1803,11 @@ class TestMixedIntIndex(Base, tm.TestCase):
 
     def test_numpy_argsort(self):
         idx = self.create_index()
-        if PY3:
+        if PY36:
+            with tm.assertRaisesRegexp(TypeError, "'>' not supported "
+                                       "between instances of 'str' and 'int'"):
+                result = np.argsort(idx)
+        elif PY3:
             with tm.assertRaisesRegexp(TypeError, "unorderable types"):
                 result = np.argsort(idx)
         else:
diff --git a/pandas/tslib.pyx b/pandas/tslib.pyx
index 91d3f0ef7..e05363de2 100644
--- a/pandas/tslib.pyx
+++ b/pandas/tslib.pyx
@@ -1539,7 +1539,8 @@ cdef convert_to_tsobject(object ts, object tz, object unit,
             "Cannot convert Period to Timestamp "
             "unambiguously. Use to_timestamp")
     else:
-        raise TypeError('Cannot convert input to Timestamp')
+        raise TypeError('Cannot convert input [{}] of type {} to '
+                        'Timestamp'.format(ts, type(ts)))
 
     if obj.value != NPY_NAT:
         _check_dts_bounds(&obj.dts)
diff --git a/pandas/types/common.py b/pandas/types/common.py
index e0e450173..691e15610 100644
--- a/pandas/types/common.py
+++ b/pandas/types/common.py
@@ -1,7 +1,8 @@
 """ common type operations """
 
 import numpy as np
-from pandas.compat import string_types, text_type, binary_type
+from pandas.compat import (string_types, text_type, binary_type,
+                           PY3, PY36)
 from pandas import lib, algos
 from .dtypes import (CategoricalDtype, CategoricalDtypeType,
                      DatetimeTZDtype, DatetimeTZDtypeType,
@@ -188,6 +189,20 @@ def is_datetime_or_timedelta_dtype(arr_or_dtype):
     return issubclass(tipo, (np.datetime64, np.timedelta64))
 
 
+def _is_unorderable_exception(e):
+    """
+    return a boolean if we an unorderable exception error message
+
+    These are different error message for PY>=3<=3.5 and PY>=3.6
+    """
+    if PY36:
+        return ("'>' not supported between instances "
+                "of 'str' and 'int'" in str(e))
+    elif PY3:
+        return 'unorderable' in str(e)
+    return False
+
+
 def is_numeric_v_string_like(a, b):
     """
     numpy doesn't like to compare numeric arrays vs scalar string-likes

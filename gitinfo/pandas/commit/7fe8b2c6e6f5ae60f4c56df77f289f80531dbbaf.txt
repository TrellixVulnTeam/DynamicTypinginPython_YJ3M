commit 7fe8b2c6e6f5ae60f4c56df77f289f80531dbbaf
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Oct 10 15:29:23 2011 -0400

    ENH: add monotonic join logic for object dtype Indexes, start on DataFrame.align

diff --git a/TODO.rst b/TODO.rst
index 2d9dd8786..c879c1fdf 100644
--- a/TODO.rst
+++ b/TODO.rst
@@ -11,3 +11,4 @@ TODO
 - prettytable output with index names
 - Add load/save functions to top level pandas namespace
 - _consolidate, does it always copy?
+- Series.align with fill method. Will have to generate more Cython code
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 633849255..4430bb607 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1010,7 +1010,37 @@ class DataFrame(NDFrame):
             return result
 
     #----------------------------------------------------------------------
-    # Reindexing
+    # Reindexing and alignment
+
+    def align(self, other, join='outer', copy=True):
+        """
+        Align two DataFrame object on their index and columns with the specified
+        join method for each axis Index
+
+        Parameters
+        ----------
+        other : DataFrame
+        join : {'outer', 'inner', 'left', 'right'}, default 'outer'
+
+        Returns
+        -------
+        (left, right) : (Series, Series)
+            Aligned Series
+        """
+        join_index, ilidx, iridx = self.index.join(other.index, how=join,
+                                                   return_indexers=True)
+
+        # TODO: speed up on homogeneous DataFrame objects
+        join_columns, clidx, cridx = self.columns.join(other.columns, how=join,
+                                                       return_indexers=True)
+
+        def _align_frame(frame, row_idx, col_idx):
+            new_data = frame._data
+            return DataFrame(new_data)
+
+        left = _align_frame(self, ilidx, clidx)
+        right = _align_frame(other, iridx, cridx)
+        return left, right
 
     def reindex(self, index=None, columns=None, method=None, copy=True):
         """Conform Series to new index with optional filling logic, placing
diff --git a/pandas/core/index.py b/pandas/core/index.py
index daa9592c6..82183c558 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -441,6 +441,10 @@ class Index(np.ndarray):
         return target, indexer
 
     def join(self, other, how='left', return_indexers=False):
+        if self.is_monotonic and other.is_monotonic:
+            return self._join_monotonic(other, how=how,
+                                        return_indexers=return_indexers)
+
         if how == 'left':
             join_index = self
         elif how == 'right':
@@ -465,6 +469,29 @@ class Index(np.ndarray):
         else:
             return join_index
 
+    def _join_monotonic(self, other, how='left', return_indexers=False):
+        if how == 'left':
+            join_index = self
+            lidx = None
+            ridx = lib.left_join_indexer_object(self, other)
+        elif how == 'right':
+            join_index = other
+            lidx = lib.left_join_indexer_object(other, self)
+            ridx = None
+        elif how == 'inner':
+            join_index, lidx, ridx = lib.inner_join_indexer_object(self, other)
+            join_index = Index(join_index)
+        elif how == 'outer':
+            join_index, lidx, ridx = lib.outer_join_indexer_object(self, other)
+            join_index = Index(join_index)
+        else:  # pragma: no cover
+            raise Exception('do not recognize join method %s' % how)
+
+        if return_indexers:
+            return join_index, lidx, ridx
+        else:
+            return join_index
+
     def slice_locs(self, start=None, end=None):
         """
         For an ordered Index, compute the slice locations for input labels
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 184a6d894..2c56a374c 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1353,26 +1353,19 @@ copy : boolean, default False
         join_index, lidx, ridx = self.index.join(other.index, how=join,
                                                  return_indexers=True)
 
-        if lidx is not None:
-            left = Series(common.take_1d(self.values, lidx), join_index,
-                          name=self.name)
-        else:
-            if copy:
-                new_values = self.values.copy()
-            else:
-                new_values = self.values
-            left = Series(new_values, join_index, name=self.name)
-
-        if ridx is not None:
-            right = Series(common.take_1d(other.values, ridx), join_index,
-                           name=other.name)
-        else:
-            if copy:
-                new_values = other.values.copy()
+        def _align_series(series, indexer):
+            if indexer is not None:
+                new_values = common.take_1d(series.values, indexer)
             else:
-                new_values = other.values
-            right = Series(new_values, join_index, name=other.name)
+                if copy:
+                    new_values = series.values.copy()
+                else:
+                    new_values = series.values
+            result = Series(new_values, join_index, name=series.name)
+            return result
 
+        left = _align_series(self, lidx)
+        right = _align_series(other, ridx)
         return left, right
 
     def reindex(self, index=None, method=None, copy=True):

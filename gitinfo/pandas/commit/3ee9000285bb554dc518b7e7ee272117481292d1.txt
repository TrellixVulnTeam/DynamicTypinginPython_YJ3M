commit 3ee9000285bb554dc518b7e7ee272117481292d1
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Wed Apr 29 12:38:10 2020 -0700

    TST: de-xfail, remove strict=False (#33854)

diff --git a/pandas/tests/arithmetic/test_datetime64.py b/pandas/tests/arithmetic/test_datetime64.py
index e2d53493d..8c480faa4 100644
--- a/pandas/tests/arithmetic/test_datetime64.py
+++ b/pandas/tests/arithmetic/test_datetime64.py
@@ -527,9 +527,9 @@ class TestDatetimeIndexComparisons:
         "op",
         [operator.eq, operator.ne, operator.gt, operator.ge, operator.lt, operator.le],
     )
-    def test_comparison_tzawareness_compat(self, op, box_df_fail):
+    def test_comparison_tzawareness_compat(self, op, box_with_array):
         # GH#18162
-        box = box_df_fail
+        box = box_with_array
 
         dr = pd.date_range("2016-01-01", periods=6)
         dz = dr.tz_localize("US/Pacific")
@@ -541,34 +541,35 @@ class TestDatetimeIndexComparisons:
         with pytest.raises(TypeError, match=msg):
             op(dr, dz)
 
-        # FIXME: DataFrame case fails to raise for == and !=, wrong
-        #  message for inequalities
+        if box is pd.DataFrame:
+            tolist = lambda x: x.astype(object).values.tolist()[0]
+        else:
+            tolist = list
+
         with pytest.raises(TypeError, match=msg):
-            op(dr, list(dz))
+            op(dr, tolist(dz))
         with pytest.raises(TypeError, match=msg):
-            op(dr, np.array(list(dz), dtype=object))
+            op(dr, np.array(tolist(dz), dtype=object))
         with pytest.raises(TypeError, match=msg):
             op(dz, dr)
 
-        # FIXME: DataFrame case fails to raise for == and !=, wrong
-        #  message for inequalities
         with pytest.raises(TypeError, match=msg):
-            op(dz, list(dr))
+            op(dz, tolist(dr))
         with pytest.raises(TypeError, match=msg):
-            op(dz, np.array(list(dr), dtype=object))
+            op(dz, np.array(tolist(dr), dtype=object))
 
         # The aware==aware and naive==naive comparisons should *not* raise
         assert np.all(dr == dr)
-        assert np.all(dr == list(dr))
-        assert np.all(list(dr) == dr)
-        assert np.all(np.array(list(dr), dtype=object) == dr)
-        assert np.all(dr == np.array(list(dr), dtype=object))
+        assert np.all(dr == tolist(dr))
+        assert np.all(tolist(dr) == dr)
+        assert np.all(np.array(tolist(dr), dtype=object) == dr)
+        assert np.all(dr == np.array(tolist(dr), dtype=object))
 
         assert np.all(dz == dz)
-        assert np.all(dz == list(dz))
-        assert np.all(list(dz) == dz)
-        assert np.all(np.array(list(dz), dtype=object) == dz)
-        assert np.all(dz == np.array(list(dz), dtype=object))
+        assert np.all(dz == tolist(dz))
+        assert np.all(tolist(dz) == dz)
+        assert np.all(np.array(tolist(dz), dtype=object) == dz)
+        assert np.all(dz == np.array(tolist(dz), dtype=object))
 
     @pytest.mark.parametrize(
         "op",
diff --git a/pandas/tests/arithmetic/test_timedelta64.py b/pandas/tests/arithmetic/test_timedelta64.py
index b64a52a77..b2ea6d8b9 100644
--- a/pandas/tests/arithmetic/test_timedelta64.py
+++ b/pandas/tests/arithmetic/test_timedelta64.py
@@ -543,14 +543,15 @@ class TestTimedelta64ArithmeticUnsorted:
 
     def test_tda_add_dt64_object_array(self, box_df_fail, tz_naive_fixture):
         # Result should be cast back to DatetimeArray
+        box = box_df_fail
         dti = pd.date_range("2016-01-01", periods=3, tz=tz_naive_fixture)
         dti = dti._with_freq(None)
         tdi = dti - dti
 
-        obj = tm.box_expected(tdi, box_df_fail)
-        other = tm.box_expected(dti, box_df_fail)
+        obj = tm.box_expected(tdi, box)
+        other = tm.box_expected(dti, box)
 
-        warn = PerformanceWarning if box_df_fail is not pd.DataFrame else None
+        warn = PerformanceWarning if box is not pd.DataFrame else None
         with tm.assert_produces_warning(warn):
             result = obj + other.astype(object)
         tm.assert_equal(result, other)
@@ -1195,9 +1196,11 @@ class TestTimedeltaArraylikeAddSubOps:
         result = tdarr - tdi
         tm.assert_equal(result, expected)
 
-    def test_td64arr_add_sub_tdi(self, box, names):
+    def test_td64arr_add_sub_tdi(self, box_with_array, names):
         # GH#17250 make sure result dtype is correct
         # GH#19043 make sure names are propagated correctly
+        box = box_with_array
+
         if box is pd.DataFrame and names[1] != names[0]:
             pytest.skip(
                 "Name propagation for DataFrame does not behave like "
@@ -1205,6 +1208,7 @@ class TestTimedeltaArraylikeAddSubOps:
             )
 
         tdi = TimedeltaIndex(["0 days", "1 day"], name=names[0])
+        tdi = np.array(tdi) if box is tm.to_array else tdi
         ser = Series([Timedelta(hours=3), Timedelta(hours=4)], name=names[1])
         expected = Series(
             [Timedelta(hours=3), Timedelta(days=1, hours=4)], name=names[2]
@@ -1299,8 +1303,10 @@ class TestTimedeltaArraylikeAddSubOps:
     # ------------------------------------------------------------------
     # __add__/__sub__ with DateOffsets and arrays of DateOffsets
 
-    def test_td64arr_add_offset_index(self, names, box):
+    def test_td64arr_add_offset_index(self, names, box_with_array):
         # GH#18849, GH#19744
+        box = box_with_array
+
         if box is pd.DataFrame and names[1] != names[0]:
             pytest.skip(
                 "Name propagation for DataFrame does not behave like "
@@ -1309,6 +1315,7 @@ class TestTimedeltaArraylikeAddSubOps:
 
         tdi = TimedeltaIndex(["1 days 00:00:00", "3 days 04:00:00"], name=names[0])
         other = pd.Index([pd.offsets.Hour(n=1), pd.offsets.Minute(n=-2)], name=names[1])
+        other = np.array(other) if box is tm.to_array else other
 
         expected = TimedeltaIndex(
             [tdi[n] + other[n] for n in range(len(tdi))], freq="infer", name=names[2]
@@ -1347,16 +1354,13 @@ class TestTimedeltaArraylikeAddSubOps:
             res2 = other + tdi
         tm.assert_equal(res2, expected)
 
-    @pytest.mark.parametrize(
-        "names", [(None, None, None), ("foo", "bar", None), ("foo", "foo", "foo")]
-    )
     def test_td64arr_sub_offset_index(self, names, box_with_array):
         # GH#18824, GH#19744
         box = box_with_array
         xbox = box if box is not tm.to_array else pd.Index
         exname = names[2] if box is not tm.to_array else names[1]
 
-        if box is pd.DataFrame and names[1] == "bar":
+        if box is pd.DataFrame and names[1] != names[0]:
             pytest.skip(
                 "Name propagation for DataFrame does not behave like "
                 "it does for Index/Series"
@@ -1392,9 +1396,6 @@ class TestTimedeltaArraylikeAddSubOps:
             res = tdi - other
         tm.assert_equal(res, expected)
 
-    @pytest.mark.parametrize(
-        "names", [(None, None, None), ("foo", "bar", None), ("foo", "foo", "foo")]
-    )
     def test_td64arr_with_offset_series(self, names, box_df_fail):
         # GH#18849
         box = box_df_fail
@@ -2030,9 +2031,13 @@ class TestTimedeltaArraylikeMulDivOps:
         with pytest.raises(TypeError, match=pattern):
             vector.astype(object) / tdser
 
-    def test_td64arr_mul_int_series(self, box_df_fail, names):
+    def test_td64arr_mul_int_series(self, box_with_array, names, request):
         # GH#19042 test for correct name attachment
-        box = box_df_fail  # broadcasts along wrong axis, but doesn't raise
+        box = box_with_array
+        if box_with_array is pd.DataFrame and names[2] is None:
+            reason = "broadcasts along wrong axis, but doesn't raise"
+            request.node.add_marker(pytest.mark.xfail(reason=reason))
+
         exname = names[2] if box is not tm.to_array else names[1]
 
         tdi = TimedeltaIndex(
@@ -2056,7 +2061,10 @@ class TestTimedeltaArraylikeMulDivOps:
 
         # The direct operation tdi * ser still needs to be fixed.
         result = ser.__rmul__(tdi)
-        tm.assert_equal(result, expected)
+        if box is pd.DataFrame:
+            assert result is NotImplemented
+        else:
+            tm.assert_equal(result, expected)
 
     # TODO: Should we be parametrizing over types for `ser` too?
     def test_float_series_rdiv_td64arr(self, box_with_array, names):
diff --git a/pandas/tests/extension/base/ops.py b/pandas/tests/extension/base/ops.py
index 400904121..d3b647204 100644
--- a/pandas/tests/extension/base/ops.py
+++ b/pandas/tests/extension/base/ops.py
@@ -29,8 +29,14 @@ class BaseOpsUtil(BaseExtensionTests):
     def _check_op(self, s, op, other, op_name, exc=NotImplementedError):
         if exc is None:
             result = op(s, other)
-            expected = s.combine(other, op)
-            self.assert_series_equal(result, expected)
+            if isinstance(s, pd.DataFrame):
+                if len(s.columns) != 1:
+                    raise NotImplementedError
+                expected = s.iloc[:, 0].combine(other, op).to_frame()
+                self.assert_frame_equal(result, expected)
+            else:
+                expected = s.combine(other, op)
+                self.assert_series_equal(result, expected)
         else:
             with pytest.raises(exc):
                 op(s, other)
diff --git a/pandas/tests/extension/test_boolean.py b/pandas/tests/extension/test_boolean.py
index 20b1eaec7..0b8b334e5 100644
--- a/pandas/tests/extension/test_boolean.py
+++ b/pandas/tests/extension/test_boolean.py
@@ -102,13 +102,15 @@ class TestMissing(base.BaseMissingTests):
 
 
 class TestArithmeticOps(base.BaseArithmeticOpsTests):
+    implements = {"__sub__", "__rsub__"}
+
     def check_opname(self, s, op_name, other, exc=None):
         # overwriting to indicate ops don't raise an error
         super().check_opname(s, op_name, other, exc=None)
 
     def _check_op(self, s, op, other, op_name, exc=NotImplementedError):
         if exc is None:
-            if op_name in ("__sub__", "__rsub__"):
+            if op_name in self.implements:
                 # subtraction for bools raises TypeError (but not yet in 1.13)
                 if _np_version_under1p14:
                     pytest.skip("__sub__ does not yet raise in numpy 1.13")
@@ -151,6 +153,14 @@ class TestArithmeticOps(base.BaseArithmeticOpsTests):
         # other specific errors tested in the boolean array specific tests
         pass
 
+    def test_arith_frame_with_scalar(self, data, all_arithmetic_operators):
+        # frame & scalar
+        op_name = all_arithmetic_operators
+        if op_name in self.implements:
+            super().test_arith_frame_with_scalar(data, all_arithmetic_operators)
+        else:
+            pytest.xfail("_reduce needs implementation")
+
 
 class TestComparisonOps(base.BaseComparisonOpsTests):
     def check_opname(self, s, op_name, other, exc=None):
diff --git a/pandas/tests/extension/test_categorical.py b/pandas/tests/extension/test_categorical.py
index 390c7a2af..d1211e477 100644
--- a/pandas/tests/extension/test_categorical.py
+++ b/pandas/tests/extension/test_categorical.py
@@ -203,6 +203,14 @@ class TestCasting(base.BaseCastingTests):
 
 
 class TestArithmeticOps(base.BaseArithmeticOpsTests):
+    def test_arith_frame_with_scalar(self, data, all_arithmetic_operators):
+        # frame & scalar
+        op_name = all_arithmetic_operators
+        if op_name != "__rmod__":
+            super().test_arith_frame_with_scalar(data, all_arithmetic_operators)
+        else:
+            pytest.skip("rmod never called when string is first argument")
+
     def test_arith_series_with_scalar(self, data, all_arithmetic_operators):
 
         op_name = all_arithmetic_operators
diff --git a/pandas/tests/extension/test_datetime.py b/pandas/tests/extension/test_datetime.py
index 3aa188098..e026809f7 100644
--- a/pandas/tests/extension/test_datetime.py
+++ b/pandas/tests/extension/test_datetime.py
@@ -111,6 +111,15 @@ class TestInterface(BaseDatetimeTests, base.BaseInterfaceTests):
 class TestArithmeticOps(BaseDatetimeTests, base.BaseArithmeticOpsTests):
     implements = {"__sub__", "__rsub__"}
 
+    def test_arith_frame_with_scalar(self, data, all_arithmetic_operators):
+        # frame & scalar
+        if all_arithmetic_operators in self.implements:
+            df = pd.DataFrame({"A": data})
+            self.check_opname(df, all_arithmetic_operators, data[0], exc=None)
+        else:
+            # ... but not the rest.
+            super().test_arith_frame_with_scalar(data, all_arithmetic_operators)
+
     def test_arith_series_with_scalar(self, data, all_arithmetic_operators):
         if all_arithmetic_operators in self.implements:
             s = pd.Series(data)
diff --git a/pandas/tests/extension/test_period.py b/pandas/tests/extension/test_period.py
index c439b8b5e..11b41eedd 100644
--- a/pandas/tests/extension/test_period.py
+++ b/pandas/tests/extension/test_period.py
@@ -84,6 +84,15 @@ class TestInterface(BasePeriodTests, base.BaseInterfaceTests):
 class TestArithmeticOps(BasePeriodTests, base.BaseArithmeticOpsTests):
     implements = {"__sub__", "__rsub__"}
 
+    def test_arith_frame_with_scalar(self, data, all_arithmetic_operators):
+        # frame & scalar
+        if all_arithmetic_operators in self.implements:
+            df = pd.DataFrame({"A": data})
+            self.check_opname(df, all_arithmetic_operators, data[0], exc=None)
+        else:
+            # ... but not the rest.
+            super().test_arith_frame_with_scalar(data, all_arithmetic_operators)
+
     def test_arith_series_with_scalar(self, data, all_arithmetic_operators):
         # we implement substitution...
         if all_arithmetic_operators in self.implements:
diff --git a/pandas/tests/frame/test_cumulative.py b/pandas/tests/frame/test_cumulative.py
index 1b7e70dd2..248f3500c 100644
--- a/pandas/tests/frame/test_cumulative.py
+++ b/pandas/tests/frame/test_cumulative.py
@@ -7,9 +7,8 @@ tests.series.test_cumulative
 """
 
 import numpy as np
-import pytest
 
-from pandas import DataFrame, Series, _is_numpy_dev
+from pandas import DataFrame, Series
 import pandas._testing as tm
 
 
@@ -74,11 +73,6 @@ class TestDataFrameCumulativeOps:
         df.cumprod(0)
         df.cumprod(1)
 
-    @pytest.mark.xfail(
-        _is_numpy_dev,
-        reason="https://github.com/pandas-dev/pandas/issues/31992",
-        strict=False,
-    )
     def test_cummin(self, datetime_frame):
         datetime_frame.iloc[5:10, 0] = np.nan
         datetime_frame.iloc[10:15, 1] = np.nan
@@ -102,11 +96,6 @@ class TestDataFrameCumulativeOps:
         cummin_xs = datetime_frame.cummin(axis=1)
         assert np.shape(cummin_xs) == np.shape(datetime_frame)
 
-    @pytest.mark.xfail(
-        _is_numpy_dev,
-        reason="https://github.com/pandas-dev/pandas/issues/31992",
-        strict=False,
-    )
     def test_cummax(self, datetime_frame):
         datetime_frame.iloc[5:10, 0] = np.nan
         datetime_frame.iloc[10:15, 1] = np.nan
diff --git a/pandas/tests/groupby/test_categorical.py b/pandas/tests/groupby/test_categorical.py
index 8e4a71418..781625f1f 100644
--- a/pandas/tests/groupby/test_categorical.py
+++ b/pandas/tests/groupby/test_categorical.py
@@ -3,7 +3,7 @@ from datetime import datetime
 import numpy as np
 import pytest
 
-from pandas.compat import PY37
+from pandas.compat import PY37, is_platform_windows
 
 import pandas as pd
 from pandas import (
@@ -13,6 +13,7 @@ from pandas import (
     Index,
     MultiIndex,
     Series,
+    _np_version_under1p17,
     qcut,
 )
 import pandas._testing as tm
@@ -210,7 +211,10 @@ def test_level_get_group(observed):
 
 # GH#21636 flaky on py37; may be related to older numpy, see discussion
 #  https://github.com/MacPython/pandas-wheels/pull/64
-@pytest.mark.xfail(PY37, reason="Flaky, GH-27902", strict=False)
+@pytest.mark.xfail(
+    PY37 and _np_version_under1p17 and not is_platform_windows(),
+    reason="Flaky, GH-27902",
+)
 @pytest.mark.parametrize("ordered", [True, False])
 def test_apply(ordered):
     # GH 10138
diff --git a/pandas/tests/io/parser/test_usecols.py b/pandas/tests/io/parser/test_usecols.py
index 979eb4702..d4e049cc3 100644
--- a/pandas/tests/io/parser/test_usecols.py
+++ b/pandas/tests/io/parser/test_usecols.py
@@ -558,11 +558,13 @@ def test_raises_on_usecols_names_mismatch(all_parsers, usecols, kwargs, expected
         tm.assert_frame_equal(result, expected)
 
 
-@pytest.mark.xfail(
-    reason="see gh-16469: works on the C engine but not the Python engine", strict=False
-)
 @pytest.mark.parametrize("usecols", [["A", "C"], [0, 2]])
-def test_usecols_subset_names_mismatch_orig_columns(all_parsers, usecols):
+def test_usecols_subset_names_mismatch_orig_columns(all_parsers, usecols, request):
+    if all_parsers.engine != "c":
+        reason = "see gh-16469: works on the C engine but not the Python engine"
+        # Number of passed names did not match number of header fields in the file
+        request.node.add_marker(pytest.mark.xfail(reason=reason, raises=ValueError))
+
     data = "a,b,c,d\n1,2,3,4\n5,6,7,8"
     names = ["A", "B", "C", "D"]
     parser = all_parsers
diff --git a/pandas/tests/scalar/timedelta/test_arithmetic.py b/pandas/tests/scalar/timedelta/test_arithmetic.py
index 3825fc451..17d6edfd1 100644
--- a/pandas/tests/scalar/timedelta/test_arithmetic.py
+++ b/pandas/tests/scalar/timedelta/test_arithmetic.py
@@ -419,7 +419,6 @@ class TestTimedeltaMultiplicationDivision:
                     _is_numpy_dev,
                     raises=RuntimeWarning,
                     reason="https://github.com/pandas-dev/pandas/issues/31992",
-                    strict=False,
                 ),
             ),
             float("nan"),
diff --git a/pandas/tests/series/test_cumulative.py b/pandas/tests/series/test_cumulative.py
index 259c5d53c..0b4c5f091 100644
--- a/pandas/tests/series/test_cumulative.py
+++ b/pandas/tests/series/test_cumulative.py
@@ -11,7 +11,6 @@ import numpy as np
 import pytest
 
 import pandas as pd
-from pandas import _is_numpy_dev
 import pandas._testing as tm
 
 
@@ -38,11 +37,6 @@ class TestSeriesCumulativeOps:
     def test_cumprod(self, datetime_series):
         _check_accum_op("cumprod", datetime_series)
 
-    @pytest.mark.xfail(
-        _is_numpy_dev,
-        reason="https://github.com/pandas-dev/pandas/issues/31992",
-        strict=False,
-    )
     def test_cummin(self, datetime_series):
         tm.assert_numpy_array_equal(
             datetime_series.cummin().values,
@@ -56,11 +50,6 @@ class TestSeriesCumulativeOps:
         result.index = result.index._with_freq(None)
         tm.assert_series_equal(result, expected)
 
-    @pytest.mark.xfail(
-        _is_numpy_dev,
-        reason="https://github.com/pandas-dev/pandas/issues/31992",
-        strict=False,
-    )
     def test_cummax(self, datetime_series):
         tm.assert_numpy_array_equal(
             datetime_series.cummax().values,
diff --git a/pandas/tests/test_downstream.py b/pandas/tests/test_downstream.py
index 57542aa3b..b671564eb 100644
--- a/pandas/tests/test_downstream.py
+++ b/pandas/tests/test_downstream.py
@@ -69,6 +69,7 @@ def test_oo_optimizable():
 
 @tm.network
 # Cython import warning
+@pytest.mark.filterwarnings("ignore:pandas.util.testing is deprecated")
 @pytest.mark.filterwarnings("ignore:can't:ImportWarning")
 @pytest.mark.filterwarnings(
     # patsy needs to update their imports
@@ -140,19 +141,19 @@ def test_pyarrow(df):
     tm.assert_frame_equal(result, df)
 
 
-@pytest.mark.xfail(reason="pandas-wheels-50", strict=False)
 def test_missing_required_dependency():
     # GH 23868
     # To ensure proper isolation, we pass these flags
     # -S : disable site-packages
     # -s : disable user site-packages
     # -E : disable PYTHON* env vars, especially PYTHONPATH
-    # And, that's apparently not enough, so we give up.
     # https://github.com/MacPython/pandas-wheels/pull/50
-    call = ["python", "-sSE", "-c", "import pandas"]
+
+    pyexe = sys.executable.replace("\\", "/")
+    call = [pyexe, "-sSE", "-c", "import pandas"]
 
     msg = (
-        r"Command '\['python', '-sSE', '-c', 'import pandas'\]' "
+        rf"Command '\['{pyexe}', '-sSE', '-c', 'import pandas'\]' "
         "returned non-zero exit status 1."
     )
 
diff --git a/pandas/tests/test_expressions.py b/pandas/tests/test_expressions.py
index fadab5d82..b0a369ea6 100644
--- a/pandas/tests/test_expressions.py
+++ b/pandas/tests/test_expressions.py
@@ -363,8 +363,6 @@ class TestExpressions:
     @pytest.mark.parametrize("axis", (0, 1))
     def test_frame_series_axis(self, axis, arith):
         # GH#26736 Dataframe.floordiv(Series, axis=1) fails
-        if axis == 1 and arith == "floordiv":
-            pytest.xfail("'floordiv' does not succeed with axis=1 #27636")
 
         df = self.frame
         if axis == 1:
diff --git a/pandas/tests/tseries/offsets/test_offsets_properties.py b/pandas/tests/tseries/offsets/test_offsets_properties.py
index 716d3ff3f..082aa45f9 100644
--- a/pandas/tests/tseries/offsets/test_offsets_properties.py
+++ b/pandas/tests/tseries/offsets/test_offsets_properties.py
@@ -85,8 +85,6 @@ gen_yqm_offset = st.one_of(
 # Offset-specific behaviour tests
 
 
-# Based on CI runs: Always passes on OSX, fails on Linux, sometimes on Windows
-@pytest.mark.xfail(strict=False, reason="inconsistent between OSs, Pythons")
 @given(gen_random_datetime, gen_yqm_offset)
 def test_on_offset_implementations(dt, offset):
     assume(not offset.normalize)

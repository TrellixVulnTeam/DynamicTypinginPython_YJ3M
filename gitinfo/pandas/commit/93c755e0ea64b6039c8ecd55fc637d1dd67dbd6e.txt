commit 93c755e0ea64b6039c8ecd55fc637d1dd67dbd6e
Author: Mie~~~ <ogotaiking@gmail.com>
Date:   Wed Nov 8 11:00:34 2017 +0800

    BUG:fix rolling skew kurt floating issue (#18065)

diff --git a/doc/source/whatsnew/v0.21.1.txt b/doc/source/whatsnew/v0.21.1.txt
index 6044f25ca..d4cfb6d5b 100644
--- a/doc/source/whatsnew/v0.21.1.txt
+++ b/doc/source/whatsnew/v0.21.1.txt
@@ -59,6 +59,7 @@ Bug Fixes
 - Bug in ``DataFrame.resample(...).apply(...)`` when there is a callable that returns different columns (:issue:`15169`)
 - Bug in :class:`TimedeltaIndex` subtraction could incorrectly overflow when ``NaT`` is present (:issue:`17791`)
 - Bug in :class:`DatetimeIndex` subtracting datetimelike from DatetimeIndex could fail to overflow (:issue:`18020`)
+- Bug in ``pd.Series.rolling.skew()`` and ``rolling.kurt()`` with all equal values has floating issue (:issue:`18044`)
 
 Conversion
 ^^^^^^^^^^
diff --git a/pandas/_libs/window.pyx b/pandas/_libs/window.pyx
index a95e50785..4d5ebdc0c 100644
--- a/pandas/_libs/window.pyx
+++ b/pandas/_libs/window.pyx
@@ -788,7 +788,17 @@ cdef inline double calc_skew(int64_t minp, int64_t nobs, double x, double xx,
         A = x / dnobs
         B = xx / dnobs - A * A
         C = xxx / dnobs - A * A * A - 3 * A * B
-        if B <= 0 or nobs < 3:
+
+        # #18044: with uniform distribution, floating issue will
+        #         cause B != 0. and cause the result is a very
+        #         large number.
+        #
+        #         in core/nanops.py nanskew/nankurt call the function
+        #         _zero_out_fperr(m2) to fix floating error.
+        #         if the variance is less than 1e-14, it could be
+        #         treat as zero, here we follow the original
+        #         skew/kurt behaviour to check B <= 1e-14
+        if B <= 1e-14 or nobs < 3:
             result = NaN
         else:
             R = sqrt(B)
@@ -915,7 +925,16 @@ cdef inline double calc_kurt(int64_t minp, int64_t nobs, double x, double xx,
         R = R * A
         D = xxxx / dnobs - R - 6 * B * A * A - 4 * C * A
 
-        if B == 0 or nobs < 4:
+        # #18044: with uniform distribution, floating issue will
+        #         cause B != 0. and cause the result is a very
+        #         large number.
+        #
+        #         in core/nanops.py nanskew/nankurt call the function
+        #         _zero_out_fperr(m2) to fix floating error.
+        #         if the variance is less than 1e-14, it could be
+        #         treat as zero, here we follow the original
+        #         skew/kurt behaviour to check B <= 1e-14
+        if B <= 1e-14 or nobs < 4:
             result = NaN
         else:
             K = (dnobs * dnobs - 1.) * D / (B * B) - 3 * ((dnobs - 1.) ** 2)
diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index baeb86923..e1c09947a 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -548,6 +548,9 @@ def nanskew(values, axis=None, skipna=True):
     m3 = adjusted3.sum(axis, dtype=np.float64)
 
     # floating point error
+    #
+    # #18044 in _libs/windows.pyx calc_skew follow this behavior
+    # to fix the fperr to treat m2 <1e-14 as zero
     m2 = _zero_out_fperr(m2)
     m3 = _zero_out_fperr(m3)
 
@@ -609,6 +612,9 @@ def nankurt(values, axis=None, skipna=True):
         result = numer / denom - adj
 
     # floating point error
+    #
+    # #18044 in _libs/windows.pyx calc_kurt follow this behavior
+    # to fix the fperr to treat denom <1e-14 as zero
     numer = _zero_out_fperr(numer)
     denom = _zero_out_fperr(denom)
 
@@ -699,6 +705,7 @@ def _maybe_null_out(result, axis, mask):
 
 
 def _zero_out_fperr(arg):
+    # #18044 reference this behavior to fix rolling skew/kurt issue
     if isinstance(arg, np.ndarray):
         with np.errstate(invalid='ignore'):
             return np.where(np.abs(arg) < 1e-14, 0, arg)
diff --git a/pandas/tests/test_window.py b/pandas/tests/test_window.py
index c567613ac..165813a89 100644
--- a/pandas/tests/test_window.py
+++ b/pandas/tests/test_window.py
@@ -2979,6 +2979,16 @@ class TestMomentsConsistency(Base):
         x = d.rolling(window=4).kurt()
         tm.assert_series_equal(expected, x)
 
+    def test_rolling_skew_eq_value_fperr(self):
+        # #18804 all rolling skew for all equal values should return Nan
+        a = pd.Series([1.1] * 15).rolling(window=10).skew()
+        assert np.isnan(a).all()
+
+    def test_rolling_kurt_eq_value_fperr(self):
+        # #18804 all rolling kurt for all equal values should return Nan
+        a = pd.Series([1.1] * 15).rolling(window=10).kurt()
+        assert np.isnan(a).all()
+
     def _check_expanding_ndarray(self, func, static_comp, has_min_periods=True,
                                  has_time_rule=True, preserve_nan=True):
         result = func(self.arr)

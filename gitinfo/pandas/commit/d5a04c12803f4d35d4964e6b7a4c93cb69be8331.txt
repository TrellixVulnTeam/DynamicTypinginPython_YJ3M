commit d5a04c12803f4d35d4964e6b7a4c93cb69be8331
Author: DrIrv <irv@princeton.com>
Date:   Wed Oct 14 12:14:51 2015 -0400

    Bug in read_excel with multi-index containing integers #11317
    
    Bug in to_excel with openpyxl 2.2+ and merging #11408

diff --git a/doc/source/whatsnew/v0.17.1.txt b/doc/source/whatsnew/v0.17.1.txt
index 70226ca30..060bea759 100755
--- a/doc/source/whatsnew/v0.17.1.txt
+++ b/doc/source/whatsnew/v0.17.1.txt
@@ -79,14 +79,13 @@ Bug Fixes
 - Bug in ``HDFStore.select`` when comparing with a numpy scalar in a where clause (:issue:`11283`)
 
 
+
 - Bug in tz-conversions with an ambiguous time and ``.dt`` accessors (:issue:`11295`)
 - Bug in comparisons of Series vs list-likes (:issue:`11339`)
 
 
 - Bug in ``DataFrame.replace`` with a ``datetime64[ns, tz]`` and a non-compat to_replace (:issue:`11326`, :issue:`11153`)
 
-
-
 - Bug in list-like indexing with a mixed-integer Index (:issue:`11320`)
 
 - Bug in ``pivot_table`` with ``margins=True`` when indexes are of ``Categorical`` dtype (:issue:`10993`)
@@ -114,6 +113,12 @@ Bug Fixes
 
 - Bug in ``pandas.json`` when file to load is big (:issue:`11344`)
 - Bugs in ``to_excel`` with duplicate columns (:issue:`11007`, :issue:`10982`, :issue:`10970`)
+
 - Fixed a bug that prevented the construction of an empty series of dtype
   ``datetime64[ns, tz]`` (:issue:`11245`).
+
+- Bug in ``read_excel`` with multi-index containing integers (:issue:`11317`)
+
+- Bug in ``to_excel`` with openpyxl 2.2+ and merging (:issue:`11408`)
+
 - Bug in ``DataFrame.to_dict()`` produces a ``np.datetime64`` object instead of ``Timestamp`` when only datetime is present in data (:issue:`11327`)
diff --git a/pandas/core/format.py b/pandas/core/format.py
index 4a3b1d02c..efa4b182f 100644
--- a/pandas/core/format.py
+++ b/pandas/core/format.py
@@ -1729,7 +1729,7 @@ class ExcelFormatter(object):
             return
 
         columns = self.columns
-        level_strs = columns.format(sparsify=True, adjoin=False, names=False)
+        level_strs = columns.format(sparsify=self.merge_cells, adjoin=False, names=False)
         level_lengths = _get_level_lengths(level_strs)
         coloffset = 0
         lnum = 0
@@ -1873,8 +1873,9 @@ class ExcelFormatter(object):
 
             # MultiIndex columns require an extra row
             # with index names (blank if None) for
-            # unambigous round-trip
-            if isinstance(self.columns, MultiIndex):
+            # unambigous round-trip, unless not merging,
+            # in which case the names all go on one row Issue #11328
+            if isinstance(self.columns, MultiIndex) and self.merge_cells:
                 self.rowcounter += 1
 
             # if index labels are not empty go ahead and dump
diff --git a/pandas/io/excel.py b/pandas/io/excel.py
index a7a844cdf..ffd2768c7 100644
--- a/pandas/io/excel.py
+++ b/pandas/io/excel.py
@@ -708,7 +708,12 @@ class _Openpyxl1Writer(ExcelWriter):
         for cell in cells:
             colletter = get_column_letter(startcol + cell.col + 1)
             xcell = wks.cell("%s%s" % (colletter, startrow + cell.row + 1))
-            xcell.value = _conv_value(cell.val)
+            if (isinstance(cell.val, compat.string_types)
+                    and xcell.data_type_for_value(cell.val)
+                         != xcell.TYPE_STRING):
+                xcell.set_value_explicit(cell.val)
+            else:
+                xcell.value = _conv_value(cell.val)
             style = None
             if cell.style:
                 style = self._convert_to_style(cell.style)
@@ -1240,7 +1245,7 @@ class _Openpyxl22Writer(_Openpyxl20Writer):
                         start_row=startrow + cell.row + 1,
                         start_column=startcol + cell.col + 1,
                         end_column=startcol + cell.mergeend + 1,
-                        end_row=startrow + cell.mergeend + 1
+                        end_row=startrow + cell.mergestart + 1
                         )
 
                 # When cells are merged only the top-left cell is preserved
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index fb58c4517..3cf91d36d 100755
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -873,10 +873,13 @@ class ParserBase(object):
         columns = lzip(*[extract(r) for r in header])
         names = ic + columns
 
+        def tostr(x):
+            return str(x) if not isinstance(x, compat.string_types) else x
+
         # if we find 'Unnamed' all of a single level, then our header was too
         # long
         for n in range(len(columns[0])):
-            if all(['Unnamed' in c[n] for c in columns]):
+            if all(['Unnamed' in tostr(c[n]) for c in columns]):
                 raise _parser.CParserError(
                     "Passed header=[%s] are too many rows for this "
                     "multi_index of columns"
diff --git a/pandas/io/tests/data/testmultiindex.xls b/pandas/io/tests/data/testmultiindex.xls
index 3664c5c8d..51ef0f6c0 100644
Binary files a/pandas/io/tests/data/testmultiindex.xls and b/pandas/io/tests/data/testmultiindex.xls differ
diff --git a/pandas/io/tests/data/testmultiindex.xlsm b/pandas/io/tests/data/testmultiindex.xlsm
index 8f359782b..28c92a5f0 100644
Binary files a/pandas/io/tests/data/testmultiindex.xlsm and b/pandas/io/tests/data/testmultiindex.xlsm differ
diff --git a/pandas/io/tests/data/testmultiindex.xlsx b/pandas/io/tests/data/testmultiindex.xlsx
index a70110caf..815f3b073 100644
Binary files a/pandas/io/tests/data/testmultiindex.xlsx and b/pandas/io/tests/data/testmultiindex.xlsx differ
diff --git a/pandas/io/tests/test_excel.py b/pandas/io/tests/test_excel.py
index b06216719..a03e54f80 100644
--- a/pandas/io/tests/test_excel.py
+++ b/pandas/io/tests/test_excel.py
@@ -558,6 +558,12 @@ class XlrdTests(ReadingTestsBase):
         actual = read_excel(mi_file, 'mi_column_name', header=[0,1], index_col=0)
         tm.assert_frame_equal(actual, expected)
 
+        # Issue #11317
+        expected.columns = mi.set_levels([1,2],level=1).set_names(['c1', 'c2'])
+        actual = read_excel(mi_file, 'name_with_int', index_col=0, header=[0,1])
+        tm.assert_frame_equal(actual, expected)
+
+        expected.columns = mi.set_names(['c1', 'c2'])
         expected.index = mi.set_names(['ilvl1', 'ilvl2'])
         actual = read_excel(mi_file, 'both_name', index_col=[0,1], header=[0,1])
         tm.assert_frame_equal(actual, expected)
@@ -1083,7 +1089,38 @@ class ExcelWriterBase(SharedItems):
             df = read_excel(reader, 'test1', index_col=[0, 1],
                               parse_dates=False)
             tm.assert_frame_equal(frame, df)
-            self.assertEqual(frame.index.names, df.index.names)
+
+    # Test for Issue 11328. If column indices are integers, make
+    # sure they are handled correctly for either setting of
+    # merge_cells
+    def test_to_excel_multiindex_cols(self):
+        _skip_if_no_xlrd()
+
+        frame = self.frame
+        arrays = np.arange(len(frame.index) * 2).reshape(2, -1)
+        new_index = MultiIndex.from_arrays(arrays,
+                                           names=['first', 'second'])
+        frame.index = new_index
+
+        new_cols_index = MultiIndex.from_tuples([(40, 1), (40, 2),
+                                                 (50, 1), (50, 2)])
+        frame.columns = new_cols_index
+        header = [0, 1]
+        if not self.merge_cells:
+            header = 0
+
+        with ensure_clean(self.ext) as path:
+             # round trip
+            frame.to_excel(path, 'test1', merge_cells=self.merge_cells)
+            reader = ExcelFile(path)
+            df = read_excel(reader, 'test1', header=header,
+                            index_col=[0, 1],
+                            parse_dates=False)
+            if not self.merge_cells:
+                fm = frame.columns.format(sparsify=False,
+                                          adjoin=False, names=False)
+                frame.columns = [ ".".join(map(str, q)) for q in zip(*fm) ]
+            tm.assert_frame_equal(frame, df)
 
     def test_to_excel_multiindex_dates(self):
         _skip_if_no_xlrd()

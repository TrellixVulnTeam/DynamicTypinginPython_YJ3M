commit 0ffc4b56c57e914b85d5b5b0033e21ee0525307f
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Fri Feb 23 03:36:42 2018 -0800

    BUG: fix index op names and pinning (#19723)

diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index 59fe4bba6..c343126db 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -1,11 +1,11 @@
-import datetime
+from datetime import datetime, timedelta
 import warnings
 import operator
 
 import numpy as np
 from pandas._libs import (lib, index as libindex, tslib as libts,
                           algos as libalgos, join as libjoin,
-                          Timestamp, Timedelta)
+                          Timedelta)
 from pandas._libs.lib import is_datetime_array
 
 from pandas.compat import range, u, set_function_name
@@ -47,6 +47,7 @@ from pandas.core.dtypes.common import (
 from pandas.core.base import PandasObject, IndexOpsMixin
 import pandas.core.common as com
 import pandas.core.base as base
+from pandas.core import ops
 from pandas.util._decorators import (
     Appender, Substitution, cache_readonly, deprecate_kwarg)
 from pandas.core.indexes.frozen import FrozenList
@@ -55,7 +56,7 @@ import pandas.core.missing as missing
 import pandas.core.algorithms as algos
 import pandas.core.sorting as sorting
 from pandas.io.formats.printing import pprint_thing
-from pandas.core.ops import _comp_method_OBJECT_ARRAY, make_invalid_op
+from pandas.core.ops import make_invalid_op
 from pandas.core.config import get_option
 from pandas.core.strings import StringMethods
 
@@ -82,6 +83,74 @@ def _try_get_item(x):
         return x
 
 
+def _make_comparison_op(op, cls):
+    def cmp_method(self, other):
+        if isinstance(other, (np.ndarray, Index, ABCSeries)):
+            if other.ndim > 0 and len(self) != len(other):
+                raise ValueError('Lengths must match to compare')
+
+        # we may need to directly compare underlying
+        # representations
+        if needs_i8_conversion(self) and needs_i8_conversion(other):
+            return self._evaluate_compare(other, op)
+
+        if is_object_dtype(self) and self.nlevels == 1:
+            # don't pass MultiIndex
+            with np.errstate(all='ignore'):
+                result = ops._comp_method_OBJECT_ARRAY(op, self.values, other)
+        else:
+            with np.errstate(all='ignore'):
+                result = op(self.values, np.asarray(other))
+
+        # technically we could support bool dtyped Index
+        # for now just return the indexing array directly
+        if is_bool_dtype(result):
+            return result
+        try:
+            return Index(result)
+        except TypeError:
+            return result
+
+    name = '__{name}__'.format(name=op.__name__)
+    # TODO: docstring?
+    return set_function_name(cmp_method, name, cls)
+
+
+def _make_arithmetic_op(op, cls):
+    def index_arithmetic_method(self, other):
+        if isinstance(other, (ABCSeries, ABCDataFrame)):
+            return NotImplemented
+        elif isinstance(other, ABCTimedeltaIndex):
+            # Defer to subclass implementation
+            return NotImplemented
+
+        other = self._validate_for_numeric_binop(other, op)
+
+        # handle time-based others
+        if isinstance(other, (ABCDateOffset, np.timedelta64, timedelta)):
+            return self._evaluate_with_timedelta_like(other, op)
+        elif isinstance(other, (datetime, np.datetime64)):
+            return self._evaluate_with_datetime_like(other, op)
+
+        values = self.values
+        with np.errstate(all='ignore'):
+            result = op(values, other)
+
+        result = missing.dispatch_missing(op, values, other, result)
+
+        attrs = self._get_attributes_dict()
+        attrs = self._maybe_update_attributes(attrs)
+        if op is divmod:
+            result = (Index(result[0], **attrs), Index(result[1], **attrs))
+        else:
+            result = Index(result, **attrs)
+        return result
+
+    name = '__{name}__'.format(name=op.__name__)
+    # TODO: docstring?
+    return set_function_name(index_arithmetic_method, name, cls)
+
+
 class InvalidIndexError(Exception):
     pass
 
@@ -2175,11 +2244,13 @@ class Index(IndexOpsMixin, PandasObject):
     def __radd__(self, other):
         return Index(other + np.array(self))
 
-    __iadd__ = __add__
+    def __iadd__(self, other):
+        # alias for __add__
+        return self + other
 
     def __sub__(self, other):
         raise TypeError("cannot perform __sub__ with this index type: "
-                        "{typ}".format(typ=type(self)))
+                        "{typ}".format(typ=type(self).__name__))
 
     def __and__(self, other):
         return self.intersection(other)
@@ -3917,13 +3988,11 @@ class Index(IndexOpsMixin, PandasObject):
             return self._shallow_copy(self.values[~self._isnan])
         return self._shallow_copy()
 
-    def _evaluate_with_timedelta_like(self, other, op, opstr, reversed=False):
+    def _evaluate_with_timedelta_like(self, other, op):
         # Timedelta knows how to operate with np.array, so dispatch to that
         # operation and then wrap the results
         other = Timedelta(other)
         values = self.values
-        if reversed:
-            values, other = other, values
 
         with np.errstate(all='ignore'):
             result = op(values, other)
@@ -3934,7 +4003,7 @@ class Index(IndexOpsMixin, PandasObject):
             return Index(result[0], **attrs), Index(result[1], **attrs)
         return Index(result, **attrs)
 
-    def _evaluate_with_datetime_like(self, other, op, opstr):
+    def _evaluate_with_datetime_like(self, other, op):
         raise TypeError("can only perform ops with datetime like values")
 
     def _evaluate_compare(self, other, op):
@@ -3943,64 +4012,39 @@ class Index(IndexOpsMixin, PandasObject):
     @classmethod
     def _add_comparison_methods(cls):
         """ add in comparison methods """
-
-        def _make_compare(op):
-            def _evaluate_compare(self, other):
-                if isinstance(other, (np.ndarray, Index, ABCSeries)):
-                    if other.ndim > 0 and len(self) != len(other):
-                        raise ValueError('Lengths must match to compare')
-
-                # we may need to directly compare underlying
-                # representations
-                if needs_i8_conversion(self) and needs_i8_conversion(other):
-                    return self._evaluate_compare(other, op)
-
-                if (is_object_dtype(self) and
-                        self.nlevels == 1):
-
-                    # don't pass MultiIndex
-                    with np.errstate(all='ignore'):
-                        result = _comp_method_OBJECT_ARRAY(
-                            op, self.values, other)
-                else:
-                    with np.errstate(all='ignore'):
-                        result = op(self.values, np.asarray(other))
-
-                # technically we could support bool dtyped Index
-                # for now just return the indexing array directly
-                if is_bool_dtype(result):
-                    return result
-                try:
-                    return Index(result)
-                except TypeError:
-                    return result
-
-            name = '__{name}__'.format(name=op.__name__)
-            return set_function_name(_evaluate_compare, name, cls)
-
-        cls.__eq__ = _make_compare(operator.eq)
-        cls.__ne__ = _make_compare(operator.ne)
-        cls.__lt__ = _make_compare(operator.lt)
-        cls.__gt__ = _make_compare(operator.gt)
-        cls.__le__ = _make_compare(operator.le)
-        cls.__ge__ = _make_compare(operator.ge)
+        cls.__eq__ = _make_comparison_op(operator.eq, cls)
+        cls.__ne__ = _make_comparison_op(operator.ne, cls)
+        cls.__lt__ = _make_comparison_op(operator.lt, cls)
+        cls.__gt__ = _make_comparison_op(operator.gt, cls)
+        cls.__le__ = _make_comparison_op(operator.le, cls)
+        cls.__ge__ = _make_comparison_op(operator.ge, cls)
 
     @classmethod
     def _add_numeric_methods_add_sub_disabled(cls):
         """ add in the numeric add/sub methods to disable """
-        cls.__add__ = cls.__radd__ = __iadd__ = make_invalid_op('__add__')  # noqa
-        cls.__sub__ = __isub__ = make_invalid_op('__sub__')  # noqa
+        cls.__add__ = make_invalid_op('__add__')
+        cls.__radd__ = make_invalid_op('__radd__')
+        cls.__iadd__ = make_invalid_op('__iadd__')
+        cls.__sub__ = make_invalid_op('__sub__')
+        cls.__rsub__ = make_invalid_op('__rsub__')
+        cls.__isub__ = make_invalid_op('__isub__')
 
     @classmethod
     def _add_numeric_methods_disabled(cls):
         """ add in numeric methods to disable other than add/sub """
         cls.__pow__ = make_invalid_op('__pow__')
         cls.__rpow__ = make_invalid_op('__rpow__')
-        cls.__mul__ = cls.__rmul__ = make_invalid_op('__mul__')
-        cls.__floordiv__ = cls.__rfloordiv__ = make_invalid_op('__floordiv__')
-        cls.__truediv__ = cls.__rtruediv__ = make_invalid_op('__truediv__')
+        cls.__mul__ = make_invalid_op('__mul__')
+        cls.__rmul__ = make_invalid_op('__rmul__')
+        cls.__floordiv__ = make_invalid_op('__floordiv__')
+        cls.__rfloordiv__ = make_invalid_op('__rfloordiv__')
+        cls.__truediv__ = make_invalid_op('__truediv__')
+        cls.__rtruediv__ = make_invalid_op('__rtruediv__')
         if not compat.PY3:
-            cls.__div__ = cls.__rdiv__ = make_invalid_op('__div__')
+            cls.__div__ = make_invalid_op('__div__')
+            cls.__rdiv__ = make_invalid_op('__rdiv__')
+        cls.__mod__ = make_invalid_op('__mod__')
+        cls.__divmod__ = make_invalid_op('__divmod__')
         cls.__neg__ = make_invalid_op('__neg__')
         cls.__pos__ = make_invalid_op('__pos__')
         cls.__abs__ = make_invalid_op('__abs__')
@@ -4015,34 +4059,29 @@ class Index(IndexOpsMixin, PandasObject):
 
         if not self._is_numeric_dtype:
             raise TypeError("cannot evaluate a numeric op "
-                            "{opstr} for type: {typ}".format(
-                                opstr=opstr,
-                                typ=type(self))
-                            )
+                            "{opstr} for type: {typ}"
+                            .format(opstr=opstr, typ=type(self).__name__))
 
-    def _validate_for_numeric_binop(self, other, op, opstr):
+    def _validate_for_numeric_binop(self, other, op):
         """
         return valid other, evaluate or raise TypeError
         if we are not of the appropriate type
 
         internal method called by ops
         """
+        opstr = '__{opname}__'.format(opname=op.__name__)
         # if we are an inheritor of numeric,
         # but not actually numeric (e.g. DatetimeIndex/PeriodIndex)
         if not self._is_numeric_dtype:
             raise TypeError("cannot evaluate a numeric op {opstr} "
-                            "for type: {typ}".format(
-                                opstr=opstr,
-                                typ=type(self))
-                            )
+                            "for type: {typ}"
+                            .format(opstr=opstr, typ=type(self).__name__))
 
         if isinstance(other, Index):
             if not other._is_numeric_dtype:
                 raise TypeError("cannot evaluate a numeric op "
-                                "{opstr} with type: {typ}".format(
-                                    opstr=type(self),
-                                    typ=type(other))
-                                )
+                                "{opstr} with type: {typ}"
+                                .format(opstr=opstr, typ=type(other)))
         elif isinstance(other, np.ndarray) and not other.ndim:
             other = other.item()
 
@@ -4054,11 +4093,10 @@ class Index(IndexOpsMixin, PandasObject):
             if other.dtype.kind not in ['f', 'i', 'u']:
                 raise TypeError("cannot evaluate a numeric op "
                                 "with a non-numeric dtype")
-        elif isinstance(other, (ABCDateOffset, np.timedelta64,
-                                datetime.timedelta)):
+        elif isinstance(other, (ABCDateOffset, np.timedelta64, timedelta)):
             # higher up to handle
             pass
-        elif isinstance(other, (Timestamp, np.datetime64)):
+        elif isinstance(other, (datetime, np.datetime64)):
             # higher up to handle
             pass
         else:
@@ -4070,73 +4108,24 @@ class Index(IndexOpsMixin, PandasObject):
     @classmethod
     def _add_numeric_methods_binary(cls):
         """ add in numeric methods """
-
-        def _make_evaluate_binop(op, opstr, reversed=False, constructor=Index):
-            def _evaluate_numeric_binop(self, other):
-                if isinstance(other, (ABCSeries, ABCDataFrame)):
-                    return NotImplemented
-                elif isinstance(other, ABCTimedeltaIndex):
-                    # Defer to subclass implementation
-                    return NotImplemented
-
-                other = self._validate_for_numeric_binop(other, op, opstr)
-
-                # handle time-based others
-                if isinstance(other, (ABCDateOffset, np.timedelta64,
-                                      datetime.timedelta)):
-                    return self._evaluate_with_timedelta_like(other, op, opstr,
-                                                              reversed)
-                elif isinstance(other, (Timestamp, np.datetime64)):
-                    return self._evaluate_with_datetime_like(other, op, opstr)
-
-                # if we are a reversed non-commutative op
-                values = self.values
-                if reversed:
-                    values, other = other, values
-
-                attrs = self._get_attributes_dict()
-                attrs = self._maybe_update_attributes(attrs)
-                with np.errstate(all='ignore'):
-                    result = op(values, other)
-
-                result = missing.dispatch_missing(op, values, other, result)
-                return constructor(result, **attrs)
-
-            return _evaluate_numeric_binop
-
-        cls.__add__ = cls.__radd__ = _make_evaluate_binop(
-            operator.add, '__add__')
-        cls.__sub__ = _make_evaluate_binop(
-            operator.sub, '__sub__')
-        cls.__rsub__ = _make_evaluate_binop(
-            operator.sub, '__sub__', reversed=True)
-        cls.__mul__ = cls.__rmul__ = _make_evaluate_binop(
-            operator.mul, '__mul__')
-        cls.__rpow__ = _make_evaluate_binop(
-            operator.pow, '__pow__', reversed=True)
-        cls.__pow__ = _make_evaluate_binop(
-            operator.pow, '__pow__')
-        cls.__mod__ = _make_evaluate_binop(
-            operator.mod, '__mod__')
-        cls.__floordiv__ = _make_evaluate_binop(
-            operator.floordiv, '__floordiv__')
-        cls.__rfloordiv__ = _make_evaluate_binop(
-            operator.floordiv, '__floordiv__', reversed=True)
-        cls.__truediv__ = _make_evaluate_binop(
-            operator.truediv, '__truediv__')
-        cls.__rtruediv__ = _make_evaluate_binop(
-            operator.truediv, '__truediv__', reversed=True)
+        cls.__add__ = _make_arithmetic_op(operator.add, cls)
+        cls.__radd__ = _make_arithmetic_op(ops.radd, cls)
+        cls.__sub__ = _make_arithmetic_op(operator.sub, cls)
+        cls.__rsub__ = _make_arithmetic_op(ops.rsub, cls)
+        cls.__mul__ = _make_arithmetic_op(operator.mul, cls)
+        cls.__rmul__ = _make_arithmetic_op(ops.rmul, cls)
+        cls.__rpow__ = _make_arithmetic_op(ops.rpow, cls)
+        cls.__pow__ = _make_arithmetic_op(operator.pow, cls)
+        cls.__mod__ = _make_arithmetic_op(operator.mod, cls)
+        cls.__floordiv__ = _make_arithmetic_op(operator.floordiv, cls)
+        cls.__rfloordiv__ = _make_arithmetic_op(ops.rfloordiv, cls)
+        cls.__truediv__ = _make_arithmetic_op(operator.truediv, cls)
+        cls.__rtruediv__ = _make_arithmetic_op(ops.rtruediv, cls)
         if not compat.PY3:
-            cls.__div__ = _make_evaluate_binop(
-                operator.div, '__div__')
-            cls.__rdiv__ = _make_evaluate_binop(
-                operator.div, '__div__', reversed=True)
+            cls.__div__ = _make_arithmetic_op(operator.div, cls)
+            cls.__rdiv__ = _make_arithmetic_op(ops.rdiv, cls)
 
-        cls.__divmod__ = _make_evaluate_binop(
-            divmod,
-            '__divmod__',
-            constructor=lambda result, **attrs: (Index(result[0], **attrs),
-                                                 Index(result[1], **attrs)))
+        cls.__divmod__ = _make_arithmetic_op(divmod, cls)
 
     @classmethod
     def _add_numeric_methods_unary(cls):
@@ -4153,8 +4142,8 @@ class Index(IndexOpsMixin, PandasObject):
 
             return _evaluate_numeric_unary
 
-        cls.__neg__ = _make_evaluate_unary(lambda x: -x, '__neg__')
-        cls.__pos__ = _make_evaluate_unary(lambda x: x, '__pos__')
+        cls.__neg__ = _make_evaluate_unary(operator.neg, '__neg__')
+        cls.__pos__ = _make_evaluate_unary(operator.pos, '__pos__')
         cls.__abs__ = _make_evaluate_unary(np.abs, '__abs__')
         cls.__inv__ = _make_evaluate_unary(lambda x: -x, '__inv__')
 
diff --git a/pandas/core/indexes/datetimelike.py b/pandas/core/indexes/datetimelike.py
index 187f9fcf5..ac75e5ae5 100644
--- a/pandas/core/indexes/datetimelike.py
+++ b/pandas/core/indexes/datetimelike.py
@@ -669,6 +669,7 @@ class DatetimeIndexOpsMixin(object):
                 result = self._add_offset_array(other)
             elif isinstance(self, TimedeltaIndex) and isinstance(other, Index):
                 if hasattr(other, '_add_delta'):
+                    # i.e. DatetimeIndex, TimedeltaIndex, or PeriodIndex
                     result = other._add_delta(self)
                 else:
                     raise TypeError("cannot add TimedeltaIndex and {typ}"
@@ -693,7 +694,11 @@ class DatetimeIndexOpsMixin(object):
             return result
 
         cls.__add__ = __add__
-        cls.__radd__ = __add__
+
+        def __radd__(self, other):
+            # alias for __add__
+            return self.__add__(other)
+        cls.__radd__ = __radd__
 
         def __sub__(self, other):
             from pandas.core.index import Index
@@ -712,10 +717,10 @@ class DatetimeIndexOpsMixin(object):
                 # Array/Index of DateOffset objects
                 result = self._sub_offset_array(other)
             elif isinstance(self, TimedeltaIndex) and isinstance(other, Index):
-                if not isinstance(other, TimedeltaIndex):
-                    raise TypeError("cannot subtract TimedeltaIndex and {typ}"
-                                    .format(typ=type(other).__name__))
-                result = self._add_delta(-other)
+                # We checked above for timedelta64_dtype(other) so this
+                # must be invalid.
+                raise TypeError("cannot subtract TimedeltaIndex and {typ}"
+                                .format(typ=type(other).__name__))
             elif isinstance(other, DatetimeIndex):
                 result = self._sub_datelike(other)
             elif is_integer(other):
@@ -747,8 +752,15 @@ class DatetimeIndexOpsMixin(object):
             return -(self - other)
         cls.__rsub__ = __rsub__
 
-        cls.__iadd__ = __add__
-        cls.__isub__ = __sub__
+        def __iadd__(self, other):
+            # alias for __add__
+            return self.__add__(other)
+        cls.__iadd__ = __iadd__
+
+        def __isub__(self, other):
+            # alias for __sub__
+            return self.__sub__(other)
+        cls.__isub__ = __isub__
 
     def _add_delta(self, other):
         return NotImplemented
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index debeabf9b..17f92339e 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -100,10 +100,11 @@ def _field_accessor(name, field, docstring=None):
     return property(f)
 
 
-def _dt_index_cmp(opname, cls, nat_result=False):
+def _dt_index_cmp(opname, cls):
     """
     Wrap comparison operations to convert datetime-like to datetime64
     """
+    nat_result = True if opname == '__ne__' else False
 
     def wrapper(self, other):
         func = getattr(super(DatetimeIndex, self), opname)
@@ -291,7 +292,7 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
     def _add_comparison_methods(cls):
         """ add in comparison methods """
         cls.__eq__ = _dt_index_cmp('__eq__', cls)
-        cls.__ne__ = _dt_index_cmp('__ne__', cls, nat_result=True)
+        cls.__ne__ = _dt_index_cmp('__ne__', cls)
         cls.__lt__ = _dt_index_cmp('__lt__', cls)
         cls.__gt__ = _dt_index_cmp('__gt__', cls)
         cls.__le__ = _dt_index_cmp('__le__', cls)
diff --git a/pandas/core/indexes/period.py b/pandas/core/indexes/period.py
index 88f929765..4c14cbffc 100644
--- a/pandas/core/indexes/period.py
+++ b/pandas/core/indexes/period.py
@@ -76,26 +76,25 @@ def dt64arr_to_periodarr(data, freq, tz):
 _DIFFERENT_FREQ_INDEX = period._DIFFERENT_FREQ_INDEX
 
 
-def _period_index_cmp(opname, cls, nat_result=False):
+def _period_index_cmp(opname, cls):
     """
-    Wrap comparison operations to convert datetime-like to datetime64
+    Wrap comparison operations to convert Period-like to PeriodDtype
     """
+    nat_result = True if opname == '__ne__' else False
 
     def wrapper(self, other):
+        op = getattr(self._ndarray_values, opname)
         if isinstance(other, Period):
-            func = getattr(self._ndarray_values, opname)
-            other_base, _ = _gfc(other.freq)
             if other.freq != self.freq:
                 msg = _DIFFERENT_FREQ_INDEX.format(self.freqstr, other.freqstr)
                 raise IncompatibleFrequency(msg)
 
-            result = func(other.ordinal)
+            result = op(other.ordinal)
         elif isinstance(other, PeriodIndex):
             if other.freq != self.freq:
                 msg = _DIFFERENT_FREQ_INDEX.format(self.freqstr, other.freqstr)
                 raise IncompatibleFrequency(msg)
 
-            op = getattr(self._ndarray_values, opname)
             result = op(other._ndarray_values)
 
             mask = self._isnan | other._isnan
@@ -108,8 +107,7 @@ def _period_index_cmp(opname, cls, nat_result=False):
             result.fill(nat_result)
         else:
             other = Period(other, freq=self.freq)
-            func = getattr(self._ndarray_values, opname)
-            result = func(other.ordinal)
+            result = op(other.ordinal)
 
         if self.hasnans:
             result[self._isnan] = nat_result
@@ -231,7 +229,7 @@ class PeriodIndex(DatelikeOps, DatetimeIndexOpsMixin, Int64Index):
     def _add_comparison_methods(cls):
         """ add in comparison methods """
         cls.__eq__ = _period_index_cmp('__eq__', cls)
-        cls.__ne__ = _period_index_cmp('__ne__', cls, nat_result=True)
+        cls.__ne__ = _period_index_cmp('__ne__', cls)
         cls.__lt__ = _period_index_cmp('__lt__', cls)
         cls.__gt__ = _period_index_cmp('__gt__', cls)
         cls.__le__ = _period_index_cmp('__le__', cls)
diff --git a/pandas/core/indexes/range.py b/pandas/core/indexes/range.py
index 0ac415ee0..9d770cffb 100644
--- a/pandas/core/indexes/range.py
+++ b/pandas/core/indexes/range.py
@@ -16,6 +16,7 @@ from pandas.compat import lrange, range, get_range_parameters
 from pandas.compat.numpy import function as nv
 
 import pandas.core.common as com
+from pandas.core import ops
 from pandas.core.indexes.base import Index, _index_shared_docs
 from pandas.util._decorators import Appender, cache_readonly
 import pandas.core.dtypes.concat as _concat
@@ -570,16 +571,12 @@ class RangeIndex(Int64Index):
     def _add_numeric_methods_binary(cls):
         """ add in numeric methods, specialized to RangeIndex """
 
-        def _make_evaluate_binop(op, opstr, reversed=False, step=False):
+        def _make_evaluate_binop(op, step=False):
             """
             Parameters
             ----------
             op : callable that accepts 2 parms
                 perform the binary op
-            opstr : string
-                string name of ops
-            reversed : boolean, default False
-                if this is a reversed op, e.g. radd
             step : callable, optional, default to False
                 op to apply to the step parm if not None
                 if False, use the existing step
@@ -594,17 +591,13 @@ class RangeIndex(Int64Index):
                 elif isinstance(other, (timedelta, np.timedelta64)):
                     # GH#19333 is_integer evaluated True on timedelta64,
                     # so we need to catch these explicitly
-                    if reversed:
-                        return op(other, self._int64index)
                     return op(self._int64index, other)
 
-                other = self._validate_for_numeric_binop(other, op, opstr)
+                other = self._validate_for_numeric_binop(other, op)
                 attrs = self._get_attributes_dict()
                 attrs = self._maybe_update_attributes(attrs)
 
                 left, right = self, other
-                if reversed:
-                    left, right = right, left
 
                 try:
                     # apply if we have an override
@@ -638,43 +631,26 @@ class RangeIndex(Int64Index):
 
                     return result
 
-                except (ValueError, TypeError, AttributeError,
-                        ZeroDivisionError):
+                except (ValueError, TypeError, ZeroDivisionError):
                     # Defer to Int64Index implementation
-                    if reversed:
-                        return op(other, self._int64index)
                     return op(self._int64index, other)
+                    # TODO: Do attrs get handled reliably?
 
             return _evaluate_numeric_binop
 
-        cls.__add__ = cls.__radd__ = _make_evaluate_binop(
-            operator.add, '__add__')
-        cls.__sub__ = _make_evaluate_binop(operator.sub, '__sub__')
-        cls.__rsub__ = _make_evaluate_binop(
-            operator.sub, '__sub__', reversed=True)
-        cls.__mul__ = cls.__rmul__ = _make_evaluate_binop(
-            operator.mul,
-            '__mul__',
-            step=operator.mul)
-        cls.__truediv__ = _make_evaluate_binop(
-            operator.truediv,
-            '__truediv__',
-            step=operator.truediv)
-        cls.__rtruediv__ = _make_evaluate_binop(
-            operator.truediv,
-            '__truediv__',
-            reversed=True,
-            step=operator.truediv)
+        cls.__add__ = _make_evaluate_binop(operator.add)
+        cls.__radd__ = _make_evaluate_binop(ops.radd)
+        cls.__sub__ = _make_evaluate_binop(operator.sub)
+        cls.__rsub__ = _make_evaluate_binop(ops.rsub)
+        cls.__mul__ = _make_evaluate_binop(operator.mul, step=operator.mul)
+        cls.__rmul__ = _make_evaluate_binop(ops.rmul, step=ops.rmul)
+        cls.__truediv__ = _make_evaluate_binop(operator.truediv,
+                                               step=operator.truediv)
+        cls.__rtruediv__ = _make_evaluate_binop(ops.rtruediv,
+                                                step=ops.rtruediv)
         if not compat.PY3:
-            cls.__div__ = _make_evaluate_binop(
-                operator.div,
-                '__div__',
-                step=operator.div)
-            cls.__rdiv__ = _make_evaluate_binop(
-                operator.div,
-                '__div__',
-                reversed=True,
-                step=operator.div)
+            cls.__div__ = _make_evaluate_binop(operator.div, step=operator.div)
+            cls.__rdiv__ = _make_evaluate_binop(ops.rdiv, step=ops.rdiv)
 
 
 RangeIndex._add_numeric_methods()
diff --git a/pandas/core/indexes/timedeltas.py b/pandas/core/indexes/timedeltas.py
index 6b61db53d..3542a2429 100644
--- a/pandas/core/indexes/timedeltas.py
+++ b/pandas/core/indexes/timedeltas.py
@@ -53,10 +53,11 @@ def _field_accessor(name, alias, docstring=None):
     return property(f)
 
 
-def _td_index_cmp(opname, cls, nat_result=False):
+def _td_index_cmp(opname, cls):
     """
     Wrap comparison operations to convert timedelta-like to timedelta64
     """
+    nat_result = True if opname == '__ne__' else False
 
     def wrapper(self, other):
         msg = "cannot compare a TimedeltaIndex with type {0}"
@@ -184,7 +185,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, TimelikeOps, Int64Index):
     def _add_comparison_methods(cls):
         """ add in comparison methods """
         cls.__eq__ = _td_index_cmp('__eq__', cls)
-        cls.__ne__ = _td_index_cmp('__ne__', cls, nat_result=True)
+        cls.__ne__ = _td_index_cmp('__ne__', cls)
         cls.__lt__ = _td_index_cmp('__lt__', cls)
         cls.__gt__ = _td_index_cmp('__gt__', cls)
         cls.__le__ = _td_index_cmp('__le__', cls)
@@ -383,11 +384,12 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, TimelikeOps, Int64Index):
 
         return TimedeltaIndex(new_values, freq='infer')
 
-    def _evaluate_with_timedelta_like(self, other, op, opstr, reversed=False):
+    def _evaluate_with_timedelta_like(self, other, op):
         if isinstance(other, ABCSeries):
             # GH#19042
             return NotImplemented
 
+        opstr = '__{opname}__'.format(opname=op.__name__).replace('__r', '__')
         # allow division by a timedelta
         if opstr in ['__div__', '__truediv__', '__floordiv__']:
             if _is_convertible_to_td(other):
@@ -398,11 +400,9 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, TimelikeOps, Int64Index):
 
                 i8 = self.asi8
                 left, right = i8, other.value
-                if reversed:
-                    left, right = right, left
 
                 if opstr in ['__floordiv__']:
-                    result = left // right
+                    result = op(left, right)
                 else:
                     result = op(left, np.float64(right))
                 result = self._maybe_mask_results(result, convert='float64')
diff --git a/pandas/tests/indexes/common.py b/pandas/tests/indexes/common.py
index 1162662bf..8f51dbabd 100644
--- a/pandas/tests/indexes/common.py
+++ b/pandas/tests/indexes/common.py
@@ -127,16 +127,17 @@ class Base(object):
         idx = self.create_index()
         tm.assert_raises_regex(TypeError, "cannot perform __mul__",
                                lambda: idx * 1)
-        tm.assert_raises_regex(TypeError, "cannot perform __mul__",
+        tm.assert_raises_regex(TypeError, "cannot perform __rmul__",
                                lambda: 1 * idx)
 
         div_err = "cannot perform __truediv__" if PY3 \
             else "cannot perform __div__"
         tm.assert_raises_regex(TypeError, div_err, lambda: idx / 1)
+        div_err = div_err.replace(' __', ' __r')
         tm.assert_raises_regex(TypeError, div_err, lambda: 1 / idx)
         tm.assert_raises_regex(TypeError, "cannot perform __floordiv__",
                                lambda: idx // 1)
-        tm.assert_raises_regex(TypeError, "cannot perform __floordiv__",
+        tm.assert_raises_regex(TypeError, "cannot perform __rfloordiv__",
                                lambda: 1 // idx)
 
     def test_logical_compat(self):
diff --git a/pandas/tests/indexes/test_base.py b/pandas/tests/indexes/test_base.py
index 90edcb526..d7f185853 100644
--- a/pandas/tests/indexes/test_base.py
+++ b/pandas/tests/indexes/test_base.py
@@ -7,6 +7,7 @@ from datetime import datetime, timedelta
 from collections import defaultdict
 
 import pandas.util.testing as tm
+from pandas.core.dtypes.generic import ABCIndex
 from pandas.core.dtypes.common import is_unsigned_integer_dtype
 from pandas.core.indexes.api import Index, MultiIndex
 from pandas.tests.indexes.common import Base
@@ -1988,6 +1989,17 @@ Index([u'a', u'bb', u'ccc', u'a', u'bb', u'ccc', u'a', u'bb', u'ccc', u'a',
         tm.assert_index_equal(idx - idx, 0 * idx)
         assert not (idx - idx).empty
 
+    def test_iadd_preserves_name(self):
+        # GH#17067, GH#19723 __iadd__ and __isub__ should preserve index name
+        ser = pd.Series([1, 2, 3])
+        ser.index.name = 'foo'
+
+        ser.index += 1
+        assert ser.index.name == "foo"
+
+        ser.index -= 1
+        assert ser.index.name == "foo"
+
 
 class TestMixedIntIndex(Base):
     # Mostly the tests from common.py for which the results differ
@@ -2301,9 +2313,17 @@ class TestIndexUtils(object):
         tm.assert_index_equal(result, expected)
 
 
-@pytest.mark.parametrize('opname', ['eq', 'ne', 'le', 'lt', 'ge', 'gt'])
+@pytest.mark.parametrize('opname', ['eq', 'ne', 'le', 'lt', 'ge', 'gt',
+                                    'add', 'radd', 'sub', 'rsub',
+                                    'mul', 'rmul', 'truediv', 'rtruediv',
+                                    'floordiv', 'rfloordiv',
+                                    'pow', 'rpow', 'mod', 'divmod'])
 def test_generated_op_names(opname, indices):
     index = indices
+    if isinstance(index, ABCIndex) and opname == 'rsub':
+        # pd.Index.__rsub__ does not exist; though the method does exist
+        # for subclasses.  see GH#19723
+        return
     opname = '__{name}__'.format(name=opname)
     method = getattr(index, opname)
     assert method.__name__ == opname

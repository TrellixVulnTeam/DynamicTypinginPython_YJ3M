commit 00dbf3de095e3658c63163f0a15d366429cbed81
Author: Jeff Reback <jeff@reback.net>
Date:   Fri Feb 13 22:57:15 2015 -0500

    clean up indexing/index method names to make all module public (rather than _ leading)

diff --git a/pandas/core/categorical.py b/pandas/core/categorical.py
index 4032a8e55..fd9ef5d2e 100644
--- a/pandas/core/categorical.py
+++ b/pandas/core/categorical.py
@@ -10,7 +10,6 @@ from pandas.compat import u
 from pandas.core.algorithms import factorize
 from pandas.core.base import PandasObject, PandasDelegate
 from pandas.core.index import Index, _ensure_index
-from pandas.core.indexing import _is_null_slice
 from pandas.tseries.period import PeriodIndex
 import pandas.core.common as com
 from pandas.util.decorators import cache_readonly
@@ -18,7 +17,7 @@ from pandas.util.decorators import cache_readonly
 from pandas.core.common import (CategoricalDtype, ABCSeries, isnull, notnull,
                                 is_categorical_dtype, is_integer_dtype, is_object_dtype,
                                 _possibly_infer_to_datetimelike, get_dtype_kinds,
-                                is_list_like, is_sequence,
+                                is_list_like, is_sequence, is_null_slice,
                                 _ensure_platform_int, _ensure_object, _ensure_int64,
                                 _coerce_indexer_dtype, _values_from_object, take_1d)
 from pandas.util.terminal import get_terminal_size
@@ -78,7 +77,7 @@ def _cat_compare_op(op):
 
     return f
 
-def _maybe_to_categorical(array):
+def maybe_to_categorical(array):
     """ coerce to a categorical if a series is given """
     if isinstance(array, ABCSeries):
         return array.values
@@ -1116,7 +1115,7 @@ class Categorical(PandasObject):
         # only allow 1 dimensional slicing, but can
         # in a 2-d case be passd (slice(None),....)
         if isinstance(slicer, tuple) and len(slicer) == 2:
-            if not _is_null_slice(slicer[0]):
+            if not is_null_slice(slicer[0]):
                 raise AssertionError("invalid slicing for a 1-ndim categorical")
             slicer = slicer[1]
 
@@ -1263,7 +1262,7 @@ class Categorical(PandasObject):
             # only allow 1 dimensional slicing, but can
             # in a 2-d case be passd (slice(None),....)
             if len(key) == 2:
-                if not _is_null_slice(key[0]):
+                if not is_null_slice(key[0]):
                     raise AssertionError("invalid slicing for a 1-ndim categorical")
                 key = key[1]
             elif len(key) == 1:
diff --git a/pandas/core/common.py b/pandas/core/common.py
index 05739a11c..b48e73ca7 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -2544,9 +2544,13 @@ def is_re_compilable(obj):
 
 
 def is_list_like(arg):
-    return (hasattr(arg, '__iter__') and
+     return (hasattr(arg, '__iter__') and
             not isinstance(arg, compat.string_and_binary_types))
 
+def is_null_slice(obj):
+    return (isinstance(obj, slice) and obj.start is None and
+            obj.stop is None and obj.step is None)
+
 
 def is_hashable(arg):
     """Return True if hash(arg) will succeed, False otherwise.
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index dbb4e83ed..733de1fc2 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -30,9 +30,9 @@ from pandas.core.common import (isnull, notnull, PandasError, _try_sort,
                                 is_categorical_dtype)
 from pandas.core.generic import NDFrame, _shared_docs
 from pandas.core.index import Index, MultiIndex, _ensure_index
-from pandas.core.indexing import (_maybe_droplevels,
-                                  _convert_to_index_sliceable,
-                                  _check_bool_indexer)
+from pandas.core.indexing import (maybe_droplevels,
+                                  convert_to_index_sliceable,
+                                  check_bool_indexer)
 from pandas.core.internals import (BlockManager,
                                    create_block_manager_from_arrays,
                                    create_block_manager_from_blocks)
@@ -1765,7 +1765,7 @@ class DataFrame(NDFrame):
             pass
 
         # see if we can slice the rows
-        indexer = _convert_to_index_sliceable(self, key)
+        indexer = convert_to_index_sliceable(self, key)
         if indexer is not None:
             return self._getitem_slice(indexer)
 
@@ -1809,9 +1809,9 @@ class DataFrame(NDFrame):
             elif len(key) != len(self.index):
                 raise ValueError('Item wrong length %d instead of %d.' %
                                  (len(key), len(self.index)))
-            # _check_bool_indexer will throw exception if Series key cannot
+            # check_bool_indexer will throw exception if Series key cannot
             # be reindexed to match DataFrame rows
-            key = _check_bool_indexer(self.index, key)
+            key = check_bool_indexer(self.index, key)
             indexer = key.nonzero()[0]
             return self.take(indexer, axis=0, convert=False)
         else:
@@ -1822,7 +1822,7 @@ class DataFrame(NDFrame):
         loc = self.columns.get_loc(key)
         if isinstance(loc, (slice, Series, np.ndarray, Index)):
             new_columns = self.columns[loc]
-            result_columns = _maybe_droplevels(new_columns, key)
+            result_columns = maybe_droplevels(new_columns, key)
             if self._is_mixed_type:
                 result = self.reindex(columns=new_columns)
                 result.columns = result_columns
@@ -2097,7 +2097,7 @@ class DataFrame(NDFrame):
     def __setitem__(self, key, value):
 
         # see if we can slice the rows
-        indexer = _convert_to_index_sliceable(self, key)
+        indexer = convert_to_index_sliceable(self, key)
         if indexer is not None:
             return self._setitem_slice(indexer, value)
 
@@ -2119,7 +2119,7 @@ class DataFrame(NDFrame):
             if len(key) != len(self.index):
                 raise ValueError('Item wrong length %d instead of %d!' %
                                  (len(key), len(self.index)))
-            key = _check_bool_indexer(self.index, key)
+            key = check_bool_indexer(self.index, key)
             indexer = key.nonzero()[0]
             self._check_setitem_copy()
             self.ix._setitem_with_indexer(indexer, value)
@@ -2246,7 +2246,7 @@ class DataFrame(NDFrame):
             if isinstance(self.columns, MultiIndex) and key in self.columns:
                 loc = self.columns.get_loc(key)
                 if isinstance(loc, (slice, Series, np.ndarray, Index)):
-                    cols = _maybe_droplevels(self.columns[loc], key)
+                    cols = maybe_droplevels(self.columns[loc], key)
                     if len(cols) and not cols.equals(value.columns):
                         value = value.reindex_axis(cols, axis=1)
             # now align rows
diff --git a/pandas/core/index.py b/pandas/core/index.py
index c62f18f24..2444014ac 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -20,7 +20,7 @@ from pandas.core.common import isnull, array_equivalent
 import pandas.core.common as com
 from pandas.core.common import (_values_from_object, is_float, is_integer,
                                 ABCSeries, _ensure_object, _ensure_int64, is_bool_indexer,
-                                is_list_like, is_bool_dtype, is_integer_dtype)
+                                is_list_like, is_bool_dtype, is_null_slice, is_integer_dtype)
 from pandas.core.config import get_option
 from pandas.io.common import PerformanceWarning
 
@@ -720,7 +720,7 @@ class Index(IndexOpsMixin, PandasObject):
         def is_int(v):
             return v is None or is_integer(v)
 
-        is_null_slice = start is None and stop is None
+        is_null_slicer = start is None and stop is None
         is_index_slice = is_int(start) and is_int(stop)
         is_positional = is_index_slice and not self.is_integer()
 
@@ -742,7 +742,7 @@ class Index(IndexOpsMixin, PandasObject):
             if self.inferred_type == 'mixed-integer-float':
                 raise
 
-        if is_null_slice:
+        if is_null_slicer:
             indexer = key
         elif is_positional:
             indexer = key
@@ -2615,7 +2615,7 @@ class Float64Index(NumericIndex):
         if not np.isscalar(key):
             raise InvalidIndexError
 
-        from pandas.core.indexing import _maybe_droplevels
+        from pandas.core.indexing import maybe_droplevels
         from pandas.core.series import Series
 
         k = _values_from_object(key)
@@ -2626,7 +2626,7 @@ class Float64Index(NumericIndex):
             return new_values
 
         new_index = self[loc]
-        new_index = _maybe_droplevels(new_index, k)
+        new_index = maybe_droplevels(new_index, k)
         return Series(new_values, index=new_index, name=series.name)
 
     def equals(self, other):
@@ -3245,7 +3245,7 @@ class MultiIndex(Index):
 
     def get_value(self, series, key):
         # somewhat broken encapsulation
-        from pandas.core.indexing import _maybe_droplevels
+        from pandas.core.indexing import maybe_droplevels
         from pandas.core.series import Series
 
         # Label-based
@@ -3257,7 +3257,7 @@ class MultiIndex(Index):
             loc = self.get_loc(k)
             new_values = series.values[loc]
             new_index = self[loc]
-            new_index = _maybe_droplevels(new_index, k)
+            new_index = maybe_droplevels(new_index, k)
             return Series(new_values, index=new_index, name=series.name)
 
         try:
@@ -4192,7 +4192,7 @@ class MultiIndex(Index):
         -------
         loc : int or slice object
         """
-        def _maybe_drop_levels(indexer, levels, drop_level):
+        def maybe_droplevels(indexer, levels, drop_level):
             if not drop_level:
                 return self[indexer]
             # kludgearound
@@ -4221,7 +4221,7 @@ class MultiIndex(Index):
 
                 result = loc if result is None else result & loc
 
-            return result, _maybe_drop_levels(result, level, drop_level)
+            return result, maybe_droplevels(result, level, drop_level)
 
         level = self._get_level_number(level)
 
@@ -4234,7 +4234,7 @@ class MultiIndex(Index):
             try:
                 if key in self.levels[0]:
                     indexer = self._get_level_indexer(key, level=level)
-                    new_index = _maybe_drop_levels(indexer, [0], drop_level)
+                    new_index = maybe_droplevels(indexer, [0], drop_level)
                     return indexer, new_index
             except TypeError:
                 pass
@@ -4248,8 +4248,8 @@ class MultiIndex(Index):
                         indexer = self.get_loc(key)
                     ilevels = [i for i in range(len(key))
                                if key[i] != slice(None, None)]
-                    return indexer, _maybe_drop_levels(indexer, ilevels,
-                                                       drop_level)
+                    return indexer, maybe_droplevels(indexer, ilevels,
+                                                     drop_level)
 
                 if len(key) == self.nlevels:
 
@@ -4307,11 +4307,11 @@ class MultiIndex(Index):
                     indexer = slice(None, None)
                 ilevels = [i for i in range(len(key))
                            if key[i] != slice(None, None)]
-                return indexer, _maybe_drop_levels(indexer, ilevels,
-                                                   drop_level)
+                return indexer, maybe_droplevels(indexer, ilevels,
+                                                 drop_level)
         else:
             indexer = self._get_level_indexer(key, level=level)
-            return indexer, _maybe_drop_levels(indexer, [level], drop_level)
+            return indexer, maybe_droplevels(indexer, [level], drop_level)
 
     def _get_level_indexer(self, key, level=0):
         # return a boolean indexer or a slice showing where the key is
@@ -4388,8 +4388,6 @@ class MultiIndex(Index):
                for passing to iloc
         """
 
-        from pandas.core.indexing import _is_null_slice
-
         # must be lexsorted to at least as many levels
         if not self.is_lexsorted_for_tuple(tup):
             raise KeyError('MultiIndex Slicing requires the index to be fully lexsorted'
@@ -4427,7 +4425,7 @@ class MultiIndex(Index):
                 else:
                     ranges.append(np.zeros(self.labels[i].shape, dtype=bool))
 
-            elif _is_null_slice(k):
+            elif is_null_slice(k):
                 # empty slice
                 pass
 
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 56446d056..426fce079 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -7,6 +7,7 @@ import pandas.compat as compat
 import pandas.core.common as com
 from pandas.core.common import (is_bool_indexer, is_integer_dtype,
                                 _asarray_tuplesafe, is_list_like, isnull,
+                                is_null_slice,
                                 ABCSeries, ABCDataFrame, ABCPanel, is_float,
                                 _values_from_object, _infer_fill_value, is_integer)
 import pandas.lib as lib
@@ -140,7 +141,7 @@ class _NDFrameIndexer(object):
 
     def _is_nested_tuple_indexer(self, tup):
         if any([ isinstance(ax, MultiIndex) for ax in self.obj.axes ]):
-            return any([ _is_nested_tuple(tup,ax) for ax in self.obj.axes ])
+            return any([ is_nested_tuple(tup,ax) for ax in self.obj.axes ])
         return False
 
     def _convert_tuple(self, key, is_setter=False):
@@ -185,7 +186,7 @@ class _NDFrameIndexer(object):
                 if isinstance(i, slice):
                     # should check the stop slice?
                     pass
-                elif is_list_like(i):
+                elif is_list_like_indexer(i):
                     # should check the elements?
                     pass
                 elif is_integer(i):
@@ -214,7 +215,7 @@ class _NDFrameIndexer(object):
 
                     # reindex the axis to the new value
                     # and set inplace
-                    key, _ = _convert_missing_indexer(idx)
+                    key, _ = convert_missing_indexer(idx)
 
                     # if this is the items axes, then take the main missing
                     # path first
@@ -232,7 +233,7 @@ class _NDFrameIndexer(object):
                             if _i != i
                         ]
                         if any([not l for l in len_non_info_axes]):
-                            if not is_list_like(value):
+                            if not is_list_like_indexer(value):
                                 raise ValueError("cannot set a frame with no "
                                                  "defined index and a scalar")
                             self.obj[key] = value
@@ -242,7 +243,7 @@ class _NDFrameIndexer(object):
                         # add a new item with the dtype setup
                         self.obj[key] = _infer_fill_value(value)
 
-                        new_indexer = _convert_from_missing_indexer_tuple(
+                        new_indexer = convert_from_missing_indexer_tuple(
                             indexer, self.obj.axes)
                         self._setitem_with_indexer(new_indexer, value)
                         return self.obj
@@ -252,7 +253,7 @@ class _NDFrameIndexer(object):
                     # just replacing the block manager here
                     # so the object is the same
                     index = self.obj._get_axis(i)
-                    labels = _safe_append_to_index(index, key)
+                    labels = safe_append_to_index(index, key)
                     self.obj._data = self.obj.reindex_axis(labels, i)._data
                     self.obj._maybe_update_cacher(clear=True)
                     self.obj.is_copy=None
@@ -265,7 +266,7 @@ class _NDFrameIndexer(object):
             indexer = tuple(nindexer)
         else:
 
-            indexer, missing = _convert_missing_indexer(indexer)
+            indexer, missing = convert_missing_indexer(indexer)
 
             if missing:
 
@@ -276,7 +277,7 @@ class _NDFrameIndexer(object):
                     if len(index) == 0:
                         new_index = Index([indexer])
                     else:
-                        new_index = _safe_append_to_index(index, indexer)
+                        new_index = safe_append_to_index(index, indexer)
 
                     # this preserves dtype of the value
                     new_values = Series([value]).values
@@ -307,7 +308,7 @@ class _NDFrameIndexer(object):
                     else:
 
                         # must have conforming columns
-                        if com.is_list_like(value):
+                        if is_list_like_indexer(value):
                             if len(value) != len(self.obj.columns):
                                 raise ValueError(
                                     "cannot set a row with mismatched columns"
@@ -356,11 +357,11 @@ class _NDFrameIndexer(object):
                 idx = indexer[:info_axis][0]
 
                 plane_indexer = tuple([idx]) + indexer[info_axis + 1:]
-                lplane_indexer = _length_of_indexer(plane_indexer[0], index)
+                lplane_indexer = length_of_indexer(plane_indexer[0], index)
 
                 # require that we are setting the right number of values that
                 # we are indexing
-                if is_list_like(value) and np.iterable(value) and lplane_indexer != len(value):
+                if is_list_like_indexer(value) and np.iterable(value) and lplane_indexer != len(value):
 
                     if len(obj[idx]) != len(value):
                         raise ValueError(
@@ -384,8 +385,8 @@ class _NDFrameIndexer(object):
                 plane_indexer = indexer[:info_axis] + indexer[info_axis + 1:]
                 if info_axis > 0:
                     plane_axis = self.obj.axes[:info_axis][0]
-                    lplane_indexer = _length_of_indexer(plane_indexer[0],
-                                                        plane_axis)
+                    lplane_indexer = length_of_indexer(plane_indexer[0],
+                                                       plane_axis)
                 else:
                     lplane_indexer = 0
 
@@ -397,7 +398,7 @@ class _NDFrameIndexer(object):
                 # as we have a null slice which means essentially reassign to the columns
                 # of a multi-dim object
                 # GH6149
-                if isinstance(pi, tuple) and all(_is_null_slice(idx) for idx in pi):
+                if isinstance(pi, tuple) and all(is_null_slice(idx) for idx in pi):
                     s = v
                 else:
                     # set the item, possibly having a dtype change
@@ -427,7 +428,7 @@ class _NDFrameIndexer(object):
 
             # we need an interable, with a ndim of at least 1
             # eg. don't pass thru np.array(0)
-            if _is_list_like(value) and getattr(value,'ndim',1) > 0:
+            if is_list_like_indexer(value) and getattr(value,'ndim',1) > 0:
 
                 # we have an equal len Frame
                 if isinstance(value, ABCDataFrame) and value.ndim > 1:
@@ -474,13 +475,13 @@ class _NDFrameIndexer(object):
 
         else:
             if isinstance(indexer, tuple):
-                indexer = _maybe_convert_ix(*indexer)
+                indexer = maybe_convert_ix(*indexer)
 
                 # if we are setting on the info axis ONLY
                 # set using those methods to avoid block-splitting
                 # logic here
                 if len(indexer) > info_axis and is_integer(indexer[info_axis]) and all(
-                    _is_null_slice(idx) for i, idx in enumerate(indexer) if i != info_axis):
+                    is_null_slice(idx) for i, idx in enumerate(indexer) if i != info_axis):
                     self.obj[item_labels[indexer[info_axis]]] = value
                     return
 
@@ -511,7 +512,7 @@ class _NDFrameIndexer(object):
             ravel = lambda i: i.ravel() if isinstance(i, np.ndarray) else i
             indexer = tuple(map(ravel, indexer))
 
-            aligners = [not _is_null_slice(idx) for idx in indexer]
+            aligners = [not is_null_slice(idx) for idx in indexer]
             sum_aligners = sum(aligners)
             single_aligner = sum_aligners == 1
             is_frame = self.obj.ndim == 2
@@ -550,10 +551,10 @@ class _NDFrameIndexer(object):
 
                 # multiple aligners (or null slices)
                 if com.is_sequence(idx) or isinstance(idx, slice):
-                    if single_aligner and _is_null_slice(idx):
+                    if single_aligner and is_null_slice(idx):
                         continue
                     new_ix = ax[idx]
-                    if not is_list_like(new_ix):
+                    if not is_list_like_indexer(new_ix):
                         new_ix = Index([new_ix])
                     else:
                         new_ix = Index(new_ix)
@@ -611,7 +612,7 @@ class _NDFrameIndexer(object):
 
         if isinstance(indexer, tuple):
 
-            aligners = [not _is_null_slice(idx) for idx in indexer]
+            aligners = [not is_null_slice(idx) for idx in indexer]
             sum_aligners = sum(aligners)
             single_aligner = sum_aligners == 1
 
@@ -652,7 +653,7 @@ class _NDFrameIndexer(object):
                     val = df.reindex(idx, columns=cols).values
                 return val
 
-        elif ((isinstance(indexer, slice) or com.is_list_like(indexer))
+        elif ((isinstance(indexer, slice) or is_list_like_indexer(indexer))
               and is_frame):
             ax = self.obj.index[indexer]
             if df.index.equals(ax):
@@ -707,7 +708,7 @@ class _NDFrameIndexer(object):
             if i >= self.obj.ndim:
                 raise IndexingError('Too many indexers')
 
-            if _is_null_slice(key):
+            if is_null_slice(key):
                 continue
 
             retval = getattr(retval, self.name)._getitem_axis(key, axis=i)
@@ -721,7 +722,7 @@ class _NDFrameIndexer(object):
         if not isinstance(self.obj, NDFrame):
             return False
 
-        if not all(_is_list_like(x) for x in tup):
+        if not all(is_list_like_indexer(x) for x in tup):
             return False
 
         # just too complicated
@@ -753,7 +754,7 @@ class _NDFrameIndexer(object):
         labels = self.obj._get_axis(axis)
 
         if is_bool_indexer(key):
-            key = _check_bool_indexer(labels, key)
+            key = check_bool_indexer(labels, key)
             return labels[key]
         else:
             if isinstance(key, Index):
@@ -814,11 +815,11 @@ class _NDFrameIndexer(object):
         # df.ix[d1:d2, 0] -> columns first (True)
         # df.ix[0, ['C', 'B', A']] -> rows first (False)
         for i, key in enumerate(tup):
-            if _is_label_like(key) or isinstance(key, tuple):
+            if is_label_like(key) or isinstance(key, tuple):
                 section = self._getitem_axis(key, axis=i)
 
                 # we have yielded a scalar ?
-                if not _is_list_like(section):
+                if not is_list_like_indexer(section):
                     return section
 
                 elif section.ndim == self.ndim:
@@ -865,7 +866,7 @@ class _NDFrameIndexer(object):
         axis = 0
         for i, key in enumerate(tup):
 
-            if _is_null_slice(key):
+            if is_null_slice(key):
                 axis += 1
                 continue
 
@@ -899,8 +900,8 @@ class _NDFrameIndexer(object):
         labels = self.obj._get_axis(axis)
         if isinstance(key, slice):
             return self._get_slice_axis(key, axis=axis)
-        elif _is_list_like(key) and not (isinstance(key, tuple) and
-                                         isinstance(labels, MultiIndex)):
+        elif is_list_like_indexer(key) and not (isinstance(key, tuple) and
+                                        isinstance(labels, MultiIndex)):
 
             if hasattr(key, 'ndim') and key.ndim > 1:
                 raise ValueError('Cannot index with multidimensional key')
@@ -946,7 +947,7 @@ class _NDFrameIndexer(object):
             return result
 
         if is_bool_indexer(key):
-            key = _check_bool_indexer(labels, key)
+            key = check_bool_indexer(labels, key)
             inds, = key.nonzero()
             return self.obj.take(inds, axis=axis, convert=False)
         else:
@@ -1091,11 +1092,11 @@ class _NDFrameIndexer(object):
         if isinstance(obj, slice):
             return self._convert_slice_indexer(obj, axis)
 
-        elif _is_nested_tuple(obj, labels):
+        elif is_nested_tuple(obj, labels):
             return labels.get_locs(obj)
-        elif _is_list_like(obj):
+        elif is_list_like_indexer(obj):
             if is_bool_indexer(obj):
-                obj = _check_bool_indexer(labels, obj)
+                obj = check_bool_indexer(labels, obj)
                 inds, = obj.nonzero()
                 return inds
             else:
@@ -1144,7 +1145,7 @@ class _NDFrameIndexer(object):
                 return labels.get_loc(obj)
             except KeyError:
                 # allow a not found key only if we are a setter
-                if not is_list_like(obj) and is_setter:
+                if not is_list_like_indexer(obj) and is_setter:
                     return {'key': obj}
                 raise
 
@@ -1156,7 +1157,7 @@ class _NDFrameIndexer(object):
     def _get_slice_axis(self, slice_obj, axis=0):
         obj = self.obj
 
-        if not _need_slice(slice_obj):
+        if not need_slice(slice_obj):
             return obj
         indexer = self._convert_slice_indexer(slice_obj, axis)
 
@@ -1177,7 +1178,7 @@ class _IXIndexer(_NDFrameIndexer):
         elif is_bool_indexer(key):
             return True
 
-        elif _is_list_like(key):
+        elif is_list_like_indexer(key):
             return True
 
         else:
@@ -1201,7 +1202,7 @@ class _LocationIndexer(_NDFrameIndexer):
 
     def _getbool_axis(self, key, axis=0):
         labels = self.obj._get_axis(axis)
-        key = _check_bool_indexer(labels, key)
+        key = check_bool_indexer(labels, key)
         inds, = key.nonzero()
         try:
             return self.obj.take(inds, axis=axis, convert=False)
@@ -1211,7 +1212,7 @@ class _LocationIndexer(_NDFrameIndexer):
     def _get_slice_axis(self, slice_obj, axis=0):
         """ this is pretty simple as we just have to deal with labels """
         obj = self.obj
-        if not _need_slice(slice_obj):
+        if not need_slice(slice_obj):
             return obj
 
         labels = obj._get_axis(axis)
@@ -1264,7 +1265,7 @@ class _LocIndexer(_LocationIndexer):
         elif is_bool_indexer(key):
             return True
 
-        elif _is_list_like(key):
+        elif is_list_like_indexer(key):
 
             # mi is just a passthru
             if isinstance(key, tuple) and isinstance(ax, MultiIndex):
@@ -1310,7 +1311,7 @@ class _LocIndexer(_LocationIndexer):
             return self._get_slice_axis(key, axis=axis)
         elif is_bool_indexer(key):
             return self._getbool_axis(key, axis=axis)
-        elif _is_list_like(key):
+        elif is_list_like_indexer(key):
 
             # GH 7349
             # possibly convert a list-like into a nested tuple
@@ -1329,7 +1330,7 @@ class _LocIndexer(_LocationIndexer):
                 return self._getitem_iterable(key, axis=axis)
 
             # nested tuple slicing
-            if _is_nested_tuple(key, labels):
+            if is_nested_tuple(key, labels):
                 locs = labels.get_locs(key)
                 indexer = [ slice(None) ] * self.ndim
                 indexer[axis] = locs
@@ -1363,7 +1364,7 @@ class _iLocIndexer(_LocationIndexer):
             return True
         elif is_integer(key):
             return self._is_valid_integer(key, axis)
-        elif _is_list_like(key):
+        elif is_list_like_indexer(key):
             return self._is_valid_list_like(key, axis)
         return False
 
@@ -1405,7 +1406,7 @@ class _iLocIndexer(_LocationIndexer):
             if i >= self.obj.ndim:
                 raise IndexingError('Too many indexers')
 
-            if _is_null_slice(key):
+            if is_null_slice(key):
                 axis += 1
                 continue
 
@@ -1423,7 +1424,7 @@ class _iLocIndexer(_LocationIndexer):
     def _get_slice_axis(self, slice_obj, axis=0):
         obj = self.obj
 
-        if not _need_slice(slice_obj):
+        if not need_slice(slice_obj):
             return obj
 
         slice_obj = self._convert_slice_indexer(slice_obj, axis)
@@ -1445,7 +1446,7 @@ class _iLocIndexer(_LocationIndexer):
         # a single integer or a list of integers
         else:
 
-            if _is_list_like(key):
+            if is_list_like_indexer(key):
 
                 # validate list bounds
                 self._is_valid_list_like(key, axis)
@@ -1493,7 +1494,7 @@ class _ScalarAccessIndexer(_NDFrameIndexer):
         if not isinstance(key, tuple):
 
             # we could have a convertible item here (e.g. Timestamp)
-            if not _is_list_like(key):
+            if not is_list_like_indexer(key):
                 key = tuple([key])
             else:
                 raise ValueError('Invalid call for scalar access (getting)!')
@@ -1555,7 +1556,7 @@ class _iAtIndexer(_ScalarAccessIndexer):
 _eps = np.finfo('f4').eps
 
 
-def _length_of_indexer(indexer, target=None):
+def length_of_indexer(indexer, target=None):
     """return the length of a single non-tuple indexer which could be a slice
     """
     if target is not None and isinstance(indexer, slice):
@@ -1578,12 +1579,12 @@ def _length_of_indexer(indexer, target=None):
         return (stop - start) / step
     elif isinstance(indexer, (ABCSeries, Index, np.ndarray, list)):
         return len(indexer)
-    elif not is_list_like(indexer):
+    elif not is_list_like_indexer(indexer):
         return 1
     raise AssertionError("cannot find the length of the indexer")
 
 
-def _convert_to_index_sliceable(obj, key):
+def convert_to_index_sliceable(obj, key):
     """if we are index sliceable, then return my slicer, otherwise return None
     """
     idx = obj.index
@@ -1606,7 +1607,7 @@ def _convert_to_index_sliceable(obj, key):
     return None
 
 
-def _is_index_slice(obj):
+def is_index_slice(obj):
     def _is_valid_index(x):
         return (is_integer(x) or is_float(x)
                 and np.allclose(x, int(x), rtol=_eps, atol=0))
@@ -1619,7 +1620,7 @@ def _is_index_slice(obj):
     return not both_none and (_crit(obj.start) and _crit(obj.stop))
 
 
-def _check_bool_indexer(ax, key):
+def check_bool_indexer(ax, key):
     # boolean indexing, need to check that the data are aligned, otherwise
     # disallowed
 
@@ -1642,7 +1643,7 @@ def _check_bool_indexer(ax, key):
     return result
 
 
-def _convert_missing_indexer(indexer):
+def convert_missing_indexer(indexer):
     """ reverse convert a missing indexer, which is a dict
         return the scalar indexer and a boolean indicating if we converted """
 
@@ -1658,7 +1659,7 @@ def _convert_missing_indexer(indexer):
     return indexer, False
 
 
-def _convert_from_missing_indexer_tuple(indexer, axes):
+def convert_from_missing_indexer_tuple(indexer, axes):
     """ create a filtered indexer that doesn't have any missing indexers """
     def get_indexer(_i, _idx):
         return (axes[_i].get_loc(_idx['key'])
@@ -1666,7 +1667,7 @@ def _convert_from_missing_indexer_tuple(indexer, axes):
     return tuple([get_indexer(_i, _idx) for _i, _idx in enumerate(indexer)])
 
 
-def _safe_append_to_index(index, key):
+def safe_append_to_index(index, key):
     """ a safe append to an index, if incorrect type, then catch and recreate
     """
     try:
@@ -1679,7 +1680,7 @@ def _safe_append_to_index(index, key):
                          "{1}".format(index.__class__.__name__, key))
 
 
-def _maybe_convert_indices(indices, n):
+def maybe_convert_indices(indices, n):
     """ if we have negative indicies, translate to postive here
     if have indicies that are out-of-bounds, raise an IndexError
     """
@@ -1699,7 +1700,7 @@ def _maybe_convert_indices(indices, n):
     return indices
 
 
-def _maybe_convert_ix(*args):
+def maybe_convert_ix(*args):
     """
     We likely want to take the cross-product
     """
@@ -1715,7 +1716,7 @@ def _maybe_convert_ix(*args):
         return args
 
 
-def _is_nested_tuple(tup, labels):
+def is_nested_tuple(tup, labels):
     # check for a compatiable nested tuple and multiindexes among the axes
     if not isinstance(tup, tuple):
         return False
@@ -1728,31 +1729,22 @@ def _is_nested_tuple(tup, labels):
 
     return False
 
+def is_list_like_indexer(key):
+    # allow a list_like, but exclude NamedTuples which can be indexers
+    return is_list_like(key) and not (isinstance(key, tuple) and type(key) is not tuple)
 
-def _is_null_slice(obj):
-    return (isinstance(obj, slice) and obj.start is None and
-            obj.stop is None and obj.step is None)
-
-
-def _is_label_like(key):
+def is_label_like(key):
     # select a label or row
-    return not isinstance(key, slice) and not _is_list_like(key)
-
-
-def _is_list_like(obj):
-    # Consider namedtuples to be not list like as they are useful as indices
-    return (hasattr(obj, '__iter__')
-            and not isinstance(obj, compat.string_types)
-            and not (isinstance(obj, tuple) and type(obj) is not tuple))
+    return not isinstance(key, slice) and not is_list_like_indexer(key)
 
 
-def _need_slice(obj):
+def need_slice(obj):
     return (obj.start is not None or
             obj.stop is not None or
             (obj.step is not None and obj.step != 1))
 
 
-def _maybe_droplevels(index, key):
+def maybe_droplevels(index, key):
     # drop levels
     original_index = index
     if isinstance(key, tuple):
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 6c0b8f5ec..359463b10 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -16,8 +16,8 @@ from pandas.core.common import (_possibly_downcast_to_dtype, isnull,
                                 _possibly_infer_to_datetimelike, array_equivalent,
                                 _maybe_convert_string_to_object, is_categorical)
 from pandas.core.index import Index, MultiIndex, _ensure_index
-from pandas.core.indexing import (_maybe_convert_indices, _length_of_indexer)
-from pandas.core.categorical import Categorical, _maybe_to_categorical
+from pandas.core.indexing import maybe_convert_indices, length_of_indexer
+from pandas.core.categorical import Categorical, maybe_to_categorical
 import pandas.core.common as com
 from pandas.sparse.array import _maybe_to_sparse, SparseArray
 import pandas.lib as lib
@@ -560,7 +560,7 @@ class Block(PandasObject):
         elif isinstance(indexer, slice):
 
             if is_list_like(value) and l:
-                if len(value) != _length_of_indexer(indexer, values):
+                if len(value) != length_of_indexer(indexer, values):
                     raise ValueError("cannot set using a slice indexer with a "
                                      "different length than the value")
 
@@ -1638,7 +1638,7 @@ class CategoricalBlock(NonConsolidatableMixIn, ObjectBlock):
                  fastpath=False, **kwargs):
 
         # coerce to categorical if we can
-        super(CategoricalBlock, self).__init__(_maybe_to_categorical(values),
+        super(CategoricalBlock, self).__init__(maybe_to_categorical(values),
                                                fastpath=True, placement=placement,
                                                **kwargs)
 
@@ -3262,7 +3262,7 @@ class BlockManager(PandasObject):
 
         n = self.shape[axis]
         if convert:
-            indexer = _maybe_convert_indices(indexer, n)
+            indexer = maybe_convert_indices(indexer, n)
 
         if verify:
             if ((indexer == -1) | (indexer >= n)).any():
@@ -4449,5 +4449,5 @@ def _preprocess_slice_or_indexer(slice_or_indexer, length, allow_fill):
     else:
         indexer = np.asanyarray(slice_or_indexer, dtype=np.int64)
         if not allow_fill:
-            indexer = _maybe_convert_indices(indexer, length)
+            indexer = maybe_convert_indices(indexer, length)
         return 'fancy', indexer, len(indexer)
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index df3e6c019..2b2d28d62 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -10,11 +10,11 @@ import sys
 import warnings
 import numpy as np
 from pandas.core.common import (PandasError, _try_sort, _default_index,
-                                _infer_dtype_from_scalar, notnull)
+                                _infer_dtype_from_scalar, notnull, is_list_like)
 from pandas.core.categorical import Categorical
 from pandas.core.index import (Index, MultiIndex, _ensure_index,
                                _get_combined_index)
-from pandas.core.indexing import _maybe_droplevels, _is_list_like
+from pandas.core.indexing import maybe_droplevels
 from pandas.core.internals import (BlockManager,
                                    create_block_manager_from_arrays,
                                    create_block_manager_from_blocks)
@@ -253,7 +253,7 @@ class Panel(NDFrame):
     def __getitem__(self, key):
         if isinstance(self._info_axis, MultiIndex):
             return self._getitem_multilevel(key)
-        if not (_is_list_like(key) or isinstance(key, slice)):
+        if not (is_list_like(key) or isinstance(key, slice)):
             return super(Panel, self).__getitem__(key)
         return self.ix[key]
 
@@ -262,7 +262,7 @@ class Panel(NDFrame):
         loc = info.get_loc(key)
         if isinstance(loc, (slice, np.ndarray)):
             new_index = info[loc]
-            result_index = _maybe_droplevels(new_index, key)
+            result_index = maybe_droplevels(new_index, key)
             slices = [loc] + [slice(None) for x in range(
                 self._AXIS_LEN - 1)]
             new_values = self.values[slices]
@@ -806,7 +806,7 @@ class Panel(NDFrame):
         # xs cannot handle a non-scalar key, so just reindex here
         # if we have a multi-index and a single tuple, then its a reduction (GH 7516)
         if not (isinstance(ax, MultiIndex) and isinstance(key, tuple)):
-            if _is_list_like(key):
+            if is_list_like(key):
                 indexer = {self._get_axis_name(axis): key}
                 return self.reindex(**indexer)
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 8e859c06c..901faef48 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -24,7 +24,7 @@ from pandas.core.common import (isnull, notnull, is_bool_indexer,
                                 _maybe_box_datetimelike, ABCDataFrame)
 from pandas.core.index import (Index, MultiIndex, InvalidIndexError,
                                _ensure_index)
-from pandas.core.indexing import _check_bool_indexer, _maybe_convert_indices
+from pandas.core.indexing import check_bool_indexer, maybe_convert_indices
 from pandas.core import generic, base
 from pandas.core.internals import SingleBlockManager
 from pandas.core.categorical import Categorical, CategoricalAccessor
@@ -548,7 +548,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
             key = list(key)
 
         if is_bool_indexer(key):
-            key = _check_bool_indexer(self.index, key)
+            key = check_bool_indexer(self.index, key)
 
         return self._get_with(key)
 
@@ -666,7 +666,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
                     raise IndexError(key)
 
             if is_bool_indexer(key):
-                key = _check_bool_indexer(self.index, key)
+                key = check_bool_indexer(self.index, key)
                 try:
                     self.where(~key, value, inplace=True)
                     return
@@ -2183,7 +2183,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         """
         # check/convert indicies here
         if convert:
-            indices = _maybe_convert_indices(
+            indices = maybe_convert_indices(
                 indices, len(self._get_axis(axis)))
 
         indices = com._ensure_platform_int(indices)
diff --git a/pandas/sparse/frame.py b/pandas/sparse/frame.py
index bd34c7e5f..821720f40 100644
--- a/pandas/sparse/frame.py
+++ b/pandas/sparse/frame.py
@@ -13,7 +13,6 @@ import numpy as np
 from pandas.core.common import (isnull, notnull, _pickle_array,
                                 _unpickle_array, _try_sort)
 from pandas.core.index import Index, MultiIndex, _ensure_index
-from pandas.core.indexing import _maybe_convert_indices
 from pandas.core.series import Series
 from pandas.core.frame import (DataFrame, extract_index, _prep_ndarray,
                                _default_index)
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 563e9d4da..82e5d6818 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -13300,7 +13300,8 @@ class TestDataFrame(tm.TestCase, CheckIndexing,
         index = Index([idx1, idx2],
                       name="composite_index", tupleize_cols=False)
         df = DataFrame([(1, 2), (3, 4)], index=index, columns=["A", "B"])
-        self.assertEqual(df.ix[IndexType("foo", "bar")]["A"], 1)
+        result = df.ix[IndexType("foo", "bar")]["A"]
+        self.assertEqual(result, 1)
 
     def test_empty_nonzero(self):
         df = DataFrame([1, 2, 3])

commit 7735405396dae497b5cedf327c16810c20b94561
Author: jreback <jeff@reback.net>
Date:   Wed Mar 20 08:32:29 2013 -0400

    TST: added ensure_clean file cleanup context manager for file based tests

diff --git a/pandas/io/tests/test_excel.py b/pandas/io/tests/test_excel.py
index 062ba0c5e..00005c757 100644
--- a/pandas/io/tests/test_excel.py
+++ b/pandas/io/tests/test_excel.py
@@ -19,7 +19,9 @@ import pandas.io.parsers as parsers
 from pandas.io.parsers import (read_csv, read_table, read_fwf,
                                ExcelFile, TextFileReader, TextParser)
 from pandas.util.testing import (assert_almost_equal,
-                                 assert_series_equal, network)
+                                 assert_series_equal, 
+                                 network,
+                                 ensure_clean)
 import pandas.util.testing as tm
 import pandas as pd
 
@@ -275,31 +277,30 @@ class ExcelTests(unittest.TestCase):
     def _check_extension(self, ext):
         path = '__tmp_to_excel_from_excel__.' + ext
 
-        self.frame['A'][:5] = nan
-
-        self.frame.to_excel(path, 'test1')
-        self.frame.to_excel(path, 'test1', cols=['A', 'B'])
-        self.frame.to_excel(path, 'test1', header=False)
-        self.frame.to_excel(path, 'test1', index=False)
-
-        # test roundtrip
-        self.frame.to_excel(path, 'test1')
-        reader = ExcelFile(path)
-        recons = reader.parse('test1', index_col=0)
-        tm.assert_frame_equal(self.frame, recons)
-
-        self.frame.to_excel(path, 'test1', index=False)
-        reader = ExcelFile(path)
-        recons = reader.parse('test1', index_col=None)
-        recons.index = self.frame.index
-        tm.assert_frame_equal(self.frame, recons)
+        with ensure_clean(path) as path:
+            self.frame['A'][:5] = nan
 
-        self.frame.to_excel(path, 'test1', na_rep='NA')
-        reader = ExcelFile(path)
-        recons = reader.parse('test1', index_col=0, na_values=['NA'])
-        tm.assert_frame_equal(self.frame, recons)
+            self.frame.to_excel(path, 'test1')
+            self.frame.to_excel(path, 'test1', cols=['A', 'B'])
+            self.frame.to_excel(path, 'test1', header=False)
+            self.frame.to_excel(path, 'test1', index=False)
 
-        os.remove(path)
+            # test roundtrip
+            self.frame.to_excel(path, 'test1')
+            reader = ExcelFile(path)
+            recons = reader.parse('test1', index_col=0)
+            tm.assert_frame_equal(self.frame, recons)
+            
+            self.frame.to_excel(path, 'test1', index=False)
+            reader = ExcelFile(path)
+            recons = reader.parse('test1', index_col=None)
+            recons.index = self.frame.index
+            tm.assert_frame_equal(self.frame, recons)
+            
+            self.frame.to_excel(path, 'test1', na_rep='NA')
+            reader = ExcelFile(path)
+            recons = reader.parse('test1', index_col=0, na_values=['NA'])
+            tm.assert_frame_equal(self.frame, recons)
 
     def test_excel_roundtrip_xls_mixed(self):
         _skip_if_no_xlrd()
@@ -315,12 +316,11 @@ class ExcelTests(unittest.TestCase):
     def _check_extension_mixed(self, ext):
         path = '__tmp_to_excel_from_excel_mixed__.' + ext
 
-        self.mixed_frame.to_excel(path, 'test1')
-        reader = ExcelFile(path)
-        recons = reader.parse('test1', index_col=0)
-        tm.assert_frame_equal(self.mixed_frame, recons)
-
-        os.remove(path)
+        with ensure_clean(path) as path:
+            self.mixed_frame.to_excel(path, 'test1')
+            reader = ExcelFile(path)
+            recons = reader.parse('test1', index_col=0)
+            tm.assert_frame_equal(self.mixed_frame, recons)
 
     def test_excel_roundtrip_xls_tsframe(self):
         _skip_if_no_xlrd()
@@ -337,12 +337,11 @@ class ExcelTests(unittest.TestCase):
 
         df = tm.makeTimeDataFrame()[:5]
 
-        df.to_excel(path, 'test1')
-        reader = ExcelFile(path)
-        recons = reader.parse('test1')
-        tm.assert_frame_equal(df, recons)
-
-        os.remove(path)
+        with ensure_clean(path) as path:
+            df.to_excel(path, 'test1')
+            reader = ExcelFile(path)
+            recons = reader.parse('test1')
+            tm.assert_frame_equal(df, recons)
 
     def test_excel_roundtrip_xls_int64(self):
         _skip_if_no_excelsuite()
@@ -355,21 +354,20 @@ class ExcelTests(unittest.TestCase):
     def _check_extension_int64(self, ext):
         path = '__tmp_to_excel_from_excel_int64__.' + ext
 
-        self.frame['A'][:5] = nan
-
-        self.frame.to_excel(path, 'test1')
-        self.frame.to_excel(path, 'test1', cols=['A', 'B'])
-        self.frame.to_excel(path, 'test1', header=False)
-        self.frame.to_excel(path, 'test1', index=False)
-
-        # Test np.int64, values read come back as float
-        frame = DataFrame(np.random.randint(-10, 10, size=(10, 2)), dtype=np.int64)
-        frame.to_excel(path, 'test1')
-        reader = ExcelFile(path)
-        recons = reader.parse('test1').astype(np.int64)
-        tm.assert_frame_equal(frame, recons, check_dtype=False)
+        with ensure_clean(path) as path:
+            self.frame['A'][:5] = nan
 
-        os.remove(path)
+            self.frame.to_excel(path, 'test1')
+            self.frame.to_excel(path, 'test1', cols=['A', 'B'])
+            self.frame.to_excel(path, 'test1', header=False)
+            self.frame.to_excel(path, 'test1', index=False)
+            
+            # Test np.int64, values read come back as float
+            frame = DataFrame(np.random.randint(-10, 10, size=(10, 2)), dtype=np.int64)
+            frame.to_excel(path, 'test1')
+            reader = ExcelFile(path)
+            recons = reader.parse('test1').astype(np.int64)
+            tm.assert_frame_equal(frame, recons, check_dtype=False)
 
     def test_excel_roundtrip_xls_bool(self):
         _skip_if_no_excelsuite()
@@ -382,21 +380,20 @@ class ExcelTests(unittest.TestCase):
     def _check_extension_bool(self, ext):
         path = '__tmp_to_excel_from_excel_bool__.' + ext
 
-        self.frame['A'][:5] = nan
-
-        self.frame.to_excel(path, 'test1')
-        self.frame.to_excel(path, 'test1', cols=['A', 'B'])
-        self.frame.to_excel(path, 'test1', header=False)
-        self.frame.to_excel(path, 'test1', index=False)
-
-        # Test reading/writing np.bool8, roundtrip only works for xlsx
-        frame = (DataFrame(np.random.randn(10, 2)) >= 0)
-        frame.to_excel(path, 'test1')
-        reader = ExcelFile(path)
-        recons = reader.parse('test1').astype(np.bool8)
-        tm.assert_frame_equal(frame, recons)
+        with ensure_clean(path) as path:
+            self.frame['A'][:5] = nan
 
-        os.remove(path)
+            self.frame.to_excel(path, 'test1')
+            self.frame.to_excel(path, 'test1', cols=['A', 'B'])
+            self.frame.to_excel(path, 'test1', header=False)
+            self.frame.to_excel(path, 'test1', index=False)
+            
+            # Test reading/writing np.bool8, roundtrip only works for xlsx
+            frame = (DataFrame(np.random.randn(10, 2)) >= 0)
+            frame.to_excel(path, 'test1')
+            reader = ExcelFile(path)
+            recons = reader.parse('test1').astype(np.bool8)
+            tm.assert_frame_equal(frame, recons)
 
     def test_excel_roundtrip_xls_sheets(self):
         _skip_if_no_excelsuite()
@@ -409,28 +406,28 @@ class ExcelTests(unittest.TestCase):
     def _check_extension_sheets(self, ext):
         path = '__tmp_to_excel_from_excel_sheets__.' + ext
 
-        self.frame['A'][:5] = nan
-
-        self.frame.to_excel(path, 'test1')
-        self.frame.to_excel(path, 'test1', cols=['A', 'B'])
-        self.frame.to_excel(path, 'test1', header=False)
-        self.frame.to_excel(path, 'test1', index=False)
-
-        # Test writing to separate sheets
-        writer = ExcelWriter(path)
-        self.frame.to_excel(writer, 'test1')
-        self.tsframe.to_excel(writer, 'test2')
-        writer.save()
-        reader = ExcelFile(path)
-        recons = reader.parse('test1', index_col=0)
-        tm.assert_frame_equal(self.frame, recons)
-        recons = reader.parse('test2', index_col=0)
-        tm.assert_frame_equal(self.tsframe, recons)
-        np.testing.assert_equal(2, len(reader.sheet_names))
-        np.testing.assert_equal('test1', reader.sheet_names[0])
-        np.testing.assert_equal('test2', reader.sheet_names[1])
-
-        os.remove(path)
+        with ensure_clean(path) as path:
+            self.frame['A'][:5] = nan
+
+            self.frame.to_excel(path, 'test1')
+            self.frame.to_excel(path, 'test1', cols=['A', 'B'])
+            self.frame.to_excel(path, 'test1', header=False)
+            self.frame.to_excel(path, 'test1', index=False)
+            
+            # Test writing to separate sheets
+            writer = ExcelWriter(path)
+            self.frame.to_excel(writer, 'test1')
+            self.tsframe.to_excel(writer, 'test2')
+            writer.save()
+            reader = ExcelFile(path)
+            recons = reader.parse('test1', index_col=0)
+            tm.assert_frame_equal(self.frame, recons)
+            recons = reader.parse('test2', index_col=0)
+            tm.assert_frame_equal(self.tsframe, recons)
+            np.testing.assert_equal(2, len(reader.sheet_names))
+            np.testing.assert_equal('test1', reader.sheet_names[0])
+            np.testing.assert_equal('test2', reader.sheet_names[1])
+            
 
     def test_excel_roundtrip_xls_colaliases(self):
         _skip_if_no_excelsuite()
@@ -443,24 +440,23 @@ class ExcelTests(unittest.TestCase):
     def _check_extension_colaliases(self, ext):
         path = '__tmp_to_excel_from_excel_aliases__.' + ext
 
-        self.frame['A'][:5] = nan
-
-        self.frame.to_excel(path, 'test1')
-        self.frame.to_excel(path, 'test1', cols=['A', 'B'])
-        self.frame.to_excel(path, 'test1', header=False)
-        self.frame.to_excel(path, 'test1', index=False)
-
-        # column aliases
-        col_aliases = Index(['AA', 'X', 'Y', 'Z'])
-        self.frame2.to_excel(path, 'test1', header=col_aliases)
-        reader = ExcelFile(path)
-        rs = reader.parse('test1', index_col=0)
-        xp = self.frame2.copy()
-        xp.columns = col_aliases
-        tm.assert_frame_equal(xp, rs)
-
-        os.remove(path)
+        with ensure_clean(path) as path:
+            self.frame['A'][:5] = nan
 
+            self.frame.to_excel(path, 'test1')
+            self.frame.to_excel(path, 'test1', cols=['A', 'B'])
+            self.frame.to_excel(path, 'test1', header=False)
+            self.frame.to_excel(path, 'test1', index=False)
+            
+            # column aliases
+            col_aliases = Index(['AA', 'X', 'Y', 'Z'])
+            self.frame2.to_excel(path, 'test1', header=col_aliases)
+            reader = ExcelFile(path)
+            rs = reader.parse('test1', index_col=0)
+            xp = self.frame2.copy()
+            xp.columns = col_aliases
+            tm.assert_frame_equal(xp, rs)
+            
     def test_excel_roundtrip_xls_indexlabels(self):
         _skip_if_no_excelsuite()
         self._check_extension_indexlabels('xls')
@@ -471,7 +467,9 @@ class ExcelTests(unittest.TestCase):
 
     def _check_extension_indexlabels(self, ext):
         path = '__tmp_to_excel_from_excel_indexlabels__.' + ext
-        try:
+
+        with ensure_clean(path) as path:
+
             self.frame['A'][:5] = nan
 
             self.frame.to_excel(path, 'test1')
@@ -501,12 +499,12 @@ class ExcelTests(unittest.TestCase):
             recons = reader.parse('test1', index_col=0).astype(np.int64)
             frame.index.names = ['test']
             self.assertEqual(frame.index.names, recons.index.names)
-        finally:
-            os.remove(path)
 
         # test index_labels in same row as column names
         path = '%s.xls' % tm.rands(10)
-        try:
+
+        with ensure_clean(path) as path:
+
             self.frame.to_excel(path, 'test1',
                                 cols=['A', 'B', 'C', 'D'], index=False)
             # take 'A' and 'B' as indexes (they are in same row as cols 'C',
@@ -517,8 +515,6 @@ class ExcelTests(unittest.TestCase):
             reader = ExcelFile(path)
             recons = reader.parse('test1', index_col=[0, 1])
             tm.assert_frame_equal(df, recons)
-        finally:
-            os.remove(path)
 
     def test_excel_roundtrip_indexname(self):
         _skip_if_no_xlrd()
@@ -529,31 +525,29 @@ class ExcelTests(unittest.TestCase):
         df = DataFrame(np.random.randn(10, 4))
         df.index.name = 'foo'
 
-        df.to_excel(path)
-
-        xf = ExcelFile(path)
-        result = xf.parse(xf.sheet_names[0], index_col=0)
+        with ensure_clean(path) as path:
+            df.to_excel(path)
 
-        tm.assert_frame_equal(result, df)
-        self.assertEqual(result.index.name, 'foo')
-
-        try:
-            os.remove(path)
-        except os.error:
-            pass
+            xf = ExcelFile(path)
+            result = xf.parse(xf.sheet_names[0], index_col=0)
+            
+            tm.assert_frame_equal(result, df)
+            self.assertEqual(result.index.name, 'foo')
 
     def test_excel_roundtrip_datetime(self):
         _skip_if_no_xlrd()
         _skip_if_no_xlwt()
+
         # datetime.date, not sure what to test here exactly
         path = '__tmp_excel_roundtrip_datetime__.xls'
         tsf = self.tsframe.copy()
-        tsf.index = [x.date() for x in self.tsframe.index]
-        tsf.to_excel(path, 'test1')
-        reader = ExcelFile(path)
-        recons = reader.parse('test1')
-        tm.assert_frame_equal(self.tsframe, recons)
-        os.remove(path)
+        with ensure_clean(path) as path:
+
+            tsf.index = [x.date() for x in self.tsframe.index]
+            tsf.to_excel(path, 'test1')
+            reader = ExcelFile(path)
+            recons = reader.parse('test1')
+            tm.assert_frame_equal(self.tsframe, recons)
 
     def test_excel_roundtrip_bool(self):
         _skip_if_no_openpyxl()
@@ -561,24 +555,27 @@ class ExcelTests(unittest.TestCase):
         # Test roundtrip np.bool8, does not seem to work for xls
         path = '__tmp_excel_roundtrip_bool__.xlsx'
         frame = (DataFrame(np.random.randn(10, 2)) >= 0)
-        frame.to_excel(path, 'test1')
-        reader = ExcelFile(path)
-        recons = reader.parse('test1')
-        tm.assert_frame_equal(frame, recons)
-        os.remove(path)
+        with ensure_clean(path) as path:
+
+            frame.to_excel(path, 'test1')
+            reader = ExcelFile(path)
+            recons = reader.parse('test1')
+            tm.assert_frame_equal(frame, recons)
 
     def test_to_excel_periodindex(self):
         _skip_if_no_excelsuite()
+
         for ext in ['xls', 'xlsx']:
             path = '__tmp_to_excel_periodindex__.' + ext
             frame = self.tsframe
             xp = frame.resample('M', kind='period')
-            xp.to_excel(path, 'sht1')
 
-            reader = ExcelFile(path)
-            rs = reader.parse('sht1', index_col=0, parse_dates=True)
-            tm.assert_frame_equal(xp, rs.to_period('M'))
-            os.remove(path)
+            with ensure_clean(path) as path:
+                xp.to_excel(path, 'sht1')
+
+                reader = ExcelFile(path)
+                rs = reader.parse('sht1', index_col=0, parse_dates=True)
+                tm.assert_frame_equal(xp, rs.to_period('M'))
 
     def test_to_excel_multiindex(self):
         _skip_if_no_xlrd()
@@ -599,18 +596,18 @@ class ExcelTests(unittest.TestCase):
         new_index = MultiIndex.from_arrays(arrays,
                                            names=['first', 'second'])
         frame.index = new_index
-        frame.to_excel(path, 'test1', header=False)
-        frame.to_excel(path, 'test1', cols=['A', 'B'])
 
-        # round trip
-        frame.to_excel(path, 'test1')
-        reader = ExcelFile(path)
-        df = reader.parse('test1', index_col=[0, 1], parse_dates=False)
-        tm.assert_frame_equal(frame, df)
-        self.assertEqual(frame.index.names, df.index.names)
-        self.frame.index = old_index  # needed if setUP becomes a classmethod
+        with ensure_clean(path) as path:
+            frame.to_excel(path, 'test1', header=False)
+            frame.to_excel(path, 'test1', cols=['A', 'B'])
 
-        os.remove(path)
+            # round trip
+            frame.to_excel(path, 'test1')
+            reader = ExcelFile(path)
+            df = reader.parse('test1', index_col=[0, 1], parse_dates=False)
+            tm.assert_frame_equal(frame, df)
+            self.assertEqual(frame.index.names, df.index.names)
+            self.frame.index = old_index  # needed if setUP becomes a classmethod
 
     def test_to_excel_multiindex_dates(self):
         _skip_if_no_xlrd()
@@ -630,22 +627,21 @@ class ExcelTests(unittest.TestCase):
         new_index = [old_index, np.arange(len(old_index))]
         tsframe.index = MultiIndex.from_arrays(new_index)
 
-        tsframe.to_excel(path, 'test1', index_label=['time', 'foo'])
-        reader = ExcelFile(path)
-        recons = reader.parse('test1', index_col=[0, 1])
-
-        tm.assert_frame_equal(tsframe, recons, check_names=False)
-        self.assertEquals(recons.index.names, ['time', 'foo'])
-
-        # infer index
-        tsframe.to_excel(path, 'test1')
-        reader = ExcelFile(path)
-        recons = reader.parse('test1')
-        tm.assert_frame_equal(tsframe, recons)
+        with ensure_clean(path) as path:
+            tsframe.to_excel(path, 'test1', index_label=['time', 'foo'])
+            reader = ExcelFile(path)
+            recons = reader.parse('test1', index_col=[0, 1])
+            
+            tm.assert_frame_equal(tsframe, recons, check_names=False)
+            self.assertEquals(recons.index.names, ['time', 'foo'])
 
-        self.tsframe.index = old_index  # needed if setUP becomes classmethod
+            # infer index
+            tsframe.to_excel(path, 'test1')
+            reader = ExcelFile(path)
+            recons = reader.parse('test1')
+            tm.assert_frame_equal(tsframe, recons)
 
-        os.remove(path)
+            self.tsframe.index = old_index  # needed if setUP becomes classmethod
 
     def test_to_excel_float_format(self):
         _skip_if_no_excelsuite()
@@ -654,15 +650,16 @@ class ExcelTests(unittest.TestCase):
             df = DataFrame([[0.123456, 0.234567, 0.567567],
                             [12.32112, 123123.2, 321321.2]],
                            index=['A', 'B'], columns=['X', 'Y', 'Z'])
-            df.to_excel(filename, 'test1', float_format='%.2f')
 
-            reader = ExcelFile(filename)
-            rs = reader.parse('test1', index_col=None)
-            xp = DataFrame([[0.12, 0.23, 0.57],
-                            [12.32, 123123.20, 321321.20]],
-                           index=['A', 'B'], columns=['X', 'Y', 'Z'])
-            tm.assert_frame_equal(rs, xp)
-            os.remove(filename)
+            with ensure_clean(filename) as filename:
+                df.to_excel(filename, 'test1', float_format='%.2f')
+
+                reader = ExcelFile(filename)
+                rs = reader.parse('test1', index_col=None)
+                xp = DataFrame([[0.12, 0.23, 0.57],
+                                [12.32, 123123.20, 321321.20]],
+                               index=['A', 'B'], columns=['X', 'Y', 'Z'])
+                tm.assert_frame_equal(rs, xp)
 
     def test_to_excel_unicode_filename(self):
         _skip_if_no_excelsuite()
@@ -680,15 +677,16 @@ class ExcelTests(unittest.TestCase):
             df = DataFrame([[0.123456, 0.234567, 0.567567],
                             [12.32112, 123123.2, 321321.2]],
                            index=['A', 'B'], columns=['X', 'Y', 'Z'])
-            df.to_excel(filename, 'test1', float_format='%.2f')
 
-            reader = ExcelFile(filename)
-            rs = reader.parse('test1', index_col=None)
-            xp = DataFrame([[0.12, 0.23, 0.57],
-                            [12.32, 123123.20, 321321.20]],
-                           index=['A', 'B'], columns=['X', 'Y', 'Z'])
-            tm.assert_frame_equal(rs, xp)
-            os.remove(filename)
+            with ensure_clean(filename) as filename:
+                df.to_excel(filename, 'test1', float_format='%.2f')
+
+                reader = ExcelFile(filename)
+                rs = reader.parse('test1', index_col=None)
+                xp = DataFrame([[0.12, 0.23, 0.57],
+                                [12.32, 123123.20, 321321.20]],
+                               index=['A', 'B'], columns=['X', 'Y', 'Z'])
+                tm.assert_frame_equal(rs, xp)
 
     def test_to_excel_styleconverter(self):
         from pandas.io.parsers import CellStyleConverter
@@ -840,12 +838,11 @@ class ExcelTests(unittest.TestCase):
         def roundtrip(df, header=True, parser_hdr=0):
             path = '__tmp__test_xl_010_%s__.xls' % np.random.randint(1, 10000)
             df.to_excel(path, header=header)
-            xf = pd.ExcelFile(path)
-            try:
+
+            with ensure_clean(path) as path:
+                xf = pd.ExcelFile(path)
                 res = xf.parse(xf.sheet_names[0], header=parser_hdr)
                 return res
-            finally:
-                os.remove(path)
 
         nrows = 5
         ncols = 3
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index facc5325a..9326ae00f 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -19,7 +19,9 @@ import pandas.io.parsers as parsers
 from pandas.io.parsers import (read_csv, read_table, read_fwf,
                                TextFileReader, TextParser)
 from pandas.util.testing import (assert_almost_equal,
-                                 assert_series_equal, network)
+                                 assert_series_equal, 
+                                 network,
+                                 ensure_clean)
 import pandas.util.testing as tm
 import pandas as pd
 
@@ -1372,29 +1374,25 @@ A,B,C
 
         path = '__%s__.csv' % tm.rands(10)
 
-        for sep, dat in [('\t', data), (',', data2)]:
-            for enc in ['utf-16', 'utf-16le', 'utf-16be']:
-                bytes = dat.encode(enc)
-                with open(path, 'wb') as f:
-                    f.write(bytes)
-
-                s = BytesIO(dat.encode('utf-8'))
-                if py3compat.PY3:
-                    # somewhat False since the code never sees bytes
-                    from io import TextIOWrapper
-                    s = TextIOWrapper(s, encoding='utf-8')
-
-                result = self.read_csv(path, encoding=enc, skiprows=2,
-                                       sep=sep)
-                expected = self.read_csv(s, encoding='utf-8', skiprows=2,
-                                         sep=sep)
-
-                tm.assert_frame_equal(result, expected)
-
-        try:
-            os.remove(path)
-        except os.error:
-            pass
+        with ensure_clean(path) as path:
+            for sep, dat in [('\t', data), (',', data2)]:
+                for enc in ['utf-16', 'utf-16le', 'utf-16be']:
+                    bytes = dat.encode(enc)
+                    with open(path, 'wb') as f:
+                        f.write(bytes)
+                        
+                    s = BytesIO(dat.encode('utf-8'))
+                    if py3compat.PY3:
+                        # somewhat False since the code never sees bytes
+                        from io import TextIOWrapper
+                        s = TextIOWrapper(s, encoding='utf-8')
+
+                    result = self.read_csv(path, encoding=enc, skiprows=2,
+                                           sep=sep)
+                    expected = self.read_csv(s, encoding='utf-8', skiprows=2,
+                                             sep=sep)
+
+                    tm.assert_frame_equal(result, expected)
 
     def test_utf16_example(self):
         path = os.path.join(self.dirpath, 'utf16_ex.txt')
@@ -1722,32 +1720,27 @@ eight,1,2,3"""
         if PY3:
             raise nose.SkipTest
 
-        with open('__foo__.txt', 'wb') as f:
-            f.write('AAA\nBBB\nCCC\nDDD\nEEE\nFFF\nGGG')
+        with ensure_clean() as path:
+            with open(path, 'wb') as f:
+                f.write('AAA\nBBB\nCCC\nDDD\nEEE\nFFF\nGGG')
 
-        with open('__foo__.txt', 'rb') as f:
-            for line in f:
-                if 'CCC' in line:
-                    break
+            with open(path, 'rb') as f:
+                for line in f:
+                    if 'CCC' in line:
+                        break
 
-            try:
-                read_table(f, squeeze=True, header=None, engine='c')
-            except Exception:
-                pass
-            else:
-                raise ValueError('this should not happen')
-
-            result = read_table(f, squeeze=True, header=None,
-                                engine='python')
+                try:
+                    read_table(f, squeeze=True, header=None, engine='c')
+                except Exception:
+                    pass
+                else:
+                    raise ValueError('this should not happen')
 
-            expected = Series(['DDD', 'EEE', 'FFF', 'GGG'])
-            tm.assert_series_equal(result, expected)
-
-        try:
-            os.remove('__foo__.txt')
-        except os.error:
-            pass
+                result = read_table(f, squeeze=True, header=None,
+                                    engine='python')
 
+                expected = Series(['DDD', 'EEE', 'FFF', 'GGG'])
+                tm.assert_series_equal(result, expected)
 
 class TestCParserHighMemory(ParserTests, unittest.TestCase):
 
@@ -1924,41 +1917,30 @@ a,b,c
         data = open(self.csv1, 'rb').read()
         expected = self.read_csv(self.csv1)
 
-        try:
-            tmp = gzip.GzipFile('__tmp__', mode='wb')
+        with ensure_clean() as path:
+            tmp = gzip.GzipFile(path, mode='wb')
             tmp.write(data)
             tmp.close()
 
-            result = self.read_csv('__tmp__', compression='gzip')
+            result = self.read_csv(path, compression='gzip')
             tm.assert_frame_equal(result, expected)
 
-            result = self.read_csv(open('__tmp__', 'rb'), compression='gzip')
+            result = self.read_csv(open(path, 'rb'), compression='gzip')
             tm.assert_frame_equal(result, expected)
-        finally:
-            # try:
-            #     os.remove('__tmp__')
-            # except:
-            #     pass
-            pass
 
-        try:
-            tmp = bz2.BZ2File('__tmp__', mode='wb')
+        with ensure_clean() as path:
+            tmp = bz2.BZ2File(path, mode='wb')
             tmp.write(data)
             tmp.close()
 
-            result = self.read_csv('__tmp__', compression='bz2')
+            result = self.read_csv(path, compression='bz2')
             tm.assert_frame_equal(result, expected)
 
-            # result = self.read_csv(open('__tmp__', 'rb'), compression='bz2')
+            # result = self.read_csv(open(path, 'rb'), compression='bz2')
             # tm.assert_frame_equal(result, expected)
 
             self.assertRaises(ValueError, self.read_csv,
-                              '__tmp__', compression='bz3')
-        finally:
-            try:
-                os.remove('__tmp__')
-            except:
-                pass
+                              path, compression='bz3')
 
     def test_decompression_regex_sep(self):
         try:
@@ -1971,35 +1953,24 @@ a,b,c
         data = data.replace(b',', b'::')
         expected = self.read_csv(self.csv1)
 
-        try:
-            tmp = gzip.GzipFile('__tmp__', mode='wb')
+        with ensure_clean() as path:
+            tmp = gzip.GzipFile(path, mode='wb')
             tmp.write(data)
             tmp.close()
 
-            result = self.read_csv('__tmp__', sep='::', compression='gzip')
+            result = self.read_csv(path, sep='::', compression='gzip')
             tm.assert_frame_equal(result, expected)
-        finally:
-            # try:
-            #     os.remove('__tmp__')
-            # except:
-            #     pass
-            pass
 
-        try:
-            tmp = bz2.BZ2File('__tmp__', mode='wb')
+        with ensure_clean() as path:
+            tmp = bz2.BZ2File(path, mode='wb')
             tmp.write(data)
             tmp.close()
 
-            result = self.read_csv('__tmp__', sep='::', compression='bz2')
+            result = self.read_csv(path, sep='::', compression='bz2')
             tm.assert_frame_equal(result, expected)
 
             self.assertRaises(ValueError, self.read_csv,
-                              '__tmp__', compression='bz3')
-        finally:
-            try:
-                os.remove('__tmp__')
-            except:
-                pass
+                              path, compression='bz3')
 
     def test_memory_map(self):
         # it works!
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 626592958..0866e154f 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -26,7 +26,8 @@ from pandas.io.parsers import read_csv
 
 from pandas.util.testing import (assert_almost_equal,
                                  assert_series_equal,
-                                 assert_frame_equal)
+                                 assert_frame_equal,
+                                 ensure_clean)
 from pandas.util import py3compat
 from pandas.util.compat import OrderedDict
 
@@ -4405,66 +4406,67 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         self.assertRaises(TypeError, df.__eq__, None)
 
     def test_to_csv_from_csv(self):
-        path = '__tmp_to_csv_from_csv__'
 
-        self.frame['A'][:5] = nan
+        pname = '__tmp_to_csv_from_csv__'
+        with ensure_clean(pname) as path:
 
-        self.frame.to_csv(path)
-        self.frame.to_csv(path, cols=['A', 'B'])
-        self.frame.to_csv(path, header=False)
-        self.frame.to_csv(path, index=False)
+             self.frame['A'][:5] = nan
 
-        # test roundtrip
+             self.frame.to_csv(path)
+             self.frame.to_csv(path, cols=['A', 'B'])
+             self.frame.to_csv(path, header=False)
+             self.frame.to_csv(path, index=False)
 
-        self.tsframe.to_csv(path)
-        recons = DataFrame.from_csv(path)
+             # test roundtrip
+             self.tsframe.to_csv(path)
+             recons = DataFrame.from_csv(path)
 
-        assert_frame_equal(self.tsframe, recons)
+             assert_frame_equal(self.tsframe, recons)
 
-        self.tsframe.to_csv(path, index_label='index')
-        recons = DataFrame.from_csv(path, index_col=None)
-        assert(len(recons.columns) == len(self.tsframe.columns) + 1)
+             self.tsframe.to_csv(path, index_label='index')
+             recons = DataFrame.from_csv(path, index_col=None)
+             assert(len(recons.columns) == len(self.tsframe.columns) + 1)
 
-        # no index
-        self.tsframe.to_csv(path, index=False)
-        recons = DataFrame.from_csv(path, index_col=None)
-        assert_almost_equal(self.tsframe.values, recons.values)
+             # no index
+             self.tsframe.to_csv(path, index=False)
+             recons = DataFrame.from_csv(path, index_col=None)
+             assert_almost_equal(self.tsframe.values, recons.values)
 
-        # corner case
-        dm = DataFrame({'s1': Series(range(3), range(3)),
-                        's2': Series(range(2), range(2))})
-        dm.to_csv(path)
-        recons = DataFrame.from_csv(path)
-        assert_frame_equal(dm, recons)
-
-        # duplicate index
-        df = DataFrame(np.random.randn(3, 3), index=['a', 'a', 'b'],
-                       columns=['x', 'y', 'z'])
-        df.to_csv(path)
-        result = DataFrame.from_csv(path)
-        assert_frame_equal(result, df)
+             # corner case
+             dm = DataFrame({'s1': Series(range(3), range(3)),
+                             's2': Series(range(2), range(2))})
+             dm.to_csv(path)
+             recons = DataFrame.from_csv(path)
+             assert_frame_equal(dm, recons)
 
-        midx = MultiIndex.from_tuples([('A', 1, 2), ('A', 1, 2), ('B', 1, 2)])
-        df = DataFrame(np.random.randn(3, 3), index=midx,
-                       columns=['x', 'y', 'z'])
-        df.to_csv(path)
-        result = DataFrame.from_csv(path, index_col=[0, 1, 2],
-                                    parse_dates=False)
-        assert_frame_equal(result, df, check_names=False)  # TODO from_csv names index ['Unnamed: 1', 'Unnamed: 2'] should it ?
-
-        # column aliases
-        col_aliases = Index(['AA', 'X', 'Y', 'Z'])
-        self.frame2.to_csv(path, header=col_aliases)
-        rs = DataFrame.from_csv(path)
-        xp = self.frame2.copy()
-        xp.columns = col_aliases
+        with ensure_clean(pname) as path:
 
-        assert_frame_equal(xp, rs)
+             # duplicate index
+             df = DataFrame(np.random.randn(3, 3), index=['a', 'a', 'b'],
+                            columns=['x', 'y', 'z'])
+             df.to_csv(path)
+             result = DataFrame.from_csv(path)
+             assert_frame_equal(result, df)
+
+             midx = MultiIndex.from_tuples([('A', 1, 2), ('A', 1, 2), ('B', 1, 2)])
+             df = DataFrame(np.random.randn(3, 3), index=midx,
+                            columns=['x', 'y', 'z'])
+             df.to_csv(path)
+             result = DataFrame.from_csv(path, index_col=[0, 1, 2],
+                                         parse_dates=False)
+             assert_frame_equal(result, df, check_names=False)  # TODO from_csv names index ['Unnamed: 1', 'Unnamed: 2'] should it ?
 
-        self.assertRaises(ValueError, self.frame2.to_csv, path,
-                          header=['AA', 'X'])
+             # column aliases
+             col_aliases = Index(['AA', 'X', 'Y', 'Z'])
+             self.frame2.to_csv(path, header=col_aliases)
+             rs = DataFrame.from_csv(path)
+             xp = self.frame2.copy()
+             xp.columns = col_aliases
 
-        os.remove(path)
+             assert_frame_equal(xp, rs)
+
+             self.assertRaises(ValueError, self.frame2.to_csv, path,
+                               header=['AA', 'X'])
 
     @slow
     def test_to_csv_moar(self):
@@ -4472,14 +4474,10 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         path = '__tmp_to_csv_moar__'
         def _do_test(df,path,r_dtype=None,c_dtype=None,rnlvl=None,cnlvl=None,
                      dupe_col=False):
-               try:
+
+               with ensure_clean(path) as path:
                     df.to_csv(path,encoding='utf8')
                     recons = DataFrame.from_csv(path)
-               finally:
-                   try:
-                       os.remove(path)
-                   except:
-                       pass
 
                def _to_uni(x):
                    if not isinstance(x,unicode):
@@ -4584,119 +4582,107 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
 
 
     def test_to_csv_from_csv_w_some_infs(self):
-        path = '__%s__' % tm.rands(10)
 
         # test roundtrip with inf, -inf, nan, as full columns and mix
         self.frame['G'] = np.nan
         f = lambda x: [np.inf, np.nan][np.random.rand() < .5]
         self.frame['H'] = self.frame.index.map(f)
 
-        self.frame.to_csv(path)
-        recons = DataFrame.from_csv(path)
-
-        assert_frame_equal(self.frame, recons, check_names=False)  # TODO to_csv drops column name
-        assert_frame_equal(np.isinf(self.frame), np.isinf(recons), check_names=False)
+        with ensure_clean() as path:
+             self.frame.to_csv(path)
+             recons = DataFrame.from_csv(path)
 
-        try:
-            os.remove(path)
-        except os.error:
-            pass
+             assert_frame_equal(self.frame, recons, check_names=False)  # TODO to_csv drops column name
+             assert_frame_equal(np.isinf(self.frame), np.isinf(recons), check_names=False)
 
     def test_to_csv_from_csv_w_all_infs(self):
-        import tempfile
-        path = tempfile.mktemp()
-        path += '__tmp__'
 
         # test roundtrip with inf, -inf, nan, as full columns and mix
         self.frame['E'] = np.inf
         self.frame['F'] = -np.inf
 
-        self.frame.to_csv(path)
-        recons = DataFrame.from_csv(path)
+        with ensure_clean() as path:
+            self.frame.to_csv(path)
+            recons = DataFrame.from_csv(path)
 
-        assert_frame_equal(self.frame, recons, check_names=False)  # TODO to_csv drops column name
-        assert_frame_equal(np.isinf(self.frame), np.isinf(recons), check_names=False)
-
-        os.remove(path)
+            assert_frame_equal(self.frame, recons, check_names=False)  # TODO to_csv drops column name
+            assert_frame_equal(np.isinf(self.frame), np.isinf(recons), check_names=False)
 
     def test_to_csv_multiindex(self):
-        path = '__tmp_to_csv_multiindex__'
 
+        pname = '__tmp_to_csv_multiindex__'
         frame = self.frame
         old_index = frame.index
         arrays = np.arange(len(old_index) * 2).reshape(2, -1)
         new_index = MultiIndex.from_arrays(arrays, names=['first', 'second'])
         frame.index = new_index
-        frame.to_csv(path, header=False)
-        frame.to_csv(path, cols=['A', 'B'])
-
-        # round trip
-        frame.to_csv(path)
-        df = DataFrame.from_csv(path, index_col=[0, 1], parse_dates=False)
-
-        assert_frame_equal(frame, df, check_names=False)  # TODO to_csv drops column name
-        self.assertEqual(frame.index.names, df.index.names)
-        self.frame.index = old_index  # needed if setUP becomes a classmethod
-
-        # try multiindex with dates
-        tsframe = self.tsframe
-        old_index = tsframe.index
-        new_index = [old_index, np.arange(len(old_index))]
-        tsframe.index = MultiIndex.from_arrays(new_index)
-
-        tsframe.to_csv(path, index_label=['time', 'foo'])
-        recons = DataFrame.from_csv(path, index_col=[0, 1])
-        assert_frame_equal(tsframe, recons, check_names=False)  # TODO to_csv drops column name
 
-        # do not load index
-        tsframe.to_csv(path)
-        recons = DataFrame.from_csv(path, index_col=None)
-        np.testing.assert_equal(len(recons.columns), len(tsframe.columns) + 2)
-
-        # no index
-        tsframe.to_csv(path, index=False)
-        recons = DataFrame.from_csv(path, index_col=None)
-        assert_almost_equal(recons.values, self.tsframe.values)
-        self.tsframe.index = old_index  # needed if setUP becomes classmethod
-
-        os.remove(path)
-
-        # empty
-        tsframe[:0].to_csv(path)
-        recons = DataFrame.from_csv(path)
-        exp = tsframe[:0]
-        exp.index = []
-
-        self.assert_(recons.columns.equals(exp.columns))
-        self.assert_(len(recons) == 0)
-
-        os.remove(path)
+        with ensure_clean(pname) as path:
+             frame.to_csv(path, header=False)
+             frame.to_csv(path, cols=['A', 'B'])
+
+             # round trip
+             frame.to_csv(path)
+             df = DataFrame.from_csv(path, index_col=[0, 1], parse_dates=False)
+
+             assert_frame_equal(frame, df, check_names=False)  # TODO to_csv drops column name
+             self.assertEqual(frame.index.names, df.index.names)
+             self.frame.index = old_index  # needed if setUP becomes a classmethod
+
+              # try multiindex with dates
+             tsframe = self.tsframe
+             old_index = tsframe.index
+             new_index = [old_index, np.arange(len(old_index))]
+             tsframe.index = MultiIndex.from_arrays(new_index)
+
+             tsframe.to_csv(path, index_label=['time', 'foo'])
+             recons = DataFrame.from_csv(path, index_col=[0, 1])
+             assert_frame_equal(tsframe, recons, check_names=False)  # TODO to_csv drops column name
+
+             # do not load index
+             tsframe.to_csv(path)
+             recons = DataFrame.from_csv(path, index_col=None)
+             np.testing.assert_equal(len(recons.columns), len(tsframe.columns) + 2)
+
+             # no index
+             tsframe.to_csv(path, index=False)
+             recons = DataFrame.from_csv(path, index_col=None)
+             assert_almost_equal(recons.values, self.tsframe.values)
+             self.tsframe.index = old_index  # needed if setUP becomes classmethod
+
+        with ensure_clean(pname) as path:
+            # empty
+            tsframe[:0].to_csv(path)
+            recons = DataFrame.from_csv(path)
+            exp = tsframe[:0]
+            exp.index = []
+
+            self.assert_(recons.columns.equals(exp.columns))
+            self.assert_(len(recons) == 0)
 
     def test_to_csv_float32_nanrep(self):
         df = DataFrame(np.random.randn(1, 4).astype(np.float32))
         df[1] = np.nan
 
-        pth = '__tmp_to_csv_float32_nanrep__.csv'
-        df.to_csv(pth, na_rep=999)
+        with ensure_clean('__tmp_to_csv_float32_nanrep__.csv') as path:
+            df.to_csv(path, na_rep=999)
 
-        lines = open(pth).readlines()
-        self.assert_(lines[1].split(',')[2] == '999')
-        os.remove(pth)
+            with open(path) as f:
+                 lines = f.readlines()
+                 self.assert_(lines[1].split(',')[2] == '999')
 
     def test_to_csv_withcommas(self):
 
-        path = '__tmp_to_csv_withcommas__'
         # Commas inside fields should be correctly escaped when saving as CSV.
-
         df = DataFrame({'A': [1, 2, 3], 'B': ['5,6', '7,8', '9,0']})
-        df.to_csv(path)
-        df2 = DataFrame.from_csv(path)
-        assert_frame_equal(df2, df)
 
-        os.remove(path)
+        with ensure_clean('__tmp_to_csv_withcommas__.csv') as path:
+            df.to_csv(path)
+            df2 = DataFrame.from_csv(path)
+            assert_frame_equal(df2, df)
 
     def test_to_csv_mixed(self):
-        filename = '__tmp_to_csv_mixed__.csv'
+
         def create_cols(name):
             return [ "%s%03d" % (name,i) for i in xrange(5) ]
 
@@ -4720,17 +4706,17 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
             for c in create_cols(n):
                 dtypes[c] = dtype
 
-        df.to_csv(filename)
-
-        rs = pan.read_csv(filename, index_col=0, dtype=dtypes, parse_dates=create_cols('date'))
-        assert_frame_equal(rs, df)
-        os.remove(filename)
+        with ensure_clean() as filename:
+            df.to_csv(filename)
+            rs = pan.read_csv(filename, index_col=0, dtype=dtypes, parse_dates=create_cols('date'))
+            assert_frame_equal(rs, df)
 
     def test_to_csv_dups_cols(self):
-        filename = '__tmp_to_csv_dup_cols__.csv'
 
         df        = DataFrame(np.random.randn(1000, 30),columns=range(15)+range(15),dtype='float64')
-        df.to_csv(filename) # single dtype, fine
+
+        with ensure_clean() as filename:
+            df.to_csv(filename) # single dtype, fine
 
         df_float  = DataFrame(np.random.randn(1000, 30),dtype='float64')
         df_int    = DataFrame(np.random.randn(1000, 30),dtype='int64')
@@ -4740,48 +4726,45 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         df        = pan.concat([ df_float, df_int, df_bool, df_object, df_dt ], axis=1)
 
         #### this raises because we have duplicate column names across dtypes ####
-        self.assertRaises(Exception, df.to_csv, filename)
+        with ensure_clean() as filename:
+            self.assertRaises(Exception, df.to_csv, filename)
 
     def test_to_csv_chunking(self):
-        filename = '__tmp_to_csv_chunking__.csv'
 
         aa=DataFrame({'A':range(100000)})
-
         aa['B'] = aa.A + 1.0
         aa['C'] = aa.A + 2.0
         aa['D'] = aa.A + 3.0
 
         for chunksize in [10000,50000,100000]:
-            aa.to_csv(filename,chunksize=chunksize)
-            rs = pan.read_csv(filename,index_col=0)
-            assert_frame_equal(rs, aa)
-
-        os.remove(filename)
+            with ensure_clean() as filename:
+                aa.to_csv(filename,chunksize=chunksize)
+                rs = pan.read_csv(filename,index_col=0)
+                assert_frame_equal(rs, aa)
 
     def test_to_csv_bug(self):
-        path = '__tmp_to_csv_bug__.csv'
         f1 = StringIO('a,1.0\nb,2.0')
         df = DataFrame.from_csv(f1, header=None)
         newdf = DataFrame({'t': df[df.columns[0]]})
-        newdf.to_csv(path)
 
-        recons = pan.read_csv(path, index_col=0)
-        assert_frame_equal(recons, newdf, check_names=False)  # don't check_names as t != 1
+        with ensure_clean() as path:
+            newdf.to_csv(path)
 
-        os.remove(path)
+            recons = pan.read_csv(path, index_col=0)
+            assert_frame_equal(recons, newdf, check_names=False)  # don't check_names as t != 1
 
     def test_to_csv_unicode(self):
-        path = '__tmp_to_csv_unicode__.csv'
-        df = DataFrame({u'c/\u03c3': [1, 2, 3]})
-        df.to_csv(path, encoding='UTF-8')
-        df2 = pan.read_csv(path, index_col=0, encoding='UTF-8')
-        assert_frame_equal(df, df2)
 
-        df.to_csv(path, encoding='UTF-8', index=False)
-        df2 = pan.read_csv(path, index_col=None, encoding='UTF-8')
-        assert_frame_equal(df, df2)
+        df = DataFrame({u'c/\u03c3': [1, 2, 3]})
+        with ensure_clean() as path:
+        
+            df.to_csv(path, encoding='UTF-8')
+            df2 = pan.read_csv(path, index_col=0, encoding='UTF-8')
+            assert_frame_equal(df, df2)
 
-        os.remove(path)
+            df.to_csv(path, encoding='UTF-8', index=False)
+            df2 = pan.read_csv(path, index_col=None, encoding='UTF-8')
+            assert_frame_equal(df, df2)
 
     def test_to_csv_unicode_index_col(self):
         buf = StringIO('')
@@ -4805,18 +4788,20 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         assert_frame_equal(recons, self.frame, check_names=False)  # TODO to_csv drops column name
 
     def test_to_csv_float_format(self):
-        filename = '__tmp_to_csv_float_format__.csv'
+
         df = DataFrame([[0.123456, 0.234567, 0.567567],
                         [12.32112, 123123.2, 321321.2]],
                        index=['A', 'B'], columns=['X', 'Y', 'Z'])
-        df.to_csv(filename, float_format='%.2f')
 
-        rs = pan.read_csv(filename, index_col=0)
-        xp = DataFrame([[0.12, 0.23, 0.57],
-                        [12.32, 123123.20, 321321.20]],
-                       index=['A', 'B'], columns=['X', 'Y', 'Z'])
-        assert_frame_equal(rs, xp)
-        os.remove(filename)
+        with ensure_clean() as filename:
+
+            df.to_csv(filename, float_format='%.2f')
+
+            rs = pan.read_csv(filename, index_col=0)
+            xp = DataFrame([[0.12, 0.23, 0.57],
+                            [12.32, 123123.20, 321321.20]],
+                           index=['A', 'B'], columns=['X', 'Y', 'Z'])
+            assert_frame_equal(rs, xp)
 
     def test_to_csv_quoting(self):
         import csv
diff --git a/pandas/tests/test_graphics.py b/pandas/tests/test_graphics.py
index 89cc407da..015a2ff93 100644
--- a/pandas/tests/test_graphics.py
+++ b/pandas/tests/test_graphics.py
@@ -7,6 +7,7 @@ from datetime import datetime, date
 
 from pandas import Series, DataFrame, MultiIndex, PeriodIndex, date_range
 import pandas.util.testing as tm
+from pandas.util.testing import ensure_clean
 
 import numpy as np
 
@@ -692,9 +693,6 @@ class TestDataFrameGroupByPlots(unittest.TestCase):
         for ax in axes.ravel():
             self.assert_(len(ax.patches) > 0)
 
-PNG_PATH = 'tmp.png'
-
-
 def _check_plot_works(f, *args, **kwargs):
     import matplotlib.pyplot as plt
 
@@ -711,9 +709,9 @@ def _check_plot_works(f, *args, **kwargs):
         assert(ret is not None)  # do something more intelligent
     except Exception:
         pass
-    plt.savefig(PNG_PATH)
-    os.remove(PNG_PATH)
 
+    with ensure_clean() as path:
+        plt.savefig(path)
 
 def curpath():
     pth, _ = os.path.split(os.path.abspath(__file__))
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index d857e999b..84f5f3afa 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -18,7 +18,8 @@ from pandas.util import py3compat
 from pandas.util.testing import (assert_panel_equal,
                                  assert_frame_equal,
                                  assert_series_equal,
-                                 assert_almost_equal)
+                                 assert_almost_equal,
+                                 ensure_clean)
 import pandas.core.panel as panelm
 import pandas.util.testing as tm
 
@@ -1317,12 +1318,12 @@ class TestPanel(unittest.TestCase, PanelTests, CheckIndexing,
 
         for ext in ['xls', 'xlsx']:
             path = '__tmp__.' + ext
-            self.panel.to_excel(path)
-            reader = ExcelFile(path)
-            for item, df in self.panel.iterkv():
-                recdf = reader.parse(str(item), index_col=0)
-                assert_frame_equal(df, recdf)
-            os.remove(path)
+            with ensure_clean(path) as path:
+                self.panel.to_excel(path)
+                reader = ExcelFile(path)
+                for item, df in self.panel.iterkv():
+                    recdf = reader.parse(str(item), index_col=0)
+                    assert_frame_equal(df, recdf)
 
     def test_dropna(self):
         p = Panel(np.random.randn(4, 5, 6), major_axis=list('abcde'))
diff --git a/pandas/tests/test_panel4d.py b/pandas/tests/test_panel4d.py
index 5bb452deb..5981640b4 100644
--- a/pandas/tests/test_panel4d.py
+++ b/pandas/tests/test_panel4d.py
@@ -1043,30 +1043,9 @@ class TestPanel4d(unittest.TestCase, CheckIndexing, SafeForSparse,
 
     def test_from_frame_level1_unsorted(self):
         raise nose.SkipTest
-    #    tuples = [('MSFT', 3), ('MSFT', 2), ('AAPL', 2),
-    #              ('AAPL', 1), ('MSFT', 1)]
-    #    midx = MultiIndex.from_tuples(tuples)
-    #    df = DataFrame(np.random.rand(5,4), index=midx)
-    #    p = df.to_panel()
-    #    assert_frame_equal(p.minor_xs(2), df.ix[:,2].sort_index())
 
     def test_to_excel(self):
         raise nose.SkipTest
-    #    try:
-    #        import xlwt
-    #        import xlrd
-    #        import openpyxl
-    #    except ImportError:
-    #        raise nose.SkipTest
-
-    #    for ext in ['xls', 'xlsx']:
-    #        path = '__tmp__.' + ext
-    #        self.panel.to_excel(path)
-    #        reader = ExcelFile(path)
-    #        for item, df in self.panel.iteritems():
-    #            recdf = reader.parse(str(item),index_col=0)
-    #            assert_frame_equal(df, recdf)
-    #        os.remove(path)
 
 
 if __name__ == '__main__':
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 74b41f4ef..20c57ebbd 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -24,7 +24,9 @@ import pandas.core.nanops as nanops
 
 from pandas.util.py3compat import StringIO
 from pandas.util import py3compat
-from pandas.util.testing import assert_series_equal, assert_almost_equal
+from pandas.util.testing import (assert_series_equal, 
+                                 assert_almost_equal, 
+                                 ensure_clean)
 import pandas.util.testing as tm
 
 
@@ -178,10 +180,11 @@ class CheckNameIntegration(object):
         self.assertEquals(unpickled.name, self.ts.name)
 
     def _pickle_roundtrip_name(self, obj):
-        obj.save('__tmp_name__')
-        unpickled = Series.load('__tmp_name__')
-        os.remove('__tmp_name__')
-        return unpickled
+
+        with ensure_clean() as path:
+            obj.save(path)
+            unpickled = Series.load(path)
+            return unpickled
 
     def test_argsort_preserve_name(self):
         result = self.ts.argsort()
@@ -610,10 +613,11 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         assert_series_equal(unp_ts, self.ts)
 
     def _pickle_roundtrip(self, obj):
-        obj.save('__tmp_pickle_roundtrip__')
-        unpickled = Series.load('__tmp_pickle_roundtrip__')
-        os.remove('__tmp_pickle_roundtrip__')
-        return unpickled
+
+        with ensure_clean() as path:
+            obj.save(path)
+            unpickled = Series.load(path)
+            return unpickled
 
     def test_getitem_get(self):
         idx1 = self.series.index[5]
@@ -2557,43 +2561,42 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         assert_series_equal(iranks, exp)
 
     def test_from_csv(self):
-        path = '_foo_from_csv'
-        self.ts.to_csv(path)
-        ts = Series.from_csv(path)
-        assert_series_equal(self.ts, ts)
-        self.assertTrue(ts.index.name is None)
-
-        self.series.to_csv(path)
-        series = Series.from_csv(path)
-        self.assert_(series.name is None)
-        self.assert_(series.index.name is None)
-        assert_series_equal(self.series, series)
-
-        outfile = open(path, 'w')
-        outfile.write('1998-01-01|1.0\n1999-01-01|2.0')
-        outfile.close()
-        series = Series.from_csv(path, sep='|')
-        checkseries = Series(
-            {datetime(1998, 1, 1): 1.0, datetime(1999, 1, 1): 2.0})
-        assert_series_equal(checkseries, series)
-
-        series = Series.from_csv(path, sep='|', parse_dates=False)
-        checkseries = Series({'1998-01-01': 1.0, '1999-01-01': 2.0})
-        assert_series_equal(checkseries, series)
-
-        os.remove(path)
+
+        with ensure_clean() as path:
+            self.ts.to_csv(path)
+            ts = Series.from_csv(path)
+            assert_series_equal(self.ts, ts)
+            self.assertTrue(ts.index.name is None)
+            
+            self.series.to_csv(path)
+            series = Series.from_csv(path)
+            self.assert_(series.name is None)
+            self.assert_(series.index.name is None)
+            assert_series_equal(self.series, series)
+
+            outfile = open(path, 'w')
+            outfile.write('1998-01-01|1.0\n1999-01-01|2.0')
+            outfile.close()
+            series = Series.from_csv(path, sep='|')
+            checkseries = Series(
+                 {datetime(1998, 1, 1): 1.0, datetime(1999, 1, 1): 2.0})
+            assert_series_equal(checkseries, series)
+
+            series = Series.from_csv(path, sep='|', parse_dates=False)
+            checkseries = Series({'1998-01-01': 1.0, '1999-01-01': 2.0})
+            assert_series_equal(checkseries, series)
 
     def test_to_csv(self):
-        self.ts.to_csv('_foo')
 
-        lines = open('_foo', 'U').readlines()
-        assert(lines[1] != '\n')
+        with ensure_clean() as path:
+            self.ts.to_csv(path)
 
-        self.ts.to_csv('_foo', index=False)
-        arr = np.loadtxt('_foo')
-        assert_almost_equal(arr, self.ts.values)
+            lines = open(path, 'U').readlines()
+            assert(lines[1] != '\n')
 
-        os.remove('_foo')
+            self.ts.to_csv(path, index=False)
+            arr = np.loadtxt(path)
+            assert_almost_equal(arr, self.ts.values)
 
     def test_to_csv_unicode_index(self):
         buf = StringIO()
@@ -2620,14 +2623,14 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self.assert_(np.array_equal(Series(self.ts.to_dict()), self.ts))
 
     def test_to_csv_float_format(self):
-        filename = '__tmp__.csv'
-        ser = Series([0.123456, 0.234567, 0.567567])
-        ser.to_csv(filename, float_format='%.2f')
 
-        rs = Series.from_csv(filename)
-        xp = Series([0.12, 0.23, 0.57])
-        assert_series_equal(rs, xp)
-        os.remove(filename)
+        with ensure_clean() as filename:
+            ser = Series([0.123456, 0.234567, 0.567567])
+            ser.to_csv(filename, float_format='%.2f')
+
+            rs = Series.from_csv(filename)
+            xp = Series([0.12, 0.23, 0.57])
+            assert_series_equal(rs, xp)
 
     def test_to_csv_list_entries(self):
         s = Series(['jack and jill', 'jesse and frank'])
diff --git a/pandas/tseries/tests/test_plotting.py b/pandas/tseries/tests/test_plotting.py
index 69e965125..ec07077c7 100644
--- a/pandas/tseries/tests/test_plotting.py
+++ b/pandas/tseries/tests/test_plotting.py
@@ -15,7 +15,7 @@ from pandas.tseries.offsets import DateOffset
 from pandas.tseries.period import period_range, Period, PeriodIndex
 from pandas.tseries.resample import DatetimeIndex
 
-from pandas.util.testing import assert_series_equal
+from pandas.util.testing import assert_series_equal, ensure_clean
 import pandas.util.testing as tm
 
 
@@ -933,9 +933,6 @@ class TestTSPlot(unittest.TestCase):
         assert_array_equal(np.array([x.toordinal() for x in dates]),
                            line2.get_xydata()[:, 0])
 
-PNG_PATH = 'tmp.png'
-
-
 def _check_plot_works(f, freq=None, series=None, *args, **kwargs):
     import matplotlib.pyplot as plt
 
@@ -966,8 +963,9 @@ def _check_plot_works(f, freq=None, series=None, *args, **kwargs):
         assert(ret is not None)  # do something more intelligent
     except Exception:
         pass
-    plt.savefig(PNG_PATH)
-    os.remove(PNG_PATH)
+
+    with ensure_path() as path:
+        plt.savefig(path)
 
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index 758629a42..bcd3fb6a3 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -6,6 +6,7 @@ from datetime import datetime
 import random
 import string
 import sys
+import tempfile
 
 from contextlib import contextmanager  # contextlib is available since 2.5
 
@@ -74,6 +75,24 @@ def set_trace():
         from pdb import Pdb as OldPdb
         OldPdb().set_trace(sys._getframe().f_back)
 
+#------------------------------------------------------------------------------
+# contextmanager to ensure the file cleanup
+from contextlib import contextmanager
+@contextmanager
+def ensure_clean(filename = None):
+    # if we are not passed a filename, generate a temporary
+    if filename is None:
+        filename = tempfile.mkstemp()[1]
+
+    try:
+        yield filename
+    finally:
+        import os
+        try:
+            os.remove(filename)
+        except:
+            pass
+
 #------------------------------------------------------------------------------
 # Comparators
 

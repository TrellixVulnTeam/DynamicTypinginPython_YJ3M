commit 1d295cd95f8b06d28ddd026ec0ec3373effaf172
Author: Jeff Reback <jeff@reback.net>
Date:   Fri Jul 24 18:16:11 2015 -0400

    provide proper index coercion with _shallow_copy for insert,delete,append operations

diff --git a/doc/source/whatsnew/v0.17.0.txt b/doc/source/whatsnew/v0.17.0.txt
index 914ea6751..f4f8f8ae9 100644
--- a/doc/source/whatsnew/v0.17.0.txt
+++ b/doc/source/whatsnew/v0.17.0.txt
@@ -367,7 +367,8 @@ Bug Fixes
 - Bug in ``Series.shift`` and ``DataFrame.shift`` not supporting categorical data (:issue:`9416`)
 - Bug in ``Series.map`` using categorical ``Series`` raises ``AttributeError`` (:issue:`10324`)
 - Bug in ``MultiIndex.get_level_values`` including ``Categorical`` raises ``AttributeError`` (:issue:`10460`)
-- Bug in `get_dummies` with `sparse=True` not returning SparseDataFrame (:issue:`10531`)
+- Bug in ``pd.get_dummies`` with `sparse=True` not returning ``SparseDataFrame`` (:issue:`10531`)
+- Bug in ``Index`` subtypes (such as ``PeriodIndex``) not returning their own type for ``.drop`` and ``.insert`` methods (:issue:`10620`)
 
 
 
@@ -402,6 +403,3 @@ Bug Fixes
 - Bug in vectorised setting of timestamp columns with python ``datetime.date`` and numpy ``datetime64`` (:issue:`10408`, :issue:`10412`)
 
 - Bug in ``pd.DataFrame`` when constructing an empty DataFrame with a string dtype (:issue:`9428`)
-- Bug in `Index` subtypes (such as `PeriodIndex`) not returning their own type for `.drop` and `.insert` methods
-
-- Bug in `Index` subtypes (such as `PeriodIndex`) not returning their own type for `.drop` and `.insert` methods
diff --git a/pandas/core/index.py b/pandas/core/index.py
index f6f625762..ea9d1f38b 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -89,7 +89,6 @@ class Index(IndexOpsMixin, PandasObject):
     _left_indexer = _algos.left_join_indexer_object
     _inner_indexer = _algos.inner_join_indexer_object
     _outer_indexer = _algos.outer_join_indexer_object
-
     _box_scalars = False
 
     _typ = 'index'
@@ -204,6 +203,17 @@ class Index(IndexOpsMixin, PandasObject):
 
     @classmethod
     def _simple_new(cls, values, name=None, **kwargs):
+        """
+        we require the we have a dtype compat for the values
+        if we are passed a non-dtype compat, then coerce using the constructor
+
+        Must be careful not to recurse.
+        """
+        if not hasattr(values, 'dtype'):
+            values = np.array(values,copy=False)
+            if is_object_dtype(values):
+                values = cls(values, name=name, **kwargs).values
+
         result = object.__new__(cls)
         result._data = values
         result.name = name
@@ -341,15 +351,41 @@ class Index(IndexOpsMixin, PandasObject):
             result._id = self._id
         return result
 
-    def _shallow_copy(self, values=None, **kwargs):
-        """ create a new Index, don't copy the data, use the same object attributes
-            with passed in attributes taking precedence """
+    def _shallow_copy(self, values=None, infer=False, **kwargs):
+        """
+        create a new Index, don't copy the data, use the same object attributes
+        with passed in attributes taking precedence
+
+        *this is an internal non-public method*
+
+        Parameters
+        ----------
+        values : the values to create the new Index, optional
+        infer : boolean, default False
+            if True, infer the new type of the passed values
+        kwargs : updates the default attributes for this Index
+        """
         if values is None:
             values = self.values
         attributes = self._get_attributes_dict()
         attributes.update(kwargs)
+
+        if infer:
+            attributes['copy'] = False
+            return Index(values, **attributes)
+
         return self.__class__._simple_new(values,**attributes)
 
+    def _coerce_scalar_to_index(self, item):
+        """
+        we need to coerce a scalar to a compat for our index type
+
+        Parameters
+        ----------
+        item : scalar item to coerce
+        """
+        return Index([item], dtype=self.dtype, **self._get_attributes_dict())
+
     def copy(self, names=None, name=None, dtype=None, deep=False):
         """
         Make a copy of this object.  Name and dtype sets those attributes on
@@ -1132,7 +1168,9 @@ class Index(IndexOpsMixin, PandasObject):
         appended : Index
         """
         to_concat, name = self._ensure_compat_append(other)
-        return Index(np.concatenate(to_concat), name=name)
+        attribs = self._get_attributes_dict()
+        attribs['name'] = name
+        return self._shallow_copy(np.concatenate(to_concat), infer=True, **attribs)
 
     @staticmethod
     def _ensure_compat_concat(indexes):
@@ -2532,7 +2570,8 @@ class Index(IndexOpsMixin, PandasObject):
         -------
         new_index : Index
         """
-        return self._shallow_copy(np.delete(self._data, loc))
+        attribs = self._get_attributes_dict()
+        return self._shallow_copy(np.delete(self._data, loc), **attribs)
 
     def insert(self, loc, item):
         """
@@ -2548,12 +2587,13 @@ class Index(IndexOpsMixin, PandasObject):
         -------
         new_index : Index
         """
-        indexes=[self[:loc],
-                 Index([item]),
-                 self[loc:]]
-
-        return indexes[0].append(indexes[1]).append(indexes[2])
+        _self = np.asarray(self)
+        item = self._coerce_scalar_to_index(item).values
 
+        idx = np.concatenate(
+            (_self[:loc], item, _self[loc:]))
+        attribs = self._get_attributes_dict()
+        return self._shallow_copy(idx, infer=True, **attribs)
 
     def drop(self, labels, errors='raise'):
         """
@@ -3684,7 +3724,7 @@ class MultiIndex(Index):
         Level of sortedness (must be lexicographically sorted by that
         level)
     names : optional sequence of objects
-        Names for each of the index levels.
+        Names for each of the index levels. (name is accepted for compat)
     copy : boolean, default False
         Copy the meta-data
     verify_integrity : boolean, default True
@@ -3700,8 +3740,11 @@ class MultiIndex(Index):
     rename = Index.set_names
 
     def __new__(cls, levels=None, labels=None, sortorder=None, names=None,
-                copy=False, verify_integrity=True, _set_identity=True, **kwargs):
+                copy=False, verify_integrity=True, _set_identity=True, name=None, **kwargs):
 
+        # compat with Index
+        if name is not None:
+            names = name
         if levels is None or labels is None:
             raise TypeError("Must pass both levels and labels")
         if len(levels) != len(labels):
@@ -4010,7 +4053,12 @@ class MultiIndex(Index):
         result._id = self._id
         return result
 
-    _shallow_copy = view
+    def _shallow_copy(self, values=None, infer=False, **kwargs):
+        if values is not None:
+            if 'name' in kwargs:
+                kwargs['names'] = kwargs.pop('name',None)
+            return MultiIndex.from_tuples(values, **kwargs)
+        return self.view()
 
     @cache_readonly
     def dtype(self):
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index b030908b7..81c6366b4 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -401,30 +401,33 @@ class Base(object):
         for name, idx in compat.iteritems(self.indices):
             result = idx[1:4]
 
-            if len(idx)>0:
-                #test 0th element
-                self.assertTrue(idx[0:4].equals(
-                    result.insert(0, idx[0])))
+            if not len(idx):
+                continue
+
+            #test 0th element
+            self.assertTrue(idx[0:4].equals(
+                result.insert(0, idx[0])))
 
     def test_delete_base(self):
 
         for name, idx in compat.iteritems(self.indices):
 
-            if len(idx)>0:
+            if not len(idx):
+                continue
 
-                expected = idx[1:]
-                result = idx.delete(0)
-                self.assertTrue(result.equals(expected))
-                self.assertEqual(result.name, expected.name)
+            expected = idx[1:]
+            result = idx.delete(0)
+            self.assertTrue(result.equals(expected))
+            self.assertEqual(result.name, expected.name)
 
-                expected = idx[:-1]
-                result = idx.delete(-1)
-                self.assertTrue(result.equals(expected))
-                self.assertEqual(result.name, expected.name)
+            expected = idx[:-1]
+            result = idx.delete(-1)
+            self.assertTrue(result.equals(expected))
+            self.assertEqual(result.name, expected.name)
 
-                with tm.assertRaises((IndexError, ValueError)):
-                    # either depending on numpy version
-                    result = idx.delete(len(idx))
+            with tm.assertRaises((IndexError, ValueError)):
+                # either depending on numpy version
+                result = idx.delete(len(idx))
 
     def test_equals_op(self):
         # GH9947, GH10637
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 6cf972d4d..ec60edb6a 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -5,7 +5,8 @@ from datetime import timedelta
 import numpy as np
 from pandas.core.common import (_NS_DTYPE, _INT64_DTYPE,
                                 _values_from_object, _maybe_box,
-                                ABCSeries, is_integer, is_float)
+                                ABCSeries, is_integer, is_float,
+                                is_object_dtype, is_datetime64_dtype)
 from pandas.core.index import Index, Int64Index, Float64Index
 import pandas.compat as compat
 from pandas.compat import u
@@ -494,9 +495,16 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index):
 
     @classmethod
     def _simple_new(cls, values, name=None, freq=None, tz=None, **kwargs):
+        """
+        we require the we have a dtype compat for the values
+        if we are passed a non-dtype compat, then coerce using the constructor
+        """
+
         if not getattr(values,'dtype',None):
             values = np.array(values,copy=False)
-        if values.dtype != _NS_DTYPE:
+        if is_object_dtype(values):
+            return cls(values, name=name, freq=freq, tz=tz, **kwargs).values
+        elif not is_datetime64_dtype(values):
             values = com._ensure_int64(values).view(_NS_DTYPE)
 
         result = object.__new__(cls)
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index 7606bd0bd..242d9a775 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -19,7 +19,7 @@ from pandas._period import (
 import pandas.core.common as com
 from pandas.core.common import (isnull, _INT64_DTYPE, _maybe_box,
                                 _values_from_object, ABCSeries,
-                                is_integer, is_float)
+                                is_integer, is_float, is_object_dtype)
 from pandas import compat
 from pandas.lib import Timestamp, Timedelta
 import pandas.lib as lib
@@ -259,6 +259,11 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
 
     @classmethod
     def _simple_new(cls, values, name=None, freq=None, **kwargs):
+        if not getattr(values,'dtype',None):
+            values = np.array(values,copy=False)
+        if is_object_dtype(values):
+            return PeriodIndex(values, name=name, freq=freq, **kwargs)
+
         result = object.__new__(cls)
         result._data = values
         result.name = name
@@ -266,6 +271,20 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
         result._reset_identity()
         return result
 
+    def _shallow_copy(self, values=None, infer=False, **kwargs):
+        """ we always want to return a PeriodIndex """
+        return super(PeriodIndex, self)._shallow_copy(values=values, infer=False, **kwargs)
+
+    def _coerce_scalar_to_index(self, item):
+        """
+        we need to coerce a scalar to a compat for our index type
+
+        Parameters
+        ----------
+        item : scalar item to coerce
+        """
+        return PeriodIndex([item], **self._get_attributes_dict())
+
     @property
     def _na_value(self):
         return self._box_func(tslib.iNaT)

commit 31f06e6ec7b0eaf7ce1cf9dd962c4b0827a6ab8d
Author: benjamin <bjonen@gmail.com>
Date:   Mon Mar 17 22:54:56 2014 +0100

    ENH: Added CustomBusinessMonth offset.

diff --git a/doc/source/timeseries.rst b/doc/source/timeseries.rst
index 899bc2232..e3070ff15 100644
--- a/doc/source/timeseries.rst
+++ b/doc/source/timeseries.rst
@@ -432,6 +432,8 @@ frequency increment. Specific offset logic like "month", "business day", or
     MonthBegin, "calendar month begin"
     BMonthEnd, "business month end"
     BMonthBegin, "business month begin"
+    CBMonthEnd, "custom business month end"
+    CBMonthBegin, "custom business month begin"
     QuarterEnd, "calendar quarter end"
     QuarterBegin, "calendar quarter begin"
     BQuarterEnd, "business quarter end"
@@ -558,6 +560,20 @@ As of v0.14 holiday calendars can be used to provide the list of holidays.  See
     # Tuesday after MLK Day (Monday is skipped because it's a holiday)
     dt + bday_us
 
+Monthly offsets that respect a certain holiday calendar can be defined
+in the usual way.
+
+.. ipython:: python
+
+    from pandas.tseries.offsets import CustomBusinessMonthBegin
+    bmth_us = CustomBusinessMonthBegin(calendar=USFederalHolidayCalendar())
+    # Skip new years
+    dt = datetime(2013, 12, 17)
+    dt + bmth_us
+   
+    # Define date index with custom offset
+    from pandas import DatetimeIndex
+    DatetimeIndex(start='20100101',end='20120101',freq=bmth_us)
 
 .. note::
 
@@ -601,8 +617,10 @@ frequencies. We will refer to these aliases as *offset aliases*
     "W", "weekly frequency"
     "M", "month end frequency"
     "BM", "business month end frequency"
+    "CBM", "custom business month end frequency"
     "MS", "month start frequency"
     "BMS", "business month start frequency"
+    "CBMS", "custom business month start frequency"
     "Q", "quarter end frequency"
     "BQ", "business quarter endfrequency"
     "QS", "quarter start frequency"
diff --git a/doc/source/v0.14.0.txt b/doc/source/v0.14.0.txt
index 49507f2b6..e4b356e37 100644
--- a/doc/source/v0.14.0.txt
+++ b/doc/source/v0.14.0.txt
@@ -477,6 +477,7 @@ Enhancements
 - Implemented ``Panel.pct_change`` (:issue:`6904`)
 - Added ``how`` option to rolling-moment functions to dictate how to handle resampling; :func:``rolling_max`` defaults to max,
   :func:``rolling_min`` defaults to min, and all others default to mean (:issue:`6297`)
+- ``CustomBuisnessMonthBegin`` and ``CustomBusinessMonthEnd`` are now available (:issue:`6866`) 
 
 Performance
 ~~~~~~~~~~~
diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 1fb6ae422..6678baac1 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -10,14 +10,20 @@ businessDay = bday
 try:
     cday = CDay()
     customBusinessDay = CustomBusinessDay()
+    customBusinessMonthEnd = CBMonthEnd()
+    customBusinessMonthBegin = CBMonthBegin()
 except NotImplementedError:
     cday = None
     customBusinessDay = None
+    customBusinessMonthEnd = None
+    customBusinessMonthBegin = None
 monthEnd = MonthEnd()
 yearEnd = YearEnd()
 yearBegin = YearBegin()
 bmonthEnd = BMonthEnd()
-businessMonthEnd = bmonthEnd
+bmonthBegin = BMonthBegin()
+cbmonthEnd = customBusinessMonthEnd
+cbmonthBegin = customBusinessMonthBegin
 bquarterEnd = BQuarterEnd()
 quarterEnd = QuarterEnd()
 byearEnd = BYearEnd()
diff --git a/pandas/tseries/offsets.py b/pandas/tseries/offsets.py
index d5eaad61b..0c8d3c716 100644
--- a/pandas/tseries/offsets.py
+++ b/pandas/tseries/offsets.py
@@ -1,3 +1,4 @@
+import sys
 from datetime import date, datetime, timedelta
 from pandas.compat import range
 from pandas import compat
@@ -16,6 +17,7 @@ from pandas import _np_version_under1p7
 import functools
 
 __all__ = ['Day', 'BusinessDay', 'BDay', 'CustomBusinessDay', 'CDay',
+           'CBMonthEnd','CBMonthBegin',
            'MonthBegin', 'BMonthBegin', 'MonthEnd', 'BMonthEnd',
            'YearBegin', 'BYearBegin', 'YearEnd', 'BYearEnd',
            'QuarterBegin', 'BQuarterBegin', 'QuarterEnd', 'BQuarterEnd',
@@ -703,6 +705,132 @@ class BusinessMonthBegin(MonthOffset):
     _prefix = 'BMS'
 
 
+
+class CustomBusinessMonthEnd(MonthOffset):
+    """
+    **EXPERIMENTAL** DateOffset of one custom business month
+
+    .. warning:: EXPERIMENTAL
+
+        This class is not officially supported and the API is likely to change
+        in future versions. Use this at your own risk.
+
+    Parameters
+    ----------
+    n : int, default 1
+    offset : timedelta, default timedelta(0)
+    normalize : bool, default False
+        Normalize start/end dates to midnight before generating date range
+    weekmask : str, Default 'Mon Tue Wed Thu Fri'
+        weekmask of valid business days, passed to ``numpy.busdaycalendar``
+    holidays : list
+        list/array of dates to exclude from the set of valid business days,
+        passed to ``numpy.busdaycalendar``
+    """
+
+    _cacheable = False
+    _prefix = 'CBM'
+    def __init__(self, n=1, **kwds):
+        self.n = int(n)
+        self.kwds = kwds
+        self.offset = kwds.get('offset', timedelta(0))
+        self.normalize = kwds.get('normalize', False)
+        self.weekmask = kwds.get('weekmask', 'Mon Tue Wed Thu Fri')
+        holidays = kwds.get('holidays', [])
+        self.cbday = CustomBusinessDay(n=self.n,**kwds)
+        self.m_offset = MonthEnd()
+
+    @apply_nat
+    def apply(self,other):
+        n = self.n
+        dt_in = other
+        # First move to month offset
+        cur_mend = self.m_offset.rollforward(dt_in)
+        # Find this custom month offset
+        cur_cmend = self.cbday.rollback(cur_mend)
+        
+        # handle zero case. arbitrarily rollforward
+        if n == 0 and dt_in != cur_cmend:
+            n += 1
+
+        if dt_in < cur_cmend and n >= 1:
+            n -= 1
+        elif dt_in > cur_cmend and n <= -1:
+            n += 1
+ 
+        new = cur_mend + n * MonthEnd()
+        result = self.cbday.rollback(new)
+        return as_timestamp(result)
+        
+    def __repr__(self):
+        if sys.version_info.major < 3:
+            return BusinessDay.__repr__.__func__(self)
+        else:
+            return BusinessDay.__repr__(self)
+
+class CustomBusinessMonthBegin(MonthOffset):
+    """
+    **EXPERIMENTAL** DateOffset of one custom business month
+
+    .. warning:: EXPERIMENTAL
+
+        This class is not officially supported and the API is likely to change
+        in future versions. Use this at your own risk.
+
+    Parameters
+    ----------
+    n : int, default 1
+    offset : timedelta, default timedelta(0)
+    normalize : bool, default False
+        Normalize start/end dates to midnight before generating date range
+    weekmask : str, Default 'Mon Tue Wed Thu Fri'
+        weekmask of valid business days, passed to ``numpy.busdaycalendar``
+    holidays : list
+        list/array of dates to exclude from the set of valid business days,
+        passed to ``numpy.busdaycalendar``
+    """
+
+    _cacheable = False
+    _prefix = 'CBMS'
+    def __init__(self, n=1, **kwds):
+        self.n = int(n)
+        self.kwds = kwds
+        self.offset = kwds.get('offset', timedelta(0))
+        self.normalize = kwds.get('normalize', False)
+        self.weekmask = kwds.get('weekmask', 'Mon Tue Wed Thu Fri')
+        holidays = kwds.get('holidays', [])
+        self.cbday = CustomBusinessDay(n=self.n,**kwds)
+        self.m_offset = MonthBegin()
+
+    @apply_nat
+    def apply(self,other):
+        n = self.n
+        dt_in = other
+        # First move to month offset
+        cur_mbegin = self.m_offset.rollback(dt_in)
+        # Find this custom month offset
+        cur_cmbegin = self.cbday.rollforward(cur_mbegin)
+
+        # handle zero case. arbitrarily rollforward
+        if n == 0 and dt_in != cur_cmbegin:
+            n += 1
+
+        if dt_in > cur_cmbegin and n <= -1:
+            n += 1
+        elif dt_in < cur_cmbegin and n >= 1:
+            n -= 1
+ 
+        new = cur_mbegin + n * MonthBegin()
+        result = self.cbday.rollforward(new)
+        return as_timestamp(result)
+
+        
+    def __repr__(self):
+        if sys.version_info.major < 3:
+            return BusinessDay.__repr__.__func__(self)
+        else:
+            return BusinessDay.__repr__(self)
+
 class Week(DateOffset):
     """
     Weekly offset
@@ -1906,6 +2034,8 @@ class Nano(Tick):
 BDay = BusinessDay
 BMonthEnd = BusinessMonthEnd
 BMonthBegin = BusinessMonthBegin
+CBMonthEnd = CustomBusinessMonthEnd
+CBMonthBegin = CustomBusinessMonthBegin
 CDay = CustomBusinessDay
 
 
@@ -1988,28 +2118,30 @@ def generate_range(start=None, end=None, periods=None,
         cur = next_date
 
 prefix_mapping = dict((offset._prefix, offset) for offset in [
-    YearBegin,           # 'AS'
-    YearEnd,             # 'A'
-    BYearBegin,          # 'BAS'
-    BYearEnd,            # 'BA'
-    BusinessDay,         # 'B'
-    BusinessMonthBegin,  # 'BMS'
-    BusinessMonthEnd,    # 'BM'
-    BQuarterEnd,         # 'BQ'
-    BQuarterBegin,       # 'BQS'
-    CustomBusinessDay,   # 'C'
-    MonthEnd,            # 'M'
-    MonthBegin,          # 'MS'
-    Week,                # 'W'
-    Second,              # 'S'
-    Minute,              # 'T'
-    Micro,               # 'U'
-    QuarterEnd,          # 'Q'
-    QuarterBegin,        # 'QS'
-    Milli,               # 'L'
-    Hour,                # 'H'
-    Day,                 # 'D'
-    WeekOfMonth,         # 'WOM'
+    YearBegin,                # 'AS'
+    YearEnd,                  # 'A'
+    BYearBegin,               # 'BAS'
+    BYearEnd,                 # 'BA'
+    BusinessDay,              # 'B'
+    BusinessMonthBegin,       # 'BMS'
+    BusinessMonthEnd,         # 'BM'
+    BQuarterEnd,              # 'BQ'
+    BQuarterBegin,            # 'BQS'
+    CustomBusinessDay,        # 'C'
+    CustomBusinessMonthEnd,   # 'CBM'
+    CustomBusinessMonthBegin, # 'CBMS'
+    MonthEnd,                 # 'M'
+    MonthBegin,               # 'MS'
+    Week,                     # 'W'
+    Second,                   # 'S'
+    Minute,                   # 'T'
+    Micro,                    # 'U'
+    QuarterEnd,               # 'Q'
+    QuarterBegin,             # 'QS'
+    Milli,                    # 'L'
+    Hour,                     # 'H'
+    Day,                      # 'D'
+    WeekOfMonth,              # 'WOM'
     FY5253,
     FY5253Quarter,
 ])
diff --git a/pandas/tseries/tests/test_offsets.py b/pandas/tseries/tests/test_offsets.py
index 45ac1b3ac..c67af9f50 100644
--- a/pandas/tseries/tests/test_offsets.py
+++ b/pandas/tseries/tests/test_offsets.py
@@ -9,10 +9,11 @@ from nose.tools import assert_raises
 import numpy as np
 
 from pandas.core.datetools import (
-    bday, BDay, cday, CDay, BQuarterEnd, BMonthEnd, BYearEnd, MonthEnd,
-    MonthBegin, BYearBegin, QuarterBegin, BQuarterBegin, BMonthBegin,
-    DateOffset, Week, YearBegin, YearEnd, Hour, Minute, Second, Day, Micro,
-    Milli, Nano, Easter, 
+    bday, BDay, cday, CDay, BQuarterEnd, BMonthEnd,
+    CBMonthEnd, CBMonthBegin, 
+    BYearEnd, MonthEnd, MonthBegin, BYearBegin,
+    QuarterBegin, BQuarterBegin, BMonthBegin, DateOffset, Week,
+    YearBegin, YearEnd, Hour, Minute, Second, Day, Micro, Milli, Nano, Easter,
     WeekOfMonth, format, ole2datetime, QuarterEnd, to_datetime, normalize_date,
     get_offset, get_offset_name, get_standard_freq)
 
@@ -100,7 +101,7 @@ class TestBase(tm.TestCase):
     _offset = None
 
     offset_types = [getattr(offsets, o) for o in offsets.__all__]
-    skip_np_u1p7 = [offsets.CustomBusinessDay, offsets.CDay, offsets.Nano]
+    skip_np_u1p7 = [offsets.CustomBusinessDay, offsets.CDay, offsets.CustomBusinessMonthBegin, offsets.CustomBusinessMonthEnd, offsets.Nano]
 
     def _get_offset(self, klass, value=1):
         # create instance from offset class
@@ -594,6 +595,328 @@ class TestCustomBusinessDay(TestBase):
         dt = datetime(2014, 1, 17)
         assertEq(CDay(calendar=calendar), dt, datetime(2014, 1, 21))
 
+class TestCustomBusinessMonthEnd(TestBase):
+    _multiprocess_can_split_ = True
+
+    def setUp(self):
+        self.d = datetime(2008, 1, 1)
+
+        _skip_if_no_cday()        
+        self.offset = CBMonthEnd()
+        self.offset2 = CBMonthEnd(2)
+
+    def test_different_normalize_equals(self):
+        # equivalent in this special case
+        offset = CBMonthEnd()
+        offset2 = CBMonthEnd()
+        offset2.normalize = True
+        self.assertEqual(offset, offset2)
+
+    def test_repr(self):
+        assert repr(self.offset) == '<CustomBusinessMonthEnd>'
+        assert repr(self.offset2) == '<2 * CustomBusinessMonthEnds>'
+
+    def testEQ(self):
+        self.assertEqual(self.offset2, self.offset2)
+
+    def test_mul(self):
+        pass
+
+    def test_hash(self):
+        self.assertEqual(hash(self.offset2), hash(self.offset2))
+
+    def testCall(self):
+        self.assertEqual(self.offset2(self.d), datetime(2008, 2, 29))
+
+    def testRAdd(self):
+        self.assertEqual(self.d + self.offset2, self.offset2 + self.d)
+
+    def testSub(self):
+        off = self.offset2
+        self.assertRaises(Exception, off.__sub__, self.d)
+        self.assertEqual(2 * off - off, off)
+
+        self.assertEqual(self.d - self.offset2, 
+                         self.d + CBMonthEnd(-2))
+
+    def testRSub(self):
+        self.assertEqual(self.d - self.offset2, (-self.offset2).apply(self.d))
+
+    def testMult1(self):
+        self.assertEqual(self.d + 10 * self.offset, 
+                         self.d + CBMonthEnd(10))
+
+    def testMult2(self):
+        self.assertEqual(self.d + (-5 * CBMonthEnd(-10)),
+                         self.d + CBMonthEnd(50))
+
+    def testRollback1(self):
+        self.assertEqual(
+            CDay(10).rollback(datetime(2007, 12, 31)), datetime(2007, 12, 31))
+
+    def testRollback2(self):
+        self.assertEqual(CBMonthEnd(10).rollback(self.d),
+                         datetime(2007,12,31))
+
+    def testRollforward1(self):
+        self.assertEqual(CBMonthEnd(10).rollforward(self.d), datetime(2008,1,31))
+
+    def test_roll_date_object(self):
+        offset = CBMonthEnd()
+
+        dt = date(2012, 9, 15)
+
+        result = offset.rollback(dt)
+        self.assertEqual(result, datetime(2012, 8, 31))
+
+        result = offset.rollforward(dt)
+        self.assertEqual(result, datetime(2012, 9, 28))
+
+        offset = offsets.Day()
+        result = offset.rollback(dt)
+        self.assertEqual(result, datetime(2012, 9, 15))
+
+        result = offset.rollforward(dt)
+        self.assertEqual(result, datetime(2012, 9, 15))
+
+    def test_onOffset(self):
+        tests = [(CBMonthEnd(), datetime(2008, 1, 31), True),
+                 (CBMonthEnd(), datetime(2008, 1, 1), False)]
+
+        for offset, date, expected in tests:
+            assertOnOffset(offset, date, expected)
+
+
+    def test_apply(self):
+        cbm = CBMonthEnd()
+        tests = []
+
+        tests.append((cbm,
+                      {datetime(2008, 1, 1): datetime(2008, 1, 31),
+                       datetime(2008, 2, 7): datetime(2008, 2, 29)}))
+
+        tests.append((2 * cbm,
+                      {datetime(2008, 1, 1): datetime(2008, 2, 29),
+                       datetime(2008, 2, 7): datetime(2008, 3, 31)}))
+
+        tests.append((-cbm,
+                      {datetime(2008, 1, 1): datetime(2007, 12, 31),
+                       datetime(2008, 2, 8): datetime(2008, 1, 31)}))
+
+        tests.append((-2 * cbm,
+                      {datetime(2008, 1, 1): datetime(2007, 11, 30),
+                       datetime(2008, 2, 9): datetime(2007, 12, 31)}))
+
+        tests.append((CBMonthEnd(0),
+                      {datetime(2008, 1, 1): datetime(2008, 1, 31),
+                       datetime(2008, 2, 7): datetime(2008, 2, 29)}))
+
+        for offset, cases in tests:
+            for base, expected in compat.iteritems(cases):
+                assertEq(offset, base, expected)
+
+    def test_apply_large_n(self):
+        dt = datetime(2012, 10, 23)
+
+        result = dt + CBMonthEnd(10)
+        self.assertEqual(result, datetime(2013, 7, 31))
+
+        result = dt + CDay(100) - CDay(100)
+        self.assertEqual(result, dt)
+
+        off = CBMonthEnd() * 6
+        rs = datetime(2012, 1, 1) - off
+        xp = datetime(2011, 7, 29)
+        self.assertEqual(rs, xp)
+
+        st = datetime(2011, 12, 18)
+        rs = st + off
+        xp = datetime(2012, 5, 31)
+        self.assertEqual(rs, xp)
+
+    def test_offsets_compare_equal(self):
+        offset1 = CBMonthEnd()
+        offset2 = CBMonthEnd()
+        self.assertFalse(offset1 != offset2)
+
+    def test_holidays(self):
+        # Define a TradingDay offset
+        holidays = ['2012-01-31', datetime(2012, 2, 28),
+                    np.datetime64('2012-02-29')]
+        bm_offset = CBMonthEnd(holidays=holidays)
+        dt = datetime(2012,1,1)
+        self.assertEqual(dt + bm_offset,datetime(2012,1,30))
+        self.assertEqual(dt + 2*bm_offset,datetime(2012,2,27))
+
+    def test_datetimindex(self):
+        from pandas.tseries.holiday import USFederalHolidayCalendar
+        self.assertEqual(DatetimeIndex(start='2012',end='2013',freq='CBM').tolist()[0],
+        datetime(2012,4,30))
+        self.assertEqual(DatetimeIndex(start='20120101',end='20130101',freq=CBMonthEnd(calendar=USFederalHolidayCalendar())).tolist()[0],
+        datetime(2012,1,31))
+
+
+class TestCustomBusinessMonthBegin(TestBase):
+    _multiprocess_can_split_ = True
+
+    def setUp(self):
+        self.d = datetime(2008, 1, 1)
+
+        _skip_if_no_cday()        
+        self.offset = CBMonthBegin()
+        self.offset2 = CBMonthBegin(2)
+
+    def test_different_normalize_equals(self):
+        # equivalent in this special case
+        offset = CBMonthBegin()
+        offset2 = CBMonthBegin()
+        offset2.normalize = True
+        self.assertEqual(offset, offset2)
+
+    def test_repr(self):
+        assert repr(self.offset) == '<CustomBusinessMonthBegin>'
+        assert repr(self.offset2) == '<2 * CustomBusinessMonthBegins>'
+
+    def testEQ(self):
+        self.assertEqual(self.offset2, self.offset2)
+
+    def test_mul(self):
+        pass
+
+    def test_hash(self):
+        self.assertEqual(hash(self.offset2), hash(self.offset2))
+
+    def testCall(self):
+        self.assertEqual(self.offset2(self.d), datetime(2008, 3, 3))
+
+    def testRAdd(self):
+        self.assertEqual(self.d + self.offset2, self.offset2 + self.d)
+
+    def testSub(self):
+        off = self.offset2
+        self.assertRaises(Exception, off.__sub__, self.d)
+        self.assertEqual(2 * off - off, off)
+
+        self.assertEqual(self.d - self.offset2, 
+                         self.d + CBMonthBegin(-2))
+
+    def testRSub(self):
+        self.assertEqual(self.d - self.offset2, (-self.offset2).apply(self.d))
+
+    def testMult1(self):
+        self.assertEqual(self.d + 10 * self.offset, 
+                         self.d + CBMonthBegin(10))
+
+    def testMult2(self):
+        self.assertEqual(self.d + (-5 * CBMonthBegin(-10)),
+                         self.d + CBMonthBegin(50))
+
+    def testRollback1(self):
+        self.assertEqual(
+            CDay(10).rollback(datetime(2007, 12, 31)), datetime(2007, 12, 31))
+
+    def testRollback2(self):
+        self.assertEqual(CBMonthBegin(10).rollback(self.d),
+                         datetime(2008,1,1))
+
+    def testRollforward1(self):
+        self.assertEqual(CBMonthBegin(10).rollforward(self.d), datetime(2008,1,1))
+
+    def test_roll_date_object(self):
+        offset = CBMonthBegin()
+
+        dt = date(2012, 9, 15)
+
+        result = offset.rollback(dt)
+        self.assertEqual(result, datetime(2012, 9, 3))
+
+        result = offset.rollforward(dt)
+        self.assertEqual(result, datetime(2012, 10, 1))
+
+        offset = offsets.Day()
+        result = offset.rollback(dt)
+        self.assertEqual(result, datetime(2012, 9, 15))
+
+        result = offset.rollforward(dt)
+        self.assertEqual(result, datetime(2012, 9, 15))
+
+    def test_onOffset(self):
+        tests = [(CBMonthBegin(), datetime(2008, 1, 1), True),
+                 (CBMonthBegin(), datetime(2008, 1, 31), False)]
+
+        for offset, date, expected in tests:
+            assertOnOffset(offset, date, expected)
+
+
+    def test_apply(self):
+        cbm = CBMonthBegin()
+        tests = []
+
+        tests.append((cbm,
+                      {datetime(2008, 1, 1): datetime(2008, 2, 1),
+                       datetime(2008, 2, 7): datetime(2008, 3, 3)}))
+
+        tests.append((2 * cbm,
+                      {datetime(2008, 1, 1): datetime(2008, 3, 3),
+                       datetime(2008, 2, 7): datetime(2008, 4, 1)}))
+
+        tests.append((-cbm,
+                      {datetime(2008, 1, 1): datetime(2007, 12, 3),
+                       datetime(2008, 2, 8): datetime(2008, 2, 1)}))
+
+        tests.append((-2 * cbm,
+                      {datetime(2008, 1, 1): datetime(2007, 11, 1),
+                       datetime(2008, 2, 9): datetime(2008, 1, 1)}))
+
+        tests.append((CBMonthBegin(0),
+                      {datetime(2008, 1, 1): datetime(2008, 1, 1),
+                       datetime(2008, 1, 7): datetime(2008, 2, 1)}))
+
+        for offset, cases in tests:
+            for base, expected in compat.iteritems(cases):
+                assertEq(offset, base, expected)
+
+    def test_apply_large_n(self):
+        dt = datetime(2012, 10, 23)
+
+        result = dt + CBMonthBegin(10)
+        self.assertEqual(result, datetime(2013, 8, 1))
+
+        result = dt + CDay(100) - CDay(100)
+        self.assertEqual(result, dt)
+
+        off = CBMonthBegin() * 6
+        rs = datetime(2012, 1, 1) - off
+        xp = datetime(2011, 7, 1)
+        self.assertEqual(rs, xp)
+
+        st = datetime(2011, 12, 18)
+        rs = st + off
+        xp = datetime(2012, 6, 1)
+        self.assertEqual(rs, xp)
+
+    def test_offsets_compare_equal(self):
+        offset1 = CBMonthBegin()
+        offset2 = CBMonthBegin()
+        self.assertFalse(offset1 != offset2)
+
+    def test_holidays(self):
+        # Define a TradingDay offset
+        holidays = ['2012-02-01', datetime(2012, 2, 2),
+                    np.datetime64('2012-03-01')]
+        bm_offset = CBMonthBegin(holidays=holidays)
+        dt = datetime(2012,1,1)
+        self.assertEqual(dt + bm_offset,datetime(2012,1,2))
+        self.assertEqual(dt + 2*bm_offset,datetime(2012,2,3))
+
+    def test_datetimindex(self):
+        self.assertEqual(DatetimeIndex(start='2012',end='2013',freq='CBMS').tolist()[0],
+                         datetime(2012,5,1))
+        self.assertEqual(DatetimeIndex(start='20120101',end='20130101',freq=CBMonthBegin(calendar=USFederalHolidayCalendar())).tolist()[0],
+        datetime(2012,1,3))
+
+
+
 def assertOnOffset(offset, date, expected):
     actual = offset.onOffset(date)
     assert actual == expected, ("\nExpected: %s\nActual: %s\nFor Offset: %s)"
diff --git a/vb_suite/timeseries.py b/vb_suite/timeseries.py
index 3ea970bae..06ef99442 100644
--- a/vb_suite/timeseries.py
+++ b/vb_suite/timeseries.py
@@ -288,6 +288,7 @@ import pandas as pd
 
 date = dt.datetime(2011,1,1)
 cday = pd.offsets.CustomBusinessDay()
+cme = pd.offsets.CustomBusinessMonthEnd()
 """
 timeseries_custom_bday_incr = \
     Benchmark("date + cday",setup)
@@ -295,3 +296,10 @@ timeseries_custom_bday_incr = \
 # Increment by n
 timeseries_custom_bday_incr_n = \
     Benchmark("date + 10 * cday",setup)
+
+# Increment custom business month
+timeseries_custom_bmonthend_incr = \
+    Benchmark("date + cme",setup)
+
+timeseries_custom_bmonthend_incr_n = \
+    Benchmark("date + 10 * cme",setup)

commit 79e1fc3d1242901a3080be9bbe8c7a4f8769a748
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Thu Nov 14 08:31:54 2019 -0800

    REF: boilerplate for ops internal consistency (#28037)

diff --git a/pandas/core/arrays/categorical.py b/pandas/core/arrays/categorical.py
index 73d1db9bd..817972b33 100644
--- a/pandas/core/arrays/categorical.py
+++ b/pandas/core/arrays/categorical.py
@@ -8,7 +8,7 @@ import numpy as np
 
 from pandas._config import get_option
 
-from pandas._libs import algos as libalgos, hashtable as htable, lib
+from pandas._libs import algos as libalgos, hashtable as htable
 from pandas.compat.numpy import function as nv
 from pandas.util._decorators import (
     Appender,
@@ -39,7 +39,7 @@ from pandas.core.dtypes.common import (
     needs_i8_conversion,
 )
 from pandas.core.dtypes.dtypes import CategoricalDtype
-from pandas.core.dtypes.generic import ABCDataFrame, ABCIndexClass, ABCSeries
+from pandas.core.dtypes.generic import ABCIndexClass, ABCSeries
 from pandas.core.dtypes.inference import is_hashable
 from pandas.core.dtypes.missing import isna, notna
 
@@ -52,6 +52,7 @@ from pandas.core.base import NoNewAttributesMixin, PandasObject, _shared_docs
 import pandas.core.common as com
 from pandas.core.construction import array, extract_array, sanitize_array
 from pandas.core.missing import interpolate_2d
+from pandas.core.ops.common import unpack_zerodim_and_defer
 from pandas.core.sorting import nargsort
 
 from pandas.io.formats import console
@@ -74,16 +75,14 @@ _take_msg = textwrap.dedent(
 def _cat_compare_op(op):
     opname = "__{op}__".format(op=op.__name__)
 
+    @unpack_zerodim_and_defer(opname)
     def f(self, other):
         # On python2, you can usually compare any type to any type, and
         # Categoricals can be seen as a custom type, but having different
         # results depending whether categories are the same or not is kind of
         # insane, so be a bit stricter here and use the python3 idea of
         # comparing only things of equal type.
-        if isinstance(other, (ABCDataFrame, ABCSeries, ABCIndexClass)):
-            return NotImplemented
 
-        other = lib.item_from_zerodim(other)
         if is_list_like(other) and len(other) != len(self):
             # TODO: Could this fail if the categories are listlike objects?
             raise ValueError("Lengths must match.")
diff --git a/pandas/core/arrays/datetimelike.py b/pandas/core/arrays/datetimelike.py
index 287ff9d61..e52bc17fc 100644
--- a/pandas/core/arrays/datetimelike.py
+++ b/pandas/core/arrays/datetimelike.py
@@ -33,12 +33,7 @@ from pandas.core.dtypes.common import (
     is_unsigned_integer_dtype,
     pandas_dtype,
 )
-from pandas.core.dtypes.generic import (
-    ABCDataFrame,
-    ABCIndexClass,
-    ABCPeriodArray,
-    ABCSeries,
-)
+from pandas.core.dtypes.generic import ABCIndexClass, ABCPeriodArray, ABCSeries
 from pandas.core.dtypes.inference import is_array_like
 from pandas.core.dtypes.missing import is_valid_nat_for_dtype, isna
 
@@ -46,6 +41,7 @@ from pandas._typing import DatetimeLikeScalar
 from pandas.core import missing, nanops
 from pandas.core.algorithms import checked_add_with_arr, take, unique1d, value_counts
 import pandas.core.common as com
+from pandas.core.ops.common import unpack_zerodim_and_defer
 from pandas.core.ops.invalid import make_invalid_op
 
 from pandas.tseries import frequencies
@@ -1194,13 +1190,11 @@ class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)
         #  to be passed explicitly.
         return self._generate_range(start=start, end=end, periods=None, freq=self.freq)
 
+    @unpack_zerodim_and_defer("__add__")
     def __add__(self, other):
-        other = lib.item_from_zerodim(other)
-        if isinstance(other, (ABCSeries, ABCDataFrame, ABCIndexClass)):
-            return NotImplemented
 
         # scalar others
-        elif other is NaT:
+        if other is NaT:
             result = self._add_nat()
         elif isinstance(other, (Tick, timedelta, np.timedelta64)):
             result = self._add_delta(other)
@@ -1248,13 +1242,11 @@ class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)
         # alias for __add__
         return self.__add__(other)
 
+    @unpack_zerodim_and_defer("__sub__")
     def __sub__(self, other):
-        other = lib.item_from_zerodim(other)
-        if isinstance(other, (ABCSeries, ABCDataFrame, ABCIndexClass)):
-            return NotImplemented
 
         # scalar others
-        elif other is NaT:
+        if other is NaT:
             result = self._sub_nat()
         elif isinstance(other, (Tick, timedelta, np.timedelta64)):
             result = self._add_delta(-other)
@@ -1343,11 +1335,11 @@ class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)
         return -(self - other)
 
     # FIXME: DTA/TDA/PA inplace methods should actually be inplace, GH#24115
-    def __iadd__(self, other):
+    def __iadd__(self, other):  # type: ignore
         # alias for __add__
         return self.__add__(other)
 
-    def __isub__(self, other):
+    def __isub__(self, other):  # type: ignore
         # alias for __sub__
         return self.__sub__(other)
 
diff --git a/pandas/core/arrays/datetimes.py b/pandas/core/arrays/datetimes.py
index 7cd103d12..8e3c727a1 100644
--- a/pandas/core/arrays/datetimes.py
+++ b/pandas/core/arrays/datetimes.py
@@ -40,12 +40,7 @@ from pandas.core.dtypes.common import (
     pandas_dtype,
 )
 from pandas.core.dtypes.dtypes import DatetimeTZDtype
-from pandas.core.dtypes.generic import (
-    ABCDataFrame,
-    ABCIndexClass,
-    ABCPandasArray,
-    ABCSeries,
-)
+from pandas.core.dtypes.generic import ABCIndexClass, ABCPandasArray, ABCSeries
 from pandas.core.dtypes.missing import isna
 
 from pandas.core import ops
@@ -53,6 +48,7 @@ from pandas.core.algorithms import checked_add_with_arr
 from pandas.core.arrays import datetimelike as dtl
 from pandas.core.arrays._ranges import generate_regular_range
 import pandas.core.common as com
+from pandas.core.ops.common import unpack_zerodim_and_defer
 from pandas.core.ops.invalid import invalid_comparison
 
 from pandas.tseries.frequencies import get_period_alias, to_offset
@@ -157,11 +153,8 @@ def _dt_array_cmp(cls, op):
     opname = "__{name}__".format(name=op.__name__)
     nat_result = opname == "__ne__"
 
+    @unpack_zerodim_and_defer(opname)
     def wrapper(self, other):
-        if isinstance(other, (ABCDataFrame, ABCSeries, ABCIndexClass)):
-            return NotImplemented
-
-        other = lib.item_from_zerodim(other)
 
         if isinstance(other, (datetime, np.datetime64, str)):
             if isinstance(other, (datetime, np.datetime64)):
diff --git a/pandas/core/arrays/integer.py b/pandas/core/arrays/integer.py
index 41d8bffd8..e167e556b 100644
--- a/pandas/core/arrays/integer.py
+++ b/pandas/core/arrays/integer.py
@@ -21,12 +21,12 @@ from pandas.core.dtypes.common import (
     is_scalar,
 )
 from pandas.core.dtypes.dtypes import register_extension_dtype
-from pandas.core.dtypes.generic import ABCDataFrame, ABCIndexClass, ABCSeries
 from pandas.core.dtypes.missing import isna, notna
 
 from pandas.core import nanops, ops
 from pandas.core.algorithms import take
 from pandas.core.arrays import ExtensionArray, ExtensionOpsMixin
+from pandas.core.ops.common import unpack_zerodim_and_defer
 from pandas.core.tools.numeric import to_numeric
 
 
@@ -602,13 +602,8 @@ class IntegerArray(ExtensionArray, ExtensionOpsMixin):
     def _create_comparison_method(cls, op):
         op_name = op.__name__
 
+        @unpack_zerodim_and_defer(op.__name__)
         def cmp_method(self, other):
-
-            if isinstance(other, (ABCDataFrame, ABCSeries, ABCIndexClass)):
-                # Rely on pandas to unbox and dispatch to us.
-                return NotImplemented
-
-            other = lib.item_from_zerodim(other)
             mask = None
 
             if isinstance(other, IntegerArray):
@@ -697,15 +692,14 @@ class IntegerArray(ExtensionArray, ExtensionOpsMixin):
     def _create_arithmetic_method(cls, op):
         op_name = op.__name__
 
+        @unpack_zerodim_and_defer(op.__name__)
         def integer_arithmetic_method(self, other):
 
-            if isinstance(other, (ABCDataFrame, ABCSeries, ABCIndexClass)):
-                # Rely on pandas to unbox and dispatch to us.
-                return NotImplemented
-
-            other = lib.item_from_zerodim(other)
             mask = None
 
+            if getattr(other, "ndim", 0) > 1:
+                raise NotImplementedError("can only perform ops with 1-d structures")
+
             if isinstance(other, IntegerArray):
                 other, mask = other._data, other._mask
 
diff --git a/pandas/core/arrays/period.py b/pandas/core/arrays/period.py
index 78cc54db4..fdf4059fa 100644
--- a/pandas/core/arrays/period.py
+++ b/pandas/core/arrays/period.py
@@ -4,7 +4,6 @@ from typing import Any, Callable, List, Optional, Sequence, Union
 
 import numpy as np
 
-from pandas._libs import lib
 from pandas._libs.tslibs import (
     NaT,
     NaTType,
@@ -35,7 +34,6 @@ from pandas.core.dtypes.common import (
 )
 from pandas.core.dtypes.dtypes import PeriodDtype
 from pandas.core.dtypes.generic import (
-    ABCDataFrame,
     ABCIndexClass,
     ABCPeriodArray,
     ABCPeriodIndex,
@@ -46,6 +44,7 @@ from pandas.core.dtypes.missing import isna, notna
 import pandas.core.algorithms as algos
 from pandas.core.arrays import datetimelike as dtl
 import pandas.core.common as com
+from pandas.core.ops.common import unpack_zerodim_and_defer
 
 from pandas.tseries import frequencies
 from pandas.tseries.offsets import DateOffset, Tick, _delta_to_tick
@@ -69,13 +68,10 @@ def _period_array_cmp(cls, op):
     opname = "__{name}__".format(name=op.__name__)
     nat_result = opname == "__ne__"
 
+    @unpack_zerodim_and_defer(opname)
     def wrapper(self, other):
         ordinal_op = getattr(self.asi8, opname)
 
-        other = lib.item_from_zerodim(other)
-        if isinstance(other, (ABCDataFrame, ABCSeries, ABCIndexClass)):
-            return NotImplemented
-
         if is_list_like(other) and len(other) != len(self):
             raise ValueError("Lengths must match")
 
diff --git a/pandas/core/arrays/sparse/array.py b/pandas/core/arrays/sparse/array.py
index 14024401e..943dea425 100644
--- a/pandas/core/arrays/sparse/array.py
+++ b/pandas/core/arrays/sparse/array.py
@@ -34,12 +34,7 @@ from pandas.core.dtypes.common import (
     is_string_dtype,
     pandas_dtype,
 )
-from pandas.core.dtypes.generic import (
-    ABCDataFrame,
-    ABCIndexClass,
-    ABCSeries,
-    ABCSparseArray,
-)
+from pandas.core.dtypes.generic import ABCIndexClass, ABCSeries, ABCSparseArray
 from pandas.core.dtypes.missing import isna, na_value_for_dtype, notna
 
 import pandas.core.algorithms as algos
@@ -49,6 +44,7 @@ import pandas.core.common as com
 from pandas.core.construction import sanitize_array
 from pandas.core.missing import interpolate_2d
 import pandas.core.ops as ops
+from pandas.core.ops.common import unpack_zerodim_and_defer
 
 import pandas.io.formats.printing as printing
 
@@ -1410,12 +1406,8 @@ class SparseArray(PandasObject, ExtensionArray, ExtensionOpsMixin):
     def _create_arithmetic_method(cls, op):
         op_name = op.__name__
 
+        @unpack_zerodim_and_defer(op_name)
         def sparse_arithmetic_method(self, other):
-            if isinstance(other, (ABCDataFrame, ABCSeries, ABCIndexClass)):
-                # Rely on pandas to dispatch to us.
-                return NotImplemented
-
-            other = lib.item_from_zerodim(other)
 
             if isinstance(other, SparseArray):
                 return _sparse_array_op(self, other, op, op_name)
@@ -1463,12 +1455,9 @@ class SparseArray(PandasObject, ExtensionArray, ExtensionOpsMixin):
         if op_name in {"and_", "or_"}:
             op_name = op_name[:-1]
 
+        @unpack_zerodim_and_defer(op_name)
         def cmp_method(self, other):
 
-            if isinstance(other, (ABCSeries, ABCIndexClass)):
-                # Rely on pandas to unbox and dispatch to us.
-                return NotImplemented
-
             if not is_scalar(other) and not isinstance(other, type(self)):
                 # convert list-like to ndarray
                 other = np.asarray(other)
diff --git a/pandas/core/arrays/timedeltas.py b/pandas/core/arrays/timedeltas.py
index 21e07b510..816beb758 100644
--- a/pandas/core/arrays/timedeltas.py
+++ b/pandas/core/arrays/timedeltas.py
@@ -45,6 +45,7 @@ from pandas.core.dtypes.missing import isna
 from pandas.core import nanops
 from pandas.core.algorithms import checked_add_with_arr
 import pandas.core.common as com
+from pandas.core.ops.common import unpack_zerodim_and_defer
 from pandas.core.ops.invalid import invalid_comparison
 
 from pandas.tseries.frequencies import to_offset
@@ -82,10 +83,8 @@ def _td_array_cmp(cls, op):
     opname = "__{name}__".format(name=op.__name__)
     nat_result = opname == "__ne__"
 
+    @unpack_zerodim_and_defer(opname)
     def wrapper(self, other):
-        other = lib.item_from_zerodim(other)
-        if isinstance(other, (ABCDataFrame, ABCSeries, ABCIndexClass)):
-            return NotImplemented
 
         if _is_convertible_to_td(other) or other is NaT:
             try:
diff --git a/pandas/core/indexes/range.py b/pandas/core/indexes/range.py
index 0fe0fe5a4..6f806c5ba 100644
--- a/pandas/core/indexes/range.py
+++ b/pandas/core/indexes/range.py
@@ -21,7 +21,7 @@ from pandas.core.dtypes.common import (
     is_scalar,
     is_timedelta64_dtype,
 )
-from pandas.core.dtypes.generic import ABCDataFrame, ABCSeries, ABCTimedeltaIndex
+from pandas.core.dtypes.generic import ABCTimedeltaIndex
 
 from pandas.core import ops
 import pandas.core.common as com
@@ -29,6 +29,7 @@ from pandas.core.construction import extract_array
 import pandas.core.indexes.base as ibase
 from pandas.core.indexes.base import Index, _index_shared_docs
 from pandas.core.indexes.numeric import Int64Index
+from pandas.core.ops.common import unpack_zerodim_and_defer
 
 from pandas.io.formats.printing import pprint_thing
 
@@ -731,9 +732,8 @@ class RangeIndex(Int64Index):
         # fall back to Int64Index
         return super().__getitem__(key)
 
+    @unpack_zerodim_and_defer("__floordiv__")
     def __floordiv__(self, other):
-        if isinstance(other, (ABCSeries, ABCDataFrame)):
-            return NotImplemented
 
         if is_integer(other) and other != 0:
             if len(self) == 0 or self.start % other == 0 and self.step % other == 0:
@@ -769,10 +769,9 @@ class RangeIndex(Int64Index):
                 if False, use the existing step
             """
 
+            @unpack_zerodim_and_defer(op.__name__)
             def _evaluate_numeric_binop(self, other):
-                if isinstance(other, (ABCSeries, ABCDataFrame)):
-                    return NotImplemented
-                elif isinstance(other, ABCTimedeltaIndex):
+                if isinstance(other, ABCTimedeltaIndex):
                     # Defer to TimedeltaIndex implementation
                     return NotImplemented
                 elif isinstance(other, (timedelta, np.timedelta64)):
diff --git a/pandas/core/ops/__init__.py b/pandas/core/ops/__init__.py
index 398fa9b0c..f7a125889 100644
--- a/pandas/core/ops/__init__.py
+++ b/pandas/core/ops/__init__.py
@@ -29,6 +29,7 @@ from pandas.core.ops.array_ops import (
     logical_op,
 )
 from pandas.core.ops.array_ops import comp_method_OBJECT_ARRAY  # noqa:F401
+from pandas.core.ops.common import unpack_zerodim_and_defer
 from pandas.core.ops.dispatch import maybe_dispatch_ufunc_to_dunder_op  # noqa:F401
 from pandas.core.ops.dispatch import should_series_dispatch
 from pandas.core.ops.docstrings import (
@@ -489,9 +490,8 @@ def _arith_method_SERIES(cls, op, special):
     op_name = _get_op_name(op, special)
     eval_kwargs = _gen_eval_kwargs(op_name)
 
+    @unpack_zerodim_and_defer(op_name)
     def wrapper(left, right):
-        if isinstance(right, ABCDataFrame):
-            return NotImplemented
 
         left, right = _align_method_SERIES(left, right)
         res_name = get_op_result_name(left, right)
@@ -512,14 +512,11 @@ def _comp_method_SERIES(cls, op, special):
     """
     op_name = _get_op_name(op, special)
 
+    @unpack_zerodim_and_defer(op_name)
     def wrapper(self, other):
 
         res_name = get_op_result_name(self, other)
 
-        if isinstance(other, ABCDataFrame):  # pragma: no cover
-            # Defer to DataFrame implementation; fail early
-            return NotImplemented
-
         if isinstance(other, ABCSeries) and not self._indexed_same(other):
             raise ValueError("Can only compare identically-labeled Series objects")
 
@@ -541,14 +538,11 @@ def _bool_method_SERIES(cls, op, special):
     """
     op_name = _get_op_name(op, special)
 
+    @unpack_zerodim_and_defer(op_name)
     def wrapper(self, other):
         self, other = _align_method_SERIES(self, other, align_asobject=True)
         res_name = get_op_result_name(self, other)
 
-        if isinstance(other, ABCDataFrame):
-            # Defer to DataFrame implementation; fail early
-            return NotImplemented
-
         lvalues = extract_array(self, extract_numpy=True)
         rvalues = extract_array(other, extract_numpy=True)
 
diff --git a/pandas/core/ops/common.py b/pandas/core/ops/common.py
new file mode 100644
index 000000000..f4b16cf4a
--- /dev/null
+++ b/pandas/core/ops/common.py
@@ -0,0 +1,66 @@
+"""
+Boilerplate functions used in defining binary operations.
+"""
+from functools import wraps
+
+from pandas._libs.lib import item_from_zerodim
+
+from pandas.core.dtypes.generic import ABCDataFrame, ABCIndexClass, ABCSeries
+
+
+def unpack_zerodim_and_defer(name: str):
+    """
+    Boilerplate for pandas conventions in arithmetic and comparison methods.
+
+    Parameters
+    ----------
+    name : str
+
+    Returns
+    -------
+    decorator
+    """
+
+    def wrapper(method):
+        return _unpack_zerodim_and_defer(method, name)
+
+    return wrapper
+
+
+def _unpack_zerodim_and_defer(method, name: str):
+    """
+    Boilerplate for pandas conventions in arithmetic and comparison methods.
+
+    Ensure method returns NotImplemented when operating against "senior"
+    classes.  Ensure zero-dimensional ndarrays are always unpacked.
+
+    Parameters
+    ----------
+    method : binary method
+    name : str
+
+    Returns
+    -------
+    method
+    """
+
+    is_cmp = name.strip("__") in {"eq", "ne", "lt", "le", "gt", "ge"}
+
+    @wraps(method)
+    def new_method(self, other):
+
+        if is_cmp and isinstance(self, ABCIndexClass) and isinstance(other, ABCSeries):
+            # For comparison ops, Index does *not* defer to Series
+            pass
+        else:
+            for cls in [ABCDataFrame, ABCSeries, ABCIndexClass]:
+                if isinstance(self, cls):
+                    break
+                if isinstance(other, cls):
+                    return NotImplemented
+
+        other = item_from_zerodim(other)
+
+        return method(self, other)
+
+    return new_method
diff --git a/pandas/tests/arithmetic/test_datetime64.py b/pandas/tests/arithmetic/test_datetime64.py
index 4d3d6e2df..1ba0930c0 100644
--- a/pandas/tests/arithmetic/test_datetime64.py
+++ b/pandas/tests/arithmetic/test_datetime64.py
@@ -1029,6 +1029,7 @@ class TestDatetime64Arithmetic:
             [
                 "unsupported operand type",
                 "cannot (add|subtract)",
+                "cannot use operands with types",
                 "ufunc '?(add|subtract)'? cannot use operands with types",
             ]
         )

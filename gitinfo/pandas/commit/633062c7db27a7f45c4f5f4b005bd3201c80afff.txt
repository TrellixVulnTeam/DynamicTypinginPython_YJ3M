commit 633062c7db27a7f45c4f5f4b005bd3201c80afff
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Jul 26 23:06:15 2011 -0400

    ENH: multi-grouping using functions works too

diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 3aa05bb9d..613b764de 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -54,7 +54,7 @@ class GroupBy(object):
         try:
             return get(attr)
         except AttributeError:
-            if hasattr(type(self.obj), attr):
+            if hasattr(self.obj, attr):
                 return self._make_wrapper(attr)
             raise
 
@@ -278,12 +278,17 @@ class Grouping(object):
         self.index = np.asarray(index)
         self.grouper = _convert_grouper(index, grouper)
 
-        # eager beaver
-        if isinstance(self.grouper, np.ndarray):
-            self.indices = _tseries.groupby_indices(self.grouper)
-        else:
-            # some kind of callable
-            self.indices = _tseries.func_groupby_indices(index, self.grouper)
+        if not isinstance(self.grouper, np.ndarray):
+            self.grouper = _tseries.arrmap(self.index, self.grouper)
+
+        self.indices = _tseries.groupby_indices(self.grouper)
+
+        # # eager beaver
+        # if isinstance(self.grouper, np.ndarray):
+        #     self.indices = _tseries.groupby_indices(self.grouper)
+        # else:
+        #     # some kind of callable
+        #     self.indices = _tseries.func_groupby_indices(index, self.grouper)
 
     def __repr__(self):
         return 'Grouping(%s)' % self.name
diff --git a/pandas/src/groupby.pyx b/pandas/src/groupby.pyx
index c406dd9ff..93773b4c9 100644
--- a/pandas/src/groupby.pyx
+++ b/pandas/src/groupby.pyx
@@ -7,11 +7,11 @@ cdef inline _isnan(object o):
     return o != o
 
 @cython.boundscheck(False)
-def arrmap(ndarray[object, ndim=1] index, object func):
+def arrmap(ndarray[object] index, object func):
     cdef int length = index.shape[0]
     cdef int i = 0
 
-    cdef ndarray[object, ndim=1] result = np.empty(length, dtype=np.object_)
+    cdef ndarray[object] result = np.empty(length, dtype=np.object_)
 
     for i from 0 <= i < length:
         result[i] = func(index[i])
@@ -19,11 +19,11 @@ def arrmap(ndarray[object, ndim=1] index, object func):
     return result
 
 @cython.boundscheck(False)
-def groupby(object index, object mapper):
+def groupby_func(object index, object mapper):
     cdef dict result = {}
-    cdef ndarray[object, ndim=1] mapped_index
-    cdef ndarray[object, ndim=1] index_buf
-    cdef ndarray[int8_t, ndim=1] mask
+    cdef ndarray[object] mapped_index
+    cdef ndarray[object] index_buf
+    cdef ndarray[int8_t] mask
     cdef int i, length
     cdef list members
     cdef object idx, key
@@ -48,6 +48,32 @@ def groupby(object index, object mapper):
 
     return result
 
+@cython.boundscheck(False)
+def groupby(ndarray[object] index, ndarray[object] labels):
+    cdef dict result = {}
+    cdef ndarray[int8_t] mask
+    cdef int i, length
+    cdef list members
+    cdef object idx, key
+
+    length = len(index)
+    mask = isnullobj(labels)
+
+    for i from 0 <= i < length:
+        if mask[i]:
+            continue
+
+        key = labels[i]
+        idx = index[i]
+        if key in result:
+            members = result[key]
+            members.append(idx)
+        else:
+            result[key] = [idx]
+
+    return result
+
+
 def func_groupby_indices(object index, object mapper):
     return groupby_indices_naive(arrmap(index, mapper))
 
@@ -294,13 +320,13 @@ def _result_shape(label_list):
         shape.append(1 + labels[-1])
     return tuple(shape)
 
-def reduce_mean(ndarray[object, ndim=1] indices,
-                ndarray[object, ndim=1] buckets,
-                ndarray[double_t, ndim=1] values,
+def reduce_mean(ndarray[object] indices,
+                ndarray[object] buckets,
+                ndarray[double_t] values,
                 inclusive=False):
     cdef:
         Py_ssize_t i, j, nbuckets, nvalues
-        ndarray[double_t, ndim=1] output
+        ndarray[double_t] output
         double_t the_sum, val, nobs
 
 
@@ -353,13 +379,13 @@ def _bucket_locs(index, buckets, inclusive=False):
 
 '''
 
-def ts_upsample_mean(ndarray[object, ndim=1] indices,
-                     ndarray[object, ndim=1] buckets,
-                     ndarray[double_t, ndim=1] values,
+def ts_upsample_mean(ndarray[object] indices,
+                     ndarray[object] buckets,
+                     ndarray[double_t] values,
                      inclusive=False):
     cdef:
         Py_ssize_t i, j, nbuckets, nvalues
-        ndarray[double_t, ndim=1] output
+        ndarray[double_t] output
         object next_bound
         double_t the_sum, val, nobs
 
@@ -389,7 +415,7 @@ def ts_upsample_mean(ndarray[object, ndim=1] indices,
 
     cdef:
         Py_ssize_t i, j, nbuckets, nvalues
-        ndarray[double_t, ndim=1] output
+        ndarray[double_t] output
         object next_bound
         double_t the_sum, val, nobs
 
@@ -446,9 +472,9 @@ def ts_upsample_mean(ndarray[object, ndim=1] indices,
     return output
 '''
 
-def ts_upsample_generic(ndarray[object, ndim=1] indices,
-                        ndarray[object, ndim=1] buckets,
-                        ndarray[double_t, ndim=1] values,
+def ts_upsample_generic(ndarray[object] indices,
+                        ndarray[object] buckets,
+                        ndarray[double_t] values,
                         object aggfunc,
                         inclusive=False):
     '''
@@ -456,7 +482,7 @@ def ts_upsample_generic(ndarray[object, ndim=1] indices,
     '''
     cdef:
         Py_ssize_t i, j, jstart, nbuckets, nvalues
-        ndarray[double_t, ndim=1] output
+        ndarray[double_t] output
         object next_bound
         double_t the_sum, val, nobs
 
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index 622fa0746..17c2ed852 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -147,46 +147,6 @@ class TestGroupBy(unittest.TestCase):
         expected = Series([4, 2], index=['bar', 'foo'])
         assert_series_equal(agged, expected)
 
-    def test_multi_iter(self):
-        s = Series(np.arange(6))
-        k1 = np.array(['a', 'a', 'a', 'b', 'b', 'b'])
-        k2 = np.array(['1', '2', '1', '2', '1', '2'])
-
-        grouped = s.groupby([k1, k2])
-
-        iterated = list(grouped)
-        expected = [('a', '1', s[[0, 2]]),
-                    ('a', '2', s[[1]]),
-                    ('b', '1', s[[4]]),
-                    ('b', '2', s[[3, 5]])]
-        for i, (one, two, three) in enumerate(iterated):
-            e1, e2, e3 = expected[i]
-            self.assert_(e1 == one)
-            self.assert_(e2 == two)
-            assert_series_equal(three, e3)
-
-    def test_multi_iter_frame(self):
-        k1 = np.array(['b', 'b', 'b', 'a', 'a', 'a'])
-        k2 = np.array(['1', '2', '1', '2', '1', '2'])
-        df = DataFrame({'v1' : np.random.randn(6),
-                        'v2' : np.random.randn(6),
-                        'k1' : k1, 'k2' : k2},
-                       index=['one', 'two', 'three', 'four', 'five', 'six'])
-
-        grouped = df.groupby(['k1', 'k2'])
-
-        iterated = list(grouped)
-        idx = df.index
-        expected = [('b', '1', df.ix[idx[[0, 2]]]),
-                    ('b', '2', df.ix[idx[[1]]]),
-                    ('a', '1', df.ix[idx[[4]]]),
-                    ('a', '2', df.ix[idx[[3, 5]]])]
-        for i, (one, two, three) in enumerate(iterated):
-            e1, e2, e3 = expected[i]
-            self.assert_(e1 == one)
-            self.assert_(e2 == two)
-            assert_frame_equal(three, e3)
-
     def test_attr_wrapper(self):
         grouped = self.ts.groupby(lambda x: x.weekday())
 
@@ -279,6 +239,56 @@ class TestGroupBy(unittest.TestCase):
         self.assertEqual(len(grouped), len(self.frame.index))
         self.assertEqual(len(grouped.columns), 2)
 
+    def test_multi_iter(self):
+        s = Series(np.arange(6))
+        k1 = np.array(['a', 'a', 'a', 'b', 'b', 'b'])
+        k2 = np.array(['1', '2', '1', '2', '1', '2'])
+
+        grouped = s.groupby([k1, k2])
+
+        iterated = list(grouped)
+        expected = [('a', '1', s[[0, 2]]),
+                    ('a', '2', s[[1]]),
+                    ('b', '1', s[[4]]),
+                    ('b', '2', s[[3, 5]])]
+        for i, (one, two, three) in enumerate(iterated):
+            e1, e2, e3 = expected[i]
+            self.assert_(e1 == one)
+            self.assert_(e2 == two)
+            assert_series_equal(three, e3)
+
+    def test_multi_iter_frame(self):
+        k1 = np.array(['b', 'b', 'b', 'a', 'a', 'a'])
+        k2 = np.array(['1', '2', '1', '2', '1', '2'])
+        df = DataFrame({'v1' : np.random.randn(6),
+                        'v2' : np.random.randn(6),
+                        'k1' : k1, 'k2' : k2},
+                       index=['one', 'two', 'three', 'four', 'five', 'six'])
+
+        grouped = df.groupby(['k1', 'k2'])
+
+        iterated = list(grouped)
+        idx = df.index
+        expected = [('b', '1', df.ix[idx[[0, 2]]]),
+                    ('b', '2', df.ix[idx[[1]]]),
+                    ('a', '1', df.ix[idx[[4]]]),
+                    ('a', '2', df.ix[idx[[3, 5]]])]
+        for i, (one, two, three) in enumerate(iterated):
+            e1, e2, e3 = expected[i]
+            self.assert_(e1 == one)
+            self.assert_(e2 == two)
+            assert_frame_equal(three, e3)
+
+    def test_multi_func(self):
+        col1 = self.df['A']
+        col2 = self.df['B']
+
+        grouped = self.df.groupby([col1.get, col2.get])
+        agged = grouped.mean()
+        expected = self.df.groupby(['A', 'B']).mean()
+        assert_frame_equal(agged.ix[:, ['C', 'D']],
+                           expected.ix[:, ['C', 'D']])
+
     def test_groupby_multiple_columns(self):
         data = self.df
         grouped = data.groupby(['A', 'B'])

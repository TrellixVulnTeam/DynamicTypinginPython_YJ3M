commit c62811f97126a51efd7f8c4ad80907631e000e0a
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Jul 24 10:39:12 2011 -0400

    ENH: perf opt in Index. lazy enforcement of uniqueness, prevent unnecessary calls to map_indices

diff --git a/pandas/core/common.py b/pandas/core/common.py
index 4288d6c24..50b562fa8 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -96,6 +96,23 @@ def _infer_dtype(value):
     else:
         return object
 
+def _is_bool_indexer(key):
+    if isinstance(key, np.ndarray) and key.dtype == np.object_:
+        mask = isnull(key)
+        if mask.any():
+            raise ValueError('cannot index with vector containing '
+                             'NA / NaN values')
+        return set([True, False]).issubset(set(key))
+    elif isinstance(key, np.ndarray) and key.dtype == np.bool_:
+        return True
+    elif isinstance(key, list):
+        try:
+            return set([True, False]).issubset(set(key))
+        except TypeError:
+            return False
+
+    return False
+
 def _default_index(n):
     from pandas.core.index import NULL_INDEX
     if n == 0:
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 1a2bb0444..d3f62a5ea 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -2,7 +2,7 @@
 
 import numpy as np
 
-from pandas.core.common import _ensure_index
+from pandas.core.common import _ensure_index, _is_bool_indexer
 import pandas._tseries as _tseries
 
 __all__ = ['Index']
@@ -52,6 +52,8 @@ class Index(np.ndarray):
             return self.item()
             # raise Exception('Cannot create 0-dimensional Index!')
 
+        return
+
         # New instance creation
         if obj is None:
             pass
@@ -62,11 +64,10 @@ class Index(np.ndarray):
 
         # View casting
         else:
-            if hasattr(obj, '_cache_indexMap'):
-                self._cache_indexMap = obj._cache_indexMap
-                self._cache_allDates = getattr(obj, '_cache_allDates', None)
-
-        self._checkForDuplicates()
+            pass
+            # if hasattr(obj, '_cache_indexMap'):
+            #     self._cache_indexMap = obj._cache_indexMap
+            #     self._cache_allDates = getattr(obj, '_cache_allDates', None)
 
     def summary(self):
         if len(self) > 0:
@@ -79,6 +80,7 @@ class Index(np.ndarray):
     def indexMap(self):
         if not hasattr(self, '_cache_indexMap'):
             self._cache_indexMap = _tseries.map_indices(self)
+            self._verify_integrity()
 
         return self._cache_indexMap
 
@@ -92,7 +94,7 @@ class Index(np.ndarray):
     def is_all_dates(self):
         return self._allDates
 
-    def _checkForDuplicates(self):
+    def _verify_integrity(self):
         if len(self.indexMap) < len(self):
             raise Exception('Index cannot contain duplicate values!')
 
@@ -127,6 +129,9 @@ class Index(np.ndarray):
         if np.isscalar(key):
             return arr_idx[key]
         else:
+            if _is_bool_indexer(key):
+                key = np.asarray(key)
+
             # easier to ask forgiveness than permission
             try:
                 return Index(arr_idx[key])
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index aed38bd87..e459d7570 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -222,7 +222,7 @@ class _DataFrameIndexer(object):
                 if not key.index.equals(labels):
                     raise Exception('Cannot use boolean index with misaligned '
                                     'or unequal labels')
-            return self.frame.reindex(**{axis_name : labels[key]})
+            return self.frame.reindex(**{axis_name : labels[np.asarray(key)]})
         else:
             if _is_integer_dtype(keyarr) and _is_integer_index(labels):
                 raise AmbiguousIndexError('integer labels')
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 420be9181..bb14a1ecf 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -646,13 +646,17 @@ class BlockManager(object):
         return BlockManager(consolidated, new_axes)
 
     def rename_axis(self, mapper, axis=1):
-        new_axis = [mapper(x) for x in self.axes[axis]]
+        new_axis = Index([mapper(x) for x in self.axes[axis]])
+        new_axis._verify_integrity()
+
         new_axes = list(self.axes)
         new_axes[axis] = new_axis
         return BlockManager(self.blocks, new_axes)
 
     def rename_items(self, mapper):
         new_items = Index([mapper(x) for x in self.items])
+        new_items._verify_integrity()
+
         new_blocks = []
         for block in self.blocks:
             newb = block.copy()
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 6e3a05073..d02c3c57a 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -1555,7 +1555,8 @@ class LongPanel(Panel, Picklable):
         assert(self.index is other.index)
 
         values = np.concatenate((self.values, other.values), axis=1).copy()
-        items = self.items.tolist() + other.items.tolist()
+        items = Index(np.concatenate((self.items, other.items)))
+        items._verify_integrity()
 
         return LongPanel(values, items, self.index)
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 3807de4c3..d7bd15a05 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -13,7 +13,7 @@ import warnings
 from numpy import nan, ndarray
 import numpy as np
 
-from pandas.core.common import isnull, notnull, _ensure_index
+from pandas.core.common import isnull, notnull, _ensure_index, _is_bool_indexer
 from pandas.core.daterange import DateRange
 from pandas.core.generic import PandasObject
 from pandas.core.index import Index
@@ -293,9 +293,6 @@ class Series(np.ndarray, PandasObject):
                 raise Exception('can only boolean index with like-indexed '
                                 'Series or raw ndarrays')
 
-        # TODO: [slice(0, 5, None)] will break if you convert to ndarray,
-        # e.g. as requested by np.median
-
         def _index_with(indexer):
             return Series(values[indexer], index=self.index[indexer])
 
@@ -306,6 +303,10 @@ class Series(np.ndarray, PandasObject):
             key = np.asarray(key, dtype=bool)
             return _index_with(key)
 
+
+        # TODO: [slice(0, 5, None)] will break if you convert to ndarray,
+        # e.g. as requested by np.median
+
         try:
             return _index_with(key)
         except Exception:
@@ -735,12 +736,8 @@ class Series(np.ndarray, PandasObject):
         y : Series
         """
         newIndex = np.concatenate((self.index, other.index))
-
-        # Force overlap check
-        try:
-            newIndex = Index(newIndex)
-        except Exception:
-            raise
+        newIndex = Index(newIndex)
+        newIndex._verify_integrity()
 
         new_values = np.concatenate((self, other))
         return Series(new_values, index=newIndex)
@@ -1441,15 +1438,6 @@ class TimeSeries(Series):
 #-------------------------------------------------------------------------------
 # Supplementary functions
 
-def _is_bool_indexer(key):
-    if isinstance(key, np.ndarray) and key.dtype == np.object_:
-        mask = isnull(key)
-        if mask.any():
-            raise ValueError('cannot index with vector containing '
-                             'NA / NaN values')
-
-        return set([True, False]).issubset(set(key))
-    return False
 
 _ndgi = ndarray.__getitem__
 
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 01bc9f735..136d59480 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -26,7 +26,8 @@ class TestIndex(unittest.TestCase):
         self.assert_(copy is self.strIndex)
 
     def test_duplicates(self):
-        self.assertRaises(Exception, Index, [0, 0, 0])
+        idx = Index([0, 0, 0])
+        self.assertRaises(Exception, idx._verify_integrity)
 
     def test_sort(self):
         self.assertRaises(Exception, self.strIndex.sort)

commit fa557f7391589f351b1260f46b3b3db22492f50b
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Wed Sep 13 16:20:53 2017 -0700

    De-privatize timezone funcs (#17502)

diff --git a/pandas/_libs/index.pyx b/pandas/_libs/index.pyx
index bf4d53683..884117799 100644
--- a/pandas/_libs/index.pyx
+++ b/pandas/_libs/index.pyx
@@ -17,7 +17,7 @@ cimport tslib
 
 from hashtable cimport HashTable
 
-from tslibs.timezones cimport _is_utc
+from tslibs.timezones cimport is_utc, get_utcoffset
 from pandas._libs import tslib, algos, hashtable as _hash
 from pandas._libs.tslib import Timestamp, Timedelta
 from datetime import datetime, timedelta
@@ -551,8 +551,8 @@ cdef inline _to_i8(object val):
             tzinfo = getattr(val, 'tzinfo', None)
             # Save the original date value so we can get the utcoffset from it.
             ival = _pydatetime_to_dts(val, &dts)
-            if tzinfo is not None and not _is_utc(tzinfo):
-                offset = tslib._get_utcoffset(tzinfo, val)
+            if tzinfo is not None and not is_utc(tzinfo):
+                offset = get_utcoffset(tzinfo, val)
                 ival -= tslib._delta_to_nanoseconds(offset)
             return ival
         return val
diff --git a/pandas/_libs/period.pyx b/pandas/_libs/period.pyx
index 2b0734f5c..9e473a7f3 100644
--- a/pandas/_libs/period.pyx
+++ b/pandas/_libs/period.pyx
@@ -34,7 +34,7 @@ from lib cimport is_null_datetimelike, is_period
 from pandas._libs import tslib, lib
 from pandas._libs.tslib import (Timedelta, Timestamp, iNaT,
                                 NaT)
-from tslibs.timezones cimport _is_utc, _is_tzlocal, _get_utcoffset
+from tslibs.timezones cimport is_utc, is_tzlocal, get_utcoffset
 from tslib cimport (
     maybe_get_tz,
     _get_dst_info,
@@ -533,7 +533,7 @@ cdef _reso_local(ndarray[int64_t] stamps, object tz):
         ndarray[int64_t] trans, deltas, pos
         pandas_datetimestruct dts
 
-    if _is_utc(tz):
+    if is_utc(tz):
         for i in range(n):
             if stamps[i] == NPY_NAT:
                 continue
@@ -541,7 +541,7 @@ cdef _reso_local(ndarray[int64_t] stamps, object tz):
             curr_reso = _reso_stamp(&dts)
             if curr_reso < reso:
                 reso = curr_reso
-    elif _is_tzlocal(tz):
+    elif is_tzlocal(tz):
         for i in range(n):
             if stamps[i] == NPY_NAT:
                 continue
@@ -549,7 +549,7 @@ cdef _reso_local(ndarray[int64_t] stamps, object tz):
                                               &dts)
             dt = datetime(dts.year, dts.month, dts.day, dts.hour,
                           dts.min, dts.sec, dts.us, tz)
-            delta = int(_get_utcoffset(tz, dt).total_seconds()) * 1000000000
+            delta = int(get_utcoffset(tz, dt).total_seconds()) * 1000000000
             pandas_datetime_to_datetimestruct(stamps[i] + delta,
                                               PANDAS_FR_ns, &dts)
             curr_reso = _reso_stamp(&dts)
@@ -597,7 +597,7 @@ cdef ndarray[int64_t] localize_dt64arr_to_period(ndarray[int64_t] stamps,
         ndarray[int64_t] trans, deltas, pos
         pandas_datetimestruct dts
 
-    if _is_utc(tz):
+    if is_utc(tz):
         for i in range(n):
             if stamps[i] == NPY_NAT:
                 result[i] = NPY_NAT
@@ -607,7 +607,7 @@ cdef ndarray[int64_t] localize_dt64arr_to_period(ndarray[int64_t] stamps,
                                            dts.hour, dts.min, dts.sec,
                                            dts.us, dts.ps, freq)
 
-    elif _is_tzlocal(tz):
+    elif is_tzlocal(tz):
         for i in range(n):
             if stamps[i] == NPY_NAT:
                 result[i] = NPY_NAT
@@ -616,7 +616,7 @@ cdef ndarray[int64_t] localize_dt64arr_to_period(ndarray[int64_t] stamps,
                                               &dts)
             dt = datetime(dts.year, dts.month, dts.day, dts.hour,
                           dts.min, dts.sec, dts.us, tz)
-            delta = int(_get_utcoffset(tz, dt).total_seconds()) * 1000000000
+            delta = int(get_utcoffset(tz, dt).total_seconds()) * 1000000000
             pandas_datetime_to_datetimestruct(stamps[i] + delta,
                                               PANDAS_FR_ns, &dts)
             result[i] = get_period_ordinal(dts.year, dts.month, dts.day,
diff --git a/pandas/_libs/src/inference.pyx b/pandas/_libs/src/inference.pyx
index 95145ff49..2bb362eab 100644
--- a/pandas/_libs/src/inference.pyx
+++ b/pandas/_libs/src/inference.pyx
@@ -3,7 +3,7 @@ from decimal import Decimal
 cimport util
 cimport cython
 from tslib import NaT
-from tslibs.timezones cimport _get_zone
+from tslibs.timezones cimport get_timezone
 from datetime import datetime, timedelta
 iNaT = util.get_nat()
 
@@ -901,13 +901,13 @@ cpdef bint is_datetime_with_singletz_array(ndarray[object] values):
     for i in range(n):
         base_val = values[i]
         if base_val is not NaT:
-            base_tz = _get_zone(getattr(base_val, 'tzinfo', None))
+            base_tz = get_timezone(getattr(base_val, 'tzinfo', None))
 
             for j in range(i, n):
                 val = values[j]
                 if val is not NaT:
                     tz = getattr(val, 'tzinfo', None)
-                    if base_tz != tz and base_tz != _get_zone(tz):
+                    if base_tz != tz and base_tz != get_timezone(tz):
                         return False
             break
 
diff --git a/pandas/_libs/tslib.pyx b/pandas/_libs/tslib.pyx
index a8ae0fcd7..629325c28 100644
--- a/pandas/_libs/tslib.pyx
+++ b/pandas/_libs/tslib.pyx
@@ -108,11 +108,11 @@ iNaT = NPY_NAT
 
 
 from tslibs.timezones cimport (
-    _is_utc, _is_tzlocal,
-    _treat_tz_as_dateutil, _treat_tz_as_pytz,
-    _get_zone,
-    _get_utcoffset)
-from tslibs.timezones import get_timezone, _get_utcoffset  # noqa
+    is_utc, is_tzlocal,
+    treat_tz_as_dateutil, treat_tz_as_pytz,
+    get_timezone,
+    get_utcoffset)
+from tslibs.timezones import get_timezone, get_utcoffset  # noqa
 
 
 cdef inline object create_timestamp_from_ts(
@@ -160,7 +160,7 @@ def ints_to_pydatetime(ndarray[int64_t] arr, tz=None, freq=None, box=False):
         func_create = create_datetime_from_ts
 
     if tz is not None:
-        if _is_utc(tz):
+        if is_utc(tz):
             for i in range(n):
                 value = arr[i]
                 if value == NPY_NAT:
@@ -169,7 +169,7 @@ def ints_to_pydatetime(ndarray[int64_t] arr, tz=None, freq=None, box=False):
                     pandas_datetime_to_datetimestruct(
                         value, PANDAS_FR_ns, &dts)
                     result[i] = func_create(value, dts, tz, freq)
-        elif _is_tzlocal(tz) or _is_fixed_offset(tz):
+        elif is_tzlocal(tz) or _is_fixed_offset(tz):
             for i in range(n):
                 value = arr[i]
                 if value == NPY_NAT:
@@ -194,7 +194,7 @@ def ints_to_pydatetime(ndarray[int64_t] arr, tz=None, freq=None, box=False):
 
                     # Adjust datetime64 timestamp, recompute datetimestruct
                     pos = trans.searchsorted(value, side='right') - 1
-                    if _treat_tz_as_pytz(tz):
+                    if treat_tz_as_pytz(tz):
                         # find right representation of dst etc in pytz timezone
                         new_tz = tz._tzinfos[tz._transition_info[pos]]
                     else:
@@ -242,12 +242,12 @@ def ints_to_pytimedelta(ndarray[int64_t] arr, box=False):
 
 
 cdef inline bint _is_fixed_offset(object tz):
-    if _treat_tz_as_dateutil(tz):
+    if treat_tz_as_dateutil(tz):
         if len(tz._trans_idx) == 0 and len(tz._trans_list) == 0:
             return 1
         else:
             return 0
-    elif _treat_tz_as_pytz(tz):
+    elif treat_tz_as_pytz(tz):
         if (len(tz._transition_info) == 0
             and len(tz._utc_transition_times) == 0):
             return 1
@@ -1107,12 +1107,12 @@ cdef class _Timestamp(datetime):
         try:
             stamp += self.strftime('%z')
             if self.tzinfo:
-                zone = _get_zone(self.tzinfo)
+                zone = get_timezone(self.tzinfo)
         except ValueError:
             year2000 = self.replace(year=2000)
             stamp += year2000.strftime('%z')
             if self.tzinfo:
-                zone = _get_zone(self.tzinfo)
+                zone = get_timezone(self.tzinfo)
 
         try:
             stamp += zone.strftime(' %%Z')
@@ -1272,7 +1272,7 @@ cdef class _Timestamp(datetime):
         cdef:
             int64_t val
         val = self.value
-        if self.tz is not None and not _is_utc(self.tz):
+        if self.tz is not None and not is_utc(self.tz):
             val = tz_convert_single(self.value, 'UTC', self.tz)
         return val
 
@@ -1510,14 +1510,14 @@ cdef convert_to_tsobject(object ts, object tz, object unit,
                     except:
                         pass
                     obj.value = _pydatetime_to_dts(ts, &obj.dts)
-                    ts_offset = _get_utcoffset(ts.tzinfo, ts)
+                    ts_offset = get_utcoffset(ts.tzinfo, ts)
                     obj.value -= _delta_to_nanoseconds(ts_offset)
-                    tz_offset = _get_utcoffset(tz, ts)
+                    tz_offset = get_utcoffset(tz, ts)
                     obj.value += _delta_to_nanoseconds(tz_offset)
                     pandas_datetime_to_datetimestruct(obj.value,
                                                       PANDAS_FR_ns, &obj.dts)
                     obj.tzinfo = tz
-            elif not _is_utc(tz):
+            elif not is_utc(tz):
                 ts = _localize_pydatetime(ts, tz)
                 obj.value = _pydatetime_to_dts(ts, &obj.dts)
                 obj.tzinfo = ts.tzinfo
@@ -1529,8 +1529,8 @@ cdef convert_to_tsobject(object ts, object tz, object unit,
             obj.value = _pydatetime_to_dts(ts, &obj.dts)
             obj.tzinfo = ts.tzinfo
 
-        if obj.tzinfo is not None and not _is_utc(obj.tzinfo):
-            offset = _get_utcoffset(obj.tzinfo, ts)
+        if obj.tzinfo is not None and not is_utc(obj.tzinfo):
+            offset = get_utcoffset(obj.tzinfo, ts)
             obj.value -= _delta_to_nanoseconds(offset)
 
         if is_timestamp(ts):
@@ -1641,13 +1641,13 @@ cdef inline void _localize_tso(_TSObject obj, object tz):
     """
     Take a TSObject in UTC and localizes to timezone tz.
     """
-    if _is_utc(tz):
+    if is_utc(tz):
         obj.tzinfo = tz
-    elif _is_tzlocal(tz):
+    elif is_tzlocal(tz):
         pandas_datetime_to_datetimestruct(obj.value, PANDAS_FR_ns, &obj.dts)
         dt = datetime(obj.dts.year, obj.dts.month, obj.dts.day, obj.dts.hour,
                       obj.dts.min, obj.dts.sec, obj.dts.us, tz)
-        delta = int(_get_utcoffset(tz, dt).total_seconds()) * 1000000000
+        delta = int(get_utcoffset(tz, dt).total_seconds()) * 1000000000
         if obj.value != NPY_NAT:
             pandas_datetime_to_datetimestruct(obj.value + delta,
                                               PANDAS_FR_ns, &obj.dts)
@@ -1671,7 +1671,7 @@ cdef inline void _localize_tso(_TSObject obj, object tz):
                 pandas_datetime_to_datetimestruct(
                     obj.value, PANDAS_FR_ns, &obj.dts)
             obj.tzinfo = tz
-        elif _treat_tz_as_pytz(tz):
+        elif treat_tz_as_pytz(tz):
             inf = tz._transition_info[pos]
             if obj.value != NPY_NAT:
                 pandas_datetime_to_datetimestruct(obj.value + deltas[pos],
@@ -1680,7 +1680,7 @@ cdef inline void _localize_tso(_TSObject obj, object tz):
                 pandas_datetime_to_datetimestruct(obj.value,
                                                   PANDAS_FR_ns, &obj.dts)
             obj.tzinfo = tz._tzinfos[inf]
-        elif _treat_tz_as_dateutil(tz):
+        elif treat_tz_as_dateutil(tz):
             if obj.value != NPY_NAT:
                 pandas_datetime_to_datetimestruct(obj.value + deltas[pos],
                                                   PANDAS_FR_ns, &obj.dts)
@@ -1770,10 +1770,10 @@ def datetime_to_datetime64(ndarray[object] values):
         elif PyDateTime_Check(val):
             if val.tzinfo is not None:
                 if inferred_tz is not None:
-                    if _get_zone(val.tzinfo) != inferred_tz:
+                    if get_timezone(val.tzinfo) != inferred_tz:
                         raise ValueError('Array must be all same time zone')
                 else:
-                    inferred_tz = _get_zone(val.tzinfo)
+                    inferred_tz = get_timezone(val.tzinfo)
 
                 _ts = convert_to_tsobject(val, None, None, 0, 0)
                 iresult[i] = _ts.value
@@ -4088,9 +4088,9 @@ def tz_convert(ndarray[int64_t] vals, object tz1, object tz2):
         return np.array([], dtype=np.int64)
 
     # Convert to UTC
-    if _get_zone(tz1) != 'UTC':
+    if get_timezone(tz1) != 'UTC':
         utc_dates = np.empty(n, dtype=np.int64)
-        if _is_tzlocal(tz1):
+        if is_tzlocal(tz1):
             for i in range(n):
                 v = vals[i]
                 if v == NPY_NAT:
@@ -4099,7 +4099,7 @@ def tz_convert(ndarray[int64_t] vals, object tz1, object tz2):
                     pandas_datetime_to_datetimestruct(v, PANDAS_FR_ns, &dts)
                     dt = datetime(dts.year, dts.month, dts.day, dts.hour,
                                   dts.min, dts.sec, dts.us, tz1)
-                    delta = (int(_get_utcoffset(tz1, dt).total_seconds())
+                    delta = (int(get_utcoffset(tz1, dt).total_seconds())
                              * 1000000000)
                     utc_dates[i] = v - delta
         else:
@@ -4126,11 +4126,11 @@ def tz_convert(ndarray[int64_t] vals, object tz1, object tz2):
     else:
         utc_dates = vals
 
-    if _get_zone(tz2) == 'UTC':
+    if get_timezone(tz2) == 'UTC':
         return utc_dates
 
     result = np.zeros(n, dtype=np.int64)
-    if _is_tzlocal(tz2):
+    if is_tzlocal(tz2):
         for i in range(n):
             v = utc_dates[i]
             if v == NPY_NAT:
@@ -4139,7 +4139,7 @@ def tz_convert(ndarray[int64_t] vals, object tz1, object tz2):
                 pandas_datetime_to_datetimestruct(v, PANDAS_FR_ns, &dts)
                 dt = datetime(dts.year, dts.month, dts.day, dts.hour,
                               dts.min, dts.sec, dts.us, tz2)
-                delta = (int(_get_utcoffset(tz2, dt).total_seconds())
+                delta = (int(get_utcoffset(tz2, dt).total_seconds())
                              * 1000000000)
                 result[i] = v + delta
         return result
@@ -4202,13 +4202,13 @@ def tz_convert_single(int64_t val, object tz1, object tz2):
         return val
 
     # Convert to UTC
-    if _is_tzlocal(tz1):
+    if is_tzlocal(tz1):
         pandas_datetime_to_datetimestruct(val, PANDAS_FR_ns, &dts)
         dt = datetime(dts.year, dts.month, dts.day, dts.hour,
                       dts.min, dts.sec, dts.us, tz1)
-        delta = int(_get_utcoffset(tz1, dt).total_seconds()) * 1000000000
+        delta = int(get_utcoffset(tz1, dt).total_seconds()) * 1000000000
         utc_date = val - delta
-    elif _get_zone(tz1) != 'UTC':
+    elif get_timezone(tz1) != 'UTC':
         trans, deltas, typ = _get_dst_info(tz1)
         pos = trans.searchsorted(val, side='right') - 1
         if pos < 0:
@@ -4218,13 +4218,13 @@ def tz_convert_single(int64_t val, object tz1, object tz2):
     else:
         utc_date = val
 
-    if _get_zone(tz2) == 'UTC':
+    if get_timezone(tz2) == 'UTC':
         return utc_date
-    if _is_tzlocal(tz2):
+    if is_tzlocal(tz2):
         pandas_datetime_to_datetimestruct(val, PANDAS_FR_ns, &dts)
         dt = datetime(dts.year, dts.month, dts.day, dts.hour,
                       dts.min, dts.sec, dts.us, tz2)
-        delta = int(_get_utcoffset(tz2, dt).total_seconds()) * 1000000000
+        delta = int(get_utcoffset(tz2, dt).total_seconds()) * 1000000000
         return utc_date + delta
 
     # Convert UTC to other timezone
@@ -4289,13 +4289,13 @@ cdef object _get_dst_info(object tz):
     """
     cache_key = _tz_cache_key(tz)
     if cache_key is None:
-        num = int(_get_utcoffset(tz, None).total_seconds()) * 1000000000
+        num = int(get_utcoffset(tz, None).total_seconds()) * 1000000000
         return (np.array([NPY_NAT + 1], dtype=np.int64),
                 np.array([num], dtype=np.int64),
                 None)
 
     if cache_key not in dst_cache:
-        if _treat_tz_as_pytz(tz):
+        if treat_tz_as_pytz(tz):
             trans = np.array(tz._utc_transition_times, dtype='M8[ns]')
             trans = trans.view('i8')
             try:
@@ -4306,7 +4306,7 @@ cdef object _get_dst_info(object tz):
             deltas = _unbox_utcoffsets(tz._transition_info)
             typ = 'pytz'
 
-        elif _treat_tz_as_dateutil(tz):
+        elif treat_tz_as_dateutil(tz):
             if len(tz._trans_list):
                 # get utc trans times
                 trans_list = _get_utc_trans_times_from_dateutil_tz(tz)
@@ -4336,7 +4336,7 @@ cdef object _get_dst_info(object tz):
         else:
             # static tzinfo
             trans = np.array([NPY_NAT + 1], dtype=np.int64)
-            num = int(_get_utcoffset(tz, None).total_seconds()) * 1000000000
+            num = int(get_utcoffset(tz, None).total_seconds()) * 1000000000
             deltas = np.array([num], dtype=np.int64)
             typ = 'static'
 
@@ -4405,13 +4405,13 @@ def tz_localize_to_utc(ndarray[int64_t] vals, object tz, object ambiguous=None,
 
     result = np.empty(n, dtype=np.int64)
 
-    if _is_tzlocal(tz):
+    if is_tzlocal(tz):
         for i in range(n):
             v = vals[i]
             pandas_datetime_to_datetimestruct(v, PANDAS_FR_ns, &dts)
             dt = datetime(dts.year, dts.month, dts.day, dts.hour,
                           dts.min, dts.sec, dts.us, tz)
-            delta = int(_get_utcoffset(tz, dt).total_seconds()) * 1000000000
+            delta = int(get_utcoffset(tz, dt).total_seconds()) * 1000000000
             result[i] = v - delta
         return result
 
@@ -5116,7 +5116,7 @@ cdef _normalize_local(ndarray[int64_t] stamps, object tz):
         ndarray[int64_t] trans, deltas, pos
         pandas_datetimestruct dts
 
-    if _is_utc(tz):
+    if is_utc(tz):
         with nogil:
             for i in range(n):
                 if stamps[i] == NPY_NAT:
@@ -5125,7 +5125,7 @@ cdef _normalize_local(ndarray[int64_t] stamps, object tz):
                 pandas_datetime_to_datetimestruct(
                     stamps[i], PANDAS_FR_ns, &dts)
                 result[i] = _normalized_stamp(&dts)
-    elif _is_tzlocal(tz):
+    elif is_tzlocal(tz):
         for i in range(n):
             if stamps[i] == NPY_NAT:
                 result[i] = NPY_NAT
@@ -5133,7 +5133,7 @@ cdef _normalize_local(ndarray[int64_t] stamps, object tz):
             pandas_datetime_to_datetimestruct(stamps[i], PANDAS_FR_ns, &dts)
             dt = datetime(dts.year, dts.month, dts.day, dts.hour,
                           dts.min, dts.sec, dts.us, tz)
-            delta = int(_get_utcoffset(tz, dt).total_seconds()) * 1000000000
+            delta = int(get_utcoffset(tz, dt).total_seconds()) * 1000000000
             pandas_datetime_to_datetimestruct(stamps[i] + delta,
                                               PANDAS_FR_ns, &dts)
             result[i] = _normalized_stamp(&dts)
@@ -5180,12 +5180,12 @@ def dates_normalized(ndarray[int64_t] stamps, tz=None):
         Py_ssize_t i, n = len(stamps)
         pandas_datetimestruct dts
 
-    if tz is None or _is_utc(tz):
+    if tz is None or is_utc(tz):
         for i in range(n):
             pandas_datetime_to_datetimestruct(stamps[i], PANDAS_FR_ns, &dts)
             if (dts.hour + dts.min + dts.sec + dts.us) > 0:
                 return False
-    elif _is_tzlocal(tz):
+    elif is_tzlocal(tz):
         for i in range(n):
             pandas_datetime_to_datetimestruct(stamps[i], PANDAS_FR_ns, &dts)
             dt = datetime(dts.year, dts.month, dts.day, dts.hour, dts.min,
diff --git a/pandas/_libs/tslibs/timezones.pxd b/pandas/_libs/tslibs/timezones.pxd
index 897bd8af7..ead556644 100644
--- a/pandas/_libs/tslibs/timezones.pxd
+++ b/pandas/_libs/tslibs/timezones.pxd
@@ -1,12 +1,12 @@
 # -*- coding: utf-8 -*-
 # cython: profile=False
 
-cdef bint _is_utc(object tz)
-cdef bint _is_tzlocal(object tz)
+cdef bint is_utc(object tz)
+cdef bint is_tzlocal(object tz)
 
-cdef bint _treat_tz_as_pytz(object tz)
-cdef bint _treat_tz_as_dateutil(object tz)
+cdef bint treat_tz_as_pytz(object tz)
+cdef bint treat_tz_as_dateutil(object tz)
 
-cdef object _get_zone(object tz)
+cpdef object get_timezone(object tz)
 
-cpdef _get_utcoffset(tzinfo, obj)
+cpdef get_utcoffset(tzinfo, obj)
diff --git a/pandas/_libs/tslibs/timezones.pyx b/pandas/_libs/tslibs/timezones.pyx
index 249eedef4..3db369a09 100644
--- a/pandas/_libs/tslibs/timezones.pyx
+++ b/pandas/_libs/tslibs/timezones.pyx
@@ -10,24 +10,24 @@ import pytz
 UTC = pytz.utc
 
 
-cdef inline bint _is_utc(object tz):
+cdef inline bint is_utc(object tz):
     return tz is UTC or isinstance(tz, _dateutil_tzutc)
 
 
-cdef inline bint _is_tzlocal(object tz):
+cdef inline bint is_tzlocal(object tz):
     return isinstance(tz, _dateutil_tzlocal)
 
 
-cdef inline bint _treat_tz_as_pytz(object tz):
+cdef inline bint treat_tz_as_pytz(object tz):
     return hasattr(tz, '_utc_transition_times') and hasattr(
         tz, '_transition_info')
 
 
-cdef inline bint _treat_tz_as_dateutil(object tz):
+cdef inline bint treat_tz_as_dateutil(object tz):
     return hasattr(tz, '_trans_list') and hasattr(tz, '_trans_idx')
 
 
-cdef inline object _get_zone(object tz):
+cpdef inline object get_timezone(object tz):
     """
     We need to do several things here:
     1) Distinguish between pytz and dateutil timezones
@@ -40,10 +40,10 @@ cdef inline object _get_zone(object tz):
     the tz name. It needs to be a string so that we can serialize it with
     UJSON/pytables. maybe_get_tz (below) is the inverse of this process.
     """
-    if _is_utc(tz):
+    if is_utc(tz):
         return 'UTC'
     else:
-        if _treat_tz_as_dateutil(tz):
+        if treat_tz_as_dateutil(tz):
             if '.tar.gz' in tz._filename:
                 raise ValueError(
                     'Bad tz filename. Dateutil on python 3 on windows has a '
@@ -64,14 +64,10 @@ cdef inline object _get_zone(object tz):
             except AttributeError:
                 return tz
 
-
-def get_timezone(tz):
-    return _get_zone(tz)
-
 #----------------------------------------------------------------------
 # UTC Offsets
 
-cpdef _get_utcoffset(tzinfo, obj):
+cpdef get_utcoffset(tzinfo, obj):
     try:
         return tzinfo._utcoffset
     except AttributeError:

commit 0cc1a3d0bc4617440e3df9e3e55b19cb6fb51a2d
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Apr 21 20:14:01 2012 -0400

    REF: major time series refactor, rename resample to asfreq, skts -> period, various cleanup

diff --git a/RELEASE.rst b/RELEASE.rst
index 176ace50d..0122a1f34 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -32,7 +32,8 @@ pandas 0.8.0
 
 **API Changes**
 
- - Change BDay (business day) to not normalize dates by default
+  - Change BDay (business day) to not normalize dates by default
+  - Remove deprecated DataMatrix name
 
 pandas 0.7.3
 ============
diff --git a/pandas/compat/__init__.py b/pandas/compat/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/compat/scipy.py b/pandas/compat/scipy.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/core/algorithms.py b/pandas/core/algorithms.py
index 368f4e815..15232e2bd 100644
--- a/pandas/core/algorithms.py
+++ b/pandas/core/algorithms.py
@@ -20,29 +20,36 @@ def match(values, index):
     -------
     match : ndarray
     """
-    if com.is_float_dtype(index):
-        return _match_generic(values, index, lib.Float64HashTable,
-                              com._ensure_float64)
-    elif com.is_integer_dtype(index):
-        return _match_generic(values, index, lib.Int64HashTable,
-                              com._ensure_int64)
-    else:
-        return _match_generic(values, index, lib.PyObjectHashTable,
-                              com._ensure_object)
+    f = lambda htype, caster: _match_generic(values, index, htype, caster)
+    return _hashtable_algo(f, index.dtype)
+
+def unique(values):
+    """
+
+    """
+    f = lambda htype, caster: _unique_generic(values, htype, caster)
+    return _hashtable_algo(f, values.dtype)
+
 
 def count(values, uniques=None):
+    f = lambda htype, caster: _count_generic(values, htype, caster)
+
     if uniques is not None:
         raise NotImplementedError
     else:
-        if com.is_float_dtype(values):
-            return _count_generic(values, lib.Float64HashTable,
-                                  com._ensure_float64)
-        elif com.is_integer_dtype(values):
-            return _count_generic(values, lib.Int64HashTable,
-                                  com._ensure_int64)
-        else:
-            return _count_generic(values, lib.PyObjectHashTable,
-                                  com._ensure_object)
+        return _hashtable_algo(f, values.dtype)
+
+def _hashtable_algo(f, dtype):
+    """
+    f(HashTable, type_caster) -> result
+    """
+    if com.is_float_dtype(dtype):
+        return f(lib.Float64HashTable, com._ensure_float64)
+    elif com.is_integer_dtype(dtype):
+        return f(lib.Int64HashTable, com._ensure_int64)
+    else:
+        return f(lib.PyObjectHashTable, com._ensure_object)
+
 
 def _count_generic(values, table_type, type_caster):
     values = type_caster(values)
@@ -58,6 +65,12 @@ def _match_generic(values, index, table_type, type_caster):
     table.map_locations(index)
     return table.lookup(values)
 
+def _unique_generic(values, table_type, type_caster):
+    values = type_caster(values)
+    table = table_type(len(values))
+    uniques = table.unique(values)
+    return uniques
+
 def factorize(values, sort=False, order=None, na_sentinel=-1):
     """
     Encode input values as an enumerated type or categorical variable
@@ -177,9 +190,3 @@ _hashtables = {
     'int64' : lib.Int64HashTable,
     'generic' : lib.PyObjectHashTable
 }
-
-def unique(values):
-    """
-
-    """
-    pass
diff --git a/pandas/core/api.py b/pandas/core/api.py
index 703dd73e5..e8b652c99 100644
--- a/pandas/core/api.py
+++ b/pandas/core/api.py
@@ -1,3 +1,4 @@
+
 # pylint: disable=W0614,W0401,W0611
 
 import numpy as np
@@ -6,15 +7,9 @@ from pandas.core.datetools import DateOffset, to_datetime
 import pandas.core.datetools as datetools
 
 from pandas.core.common import isnull, notnull, save, load
+from pandas.core.factor import Factor
 from pandas.core.format import set_printoptions
-from pandas.core.index import (Index, Int64Index, Factor, MultiIndex,
-                               DatetimeIndex, IntervalIndex)
-
-# deprecated
-from pandas.core.daterange import DateRange
-
-from pandas.core.daterange import date_range, bdate_range
-from pandas.core.datetools import Timestamp, Interval
+from pandas.core.index import Index, Int64Index, MultiIndex
 
 from pandas.core.series import Series, TimeSeries
 from pandas.core.frame import DataFrame
@@ -22,6 +17,10 @@ from pandas.core.panel import Panel
 from pandas.core.groupby import groupby, TimeGrouper
 from pandas.core.reshape import pivot_simple as pivot
 
-DataMatrix = DataFrame
 WidePanel = Panel
 
+from pandas.core.daterange import DateRange # deprecated
+
+from pandas.tseries.index import (DatetimeIndex, Timestamp,
+                                  date_range, bdate_range)
+from pandas.tseries.period import Period, PeriodIndex
diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index 4730e93b9..c9c673a42 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -43,50 +43,6 @@ class DateRange(Index):
         self.tzinfo = tzinfo
         Index.__setstate__(self, *index_state)
 
-def date_range(start=None, end=None, periods=None, freq='D', tz=None,
-               normalize=False):
-    """
-    Return a fixed frequency datetime index, with day (calendar) as the default
-    frequency
-
-
-    Parameters
-    ----------
-    start :
-    end :
-    normalize : bool, default False
-        Normalize start/end dates to midnight before generating date range
-
-    Returns
-    -------
-
-    """
-    return DatetimeIndex(start=start, end=end, periods=periods,
-                         freq=freq, tz=tz, normalize=normalize)
-
-
-def bdate_range(start=None, end=None, periods=None, freq='B', tz=None,
-                normalize=True):
-    """
-    Return a fixed frequency datetime index, with business day as the default
-    frequency
-
-    Parameters
-    ----------
-
-    normalize : bool, default False
-        Normalize start/end dates to midnight before generating date
-        range. Defaults to True for legacy reasons
-
-    Returns
-    -------
-    date_range : DatetimeIndex
-
-    """
-
-    return DatetimeIndex(start=start, end=end, periods=periods,
-                         freq=freq, tz=tz, normalize=normalize)
-
 def interval_range():
     """
     Return a fixed frequency interval index
diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index eeff2d583..c0cc6e49f 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -1,2313 +1,5 @@
 """A collection of random tools for dealing with dates in Python"""
-from datetime import datetime, timedelta
-import sys
-import numpy as np
-import pandas._tseries as lib
-import re
 
-from pandas._tseries import Timestamp
-import pandas.core.common as com
-
-try:
-    import dateutil
-    from dateutil import parser
-    from dateutil.relativedelta import relativedelta
-
-    # raise exception if dateutil 2.0 install on 2.x platform
-    if (sys.version_info[0] == 2 and
-        dateutil.__version__ == '2.0'):  # pragma: no cover
-        raise Exception('dateutil 2.0 incompatible with Python 2.x, you must '
-                        'install version 1.5!')
-except ImportError: # pragma: no cover
-    print 'Please install python-dateutil via easy_install or some method!'
-    raise # otherwise a 2nd import won't show the message
-
-#-------------------------------------------------------------------------------
-# Boxing and unboxing
-
-def _dt_box(key, offset=None, tz=None):
-    '''
-    timestamp-like (int64, python datetime, etc.) => Timestamp
-    '''
-    return Timestamp(key, offset=offset, tz=tz)
-
-def _dt_box_array(arr, offset=None, tz=None):
-    if arr is None:
-        return arr
-
-    if not isinstance(arr, np.ndarray):
-        return arr
-
-    boxfunc = lambda x: _dt_box(x, offset=offset, tz=tz)
-    boxer = np.frompyfunc(boxfunc, 1, 1)
-    return boxer(arr)
-
-def _dt_unbox(key):
-    '''
-    Timestamp-like => dt64
-    '''
-    if not isinstance(key, datetime):
-        key = to_timestamp(key)
-
-    return np.datetime64(lib.pydt_to_i8(key))
-
-def _dt_unbox_array(arr):
-    if arr is None:
-        return arr
-    unboxer = np.frompyfunc(_dt_unbox, 1, 1)
-    return unboxer(arr)
-
-def _str_to_dt_array(arr):
-    def parser(x):
-        result = parse_time_string(x)
-        return result[0]
-
-    p_ufunc = np.frompyfunc(parser, 1, 1)
-    data = p_ufunc(arr)
-    return np.array(data, dtype='M8[us]')
-
-def to_datetime(arg, errors='ignore', dayfirst=False):
-    """
-    Convert argument to datetime
-
-    Parameters
-    ----------
-    arg : string, datetime, array of strings (with possible NAs)
-    errors : {'ignore', 'raise'}, default 'ignore'
-        Errors are ignored by default (values left untouched)
-
-    Returns
-    -------
-    ret : datetime if parsing succeeded
-    """
-    from pandas.core.series import Series
-    if arg is None:
-        return arg
-    elif isinstance(arg, datetime):
-        return arg
-    elif isinstance(arg, Series):
-        values = lib.string_to_datetime(com._ensure_object(arg.values),
-                                        raise_=errors == 'raise',
-                                        dayfirst=dayfirst)
-        return Series(values, index=arg.index, name=arg.name)
-    elif isinstance(arg, (np.ndarray, list)):
-        if isinstance(arg, list):
-            arg = np.array(arg, dtype='O')
-        return lib.string_to_datetime(com._ensure_object(arg),
-                                      raise_=errors == 'raise',
-                                      dayfirst=dayfirst)
-
-    try:
-        if not arg:
-            return arg
-        return parser.parse(arg, dayfirst=dayfirst)
-    except Exception:
-        if errors == 'raise':
-            raise
-        return arg
-
-
-def to_timestamp(arg, offset=None, tz=None):
-    if arg is None:
-        return arg
-    return Timestamp(arg, offset=offset, tz=tz)
-
-
-def to_interval(arg, freq=None):
-    """ Attempts to convert arg to timestamp """
-    if arg is None:
-        return arg
-
-    if type(arg) == float:
-        raise TypeError("Cannot convert a float to interval")
-
-    return Interval(arg, freq=freq)
-
-
-#---------------
-# Interval logic
-
-
-class Interval(object):
-
-    def __init__(self, value=None, freq=None,
-                 year=None, month=1, quarter=None, day=1,
-                 hour=0, minute=0, second=0):
-        """
-        Represents an interval of time
-
-        Parameters
-        ----------
-        value : Interval or basestring, default None
-            The time interval represented (e.g., '4Q2005')
-        freq : str, default None
-            e.g., 'B' for businessday, ('T', 5) or '5T' for 5 minutes
-        year : int, default None
-        month : int, default 1
-        quarter : int, default None
-        day : int, default 1
-        hour : int, default 0
-        minute : int, default 0
-        second : int, default 0
-        """
-        # freq points to a tuple (base, mult);  base is one of the defined
-        # intervals such as A, Q, etc. Every five minutes would be, e.g.,
-        # ('T', 5) but may be passed in as a string like '5T'
-
-        self.freq = None
-
-        # ordinal is the interval offset from the gregorian proleptic epoch
-
-        self.ordinal = None
-
-        if value is None:
-            if freq is None:
-                raise ValueError("If value is None, freq cannot be None")
-
-            if year is None:
-                raise ValueError("If value is None, year cannot be None")
-
-            if quarter is not None:
-                month = (quarter - 1) * 3 + 1
-
-            base, mult = _get_freq_code(freq)
-
-            self.ordinal = lib.skts_ordinal(year, month, day, hour, minute,
-                                            second, base, mult)
-
-        elif isinstance(value, Interval):
-            other = value
-            if freq is None or _gfc(freq) == _gfc(other.freq):
-                self.ordinal = other.ordinal
-                freq = other.freq
-            else:
-                converted = other.resample(freq)
-                self.ordinal = converted.ordinal
-
-        elif isinstance(value, basestring):
-            value = value.upper()
-            dt, parsed, reso = parse_time_string(value)
-
-            if freq is None:
-                if reso == 'year':
-                    freq = 'A'
-                elif reso == 'quarter':
-                    freq = 'Q'
-                elif reso == 'month':
-                    freq = 'M'
-                elif reso == 'day':
-                    freq = 'D'
-                elif reso == 'hour':
-                    freq = 'H'
-                elif reso == 'minute':
-                    freq = 'T'
-                elif reso == 'second':
-                    freq = 'S'
-                else:
-                    raise ValueError("Could not infer frequency for interval")
-
-        elif isinstance(value, datetime):
-            dt = value
-            if freq is None:
-                raise ValueError('Must supply freq for datetime value')
-        elif isinstance(value, (int, long)):
-            if value <= 0:
-                raise ValueError("Value must be positive")
-            self.ordinal = value
-            if freq is None:
-                raise ValueError('Must supply freq for ordinal value')
-        else:
-            msg = "Value must be Interval, string, integer, or datetime"
-            raise ValueError(msg)
-
-        base, mult = _gfc(freq)
-
-        if self.ordinal is None:
-            self.ordinal = lib.skts_ordinal(dt.year, dt.month, dt.day, dt.hour,
-                                            dt.minute, dt.second, base, mult)
-
-        self.freq = _get_freq_str(base, mult)
-
-    def __eq__(self, other):
-        if isinstance(other, Interval):
-            return (self.ordinal == other.ordinal
-                    and _gfc(self.freq) == _gfc(other.freq))
-        return False
-
-    def __add__(self, other):
-        if isinstance(other, (int, long)):
-            return Interval(self.ordinal + other, self.freq)
-        raise ValueError("Cannot add with non-integer value")
-
-    def __sub__(self, other):
-        if isinstance(other, (int, long)):
-            return Interval(self.ordinal - other, self.freq)
-        if isinstance(other, Interval):
-            if other.freq != self.freq:
-                raise ValueError("Cannot do arithmetic with "
-                                 "non-conforming intervals")
-            return self.ordinal - other.ordinal
-        raise ValueError("Cannot sub with non-integer value")
-
-    def resample(self, freq=None, how='E'):
-        """
-
-        Parameters
-        ----------
-        freq :
-        how :
-
-        Returns
-        -------
-        resampled : Interval
-        """
-        how = validate_end_alias(how)
-        base1, mult1 = _get_freq_code(self.freq)
-        base2, mult2 = _get_freq_code(freq)
-
-        new_ordinal = lib.skts_resample(self.ordinal, base1, mult1,
-                                        base2, mult2, how)
-
-        return Interval(new_ordinal, (base2, mult2))
-
-    # for skts compatibility
-    asfreq = resample
-
-    def start_time(self):
-        return self.to_timestamp(which_end='S')
-
-    def end_time(self):
-        return self.to_timestamp(which_end='E')
-
-    def to_timestamp(self, which_end='S'):
-        """
-        Return the Timestamp at the start/end of the interval
-
-        Parameters
-        ----------
-        which_end: str, default 'S' (start)
-            'S', 'E'. Can be aliased as case insensitive
-            'Start', 'Finish', 'Begin', 'End'
-
-        Returns
-        -------
-        Timestamp
-        """
-        which_end = validate_end_alias(which_end)
-        new_val = self.resample('S', which_end)
-        base, mult = _get_freq_code(new_val.freq)
-        return Timestamp(lib.skts_ordinal_to_dt64(new_val.ordinal, base, mult))
-
-    @property
-    def year(self):
-        base, mult = _gfc(self.freq)
-        return lib.get_skts_year(self.ordinal, base, mult)
-
-    @property
-    def month(self):
-        base, mult = _gfc(self.freq)
-        return lib.get_skts_month(self.ordinal, base, mult)
-
-    @property
-    def qyear(self):
-        base, mult = _gfc(self.freq)
-        return lib.get_skts_qyear(self.ordinal, base, mult)
-
-    @property
-    def quarter(self):
-        base, mult = _gfc(self.freq)
-        return lib.get_skts_quarter(self.ordinal, base, mult)
-
-    @property
-    def day(self):
-        base, mult = _gfc(self.freq)
-        return lib.get_skts_day(self.ordinal, base, mult)
-
-    @property
-    def week(self):
-        base, mult = _gfc(self.freq)
-        return lib.get_skts_week(self.ordinal, base, mult)
-
-    @property
-    def weekday(self):
-        base, mult = _gfc(self.freq)
-        return lib.get_skts_weekday(self.ordinal, base, mult)
-
-    @property
-    def day_of_week(self):
-        base, mult = _gfc(self.freq)
-        return lib.get_skts_dow(self.ordinal, base, mult)
-
-    @property
-    def day_of_year(self):
-        base, mult = _gfc(self.freq)
-        return lib.get_skts_doy(self.ordinal, base, mult)
-
-    @property
-    def hour(self):
-        base, mult = _gfc(self.freq)
-        return lib.get_skts_hour(self.ordinal, base, mult)
-
-    @property
-    def minute(self):
-        base, mult = _gfc(self.freq)
-        return lib.get_skts_minute(self.ordinal, base, mult)
-
-    @property
-    def second(self):
-        base, mult = _gfc(self.freq)
-        return lib.get_skts_second(self.ordinal, base, mult)
-
-    @classmethod
-    def now(cls, freq=None):
-        return Interval(datetime.now(), freq=freq)
-
-    def __repr__(self):
-        base, mult = _gfc(self.freq)
-        formatted = lib.skts_ordinal_to_string(self.ordinal, base, mult)
-        freqstr = _reverse_interval_code_map[base]
-        if mult == 1:
-            return "Interval('%s', '%s')" % (formatted, freqstr)
-        return ("Interval('%s', '%d%s')" % (formatted, mult, freqstr))
-
-    def __str__(self):
-        base, mult = _gfc(self.freq)
-        formatted = lib.skts_ordinal_to_string(self.ordinal, base, mult)
-        return ("%s" % formatted)
-
-    def strftime(self, fmt):
-        """
-        Returns the string representation of the :class:`Interval`, depending
-        on the selected :keyword:`format`. :keyword:`format` must be a string
-        containing one or several directives.  The method recognizes the same
-        directives as the :func:`time.strftime` function of the standard Python
-        distribution, as well as the specific additional directives ``%f``,
-        ``%F``, ``%q``. (formatting & docs originally from scikits.timeries)
-
-        +-----------+--------------------------------+-------+
-        | Directive | Meaning                        | Notes |
-        +===========+================================+=======+
-        | ``%a``    | Locale's abbreviated weekday   |       |
-        |           | name.                          |       |
-        +-----------+--------------------------------+-------+
-        | ``%A``    | Locale's full weekday name.    |       |
-        +-----------+--------------------------------+-------+
-        | ``%b``    | Locale's abbreviated month     |       |
-        |           | name.                          |       |
-        +-----------+--------------------------------+-------+
-        | ``%B``    | Locale's full month name.      |       |
-        +-----------+--------------------------------+-------+
-        | ``%c``    | Locale's appropriate date and  |       |
-        |           | time representation.           |       |
-        +-----------+--------------------------------+-------+
-        | ``%d``    | Day of the month as a decimal  |       |
-        |           | number [01,31].                |       |
-        +-----------+--------------------------------+-------+
-        | ``%f``    | 'Fiscal' year without a        | \(1)  |
-        |           | century  as a decimal number   |       |
-        |           | [00,99]                        |       |
-        +-----------+--------------------------------+-------+
-        | ``%F``    | 'Fiscal' year with a century   | \(2)  |
-        |           | as a decimal number            |       |
-        +-----------+--------------------------------+-------+
-        | ``%H``    | Hour (24-hour clock) as a      |       |
-        |           | decimal number [00,23].        |       |
-        +-----------+--------------------------------+-------+
-        | ``%I``    | Hour (12-hour clock) as a      |       |
-        |           | decimal number [01,12].        |       |
-        +-----------+--------------------------------+-------+
-        | ``%j``    | Day of the year as a decimal   |       |
-        |           | number [001,366].              |       |
-        +-----------+--------------------------------+-------+
-        | ``%m``    | Month as a decimal number      |       |
-        |           | [01,12].                       |       |
-        +-----------+--------------------------------+-------+
-        | ``%M``    | Minute as a decimal number     |       |
-        |           | [00,59].                       |       |
-        +-----------+--------------------------------+-------+
-        | ``%p``    | Locale's equivalent of either  | \(3)  |
-        |           | AM or PM.                      |       |
-        +-----------+--------------------------------+-------+
-        | ``%q``    | Quarter as a decimal number    |       |
-        |           | [01,04]                        |       |
-        +-----------+--------------------------------+-------+
-        | ``%S``    | Second as a decimal number     | \(4)  |
-        |           | [00,61].                       |       |
-        +-----------+--------------------------------+-------+
-        | ``%U``    | Week number of the year        | \(5)  |
-        |           | (Sunday as the first day of    |       |
-        |           | the week) as a decimal number  |       |
-        |           | [00,53].  All days in a new    |       |
-        |           | year preceding the first       |       |
-        |           | Sunday are considered to be in |       |
-        |           | week 0.                        |       |
-        +-----------+--------------------------------+-------+
-        | ``%w``    | Weekday as a decimal number    |       |
-        |           | [0(Sunday),6].                 |       |
-        +-----------+--------------------------------+-------+
-        | ``%W``    | Week number of the year        | \(5)  |
-        |           | (Monday as the first day of    |       |
-        |           | the week) as a decimal number  |       |
-        |           | [00,53].  All days in a new    |       |
-        |           | year preceding the first       |       |
-        |           | Monday are considered to be in |       |
-        |           | week 0.                        |       |
-        +-----------+--------------------------------+-------+
-        | ``%x``    | Locale's appropriate date      |       |
-        |           | representation.                |       |
-        +-----------+--------------------------------+-------+
-        | ``%X``    | Locale's appropriate time      |       |
-        |           | representation.                |       |
-        +-----------+--------------------------------+-------+
-        | ``%y``    | Year without century as a      |       |
-        |           | decimal number [00,99].        |       |
-        +-----------+--------------------------------+-------+
-        | ``%Y``    | Year with century as a decimal |       |
-        |           | number.                        |       |
-        +-----------+--------------------------------+-------+
-        | ``%Z``    | Time zone name (no characters  |       |
-        |           | if no time zone exists).       |       |
-        +-----------+--------------------------------+-------+
-        | ``%%``    | A literal ``'%'`` character.   |       |
-        +-----------+--------------------------------+-------+
-
-        .. note::
-
-            (1)
-                The ``%f`` directive is the same as ``%y`` if the frequency is
-                not quarterly.
-                Otherwise, it corresponds to the 'fiscal' year, as defined by
-                the :attr:`qyear` attribute.
-
-            (2)
-                The ``%F`` directive is the same as ``%Y`` if the frequency is
-                not quarterly.
-                Otherwise, it corresponds to the 'fiscal' year, as defined by
-                the :attr:`qyear` attribute.
-
-            (3)
-                The ``%p`` directive only affects the output hour field
-                if the ``%I`` directive is used to parse the hour.
-
-            (4)
-                The range really is ``0`` to ``61``; this accounts for leap
-                seconds and the (very rare) double leap seconds.
-
-            (5)
-                The ``%U`` and ``%W`` directives are only used in calculations
-                when the day of the week and the year are specified.
-
-        .. rubric::  Examples
-
-            >>> a = Interval(freq='Q@JUL', year=2006, quarter=1)
-            >>> a.strftime('%F-Q%q')
-            '2006-Q1'
-            >>> # Output the last month in the quarter of this date
-            >>> a.strftime('%b-%Y')
-            'Oct-2005'
-            >>>
-            >>> a = Interval(freq='D', year=2001, month=1, day=1)
-            >>> a.strftime('%d-%b-%Y')
-            '01-Jan-2006'
-            >>> a.strftime('%b. %d, %Y was a %A')
-            'Jan. 01, 2001 was a Monday'
-        """
-        base, mult = _gfc(self.freq)
-        if fmt is not None:
-            return lib.skts_strftime(self.ordinal, base, mult, fmt)
-        else:
-            return lib.skts_ordinal_to_string(self.ordinal, base, mult)
-
-def _skts_unbox(key, check=None):
-    '''
-    Interval-like => int64
-    '''
-    if not isinstance(key, Interval):
-        key = Interval(key, freq=check)
-    elif check is not None:
-        if key.freq != check:
-            raise ValueError("%s is wrong freq" % key)
-    return np.int64(key.ordinal)
-
-def _skts_unbox_array(arr, check=None):
-    if arr is None:
-        return arr
-    unboxer = np.frompyfunc(lambda x: _skts_unbox(x, check=check), 1, 1)
-    return unboxer(arr)
-
-def _skts_box(val, freq):
-    return Interval(val, freq=freq)
-
-def _skts_box_array(arr, freq):
-    if arr is None:
-        return arr
-
-    if not isinstance(arr, np.ndarray):
-        return arr
-
-    boxfunc = lambda x: _skts_box(x, freq)
-    boxer = np.frompyfunc(boxfunc, 1, 1)
-    return boxer(arr)
-
-def dt64arr_to_sktsarr(data, freq):
-    if data is None:
-        return data
-
-    if isinstance(freq, basestring):
-        base, mult = _get_freq_code(freq)
-    else:
-        base, mult = freq
-
-    return lib.dt64arr_to_sktsarr(data.view('i8'), base, mult)
-
-# interval frequency constants corresponding to scikits timeseries
-# originals
-_interval_code_map = {
-    # Annual freqs with various fiscal year ends.
-    # eg, 2005 for A-FEB runs Mar 1, 2004 to Feb 28, 2005
-    "A"     : 1000,  # Annual
-    "A-DEC" : 1000,  # Annual - December year end
-    "A-JAN" : 1001,  # Annual - January year end
-    "A-FEB" : 1002,  # Annual - February year end
-    "A-MAR" : 1003,  # Annual - March year end
-    "A-APR" : 1004,  # Annual - April year end
-    "A-MAY" : 1005,  # Annual - May year end
-    "A-JUN" : 1006,  # Annual - June year end
-    "A-JUL" : 1007,  # Annual - July year end
-    "A-AUG" : 1008,  # Annual - August year end
-    "A-SEP" : 1009,  # Annual - September year end
-    "A-OCT" : 1010,  # Annual - October year end
-    "A-NOV" : 1011,  # Annual - November year end
-
-    # Quarterly frequencies with various fiscal year ends.
-    # eg, Q42005 for Q-OCT runs Aug 1, 2005 to Oct 31, 2005
-    "Q"     : 2000,    # Quarterly - December year end (default quarterly)
-    "Q-DEC" : 2000 ,    # Quarterly - December year end
-    "Q-JAN" : 2001,    # Quarterly - January year end
-    "Q-FEB" : 2002,    # Quarterly - February year end
-    "Q-MAR" : 2003,    # Quarterly - March year end
-    "Q-APR" : 2004,    # Quarterly - April year end
-    "Q-MAY" : 2005,    # Quarterly - May year end
-    "Q-JUN" : 2006,    # Quarterly - June year end
-    "Q-JUL" : 2007,    # Quarterly - July year end
-    "Q-AUG" : 2008,    # Quarterly - August year end
-    "Q-SEP" : 2009,    # Quarterly - September year end
-    "Q-OCT" : 2010,    # Quarterly - October year end
-    "Q-NOV" : 2011,    # Quarterly - November year end
-
-    "M"     : 3000,   # Monthly
-
-    "W"     : 4000,    # Weekly
-    "W-SUN" : 4000,    # Weekly - Sunday end of week
-    "W-MON" : 4001,    # Weekly - Monday end of week
-    "W-TUE" : 4002,    # Weekly - Tuesday end of week
-    "W-WED" : 4003,    # Weekly - Wednesday end of week
-    "W-THU" : 4004,    # Weekly - Thursday end of week
-    "W-FRI" : 4005,    # Weekly - Friday end of week
-    "W-SAT" : 4006,    # Weekly - Saturday end of week
-
-    "B"      : 5000,   # Business days
-    "D"      : 6000,   # Daily
-    "H"      : 7000,   # Hourly
-    "T"      : 8000,   # Minutely
-    "S"      : 9000,   # Secondly
-    None     : -10000  # Undefined
-}
-
-def _skts_alias_dictionary():
-    """
-    Build freq alias dictionary to support freqs from original c_dates.c file
-    of the scikits.timeseries library.
-    """
-    alias_dict = {}
-
-    M_aliases = ["M", "MTH", "MONTH", "MONTHLY"]
-    B_aliases = ["B", "BUS", "BUSINESS", "BUSINESSLY", 'WEEKDAY']
-    D_aliases = ["D", "DAY", "DLY", "DAILY"]
-    H_aliases = ["H", "HR", "HOUR", "HRLY", "HOURLY"]
-    T_aliases = ["T", "MIN", "MINUTE", "MINUTELY"]
-    S_aliases = ["S", "SEC", "SECOND", "SECONDLY"]
-    U_aliases = ["U", "UND", "UNDEF", "UNDEFINED"]
-
-    for k in M_aliases:
-        alias_dict[k] = 'M'
-
-    for k in B_aliases:
-        alias_dict[k] = 'B'
-
-    for k in D_aliases:
-        alias_dict[k] = 'D'
-
-    for k in H_aliases:
-        alias_dict[k] = 'H'
-
-    for k in T_aliases:
-        alias_dict[k] = 'Min'
-
-    for k in S_aliases:
-        alias_dict[k] = 'S'
-
-    for k in U_aliases:
-        alias_dict[k] = None
-
-    A_prefixes = ["A", "Y", "ANN", "ANNUAL", "ANNUALLY", "YR", "YEAR",
-                  "YEARLY"]
-
-    Q_prefixes = ["Q", "QTR", "QUARTER", "QUARTERLY", "Q-E",
-                  "QTR-E", "QUARTER-E", "QUARTERLY-E"]
-
-    month_names = [
-        [ "DEC", "DECEMBER" ],
-        [ "JAN", "JANUARY" ],
-        [ "FEB", "FEBRUARY" ],
-        [ "MAR", "MARCH" ],
-        [ "APR", "APRIL" ],
-        [ "MAY", "MAY" ],
-        [ "JUN", "JUNE" ],
-        [ "JUL", "JULY" ],
-        [ "AUG", "AUGUST" ],
-        [ "SEP", "SEPTEMBER" ],
-        [ "OCT", "OCTOBER" ],
-        [ "NOV", "NOVEMBER" ] ]
-
-    seps = ["@", "-"]
-
-    for k in A_prefixes:
-        alias_dict[k] = 'A'
-        for m_tup in month_names:
-            for sep in seps:
-                m1, m2 = m_tup
-                alias_dict[k + sep + m1] = 'A-' + m1
-                alias_dict[k + sep + m2] = 'A-' + m1
-
-    for k in Q_prefixes:
-        alias_dict[k] = 'Q'
-        for m_tup in month_names:
-            for sep in seps:
-                m1, m2 = m_tup
-                alias_dict[k + sep + m1] = 'Q-' + m1
-                alias_dict[k + sep + m2] = 'Q-' + m1
-
-    W_prefixes = ["W", "WK", "WEEK", "WEEKLY"]
-
-    day_names = [
-        [ "SUN", "SUNDAY" ],
-        [ "MON", "MONDAY" ],
-        [ "TUE", "TUESDAY" ],
-        [ "WED", "WEDNESDAY" ],
-        [ "THU", "THURSDAY" ],
-        [ "FRI", "FRIDAY" ],
-        [ "SAT", "SATURDAY" ] ]
-
-    for k in W_prefixes:
-        alias_dict[k] = 'W'
-        for d_tup in day_names:
-            for sep in ["@", "-"]:
-                d1, d2 = d_tup
-                alias_dict[k + sep + d1] = 'W-' + d1
-                alias_dict[k + sep + d2] = 'W-' + d1
-
-    return alias_dict
-
-_reverse_interval_code_map = {}
-for k, v in _interval_code_map.iteritems():
-    _reverse_interval_code_map[v] = k
-
-_reso_interval_map = {
-    "year"    : "A",
-    "quarter" : "Q",
-    "month"   : "M",
-    "day"     : "D",
-    "hour"    : "H",
-    "minute"  : "T",
-    "second"  : "S",
-}
-
-def _infer_interval_group(freqstr):
-    return _interval_group(_reso_interval_map[freqstr])
-
-def _interval_group(freqstr):
-    base, mult = _get_freq_code(freqstr)
-    return base // 1000 * 1000
-
-def _get_freq_code(freqstr):
-    if isinstance(freqstr, DateOffset):
-        freqstr = (get_offset_name(freqstr), freqstr.n)
-
-    if isinstance(freqstr, tuple):
-        if (isinstance(freqstr[0], (int, long)) and
-            isinstance(freqstr[1], (int, long))):
-            #e.g., freqstr = (2000, 1)
-            return freqstr
-        else:
-            #e.g., freqstr = ('T', 5)
-            try:
-                code = _interval_str_to_code(freqstr[0])
-                stride = freqstr[1]
-            except:
-                code = _interval_str_to_code(freqstr[1])
-                stride = freqstr[0]
-            return code, stride
-
-    if isinstance(freqstr, (int, long)):
-        return (freqstr, 1)
-
-    base, stride = _base_and_stride(freqstr)
-    code = _interval_str_to_code(base)
-
-    return code, stride
-
-_skts_alias_dict = _skts_alias_dictionary()
-
-def _interval_str_to_code(freqstr):
-    # hack
-    freqstr = _rule_aliases.get(freqstr, freqstr)
-    freqstr = _rule_aliases.get(freqstr.lower(), freqstr)
-
-    try:
-        freqstr = freqstr.upper()
-        return _interval_code_map[freqstr]
-    except:
-        alias = _skts_alias_dict[freqstr]
-        try:
-            return _interval_code_map[alias]
-        except:
-            raise "Could not interpret frequency %s" % freqstr
-
-_gfc = _get_freq_code
-
-def _get_freq_str(base, mult):
-    code = _reverse_interval_code_map.get(base)
-    if code is None:
-        return _unknown_freq
-    if mult == 1:
-        return code
-    return str(mult) + code
-
-_gfs = _get_freq_str
-
-_unknown_freq = 'Unknown'
-
-#-------------------------------------------------------------------------------
-# Miscellaneous date functions
-
-def format(dt):
-    """Returns date in YYYYMMDD format."""
-    return dt.strftime('%Y%m%d')
-
-OLE_TIME_ZERO = datetime(1899, 12, 30, 0, 0, 0)
-
-def ole2datetime(oledt):
-    """function for converting excel date to normal date format"""
-    val = float(oledt)
-
-    # Excel has a bug where it thinks the date 2/29/1900 exists
-    # we just reject any date before 3/1/1900.
-    if val < 61:
-        raise Exception("Value is outside of acceptable range: %s " % val)
-
-    return OLE_TIME_ZERO + timedelta(days=val)
-
-
-class DateParseError(ValueError):
-    pass
-
-_dtparser = parser.parser()
-
-# patterns for quarters like '4Q2005', '05Q1'
-qpat1full = re.compile(r'(\d)Q(\d\d\d\d)')
-qpat2full = re.compile(r'(\d\d\d\d)Q(\d)')
-qpat1 = re.compile(r'(\d)Q(\d\d)')
-qpat2 = re.compile(r'(\d\d)Q(\d)')
-
-def parse_time_string(arg):
-    """
-    Try hard to parse datetime string, leveraging dateutil plus some extra
-    goodies like quarter recognition.
-
-    Parameters
-    ----------
-    arg : basestring
-
-    Returns
-    -------
-    datetime, datetime/dateutil.parser._result, str
-    """
-    from pandas.core.format import print_config
-
-    if not isinstance(arg, basestring):
-        return arg
-
-    arg = arg.upper()
-    try:
-        default = datetime(1,1,1).replace(hour=0, minute=0,
-                                          second=0, microsecond=0)
-
-        # special handling for possibilities eg, 2Q2005, 2Q05, 2005Q1, 05Q1
-        if len(arg) in [4, 6]:
-            add_century = False
-            if len(arg) == 4:
-                add_century = True
-                qpats = [(qpat1, 1), (qpat2, 0)]
-            else:
-                qpats = [(qpat1full, 1), (qpat2full, 0)]
-
-            for pat, yfirst in qpats:
-                qparse = pat.match(arg)
-                if qparse is not None:
-                    if yfirst:
-                        yi, qi = 1, 2
-                    else:
-                        yi, qi = 2, 1
-                    q = int(qparse.group(yi))
-                    y_str = qparse.group(qi)
-                    y = int(y_str)
-                    if add_century:
-                        y += 2000
-                    ret = default.replace(year=y, month=(q-1)*3+1)
-                    return ret, ret, 'quarter'
-
-        dayfirst = print_config.date_dayfirst
-        yearfirst = print_config.date_yearfirst
-
-        parsed = _dtparser._parse(arg, dayfirst=dayfirst, yearfirst=yearfirst)
-        if parsed is None:
-            raise DateParseError("Could not parse %s" % arg)
-
-        repl = {}
-        reso = 'year'
-        stopped = False
-        for attr in ["year", "month", "day", "hour",
-                     "minute", "second", "microsecond"]:
-            can_be_zero = ['hour', 'minute', 'second', 'microsecond']
-            value = getattr(parsed, attr)
-            if value is not None and (value != 0 or attr in can_be_zero):
-                repl[attr] = value
-                if not stopped:
-                    reso = attr
-                else:
-                    raise DateParseError("Missing attribute before %s" % attr)
-            else:
-                stopped = True
-        ret = default.replace(**repl)
-        return ret, parsed, reso  # datetime, resolution
-    except Exception, e:
-        raise DateParseError(e)
-
-def normalize_date(dt):
-    if isinstance(dt, np.datetime64):
-        dt = _dt_box(dt)
-    return dt.replace(hour=0, minute=0, second=0, microsecond=0)
-
-def _get_firstbday(wkday):
-    """
-    wkday is the result of monthrange(year, month)
-
-    If it's a saturday or sunday, increment first business day to reflect this
-    """
-    firstBDay = 1
-    if wkday == 5: # on Saturday
-        firstBDay = 3
-    elif wkday == 6: # on Sunday
-        firstBDay = 2
-    return firstBDay
-
-#-------------------------------------------------------------------------------
-# DateOffset
-
-class CacheableOffset(object):
-
-    _cacheable = True
-
-
-class DateOffset(object):
-    """
-    Standard kind of date increment used for a date range.
-
-    Works exactly like relativedelta in terms of the keyword args you
-    pass in, use of the keyword n is discouraged-- you would be better
-    off specifying n in the keywords you use, but regardless it is
-    there for you. n is needed for DateOffset subclasses.
-
-    DateOffets work as follows.  Each offset specify a set of dates
-    that conform to the DateOffset.  For example, Bday defines this
-    set to be the set of dates that are weekdays (M-F).  To test if a
-    date is in the set of a DateOffset dateOffset we can use the
-    onOffset method: dateOffset.onOffset(date).
-
-    If a date is not on a valid date, the rollback and rollforward
-    methods can be used to roll the date to the nearest valid date
-    before/after the date.
-
-    DateOffsets can be created to move dates forward a given number of
-    valid dates.  For example, Bday(2) can be added to a date to move
-    it two business days forward.  If the date does not start on a
-    valid date, first it is moved to a valid date.  Thus psedo code
-    is:
-
-    def __add__(date):
-      date = rollback(date) # does nothing is date is valid
-      return date + <n number of periods>
-
-    When a date offset is created for a negitive number of periods,
-    the date is first rolled forward.  The pseudo code is:
-
-    def __add__(date):
-      date = rollforward(date) # does nothing is date is valid
-      return date + <n number of periods>
-
-    Zero presents a problem.  Should it roll forward or back?  We
-    arbitrarily have it rollforward:
-
-    date + BDay(0) == BDay.rollforward(date)
-
-    Since 0 is a bit weird, we suggest avoiding its use.
-    """
-    _cacheable = False
-    _normalize_cache = True
-
-    def __init__(self, n=1, **kwds):
-        self.n = int(n)
-        self.kwds = kwds
-        if len(kwds) > 0:
-            self._offset = relativedelta(**kwds)
-        else:
-            self._offset = timedelta(1)
-
-    def apply(self, other):
-        if len(self.kwds) > 0:
-            if self.n > 0:
-                for i in xrange(self.n):
-                    other = other + self._offset
-            else:
-                for i in xrange(-self.n):
-                    other = other - self._offset
-            return other
-        else:
-            return other + timedelta(self.n)
-
-    def isAnchored(self):
-        return (self.n == 1)
-
-    def copy(self):
-        return self.__class__(self.n, **self.kwds)
-
-    def _should_cache(self):
-        return self.isAnchored() and self._cacheable
-
-    def _params(self):
-        attrs = [(k, v) for k, v in vars(self).iteritems()
-                 if k not in ['kwds', '_offset', 'name']]
-        attrs.extend(self.kwds.items())
-        attrs = sorted(set(attrs))
-
-        params = tuple([str(self.__class__)] + attrs)
-        return params
-
-    def __repr__(self):
-        if hasattr(self, 'name') and len(self.name):
-            return self.name
-
-        className = getattr(self, '_outputName', type(self).__name__)
-        exclude = set(['n', 'inc'])
-        attrs = []
-        for attr in self.__dict__:
-            if ((attr == 'kwds' and len(self.kwds) == 0)
-                or attr.startswith('_')):
-                continue
-            if attr not in exclude:
-                attrs.append('='.join((attr, repr(getattr(self, attr)))))
-
-        if abs(self.n) != 1:
-            plural = 's'
-        else:
-            plural = ''
-
-        out = '<%s ' % self.n + className + plural
-        if attrs:
-            out += ': ' + ', '.join(attrs)
-        out += '>'
-        return out
-
-    def __eq__(self, other):
-        if other is None:
-            return False
-
-        if isinstance(other, basestring):
-            other = to_offset(other)
-
-        if not isinstance(other, DateOffset):
-            return False
-
-        return self._params() == other._params()
-
-    def __ne__(self, other):
-        return not self == other
-
-    def __hash__(self):
-        return hash(self._params())
-
-    def __call__(self, other):
-        return self.apply(other)
-
-    def __add__(self, other):
-        return self.apply(other)
-
-    def __radd__(self, other):
-        return self.__add__(other)
-
-    def __sub__(self, other):
-        if isinstance(other, datetime):
-            raise TypeError('Cannot subtract datetime from offset!')
-        elif type(other) == type(self):
-            return self.__class__(self.n - other.n, **self.kwds)
-        else: # pragma: no cover
-            raise TypeError('Cannot subtract %s from %s'
-                            % (type(other), type(self)))
-
-    def __rsub__(self, other):
-        return self.__class__(-self.n, **self.kwds) + other
-
-    def __mul__(self, someInt):
-        return self.__class__(n=someInt * self.n, **self.kwds)
-
-    def __rmul__(self, someInt):
-        return self.__mul__(someInt)
-
-    def __neg__(self):
-        return self.__class__(-self.n, **self.kwds)
-
-    def rollback(self, someDate):
-        """Roll provided date backward to next offset only if not on offset"""
-        if not self.onOffset(someDate):
-            someDate = someDate - self.__class__(1, **self.kwds)
-        return someDate
-
-    def rollforward(self, dt):
-        """Roll provided date forward to next offset only if not on offset"""
-        if isinstance(dt, np.datetime64):
-            dt = _dt_box(dt)
-        if not self.onOffset(dt):
-            dt = dt + self.__class__(1, **self.kwds)
-        return dt
-
-    def onOffset(self, dt):
-        if type(self) == DateOffset:
-            return True
-
-        # Default (slow) method for determining if some date is a member of the
-        # date range generated by this offset. Subclasses may have this
-        # re-implemented in a nicer way.
-        a = dt
-        b = ((dt + self) - self)
-        return a == b
-
-
-class Day(DateOffset, CacheableOffset):
-    _outputName = 'Day'
-
-    def rule_code(self):
-        return 'D'
-
-class BDay(DateOffset, CacheableOffset):
-    """
-    DateOffset subclass representing possibly n business days
-    """
-    _outputName = 'BusinessDay'
-    def __init__(self, n=1, **kwds):
-        self.n = int(n)
-        self.kwds = kwds
-        self.offset = kwds.get('offset', timedelta(0))
-        self.normalize = kwds.get('normalize', False)
-
-    def rule_code(self):
-        return 'B'
-
-    def __repr__(self):
-        if hasattr(self, 'name') and len(self.name):
-            return self.name
-
-        className = getattr(self, '_outputName', self.__class__.__name__)
-        attrs = []
-
-        if self.offset:
-            attrs = ['offset=%s' % repr(self.offset)]
-
-        if abs(self.n) != 1:
-            plural = 's'
-        else:
-            plural = ''
-
-        out = '<%s ' % self.n + className + plural
-        if attrs:
-            out += ': ' + ', '.join(attrs)
-        out += '>'
-        return out
-
-    def isAnchored(self):
-        return (self.n == 1)
-
-    def apply(self, other):
-        if isinstance(other, datetime):
-            n = self.n
-
-            if n == 0 and other.weekday() > 4:
-                n = 1
-
-            result = other
-
-            while n != 0:
-                k = n // abs(n)
-                result = result + timedelta(k)
-                if result.weekday() < 5:
-                    n -= k
-
-            if self.normalize:
-                result = datetime(result.year, result.month, result.day)
-
-            if self.offset:
-                result = result + self.offset
-
-            return result
-
-        elif isinstance(other, (timedelta, Tick)):
-            return BDay(self.n, offset=self.offset + other,
-                        normalize=self.normalize)
-        else:
-            raise Exception('Only know how to combine business day with '
-                            'datetime or timedelta!')
-    @classmethod
-    def onOffset(cls, dt):
-        if isinstance(dt, np.datetime64):
-            dt = _dt_box(dt)
-        return dt.weekday() < 5
-
-
-class MonthEnd(DateOffset, CacheableOffset):
-    """DateOffset of one month end"""
-
-    def apply(self, other):
-        n = self.n
-        _, days_in_month = lib.monthrange(other.year, other.month)
-        if other.day != days_in_month:
-            other = other + relativedelta(months=-1, day=31)
-            if n <= 0:
-                n = n + 1
-        other = other + relativedelta(months=n, day=31)
-        return other
-
-    @classmethod
-    def onOffset(cls, dt):
-        __junk, days_in_month = lib.monthrange(dt.year, dt.month)
-        return dt.day == days_in_month
-
-    def rule_code(self):
-        return 'M'
-
-class MonthBegin(DateOffset, CacheableOffset):
-    """DateOffset of one month at beginning"""
-
-    def apply(self, other):
-        n = self.n
-
-        if other.day > 1 and n <= 0: #then roll forward if n<=0
-            n += 1
-
-        other = other + relativedelta(months=n, day=1)
-        return other
-
-    @classmethod
-    def onOffset(cls, dt):
-        firstDay, _ = lib.monthrange(dt.year, dt.month)
-        return dt.day == (firstDay + 1)
-
-    def rule_code(self):
-        return 'MS'
-
-
-class BMonthEnd(DateOffset, CacheableOffset):
-    """DateOffset increments between business EOM dates"""
-    _outputName = 'BusinessMonthEnd'
-
-    def isAnchored(self):
-        return (self.n == 1)
-
-    def apply(self, other):
-        n = self.n
-
-        wkday, days_in_month = lib.monthrange(other.year, other.month)
-        lastBDay = days_in_month - max(((wkday + days_in_month - 1) % 7) - 4, 0)
-
-        if n > 0 and not other.day >= lastBDay:
-            n = n - 1
-        elif n <= 0 and other.day > lastBDay:
-            n = n + 1
-        other = other + relativedelta(months=n, day=31)
-
-        if other.weekday() > 4:
-            other = other - BDay()
-        return other
-
-    def rule_code(self):
-        return 'BM'
-
-
-class BMonthBegin(DateOffset, CacheableOffset):
-    """DateOffset of one business month at beginning"""
-
-    def apply(self, other):
-        n = self.n
-
-        wkday, _ = lib.monthrange(other.year, other.month)
-        firstBDay = _get_firstbday(wkday)
-
-        if other.day > firstBDay and n<=0:
-            # as if rolled forward already
-            n += 1
-
-        other = other + relativedelta(months=n)
-        wkday, _ = lib.monthrange(other.year, other.month)
-        firstBDay = _get_firstbday(wkday)
-        result = datetime(other.year, other.month, firstBDay)
-        return result
-
-    def rule_code(self):
-        return 'BMS'
-
-
-class Week(DateOffset, CacheableOffset):
-    """
-    Weekly offset
-
-    Parameters
-    ----------
-    weekday : int, default None
-        Always generate specific day of week. 0 for Monday
-    """
-    def __init__(self, n=1, **kwds):
-        self.n = n
-        self.weekday = kwds.get('weekday', None)
-
-        if self.weekday is not None:
-            if self.weekday < 0 or self.weekday > 6:
-                raise Exception('Day must be 0<=day<=6, got %d' %
-                                self.weekday)
-
-        self.inc = timedelta(weeks=1)
-        self.kwds = kwds
-
-    def isAnchored(self):
-        return (self.n == 1 and self.weekday is not None)
-
-    def apply(self, other):
-        if self.weekday is None:
-            return other + self.n * self.inc
-
-        if self.n > 0:
-            k = self.n
-            otherDay = other.weekday()
-            if otherDay != self.weekday:
-                other = other + timedelta((self.weekday - otherDay) % 7)
-                k = k - 1
-            for i in xrange(k):
-                other = other + self.inc
-        else:
-            k = self.n
-            otherDay = other.weekday()
-            if otherDay != self.weekday:
-                other = other + timedelta((self.weekday - otherDay) % 7)
-            for i in xrange(-k):
-                other = other - self.inc
-        return other
-
-    def onOffset(self, dt):
-        return dt.weekday() == self.weekday
-
-    def rule_code(self):
-        suffix = ''
-        if self.weekday is not None:
-            suffix = '-%s' % (_weekday_dict[self.weekday])
-        return 'W' + suffix
-
-_weekday_dict = {
-    0: 'MON',
-    1: 'TUE',
-    2: 'WED',
-    3: 'THU',
-    4: 'FRI',
-    5: 'SAT',
-    6: 'SUN'
-}
-
-class WeekOfMonth(DateOffset, CacheableOffset):
-    """
-    Describes monthly dates like "the Tuesday of the 2nd week of each month"
-
-    Parameters
-    ----------
-    n : int
-    week : {0, 1, 2, 3, ...}
-        0 is 1st week of month, 1 2nd week, etc.
-    weekday : {0, 1, ..., 6}
-        0: Mondays
-        1: Tuedays
-        2: Wednesdays
-        3: Thursdays
-        4: Fridays
-        5: Saturdays
-        6: Sundays
-    """
-    def __init__(self, n=1, **kwds):
-        self.n = n
-        self.weekday = kwds['weekday']
-        self.week = kwds['week']
-
-        if self.n == 0:
-            raise Exception('N cannot be 0')
-
-        if self.weekday < 0 or self.weekday > 6:
-            raise Exception('Day must be 0<=day<=6, got %d' %
-                            self.weekday)
-        if self.week < 0 or self.week > 3:
-            raise Exception('Week must be 0<=day<=3, got %d' %
-                            self.week)
-
-        self.kwds = kwds
-
-    def apply(self, other):
-        offsetOfMonth = self.getOffsetOfMonth(other)
-
-        if offsetOfMonth > other:
-            if self.n > 0:
-                months = self.n - 1
-            else:
-                months = self.n
-        elif offsetOfMonth == other:
-            months = self.n
-        else:
-            if self.n > 0:
-                months = self.n
-            else:
-                months = self.n + 1
-
-        return self.getOffsetOfMonth(other + relativedelta(months=months, day=1))
-
-    def getOffsetOfMonth(self, dt):
-        w = Week(weekday=self.weekday)
-        d = datetime(dt.year, dt.month, 1)
-
-        d = w.rollforward(d)
-
-        for i in xrange(self.week):
-            d = w.apply(d)
-
-        return d
-
-    def onOffset(self, dt):
-        return dt == self.getOffsetOfMonth(dt)
-
-    def rule_code(self):
-        suffix = '-%d%s' % (self.week + 1, _weekday_dict.get(self.weekday, ''))
-        return 'WOM' + suffix
-
-class BQuarterEnd(DateOffset, CacheableOffset):
-    """DateOffset increments between business Quarter dates
-    startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...
-    startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...
-    startingMonth = 3 corresponds to dates like 3/30/2007, 6/29/2007, ...
-    """
-    _outputName = 'BusinessQuarterEnd'
-
-    def __init__(self, n=1, **kwds):
-        self.n = n
-        self.startingMonth = kwds.get('startingMonth', 3)
-
-        self.offset = BMonthEnd(3)
-        self.kwds = kwds
-
-    def isAnchored(self):
-        return (self.n == 1 and self.startingMonth is not None)
-
-    def apply(self, other):
-        n = self.n
-
-        wkday, days_in_month = lib.monthrange(other.year, other.month)
-        lastBDay = days_in_month - max(((wkday + days_in_month - 1) % 7) - 4, 0)
-
-        monthsToGo = 3 - ((other.month - self.startingMonth) % 3)
-        if monthsToGo == 3:
-            monthsToGo = 0
-
-        if n > 0 and not (other.day >= lastBDay and monthsToGo == 0):
-            n = n - 1
-        elif n <= 0 and other.day > lastBDay and monthsToGo == 0:
-            n = n + 1
-
-        other = other + relativedelta(months=monthsToGo + 3*n, day=31)
-
-        if other.weekday() > 4:
-            other = other - BDay()
-
-        return other
-
-    def onOffset(self, dt):
-        modMonth = (dt.month - self.startingMonth) % 3
-        return BMonthEnd().onOffset(dt) and modMonth == 0
-
-    def rule_code(self):
-        suffix = '-%s' % _month_dict[self.startingMonth]
-        return 'BQ' + suffix
-
-_month_dict = {
-    1: 'JAN',
-    2: 'FEB',
-    3: 'MAR',
-    4: 'APR',
-    5: 'MAY',
-    6: 'JUN',
-    7: 'JUL',
-    8: 'AUG',
-    9: 'SEP',
-    10: 'OCT',
-    11: 'NOV',
-    12: 'DEC'
-}
-
-class BQuarterBegin(DateOffset, CacheableOffset):
-    _outputName = "BusinessQuarterBegin"
-
-    def __init__(self, n=1, **kwds):
-        self.n = n
-        self.startingMonth = kwds.get('startingMonth', 3)
-
-        self.offset = BMonthBegin(3)
-        self.kwds = kwds
-
-    def isAnchored(self):
-        return (self.n == 1 and self.startingMonth is not None)
-
-    def apply(self, other):
-        n = self.n
-
-        wkday, _ = lib.monthrange(other.year, other.month)
-
-        firstBDay = _get_firstbday(wkday)
-
-        monthsSince = (other.month - self.startingMonth) % 3
-        if monthsSince == 3: # on offset
-            monthsSince = 0
-
-        if n <= 0 and monthsSince != 0: # make sure to roll forward so negate
-            monthsSince = monthsSince - 3
-
-        # roll forward if on same month later than first bday
-        if n <= 0 and (monthsSince == 0 and other.day > firstBDay):
-            n = n + 1
-        # pretend to roll back if on same month but before firstbday
-        elif n > 0 and (monthsSince == 0 and other.day < firstBDay):
-            n = n - 1
-
-        # get the first bday for result
-        other = other + relativedelta(months=3*n - monthsSince)
-        wkday, _ = lib.monthrange(other.year, other.month)
-        firstBDay = _get_firstbday(wkday)
-        result = datetime(other.year, other.month, firstBDay)
-        return result
-
-    def rule_code(self):
-        suffix = '-%s' % _month_dict[self.startingMonth]
-        return 'BQS' + suffix
-
-
-class QuarterEnd(DateOffset, CacheableOffset):
-    """DateOffset increments between business Quarter dates
-    startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...
-    startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...
-    startingMonth = 3 corresponds to dates like 3/31/2007, 6/30/2007, ...
-    """
-    _outputName = 'QuarterEnd'
-
-    def __init__(self, n=1, **kwds):
-        self.n = n
-        self.startingMonth = kwds.get('startingMonth', 3)
-
-        self.offset = MonthEnd(3)
-        self.kwds = kwds
-
-    def isAnchored(self):
-        return (self.n == 1 and self.startingMonth is not None)
-
-    def apply(self, other):
-        n = self.n
-
-        wkday, days_in_month = lib.monthrange(other.year, other.month)
-
-        monthsToGo = 3 - ((other.month - self.startingMonth) % 3)
-        if monthsToGo == 3:
-            monthsToGo = 0
-
-        if n > 0 and not (other.day >= days_in_month and monthsToGo == 0):
-            n = n - 1
-
-        other = other + relativedelta(months=monthsToGo + 3*n, day=31)
-
-        return other
-
-    def onOffset(self, dt):
-        modMonth = (dt.month - self.startingMonth) % 3
-        return MonthEnd().onOffset(dt) and modMonth == 0
-
-    def rule_code(self):
-        suffix = '-%s' % _month_dict[self.startingMonth]
-        return 'Q' + suffix
-
-
-class QuarterBegin(DateOffset, CacheableOffset):
-    _outputName = 'QuarterBegin'
-
-    def __init__(self, n=1, **kwds):
-        self.n = n
-        self.startingMonth = kwds.get('startingMonth', 3)
-
-        self.offset = MonthBegin(3)
-        self.kwds = kwds
-
-    def isAnchored(self):
-        return (self.n == 1 and self.startingMonth is not None)
-
-    def apply(self, other):
-        n = self.n
-
-        wkday, days_in_month = lib.monthrange(other.year, other.month)
-
-        monthsSince = (other.month - self.startingMonth) % 3
-
-        if monthsSince == 3: # on an offset
-            monthsSince = 0
-
-        if n <= 0 and monthsSince != 0:
-            # make sure you roll forward, so negate
-            monthsSince = monthsSince - 3
-
-        if n < 0 and (monthsSince == 0 and other.day > 1):
-            # after start, so come back an extra period as if rolled forward
-            n = n + 1
-
-        other = other + relativedelta(months=3*n - monthsSince, day=1)
-        return other
-
-    def rule_code(self):
-        suffix = '-%s' % _month_dict[self.startingMonth]
-        return 'QS' + suffix
-
-
-class BYearEnd(DateOffset, CacheableOffset):
-    """DateOffset increments between business EOM dates"""
-    _outputName = 'BusinessYearEnd'
-
-    def __init__(self, n=1, **kwds):
-        self.month = kwds.get('month', 12)
-
-        if self.month < 1 or self.month > 12:
-            raise Exception('Month must go from 1 to 12')
-
-        DateOffset.__init__(self, n=n, **kwds)
-
-    def apply(self, other):
-        n = self.n
-
-        wkday, days_in_month = lib.monthrange(other.year, self.month)
-        lastBDay = (days_in_month -
-                    max(((wkday + days_in_month - 1) % 7) - 4, 0))
-
-        years = n
-        if n > 0:
-            if (other.month < self.month or
-                (other.month == self.month and other.day < lastBDay)):
-                years -= 1
-        elif n <= 0:
-            if (other.month > self.month or
-                (other.month == self.month and other.day > lastBDay)):
-                years += 1
-
-        other = other + relativedelta(years=years)
-
-        _, days_in_month = lib.monthrange(other.year, self.month)
-        result = datetime(other.year, self.month, days_in_month)
-
-        if result.weekday() > 4:
-            result = result - BDay()
-
-        return result
-
-    def rule_code(self):
-        suffix = '-%s' % _month_dict[self.month]
-        return 'BA' + suffix
-
-
-class BYearBegin(DateOffset, CacheableOffset):
-    """DateOffset increments between business year begin dates"""
-    _outputName = 'BusinessYearBegin'
-
-    def __init__(self, n=1, **kwds):
-        self.month = kwds.get('month', 1)
-
-        if self.month < 1 or self.month > 12:
-            raise Exception('Month must go from 1 to 12')
-
-        DateOffset.__init__(self, n=n, **kwds)
-
-    def apply(self, other):
-        n = self.n
-
-        wkday, days_in_month = lib.monthrange(other.year, self.month)
-
-        firstBDay = _get_firstbday(wkday)
-
-        years = n
-
-
-        if n > 0: # roll back first for positive n
-            if (other.month < self.month or
-                (other.month == self.month and other.day < firstBDay)):
-                years -= 1
-        elif n <= 0: # roll forward
-            if (other.month > self.month or
-                (other.month == self.month and other.day > firstBDay)):
-                years += 1
-
-        # set first bday for result
-        other = other + relativedelta(years = years)
-        wkday, days_in_month = lib.monthrange(other.year, self.month)
-        firstBDay = _get_firstbday(wkday)
-        result = datetime(other.year, self.month, firstBDay)
-        return result
-
-    def rule_code(self):
-        suffix = '-%s' % _month_dict[self.month]
-        return 'BAS' + suffix
-
-
-class YearEnd(DateOffset, CacheableOffset):
-    """DateOffset increments between calendar year ends"""
-
-    def __init__(self, n=1, **kwds):
-        self.month = kwds.get('month', 12)
-
-        if self.month < 1 or self.month > 12:
-            raise Exception('Month must go from 1 to 12')
-
-        DateOffset.__init__(self, n=n, **kwds)
-
-    def apply(self, other):
-        n = self.n
-        wkday, days_in_month = lib.monthrange(other.year, self.month)
-        if other.month != self.month or other.day != days_in_month:
-            other = datetime(other.year - 1, self.month, days_in_month)
-            if n <= 0:
-                n = n + 1
-        other = other + relativedelta(years=n)
-        return other
-
-    def onOffset(self, dt):
-        wkday, days_in_month = lib.monthrange(dt.year, self.month)
-        return self.month == dt.month and dt.day == days_in_month
-
-    def rule_code(self):
-        suffix = '-%s' % _month_dict[self.month]
-        return 'A' + suffix
-
-
-class YearBegin(DateOffset, CacheableOffset):
-    """DateOffset increments between calendar year begin dates"""
-
-    def __init__(self, n=1, **kwds):
-        self.month = kwds.get('month', 12)
-
-        if self.month < 1 or self.month > 12:
-            raise Exception('Month must go from 1 to 12')
-
-        DateOffset.__init__(self, n=n, **kwds)
-
-    def apply(self, other):
-        n = self.n
-        if other.month != 1 or other.day != 1:
-            other = datetime(other.year, 1, 1)
-            if n <= 0:
-                n = n + 1
-        other = other + relativedelta(years = n, day=1)
-        return other
-
-    @classmethod
-    def onOffset(cls, dt):
-        return dt.month == 1 and dt.day == 1
-
-    def rule_code(self):
-        suffix = '-%s' % _month_dict[self.month]
-        return 'AS' + suffix
-
-
-#-------------------------------------------------------------------------------
-# Ticks
-
-class Tick(DateOffset):
-    _delta = None
-    _inc = timedelta(microseconds=1000)
-
-    def __eq__(self, other):
-        if isinstance(other, Tick):
-            return self._inc == other._inc
-        else:
-            return DateOffset.__eq__(self, other)
-
-    def __ne__(self, other):
-        if isinstance(other, Tick):
-            return self.delta != other.delta
-        else:
-            return DateOffset.__ne__(self, other)
-
-    @property
-    def delta(self):
-        if self._delta is None:
-            self._delta = self.n * self._inc
-
-        return self._delta
-
-    def us_stride(self):
-        return (self.delta.days * 24 * 60 * 60 * 1000000
-                + self.delta.seconds * 1000000
-                + self.delta.microseconds)
-
-    def apply(self, other):
-        if isinstance(other, (datetime, timedelta)):
-            return other + self.delta
-        elif isinstance(other, type(self)):
-            return type(self)(self.n + other.n)
-
-    def rule_code(self):
-        return 'T'
-
-class Hour(Tick):
-    _inc = timedelta(0, 3600)
-
-    def rule_code(self):
-        return 'H'
-
-class Minute(Tick):
-    _inc = timedelta(0, 60)
-
-    def rule_code(self):
-        return 'T'
-
-class Second(Tick):
-    _inc = timedelta(0, 1)
-
-    def rule_code(self):
-        return 'S'
-
-class Milli(Tick):
-
-    def rule_code(self):
-        return 'L'
-
-class Micro(Tick):
-    _inc = timedelta(microseconds=1)
-
-    def rule_code(self):
-        return 'U'
-
-day = DateOffset()
-bday = BDay()
-businessDay = bday
-monthEnd = MonthEnd()
-yearEnd = YearEnd()
-yearBegin = YearBegin()
-bmonthEnd = BMonthEnd()
-businessMonthEnd = bmonthEnd
-bquarterEnd = BQuarterEnd()
-quarterEnd = QuarterEnd()
-byearEnd = BYearEnd()
-week = Week()
-
-
-# Functions/offsets to roll dates forward
-thisMonthEnd = MonthEnd(0)
-thisBMonthEnd = BMonthEnd(0)
-thisYearEnd = YearEnd(0)
-thisYearBegin = YearBegin(0)
-thisBQuarterEnd = BQuarterEnd(0)
-thisQuarterEnd = QuarterEnd(0)
-
-# Functions to check where a date lies
-isBusinessDay = BDay().onOffset
-isMonthEnd = MonthEnd().onOffset
-isBMonthEnd = BMonthEnd().onOffset
-
-#-------------------------------------------------------------------------------
-# Offset names ("time rules") and related functions
-
-
-_offset_map = {
-    'D'     : Day(),
-    'B'     : BDay(),
-    'H'     : Hour(),
-    'T'     : Minute(),
-    'S'     : Second(),
-    'L'     : Milli(),
-    'U'     : Micro(),
-    None    : None,
-
-    # Monthly - Calendar
-    'M'      : MonthEnd(),
-    'MS'     : MonthBegin(),
-
-    # Monthly - Business
-    'BM'     : BMonthEnd(),
-    'BMS'    : BMonthBegin(),
-
-    # Annual - Calendar
-    'A-JAN' : YearEnd(month=1),
-    'A-FEB' : YearEnd(month=2),
-    'A-MAR' : YearEnd(month=3),
-    'A-APR' : YearEnd(month=4),
-    'A-MAY' : YearEnd(month=5),
-    'A-JUN' : YearEnd(month=6),
-    'A-JUL' : YearEnd(month=7),
-    'A-AUG' : YearEnd(month=8),
-    'A-SEP' : YearEnd(month=9),
-    'A-OCT' : YearEnd(month=10),
-    'A-NOV' : YearEnd(month=11),
-    'A-DEC' : YearEnd(month=12),
-    'A'     : YearEnd(month=12),
-
-    # Annual - Calendar (start)
-    'AS-JAN' : YearBegin(month=1),
-    'AS'     : YearBegin(month=1),
-    'AS-FEB' : YearBegin(month=2),
-    'AS-MAR' : YearBegin(month=3),
-    'AS-APR' : YearBegin(month=4),
-    'AS-MAY' : YearBegin(month=5),
-    'AS-JUN' : YearBegin(month=6),
-    'AS-JUL' : YearBegin(month=7),
-    'AS-AUG' : YearBegin(month=8),
-    'AS-SEP' : YearBegin(month=9),
-    'AS-OCT' : YearBegin(month=10),
-    'AS-NOV' : YearBegin(month=11),
-    'AS-DEC' : YearBegin(month=12),
-    # Annual - Business
-    'BA-JAN' : BYearEnd(month=1),
-    'BA-FEB' : BYearEnd(month=2),
-    'BA-MAR' : BYearEnd(month=3),
-    'BA-APR' : BYearEnd(month=4),
-    'BA-MAY' : BYearEnd(month=5),
-    'BA-JUN' : BYearEnd(month=6),
-    'BA-JUL' : BYearEnd(month=7),
-    'BA-AUG' : BYearEnd(month=8),
-    'BA-SEP' : BYearEnd(month=9),
-    'BA-OCT' : BYearEnd(month=10),
-    'BA-NOV' : BYearEnd(month=11),
-    'BA-DEC' : BYearEnd(month=12),
-    'BA'     : BYearEnd(month=12),
-    # Annual - Business (Start)
-    'BAS-JAN' : BYearBegin(month=1),
-    'BAS'     : BYearBegin(month=1),
-    'BAS-FEB' : BYearBegin(month=2),
-    'BAS-MAR' : BYearBegin(month=3),
-    'BAS-APR' : BYearBegin(month=4),
-    'BAS-MAY' : BYearBegin(month=5),
-    'BAS-JUN' : BYearBegin(month=6),
-    'BAS-JUL' : BYearBegin(month=7),
-    'BAS-AUG' : BYearBegin(month=8),
-    'BAS-SEP' : BYearBegin(month=9),
-    'BAS-OCT' : BYearBegin(month=10),
-    'BAS-NOV' : BYearBegin(month=11),
-    'BAS-DEC' : BYearBegin(month=12),
-    # Quarterly - Calendar
-    # 'Q'     : QuarterEnd(startingMonth=3),
-
-    'Q-JAN' : QuarterEnd(startingMonth=1),
-    'Q-FEB' : QuarterEnd(startingMonth=2),
-    'Q-MAR' : QuarterEnd(startingMonth=3),
-    'Q-APR' : QuarterEnd(startingMonth=4),
-    'Q-MAY' : QuarterEnd(startingMonth=5),
-    'Q-JUN' : QuarterEnd(startingMonth=6),
-    'Q-JUL' : QuarterEnd(startingMonth=7),
-    'Q-AUG' : QuarterEnd(startingMonth=8),
-    'Q-SEP' : QuarterEnd(startingMonth=9),
-    'Q-OCT' : QuarterEnd(startingMonth=10),
-    'Q-NOV' : QuarterEnd(startingMonth=11),
-    'Q-DEC' : QuarterEnd(startingMonth=12),
-    # Quarterly - Calendar (Start)
-    # 'QS'     : QuarterBegin(startingMonth=1),
-
-    'QS-JAN' : QuarterBegin(startingMonth=1),
-    'QS-FEB' : QuarterBegin(startingMonth=2),
-    'QS-MAR' : QuarterBegin(startingMonth=3),
-    'QS-APR' : QuarterBegin(startingMonth=4),
-    'QS-MAY' : QuarterBegin(startingMonth=5),
-    'QS-JUN' : QuarterBegin(startingMonth=6),
-    'QS-JUL' : QuarterBegin(startingMonth=7),
-    'QS-AUG' : QuarterBegin(startingMonth=8),
-    'QS-SEP' : QuarterBegin(startingMonth=9),
-    'QS-OCT' : QuarterBegin(startingMonth=10),
-    'QS-NOV' : QuarterBegin(startingMonth=11),
-    'QS-DEC' : QuarterBegin(startingMonth=12),
-    # Quarterly - Business
-    'BQ-JAN' : BQuarterEnd(startingMonth=1),
-    'BQ-FEB' : BQuarterEnd(startingMonth=2),
-    'BQ-MAR' : BQuarterEnd(startingMonth=3),
-
-    # 'BQ'     : BQuarterEnd(startingMonth=3),
-
-    'BQ-APR' : BQuarterEnd(startingMonth=4),
-    'BQ-MAY' : BQuarterEnd(startingMonth=5),
-    'BQ-JUN' : BQuarterEnd(startingMonth=6),
-    'BQ-JUL' : BQuarterEnd(startingMonth=7),
-    'BQ-AUG' : BQuarterEnd(startingMonth=8),
-    'BQ-SEP' : BQuarterEnd(startingMonth=9),
-    'BQ-OCT' : BQuarterEnd(startingMonth=10),
-    'BQ-NOV' : BQuarterEnd(startingMonth=11),
-    'BQ-DEC' : BQuarterEnd(startingMonth=12),
-    # Quarterly - Business (Start)
-    'BQS-JAN' : BQuarterBegin(startingMonth=1),
-    'BQS'     : BQuarterBegin(startingMonth=1),
-    'BQS-FEB' : BQuarterBegin(startingMonth=2),
-    'BQS-MAR' : BQuarterBegin(startingMonth=3),
-    'BQS-APR' : BQuarterBegin(startingMonth=4),
-    'BQS-MAY' : BQuarterBegin(startingMonth=5),
-    'BQS-JUN' : BQuarterBegin(startingMonth=6),
-    'BQS-JUL' : BQuarterBegin(startingMonth=7),
-    'BQS-AUG' : BQuarterBegin(startingMonth=8),
-    'BQS-SEP' : BQuarterBegin(startingMonth=9),
-    'BQS-OCT' : BQuarterBegin(startingMonth=10),
-    'BQS-NOV' : BQuarterBegin(startingMonth=11),
-    'BQS-DEC' : BQuarterBegin(startingMonth=12),
-
-    # Weekly
-    'W-MON' : Week(weekday=0),
-    'W-TUE' : Week(weekday=1),
-    'W-WED' : Week(weekday=2),
-    'W-THU' : Week(weekday=3),
-    'W-FRI' : Week(weekday=4),
-    'W-SAT' : Week(weekday=5),
-    'W-SUN' : Week(weekday=6),
-
-    # Dunno about these
-
-    # 'WS'    : Week(weekday=0),
-    # 'BWS'   : Week(weekday=0),
-    # 'BW'    : Week(weekday=4),
-    # 'W'     : Week(weekday=6),
-}
-
-_rule_aliases = {
-    # Legacy rules that will continue to map to their original values
-    # essentially for the rest of time
-
-    'WEEKDAY': 'B',
-    'EOM': 'BM',
-
-    'W@MON': 'W-MON',
-    'W@TUE': 'W-TUE',
-    'W@WED': 'W-WED',
-    'W@THU': 'W-THU',
-    'W@FRI': 'W-FRI',
-    'W@SAT': 'W-SAT',
-    'W@SUN': 'W-SUN',
-
-    'Q@JAN': 'BQ-JAN',
-    'Q@FEB': 'BQ-FEB',
-    'Q@MAR': 'BQ-MAR',
-
-    'A@JAN' : 'BA-JAN',
-    'A@FEB' : 'BA-FEB',
-    'A@MAR' : 'BA-MAR',
-    'A@APR' : 'BA-APR',
-    'A@MAY' : 'BA-MAY',
-    'A@JUN' : 'BA-JUN',
-    'A@JUL' : 'BA-JUL',
-    'A@AUG' : 'BA-AUG',
-    'A@SEP' : 'BA-SEP',
-    'A@OCT' : 'BA-OCT',
-    'A@NOV' : 'BA-NOV',
-    'A@DEC' : 'BA-DEC',
-
-    # lite aliases
-    'Min': 'T',
-    'min': 'T',
-    'ms': 'L',
-    'us': 'U'
-}
-
-for i, weekday in enumerate(['MON', 'TUE', 'WED', 'THU', 'FRI']):
-    for iweek in xrange(4):
-        name = 'WOM-%d%s' % (iweek + 1, weekday)
-        _offset_map[name] = WeekOfMonth(week=iweek, weekday=i)
-        _rule_aliases[name.replace('-', '@')] = name
-
-_legacy_reverse_map = dict((v, k) for k, v in _rule_aliases.iteritems())
-
-# for helping out with pretty-printing and name-lookups
-
-_offset_names = {}
-for name, offset in _offset_map.iteritems():
-    if offset is None:
-        continue
-    offset.name = name
-    _offset_names[offset] = name
-
-
-def inferTimeRule(index):
-    if len(index) < 3:
-        raise Exception('Need at least three dates to infer time rule!')
-
-    first, second, third = index[:3]
-    items = _offset_map.iteritems()
-
-    for rule, offset in items:
-        if offset is None:
-            continue
-        if (first + offset) == second and (second + offset) == third:
-            return rule
-
-    raise Exception('Could not infer time rule from data!')
-
-opattern = re.compile(r'(\d*)\s*(\S+)')
-
-def to_offset(freqstr):
-    """
-    Return DateOffset object from string representation
-
-    Example
-    -------
-    to_offset('5Min') -> Minute(5)
-    """
-    if freqstr is None:
-        return None
-
-    if isinstance(freqstr, DateOffset):
-        return freqstr
-
-    if isinstance(freqstr, tuple):
-        name = freqstr[0]
-        stride = freqstr[1]
-        if isinstance(stride, basestring):
-            name, stride = stride, name
-        name, _ = _base_and_stride(name)
-    else:
-        name, stride = _base_and_stride(freqstr)
-
-    offset = get_offset(name)
-
-    return offset * stride
-
-def _base_and_stride(freqstr):
-    """
-    Return base freq and stride info from string representation
-
-    Example
-    -------
-    _freq_and_stride('5Min') -> 'Min', 5
-    """
-    groups = opattern.match(freqstr)
-
-    if groups.lastindex != 2:
-        raise ValueError("Could not evaluate %s" % freqstr)
-
-    stride = groups.group(1)
-
-    if len(stride):
-        stride = int(stride)
-    else:
-        stride = 1
-
-    base = groups.group(2)
-
-    return (base, stride)
-
-_dont_uppercase = ['MS', 'ms']
-
-def get_offset(name):
-    """
-    Return DateOffset object associated with rule name
-
-    Example
-    -------
-    get_offset('EOM') --> BMonthEnd(1)
-    """
-    if name not in _dont_uppercase:
-        name = name.upper()
-
-        if name in _rule_aliases:
-            name = _rule_aliases[name]
-        elif name.lower() in _rule_aliases:
-            name = _rule_aliases[name.lower()]
-    else:
-        if name in _rule_aliases:
-            name = _rule_aliases[name]
-
-    offset = _offset_map.get(name)
-
-    if offset is not None:
-        return offset
-    else:
-        raise Exception('Bad rule name requested: %s!' % name)
-
-
-getOffset = get_offset
-
-
-def hasOffsetName(offset):
-    return offset in _offset_names
-
-def get_offset_name(offset):
-    """
-    Return rule name associated with a DateOffset object
-
-    Example
-    -------
-    get_offset_name(BMonthEnd(1)) --> 'EOM'
-    """
-    name = _offset_names.get(offset)
-
-    if name is not None:
-        return name
-    else:
-        raise Exception('Bad rule given: %s!' % offset)
-
-def get_legacy_offset_name(offset):
-    """
-    Return the pre pandas 0.8.0 name for the date offset
-    """
-    name = _offset_names.get(offset)
-    return _legacy_reverse_map.get(name, name)
-
-get_offset_name = get_offset_name
-
-def get_standard_freq(freq):
-    """
-    Return the standardized frequency string
-    """
-    if freq is None:
-        return None
-
-    if isinstance(freq, DateOffset):
-        return get_offset_name(freq)
-
-    code, stride = _get_freq_code(freq)
-    return _get_freq_str(code, stride)
-
-def _infer_tzinfo(start, end):
-    def _infer(a, b):
-        tz = a.tzinfo
-        if b and b.tzinfo:
-            assert(tz == b.tzinfo)
-        return tz
-    tz = None
-    if start is not None:
-        tz = _infer(start, end)
-    elif end is not None:
-        tz = _infer(end, start)
-    return tz
-
-
-def _figure_out_timezone(start, end, tzinfo):
-    inferred_tz = _infer_tzinfo(start, end)
-    tz = inferred_tz
-    if inferred_tz is None and tzinfo is not None:
-        tz = tzinfo
-    elif tzinfo is not None:
-        assert(inferred_tz == tzinfo)
-        # make tz naive for now
-
-    if isinstance(tz, (str, unicode)):
-        import pytz
-        tz = pytz.timezone(tz)
-
-    start = start if start is None else start.replace(tzinfo=None)
-    end = end if end is None else end.replace(tzinfo=None)
-
-    return start, end, tz
-
-_CACHE_START = Timestamp(datetime(1950, 1, 1))
-_CACHE_END   = Timestamp(datetime(2030, 1, 1))
-
-_daterange_cache = {}
-
-def generate_range(start=None, end=None, periods=None,
-                   offset=BDay(), time_rule=None):
-    """
-    Generates a sequence of dates corresponding to the specified time
-    offset. Similar to dateutil.rrule except uses pandas DateOffset
-    objects to represent time increments
-
-    Parameters
-    ----------
-    start : datetime (default None)
-    end : datetime (default None)
-    periods : int, optional
-
-    Note
-    ----
-    * This method is faster for generating weekdays than dateutil.rrule
-    * At least two of (start, end, periods) must be specified.
-    * If both start and end are specified, the returned dates will
-    satisfy start <= date <= end.
-
-    Returns
-    -------
-    dates : generator object
-
-    """
-
-    if time_rule is not None:
-        offset = getOffset(time_rule)
-
-    start = to_datetime(start)
-    end = to_datetime(end)
-
-    if start and not offset.onOffset(start):
-        start = offset.rollforward(start)
-
-    if end and not offset.onOffset(end):
-        end = offset.rollback(end)
-
-        if periods is None and end < start:
-            end = None
-            periods = 0
-
-    if end is None:
-        end = start + (periods - 1) * offset
-
-    if start is None:
-        start = end - (periods - 1) * offset
-
-    cur = start
-
-    next_date = cur
-    while cur <= end:
-        yield cur
-
-        # faster than cur + offset
-        next_date = offset.apply(cur)
-        if next_date <= cur:
-            raise ValueError('Offset %s did not increment date' % offset)
-        cur = next_date
-
-def _naive_in_cache_range(start, end):
-    if start is None or end is None:
-        return False
-    else:
-        return _in_range(start, end, _CACHE_START, _CACHE_END)
-
-def _in_range(start, end, rng_start, rng_end):
-    return start > rng_start and end < rng_end
-
-def validate_end_alias(how):
-    how_dict = {'S': 'S', 'E': 'E',
-                'START': 'S', 'FINISH': 'E',
-                'BEGIN': 'S', 'END': 'E'}
-    how = how_dict.get(str(how).upper())
-    if how not in set(['S', 'E']):
-        raise ValueError('How must be one of S or E')
-    return how
+from pandas.tseries.tools import *
+from pandas.tseries.offsets import *
+from pandas.tseries.frequencies import *
diff --git a/pandas/core/factor.py b/pandas/core/factor.py
new file mode 100644
index 000000000..3ed5fdc15
--- /dev/null
+++ b/pandas/core/factor.py
@@ -0,0 +1,71 @@
+import numpy as np
+
+from pandas.core.index import Index
+import pandas._tseries as lib
+
+
+class Factor(np.ndarray):
+    """
+    Represents a categorical variable in classic R / S-plus fashion
+
+    Parameters
+    ----------
+    data : array-like
+
+    Returns
+    -------
+    **Attributes**
+      * labels : ndarray
+      * levels : ndarray
+    """
+    def __new__(cls, data):
+        data = np.asarray(data, dtype=object)
+        levels, factor = unique_with_labels(data)
+        factor = factor.view(Factor)
+        factor.levels = levels
+        return factor
+
+    levels = None
+
+    def __array_finalize__(self, obj):
+        self.levels = getattr(obj, 'levels', None)
+
+    @property
+    def labels(self):
+        return self.view(np.ndarray)
+
+    def asarray(self):
+        return np.asarray(self.levels).take(self.labels)
+
+    def __len__(self):
+        return len(self.labels)
+
+    def __repr__(self):
+        temp = 'Factor:\n%s\nLevels (%d): %s'
+        values = self.asarray()
+        return temp % (repr(values), len(self.levels), self.levels)
+
+    def __getitem__(self, key):
+        if isinstance(key, (int, np.integer)):
+            i = self.labels[key]
+            return self.levels[i]
+        else:
+            return np.ndarray.__getitem__(self, key)
+
+
+def unique_with_labels(values):
+    rizer = lib.Factorizer(len(values))
+    labels, _ = rizer.factorize(values, sort=False)
+    uniques = Index(rizer.uniques)
+
+    try:
+        sorter = uniques.argsort()
+        reverse_indexer = np.empty(len(sorter), dtype='i4')
+        reverse_indexer.put(sorter, np.arange(len(sorter)))
+        labels = reverse_indexer.take(labels)
+        uniques = uniques.take(sorter)
+    except TypeError:
+        pass
+
+    return uniques, labels
+
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index a9f656399..2c9e28109 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2944,7 +2944,7 @@ class DataFrame(NDFrame):
         -------
         converted : DataFrame
         """
-        from pandas.core.daterange import date_range
+        from pandas.tseries.index import date_range
         if len(self.index) == 0:
             return self.copy()
         dti = date_range(self.index[0], self.index[-1], freq=freq)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 49a392a7b..4650a2592 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1,7 +1,7 @@
 # pylint: disable=E1101,E1103,W0232
 
-from datetime import time, datetime
-from datetime import timedelta
+from datetime import time
+
 from itertools import izip
 import weakref
 
@@ -12,12 +12,6 @@ import pandas.core.common as com
 import pandas._tseries as lib
 import pandas._engines as _gin
 
-from pandas._tseries import Timestamp
-
-import pandas.core.datetools as datetools
-from pandas.core.datetools import (_dt_box, _dt_unbox, _dt_box_array,
-                                   _dt_unbox_array, to_timestamp, Interval,
-                                   _skts_unbox_array, _skts_box, to_interval)
 
 __all__ = ['Index']
 
@@ -839,1657 +833,232 @@ class Index(np.ndarray):
             join_index = left
             left_indexer = None
 
-        if right_lev_indexer is not None:
-            right_indexer = right_lev_indexer.take(join_index.labels[level])
-        else:
-            right_indexer = join_index.labels[level]
-
-        if flip_order:
-            left_indexer, right_indexer = right_indexer, left_indexer
-
-        if return_indexers:
-            return join_index, left_indexer, right_indexer
-        else:
-            return join_index
-
-    def _join_monotonic(self, other, how='left', return_indexers=False):
-        if self.equals(other):
-            ret_index = other if how == 'right' else self
-            if return_indexers:
-                return ret_index, None, None
-            else:
-                return ret_index
-
-        if how == 'left':
-            join_index = self
-            lidx = None
-            ridx = self._left_indexer(self, other)
-        elif how == 'right':
-            join_index = other
-            lidx = self._left_indexer(other, self)
-            ridx = None
-        elif how == 'inner':
-            join_index, lidx, ridx = self._inner_indexer(self.values,
-                                                         other.values)
-            join_index = self._wrap_joined_index(join_index, other)
-        elif how == 'outer':
-            join_index, lidx, ridx = self._outer_indexer(self.values,
-                                                         other.values)
-            join_index = self._wrap_joined_index(join_index, other)
-
-        if return_indexers:
-            return join_index, lidx, ridx
-        else:
-            return join_index
-
-    def _wrap_joined_index(self, joined, other):
-        name = self.name if self.name == other.name else None
-        return Index(joined, name=name)
-
-    def slice_locs(self, start=None, end=None):
-        """
-        For an ordered Index, compute the slice locations for input labels
-
-        Parameters
-        ----------
-        start : label, default None
-            If None, defaults to the beginning
-        end : label
-            If None, defaults to the end
-
-        Returns
-        -------
-        (begin, end) : (int, int)
-
-        Notes
-        -----
-        This function assumes that the data is sorted, so use at your own peril
-        """
-        if start is None:
-            beg_slice = 0
-        else:
-            try:
-                beg_slice = self.get_loc(start)
-            except KeyError:
-                if self.is_monotonic:
-                    beg_slice = self.searchsorted(start, side='left')
-                else:
-                    raise
-
-        if end is None:
-            end_slice = len(self)
-        else:
-            try:
-                end_slice = self.get_loc(end) + 1
-            except KeyError:
-                if self.is_monotonic:
-                    end_slice = self.searchsorted(end, side='right')
-                else:
-                    raise
-
-        return beg_slice, end_slice
-
-    def delete(self, loc):
-        """
-        Make new Index with passed location deleted
-
-        Returns
-        -------
-        new_index : Index
-        """
-        arr = np.delete(np.asarray(self), loc)
-        return Index(arr)
-
-    def insert(self, loc, item):
-        """
-        Make new Index inserting new item at location
-
-        Parameters
-        ----------
-        loc : int
-        item : object
-
-        Returns
-        -------
-        new_index : Index
-        """
-        index = np.asarray(self)
-        # because numpy is fussy with tuples
-        item_idx = Index([item], dtype=index.dtype)
-        new_index = np.concatenate((index[:loc], item_idx, index[loc:]))
-        return Index(new_index, name=self.name)
-
-    def drop(self, labels):
-        """
-        Make new Index with passed list of labels deleted
-
-        Parameters
-        ----------
-        labels : array-like
-
-        Returns
-        -------
-        dropped : Index
-        """
-        labels = np.asarray(list(labels), dtype=object)
-        indexer = self.get_indexer(labels)
-        mask = indexer == -1
-        if mask.any():
-            raise ValueError('labels %s not contained in axis' % labels[mask])
-        return self.delete(indexer)
-
-    def copy(self, order='C'):
-        """
-        Overridden ndarray.copy to copy over attributes
-
-        Returns
-        -------
-        cp : Index
-            Returns view on same base ndarray
-        """
-        cp = self.view(np.ndarray).view(type(self))
-        cp.__dict__.update(self.__dict__)
-        return cp
-
-
-class Int64Index(Index):
-
-    _groupby = lib.groupby_int64
-    _arrmap = lib.arrmap_int64
-    _left_indexer = lib.left_join_indexer_int64
-    _inner_indexer = lib.inner_join_indexer_int64
-    _outer_indexer = lib.outer_join_indexer_int64
-
-    _engine_type = _gin.Int64Engine
-
-    def __new__(cls, data, dtype=None, copy=False, name=None):
-        if not isinstance(data, np.ndarray):
-            if np.isscalar(data):
-                raise ValueError('Index(...) must be called with a collection '
-                                 'of some kind, %s was passed' % repr(data))
-
-            # other iterable of some kind
-            if not isinstance(data, (list, tuple)):
-                data = list(data)
-            data = np.asarray(data)
-
-        if issubclass(data.dtype.type, basestring):
-            raise TypeError('String dtype not supported, you may need '
-                            'to explicitly cast to int')
-        elif issubclass(data.dtype.type, np.integer):
-            subarr = np.array(data, dtype=np.int64, copy=copy)
-        else:
-            subarr = np.array(data, dtype=np.int64, copy=copy)
-            if len(data) > 0:
-                if (subarr != data).any():
-                    raise TypeError('Unsafe NumPy casting, you must '
-                                    'explicitly cast')
-
-        subarr = subarr.view(cls)
-        subarr.name = name
-        return subarr
-
-    @property
-    def inferred_type(self):
-        return 'integer'
-
-    @property
-    def _constructor(self):
-        return Int64Index
-
-    @property
-    def dtype(self):
-        return np.dtype('int64')
-
-    @property
-    def is_all_dates(self):
-        """
-        Checks that all the labels are datetime objects
-        """
-        return False
-
-    def equals(self, other):
-        """
-        Determines if two Index objects contain the same elements.
-        """
-        if self is other:
-            return True
-
-        # if not isinstance(other, Int64Index):
-        #     return False
-
-        return np.array_equal(self, other)
-
-    def _wrap_joined_index(self, joined, other):
-        name = self.name if self.name == other.name else None
-        return Int64Index(joined, name=name)
-
-# -------- some conversion wrapper functions
-
-def _as_i8(arg):
-    if isinstance(arg, np.ndarray) and arg.dtype == np.datetime64:
-        return arg.view('i8', type=np.ndarray)
-    else:
-        return arg
-
-def _wrap_i8_function(f):
-    @staticmethod
-    def wrapper(*args, **kwargs):
-        view_args = [_as_i8(arg) for arg in args]
-        return f(*view_args, **kwargs)
-    return wrapper
-
-def _wrap_dt_function(f):
-    @staticmethod
-    def wrapper(*args, **kwargs):
-        view_args = [_dt_box_array(_as_i8(arg)) for arg in args]
-        return f(*view_args, **kwargs)
-    return wrapper
-
-def _join_i8_wrapper(joinf, with_indexers=True):
-    @staticmethod
-    def wrapper(left, right):
-        if isinstance(left, np.ndarray):
-            left = left.view('i8', type=np.ndarray)
-        if isinstance(right, np.ndarray):
-            right = right.view('i8', type=np.ndarray)
-        results = joinf(left, right)
-        if with_indexers:
-            join_index, left_indexer, right_indexer = results
-            join_index = join_index.view('M8')
-            return join_index, left_indexer, right_indexer
-        return results
-    return wrapper
-
-def _dt_index_cmp(opname):
-    """
-    Wrap comparison operations to unbox datetime-like to a datetime64.
-    """
-    def wrapper(self, other):
-        if isinstance(other, datetime):
-            func = getattr(self, opname)
-            result = func(_dt_unbox(other))
-        elif isinstance(other, np.ndarray):
-            func = getattr(super(DatetimeIndex, self), opname)
-            result = func(other)
-        else:
-            other = _ensure_datetime64(other)
-            func = getattr(super(DatetimeIndex, self), opname)
-            result = func(other)
-        try:
-            return result.view(np.ndarray)
-        except:
-            return result
-    return wrapper
-
-def _ensure_datetime64(other):
-    if isinstance(other, np.datetime64):
-        return other
-    elif com.is_integer(other):
-        return np.datetime64(other)
-    else:
-        raise TypeError(other)
-
-def _dt_index_op(opname):
-    """
-    Wrap arithmetic operations to unbox a timedelta to a timedelta64.
-    """
-    def wrapper(self, other):
-        if isinstance(other, timedelta):
-            func = getattr(self, opname)
-            return func(np.timedelta64(other))
-        else:
-            func = getattr(super(DatetimeIndex, self), opname)
-            return func(other)
-    return wrapper
-
-def _ensure_compat_concat(indexes):
-    is_m8 = [isinstance(idx, DatetimeIndex) for idx in indexes]
-    if any(is_m8) and not all(is_m8):
-        return [_maybe_box_dtindex(idx) for idx in indexes]
-    return indexes
-
-
-def _maybe_box_dtindex(idx):
-    if isinstance(idx, DatetimeIndex):
-        return Index(_dt_box_array(idx.asi8), dtype='object')
-    return idx
-
-_midnight = time(0, 0)
-
-class DatetimeIndex(Int64Index):
-    """
-    Immutable ndarray of datetime64 data, represented internally as int64, and
-    which can be boxed to Timestamp objects that are subclasses of datetime and
-    carry metadata such as frequency information.
-
-    Parameters
-    ----------
-    data  : array-like (1-dimensional), optional
-        Optional datetime-like data to construct index with
-    dtype : NumPy dtype (default: M8[us])
-    copy  : bool
-        Make a copy of input ndarray
-    freq : string or pandas offset object, optional
-        One of pandas date offset strings or corresponding objects
-    start : starting value, datetime-like, optional
-        If data is None, start is used as the start point in generating regular
-        timestamp data.
-    periods  : int, optional, > 0
-        Number of periods to generate, if generating index. Takes precedence
-        over end argument
-    end   : end time, datetime-like, optional
-        If periods is none, generated index will extend to first conforming
-        time on or just past end argument
-    """
-
-    _inner_indexer = _join_i8_wrapper(lib.inner_join_indexer_int64)
-    _outer_indexer = _join_i8_wrapper(lib.outer_join_indexer_int64)
-    _left_indexer  = _join_i8_wrapper(lib.left_join_indexer_int64,
-                                      with_indexers=False)
-    _groupby = lib.groupby_arrays # _wrap_i8_function(lib.groupby_int64)
-
-    _arrmap = _wrap_dt_function(lib.arrmap_object)
-
-    __eq__ = _dt_index_cmp('__eq__')
-    __ne__ = _dt_index_cmp('__ne__')
-    __lt__ = _dt_index_cmp('__lt__')
-    __gt__ = _dt_index_cmp('__gt__')
-    __le__ = _dt_index_cmp('__le__')
-    __ge__ = _dt_index_cmp('__ge__')
-
-    __add__ = _dt_index_op('__add__')
-    __sub__ = _dt_index_op('__sub__')
-
-    # structured array cache for datetime fields
-    _sarr_cache = None
-
-    _engine_type = _gin.DatetimeEngine
-
-    offset = None
-
-    def __new__(cls, data=None,
-                freq=None, start=None, end=None, periods=None,
-                dtype=None, copy=False, name=None, tz=None,
-                verify_integrity=True, normalize=False, **kwds):
-
-        warn = False
-        if 'offset' in kwds and kwds['offset']:
-            freq = kwds['offset']
-            warn = True
-
-        if not isinstance(freq, datetools.DateOffset):
-            freq = datetools.to_offset(freq)
-
-        if warn:
-            import warnings
-            warnings.warn("parameter 'offset' is deprecated, "
-                          "please use 'freq' instead",
-                          FutureWarning)
-            if isinstance(freq, basestring):
-                freq = datetools.get_offset(freq)
-        else:
-            if isinstance(freq, basestring):
-                freq = datetools.to_offset(freq)
-
-        offset = freq
-
-        if data is None and offset is None:
-            raise ValueError("Must provide freq argument if no data is "
-                             "supplied")
-
-        if data is None:
-            _normalized = True
-
-            if start is not None:
-                start = datetools.to_timestamp(start)
-                if not isinstance(start, Timestamp):
-                    raise ValueError('Failed to convert %s to timestamp'
-                                     % start)
-
-                if normalize:
-                    start = datetools.normalize_date(start)
-                    _normalized = True
-                else:
-                    _normalized = _normalized and start.time() == _midnight
-
-            if end is not None:
-                end = datetools.to_timestamp(end)
-                if not isinstance(end, Timestamp):
-                    raise ValueError('Failed to convert %s to timestamp'
-                                     % end)
-
-                if normalize:
-                    end = datetools.normalize_date(end)
-                    _normalized = True
-                else:
-                    _normalized = _normalized and end.time() == _midnight
-
-            start, end, tz = datetools._figure_out_timezone(start, end, tz)
-
-            if (offset._should_cache() and
-                not (offset._normalize_cache and not _normalized) and
-                datetools._naive_in_cache_range(start, end)):
-                index = cls._cached_range(start, end, periods=periods,
-                                          offset=offset, name=name)
-            else:
-                if isinstance(offset, datetools.Tick):
-                    if periods is None:
-                        b, e = Timestamp(start), Timestamp(end)
-                        data = np.arange(b.value, e.value+1,
-                                        offset.us_stride(), dtype=np.int64)
-                    else:
-                        b = Timestamp(start)
-                        e = b.value + periods * offset.us_stride()
-                        data = np.arange(b.value, e,
-                                         offset.us_stride(), dtype=np.int64)
-
-                else:
-                    xdr = datetools.generate_range(start=start, end=end,
-                        periods=periods, offset=offset)
-
-                    data = _dt_unbox_array(list(xdr))
-
-                index = np.array(data, dtype=np.datetime64, copy=False)
-
-            index = index.view(cls)
-            index.name = name
-            index.offset = offset
-            index.tz = tz
-
-            return index
-
-        if not isinstance(data, np.ndarray):
-            if np.isscalar(data):
-                raise ValueError('DatetimeIndex() must be called with a '
-                                 'collection of some kind, %s was passed'
-                                 % repr(data))
-
-            if isinstance(data, datetime):
-                data = [data]
-
-            # other iterable of some kind
-            if not isinstance(data, (list, tuple)):
-                data = list(data)
-
-            data = np.asarray(data, dtype='O')
-
-            # try a few ways to make it datetime64
-            if lib.is_string_array(data):
-                data = datetools._str_to_dt_array(data)
-            else:
-                data = np.asarray(data, dtype='M8[us]')
-
-        if issubclass(data.dtype.type, basestring):
-            subarr = datetools._str_to_dt_array(data)
-        elif issubclass(data.dtype.type, np.integer):
-            subarr = np.array(data, dtype='M8[us]', copy=copy)
-        elif issubclass(data.dtype.type, np.datetime64):
-            subarr = np.array(data, dtype='M8[us]', copy=copy)
-        else:
-            subarr = np.array(data, dtype='M8[us]', copy=copy)
-
-        # TODO: this is horribly inefficient. If user passes data + offset, we
-        # need to make sure data points conform. Punting on this
-
-        if verify_integrity:
-            if offset is not None:
-                for i, ts in enumerate(subarr):
-                    if not offset.onOffset(Timestamp(ts)):
-                        val = Timestamp(offset.rollforward(ts)).value
-                        subarr[i] = val
-
-        subarr = subarr.view(cls)
-        subarr.name = name
-        subarr.offset = offset
-        subarr.tz = tz
-
-        return subarr
-
-    @classmethod
-    def _simple_new(cls, values, name, offset, tz):
-        result = values.view(cls)
-        result.name = name
-        result.offset = offset
-        result.tz = tz
-
-        return result
-
-    @property
-    def tzinfo(self):
-        """
-        Alias for tz attribute
-        """
-        return self.tz
-
-    @classmethod
-    def _cached_range(cls, start=None, end=None, periods=None, offset=None,
-                      name=None):
-        if start is not None:
-            start = Timestamp(start)
-        if end is not None:
-            end = Timestamp(end)
-
-        if offset is None:
-            raise Exception('Must provide a DateOffset!')
-
-        drc = datetools._daterange_cache
-        if offset not in drc:
-            xdr = datetools.generate_range(offset=offset,
-                    start=datetools._CACHE_START, end=datetools._CACHE_END)
-
-            arr = np.array(_dt_unbox_array(list(xdr)),
-                           dtype='M8[us]', copy=False)
-
-            cachedRange = arr.view(DatetimeIndex)
-            cachedRange.offset = offset
-            cachedRange.tz = None
-            cachedRange.name = None
-            drc[offset] = cachedRange
-        else:
-            cachedRange = drc[offset]
-
-        if start is None:
-            if end is None:
-                raise Exception('Must provide start or end date!')
-            if periods is None:
-                raise Exception('Must provide number of periods!')
-
-            assert(isinstance(end, Timestamp))
-
-            end = offset.rollback(end)
-
-            endLoc = cachedRange.get_loc(end) + 1
-            startLoc = endLoc - periods
-        elif end is None:
-            assert(isinstance(start, Timestamp))
-            start = offset.rollforward(start)
-
-            startLoc = cachedRange.get_loc(start)
-            if periods is None:
-                raise Exception('Must provide number of periods!')
-
-            endLoc = startLoc + periods
-        else:
-            if not offset.onOffset(start):
-                start = offset.rollforward(start)
-
-            if not offset.onOffset(end):
-                end = offset.rollback(end)
-
-            startLoc = cachedRange.get_loc(start)
-            endLoc = cachedRange.get_loc(end) + 1
-
-        indexSlice = cachedRange[startLoc:endLoc]
-        indexSlice.name = name
-        indexSlice.offset = offset
-
-        return indexSlice
-
-    def _mpl_repr(self):
-        # how to represent ourselves to matplotlib
-        return self.values.astype('O')
-
-    def __repr__(self):
-        if self.offset is not None:
-            output = str(self.__class__) + '\n'
-            output += 'freq: %s, timezone: %s\n' % (self.offset, self.tz)
-            if len(self) > 0:
-                output += '[%s, ..., %s]\n' % (self[0], self[-1])
-            output += 'length: %d' % len(self)
-            return output
-        else:
-            return super(DatetimeIndex, self).__repr__()
-
-    __str__ = __repr__
-
-    def __reduce__(self):
-        """Necessary for making this object picklable"""
-        object_state = list(np.ndarray.__reduce__(self))
-        subclass_state = self.name, self.offset, self.tz
-        object_state[2] = (object_state[2], subclass_state)
-        return tuple(object_state)
-
-    def __setstate__(self, state):
-        """Necessary for making this object picklable"""
-        if len(state) == 2:
-            nd_state, own_state = state
-            self.name = own_state[0]
-            self.offset = own_state[1]
-            self.tz = own_state[2]
-            np.ndarray.__setstate__(self, nd_state)
-        elif len(state) == 3:
-            # legacy format: daterange
-            offset = state[1]
-
-            if len(state) > 2:
-                tzinfo = state[2]
-            else: # pragma: no cover
-                tzinfo = None
-
-            self.offset = offset
-            self.tzinfo = tzinfo
-
-            # extract the raw datetime data, turn into datetime64
-            index_state = state[0]
-            raw_data = index_state[0][4]
-            raw_data = np.array(raw_data, dtype='M8[us]')
-            new_state = raw_data.__reduce__()
-            np.ndarray.__setstate__(self, new_state[2])
-        else:  # pragma: no cover
-            np.ndarray.__setstate__(self, state)
-
-    def __add__(self, other):
-        if isinstance(other, Index):
-            return self.union(other)
-        elif isinstance(other, (datetools.DateOffset, timedelta)):
-            new_values = self.astype('O') + other
-            return DatetimeIndex(new_values, tz=self.tz)
-        else:
-            return Index(self.view(np.ndarray) + other)
-
-    @property
-    def asi8(self):
-        # do not cache or you'll create a memory leak
-        return self.values.view('i8')
-
-    @property
-    def asstruct(self):
-        if self._sarr_cache is None:
-            self._sarr_cache = lib.build_field_sarray(self.asi8)
-        return self._sarr_cache
-
-    @property
-    def asobject(self):
-        """
-        Unbox to an index of type object
-        """
-        boxed_values = _dt_box_array(self.asi8, self.offset, self.tz)
-        return Index(boxed_values, dtype=object)
-
-    def to_interval(self, freq=None):
-        """
-        Cast to IntervalIndex at a particular frequency
-        """
-        if self.freq is None and freq is None:
-            msg = "You must pass a freq argument as current index has none."
-            raise ValueError(msg)
-
-        if freq is None:
-            freq = self.freq
-
-        return IntervalIndex(self.values, freq=freq)
-
-    def snap(self, freq='S'):
-        """
-        Snap time stamps to nearest occuring frequency
-
-        """
-        # Superdumb, punting on any optimizing
-        freq = datetools.to_offset(freq)
-
-        snapped = np.empty(len(self), dtype='M8[us]')
-
-        for i, v in enumerate(self):
-            s = v
-            if not freq.onOffset(s):
-                t0 = freq.rollback(s)
-                t1 = freq.rollforward(s)
-                if abs(s - t0) < abs(t1 - s):
-                    s = t0
-                else:
-                    s = t1
-            snapped[i] = np.datetime64(s)
-
-        # we know it conforms; skip check
-        return DatetimeIndex(snapped, freq=freq, verify_integrity=False)
-
-    def shift(self, n, freq=None):
-        """
-        Specialized shift which produces a DatetimeIndex
-
-        Parameters
-        ----------
-        n : int
-            Periods to shift by
-        freq : DateOffset or timedelta-like, optional
-
-        Returns
-        -------
-        shifted : DatetimeIndex
-        """
-        if freq is not None and freq != self.offset:
-            if isinstance(freq, basestring):
-                freq = datetools.to_offset(freq)
-            return Index.shift(self, n, freq)
-
-        if n == 0:
-            # immutable so OK
-            return self
-
-        if self.offset is None:
-            raise ValueError("Cannot shift with no offset")
-
-        start = self[0] + n * self.offset
-        end = self[-1] + n * self.offset
-        return DatetimeIndex(start=start, end=end, freq=self.offset,
-                             name=self.name)
-
-    def union(self, other):
-        """
-        Specialized union for DatetimeIndex objects. If combine
-        overlapping ranges with the same DateOffset, will be much
-        faster than Index.union
-
-        Parameters
-        ----------
-        other : DatetimeIndex or array-like
-
-        Returns
-        -------
-        y : Index or DatetimeIndex
-        """
-        if self._can_fast_union(other):
-            return self._fast_union(other)
-        else:
-            return Index.union(self, other)
-
-    def join(self, other, how='left', level=None, return_indexers=False):
-        """
-        See Index.join
-        """
-        if not isinstance(other, DatetimeIndex) and len(other) > 0:
-            try:
-                other = DatetimeIndex(other)
-            except ValueError:
-                pass
-
-        return Index.join(self, other, how=how, level=level,
-                          return_indexers=return_indexers)
-
-
-    def _wrap_joined_index(self, joined, other):
-        name = self.name if self.name == other.name else None
-        if (isinstance(other, DatetimeIndex)
-            and self.offset == other.offset
-            and self._can_fast_union(other)):
-            joined = self._view_like(joined)
-            joined.name = name
-            return joined
-        else:
-            return DatetimeIndex(joined, name=name)
-
-    def _can_fast_union(self, other):
-        if not isinstance(other, DatetimeIndex):
-            return False
-
-        offset = self.offset
-
-        if offset is None:
-            return False
-
-        if len(other) == 0:
-            return True
-
-        # to make our life easier, "sort" the two ranges
-        if self[0] <= other[0]:
-            left, right = self, other
-        else:
-            left, right = other, self
-
-        left_end = left[-1]
-        right_start = right[0]
-
-        # Only need to "adjoin", not overlap
-        return (left_end + offset) >= right_start
-
-    def _fast_union(self, other):
-        if len(other) == 0:
-            return self.view(type(self))
-
-        # to make our life easier, "sort" the two ranges
-        if self[0] <= other[0]:
-            left, right = self, other
-        else:
-            left, right = other, self
-
-        left_start, left_end = left[0], left[-1]
-        right_end = right[-1]
-
-        if not self.offset._should_cache():
-            # concatenate dates
-            if left_end < right_end:
-                loc = right.searchsorted(left_end, side='right')
-                right_chunk = right.values[loc:]
-                dates = np.concatenate((left.values, right_chunk))
-                return self._view_like(dates)
-            else:
-                return left
-        else:
-            return type(self)(start=left_start,
-                              end=max(left_end, right_end),
-                              freq=left.offset)
-
-    def __array_finalize__(self, obj):
-        if self.ndim == 0: # pragma: no cover
-            return self.item()
-
-        self.offset = getattr(obj, 'offset', None)
-        self.tz = getattr(obj, 'tz', None)
-
-    def intersection(self, other):
-        """
-        Specialized intersection for DatetimeIndex objects. May be much faster
-        than Index.union
-
-        Parameters
-        ----------
-        other : DatetimeIndex or array-like
-
-        Returns
-        -------
-        y : Index or DatetimeIndex
-        """
-        if not isinstance(other, DatetimeIndex):
-            try:
-                other = DatetimeIndex(other)
-            except TypeError:
-                pass
-            return Index.intersection(self, other)
-        elif other.offset != self.offset:
-            return Index.intersection(self, other)
-
-        # to make our life easier, "sort" the two ranges
-        if self[0] <= other[0]:
-            left, right = self, other
-        else:
-            left, right = other, self
-
-        end = min(left[-1], right[-1])
-        start = right[0]
-
-        if end < start:
-            return type(self)(data=[])
-        else:
-            lslice = slice(*left.slice_locs(start, end))
-            left_chunk = left.values[lslice]
-            return self._view_like(left_chunk)
-
-    def _partial_date_slice(self, reso, parsed):
-        if reso == 'year':
-            t1 = to_timestamp(datetime(parsed.year, 1, 1))
-            t2 = to_timestamp(datetime(parsed.year, 12, 31))
-        elif reso == 'month':
-            d = lib.monthrange(parsed.year, parsed.month)[1]
-            t1 = to_timestamp(datetime(parsed.year, parsed.month, 1))
-            t2 = to_timestamp(datetime(parsed.year, parsed.month, d))
-        elif reso == 'quarter':
-            qe = (((parsed.month - 1) + 2) % 12) + 1 # two months ahead
-            d = lib.monthrange(parsed.year, qe)[1]   # at end of month
-            t1 = to_timestamp(datetime(parsed.year, parsed.month, 1))
-            t2 = to_timestamp(datetime(parsed.year, qe, d))
-        else:
-            raise KeyError
-
-        stamps = self.asi8
-        left = stamps.searchsorted(t1.value, side='left')
-        right = stamps.searchsorted(t2.value, side='right')
-        return slice(left, right)
-
-    def get_value(self, series, key):
-        """
-        Fast lookup of value from 1-dimensional ndarray. Only use this if you
-        know what you're doing
-        """
-        try:
-            return Index.get_value(self, series, key)
-        except KeyError:
-
-            try:
-                asdt, parsed, reso = datetools.parse_time_string(key)
-                key = asdt
-                loc = self._partial_date_slice(reso, parsed)
-                return series[loc]
-            except (TypeError, ValueError, KeyError):
-                pass
-
-            return self._engine.get_value(series, to_timestamp(key))
-
-    def get_loc(self, key):
-        """
-        Get integer location for requested label
-
-        Returns
-        -------
-        loc : int
-        """
-        try:
-            return self._engine.get_loc(key)
-        except KeyError:
-            try:
-                return self._get_string_slice(key)
-            except (TypeError, KeyError):
-                pass
-
-            return self._engine.get_loc(to_timestamp(key))
-
-    def _get_string_slice(self, key):
-        asdt, parsed, reso = datetools.parse_time_string(key)
-        key = asdt
-        loc = self._partial_date_slice(reso, parsed)
-        return loc
-
-    def slice_locs(self, start=None, end=None):
-        """
-        Index.slice_locs, customized to handle partial ISO-8601 string slicing
-        """
-        if isinstance(start, basestring) or isinstance(end, basestring):
-            try:
-                if start:
-                    start_loc = self._get_string_slice(start).start
-                else:
-                    start_loc = 0
-
-                if end:
-                    end_loc = self._get_string_slice(end).stop
-                else:
-                    end_loc = len(self)
-
-                return start_loc, end_loc
-            except KeyError:
-                pass
-
-        return Index.slice_locs(self, start, end)
-
-    def __getitem__(self, key):
-        """Override numpy.ndarray's __getitem__ method to work as desired"""
-        arr_idx = self.view(np.ndarray)
-        if np.isscalar(key):
-            val = arr_idx[key]
-            return _dt_box(val, offset=self.offset, tz=self.tz)
-        else:
-            if com._is_bool_indexer(key):
-                key = np.asarray(key)
-                key = lib.maybe_booleans_to_slice(key)
-
-            new_offset = None
-            if isinstance(key, slice):
-                if self.offset is not None and key.step is not None:
-                    new_offset = key.step * self.offset
-                else:
-                    new_offset = self.offset
-
-            result = arr_idx[key]
-            if result.ndim > 1:
-                return result
-
-            return self._simple_new(result, self.name, new_offset, self.tz)
-
-    # Try to run function on index first, and then on elements of index
-    # Especially important for group-by functionality
-    def map(self, f):
-        try:
-            return f(self)
-        except:
-            return Index.map(self, f)
-
-    # alias to offset
-    @property
-    def freq(self):
-        return self.offset
-
-    # Fast field accessors for periods of datetime index
-    # --------------------------------------------------------------
-
-    @property
-    def year(self):
-        return lib.fast_field_accessor(self.asi8, 'Y')
-
-    @property
-    def month(self):
-        return lib.fast_field_accessor(self.asi8, 'M')
-
-    @property
-    def day(self):
-        return lib.fast_field_accessor(self.asi8, 'D')
-
-    @property
-    def hour(self):
-        return lib.fast_field_accessor(self.asi8, 'h')
-
-    @property
-    def minute(self):
-        return lib.fast_field_accessor(self.asi8, 'm')
-
-    @property
-    def second(self):
-        return lib.fast_field_accessor(self.asi8, 's')
-
-    @property
-    def microsecond(self):
-        return lib.fast_field_accessor(self.asi8, 'us')
-
-    @property
-    def weekofyear(self):
-        return lib.fast_field_accessor(self.asi8, 'woy')
-
-    @property
-    def dayofweek(self):
-        return lib.fast_field_accessor(self.asi8, 'dow')
-
-    @property
-    def dayofyear(self):
-        return lib.fast_field_accessor(self.asi8, 'doy')
-
-    @property
-    def quarter(self):
-        return lib.fast_field_accessor(self.asi8, 'q')
-
-    def __iter__(self):
-        return iter(self.asobject)
-
-    def searchsorted(self, key, side='left'):
-        if isinstance(key, np.ndarray):
-            key = np.array(key, dtype='M8[us]', copy=False)
-        else:
-            key = _dt_unbox(key)
-
-        return self.values.searchsorted(key, side=side)
-
-    def is_type_compatible(self, typ):
-        return typ == self.inferred_type or typ == 'datetime'
-
-    # hack to workaround argmin failure
-    def argmin(self):
-        return (-self).argmax()
-
-    @property
-    def inferred_type(self):
-        # b/c datetime is represented as microseconds since the epoch, make
-        # sure we can't have ambiguous indexing
-        return 'datetime64'
-
-    @property
-    def _constructor(self):
-        return DatetimeIndex
-
-    @property
-    def dtype(self):
-        return np.dtype('M8')
-
-    @property
-    def is_all_dates(self):
-        return True
-
-    def equals(self, other):
-        """
-        Determines if two Index objects contain the same elements.
-        """
-        if self is other:
-            return True
-
-        if (not hasattr(other, 'inferred_type') or
-            other.inferred_type != 'datetime64'):
-            if self.offset is not None:
-                return False
-            try:
-                other = DatetimeIndex(other)
-            except:
-                return False
-
-        return np.array_equal(self.asi8, other.asi8)
-
-    def insert(self, loc, item):
-        """
-        Make new Index inserting new item at location
-
-        Parameters
-        ----------
-        loc : int
-        item : object
-
-        Returns
-        -------
-        new_index : Index
-        """
-        if type(item) == datetime:
-            item = _dt_unbox(item)
-
-        if self.offset is not None and not self.offset.onOffset(item):
-            raise ValueError("Cannot insert value at non-conforming time")
-
-        return super(DatetimeIndex, self).insert(loc, item)
-
-    def _view_like(self, ndarray):
-        result = ndarray.view(type(self))
-        result.offset = self.offset
-        result.tz = self.tz
-        result.name = self.name
-        return result
-
-    def tz_normalize(self, tz):
-        """
-        Convert DatetimeIndex from one time zone to another (using pytz)
-
-        Returns
-        -------
-        normalized : DatetimeIndex
-        """
-        new_dates = lib.tz_normalize_array(self.asi8, self.tz, tz)
-        new_dates = new_dates.view('M8[us]')
-        new_dates = new_dates.view(self.__class__)
-        new_dates.offset = self.offset
-        new_dates.tz = tz
-        new_dates.name = self.name
-        return new_dates
-
-    def tz_localize(self, tz):
-        """
-        Localize tz-naive DatetimeIndex to given time zone (using pytz)
-
-        Returns
-        -------
-        localized : DatetimeIndex
-        """
-        if self.tz is not None:
-            raise ValueError("Already have timezone info, "
-                             "use tz_normalize to convert.")
-
-        new_dates = lib.tz_localize_array(self.asi8, tz)
-        new_dates = new_dates.view('M8[us]')
-        new_dates = new_dates.view(self.__class__)
-        new_dates.offset = self.offset
-        new_dates.tz = tz
-        new_dates.name = self.name
-        return new_dates
-
-    def tz_validate(self):
-        """
-        For a localized time zone, verify that there are no DST ambiguities
-        (using pytz)
-
-        Returns
-        -------
-        result : boolean
-            True if there are no DST ambiguities
-        """
-        import pytz
-
-        if self.tz is None or self.tz is pytz.utc:
-            return True
-
-        # See if there are any DST resolution problems
-        try:
-            lib.tz_localize_array(self.asi8, self.tz)
-        except:
-            return False
-
-        return True
-
-# --- Interval index sketch
-
-class IntervalIndex(Int64Index):
-    """
-    Immutable ndarray holding ordinal values indicating regular intervals in
-    time such as particular years, quarters, months, etc. A value of 1 is the
-    interval containing the Gregorian proleptic datetime Jan 1, 0001 00:00:00.
-    This ordinal representation is from the scikits.timeseries project.
-
-    For instance,
-        # construct interval for day 1/1/1 and get the first second
-        i = Interval(year=1,month=1,day=1,freq='D').resample('S', 'S')
-        i.ordinal
-        ===> 1
-
-    Index keys are boxed to Interval objects which carries the metadata (eg,
-    frequency information).
-
-    Parameters
-    ----------
-    data  : array-like (1-dimensional), optional
-        Optional interval-like data to construct index with
-    dtype : NumPy dtype (default: i8)
-    copy  : bool
-        Make a copy of input ndarray
-    freq : string or interval object, optional
-        One of pandas interval strings or corresponding objects
-    start : starting value, interval-like, optional
-        If data is None, used as the start point in generating regular
-        interval data.
-    periods  : int, optional, > 0
-        Number of intervals to generate, if generating index. Takes precedence
-        over end argument
-    end   : end value, interval-like, optional
-        If periods is none, generated index will extend to first conforming
-        interval on or just past end argument
-    """
-
-    def __new__(cls, data=None,
-                freq=None, start=None, end=None, periods=None,
-                copy=False, name=None):
-
-        if isinstance(freq, Interval):
-            freq = freq.freq
-        else:
-            freq = datetools.get_standard_freq(freq)
-
-        if data is None:
-            if start is None and end is None:
-                raise ValueError('Must specify start, end, or data')
-
-            start = to_interval(start, freq)
-            end = to_interval(end, freq)
-
-            is_start_intv = isinstance(start, Interval)
-            is_end_intv = isinstance(end, Interval)
-            if (start is not None and not is_start_intv):
-                raise ValueError('Failed to convert %s to interval' % start)
-
-            if (end is not None and not is_end_intv):
-                raise ValueError('Failed to convert %s to interval' % end)
-
-            if is_start_intv and is_end_intv and (start.freq != end.freq):
-                raise ValueError('Start and end must have same freq')
-
-            if freq is None:
-                if is_start_intv:
-                    freq = start.freq
-                elif is_end_intv:
-                    freq = end.freq
-                else:
-                    raise ValueError('Could not infer freq from start/end')
-
-            if periods is not None:
-                if start is None:
-                    data = np.arange(end.ordinal - periods + 1,
-                                     end.ordinal + 1,
-                                     dtype=np.int64)
-                else:
-                    data = np.arange(start.ordinal, start.ordinal + periods,
-                                     dtype=np.int64)
-            else:
-                if start is None or end is None:
-                    msg = 'Must specify both start and end if periods is None'
-                    raise ValueError(msg)
-                data = np.arange(start.ordinal, end.ordinal+1, dtype=np.int64)
-
-            subarr = data.view(cls)
-            subarr.name = name
-            subarr.freq = freq
-
-            return subarr
-
-        if not isinstance(data, np.ndarray):
-            if np.isscalar(data):
-                raise ValueError('IntervalIndex() must be called with a '
-                                 'collection of some kind, %s was passed'
-                                 % repr(data))
-
-            if isinstance(data, Interval):
-                data = [data]
-
-            # other iterable of some kind
-            if not isinstance(data, (list, tuple)):
-                data = list(data)
-
-            try:
-                data = np.array(data, dtype='i8')
-            except:
-                data = np.array(data, dtype='O')
-
-            if freq is None:
-                raise ValueError('freq cannot be none')
-
-            data = _skts_unbox_array(data, check=freq)
-        else:
-            if isinstance(data, IntervalIndex):
-                if freq is None or freq == data.freq:
-                    freq = data.freq
-                    data = data.values
-                else:
-                    base1, mult1 = datetools._get_freq_code(data.freq)
-                    base2, mult2 = datetools._get_freq_code(freq)
-                    data = lib.skts_resample_arr(data.values, base1, mult1,
-                                                 base2, mult2, 'E')
-            else:
-                if freq is None:
-                    raise ValueError('freq cannot be none')
-
-                if data.dtype == np.datetime64:
-                    data = datetools.dt64arr_to_sktsarr(data, freq)
-                elif data.dtype == np.int64:
-                    pass
-                else:
-                    data = data.astype('i8')
-
-        data = np.array(data, dtype=np.int64, copy=False)
-
-        if (data <= 0).any():
-            raise ValueError("Found illegal (<= 0) values in data")
-
-        subarr = data.view(cls)
-        subarr.name = name
-        subarr.freq = freq
-
-        return subarr
-
-    def resample(self, freq=None, how='E'):
-        how = datetools.validate_end_alias(how)
-
-        base1, mult1 = datetools._get_freq_code(self.freq)
-
-        if isinstance(freq, basestring):
-            base2, mult2 = datetools._get_freq_code(freq)
-        else:
-            base2, mult2 = freq
-
-
-        new_data = lib.skts_resample_arr(self.values,
-                                         base1, mult1,
-                                         base2, mult2, how)
-
-        return IntervalIndex(new_data, freq=freq)
-
-    @property
-    def year(self):
-        base, mult = datetools._get_freq_code(self.freq)
-        return lib.get_skts_year_arr(self.values, base, mult)
-
-    @property
-    def month(self):
-        base, mult = datetools._get_freq_code(self.freq)
-        return lib.get_skts_month_arr(self.values, base, mult)
-
-    @property
-    def qyear(self):
-        base, mult = datetools._get_freq_code(self.freq)
-        return lib.get_skts_qyear_arr(self.values, base, mult)
-
-    @property
-    def quarter(self):
-        base, mult = datetools._get_freq_code(self.freq)
-        return lib.get_skts_quarter_arr(self.values, base, mult)
-
-    @property
-    def day(self):
-        base, mult = datetools._get_freq_code(self.freq)
-        return lib.get_skts_day_arr(self.values, base, mult)
-
-    @property
-    def week(self):
-        base, mult = datetools._get_freq_code(self.freq)
-        return lib.get_skts_week_arr(self.values, base, mult)
-
-    @property
-    def weekday(self):
-        base, mult = datetools._get_freq_code(self.freq)
-        return lib.get_skts_weekday_arr(self.values, base, mult)
-
-    @property
-    def day_of_week(self):
-        base, mult = datetools._get_freq_code(self.freq)
-        return lib.get_skts_dow_arr(self.values, base, mult)
-
-    @property
-    def day_of_year(self):
-        base, mult = datetools._get_freq_code(self.freq)
-        return lib.get_skts_doy_arr(self.values, base, mult)
+        if right_lev_indexer is not None:
+            right_indexer = right_lev_indexer.take(join_index.labels[level])
+        else:
+            right_indexer = join_index.labels[level]
 
-    @property
-    def hour(self):
-        base, mult = datetools._get_freq_code(self.freq)
-        return lib.get_skts_hour_arr(self.values, base, mult)
+        if flip_order:
+            left_indexer, right_indexer = right_indexer, left_indexer
 
-    @property
-    def minute(self):
-        base, mult = datetools._get_freq_code(self.freq)
-        return lib.get_skts_minute_arr(self.values, base, mult)
+        if return_indexers:
+            return join_index, left_indexer, right_indexer
+        else:
+            return join_index
 
-    @property
-    def second(self):
-        base, mult = datetools._get_freq_code(self.freq)
-        return lib.get_skts_second_arr(self.values, base, mult)
+    def _join_monotonic(self, other, how='left', return_indexers=False):
+        if self.equals(other):
+            ret_index = other if how == 'right' else self
+            if return_indexers:
+                return ret_index, None, None
+            else:
+                return ret_index
 
-    # Try to run function on index first, and then on elements of index
-    # Especially important for group-by functionality
-    def map(self, func_to_map):
-        try:
-            return func_to_map(self)
-        except:
-            return super(DatetimeIndex, self).map(func_to_map)
+        if how == 'left':
+            join_index = self
+            lidx = None
+            ridx = self._left_indexer(self, other)
+        elif how == 'right':
+            join_index = other
+            lidx = self._left_indexer(other, self)
+            ridx = None
+        elif how == 'inner':
+            join_index, lidx, ridx = self._inner_indexer(self.values,
+                                                         other.values)
+            join_index = self._wrap_joined_index(join_index, other)
+        elif how == 'outer':
+            join_index, lidx, ridx = self._outer_indexer(self.values,
+                                                         other.values)
+            join_index = self._wrap_joined_index(join_index, other)
 
-    def _mpl_repr(self):
-        # how to represent ourselves to matplotlib
-        return datetools._skts_box_array(self, self.freq)
+        if return_indexers:
+            return join_index, lidx, ridx
+        else:
+            return join_index
 
-    def to_timestamp(self):
-        """
-        Cast to datetimeindex of timestamps, at *beginning* of interval
-        """
-        base, mult = datetools._get_freq_code('S')
-        new_data = self.resample('S', 'S')
-        new_data = lib.sktsarr_to_dt64arr(new_data.values, base, mult)
-        return DatetimeIndex(new_data, freq=self.freq)
+    def _wrap_joined_index(self, joined, other):
+        name = self.name if self.name == other.name else None
+        return Index(joined, name=name)
 
-    def shift(self, n):
+    def slice_locs(self, start=None, end=None):
         """
-        Specialized shift which produces an IntervalIndex
+        For an ordered Index, compute the slice locations for input labels
 
         Parameters
         ----------
-        n : int
-            Periods to shift by
-        freq : freq string
+        start : label, default None
+            If None, defaults to the beginning
+        end : label
+            If None, defaults to the end
 
         Returns
         -------
-        shifted : IntervalIndex
-        """
-        if n == 0:
-            return self
-
-        return IntervalIndex(data=self.values + n, freq=self.freq)
-
-    def __add__(self, other):
-        if isinstance(other, (int, long)):
-            return IntervalIndex(self.values + other, self.freq)
-        return super(IntervalIndex, self).__add__(other)
-
-    def __sub__(self, other):
-        if isinstance(other, (int, long)):
-            return IntervalIndex(self.values - other, self.freq)
-        if isinstance(other, Interval):
-            if other.freq != self.freq:
-                raise ValueError("Cannot do arithmetic with "
-                                 "non-conforming intervals")
-            return IntervalIndex(self.values - other.ordinal)
-        return super(IntervalIndex, self).__sub__(other)
-
-    @property
-    def inferred_type(self):
-        # b/c data is represented as ints make sure we can't have ambiguous
-        # indexing
-        return 'interval'
+        (begin, end) : (int, int)
 
-    def get_value(self, series, key):
-        """
-        Fast lookup of value from 1-dimensional ndarray. Only use this if you
-        know what you're doing
+        Notes
+        -----
+        This function assumes that the data is sorted, so use at your own peril
         """
-        try:
-            return super(IntervalIndex, self).get_value(series, key)
-        except KeyError:
+        if start is None:
+            beg_slice = 0
+        else:
             try:
-                asdt, parsed, reso = datetools.parse_time_string(key)
-                grp = datetools._infer_interval_group(reso)
-                freqn = datetools._interval_group(self.freq)
-
-                # if our data is higher resolution than requested key, slice
-                if grp < freqn:
-                    iv = Interval(asdt, freq=(grp,1))
-                    ord1 = iv.resample(self.freq, how='S').ordinal
-                    ord2 = iv.resample(self.freq, how='E').ordinal
-                    pos = np.searchsorted(self.values, [ord1, ord2])
-                    key = slice(pos[0], pos[1]+1)
-                    return series[key]
+                beg_slice = self.get_loc(start)
+            except KeyError:
+                if self.is_monotonic:
+                    beg_slice = self.searchsorted(start, side='left')
                 else:
-                    key = to_interval(asdt, freq=self.freq).ordinal
-                    return self._engine.get_value(series, key)
-            except TypeError:
-                pass
+                    raise
+
+        if end is None:
+            end_slice = len(self)
+        else:
+            try:
+                end_slice = self.get_loc(end) + 1
             except KeyError:
-                pass
-            except IndexError:
-                ival = Interval(key, freq=self.freq)
-                raise IndexError("%s is out of bounds" % ival)
+                if self.is_monotonic:
+                    end_slice = self.searchsorted(end, side='right')
+                else:
+                    raise
 
-            key = to_interval(key, self.freq).ordinal
-            return self._engine.get_value(series, key)
+        return beg_slice, end_slice
 
-    def get_loc(self, key):
+    def delete(self, loc):
         """
-        Get integer location for requested label
+        Make new Index with passed location deleted
 
         Returns
         -------
-        loc : int
+        new_index : Index
         """
-        try:
-            return self._engine.get_loc(key)
-        except KeyError:
-            try:
-                asdt, parsed, reso = datetools.parse_time_string(key)
-                key = asdt
-            except TypeError:
-                pass
-            except KeyError:
-                pass
-
-            key = to_interval(key, self.freq).ordinal
-            return self._engine.get_loc(key)
-
-    def __getitem__(self, key):
-        """Override numpy.ndarray's __getitem__ method to work as desired"""
-        arr_idx = self.view(np.ndarray)
-        if np.isscalar(key):
-            val = arr_idx[key]
-            return _skts_box(val, freq=self.freq)
-        else:
-            if com._is_bool_indexer(key):
-                key = np.asarray(key)
+        arr = np.delete(np.asarray(self), loc)
+        return Index(arr)
 
-            result = arr_idx[key]
-            if result.ndim > 1:
-                return IntervalIndex(result, name=self.name, freq=self.freq)
+    def insert(self, loc, item):
+        """
+        Make new Index inserting new item at location
 
-            return IntervalIndex(result, name=self.name, freq=self.freq)
+        Parameters
+        ----------
+        loc : int
+        item : object
 
-    def format(self, name=False):
+        Returns
+        -------
+        new_index : Index
         """
-        Render a string representation of the Index
+        index = np.asarray(self)
+        # because numpy is fussy with tuples
+        item_idx = Index([item], dtype=index.dtype)
+        new_index = np.concatenate((index[:loc], item_idx, index[loc:]))
+        return Index(new_index, name=self.name)
+
+    def drop(self, labels):
         """
-        header = []
+        Make new Index with passed list of labels deleted
 
-        if name:
-            header.append(str(self.name) if self.name is not None else '')
+        Parameters
+        ----------
+        labels : array-like
 
-        return header + ['%s' % _skts_box(x, freq=self.freq) for x in self]
+        Returns
+        -------
+        dropped : Index
+        """
+        labels = np.asarray(list(labels), dtype=object)
+        indexer = self.get_indexer(labels)
+        mask = indexer == -1
+        if mask.any():
+            raise ValueError('labels %s not contained in axis' % labels[mask])
+        return self.delete(indexer)
 
-    def _view_like(self, ndarray):
-        result = ndarray.view(type(self))
-        result.freq = self.freq
-        result.name = self.name
-        return result
+    def copy(self, order='C'):
+        """
+        Overridden ndarray.copy to copy over attributes
 
-    def __array_finalize__(self, obj):
-        if self.ndim == 0: # pragma: no cover
-            return self.item()
+        Returns
+        -------
+        cp : Index
+            Returns view on same base ndarray
+        """
+        cp = self.view(np.ndarray).view(type(self))
+        cp.__dict__.update(self.__dict__)
+        return cp
 
-        self.freq = getattr(obj, 'freq', None)
 
-    def __repr__(self):
-        output = str(self.__class__) + '\n'
-        output += 'freq: ''%s''\n' % self.freq
-        if len(self) > 0:
-            output += '[%s, ..., %s]\n' % (self[0], self[-1])
-        output += 'length: %d' % len(self)
-        return output
+class Int64Index(Index):
 
-# --------------------------- end of datetime-specific code ---------------
+    _groupby = lib.groupby_int64
+    _arrmap = lib.arrmap_int64
+    _left_indexer = lib.left_join_indexer_int64
+    _inner_indexer = lib.inner_join_indexer_int64
+    _outer_indexer = lib.outer_join_indexer_int64
 
-class Factor(np.ndarray):
-    """
-    Represents a categorical variable in classic R / S-plus fashion
+    _engine_type = _gin.Int64Engine
 
-    Parameters
-    ----------
-    data : array-like
+    def __new__(cls, data, dtype=None, copy=False, name=None):
+        if not isinstance(data, np.ndarray):
+            if np.isscalar(data):
+                raise ValueError('Index(...) must be called with a collection '
+                                 'of some kind, %s was passed' % repr(data))
 
-    Returns
-    -------
-    **Attributes**
-      * labels : ndarray
-      * levels : ndarray
-    """
-    def __new__(cls, data):
-        data = np.asarray(data, dtype=object)
-        levels, factor = unique_with_labels(data)
-        factor = factor.view(Factor)
-        factor.levels = levels
-        return factor
+            # other iterable of some kind
+            if not isinstance(data, (list, tuple)):
+                data = list(data)
+            data = np.asarray(data)
 
-    levels = None
+        if issubclass(data.dtype.type, basestring):
+            raise TypeError('String dtype not supported, you may need '
+                            'to explicitly cast to int')
+        elif issubclass(data.dtype.type, np.integer):
+            subarr = np.array(data, dtype=np.int64, copy=copy)
+        else:
+            subarr = np.array(data, dtype=np.int64, copy=copy)
+            if len(data) > 0:
+                if (subarr != data).any():
+                    raise TypeError('Unsafe NumPy casting, you must '
+                                    'explicitly cast')
 
-    def __array_finalize__(self, obj):
-        self.levels = getattr(obj, 'levels', None)
+        subarr = subarr.view(cls)
+        subarr.name = name
+        return subarr
 
     @property
-    def labels(self):
-        return self.view(np.ndarray)
-
-    def asarray(self):
-        return np.asarray(self.levels).take(self.labels)
-
-    def __len__(self):
-        return len(self.labels)
+    def inferred_type(self):
+        return 'integer'
 
-    def __repr__(self):
-        temp = 'Factor:\n%s\nLevels (%d): %s'
-        values = self.asarray()
-        return temp % (repr(values), len(self.levels), self.levels)
+    @property
+    def _constructor(self):
+        return Int64Index
 
-    def __getitem__(self, key):
-        if isinstance(key, (int, np.integer)):
-            i = self.labels[key]
-            return self.levels[i]
-        else:
-            return np.ndarray.__getitem__(self, key)
+    @property
+    def dtype(self):
+        return np.dtype('int64')
 
+    @property
+    def is_all_dates(self):
+        """
+        Checks that all the labels are datetime objects
+        """
+        return False
 
-def unique_with_labels(values):
-    rizer = lib.Factorizer(len(values))
-    labels, _ = rizer.factorize(values, sort=False)
-    uniques = Index(rizer.uniques)
+    def equals(self, other):
+        """
+        Determines if two Index objects contain the same elements.
+        """
+        if self is other:
+            return True
 
-    try:
-        sorter = uniques.argsort()
-        reverse_indexer = np.empty(len(sorter), dtype='i4')
-        reverse_indexer.put(sorter, np.arange(len(sorter)))
-        labels = reverse_indexer.take(labels)
-        uniques = uniques.take(sorter)
-    except TypeError:
-        pass
+        # if not isinstance(other, Int64Index):
+        #     return False
 
-    return uniques, labels
+        return np.array_equal(self, other)
 
+    def _wrap_joined_index(self, joined, other):
+        name = self.name if self.name == other.name else None
+        return Int64Index(joined, name=name)
 
-def unique_int64(values):
-    if values.dtype != np.int64:
-        values = values.astype('i8')
 
-    table = lib.Int64HashTable(len(values))
-    uniques = table.unique(values)
-    return uniques
 
 
 class MultiIndex(Index):
@@ -2751,6 +1320,8 @@ class MultiIndex(Index):
         -------
         index : MultiIndex
         """
+        from pandas.core.factor import Factor
+
         if len(arrays) == 1:
             name = None if names is None else names[0]
             return Index(arrays[0], name=name)
@@ -3677,21 +2248,18 @@ def _sanitize_and_check(indexes):
 
 def _handle_legacy_indexes(indexes):
     from pandas.core.daterange import DateRange
+    from pandas.tseries.index import DatetimeIndex
 
     converted = []
     for index in indexes:
         if isinstance(index, DateRange):
-            index = _convert_daterange(index)
+            index = DatetimeIndex(start=index[0], end=index[-1],
+                                  freq=index.offset, tz=index.tzinfo)
 
         converted.append(index)
 
     return converted
 
-def _convert_daterange(obj):
-    return DatetimeIndex(start=obj[0], end=obj[-1],
-                         freq=obj.offset, tz=obj.tzinfo)
-
-
 def _get_consensus_names(indexes):
     consensus_name = indexes[0].names
     for index in indexes[1:]:
@@ -3699,3 +2267,16 @@ def _get_consensus_names(indexes):
             consensus_name = [None] * index.nlevels
             break
     return consensus_name
+
+from pandas.tseries.index import DatetimeIndex, _dt_box_array
+
+def _ensure_compat_concat(indexes):
+    is_m8 = [isinstance(idx, DatetimeIndex) for idx in indexes]
+    if any(is_m8) and not all(is_m8):
+        return [_maybe_box_dtindex(idx) for idx in indexes]
+    return indexes
+
+def _maybe_box_dtindex(idx):
+    if isinstance(idx, DatetimeIndex):
+        return Index(_dt_box_array(idx.asi8), dtype='object')
+    return idx
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index bf3c005c5..2efad22ce 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -9,7 +9,8 @@ import numpy as np
 
 from pandas.core.common import (PandasError, _mut_exclusive,
                                 _try_sort, _default_index, _infer_dtype)
-from pandas.core.index import (Factor, Index, MultiIndex, _ensure_index,
+from pandas.core.factor import Factor
+from pandas.core.index import (Index, MultiIndex, _ensure_index,
                                _get_combined_index)
 from pandas.core.indexing import _NDFrameIndexer, _maybe_droplevels
 from pandas.core.internals import BlockManager, make_block, form_blocks
@@ -1270,8 +1271,6 @@ def _homogenize_dict(frames, intersect=True, dtype=None):
 
 
 def _extract_axis(data, axis=0, intersect=False):
-    from pandas.core.index import _union_indexes
-
     if len(data) == 0:
         index = Index([])
     elif len(data) > 0:
diff --git a/pandas/core/series.py b/pandas/core/series.py
index a784e5a19..009e1ad65 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2311,7 +2311,7 @@ copy : boolean, default False
         -------
         converted : DataFrame
         """
-        from pandas.core.daterange import date_range
+        from pandas.tseries.index import date_range
         if len(self.index) == 0:
             return self.copy()
         dti = date_range(self.index[0], self.index[-1], freq=freq)
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index c70201f3a..91b4fa9c0 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -11,12 +11,17 @@ import time
 import numpy as np
 from pandas import Series, TimeSeries, DataFrame, Panel, Index, MultiIndex
 from pandas.core.common import adjoin
-from pandas.core.algorithms import match
-import pandas._tseries as lib
-from contextlib import contextmanager
+from pandas.core.algorithms import match, unique
 
+from pandas.core.factor import Factor
+from pandas.core.common import _asarray_tuplesafe
+from pandas.core.internals import BlockManager, make_block
+from pandas.core.reshape import block2d_to_block3d
 import pandas.core.common as com
 
+import pandas._tseries as lib
+from contextlib import contextmanager
+
 # reading and writing the full object in one go
 _TYPE_MAP = {
     Series     : 'series',
@@ -421,10 +426,7 @@ class HDFStore(object):
             self._write_array(group, 'block%d_values' % i, blk.values)
 
     def _read_block_manager(self, group):
-        from pandas.core.internals import BlockManager, make_block
-
         ndim = group._v_attrs.ndim
-        nblocks = group._v_attrs.nblocks
 
         axes = []
         for i in xrange(ndim):
@@ -689,11 +691,6 @@ class HDFStore(object):
         return self._read_panel_table(group, where)['value']
 
     def _read_panel_table(self, group, where=None):
-        from pandas.core.index import unique_int64, Factor
-        from pandas.core.common import _asarray_tuplesafe
-        from pandas.core.internals import BlockManager
-        from pandas.core.reshape import block2d_to_block3d
-
         table = getattr(group, 'table')
         fields = table._v_attrs.fields
 
@@ -714,7 +711,7 @@ class HDFStore(object):
         J, K = len(major.levels), len(minor.levels)
         key = major.labels * K + minor.labels
 
-        if len(unique_int64(key)) == len(key):
+        if len(unique(key)) == len(key):
             sorter, _ = lib.groupsort_indexer(key, J * K)
 
             # the data need to be sorted
@@ -739,7 +736,6 @@ class HDFStore(object):
 
             # need a better algorithm
             tuple_index = long_index.get_tuple_index()
-            index_map = lib.map_indices_object(tuple_index)
 
             unique_tuples = lib.fast_unique(tuple_index)
             unique_tuples = _asarray_tuplesafe(unique_tuples)
diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index 3e10a452f..882c95631 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -93,7 +93,7 @@ cdef extern from "np_datetime_strings.h":
 
     int get_datetime_iso_8601_strlen(int local, NPY_DATETIMEUNIT base)
 
-cdef extern from "skts.h":
+cdef extern from "period.h":
     ctypedef struct date_info:
         long absdate
         double abstime
@@ -108,32 +108,32 @@ cdef extern from "skts.h":
         int day_of_year
         int calendar
 
-    long resample(long dtordinal, int freq1, int freq2, char relation) except -1
+    long asfreq(long dtordinal, int freq1, int freq2, char relation) except -1
 
-    long get_skts_ordinal(int year, int month, int day,
+    long get_period_ordinal(int year, int month, int day,
                           int hour, int minute, int second,
                           int freq) except -1
 
-    long get_python_ordinal(long skts_ordinal, int freq) except -1
+    long get_python_ordinal(long period_ordinal, int freq) except -1
 
-    char *interval_strftime(long value, int freq, PyObject *args)
-    char *interval_to_string(long value, int freq)
-    char *interval_to_string2(long value, int freq, char *fmt)
+    char *skts_strftime(long value, int freq, PyObject *args)
+    char *period_to_string(long value, int freq)
+    char *period_to_string2(long value, int freq, char *fmt)
 
     int get_date_info(long ordinal, int freq, date_info *dinfo) except -1
 
-    int iyear(long ordinal, int freq) except -1
-    int iqyear(long ordinal, int freq) except -1
-    int iquarter(long ordinal, int freq) except -1
-    int imonth(long ordinal, int freq) except -1
-    int iday(long ordinal, int freq) except -1
-    int iweekday(long ordinal, int freq) except -1
-    int iday_of_week(long ordinal, int freq) except -1
-    int iday_of_year(long ordinal, int freq) except -1
-    int iweek(long ordinal, int freq) except -1
-    int ihour(long ordinal, int freq) except -1
-    int iminute(long ordinal, int freq) except -1
-    int isecond(long ordinal, int freq) except -1
+    int pyear(long ordinal, int freq) except -1
+    int pqyear(long ordinal, int freq) except -1
+    int pquarter(long ordinal, int freq) except -1
+    int pmonth(long ordinal, int freq) except -1
+    int pday(long ordinal, int freq) except -1
+    int pweekday(long ordinal, int freq) except -1
+    int pday_of_week(long ordinal, int freq) except -1
+    int pday_of_year(long ordinal, int freq) except -1
+    int pweek(long ordinal, int freq) except -1
+    int phour(long ordinal, int freq) except -1
+    int pminute(long ordinal, int freq) except -1
+    int psecond(long ordinal, int freq) except -1
 
 cdef extern from "stdint.h":
     enum: INT64_MIN
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 0fd19ca44..ad2d9a11e 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -92,16 +92,16 @@ class Timestamp(_Timestamp):
         object_state = self.value, self.offset, self.tzinfo
         return (Timestamp, object_state)
 
-    def to_interval(self, freq=None):
+    def to_period(self, freq=None):
         """
-        Return an interval of which this timestamp is an observation.
+        Return an period of which this timestamp is an observation.
         """
-        from pandas.core.datetools import Interval
+        from pandas.tseries.period import Period
 
         if freq == None:
             freq = self.freq
 
-        return Interval(self, freq=freq)
+        return Period(self, freq=freq)
 
 def apply_offset(ndarray[object] values, object offset):
     cdef:
@@ -976,33 +976,33 @@ def monthrange(int64_t year, int64_t month):
 cdef inline int64_t ts_dayofweek(_TSObject ts):
     return dayofweek(ts.dtval.year, ts.dtval.month, ts.dtval.day)
 
-# Interval logic
+# Period logic
 # ------------------------------------------------------------------------------
 
-cdef long apply_mult(long skts_ord, long mult):
+cdef long apply_mult(long period_ord, long mult):
     """
     Get base+multiple ordinal value from corresponding base-only ordinal value.
     For example, 5min ordinal will be 1/5th the 1min ordinal (rounding down to
     integer).
     """
     if mult == 1:
-        return skts_ord
+        return period_ord
 
-    return (skts_ord - 1) // mult
+    return (period_ord - 1) // mult
 
-cdef long remove_mult(long skts_ord_w_mult, long mult):
+cdef long remove_mult(long period_ord_w_mult, long mult):
     """
     Get base-only ordinal value from corresponding base+multiple ordinal.
     """
     if mult == 1:
-        return skts_ord_w_mult
+        return period_ord_w_mult
 
-    return skts_ord_w_mult * mult + 1;
+    return period_ord_w_mult * mult + 1;
 
-def dt64arr_to_sktsarr(ndarray[int64_t] dtarr, int base, long mult):
+def dt64arr_to_periodarr(ndarray[int64_t] dtarr, int base, long mult):
     """
     Convert array of datetime64 values (passed in as 'i8' dtype) to a set of
-    intervals corresponding to desired frequency, per skts convention.
+    periods corresponding to desired frequency, per period convention.
     """
     cdef:
         ndarray[int64_t] out
@@ -1015,34 +1015,34 @@ def dt64arr_to_sktsarr(ndarray[int64_t] dtarr, int base, long mult):
 
     for i in range(l):
         PyArray_DatetimeToDatetimeStruct(dtarr[i], NPY_FR_us, &dts)
-        out[i] = get_skts_ordinal(dts.year, dts.month, dts.day,
+        out[i] = get_period_ordinal(dts.year, dts.month, dts.day,
                                   dts.hour, dts.min, dts.sec, base)
         out[i] = apply_mult(out[i], mult)
     return out
 
-def sktsarr_to_dt64arr(ndarray[int64_t] sktsarr, int base, long mult):
+def periodarr_to_dt64arr(ndarray[int64_t] periodarr, int base, long mult):
     """
     Convert array to datetime64 values from a set of ordinals corresponding to
-    intervals per skts convention.
+    periods per period convention.
     """
     cdef:
         ndarray[int64_t] out
         Py_ssize_t i, l
 
-    l = len(sktsarr)
+    l = len(periodarr)
 
     out = np.empty(l, dtype='i8')
 
     for i in range(l):
-        out[i] = skts_ordinal_to_dt64(sktsarr[i], base, mult)
+        out[i] = period_ordinal_to_dt64(periodarr[i], base, mult)
 
     return out
 
-cpdef long skts_resample(long skts_ordinal, int base1, long mult1, int base2, long mult2,
-                         object relation='E'):
+cpdef long period_asfreq(long period_ordinal, int base1, long mult1,
+                           int base2, long mult2, object relation='E'):
     """
-    Convert skts ordinal from one frequency to another, and if upsampling, choose
-    to use start ('S') or end ('E') of interval.
+    Convert period ordinal from one frequency to another, and if upsampling,
+    choose to use start ('S') or end ('E') of period.
     """
     cdef:
         long retval
@@ -1050,21 +1050,21 @@ cpdef long skts_resample(long skts_ordinal, int base1, long mult1, int base2, lo
     if relation not in ('S', 'E'):
         raise ValueError('relation argument must be one of S or E')
 
-    skts_ordinal = remove_mult(skts_ordinal, mult1)
+    period_ordinal = remove_mult(period_ordinal, mult1)
 
     if mult1 != 1 and relation == 'E':
-        skts_ordinal += (mult1 - 1)
+        period_ordinal += (mult1 - 1)
 
-    retval = resample(skts_ordinal, base1, base2, (<char*>relation)[0])
+    retval = asfreq(period_ordinal, base1, base2, (<char*>relation)[0])
     retval = apply_mult(retval, mult2)
 
     return retval
 
-def skts_resample_arr(ndarray[int64_t] arr, int base1, long mult1, int base2, long mult2,
-                      object relation='E'):
+def period_asfreq_arr(ndarray[int64_t] arr, int base1, long mult1, int base2,
+                        long mult2, object relation='E'):
     """
-    Convert int64-array of skts ordinals from one frequency to another, and if
-    upsampling, choose to use start ('S') or end ('E') of interval.
+    Convert int64-array of period ordinals from one frequency to another, and if
+    upsampling, choose to use start ('S') or end ('E') of period.
     """
     cdef:
         ndarray[int64_t] new_arr
@@ -1077,25 +1077,26 @@ def skts_resample_arr(ndarray[int64_t] arr, int base1, long mult1, int base2, lo
     new_arr = np.empty(sz, dtype=np.int64)
 
     for i in range(sz):
-        new_arr[i] = skts_resample(arr[i], base1, mult1, base2, mult2, relation)
+        new_arr[i] = period_asfreq(arr[i], base1, mult1, base2, mult2, relation)
 
     return new_arr
 
-def skts_ordinal(int y, int m, int d, int h, int min, int s, int base, long mult):
+def period_ordinal(int y, int m, int d, int h, int min, int s,
+                   int base, long mult):
     cdef:
         long ordinal
 
-    ordinal = get_skts_ordinal(y, m, d, h, min, s, base)
+    ordinal = get_period_ordinal(y, m, d, h, min, s, base)
 
     return apply_mult(ordinal, mult)
 
-cpdef int64_t skts_ordinal_to_dt64(long skts_ordinal, int base, long mult):
+cpdef int64_t period_ordinal_to_dt64(long period_ordinal, int base, long mult):
     cdef:
         long ordinal
         npy_datetimestruct dts
         date_info dinfo
 
-    ordinal = remove_mult(skts_ordinal, mult)
+    ordinal = remove_mult(period_ordinal, mult)
 
     get_date_info(ordinal, base, &dinfo)
 
@@ -1109,72 +1110,73 @@ cpdef int64_t skts_ordinal_to_dt64(long skts_ordinal, int base, long mult):
 
     return PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts)
 
-def skts_ordinal_to_string(long value, int base, long mult):
+def period_ordinal_to_string(long value, int base, long mult):
     cdef:
         char *ptr
 
-    ptr = interval_to_string(remove_mult(value, mult), base)
+    ptr = period_to_string(remove_mult(value, mult), base)
 
     if ptr == NULL:
         raise ValueError("Could not create string from ordinal '%d'" % value)
 
     return <object>ptr
 
-def skts_strftime(long value, int freq, long mult, object fmt):
+def period_strftime(long value, int freq, long mult, object fmt):
     cdef:
         char *ptr
 
     value = remove_mult(value, mult)
-    ptr = interval_to_string2(value, freq, <char*>fmt)
+    ptr = period_to_string2(value, freq, <char*>fmt)
 
     if ptr == NULL:
         raise ValueError("Could not create string with fmt '%s'" % fmt)
 
     return <object>ptr
 
-# interval accessors
+# period accessors
 
 ctypedef int (*accessor)(long ordinal, int base) except -1
 
-cdef int apply_accessor(accessor func, long value, int base, long mult) except -1:
+cdef int apply_accessor(accessor func, long value, int base,
+                        long mult) except -1:
     value = remove_mult(value, mult)
     return func(value, base)
 
-cpdef int get_skts_year(long value, int base, long mult) except -1:
-    return apply_accessor(iyear, value, base, mult)
+cpdef int get_period_year(long value, int base, long mult) except -1:
+    return apply_accessor(pyear, value, base, mult)
 
-cpdef int get_skts_qyear(long value, int base, long mult) except -1:
-    return apply_accessor(iqyear, value, base, mult)
+cpdef int get_period_qyear(long value, int base, long mult) except -1:
+    return apply_accessor(pqyear, value, base, mult)
 
-cpdef int get_skts_quarter(long value, int base, long mult) except -1:
-    return apply_accessor(iquarter, value, base, mult)
+cpdef int get_period_quarter(long value, int base, long mult) except -1:
+    return apply_accessor(pquarter, value, base, mult)
 
-cpdef int get_skts_month(long value, int base, long mult) except -1:
-    return apply_accessor(imonth, value, base, mult)
+cpdef int get_period_month(long value, int base, long mult) except -1:
+    return apply_accessor(pmonth, value, base, mult)
 
-cpdef int get_skts_day(long value, int base, long mult) except -1:
-    return apply_accessor(iday, value, base, mult)
+cpdef int get_period_day(long value, int base, long mult) except -1:
+    return apply_accessor(pday, value, base, mult)
 
-cpdef int get_skts_hour(long value, int base, long mult) except -1:
-    return apply_accessor(ihour, value, base, mult)
+cpdef int get_period_hour(long value, int base, long mult) except -1:
+    return apply_accessor(phour, value, base, mult)
 
-cpdef int get_skts_minute(long value, int base, long mult) except -1:
-    return apply_accessor(iminute, value, base, mult)
+cpdef int get_period_minute(long value, int base, long mult) except -1:
+    return apply_accessor(pminute, value, base, mult)
 
-cpdef int get_skts_second(long value, int base, long mult) except -1:
-    return apply_accessor(isecond, value, base, mult)
+cpdef int get_period_second(long value, int base, long mult) except -1:
+    return apply_accessor(psecond, value, base, mult)
 
-cpdef int get_skts_dow(long value, int base, long mult) except -1:
-    return apply_accessor(iday_of_week, value, base, mult)
+cpdef int get_period_dow(long value, int base, long mult) except -1:
+    return apply_accessor(pday_of_week, value, base, mult)
 
-cpdef int get_skts_week(long value, int base, long mult) except -1:
-    return apply_accessor(iweek, value, base, mult)
+cpdef int get_period_week(long value, int base, long mult) except -1:
+    return apply_accessor(pweek, value, base, mult)
 
-cpdef int get_skts_weekday(long value, int base, long mult) except -1:
-    return apply_accessor(iweekday, value, base, mult)
+cpdef int get_period_weekday(long value, int base, long mult) except -1:
+    return apply_accessor(pweekday, value, base, mult)
 
-cpdef int get_skts_doy(long value, int base, long mult) except -1:
-    return apply_accessor(iday_of_year, value, base, mult)
+cpdef int get_period_doy(long value, int base, long mult) except -1:
+    return apply_accessor(pday_of_year, value, base, mult)
 
 # same but for arrays
 
@@ -1194,39 +1196,39 @@ cdef ndarray[int64_t] apply_accessor_arr(accessor func,
 
     return out
 
-def get_skts_year_arr(ndarray[int64_t] arr, int base, long mult):
-    return apply_accessor_arr(iyear, arr, base, mult)
+def get_period_year_arr(ndarray[int64_t] arr, int base, long mult):
+    return apply_accessor_arr(pyear, arr, base, mult)
 
-def get_skts_qyear_arr(ndarray[int64_t] arr, int base, long mult):
-    return apply_accessor_arr(iqyear, arr, base, mult)
+def get_period_qyear_arr(ndarray[int64_t] arr, int base, long mult):
+    return apply_accessor_arr(pqyear, arr, base, mult)
 
-def get_skts_quarter_arr(ndarray[int64_t] arr, int base, long mult):
-    return apply_accessor_arr(iquarter, arr, base, mult)
+def get_period_quarter_arr(ndarray[int64_t] arr, int base, long mult):
+    return apply_accessor_arr(pquarter, arr, base, mult)
 
-def get_skts_month_arr(ndarray[int64_t] arr, int base, long mult):
-    return apply_accessor_arr(imonth, arr, base, mult)
+def get_period_month_arr(ndarray[int64_t] arr, int base, long mult):
+    return apply_accessor_arr(pmonth, arr, base, mult)
 
-def get_skts_day_arr(ndarray[int64_t] arr, int base, long mult):
-    return apply_accessor_arr(iday, arr, base, mult)
+def get_period_day_arr(ndarray[int64_t] arr, int base, long mult):
+    return apply_accessor_arr(pday, arr, base, mult)
 
-def get_skts_hour_arr(ndarray[int64_t] arr, int base, long mult):
-    return apply_accessor_arr(ihour, arr, base, mult)
+def get_period_hour_arr(ndarray[int64_t] arr, int base, long mult):
+    return apply_accessor_arr(phour, arr, base, mult)
 
-def get_skts_minute_arr(ndarray[int64_t] arr, int base, long mult):
-    return apply_accessor_arr(iminute, arr, base, mult)
+def get_period_minute_arr(ndarray[int64_t] arr, int base, long mult):
+    return apply_accessor_arr(pminute, arr, base, mult)
 
-def get_skts_second_arr(ndarray[int64_t] arr, int base, long mult):
-    return apply_accessor_arr(isecond, arr, base, mult)
+def get_period_second_arr(ndarray[int64_t] arr, int base, long mult):
+    return apply_accessor_arr(psecond, arr, base, mult)
 
-def get_skts_dow_arr(ndarray[int64_t] arr, int base, long mult):
-    return apply_accessor_arr(iday_of_week, arr, base, mult)
+def get_period_dow_arr(ndarray[int64_t] arr, int base, long mult):
+    return apply_accessor_arr(pday_of_week, arr, base, mult)
 
-def get_skts_week_arr(ndarray[int64_t] arr, int base, long mult):
-    return apply_accessor_arr(iweek, arr, base, mult)
+def get_period_week_arr(ndarray[int64_t] arr, int base, long mult):
+    return apply_accessor_arr(pweek, arr, base, mult)
 
-def get_skts_weekday_arr(ndarray[int64_t] arr, int base, long mult):
-    return apply_accessor_arr(iweekday, arr, base, mult)
+def get_period_weekday_arr(ndarray[int64_t] arr, int base, long mult):
+    return apply_accessor_arr(pweekday, arr, base, mult)
 
-def get_skts_doy_arr(ndarray[int64_t] arr, int base, long mult):
-    return apply_accessor_arr(iday_of_year, arr, base, mult)
+def get_period_doy_arr(ndarray[int64_t] arr, int base, long mult):
+    return apply_accessor_arr(pday_of_year, arr, base, mult)
 
diff --git a/pandas/src/skts.c b/pandas/src/period.c
similarity index 97%
rename from pandas/src/skts.c
rename to pandas/src/period.c
index 540826ee8..c4d1fbb90 100644
--- a/pandas/src/skts.c
+++ b/pandas/src/period.c
@@ -1,17 +1,17 @@
-#include "skts.h"
+#include "period.h"
 #include "limits.h"
 #include "numpy/ndarraytypes.h"
 
 /*
  * Borrowed and derived code from scikits.timeseries that we will expose via
- * Cython to pandas. This primarily concerns interval representation and
+ * Cython to pandas. This primarily concerns period representation and
  * frequency conversion routines.
  */
 
 /* see end of file for stuff pandas uses (search for 'pandas') */
 
 /* ------------------------------------------------------------------
- * Code derived from skts
+ * Code derived from scikits.timeseries
  * ------------------------------------------------------------------*/
 
 static asfreq_info NULL_AF_INFO;
@@ -957,14 +957,14 @@ int dInfoCalc_SetFromAbsDateTime(struct date_info *dinfo,
  * New pandas API-helper code, to expose to cython
  * ------------------------------------------------------------------*/
 
-long resample(long skts_ordinal, int freq1, int freq2, char relation)
+long asfreq(long period_ordinal, int freq1, int freq2, char relation)
 {
     freq_conv_func func = get_asfreq_func(freq1, freq2, 0);
 
     asfreq_info finfo;
     get_asfreq_info(freq1, freq2, &finfo);
 
-    long val = (*func)(skts_ordinal, relation, &finfo);
+    long val = (*func)(period_ordinal, relation, &finfo);
 
     if (val == INT_ERR_CODE)
         Py_Error(PyExc_ValueError, "Unable to convert to desired frequency.");
@@ -974,8 +974,8 @@ onError:
     return INT_ERR_CODE;
 }
 
-/* generate an ordinal in skts space */
-long get_skts_ordinal(int year, int month, int day,
+/* generate an ordinal in period space */
+long get_period_ordinal(int year, int month, int day,
                       int hour, int minute, int second,
                       int freq)
 {
@@ -1063,14 +1063,14 @@ onError:
 /*
     Returns the proleptic Gregorian ordinal of the date, as an integer.
     This corresponds to the number of days since Jan., 1st, 1AD.
-    When the instance has a frequency less than daily, the proleptic date 
+    When the instance has a frequency less than daily, the proleptic date
     is calculated for the last day of the period.
 */
 
-long get_python_ordinal(long skts_ordinal, int freq)
+long get_python_ordinal(long period_ordinal, int freq)
 {
     if (freq == FR_DAY)
-        return skts_ordinal;
+        return period_ordinal;
 
     long (*toDaily)(long, char, asfreq_info*) = NULL;
     asfreq_info af_info;
@@ -1078,7 +1078,7 @@ long get_python_ordinal(long skts_ordinal, int freq)
     toDaily = get_asfreq_func(freq, FR_DAY, 0);
     get_asfreq_info(freq, FR_DAY, &af_info);
 
-    return toDaily(skts_ordinal, 'E', &af_info);
+    return toDaily(period_ordinal, 'E', &af_info);
 }
 
 char *str_replace(const char *s, const char *old, const char *new) {
@@ -1112,10 +1112,10 @@ char *str_replace(const char *s, const char *old, const char *new) {
     return ret;
 }
 
-// function to generate a nice string representation of the interval
+// function to generate a nice string representation of the period
 // object, originally from DateObject_strftime
 
-char *interval_strftime(long value, int freq, PyObject *args)
+char *skts_strftime(long value, int freq, PyObject *args)
 {
     char *orig_fmt_str, *fmt_str;
     char *result;
@@ -1249,7 +1249,7 @@ char *interval_strftime(long value, int freq, PyObject *args)
     return result;
 }
 
-char *interval_to_string(long value, int freq)
+char *period_to_string(long value, int freq)
 {
     int freq_group = get_freq_group(freq);
     PyObject *string_arg;
@@ -1276,19 +1276,19 @@ char *interval_to_string(long value, int freq)
 
     if (string_arg == NULL) { return (char *)NULL; }
 
-    retval = interval_strftime(value, freq, string_arg);
+    retval = skts_strftime(value, freq, string_arg);
     Py_DECREF(string_arg);
 
     return retval;
 }
 
-char *interval_to_string2(long value, int freq, char *fmt)
+char *period_to_string2(long value, int freq, char *fmt)
 {
     PyObject *string_arg;
     char *retval;
     string_arg = Py_BuildValue("(s)", fmt);
     if (string_arg == NULL) { return (char *)NULL; }
-    retval = interval_strftime(value, freq, string_arg);
+    retval = skts_strftime(value, freq, string_arg);
     Py_DECREF(string_arg);
     return retval;
 }
@@ -1352,83 +1352,83 @@ int get_date_info(long ordinal, int freq, struct date_info *dinfo)
     return 0;
 }
 
-int iyear(long ordinal, int freq) {
+int pyear(long ordinal, int freq) {
     struct date_info dinfo;
     get_date_info(ordinal, freq, &dinfo);
     return dinfo.year;
 }
 
-int iqyear(long ordinal, int freq) {
+int pqyear(long ordinal, int freq) {
     int year, quarter;
     if( _quarter_year(ordinal, freq, &year, &quarter) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return year;
 }
 
-int iquarter(long ordinal, int freq) {
+int pquarter(long ordinal, int freq) {
     int year, quarter;
     if(_quarter_year(ordinal, freq, &year, &quarter) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return quarter;
 }
 
-int imonth(long ordinal, int freq) {
+int pmonth(long ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return dinfo.month;
 }
 
-int iday(long ordinal, int freq) {
+int pday(long ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return dinfo.day;
 }
 
-int iweekday(long ordinal, int freq) {
+int pweekday(long ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return dinfo.day_of_week;
 }
 
-int iday_of_week(long ordinal, int freq) {
+int pday_of_week(long ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return dinfo.day_of_week;
 }
 
-int iday_of_year(long ordinal, int freq) {
+int pday_of_year(long ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return dinfo.day_of_year;
 }
 
-int iweek(long ordinal, int freq) {
+int pweek(long ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return _ISOWeek(&dinfo);
 }
 
-int ihour(long ordinal, int freq) {
+int phour(long ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return dinfo.hour;
 }
 
-int iminute(long ordinal, int freq) {
+int pminute(long ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return dinfo.minute;
 }
 
-int isecond(long ordinal, int freq) {
+int psecond(long ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
diff --git a/pandas/src/skts.h b/pandas/src/period.h
similarity index 83%
rename from pandas/src/skts.h
rename to pandas/src/period.h
index a47fe8ace..c0d51a70a 100644
--- a/pandas/src/skts.h
+++ b/pandas/src/period.h
@@ -1,16 +1,16 @@
-/* 
+/*
  * Borrowed and derived code from scikits.timeseries that we will expose via
  * Cython to pandas. This primarily concerns interval representation and
  * frequency conversion routines.
  */
 
-#ifndef C_SKTS_H
-#define C_SKTS_H
+#ifndef C_PERIOD_H
+#define C_PERIOD_H
 
 #include <Python.h>
 
 /*
- * declarations from skts here
+ * declarations from period here
  */
 
 #define GREGORIAN_CALENDAR 0
@@ -120,31 +120,31 @@ typedef long (*freq_conv_func)(long, char, asfreq_info*);
  * new pandas API helper functions here
  */
 
-long resample(long skts_ordinal, int freq1, int freq2, char relation);
+long asfreq(long period_ordinal, int freq1, int freq2, char relation);
 
-long get_skts_ordinal(int year, int month, int day,
+long get_period_ordinal(int year, int month, int day,
                       int hour, int minute, int second,
                       int freq);
 
-long get_python_ordinal(long skts_ordinal, int freq);
+long get_python_ordinal(long period_ordinal, int freq);
 
-char *interval_strftime(long value, int freq, PyObject *args);
-char *interval_to_string(long value, int freq);
-char *interval_to_string2(long value, int freq, char *fmt);
+char *skts_strftime(long value, int freq, PyObject *args);
+char *period_to_string(long value, int freq);
+char *period_to_string2(long value, int freq, char *fmt);
 
 int get_date_info(long ordinal, int freq, struct date_info *dinfo);
 
-int iyear(long ordinal, int freq);
-int iqyear(long ordinal, int freq);
-int iquarter(long ordinal, int freq);
-int imonth(long ordinal, int freq);
-int iday(long ordinal, int freq);
-int iweekday(long ordinal, int freq);
-int iday_of_week(long ordinal, int freq);
-int iday_of_year(long ordinal, int freq);
-int iweek(long ordinal, int freq);
-int ihour(long ordinal, int freq);
-int iminute(long ordinal, int freq);
-int isecond(long ordinal, int freq);
+int pyear(long ordinal, int freq);
+int pqyear(long ordinal, int freq);
+int pquarter(long ordinal, int freq);
+int pmonth(long ordinal, int freq);
+int pday(long ordinal, int freq);
+int pweekday(long ordinal, int freq);
+int pday_of_week(long ordinal, int freq);
+int pday_of_year(long ordinal, int freq);
+int pweek(long ordinal, int freq);
+int phour(long ordinal, int freq);
+int pminute(long ordinal, int freq);
+int psecond(long ordinal, int freq);
 
 #endif
diff --git a/pandas/tests/test_daterange.py b/pandas/tests/test_daterange.py
index b29068020..2eef5c88e 100644
--- a/pandas/tests/test_daterange.py
+++ b/pandas/tests/test_daterange.py
@@ -7,10 +7,9 @@ import numpy as np
 import pandas.core.datetools as datetools
 from pandas.core.datetools import generate_range
 from pandas.core.index import Index, DatetimeIndex
-from pandas.core.daterange import bdate_range, date_range
-import pandas.util.testing as tm
 
-import pandas._tseries as lib
+from pandas.tseries.index import bdate_range, date_range
+import pandas.tseries.tools as tools
 
 try:
     import pytz
@@ -330,17 +329,17 @@ class TestDateRange(unittest.TestCase):
 
         start = eastern.localize(_start)
         end = eastern.localize(_end)
-        assert(datetools._infer_tzinfo(start, end) is eastern)
-        assert(datetools._infer_tzinfo(start, None) is eastern)
-        assert(datetools._infer_tzinfo(None, end) is eastern)
+        assert(tools._infer_tzinfo(start, end) is eastern)
+        assert(tools._infer_tzinfo(start, None) is eastern)
+        assert(tools._infer_tzinfo(None, end) is eastern)
 
         start = utc.localize(_start)
         end = utc.localize(_end)
-        assert(datetools._infer_tzinfo(start, end) is utc)
+        assert(tools._infer_tzinfo(start, end) is utc)
 
         end = eastern.localize(_end)
-        self.assertRaises(Exception, datetools._infer_tzinfo, start, end)
-        self.assertRaises(Exception, datetools._infer_tzinfo, end, start)
+        self.assertRaises(Exception, tools._infer_tzinfo, start, end)
+        self.assertRaises(Exception, tools._infer_tzinfo, end, start)
 
     def test_date_parse_failure(self):
         badly_formed_date = '2007/100/1'
diff --git a/pandas/tests/test_datetools.py b/pandas/tests/test_datetools.py
index 97437dc94..5c1f35c52 100644
--- a/pandas/tests/test_datetools.py
+++ b/pandas/tests/test_datetools.py
@@ -8,8 +8,11 @@ from pandas.core.datetools import (
     DateOffset, Week, YearBegin, YearEnd, Hour, Minute, Second,
     WeekOfMonth, format, ole2datetime, QuarterEnd, to_datetime, normalize_date,
     get_offset, get_offset_name, inferTimeRule, hasOffsetName,
-    _dt_box, _dt_unbox, parse_time_string, get_standard_freq,
-    _offset_map)
+    get_standard_freq)
+
+from pandas.tseries.frequencies import _offset_map
+from pandas.tseries.index import _to_m8
+from pandas.tseries.tools import parse_time_string
 
 from nose.tools import assert_raises
 
@@ -50,9 +53,9 @@ def test_normalize_date():
     actual = normalize_date(datetime(2007, 10, 1, 1, 12, 5, 10))
     assert actual == datetime(2007, 10, 1)
 
-def test_datetime64_unbox():
+def test_to_m8():
     valb = datetime(2007, 10, 1)
-    valu = _dt_unbox(valb)
+    valu = _to_m8(valb)
     assert type(valu) == np.datetime64
     #assert valu == np.datetime64(datetime(2007,10,1))
 
diff --git a/pandas/tests/test_graphics.py b/pandas/tests/test_graphics.py
index b5d4ae6cc..c5095966b 100644
--- a/pandas/tests/test_graphics.py
+++ b/pandas/tests/test_graphics.py
@@ -3,7 +3,7 @@ import os
 import string
 import unittest
 
-from pandas import Series, DataFrame, MultiIndex, IntervalIndex
+from pandas import Series, DataFrame, MultiIndex, PeriodIndex
 import pandas.util.testing as tm
 
 import numpy as np
@@ -32,7 +32,7 @@ class TestSeriesPlots(unittest.TestCase):
         self.series = tm.makeStringSeries()
         self.series.name = 'series'
 
-        self.iseries = tm.makeIntervalSeries()
+        self.iseries = tm.makePeriodSeries()
         self.iseries.name = 'iseries'
 
     @slow
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index d5679b639..d2ef630d0 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -8,13 +8,14 @@ import nose
 
 import numpy as np
 
-from pandas.core.index import Index, Int64Index, Factor, MultiIndex
+from pandas.core.factor import Factor
+from pandas.core.index import Index, Int64Index, MultiIndex
 from pandas.util.testing import assert_almost_equal
 from pandas.util import py3compat
 
 import pandas.util.testing as tm
-import pandas._tseries as tseries
-from pandas.core.datetools import _dt_unbox
+
+from pandas.tseries.index import _to_m8
 
 class TestIndex(unittest.TestCase):
 
@@ -113,7 +114,7 @@ class TestIndex(unittest.TestCase):
     def test_comparators(self):
         index = self.dateIndex
         element = index[len(index) // 2]
-        element = _dt_unbox(element)
+        element = _to_m8(element)
 
         arr = np.array(index)
 
@@ -153,7 +154,7 @@ class TestIndex(unittest.TestCase):
     def test_getitem(self):
         arr = np.array(self.dateIndex)
         exp = self.dateIndex[5]
-        exp = _dt_unbox(exp)
+        exp = _to_m8(exp)
 
         self.assertEquals(exp, arr[5])
 
diff --git a/pandas/tests/test_interval.py b/pandas/tests/test_interval.py
deleted file mode 100644
index cc5c884d7..000000000
--- a/pandas/tests/test_interval.py
+++ /dev/null
@@ -1,1080 +0,0 @@
-"""Tests suite for Interval handling.
-
-Parts derived from scikits.timeseries code, original authors:
-- Pierre Gerard-Marchant & Matt Knox
-- pierregm_at_uga_dot_edu - mattknow_ca_at_hotmail_dot_com
-
-"""
-
-from unittest import TestCase
-from datetime import datetime
-
-from numpy.ma.testutils import assert_equal
-from pandas.core.datetools import Interval
-from pandas.core.index import IntervalIndex, DatetimeIndex
-import pandas.core.datetools as datetools
-import numpy as np
-
-from pandas import Series
-from pandas.util.testing import assert_series_equal
-
-class TestIntervalProperties(TestCase):
-    "Test properties such as year, month, weekday, etc...."
-    #
-    def __init__(self, *args, **kwds):
-        TestCase.__init__(self, *args, **kwds)
-
-    def test_interval_constructor(self):
-        i1 = Interval('1/1/2005', freq='M')
-        i2 = Interval('Jan 2005')
-
-        self.assertEquals(i1, i2)
-
-        i1 = Interval('2005', freq='A')
-        i2 = Interval('2005')
-        i3 = Interval('2005', freq='a')
-
-        self.assertEquals(i1, i2)
-        self.assertEquals(i1, i3)
-
-        i4 = Interval('2005', freq='M')
-        i5 = Interval('2005', freq='m')
-
-        self.assert_(i1 != i4)
-        self.assertEquals(i4, i5)
-
-        i1 = Interval.now('Q')
-        i2 = Interval(datetime.now(), freq='Q')
-        i3 = Interval.now('q')
-
-        self.assertEquals(i1, i2)
-        self.assertEquals(i1, i3)
-
-        # Biz day construction, roll forward if non-weekday
-        i1 = Interval('3/10/12', freq='B')
-        i2 = Interval('3/12/12', freq='D')
-        self.assertEquals(i1, i2.resample('B'))
-
-        i3 = Interval('3/10/12', freq='b')
-        self.assertEquals(i1, i3)
-
-        i1 = Interval(year=2005, quarter=1, freq='Q')
-        i2 = Interval('1/1/2005', freq='Q')
-        self.assertEquals(i1, i2)
-
-        i1 = Interval(year=2005, quarter=3, freq='Q')
-        i2 = Interval('9/1/2005', freq='Q')
-        self.assertEquals(i1, i2)
-
-        i1 = Interval(year=2005, month=3, day=1, freq='D')
-        i2 = Interval('3/1/2005', freq='D')
-        self.assertEquals(i1, i2)
-
-        i3 = Interval(year=2005, month=3, day=1, freq='d')
-        self.assertEquals(i1, i3)
-
-        i1 = Interval(year=2012, month=3, day=10, freq='B')
-        i2 = Interval('3/12/12', freq='B')
-        self.assertEquals(i1, i2)
-
-        i1 = Interval('2005Q1')
-        i2 = Interval(year=2005, quarter=1, freq='Q')
-        i3 = Interval('2005q1')
-        self.assertEquals(i1, i2)
-        self.assertEquals(i1, i3)
-
-        i1 = Interval('05Q1')
-        self.assertEquals(i1, i2)
-        lower = Interval('05q1')
-        self.assertEquals(i1, lower)
-
-        i1 = Interval('1Q2005')
-        self.assertEquals(i1, i2)
-        lower = Interval('1q2005')
-        self.assertEquals(i1, lower)
-
-        i1 = Interval('1Q05')
-        self.assertEquals(i1, i2)
-        lower = Interval('1q05')
-        self.assertEquals(i1, lower)
-
-        i1 = Interval('4Q1984')
-        self.assertEquals(i1.year, 1984)
-        lower = Interval('4q1984')
-        self.assertEquals(i1, lower)
-
-        i1 = Interval('1982', freq='min')
-        i2 = Interval('1982', freq='MIN')
-        self.assertEquals(i1, i2)
-        i2 = Interval('1982', freq=('Min', 1))
-        self.assertEquals(i1, i2)
-
-    def test_freq_str(self):
-        i1 = Interval('1982', freq='Min')
-        self.assert_(i1.freq[0] != '1')
-
-        i2 = Interval('11/30/2005', freq='2Q')
-        self.assertEquals(i2.freq[0], '2')
-
-    def test_to_timestamp(self):
-        intv = Interval('1982', freq='A')
-        start_ts = intv.to_timestamp(which_end='S')
-        aliases = ['s', 'StarT', 'BEGIn']
-        for a in aliases:
-            self.assertEquals(start_ts, intv.to_timestamp(which_end=a))
-
-        end_ts = intv.to_timestamp(which_end='E')
-        aliases = ['e', 'end', 'FINIsH']
-        for a in aliases:
-            self.assertEquals(end_ts, intv.to_timestamp(which_end=a))
-
-        from_lst = ['A', 'Q', 'M', 'W', 'B',
-                    'D', 'H', 'Min', 'S']
-        for i, fcode in enumerate(from_lst):
-            intv = Interval('1982', freq=fcode)
-            result = intv.to_timestamp().to_interval(fcode)
-            self.assertEquals(result, intv)
-
-            self.assertEquals(intv.start_time(), intv.to_timestamp('S'))
-
-            self.assertEquals(intv.end_time(), intv.to_timestamp('E'))
-
-
-    def test_properties_annually(self):
-        # Test properties on Intervals with annually frequency.
-        a_date = Interval(freq='A', year=2007)
-        assert_equal(a_date.year, 2007)
-
-    def test_properties_quarterly(self):
-        # Test properties on Intervals with daily frequency.
-        qedec_date = Interval(freq="Q-DEC", year=2007, quarter=1)
-        qejan_date = Interval(freq="Q-JAN", year=2007, quarter=1)
-        qejun_date = Interval(freq="Q-JUN", year=2007, quarter=1)
-        #
-        for x in range(3):
-            for qd in (qedec_date, qejan_date, qejun_date):
-                assert_equal((qd + x).qyear, 2007)
-                assert_equal((qd + x).quarter, x + 1)
-
-
-    def test_properties_monthly(self):
-        # Test properties on Intervals with daily frequency.
-        m_date = Interval(freq='M', year=2007, month=1)
-        for x in range(11):
-            m_ival_x = m_date + x
-            assert_equal(m_ival_x.year, 2007)
-            if 1 <= x + 1 <= 3:
-                assert_equal(m_ival_x.quarter, 1)
-            elif 4 <= x + 1 <= 6:
-                assert_equal(m_ival_x.quarter, 2)
-            elif 7 <= x + 1 <= 9:
-                assert_equal(m_ival_x.quarter, 3)
-            elif 10 <= x + 1 <= 12:
-                assert_equal(m_ival_x.quarter, 4)
-            assert_equal(m_ival_x.month, x + 1)
-
-
-    def test_properties_weekly(self):
-        # Test properties on Intervals with daily frequency.
-        w_date = Interval(freq='WK', year=2007, month=1, day=7)
-        #
-        assert_equal(w_date.year, 2007)
-        assert_equal(w_date.quarter, 1)
-        assert_equal(w_date.month, 1)
-        assert_equal(w_date.week, 1)
-        assert_equal((w_date - 1).week, 52)
-
-
-    def test_properties_daily(self):
-        # Test properties on Intervals with daily frequency.
-        b_date = Interval(freq='B', year=2007, month=1, day=1)
-        #
-        assert_equal(b_date.year, 2007)
-        assert_equal(b_date.quarter, 1)
-        assert_equal(b_date.month, 1)
-        assert_equal(b_date.day, 1)
-        assert_equal(b_date.weekday, 0)
-        assert_equal(b_date.day_of_year, 1)
-        #
-        d_date = Interval(freq='D', year=2007, month=1, day=1)
-        #
-        assert_equal(d_date.year, 2007)
-        assert_equal(d_date.quarter, 1)
-        assert_equal(d_date.month, 1)
-        assert_equal(d_date.day, 1)
-        assert_equal(d_date.weekday, 0)
-        assert_equal(d_date.day_of_year, 1)
-
-
-    def test_properties_hourly(self):
-        # Test properties on Intervals with hourly frequency.
-        h_date = Interval(freq='H', year=2007, month=1, day=1, hour=0)
-        #
-        assert_equal(h_date.year, 2007)
-        assert_equal(h_date.quarter, 1)
-        assert_equal(h_date.month, 1)
-        assert_equal(h_date.day, 1)
-        assert_equal(h_date.weekday, 0)
-        assert_equal(h_date.day_of_year, 1)
-        assert_equal(h_date.hour, 0)
-        #
-
-
-    def test_properties_minutely(self):
-        # Test properties on Intervals with minutely frequency.
-        t_date = Interval(freq='Min', year=2007, month=1, day=1, hour=0,
-                          minute=0)
-        #
-        assert_equal(t_date.quarter, 1)
-        assert_equal(t_date.month, 1)
-        assert_equal(t_date.day, 1)
-        assert_equal(t_date.weekday, 0)
-        assert_equal(t_date.day_of_year, 1)
-        assert_equal(t_date.hour, 0)
-        assert_equal(t_date.minute, 0)
-
-
-    def test_properties_secondly(self):
-        # Test properties on Intervals with secondly frequency.
-        s_date = Interval(freq='Min', year=2007, month=1, day=1,
-                                       hour=0, minute=0, second=0)
-        #
-        assert_equal(s_date.year, 2007)
-        assert_equal(s_date.quarter, 1)
-        assert_equal(s_date.month, 1)
-        assert_equal(s_date.day, 1)
-        assert_equal(s_date.weekday, 0)
-        assert_equal(s_date.day_of_year, 1)
-        assert_equal(s_date.hour, 0)
-        assert_equal(s_date.minute, 0)
-        assert_equal(s_date.second, 0)
-
-def noWrap(item):
-    return item
-
-class TestFreqConversion(TestCase):
-    "Test frequency conversion of date objects"
-
-    def __init__(self, *args, **kwds):
-        TestCase.__init__(self, *args, **kwds)
-
-    def test_conv_annual(self):
-        # frequency conversion tests: from Annual Frequency
-
-        ival_A = Interval(freq='A', year=2007)
-
-        ival_AJAN = Interval(freq="A-JAN", year=2007)
-        ival_AJUN = Interval(freq="A-JUN", year=2007)
-        ival_ANOV = Interval(freq="A-NOV", year=2007)
-
-        ival_A_to_Q_start = Interval(freq='Q', year=2007, quarter=1)
-        ival_A_to_Q_end = Interval(freq='Q', year=2007, quarter=4)
-        ival_A_to_M_start = Interval(freq='M', year=2007, month=1)
-        ival_A_to_M_end = Interval(freq='M', year=2007, month=12)
-        ival_A_to_W_start = Interval(freq='WK', year=2007, month=1, day=1)
-        ival_A_to_W_end = Interval(freq='WK', year=2007, month=12, day=31)
-        ival_A_to_B_start = Interval(freq='B', year=2007, month=1, day=1)
-        ival_A_to_B_end = Interval(freq='B', year=2007, month=12, day=31)
-        ival_A_to_D_start = Interval(freq='D', year=2007, month=1, day=1)
-        ival_A_to_D_end = Interval(freq='D', year=2007, month=12, day=31)
-        ival_A_to_H_start = Interval(freq='H', year=2007, month=1, day=1,
-                                    hour=0)
-        ival_A_to_H_end = Interval(freq='H', year=2007, month=12, day=31,
-                                    hour=23)
-        ival_A_to_T_start = Interval(freq='Min', year=2007, month=1, day=1,
-                                    hour=0, minute=0)
-        ival_A_to_T_end = Interval(freq='Min', year=2007, month=12, day=31,
-                                    hour=23, minute=59)
-        ival_A_to_S_start = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=0, minute=0, second=0)
-        ival_A_to_S_end = Interval(freq='S', year=2007, month=12, day=31,
-                                    hour=23, minute=59, second=59)
-
-        ival_AJAN_to_D_end = Interval(freq='D', year=2007, month=1, day=31)
-        ival_AJAN_to_D_start = Interval(freq='D', year=2006, month=2, day=1)
-        ival_AJUN_to_D_end = Interval(freq='D', year=2007, month=6, day=30)
-        ival_AJUN_to_D_start = Interval(freq='D', year=2006, month=7, day=1)
-        ival_ANOV_to_D_end = Interval(freq='D', year=2007, month=11, day=30)
-        ival_ANOV_to_D_start = Interval(freq='D', year=2006, month=12, day=1)
-
-        assert_equal(ival_A.resample('Q', 'S'), ival_A_to_Q_start)
-        assert_equal(ival_A.resample('Q', 'E'), ival_A_to_Q_end)
-        assert_equal(ival_A.resample('M', 'S'), ival_A_to_M_start)
-        assert_equal(ival_A.resample('M', 'E'), ival_A_to_M_end)
-        assert_equal(ival_A.resample('WK', 'S'), ival_A_to_W_start)
-        assert_equal(ival_A.resample('WK', 'E'), ival_A_to_W_end)
-        assert_equal(ival_A.resample('B', 'S'), ival_A_to_B_start)
-        assert_equal(ival_A.resample('B', 'E'), ival_A_to_B_end)
-        assert_equal(ival_A.resample('D', 'S'), ival_A_to_D_start)
-        assert_equal(ival_A.resample('D', 'E'), ival_A_to_D_end)
-        assert_equal(ival_A.resample('H', 'S'), ival_A_to_H_start)
-        assert_equal(ival_A.resample('H', 'E'), ival_A_to_H_end)
-        assert_equal(ival_A.resample('Min', 'S'), ival_A_to_T_start)
-        assert_equal(ival_A.resample('Min', 'E'), ival_A_to_T_end)
-        assert_equal(ival_A.resample('S', 'S'), ival_A_to_S_start)
-        assert_equal(ival_A.resample('S', 'E'), ival_A_to_S_end)
-
-        assert_equal(ival_AJAN.resample('D', 'S'), ival_AJAN_to_D_start)
-        assert_equal(ival_AJAN.resample('D', 'E'), ival_AJAN_to_D_end)
-
-        assert_equal(ival_AJUN.resample('D', 'S'), ival_AJUN_to_D_start)
-        assert_equal(ival_AJUN.resample('D', 'E'), ival_AJUN_to_D_end)
-
-        assert_equal(ival_ANOV.resample('D', 'S'), ival_ANOV_to_D_start)
-        assert_equal(ival_ANOV.resample('D', 'E'), ival_ANOV_to_D_end)
-
-        assert_equal(ival_A.resample('A'), ival_A)
-
-
-    def test_conv_quarterly(self):
-        # frequency conversion tests: from Quarterly Frequency
-
-        ival_Q = Interval(freq='Q', year=2007, quarter=1)
-        ival_Q_end_of_year = Interval(freq='Q', year=2007, quarter=4)
-
-        ival_QEJAN = Interval(freq="Q-JAN", year=2007, quarter=1)
-        ival_QEJUN = Interval(freq="Q-JUN", year=2007, quarter=1)
-
-        ival_Q_to_A = Interval(freq='A', year=2007)
-        ival_Q_to_M_start = Interval(freq='M', year=2007, month=1)
-        ival_Q_to_M_end = Interval(freq='M', year=2007, month=3)
-        ival_Q_to_W_start = Interval(freq='WK', year=2007, month=1, day=1)
-        ival_Q_to_W_end = Interval(freq='WK', year=2007, month=3, day=31)
-        ival_Q_to_B_start = Interval(freq='B', year=2007, month=1, day=1)
-        ival_Q_to_B_end = Interval(freq='B', year=2007, month=3, day=30)
-        ival_Q_to_D_start = Interval(freq='D', year=2007, month=1, day=1)
-        ival_Q_to_D_end = Interval(freq='D', year=2007, month=3, day=31)
-        ival_Q_to_H_start = Interval(freq='H', year=2007, month=1, day=1,
-                                    hour=0)
-        ival_Q_to_H_end = Interval(freq='H', year=2007, month=3, day=31,
-                                    hour=23)
-        ival_Q_to_T_start = Interval(freq='Min', year=2007, month=1, day=1,
-                                    hour=0, minute=0)
-        ival_Q_to_T_end = Interval(freq='Min', year=2007, month=3, day=31,
-                                    hour=23, minute=59)
-        ival_Q_to_S_start = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=0, minute=0, second=0)
-        ival_Q_to_S_end = Interval(freq='S', year=2007, month=3, day=31,
-                                    hour=23, minute=59, second=59)
-
-        ival_QEJAN_to_D_start = Interval(freq='D', year=2006, month=2, day=1)
-        ival_QEJAN_to_D_end = Interval(freq='D', year=2006, month=4, day=30)
-
-        ival_QEJUN_to_D_start = Interval(freq='D', year=2006, month=7, day=1)
-        ival_QEJUN_to_D_end = Interval(freq='D', year=2006, month=9, day=30)
-
-        assert_equal(ival_Q.resample('A'), ival_Q_to_A)
-        assert_equal(ival_Q_end_of_year.resample('A'), ival_Q_to_A)
-
-        assert_equal(ival_Q.resample('M', 'S'), ival_Q_to_M_start)
-        assert_equal(ival_Q.resample('M', 'E'), ival_Q_to_M_end)
-        assert_equal(ival_Q.resample('WK', 'S'), ival_Q_to_W_start)
-        assert_equal(ival_Q.resample('WK', 'E'), ival_Q_to_W_end)
-        assert_equal(ival_Q.resample('B', 'S'), ival_Q_to_B_start)
-        assert_equal(ival_Q.resample('B', 'E'), ival_Q_to_B_end)
-        assert_equal(ival_Q.resample('D', 'S'), ival_Q_to_D_start)
-        assert_equal(ival_Q.resample('D', 'E'), ival_Q_to_D_end)
-        assert_equal(ival_Q.resample('H', 'S'), ival_Q_to_H_start)
-        assert_equal(ival_Q.resample('H', 'E'), ival_Q_to_H_end)
-        assert_equal(ival_Q.resample('Min', 'S'), ival_Q_to_T_start)
-        assert_equal(ival_Q.resample('Min', 'E'), ival_Q_to_T_end)
-        assert_equal(ival_Q.resample('S', 'S'), ival_Q_to_S_start)
-        assert_equal(ival_Q.resample('S', 'E'), ival_Q_to_S_end)
-
-        assert_equal(ival_QEJAN.resample('D', 'S'), ival_QEJAN_to_D_start)
-        assert_equal(ival_QEJAN.resample('D', 'E'), ival_QEJAN_to_D_end)
-        assert_equal(ival_QEJUN.resample('D', 'S'), ival_QEJUN_to_D_start)
-        assert_equal(ival_QEJUN.resample('D', 'E'), ival_QEJUN_to_D_end)
-
-        assert_equal(ival_Q.resample('Q'), ival_Q)
-
-
-    def test_conv_monthly(self):
-        # frequency conversion tests: from Monthly Frequency
-
-        ival_M = Interval(freq='M', year=2007, month=1)
-        ival_M_end_of_year = Interval(freq='M', year=2007, month=12)
-        ival_M_end_of_quarter = Interval(freq='M', year=2007, month=3)
-        ival_M_to_A = Interval(freq='A', year=2007)
-        ival_M_to_Q = Interval(freq='Q', year=2007, quarter=1)
-        ival_M_to_W_start = Interval(freq='WK', year=2007, month=1, day=1)
-        ival_M_to_W_end = Interval(freq='WK', year=2007, month=1, day=31)
-        ival_M_to_B_start = Interval(freq='B', year=2007, month=1, day=1)
-        ival_M_to_B_end = Interval(freq='B', year=2007, month=1, day=31)
-        ival_M_to_D_start = Interval(freq='D', year=2007, month=1, day=1)
-        ival_M_to_D_end = Interval(freq='D', year=2007, month=1, day=31)
-        ival_M_to_H_start = Interval(freq='H', year=2007, month=1, day=1,
-                                    hour=0)
-        ival_M_to_H_end = Interval(freq='H', year=2007, month=1, day=31,
-                                    hour=23)
-        ival_M_to_T_start = Interval(freq='Min', year=2007, month=1, day=1,
-                                    hour=0, minute=0)
-        ival_M_to_T_end = Interval(freq='Min', year=2007, month=1, day=31,
-                                    hour=23, minute=59)
-        ival_M_to_S_start = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=0, minute=0, second=0)
-        ival_M_to_S_end = Interval(freq='S', year=2007, month=1, day=31,
-                                    hour=23, minute=59, second=59)
-
-        assert_equal(ival_M.resample('A'), ival_M_to_A)
-        assert_equal(ival_M_end_of_year.resample('A'), ival_M_to_A)
-        assert_equal(ival_M.resample('Q'), ival_M_to_Q)
-        assert_equal(ival_M_end_of_quarter.resample('Q'), ival_M_to_Q)
-
-        assert_equal(ival_M.resample('WK', 'S'), ival_M_to_W_start)
-        assert_equal(ival_M.resample('WK', 'E'), ival_M_to_W_end)
-        assert_equal(ival_M.resample('B', 'S'), ival_M_to_B_start)
-        assert_equal(ival_M.resample('B', 'E'), ival_M_to_B_end)
-        assert_equal(ival_M.resample('D', 'S'), ival_M_to_D_start)
-        assert_equal(ival_M.resample('D', 'E'), ival_M_to_D_end)
-        assert_equal(ival_M.resample('H', 'S'), ival_M_to_H_start)
-        assert_equal(ival_M.resample('H', 'E'), ival_M_to_H_end)
-        assert_equal(ival_M.resample('Min', 'S'), ival_M_to_T_start)
-        assert_equal(ival_M.resample('Min', 'E'), ival_M_to_T_end)
-        assert_equal(ival_M.resample('S', 'S'), ival_M_to_S_start)
-        assert_equal(ival_M.resample('S', 'E'), ival_M_to_S_end)
-
-        assert_equal(ival_M.resample('M'), ival_M)
-
-
-    def test_conv_weekly(self):
-        # frequency conversion tests: from Weekly Frequency
-
-        ival_W = Interval(freq='WK', year=2007, month=1, day=1)
-
-        ival_WSUN = Interval(freq='WK', year=2007, month=1, day=7)
-        ival_WSAT = Interval(freq='WK-SAT', year=2007, month=1, day=6)
-        ival_WFRI = Interval(freq='WK-FRI', year=2007, month=1, day=5)
-        ival_WTHU = Interval(freq='WK-THU', year=2007, month=1, day=4)
-        ival_WWED = Interval(freq='WK-WED', year=2007, month=1, day=3)
-        ival_WTUE = Interval(freq='WK-TUE', year=2007, month=1, day=2)
-        ival_WMON = Interval(freq='WK-MON', year=2007, month=1, day=1)
-
-        ival_WSUN_to_D_start = Interval(freq='D', year=2007, month=1, day=1)
-        ival_WSUN_to_D_end = Interval(freq='D', year=2007, month=1, day=7)
-        ival_WSAT_to_D_start = Interval(freq='D', year=2006, month=12, day=31)
-        ival_WSAT_to_D_end = Interval(freq='D', year=2007, month=1, day=6)
-        ival_WFRI_to_D_start = Interval(freq='D', year=2006, month=12, day=30)
-        ival_WFRI_to_D_end = Interval(freq='D', year=2007, month=1, day=5)
-        ival_WTHU_to_D_start = Interval(freq='D', year=2006, month=12, day=29)
-        ival_WTHU_to_D_end = Interval(freq='D', year=2007, month=1, day=4)
-        ival_WWED_to_D_start = Interval(freq='D', year=2006, month=12, day=28)
-        ival_WWED_to_D_end = Interval(freq='D', year=2007, month=1, day=3)
-        ival_WTUE_to_D_start = Interval(freq='D', year=2006, month=12, day=27)
-        ival_WTUE_to_D_end = Interval(freq='D', year=2007, month=1, day=2)
-        ival_WMON_to_D_start = Interval(freq='D', year=2006, month=12, day=26)
-        ival_WMON_to_D_end = Interval(freq='D', year=2007, month=1, day=1)
-
-        ival_W_end_of_year = Interval(freq='WK', year=2007, month=12, day=31)
-        ival_W_end_of_quarter = Interval(freq='WK', year=2007, month=3, day=31)
-        ival_W_end_of_month = Interval(freq='WK', year=2007, month=1, day=31)
-        ival_W_to_A = Interval(freq='A', year=2007)
-        ival_W_to_Q = Interval(freq='Q', year=2007, quarter=1)
-        ival_W_to_M = Interval(freq='M', year=2007, month=1)
-
-        if Interval(freq='D', year=2007, month=12, day=31).weekday == 6:
-            ival_W_to_A_end_of_year = Interval(freq='A', year=2007)
-        else:
-            ival_W_to_A_end_of_year = Interval(freq='A', year=2008)
-
-        if Interval(freq='D', year=2007, month=3, day=31).weekday == 6:
-            ival_W_to_Q_end_of_quarter = Interval(freq='Q', year=2007,
-                                                  quarter=1)
-        else:
-            ival_W_to_Q_end_of_quarter = Interval(freq='Q', year=2007,
-                                                  quarter=2)
-
-        if Interval(freq='D', year=2007, month=1, day=31).weekday == 6:
-            ival_W_to_M_end_of_month = Interval(freq='M', year=2007, month=1)
-        else:
-            ival_W_to_M_end_of_month = Interval(freq='M', year=2007, month=2)
-
-        ival_W_to_B_start = Interval(freq='B', year=2007, month=1, day=1)
-        ival_W_to_B_end = Interval(freq='B', year=2007, month=1, day=5)
-        ival_W_to_D_start = Interval(freq='D', year=2007, month=1, day=1)
-        ival_W_to_D_end = Interval(freq='D', year=2007, month=1, day=7)
-        ival_W_to_H_start = Interval(freq='H', year=2007, month=1, day=1,
-                                    hour=0)
-        ival_W_to_H_end = Interval(freq='H', year=2007, month=1, day=7,
-                                    hour=23)
-        ival_W_to_T_start = Interval(freq='Min', year=2007, month=1, day=1,
-                                    hour=0, minute=0)
-        ival_W_to_T_end = Interval(freq='Min', year=2007, month=1, day=7,
-                                    hour=23, minute=59)
-        ival_W_to_S_start = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=0, minute=0, second=0)
-        ival_W_to_S_end = Interval(freq='S', year=2007, month=1, day=7,
-                                    hour=23, minute=59, second=59)
-
-        assert_equal(ival_W.resample('A'), ival_W_to_A)
-        assert_equal(ival_W_end_of_year.resample('A'),
-                     ival_W_to_A_end_of_year)
-        assert_equal(ival_W.resample('Q'), ival_W_to_Q)
-        assert_equal(ival_W_end_of_quarter.resample('Q'),
-                     ival_W_to_Q_end_of_quarter)
-        assert_equal(ival_W.resample('M'), ival_W_to_M)
-        assert_equal(ival_W_end_of_month.resample('M'),
-                     ival_W_to_M_end_of_month)
-
-        assert_equal(ival_W.resample('B', 'S'), ival_W_to_B_start)
-        assert_equal(ival_W.resample('B', 'E'), ival_W_to_B_end)
-
-        assert_equal(ival_W.resample('D', 'S'), ival_W_to_D_start)
-        assert_equal(ival_W.resample('D', 'E'), ival_W_to_D_end)
-
-        assert_equal(ival_WSUN.resample('D', 'S'), ival_WSUN_to_D_start)
-        assert_equal(ival_WSUN.resample('D', 'E'), ival_WSUN_to_D_end)
-        assert_equal(ival_WSAT.resample('D', 'S'), ival_WSAT_to_D_start)
-        assert_equal(ival_WSAT.resample('D', 'E'), ival_WSAT_to_D_end)
-        assert_equal(ival_WFRI.resample('D', 'S'), ival_WFRI_to_D_start)
-        assert_equal(ival_WFRI.resample('D', 'E'), ival_WFRI_to_D_end)
-        assert_equal(ival_WTHU.resample('D', 'S'), ival_WTHU_to_D_start)
-        assert_equal(ival_WTHU.resample('D', 'E'), ival_WTHU_to_D_end)
-        assert_equal(ival_WWED.resample('D', 'S'), ival_WWED_to_D_start)
-        assert_equal(ival_WWED.resample('D', 'E'), ival_WWED_to_D_end)
-        assert_equal(ival_WTUE.resample('D', 'S'), ival_WTUE_to_D_start)
-        assert_equal(ival_WTUE.resample('D', 'E'), ival_WTUE_to_D_end)
-        assert_equal(ival_WMON.resample('D', 'S'), ival_WMON_to_D_start)
-        assert_equal(ival_WMON.resample('D', 'E'), ival_WMON_to_D_end)
-
-        assert_equal(ival_W.resample('H', 'S'), ival_W_to_H_start)
-        assert_equal(ival_W.resample('H', 'E'), ival_W_to_H_end)
-        assert_equal(ival_W.resample('Min', 'S'), ival_W_to_T_start)
-        assert_equal(ival_W.resample('Min', 'E'), ival_W_to_T_end)
-        assert_equal(ival_W.resample('S', 'S'), ival_W_to_S_start)
-        assert_equal(ival_W.resample('S', 'E'), ival_W_to_S_end)
-
-        assert_equal(ival_W.resample('WK'), ival_W)
-
-
-    def test_conv_business(self):
-        # frequency conversion tests: from Business Frequency"
-
-        ival_B = Interval(freq='B', year=2007, month=1, day=1)
-        ival_B_end_of_year = Interval(freq='B', year=2007, month=12, day=31)
-        ival_B_end_of_quarter = Interval(freq='B', year=2007, month=3, day=30)
-        ival_B_end_of_month = Interval(freq='B', year=2007, month=1, day=31)
-        ival_B_end_of_week = Interval(freq='B', year=2007, month=1, day=5)
-
-        ival_B_to_A = Interval(freq='A', year=2007)
-        ival_B_to_Q = Interval(freq='Q', year=2007, quarter=1)
-        ival_B_to_M = Interval(freq='M', year=2007, month=1)
-        ival_B_to_W = Interval(freq='WK', year=2007, month=1, day=7)
-        ival_B_to_D = Interval(freq='D', year=2007, month=1, day=1)
-        ival_B_to_H_start = Interval(freq='H', year=2007, month=1, day=1,
-                                    hour=0)
-        ival_B_to_H_end = Interval(freq='H', year=2007, month=1, day=1,
-                                    hour=23)
-        ival_B_to_T_start = Interval(freq='Min', year=2007, month=1, day=1,
-                                    hour=0, minute=0)
-        ival_B_to_T_end = Interval(freq='Min', year=2007, month=1, day=1,
-                                    hour=23, minute=59)
-        ival_B_to_S_start = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=0, minute=0, second=0)
-        ival_B_to_S_end = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=23, minute=59, second=59)
-
-        assert_equal(ival_B.resample('A'), ival_B_to_A)
-        assert_equal(ival_B_end_of_year.resample('A'), ival_B_to_A)
-        assert_equal(ival_B.resample('Q'), ival_B_to_Q)
-        assert_equal(ival_B_end_of_quarter.resample('Q'), ival_B_to_Q)
-        assert_equal(ival_B.resample('M'), ival_B_to_M)
-        assert_equal(ival_B_end_of_month.resample('M'), ival_B_to_M)
-        assert_equal(ival_B.resample('WK'), ival_B_to_W)
-        assert_equal(ival_B_end_of_week.resample('WK'), ival_B_to_W)
-
-        assert_equal(ival_B.resample('D'), ival_B_to_D)
-
-        assert_equal(ival_B.resample('H', 'S'), ival_B_to_H_start)
-        assert_equal(ival_B.resample('H', 'E'), ival_B_to_H_end)
-        assert_equal(ival_B.resample('Min', 'S'), ival_B_to_T_start)
-        assert_equal(ival_B.resample('Min', 'E'), ival_B_to_T_end)
-        assert_equal(ival_B.resample('S', 'S'), ival_B_to_S_start)
-        assert_equal(ival_B.resample('S', 'E'), ival_B_to_S_end)
-
-        assert_equal(ival_B.resample('B'), ival_B)
-
-
-    def test_conv_daily(self):
-        # frequency conversion tests: from Business Frequency"
-
-        ival_D = Interval(freq='D', year=2007, month=1, day=1)
-        ival_D_end_of_year = Interval(freq='D', year=2007, month=12, day=31)
-        ival_D_end_of_quarter = Interval(freq='D', year=2007, month=3, day=31)
-        ival_D_end_of_month = Interval(freq='D', year=2007, month=1, day=31)
-        ival_D_end_of_week = Interval(freq='D', year=2007, month=1, day=7)
-
-        ival_D_friday = Interval(freq='D', year=2007, month=1, day=5)
-        ival_D_saturday = Interval(freq='D', year=2007, month=1, day=6)
-        ival_D_sunday = Interval(freq='D', year=2007, month=1, day=7)
-        ival_D_monday = Interval(freq='D', year=2007, month=1, day=8)
-
-        ival_B_friday = Interval(freq='B', year=2007, month=1, day=5)
-        ival_B_monday = Interval(freq='B', year=2007, month=1, day=8)
-
-        ival_D_to_A = Interval(freq='A', year=2007)
-
-        ival_Deoq_to_AJAN = Interval(freq='A-JAN', year=2008)
-        ival_Deoq_to_AJUN = Interval(freq='A-JUN', year=2007)
-        ival_Deoq_to_ADEC = Interval(freq='A-DEC', year=2007)
-
-        ival_D_to_QEJAN = Interval(freq="Q-JAN", year=2007, quarter=4)
-        ival_D_to_QEJUN = Interval(freq="Q-JUN", year=2007, quarter=3)
-        ival_D_to_QEDEC = Interval(freq="Q-DEC", year=2007, quarter=1)
-
-        ival_D_to_M = Interval(freq='M', year=2007, month=1)
-        ival_D_to_W = Interval(freq='WK', year=2007, month=1, day=7)
-
-        ival_D_to_H_start = Interval(freq='H', year=2007, month=1, day=1,
-                                    hour=0)
-        ival_D_to_H_end = Interval(freq='H', year=2007, month=1, day=1,
-                                    hour=23)
-        ival_D_to_T_start = Interval(freq='Min', year=2007, month=1, day=1,
-                                    hour=0, minute=0)
-        ival_D_to_T_end = Interval(freq='Min', year=2007, month=1, day=1,
-                                    hour=23, minute=59)
-        ival_D_to_S_start = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=0, minute=0, second=0)
-        ival_D_to_S_end = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=23, minute=59, second=59)
-
-        assert_equal(ival_D.resample('A'), ival_D_to_A)
-
-        assert_equal(ival_D_end_of_quarter.resample('A-JAN'),
-                     ival_Deoq_to_AJAN)
-        assert_equal(ival_D_end_of_quarter.resample('A-JUN'),
-                     ival_Deoq_to_AJUN)
-        assert_equal(ival_D_end_of_quarter.resample('A-DEC'),
-                     ival_Deoq_to_ADEC)
-
-        assert_equal(ival_D_end_of_year.resample('A'), ival_D_to_A)
-        assert_equal(ival_D_end_of_quarter.resample('Q'), ival_D_to_QEDEC)
-        assert_equal(ival_D.resample("Q-JAN"), ival_D_to_QEJAN)
-        assert_equal(ival_D.resample("Q-JUN"), ival_D_to_QEJUN)
-        assert_equal(ival_D.resample("Q-DEC"), ival_D_to_QEDEC)
-        assert_equal(ival_D.resample('M'), ival_D_to_M)
-        assert_equal(ival_D_end_of_month.resample('M'), ival_D_to_M)
-        assert_equal(ival_D.resample('WK'), ival_D_to_W)
-        assert_equal(ival_D_end_of_week.resample('WK'), ival_D_to_W)
-
-        assert_equal(ival_D_friday.resample('B'), ival_B_friday)
-        assert_equal(ival_D_saturday.resample('B', 'S'), ival_B_friday)
-        assert_equal(ival_D_saturday.resample('B', 'E'), ival_B_monday)
-        assert_equal(ival_D_sunday.resample('B', 'S'), ival_B_friday)
-        assert_equal(ival_D_sunday.resample('B', 'E'), ival_B_monday)
-
-        assert_equal(ival_D.resample('H', 'S'), ival_D_to_H_start)
-        assert_equal(ival_D.resample('H', 'E'), ival_D_to_H_end)
-        assert_equal(ival_D.resample('Min', 'S'), ival_D_to_T_start)
-        assert_equal(ival_D.resample('Min', 'E'), ival_D_to_T_end)
-        assert_equal(ival_D.resample('S', 'S'), ival_D_to_S_start)
-        assert_equal(ival_D.resample('S', 'E'), ival_D_to_S_end)
-
-        assert_equal(ival_D.resample('D'), ival_D)
-
-    def test_conv_hourly(self):
-        # frequency conversion tests: from Hourly Frequency"
-
-        ival_H = Interval(freq='H', year=2007, month=1, day=1, hour=0)
-        ival_H_end_of_year = Interval(freq='H', year=2007, month=12, day=31,
-                                    hour=23)
-        ival_H_end_of_quarter = Interval(freq='H', year=2007, month=3, day=31,
-                                        hour=23)
-        ival_H_end_of_month = Interval(freq='H', year=2007, month=1, day=31,
-                                    hour=23)
-        ival_H_end_of_week = Interval(freq='H', year=2007, month=1, day=7,
-                                    hour=23)
-        ival_H_end_of_day = Interval(freq='H', year=2007, month=1, day=1,
-                                    hour=23)
-        ival_H_end_of_bus = Interval(freq='H', year=2007, month=1, day=1,
-                                    hour=23)
-
-        ival_H_to_A = Interval(freq='A', year=2007)
-        ival_H_to_Q = Interval(freq='Q', year=2007, quarter=1)
-        ival_H_to_M = Interval(freq='M', year=2007, month=1)
-        ival_H_to_W = Interval(freq='WK', year=2007, month=1, day=7)
-        ival_H_to_D = Interval(freq='D', year=2007, month=1, day=1)
-        ival_H_to_B = Interval(freq='B', year=2007, month=1, day=1)
-
-        ival_H_to_T_start = Interval(freq='Min', year=2007, month=1, day=1,
-                                    hour=0, minute=0)
-        ival_H_to_T_end = Interval(freq='Min', year=2007, month=1, day=1,
-                                    hour=0, minute=59)
-        ival_H_to_S_start = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=0, minute=0, second=0)
-        ival_H_to_S_end = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=0, minute=59, second=59)
-
-        assert_equal(ival_H.resample('A'), ival_H_to_A)
-        assert_equal(ival_H_end_of_year.resample('A'), ival_H_to_A)
-        assert_equal(ival_H.resample('Q'), ival_H_to_Q)
-        assert_equal(ival_H_end_of_quarter.resample('Q'), ival_H_to_Q)
-        assert_equal(ival_H.resample('M'), ival_H_to_M)
-        assert_equal(ival_H_end_of_month.resample('M'), ival_H_to_M)
-        assert_equal(ival_H.resample('WK'), ival_H_to_W)
-        assert_equal(ival_H_end_of_week.resample('WK'), ival_H_to_W)
-        assert_equal(ival_H.resample('D'), ival_H_to_D)
-        assert_equal(ival_H_end_of_day.resample('D'), ival_H_to_D)
-        assert_equal(ival_H.resample('B'), ival_H_to_B)
-        assert_equal(ival_H_end_of_bus.resample('B'), ival_H_to_B)
-
-        assert_equal(ival_H.resample('Min', 'S'), ival_H_to_T_start)
-        assert_equal(ival_H.resample('Min', 'E'), ival_H_to_T_end)
-        assert_equal(ival_H.resample('S', 'S'), ival_H_to_S_start)
-        assert_equal(ival_H.resample('S', 'E'), ival_H_to_S_end)
-
-        assert_equal(ival_H.resample('H'), ival_H)
-
-    def test_conv_minutely(self):
-        # frequency conversion tests: from Minutely Frequency"
-
-        ival_T = Interval(freq='Min', year=2007, month=1, day=1,
-                        hour=0, minute=0)
-        ival_T_end_of_year = Interval(freq='Min', year=2007, month=12, day=31,
-                                    hour=23, minute=59)
-        ival_T_end_of_quarter = Interval(freq='Min', year=2007, month=3, day=31,
-                                        hour=23, minute=59)
-        ival_T_end_of_month = Interval(freq='Min', year=2007, month=1, day=31,
-                                    hour=23, minute=59)
-        ival_T_end_of_week = Interval(freq='Min', year=2007, month=1, day=7,
-                                    hour=23, minute=59)
-        ival_T_end_of_day = Interval(freq='Min', year=2007, month=1, day=1,
-                                    hour=23, minute=59)
-        ival_T_end_of_bus = Interval(freq='Min', year=2007, month=1, day=1,
-                                    hour=23, minute=59)
-        ival_T_end_of_hour = Interval(freq='Min', year=2007, month=1, day=1,
-                                    hour=0, minute=59)
-
-        ival_T_to_A = Interval(freq='A', year=2007)
-        ival_T_to_Q = Interval(freq='Q', year=2007, quarter=1)
-        ival_T_to_M = Interval(freq='M', year=2007, month=1)
-        ival_T_to_W = Interval(freq='WK', year=2007, month=1, day=7)
-        ival_T_to_D = Interval(freq='D', year=2007, month=1, day=1)
-        ival_T_to_B = Interval(freq='B', year=2007, month=1, day=1)
-        ival_T_to_H = Interval(freq='H', year=2007, month=1, day=1, hour=0)
-
-        ival_T_to_S_start = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=0, minute=0, second=0)
-        ival_T_to_S_end = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=0, minute=0, second=59)
-
-        assert_equal(ival_T.resample('A'), ival_T_to_A)
-        assert_equal(ival_T_end_of_year.resample('A'), ival_T_to_A)
-        assert_equal(ival_T.resample('Q'), ival_T_to_Q)
-        assert_equal(ival_T_end_of_quarter.resample('Q'), ival_T_to_Q)
-        assert_equal(ival_T.resample('M'), ival_T_to_M)
-        assert_equal(ival_T_end_of_month.resample('M'), ival_T_to_M)
-        assert_equal(ival_T.resample('WK'), ival_T_to_W)
-        assert_equal(ival_T_end_of_week.resample('WK'), ival_T_to_W)
-        assert_equal(ival_T.resample('D'), ival_T_to_D)
-        assert_equal(ival_T_end_of_day.resample('D'), ival_T_to_D)
-        assert_equal(ival_T.resample('B'), ival_T_to_B)
-        assert_equal(ival_T_end_of_bus.resample('B'), ival_T_to_B)
-        assert_equal(ival_T.resample('H'), ival_T_to_H)
-        assert_equal(ival_T_end_of_hour.resample('H'), ival_T_to_H)
-
-        assert_equal(ival_T.resample('S', 'S'), ival_T_to_S_start)
-        assert_equal(ival_T.resample('S', 'E'), ival_T_to_S_end)
-
-        assert_equal(ival_T.resample('Min'), ival_T)
-
-    def test_conv_secondly(self):
-        # frequency conversion tests: from Secondly Frequency"
-
-        ival_S = Interval(freq='S', year=2007, month=1, day=1,
-                        hour=0, minute=0, second=0)
-        ival_S_end_of_year = Interval(freq='S', year=2007, month=12, day=31,
-                                    hour=23, minute=59, second=59)
-        ival_S_end_of_quarter = Interval(freq='S', year=2007, month=3, day=31,
-                                        hour=23, minute=59, second=59)
-        ival_S_end_of_month = Interval(freq='S', year=2007, month=1, day=31,
-                                    hour=23, minute=59, second=59)
-        ival_S_end_of_week = Interval(freq='S', year=2007, month=1, day=7,
-                                    hour=23, minute=59, second=59)
-        ival_S_end_of_day = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=23, minute=59, second=59)
-        ival_S_end_of_bus = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=23, minute=59, second=59)
-        ival_S_end_of_hour = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=0, minute=59, second=59)
-        ival_S_end_of_minute = Interval(freq='S', year=2007, month=1, day=1,
-                                    hour=0, minute=0, second=59)
-
-        ival_S_to_A = Interval(freq='A', year=2007)
-        ival_S_to_Q = Interval(freq='Q', year=2007, quarter=1)
-        ival_S_to_M = Interval(freq='M', year=2007, month=1)
-        ival_S_to_W = Interval(freq='WK', year=2007, month=1, day=7)
-        ival_S_to_D = Interval(freq='D', year=2007, month=1, day=1)
-        ival_S_to_B = Interval(freq='B', year=2007, month=1, day=1)
-        ival_S_to_H = Interval(freq='H', year=2007, month=1, day=1,
-                            hour=0)
-        ival_S_to_T = Interval(freq='Min', year=2007, month=1, day=1,
-                            hour=0, minute=0)
-
-        assert_equal(ival_S.resample('A'), ival_S_to_A)
-        assert_equal(ival_S_end_of_year.resample('A'), ival_S_to_A)
-        assert_equal(ival_S.resample('Q'), ival_S_to_Q)
-        assert_equal(ival_S_end_of_quarter.resample('Q'), ival_S_to_Q)
-        assert_equal(ival_S.resample('M'), ival_S_to_M)
-        assert_equal(ival_S_end_of_month.resample('M'), ival_S_to_M)
-        assert_equal(ival_S.resample('WK'), ival_S_to_W)
-        assert_equal(ival_S_end_of_week.resample('WK'), ival_S_to_W)
-        assert_equal(ival_S.resample('D'), ival_S_to_D)
-        assert_equal(ival_S_end_of_day.resample('D'), ival_S_to_D)
-        assert_equal(ival_S.resample('B'), ival_S_to_B)
-        assert_equal(ival_S_end_of_bus.resample('B'), ival_S_to_B)
-        assert_equal(ival_S.resample('H'), ival_S_to_H)
-        assert_equal(ival_S_end_of_hour.resample('H'), ival_S_to_H)
-        assert_equal(ival_S.resample('Min'), ival_S_to_T)
-        assert_equal(ival_S_end_of_minute.resample('Min'), ival_S_to_T)
-
-        assert_equal(ival_S.resample('S'), ival_S)
-
-class TestIntervalIndex(TestCase):
-    def __init__(self, *args, **kwds):
-        TestCase.__init__(self, *args, **kwds)
-
-    def test_constructor(self):
-        ii = IntervalIndex(freq='A', start='1/1/2001', end='12/1/2009')
-        assert_equal(len(ii), 9)
-
-        ii = IntervalIndex(freq='Q', start='1/1/2001', end='12/1/2009')
-        assert_equal(len(ii), 4 * 9)
-
-        ii = IntervalIndex(freq='M', start='1/1/2001', end='12/1/2009')
-        assert_equal(len(ii), 12 * 9)
-
-        ii = IntervalIndex(freq='D', start='1/1/2001', end='12/31/2009')
-        assert_equal(len(ii), 365 * 9 + 2)
-
-        ii = IntervalIndex(freq='B', start='1/1/2001', end='12/31/2009')
-        assert_equal(len(ii), 261 * 9)
-
-        ii = IntervalIndex(freq='H', start='1/1/2001', end='12/31/2001 23:00')
-        assert_equal(len(ii), 365 * 24)
-
-        ii = IntervalIndex(freq='Min', start='1/1/2001', end='1/1/2001 23:59')
-        assert_equal(len(ii), 24 * 60)
-
-        ii = IntervalIndex(freq='S', start='1/1/2001', end='1/1/2001 23:59:59')
-        assert_equal(len(ii), 24 * 60 * 60)
-
-        start = Interval('02-Apr-2005', 'B')
-        i1 = IntervalIndex(start=start, periods=20)
-        assert_equal(len(i1), 20)
-        assert_equal(i1.freq, start.freq)
-        assert_equal(i1[0], start)
-
-        end_intv = Interval('2006-12-31', 'W')
-        i1 = IntervalIndex(end=end_intv, periods=10)
-        assert_equal(len(i1), 10)
-        assert_equal(i1.freq, end_intv.freq)
-        assert_equal(i1[-1], end_intv)
-
-        end_intv = Interval('2006-12-31', '1w')
-        i2 = IntervalIndex(end=end_intv, periods=10)
-        assert_equal(len(i1), len(i2))
-        self.assert_((i1 == i2).all())
-        assert_equal(i1.freq, i2.freq)
-
-        end_intv = Interval('2006-12-31', ('w', 1))
-        i2 = IntervalIndex(end=end_intv, periods=10)
-        assert_equal(len(i1), len(i2))
-        self.assert_((i1 == i2).all())
-        assert_equal(i1.freq, i2.freq)
-
-        try:
-            IntervalIndex(start=start, end=end_intv)
-            raise AssertionError('Cannot allow mixed freq for start and end')
-        except ValueError:
-            pass
-
-        end_intv = Interval('2005-05-01', 'B')
-        i1 = IntervalIndex(start=start, end=end_intv)
-
-        try:
-            IntervalIndex(start=start)
-            raise AssertionError('Must specify periods if missing start or end')
-        except ValueError:
-            pass
-
-    def test_shift(self):
-        ii1 = IntervalIndex(freq='A', start='1/1/2001', end='12/1/2009')
-        ii2 = IntervalIndex(freq='A', start='1/1/2002', end='12/1/2010')
-        assert_equal(len(ii1), len(ii2))
-        assert_equal(ii1.shift(1).values, ii2.values)
-
-        ii1 = IntervalIndex(freq='A', start='1/1/2001', end='12/1/2009')
-        ii2 = IntervalIndex(freq='A', start='1/1/2000', end='12/1/2008')
-        assert_equal(len(ii1), len(ii2))
-        assert_equal(ii1.shift(-1).values, ii2.values)
-
-        ii1 = IntervalIndex(freq='M', start='1/1/2001', end='12/1/2009')
-        ii2 = IntervalIndex(freq='M', start='2/1/2001', end='1/1/2010')
-        assert_equal(len(ii1), len(ii2))
-        assert_equal(ii1.shift(1).values, ii2.values)
-
-        ii1 = IntervalIndex(freq='M', start='1/1/2001', end='12/1/2009')
-        ii2 = IntervalIndex(freq='M', start='12/1/2000', end='11/1/2009')
-        assert_equal(len(ii1), len(ii2))
-        assert_equal(ii1.shift(-1).values, ii2.values)
-
-        ii1 = IntervalIndex(freq='D', start='1/1/2001', end='12/1/2009')
-        ii2 = IntervalIndex(freq='D', start='1/2/2001', end='12/2/2009')
-        assert_equal(len(ii1), len(ii2))
-        assert_equal(ii1.shift(1).values, ii2.values)
-
-        ii1 = IntervalIndex(freq='D', start='1/1/2001', end='12/1/2009')
-        ii2 = IntervalIndex(freq='D', start='12/31/2000', end='11/30/2009')
-        assert_equal(len(ii1), len(ii2))
-        assert_equal(ii1.shift(-1).values, ii2.values)
-
-    def test_resample(self):
-        ii1 = IntervalIndex(freq='A', start='1/1/2001', end='1/1/2001')
-        ii2 = IntervalIndex(freq='Q', start='1/1/2001', end='1/1/2001')
-        ii3 = IntervalIndex(freq='M', start='1/1/2001', end='1/1/2001')
-        ii4 = IntervalIndex(freq='D', start='1/1/2001', end='1/1/2001')
-        ii5 = IntervalIndex(freq='H', start='1/1/2001', end='1/1/2001 00:00')
-        ii6 = IntervalIndex(freq='Min', start='1/1/2001', end='1/1/2001 00:00')
-        ii7 = IntervalIndex(freq='S', start='1/1/2001', end='1/1/2001 00:00:00')
-
-        self.assertEquals(ii1.resample('Q', 'S'), ii2)
-        self.assertEquals(ii1.resample('Q', 's'), ii2)
-        self.assertEquals(ii1.resample('M', 'start'), ii3)
-        self.assertEquals(ii1.resample('D', 'StarT'), ii4)
-        self.assertEquals(ii1.resample('H', 'beGIN'), ii5)
-        self.assertEquals(ii1.resample('Min', 'S'), ii6)
-        self.assertEquals(ii1.resample('S', 'S'), ii7)
-
-        self.assertEquals(ii2.resample('A', 'S'), ii1)
-        self.assertEquals(ii2.resample('M', 'S'), ii3)
-        self.assertEquals(ii2.resample('D', 'S'), ii4)
-        self.assertEquals(ii2.resample('H', 'S'), ii5)
-        self.assertEquals(ii2.resample('Min', 'S'), ii6)
-        self.assertEquals(ii2.resample('S', 'S'), ii7)
-
-        self.assertEquals(ii3.resample('A', 'S'), ii1)
-        self.assertEquals(ii3.resample('Q', 'S'), ii2)
-        self.assertEquals(ii3.resample('D', 'S'), ii4)
-        self.assertEquals(ii3.resample('H', 'S'), ii5)
-        self.assertEquals(ii3.resample('Min', 'S'), ii6)
-        self.assertEquals(ii3.resample('S', 'S'), ii7)
-
-        self.assertEquals(ii4.resample('A', 'S'), ii1)
-        self.assertEquals(ii4.resample('Q', 'S'), ii2)
-        self.assertEquals(ii4.resample('M', 'S'), ii3)
-        self.assertEquals(ii4.resample('H', 'S'), ii5)
-        self.assertEquals(ii4.resample('Min', 'S'), ii6)
-        self.assertEquals(ii4.resample('S', 'S'), ii7)
-
-        self.assertEquals(ii5.resample('A', 'S'), ii1)
-        self.assertEquals(ii5.resample('Q', 'S'), ii2)
-        self.assertEquals(ii5.resample('M', 'S'), ii3)
-        self.assertEquals(ii5.resample('D', 'S'), ii4)
-        self.assertEquals(ii5.resample('Min', 'S'), ii6)
-        self.assertEquals(ii5.resample('S', 'S'), ii7)
-
-        self.assertEquals(ii6.resample('A', 'S'), ii1)
-        self.assertEquals(ii6.resample('Q', 'S'), ii2)
-        self.assertEquals(ii6.resample('M', 'S'), ii3)
-        self.assertEquals(ii6.resample('D', 'S'), ii4)
-        self.assertEquals(ii6.resample('H', 'S'), ii5)
-        self.assertEquals(ii6.resample('S', 'S'), ii7)
-
-        self.assertEquals(ii7.resample('A', 'S'), ii1)
-        self.assertEquals(ii7.resample('Q', 'S'), ii2)
-        self.assertEquals(ii7.resample('M', 'S'), ii3)
-        self.assertEquals(ii7.resample('D', 'S'), ii4)
-        self.assertEquals(ii7.resample('H', 'S'), ii5)
-        self.assertEquals(ii7.resample('Min', 'S'), ii6)
-
-        #self.assertEquals(ii7.resample('A', 'E'), i_end)
-
-    def test_badinput(self):
-        self.assertRaises(datetools.DateParseError, Interval, '1/1/-2000', 'A')
-        self.assertRaises(ValueError, Interval, -2000, 'A')
-        self.assertRaises(ValueError, Interval, 0, 'A')
-        self.assertRaises(ValueError, IntervalIndex, [-1, 0, 1], 'A')
-        self.assertRaises(ValueError, IntervalIndex, np.array([-1, 0, 1]), 'A')
-
-    def test_dti_to_interval(self):
-        dti = DatetimeIndex(start='1/1/2005', end='12/1/2005', freq='M')
-        ii1 = dti.to_interval()
-        ii2 = dti.to_interval(freq='D')
-
-        self.assertEquals(ii1[0], Interval('Jan 2005', freq='M'))
-        self.assertEquals(ii2[0], Interval('1/31/2005', freq='D'))
-
-        self.assertEquals(ii1[-1], Interval('Nov 2005', freq='M'))
-        self.assertEquals(ii2[-1], Interval('11/30/2005', freq='D'))
-
-    def test_iindex_slice_index(self):
-        ii = IntervalIndex(start='1/1/10', end='12/31/12', freq='M')
-        s = Series(np.random.rand(len(ii)), index=ii)
-        res = s['2010']
-        exp = s[0:12]
-        assert_series_equal(res, exp)
-        res = s['2011']
-        exp = s[12:24]
-        assert_series_equal(res, exp)
-
-    def test_iindex_qaccess(self):
-        ii = IntervalIndex(['2Q05', '3Q05', '4Q05', '1Q06', '2Q06'], freq='Q')
-        s = Series(np.random.rand(len(ii)), index=ii).cumsum()
-        # Todo: fix these accessors!
-        self.assert_(s['05Q4'] == s[2])
-
-    def test_interval_dt64_round_trip(self):
-        dti = DatetimeIndex(['1/1/2002', '1/2/2002', '1/3/2002', '1/4/2002',
-                             '1/5/2002', '1/6/2002', '1/7/2002'], freq='B')
-        ii = dti.to_interval()
-        self.assert_(ii.to_timestamp().equals(dti))
-
-        dti = DatetimeIndex(['1/1/2002', '1/2/2002', '1/3/2002', '1/4/2002',
-                             '1/5/2002', '1/6/2002', '1/7/2002'], freq='B')
-        ii = dti.to_interval(freq='3H')
-        self.assert_(ii.to_timestamp().equals(dti))
-
-    def test_iindex_multiples(self):
-        ii = IntervalIndex(start='1/1/10', end='12/31/12', freq='2M')
-        self.assertEquals(ii[0], Interval('1/1/10', '2M'))
-        self.assertEquals(ii[1], Interval('3/1/10', '2M'))
-
-        self.assertEquals(ii[0].resample('6M'), ii[2].resample('6M'))
-        self.assertEquals(ii[0].resample('A'), ii[2].resample('A'))
-
-        self.assertEquals(ii[0].resample('M', how='S'),
-                          Interval('Jan 2010', '1M'))
-        self.assertEquals(ii[0].resample('M', how='E'),
-                          Interval('Feb 2010', '1M'))
-        self.assertEquals(ii[1].resample('M', how='S'),
-                          Interval('Mar 2010', '1M'))
-
-        i = Interval('1/1/2010 12:05:18', '5S')
-        self.assertEquals(i, Interval('1/1/2010 12:05:15', '5S'))
-
-        i = Interval('1/1/2010 12:05:18', '5S')
-        self.assertEquals(i.resample('1S', how='E'),
-                          Interval('1/1/2010 12:05:19', '1S'))
-
-class TestMethods(TestCase):
-    "Base test class for MaskedArrays."
-
-    def __init__(self, *args, **kwds):
-        TestCase.__init__(self, *args, **kwds)
-
-    def test_add(self):
-        dt1 = Interval(freq='D', year=2008, month=1, day=1)
-        dt2 = Interval(freq='D', year=2008, month=1, day=2)
-        assert_equal(dt1 + 1, dt2)
-        #
-        self.assertRaises(ValueError, dt1.__add__, "str")
-        self.assertRaises(ValueError, dt1.__add__, dt2)
-
-###############################################################################
-#------------------------------------------------------------------------------
-
-if __name__ == '__main__':
-    import nose
-    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
-                   exit=False)
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index e0efd2400..2e6f1eefa 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -15,6 +15,7 @@ import numpy.ma as ma
 from pandas import (Index, Series, TimeSeries, DataFrame, isnull, notnull,
                     bdate_range)
 from pandas.core.index import MultiIndex
+from pandas.tseries.index import Timestamp
 
 import pandas.core.datetools as datetools
 import pandas.core.nanops as nanops
@@ -2430,13 +2431,12 @@ class TestSeriesNonUnique(unittest.TestCase):
 
     def test_datetime_indexing(self):
         from pandas import date_range
-        from pandas.core.datetools import to_timestamp
 
         index = date_range('1/1/2000', '1/7/2000')
         index = index.repeat(3)
 
         s = Series(len(index), index=index)
-        stamp = to_timestamp('1/8/2000')
+        stamp = Timestamp('1/8/2000')
 
         self.assertRaises(KeyError, s.__getitem__, stamp)
         self.assertRaises(KeyError, s.__setitem__, stamp, 0)
diff --git a/pandas/tools/merge.py b/pandas/tools/merge.py
index f5ef1f9d6..0b61db569 100644
--- a/pandas/tools/merge.py
+++ b/pandas/tools/merge.py
@@ -4,11 +4,12 @@ SQL-style merge routines
 
 import numpy as np
 
+from pandas.core.factor import Factor
 from pandas.core.frame import DataFrame, _merge_doc
 from pandas.core.generic import NDFrame
 from pandas.core.groupby import get_group_index
 from pandas.core.series import Series
-from pandas.core.index import (Factor, Index, MultiIndex, _get_combined_index,
+from pandas.core.index import (Index, MultiIndex, _get_combined_index,
                                _ensure_index, _get_consensus_names)
 from pandas.core.internals import (IntBlock, BoolBlock, BlockManager,
                                    make_block, _consolidate)
diff --git a/pandas/tools/tsplotting.py b/pandas/tools/tsplotting.py
index c8048440e..fb7f7bb67 100644
--- a/pandas/tools/tsplotting.py
+++ b/pandas/tools/tsplotting.py
@@ -15,8 +15,8 @@ import numpy as np
 
 import pandas.core.datetools as datetools
 
-from pandas.core.datetools import Interval
-from pandas.core.index import IntervalIndex
+from pandas.core.datetools import Period
+from pandas.core.index import PeriodIndex
 from pandas.core.series import Series
 
 import warnings
@@ -135,7 +135,7 @@ def period_break(dates, period):
 
     Parameters
     ----------
-    dates : IntervalIndex
+    dates : PeriodIndex
         Array of intervals to monitor.
     period : string
         Name of the period to monitor.
@@ -216,10 +216,10 @@ def _daily_finder(vmin, vmax, freq):
     # save this for later usage
     vmin_orig = vmin
 
-    (vmin, vmax) = (Interval(value=int(vmin), freq=freq),
-                    Interval(value=int(vmax), freq=freq))
+    (vmin, vmax) = (Period(value=int(vmin), freq=freq),
+                    Period(value=int(vmax), freq=freq))
     span = vmax.ordinal - vmin.ordinal + 1
-    dates_ = IntervalIndex(start=vmin, end=vmax, freq=freq)
+    dates_ = PeriodIndex(start=vmin, end=vmax, freq=freq)
     # Initialize the output
     info = np.zeros(span,
                     dtype=[('val', int), ('maj', bool), ('min', bool),
@@ -651,7 +651,7 @@ class TimeSeries_DateLocator(Locator):
 #####-------------------------------------------------------------------------
 class TimeSeries_DateFormatter(Formatter):
     """
-    Formats the ticks along an axis controlled by a :class:`IntervalIndex`.
+    Formats the ticks along an axis controlled by a :class:`PeriodIndex`.
 
     Parameters
     ----------
@@ -722,7 +722,7 @@ class TimeSeries_DateFormatter(Formatter):
             return ''
         else:
             fmt = self.formatdict.pop(x, '')
-            return Interval(int(x), self.freq).strftime(fmt)
+            return Period(int(x), self.freq).strftime(fmt)
 
 
 #####--------------------------------------------------------------------------
@@ -744,7 +744,7 @@ class TimeSeriesPlot(Subplot, object):
     attribute.  It gives its frequency to the plot.  This frequency can be
     accessed through the attribute :attr:`freq`.  All the other series that
     will be plotted will be first converted to the :attr:`freq` frequency,
-    using their :meth:`~resample` method.
+    using their :meth:`~asfreq` method.
 
     The same parameters used for the instanciation of a standard
     :class:`matplotlib.axes.Subplot` are recognized.
@@ -758,7 +758,7 @@ class TimeSeriesPlot(Subplot, object):
     ----------
     freq : int
         Frequency of the plot.
-    xdata : IntervalIndex
+    xdata : PeriodIndex
         The array of dates corresponding to the x axis.
     legendsymbols : list
     legendlabels : list
@@ -871,12 +871,12 @@ class TimeSeriesPlot(Subplot, object):
                     output.extend([x, y, b])
                 else:
                     output.extend([x, y])
-            # The argument is a IntervalIndex............
-            elif isinstance(a, IntervalIndex):
+            # The argument is a PeriodIndex............
+            elif isinstance(a, PeriodIndex):
                 # Force to current freq
                 if self.freq is not None:
                     if a.freq != self.freq:
-                        a = a.resample(self.freq)
+                        a = a.asfreq(self.freq)
                 # There's an argument after
                 if len(remaining) > 0:
                     #...and it's a format string
@@ -887,7 +887,7 @@ class TimeSeriesPlot(Subplot, object):
                         else:
                             output.extend([a, self.series, b])
                     #... and it's another date: use the default
-                    elif isinstance(remaining[0], IntervalIndex):
+                    elif isinstance(remaining[0], PeriodIndex):
                         if self.series is None:
                             raise ValueError(noinfo_msg)
                         else:
@@ -921,7 +921,7 @@ class TimeSeriesPlot(Subplot, object):
         # Force the xdata to the current frequency
         elif output[0].freq != self.freq:
             output = list(output)
-            output[0] = output[0].resample(self.freq)
+            output[0] = output[0].asfreq(self.freq)
         return output
     #......................................................
     def tsplot(self, *args,  **kwargs):
@@ -1011,7 +1011,7 @@ class TimeSeriesPlot(Subplot, object):
     def set_dlim(self, start_date=None, end_date=None):
         """
         Sets the date limits of the plot to ``start_date`` and ``end_date``.
-        The dates can be given as :class:`~Interval` objects, strings or
+        The dates can be given as :class:`~Period` objects, strings or
         integers.
 
         Parameters
@@ -1028,10 +1028,10 @@ class TimeSeriesPlot(Subplot, object):
             raise ValueError("Undefined frequency! Date limits can't be set!")
         # TODO : Shouldn't we make get_datevalue a more generic function ?
         def get_datevalue(date, freq):
-            if isinstance(date, Interval):
-                return date.resample(freq).value
+            if isinstance(date, Period):
+                return date.asfreq(freq).value
             elif isinstance(date, str):
-                return Interval(date, freq).value
+                return Period(date, freq).value
             elif isinstance(date, (int, float)) or \
                 (isinstance(date, np.ndarray) and (date.size == 1)):
                 return date
@@ -1054,10 +1054,10 @@ class TimeSeriesPlot(Subplot, object):
 
     def get_dlim(self):
         """
-        Returns the limits of the x axis as a :class:`~IntervalIndex`.
+        Returns the limits of the x axis as a :class:`~PeriodIndex`.
         """
         xlims = self.get_xlim()
-        return IntervalIndex(xlims, freq=self.freq)
+        return PeriodIndex(xlims, freq=self.freq)
 
 TSPlot = TimeSeriesPlot
 
diff --git a/pandas/tseries/frequencies.py b/pandas/tseries/frequencies.py
new file mode 100644
index 000000000..3c4320cd5
--- /dev/null
+++ b/pandas/tseries/frequencies.py
@@ -0,0 +1,603 @@
+import re
+
+from pandas.tseries.offsets import DateOffset
+import pandas.tseries.offsets as offsets
+
+
+def get_freq_code(freqstr):
+    """
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+    """
+    if isinstance(freqstr, DateOffset):
+        freqstr = (get_offset_name(freqstr), freqstr.n)
+
+    if isinstance(freqstr, tuple):
+        if (isinstance(freqstr[0], (int, long)) and
+            isinstance(freqstr[1], (int, long))):
+            #e.g., freqstr = (2000, 1)
+            return freqstr
+        else:
+            #e.g., freqstr = ('T', 5)
+            try:
+                code = _period_str_to_code(freqstr[0])
+                stride = freqstr[1]
+            except:
+                code = _period_str_to_code(freqstr[1])
+                stride = freqstr[0]
+            return code, stride
+
+    if isinstance(freqstr, (int, long)):
+        return (freqstr, 1)
+
+    base, stride = _base_and_stride(freqstr)
+    code = _period_str_to_code(base)
+
+    return code, stride
+
+
+def _get_freq_str(base, mult):
+    code = _reverse_period_code_map.get(base)
+    if code is None:
+        return _unknown_freq
+    if mult == 1:
+        return code
+    return str(mult) + code
+
+
+_unknown_freq = 'Unknown'
+
+
+#-------------------------------------------------------------------------------
+# Offset names ("time rules") and related functions
+
+
+from pandas.tseries.offsets import (Day, BDay, Hour, Minute, Second, Milli,
+                                    Micro, MonthEnd, MonthBegin, BMonthBegin,
+                                    BMonthEnd, YearBegin, YearEnd, BYearBegin,
+                                    BYearEnd, QuarterBegin, QuarterEnd,
+                                    BQuarterBegin, BQuarterEnd)
+
+_offset_map = {
+    'D'     : Day(),
+    'B'     : BDay(),
+    'H'     : Hour(),
+    'T'     : Minute(),
+    'S'     : Second(),
+    'L'     : Milli(),
+    'U'     : Micro(),
+    None    : None,
+
+    # Monthly - Calendar
+    'M'      : MonthEnd(),
+    'MS'     : MonthBegin(),
+
+    # Monthly - Business
+    'BM'     : BMonthEnd(),
+    'BMS'    : BMonthBegin(),
+
+    # Annual - Calendar
+    'A-JAN' : YearEnd(month=1),
+    'A-FEB' : YearEnd(month=2),
+    'A-MAR' : YearEnd(month=3),
+    'A-APR' : YearEnd(month=4),
+    'A-MAY' : YearEnd(month=5),
+    'A-JUN' : YearEnd(month=6),
+    'A-JUL' : YearEnd(month=7),
+    'A-AUG' : YearEnd(month=8),
+    'A-SEP' : YearEnd(month=9),
+    'A-OCT' : YearEnd(month=10),
+    'A-NOV' : YearEnd(month=11),
+    'A-DEC' : YearEnd(month=12),
+    'A'     : YearEnd(month=12),
+
+    # Annual - Calendar (start)
+    'AS-JAN' : YearBegin(month=1),
+    'AS'     : YearBegin(month=1),
+    'AS-FEB' : YearBegin(month=2),
+    'AS-MAR' : YearBegin(month=3),
+    'AS-APR' : YearBegin(month=4),
+    'AS-MAY' : YearBegin(month=5),
+    'AS-JUN' : YearBegin(month=6),
+    'AS-JUL' : YearBegin(month=7),
+    'AS-AUG' : YearBegin(month=8),
+    'AS-SEP' : YearBegin(month=9),
+    'AS-OCT' : YearBegin(month=10),
+    'AS-NOV' : YearBegin(month=11),
+    'AS-DEC' : YearBegin(month=12),
+
+    # Annual - Business
+    'BA-JAN' : BYearEnd(month=1),
+    'BA-FEB' : BYearEnd(month=2),
+    'BA-MAR' : BYearEnd(month=3),
+    'BA-APR' : BYearEnd(month=4),
+    'BA-MAY' : BYearEnd(month=5),
+    'BA-JUN' : BYearEnd(month=6),
+    'BA-JUL' : BYearEnd(month=7),
+    'BA-AUG' : BYearEnd(month=8),
+    'BA-SEP' : BYearEnd(month=9),
+    'BA-OCT' : BYearEnd(month=10),
+    'BA-NOV' : BYearEnd(month=11),
+    'BA-DEC' : BYearEnd(month=12),
+    'BA'     : BYearEnd(month=12),
+
+    # Annual - Business (Start)
+    'BAS-JAN' : BYearBegin(month=1),
+    'BAS'     : BYearBegin(month=1),
+    'BAS-FEB' : BYearBegin(month=2),
+    'BAS-MAR' : BYearBegin(month=3),
+    'BAS-APR' : BYearBegin(month=4),
+    'BAS-MAY' : BYearBegin(month=5),
+    'BAS-JUN' : BYearBegin(month=6),
+    'BAS-JUL' : BYearBegin(month=7),
+    'BAS-AUG' : BYearBegin(month=8),
+    'BAS-SEP' : BYearBegin(month=9),
+    'BAS-OCT' : BYearBegin(month=10),
+    'BAS-NOV' : BYearBegin(month=11),
+    'BAS-DEC' : BYearBegin(month=12),
+
+    # Quarterly - Calendar
+    # 'Q'     : QuarterEnd(startingMonth=3),
+    'Q-JAN' : QuarterEnd(startingMonth=1),
+    'Q-FEB' : QuarterEnd(startingMonth=2),
+    'Q-MAR' : QuarterEnd(startingMonth=3),
+    'Q-APR' : QuarterEnd(startingMonth=4),
+    'Q-MAY' : QuarterEnd(startingMonth=5),
+    'Q-JUN' : QuarterEnd(startingMonth=6),
+    'Q-JUL' : QuarterEnd(startingMonth=7),
+    'Q-AUG' : QuarterEnd(startingMonth=8),
+    'Q-SEP' : QuarterEnd(startingMonth=9),
+    'Q-OCT' : QuarterEnd(startingMonth=10),
+    'Q-NOV' : QuarterEnd(startingMonth=11),
+    'Q-DEC' : QuarterEnd(startingMonth=12),
+
+    # Quarterly - Calendar (Start)
+    # 'QS'     : QuarterBegin(startingMonth=1),
+    'QS-JAN' : QuarterBegin(startingMonth=1),
+    'QS-FEB' : QuarterBegin(startingMonth=2),
+    'QS-MAR' : QuarterBegin(startingMonth=3),
+    'QS-APR' : QuarterBegin(startingMonth=4),
+    'QS-MAY' : QuarterBegin(startingMonth=5),
+    'QS-JUN' : QuarterBegin(startingMonth=6),
+    'QS-JUL' : QuarterBegin(startingMonth=7),
+    'QS-AUG' : QuarterBegin(startingMonth=8),
+    'QS-SEP' : QuarterBegin(startingMonth=9),
+    'QS-OCT' : QuarterBegin(startingMonth=10),
+    'QS-NOV' : QuarterBegin(startingMonth=11),
+    'QS-DEC' : QuarterBegin(startingMonth=12),
+
+    # Quarterly - Business
+    'BQ-JAN' : BQuarterEnd(startingMonth=1),
+    'BQ-FEB' : BQuarterEnd(startingMonth=2),
+    'BQ-MAR' : BQuarterEnd(startingMonth=3),
+
+    # 'BQ'     : BQuarterEnd(startingMonth=3),
+    'BQ-APR' : BQuarterEnd(startingMonth=4),
+    'BQ-MAY' : BQuarterEnd(startingMonth=5),
+    'BQ-JUN' : BQuarterEnd(startingMonth=6),
+    'BQ-JUL' : BQuarterEnd(startingMonth=7),
+    'BQ-AUG' : BQuarterEnd(startingMonth=8),
+    'BQ-SEP' : BQuarterEnd(startingMonth=9),
+    'BQ-OCT' : BQuarterEnd(startingMonth=10),
+    'BQ-NOV' : BQuarterEnd(startingMonth=11),
+    'BQ-DEC' : BQuarterEnd(startingMonth=12),
+
+    # Quarterly - Business (Start)
+    'BQS-JAN' : BQuarterBegin(startingMonth=1),
+    'BQS'     : BQuarterBegin(startingMonth=1),
+    'BQS-FEB' : BQuarterBegin(startingMonth=2),
+    'BQS-MAR' : BQuarterBegin(startingMonth=3),
+    'BQS-APR' : BQuarterBegin(startingMonth=4),
+    'BQS-MAY' : BQuarterBegin(startingMonth=5),
+    'BQS-JUN' : BQuarterBegin(startingMonth=6),
+    'BQS-JUL' : BQuarterBegin(startingMonth=7),
+    'BQS-AUG' : BQuarterBegin(startingMonth=8),
+    'BQS-SEP' : BQuarterBegin(startingMonth=9),
+    'BQS-OCT' : BQuarterBegin(startingMonth=10),
+    'BQS-NOV' : BQuarterBegin(startingMonth=11),
+    'BQS-DEC' : BQuarterBegin(startingMonth=12),
+
+    # Weekly
+    'W-MON' : offsets.Week(weekday=0),
+    'W-TUE' : offsets.Week(weekday=1),
+    'W-WED' : offsets.Week(weekday=2),
+    'W-THU' : offsets.Week(weekday=3),
+    'W-FRI' : offsets.Week(weekday=4),
+    'W-SAT' : offsets.Week(weekday=5),
+    'W-SUN' : offsets.Week(weekday=6),
+}
+
+_rule_aliases = {
+    # Legacy rules that will continue to map to their original values
+    # essentially for the rest of time
+
+    'WEEKDAY': 'B',
+    'EOM': 'BM',
+
+    'W@MON': 'W-MON',
+    'W@TUE': 'W-TUE',
+    'W@WED': 'W-WED',
+    'W@THU': 'W-THU',
+    'W@FRI': 'W-FRI',
+    'W@SAT': 'W-SAT',
+    'W@SUN': 'W-SUN',
+
+    'Q@JAN': 'BQ-JAN',
+    'Q@FEB': 'BQ-FEB',
+    'Q@MAR': 'BQ-MAR',
+
+    'A@JAN' : 'BA-JAN',
+    'A@FEB' : 'BA-FEB',
+    'A@MAR' : 'BA-MAR',
+    'A@APR' : 'BA-APR',
+    'A@MAY' : 'BA-MAY',
+    'A@JUN' : 'BA-JUN',
+    'A@JUL' : 'BA-JUL',
+    'A@AUG' : 'BA-AUG',
+    'A@SEP' : 'BA-SEP',
+    'A@OCT' : 'BA-OCT',
+    'A@NOV' : 'BA-NOV',
+    'A@DEC' : 'BA-DEC',
+
+    # lite aliases
+    'Min': 'T',
+    'min': 'T',
+    'ms': 'L',
+    'us': 'U'
+}
+
+for i, weekday in enumerate(['MON', 'TUE', 'WED', 'THU', 'FRI']):
+    for iweek in xrange(4):
+        name = 'WOM-%d%s' % (iweek + 1, weekday)
+        _offset_map[name] = offsets.WeekOfMonth(week=iweek, weekday=i)
+        _rule_aliases[name.replace('-', '@')] = name
+
+_legacy_reverse_map = dict((v, k) for k, v in _rule_aliases.iteritems())
+
+# for helping out with pretty-printing and name-lookups
+
+_offset_names = {}
+for name, offset in _offset_map.iteritems():
+    if offset is None:
+        continue
+    offset.name = name
+    _offset_names[offset] = name
+
+
+def inferTimeRule(index):
+    if len(index) < 3:
+        raise Exception('Need at least three dates to infer time rule!')
+
+    first, second, third = index[:3]
+    items = _offset_map.iteritems()
+
+    for rule, offset in items:
+        if offset is None:
+            continue
+        if (first + offset) == second and (second + offset) == third:
+            return rule
+
+    raise Exception('Could not infer time rule from data!')
+
+
+def to_offset(freqstr):
+    """
+    Return DateOffset object from string representation
+
+    Example
+    -------
+    to_offset('5Min') -> Minute(5)
+    """
+    if freqstr is None:
+        return None
+
+    if isinstance(freqstr, DateOffset):
+        return freqstr
+
+    if isinstance(freqstr, tuple):
+        name = freqstr[0]
+        stride = freqstr[1]
+        if isinstance(stride, basestring):
+            name, stride = stride, name
+        name, _ = _base_and_stride(name)
+    else:
+        name, stride = _base_and_stride(freqstr)
+
+    offset = get_offset(name)
+
+    return offset * stride
+
+
+opattern = re.compile(r'(\d*)\s*(\S+)')
+
+def _base_and_stride(freqstr):
+    """
+    Return base freq and stride info from string representation
+
+    Example
+    -------
+    _freq_and_stride('5Min') -> 'Min', 5
+    """
+    groups = opattern.match(freqstr)
+
+    if groups.lastindex != 2:
+        raise ValueError("Could not evaluate %s" % freqstr)
+
+    stride = groups.group(1)
+
+    if len(stride):
+        stride = int(stride)
+    else:
+        stride = 1
+
+    base = groups.group(2)
+
+    return (base, stride)
+
+
+_dont_uppercase = ['MS', 'ms']
+
+
+def get_offset(name):
+    """
+    Return DateOffset object associated with rule name
+
+    Example
+    -------
+    get_offset('EOM') --> BMonthEnd(1)
+    """
+    if name not in _dont_uppercase:
+        name = name.upper()
+
+        if name in _rule_aliases:
+            name = _rule_aliases[name]
+        elif name.lower() in _rule_aliases:
+            name = _rule_aliases[name.lower()]
+    else:
+        if name in _rule_aliases:
+            name = _rule_aliases[name]
+
+    offset = _offset_map.get(name)
+
+    if offset is not None:
+        return offset
+    else:
+        raise Exception('Bad rule name requested: %s!' % name)
+
+
+getOffset = get_offset
+
+
+def hasOffsetName(offset):
+    return offset in _offset_names
+
+def get_offset_name(offset):
+    """
+    Return rule name associated with a DateOffset object
+
+    Example
+    -------
+    get_offset_name(BMonthEnd(1)) --> 'EOM'
+    """
+    name = _offset_names.get(offset)
+
+    if name is not None:
+        return name
+    else:
+        raise Exception('Bad rule given: %s!' % offset)
+
+def get_legacy_offset_name(offset):
+    """
+    Return the pre pandas 0.8.0 name for the date offset
+    """
+    name = _offset_names.get(offset)
+    return _legacy_reverse_map.get(name, name)
+
+get_offset_name = get_offset_name
+
+def get_standard_freq(freq):
+    """
+    Return the standardized frequency string
+    """
+    if freq is None:
+        return None
+
+    if isinstance(freq, DateOffset):
+        return get_offset_name(freq)
+
+    code, stride = get_freq_code(freq)
+    return _get_freq_str(code, stride)
+
+#----------------------------------------------------------------------
+# Period codes
+
+# period frequency constants corresponding to scikits timeseries
+# originals
+_period_code_map = {
+    # Annual freqs with various fiscal year ends.
+    # eg, 2005 for A-FEB runs Mar 1, 2004 to Feb 28, 2005
+    "A"     : 1000,  # Annual
+    "A-DEC" : 1000,  # Annual - December year end
+    "A-JAN" : 1001,  # Annual - January year end
+    "A-FEB" : 1002,  # Annual - February year end
+    "A-MAR" : 1003,  # Annual - March year end
+    "A-APR" : 1004,  # Annual - April year end
+    "A-MAY" : 1005,  # Annual - May year end
+    "A-JUN" : 1006,  # Annual - June year end
+    "A-JUL" : 1007,  # Annual - July year end
+    "A-AUG" : 1008,  # Annual - August year end
+    "A-SEP" : 1009,  # Annual - September year end
+    "A-OCT" : 1010,  # Annual - October year end
+    "A-NOV" : 1011,  # Annual - November year end
+
+    # Quarterly frequencies with various fiscal year ends.
+    # eg, Q42005 for Q-OCT runs Aug 1, 2005 to Oct 31, 2005
+    "Q"     : 2000,    # Quarterly - December year end (default quarterly)
+    "Q-DEC" : 2000 ,    # Quarterly - December year end
+    "Q-JAN" : 2001,    # Quarterly - January year end
+    "Q-FEB" : 2002,    # Quarterly - February year end
+    "Q-MAR" : 2003,    # Quarterly - March year end
+    "Q-APR" : 2004,    # Quarterly - April year end
+    "Q-MAY" : 2005,    # Quarterly - May year end
+    "Q-JUN" : 2006,    # Quarterly - June year end
+    "Q-JUL" : 2007,    # Quarterly - July year end
+    "Q-AUG" : 2008,    # Quarterly - August year end
+    "Q-SEP" : 2009,    # Quarterly - September year end
+    "Q-OCT" : 2010,    # Quarterly - October year end
+    "Q-NOV" : 2011,    # Quarterly - November year end
+
+    "M"     : 3000,   # Monthly
+
+    "W"     : 4000,    # Weekly
+    "W-SUN" : 4000,    # Weekly - Sunday end of week
+    "W-MON" : 4001,    # Weekly - Monday end of week
+    "W-TUE" : 4002,    # Weekly - Tuesday end of week
+    "W-WED" : 4003,    # Weekly - Wednesday end of week
+    "W-THU" : 4004,    # Weekly - Thursday end of week
+    "W-FRI" : 4005,    # Weekly - Friday end of week
+    "W-SAT" : 4006,    # Weekly - Saturday end of week
+
+    "B"      : 5000,   # Business days
+    "D"      : 6000,   # Daily
+    "H"      : 7000,   # Hourly
+    "T"      : 8000,   # Minutely
+    "S"      : 9000,   # Secondly
+    None     : -10000  # Undefined
+}
+
+def _period_alias_dictionary():
+    """
+    Build freq alias dictionary to support freqs from original c_dates.c file
+    of the scikits.timeseries library.
+    """
+    alias_dict = {}
+
+    M_aliases = ["M", "MTH", "MONTH", "MONTHLY"]
+    B_aliases = ["B", "BUS", "BUSINESS", "BUSINESSLY", 'WEEKDAY']
+    D_aliases = ["D", "DAY", "DLY", "DAILY"]
+    H_aliases = ["H", "HR", "HOUR", "HRLY", "HOURLY"]
+    T_aliases = ["T", "MIN", "MINUTE", "MINUTELY"]
+    S_aliases = ["S", "SEC", "SECOND", "SECONDLY"]
+    U_aliases = ["U", "UND", "UNDEF", "UNDEFINED"]
+
+    for k in M_aliases:
+        alias_dict[k] = 'M'
+
+    for k in B_aliases:
+        alias_dict[k] = 'B'
+
+    for k in D_aliases:
+        alias_dict[k] = 'D'
+
+    for k in H_aliases:
+        alias_dict[k] = 'H'
+
+    for k in T_aliases:
+        alias_dict[k] = 'Min'
+
+    for k in S_aliases:
+        alias_dict[k] = 'S'
+
+    for k in U_aliases:
+        alias_dict[k] = None
+
+    A_prefixes = ["A", "Y", "ANN", "ANNUAL", "ANNUALLY", "YR", "YEAR",
+                  "YEARLY"]
+
+    Q_prefixes = ["Q", "QTR", "QUARTER", "QUARTERLY", "Q-E",
+                  "QTR-E", "QUARTER-E", "QUARTERLY-E"]
+
+    month_names = [
+        [ "DEC", "DECEMBER" ],
+        [ "JAN", "JANUARY" ],
+        [ "FEB", "FEBRUARY" ],
+        [ "MAR", "MARCH" ],
+        [ "APR", "APRIL" ],
+        [ "MAY", "MAY" ],
+        [ "JUN", "JUNE" ],
+        [ "JUL", "JULY" ],
+        [ "AUG", "AUGUST" ],
+        [ "SEP", "SEPTEMBER" ],
+        [ "OCT", "OCTOBER" ],
+        [ "NOV", "NOVEMBER" ] ]
+
+    seps = ["@", "-"]
+
+    for k in A_prefixes:
+        alias_dict[k] = 'A'
+        for m_tup in month_names:
+            for sep in seps:
+                m1, m2 = m_tup
+                alias_dict[k + sep + m1] = 'A-' + m1
+                alias_dict[k + sep + m2] = 'A-' + m1
+
+    for k in Q_prefixes:
+        alias_dict[k] = 'Q'
+        for m_tup in month_names:
+            for sep in seps:
+                m1, m2 = m_tup
+                alias_dict[k + sep + m1] = 'Q-' + m1
+                alias_dict[k + sep + m2] = 'Q-' + m1
+
+    W_prefixes = ["W", "WK", "WEEK", "WEEKLY"]
+
+    day_names = [
+        [ "SUN", "SUNDAY" ],
+        [ "MON", "MONDAY" ],
+        [ "TUE", "TUESDAY" ],
+        [ "WED", "WEDNESDAY" ],
+        [ "THU", "THURSDAY" ],
+        [ "FRI", "FRIDAY" ],
+        [ "SAT", "SATURDAY" ] ]
+
+    for k in W_prefixes:
+        alias_dict[k] = 'W'
+        for d_tup in day_names:
+            for sep in ["@", "-"]:
+                d1, d2 = d_tup
+                alias_dict[k + sep + d1] = 'W-' + d1
+                alias_dict[k + sep + d2] = 'W-' + d1
+
+    return alias_dict
+
+_reverse_period_code_map = {}
+for k, v in _period_code_map.iteritems():
+    _reverse_period_code_map[v] = k
+
+_reso_period_map = {
+    "year"    : "A",
+    "quarter" : "Q",
+    "month"   : "M",
+    "day"     : "D",
+    "hour"    : "H",
+    "minute"  : "T",
+    "second"  : "S",
+}
+
+def _infer_period_group(freqstr):
+    return _period_group(_reso_period_map[freqstr])
+
+def _period_group(freqstr):
+    base, mult = get_freq_code(freqstr)
+    return base // 1000 * 1000
+
+_period_alias_dict = _period_alias_dictionary()
+
+def _period_str_to_code(freqstr):
+    # hack
+    freqstr = _rule_aliases.get(freqstr, freqstr)
+    freqstr = _rule_aliases.get(freqstr.lower(), freqstr)
+
+    try:
+        freqstr = freqstr.upper()
+        return _period_code_map[freqstr]
+    except:
+        alias = _period_alias_dict[freqstr]
+        try:
+            return _period_code_map[alias]
+        except:
+            raise "Could not interpret frequency %s" % freqstr
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
new file mode 100644
index 000000000..251a78c22
--- /dev/null
+++ b/pandas/tseries/index.py
@@ -0,0 +1,1067 @@
+from datetime import time, datetime
+from datetime import timedelta
+
+import numpy as np
+
+from pandas.core.index import Index, Int64Index
+from pandas.tseries.tools import parse_time_string
+import pandas.core.common as com
+import pandas.core.datetools as datetools
+import pandas.tseries.tools as tools
+
+from pandas._engines import DatetimeEngine
+from pandas._tseries import Timestamp
+import pandas._tseries as lib
+
+# -------- some conversion wrapper functions
+
+def _as_i8(arg):
+    if isinstance(arg, np.ndarray) and arg.dtype == np.datetime64:
+        return arg.view('i8', type=np.ndarray)
+    else:
+        return arg
+
+def _wrap_i8_function(f):
+    @staticmethod
+    def wrapper(*args, **kwargs):
+        view_args = [_as_i8(arg) for arg in args]
+        return f(*view_args, **kwargs)
+    return wrapper
+
+def _wrap_dt_function(f):
+    @staticmethod
+    def wrapper(*args, **kwargs):
+        view_args = [_dt_box_array(_as_i8(arg)) for arg in args]
+        return f(*view_args, **kwargs)
+    return wrapper
+
+def _join_i8_wrapper(joinf, with_indexers=True):
+    @staticmethod
+    def wrapper(left, right):
+        if isinstance(left, np.ndarray):
+            left = left.view('i8', type=np.ndarray)
+        if isinstance(right, np.ndarray):
+            right = right.view('i8', type=np.ndarray)
+        results = joinf(left, right)
+        if with_indexers:
+            join_index, left_indexer, right_indexer = results
+            join_index = join_index.view('M8')
+            return join_index, left_indexer, right_indexer
+        return results
+    return wrapper
+
+def _dt_index_cmp(opname):
+    """
+    Wrap comparison operations to convert datetime-like to datetime64
+    """
+    def wrapper(self, other):
+        if isinstance(other, datetime):
+            func = getattr(self, opname)
+            result = func(_to_m8(other))
+        elif isinstance(other, np.ndarray):
+            func = getattr(super(DatetimeIndex, self), opname)
+            result = func(other)
+        else:
+            other = _ensure_datetime64(other)
+            func = getattr(super(DatetimeIndex, self), opname)
+            result = func(other)
+        try:
+            return result.view(np.ndarray)
+        except:
+            return result
+    return wrapper
+
+def _ensure_datetime64(other):
+    if isinstance(other, np.datetime64):
+        return other
+    elif com.is_integer(other):
+        return np.datetime64(other)
+    else:
+        raise TypeError(other)
+
+def _dt_index_op(opname):
+    """
+    Wrap arithmetic operations to convert timedelta to a timedelta64.
+    """
+    def wrapper(self, other):
+        if isinstance(other, timedelta):
+            func = getattr(self, opname)
+            return func(np.timedelta64(other))
+        else:
+            func = getattr(super(DatetimeIndex, self), opname)
+            return func(other)
+    return wrapper
+
+
+_midnight = time(0, 0)
+
+class DatetimeIndex(Int64Index):
+    """
+    Immutable ndarray of datetime64 data, represented internally as int64, and
+    which can be boxed to Timestamp objects that are subclasses of datetime and
+    carry metadata such as frequency information.
+
+    Parameters
+    ----------
+    data  : array-like (1-dimensional), optional
+        Optional datetime-like data to construct index with
+    dtype : NumPy dtype (default: M8[us])
+    copy  : bool
+        Make a copy of input ndarray
+    freq : string or pandas offset object, optional
+        One of pandas date offset strings or corresponding objects
+    start : starting value, datetime-like, optional
+        If data is None, start is used as the start point in generating regular
+        timestamp data.
+    periods  : int, optional, > 0
+        Number of periods to generate, if generating index. Takes precedence
+        over end argument
+    end   : end time, datetime-like, optional
+        If periods is none, generated index will extend to first conforming
+        time on or just past end argument
+    """
+
+    _inner_indexer = _join_i8_wrapper(lib.inner_join_indexer_int64)
+    _outer_indexer = _join_i8_wrapper(lib.outer_join_indexer_int64)
+    _left_indexer  = _join_i8_wrapper(lib.left_join_indexer_int64,
+                                      with_indexers=False)
+    _groupby = lib.groupby_arrays # _wrap_i8_function(lib.groupby_int64)
+
+    _arrmap = _wrap_dt_function(lib.arrmap_object)
+
+    __eq__ = _dt_index_cmp('__eq__')
+    __ne__ = _dt_index_cmp('__ne__')
+    __lt__ = _dt_index_cmp('__lt__')
+    __gt__ = _dt_index_cmp('__gt__')
+    __le__ = _dt_index_cmp('__le__')
+    __ge__ = _dt_index_cmp('__ge__')
+
+    __add__ = _dt_index_op('__add__')
+    __sub__ = _dt_index_op('__sub__')
+
+    # structured array cache for datetime fields
+    _sarr_cache = None
+
+    _engine_type = DatetimeEngine
+
+    offset = None
+
+    def __new__(cls, data=None,
+                freq=None, start=None, end=None, periods=None,
+                dtype=None, copy=False, name=None, tz=None,
+                verify_integrity=True, normalize=False, **kwds):
+
+        warn = False
+        if 'offset' in kwds and kwds['offset']:
+            freq = kwds['offset']
+            warn = True
+
+        if not isinstance(freq, datetools.DateOffset):
+            freq = datetools.to_offset(freq)
+
+        if warn:
+            import warnings
+            warnings.warn("parameter 'offset' is deprecated, "
+                          "please use 'freq' instead",
+                          FutureWarning)
+            if isinstance(freq, basestring):
+                freq = datetools.get_offset(freq)
+        else:
+            if isinstance(freq, basestring):
+                freq = datetools.to_offset(freq)
+
+        offset = freq
+
+        if data is None and offset is None:
+            raise ValueError("Must provide freq argument if no data is "
+                             "supplied")
+
+        if data is None:
+            _normalized = True
+
+            if start is not None:
+                start = Timestamp(start)
+                if not isinstance(start, Timestamp):
+                    raise ValueError('Failed to convert %s to timestamp'
+                                     % start)
+
+                if normalize:
+                    start = datetools.normalize_date(start)
+                    _normalized = True
+                else:
+                    _normalized = _normalized and start.time() == _midnight
+
+            if end is not None:
+                end = Timestamp(end)
+                if not isinstance(end, Timestamp):
+                    raise ValueError('Failed to convert %s to timestamp'
+                                     % end)
+
+                if normalize:
+                    end = datetools.normalize_date(end)
+                    _normalized = True
+                else:
+                    _normalized = _normalized and end.time() == _midnight
+
+            start, end, tz = tools._figure_out_timezone(start, end, tz)
+
+            if (offset._should_cache() and
+                not (offset._normalize_cache and not _normalized) and
+                datetools._naive_in_cache_range(start, end)):
+                index = cls._cached_range(start, end, periods=periods,
+                                          offset=offset, name=name)
+            else:
+                if isinstance(offset, datetools.Tick):
+                    if periods is None:
+                        b, e = Timestamp(start), Timestamp(end)
+                        data = np.arange(b.value, e.value+1,
+                                        offset.us_stride(), dtype=np.int64)
+                    else:
+                        b = Timestamp(start)
+                        e = b.value + periods * offset.us_stride()
+                        data = np.arange(b.value, e,
+                                         offset.us_stride(), dtype=np.int64)
+
+                else:
+                    xdr = datetools.generate_range(start=start, end=end,
+                        periods=periods, offset=offset)
+
+                    data = _to_m8_array(list(xdr))
+
+                index = np.array(data, dtype=np.datetime64, copy=False)
+
+            index = index.view(cls)
+            index.name = name
+            index.offset = offset
+            index.tz = tz
+
+            return index
+
+        if not isinstance(data, np.ndarray):
+            if np.isscalar(data):
+                raise ValueError('DatetimeIndex() must be called with a '
+                                 'collection of some kind, %s was passed'
+                                 % repr(data))
+
+            if isinstance(data, datetime):
+                data = [data]
+
+            # other iterable of some kind
+            if not isinstance(data, (list, tuple)):
+                data = list(data)
+
+            data = np.asarray(data, dtype='O')
+
+            # try a few ways to make it datetime64
+            if lib.is_string_array(data):
+                data = _str_to_dt_array(data)
+            else:
+                data = np.asarray(data, dtype='M8[us]')
+
+        if issubclass(data.dtype.type, basestring):
+            subarr = _str_to_dt_array(data)
+        elif issubclass(data.dtype.type, np.integer):
+            subarr = np.array(data, dtype='M8[us]', copy=copy)
+        elif issubclass(data.dtype.type, np.datetime64):
+            subarr = np.array(data, dtype='M8[us]', copy=copy)
+        else:
+            subarr = np.array(data, dtype='M8[us]', copy=copy)
+
+        # TODO: this is horribly inefficient. If user passes data + offset, we
+        # need to make sure data points conform. Punting on this
+
+        if verify_integrity:
+            if offset is not None:
+                for i, ts in enumerate(subarr):
+                    if not offset.onOffset(Timestamp(ts)):
+                        val = Timestamp(offset.rollforward(ts)).value
+                        subarr[i] = val
+
+        subarr = subarr.view(cls)
+        subarr.name = name
+        subarr.offset = offset
+        subarr.tz = tz
+
+        return subarr
+
+    @classmethod
+    def _simple_new(cls, values, name, offset, tz):
+        result = values.view(cls)
+        result.name = name
+        result.offset = offset
+        result.tz = tz
+
+        return result
+
+    @property
+    def tzinfo(self):
+        """
+        Alias for tz attribute
+        """
+        return self.tz
+
+    @classmethod
+    def _cached_range(cls, start=None, end=None, periods=None, offset=None,
+                      name=None):
+        if start is not None:
+            start = Timestamp(start)
+        if end is not None:
+            end = Timestamp(end)
+
+        if offset is None:
+            raise Exception('Must provide a DateOffset!')
+
+        drc = _daterange_cache
+        if offset not in _daterange_cache:
+            xdr = datetools.generate_range(offset=offset,
+                    start=_CACHE_START, end=_CACHE_END)
+
+            arr = np.array(_to_m8_array(list(xdr)),
+                           dtype='M8[us]', copy=False)
+
+            cachedRange = arr.view(DatetimeIndex)
+            cachedRange.offset = offset
+            cachedRange.tz = None
+            cachedRange.name = None
+            drc[offset] = cachedRange
+        else:
+            cachedRange = drc[offset]
+
+        if start is None:
+            if end is None:
+                raise Exception('Must provide start or end date!')
+            if periods is None:
+                raise Exception('Must provide number of periods!')
+
+            assert(isinstance(end, Timestamp))
+
+            end = offset.rollback(end)
+
+            endLoc = cachedRange.get_loc(end) + 1
+            startLoc = endLoc - periods
+        elif end is None:
+            assert(isinstance(start, Timestamp))
+            start = offset.rollforward(start)
+
+            startLoc = cachedRange.get_loc(start)
+            if periods is None:
+                raise Exception('Must provide number of periods!')
+
+            endLoc = startLoc + periods
+        else:
+            if not offset.onOffset(start):
+                start = offset.rollforward(start)
+
+            if not offset.onOffset(end):
+                end = offset.rollback(end)
+
+            startLoc = cachedRange.get_loc(start)
+            endLoc = cachedRange.get_loc(end) + 1
+
+        indexSlice = cachedRange[startLoc:endLoc]
+        indexSlice.name = name
+        indexSlice.offset = offset
+
+        return indexSlice
+
+    def _mpl_repr(self):
+        # how to represent ourselves to matplotlib
+        return self.values.astype('O')
+
+    def __repr__(self):
+        if self.offset is not None:
+            output = str(self.__class__) + '\n'
+            output += 'freq: %s, timezone: %s\n' % (self.offset, self.tz)
+            if len(self) > 0:
+                output += '[%s, ..., %s]\n' % (self[0], self[-1])
+            output += 'length: %d' % len(self)
+            return output
+        else:
+            return super(DatetimeIndex, self).__repr__()
+
+    __str__ = __repr__
+
+    def __reduce__(self):
+        """Necessary for making this object picklable"""
+        object_state = list(np.ndarray.__reduce__(self))
+        subclass_state = self.name, self.offset, self.tz
+        object_state[2] = (object_state[2], subclass_state)
+        return tuple(object_state)
+
+    def __setstate__(self, state):
+        """Necessary for making this object picklable"""
+        if len(state) == 2:
+            nd_state, own_state = state
+            self.name = own_state[0]
+            self.offset = own_state[1]
+            self.tz = own_state[2]
+            np.ndarray.__setstate__(self, nd_state)
+        elif len(state) == 3:
+            # legacy format: daterange
+            offset = state[1]
+
+            if len(state) > 2:
+                tzinfo = state[2]
+            else: # pragma: no cover
+                tzinfo = None
+
+            self.offset = offset
+            self.tzinfo = tzinfo
+
+            # extract the raw datetime data, turn into datetime64
+            index_state = state[0]
+            raw_data = index_state[0][4]
+            raw_data = np.array(raw_data, dtype='M8[us]')
+            new_state = raw_data.__reduce__()
+            np.ndarray.__setstate__(self, new_state[2])
+        else:  # pragma: no cover
+            np.ndarray.__setstate__(self, state)
+
+    def __add__(self, other):
+        if isinstance(other, Index):
+            return self.union(other)
+        elif isinstance(other, (datetools.DateOffset, timedelta)):
+            new_values = self.astype('O') + other
+            return DatetimeIndex(new_values, tz=self.tz)
+        else:
+            return Index(self.view(np.ndarray) + other)
+
+    @property
+    def asi8(self):
+        # do not cache or you'll create a memory leak
+        return self.values.view('i8')
+
+    @property
+    def asstruct(self):
+        if self._sarr_cache is None:
+            self._sarr_cache = lib.build_field_sarray(self.asi8)
+        return self._sarr_cache
+
+    @property
+    def asobject(self):
+        """
+        Convert to Index of datetime objects
+        """
+        boxed_values = _dt_box_array(self.asi8, self.offset, self.tz)
+        return Index(boxed_values, dtype=object)
+
+    def to_period(self, freq=None):
+        """
+        Cast to PeriodIndex at a particular frequency
+        """
+        from pandas.tseries.period import PeriodIndex
+
+        if self.freq is None and freq is None:
+            msg = "You must pass a freq argument as current index has none."
+            raise ValueError(msg)
+
+        if freq is None:
+            freq = self.freq
+
+        return PeriodIndex(self.values, freq=freq)
+
+    def snap(self, freq='S'):
+        """
+        Snap time stamps to nearest occuring frequency
+
+        """
+        # Superdumb, punting on any optimizing
+        freq = datetools.to_offset(freq)
+
+        snapped = np.empty(len(self), dtype='M8[us]')
+
+        for i, v in enumerate(self):
+            s = v
+            if not freq.onOffset(s):
+                t0 = freq.rollback(s)
+                t1 = freq.rollforward(s)
+                if abs(s - t0) < abs(t1 - s):
+                    s = t0
+                else:
+                    s = t1
+            snapped[i] = np.datetime64(s)
+
+        # we know it conforms; skip check
+        return DatetimeIndex(snapped, freq=freq, verify_integrity=False)
+
+    def shift(self, n, freq=None):
+        """
+        Specialized shift which produces a DatetimeIndex
+
+        Parameters
+        ----------
+        n : int
+            Periods to shift by
+        freq : DateOffset or timedelta-like, optional
+
+        Returns
+        -------
+        shifted : DatetimeIndex
+        """
+        if freq is not None and freq != self.offset:
+            if isinstance(freq, basestring):
+                freq = datetools.to_offset(freq)
+            return Index.shift(self, n, freq)
+
+        if n == 0:
+            # immutable so OK
+            return self
+
+        if self.offset is None:
+            raise ValueError("Cannot shift with no offset")
+
+        start = self[0] + n * self.offset
+        end = self[-1] + n * self.offset
+        return DatetimeIndex(start=start, end=end, freq=self.offset,
+                             name=self.name)
+
+    def union(self, other):
+        """
+        Specialized union for DatetimeIndex objects. If combine
+        overlapping ranges with the same DateOffset, will be much
+        faster than Index.union
+
+        Parameters
+        ----------
+        other : DatetimeIndex or array-like
+
+        Returns
+        -------
+        y : Index or DatetimeIndex
+        """
+        if self._can_fast_union(other):
+            return self._fast_union(other)
+        else:
+            return Index.union(self, other)
+
+    def join(self, other, how='left', level=None, return_indexers=False):
+        """
+        See Index.join
+        """
+        if not isinstance(other, DatetimeIndex) and len(other) > 0:
+            try:
+                other = DatetimeIndex(other)
+            except ValueError:
+                pass
+
+        return Index.join(self, other, how=how, level=level,
+                          return_indexers=return_indexers)
+
+
+    def _wrap_joined_index(self, joined, other):
+        name = self.name if self.name == other.name else None
+        if (isinstance(other, DatetimeIndex)
+            and self.offset == other.offset
+            and self._can_fast_union(other)):
+            joined = self._view_like(joined)
+            joined.name = name
+            return joined
+        else:
+            return DatetimeIndex(joined, name=name)
+
+    def _can_fast_union(self, other):
+        if not isinstance(other, DatetimeIndex):
+            return False
+
+        offset = self.offset
+
+        if offset is None:
+            return False
+
+        if len(other) == 0:
+            return True
+
+        # to make our life easier, "sort" the two ranges
+        if self[0] <= other[0]:
+            left, right = self, other
+        else:
+            left, right = other, self
+
+        left_end = left[-1]
+        right_start = right[0]
+
+        # Only need to "adjoin", not overlap
+        return (left_end + offset) >= right_start
+
+    def _fast_union(self, other):
+        if len(other) == 0:
+            return self.view(type(self))
+
+        # to make our life easier, "sort" the two ranges
+        if self[0] <= other[0]:
+            left, right = self, other
+        else:
+            left, right = other, self
+
+        left_start, left_end = left[0], left[-1]
+        right_end = right[-1]
+
+        if not self.offset._should_cache():
+            # concatenate dates
+            if left_end < right_end:
+                loc = right.searchsorted(left_end, side='right')
+                right_chunk = right.values[loc:]
+                dates = np.concatenate((left.values, right_chunk))
+                return self._view_like(dates)
+            else:
+                return left
+        else:
+            return type(self)(start=left_start,
+                              end=max(left_end, right_end),
+                              freq=left.offset)
+
+    def __array_finalize__(self, obj):
+        if self.ndim == 0: # pragma: no cover
+            return self.item()
+
+        self.offset = getattr(obj, 'offset', None)
+        self.tz = getattr(obj, 'tz', None)
+
+    def intersection(self, other):
+        """
+        Specialized intersection for DatetimeIndex objects. May be much faster
+        than Index.union
+
+        Parameters
+        ----------
+        other : DatetimeIndex or array-like
+
+        Returns
+        -------
+        y : Index or DatetimeIndex
+        """
+        if not isinstance(other, DatetimeIndex):
+            try:
+                other = DatetimeIndex(other)
+            except TypeError:
+                pass
+            return Index.intersection(self, other)
+        elif other.offset != self.offset:
+            return Index.intersection(self, other)
+
+        # to make our life easier, "sort" the two ranges
+        if self[0] <= other[0]:
+            left, right = self, other
+        else:
+            left, right = other, self
+
+        end = min(left[-1], right[-1])
+        start = right[0]
+
+        if end < start:
+            return type(self)(data=[])
+        else:
+            lslice = slice(*left.slice_locs(start, end))
+            left_chunk = left.values[lslice]
+            return self._view_like(left_chunk)
+
+    def _partial_date_slice(self, reso, parsed):
+        if reso == 'year':
+            t1 = Timestamp(datetime(parsed.year, 1, 1))
+            t2 = Timestamp(datetime(parsed.year, 12, 31))
+        elif reso == 'month':
+            d = lib.monthrange(parsed.year, parsed.month)[1]
+            t1 = Timestamp(datetime(parsed.year, parsed.month, 1))
+            t2 = Timestamp(datetime(parsed.year, parsed.month, d))
+        elif reso == 'quarter':
+            qe = (((parsed.month - 1) + 2) % 12) + 1 # two months ahead
+            d = lib.monthrange(parsed.year, qe)[1]   # at end of month
+            t1 = Timestamp(datetime(parsed.year, parsed.month, 1))
+            t2 = Timestamp(datetime(parsed.year, qe, d))
+        else:
+            raise KeyError
+
+        stamps = self.asi8
+        left = stamps.searchsorted(t1.value, side='left')
+        right = stamps.searchsorted(t2.value, side='right')
+        return slice(left, right)
+
+    def get_value(self, series, key):
+        """
+        Fast lookup of value from 1-dimensional ndarray. Only use this if you
+        know what you're doing
+        """
+        try:
+            return Index.get_value(self, series, key)
+        except KeyError:
+
+            try:
+                asdt, parsed, reso = datetools.parse_time_string(key)
+                key = asdt
+                loc = self._partial_date_slice(reso, parsed)
+                return series[loc]
+            except (TypeError, ValueError, KeyError):
+                pass
+
+            return self._engine.get_value(series, Timestamp(key))
+
+    def get_loc(self, key):
+        """
+        Get integer location for requested label
+
+        Returns
+        -------
+        loc : int
+        """
+        try:
+            return self._engine.get_loc(key)
+        except KeyError:
+            try:
+                return self._get_string_slice(key)
+            except (TypeError, KeyError):
+                pass
+
+            return self._engine.get_loc(Timestamp(key))
+
+    def _get_string_slice(self, key):
+        asdt, parsed, reso = datetools.parse_time_string(key)
+        key = asdt
+        loc = self._partial_date_slice(reso, parsed)
+        return loc
+
+    def slice_locs(self, start=None, end=None):
+        """
+        Index.slice_locs, customized to handle partial ISO-8601 string slicing
+        """
+        if isinstance(start, basestring) or isinstance(end, basestring):
+            try:
+                if start:
+                    start_loc = self._get_string_slice(start).start
+                else:
+                    start_loc = 0
+
+                if end:
+                    end_loc = self._get_string_slice(end).stop
+                else:
+                    end_loc = len(self)
+
+                return start_loc, end_loc
+            except KeyError:
+                pass
+
+        return Index.slice_locs(self, start, end)
+
+    def __getitem__(self, key):
+        """Override numpy.ndarray's __getitem__ method to work as desired"""
+        arr_idx = self.view(np.ndarray)
+        if np.isscalar(key):
+            val = arr_idx[key]
+            return Timestamp(val, offset=self.offset, tz=self.tz)
+        else:
+            if com._is_bool_indexer(key):
+                key = np.asarray(key)
+                key = lib.maybe_booleans_to_slice(key)
+
+            new_offset = None
+            if isinstance(key, slice):
+                if self.offset is not None and key.step is not None:
+                    new_offset = key.step * self.offset
+                else:
+                    new_offset = self.offset
+
+            result = arr_idx[key]
+            if result.ndim > 1:
+                return result
+
+            return self._simple_new(result, self.name, new_offset, self.tz)
+
+    # Try to run function on index first, and then on elements of index
+    # Especially important for group-by functionality
+    def map(self, f):
+        try:
+            return f(self)
+        except:
+            return Index.map(self, f)
+
+    # alias to offset
+    @property
+    def freq(self):
+        return self.offset
+
+    # Fast field accessors for periods of datetime index
+    # --------------------------------------------------------------
+
+    @property
+    def year(self):
+        return lib.fast_field_accessor(self.asi8, 'Y')
+
+    @property
+    def month(self):
+        return lib.fast_field_accessor(self.asi8, 'M')
+
+    @property
+    def day(self):
+        return lib.fast_field_accessor(self.asi8, 'D')
+
+    @property
+    def hour(self):
+        return lib.fast_field_accessor(self.asi8, 'h')
+
+    @property
+    def minute(self):
+        return lib.fast_field_accessor(self.asi8, 'm')
+
+    @property
+    def second(self):
+        return lib.fast_field_accessor(self.asi8, 's')
+
+    @property
+    def microsecond(self):
+        return lib.fast_field_accessor(self.asi8, 'us')
+
+    @property
+    def weekofyear(self):
+        return lib.fast_field_accessor(self.asi8, 'woy')
+
+    @property
+    def dayofweek(self):
+        return lib.fast_field_accessor(self.asi8, 'dow')
+
+    @property
+    def dayofyear(self):
+        return lib.fast_field_accessor(self.asi8, 'doy')
+
+    @property
+    def quarter(self):
+        return lib.fast_field_accessor(self.asi8, 'q')
+
+    def __iter__(self):
+        return iter(self.asobject)
+
+    def searchsorted(self, key, side='left'):
+        if isinstance(key, np.ndarray):
+            key = np.array(key, dtype='M8[us]', copy=False)
+        else:
+            key = _to_m8(key)
+
+        return self.values.searchsorted(key, side=side)
+
+    def is_type_compatible(self, typ):
+        return typ == self.inferred_type or typ == 'datetime'
+
+    # hack to workaround argmin failure
+    def argmin(self):
+        return (-self).argmax()
+
+    @property
+    def inferred_type(self):
+        # b/c datetime is represented as microseconds since the epoch, make
+        # sure we can't have ambiguous indexing
+        return 'datetime64'
+
+    @property
+    def _constructor(self):
+        return DatetimeIndex
+
+    @property
+    def dtype(self):
+        return np.dtype('M8')
+
+    @property
+    def is_all_dates(self):
+        return True
+
+    def equals(self, other):
+        """
+        Determines if two Index objects contain the same elements.
+        """
+        if self is other:
+            return True
+
+        if (not hasattr(other, 'inferred_type') or
+            other.inferred_type != 'datetime64'):
+            if self.offset is not None:
+                return False
+            try:
+                other = DatetimeIndex(other)
+            except:
+                return False
+
+        return np.array_equal(self.asi8, other.asi8)
+
+    def insert(self, loc, item):
+        """
+        Make new Index inserting new item at location
+
+        Parameters
+        ----------
+        loc : int
+        item : object
+
+        Returns
+        -------
+        new_index : Index
+        """
+        if type(item) == datetime:
+            item = _to_m8(item)
+
+        if self.offset is not None and not self.offset.onOffset(item):
+            raise ValueError("Cannot insert value at non-conforming time")
+
+        return super(DatetimeIndex, self).insert(loc, item)
+
+    def _view_like(self, ndarray):
+        result = ndarray.view(type(self))
+        result.offset = self.offset
+        result.tz = self.tz
+        result.name = self.name
+        return result
+
+    def tz_normalize(self, tz):
+        """
+        Convert DatetimeIndex from one time zone to another (using pytz)
+
+        Returns
+        -------
+        normalized : DatetimeIndex
+        """
+        new_dates = lib.tz_normalize_array(self.asi8, self.tz, tz)
+        new_dates = new_dates.view('M8[us]')
+        new_dates = new_dates.view(self.__class__)
+        new_dates.offset = self.offset
+        new_dates.tz = tz
+        new_dates.name = self.name
+        return new_dates
+
+    def tz_localize(self, tz):
+        """
+        Localize tz-naive DatetimeIndex to given time zone (using pytz)
+
+        Returns
+        -------
+        localized : DatetimeIndex
+        """
+        if self.tz is not None:
+            raise ValueError("Already have timezone info, "
+                             "use tz_normalize to convert.")
+
+        new_dates = lib.tz_localize_array(self.asi8, tz)
+        new_dates = new_dates.view('M8[us]')
+        new_dates = new_dates.view(self.__class__)
+        new_dates.offset = self.offset
+        new_dates.tz = tz
+        new_dates.name = self.name
+        return new_dates
+
+    def tz_validate(self):
+        """
+        For a localized time zone, verify that there are no DST ambiguities
+        (using pytz)
+
+        Returns
+        -------
+        result : boolean
+            True if there are no DST ambiguities
+        """
+        import pytz
+
+        if self.tz is None or self.tz is pytz.utc:
+            return True
+
+        # See if there are any DST resolution problems
+        try:
+            lib.tz_localize_array(self.asi8, self.tz)
+        except:
+            return False
+
+        return True
+
+
+def date_range(start=None, end=None, periods=None, freq='D', tz=None,
+               normalize=False):
+    """
+    Return a fixed frequency datetime index, with day (calendar) as the default
+    frequency
+
+
+    Parameters
+    ----------
+    start :
+    end :
+    normalize : bool, default False
+        Normalize start/end dates to midnight before generating date range
+
+    Returns
+    -------
+
+    """
+    return DatetimeIndex(start=start, end=end, periods=periods,
+                         freq=freq, tz=tz, normalize=normalize)
+
+
+def bdate_range(start=None, end=None, periods=None, freq='B', tz=None,
+                normalize=True):
+    """
+    Return a fixed frequency datetime index, with business day as the default
+    frequency
+
+    Parameters
+    ----------
+
+    normalize : bool, default False
+        Normalize start/end dates to midnight before generating date
+        range. Defaults to True for legacy reasons
+
+    Returns
+    -------
+    date_range : DatetimeIndex
+
+    """
+
+    return DatetimeIndex(start=start, end=end, periods=periods,
+                         freq=freq, tz=tz, normalize=normalize)
+
+
+def _dt_box_array(arr, offset=None, tz=None):
+    if arr is None:
+        return arr
+
+    if not isinstance(arr, np.ndarray):
+        return arr
+
+    boxfunc = lambda x: Timestamp(x, offset=offset, tz=tz)
+    boxer = np.frompyfunc(boxfunc, 1, 1)
+    return boxer(arr)
+
+
+def _to_m8(key):
+    '''
+    Timestamp-like => dt64
+    '''
+    if not isinstance(key, datetime):
+        # this also converts strings
+        key = Timestamp(key)
+
+    return np.datetime64(lib.pydt_to_i8(key))
+
+
+def _to_m8_array(arr):
+    if arr is None:
+        return arr
+    return np.frompyfunc(_to_m8, 1, 1)(arr)
+
+
+def _str_to_dt_array(arr):
+    def parser(x):
+        result = parse_time_string(x)
+        return result[0]
+
+    p_ufunc = np.frompyfunc(parser, 1, 1)
+    data = p_ufunc(arr)
+    return np.array(data, dtype='M8[us]')
+
+
+_CACHE_START = Timestamp(datetime(1950, 1, 1))
+_CACHE_END   = Timestamp(datetime(2030, 1, 1))
+
+_daterange_cache = {}
+
+
+def _naive_in_cache_range(start, end):
+    if start is None or end is None:
+        return False
+    else:
+        return _in_range(start, end, _CACHE_START, _CACHE_END)
+
+def _in_range(start, end, rng_start, rng_end):
+    return start > rng_start and end < rng_end
diff --git a/pandas/tseries/interval.py b/pandas/tseries/interval.py
new file mode 100644
index 000000000..58c16dcf0
--- /dev/null
+++ b/pandas/tseries/interval.py
@@ -0,0 +1,35 @@
+import numpy as np
+
+from pandas.core.index import Index
+
+class Interval(object):
+    """
+    Represents an interval of time defined by two timestamps
+    """
+
+    def __init__(self, start, end):
+        self.start = start
+        self.end = end
+
+class PeriodInterval(object):
+    """
+    Represents an interval of time defined by two Period objects (time ordinals)
+    """
+
+    def __init__(self, start, end):
+        self.start = start
+        self.end = end
+
+
+class IntervalIndex(Index):
+    """
+
+    """
+    def __new__(self, starts, ends):
+        pass
+
+    def dtype(self):
+        return self.values.dtype
+
+if __name__ == '__main__':
+    pass
diff --git a/pandas/tseries/offsets.py b/pandas/tseries/offsets.py
new file mode 100644
index 000000000..9a4859dad
--- /dev/null
+++ b/pandas/tseries/offsets.py
@@ -0,0 +1,1024 @@
+from datetime import datetime, timedelta
+
+import numpy as np
+
+from pandas.tseries.tools import to_datetime
+
+# import after tools, dateutil check
+from dateutil.relativedelta import relativedelta
+
+from pandas._tseries import Timestamp
+import pandas._tseries as lib
+
+#-------------------------------------------------------------------------------
+# DateOffset
+
+
+class CacheableOffset(object):
+
+    _cacheable = True
+
+
+class DateOffset(object):
+    """
+    Standard kind of date increment used for a date range.
+
+    Works exactly like relativedelta in terms of the keyword args you
+    pass in, use of the keyword n is discouraged-- you would be better
+    off specifying n in the keywords you use, but regardless it is
+    there for you. n is needed for DateOffset subclasses.
+
+    DateOffets work as follows.  Each offset specify a set of dates
+    that conform to the DateOffset.  For example, Bday defines this
+    set to be the set of dates that are weekdays (M-F).  To test if a
+    date is in the set of a DateOffset dateOffset we can use the
+    onOffset method: dateOffset.onOffset(date).
+
+    If a date is not on a valid date, the rollback and rollforward
+    methods can be used to roll the date to the nearest valid date
+    before/after the date.
+
+    DateOffsets can be created to move dates forward a given number of
+    valid dates.  For example, Bday(2) can be added to a date to move
+    it two business days forward.  If the date does not start on a
+    valid date, first it is moved to a valid date.  Thus psedo code
+    is:
+
+    def __add__(date):
+      date = rollback(date) # does nothing is date is valid
+      return date + <n number of periods>
+
+    When a date offset is created for a negitive number of periods,
+    the date is first rolled forward.  The pseudo code is:
+
+    def __add__(date):
+      date = rollforward(date) # does nothing is date is valid
+      return date + <n number of periods>
+
+    Zero presents a problem.  Should it roll forward or back?  We
+    arbitrarily have it rollforward:
+
+    date + BDay(0) == BDay.rollforward(date)
+
+    Since 0 is a bit weird, we suggest avoiding its use.
+    """
+    _cacheable = False
+    _normalize_cache = True
+
+    def __init__(self, n=1, **kwds):
+        self.n = int(n)
+        self.kwds = kwds
+        if len(kwds) > 0:
+            self._offset = relativedelta(**kwds)
+        else:
+            self._offset = timedelta(1)
+
+    def apply(self, other):
+        if len(self.kwds) > 0:
+            if self.n > 0:
+                for i in xrange(self.n):
+                    other = other + self._offset
+            else:
+                for i in xrange(-self.n):
+                    other = other - self._offset
+            return other
+        else:
+            return other + timedelta(self.n)
+
+    def isAnchored(self):
+        return (self.n == 1)
+
+    def copy(self):
+        return self.__class__(self.n, **self.kwds)
+
+    def _should_cache(self):
+        return self.isAnchored() and self._cacheable
+
+    def _params(self):
+        attrs = [(k, v) for k, v in vars(self).iteritems()
+                 if k not in ['kwds', '_offset', 'name']]
+        attrs.extend(self.kwds.items())
+        attrs = sorted(set(attrs))
+
+        params = tuple([str(self.__class__)] + attrs)
+        return params
+
+    def __repr__(self):
+        if hasattr(self, 'name') and len(self.name):
+            return self.name
+
+        className = getattr(self, '_outputName', type(self).__name__)
+        exclude = set(['n', 'inc'])
+        attrs = []
+        for attr in self.__dict__:
+            if ((attr == 'kwds' and len(self.kwds) == 0)
+                or attr.startswith('_')):
+                continue
+            if attr not in exclude:
+                attrs.append('='.join((attr, repr(getattr(self, attr)))))
+
+        if abs(self.n) != 1:
+            plural = 's'
+        else:
+            plural = ''
+
+        out = '<%s ' % self.n + className + plural
+        if attrs:
+            out += ': ' + ', '.join(attrs)
+        out += '>'
+        return out
+
+    def __eq__(self, other):
+        if other is None:
+            return False
+
+        if isinstance(other, basestring):
+            from pandas.tseries.frequencies import to_offset
+            other = to_offset(other)
+
+        if not isinstance(other, DateOffset):
+            return False
+
+        return self._params() == other._params()
+
+    def __ne__(self, other):
+        return not self == other
+
+    def __hash__(self):
+        return hash(self._params())
+
+    def __call__(self, other):
+        return self.apply(other)
+
+    def __add__(self, other):
+        return self.apply(other)
+
+    def __radd__(self, other):
+        return self.__add__(other)
+
+    def __sub__(self, other):
+        if isinstance(other, datetime):
+            raise TypeError('Cannot subtract datetime from offset!')
+        elif type(other) == type(self):
+            return self.__class__(self.n - other.n, **self.kwds)
+        else: # pragma: no cover
+            raise TypeError('Cannot subtract %s from %s'
+                            % (type(other), type(self)))
+
+    def __rsub__(self, other):
+        return self.__class__(-self.n, **self.kwds) + other
+
+    def __mul__(self, someInt):
+        return self.__class__(n=someInt * self.n, **self.kwds)
+
+    def __rmul__(self, someInt):
+        return self.__mul__(someInt)
+
+    def __neg__(self):
+        return self.__class__(-self.n, **self.kwds)
+
+    def rollback(self, someDate):
+        """Roll provided date backward to next offset only if not on offset"""
+        if not self.onOffset(someDate):
+            someDate = someDate - self.__class__(1, **self.kwds)
+        return someDate
+
+    def rollforward(self, dt):
+        """Roll provided date forward to next offset only if not on offset"""
+        if isinstance(dt, np.datetime64):
+            dt = Timestamp(dt)
+        if not self.onOffset(dt):
+            dt = dt + self.__class__(1, **self.kwds)
+        return dt
+
+    def onOffset(self, dt):
+        if type(self) == DateOffset:
+            return True
+
+        # Default (slow) method for determining if some date is a member of the
+        # date range generated by this offset. Subclasses may have this
+        # re-implemented in a nicer way.
+        a = dt
+        b = ((dt + self) - self)
+        return a == b
+
+
+class Day(DateOffset, CacheableOffset):
+
+    def rule_code(self):
+        return 'D'
+
+
+class BusinessDay(DateOffset, CacheableOffset):
+    """
+    DateOffset subclass representing possibly n business days
+    """
+    def __init__(self, n=1, **kwds):
+        self.n = int(n)
+        self.kwds = kwds
+        self.offset = kwds.get('offset', timedelta(0))
+        self.normalize = kwds.get('normalize', False)
+
+    def rule_code(self):
+        return 'B'
+
+    def __repr__(self):
+        if hasattr(self, 'name') and len(self.name):
+            return self.name
+
+        className = getattr(self, '_outputName', self.__class__.__name__)
+        attrs = []
+
+        if self.offset:
+            attrs = ['offset=%s' % repr(self.offset)]
+
+        if abs(self.n) != 1:
+            plural = 's'
+        else:
+            plural = ''
+
+        out = '<%s ' % self.n + className + plural
+        if attrs:
+            out += ': ' + ', '.join(attrs)
+        out += '>'
+        return out
+
+    def isAnchored(self):
+        return (self.n == 1)
+
+    def apply(self, other):
+        if isinstance(other, datetime):
+            n = self.n
+
+            if n == 0 and other.weekday() > 4:
+                n = 1
+
+            result = other
+
+            while n != 0:
+                k = n // abs(n)
+                result = result + timedelta(k)
+                if result.weekday() < 5:
+                    n -= k
+
+            if self.normalize:
+                result = datetime(result.year, result.month, result.day)
+
+            if self.offset:
+                result = result + self.offset
+
+            return result
+
+        elif isinstance(other, (timedelta, Tick)):
+            return BDay(self.n, offset=self.offset + other,
+                        normalize=self.normalize)
+        else:
+            raise Exception('Only know how to combine business day with '
+                            'datetime or timedelta!')
+    @classmethod
+    def onOffset(cls, dt):
+        if isinstance(dt, np.datetime64):
+             dt = Timestamp(dt)
+        return dt.weekday() < 5
+
+
+class MonthEnd(DateOffset, CacheableOffset):
+    """DateOffset of one month end"""
+
+    def apply(self, other):
+        n = self.n
+        _, days_in_month = lib.monthrange(other.year, other.month)
+        if other.day != days_in_month:
+            other = other + relativedelta(months=-1, day=31)
+            if n <= 0:
+                n = n + 1
+        other = other + relativedelta(months=n, day=31)
+        return other
+
+    @classmethod
+    def onOffset(cls, dt):
+        __junk, days_in_month = lib.monthrange(dt.year, dt.month)
+        return dt.day == days_in_month
+
+    def rule_code(self):
+        return 'M'
+
+
+class MonthBegin(DateOffset, CacheableOffset):
+    """DateOffset of one month at beginning"""
+
+    def apply(self, other):
+        n = self.n
+
+        if other.day > 1 and n <= 0: #then roll forward if n<=0
+            n += 1
+
+        other = other + relativedelta(months=n, day=1)
+        return other
+
+    @classmethod
+    def onOffset(cls, dt):
+        firstDay, _ = lib.monthrange(dt.year, dt.month)
+        return dt.day == (firstDay + 1)
+
+    def rule_code(self):
+        return 'MS'
+
+
+class BusinessMonthEnd(DateOffset, CacheableOffset):
+    """DateOffset increments between business EOM dates"""
+
+    def isAnchored(self):
+        return (self.n == 1)
+
+    def apply(self, other):
+        n = self.n
+
+        wkday, days_in_month = lib.monthrange(other.year, other.month)
+        lastBDay = days_in_month - max(((wkday + days_in_month - 1) % 7) - 4, 0)
+
+        if n > 0 and not other.day >= lastBDay:
+            n = n - 1
+        elif n <= 0 and other.day > lastBDay:
+            n = n + 1
+        other = other + relativedelta(months=n, day=31)
+
+        if other.weekday() > 4:
+            other = other - BDay()
+        return other
+
+    def rule_code(self):
+        return 'BM'
+
+
+class BusinessMonthBegin(DateOffset, CacheableOffset):
+    """DateOffset of one business month at beginning"""
+
+    def apply(self, other):
+        n = self.n
+
+        wkday, _ = lib.monthrange(other.year, other.month)
+        first = _get_firstbday(wkday)
+
+        if other.day > first and n<=0:
+            # as if rolled forward already
+            n += 1
+
+        other = other + relativedelta(months=n)
+        wkday, _ = lib.monthrange(other.year, other.month)
+        first = _get_firstbday(wkday)
+        result = datetime(other.year, other.month, first)
+        return result
+
+    def rule_code(self):
+        return 'BMS'
+
+
+class Week(DateOffset, CacheableOffset):
+    """
+    Weekly offset
+
+    Parameters
+    ----------
+    weekday : int, default None
+        Always generate specific day of week. 0 for Monday
+    """
+    def __init__(self, n=1, **kwds):
+        self.n = n
+        self.weekday = kwds.get('weekday', None)
+
+        if self.weekday is not None:
+            if self.weekday < 0 or self.weekday > 6:
+                raise Exception('Day must be 0<=day<=6, got %d' %
+                                self.weekday)
+
+        self.inc = timedelta(weeks=1)
+        self.kwds = kwds
+
+    def isAnchored(self):
+        return (self.n == 1 and self.weekday is not None)
+
+    def apply(self, other):
+        if self.weekday is None:
+            return other + self.n * self.inc
+
+        if self.n > 0:
+            k = self.n
+            otherDay = other.weekday()
+            if otherDay != self.weekday:
+                other = other + timedelta((self.weekday - otherDay) % 7)
+                k = k - 1
+            for i in xrange(k):
+                other = other + self.inc
+        else:
+            k = self.n
+            otherDay = other.weekday()
+            if otherDay != self.weekday:
+                other = other + timedelta((self.weekday - otherDay) % 7)
+            for i in xrange(-k):
+                other = other - self.inc
+        return other
+
+    def onOffset(self, dt):
+        return dt.weekday() == self.weekday
+
+    def rule_code(self):
+        suffix = ''
+        if self.weekday is not None:
+            suffix = '-%s' % (_weekday_dict[self.weekday])
+        return 'W' + suffix
+
+_weekday_dict = {
+    0: 'MON',
+    1: 'TUE',
+    2: 'WED',
+    3: 'THU',
+    4: 'FRI',
+    5: 'SAT',
+    6: 'SUN'
+}
+
+class WeekOfMonth(DateOffset, CacheableOffset):
+    """
+    Describes monthly dates like "the Tuesday of the 2nd week of each month"
+
+    Parameters
+    ----------
+    n : int
+    week : {0, 1, 2, 3, ...}
+        0 is 1st week of month, 1 2nd week, etc.
+    weekday : {0, 1, ..., 6}
+        0: Mondays
+        1: Tuedays
+        2: Wednesdays
+        3: Thursdays
+        4: Fridays
+        5: Saturdays
+        6: Sundays
+    """
+    def __init__(self, n=1, **kwds):
+        self.n = n
+        self.weekday = kwds['weekday']
+        self.week = kwds['week']
+
+        if self.n == 0:
+            raise Exception('N cannot be 0')
+
+        if self.weekday < 0 or self.weekday > 6:
+            raise Exception('Day must be 0<=day<=6, got %d' %
+                            self.weekday)
+        if self.week < 0 or self.week > 3:
+            raise Exception('Week must be 0<=day<=3, got %d' %
+                            self.week)
+
+        self.kwds = kwds
+
+    def apply(self, other):
+        offsetOfMonth = self.getOffsetOfMonth(other)
+
+        if offsetOfMonth > other:
+            if self.n > 0:
+                months = self.n - 1
+            else:
+                months = self.n
+        elif offsetOfMonth == other:
+            months = self.n
+        else:
+            if self.n > 0:
+                months = self.n
+            else:
+                months = self.n + 1
+
+        return self.getOffsetOfMonth(other + relativedelta(months=months, day=1))
+
+    def getOffsetOfMonth(self, dt):
+        w = Week(weekday=self.weekday)
+        d = datetime(dt.year, dt.month, 1)
+
+        d = w.rollforward(d)
+
+        for i in xrange(self.week):
+            d = w.apply(d)
+
+        return d
+
+    def onOffset(self, dt):
+        return dt == self.getOffsetOfMonth(dt)
+
+    def rule_code(self):
+        suffix = '-%d%s' % (self.week + 1, _weekday_dict.get(self.weekday, ''))
+        return 'WOM' + suffix
+
+
+class BQuarterEnd(DateOffset, CacheableOffset):
+    """DateOffset increments between business Quarter dates
+    startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...
+    startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...
+    startingMonth = 3 corresponds to dates like 3/30/2007, 6/29/2007, ...
+    """
+    _outputName = 'BusinessQuarterEnd'
+
+    def __init__(self, n=1, **kwds):
+        self.n = n
+        self.startingMonth = kwds.get('startingMonth', 3)
+
+        self.offset = BMonthEnd(3)
+        self.kwds = kwds
+
+    def isAnchored(self):
+        return (self.n == 1 and self.startingMonth is not None)
+
+    def apply(self, other):
+        n = self.n
+
+        wkday, days_in_month = lib.monthrange(other.year, other.month)
+        lastBDay = days_in_month - max(((wkday + days_in_month - 1) % 7) - 4, 0)
+
+        monthsToGo = 3 - ((other.month - self.startingMonth) % 3)
+        if monthsToGo == 3:
+            monthsToGo = 0
+
+        if n > 0 and not (other.day >= lastBDay and monthsToGo == 0):
+            n = n - 1
+        elif n <= 0 and other.day > lastBDay and monthsToGo == 0:
+            n = n + 1
+
+        other = other + relativedelta(months=monthsToGo + 3*n, day=31)
+
+        if other.weekday() > 4:
+            other = other - BDay()
+
+        return other
+
+    def onOffset(self, dt):
+        modMonth = (dt.month - self.startingMonth) % 3
+        return BMonthEnd().onOffset(dt) and modMonth == 0
+
+    def rule_code(self):
+        suffix = '-%s' % _month_dict[self.startingMonth]
+        return 'BQ' + suffix
+
+
+_month_dict = {
+    1: 'JAN',
+    2: 'FEB',
+    3: 'MAR',
+    4: 'APR',
+    5: 'MAY',
+    6: 'JUN',
+    7: 'JUL',
+    8: 'AUG',
+    9: 'SEP',
+    10: 'OCT',
+    11: 'NOV',
+    12: 'DEC'
+}
+
+
+class BQuarterBegin(DateOffset, CacheableOffset):
+    _outputName = "BusinessQuarterBegin"
+
+    def __init__(self, n=1, **kwds):
+        self.n = n
+        self.startingMonth = kwds.get('startingMonth', 3)
+
+        self.offset = BMonthBegin(3)
+        self.kwds = kwds
+
+    def isAnchored(self):
+        return (self.n == 1 and self.startingMonth is not None)
+
+    def apply(self, other):
+        n = self.n
+
+        wkday, _ = lib.monthrange(other.year, other.month)
+
+        first = _get_firstbday(wkday)
+
+        monthsSince = (other.month - self.startingMonth) % 3
+        if monthsSince == 3: # on offset
+            monthsSince = 0
+
+        if n <= 0 and monthsSince != 0: # make sure to roll forward so negate
+            monthsSince = monthsSince - 3
+
+        # roll forward if on same month later than first bday
+        if n <= 0 and (monthsSince == 0 and other.day > first):
+            n = n + 1
+        # pretend to roll back if on same month but before firstbday
+        elif n > 0 and (monthsSince == 0 and other.day < first):
+            n = n - 1
+
+        # get the first bday for result
+        other = other + relativedelta(months=3*n - monthsSince)
+        wkday, _ = lib.monthrange(other.year, other.month)
+        first = _get_firstbday(wkday)
+        result = datetime(other.year, other.month, first)
+        return result
+
+    def rule_code(self):
+        suffix = '-%s' % _month_dict[self.startingMonth]
+        return 'BQS' + suffix
+
+
+class QuarterEnd(DateOffset, CacheableOffset):
+    """DateOffset increments between business Quarter dates
+    startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ...
+    startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ...
+    startingMonth = 3 corresponds to dates like 3/31/2007, 6/30/2007, ...
+    """
+    _outputName = 'QuarterEnd'
+
+    def __init__(self, n=1, **kwds):
+        self.n = n
+        self.startingMonth = kwds.get('startingMonth', 3)
+
+        self.offset = MonthEnd(3)
+        self.kwds = kwds
+
+    def isAnchored(self):
+        return (self.n == 1 and self.startingMonth is not None)
+
+    def apply(self, other):
+        n = self.n
+
+        wkday, days_in_month = lib.monthrange(other.year, other.month)
+
+        monthsToGo = 3 - ((other.month - self.startingMonth) % 3)
+        if monthsToGo == 3:
+            monthsToGo = 0
+
+        if n > 0 and not (other.day >= days_in_month and monthsToGo == 0):
+            n = n - 1
+
+        other = other + relativedelta(months=monthsToGo + 3*n, day=31)
+
+        return other
+
+    def onOffset(self, dt):
+        modMonth = (dt.month - self.startingMonth) % 3
+        return MonthEnd().onOffset(dt) and modMonth == 0
+
+    def rule_code(self):
+        suffix = '-%s' % _month_dict[self.startingMonth]
+        return 'Q' + suffix
+
+
+class QuarterBegin(DateOffset, CacheableOffset):
+    _outputName = 'QuarterBegin'
+
+    def __init__(self, n=1, **kwds):
+        self.n = n
+        self.startingMonth = kwds.get('startingMonth', 3)
+
+        self.offset = MonthBegin(3)
+        self.kwds = kwds
+
+    def isAnchored(self):
+        return (self.n == 1 and self.startingMonth is not None)
+
+    def apply(self, other):
+        n = self.n
+
+        wkday, days_in_month = lib.monthrange(other.year, other.month)
+
+        monthsSince = (other.month - self.startingMonth) % 3
+
+        if monthsSince == 3: # on an offset
+            monthsSince = 0
+
+        if n <= 0 and monthsSince != 0:
+            # make sure you roll forward, so negate
+            monthsSince = monthsSince - 3
+
+        if n < 0 and (monthsSince == 0 and other.day > 1):
+            # after start, so come back an extra period as if rolled forward
+            n = n + 1
+
+        other = other + relativedelta(months=3*n - monthsSince, day=1)
+        return other
+
+    def rule_code(self):
+        suffix = '-%s' % _month_dict[self.startingMonth]
+        return 'QS' + suffix
+
+
+class BYearEnd(DateOffset, CacheableOffset):
+    """DateOffset increments between business EOM dates"""
+    _outputName = 'BusinessYearEnd'
+
+    def __init__(self, n=1, **kwds):
+        self.month = kwds.get('month', 12)
+
+        if self.month < 1 or self.month > 12:
+            raise Exception('Month must go from 1 to 12')
+
+        DateOffset.__init__(self, n=n, **kwds)
+
+    def apply(self, other):
+        n = self.n
+
+        wkday, days_in_month = lib.monthrange(other.year, self.month)
+        lastBDay = (days_in_month -
+                    max(((wkday + days_in_month - 1) % 7) - 4, 0))
+
+        years = n
+        if n > 0:
+            if (other.month < self.month or
+                (other.month == self.month and other.day < lastBDay)):
+                years -= 1
+        elif n <= 0:
+            if (other.month > self.month or
+                (other.month == self.month and other.day > lastBDay)):
+                years += 1
+
+        other = other + relativedelta(years=years)
+
+        _, days_in_month = lib.monthrange(other.year, self.month)
+        result = datetime(other.year, self.month, days_in_month)
+
+        if result.weekday() > 4:
+            result = result - BDay()
+
+        return result
+
+    def rule_code(self):
+        suffix = '-%s' % _month_dict[self.month]
+        return 'BA' + suffix
+
+
+class BYearBegin(DateOffset, CacheableOffset):
+    """DateOffset increments between business year begin dates"""
+    _outputName = 'BusinessYearBegin'
+
+    def __init__(self, n=1, **kwds):
+        self.month = kwds.get('month', 1)
+
+        if self.month < 1 or self.month > 12:
+            raise Exception('Month must go from 1 to 12')
+
+        DateOffset.__init__(self, n=n, **kwds)
+
+    def apply(self, other):
+        n = self.n
+
+        wkday, days_in_month = lib.monthrange(other.year, self.month)
+
+        first = _get_firstbday(wkday)
+
+        years = n
+
+
+        if n > 0: # roll back first for positive n
+            if (other.month < self.month or
+                (other.month == self.month and other.day < first)):
+                years -= 1
+        elif n <= 0: # roll forward
+            if (other.month > self.month or
+                (other.month == self.month and other.day > first)):
+                years += 1
+
+        # set first bday for result
+        other = other + relativedelta(years = years)
+        wkday, days_in_month = lib.monthrange(other.year, self.month)
+        first = _get_firstbday(wkday)
+        return datetime(other.year, self.month, first)
+
+    def rule_code(self):
+        suffix = '-%s' % _month_dict[self.month]
+        return 'BAS' + suffix
+
+
+class YearEnd(DateOffset, CacheableOffset):
+    """DateOffset increments between calendar year ends"""
+
+    def __init__(self, n=1, **kwds):
+        self.month = kwds.get('month', 12)
+
+        if self.month < 1 or self.month > 12:
+            raise Exception('Month must go from 1 to 12')
+
+        DateOffset.__init__(self, n=n, **kwds)
+
+    def apply(self, other):
+        n = self.n
+        wkday, days_in_month = lib.monthrange(other.year, self.month)
+        if other.month != self.month or other.day != days_in_month:
+            other = datetime(other.year - 1, self.month, days_in_month)
+            if n <= 0:
+                n = n + 1
+        other = other + relativedelta(years=n)
+        return other
+
+    def onOffset(self, dt):
+        wkday, days_in_month = lib.monthrange(dt.year, self.month)
+        return self.month == dt.month and dt.day == days_in_month
+
+    def rule_code(self):
+        suffix = '-%s' % _month_dict[self.month]
+        return 'A' + suffix
+
+
+class YearBegin(DateOffset, CacheableOffset):
+    """DateOffset increments between calendar year begin dates"""
+
+    def __init__(self, n=1, **kwds):
+        self.month = kwds.get('month', 12)
+
+        if self.month < 1 or self.month > 12:
+            raise Exception('Month must go from 1 to 12')
+
+        DateOffset.__init__(self, n=n, **kwds)
+
+    def apply(self, other):
+        n = self.n
+        if other.month != 1 or other.day != 1:
+            other = datetime(other.year, 1, 1)
+            if n <= 0:
+                n = n + 1
+        other = other + relativedelta(years = n, day=1)
+        return other
+
+    @classmethod
+    def onOffset(cls, dt):
+        return dt.month == 1 and dt.day == 1
+
+    def rule_code(self):
+        suffix = '-%s' % _month_dict[self.month]
+        return 'AS' + suffix
+
+
+#-------------------------------------------------------------------------------
+# Ticks
+
+class Tick(DateOffset):
+    _delta = None
+    _inc = timedelta(microseconds=1000)
+
+    def __eq__(self, other):
+        if isinstance(other, Tick):
+            return self._inc == other._inc
+        else:
+            return DateOffset.__eq__(self, other)
+
+    def __ne__(self, other):
+        if isinstance(other, Tick):
+            return self.delta != other.delta
+        else:
+            return DateOffset.__ne__(self, other)
+
+    @property
+    def delta(self):
+        if self._delta is None:
+            self._delta = self.n * self._inc
+
+        return self._delta
+
+    def us_stride(self):
+        return (self.delta.days * 24 * 60 * 60 * 1000000
+                + self.delta.seconds * 1000000
+                + self.delta.microseconds)
+
+    def apply(self, other):
+        if isinstance(other, (datetime, timedelta)):
+            return other + self.delta
+        elif isinstance(other, type(self)):
+            return type(self)(self.n + other.n)
+
+    def rule_code(self):
+        return 'T'
+
+class Hour(Tick):
+    _inc = timedelta(0, 3600)
+
+    def rule_code(self):
+        return 'H'
+
+class Minute(Tick):
+    _inc = timedelta(0, 60)
+
+    def rule_code(self):
+        return 'T'
+
+class Second(Tick):
+    _inc = timedelta(0, 1)
+
+    def rule_code(self):
+        return 'S'
+
+class Milli(Tick):
+
+    def rule_code(self):
+        return 'L'
+
+class Micro(Tick):
+    _inc = timedelta(microseconds=1)
+
+    def rule_code(self):
+        return 'U'
+
+BDay = BusinessDay
+BMonthEnd = BusinessMonthEnd
+BMonthBegin = BusinessMonthBegin
+
+day = DateOffset()
+bday = BDay()
+businessDay = bday
+monthEnd = MonthEnd()
+yearEnd = YearEnd()
+yearBegin = YearBegin()
+bmonthEnd = BMonthEnd()
+businessMonthEnd = bmonthEnd
+bquarterEnd = BQuarterEnd()
+quarterEnd = QuarterEnd()
+byearEnd = BYearEnd()
+week = Week()
+
+
+# Functions/offsets to roll dates forward
+thisMonthEnd = MonthEnd(0)
+thisBMonthEnd = BMonthEnd(0)
+thisYearEnd = YearEnd(0)
+thisYearBegin = YearBegin(0)
+thisBQuarterEnd = BQuarterEnd(0)
+thisQuarterEnd = QuarterEnd(0)
+
+# Functions to check where a date lies
+isBusinessDay = BDay().onOffset
+isMonthEnd = MonthEnd().onOffset
+isBMonthEnd = BMonthEnd().onOffset
+
+
+def _get_firstbday(wkday):
+    """
+    wkday is the result of monthrange(year, month)
+
+    If it's a saturday or sunday, increment first business day to reflect this
+    """
+    first = 1
+    if wkday == 5: # on Saturday
+        first = 3
+    elif wkday == 6: # on Sunday
+        first = 2
+    return first
+
+
+def generate_range(start=None, end=None, periods=None,
+                   offset=BDay(), time_rule=None):
+    """
+    Generates a sequence of dates corresponding to the specified time
+    offset. Similar to dateutil.rrule except uses pandas DateOffset
+    objects to represent time increments
+
+    Parameters
+    ----------
+    start : datetime (default None)
+    end : datetime (default None)
+    periods : int, optional
+
+    Note
+    ----
+    * This method is faster for generating weekdays than dateutil.rrule
+    * At least two of (start, end, periods) must be specified.
+    * If both start and end are specified, the returned dates will
+    satisfy start <= date <= end.
+
+    Returns
+    -------
+    dates : generator object
+
+    """
+    if time_rule is not None:
+        from pandas.tseries.frequencies import get_offset
+        offset = get_offset(time_rule)
+
+    start = to_datetime(start)
+    end = to_datetime(end)
+
+    if start and not offset.onOffset(start):
+        start = offset.rollforward(start)
+
+    if end and not offset.onOffset(end):
+        end = offset.rollback(end)
+
+        if periods is None and end < start:
+            end = None
+            periods = 0
+
+    if end is None:
+        end = start + (periods - 1) * offset
+
+    if start is None:
+        start = end - (periods - 1) * offset
+
+    cur = start
+
+    next_date = cur
+    while cur <= end:
+        yield cur
+
+        # faster than cur + offset
+        next_date = offset.apply(cur)
+        if next_date <= cur:
+            raise ValueError('Offset %s did not increment date' % offset)
+        cur = next_date
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
new file mode 100644
index 000000000..05657b47c
--- /dev/null
+++ b/pandas/tseries/period.py
@@ -0,0 +1,856 @@
+from datetime import datetime
+import numpy as np
+
+from pandas.tseries.frequencies import get_freq_code as _gfc
+from pandas.tseries.index import DatetimeIndex, Int64Index
+from pandas.tseries.tools import parse_time_string
+import pandas.tseries.frequencies as _freq_mod
+
+import pandas.core.common as com
+import pandas.core.datetools as datetools
+
+from pandas._tseries import Timestamp
+import pandas._tseries as lib
+
+
+#---------------
+# Period logic
+
+def to_period(arg, freq=None):
+    """ Attempts to convert arg to timestamp """
+    if arg is None:
+        return arg
+
+    if type(arg) == float:
+        raise TypeError("Cannot convert a float to period")
+
+    return Period(arg, freq=freq)
+
+class Period(object):
+
+    def __init__(self, value=None, freq=None,
+                 year=None, month=1, quarter=None, day=1,
+                 hour=0, minute=0, second=0):
+        """
+        Represents an period of time
+
+        Parameters
+        ----------
+        value : Period or basestring, default None
+            The time period represented (e.g., '4Q2005')
+        freq : str, default None
+            e.g., 'B' for businessday, ('T', 5) or '5T' for 5 minutes
+        year : int, default None
+        month : int, default 1
+        quarter : int, default None
+        day : int, default 1
+        hour : int, default 0
+        minute : int, default 0
+        second : int, default 0
+        """
+        # freq points to a tuple (base, mult);  base is one of the defined
+        # periods such as A, Q, etc. Every five minutes would be, e.g.,
+        # ('T', 5) but may be passed in as a string like '5T'
+
+        self.freq = None
+
+        # ordinal is the period offset from the gregorian proleptic epoch
+
+        self.ordinal = None
+
+        if value is None:
+            if freq is None:
+                raise ValueError("If value is None, freq cannot be None")
+
+            if year is None:
+                raise ValueError("If value is None, year cannot be None")
+
+            if quarter is not None:
+                month = (quarter - 1) * 3 + 1
+
+            base, mult = _gfc(freq)
+
+            self.ordinal = lib.period_ordinal(year, month, day, hour, minute,
+                                            second, base, mult)
+
+        elif isinstance(value, Period):
+            other = value
+            if freq is None or _gfc(freq) == _gfc(other.freq):
+                self.ordinal = other.ordinal
+                freq = other.freq
+            else:
+                converted = other.asfreq(freq)
+                self.ordinal = converted.ordinal
+
+        elif isinstance(value, basestring):
+            value = value.upper()
+            dt, parsed, reso = parse_time_string(value)
+
+            if freq is None:
+                if reso == 'year':
+                    freq = 'A'
+                elif reso == 'quarter':
+                    freq = 'Q'
+                elif reso == 'month':
+                    freq = 'M'
+                elif reso == 'day':
+                    freq = 'D'
+                elif reso == 'hour':
+                    freq = 'H'
+                elif reso == 'minute':
+                    freq = 'T'
+                elif reso == 'second':
+                    freq = 'S'
+                else:
+                    raise ValueError("Could not infer frequency for period")
+
+        elif isinstance(value, datetime):
+            dt = value
+            if freq is None:
+                raise ValueError('Must supply freq for datetime value')
+        elif isinstance(value, (int, long)):
+            if value <= 0:
+                raise ValueError("Value must be positive")
+            self.ordinal = value
+            if freq is None:
+                raise ValueError('Must supply freq for ordinal value')
+        else:
+            msg = "Value must be Period, string, integer, or datetime"
+            raise ValueError(msg)
+
+        base, mult = _gfc(freq)
+
+        if self.ordinal is None:
+            self.ordinal = lib.period_ordinal(dt.year, dt.month, dt.day, dt.hour,
+                                            dt.minute, dt.second, base, mult)
+
+        self.freq = _freq_mod._get_freq_str(base, mult)
+
+    def __eq__(self, other):
+        if isinstance(other, Period):
+            return (self.ordinal == other.ordinal
+                    and _gfc(self.freq) == _gfc(other.freq))
+        return False
+
+    def __add__(self, other):
+        if isinstance(other, (int, long)):
+            return Period(self.ordinal + other, self.freq)
+        raise ValueError("Cannot add with non-integer value")
+
+    def __sub__(self, other):
+        if isinstance(other, (int, long)):
+            return Period(self.ordinal - other, self.freq)
+        if isinstance(other, Period):
+            if other.freq != self.freq:
+                raise ValueError("Cannot do arithmetic with "
+                                 "non-conforming periods")
+            return self.ordinal - other.ordinal
+        raise ValueError("Cannot sub with non-integer value")
+
+    def asfreq(self, freq=None, how='E'):
+        """
+
+        Parameters
+        ----------
+        freq :
+        how :
+
+        Returns
+        -------
+        resampled : Period
+        """
+        how = _validate_end_alias(how)
+        base1, mult1 = _gfc(self.freq)
+        base2, mult2 = _gfc(freq)
+
+        new_ordinal = lib.period_asfreq(self.ordinal, base1, mult1,
+                                        base2, mult2, how)
+
+        return Period(new_ordinal, (base2, mult2))
+
+    def start_time(self):
+        return self.to_timestamp(which_end='S')
+
+    def end_time(self):
+        return self.to_timestamp(which_end='E')
+
+    def to_timestamp(self, which_end='S'):
+        """
+        Return the Timestamp at the start/end of the period
+
+        Parameters
+        ----------
+        which_end: str, default 'S' (start)
+            'S', 'E'. Can be aliased as case insensitive
+            'Start', 'Finish', 'Begin', 'End'
+
+        Returns
+        -------
+        Timestamp
+        """
+        which_end = _validate_end_alias(which_end)
+        new_val = self.asfreq('S', which_end)
+        base, mult = _gfc(new_val.freq)
+        return Timestamp(lib.period_ordinal_to_dt64(new_val.ordinal, base, mult))
+
+    @property
+    def year(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_year(self.ordinal, base, mult)
+
+    @property
+    def month(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_month(self.ordinal, base, mult)
+
+    @property
+    def qyear(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_qyear(self.ordinal, base, mult)
+
+    @property
+    def quarter(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_quarter(self.ordinal, base, mult)
+
+    @property
+    def day(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_day(self.ordinal, base, mult)
+
+    @property
+    def week(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_week(self.ordinal, base, mult)
+
+    @property
+    def weekday(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_weekday(self.ordinal, base, mult)
+
+    @property
+    def day_of_week(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_dow(self.ordinal, base, mult)
+
+    @property
+    def day_of_year(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_doy(self.ordinal, base, mult)
+
+    @property
+    def hour(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_hour(self.ordinal, base, mult)
+
+    @property
+    def minute(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_minute(self.ordinal, base, mult)
+
+    @property
+    def second(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_second(self.ordinal, base, mult)
+
+    @classmethod
+    def now(cls, freq=None):
+        return Period(datetime.now(), freq=freq)
+
+    def __repr__(self):
+        base, mult = _gfc(self.freq)
+        formatted = lib.period_ordinal_to_string(self.ordinal, base, mult)
+        freqstr = _freq_mod._reverse_period_code_map[base]
+        if mult == 1:
+            return "Period('%s', '%s')" % (formatted, freqstr)
+        return ("Period('%s', '%d%s')" % (formatted, mult, freqstr))
+
+    def __str__(self):
+        base, mult = _gfc(self.freq)
+        formatted = lib.period_ordinal_to_string(self.ordinal, base, mult)
+        return ("%s" % formatted)
+
+    def strftime(self, fmt):
+        """
+        Returns the string representation of the :class:`Period`, depending
+        on the selected :keyword:`format`. :keyword:`format` must be a string
+        containing one or several directives.  The method recognizes the same
+        directives as the :func:`time.strftime` function of the standard Python
+        distribution, as well as the specific additional directives ``%f``,
+        ``%F``, ``%q``. (formatting & docs originally from scikits.timeries)
+
+        +-----------+--------------------------------+-------+
+        | Directive | Meaning                        | Notes |
+        +===========+================================+=======+
+        | ``%a``    | Locale's abbreviated weekday   |       |
+        |           | name.                          |       |
+        +-----------+--------------------------------+-------+
+        | ``%A``    | Locale's full weekday name.    |       |
+        +-----------+--------------------------------+-------+
+        | ``%b``    | Locale's abbreviated month     |       |
+        |           | name.                          |       |
+        +-----------+--------------------------------+-------+
+        | ``%B``    | Locale's full month name.      |       |
+        +-----------+--------------------------------+-------+
+        | ``%c``    | Locale's appropriate date and  |       |
+        |           | time representation.           |       |
+        +-----------+--------------------------------+-------+
+        | ``%d``    | Day of the month as a decimal  |       |
+        |           | number [01,31].                |       |
+        +-----------+--------------------------------+-------+
+        | ``%f``    | 'Fiscal' year without a        | \(1)  |
+        |           | century  as a decimal number   |       |
+        |           | [00,99]                        |       |
+        +-----------+--------------------------------+-------+
+        | ``%F``    | 'Fiscal' year with a century   | \(2)  |
+        |           | as a decimal number            |       |
+        +-----------+--------------------------------+-------+
+        | ``%H``    | Hour (24-hour clock) as a      |       |
+        |           | decimal number [00,23].        |       |
+        +-----------+--------------------------------+-------+
+        | ``%I``    | Hour (12-hour clock) as a      |       |
+        |           | decimal number [01,12].        |       |
+        +-----------+--------------------------------+-------+
+        | ``%j``    | Day of the year as a decimal   |       |
+        |           | number [001,366].              |       |
+        +-----------+--------------------------------+-------+
+        | ``%m``    | Month as a decimal number      |       |
+        |           | [01,12].                       |       |
+        +-----------+--------------------------------+-------+
+        | ``%M``    | Minute as a decimal number     |       |
+        |           | [00,59].                       |       |
+        +-----------+--------------------------------+-------+
+        | ``%p``    | Locale's equivalent of either  | \(3)  |
+        |           | AM or PM.                      |       |
+        +-----------+--------------------------------+-------+
+        | ``%q``    | Quarter as a decimal number    |       |
+        |           | [01,04]                        |       |
+        +-----------+--------------------------------+-------+
+        | ``%S``    | Second as a decimal number     | \(4)  |
+        |           | [00,61].                       |       |
+        +-----------+--------------------------------+-------+
+        | ``%U``    | Week number of the year        | \(5)  |
+        |           | (Sunday as the first day of    |       |
+        |           | the week) as a decimal number  |       |
+        |           | [00,53].  All days in a new    |       |
+        |           | year preceding the first       |       |
+        |           | Sunday are considered to be in |       |
+        |           | week 0.                        |       |
+        +-----------+--------------------------------+-------+
+        | ``%w``    | Weekday as a decimal number    |       |
+        |           | [0(Sunday),6].                 |       |
+        +-----------+--------------------------------+-------+
+        | ``%W``    | Week number of the year        | \(5)  |
+        |           | (Monday as the first day of    |       |
+        |           | the week) as a decimal number  |       |
+        |           | [00,53].  All days in a new    |       |
+        |           | year preceding the first       |       |
+        |           | Monday are considered to be in |       |
+        |           | week 0.                        |       |
+        +-----------+--------------------------------+-------+
+        | ``%x``    | Locale's appropriate date      |       |
+        |           | representation.                |       |
+        +-----------+--------------------------------+-------+
+        | ``%X``    | Locale's appropriate time      |       |
+        |           | representation.                |       |
+        +-----------+--------------------------------+-------+
+        | ``%y``    | Year without century as a      |       |
+        |           | decimal number [00,99].        |       |
+        +-----------+--------------------------------+-------+
+        | ``%Y``    | Year with century as a decimal |       |
+        |           | number.                        |       |
+        +-----------+--------------------------------+-------+
+        | ``%Z``    | Time zone name (no characters  |       |
+        |           | if no time zone exists).       |       |
+        +-----------+--------------------------------+-------+
+        | ``%%``    | A literal ``'%'`` character.   |       |
+        +-----------+--------------------------------+-------+
+
+        .. note::
+
+            (1)
+                The ``%f`` directive is the same as ``%y`` if the frequency is
+                not quarterly.
+                Otherwise, it corresponds to the 'fiscal' year, as defined by
+                the :attr:`qyear` attribute.
+
+            (2)
+                The ``%F`` directive is the same as ``%Y`` if the frequency is
+                not quarterly.
+                Otherwise, it corresponds to the 'fiscal' year, as defined by
+                the :attr:`qyear` attribute.
+
+            (3)
+                The ``%p`` directive only affects the output hour field
+                if the ``%I`` directive is used to parse the hour.
+
+            (4)
+                The range really is ``0`` to ``61``; this accounts for leap
+                seconds and the (very rare) double leap seconds.
+
+            (5)
+                The ``%U`` and ``%W`` directives are only used in calculations
+                when the day of the week and the year are specified.
+
+        .. rubric::  Examples
+
+            >>> a = Period(freq='Q@JUL', year=2006, quarter=1)
+            >>> a.strftime('%F-Q%q')
+            '2006-Q1'
+            >>> # Output the last month in the quarter of this date
+            >>> a.strftime('%b-%Y')
+            'Oct-2005'
+            >>>
+            >>> a = Period(freq='D', year=2001, month=1, day=1)
+            >>> a.strftime('%d-%b-%Y')
+            '01-Jan-2006'
+            >>> a.strftime('%b. %d, %Y was a %A')
+            'Jan. 01, 2001 was a Monday'
+        """
+        base, mult = _gfc(self.freq)
+        if fmt is not None:
+            return lib.period_strftime(self.ordinal, base, mult, fmt)
+        else:
+            return lib.period_ordinal_to_string(self.ordinal, base, mult)
+
+def _period_unbox(key, check=None):
+    '''
+    Period-like => int64
+    '''
+    if not isinstance(key, Period):
+        key = Period(key, freq=check)
+    elif check is not None:
+        if key.freq != check:
+            raise ValueError("%s is wrong freq" % key)
+    return np.int64(key.ordinal)
+
+def _period_unbox_array(arr, check=None):
+    if arr is None:
+        return arr
+    unboxer = np.frompyfunc(lambda x: _period_unbox(x, check=check), 1, 1)
+    return unboxer(arr)
+
+def _period_box(val, freq):
+    return Period(val, freq=freq)
+
+def _period_box_array(arr, freq):
+    if arr is None:
+        return arr
+
+    if not isinstance(arr, np.ndarray):
+        return arr
+
+    boxfunc = lambda x: _period_box(x, freq)
+    boxer = np.frompyfunc(boxfunc, 1, 1)
+    return boxer(arr)
+
+def dt64arr_to_periodarr(data, freq):
+    if data is None:
+        return data
+
+    if isinstance(freq, basestring):
+        base, mult = _gfc(freq)
+    else:
+        base, mult = freq
+
+    return lib.dt64arr_to_periodarr(data.view('i8'), base, mult)
+
+# --- Period index sketch
+
+class PeriodIndex(Int64Index):
+    """
+    Immutable ndarray holding ordinal values indicating regular periods in
+    time such as particular years, quarters, months, etc. A value of 1 is the
+    period containing the Gregorian proleptic datetime Jan 1, 0001 00:00:00.
+    This ordinal representation is from the scikits.timeseries project.
+
+    For instance,
+        # construct period for day 1/1/1 and get the first second
+        i = Period(year=1,month=1,day=1,freq='D').asfreq('S', 'S')
+        i.ordinal
+        ===> 1
+
+    Index keys are boxed to Period objects which carries the metadata (eg,
+    frequency information).
+
+    Parameters
+    ----------
+    data  : array-like (1-dimensional), optional
+        Optional period-like data to construct index with
+    dtype : NumPy dtype (default: i8)
+    copy  : bool
+        Make a copy of input ndarray
+    freq : string or period object, optional
+        One of pandas period strings or corresponding objects
+    start : starting value, period-like, optional
+        If data is None, used as the start point in generating regular
+        period data.
+    periods  : int, optional, > 0
+        Number of periods to generate, if generating index. Takes precedence
+        over end argument
+    end   : end value, period-like, optional
+        If periods is none, generated index will extend to first conforming
+        period on or just past end argument
+    """
+
+    def __new__(cls, data=None,
+                freq=None, start=None, end=None, periods=None,
+                copy=False, name=None):
+
+        if isinstance(freq, Period):
+            freq = freq.freq
+        else:
+            freq = datetools.get_standard_freq(freq)
+
+        if data is None:
+            if start is None and end is None:
+                raise ValueError('Must specify start, end, or data')
+
+            start = to_period(start, freq)
+            end = to_period(end, freq)
+
+            is_start_intv = isinstance(start, Period)
+            is_end_intv = isinstance(end, Period)
+            if (start is not None and not is_start_intv):
+                raise ValueError('Failed to convert %s to period' % start)
+
+            if (end is not None and not is_end_intv):
+                raise ValueError('Failed to convert %s to period' % end)
+
+            if is_start_intv and is_end_intv and (start.freq != end.freq):
+                raise ValueError('Start and end must have same freq')
+
+            if freq is None:
+                if is_start_intv:
+                    freq = start.freq
+                elif is_end_intv:
+                    freq = end.freq
+                else:
+                    raise ValueError('Could not infer freq from start/end')
+
+            if periods is not None:
+                if start is None:
+                    data = np.arange(end.ordinal - periods + 1,
+                                     end.ordinal + 1,
+                                     dtype=np.int64)
+                else:
+                    data = np.arange(start.ordinal, start.ordinal + periods,
+                                     dtype=np.int64)
+            else:
+                if start is None or end is None:
+                    msg = 'Must specify both start and end if periods is None'
+                    raise ValueError(msg)
+                data = np.arange(start.ordinal, end.ordinal+1, dtype=np.int64)
+
+            subarr = data.view(cls)
+            subarr.name = name
+            subarr.freq = freq
+
+            return subarr
+
+        if not isinstance(data, np.ndarray):
+            if np.isscalar(data):
+                raise ValueError('PeriodIndex() must be called with a '
+                                 'collection of some kind, %s was passed'
+                                 % repr(data))
+
+            if isinstance(data, Period):
+                data = [data]
+
+            # other iterable of some kind
+            if not isinstance(data, (list, tuple)):
+                data = list(data)
+
+            try:
+                data = np.array(data, dtype='i8')
+            except:
+                data = np.array(data, dtype='O')
+
+            if freq is None:
+                raise ValueError('freq cannot be none')
+
+            data = _period_unbox_array(data, check=freq)
+        else:
+            if isinstance(data, PeriodIndex):
+                if freq is None or freq == data.freq:
+                    freq = data.freq
+                    data = data.values
+                else:
+                    base1, mult1 = _gfc(data.freq)
+                    base2, mult2 = _gfc(freq)
+                    data = lib.period_asfreq_arr(data.values, base1, mult1,
+                                                 base2, mult2, 'E')
+            else:
+                if freq is None:
+                    raise ValueError('freq cannot be none')
+
+                if data.dtype == np.datetime64:
+                    data = dt64arr_to_periodarr(data, freq)
+                elif data.dtype == np.int64:
+                    pass
+                else:
+                    data = data.astype('i8')
+
+        data = np.array(data, dtype=np.int64, copy=False)
+
+        if (data <= 0).any():
+            raise ValueError("Found illegal (<= 0) values in data")
+
+        subarr = data.view(cls)
+        subarr.name = name
+        subarr.freq = freq
+
+        return subarr
+
+    def asfreq(self, freq=None, how='E'):
+        how = _validate_end_alias(how)
+
+        base1, mult1 = _gfc(self.freq)
+
+        if isinstance(freq, basestring):
+            base2, mult2 = _gfc(freq)
+        else:
+            base2, mult2 = freq
+
+
+        new_data = lib.period_asfreq_arr(self.values,
+                                         base1, mult1,
+                                         base2, mult2, how)
+
+        return PeriodIndex(new_data, freq=freq)
+
+    @property
+    def year(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_year_arr(self.values, base, mult)
+
+    @property
+    def month(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_month_arr(self.values, base, mult)
+
+    @property
+    def qyear(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_qyear_arr(self.values, base, mult)
+
+    @property
+    def quarter(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_quarter_arr(self.values, base, mult)
+
+    @property
+    def day(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_day_arr(self.values, base, mult)
+
+    @property
+    def week(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_week_arr(self.values, base, mult)
+
+    @property
+    def weekday(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_weekday_arr(self.values, base, mult)
+
+    @property
+    def day_of_week(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_dow_arr(self.values, base, mult)
+
+    @property
+    def day_of_year(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_doy_arr(self.values, base, mult)
+
+    @property
+    def hour(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_hour_arr(self.values, base, mult)
+
+    @property
+    def minute(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_minute_arr(self.values, base, mult)
+
+    @property
+    def second(self):
+        base, mult = _gfc(self.freq)
+        return lib.get_period_second_arr(self.values, base, mult)
+
+    # Try to run function on index first, and then on elements of index
+    # Especially important for group-by functionality
+    def map(self, func_to_map):
+        try:
+            return func_to_map(self)
+        except:
+            return super(DatetimeIndex, self).map(func_to_map)
+
+    def _mpl_repr(self):
+        # how to represent ourselves to matplotlib
+        return datetools._period_box_array(self, self.freq)
+
+    def to_timestamp(self):
+        """
+        Cast to datetimeindex of timestamps, at *beginning* of period
+        """
+        base, mult = _gfc('S')
+        new_data = self.asfreq('S', 'S')
+        new_data = lib.periodarr_to_dt64arr(new_data.values, base, mult)
+        return DatetimeIndex(new_data, freq=self.freq)
+
+    def shift(self, n):
+        """
+        Specialized shift which produces an PeriodIndex
+
+        Parameters
+        ----------
+        n : int
+            Periods to shift by
+        freq : freq string
+
+        Returns
+        -------
+        shifted : PeriodIndex
+        """
+        if n == 0:
+            return self
+
+        return PeriodIndex(data=self.values + n, freq=self.freq)
+
+    def __add__(self, other):
+        if isinstance(other, (int, long)):
+            return PeriodIndex(self.values + other, self.freq)
+        return super(PeriodIndex, self).__add__(other)
+
+    def __sub__(self, other):
+        if isinstance(other, (int, long)):
+            return PeriodIndex(self.values - other, self.freq)
+        if isinstance(other, Period):
+            if other.freq != self.freq:
+                raise ValueError("Cannot do arithmetic with "
+                                 "non-conforming periods")
+            return PeriodIndex(self.values - other.ordinal)
+        return super(PeriodIndex, self).__sub__(other)
+
+    @property
+    def inferred_type(self):
+        # b/c data is represented as ints make sure we can't have ambiguous
+        # indexing
+        return 'period'
+
+    def get_value(self, series, key):
+        """
+        Fast lookup of value from 1-dimensional ndarray. Only use this if you
+        know what you're doing
+        """
+        try:
+            return super(PeriodIndex, self).get_value(series, key)
+        except KeyError:
+            try:
+                asdt, parsed, reso = datetools.parse_time_string(key)
+                grp = _freq_mod._infer_period_group(reso)
+                freqn = _freq_mod._period_group(self.freq)
+
+                # if our data is higher resolution than requested key, slice
+                if grp < freqn:
+                    iv = Period(asdt, freq=(grp,1))
+                    ord1 = iv.asfreq(self.freq, how='S').ordinal
+                    ord2 = iv.asfreq(self.freq, how='E').ordinal
+                    pos = np.searchsorted(self.values, [ord1, ord2])
+                    key = slice(pos[0], pos[1]+1)
+                    return series[key]
+                else:
+                    key = to_period(asdt, freq=self.freq).ordinal
+                    return self._engine.get_value(series, key)
+            except TypeError:
+                pass
+            except KeyError:
+                pass
+            except IndexError:
+                ival = Period(key, freq=self.freq)
+                raise IndexError("%s is out of bounds" % ival)
+
+            key = to_period(key, self.freq).ordinal
+            return self._engine.get_value(series, key)
+
+    def get_loc(self, key):
+        """
+        Get integer location for requested label
+
+        Returns
+        -------
+        loc : int
+        """
+        try:
+            return self._engine.get_loc(key)
+        except KeyError:
+            try:
+                asdt, parsed, reso = datetools.parse_time_string(key)
+                key = asdt
+            except TypeError:
+                pass
+            except KeyError:
+                pass
+
+            key = to_period(key, self.freq).ordinal
+            return self._engine.get_loc(key)
+
+    def __getitem__(self, key):
+        """Override numpy.ndarray's __getitem__ method to work as desired"""
+        arr_idx = self.view(np.ndarray)
+        if np.isscalar(key):
+            val = arr_idx[key]
+            return _period_box(val, freq=self.freq)
+        else:
+            if com._is_bool_indexer(key):
+                key = np.asarray(key)
+
+            result = arr_idx[key]
+            if result.ndim > 1:
+                return PeriodIndex(result, name=self.name, freq=self.freq)
+
+            return PeriodIndex(result, name=self.name, freq=self.freq)
+
+    def format(self, name=False):
+        """
+        Render a string representation of the Index
+        """
+        header = []
+
+        if name:
+            header.append(str(self.name) if self.name is not None else '')
+
+        return header + ['%s' % _period_box(x, freq=self.freq) for x in self]
+
+    def _view_like(self, ndarray):
+        result = ndarray.view(type(self))
+        result.freq = self.freq
+        result.name = self.name
+        return result
+
+    def __array_finalize__(self, obj):
+        if self.ndim == 0: # pragma: no cover
+            return self.item()
+
+        self.freq = getattr(obj, 'freq', None)
+
+    def __repr__(self):
+        output = str(self.__class__) + '\n'
+        output += 'freq: ''%s''\n' % self.freq
+        if len(self) > 0:
+            output += '[%s, ..., %s]\n' % (self[0], self[-1])
+        output += 'length: %d' % len(self)
+        return output
+
+
+def _validate_end_alias(how):
+    how_dict = {'S': 'S', 'E': 'E',
+                'START': 'S', 'FINISH': 'E',
+                'BEGIN': 'S', 'END': 'E'}
+    how = how_dict.get(str(how).upper())
+    if how not in set(['S', 'E']):
+        raise ValueError('How must be one of S or E')
+    return how
+
diff --git a/pandas/tests/data/frame.pickle b/pandas/tseries/tests/data/frame.pickle
similarity index 100%
rename from pandas/tests/data/frame.pickle
rename to pandas/tseries/tests/data/frame.pickle
diff --git a/pandas/tests/data/series.pickle b/pandas/tseries/tests/data/series.pickle
similarity index 100%
rename from pandas/tests/data/series.pickle
rename to pandas/tseries/tests/data/series.pickle
diff --git a/pandas/tseries/tests/test_period.py b/pandas/tseries/tests/test_period.py
new file mode 100644
index 000000000..7b7919a90
--- /dev/null
+++ b/pandas/tseries/tests/test_period.py
@@ -0,0 +1,1082 @@
+"""Tests suite for Period handling.
+
+Parts derived from scikits.timeseries code, original authors:
+- Pierre Gerard-Marchant & Matt Knox
+- pierregm_at_uga_dot_edu - mattknow_ca_at_hotmail_dot_com
+
+"""
+
+from unittest import TestCase
+from datetime import datetime
+
+from numpy.ma.testutils import assert_equal
+
+from pandas.tseries.period import Period, PeriodIndex
+from pandas.tseries.index import DatetimeIndex
+
+import pandas.core.datetools as datetools
+import numpy as np
+
+from pandas import Series
+from pandas.util.testing import assert_series_equal
+
+class TestPeriodProperties(TestCase):
+    "Test properties such as year, month, weekday, etc...."
+    #
+    def __init__(self, *args, **kwds):
+        TestCase.__init__(self, *args, **kwds)
+
+    def test_interval_constructor(self):
+        i1 = Period('1/1/2005', freq='M')
+        i2 = Period('Jan 2005')
+
+        self.assertEquals(i1, i2)
+
+        i1 = Period('2005', freq='A')
+        i2 = Period('2005')
+        i3 = Period('2005', freq='a')
+
+        self.assertEquals(i1, i2)
+        self.assertEquals(i1, i3)
+
+        i4 = Period('2005', freq='M')
+        i5 = Period('2005', freq='m')
+
+        self.assert_(i1 != i4)
+        self.assertEquals(i4, i5)
+
+        i1 = Period.now('Q')
+        i2 = Period(datetime.now(), freq='Q')
+        i3 = Period.now('q')
+
+        self.assertEquals(i1, i2)
+        self.assertEquals(i1, i3)
+
+        # Biz day construction, roll forward if non-weekday
+        i1 = Period('3/10/12', freq='B')
+        i2 = Period('3/12/12', freq='D')
+        self.assertEquals(i1, i2.asfreq('B'))
+
+        i3 = Period('3/10/12', freq='b')
+        self.assertEquals(i1, i3)
+
+        i1 = Period(year=2005, quarter=1, freq='Q')
+        i2 = Period('1/1/2005', freq='Q')
+        self.assertEquals(i1, i2)
+
+        i1 = Period(year=2005, quarter=3, freq='Q')
+        i2 = Period('9/1/2005', freq='Q')
+        self.assertEquals(i1, i2)
+
+        i1 = Period(year=2005, month=3, day=1, freq='D')
+        i2 = Period('3/1/2005', freq='D')
+        self.assertEquals(i1, i2)
+
+        i3 = Period(year=2005, month=3, day=1, freq='d')
+        self.assertEquals(i1, i3)
+
+        i1 = Period(year=2012, month=3, day=10, freq='B')
+        i2 = Period('3/12/12', freq='B')
+        self.assertEquals(i1, i2)
+
+        i1 = Period('2005Q1')
+        i2 = Period(year=2005, quarter=1, freq='Q')
+        i3 = Period('2005q1')
+        self.assertEquals(i1, i2)
+        self.assertEquals(i1, i3)
+
+        i1 = Period('05Q1')
+        self.assertEquals(i1, i2)
+        lower = Period('05q1')
+        self.assertEquals(i1, lower)
+
+        i1 = Period('1Q2005')
+        self.assertEquals(i1, i2)
+        lower = Period('1q2005')
+        self.assertEquals(i1, lower)
+
+        i1 = Period('1Q05')
+        self.assertEquals(i1, i2)
+        lower = Period('1q05')
+        self.assertEquals(i1, lower)
+
+        i1 = Period('4Q1984')
+        self.assertEquals(i1.year, 1984)
+        lower = Period('4q1984')
+        self.assertEquals(i1, lower)
+
+        i1 = Period('1982', freq='min')
+        i2 = Period('1982', freq='MIN')
+        self.assertEquals(i1, i2)
+        i2 = Period('1982', freq=('Min', 1))
+        self.assertEquals(i1, i2)
+
+    def test_freq_str(self):
+        i1 = Period('1982', freq='Min')
+        self.assert_(i1.freq[0] != '1')
+
+        i2 = Period('11/30/2005', freq='2Q')
+        self.assertEquals(i2.freq[0], '2')
+
+    def test_to_timestamp(self):
+        intv = Period('1982', freq='A')
+        start_ts = intv.to_timestamp(which_end='S')
+        aliases = ['s', 'StarT', 'BEGIn']
+        for a in aliases:
+            self.assertEquals(start_ts, intv.to_timestamp(which_end=a))
+
+        end_ts = intv.to_timestamp(which_end='E')
+        aliases = ['e', 'end', 'FINIsH']
+        for a in aliases:
+            self.assertEquals(end_ts, intv.to_timestamp(which_end=a))
+
+        from_lst = ['A', 'Q', 'M', 'W', 'B',
+                    'D', 'H', 'Min', 'S']
+        for i, fcode in enumerate(from_lst):
+            intv = Period('1982', freq=fcode)
+            result = intv.to_timestamp().to_period(fcode)
+            self.assertEquals(result, intv)
+
+            self.assertEquals(intv.start_time(), intv.to_timestamp('S'))
+
+            self.assertEquals(intv.end_time(), intv.to_timestamp('E'))
+
+
+    def test_properties_annually(self):
+        # Test properties on Periods with annually frequency.
+        a_date = Period(freq='A', year=2007)
+        assert_equal(a_date.year, 2007)
+
+    def test_properties_quarterly(self):
+        # Test properties on Periods with daily frequency.
+        qedec_date = Period(freq="Q-DEC", year=2007, quarter=1)
+        qejan_date = Period(freq="Q-JAN", year=2007, quarter=1)
+        qejun_date = Period(freq="Q-JUN", year=2007, quarter=1)
+        #
+        for x in range(3):
+            for qd in (qedec_date, qejan_date, qejun_date):
+                assert_equal((qd + x).qyear, 2007)
+                assert_equal((qd + x).quarter, x + 1)
+
+
+    def test_properties_monthly(self):
+        # Test properties on Periods with daily frequency.
+        m_date = Period(freq='M', year=2007, month=1)
+        for x in range(11):
+            m_ival_x = m_date + x
+            assert_equal(m_ival_x.year, 2007)
+            if 1 <= x + 1 <= 3:
+                assert_equal(m_ival_x.quarter, 1)
+            elif 4 <= x + 1 <= 6:
+                assert_equal(m_ival_x.quarter, 2)
+            elif 7 <= x + 1 <= 9:
+                assert_equal(m_ival_x.quarter, 3)
+            elif 10 <= x + 1 <= 12:
+                assert_equal(m_ival_x.quarter, 4)
+            assert_equal(m_ival_x.month, x + 1)
+
+
+    def test_properties_weekly(self):
+        # Test properties on Periods with daily frequency.
+        w_date = Period(freq='WK', year=2007, month=1, day=7)
+        #
+        assert_equal(w_date.year, 2007)
+        assert_equal(w_date.quarter, 1)
+        assert_equal(w_date.month, 1)
+        assert_equal(w_date.week, 1)
+        assert_equal((w_date - 1).week, 52)
+
+
+    def test_properties_daily(self):
+        # Test properties on Periods with daily frequency.
+        b_date = Period(freq='B', year=2007, month=1, day=1)
+        #
+        assert_equal(b_date.year, 2007)
+        assert_equal(b_date.quarter, 1)
+        assert_equal(b_date.month, 1)
+        assert_equal(b_date.day, 1)
+        assert_equal(b_date.weekday, 0)
+        assert_equal(b_date.day_of_year, 1)
+        #
+        d_date = Period(freq='D', year=2007, month=1, day=1)
+        #
+        assert_equal(d_date.year, 2007)
+        assert_equal(d_date.quarter, 1)
+        assert_equal(d_date.month, 1)
+        assert_equal(d_date.day, 1)
+        assert_equal(d_date.weekday, 0)
+        assert_equal(d_date.day_of_year, 1)
+
+
+    def test_properties_hourly(self):
+        # Test properties on Periods with hourly frequency.
+        h_date = Period(freq='H', year=2007, month=1, day=1, hour=0)
+        #
+        assert_equal(h_date.year, 2007)
+        assert_equal(h_date.quarter, 1)
+        assert_equal(h_date.month, 1)
+        assert_equal(h_date.day, 1)
+        assert_equal(h_date.weekday, 0)
+        assert_equal(h_date.day_of_year, 1)
+        assert_equal(h_date.hour, 0)
+        #
+
+
+    def test_properties_minutely(self):
+        # Test properties on Periods with minutely frequency.
+        t_date = Period(freq='Min', year=2007, month=1, day=1, hour=0,
+                          minute=0)
+        #
+        assert_equal(t_date.quarter, 1)
+        assert_equal(t_date.month, 1)
+        assert_equal(t_date.day, 1)
+        assert_equal(t_date.weekday, 0)
+        assert_equal(t_date.day_of_year, 1)
+        assert_equal(t_date.hour, 0)
+        assert_equal(t_date.minute, 0)
+
+
+    def test_properties_secondly(self):
+        # Test properties on Periods with secondly frequency.
+        s_date = Period(freq='Min', year=2007, month=1, day=1,
+                                       hour=0, minute=0, second=0)
+        #
+        assert_equal(s_date.year, 2007)
+        assert_equal(s_date.quarter, 1)
+        assert_equal(s_date.month, 1)
+        assert_equal(s_date.day, 1)
+        assert_equal(s_date.weekday, 0)
+        assert_equal(s_date.day_of_year, 1)
+        assert_equal(s_date.hour, 0)
+        assert_equal(s_date.minute, 0)
+        assert_equal(s_date.second, 0)
+
+def noWrap(item):
+    return item
+
+class TestFreqConversion(TestCase):
+    "Test frequency conversion of date objects"
+
+    def __init__(self, *args, **kwds):
+        TestCase.__init__(self, *args, **kwds)
+
+    def test_conv_annual(self):
+        # frequency conversion tests: from Annual Frequency
+
+        ival_A = Period(freq='A', year=2007)
+
+        ival_AJAN = Period(freq="A-JAN", year=2007)
+        ival_AJUN = Period(freq="A-JUN", year=2007)
+        ival_ANOV = Period(freq="A-NOV", year=2007)
+
+        ival_A_to_Q_start = Period(freq='Q', year=2007, quarter=1)
+        ival_A_to_Q_end = Period(freq='Q', year=2007, quarter=4)
+        ival_A_to_M_start = Period(freq='M', year=2007, month=1)
+        ival_A_to_M_end = Period(freq='M', year=2007, month=12)
+        ival_A_to_W_start = Period(freq='WK', year=2007, month=1, day=1)
+        ival_A_to_W_end = Period(freq='WK', year=2007, month=12, day=31)
+        ival_A_to_B_start = Period(freq='B', year=2007, month=1, day=1)
+        ival_A_to_B_end = Period(freq='B', year=2007, month=12, day=31)
+        ival_A_to_D_start = Period(freq='D', year=2007, month=1, day=1)
+        ival_A_to_D_end = Period(freq='D', year=2007, month=12, day=31)
+        ival_A_to_H_start = Period(freq='H', year=2007, month=1, day=1,
+                                    hour=0)
+        ival_A_to_H_end = Period(freq='H', year=2007, month=12, day=31,
+                                    hour=23)
+        ival_A_to_T_start = Period(freq='Min', year=2007, month=1, day=1,
+                                    hour=0, minute=0)
+        ival_A_to_T_end = Period(freq='Min', year=2007, month=12, day=31,
+                                    hour=23, minute=59)
+        ival_A_to_S_start = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=0, minute=0, second=0)
+        ival_A_to_S_end = Period(freq='S', year=2007, month=12, day=31,
+                                    hour=23, minute=59, second=59)
+
+        ival_AJAN_to_D_end = Period(freq='D', year=2007, month=1, day=31)
+        ival_AJAN_to_D_start = Period(freq='D', year=2006, month=2, day=1)
+        ival_AJUN_to_D_end = Period(freq='D', year=2007, month=6, day=30)
+        ival_AJUN_to_D_start = Period(freq='D', year=2006, month=7, day=1)
+        ival_ANOV_to_D_end = Period(freq='D', year=2007, month=11, day=30)
+        ival_ANOV_to_D_start = Period(freq='D', year=2006, month=12, day=1)
+
+        assert_equal(ival_A.asfreq('Q', 'S'), ival_A_to_Q_start)
+        assert_equal(ival_A.asfreq('Q', 'E'), ival_A_to_Q_end)
+        assert_equal(ival_A.asfreq('M', 'S'), ival_A_to_M_start)
+        assert_equal(ival_A.asfreq('M', 'E'), ival_A_to_M_end)
+        assert_equal(ival_A.asfreq('WK', 'S'), ival_A_to_W_start)
+        assert_equal(ival_A.asfreq('WK', 'E'), ival_A_to_W_end)
+        assert_equal(ival_A.asfreq('B', 'S'), ival_A_to_B_start)
+        assert_equal(ival_A.asfreq('B', 'E'), ival_A_to_B_end)
+        assert_equal(ival_A.asfreq('D', 'S'), ival_A_to_D_start)
+        assert_equal(ival_A.asfreq('D', 'E'), ival_A_to_D_end)
+        assert_equal(ival_A.asfreq('H', 'S'), ival_A_to_H_start)
+        assert_equal(ival_A.asfreq('H', 'E'), ival_A_to_H_end)
+        assert_equal(ival_A.asfreq('Min', 'S'), ival_A_to_T_start)
+        assert_equal(ival_A.asfreq('Min', 'E'), ival_A_to_T_end)
+        assert_equal(ival_A.asfreq('S', 'S'), ival_A_to_S_start)
+        assert_equal(ival_A.asfreq('S', 'E'), ival_A_to_S_end)
+
+        assert_equal(ival_AJAN.asfreq('D', 'S'), ival_AJAN_to_D_start)
+        assert_equal(ival_AJAN.asfreq('D', 'E'), ival_AJAN_to_D_end)
+
+        assert_equal(ival_AJUN.asfreq('D', 'S'), ival_AJUN_to_D_start)
+        assert_equal(ival_AJUN.asfreq('D', 'E'), ival_AJUN_to_D_end)
+
+        assert_equal(ival_ANOV.asfreq('D', 'S'), ival_ANOV_to_D_start)
+        assert_equal(ival_ANOV.asfreq('D', 'E'), ival_ANOV_to_D_end)
+
+        assert_equal(ival_A.asfreq('A'), ival_A)
+
+
+    def test_conv_quarterly(self):
+        # frequency conversion tests: from Quarterly Frequency
+
+        ival_Q = Period(freq='Q', year=2007, quarter=1)
+        ival_Q_end_of_year = Period(freq='Q', year=2007, quarter=4)
+
+        ival_QEJAN = Period(freq="Q-JAN", year=2007, quarter=1)
+        ival_QEJUN = Period(freq="Q-JUN", year=2007, quarter=1)
+
+        ival_Q_to_A = Period(freq='A', year=2007)
+        ival_Q_to_M_start = Period(freq='M', year=2007, month=1)
+        ival_Q_to_M_end = Period(freq='M', year=2007, month=3)
+        ival_Q_to_W_start = Period(freq='WK', year=2007, month=1, day=1)
+        ival_Q_to_W_end = Period(freq='WK', year=2007, month=3, day=31)
+        ival_Q_to_B_start = Period(freq='B', year=2007, month=1, day=1)
+        ival_Q_to_B_end = Period(freq='B', year=2007, month=3, day=30)
+        ival_Q_to_D_start = Period(freq='D', year=2007, month=1, day=1)
+        ival_Q_to_D_end = Period(freq='D', year=2007, month=3, day=31)
+        ival_Q_to_H_start = Period(freq='H', year=2007, month=1, day=1,
+                                    hour=0)
+        ival_Q_to_H_end = Period(freq='H', year=2007, month=3, day=31,
+                                    hour=23)
+        ival_Q_to_T_start = Period(freq='Min', year=2007, month=1, day=1,
+                                    hour=0, minute=0)
+        ival_Q_to_T_end = Period(freq='Min', year=2007, month=3, day=31,
+                                    hour=23, minute=59)
+        ival_Q_to_S_start = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=0, minute=0, second=0)
+        ival_Q_to_S_end = Period(freq='S', year=2007, month=3, day=31,
+                                    hour=23, minute=59, second=59)
+
+        ival_QEJAN_to_D_start = Period(freq='D', year=2006, month=2, day=1)
+        ival_QEJAN_to_D_end = Period(freq='D', year=2006, month=4, day=30)
+
+        ival_QEJUN_to_D_start = Period(freq='D', year=2006, month=7, day=1)
+        ival_QEJUN_to_D_end = Period(freq='D', year=2006, month=9, day=30)
+
+        assert_equal(ival_Q.asfreq('A'), ival_Q_to_A)
+        assert_equal(ival_Q_end_of_year.asfreq('A'), ival_Q_to_A)
+
+        assert_equal(ival_Q.asfreq('M', 'S'), ival_Q_to_M_start)
+        assert_equal(ival_Q.asfreq('M', 'E'), ival_Q_to_M_end)
+        assert_equal(ival_Q.asfreq('WK', 'S'), ival_Q_to_W_start)
+        assert_equal(ival_Q.asfreq('WK', 'E'), ival_Q_to_W_end)
+        assert_equal(ival_Q.asfreq('B', 'S'), ival_Q_to_B_start)
+        assert_equal(ival_Q.asfreq('B', 'E'), ival_Q_to_B_end)
+        assert_equal(ival_Q.asfreq('D', 'S'), ival_Q_to_D_start)
+        assert_equal(ival_Q.asfreq('D', 'E'), ival_Q_to_D_end)
+        assert_equal(ival_Q.asfreq('H', 'S'), ival_Q_to_H_start)
+        assert_equal(ival_Q.asfreq('H', 'E'), ival_Q_to_H_end)
+        assert_equal(ival_Q.asfreq('Min', 'S'), ival_Q_to_T_start)
+        assert_equal(ival_Q.asfreq('Min', 'E'), ival_Q_to_T_end)
+        assert_equal(ival_Q.asfreq('S', 'S'), ival_Q_to_S_start)
+        assert_equal(ival_Q.asfreq('S', 'E'), ival_Q_to_S_end)
+
+        assert_equal(ival_QEJAN.asfreq('D', 'S'), ival_QEJAN_to_D_start)
+        assert_equal(ival_QEJAN.asfreq('D', 'E'), ival_QEJAN_to_D_end)
+        assert_equal(ival_QEJUN.asfreq('D', 'S'), ival_QEJUN_to_D_start)
+        assert_equal(ival_QEJUN.asfreq('D', 'E'), ival_QEJUN_to_D_end)
+
+        assert_equal(ival_Q.asfreq('Q'), ival_Q)
+
+
+    def test_conv_monthly(self):
+        # frequency conversion tests: from Monthly Frequency
+
+        ival_M = Period(freq='M', year=2007, month=1)
+        ival_M_end_of_year = Period(freq='M', year=2007, month=12)
+        ival_M_end_of_quarter = Period(freq='M', year=2007, month=3)
+        ival_M_to_A = Period(freq='A', year=2007)
+        ival_M_to_Q = Period(freq='Q', year=2007, quarter=1)
+        ival_M_to_W_start = Period(freq='WK', year=2007, month=1, day=1)
+        ival_M_to_W_end = Period(freq='WK', year=2007, month=1, day=31)
+        ival_M_to_B_start = Period(freq='B', year=2007, month=1, day=1)
+        ival_M_to_B_end = Period(freq='B', year=2007, month=1, day=31)
+        ival_M_to_D_start = Period(freq='D', year=2007, month=1, day=1)
+        ival_M_to_D_end = Period(freq='D', year=2007, month=1, day=31)
+        ival_M_to_H_start = Period(freq='H', year=2007, month=1, day=1,
+                                    hour=0)
+        ival_M_to_H_end = Period(freq='H', year=2007, month=1, day=31,
+                                    hour=23)
+        ival_M_to_T_start = Period(freq='Min', year=2007, month=1, day=1,
+                                    hour=0, minute=0)
+        ival_M_to_T_end = Period(freq='Min', year=2007, month=1, day=31,
+                                    hour=23, minute=59)
+        ival_M_to_S_start = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=0, minute=0, second=0)
+        ival_M_to_S_end = Period(freq='S', year=2007, month=1, day=31,
+                                    hour=23, minute=59, second=59)
+
+        assert_equal(ival_M.asfreq('A'), ival_M_to_A)
+        assert_equal(ival_M_end_of_year.asfreq('A'), ival_M_to_A)
+        assert_equal(ival_M.asfreq('Q'), ival_M_to_Q)
+        assert_equal(ival_M_end_of_quarter.asfreq('Q'), ival_M_to_Q)
+
+        assert_equal(ival_M.asfreq('WK', 'S'), ival_M_to_W_start)
+        assert_equal(ival_M.asfreq('WK', 'E'), ival_M_to_W_end)
+        assert_equal(ival_M.asfreq('B', 'S'), ival_M_to_B_start)
+        assert_equal(ival_M.asfreq('B', 'E'), ival_M_to_B_end)
+        assert_equal(ival_M.asfreq('D', 'S'), ival_M_to_D_start)
+        assert_equal(ival_M.asfreq('D', 'E'), ival_M_to_D_end)
+        assert_equal(ival_M.asfreq('H', 'S'), ival_M_to_H_start)
+        assert_equal(ival_M.asfreq('H', 'E'), ival_M_to_H_end)
+        assert_equal(ival_M.asfreq('Min', 'S'), ival_M_to_T_start)
+        assert_equal(ival_M.asfreq('Min', 'E'), ival_M_to_T_end)
+        assert_equal(ival_M.asfreq('S', 'S'), ival_M_to_S_start)
+        assert_equal(ival_M.asfreq('S', 'E'), ival_M_to_S_end)
+
+        assert_equal(ival_M.asfreq('M'), ival_M)
+
+
+    def test_conv_weekly(self):
+        # frequency conversion tests: from Weekly Frequency
+
+        ival_W = Period(freq='WK', year=2007, month=1, day=1)
+
+        ival_WSUN = Period(freq='WK', year=2007, month=1, day=7)
+        ival_WSAT = Period(freq='WK-SAT', year=2007, month=1, day=6)
+        ival_WFRI = Period(freq='WK-FRI', year=2007, month=1, day=5)
+        ival_WTHU = Period(freq='WK-THU', year=2007, month=1, day=4)
+        ival_WWED = Period(freq='WK-WED', year=2007, month=1, day=3)
+        ival_WTUE = Period(freq='WK-TUE', year=2007, month=1, day=2)
+        ival_WMON = Period(freq='WK-MON', year=2007, month=1, day=1)
+
+        ival_WSUN_to_D_start = Period(freq='D', year=2007, month=1, day=1)
+        ival_WSUN_to_D_end = Period(freq='D', year=2007, month=1, day=7)
+        ival_WSAT_to_D_start = Period(freq='D', year=2006, month=12, day=31)
+        ival_WSAT_to_D_end = Period(freq='D', year=2007, month=1, day=6)
+        ival_WFRI_to_D_start = Period(freq='D', year=2006, month=12, day=30)
+        ival_WFRI_to_D_end = Period(freq='D', year=2007, month=1, day=5)
+        ival_WTHU_to_D_start = Period(freq='D', year=2006, month=12, day=29)
+        ival_WTHU_to_D_end = Period(freq='D', year=2007, month=1, day=4)
+        ival_WWED_to_D_start = Period(freq='D', year=2006, month=12, day=28)
+        ival_WWED_to_D_end = Period(freq='D', year=2007, month=1, day=3)
+        ival_WTUE_to_D_start = Period(freq='D', year=2006, month=12, day=27)
+        ival_WTUE_to_D_end = Period(freq='D', year=2007, month=1, day=2)
+        ival_WMON_to_D_start = Period(freq='D', year=2006, month=12, day=26)
+        ival_WMON_to_D_end = Period(freq='D', year=2007, month=1, day=1)
+
+        ival_W_end_of_year = Period(freq='WK', year=2007, month=12, day=31)
+        ival_W_end_of_quarter = Period(freq='WK', year=2007, month=3, day=31)
+        ival_W_end_of_month = Period(freq='WK', year=2007, month=1, day=31)
+        ival_W_to_A = Period(freq='A', year=2007)
+        ival_W_to_Q = Period(freq='Q', year=2007, quarter=1)
+        ival_W_to_M = Period(freq='M', year=2007, month=1)
+
+        if Period(freq='D', year=2007, month=12, day=31).weekday == 6:
+            ival_W_to_A_end_of_year = Period(freq='A', year=2007)
+        else:
+            ival_W_to_A_end_of_year = Period(freq='A', year=2008)
+
+        if Period(freq='D', year=2007, month=3, day=31).weekday == 6:
+            ival_W_to_Q_end_of_quarter = Period(freq='Q', year=2007,
+                                                  quarter=1)
+        else:
+            ival_W_to_Q_end_of_quarter = Period(freq='Q', year=2007,
+                                                  quarter=2)
+
+        if Period(freq='D', year=2007, month=1, day=31).weekday == 6:
+            ival_W_to_M_end_of_month = Period(freq='M', year=2007, month=1)
+        else:
+            ival_W_to_M_end_of_month = Period(freq='M', year=2007, month=2)
+
+        ival_W_to_B_start = Period(freq='B', year=2007, month=1, day=1)
+        ival_W_to_B_end = Period(freq='B', year=2007, month=1, day=5)
+        ival_W_to_D_start = Period(freq='D', year=2007, month=1, day=1)
+        ival_W_to_D_end = Period(freq='D', year=2007, month=1, day=7)
+        ival_W_to_H_start = Period(freq='H', year=2007, month=1, day=1,
+                                    hour=0)
+        ival_W_to_H_end = Period(freq='H', year=2007, month=1, day=7,
+                                    hour=23)
+        ival_W_to_T_start = Period(freq='Min', year=2007, month=1, day=1,
+                                    hour=0, minute=0)
+        ival_W_to_T_end = Period(freq='Min', year=2007, month=1, day=7,
+                                    hour=23, minute=59)
+        ival_W_to_S_start = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=0, minute=0, second=0)
+        ival_W_to_S_end = Period(freq='S', year=2007, month=1, day=7,
+                                    hour=23, minute=59, second=59)
+
+        assert_equal(ival_W.asfreq('A'), ival_W_to_A)
+        assert_equal(ival_W_end_of_year.asfreq('A'),
+                     ival_W_to_A_end_of_year)
+        assert_equal(ival_W.asfreq('Q'), ival_W_to_Q)
+        assert_equal(ival_W_end_of_quarter.asfreq('Q'),
+                     ival_W_to_Q_end_of_quarter)
+        assert_equal(ival_W.asfreq('M'), ival_W_to_M)
+        assert_equal(ival_W_end_of_month.asfreq('M'),
+                     ival_W_to_M_end_of_month)
+
+        assert_equal(ival_W.asfreq('B', 'S'), ival_W_to_B_start)
+        assert_equal(ival_W.asfreq('B', 'E'), ival_W_to_B_end)
+
+        assert_equal(ival_W.asfreq('D', 'S'), ival_W_to_D_start)
+        assert_equal(ival_W.asfreq('D', 'E'), ival_W_to_D_end)
+
+        assert_equal(ival_WSUN.asfreq('D', 'S'), ival_WSUN_to_D_start)
+        assert_equal(ival_WSUN.asfreq('D', 'E'), ival_WSUN_to_D_end)
+        assert_equal(ival_WSAT.asfreq('D', 'S'), ival_WSAT_to_D_start)
+        assert_equal(ival_WSAT.asfreq('D', 'E'), ival_WSAT_to_D_end)
+        assert_equal(ival_WFRI.asfreq('D', 'S'), ival_WFRI_to_D_start)
+        assert_equal(ival_WFRI.asfreq('D', 'E'), ival_WFRI_to_D_end)
+        assert_equal(ival_WTHU.asfreq('D', 'S'), ival_WTHU_to_D_start)
+        assert_equal(ival_WTHU.asfreq('D', 'E'), ival_WTHU_to_D_end)
+        assert_equal(ival_WWED.asfreq('D', 'S'), ival_WWED_to_D_start)
+        assert_equal(ival_WWED.asfreq('D', 'E'), ival_WWED_to_D_end)
+        assert_equal(ival_WTUE.asfreq('D', 'S'), ival_WTUE_to_D_start)
+        assert_equal(ival_WTUE.asfreq('D', 'E'), ival_WTUE_to_D_end)
+        assert_equal(ival_WMON.asfreq('D', 'S'), ival_WMON_to_D_start)
+        assert_equal(ival_WMON.asfreq('D', 'E'), ival_WMON_to_D_end)
+
+        assert_equal(ival_W.asfreq('H', 'S'), ival_W_to_H_start)
+        assert_equal(ival_W.asfreq('H', 'E'), ival_W_to_H_end)
+        assert_equal(ival_W.asfreq('Min', 'S'), ival_W_to_T_start)
+        assert_equal(ival_W.asfreq('Min', 'E'), ival_W_to_T_end)
+        assert_equal(ival_W.asfreq('S', 'S'), ival_W_to_S_start)
+        assert_equal(ival_W.asfreq('S', 'E'), ival_W_to_S_end)
+
+        assert_equal(ival_W.asfreq('WK'), ival_W)
+
+
+    def test_conv_business(self):
+        # frequency conversion tests: from Business Frequency"
+
+        ival_B = Period(freq='B', year=2007, month=1, day=1)
+        ival_B_end_of_year = Period(freq='B', year=2007, month=12, day=31)
+        ival_B_end_of_quarter = Period(freq='B', year=2007, month=3, day=30)
+        ival_B_end_of_month = Period(freq='B', year=2007, month=1, day=31)
+        ival_B_end_of_week = Period(freq='B', year=2007, month=1, day=5)
+
+        ival_B_to_A = Period(freq='A', year=2007)
+        ival_B_to_Q = Period(freq='Q', year=2007, quarter=1)
+        ival_B_to_M = Period(freq='M', year=2007, month=1)
+        ival_B_to_W = Period(freq='WK', year=2007, month=1, day=7)
+        ival_B_to_D = Period(freq='D', year=2007, month=1, day=1)
+        ival_B_to_H_start = Period(freq='H', year=2007, month=1, day=1,
+                                    hour=0)
+        ival_B_to_H_end = Period(freq='H', year=2007, month=1, day=1,
+                                    hour=23)
+        ival_B_to_T_start = Period(freq='Min', year=2007, month=1, day=1,
+                                    hour=0, minute=0)
+        ival_B_to_T_end = Period(freq='Min', year=2007, month=1, day=1,
+                                    hour=23, minute=59)
+        ival_B_to_S_start = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=0, minute=0, second=0)
+        ival_B_to_S_end = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=23, minute=59, second=59)
+
+        assert_equal(ival_B.asfreq('A'), ival_B_to_A)
+        assert_equal(ival_B_end_of_year.asfreq('A'), ival_B_to_A)
+        assert_equal(ival_B.asfreq('Q'), ival_B_to_Q)
+        assert_equal(ival_B_end_of_quarter.asfreq('Q'), ival_B_to_Q)
+        assert_equal(ival_B.asfreq('M'), ival_B_to_M)
+        assert_equal(ival_B_end_of_month.asfreq('M'), ival_B_to_M)
+        assert_equal(ival_B.asfreq('WK'), ival_B_to_W)
+        assert_equal(ival_B_end_of_week.asfreq('WK'), ival_B_to_W)
+
+        assert_equal(ival_B.asfreq('D'), ival_B_to_D)
+
+        assert_equal(ival_B.asfreq('H', 'S'), ival_B_to_H_start)
+        assert_equal(ival_B.asfreq('H', 'E'), ival_B_to_H_end)
+        assert_equal(ival_B.asfreq('Min', 'S'), ival_B_to_T_start)
+        assert_equal(ival_B.asfreq('Min', 'E'), ival_B_to_T_end)
+        assert_equal(ival_B.asfreq('S', 'S'), ival_B_to_S_start)
+        assert_equal(ival_B.asfreq('S', 'E'), ival_B_to_S_end)
+
+        assert_equal(ival_B.asfreq('B'), ival_B)
+
+
+    def test_conv_daily(self):
+        # frequency conversion tests: from Business Frequency"
+
+        ival_D = Period(freq='D', year=2007, month=1, day=1)
+        ival_D_end_of_year = Period(freq='D', year=2007, month=12, day=31)
+        ival_D_end_of_quarter = Period(freq='D', year=2007, month=3, day=31)
+        ival_D_end_of_month = Period(freq='D', year=2007, month=1, day=31)
+        ival_D_end_of_week = Period(freq='D', year=2007, month=1, day=7)
+
+        ival_D_friday = Period(freq='D', year=2007, month=1, day=5)
+        ival_D_saturday = Period(freq='D', year=2007, month=1, day=6)
+        ival_D_sunday = Period(freq='D', year=2007, month=1, day=7)
+        ival_D_monday = Period(freq='D', year=2007, month=1, day=8)
+
+        ival_B_friday = Period(freq='B', year=2007, month=1, day=5)
+        ival_B_monday = Period(freq='B', year=2007, month=1, day=8)
+
+        ival_D_to_A = Period(freq='A', year=2007)
+
+        ival_Deoq_to_AJAN = Period(freq='A-JAN', year=2008)
+        ival_Deoq_to_AJUN = Period(freq='A-JUN', year=2007)
+        ival_Deoq_to_ADEC = Period(freq='A-DEC', year=2007)
+
+        ival_D_to_QEJAN = Period(freq="Q-JAN", year=2007, quarter=4)
+        ival_D_to_QEJUN = Period(freq="Q-JUN", year=2007, quarter=3)
+        ival_D_to_QEDEC = Period(freq="Q-DEC", year=2007, quarter=1)
+
+        ival_D_to_M = Period(freq='M', year=2007, month=1)
+        ival_D_to_W = Period(freq='WK', year=2007, month=1, day=7)
+
+        ival_D_to_H_start = Period(freq='H', year=2007, month=1, day=1,
+                                    hour=0)
+        ival_D_to_H_end = Period(freq='H', year=2007, month=1, day=1,
+                                    hour=23)
+        ival_D_to_T_start = Period(freq='Min', year=2007, month=1, day=1,
+                                    hour=0, minute=0)
+        ival_D_to_T_end = Period(freq='Min', year=2007, month=1, day=1,
+                                    hour=23, minute=59)
+        ival_D_to_S_start = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=0, minute=0, second=0)
+        ival_D_to_S_end = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=23, minute=59, second=59)
+
+        assert_equal(ival_D.asfreq('A'), ival_D_to_A)
+
+        assert_equal(ival_D_end_of_quarter.asfreq('A-JAN'),
+                     ival_Deoq_to_AJAN)
+        assert_equal(ival_D_end_of_quarter.asfreq('A-JUN'),
+                     ival_Deoq_to_AJUN)
+        assert_equal(ival_D_end_of_quarter.asfreq('A-DEC'),
+                     ival_Deoq_to_ADEC)
+
+        assert_equal(ival_D_end_of_year.asfreq('A'), ival_D_to_A)
+        assert_equal(ival_D_end_of_quarter.asfreq('Q'), ival_D_to_QEDEC)
+        assert_equal(ival_D.asfreq("Q-JAN"), ival_D_to_QEJAN)
+        assert_equal(ival_D.asfreq("Q-JUN"), ival_D_to_QEJUN)
+        assert_equal(ival_D.asfreq("Q-DEC"), ival_D_to_QEDEC)
+        assert_equal(ival_D.asfreq('M'), ival_D_to_M)
+        assert_equal(ival_D_end_of_month.asfreq('M'), ival_D_to_M)
+        assert_equal(ival_D.asfreq('WK'), ival_D_to_W)
+        assert_equal(ival_D_end_of_week.asfreq('WK'), ival_D_to_W)
+
+        assert_equal(ival_D_friday.asfreq('B'), ival_B_friday)
+        assert_equal(ival_D_saturday.asfreq('B', 'S'), ival_B_friday)
+        assert_equal(ival_D_saturday.asfreq('B', 'E'), ival_B_monday)
+        assert_equal(ival_D_sunday.asfreq('B', 'S'), ival_B_friday)
+        assert_equal(ival_D_sunday.asfreq('B', 'E'), ival_B_monday)
+
+        assert_equal(ival_D.asfreq('H', 'S'), ival_D_to_H_start)
+        assert_equal(ival_D.asfreq('H', 'E'), ival_D_to_H_end)
+        assert_equal(ival_D.asfreq('Min', 'S'), ival_D_to_T_start)
+        assert_equal(ival_D.asfreq('Min', 'E'), ival_D_to_T_end)
+        assert_equal(ival_D.asfreq('S', 'S'), ival_D_to_S_start)
+        assert_equal(ival_D.asfreq('S', 'E'), ival_D_to_S_end)
+
+        assert_equal(ival_D.asfreq('D'), ival_D)
+
+    def test_conv_hourly(self):
+        # frequency conversion tests: from Hourly Frequency"
+
+        ival_H = Period(freq='H', year=2007, month=1, day=1, hour=0)
+        ival_H_end_of_year = Period(freq='H', year=2007, month=12, day=31,
+                                    hour=23)
+        ival_H_end_of_quarter = Period(freq='H', year=2007, month=3, day=31,
+                                        hour=23)
+        ival_H_end_of_month = Period(freq='H', year=2007, month=1, day=31,
+                                    hour=23)
+        ival_H_end_of_week = Period(freq='H', year=2007, month=1, day=7,
+                                    hour=23)
+        ival_H_end_of_day = Period(freq='H', year=2007, month=1, day=1,
+                                    hour=23)
+        ival_H_end_of_bus = Period(freq='H', year=2007, month=1, day=1,
+                                    hour=23)
+
+        ival_H_to_A = Period(freq='A', year=2007)
+        ival_H_to_Q = Period(freq='Q', year=2007, quarter=1)
+        ival_H_to_M = Period(freq='M', year=2007, month=1)
+        ival_H_to_W = Period(freq='WK', year=2007, month=1, day=7)
+        ival_H_to_D = Period(freq='D', year=2007, month=1, day=1)
+        ival_H_to_B = Period(freq='B', year=2007, month=1, day=1)
+
+        ival_H_to_T_start = Period(freq='Min', year=2007, month=1, day=1,
+                                    hour=0, minute=0)
+        ival_H_to_T_end = Period(freq='Min', year=2007, month=1, day=1,
+                                    hour=0, minute=59)
+        ival_H_to_S_start = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=0, minute=0, second=0)
+        ival_H_to_S_end = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=0, minute=59, second=59)
+
+        assert_equal(ival_H.asfreq('A'), ival_H_to_A)
+        assert_equal(ival_H_end_of_year.asfreq('A'), ival_H_to_A)
+        assert_equal(ival_H.asfreq('Q'), ival_H_to_Q)
+        assert_equal(ival_H_end_of_quarter.asfreq('Q'), ival_H_to_Q)
+        assert_equal(ival_H.asfreq('M'), ival_H_to_M)
+        assert_equal(ival_H_end_of_month.asfreq('M'), ival_H_to_M)
+        assert_equal(ival_H.asfreq('WK'), ival_H_to_W)
+        assert_equal(ival_H_end_of_week.asfreq('WK'), ival_H_to_W)
+        assert_equal(ival_H.asfreq('D'), ival_H_to_D)
+        assert_equal(ival_H_end_of_day.asfreq('D'), ival_H_to_D)
+        assert_equal(ival_H.asfreq('B'), ival_H_to_B)
+        assert_equal(ival_H_end_of_bus.asfreq('B'), ival_H_to_B)
+
+        assert_equal(ival_H.asfreq('Min', 'S'), ival_H_to_T_start)
+        assert_equal(ival_H.asfreq('Min', 'E'), ival_H_to_T_end)
+        assert_equal(ival_H.asfreq('S', 'S'), ival_H_to_S_start)
+        assert_equal(ival_H.asfreq('S', 'E'), ival_H_to_S_end)
+
+        assert_equal(ival_H.asfreq('H'), ival_H)
+
+    def test_conv_minutely(self):
+        # frequency conversion tests: from Minutely Frequency"
+
+        ival_T = Period(freq='Min', year=2007, month=1, day=1,
+                        hour=0, minute=0)
+        ival_T_end_of_year = Period(freq='Min', year=2007, month=12, day=31,
+                                    hour=23, minute=59)
+        ival_T_end_of_quarter = Period(freq='Min', year=2007, month=3, day=31,
+                                        hour=23, minute=59)
+        ival_T_end_of_month = Period(freq='Min', year=2007, month=1, day=31,
+                                    hour=23, minute=59)
+        ival_T_end_of_week = Period(freq='Min', year=2007, month=1, day=7,
+                                    hour=23, minute=59)
+        ival_T_end_of_day = Period(freq='Min', year=2007, month=1, day=1,
+                                    hour=23, minute=59)
+        ival_T_end_of_bus = Period(freq='Min', year=2007, month=1, day=1,
+                                    hour=23, minute=59)
+        ival_T_end_of_hour = Period(freq='Min', year=2007, month=1, day=1,
+                                    hour=0, minute=59)
+
+        ival_T_to_A = Period(freq='A', year=2007)
+        ival_T_to_Q = Period(freq='Q', year=2007, quarter=1)
+        ival_T_to_M = Period(freq='M', year=2007, month=1)
+        ival_T_to_W = Period(freq='WK', year=2007, month=1, day=7)
+        ival_T_to_D = Period(freq='D', year=2007, month=1, day=1)
+        ival_T_to_B = Period(freq='B', year=2007, month=1, day=1)
+        ival_T_to_H = Period(freq='H', year=2007, month=1, day=1, hour=0)
+
+        ival_T_to_S_start = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=0, minute=0, second=0)
+        ival_T_to_S_end = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=0, minute=0, second=59)
+
+        assert_equal(ival_T.asfreq('A'), ival_T_to_A)
+        assert_equal(ival_T_end_of_year.asfreq('A'), ival_T_to_A)
+        assert_equal(ival_T.asfreq('Q'), ival_T_to_Q)
+        assert_equal(ival_T_end_of_quarter.asfreq('Q'), ival_T_to_Q)
+        assert_equal(ival_T.asfreq('M'), ival_T_to_M)
+        assert_equal(ival_T_end_of_month.asfreq('M'), ival_T_to_M)
+        assert_equal(ival_T.asfreq('WK'), ival_T_to_W)
+        assert_equal(ival_T_end_of_week.asfreq('WK'), ival_T_to_W)
+        assert_equal(ival_T.asfreq('D'), ival_T_to_D)
+        assert_equal(ival_T_end_of_day.asfreq('D'), ival_T_to_D)
+        assert_equal(ival_T.asfreq('B'), ival_T_to_B)
+        assert_equal(ival_T_end_of_bus.asfreq('B'), ival_T_to_B)
+        assert_equal(ival_T.asfreq('H'), ival_T_to_H)
+        assert_equal(ival_T_end_of_hour.asfreq('H'), ival_T_to_H)
+
+        assert_equal(ival_T.asfreq('S', 'S'), ival_T_to_S_start)
+        assert_equal(ival_T.asfreq('S', 'E'), ival_T_to_S_end)
+
+        assert_equal(ival_T.asfreq('Min'), ival_T)
+
+    def test_conv_secondly(self):
+        # frequency conversion tests: from Secondly Frequency"
+
+        ival_S = Period(freq='S', year=2007, month=1, day=1,
+                        hour=0, minute=0, second=0)
+        ival_S_end_of_year = Period(freq='S', year=2007, month=12, day=31,
+                                    hour=23, minute=59, second=59)
+        ival_S_end_of_quarter = Period(freq='S', year=2007, month=3, day=31,
+                                        hour=23, minute=59, second=59)
+        ival_S_end_of_month = Period(freq='S', year=2007, month=1, day=31,
+                                    hour=23, minute=59, second=59)
+        ival_S_end_of_week = Period(freq='S', year=2007, month=1, day=7,
+                                    hour=23, minute=59, second=59)
+        ival_S_end_of_day = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=23, minute=59, second=59)
+        ival_S_end_of_bus = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=23, minute=59, second=59)
+        ival_S_end_of_hour = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=0, minute=59, second=59)
+        ival_S_end_of_minute = Period(freq='S', year=2007, month=1, day=1,
+                                    hour=0, minute=0, second=59)
+
+        ival_S_to_A = Period(freq='A', year=2007)
+        ival_S_to_Q = Period(freq='Q', year=2007, quarter=1)
+        ival_S_to_M = Period(freq='M', year=2007, month=1)
+        ival_S_to_W = Period(freq='WK', year=2007, month=1, day=7)
+        ival_S_to_D = Period(freq='D', year=2007, month=1, day=1)
+        ival_S_to_B = Period(freq='B', year=2007, month=1, day=1)
+        ival_S_to_H = Period(freq='H', year=2007, month=1, day=1,
+                            hour=0)
+        ival_S_to_T = Period(freq='Min', year=2007, month=1, day=1,
+                            hour=0, minute=0)
+
+        assert_equal(ival_S.asfreq('A'), ival_S_to_A)
+        assert_equal(ival_S_end_of_year.asfreq('A'), ival_S_to_A)
+        assert_equal(ival_S.asfreq('Q'), ival_S_to_Q)
+        assert_equal(ival_S_end_of_quarter.asfreq('Q'), ival_S_to_Q)
+        assert_equal(ival_S.asfreq('M'), ival_S_to_M)
+        assert_equal(ival_S_end_of_month.asfreq('M'), ival_S_to_M)
+        assert_equal(ival_S.asfreq('WK'), ival_S_to_W)
+        assert_equal(ival_S_end_of_week.asfreq('WK'), ival_S_to_W)
+        assert_equal(ival_S.asfreq('D'), ival_S_to_D)
+        assert_equal(ival_S_end_of_day.asfreq('D'), ival_S_to_D)
+        assert_equal(ival_S.asfreq('B'), ival_S_to_B)
+        assert_equal(ival_S_end_of_bus.asfreq('B'), ival_S_to_B)
+        assert_equal(ival_S.asfreq('H'), ival_S_to_H)
+        assert_equal(ival_S_end_of_hour.asfreq('H'), ival_S_to_H)
+        assert_equal(ival_S.asfreq('Min'), ival_S_to_T)
+        assert_equal(ival_S_end_of_minute.asfreq('Min'), ival_S_to_T)
+
+        assert_equal(ival_S.asfreq('S'), ival_S)
+
+class TestPeriodIndex(TestCase):
+    def __init__(self, *args, **kwds):
+        TestCase.__init__(self, *args, **kwds)
+
+    def test_constructor(self):
+        ii = PeriodIndex(freq='A', start='1/1/2001', end='12/1/2009')
+        assert_equal(len(ii), 9)
+
+        ii = PeriodIndex(freq='Q', start='1/1/2001', end='12/1/2009')
+        assert_equal(len(ii), 4 * 9)
+
+        ii = PeriodIndex(freq='M', start='1/1/2001', end='12/1/2009')
+        assert_equal(len(ii), 12 * 9)
+
+        ii = PeriodIndex(freq='D', start='1/1/2001', end='12/31/2009')
+        assert_equal(len(ii), 365 * 9 + 2)
+
+        ii = PeriodIndex(freq='B', start='1/1/2001', end='12/31/2009')
+        assert_equal(len(ii), 261 * 9)
+
+        ii = PeriodIndex(freq='H', start='1/1/2001', end='12/31/2001 23:00')
+        assert_equal(len(ii), 365 * 24)
+
+        ii = PeriodIndex(freq='Min', start='1/1/2001', end='1/1/2001 23:59')
+        assert_equal(len(ii), 24 * 60)
+
+        ii = PeriodIndex(freq='S', start='1/1/2001', end='1/1/2001 23:59:59')
+        assert_equal(len(ii), 24 * 60 * 60)
+
+        start = Period('02-Apr-2005', 'B')
+        i1 = PeriodIndex(start=start, periods=20)
+        assert_equal(len(i1), 20)
+        assert_equal(i1.freq, start.freq)
+        assert_equal(i1[0], start)
+
+        end_intv = Period('2006-12-31', 'W')
+        i1 = PeriodIndex(end=end_intv, periods=10)
+        assert_equal(len(i1), 10)
+        assert_equal(i1.freq, end_intv.freq)
+        assert_equal(i1[-1], end_intv)
+
+        end_intv = Period('2006-12-31', '1w')
+        i2 = PeriodIndex(end=end_intv, periods=10)
+        assert_equal(len(i1), len(i2))
+        self.assert_((i1 == i2).all())
+        assert_equal(i1.freq, i2.freq)
+
+        end_intv = Period('2006-12-31', ('w', 1))
+        i2 = PeriodIndex(end=end_intv, periods=10)
+        assert_equal(len(i1), len(i2))
+        self.assert_((i1 == i2).all())
+        assert_equal(i1.freq, i2.freq)
+
+        try:
+            PeriodIndex(start=start, end=end_intv)
+            raise AssertionError('Cannot allow mixed freq for start and end')
+        except ValueError:
+            pass
+
+        end_intv = Period('2005-05-01', 'B')
+        i1 = PeriodIndex(start=start, end=end_intv)
+
+        try:
+            PeriodIndex(start=start)
+            raise AssertionError('Must specify periods if missing start or end')
+        except ValueError:
+            pass
+
+    def test_shift(self):
+        ii1 = PeriodIndex(freq='A', start='1/1/2001', end='12/1/2009')
+        ii2 = PeriodIndex(freq='A', start='1/1/2002', end='12/1/2010')
+        assert_equal(len(ii1), len(ii2))
+        assert_equal(ii1.shift(1).values, ii2.values)
+
+        ii1 = PeriodIndex(freq='A', start='1/1/2001', end='12/1/2009')
+        ii2 = PeriodIndex(freq='A', start='1/1/2000', end='12/1/2008')
+        assert_equal(len(ii1), len(ii2))
+        assert_equal(ii1.shift(-1).values, ii2.values)
+
+        ii1 = PeriodIndex(freq='M', start='1/1/2001', end='12/1/2009')
+        ii2 = PeriodIndex(freq='M', start='2/1/2001', end='1/1/2010')
+        assert_equal(len(ii1), len(ii2))
+        assert_equal(ii1.shift(1).values, ii2.values)
+
+        ii1 = PeriodIndex(freq='M', start='1/1/2001', end='12/1/2009')
+        ii2 = PeriodIndex(freq='M', start='12/1/2000', end='11/1/2009')
+        assert_equal(len(ii1), len(ii2))
+        assert_equal(ii1.shift(-1).values, ii2.values)
+
+        ii1 = PeriodIndex(freq='D', start='1/1/2001', end='12/1/2009')
+        ii2 = PeriodIndex(freq='D', start='1/2/2001', end='12/2/2009')
+        assert_equal(len(ii1), len(ii2))
+        assert_equal(ii1.shift(1).values, ii2.values)
+
+        ii1 = PeriodIndex(freq='D', start='1/1/2001', end='12/1/2009')
+        ii2 = PeriodIndex(freq='D', start='12/31/2000', end='11/30/2009')
+        assert_equal(len(ii1), len(ii2))
+        assert_equal(ii1.shift(-1).values, ii2.values)
+
+    def test_asfreq(self):
+        ii1 = PeriodIndex(freq='A', start='1/1/2001', end='1/1/2001')
+        ii2 = PeriodIndex(freq='Q', start='1/1/2001', end='1/1/2001')
+        ii3 = PeriodIndex(freq='M', start='1/1/2001', end='1/1/2001')
+        ii4 = PeriodIndex(freq='D', start='1/1/2001', end='1/1/2001')
+        ii5 = PeriodIndex(freq='H', start='1/1/2001', end='1/1/2001 00:00')
+        ii6 = PeriodIndex(freq='Min', start='1/1/2001', end='1/1/2001 00:00')
+        ii7 = PeriodIndex(freq='S', start='1/1/2001', end='1/1/2001 00:00:00')
+
+        self.assertEquals(ii1.asfreq('Q', 'S'), ii2)
+        self.assertEquals(ii1.asfreq('Q', 's'), ii2)
+        self.assertEquals(ii1.asfreq('M', 'start'), ii3)
+        self.assertEquals(ii1.asfreq('D', 'StarT'), ii4)
+        self.assertEquals(ii1.asfreq('H', 'beGIN'), ii5)
+        self.assertEquals(ii1.asfreq('Min', 'S'), ii6)
+        self.assertEquals(ii1.asfreq('S', 'S'), ii7)
+
+        self.assertEquals(ii2.asfreq('A', 'S'), ii1)
+        self.assertEquals(ii2.asfreq('M', 'S'), ii3)
+        self.assertEquals(ii2.asfreq('D', 'S'), ii4)
+        self.assertEquals(ii2.asfreq('H', 'S'), ii5)
+        self.assertEquals(ii2.asfreq('Min', 'S'), ii6)
+        self.assertEquals(ii2.asfreq('S', 'S'), ii7)
+
+        self.assertEquals(ii3.asfreq('A', 'S'), ii1)
+        self.assertEquals(ii3.asfreq('Q', 'S'), ii2)
+        self.assertEquals(ii3.asfreq('D', 'S'), ii4)
+        self.assertEquals(ii3.asfreq('H', 'S'), ii5)
+        self.assertEquals(ii3.asfreq('Min', 'S'), ii6)
+        self.assertEquals(ii3.asfreq('S', 'S'), ii7)
+
+        self.assertEquals(ii4.asfreq('A', 'S'), ii1)
+        self.assertEquals(ii4.asfreq('Q', 'S'), ii2)
+        self.assertEquals(ii4.asfreq('M', 'S'), ii3)
+        self.assertEquals(ii4.asfreq('H', 'S'), ii5)
+        self.assertEquals(ii4.asfreq('Min', 'S'), ii6)
+        self.assertEquals(ii4.asfreq('S', 'S'), ii7)
+
+        self.assertEquals(ii5.asfreq('A', 'S'), ii1)
+        self.assertEquals(ii5.asfreq('Q', 'S'), ii2)
+        self.assertEquals(ii5.asfreq('M', 'S'), ii3)
+        self.assertEquals(ii5.asfreq('D', 'S'), ii4)
+        self.assertEquals(ii5.asfreq('Min', 'S'), ii6)
+        self.assertEquals(ii5.asfreq('S', 'S'), ii7)
+
+        self.assertEquals(ii6.asfreq('A', 'S'), ii1)
+        self.assertEquals(ii6.asfreq('Q', 'S'), ii2)
+        self.assertEquals(ii6.asfreq('M', 'S'), ii3)
+        self.assertEquals(ii6.asfreq('D', 'S'), ii4)
+        self.assertEquals(ii6.asfreq('H', 'S'), ii5)
+        self.assertEquals(ii6.asfreq('S', 'S'), ii7)
+
+        self.assertEquals(ii7.asfreq('A', 'S'), ii1)
+        self.assertEquals(ii7.asfreq('Q', 'S'), ii2)
+        self.assertEquals(ii7.asfreq('M', 'S'), ii3)
+        self.assertEquals(ii7.asfreq('D', 'S'), ii4)
+        self.assertEquals(ii7.asfreq('H', 'S'), ii5)
+        self.assertEquals(ii7.asfreq('Min', 'S'), ii6)
+
+        #self.assertEquals(ii7.asfreq('A', 'E'), i_end)
+
+    def test_badinput(self):
+        self.assertRaises(datetools.DateParseError, Period, '1/1/-2000', 'A')
+        self.assertRaises(ValueError, Period, -2000, 'A')
+        self.assertRaises(ValueError, Period, 0, 'A')
+        self.assertRaises(ValueError, PeriodIndex, [-1, 0, 1], 'A')
+        self.assertRaises(ValueError, PeriodIndex, np.array([-1, 0, 1]), 'A')
+
+    def test_dti_to_period(self):
+        dti = DatetimeIndex(start='1/1/2005', end='12/1/2005', freq='M')
+        ii1 = dti.to_period()
+        ii2 = dti.to_period(freq='D')
+
+        self.assertEquals(ii1[0], Period('Jan 2005', freq='M'))
+        self.assertEquals(ii2[0], Period('1/31/2005', freq='D'))
+
+        self.assertEquals(ii1[-1], Period('Nov 2005', freq='M'))
+        self.assertEquals(ii2[-1], Period('11/30/2005', freq='D'))
+
+    def test_iindex_slice_index(self):
+        ii = PeriodIndex(start='1/1/10', end='12/31/12', freq='M')
+        s = Series(np.random.rand(len(ii)), index=ii)
+        res = s['2010']
+        exp = s[0:12]
+        assert_series_equal(res, exp)
+        res = s['2011']
+        exp = s[12:24]
+        assert_series_equal(res, exp)
+
+    def test_iindex_qaccess(self):
+        ii = PeriodIndex(['2Q05', '3Q05', '4Q05', '1Q06', '2Q06'], freq='Q')
+        s = Series(np.random.rand(len(ii)), index=ii).cumsum()
+        # Todo: fix these accessors!
+        self.assert_(s['05Q4'] == s[2])
+
+    def test_interval_dt64_round_trip(self):
+        dti = DatetimeIndex(['1/1/2002', '1/2/2002', '1/3/2002', '1/4/2002',
+                             '1/5/2002', '1/6/2002', '1/7/2002'], freq='B')
+        ii = dti.to_period()
+        self.assert_(ii.to_timestamp().equals(dti))
+
+        dti = DatetimeIndex(['1/1/2002', '1/2/2002', '1/3/2002', '1/4/2002',
+                             '1/5/2002', '1/6/2002', '1/7/2002'], freq='B')
+        ii = dti.to_period(freq='3H')
+        self.assert_(ii.to_timestamp().equals(dti))
+
+    def test_iindex_multiples(self):
+        ii = PeriodIndex(start='1/1/10', end='12/31/12', freq='2M')
+        self.assertEquals(ii[0], Period('1/1/10', '2M'))
+        self.assertEquals(ii[1], Period('3/1/10', '2M'))
+
+        self.assertEquals(ii[0].asfreq('6M'), ii[2].asfreq('6M'))
+        self.assertEquals(ii[0].asfreq('A'), ii[2].asfreq('A'))
+
+        self.assertEquals(ii[0].asfreq('M', how='S'),
+                          Period('Jan 2010', '1M'))
+        self.assertEquals(ii[0].asfreq('M', how='E'),
+                          Period('Feb 2010', '1M'))
+        self.assertEquals(ii[1].asfreq('M', how='S'),
+                          Period('Mar 2010', '1M'))
+
+        i = Period('1/1/2010 12:05:18', '5S')
+        self.assertEquals(i, Period('1/1/2010 12:05:15', '5S'))
+
+        i = Period('1/1/2010 12:05:18', '5S')
+        self.assertEquals(i.asfreq('1S', how='E'),
+                          Period('1/1/2010 12:05:19', '1S'))
+
+class TestMethods(TestCase):
+    "Base test class for MaskedArrays."
+
+    def __init__(self, *args, **kwds):
+        TestCase.__init__(self, *args, **kwds)
+
+    def test_add(self):
+        dt1 = Period(freq='D', year=2008, month=1, day=1)
+        dt2 = Period(freq='D', year=2008, month=1, day=2)
+        assert_equal(dt1 + 1, dt2)
+        #
+        self.assertRaises(ValueError, dt1.__add__, "str")
+        self.assertRaises(ValueError, dt1.__add__, dt2)
+
+###############################################################################
+#------------------------------------------------------------------------------
+
+if __name__ == '__main__':
+    import nose
+    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
+                   exit=False)
diff --git a/pandas/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
similarity index 100%
rename from pandas/tests/test_timeseries.py
rename to pandas/tseries/tests/test_timeseries.py
diff --git a/pandas/tseries/tests/test_tools.py b/pandas/tseries/tests/test_util.py
similarity index 96%
rename from pandas/tseries/tests/test_tools.py
rename to pandas/tseries/tests/test_util.py
index b828dbff1..38d812915 100644
--- a/pandas/tseries/tests/test_tools.py
+++ b/pandas/tseries/tests/test_util.py
@@ -6,7 +6,7 @@ import numpy as np
 from pandas import Series, date_range
 import pandas.util.testing as tm
 
-from pandas.tseries.tools import convert_to_annual, isleapyear
+from pandas.tseries.util import convert_to_annual, isleapyear
 
 class TestConvertAnnual(unittest.TestCase):
     """
diff --git a/pandas/tseries/tools.py b/pandas/tseries/tools.py
index ac665bb77..05e37d6d8 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/tseries/tools.py
@@ -1,85 +1,209 @@
-from pandas.core.frame import DataFrame
-import pandas.core.nanops as nanops
+from datetime import datetime, timedelta
+import re
+import sys
 
 import numpy as np
 
-def convert_to_annual(series, freq=None):
+import pandas._tseries as lib
+import pandas.core.common as com
+
+try:
+    import dateutil
+    from dateutil.parser import parser
+    from dateutil.relativedelta import relativedelta
+
+    # raise exception if dateutil 2.0 install on 2.x platform
+    if (sys.version_info[0] == 2 and
+        dateutil.__version__ == '2.0'):  # pragma: no cover
+        raise Exception('dateutil 2.0 incompatible with Python 2.x, you must '
+                        'install version 1.5!')
+except ImportError: # pragma: no cover
+    print 'Please install python-dateutil via easy_install or some method!'
+    raise # otherwise a 2nd import won't show the message
+
+
+def _infer_tzinfo(start, end):
+    def _infer(a, b):
+        tz = a.tzinfo
+        if b and b.tzinfo:
+            assert(tz == b.tzinfo)
+        return tz
+    tz = None
+    if start is not None:
+        tz = _infer(start, end)
+    elif end is not None:
+        tz = _infer(end, start)
+    return tz
+
+
+def _figure_out_timezone(start, end, tzinfo):
+    inferred_tz = _infer_tzinfo(start, end)
+    tz = inferred_tz
+    if inferred_tz is None and tzinfo is not None:
+        tz = tzinfo
+    elif tzinfo is not None:
+        assert(inferred_tz == tzinfo)
+        # make tz naive for now
+
+    if isinstance(tz, (str, unicode)):
+        import pytz
+        tz = pytz.timezone(tz)
+
+    start = start if start is None else start.replace(tzinfo=None)
+    end = end if end is None else end.replace(tzinfo=None)
+
+    return start, end, tz
+
+
+def to_datetime(arg, errors='ignore', dayfirst=False):
     """
-    Group a series by years, taking leap years into account.
-
-    The output has as many rows as distinct years in the original series,
-    and as many columns as the length of a leap year in the units corresponding
-    to the original frequency (366 for daily frequency, 366*24 for hourly...).
-    The fist column of the output corresponds to Jan. 1st, 00:00:00,
-    while the last column corresponds to Dec, 31st, 23:59:59.
-    Entries corresponding to Feb. 29th are masked for non-leap years.
-
-    For example, if the initial series has a daily frequency, the 59th column
-    of the output always corresponds to Feb. 28th, the 61st column to Mar. 1st,
-    and the 60th column is masked for non-leap years.
-    With a hourly initial frequency, the (59*24)th column of the output always
-    correspond to Feb. 28th 23:00, the (61*24)th column to Mar. 1st, 00:00, and
-    the 24 columns between (59*24) and (61*24) are masked.
-
-    If the original frequency is less than daily, the output is equivalent to
-    ``series.convert('A', func=None)``.
+    Convert argument to datetime
 
     Parameters
     ----------
-    series : TimeSeries
-    freq : string or None, default None
-
+    arg : string, datetime, array of strings (with possible NAs)
+    errors : {'ignore', 'raise'}, default 'ignore'
+        Errors are ignored by default (values left untouched)
 
     Returns
     -------
-    annual : DataFrame
+    ret : datetime if parsing succeeded
     """
-    index = series.index
-    year = index.year
-    years = nanops.unique1d(year)
-
-    if freq is not None:
-        freq = freq.upper()
-
-    if freq == 'D':
-        width = 366
-        offset = index.dayofyear - 1
-
-        # adjust for leap year
-        offset[(-isleapyear(year)) & (offset >= 59)] += 1
-
-        columns = range(1, 367)
-        # todo: strings like 1/1, 1/25, etc.?
-    elif freq in ('M', 'BM'):
-        width = 12
-        offset = index.month - 1
-        columns = range(1, 13)
-    else:
-        raise NotImplementedError(freq)
-
-    flat_index = (year - years.min()) * width + offset
-
-    values = np.empty((len(years), width), dtype=series.dtype)
-
-    if not np.issubdtype(series.dtype, np.integer):
-        values.fill(np.nan)
-    else:
-        raise Exception('need to upcast')
-
-    values.put(flat_index, series.values)
-
-    return DataFrame(values, index=years, columns=columns)
-
-def isleapyear(year):
+    from pandas.core.series import Series
+    if arg is None:
+        return arg
+    elif isinstance(arg, datetime):
+        return arg
+    elif isinstance(arg, Series):
+        values = lib.string_to_datetime(com._ensure_object(arg.values),
+                                        raise_=errors == 'raise',
+                                        dayfirst=dayfirst)
+        return Series(values, index=arg.index, name=arg.name)
+    elif isinstance(arg, (np.ndarray, list)):
+        if isinstance(arg, list):
+            arg = np.array(arg, dtype='O')
+        return lib.string_to_datetime(com._ensure_object(arg),
+                                      raise_=errors == 'raise',
+                                      dayfirst=dayfirst)
+
+    try:
+        if not arg:
+            return arg
+        return _dtparser.parse(arg, dayfirst=dayfirst)
+    except Exception:
+        if errors == 'raise':
+            raise
+        return arg
+
+
+class DateParseError(ValueError):
+    pass
+
+
+_dtparser = parser()
+
+
+# patterns for quarters like '4Q2005', '05Q1'
+qpat1full = re.compile(r'(\d)Q(\d\d\d\d)')
+qpat2full = re.compile(r'(\d\d\d\d)Q(\d)')
+qpat1 = re.compile(r'(\d)Q(\d\d)')
+qpat2 = re.compile(r'(\d\d)Q(\d)')
+
+
+def parse_time_string(arg):
     """
-    Returns true if year is a leap year.
+    Try hard to parse datetime string, leveraging dateutil plus some extra
+    goodies like quarter recognition.
 
     Parameters
     ----------
-    year : integer / sequence
-        A given (list of) year(s).
+    arg : basestring
+
+    Returns
+    -------
+    datetime, datetime/dateutil.parser._result, str
     """
-    year = np.asarray(year)
-    return np.logical_or(year % 400 == 0,
-                         np.logical_and(year % 4 == 0, year % 100 > 0))
+    from pandas.core.format import print_config
+
+    if not isinstance(arg, basestring):
+        return arg
+
+    arg = arg.upper()
+    try:
+        default = datetime(1,1,1).replace(hour=0, minute=0,
+                                          second=0, microsecond=0)
+
+        # special handling for possibilities eg, 2Q2005, 2Q05, 2005Q1, 05Q1
+        if len(arg) in [4, 6]:
+            add_century = False
+            if len(arg) == 4:
+                add_century = True
+                qpats = [(qpat1, 1), (qpat2, 0)]
+            else:
+                qpats = [(qpat1full, 1), (qpat2full, 0)]
+
+            for pat, yfirst in qpats:
+                qparse = pat.match(arg)
+                if qparse is not None:
+                    if yfirst:
+                        yi, qi = 1, 2
+                    else:
+                        yi, qi = 2, 1
+                    q = int(qparse.group(yi))
+                    y_str = qparse.group(qi)
+                    y = int(y_str)
+                    if add_century:
+                        y += 2000
+                    ret = default.replace(year=y, month=(q-1)*3+1)
+                    return ret, ret, 'quarter'
+
+        dayfirst = print_config.date_dayfirst
+        yearfirst = print_config.date_yearfirst
+
+        parsed = _dtparser._parse(arg, dayfirst=dayfirst, yearfirst=yearfirst)
+        if parsed is None:
+            raise DateParseError("Could not parse %s" % arg)
+
+        repl = {}
+        reso = 'year'
+        stopped = False
+        for attr in ["year", "month", "day", "hour",
+                     "minute", "second", "microsecond"]:
+            can_be_zero = ['hour', 'minute', 'second', 'microsecond']
+            value = getattr(parsed, attr)
+            if value is not None and (value != 0 or attr in can_be_zero):
+                repl[attr] = value
+                if not stopped:
+                    reso = attr
+                else:
+                    raise DateParseError("Missing attribute before %s" % attr)
+            else:
+                stopped = True
+        ret = default.replace(**repl)
+        return ret, parsed, reso  # datetime, resolution
+    except Exception, e:
+        raise DateParseError(e)
+
+def normalize_date(dt):
+    if isinstance(dt, np.datetime64):
+        dt = lib.Timestamp(dt)
+    return dt.replace(hour=0, minute=0, second=0, microsecond=0)
+
+
+def format(dt):
+    """Returns date in YYYYMMDD format."""
+    return dt.strftime('%Y%m%d')
+
+OLE_TIME_ZERO = datetime(1899, 12, 30, 0, 0, 0)
+
+def ole2datetime(oledt):
+    """function for converting excel date to normal date format"""
+    val = float(oledt)
+
+    # Excel has a bug where it thinks the date 2/29/1900 exists
+    # we just reject any date before 3/1/1900.
+    if val < 61:
+        raise Exception("Value is outside of acceptable range: %s " % val)
+
+    return OLE_TIME_ZERO + timedelta(days=val)
 
diff --git a/pandas/tseries/util.py b/pandas/tseries/util.py
new file mode 100644
index 000000000..c3b4b8272
--- /dev/null
+++ b/pandas/tseries/util.py
@@ -0,0 +1,84 @@
+import numpy as np
+
+from pandas.core.frame import DataFrame
+import pandas.core.nanops as nanops
+
+def convert_to_annual(series, freq=None):
+    """
+    Group a series by years, taking leap years into account.
+
+    The output has as many rows as distinct years in the original series,
+    and as many columns as the length of a leap year in the units corresponding
+    to the original frequency (366 for daily frequency, 366*24 for hourly...).
+    The fist column of the output corresponds to Jan. 1st, 00:00:00,
+    while the last column corresponds to Dec, 31st, 23:59:59.
+    Entries corresponding to Feb. 29th are masked for non-leap years.
+
+    For example, if the initial series has a daily frequency, the 59th column
+    of the output always corresponds to Feb. 28th, the 61st column to Mar. 1st,
+    and the 60th column is masked for non-leap years.
+    With a hourly initial frequency, the (59*24)th column of the output always
+    correspond to Feb. 28th 23:00, the (61*24)th column to Mar. 1st, 00:00, and
+    the 24 columns between (59*24) and (61*24) are masked.
+
+    If the original frequency is less than daily, the output is equivalent to
+    ``series.convert('A', func=None)``.
+
+    Parameters
+    ----------
+    series : TimeSeries
+    freq : string or None, default None
+
+
+    Returns
+    -------
+    annual : DataFrame
+    """
+    index = series.index
+    year = index.year
+    years = nanops.unique1d(year)
+
+    if freq is not None:
+        freq = freq.upper()
+
+    if freq == 'D':
+        width = 366
+        offset = index.dayofyear - 1
+
+        # adjust for leap year
+        offset[(-isleapyear(year)) & (offset >= 59)] += 1
+
+        columns = range(1, 367)
+        # todo: strings like 1/1, 1/25, etc.?
+    elif freq in ('M', 'BM'):
+        width = 12
+        offset = index.month - 1
+        columns = range(1, 13)
+    else:
+        raise NotImplementedError(freq)
+
+    flat_index = (year - years.min()) * width + offset
+
+    values = np.empty((len(years), width), dtype=series.dtype)
+
+    if not np.issubdtype(series.dtype, np.integer):
+        values.fill(np.nan)
+    else:
+        raise Exception('need to upcast')
+
+    values.put(flat_index, series.values)
+
+    return DataFrame(values, index=years, columns=columns)
+
+def isleapyear(year):
+    """
+    Returns true if year is a leap year.
+
+    Parameters
+    ----------
+    year : integer / sequence
+        A given (list of) year(s).
+    """
+    year = np.asarray(year)
+    return np.logical_or(year % 400 == 0,
+                         np.logical_and(year % 4 == 0, year % 100 > 0))
diff --git a/pandas/util/terminal.py b/pandas/util/terminal.py
index c5b29f7f6..4278f35ba 100644
--- a/pandas/util/terminal.py
+++ b/pandas/util/terminal.py
@@ -12,6 +12,8 @@ It is mentioned in the stackoverflow response that this code works
 on linux, os x, windows and cygwin (windows).
 """
 
+import os
+
 __all__=['get_terminal_size']
 
 
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index 3135e65a0..50a3bdd65 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -19,11 +19,10 @@ import pandas.core.frame as frame
 import pandas.core.panel as panel
 
 from pandas import bdate_range
-from pandas.core.index import DatetimeIndex, IntervalIndex
+from pandas.tseries.index import DatetimeIndex
+from pandas.tseries.period import PeriodIndex
+from pandas.tseries.interval import IntervalIndex
 
-# to_reload = ['index', 'daterange', 'series', 'frame', 'matrix', 'panel']
-# for mod in to_reload:
-#     reload(locals()[mod])
 
 Index = index.Index
 Series = series.Series
@@ -210,16 +209,16 @@ def makeDateIndex(k):
     dr = bdate_range(dt, periods=k)
     return DatetimeIndex(dr)
 
-def makeIntervalIndex(k):
+def makePeriodIndex(k):
     dt = datetime(2000,1,1)
-    dr = IntervalIndex(start=dt, periods=k, freq='B')
+    dr = PeriodIndex(start=dt, periods=k, freq='B')
     return dr
 
 def makeTimeSeries():
     return Series(randn(N), index=makeDateIndex(N))
 
-def makeIntervalSeries():
-    return Series(randn(N), index=makeIntervalIndex(N))
+def makePeriodSeries():
+    return Series(randn(N), index=makePeriodIndex(N))
 
 def getTimeSeriesData():
     return dict((c, makeTimeSeries()) for c in getCols(K))
diff --git a/setup.py b/setup.py
index e1218755d..628710a1d 100755
--- a/setup.py
+++ b/setup.py
@@ -214,7 +214,7 @@ class CleanCommand(Command):
         self._clean_trees = []
         self._clean_exclude = ['np_datetime.c',
                                'np_datetime_strings.c',
-                               'skts.c']
+                               'period.c']
 
         for root, dirs, files in list(os.walk('pandas')):
             for f in files:
@@ -347,9 +347,9 @@ else:
 tseries_ext = Extension('pandas._tseries',
                         depends=tseries_depends + ['pandas/src/numpy_helper.h'],
                         sources=[srcpath('tseries', suffix=suffix),
+                                 'pandas/src/period.c',
                                  'pandas/src/np_datetime.c',
-                                 'pandas/src/np_datetime_strings.c',
-                                 'pandas/src/skts.c'],
+                                 'pandas/src/np_datetime_strings.c'],
                         include_dirs=[np.get_include()],
                         # pyrex_gdb=True,
                         # extra_compile_args=['-Wconversion']

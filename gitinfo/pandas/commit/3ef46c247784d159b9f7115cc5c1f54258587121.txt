commit 3ef46c247784d159b9f7115cc5c1f54258587121
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Apr 12 23:08:02 2010 +0000

    code rearrangement
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@157 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 2bcaa93dd..6ae596ce3 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -538,9 +538,8 @@ class DataFrame(Picklable, Groupable):
 
         return DataMatrix(self._series, index=self.index)
 
-    def toString(self, buffer=sys.stdout, verbose=False,
-                 columns=None, colSpace=15, nanRep='NaN',
-                 formatters=None, float_format=None):
+    def toString(self, buffer=sys.stdout, columns=None, colSpace=15,
+                 nanRep='NaN', formatters=None, float_format=None):
         """Output a tab-separated version of this DataFrame"""
         series = self._series
 
@@ -558,8 +557,6 @@ class DataFrame(Picklable, Groupable):
         else:
             idxSpace = max([len(str(idx)) for idx in self.index]) + 4
             head = _pfixed('', idxSpace)
-            if verbose:
-                colSpace = max([len(c) for c in columns]) + 4
 
             for h in columns:
                 head += _pfixed(h, colSpace)
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 492df57c7..cbbb4aa5b 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -208,185 +208,223 @@ class DataMatrix(DataFrame):
     def _constructor(self):
         return DataMatrix
 
-    def __getstate__(self):
-        if self.objects is not None:
-            objects = self.objects._matrix_state(pickle_index=False)
-        else:
-            objects = None
+    # Because of DataFrame property
+    values = None
 
-        state = self._matrix_state()
+#-------------------------------------------------------------------------------
+# DataMatrix-specific implementation of private API
 
-        return (state, objects)
+    def _join_on(self, other, on):
+        if len(other.index) == 0:
+            return self
 
-    def _matrix_state(self, pickle_index=True):
-        columns = _pickle_array(self.columns)
+        if on not in self:
+            raise Exception('%s column not contained in this frame!' % on)
 
-        if pickle_index:
-            index = _pickle_array(self.index)
+        fillVec, mask = tseries.getMergeVec(self[on],
+                                            other.index.indexMap)
+
+        tmpMatrix = other.values.take(fillVec, axis=0)
+        tmpMatrix[-mask] = NaN
+
+        seriesDict = dict((col, tmpMatrix[:, j])
+                           for j, col in enumerate(other.columns))
+
+        if getattr(other, 'objects'):
+            objects = other.objects
+
+            tmpMat = objects.values.take(fillVec, axis=0)
+            tmpMat[-mask] = NaN
+            objDict = dict((col, tmpMat[:, j])
+                           for j, col in enumerate(objects.columns))
+
+            seriesDict.update(objDict)
+
+        filledFrame = DataFrame(data=seriesDict, index=self.index)
+
+        return self.leftJoin(filledFrame)
+
+    def _reindex_index(self, index, method):
+        if index is self.index:
+            return self.copy()
+
+        if not isinstance(index, Index):
+            index = Index(index)
+
+        if len(self.index) == 0:
+            return DataMatrix(index=index, columns=self.columns)
+
+        fillVec, mask = tseries.getFillVec(self.index, index,
+                                           self.index.indexMap,
+                                           index.indexMap, method)
+
+        tmpMatrix = self.values.take(fillVec, axis=0)
+        if len(index) > 0:
+            tmpMatrix[-mask] = NaN
+
+        if self.objects is not None and len(self.objects.columns) > 0:
+            newObjects = self.objects.reindex(index)
         else:
-            index = None
+            newObjects = None
 
-        return self.values, index, columns
+        return DataMatrix(tmpMatrix, index=index,
+                          columns=self.columns,
+                          objects=newObjects)
 
-    def __setstate__(self, state):
-        (vals, idx, cols), object_state = state
+    def _reindex_columns(self, columns):
+        if len(columns) == 0:
+            return DataMatrix(index=self.index)
 
-        self.values = vals
-        self.index = _unpickle_array(idx)
-        self.columns = _unpickle_array(cols)
+        if not isinstance(columns, Index):
+            columns = Index(columns)
 
-        if object_state:
-            ovals, _, ocols = object_state
-            self.objects = DataMatrix(ovals,
-                                      index=self.index,
-                                      columns=_unpickle_array(ocols))
+        if self.objects is not None:
+            object_columns = columns.intersection(self.objects.columns)
+            columns = columns - object_columns
+
+            objects = self.objects._reindex_columns(object_columns)
         else:
-            self.objects = None
+            objects = None
 
-    # Because of DataFrame property
-    values = None
+        if len(columns) > 0 and len(self.columns) == 0:
+            return DataMatrix(index=self.index, columns=columns,
+                              objects=objects)
 
-#-------------------------------------------------------------------------------
-# Outputting
+        indexer, mask = tseries.getFillVec(self.columns, columns,
+                                           self.columns.indexMap,
+                                           columns.indexMap, None)
 
-    def toCSV(self, path, nanRep='', writeMode='wb', index=True,
-              header=True, cols=None, verbose=False):
+        newValues = self.values.take(indexer, axis=1)
+        if len(mask) > 0:
+            newValues[:, -mask] = NaN
+
+        return DataMatrix(newValues, index=self.index, columns=columns,
+                          objects=objects)
+
+    def _combineFrame(self, other, func):
         """
-        Write the DataMatrix to a CSV file
+        Methodology, briefly
+        - Really concerned here about speed, space
 
-        Parameters
-        ----------
-        path : string
-            Output file path
-        nanRep : string, default=''
-            Appearance of NaN values in output
-        index : boolean, default=True
-            Prints index if True
-        header : boolean, default=True
-            Prints header if True
-        cols : list of strings
-            Prints the values in order specified by cols.
-            By default, prints all columns in lexicographical order.
+        - Get new index
+        - Reindex to new index
+        - Determine newColumns and commonColumns
+        - Add common columns over all (new) indices
+        - Fill to new set of columns
+
+        Could probably deal with some Cython action in here at some point
         """
-        f = open(path, writeMode)
+        if self.index.equals(other.index):
+            newIndex = self.index
+            myReindex = self
+            hisReindex = other
+        else:
+            newIndex = self.index.union(other.index)
+            myReindex = self.reindex(newIndex)
+            hisReindex = other.reindex(newIndex)
 
-        if cols is None:
-            cols = self.cols()
-        series = self._series
+        if not self and not other:
+            return DataMatrix(index=newIndex)
+        elif not self:
+            return other * NaN
+        elif not other:
+            return self * NaN
 
-        if header:
-            if index:
-                f.write(',')
-            f.write(','.join([str(c) for c in cols]))
-            f.write('\n')
+        myValues = myReindex.values
+        safe = self.columns.equals(other.columns)
 
-        for idx in self.index:
-            if index:
-                f.write(str(idx) + ',')
+        if safe:
+            newCols = self.columns
+            commonCols = self.columns
+        else:
+            newCols = self.columns.union(other.columns)
+            commonCols = self.columns.intersection(other.columns)
 
-            for col in cols:
-                val = series[col][idx]
-                if isnull(val):
-                    val = nanRep
-                else:
-                    val = str(val)
-                f.write(val + ',')
-            f.write('\n')
+        hisValues = hisReindex.values
+        hisCols = hisReindex.columns
 
-        f.close()
+        if safe:
+            resultMatrix = func(myValues, hisValues)
+        else:
+            T, N = len(newIndex), len(newCols)
+            resultMatrix = np.empty((T, N), dtype=self.values.dtype)
+            resultMatrix.fill(NaN)
 
-        if verbose: # pragma: no cover
-            print 'CSV file written successfully: %s' % path
+            myIndexer = [self.columns.indexMap[idx] for idx in commonCols]
+            hisIndexer =  [hisCols.indexMap[idx] for idx in commonCols]
+            resultIndexer = [newCols.indexMap[idx] for idx in commonCols]
 
-    def toString(self, buffer=sys.stdout, verbose=False,
-                 columns=None, colSpace=15, nanRep='NaN',
-                 formatters=None, float_format=None):
-        """
-        Output a string version of this DataMatrix
-        """
-        formatters = formatters or {}
+            resultMatrix[:, resultIndexer] = func(myValues[:, myIndexer],
+                                                  hisValues[:, hisIndexer])
 
-        if columns is None:
-            columns = self.columns
-            values = self.values
-            if self.objects:
-                columns = list(columns) + list(self.objects.columns)
-                values = np.column_stack((values.astype(object),
-                                          self.objects.values))
-        else:
-            columns = [c for c in columns if c in self]
-            values = self.asMatrix(columns)
+        # TODO: deal with objects
+        return DataMatrix(resultMatrix, index=newIndex, columns=newCols)
 
-        ident = lambda x: x
+    def _combineSeries(self, other, func):
+        newIndex = self.index
+        newCols = self.columns
 
-        idxSpace = max([len(str(idx)) for idx in self.index]) + 4
+        if not self:
+            return DataFrame(index=NULL_INDEX)
 
-        if len(self.cols()) == 0:
-            buffer.write('DataMatrix is empty!\n')
-            buffer.write(repr(self.index))
+        if self.index._allDates and other.index._allDates:
+            # Operate row-wise
+            if self.index.equals(other.index):
+                newIndex = self.index
+            else:
+                newIndex = self.index + other.index
+
+            other = other.reindex(newIndex).view(np.ndarray)
+            myReindex = self.reindex(newIndex)
+            resultMatrix = func(myReindex.values.T, other).T
         else:
-            buffer.write(_pfixed('', idxSpace))
-            for h in columns:
-                buffer.write(_pfixed(h, colSpace))
-            buffer.write('\n')
+            if len(other) == 0:
+                return self * NaN
 
-            for i, idx in enumerate(self.index):
-                buffer.write(_pfixed(idx, idxSpace))
-                for j, col in enumerate(columns):
-                    formatter = formatters.get(col, ident)
-                    buffer.write(_pfixed(formatter(values[i, j]), colSpace,
-                                         float_format=float_format,
-                                         nanRep=nanRep))
-                buffer.write('\n')
+            newCols = self.columns.union(other.index)
 
-    def info(self, buffer=sys.stdout):
-        """
-        Concise summary of a DataMatrix, used in __repr__ when very large.
-        """
-        print >> buffer, 'Index: %s entries' % len(self.index),
-        if len(self.index) > 0:
-            print >> buffer, ', %s to %s' % (self.index[0], self.index[-1])
-        else:
-            print >> buffer, ''
+            # Operate column-wise
+            this = self.reindex(columns=newCols)
+            other = other.reindex(newCols).values()
 
-        if len(self.columns) == 0:
-            print >> buffer, 'DataMatrix is empty!'
-            print >> buffer, repr(self.index)
-            return
+            resultMatrix = func(this.values, other)
 
-        print >> buffer, 'Data columns:'
-        space = max([len(str(k)) for k in self.cols()]) + 4
+        # TODO: deal with objects
+        return DataMatrix(resultMatrix, index=newIndex, columns=newCols)
 
-        counts = self.apply(notnull).sum(0)
+    def _combineFunc(self, other, func):
+        """
+        Combine DataMatrix objects with other Series- or DataFrame-like objects
 
-        columns = []
-        for j, col in enumerate(self.columns):
-            columns.append((col, '%s%d  non-null values' %
-                           (_pfixed(col, space), counts[j])))
+        This is the core method used for the overloaded arithmetic methods
 
-        if self.objects is not None and len(self.objects.columns) > 0:
-            n = len(self.objects.index)
-            for col in self.objects:
-                line = '%s%d  non-null values' % (_pfixed(col, space), n)
-                columns.append((col, line))
+        Result hierarchy
+        ----------------
+        DataMatrix + DataFrame --> DataMatrix
+        DataMatrix + DataMatrix --> DataMatrix
+        DataMatrix + Series --> DataMatrix
+        DataMatrix + constant --> DataMatrix
 
-        try:
-            columns = [c[1] for c in sorted(columns)]
-        except TypeError:
-            columns = sorted([c[1] for c in columns])
+        The reason for 'upcasting' the result is that if addition succeed,
+        we can assume that the input DataFrame was homogeneous.
+        """
+        newIndex = self.index
+        if isinstance(other, DataFrame):
+            return self._combineFrame(other, func)
 
-        dtypeLine = ''
+        elif isinstance(other, Series):
+            return self._combineSeries(other, func)
 
-        nf = len(self.columns)
-        df = self.values.dtype
-        if self.objects is not None:
-            no = len(self.objects.columns)
-            do = self.objects.values.dtype
-            dtypeLine = '\ndtypes: %s(%d), %s(%d)' % (df, nf, do, no)
         else:
-            dtypeLine = '\ndtype: %s(%d)' % (df, nf)
+            if not self:
+                return self
 
-        buffer.write('\n'.join(columns) + dtypeLine)
+            # Constant of some kind
+            newCols = self.columns
+            resultMatrix = func(self.values, other)
+
+        # TODO: deal with objects
+        return DataMatrix(resultMatrix, index=newIndex, columns=newCols)
 
 #-------------------------------------------------------------------------------
 # Properties for index and columns
@@ -429,6 +467,41 @@ class DataMatrix(DataFrame):
 #-------------------------------------------------------------------------------
 # "Magic methods"
 
+    def __getstate__(self):
+        if self.objects is not None:
+            objects = self.objects._matrix_state(pickle_index=False)
+        else:
+            objects = None
+
+        state = self._matrix_state()
+
+        return (state, objects)
+
+    def _matrix_state(self, pickle_index=True):
+        columns = _pickle_array(self.columns)
+
+        if pickle_index:
+            index = _pickle_array(self.index)
+        else:
+            index = None
+
+        return self.values, index, columns
+
+    def __setstate__(self, state):
+        (vals, idx, cols), object_state = state
+
+        self.values = vals
+        self.index = _unpickle_array(idx)
+        self.columns = _unpickle_array(cols)
+
+        if object_state:
+            ovals, _, ocols = object_state
+            self.objects = DataMatrix(ovals,
+                                      index=self.index,
+                                      columns=_unpickle_array(ocols))
+        else:
+            self.objects = None
+
     def __nonzero__(self):
         N, K = self.values.shape
         if N == 0 or K == 0:
@@ -648,133 +721,237 @@ class DataMatrix(DataFrame):
         return series
     _series = property(_getSeriesDict)
 
-    def _combineFrame(self, other, func):
+#-------------------------------------------------------------------------------
+# Outputting
+
+    def toCSV(self, path, nanRep='', writeMode='wb', index=True,
+              header=True, cols=None, verbose=False):
         """
-        Methodology, briefly
-        - Really concerned here about speed, space
+        Write the DataMatrix to a CSV file
 
-        - Get new index
-        - Reindex to new index
-        - Determine newColumns and commonColumns
-        - Add common columns over all (new) indices
-        - Fill to new set of columns
+        Parameters
+        ----------
+        path : string
+            Output file path
+        nanRep : string, default=''
+            Appearance of NaN values in output
+        index : boolean, default=True
+            Prints index if True
+        header : boolean, default=True
+            Prints header if True
+        cols : list of strings
+            Prints the values in order specified by cols.
+            By default, prints all columns in lexicographical order.
+        """
+        f = open(path, writeMode)
 
-        Could probably deal with some Cython action in here at some point
+        if cols is None:
+            cols = self.cols()
+        series = self._series
+
+        if header:
+            if index:
+                f.write(',')
+            f.write(','.join([str(c) for c in cols]))
+            f.write('\n')
+
+        for idx in self.index:
+            if index:
+                f.write(str(idx) + ',')
+
+            for col in cols:
+                val = series[col][idx]
+                if isnull(val):
+                    val = nanRep
+                else:
+                    val = str(val)
+                f.write(val + ',')
+            f.write('\n')
+
+        f.close()
+
+        if verbose: # pragma: no cover
+            print 'CSV file written successfully: %s' % path
+
+    def toString(self, buffer=sys.stdout, columns=None, colSpace=15,
+                 nanRep='NaN', formatters=None, float_format=None):
         """
-        if self.index.equals(other.index):
-            newIndex = self.index
-            myReindex = self
-            hisReindex = other
+        Output a string version of this DataMatrix
+        """
+        formatters = formatters or {}
+
+        if columns is None:
+            columns = self.columns
+            values = self.values
+            if self.objects:
+                columns = list(columns) + list(self.objects.columns)
+                values = np.column_stack((values.astype(object),
+                                          self.objects.values))
         else:
-            newIndex = self.index.union(other.index)
-            myReindex = self.reindex(newIndex)
-            hisReindex = other.reindex(newIndex)
+            columns = [c for c in columns if c in self]
+            values = self.asMatrix(columns)
 
-        if not self and not other:
-            return DataMatrix(index=newIndex)
-        elif not self:
-            return other * NaN
-        elif not other:
-            return self * NaN
+        ident = lambda x: x
 
-        myValues = myReindex.values
-        safe = self.columns.equals(other.columns)
+        idxSpace = max([len(str(idx)) for idx in self.index]) + 4
 
-        if safe:
-            newCols = self.columns
-            commonCols = self.columns
+        if len(self.cols()) == 0:
+            buffer.write('DataMatrix is empty!\n')
+            buffer.write(repr(self.index))
         else:
-            newCols = self.columns.union(other.columns)
-            commonCols = self.columns.intersection(other.columns)
+            buffer.write(_pfixed('', idxSpace))
+            for h in columns:
+                buffer.write(_pfixed(h, colSpace))
+            buffer.write('\n')
 
-        hisValues = hisReindex.values
-        hisCols = hisReindex.columns
+            for i, idx in enumerate(self.index):
+                buffer.write(_pfixed(idx, idxSpace))
+                for j, col in enumerate(columns):
+                    formatter = formatters.get(col, ident)
+                    buffer.write(_pfixed(formatter(values[i, j]), colSpace,
+                                         float_format=float_format,
+                                         nanRep=nanRep))
+                buffer.write('\n')
 
-        if safe:
-            resultMatrix = func(myValues, hisValues)
+    def info(self, buffer=sys.stdout):
+        """
+        Concise summary of a DataMatrix, used in __repr__ when very large.
+        """
+        print >> buffer, 'Index: %s entries' % len(self.index),
+        if len(self.index) > 0:
+            print >> buffer, ', %s to %s' % (self.index[0], self.index[-1])
         else:
-            T, N = len(newIndex), len(newCols)
-            resultMatrix = np.empty((T, N), dtype=self.values.dtype)
-            resultMatrix.fill(NaN)
+            print >> buffer, ''
 
-            myIndexer = [self.columns.indexMap[idx] for idx in commonCols]
-            hisIndexer =  [hisCols.indexMap[idx] for idx in commonCols]
-            resultIndexer = [newCols.indexMap[idx] for idx in commonCols]
+        if len(self.columns) == 0:
+            print >> buffer, 'DataMatrix is empty!'
+            print >> buffer, repr(self.index)
+            return
 
-            resultMatrix[:, resultIndexer] = func(myValues[:, myIndexer],
-                                                  hisValues[:, hisIndexer])
+        print >> buffer, 'Data columns:'
+        space = max([len(str(k)) for k in self.cols()]) + 4
 
-        # TODO: deal with objects
-        return DataMatrix(resultMatrix, index=newIndex, columns=newCols)
+        counts = self.apply(notnull).sum(0)
 
-    def _combineSeries(self, other, func):
-        newIndex = self.index
-        newCols = self.columns
+        columns = []
+        for j, col in enumerate(self.columns):
+            columns.append((col, '%s%d  non-null values' %
+                           (_pfixed(col, space), counts[j])))
 
-        if not self:
-            return DataFrame(index=NULL_INDEX)
+        if self.objects is not None and len(self.objects.columns) > 0:
+            n = len(self.objects.index)
+            for col in self.objects:
+                line = '%s%d  non-null values' % (_pfixed(col, space), n)
+                columns.append((col, line))
 
-        if self.index._allDates and other.index._allDates:
-            # Operate row-wise
-            if self.index.equals(other.index):
-                newIndex = self.index
-            else:
-                newIndex = self.index + other.index
+        try:
+            columns = [c[1] for c in sorted(columns)]
+        except TypeError:
+            columns = sorted([c[1] for c in columns])
 
-            other = other.reindex(newIndex).view(np.ndarray)
-            myReindex = self.reindex(newIndex)
-            resultMatrix = func(myReindex.values.T, other).T
+        dtypeLine = ''
+
+        nf = len(self.columns)
+        df = self.values.dtype
+        if self.objects is not None:
+            no = len(self.objects.columns)
+            do = self.objects.values.dtype
+            dtypeLine = '\ndtypes: %s(%d), %s(%d)' % (df, nf, do, no)
         else:
-            if len(other) == 0:
-                return self * NaN
+            dtypeLine = '\ndtype: %s(%d)' % (df, nf)
 
-            newCols = self.columns.union(other.index)
+        buffer.write('\n'.join(columns) + dtypeLine)
+
+
+#-------------------------------------------------------------------------------
+# Public methods
+
+    def apply(self, func, axis=0):
+        """
+        Applies func to columns (Series) of this DataMatrix and returns either
+        a DataMatrix (if the function produces another series) or a Series
+        indexed on the column names of the DataFrame if the function produces
+        a value.
+
+        Parameters
+        ----------
+        func : function
+            Function to apply to each column
+
+        Examples
+        --------
+
+            >>> df.apply(numpy.sqrt) --> DataMatrix
+            >>> df.apply(numpy.sum) --> Series
+
+        N.B.: Do NOT use functions that might toy with the index.
+        """
+        if not len(self.cols()):
+            return self
 
-            # Operate column-wise
-            this = self.reindex(columns=newCols)
-            other = other.reindex(newCols).values()
+        if isinstance(func, np.ufunc):
+            results = func(self.values)
+            return DataMatrix(data=results, index=self.index,
+                              columns=self.columns, objects=self.objects)
+        else:
+            return DataFrame.apply(self, func, axis=axis)
 
-            resultMatrix = func(this.values, other)
+    def applymap(self, func):
+        """
+        Apply a function to a DataMatrix that is intended to operate
+        elementwise, i.e. like doing
+            map(func, series) for each series in the DataMatrix
 
-        # TODO: deal with objects
-        return DataMatrix(resultMatrix, index=newIndex, columns=newCols)
+        Parameters
+        ----------
+        func : function
+            Python function, returns a single value from a single value
 
-    def _combineFunc(self, other, func):
+        Note : try to avoid using this function if you can, very slow.
         """
-        Combine DataMatrix objects with other Series- or DataFrame-like objects
+        npfunc = np.frompyfunc(func, 1, 1)
+        results = npfunc(self.values)
+        try:
+            results = results.astype(self.values.dtype)
+        except Exception:
+            pass
 
-        This is the core method used for the overloaded arithmetic methods
+        return DataMatrix(results, index=self.index, columns=self.columns)
 
-        Result hierarchy
-        ----------------
-        DataMatrix + DataFrame --> DataMatrix
-        DataMatrix + DataMatrix --> DataMatrix
-        DataMatrix + Series --> DataMatrix
-        DataMatrix + constant --> DataMatrix
+    def append(self, other):
+        """
+        Glue together DataFrame objects having non-overlapping indices
 
-        The reason for 'upcasting' the result is that if addition succeed,
-        we can assume that the input DataFrame was homogeneous.
+        Parameters
+        ----------
+        other : DataFrame
         """
-        newIndex = self.index
-        if isinstance(other, DataFrame):
-            return self._combineFrame(other, func)
+        if not other:
+            return self.copy()
 
-        elif isinstance(other, Series):
-            return self._combineSeries(other, func)
+        if not self:
+            return other.copy()
 
-        else:
-            if not self:
-                return self
+        if (isinstance(other, DataMatrix) and
+            self.columns.equals(other.columns)):
 
-            # Constant of some kind
-            newCols = self.columns
-            resultMatrix = func(self.values, other)
+            idx = Index(np.concatenate([self.index, other.index]))
+            mat = np.vstack((self.values, other.values))
 
-        # TODO: deal with objects
-        return DataMatrix(resultMatrix, index=newIndex, columns=newCols)
+            if other.objects is None:
+                objects = self.objects
+            elif self.objects is None:
+                objects = other.objects
+            else:
+                objects = self.objects.append(other.objects)
 
-#-------------------------------------------------------------------------------
-# Public methods
+            if objects:
+                objects = objects.reindex(idx)
+
+            dm = DataMatrix(mat, idx, self.columns, objects=objects)
+            return dm
+        else:
+            return super(DataMatrix, self).append(other)
 
     def asMatrix(self, columns=None):
         """
@@ -953,93 +1130,6 @@ class DataMatrix(DataFrame):
 
         return result
 
-    def _join_on(self, other, on):
-        if len(other.index) == 0:
-            return self
-
-        if on not in self:
-            raise Exception('%s column not contained in this frame!' % on)
-
-        fillVec, mask = tseries.getMergeVec(self[on],
-                                            other.index.indexMap)
-
-        tmpMatrix = other.values.take(fillVec, axis=0)
-        tmpMatrix[-mask] = NaN
-
-        seriesDict = dict((col, tmpMatrix[:, j])
-                           for j, col in enumerate(other.columns))
-
-        if getattr(other, 'objects'):
-            objects = other.objects
-
-            tmpMat = objects.values.take(fillVec, axis=0)
-            tmpMat[-mask] = NaN
-            objDict = dict((col, tmpMat[:, j])
-                           for j, col in enumerate(objects.columns))
-
-            seriesDict.update(objDict)
-
-        filledFrame = DataFrame(data=seriesDict, index=self.index)
-
-        return self.leftJoin(filledFrame)
-
-    def _reindex_index(self, index, method):
-        if index is self.index:
-            return self.copy()
-
-        if not isinstance(index, Index):
-            index = Index(index)
-
-        if len(self.index) == 0:
-            return DataMatrix(index=index, columns=self.columns)
-
-        fillVec, mask = tseries.getFillVec(self.index, index,
-                                           self.index.indexMap,
-                                           index.indexMap, method)
-
-        tmpMatrix = self.values.take(fillVec, axis=0)
-        if len(index) > 0:
-            tmpMatrix[-mask] = NaN
-
-        if self.objects is not None and len(self.objects.columns) > 0:
-            newObjects = self.objects.reindex(index)
-        else:
-            newObjects = None
-
-        return DataMatrix(tmpMatrix, index=index,
-                          columns=self.columns,
-                          objects=newObjects)
-
-    def _reindex_columns(self, columns):
-        if len(columns) == 0:
-            return DataMatrix(index=self.index)
-
-        if not isinstance(columns, Index):
-            columns = Index(columns)
-
-        if self.objects is not None:
-            object_columns = columns.intersection(self.objects.columns)
-            columns = columns - object_columns
-
-            objects = self.objects._reindex_columns(object_columns)
-        else:
-            objects = None
-
-        if len(columns) > 0 and len(self.columns) == 0:
-            return DataMatrix(index=self.index, columns=columns,
-                              objects=objects)
-
-        indexer, mask = tseries.getFillVec(self.columns, columns,
-                                           self.columns.indexMap,
-                                           columns.indexMap, None)
-
-        newValues = self.values.take(indexer, axis=1)
-        if len(mask) > 0:
-            newValues[:, -mask] = NaN
-
-        return DataMatrix(newValues, index=self.index, columns=columns,
-                          objects=objects)
-
     @property
     def T(self):
         """
@@ -1110,93 +1200,6 @@ class DataMatrix(DataFrame):
         return DataMatrix(data=newValues, index=newIndex, columns=self.columns,
                           objects=shifted_objects)
 
-    def apply(self, func, axis=0):
-        """
-        Applies func to columns (Series) of this DataMatrix and returns either
-        a DataMatrix (if the function produces another series) or a Series
-        indexed on the column names of the DataFrame if the function produces
-        a value.
-
-        Parameters
-        ----------
-        func : function
-            Function to apply to each column
-
-        Examples
-        --------
-
-            >>> df.apply(numpy.sqrt) --> DataMatrix
-            >>> df.apply(numpy.sum) --> Series
-
-        N.B.: Do NOT use functions that might toy with the index.
-        """
-        if not len(self.cols()):
-            return self
-
-        if isinstance(func, np.ufunc):
-            results = func(self.values)
-            return DataMatrix(data=results, index=self.index,
-                              columns=self.columns, objects=self.objects)
-        else:
-            return DataFrame.apply(self, func, axis=axis)
-
-    def applymap(self, func):
-        """
-        Apply a function to a DataMatrix that is intended to operate
-        elementwise, i.e. like doing
-            map(func, series) for each series in the DataMatrix
-
-        Parameters
-        ----------
-        func : function
-            Python function, returns a single value from a single value
-
-        Note : try to avoid using this function if you can, very slow.
-        """
-        npfunc = np.frompyfunc(func, 1, 1)
-        results = npfunc(self.values)
-        try:
-            results = results.astype(self.values.dtype)
-        except Exception:
-            pass
-
-        return DataMatrix(results, index=self.index, columns=self.columns)
-
-    def append(self, other):
-        """
-        Glue together DataFrame objects having non-overlapping indices
-
-        Parameters
-        ----------
-        other : DataFrame
-        """
-        if not other:
-            return self.copy()
-
-        if not self:
-            return other.copy()
-
-        if (isinstance(other, DataMatrix) and
-            self.columns.equals(other.columns)):
-
-            idx = Index(np.concatenate([self.index, other.index]))
-            mat = np.vstack((self.values, other.values))
-
-            if other.objects is None:
-                objects = self.objects
-            elif self.objects is None:
-                objects = other.objects
-            else:
-                objects = self.objects.append(other.objects)
-
-            if objects:
-                objects = objects.reindex(idx)
-
-            dm = DataMatrix(mat, idx, self.columns, objects=objects)
-            return dm
-        else:
-            return super(DataMatrix, self).append(other)
-
 def _reorder_columns(mat, current, desired):
     fillVec, mask = tseries.getFillVec(current, desired, current.indexMap,
                                        desired.indexMap, None)
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index 0d66f95d8..b3dc6cef5 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -282,7 +282,6 @@ class TestDataFrame(unittest.TestCase):
         biggie.toString(buffer=buf)
 
         biggie.toString(buffer=buf, columns=['B', 'A'], colSpace=17)
-        biggie.toString(buffer=buf, columns=['B', 'A'], verbose=True)
         biggie.toString(buffer=buf, columns=['B', 'A'],
                         formatters={'A' : lambda x: '%.1f' % x})
 

commit 94bca94daf64cc6cd36705a9bfe4d6d9f8306202
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Thu Nov 2 04:56:15 2017 -0700

    Move scalar arithmetic tests to tests.scalars (#18075)

diff --git a/pandas/tests/indexes/datetimes/test_arithmetic.py b/pandas/tests/indexes/datetimes/test_arithmetic.py
index 2f3d56759..bf0217e9b 100644
--- a/pandas/tests/indexes/datetimes/test_arithmetic.py
+++ b/pandas/tests/indexes/datetimes/test_arithmetic.py
@@ -199,25 +199,6 @@ class TestDatetimeIndexArithmetic(object):
             tm.assert_index_equal(result, exp)
             assert result.freq == 'D'
 
-    def test_overflow_offset(self):
-        # xref https://github.com/statsmodels/statsmodels/issues/3374
-        # ends up multiplying really large numbers which overflow
-
-        t = Timestamp('2017-01-13 00:00:00', freq='D')
-        offset = 20169940 * pd.offsets.Day(1)
-
-        def f():
-            t + offset
-        pytest.raises(OverflowError, f)
-
-        def f():
-            offset + t
-        pytest.raises(OverflowError, f)
-
-        def f():
-            t - offset
-        pytest.raises(OverflowError, f)
-
 
 # GH 10699
 @pytest.mark.parametrize('klass,assert_func', zip([Series, DatetimeIndex],
diff --git a/pandas/tests/indexes/timedeltas/test_arithmetic.py b/pandas/tests/indexes/timedeltas/test_arithmetic.py
index 9341cf220..bbc8dd657 100644
--- a/pandas/tests/indexes/timedeltas/test_arithmetic.py
+++ b/pandas/tests/indexes/timedeltas/test_arithmetic.py
@@ -51,44 +51,6 @@ class TestTimedeltaIndexArithmetic(object):
         pytest.raises(ValueError, lambda: idx * self._holder(np.arange(3)))
         pytest.raises(ValueError, lambda: idx * np.array([1, 2]))
 
-    # FIXME: duplicate.  This came from `test_timedelta`, whereas the
-    # version above came from `test_astype`.  Make sure there aren't more
-    # duplicates.
-    def test_numeric_compat__(self):
-
-        idx = self._holder(np.arange(5, dtype='int64'))
-        didx = self._holder(np.arange(5, dtype='int64') ** 2)
-        result = idx * 1
-        tm.assert_index_equal(result, idx)
-
-        result = 1 * idx
-        tm.assert_index_equal(result, idx)
-
-        result = idx / 1
-        tm.assert_index_equal(result, idx)
-
-        result = idx // 1
-        tm.assert_index_equal(result, idx)
-
-        result = idx * np.array(5, dtype='int64')
-        tm.assert_index_equal(result,
-                              self._holder(np.arange(5, dtype='int64') * 5))
-
-        result = idx * np.arange(5, dtype='int64')
-        tm.assert_index_equal(result, didx)
-
-        result = idx * Series(np.arange(5, dtype='int64'))
-        tm.assert_index_equal(result, didx)
-
-        result = idx * Series(np.arange(5, dtype='float64') + 0.1)
-        tm.assert_index_equal(result, self._holder(np.arange(
-            5, dtype='float64') * (np.arange(5, dtype='float64') + 0.1)))
-
-        # invalid
-        pytest.raises(TypeError, lambda: idx * idx)
-        pytest.raises(ValueError, lambda: idx * self._holder(np.arange(3)))
-        pytest.raises(ValueError, lambda: idx * np.array([1, 2]))
-
     def test_ufunc_coercions(self):
         # normal ops are also tested in tseries/test_timedeltas.py
         idx = TimedeltaIndex(['2H', '4H', '6H', '8H', '10H'],
@@ -406,47 +368,6 @@ class TestTimedeltaIndexArithmetic(object):
         expected = Timestamp('20130102')
         assert result == expected
 
-    # TODO: Split by op, better name
-    def test_ops(self):
-        td = Timedelta(10, unit='d')
-        assert -td == Timedelta(-10, unit='d')
-        assert +td == Timedelta(10, unit='d')
-        assert td - td == Timedelta(0, unit='ns')
-        assert (td - pd.NaT) is pd.NaT
-        assert td + td == Timedelta(20, unit='d')
-        assert (td + pd.NaT) is pd.NaT
-        assert td * 2 == Timedelta(20, unit='d')
-        assert (td * pd.NaT) is pd.NaT
-        assert td / 2 == Timedelta(5, unit='d')
-        assert td // 2 == Timedelta(5, unit='d')
-        assert abs(td) == td
-        assert abs(-td) == td
-        assert td / td == 1
-        assert (td / pd.NaT) is np.nan
-        assert (td // pd.NaT) is np.nan
-
-        # invert
-        assert -td == Timedelta('-10d')
-        assert td * -1 == Timedelta('-10d')
-        assert -1 * td == Timedelta('-10d')
-        assert abs(-td) == Timedelta('10d')
-
-        # invalid multiply with another timedelta
-        pytest.raises(TypeError, lambda: td * td)
-
-        # can't operate with integers
-        pytest.raises(TypeError, lambda: td + 2)
-        pytest.raises(TypeError, lambda: td - 2)
-
-    def test_ops_offsets(self):
-        td = Timedelta(10, unit='d')
-        assert Timedelta(241, unit='h') == td + pd.offsets.Hour(1)
-        assert Timedelta(241, unit='h') == pd.offsets.Hour(1) + td
-        assert 240 == td / pd.offsets.Hour(1)
-        assert 1 / 240.0 == pd.offsets.Hour(1) / td
-        assert Timedelta(239, unit='h') == td - pd.offsets.Hour(1)
-        assert Timedelta(-239, unit='h') == pd.offsets.Hour(1) - td
-
     def test_ops_ndarray(self):
         td = Timedelta('1 day')
 
@@ -530,50 +451,6 @@ class TestTimedeltaIndexArithmetic(object):
         tm.assert_series_equal(s + pd.Timedelta('00:30:00'), exp)
         tm.assert_series_equal(pd.Timedelta('00:30:00') + s, exp)
 
-    def test_ops_notimplemented(self):
-        class Other:
-            pass
-
-        other = Other()
-
-        td = Timedelta('1 day')
-        assert td.__add__(other) is NotImplemented
-        assert td.__sub__(other) is NotImplemented
-        assert td.__truediv__(other) is NotImplemented
-        assert td.__mul__(other) is NotImplemented
-        assert td.__floordiv__(other) is NotImplemented
-
-    def test_timedelta_ops_scalar(self):
-        # GH 6808
-        base = pd.to_datetime('20130101 09:01:12.123456')
-        expected_add = pd.to_datetime('20130101 09:01:22.123456')
-        expected_sub = pd.to_datetime('20130101 09:01:02.123456')
-
-        for offset in [pd.to_timedelta(10, unit='s'), timedelta(seconds=10),
-                       np.timedelta64(10, 's'),
-                       np.timedelta64(10000000000, 'ns'),
-                       pd.offsets.Second(10)]:
-            result = base + offset
-            assert result == expected_add
-
-            result = base - offset
-            assert result == expected_sub
-
-        base = pd.to_datetime('20130102 09:01:12.123456')
-        expected_add = pd.to_datetime('20130103 09:01:22.123456')
-        expected_sub = pd.to_datetime('20130101 09:01:02.123456')
-
-        for offset in [pd.to_timedelta('1 day, 00:00:10'),
-                       pd.to_timedelta('1 days, 00:00:10'),
-                       timedelta(days=1, seconds=10),
-                       np.timedelta64(1, 'D') + np.timedelta64(10, 's'),
-                       pd.offsets.Day() + pd.offsets.Second(10)]:
-            result = base + offset
-            assert result == expected_add
-
-            result = base - offset
-            assert result == expected_sub
-
     def test_timedelta_ops_with_missing_values(self):
         # setup
         s1 = pd.to_timedelta(Series(['00:00:01']))
diff --git a/pandas/tests/scalar/test_timedelta.py b/pandas/tests/scalar/test_timedelta.py
index d4434b3af..17c818779 100644
--- a/pandas/tests/scalar/test_timedelta.py
+++ b/pandas/tests/scalar/test_timedelta.py
@@ -40,6 +40,91 @@ class TestTimedeltaArithmetic(object):
 
         pytest.raises(TypeError, lambda: Timedelta(nanoseconds='abc'))
 
+    def test_ops_notimplemented(self):
+        class Other:
+            pass
+
+        other = Other()
+
+        td = Timedelta('1 day')
+        assert td.__add__(other) is NotImplemented
+        assert td.__sub__(other) is NotImplemented
+        assert td.__truediv__(other) is NotImplemented
+        assert td.__mul__(other) is NotImplemented
+        assert td.__floordiv__(other) is NotImplemented
+
+    def test_timedelta_ops_scalar(self):
+        # GH 6808
+        base = pd.to_datetime('20130101 09:01:12.123456')
+        expected_add = pd.to_datetime('20130101 09:01:22.123456')
+        expected_sub = pd.to_datetime('20130101 09:01:02.123456')
+
+        for offset in [pd.to_timedelta(10, unit='s'), timedelta(seconds=10),
+                       np.timedelta64(10, 's'),
+                       np.timedelta64(10000000000, 'ns'),
+                       pd.offsets.Second(10)]:
+            result = base + offset
+            assert result == expected_add
+
+            result = base - offset
+            assert result == expected_sub
+
+        base = pd.to_datetime('20130102 09:01:12.123456')
+        expected_add = pd.to_datetime('20130103 09:01:22.123456')
+        expected_sub = pd.to_datetime('20130101 09:01:02.123456')
+
+        for offset in [pd.to_timedelta('1 day, 00:00:10'),
+                       pd.to_timedelta('1 days, 00:00:10'),
+                       timedelta(days=1, seconds=10),
+                       np.timedelta64(1, 'D') + np.timedelta64(10, 's'),
+                       pd.offsets.Day() + pd.offsets.Second(10)]:
+            result = base + offset
+            assert result == expected_add
+
+            result = base - offset
+            assert result == expected_sub
+
+    def test_ops_offsets(self):
+        td = Timedelta(10, unit='d')
+        assert Timedelta(241, unit='h') == td + pd.offsets.Hour(1)
+        assert Timedelta(241, unit='h') == pd.offsets.Hour(1) + td
+        assert 240 == td / pd.offsets.Hour(1)
+        assert 1 / 240.0 == pd.offsets.Hour(1) / td
+        assert Timedelta(239, unit='h') == td - pd.offsets.Hour(1)
+        assert Timedelta(-239, unit='h') == pd.offsets.Hour(1) - td
+
+    # TODO: Split by op, better name
+    def test_ops(self):
+        td = Timedelta(10, unit='d')
+        assert -td == Timedelta(-10, unit='d')
+        assert +td == Timedelta(10, unit='d')
+        assert td - td == Timedelta(0, unit='ns')
+        assert (td - pd.NaT) is pd.NaT
+        assert td + td == Timedelta(20, unit='d')
+        assert (td + pd.NaT) is pd.NaT
+        assert td * 2 == Timedelta(20, unit='d')
+        assert (td * pd.NaT) is pd.NaT
+        assert td / 2 == Timedelta(5, unit='d')
+        assert td // 2 == Timedelta(5, unit='d')
+        assert abs(td) == td
+        assert abs(-td) == td
+        assert td / td == 1
+        assert (td / pd.NaT) is np.nan
+        assert (td // pd.NaT) is np.nan
+
+        # invert
+        assert -td == Timedelta('-10d')
+        assert td * -1 == Timedelta('-10d')
+        assert -1 * td == Timedelta('-10d')
+        assert abs(-td) == Timedelta('10d')
+
+        # invalid multiply with another timedelta
+        pytest.raises(TypeError, lambda: td * td)
+
+        # can't operate with integers
+        pytest.raises(TypeError, lambda: td + 2)
+        pytest.raises(TypeError, lambda: td - 2)
+
 
 class TestTimedeltas(object):
     _multiprocess_can_split_ = True
diff --git a/pandas/tests/scalar/test_timestamp.py b/pandas/tests/scalar/test_timestamp.py
index efee09679..4cd9a2fad 100644
--- a/pandas/tests/scalar/test_timestamp.py
+++ b/pandas/tests/scalar/test_timestamp.py
@@ -28,6 +28,24 @@ from pandas.tseries.frequencies import (RESO_DAY, RESO_HR, RESO_MIN, RESO_US,
                                         RESO_MS, RESO_SEC)
 
 
+class TestTimestampArithmetic(object):
+    def test_overflow_offset(self):
+        # xref https://github.com/statsmodels/statsmodels/issues/3374
+        # ends up multiplying really large numbers which overflow
+
+        stamp = Timestamp('2017-01-13 00:00:00', freq='D')
+        offset = 20169940 * offsets.Day(1)
+
+        with pytest.raises(OverflowError):
+            stamp + offset
+
+        with pytest.raises(OverflowError):
+            offset + stamp
+
+        with pytest.raises(OverflowError):
+            stamp - offset
+
+
 class TestTimestamp(object):
 
     def test_constructor(self):

commit 952c5f0bc433622d21df20ed761ee4cb728370eb
Author: Phillip Cloud <cpcloud@gmail.com>
Date:   Fri Sep 13 09:28:25 2013 -0400

    BUG/VIS: correctly test for yaxis ticklocs across different versions of MPL

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 124661021..1d9fec688 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -396,6 +396,8 @@ Bug Fixes
   - Fixed bug with reading compressed files in as ``bytes`` rather than ``str``
     in Python 3. Simplifies bytes-producing file-handling in Python 3
     (:issue:`3963`, :issue:`4785`).
+  - Fixed an issue related to ticklocs/ticklabels with log scale bar plots
+    across different versions of matplotlib (:issue:`4789`)
 
 pandas 0.12.0
 -------------
diff --git a/pandas/tests/test_graphics.py b/pandas/tests/test_graphics.py
index 1583a3c0b..aa989e9d7 100644
--- a/pandas/tests/test_graphics.py
+++ b/pandas/tests/test_graphics.py
@@ -2,6 +2,7 @@ import nose
 import os
 import string
 import unittest
+from distutils.version import LooseVersion
 
 from datetime import datetime, date, timedelta
 
@@ -34,8 +35,9 @@ class TestSeriesPlots(unittest.TestCase):
         try:
             import matplotlib as mpl
             mpl.use('Agg', warn=False)
+            cls.mpl_le_1_2_1 = str(mpl.__version__) <= LooseVersion('1.2.1')
         except ImportError:
-            raise nose.SkipTest
+            raise nose.SkipTest("matplotlib not installed")
 
     def setUp(self):
         self.ts = tm.makeTimeSeries()
@@ -161,6 +163,16 @@ class TestSeriesPlots(unittest.TestCase):
             for r in ax.patches:
                 self.assert_(r.get_linewidth() == 2)
 
+    @slow
+    def test_bar_log(self):
+        expected = np.array([1., 10., 100., 1000.])
+
+        if not self.mpl_le_1_2_1:
+            expected = np.hstack((.1, expected, 1e4))
+
+        ax = Series([200, 500]).plot(log=True, kind='bar')
+        assert_array_equal(ax.yaxis.get_ticklocs(), expected)
+
     def test_rotation(self):
         df = DataFrame(randn(5, 5))
         ax = df.plot(rot=30)
@@ -342,8 +354,9 @@ class TestDataFramePlots(unittest.TestCase):
         try:
             import matplotlib as mpl
             mpl.use('Agg', warn=False)
+            cls.mpl_le_1_2_1 = str(mpl.__version__) <= LooseVersion('1.2.1')
         except ImportError:
-            raise nose.SkipTest
+            raise nose.SkipTest("matplotlib not installed")
 
     def tearDown(self):
         import matplotlib.pyplot as plt
@@ -559,22 +572,31 @@ class TestDataFramePlots(unittest.TestCase):
                          ax.patches[0].get_x() + ax.patches[0].get_width())
 
     @slow
-    def test_bar_log(self):
+    def test_bar_log_no_subplots(self):
         # GH3254, GH3298 matplotlib/matplotlib#1882, #1892
         # regressions in 1.2.1
+        expected = np.array([1., 10.])
+
+        if not self.mpl_le_1_2_1:
+            expected = np.hstack((.1, expected, 100))
 
+        # no subplots
         df = DataFrame({'A': [3] * 5, 'B': lrange(1, 6)}, index=lrange(5))
         ax = df.plot(kind='bar', grid=True, log=True)
-        self.assertEqual(ax.yaxis.get_ticklocs()[0], 1.0)
+        assert_array_equal(ax.yaxis.get_ticklocs(), expected)
+
+    @slow
+    def test_bar_log_subplots(self):
+        expected = np.array([1., 10., 100., 1000.])
+        if not self.mpl_le_1_2_1:
+            expected = np.hstack((.1, expected, 1e4))
 
-        p1 = Series([200, 500]).plot(log=True, kind='bar')
-        p2 = DataFrame([Series([200, 300]),
+        ax = DataFrame([Series([200, 300]),
                         Series([300, 500])]).plot(log=True, kind='bar',
                                                   subplots=True)
 
-        (p1.yaxis.get_ticklocs() == np.array([0.625, 1.625]))
-        (p2[0].yaxis.get_ticklocs() == np.array([1., 10., 100., 1000.])).all()
-        (p2[1].yaxis.get_ticklocs() == np.array([1., 10., 100., 1000.])).all()
+        assert_array_equal(ax[0].yaxis.get_ticklocs(), expected)
+        assert_array_equal(ax[1].yaxis.get_ticklocs(), expected)
 
     @slow
     def test_boxplot(self):
diff --git a/pandas/tools/plotting.py b/pandas/tools/plotting.py
index 9f6f3b08e..ce75e755a 100644
--- a/pandas/tools/plotting.py
+++ b/pandas/tools/plotting.py
@@ -4,6 +4,7 @@ import datetime
 import warnings
 import re
 from contextlib import contextmanager
+from distutils.version import LooseVersion
 
 import numpy as np
 
@@ -1452,7 +1453,13 @@ class BarPlot(MPLPlot):
 
     def _make_plot(self):
         import matplotlib as mpl
+
+        # mpl decided to make their version string unicode across all Python
+        # versions for mpl >= 1.3 so we have to call str here for python 2
+        mpl_le_1_2_1 = str(mpl.__version__) <= LooseVersion('1.2.1')
+
         colors = self._get_colors()
+        ncolors = len(colors)
         rects = []
         labels = []
 
@@ -1466,19 +1473,18 @@ class BarPlot(MPLPlot):
             ax = self._get_ax(i)
             label = com.pprint_thing(label)
             kwds = self.kwds.copy()
-            kwds['color'] = colors[i % len(colors)]
+            kwds['color'] = colors[i % ncolors]
 
-            start =0
+            start = 0
             if self.log:
                 start = 1
                 if any(y < 1):
                     # GH3254
-                    start = 0 if mpl.__version__ == "1.2.1" else None
+                    start = 0 if mpl_le_1_2_1 else None
 
             if self.subplots:
                 rect = bar_f(ax, self.ax_pos, y,  self.bar_width,
-                             start = start,
-                             **kwds)
+                             start=start, **kwds)
                 ax.set_title(label)
             elif self.stacked:
                 mask = y > 0
@@ -1489,8 +1495,7 @@ class BarPlot(MPLPlot):
                 neg_prior = neg_prior + np.where(mask, 0, y)
             else:
                 rect = bar_f(ax, self.ax_pos + i * 0.75 / K, y, 0.75 / K,
-                             start = start,
-                              label=label, **kwds)
+                             start=start, label=label, **kwds)
             rects.append(rect)
             if self.mark_right:
                 labels.append(self._get_marked_label(label, i))

commit 808547e060bd5e84dfa85213c603d909bbb29ed5
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri May 4 19:12:27 2012 -0400

    REF: working on UTC only timestamp handling, timezone handling modifications, not yet working

diff --git a/pandas/core/index.py b/pandas/core/index.py
index 411421be7..25d86f50d 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -386,11 +386,13 @@ class Index(np.ndarray):
 
     def asof_locs(self, where, mask):
         """
+        where : array of timestamps
+        mask : array of booleans where data is NA
 
         """
         locs = self.values[mask].searchsorted(where.values, side='right')
-        locs = np.where(locs > 0, locs - 1, 0)
 
+        locs = np.where(locs > 0, locs - 1, 0)
         result = np.arange(len(self))[mask].take(locs)
 
         first = mask.argmax()
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index d23a3b146..44a40fb8d 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -788,9 +788,6 @@ try:
 except:
     have_pytz = False
 
-trans_cache = {}
-utc_offset_cache = {}
-
 def tz_convert(ndarray[int64_t] vals, object tz1, object tz2):
     cdef:
         ndarray[int64_t] utc_dates, result, trans, deltas
@@ -839,7 +836,7 @@ def tz_convert(ndarray[int64_t] vals, object tz1, object tz2):
 trans_cache = {}
 utc_offset_cache = {}
 
-def _get_transitions(object tz):
+def _get_transitions(tz):
     """
     Get UTC times of DST transitions
     """
@@ -848,7 +845,7 @@ def _get_transitions(object tz):
         trans_cache[tz] = arr.view('i8')
     return trans_cache[tz]
 
-def _get_deltas(object tz):
+def _get_deltas(tz):
     """
     Get UTC offsets in microseconds corresponding to DST transitions
     """
@@ -860,7 +857,7 @@ cdef double total_seconds(object td): # Python 2.6 compat
     return ((td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) //
             10**6)
 
-cdef ndarray _unbox_utcoffsets(object transinfo):
+cpdef ndarray _unbox_utcoffsets(object transinfo):
     cdef:
         Py_ssize_t i, sz
         ndarray[int64_t] arr
@@ -874,7 +871,7 @@ cdef ndarray _unbox_utcoffsets(object transinfo):
     return arr
 
 
-def tz_localize(ndarray[int64_t] vals, object tz):
+def tz_localize_check(ndarray[int64_t] vals, object tz):
     """
     Localize tzinfo-naive DateRange to given time zone (using pytz). If
     there are ambiguities in the values, raise AmbiguousTimeError.
@@ -892,7 +889,7 @@ def tz_localize(ndarray[int64_t] vals, object tz):
         raise Exception("Could not find pytz module")
 
     if tz == pytz.utc or tz is None:
-        return vals
+        return
 
     trans = _get_transitions(tz)
     deltas = _get_deltas(tz)
@@ -915,8 +912,6 @@ def tz_localize(ndarray[int64_t] vals, object tz):
             msg = "Cannot localize, ambiguous time %s found" % Timestamp(v)
             raise pytz.AmbiguousTimeError(msg)
 
-    return vals
-
 
 # Accessors
 #----------------------------------------------------------------------
diff --git a/pandas/tests/test_algos.py b/pandas/tests/test_algos.py
new file mode 100644
index 000000000..06b0a6798
--- /dev/null
+++ b/pandas/tests/test_algos.py
@@ -0,0 +1,7 @@
+import unittest
+
+import numpy as np
+
+import pandas.core.algorithms as algos
+import pandas.util.testing as tm
+
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 2c8b3bb0a..2c98575bd 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -15,6 +15,10 @@ import pandas.tseries.tools as tools
 from pandas._tseries import Timestamp
 import pandas._tseries as lib
 
+def _utc():
+    import pytz
+    return pytz.utc
+
 # -------- some conversion wrapper functions
 
 def _as_i8(arg):
@@ -195,48 +199,8 @@ class DatetimeIndex(Int64Index):
                              "supplied")
 
         if data is None:
-            _normalized = True
-
-            if start is not None:
-                start = Timestamp(start)
-                if not isinstance(start, Timestamp):
-                    raise ValueError('Failed to convert %s to timestamp'
-                                     % start)
-
-                if normalize:
-                    start = normalize_date(start)
-                    _normalized = True
-                else:
-                    _normalized = _normalized and start.time() == _midnight
-
-            if end is not None:
-                end = Timestamp(end)
-                if not isinstance(end, Timestamp):
-                    raise ValueError('Failed to convert %s to timestamp'
-                                     % end)
-
-                if normalize:
-                    end = normalize_date(end)
-                    _normalized = True
-                else:
-                    _normalized = _normalized and end.time() == _midnight
-
-            start, end, tz = tools._figure_out_timezone(start, end, tz)
-
-            if (offset._should_cache() and
-                not (offset._normalize_cache and not _normalized) and
-                _naive_in_cache_range(start, end)):
-                index = cls._cached_range(start, end, periods=periods,
-                                          offset=offset, name=name)
-            else:
-                index = _generate_regular_range(start, end, periods, offset)
-
-            index = index.view(cls)
-            index.name = name
-            index.offset = offset
-            index.tz = tz
-
-            return index
+            return cls._generate(start, end, periods, name, offset,
+                                 tz=tz, normalize=normalize)
 
         if not isinstance(data, np.ndarray):
             if np.isscalar(data):
@@ -292,6 +256,59 @@ class DatetimeIndex(Int64Index):
 
         return subarr
 
+    @classmethod
+    def _generate(cls, start, end, periods, name, offset,
+                  tz=None, normalize=False):
+        _normalized = True
+
+        if start is not None:
+            start = Timestamp(start)
+            if not isinstance(start, Timestamp):
+                raise ValueError('Failed to convert %s to timestamp'
+                                 % start)
+
+            if normalize:
+                start = normalize_date(start)
+                _normalized = True
+            else:
+                _normalized = _normalized and start.time() == _midnight
+
+        if end is not None:
+            end = Timestamp(end)
+            if not isinstance(end, Timestamp):
+                raise ValueError('Failed to convert %s to timestamp'
+                                 % end)
+
+            if normalize:
+                end = normalize_date(end)
+                _normalized = True
+            else:
+                _normalized = _normalized and end.time() == _midnight
+
+        start, end, tz = tools._figure_out_timezone(start, end, tz)
+
+        if (offset._should_cache() and
+            not (offset._normalize_cache and not _normalized) and
+            _naive_in_cache_range(start, end)):
+            index = cls._cached_range(start, end, periods=periods,
+                                      offset=offset, name=name)
+        else:
+            index = _generate_regular_range(start, end, periods, offset)
+
+        if tz is not None:
+            # Convert local to UTC
+            ints = index.view('i8')
+            lib.tz_localize_check(ints, tz)
+            index = tz_convert(ints, tz, _utc())
+            index = index.view('M8[us]')
+
+        index = index.view(cls)
+        index.name = name
+        index.offset = offset
+        index.tz = tz
+
+        return index
+
     @classmethod
     def _simple_new(cls, values, name, offset, tz):
         result = values.view(cls)
@@ -621,8 +638,8 @@ class DatetimeIndex(Int64Index):
         this = self
         if isinstance(other, DatetimeIndex):
             if self.tz != other.tz:
-                this = self.tz_normalize('UTC')
-                other = other.tz_normalize('UTC')
+                this = self.tz_convert('UTC')
+                other = other.tz_convert('UTC')
         return this, other
 
     def _wrap_joined_index(self, joined, other):
@@ -1029,7 +1046,7 @@ class DatetimeIndex(Int64Index):
         result.name = self.name
         return result
 
-    def tz_normalize(self, tz):
+    def tz_convert(self, tz):
         """
         Convert DatetimeIndex from one time zone to another (using pytz)
 
@@ -1040,16 +1057,10 @@ class DatetimeIndex(Int64Index):
         tz = tools._maybe_get_tz(tz)
 
         if self.tz is None:
-            new_dates = lib.tz_localize(self.asi8, tz)
-        else:
-            new_dates = lib.tz_convert(self.asi8, self.tz, tz)
+            return self.tz_localize(tz)
 
-        new_dates = new_dates.view('M8[us]')
-        new_dates = new_dates.view(type(self))
-        new_dates.offset = self.offset
-        new_dates.tz = tz
-        new_dates.name = self.name
-        return new_dates
+        # No conversion since timestamps are all UTC to begin with
+        return self._simple_new(self.values, self.name, self.offset, tz)
 
     def tz_localize(self, tz):
         """
@@ -1061,16 +1072,15 @@ class DatetimeIndex(Int64Index):
         """
         if self.tz is not None:
             raise ValueError("Already have timezone info, "
-                             "use tz_normalize to convert.")
+                             "use tz_convert to convert.")
         tz = tools._maybe_get_tz(tz)
 
-        new_dates = lib.tz_localize(self.asi8, tz)
+        lib.tz_localize_check(self.asi8, tz)
+
+        # Convert to UTC
+        new_dates = tz_convert(self.asi8, tz, _utc())
         new_dates = new_dates.view('M8[us]')
-        new_dates = new_dates.view(self.__class__)
-        new_dates.offset = self.offset
-        new_dates.tz = tz
-        new_dates.name = self.name
-        return new_dates
+        return self._simple_new(new_dates, self.name, self.offset, tz)
 
     def tz_validate(self):
         """
@@ -1095,6 +1105,65 @@ class DatetimeIndex(Int64Index):
 
         return True
 
+def tz_convert(vals, tz1, tz2):
+    n = len(vals)
+    import pytz
+    # Convert to UTC
+
+    if tz1.zone != 'UTC':
+        utc_dates = np.empty(n, dtype=np.int64)
+        deltas = _get_deltas(tz1)
+        trans = _get_transitions(tz1)
+        pos = max(trans.searchsorted(vals[0], side='right') - 1, 0)
+
+        offset = deltas[pos]
+        for i in range(n):
+            v = vals[i]
+            if v >= trans[pos + 1]:
+                pos += 1
+                offset = deltas[pos]
+            utc_dates[i] = v - offset
+    else:
+        utc_dates = vals
+
+    if tz2.zone == 'UTC':
+        return utc_dates
+
+    # Convert UTC to other timezone
+
+    result = np.empty(n, dtype=np.int64)
+    trans = _get_transitions(tz2)
+    deltas = _get_deltas(tz2)
+    pos = max(trans.searchsorted(utc_dates[0], side='right') - 1, 0)
+    offset = deltas[pos]
+    for i in range(n):
+        v = utc_dates[i]
+        if v >= trans[pos + 1]:
+            pos += 1
+            offset = deltas[pos]
+        result[i] = v + offset
+
+    return result
+
+trans_cache = {}
+utc_offset_cache = {}
+
+def _get_transitions(tz):
+    """
+    Get UTC times of DST transitions
+    """
+    if tz not in trans_cache:
+        arr = np.array(tz._utc_transition_times, dtype='M8[us]')
+        trans_cache[tz] = arr.view('i8')
+    return trans_cache[tz]
+
+def _get_deltas(tz):
+    """
+    Get UTC offsets in microseconds corresponding to DST transitions
+    """
+    if tz not in utc_offset_cache:
+        utc_offset_cache[tz] = lib._unbox_utcoffsets(tz._transition_info)
+    return utc_offset_cache[tz]
 
 def _generate_regular_range(start, end, periods, offset):
     if com._count_not_none(start, end, periods) < 2:
diff --git a/pandas/tseries/tests/test_daterange.py b/pandas/tseries/tests/test_daterange.py
index 3ca574c0d..b8b3ff82c 100644
--- a/pandas/tseries/tests/test_daterange.py
+++ b/pandas/tseries/tests/test_daterange.py
@@ -12,11 +12,6 @@ from pandas.tseries.index import DatetimeIndex
 from pandas.tseries.index import bdate_range, date_range
 import pandas.tseries.tools as tools
 
-try:
-    import pytz
-except ImportError:
-    pass
-
 def eq_gen_range(kwargs, expected):
     rng = generate_range(**kwargs)
     assert(np.array_equal(list(rng), expected))
@@ -241,71 +236,11 @@ class TestDateRange(unittest.TestCase):
         result = a.intersection(b)
         self.assert_(result.equals(b))
 
-    def test_with_tz(self):
-        _skip_if_no_pytz()
-        tz = pytz.timezone('US/Central')
-
-        # just want it to work
-        start = datetime(2011, 3, 12, tzinfo=pytz.utc)
-        dr = bdate_range(start, periods=50, freq=datetools.Hour())
-        self.assert_(dr.tz is not None)
-        self.assert_(dr.tz is start.tzinfo)
-
-        # DateRange with naive datetimes
-        dr = bdate_range('1/1/2005', '1/1/2009', tz=pytz.utc)
-        dr = bdate_range('1/1/2005', '1/1/2009', tz=tz)
-
-        # normalized
-        central = dr.tz_normalize(tz)
-        self.assert_(central.tz is tz)
-        self.assert_(central[0].tz is tz)
-
-        # datetimes with tzinfo set
-        dr = bdate_range(datetime(2005, 1, 1, tzinfo=pytz.utc),
-                         '1/1/2009', tz=pytz.utc)
-
-        self.assertRaises(Exception, bdate_range,
-                          datetime(2005, 1, 1, tzinfo=pytz.utc),
-                          '1/1/2009', tz=tz)
-
-    def test_tz_localize(self):
-        _skip_if_no_pytz()
-        dr = bdate_range('1/1/2009', '1/1/2010')
-        dr_utc = bdate_range('1/1/2009', '1/1/2010', tz=pytz.utc)
-        localized = dr.tz_localize(pytz.utc)
-        self.assert_(np.array_equal(dr_utc, localized))
-
-    def test_with_tz_ambiguous_times(self):
-        _skip_if_no_pytz()
-        tz = pytz.timezone('US/Eastern')
-
-        # regular no problem
-        self.assert_(self.rng.tz_validate())
-
-        # March 13, 2011, spring forward, skip from 2 AM to 3 AM
-        dr = date_range(datetime(2011, 3, 13, 1, 30), periods=3,
-                        freq=datetools.Hour(), tz=tz)
-        self.assert_(not dr.tz_validate())
-
-        # after dst transition
-        dr = date_range(datetime(2011, 3, 13, 3, 30), periods=3,
-                        freq=datetools.Hour(), tz=tz)
-        self.assert_(dr.tz_validate())
-
-        # November 6, 2011, fall back, repeat 2 AM hour
-        dr = date_range(datetime(2011, 11, 6, 1, 30), periods=3,
-                        freq=datetools.Hour(), tz=tz)
-        self.assert_(not dr.tz_validate())
-
-        # UTC is OK
-        dr = date_range(datetime(2011, 3, 13), periods=48,
-                        freq=datetools.Minute(30), tz=pytz.utc)
-        self.assert_(dr.tz_validate())
-
     def test_summary(self):
         self.rng.summary()
         self.rng[2:2].summary()
         try:
+            import pytz
             bdate_range('1/1/2005', '1/1/2009', tz=pytz.utc).summary()
         except Exception:
             pass
@@ -319,29 +254,6 @@ class TestDateRange(unittest.TestCase):
         assert dr[0] == firstDate
         assert dr[-1] == end
 
-    # test utility methods
-    def test_infer_tz(self):
-        _skip_if_no_pytz()
-        eastern = pytz.timezone('US/Eastern')
-        utc = pytz.utc
-
-        _start = datetime(2001, 1, 1)
-        _end = datetime(2009, 1, 1)
-
-        start = eastern.localize(_start)
-        end = eastern.localize(_end)
-        assert(tools._infer_tzinfo(start, end) is eastern)
-        assert(tools._infer_tzinfo(start, None) is eastern)
-        assert(tools._infer_tzinfo(None, end) is eastern)
-
-        start = utc.localize(_start)
-        end = utc.localize(_end)
-        assert(tools._infer_tzinfo(start, end) is utc)
-
-        end = eastern.localize(_end)
-        self.assertRaises(Exception, tools._infer_tzinfo, start, end)
-        self.assertRaises(Exception, tools._infer_tzinfo, end, start)
-
     def test_date_parse_failure(self):
         badly_formed_date = '2007/100/1'
         self.assertRaises(ValueError, bdate_range, start=badly_formed_date,
@@ -377,13 +289,6 @@ class TestDateRange(unittest.TestCase):
         self.assert_(np.array_equal(result, DatetimeIndex(exp_values)))
 
 
-def _skip_if_no_pytz():
-    try:
-        import pytz
-    except ImportError:
-        import nose
-        raise nose.SkipTest
-
 
 if __name__ == '__main__':
     import nose
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 76c5180be..970cb753a 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -33,11 +33,6 @@ import pandas.core.common as com
 NaT = lib.NaT
 
 
-try:
-    import pytz
-except ImportError:
-    pass
-
 class TestTimeSeriesDuplicates(unittest.TestCase):
 
     def setUp(self):
@@ -491,14 +486,6 @@ class TestTimeSeries(unittest.TestCase):
         expected = ts[5:].asfreq('4H', method='ffill')
         assert_series_equal(result, expected)
 
-    def test_take_dont_lose_meta(self):
-        _skip_if_no_pytz()
-        rng = date_range('1/1/2000', periods=20, tz='US/Eastern')
-
-        result = rng.take(range(5))
-        self.assert_(result.tz == rng.tz)
-        self.assert_(result.freq == rng.freq)
-
     def test_date_range_gen_error(self):
         rng = date_range('1/1/2000 00:00', '1/1/2000 00:18', freq='5min')
         self.assertEquals(len(rng), 4)
@@ -627,14 +614,6 @@ def _simple_ts(start, end, freq='D'):
     return Series(np.random.randn(len(rng)), index=rng)
 
 
-def _skip_if_no_pytz():
-    try:
-        import pytz
-    except ImportError:
-        import nose
-        raise nose.SkipTest
-
-
 class TestLegacySupport(unittest.TestCase):
 
     @classmethod
@@ -902,77 +881,6 @@ class TestLegacySupport(unittest.TestCase):
         result = rng[:50].intersection(nofreq)
         self.assert_(result.freq == rng.freq)
 
-class TestTimeZones(unittest.TestCase):
-
-    def setUp(self):
-        _skip_if_no_pytz()
-
-    def test_index_equals_with_tz(self):
-        left = date_range('1/1/2011', periods=100, freq='H', tz='utc')
-        right = date_range('1/1/2011', periods=100, freq='H',
-                           tz='US/Eastern')
-
-        self.assert_(not left.equals(right))
-
-    def test_tz_normalize_naive(self):
-        rng = date_range('1/1/2011', periods=100, freq='H')
-
-        conv = rng.tz_normalize('US/Pacific')
-        exp = rng.tz_localize('US/Pacific')
-        self.assert_(conv.equals(exp))
-
-    def test_tz_convert(self):
-        rng = date_range('1/1/2011', periods=100, freq='H')
-        ts = Series(1, index=rng)
-
-        result = ts.tz_convert('utc')
-        self.assert_(result.index.tz.zone == 'UTC')
-
-    def test_join_utc_convert(self):
-        rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
-
-        left = rng.tz_normalize('US/Eastern')
-        right = rng.tz_normalize('Europe/Berlin')
-
-        for how in ['inner', 'outer', 'left', 'right']:
-            result = left.join(left[:-5], how=how)
-            self.assert_(isinstance(result, DatetimeIndex))
-            self.assert_(result.tz == left.tz)
-
-            result = left.join(right[:-5], how=how)
-            self.assert_(isinstance(result, DatetimeIndex))
-            self.assert_(result.tz.zone == 'UTC')
-
-    def test_arith_utc_convert(self):
-        rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
-
-        perm = np.random.permutation(100)[:90]
-        ts1 = Series(np.random.randn(90),
-                     index=rng.take(perm).tz_normalize('US/Eastern'))
-
-        perm = np.random.permutation(100)[:90]
-        ts2 = Series(np.random.randn(90),
-                     index=rng.take(perm).tz_normalize('Europe/Berlin'))
-
-        result = ts1 + ts2
-
-        uts1 = ts1.tz_convert('utc')
-        uts2 = ts2.tz_convert('utc')
-        expected = uts1 + uts2
-
-        self.assert_(result.index.tz == pytz.UTC)
-        assert_series_equal(result, expected)
-
-    def test_intersection(self):
-        rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
-
-        left = rng[10:90][::-1]
-        right = rng[20:80][::-1]
-
-        self.assert_(left.tz == rng.tz)
-        result = left.intersection(right)
-        self.assert_(result.tz == left.tz)
-
 
 class TestLegacyCompat(unittest.TestCase):
 
@@ -1091,47 +999,6 @@ class TestDatetime64(unittest.TestCase):
         s['1/2/2009':'2009-06-05'] = -3
         self.assert_((s[48:54] == -3).all())
 
-    def test_tz_localize(self):
-        _skip_if_no_pytz()
-        from pandas.core.datetools import Hour
-
-        dti = DatetimeIndex(start='1/1/2005', end='1/1/2005 0:00:30.256',
-                            freq='L')
-        tz = pytz.timezone('US/Eastern')
-        dti2 = dti.tz_localize(tz)
-
-        self.assert_((dti.values == dti2.values).all())
-
-        tz2 = pytz.timezone('US/Pacific')
-        dti3 = dti2.tz_normalize(tz2)
-
-        self.assert_((dti2.shift(-3, Hour()).values == dti3.values).all())
-
-        dti = DatetimeIndex(start='11/6/2011 1:59', end='11/6/2011 2:00',
-                            freq='L')
-        self.assertRaises(pytz.AmbiguousTimeError, dti.tz_localize, tz)
-
-        dti = DatetimeIndex(start='3/13/2011 1:59', end='3/13/2011 2:00',
-                            freq='L')
-        self.assertRaises(pytz.AmbiguousTimeError, dti.tz_localize, tz)
-
-    def test_asobject_tz_box(self):
-        _skip_if_no_pytz()
-        tz = pytz.timezone('US/Eastern')
-        index = DatetimeIndex(start='1/1/2005', periods=10, tz=tz,
-                              freq='B')
-
-        result = index.asobject
-        self.assert_(result[0].tz is tz)
-
-    def test_tz_string(self):
-        _skip_if_no_pytz()
-        result = date_range('1/1/2000', periods=10, tz='US/Eastern')
-        expected = date_range('1/1/2000', periods=10,
-                              tz=pytz.timezone('US/Eastern'))
-
-        self.assert_(result.equals(expected))
-
     def test_datetimeindex_constructor(self):
         arr = ['1/1/2005', '1/2/2005', 'Jn 3, 2005', '2005-01-04']
         self.assertRaises(Exception, DatetimeIndex, arr)
diff --git a/pandas/tseries/tests/test_timezones.py b/pandas/tseries/tests/test_timezones.py
new file mode 100644
index 000000000..a8a0ced48
--- /dev/null
+++ b/pandas/tseries/tests/test_timezones.py
@@ -0,0 +1,297 @@
+# pylint: disable-msg=E1101,W0612
+from __future__ import with_statement # for Python 2.5
+from datetime import datetime, time, timedelta
+import sys
+import os
+import unittest
+
+import nose
+
+import numpy as np
+
+from pandas import (Index, Series, TimeSeries, DataFrame, isnull,
+                    date_range, Timestamp)
+
+from pandas import DatetimeIndex, Int64Index, to_datetime
+
+from pandas.core.daterange import DateRange
+import pandas.core.datetools as datetools
+import pandas.tseries.offsets as offsets
+from pandas.tseries.index import bdate_range, date_range
+import pandas.tseries.tools as tools
+
+from pandas.util.testing import assert_series_equal, assert_almost_equal
+import pandas.util.testing as tm
+
+import pandas._tseries as lib
+import cPickle as pickle
+import pandas.core.datetools as dt
+from numpy.random import rand
+from pandas.util.testing import assert_frame_equal
+import pandas.util.py3compat as py3compat
+from pandas.core.datetools import BDay
+import pandas.core.common as com
+
+NaT = lib.NaT
+
+
+def _skip_if_no_pytz():
+    try:
+        import pytz
+    except ImportError:
+        raise nose.SkipTest
+
+try:
+    import pytz
+except ImportError:
+    pass
+
+
+class TestTimeZoneSupport(unittest.TestCase):
+
+    def setUp(self):
+        _skip_if_no_pytz()
+
+    def test_utc_to_local_no_modify(self):
+        rng = date_range('3/11/2012', '3/12/2012', freq='H', tz='utc')
+        rng_eastern = rng.tz_convert('US/Eastern')
+
+        # Values are unmodified
+        self.assert_(np.array_equal(rng.asi8, rng_eastern.asi8))
+
+        self.assert_(rng_eastern.tz == pytz.timezone('US/Eastern'))
+
+    def test_localize_utc_conversion(self):
+        # Localizing to time zone should:
+        #  1) check for DST ambiguities
+        #  2) convert to UTC
+
+        rng = date_range('3/10/2012', '3/11/2012', freq='30T')
+
+        converted = rng.tz_localize('US/Eastern')
+        expected_naive = rng + offsets.Hour(5)
+        self.assert_(np.array_equal(converted.asi8, expected_naive.asi8))
+
+        # DST ambiguity, this should fail
+        rng = date_range('3/11/2012', '3/12/2012', freq='30T')
+        self.assertRaises(Exception, rng.tz_localize, 'US/Eastern')
+
+    def test_tz_localize_dti(self):
+        from pandas.tseries.offsets import Hour
+
+        dti = DatetimeIndex(start='1/1/2005', end='1/1/2005 0:00:30.256',
+                            freq='L')
+        dti2 = dti.tz_localize('US/Eastern')
+
+        dti_utc = DatetimeIndex(start='1/1/2005 05:00',
+                                end='1/1/2005 5:00:30.256', freq='L',
+                                tz='utc')
+
+        self.assert_(np.array_equal(dti2.values, dti_utc.values))
+
+        dti3 = dti2.tz_convert('US/Pacific')
+        self.assert_(np.array_equal(dti3.values, dti_utc.values))
+
+        dti = DatetimeIndex(start='11/6/2011 1:59',
+                            end='11/6/2011 2:00', freq='L')
+        self.assertRaises(pytz.AmbiguousTimeError, dti.tz_localize,
+                          'US/Eastern')
+
+        dti = DatetimeIndex(start='3/13/2011 1:59', end='3/13/2011 2:00',
+                            freq='L')
+        self.assertRaises(pytz.AmbiguousTimeError, dti.tz_localize,
+                          'US/Eastern')
+
+    def test_utc_box_timestamp_and_localize(self):
+        rng = date_range('3/11/2012', '3/12/2012', freq='H', tz='utc')
+        rng = rng.tz_convert('US/Eastern')
+
+        # TODO
+
+    def test_pass_dates_convert_to_utc(self):
+        pass
+
+    def test_field_access_localize(self):
+        pass
+
+    def test_with_tz(self):
+        tz = pytz.timezone('US/Central')
+
+        # just want it to work
+        start = datetime(2011, 3, 12, tzinfo=pytz.utc)
+        dr = bdate_range(start, periods=50, freq=datetools.Hour())
+        self.assert_(dr.tz is not None)
+        self.assert_(dr.tz is start.tzinfo)
+
+        # DateRange with naive datetimes
+        dr = bdate_range('1/1/2005', '1/1/2009', tz=pytz.utc)
+        dr = bdate_range('1/1/2005', '1/1/2009', tz=tz)
+
+        # normalized
+        central = dr.tz_convert(tz)
+        self.assert_(central.tz is tz)
+        self.assert_(central[0].tz is tz)
+
+        # datetimes with tzinfo set
+        dr = bdate_range(datetime(2005, 1, 1, tzinfo=pytz.utc),
+                         '1/1/2009', tz=pytz.utc)
+
+        self.assertRaises(Exception, bdate_range,
+                          datetime(2005, 1, 1, tzinfo=pytz.utc),
+                          '1/1/2009', tz=tz)
+
+    def test_tz_localize(self):
+        dr = bdate_range('1/1/2009', '1/1/2010')
+        dr_utc = bdate_range('1/1/2009', '1/1/2010', tz=pytz.utc)
+        localized = dr.tz_localize(pytz.utc)
+        self.assert_(np.array_equal(dr_utc, localized))
+
+    def test_with_tz_ambiguous_times(self):
+        tz = pytz.timezone('US/Eastern')
+
+        rng = bdate_range(datetime(2009, 1, 1), datetime(2010, 1, 1))
+
+        # regular no problem
+        self.assert_(rng.tz_validate())
+
+        # March 13, 2011, spring forward, skip from 2 AM to 3 AM
+        dr = date_range(datetime(2011, 3, 13, 1, 30), periods=3,
+                        freq=datetools.Hour(), tz=tz)
+        self.assert_(not dr.tz_validate())
+
+        # after dst transition
+        dr = date_range(datetime(2011, 3, 13, 3, 30), periods=3,
+                        freq=datetools.Hour(), tz=tz)
+        self.assert_(dr.tz_validate())
+
+        # November 6, 2011, fall back, repeat 2 AM hour
+        dr = date_range(datetime(2011, 11, 6, 1, 30), periods=3,
+                        freq=datetools.Hour(), tz=tz)
+        self.assert_(not dr.tz_validate())
+
+        # UTC is OK
+        dr = date_range(datetime(2011, 3, 13), periods=48,
+                        freq=datetools.Minute(30), tz=pytz.utc)
+        self.assert_(dr.tz_validate())
+
+    # test utility methods
+    def test_infer_tz(self):
+        eastern = pytz.timezone('US/Eastern')
+        utc = pytz.utc
+
+        _start = datetime(2001, 1, 1)
+        _end = datetime(2009, 1, 1)
+
+        start = eastern.localize(_start)
+        end = eastern.localize(_end)
+        assert(tools._infer_tzinfo(start, end) is eastern)
+        assert(tools._infer_tzinfo(start, None) is eastern)
+        assert(tools._infer_tzinfo(None, end) is eastern)
+
+        start = utc.localize(_start)
+        end = utc.localize(_end)
+        assert(tools._infer_tzinfo(start, end) is utc)
+
+        end = eastern.localize(_end)
+        self.assertRaises(Exception, tools._infer_tzinfo, start, end)
+        self.assertRaises(Exception, tools._infer_tzinfo, end, start)
+
+    def test_asobject_tz_box(self):
+        tz = pytz.timezone('US/Eastern')
+        index = DatetimeIndex(start='1/1/2005', periods=10, tz=tz,
+                              freq='B')
+
+        result = index.asobject
+        self.assert_(result[0].tz is tz)
+
+    def test_tz_string(self):
+        result = date_range('1/1/2000', periods=10, tz='US/Eastern')
+        expected = date_range('1/1/2000', periods=10,
+                              tz=pytz.timezone('US/Eastern'))
+
+        self.assert_(result.equals(expected))
+
+    def test_take_dont_lose_meta(self):
+        _skip_if_no_pytz()
+        rng = date_range('1/1/2000', periods=20, tz='US/Eastern')
+
+        result = rng.take(range(5))
+        self.assert_(result.tz == rng.tz)
+        self.assert_(result.freq == rng.freq)
+
+
+class TestTimeZones(unittest.TestCase):
+
+    def setUp(self):
+        _skip_if_no_pytz()
+
+    def test_index_equals_with_tz(self):
+        left = date_range('1/1/2011', periods=100, freq='H', tz='utc')
+        right = date_range('1/1/2011', periods=100, freq='H',
+                           tz='US/Eastern')
+
+        self.assert_(not left.equals(right))
+
+    def test_tz_convert_naive(self):
+        rng = date_range('1/1/2011', periods=100, freq='H')
+
+        conv = rng.tz_convert('US/Pacific')
+        exp = rng.tz_localize('US/Pacific')
+        self.assert_(conv.equals(exp))
+
+    def test_tz_convert(self):
+        rng = date_range('1/1/2011', periods=100, freq='H')
+        ts = Series(1, index=rng)
+
+        result = ts.tz_convert('utc')
+        self.assert_(result.index.tz.zone == 'UTC')
+
+    def test_join_utc_convert(self):
+        rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
+
+        left = rng.tz_convert('US/Eastern')
+        right = rng.tz_convert('Europe/Berlin')
+
+        for how in ['inner', 'outer', 'left', 'right']:
+            result = left.join(left[:-5], how=how)
+            self.assert_(isinstance(result, DatetimeIndex))
+            self.assert_(result.tz == left.tz)
+
+            result = left.join(right[:-5], how=how)
+            self.assert_(isinstance(result, DatetimeIndex))
+            self.assert_(result.tz.zone == 'UTC')
+
+    def test_arith_utc_convert(self):
+        rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
+
+        perm = np.random.permutation(100)[:90]
+        ts1 = Series(np.random.randn(90),
+                     index=rng.take(perm).tz_convert('US/Eastern'))
+
+        perm = np.random.permutation(100)[:90]
+        ts2 = Series(np.random.randn(90),
+                     index=rng.take(perm).tz_convert('Europe/Berlin'))
+
+        result = ts1 + ts2
+
+        uts1 = ts1.tz_convert('utc')
+        uts2 = ts2.tz_convert('utc')
+        expected = uts1 + uts2
+
+        self.assert_(result.index.tz == pytz.UTC)
+        assert_series_equal(result, expected)
+
+    def test_intersection(self):
+        rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
+
+        left = rng[10:90][::-1]
+        right = rng[20:80][::-1]
+
+        self.assert_(left.tz == rng.tz)
+        result = left.intersection(right)
+        self.assert_(result.tz == left.tz)
+
+
+if __name__ == '__main__':
+    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
+                   exit=False)

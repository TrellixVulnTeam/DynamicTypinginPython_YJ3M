commit 285622f74019ea97240747acf69b9df459b9414e
Author: Jeffrey Tratner <jeffrey.tratner@gmail.com>
Date:   Sat Jun 29 10:17:27 2013 -0400

    ENH: Index inherits from FrozenNDArray + add FrozenList
    
    * `FrozenNDArray` - thin wrapper around ndarray that disallows setting methods
      (will be used for levels on `MultiIndex`)
    * `FrozenList` - thin wrapper around list that disallows setting methods
      (needed because of type checks elsewhere)
    
    Index inherits from FrozenNDArray now and also actually copies for deepcopy.
    Assumption is that underlying array is still immutable-ish

diff --git a/pandas/core/base.py b/pandas/core/base.py
index 16fe28a80..e63584424 100644
--- a/pandas/core/base.py
+++ b/pandas/core/base.py
@@ -1,7 +1,8 @@
 """
-Base class(es) for all pandas objects.
+Base and utility classes for pandas objects.
 """
 from pandas import compat
+import numpy as np
 
 class StringMixin(object):
     """implements string methods so long as object defines a `__unicode__` method.
@@ -56,3 +57,88 @@ class PandasObject(StringMixin):
         """
         # Should be overwritten by base classes
         return object.__repr__(self)
+
+class FrozenList(PandasObject, list):
+    """
+    Container that doesn't allow setting item *but*
+    because it's technically non-hashable, will be used
+    for lookups, appropriately, etc.
+    """
+    # Sidenote: This has to be of type list, otherwise it messes up PyTables typechecks
+
+    def __add__(self, other):
+        if isinstance(other, tuple):
+            other = list(other)
+        return self.__class__(super(FrozenList, self).__add__(other))
+
+    __iadd__ = __add__
+
+    # Python 2 compat
+    def __getslice__(self, i, j):
+        return self.__class__(super(FrozenList, self).__getslice__(i, j))
+
+    def __getitem__(self, n):
+        # Python 3 compat
+        if isinstance(n, slice):
+            return self.__class__(super(FrozenList, self).__getitem__(n))
+        return super(FrozenList, self).__getitem__(n)
+
+    def __radd__(self, other):
+        if isinstance(other, tuple):
+            other = list(other)
+        return self.__class__(other + list(self))
+
+    def __eq__(self, other):
+        if isinstance(other, (tuple, FrozenList)):
+            other = list(other)
+        return super(FrozenList, self).__eq__(other)
+
+    __req__ = __eq__
+
+    def __mul__(self, other):
+        return self.__class__(super(FrozenList, self).__mul__(other))
+
+    __imul__ = __mul__
+
+    def __hash__(self):
+        return hash(tuple(self))
+
+    def _disabled(self, *args, **kwargs):
+        """This method will not function because object is immutable."""
+        raise TypeError("'%s' does not support mutable operations." %
+                        self.__class__)
+
+    def __unicode__(self):
+        from pandas.core.common import pprint_thing
+        return "%s(%s)" % (self.__class__.__name__,
+                           pprint_thing(self, quote_strings=True,
+                                        escape_chars=('\t', '\r', '\n')))
+
+    __setitem__ = __setslice__ = __delitem__ = __delslice__ = _disabled
+    pop = append = extend = remove = sort = insert = _disabled
+
+
+class FrozenNDArray(PandasObject, np.ndarray):
+
+    # no __array_finalize__ for now because no metadata
+    def __new__(cls, data, dtype=None, copy=False):
+        if copy is None:
+            copy = not isinstance(data, FrozenNDArray)
+        res = np.array(data, dtype=dtype, copy=copy).view(cls)
+        return res
+
+    def _disabled(self, *args, **kwargs):
+        """This method will not function because object is immutable."""
+        raise TypeError("'%s' does not support mutable operations." %
+                        self.__class__)
+
+    __setitem__ = __setslice__ = __delitem__ = __delslice__ = _disabled
+    put = itemset = fill = _disabled
+
+    def _shallow_copy(self):
+        return self.view()
+
+    def values(self):
+        """returns *copy* of underlying array"""
+        arr = self.view(np.ndarray).copy()
+        return arr
diff --git a/pandas/core/common.py b/pandas/core/common.py
index 06ca3be45..9a90c6690 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -8,18 +8,16 @@ import csv
 
 from numpy.lib.format import read_array, write_array
 import numpy as np
-
 import pandas.algos as algos
 import pandas.lib as lib
 import pandas.tslib as tslib
 
 from pandas import compat
 from pandas.compat import StringIO, BytesIO, range, long, u, zip, map
-
-
 from pandas.core.config import get_option
 from pandas.core import array as pa
 
+
 # XXX: HACK for NumPy 1.5.1 to suppress warnings
 try:
     np.seterr(all='ignore')
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 15e9398bd..3e24788ec 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -9,7 +9,7 @@ import pandas.lib as lib
 import pandas.algos as _algos
 import pandas.index as _index
 from pandas.lib import Timestamp
-from pandas.core.base import PandasObject
+from pandas.core.base import FrozenList, FrozenNDArray
 
 from pandas.util.decorators import cache_readonly
 from pandas.core.common import isnull
@@ -47,7 +47,7 @@ def _shouldbe_timestamp(obj):
             or tslib.is_timestamp_array(obj))
 
 
-class Index(PandasObject, np.ndarray):
+class Index(FrozenNDArray):
     """
     Immutable ndarray implementing an ordered, sliceable set. The basic object
     storing axis labels for all pandas objects
@@ -313,7 +313,7 @@ class Index(PandasObject, np.ndarray):
         """
         Index is not mutable, so disabling deepcopy
         """
-        return self
+        return self._shallow_copy()
 
     def __contains__(self, key):
         hash(key)
@@ -326,9 +326,6 @@ class Index(PandasObject, np.ndarray):
     def __hash__(self):
         return hash(self.view(np.ndarray))
 
-    def __setitem__(self, key, value):
-        raise TypeError(str(self.__class__) + ' does not support item assignment')
-
     def __getitem__(self, key):
         """Override numpy.ndarray's __getitem__ method to work as desired"""
         arr_idx = self.view(np.ndarray)
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index d83fbd97b..d9a4196a6 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -817,7 +817,11 @@ c,4,5
         expected = self.read_csv(StringIO(data), sep=";", index_col=lrange(4))
 
         lev = expected.index.levels[0]
-        expected.index.levels[0] = lev.to_datetime(dayfirst=True)
+        levels = list(expected.index.levels)
+        levels[0] = lev.to_datetime(dayfirst=True)
+        # hack to get this to work - remove for final test
+        levels[0].name = lev.name
+        expected.index.levels = levels
         expected['aux_date'] = to_datetime(expected['aux_date'],
                                            dayfirst=True)
         expected['aux_date'] = lmap(Timestamp, expected['aux_date'])
@@ -2144,14 +2148,14 @@ a,b,c
 4,5,6
 7,8,9
 10,11,12"""
-        result = self.read_csv(StringIO(data), usecols=(0, 1, 2), 
-                               names=('a', 'b', 'c'), 
+        result = self.read_csv(StringIO(data), usecols=(0, 1, 2),
+                               names=('a', 'b', 'c'),
                                header=None,
                                converters={'a': str},
                                dtype={'b': int, 'c': float},
-                              )                               
+                              )
         result2 = self.read_csv(StringIO(data), usecols=(0, 2),
-                               names=('a', 'b', 'c'), 
+                               names=('a', 'b', 'c'),
                                header=None,
                                converters={'a': str},
                                dtype={'b': int, 'c': float},
diff --git a/pandas/tests/test_base.py b/pandas/tests/test_base.py
new file mode 100644
index 000000000..c6285bc95
--- /dev/null
+++ b/pandas/tests/test_base.py
@@ -0,0 +1,108 @@
+import re
+import unittest
+import numpy as np
+from pandas.core.base import FrozenList, FrozenNDArray
+from pandas.util.testing import assertRaisesRegexp, assert_isinstance
+
+
+class CheckImmutable(object):
+    mutable_regex = re.compile('does not support mutable operations')
+
+    def check_mutable_error(self, *args, **kwargs):
+        # pass whatever functions you normally would to assertRaises (after the Exception kind)
+        assertRaisesRegexp(TypeError, self.mutable_regex, *args, **kwargs)
+
+    def test_no_mutable_funcs(self):
+        def setitem(): self.container[0] = 5
+
+        self.check_mutable_error(setitem)
+
+        def setslice(): self.container[1:2] = 3
+
+        self.check_mutable_error(setslice)
+
+        def delitem(): del self.container[0]
+
+        self.check_mutable_error(delitem)
+
+        def delslice(): del self.container[0:3]
+
+        self.check_mutable_error(delslice)
+        mutable_methods = getattr(self, "mutable_methods", [])
+        for meth in mutable_methods:
+            self.check_mutable_error(getattr(self.container, meth))
+
+    def test_slicing_maintains_type(self):
+        result = self.container[1:2]
+        expected = self.lst[1:2]
+        self.check_result(result, expected)
+
+    def check_result(self, result, expected, klass=None):
+        klass = klass or self.klass
+        assert_isinstance(result, klass)
+        self.assertEqual(result, expected)
+
+
+class TestFrozenList(CheckImmutable, unittest.TestCase):
+    mutable_methods = ('extend', 'pop', 'remove', 'insert')
+
+    def setUp(self):
+        self.lst = [1, 2, 3, 4, 5]
+        self.container = FrozenList(self.lst)
+        self.klass = FrozenList
+
+    def test_add(self):
+        result = self.container + (1, 2, 3)
+        expected = FrozenList(self.lst + [1, 2, 3])
+        self.check_result(result, expected)
+
+        result = (1, 2, 3) + self.container
+        expected = FrozenList([1, 2, 3] + self.lst)
+        self.check_result(result, expected)
+
+    def test_inplace(self):
+        q = r = self.container
+        q += [5]
+        self.check_result(q, self.lst + [5])
+        # other shouldn't be mutated
+        self.check_result(r, self.lst)
+
+
+class TestFrozenNDArray(CheckImmutable, unittest.TestCase):
+    mutable_methods = ('put', 'itemset', 'fill')
+
+    def setUp(self):
+        self.lst = [3, 5, 7, -2]
+        self.container = FrozenNDArray(self.lst)
+        self.klass = FrozenNDArray
+
+    def test_shallow_copying(self):
+        original = self.container.copy()
+        assert_isinstance(self.container.view(), FrozenNDArray)
+        self.assert_(not isinstance(self.container.view(np.ndarray), FrozenNDArray))
+        self.assert_(self.container.view() is not self.container)
+        self.assert_(np.array_equal(self.container, original))
+        # shallow copy should be the same too
+        assert_isinstance(self.container._shallow_copy(), FrozenNDArray)
+        # setting should not be allowed
+        def testit(container): container[0] = 16
+
+        self.check_mutable_error(testit, self.container)
+
+    def test_values(self):
+        original = self.container.view(np.ndarray).copy()
+        n = original[0] + 15
+        vals = self.container.values()
+        self.assert_(np.array_equal(original, vals))
+        self.assert_(original is not vals)
+        vals[0] = n
+        self.assert_(np.array_equal(self.container, original))
+        self.assertEqual(vals[0], n)
+
+
+if __name__ == '__main__':
+    import nose
+
+    nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
+                   # '--with-coverage', '--cover-package=pandas.core'],
+                   exit=False)
diff --git a/pandas/tests/test_common.py b/pandas/tests/test_common.py
index abed2818c..3660b31b9 100644
--- a/pandas/tests/test_common.py
+++ b/pandas/tests/test_common.py
@@ -1,22 +1,21 @@
 from datetime import datetime
 import re
+import unittest
 
 import nose
 from nose.tools import assert_equal
 import unittest
+import numpy as np
+from pandas.tslib import iNaT
 
 from pandas import Series, DataFrame, date_range, DatetimeIndex, Timestamp
 from pandas.compat import range, long, lrange, lmap, u
 from pandas.core.common import notnull, isnull
+import pandas.compat as compat
 import pandas.core.common as com
 import pandas.util.testing as tm
 import pandas.core.config as cf
 
-import numpy as np
-
-from pandas.tslib import iNaT
-from pandas import compat
-
 _multiprocess_can_split_ = True
 
 
@@ -782,6 +781,7 @@ class TestTake(unittest.TestCase):
         expected[:, [2, 4]] = datetime(2007, 1, 1)
         tm.assert_almost_equal(result, expected)
 
+
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
                    exit=False)
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 5942f8cd9..7f889f464 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -57,7 +57,8 @@ class TestIndex(unittest.TestCase):
         from copy import deepcopy
 
         copy = deepcopy(self.strIndex)
-        self.assert_(copy is self.strIndex)
+        self.assert_(copy is not self.strIndex)
+        self.assert_(copy.equals(self.strIndex))
 
     def test_duplicates(self):
         idx = Index([0, 0, 0])

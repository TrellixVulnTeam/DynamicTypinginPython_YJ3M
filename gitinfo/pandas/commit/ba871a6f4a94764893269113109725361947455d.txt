commit ba871a6f4a94764893269113109725361947455d
Author: Phillip Cloud <cpcloud@gmail.com>
Date:   Sun Jan 26 13:20:48 2014 -0500

    TST: add a test for columns with nested strings

diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 487bc49c6..d654a7a20 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -12603,6 +12603,7 @@ class TestDataFrameQueryPythonPandas(TestDataFrameQueryNumExprPandas):
         cls.parser = 'pandas'
         cls.frame = _frame.copy()
 
+
 class TestDataFrameQueryPythonPython(TestDataFrameQueryNumExprPython):
 
     @classmethod
@@ -12611,6 +12612,7 @@ class TestDataFrameQueryPythonPython(TestDataFrameQueryNumExprPython):
         cls.engine = cls.parser = 'python'
         cls.frame = _frame.copy()
 
+
 PARSERS = 'python', 'pandas'
 ENGINES = 'python', 'numexpr'
 
@@ -12742,6 +12744,34 @@ class TestDataFrameQueryStrings(object):
         for parser, engine in product(PARSERS, ENGINES):
             yield self.check_object_array_eq_ne, parser, engine
 
+    def check_query_with_nested_strings(self, parser, engine):
+        skip_if_no_ne(engine)
+        skip_if_no_pandas_parser(parser)
+        from pandas.compat import StringIO
+        raw = """id          event          timestamp
+        1   "page 1 load"   1/1/2014 0:00:01
+        1   "page 1 exit"   1/1/2014 0:00:31
+        2   "page 2 load"   1/1/2014 0:01:01
+        2   "page 2 exit"   1/1/2014 0:01:31
+        3   "page 3 load"   1/1/2014 0:02:01
+        3   "page 3 exit"   1/1/2014 0:02:31
+        4   "page 1 load"   2/1/2014 1:00:01
+        4   "page 1 exit"   2/1/2014 1:00:31
+        5   "page 2 load"   2/1/2014 1:01:01
+        5   "page 2 exit"   2/1/2014 1:01:31
+        6   "page 3 load"   2/1/2014 1:02:01
+        6   "page 3 exit"   2/1/2014 1:02:31
+        """
+        df = pd.read_csv(StringIO(raw), sep=r'\s{2,}',
+                         parse_dates=['timestamp'])
+        expected = df[df.event == '"page 1 load"']
+        res = df.query("""'"page 1 load"' in event""", parser=parser,
+                       engine=engine)
+        tm.assert_frame_equal(expected, res)
+
+    def test_query_with_nested_string(self):
+        for parser, engine in product(PARSERS, ENGINES):
+            yield self.check_query_with_nested_strings, parser, engine
 
 class TestDataFrameEvalNumExprPandas(tm.TestCase):
 
@@ -12779,6 +12809,7 @@ class TestDataFrameEvalNumExprPython(TestDataFrameEvalNumExprPandas):
         cls.parser = 'python'
         skip_if_no_ne()
 
+
 class TestDataFrameEvalPythonPandas(TestDataFrameEvalNumExprPandas):
 
     @classmethod
@@ -12787,6 +12818,7 @@ class TestDataFrameEvalPythonPandas(TestDataFrameEvalNumExprPandas):
         cls.engine = 'python'
         cls.parser = 'pandas'
 
+
 class TestDataFrameEvalPythonPython(TestDataFrameEvalNumExprPython):
 
     @classmethod
@@ -12794,6 +12826,7 @@ class TestDataFrameEvalPythonPython(TestDataFrameEvalNumExprPython):
         super(TestDataFrameEvalPythonPython, cls).tearDownClass()
         cls.engine = cls.parser = 'python'
 
+
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
                    exit=False)

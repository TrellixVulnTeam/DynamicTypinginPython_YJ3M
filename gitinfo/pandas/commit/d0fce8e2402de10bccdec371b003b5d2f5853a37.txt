commit d0fce8e2402de10bccdec371b003b5d2f5853a37
Author: jreback <jeff@reback.net>
Date:   Thu Nov 29 09:56:47 2012 -0500

    added a min_itemsize example to the docs
    min_itemsize can be passed as a dict

diff --git a/doc/source/io.rst b/doc/source/io.rst
index 5785a014f..14b0538c6 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -855,7 +855,6 @@ after data is already in the table (this may become automatic in the future or a
    df2 = df[4:]
    store.append('df', df1)
    store.append('df', df2)
-   store.append('wp', wp)
    store
 
    store.select('df')
@@ -866,16 +865,27 @@ after data is already in the table (this may become automatic in the future or a
    store.create_table_index('df')
    store.handle.root.df.table
 
+Storing Mixed Types in a Table
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Storing mixed-dtype data is supported. Strings are store as a fixed-width using the maximum size of the appended column. Subsequent appends will truncate strings at this length.
+Passing ``min_itemsize = { column_name : size }`` as a paremeter to append will set a larger minimum for the column. Storing ``floats, strings, ints, bools`` are currently supported.
+
 .. ipython:: python
-   :suppress:
+       
+    df_mixed             = df.copy()     
+    df_mixed['string']   = 'string'
+    df_mixed['int']      = 1
+    df_mixed['bool']     = True
 
-   store.close()
-   import os
-   os.remove('store.h5')
+    store.append('df_mixed',df_mixed)
+    df_mixed1 = store.select('df_mixed')	    
+    df_mixed1
+    df_mixed1.get_dtype_counts()
 
 
-Querying objects stored in Table format
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+Querying a Table
+~~~~~~~~~~~~~~~~
 
 ``select`` and ``delete`` operations have an optional criteria that can be specified to select/delete only
 a subset of the data. This allows one to have a very large on-disk table and retrieve only a portion of the data.
@@ -900,32 +910,32 @@ Queries are built up using a list of ``Terms`` (currently only **anding** of ter
 
 .. ipython:: python
 
-   store = HDFStore('store.h5')
    store.append('wp',wp)
    store.select('wp',[ 'major_axis>20000102', ('minor_axis', '=', ['A','B']) ])
 
-Delete from objects stored in Table format
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+Delete from a Table
+~~~~~~~~~~~~~~~~~~~
 
 .. ipython:: python
 
    store.remove('wp', 'index>20000102' )
    store.select('wp')
 
-.. ipython:: python
-   :suppress:
-
-   store.close()
-   import os
-   os.remove('store.h5')
-
 Notes & Caveats
 ~~~~~~~~~~~~~~~
 
    - Selection by items (the top level panel dimension) is not possible; you always get all of the items in the returned Panel
-   - ``PyTables`` only supports fixed-width string columns in ``tables``. The sizes of a string based indexing column (e.g. *index* or *minor_axis*) are determined as the maximum size of the elements in that axis or by passing the ``min_itemsize`` on the first table creation. If subsequent appends introduce elements in the indexing axis that are larger than the supported indexer, an Exception will be raised (otherwise you could have a silent truncation of these indexers, leading to loss of information).
    - Once a ``table`` is created its items (Panel) / columns (DataFrame) are fixed; only exactly the same columns can be appended
    - You can not append/select/delete to a non-table (table creation is determined on the first append, or by passing ``table=True`` in a put operation)
+   - ``PyTables`` only supports fixed-width string columns in ``tables``. The sizes of a string based indexing column (e.g. *column* or *minor_axis*) are determined as the maximum size of the elements in that axis or by passing the parameter ``min_itemsize`` on the first table creation (``min_itemsize`` can be an integer or a dict of column name to an integer). If subsequent appends introduce elements in the indexing axis that are larger than the supported indexer, an Exception will be raised (otherwise you could have a silent truncation of these indexers, leading to loss of information). This is **ONLY** necessary for storing ``Panels`` (as the indexing column is stored directly in a column)
+
+     .. ipython:: python
+
+        store.append('wp_big_strings', wp, min_itemsize = 30)
+	wp = wp.rename_axis(lambda x: x + '_big_strings', axis=2)
+        store.append('wp_big_strings', wp)
+        store.select('wp_big_strings')
+
 
 Performance
 ~~~~~~~~~~~
@@ -943,3 +953,10 @@ Performance
    - ``Tables`` offer better performance when compressed after writing them (as opposed to turning on compression at the very beginning)
      use the pytables utilities ``ptrepack`` to rewrite the file (and also can change compression methods)
    - Duplicate rows can be written, but are filtered out in selection (with the last items being selected; thus a table is unique on major, minor pairs)
+
+.. ipython:: python
+   :suppress:
+
+   store.close()
+   import os
+   os.remove('store.h5')
diff --git a/doc/source/v0.10.0.txt b/doc/source/v0.10.0.txt
index 7bfd89567..2571cf716 100644
--- a/doc/source/v0.10.0.txt
+++ b/doc/source/v0.10.0.txt
@@ -63,7 +63,7 @@ Updated PyTables Support
 
   **Enhancements**
 
-       - added multi-dtype support!
+       - added mixed-dtype support!
 
           .. ipython:: python
             
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 1f8891ae6..371d2697c 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -890,9 +890,14 @@ class Col(object):
         return iter(self.values)
 
     def maybe_set_size(self, min_itemsize = None, **kwargs):
-        """ maybe set a string col itemsize """
-        if self.kind == 'string' and min_itemsize is not None:
-            if self.typ.itemsize < min_itemsize:
+        """ maybe set a string col itemsize:
+               min_itemsize can be an interger or a dict with this columns name with an integer size """
+        if self.kind == 'string':
+
+            if isinstance(min_itemsize, dict):
+                min_itemsize = min_itemsize.get(self.name)
+
+            if min_itemsize is not None and self.typ.itemsize < min_itemsize:
                 self.typ = _tables().StringCol(itemsize = min_itemsize, pos = getattr(self.typ,'pos',None))
 
     def validate_and_set(self, table, append, **kwargs):
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index 8a21f0a44..ca2ea2e70 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -12,7 +12,7 @@ from pandas.io.pytables import HDFStore, get_store, Term
 import pandas.util.testing as tm
 from pandas.tests.test_series import assert_series_equal
 from pandas.tests.test_frame import assert_frame_equal
-from pandas import concat
+from pandas import concat, Timestamp
 
 try:
     import tables
@@ -177,9 +177,20 @@ class TestHDFStore(unittest.TestCase):
         expected = expected.reindex(minor_axis = sorted(expected.minor_axis))
         tm.assert_panel_equal(self.store['s1'], expected)
 
+        # test dict format
+        self.store.append('s2', wp, min_itemsize = { 'column' : 20 })
+        self.store.append('s2', wp2)
+        expected = concat([ wp, wp2], axis = 2)
+        expected = expected.reindex(minor_axis = sorted(expected.minor_axis))
+        tm.assert_panel_equal(self.store['s2'], expected)
+
+        # apply the wrong field (similar to #1)
+        self.store.append('s3', wp, min_itemsize = { 'index' : 20 })
+        self.assertRaises(Exception, self.store.append, 's3')
+
         # test truncation of bigger strings
-        self.store.append('s2', wp)
-        self.assertRaises(Exception, self.store.append, 's2', wp2)
+        self.store.append('s4', wp)
+        self.assertRaises(Exception, self.store.append, 's4', wp2)
 
     def test_create_table_index(self):
         wp = tm.makePanel()
@@ -245,6 +256,7 @@ class TestHDFStore(unittest.TestCase):
             df['obj2'] = 'bar'
             df['bool1'] = df['A'] > 0
             df['bool2'] = df['B'] > 0
+            df['bool3'] = True
             df['int1'] = 1
             df['int2'] = 2
             return df.consolidate()

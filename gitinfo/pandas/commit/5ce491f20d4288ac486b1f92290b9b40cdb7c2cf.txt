commit 5ce491f20d4288ac486b1f92290b9b40cdb7c2cf
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Dec 29 21:34:16 2011 -0500

    ENH: inner merge working, testing

diff --git a/pandas/src/join.pyx b/pandas/src/join.pyx
index e06a55af5..0c0f13fbc 100644
--- a/pandas/src/join.pyx
+++ b/pandas/src/join.pyx
@@ -1,7 +1,53 @@
 
-def inner_join(ndarray[int32_t] left, ndarray[int32_t] right):
+def inner_join(ndarray[int32_t] left, ndarray[int32_t] right,
+               Py_ssize_t max_groups):
     cdef:
-        Py_ssize_t count
+        Py_ssize_t i, j, k, count = 0
+        ndarray[int32_t] left_count, right_count, left_sorter, right_sorter
+        ndarray[int32_t] left_indexer, right_indexer
+        int32_t lc, rc
+
+    # NA group in location 0
+
+    left_sorter, left_count = groupsort_indexer(left, max_groups)
+    right_sorter, right_count = groupsort_indexer(right, max_groups)
+
+    # First pass, determine size of result set, do not use the NA group
+    for i in range(1, max_groups + 1):
+        lc = left_count[i]
+        rc = right_count[i]
+
+        if rc > 0 and lc > 0:
+            count += lc * rc
+
+    # group 0 is the NA group
+    cdef:
+        Py_ssize_t loc, left_pos = 0, right_pos = 0, position = 0
+        Py_ssize_t offset
+
+    # exclude the NA group
+    left_pos = left_count[0]
+    right_pos = right_count[0]
+
+    left_indexer = np.empty(count, dtype='i4')
+    right_indexer = np.empty(count, dtype='i4')
+
+    for i in range(1, max_groups + 1):
+        lc = left_count[i]
+        rc = right_count[i]
+
+        if rc > 0 and lc > 0:
+            for j in range(lc):
+                offset = position + j * rc
+                for k in range(rc):
+                    left_indexer[offset + k] = left_pos + j
+                    right_indexer[offset + k] = right_pos + k
+            position += lc * rc
+        left_pos += lc
+        right_pos += rc
+
+    return (_get_result_indexer(left_sorter, left_indexer),
+            _get_result_indexer(right_sorter, right_indexer))
 
 def left_outer_join(ndarray[int32_t] left, ndarray[int32_t] right,
                     Py_ssize_t max_groups):
@@ -23,12 +69,6 @@ def left_outer_join(ndarray[int32_t] left, ndarray[int32_t] right,
         else:
             count += left_count[i]
 
-    left_indexer = np.empty(count, dtype='i4')
-    right_indexer = np.empty(count, dtype='i4')
-
-    left = left.take(left_sorter)
-    right = right.take(right_sorter)
-
     # group 0 is the NA group
     cdef:
         Py_ssize_t loc, left_pos = 0, right_pos = 0, position = 0
@@ -38,6 +78,9 @@ def left_outer_join(ndarray[int32_t] left, ndarray[int32_t] right,
     left_pos = left_count[0]
     right_pos = right_count[0]
 
+    left_indexer = np.empty(count, dtype='i4')
+    right_indexer = np.empty(count, dtype='i4')
+
     for i in range(1, max_groups + 1):
         lc = left_count[i]
         rc = right_count[i]
@@ -46,7 +89,6 @@ def left_outer_join(ndarray[int32_t] left, ndarray[int32_t] right,
             for j in range(lc):
                 left_indexer[position + j] = left_pos + j
                 right_indexer[position + j] = -1
-            left_pos += lc
             position += lc
         else:
             for j in range(lc):
@@ -54,22 +96,80 @@ def left_outer_join(ndarray[int32_t] left, ndarray[int32_t] right,
                 for k in range(rc):
                     left_indexer[offset + k] = left_pos + j
                     right_indexer[offset + k] = right_pos + k
-            left_pos += lc
-            right_pos += rc
             position += lc * rc
+        left_pos += lc
+        right_pos += rc
 
-    res_left = left_sorter.take(left_indexer)
-    np.putmask(res_left, left_indexer == -1, -1)
+    return (_get_result_indexer(left_sorter, left_indexer),
+            _get_result_indexer(right_sorter, right_indexer))
 
-    res_right = right_sorter.take(right_indexer)
-    np.putmask(res_right, right_indexer == -1, -1)
 
-    return res_left, res_right
+def full_outer_join(ndarray[int32_t] left, ndarray[int32_t] right,
+                    Py_ssize_t max_groups):
+    cdef:
+        Py_ssize_t i, j, k, count = 0
+        ndarray[int32_t] left_count, right_count, left_sorter, right_sorter
+        ndarray[int32_t] left_indexer, right_indexer
+        int32_t lc, rc
+
+    # NA group in location 0
+
+    left_sorter, left_count = groupsort_indexer(left, max_groups)
+    right_sorter, right_count = groupsort_indexer(right, max_groups)
+
+    # First pass, determine size of result set, do not use the NA group
+    for i in range(1, max_groups + 1):
+        lc = left_count[i]
+        rc = right_count[i]
+
+        if rc > 0 and lc > 0:
+            count += lc * rc
+        else:
+            count += lc + rc
+
+    # group 0 is the NA group
+    cdef:
+        Py_ssize_t loc, left_pos = 0, right_pos = 0, position = 0
+        Py_ssize_t offset
 
+    # exclude the NA group
+    left_pos = left_count[0]
+    right_pos = right_count[0]
+
+    left_indexer = np.empty(count, dtype='i4')
+    right_indexer = np.empty(count, dtype='i4')
+
+    for i in range(1, max_groups + 1):
+        lc = left_count[i]
+        rc = right_count[i]
+
+        if rc == 0:
+            for j in range(lc):
+                left_indexer[position + j] = left_pos + j
+                right_indexer[position + j] = -1
+            position += lc
+        elif lc == 0:
+            for j in range(rc):
+                left_indexer[position + j] = -1
+                right_indexer[position + j] = right_pos + j
+            position += rc
+        else:
+            for j in range(lc):
+                offset = position + j * rc
+                for k in range(rc):
+                    left_indexer[offset + k] = left_pos + j
+                    right_indexer[offset + k] = right_pos + k
+            position += lc * rc
+        left_pos += lc
+        right_pos += rc
 
-def full_outer_join(ndarray[int32_t] left, ndarray[int32_t] right):
-    pass
+    return (_get_result_indexer(left_sorter, left_indexer),
+            _get_result_indexer(right_sorter, right_indexer))
 
+def _get_result_indexer(sorter, indexer):
+    res = sorter.take(indexer)
+    np.putmask(res, indexer == -1, -1)
+    return res
 
 @cython.boundscheck(False)
 @cython.wraparound(False)
diff --git a/pandas/src/sandbox.pyx b/pandas/src/sandbox.pyx
index ce34d33b2..96d827a95 100644
--- a/pandas/src/sandbox.pyx
+++ b/pandas/src/sandbox.pyx
@@ -175,5 +175,4 @@ def roll_median(ndarray[float64_t] arg, int win, int minp):
     return output
 
 include "hashtable.pyx"
-
 include "join.pyx"
diff --git a/pandas/tools/merge.py b/pandas/tools/merge.py
index bb4d3f380..533857dcb 100644
--- a/pandas/tools/merge.py
+++ b/pandas/tools/merge.py
@@ -74,8 +74,8 @@ class _MergeOperation(object):
                  left_on=None, right_on=None,
                  left_index=False, right_index=False, sort=True,
                  suffixes=('.x', '.y'), copy=True):
-        self.left = left
-        self.right = right
+        self.left = self.orig_left = left
+        self.right = self.orig_right = right
         self.how = how
 
         self.on = _maybe_make_list(on)
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index 42921925c..0821378ee 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -10,7 +10,7 @@ import pandas._sandbox as sbx
 
 a_ = np.array
 
-N = 100
+N = 50
 NGROUPS = 8
 
 def get_test_data(ngroups=NGROUPS, n=N):
@@ -136,13 +136,21 @@ class TestMerge(unittest.TestCase):
         _check_join(self.df, self.df2, joined_both, ['key1', 'key2'],
                     how='right')
 
-    # def test_full_outer_join(self):
-    #     joined_key2 = merge(self.df, self.df2, on='key2', how='outer')
-    #     _check_join(self.df, self.df2, joined_key2, ['key2'], how='outer')
+    def test_full_outer_join(self):
+        joined_key2 = merge(self.df, self.df2, on='key2', how='outer')
+        _check_join(self.df, self.df2, joined_key2, ['key2'], how='outer')
 
-    #     joined_both = merge(self.df, self.df2, how='outer')
-    #     _check_join(self.df, self.df2, joined_both, ['key1', 'key2'],
-    #                 how='outer')
+        joined_both = merge(self.df, self.df2, how='outer')
+        _check_join(self.df, self.df2, joined_both, ['key1', 'key2'],
+                    how='outer')
+
+    def test_inner_join(self):
+        joined_key2 = merge(self.df, self.df2, on='key2', how='inner')
+        _check_join(self.df, self.df2, joined_key2, ['key2'], how='inner')
+
+        joined_both = merge(self.df, self.df2, how='inner')
+        _check_join(self.df, self.df2, joined_both, ['key1', 'key2'],
+                    how='inner')
 
     def test_handle_overlap(self):
         pass
@@ -170,7 +178,7 @@ def _check_join(left, right, result, join_col, how='left',
         try:
             lgroup = left_grouped.get_group(group_key)
         except KeyError:
-            if how == 'left':
+            if how in ('left', 'inner'):
                 raise AssertionError('key %s should not have been in the join'
                                      % str(group_key))
 
@@ -181,7 +189,7 @@ def _check_join(left, right, result, join_col, how='left',
         try:
             rgroup = right_grouped.get_group(group_key)
         except KeyError:
-            if how == 'right':
+            if how in ('right', 'inner'):
                 raise AssertionError('key %s should not have been in the join'
                                      % str(group_key))
 

commit 73ec315cac2dd1f56b7c51009087e826b3b1a5ba
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Apr 27 02:48:47 2010 +0000

    test coverage
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@162 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index fc8f57531..306dd911e 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -11,7 +11,7 @@ from pandas.core.common import _pfixed, _pickle_array, _unpickle_array
 from pandas.core.frame import DataFrame, _try_sort
 from pandas.core.index import Index, NULL_INDEX
 from pandas.core.series import Series
-from pandas.lib.tseries import isnull, notnull
+from pandas.lib.tseries import isnull
 import pandas.core.datetools as datetools
 import pandas.lib.tseries as tseries
 
@@ -264,17 +264,24 @@ class DataMatrix(DataFrame):
                                            self.index.indexMap,
                                            index.indexMap, method)
 
-        tmpMatrix = self.values.take(fillVec, axis=0)
+        mat = self.values.take(fillVec, axis=0)
+
+        notmask = -mask
         if len(index) > 0:
-            tmpMatrix[-mask] = NaN
+            if notmask.any():
+                if issubclass(mat.dtype.type, np.int_):
+                    mat = mat.astype(float)
+                elif issubclass(mat.dtype.type, np.bool_):
+                    mat = mat.astype(object)
+
+                mat[-mask] = NaN
 
         if self.objects is not None and len(self.objects.columns) > 0:
             newObjects = self.objects.reindex(index)
         else:
             newObjects = None
 
-        return DataMatrix(tmpMatrix, index=index,
-                          columns=self.columns,
+        return DataMatrix(mat, index=index, columns=self.columns,
                           objects=newObjects)
 
     def _reindex_columns(self, columns):
@@ -300,11 +307,19 @@ class DataMatrix(DataFrame):
                                            self.columns.indexMap,
                                            columns.indexMap, None)
 
-        newValues = self.values.take(indexer, axis=1)
+        mat = self.values.take(indexer, axis=1)
+
+        notmask = -mask
         if len(mask) > 0:
-            newValues[:, -mask] = NaN
+            if notmask.any():
+                if issubclass(mat.dtype.type, np.int_):
+                    mat = mat.astype(float)
+                elif issubclass(mat.dtype.type, np.bool_):
+                    mat = mat.astype(object)
+
+                mat[:, -mask] = NaN
 
-        return DataMatrix(newValues, index=self.index, columns=columns,
+        return DataMatrix(mat, index=self.index, columns=columns,
                           objects=objects)
 
     def _rename_columns_inplace(self, mapper):
@@ -843,7 +858,7 @@ class DataMatrix(DataFrame):
         print >> buffer, 'Data columns:'
         space = max([len(str(k)) for k in self.cols()]) + 4
 
-        counts = self.apply(notnull).sum(0)
+        counts = self.count()
 
         columns = []
         for j, col in enumerate(self.columns):
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 6ab70ec69..d01db62b0 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -941,6 +941,28 @@ class WidePanel(Panel):
 # LongPanel and friends
 
 
+def _long_arith_method(op, name):
+    def f(self, other, axis='major'):
+        """
+        Wrapper method for %s operation
+
+        Parameters
+        ----------
+        other : DataFrame or Panel class
+        axis : {'items', 'major', 'minor'}
+
+        Returns
+        -------
+        LongPanel
+        """
+        return self._combine(other, op, axis=axis)
+
+    f.__name__ = name
+    f.__doc__ = f.__doc__ % str(op)
+
+    return f
+
+
 class LongPanel(Panel):
     """
     Represents long or "stacked" format panel data
@@ -989,8 +1011,6 @@ class LongPanel(Panel):
         -------
         LongPanel
         """
-        from pandas.lib.tseries import getMergeVec
-
         if isinstance(data, np.ndarray):
             # Dtype when you have data
             if not issubclass(data.dtype.type, np.void):
@@ -1009,21 +1029,14 @@ class LongPanel(Panel):
         else:
             exclude = set(exclude)
 
-        if major_field in data:
-            major_vec = data.pop(major_field)
-        else:
-            raise Exception('No field named %s' % major_field)
-
-        if minor_field in data:
-            minor_vec = data.pop(minor_field)
-        else:
-            raise Exception('No field named %s' % minor_field)
+        major_vec = data.pop(major_field)
+        minor_vec = data.pop(minor_field)
 
         major_axis = Index(sorted(set(major_vec)))
         minor_axis = Index(sorted(set(minor_vec)))
 
-        major_labels, _ = getMergeVec(major_vec, major_axis.indexMap)
-        minor_labels, _ = getMergeVec(minor_vec, minor_axis.indexMap)
+        major_labels, _ = tseries.getMergeVec(major_vec, major_axis.indexMap)
+        minor_labels, _ = tseries.getMergeVec(minor_vec, minor_axis.indexMap)
 
         for col in exclude:
             del data[col]
@@ -1175,29 +1188,10 @@ class LongPanel(Panel):
         return LongPanel(new_values, self.items, self.index,
                          factors=self.factors)
 
-    def add(self, other, axis='major'):
-        """
-
-        """
-        return self._combine(other, operator.add, axis=axis)
-
-    def subtract(self, other, axis='major'):
-        """
-
-        """
-        return self._combine(other, operator.sub, axis=axis)
-
-    def multiply(self, other, axis='major'):
-        """
-
-        """
-        return self._combine(other, operator.mul, axis=axis)
-
-    def divide(self, other, axis='major'):
-        """
-
-        """
-        return self._combine(other, operator.div, axis=axis)
+    add = _long_arith_method(operator.add, 'add')
+    subtract = _long_arith_method(operator.sub, 'subtract')
+    divide = _long_arith_method(operator.div, 'divide')
+    multiply = _long_arith_method(operator.mul, 'multiply')
 
     def sort(self, axis='major'):
         """
@@ -1926,17 +1920,22 @@ def _slow_pivot(index, columns, values):
 
     return DataFrame(tree)
 
-def test():
-    return pivot(np.array([1, 2, 3, 4, 4]),
-                 np.array(['a', 'a', 'a', 'a', 'a']),
-                 np.array([1, 2, 3, 5, 4]))
-
 def _monotonic(arr):
     return not (arr[1:] < arr[:-1]).any()
 
 def group_agg(values, bounds, f):
     """
     R-style aggregator
+
+    Parameters
+    ----------
+    values : N x K ndarray
+    bounds : B-length ndarray
+    f : ndarray aggregation function
+
+    Returns
+    -------
+    ndarray with same length as bounds array
     """
     N, K = values.shape
     result = np.empty((len(bounds), K), dtype=float)
diff --git a/pandas/core/series.py b/pandas/core/series.py
index e3f359d61..9314a14b2 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1053,15 +1053,12 @@ class Series(np.ndarray, Picklable, Groupable):
         newValues = self.values().take(fillVec)
 
         notmask = -mask
-        if issubclass(newValues.dtype.type, np.int_):
-            if notmask.any():
+        if notmask.any():
+            if issubclass(newValues.dtype.type, np.int_):
                 newValues = newValues.astype(float)
-                np.putmask(newValues, notmask, NaN)
-        elif issubclass(newValues.dtype.type, np.bool_):
-            if notmask.any():
+            elif issubclass(newValues.dtype.type, np.bool_):
                 newValues = newValues.astype(object)
-                np.putmask(newValues, notmask, NaN)
-        else:
+
             np.putmask(newValues, notmask, NaN)
 
         return self.__class__(newValues, index=newIndex)
diff --git a/pandas/core/tests/test_panel.py b/pandas/core/tests/test_panel.py
index 3c58ab2e8..75892a02c 100644
--- a/pandas/core/tests/test_panel.py
+++ b/pandas/core/tests/test_panel.py
@@ -2,12 +2,12 @@ import os
 import operator
 import unittest
 
-from numpy.random import randint
 import numpy as np
 
-from pandas.core.api import Index, notnull
+from pandas.core.api import DataFrame, Index, notnull
 from pandas.core.datetools import bday
-from pandas.core.panel import WidePanel, LongPanelIndex, LongPanel
+from pandas.core.panel import (WidePanel, LongPanelIndex, LongPanel,
+                               group_agg, pivot)
 from pandas.util.testing import (assert_panel_equal,
                                  assert_frame_equal,
                                  assert_series_equal,
@@ -202,7 +202,17 @@ class TestWidePanel(unittest.TestCase, PanelTests):
         self.assertRaises(Exception, self.panel.__add__, self.panel['ItemA'])
 
     def test_fromDict(self):
-        pass
+        itema = self.panel['ItemA']
+        itemb = self.panel['ItemB']
+
+        d = {'A' : itema, 'B' : itemb[5:]}
+
+        wp = WidePanel.fromDict(d)
+        self.assert_(wp.major_axis.equals(self.panel.major_axis))
+
+        # intersect
+        wp = WidePanel.fromDict(d, intersect=True)
+        self.assert_(wp.major_axis.equals(itemb.index[5:]))
 
     def test_keys(self):
         common.equalContents(self.panel.keys(), self.panel.items)
@@ -565,29 +575,75 @@ class TestLongPanel(unittest.TestCase):
         assert_almost_equal(unpickled['ItemA'].values,
                             self.panel['ItemA'].values)
 
+    def test_len(self):
+        len(self.unfiltered_panel)
+
     def test_constructor(self):
         pass
 
-    def test_fromRecords(self):
-        pass
+    def test_fromRecords_toRecords(self):
+        # structured array
+        K = 10
+
+        recs = np.zeros(K, dtype='O,O,f8,f8')
+        recs['f0'] = range(K / 2) * 2
+        recs['f1'] = np.arange(K) / (K / 2)
+        recs['f2'] = np.arange(K) * 2
+        recs['f3'] = np.arange(K)
+
+        lp = LongPanel.fromRecords(recs, 'f0', 'f1')
+        self.assertEqual(len(lp.items), 2)
+
+        lp = LongPanel.fromRecords(recs, 'f0', 'f1', exclude=['f2'])
+        self.assertEqual(len(lp.items), 1)
+
+        torecs = lp.toRecords()
+        self.assertEqual(len(torecs.dtype.names), len(lp.items) + 2)
+
+        # DataFrame
+        df = DataFrame.fromRecords(recs)
+        lp = LongPanel.fromRecords(df, 'f0', 'f1', exclude=['f2'])
+        self.assertEqual(len(lp.items), 1)
+
+        # dict of arrays
+        series = DataFrame.fromRecords(recs)._series
+        lp = LongPanel.fromRecords(series, 'f0', 'f1', exclude=['f2'])
+        self.assertEqual(len(lp.items), 1)
+        self.assert_('f2' in series)
+
+        self.assertRaises(Exception, LongPanel.fromRecords, np.zeros((3, 3)),
+                          0, 1)
 
     def test_columns(self):
-        pass
+        self.assert_(np.array_equal(self.panel.items, self.panel.columns))
+        self.assert_(np.array_equal(self.panel.items, self.panel.cols()))
 
     def test_copy(self):
-        pass
+        thecopy = self.panel.copy()
+        self.assert_(np.array_equal(thecopy.values, self.panel.values))
+        self.assert_(thecopy.values is not self.panel.values)
 
     def test_values(self):
-        pass
+        valslice = self.panel.values[:-1]
+        self.assertRaises(Exception, self.panel._set_values, valslice)
 
     def test_getitem(self):
         col = self.panel['ItemA']
 
     def test_setitem(self):
         self.panel['ItemE'] = self.panel['ItemA']
+        self.panel['ItemF'] = 1
 
-    def test_pickle(self):
-        pass
+        wp = self.panel.toWide()
+        assert_frame_equal(wp['ItemA'], wp['ItemE'])
+
+        itemf = wp['ItemF'].values.ravel()
+        self.assert_((itemf[np.isfinite(itemf)] == 1).all())
+
+        # check exceptions raised
+        lp = self.panel.filter(['ItemA', 'ItemB'])
+        lp2 = self.panel.filter(['ItemC', 'ItemD'])
+        self.assertRaises(Exception, lp.__setitem__, lp2)
 
     def test_combineFrame(self):
         pass
@@ -630,7 +686,23 @@ class TestLongPanel(unittest.TestCase):
         # what else to test here?
 
     def test_truncate(self):
-        pass
+        dates = self.panel.major_axis
+        start, end = dates[1], dates[5]
+
+        trunced = self.panel.truncate(start, end).toWide()
+        expected = self.panel.toWide()['ItemA'].truncate(start, end)
+
+        assert_frame_equal(trunced['ItemA'], expected)
+
+        trunced = self.panel.truncate(before=start).toWide()
+        expected = self.panel.toWide()['ItemA'].truncate(before=start)
+
+        assert_frame_equal(trunced['ItemA'], expected)
+
+        trunced = self.panel.truncate(after=end).toWide()
+        expected = self.panel.toWide()['ItemA'].truncate(after=end)
+
+        assert_frame_equal(trunced['ItemA'], expected)
 
     def test_filter(self):
         pass
@@ -666,7 +738,35 @@ class TestLongPanel(unittest.TestCase):
         pass
 
     def test_addPrefix(self):
-        pass
+        lp = self.panel.addPrefix('foo#')
+        self.assertEqual(lp.items[0], 'foo#ItemA')
+
+    def test_pivot(self):
+
+        df = pivot(np.array([1, 2, 3, 4, 5]),
+                   np.array(['a', 'b', 'c', 'd', 'e']),
+                   np.array([1, 2, 3, 5, 4.]))
+        self.assertEqual(df['a'][1], 1)
+        self.assertEqual(df['b'][2], 2)
+        self.assertEqual(df['c'][3], 3)
+        self.assertEqual(df['d'][4], 5)
+        self.assertEqual(df['e'][5], 4)
+
+
+        # weird overlap
+        df = pivot(np.array([1, 2, 3, 4, 4]),
+                   np.array(['a', 'a', 'a', 'a', 'a']),
+                   np.array([1, 2, 3, 5, 4]))
+
+def test_group_agg():
+    values = np.ones((10, 2)) * np.arange(10).reshape((10, 1))
+    bounds = np.arange(5) * 2
+    f = lambda x: x.mean(axis=0)
+
+    agged = group_agg(values, bounds, f)
+
+    assert(agged[1][0] == 2.5)
+    assert(agged[2][0] == 4.5)
 
 class TestFactor(unittest.TestCase):
 

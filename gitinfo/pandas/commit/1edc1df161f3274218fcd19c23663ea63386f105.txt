commit 1edc1df161f3274218fcd19c23663ea63386f105
Author: sinhrks <sinhrks@gmail.com>
Date:   Sun Jul 10 17:16:00 2016 -0400

    CLN: remove radd workaround in ops.py
    
    Remove workaround added in #353.
    
    Author: sinhrks <sinhrks@gmail.com>
    
    Closes #13606 from sinhrks/ops_radd_cln and squashes the following commits:
    
    d873aad [sinhrks] CLN: remove radd workaround

diff --git a/pandas/core/ops.py b/pandas/core/ops.py
index f27a83f50..34ab3ae68 100644
--- a/pandas/core/ops.py
+++ b/pandas/core/ops.py
@@ -34,7 +34,7 @@ from pandas.core.common import (is_list_like, notnull, isnull,
 # methods
 
 
-def _create_methods(arith_method, radd_func, comp_method, bool_method,
+def _create_methods(arith_method, comp_method, bool_method,
                     use_numexpr, special=False, default_axis='columns'):
     # creates actual methods based upon arithmetic, comp and bool method
     # constructors.
@@ -55,14 +55,14 @@ def _create_methods(arith_method, radd_func, comp_method, bool_method,
                 return "__%s__" % x
     else:
         names = lambda x: x
-    radd_func = radd_func or operator.add
+
     # Inframe, all special methods have default_axis=None, flex methods have
     # default_axis set to the default (columns)
     # yapf: disable
     new_methods = dict(
         add=arith_method(operator.add, names('add'), op('+'),
                          default_axis=default_axis),
-        radd=arith_method(radd_func, names('radd'), op('+'),
+        radd=arith_method(lambda x, y: y + x, names('radd'), op('+'),
                           default_axis=default_axis),
         sub=arith_method(operator.sub, names('sub'), op('-'),
                          default_axis=default_axis),
@@ -149,7 +149,7 @@ def add_methods(cls, new_methods, force, select, exclude):
 
 # ----------------------------------------------------------------------
 # Arithmetic
-def add_special_arithmetic_methods(cls, arith_method=None, radd_func=None,
+def add_special_arithmetic_methods(cls, arith_method=None,
                                    comp_method=None, bool_method=None,
                                    use_numexpr=True, force=False, select=None,
                                    exclude=None):
@@ -162,8 +162,6 @@ def add_special_arithmetic_methods(cls, arith_method=None, radd_func=None,
     arith_method : function (optional)
         factory for special arithmetic methods, with op string:
         f(op, name, str_rep, default_axis=None, fill_zeros=None, **eval_kwargs)
-    radd_func :  function (optional)
-        Possible replacement for ``operator.add`` for compatibility
     comp_method : function, optional,
         factory for rich comparison - signature: f(op, name, str_rep)
     use_numexpr : bool, default True
@@ -176,12 +174,11 @@ def add_special_arithmetic_methods(cls, arith_method=None, radd_func=None,
     exclude : iterable of strings (optional)
         if passed, will not set functions with names in exclude
     """
-    radd_func = radd_func or operator.add
 
     # in frame, special methods have default_axis = None, comp methods use
     # 'columns'
 
-    new_methods = _create_methods(arith_method, radd_func, comp_method,
+    new_methods = _create_methods(arith_method, comp_method,
                                   bool_method, use_numexpr, default_axis=None,
                                   special=True)
 
@@ -218,7 +215,7 @@ def add_special_arithmetic_methods(cls, arith_method=None, radd_func=None,
                 exclude=exclude)
 
 
-def add_flex_arithmetic_methods(cls, flex_arith_method, radd_func=None,
+def add_flex_arithmetic_methods(cls, flex_arith_method,
                                 flex_comp_method=None, flex_bool_method=None,
                                 use_numexpr=True, force=False, select=None,
                                 exclude=None):
@@ -231,9 +228,6 @@ def add_flex_arithmetic_methods(cls, flex_arith_method, radd_func=None,
     flex_arith_method : function
         factory for special arithmetic methods, with op string:
         f(op, name, str_rep, default_axis=None, fill_zeros=None, **eval_kwargs)
-    radd_func :  function (optional)
-        Possible replacement for ``lambda x, y: operator.add(y, x)`` for
-        compatibility
     flex_comp_method : function, optional,
         factory for rich comparison - signature: f(op, name, str_rep)
     use_numexpr : bool, default True
@@ -246,9 +240,8 @@ def add_flex_arithmetic_methods(cls, flex_arith_method, radd_func=None,
     exclude : iterable of strings (optional)
         if passed, will not set functions with names in exclude
     """
-    radd_func = radd_func or (lambda x, y: operator.add(y, x))
     # in frame, default axis is 'columns', doesn't matter for series and panel
-    new_methods = _create_methods(flex_arith_method, radd_func,
+    new_methods = _create_methods(flex_arith_method,
                                   flex_comp_method, flex_bool_method,
                                   use_numexpr, default_axis='columns',
                                   special=False)
@@ -858,17 +851,6 @@ def _bool_method_SERIES(op, name, str_rep):
     return wrapper
 
 
-def _radd_compat(left, right):
-    radd = lambda x, y: y + x
-    # GH #353, NumPy 1.5.1 workaround
-    try:
-        output = radd(left, right)
-    except TypeError:
-        raise
-
-    return output
-
-
 _op_descriptions = {'add': {'op': '+',
                             'desc': 'Addition',
                             'reversed': False,
@@ -963,11 +945,9 @@ def _flex_method_SERIES(op, name, str_rep, default_axis=None, fill_zeros=None,
 
 
 series_flex_funcs = dict(flex_arith_method=_flex_method_SERIES,
-                         radd_func=_radd_compat,
                          flex_comp_method=_comp_method_SERIES)
 
 series_special_funcs = dict(arith_method=_arith_method_SERIES,
-                            radd_func=_radd_compat,
                             comp_method=_comp_method_SERIES,
                             bool_method=_bool_method_SERIES)
 
@@ -1209,11 +1189,9 @@ def _comp_method_FRAME(func, name, str_rep, masker=False):
 
 
 frame_flex_funcs = dict(flex_arith_method=_arith_method_FRAME,
-                        radd_func=_radd_compat,
                         flex_comp_method=_flex_comp_method_FRAME)
 
 frame_special_funcs = dict(arith_method=_arith_method_FRAME,
-                           radd_func=_radd_compat,
                            comp_method=_comp_method_FRAME,
                            bool_method=_arith_method_FRAME)
 
diff --git a/pandas/sparse/series.py b/pandas/sparse/series.py
index 519068b97..5c7762c56 100644
--- a/pandas/sparse/series.py
+++ b/pandas/sparse/series.py
@@ -7,7 +7,6 @@ with float64 data
 
 import numpy as np
 import warnings
-import operator
 
 from pandas.compat.numpy import function as nv
 from pandas.core.common import isnull, _values_from_object, _maybe_match_name
@@ -803,7 +802,7 @@ ops.add_flex_arithmetic_methods(SparseSeries, use_numexpr=False,
 # overwrite basic arithmetic to use SparseSeries version
 # force methods to overwrite previous definitions.
 ops.add_special_arithmetic_methods(SparseSeries, _arith_method,
-                                   radd_func=operator.add, comp_method=None,
+                                   comp_method=None,
                                    bool_method=None, use_numexpr=False,
                                    force=True)
 
diff --git a/pandas/tests/series/test_operators.py b/pandas/tests/series/test_operators.py
index 1e23c87fd..6ab382beb 100644
--- a/pandas/tests/series/test_operators.py
+++ b/pandas/tests/series/test_operators.py
@@ -1259,8 +1259,6 @@ class TestSeriesOperators(TestData, tm.TestCase):
         _check_op(arr, operator.floordiv)
 
     def test_series_frame_radd_bug(self):
-        import operator
-
         # GH 353
         vals = Series(tm.rands_array(5, 10))
         result = 'foo_' + vals
@@ -1273,7 +1271,78 @@ class TestSeriesOperators(TestData, tm.TestCase):
         tm.assert_frame_equal(result, expected)
 
         # really raise this time
-        self.assertRaises(TypeError, operator.add, datetime.now(), self.ts)
+        with tm.assertRaises(TypeError):
+            datetime.now() + self.ts
+
+        with tm.assertRaises(TypeError):
+            self.ts + datetime.now()
+
+    def test_series_radd_more(self):
+        data = [[1, 2, 3],
+                [1.1, 2.2, 3.3],
+                [pd.Timestamp('2011-01-01'), pd.Timestamp('2011-01-02'),
+                 pd.NaT],
+                ['x', 'y', 1]]
+
+        for d in data:
+            for dtype in [None, object]:
+                s = Series(d, dtype=dtype)
+                with tm.assertRaises(TypeError):
+                    'foo_' + s
+
+        for dtype in [None, object]:
+            res = 1 + pd.Series([1, 2, 3], dtype=dtype)
+            exp = pd.Series([2, 3, 4], dtype=dtype)
+            tm.assert_series_equal(res, exp)
+            res = pd.Series([1, 2, 3], dtype=dtype) + 1
+            tm.assert_series_equal(res, exp)
+
+            res = np.nan + pd.Series([1, 2, 3], dtype=dtype)
+            exp = pd.Series([np.nan, np.nan, np.nan], dtype=dtype)
+            tm.assert_series_equal(res, exp)
+            res = pd.Series([1, 2, 3], dtype=dtype) + np.nan
+            tm.assert_series_equal(res, exp)
+
+            s = pd.Series([pd.Timedelta('1 days'), pd.Timedelta('2 days'),
+                           pd.Timedelta('3 days')], dtype=dtype)
+            exp = pd.Series([pd.Timedelta('4 days'), pd.Timedelta('5 days'),
+                             pd.Timedelta('6 days')])
+            tm.assert_series_equal(pd.Timedelta('3 days') + s, exp)
+            tm.assert_series_equal(s + pd.Timedelta('3 days'), exp)
+
+        s = pd.Series(['x', np.nan, 'x'])
+        tm.assert_series_equal('a' + s, pd.Series(['ax', np.nan, 'ax']))
+        tm.assert_series_equal(s + 'a', pd.Series(['xa', np.nan, 'xa']))
+
+    def test_frame_radd_more(self):
+        data = [[1, 2, 3],
+                [1.1, 2.2, 3.3],
+                [pd.Timestamp('2011-01-01'), pd.Timestamp('2011-01-02'),
+                 pd.NaT],
+                ['x', 'y', 1]]
+
+        for d in data:
+            for dtype in [None, object]:
+                s = DataFrame(d, dtype=dtype)
+                with tm.assertRaises(TypeError):
+                    'foo_' + s
+
+        for dtype in [None, object]:
+            res = 1 + pd.DataFrame([1, 2, 3], dtype=dtype)
+            exp = pd.DataFrame([2, 3, 4], dtype=dtype)
+            tm.assert_frame_equal(res, exp)
+            res = pd.DataFrame([1, 2, 3], dtype=dtype) + 1
+            tm.assert_frame_equal(res, exp)
+
+            res = np.nan + pd.DataFrame([1, 2, 3], dtype=dtype)
+            exp = pd.DataFrame([np.nan, np.nan, np.nan], dtype=dtype)
+            tm.assert_frame_equal(res, exp)
+            res = pd.DataFrame([1, 2, 3], dtype=dtype) + np.nan
+            tm.assert_frame_equal(res, exp)
+
+        df = pd.DataFrame(['x', np.nan, 'x'])
+        tm.assert_frame_equal('a' + df, pd.DataFrame(['ax', np.nan, 'ax']))
+        tm.assert_frame_equal(df + 'a', pd.DataFrame(['xa', np.nan, 'xa']))
 
     def test_operators_frame(self):
         # rpow does not work with DataFrame

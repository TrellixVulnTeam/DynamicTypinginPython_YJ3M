commit 78b3bf9c5ed7861d1da948812195c458a4a40a88
Author: Phillip Cloud <cpcloud@gmail.com>
Date:   Fri Apr 4 15:55:18 2014 -0400

    BUG/API: disallow boolean arithmetic operations

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 8bf6a8d7b..718885121 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -156,6 +156,8 @@ API Changes
 - ``to_excel`` now converts ``np.inf`` into a string representation,
   customizable by the ``inf_rep`` keyword argument (Excel has no native inf
   representation) (:issue:`6782`)
+- Arithmetic ops are now disallowed when passed two bool dtype Series or
+  DataFrames (:issue:`6762`).
 
 Deprecations
 ~~~~~~~~~~~~
@@ -307,6 +309,9 @@ Bug Fixes
 - Bug in ``DataFrame.replace()`` where regex metacharacters were being treated
   as regexs even when ``regex=False`` (:issue:`6777`).
 - Bug in timedelta ops on 32-bit platforms (:issue:`6808`)
+- Bug in setting a tz-aware index directly via ``.index`` (:issue:`6785`)
+- Bug in expressions.py where numexpr would try to evaluate arithmetic ops
+  (:issue:`6762`).
 
 pandas 0.13.1
 -------------
diff --git a/pandas/computation/expressions.py b/pandas/computation/expressions.py
index b379da9cd..5575d020f 100644
--- a/pandas/computation/expressions.py
+++ b/pandas/computation/expressions.py
@@ -154,6 +154,13 @@ def _where_numexpr(cond, a, b, raise_on_error=False):
 set_use_numexpr(True)
 
 
+def _bool_arith_check(op_str, a, b, not_allowed=('+', '*', '-', '/',
+                                                 '//', '**')):
+    if op_str in not_allowed and a.dtype == bool and b.dtype == bool:
+        raise NotImplementedError("operator %r not implemented for bool "
+                                  "dtypes" % op_str)
+
+
 def evaluate(op, op_str, a, b, raise_on_error=False, use_numexpr=True,
              **eval_kwargs):
     """ evaluate and return the expression of the op on a and b
@@ -170,7 +177,7 @@ def evaluate(op, op_str, a, b, raise_on_error=False, use_numexpr=True,
                          return the results
         use_numexpr : whether to try to use numexpr (default True)
         """
-
+    _bool_arith_check(op_str, a, b)
     if use_numexpr:
         return _evaluate(op, op_str, a, b, raise_on_error=raise_on_error,
                          **eval_kwargs)
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 087e094ff..5b899dd85 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -4769,6 +4769,22 @@ class TestDataFrame(tm.TestCase, CheckIndexing,
             self.assertRaises(TypeError, self.frame.__gt__, 'foo')
             self.assertRaises(TypeError, self.frame.__ne__, 'foo')
 
+    def test_bool_ops_raise_on_arithmetic(self):
+        df = DataFrame({'a': np.random.rand(10) > 0.5,
+                        'b': np.random.rand(10) > 0.5})
+        df2 = DataFrame({'a': np.random.rand(10) > 0.5,
+                         'b': np.random.rand(10) > 0.5})
+        ops = 'add', 'mul', 'sub', 'div', 'truediv', 'floordiv', 'pow'
+        names = '+', '*', '-', '/', '/', '//', '**'
+        msg = 'operator %r not implemented for bool dtypes'
+        for op, name in zip(ops, names):
+            if not compat.PY3 or op != 'div':
+                with tm.assertRaisesRegexp(NotImplementedError,
+                                           re.escape(msg % name)):
+                    f = getattr(operator, op)
+                    f(df, df2)
+                    f(df.a, df.b)
+
     def test_constructor_lists_to_object_dtype(self):
         # from #1074
         d = DataFrame({'a': [np.nan, False]})

commit 54c0a1aa661be37ac14f86847b66e23422a6bcd2
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Jun 19 20:53:21 2012 -0400

    TST: finish test coverage of pandas.tseries.index #1245

diff --git a/pandas/core/index.py b/pandas/core/index.py
index 93aee0fd0..db0bd1bd7 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -2471,9 +2471,9 @@ def _ensure_compat_concat(indexes):
     return indexes
 
 def _maybe_box_dtindex(idx):
-    from pandas.tseries.index import DatetimeIndex, _dt_box_array
+    from pandas.tseries.index import DatetimeIndex
     if isinstance(idx, DatetimeIndex):
-        return Index(_dt_box_array(idx.asi8), dtype='object')
+        return idx.asobject
     return idx
 
 def _clean_arrays(values):
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 736a64e48..c33637c11 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -322,8 +322,7 @@ class DatetimeIndex(Int64Index):
             xdr = generate_range(offset=offset, start=_CACHE_START,
                                  end=_CACHE_END)
 
-            arr = np.array(_to_m8_array(list(xdr)),
-                           dtype=_NS_DTYPE, copy=False)
+            arr = tools.to_datetime(list(xdr), box=False)
 
             cachedRange = arr.view(DatetimeIndex)
             cachedRange.offset = offset
@@ -538,7 +537,8 @@ class DatetimeIndex(Int64Index):
         return list(self.asobject)
 
     def _get_object_index(self):
-        boxed_values = _dt_box_array(self.asi8, self.offset, self.tz)
+        boxfunc = lambda x: Timestamp(x, offset=self.offset, tz=self.tz)
+        boxed_values = lib.map_infer(self.asi8, boxfunc)
         return Index(boxed_values, dtype=object)
 
     def to_pydatetime(self):
@@ -1046,10 +1046,6 @@ class DatetimeIndex(Int64Index):
         # sure we can't have ambiguous indexing
         return 'datetime64'
 
-    @property
-    def _constructor(self):
-        return DatetimeIndex
-
     @property
     def dtype(self):
         return _NS_DTYPE
@@ -1108,10 +1104,10 @@ class DatetimeIndex(Int64Index):
         if type(item) == datetime:
             item = _to_m8(item)
 
-        if self.offset is not None and not self.offset.onOffset(item):
-            raise ValueError("Cannot insert value at non-conforming time")
-
-        return super(DatetimeIndex, self).insert(loc, item)
+        new_index = np.concatenate((self[:loc].asi8,
+                                    [item.view(np.int64)],
+                                    self[loc:].asi8))
+        return DatetimeIndex(new_index, freq='infer')
 
     def _view_like(self, ndarray):
         result = ndarray.view(type(self))
@@ -1156,29 +1152,6 @@ class DatetimeIndex(Int64Index):
 
         return self._simple_new(new_dates, self.name, self.offset, tz)
 
-    def tz_validate(self):
-        """
-        For a localized time zone, verify that there are no DST ambiguities
-        (using pytz)
-
-        Returns
-        -------
-        result : boolean
-            True if there are no DST ambiguities
-        """
-        import pytz
-
-        if self.tz is None or self.tz is pytz.utc:
-            return True
-
-        # See if there are any DST resolution problems
-        try:
-            lib.tz_localize_check(self.asi8, self.tz)
-        except:
-            return False
-
-        return True
-
     def indexer_at_time(self, time, asof=False):
         """
         Select values at particular time of day (e.g. 9:30AM)
@@ -1353,17 +1326,6 @@ def bdate_range(start=None, end=None, periods=None, freq='B', tz=None,
                          freq=freq, tz=tz, normalize=normalize)
 
 
-def _dt_box_array(arr, offset=None, tz=None):
-    if arr is None:
-        return arr
-
-    if not isinstance(arr, np.ndarray):
-        return arr
-
-    boxfunc = lambda x: Timestamp(x, offset=offset, tz=tz)
-    return lib.map_infer(arr, boxfunc)
-
-
 def _to_m8(key):
     '''
     Timestamp-like => dt64
@@ -1375,11 +1337,6 @@ def _to_m8(key):
     return np.int64(lib.pydt_to_i8(key)).view(_NS_DTYPE)
 
 
-def _to_m8_array(arr):
-    if arr is None:
-        return arr
-    return np.frompyfunc(_to_m8, 1, 1)(arr)
-
 
 def _str_to_dt_array(arr, offset=None):
     def parser(x):
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index a0d863a49..5dc617150 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -670,7 +670,8 @@ class TestTimeSeries(unittest.TestCase):
         rng = date_range('1/1/2000', periods=20)
         ts = Series(np.random.randn(20), index=rng)
 
-        ts2 = ts[5:]
+        ts_slice = ts[5:]
+        ts2 = ts_slice.copy()
         ts2.index = [x.date() for x in ts2.index]
 
         result = ts + ts2
@@ -684,6 +685,10 @@ class TestTimeSeries(unittest.TestCase):
         expected = ts[5:].asfreq('4H', method='ffill')
         assert_series_equal(result, expected)
 
+        result = rng.get_indexer(ts2.index)
+        expected = rng.get_indexer(ts_slice.index)
+        self.assert_(np.array_equal(result, expected))
+
     def test_date_range_gen_error(self):
         rng = date_range('1/1/2000 00:00', '1/1/2000 00:18', freq='5min')
         self.assertEquals(len(rng), 4)
@@ -756,6 +761,10 @@ class TestTimeSeries(unittest.TestCase):
         self.assert_((rs.index.minute == rng[1].minute).all())
         self.assert_((rs.index.second == rng[1].second).all())
 
+        result = ts.at_time('9:30')
+        expected = ts.at_time(time(9, 30))
+        assert_series_equal(result, expected)
+
         df = DataFrame(np.random.randn(len(rng), 3), index=rng)
 
         result = ts[time(9, 30)]
@@ -808,6 +817,10 @@ class TestTimeSeries(unittest.TestCase):
                 else:
                     self.assert_(t < etime)
 
+        result = ts.between_time('00:00', '01:00')
+        expected = ts.between_time(stime, etime)
+        assert_series_equal(result, expected)
+
     def test_dti_constructor_preserve_dti_freq(self):
         rng = date_range('1/1/2000', '1/2/2000', freq='5min')
 
@@ -1056,6 +1069,12 @@ class TestDatetimeIndex(unittest.TestCase):
         result = rng.groupby(rng.day)
         self.assert_(isinstance(result.values()[0][0], Timestamp))
 
+        idx = DatetimeIndex(['2000-01-03', '2000-01-01', '2000-01-02'])
+        self.assert_(idx.equals(list(idx)))
+
+        non_datetime = Index(list('abc'))
+        self.assert_(not idx.equals(list(non_datetime)))
+
     def test_union_coverage(self):
         idx = DatetimeIndex(['2000-01-03', '2000-01-01', '2000-01-02'])
         ordered = DatetimeIndex(idx.order(), freq='infer')
@@ -1082,6 +1101,11 @@ class TestDatetimeIndex(unittest.TestCase):
         ex = DatetimeIndex(['2000-01-02', '2000-01-03'])
         self.assert_(result.equals(ex))
 
+    def test_argmin_argmax(self):
+        idx = DatetimeIndex(['2000-01-04', '2000-01-01', '2000-01-02'])
+        self.assertEqual(idx.argmin(), 1)
+        self.assertEqual(idx.argmax(), 0)
+
     def test_order(self):
         idx = DatetimeIndex(['2000-01-04', '2000-01-01', '2000-01-02'])
 
@@ -1099,6 +1123,17 @@ class TestDatetimeIndex(unittest.TestCase):
         self.assert_(ordered[::-1].is_monotonic)
         self.assert_(np.array_equal(dexer, [0, 2, 1]))
 
+    def test_insert(self):
+        idx = DatetimeIndex(['2000-01-04', '2000-01-01', '2000-01-02'])
+
+        result = idx.insert(2, datetime(2000, 1, 5))
+        exp = DatetimeIndex(['2000-01-04', '2000-01-01', '2000-01-05',
+                             '2000-01-02'])
+        self.assert_(result.equals(exp))
+
+        idx = date_range('1/1/2000', periods=3, freq='M')
+        result = idx.insert(3, datetime(2000, 4, 30))
+        self.assert_(result.freqstr == 'M')
 
 class TestLegacySupport(unittest.TestCase):
 
diff --git a/pandas/tseries/tests/test_timezones.py b/pandas/tseries/tests/test_timezones.py
index 58bc4837b..dad235ede 100644
--- a/pandas/tseries/tests/test_timezones.py
+++ b/pandas/tseries/tests/test_timezones.py
@@ -245,9 +245,6 @@ class TestTimeZoneSupport(unittest.TestCase):
 
         rng = bdate_range(datetime(2009, 1, 1), datetime(2010, 1, 1))
 
-        # regular no problem
-        self.assert_(rng.tz_validate())
-
         # March 13, 2011, spring forward, skip from 2 AM to 3 AM
         dr = date_range(datetime(2011, 3, 13, 1, 30), periods=3,
                         freq=datetools.Hour())
@@ -370,6 +367,7 @@ class TestTimeZones(unittest.TestCase):
         self.assert_(conv.equals(exp))
 
     def test_series_frame_tz_localize(self):
+
         rng = date_range('1/1/2011', periods=100, freq='H')
         ts = Series(1, index=rng)
 
@@ -387,6 +385,11 @@ class TestTimeZones(unittest.TestCase):
         self.assert_(result.columns.tz.zone == 'UTC')
         assert_frame_equal(result, expected.T)
 
+        # Can't localize if already tz-aware
+        rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
+        ts = Series(1, index=rng)
+        self.assertRaises(Exception, ts.tz_localize, 'US/Eastern')
+
     def test_series_frame_tz_convert(self):
         rng = date_range('1/1/2011', periods=200, freq='D',
                          tz='US/Eastern')
@@ -406,6 +409,11 @@ class TestTimeZones(unittest.TestCase):
         self.assert_(result.columns.tz.zone == 'Europe/Berlin')
         assert_frame_equal(result, expected.T)
 
+        # can't convert tz-naive
+        rng = date_range('1/1/2011', periods=200, freq='D')
+        ts = Series(1, index=rng)
+        self.assertRaises(Exception, ts.tz_convert, 'US/Eastern')
+
     def test_join_utc_convert(self):
         rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
 
diff --git a/pandas/tseries/tools.py b/pandas/tseries/tools.py
index 4e4077ff9..c12ba901d 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/tseries/tools.py
@@ -65,7 +65,7 @@ def _figure_out_timezone(start, end, tzinfo):
     return start, end, tz
 
 
-def to_datetime(arg, errors='ignore', dayfirst=False):
+def to_datetime(arg, errors='ignore', dayfirst=False, box=True):
     """
     Convert argument to datetime
 
@@ -96,7 +96,7 @@ def to_datetime(arg, errors='ignore', dayfirst=False):
         result = lib.array_to_datetime(com._ensure_object(arg),
                                        raise_=errors == 'raise',
                                        dayfirst=dayfirst)
-        if com.is_datetime64_dtype(result):
+        if com.is_datetime64_dtype(result) and box:
             result = DatetimeIndex(result)
         return result
     try:
diff --git a/test.sh b/test.sh
index 3f378fd86..324ac68d6 100755
--- a/test.sh
+++ b/test.sh
@@ -2,7 +2,8 @@
 coverage erase
 # nosetests pandas/tests/test_index.py --with-coverage --cover-package=pandas.core --pdb-failure --pdb
 #nosetests -w pandas --with-coverage --cover-package=pandas --pdb-failure --pdb #--cover-inclusive
-nosetests -A "not slow" -w pandas/tseries --with-coverage --cover-package=pandas.tseries $* #--cover-inclusive
+#nosetests -A "not slow" -w pandas/tseries --with-coverage --cover-package=pandas.tseries $* #--cover-inclusive
+nosetests -w pandas --with-coverage --cover-package=pandas $*
 # nosetests -w pandas/io --with-coverage --cover-package=pandas.io --pdb-failure --pdb
 # nosetests -w pandas/core --with-coverage --cover-package=pandas.core --pdb-failure --pdb
 # nosetests -w pandas/stats --with-coverage --cover-package=pandas.stats

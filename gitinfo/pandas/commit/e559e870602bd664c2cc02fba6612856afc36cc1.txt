commit e559e870602bd664c2cc02fba6612856afc36cc1
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Dec 15 18:12:44 2012 -0500

    ENH: read_* function header inference. make backwards compatible again with 0.9.x. close #2539

diff --git a/RELEASE.rst b/RELEASE.rst
index 6dbd4385b..3ef165f50 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -102,10 +102,8 @@ pandas 0.10.0
     using the new option ``mode.use_inf_as_null`` (GH2050_, GH1919_)
   - ``pandas.merge`` will now default to ``sort=False``. For many use cases
     sorting the join keys is not necessary, and doing it by default is wasteful
-  - ``names`` handling in file parsing: if explicit column `names` passed,
-    `header` argument will be respected. If there is an existing header column,
-    this can rename the columns. To fix legacy code, put ``header=None`` when
-    passing ``names``
+  - Specify ``header=0`` explicitly to replace existing column names in file in
+    read_* functions.
   - Default column names for header-less parsed files (yielded by read_csv,
     etc.) are now the integers 0, 1, .... A new argument `prefix` has been
     added; to get the v0.9.x behavior specify ``prefix='X'`` (GH2034_). This API
diff --git a/doc/source/io.rst b/doc/source/io.rst
index eac64eae1..c73240725 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -52,8 +52,9 @@ data into a DataFrame object. They can take a number of arguments:
     ways to specify the file format
   - ``dtype``: A data type name or a dict of column name to data type. If not
     specified, data types will be inferred.
-  - ``header``: row number to use as the column names, and the start of the data.
-    Defaults to 0 (first row); specify None if there is no header row.
+  - ``header``: row number to use as the column names, and the start of the
+    data.  Defaults to 0 if no ``names`` passed, otherwise ``None``. Explicitly
+    pass ``header=0`` to be able to replace existing names.
   - ``skiprows``: A collection of numbers for rows in the file to skip. Can
     also be an integer to skip the first ``n`` rows
   - ``index_col``: column number, column name, or list of column numbers/names,
@@ -61,8 +62,8 @@ data into a DataFrame object. They can take a number of arguments:
     it will number the rows without using any column, unless there is one more
     data column than there are headers, in which case the first column is taken
     as the index.
-  - ``names``: List of column names to use. If file contains no header row,
-    then you should explicitly pass header=None (behavior changed in v0.10.0).
+  - ``names``: List of column names to use as column names. To replace header
+    existing in file, explicitly pass ``header=0``.
   - ``na_values``: optional list of strings to recognize as NaN (missing
     values), either in addition to or in lieu of the default set.
   - ``true_values``: list of strings to recognize as ``True``
@@ -235,7 +236,7 @@ any):
 .. ipython:: python
 
     print data
-    pd.read_csv(StringIO(data), names=['foo', 'bar', 'baz'])
+    pd.read_csv(StringIO(data), names=['foo', 'bar', 'baz'], header=0)
     pd.read_csv(StringIO(data), names=['foo', 'bar', 'baz'], header=None)
 
 If the header is in a row other than the first, pass the row number to
diff --git a/doc/source/v0.10.0.txt b/doc/source/v0.10.0.txt
index 5316458ed..e4acb86bc 100644
--- a/doc/source/v0.10.0.txt
+++ b/doc/source/v0.10.0.txt
@@ -98,17 +98,6 @@ Note:
   often one of the more expensive parts of the computation and is often
   unnecessary.
 
-- The ``names`` argument in the file parsers no longer overrides the ``header``
-  option to ``None``. This means that you need to specify ``header=None`` in
-  cases where your file has no header row:
-
-.. ipython:: python
-
-    from StringIO import StringIO
-    data = '1,2,3\n4,5,6\n7,8,9'
-    print data
-    pd.read_csv(StringIO(data), names=['a', 'b', 'c'], header=None)
-
 - The default column names for a file with no header have been changed to the
   integers ``0`` through ``N - 1``. This is to create consistency with the
   DataFrame constructor with no columns specified. The v0.9.0 behavior (names
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index 16012b3df..02b9c7ac0 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -49,7 +49,7 @@ compression : {'gzip', 'bz2', None}, default None
 dialect : string or csv.Dialect instance, default None
     If None defaults to Excel dialect. Ignored if sep longer than 1 char
     See csv.Dialect documentation for more details
-header : int, default 0
+header : int, default 0 if names parameter not specified, otherwise None
     Row to use for the column labels of the parsed DataFrame. Specify None if
     there is no header row.
 skiprows : list-like or integer
@@ -216,7 +216,7 @@ _parser_defaults = {
     'skipinitialspace': False,
     'lineterminator': None,
 
-    'header': 0,
+    'header': 'infer',
     'index_col': None,
     'names': None,
     'prefix': None,
@@ -287,7 +287,7 @@ def _make_parser_function(name, sep=','):
                  skipinitialspace=False,
                  lineterminator=None,
 
-                 header=0,
+                 header='infer',
                  index_col=None,
                  names=None,
                  prefix=None,
@@ -478,6 +478,9 @@ class TextFileReader(object):
             kwds['quotechar'] = dialect.quotechar
             kwds['quoting'] = dialect.quoting
 
+        if kwds.get('header', 'infer') == 'infer':
+            kwds['header'] = 0 if kwds.get('names') is None else None
+
         self.orig_options = kwds
 
         # miscellanea
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index 9a91793bf..7f7abd8a0 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -341,13 +341,11 @@ KORD6,19990127, 23:00:00, 22:56:00, -0.5900, 1.7100, 4.6000, 0.0000, 280.0000"""
         xp = DataFrame({'a' : [1, 5, 9], 'b' : [2, 6, 10], 'c' : [3, 7, 11],
                         'd' : [4, 8, 12]},
                        index=Index(['hello', 'world', 'foo'], name='message'))
-        rs = self.read_csv(StringIO(data), names=names,
-                           header=None, index_col=['message'])
+        rs = self.read_csv(StringIO(data), names=names, index_col=['message'])
         tm.assert_frame_equal(xp, rs)
         self.assert_(xp.index.name == rs.index.name)
 
-        rs = self.read_csv(StringIO(data), names=names,
-                           header=None, index_col='message')
+        rs = self.read_csv(StringIO(data), names=names, index_col='message')
         tm.assert_frame_equal(xp, rs)
         self.assert_(xp.index.name == rs.index.name)
 
@@ -671,8 +669,7 @@ c,4,5
                                   header=None)
 
         names = ['foo', 'bar', 'baz', 'quux', 'panda']
-        df2 = self.read_table(StringIO(data), sep=',', header=None,
-                              names=names)
+        df2 = self.read_table(StringIO(data), sep=',', names=names)
         expected = [[1,2,3,4,5.],
                     [6,7,8,9,10],
                     [11,12,13,14,15]]
@@ -691,7 +688,7 @@ bar,4,5,6
 baz,7,8,9
 """
         names = ['A', 'B', 'C']
-        df = self.read_csv(StringIO(data), names=names, header=None)
+        df = self.read_csv(StringIO(data), names=names)
 
         self.assertEqual(names, ['A', 'B', 'C'])
 
@@ -914,8 +911,7 @@ baz,12,13,14,15
 
         # regular index
         names = ['index', 'A', 'B', 'C', 'D']
-        df = self.read_csv(StringIO(no_header), index_col=0,
-                           header=None, names=names)
+        df = self.read_csv(StringIO(no_header), index_col=0, names=names)
         expected = self.read_csv(StringIO(self.data1), index_col=0)
         tm.assert_frame_equal(df, expected)
 
@@ -931,7 +927,7 @@ bar,two,12,13,14,15
         no_header = '\n'.join(lines[1:])
         names = ['index1', 'index2', 'A', 'B', 'C', 'D']
         df = self.read_csv(StringIO(no_header), index_col=[0, 1],
-                           header=None, names=names)
+                           names=names)
         expected = self.read_csv(StringIO(data), index_col=[0, 1])
         tm.assert_frame_equal(df, expected)
 
@@ -1482,6 +1478,20 @@ A,B,C
         self.assertTrue(np.array_equal(result.columns,
                                        ['SEARCH_TERM', 'ACTUAL_URL']))
 
+    def test_header_names_backward_compat(self):
+        # #2539
+        data = '1,2,3\n4,5,6'
+
+        result = self.read_csv(StringIO(data), names=['a', 'b', 'c'])
+        expected = self.read_csv(StringIO(data), names=['a', 'b', 'c'],
+                                 header=None)
+        tm.assert_frame_equal(result, expected)
+
+        data2 = 'foo,bar,baz\n' + data
+        result = self.read_csv(StringIO(data2), names=['a', 'b', 'c'],
+                               header=0)
+        tm.assert_frame_equal(result, expected)
+
 
 class TestPythonParser(ParserTests, unittest.TestCase):
 

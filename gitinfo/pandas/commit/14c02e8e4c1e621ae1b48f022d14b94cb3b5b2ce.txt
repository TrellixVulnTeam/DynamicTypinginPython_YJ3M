commit 14c02e8e4c1e621ae1b48f022d14b94cb3b5b2ce
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Aug 13 12:31:36 2011 -0400

    BUG: unicode handling in DataFrame.toString/info

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 6004e5287..8eb2aaa92 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -12,7 +12,7 @@ labeling information
 # pylint: disable=E1101,E1103
 # pylint: disable=W0212,W0231,W0703,W0622
 
-from cStringIO import StringIO
+from StringIO import StringIO
 import operator
 import sys
 import warnings
@@ -90,6 +90,11 @@ def comp_method(func, name):
 
     return f
 
+class Foo(object):
+
+    def __repr__(self):
+        return u'\u03c3'
+
 #-------------------------------------------------------------------------------
 # DataFrame class
 
@@ -511,15 +516,25 @@ class DataFrame(NDFrame):
         else:
             columns = [c for c in columns if c in self]
 
+        to_write = []
+
         if len(columns) == 0 or len(self.index) == 0:
-            print >> buf, 'Empty %s' % type(self).__name__
-            print >> buf, repr(self.index)
+            to_write.append('Empty %s' % type(self).__name__)
+            to_write.append(repr(self.index))
         else:
             (str_index,
              str_columns) = self._get_formatted_labels(sparsify=sparsify)
             stringified = [str_columns[i] + _stringify(c)
                            for i, c in enumerate(columns)]
-            print >> buf, adjoin(1, str_index, *stringified)
+            to_write.append(adjoin(1, str_index, *stringified))
+
+        for s in to_write:
+            if isinstance(s, unicode):
+                to_write = [unicode(s) for s in to_write]
+                break
+
+        for s in to_write:
+            print >> buf, s
 
     def _get_formatted_labels(self, sparsify=True):
         from pandas.core.index import _sparsify
@@ -557,26 +572,35 @@ class DataFrame(NDFrame):
 
         cols = self.columns
 
+        def _stringify(col):
+            # unicode workaround
+            if isinstance(col, tuple):
+                return str(col)
+            else:
+                return '%s' % col
+
         if verbose:
-            print >> buf, 'Data columns:'
-            space = max([len(str(k)) for k in self.columns]) + 4
+            print >> buf, unicode('Data columns:')
+            space = max([len(_stringify(k)) for k in self.columns]) + 4
             col_counts = []
             counts = self.count()
             assert(len(cols) == len(counts))
             for col, count in counts.iteritems():
+                colstr = _stringify(col)
                 col_counts.append('%s%d  non-null values' %
-                                  (_put_str(str(col), space), count))
-
-            print >> buf, '\n'.join(col_counts)
+                                  (_put_str(colstr, space), count))
+            print >> buf, unicode('\n'.join(col_counts))
         else:
             if len(cols) <= 2:
-                print >> buf, 'Columns: %s' % repr(cols)
+                print >> buf, unicode('Columns: %s' % repr(cols))
             else:
-                print >> buf, 'Columns: %s to %s' % (cols[0], cols[-1])
+                print >> buf, unicode('Columns: %s to %s'
+                                      % (_stringify(cols[0]),
+                                         _stringify(cols[-1])))
 
         counts = self._get_dtype_counts()
         dtypes = ['%s(%d)' % k for k in sorted(counts.iteritems())]
-        buf.write('dtypes: %s' % ', '.join(dtypes))
+        buf.write(u'dtypes: %s' % ', '.join(dtypes))
 
     def _get_dtype_counts(self):
         counts = {}
diff --git a/pandas/core/index.py b/pandas/core/index.py
index b1ffcfddd..3122b11be 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -124,11 +124,11 @@ class Index(np.ndarray):
             zero_time = time(0, 0)
             for dt in self:
                 if dt.time() != zero_time or dt.tzinfo is not None:
-                    return '\n'.join(str(x) for x in self)
+                    return '\n'.join('%s' % x for x in self)
                 to_join.append(dt.strftime("%Y-%m-%d"))
             return to_join
 
-        return [str(x) for x in self]
+        return ['%s' % x for x in self]
 
     def equals(self, other):
         """
@@ -337,30 +337,6 @@ class Factor(object):
             return Factor(new_labels, self.levels)
 
 
-"""
-something like this?
-
-            ----------------------------------------------------
-            | common                     | uncommon            |
-            ----------------------------------------------------
-            | foo     | bar     | baz    | qux     | wibble    |
-            ----------------------------------------------------
-A       1     ...       ...       ...      ...       ...
-        2
-        3
-B       1
-        2
-C       1
-        2
-        3     ...       ...       ...      ...       ...
-
-
- common                uncommon
- ------                --------
-|foo    bar    baz    |qux    wibble
-
-"""
-
 class MultiIndex(Index):
     """
     Implements multi-level, a.k.a. hierarchical, index object for pandas objects
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index c96ba5521..0f817a958 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -1,7 +1,7 @@
 # pylint: disable-msg=W0612,E1101
 from copy import deepcopy
 from datetime import datetime, timedelta
-from cStringIO import StringIO
+from StringIO import StringIO
 import cPickle as pickle
 import operator
 import os
@@ -1031,6 +1031,17 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         frame = DataFrame(index=np.arange(1000))
         frame.toString(buf=buf)
 
+    def test_toString_unicode_columns(self):
+        df = DataFrame({u'\u03c3' : np.arange(10.)})
+
+        buf = StringIO()
+        df.toString(buf=buf)
+        buf.getvalue()
+
+        buf = StringIO()
+        df.info(buf=buf)
+        buf.getvalue()
+
     def test_insert(self):
         df = DataFrame(np.random.randn(5, 3), index=np.arange(5),
                        columns=['c', 'b', 'a'])

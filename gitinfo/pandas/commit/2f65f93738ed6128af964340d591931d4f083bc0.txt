commit 2f65f93738ed6128af964340d591931d4f083bc0
Author: seales <cseales6@gmail.com>
Date:   Sun Dec 13 19:42:59 2015 -0800

    Spelling fixes

diff --git a/doc/source/advanced.rst b/doc/source/advanced.rst
index b550f59b8..d976b0c8c 100644
--- a/doc/source/advanced.rst
+++ b/doc/source/advanced.rst
@@ -525,7 +525,7 @@ they have a MultiIndex:
 
    df.T.sort_index(level=1, axis=1)
 
-The ``MultiIndex`` object has code to **explicity check the sort depth**. Thus,
+The ``MultiIndex`` object has code to **explicitly check the sort depth**. Thus,
 if you try to index at a depth at which the index is not sorted, it will raise
 an exception. Here is a concrete example to illustrate this:
 
diff --git a/doc/source/api.rst b/doc/source/api.rst
index c7f815914..12dc0b0cb 100644
--- a/doc/source/api.rst
+++ b/doc/source/api.rst
@@ -552,7 +552,7 @@ These can be accessed like ``Series.dt.<property>``.
 String handling
 ~~~~~~~~~~~~~~~
 ``Series.str`` can be used to access the values of the series as
-strings and apply several methods to it. These can be acccessed like
+strings and apply several methods to it. These can be accessed like
 ``Series.str.<function/property>``.
 
 .. autosummary::
diff --git a/doc/source/basics.rst b/doc/source/basics.rst
index b80ac18a2..8658c6d45 100644
--- a/doc/source/basics.rst
+++ b/doc/source/basics.rst
@@ -1097,7 +1097,7 @@ Note that the same result could have been achieved using
    ts2.reindex(ts.index).fillna(method='ffill')
 
 :meth:`~Series.reindex` will raise a ValueError if the index is not monotonic
-increasing or descreasing. :meth:`~Series.fillna` and :meth:`~Series.interpolate`
+increasing or decreasing. :meth:`~Series.fillna` and :meth:`~Series.interpolate`
 will not make any checks on the order of the index.
 
 .. _basics.limits_on_reindex_fill:
diff --git a/doc/source/categorical.rst b/doc/source/categorical.rst
index 2dc506db7..317641f1b 100644
--- a/doc/source/categorical.rst
+++ b/doc/source/categorical.rst
@@ -178,7 +178,7 @@ It's also possible to pass in the categories in a specific order:
 
 .. note::
 
-    New categorical data are NOT automatically ordered. You must explicity pass ``ordered=True`` to
+    New categorical data are NOT automatically ordered. You must explicitly pass ``ordered=True`` to
     indicate an ordered ``Categorical``.
 
 
@@ -342,7 +342,7 @@ necessarily make the sort order the same as the categories order.
 Multi Column Sorting
 ~~~~~~~~~~~~~~~~~~~~
 
-A categorical dtyped column will partcipate in a multi-column sort in a similar manner to other columns.
+A categorical dtyped column will participate in a multi-column sort in a similar manner to other columns.
 The ordering of the categorical is determined by the ``categories`` of that column.
 
 .. ipython:: python
diff --git a/doc/source/comparison_with_sas.rst b/doc/source/comparison_with_sas.rst
index f51603750..85d432b54 100644
--- a/doc/source/comparison_with_sas.rst
+++ b/doc/source/comparison_with_sas.rst
@@ -271,7 +271,7 @@ date/datetime columns.
        date2 = mdy(2, 15, 2015);
        date1_year = year(date1);
        date2_month = month(date2);
-       * shift date to begninning of next interval;
+       * shift date to beginning of next interval;
        date1_next = intnx('MONTH', date1, 1);
        * count intervals between dates;
        months_between = intck('MONTH', date1, date2);
@@ -279,7 +279,7 @@ date/datetime columns.
 
 The equivalent pandas operations are shown below.  In addition to these
 functions pandas supports other Time Series features
-not available in Base SAS (such as resampling and and custom offets) -
+not available in Base SAS (such as resampling and and custom offsets) -
 see the :ref:`timeseries documentation<timeseries>` for more details.
 
 .. ipython:: python
@@ -350,7 +350,7 @@ Sorting in SAS is accomplished via ``PROC SORT``
    run;
 
 pandas objects have a :meth:`~DataFrame.sort_values` method, which
-takes a list of columnns to sort by.
+takes a list of columns to sort by.
 
 .. ipython:: python
 
diff --git a/doc/source/cookbook.rst b/doc/source/cookbook.rst
index 779ebf87f..92ed85071 100644
--- a/doc/source/cookbook.rst
+++ b/doc/source/cookbook.rst
@@ -333,7 +333,7 @@ The :ref:`multindexing <advanced.hierarchical>` docs.
 
    # As Labelled Index
    df = df.set_index('row');df
-   # With Heirarchical Columns
+   # With Hierarchical Columns
    df.columns = pd.MultiIndex.from_tuples([tuple(c.split('_')) for c in df.columns]);df
    # Now stack & Reset
    df = df.stack(0).reset_index(1);df
diff --git a/doc/source/dsintro.rst b/doc/source/dsintro.rst
index 5a62e7dcc..11c743d6e 100644
--- a/doc/source/dsintro.rst
+++ b/doc/source/dsintro.rst
@@ -46,7 +46,7 @@ Series
 
 .. warning::
 
-   In 0.13.0 ``Series`` has internaly been refactored to no longer sub-class ``ndarray``
+   In 0.13.0 ``Series`` has internally been refactored to no longer sub-class ``ndarray``
    but instead subclass ``NDFrame``, similarly to the rest of the pandas containers. This should be
    a transparent change with only very limited API implications (See the :ref:`Internal Refactoring<whatsnew_0130.refactoring>`)
 
diff --git a/doc/source/ecosystem.rst b/doc/source/ecosystem.rst
index 762656ba0..683cb671b 100644
--- a/doc/source/ecosystem.rst
+++ b/doc/source/ecosystem.rst
@@ -155,7 +155,7 @@ or multi-indexed DataFrames.
 fredapi is a Python interface to the `Federal Reserve Economic Data (FRED) <http://research.stlouisfed.org/fred2/>`__
 provided by the Federal Reserve Bank of St. Louis. It works with both the FRED database and ALFRED database that
 contains point-in-time data (i.e. historic data revisions). fredapi provides a wrapper in python to the FRED
-HTTP API, and also provides several conveninent methods for parsing and analyzing point-in-time data from ALFRED.
+HTTP API, and also provides several convenient methods for parsing and analyzing point-in-time data from ALFRED.
 fredapi makes use of pandas and returns data in a Series or DataFrame. This module requires a FRED API key that
 you can obtain for free on the FRED website.
 
diff --git a/doc/source/enhancingperf.rst b/doc/source/enhancingperf.rst
index ead4c1034..946256d58 100644
--- a/doc/source/enhancingperf.rst
+++ b/doc/source/enhancingperf.rst
@@ -745,7 +745,7 @@ Technical Minutia Regarding Expression Evaluation
 
 Expressions that would result in an object dtype or involve datetime operations
 (because of ``NaT``) must be evaluated in Python space. The main reason for
-this behavior is to maintain backwards compatbility with versions of numpy <
+this behavior is to maintain backwards compatibility with versions of numpy <
 1.7. In those versions of ``numpy`` a call to ``ndarray.astype(str)`` will
 truncate any strings that are more than 60 characters in length. Second, we
 can't pass ``object`` arrays to ``numexpr`` thus string comparisons must be
diff --git a/doc/source/groupby.rst b/doc/source/groupby.rst
index e517e9ab9..4ae2ee192 100644
--- a/doc/source/groupby.rst
+++ b/doc/source/groupby.rst
@@ -649,7 +649,7 @@ For dataframes with multiple columns, filters should explicitly specify a column
 .. note::
 
    Some functions when applied to a groupby object will act as a **filter** on the input, returning
-   a reduced shape of the original (and potentitally eliminating groups), but with the index unchanged.
+   a reduced shape of the original (and potentially eliminating groups), but with the index unchanged.
    Passing ``as_index=False`` will not affect these transformation methods.
 
    For example: ``head, tail``.
diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index af5087689..72f1e5749 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -138,7 +138,7 @@ lower-dimensional slices. Thus,
 
     Series; ``series[label]``; scalar value
     DataFrame; ``frame[colname]``; ``Series`` corresponding to colname
-    Panel; ``panel[itemname]``; ``DataFrame`` corresponing to the itemname
+    Panel; ``panel[itemname]``; ``DataFrame`` corresponding to the itemname
 
 Here we construct a simple time series data set to use for illustrating the
 indexing functionality:
diff --git a/doc/source/io.rst b/doc/source/io.rst
index 8001cd372..807838edb 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -3065,7 +3065,7 @@ indexed dimension as the ``where``.
    i = store.root.df.table.cols.index.index
    i.optlevel, i.kind
 
-Ofentimes when appending large amounts of data to a store, it is useful to turn off index creation for each append, then recreate at the end.
+Oftentimes when appending large amounts of data to a store, it is useful to turn off index creation for each append, then recreate at the end.
 
 .. ipython:: python
 
@@ -4415,7 +4415,7 @@ whether imported ``Categorical`` variables are ordered.
 
     *Stata* supports partially labeled series.  These series have value labels for
     some but not all data values. Importing a partially labeled series will produce
-    a ``Categorial`` with string categories for the values that are labeled and
+    a ``Categorical`` with string categories for the values that are labeled and
     numeric categories for values with no label.
 
 .. _io.other:
diff --git a/doc/source/merging.rst b/doc/source/merging.rst
index eb75c2982..074b15bbb 100644
--- a/doc/source/merging.rst
+++ b/doc/source/merging.rst
@@ -135,7 +135,7 @@ functionality below.
 .. note::
    It is worth noting however, that ``concat`` (and therefore ``append``) makes
    a full copy of the data, and that constantly reusing this function can
-   create a signifcant performance hit. If you need to use the operation over
+   create a significant performance hit. If you need to use the operation over
    several datasets, use a list comprehension.
 
 ::
diff --git a/doc/source/timedeltas.rst b/doc/source/timedeltas.rst
index 39b73b307..c9aa10478 100644
--- a/doc/source/timedeltas.rst
+++ b/doc/source/timedeltas.rst
@@ -334,7 +334,7 @@ Similarly to other of the datetime-like indices, ``DatetimeIndex`` and ``PeriodI
               index=timedelta_range('1 days', periods=100, freq='h'))
    s
 
-Selections work similary, with coercion on string-likes and slices:
+Selections work similarly, with coercion on string-likes and slices:
 
 .. ipython:: python
 
diff --git a/doc/source/timeseries.rst b/doc/source/timeseries.rst
index 50f104f45..b5be9cf39 100644
--- a/doc/source/timeseries.rst
+++ b/doc/source/timeseries.rst
@@ -672,7 +672,7 @@ used exactly like a ``Timedelta`` - see the
 
 Note that some offsets (such as ``BQuarterEnd``) do not have a
 vectorized implementation.  They can still be used but may
-calculate signficantly slower and will raise a ``PerformanceWarning``
+calculate significantly slower and will raise a ``PerformanceWarning``
 
 .. ipython:: python
    :okwarning:
@@ -885,7 +885,7 @@ frequencies. We will refer to these aliases as *offset aliases*
     "H", "hourly frequency"
     "T, min", "minutely frequency"
     "S", "secondly frequency"
-    "L, ms", "milliseonds"
+    "L, ms", "milliseconds"
     "U, us", "microseconds"
     "N", "nanoseconds"
 
@@ -1374,7 +1374,7 @@ frequency. Arithmetic is not allowed between ``Period`` with different ``freq``
    p == Period('2012-01', freq='3M')
 
 
-If ``Period`` freq is daily or higher (``D``, ``H``, ``T``, ``S``, ``L``, ``U``, ``N``), ``offsets`` and ``timedelta``-like can be added if the result can have the same freq. Otherise, ``ValueError`` will be raised.
+If ``Period`` freq is daily or higher (``D``, ``H``, ``T``, ``S``, ``L``, ``U``, ``N``), ``offsets`` and ``timedelta``-like can be added if the result can have the same freq. Otherwise, ``ValueError`` will be raised.
 
 .. ipython:: python
 
diff --git a/doc/source/visualization.rst b/doc/source/visualization.rst
index 4b42ceff4..12be3037d 100644
--- a/doc/source/visualization.rst
+++ b/doc/source/visualization.rst
@@ -466,7 +466,7 @@ When ``subplots=False`` / ``by`` is ``None``:
    This is the default of ``boxplot`` in historical reason.
    Note that ``plot(kind='box')`` returns ``Axes`` as default as the same as other plots.
 * if ``return_type`` is ``'axes'``, a :class:`matplotlib Axes <matplotlib.axes.Axes>` containing the boxplot is returned.
-* if ``return_type`` is ``'both'`` a namedtuple containging the :class:`matplotlib Axes <matplotlib.axes.Axes>`
+* if ``return_type`` is ``'both'`` a namedtuple containing the :class:`matplotlib Axes <matplotlib.axes.Axes>`
    and :class:`matplotlib Lines <matplotlib.lines.Line2D>` is returned
 
 When ``subplots=True`` / ``by`` is some column of the DataFrame:

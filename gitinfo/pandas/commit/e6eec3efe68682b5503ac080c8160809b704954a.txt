commit e6eec3efe68682b5503ac080c8160809b704954a
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sun Nov 18 09:37:52 2018 -0800

    TST: Use new arithmetic fixtures, parametrize many more tests (#23757)

diff --git a/pandas/tests/arithmetic/conftest.py b/pandas/tests/arithmetic/conftest.py
index e5d9c8569..63a5c40a3 100644
--- a/pandas/tests/arithmetic/conftest.py
+++ b/pandas/tests/arithmetic/conftest.py
@@ -5,9 +5,6 @@ import numpy as np
 import pandas as pd
 
 from pandas.compat import long
-from pandas.core.arrays import (
-    PeriodArray, DatetimeArrayMixin as DatetimeArray,
-    TimedeltaArrayMixin as TimedeltaArray)
 import pandas.util.testing as tm
 
 
@@ -189,33 +186,6 @@ def box_transpose_fail(request):
     return request.param
 
 
-@pytest.fixture(params=[pd.Index, pd.Series, pd.DataFrame, PeriodArray],
-                ids=id_func)
-def box_with_period(request):
-    """
-    Like `box`, but specific to PeriodDtype for also testing PeriodArray
-    """
-    return request.param
-
-
-@pytest.fixture(params=[pd.Index, pd.Series, pd.DataFrame, DatetimeArray],
-                ids=id_func)
-def box_with_datetime(request):
-    """
-    Like `box`, but specific to datetime64 for also testing DatetimeArray
-    """
-    return request.param
-
-
-@pytest.fixture(params=[pd.Index, pd.Series, pd.DataFrame, TimedeltaArray],
-                ids=id_func)
-def box_with_timedelta(request):
-    """
-    Like `box`, but specific to timedelta64 for also testing TimedeltaArray
-    """
-    return request.param
-
-
 @pytest.fixture(params=[pd.Index, pd.Series, pd.DataFrame, tm.to_array],
                 ids=id_func)
 def box_with_array(request):
@@ -224,3 +194,7 @@ def box_with_array(request):
     classes
     """
     return request.param
+
+
+# alias so we can use the same fixture for multiple parameters in a test
+box_with_array2 = box_with_array
diff --git a/pandas/tests/arithmetic/test_datetime64.py b/pandas/tests/arithmetic/test_datetime64.py
index cd28e60b6..78af50697 100644
--- a/pandas/tests/arithmetic/test_datetime64.py
+++ b/pandas/tests/arithmetic/test_datetime64.py
@@ -20,8 +20,6 @@ from pandas.errors import PerformanceWarning, NullFrequencyError
 from pandas._libs.tslibs.conversion import localize_pydatetime
 from pandas._libs.tslibs.offsets import shift_months
 
-from pandas.core import ops
-
 from pandas import (
     Timestamp, Timedelta, Period, Series, date_range, NaT,
     DatetimeIndex, TimedeltaIndex)
@@ -53,21 +51,26 @@ class TestDatetime64DataFrameComparison(object):
 
 class TestDatetime64SeriesComparison(object):
     # TODO: moved from tests.series.test_operators; needs cleanup
-    def test_comparison_invalid(self):
+    def test_comparison_invalid(self, box):
         # GH#4968
         # invalid date/int comparisons
+        xbox = box if box not in [pd.Index, DatetimeArray] else np.ndarray
+
         ser = Series(range(5))
         ser2 = Series(pd.date_range('20010101', periods=5))
 
+        ser = tm.box_expected(ser, box)
+        ser2 = tm.box_expected(ser2, box)
+
         for (x, y) in [(ser, ser2), (ser2, ser)]:
 
             result = x == y
-            expected = Series([False] * 5)
-            tm.assert_series_equal(result, expected)
+            expected = tm.box_expected([False] * 5, xbox)
+            tm.assert_equal(result, expected)
 
             result = x != y
-            expected = Series([True] * 5)
-            tm.assert_series_equal(result, expected)
+            expected = tm.box_expected([True] * 5, xbox)
+            tm.assert_equal(result, expected)
 
             with pytest.raises(TypeError):
                 x >= y
@@ -84,27 +87,33 @@ class TestDatetime64SeriesComparison(object):
         [Period('2011-01', freq='M'), NaT, Period('2011-03', freq='M')]
     ])
     @pytest.mark.parametrize('dtype', [None, object])
-    def test_nat_comparisons_scalar(self, dtype, data):
-        left = Series(data, dtype=dtype)
-
-        expected = Series([False, False, False])
-        tm.assert_series_equal(left == NaT, expected)
-        tm.assert_series_equal(NaT == left, expected)
+    def test_nat_comparisons_scalar(self, dtype, data, box):
+        xbox = box if box is not pd.Index else np.ndarray
 
-        expected = Series([True, True, True])
-        tm.assert_series_equal(left != NaT, expected)
-        tm.assert_series_equal(NaT != left, expected)
-
-        expected = Series([False, False, False])
-        tm.assert_series_equal(left < NaT, expected)
-        tm.assert_series_equal(NaT > left, expected)
-        tm.assert_series_equal(left <= NaT, expected)
-        tm.assert_series_equal(NaT >= left, expected)
-
-        tm.assert_series_equal(left > NaT, expected)
-        tm.assert_series_equal(NaT < left, expected)
-        tm.assert_series_equal(left >= NaT, expected)
-        tm.assert_series_equal(NaT <= left, expected)
+        left = Series(data, dtype=dtype)
+        left = tm.box_expected(left, box)
+
+        expected = [False, False, False]
+        expected = tm.box_expected(expected, xbox)
+        tm.assert_equal(left == NaT, expected)
+        tm.assert_equal(NaT == left, expected)
+
+        expected = [True, True, True]
+        expected = tm.box_expected(expected, xbox)
+        tm.assert_equal(left != NaT, expected)
+        tm.assert_equal(NaT != left, expected)
+
+        expected = [False, False, False]
+        expected = tm.box_expected(expected, xbox)
+        tm.assert_equal(left < NaT, expected)
+        tm.assert_equal(NaT > left, expected)
+        tm.assert_equal(left <= NaT, expected)
+        tm.assert_equal(NaT >= left, expected)
+
+        tm.assert_equal(left > NaT, expected)
+        tm.assert_equal(NaT < left, expected)
+        tm.assert_equal(left >= NaT, expected)
+        tm.assert_equal(NaT <= left, expected)
 
     def test_series_comparison_scalars(self):
         series = Series(date_range('1/1/2000', periods=10))
@@ -159,16 +168,15 @@ class TestDatetime64SeriesComparison(object):
         assert "a TypeError will be raised" in str(m[0].message)
 
     @pytest.mark.skip(reason="GH#21359")
-    def test_dt64ser_cmp_date_invalid(self, box_with_datetime):
+    def test_dt64ser_cmp_date_invalid(self, box_with_array):
         # GH#19800 datetime.date comparison raises to
         # match DatetimeIndex/Timestamp.  This also matches the behavior
         # of stdlib datetime.datetime
-        box = box_with_datetime
 
         ser = pd.date_range('20010101', periods=10)
         date = ser.iloc[0].to_pydatetime().date()
 
-        ser = tm.box_expected(ser, box)
+        ser = tm.box_expected(ser, box_with_array)
         assert not (ser == date).any()
         assert (ser != date).all()
         with pytest.raises(TypeError):
@@ -180,18 +188,6 @@ class TestDatetime64SeriesComparison(object):
         with pytest.raises(TypeError):
             ser <= date
 
-    def test_dt64ser_cmp_period_scalar(self):
-        ser = Series(pd.period_range('2000-01-01', periods=10, freq='D'))
-        val = Period('2000-01-04', freq='D')
-        result = ser > val
-        expected = Series([x > val for x in ser])
-        tm.assert_series_equal(result, expected)
-
-        val = ser[5]
-        result = ser > val
-        expected = Series([x > val for x in ser])
-        tm.assert_series_equal(result, expected)
-
     @pytest.mark.parametrize("left,right", [
         ("lt", "gt"),
         ("le", "ge"),
@@ -230,9 +226,9 @@ class TestDatetime64SeriesComparison(object):
         result = right_f(pd.Timestamp("nat"), s_nat)
         tm.assert_series_equal(result, expected)
 
-    def test_dt64arr_timestamp_equality(self, box_with_datetime):
+    def test_dt64arr_timestamp_equality(self, box_with_array):
         # GH#11034
-        box = box_with_datetime
+        box = box_with_array
         xbox = box if box not in [pd.Index, DatetimeArray] else np.ndarray
 
         ser = pd.Series([pd.Timestamp('2000-01-29 01:59:00'), 'NaT'])
@@ -648,15 +644,163 @@ class TestDatetimeIndexComparisons(object):
 # ------------------------------------------------------------------
 # Arithmetic
 
-class TestFrameArithmetic(object):
-    def test_dt64arr_sub_timestamp(self, box):
+class TestDatetime64Arithmetic(object):
+    # This class is intended for "finished" tests that are fully parametrized
+    #  over DataFrame/Series/Index/DatetimeArray
+
+    # -------------------------------------------------------------
+    # Addition/Subtraction of timedelta-like
+
+    def test_dt64arr_add_timedeltalike_scalar(self, tz_naive_fixture,
+                                              two_hours, box_with_array):
+        # GH#22005, GH#22163 check DataFrame doesn't raise TypeError
+        tz = tz_naive_fixture
+
+        rng = pd.date_range('2000-01-01', '2000-02-01', tz=tz)
+        expected = pd.date_range('2000-01-01 02:00',
+                                 '2000-02-01 02:00', tz=tz)
+
+        # FIXME: calling with transpose=True raises ValueError
+        rng = tm.box_expected(rng, box_with_array, transpose=False)
+        expected = tm.box_expected(expected, box_with_array, transpose=False)
+
+        result = rng + two_hours
+        tm.assert_equal(result, expected)
+
+    def test_dt64arr_iadd_timedeltalike_scalar(self, tz_naive_fixture,
+                                               two_hours, box_with_array):
+        tz = tz_naive_fixture
+
+        rng = pd.date_range('2000-01-01', '2000-02-01', tz=tz)
+        expected = pd.date_range('2000-01-01 02:00',
+                                 '2000-02-01 02:00', tz=tz)
+
+        # FIXME: calling with transpose=True raises ValueError
+        rng = tm.box_expected(rng, box_with_array, transpose=False)
+        expected = tm.box_expected(expected, box_with_array, transpose=False)
+
+        rng += two_hours
+        tm.assert_equal(rng, expected)
+
+    def test_dt64arr_sub_timedeltalike_scalar(self, tz_naive_fixture,
+                                              two_hours, box_with_array):
+        tz = tz_naive_fixture
+
+        rng = pd.date_range('2000-01-01', '2000-02-01', tz=tz)
+        expected = pd.date_range('1999-12-31 22:00',
+                                 '2000-01-31 22:00', tz=tz)
+
+        # FIXME: calling with transpose=True raises ValueError
+        rng = tm.box_expected(rng, box_with_array, transpose=False)
+        expected = tm.box_expected(expected, box_with_array, transpose=False)
+
+        result = rng - two_hours
+        tm.assert_equal(result, expected)
+
+    def test_dt64arr_isub_timedeltalike_scalar(self, tz_naive_fixture,
+                                               two_hours, box_with_array):
+        tz = tz_naive_fixture
+
+        rng = pd.date_range('2000-01-01', '2000-02-01', tz=tz)
+        expected = pd.date_range('1999-12-31 22:00',
+                                 '2000-01-31 22:00', tz=tz)
+
+        # FIXME: calling with transpose=True raises ValueError
+        rng = tm.box_expected(rng, box_with_array, transpose=False)
+        expected = tm.box_expected(expected, box_with_array, transpose=False)
+
+        rng -= two_hours
+        tm.assert_equal(rng, expected)
+
+    def test_dt64arr_add_td64_scalar(self, box_with_array):
+        # scalar timedeltas/np.timedelta64 objects
+        # operate with np.timedelta64 correctly
+        ser = Series([Timestamp('20130101 9:01'), Timestamp('20130101 9:02')])
+
+        expected = Series([Timestamp('20130101 9:01:01'),
+                           Timestamp('20130101 9:02:01')])
+
+        dtarr = tm.box_expected(ser, box_with_array)
+        expected = tm.box_expected(expected, box_with_array)
+
+        result = dtarr + np.timedelta64(1, 's')
+        tm.assert_equal(result, expected)
+        result = np.timedelta64(1, 's') + dtarr
+        tm.assert_equal(result, expected)
+
+        expected = Series([Timestamp('20130101 9:01:00.005'),
+                           Timestamp('20130101 9:02:00.005')])
+        expected = tm.box_expected(expected, box_with_array)
+
+        result = dtarr + np.timedelta64(5, 'ms')
+        tm.assert_equal(result, expected)
+        result = np.timedelta64(5, 'ms') + dtarr
+        tm.assert_equal(result, expected)
+
+    def test_dt64arr_add_sub_td64_nat(self, box_with_array, tz_naive_fixture):
+        # GH#23320 special handling for timedelta64("NaT")
+        tz = tz_naive_fixture
+
+        dti = pd.date_range("1994-04-01", periods=9, tz=tz, freq="QS")
+        other = np.timedelta64("NaT")
+        expected = pd.DatetimeIndex(["NaT"] * 9, tz=tz)
+
+        # FIXME: fails with transpose=True due to tz-aware DataFrame
+        #  transpose bug
+        obj = tm.box_expected(dti, box_with_array, transpose=False)
+        expected = tm.box_expected(expected, box_with_array, transpose=False)
+
+        result = obj + other
+        tm.assert_equal(result, expected)
+        result = other + obj
+        tm.assert_equal(result, expected)
+        result = obj - other
+        tm.assert_equal(result, expected)
+        with pytest.raises(TypeError):
+            other - obj
+
+    def test_dt64arr_add_sub_td64ndarray(self, tz_naive_fixture,
+                                         box_with_array):
+        if box_with_array is pd.DataFrame:
+            pytest.xfail("FIXME: ValueError with transpose; "
+                         "alignment error without")
+
+        tz = tz_naive_fixture
+        dti = pd.date_range('2016-01-01', periods=3, tz=tz)
+        tdi = pd.TimedeltaIndex(['-1 Day', '-1 Day', '-1 Day'])
+        tdarr = tdi.values
+
+        expected = pd.date_range('2015-12-31', periods=3, tz=tz)
+
+        dtarr = tm.box_expected(dti, box_with_array)
+        expected = tm.box_expected(expected, box_with_array)
+
+        result = dtarr + tdarr
+        tm.assert_equal(result, expected)
+        result = tdarr + dtarr
+        tm.assert_equal(result, expected)
+
+        expected = pd.date_range('2016-01-02', periods=3, tz=tz)
+        expected = tm.box_expected(expected, box_with_array)
+
+        result = dtarr - tdarr
+        tm.assert_equal(result, expected)
+
+        with pytest.raises(TypeError):
+            tdarr - dtarr
+
+    # -----------------------------------------------------------------
+    # Subtraction of datetime-like scalars
+
+    @pytest.mark.parametrize('ts', [
+        pd.Timestamp('2013-01-01'),
+        pd.Timestamp('2013-01-01').to_pydatetime(),
+        pd.Timestamp('2013-01-01').to_datetime64()])
+    def test_dt64arr_sub_dtscalar(self, box, ts):
         # GH#8554, GH#22163 DataFrame op should _not_ return dt64 dtype
         idx = pd.date_range('2013-01-01', periods=3)
         idx = tm.box_expected(idx, box)
 
-        ts = pd.Timestamp('2013-01-01')
-        # TODO: parametrize over scalar types
-
         expected = pd.TimedeltaIndex(['0 Days', '1 Day', '2 Days'])
         expected = tm.box_expected(expected, box)
 
@@ -666,21 +810,20 @@ class TestFrameArithmetic(object):
     def test_dt64arr_sub_datetime64_not_ns(self, box):
         # GH#7996, GH#22163 ensure non-nano datetime64 is converted to nano
         #  for DataFrame operation
+        dt64 = np.datetime64('2013-01-01')
+        assert dt64.dtype == 'datetime64[D]'
 
         dti = pd.date_range('20130101', periods=3)
         dtarr = tm.box_expected(dti, box)
 
-        dt64 = np.datetime64('2013-01-01')
-        assert dt64.dtype == 'datetime64[D]'
-
         expected = pd.TimedeltaIndex(['0 Days', '1 Day', '2 Days'])
         expected = tm.box_expected(expected, box)
 
         result = dtarr - dt64
         tm.assert_equal(result, expected)
 
-
-class TestTimestampSeriesArithmetic(object):
+        result = dt64 - dtarr
+        tm.assert_equal(result, -expected)
 
     def test_dt64arr_sub_timestamp(self, box):
         ser = pd.date_range('2014-03-17', periods=2, freq='D',
@@ -697,6 +840,144 @@ class TestTimestampSeriesArithmetic(object):
         tm.assert_equal(ser - ts, expected)
         tm.assert_equal(ts - ser, -expected)
 
+    def test_dt64arr_sub_NaT(self, box):
+        # GH#18808
+        dti = pd.DatetimeIndex([pd.NaT, pd.Timestamp('19900315')])
+        ser = tm.box_expected(dti, box, transpose=False)
+
+        result = ser - pd.NaT
+        expected = pd.Series([pd.NaT, pd.NaT], dtype='timedelta64[ns]')
+        # FIXME: raises ValueError with transpose
+        expected = tm.box_expected(expected, box, transpose=False)
+        tm.assert_equal(result, expected)
+
+        dti_tz = dti.tz_localize('Asia/Tokyo')
+        ser_tz = tm.box_expected(dti_tz, box, transpose=False)
+
+        result = ser_tz - pd.NaT
+        expected = pd.Series([pd.NaT, pd.NaT], dtype='timedelta64[ns]')
+        expected = tm.box_expected(expected, box, transpose=False)
+        tm.assert_equal(result, expected)
+
+    # -------------------------------------------------------------
+    # Subtraction of datetime-like array-like
+
+    def test_dt64arr_naive_sub_dt64ndarray(self, box_with_array):
+        dti = pd.date_range('2016-01-01', periods=3, tz=None)
+        dt64vals = dti.values
+
+        dtarr = tm.box_expected(dti, box_with_array)
+
+        expected = dtarr - dtarr
+        result = dtarr - dt64vals
+        tm.assert_equal(result, expected)
+        result = dt64vals - dtarr
+        tm.assert_equal(result, expected)
+
+    def test_dt64arr_aware_sub_dt64ndarray_raises(self, tz_aware_fixture,
+                                                  box_with_array):
+        if box_with_array is pd.DataFrame:
+            pytest.xfail("FIXME: ValueError with transpose; "
+                         "alignment error without")
+
+        tz = tz_aware_fixture
+        dti = pd.date_range('2016-01-01', periods=3, tz=tz)
+        dt64vals = dti.values
+
+        dtarr = tm.box_expected(dti, box_with_array)
+
+        with pytest.raises(TypeError):
+            dtarr - dt64vals
+        with pytest.raises(TypeError):
+            dt64vals - dtarr
+
+    # -------------------------------------------------------------
+    # Addition of datetime-like others (invalid)
+
+    def test_dt64arr_add_dt64ndarray_raises(self, tz_naive_fixture,
+                                            box_with_array):
+        if box_with_array is pd.DataFrame:
+            pytest.xfail("FIXME: ValueError with transpose; "
+                         "alignment error without")
+
+        tz = tz_naive_fixture
+        dti = pd.date_range('2016-01-01', periods=3, tz=tz)
+        dt64vals = dti.values
+
+        dtarr = tm.box_expected(dti, box_with_array)
+
+        with pytest.raises(TypeError):
+            dtarr + dt64vals
+        with pytest.raises(TypeError):
+            dt64vals + dtarr
+
+    def test_dt64arr_add_timestamp_raises(self, box_with_array):
+        # GH#22163 ensure DataFrame doesn't cast Timestamp to i8
+        idx = DatetimeIndex(['2011-01-01', '2011-01-02'])
+        idx = tm.box_expected(idx, box_with_array)
+        msg = "cannot add"
+        with pytest.raises(TypeError, match=msg):
+            idx + Timestamp('2011-01-01')
+        with pytest.raises(TypeError, match=msg):
+            Timestamp('2011-01-01') + idx
+
+    # -------------------------------------------------------------
+    # Other Invalid Addition/Subtraction
+
+    @pytest.mark.parametrize('other', [3.14, np.array([2.0, 3.0])])
+    def test_dt64arr_add_sub_float(self, other, box_with_array):
+        dti = DatetimeIndex(['2011-01-01', '2011-01-02'], freq='D')
+        dtarr = tm.box_expected(dti, box_with_array)
+        with pytest.raises(TypeError):
+            dtarr + other
+        with pytest.raises(TypeError):
+            other + dtarr
+        with pytest.raises(TypeError):
+            dtarr - other
+        with pytest.raises(TypeError):
+            other - dtarr
+
+    @pytest.mark.parametrize('pi_freq', ['D', 'W', 'Q', 'H'])
+    @pytest.mark.parametrize('dti_freq', [None, 'D'])
+    def test_dt64arr_add_sub_parr(self, dti_freq, pi_freq,
+                                  box_with_array, box_with_array2):
+        # GH#20049 subtracting PeriodIndex should raise TypeError
+        dti = pd.DatetimeIndex(['2011-01-01', '2011-01-02'], freq=dti_freq)
+        pi = dti.to_period(pi_freq)
+
+        dtarr = tm.box_expected(dti, box_with_array)
+        parr = tm.box_expected(pi, box_with_array2)
+
+        with pytest.raises(TypeError):
+            dtarr + parr
+        with pytest.raises(TypeError):
+            parr + dtarr
+        with pytest.raises(TypeError):
+            dtarr - parr
+        with pytest.raises(TypeError):
+            parr - dtarr
+
+    @pytest.mark.parametrize('dti_freq', [None, 'D'])
+    def test_dt64arr_add_sub_period_scalar(self, dti_freq, box_with_array):
+        # GH#13078
+        # not supported, check TypeError
+        per = pd.Period('2011-01-01', freq='D')
+
+        idx = pd.DatetimeIndex(['2011-01-01', '2011-01-02'], freq=dti_freq)
+        dtarr = tm.box_expected(idx, box_with_array)
+
+        with pytest.raises(TypeError):
+            dtarr + per
+        with pytest.raises(TypeError):
+            per + dtarr
+        with pytest.raises(TypeError):
+            dtarr - per
+        with pytest.raises(TypeError):
+            per - dtarr
+
+
+class TestTimestampSeriesArithmetic(object):
+
     def test_dt64ser_sub_datetime_dtype(self):
         ts = Timestamp(datetime(1993, 1, 7, 13, 30, 00))
         dt = datetime(1993, 6, 22, 13, 30)
@@ -753,26 +1034,8 @@ class TestTimestampSeriesArithmetic(object):
         if op_str not in ['__add__', '__radd__', '__sub__', '__rsub__']:
             check(dt2, td2)
 
-    def test_sub_datetime64_not_ns(self, box):
-        # GH#7996 operation with non-nano datetime64 scalar
-        dt64 = np.datetime64('2013-01-01')
-        assert dt64.dtype == 'datetime64[D]'
-
-        obj = date_range('20130101', periods=3)
-        obj = tm.box_expected(obj, box)
-
-        expected = TimedeltaIndex([Timedelta(days=0), Timedelta(days=1),
-                                   Timedelta(days=2)])
-        expected = tm.box_expected(expected, box)
-
-        result = obj - dt64
-        tm.assert_equal(result, expected)
-
-        result = dt64 - obj
-        tm.assert_equal(result, -expected)
-
     def test_sub_single_tz(self):
-        # GH12290
+        # GH#12290
         s1 = Series([pd.Timestamp('2016-02-10', tz='America/Sao_Paulo')])
         s2 = Series([pd.Timestamp('2016-02-08', tz='America/Sao_Paulo')])
         result = s1 - s2
@@ -795,57 +1058,44 @@ class TestTimestampSeriesArithmetic(object):
         tm.assert_series_equal(res, expected)
 
     def test_sub_datetime_compat(self):
-        # see gh-14088
+        # see GH#14088
         s = Series([datetime(2016, 8, 23, 12, tzinfo=pytz.utc), pd.NaT])
         dt = datetime(2016, 8, 22, 12, tzinfo=pytz.utc)
         exp = Series([Timedelta('1 days'), pd.NaT])
         tm.assert_series_equal(s - dt, exp)
         tm.assert_series_equal(s - Timestamp(dt), exp)
 
-    def test_dt64_series_addsub_timedelta(self):
-        # scalar timedeltas/np.timedelta64 objects
-        # operate with np.timedelta64 correctly
-        s = Series([Timestamp('20130101 9:01'), Timestamp('20130101 9:02')])
-
-        result = s + np.timedelta64(1, 's')
-        result2 = np.timedelta64(1, 's') + s
-        expected = Series([Timestamp('20130101 9:01:01'),
-                           Timestamp('20130101 9:02:01')])
-        tm.assert_series_equal(result, expected)
-        tm.assert_series_equal(result2, expected)
-
-        result = s + np.timedelta64(5, 'ms')
-        result2 = np.timedelta64(5, 'ms') + s
-        expected = Series([Timestamp('20130101 9:01:00.005'),
-                           Timestamp('20130101 9:02:00.005')])
-        tm.assert_series_equal(result, expected)
-        tm.assert_series_equal(result2, expected)
-
-    def test_dt64_series_add_tick_DateOffset(self):
-        # GH 4532
+    def test_dt64_series_add_tick_DateOffset(self, box_with_array):
+        # GH#4532
         # operate with pd.offsets
         ser = Series([Timestamp('20130101 9:01'), Timestamp('20130101 9:02')])
         expected = Series([Timestamp('20130101 9:01:05'),
                            Timestamp('20130101 9:02:05')])
 
+        ser = tm.box_expected(ser, box_with_array)
+        expected = tm.box_expected(expected, box_with_array)
+
         result = ser + pd.offsets.Second(5)
-        tm.assert_series_equal(result, expected)
+        tm.assert_equal(result, expected)
 
         result2 = pd.offsets.Second(5) + ser
-        tm.assert_series_equal(result2, expected)
+        tm.assert_equal(result2, expected)
 
-    def test_dt64_series_sub_tick_DateOffset(self):
-        # GH 4532
+    def test_dt64_series_sub_tick_DateOffset(self, box_with_array):
+        # GH#4532
         # operate with pd.offsets
         ser = Series([Timestamp('20130101 9:01'), Timestamp('20130101 9:02')])
         expected = Series([Timestamp('20130101 9:00:55'),
                            Timestamp('20130101 9:01:55')])
 
+        ser = tm.box_expected(ser, box_with_array)
+        expected = tm.box_expected(expected, box_with_array)
+
         result = ser - pd.offsets.Second(5)
-        tm.assert_series_equal(result, expected)
+        tm.assert_equal(result, expected)
 
         result2 = -pd.offsets.Second(5) + ser
-        tm.assert_series_equal(result2, expected)
+        tm.assert_equal(result2, expected)
 
         with pytest.raises(TypeError):
             pd.offsets.Second(5) - ser
@@ -853,7 +1103,7 @@ class TestTimestampSeriesArithmetic(object):
     @pytest.mark.parametrize('cls_name', ['Day', 'Hour', 'Minute', 'Second',
                                           'Milli', 'Micro', 'Nano'])
     def test_dt64_series_add_tick_DateOffset_smoke(self, cls_name):
-        # GH 4532
+        # GH#4532
         # smoke tests for valid DateOffsets
         ser = Series([Timestamp('20130101 9:01'), Timestamp('20130101 9:02')])
 
@@ -862,7 +1112,7 @@ class TestTimestampSeriesArithmetic(object):
         offset_cls(5) + ser
 
     def test_dt64_series_add_mixed_tick_DateOffset(self):
-        # GH 4532
+        # GH#4532
         # operate with pd.offsets
         s = Series([Timestamp('20130101 9:01'), Timestamp('20130101 9:02')])
 
@@ -878,22 +1128,8 @@ class TestTimestampSeriesArithmetic(object):
                            Timestamp('20130101 9:07:00.005')])
         tm.assert_series_equal(result, expected)
 
-    def test_dt64_series_sub_NaT(self):
-        # GH#18808
-        dti = pd.DatetimeIndex([pd.NaT, pd.Timestamp('19900315')])
-        ser = pd.Series(dti)
-        res = ser - pd.NaT
-        expected = pd.Series([pd.NaT, pd.NaT], dtype='timedelta64[ns]')
-        tm.assert_series_equal(res, expected)
-
-        dti_tz = dti.tz_localize('Asia/Tokyo')
-        ser_tz = pd.Series(dti_tz)
-        res = ser_tz - pd.NaT
-        expected = pd.Series([pd.NaT, pd.NaT], dtype='timedelta64[ns]')
-        tm.assert_series_equal(res, expected)
-
     def test_dt64_series_arith_overflow(self):
-        # GH#12534, fixed by #19024
+        # GH#12534, fixed by GH#19024
         dt = pd.Timestamp('1700-01-31')
         td = pd.Timedelta('20000 Days')
         dti = pd.date_range('1949-09-30', freq='100Y', periods=4)
@@ -924,7 +1160,7 @@ class TestTimestampSeriesArithmetic(object):
         tm.assert_series_equal(res, -expected)
 
     def test_datetime64_ops_nat(self):
-        # GH 11349
+        # GH#11349
         datetime_series = Series([NaT, Timestamp('19900315')])
         nat_series_dtype_timestamp = Series([NaT, NaT], dtype='datetime64[ns]')
         single_nat_dtype_datetime = Series([NaT], dtype='datetime64[ns]')
@@ -1060,27 +1296,6 @@ class TestTimestampSeriesArithmetic(object):
 
 class TestDatetimeIndexArithmetic(object):
 
-    # -------------------------------------------------------------
-    # Invalid Operations
-
-    @pytest.mark.parametrize('other', [3.14, np.array([2.0, 3.0])])
-    @pytest.mark.parametrize('op', [operator.add, ops.radd,
-                                    operator.sub, ops.rsub])
-    def test_dti_add_sub_float(self, op, other):
-        dti = DatetimeIndex(['2011-01-01', '2011-01-02'], freq='D')
-        with pytest.raises(TypeError):
-            op(dti, other)
-
-    def test_dti_add_timestamp_raises(self, box_with_datetime):
-        # GH#22163 ensure DataFrame doesn't cast Timestamp to i8
-        idx = DatetimeIndex(['2011-01-01', '2011-01-02'])
-        idx = tm.box_expected(idx, box_with_datetime)
-        msg = "cannot add"
-        with pytest.raises(TypeError, match=msg):
-            idx + Timestamp('2011-01-01')
-        with pytest.raises(TypeError, match=msg):
-            Timestamp('2011-01-01') + idx
-
     # -------------------------------------------------------------
     # Binary operations DatetimeIndex and int
 
@@ -1183,74 +1398,9 @@ class TestDatetimeIndexArithmetic(object):
         with pytest.raises(TypeError):
             other - dti
 
-    # -------------------------------------------------------------
-    # Binary operations DatetimeIndex and timedelta-like
-
-    def test_dti_add_timedeltalike(self, tz_naive_fixture, two_hours,
-                                   box_with_datetime):
-        # GH#22005, GH#22163 check DataFrame doesn't raise TypeError
-        box = box_with_datetime
-
-        tz = tz_naive_fixture
-        rng = pd.date_range('2000-01-01', '2000-02-01', tz=tz)
-
-        # FIXME: calling with transpose=True raises ValueError
-        rng = tm.box_expected(rng, box, transpose=False)
-
-        result = rng + two_hours
-        expected = pd.date_range('2000-01-01 02:00',
-                                 '2000-02-01 02:00', tz=tz)
-        expected = tm.box_expected(expected, box, transpose=False)
-        tm.assert_equal(result, expected)
-
-    def test_dti_iadd_timedeltalike(self, tz_naive_fixture, two_hours):
-        tz = tz_naive_fixture
-        rng = pd.date_range('2000-01-01', '2000-02-01', tz=tz)
-        expected = pd.date_range('2000-01-01 02:00',
-                                 '2000-02-01 02:00', tz=tz)
-        rng += two_hours
-        tm.assert_index_equal(rng, expected)
-
-    def test_dti_sub_timedeltalike(self, tz_naive_fixture, two_hours):
-        tz = tz_naive_fixture
-        rng = pd.date_range('2000-01-01', '2000-02-01', tz=tz)
-        expected = pd.date_range('1999-12-31 22:00',
-                                 '2000-01-31 22:00', tz=tz)
-        result = rng - two_hours
-        tm.assert_index_equal(result, expected)
-
-    def test_dti_isub_timedeltalike(self, tz_naive_fixture, two_hours):
-        tz = tz_naive_fixture
-        rng = pd.date_range('2000-01-01', '2000-02-01', tz=tz)
-        expected = pd.date_range('1999-12-31 22:00',
-                                 '2000-01-31 22:00', tz=tz)
-        rng -= two_hours
-        tm.assert_index_equal(rng, expected)
-
-    def test_dt64arr_add_sub_td64_nat(self, box, tz_naive_fixture):
-        # GH#23320 special handling for timedelta64("NaT")
-        tz = tz_naive_fixture
-
-        dti = pd.date_range("1994-04-01", periods=9, tz=tz, freq="QS")
-        other = np.timedelta64("NaT")
-        expected = pd.DatetimeIndex(["NaT"] * 9, tz=tz)
-
-        # FIXME: fails with transpose=True due to tz-aware DataFrame
-        #  transpose bug
-        obj = tm.box_expected(dti, box, transpose=False)
-        expected = tm.box_expected(expected, box, transpose=False)
-
-        result = obj + other
-        tm.assert_equal(result, expected)
-        result = other + obj
-        tm.assert_equal(result, expected)
-        result = obj - other
-        tm.assert_equal(result, expected)
-        with pytest.raises(TypeError):
-            other - obj
-
     # -------------------------------------------------------------
     # Binary operations DatetimeIndex and TimedeltaIndex/array
+
     def test_dti_add_tdi(self, tz_naive_fixture):
         # GH#17558
         tz = tz_naive_fixture
@@ -1369,66 +1519,6 @@ class TestDatetimeIndexArithmetic(object):
         with pytest.raises(TypeError, match=msg):
             addend + dti
 
-    # -------------------------------------------------------------
-    # __add__/__sub__ with ndarray[datetime64] and ndarray[timedelta64]
-
-    def test_dti_add_dt64_array_raises(self, tz_naive_fixture):
-        tz = tz_naive_fixture
-        dti = pd.date_range('2016-01-01', periods=3, tz=tz)
-        dtarr = dti.values
-
-        with pytest.raises(TypeError):
-            dti + dtarr
-        with pytest.raises(TypeError):
-            dtarr + dti
-
-    def test_dti_sub_dt64_array_naive(self):
-        dti = pd.date_range('2016-01-01', periods=3, tz=None)
-        dtarr = dti.values
-
-        expected = dti - dti
-        result = dti - dtarr
-        tm.assert_index_equal(result, expected)
-        result = dtarr - dti
-        tm.assert_index_equal(result, expected)
-
-    def test_dti_sub_dt64_array_aware_raises(self, tz_naive_fixture):
-        tz = tz_naive_fixture
-        if tz is None:
-            return
-        dti = pd.date_range('2016-01-01', periods=3, tz=tz)
-        dtarr = dti.values
-
-        with pytest.raises(TypeError):
-            dti - dtarr
-        with pytest.raises(TypeError):
-            dtarr - dti
-
-    def test_dti_add_td64_array(self, tz_naive_fixture):
-        tz = tz_naive_fixture
-        dti = pd.date_range('2016-01-01', periods=3, tz=tz)
-        tdi = pd.TimedeltaIndex(['-1 Day', '-1 Day', '-1 Day'])
-        tdarr = tdi.values
-
-        expected = dti + tdi
-        result = dti + tdarr
-        tm.assert_index_equal(result, expected)
-        result = tdarr + dti
-        tm.assert_index_equal(result, expected)
-
-    def test_dti_sub_td64_array(self, tz_naive_fixture):
-        tz = tz_naive_fixture
-        dti = pd.date_range('2016-01-01', periods=3, tz=tz)
-        tdi = pd.TimedeltaIndex(['-1 Day', '-1 Day', '-1 Day'])
-        tdarr = tdi.values
-
-        expected = dti - tdi
-        result = dti - tdarr
-        tm.assert_index_equal(result, expected)
-
-        with pytest.raises(TypeError):
-            tdarr - dti
-
     # -------------------------------------------------------------
 
     def test_sub_dti_dti(self):
@@ -1472,44 +1562,6 @@ class TestDatetimeIndexArithmetic(object):
         result = dti2 - dti1
         tm.assert_index_equal(result, expected)
 
-    @pytest.mark.parametrize('dti_freq', [None, 'D'])
-    def test_dt64arr_add_sub_period(self, dti_freq, box_with_datetime):
-        # GH#13078
-        # not supported, check TypeError
-        p = pd.Period('2011-01-01', freq='D')
-
-        idx = pd.DatetimeIndex(['2011-01-01', '2011-01-02'], freq=dti_freq)
-        idx = tm.box_expected(idx, box_with_datetime)
-
-        with pytest.raises(TypeError):
-            idx + p
-        with pytest.raises(TypeError):
-            p + idx
-        with pytest.raises(TypeError):
-            idx - p
-        with pytest.raises(TypeError):
-            p - idx
-
-    @pytest.mark.parametrize('pi_freq', ['D', 'W', 'Q', 'H'])
-    @pytest.mark.parametrize('dti_freq', [None, 'D'])
-    def test_dti_add_sub_pi(self, dti_freq, pi_freq,
-                            box_with_datetime, box_with_period):
-        # GH#20049 subtracting PeriodIndex should raise TypeError
-        dti = pd.DatetimeIndex(['2011-01-01', '2011-01-02'], freq=dti_freq)
-        pi = dti.to_period(pi_freq)
-
-        dtarr = tm.box_expected(dti, box_with_datetime)
-        parr = tm.box_expected(pi, box_with_period)
-
-        with pytest.raises(TypeError):
-            dtarr + parr
-        with pytest.raises(TypeError):
-            parr + dtarr
-        with pytest.raises(TypeError):
-            dtarr - parr
-        with pytest.raises(TypeError):
-            parr - dtarr
-
     # -------------------------------------------------------------------
     # TODO: Most of this block is moved from series or frame tests, needs
     # cleanup, box-parametrization, and de-duplication
@@ -1828,10 +1880,8 @@ class TestDatetimeIndexArithmetic(object):
             res3 = dti - other
         tm.assert_series_equal(res3, expected_sub)
 
-    def test_dti_add_offset_tzaware(self, tz_aware_fixture, box_with_datetime):
+    def test_dti_add_offset_tzaware(self, tz_aware_fixture, box_with_array):
         # GH#21610, GH#22163 ensure DataFrame doesn't return object-dtype
-        box = box_with_datetime
-
         timezone = tz_aware_fixture
         if timezone == 'US/Pacific':
             dates = date_range('2012-11-01', periods=3, tz=timezone)
@@ -1844,8 +1894,8 @@ class TestDatetimeIndexArithmetic(object):
                                   '2010-11-01 07:00'], freq='H', tz=timezone)
 
         # FIXME: these raise ValueError with transpose=True
-        dates = tm.box_expected(dates, box, transpose=False)
-        expected = tm.box_expected(expected, box, transpose=False)
+        dates = tm.box_expected(dates, box_with_array, transpose=False)
+        expected = tm.box_expected(expected, box_with_array, transpose=False)
 
         # TODO: parametrize over the scalar being added?  radd?  sub?
         offset = dates + pd.offsets.Hour(5)
diff --git a/pandas/tests/arithmetic/test_numeric.py b/pandas/tests/arithmetic/test_numeric.py
index 9163f2e1a..f1023148a 100644
--- a/pandas/tests/arithmetic/test_numeric.py
+++ b/pandas/tests/arithmetic/test_numeric.py
@@ -806,6 +806,17 @@ class TestAdditionSubtraction(object):
 
 
 class TestUFuncCompat(object):
+
+    @pytest.mark.parametrize('holder', [pd.Int64Index, pd.UInt64Index,
+                                        pd.Float64Index, pd.Series])
+    def test_ufunc_compat(self, holder):
+        box = pd.Series if holder is pd.Series else pd.Index
+
+        idx = holder(np.arange(5, dtype='int64'))
+        result = np.sin(idx)
+        expected = box(np.sin(np.arange(5, dtype='int64')))
+        tm.assert_equal(result, expected)
+
     @pytest.mark.parametrize('holder', [pd.Int64Index, pd.UInt64Index,
                                         pd.Float64Index, pd.Series])
     def test_ufunc_coercions(self, holder):
diff --git a/pandas/tests/arithmetic/test_period.py b/pandas/tests/arithmetic/test_period.py
index a26a11cb6..af3aeaaff 100644
--- a/pandas/tests/arithmetic/test_period.py
+++ b/pandas/tests/arithmetic/test_period.py
@@ -10,9 +10,9 @@ import pytest
 import pandas as pd
 import pandas.util.testing as tm
 
+from pandas._libs.tslibs.period import IncompatibleFrequency
 from pandas.errors import PerformanceWarning
 
-import pandas.core.indexes.period as period
 from pandas.core import ops
 from pandas import Period, PeriodIndex, period_range, Series
 from pandas.tseries.frequencies import to_offset
@@ -29,6 +29,26 @@ class TestPeriodIndexComparisons(object):
         exp = idx.values < idx.values[10]
         tm.assert_numpy_array_equal(result, exp)
 
+    # TODO: moved from test_datetime64; de-duplicate with version below
+    def test_parr_cmp_period_scalar2(self, box):
+        xbox = box if box is not pd.Index else np.ndarray
+
+        pi = pd.period_range('2000-01-01', periods=10, freq='D')
+
+        val = Period('2000-01-04', freq='D')
+        expected = [x > val for x in pi]
+
+        ser = tm.box_expected(pi, box)
+        expected = tm.box_expected(expected, xbox)
+        result = ser > val
+        tm.assert_equal(result, expected)
+
+        val = pi[5]
+        result = ser > val
+        expected = [x > val for x in pi]
+        expected = tm.box_expected(expected, xbox)
+        tm.assert_equal(result, expected)
+
     @pytest.mark.parametrize('freq', ['M', '2M', '3M'])
     def test_parr_cmp_period_scalar(self, freq, box):
         # GH#13200
@@ -115,27 +135,27 @@ class TestPeriodIndexComparisons(object):
         base = tm.box_expected(base, box)
 
         msg = "Input has different freq=A-DEC from "
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             base <= Period('2011', freq='A')
 
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             Period('2011', freq='A') >= base
 
         # TODO: Could parametrize over boxes for idx?
         idx = PeriodIndex(['2011', '2012', '2013', '2014'], freq='A')
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             base <= idx
 
         # Different frequency
         msg = "Input has different freq=4M from "
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             base <= Period('2011', freq='4M')
 
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             Period('2011', freq='4M') >= base
 
         idx = PeriodIndex(['2011', '2012', '2013', '2014'], freq='4M')
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             base <= idx
 
     @pytest.mark.parametrize('freq', ['M', '2M', '3M'])
@@ -187,10 +207,10 @@ class TestPeriodIndexComparisons(object):
 
         diff = PeriodIndex(['2011-02', '2011-01', '2011-04', 'NaT'], freq='4M')
         msg = "Input has different freq=4M from PeriodIndex"
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             idx1 > diff
 
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             idx1 == diff
 
     # TODO: De-duplicate with test_pi_cmp_nat
@@ -299,12 +319,12 @@ class TestPeriodIndexArithmetic(object):
     # PeriodIndex - other is defined for integers, timedelta-like others,
     #   and PeriodIndex (with matching freq)
 
-    def test_parr_add_iadd_parr_raises(self, box):
+    def test_parr_add_iadd_parr_raises(self, box_with_array):
         rng = pd.period_range('1/1/2000', freq='D', periods=5)
         other = pd.period_range('1/6/2000', freq='D', periods=5)
         # TODO: parametrize over boxes for other?
 
-        rng = tm.box_expected(rng, box)
+        rng = tm.box_expected(rng, box_with_array)
         # An earlier implementation of PeriodIndex addition performed
         # a set operation (union).  This has since been changed to
         # raise a TypeError. See GH#14164 and GH#13077 for historical
@@ -341,13 +361,13 @@ class TestPeriodIndexArithmetic(object):
         expected = pd.Index([pd.NaT, 0 * off, 0 * off, 0 * off, 0 * off])
         tm.assert_index_equal(result, expected)
 
-    def test_parr_sub_pi_mismatched_freq(self, box):
+    def test_parr_sub_pi_mismatched_freq(self, box_with_array):
         rng = pd.period_range('1/1/2000', freq='D', periods=5)
         other = pd.period_range('1/6/2000', freq='H', periods=5)
         # TODO: parametrize over boxes for other?
 
-        rng = tm.box_expected(rng, box)
-        with pytest.raises(period.IncompatibleFrequency):
+        rng = tm.box_expected(rng, box_with_array)
+        with pytest.raises(IncompatibleFrequency):
             rng - other
 
     # -------------------------------------------------------------
@@ -356,19 +376,20 @@ class TestPeriodIndexArithmetic(object):
     @pytest.mark.parametrize('other', [3.14, np.array([2.0, 3.0])])
     @pytest.mark.parametrize('op', [operator.add, ops.radd,
                                     operator.sub, ops.rsub])
-    def test_pi_add_sub_float(self, op, other, box):
+    def test_parr_add_sub_float_raises(self, op, other, box_with_array):
         dti = pd.DatetimeIndex(['2011-01-01', '2011-01-02'], freq='D')
         pi = dti.to_period('D')
-        pi = tm.box_expected(pi, box)
+        pi = tm.box_expected(pi, box_with_array)
         with pytest.raises(TypeError):
             op(pi, other)
 
     @pytest.mark.parametrize('other', [pd.Timestamp.now(),
                                        pd.Timestamp.now().to_pydatetime(),
                                        pd.Timestamp.now().to_datetime64()])
-    def test_pi_add_sub_datetime(self, other):
+    def test_parr_add_sub_datetime_scalar(self, other, box_with_array):
         # GH#23215
         rng = pd.period_range('1/1/2000', freq='D', periods=3)
+        rng = tm.box_expected(rng, box_with_array)
 
         with pytest.raises(TypeError):
             rng + other
@@ -382,11 +403,13 @@ class TestPeriodIndexArithmetic(object):
     # -----------------------------------------------------------------
     # __add__/__sub__ with ndarray[datetime64] and ndarray[timedelta64]
 
-    def test_pi_add_sub_dt64_array_raises(self):
+    def test_parr_add_sub_dt64_array_raises(self, box_with_array):
         rng = pd.period_range('1/1/2000', freq='D', periods=3)
         dti = pd.date_range('2016-01-01', periods=3)
         dtarr = dti.values
 
+        rng = tm.box_expected(rng, box_with_array)
+
         with pytest.raises(TypeError):
             rng + dtarr
         with pytest.raises(TypeError):
@@ -402,12 +425,12 @@ class TestPeriodIndexArithmetic(object):
         tdi = pd.TimedeltaIndex(['-1 Day', '-1 Day', '-1 Day'])
         tdarr = tdi.values
 
-        with pytest.raises(period.IncompatibleFrequency):
+        with pytest.raises(IncompatibleFrequency):
             rng + tdarr
-        with pytest.raises(period.IncompatibleFrequency):
+        with pytest.raises(IncompatibleFrequency):
             tdarr + rng
 
-        with pytest.raises(period.IncompatibleFrequency):
+        with pytest.raises(IncompatibleFrequency):
             rng - tdarr
         with pytest.raises(TypeError):
             tdarr - rng
@@ -465,10 +488,10 @@ class TestPeriodIndexArithmetic(object):
                                pd.offsets.Minute(n=-2)])
         # addition/subtraction ops with incompatible offsets should issue
         # a PerformanceWarning and _then_ raise a TypeError.
-        with pytest.raises(period.IncompatibleFrequency):
+        with pytest.raises(IncompatibleFrequency):
             with tm.assert_produces_warning(PerformanceWarning):
                 pi + unanchored
-        with pytest.raises(period.IncompatibleFrequency):
+        with pytest.raises(IncompatibleFrequency):
             with tm.assert_produces_warning(PerformanceWarning):
                 unanchored + pi
 
@@ -489,10 +512,10 @@ class TestPeriodIndexArithmetic(object):
 
         # addition/subtraction ops with anchored offsets should issue
         # a PerformanceWarning and _then_ raise a TypeError.
-        with pytest.raises(period.IncompatibleFrequency):
+        with pytest.raises(IncompatibleFrequency):
             with tm.assert_produces_warning(PerformanceWarning):
                 pi - anchored
-        with pytest.raises(period.IncompatibleFrequency):
+        with pytest.raises(IncompatibleFrequency):
             with tm.assert_produces_warning(PerformanceWarning):
                 anchored - pi
 
@@ -572,10 +595,10 @@ class TestPeriodIndexArithmetic(object):
         result = per.freq + pi
         tm.assert_equal(result, expected)
 
-    def test_pi_add_offset_n_gt1_not_divisible(self, box_with_period):
+    def test_pi_add_offset_n_gt1_not_divisible(self, box_with_array):
         # GH#23215
         # PeriodIndex with freq.n > 1 add offset with offset.n % freq.n != 0
-        box = box_with_period
+        box = box_with_array
 
         pi = pd.PeriodIndex(['2016-01'], freq='2M')
         expected = pd.PeriodIndex(['2016-04'], freq='2M')
@@ -703,13 +726,13 @@ class TestPeriodIndexArithmetic(object):
         other = not_daily
         rng = pd.period_range('2014-05-01', '2014-05-15', freq='D')
         msg = 'Input has different freq(=.+)? from Period.*?\\(freq=D\\)'
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             rng + other
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             rng += other
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             rng - other
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             rng -= other
 
     def test_pi_add_iadd_timedeltalike_hourly(self, two_hours):
@@ -729,10 +752,10 @@ class TestPeriodIndexArithmetic(object):
         rng = pd.period_range('2014-01-01 10:00', '2014-01-05 10:00', freq='H')
         msg = 'Input has different freq(=.+)? from Period.*?\\(freq=H\\)'
 
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             rng + other
 
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             rng += other
 
     def test_pi_sub_isub_timedeltalike_hourly(self, two_hours):
@@ -763,13 +786,13 @@ class TestPeriodIndexArithmetic(object):
         rng = pd.period_range('2014', '2024', freq='A')
         msg = ('Input has different freq(=.+)? '
                'from Period.*?\\(freq=A-DEC\\)')
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             rng + other
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             rng += other
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             rng - other
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             rng -= other
 
     def test_pi_add_iadd_timedeltalike_M(self):
@@ -787,13 +810,13 @@ class TestPeriodIndexArithmetic(object):
         other = mismatched_freq
         rng = pd.period_range('2014-01', '2016-12', freq='M')
         msg = 'Input has different freq(=.+)? from Period.*?\\(freq=M\\)'
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             rng + other
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             rng += other
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             rng - other
-        with pytest.raises(period.IncompatibleFrequency, match=msg):
+        with pytest.raises(IncompatibleFrequency, match=msg):
             rng -= other
 
     def test_parr_add_sub_td64_nat(self, box_transpose_fail):
@@ -819,7 +842,7 @@ class TestPeriodIndexArithmetic(object):
 
 class TestPeriodSeriesArithmetic(object):
     def test_ops_series_timedelta(self):
-        # GH 13043
+        # GH#13043
         ser = pd.Series([pd.Period('2015-01-01', freq='D'),
                          pd.Period('2015-01-02', freq='D')], name='xxx')
         assert ser.dtype == 'Period[D]'
@@ -840,7 +863,7 @@ class TestPeriodSeriesArithmetic(object):
         tm.assert_series_equal(result, expected)
 
     def test_ops_series_period(self):
-        # GH 13043
+        # GH#13043
         ser = pd.Series([pd.Period('2015-01-01', freq='D'),
                          pd.Period('2015-01-02', freq='D')], name='xxx')
         assert ser.dtype == "Period[D]"
@@ -898,10 +921,10 @@ class TestPeriodIndexSeriesMethods(object):
         tm.assert_index_equal(result, exp)
 
     @pytest.mark.parametrize('ng', ["str", 1.5])
-    def test_pi_ops_errors(self, ng, box_with_period):
+    def test_parr_ops_errors(self, ng, box_with_array):
         idx = PeriodIndex(['2011-01', '2011-02', '2011-03', '2011-04'],
                           freq='M', name='idx')
-        obj = tm.box_expected(idx, box_with_period)
+        obj = tm.box_expected(idx, box_with_array)
 
         msg = r"unsupported operand type\(s\)"
         with pytest.raises(TypeError, match=msg):
@@ -1006,17 +1029,17 @@ class TestPeriodIndexSeriesMethods(object):
         # from Period
         msg = r"Input has different freq from Period.*?\(freq=D\)"
         for obj in [idx, ser]:
-            with pytest.raises(period.IncompatibleFrequency, match=msg):
+            with pytest.raises(IncompatibleFrequency, match=msg):
                 obj + pd.offsets.Hour(2)
 
-            with pytest.raises(period.IncompatibleFrequency, match=msg):
+            with pytest.raises(IncompatibleFrequency, match=msg):
                 pd.offsets.Hour(2) + obj
 
-            with pytest.raises(period.IncompatibleFrequency, match=msg):
+            with pytest.raises(IncompatibleFrequency, match=msg):
                 obj - pd.offsets.Hour(2)
 
     def test_pi_sub_period(self):
-        # GH 13071
+        # GH#13071
         idx = PeriodIndex(['2011-01', '2011-02', '2011-03', '2011-04'],
                           freq='M', name='idx')
 
@@ -1040,7 +1063,7 @@ class TestPeriodIndexSeriesMethods(object):
         tm.assert_index_equal(pd.Period('NaT', freq='M') - idx, exp)
 
     def test_pi_sub_pdnat(self):
-        # GH 13071
+        # GH#13071
         idx = PeriodIndex(['2011-01', '2011-02', 'NaT', '2011-04'],
                           freq='M', name='idx')
         exp = pd.TimedeltaIndex([pd.NaT] * 4, name='idx')
@@ -1048,7 +1071,7 @@ class TestPeriodIndexSeriesMethods(object):
         tm.assert_index_equal(idx - pd.NaT, exp)
 
     def test_pi_sub_period_nat(self):
-        # GH 13071
+        # GH#13071
         idx = PeriodIndex(['2011-01', 'NaT', '2011-03', '2011-04'],
                           freq='M', name='idx')
 
diff --git a/pandas/tests/arithmetic/test_timedelta64.py b/pandas/tests/arithmetic/test_timedelta64.py
index 58c8b3b07..4d12a86e2 100644
--- a/pandas/tests/arithmetic/test_timedelta64.py
+++ b/pandas/tests/arithmetic/test_timedelta64.py
@@ -25,7 +25,7 @@ class TestTimedelta64ArrayComparisons(object):
     # TODO: All of these need to be parametrized over box
 
     def test_compare_timedelta_series(self):
-        # regresssion test for GH5963
+        # regresssion test for GH#5963
         s = pd.Series([timedelta(days=1), timedelta(days=2)])
         actual = s > timedelta(days=1)
         expected = pd.Series([False, True])
@@ -40,9 +40,11 @@ class TestTimedelta64ArrayComparisons(object):
                 left > right
 
             with pytest.raises(TypeError):
+                # FIXME: Shouldn't this return all-False?
                 left == right
 
             with pytest.raises(TypeError):
+                # FIXME: Shouldn't this return all-True?
                 left != right
 
     @pytest.mark.parametrize('dtype', [None, object])
diff --git a/pandas/tests/indexes/test_numeric.py b/pandas/tests/indexes/test_numeric.py
index c125db16b..273e1d6ac 100644
--- a/pandas/tests/indexes/test_numeric.py
+++ b/pandas/tests/indexes/test_numeric.py
@@ -49,12 +49,6 @@ class Numeric(Base):
         result = a - fidx
         tm.assert_index_equal(result, expected)
 
-    def test_ufunc_compat(self):
-        idx = self._holder(np.arange(5, dtype='int64'))
-        result = np.sin(idx)
-        expected = Float64Index(np.sin(np.arange(5, dtype='int64')))
-        tm.assert_index_equal(result, expected)
-
     def test_index_groupby(self):
         int_idx = Index(range(6))
         float_idx = Index(np.arange(0, 0.6, 0.1))
@@ -488,11 +482,10 @@ class NumericInt(Numeric):
         exp_ridx = np.array([2, 3, 2, 3, 0, 1, 0, 1], dtype=np.intp)
         tm.assert_numpy_array_equal(ridx, exp_ridx)
 
-    def test_join_self(self):
-        kinds = 'outer', 'inner', 'left', 'right'
-        for kind in kinds:
-            joined = self.index.join(self.index, how=kind)
-            assert self.index is joined
+    @pytest.mark.parametrize('kind', ['outer', 'inner', 'left', 'right'])
+    def test_join_self(self, kind):
+        joined = self.index.join(self.index, how=kind)
+        assert self.index is joined
 
     def test_union_noncomparable(self):
         from datetime import datetime, timedelta

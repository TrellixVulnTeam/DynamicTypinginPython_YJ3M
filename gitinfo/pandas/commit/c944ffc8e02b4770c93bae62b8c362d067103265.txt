commit c944ffc8e02b4770c93bae62b8c362d067103265
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Jun 8 16:48:01 2011 -0400

    whack-a-mole with the test suite. we're getting there

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index dc3b1789e..5b03ab127 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1344,21 +1344,29 @@ class DataFrame(PandasGeneric):
     @property
     def T(self):
         """
-        Returns a DataFrame with the rows/columns switched.
-        """
-        # Need to do some 'type inference' to avoid casting
-        # float to string in weird cases
-        dtypes = list(set([x.dtype for x in self._series.values()]))
-        if len(dtypes) > 1:
-            theDtype = np.object_
-        else:
-            theDtype = dtypes[0]
-
-        valuesT = np.array([self[col] for col in self.columns],
-                           dtype=theDtype).T
-
-        return DataFrame(data=dict(zip(self.index, valuesT)),
-                         index=self.columns, columns=self.index)
+        Returns a DataMatrix with the rows/columns switched.
+        """
+        return self._constructor(data=self.values.T, index=self.columns,
+                                 columns=self.index)
+
+    # @property
+    # def T(self):
+    #     """
+    #     Returns a DataFrame with the rows/columns switched.
+    #     """
+    #     # Need to do some 'type inference' to avoid casting
+    #     # float to string in weird cases
+    #     dtypes = list(set([x.dtype for x in self._series.values()]))
+    #     if len(dtypes) > 1:
+    #         theDtype = np.object_
+    #     else:
+    #         theDtype = dtypes[0]
+
+    #     valuesT = np.array([self[col] for col in self.columns],
+    #                        dtype=theDtype).T
+
+    #     return DataFrame(data=dict(zip(self.index, valuesT)),
+    #                      index=self.columns, columns=self.index)
 
     def diff(self, periods=1):
         return self - self.shift(periods)
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 72ee9c7c0..c03daa42b 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -6,8 +6,12 @@ import numpy as np
 from pandas.core.index import Index, NULL_INDEX
 from pandas.core.common import _ensure_index
 from pandas.core.series import Series
+from pandas.util.decorators import cache_readonly
 import pandas.core.common as common
 
+def make_block(values, columns):
+    pass
+
 class Block(object):
     """
     Canonical unit of homogeneous dtype contained in DataMatrix
@@ -53,25 +57,25 @@ class Block(object):
         if needs_masking:
             if issubclass(new_values.dtype.type, np.int_):
                 new_values = new_values.astype(float)
-            elif issubclass(new_values_.dtype.type, np.bool_):
+            elif issubclass(new_values.dtype.type, np.bool_):
                 new_values = new_values.astype(object)
             common.null_out_axis(new_values, notmask, 0)
         return Block(new_values, self.columns)
 
     def reindex_columns(self, new_columns):
-        indexer, mask = self.columns.get_indexer(columns)
+        indexer, mask = self.columns.get_indexer(new_columns)
         new_values = self.values.take(indexer, axis=1)
 
         notmask = -mask
         if len(mask) > 0 and notmask.any():
-            if issubclass(mat.dtype.type, np.int_):
-                mat = mat.astype(float)
-            elif issubclass(mat.dtype.type, np.bool_):
-                mat = mat.astype(object)
+            if issubclass(new_values.dtype.type, np.int_):
+                new_values = new_values.astype(float)
+            elif issubclass(new_values.dtype.type, np.bool_):
+                new_values = new_values.astype(object)
 
-            common.null_out_axis(mat, notmask, 1)
+            common.null_out_axis(new_values, notmask, 1)
 
-        return Block(new_values, columns)
+        return Block(new_values, new_columns)
 
     def insert(self, col, value, loc=None):
         """
@@ -152,9 +156,6 @@ class BoolBlock(Block):
 class ObjectBlock(Block):
     pass
 
-def make_block(values, columns):
-    pass
-
 # TODO: flexible with index=None and/or columns=None
 
 class BlockManager(object):
@@ -236,7 +237,15 @@ class BlockManager(object):
             return _interleave(self.blocks, columns)
 
     def xs(self, i, copy=True):
-        return np.concatenate([b[i] for b in blocks])
+        if len(self.blocks) > 1:
+            if not copy:
+                raise Exception('cannot get view of mixed-type DataFrame')
+            xs = np.concatenate([b.values[i] for b in self.blocks])
+        else:
+            xs = self.blocks[0].values[i]
+            if copy:
+                xs = xs.copy()
+        return xs
 
     def consolidate(self):
         """
@@ -274,6 +283,8 @@ class BlockManager(object):
                 # delete from block, create and append new block
                 self._delete_from_block(i, col)
                 self._add_new_block(col, value)
+            else:
+                block.set(col, value)
         else:
             # new block
             self._add_new_block(col, value)
@@ -331,13 +342,14 @@ class BlockManager(object):
         new_blocks = []
         for block in self.blocks:
 
-            newb = block.reindex_index(indexer, mask, needs_masking)
+            newb = block.reindex_index(indexer, notmask, needs_masking)
             new_blocks.append(newb)
 
         return BlockManager(new_blocks, new_index, self.columns)
 
     def reindex_columns(self, new_columns):
-        assert(isinstance(new_columns, Index))
+        # assert(isinstance(new_columns, Index))
+        new_columns = _ensure_index(new_columns)
         data = self
         if not data.is_consolidated():
             data = data.consolidate()
@@ -346,6 +358,24 @@ class BlockManager(object):
         # will put these in the float bucket
         extra_columns = new_columns - self.columns
 
+        new_blocks = []
+        for block in self.blocks:
+            new_cols = block.columns.intersection(new_columns)
+            if len(extra_columns) > 0 and block.dtype == np.float64:
+                new_cols = new_cols.union(extra_columns)
+
+            if len(new_cols) == 0:
+                continue
+
+            newb = block.reindex_columns(new_cols)
+            new_blocks.append(newb)
+
+        dtypes = [x.dtype for x in self.blocks]
+        if len(extra_columns) > 0 and np.float64 not in dtypes:
+            raise Exception('deal with this later')
+
+        return BlockManager(new_blocks, self.index, new_columns)
+
 def _slice_blocks(blocks, slice_obj):
     new_blocks = []
     for block in blocks:
@@ -356,9 +386,9 @@ def _slice_blocks(blocks, slice_obj):
 # TODO!
 def _needs_other_dtype(block, to_insert):
     if block.dtype == np.float64:
-        return not issubclass(mat.dtype.type, (np.integer, np.floating))
+        return not issubclass(to_insert.dtype.type, (np.integer, np.floating))
     elif block.dtype == np.object_:
-        return issubclass(mat.dtype.type, (np.integer, np.floating))
+        return issubclass(to_insert.dtype.type, (np.integer, np.floating))
     else:
         raise Exception('have not handled this case yet')
 
@@ -463,14 +493,14 @@ def _nan_manager_matching(index, columns):
     block = Block(values, columns)
     return BlockManager([block], columns)
 
-def _nan_array(index, columns):
+def _nan_array(index, columns, dtype=np.float64):
     if index is None:
         index = NULL_INDEX
     if columns is None:
         columns = NULL_INDEX
 
     values = np.empty((len(index), len(columns)), dtype=dtype)
-    values.fill(NaN)
+    values.fill(nan)
     return values
 
 import unittest
@@ -486,14 +516,16 @@ class TestBlockOperations(unittest.TestCase):
         pass
 
 if __name__ == '__main__':
-    floats = np.repeat(np.atleast_2d(np.arange(3.)), 10, axis=0)
-    objects = np.empty((10, 2), dtype=object)
+    n = 10
+    floats = np.repeat(np.atleast_2d(np.arange(3.)), n, axis=0)
+    objects = np.empty((n, 2), dtype=object)
     objects[:, 0] = 'foo'
     objects[:, 1] = 'bar'
 
     float_cols = Index(['a', 'c', 'e'])
     object_cols = Index(['b', 'd'])
     columns = Index(sorted(float_cols + object_cols))
+    index = np.arange(n)
     new_columns = Index(['a', 'c', 'e', 'b', 'd'])
 
     fblock = Block(floats, float_cols)
@@ -503,4 +535,4 @@ if __name__ == '__main__':
 
     interleaved = _interleave(blocks, columns)
 
-    manager = BlockManager(blocks, columns)
+    mgr = BlockManager(blocks, index, columns)
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index aae5978de..ea16a3a01 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -90,6 +90,13 @@ class DataMatrix(DataFrame):
 
     values = property(fget=_get_values)
 
+    def _consolidate_inplace(self):
+        self._data = self._data.consolidate()
+
+    def consolidate(self):
+        #TODO
+        raise NotImplementedError
+
     @property
     def _constructor(self):
         return DataMatrix
@@ -144,11 +151,11 @@ class DataMatrix(DataFrame):
         return DataMatrix(new_data)
 
     def _reindex_columns(self, new_columns):
-        if len(columns) == 0:
+        if len(new_columns) == 0:
             return DataMatrix(index=self.index)
 
         new_data = self._data.reindex_columns(new_columns)
-        return DataMatrix(new_data, index=new_index, columns=self.columns)
+        return DataMatrix(new_data)
 
         # indexer, mask = self.columns.get_indexer(columns)
         # mat = self.values.take(indexer, axis=1)
@@ -385,19 +392,18 @@ class DataMatrix(DataFrame):
 
         Examples
         --------
-
-            >>> df.apply(numpy.sqrt) --> DataMatrix
-            >>> df.apply(numpy.sum) --> Series
+        >>> df.apply(numpy.sqrt) --> DataMatrix
+        >>> df.apply(numpy.sum) --> Series
 
         N.B.: Do NOT use functions that might toy with the index.
         """
-        if not len(self.cols()):
+        if not len(self.columns):
             return self
 
         if isinstance(func, np.ufunc):
             results = func(self.values)
             return DataMatrix(data=results, index=self.index,
-                              columns=self.columns, objects=self.objects)
+                              columns=self.columns)
         else:
             return DataFrame.apply(self, func, axis=axis,
                                    broadcast=broadcast)
@@ -459,34 +465,7 @@ class DataMatrix(DataFrame):
         -------
         ndarray
         """
-        if columns is None:
-            values = self.values.copy()
-
-            if self.objects:
-                values = np.column_stack((values, self.objects.values))
-                order = Index(np.concatenate((self.columns,
-                                                self.objects.columns)))
-            else:
-                order = self.columns
-
-            columns = Index(self.cols())
-        else:
-            columns = _ensure_index(columns)
-            values = self.values
-            order = self.columns
-
-            if self.objects:
-                idxMap = self.objects.columns.indexMap
-                indexer = [idxMap[col] for col in columns if col in idxMap]
-
-                obj_values = self.objects.values.take(indexer, axis=1)
-
-                values = np.column_stack((values, obj_values))
-
-                order = Index(np.concatenate((order, self.objects.columns)))
-
-        # now put in the right order
-        return _reorder_columns(values, order, columns)
+        return self._data.as_matrix(columns=columns)
 
     def copy(self):
         """
@@ -614,19 +593,11 @@ class DataMatrix(DataFrame):
         if key not in self.index:
             raise Exception('No cross-section for %s' % key)
 
-        loc = self.index.indexMap[key]
-        xs = self.values[loc, :]
-
-        if copy:
-            xs = xs.copy()
-        result = Series(xs, index=self.columns)
-
-        if self.objects is not None and len(self.objects.columns) > 0:
-            if not copy:
-                raise Exception('cannot get view of mixed-type cross-section')
-            result = result.append(self.objects.xs(key))
+        self._consolidate_inplace()
 
-        return result
+        loc = self.index.get_loc(key)
+        xs = self._data.xs(loc, copy=copy)
+        return Series(xs, index=self.columns)
 
     @property
     def T(self):
diff --git a/pandas/core/tests/test_matrix.py b/pandas/core/tests/test_matrix.py
index 5fffdbcb6..4fdc5141d 100644
--- a/pandas/core/tests/test_matrix.py
+++ b/pandas/core/tests/test_matrix.py
@@ -291,8 +291,8 @@ class TestDataMatrix(test_frame.TestDataFrame):
 
 if __name__ == '__main__':
     import nose
-    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb-failure'],
-                   exit=False)
-    # nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
+    # nose.runmodule(argv=[__file__,'-vvs','-x','--pdb-failure'],
     #                exit=False)
+    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
+                   exit=False)
 

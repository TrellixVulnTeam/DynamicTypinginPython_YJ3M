commit 2b4cd9f87babb4c6b6e200f7ea8d4a3617b4edc0
Author: Joris Van den Bossche <jorisvandenbossche@gmail.com>
Date:   Wed Apr 30 11:26:57 2014 +0200

    SQL: revert deprecated tquery/uquery to 0.13 version
    
    As tquery and uquery are deprecated, it is not needed to adapt them to the new sqlalchemy interface + the adapted version changed the signature slightly so it was not fully backwards compatible.
    Therefore: put back the old code and removed new implementatation in the classes.
    Consequence: the functions are not available for the new sqlalchemy engines, but as they are deprecated this is not needed.

diff --git a/pandas/io/sql.py b/pandas/io/sql.py
index 852d393c2..f28670927 100644
--- a/pandas/io/sql.py
+++ b/pandas/io/sql.py
@@ -6,6 +6,7 @@ from __future__ import print_function, division
 from datetime import datetime, date, timedelta
 
 import warnings
+import traceback
 import itertools
 import re
 import numpy as np
@@ -102,75 +103,122 @@ def execute(sql, con, cur=None, params=None, flavor='sqlite'):
     return pandas_sql.execute(*args)
 
 
-def tquery(sql, con, cur=None, params=None, flavor='sqlite'):
+#------------------------------------------------------------------------------
+#--- Deprecated tquery and uquery
+
+def _safe_fetch(cur):
+    try:
+        result = cur.fetchall()
+        if not isinstance(result, list):
+            result = list(result)
+        return result
+    except Exception as e: # pragma: no cover
+        excName = e.__class__.__name__
+        if excName == 'OperationalError':
+            return []
+
+def tquery(sql, con=None, cur=None, retry=True):
     """
-    Returns list of tuples corresponding to each row in given sql
+    DEPRECATED. Returns list of tuples corresponding to each row in given sql
     query.
 
     If only one column selected, then plain list is returned.
 
+    To obtain the same result in the future, you can use the following:
+    
+    >>> execute(sql, con, params).fetchall()
+
     Parameters
     ----------
     sql: string
         SQL query to be executed
-    con: SQLAlchemy engine or DBAPI2 connection (legacy mode)
-        Using SQLAlchemy makes it possible to use any DB supported by that
-        library.
-        If a DBAPI2 object is given, a supported SQL flavor must also be provided
+    con: DBAPI2 connection
     cur: depreciated, cursor is obtained from connection
-    params: list or tuple, optional
-        List of parameters to pass to execute method.
-    flavor : string "sqlite", "mysql"
-        Specifies the flavor of SQL to use.
-        Ignored when using SQLAlchemy engine. Required when using DBAPI2
-        connection.
+
     Returns
     -------
     Results Iterable
+
     """
     warnings.warn(
-        "tquery is depreciated, and will be removed in future versions",
+        "tquery is depreciated, and will be removed in future versions. "
+        "You can use ``execute(...).fetchall()`` instead.",
         FutureWarning)
+    
+    cur = execute(sql, con, cur=cur)
+    result = _safe_fetch(cur)
 
-    pandas_sql = pandasSQL_builder(con, flavor=flavor)
-    args = _convert_params(sql, params)
-    return pandas_sql.tquery(*args)
+    if con is not None:
+        try:
+            cur.close()
+            con.commit()
+        except Exception as e:
+            excName = e.__class__.__name__
+            if excName == 'OperationalError': # pragma: no cover
+                print('Failed to commit, may need to restart interpreter')
+            else:
+                raise
 
+            traceback.print_exc()
+            if retry:
+                return tquery(sql, con=con, retry=False)
 
-def uquery(sql, con, cur=None, params=None, engine=None, flavor='sqlite'):
+    if result and len(result[0]) == 1:
+        # python 3 compat
+        result = list(lzip(*result)[0])
+    elif result is None: # pragma: no cover
+        result = []
+
+    return result
+
+
+def uquery(sql, con=None, cur=None, retry=True, params=None):
     """
-    Does the same thing as tquery, but instead of returning results, it
+    DEPRECATED. Does the same thing as tquery, but instead of returning results, it
     returns the number of rows affected.  Good for update queries.
 
+    To obtain the same result in the future, you can use the following:
+    
+    >>> execute(sql, con).rowcount
+
     Parameters
     ----------
     sql: string
         SQL query to be executed
-    con: SQLAlchemy engine or DBAPI2 connection (legacy mode)
-        Using SQLAlchemy makes it possible to use any DB supported by that
-        library.
-        If a DBAPI2 object is given, a supported SQL flavor must also be provided
+    con: DBAPI2 connection
     cur: depreciated, cursor is obtained from connection
     params: list or tuple, optional
         List of parameters to pass to execute method.
-    flavor : string "sqlite", "mysql"
-        Specifies the flavor of SQL to use.
-        Ignored when using SQLAlchemy engine. Required when using DBAPI2
-        connection.
+
     Returns
     -------
     Number of affected rows
+
     """
     warnings.warn(
-        "uquery is depreciated, and will be removed in future versions",
+        "uquery is depreciated, and will be removed in future versions. "
+        "You can use ``execute(...).rowcount`` instead.",
         FutureWarning)
-    pandas_sql = pandasSQL_builder(con, flavor=flavor)
-    args = _convert_params(sql, params)
-    return pandas_sql.uquery(*args)
+
+    cur = execute(sql, con, cur=cur, params=params)
+
+    result = cur.rowcount
+    try:
+        con.commit()
+    except Exception as e:
+        excName = e.__class__.__name__
+        if excName != 'OperationalError':
+            raise
+
+        traceback.print_exc()
+        if retry:
+            print('Looks like your connection failed, reconnecting...')
+            return uquery(sql, con, retry=False)
+    return result
 
 
 #------------------------------------------------------------------------------
-# Read and write to DataFrames
+#--- Read and write to DataFrames
 
 def read_sql_table(table_name, con, meta=None, index_col=None,
                    coerce_float=True, parse_dates=None, columns=None):
@@ -722,14 +770,6 @@ class PandasSQLAlchemy(PandasSQL):
         """Simple passthrough to SQLAlchemy engine"""
         return self.engine.execute(*args, **kwargs)
 
-    def tquery(self, *args, **kwargs):
-        result = self.execute(*args, **kwargs)
-        return result.fetchall()
-
-    def uquery(self, *args, **kwargs):
-        result = self.execute(*args, **kwargs)
-        return result.rowcount
-
     def read_table(self, table_name, index_col=None, coerce_float=True,
                    parse_dates=None, columns=None):
 
@@ -953,22 +993,6 @@ class PandasSQLLegacy(PandasSQL):
             ex = DatabaseError("Execution failed on sql: %s" % args[0])
             raise_with_traceback(ex)
 
-    def tquery(self, *args):
-        cur = self.execute(*args)
-        result = self._fetchall_as_list(cur)
-
-        # This makes into tuples
-        if result and len(result[0]) == 1:
-            # python 3 compat
-            result = list(lzip(*result)[0])
-        elif result is None:  # pragma: no cover
-            result = []
-        return result
-
-    def uquery(self, *args):
-        cur = self.execute(*args)
-        return cur.rowcount
-
     def read_sql(self, sql, index_col=None, coerce_float=True, params=None,
                  parse_dates=None):
         args = _convert_params(sql, params)
@@ -1020,7 +1044,7 @@ class PandasSQLLegacy(PandasSQL):
             'mysql': "SHOW TABLES LIKE '%s'" % name}
         query = flavor_map.get(self.flavor)
 
-        return len(self.tquery(query)) > 0
+        return len(self.execute(query).fetchall()) > 0
 
     def get_table(self, table_name):
         return None  # not supported in Legacy mode
diff --git a/pandas/io/tests/test_sql.py b/pandas/io/tests/test_sql.py
index bcca8c181..683c7b7a7 100644
--- a/pandas/io/tests/test_sql.py
+++ b/pandas/io/tests/test_sql.py
@@ -296,11 +296,6 @@ class PandasSQLTest(unittest.TestCase):
         row = iris_results.fetchone()
         tm.equalContents(row, [5.1, 3.5, 1.4, 0.2, 'Iris-setosa'])
 
-    def _tquery(self):
-        iris_results = self.pandasSQL.tquery("SELECT * FROM iris")
-        row = iris_results[0]
-        tm.equalContents(row, [5.1, 3.5, 1.4, 0.2, 'Iris-setosa'])
-
 
 #------------------------------------------------------------------------------
 #--- Testing the public API
@@ -433,19 +428,6 @@ class _TestSQLApi(PandasSQLTest):
         row = iris_results.fetchone()
         tm.equalContents(row, [5.1, 3.5, 1.4, 0.2, 'Iris-setosa'])
 
-    def test_tquery(self):
-        with tm.assert_produces_warning(FutureWarning):
-            iris_results = sql.tquery(
-                "SELECT * FROM iris", con=self.conn, flavor='sqlite')
-        row = iris_results[0]
-        tm.equalContents(row, [5.1, 3.5, 1.4, 0.2, 'Iris-setosa'])
-
-    def test_uquery(self):
-        with tm.assert_produces_warning(FutureWarning):
-            rows = sql.uquery(
-                "SELECT * FROM iris LIMIT 1", con=self.conn, flavor='sqlite')
-        self.assertEqual(rows, -1)
-
     def test_date_parsing(self):
         # Test date parsing in read_sq
         # No Parsing
@@ -694,6 +676,17 @@ class TestSQLLegacyApi(_TestSQLApi):
         create_sql = sql.get_schema(self.test_frame1, 'test', 'sqlite')
         self.assert_('CREATE' in create_sql)
 
+    def test_tquery(self):
+        with tm.assert_produces_warning(FutureWarning):
+            iris_results = sql.tquery("SELECT * FROM iris", con=self.conn)
+        row = iris_results[0]
+        tm.equalContents(row, [5.1, 3.5, 1.4, 0.2, 'Iris-setosa'])
+
+    def test_uquery(self):
+        with tm.assert_produces_warning(FutureWarning):
+            rows = sql.uquery("SELECT * FROM iris LIMIT 1", con=self.conn)
+        self.assertEqual(rows, -1)
+
 
 #------------------------------------------------------------------------------
 #--- Database flavor specific tests
@@ -1063,9 +1056,6 @@ class TestSQLiteLegacy(PandasSQLTest):
     def test_execute_sql(self):
         self._execute_sql()
 
-    def test_tquery(self):
-        self._tquery()
-
 
 class TestMySQLLegacy(TestSQLiteLegacy):
     """

commit 2227c831610bfcd75377e0e41f786030cef9c4a5
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Feb 25 13:49:52 2020 -0800

    REF/TST: method-specific files for Series timeseries methods (#32226)

diff --git a/pandas/tests/series/methods/test_asfreq.py b/pandas/tests/series/methods/test_asfreq.py
index 05ec56cf0..d94b60384 100644
--- a/pandas/tests/series/methods/test_asfreq.py
+++ b/pandas/tests/series/methods/test_asfreq.py
@@ -1,8 +1,13 @@
+from datetime import datetime
+
 import numpy as np
+import pytest
 
-from pandas import DataFrame, Series, period_range
+from pandas import DataFrame, DatetimeIndex, Series, date_range, period_range
 import pandas._testing as tm
 
+from pandas.tseries.offsets import BDay, BMonthEnd
+
 
 class TestAsFreq:
     # TODO: de-duplicate/parametrize or move DataFrame test
@@ -21,3 +26,79 @@ class TestAsFreq:
         result = ts.asfreq("D", how="start")
         assert len(result) == len(ts)
         tm.assert_index_equal(result.index, index.asfreq("D", how="start"))
+
+    @pytest.mark.parametrize("tz", ["US/Eastern", "dateutil/US/Eastern"])
+    def test_tz_aware_asfreq(self, tz):
+        dr = date_range("2011-12-01", "2012-07-20", freq="D", tz=tz)
+
+        ser = Series(np.random.randn(len(dr)), index=dr)
+
+        # it works!
+        ser.asfreq("T")
+
+    def test_asfreq(self):
+        ts = Series(
+            [0.0, 1.0, 2.0],
+            index=[
+                datetime(2009, 10, 30),
+                datetime(2009, 11, 30),
+                datetime(2009, 12, 31),
+            ],
+        )
+
+        daily_ts = ts.asfreq("B")
+        monthly_ts = daily_ts.asfreq("BM")
+        tm.assert_series_equal(monthly_ts, ts)
+
+        daily_ts = ts.asfreq("B", method="pad")
+        monthly_ts = daily_ts.asfreq("BM")
+        tm.assert_series_equal(monthly_ts, ts)
+
+        daily_ts = ts.asfreq(BDay())
+        monthly_ts = daily_ts.asfreq(BMonthEnd())
+        tm.assert_series_equal(monthly_ts, ts)
+
+        result = ts[:0].asfreq("M")
+        assert len(result) == 0
+        assert result is not ts
+
+        daily_ts = ts.asfreq("D", fill_value=-1)
+        result = daily_ts.value_counts().sort_index()
+        expected = Series([60, 1, 1, 1], index=[-1.0, 2.0, 1.0, 0.0]).sort_index()
+        tm.assert_series_equal(result, expected)
+
+    def test_asfreq_datetimeindex_empty_series(self):
+        # GH#14320
+        index = DatetimeIndex(["2016-09-29 11:00"])
+        expected = Series(index=index, dtype=object).asfreq("H")
+        result = Series([3], index=index.copy()).asfreq("H")
+        tm.assert_index_equal(expected.index, result.index)
+
+    def test_asfreq_keep_index_name(self):
+        # GH#9854
+        index_name = "bar"
+        index = date_range("20130101", periods=20, name=index_name)
+        df = DataFrame(list(range(20)), columns=["foo"], index=index)
+
+        assert index_name == df.index.name
+        assert index_name == df.asfreq("10D").index.name
+
+    def test_asfreq_normalize(self):
+        rng = date_range("1/1/2000 09:30", periods=20)
+        norm = date_range("1/1/2000", periods=20)
+        vals = np.random.randn(20)
+        ts = Series(vals, index=rng)
+
+        result = ts.asfreq("D", normalize=True)
+        norm = date_range("1/1/2000", periods=20)
+        expected = Series(vals, index=norm)
+
+        tm.assert_series_equal(result, expected)
+
+        vals = np.random.randn(20, 3)
+        ts = DataFrame(vals, index=rng)
+
+        result = ts.asfreq("D", normalize=True)
+        expected = DataFrame(vals, index=norm)
+
+        tm.assert_frame_equal(result, expected)
diff --git a/pandas/tests/series/methods/test_at_time.py b/pandas/tests/series/methods/test_at_time.py
new file mode 100644
index 000000000..d9985cf33
--- /dev/null
+++ b/pandas/tests/series/methods/test_at_time.py
@@ -0,0 +1,72 @@
+from datetime import time
+
+import numpy as np
+import pytest
+
+from pandas._libs.tslibs import timezones
+
+from pandas import DataFrame, Series, date_range
+import pandas._testing as tm
+
+
+class TestAtTime:
+    @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
+    def test_localized_at_time(self, tzstr):
+        tz = timezones.maybe_get_tz(tzstr)
+
+        rng = date_range("4/16/2012", "5/1/2012", freq="H")
+        ts = Series(np.random.randn(len(rng)), index=rng)
+
+        ts_local = ts.tz_localize(tzstr)
+
+        result = ts_local.at_time(time(10, 0))
+        expected = ts.at_time(time(10, 0)).tz_localize(tzstr)
+        tm.assert_series_equal(result, expected)
+        assert timezones.tz_compare(result.index.tz, tz)
+
+    def test_at_time(self):
+        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
+        ts = Series(np.random.randn(len(rng)), index=rng)
+        rs = ts.at_time(rng[1])
+        assert (rs.index.hour == rng[1].hour).all()
+        assert (rs.index.minute == rng[1].minute).all()
+        assert (rs.index.second == rng[1].second).all()
+
+        result = ts.at_time("9:30")
+        expected = ts.at_time(time(9, 30))
+        tm.assert_series_equal(result, expected)
+
+        df = DataFrame(np.random.randn(len(rng), 3), index=rng)
+
+        result = ts[time(9, 30)]
+        result_df = df.loc[time(9, 30)]
+        expected = ts[(rng.hour == 9) & (rng.minute == 30)]
+        exp_df = df[(rng.hour == 9) & (rng.minute == 30)]
+
+        tm.assert_series_equal(result, expected)
+        tm.assert_frame_equal(result_df, exp_df)
+
+        chunk = df.loc["1/4/2000":]
+        result = chunk.loc[time(9, 30)]
+        expected = result_df[-1:]
+        tm.assert_frame_equal(result, expected)
+
+        # midnight, everything
+        rng = date_range("1/1/2000", "1/31/2000")
+        ts = Series(np.random.randn(len(rng)), index=rng)
+
+        result = ts.at_time(time(0, 0))
+        tm.assert_series_equal(result, ts)
+
+        # time doesn't exist
+        rng = date_range("1/1/2012", freq="23Min", periods=384)
+        ts = Series(np.random.randn(len(rng)), rng)
+        rs = ts.at_time("16:00")
+        assert len(rs) == 0
+
+    def test_at_time_raises(self):
+        # GH20725
+        ser = Series("a b c".split())
+        msg = "Index must be DatetimeIndex"
+        with pytest.raises(TypeError, match=msg):
+            ser.at_time("00:00")
diff --git a/pandas/tests/series/methods/test_between.py b/pandas/tests/series/methods/test_between.py
new file mode 100644
index 000000000..350a3fe6f
--- /dev/null
+++ b/pandas/tests/series/methods/test_between.py
@@ -0,0 +1,35 @@
+import numpy as np
+
+from pandas import Series, bdate_range, date_range, period_range
+import pandas._testing as tm
+
+
+class TestBetween:
+
+    # TODO: redundant with test_between_datetime_values?
+    def test_between(self):
+        series = Series(date_range("1/1/2000", periods=10))
+        left, right = series[[2, 7]]
+
+        result = series.between(left, right)
+        expected = (series >= left) & (series <= right)
+        tm.assert_series_equal(result, expected)
+
+    def test_between_datetime_values(self):
+        ser = Series(bdate_range("1/1/2000", periods=20).astype(object))
+        ser[::2] = np.nan
+
+        result = ser[ser.between(ser[3], ser[17])]
+        expected = ser[3:18].dropna()
+        tm.assert_series_equal(result, expected)
+
+        result = ser[ser.between(ser[3], ser[17], inclusive=False)]
+        expected = ser[5:16].dropna()
+        tm.assert_series_equal(result, expected)
+
+    def test_between_period_values(self):
+        ser = Series(period_range("2000-01-01", periods=10, freq="D"))
+        left, right = ser[[2, 7]]
+        result = ser.between(left, right)
+        expected = (ser >= left) & (ser <= right)
+        tm.assert_series_equal(result, expected)
diff --git a/pandas/tests/series/methods/test_between_time.py b/pandas/tests/series/methods/test_between_time.py
new file mode 100644
index 000000000..3fa26afe7
--- /dev/null
+++ b/pandas/tests/series/methods/test_between_time.py
@@ -0,0 +1,144 @@
+from datetime import datetime, time
+from itertools import product
+
+import numpy as np
+import pytest
+
+from pandas._libs.tslibs import timezones
+import pandas.util._test_decorators as td
+
+from pandas import DataFrame, Series, date_range
+import pandas._testing as tm
+
+
+class TestBetweenTime:
+    @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
+    def test_localized_between_time(self, tzstr):
+        tz = timezones.maybe_get_tz(tzstr)
+
+        rng = date_range("4/16/2012", "5/1/2012", freq="H")
+        ts = Series(np.random.randn(len(rng)), index=rng)
+
+        ts_local = ts.tz_localize(tzstr)
+
+        t1, t2 = time(10, 0), time(11, 0)
+        result = ts_local.between_time(t1, t2)
+        expected = ts.between_time(t1, t2).tz_localize(tzstr)
+        tm.assert_series_equal(result, expected)
+        assert timezones.tz_compare(result.index.tz, tz)
+
+    def test_between_time(self):
+        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
+        ts = Series(np.random.randn(len(rng)), index=rng)
+        stime = time(0, 0)
+        etime = time(1, 0)
+
+        close_open = product([True, False], [True, False])
+        for inc_start, inc_end in close_open:
+            filtered = ts.between_time(stime, etime, inc_start, inc_end)
+            exp_len = 13 * 4 + 1
+            if not inc_start:
+                exp_len -= 5
+            if not inc_end:
+                exp_len -= 4
+
+            assert len(filtered) == exp_len
+            for rs in filtered.index:
+                t = rs.time()
+                if inc_start:
+                    assert t >= stime
+                else:
+                    assert t > stime
+
+                if inc_end:
+                    assert t <= etime
+                else:
+                    assert t < etime
+
+        result = ts.between_time("00:00", "01:00")
+        expected = ts.between_time(stime, etime)
+        tm.assert_series_equal(result, expected)
+
+        # across midnight
+        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
+        ts = Series(np.random.randn(len(rng)), index=rng)
+        stime = time(22, 0)
+        etime = time(9, 0)
+
+        close_open = product([True, False], [True, False])
+        for inc_start, inc_end in close_open:
+            filtered = ts.between_time(stime, etime, inc_start, inc_end)
+            exp_len = (12 * 11 + 1) * 4 + 1
+            if not inc_start:
+                exp_len -= 4
+            if not inc_end:
+                exp_len -= 4
+
+            assert len(filtered) == exp_len
+            for rs in filtered.index:
+                t = rs.time()
+                if inc_start:
+                    assert (t >= stime) or (t <= etime)
+                else:
+                    assert (t > stime) or (t <= etime)
+
+                if inc_end:
+                    assert (t <= etime) or (t >= stime)
+                else:
+                    assert (t < etime) or (t >= stime)
+
+    def test_between_time_raises(self):
+        # GH20725
+        ser = Series("a b c".split())
+        msg = "Index must be DatetimeIndex"
+        with pytest.raises(TypeError, match=msg):
+            ser.between_time(start_time="00:00", end_time="12:00")
+
+    def test_between_time_types(self):
+        # GH11818
+        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
+        msg = r"Cannot convert arg \[datetime\.datetime\(2010, 1, 2, 1, 0\)\] to a time"
+        with pytest.raises(ValueError, match=msg):
+            rng.indexer_between_time(datetime(2010, 1, 2, 1), datetime(2010, 1, 2, 5))
+
+        frame = DataFrame({"A": 0}, index=rng)
+        with pytest.raises(ValueError, match=msg):
+            frame.between_time(datetime(2010, 1, 2, 1), datetime(2010, 1, 2, 5))
+
+        series = Series(0, index=rng)
+        with pytest.raises(ValueError, match=msg):
+            series.between_time(datetime(2010, 1, 2, 1), datetime(2010, 1, 2, 5))
+
+    @td.skip_if_has_locale
+    def test_between_time_formats(self):
+        # GH11818
+        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
+        ts = DataFrame(np.random.randn(len(rng), 2), index=rng)
+
+        strings = [
+            ("2:00", "2:30"),
+            ("0200", "0230"),
+            ("2:00am", "2:30am"),
+            ("0200am", "0230am"),
+            ("2:00:00", "2:30:00"),
+            ("020000", "023000"),
+            ("2:00:00am", "2:30:00am"),
+            ("020000am", "023000am"),
+        ]
+        expected_length = 28
+
+        for time_string in strings:
+            assert len(ts.between_time(*time_string)) == expected_length
+
+    def test_between_time_axis(self):
+        # issue 8839
+        rng = date_range("1/1/2000", periods=100, freq="10min")
+        ts = Series(np.random.randn(len(rng)), index=rng)
+        stime, etime = ("08:00:00", "09:00:00")
+        expected_length = 7
+
+        assert len(ts.between_time(stime, etime)) == expected_length
+        assert len(ts.between_time(stime, etime, axis=0)) == expected_length
+        msg = "No axis named 1 for object type <class 'pandas.core.series.Series'>"
+        with pytest.raises(ValueError, match=msg):
+            ts.between_time(stime, etime, axis=1)
diff --git a/pandas/tests/series/methods/test_truncate.py b/pandas/tests/series/methods/test_truncate.py
index d4e2890ed..c97369b34 100644
--- a/pandas/tests/series/methods/test_truncate.py
+++ b/pandas/tests/series/methods/test_truncate.py
@@ -1,7 +1,10 @@
+from datetime import datetime
+
 import numpy as np
 import pytest
 
 import pandas as pd
+from pandas import Series, date_range
 import pandas._testing as tm
 
 from pandas.tseries.offsets import BDay
@@ -76,3 +79,33 @@ class TestTruncate:
 
         with pytest.raises(ValueError, match=msg):
             ts.sort_values(ascending=False).truncate(before="2011-11", after="2011-12")
+
+    def test_truncate_datetimeindex_tz(self):
+        # GH 9243
+        idx = date_range("4/1/2005", "4/30/2005", freq="D", tz="US/Pacific")
+        s = Series(range(len(idx)), index=idx)
+        result = s.truncate(datetime(2005, 4, 2), datetime(2005, 4, 4))
+        expected = Series([1, 2, 3], index=idx[1:4])
+        tm.assert_series_equal(result, expected)
+
+    def test_truncate_periodindex(self):
+        # GH 17717
+        idx1 = pd.PeriodIndex(
+            [pd.Period("2017-09-02"), pd.Period("2017-09-02"), pd.Period("2017-09-03")]
+        )
+        series1 = pd.Series([1, 2, 3], index=idx1)
+        result1 = series1.truncate(after="2017-09-02")
+
+        expected_idx1 = pd.PeriodIndex(
+            [pd.Period("2017-09-02"), pd.Period("2017-09-02")]
+        )
+        tm.assert_series_equal(result1, pd.Series([1, 2], index=expected_idx1))
+
+        idx2 = pd.PeriodIndex(
+            [pd.Period("2017-09-03"), pd.Period("2017-09-02"), pd.Period("2017-09-03")]
+        )
+        series2 = pd.Series([1, 2, 3], index=idx2)
+        result2 = series2.sort_index().truncate(after="2017-09-02")
+
+        expected_idx2 = pd.PeriodIndex([pd.Period("2017-09-02")])
+        tm.assert_series_equal(result2, pd.Series([2], index=expected_idx2))
diff --git a/pandas/tests/series/methods/test_tz_convert.py b/pandas/tests/series/methods/test_tz_convert.py
new file mode 100644
index 000000000..ce348d532
--- /dev/null
+++ b/pandas/tests/series/methods/test_tz_convert.py
@@ -0,0 +1,29 @@
+import numpy as np
+import pytest
+
+from pandas import DatetimeIndex, Series, date_range
+import pandas._testing as tm
+
+
+class TestTZConvert:
+    def test_series_tz_convert(self):
+        rng = date_range("1/1/2011", periods=200, freq="D", tz="US/Eastern")
+        ts = Series(1, index=rng)
+
+        result = ts.tz_convert("Europe/Berlin")
+        assert result.index.tz.zone == "Europe/Berlin"
+
+        # can't convert tz-naive
+        rng = date_range("1/1/2011", periods=200, freq="D")
+        ts = Series(1, index=rng)
+
+        with pytest.raises(TypeError, match="Cannot convert tz-naive"):
+            ts.tz_convert("US/Eastern")
+
+    def test_series_tz_convert_to_utc(self):
+        base = DatetimeIndex(["2011-01-01", "2011-01-02", "2011-01-03"], tz="UTC")
+        idx1 = base.tz_convert("Asia/Tokyo")[:2]
+        idx2 = base.tz_convert("US/Eastern")[1:]
+
+        res = Series([1, 2], index=idx1) + Series([1, 1], index=idx2)
+        tm.assert_series_equal(res, Series([np.nan, 3, np.nan], index=base))
diff --git a/pandas/tests/series/methods/test_tz_localize.py b/pandas/tests/series/methods/test_tz_localize.py
new file mode 100644
index 000000000..44c55edf7
--- /dev/null
+++ b/pandas/tests/series/methods/test_tz_localize.py
@@ -0,0 +1,88 @@
+import pytest
+import pytz
+
+from pandas._libs.tslibs import timezones
+
+from pandas import DatetimeIndex, NaT, Series, Timestamp, date_range
+import pandas._testing as tm
+
+
+class TestTZLocalize:
+    def test_series_tz_localize(self):
+
+        rng = date_range("1/1/2011", periods=100, freq="H")
+        ts = Series(1, index=rng)
+
+        result = ts.tz_localize("utc")
+        assert result.index.tz.zone == "UTC"
+
+        # Can't localize if already tz-aware
+        rng = date_range("1/1/2011", periods=100, freq="H", tz="utc")
+        ts = Series(1, index=rng)
+
+        with pytest.raises(TypeError, match="Already tz-aware"):
+            ts.tz_localize("US/Eastern")
+
+    def test_series_tz_localize_ambiguous_bool(self):
+        # make sure that we are correctly accepting bool values as ambiguous
+
+        # GH#14402
+        ts = Timestamp("2015-11-01 01:00:03")
+        expected0 = Timestamp("2015-11-01 01:00:03-0500", tz="US/Central")
+        expected1 = Timestamp("2015-11-01 01:00:03-0600", tz="US/Central")
+
+        ser = Series([ts])
+        expected0 = Series([expected0])
+        expected1 = Series([expected1])
+
+        with pytest.raises(pytz.AmbiguousTimeError):
+            ser.dt.tz_localize("US/Central")
+
+        result = ser.dt.tz_localize("US/Central", ambiguous=True)
+        tm.assert_series_equal(result, expected0)
+
+        result = ser.dt.tz_localize("US/Central", ambiguous=[True])
+        tm.assert_series_equal(result, expected0)
+
+        result = ser.dt.tz_localize("US/Central", ambiguous=False)
+        tm.assert_series_equal(result, expected1)
+
+        result = ser.dt.tz_localize("US/Central", ambiguous=[False])
+        tm.assert_series_equal(result, expected1)
+
+    @pytest.mark.parametrize("tz", ["Europe/Warsaw", "dateutil/Europe/Warsaw"])
+    @pytest.mark.parametrize(
+        "method, exp",
+        [
+            ["shift_forward", "2015-03-29 03:00:00"],
+            ["NaT", NaT],
+            ["raise", None],
+            ["foo", "invalid"],
+        ],
+    )
+    def test_series_tz_localize_nonexistent(self, tz, method, exp):
+        # GH 8917
+        n = 60
+        dti = date_range(start="2015-03-29 02:00:00", periods=n, freq="min")
+        s = Series(1, dti)
+        if method == "raise":
+            with pytest.raises(pytz.NonExistentTimeError):
+                s.tz_localize(tz, nonexistent=method)
+        elif exp == "invalid":
+            with pytest.raises(ValueError):
+                dti.tz_localize(tz, nonexistent=method)
+        else:
+            result = s.tz_localize(tz, nonexistent=method)
+            expected = Series(1, index=DatetimeIndex([exp] * n, tz=tz))
+            tm.assert_series_equal(result, expected)
+
+    @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
+    def test_series_tz_localize_empty(self, tzstr):
+        # GH#2248
+        ser = Series(dtype=object)
+
+        ser2 = ser.tz_localize("utc")
+        assert ser2.index.tz == pytz.utc
+
+        ser2 = ser.tz_localize(tzstr)
+        timezones.tz_compare(ser2.index.tz, timezones.maybe_get_tz(tzstr))
diff --git a/pandas/tests/series/test_datetime_values.py b/pandas/tests/series/test_datetime_values.py
index b8be4ea13..59ae0cd63 100644
--- a/pandas/tests/series/test_datetime_values.py
+++ b/pandas/tests/series/test_datetime_values.py
@@ -19,7 +19,6 @@ from pandas import (
     PeriodIndex,
     Series,
     TimedeltaIndex,
-    bdate_range,
     date_range,
     period_range,
     timedelta_range,
@@ -622,18 +621,6 @@ class TestSeriesDatetimeValues:
         result = s.dt.date
         assert result[0] == result[2]
 
-    def test_between(self):
-        s = Series(bdate_range("1/1/2000", periods=20).astype(object))
-        s[::2] = np.nan
-
-        result = s[s.between(s[3], s[17])]
-        expected = s[3:18].dropna()
-        tm.assert_series_equal(result, expected)
-
-        result = s[s.between(s[3], s[17], inclusive=False)]
-        expected = s[5:16].dropna()
-        tm.assert_series_equal(result, expected)
-
     def test_date_tz(self):
         # GH11757
         rng = pd.DatetimeIndex(
diff --git a/pandas/tests/series/test_period.py b/pandas/tests/series/test_period.py
index 03fee3895..f41245c28 100644
--- a/pandas/tests/series/test_period.py
+++ b/pandas/tests/series/test_period.py
@@ -52,12 +52,6 @@ class TestSeriesPeriod:
         s = Series([pd.Period("2011-01", freq="M"), pd.Period("NaT", freq="M")])
         tm.assert_series_equal(s.dropna(), Series([pd.Period("2011-01", freq="M")]))
 
-    def test_between(self):
-        left, right = self.series[[2, 7]]
-        result = self.series.between(left, right)
-        expected = (self.series >= left) & (self.series <= right)
-        tm.assert_series_equal(result, expected)
-
     # ---------------------------------------------------------------------
     # NaT support
 
@@ -110,28 +104,6 @@ class TestSeriesPeriod:
 
         ts.align(ts[::2], join=join_type)
 
-    def test_truncate(self):
-        # GH 17717
-        idx1 = pd.PeriodIndex(
-            [pd.Period("2017-09-02"), pd.Period("2017-09-02"), pd.Period("2017-09-03")]
-        )
-        series1 = pd.Series([1, 2, 3], index=idx1)
-        result1 = series1.truncate(after="2017-09-02")
-
-        expected_idx1 = pd.PeriodIndex(
-            [pd.Period("2017-09-02"), pd.Period("2017-09-02")]
-        )
-        tm.assert_series_equal(result1, pd.Series([1, 2], index=expected_idx1))
-
-        idx2 = pd.PeriodIndex(
-            [pd.Period("2017-09-03"), pd.Period("2017-09-02"), pd.Period("2017-09-03")]
-        )
-        series2 = pd.Series([1, 2, 3], index=idx2)
-        result2 = series2.sort_index().truncate(after="2017-09-02")
-
-        expected_idx2 = pd.PeriodIndex([pd.Period("2017-09-02")])
-        tm.assert_series_equal(result2, pd.Series([2], index=expected_idx2))
-
     @pytest.mark.parametrize(
         "input_vals",
         [
diff --git a/pandas/tests/series/test_timeseries.py b/pandas/tests/series/test_timeseries.py
index 459377fb1..8f06ea69f 100644
--- a/pandas/tests/series/test_timeseries.py
+++ b/pandas/tests/series/test_timeseries.py
@@ -1,13 +1,11 @@
-from datetime import datetime, time, timedelta
+from datetime import datetime, timedelta
 from io import StringIO
-from itertools import product
 
 import numpy as np
 import pytest
 
 from pandas._libs.tslib import iNaT
 from pandas._libs.tslibs.np_datetime import OutOfBoundsDatetime
-import pandas.util._test_decorators as td
 
 import pandas as pd
 from pandas import (
@@ -23,8 +21,6 @@ from pandas import (
 )
 import pandas._testing as tm
 
-from pandas.tseries.offsets import BDay, BMonthEnd
-
 
 def _simple_ts(start, end, freq="D"):
     rng = date_range(start, end, freq=freq)
@@ -38,44 +34,6 @@ def assert_range_equal(left, right):
 
 
 class TestTimeSeries:
-    def test_asfreq(self):
-        ts = Series(
-            [0.0, 1.0, 2.0],
-            index=[
-                datetime(2009, 10, 30),
-                datetime(2009, 11, 30),
-                datetime(2009, 12, 31),
-            ],
-        )
-
-        daily_ts = ts.asfreq("B")
-        monthly_ts = daily_ts.asfreq("BM")
-        tm.assert_series_equal(monthly_ts, ts)
-
-        daily_ts = ts.asfreq("B", method="pad")
-        monthly_ts = daily_ts.asfreq("BM")
-        tm.assert_series_equal(monthly_ts, ts)
-
-        daily_ts = ts.asfreq(BDay())
-        monthly_ts = daily_ts.asfreq(BMonthEnd())
-        tm.assert_series_equal(monthly_ts, ts)
-
-        result = ts[:0].asfreq("M")
-        assert len(result) == 0
-        assert result is not ts
-
-        daily_ts = ts.asfreq("D", fill_value=-1)
-        result = daily_ts.value_counts().sort_index()
-        expected = Series([60, 1, 1, 1], index=[-1.0, 2.0, 1.0, 0.0]).sort_index()
-        tm.assert_series_equal(result, expected)
-
-    def test_asfreq_datetimeindex_empty_series(self):
-        # GH 14320
-        index = pd.DatetimeIndex(["2016-09-29 11:00"])
-        expected = Series(index=index, dtype=object).asfreq("H")
-        result = Series([3], index=index.copy()).asfreq("H")
-        tm.assert_index_equal(expected.index, result.index)
-
     def test_autocorr(self, datetime_series):
         # Just run the function
         corr1 = datetime_series.autocorr()
@@ -268,15 +226,6 @@ class TestTimeSeries:
         )
         assert result == expected
 
-    def test_asfreq_keep_index_name(self):
-        # GH #9854
-        index_name = "bar"
-        index = pd.date_range("20130101", periods=20, name=index_name)
-        df = pd.DataFrame(list(range(20)), columns=["foo"], index=index)
-
-        assert index_name == df.index.name
-        assert index_name == df.asfreq("10D").index.name
-
     def test_promote_datetime_date(self):
         rng = date_range("1/1/2000", periods=20)
         ts = Series(np.random.randn(20), index=rng)
@@ -300,26 +249,6 @@ class TestTimeSeries:
         expected = rng.get_indexer(ts_slice.index)
         tm.assert_numpy_array_equal(result, expected)
 
-    def test_asfreq_normalize(self):
-        rng = date_range("1/1/2000 09:30", periods=20)
-        norm = date_range("1/1/2000", periods=20)
-        vals = np.random.randn(20)
-        ts = Series(vals, index=rng)
-
-        result = ts.asfreq("D", normalize=True)
-        norm = date_range("1/1/2000", periods=20)
-        expected = Series(vals, index=norm)
-
-        tm.assert_series_equal(result, expected)
-
-        vals = np.random.randn(20, 3)
-        ts = DataFrame(vals, index=rng)
-
-        result = ts.asfreq("D", normalize=True)
-        expected = DataFrame(vals, index=norm)
-
-        tm.assert_frame_equal(result, expected)
-
     def test_first_subset(self):
         ts = _simple_ts("1/1/2000", "1/1/2010", freq="12h")
         result = ts.first("10d")
@@ -380,180 +309,6 @@ class TestTimeSeries:
         ts = Series(1, index=rng)
         repr(ts)
 
-    def test_at_time(self):
-        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
-        ts = Series(np.random.randn(len(rng)), index=rng)
-        rs = ts.at_time(rng[1])
-        assert (rs.index.hour == rng[1].hour).all()
-        assert (rs.index.minute == rng[1].minute).all()
-        assert (rs.index.second == rng[1].second).all()
-
-        result = ts.at_time("9:30")
-        expected = ts.at_time(time(9, 30))
-        tm.assert_series_equal(result, expected)
-
-        df = DataFrame(np.random.randn(len(rng), 3), index=rng)
-
-        result = ts[time(9, 30)]
-        result_df = df.loc[time(9, 30)]
-        expected = ts[(rng.hour == 9) & (rng.minute == 30)]
-        exp_df = df[(rng.hour == 9) & (rng.minute == 30)]
-
-        # FIXME: dont leave commented-out
-        # expected.index = date_range('1/1/2000', '1/4/2000')
-
-        tm.assert_series_equal(result, expected)
-        tm.assert_frame_equal(result_df, exp_df)
-
-        chunk = df.loc["1/4/2000":]
-        result = chunk.loc[time(9, 30)]
-        expected = result_df[-1:]
-        tm.assert_frame_equal(result, expected)
-
-        # midnight, everything
-        rng = date_range("1/1/2000", "1/31/2000")
-        ts = Series(np.random.randn(len(rng)), index=rng)
-
-        result = ts.at_time(time(0, 0))
-        tm.assert_series_equal(result, ts)
-
-        # time doesn't exist
-        rng = date_range("1/1/2012", freq="23Min", periods=384)
-        ts = Series(np.random.randn(len(rng)), rng)
-        rs = ts.at_time("16:00")
-        assert len(rs) == 0
-
-    def test_at_time_raises(self):
-        # GH20725
-        ser = pd.Series("a b c".split())
-        msg = "Index must be DatetimeIndex"
-        with pytest.raises(TypeError, match=msg):
-            ser.at_time("00:00")
-
-    def test_between(self):
-        series = Series(date_range("1/1/2000", periods=10))
-        left, right = series[[2, 7]]
-
-        result = series.between(left, right)
-        expected = (series >= left) & (series <= right)
-        tm.assert_series_equal(result, expected)
-
-    def test_between_time(self):
-        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
-        ts = Series(np.random.randn(len(rng)), index=rng)
-        stime = time(0, 0)
-        etime = time(1, 0)
-
-        close_open = product([True, False], [True, False])
-        for inc_start, inc_end in close_open:
-            filtered = ts.between_time(stime, etime, inc_start, inc_end)
-            exp_len = 13 * 4 + 1
-            if not inc_start:
-                exp_len -= 5
-            if not inc_end:
-                exp_len -= 4
-
-            assert len(filtered) == exp_len
-            for rs in filtered.index:
-                t = rs.time()
-                if inc_start:
-                    assert t >= stime
-                else:
-                    assert t > stime
-
-                if inc_end:
-                    assert t <= etime
-                else:
-                    assert t < etime
-
-        result = ts.between_time("00:00", "01:00")
-        expected = ts.between_time(stime, etime)
-        tm.assert_series_equal(result, expected)
-
-        # across midnight
-        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
-        ts = Series(np.random.randn(len(rng)), index=rng)
-        stime = time(22, 0)
-        etime = time(9, 0)
-
-        close_open = product([True, False], [True, False])
-        for inc_start, inc_end in close_open:
-            filtered = ts.between_time(stime, etime, inc_start, inc_end)
-            exp_len = (12 * 11 + 1) * 4 + 1
-            if not inc_start:
-                exp_len -= 4
-            if not inc_end:
-                exp_len -= 4
-
-            assert len(filtered) == exp_len
-            for rs in filtered.index:
-                t = rs.time()
-                if inc_start:
-                    assert (t >= stime) or (t <= etime)
-                else:
-                    assert (t > stime) or (t <= etime)
-
-                if inc_end:
-                    assert (t <= etime) or (t >= stime)
-                else:
-                    assert (t < etime) or (t >= stime)
-
-    def test_between_time_raises(self):
-        # GH20725
-        ser = pd.Series("a b c".split())
-        msg = "Index must be DatetimeIndex"
-        with pytest.raises(TypeError, match=msg):
-            ser.between_time(start_time="00:00", end_time="12:00")
-
-    def test_between_time_types(self):
-        # GH11818
-        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
-        msg = r"Cannot convert arg \[datetime\.datetime\(2010, 1, 2, 1, 0\)\] to a time"
-        with pytest.raises(ValueError, match=msg):
-            rng.indexer_between_time(datetime(2010, 1, 2, 1), datetime(2010, 1, 2, 5))
-
-        frame = DataFrame({"A": 0}, index=rng)
-        with pytest.raises(ValueError, match=msg):
-            frame.between_time(datetime(2010, 1, 2, 1), datetime(2010, 1, 2, 5))
-
-        series = Series(0, index=rng)
-        with pytest.raises(ValueError, match=msg):
-            series.between_time(datetime(2010, 1, 2, 1), datetime(2010, 1, 2, 5))
-
-    @td.skip_if_has_locale
-    def test_between_time_formats(self):
-        # GH11818
-        rng = date_range("1/1/2000", "1/5/2000", freq="5min")
-        ts = DataFrame(np.random.randn(len(rng), 2), index=rng)
-
-        strings = [
-            ("2:00", "2:30"),
-            ("0200", "0230"),
-            ("2:00am", "2:30am"),
-            ("0200am", "0230am"),
-            ("2:00:00", "2:30:00"),
-            ("020000", "023000"),
-            ("2:00:00am", "2:30:00am"),
-            ("020000am", "023000am"),
-        ]
-        expected_length = 28
-
-        for time_string in strings:
-            assert len(ts.between_time(*time_string)) == expected_length
-
-    def test_between_time_axis(self):
-        # issue 8839
-        rng = date_range("1/1/2000", periods=100, freq="10min")
-        ts = Series(np.random.randn(len(rng)), index=rng)
-        stime, etime = ("08:00:00", "09:00:00")
-        expected_length = 7
-
-        assert len(ts.between_time(stime, etime)) == expected_length
-        assert len(ts.between_time(stime, etime, axis=0)) == expected_length
-        msg = "No axis named 1 for object type <class 'pandas.core.series.Series'>"
-        with pytest.raises(ValueError, match=msg):
-            ts.between_time(stime, etime, axis=1)
-
     def test_to_period(self):
         from pandas.core.indexes.period import period_range
 
diff --git a/pandas/tests/series/test_timezones.py b/pandas/tests/series/test_timezones.py
index a363f927d..74363f4c7 100644
--- a/pandas/tests/series/test_timezones.py
+++ b/pandas/tests/series/test_timezones.py
@@ -10,118 +10,12 @@ import pytz
 
 from pandas._libs.tslibs import conversion, timezones
 
-from pandas import DatetimeIndex, Index, NaT, Series, Timestamp
+from pandas import DatetimeIndex, Index, Series, Timestamp
 import pandas._testing as tm
 from pandas.core.indexes.datetimes import date_range
 
 
 class TestSeriesTimezones:
-    # -----------------------------------------------------------------
-    # Series.tz_localize
-    def test_series_tz_localize(self):
-
-        rng = date_range("1/1/2011", periods=100, freq="H")
-        ts = Series(1, index=rng)
-
-        result = ts.tz_localize("utc")
-        assert result.index.tz.zone == "UTC"
-
-        # Can't localize if already tz-aware
-        rng = date_range("1/1/2011", periods=100, freq="H", tz="utc")
-        ts = Series(1, index=rng)
-
-        with pytest.raises(TypeError, match="Already tz-aware"):
-            ts.tz_localize("US/Eastern")
-
-    def test_series_tz_localize_ambiguous_bool(self):
-        # make sure that we are correctly accepting bool values as ambiguous
-
-        # GH#14402
-        ts = Timestamp("2015-11-01 01:00:03")
-        expected0 = Timestamp("2015-11-01 01:00:03-0500", tz="US/Central")
-        expected1 = Timestamp("2015-11-01 01:00:03-0600", tz="US/Central")
-
-        ser = Series([ts])
-        expected0 = Series([expected0])
-        expected1 = Series([expected1])
-
-        with pytest.raises(pytz.AmbiguousTimeError):
-            ser.dt.tz_localize("US/Central")
-
-        result = ser.dt.tz_localize("US/Central", ambiguous=True)
-        tm.assert_series_equal(result, expected0)
-
-        result = ser.dt.tz_localize("US/Central", ambiguous=[True])
-        tm.assert_series_equal(result, expected0)
-
-        result = ser.dt.tz_localize("US/Central", ambiguous=False)
-        tm.assert_series_equal(result, expected1)
-
-        result = ser.dt.tz_localize("US/Central", ambiguous=[False])
-        tm.assert_series_equal(result, expected1)
-
-    @pytest.mark.parametrize("tz", ["Europe/Warsaw", "dateutil/Europe/Warsaw"])
-    @pytest.mark.parametrize(
-        "method, exp",
-        [
-            ["shift_forward", "2015-03-29 03:00:00"],
-            ["NaT", NaT],
-            ["raise", None],
-            ["foo", "invalid"],
-        ],
-    )
-    def test_series_tz_localize_nonexistent(self, tz, method, exp):
-        # GH 8917
-        n = 60
-        dti = date_range(start="2015-03-29 02:00:00", periods=n, freq="min")
-        s = Series(1, dti)
-        if method == "raise":
-            with pytest.raises(pytz.NonExistentTimeError):
-                s.tz_localize(tz, nonexistent=method)
-        elif exp == "invalid":
-            with pytest.raises(ValueError):
-                dti.tz_localize(tz, nonexistent=method)
-        else:
-            result = s.tz_localize(tz, nonexistent=method)
-            expected = Series(1, index=DatetimeIndex([exp] * n, tz=tz))
-            tm.assert_series_equal(result, expected)
-
-    @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
-    def test_series_tz_localize_empty(self, tzstr):
-        # GH#2248
-        ser = Series(dtype=object)
-
-        ser2 = ser.tz_localize("utc")
-        assert ser2.index.tz == pytz.utc
-
-        ser2 = ser.tz_localize(tzstr)
-        timezones.tz_compare(ser2.index.tz, timezones.maybe_get_tz(tzstr))
-
-    # -----------------------------------------------------------------
-    # Series.tz_convert
-
-    def test_series_tz_convert(self):
-        rng = date_range("1/1/2011", periods=200, freq="D", tz="US/Eastern")
-        ts = Series(1, index=rng)
-
-        result = ts.tz_convert("Europe/Berlin")
-        assert result.index.tz.zone == "Europe/Berlin"
-
-        # can't convert tz-naive
-        rng = date_range("1/1/2011", periods=200, freq="D")
-        ts = Series(1, index=rng)
-
-        with pytest.raises(TypeError, match="Cannot convert tz-naive"):
-            ts.tz_convert("US/Eastern")
-
-    def test_series_tz_convert_to_utc(self):
-        base = DatetimeIndex(["2011-01-01", "2011-01-02", "2011-01-03"], tz="UTC")
-        idx1 = base.tz_convert("Asia/Tokyo")[:2]
-        idx2 = base.tz_convert("US/Eastern")[1:]
-
-        res = Series([1, 2], index=idx1) + Series([1, 1], index=idx2)
-        tm.assert_series_equal(res, Series([np.nan, 3, np.nan], index=base))
-
     # -----------------------------------------------------------------
     # Series.append
 
@@ -225,15 +119,6 @@ class TestSeriesTimezones:
         # it works! #2443
         repr(series.index[0])
 
-    @pytest.mark.parametrize("tz", ["US/Eastern", "dateutil/US/Eastern"])
-    def test_tz_aware_asfreq(self, tz):
-        dr = date_range("2011-12-01", "2012-07-20", freq="D", tz=tz)
-
-        ser = Series(np.random.randn(len(dr)), index=dr)
-
-        # it works!
-        ser.asfreq("T")
-
     @pytest.mark.parametrize("tz", ["US/Eastern", "dateutil/US/Eastern"])
     def test_string_index_alias_tz_aware(self, tz):
         rng = date_range("1/1/2000", periods=10, tz=tz)
@@ -299,28 +184,6 @@ class TestSeriesTimezones:
         assert new1.index.tz == pytz.UTC
         assert new2.index.tz == pytz.UTC
 
-    @pytest.mark.parametrize("tzstr", ["US/Eastern", "dateutil/US/Eastern"])
-    def test_localized_at_time_between_time(self, tzstr):
-        from datetime import time
-
-        tz = timezones.maybe_get_tz(tzstr)
-
-        rng = date_range("4/16/2012", "5/1/2012", freq="H")
-        ts = Series(np.random.randn(len(rng)), index=rng)
-
-        ts_local = ts.tz_localize(tzstr)
-
-        result = ts_local.at_time(time(10, 0))
-        expected = ts.at_time(time(10, 0)).tz_localize(tzstr)
-        tm.assert_series_equal(result, expected)
-        assert timezones.tz_compare(result.index.tz, tz)
-
-        t1, t2 = time(10, 0), time(11, 0)
-        result = ts_local.between_time(t1, t2)
-        expected = ts.between_time(t1, t2).tz_localize(tzstr)
-        tm.assert_series_equal(result, expected)
-        assert timezones.tz_compare(result.index.tz, tz)
-
     @pytest.mark.parametrize("tzstr", ["Europe/Berlin", "dateutil/Europe/Berlin"])
     def test_getitem_pydatetime_tz(self, tzstr):
         tz = timezones.maybe_get_tz(tzstr)
@@ -335,14 +198,6 @@ class TestSeriesTimezones:
         time_datetime = conversion.localize_pydatetime(dt, tz)
         assert ts[time_pandas] == ts[time_datetime]
 
-    def test_series_truncate_datetimeindex_tz(self):
-        # GH 9243
-        idx = date_range("4/1/2005", "4/30/2005", freq="D", tz="US/Pacific")
-        s = Series(range(len(idx)), index=idx)
-        result = s.truncate(datetime(2005, 4, 2), datetime(2005, 4, 4))
-        expected = Series([1, 2, 3], index=idx[1:4])
-        tm.assert_series_equal(result, expected)
-
     @pytest.mark.parametrize("copy", [True, False])
     @pytest.mark.parametrize(
         "method, tz", [["tz_localize", None], ["tz_convert", "Europe/Berlin"]]

commit 0b6ce9d75d228b103ad33f6c4e62840af7562cc9
Author: Adam Klein <adamklein@gmail.com>
Date:   Wed Mar 14 16:57:41 2012 -0400

    ENH, TST: added interval accessors, port skts testing over

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 339512b77..b61b28e99 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -60,7 +60,7 @@ def _dt_unbox_array(arr):
     unboxer = np.frompyfunc(_dt_unbox, 1, 1)
     return unboxer(arr)
 
-def _from_string_array(arr):
+def _str_to_dt_array(arr):
     def parser(x):
         result = parse_time_string(x)
         return result[0]
@@ -300,16 +300,17 @@ class Interval:
     def __add__(self, other):
         if isinstance(other, (int, long)):
             return Interval(self.ordinal + other, self.freq)
-        raise "Cannot add with non-integer value"
+        raise ValueError("Cannot add with non-integer value")
 
     def __sub__(self, other):
         if isinstance(other, (int, long)):
             return Interval(self.ordinal - other, self.freq)
         if isinstance(other, Interval):
             if other.freq != self.freq:
-                raise "Cannot do arithmetic with non-conforming intervals"
+                raise ValueError("Cannot do arithmetic with "
+                                 "non-conforming intervals")
             return self.ordinal - other.ordinal
-        raise "Cannot sub with non-integer value"
+        raise ValueError("Cannot sub with non-integer value")
 
     def asfreq(self, freq=None, how='E'):
         if how not in ('S', 'E'):
@@ -322,11 +323,71 @@ class Interval:
         else:
             base2, mult2 = freq
 
-        new_ordinal = lib.skts_freq_conv(self.ordinal, base1, mult1, 
+        new_ordinal = lib.skts_freq_conv(self.ordinal, base1, mult1,
                                          base2, mult2, how)
 
         return Interval(new_ordinal, (base2, mult2))
 
+    @property
+    def year(self):
+        base, mult = self.freq
+        return lib.get_skts_field(self.ordinal, base, mult, 'Y')
+
+    @property
+    def month(self):
+        base, mult = self.freq
+        return lib.get_skts_field(self.ordinal, base, mult, 'M')
+
+    @property
+    def qyear(self):
+        base, mult = self.freq
+        return lib.get_skts_field(self.ordinal, base, mult, 'R')
+
+    @property
+    def quarter(self):
+        base, mult = self.freq
+        return lib.get_skts_field(self.ordinal, base, mult, 'Q')
+
+    @property
+    def day(self):
+        base, mult = self.freq
+        return lib.get_skts_field(self.ordinal, base, mult, 'D')
+
+    @property
+    def week(self):
+        base, mult = self.freq
+        return lib.get_skts_field(self.ordinal, base, mult, 'E')
+
+    @property
+    def weekday(self):
+        base, mult = self.freq
+        return lib.get_skts_field(self.ordinal, base, mult, 'K')
+
+    @property
+    def day_of_week(self):
+        base, mult = self.freq
+        return lib.get_skts_field(self.ordinal, base, mult, 'W')
+
+    @property
+    def day_of_year(self):
+        base, mult = self.freq
+        return lib.get_skts_field(self.ordinal, base, mult, 'A')
+
+    @property
+    def hour(self):
+        base, mult = self.freq
+        return lib.get_skts_field(self.ordinal, base, mult, 'H')
+
+    @property
+    def minute(self):
+        base, mult = self.freq
+        return lib.get_skts_field(self.ordinal, base, mult, 'T')
+
+    @property
+    def second(self):
+        base, mult = self.freq
+        return lib.get_skts_field(self.ordinal, base, mult, 'S')
+
     @classmethod
     def now(cls, freq=None):
         if isinstance(freq, basestring):
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 2ea4cd7d0..4a4119bf8 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1221,12 +1221,12 @@ class DatetimeIndex(Int64Index):
 
             # try a few ways to make it datetime64
             if lib.is_string_array(data):
-                data = datetools._from_string_array(data)
+                data = datetools._str_to_dt_array(data)
             else:
                 data = np.asarray(data, dtype='M8[us]')
 
         if issubclass(data.dtype.type, basestring):
-            subarr = datetools._from_string_array(data)
+            subarr = datetools._str_to_dt_array(data)
         elif issubclass(data.dtype.type, np.integer):
             subarr = np.array(data, dtype='M8[us]', copy=copy)
         elif issubclass(data.dtype.type, np.datetime64):
diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index 4abad6697..9d5db1b0a 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -93,6 +93,20 @@ cdef extern from "np_datetime_strings.h":
     int get_datetime_iso_8601_strlen(int local, NPY_DATETIMEUNIT base)
 
 cdef extern from "skts.h":
+    ctypedef struct date_info:
+        long absdate
+        double abstime
+        double second
+        int minute
+        int hour
+        int day
+        int month
+        int quarter
+        int year
+        int day_of_week
+        int day_of_year
+        int calendar
+
     long frequency_conversion(long dtordinal, int freq1, int freq2, char relation) except -1
 
     long get_skts_ordinal(int year, int month, int day,
@@ -104,6 +118,21 @@ cdef extern from "skts.h":
     PyObject *interval_strftime(long value, int freq, PyObject *args)
     PyObject *interval_to_string(long value, int freq)
 
+    # int get_date_info(long ordinal, int freq, date_info *dinfo) except -1
+
+    int iyear(long ordinal, int freq) except -1
+    int iqyear(long ordinal, int freq) except -1
+    int iquarter(long ordinal, int freq) except -1
+    int imonth(long ordinal, int freq) except -1
+    int iday(long ordinal, int freq) except -1
+    int iweekday(long ordinal, int freq) except -1
+    int iday_of_week(long ordinal, int freq) except -1
+    int iday_of_year(long ordinal, int freq) except -1
+    int iweek(long ordinal, int freq) except -1
+    int ihour(long ordinal, int freq) except -1
+    int iminute(long ordinal, int freq) except -1
+    int isecond(long ordinal, int freq) except -1
+
 cdef extern from "stdint.h":
     enum: INT64_MIN
 
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index f66a16621..3dd0454ad 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -1855,13 +1855,19 @@ cdef long apply_mult(long skts_ord, long mult):
     For example, 5min ordinal will be 1/5th the 1min ordinal (rounding down to
     integer).
     """
+    if mult == 1:
+        return skts_ord
+
     return (skts_ord - 1) // mult
 
-cdef long remove_mult(long skits_ord_w_mult, long mult):
+cdef long remove_mult(long skts_ord_w_mult, long mult):
     """
     Get base-only ordinal value from corresponding base+multiple ordinal.
     """
-    return skits_ord_w_mult * mult + 1;
+    if mult == 1:
+        return skts_ord_w_mult
+
+    return skts_ord_w_mult * mult + 1;
 
 def dt64arr_to_sktsarr(ndarray[int64_t] dtarr, int base, long mult):
     """
@@ -1923,3 +1929,40 @@ def skts_ordinal_to_dt(long skts_ordinal, int base, long mult):
 
 def skts_ordinal_to_string(long value, int base, long mult):
     return <object>interval_to_string(remove_mult(value, mult), base)
+
+def get_skts_field(long value, int base, long mult, object fld):
+    return _get_skts_field(value, base, mult, (<char*>fld)[0])
+
+cdef int _get_skts_field(long value, int base, long mult, char fld) except -1:
+    cdef:
+        date_info dinfo
+
+    value = remove_mult(value, mult)
+
+    if fld == 'Y':
+        return iyear(value, base)
+    elif fld == 'R':
+        return iqyear(value, base)
+    elif fld == 'Q':
+        return iquarter(value, base)
+    elif fld == 'M':
+        return imonth(value, base)
+    elif fld == 'D':
+        return iday(value, base)
+    elif fld == 'H':
+        return ihour(value, base)
+    elif fld == 'T':
+        return iminute(value, base)
+    elif fld == 'S':
+        return isecond(value, base)
+    elif fld == 'W':
+        return iday_of_week(value, base)
+    elif fld == 'E':
+        return iweek(value, base)
+    elif fld == 'K': # python weekday
+        return iweekday(value, base)
+    elif fld == 'A':
+        return iday_of_year(value, base)
+
+    raise ValueError("Bad field passed to _get_skts_field")
+
diff --git a/pandas/src/skts.c b/pandas/src/skts.c
index e4b0a2cc9..c0f1582a0 100644
--- a/pandas/src/skts.c
+++ b/pandas/src/skts.c
@@ -959,7 +959,7 @@ int dInfoCalc_SetFromAbsDateTime(struct date_info *dinfo,
 
 long frequency_conversion(long skts_ordinal, int freq1, int freq2, char relation)
 {
-    freq_conv_func func = get_asfreq_func(freq1, freq2, 1);
+    freq_conv_func func = get_asfreq_func(freq1, freq2, 0);
 
     asfreq_info finfo;
     get_asfreq_info(freq1, freq2, &finfo);
@@ -1283,3 +1283,145 @@ PyObject *interval_to_string(long value, int freq)
 
     return retval;
 }
+
+static int _quarter_year(long ordinal, int freq, int *year, int *quarter) {
+    asfreq_info af_info;
+    int qtr_freq;
+
+    ordinal = get_python_ordinal(ordinal, freq);
+
+    if (get_freq_group(freq) == FR_QTR)
+        qtr_freq = freq;
+    else
+        qtr_freq = FR_QTR;
+
+    get_asfreq_info(FR_DAY, qtr_freq, &af_info);
+
+    if (DtoQ_yq(ordinal, &af_info, year, quarter) == INT_ERR_CODE)
+        return INT_ERR_CODE;
+
+    if ((qtr_freq % 1000) > 12)
+        *year -= 1;
+
+    return 0;
+}
+
+static int _ISOWeek(struct date_info *dinfo)
+{
+    int week;
+
+    /* Estimate */
+    week = (dinfo->day_of_year-1) - dinfo->day_of_week + 3;
+    if (week >= 0) week = week / 7 + 1;
+
+    /* Verify */
+    if (week < 0) {
+        /* The day lies in last week of the previous year */
+        if ((week > -2) ||
+            (week == -2 && dInfoCalc_Leapyear(dinfo->year-1, dinfo->calendar)))
+            week = 53;
+        else
+            week = 52;
+    } else if (week == 53) {
+    /* Check if the week belongs to year or year+1 */
+        if (31-dinfo->day + dinfo->day_of_week < 3) {
+            week = 1;
+        }
+    }
+
+    return week;
+}
+
+int get_date_info(long ordinal, int freq, struct date_info *dinfo)
+{
+    long absdate = get_python_ordinal(ordinal, freq);
+    double abstime = getAbsTime(freq, absdate, ordinal);
+
+    if(dInfoCalc_SetFromAbsDateTime(dinfo, absdate, abstime, GREGORIAN_CALENDAR))
+        return INT_ERR_CODE;
+
+    return 0;
+}
+
+int iyear(long ordinal, int freq) {
+    struct date_info dinfo;
+    get_date_info(ordinal, freq, &dinfo);
+    return dinfo.year;
+}
+
+int iqyear(long ordinal, int freq) {
+    int year, quarter;
+    if( _quarter_year(ordinal, freq, &year, &quarter) == INT_ERR_CODE)
+        return INT_ERR_CODE;
+    return year;
+}
+
+int iquarter(long ordinal, int freq) {
+    int year, quarter;
+    if(_quarter_year(ordinal, freq, &year, &quarter) == INT_ERR_CODE)
+        return INT_ERR_CODE;
+    return quarter;
+}
+
+int imonth(long ordinal, int freq) {
+    struct date_info dinfo;
+    if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
+        return INT_ERR_CODE;
+    return dinfo.month;
+}
+
+int iday(long ordinal, int freq) {
+    struct date_info dinfo;
+    if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
+        return INT_ERR_CODE;
+    return dinfo.day;
+}
+
+int iweekday(long ordinal, int freq) {
+    struct date_info dinfo;
+    if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
+        return INT_ERR_CODE;
+    return dinfo.day_of_week;
+}
+
+int iday_of_week(long ordinal, int freq) {
+    struct date_info dinfo;
+    if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
+        return INT_ERR_CODE;
+    return dinfo.day_of_week;
+}
+
+int iday_of_year(long ordinal, int freq) {
+    struct date_info dinfo;
+    if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
+        return INT_ERR_CODE;
+    return dinfo.day_of_year;
+}
+
+int iweek(long ordinal, int freq) {
+    struct date_info dinfo;
+    if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
+        return INT_ERR_CODE;
+    return _ISOWeek(&dinfo);
+}
+
+int ihour(long ordinal, int freq) {
+    struct date_info dinfo;
+    if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
+        return INT_ERR_CODE;
+    return dinfo.hour;
+}
+
+int iminute(long ordinal, int freq) {
+    struct date_info dinfo;
+    if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
+        return INT_ERR_CODE;
+    return dinfo.minute;
+}
+
+int isecond(long ordinal, int freq) {
+    struct date_info dinfo;
+    if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
+        return INT_ERR_CODE;
+    return (int)dinfo.second;
+}
diff --git a/pandas/src/skts.h b/pandas/src/skts.h
index 80308ece7..5da44b6c6 100644
--- a/pandas/src/skts.h
+++ b/pandas/src/skts.h
@@ -161,4 +161,19 @@ long get_python_ordinal(long skts_ordinal, int freq);
 PyObject *interval_strftime(long value, int freq, PyObject *args);
 PyObject *interval_to_string(long value, int freq);
 
+int get_date_info(long ordinal, int freq, struct date_info *dinfo);
+
+int iyear(long ordinal, int freq);
+int iqyear(long ordinal, int freq);
+int iquarter(long ordinal, int freq);
+int imonth(long ordinal, int freq);
+int iday(long ordinal, int freq);
+int iweekday(long ordinal, int freq);
+int iday_of_week(long ordinal, int freq);
+int iday_of_year(long ordinal, int freq);
+int iweek(long ordinal, int freq);
+int ihour(long ordinal, int freq);
+int iminute(long ordinal, int freq);
+int isecond(long ordinal, int freq);
+
 #endif
diff --git a/pandas/tests/test_datetime64.py b/pandas/tests/test_datetime64.py
index ea178ede9..14a4d5a49 100644
--- a/pandas/tests/test_datetime64.py
+++ b/pandas/tests/test_datetime64.py
@@ -561,53 +561,7 @@ class TestDatetime64(unittest.TestCase):
         for other in [idx2, idx3, idx4, idx5, idx6]:
             self.assert_( (idx1.values == other.values).all() )
 
-    def test_interval_constructor(self):
-        i1 = Interval('1/1/2005', freq='M')
-        i2 = Interval('Jan 2005')
-
-        self.assertEquals(i1, i2)
-
-        i1 = Interval('2005', freq='A')
-        i2 = Interval('2005')
-
-        self.assertEquals(i1, i2)
-
-        i3 = Interval('2005', freq='M')
-        self.assert_(i1 != i3)
-
-        i1 = Interval.now('Q')
-        i2 = Interval(datetime.now(), freq='Q')
-
-        self.assertEquals(i1, i2)
-
-        # Biz day construction, roll forward if non-weekday
-        i1 = Interval('3/10/12', freq='B')
-        i2 = Interval('3/12/12', freq='D')
-        self.assertEquals(i1, i2.asfreq('B'))
-
-        i1 = Interval(year=2005, quarter=1, freq='Q')
-        i2 = Interval('1/1/2005', freq='Q')
-        self.assertEquals(i1, i2)
-
-        i1 = Interval(year=2005, quarter=3, freq='Q')
-        i2 = Interval('9/1/2005', freq='Q')
-        self.assertEquals(i1, i2)
-
-        i1 = Interval(year=2005, month=3, day=1, freq='D')
-        i2 = Interval('3/1/2005', freq='D')
-        self.assertEquals(i1, i2)
-
-        i1 = Interval(year=2012, month=3, day=10, freq='B')
-        i2 = Interval('3/12/12', freq='B')
-        self.assertEquals(i1, i2)
-
-    def test_interval_asfreq(self):
-        # need a whole bunch of tests here ...
-        # D to B conversion exception, not on biz day
-        i1 = Interval('3/10/12')
-        self.assertRaises(Exception, i1.asfreq, 'B')
-
-    def test_interval_slice_index(self):
+    def test_iindex_slice_index(self):
         ii = IntervalIndex(start='1/1/10', end='12/31/12', freq='M')
         s = Series(np.random.rand(len(ii)), index=ii)
         res = s['2010']
@@ -617,7 +571,7 @@ class TestDatetime64(unittest.TestCase):
         exp = s[12:24]
         assert_series_equal(res, exp)
         
-    def test_interval_multiples(self):
+    def test_iindex_multiples(self):
         ii = IntervalIndex(start='1/1/10', end='12/31/12', freq='2M')
         self.assertEquals(ii[0], Interval('1/1/10', '2M'))
         self.assertEquals(ii[1], Interval('3/1/10', '2M'))

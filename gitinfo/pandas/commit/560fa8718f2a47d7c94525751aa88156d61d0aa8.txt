commit 560fa8718f2a47d7c94525751aa88156d61d0aa8
Author: Jeff Reback <jeff@reback.net>
Date:   Mon Mar 2 06:06:30 2015 -0500

    API: enable float slicing with .ix

diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index 846285ef4..5079b4fa8 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -295,26 +295,18 @@ Selection By Label
 .. warning::
 
    ``.loc`` is strict when you present slicers that are not compatible (or convertible) with the index type. For example
-   using integers in a ``DatetimeIndex`` or float indexers in an ``Int64Index``. These will raise a ``TypeError``.
+   using integers in a ``DatetimeIndex``. These will raise a ``TypeError``.
 
   .. ipython:: python
 
      dfl = DataFrame(np.random.randn(5,4), columns=list('ABCD'), index=date_range('20130101',periods=5))
      dfl
-     sl = Series(range(5),[-2,-1,1,2,3])
-     sl
 
   .. code-block:: python
 
      In [4]: dfl.loc[2:3]
      TypeError: cannot do slice indexing on <class 'pandas.tseries.index.DatetimeIndex'> with these indexers [2] of <type 'int'>
 
-  .. code-block:: python
-
-     In [8]: sl.loc[-1.0:2]
-     TypeError: cannot do slice indexing on <class 'pandas.core.index.Int64Index'> with these indexers [-1.0] of <type 'float'>
-
-
   String likes in slicing *can* be convertible to the type of the index and lead to natural slicing.
 
   .. ipython:: python
diff --git a/doc/source/whatsnew/v0.16.0.txt b/doc/source/whatsnew/v0.16.0.txt
index 03b0b55b8..9cb474a53 100644
--- a/doc/source/whatsnew/v0.16.0.txt
+++ b/doc/source/whatsnew/v0.16.0.txt
@@ -322,13 +322,6 @@ The behavior of a small sub-set of edge cases for using ``.loc`` have changed (:
      In [6]: s.loc[-10:3]
      KeyError: 'start bound [-10] is not the [index]'
 
-     In [8]: s.loc[-1.0:2]
-     Out[2]:
-     -1    1
-      1    2
-      2    3
-     dtype: int64
-
   New Behavior
 
   .. ipython:: python
@@ -336,10 +329,25 @@ The behavior of a small sub-set of edge cases for using ``.loc`` have changed (:
      df.loc['2013-01-02':'2013-01-10']
      s.loc[-10:3]
 
+- allow slicing with float-like values on an integer index for ``.ix``. Previously this was only enabled for ``.loc``:
+
   .. code-block:: python
 
-     In [8]: s.loc[-1.0:2]
-     TypeError: cannot do slice indexing on <class 'pandas.core.index.Int64Index'> with these indexers [-1.0] of <type 'float'>
+  Previous Behavior
+
+     In [8]: s.ix[-1.0:2]
+     TypeError: the slice start value [-1.0] is not a proper indexer for this index type (Int64Index)
+
+  New Behavior
+
+  .. ipython:: python
+
+     In [8]: s.ix[-1.0:2]
+     Out[2]:
+     -1    1
+      1    2
+      2    3
+     dtype: int64
 
 - provide a useful exception for indexing with an invalid type for that index when using ``.loc``. For example trying to use ``.loc`` on an index of type ``DatetimeIndex`` or ``PeriodIndex`` or ``TimedeltaIndex``, with an integer (or a float).
 
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 020ba5cb2..298f00532 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -707,8 +707,11 @@ class Index(IndexOpsMixin, PandasObject):
             if v is None or is_integer(v):
                 return True
 
-            # dissallow floats
+            # dissallow floats (except for .ix)
             elif is_float(v):
+                if typ == 'ix':
+                    return True
+
                 return False
 
             return True
diff --git a/pandas/tests/test_indexing.py b/pandas/tests/test_indexing.py
index 847506b9e..b8650683a 100644
--- a/pandas/tests/test_indexing.py
+++ b/pandas/tests/test_indexing.py
@@ -4004,6 +4004,12 @@ class TestIndexing(tm.TestCase):
 
     def test_slice_indexer(self):
 
+        def check_iloc_compat(s):
+            # invalid type for iloc (but works with a warning)
+            self.assert_produces_warning(FutureWarning, lambda : s.iloc[6.0:8])
+            self.assert_produces_warning(FutureWarning, lambda : s.iloc[6.0:8.0])
+            self.assert_produces_warning(FutureWarning, lambda : s.iloc[6:8.0])
+
         def check_slicing_positional(index):
 
             s = Series(np.arange(len(index))+10,index=index)
@@ -4031,17 +4037,16 @@ class TestIndexing(tm.TestCase):
             self.assertRaises(TypeError, lambda : s.loc[2.0:5.0])
             self.assertRaises(TypeError, lambda : s.loc[2:5.0])
 
-            # these work for now
-            #self.assertRaises(TypeError, lambda : s.iloc[2.0:5])
-            #self.assertRaises(TypeError, lambda : s.iloc[2.0:5.0])
-            #self.assertRaises(TypeError, lambda : s.iloc[2:5.0])
+            check_iloc_compat(s)
 
         # all index types except int, float
         for index in [ tm.makeStringIndex, tm.makeUnicodeIndex,
                        tm.makeDateIndex, tm.makeTimedeltaIndex, tm.makePeriodIndex ]:
             check_slicing_positional(index())
 
-        # int
+        ############
+        # IntIndex #
+        ############
         index = tm.makeIntIndex()
         s = Series(np.arange(len(index))+10,index+5)
 
@@ -4050,38 +4055,34 @@ class TestIndexing(tm.TestCase):
         result4 = s.iloc[2:5]
         assert_series_equal(result1, result4)
 
-        # these are all value based
+        # these are all label based
         result2 = s.ix[2:5]
         result3 = s.loc[2:5]
         assert_series_equal(result2, result3)
 
         # float slicers on an int index
         expected = Series([11,12,13],index=[6,7,8])
-        result = s.loc[6.0:8.5]
-        assert_series_equal(result, expected)
+        for method in [lambda x: x.loc, lambda x: x.ix]:
+            result = method(s)[6.0:8.5]
+            assert_series_equal(result, expected)
 
-        result = s.loc[5.5:8.5]
-        assert_series_equal(result, expected)
+            result = method(s)[5.5:8.5]
+            assert_series_equal(result, expected)
 
-        result = s.loc[5.5:8.0]
-        assert_series_equal(result, expected)
+            result = method(s)[5.5:8.0]
+            assert_series_equal(result, expected)
 
-        # make all float slicing fail for ix/[] with an int index
+        # make all float slicing fail for [] with an int index
         self.assertRaises(TypeError, lambda : s[6.0:8])
         self.assertRaises(TypeError, lambda : s[6.0:8.0])
         self.assertRaises(TypeError, lambda : s[6:8.0])
-        self.assertRaises(TypeError, lambda : s.ix[6.0:8])
-        self.assertRaises(TypeError, lambda : s.ix[6.0:8.0])
-        self.assertRaises(TypeError, lambda : s.ix[6:8.0])
 
-        # these work for now
-        #self.assertRaises(TypeError, lambda : s.iloc[6.0:8])
-        #self.assertRaises(TypeError, lambda : s.iloc[6.0:8.0])
-        #self.assertRaises(TypeError, lambda : s.iloc[6:8.0])
+        check_iloc_compat(s)
 
-        # float
-        index = tm.makeFloatIndex()
-        s = Series(np.arange(len(index))+10,index=index+5)
+        ##############
+        # FloatIndex #
+        ##############
+        s.index = s.index.astype('float64')
 
         # these are all value based
         result1 = s[6:8]
@@ -4090,50 +4091,25 @@ class TestIndexing(tm.TestCase):
         assert_series_equal(result1, result2)
         assert_series_equal(result1, result3)
 
-        # these are all valid
-        result1a = s[6.0:8]
-        result2a = s[6.0:8.0]
-        result3a = s[6:8.0]
-        result1b = s[6.5:8]
-        result2b = s[6.5:8.5]
-        result3b = s[6:8.5]
-        assert_series_equal(result1a, result2a)
-        assert_series_equal(result1a, result3a)
-        assert_series_equal(result1a, result1b)
-        assert_series_equal(result1a, result2b)
-        assert_series_equal(result1a, result3b)
-
-        result1c = s.ix[6.0:8]
-        result2c = s.ix[6.0:8.0]
-        result3c = s.ix[6:8.0]
-        result1d = s.ix[6.5:8]
-        result2d = s.ix[6.5:8.5]
-        result3d = s.ix[6:8.5]
-        assert_series_equal(result1a, result1c)
-        assert_series_equal(result1a, result2c)
-        assert_series_equal(result1a, result3c)
-        assert_series_equal(result1a, result1d)
-        assert_series_equal(result1a, result2d)
-        assert_series_equal(result1a, result3d)
-
-        result1e = s.loc[6.0:8]
-        result2e = s.loc[6.0:8.0]
-        result3e = s.loc[6:8.0]
-        result1f = s.loc[6.5:8]
-        result2f = s.loc[6.5:8.5]
-        result3f = s.loc[6:8.5]
-        assert_series_equal(result1a, result1e)
-        assert_series_equal(result1a, result2e)
-        assert_series_equal(result1a, result3e)
-        assert_series_equal(result1a, result1f)
-        assert_series_equal(result1a, result2f)
-        assert_series_equal(result1a, result3f)
-
-
-        # these work for now
-        #self.assertRaises(TypeError, lambda : s.iloc[2.0:5])
-        #self.assertRaises(TypeError, lambda : s.iloc[2.0:5.0])
-        #self.assertRaises(TypeError, lambda : s.iloc[2:5.0])
+        # these are valid for all methods
+        # these are treated like labels (e.g. the rhs IS included)
+        def compare(slicers, expected):
+            for method in [lambda x: x, lambda x: x.loc, lambda x: x.ix ]:
+                for slices in slicers:
+
+                    result = method(s)[slices]
+                    assert_series_equal(result, expected)
+
+        compare([slice(6.0,8),slice(6.0,8.0),slice(6,8.0)],
+                s[(s.index>=6.0)&(s.index<=8)])
+        compare([slice(6.5,8),slice(6.5,8.5)],
+                s[(s.index>=6.5)&(s.index<=8.5)])
+        compare([slice(6,8.5)],
+                s[(s.index>=6.0)&(s.index<=8.5)])
+        compare([slice(6.5,6.5)],
+                s[(s.index>=6.5)&(s.index<=6.5)])
+
+        check_iloc_compat(s)
 
     def test_set_ix_out_of_bounds_axis_0(self):
         df = pd.DataFrame(randn(2, 5), index=["row%s" % i for i in range(2)], columns=["col%s" % i for i in range(5)])

commit 2c982dfcf4698970fa51046aea066d78f0166f57
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sun Nov 11 15:26:59 2018 -0800

    BUG/REF: TimedeltaIndex.__new__ (#23539)

diff --git a/doc/source/whatsnew/v0.24.0.txt b/doc/source/whatsnew/v0.24.0.txt
index 3c05d4d90..73fd52664 100644
--- a/doc/source/whatsnew/v0.24.0.txt
+++ b/doc/source/whatsnew/v0.24.0.txt
@@ -247,6 +247,7 @@ Backwards incompatible API changes
 
 - A newly constructed empty :class:`DataFrame` with integer as the ``dtype`` will now only be cast to ``float64`` if ``index`` is specified (:issue:`22858`)
 - :meth:`Series.str.cat` will now raise if `others` is a `set` (:issue:`23009`)
+- Passing scalar values to :class:`DatetimeIndex` or :class:`TimedeltaIndex` will now raise ``TypeError`` instead of ``ValueError`` (:issue:`23539`)
 
 .. _whatsnew_0240.api_breaking.deps:
 
@@ -969,6 +970,7 @@ Deprecations
 - The class ``FrozenNDArray`` has been deprecated. When unpickling, ``FrozenNDArray`` will be unpickled to ``np.ndarray`` once this class is removed (:issue:`9031`)
 - Deprecated the `nthreads` keyword of :func:`pandas.read_feather` in favor of
   `use_threads` to reflect the changes in pyarrow 0.11.0. (:issue:`23053`)
+- Constructing a :class:`TimedeltaIndex` from data with ``datetime64``-dtyped data is deprecated, will raise ``TypeError`` in a future version (:issue:`23539`)
 
 .. _whatsnew_0240.deprecations.datetimelike_int_ops:
 
diff --git a/pandas/core/arrays/datetimes.py b/pandas/core/arrays/datetimes.py
index 08b83598b..b0485cc82 100644
--- a/pandas/core/arrays/datetimes.py
+++ b/pandas/core/arrays/datetimes.py
@@ -234,9 +234,7 @@ class DatetimeArrayMixin(dtl.DatetimeLikeArrayMixin):
 
         result = cls._simple_new(values, freq=freq, tz=tz)
         if freq_infer:
-            inferred = result.inferred_freq
-            if inferred:
-                result.freq = to_offset(inferred)
+            result.freq = to_offset(result.inferred_freq)
 
         # NB: Among other things not yet ported from the DatetimeIndex
         # constructor, this does not call _deepcopy_if_needed
diff --git a/pandas/core/arrays/timedeltas.py b/pandas/core/arrays/timedeltas.py
index cf3ba263d..1f78e0c00 100644
--- a/pandas/core/arrays/timedeltas.py
+++ b/pandas/core/arrays/timedeltas.py
@@ -1,18 +1,28 @@
 # -*- coding: utf-8 -*-
 from datetime import timedelta
+import warnings
 
 import numpy as np
 
 from pandas._libs import tslibs
-from pandas._libs.tslibs import Timedelta, Timestamp, NaT
+from pandas._libs.tslibs import Timedelta, Timestamp, NaT, iNaT
 from pandas._libs.tslibs.fields import get_timedelta_field
-from pandas._libs.tslibs.timedeltas import array_to_timedelta64
+from pandas._libs.tslibs.timedeltas import (
+    array_to_timedelta64, parse_timedelta_unit)
 
 from pandas import compat
 
 from pandas.core.dtypes.common import (
-    _TD_DTYPE, is_list_like)
-from pandas.core.dtypes.generic import ABCSeries
+    _TD_DTYPE,
+    is_object_dtype,
+    is_string_dtype,
+    is_float_dtype,
+    is_integer_dtype,
+    is_timedelta64_dtype,
+    is_datetime64_dtype,
+    is_list_like,
+    ensure_int64)
+from pandas.core.dtypes.generic import ABCSeries, ABCTimedeltaIndex
 from pandas.core.dtypes.missing import isna
 
 import pandas.core.common as com
@@ -139,9 +149,7 @@ class TimedeltaArrayMixin(dtl.DatetimeLikeArrayMixin):
 
         result = cls._simple_new(values, freq=freq)
         if freq_infer:
-            inferred = result.inferred_freq
-            if inferred:
-                result.freq = to_offset(inferred)
+            result.freq = to_offset(result.inferred_freq)
 
         return result
 
@@ -397,6 +405,163 @@ TimedeltaArrayMixin._add_datetimelike_methods()
 # ---------------------------------------------------------------------
 # Constructor Helpers
 
+def sequence_to_td64ns(data, copy=False, unit="ns", errors="raise"):
+    """
+    Parameters
+    ----------
+    array : list-like
+    copy : bool, default False
+    unit : str, default "ns"
+    errors : {"raise", "coerce", "ignore"}, default "raise"
+
+    Returns
+    -------
+    ndarray[timedelta64[ns]]
+    inferred_freq : Tick or None
+
+    Raises
+    ------
+    ValueError : data cannot be converted to timedelta64[ns]
+
+    Notes
+    -----
+    Unlike `pandas.to_timedelta`, if setting `errors=ignore` will not cause
+    errors to be ignored; they are caught and subsequently ignored at a
+    higher level.
+    """
+    inferred_freq = None
+    unit = parse_timedelta_unit(unit)
+
+    # Unwrap whatever we have into a np.ndarray
+    if not hasattr(data, 'dtype'):
+        # e.g. list, tuple
+        if np.ndim(data) == 0:
+            # i.e. generator
+            data = list(data)
+        data = np.array(data, copy=False)
+    elif isinstance(data, ABCSeries):
+        data = data._values
+    elif isinstance(data, (ABCTimedeltaIndex, TimedeltaArrayMixin)):
+        inferred_freq = data.freq
+        data = data._data
+
+    # Convert whatever we have into timedelta64[ns] dtype
+    if is_object_dtype(data) or is_string_dtype(data):
+        # no need to make a copy, need to convert if string-dtyped
+        data = objects_to_td64ns(data, unit=unit, errors=errors)
+        copy = False
+
+    elif is_integer_dtype(data):
+        # treat as multiples of the given unit
+        data, copy_made = ints_to_td64ns(data, unit=unit)
+        copy = copy and not copy_made
+
+    elif is_float_dtype(data):
+        # treat as multiples of the given unit.  If after converting to nanos,
+        #  there are fractional components left, these are truncated
+        #  (i.e. NOT rounded)
+        mask = np.isnan(data)
+        coeff = np.timedelta64(1, unit) / np.timedelta64(1, 'ns')
+        data = (coeff * data).astype(np.int64).view('timedelta64[ns]')
+        data[mask] = iNaT
+        copy = False
+
+    elif is_timedelta64_dtype(data):
+        if data.dtype != _TD_DTYPE:
+            # non-nano unit
+            # TODO: watch out for overflows
+            data = data.astype(_TD_DTYPE)
+            copy = False
+
+    elif is_datetime64_dtype(data):
+        # GH#23539
+        warnings.warn("Passing datetime64-dtype data to TimedeltaIndex is "
+                      "deprecated, will raise a TypeError in a future "
+                      "version",
+                      FutureWarning, stacklevel=3)
+        data = ensure_int64(data).view(_TD_DTYPE)
+
+    else:
+        raise TypeError("dtype {dtype} cannot be converted to timedelta64[ns]"
+                        .format(dtype=data.dtype))
+
+    data = np.array(data, copy=copy)
+    assert data.dtype == 'm8[ns]', data
+    return data, inferred_freq
+
+
+def ints_to_td64ns(data, unit="ns"):
+    """
+    Convert an ndarray with integer-dtype to timedelta64[ns] dtype, treating
+    the integers as multiples of the given timedelta unit.
+
+    Parameters
+    ----------
+    data : np.ndarray with integer-dtype
+    unit : str, default "ns"
+
+    Returns
+    -------
+    ndarray[timedelta64[ns]]
+    bool : whether a copy was made
+    """
+    copy_made = False
+    unit = unit if unit is not None else "ns"
+
+    if data.dtype != np.int64:
+        # converting to int64 makes a copy, so we can avoid
+        # re-copying later
+        data = data.astype(np.int64)
+        copy_made = True
+
+    if unit != "ns":
+        dtype_str = "timedelta64[{unit}]".format(unit=unit)
+        data = data.view(dtype_str)
+
+        # TODO: watch out for overflows when converting from lower-resolution
+        data = data.astype("timedelta64[ns]")
+        # the astype conversion makes a copy, so we can avoid re-copying later
+        copy_made = True
+
+    else:
+        data = data.view("timedelta64[ns]")
+
+    return data, copy_made
+
+
+def objects_to_td64ns(data, unit="ns", errors="raise"):
+    """
+    Convert a object-dtyped or string-dtyped array into an
+    timedelta64[ns]-dtyped array.
+
+    Parameters
+    ----------
+    data : ndarray or Index
+    unit : str, default "ns"
+    errors : {"raise", "coerce", "ignore"}, default "raise"
+
+    Returns
+    -------
+    ndarray[timedelta64[ns]]
+
+    Raises
+    ------
+    ValueError : data cannot be converted to timedelta64[ns]
+
+    Notes
+    -----
+    Unlike `pandas.to_timedelta`, if setting `errors=ignore` will not cause
+    errors to be ignored; they are caught and subsequently ignored at a
+    higher level.
+    """
+    # coerce Index to np.ndarray, converting string-dtype if necessary
+    values = np.array(data, dtype=np.object_, copy=False)
+
+    result = array_to_timedelta64(values,
+                                  unit=unit, errors=errors)
+    return result.view('timedelta64[ns]')
+
+
 def _generate_regular_range(start, end, periods, offset):
     stride = offset.nanos
     if periods is None:
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index 8da067255..c82cff195 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -239,6 +239,21 @@ class DatetimeIndex(DatetimeArrayMixin, DatelikeOps, TimelikeOps,
                 dayfirst=False, yearfirst=False, dtype=None,
                 copy=False, name=None, verify_integrity=True):
 
+        if data is None:
+            # TODO: Remove this block and associated kwargs; GH#20535
+            result = cls._generate_range(start, end, periods,
+                                         freq=freq, tz=tz, normalize=normalize,
+                                         closed=closed, ambiguous=ambiguous)
+            result.name = name
+            return result
+
+        if is_scalar(data):
+            raise TypeError("{cls}() must be called with a "
+                            "collection of some kind, {data} was passed"
+                            .format(cls=cls.__name__, data=repr(data)))
+
+        # - Cases checked above all return/raise before reaching here - #
+
         # This allows to later ensure that the 'copy' parameter is honored:
         if isinstance(data, Index):
             ref_to_data = data._data
@@ -253,20 +268,8 @@ class DatetimeIndex(DatetimeArrayMixin, DatelikeOps, TimelikeOps,
         # if dtype has an embedded tz, capture it
         tz = dtl.validate_tz_from_dtype(dtype, tz)
 
-        if data is None:
-            # TODO: Remove this block and associated kwargs; GH#20535
-            result = cls._generate_range(start, end, periods,
-                                         freq=freq, tz=tz, normalize=normalize,
-                                         closed=closed, ambiguous=ambiguous)
-            result.name = name
-            return result
-
         if not isinstance(data, (np.ndarray, Index, ABCSeries,
                                  DatetimeArrayMixin)):
-            if is_scalar(data):
-                raise ValueError('DatetimeIndex() must be called with a '
-                                 'collection of some kind, %s was passed'
-                                 % repr(data))
             # other iterable of some kind
             if not isinstance(data, (list, tuple)):
                 data = list(data)
@@ -328,9 +331,7 @@ class DatetimeIndex(DatetimeArrayMixin, DatelikeOps, TimelikeOps,
                 cls._validate_frequency(subarr, freq, ambiguous=ambiguous)
 
         if freq_infer:
-            inferred = subarr.inferred_freq
-            if inferred:
-                subarr.freq = to_offset(inferred)
+            subarr.freq = to_offset(subarr.inferred_freq)
 
         return subarr._deepcopy_if_needed(ref_to_data, copy)
 
diff --git a/pandas/core/indexes/timedeltas.py b/pandas/core/indexes/timedeltas.py
index 5b077a698..35e17c740 100644
--- a/pandas/core/indexes/timedeltas.py
+++ b/pandas/core/indexes/timedeltas.py
@@ -15,7 +15,8 @@ from pandas.core.dtypes.common import (
 from pandas.core.dtypes.missing import isna
 
 from pandas.core.arrays.timedeltas import (
-    TimedeltaArrayMixin, _is_convertible_to_td, _to_m8)
+    TimedeltaArrayMixin, _is_convertible_to_td, _to_m8,
+    sequence_to_td64ns)
 from pandas.core.arrays import datetimelike as dtl
 
 from pandas.core.indexes.base import Index
@@ -33,10 +34,9 @@ from pandas.core.indexes.datetimelike import (
     TimelikeOps, DatetimeIndexOpsMixin, wrap_arithmetic_op,
     wrap_array_method, wrap_field_accessor)
 from pandas.core.tools.timedeltas import (
-    to_timedelta, _coerce_scalar_to_timedelta_type)
+    _coerce_scalar_to_timedelta_type)
 from pandas._libs import (lib, index as libindex,
                           join as libjoin, Timedelta, NaT)
-from pandas._libs.tslibs.timedeltas import array_to_timedelta64
 
 
 class TimedeltaIndex(TimedeltaArrayMixin, DatetimeIndexOpsMixin,
@@ -139,12 +139,6 @@ class TimedeltaIndex(TimedeltaArrayMixin, DatetimeIndexOpsMixin,
                 periods=None, closed=None, dtype=None, copy=False,
                 name=None, verify_integrity=True):
 
-        if isinstance(data, TimedeltaIndex) and freq is None and name is None:
-            if copy:
-                return data.copy()
-            else:
-                return data._shallow_copy()
-
         freq, freq_infer = dtl.maybe_infer_freq(freq)
 
         if data is None:
@@ -154,32 +148,31 @@ class TimedeltaIndex(TimedeltaArrayMixin, DatetimeIndexOpsMixin,
             result.name = name
             return result
 
-        if unit is not None:
-            data = to_timedelta(data, unit=unit, box=False)
-
         if is_scalar(data):
-            raise ValueError('TimedeltaIndex() must be called with a '
-                             'collection of some kind, {data} was passed'
-                             .format(data=repr(data)))
-
-        # convert if not already
-        if getattr(data, 'dtype', None) != _TD_DTYPE:
-            data = to_timedelta(data, unit=unit, box=False)
-        elif copy:
-            data = np.array(data, copy=True)
-
-        data = np.array(data, copy=False)
-        if data.dtype == np.object_:
-            data = array_to_timedelta64(data)
-        if data.dtype != _TD_DTYPE:
-            if is_timedelta64_dtype(data):
-                # non-nano unit
-                # TODO: watch out for overflows
-                data = data.astype(_TD_DTYPE)
+            raise TypeError('{cls}() must be called with a '
+                            'collection of some kind, {data} was passed'
+                            .format(cls=cls.__name__, data=repr(data)))
+
+        if isinstance(data, TimedeltaIndex) and freq is None and name is None:
+            if copy:
+                return data.copy()
             else:
-                data = ensure_int64(data).view(_TD_DTYPE)
+                return data._shallow_copy()
 
-        assert data.dtype == 'm8[ns]', data.dtype
+        # - Cases checked above all return/raise before reaching here - #
+
+        data, inferred_freq = sequence_to_td64ns(data, copy=copy, unit=unit)
+        if inferred_freq is not None:
+            if freq is not None and freq != inferred_freq:
+                raise ValueError('Inferred frequency {inferred} from passed '
+                                 'values does not conform to passed frequency '
+                                 '{passed}'
+                                 .format(inferred=inferred_freq,
+                                         passed=freq.freqstr))
+            elif freq_infer:
+                freq = inferred_freq
+                freq_infer = False
+            verify_integrity = False
 
         subarr = cls._simple_new(data, name=name, freq=freq)
         # check that we are matching freqs
@@ -188,9 +181,7 @@ class TimedeltaIndex(TimedeltaArrayMixin, DatetimeIndexOpsMixin,
                 cls._validate_frequency(subarr, freq)
 
         if freq_infer:
-            inferred = subarr.inferred_freq
-            if inferred:
-                subarr.freq = to_offset(inferred)
+            subarr.freq = to_offset(subarr.inferred_freq)
 
         return subarr
 
diff --git a/pandas/core/tools/timedeltas.py b/pandas/core/tools/timedeltas.py
index 220b14a9c..fad136b3b 100644
--- a/pandas/core/tools/timedeltas.py
+++ b/pandas/core/tools/timedeltas.py
@@ -6,16 +6,13 @@ import numpy as np
 import pandas as pd
 from pandas._libs import tslibs
 from pandas._libs.tslibs.timedeltas import (convert_to_timedelta64,
-                                            array_to_timedelta64,
                                             parse_timedelta_unit)
 
-from pandas.core.dtypes.common import (
-    ensure_object,
-    is_integer_dtype,
-    is_timedelta64_dtype,
-    is_list_like)
+from pandas.core.dtypes.common import is_list_like
 from pandas.core.dtypes.generic import ABCSeries, ABCIndexClass
 
+from pandas.core.arrays.timedeltas import sequence_to_td64ns
+
 
 def to_timedelta(arg, unit='ns', box=True, errors='raise'):
     """
@@ -129,31 +126,27 @@ def _convert_listlike(arg, unit='ns', box=True, errors='raise', name=None):
     """Convert a list of objects to a timedelta index object."""
 
     if isinstance(arg, (list, tuple)) or not hasattr(arg, 'dtype'):
-        arg = np.array(list(arg), dtype='O')
-
-    # these are shortcut-able
-    if is_timedelta64_dtype(arg):
-        value = arg.astype('timedelta64[ns]')
-    elif is_integer_dtype(arg):
-        value = arg.astype('timedelta64[{unit}]'.format(unit=unit)).astype(
-            'timedelta64[ns]', copy=False)
-    else:
-        try:
-            value = array_to_timedelta64(ensure_object(arg),
-                                         unit=unit, errors=errors)
-            value = value.astype('timedelta64[ns]', copy=False)
-        except ValueError:
-            if errors == 'ignore':
-                return arg
-            else:
-                # This else-block accounts for the cases when errors='raise'
-                # and errors='coerce'. If errors == 'raise', these errors
-                # should be raised. If errors == 'coerce', we shouldn't
-                # expect any errors to be raised, since all parsing errors
-                # cause coercion to pd.NaT. However, if an error / bug is
-                # introduced that causes an Exception to be raised, we would
-                # like to surface it.
-                raise
+        # This is needed only to ensure that in the case where we end up
+        #  returning arg (errors == "ignore"), and where the input is a
+        #  generator, we return a useful list-like instead of a
+        #  used-up generator
+        arg = np.array(list(arg), dtype=object)
+
+    try:
+        value = sequence_to_td64ns(arg, unit=unit,
+                                   errors=errors, copy=False)[0]
+    except ValueError:
+        if errors == 'ignore':
+            return arg
+        else:
+            # This else-block accounts for the cases when errors='raise'
+            # and errors='coerce'. If errors == 'raise', these errors
+            # should be raised. If errors == 'coerce', we shouldn't
+            # expect any errors to be raised, since all parsing errors
+            # cause coercion to pd.NaT. However, if an error / bug is
+            # introduced that causes an Exception to be raised, we would
+            # like to surface it.
+            raise
 
     if box:
         from pandas import TimedeltaIndex
diff --git a/pandas/tests/arithmetic/test_timedelta64.py b/pandas/tests/arithmetic/test_timedelta64.py
index f92a772f3..50c0e9564 100644
--- a/pandas/tests/arithmetic/test_timedelta64.py
+++ b/pandas/tests/arithmetic/test_timedelta64.py
@@ -1054,11 +1054,11 @@ class TestTimedeltaArraylikeMulDivOps(object):
         idx = tm.box_expected(idx, box)
 
         rng5f = np.arange(5, dtype='float64')
-        expected = TimedeltaIndex(rng5f * (rng5f + 0.1))
+        expected = TimedeltaIndex(rng5f * (rng5f + 1.0))
         box2 = pd.Series if box is pd.Index else box
         expected = tm.box_expected(expected, box2)
 
-        result = idx * Series(rng5f + 0.1)
+        result = idx * Series(rng5f + 1.0)
         tm.assert_equal(result, expected)
 
     # TODO: Put Series/DataFrame in others?
diff --git a/pandas/tests/indexes/datetimes/test_construction.py b/pandas/tests/indexes/datetimes/test_construction.py
index 04b2c4f28..42a75f277 100644
--- a/pandas/tests/indexes/datetimes/test_construction.py
+++ b/pandas/tests/indexes/datetimes/test_construction.py
@@ -318,7 +318,8 @@ class TestDatetimeIndex(object):
         pytest.raises(ValueError, DatetimeIndex, start='1/1/2000',
                       end='1/10/2000')
 
-        pytest.raises(ValueError, DatetimeIndex, '1/1/2000')
+        with pytest.raises(TypeError):
+            DatetimeIndex('1/1/2000')
 
         # generator expression
         gen = (datetime(2000, 1, 1) + timedelta(i) for i in range(10))
diff --git a/pandas/tests/indexes/timedeltas/test_arithmetic.py b/pandas/tests/indexes/timedeltas/test_arithmetic.py
index a03698c9e..82337ac37 100644
--- a/pandas/tests/indexes/timedeltas/test_arithmetic.py
+++ b/pandas/tests/indexes/timedeltas/test_arithmetic.py
@@ -453,10 +453,16 @@ class TestTimedeltaIndexArithmetic(object):
         # setup
         s1 = pd.to_timedelta(Series(['00:00:01']))
         s2 = pd.to_timedelta(Series(['00:00:02']))
-        sn = pd.to_timedelta(Series([pd.NaT]))
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            # Passing datetime64-dtype data to TimedeltaIndex is deprecated
+            sn = pd.to_timedelta(Series([pd.NaT]))
+
         df1 = pd.DataFrame(['00:00:01']).apply(pd.to_timedelta)
         df2 = pd.DataFrame(['00:00:02']).apply(pd.to_timedelta)
-        dfn = pd.DataFrame([pd.NaT]).apply(pd.to_timedelta)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            # Passing datetime64-dtype data to TimedeltaIndex is deprecated
+            dfn = pd.DataFrame([pd.NaT]).apply(pd.to_timedelta)
+
         scalar1 = pd.to_timedelta('00:00:01')
         scalar2 = pd.to_timedelta('00:00:02')
         timedelta_NaT = pd.to_timedelta('NaT')
diff --git a/pandas/tests/indexes/timedeltas/test_construction.py b/pandas/tests/indexes/timedeltas/test_construction.py
index 1abda6247..074c8904b 100644
--- a/pandas/tests/indexes/timedeltas/test_construction.py
+++ b/pandas/tests/indexes/timedeltas/test_construction.py
@@ -5,11 +5,81 @@ import pytest
 
 import pandas as pd
 import pandas.util.testing as tm
-from pandas import TimedeltaIndex, timedelta_range, to_timedelta
+from pandas import TimedeltaIndex, timedelta_range, to_timedelta, Timedelta
 
 
 class TestTimedeltaIndex(object):
 
+    def test_int64_nocopy(self):
+        # GH#23539 check that a copy isn't made when we pass int64 data
+        #  and copy=False
+        arr = np.arange(10, dtype=np.int64)
+        tdi = TimedeltaIndex(arr, copy=False)
+        assert tdi._data.base is arr
+
+    def test_infer_from_tdi(self):
+        # GH#23539
+        # fast-path for inferring a frequency if the passed data already
+        #  has one
+        tdi = pd.timedelta_range('1 second', periods=10**7, freq='1s')
+
+        result = pd.TimedeltaIndex(tdi, freq='infer')
+        assert result.freq == tdi.freq
+
+        # check that inferred_freq was not called by checking that the
+        #  value has not been cached
+        assert "inferred_freq" not in getattr(result, "_cache", {})
+
+    def test_infer_from_tdi_mismatch(self):
+        # GH#23539
+        # fast-path for invalidating a frequency if the passed data already
+        #  has one and it does not match the `freq` input
+        tdi = pd.timedelta_range('1 second', periods=100, freq='1s')
+
+        msg = ("Inferred frequency .* from passed values does "
+               "not conform to passed frequency")
+        with pytest.raises(ValueError, match=msg):
+            TimedeltaIndex(tdi, freq='D')
+
+    def test_dt64_data_invalid(self):
+        # GH#23539
+        # passing tz-aware DatetimeIndex raises, naive or ndarray[datetime64]
+        #  does not yet, but will in the future
+        dti = pd.date_range('2016-01-01', periods=3)
+
+        msg = "cannot be converted to timedelta64"
+        with pytest.raises(TypeError, match=msg):
+            TimedeltaIndex(dti.tz_localize('Europe/Brussels'))
+
+        with tm.assert_produces_warning(FutureWarning):
+            TimedeltaIndex(dti)
+
+        with tm.assert_produces_warning(FutureWarning):
+            TimedeltaIndex(np.asarray(dti))
+
+    def test_float64_ns_rounded(self):
+        # GH#23539 without specifying a unit, floats are regarded as nanos,
+        #  and fractional portions are truncated
+        tdi = TimedeltaIndex([2.3, 9.7])
+        expected = TimedeltaIndex([2, 9])
+        tm.assert_index_equal(tdi, expected)
+
+        # integral floats are non-lossy
+        tdi = TimedeltaIndex([2.0, 9.0])
+        expected = TimedeltaIndex([2, 9])
+        tm.assert_index_equal(tdi, expected)
+
+        # NaNs get converted to NaT
+        tdi = TimedeltaIndex([2.0, np.nan])
+        expected = TimedeltaIndex([pd.Timedelta(nanoseconds=2), pd.NaT])
+        tm.assert_index_equal(tdi, expected)
+
+    def test_float64_unit_conversion(self):
+        # GH#23539
+        tdi = TimedeltaIndex([1.5, 2.25], unit='D')
+        expected = TimedeltaIndex([Timedelta(days=1.5), Timedelta(days=2.25)])
+        tm.assert_index_equal(tdi, expected)
+
     def test_construction_base_constructor(self):
         arr = [pd.Timedelta('1 days'), pd.NaT, pd.Timedelta('3 days')]
         tm.assert_index_equal(pd.Index(arr), pd.TimedeltaIndex(arr))
@@ -63,7 +133,8 @@ class TestTimedeltaIndex(object):
         pytest.raises(ValueError, TimedeltaIndex, start='1 days',
                       end='10 days')
 
-        pytest.raises(ValueError, TimedeltaIndex, '1 days')
+        with pytest.raises(TypeError):
+            TimedeltaIndex('1 days')
 
         # generator expression
         gen = (timedelta(i) for i in range(10))
diff --git a/pandas/tests/indexes/timedeltas/test_ops.py b/pandas/tests/indexes/timedeltas/test_ops.py
index 2fc0a49d7..989955c0d 100644
--- a/pandas/tests/indexes/timedeltas/test_ops.py
+++ b/pandas/tests/indexes/timedeltas/test_ops.py
@@ -54,8 +54,7 @@ class TestTimedeltaIndexOps(Ops):
             assert pd.isna(getattr(obj, op)())
 
     def test_numpy_minmax(self):
-        dr = pd.date_range(start='2016-01-15', end='2016-01-20')
-        td = TimedeltaIndex(np.asarray(dr))
+        td = timedelta_range('16815 days', '16820 days', freq='D')
 
         assert np.min(td) == Timedelta('16815 days')
         assert np.max(td) == Timedelta('16820 days')
diff --git a/pandas/tests/scalar/timedelta/test_arithmetic.py b/pandas/tests/scalar/timedelta/test_arithmetic.py
index 65709b0ee..79fa49b56 100644
--- a/pandas/tests/scalar/timedelta/test_arithmetic.py
+++ b/pandas/tests/scalar/timedelta/test_arithmetic.py
@@ -506,6 +506,9 @@ class TestTimedeltaMultiplicationDivision(object):
             # TODO: GH-19761. Change to TypeError.
             ser // td
 
+    # ----------------------------------------------------------------
+    # Timedelta.__mod__, __rmod__
+
     def test_mod_timedeltalike(self):
         # GH#19365
         td = Timedelta(hours=37)
@@ -545,9 +548,6 @@ class TestTimedeltaMultiplicationDivision(object):
         assert isinstance(result, Timedelta)
         assert result == Timedelta(hours=2)
 
-    # ----------------------------------------------------------------
-    # Timedelta.__mod__, __rmod__
-
     def test_mod_numeric(self):
         # GH#19365
         td = Timedelta(hours=37)

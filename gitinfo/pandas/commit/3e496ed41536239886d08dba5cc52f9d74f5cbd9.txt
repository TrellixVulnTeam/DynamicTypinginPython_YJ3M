commit 3e496ed41536239886d08dba5cc52f9d74f5cbd9
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat May 19 13:03:54 2012 -0400

    ENH: more nanosecond support #1238

diff --git a/doc/source/io.rst b/doc/source/io.rst
index 98a69ba50..caa2a8a80 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -59,7 +59,7 @@ The two workhorse functions for reading text files (a.k.a. flat files) are
 They both use the same parsing code to intelligently convert tabular
 data into a DataFrame object. They can take a number of arguments:
 
-  - ``path_or_buffer``: Either a string path to a file, or any object with a
+  - ``filepath_or_buffer``: Either a string path to a file, or any object with a
     ``read`` method (such as an open file or ``StringIO``).
   - ``sep`` or ``delimiter``: A delimiter / separator to split fields
     on. `read_csv` is capable of inferring the delimiter automatically in some
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 41b293c17..1ce05f852 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -215,7 +215,7 @@ class PandasObject(object):
         end_date = end = self.index[0] + offset
 
         # Tick-like, e.g. 3 weeks
-        if not offset.isAnchored() and hasattr(offset, 'delta'):
+        if not offset.isAnchored() and hasattr(offset, '_inc'):
             if end_date in self.index:
                 end = self.index.searchsorted(end_date, side='left')
 
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index a73a71f76..93e1ced2d 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -9,6 +9,7 @@ from cpython cimport *
 from datetime cimport *
 from util cimport is_integer_object, is_datetime64_object
 
+from datetime import timedelta
 from dateutil.parser import parse as parse_date
 cimport util
 
@@ -240,7 +241,15 @@ cdef class _Timestamp(datetime):
             else:
                 return Timestamp((self.offset.__mul__(other)).apply(self))
         else:
-            return datetime.__add__(self, other)
+            if isinstance(other, timedelta) or hasattr(other, 'delta'):
+                nanos = _delta_to_nanoseconds(other)
+                return Timestamp(self.value + nanos)
+            else:
+                result = datetime.__add__(self, other)
+                if isinstance(result, datetime):
+                    result = Timestamp(result)
+                    result.nanosecond = self.nanosecond
+                return result
 
     def __sub__(self, other):
         if is_integer_object(other):
@@ -253,6 +262,16 @@ cdef class _Timestamp(datetime):
                                   field)
         return out[0]
 
+def _delta_to_nanoseconds(delta):
+    try:
+        delta = delta.delta
+    except:
+        pass
+    return (delta.days * 24 * 60 * 60 * 1000000
+            + delta.seconds * 1000000
+            + delta.microseconds) * 1000
+
+
 # lightweight C object to hold datetime & int64 pair
 cdef class _TSObject:
     cdef:
diff --git a/pandas/tseries/offsets.py b/pandas/tseries/offsets.py
index 3db105db4..fe268003c 100644
--- a/pandas/tseries/offsets.py
+++ b/pandas/tseries/offsets.py
@@ -4,6 +4,7 @@ import numpy as np
 
 from pandas.core.common import _count_not_none
 from pandas.tseries.tools import to_datetime
+from pandas.util.decorators import cache_readonly
 
 # import after tools, dateutil check
 from dateutil.relativedelta import relativedelta
@@ -408,7 +409,7 @@ class Week(DateOffset, CacheableOffset):
                 raise Exception('Day must be 0<=day<=6, got %d' %
                                 self.weekday)
 
-        self.delta = timedelta(weeks=1)
+        self._inc = timedelta(weeks=1)
         self.kwds = kwds
 
     def isAnchored(self):
@@ -416,7 +417,7 @@ class Week(DateOffset, CacheableOffset):
 
     def apply(self, other):
         if self.weekday is None:
-            return other + self.n * self.delta
+            return other + self.n * self._inc
 
         if self.n > 0:
             k = self.n
@@ -425,14 +426,14 @@ class Week(DateOffset, CacheableOffset):
                 other = other + timedelta((self.weekday - otherDay) % 7)
                 k = k - 1
             for i in xrange(k):
-                other = other + self.delta
+                other = other + self._inc
         else:
             k = self.n
             otherDay = other.weekday()
             if otherDay != self.weekday:
                 other = other + timedelta((self.weekday - otherDay) % 7)
             for i in xrange(-k):
-                other = other - self.delta
+                other = other - self._inc
         return other
 
     def onOffset(self, dt):
@@ -919,7 +920,6 @@ class YearBegin(DateOffset, CacheableOffset):
 # Ticks
 
 class Tick(DateOffset):
-    _delta = None
     _inc = timedelta(microseconds=1000)
 
     def __add__(self, other):
@@ -955,12 +955,9 @@ class Tick(DateOffset):
         else:
             return DateOffset.__ne__(self, other)
 
-    @property
+    @cache_readonly
     def delta(self):
-        if self._delta is None:
-            self._delta = self.n * self._inc
-
-        return self._delta
+        return self.n * self._inc
 
     @property
     def nanos(self):
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index e8f78eead..1868b5617 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -1189,6 +1189,10 @@ class TestTimestamp(unittest.TestCase):
         self.assert_(other > val)
         self.assert_(other >= val)
 
+    def test_delta_preserve_nanos(self):
+        val = Timestamp(1337299200000000123L)
+        result = val + timedelta(1)
+        self.assert_(result.nanosecond == val.nanosecond)
 
 """
 

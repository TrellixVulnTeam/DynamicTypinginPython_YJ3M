commit eb36ebf95753e91ce50d55cc6ab565e886e596b9
Author: Adam Klein <adamklein@gmail.com>
Date:   Mon Mar 19 17:32:15 2012 -0400

    ENH: delete accumulated datetime cruft

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 2fa0109ab..0f3c3e2be 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -5,11 +5,12 @@ import numpy as np
 import pandas._tseries as lib
 import re
 
-from pandas._tseries import Timestamp
+from pandas._tseries import Timestamp, monthrange
 
 try:
     import dateutil
     from dateutil import parser
+    from dateutil.relativedelta import relativedelta
 
     # raise exception if dateutil 2.0 install on 2.x platform
     if (sys.version_info[0] == 2 and
@@ -20,11 +21,6 @@ except ImportError: # pragma: no cover
     print 'Please install python-dateutil via easy_install or some method!'
     raise # otherwise a 2nd import won't show the message
 
-import calendar #NOTE: replace with _tseries.monthrange
-
-# for backward compatibility
-relativedelta = lib.Delta
-
 #-------------------------------------------------------------------------------
 # Boxing and unboxing
 
@@ -78,14 +74,21 @@ class Ts(lib.Timestamp):
         ts = to_timestamp(value, freq, tzinfo)
         return lib.Timestamp.__new__(Ts, ts, freq, tzinfo)
 
-    def asinterval(self, freq):
+    @property
+    def freq(self):
+        return self.offset
+
+    def to_interval(self, freq=None):
         """
         Return an interval of which this timestamp is an observation.
         """
+        if freq == None:
+            freq = self.freq
+
         return Interval(self, freq=freq)
 
-#-------
-# Interval sketching
+#---------------
+# Interval logic
 
 def _skts_unbox(key, check=None):
     '''
@@ -328,6 +331,11 @@ class Interval:
 
         return Interval(new_ordinal, (base2, mult2))
 
+    def to_timestamp(self):
+        base, mult = _get_freq_code('S')
+        new_val = self.resample('S', 'S')
+        return Timestamp(lib.skts_ordinal_to_dt64(new_val, base, mult))
+
     @property
     def year(self):
         base, mult = self.freq
@@ -482,11 +490,16 @@ class DateParseError(Exception):
 _dtparser = parser.parser()
 
 def parse_time_string(arg):
+    from pandas.core.format import print_config
+
     if not isinstance(arg, basestring):
         return arg
 
     try:
-        parsed = _dtparser._parse(arg)
+        dayfirst = print_config.date_dayfirst
+        yearfirst = print_config.date_yearfirst
+
+        parsed = _dtparser._parse(arg, dayfirst=dayfirst, yearfirst=yearfirst)
         default = datetime(1,1,1).replace(hour=0, minute=0,
                                           second=0, microsecond=0)
         if parsed is None:
@@ -530,7 +543,7 @@ def normalize_date(dt):
 
 def _get_firstbday(wkday):
     """
-    wkday is the result of calendar.monthrange(year, month)
+    wkday is the result of monthrange(year, month)
 
     If it's a saturday or sunday, increment first business day to reflect this
     """
@@ -597,7 +610,7 @@ class DateOffset(object):
         self.n = int(n)
         self.kwds = kwds
         if len(kwds) > 0:
-            self._offset = lib.Delta(**kwds)
+            self._offset = relativedelta(**kwds)
         else:
             self._offset = timedelta(1)
 
@@ -808,17 +821,17 @@ class MonthEnd(DateOffset, CacheableOffset):
 
     def apply(self, other):
         n = self.n
-        _, days_in_month = calendar.monthrange(other.year, other.month)
+        _, days_in_month = monthrange(other.year, other.month)
         if other.day != days_in_month:
-            other = other + lib.Delta(months=-1, day=31)
+            other = other + relativedelta(months=-1, day=31)
             if n <= 0:
                 n = n + 1
-        other = other + lib.Delta(months=n, day=31)
+        other = other + relativedelta(months=n, day=31)
         return other
 
     @classmethod
     def onOffset(cls, someDate):
-        __junk, days_in_month = calendar.monthrange(someDate.year,
+        __junk, days_in_month = monthrange(someDate.year,
                                                    someDate.month)
         return someDate.day == days_in_month
 
@@ -833,12 +846,12 @@ class MonthBegin(DateOffset, CacheableOffset):
         if other.day > 1 and n <= 0: #then roll forward if n<=0
             n += 1
 
-        other = other + lib.Delta(months=n, day=1)
+        other = other + relativedelta(months=n, day=1)
         return other
 
     @classmethod
     def onOffset(cls, someDate):
-        firstDay, _ = calendar.monthrange(someDate.year, someDate.month)
+        firstDay, _ = monthrange(someDate.year, someDate.month)
         return someDate.day == (firstDay + 1)
 
 class BMonthEnd(DateOffset, CacheableOffset):
@@ -852,14 +865,14 @@ class BMonthEnd(DateOffset, CacheableOffset):
     def apply(self, other):
         n = self.n
 
-        wkday, days_in_month = calendar.monthrange(other.year, other.month)
+        wkday, days_in_month = monthrange(other.year, other.month)
         lastBDay = days_in_month - max(((wkday + days_in_month - 1) % 7) - 4, 0)
 
         if n > 0 and not other.day >= lastBDay:
             n = n - 1
         elif n <= 0 and other.day > lastBDay:
             n = n + 1
-        other = other + lib.Delta(months=n, day=31)
+        other = other + relativedelta(months=n, day=31)
 
         if other.weekday() > 4:
             other = other - BDay()
@@ -873,15 +886,15 @@ class BMonthBegin(DateOffset, CacheableOffset):
     def apply(self, other):
         n = self.n
 
-        wkday, _ = calendar.monthrange(other.year, other.month)
+        wkday, _ = monthrange(other.year, other.month)
         firstBDay = _get_firstbday(wkday)
 
         if other.day > firstBDay and n<=0:
             # as if rolled forward already
             n += 1
 
-        other = other + lib.Delta(months=n)
-        wkday, _ = calendar.monthrange(other.year, other.month)
+        other = other + relativedelta(months=n)
+        wkday, _ = monthrange(other.year, other.month)
         firstBDay = _get_firstbday(wkday)
         result = datetime(other.year, other.month, firstBDay)
         return result
@@ -989,7 +1002,7 @@ class WeekOfMonth(DateOffset, CacheableOffset):
             else:
                 months = self.n + 1
 
-        return self.getOffsetOfMonth(other + lib.Delta(months=months, day=1))
+        return self.getOffsetOfMonth(other + relativedelta(months=months, day=1))
 
     def getOffsetOfMonth(self, someDate):
         w = Week(weekday=self.weekday)
@@ -1027,7 +1040,7 @@ class BQuarterEnd(DateOffset, CacheableOffset):
     def apply(self, other):
         n = self.n
 
-        wkday, days_in_month = calendar.monthrange(other.year, other.month)
+        wkday, days_in_month = monthrange(other.year, other.month)
         lastBDay = days_in_month - max(((wkday + days_in_month - 1) % 7) - 4, 0)
 
         monthsToGo = 3 - ((other.month - self.startingMonth) % 3)
@@ -1039,7 +1052,7 @@ class BQuarterEnd(DateOffset, CacheableOffset):
         elif n <= 0 and other.day > lastBDay and monthsToGo == 0:
             n = n + 1
 
-        other = other + lib.Delta(months=monthsToGo + 3*n, day=31)
+        other = other + relativedelta(months=monthsToGo + 3*n, day=31)
 
         if other.weekday() > 4:
             other = other - BDay()
@@ -1070,7 +1083,7 @@ class BQuarterBegin(DateOffset, CacheableOffset):
         if self._normalizeFirst:
             other = normalize_date(other)
 
-        wkday, _ = calendar.monthrange(other.year, other.month)
+        wkday, _ = monthrange(other.year, other.month)
 
         firstBDay = _get_firstbday(wkday)
 
@@ -1089,8 +1102,8 @@ class BQuarterBegin(DateOffset, CacheableOffset):
             n = n - 1
 
         # get the first bday for result
-        other = other + lib.Delta(months=3*n - monthsSince)
-        wkday, _ = calendar.monthrange(other.year, other.month)
+        other = other + relativedelta(months=3*n - monthsSince)
+        wkday, _ = monthrange(other.year, other.month)
         firstBDay = _get_firstbday(wkday)
         result = datetime(other.year, other.month, firstBDay)
         return result
@@ -1118,7 +1131,7 @@ class QuarterEnd(DateOffset, CacheableOffset):
     def apply(self, other):
         n = self.n
 
-        wkday, days_in_month = calendar.monthrange(other.year, other.month)
+        wkday, days_in_month = monthrange(other.year, other.month)
 
         monthsToGo = 3 - ((other.month - self.startingMonth) % 3)
         if monthsToGo == 3:
@@ -1127,7 +1140,7 @@ class QuarterEnd(DateOffset, CacheableOffset):
         if n > 0 and not (other.day >= days_in_month and monthsToGo == 0):
             n = n - 1
 
-        other = other + lib.Delta(months=monthsToGo + 3*n, day=31)
+        other = other + relativedelta(months=monthsToGo + 3*n, day=31)
 
         return other
 
@@ -1152,7 +1165,7 @@ class QuarterBegin(DateOffset, CacheableOffset):
     def apply(self, other):
         n = self.n
 
-        wkday, days_in_month = calendar.monthrange(other.year, other.month)
+        wkday, days_in_month = monthrange(other.year, other.month)
 
         monthsSince = (other.month - self.startingMonth) % 3
 
@@ -1167,7 +1180,7 @@ class QuarterBegin(DateOffset, CacheableOffset):
             # after start, so come back an extra period as if rolled forward
             n = n + 1
 
-        other = other + lib.Delta(months=3*n - monthsSince, day=1)
+        other = other + relativedelta(months=3*n - monthsSince, day=1)
         return other
 
 
@@ -1190,7 +1203,7 @@ class BYearEnd(DateOffset, CacheableOffset):
         if self._normalizeFirst:
             other = normalize_date(other)
 
-        wkday, days_in_month = calendar.monthrange(other.year, self.month)
+        wkday, days_in_month = monthrange(other.year, self.month)
         lastBDay = (days_in_month -
                     max(((wkday + days_in_month - 1) % 7) - 4, 0))
 
@@ -1204,9 +1217,9 @@ class BYearEnd(DateOffset, CacheableOffset):
                 (other.month == self.month and other.day > lastBDay)):
                 years += 1
 
-        other = other + lib.Delta(years=years)
+        other = other + relativedelta(years=years)
 
-        _, days_in_month = calendar.monthrange(other.year, self.month)
+        _, days_in_month = monthrange(other.year, self.month)
         result = datetime(other.year, self.month, days_in_month)
 
         if result.weekday() > 4:
@@ -1233,7 +1246,7 @@ class BYearBegin(DateOffset, CacheableOffset):
         if self._normalizeFirst:
             other = normalize_date(other)
 
-        wkday, days_in_month = calendar.monthrange(other.year, self.month)
+        wkday, days_in_month = monthrange(other.year, self.month)
 
         firstBDay = _get_firstbday(wkday)
 
@@ -1250,8 +1263,8 @@ class BYearBegin(DateOffset, CacheableOffset):
                 years += 1
 
         # set first bday for result
-        other = other + lib.Delta(years = years)
-        wkday, days_in_month = calendar.monthrange(other.year, self.month)
+        other = other + relativedelta(years = years)
+        wkday, days_in_month = monthrange(other.year, self.month)
         firstBDay = _get_firstbday(wkday)
         result = datetime(other.year, self.month, firstBDay)
         return result
@@ -1274,7 +1287,7 @@ class YearEnd(DateOffset, CacheableOffset):
             other = datetime(other.year - 1, 12, 31)
             if n <= 0:
                 n = n + 1
-        other = other + lib.Delta(years=n)
+        other = other + relativedelta(years=n)
         return other
 
     @classmethod
@@ -1292,7 +1305,7 @@ class YearBegin(DateOffset, CacheableOffset):
             other = datetime(other.year, 1, 1)
             if n <= 0:
                 n = n + 1
-        other = other + lib.Delta(years = n, day=1)
+        other = other + relativedelta(years = n, day=1)
         return other
 
     @classmethod
diff --git a/pandas/core/format.py b/pandas/core/format.py
index 16ab60e0a..155f83d76 100644
--- a/pandas/core/format.py
+++ b/pandas/core/format.py
@@ -602,7 +602,8 @@ def _has_names(index):
 
 def set_printoptions(precision=None, column_space=None, max_rows=None,
                      max_columns=None, colheader_justify='right',
-                     notebook_repr_html=None):
+                     notebook_repr_html=None, 
+                     date_dayfirst=None, date_yearfirst=None):
     """
     Alter default behavior of DataFrame.toString
 
@@ -622,6 +623,10 @@ def set_printoptions(precision=None, column_space=None, max_rows=None,
     notebook_repr_html : boolean
         When True (default), IPython notebook will use html representation for
         pandas objects (if it is available).
+    date_dayfirst : boolean
+        When True, prints and parses dates with the day first, eg 20/01/2005
+    date_yearfirst : boolean
+        When True, prints and parses dates with the year first, eg 2005/01/20
     """
     if precision is not None:
         print_config.precision = precision
@@ -635,6 +640,10 @@ def set_printoptions(precision=None, column_space=None, max_rows=None,
         print_config.colheader_justify = colheader_justify
     if notebook_repr_html is not None:
         print_config.notebook_repr_html = notebook_repr_html
+    if date_dayfirst is not None:
+        print_config.date_dayfirst = date_dayfirst
+    if date_yearfirst is not None:
+        print_config.date_yearfirst = date_yearfirst
 
 def reset_printoptions():
     print_config.reset()
@@ -761,13 +770,14 @@ class _GlobalPrintConfig(object):
         self.max_columns = 0
         self.colheader_justify = 'right'
         self.notebook_repr_html = True
+        self.date_dayfirst = False
+        self.date_yearfirst = False
 
     def reset(self):
         self.__init__()
 
 print_config = _GlobalPrintConfig()
 
-
 if __name__ == '__main__':
     arr = np.array([746.03, 0.00, 5620.00, 1592.36])
     # arr = np.array([11111111.1, 1.55])
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 18b93297e..4711207e8 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -59,6 +59,10 @@ class Timestamp(_Timestamp):
 
         return ts_base
 
+    @property
+    def freq(self):
+        return self.offset
+
     def __setstate__(self, state):
         self.value = state[0]
         self.offset = state[1]
@@ -178,7 +182,8 @@ cdef convert_to_tsobject(object ts, object tzinfo=None):
         tmp = ts
         retval.value = tmp.value
         retval.dtval = tmp
-    elif isinstance(ts, Delta):
+    # fallback, does it at least have the right fields?
+    elif isinstance(ts, object):
         dts.year = ts.year
         dts.month = ts.month
         dts.day = ts.day
@@ -199,23 +204,6 @@ cdef convert_to_tsobject(object ts, object tzinfo=None):
 
     return retval
 
-#cdef convert_to_res(object res):
-#    if res == 'microsecond':
-#        return r_microsecond
-#    if res == 'second':
-#        return r_second
-#    if res == 'minute':
-#        return r_minute
-#    if res == 'hour':
-#        return r_hour
-#    if res == 'day':
-#        return r_day
-#    if res == 'month':
-#        return r_month
-#    if res == 'year':
-#        return r_year
-#    return r_invalid
-
 cdef conversion_factor(time_res res1, time_res res2):
     cdef:
         time_res min_res, max_res
@@ -595,953 +583,6 @@ cdef int64_t _count_range(_Offset offset, object end):
         offset.next()
     return i
 
-# Here's some frequency caching logic
-# ----------------------------------------------------------------------------------
-
-# cache size...
-# daily 1850-2050 takes up 73049 x 8bytes / 2**20bytes => 0.56Mb of cache. seems ok
-# double this at least, for indexer
-
-cdef class DatetimeCache:
-    """
-    Holds a array of datetimes according to some regular offset rule, along
-    with a int64 => Py_ssize_t hashtable to lookup array index values.
-    """
-    cdef:
-        object start
-        object end
-        object buf
-        object periods
-
-        _Offset offset
-        Int64HashTable indexer
-        object is_dirty
-
-        int64_t end_anchor
-
-    def __init__(self, _Offset offset, object end=None, object periods=None):
-        """
-        Note, prefer 'periods' argument over 'end' for generating range.
-        """
-
-        self.offset = offset
-        self.start = offset.ts
-        self.end = convert_to_tsobject(end)
-        self.buf = None
-        self.periods = periods
-        self.is_dirty = True
-
-    cdef rebuild(self):
-        """
-        Rebuild cache so that start and end fall within the range of
-        times generated.
-        """
-        cdef:
-            int64_t periods
-            Py_ssize_t i
-            ndarray[int64_t] buf
-
-        # TODO: minimize memory allocation by copying existing data
-
-        if self.periods is not None:
-            periods = self.periods
-            if self.buf is not None and periods < len(self.buf):
-                periods = len(self.buf)
-        else:
-            periods = self.count()
-
-        self.offset.anchor(self.start)
-        buf = _generate_range(self.offset, periods)
-
-        self.end = convert_to_tsobject(buf[-1])
-        self.buf = buf
-
-        self.offset.prev()
-        self.end_anchor = self.offset._get_anchor()
-
-        self.indexer = Int64HashTable(size_hint=periods)
-        for i in range(periods):
-            self.indexer.set_item(buf[i], i)
-
-        self.is_dirty = False
-
-    cdef int search(self, object ts, object side='left'):
-        cdef _TSObject t = convert_to_tsobject(ts)
-        return np.searchsorted(self.buf, t, side=side)
-
-    cdef set_start(self, _Offset off):
-        self.start = convert_to_tsobject(off._get_anchor())
-        self.is_dirty = True
-
-    cdef set_end(self, _Offset off):
-        self.end = off._ts()
-        self.is_dirty = True
-
-    cdef set_periods(self, object periods):
-        self.periods = periods
-        self.is_dirty = True
-
-    cdef int _lookup(self, int64_t val):
-        cdef:
-            kh_int64_t *table = self.indexer.table
-            cdef khiter_t k
-
-        k = kh_get_int64(table, val)
-        if k != table.n_buckets:
-            return table.vals[k]
-        else:
-            return -1
-
-    cpdef ndarray[int64_t] extend(self, int64_t first, int64_t last, int n=0):
-        """
-        Extend cache to at least n periods beyond first and last
-        """
-        cdef:
-            _Offset offset
-            Py_ssize_t i, j
-            int an
-
-        an = abs(n)
-        offset = self.offset
-
-        offset.anchor()
-        # if first is before current start
-        if offset._ts() > first:
-            # move back until on or just past first
-            while offset._ts() > first:
-                offset.prev()
-            # move back an additional n periods
-            for i in range(an):
-                offset.prev()
-            self.set_start(offset)
-        # if first is after current start
-        else:
-            # move forward up to n periods until on or just past first
-            for i in range(an):
-                if offset._ts() >= first:
-                    break
-                offset.next()
-            # now move back n periods
-            for i in range(an):
-                offset.prev()
-            # are we earlier than start?
-            if offset._ts() < self.start.value:
-                self.set_start(offset)
-
-        offset.anchor(self.end_anchor)
-        # if last is after current end
-        if offset._ts() < last:
-            # move forward until on or just past last
-            while offset._ts() < last:
-                offset.next()
-            # move forward an additional n periods
-            for i in range(an):
-                offset.next()
-            self.set_end(offset)
-        # if last is before current end
-        else:
-            # move back up to n periods until on or just past last
-            for i in range(an):
-                if offset._ts() <= last:
-                    break
-                offset.prev()
-            # move forward n periods
-            for j in range(an):
-                offset.next()
-            # are we further than end?
-            if offset._ts() > self.end.value:
-                self.set_end(offset)
-
-        if self.is_dirty:
-            self.rebuild()
-
-        return self.buf
-
-    # user/python-accessible methods
-
-    cpdef Py_ssize_t count(self):
-        if not self.is_dirty:
-            return len(self.buf)
-
-        self.offset.anchor(self.start)
-        return _count_range(self.offset, self.end)
-
-    cpdef lookup(self, object tslike):
-        cdef:
-            _TSObject ts = convert_to_tsobject(tslike)
-            int64_t idx
-
-        if ts.value < self.start.value:
-            self.extend(ts.value, self.end.value)
-
-        if ts.value > self.end.value:
-            self.extend(self.start.value, ts.value)
-
-        idx = self._lookup(ts.value)
-        if idx < 0:
-            raise KeyError(ts.value)
-        else:
-            return idx
-
-    cpdef ndarray[int64_t] cache(self):
-        return self.buf
-
-_DEFAULT_BEGIN = Timestamp(datetime(1850, 1, 1))
-_DEFAULT_END = Timestamp(datetime(2050, 1, 1))
-
-_tcaches = {}
-
-_months = {
-    'JAN' : 1,
-    'FEB' : 2,
-    'MAR' : 3,
-    'APR' : 4,
-    'MAY' : 5,
-    'JUN' : 6,
-    'JUL' : 7,
-    'AUG' : 8,
-    'SEP' : 9,
-    'OCT' : 10,
-    'NOV' : 11,
-    'DEC' : 12
-}
-
-_quarters = {
-    'JAN' : 0,
-    'FEB' : 1,
-    'MAR' : 2
-}
-
-_weekdays = {
-    'MON' : 0,
-    'TUE' : 1,
-    'WED' : 2,
-    'THU' : 3,
-    'FRI' : 4
-}
-
-# first two letters of frequency determines major rank for considering up- or
-# down-sampling
-_freqrank = {
-    'DA' : 5,  # upsampling
-    'WE' : 4,
-    'W@' : 3,
-    'EO' : 2,
-    'Q@' : 1,
-    'A@' : 0,  # downsampling
-}
-
-def flush_tcache(object freq):
-    if freq in _tcaches:
-        del _tcaches[freq]
-
-# TODO: missing feature, user-provided striding
-
-cpdef DatetimeCache get_tcache(freq, object first=None, object last=None):
-    """
-    Retrieve from cache (or generate, first time through) times that correspond
-    to the frequency we care about.
-
-    First and last allow overriding default cache range.
-    """
-    cdef:
-        _Offset offset
-        int64_t s, e
-        DatetimeCache tc
-
-    if first is None:
-        first = _DEFAULT_BEGIN
-
-    if last is None:
-        last  = _DEFAULT_END
-
-    if freq not in _tcaches:
-        if freq == 'WEEKDAY':
-            offset = DayOffset(stride=1, biz=1)
-
-        elif freq == 'DAILY':
-            offset = DayOffset(stride=1, biz=0)
-
-        elif freq == 'EOM':
-            offset = MonthOffset(dayoffset=-1, biz=-1)
-
-        elif freq.startswith('W@'):
-            wkd = first.weekday()
-            dow = freq[-3:]
-            if dow not in _weekdays:
-                raise ValueError('Bad weekday %s' % freq)
-            first += timedelta(days=(_weekdays[dow] - wkd) % 7)
-            offset = DayOffset(stride=7, biz=1)
-
-        elif freq.startswith('Q@'):
-            mo = freq[-3:]
-            if mo not in _quarters:
-                raise ValueError('Bad month quarter %s' % freq)
-            first += Delta(months=_quarters[mo])
-            offset = MonthOffset(dayoffset=-1, stride=3, biz=-1)
-
-        elif freq.startswith('A@'):
-            mo = freq[-3:]
-            if mo not in _months:
-                raise ValueError('Bad annual month in %s' % freq)
-            if _months[mo] < 12:
-                first += Delta(months=_months[mo])
-            offset = YearOffset(dayoffset=-1, biz=-1)
-
-        elif freq.startswith('WOM@'):
-            offset = freq.split('@')[1]
-            week = int(offset[:-3])
-            dow = offset[-3:]
-            if dow not in _weekdays:
-                raise ValueError('Bad weekday in %s' % freq)
-            offset = DayOfMonthOffset(week=week, day=_weekdays[dow])
-
-        else:
-            raise ValueError('Supplied frequency %s not implemented' % freq)
-
-        offset.anchor(first)
-        last = Timestamp(last)
-
-        _tcaches[freq] = DatetimeCache(offset, last.value)
-
-    tc = _tcaches[freq]
-
-    if tc.is_dirty:
-        tc.rebuild()
-
-    return _tcaches[freq]
-
-# Helper methods for frequency-based analysis
-# -------------------------------------------------------------
-
-@cython.wraparound(False)
-def conformity_check(ndarray[int64_t] data, object freq):
-    """
-    Return first non-conforming time, otherwise None. Also, return
-    whether all times are concecutive according to the frequency.
-    """
-    cdef:
-        Py_ssize_t i, ld, lc
-        int idx, previdx
-        object regular
-        ndarray[int64_t] cache
-        DatetimeCache tc
-
-    regular = True
-    ld = len(data)
-
-    if ld == 0:
-        return None, regular
-
-    tc = get_tcache(freq)
-    cache = tc.cache()
-
-    lc = len(cache)
-
-    # make sure cache is large enough to handle data
-    if data[0] < cache[0] or data[ld-1] > cache[lc-1]:
-        tc.extend(data[0], data[ld-1])
-
-    previdx = tc._lookup(data[0])
-    if previdx == -1:
-        return data[0], False
-
-    i = 1
-    while i < ld:
-        idx = tc._lookup(data[i])
-        if idx == -1:
-            return data[i], False
-        if previdx != (idx - 1):
-            regular = False
-        i += 1
-
-    return None, regular
-
-@cython.wraparound(False)
-cpdef ndarray[int64_t] fast_shift(ndarray[int64_t] data, object freq, int64_t n):
-    """
-    Shift times n periods according to the frequency.
-    """
-    cdef:
-        DatetimeCache tc
-        ndarray[int64_t] result, cache
-        Py_ssize_t i, ld, lc
-        int idx, s, e
-
-    ld = len(data)
-
-    tc = get_tcache(freq)
-    cache = tc.cache()
-
-    lc = len(cache)
-
-    # make sure cache is large enough to handle data
-    # plus a shift of N
-    s = cache.searchsorted(data[0])
-    e = cache.searchsorted(data[ld-1])
-
-    if (data[0] < cache[0] or s + n < 0 or
-        data[ld-1] > cache[lc-1] or e + n > lc):
-        cache = tc.extend(data[0], data[ld-1], n)
-
-    result = np.empty(ld, dtype='i8')
-    for i in range(ld):
-        idx = tc._lookup(data[i]) + n
-        if idx == -1:
-            raise ValueError("Shift hit nonconforming time %s" 
-                             % np.datetime64(data[i]))
-        result[i] = cache[idx]
-
-    return result
-
-
-# The following is derived from relativedelta.py in dateutil package
-# ------------------------------------------------------------------------------
-# Copyright (c) 2003-2010  Gustavo Niemeyer <gustavo@niemeyer.net>
-# under Simplified BSD
-
-cdef class Weekday:
-    cdef:
-        int64_t weekday, n
-
-    def __init__(self, int64_t weekday, int64_t n = INT64_MIN):
-        if weekday < 0 or weekday > 6:
-            raise ValueError("Invalid weekday: %d", weekday)
-
-        self.weekday = weekday
-        self.n = n
-
-    def __call__(self, int n):
-        if n == self.n:
-            return self
-        else:
-            return self.__class__(self.weekday, n)
-
-    def __richcmp__(self, other, int op):
-        isequal = False
-
-        if not isinstance(other, Weekday):
-            isequal = False
-        else:
-            isequal = (self.weekday == other.weekday and self.n == other.n)
-
-        if op == 2: # equals
-            return isequal
-        if op == 3: # not equals
-            return not isequal
-
-        raise NotImplementedError("Comparison not supported")
-
-    property weekday:
-        def __get__(self):
-            return self.weekday
-
-    property n:
-        def __get__(self):
-            return self.n if self.n != INT64_MIN else None
-
-    def __repr__(self):
-        s = ("MO", "TU", "WE", "TH", "FR", "SA", "SU")[self.weekday]
-        if self.n == INT64_MIN:
-            return s
-        else:
-            return "%s(%+d)" % (s, self.n)
-
-MO, TU, WE, TH, FR, SA, SU = weekdays = tuple(Weekday(x) for x in range(7))
-
-cdef class Delta:
-    """
-    There's two different ways to build a Delta instance. The
-    first one is passing it two Timestamp classes:
-
-        Delta(Timestamp1, Timestamp1)
-
-    In which case the following holds:
-
-        Timestamp1 + Delta(Timestamp1, Timestamp2) == TimeStamp2
-
-    And the other way is to use the following keyword arguments:
-
-        year, month, day, hour, minute, second, microsecond:
-            Absolute information.
-
-        years, months, weeks, days, hours, minutes, seconds, microseconds:
-            Relative information, may be negative.
-
-        weekday:
-            One of the weekday instances (MO, TU, etc). These instances may
-            receive a parameter N, specifying the Nth weekday, which could
-            be positive or negative (like MO(+1) or MO(-2). Not specifying
-            it is the same as specifying +1. You can also use an integer,
-            where 0=MO.
-
-        leapdays:
-            Will add given days to the date found, if year is a leap
-            year, and the date found is post 28 of february.
-
-        yearday, nlyearday:
-            Set the yearday or the non-leap year day (jump leap days).
-            These are converted to day/month/leapdays information.
-
-    Here is the behavior of operations with Delta:
-
-    1) Calculate the absolute year, using the 'year' argument, or the
-    original datetime year, if the argument is not present.
-
-    2) Add the relative 'years' argument to the absolute year.
-
-    3) Do steps 1 and 2 for month/months.
-
-    4) Calculate the absolute day, using the 'day' argument, or the
-    original datetime day, if the argument is not present. Then,
-    subtract from the day until it fits in the year and month
-    found after their operations.
-
-    5) Add the relative 'days' argument to the absolute day. Notice
-    that the 'weeks' argument is multiplied by 7 and added to
-    'days'.
-
-    6) Do steps 1 and 2 for hour/hours, minute/minutes, second/seconds,
-    microsecond/microseconds.
-
-    7) If the 'weekday' argument is present, calculate the weekday,
-    with the given (wday, nth) tuple. wday is the index of the
-    weekday (0-6, 0=Mon), and nth is the number of weeks to add
-    forward or backward, depending on its signal. Notice that if
-    the calculated date is already Monday, for example, using
-    (0, 1) or (0, -1) won't change the day.
-    """
-
-    cdef:
-        int64_t years, months, days, leapdays, hours, minutes, seconds, microseconds
-        int64_t year, month, day, hour, minute, second, microsecond
-        object weekday
-
-    def __init__(self,
-
-                 object ts1=None,
-                 object ts2=None,
-
-                 int64_t years=0,
-                 int64_t months=0,
-                 int64_t days=0,
-                 int64_t leapdays=0,
-                 int64_t weeks=0,
-                 int64_t hours=0,
-                 int64_t minutes=0,
-                 int64_t seconds=0,
-                 int64_t microseconds=0,
-
-                 int64_t year=-1,
-                 int64_t month=-1,
-                 int64_t day=-1,
-                 int64_t yearday=-1,
-                 int64_t nlyearday=-1,
-                 int64_t hour=-1,
-                 int64_t minute=-1,
-                 int64_t second=-1,
-                 int64_t microsecond=-1,
-
-                 object weekday=None):
-
-        if ts1 and ts2:
-            if not (isinstance(ts1, Timestamp) and isinstance(ts2, Timestamp)):
-                raise TypeError("Delta only diffs Timestamp")
-
-            self.years = 0
-            self.months = 0
-            self.days = 0
-            self.leapdays = 0
-            self.hours = 0
-            self.minutes = 0
-            self.seconds = 0
-            self.microseconds = 0
-
-            self.year = -1
-            self.month = -1
-            self.day = -1
-            self.hour = -1
-            self.minute = -1
-            self.second = -1
-            self.microsecond = -1
-            self.weekday = None
-
-            # difference in months
-            months = (ts1.year * 12 + ts1.month) - (ts2.year * 12 + ts2.month)
-            self._set_months(months)
-
-            # add ourself (delta) to ts2
-            dtm = self.__add__(ts2)
-
-            if ts1 < ts2:
-                while ts1 > dtm:
-                    months += 1
-                    self._set_months(months)
-                    dtm = self.__add__(ts2)
-            else:
-                while ts1 < dtm:
-                    months -= 1
-                    self._set_months(months)
-                    dtm = self.__add__(ts2)
-            delta = ts1 - dtm
-            self.seconds = delta.seconds + delta.days * 86400
-            self.microseconds = delta.microseconds
-        else:
-            self.years = years
-            self.months = months
-            self.days = days + weeks * 7
-            self.leapdays = leapdays
-            self.hours = hours
-            self.minutes = minutes
-            self.seconds = seconds
-            self.microseconds = microseconds
-
-            self.year = year
-            self.month = month
-            self.day = day
-            self.hour = hour
-            self.minute = minute
-            self.second = second
-            self.microsecond = microsecond
-
-            if isinstance(weekday, Weekday):
-                self.weekday = weekday
-            elif isinstance(weekday, type(None)):
-                self.weekday = None
-            else:
-                self.weekday = weekdays[weekday]
-
-            yday = 0
-            if nlyearday != -1:
-                yday = nlyearday
-            elif yearday != -1:
-                yday = yearday
-                if yearday > 59:
-                    self.leapdays = -1
-            if yday:
-                ydayidx = [31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,
-                           366]
-                for idx, ydays in enumerate(ydayidx):
-                    if yday <= ydays:
-                        self.month = idx + 1
-                        if idx == 0:
-                            self.day = yday
-                        else:
-                            self.day = yday - ydayidx[idx-1]
-                        break
-                else:
-                    raise ValueError("invalid year day (%d)" % yday)
-
-        self._fix()
-
-    def _fix(self):
-        if abs(self.microseconds) > 999999:
-            s = self.microseconds//abs(self.microseconds)
-            div, mod = divmod(self.microseconds*s, 1000000)
-            self.microseconds = mod*s
-            self.seconds += div*s
-        if abs(self.seconds) > 59:
-            s = self.seconds//abs(self.seconds)
-            div, mod = divmod(self.seconds*s, 60)
-            self.seconds = mod*s
-            self.minutes += div*s
-        if abs(self.minutes) > 59:
-            s = self.minutes//abs(self.minutes)
-            div, mod = divmod(self.minutes*s, 60)
-            self.minutes = mod*s
-            self.hours += div*s
-        if abs(self.hours) > 23:
-            s = self.hours//abs(self.hours)
-            div, mod = divmod(self.hours*s, 24)
-            self.hours = mod*s
-            self.days += div*s
-        if abs(self.months) > 11:
-            s = self.months//abs(self.months)
-            div, mod = divmod(self.months*s, 12)
-            self.months = mod*s
-            self.years += div*s
-
-    def _set_months(self, months):
-        self.months = months
-        if abs(self.months) > 11:
-            s = self.months//abs(self.months)
-            div, mod = divmod(self.months*s, 12)
-            self.months = mod*s
-            self.years = div*s
-        else:
-            self.years = 0
-
-    def __add__(self, other):
-        if not isinstance(self, Delta):
-            tmp = self
-            self = other
-            other = tmp
-
-        if isinstance(other, Delta):
-            return self._add_delta(other)
-
-        if isinstance(other, Timestamp):
-            return self._add_timestamp(other)
-
-        if isinstance(other, datetime):
-            return self._add_timestamp(Timestamp(other))
-
-        raise ValueError("Cannot add to Delta")
-
-    def _add_timestamp(self, other):
-        year = (self.year if self.year != -1 else other.year) + self.years
-        month = (self.month if self.month != -1 else other.month)
-
-        if self.months:
-            assert 1 <= abs(self.months) <= 12
-            month += self.months
-            if month > 12:
-                year += 1
-                month -= 12
-            elif month < 1:
-                year -= 1
-                month += 12
-        day = min(monthrange(year, month)[1],
-                  self.day if self.day != -1 else other.day)
-        repl = {"year": year, "month": month, "day": day}
-        for attr in ["hour", "minute", "second", "microsecond"]:
-            value = getattr(self, attr)
-            if value != -1:
-                repl[attr] = value
-        days = self.days
-        if self.leapdays and month > 2 and isleapyear(year):
-            days += self.leapdays
-        ret = (other.replace(**repl)
-               + timedelta(days=days,
-                           hours=self.hours,
-                           minutes=self.minutes,
-                           seconds=self.seconds,
-                           microseconds=self.microseconds))
-        if self.weekday:
-            weekday, nth = self.weekday.weekday, (self.weekday.n or 1)
-
-            jumpdays = (abs(nth)-1)*7
-            if nth > 0:
-                jumpdays += (7-ret.weekday()+weekday)%7
-            else:
-                jumpdays += (ret.weekday()-weekday)%7
-                jumpdays *= -1
-            ret += timedelta(days=jumpdays)
-
-        return Timestamp(ret)
-
-    def __richcmp__(self, other, op):
-        if op == 3:
-            return not (self == other)
-        elif op == 2:
-            if not isinstance(other, Delta):
-                return False
-            if self.weekday or other.weekday:
-                if not self.weekday or not other.weekday:
-                    return False
-                if self.weekday.weekday != other.weekday.weekday:
-                    return False
-                n1, n2 = self.weekday.n, other.weekday.n
-                if n1 != n2 and not ((not n1 or n1 == 1) and (not n2 or n2 == 1)):
-                    return False
-            return (self.years == other.years and
-                    self.months == other.months and
-                    self.days == other.days and
-                    self.hours == other.hours and
-                    self.minutes == other.minutes and
-                    self.seconds == other.seconds and
-                    self.leapdays == other.leapdays and
-                    self.year == other.year and
-                    self.month == other.month and
-                    self.day == other.day and
-                    self.hour == other.hour and
-                    self.minute == other.minute and
-                    self.second == other.second and
-                    self.microsecond == other.microsecond)
-        else:
-            raise NotImplementedError("Delta doesn't implement that comparison")
-
-    def _add_delta(self, other):
-        if not isinstance(self, Delta):
-            tmp = self
-            self = other
-            other = tmp
-
-        return Delta(years=other.years+self.years,
-                    months=other.months+self.months,
-                    days=other.days+self.days,
-                    hours=other.hours+self.hours,
-                    minutes=other.minutes+self.minutes,
-                    seconds=other.seconds+self.seconds,
-                    microseconds=other.microseconds+self.microseconds,
-                    leapdays=other.leapdays if other.leapdays != -1 else self.leapdays,
-                    year=other.year if other.year != -1 else self.year,
-                    month=other.month if other.month != -1 else self.month,
-                    day=other.day if other.day != -1 else self.day,
-                    weekday=other.weekday or self.weekday,
-                    hour=other.hour if other.hour != -1 else self.hour,
-                    minute=other.minute if other.minute != -1 else self.minute,
-                    second=other.second if other.second != -1 else self.second,
-                    microsecond=(other.microsecond if other.microsecond != -1
-                                                    else self.microsecond))
-
-
-    def __sub__(self, other):
-        if not isinstance(self, Delta):
-            tmp = self
-            self = other
-            other = tmp
-
-        if isinstance(other, Delta):
-            return self._sub_delta(other)
-        else:
-            return self.__neg__().__add__(other)
-
-    def _sub_delta(self, other):
-        return Delta(years=other.years-self.years,
-                    months=other.months-self.months,
-                    days=other.days-self.days,
-                    hours=other.hours-self.hours,
-                    minutes=other.minutes-self.minutes,
-                    seconds=other.seconds-self.seconds,
-                    microseconds=other.microseconds-self.microseconds,
-                    leapdays=other.leapdays if other.leapdays != -1 else self.leapdays,
-                    year=other.year if other.year != -1 else self.year,
-                    month=other.month if other.month != -1 else self.month,
-                    day=other.day if other.day != -1 else self.day,
-                    weekday=other.weekday or self.weekday,
-                    hour=other.hour if other.hour != -1 else self.hour,
-                    minute=other.minute if other.minute != -1 else self.minute,
-                    second=other.second if other.second != -1 else self.second,
-                    microsecond=(other.microsecond if other.microsecond != -1
-                                                    else self.microsecond))
-
-    def __neg__(self):
-        return Delta(years=-self.years,
-                     months=-self.months,
-                     days=-self.days,
-                     hours=-self.hours,
-                     minutes=-self.minutes,
-                     seconds=-self.seconds,
-                     microseconds=-self.microseconds,
-                     leapdays=self.leapdays,
-                     year=self.year,
-                     month=self.month,
-                     day=self.day,
-                     weekday=self.weekday,
-                     hour=self.hour,
-                     minute=self.minute,
-                     second=self.second,
-                     microsecond=self.microsecond)
-
-
-    def __mul__(self, v):
-        cdef int64_t f
-
-        if not isinstance(self, Delta):
-            tmp = self
-            self = v
-            v = tmp
-
-        f = v
-
-        return Delta(years=self.years*f,
-                     months=self.months*f,
-                     days=self.days*f,
-                     hours=self.hours*f,
-                     minutes=self.minutes*f,
-                     seconds=self.seconds*f,
-                     microseconds=self.microseconds*f,
-                     leapdays=self.leapdays,
-                     year=self.year,
-                     month=self.month,
-                     day=self.day,
-                     weekday=self.weekday,
-                     hour=self.hour,
-                     minute=self.minute,
-                     second=self.second,
-                     microsecond=self.microsecond)
-
-    def __repr__(self):
-        l = []
-        for attr in ["years", "months", "days", "leapdays",
-                     "hours", "minutes", "seconds", "microseconds"]:
-            value = getattr(self, attr)
-            if value:
-                l.append("%s=%+d" % (attr, value))
-        for attr in ["year", "month", "day", "weekday",
-                     "hour", "minute", "second", "microsecond"]:
-            value = getattr(self, attr)
-            if value != -1:
-                l.append("%s=%s" % (attr, value))
-        return "%s(%s)" % (self.__class__.__name__, ", ".join(l))
-
-    property year:
-        def __get__(self):
-            return self.year
-
-    property month:
-        def __get__(self):
-            return self.month
-
-    property day:
-        def __get__(self):
-            return self.day
-
-    property weekday:
-        def __get__(self):
-            return self.weekday
-
-    property hour:
-        def __get__(self):
-            return self.hour
-
-    property minute:
-        def __get__(self):
-            return self.minute
-
-    property second:
-        def __get__(self):
-            return self.second
-
-    property microsecond:
-        def __get__(self):
-            return self.microsecond
-
-    property years:
-        def __get__(self):
-            return self.years
-
-    property months:
-        def __get__(self):
-            return self.months
-
-    property days:
-        def __get__(self):
-            return self.days
-
-    property leapdays:
-        def __get__(self):
-            return self.leapdays
-
-    property hours:
-        def __get__(self):
-            return self.hours
-
-    property minutes:
-        def __get__(self):
-            return self.minutes
-
-    property seconds:
-        def __get__(self):
-            return self.seconds
-
-    property microseconds:
-        def __get__(self):
-            return self.microseconds
-
-# End derivation from dateutil
-
 # Conversion routines
 # ------------------------------------------------------------------------------
 
diff --git a/pandas/tests/test_datetime64.py b/pandas/tests/test_datetime64.py
index 4b7a44897..b57425d77 100644
--- a/pandas/tests/test_datetime64.py
+++ b/pandas/tests/test_datetime64.py
@@ -275,28 +275,6 @@ class TestDatetime64(unittest.TestCase):
                              periods=98)
         self.assert_( len(dti1.diff(dti2)) == 2)
 
-    def test_datetimecache(self):
-        lib.flush_tcache('W@TUE')
-
-        tc = lib.get_tcache('W@TUE', first = datetime(2004,1,6),
-                            last = datetime(2004,12,28))
-        cache = tc.cache()
-
-        self.assert_(lib.Timestamp(cache[0]) == datetime(2004,1,6))
-        self.assert_(lib.Timestamp(cache[-1]) == datetime(2004,12,28))
-
-        cache = tc.extend(cache[0], cache[-1], 1)
-
-        self.assert_(lib.Timestamp(cache[0]) == datetime(2003,12,30))
-        self.assert_(lib.Timestamp(cache[-1]) == datetime(2005,1,4))
-
-        cache = tc.extend(cache[0], cache[-1], 1)
-
-        self.assert_(lib.Timestamp(cache[0]) == datetime(2003,12,23))
-        self.assert_(lib.Timestamp(cache[-1]) == datetime(2005,1,11))
-
-        lib.flush_tcache('W@TUE')
-
     def test_fancy_getitem(self):
         dti = DatetimeIndex(freq='WOM@1FRI', start=datetime(2005,1,1),
                             end=datetime(2010,1,1))
diff --git a/pandas/tests/test_datetools.py b/pandas/tests/test_datetools.py
index f056a22b3..94f65b2bd 100644
--- a/pandas/tests/test_datetools.py
+++ b/pandas/tests/test_datetools.py
@@ -13,7 +13,7 @@ from pandas.core.datetools import (
 from nose.tools import assert_raises
 
 import pandas._tseries as lib
-from pandas._tseries import Timestamp, Delta
+from pandas._tseries import Timestamp
 
 def test_monthrange():
     import calendar
@@ -104,32 +104,6 @@ class TestDateOffset(unittest.TestCase):
         self.assert_(offset1 != offset2)
         self.assert_(not (offset1 == offset2))
 
-class TestDelta(unittest.TestCase):
-
-    def setUp(self):
-        self.d = Timestamp(datetime(2008, 1, 2))
-
-    def test_repr(self):
-        repr(Delta())
-        repr(Delta(2))
-        repr(2 * Delta())
-        repr(2 * Delta(months=2))
-
-    def test_mul(self):
-        assert Delta(days=2) == 2 * Delta(days=1)
-        assert Delta(days=2) == Delta(days=1) * 2
-
-    def test_constructor(self):
-
-        assert((self.d + Delta(months=2)) == Timestamp(datetime(2008, 3, 2)))
-        assert((self.d - Delta(months=2)) == Timestamp(datetime(2007, 11, 2)))
-
-        assert((self.d + Delta(days=2)) == Timestamp(datetime(2008, 1, 4)))
-
-        d = Timestamp(datetime(2008, 1, 31))
-        assert((d + Delta(months=1)) == Timestamp(datetime(2008, 2, 29)))
-
-
 class TestBusinessDay(unittest.TestCase):
 
     def setUp(self):

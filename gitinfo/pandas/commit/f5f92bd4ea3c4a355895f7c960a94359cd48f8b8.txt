commit f5f92bd4ea3c4a355895f7c960a94359cd48f8b8
Author: jniznan <jurajniznan@gmail.com>
Date:   Sun Jun 9 20:07:21 2013 +0200

    ENH: DataFrame.corr(method='spearman') is cythonized.

diff --git a/pandas/algos.pyx b/pandas/algos.pyx
index 836101eca..e30e69df6 100644
--- a/pandas/algos.pyx
+++ b/pandas/algos.pyx
@@ -997,6 +997,72 @@ def nancorr(ndarray[float64_t, ndim=2] mat, cov=False, minp=None):
 
     return result
 
+#----------------------------------------------------------------------
+# Pairwise Spearman correlation
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def nancorr_spearman(ndarray[float64_t, ndim=2] mat, minp=None):
+    cdef:
+        Py_ssize_t i, j, xi, yi, N, K
+        ndarray[float64_t, ndim=2] result
+        ndarray[float64_t, ndim=1] maskedx
+        ndarray[float64_t, ndim=1] maskedy
+        ndarray[uint8_t, ndim=2] mask
+        int64_t nobs = 0
+        float64_t vx, vy, sumx, sumxx, sumyy, mean, divisor
+
+    N, K = (<object> mat).shape
+
+    if minp is None:
+        minp = 1
+
+    result = np.empty((K, K), dtype=np.float64)
+    mask = np.isfinite(mat).view(np.uint8)
+
+    for xi in range(K):
+        for yi in range(xi + 1):
+            nobs = 0
+            for i in range(N):
+                if mask[i, xi] and mask[i, yi]:
+                    nobs += 1
+
+            if nobs < minp:
+                result[xi, yi] = result[yi, xi] = np.NaN
+            else:
+                maskedx = np.empty(nobs, dtype=np.float64)
+                maskedy = np.empty(nobs, dtype=np.float64)
+                j = 0
+                for i in range(N):
+                    if mask[i, xi] and mask[i, yi]:
+                        maskedx[j] = mat[i, xi]
+                        maskedy[j] = mat[i, yi]
+                        j += 1
+                maskedx = rank_1d_float64(maskedx)
+                maskedy = rank_1d_float64(maskedy)
+
+                mean = (nobs + 1) / 2.
+
+                # now the cov numerator
+                sumx = sumxx = sumyy = 0
+
+                for i in range(nobs):
+                    vx = maskedx[i] - mean
+                    vy = maskedy[i] - mean
+
+                    sumx += vx * vy
+                    sumxx += vx * vx
+                    sumyy += vy * vy
+
+                divisor = sqrt(sumxx * sumyy)
+
+                if divisor != 0:
+                    result[xi, yi] = result[yi, xi] = sumx / divisor
+                else:
+                    result[xi, yi] = result[yi, xi] = np.NaN
+
+    return result
+
 #----------------------------------------------------------------------
 # Rolling variance
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 5e3d3e95d..5a5ad2019 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1528,7 +1528,7 @@ class DataFrame(NDFrame):
         from pandas.io.stata import StataWriter
         writer = StataWriter(fname,self,convert_dates=convert_dates, encoding=encoding, byteorder=byteorder)
         writer.write_file()
-        
+
     def to_sql(self, name, con, flavor='sqlite', if_exists='fail', **kwargs):
         """
         Write records stored in a DataFrame to a SQL database.
@@ -4724,7 +4724,7 @@ class DataFrame(NDFrame):
         min_periods : int, optional
             Minimum number of observations required per pair of columns
             to have a valid result. Currently only available for pearson
-            correlation
+            and spearman correlation
 
         Returns
         -------
@@ -4737,6 +4737,9 @@ class DataFrame(NDFrame):
         if method == 'pearson':
             correl = _algos.nancorr(com._ensure_float64(mat),
                                     minp=min_periods)
+        elif method == 'spearman':
+            correl = _algos.nancorr_spearman(com._ensure_float64(mat),
+                                             minp=min_periods)
         else:
             if min_periods is None:
                 min_periods = 1

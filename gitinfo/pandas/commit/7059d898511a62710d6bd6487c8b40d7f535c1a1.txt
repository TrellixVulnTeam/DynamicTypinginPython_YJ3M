commit 7059d898511a62710d6bd6487c8b40d7f535c1a1
Author: funnycrab <funnycrabneverfail@gmail.com>
Date:   Mon Apr 3 08:41:29 2017 -0400

    BUG: Fix rollover handling in json encoding
    
    closes #15716
    closes #15864
    
    whenever the frac is incremented, there is a chance that its  value
    may hit the value of pow10.
    
    Author: funnycrab <funnycrabneverfail@gmail.com>
    Author: Funnycrab <Funnycrab>
    
    Closes #15865 from funnycrab/fix_rollover_handling_in_json_enc and squashes the following commits:
    
    c9710ee [funnycrab] add more tests for examples listed in issue #15716 and #15864
    3cee6b3 [funnycrab] add whatsnew entry
    9b0dff0 [funnycrab] remove additional blank line
    75effb4 [funnycrab] add tests
    6acb969 [funnycrab] fix for cpplint
    aec58e6 [Funnycrab] BUG: Fix rollover handling in json encoding

diff --git a/doc/source/whatsnew/v0.20.0.txt b/doc/source/whatsnew/v0.20.0.txt
index ceb8f0f5f..63aea96ef 100644
--- a/doc/source/whatsnew/v0.20.0.txt
+++ b/doc/source/whatsnew/v0.20.0.txt
@@ -1010,6 +1010,7 @@ I/O
 - Bug in ``pd.read_hdf()`` passing a ``Timestamp`` to the ``where`` parameter with a non date column (:issue:`15492`)
 - Bug in ``DataFrame.to_stata()`` and ``StataWriter`` which produces incorrectly formatted files to be produced for some locales (:issue:`13856`)
 - Bug in ``StataReader`` and ``StataWriter`` which allows invalid encodings (:issue:`15723`)
+- Bug in ``pd.to_json()`` for the C engine where rollover was not correctly handled for case where frac is odd and diff is exactly 0.5 (:issue:`15716`, :issue:`15864`)
 
 Plotting
 ^^^^^^^^
diff --git a/pandas/_libs/src/ujson/lib/ultrajsonenc.c b/pandas/_libs/src/ujson/lib/ultrajsonenc.c
index 5a1507193..6bf229774 100644
--- a/pandas/_libs/src/ujson/lib/ultrajsonenc.c
+++ b/pandas/_libs/src/ujson/lib/ultrajsonenc.c
@@ -823,17 +823,19 @@ int Buffer_AppendDoubleUnchecked(JSOBJ obj, JSONObjectEncoder *enc,
 
     if (diff > 0.5) {
         ++frac;
-        /* handle rollover, e.g.  case 0.99 with prec 1 is 1.0  */
-        if (frac >= pow10) {
-            frac = 0;
-            ++whole;
-        }
     } else if (diff == 0.5 && ((frac == 0) || (frac & 1))) {
         /* if halfway, round up if odd, OR
         if last digit is 0.  That last part is strange */
         ++frac;
     }
 
+    // handle rollover, e.g.
+    // case 0.99 with prec 1 is 1.0 and case 0.95 with prec is 1.0 as well
+    if (frac >= pow10) {
+        frac = 0;
+        ++whole;
+    }
+
     if (enc->doublePrecision == 0) {
         diff = value - whole;
 
diff --git a/pandas/tests/io/json/test_pandas.py b/pandas/tests/io/json/test_pandas.py
index 7dbcf25c6..8fc8ecbdf 100644
--- a/pandas/tests/io/json/test_pandas.py
+++ b/pandas/tests/io/json/test_pandas.py
@@ -380,6 +380,31 @@ class TestPandasContainer(tm.TestCase):
         unser = read_json(df.to_json(), dtype=False)
         self.assertTrue(np.isnan(unser[2][0]))
 
+    def test_frame_to_json_float_precision(self):
+        df = pd.DataFrame([dict(a_float=0.95)])
+        encoded = df.to_json(double_precision=1)
+        self.assertEqual(encoded, '{"a_float":{"0":1.0}}')
+
+        df = pd.DataFrame([dict(a_float=1.95)])
+        encoded = df.to_json(double_precision=1)
+        self.assertEqual(encoded, '{"a_float":{"0":2.0}}')
+
+        df = pd.DataFrame([dict(a_float=-1.95)])
+        encoded = df.to_json(double_precision=1)
+        self.assertEqual(encoded, '{"a_float":{"0":-2.0}}')
+
+        df = pd.DataFrame([dict(a_float=0.995)])
+        encoded = df.to_json(double_precision=2)
+        self.assertEqual(encoded, '{"a_float":{"0":1.0}}')
+
+        df = pd.DataFrame([dict(a_float=0.9995)])
+        encoded = df.to_json(double_precision=3)
+        self.assertEqual(encoded, '{"a_float":{"0":1.0}}')
+
+        df = pd.DataFrame([dict(a_float=0.99999999999999944)])
+        encoded = df.to_json(double_precision=15)
+        self.assertEqual(encoded, '{"a_float":{"0":1.0}}')
+
     def test_frame_to_json_except(self):
         df = DataFrame([1, 2, 3])
         self.assertRaises(ValueError, df.to_json, orient="garbage")
diff --git a/pandas/tests/io/json/test_ujson.py b/pandas/tests/io/json/test_ujson.py
index e66721bee..c2cbbe1ca 100644
--- a/pandas/tests/io/json/test_ujson.py
+++ b/pandas/tests/io/json/test_ujson.py
@@ -43,6 +43,48 @@ class UltraJSONTests(TestCase):
         decoded = ujson.decode(encoded)
         self.assertEqual(decoded, 1337.1337)
 
+        sut = decimal.Decimal("0.95")
+        encoded = ujson.encode(sut, double_precision=1)
+        self.assertEqual(encoded, "1.0")
+        decoded = ujson.decode(encoded)
+        self.assertEqual(decoded, 1.0)
+
+        sut = decimal.Decimal("0.94")
+        encoded = ujson.encode(sut, double_precision=1)
+        self.assertEqual(encoded, "0.9")
+        decoded = ujson.decode(encoded)
+        self.assertEqual(decoded, 0.9)
+
+        sut = decimal.Decimal("1.95")
+        encoded = ujson.encode(sut, double_precision=1)
+        self.assertEqual(encoded, "2.0")
+        decoded = ujson.decode(encoded)
+        self.assertEqual(decoded, 2.0)
+
+        sut = decimal.Decimal("-1.95")
+        encoded = ujson.encode(sut, double_precision=1)
+        self.assertEqual(encoded, "-2.0")
+        decoded = ujson.decode(encoded)
+        self.assertEqual(decoded, -2.0)
+
+        sut = decimal.Decimal("0.995")
+        encoded = ujson.encode(sut, double_precision=2)
+        self.assertEqual(encoded, "1.0")
+        decoded = ujson.decode(encoded)
+        self.assertEqual(decoded, 1.0)
+
+        sut = decimal.Decimal("0.9995")
+        encoded = ujson.encode(sut, double_precision=3)
+        self.assertEqual(encoded, "1.0")
+        decoded = ujson.decode(encoded)
+        self.assertEqual(decoded, 1.0)
+
+        sut = decimal.Decimal("0.99999999999999944")
+        encoded = ujson.encode(sut, double_precision=15)
+        self.assertEqual(encoded, "1.0")
+        decoded = ujson.decode(encoded)
+        self.assertEqual(decoded, 1.0)
+
     def test_encodeStringConversion(self):
         input = "A string \\ / \b \f \n \r \t </script> &"
         not_html_encoded = ('"A string \\\\ \\/ \\b \\f \\n '

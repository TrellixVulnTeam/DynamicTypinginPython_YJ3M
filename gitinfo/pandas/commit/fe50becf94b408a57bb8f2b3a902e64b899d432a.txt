commit fe50becf94b408a57bb8f2b3a902e64b899d432a
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Sep 5 16:37:58 2011 -0400

    ENH: indexing object with MultiIndex works if indexing the top level. address GH #120

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 029fb6ac5..96c1dacfa 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -793,12 +793,16 @@ class DataFrame(NDFrame):
 
     def _getitem_multilevel(self, key):
         loc = self.columns.get_loc(key)
-        if isinstance(loc, slice):
+        if isinstance(loc, (slice, np.ndarray)):
             new_columns = self.columns[loc]
-            new_columns = _maybe_droplevels(new_columns, key)
-            new_values = self.values[:, loc]
-            result = DataFrame(new_values, index=self.index,
-                               columns=new_columns)
+            result_columns = _maybe_droplevels(new_columns, key)
+            if self._is_mixed_type:
+                result = self.reindex(columns=new_columns)
+                result.columns = result_columns
+            else:
+                new_values = self.values[:, loc]
+                result = DataFrame(new_values, index=self.index,
+                                   columns=result_columns)
             return result
         else:
             return self._getitem_single(key)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 98e423407..dea293b2e 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -965,11 +965,13 @@ class MultiIndex(Index):
             labels = self.labels[0]
             loc = level.get_loc(key)
 
-            assert(self.lexsort_depth >= 1)
-
-            i = labels.searchsorted(loc, side='left')
-            j = labels.searchsorted(loc, side='right')
-            return slice(i, j)
+            if self.lexsort_depth == 0:
+                return labels == loc
+            else:
+                # sorted, so can return slice object -> view
+                i = labels.searchsorted(loc, side='left')
+                j = labels.searchsorted(loc, side='right')
+                return slice(i, j)
 
     def _get_tuple_loc(self, tup):
         indexer = self._get_label_key(tup)
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index fc93190f3..454dea559 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -438,7 +438,8 @@ class BlockManager(object):
 
         new_axes = list(self.axes)
 
-        if isinstance(loc, slice):
+        # could be an array indexer!
+        if isinstance(loc, (slice, np.ndarray)):
             new_axes[axis] = new_axes[axis][loc]
         else:
             new_axes.pop(axis)
diff --git a/pandas/core/series.py b/pandas/core/series.py
index f7dda6529..55a0e3c9a 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -271,7 +271,7 @@ copy : boolean, default False
         values = self.values
         try:
             loc = self.index.get_loc(key)
-            if isinstance(loc, slice):
+            if isinstance(loc, (slice, np.ndarray)):
                 # TODO: what if a level contains tuples??
                 new_index = self.index[loc]
                 new_index = _maybe_droplevels(new_index, key)
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index a83996a3a..9c6ab511e 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -276,7 +276,39 @@ class TestMultiLevel(unittest.TestCase):
     def test_frame_getitem_not_sorted(self):
         df = self.frame.T
         df['foo', 'four'] = 'foo'
-        self.assertRaises(Exception, df.__getitem__, 'foo')
+
+        arrays = [np.array(x) for x in zip(*df.columns.get_tuple_index())]
+
+        result = df['foo']
+        result2 = df.ix[:, 'foo']
+        expected = df.reindex(columns=df.columns[arrays[0] == 'foo'])
+        expected.columns = expected.columns.droplevel(0)
+        assert_frame_equal(result, expected)
+        assert_frame_equal(result2, expected)
+
+        df = df.T
+        result = df.xs('foo')
+        result2 = df.ix['foo']
+        expected = df.reindex(df.index[arrays[0] == 'foo'])
+        expected.index = expected.index.droplevel(0)
+        assert_frame_equal(result, expected)
+        assert_frame_equal(result2, expected)
+
+    def test_series_getitem_not_sorted(self):
+        arrays = [['bar', 'bar', 'baz', 'baz', 'qux', 'qux', 'foo', 'foo'],
+        ['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two']]
+        tuples = zip(*arrays)
+        index = MultiIndex.from_tuples(tuples)
+        s = Series(randn(8), index=index)
+
+        arrays = [np.array(x) for x in zip(*index.get_tuple_index())]
+
+        result = s['qux']
+        result2 = s.ix['qux']
+        expected = s[arrays[0] == 'qux']
+        expected.index = expected.index.droplevel(0)
+        assert_series_equal(result, expected)
+        assert_series_equal(result2, expected)
 
 if __name__ == '__main__':
 

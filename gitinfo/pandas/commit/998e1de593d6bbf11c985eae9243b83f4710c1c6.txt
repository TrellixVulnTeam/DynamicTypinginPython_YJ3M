commit 998e1de593d6bbf11c985eae9243b83f4710c1c6
Author: h-vetinari <33685575+h-vetinari@users.noreply.github.com>
Date:   Thu Mar 14 16:52:00 2019 +0100

    Fixturize tests/frame/test_operators.py (#25641)

diff --git a/pandas/tests/frame/test_operators.py b/pandas/tests/frame/test_operators.py
index e9521fa15..9707ae80e 100644
--- a/pandas/tests/frame/test_operators.py
+++ b/pandas/tests/frame/test_operators.py
@@ -13,7 +13,7 @@ from pandas.compat import range
 import pandas as pd
 from pandas import DataFrame, MultiIndex, Series, compat
 import pandas.core.common as com
-from pandas.tests.frame.common import TestData, _check_mixed_float
+from pandas.tests.frame.common import _check_mixed_float
 import pandas.util.testing as tm
 from pandas.util.testing import (
     assert_frame_equal, assert_numpy_array_equal, assert_series_equal)
@@ -207,7 +207,7 @@ class TestDataFrameLogicalOperators(object):
         assert_series_equal(result, expected)
 
 
-class TestDataFrameOperators(TestData):
+class TestDataFrameOperators(object):
 
     @pytest.mark.parametrize('op', [operator.add, operator.sub,
                                     operator.mul, operator.truediv])
@@ -238,9 +238,9 @@ class TestDataFrameOperators(TestData):
                                         ('__ne__', True)])
     # TODO: not sure what's correct here.
     @pytest.mark.filterwarnings("ignore:elementwise:FutureWarning")
-    def test_logical_typeerror_with_non_valid(self, op, res):
+    def test_logical_typeerror_with_non_valid(self, op, res, float_frame):
         # we are comparing floats vs a string
-        result = getattr(self.frame, op)('foo')
+        result = getattr(float_frame, op)('foo')
         assert bool(result.all().all()) is res
 
     def test_binary_ops_align(self):
@@ -318,16 +318,17 @@ class TestDataFrameOperators(TestData):
         exp = DataFrame({'A': [np.nan, 3, np.nan]}, index=base)
         assert_frame_equal(df1 + df2, exp)
 
-    def test_combineFrame(self):
-        frame_copy = self.frame.reindex(self.frame.index[::2])
+    def test_combineFrame(self, float_frame, mixed_float_frame,
+                          mixed_int_frame):
+        frame_copy = float_frame.reindex(float_frame.index[::2])
 
         del frame_copy['D']
         frame_copy['C'][:5] = np.nan
 
-        added = self.frame + frame_copy
+        added = float_frame + frame_copy
 
         indexer = added['A'].dropna().index
-        exp = (self.frame['A'] * 2).copy()
+        exp = (float_frame['A'] * 2).copy()
 
         tm.assert_series_equal(added['A'].dropna(), exp.loc[indexer])
 
@@ -340,95 +341,94 @@ class TestDataFrameOperators(TestData):
 
         assert np.isnan(added['D']).all()
 
-        self_added = self.frame + self.frame
-        tm.assert_index_equal(self_added.index, self.frame.index)
+        self_added = float_frame + float_frame
+        tm.assert_index_equal(self_added.index, float_frame.index)
 
-        added_rev = frame_copy + self.frame
+        added_rev = frame_copy + float_frame
         assert np.isnan(added['D']).all()
         assert np.isnan(added_rev['D']).all()
 
         # corner cases
 
         # empty
-        plus_empty = self.frame + self.empty
+        plus_empty = float_frame + DataFrame()
         assert np.isnan(plus_empty.values).all()
 
-        empty_plus = self.empty + self.frame
+        empty_plus = DataFrame() + float_frame
         assert np.isnan(empty_plus.values).all()
 
-        empty_empty = self.empty + self.empty
+        empty_empty = DataFrame() + DataFrame()
         assert empty_empty.empty
 
         # out of order
-        reverse = self.frame.reindex(columns=self.frame.columns[::-1])
+        reverse = float_frame.reindex(columns=float_frame.columns[::-1])
 
-        assert_frame_equal(reverse + self.frame, self.frame * 2)
+        assert_frame_equal(reverse + float_frame, float_frame * 2)
 
         # mix vs float64, upcast
-        added = self.frame + self.mixed_float
+        added = float_frame + mixed_float_frame
         _check_mixed_float(added, dtype='float64')
-        added = self.mixed_float + self.frame
+        added = mixed_float_frame + float_frame
         _check_mixed_float(added, dtype='float64')
 
         # mix vs mix
-        added = self.mixed_float + self.mixed_float2
-        _check_mixed_float(added, dtype=dict(C=None))
-        added = self.mixed_float2 + self.mixed_float
+        added = mixed_float_frame + mixed_float_frame
         _check_mixed_float(added, dtype=dict(C=None))
 
         # with int
-        added = self.frame + self.mixed_int
+        added = float_frame + mixed_int_frame
         _check_mixed_float(added, dtype='float64')
 
-    def test_combineSeries(self):
+    def test_combineSeries(self, float_frame, mixed_float_frame,
+                           mixed_int_frame, datetime_frame):
 
         # Series
-        series = self.frame.xs(self.frame.index[0])
+        series = float_frame.xs(float_frame.index[0])
 
-        added = self.frame + series
+        added = float_frame + series
 
         for key, s in compat.iteritems(added):
-            assert_series_equal(s, self.frame[key] + series[key])
+            assert_series_equal(s, float_frame[key] + series[key])
 
         larger_series = series.to_dict()
         larger_series['E'] = 1
         larger_series = Series(larger_series)
-        larger_added = self.frame + larger_series
+        larger_added = float_frame + larger_series
 
-        for key, s in compat.iteritems(self.frame):
+        for key, s in compat.iteritems(float_frame):
             assert_series_equal(larger_added[key], s + series[key])
         assert 'E' in larger_added
         assert np.isnan(larger_added['E']).all()
 
         # no upcast needed
-        added = self.mixed_float + series
+        added = mixed_float_frame + series
         _check_mixed_float(added)
 
         # vs mix (upcast) as needed
-        added = self.mixed_float + series.astype('float32')
+        added = mixed_float_frame + series.astype('float32')
         _check_mixed_float(added, dtype=dict(C=None))
-        added = self.mixed_float + series.astype('float16')
+        added = mixed_float_frame + series.astype('float16')
         _check_mixed_float(added, dtype=dict(C=None))
 
         # these raise with numexpr.....as we are adding an int64 to an
         # uint64....weird vs int
 
-        # added = self.mixed_int + (100*series).astype('int64')
+        # added = mixed_int_frame + (100*series).astype('int64')
         # _check_mixed_int(added, dtype = dict(A = 'int64', B = 'float64', C =
         # 'int64', D = 'int64'))
-        # added = self.mixed_int + (100*series).astype('int32')
+        # added = mixed_int_frame + (100*series).astype('int32')
         # _check_mixed_int(added, dtype = dict(A = 'int32', B = 'float64', C =
         # 'int32', D = 'int64'))
 
         # TimeSeries
-        ts = self.tsframe['A']
+        ts = datetime_frame['A']
 
         # 10890
         # we no longer allow auto timeseries broadcasting
         # and require explicit broadcasting
-        added = self.tsframe.add(ts, axis='index')
+        added = datetime_frame.add(ts, axis='index')
 
-        for key, col in compat.iteritems(self.tsframe):
+        for key, col in compat.iteritems(datetime_frame):
             result = col + ts
             assert_series_equal(added[key], result, check_names=False)
             assert added[key].name == key
@@ -437,52 +437,52 @@ class TestDataFrameOperators(TestData):
             else:
                 assert result.name is None
 
-        smaller_frame = self.tsframe[:-5]
+        smaller_frame = datetime_frame[:-5]
         smaller_added = smaller_frame.add(ts, axis='index')
 
-        tm.assert_index_equal(smaller_added.index, self.tsframe.index)
+        tm.assert_index_equal(smaller_added.index, datetime_frame.index)
 
         smaller_ts = ts[:-5]
-        smaller_added2 = self.tsframe.add(smaller_ts, axis='index')
+        smaller_added2 = datetime_frame.add(smaller_ts, axis='index')
         assert_frame_equal(smaller_added, smaller_added2)
 
         # length 0, result is all-nan
-        result = self.tsframe.add(ts[:0], axis='index')
-        expected = DataFrame(np.nan, index=self.tsframe.index,
-                             columns=self.tsframe.columns)
+        result = datetime_frame.add(ts[:0], axis='index')
+        expected = DataFrame(np.nan, index=datetime_frame.index,
+                             columns=datetime_frame.columns)
         assert_frame_equal(result, expected)
 
         # Frame is all-nan
-        result = self.tsframe[:0].add(ts, axis='index')
-        expected = DataFrame(np.nan, index=self.tsframe.index,
-                             columns=self.tsframe.columns)
+        result = datetime_frame[:0].add(ts, axis='index')
+        expected = DataFrame(np.nan, index=datetime_frame.index,
+                             columns=datetime_frame.columns)
         assert_frame_equal(result, expected)
 
         # empty but with non-empty index
-        frame = self.tsframe[:1].reindex(columns=[])
+        frame = datetime_frame[:1].reindex(columns=[])
         result = frame.mul(ts, axis='index')
         assert len(result) == len(ts)
 
-    def test_combineFunc(self):
-        result = self.frame * 2
-        tm.assert_numpy_array_equal(result.values, self.frame.values * 2)
+    def test_combineFunc(self, float_frame, mixed_float_frame):
+        result = float_frame * 2
+        tm.assert_numpy_array_equal(result.values, float_frame.values * 2)
 
         # vs mix
-        result = self.mixed_float * 2
+        result = mixed_float_frame * 2
         for c, s in compat.iteritems(result):
             tm.assert_numpy_array_equal(
-                s.values, self.mixed_float[c].values * 2)
+                s.values, mixed_float_frame[c].values * 2)
         _check_mixed_float(result, dtype=dict(C=None))
 
-        result = self.empty * 2
-        assert result.index is self.empty.index
+        result = DataFrame() * 2
+        assert result.index.equals(DataFrame().index)
         assert len(result.columns) == 0
 
-    def test_comparisons(self):
+    def test_comparisons(self, simple_frame, float_frame):
         df1 = tm.makeTimeDataFrame()
         df2 = tm.makeTimeDataFrame()
 
-        row = self.simple.xs('a')
+        row = simple_frame.xs('a')
         ndim_5 = np.ones(df1.shape + (1, 1, 1))
 
         def test_comp(func):
@@ -493,17 +493,17 @@ class TestDataFrameOperators(TestData):
             with pytest.raises(ValueError, match='dim must be <= 2'):
                 func(df1, ndim_5)
 
-            result2 = func(self.simple, row)
+            result2 = func(simple_frame, row)
             tm.assert_numpy_array_equal(result2.values,
-                                        func(self.simple.values, row.values))
+                                        func(simple_frame.values, row.values))
 
-            result3 = func(self.frame, 0)
+            result3 = func(float_frame, 0)
             tm.assert_numpy_array_equal(result3.values,
-                                        func(self.frame.values, 0))
+                                        func(float_frame.values, 0))
 
             msg = 'Can only compare identically-labeled DataFrame'
             with pytest.raises(ValueError, match=msg):
-                func(self.simple, self.simple[:2])
+                func(simple_frame, simple_frame[:2])
 
         test_comp(operator.eq)
         test_comp(operator.ne)
@@ -599,9 +599,9 @@ class TestDataFrameOperators(TestData):
         with pytest.raises(ValueError, match=msg1d):
             result = df == tup
 
-    def test_combine_generic(self):
-        df1 = self.frame
-        df2 = self.frame.loc[self.frame.index[:-5], ['A', 'B', 'C']]
+    def test_combine_generic(self, float_frame):
+        df1 = float_frame
+        df2 = float_frame.loc[float_frame.index[:-5], ['A', 'B', 'C']]
 
         combined = df1.combine(df2, np.add)
         combined2 = df2.combine(df1, np.add)
@@ -611,8 +611,8 @@ class TestDataFrameOperators(TestData):
         chunk = combined.loc[combined.index[:-5], ['A', 'B', 'C']]
         chunk2 = combined2.loc[combined2.index[:-5], ['A', 'B', 'C']]
 
-        exp = self.frame.loc[self.frame.index[:-5],
-                             ['A', 'B', 'C']].reindex_like(chunk) * 2
+        exp = float_frame.loc[float_frame.index[:-5],
+                              ['A', 'B', 'C']].reindex_like(chunk) * 2
         assert_frame_equal(chunk, exp)
         assert_frame_equal(chunk2, exp)
 

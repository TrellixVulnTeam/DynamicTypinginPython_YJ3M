commit 1940fcea056325cbe878c72078c51f80ea8482f4
Author: Kaiqi Dong <kaiqi@kth.se>
Date:   Thu Apr 30 19:48:04 2020 +0200

    TST/REF: Parametrize consistency data and de-private methods (#33875)

diff --git a/pandas/tests/window/common.py b/pandas/tests/window/common.py
index 72a0d12ed..7a7ab57cd 100644
--- a/pandas/tests/window/common.py
+++ b/pandas/tests/window/common.py
@@ -3,7 +3,7 @@ from datetime import datetime
 import numpy as np
 from numpy.random import randn
 
-from pandas import DataFrame, Series, bdate_range, notna
+from pandas import DataFrame, Series, bdate_range
 import pandas._testing as tm
 
 N, K = 100, 10
@@ -24,155 +24,6 @@ class Base:
         self.frame = DataFrame(randn(N, K), index=self.rng, columns=np.arange(K))
 
 
-# create the data only once as we are not setting it
-def _create_consistency_data():
-    def create_series():
-        return [
-            Series(dtype=object),
-            Series([np.nan]),
-            Series([np.nan, np.nan]),
-            Series([3.0]),
-            Series([np.nan, 3.0]),
-            Series([3.0, np.nan]),
-            Series([1.0, 3.0]),
-            Series([2.0, 2.0]),
-            Series([3.0, 1.0]),
-            Series(
-                [5.0, 5.0, 5.0, 5.0, np.nan, np.nan, np.nan, 5.0, 5.0, np.nan, np.nan]
-            ),
-            Series(
-                [
-                    np.nan,
-                    5.0,
-                    5.0,
-                    5.0,
-                    np.nan,
-                    np.nan,
-                    np.nan,
-                    5.0,
-                    5.0,
-                    np.nan,
-                    np.nan,
-                ]
-            ),
-            Series(
-                [
-                    np.nan,
-                    np.nan,
-                    5.0,
-                    5.0,
-                    np.nan,
-                    np.nan,
-                    np.nan,
-                    5.0,
-                    5.0,
-                    np.nan,
-                    np.nan,
-                ]
-            ),
-            Series(
-                [
-                    np.nan,
-                    3.0,
-                    np.nan,
-                    3.0,
-                    4.0,
-                    5.0,
-                    6.0,
-                    np.nan,
-                    np.nan,
-                    7.0,
-                    12.0,
-                    13.0,
-                    14.0,
-                    15.0,
-                ]
-            ),
-            Series(
-                [
-                    np.nan,
-                    5.0,
-                    np.nan,
-                    2.0,
-                    4.0,
-                    0.0,
-                    9.0,
-                    np.nan,
-                    np.nan,
-                    3.0,
-                    12.0,
-                    13.0,
-                    14.0,
-                    15.0,
-                ]
-            ),
-            Series(
-                [
-                    2.0,
-                    3.0,
-                    np.nan,
-                    3.0,
-                    4.0,
-                    5.0,
-                    6.0,
-                    np.nan,
-                    np.nan,
-                    7.0,
-                    12.0,
-                    13.0,
-                    14.0,
-                    15.0,
-                ]
-            ),
-            Series(
-                [
-                    2.0,
-                    5.0,
-                    np.nan,
-                    2.0,
-                    4.0,
-                    0.0,
-                    9.0,
-                    np.nan,
-                    np.nan,
-                    3.0,
-                    12.0,
-                    13.0,
-                    14.0,
-                    15.0,
-                ]
-            ),
-            Series(range(10)),
-            Series(range(20, 0, -2)),
-        ]
-
-    def create_dataframes():
-        return [
-            DataFrame(),
-            DataFrame(columns=["a"]),
-            DataFrame(columns=["a", "a"]),
-            DataFrame(columns=["a", "b"]),
-            DataFrame(np.arange(10).reshape((5, 2))),
-            DataFrame(np.arange(25).reshape((5, 5))),
-            DataFrame(np.arange(25).reshape((5, 5)), columns=["a", "b", 99, "d", "d"]),
-        ] + [DataFrame(s) for s in create_series()]
-
-    def is_constant(x):
-        values = x.values.ravel()
-        return len(set(values[notna(values)])) == 1
-
-    def no_nans(x):
-        return x.notna().all().all()
-
-    # data is a tuple(object, is_constant, no_nans)
-    data = create_series() + create_dataframes()
-
-    return [(x, is_constant(x), no_nans(x)) for x in data]
-
-
-_consistency_data = _create_consistency_data()
-
-
 class ConsistencyBase(Base):
     base_functions = [
         (lambda v: Series(v).count(), None, "count"),
@@ -210,154 +61,6 @@ class ConsistencyBase(Base):
 
     def _create_data(self):
         super()._create_data()
-        self.data = _consistency_data
-
-    def _test_moments_consistency_mock_mean(self, mean, mock_mean):
-        for (x, is_constant, no_nans) in self.data:
-            mean_x = mean(x)
-            # check that correlation of a series with itself is either 1 or NaN
-
-            if mock_mean:
-                # check that mean equals mock_mean
-                expected = mock_mean(x)
-                tm.assert_equal(mean_x, expected.astype("float64"))
-
-    def _test_moments_consistency_is_constant(self, min_periods, count, mean, corr):
-        for (x, is_constant, no_nans) in self.data:
-            count_x = count(x)
-            mean_x = mean(x)
-            # check that correlation of a series with itself is either 1 or NaN
-            corr_x_x = corr(x, x)
-
-            if is_constant:
-                exp = x.max() if isinstance(x, Series) else x.max().max()
-
-                # check mean of constant series
-                expected = x * np.nan
-                expected[count_x >= max(min_periods, 1)] = exp
-                tm.assert_equal(mean_x, expected)
-
-                # check correlation of constant series with itself is NaN
-                expected[:] = np.nan
-                tm.assert_equal(corr_x_x, expected)
-
-    def _test_moments_consistency_var_debiasing_factors(
-        self, var_biased=None, var_unbiased=None, var_debiasing_factors=None
-    ):
-        for (x, is_constant, no_nans) in self.data:
-            if var_unbiased and var_biased and var_debiasing_factors:
-                # check variance debiasing factors
-                var_unbiased_x = var_unbiased(x)
-                var_biased_x = var_biased(x)
-                var_debiasing_factors_x = var_debiasing_factors(x)
-                tm.assert_equal(var_unbiased_x, var_biased_x * var_debiasing_factors_x)
-
-    def _test_moments_consistency_var_data(
-        self, min_periods, count, mean, var_unbiased, var_biased
-    ):
-        for (x, is_constant, no_nans) in self.data:
-            count_x = count(x)
-            mean_x = mean(x)
-            for var in [var_biased, var_unbiased]:
-                var_x = var(x)
-                assert not (var_x < 0).any().any()
-
-                if var is var_biased:
-                    # check that biased var(x) == mean(x^2) - mean(x)^2
-                    mean_x2 = mean(x * x)
-                    tm.assert_equal(var_x, mean_x2 - (mean_x * mean_x))
-
-                if is_constant:
-                    # check that variance of constant series is identically 0
-                    assert not (var_x > 0).any().any()
-                    expected = x * np.nan
-                    expected[count_x >= max(min_periods, 1)] = 0.0
-                    if var is var_unbiased:
-                        expected[count_x < 2] = np.nan
-                    tm.assert_equal(var_x, expected)
-
-    def _test_moments_consistency_std_data(
-        self, std_unbiased, var_unbiased, std_biased, var_biased
-    ):
-        for (x, is_constant, no_nans) in self.data:
-            for (std, var) in [(std_biased, var_biased), (std_unbiased, var_unbiased)]:
-                var_x = var(x)
-                std_x = std(x)
-                assert not (var_x < 0).any().any()
-                assert not (std_x < 0).any().any()
-
-                # check that var(x) == std(x)^2
-                tm.assert_equal(var_x, std_x * std_x)
-
-    def _test_moments_consistency_cov_data(
-        self, cov_unbiased, var_unbiased, cov_biased, var_biased
-    ):
-        for (x, is_constant, no_nans) in self.data:
-            for (cov, var) in [(cov_biased, var_biased), (cov_unbiased, var_unbiased)]:
-                var_x = var(x)
-                assert not (var_x < 0).any().any()
-                if cov:
-                    cov_x_x = cov(x, x)
-                    assert not (cov_x_x < 0).any().any()
-
-                    # check that var(x) == cov(x, x)
-                    tm.assert_equal(var_x, cov_x_x)
-
-    def _test_moments_consistency_series_data(
-        self,
-        corr,
-        mean,
-        std_biased,
-        std_unbiased,
-        cov_unbiased,
-        var_unbiased,
-        var_biased,
-        cov_biased,
-    ):
-        for (x, is_constant, no_nans) in self.data:
-            if isinstance(x, Series):
-                y = x
-                mean_x = mean(x)
-                if not x.isna().equals(y.isna()):
-                    # can only easily test two Series with similar
-                    # structure
-                    pass
-
-                # check that cor(x, y) is symmetric
-                corr_x_y = corr(x, y)
-                corr_y_x = corr(y, x)
-                tm.assert_equal(corr_x_y, corr_y_x)
-
-                for (std, var, cov) in [
-                    (std_biased, var_biased, cov_biased),
-                    (std_unbiased, var_unbiased, cov_unbiased),
-                ]:
-                    var_x = var(x)
-                    std_x = std(x)
-
-                    if cov:
-                        # check that cov(x, y) is symmetric
-                        cov_x_y = cov(x, y)
-                        cov_y_x = cov(y, x)
-                        tm.assert_equal(cov_x_y, cov_y_x)
-
-                        # check that cov(x, y) == (var(x+y) - var(x) -
-                        # var(y)) / 2
-                        var_x_plus_y = var(x + y)
-                        var_y = var(y)
-                        tm.assert_equal(cov_x_y, 0.5 * (var_x_plus_y - var_x - var_y))
-
-                        # check that corr(x, y) == cov(x, y) / (std(x) *
-                        # std(y))
-                        std_y = std(y)
-                        tm.assert_equal(corr_x_y, cov_x_y / (std_x * std_y))
-
-                        if cov is cov_biased:
-                            # check that biased cov(x, y) == mean(x*y) -
-                            # mean(x)*mean(y)
-                            mean_y = mean(y)
-                            mean_x_times_y = mean(x * y)
-                            tm.assert_equal(cov_x_y, mean_x_times_y - (mean_x * mean_y))
 
     def _check_pairwise_moment(self, dispatch, name, **kwargs):
         def get_result(obj, obj2=None):
@@ -400,3 +103,146 @@ def check_binary_ew_min_periods(name, min_periods, A, B):
         Series([1.0]), Series([1.0]), 50, name=name, min_periods=min_periods
     )
     tm.assert_series_equal(result, Series([np.NaN]))
+
+
+def moments_consistency_mock_mean(x, mean, mock_mean):
+    mean_x = mean(x)
+    # check that correlation of a series with itself is either 1 or NaN
+
+    if mock_mean:
+        # check that mean equals mock_mean
+        expected = mock_mean(x)
+        tm.assert_equal(mean_x, expected.astype("float64"))
+
+
+def moments_consistency_is_constant(x, is_constant, min_periods, count, mean, corr):
+    count_x = count(x)
+    mean_x = mean(x)
+    # check that correlation of a series with itself is either 1 or NaN
+    corr_x_x = corr(x, x)
+
+    if is_constant:
+        exp = x.max() if isinstance(x, Series) else x.max().max()
+
+        # check mean of constant series
+        expected = x * np.nan
+        expected[count_x >= max(min_periods, 1)] = exp
+        tm.assert_equal(mean_x, expected)
+
+        # check correlation of constant series with itself is NaN
+        expected[:] = np.nan
+        tm.assert_equal(corr_x_x, expected)
+
+
+def moments_consistency_var_debiasing_factors(
+    x, var_biased, var_unbiased, var_debiasing_factors
+):
+    if var_unbiased and var_biased and var_debiasing_factors:
+        # check variance debiasing factors
+        var_unbiased_x = var_unbiased(x)
+        var_biased_x = var_biased(x)
+        var_debiasing_factors_x = var_debiasing_factors(x)
+        tm.assert_equal(var_unbiased_x, var_biased_x * var_debiasing_factors_x)
+
+
+def moments_consistency_var_data(
+    x, is_constant, min_periods, count, mean, var_unbiased, var_biased
+):
+    count_x = count(x)
+    mean_x = mean(x)
+    for var in [var_biased, var_unbiased]:
+        var_x = var(x)
+        assert not (var_x < 0).any().any()
+
+        if var is var_biased:
+            # check that biased var(x) == mean(x^2) - mean(x)^2
+            mean_x2 = mean(x * x)
+            tm.assert_equal(var_x, mean_x2 - (mean_x * mean_x))
+
+        if is_constant:
+            # check that variance of constant series is identically 0
+            assert not (var_x > 0).any().any()
+            expected = x * np.nan
+            expected[count_x >= max(min_periods, 1)] = 0.0
+            if var is var_unbiased:
+                expected[count_x < 2] = np.nan
+            tm.assert_equal(var_x, expected)
+
+
+def moments_consistency_std_data(x, std_unbiased, var_unbiased, std_biased, var_biased):
+    for (std, var) in [(std_biased, var_biased), (std_unbiased, var_unbiased)]:
+        var_x = var(x)
+        std_x = std(x)
+        assert not (var_x < 0).any().any()
+        assert not (std_x < 0).any().any()
+
+        # check that var(x) == std(x)^2
+        tm.assert_equal(var_x, std_x * std_x)
+
+
+def moments_consistency_cov_data(x, cov_unbiased, var_unbiased, cov_biased, var_biased):
+    for (cov, var) in [(cov_biased, var_biased), (cov_unbiased, var_unbiased)]:
+        var_x = var(x)
+        assert not (var_x < 0).any().any()
+        if cov:
+            cov_x_x = cov(x, x)
+            assert not (cov_x_x < 0).any().any()
+
+            # check that var(x) == cov(x, x)
+            tm.assert_equal(var_x, cov_x_x)
+
+
+def moments_consistency_series_data(
+    x,
+    corr,
+    mean,
+    std_biased,
+    std_unbiased,
+    cov_unbiased,
+    var_unbiased,
+    var_biased,
+    cov_biased,
+):
+    if isinstance(x, Series):
+        y = x
+        mean_x = mean(x)
+        if not x.isna().equals(y.isna()):
+            # can only easily test two Series with similar
+            # structure
+            pass
+
+        # check that cor(x, y) is symmetric
+        corr_x_y = corr(x, y)
+        corr_y_x = corr(y, x)
+        tm.assert_equal(corr_x_y, corr_y_x)
+
+        for (std, var, cov) in [
+            (std_biased, var_biased, cov_biased),
+            (std_unbiased, var_unbiased, cov_unbiased),
+        ]:
+            var_x = var(x)
+            std_x = std(x)
+
+            if cov:
+                # check that cov(x, y) is symmetric
+                cov_x_y = cov(x, y)
+                cov_y_x = cov(y, x)
+                tm.assert_equal(cov_x_y, cov_y_x)
+
+                # check that cov(x, y) == (var(x+y) - var(x) -
+                # var(y)) / 2
+                var_x_plus_y = var(x + y)
+                var_y = var(y)
+                tm.assert_equal(cov_x_y, 0.5 * (var_x_plus_y - var_x - var_y))
+
+                # check that corr(x, y) == cov(x, y) / (std(x) *
+                # std(y))
+                std_y = std(y)
+                tm.assert_equal(corr_x_y, cov_x_y / (std_x * std_y))
+
+                if cov is cov_biased:
+                    # check that biased cov(x, y) == mean(x*y) -
+                    # mean(x)*mean(y)
+                    mean_y = mean(y)
+                    mean_x_times_y = mean(x * y)
+                    tm.assert_equal(cov_x_y, mean_x_times_y - (mean_x * mean_y))
diff --git a/pandas/tests/window/conftest.py b/pandas/tests/window/conftest.py
index fb46ca51a..856c8f388 100644
--- a/pandas/tests/window/conftest.py
+++ b/pandas/tests/window/conftest.py
@@ -1,7 +1,10 @@
+import numpy as np
 import pytest
 
 import pandas.util._test_decorators as td
 
+from pandas import DataFrame, Series, notna
+
 
 @pytest.fixture(params=[True, False])
 def raw(request):
@@ -87,3 +90,155 @@ def engine(request):
 def engine_and_raw(request):
     """engine and raw keyword arguments for rolling.apply"""
     return request.param
+
+
+# create the data only once as we are not setting it
+def _create_consistency_data():
+    def create_series():
+        return [
+            Series(dtype=object),
+            Series([np.nan]),
+            Series([np.nan, np.nan]),
+            Series([3.0]),
+            Series([np.nan, 3.0]),
+            Series([3.0, np.nan]),
+            Series([1.0, 3.0]),
+            Series([2.0, 2.0]),
+            Series([3.0, 1.0]),
+            Series(
+                [5.0, 5.0, 5.0, 5.0, np.nan, np.nan, np.nan, 5.0, 5.0, np.nan, np.nan]
+            ),
+            Series(
+                [
+                    np.nan,
+                    5.0,
+                    5.0,
+                    5.0,
+                    np.nan,
+                    np.nan,
+                    np.nan,
+                    5.0,
+                    5.0,
+                    np.nan,
+                    np.nan,
+                ]
+            ),
+            Series(
+                [
+                    np.nan,
+                    np.nan,
+                    5.0,
+                    5.0,
+                    np.nan,
+                    np.nan,
+                    np.nan,
+                    5.0,
+                    5.0,
+                    np.nan,
+                    np.nan,
+                ]
+            ),
+            Series(
+                [
+                    np.nan,
+                    3.0,
+                    np.nan,
+                    3.0,
+                    4.0,
+                    5.0,
+                    6.0,
+                    np.nan,
+                    np.nan,
+                    7.0,
+                    12.0,
+                    13.0,
+                    14.0,
+                    15.0,
+                ]
+            ),
+            Series(
+                [
+                    np.nan,
+                    5.0,
+                    np.nan,
+                    2.0,
+                    4.0,
+                    0.0,
+                    9.0,
+                    np.nan,
+                    np.nan,
+                    3.0,
+                    12.0,
+                    13.0,
+                    14.0,
+                    15.0,
+                ]
+            ),
+            Series(
+                [
+                    2.0,
+                    3.0,
+                    np.nan,
+                    3.0,
+                    4.0,
+                    5.0,
+                    6.0,
+                    np.nan,
+                    np.nan,
+                    7.0,
+                    12.0,
+                    13.0,
+                    14.0,
+                    15.0,
+                ]
+            ),
+            Series(
+                [
+                    2.0,
+                    5.0,
+                    np.nan,
+                    2.0,
+                    4.0,
+                    0.0,
+                    9.0,
+                    np.nan,
+                    np.nan,
+                    3.0,
+                    12.0,
+                    13.0,
+                    14.0,
+                    15.0,
+                ]
+            ),
+            Series(range(10)),
+            Series(range(20, 0, -2)),
+        ]
+
+    def create_dataframes():
+        return [
+            DataFrame(),
+            DataFrame(columns=["a"]),
+            DataFrame(columns=["a", "a"]),
+            DataFrame(columns=["a", "b"]),
+            DataFrame(np.arange(10).reshape((5, 2))),
+            DataFrame(np.arange(25).reshape((5, 5))),
+            DataFrame(np.arange(25).reshape((5, 5)), columns=["a", "b", 99, "d", "d"]),
+        ] + [DataFrame(s) for s in create_series()]
+
+    def is_constant(x):
+        values = x.values.ravel()
+        return len(set(values[notna(values)])) == 1
+
+    def no_nans(x):
+        return x.notna().all().all()
+
+    # data is a tuple(object, is_constant, no_nans)
+    data = create_series() + create_dataframes()
+
+    return [(x, is_constant(x), no_nans(x)) for x in data]
+
+
+@pytest.fixture(params=_create_consistency_data())
+def consistency_data(request):
+    """Create consistency data"""
+    return request.param
diff --git a/pandas/tests/window/moments/test_moments_ewm.py b/pandas/tests/window/moments/test_moments_ewm.py
index 78b086927..370482652 100644
--- a/pandas/tests/window/moments/test_moments_ewm.py
+++ b/pandas/tests/window/moments/test_moments_ewm.py
@@ -11,6 +11,13 @@ from pandas.tests.window.common import (
     check_binary_ew,
     check_binary_ew_min_periods,
     ew_func,
+    moments_consistency_cov_data,
+    moments_consistency_is_constant,
+    moments_consistency_mock_mean,
+    moments_consistency_series_data,
+    moments_consistency_std_data,
+    moments_consistency_var_data,
+    moments_consistency_var_debiasing_factors,
 )
 
 
@@ -293,227 +300,240 @@ class TestEwmMomentsConsistency(ConsistencyBase):
         with pytest.raises(Exception, match=msg):
             ew_func(A, randn(50), 20, name=name, min_periods=5)
 
-    @pytest.mark.slow
-    @pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
-    @pytest.mark.parametrize("adjust", [True, False])
-    @pytest.mark.parametrize("ignore_na", [True, False])
-    def test_ewm_consistency(self, min_periods, adjust, ignore_na):
-        def _weights(s, com, adjust, ignore_na):
-            if isinstance(s, DataFrame):
-                if not len(s.columns):
-                    return DataFrame(index=s.index, columns=s.columns)
-                w = concat(
-                    [
-                        _weights(
-                            s.iloc[:, i], com=com, adjust=adjust, ignore_na=ignore_na
-                        )
-                        for i, _ in enumerate(s.columns)
-                    ],
-                    axis=1,
-                )
-                w.index = s.index
-                w.columns = s.columns
-                return w
-
-            w = Series(np.nan, index=s.index)
-            alpha = 1.0 / (1.0 + com)
-            if ignore_na:
-                w[s.notna()] = _weights(
-                    s[s.notna()], com=com, adjust=adjust, ignore_na=False
-                )
-            elif adjust:
-                for i in range(len(s)):
-                    if s.iat[i] == s.iat[i]:
-                        w.iat[i] = pow(1.0 / (1.0 - alpha), i)
-            else:
-                sum_wts = 0.0
-                prev_i = -1
-                for i in range(len(s)):
-                    if s.iat[i] == s.iat[i]:
-                        if prev_i == -1:
-                            w.iat[i] = 1.0
-                        else:
-                            w.iat[i] = alpha * sum_wts / pow(1.0 - alpha, i - prev_i)
-                        sum_wts += w.iat[i]
-                        prev_i = i
+
+@pytest.mark.slow
+@pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
+@pytest.mark.parametrize("adjust", [True, False])
+@pytest.mark.parametrize("ignore_na", [True, False])
+def test_ewm_consistency(consistency_data, min_periods, adjust, ignore_na):
+    def _weights(s, com, adjust, ignore_na):
+        if isinstance(s, DataFrame):
+            if not len(s.columns):
+                return DataFrame(index=s.index, columns=s.columns)
+            w = concat(
+                [
+                    _weights(s.iloc[:, i], com=com, adjust=adjust, ignore_na=ignore_na)
+                    for i, _ in enumerate(s.columns)
+                ],
+                axis=1,
+            )
+            w.index = s.index
+            w.columns = s.columns
             return w
 
-        def _variance_debiasing_factors(s, com, adjust, ignore_na):
-            weights = _weights(s, com=com, adjust=adjust, ignore_na=ignore_na)
-            cum_sum = weights.cumsum().fillna(method="ffill")
-            cum_sum_sq = (weights * weights).cumsum().fillna(method="ffill")
-            numerator = cum_sum * cum_sum
-            denominator = numerator - cum_sum_sq
-            denominator[denominator <= 0.0] = np.nan
-            return numerator / denominator
-
-        def _ewma(s, com, min_periods, adjust, ignore_na):
-            weights = _weights(s, com=com, adjust=adjust, ignore_na=ignore_na)
-            result = (
-                s.multiply(weights)
-                .cumsum()
-                .divide(weights.cumsum())
-                .fillna(method="ffill")
+        w = Series(np.nan, index=s.index)
+        alpha = 1.0 / (1.0 + com)
+        if ignore_na:
+            w[s.notna()] = _weights(
+                s[s.notna()], com=com, adjust=adjust, ignore_na=False
             )
-            result[
-                s.expanding().count() < (max(min_periods, 1) if min_periods else 1)
-            ] = np.nan
-            return result
-
-        com = 3.0
-        self._test_moments_consistency_mock_mean(
-            mean=lambda x: x.ewm(
-                com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-            ).mean(),
-            mock_mean=lambda x: _ewma(
-                x, com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-            ),
+        elif adjust:
+            for i in range(len(s)):
+                if s.iat[i] == s.iat[i]:
+                    w.iat[i] = pow(1.0 / (1.0 - alpha), i)
+        else:
+            sum_wts = 0.0
+            prev_i = -1
+            for i in range(len(s)):
+                if s.iat[i] == s.iat[i]:
+                    if prev_i == -1:
+                        w.iat[i] = 1.0
+                    else:
+                        w.iat[i] = alpha * sum_wts / pow(1.0 - alpha, i - prev_i)
+                    sum_wts += w.iat[i]
+                    prev_i = i
+        return w
+
+    def _variance_debiasing_factors(s, com, adjust, ignore_na):
+        weights = _weights(s, com=com, adjust=adjust, ignore_na=ignore_na)
+        cum_sum = weights.cumsum().fillna(method="ffill")
+        cum_sum_sq = (weights * weights).cumsum().fillna(method="ffill")
+        numerator = cum_sum * cum_sum
+        denominator = numerator - cum_sum_sq
+        denominator[denominator <= 0.0] = np.nan
+        return numerator / denominator
+
+    def _ewma(s, com, min_periods, adjust, ignore_na):
+        weights = _weights(s, com=com, adjust=adjust, ignore_na=ignore_na)
+        result = (
+            s.multiply(weights).cumsum().divide(weights.cumsum()).fillna(method="ffill")
         )
-
-        self._test_moments_consistency_is_constant(
-            min_periods=min_periods,
-            count=lambda x: x.expanding().count(),
-            mean=lambda x: x.ewm(
+        result[
+            s.expanding().count() < (max(min_periods, 1) if min_periods else 1)
+        ] = np.nan
+        return result
+
+    x, is_constant, no_nans = consistency_data
+    com = 3.0
+    moments_consistency_mock_mean(
+        x=x,
+        mean=lambda x: x.ewm(
+            com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+        ).mean(),
+        mock_mean=lambda x: _ewma(
+            x, com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+        ),
+    )
+
+    moments_consistency_is_constant(
+        x=x,
+        is_constant=is_constant,
+        min_periods=min_periods,
+        count=lambda x: x.expanding().count(),
+        mean=lambda x: x.ewm(
+            com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+        ).mean(),
+        corr=lambda x, y: x.ewm(
+            com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+        ).corr(y),
+    )
+
+    moments_consistency_var_debiasing_factors(
+        x=x,
+        var_unbiased=lambda x: (
+            x.ewm(
                 com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-            ).mean(),
-            corr=lambda x, y: x.ewm(
+            ).var(bias=False)
+        ),
+        var_biased=lambda x: (
+            x.ewm(
                 com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-            ).corr(y),
-        )
-
-        self._test_moments_consistency_var_debiasing_factors(
-            var_unbiased=lambda x: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).var(bias=False)
-            ),
-            var_biased=lambda x: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).var(bias=True)
-            ),
-            var_debiasing_factors=lambda x: (
-                _variance_debiasing_factors(
-                    x, com=com, adjust=adjust, ignore_na=ignore_na
-                )
-            ),
-        )
-
-    @pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
-    @pytest.mark.parametrize("adjust", [True, False])
-    @pytest.mark.parametrize("ignore_na", [True, False])
-    def test_ewm_consistency_var(self, min_periods, adjust, ignore_na):
-        com = 3.0
-        self._test_moments_consistency_var_data(
-            min_periods,
-            count=lambda x: x.expanding().count(),
-            mean=lambda x: x.ewm(
+            ).var(bias=True)
+        ),
+        var_debiasing_factors=lambda x: (
+            _variance_debiasing_factors(x, com=com, adjust=adjust, ignore_na=ignore_na)
+        ),
+    )
+
+
+@pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
+@pytest.mark.parametrize("adjust", [True, False])
+@pytest.mark.parametrize("ignore_na", [True, False])
+def test_ewm_consistency_var(consistency_data, min_periods, adjust, ignore_na):
+    x, is_constant, no_nans = consistency_data
+    com = 3.0
+    moments_consistency_var_data(
+        x=x,
+        is_constant=is_constant,
+        min_periods=min_periods,
+        count=lambda x: x.expanding().count(),
+        mean=lambda x: x.ewm(
+            com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+        ).mean(),
+        var_unbiased=lambda x: (
+            x.ewm(
                 com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-            ).mean(),
-            var_unbiased=lambda x: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).var(bias=False)
-            ),
-            var_biased=lambda x: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).var(bias=True)
-            ),
-        )
-
-    @pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
-    @pytest.mark.parametrize("adjust", [True, False])
-    @pytest.mark.parametrize("ignore_na", [True, False])
-    def test_ewm_consistency_std(self, min_periods, adjust, ignore_na):
-        com = 3.0
-        self._test_moments_consistency_std_data(
-            var_unbiased=lambda x: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).var(bias=False)
-            ),
-            std_unbiased=lambda x: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).std(bias=False)
-            ),
-            var_biased=lambda x: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).var(bias=True)
-            ),
-            std_biased=lambda x: x.ewm(
+            ).var(bias=False)
+        ),
+        var_biased=lambda x: (
+            x.ewm(
                 com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-            ).std(bias=True),
-        )
-
-    @pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
-    @pytest.mark.parametrize("adjust", [True, False])
-    @pytest.mark.parametrize("ignore_na", [True, False])
-    def test_ewm_consistency_cov(self, min_periods, adjust, ignore_na):
-        com = 3.0
-        self._test_moments_consistency_cov_data(
-            var_unbiased=lambda x: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).var(bias=False)
-            ),
-            cov_unbiased=lambda x, y: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).cov(y, bias=False)
-            ),
-            var_biased=lambda x: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).var(bias=True)
-            ),
-            cov_biased=lambda x, y: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).cov(y, bias=True)
-            ),
-        )
-
-    @pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
-    @pytest.mark.parametrize("adjust", [True, False])
-    @pytest.mark.parametrize("ignore_na", [True, False])
-    def test_ewm_consistency_series_data(self, min_periods, adjust, ignore_na):
-        com = 3.0
-        self._test_moments_consistency_series_data(
-            mean=lambda x: x.ewm(
+            ).var(bias=True)
+        ),
+    )
+
+
+@pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
+@pytest.mark.parametrize("adjust", [True, False])
+@pytest.mark.parametrize("ignore_na", [True, False])
+def test_ewm_consistency_std(consistency_data, min_periods, adjust, ignore_na):
+    x, is_constant, no_nans = consistency_data
+    com = 3.0
+    moments_consistency_std_data(
+        x=x,
+        var_unbiased=lambda x: (
+            x.ewm(
                 com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-            ).mean(),
-            corr=lambda x, y: x.ewm(
+            ).var(bias=False)
+        ),
+        std_unbiased=lambda x: (
+            x.ewm(
                 com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-            ).corr(y),
-            var_unbiased=lambda x: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).var(bias=False)
-            ),
-            std_unbiased=lambda x: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).std(bias=False)
-            ),
-            cov_unbiased=lambda x, y: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).cov(y, bias=False)
-            ),
-            var_biased=lambda x: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).var(bias=True)
-            ),
-            std_biased=lambda x: x.ewm(
+            ).std(bias=False)
+        ),
+        var_biased=lambda x: (
+            x.ewm(
                 com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-            ).std(bias=True),
-            cov_biased=lambda x, y: (
-                x.ewm(
-                    com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
-                ).cov(y, bias=True)
-            ),
-        )
+            ).var(bias=True)
+        ),
+        std_biased=lambda x: x.ewm(
+            com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+        ).std(bias=True),
+    )
+
+
+@pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
+@pytest.mark.parametrize("adjust", [True, False])
+@pytest.mark.parametrize("ignore_na", [True, False])
+def test_ewm_consistency_cov(consistency_data, min_periods, adjust, ignore_na):
+    x, is_constant, no_nans = consistency_data
+    com = 3.0
+    moments_consistency_cov_data(
+        x=x,
+        var_unbiased=lambda x: (
+            x.ewm(
+                com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+            ).var(bias=False)
+        ),
+        cov_unbiased=lambda x, y: (
+            x.ewm(
+                com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+            ).cov(y, bias=False)
+        ),
+        var_biased=lambda x: (
+            x.ewm(
+                com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+            ).var(bias=True)
+        ),
+        cov_biased=lambda x, y: (
+            x.ewm(
+                com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+            ).cov(y, bias=True)
+        ),
+    )
+
+
+@pytest.mark.slow
+@pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
+@pytest.mark.parametrize("adjust", [True, False])
+@pytest.mark.parametrize("ignore_na", [True, False])
+def test_ewm_consistency_series_data(consistency_data, min_periods, adjust, ignore_na):
+    x, is_constant, no_nans = consistency_data
+    com = 3.0
+    moments_consistency_series_data(
+        x=x,
+        mean=lambda x: x.ewm(
+            com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+        ).mean(),
+        corr=lambda x, y: x.ewm(
+            com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+        ).corr(y),
+        var_unbiased=lambda x: (
+            x.ewm(
+                com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+            ).var(bias=False)
+        ),
+        std_unbiased=lambda x: (
+            x.ewm(
+                com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+            ).std(bias=False)
+        ),
+        cov_unbiased=lambda x, y: (
+            x.ewm(
+                com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+            ).cov(y, bias=False)
+        ),
+        var_biased=lambda x: (
+            x.ewm(
+                com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+            ).var(bias=True)
+        ),
+        std_biased=lambda x: x.ewm(
+            com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+        ).std(bias=True),
+        cov_biased=lambda x, y: (
+            x.ewm(
+                com=com, min_periods=min_periods, adjust=adjust, ignore_na=ignore_na
+            ).cov(y, bias=True)
+        ),
+    )
diff --git a/pandas/tests/window/moments/test_moments_expanding.py b/pandas/tests/window/moments/test_moments_expanding.py
index a358f0e70..e97383823 100644
--- a/pandas/tests/window/moments/test_moments_expanding.py
+++ b/pandas/tests/window/moments/test_moments_expanding.py
@@ -6,7 +6,16 @@ import pytest
 
 from pandas import DataFrame, Index, MultiIndex, Series, isna, notna
 import pandas._testing as tm
-from pandas.tests.window.common import ConsistencyBase
+from pandas.tests.window.common import (
+    ConsistencyBase,
+    moments_consistency_cov_data,
+    moments_consistency_is_constant,
+    moments_consistency_mock_mean,
+    moments_consistency_series_data,
+    moments_consistency_std_data,
+    moments_consistency_var_data,
+    moments_consistency_var_debiasing_factors,
+)
 
 
 class TestExpandingMomentsConsistency(ConsistencyBase):
@@ -334,8 +343,8 @@ class TestExpandingMomentsConsistency(ConsistencyBase):
 
     @pytest.mark.slow
     @pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
-    def test_expanding_consistency(self, min_periods):
-
+    def test_expanding_consistency(self, consistency_data, min_periods):
+        x, is_constant, no_nans = consistency_data
         # suppress warnings about empty slices, as we are deliberately testing
         # with empty/0-length Series/DataFrames
         with warnings.catch_warnings():
@@ -346,20 +355,24 @@ class TestExpandingMomentsConsistency(ConsistencyBase):
             )
 
             # test consistency between different expanding_* moments
-            self._test_moments_consistency_mock_mean(
+            moments_consistency_mock_mean(
+                x=x,
                 mean=lambda x: x.expanding(min_periods=min_periods).mean(),
                 mock_mean=lambda x: x.expanding(min_periods=min_periods).sum()
                 / x.expanding().count(),
             )
 
-            self._test_moments_consistency_is_constant(
+            moments_consistency_is_constant(
+                x=x,
+                is_constant=is_constant,
                 min_periods=min_periods,
                 count=lambda x: x.expanding().count(),
                 mean=lambda x: x.expanding(min_periods=min_periods).mean(),
                 corr=lambda x, y: x.expanding(min_periods=min_periods).corr(y),
             )
 
-            self._test_moments_consistency_var_debiasing_factors(
+            moments_consistency_var_debiasing_factors(
+                x=x,
                 var_unbiased=lambda x: x.expanding(min_periods=min_periods).var(),
                 var_biased=lambda x: x.expanding(min_periods=min_periods).var(ddof=0),
                 var_debiasing_factors=lambda x: (
@@ -369,7 +382,8 @@ class TestExpandingMomentsConsistency(ConsistencyBase):
             )
 
     @pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
-    def test_expanding_apply_consistency(self, min_periods):
+    def test_expanding_apply_consistency(self, consistency_data, min_periods):
+        x, is_constant, no_nans = consistency_data
         with warnings.catch_warnings():
             warnings.filterwarnings(
                 "ignore",
@@ -379,77 +393,89 @@ class TestExpandingMomentsConsistency(ConsistencyBase):
             # test consistency between expanding_xyz() and either (a)
             # expanding_apply of Series.xyz(), or (b) expanding_apply of
             # np.nanxyz()
-            for (x, is_constant, no_nans) in self.data:
-                functions = self.base_functions
-
-                # GH 8269
-                if no_nans:
-                    functions = self.base_functions + self.no_nan_functions
-                for (f, require_min_periods, name) in functions:
-                    expanding_f = getattr(x.expanding(min_periods=min_periods), name)
-
-                    if (
-                        require_min_periods
-                        and (min_periods is not None)
-                        and (min_periods < require_min_periods)
-                    ):
-                        continue
-
-                    if name == "count":
-                        expanding_f_result = expanding_f()
-                        expanding_apply_f_result = x.expanding(min_periods=0).apply(
-                            func=f, raw=True
-                        )
+            functions = self.base_functions
+
+            # GH 8269
+            if no_nans:
+                functions = self.base_functions + self.no_nan_functions
+            for (f, require_min_periods, name) in functions:
+                expanding_f = getattr(x.expanding(min_periods=min_periods), name)
+
+                if (
+                    require_min_periods
+                    and (min_periods is not None)
+                    and (min_periods < require_min_periods)
+                ):
+                    continue
+
+                if name == "count":
+                    expanding_f_result = expanding_f()
+                    expanding_apply_f_result = x.expanding(min_periods=0).apply(
+                        func=f, raw=True
+                    )
+                else:
+                    if name in ["cov", "corr"]:
+                        expanding_f_result = expanding_f(pairwise=False)
                     else:
-                        if name in ["cov", "corr"]:
-                            expanding_f_result = expanding_f(pairwise=False)
-                        else:
-                            expanding_f_result = expanding_f()
-                        expanding_apply_f_result = x.expanding(
-                            min_periods=min_periods
-                        ).apply(func=f, raw=True)
-
-                    # GH 9422
-                    if name in ["sum", "prod"]:
-                        tm.assert_equal(expanding_f_result, expanding_apply_f_result)
+                        expanding_f_result = expanding_f()
+                    expanding_apply_f_result = x.expanding(
+                        min_periods=min_periods
+                    ).apply(func=f, raw=True)
+
+                # GH 9422
+                if name in ["sum", "prod"]:
+                    tm.assert_equal(expanding_f_result, expanding_apply_f_result)
+
+
+@pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
+def test_moments_consistency_var(consistency_data, min_periods):
+    x, is_constant, no_nans = consistency_data
+    moments_consistency_var_data(
+        x=x,
+        is_constant=is_constant,
+        min_periods=min_periods,
+        count=lambda x: x.expanding(min_periods=min_periods).count(),
+        mean=lambda x: x.expanding(min_periods=min_periods).mean(),
+        var_unbiased=lambda x: x.expanding(min_periods=min_periods).var(),
+        var_biased=lambda x: x.expanding(min_periods=min_periods).var(ddof=0),
+    )
 
-    @pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
-    def test_moments_consistency_var(self, min_periods):
-        self._test_moments_consistency_var_data(
-            min_periods=min_periods,
-            count=lambda x: x.expanding(min_periods=min_periods).count(),
-            mean=lambda x: x.expanding(min_periods=min_periods).mean(),
-            var_unbiased=lambda x: x.expanding(min_periods=min_periods).var(),
-            var_biased=lambda x: x.expanding(min_periods=min_periods).var(ddof=0),
-        )
 
-    @pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
-    def test_expanding_consistency_std(self, min_periods):
-        self._test_moments_consistency_std_data(
-            var_unbiased=lambda x: x.expanding(min_periods=min_periods).var(),
-            std_unbiased=lambda x: x.expanding(min_periods=min_periods).std(),
-            var_biased=lambda x: x.expanding(min_periods=min_periods).var(ddof=0),
-            std_biased=lambda x: x.expanding(min_periods=min_periods).std(ddof=0),
-        )
+@pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
+def test_expanding_consistency_std(consistency_data, min_periods):
+    x, is_constant, no_nans = consistency_data
+    moments_consistency_std_data(
+        x=x,
+        var_unbiased=lambda x: x.expanding(min_periods=min_periods).var(),
+        std_unbiased=lambda x: x.expanding(min_periods=min_periods).std(),
+        var_biased=lambda x: x.expanding(min_periods=min_periods).var(ddof=0),
+        std_biased=lambda x: x.expanding(min_periods=min_periods).std(ddof=0),
+    )
 
-    @pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
-    def test_expanding_consistency_cov(self, min_periods):
-        self._test_moments_consistency_cov_data(
-            var_unbiased=lambda x: x.expanding(min_periods=min_periods).var(),
-            cov_unbiased=lambda x, y: x.expanding(min_periods=min_periods).cov(y),
-            var_biased=lambda x: x.expanding(min_periods=min_periods).var(ddof=0),
-            cov_biased=lambda x, y: x.expanding(min_periods=min_periods).cov(y, ddof=0),
-        )
 
-    @pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
-    def test_expanding_consistency_series(self, min_periods):
-        self._test_moments_consistency_series_data(
-            mean=lambda x: x.expanding(min_periods=min_periods).mean(),
-            corr=lambda x, y: x.expanding(min_periods=min_periods).corr(y),
-            var_unbiased=lambda x: x.expanding(min_periods=min_periods).var(),
-            std_unbiased=lambda x: x.expanding(min_periods=min_periods).std(),
-            cov_unbiased=lambda x, y: x.expanding(min_periods=min_periods).cov(y),
-            var_biased=lambda x: x.expanding(min_periods=min_periods).var(ddof=0),
-            std_biased=lambda x: x.expanding(min_periods=min_periods).std(ddof=0),
-            cov_biased=lambda x, y: x.expanding(min_periods=min_periods).cov(y, ddof=0),
-        )
+@pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
+def test_expanding_consistency_cov(consistency_data, min_periods):
+    x, is_constant, no_nans = consistency_data
+    moments_consistency_cov_data(
+        x=x,
+        var_unbiased=lambda x: x.expanding(min_periods=min_periods).var(),
+        cov_unbiased=lambda x, y: x.expanding(min_periods=min_periods).cov(y),
+        var_biased=lambda x: x.expanding(min_periods=min_periods).var(ddof=0),
+        cov_biased=lambda x, y: x.expanding(min_periods=min_periods).cov(y, ddof=0),
+    )
+
+
+@pytest.mark.parametrize("min_periods", [0, 1, 2, 3, 4])
+def test_expanding_consistency_series(consistency_data, min_periods):
+    x, is_constant, no_nans = consistency_data
+    moments_consistency_series_data(
+        x=x,
+        mean=lambda x: x.expanding(min_periods=min_periods).mean(),
+        corr=lambda x, y: x.expanding(min_periods=min_periods).corr(y),
+        var_unbiased=lambda x: x.expanding(min_periods=min_periods).var(),
+        std_unbiased=lambda x: x.expanding(min_periods=min_periods).std(),
+        cov_unbiased=lambda x, y: x.expanding(min_periods=min_periods).cov(y),
+        var_biased=lambda x: x.expanding(min_periods=min_periods).var(ddof=0),
+        std_biased=lambda x: x.expanding(min_periods=min_periods).std(ddof=0),
+        cov_biased=lambda x, y: x.expanding(min_periods=min_periods).cov(y, ddof=0),
+    )
diff --git a/pandas/tests/window/moments/test_moments_rolling.py b/pandas/tests/window/moments/test_moments_rolling.py
index 503f2e12b..c15b7ed00 100644
--- a/pandas/tests/window/moments/test_moments_rolling.py
+++ b/pandas/tests/window/moments/test_moments_rolling.py
@@ -12,7 +12,17 @@ import pandas as pd
 from pandas import DataFrame, DatetimeIndex, Index, Series, isna, notna
 import pandas._testing as tm
 from pandas.core.window.common import _flex_binary_moment
-from pandas.tests.window.common import Base, ConsistencyBase
+from pandas.tests.window.common import (
+    Base,
+    ConsistencyBase,
+    moments_consistency_cov_data,
+    moments_consistency_is_constant,
+    moments_consistency_mock_mean,
+    moments_consistency_series_data,
+    moments_consistency_std_data,
+    moments_consistency_var_data,
+    moments_consistency_var_debiasing_factors,
+)
 
 import pandas.tseries.offsets as offsets
 
@@ -936,88 +946,13 @@ class TestRollingMomentsConsistency(ConsistencyBase):
     def setup_method(self, method):
         self._create_data()
 
-    @pytest.mark.slow
     @pytest.mark.parametrize(
         "window,min_periods,center", list(_rolling_consistency_cases())
     )
-    def test_rolling_consistency(self, window, min_periods, center):
-
-        # suppress warnings about empty slices, as we are deliberately testing
-        # with empty/0-length Series/DataFrames
-        with warnings.catch_warnings():
-            warnings.filterwarnings(
-                "ignore",
-                message=".*(empty slice|0 for slice).*",
-                category=RuntimeWarning,
-            )
-
-            # test consistency between different rolling_* moments
-            self._test_moments_consistency_mock_mean(
-                mean=lambda x: (
-                    x.rolling(
-                        window=window, min_periods=min_periods, center=center
-                    ).mean()
-                ),
-                mock_mean=lambda x: (
-                    x.rolling(window=window, min_periods=min_periods, center=center)
-                    .sum()
-                    .divide(
-                        x.rolling(
-                            window=window, min_periods=min_periods, center=center
-                        ).count()
-                    )
-                ),
-            )
-
-            self._test_moments_consistency_is_constant(
-                min_periods=min_periods,
-                count=lambda x: (
-                    x.rolling(
-                        window=window, min_periods=min_periods, center=center
-                    ).count()
-                ),
-                mean=lambda x: (
-                    x.rolling(
-                        window=window, min_periods=min_periods, center=center
-                    ).mean()
-                ),
-                corr=lambda x, y: (
-                    x.rolling(
-                        window=window, min_periods=min_periods, center=center
-                    ).corr(y)
-                ),
-            )
-
-            self._test_moments_consistency_var_debiasing_factors(
-                var_unbiased=lambda x: (
-                    x.rolling(
-                        window=window, min_periods=min_periods, center=center
-                    ).var()
-                ),
-                var_biased=lambda x: (
-                    x.rolling(
-                        window=window, min_periods=min_periods, center=center
-                    ).var(ddof=0)
-                ),
-                var_debiasing_factors=lambda x: (
-                    x.rolling(window=window, min_periods=min_periods, center=center)
-                    .count()
-                    .divide(
-                        (
-                            x.rolling(
-                                window=window, min_periods=min_periods, center=center
-                            ).count()
-                            - 1.0
-                        ).replace(0.0, np.nan)
-                    )
-                ),
-            )
-
-    @pytest.mark.parametrize(
-        "window,min_periods,center", list(_rolling_consistency_cases())
-    )
-    def test_rolling_apply_consistency(self, window, min_periods, center):
-
+    def test_rolling_apply_consistency(
+        self, consistency_data, window, min_periods, center
+    ):
+        x, is_constant, no_nans = consistency_data
         with warnings.catch_warnings():
             warnings.filterwarnings(
                 "ignore",
@@ -1027,149 +962,41 @@ class TestRollingMomentsConsistency(ConsistencyBase):
             # test consistency between rolling_xyz() and either (a)
             # rolling_apply of Series.xyz(), or (b) rolling_apply of
             # np.nanxyz()
-            for (x, is_constant, no_nans) in self.data:
-                functions = self.base_functions
-
-                # GH 8269
-                if no_nans:
-                    functions = self.base_functions + self.no_nan_functions
-                for (f, require_min_periods, name) in functions:
-                    rolling_f = getattr(
-                        x.rolling(
-                            window=window, center=center, min_periods=min_periods
-                        ),
-                        name,
-                    )
-
-                    if (
-                        require_min_periods
-                        and (min_periods is not None)
-                        and (min_periods < require_min_periods)
-                    ):
-                        continue
-
-                    if name == "count":
-                        rolling_f_result = rolling_f()
-                        rolling_apply_f_result = x.rolling(
-                            window=window, min_periods=min_periods, center=center
-                        ).apply(func=f, raw=True)
-                    else:
-                        if name in ["cov", "corr"]:
-                            rolling_f_result = rolling_f(pairwise=False)
-                        else:
-                            rolling_f_result = rolling_f()
-                        rolling_apply_f_result = x.rolling(
-                            window=window, min_periods=min_periods, center=center
-                        ).apply(func=f, raw=True)
-
-                    # GH 9422
-                    if name in ["sum", "prod"]:
-                        tm.assert_equal(rolling_f_result, rolling_apply_f_result)
-
-    @pytest.mark.parametrize(
-        "window,min_periods,center", list(_rolling_consistency_cases())
-    )
-    def test_rolling_consistency_var(self, window, min_periods, center):
-        self._test_moments_consistency_var_data(
-            min_periods,
-            count=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).count()
-            ),
-            mean=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).mean()
-            ),
-            var_unbiased=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).var()
-            ),
-            var_biased=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).var(
-                    ddof=0
+            functions = self.base_functions
+
+            # GH 8269
+            if no_nans:
+                functions = self.base_functions + self.no_nan_functions
+            for (f, require_min_periods, name) in functions:
+                rolling_f = getattr(
+                    x.rolling(window=window, center=center, min_periods=min_periods),
+                    name,
                 )
-            ),
-        )
 
-    @pytest.mark.parametrize(
-        "window,min_periods,center", list(_rolling_consistency_cases())
-    )
-    def test_rolling_consistency_std(self, window, min_periods, center):
-        self._test_moments_consistency_std_data(
-            var_unbiased=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).var()
-            ),
-            std_unbiased=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).std()
-            ),
-            var_biased=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).var(
-                    ddof=0
-                )
-            ),
-            std_biased=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).std(
-                    ddof=0
-                )
-            ),
-        )
+                if (
+                    require_min_periods
+                    and (min_periods is not None)
+                    and (min_periods < require_min_periods)
+                ):
+                    continue
 
-    @pytest.mark.parametrize(
-        "window,min_periods,center", list(_rolling_consistency_cases())
-    )
-    def test_rolling_consistency_cov(self, window, min_periods, center):
-        self._test_moments_consistency_cov_data(
-            var_unbiased=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).var()
-            ),
-            cov_unbiased=lambda x, y: (
-                x.rolling(window=window, min_periods=min_periods, center=center).cov(y)
-            ),
-            var_biased=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).var(
-                    ddof=0
-                )
-            ),
-            cov_biased=lambda x, y: (
-                x.rolling(window=window, min_periods=min_periods, center=center).cov(
-                    y, ddof=0
-                )
-            ),
-        )
+                if name == "count":
+                    rolling_f_result = rolling_f()
+                    rolling_apply_f_result = x.rolling(
+                        window=window, min_periods=min_periods, center=center
+                    ).apply(func=f, raw=True)
+                else:
+                    if name in ["cov", "corr"]:
+                        rolling_f_result = rolling_f(pairwise=False)
+                    else:
+                        rolling_f_result = rolling_f()
+                    rolling_apply_f_result = x.rolling(
+                        window=window, min_periods=min_periods, center=center
+                    ).apply(func=f, raw=True)
 
-    @pytest.mark.parametrize(
-        "window,min_periods,center", list(_rolling_consistency_cases())
-    )
-    def test_rolling_consistency_series(self, window, min_periods, center):
-        self._test_moments_consistency_series_data(
-            mean=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).mean()
-            ),
-            corr=lambda x, y: (
-                x.rolling(window=window, min_periods=min_periods, center=center).corr(y)
-            ),
-            var_unbiased=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).var()
-            ),
-            std_unbiased=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).std()
-            ),
-            cov_unbiased=lambda x, y: (
-                x.rolling(window=window, min_periods=min_periods, center=center).cov(y)
-            ),
-            var_biased=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).var(
-                    ddof=0
-                )
-            ),
-            std_biased=lambda x: (
-                x.rolling(window=window, min_periods=min_periods, center=center).std(
-                    ddof=0
-                )
-            ),
-            cov_biased=lambda x, y: (
-                x.rolling(window=window, min_periods=min_periods, center=center).cov(
-                    y, ddof=0
-                )
-            ),
-        )
+                # GH 9422
+                if name in ["sum", "prod"]:
+                    tm.assert_equal(rolling_f_result, rolling_apply_f_result)
 
     # binary moments
     def test_rolling_cov(self):
@@ -1601,3 +1428,180 @@ class TestRollingMomentsConsistency(ConsistencyBase):
 
             df2_result = f(df2)
             tm.assert_frame_equal(df2_result, df2_expected)
+
+
+@pytest.mark.parametrize(
+    "window,min_periods,center", list(_rolling_consistency_cases())
+)
+def test_rolling_consistency_var(consistency_data, window, min_periods, center):
+    x, is_constant, no_nans = consistency_data
+    moments_consistency_var_data(
+        x=x,
+        is_constant=is_constant,
+        min_periods=min_periods,
+        count=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).count()
+        ),
+        mean=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).mean()
+        ),
+        var_unbiased=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).var()
+        ),
+        var_biased=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).var(ddof=0)
+        ),
+    )
+
+
+@pytest.mark.parametrize(
+    "window,min_periods,center", list(_rolling_consistency_cases())
+)
+def test_rolling_consistency_std(consistency_data, window, min_periods, center):
+    x, is_constant, no_nans = consistency_data
+    moments_consistency_std_data(
+        x=x,
+        var_unbiased=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).var()
+        ),
+        std_unbiased=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).std()
+        ),
+        var_biased=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).var(ddof=0)
+        ),
+        std_biased=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).std(ddof=0)
+        ),
+    )
+
+
+@pytest.mark.parametrize(
+    "window,min_periods,center", list(_rolling_consistency_cases())
+)
+def test_rolling_consistency_cov(consistency_data, window, min_periods, center):
+    x, is_constant, no_nans = consistency_data
+    moments_consistency_cov_data(
+        x=x,
+        var_unbiased=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).var()
+        ),
+        cov_unbiased=lambda x, y: (
+            x.rolling(window=window, min_periods=min_periods, center=center).cov(y)
+        ),
+        var_biased=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).var(ddof=0)
+        ),
+        cov_biased=lambda x, y: (
+            x.rolling(window=window, min_periods=min_periods, center=center).cov(
+                y, ddof=0
+            )
+        ),
+    )
+
+
+@pytest.mark.slow
+@pytest.mark.parametrize(
+    "window,min_periods,center", list(_rolling_consistency_cases())
+)
+def test_rolling_consistency_series(consistency_data, window, min_periods, center):
+    x, is_constant, no_nans = consistency_data
+    moments_consistency_series_data(
+        x=x,
+        mean=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).mean()
+        ),
+        corr=lambda x, y: (
+            x.rolling(window=window, min_periods=min_periods, center=center).corr(y)
+        ),
+        var_unbiased=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).var()
+        ),
+        std_unbiased=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).std()
+        ),
+        cov_unbiased=lambda x, y: (
+            x.rolling(window=window, min_periods=min_periods, center=center).cov(y)
+        ),
+        var_biased=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).var(ddof=0)
+        ),
+        std_biased=lambda x: (
+            x.rolling(window=window, min_periods=min_periods, center=center).std(ddof=0)
+        ),
+        cov_biased=lambda x, y: (
+            x.rolling(window=window, min_periods=min_periods, center=center).cov(
+                y, ddof=0
+            )
+        ),
+    )
+
+
+@pytest.mark.slow
+@pytest.mark.parametrize(
+    "window,min_periods,center", list(_rolling_consistency_cases())
+)
+def test_rolling_consistency(consistency_data, window, min_periods, center):
+    x, is_constant, no_nans = consistency_data
+    # suppress warnings about empty slices, as we are deliberately testing
+    # with empty/0-length Series/DataFrames
+    with warnings.catch_warnings():
+        warnings.filterwarnings(
+            "ignore", message=".*(empty slice|0 for slice).*", category=RuntimeWarning,
+        )
+
+        # test consistency between different rolling_* moments
+        moments_consistency_mock_mean(
+            x=x,
+            mean=lambda x: (
+                x.rolling(window=window, min_periods=min_periods, center=center).mean()
+            ),
+            mock_mean=lambda x: (
+                x.rolling(window=window, min_periods=min_periods, center=center)
+                .sum()
+                .divide(
+                    x.rolling(
+                        window=window, min_periods=min_periods, center=center
+                    ).count()
+                )
+            ),
+        )
+
+        moments_consistency_is_constant(
+            x=x,
+            is_constant=is_constant,
+            min_periods=min_periods,
+            count=lambda x: (
+                x.rolling(window=window, min_periods=min_periods, center=center).count()
+            ),
+            mean=lambda x: (
+                x.rolling(window=window, min_periods=min_periods, center=center).mean()
+            ),
+            corr=lambda x, y: (
+                x.rolling(window=window, min_periods=min_periods, center=center).corr(y)
+            ),
+        )
+
+        moments_consistency_var_debiasing_factors(
+            x=x,
+            var_unbiased=lambda x: (
+                x.rolling(window=window, min_periods=min_periods, center=center).var()
+            ),
+            var_biased=lambda x: (
+                x.rolling(window=window, min_periods=min_periods, center=center).var(
+                    ddof=0
+                )
+            ),
+            var_debiasing_factors=lambda x: (
+                x.rolling(window=window, min_periods=min_periods, center=center)
+                .count()
+                .divide(
+                    (
+                        x.rolling(
+                            window=window, min_periods=min_periods, center=center
+                        ).count()
+                        - 1.0
+                    ).replace(0.0, np.nan)
+                )
+            ),
+        )

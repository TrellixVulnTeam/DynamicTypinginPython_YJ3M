commit 54f1b3eca094e0b98d6d2b93854f9c937394109d
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Feb 6 03:34:32 2018 -0800

    Collect Series timezone tests (#19541)

diff --git a/pandas/tests/series/test_timezones.py b/pandas/tests/series/test_timezones.py
new file mode 100644
index 000000000..2e15c964e
--- /dev/null
+++ b/pandas/tests/series/test_timezones.py
@@ -0,0 +1,293 @@
+# -*- coding: utf-8 -*-
+"""
+Tests for Series timezone-related methods
+"""
+from datetime import datetime
+
+import pytest
+import pytz
+import numpy as np
+from dateutil.tz import tzoffset
+
+import pandas.util.testing as tm
+from pandas._libs import tslib
+from pandas._libs.tslibs import timezones
+from pandas.compat import lrange
+from pandas.core.indexes.datetimes import date_range
+from pandas import Series, Timestamp, DatetimeIndex, Index
+
+
+class TestSeriesTimezones(object):
+    # -----------------------------------------------------------------
+    # Series.tz_localize
+    def test_series_tz_localize(self):
+
+        rng = date_range('1/1/2011', periods=100, freq='H')
+        ts = Series(1, index=rng)
+
+        result = ts.tz_localize('utc')
+        assert result.index.tz.zone == 'UTC'
+
+        # Can't localize if already tz-aware
+        rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
+        ts = Series(1, index=rng)
+        tm.assert_raises_regex(TypeError, 'Already tz-aware',
+                               ts.tz_localize, 'US/Eastern')
+
+    def test_series_tz_localize_ambiguous_bool(self):
+        # make sure that we are correctly accepting bool values as ambiguous
+
+        # GH#14402
+        ts = Timestamp('2015-11-01 01:00:03')
+        expected0 = Timestamp('2015-11-01 01:00:03-0500', tz='US/Central')
+        expected1 = Timestamp('2015-11-01 01:00:03-0600', tz='US/Central')
+
+        ser = Series([ts])
+        expected0 = Series([expected0])
+        expected1 = Series([expected1])
+
+        with pytest.raises(pytz.AmbiguousTimeError):
+            ser.dt.tz_localize('US/Central')
+
+        result = ser.dt.tz_localize('US/Central', ambiguous=True)
+        tm.assert_series_equal(result, expected0)
+
+        result = ser.dt.tz_localize('US/Central', ambiguous=[True])
+        tm.assert_series_equal(result, expected0)
+
+        result = ser.dt.tz_localize('US/Central', ambiguous=False)
+        tm.assert_series_equal(result, expected1)
+
+        result = ser.dt.tz_localize('US/Central', ambiguous=[False])
+        tm.assert_series_equal(result, expected1)
+
+    @pytest.mark.parametrize('tzstr', ['US/Eastern', 'dateutil/US/Eastern'])
+    def test_series_tz_localize_empty(self, tzstr):
+        # GH#2248
+        ser = Series()
+
+        ser2 = ser.tz_localize('utc')
+        assert ser2.index.tz == pytz.utc
+
+        ser2 = ser.tz_localize(tzstr)
+        timezones.tz_compare(ser2.index.tz, timezones.maybe_get_tz(tzstr))
+
+    # -----------------------------------------------------------------
+    # Series.tz_convert
+
+    def test_series_tz_convert(self):
+        rng = date_range('1/1/2011', periods=200, freq='D', tz='US/Eastern')
+        ts = Series(1, index=rng)
+
+        result = ts.tz_convert('Europe/Berlin')
+        assert result.index.tz.zone == 'Europe/Berlin'
+
+        # can't convert tz-naive
+        rng = date_range('1/1/2011', periods=200, freq='D')
+        ts = Series(1, index=rng)
+        tm.assert_raises_regex(TypeError, "Cannot convert tz-naive",
+                               ts.tz_convert, 'US/Eastern')
+
+    # -----------------------------------------------------------------
+    # Series.append
+
+    def test_series_append_aware(self):
+        rng1 = date_range('1/1/2011 01:00', periods=1, freq='H',
+                          tz='US/Eastern')
+        rng2 = date_range('1/1/2011 02:00', periods=1, freq='H',
+                          tz='US/Eastern')
+        ser1 = Series([1], index=rng1)
+        ser2 = Series([2], index=rng2)
+        ts_result = ser1.append(ser2)
+
+        exp_index = DatetimeIndex(['2011-01-01 01:00', '2011-01-01 02:00'],
+                                  tz='US/Eastern')
+        exp = Series([1, 2], index=exp_index)
+        tm.assert_series_equal(ts_result, exp)
+        assert ts_result.index.tz == rng1.tz
+
+        rng1 = date_range('1/1/2011 01:00', periods=1, freq='H', tz='UTC')
+        rng2 = date_range('1/1/2011 02:00', periods=1, freq='H', tz='UTC')
+        ser1 = Series([1], index=rng1)
+        ser2 = Series([2], index=rng2)
+        ts_result = ser1.append(ser2)
+
+        exp_index = DatetimeIndex(['2011-01-01 01:00', '2011-01-01 02:00'],
+                                  tz='UTC')
+        exp = Series([1, 2], index=exp_index)
+        tm.assert_series_equal(ts_result, exp)
+        utc = rng1.tz
+        assert utc == ts_result.index.tz
+
+        # GH#7795
+        # different tz coerces to object dtype, not UTC
+        rng1 = date_range('1/1/2011 01:00', periods=1, freq='H',
+                          tz='US/Eastern')
+        rng2 = date_range('1/1/2011 02:00', periods=1, freq='H',
+                          tz='US/Central')
+        ser1 = Series([1], index=rng1)
+        ser2 = Series([2], index=rng2)
+        ts_result = ser1.append(ser2)
+        exp_index = Index([Timestamp('1/1/2011 01:00', tz='US/Eastern'),
+                           Timestamp('1/1/2011 02:00', tz='US/Central')])
+        exp = Series([1, 2], index=exp_index)
+        tm.assert_series_equal(ts_result, exp)
+
+    def test_series_append_aware_naive(self):
+        rng1 = date_range('1/1/2011 01:00', periods=1, freq='H')
+        rng2 = date_range('1/1/2011 02:00', periods=1, freq='H',
+                          tz='US/Eastern')
+        ser1 = Series(np.random.randn(len(rng1)), index=rng1)
+        ser2 = Series(np.random.randn(len(rng2)), index=rng2)
+        ts_result = ser1.append(ser2)
+
+        expected = ser1.index.astype(object).append(ser2.index.astype(object))
+        assert ts_result.index.equals(expected)
+
+        # mixed
+        rng1 = date_range('1/1/2011 01:00', periods=1, freq='H')
+        rng2 = lrange(100)
+        ser1 = Series(np.random.randn(len(rng1)), index=rng1)
+        ser2 = Series(np.random.randn(len(rng2)), index=rng2)
+        ts_result = ser1.append(ser2)
+
+        expected = ser1.index.astype(object).append(ser2.index)
+        assert ts_result.index.equals(expected)
+
+    def test_series_append_dst(self):
+        rng1 = date_range('1/1/2016 01:00', periods=3, freq='H',
+                          tz='US/Eastern')
+        rng2 = date_range('8/1/2016 01:00', periods=3, freq='H',
+                          tz='US/Eastern')
+        ser1 = Series([1, 2, 3], index=rng1)
+        ser2 = Series([10, 11, 12], index=rng2)
+        ts_result = ser1.append(ser2)
+
+        exp_index = DatetimeIndex(['2016-01-01 01:00', '2016-01-01 02:00',
+                                   '2016-01-01 03:00', '2016-08-01 01:00',
+                                   '2016-08-01 02:00', '2016-08-01 03:00'],
+                                  tz='US/Eastern')
+        exp = Series([1, 2, 3, 10, 11, 12], index=exp_index)
+        tm.assert_series_equal(ts_result, exp)
+        assert ts_result.index.tz == rng1.tz
+
+    # -----------------------------------------------------------------
+
+    def test_dateutil_tzoffset_support(self):
+        values = [188.5, 328.25]
+        tzinfo = tzoffset(None, 7200)
+        index = [datetime(2012, 5, 11, 11, tzinfo=tzinfo),
+                 datetime(2012, 5, 11, 12, tzinfo=tzinfo)]
+        series = Series(data=values, index=index)
+
+        assert series.index.tz == tzinfo
+
+        # it works! #2443
+        repr(series.index[0])
+
+    @pytest.mark.parametrize('tz', ['US/Eastern', 'dateutil/US/Eastern'])
+    def test_tz_aware_asfreq(self, tz):
+        dr = date_range('2011-12-01', '2012-07-20', freq='D', tz=tz)
+
+        ser = Series(np.random.randn(len(dr)), index=dr)
+
+        # it works!
+        ser.asfreq('T')
+
+    @pytest.mark.parametrize('tz', ['US/Eastern', 'dateutil/US/Eastern'])
+    def test_string_index_alias_tz_aware(self, tz):
+        rng = date_range('1/1/2000', periods=10, tz=tz)
+        ser = Series(np.random.randn(len(rng)), index=rng)
+
+        result = ser['1/3/2000']
+        tm.assert_almost_equal(result, ser[2])
+
+    # TODO: De-duplicate with test below
+    def test_series_add_tz_mismatch_converts_to_utc_duplicate(self):
+        rng = date_range('1/1/2011', periods=10, freq='H', tz='US/Eastern')
+        ser = Series(np.random.randn(len(rng)), index=rng)
+
+        ts_moscow = ser.tz_convert('Europe/Moscow')
+
+        result = ser + ts_moscow
+        assert result.index.tz is pytz.utc
+
+        result = ts_moscow + ser
+        assert result.index.tz is pytz.utc
+
+    def test_series_add_tz_mismatch_converts_to_utc(self):
+        rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
+
+        perm = np.random.permutation(100)[:90]
+        ser1 = Series(np.random.randn(90),
+                      index=rng.take(perm).tz_convert('US/Eastern'))
+
+        perm = np.random.permutation(100)[:90]
+        ser2 = Series(np.random.randn(90),
+                      index=rng.take(perm).tz_convert('Europe/Berlin'))
+
+        result = ser1 + ser2
+
+        uts1 = ser1.tz_convert('utc')
+        uts2 = ser2.tz_convert('utc')
+        expected = uts1 + uts2
+
+        assert result.index.tz == pytz.UTC
+        tm.assert_series_equal(result, expected)
+
+    def test_series_add_aware_naive_raises(self):
+        rng = date_range('1/1/2011', periods=10, freq='H')
+        ser = Series(np.random.randn(len(rng)), index=rng)
+
+        ser_utc = ser.tz_localize('utc')
+
+        with pytest.raises(Exception):
+            ser + ser_utc
+
+        with pytest.raises(Exception):
+            ser_utc + ser
+
+    def test_series_align_aware(self):
+        idx1 = date_range('2001', periods=5, freq='H', tz='US/Eastern')
+        ser = Series(np.random.randn(len(idx1)), index=idx1)
+        ser_central = ser.tz_convert('US/Central')
+        # # different timezones convert to UTC
+
+        new1, new2 = ser.align(ser_central)
+        assert new1.index.tz == pytz.UTC
+        assert new2.index.tz == pytz.UTC
+
+    @pytest.mark.parametrize('tzstr', ['US/Eastern', 'dateutil/US/Eastern'])
+    def test_localized_at_time_between_time(self, tzstr):
+        from datetime import time
+        tz = timezones.maybe_get_tz(tzstr)
+
+        rng = date_range('4/16/2012', '5/1/2012', freq='H')
+        ts = Series(np.random.randn(len(rng)), index=rng)
+
+        ts_local = ts.tz_localize(tzstr)
+
+        result = ts_local.at_time(time(10, 0))
+        expected = ts.at_time(time(10, 0)).tz_localize(tzstr)
+        tm.assert_series_equal(result, expected)
+        assert timezones.tz_compare(result.index.tz, tz)
+
+        t1, t2 = time(10, 0), time(11, 0)
+        result = ts_local.between_time(t1, t2)
+        expected = ts.between_time(t1, t2).tz_localize(tzstr)
+        tm.assert_series_equal(result, expected)
+        assert timezones.tz_compare(result.index.tz, tz)
+
+    @pytest.mark.parametrize('tzstr', ['Europe/Berlin',
+                                       'dateutil/Europe/Berlin'])
+    def test_getitem_pydatetime_tz(self, tzstr):
+        tz = timezones.maybe_get_tz(tzstr)
+
+        index = date_range(start='2012-12-24 16:00', end='2012-12-24 18:00',
+                           freq='H', tz=tzstr)
+        ts = Series(index=index, data=index.hour)
+        time_pandas = Timestamp('2012-12-24 17:00', tz=tzstr)
+
+        dt = datetime(2012, 12, 24, 17, 0)
+        time_datetime = tslib._localize_pydatetime(dt, tz)
+        assert ts[time_pandas] == ts[time_datetime]
diff --git a/pandas/tests/tseries/test_timezones.py b/pandas/tests/tseries/test_timezones.py
index 2630984a7..8f46e0a58 100644
--- a/pandas/tests/tseries/test_timezones.py
+++ b/pandas/tests/tseries/test_timezones.py
@@ -8,7 +8,7 @@ import numpy as np
 from dateutil.parser import parse
 from pytz import NonExistentTimeError
 from distutils.version import LooseVersion
-from dateutil.tz import tzlocal, tzoffset
+from dateutil.tz import tzlocal
 from datetime import datetime, timedelta, tzinfo
 
 import pandas.util.testing as tm
@@ -18,9 +18,9 @@ from pandas.compat import lrange, zip
 from pandas.core.indexes.datetimes import bdate_range, date_range
 from pandas._libs import tslib
 from pandas._libs.tslibs import timezones, conversion
-from pandas import (Index, Series, isna, Timestamp, NaT,
+from pandas import (Index, isna, Timestamp, NaT,
                     DatetimeIndex, to_datetime)
-from pandas.util.testing import assert_series_equal, set_timezone
+from pandas.util.testing import set_timezone
 
 
 class FixedOffset(tzinfo):
@@ -142,17 +142,6 @@ class TestTimeZoneSupportPytz(object):
         pytest.raises(pytz.NonExistentTimeError, dti.tz_localize,
                       self.tzstr('US/Eastern'))
 
-    def test_tz_localize_empty_series(self):
-        # #2248
-
-        ts = Series()
-
-        ts2 = ts.tz_localize('utc')
-        assert ts2.index.tz == pytz.utc
-
-        ts2 = ts.tz_localize(self.tzstr('US/Eastern'))
-        assert self.cmptz(ts2.index.tz, self.tz('US/Eastern'))
-
     def test_create_with_tz(self):
         stamp = Timestamp('3/11/2012 05:00', tz=self.tzstr('US/Eastern'))
         assert stamp.hour == 5
@@ -455,34 +444,6 @@ class TestTimeZoneSupportPytz(object):
         # right is datetime64[ns, tzfile('/usr/share/zoneinfo/US/Eastern')]
         tm.assert_numpy_array_equal(di_test.values, localized.values)
 
-    def test_ambiguous_bool(self):
-        # make sure that we are correctly accepting bool values as ambiguous
-
-        # gh-14402
-        t = Timestamp('2015-11-01 01:00:03')
-        expected0 = Timestamp('2015-11-01 01:00:03-0500', tz='US/Central')
-        expected1 = Timestamp('2015-11-01 01:00:03-0600', tz='US/Central')
-
-        s = Series([t])
-        expected0 = Series([expected0])
-        expected1 = Series([expected1])
-
-        def f():
-            s.dt.tz_localize('US/Central')
-        pytest.raises(pytz.AmbiguousTimeError, f)
-
-        result = s.dt.tz_localize('US/Central', ambiguous=True)
-        assert_series_equal(result, expected0)
-
-        result = s.dt.tz_localize('US/Central', ambiguous=[True])
-        assert_series_equal(result, expected0)
-
-        result = s.dt.tz_localize('US/Central', ambiguous=False)
-        assert_series_equal(result, expected1)
-
-        result = s.dt.tz_localize('US/Central', ambiguous=[False])
-        assert_series_equal(result, expected1)
-
     def test_nonexistent_raise_coerce(self):
         # See issue 13057
         from pytz.exceptions import NonExistentTimeError
@@ -565,34 +526,6 @@ class TestTimeZoneSupportPytz(object):
             assert x == exval
             assert x.tzinfo == exval.tzinfo
 
-    def test_localized_at_time_between_time(self):
-        from datetime import time
-
-        rng = date_range('4/16/2012', '5/1/2012', freq='H')
-        ts = Series(np.random.randn(len(rng)), index=rng)
-
-        ts_local = ts.tz_localize(self.tzstr('US/Eastern'))
-
-        result = ts_local.at_time(time(10, 0))
-        expected = ts.at_time(time(10, 0)).tz_localize(self.tzstr(
-            'US/Eastern'))
-        assert_series_equal(result, expected)
-        assert self.cmptz(result.index.tz, self.tz('US/Eastern'))
-
-        t1, t2 = time(10, 0), time(11, 0)
-        result = ts_local.between_time(t1, t2)
-        expected = ts.between_time(t1,
-                                   t2).tz_localize(self.tzstr('US/Eastern'))
-        assert_series_equal(result, expected)
-        assert self.cmptz(result.index.tz, self.tz('US/Eastern'))
-
-    def test_string_index_alias_tz_aware(self):
-        rng = date_range('1/1/2000', periods=10, tz=self.tzstr('US/Eastern'))
-        ts = Series(np.random.randn(len(rng)), index=rng)
-
-        result = ts['1/3/2000']
-        tm.assert_almost_equal(result, ts[2])
-
     def test_fixed_offset(self):
         dates = [datetime(2000, 1, 1, tzinfo=fixed_off),
                  datetime(2000, 1, 2, tzinfo=fixed_off),
@@ -668,15 +601,6 @@ class TestTimeZoneSupportPytz(object):
         result = dr_tz.shift(1, '10T')
         assert result.tz == dr_tz.tz
 
-    def test_tz_aware_asfreq(self):
-        dr = date_range('2011-12-01', '2012-07-20', freq='D',
-                        tz=self.tzstr('US/Eastern'))
-
-        s = Series(np.random.randn(len(dr)), index=dr)
-
-        # it works!
-        s.asfreq('T')
-
     def test_static_tzinfo(self):
         # it works!
         index = DatetimeIndex([datetime(2012, 1, 1)], tz=self.tzstr('EST'))
@@ -709,28 +633,6 @@ class TestTimeZoneSupportPytz(object):
         assert dr.tz == dr2.tz
         assert dr2.name == 'foo'
 
-    def test_dateutil_tzoffset_support(self):
-        values = [188.5, 328.25]
-        tzinfo = tzoffset(None, 7200)
-        index = [datetime(2012, 5, 11, 11, tzinfo=tzinfo),
-                 datetime(2012, 5, 11, 12, tzinfo=tzinfo)]
-        series = Series(data=values, index=index)
-
-        assert series.index.tz == tzinfo
-
-        # it works! #2443
-        repr(series.index[0])
-
-    def test_getitem_pydatetime_tz(self):
-        index = date_range(start='2012-12-24 16:00', end='2012-12-24 18:00',
-                           freq='H', tz=self.tzstr('Europe/Berlin'))
-        ts = Series(index=index, data=index.hour)
-        time_pandas = Timestamp('2012-12-24 17:00',
-                                tz=self.tzstr('Europe/Berlin'))
-        time_datetime = self.localize(
-            self.tz('Europe/Berlin'), datetime(2012, 12, 24, 17, 0))
-        assert ts[time_pandas] == ts[time_datetime]
-
     def test_index_drop_dont_lose_tz(self):
         # #2621
         ind = date_range("2012-12-01", periods=10, tz="utc")
@@ -1056,33 +958,6 @@ class TestTimeZones(object):
                 tm.assert_index_equal(reset, idx)
                 assert reset.tzinfo is None
 
-    def test_series_tz_localize(self):
-
-        rng = date_range('1/1/2011', periods=100, freq='H')
-        ts = Series(1, index=rng)
-
-        result = ts.tz_localize('utc')
-        assert result.index.tz.zone == 'UTC'
-
-        # Can't localize if already tz-aware
-        rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
-        ts = Series(1, index=rng)
-        tm.assert_raises_regex(TypeError, 'Already tz-aware',
-                               ts.tz_localize, 'US/Eastern')
-
-    def test_series_tz_convert(self):
-        rng = date_range('1/1/2011', periods=200, freq='D', tz='US/Eastern')
-        ts = Series(1, index=rng)
-
-        result = ts.tz_convert('Europe/Berlin')
-        assert result.index.tz.zone == 'Europe/Berlin'
-
-        # can't convert tz-naive
-        rng = date_range('1/1/2011', periods=200, freq='D')
-        ts = Series(1, index=rng)
-        tm.assert_raises_regex(TypeError, "Cannot convert tz-naive",
-                               ts.tz_convert, 'US/Eastern')
-
     def test_tz_convert_roundtrip(self):
         for tz in self.timezones:
             idx1 = date_range(start='2014-01-01', end='2014-12-31', freq='M',
@@ -1127,12 +1002,6 @@ class TestTimeZones(object):
 
     def test_join_aware(self):
         rng = date_range('1/1/2011', periods=10, freq='H')
-        ts = Series(np.random.randn(len(rng)), index=rng)
-
-        ts_utc = ts.tz_localize('utc')
-
-        pytest.raises(Exception, ts.__add__, ts_utc)
-        pytest.raises(Exception, ts_utc.__add__, ts)
 
         # non-overlapping
         rng = date_range("2012-11-15 00:00:00", periods=6, freq="H",
@@ -1144,127 +1013,6 @@ class TestTimeZones(object):
         result = rng.union(rng2)
         assert result.tz.zone == 'UTC'
 
-    def test_series_align_aware(self):
-        idx1 = date_range('2001', periods=5, freq='H', tz='US/Eastern')
-        ser = Series(np.random.randn(len(idx1)), index=idx1)
-        ser_central = ser.tz_convert('US/Central')
-        # # different timezones convert to UTC
-
-        new1, new2 = ser.align(ser_central)
-        assert new1.index.tz == pytz.UTC
-        assert new2.index.tz == pytz.UTC
-
-    def test_append_aware(self):
-        rng1 = date_range('1/1/2011 01:00', periods=1, freq='H',
-                          tz='US/Eastern')
-        rng2 = date_range('1/1/2011 02:00', periods=1, freq='H',
-                          tz='US/Eastern')
-        ts1 = Series([1], index=rng1)
-        ts2 = Series([2], index=rng2)
-        ts_result = ts1.append(ts2)
-
-        exp_index = DatetimeIndex(['2011-01-01 01:00', '2011-01-01 02:00'],
-                                  tz='US/Eastern')
-        exp = Series([1, 2], index=exp_index)
-        assert_series_equal(ts_result, exp)
-        assert ts_result.index.tz == rng1.tz
-
-        rng1 = date_range('1/1/2011 01:00', periods=1, freq='H', tz='UTC')
-        rng2 = date_range('1/1/2011 02:00', periods=1, freq='H', tz='UTC')
-        ts1 = Series([1], index=rng1)
-        ts2 = Series([2], index=rng2)
-        ts_result = ts1.append(ts2)
-
-        exp_index = DatetimeIndex(['2011-01-01 01:00', '2011-01-01 02:00'],
-                                  tz='UTC')
-        exp = Series([1, 2], index=exp_index)
-        assert_series_equal(ts_result, exp)
-        utc = rng1.tz
-        assert utc == ts_result.index.tz
-
-        # GH 7795
-        # different tz coerces to object dtype, not UTC
-        rng1 = date_range('1/1/2011 01:00', periods=1, freq='H',
-                          tz='US/Eastern')
-        rng2 = date_range('1/1/2011 02:00', periods=1, freq='H',
-                          tz='US/Central')
-        ts1 = Series([1], index=rng1)
-        ts2 = Series([2], index=rng2)
-        ts_result = ts1.append(ts2)
-        exp_index = Index([Timestamp('1/1/2011 01:00', tz='US/Eastern'),
-                           Timestamp('1/1/2011 02:00', tz='US/Central')])
-        exp = Series([1, 2], index=exp_index)
-        assert_series_equal(ts_result, exp)
-
-    def test_append_dst(self):
-        rng1 = date_range('1/1/2016 01:00', periods=3, freq='H',
-                          tz='US/Eastern')
-        rng2 = date_range('8/1/2016 01:00', periods=3, freq='H',
-                          tz='US/Eastern')
-        ts1 = Series([1, 2, 3], index=rng1)
-        ts2 = Series([10, 11, 12], index=rng2)
-        ts_result = ts1.append(ts2)
-
-        exp_index = DatetimeIndex(['2016-01-01 01:00', '2016-01-01 02:00',
-                                   '2016-01-01 03:00', '2016-08-01 01:00',
-                                   '2016-08-01 02:00', '2016-08-01 03:00'],
-                                  tz='US/Eastern')
-        exp = Series([1, 2, 3, 10, 11, 12], index=exp_index)
-        assert_series_equal(ts_result, exp)
-        assert ts_result.index.tz == rng1.tz
-
-    def test_append_aware_naive(self):
-        rng1 = date_range('1/1/2011 01:00', periods=1, freq='H')
-        rng2 = date_range('1/1/2011 02:00', periods=1, freq='H',
-                          tz='US/Eastern')
-        ts1 = Series(np.random.randn(len(rng1)), index=rng1)
-        ts2 = Series(np.random.randn(len(rng2)), index=rng2)
-        ts_result = ts1.append(ts2)
-
-        assert ts_result.index.equals(ts1.index.astype(object).append(
-            ts2.index.astype(object)))
-
-        # mixed
-        rng1 = date_range('1/1/2011 01:00', periods=1, freq='H')
-        rng2 = lrange(100)
-        ts1 = Series(np.random.randn(len(rng1)), index=rng1)
-        ts2 = Series(np.random.randn(len(rng2)), index=rng2)
-        ts_result = ts1.append(ts2)
-        assert ts_result.index.equals(ts1.index.astype(object).append(
-            ts2.index))
-
-    def test_series_add_tz_mismatch_converts_to_utc(self):
-        rng = date_range('1/1/2011', periods=10, freq='H', tz='US/Eastern')
-        ts = Series(np.random.randn(len(rng)), index=rng)
-
-        ts_moscow = ts.tz_convert('Europe/Moscow')
-
-        result = ts + ts_moscow
-        assert result.index.tz is pytz.utc
-
-        result = ts_moscow + ts
-        assert result.index.tz is pytz.utc
-
-    def test_arith_utc_convert(self):
-        rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
-
-        perm = np.random.permutation(100)[:90]
-        ts1 = Series(np.random.randn(90),
-                     index=rng.take(perm).tz_convert('US/Eastern'))
-
-        perm = np.random.permutation(100)[:90]
-        ts2 = Series(np.random.randn(90),
-                     index=rng.take(perm).tz_convert('Europe/Berlin'))
-
-        result = ts1 + ts2
-
-        uts1 = ts1.tz_convert('utc')
-        uts2 = ts2.tz_convert('utc')
-        expected = uts1 + uts2
-
-        assert result.index.tz == pytz.UTC
-        assert_series_equal(result, expected)
-
     def test_intersection(self):
         rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
 

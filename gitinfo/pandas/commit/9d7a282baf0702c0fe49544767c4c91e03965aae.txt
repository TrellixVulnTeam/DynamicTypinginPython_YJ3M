commit 9d7a282baf0702c0fe49544767c4c91e03965aae
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Thu Aug 15 05:44:10 2019 -0700

    CLN: simplify comparison method, docstring cleanups (#27923)

diff --git a/pandas/core/computation/common.py b/pandas/core/computation/common.py
index b8e212fd2..2a4277e4e 100644
--- a/pandas/core/computation/common.py
+++ b/pandas/core/computation/common.py
@@ -2,7 +2,7 @@ from functools import reduce
 
 import numpy as np
 
-import pandas as pd
+from pandas._config import get_option
 
 # A token value Python's tokenizer probably will never use.
 _BACKTICK_QUOTED_STRING = 100
@@ -11,7 +11,7 @@ _BACKTICK_QUOTED_STRING = 100
 def _ensure_decoded(s):
     """ if we have bytes, decode them to unicode """
     if isinstance(s, (np.bytes_, bytes)):
-        s = s.decode(pd.get_option("display.encoding"))
+        s = s.decode(get_option("display.encoding"))
     return s
 
 
diff --git a/pandas/core/computation/expressions.py b/pandas/core/computation/expressions.py
index d9dc194d4..0ecf56cf6 100644
--- a/pandas/core/computation/expressions.py
+++ b/pandas/core/computation/expressions.py
@@ -203,17 +203,18 @@ def _bool_arith_check(
 
 
 def evaluate(op, op_str, a, b, use_numexpr=True, **eval_kwargs):
-    """ evaluate and return the expression of the op on a and b
-
-        Parameters
-        ----------
-
-        op :    the actual operand
-        op_str: the string version of the op
-        a :     left operand
-        b :     right operand
-        use_numexpr : whether to try to use numexpr (default True)
-        """
+    """
+    Evaluate and return the expression of the op on a and b.
+
+    Parameters
+    ----------
+    op : the actual operand
+    op_str : the string version of the op
+    a : left operand
+    b : right operand
+    use_numexpr : bool, default True
+        Whether to try to use numexpr.
+    """
 
     use_numexpr = use_numexpr and _bool_arith_check(op_str, a, b)
     if use_numexpr:
@@ -222,16 +223,17 @@ def evaluate(op, op_str, a, b, use_numexpr=True, **eval_kwargs):
 
 
 def where(cond, a, b, use_numexpr=True):
-    """ evaluate the where condition cond on a and b
-
-        Parameters
-        ----------
-
-        cond : a boolean array
-        a :    return if cond is True
-        b :    return if cond is False
-        use_numexpr : whether to try to use numexpr (default True)
-        """
+    """
+    Evaluate the where condition cond on a and b
+
+    Parameters
+    ----------
+    cond : ndarray[bool]
+    a : return if cond is True
+    b : return if cond is False
+    use_numexpr : bool, default True
+        Whether to try to use numexpr.
+    """
 
     if use_numexpr:
         return _where(cond, a, b)
diff --git a/pandas/core/computation/ops.py b/pandas/core/computation/ops.py
index 2bf09a553..b49220ae7 100644
--- a/pandas/core/computation/ops.py
+++ b/pandas/core/computation/ops.py
@@ -51,8 +51,9 @@ _LOCAL_TAG = "__pd_eval_local_"
 
 
 class UndefinedVariableError(NameError):
-
-    """NameError subclass for local variables."""
+    """
+    NameError subclass for local variables.
+    """
 
     def __init__(self, name, is_local):
         if is_local:
@@ -191,8 +192,8 @@ _bool_op_map = {"not": "~", "and": "&", "or": "|"}
 
 
 class Op:
-
-    """Hold an operator of arbitrary arity
+    """
+    Hold an operator of arbitrary arity.
     """
 
     def __init__(self, op, operands, *args, **kwargs):
@@ -204,8 +205,9 @@ class Op:
         return iter(self.operands)
 
     def __repr__(self):
-        """Print a generic n-ary operator and its operands using infix
-        notation"""
+        """
+        Print a generic n-ary operator and its operands using infix notation.
+        """
         # recurse over the operands
         parened = ("({0})".format(pprint_thing(opr)) for opr in self.operands)
         return pprint_thing(" {0} ".format(self.op).join(parened))
@@ -296,7 +298,8 @@ for d in (_cmp_ops_dict, _bool_ops_dict, _arith_ops_dict):
 
 
 def _cast_inplace(terms, acceptable_dtypes, dtype):
-    """Cast an expression inplace.
+    """
+    Cast an expression inplace.
 
     Parameters
     ----------
@@ -304,7 +307,6 @@ def _cast_inplace(terms, acceptable_dtypes, dtype):
         The expression that should cast.
     acceptable_dtypes : list of acceptable numpy.dtype
         Will not cast if term's dtype in this list.
-
     dtype : str or numpy.dtype
         The dtype to cast to.
     """
@@ -325,8 +327,8 @@ def is_term(obj):
 
 
 class BinOp(Op):
-
-    """Hold a binary operator and its operands
+    """
+    Hold a binary operator and its operands.
 
     Parameters
     ----------
@@ -355,7 +357,8 @@ class BinOp(Op):
             )
 
     def __call__(self, env):
-        """Recursively evaluate an expression in Python space.
+        """
+        Recursively evaluate an expression in Python space.
 
         Parameters
         ----------
@@ -377,7 +380,8 @@ class BinOp(Op):
         return self.func(left, right)
 
     def evaluate(self, env, engine, parser, term_type, eval_in_python):
-        """Evaluate a binary operation *before* being passed to the engine.
+        """
+        Evaluate a binary operation *before* being passed to the engine.
 
         Parameters
         ----------
diff --git a/pandas/core/ops/__init__.py b/pandas/core/ops/__init__.py
index 843f12c20..26672593f 100644
--- a/pandas/core/ops/__init__.py
+++ b/pandas/core/ops/__init__.py
@@ -32,7 +32,6 @@ from pandas.core.dtypes.common import (
     is_period_dtype,
     is_scalar,
     is_timedelta64_dtype,
-    needs_i8_conversion,
 )
 from pandas.core.dtypes.generic import (
     ABCDataFrame,
@@ -758,17 +757,12 @@ def _comp_method_SERIES(cls, op, special):
     code duplication.
     """
     op_name = _get_op_name(op, special)
-    masker = _gen_eval_kwargs(op_name).get("masker", False)
 
     def na_op(x, y):
         # TODO:
-        # should have guarantess on what x, y can be type-wise
+        # should have guarantees on what x, y can be type-wise
         # Extension Dtypes are not called here
 
-        # Checking that cases that were once handled here are no longer
-        # reachable.
-        assert not (is_categorical_dtype(y) and not is_scalar(y))
-
         if is_object_dtype(x.dtype):
             result = _comp_method_OBJECT_ARRAY(op, x, y)
 
@@ -776,32 +770,11 @@ def _comp_method_SERIES(cls, op, special):
             return invalid_comparison(x, y, op)
 
         else:
-
-            # we want to compare like types
-            # we only want to convert to integer like if
-            # we are not NotImplemented, otherwise
-            # we would allow datetime64 (but viewed as i8) against
-            # integer comparisons
-
-            # we have a datetime/timedelta and may need to convert
-            assert not needs_i8_conversion(x)
-            mask = None
-            if not is_scalar(y) and needs_i8_conversion(y):
-                mask = isna(x) | isna(y)
-                y = y.view("i8")
-                x = x.view("i8")
-
-            method = getattr(x, op_name, None)
-            if method is not None:
-                with np.errstate(all="ignore"):
-                    result = method(y)
-                if result is NotImplemented:
-                    return invalid_comparison(x, y, op)
-            else:
-                result = op(x, y)
-
-            if mask is not None and mask.any():
-                result[mask] = masker
+            method = getattr(x, op_name)
+            with np.errstate(all="ignore"):
+                result = method(y)
+            if result is NotImplemented:
+                return invalid_comparison(x, y, op)
 
         return result
 

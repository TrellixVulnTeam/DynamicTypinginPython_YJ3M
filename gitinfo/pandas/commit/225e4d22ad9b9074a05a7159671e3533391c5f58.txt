commit 225e4d22ad9b9074a05a7159671e3533391c5f58
Author: y-p <yoval@gmx.com>
Date:   Wed Nov 28 22:50:33 2012 +0200

    ENH: enhance useability of options API
    
    - Only 4 functions get,set,reset,describe  are now defined
    - All functions accept a regexp as input and will
      try to do the right thing accordingly.
    
      For example: get_option("max_rows") now returns
      the value of print_config.max_rows.
    - keys are now case-insensitive.

diff --git a/doc/source/v0.10.0.txt b/doc/source/v0.10.0.txt
index 2571cf716..7d62ddc0d 100644
--- a/doc/source/v0.10.0.txt
+++ b/doc/source/v0.10.0.txt
@@ -117,10 +117,11 @@ API changes
 
   - New API functions for working with pandas options (GH2097_):
 
-    - ``get_option`` / ``set_option`` - get/set the value of an option.
-    - ``reset_option`` / ``reset_options`` - reset an options / all options to their default value.
-    - ``describe_options`` - print a description of one or more option. When called  with no arguments. print all registered options.
-    - ``set_printoptions`` is now deprecated (but functioning), the print options now live under "print_config.XYZ". For example:
+    - ``get_option`` / ``set_option`` - get/set the value of an option. Partial names are accepted.
+    - ``reset_option`` - reset one or more options to their default value. Partial names are accepted.
+    - ``describe_option`` - print a description of one or more options. When called  with no arguments. print all registered options.
+
+    Note: ``set_printoptions`` is now deprecated (but functioning), the print options now live under "print_config.XYZ". For example:
 
 
     .. ipython:: python
diff --git a/pandas/core/api.py b/pandas/core/api.py
index 469f36831..3da591f7a 100644
--- a/pandas/core/api.py
+++ b/pandas/core/api.py
@@ -31,4 +31,4 @@ from pandas.core.daterange import DateRange # deprecated
 import pandas.core.datetools as datetools
 
 from pandas.core.config import get_option,set_option,reset_option,\
-                               reset_options,describe_options
+                               describe_option
diff --git a/pandas/core/config.py b/pandas/core/config.py
index 09c1a5f37..dff60162c 100644
--- a/pandas/core/config.py
+++ b/pandas/core/config.py
@@ -9,6 +9,8 @@ Overview
 
 This module supports the following requirements:
 - options are referenced using keys in dot.notation, e.g. "x.y.option - z".
+- keys are case-insensitive.
+- functions should accept partial/regex keys, when unambiguous.
 - options can be registered by modules at import time.
 - options can be registered at init-time (via core.config_init)
 - options have a default value, and (optionally) a description and
@@ -24,6 +26,7 @@ This module supports the following requirements:
 - the user can set / get / reset or ask for the description of an option.
 - a developer can register and mark an option as deprecated.
 
+
 Implementation
 ==============
 
@@ -56,17 +59,18 @@ RegisteredOption = namedtuple("RegisteredOption", "key defval doc validator")
 __deprecated_options = {} # holds deprecated option metdata
 __registered_options = {} # holds registered option metdata
 __global_config = {}      # holds the current values for registered options
+__reserved_keys = ["all"] # keys which have a special meaning
 
 ##########################################
 # User API
 
 
-def get_option(key):
+def get_option(pat):
     """Retrieves the value of the specified option
 
     Parameters
     ----------
-    key - str, a fully - qualified option name , e.g. "x.y.z.option"
+    pat - str/regexp which should match a single option.
 
     Returns
     -------
@@ -77,7 +81,16 @@ def get_option(key):
     KeyError if no such option exists
     """
 
+    keys = _select_options(pat)
+    if len(keys) == 0:
+        _warn_if_deprecated(pat)
+        raise KeyError("No such keys(s)")
+    if len(keys) > 1:
+        raise KeyError("Pattern matched multiple keys")
+    key = keys[0]
+
     _warn_if_deprecated(key)
+
     key = _translate_key(key)
 
     # walk the nested dict
@@ -86,12 +99,12 @@ def get_option(key):
     return root[k]
 
 
-def set_option(key, value):
+def set_option(pat, value):
     """Sets the value of the specified option
 
     Parameters
     ----------
-    key - str, a fully - qualified option name , e.g. "x.y.z.option"
+    pat - str/regexp which should match a single option.
 
     Returns
     -------
@@ -101,6 +114,14 @@ def set_option(key, value):
     ------
     KeyError if no such option exists
     """
+    keys = _select_options(pat)
+    if len(keys) == 0:
+        _warn_if_deprecated(pat)
+        raise KeyError("No such keys(s)")
+    if len(keys) > 1:
+        raise KeyError("Pattern matched multiple keys")
+    key = keys[0]
+
     _warn_if_deprecated(key)
     key = _translate_key(key)
 
@@ -110,31 +131,14 @@ def set_option(key, value):
 
     # walk the nested dict
     root, k = _get_root(key)
-
     root[k] = value
 
 
-def _get_option_desription(key):
-    """Prints the description associated with the specified option
-
-    Parameters
-    ----------
-    key - str, a fully - qualified option name , e.g. "x.y.z.option"
-
-    Returns
-    -------
-    None
-
-    Raises
-    ------
-    KeyError if no such option exists
-    """
-    _warn_if_deprecated(key)
-    key = _translate_key(key)
-
-def describe_options(pat="",_print_desc=True):
+def describe_option(pat="",_print_desc=True):
     """ Prints the description for one or more registered options
 
+    Call with not arguments to get a listing for all registered options.
+
     Parameters
     ----------
     pat - str, a regexp pattern. All matching keys will have their
@@ -150,44 +154,47 @@ def describe_options(pat="",_print_desc=True):
     is False
 
     """
-    s=u""
-    if pat in __registered_options.keys(): # exact key name?
-        s = _build_option_description(pat)
-    else:
-        for k in sorted(__registered_options.keys()): # filter by pat
-            if re.search(pat,k):
-                s += _build_option_description(k)
-
-    if s == u"":
+    keys = _select_options(pat)
+    if len(keys) == 0:
         raise KeyError("No such keys(s)")
 
+    s=u""
+    for k in keys: # filter by pat
+        s += _build_option_description(k)
+
     if _print_desc:
         print(s)
     else:
         return(s)
 
-def reset_option(key):
-    """ Reset a single option to it's default value """
-    set_option(key, __registered_options[key].defval)
+def reset_option(pat):
+    """Reset one or more options to their default value.
 
-
-def reset_options(prefix=""):
-    """ Resets all registered options to their default value
+    pass "all" as argument to reset all options.
 
     Parameters
     ----------
-    prefix - str,  if specified only options matching `prefix`* will be reset
+    pat - str/regex  if specified only options matching `prefix`* will be reset
 
     Returns
     -------
     None
 
     """
+    keys = _select_options(pat)
 
-    for k in __registered_options.keys():
-        if k[:len(prefix)] == prefix:
-            reset_option(k)
+    if pat == u"":
+        raise ValueError("You must provide a non-empty pattern")
 
+    if len(keys) == 0:
+        raise KeyError("No such keys(s)")
+
+    if len(keys) > 1 and len(pat)<4 and pat != "all":
+        raise ValueError("You must specify at least 4 characters "
+                         "when resetting multiple keys")
+
+    for k in keys:
+        set_option(k, __registered_options[k].defval)
 
 ######################################################
 # Functions for use by pandas developers, in addition to User - api
@@ -214,9 +221,12 @@ def register_option(key, defval, doc="", validator=None):
 
     """
 
+    key=key.lower()
 
     if key in __registered_options:
         raise KeyError("Option '%s' has already been registered" % key)
+    if key in __reserved_keys:
+        raise KeyError("Option '%s' is a reserved key" % key)
 
     # the default value should be legal
     if validator:
@@ -282,6 +292,8 @@ def deprecate_option(key, msg=None, rkey=None, removal_ver=None):
     KeyError - if key has already been deprecated.
 
     """
+    key=key.lower()
+
     if key in __deprecated_options:
         raise KeyError("Option '%s' has already been defined as deprecated." % key)
 
@@ -290,6 +302,17 @@ def deprecate_option(key, msg=None, rkey=None, removal_ver=None):
 ################################
 # functions internal to the module
 
+def _select_options(pat):
+    """returns a list of keys matching `pat`
+
+    if pat=="all", returns all registered options
+    """
+    keys = sorted(__registered_options.keys())
+    if pat == "all": # reserved key
+        return keys
+
+    return [k for k in keys if re.search(pat,k,re.I)]
+
 
 def _get_root(key):
     path = key.split(".")
@@ -301,6 +324,8 @@ def _get_root(key):
 
 def _is_deprecated(key):
     """ Returns True if the given option has been deprecated """
+
+    key = key.lower()
     return __deprecated_options.has_key(key)
 
 
@@ -356,6 +381,7 @@ def _warn_if_deprecated(key):
     -------
     bool - True if `key` is deprecated, False otherwise.
     """
+
     d = _get_deprecated_option(key)
     if d:
         if d.msg:
diff --git a/pandas/core/format.py b/pandas/core/format.py
index ba9058143..f986e2226 100644
--- a/pandas/core/format.py
+++ b/pandas/core/format.py
@@ -11,8 +11,7 @@ except:
 from pandas.core.common import adjoin, isnull, notnull
 from pandas.core.index import MultiIndex, _ensure_index
 from pandas.util import py3compat
-from pandas.core.config import get_option, set_option, \
-                               reset_options
+from pandas.core.config import get_option, set_option, reset_option
 import pandas.core.common as com
 import pandas.lib as lib
 
@@ -985,7 +984,7 @@ def set_printoptions(precision=None, column_space=None, max_rows=None,
         set_option("print_config.encoding", encoding)
 
 def reset_printoptions():
-    reset_options("print_config.")
+    reset_option("^print_config\.")
 
 def detect_console_encoding():
     """
diff --git a/pandas/tests/test_config.py b/pandas/tests/test_config.py
index 862b0d29f..6b91fa1e7 100644
--- a/pandas/tests/test_config.py
+++ b/pandas/tests/test_config.py
@@ -33,8 +33,7 @@ class TestConfig(unittest.TestCase):
         self.assertTrue(hasattr(pd, 'get_option'))
         self.assertTrue(hasattr(pd, 'set_option'))
         self.assertTrue(hasattr(pd, 'reset_option'))
-        self.assertTrue(hasattr(pd, 'reset_options'))
-        self.assertTrue(hasattr(pd, 'describe_options'))
+        self.assertTrue(hasattr(pd, 'describe_option'))
 
     def test_register_option(self):
         self.cf.register_option('a', 1, 'doc')
@@ -55,7 +54,7 @@ class TestConfig(unittest.TestCase):
         self.cf.register_option('k.b.c.d1', 1, 'doc')
         self.cf.register_option('k.b.c.d2', 1, 'doc')
 
-    def test_describe_options(self):
+    def test_describe_option(self):
         self.cf.register_option('a', 1, 'doc')
         self.cf.register_option('b', 1, 'doc2')
         self.cf.deprecate_option('b')
@@ -67,31 +66,52 @@ class TestConfig(unittest.TestCase):
         self.cf.deprecate_option('g.h',rkey="blah")
 
         # non-existent keys raise KeyError
-        self.assertRaises(KeyError, self.cf.describe_options, 'no.such.key')
+        self.assertRaises(KeyError, self.cf.describe_option, 'no.such.key')
 
         # we can get the description for any key we registered
-        self.assertTrue('doc' in self.cf.describe_options('a',_print_desc=False))
-        self.assertTrue('doc2' in self.cf.describe_options('b',_print_desc=False))
-        self.assertTrue('precated' in self.cf.describe_options('b',_print_desc=False))
+        self.assertTrue('doc' in self.cf.describe_option('a',_print_desc=False))
+        self.assertTrue('doc2' in self.cf.describe_option('b',_print_desc=False))
+        self.assertTrue('precated' in self.cf.describe_option('b',_print_desc=False))
 
-        self.assertTrue('doc3' in self.cf.describe_options('c.d.e1',_print_desc=False))
-        self.assertTrue('doc4' in self.cf.describe_options('c.d.e2',_print_desc=False))
+        self.assertTrue('doc3' in self.cf.describe_option('c.d.e1',_print_desc=False))
+        self.assertTrue('doc4' in self.cf.describe_option('c.d.e2',_print_desc=False))
 
         # if no doc is specified we get a default message
         # saying "description not available"
-        self.assertTrue('vailable' in self.cf.describe_options('f',_print_desc=False))
-        self.assertTrue('vailable' in self.cf.describe_options('g.h',_print_desc=False))
-        self.assertTrue('precated' in self.cf.describe_options('g.h',_print_desc=False))
-        self.assertTrue('blah' in self.cf.describe_options('g.h',_print_desc=False))
+        self.assertTrue('vailable' in self.cf.describe_option('f',_print_desc=False))
+        self.assertTrue('vailable' in self.cf.describe_option('g.h',_print_desc=False))
+        self.assertTrue('precated' in self.cf.describe_option('g.h',_print_desc=False))
+        self.assertTrue('blah' in self.cf.describe_option('g.h',_print_desc=False))
+
+    def test_case_insensitive(self):
+        self.cf.register_option('KanBAN', 1, 'doc')
+
+        self.assertTrue('doc' in self.cf.describe_option('kanbaN',_print_desc=False))
+        self.assertEqual(self.cf.get_option('kanBaN'), 1)
+        self.cf.set_option('KanBan',2)
+        self.assertEqual(self.cf.get_option('kAnBaN'), 2)
+
+
+        # gets of non-existent keys fail
+        self.assertRaises(KeyError, self.cf.get_option, 'no_such_option')
+        self.cf.deprecate_option('KanBan')
+
+        # testing warning with catch_warning was only added in 2.6
+        self.assertTrue(self.cf._is_deprecated('kAnBaN'))
+
+    def test_set_option(self):
+        self.cf.register_option('a', 1, 'doc')
+        self.cf.register_option('b.c', 'hullo', 'doc2')
+        self.cf.register_option('b.b', None, 'doc2')
 
     def test_get_option(self):
         self.cf.register_option('a', 1, 'doc')
-        self.cf.register_option('b.a', 'hullo', 'doc2')
+        self.cf.register_option('b.c', 'hullo', 'doc2')
         self.cf.register_option('b.b', None, 'doc2')
 
         # gets of existing keys succeed
         self.assertEqual(self.cf.get_option('a'), 1)
-        self.assertEqual(self.cf.get_option('b.a'), 'hullo')
+        self.assertEqual(self.cf.get_option('b.c'), 'hullo')
         self.assertTrue(self.cf.get_option('b.b') is None)
 
         # gets of non-existent keys fail
@@ -99,86 +119,86 @@ class TestConfig(unittest.TestCase):
 
     def test_set_option(self):
         self.cf.register_option('a', 1, 'doc')
-        self.cf.register_option('b.a', 'hullo', 'doc2')
+        self.cf.register_option('b.c', 'hullo', 'doc2')
         self.cf.register_option('b.b', None, 'doc2')
 
         self.assertEqual(self.cf.get_option('a'), 1)
-        self.assertEqual(self.cf.get_option('b.a'), 'hullo')
+        self.assertEqual(self.cf.get_option('b.c'), 'hullo')
         self.assertTrue(self.cf.get_option('b.b') is None)
 
         self.cf.set_option('a', 2)
-        self.cf.set_option('b.a', 'wurld')
+        self.cf.set_option('b.c', 'wurld')
         self.cf.set_option('b.b', 1.1)
 
         self.assertEqual(self.cf.get_option('a'), 2)
-        self.assertEqual(self.cf.get_option('b.a'), 'wurld')
+        self.assertEqual(self.cf.get_option('b.c'), 'wurld')
         self.assertEqual(self.cf.get_option('b.b'), 1.1)
 
         self.assertRaises(KeyError, self.cf.set_option, 'no.such.key', None)
 
     def test_validation(self):
         self.cf.register_option('a', 1, 'doc', validator=self.cf.is_int)
-        self.cf.register_option('b.a', 'hullo', 'doc2',
+        self.cf.register_option('b.c', 'hullo', 'doc2',
                                 validator=self.cf.is_text)
         self.assertRaises(ValueError, self.cf.register_option, 'a.b.c.d2',
                           'NO', 'doc', validator=self.cf.is_int)
 
         self.cf.set_option('a', 2)  # int is_int
-        self.cf.set_option('b.a', 'wurld')  # str is_str
+        self.cf.set_option('b.c', 'wurld')  # str is_str
 
         self.assertRaises(ValueError, self.cf.set_option, 'a', None)  # None not is_int
         self.assertRaises(ValueError, self.cf.set_option, 'a', 'ab')
-        self.assertRaises(ValueError, self.cf.set_option, 'b.a', 1)
+        self.assertRaises(ValueError, self.cf.set_option, 'b.c', 1)
 
     def test_reset_option(self):
         self.cf.register_option('a', 1, 'doc', validator=self.cf.is_int)
-        self.cf.register_option('b.a', 'hullo', 'doc2',
+        self.cf.register_option('b.c', 'hullo', 'doc2',
                                 validator=self.cf.is_str)
         self.assertEqual(self.cf.get_option('a'), 1)
-        self.assertEqual(self.cf.get_option('b.a'), 'hullo')
+        self.assertEqual(self.cf.get_option('b.c'), 'hullo')
 
         self.cf.set_option('a', 2)
-        self.cf.set_option('b.a', 'wurld')
+        self.cf.set_option('b.c', 'wurld')
         self.assertEqual(self.cf.get_option('a'), 2)
-        self.assertEqual(self.cf.get_option('b.a'), 'wurld')
+        self.assertEqual(self.cf.get_option('b.c'), 'wurld')
 
         self.cf.reset_option('a')
         self.assertEqual(self.cf.get_option('a'), 1)
-        self.assertEqual(self.cf.get_option('b.a'), 'wurld')
-        self.cf.reset_option('b.a')
+        self.assertEqual(self.cf.get_option('b.c'), 'wurld')
+        self.cf.reset_option('b.c')
         self.assertEqual(self.cf.get_option('a'), 1)
-        self.assertEqual(self.cf.get_option('b.a'), 'hullo')
+        self.assertEqual(self.cf.get_option('b.c'), 'hullo')
 
-    def test_reset_options(self):
+    def test_reset_option_all(self):
         self.cf.register_option('a', 1, 'doc', validator=self.cf.is_int)
-        self.cf.register_option('b.a', 'hullo', 'doc2',
+        self.cf.register_option('b.c', 'hullo', 'doc2',
                                 validator=self.cf.is_str)
         self.assertEqual(self.cf.get_option('a'), 1)
-        self.assertEqual(self.cf.get_option('b.a'), 'hullo')
+        self.assertEqual(self.cf.get_option('b.c'), 'hullo')
 
         self.cf.set_option('a', 2)
-        self.cf.set_option('b.a', 'wurld')
+        self.cf.set_option('b.c', 'wurld')
         self.assertEqual(self.cf.get_option('a'), 2)
-        self.assertEqual(self.cf.get_option('b.a'), 'wurld')
+        self.assertEqual(self.cf.get_option('b.c'), 'wurld')
 
-        self.cf.reset_options()
+        self.cf.reset_option("all")
         self.assertEqual(self.cf.get_option('a'), 1)
-        self.assertEqual(self.cf.get_option('b.a'), 'hullo')
+        self.assertEqual(self.cf.get_option('b.c'), 'hullo')
 
 
     def test_deprecate_option(self):
         import sys
-        self.cf.deprecate_option('c')  # we can deprecate non-existent options
+        self.cf.deprecate_option('foo')  # we can deprecate non-existent options
 
         # testing warning with catch_warning was only added in 2.6
         if sys.version_info[:2]<(2,6):
             raise nose.SkipTest()
 
-        self.assertTrue(self.cf._is_deprecated('c'))
+        self.assertTrue(self.cf._is_deprecated('foo'))
         with warnings.catch_warnings(record=True) as w:
             warnings.simplefilter('always')
             try:
-                self.cf.get_option('c')
+                self.cf.get_option('foo')
             except KeyError:
                 pass
             else:
@@ -188,8 +208,8 @@ class TestConfig(unittest.TestCase):
             self.assertTrue('deprecated' in str(w[-1]))  # we get the default message
 
         self.cf.register_option('a', 1, 'doc', validator=self.cf.is_int)
-        self.cf.register_option('b.a', 'hullo', 'doc2')
-        self.cf.register_option('c', 'hullo', 'doc2')
+        self.cf.register_option('b.c', 'hullo', 'doc2')
+        self.cf.register_option('foo', 'hullo', 'doc2')
 
         self.cf.deprecate_option('a', removal_ver='nifty_ver')
         with warnings.catch_warnings(record=True) as w:
@@ -202,10 +222,10 @@ class TestConfig(unittest.TestCase):
 
             self.assertRaises(KeyError, self.cf.deprecate_option, 'a')  # can't depr. twice
 
-        self.cf.deprecate_option('b.a', 'zounds!')
+        self.cf.deprecate_option('b.c', 'zounds!')
         with warnings.catch_warnings(record=True) as w:
             warnings.simplefilter('always')
-            self.cf.get_option('b.a')
+            self.cf.get_option('b.c')
 
             self.assertEqual(len(w), 1)  # should have raised one warning
             self.assertTrue('zounds!' in str(w[-1]))  # we get the custom message
@@ -252,8 +272,8 @@ class TestConfig(unittest.TestCase):
 
         self.assertEqual(self.cf.get_option('base.a'), 3)
         self.assertEqual(self.cf.get_option('base.b'), 4)
-        self.assertTrue('doc1' in self.cf.describe_options('base.a',_print_desc=False))
-        self.assertTrue('doc2' in self.cf.describe_options('base.b',_print_desc=False))
+        self.assertTrue('doc1' in self.cf.describe_option('base.a',_print_desc=False))
+        self.assertTrue('doc2' in self.cf.describe_option('base.b',_print_desc=False))
 
         self.cf.reset_option('base.a')
         self.cf.reset_option('base.b')

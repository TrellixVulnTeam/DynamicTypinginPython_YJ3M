commit 1e07af72bccc16152b3d59252a751ba5b6894456
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Sep 30 20:15:36 2012 -0400

    ENH: enable downcasting int64 to int types that fit

diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index aa189c9e8..65ee3872f 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -201,6 +201,7 @@ def _read(filepath_or_buffer, kwds):
 def read_csv(filepath_or_buffer,
              sep=',',
              engine='c',
+             as_recarray=False,
              dialect=None,
              header=0,
              index_col=None,
@@ -208,6 +209,8 @@ def read_csv(filepath_or_buffer,
              skiprows=None,
              na_values=None,
              na_filter=True,
+             compact_ints=False,
+             use_unsigned=False,
              keep_default_na=True,
              thousands=None,
              comment=None,
@@ -230,6 +233,7 @@ def read_csv(filepath_or_buffer,
                 names=names, skiprows=skiprows,
                 na_values=na_values,
                 na_filter=na_filter,
+                compact_ints=compact_ints, use_unsigned=use_unsigned,
                 keep_default_na=keep_default_na,
                 thousands=thousands,
                 comment=comment, parse_dates=parse_dates,
@@ -240,7 +244,7 @@ def read_csv(filepath_or_buffer,
                 converters=converters, verbose=verbose,
                 delimiter=delimiter, encoding=encoding,
                 squeeze=squeeze,
-                engine=engine)
+                engine=engine, as_recarray=as_recarray)
 
     # Alias sep -> delimiter.
     sep = kwds.pop('sep')
@@ -433,6 +437,8 @@ class TextFileReader(object):
                  skipinitialspace=False,
                  squeeze=False,
                  as_recarray=False,
+                 compact_ints=False,
+                 use_unsigned=False,
                  factorize=True,
                  **kwds):
 
@@ -501,6 +507,8 @@ class TextFileReader(object):
         self.verbose = verbose
         self.warn_bad_lines = warn_bad_lines
         self.error_bad_lines = error_bad_lines
+        self.compact_ints = compact_ints
+        self.use_unsigned = use_unsigned
 
         # miscellanea
         self.kwds = kwds
@@ -584,6 +592,8 @@ class TextFileReader(object):
         if kind == 'c':
             params.update(warn_bad_lines=self.warn_bad_lines,
                           error_bad_lines=self.error_bad_lines,
+                          use_unsigned=self.use_unsigned,
+                          compact_ints=self.compact_ints,
                           as_recarray=self.as_recarray,
                           factorize=self.factorize)
 
@@ -609,6 +619,10 @@ class TextFileReader(object):
         # index = None
 
         ret = self._engine.read(nrows)
+
+        if self.as_recarray:
+            return ret
+
         index, columns, col_dict = ret
 
         # May alter columns / col_dict
diff --git a/pandas/io/tests/test_cparser.py b/pandas/io/tests/test_cparser.py
index bb9a0e1e4..07a345fbb 100644
--- a/pandas/io/tests/test_cparser.py
+++ b/pandas/io/tests/test_cparser.py
@@ -195,6 +195,7 @@ class TestCParser(unittest.TestCase):
     def test_na_substitution(self):
         pass
 
+
 def assert_array_dicts_equal(left, right):
     for k, v in left.iteritems():
         assert(np.array_equal(v, right[k]))
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index 0e3f0c563..f36f048ab 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -1527,6 +1527,22 @@ class TestCParser(ParserTests, unittest.TestCase):
         kwds['engine'] = 'c'
         return read_table(*args, **kwds)
 
+    def test_compact_ints(self):
+        data = ('0,1,0,0\n'
+                '1,1,0,0\n'
+                '0,1,0,1')
+
+        result = read_csv(StringIO(data), delimiter=',', header=None,
+                          compact_ints=True, as_recarray=True)
+        ex_dtype = np.dtype([(str(i), 'i1') for i in range(4)])
+        self.assertEqual(result.dtype, ex_dtype)
+
+        result = read_csv(StringIO(data), delimiter=',', header=None,
+                          as_recarray=True, compact_ints=True,
+                          use_unsigned=True)
+        ex_dtype = np.dtype([(str(i), 'u1') for i in range(4)])
+        self.assertEqual(result.dtype, ex_dtype)
+
 
 class TestParseSQL(unittest.TestCase):
 
diff --git a/pandas/src/parser.pyx b/pandas/src/parser.pyx
index 45c4f533e..0c72ece1a 100644
--- a/pandas/src/parser.pyx
+++ b/pandas/src/parser.pyx
@@ -28,12 +28,21 @@ from khash cimport *
 
 cdef extern from "stdint.h":
     enum: UINT8_MAX
+    enum: UINT16_MAX
+    enum: UINT32_MAX
     enum: INT8_MIN
-    enum: INT64_MAX
-    enum: INT64_MIN
+    enum: INT8_MAX
+    enum: INT16_MIN
+    enum: INT16_MAX
     enum: INT32_MAX
     enum: INT32_MIN
+    enum: INT64_MAX
+    enum: INT64_MIN
 
+try:
+    basestring
+except NameError:
+    basestring = str
 
 cdef extern from "Python.h":
     ctypedef struct FILE
@@ -204,6 +213,7 @@ cdef class TextReader:
         object header, names
         object low_memory
         object skiprows
+        object compact_ints, use_unsigned
 
     def __cinit__(self, source,
                   delimiter=b',',
@@ -235,7 +245,8 @@ cdef class TextReader:
 
                   na_filter=True,
                   na_values=None,
-
+                  compact_ints=False,
+                  use_unsigned=False,
                   low_memory=False,
                   skiprows=None,
                   skip_footer=0,
@@ -310,6 +321,9 @@ cdef class TextReader:
         self.na_filter = na_filter
         self.as_recarray = as_recarray
 
+        self.compact_ints = compact_ints
+        self.use_unsigned = use_unsigned
+
         self.verbose = verbose
         self.low_memory = low_memory
 
@@ -514,7 +528,6 @@ cdef class TextReader:
 
         self._end_clock('Type conversion')
 
-
         return columns
 
     def debug_print(self):
@@ -581,6 +594,9 @@ cdef class TextReader:
             if upcast_na and na_count > 0:
                 col_res = _maybe_upcast(col_res)
 
+            if issubclass(col_res.dtype.type, np.integer) and self.compact_ints:
+                col_res = downcast_int64(col_res, self.use_unsigned)
+
             if col_res is None:
                 raise Exception('Unable to parse column %d' % i)
 
@@ -912,7 +928,77 @@ cdef raise_parser_error(object base, parser_t *parser):
 
     raise CParserError(message)
 
+def downcast_int64(ndarray[int64_t] arr, bint use_unsigned=0):
+    cdef:
+        Py_ssize_t i, n = len(arr)
+        int64_t mx = INT64_MIN + 1, mn = INT64_MAX
+        int64_t NA = na_values[np.int64]
+        int64_t val
+        ndarray[uint8_t] mask
+        int na_count = 0
+
+    _mask = np.empty(n, dtype=bool)
+    mask = _mask.view(np.uint8)
+
+    for i in range(n):
+        val = arr[i]
+
+        if val == NA:
+            mask[i] = 1
+            na_count += 1
+            continue
+
+        # not NA
+        mask[i] = 0
+
+        if val > mx:
+            mx = val
+
+        if val < mn:
+            mn = val
+
+    if mn >= 0 and use_unsigned:
+        if mx <= UINT8_MAX - 1:
+            result = arr.astype(np.uint8)
+            if na_count:
+                np.putmask(result, _mask, na_values[np.uint8])
+            return result
+
+        if mx <= UINT16_MAX - 1:
+            result = arr.astype(np.uint16)
+            if na_count:
+                np.putmask(result, _mask, na_values[np.uint16])
+            return result
+
+        if mx <= UINT32_MAX - 1:
+            result = arr.astype(np.uint32)
+            if na_count:
+                np.putmask(result, _mask, na_values[np.uint32])
+            return result
+
+    else:
+        if mn >= INT8_MIN + 1 and mx <= INT8_MAX:
+            result = arr.astype(np.int8)
+            if na_count:
+                np.putmask(result, _mask, na_values[np.int8])
+            return result
+
+        if mn >= INT16_MIN + 1 and mx <= INT16_MAX:
+            result = arr.astype(np.int16)
+            if na_count:
+                np.putmask(result, _mask, na_values[np.int16])
+            return result
+
+        if mn >= INT32_MIN + 1 and mx <= INT32_MAX:
+            result = arr.astype(np.int32)
+            if na_count:
+                np.putmask(result, _mask, na_values[np.int32])
+            return result
+
+    return arr
+
 #----------------------------------------------------------------------
+
 # NA values
 
 na_values = {
@@ -971,6 +1057,9 @@ def _to_structured_array(dict columns, object names):
         int stride, elsize
         char *buf
 
+    if names is None:
+        names = ['%d' % i for i in range(len(columns))]
+
     dt = np.dtype([(str(name), columns[i].dtype)
                    for i, name in enumerate(names)])
     fnames = dt.names

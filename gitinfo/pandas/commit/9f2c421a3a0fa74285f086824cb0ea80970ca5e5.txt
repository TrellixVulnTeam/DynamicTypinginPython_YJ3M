commit 9f2c421a3a0fa74285f086824cb0ea80970ca5e5
Author: Simon Hawkins <simonjayhawkins@gmail.com>
Date:   Mon Jan 28 12:38:29 2019 +0000

    STY: use pytest.raises context syntax (indexing) (#24960)

diff --git a/pandas/tests/indexing/multiindex/test_loc.py b/pandas/tests/indexing/multiindex/test_loc.py
index ea451d40e..073d40001 100644
--- a/pandas/tests/indexing/multiindex/test_loc.py
+++ b/pandas/tests/indexing/multiindex/test_loc.py
@@ -123,10 +123,12 @@ class TestMultiIndexLoc(object):
         tm.assert_frame_equal(rs, xp)
 
         # missing label
-        pytest.raises(KeyError, lambda: mi_int.loc[2])
+        with pytest.raises(KeyError, match=r"^2L?$"):
+            mi_int.loc[2]
         with catch_warnings(record=True):
             # GH 21593
-            pytest.raises(KeyError, lambda: mi_int.ix[2])
+            with pytest.raises(KeyError, match=r"^2L?$"):
+                mi_int.ix[2]
 
     def test_loc_multiindex_indexer_none(self):
 
diff --git a/pandas/tests/indexing/multiindex/test_partial.py b/pandas/tests/indexing/multiindex/test_partial.py
index 2e37ebe4a..473463def 100644
--- a/pandas/tests/indexing/multiindex/test_partial.py
+++ b/pandas/tests/indexing/multiindex/test_partial.py
@@ -104,8 +104,8 @@ class TestMultiIndexPartial(object):
             result = df.ix[('a', 'y'), [1, 0]]
         tm.assert_frame_equal(result, expected)
 
-        pytest.raises(KeyError, df.loc.__getitem__,
-                      (('a', 'foo'), slice(None, None)))
+        with pytest.raises(KeyError, match=r"\('a', 'foo'\)"):
+            df.loc[('a', 'foo'), :]
 
     def test_partial_set(
             self, multiindex_year_month_day_dataframe_random_data):
diff --git a/pandas/tests/indexing/multiindex/test_slice.py b/pandas/tests/indexing/multiindex/test_slice.py
index fcecb2b45..db7d07918 100644
--- a/pandas/tests/indexing/multiindex/test_slice.py
+++ b/pandas/tests/indexing/multiindex/test_slice.py
@@ -107,7 +107,8 @@ class TestMultiIndexSlicers(object):
         # ambiguous cases
         # these can be multiply interpreted (e.g. in this case
         # as df.loc[slice(None),[1]] as well
-        pytest.raises(KeyError, lambda: df.loc[slice(None), [1]])
+        with pytest.raises(KeyError, match=r"'\[1\] not in index'"):
+            df.loc[slice(None), [1]]
 
         result = df.loc[(slice(None), [1]), :]
         expected = df.iloc[[0, 3]]
diff --git a/pandas/tests/indexing/test_categorical.py b/pandas/tests/indexing/test_categorical.py
index b7443e242..317aac176 100644
--- a/pandas/tests/indexing/test_categorical.py
+++ b/pandas/tests/indexing/test_categorical.py
@@ -53,23 +53,20 @@ class TestCategoricalIndex(object):
         assert_frame_equal(df, expected)
 
         # value not in the categories
-        pytest.raises(KeyError, lambda: df.loc['d'])
+        with pytest.raises(KeyError, match=r"^'d'$"):
+            df.loc['d']
 
-        def f():
+        msg = "cannot append a non-category item to a CategoricalIndex"
+        with pytest.raises(TypeError, match=msg):
             df.loc['d'] = 10
 
-        pytest.raises(TypeError, f)
-
-        def f():
+        msg = ("cannot insert an item into a CategoricalIndex that is not"
+               " already an existing category")
+        with pytest.raises(TypeError, match=msg):
             df.loc['d', 'A'] = 10
-
-        pytest.raises(TypeError, f)
-
-        def f():
+        with pytest.raises(TypeError, match=msg):
             df.loc['d', 'C'] = 10
 
-        pytest.raises(TypeError, f)
-
     def test_getitem_scalar(self):
 
         cats = Categorical([Timestamp('12-31-1999'),
@@ -318,7 +315,8 @@ class TestCategoricalIndex(object):
         assert_frame_equal(result, expected, check_index_type=True)
 
         # element in the categories but not in the values
-        pytest.raises(KeyError, lambda: self.df2.loc['e'])
+        with pytest.raises(KeyError, match=r"^'e'$"):
+            self.df2.loc['e']
 
         # assign is ok
         df = self.df2.copy()
@@ -616,22 +614,29 @@ class TestCategoricalIndex(object):
         assert_frame_equal(result, expected, check_index_type=True)
 
         # passed duplicate indexers are not allowed
-        pytest.raises(ValueError, lambda: self.df2.reindex(['a', 'a']))
+        msg = "cannot reindex with a non-unique indexer"
+        with pytest.raises(ValueError, match=msg):
+            self.df2.reindex(['a', 'a'])
 
         # args NotImplemented ATM
-        pytest.raises(NotImplementedError,
-                      lambda: self.df2.reindex(['a'], method='ffill'))
-        pytest.raises(NotImplementedError,
-                      lambda: self.df2.reindex(['a'], level=1))
-        pytest.raises(NotImplementedError,
-                      lambda: self.df2.reindex(['a'], limit=2))
+        msg = r"argument {} is not implemented for CategoricalIndex\.reindex"
+        with pytest.raises(NotImplementedError, match=msg.format('method')):
+            self.df2.reindex(['a'], method='ffill')
+        with pytest.raises(NotImplementedError, match=msg.format('level')):
+            self.df2.reindex(['a'], level=1)
+        with pytest.raises(NotImplementedError, match=msg.format('limit')):
+            self.df2.reindex(['a'], limit=2)
 
     def test_loc_slice(self):
         # slicing
         # not implemented ATM
         # GH9748
 
-        pytest.raises(TypeError, lambda: self.df.loc[1:5])
+        msg = ("cannot do slice indexing on {klass} with these "
+               r"indexers \[1\] of {kind}".format(
+                   klass=str(CategoricalIndex), kind=str(int)))
+        with pytest.raises(TypeError, match=msg):
+            self.df.loc[1:5]
 
         # result = df.loc[1:5]
         # expected = df.iloc[[1,2,3,4]]
@@ -679,8 +684,11 @@ class TestCategoricalIndex(object):
         #         categories=[3, 2, 1],
         #         ordered=False,
         #         name=u'B')
-        pytest.raises(TypeError, lambda: df4[df4.index < 2])
-        pytest.raises(TypeError, lambda: df4[df4.index > 1])
+        msg = "Unordered Categoricals can only compare equality or not"
+        with pytest.raises(TypeError, match=msg):
+            df4[df4.index < 2]
+        with pytest.raises(TypeError, match=msg):
+            df4[df4.index > 1]
 
     def test_indexing_with_category(self):
 
diff --git a/pandas/tests/indexing/test_chaining_and_caching.py b/pandas/tests/indexing/test_chaining_and_caching.py
index e38c1b16b..be0d9c5cf 100644
--- a/pandas/tests/indexing/test_chaining_and_caching.py
+++ b/pandas/tests/indexing/test_chaining_and_caching.py
@@ -302,11 +302,11 @@ class TestChaining(object):
                         'c': ['a', 'b', np.nan, 'd']})
         mask = pd.isna(df.c)
 
-        def f():
+        msg = ("A value is trying to be set on a copy of a slice from a"
+               " DataFrame")
+        with pytest.raises(com.SettingWithCopyError, match=msg):
             df[['c']][mask] = df[['b']][mask]
 
-        pytest.raises(com.SettingWithCopyError, f)
-
         # invalid warning as we are returning a new object
         # GH 8730
         df1 = DataFrame({'x': Series(['a', 'b', 'c']),
diff --git a/pandas/tests/indexing/test_floats.py b/pandas/tests/indexing/test_floats.py
index de91b8f4a..b9b47338c 100644
--- a/pandas/tests/indexing/test_floats.py
+++ b/pandas/tests/indexing/test_floats.py
@@ -6,7 +6,7 @@ import numpy as np
 import pytest
 
 from pandas import (
-    DataFrame, Float64Index, Index, Int64Index, RangeIndex, Series)
+    DataFrame, Float64Index, Index, Int64Index, RangeIndex, Series, compat)
 import pandas.util.testing as tm
 from pandas.util.testing import assert_almost_equal, assert_series_equal
 
@@ -54,9 +54,11 @@ class TestFloatIndexers(object):
             with pytest.raises(TypeError, match=msg):
                 s.iloc[3.0]
 
-            def f():
+            msg = ("cannot do positional indexing on {klass} with these "
+                   r"indexers \[3\.0\] of {kind}".format(
+                       klass=type(i), kind=str(float)))
+            with pytest.raises(TypeError, match=msg):
                 s.iloc[3.0] = 0
-            pytest.raises(TypeError, f)
 
     @ignore_ix
     def test_scalar_non_numeric(self):
@@ -82,35 +84,46 @@ class TestFloatIndexers(object):
                                       (lambda x: x.iloc, False),
                                       (lambda x: x, True)]:
 
-                    def f():
-                        with catch_warnings(record=True):
-                            idxr(s)[3.0]
-
                     # gettitem on a DataFrame is a KeyError as it is indexing
                     # via labels on the columns
                     if getitem and isinstance(s, DataFrame):
                         error = KeyError
+                        msg = r"^3(\.0)?$"
                     else:
                         error = TypeError
-                    pytest.raises(error, f)
+                        msg = (r"cannot do (label|index|positional) indexing"
+                               r" on {klass} with these indexers \[3\.0\] of"
+                               r" {kind}|"
+                               "Cannot index by location index with a"
+                               " non-integer key"
+                               .format(klass=type(i), kind=str(float)))
+                    with catch_warnings(record=True):
+                        with pytest.raises(error, match=msg):
+                            idxr(s)[3.0]
 
                 # label based can be a TypeError or KeyError
-                def f():
-                    s.loc[3.0]
-
                 if s.index.inferred_type in ['string', 'unicode', 'mixed']:
                     error = KeyError
+                    msg = r"^3$"
                 else:
                     error = TypeError
-                pytest.raises(error, f)
+                    msg = (r"cannot do (label|index) indexing"
+                           r" on {klass} with these indexers \[3\.0\] of"
+                           r" {kind}"
+                           .format(klass=type(i), kind=str(float)))
+                with pytest.raises(error, match=msg):
+                    s.loc[3.0]
 
                 # contains
                 assert 3.0 not in s
 
                 # setting with a float fails with iloc
-                def f():
+                msg = (r"cannot do (label|index|positional) indexing"
+                       r" on {klass} with these indexers \[3\.0\] of"
+                       r" {kind}"
+                       .format(klass=type(i), kind=str(float)))
+                with pytest.raises(TypeError, match=msg):
                     s.iloc[3.0] = 0
-                pytest.raises(TypeError, f)
 
                 # setting with an indexer
                 if s.index.inferred_type in ['categorical']:
@@ -145,7 +158,12 @@ class TestFloatIndexers(object):
             # fallsback to position selection, series only
             s = Series(np.arange(len(i)), index=i)
             s[3]
-            pytest.raises(TypeError, lambda: s[3.0])
+            msg = (r"cannot do (label|index) indexing"
+                   r" on {klass} with these indexers \[3\.0\] of"
+                   r" {kind}"
+                   .format(klass=type(i), kind=str(float)))
+            with pytest.raises(TypeError, match=msg):
+                s[3.0]
 
     @ignore_ix
     def test_scalar_with_mixed(self):
@@ -153,19 +171,23 @@ class TestFloatIndexers(object):
         s2 = Series([1, 2, 3], index=['a', 'b', 'c'])
         s3 = Series([1, 2, 3], index=['a', 'b', 1.5])
 
-        # lookup in a pure string index
+        # lookup in a pure stringstr
         # with an invalid indexer
         for idxr in [lambda x: x.ix,
                      lambda x: x,
                      lambda x: x.iloc]:
 
-            def f():
-                with catch_warnings(record=True):
+            msg = (r"cannot do label indexing"
+                   r" on {klass} with these indexers \[1\.0\] of"
+                   r" {kind}|"
+                   "Cannot index by location index with a non-integer key"
+                   .format(klass=str(Index), kind=str(float)))
+            with catch_warnings(record=True):
+                with pytest.raises(TypeError, match=msg):
                     idxr(s2)[1.0]
 
-            pytest.raises(TypeError, f)
-
-        pytest.raises(KeyError, lambda: s2.loc[1.0])
+        with pytest.raises(KeyError, match=r"^1$"):
+            s2.loc[1.0]
 
         result = s2.loc['b']
         expected = 2
@@ -175,11 +197,13 @@ class TestFloatIndexers(object):
         # indexing
         for idxr in [lambda x: x]:
 
-            def f():
+            msg = (r"cannot do label indexing"
+                   r" on {klass} with these indexers \[1\.0\] of"
+                   r" {kind}"
+                   .format(klass=str(Index), kind=str(float)))
+            with pytest.raises(TypeError, match=msg):
                 idxr(s3)[1.0]
 
-            pytest.raises(TypeError, f)
-
             result = idxr(s3)[1]
             expected = 2
             assert result == expected
@@ -189,17 +213,22 @@ class TestFloatIndexers(object):
         for idxr in [lambda x: x.ix]:
             with catch_warnings(record=True):
 
-                def f():
+                msg = (r"cannot do label indexing"
+                       r" on {klass} with these indexers \[1\.0\] of"
+                       r" {kind}"
+                       .format(klass=str(Index), kind=str(float)))
+                with pytest.raises(TypeError, match=msg):
                     idxr(s3)[1.0]
 
-                pytest.raises(TypeError, f)
-
                 result = idxr(s3)[1]
                 expected = 2
                 assert result == expected
 
-        pytest.raises(TypeError, lambda: s3.iloc[1.0])
-        pytest.raises(KeyError, lambda: s3.loc[1.0])
+        msg = "Cannot index by location index with a non-integer key"
+        with pytest.raises(TypeError, match=msg):
+            s3.iloc[1.0]
+        with pytest.raises(KeyError, match=r"^1$"):
+            s3.loc[1.0]
 
         result = s3.loc[1.5]
         expected = 3
@@ -280,16 +309,14 @@ class TestFloatIndexers(object):
                 # setting
                 s2 = s.copy()
 
-                def f():
-                    with catch_warnings(record=True):
-                        idxr(s2)[indexer] = expected
                 with catch_warnings(record=True):
                     result = idxr(s2)[indexer]
                 self.check(result, s, 3, getitem)
 
                 # random integer is a KeyError
                 with catch_warnings(record=True):
-                    pytest.raises(KeyError, lambda: idxr(s)[3.5])
+                    with pytest.raises(KeyError, match=r"^3\.5$"):
+                        idxr(s)[3.5]
 
             # contains
             assert 3.0 in s
@@ -303,11 +330,16 @@ class TestFloatIndexers(object):
             self.check(result, s, 3, False)
 
             # iloc raises with a float
-            pytest.raises(TypeError, lambda: s.iloc[3.0])
+            msg = "Cannot index by location index with a non-integer key"
+            with pytest.raises(TypeError, match=msg):
+                s.iloc[3.0]
 
-            def g():
+            msg = (r"cannot do positional indexing"
+                   r" on {klass} with these indexers \[3\.0\] of"
+                   r" {kind}"
+                   .format(klass=str(Float64Index), kind=str(float)))
+            with pytest.raises(TypeError, match=msg):
                 s2.iloc[3.0] = 0
-            pytest.raises(TypeError, g)
 
     @ignore_ix
     def test_slice_non_numeric(self):
@@ -329,37 +361,55 @@ class TestFloatIndexers(object):
                           slice(3, 4.0),
                           slice(3.0, 4.0)]:
 
-                    def f():
+                    msg = ("cannot do slice indexing"
+                           r" on {klass} with these indexers \[(3|4)\.0\] of"
+                           " {kind}"
+                           .format(klass=type(index), kind=str(float)))
+                    with pytest.raises(TypeError, match=msg):
                         s.iloc[l]
-                    pytest.raises(TypeError, f)
 
                     for idxr in [lambda x: x.ix,
                                  lambda x: x.loc,
                                  lambda x: x.iloc,
                                  lambda x: x]:
 
-                        def f():
-                            with catch_warnings(record=True):
+                        msg = ("cannot do slice indexing"
+                               r" on {klass} with these indexers"
+                               r" \[(3|4)(\.0)?\]"
+                               r" of ({kind_float}|{kind_int})"
+                               .format(klass=type(index),
+                                       kind_float=str(float),
+                                       kind_int=str(int)))
+                        with catch_warnings(record=True):
+                            with pytest.raises(TypeError, match=msg):
                                 idxr(s)[l]
-                        pytest.raises(TypeError, f)
 
                 # setitem
                 for l in [slice(3.0, 4),
                           slice(3, 4.0),
                           slice(3.0, 4.0)]:
 
-                    def f():
+                    msg = ("cannot do slice indexing"
+                           r" on {klass} with these indexers \[(3|4)\.0\] of"
+                           " {kind}"
+                           .format(klass=type(index), kind=str(float)))
+                    with pytest.raises(TypeError, match=msg):
                         s.iloc[l] = 0
-                    pytest.raises(TypeError, f)
 
                     for idxr in [lambda x: x.ix,
                                  lambda x: x.loc,
                                  lambda x: x.iloc,
                                  lambda x: x]:
-                        def f():
-                            with catch_warnings(record=True):
+                        msg = ("cannot do slice indexing"
+                               r" on {klass} with these indexers"
+                               r" \[(3|4)(\.0)?\]"
+                               r" of ({kind_float}|{kind_int})"
+                               .format(klass=type(index),
+                                       kind_float=str(float),
+                                       kind_int=str(int)))
+                        with catch_warnings(record=True):
+                            with pytest.raises(TypeError, match=msg):
                                 idxr(s)[l] = 0
-                        pytest.raises(TypeError, f)
 
     @ignore_ix
     def test_slice_integer(self):
@@ -396,11 +446,13 @@ class TestFloatIndexers(object):
                     self.check(result, s, indexer, False)
 
                 # positional indexing
-                def f():
+                msg = ("cannot do slice indexing"
+                       r" on {klass} with these indexers \[(3|4)\.0\] of"
+                       " {kind}"
+                       .format(klass=type(index), kind=str(float)))
+                with pytest.raises(TypeError, match=msg):
                     s[l]
 
-                pytest.raises(TypeError, f)
-
             # getitem out-of-bounds
             for l in [slice(-6, 6),
                       slice(-6.0, 6.0)]:
@@ -420,11 +472,13 @@ class TestFloatIndexers(object):
                     self.check(result, s, indexer, False)
 
             # positional indexing
-            def f():
+            msg = ("cannot do slice indexing"
+                   r" on {klass} with these indexers \[-6\.0\] of"
+                   " {kind}"
+                   .format(klass=type(index), kind=str(float)))
+            with pytest.raises(TypeError, match=msg):
                 s[slice(-6.0, 6.0)]
 
-            pytest.raises(TypeError, f)
-
             # getitem odd floats
             for l, res1 in [(slice(2.5, 4), slice(3, 5)),
                             (slice(2, 3.5), slice(2, 4)),
@@ -443,11 +497,13 @@ class TestFloatIndexers(object):
                     self.check(result, s, res, False)
 
                 # positional indexing
-                def f():
+                msg = ("cannot do slice indexing"
+                       r" on {klass} with these indexers \[(2|3)\.5\] of"
+                       " {kind}"
+                       .format(klass=type(index), kind=str(float)))
+                with pytest.raises(TypeError, match=msg):
                     s[l]
 
-                pytest.raises(TypeError, f)
-
             # setitem
             for l in [slice(3.0, 4),
                       slice(3, 4.0),
@@ -462,11 +518,13 @@ class TestFloatIndexers(object):
                     assert (result == 0).all()
 
                 # positional indexing
-                def f():
+                msg = ("cannot do slice indexing"
+                       r" on {klass} with these indexers \[(3|4)\.0\] of"
+                       " {kind}"
+                       .format(klass=type(index), kind=str(float)))
+                with pytest.raises(TypeError, match=msg):
                     s[l] = 0
 
-                pytest.raises(TypeError, f)
-
     def test_integer_positional_indexing(self):
         """ make sure that we are raising on positional indexing
         w.r.t. an integer index """
@@ -484,11 +542,17 @@ class TestFloatIndexers(object):
                       slice(2.0, 4),
                       slice(2.0, 4.0)]:
 
-                def f():
+                if compat.PY2:
+                    klass = Int64Index
+                else:
+                    klass = RangeIndex
+                msg = ("cannot do slice indexing"
+                       r" on {klass} with these indexers \[(2|4)\.0\] of"
+                       " {kind}"
+                       .format(klass=str(klass), kind=str(float)))
+                with pytest.raises(TypeError, match=msg):
                     idxr(s)[l]
 
-                pytest.raises(TypeError, f)
-
     @ignore_ix
     def test_slice_integer_frame_getitem(self):
 
@@ -509,11 +573,13 @@ class TestFloatIndexers(object):
                     self.check(result, s, indexer, False)
 
                     # positional indexing
-                    def f():
+                    msg = ("cannot do slice indexing"
+                           r" on {klass} with these indexers \[(0|1)\.0\] of"
+                           " {kind}"
+                           .format(klass=type(index), kind=str(float)))
+                    with pytest.raises(TypeError, match=msg):
                         s[l]
 
-                    pytest.raises(TypeError, f)
-
                 # getitem out-of-bounds
                 for l in [slice(-10, 10),
                           slice(-10.0, 10.0)]:
@@ -522,11 +588,13 @@ class TestFloatIndexers(object):
                     self.check(result, s, slice(-10, 10), True)
 
                 # positional indexing
-                def f():
+                msg = ("cannot do slice indexing"
+                       r" on {klass} with these indexers \[-10\.0\] of"
+                       " {kind}"
+                       .format(klass=type(index), kind=str(float)))
+                with pytest.raises(TypeError, match=msg):
                     s[slice(-10.0, 10.0)]
 
-                pytest.raises(TypeError, f)
-
                 # getitem odd floats
                 for l, res in [(slice(0.5, 1), slice(1, 2)),
                                (slice(0, 0.5), slice(0, 1)),
@@ -536,11 +604,13 @@ class TestFloatIndexers(object):
                     self.check(result, s, res, False)
 
                     # positional indexing
-                    def f():
+                    msg = ("cannot do slice indexing"
+                           r" on {klass} with these indexers \[0\.5\] of"
+                           " {kind}"
+                           .format(klass=type(index), kind=str(float)))
+                    with pytest.raises(TypeError, match=msg):
                         s[l]
 
-                    pytest.raises(TypeError, f)
-
                 # setitem
                 for l in [slice(3.0, 4),
                           slice(3, 4.0),
@@ -552,11 +622,13 @@ class TestFloatIndexers(object):
                     assert (result == 0).all()
 
                     # positional indexing
-                    def f():
+                    msg = ("cannot do slice indexing"
+                           r" on {klass} with these indexers \[(3|4)\.0\] of"
+                           " {kind}"
+                           .format(klass=type(index), kind=str(float)))
+                    with pytest.raises(TypeError, match=msg):
                         s[l] = 0
 
-                    pytest.raises(TypeError, f)
-
             f(lambda x: x.loc)
             with catch_warnings(record=True):
                 f(lambda x: x.ix)
@@ -632,9 +704,12 @@ class TestFloatIndexers(object):
         # value not found (and no fallbacking at all)
 
         # scalar integers
-        pytest.raises(KeyError, lambda: s.loc[4])
-        pytest.raises(KeyError, lambda: s.loc[4])
-        pytest.raises(KeyError, lambda: s[4])
+        with pytest.raises(KeyError, match=r"^4\.0$"):
+            s.loc[4]
+        with pytest.raises(KeyError, match=r"^4\.0$"):
+            s.loc[4]
+        with pytest.raises(KeyError, match=r"^4\.0$"):
+            s[4]
 
         # fancy floats/integers create the correct entry (as nan)
         # fancy tests
diff --git a/pandas/tests/indexing/test_iloc.py b/pandas/tests/indexing/test_iloc.py
index a867387db..5c87d553d 100644
--- a/pandas/tests/indexing/test_iloc.py
+++ b/pandas/tests/indexing/test_iloc.py
@@ -26,26 +26,33 @@ class TestiLoc(Base):
         msg = 'positional indexers are out-of-bounds'
         with pytest.raises(IndexError, match=msg):
             df.iloc[:, [0, 1, 2, 3, 4, 5]]
-        pytest.raises(IndexError, lambda: df.iloc[[1, 30]])
-        pytest.raises(IndexError, lambda: df.iloc[[1, -30]])
-        pytest.raises(IndexError, lambda: df.iloc[[100]])
+        with pytest.raises(IndexError, match=msg):
+            df.iloc[[1, 30]]
+        with pytest.raises(IndexError, match=msg):
+            df.iloc[[1, -30]]
+        with pytest.raises(IndexError, match=msg):
+            df.iloc[[100]]
 
         s = df['A']
-        pytest.raises(IndexError, lambda: s.iloc[[100]])
-        pytest.raises(IndexError, lambda: s.iloc[[-100]])
+        with pytest.raises(IndexError, match=msg):
+            s.iloc[[100]]
+        with pytest.raises(IndexError, match=msg):
+            s.iloc[[-100]]
 
         # still raise on a single indexer
         msg = 'single positional indexer is out-of-bounds'
         with pytest.raises(IndexError, match=msg):
             df.iloc[30]
-        pytest.raises(IndexError, lambda: df.iloc[-30])
+        with pytest.raises(IndexError, match=msg):
+            df.iloc[-30]
 
         # GH10779
         # single positive/negative indexer exceeding Series bounds should raise
         # an IndexError
         with pytest.raises(IndexError, match=msg):
             s.iloc[30]
-        pytest.raises(IndexError, lambda: s.iloc[-30])
+        with pytest.raises(IndexError, match=msg):
+            s.iloc[-30]
 
         # slices are ok
         result = df.iloc[:, 4:10]  # 0 < start < len < stop
@@ -104,8 +111,12 @@ class TestiLoc(Base):
         check(dfl.iloc[:, 1:3], dfl.iloc[:, [1]])
         check(dfl.iloc[4:6], dfl.iloc[[4]])
 
-        pytest.raises(IndexError, lambda: dfl.iloc[[4, 5, 6]])
-        pytest.raises(IndexError, lambda: dfl.iloc[:, 4])
+        msg = "positional indexers are out-of-bounds"
+        with pytest.raises(IndexError, match=msg):
+            dfl.iloc[[4, 5, 6]]
+        msg = "single positional indexer is out-of-bounds"
+        with pytest.raises(IndexError, match=msg):
+            dfl.iloc[:, 4]
 
     def test_iloc_getitem_int(self):
 
@@ -437,10 +448,16 @@ class TestiLoc(Base):
         assert result == exp
 
         # out-of-bounds exception
-        pytest.raises(IndexError, df.iloc.__getitem__, tuple([10, 5]))
+        msg = "single positional indexer is out-of-bounds"
+        with pytest.raises(IndexError, match=msg):
+            df.iloc[10, 5]
 
         # trying to use a label
-        pytest.raises(ValueError, df.iloc.__getitem__, tuple(['j', 'D']))
+        msg = (r"Location based indexing can only have \[integer, integer"
+               r" slice \(START point is INCLUDED, END point is EXCLUDED\),"
+               r" listlike of integers, boolean array\] types")
+        with pytest.raises(ValueError, match=msg):
+            df.iloc['j', 'D']
 
     def test_iloc_getitem_doc_issue(self):
 
@@ -555,10 +572,15 @@ class TestiLoc(Base):
         # GH 3631, iloc with a mask (of a series) should raise
         df = DataFrame(lrange(5), list('ABCDE'), columns=['a'])
         mask = (df.a % 2 == 0)
-        pytest.raises(ValueError, df.iloc.__getitem__, tuple([mask]))
+        msg = ("iLocation based boolean indexing cannot use an indexable as"
+               " a mask")
+        with pytest.raises(ValueError, match=msg):
+            df.iloc[mask]
         mask.index = lrange(len(mask))
-        pytest.raises(NotImplementedError, df.iloc.__getitem__,
-                      tuple([mask]))
+        msg = ("iLocation based boolean indexing on an integer type is not"
+               " available")
+        with pytest.raises(NotImplementedError, match=msg):
+            df.iloc[mask]
 
         # ndarray ok
         result = df.iloc[np.array([True] * len(mask), dtype=bool)]
diff --git a/pandas/tests/indexing/test_ix.py b/pandas/tests/indexing/test_ix.py
index 35805bce0..fb4dfbb39 100644
--- a/pandas/tests/indexing/test_ix.py
+++ b/pandas/tests/indexing/test_ix.py
@@ -102,7 +102,12 @@ class TestIX(object):
                 with catch_warnings(record=True):
                     df.ix[key]
 
-                pytest.raises(TypeError, lambda: df.loc[key])
+                msg = (r"cannot do slice indexing"
+                       r" on {klass} with these indexers \[(0|1)\] of"
+                       r" {kind}"
+                       .format(klass=type(df.index), kind=str(int)))
+                with pytest.raises(TypeError, match=msg):
+                    df.loc[key]
 
         df = DataFrame(np.random.randn(5, 4), columns=list('ABCD'),
                        index=pd.date_range('2012-01-01', periods=5))
@@ -122,7 +127,8 @@ class TestIX(object):
                 with catch_warnings(record=True):
                     expected = df.ix[key]
             except KeyError:
-                pytest.raises(KeyError, lambda: df.loc[key])
+                with pytest.raises(KeyError, match=r"^'2012-01-31'$"):
+                    df.loc[key]
                 continue
 
             result = df.loc[key]
@@ -279,14 +285,18 @@ class TestIX(object):
             np.random.randn(2, 5), index=["row%s" % i for i in range(2)],
             columns=["col%s" % i for i in range(5)])
         with catch_warnings(record=True):
-            pytest.raises(ValueError, df.ix.__setitem__, (2, 0), 100)
+            msg = "cannot set by positional indexing with enlargement"
+            with pytest.raises(ValueError, match=msg):
+                df.ix[2, 0] = 100
 
     def test_ix_setitem_out_of_bounds_axis_1(self):
         df = DataFrame(
             np.random.randn(5, 2), index=["row%s" % i for i in range(5)],
             columns=["col%s" % i for i in range(2)])
         with catch_warnings(record=True):
-            pytest.raises(ValueError, df.ix.__setitem__, (0, 2), 100)
+            msg = "cannot set by positional indexing with enlargement"
+            with pytest.raises(ValueError, match=msg):
+                df.ix[0, 2] = 100
 
     def test_ix_empty_list_indexer_is_ok(self):
         with catch_warnings(record=True):
diff --git a/pandas/tests/indexing/test_loc.py b/pandas/tests/indexing/test_loc.py
index 17e107c7a..3bf4a6bee 100644
--- a/pandas/tests/indexing/test_loc.py
+++ b/pandas/tests/indexing/test_loc.py
@@ -233,8 +233,10 @@ class TestLoc(Base):
                        columns=['e', 'f', 'g'])
 
         # raise a KeyError?
-        pytest.raises(KeyError, df.loc.__getitem__,
-                      tuple([[1, 2], [1, 2]]))
+        msg = (r"\"None of \[Int64Index\(\[1, 2\], dtype='int64'\)\] are"
+               r" in the \[index\]\"")
+        with pytest.raises(KeyError, match=msg):
+            df.loc[[1, 2], [1, 2]]
 
         # GH  7496
         # loc should not fallback
@@ -243,10 +245,18 @@ class TestLoc(Base):
         s.loc[1] = 1
         s.loc['a'] = 2
 
-        pytest.raises(KeyError, lambda: s.loc[-1])
-        pytest.raises(KeyError, lambda: s.loc[[-1, -2]])
+        with pytest.raises(KeyError, match=r"^-1$"):
+            s.loc[-1]
+
+        msg = (r"\"None of \[Int64Index\(\[-1, -2\], dtype='int64'\)\] are"
+               r" in the \[index\]\"")
+        with pytest.raises(KeyError, match=msg):
+            s.loc[[-1, -2]]
 
-        pytest.raises(KeyError, lambda: s.loc[['4']])
+        msg = (r"\"None of \[Index\(\[u?'4'\], dtype='object'\)\] are"
+               r" in the \[index\]\"")
+        with pytest.raises(KeyError, match=msg):
+            s.loc[['4']]
 
         s.loc[-1] = 3
         with tm.assert_produces_warning(FutureWarning,
@@ -256,29 +266,28 @@ class TestLoc(Base):
         tm.assert_series_equal(result, expected)
 
         s['a'] = 2
-        pytest.raises(KeyError, lambda: s.loc[[-2]])
+        msg = (r"\"None of \[Int64Index\(\[-2\], dtype='int64'\)\] are"
+               r" in the \[index\]\"")
+        with pytest.raises(KeyError, match=msg):
+            s.loc[[-2]]
 
         del s['a']
 
-        def f():
+        with pytest.raises(KeyError, match=msg):
             s.loc[[-2]] = 0
 
-        pytest.raises(KeyError, f)
-
         # inconsistency between .loc[values] and .loc[values,:]
         # GH 7999
         df = DataFrame([['a'], ['b']], index=[1, 2], columns=['value'])
 
-        def f():
+        msg = (r"\"None of \[Int64Index\(\[3\], dtype='int64'\)\] are"
+               r" in the \[index\]\"")
+        with pytest.raises(KeyError, match=msg):
             df.loc[[3], :]
 
-        pytest.raises(KeyError, f)
-
-        def f():
+        with pytest.raises(KeyError, match=msg):
             df.loc[[3]]
 
-        pytest.raises(KeyError, f)
-
     def test_loc_getitem_list_with_fail(self):
         # 15747
         # should KeyError if *any* missing labels
@@ -600,11 +609,15 @@ Region_1,Site_2,3977723089,A,5/20/2015 8:33,5/20/2015 9:09,Yes,No"""
         # these are going to raise because the we are non monotonic
         df = DataFrame({'A': [1, 2, 3, 4, 5, 6],
                         'B': [3, 4, 5, 6, 7, 8]}, index=[0, 1, 0, 1, 2, 3])
-        pytest.raises(KeyError, df.loc.__getitem__,
-                      tuple([slice(1, None)]))
-        pytest.raises(KeyError, df.loc.__getitem__,
-                      tuple([slice(0, None)]))
-        pytest.raises(KeyError, df.loc.__getitem__, tuple([slice(1, 2)]))
+        msg = "'Cannot get left slice bound for non-unique label: 1'"
+        with pytest.raises(KeyError, match=msg):
+            df.loc[1:]
+        msg = "'Cannot get left slice bound for non-unique label: 0'"
+        with pytest.raises(KeyError, match=msg):
+            df.loc[0:]
+        msg = "'Cannot get left slice bound for non-unique label: 1'"
+        with pytest.raises(KeyError, match=msg):
+            df.loc[1:2]
 
         # monotonic are ok
         df = DataFrame({'A': [1, 2, 3, 4, 5, 6],
diff --git a/pandas/tests/indexing/test_partial.py b/pandas/tests/indexing/test_partial.py
index b863afe02..5b6a5ab9e 100644
--- a/pandas/tests/indexing/test_partial.py
+++ b/pandas/tests/indexing/test_partial.py
@@ -246,7 +246,10 @@ class TestPartialSetting(object):
         tm.assert_series_equal(result, expected, check_index_type=True)
 
         # raises as nothing in in the index
-        pytest.raises(KeyError, lambda: ser.loc[[3, 3, 3]])
+        msg = (r"\"None of \[Int64Index\(\[3, 3, 3\], dtype='int64'\)\] are"
+               r" in the \[index\]\"")
+        with pytest.raises(KeyError, match=msg):
+            ser.loc[[3, 3, 3]]
 
         expected = Series([0.2, 0.2, np.nan], index=[2, 2, 3])
         with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
@@ -342,7 +345,10 @@ class TestPartialSetting(object):
         tm.assert_series_equal(result, expected, check_index_type=True)
 
         # raises as nothing in in the index
-        pytest.raises(KeyError, lambda: ser.loc[[3, 3, 3]])
+        msg = (r"\"None of \[Int64Index\(\[3, 3, 3\], dtype='int64',"
+               r" name=u?'idx'\)\] are in the \[index\]\"")
+        with pytest.raises(KeyError, match=msg):
+            ser.loc[[3, 3, 3]]
 
         exp_idx = Index([2, 2, 3], dtype='int64', name='idx')
         expected = Series([0.2, 0.2, np.nan], index=exp_idx, name='s')
diff --git a/pandas/tests/indexing/test_scalar.py b/pandas/tests/indexing/test_scalar.py
index e4b8181a6..6d607ce86 100644
--- a/pandas/tests/indexing/test_scalar.py
+++ b/pandas/tests/indexing/test_scalar.py
@@ -30,7 +30,9 @@ class TestScalar(Base):
 
             for f in [d['labels'], d['ts'], d['floats']]:
                 if f is not None:
-                    pytest.raises(ValueError, self.check_values, f, 'iat')
+                    msg = "iAt based indexing can only have integer indexers"
+                    with pytest.raises(ValueError, match=msg):
+                        self.check_values(f, 'iat')
 
             # at
             for f in [d['ints'], d['uints'], d['labels'],
@@ -57,7 +59,9 @@ class TestScalar(Base):
 
             for f in [d['labels'], d['ts'], d['floats']]:
                 if f is not None:
-                    pytest.raises(ValueError, _check, f, 'iat')
+                    msg = "iAt based indexing can only have integer indexers"
+                    with pytest.raises(ValueError, match=msg):
+                        _check(f, 'iat')
 
             # at
             for f in [d['ints'], d['uints'], d['labels'],
@@ -107,8 +111,12 @@ class TestScalar(Base):
         result = s.iat[2]
         assert result == 2
 
-        pytest.raises(IndexError, lambda: s.iat[10])
-        pytest.raises(IndexError, lambda: s.iat[-10])
+        msg = "index 10 is out of bounds for axis 0 with size 5"
+        with pytest.raises(IndexError, match=msg):
+            s.iat[10]
+        msg = "index -10 is out of bounds for axis 0 with size 5"
+        with pytest.raises(IndexError, match=msg):
+            s.iat[-10]
 
         result = s.iloc[[2, 3]]
         expected = Series([2, 3], [2, 2], dtype='int64')
@@ -128,22 +136,30 @@ class TestScalar(Base):
         s = Series([1, 2, 3], index=list('abc'))
         result = s.at['a']
         assert result == 1
-        pytest.raises(ValueError, lambda: s.at[0])
+        msg = ("At based indexing on an non-integer index can only have"
+               " non-integer indexers")
+        with pytest.raises(ValueError, match=msg):
+            s.at[0]
 
         df = DataFrame({'A': [1, 2, 3]}, index=list('abc'))
         result = df.at['a', 'A']
         assert result == 1
-        pytest.raises(ValueError, lambda: df.at['a', 0])
+        with pytest.raises(ValueError, match=msg):
+            df.at['a', 0]
 
         s = Series([1, 2, 3], index=[3, 2, 1])
         result = s.at[1]
         assert result == 3
-        pytest.raises(ValueError, lambda: s.at['a'])
+        msg = ("At based indexing on an integer index can only have integer"
+               " indexers")
+        with pytest.raises(ValueError, match=msg):
+            s.at['a']
 
         df = DataFrame({0: [1, 2, 3]}, index=[3, 2, 1])
         result = df.at[1, 0]
         assert result == 3
-        pytest.raises(ValueError, lambda: df.at['a', 0])
+        with pytest.raises(ValueError, match=msg):
+            df.at['a', 0]
 
         # GH 13822, incorrect error string with non-unique columns when missing
         # column is accessed

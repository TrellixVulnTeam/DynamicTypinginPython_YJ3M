commit 10c8f08d993b0098a470e2aabd0234fe45068183
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Sep 5 23:55:12 2011 -0400

    BUG: groupby bug with flex aggregate functions. and hierarchical columns weren't being passed on

diff --git a/doc/source/reshaping.rst b/doc/source/reshaping.rst
index c395416ca..c1388edc7 100644
--- a/doc/source/reshaping.rst
+++ b/doc/source/reshaping.rst
@@ -176,3 +176,22 @@ the right thing:
 
    df[:3].unstack(0)
    df2.unstack(1)
+
+Combining with stats and GroupBy
+--------------------------------
+
+It should be no shock that combining ``pivot`` / ``stack`` / ``unstack`` with
+GroupBy and the basic Series and DataFrame statistical functions can produce
+some very expressive and fast data manipulations.
+
+.. ipython:: python
+
+   df
+   df.stack().mean(1).unstack()
+
+   # same result, another way
+   df.groupby(level=1, axis=1).mean()
+
+   df.stack().groupby(level=1).mean()
+
+   df.mean().unstack(0)
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 5811ad0e6..815109d02 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -278,24 +278,30 @@ class GroupBy(object):
     def transform(self, func):
         raise NotImplementedError
 
-    def mean(self):
+    def mean(self, axis=None):
         """
         Compute mean of groups, excluding missing values
 
         For multiple groupings, the result index will be a MultiIndex
         """
-        return self._cython_agg_general('mean')
+        if self.axis == 0:
+            return self._cython_agg_general('mean')
+        else:
+            return self.aggregate(lambda x: x.mean(axis=self.axis))
 
-    def sum(self):
+    def sum(self, axis=None):
         """
         Compute sum of values, excluding missing values
 
         For multiple groupings, the result index will be a MultiIndex
         """
         try:
-            return self._cython_agg_general('add')
+            if self.axis == 0:
+                return self._cython_agg_general('add')
+            else:
+                return self.aggregate(lambda x: x.sum(axis=self.axis))
         except Exception:
-            return self.aggregate(np.sum)
+            return self.aggregate(lambda x: np.sum(x, axis=self.axis))
 
     def _cython_agg_general(self, how):
         label_list = [ping.labels for ping in self.groupings]
@@ -889,19 +895,38 @@ class DataFrameGroupBy(GroupBy):
         return DataFrame(result)
 
     def _wrap_aggregated_output(self, output, mask):
+        agg_axis = 0 if self.axis == 1 else 1
+        agg_labels = self.obj._get_axis(agg_axis)
+        if isinstance(output, dict):
+            if len(output) == len(agg_labels):
+                output_keys = agg_labels
+            else:
+                output_keys = sorted(output)
+                try:
+                    output_keys.sort()
+                except Exception:  # pragma: no cover
+                    pass
+
+                if isinstance(agg_labels, MultiIndex):
+                    output_keys = MultiIndex.from_tuples(output_keys,
+                                                         names=agg_labels.names)
+        else:
+            output_keys = agg_labels
+
         if len(self.groupings) > 1:
             if not self.as_index:
-                result = DataFrame(output)
+                result = DataFrame(output, columns=output_keys)
                 group_levels = self._get_group_levels(mask)
                 for i, (name, labels) in enumerate(group_levels):
                     result.insert(i, name, labels)
                 result = result.consolidate()
             else:
                 index = self._get_multi_index(mask)
-                result = DataFrame(output, index=index)
+                result = DataFrame(output, index=index, columns=output_keys)
         else:
             name_list = self._get_names()
-            result = DataFrame(output, index=name_list[0][1])
+            result = DataFrame(output, index=name_list[0][1],
+                               columns=output_keys)
 
         if self.axis == 1:
             result = result.T
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index d1dbff2ab..45e0be211 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -537,7 +537,9 @@ class TestGroupBy(unittest.TestCase):
         grouped = df.T.groupby([lambda x: x.year,
                                 lambda x: x.month,
                                 lambda x: x.day], axis=1)
+
         agged = grouped.agg(lambda x: x.sum(1))
+        self.assert_(agged.index.equals(df.columns))
         assert_almost_equal(df.T.values, agged.values)
 
         agged = grouped.agg(lambda x: x.sum(1))
@@ -704,6 +706,36 @@ class TestGroupBy(unittest.TestCase):
         exp = s1.groupby(s2.reindex(s1.index).get).mean()
         assert_series_equal(agged, exp)
 
+    def test_groupby_with_hier_columns(self):
+        tuples = zip(*[['bar', 'bar', 'baz', 'baz',
+                        'foo', 'foo', 'qux', 'qux'],
+                       ['one', 'two', 'one', 'two',
+                        'one', 'two', 'one', 'two']])
+        index = MultiIndex.from_tuples(tuples)
+        columns = MultiIndex.from_tuples([('A', 'cat'), ('B', 'dog'),
+                                          ('B', 'cat'), ('A', 'dog')])
+        df = DataFrame(np.random.randn(8, 4), index=index,
+                       columns=columns)
+
+        result = df.groupby(level=0).mean()
+        self.assert_(result.columns.equals(columns))
+
+        result = df.groupby(level=0).agg(np.mean)
+        self.assert_(result.columns.equals(columns))
+
+        result = df.groupby(level=0).apply(lambda x: x.mean())
+        self.assert_(result.columns.equals(columns))
+
+        result = df.groupby(level=0, axis=1).agg(lambda x: x.mean(1))
+        self.assert_(result.columns.equals(Index(['A', 'B'])))
+        self.assert_(result.index.equals(df.index))
+
+        # add a nuisance column
+        sorted_columns, _ = columns.sortlevel(0)
+        df['A', 'foo'] = 'bar'
+        result = df.groupby(level=0).mean()
+        self.assert_(result.columns.equals(sorted_columns))
+
 class TestPanelGroupBy(unittest.TestCase):
 
     def setUp(self):

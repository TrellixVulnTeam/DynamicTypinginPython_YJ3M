commit 29e8794e0ed16bb1c0abc3ad6c0129fc4acfb316
Author: Chang She <chang@lambdafoundry.com>
Date:   Wed Apr 4 14:32:38 2012 -0400

    ENH: to_timestamp supports 'S', 'E' end argument. aliased to start_time and end_time

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index e0711e46c..f8f2f5294 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -81,3 +81,8 @@ def bdate_range(start=None, end=None, periods=None, freq='B', tz=None):
 
     return DatetimeIndex(start=start, end=end, periods=periods,
                          freq=freq, tz=tz)
+
+def interval_range():
+    """
+    Return a fixed frequency interval index
+    """
diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 842fbd3d6..8d3e63c8a 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -231,13 +231,7 @@ class Interval(object):
         -------
         resampled : Interval
         """
-        how_dict = {'S': 'S', 'E': 'E',
-                    'START': 'S', 'FINISH': 'E',
-                    'BEGIN': 'S', 'END': 'E'}
-        how = how_dict.get(str(how).upper())
-        if how not in set(['S', 'E']):
-            raise ValueError('How must be one of S or E')
-
+        how = validate_end_alias(how)
         base1, mult1 = _get_freq_code(self.freq)
         base2, mult2 = _get_freq_code(freq)
 
@@ -249,10 +243,30 @@ class Interval(object):
     # for skts compatibility
     asfreq = resample
 
-    def to_timestamp(self):
-        base, mult = _get_freq_code('S')
-        new_val = self.resample('S', 'S').ordinal
-        return Timestamp(lib.skts_ordinal_to_dt64(new_val, base, mult))
+    def start_time(self):
+        return self.to_timestamp(which_end='S')
+
+    def end_time(self):
+        return self.to_timestamp(which_end='E')
+
+    def to_timestamp(self, which_end='S'):
+        """
+        Return the Timestamp at the start/end of the interval
+
+        Parameters
+        ----------
+        which_end: str, default 'S' (start)
+            'S', 'E'. Can be aliased as case insensitive
+            'Start', 'Finish', 'Begin', 'End'
+
+        Returns
+        -------
+        Timestamp
+        """
+        which_end = validate_end_alias(which_end)
+        new_val = self.resample('S', which_end)
+        base, mult = _get_freq_code(new_val.freq)
+        return Timestamp(lib.skts_ordinal_to_dt64(new_val.ordinal, base, mult))
 
     @property
     def year(self):
@@ -1925,14 +1939,12 @@ _offset_map = {
     "BQS@NOV" : BQuarterBegin(startingMonth=11),
     "BQS@DEC" : BQuarterBegin(startingMonth=12),
     # Monthly - Calendar
-    "EOM"      : BMonthEnd(1),  # legacy, deprecated?
-
     "M"      : MonthEnd(),
     "MS"     : MonthBegin(),
 
-
     # Monthly - Business
     "BM"     : BMonthEnd(),
+    "EOM"      : BMonthEnd(1),  # legacy, deprecated?
     "BMS"    : BMonthBegin(),
 
     # "EOM"    : MonthEnd(),
@@ -2200,3 +2212,12 @@ def _naive_in_cache_range(start, end):
 
 def _in_range(start, end, rng_start, rng_end):
     return start > rng_start and end < rng_end
+
+def validate_end_alias(how):
+    how_dict = {'S': 'S', 'E': 'E',
+                'START': 'S', 'FINISH': 'E',
+                'BEGIN': 'S', 'END': 'E'}
+    how = how_dict.get(str(how).upper())
+    if how not in set(['S', 'E']):
+        raise ValueError('How must be one of S or E')
+    return how
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 2e23634f9..a5ad2705a 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -2076,12 +2076,7 @@ class IntervalIndex(Int64Index):
         return subarr
 
     def resample(self, freq=None, how='E'):
-        how_dict = {'S': 'S', 'E': 'E',
-                    'START': 'S', 'FINISH': 'E',
-                    'BEGIN': 'S', 'END': 'E'}
-        how = how_dict.get(str(how).upper())
-        if how not in set(['S', 'E']):
-            raise ValueError('How must be one of S or E')
+        how = datetools.validate_end_alias(how)
 
         base1, mult1 = datetools._get_freq_code(self.freq)
 
diff --git a/pandas/tests/test_datetools.py b/pandas/tests/test_datetools.py
index 3868514be..99d740f5f 100644
--- a/pandas/tests/test_datetools.py
+++ b/pandas/tests/test_datetools.py
@@ -8,7 +8,8 @@ from pandas.core.datetools import (
     DateOffset, Week, YearBegin, YearEnd, Hour, Minute, Second,
     WeekOfMonth, format, ole2datetime, QuarterEnd, to_datetime, normalize_date,
     getOffset, getOffsetName, inferTimeRule, hasOffsetName,
-    _dt_box, _dt_unbox, parse_time_string, get_standard_freq)
+    _dt_box, _dt_unbox, parse_time_string, get_standard_freq,
+    _offset_map)
 
 from nose.tools import assert_raises
 
@@ -1310,6 +1311,30 @@ def test_get_standard_freq():
     assert fstr == get_standard_freq('5QuarTer')
     assert fstr == get_standard_freq(('q', 5))
 
+def test_rule_code():
+    lst = ['M', 'MS', 'BM', 'BMS', 'D', 'B', 'H', 'Min', 'S', 'L', 'U']
+    for k in lst:
+        assert k == _offset_map[k].rule_code()
+        assert k == (_offset_map[k] * 3).rule_code()
+
+    suffix_lst = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
+    base = 'W'
+    for v in suffix_lst:
+        alias = '@'.join([base, v])
+        assert alias == _offset_map[alias].rule_code()
+        assert alias == (_offset_map[alias] * 5).rule_code()
+
+    suffix_lst = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG',
+                  'SEP', 'OCT', 'NOV', 'DEC']
+    base_lst = ['A', 'AS', 'BA', 'BAS', 'Q', 'QS', 'BQ', 'BQS']
+    for base in base_lst:
+        for v in suffix_lst:
+            alias = '@'.join([base, v])
+            assert alias == _offset_map[alias].rule_code()
+            assert alias == (_offset_map[alias] * 5).rule_code()
+
+
+
 
 if __name__ == '__main__':
     import nose
diff --git a/pandas/tests/test_interval.py b/pandas/tests/test_interval.py
index a0424f0fb..2a374f46e 100644
--- a/pandas/tests/test_interval.py
+++ b/pandas/tests/test_interval.py
@@ -109,6 +109,30 @@ class TestIntervalProperties(TestCase):
         i2 = Interval('1982', freq=('Min', 1))
         self.assertEquals(i1, i2)
 
+    def test_to_timestamp(self):
+        intv = Interval('1982', freq='A')
+        start_ts = intv.to_timestamp(which_end='S')
+        aliases = ['s', 'StarT', 'BEGIn']
+        for a in aliases:
+            self.assertEquals(start_ts, intv.to_timestamp(which_end=a))
+
+        end_ts = intv.to_timestamp(which_end='E')
+        aliases = ['e', 'end', 'FINIsH']
+        for a in aliases:
+            self.assertEquals(end_ts, intv.to_timestamp(which_end=a))
+
+        from_lst = ['A', 'Q', 'M', 'W', 'B',
+                    'D', 'H', 'Min', 'S']
+        for i, fcode in enumerate(from_lst):
+            intv = Interval('1982', freq=fcode)
+            result = intv.to_timestamp().to_interval(fcode)
+            self.assertEquals(result, intv)
+
+            self.assertEquals(intv.start_time(), intv.to_timestamp('S'))
+
+            self.assertEquals(intv.end_time(), intv.to_timestamp('E'))
+
+
     def test_properties_annually(self):
         # Test properties on Intervals with annually frequency.
         a_date = Interval(freq='A', year=2007)

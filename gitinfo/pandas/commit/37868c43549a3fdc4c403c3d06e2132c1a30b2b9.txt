commit 37868c43549a3fdc4c403c3d06e2132c1a30b2b9
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Oct 31 20:10:25 2012 -0400

    BUG: correct computation of min/max for datetime64 and box result. close #2083

diff --git a/RELEASE.rst b/RELEASE.rst
index 8c25834d1..8cda23b8f 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -40,6 +40,7 @@ pandas 0.9.1
   - Fix matplotlib unicode interaction bug
   - Make WLS r-squared match statsmodels 0.5.0 fixed value
   - Fix zero-trimming DataFrame formatting bug
+  - Correctly compute/box datetime64 min/max values from Series.min/max (#2083)
 
 pandas 0.9.0
 ============
diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index 9a1785b95..8c6119fc8 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -34,7 +34,7 @@ def _bottleneck_switch(bn_name, alt, zero_value=None, **kwargs):
                     result.fill(0)
                     return result
 
-            if _USE_BOTTLENECK and skipna and values.dtype != np.object_:
+            if _USE_BOTTLENECK and skipna and _bn_ok_dtype(values.dtype):
                 result = bn_func(values, axis=axis, **kwds)
                 # prefer to treat inf/-inf as NA
                 if _has_infs(result):
@@ -48,6 +48,10 @@ def _bottleneck_switch(bn_name, alt, zero_value=None, **kwargs):
 
     return f
 
+def _bn_ok_dtype(dt):
+    # Bottleneck chokes on datetime64
+    return dt != np.object_ and not issubclass(dt.type, np.datetime64)
+
 
 def _has_infs(result):
     if isinstance(result, np.ndarray):
@@ -147,10 +151,17 @@ def _nanvar(values, axis=None, skipna=True, ddof=1):
 
 def _nanmin(values, axis=None, skipna=True):
     mask = isnull(values)
-    if skipna and not issubclass(values.dtype.type,
+
+    dtype = values.dtype
+
+    if skipna and not issubclass(dtype.type,
                                  (np.integer, np.datetime64)):
         values = values.copy()
         np.putmask(values, mask, np.inf)
+
+    if issubclass(dtype.type, np.datetime64):
+        values = values.view(np.int64)
+
     # numpy 1.6.1 workaround in Python 3.x
     if (values.dtype == np.object_
         and sys.version_info[0] >= 3):  # pragma: no cover
@@ -168,15 +179,27 @@ def _nanmin(values, axis=None, skipna=True):
         else:
             result = values.min(axis)
 
+    if issubclass(dtype.type, np.datetime64):
+        if not isinstance(result, np.ndarray):
+            result = lib.Timestamp(result)
+        else:
+            result = result.view(dtype)
+
     return _maybe_null_out(result, axis, mask)
 
 
 def _nanmax(values, axis=None, skipna=True):
     mask = isnull(values)
-    if skipna and not issubclass(values.dtype.type,
-                                 (np.integer, np.datetime64)):
+
+    dtype = values.dtype
+
+    if skipna and not issubclass(dtype.type, (np.integer, np.datetime64)):
         values = values.copy()
         np.putmask(values, mask, -np.inf)
+
+    if issubclass(dtype.type, np.datetime64):
+        values = values.view(np.int64)
+
     # numpy 1.6.1 workaround in Python 3.x
     if (values.dtype == np.object_
         and sys.version_info[0] >= 3):  # pragma: no cover
@@ -195,6 +218,12 @@ def _nanmax(values, axis=None, skipna=True):
         else:
             result = values.max(axis)
 
+    if issubclass(dtype.type, np.datetime64):
+        if not isinstance(result, np.ndarray):
+            result = lib.Timestamp(result)
+        else:
+            result = result.view(dtype)
+
     return _maybe_null_out(result, axis, mask)
 
 
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 559e35831..570905f2f 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -1781,6 +1781,21 @@ class TestLegacySupport(unittest.TestCase):
         self.assertEqual(rng.min(), rng[0])
         self.assertEqual(rng.max(), rng[-1])
 
+    def test_min_max_series(self):
+        rng = date_range('1/1/2000', periods=10, freq='4h')
+        lvls = ['A','A','A','B','B','B','C','C','C','C']
+        df = DataFrame({'TS': rng, 'V' : np.random.randn(len(rng)),
+                        'L' : lvls})
+
+        result = df.TS.max()
+        exp = Timestamp(df.TS.iget(-1))
+        self.assertTrue(isinstance(result, Timestamp))
+        self.assertEqual(result, exp)
+
+        result = df.TS.min()
+        exp = Timestamp(df.TS.iget(0))
+        self.assertTrue(isinstance(result, Timestamp))
+        self.assertEqual(result, exp)
 
 class TestLegacyCompat(unittest.TestCase):
 

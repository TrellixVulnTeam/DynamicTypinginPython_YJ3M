commit b3aff681cd30cadfa13552fee7289e8d8cef8693
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Thu Dec 26 05:27:08 2019 -0800

    REF/TST: directories for CategoricalIndex, RangeIndex tests (#30476)

diff --git a/pandas/tests/indexes/categorical/__init__.py b/pandas/tests/indexes/categorical/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/tests/indexes/test_category.py b/pandas/tests/indexes/categorical/test_category.py
similarity index 87%
rename from pandas/tests/indexes/test_category.py
rename to pandas/tests/indexes/categorical/test_category.py
index 7286fca42..9a5f9e403 100644
--- a/pandas/tests/indexes/test_category.py
+++ b/pandas/tests/indexes/categorical/test_category.py
@@ -12,7 +12,7 @@ from pandas import Categorical, IntervalIndex
 from pandas.core.indexes.api import CategoricalIndex, Index
 import pandas.util.testing as tm
 
-from .common import Base
+from ..common import Base
 
 
 class TestCategoricalIndex(Base):
@@ -32,147 +32,6 @@ class TestCategoricalIndex(Base):
         key = idx[0]
         assert idx._can_hold_identifiers_and_holds_name(key) is True
 
-    def test_construction(self):
-
-        ci = self.create_index(categories=list("abcd"))
-        categories = ci.categories
-
-        result = Index(ci)
-        tm.assert_index_equal(result, ci, exact=True)
-        assert not result.ordered
-
-        result = Index(ci.values)
-        tm.assert_index_equal(result, ci, exact=True)
-        assert not result.ordered
-
-        # empty
-        result = CategoricalIndex(categories=categories)
-        tm.assert_index_equal(result.categories, Index(categories))
-        tm.assert_numpy_array_equal(result.codes, np.array([], dtype="int8"))
-        assert not result.ordered
-
-        # passing categories
-        result = CategoricalIndex(list("aabbca"), categories=categories)
-        tm.assert_index_equal(result.categories, Index(categories))
-        tm.assert_numpy_array_equal(
-            result.codes, np.array([0, 0, 1, 1, 2, 0], dtype="int8")
-        )
-
-        c = pd.Categorical(list("aabbca"))
-        result = CategoricalIndex(c)
-        tm.assert_index_equal(result.categories, Index(list("abc")))
-        tm.assert_numpy_array_equal(
-            result.codes, np.array([0, 0, 1, 1, 2, 0], dtype="int8")
-        )
-        assert not result.ordered
-
-        result = CategoricalIndex(c, categories=categories)
-        tm.assert_index_equal(result.categories, Index(categories))
-        tm.assert_numpy_array_equal(
-            result.codes, np.array([0, 0, 1, 1, 2, 0], dtype="int8")
-        )
-        assert not result.ordered
-
-        ci = CategoricalIndex(c, categories=list("abcd"))
-        result = CategoricalIndex(ci)
-        tm.assert_index_equal(result.categories, Index(categories))
-        tm.assert_numpy_array_equal(
-            result.codes, np.array([0, 0, 1, 1, 2, 0], dtype="int8")
-        )
-        assert not result.ordered
-
-        result = CategoricalIndex(ci, categories=list("ab"))
-        tm.assert_index_equal(result.categories, Index(list("ab")))
-        tm.assert_numpy_array_equal(
-            result.codes, np.array([0, 0, 1, 1, -1, 0], dtype="int8")
-        )
-        assert not result.ordered
-
-        result = CategoricalIndex(ci, categories=list("ab"), ordered=True)
-        tm.assert_index_equal(result.categories, Index(list("ab")))
-        tm.assert_numpy_array_equal(
-            result.codes, np.array([0, 0, 1, 1, -1, 0], dtype="int8")
-        )
-        assert result.ordered
-
-        result = pd.CategoricalIndex(ci, categories=list("ab"), ordered=True)
-        expected = pd.CategoricalIndex(
-            ci, categories=list("ab"), ordered=True, dtype="category"
-        )
-        tm.assert_index_equal(result, expected, exact=True)
-
-        # turn me to an Index
-        result = Index(np.array(ci))
-        assert isinstance(result, Index)
-        assert not isinstance(result, CategoricalIndex)
-
-    def test_construction_with_dtype(self):
-
-        # specify dtype
-        ci = self.create_index(categories=list("abc"))
-
-        result = Index(np.array(ci), dtype="category")
-        tm.assert_index_equal(result, ci, exact=True)
-
-        result = Index(np.array(ci).tolist(), dtype="category")
-        tm.assert_index_equal(result, ci, exact=True)
-
-        # these are generally only equal when the categories are reordered
-        ci = self.create_index()
-
-        result = Index(np.array(ci), dtype="category").reorder_categories(ci.categories)
-        tm.assert_index_equal(result, ci, exact=True)
-
-        # make sure indexes are handled
-        expected = CategoricalIndex([0, 1, 2], categories=[0, 1, 2], ordered=True)
-        idx = Index(range(3))
-        result = CategoricalIndex(idx, categories=idx, ordered=True)
-        tm.assert_index_equal(result, expected, exact=True)
-
-    def test_construction_empty_with_bool_categories(self):
-        # see gh-22702
-        cat = pd.CategoricalIndex([], categories=[True, False])
-        categories = sorted(cat.categories.tolist())
-        assert categories == [False, True]
-
-    def test_construction_with_categorical_dtype(self):
-        # construction with CategoricalDtype
-        # GH18109
-        data, cats, ordered = "a a b b".split(), "c b a".split(), True
-        dtype = CategoricalDtype(categories=cats, ordered=ordered)
-
-        result = CategoricalIndex(data, dtype=dtype)
-        expected = CategoricalIndex(data, categories=cats, ordered=ordered)
-        tm.assert_index_equal(result, expected, exact=True)
-
-        # GH 19032
-        result = Index(data, dtype=dtype)
-        tm.assert_index_equal(result, expected, exact=True)
-
-        # error when combining categories/ordered and dtype kwargs
-        msg = "Cannot specify `categories` or `ordered` together with `dtype`."
-        with pytest.raises(ValueError, match=msg):
-            CategoricalIndex(data, categories=cats, dtype=dtype)
-
-        with pytest.raises(ValueError, match=msg):
-            Index(data, categories=cats, dtype=dtype)
-
-        with pytest.raises(ValueError, match=msg):
-            CategoricalIndex(data, ordered=ordered, dtype=dtype)
-
-        with pytest.raises(ValueError, match=msg):
-            Index(data, ordered=ordered, dtype=dtype)
-
-    def test_create_categorical(self):
-        # https://github.com/pandas-dev/pandas/pull/17513
-        # The public CI constructor doesn't hit this code path with
-        # instances of CategoricalIndex, but we still want to test the code
-        ci = CategoricalIndex(["a", "b", "c"])
-        # First ci is self, second ci is data.
-        result = CategoricalIndex._create_categorical(ci, ci)
-        expected = Categorical(["a", "b", "c"])
-        tm.assert_categorical_equal(result, expected)
-
     @pytest.mark.parametrize(
         "func,op_name",
         [
diff --git a/pandas/tests/indexes/categorical/test_constructors.py b/pandas/tests/indexes/categorical/test_constructors.py
new file mode 100644
index 000000000..f3d580b72
--- /dev/null
+++ b/pandas/tests/indexes/categorical/test_constructors.py
@@ -0,0 +1,147 @@
+import numpy as np
+import pytest
+
+from pandas import Categorical, CategoricalDtype, CategoricalIndex, Index
+import pandas.util.testing as tm
+
+
+class TestCategoricalIndexConstructors:
+    def test_construction(self):
+
+        ci = CategoricalIndex(list("aabbca"), categories=list("abcd"), ordered=False)
+        categories = ci.categories
+
+        result = Index(ci)
+        tm.assert_index_equal(result, ci, exact=True)
+        assert not result.ordered
+
+        result = Index(ci.values)
+        tm.assert_index_equal(result, ci, exact=True)
+        assert not result.ordered
+
+        # empty
+        result = CategoricalIndex(categories=categories)
+        tm.assert_index_equal(result.categories, Index(categories))
+        tm.assert_numpy_array_equal(result.codes, np.array([], dtype="int8"))
+        assert not result.ordered
+
+        # passing categories
+        result = CategoricalIndex(list("aabbca"), categories=categories)
+        tm.assert_index_equal(result.categories, Index(categories))
+        tm.assert_numpy_array_equal(
+            result.codes, np.array([0, 0, 1, 1, 2, 0], dtype="int8")
+        )
+
+        c = Categorical(list("aabbca"))
+        result = CategoricalIndex(c)
+        tm.assert_index_equal(result.categories, Index(list("abc")))
+        tm.assert_numpy_array_equal(
+            result.codes, np.array([0, 0, 1, 1, 2, 0], dtype="int8")
+        )
+        assert not result.ordered
+
+        result = CategoricalIndex(c, categories=categories)
+        tm.assert_index_equal(result.categories, Index(categories))
+        tm.assert_numpy_array_equal(
+            result.codes, np.array([0, 0, 1, 1, 2, 0], dtype="int8")
+        )
+        assert not result.ordered
+
+        ci = CategoricalIndex(c, categories=list("abcd"))
+        result = CategoricalIndex(ci)
+        tm.assert_index_equal(result.categories, Index(categories))
+        tm.assert_numpy_array_equal(
+            result.codes, np.array([0, 0, 1, 1, 2, 0], dtype="int8")
+        )
+        assert not result.ordered
+
+        result = CategoricalIndex(ci, categories=list("ab"))
+        tm.assert_index_equal(result.categories, Index(list("ab")))
+        tm.assert_numpy_array_equal(
+            result.codes, np.array([0, 0, 1, 1, -1, 0], dtype="int8")
+        )
+        assert not result.ordered
+
+        result = CategoricalIndex(ci, categories=list("ab"), ordered=True)
+        tm.assert_index_equal(result.categories, Index(list("ab")))
+        tm.assert_numpy_array_equal(
+            result.codes, np.array([0, 0, 1, 1, -1, 0], dtype="int8")
+        )
+        assert result.ordered
+
+        result = CategoricalIndex(ci, categories=list("ab"), ordered=True)
+        expected = CategoricalIndex(
+            ci, categories=list("ab"), ordered=True, dtype="category"
+        )
+        tm.assert_index_equal(result, expected, exact=True)
+
+        # turn me to an Index
+        result = Index(np.array(ci))
+        assert isinstance(result, Index)
+        assert not isinstance(result, CategoricalIndex)
+
+    def test_construction_with_dtype(self):
+
+        # specify dtype
+        ci = CategoricalIndex(list("aabbca"), categories=list("abc"), ordered=False)
+
+        result = Index(np.array(ci), dtype="category")
+        tm.assert_index_equal(result, ci, exact=True)
+
+        result = Index(np.array(ci).tolist(), dtype="category")
+        tm.assert_index_equal(result, ci, exact=True)
+
+        # these are generally only equal when the categories are reordered
+        ci = CategoricalIndex(list("aabbca"), categories=list("cab"), ordered=False)
+
+        result = Index(np.array(ci), dtype="category").reorder_categories(ci.categories)
+        tm.assert_index_equal(result, ci, exact=True)
+
+        # make sure indexes are handled
+        expected = CategoricalIndex([0, 1, 2], categories=[0, 1, 2], ordered=True)
+        idx = Index(range(3))
+        result = CategoricalIndex(idx, categories=idx, ordered=True)
+        tm.assert_index_equal(result, expected, exact=True)
+
+    def test_construction_empty_with_bool_categories(self):
+        # see GH#22702
+        cat = CategoricalIndex([], categories=[True, False])
+        categories = sorted(cat.categories.tolist())
+        assert categories == [False, True]
+
+    def test_construction_with_categorical_dtype(self):
+        # construction with CategoricalDtype
+        # GH#18109
+        data, cats, ordered = "a a b b".split(), "c b a".split(), True
+        dtype = CategoricalDtype(categories=cats, ordered=ordered)
+
+        result = CategoricalIndex(data, dtype=dtype)
+        expected = CategoricalIndex(data, categories=cats, ordered=ordered)
+        tm.assert_index_equal(result, expected, exact=True)
+
+        # GH#19032
+        result = Index(data, dtype=dtype)
+        tm.assert_index_equal(result, expected, exact=True)
+
+        # error when combining categories/ordered and dtype kwargs
+        msg = "Cannot specify `categories` or `ordered` together with `dtype`."
+        with pytest.raises(ValueError, match=msg):
+            CategoricalIndex(data, categories=cats, dtype=dtype)
+
+        with pytest.raises(ValueError, match=msg):
+            Index(data, categories=cats, dtype=dtype)
+
+        with pytest.raises(ValueError, match=msg):
+            CategoricalIndex(data, ordered=ordered, dtype=dtype)
+
+        with pytest.raises(ValueError, match=msg):
+            Index(data, ordered=ordered, dtype=dtype)
+
+    def test_create_categorical(self):
+        # GH#17513 The public CI constructor doesn't hit this code path with
+        # instances of CategoricalIndex, but we still want to test the code
+        ci = CategoricalIndex(["a", "b", "c"])
+        # First ci is self, second ci is data.
+        result = CategoricalIndex._create_categorical(ci, ci)
+        expected = Categorical(["a", "b", "c"])
+        tm.assert_categorical_equal(result, expected)
diff --git a/pandas/tests/indexes/ranges/__init__.py b/pandas/tests/indexes/ranges/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/tests/indexes/ranges/test_constructors.py b/pandas/tests/indexes/ranges/test_constructors.py
new file mode 100644
index 000000000..5067b6c74
--- /dev/null
+++ b/pandas/tests/indexes/ranges/test_constructors.py
@@ -0,0 +1,154 @@
+from datetime import datetime
+
+import numpy as np
+import pytest
+
+from pandas import Index, RangeIndex, Series
+import pandas.util.testing as tm
+
+
+class TestRangeIndexConstructors:
+    @pytest.mark.parametrize("name", [None, "foo"])
+    @pytest.mark.parametrize(
+        "args, kwargs, start, stop, step",
+        [
+            ((5,), dict(), 0, 5, 1),
+            ((1, 5), dict(), 1, 5, 1),
+            ((1, 5, 2), dict(), 1, 5, 2),
+            ((0,), dict(), 0, 0, 1),
+            ((0, 0), dict(), 0, 0, 1),
+            (tuple(), dict(start=0), 0, 0, 1),
+            (tuple(), dict(stop=0), 0, 0, 1),
+        ],
+    )
+    def test_constructor(self, args, kwargs, start, stop, step, name):
+        result = RangeIndex(*args, name=name, **kwargs)
+        expected = Index(np.arange(start, stop, step, dtype=np.int64), name=name)
+        assert isinstance(result, RangeIndex)
+        assert result.name is name
+        assert result._range == range(start, stop, step)
+        tm.assert_index_equal(result, expected)
+
+    def test_constructor_invalid_args(self):
+        msg = "RangeIndex\\(\\.\\.\\.\\) must be called with integers"
+        with pytest.raises(TypeError, match=msg):
+            RangeIndex()
+
+        with pytest.raises(TypeError, match=msg):
+            RangeIndex(name="Foo")
+
+        # invalid args
+        for i in [
+            Index(["a", "b"]),
+            Series(["a", "b"]),
+            np.array(["a", "b"]),
+            [],
+            "foo",
+            datetime(2000, 1, 1, 0, 0),
+            np.arange(0, 10),
+            np.array([1]),
+            [1],
+        ]:
+            with pytest.raises(TypeError):
+                RangeIndex(i)
+
+        # we don't allow on a bare Index
+        msg = (
+            r"Index\(\.\.\.\) must be called with a collection of some "
+            r"kind, 0 was passed"
+        )
+        with pytest.raises(TypeError, match=msg):
+            Index(0, 1000)
+
+    def test_constructor_same(self):
+
+        # pass thru w and w/o copy
+        index = RangeIndex(1, 5, 2)
+        result = RangeIndex(index, copy=False)
+        assert result.identical(index)
+
+        result = RangeIndex(index, copy=True)
+        tm.assert_index_equal(result, index, exact=True)
+
+        result = RangeIndex(index)
+        tm.assert_index_equal(result, index, exact=True)
+
+        with pytest.raises(
+            ValueError,
+            match="Incorrect `dtype` passed: expected signed integer, received float64",
+        ):
+            RangeIndex(index, dtype="float64")
+
+    def test_constructor_range(self):
+
+        msg = "Value needs to be a scalar value, was type <class 'range'>"
+        with pytest.raises(TypeError, match=msg):
+            result = RangeIndex(range(1, 5, 2))
+
+        result = RangeIndex.from_range(range(1, 5, 2))
+        expected = RangeIndex(1, 5, 2)
+        tm.assert_index_equal(result, expected, exact=True)
+
+        result = RangeIndex.from_range(range(5, 6))
+        expected = RangeIndex(5, 6, 1)
+        tm.assert_index_equal(result, expected, exact=True)
+
+        # an invalid range
+        result = RangeIndex.from_range(range(5, 1))
+        expected = RangeIndex(0, 0, 1)
+        tm.assert_index_equal(result, expected, exact=True)
+
+        result = RangeIndex.from_range(range(5))
+        expected = RangeIndex(0, 5, 1)
+        tm.assert_index_equal(result, expected, exact=True)
+
+        result = Index(range(1, 5, 2))
+        expected = RangeIndex(1, 5, 2)
+        tm.assert_index_equal(result, expected, exact=True)
+
+        with pytest.raises(
+            ValueError,
+            match="Incorrect `dtype` passed: expected signed integer, received float64",
+        ):
+            Index(range(1, 5, 2), dtype="float64")
+        msg = r"^from_range\(\) got an unexpected keyword argument"
+        with pytest.raises(TypeError, match=msg):
+            RangeIndex.from_range(range(10), copy=True)
+
+    def test_constructor_name(self):
+        # GH#12288
+        orig = RangeIndex(10)
+        orig.name = "original"
+
+        copy = RangeIndex(orig)
+        copy.name = "copy"
+
+        assert orig.name == "original"
+        assert copy.name == "copy"
+
+        new = Index(copy)
+        assert new.name == "copy"
+
+        new.name = "new"
+        assert orig.name == "original"
+        assert copy.name == "copy"
+        assert new.name == "new"
+
+    def test_constructor_corner(self):
+        arr = np.array([1, 2, 3, 4], dtype=object)
+        index = RangeIndex(1, 5)
+        assert index.values.dtype == np.int64
+        tm.assert_index_equal(index, Index(arr))
+
+        # non-int raise Exception
+        with pytest.raises(TypeError):
+            RangeIndex("1", "10", "1")
+        with pytest.raises(TypeError):
+            RangeIndex(1.1, 10.2, 1.3)
+
+        # invalid passed type
+        with pytest.raises(
+            ValueError,
+            match="Incorrect `dtype` passed: expected signed integer, received float64",
+        ):
+            RangeIndex(1, 5, dtype="float64")
diff --git a/pandas/tests/indexes/test_range.py b/pandas/tests/indexes/ranges/test_range.py
similarity index 86%
rename from pandas/tests/indexes/test_range.py
rename to pandas/tests/indexes/ranges/test_range.py
index 13b8ca2a8..c9ef6677c 100644
--- a/pandas/tests/indexes/test_range.py
+++ b/pandas/tests/indexes/ranges/test_range.py
@@ -6,10 +6,10 @@ import pytest
 from pandas.core.dtypes.common import ensure_platform_int
 
 import pandas as pd
-from pandas import Float64Index, Index, Int64Index, RangeIndex, Series
+from pandas import Float64Index, Index, Int64Index, RangeIndex
 import pandas.util.testing as tm
 
-from .test_numeric import Numeric
+from ..test_numeric import Numeric
 
 # aliases to make some tests easier to read
 RI = RangeIndex
@@ -45,151 +45,6 @@ class TestRangeIndex(Numeric):
         with pytest.raises(ValueError, match="^Length"):
             index.names = ["roger", "harold"]
 
-    @pytest.mark.parametrize("name", [None, "foo"])
-    @pytest.mark.parametrize(
-        "args, kwargs, start, stop, step",
-        [
-            ((5,), dict(), 0, 5, 1),
-            ((1, 5), dict(), 1, 5, 1),
-            ((1, 5, 2), dict(), 1, 5, 2),
-            ((0,), dict(), 0, 0, 1),
-            ((0, 0), dict(), 0, 0, 1),
-            (tuple(), dict(start=0), 0, 0, 1),
-            (tuple(), dict(stop=0), 0, 0, 1),
-        ],
-    )
-    def test_constructor(self, args, kwargs, start, stop, step, name):
-        result = RangeIndex(*args, name=name, **kwargs)
-        expected = Index(np.arange(start, stop, step, dtype=np.int64), name=name)
-        assert isinstance(result, RangeIndex)
-        assert result.name is name
-        assert result._range == range(start, stop, step)
-        tm.assert_index_equal(result, expected)
-
-    def test_constructor_invalid_args(self):
-        msg = "RangeIndex\\(\\.\\.\\.\\) must be called with integers"
-        with pytest.raises(TypeError, match=msg):
-            RangeIndex()
-
-        with pytest.raises(TypeError, match=msg):
-            RangeIndex(name="Foo")
-
-        # invalid args
-        for i in [
-            Index(["a", "b"]),
-            Series(["a", "b"]),
-            np.array(["a", "b"]),
-            [],
-            "foo",
-            datetime(2000, 1, 1, 0, 0),
-            np.arange(0, 10),
-            np.array([1]),
-            [1],
-        ]:
-            with pytest.raises(TypeError):
-                RangeIndex(i)
-
-        # we don't allow on a bare Index
-        msg = (
-            r"Index\(\.\.\.\) must be called with a collection of some "
-            r"kind, 0 was passed"
-        )
-        with pytest.raises(TypeError, match=msg):
-            Index(0, 1000)
-
-    def test_constructor_same(self):
-
-        # pass thru w and w/o copy
-        index = RangeIndex(1, 5, 2)
-        result = RangeIndex(index, copy=False)
-        assert result.identical(index)
-
-        result = RangeIndex(index, copy=True)
-        tm.assert_index_equal(result, index, exact=True)
-
-        result = RangeIndex(index)
-        tm.assert_index_equal(result, index, exact=True)
-
-        with pytest.raises(
-            ValueError,
-            match="Incorrect `dtype` passed: expected signed integer, received float64",
-        ):
-            RangeIndex(index, dtype="float64")
-
-    def test_constructor_range(self):
-
-        msg = "Value needs to be a scalar value, was type <class 'range'>"
-        with pytest.raises(TypeError, match=msg):
-            result = RangeIndex(range(1, 5, 2))
-
-        result = RangeIndex.from_range(range(1, 5, 2))
-        expected = RangeIndex(1, 5, 2)
-        tm.assert_index_equal(result, expected, exact=True)
-
-        result = RangeIndex.from_range(range(5, 6))
-        expected = RangeIndex(5, 6, 1)
-        tm.assert_index_equal(result, expected, exact=True)
-
-        # an invalid range
-        result = RangeIndex.from_range(range(5, 1))
-        expected = RangeIndex(0, 0, 1)
-        tm.assert_index_equal(result, expected, exact=True)
-
-        result = RangeIndex.from_range(range(5))
-        expected = RangeIndex(0, 5, 1)
-        tm.assert_index_equal(result, expected, exact=True)
-
-        result = Index(range(1, 5, 2))
-        expected = RangeIndex(1, 5, 2)
-        tm.assert_index_equal(result, expected, exact=True)
-
-        with pytest.raises(
-            ValueError,
-            match="Incorrect `dtype` passed: expected signed integer, received float64",
-        ):
-            Index(range(1, 5, 2), dtype="float64")
-        msg = r"^from_range\(\) got an unexpected keyword argument"
-        with pytest.raises(TypeError, match=msg):
-            pd.RangeIndex.from_range(range(10), copy=True)
-
-    def test_constructor_name(self):
-        # GH12288
-        orig = RangeIndex(10)
-        orig.name = "original"
-
-        copy = RangeIndex(orig)
-        copy.name = "copy"
-
-        assert orig.name == "original"
-        assert copy.name == "copy"
-
-        new = Index(copy)
-        assert new.name == "copy"
-
-        new.name = "new"
-        assert orig.name == "original"
-        assert copy.name == "copy"
-        assert new.name == "new"
-
-    def test_constructor_corner(self):
-        arr = np.array([1, 2, 3, 4], dtype=object)
-        index = RangeIndex(1, 5)
-        assert index.values.dtype == np.int64
-        tm.assert_index_equal(index, Index(arr))
-
-        # non-int raise Exception
-        with pytest.raises(TypeError):
-            RangeIndex("1", "10", "1")
-        with pytest.raises(TypeError):
-            RangeIndex(1.1, 10.2, 1.3)
-
-        # invalid passed type
-        with pytest.raises(
-            ValueError,
-            match="Incorrect `dtype` passed: expected signed integer, received float64",
-        ):
-            RangeIndex(1, 5, dtype="float64")
-
     @pytest.mark.parametrize(
         "index, start, stop, step",
         [

commit 17459da718c074b202e75d7ae43717407482c1ee
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Apr 21 17:28:50 2011 -0400

    block union routine finally working

diff --git a/pandas/lib/src/sparse.pyx b/pandas/lib/src/sparse.pyx
index e2a71e703..04dfe2c39 100644
--- a/pandas/lib/src/sparse.pyx
+++ b/pandas/lib/src/sparse.pyx
@@ -287,8 +287,7 @@ cdef class BlockIndex(SparseIndex):
             list out_blengths = []
 
             pyst xi = 0, yi = 0
-            int32_t cur_loc, cur_length, xend, yend, diff
-
+            int32_t cur_loc, cur_length, diff
 
         y = other.to_block_index()
 
@@ -345,7 +344,7 @@ cdef class BlockIndex(SparseIndex):
             out_blocs.append(cur_loc)
             out_blengths.append(cur_length)
 
-        return BlockIndex(self.length, out_blocs, out_blengths)
+        return BlockIndex(out_length, out_blocs, out_blengths)
 
     cpdef BlockIndex make_union(self, SparseIndex other):
         '''
@@ -364,74 +363,150 @@ cdef class BlockIndex(SparseIndex):
         -------
         union : BlockIndex
         '''
-        cdef:
-            BlockIndex y
-            pyst out_length
-            ndarray[int32_t, ndim=1] xloc, xlen, yloc, ylen
+        return BlockUnion(self, other.to_block_index()).result
 
-            list out_blocs = []
-            list out_blengths = []
+# class BlockIntersection(object):
 
-            pyst xi = 0, yi = 0 # block indices
-            int32_t cur_loc, cur_length, xend, yend, diff
+#     def __init__(self, BlockIndex x, BlockIndex y):
+#         pass
 
+cdef class BlockUnion(object):
+    '''
+    Object-oriented approach makes sharing state between recursive functions a
+    lot easier and reduces code duplication
+    '''
+    cdef:
+        BlockIndex x, y, result
+        ndarray xstart, xend, ystart, yend
+        int32_t xi, yi # block indices
 
-        y = other.to_block_index()
+    def __init__(self, BlockIndex x, BlockIndex y):
+        self.x = x
+        self.y = y
 
-        # unwise? should enforce same length?
-        out_length = int_max(self.length, y.length)
+        self.xstart = self.x.blocs
+        self.xend = self.x.blocs + self.x.blengths
+        self.ystart = self.y.blocs
+        self.yend = self.y.blocs + self.y.blengths
 
-        xloc = self.blocs
-        xlen = self.blengths
-        yloc = y.blocs
-        ylen = y.blengths
+        self.xi = 0
+        self.yi = 0
+
+        self.result = self._make_merged_blocks()
+
+    cdef _make_merged_blocks(self):
+        cdef:
+            pyst out_length
+            ndarray[int32_t, ndim=1] xstart, xend, ystart, yend
+            int32_t nstart, nend, diff
+            list out_blocs = [], out_blengths = []
+
+        out_length = int_max(self.x.length, self.y.length)
+
+        xstart = self.xstart
+        xend = self.xend
+        ystart = self.ystart
+        yend = self.yend
 
         while True:
             # we are done (or possibly never began)
-            if xi >= self.nblocks or yi >= y.nblocks:
+            if self.xi >= self.x.nblocks and self.yi >= self.y.nblocks:
                 break
+            elif self.yi >= self.y.nblocks:
+                # through with y, just pass through x blocks
+                nstart = xstart[self.xi]
+                nend = xend[self.xi]
+                self.xi += 1
+            elif self.xi >= self.x.nblocks:
+                # through with x, just pass through y blocks
+                nstart = ystart[self.yi]
+                nend = yend[self.yi]
+                self.yi += 1
+            else:
+                # find end of new block
+                if xstart[self.xi] < ystart[self.yi]:
+                    nstart = xstart[self.xi]
+                    nend = self._find_next_block_end(0)
+                else:
+                    nstart = ystart[self.yi]
+                    nend = self._find_next_block_end(1)
 
-            # completely symmetric...would like to avoid code dup but oh well
-            if xloc[xi] >= yloc[yi]:
-                cur_loc = xloc[xi]
-                diff = xloc[xi] - yloc[yi]
-
-                if ylen[yi] - diff <= 0:
-                    # have to skip this block
-                    yi += 1
-                    continue
+            out_blocs.append(nstart)
+            out_blengths.append(nend - nstart)
 
-                if ylen[yi] - diff < xlen[xi]:
-                    # take end of y block, move onward
-                    cur_length = ylen[yi] - diff
-                    yi += 1
-                else:
-                    # take end of x block
-                    cur_length = xlen[xi]
-                    xi += 1
+        return BlockIndex(out_length, out_blocs, out_blengths)
 
-            else: # xloc[xi] < yloc[yi]
-                cur_loc = yloc[yi]
-                diff = yloc[yi] - xloc[xi]
+    cdef int32_t _find_next_block_end(self, bint mode) except -1:
+        '''
+        Wow, this got complicated in a hurry
 
-                if xlen[xi] - diff <= 0:
-                    # have to skip this block
-                    xi += 1
-                    continue
+        mode 0: block started in index x
+        mode 1: block started in index y
+        '''
+        cdef:
+            ndarray[int32_t, ndim=1] xstart, xend, ystart, yend
+            int32_t xi, yi, xnblocks, ynblocks, nend
+
+        if mode != 0 and mode != 1:
+            raise Exception('Mode must be 0 or 1')
+
+        # so symmetric code will work
+        if mode == 0:
+            xstart = self.xstart
+            xend = self.xend
+            xi = self.xi
+
+            ystart = self.ystart
+            yend = self.yend
+            yi = self.yi
+            ynblocks = self.y.nblocks
+        else:
+            xstart = self.ystart
+            xend = self.yend
+            xi = self.yi
+
+            ystart = self.xstart
+            yend = self.xend
+            yi = self.xi
+            ynblocks = self.x.nblocks
+
+        nend = xend[xi]
+
+        # print 'here xi=%d, yi=%d, mode=%d, nend=%d' % (self.xi, self.yi,
+        #                                                mode, nend)
+
+        # done with y?
+        if yi == ynblocks:
+            self._set_current_indices(xi + 1, yi, mode)
+            return nend
+        elif nend < ystart[yi]:
+            # block ends before y block
+            self._set_current_indices(xi + 1, yi, mode)
+            return nend
+        else:
+            while yi < ynblocks and nend > yend[yi]:
+                yi += 1
 
-                if xlen[xi] - diff < ylen[yi]:
-                    # take end of x block, move onward
-                    cur_length = xlen[xi] - diff
-                    xi += 1
-                else:
-                    # take end of y block
-                    cur_length = ylen[yi]
-                    yi += 1
+            self._set_current_indices(xi + 1, yi, mode)
 
-            out_blocs.append(cur_loc)
-            out_blengths.append(cur_length)
+            if yi == ynblocks:
+                return nend
 
-        return BlockIndex(self.length, out_blocs, out_blengths)
+            if nend < ystart[yi]:
+                # we're done, return the block end
+                return nend
+            else:
+                # merge blocks, continue searching
+                # this also catches the case where blocks
+                return self._find_next_block_end(1 - mode)
+
+    cdef _set_current_indices(self, int32_t xi, int32_t yi, bint mode):
+        if mode == 0:
+            self.xi = xi
+            self.yi = yi
+        else:
+            self.xi = yi
+            self.yi = xi
 
 #-------------------------------------------------------------------------------
 # Sparse arithmetic
@@ -467,27 +542,27 @@ cdef tuple sparse_nancombine(ndarray x, SparseIndex xindex,
 
 cpdef sparse_add(ndarray x, SparseIndex xindex, float64_t xfill,
                  ndarray y, SparseIndex yindex, float64_t yfill):
-    return sparse_nancombine(x, xindex, xfill,
+    return sparse_combine(x, xindex, xfill,
                              y, yindex, yfill, __add)
 
 cpdef sparse_sub(ndarray x, SparseIndex xindex, float64_t xfill,
                  ndarray y, SparseIndex yindex, float64_t yfill):
-    return sparse_nancombine(x, xindex, xfill,
+    return sparse_combine(x, xindex, xfill,
                              y, yindex, yfill, __sub)
 
 cpdef sparse_mul(ndarray x, SparseIndex xindex, float64_t xfill,
                  ndarray y, SparseIndex yindex, float64_t yfill):
-    return sparse_nancombine(x, xindex, xfill,
+    return sparse_combine(x, xindex, xfill,
                              y, yindex, yfill, __mul)
 
 cpdef sparse_div(ndarray x, SparseIndex xindex, float64_t xfill,
                  ndarray y, SparseIndex yindex, float64_t yfill):
-    return sparse_nancombine(x, xindex, xfill,
+    return sparse_combine(x, xindex, xfill,
                              y, yindex, yfill, __div)
 
 cpdef sparse_pow(ndarray x, SparseIndex xindex, float64_t xfill,
                  ndarray y, SparseIndex yindex, float64_t yfill):
-    return sparse_nancombine(x, xindex, xfill,
+    return sparse_combine(x, xindex, xfill,
                              y, yindex, yfill, __pow)
 
 cdef tuple sparse_combine(ndarray x, SparseIndex xindex, float64_t xfill,
diff --git a/pandas/lib/tests/test_sparse.py b/pandas/lib/tests/test_sparse.py
index 583c295b2..5ab35a8ab 100644
--- a/pandas/lib/tests/test_sparse.py
+++ b/pandas/lib/tests/test_sparse.py
@@ -96,6 +96,93 @@ class TestBlockIndex(TestCase):
 
         check_cases(_check_case)
 
+    def test_make_union(self):
+        def _check_case(xloc, xlen, yloc, ylen, eloc, elen):
+            xindex = BlockIndex(TEST_LENGTH, xloc, xlen)
+            yindex = BlockIndex(TEST_LENGTH, yloc, ylen)
+            result = xindex.make_union(yindex)
+            self.assert_(isinstance(result, BlockIndex))
+            assert_equal(result.blocs, eloc)
+            assert_equal(result.blengths, elen)
+
+        """
+        x: ----
+        y:     ----
+        r: --------
+        """
+        xloc = [0]; xlen = [5]
+        yloc = [5]; ylen = [4]
+        eloc = [0]; elen = [9]
+        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+        """
+        x: -----     -----
+        y:   -----          --
+        """
+        xloc = [0, 10]; xlen = [5, 5]
+        yloc = [2, 17]; ylen = [5, 2]
+        eloc = [0, 10, 17]; elen = [7, 5, 2]
+        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+        """
+        x: ------
+        y:    -------
+        r: ----------
+        """
+        xloc = [1]; xlen = [5]
+        yloc = [3]; ylen = [5]
+        eloc = [1]; elen = [7]
+        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+        """
+        x: ------  -----
+        y:    -------
+        r: -------------
+        """
+        xloc = [2, 10]; xlen = [4, 4]
+        yloc = [4]; ylen = [8]
+        eloc = [2]; elen = [12]
+        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+        """
+        x: ---  -----
+        y: -------
+        r: -------------
+        """
+        xloc = [0, 5]; xlen = [3, 5]
+        yloc = [0]; ylen = [7]
+        eloc = [0]; elen = [10]
+        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+        """
+        x: ------  -----
+        y:    -------  ---
+        r: -------------
+        """
+        xloc = [2, 10]; xlen = [4, 4]
+        yloc = [4, 13]; ylen = [8, 4]
+        eloc = [2]; elen = [15]
+        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+        """
+        x: ----------------------
+        y:   ----  ----   ---
+        r: ----------------------
+        """
+        xloc = [2]; xlen = [15]
+        yloc = [4, 9, 14]; ylen = [3, 2, 2]
+        eloc = [2]; elen = [15]
+        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+        """
+        x: ----       ---
+        y:       ---       ---
+        """
+        xloc = [0, 10]; xlen = [3, 3]
+        yloc = [5, 15]; ylen = [2, 2]
+        eloc = [0, 5, 10, 15]; elen = [3, 2, 3, 2]
+        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
     def test_to_int_index(self):
         locs = [0, 10]
         lengths = [4, 6]
@@ -149,9 +236,10 @@ class TestIntIndex(TestCase):
 
         check_cases(_check_case)
 
-    def test_union(self):
+    def test_make_union(self):
         pass
 
+
 class TestSparseOperators(TestCase):
 
     def _arith_op_tests(self, sparse_op, python_op):

commit 457c5bbe84845313e606faa215fe668b25aa044f
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Nov 23 22:33:56 2009 +0000

    added time rule mappings in datetools.py and connected with shift, asfreq methods'
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@52 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index 38d5febaf..1ac9e252f 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -37,7 +37,14 @@ class XDateRange(object):
     _cacheStart = {}
     _cacheEnd = {}
     def __init__(self, fromDate=None, toDate=None, nPeriods=None,
-                 offset=datetools.BDay()):
+                 offset = datetools.BDay(), timeRule=None):
+
+        if timeRule is not None:
+            offset = datetools.getOffset(timeRule)
+
+        if timeRule is None:
+            if offset in datetools._offsetNames:
+                timeRule = datetools._offsetNames[offset]
 
         fromDate = datetools.to_datetime(fromDate)
         toDate = datetools.to_datetime(toDate)
@@ -57,6 +64,7 @@ class XDateRange(object):
             fromDate = toDate - (nPeriods - 1) * offset
 
         self.offset = offset
+        self.timeRule = timeRule
         self.fromDate = fromDate
         self.toDate = toDate
         self.nPeriods = nPeriods
@@ -106,7 +114,7 @@ class DateRange(Index):
     """
     _cache = {}
     def __new__(cls, fromDate=None, toDate=None, periods=None,
-                offset=datetools.bday, **kwds):
+                offset=datetools.bday, timeRule=None, **kwds):
 
         # Allow us to circumvent hitting the cache
         index = kwds.get('index')
@@ -121,10 +129,11 @@ class DateRange(Index):
 
             if offset.isAnchored() and not isinstance(offset, datetools.Tick):
                 index = cls.getCachedRange(fromDate, toDate, periods=periods,
-                                           offset=offset)
+                                           offset=offset, timeRule=timeRule)
             else:
                 xdr = XDateRange(fromDate=fromDate, toDate=toDate,
-                                 nPeriods=periods, offset=offset)
+                                 nPeriods=periods, offset=offset,
+                                 timeRule=timeRule)
 
                 index = np.array(list(xdr), dtype=object, copy=False)
 
@@ -135,8 +144,15 @@ class DateRange(Index):
 
         return index
 
+
     @classmethod
-    def getCachedRange(cls, start=None, end=None, periods=None, offset=None):
+    def getCachedRange(cls, start=None, end=None, periods=None, offset=None,
+                       timeRule=None):
+
+        # HACK: fix this dependency later
+        if timeRule is not None:
+            offset = datetools.getOffset(timeRule)
+
         if offset is None:
             raise Exception('Must provide a DateOffset!')
 
diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index ebed5f531..66c2fc1ec 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -21,8 +21,8 @@ def ole2datetime(oledt):
     val = float(oledt)
     if val < 61:
         raise Exception("Value is outside of acceptable range: %s " % val)
-    return OLE_TIME_ZERO + timedelta(days=val)  
-            
+    return OLE_TIME_ZERO + timedelta(days=val)
+
 def to_datetime(input):
     """Attempts to convert input to datetime"""
     if input is None or isinstance(input, datetime):
@@ -102,7 +102,7 @@ class DateOffset(object):
 
     def isAnchored(self):
         return (self.n == 1)
-        
+
     def copy(self):
         return self.__class__(self.n, **self.kwds)
 
@@ -187,7 +187,7 @@ class DateOffset(object):
         obj = cls()
         return someDate == ((someDate + obj) - obj)
 
-    
+
 class BDay(DateOffset):
     """
     DateOffset subclass representing possibly n business days
@@ -248,7 +248,7 @@ class BDay(DateOffset):
     def onOffset(cls, someDate):
         return someDate.weekday() < 5
 
-    
+
 class MonthEnd(DateOffset):
     _normalizeFirst = True
     """DateOffset of one month end"""
@@ -459,7 +459,7 @@ class YearBegin(DateOffset):
 
 class Tick(DateOffset):
     pass
-    
+
 class Hour(Tick):
     _normalizeFirst = False
     _delta = None
@@ -528,3 +528,64 @@ thisBQuarterEnd = BQuarterEnd(0)
 isBusinessDay = BDay.onOffset
 isMonthEnd = MonthEnd.onOffset
 isBMonthEnd = BMonthEnd.onOffset
+
+#-------------------------------------------------------------------------------
+# Offset names ("time rules") and related functions
+
+_offsetMap = {
+    "WEEKDAY"  : BDay(1),
+    "EOM"      : BMonthEnd(1),
+    "W@MON"    : Week(dayOfWeek=0),
+    "W@TUE"    : Week(dayOfWeek=1),
+    "W@WED"    : Week(dayOfWeek=2),
+    "W@THU"    : Week(dayOfWeek=3),
+    "W@FRI"    : Week(dayOfWeek=4),
+    "Q@JAN"    : BQuarterEnd(startingMonth=1),
+    "Q@FEB"    : BQuarterEnd(startingMonth=2),
+    "Q@MAR"    : BQuarterEnd(startingMonth=3),
+    "A@DEC"    : BYearEnd()
+}
+
+_offsetNames = dict([(v, k) for k, v in _offsetMap.iteritems()])
+
+def inferTimeRule(index):
+    if len(index) <= 1:
+        raise Exception('Need at least two dates to infer time rule!')
+
+    first, second, third = index[:3]
+    for rule, offset in _offsetMap.iteritems():
+        if second == (first + offset) and third == (second + offset):
+            return rule
+
+    raise Exception('Could not infer time rule from data!')
+
+def getOffset(name):
+    """
+    Return DateOffset object associated with rule name
+
+    Example
+    -------
+    getOffset('EOM') --> BMonthEnd(1)
+    """
+    offset = _offsetMap.get(name)
+    if offset is not None:
+        return offset
+    else:
+        raise Exception('Bad rule name requested: %s!' % name)
+
+def hasOffsetName(offset):
+    return offset in _offsetNames
+
+def getOffsetName(offset):
+    """
+    Return rule name associated with a DateOffset object
+
+    Example
+    -------
+    getOffsetName(BMonthEnd(1)) --> 'EOM'
+    """
+    name = _offsetNames.get(offset)
+    if name is not None:
+        return name
+    else:
+        raise Exception('Bad offset name requested: %s!' % offset)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 5eaa71b49..db95ec0da 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -668,12 +668,12 @@ class DataFrame(Picklable, Groupable):
         fillMethod: {'backfill', 'pad', 'interpolate', None}
                     Method to use for filling holes in new inde
         """
-        if not isinstance(freq, datetools.DateOffset):
-            raise Exception('Must pass DateOffset!')
-
-        dateRange = DateRange(self.index[0], self.index[-1], offset=freq)
+        if isinstance(freq, datetools.DateOffset):
+            dateRange = DateRange(self.index[0], self.index[-1], offset=freq)
+        else:
+            dateRange = DateRange(self.index[0], self.index[-1], timeRule=freq)
 
-        return self.reindex(dateRange, fillMethod=fillMethod)
+        return self.reindex(dateRange, fillMethod = fillMethod)
 
     def asMatrix(self, columns=None):
         """
@@ -1030,7 +1030,7 @@ class DataFrame(Picklable, Groupable):
         temp = temp[periods:] - temp[:-periods]
         return self.fromMatrix(temp, self.cols(), self.index[periods:])
 
-    def shift(self, periods, offset=None):
+    def shift(self, periods, offset=None, timeRule=None):
         """
         Shift the underlying series of the DataFrame and Series objects within
         by given number (positive or negative) of business/weekdays.
@@ -1040,6 +1040,9 @@ class DataFrame(Picklable, Groupable):
         if periods == 0:
             return self
 
+        if timeRule is not None and offset is None:
+            offset = datetools.getOffset(timeRule)
+
         if offset is None:
             if periods > 0:
                 newIndex = self.index[periods:]
diff --git a/pandas/core/series.py b/pandas/core/series.py
index d640b5420..73c86ea5d 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -840,7 +840,7 @@ class Series(np.ndarray, Picklable, Groupable):
 #-------------------------------------------------------------------------------
 # TimeSeries methods
 
-    def shift(self, periods, offset=None):
+    def shift(self, periods, offset=None, timeRule=None):
         """
         Shift the underlying series of the DataMatrix and Series objects within
         by given number (positive or negative) of business/weekdays.
@@ -851,6 +851,8 @@ class Series(np.ndarray, Picklable, Groupable):
             Number of periods to move
         offset: DateOffset, optional
             Increment to use from datetools module
+        timeRule: string
+            time rule name to use by name (e.g. 'WEEKDAY')
 
         Returns
         -------
@@ -859,6 +861,9 @@ class Series(np.ndarray, Picklable, Groupable):
         if periods == 0:
             return self
 
+        if timeRule is not None and offset is None:
+            offset = datetools.getOffset(timeRule)
+
         if offset is None:
             if periods > 0:
                 newIndex = self.index[periods:]
@@ -966,10 +971,10 @@ class Series(np.ndarray, Picklable, Groupable):
         -------
         TimeSeries
         """
-        if not isinstance(freq, datetools.DateOffset):
-            raise Exception('Must pass DateOffset!')
-
-        dateRange = DateRange(self.index[0], self.index[-1], offset=freq)
+        if isinstance(freq, datetools.DateOffset):
+            dateRange = DateRange(self.index[0], self.index[-1], offset=freq)
+        else:
+            dateRange = DateRange(self.index[0], self.index[-1], timeRule=freq)
 
         return self.reindex(dateRange, fillMethod=fillMethod)
 

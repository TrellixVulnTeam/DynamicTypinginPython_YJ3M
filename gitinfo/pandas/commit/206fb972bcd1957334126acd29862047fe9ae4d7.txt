commit 206fb972bcd1957334126acd29862047fe9ae4d7
Author: Jan Schulz <jasc@gmx.net>
Date:   Mon Sep 1 15:20:42 2014 +0200

    FIX: Implement small Categorical fixups
    
    This is a squashed commit which adresses several small issues
    identified in the latest code review.
    
    * As per dicussion in https://github.com/pydata/pandas/issues/8074,
      Categorical.unique() should return an array and not a Index object
      to make is consistant with other unique() implementations.
    
    * Mark a few more categorical methods as internal
    
    * Change reorder_levels and drop_unused_levels to inplace=False. As per
      the discussion in #8074, change the default of both methods
      to return a copy and only do the change inplace if told otherwise.
    
      Discusion in
      https://github.com/pydata/pandas/issues/8074#issuecomment-54093664
    
    * Make str(cat) more array like. As Categorical is more like
      np.ndarray and less similar to pd.Series, change the string
      representation of Categorical to be more like np.ndarray.
    
      The new str(cat) will only show at max 10 values.
    
      Also remove the "Categorical(" in front of an empty categorical
      -> either that's put in front of every str(cta) or none. It also missed
      the final ")".
    
    * Test more nan handling in Categorical
    
    * Add a testcase for groupby with two columns and unused categories
    
      During the devleopment of pandas new Categorical support, groupby
      with two columns (one worked) didn't include empty categories which
      omits rows with NaN. Add a testcase so this is checked.
    
      No codechanges nessesary, this bug was fixed at some other places
      before. See #8138 for more details.

diff --git a/doc/source/categorical.rst b/doc/source/categorical.rst
index 6ed1a7982..39ec42482 100644
--- a/doc/source/categorical.rst
+++ b/doc/source/categorical.rst
@@ -298,12 +298,13 @@ This is even true for strings and numeric data:
 
 Reordering the levels is possible via the ``Categorical.reorder_levels(new_levels)``  or
 ``Series.cat.reorder_levels(new_levels)`` methods. All old levels must be included in the new
-levels.
+levels. Note that per default, this operation returns a new Series and you need to specify
+``inplace=True`` to do the change inplace!
 
 .. ipython:: python
 
-    s2 = pd.Series(pd.Categorical([1,2,3,1]))
-    s2.cat.reorder_levels([2,3,1])
+    s = pd.Series(pd.Categorical([1,2,3,1]))
+    s2 = s.cat.reorder_levels([2,3,1])
     s2
     s2.sort()
     s2
@@ -322,8 +323,8 @@ old levels:
 
 .. ipython:: python
 
-    s3 = pd.Series(pd.Categorical(["a","b","d"]))
-    s3.cat.reorder_levels(["a","b","c","d"])
+    s = pd.Series(pd.Categorical(["a","b","d"]))
+    s3 = s.cat.reorder_levels(["a","b","c","d"])
     s3
 
 
@@ -582,7 +583,7 @@ relevant columns back to `category` and assign the right levels and level orderi
     # rename the levels
     s.cat.levels = ["very good", "good", "bad"]
     # reorder the levels and add missing levels
-    s.cat.reorder_levels(["very bad", "bad", "medium", "good", "very good"])
+    s = s.cat.reorder_levels(["very bad", "bad", "medium", "good", "very good"])
     df = pd.DataFrame({"cats":s, "vals":[1,2,3,4,5,6]})
     csv = StringIO()
     df.to_csv(csv)
@@ -591,7 +592,7 @@ relevant columns back to `category` and assign the right levels and level orderi
     df2["cats"]
     # Redo the category
     df2["cats"] = df2["cats"].astype("category")
-    df2["cats"].cat.reorder_levels(["very bad", "bad", "medium", "good", "very good"])
+    df2["cats"].cat.reorder_levels(["very bad", "bad", "medium", "good", "very good"], inplace=True)
     df2.dtypes
     df2["cats"]
 
@@ -731,7 +732,7 @@ Series of type ``category`` this means that there is some danger to confuse both
     except Exception as e:
         print("Exception: " + str(e))
     # right
-    s.cat.reorder_levels([4,3,2,1])
+    s = s.cat.reorder_levels([4,3,2,1])
     print(s.cat.levels)
 
 See also the API documentation for :func:`pandas.Series.reorder_levels` and
@@ -742,8 +743,7 @@ Old style constructor usage
 
 I earlier versions, a `Categorical` could be constructed by passing in precomputed `codes`
 (called then `labels`) instead of values with levels. The `codes` are interpreted as pointers
-to the levels with `-1` as `NaN`. This usage is now deprecated and not available unless
-``compat=True`` is passed to the constructor of `Categorical`.
+to the levels with `-1` as `NaN`.
 
 .. ipython:: python
     :okwarning:
diff --git a/pandas/core/categorical.py b/pandas/core/categorical.py
index 1e9f7d69c..fc12c7db5 100644
--- a/pandas/core/categorical.py
+++ b/pandas/core/categorical.py
@@ -299,6 +299,8 @@ class Categorical(PandasObject):
         """
         Make a Categorical type from a single array-like object.
 
+        For internal compatibility with numpy arrays.
+
         Parameters
         ----------
         data : array-like
@@ -412,7 +414,7 @@ class Categorical(PandasObject):
 
     levels = property(fget=_get_levels, fset=_set_levels, doc=_levels_doc)
 
-    def reorder_levels(self, new_levels, ordered=None):
+    def reorder_levels(self, new_levels, ordered=None, inplace=False):
         """ Reorders levels as specified in new_levels.
 
         `new_levels` must include all old levels but can also include new level items. In
@@ -432,27 +434,50 @@ class Categorical(PandasObject):
         ordered : boolean, optional
            Whether or not the categorical is treated as a ordered categorical. If not given,
            do not change the ordered information.
+        inplace : bool (default: False)
+           Whether or not to reorder the levels inplace or return a copy of this categorical with
+           reordered levels.
+
+        Returns
+        -------
+        cat : Categorical with reordered levels.
         """
         new_levels = self._validate_levels(new_levels)
 
         if len(new_levels) < len(self._levels) or len(self._levels.difference(new_levels)):
             raise ValueError('Reordered levels must include all original levels')
-        values = self.__array__()
-        self._codes = _get_codes_for_values(values, new_levels)
-        self._levels = new_levels
+
+        cat = self if inplace else self.copy()
+        values = cat.__array__()
+        cat._codes = _get_codes_for_values(values, new_levels)
+        cat._levels = new_levels
         if not ordered is None:
-            self.ordered = ordered
+            cat.ordered = ordered
+        if not inplace:
+            return cat
 
-    def remove_unused_levels(self):
+    def remove_unused_levels(self, inplace=False):
         """ Removes levels which are not used.
 
-        The level removal is done inplace.
+        Parameters
+        ----------
+        inplace : bool (default: False)
+           Whether or not to drop unused levels inplace or return a copy of this categorical with
+           unused levels dropped.
+
+        Returns
+        -------
+        cat : Categorical with unused levels dropped.
+
         """
-        _used = sorted(np.unique(self._codes))
-        new_levels = self.levels.take(com._ensure_platform_int(_used))
+        cat = self if inplace else self.copy()
+        _used = sorted(np.unique(cat._codes))
+        new_levels = cat.levels.take(com._ensure_platform_int(_used))
         new_levels = _ensure_index(new_levels)
-        self._codes = _get_codes_for_values(self.__array__(), new_levels)
-        self._levels = new_levels
+        cat._codes = _get_codes_for_values(cat.__array__(), new_levels)
+        cat._levels = new_levels
+        if not inplace:
+            return cat
 
 
     __eq__ = _cat_compare_op('__eq__')
@@ -683,7 +708,14 @@ class Categorical(PandasObject):
         return self
 
     def to_dense(self):
-        """ Return my 'dense' repr """
+        """Return my 'dense' representation
+
+        For internal compatibility with numpy arrays.
+
+        Returns
+        -------
+        dense : array
+        """
         return np.asarray(self)
 
     def fillna(self, fill_value=None, method=None, limit=None, **kwargs):
@@ -743,7 +775,10 @@ class Categorical(PandasObject):
                            name=self.name, fastpath=True)
 
     def take_nd(self, indexer, allow_fill=True, fill_value=None):
-        """ Take the codes by the indexer, fill with the fill_value. """
+        """ Take the codes by the indexer, fill with the fill_value.
+
+        For internal compatibility with numpy arrays.
+        """
 
         # filling must always be None/nan here
         # but is passed thru internally
@@ -757,7 +792,10 @@ class Categorical(PandasObject):
     take = take_nd
 
     def _slice(self, slicer):
-        """ Return a slice of myself. """
+        """ Return a slice of myself.
+
+        For internal compatibility with numpy arrays.
+        """
 
         # only allow 1 dimensional slicing, but can
         # in a 2-d case be passd (slice(None),....)
@@ -771,19 +809,21 @@ class Categorical(PandasObject):
                            name=self.name, fastpath=True)
 
     def __len__(self):
+        """The length of this Categorical."""
         return len(self._codes)
 
     def __iter__(self):
+        """Returns an Iterator over the values of this Categorical."""
         return iter(np.array(self))
 
-    def _tidy_repr(self, max_vals=20):
+    def _tidy_repr(self, max_vals=10):
         num = max_vals // 2
         head = self[:num]._get_repr(length=False, name=False, footer=False)
         tail = self[-(max_vals - num):]._get_repr(length=False,
                                                   name=False,
                                                   footer=False)
 
-        result = '%s\n...\n%s' % (head, tail)
+        result = '%s, ..., %s' % (head[:-1], tail[1:])
         result = '%s\n%s' % (result, self._repr_footer())
 
         return compat.text_type(result)
@@ -840,17 +880,14 @@ class Categorical(PandasObject):
 
     def __unicode__(self):
         """ Unicode representation. """
-        width, height = get_terminal_size()
-        max_rows = (height if get_option("display.max_rows") == 0
-                    else get_option("display.max_rows"))
-
-        if len(self._codes) > (max_rows or 1000):
-            result = self._tidy_repr(min(30, max_rows) - 4)
+        _maxlen = 10
+        if len(self._codes) > _maxlen:
+            result = self._tidy_repr(_maxlen)
         elif len(self._codes) > 0:
-            result = self._get_repr(length=len(self) > 50,
+            result = self._get_repr(length=len(self) > _maxlen,
                                     name=True)
         else:
-            result = 'Categorical([], %s' % self._get_repr(name=True,
+            result = '[], %s' % self._get_repr(name=True,
                                                            length=False,
                                                            footer=True,
                                                            ).replace("\n",", ")
@@ -1025,7 +1062,7 @@ class Categorical(PandasObject):
         -------
         unique values : array
         """
-        return self.levels
+        return np.asarray(self.levels)
 
     def equals(self, other):
         """
@@ -1113,8 +1150,11 @@ class CategoricalProperties(PandasDelegate):
         return setattr(self.categorical, name, new_values)
 
     def _delegate_method(self, name, *args, **kwargs):
+        from pandas import Series
         method = getattr(self.categorical, name)
-        return method(*args, **kwargs)
+        res = method(*args, **kwargs)
+        if not res is None:
+            return Series(res, index=self.index)
 
 CategoricalProperties._add_delegate_accessors(delegate=Categorical,
                                               accessors=["levels", "ordered"],
diff --git a/pandas/core/format.py b/pandas/core/format.py
index fe5cbb733..951559e6e 100644
--- a/pandas/core/format.py
+++ b/pandas/core/format.py
@@ -116,6 +116,9 @@ class CategoricalFormatter(object):
         fmt_values = self._get_formatted_values()
 
         result = ['%s' % i for i in fmt_values]
+        result = [i.strip() for i in result]
+        result = u(', ').join(result)
+        result = [u('[')+result+u(']')]
         if self.footer:
             footer = self._get_footer()
             if footer:
diff --git a/pandas/tests/test_categorical.py b/pandas/tests/test_categorical.py
index 9aafffa8c..0c3117e8e 100644
--- a/pandas/tests/test_categorical.py
+++ b/pandas/tests/test_categorical.py
@@ -407,7 +407,7 @@ class TestCategorical(tm.TestCase):
 
 
     def test_print(self):
-        expected = [" a", " b", " b", " a", " a", " c", " c", " c",
+        expected = ["[a, b, b, a, a, c, c, c]",
                     "Levels (3, object): [a < b < c]"]
         expected = "\n".join(expected)
         actual = repr(self.factor)
@@ -415,33 +415,31 @@ class TestCategorical(tm.TestCase):
 
     def test_big_print(self):
         factor = Categorical([0,1,2,0,1,2]*100, ['a', 'b', 'c'], name='cat', fastpath=True)
-        expected = [" a", " b", " c", " a", " b", " c", " a", " b", " c",
-                    " a", " b", " c", " a", "...", " c", " a", " b", " c",
-                    " a", " b", " c", " a", " b", " c", " a", " b", " c",
+        expected = ["[a, b, c, a, b, ..., b, c, a, b, c]",
                     "Name: cat, Length: 600",
                     "Levels (3, object): [a, b, c]"]
         expected = "\n".join(expected)
 
         actual = repr(factor)
 
-        self.assertEqual(expected, actual)
+        self.assertEqual(actual, expected)
 
     def test_empty_print(self):
         factor = Categorical([], ["a","b","c"], name="cat")
-        expected = ("Categorical([], Name: cat, Levels (3, object): [a < b < c]")
+        expected = ("[], Name: cat, Levels (3, object): [a < b < c]")
         # hack because array_repr changed in numpy > 1.6.x
         actual = repr(factor)
 
         self.assertEqual(actual, expected)
 
         factor = Categorical([], ["a","b","c"])
-        expected = ("Categorical([], Levels (3, object): [a < b < c]")
+        expected = ("[], Levels (3, object): [a < b < c]")
         actual = repr(factor)
 
         self.assertEqual(expected, actual)
 
         factor = Categorical([], [])
-        expected = ("Categorical([], Levels (0, object): []")
+        expected = ("[], Levels (0, object): []")
         self.assertEqual(expected, repr(factor))
 
     def test_periodindex(self):
@@ -495,9 +493,21 @@ class TestCategorical(tm.TestCase):
         cat = Categorical(["a","b","c","a"], ordered=True)
         exp_levels = np.array(["c","b","a"])
         exp_values = np.array(["a","b","c","a"])
-        cat.reorder_levels(["c","b","a"])
+
+        res = cat.reorder_levels(["c","b","a"], inplace=True)
         self.assert_numpy_array_equal(cat.levels, exp_levels)
         self.assert_numpy_array_equal(cat.__array__(), exp_values)
+        self.assertIsNone(res)
+
+        res = cat.reorder_levels(["a","b","c"])
+        # cat must be the same as before
+        self.assert_numpy_array_equal(cat.levels, exp_levels)
+        self.assert_numpy_array_equal(cat.__array__(), exp_values)
+        # only res is changed
+        exp_levels_back = np.array(["a","b","c"])
+        self.assert_numpy_array_equal(res.levels, exp_levels_back)
+        self.assert_numpy_array_equal(res.__array__(), exp_values)
+
 
         # not all "old" included in "new"
         def f():
@@ -510,7 +520,7 @@ class TestCategorical(tm.TestCase):
         self.assertRaises(ValueError, f)
 
         # This works: all "old" included in "new"
-        cat.reorder_levels(["a","b","c","d"])
+        cat = cat.reorder_levels(["a","b","c","d"])
         exp_levels = np.array(["a","b","c","d"])
         self.assert_numpy_array_equal(cat.levels, exp_levels)
 
@@ -519,7 +529,7 @@ class TestCategorical(tm.TestCase):
         self.assert_numpy_array_equal(c._codes, np.array([0,1,2,3,0]))
         self.assert_numpy_array_equal(c.levels , np.array([1,2,3,4] ))
         self.assert_numpy_array_equal(c.get_values() , np.array([1,2,3,4,1] ))
-        c.reorder_levels([4,3,2,1]) # all "pointers" to '4' must be changed from 3 to 0,...
+        c = c.reorder_levels([4,3,2,1]) # all "pointers" to '4' must be changed from 3 to 0,...
         self.assert_numpy_array_equal(c._codes , np.array([3,2,1,0,3])) # positions are changed
         self.assert_numpy_array_equal(c.levels , np.array([4,3,2,1])) # levels are now in new order
         self.assert_numpy_array_equal(c.get_values() , np.array([1,2,3,4,1])) # output is the same
@@ -527,14 +537,26 @@ class TestCategorical(tm.TestCase):
         self.assertTrue(c.max(), 1)
 
         def f():
-            c.reorder_levels([4,3,2,10])
+            c.reorder_levels([4,3,2,10]) # 1 vs 10 -> not all new in old
         self.assertRaises(ValueError, f)
 
+
+
     def test_remove_unused_levels(self):
         c = Categorical(["a","b","c","d","a"], levels=["a","b","c","d","e"])
-        self.assert_numpy_array_equal(c.levels , np.array(["a","b","c","d","e"]))
-        c.remove_unused_levels()
-        self.assert_numpy_array_equal(c.levels , np.array(["a","b","c","d"]))
+        exp_levels_all = np.array(["a","b","c","d","e"])
+        exp_levels_dropped = np.array(["a","b","c","d"])
+
+        self.assert_numpy_array_equal(c.levels, exp_levels_all)
+
+        res = c.remove_unused_levels()
+        self.assert_numpy_array_equal(res.levels, exp_levels_dropped)
+        self.assert_numpy_array_equal(c.levels, exp_levels_all)
+
+        res = c.remove_unused_levels(inplace=True)
+        self.assert_numpy_array_equal(c.levels, exp_levels_dropped)
+        self.assertIsNone(res)
+
 
     def test_nan_handling(self):
 
@@ -542,11 +564,17 @@ class TestCategorical(tm.TestCase):
         c = Categorical(["a","b",np.nan,"a"])
         self.assert_numpy_array_equal(c.levels , np.array(["a","b"]))
         self.assert_numpy_array_equal(c._codes , np.array([0,1,-1,0]))
+        c[1] = np.nan
+        self.assert_numpy_array_equal(c.levels , np.array(["a","b"]))
+        self.assert_numpy_array_equal(c._codes , np.array([0,-1,-1,0]))
 
         # If levels have nan included, the code should point to that instead
         c = Categorical(["a","b",np.nan,"a"], levels=["a","b",np.nan])
         self.assert_numpy_array_equal(c.levels , np.array(["a","b",np.nan],dtype=np.object_))
         self.assert_numpy_array_equal(c._codes , np.array([0,1,2,0]))
+        c[1] = np.nan
+        self.assert_numpy_array_equal(c.levels , np.array(["a","b",np.nan],dtype=np.object_))
+        self.assert_numpy_array_equal(c._codes , np.array([0,2,2,0]))
 
         # Changing levels should also make the replaced level np.nan
         c = Categorical(["a","b","c","a"])
@@ -554,6 +582,18 @@ class TestCategorical(tm.TestCase):
         self.assert_numpy_array_equal(c.levels , np.array(["a","b",np.nan],dtype=np.object_))
         self.assert_numpy_array_equal(c._codes , np.array([0,1,2,0]))
 
+        # Adding nan to levels should make assigned nan point to the level!
+        c = Categorical(["a","b",np.nan,"a"])
+        self.assert_numpy_array_equal(c.levels , np.array(["a","b"]))
+        self.assert_numpy_array_equal(c._codes , np.array([0,1,-1,0]))
+        c.levels = ["a","b",np.nan]
+        self.assert_numpy_array_equal(c.levels , np.array(["a","b",np.nan],dtype=np.object_))
+        self.assert_numpy_array_equal(c._codes , np.array([0,1,-1,0]))
+        c[1] = np.nan
+        self.assert_numpy_array_equal(c.levels , np.array(["a","b",np.nan],dtype=np.object_))
+        self.assert_numpy_array_equal(c._codes , np.array([0,2,-1,0]))
+
+
     def test_isnull(self):
         exp = np.array([False, False, True])
         c = Categorical(["a","b",np.nan])
@@ -564,6 +604,7 @@ class TestCategorical(tm.TestCase):
         res = c.isnull()
         self.assert_numpy_array_equal(res, exp)
 
+        # test both nan in levels and as -1
         exp = np.array([True, False, True])
         c = Categorical(["a","b",np.nan])
         c.levels = ["a","b",np.nan]
@@ -637,6 +678,12 @@ class TestCategorical(tm.TestCase):
         _max = cat.max(numeric_only=True)
         self.assertEqual(_max, 1)
 
+    def test_unique(self):
+        cat = Categorical(["a","b","c","d"])
+        exp = np.asarray(["a","b","c","d"])
+        res = cat.unique()
+        self.assert_numpy_array_equal(res, exp)
+        self.assertEqual(type(res), type(exp))
 
     def test_mode(self):
         s = Categorical([1,1,2,4,5,5,5], levels=[5,4,3,2,1], ordered=True)
@@ -970,11 +1017,13 @@ class TestCategoricalAsBlock(tm.TestCase):
         self.assert_numpy_array_equal(s.cat.levels, np.array(["a","b"]))
         self.assertEqual(s.cat.ordered, True)
         exp = Categorical(["a","b",np.nan,"a"], levels=["b","a"])
-        s.cat.reorder_levels(["b", "a"])
+        s.cat.reorder_levels(["b", "a"], inplace=True)
         self.assertTrue(s.values.equals(exp))
+        res = s.cat.reorder_levels(["b", "a"])
+        self.assertTrue(res.values.equals(exp))
         exp = Categorical(["a","b",np.nan,"a"], levels=["b","a"])
         s[:] = "a"
-        s.cat.remove_unused_levels()
+        s = s.cat.remove_unused_levels()
         self.assert_numpy_array_equal(s.cat.levels, np.array(["a"]))
 
     def test_sequence_like(self):
@@ -1026,7 +1075,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         s = Series(Categorical(["a","b","c","a"], ordered=True))
         exp_levels = np.array(["c","b","a"])
         exp_values = np.array(["a","b","c","a"])
-        s.cat.reorder_levels(["c","b","a"])
+        s = s.cat.reorder_levels(["c","b","a"])
         self.assert_numpy_array_equal(s.cat.levels, exp_levels)
         self.assert_numpy_array_equal(s.values.__array__(), exp_values)
         self.assert_numpy_array_equal(s.__array__(), exp_values)
@@ -1035,7 +1084,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         s = Series(Categorical(["a","b","b","a"], levels=["a","b","c"]))
         exp_levels = np.array(["a","b"])
         exp_values = np.array(["a","b","b","a"])
-        s.cat.remove_unused_levels()
+        s = s.cat.remove_unused_levels()
         self.assert_numpy_array_equal(s.cat.levels, exp_levels)
         self.assert_numpy_array_equal(s.values.__array__(), exp_values)
         self.assert_numpy_array_equal(s.__array__(), exp_values)
@@ -1298,7 +1347,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         # GH 7848
         df = DataFrame({"id":[6,5,4,3,2,1], "raw_grade":['a', 'b', 'b', 'a', 'a', 'e']})
         df["grade"] = pd.Categorical(df["raw_grade"])
-        df['grade'].cat.reorder_levels(['b', 'e', 'a'])
+        df['grade'] = df['grade'].cat.reorder_levels(['b', 'e', 'a'])
 
         # sorts 'grade' according to the order of the levels
         result = df.sort(columns=['grade'])
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index 440331f92..f1b54ecd9 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -4727,7 +4727,41 @@ class TestGroupBy(tm.TestCase):
         expected = gb2.transform('mean')
         tm.assert_frame_equal(result, expected)
 
-
+    def test_groupby_categorical_two_columns(self):
+
+        # https://github.com/pydata/pandas/issues/8138
+        d = {'cat': pd.Categorical(["a","b","a","b"], categories=["a", "b", "c"]),
+             'ints': [1, 1, 2, 2],'val': [10, 20, 30, 40]}
+        test = pd.DataFrame(d)
+
+        # Grouping on a single column
+        groups_single_key = test.groupby("cat")
+        res = groups_single_key.agg('mean')
+        exp = DataFrame({"ints":[1.5,1.5,np.nan], "val":[20,30,np.nan]},
+                        index=pd.Index(["a", "b", "c"], name="cat"))
+        tm.assert_frame_equal(res, exp)
+
+        # Grouping on two columns
+        groups_double_key = test.groupby(["cat","ints"])
+        res = groups_double_key.agg('mean')
+        exp = DataFrame({"val":[10,30,20,40,np.nan,np.nan],
+                         "cat": ["a","a","b","b","c","c"],
+                         "ints": [1,2,1,2,1,2]}).set_index(["cat","ints"])
+        tm.assert_frame_equal(res, exp)
+
+        d = {'C1': [3, 3, 4, 5], 'C2': [1, 2, 3, 4], 'C3': [10, 100, 200, 34]}
+        test = pd.DataFrame(d)
+        values = pd.cut(test['C1'], [1, 2, 3, 6])
+        values.name = "cat"
+        groups_double_key = test.groupby([values,'C2'])
+
+        res = groups_double_key.agg('mean')
+        nan = np.nan
+        idx = MultiIndex.from_product([["(1, 2]", "(2, 3]", "(3, 6]"],[1,2,3,4]],
+                                      names=["cat", "C2"])
+        exp = DataFrame({"C1":[nan,nan,nan,nan,  3,  3,nan,nan, nan,nan,  4, 5],
+                         "C3":[nan,nan,nan,nan, 10,100,nan,nan, nan,nan,200,34]}, index=idx)
+        tm.assert_frame_equal(res, exp)
 
 
 def assert_fp_equal(a, b):

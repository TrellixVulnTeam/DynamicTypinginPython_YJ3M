commit 029f7073b1fa309923b493bbcff602d28057eb11
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sat Mar 14 09:33:19 2020 -0700

    Disallow lossy SparseArray conversion (#32501)

diff --git a/pandas/core/arrays/sparse/array.py b/pandas/core/arrays/sparse/array.py
index 3b5e6b2d2..930915552 100644
--- a/pandas/core/arrays/sparse/array.py
+++ b/pandas/core/arrays/sparse/array.py
@@ -27,6 +27,7 @@ from pandas.core.dtypes.common import (
     is_array_like,
     is_bool_dtype,
     is_datetime64_any_dtype,
+    is_datetime64tz_dtype,
     is_dtype_equal,
     is_integer,
     is_object_dtype,
@@ -42,7 +43,7 @@ from pandas.core.arrays import ExtensionArray, ExtensionOpsMixin
 from pandas.core.arrays.sparse.dtype import SparseDtype
 from pandas.core.base import PandasObject
 import pandas.core.common as com
-from pandas.core.construction import sanitize_array
+from pandas.core.construction import extract_array, sanitize_array
 from pandas.core.indexers import check_array_indexer
 from pandas.core.missing import interpolate_2d
 import pandas.core.ops as ops
@@ -312,7 +313,7 @@ class SparseArray(PandasObject, ExtensionArray, ExtensionOpsMixin):
             dtype = dtype.subtype
 
         if index is not None and not is_scalar(data):
-            raise Exception("must only pass scalars with an index ")
+            raise Exception("must only pass scalars with an index")
 
         if is_scalar(data):
             if index is not None:
@@ -367,6 +368,19 @@ class SparseArray(PandasObject, ExtensionArray, ExtensionOpsMixin):
             sparse_index = data._sparse_index
             sparse_values = np.asarray(data.sp_values, dtype=dtype)
         elif sparse_index is None:
+            data = extract_array(data, extract_numpy=True)
+            if not isinstance(data, np.ndarray):
+                # EA
+                if is_datetime64tz_dtype(data.dtype):
+                    warnings.warn(
+                        f"Creating SparseArray from {data.dtype} data "
+                        "loses timezone information.  Cast to object before "
+                        "sparse to retain timezone information.",
+                        UserWarning,
+                        stacklevel=2,
+                    )
+                    data = np.asarray(data, dtype="datetime64[ns]")
+                data = np.asarray(data)
             sparse_values, sparse_index, fill_value = make_sparse(
                 data, kind=kind, fill_value=fill_value, dtype=dtype
             )
@@ -1497,7 +1511,7 @@ SparseArray._add_comparison_ops()
 SparseArray._add_unary_ops()
 
 
-def make_sparse(arr, kind="block", fill_value=None, dtype=None, copy=False):
+def make_sparse(arr: np.ndarray, kind="block", fill_value=None, dtype=None, copy=False):
     """
     Convert ndarray to sparse format
 
@@ -1513,7 +1527,7 @@ def make_sparse(arr, kind="block", fill_value=None, dtype=None, copy=False):
     -------
     (sparse_values, index, fill_value) : (ndarray, SparseIndex, Scalar)
     """
-    arr = com.values_from_object(arr)
+    assert isinstance(arr, np.ndarray)
 
     if arr.ndim > 1:
         raise TypeError("expected dimension <= 1 data")
diff --git a/pandas/tests/arrays/sparse/test_array.py b/pandas/tests/arrays/sparse/test_array.py
index baca18239..4dab86166 100644
--- a/pandas/tests/arrays/sparse/test_array.py
+++ b/pandas/tests/arrays/sparse/test_array.py
@@ -96,6 +96,22 @@ class TestSparseArray:
         with pytest.raises(ValueError, match="Cannot convert"):
             SparseArray([0, 1, np.nan], dtype=dtype)
 
+    def test_constructor_warns_when_losing_timezone(self):
+        # GH#32501 warn when losing timezone inforamtion
+        dti = pd.date_range("2016-01-01", periods=3, tz="US/Pacific")
+
+        expected = SparseArray(np.asarray(dti, dtype="datetime64[ns]"))
+
+        with tm.assert_produces_warning(UserWarning):
+            result = SparseArray(dti)
+
+        tm.assert_sp_array_equal(result, expected)
+
+        with tm.assert_produces_warning(UserWarning):
+            result = SparseArray(pd.Series(dti))
+
+        tm.assert_sp_array_equal(result, expected)
+
     def test_constructor_spindex_dtype(self):
         arr = SparseArray(data=[1, 2], sparse_index=IntIndex(4, [1, 2]))
         # XXX: Behavior change: specifying SparseIndex no longer changes the

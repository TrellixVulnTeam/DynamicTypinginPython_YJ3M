commit 54f20cfb88e646357f6287d3cd5746e560c71ef6
Author: Tom Augspurger <tom.w.augspurger@gmail.com>
Date:   Fri Sep 18 12:46:32 2015 -0500

    COMPAT: Support for matplotlib 1.5

diff --git a/ci/install_conda.sh b/ci/install_conda.sh
index c54f5494c..8d99034a8 100755
--- a/ci/install_conda.sh
+++ b/ci/install_conda.sh
@@ -72,6 +72,7 @@ bash miniconda.sh -b -p $HOME/miniconda || exit 1
 
 conda config --set always_yes yes --set changeps1 no || exit 1
 conda update -q conda || exit 1
+conda config --add channels conda-forge || exit 1
 conda config --add channels http://conda.binstar.org/pandas || exit 1
 conda config --set ssl_verify false || exit 1
 
diff --git a/doc/source/whatsnew/v0.17.0.txt b/doc/source/whatsnew/v0.17.0.txt
index 1a976bf0d..4ec5281b5 100644
--- a/doc/source/whatsnew/v0.17.0.txt
+++ b/doc/source/whatsnew/v0.17.0.txt
@@ -50,6 +50,7 @@ Highlights include:
 - Documentation comparing SAS to *pandas*, see :ref:`here <compare_with_sas>`
 - Removal of the automatic TimeSeries broadcasting, deprecated since 0.8.0, see :ref:`here <whatsnew_0170.prior_deprecations>`
 - Compatibility with Python 3.5 (:issue:`11097`)
+- Compatibility with matplotlib 1.5.0 (:issue:`11111`)
 
 Check the :ref:`API Changes <whatsnew_0170.api>` and :ref:`deprecations <whatsnew_0170.deprecations>` before updating.
 
diff --git a/pandas/tests/test_graphics.py b/pandas/tests/test_graphics.py
index ad9518116..39da7dc72 100644
--- a/pandas/tests/test_graphics.py
+++ b/pandas/tests/test_graphics.py
@@ -74,13 +74,22 @@ class TestPlotBase(tm.TestCase):
                                       'weight': random.normal(161, 32, size=n),
                                       'category': random.randint(4, size=n)})
 
-        if str(mpl.__version__) >= LooseVersion('1.4'):
+        self.mpl_le_1_2_1 = plotting._mpl_le_1_2_1()
+        self.mpl_ge_1_3_1 = plotting._mpl_ge_1_3_1()
+        self.mpl_ge_1_4_0 = plotting._mpl_ge_1_4_0()
+        self.mpl_ge_1_5_0 = plotting._mpl_ge_1_5_0()
+
+        if self.mpl_ge_1_4_0:
             self.bp_n_objects = 7
         else:
             self.bp_n_objects = 8
+        if self.mpl_ge_1_5_0:
+            # 1.5 added PolyCollections to legend handler
+            # so we have twice as many items.
+            self.polycollection_factor = 2
+        else:
+            self.polycollection_factor = 1
 
-        self.mpl_le_1_2_1 = str(mpl.__version__) <= LooseVersion('1.2.1')
-        self.mpl_ge_1_3_1 = str(mpl.__version__) >= LooseVersion('1.3.1')
 
     def tearDown(self):
         tm.close()
@@ -183,7 +192,7 @@ class TestPlotBase(tm.TestCase):
         """
 
         from matplotlib.lines import Line2D
-        from matplotlib.collections import Collection
+        from matplotlib.collections import Collection, PolyCollection
         conv = self.colorconverter
         if linecolors is not None:
 
@@ -197,6 +206,8 @@ class TestPlotBase(tm.TestCase):
                     result = patch.get_color()
                     # Line2D may contains string color expression
                     result = conv.to_rgba(result)
+                elif isinstance(patch, PolyCollection):
+                    result = tuple(patch.get_edgecolor()[0])
                 else:
                     result = patch.get_edgecolor()
 
@@ -472,6 +483,21 @@ class TestPlotBase(tm.TestCase):
                 obj.plot(kind=kind, grid=True, **kws)
                 self.assertTrue(is_grid_on())
 
+    def _maybe_unpack_cycler(self, rcParams, field='color'):
+        """
+        Compat layer for MPL 1.5 change to color cycle
+
+        Before: plt.rcParams['axes.color_cycle'] -> ['b', 'g', 'r'...]
+        After : plt.rcParams['axes.prop_cycle'] -> cycler(...)
+        """
+        if self.mpl_ge_1_5_0:
+            cyl = rcParams['axes.prop_cycle']
+            colors = [v[field] for v in cyl]
+        else:
+            colors = rcParams['axes.color_cycle']
+        return colors
+
+
 @tm.mplskip
 class TestSeriesPlots(TestPlotBase):
 
@@ -536,9 +562,13 @@ class TestSeriesPlots(TestPlotBase):
 
     def test_dont_modify_rcParams(self):
         # GH 8242
-        colors = self.plt.rcParams['axes.color_cycle']
+        if self.mpl_ge_1_5_0:
+            key = 'axes.prop_cycle'
+        else:
+            key = 'axes.color_cycle'
+        colors = self.plt.rcParams[key]
         Series([1, 2, 3]).plot()
-        self.assertEqual(colors, self.plt.rcParams['axes.color_cycle'])
+        self.assertEqual(colors, self.plt.rcParams[key])
 
     def test_ts_line_lim(self):
         ax = self.ts.plot()
@@ -1109,7 +1139,8 @@ class TestSeriesPlots(TestPlotBase):
             s.plot(yerr=np.arange(11))
 
         s_err = ['zzz']*10
-        with tm.assertRaises(TypeError):
+        # in mpl 1.5+ this is a TypeError
+        with tm.assertRaises((ValueError, TypeError)):
             s.plot(yerr=s_err)
 
     def test_table(self):
@@ -1183,7 +1214,10 @@ class TestSeriesPlots(TestPlotBase):
     def test_time_series_plot_color_with_empty_kwargs(self):
         import matplotlib as mpl
 
-        def_colors = mpl.rcParams['axes.color_cycle']
+        if self.mpl_ge_1_5_0:
+            def_colors = self._maybe_unpack_cycler(mpl.rcParams)
+        else:
+            def_colors = mpl.rcParams['axes.color_cycle']
         index = date_range('1/1/2000', periods=12)
         s = Series(np.arange(1, 13), index=index)
 
@@ -1292,7 +1326,11 @@ class TestDataFramePlots(TestPlotBase):
         fig, ax = self.plt.subplots()
         axes = df.plot.bar(subplots=True, ax=ax)
         self.assertEqual(len(axes), 1)
-        self.assertIs(ax.get_axes(), axes[0])
+        if self.mpl_ge_1_5_0:
+            result = ax.axes
+        else:
+            result = ax.get_axes()  # deprecated
+        self.assertIs(result, axes[0])
 
     def test_color_and_style_arguments(self):
         df = DataFrame({'x': [1, 2], 'y': [3, 4]})
@@ -1802,8 +1840,7 @@ class TestDataFramePlots(TestPlotBase):
     @slow
     def test_bar_colors(self):
         import matplotlib.pyplot as plt
-
-        default_colors = plt.rcParams.get('axes.color_cycle')
+        default_colors = self._maybe_unpack_cycler(plt.rcParams)
 
         df = DataFrame(randn(5, 5))
         ax = df.plot.bar()
@@ -2326,6 +2363,7 @@ class TestDataFramePlots(TestPlotBase):
 
     @slow
     def test_hist_df(self):
+        from matplotlib.patches import Rectangle
         if self.mpl_le_1_2_1:
             raise nose.SkipTest("not supported in matplotlib <= 1.2.x")
 
@@ -2346,11 +2384,14 @@ class TestDataFramePlots(TestPlotBase):
 
         ax = series.plot.hist(normed=True, cumulative=True, bins=4)
         # height of last bin (index 5) must be 1.0
-        self.assertAlmostEqual(ax.get_children()[5].get_height(), 1.0)
+        rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]
+        self.assertAlmostEqual(rects[-1].get_height(), 1.0)
         tm.close()
 
         ax = series.plot.hist(cumulative=True, bins=4)
-        self.assertAlmostEqual(ax.get_children()[5].get_height(), 100.0)
+        rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]
+
+        self.assertAlmostEqual(rects[-2].get_height(), 100.0)
         tm.close()
 
         # if horizontal, yticklabels are rotated
@@ -2626,7 +2667,7 @@ class TestDataFramePlots(TestPlotBase):
     def test_line_colors_and_styles_subplots(self):
         # GH 9894
         from matplotlib import cm
-        default_colors = self.plt.rcParams.get('axes.color_cycle')
+        default_colors = self._maybe_unpack_cycler(self.plt.rcParams)
 
         df = DataFrame(randn(5, 5))
 
@@ -2698,7 +2739,8 @@ class TestDataFramePlots(TestPlotBase):
 
         handles, labels = ax.get_legend_handles_labels()
         # legend is stored as Line2D, thus check linecolors
-        self._check_colors(handles, linecolors=custom_colors)
+        linehandles = [x for x in handles if not isinstance(x, PolyCollection)]
+        self._check_colors(linehandles, linecolors=custom_colors)
         for h in handles:
             self.assertTrue(h.get_alpha() is None)
         tm.close()
@@ -2710,12 +2752,13 @@ class TestDataFramePlots(TestPlotBase):
         self._check_colors(poly, facecolors=jet_colors)
 
         handles, labels = ax.get_legend_handles_labels()
-        self._check_colors(handles, linecolors=jet_colors)
+        linehandles = [x for x in handles if not isinstance(x, PolyCollection)]
+        self._check_colors(linehandles, linecolors=jet_colors)
         for h in handles:
             self.assertTrue(h.get_alpha() is None)
         tm.close()
 
-        # When stacked=True, alpha is set to 0.5
+        # When stacked=False, alpha is set to 0.5
         ax = df.plot.area(colormap=cm.jet, stacked=False)
         self._check_colors(ax.get_lines(), linecolors=jet_colors)
         poly = [o for o in ax.get_children() if isinstance(o, PolyCollection)]
@@ -2724,13 +2767,13 @@ class TestDataFramePlots(TestPlotBase):
 
         handles, labels = ax.get_legend_handles_labels()
         # Line2D can't have alpha in its linecolor
-        self._check_colors(handles, linecolors=jet_colors)
+        self._check_colors(handles[:len(jet_colors)], linecolors=jet_colors)
         for h in handles:
             self.assertEqual(h.get_alpha(), 0.5)
 
     @slow
     def test_hist_colors(self):
-        default_colors = self.plt.rcParams.get('axes.color_cycle')
+        default_colors = self._maybe_unpack_cycler(self.plt.rcParams)
 
         df = DataFrame(randn(5, 5))
         ax = df.plot.hist()
@@ -2791,7 +2834,7 @@ class TestDataFramePlots(TestPlotBase):
         _skip_if_no_scipy_gaussian_kde()
 
         from matplotlib import cm
-        default_colors = self.plt.rcParams.get('axes.color_cycle')
+        default_colors = self._maybe_unpack_cycler(self.plt.rcParams)
 
         df = DataFrame(randn(5, 5))
 
@@ -2853,7 +2896,7 @@ class TestDataFramePlots(TestPlotBase):
             self._check_colors(bp['fliers'], linecolors=[fliers_c] * len(bp['fliers']))
             self._check_colors(bp['caps'], linecolors=[caps_c] * len(bp['caps']))
 
-        default_colors = self.plt.rcParams.get('axes.color_cycle')
+        default_colors = self._maybe_unpack_cycler(self.plt.rcParams)
 
         df = DataFrame(randn(5, 5))
         bp = df.plot.box(return_type='dict')
@@ -2900,12 +2943,17 @@ class TestDataFramePlots(TestPlotBase):
 
     def test_default_color_cycle(self):
         import matplotlib.pyplot as plt
-        plt.rcParams['axes.color_cycle'] = list('rgbk')
+        colors = list('rgbk')
+        if self.mpl_ge_1_5_0:
+            import cycler
+            plt.rcParams['axes.prop_cycle'] = cycler.cycler('color', colors)
+        else:
+            plt.rcParams['axes.color_cycle'] = colors
 
         df = DataFrame(randn(5, 3))
         ax = df.plot()
 
-        expected = plt.rcParams['axes.color_cycle'][:3]
+        expected = self._maybe_unpack_cycler(plt.rcParams)[:3]
         self._check_colors(ax.get_lines(), linecolors=expected)
 
     def test_unordered_ts(self):
@@ -3125,7 +3173,7 @@ class TestDataFramePlots(TestPlotBase):
             df.plot(yerr=np.random.randn(11))
 
         df_err = DataFrame({'x': ['zzz']*12, 'y': ['zzz']*12})
-        with tm.assertRaises(TypeError):
+        with tm.assertRaises((ValueError, TypeError)):
             df.plot(yerr=df_err)
 
     @slow
diff --git a/pandas/tests/test_graphics_others.py b/pandas/tests/test_graphics_others.py
index 641180c80..a3189790b 100644
--- a/pandas/tests/test_graphics_others.py
+++ b/pandas/tests/test_graphics_others.py
@@ -607,6 +607,8 @@ class TestDataFrameGroupByPlots(TestPlotBase):
 
     @slow
     def test_grouped_hist_legacy(self):
+        from matplotlib.patches import Rectangle
+
         df = DataFrame(randn(500, 2), columns=['A', 'B'])
         df['C'] = np.random.randint(0, 4, 500)
         df['D'] = ['X'] * 500
@@ -633,7 +635,8 @@ class TestDataFrameGroupByPlots(TestPlotBase):
                                      xlabelsize=xf, xrot=xrot, ylabelsize=yf, yrot=yrot)
         # height of last bin (index 5) must be 1.0
         for ax in axes.ravel():
-            height = ax.get_children()[5].get_height()
+            rects = [x for x in ax.get_children() if isinstance(x, Rectangle)]
+            height = rects[-1].get_height()
             self.assertAlmostEqual(height, 1.0)
         self._check_ticks_props(axes, xlabelsize=xf, xrot=xrot,
                                 ylabelsize=yf, yrot=yrot)
diff --git a/pandas/tools/plotting.py b/pandas/tools/plotting.py
index cd2297d60..bf839cb1b 100644
--- a/pandas/tools/plotting.py
+++ b/pandas/tools/plotting.py
@@ -24,13 +24,13 @@ from pandas.tseries.offsets import DateOffset
 from pandas.compat import range, lrange, lmap, map, zip, string_types
 import pandas.compat as compat
 from pandas.util.decorators import Appender
-
 try:  # mpl optional
     import pandas.tseries.converter as conv
     conv.register()  # needs to override so set_xlim works with str/number
 except ImportError:
     pass
 
+
 # Extracted from https://gist.github.com/huyng/816622
 # this is the rcParams set when setting display.with_mpl_style
 # to True.
@@ -97,6 +97,48 @@ mpl_stylesheet = {
      'ytick.minor.size': 0.0
 }
 
+
+def _mpl_le_1_2_1():
+    try:
+        import matplotlib as mpl
+        return (str(mpl.__version__) <= LooseVersion('1.2.1') and
+                str(mpl.__version__)[0] != '0')
+    except ImportError:
+        return False
+
+def _mpl_ge_1_3_1():
+    try:
+        import matplotlib
+        # The or v[0] == '0' is because their versioneer is
+        # messed up on dev
+        return (matplotlib.__version__ >= LooseVersion('1.3.1')
+                or matplotlib.__version__[0] == '0')
+    except ImportError:
+        return False
+
+def _mpl_ge_1_4_0():
+    try:
+        import matplotlib
+        return (matplotlib.__version__  >= LooseVersion('1.4')
+                or matplotlib.__version__[0] == '0')
+    except ImportError:
+        return False
+
+def _mpl_ge_1_5_0():
+    try:
+        import matplotlib
+        return (matplotlib.__version__  >= LooseVersion('1.5')
+                or matplotlib.__version__[0] == '0')
+    except ImportError:
+        return False
+
+if _mpl_ge_1_5_0():
+    # Compat with mp 1.5, which uses cycler.
+    import cycler
+    colors = mpl_stylesheet.pop('axes.color_cycle')
+    mpl_stylesheet['axes.prop_cycle'] = cycler.cycler('color_cycle', colors)
+
+
 def _get_standard_kind(kind):
     return {'density': 'kde'}.get(kind, kind)
 
@@ -784,7 +826,6 @@ class MPLPlot(object):
     _layout_type = 'vertical'
     _default_rot = 0
     orientation = None
-
     _pop_attributes = ['label', 'style', 'logy', 'logx', 'loglog',
                        'mark_right', 'stacked']
     _attr_defaults = {'logy': False, 'logx': False, 'loglog': False,
@@ -973,8 +1014,9 @@ class MPLPlot(object):
         else:
             # otherwise, create twin axes
             orig_ax, new_ax = ax, ax.twinx()
-            new_ax._get_lines.color_cycle = orig_ax._get_lines.color_cycle
-
+            # TODO: use Matplotlib public API when available
+            new_ax._get_lines = orig_ax._get_lines
+            new_ax._get_patches_for_fill = orig_ax._get_patches_for_fill
             orig_ax.right_ax, new_ax.left_ax = new_ax, orig_ax
 
             if not self._has_plotted_object(orig_ax):  # no data on left y
@@ -1197,6 +1239,14 @@ class MPLPlot(object):
         import matplotlib.pyplot as plt
         return plt
 
+    @staticmethod
+    def mpl_ge_1_3_1():
+        return _mpl_ge_1_3_1()
+
+    @staticmethod
+    def mpl_ge_1_5_0():
+        return _mpl_ge_1_5_0()
+
     _need_to_set_index = False
 
     def _get_xticks(self, convert_period=False):
@@ -1474,9 +1524,6 @@ class ScatterPlot(PlanePlot):
         self.c = c
 
     def _make_plot(self):
-        import matplotlib as mpl
-        mpl_ge_1_3_1 = str(mpl.__version__) >= LooseVersion('1.3.1')
-
         x, y, c, data = self.x, self.y, self.c, self.data
         ax = self.axes[0]
 
@@ -1505,7 +1552,7 @@ class ScatterPlot(PlanePlot):
         if cb:
             img = ax.collections[0]
             kws = dict(ax=ax)
-            if mpl_ge_1_3_1:
+            if self.mpl_ge_1_3_1():
                 kws['label'] = c if c_is_column else ''
             self.fig.colorbar(img, **kws)
 
@@ -1636,6 +1683,11 @@ class LinePlot(MPLPlot):
 
         # Set ax with freq info
         _decorate_axes(ax, freq, kwds)
+        # digging deeper
+        if hasattr(ax, 'left_ax'):
+            _decorate_axes(ax.left_ax, freq, kwds)
+        if hasattr(ax, 'right_ax'):
+            _decorate_axes(ax.right_ax, freq, kwds)
         ax._plot_data.append((data, cls._kind, kwds))
 
         lines = cls._plot(ax, data.index, data.values, style=style, **kwds)
@@ -1743,6 +1795,8 @@ class AreaPlot(LinePlot):
         if not 'color' in kwds:
             kwds['color'] = lines[0].get_color()
 
+        if cls.mpl_ge_1_5_0(): # mpl 1.5 added real support for poly legends
+            kwds.pop('label')
         ax.fill_between(xdata, start, y_values, **kwds)
         cls._update_stacker(ax, stacking_id, y)
         return lines
diff --git a/pandas/tseries/tests/test_plotting.py b/pandas/tseries/tests/test_plotting.py
index d9b31c0a1..bcd1e400d 100644
--- a/pandas/tseries/tests/test_plotting.py
+++ b/pandas/tseries/tests/test_plotting.py
@@ -483,6 +483,7 @@ class TestTSPlot(tm.TestCase):
         ts[5:25] = np.nan
         ax = ts.plot()
         lines = ax.get_lines()
+        tm._skip_if_mpl_1_5()
         self.assertEqual(len(lines), 1)
         l = lines[0]
         data = l.get_xydata()
@@ -532,6 +533,9 @@ class TestTSPlot(tm.TestCase):
         self.assertEqual(len(ax.right_ax.get_lines()), 1)
         l = lines[0]
         data = l.get_xydata()
+
+        tm._skip_if_mpl_1_5()
+
         tm.assertIsInstance(data, np.ma.core.MaskedArray)
         mask = data.mask
         self.assertTrue(mask[5:25, 1].all())
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index 6d443c8fb..d70e6349d 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -196,6 +196,14 @@ def mplskip(cls):
     return cls
 
 
+def _skip_if_mpl_1_5():
+    import matplotlib
+    v = matplotlib.__version__
+    if v > LooseVersion('1.4.3') or v[0] == '0':
+        import nose
+        raise nose.SkipTest("matplotlib 1.5")
+
+
 def _skip_if_no_scipy():
     try:
         import scipy.stats

commit d859cbdf38ecb6ade84edc05bbfb866ddb0a25e8
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Sep 26 22:40:14 2011 -0400

    ENH: work on faster merging function that does not produce intermediate copies

diff --git a/pandas/core/common.py b/pandas/core/common.py
index 8ace1d21e..826015706 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -155,7 +155,7 @@ def take_1d(arr, indexer):
 
     return out
 
-def take_2d(arr, indexer, mask=None, needs_masking=None, axis=0):
+def take_2d(arr, indexer, out=None, mask=None, needs_masking=None, axis=0):
     """
     Specialized Cython take which sets NaN values in one pass
     """
@@ -183,11 +183,11 @@ def take_2d(arr, indexer, mask=None, needs_masking=None, axis=0):
         take_f = _get_take2d_function(dtype_str, axis=axis)
         take_f(arr, indexer, out=out)
     else:
-        out = arr.take(indexer, axis=axis)
         if mask is None:
             mask = indexer == -1
             needs_masking = mask.any()
 
+        out = arr.take(indexer, axis=axis)
         if needs_masking:
             out = _maybe_upcast(out)
             null_out_axis(out, mask, axis)
@@ -200,15 +200,21 @@ def null_out_axis(arr, mask, axis):
 
     arr[tuple(indexer)] = np.NaN
 
-def take_fast(arr, indexer, mask, needs_masking, axis=0):
+def take_fast(arr, indexer, mask, needs_masking, axis=0, out=None):
     if arr.ndim == 2:
-        return take_2d(arr, indexer, mask=mask,
+        return take_2d(arr, indexer, out=out, mask=mask,
                        needs_masking=needs_masking,
                        axis=axis)
-    out = arr.take(indexer, axis=axis)
-    if needs_masking:
-        out = _maybe_upcast(out)
-        null_out_axis(out, mask, axis)
+
+    if out is None:
+        out = arr.take(indexer, axis=axis)
+        if needs_masking:
+            out = _maybe_upcast(out)
+            null_out_axis(out, mask, axis)
+    else:
+        out = arr.take(indexer, axis=axis)
+        if needs_masking and _need_upcast(out):
+            raise Exception('incompatible type for NAs')
     return out
 
 def _maybe_upcast(values):
@@ -219,6 +225,11 @@ def _maybe_upcast(values):
 
     return values
 
+def _need_upcast(values):
+    if issubclass(values.dtype.type, (np.int_, np.bool_)):
+        return True
+    return False
+
 #-------------------------------------------------------------------------------
 # Lots of little utilities
 
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 5cfe0831b..a7ddda876 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -162,13 +162,6 @@ class Block(object):
         new_values.flat[mask] = value
         return make_block(new_values, self.items, self.ref_items)
 
-def _cast_if_bool_int(values):
-    if issubclass(values.dtype.type, np.int_):
-        values = values.astype(float)
-    elif issubclass(values.dtype.type, np.bool_):
-        values = values.astype(object)
-    return values
-
 #-------------------------------------------------------------------------------
 # Is this even possible?
 
@@ -886,6 +879,8 @@ def _consolidate(blocks, items):
     return new_blocks
 
 def _merge_blocks(blocks, items):
+    if len(blocks) == 1:
+        return blocks[0]
     new_values = np.vstack([b.values for b in blocks])
     new_items = np.concatenate([b.items for b in blocks])
     new_block = make_block(new_values, new_items, items)
@@ -918,3 +913,122 @@ def _union_items_slow(all_items):
         else:
             seen = seen.union(items)
     return seen
+
+
+def merge_managers(left, right, index, axis=1):
+    """
+    Parameters
+    ----------
+    other
+    lindexer
+    lmask
+    rindexer
+    rmask
+
+    Returns
+    -------
+    merged : BlockManager
+    """
+    assert(left.is_consolidated())
+    assert(right.is_consolidated())
+
+    if left.axes[axis].equals(index):
+        lindexer = np.arange(index, dtype=np.int32)
+        lmask = np.zeros(len(index), dtype=np.bool)
+        lneed_masking = False
+    else:
+        lindexer = left.axes[axis].get_indexer(index)
+        lmask = lindexer == -1
+        lneed_masking = lmask.any()
+
+    if right.axes[axis].equals(index):
+        rindexer = np.arange(index, dtype=np.int32)
+        rmask = np.zeros(len(index), dtype=np.bool)
+        rneed_masking = False
+    else:
+        rindexer = right.axes[axis].get_indexer(index)
+        rmask = rindexer == -1
+        rneed_masking = rmask.any()
+
+    lblocks = _maybe_upcast_blocks(left.blocks, lneed_masking)
+    rblocks = _maybe_upcast_blocks(right.blocks, rneed_masking)
+
+    left_blockmap = dict((type(blk), blk) for blk in lblocks)
+    right_blockmap = dict((type(blk), blk) for blk in rblocks)
+
+    # do NOT sort
+    result_items = left.items.append(right.items)
+
+    result_axes = list(left.axes)
+    result_axes[0] = result_items
+    result_axes[axis] = index
+
+    result_blocks = []
+
+    kinds = [FloatBlock, ObjectBlock, BoolBlock, IntBlock]
+    for klass in kinds:
+        if klass in left_blockmap and right_blockmap:
+            # true merge
+            left = left_blockmap[klass]
+            right = right_blockmap[klass]
+            new_values = _merge_blocks_fast(left, right,
+                                            lindexer, lmask, lneed_masking,
+                                            rindexer, rmask, rneed_masking,
+                                            axis=axis)
+            new_items = left.items.append(right.items)
+            res_blk = make_block(new_values, new_items, result_items)
+        elif klass in left_blockmap:
+            # only take necessary
+            blk = left_blockmap[klass]
+            res_blk = blk.reindex_axis(lindexer, lmask, lneed_masking,
+                                       axis=axis)
+            res_blk.ref_items = result_items
+        elif klass in right_blockmap:
+            # only take necessary
+            blk = right_blockmap[klass]
+            res_blk = blk.reindex_axis(lindexer, lmask, lneed_masking,
+                                       axis=axis)
+            res_blk.ref_items = result_items
+
+        result_blocks.append(res_blk)
+
+    return BlockManager(result_blocks, result_axes)
+
+def _maybe_upcast_blocks(blocks, needs_masking):
+    """
+    Upcast and consolidate if necessary
+    """
+    if not needs_masking:
+        return blocks
+    new_blocks = []
+    for block in blocks:
+        if isinstance(block, IntBlock):
+            newb = make_block(block.values.astype(float), block.items,
+                              block.ref_items)
+        elif isinstance(block, BoolBlock):
+            newb = make_block(block.values.astype(object), block.items,
+                              block.ref_items)
+        else:
+            newb = block
+        new_blocks.append(newb)
+
+    # use any ref_items
+    return _consolidate(blocks, newb.ref_items)
+
+def _merge_blocks_fast(left, right, lindexer, lmask, lneed_masking,
+                       rindexer, rmask, rneed_masking, axis=1):
+    n = len(lindexer)
+    lk = len(left.items)
+    rk = len(right.items)
+
+    out_shape = list(left.shape)
+    out_shape[0] = lk + rk
+    out_shape[axis] = n
+
+    out = np.empty(out_shape, dtype=left.values.dtype)
+    common.take_fast(left.values, lindexer, lmask, lneed_masking,
+                     axis=axis, out=out[:lk].T)
+    common.take_fast(right.values, rindexer, rmask, rneed_masking,
+                     axis=axis, out=out[lk:].T)
+
+    return out
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 1b0625d41..16df6056c 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -2471,6 +2471,19 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         self.assertRaises(Exception, target.join, source, on='C',
                           how='left')
 
+    def test_join_index_mixed(self):
+        # TODO!
+
+        df1 = DataFrame({'A' : 1., 'B' : 2, 'C' : 'foo', 'D' : True},
+                        index=np.arange(10))
+        self.assert_(df1['B'].dtype == np.int_)
+        self.assert_(df1['D'].dtype == np.bool_)
+
+        df2 = DataFrame({'A' : 1., 'B' : 2, 'C' : 'foo', 'D' : True},
+                        index=np.arange(0, 10, 2))
+
+        joined = df1.join(df2, lsuffix='_one', rsuffix='_two')
+
     def test_clip(self):
         median = self.frame.median().median()
 
diff --git a/setup.py b/setup.py
index a350ba5ac..bf897f256 100755
--- a/setup.py
+++ b/setup.py
@@ -118,7 +118,7 @@ CLASSIFIERS = [
 MAJOR = 0
 MINOR = 4
 MICRO = 1
-ISRELEASED = True
+ISRELEASED = False
 VERSION = '%d.%d.%d' % (MAJOR, MINOR, MICRO)
 
 FULLVERSION = VERSION

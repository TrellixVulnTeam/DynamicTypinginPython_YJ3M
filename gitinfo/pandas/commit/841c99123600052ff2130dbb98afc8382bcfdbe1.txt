commit 841c99123600052ff2130dbb98afc8382bcfdbe1
Author: Chang She <changshe@gmail.com>
Date:   Tue Nov 27 13:58:06 2012 -0500

    ENH: partial date slicing for day, hour, and minute resolutions #2306

diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 44660cd3b..bb5ed79cc 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -1603,3 +1603,100 @@ cpdef normalize_date(object dt):
         return datetime(dt.year, dt.month, dt.day)
     else:
         raise TypeError('Unrecognized type: %s' % type(dt))
+
+cpdef resolution(ndarray[int64_t] stamps, tz=None):
+    cdef:
+        Py_ssize_t i, n = len(stamps)
+        pandas_datetimestruct dts
+        int reso = D_RESO, curr_reso
+
+    if tz is not None:
+        if isinstance(tz, basestring):
+            tz = pytz.timezone(tz)
+        return _reso_local(stamps, tz)
+    else:
+        for i in range(n):
+            if stamps[i] == NPY_NAT:
+                continue
+            pandas_datetime_to_datetimestruct(stamps[i], PANDAS_FR_ns, &dts)
+            curr_reso = _reso_stamp(&dts)
+            if curr_reso < reso:
+                reso = curr_reso
+        return reso
+
+US_RESO = 0
+S_RESO = 1
+T_RESO = 2
+H_RESO = 3
+D_RESO = 4
+
+cdef inline int _reso_stamp(pandas_datetimestruct *dts):
+    if dts.us != 0:
+        return US_RESO
+    elif dts.sec != 0:
+        return S_RESO
+    elif dts.min != 0:
+        return T_RESO
+    elif dts.hour != 0:
+        return H_RESO
+    return D_RESO
+
+cdef _reso_local(ndarray[int64_t] stamps, object tz):
+    cdef:
+        Py_ssize_t n = len(stamps)
+        int reso = D_RESO, curr_reso
+        ndarray[int64_t] trans, deltas, pos
+        pandas_datetimestruct dts
+
+    if _is_utc(tz):
+        for i in range(n):
+            if stamps[i] == NPY_NAT:
+                continue
+            pandas_datetime_to_datetimestruct(stamps[i], PANDAS_FR_ns, &dts)
+            curr_reso = _reso_stamp(&dts)
+            if curr_reso < reso:
+                reso = curr_reso
+    elif _is_tzlocal(tz):
+        for i in range(n):
+            if stamps[i] == NPY_NAT:
+                continue
+            pandas_datetime_to_datetimestruct(stamps[i], PANDAS_FR_ns,
+                                              &dts)
+            dt = datetime(dts.year, dts.month, dts.day, dts.hour,
+                          dts.min, dts.sec, dts.us, tz)
+            delta = int(total_seconds(_get_utcoffset(tz, dt))) * 1000000000
+            pandas_datetime_to_datetimestruct(stamps[i] + delta,
+                                              PANDAS_FR_ns, &dts)
+            curr_reso = _reso_stamp(&dts)
+            if curr_reso < reso:
+                reso = curr_reso
+    else:
+        # Adjust datetime64 timestamp, recompute datetimestruct
+        trans = _get_transitions(tz)
+        deltas = _get_deltas(tz)
+        _pos = trans.searchsorted(stamps, side='right') - 1
+        if _pos.dtype != np.int64:
+            _pos = _pos.astype(np.int64)
+        pos = _pos
+
+        # statictzinfo
+        if not hasattr(tz, '_transition_info'):
+            for i in range(n):
+                if stamps[i] == NPY_NAT:
+                    continue
+                pandas_datetime_to_datetimestruct(stamps[i] + deltas[0],
+                                                  PANDAS_FR_ns, &dts)
+                curr_reso = _reso_stamp(&dts)
+                if curr_reso < reso:
+                    reso = curr_reso
+        else:
+            for i in range(n):
+                if stamps[i] == NPY_NAT:
+                    continue
+                pandas_datetime_to_datetimestruct(stamps[i] + deltas[pos[i]],
+                                                  PANDAS_FR_ns, &dts)
+                curr_reso = _reso_stamp(&dts)
+                if curr_reso < reso:
+                    reso = curr_reso
+
+    return reso
diff --git a/pandas/tseries/frequencies.py b/pandas/tseries/frequencies.py
index bc1770d58..a16999248 100644
--- a/pandas/tseries/frequencies.py
+++ b/pandas/tseries/frequencies.py
@@ -22,6 +22,24 @@ class FreqGroup(object):
     FR_MIN = 8000
     FR_SEC = 9000
 
+class Resolution(object):
+
+    RESO_US = 0
+    RESO_SEC = 1
+    RESO_MIN = 2
+    RESO_HR = 3
+    RESO_DAY = 4
+
+    @classmethod
+    def get_str(cls, reso):
+        return {RESO_US : 'microsecond',
+                RESO_SEC : 'second',
+                RESO_MIN : 'minute',
+                RESO_HR : 'hour',
+                RESO_DAY : 'day'}.get(reso, 'day')
+
+def get_reso_string(reso):
+    return Resolution.get_str(reso)
 
 def get_to_timestamp_base(base):
     if base <= FreqGroup.FR_WK:
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 6cbfbfa45..c6eec268c 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -8,7 +8,8 @@ import numpy as np
 
 from pandas.core.common import isnull
 from pandas.core.index import Index, Int64Index
-from pandas.tseries.frequencies import infer_freq, to_offset, get_period_alias
+from pandas.tseries.frequencies import (infer_freq, to_offset, get_period_alias,
+                                        Resolution, get_reso_string)
 from pandas.tseries.offsets import DateOffset, generate_range, Tick
 from pandas.tseries.tools import parse_time_string, normalize_date
 from pandas.util.decorators import cache_readonly
@@ -1006,6 +1007,23 @@ class DatetimeIndex(Int64Index):
             d = lib.monthrange(parsed.year, qe)[1]   # at end of month
             t1 = Timestamp(datetime(parsed.year, parsed.month, 1))
             t2 = Timestamp(datetime(parsed.year, qe, d))
+        elif reso == 'day' and self._resolution < Resolution.RESO_DAY:
+            st = datetime(parsed.year, parsed.month, parsed.day)
+            t1 = Timestamp(st)
+            t2 = st + offsets.Day()
+            t2 = Timestamp(Timestamp(t2).value - 1)
+        elif (reso == 'hour' and
+              self._resolution < Resolution.RESO_HR):
+            st = datetime(parsed.year, parsed.month, parsed.day,
+                          hour=parsed.hour)
+            t1 = Timestamp(st)
+            t2 = Timestamp(Timestamp(st + offsets.Hour()).value - 1)
+        elif (reso == 'minute' and
+              self._resolution < Resolution.RESO_MIN):
+            st = datetime(parsed.year, parsed.month, parsed.day,
+                          hour=parsed.hour, minute=parsed.minute)
+            t1 = Timestamp(st)
+            t2 = Timestamp(Timestamp(st + offsets.Minute()).value - 1)
         else:
             raise KeyError
 
@@ -1221,6 +1239,18 @@ class DatetimeIndex(Int64Index):
         """
         return lib.dates_normalized(self.asi8, self.tz)
 
+    @cache_readonly
+    def resolution(self):
+        """
+        Returns day, hour, minute, second, or microsecond
+        """
+        reso = self._resolution
+        return get_reso_string(reso)
+
+    @cache_readonly
+    def _resolution(self):
+        return lib.resolution(self.asi8, self.tz)
+
     def equals(self, other):
         """
         Determines if two Index objects contain the same elements.
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index 85b3654ba..b1fa5d538 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -1219,4 +1219,3 @@ def period_range(start=None, end=None, periods=None, freq='D', name=None):
     """
     return PeriodIndex(start=start, end=end, periods=periods,
                        freq=freq, name=name)
-
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index ef35c44b5..cce5093e2 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -1833,6 +1833,48 @@ class TestLegacySupport(unittest.TestCase):
         expected = s[:'20060228']
         assert_series_equal(result, expected)
 
+        result = s['2005-1-1']
+        self.assert_(result == s.irow(0))
+
+        self.assertRaises(Exception, s.__getitem__, '2004-12-31')
+
+    def test_partial_slice_daily(self):
+        rng = DatetimeIndex(freq='H', start=datetime(2005,1,31), periods=500)
+        s = Series(np.arange(len(rng)), index=rng)
+
+        result = s['2005-1-31']
+        assert_series_equal(result, s.ix[:24])
+
+        self.assertRaises(Exception, s.__getitem__, '2004-12-31 00')
+
+    def test_partial_slice_hourly(self):
+        rng = DatetimeIndex(freq='T', start=datetime(2005,1,1,20,0,0),
+                            periods=500)
+        s = Series(np.arange(len(rng)), index=rng)
+
+        result = s['2005-1-1']
+        assert_series_equal(result, s.ix[:60*4])
+
+        result = s['2005-1-1 20']
+        assert_series_equal(result, s.ix[:60])
+
+        self.assert_(s['2005-1-1 20:00'] == s.ix[0])
+        self.assertRaises(Exception, s.__getitem__, '2004-12-31 00:15')
+
+    def test_partial_slice_minutely(self):
+        rng = DatetimeIndex(freq='S', start=datetime(2005,1,1,23,59,0),
+                            periods=500)
+        s = Series(np.arange(len(rng)), index=rng)
+
+        result = s['2005-1-1 23:59']
+        assert_series_equal(result, s.ix[:60])
+
+        result = s['2005-1-1']
+        assert_series_equal(result, s.ix[:60])
+
+        self.assert_(s['2005-1-1 23:59:00'] == s.ix[0])
+        self.assertRaises(Exception, s.__getitem__, '2004-12-31 00:00:00')
+
     def test_partial_not_monotonic(self):
         rng = date_range(datetime(2005,1,1), periods=20, freq='M')
         ts = Series(np.arange(len(rng)), index=rng)
diff --git a/pandas/tseries/tools.py b/pandas/tseries/tools.py
index befe3444d..7c7ec3845 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/tseries/tools.py
@@ -9,7 +9,7 @@ import pandas.core.common as com
 
 try:
     import dateutil
-    from dateutil.parser import parse
+    from dateutil.parser import parse, DEFAULTPARSER
     from dateutil.relativedelta import relativedelta
 
     # raise exception if dateutil 2.0 install on 2.x platform
@@ -131,6 +131,7 @@ qpat2full = re.compile(r'(\d\d\d\d)Q(\d)')
 qpat1 = re.compile(r'(\d)Q(\d\d)')
 qpat2 = re.compile(r'(\d\d)Q(\d)')
 ypat = re.compile(r'(\d\d\d\d)$')
+has_time = re.compile('(.+)([\s]|T)+(.+)')
 
 
 def parse_time_string(arg, freq=None, dayfirst=None, yearfirst=None):
@@ -226,25 +227,61 @@ def parse_time_string(arg, freq=None, dayfirst=None, yearfirst=None):
         yearfirst = print_config.date_yearfirst
 
     try:
-        parsed = parse(arg, dayfirst=dayfirst, yearfirst=yearfirst)
+        parsed, reso = dateutil_parse(arg, default, dayfirst=dayfirst,
+                                      yearfirst=yearfirst)
     except Exception, e:
         raise DateParseError(e)
 
     if parsed is None:
         raise DateParseError("Could not parse %s" % arg)
 
-    repl = {}
-    reso = 'year'
+    return parsed, parsed, reso  # datetime, resolution
+
+def dateutil_parse(timestr, default,
+                   ignoretz=False, tzinfos=None,
+                   **kwargs):
+    """ lifted from dateutil to get resolution"""
+    res = DEFAULTPARSER._parse(timestr, **kwargs)
+
+    if res is None:
+        raise ValueError, "unknown string format"
 
+    repl = {}
     for attr in ["year", "month", "day", "hour",
                  "minute", "second", "microsecond"]:
-        value = getattr(parsed, attr)
-        if value is not None and value != 0:  # or attr in can_be_zero):
+        value = getattr(res, attr)
+        if value is not None:
             repl[attr] = value
             reso = attr
-    ret = default.replace(**repl)
-    return ret, parsed, reso  # datetime, resolution
+    if reso == 'microsecond' and repl['microsecond'] == 0:
+        reso = 'second'
 
+    ret = default.replace(**repl)
+    if res.weekday is not None and not res.day:
+        ret = ret+relativedelta.relativedelta(weekday=res.weekday)
+    if not ignoretz:
+        if callable(tzinfos) or tzinfos and res.tzname in tzinfos:
+            if callable(tzinfos):
+                tzdata = tzinfos(res.tzname, res.tzoffset)
+            else:
+                tzdata = tzinfos.get(res.tzname)
+            if isinstance(tzdata, datetime.tzinfo):
+                tzinfo = tzdata
+            elif isinstance(tzdata, basestring):
+                tzinfo = tz.tzstr(tzdata)
+            elif isinstance(tzdata, int):
+                tzinfo = tz.tzoffset(res.tzname, tzdata)
+            else:
+                raise ValueError, "offset must be tzinfo subclass, " \
+                                  "tz string, or int offset"
+            ret = ret.replace(tzinfo=tzinfo)
+        elif res.tzname and res.tzname in time.tzname:
+            ret = ret.replace(tzinfo=tz.tzlocal())
+        elif res.tzoffset == 0:
+            ret = ret.replace(tzinfo=tz.tzutc())
+        elif res.tzoffset:
+            ret = ret.replace(tzinfo=tz.tzoffset(res.tzname, res.tzoffset))
+    return ret, reso
 
 def _attempt_monthly(val):
     pats = ['%Y-%m', '%m-%Y', '%b %Y', '%b-%Y']

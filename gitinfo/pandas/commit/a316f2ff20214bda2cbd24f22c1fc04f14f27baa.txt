commit a316f2ff20214bda2cbd24f22c1fc04f14f27baa
Author: jreback <jeff@reback.net>
Date:   Sat Mar 1 14:03:43 2014 -0500

    BUG/API: allow TimeGrouper with other columns in a groupby (GH3794)

diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 86590d231..cb8299921 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -1479,6 +1479,8 @@ class Grouping(object):
     ----------
     index : Index
     grouper :
+    obj :
+    axis :
     name :
     level :
 
@@ -1493,7 +1495,7 @@ class Grouping(object):
       * groups : dict of {group -> label_list}
     """
 
-    def __init__(self, index, grouper=None, name=None, level=None,
+    def __init__(self, index, grouper=None, obj=None, axis=0, name=None, level=None,
                  sort=True):
 
         self.name = name
@@ -1566,6 +1568,30 @@ class Grouping(object):
                 if self.name is None:
                     self.name = factor.name
 
+            # a passed TimeGrouper like
+            elif isinstance(self.grouper, CustomGrouper):
+
+                # get the obj to work on
+                if self.grouper.name is not None:
+                    name = self.grouper.name
+                    if name not in obj._info_axis:
+                        raise KeyError("The grouper name {0} is not found".format(name))
+                    ax = Index(obj[name],name=name)
+                else:
+                    ax = obj._get_axis(axis)
+                    if self.grouper.level is not None:
+                        level = self.grouper.level
+                        if isinstance(ax, MultiIndex):
+                            level = ax._get_level_name(level)
+                            ax = Index(ax.get_level_values(level), name=level)
+                        else:
+                            if not (level == 0 or level == ax.name):
+                                raise ValueError("The grouper level {0} is not valid".format(level))
+
+                self.grouper = self.grouper._get_grouper_for_ax(ax)
+                if self.name is None:
+                    self.name = self.grouper.name
+
             # no level passed
             if not isinstance(self.grouper, (Series, np.ndarray)):
                 self.grouper = self.index.map(self.grouper)
@@ -1704,7 +1730,7 @@ def _get_grouper(obj, key=None, axis=0, level=None, sort=True):
             errmsg = "Categorical grouper must have len(grouper) == len(data)"
             raise AssertionError(errmsg)
 
-        ping = Grouping(group_axis, gpr, name=name, level=level, sort=sort)
+        ping = Grouping(group_axis, gpr, obj=obj, axis=axis, name=name, level=level, sort=sort)
         groupings.append(ping)
 
     if len(groupings) == 0:
diff --git a/pandas/core/series.py b/pandas/core/series.py
index bc5566ce4..dd11b7bec 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2031,7 +2031,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
             raise ValueError("cannot reindex series on non-zero axis!")
         return self.reindex(index=labels, **kwargs)
 
-    def take(self, indices, axis=0, convert=True):
+    def take(self, indices, axis=0, convert=True, is_copy=False):
         """
         Analogous to ndarray.take, return Series corresponding to requested
         indices
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index adca8389b..0d3270d97 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -2903,6 +2903,108 @@ class TestGroupBy(tm.TestCase):
         self.assertTrue(isinstance(groups,dict))
         self.assertTrue(len(groups) == 3)
 
+    def test_timegrouper_with_reg_groups(self):
+
+        # GH 3794
+        # allow combinateion of timegrouper/reg groups
+
+        import datetime as DT
+
+        df = DataFrame({
+            'Branch' : 'A A A A A A A B'.split(),
+            'Buyer': 'Carl Mark Carl Carl Joe Joe Joe Carl'.split(),
+            'Quantity': [1,3,5,1,8,1,9,3],
+            'Date' : [
+                DT.datetime(2013,1,1,13,0),
+                DT.datetime(2013,1,1,13,5),
+                DT.datetime(2013,10,1,20,0),
+                DT.datetime(2013,10,2,10,0),
+                DT.datetime(2013,10,1,20,0),
+                DT.datetime(2013,10,2,10,0),
+                DT.datetime(2013,12,2,12,0),
+                DT.datetime(2013,12,2,14,0),
+                ]}).set_index('Date')
+
+        expected = DataFrame({
+            'Buyer': 'Carl Joe Mark'.split(),
+            'Quantity': [10,18,3],
+            'Date' : [
+                DT.datetime(2013,12,31,0,0),
+                DT.datetime(2013,12,31,0,0),
+                DT.datetime(2013,12,31,0,0),
+                ]}).set_index(['Date','Buyer'])
+        result = df.groupby([pd.TimeGrouper('A'),'Buyer']).sum()
+        assert_frame_equal(result,expected)
+
+        expected = DataFrame({
+            'Buyer': 'Carl Mark Carl Joe'.split(),
+            'Quantity': [1,3,9,18],
+            'Date' : [
+                DT.datetime(2013,1,1,0,0),
+                DT.datetime(2013,1,1,0,0),
+                DT.datetime(2013,7,1,0,0),
+                DT.datetime(2013,7,1,0,0),
+                ]}).set_index(['Date','Buyer'])
+
+        result = df.groupby([pd.TimeGrouper('6MS'),'Buyer']).sum()
+        assert_frame_equal(result,expected)
+
+        df = DataFrame({
+            'Branch' : 'A A A A A A A B'.split(),
+            'Buyer': 'Carl Mark Carl Carl Joe Joe Joe Carl'.split(),
+            'Quantity': [1,3,5,1,8,1,9,3],
+            'Date' : [
+                DT.datetime(2013,10,1,13,0),
+                DT.datetime(2013,10,1,13,5),
+                DT.datetime(2013,10,1,20,0),
+                DT.datetime(2013,10,2,10,0),
+                DT.datetime(2013,10,1,20,0),
+                DT.datetime(2013,10,2,10,0),
+                DT.datetime(2013,10,2,12,0),
+                DT.datetime(2013,10,2,14,0),
+                ]}).set_index('Date')
+
+        expected = DataFrame({
+            'Buyer': 'Carl Joe Mark Carl Joe'.split(),
+            'Quantity': [6,8,3,4,10],
+            'Date' : [
+                DT.datetime(2013,10,1,0,0),
+                DT.datetime(2013,10,1,0,0),
+                DT.datetime(2013,10,1,0,0),
+                DT.datetime(2013,10,2,0,0),
+                DT.datetime(2013,10,2,0,0),
+                ]}).set_index(['Date','Buyer'])
+
+        result = df.groupby([pd.TimeGrouper('1D'),'Buyer']).sum()
+        assert_frame_equal(result,expected)
+
+        result = df.groupby([pd.TimeGrouper('1M'),'Buyer']).sum()
+        expected = DataFrame({
+            'Buyer': 'Carl Joe Mark'.split(),
+            'Quantity': [10,18,3],
+            'Date' : [
+                DT.datetime(2013,10,31,0,0),
+                DT.datetime(2013,10,31,0,0),
+                DT.datetime(2013,10,31,0,0),
+                ]}).set_index(['Date','Buyer'])
+        assert_frame_equal(result,expected)
+
+        # passing the name
+        df = df.reset_index()
+        result = df.groupby([pd.TimeGrouper('1M',name='Date'),'Buyer']).sum()
+        assert_frame_equal(result,expected)
+
+        self.assertRaises(KeyError, lambda : df.groupby([pd.TimeGrouper('1M',name='foo'),'Buyer']).sum())
+
+        # passing the level
+        df = df.set_index('Date')
+        result = df.groupby([pd.TimeGrouper('1M',level='Date'),'Buyer']).sum()
+        assert_frame_equal(result,expected)
+        result = df.groupby([pd.TimeGrouper('1M',level=0),'Buyer']).sum()
+        assert_frame_equal(result,expected)
+
+        self.assertRaises(ValueError, lambda : df.groupby([pd.TimeGrouper('1M',level='foo'),'Buyer']).sum())
+
     def test_cumcount(self):
         df = DataFrame([['a'], ['a'], ['a'], ['b'], ['a']], columns=['A'])
         g = df.groupby('A')
diff --git a/pandas/tseries/resample.py b/pandas/tseries/resample.py
index e4221fdea..89d1daf2a 100644
--- a/pandas/tseries/resample.py
+++ b/pandas/tseries/resample.py
@@ -30,6 +30,8 @@ class TimeGrouper(CustomGrouper):
     nperiods : optional, integer
     convention : {'start', 'end', 'e', 's'}
         If axis is PeriodIndex
+    name : referring name, default None
+    level : referering level, default None
 
     Notes
     -----
@@ -39,7 +41,7 @@ class TimeGrouper(CustomGrouper):
     def __init__(self, freq='Min', closed=None, label=None, how='mean',
                  nperiods=None, axis=0,
                  fill_method=None, limit=None, loffset=None, kind=None,
-                 convention=None, base=0):
+                 convention=None, base=0, name=None, level=None):
         self.freq = to_offset(freq)
 
         end_types = set(['M', 'A', 'Q', 'BM', 'BA', 'BQ', 'W'])
@@ -70,6 +72,8 @@ class TimeGrouper(CustomGrouper):
         self.fill_method = fill_method
         self.limit = limit
         self.base = base
+        self.name = name
+        self.level = level
 
     def resample(self, obj):
         ax = obj._get_axis(self.axis)
@@ -103,13 +107,42 @@ class TimeGrouper(CustomGrouper):
         # return a tuple of (binner, grouper, obj)
         return self._get_time_grouper(obj)
 
+    def _get_grouper_for_ax(self, ax):
+        # return an ordering of the transformed group labels,
+        # suitable for multi-grouping, e.g the labels for
+        # the resampled intervals
+
+        indexer = None
+        if not ax.is_monotonic:
+            indexer = ax.argsort(kind='quicksort')
+            ax = ax.take(indexer)
+
+        if self.kind is None or self.kind == 'timestamp':
+            binner, bins, binlabels = self._get_time_bins(ax)
+        else:
+            binner, bins, binlabels = self._get_time_period_bins(ax)
+
+        grp = BinGrouper(bins, binlabels)
+
+        # create the grouper
+        l = []
+        for key, group in grp.get_iterator(ax):
+            l.extend([key]*len(group))
+        grouper = binner.__class__(l,freq=binner.freq,name=binner.name)
+
+        # since we may have had to sort
+        # may need to reorder groups here
+        if indexer is not None:
+            grouper = grouper.take(indexer)
+        return grouper
+
     def _ensure_sortedness(self, obj):
         # ensure that our object is sorted
         ax = obj._get_axis(self.axis)
         if not ax.is_monotonic:
             try:
                 obj = obj.sort_index(axis=self.axis)
-            except TypeError:
+            except:
                 obj = obj.sort_index()
         return obj
 
diff --git a/pandas/tseries/tests/test_resample.py b/pandas/tseries/tests/test_resample.py
index 23b8905b2..20c672472 100644
--- a/pandas/tseries/tests/test_resample.py
+++ b/pandas/tseries/tests/test_resample.py
@@ -1137,7 +1137,6 @@ class TestTimeGrouper(tm.TestCase):
         _, grouper, _ = tg.get_grouper(df)
 
         # Errors
-
         grouped = df.groupby(grouper, group_keys=False)
         f = lambda df: df['close'] / df['open']
 

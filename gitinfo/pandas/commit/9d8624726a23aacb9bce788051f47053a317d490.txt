commit 9d8624726a23aacb9bce788051f47053a317d490
Author: Jan Schulz <jasc@gmx.net>
Date:   Sat Sep 13 18:57:22 2014 +0200

    API: rename Categorical.levels to .categories
    
    The name 'levels' was already used by a much different concept in
    MultiIndex and this was too confusing, so change the name to
    'categories'. Add deprecation warning if the old name is used
    (in constructor or the public 'levels' attribute). The old name
    'levels' is not anymore exposed unter Series.cat as it was never
    part of a stable release.
    
    See the discussion in https://github.com/pydata/pandas/issues/8074
    
    This rename was done by search&replace in categorical.py and the
    corresponding tests_categorical.py, implementing the deprecation
    accessor (with a temporary 'raise Exception') and then run the the
    unittests and change code until all tests pass.

diff --git a/doc/source/api.rst b/doc/source/api.rst
index f831b97d2..a33db3dda 100644
--- a/doc/source/api.rst
+++ b/doc/source/api.rst
@@ -562,10 +562,10 @@ following usable methods and properties (all available as ``Series.cat.<method_o
 .. autosummary::
    :toctree: generated/
 
-   Categorical.levels
+   Categorical.categories
    Categorical.ordered
-   Categorical.reorder_levels
-   Categorical.remove_unused_levels
+   Categorical.reorder_categories
+   Categorical.remove_unused_categories
 
 The following methods are considered API when using ``Categorical`` directly:
 
diff --git a/pandas/core/algorithms.py b/pandas/core/algorithms.py
index 8d1b15885..8c4f45fde 100644
--- a/pandas/core/algorithms.py
+++ b/pandas/core/algorithms.py
@@ -213,7 +213,7 @@ def value_counts(values, sort=True, ascending=False, normalize=False,
             raise TypeError("bins argument only works with numeric data.")
         values = cat.codes
     elif is_category:
-        bins = values.levels
+        bins = values.categories
         cat = values
         values = cat.codes
 
@@ -248,11 +248,11 @@ def value_counts(values, sort=True, ascending=False, normalize=False,
     result = Series(counts, index=com._values_from_object(keys))
     if bins is not None:
         # TODO: This next line should be more efficient
-        result = result.reindex(np.arange(len(cat.levels)), fill_value=0)
+        result = result.reindex(np.arange(len(cat.categories)), fill_value=0)
         if not is_category:
             result.index = bins[:-1]
         else:
-            result.index = cat.levels
+            result.index = cat.categories
 
     if sort:
         result.sort()
diff --git a/pandas/core/categorical.py b/pandas/core/categorical.py
index 565d886a2..9a35eb989 100644
--- a/pandas/core/categorical.py
+++ b/pandas/core/categorical.py
@@ -22,16 +22,17 @@ from pandas.core import format as fmt
 def _cat_compare_op(op):
     def f(self, other):
         # On python2, you can usually compare any type to any type, and Categoricals can be
-        # seen as a custom type, but having different results depending whether a level are
+        # seen as a custom type, but having different results depending whether categories are
         # the same or not is kind of insane, so be a bit stricter here and use the python3 idea
         # of comparing only things of equal type.
         if not self.ordered:
             if op in ['__lt__', '__gt__','__le__','__ge__']:
                 raise TypeError("Unordered Categoricals can only compare equality or not")
         if isinstance(other, Categorical):
-            # Two Categoricals can only be be compared if the levels are the same
-            if (len(self.levels) != len(other.levels)) or not ((self.levels == other.levels).all()):
-                raise TypeError("Categoricals can only be compared if 'levels' are the same")
+            # Two Categoricals can only be be compared if the categories are the same
+            if (len(self.categories) != len(other.categories)) or \
+                    not ((self.categories == other.categories).all()):
+                raise TypeError("Categoricals can only be compared if 'categories' are the same")
             if not (self.ordered == other.ordered):
                 raise TypeError("Categoricals can only be compared if 'ordered' is the same")
             na_mask = (self._codes == -1) | (other._codes == -1)
@@ -42,8 +43,8 @@ def _cat_compare_op(op):
                 ret[na_mask] = False
             return ret
         elif np.isscalar(other):
-            if other in self.levels:
-                i = self.levels.get_loc(other)
+            if other in self.categories:
+                i = self.categories.get_loc(other)
                 return getattr(self._codes, op)(i)
             else:
                 return np.repeat(False, len(self))
@@ -67,37 +68,37 @@ def _maybe_to_categorical(array):
     return array
 
 
-_codes_doc = """The level codes of this categorical.
+_codes_doc = """The category codes of this categorical.
 
 Level codes are an array if integer which are the positions of the real
-values in the levels array.
+values in the categories array.
 
 There is not setter, used the other categorical methods and the item setter on
 Categorical to change values in the categorical.
 """
 
-_levels_doc = """The levels of this categorical.
+_categories_doc = """The categories of this categorical.
 
-Setting assigns new values to each level (effectively a rename of
-each individual level).
+Setting assigns new values to each category (effectively a rename of
+each individual category).
 
 The assigned value has to be a list-like object. If the number of
-level-items is less than number of level-items in the current level,
-all level-items at a higher position are set to NaN. If the number of
-level-items is more that the current number of level-items, new
-(unused) levels are added at the end.
+category-items is less than number of category-items in the current category,
+all category-items at a higher position are set to NaN. If the number of
+category-items is more that the current number of category-items, new
+(unused) categories are added at the end.
 
-To add level-items in between, use `reorder_levels`.
+To add category-items in between, use `reorder_categories`.
 
 Raises
 ------
 ValueError
-    If the new levels do not validate as levels
+    If the new categories do not validate as categories
 
 See also
 --------
-Categorical.reorder_levels
-Categorical.remove_unused_levels
+Categorical.reorder_categories
+Categorical.remove_unused_categories
 """
 class Categorical(PandasObject):
 
@@ -105,21 +106,21 @@ class Categorical(PandasObject):
     Represents a categorical variable in classic R / S-plus fashion
 
     `Categoricals` can only take on only a limited, and usually fixed, number
-    of possible values (`levels`). In contrast to statistical categorical
+    of possible values (`categories`). In contrast to statistical categorical
     variables, a `Categorical` might have an order, but numerical operations
     (additions, divisions, ...) are not possible.
 
-    All values of the `Categorical` are either in `levels` or `np.nan`.
-    Assigning values outside of `levels` will raise a `ValueError`. Order is
-    defined by the order of the `levels`, not lexical order of the values.
+    All values of the `Categorical` are either in `categories` or `np.nan`.
+    Assigning values outside of `categories` will raise a `ValueError`. Order is
+    defined by the order of the `categories`, not lexical order of the values.
 
     Parameters
     ----------
     values : list-like
-        The values of the categorical. If levels are given, values not in levels will
+        The values of the categorical. If categories are given, values not in categories will
         be replaced with NaN.
-    levels : Index-like (unique), optional
-        The unique levels for this categorical. If not given, the levels are assumed
+    categories : Index-like (unique), optional
+        The unique categories for this categorical. If not given, the categories are assumed
         to be the unique values of values.
     ordered : boolean, optional
         Whether or not this categorical is treated as a ordered categorical. If not given,
@@ -130,43 +131,34 @@ class Categorical(PandasObject):
 
     Attributes
     ----------
-    levels : Index
-        The levels of this categorical
+    categories : Index
+        The categories of this categorical
     codes : ndarray
-        The codes (integer positions, which point to the levels) of this categorical, read only
+        The codes (integer positions, which point to the categories) of this categorical, read only.
     ordered : boolean
-        Whether or not this Categorical is ordered
+        Whether or not this Categorical is ordered.
     name : string
-        The name of this Categorical
+        The name of this Categorical.
 
     Raises
     ------
     ValueError
-        If the levels do not validate
+        If the categories do not validate.
     TypeError
-        If an explicit ``ordered=True`` is given but no `levels` and the `values` are not sortable
+        If an explicit ``ordered=True`` is given but no `categories` and the `values` are
+        not sortable.
 
 
     Examples
     --------
     >>> from pandas import Categorical
     >>> Categorical([1, 2, 3, 1, 2, 3])
-    1
-    2
-    3
-    1
-    2
-    3
-    Levels (3): Int64Index([1, 2, 3], dtype=int64), ordered
+    [1, 2, 3, 1, 2, 3]
+    Categories (3, int64): [1 < 2 < 3]
 
     >>> Categorical(['a', 'b', 'c', 'a', 'b', 'c'])
-    a
-    b
-    c
-    a
-    b
-    c
-    Levels (3): Index(['a', 'b', 'c'], dtype=object), ordered
+    [a, b, c, a, b, c]
+    Categories (3, object): [a < b < c]
 
     >>> a = Categorical(['a','b','c','a','b','c'], ['c', 'b', 'a'])
     >>> a.min()
@@ -182,7 +174,7 @@ class Categorical(PandasObject):
     """Whether or not this Categorical is ordered.
 
     Only ordered `Categoricals` can be sorted (according to the order
-    of the levels) and have a min and max value.
+    of the categories) and have a min and max value.
 
     See also
     --------
@@ -195,19 +187,30 @@ class Categorical(PandasObject):
     # For comparisons, so that numpy uses our implementation if the compare ops, which raise
     __array_priority__ = 1000
 
-    def __init__(self, values, levels=None, ordered=None, name=None, fastpath=False):
+    def __init__(self, values, categories=None, ordered=None, name=None, fastpath=False,
+                 levels=None):
 
         if fastpath:
             # fast path
             self._codes = values
             self.name = name
-            self.levels = levels
+            self.categories = categories
             self.ordered = ordered
             return
 
         if name is None:
             name = getattr(values, 'name', None)
 
+        # TODO: Remove after deprecation period in 2017/ after 0.18
+        if not levels is None:
+            warn("Creating a 'Categorical' with 'levels' is deprecated, use 'categories' instead",
+                 FutureWarning)
+            if categories is None:
+                categories = levels
+            else:
+                raise ValueError("Cannot pass in both 'categories' and (deprecated) 'levels', "
+                                 "use only 'categories'")
+
         # sanitize input
         if com.is_categorical_dtype(values):
 
@@ -215,8 +218,8 @@ class Categorical(PandasObject):
             cat = values
             if isinstance(values, com.ABCSeries):
                 cat = values.values
-            if levels is None:
-                levels = cat.levels
+            if categories is None:
+                categories = cat.categories
             if ordered is None:
                 ordered = cat.ordered
             values = values.__array__()
@@ -235,58 +238,58 @@ class Categorical(PandasObject):
                 values = _convert_to_list_like(values)
                 from pandas.core.series import _sanitize_array
                 # On list with NaNs, int values will be converted to float. Use "object" dtype
-                # to prevent this. In the end objects will be casted to int/... in the level
+                # to prevent this. In the end objects will be casted to int/... in the category
                 # assignment step.
                 dtype = 'object' if isnull(values).any() else None
                 values = _sanitize_array(values, None, dtype=dtype)
 
-        if levels is None:
+        if categories is None:
             try:
-                codes, levels = factorize(values, sort=True)
+                codes, categories = factorize(values, sort=True)
                 # If the underlying data structure was sortable, and the user doesn't want to
                 # "forget" this order, the categorical also is sorted/ordered
                 if ordered is None:
                     ordered = True
             except TypeError:
-                codes, levels = factorize(values, sort=False)
+                codes, categories = factorize(values, sort=False)
                 if ordered:
-                    # raise, as we don't have a sortable data structure and so the usershould
-                    # give us one by specifying levels
-                    raise TypeError("'values' is not ordered, please explicitly specify the level "
-                                    "order by passing in a level argument.")
+                    # raise, as we don't have a sortable data structure and so the user should
+                    # give us one by specifying categories
+                    raise TypeError("'values' is not ordered, please explicitly specify the "
+                                    "categories order by passing in a categories argument.")
         else:
-            # there were two ways if levels are present
+            # there were two ways if categories are present
             # - the old one, where each value is a int pointer to the levels array -> not anymore
             #   possible, but code outside of pandas could call us like that, so make some checks
-            # - the new one, where each value is also in the level array (or np.nan)
+            # - the new one, where each value is also in the categories array (or np.nan)
 
             # make sure that we always have the same type here, no matter what we get passed in
-            levels = self._validate_levels(levels)
+            categories = self._validate_categories(categories)
 
-            codes = _get_codes_for_values(values, levels)
+            codes = _get_codes_for_values(values, categories)
 
             # TODO: check for old style usage. These warnings should be removes after 0.18/ in 2016
-            if com.is_integer_dtype(values) and not com.is_integer_dtype(levels):
-                warn("Values and Levels have different dtypes. Did you mean to use\n"
-                     "'Categorical.from_codes(codes, levels)'?", RuntimeWarning)
+            if com.is_integer_dtype(values) and not com.is_integer_dtype(categories):
+                warn("Values and categories have different dtypes. Did you mean to use\n"
+                     "'Categorical.from_codes(codes, categories)'?", RuntimeWarning)
 
             if com.is_integer_dtype(values) and (codes == -1).all():
-                warn("None of the levels were found in values. Did you mean to use\n"
-                     "'Categorical.from_codes(codes, levels)'?", RuntimeWarning)
+                warn("None of the categories were found in values. Did you mean to use\n"
+                     "'Categorical.from_codes(codes, categories)'?", RuntimeWarning)
 
-            # if we got levels, we can assume that the order is intended
+            # if we got categories, we can assume that the order is intended
             # if ordered is unspecified
             if ordered is None:
                 ordered = True
 
         self.ordered = False if ordered is None else ordered
         self._codes = codes
-        self.levels = levels
+        self.categories = categories
         self.name = name
 
     def copy(self):
         """ Copy constructor. """
-        return Categorical(values=self._codes.copy(),levels=self.levels,
+        return Categorical(values=self._codes.copy(),categories=self.categories,
                            name=self.name, ordered=self.ordered, fastpath=True)
 
     @classmethod
@@ -299,17 +302,17 @@ class Categorical(PandasObject):
         Parameters
         ----------
         data : array-like
-            Can be an Index or array-like. The levels are assumed to be
+            Can be an Index or array-like. The categories are assumed to be
             the unique values of `data`.
         """
         return Categorical(data)
 
     @classmethod
-    def from_codes(cls, codes, levels, ordered=False, name=None):
+    def from_codes(cls, codes, categories, ordered=False, name=None):
         """
-        Make a Categorical type from codes and levels arrays.
+        Make a Categorical type from codes and categories arrays.
 
-        This constructor is useful if you already have codes and levels and so do not need the
+        This constructor is useful if you already have codes and categories and so do not need the
         (computation intensive) factorization step, which is usually done on the constructor.
 
         If your data does not follow this convention, please use the normal constructor.
@@ -317,9 +320,9 @@ class Categorical(PandasObject):
         Parameters
         ----------
         codes : array-like, integers
-            An integer array, where each integer points to a level in levels or -1 for NaN
-        levels : index-like
-            The levels for the categorical. Items need to be unique.
+            An integer array, where each integer points to a category in categories or -1 for NaN
+        categories : index-like
+            The categories for the categorical. Items need to be unique.
         ordered : boolean, optional
             Whether or not this categorical is treated as a ordered categorical. If not given,
             the resulting categorical will be unordered.
@@ -331,18 +334,18 @@ class Categorical(PandasObject):
         except:
             raise ValueError("codes need to be convertible to an arrays of integers")
 
-        levels = cls._validate_levels(levels)
+        categories = cls._validate_categories(categories)
 
-        if codes.max() >= len(levels) or codes.min() < -1:
-            raise ValueError("codes need to be between -1 and len(levels)-1")
+        if codes.max() >= len(categories) or codes.min() < -1:
+            raise ValueError("codes need to be between -1 and len(categories)-1")
 
 
-        return Categorical(codes, levels=levels, ordered=ordered, name=name, fastpath=True)
+        return Categorical(codes, categories=categories, ordered=ordered, name=name, fastpath=True)
 
     _codes = None
 
     def _get_codes(self):
-        """ Get the level codes.
+        """ Get the codes.
 
         Returns
         -------
@@ -362,7 +365,7 @@ class Categorical(PandasObject):
     codes = property(fget=_get_codes, fset=_set_codes, doc=_codes_doc)
 
     def _get_labels(self):
-        """ Get the level labels (deprecated).
+        """ Get the category labels (deprecated).
 
         Deprecated, use .codes!
         """
@@ -372,105 +375,115 @@ class Categorical(PandasObject):
 
     labels = property(fget=_get_labels, fset=_set_codes)
 
-    _levels = None
+    _categories = None
 
     @classmethod
-    def _validate_levels(cls, levels):
-        """" Validates that we have good levels """
-        if not isinstance(levels, Index):
+    def _validate_categories(cls, categories):
+        """" Validates that we have good categories """
+        if not isinstance(categories, Index):
             dtype = None
-            if not hasattr(levels, "dtype"):
-                levels = _convert_to_list_like(levels)
-                # on levels with NaNs, int values would be converted to float. Use "object" dtype
-                # to prevent this.
-                if isnull(levels).any():
-                    without_na = np.array([x for x in levels if com.notnull(x)])
-                    with_na = np.array(levels)
+            if not hasattr(categories, "dtype"):
+                categories = _convert_to_list_like(categories)
+                # on categories with NaNs, int values would be converted to float.
+                # Use "object" dtype to prevent this.
+                if isnull(categories).any():
+                    without_na = np.array([x for x in categories if com.notnull(x)])
+                    with_na = np.array(categories)
                     if with_na.dtype != without_na.dtype:
                         dtype = "object"
-            levels = Index(levels, dtype=dtype)
-        if not levels.is_unique:
-            raise ValueError('Categorical levels must be unique')
-        return levels
+            categories = Index(categories, dtype=dtype)
+        if not categories.is_unique:
+            raise ValueError('Categorical categories must be unique')
+        return categories
 
-    def _set_levels(self, levels):
-        """ Sets new levels """
-        levels = self._validate_levels(levels)
+    def _set_categories(self, categories):
+        """ Sets new categories """
+        categories = self._validate_categories(categories)
 
-        if not self._levels is None and len(levels) < len(self._levels):
+        if not self._categories is None and len(categories) < len(self._categories):
             # remove all _codes which are larger
-            self._codes[self._codes >= len(levels)] = -1
-        self._levels = levels
+            self._codes[self._codes >= len(categories)] = -1
+        self._categories = categories
+
+    def _get_categories(self):
+        """ Gets the categories """
+        # categories is an Index, which is immutable -> no need to copy
+        return self._categories
+
+    categories = property(fget=_get_categories, fset=_set_categories, doc=_categories_doc)
+
+    def _set_levels(self, levels):
+        """ set new levels (deprecated, use "categories") """
+        warn("Assigning to 'levels' is deprecated, use 'categories'", FutureWarning)
+        self.categories = levels
 
     def _get_levels(self):
-        """ Gets the levels """
-        # levels is an Index, which is immutable -> no need to copy
-        return self._levels
+        """ Gets the levels (deprecated, use "categories") """
+        warn("Accessing 'levels' is deprecated, use 'categories'", FutureWarning)
+        return self.categories
 
-    levels = property(fget=_get_levels, fset=_set_levels, doc=_levels_doc)
+    # TODO: Remove after deprecation period in 2017/ after 0.18
+    levels = property(fget=_get_levels, fset=_set_levels)
 
-    def reorder_levels(self, new_levels, ordered=None, inplace=False):
-        """ Reorders levels as specified in new_levels.
 
-        `new_levels` must include all old levels but can also include new level items. In
-        contrast to assigning to `levels`, these new level items can be in arbitrary positions.
+    def reorder_categories(self, new_categories, ordered=None, inplace=False):
+        """ Reorders categories as specified in new_categories.
 
-        The level reordering is done inplace.
+        `new_categories` do not need to include all old categories and can also include new
+        category items. All old categories not in new categories are replaced by NaN. In
+        contrast to assigning to `categories`, new category items can be in arbitrary positions.
 
         Raises
         ------
         ValueError
-            If the new levels do not contain all old level items
+            If the new categories do not contain all old category items
 
         Parameters
         ----------
-        new_levels : Index-like
-           The levels in new order. must be of same length as the old levels
+        new_categories : Index-like
+           The categories in new order.
         ordered : boolean, optional
            Whether or not the categorical is treated as a ordered categorical. If not given,
            do not change the ordered information.
         inplace : bool (default: False)
-           Whether or not to reorder the levels inplace or return a copy of this categorical with
-           reordered levels.
+           Whether or not to reorder the categories inplace or return a copy of this categorical
+           with reordered categories.
 
         Returns
         -------
-        cat : Categorical with reordered levels.
+        cat : Categorical with reordered categories or None if inplace.
         """
-        new_levels = self._validate_levels(new_levels)
-
-        if len(new_levels) < len(self._levels) or len(self._levels.difference(new_levels)):
-            raise ValueError('Reordered levels must include all original levels')
+        new_categories = self._validate_categories(new_categories)
 
         cat = self if inplace else self.copy()
         values = cat.__array__()
-        cat._codes = _get_codes_for_values(values, new_levels)
-        cat._levels = new_levels
+        cat._codes = _get_codes_for_values(values, new_categories)
+        cat._categories = new_categories
         if not ordered is None:
             cat.ordered = ordered
         if not inplace:
             return cat
 
-    def remove_unused_levels(self, inplace=False):
-        """ Removes levels which are not used.
+    def remove_unused_categories(self, inplace=False):
+        """ Removes categories which are not used.
 
         Parameters
         ----------
         inplace : bool (default: False)
-           Whether or not to drop unused levels inplace or return a copy of this categorical with
-           unused levels dropped.
+           Whether or not to drop unused categories inplace or return a copy of this categorical
+           with unused categories dropped.
 
         Returns
         -------
-        cat : Categorical with unused levels dropped.
+        cat : Categorical with unused categories dropped or None if inplace.
 
         """
         cat = self if inplace else self.copy()
         _used = sorted(np.unique(cat._codes))
-        new_levels = cat.levels.take(com._ensure_platform_int(_used))
-        new_levels = _ensure_index(new_levels)
-        cat._codes = _get_codes_for_values(cat.__array__(), new_levels)
-        cat._levels = new_levels
+        new_categories = cat.categories.take(com._ensure_platform_int(_used))
+        new_categories = _ensure_index(new_categories)
+        cat._codes = _get_codes_for_values(cat.__array__(), new_categories)
+        cat._categories = new_categories
         if not inplace:
             return cat
 
@@ -503,10 +516,10 @@ class Categorical(PandasObject):
         -------
         values : numpy array
             A numpy array of either the specified dtype or, if dtype==None (default), the same
-            dtype as categorical.levels.dtype
+            dtype as categorical.categories.dtype
         """
-        ret = com.take_1d(self.levels.values, self._codes)
-        if dtype and dtype != self.levels.dtype:
+        ret = com.take_1d(self.categories.values, self._codes)
+        if dtype and dtype != self.categories.dtype:
             return np.asarray(ret, dtype)
         return ret
 
@@ -518,7 +531,7 @@ class Categorical(PandasObject):
         """
         Detect missing values
 
-        Both missing values (-1 in .codes) and NA as a level are detected.
+        Both missing values (-1 in .codes) and NA as a category are detected.
 
         Returns
         -------
@@ -532,11 +545,11 @@ class Categorical(PandasObject):
 
         ret = self._codes == -1
 
-        # String/object and float levels can hold np.nan
-        if self.levels.dtype.kind in ['S', 'O', 'f']:
-            if np.nan in self.levels:
-                nan_pos = np.where(isnull(self.levels))[0]
-                # we only have one NA in levels
+        # String/object and float categories can hold np.nan
+        if self.categories.dtype.kind in ['S', 'O', 'f']:
+            if np.nan in self.categories:
+                nan_pos = np.where(isnull(self.categories))[0]
+                # we only have one NA in categories
                 ret = np.logical_or(ret , self._codes == nan_pos)
         return ret
 
@@ -544,7 +557,7 @@ class Categorical(PandasObject):
         """
         Reverse of isnull
 
-        Both missing values (-1 in .codes) and NA as a level are detected as null.
+        Both missing values (-1 in .codes) and NA as a category are detected as null.
 
         Returns
         -------
@@ -565,12 +578,13 @@ class Categorical(PandasObject):
         Returns
         -------
         values : numpy array
-            A numpy array of the same dtype as categorical.levels.dtype or dtype string if periods
+            A numpy array of the same dtype as categorical.categories.dtype or dtype string if
+            periods
         """
 
         # if we are a period index, return a string repr
-        if isinstance(self.levels, PeriodIndex):
-            return com.take_1d(np.array(self.levels.to_native_types(), dtype=object),
+        if isinstance(self.categories, PeriodIndex):
+            return com.take_1d(np.array(self.categories.to_native_types(), dtype=object),
                                self._codes)
 
         return np.array(self)
@@ -594,7 +608,7 @@ class Categorical(PandasObject):
         return result
 
     def order(self, inplace=False, ascending=True, na_position='last', **kwargs):
-        """ Sorts the Category by level value returning a new Categorical by default.
+        """ Sorts the Category by category value returning a new Categorical by default.
 
         Only ordered Categoricals can be sorted!
 
@@ -648,12 +662,12 @@ class Categorical(PandasObject):
             self._codes = codes
             return
         else:
-            return Categorical(values=codes,levels=self.levels, ordered=self.ordered,
+            return Categorical(values=codes,categories=self.categories, ordered=self.ordered,
                                name=self.name, fastpath=True)
 
 
     def sort(self, inplace=True, ascending=True, na_position='last', **kwargs):
-        """ Sorts the Category inplace by level value.
+        """ Sorts the Category inplace by category value.
 
         Only ordered Categoricals can be sorted!
 
@@ -739,12 +753,12 @@ class Categorical(PandasObject):
 
         values = self._codes
 
-        # Make sure that we also get NA in levels
-        if self.levels.dtype.kind in ['S', 'O', 'f']:
-            if np.nan in self.levels:
+        # Make sure that we also get NA in categories
+        if self.categories.dtype.kind in ['S', 'O', 'f']:
+            if np.nan in self.categories:
                 values = values.copy()
-                nan_pos = np.where(isnull(self.levels))[0]
-                # we only have one NA in levels
+                nan_pos = np.where(isnull(self.categories))[0]
+                # we only have one NA in categories
                 values[values == nan_pos] = -1
 
 
@@ -753,20 +767,20 @@ class Categorical(PandasObject):
 
             values = self.to_dense().reshape(-1,len(self))
             values = com.interpolate_2d(
-                values, method, 0, None, fill_value).astype(self.levels.dtype)[0]
-            values = _get_codes_for_values(values, self.levels)
+                values, method, 0, None, fill_value).astype(self.categories.dtype)[0]
+            values = _get_codes_for_values(values, self.categories)
 
         else:
 
-            if not com.isnull(fill_value) and fill_value not in self.levels:
-                raise ValueError("fill value must be in levels")
+            if not com.isnull(fill_value) and fill_value not in self.categories:
+                raise ValueError("fill value must be in categories")
 
             mask = values==-1
             if mask.any():
                 values = values.copy()
-                values[mask] = self.levels.get_loc(fill_value)
+                values[mask] = self.categories.get_loc(fill_value)
 
-        return Categorical(values, levels=self.levels, ordered=self.ordered,
+        return Categorical(values, categories=self.categories, ordered=self.ordered,
                            name=self.name, fastpath=True)
 
     def take_nd(self, indexer, allow_fill=True, fill_value=None):
@@ -780,7 +794,7 @@ class Categorical(PandasObject):
         assert isnull(fill_value)
 
         codes = com.take_1d(self._codes, indexer, allow_fill=True, fill_value=-1)
-        result = Categorical(codes, levels=self.levels, ordered=self.ordered,
+        result = Categorical(codes, categories=self.categories, ordered=self.ordered,
                              name=self.name, fastpath=True)
         return result
 
@@ -800,7 +814,7 @@ class Categorical(PandasObject):
             slicer = slicer[1]
 
         _codes = self._codes[slicer]
-        return Categorical(values=_codes,levels=self.levels, ordered=self.ordered,
+        return Categorical(values=_codes,categories=self.categories, ordered=self.ordered,
                            name=self.name, fastpath=True)
 
     def __len__(self):
@@ -823,21 +837,21 @@ class Categorical(PandasObject):
 
         return compat.text_type(result)
 
-    def _repr_level_info(self):
+    def _repr_categories_info(self):
         """ Returns a string representation of the footer."""
 
-        max_levels = (10 if get_option("display.max_levels") == 0
-                    else get_option("display.max_levels"))
-        level_strs = fmt.format_array(self.levels.get_values(), None)
-        if len(level_strs) > max_levels:
-            num = max_levels // 2
-            head = level_strs[:num]
-            tail = level_strs[-(max_levels - num):]
-            level_strs = head + ["..."] + tail
+        max_categories = (10 if get_option("display.max_categories") == 0
+                    else get_option("display.max_categories"))
+        category_strs = fmt.format_array(self.categories.get_values(), None)
+        if len(category_strs) > max_categories:
+            num = max_categories // 2
+            head = category_strs[:num]
+            tail = category_strs[-(max_categories - num):]
+            category_strs = head + ["..."] + tail
         # Strip all leading spaces, which format_array adds for columns...
-        level_strs = [x.strip() for x in level_strs]
-        levheader = "Levels (%d, %s): " % (len(self.levels),
-                                               self.levels.dtype)
+        category_strs = [x.strip() for x in category_strs]
+        levheader = "Categories (%d, %s): " % (len(self.categories),
+                                               self.categories.dtype)
         width, height = get_terminal_size()
         max_width = (width if get_option("display.width") == 0
                     else get_option("display.width"))
@@ -848,7 +862,7 @@ class Categorical(PandasObject):
         start = True
         cur_col_len = len(levheader)
         sep_len, sep = (3, " < ") if self.ordered else (2, ", ")
-        for val in level_strs:
+        for val in category_strs:
             if max_width != 0 and cur_col_len + sep_len + len(val) > max_width:
                 levstring += "\n" + (" "* len(levheader))
                 cur_col_len = len(levheader)
@@ -864,7 +878,7 @@ class Categorical(PandasObject):
 
         namestr = "Name: %s, " % self.name if self.name is not None else ""
         return u('%sLength: %d\n%s') % (namestr,
-                                       len(self), self._repr_level_info())
+                                       len(self), self._repr_categories_info())
 
     def _get_repr(self, name=False, length=True, na_rep='NaN', footer=True):
         formatter = fmt.CategoricalFormatter(self, name=name,
@@ -896,9 +910,9 @@ class Categorical(PandasObject):
             if i == -1:
                 return np.nan
             else:
-                return self.levels[i]
+                return self.categories[i]
         else:
-            return Categorical(values=self._codes[key], levels=self.levels,
+            return Categorical(values=self._codes[key], categories=self.categories,
                                ordered=self.ordered, fastpath=True)
 
     def __setitem__(self, key, value):
@@ -908,22 +922,23 @@ class Categorical(PandasObject):
         Raises
         ------
         ValueError
-            If (one or more) Value is not in levels or if a assigned `Categorical` has not the
-            same levels
+            If (one or more) Value is not in categories or if a assigned `Categorical` has not the
+            same categories
 
         """
 
-        # require identical level set
+        # require identical categories set
         if isinstance(value, Categorical):
-            if not value.levels.equals(self.levels):
-                raise ValueError("cannot set a Categorical with another, without identical levels")
+            if not value.categories.equals(self.categories):
+                raise ValueError("Cannot set a Categorical with another, without identical "
+                                 "categories")
 
         rvalue = value if com.is_list_like(value) else [value]
-        to_add = Index(rvalue).difference(self.levels)
-        # no assignments of values not in levels, but it's always ok to set something to np.nan
+        to_add = Index(rvalue).difference(self.categories)
+        # no assignments of values not in categories, but it's always ok to set something to np.nan
         if len(to_add) and not isnull(to_add).all():
-            raise ValueError("cannot setitem on a Categorical with a new level,"
-                             " set the levels first")
+            raise ValueError("cannot setitem on a Categorical with a new category,"
+                             " set the categories first")
 
         # set by position
         if isinstance(key, (int, np.integer)):
@@ -954,14 +969,14 @@ class Categorical(PandasObject):
             # FIXME: remove when numpy 1.9 is the lowest numpy version pandas accepts...
             key = np.asarray(key)
 
-        lindexer = self.levels.get_indexer(rvalue)
+        lindexer = self.categories.get_indexer(rvalue)
 
         # FIXME: the following can be removed after https://github.com/pydata/pandas/issues/7820
         # is fixed.
-        # float levels do currently return -1 for np.nan, even if np.nan is included in the index
-        # "repair" this here
-        if isnull(rvalue).any() and isnull(self.levels).any():
-            nan_pos = np.where(com.isnull(self.levels))[0]
+        # float categories do currently return -1 for np.nan, even if np.nan is included in the
+        # index -> "repair" this here
+        if isnull(rvalue).any() and isnull(self.categories).any():
+            nan_pos = np.where(com.isnull(self.categories))[0]
             lindexer[lindexer == -1] = nan_pos
 
         self._codes[key] = lindexer
@@ -999,7 +1014,7 @@ class Categorical(PandasObject):
         if pointer == -1:
             return np.nan
         else:
-            return self.levels[pointer]
+            return self.categories[pointer]
 
 
     def max(self, numeric_only=None, **kwargs):
@@ -1026,7 +1041,7 @@ class Categorical(PandasObject):
         if pointer == -1:
             return np.nan
         else:
-            return self.levels[pointer]
+            return self.categories[pointer]
 
     def mode(self):
         """
@@ -1043,7 +1058,7 @@ class Categorical(PandasObject):
         import pandas.hashtable as htable
         good = self._codes != -1
         result = Categorical(sorted(htable.mode_int64(com._ensure_int64(self._codes[good]))),
-                             levels=self.levels,ordered=self.ordered, name=self.name,
+                             categories=self.categories,ordered=self.ordered, name=self.name,
                              fastpath=True)
         return result
 
@@ -1051,13 +1066,13 @@ class Categorical(PandasObject):
         """
         Return the unique values.
 
-        This includes all levels, even if one or more is unused.
+        This includes all categories, even if one or more is unused.
 
         Returns
         -------
         unique values : array
         """
-        return np.asarray(self.levels)
+        return np.asarray(self.categories)
 
     def equals(self, other):
         """
@@ -1076,7 +1091,7 @@ class Categorical(PandasObject):
         if not isinstance(other, Categorical):
             return False
         # TODO: should this also test if name is equal?
-        return (self.levels.equals(other.levels) and self.ordered == other.ordered and
+        return (self.categories.equals(other.categories) and self.ordered == other.ordered and
                 np.array_equal(self._codes, other._codes))
 
     def describe(self):
@@ -1085,7 +1100,7 @@ class Categorical(PandasObject):
         Returns
         -------
         description: `DataFrame`
-            A dataframe with frequency and counts by level.
+            A dataframe with frequency and counts by category.
         """
         # Hack?
         from pandas.core.frame import DataFrame
@@ -1100,22 +1115,22 @@ class Categorical(PandasObject):
         result = concat([counts,freqs],axis=1)
         result.columns = ['counts','freqs']
 
-        # fill in the real levels
+        # fill in the real categories
         check = result.index == -1
         if check.any():
             # Sort -1 (=NaN) to the last position
-            index = np.arange(0, len(self.levels)+1, dtype='int64')
+            index = np.arange(0, len(self.categories)+1, dtype='int64')
             index[-1] = -1
             result = result.reindex(index)
             # build new index
-            levels = np.arange(0,len(self.levels)+1 ,dtype=object)
-            levels[:-1] = self.levels
-            levels[-1] = np.nan
-            result.index = levels.take(com._ensure_platform_int(result.index))
+            categories = np.arange(0,len(self.categories)+1 ,dtype=object)
+            categories[:-1] = self.categories
+            categories[-1] = np.nan
+            result.index = categories.take(com._ensure_platform_int(result.index))
         else:
-            result.index = self.levels.take(com._ensure_platform_int(result.index))
-            result = result.reindex(self.levels)
-        result.index.name = 'levels'
+            result.index = self.categories.take(com._ensure_platform_int(result.index))
+            result = result.reindex(self.categories)
+        result.index.name = 'categories'
 
         return result
 
@@ -1127,9 +1142,9 @@ class CategoricalAccessor(PandasDelegate):
 
     Examples
     --------
-    >>> s.cat.levels
-    >>> s.cat.levels = list('abc')
-    >>> s.cat.reorder_levels(list('cab'))
+    >>> s.cat.categories
+    >>> s.cat.categories = list('abc')
+    >>> s.cat.reorder_categories(list('cab'))
 
     Allows accessing to specific getter and access methods
     """
@@ -1156,27 +1171,29 @@ class CategoricalAccessor(PandasDelegate):
         if not res is None:
             return Series(res, index=self.index)
 
+# TODO: remove levels after the deprecation period
 CategoricalAccessor._add_delegate_accessors(delegate=Categorical,
-                                              accessors=["levels", "ordered"],
-                                              typ='property')
+                                            accessors=["categories", "ordered"],
+                                            typ='property')
 CategoricalAccessor._add_delegate_accessors(delegate=Categorical,
-                                              accessors=["reorder_levels", "remove_unused_levels"],
-                                              typ='method')
+                                            accessors=["reorder_categories",
+                                                       "remove_unused_categories"],
+                                            typ='method')
 
 ##### utility routines #####
 
-def _get_codes_for_values(values, levels):
+def _get_codes_for_values(values, categories):
     """"
-    utility routine to turn values into codes given the specified levels
+    utility routine to turn values into codes given the specified categories
     """
 
     from pandas.core.algorithms import _get_data_algo, _hashtables
-    if values.dtype != levels.dtype:
+    if values.dtype != categories.dtype:
         values = com._ensure_object(values)
-        levels = com._ensure_object(levels)
+        categories = com._ensure_object(categories)
     (hash_klass, vec_klass), vals = _get_data_algo(values, _hashtables)
-    t = hash_klass(len(levels))
-    t.map_locations(com._values_from_object(levels))
+    t = hash_klass(len(categories))
+    t.map_locations(com._values_from_object(categories))
     return com._ensure_platform_int(t.lookup(values))
 
 def _convert_to_list_like(list_like):
diff --git a/pandas/core/config_init.py b/pandas/core/config_init.py
index 837926653..1d93b9d5e 100644
--- a/pandas/core/config_init.py
+++ b/pandas/core/config_init.py
@@ -59,10 +59,10 @@ pc_max_cols_doc = """
     correct auto-detection.
 """
 
-pc_max_levels_doc = """
+pc_max_categories_doc = """
 : int
-    This sets the maximum number of levels pandas should output when printing
-    out a `Categorical`.
+    This sets the maximum number of categories pandas should output when printing
+    out a `Categorical` or a Series of dtype "category".
 """
 
 pc_max_info_cols_doc = """
@@ -237,7 +237,7 @@ with cf.config_prefix('display'):
                        validator=is_instance_factory((int, type(None))))
     cf.register_option('max_rows', 60, pc_max_rows_doc,
                        validator=is_instance_factory([type(None), int]))
-    cf.register_option('max_levels', 8, pc_max_levels_doc, validator=is_int)
+    cf.register_option('max_categories', 8, pc_max_categories_doc, validator=is_int)
     cf.register_option('max_colwidth', 50, max_colwidth_doc, validator=is_int)
     cf.register_option('max_columns', 20, pc_max_cols_doc,
                        validator=is_instance_factory([type(None), int]))
diff --git a/pandas/core/format.py b/pandas/core/format.py
index 951559e6e..2773cc0c1 100644
--- a/pandas/core/format.py
+++ b/pandas/core/format.py
@@ -90,7 +90,7 @@ class CategoricalFormatter(object):
                 footer += ', '
             footer += "Length: %d" % len(self.categorical)
 
-        level_info = self.categorical._repr_level_info()
+        level_info = self.categorical._repr_categories_info()
 
         # Levels are added in a newline
         if footer:
@@ -176,7 +176,7 @@ class SeriesFormatter(object):
         # level infos are added to the end and in a new line, like it is done for Categoricals
         # Only added when we request a name
         if self.name and com.is_categorical_dtype(self.series.dtype):
-            level_info = self.series.values._repr_level_info()
+            level_info = self.series.values._repr_categories_info()
             if footer:
                 footer += "\n"
             footer += level_info
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index fb538e7cb..db04f4933 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -1924,7 +1924,7 @@ class Grouping(object):
                 self.grouper = np.asarray(factor)
 
                 self._labels = factor.codes
-                self._group_index = factor.levels
+                self._group_index = factor.categories
                 if self.name is None:
                     self.name = factor.name
 
@@ -3545,7 +3545,7 @@ def _lexsort_indexer(keys, orders=None, na_position='last'):
         if na_position not in ['last','first']:
             raise ValueError('invalid na_position: {!r}'.format(na_position))
 
-        n = len(c.levels)
+        n = len(c.categories)
         codes = c.codes.copy()
 
         mask = (c.codes == -1)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 23f4cfd44..b58546da0 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -3206,7 +3206,7 @@ class MultiIndex(Index):
             return Index(arrays[0], name=name)
 
         cats = [Categorical.from_array(arr) for arr in arrays]
-        levels = [c.levels for c in cats]
+        levels = [c.categories for c in cats]
         labels = [c.codes for c in cats]
         if names is None:
             names = [c.name for c in cats]
@@ -3301,7 +3301,7 @@ class MultiIndex(Index):
         categoricals = [Categorical.from_array(it) for it in iterables]
         labels = cartesian_product([c.codes for c in categoricals])
 
-        return MultiIndex(levels=[c.levels for c in categoricals],
+        return MultiIndex(levels=[c.categories for c in categoricals],
                           labels=labels, sortorder=sortorder, names=names)
 
     @property
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 053b92b2a..0055947c5 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -1698,12 +1698,12 @@ class CategoricalBlock(NonConsolidatableMixIn, ObjectBlock):
         return the block concatenation
         """
 
-        levels = self.values.levels
+        categories = self.values.categories
         for b in blocks:
-            if not levels.equals(b.values.levels):
+            if not categories.equals(b.values.categories):
                 raise ValueError("incompatible levels in categorical block merge")
 
-        return self._holder(values[0], levels=levels)
+        return self._holder(values[0], categories=categories)
 
     def to_native_types(self, slicer=None, na_rep='', **kwargs):
         """ convert to our native types format, slicing if desired """
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 95d279add..686a0c4f6 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -99,7 +99,7 @@ def panel_index(time, panels, names=['time', 'panel']):
     panel_factor = Categorical.from_array(panels)
 
     labels = [time_factor.codes, panel_factor.codes]
-    levels = [time_factor.levels, panel_factor.levels]
+    levels = [time_factor.categories, panel_factor.categories]
     return MultiIndex(levels, labels, sortorder=None, names=names,
                       verify_integrity=False)
 
diff --git a/pandas/core/reshape.py b/pandas/core/reshape.py
index 458f67253..bb6f6f4d0 100644
--- a/pandas/core/reshape.py
+++ b/pandas/core/reshape.py
@@ -1113,7 +1113,7 @@ def get_dummies(data, prefix=None, prefix_sep='_', dummy_na=False,
 def _get_dummies_1d(data, prefix, prefix_sep='_', dummy_na=False):
     # Series avoids inconsistent NaN handling
     cat = Categorical.from_array(Series(data))
-    levels = cat.levels
+    levels = cat.categories
 
     # if all NaN
     if not dummy_na and len(levels) == 0:
@@ -1130,7 +1130,7 @@ def _get_dummies_1d(data, prefix, prefix_sep='_', dummy_na=False):
     dummy_mat = np.eye(number_of_cols).take(cat.codes, axis=0)
 
     if dummy_na:
-        levels = np.append(cat.levels, np.nan)
+        levels = np.append(cat.categories, np.nan)
     else:
         # reset NaN GH4446
         dummy_mat[cat.codes == -1] = 0
@@ -1182,7 +1182,7 @@ def make_axis_dummies(frame, axis='minor', transform=None):
         mapped_items = items.map(transform)
         cat = Categorical.from_array(mapped_items.take(labels))
         labels = cat.codes
-        items = cat.levels
+        items = cat.categories
 
     values = np.eye(len(items), dtype=float)
     values = values.take(labels, axis=0)
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 9a55ed789..f77d3a60a 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -922,7 +922,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
 
         # Categorical
         if com.is_categorical_dtype(self.dtype):
-            level_info = self.values._repr_level_info()
+            level_info = self.values._repr_categories_info()
             return u('%sLength: %d, dtype: %s\n%s') % (namestr,
                                                        len(self),
                                                        str(self.dtype.name),
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 5a68cb16f..50b279dbe 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -3522,8 +3522,8 @@ class LegacyTable(Table):
             return None
 
         factors = [Categorical.from_array(a.values) for a in self.index_axes]
-        levels = [f.levels for f in factors]
-        N = [len(f.levels) for f in factors]
+        levels = [f.categories for f in factors]
+        N = [len(f.categories) for f in factors]
         labels = [f.codes for f in factors]
 
         # compute the key
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index 4f72c0d1c..047197124 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -4541,7 +4541,7 @@ class TestHDFStore(tm.TestCase):
 
         with ensure_clean_store(self.path) as store:
 
-            s = Series(Categorical(['a', 'b', 'b', 'a', 'a', 'c'], levels=['a','b','c','d']))
+            s = Series(Categorical(['a', 'b', 'b', 'a', 'a', 'c'], categories=['a','b','c','d']))
 
             self.assertRaises(NotImplementedError, store.put, 's_fixed', s, format='fixed')
             self.assertRaises(NotImplementedError, store.append, 's_table', s, format='table')
diff --git a/pandas/tests/test_categorical.py b/pandas/tests/test_categorical.py
index eb1acdeb7..c29deeecd 100644
--- a/pandas/tests/test_categorical.py
+++ b/pandas/tests/test_categorical.py
@@ -43,12 +43,12 @@ class TestCategorical(tm.TestCase):
         exp_arr = np.array(["a", "b", "c", "a", "b", "c"])
         c1 = Categorical(exp_arr)
         self.assert_numpy_array_equal(c1.__array__(), exp_arr)
-        c2 = Categorical(exp_arr, levels=["a","b","c"])
+        c2 = Categorical(exp_arr, categories=["a","b","c"])
         self.assert_numpy_array_equal(c2.__array__(), exp_arr)
-        c2 = Categorical(exp_arr, levels=["c","b","a"])
+        c2 = Categorical(exp_arr, categories=["c","b","a"])
         self.assert_numpy_array_equal(c2.__array__(), exp_arr)
 
-        # levels must be unique
+        # categories must be unique
         def f():
             Categorical([1,2], [1,2,2])
         self.assertRaises(ValueError, f)
@@ -65,25 +65,25 @@ class TestCategorical(tm.TestCase):
         c2 = Categorical(c1)
         self.assertTrue(c1.equals(c2))
 
-        c1 = Categorical(["a", "b", "c", "a"], levels=["a","b","c","d"])
+        c1 = Categorical(["a", "b", "c", "a"], categories=["a","b","c","d"])
         c2 = Categorical(c1)
         self.assertTrue(c1.equals(c2))
 
-        c1 = Categorical(["a", "b", "c", "a"], levels=["a","c","b"])
+        c1 = Categorical(["a", "b", "c", "a"], categories=["a","c","b"])
         c2 = Categorical(c1)
         self.assertTrue(c1.equals(c2))
 
-        c1 = Categorical(["a", "b", "c", "a"], levels=["a","c","b"])
-        c2 = Categorical(c1, levels=["a","b","c"])
+        c1 = Categorical(["a", "b", "c", "a"], categories=["a","c","b"])
+        c2 = Categorical(c1, categories=["a","b","c"])
         self.assert_numpy_array_equal(c1.__array__(), c2.__array__())
-        self.assert_numpy_array_equal(c2.levels, np.array(["a","b","c"]))
+        self.assert_numpy_array_equal(c2.categories, np.array(["a","b","c"]))
 
         # Series of dtype category
-        c1 = Categorical(["a", "b", "c", "a"], levels=["a","b","c","d"])
+        c1 = Categorical(["a", "b", "c", "a"], categories=["a","b","c","d"])
         c2 = Categorical(Series(c1))
         self.assertTrue(c1.equals(c2))
 
-        c1 = Categorical(["a", "b", "c", "a"], levels=["a","c","b"])
+        c1 = Categorical(["a", "b", "c", "a"], categories=["a","c","b"])
         c2 = Categorical(Series(c1))
         self.assertTrue(c1.equals(c2))
 
@@ -92,79 +92,79 @@ class TestCategorical(tm.TestCase):
         c2 = Categorical(Series(["a", "b", "c", "a"]))
         self.assertTrue(c1.equals(c2))
 
-        c1 = Categorical(["a", "b", "c", "a"], levels=["a","b","c","d"])
-        c2 = Categorical(Series(["a", "b", "c", "a"]), levels=["a","b","c","d"])
+        c1 = Categorical(["a", "b", "c", "a"], categories=["a","b","c","d"])
+        c2 = Categorical(Series(["a", "b", "c", "a"]), categories=["a","b","c","d"])
         self.assertTrue(c1.equals(c2))
 
-        # This should result in integer levels, not float!
-        cat = pd.Categorical([1,2,3,np.nan], levels=[1,2,3])
-        self.assertTrue(com.is_integer_dtype(cat.levels))
+        # This should result in integer categories, not float!
+        cat = pd.Categorical([1,2,3,np.nan], categories=[1,2,3])
+        self.assertTrue(com.is_integer_dtype(cat.categories))
 
         # https://github.com/pydata/pandas/issues/3678
         cat = pd.Categorical([np.nan,1, 2, 3])
-        self.assertTrue(com.is_integer_dtype(cat.levels))
+        self.assertTrue(com.is_integer_dtype(cat.categories))
 
         # this should result in floats
         cat = pd.Categorical([np.nan, 1, 2., 3 ])
-        self.assertTrue(com.is_float_dtype(cat.levels))
+        self.assertTrue(com.is_float_dtype(cat.categories))
 
         cat = pd.Categorical([np.nan, 1., 2., 3. ])
-        self.assertTrue(com.is_float_dtype(cat.levels))
+        self.assertTrue(com.is_float_dtype(cat.categories))
 
-        # preserve int as far as possible by converting to object if NaN is in levels
-        cat = pd.Categorical([np.nan, 1, 2, 3], levels=[np.nan, 1, 2, 3])
-        self.assertTrue(com.is_object_dtype(cat.levels))
+        # preserve int as far as possible by converting to object if NaN is in categories
+        cat = pd.Categorical([np.nan, 1, 2, 3], categories=[np.nan, 1, 2, 3])
+        self.assertTrue(com.is_object_dtype(cat.categories))
         # This doesn't work -> this would probably need some kind of "remember the original type"
         # feature to try to cast the array interface result to...
         #vals = np.asarray(cat[cat.notnull()])
         #self.assertTrue(com.is_integer_dtype(vals))
-        cat = pd.Categorical([np.nan,"a", "b", "c"], levels=[np.nan,"a", "b", "c"])
-        self.assertTrue(com.is_object_dtype(cat.levels))
+        cat = pd.Categorical([np.nan,"a", "b", "c"], categories=[np.nan,"a", "b", "c"])
+        self.assertTrue(com.is_object_dtype(cat.categories))
         # but don't do it for floats
-        cat = pd.Categorical([np.nan, 1., 2., 3.], levels=[np.nan, 1., 2., 3.])
-        self.assertTrue(com.is_float_dtype(cat.levels))
+        cat = pd.Categorical([np.nan, 1., 2., 3.], categories=[np.nan, 1., 2., 3.])
+        self.assertTrue(com.is_float_dtype(cat.categories))
 
 
         # corner cases
         cat = pd.Categorical([1])
-        self.assertTrue(len(cat.levels) == 1)
-        self.assertTrue(cat.levels[0] == 1)
+        self.assertTrue(len(cat.categories) == 1)
+        self.assertTrue(cat.categories[0] == 1)
         self.assertTrue(len(cat.codes) == 1)
         self.assertTrue(cat.codes[0] == 0)
 
         cat = pd.Categorical(["a"])
-        self.assertTrue(len(cat.levels) == 1)
-        self.assertTrue(cat.levels[0] == "a")
+        self.assertTrue(len(cat.categories) == 1)
+        self.assertTrue(cat.categories[0] == "a")
         self.assertTrue(len(cat.codes) == 1)
         self.assertTrue(cat.codes[0] == 0)
 
         # Scalars should be converted to lists
         cat = pd.Categorical(1)
-        self.assertTrue(len(cat.levels) == 1)
-        self.assertTrue(cat.levels[0] == 1)
+        self.assertTrue(len(cat.categories) == 1)
+        self.assertTrue(cat.categories[0] == 1)
         self.assertTrue(len(cat.codes) == 1)
         self.assertTrue(cat.codes[0] == 0)
 
-        cat = pd.Categorical([1], levels=1)
-        self.assertTrue(len(cat.levels) == 1)
-        self.assertTrue(cat.levels[0] == 1)
+        cat = pd.Categorical([1], categories=1)
+        self.assertTrue(len(cat.categories) == 1)
+        self.assertTrue(cat.categories[0] == 1)
         self.assertTrue(len(cat.codes) == 1)
         self.assertTrue(cat.codes[0] == 0)
 
-        # Catch old style constructor useage: two arrays, codes + levels
+        # Catch old style constructor useage: two arrays, codes + categories
         # We can only catch two cases:
         #  - when the first is an integer dtype and the second is not
         #  - when the resulting codes are all -1/NaN
         with tm.assert_produces_warning(RuntimeWarning):
-            c_old = Categorical([0,1,2,0,1,2], levels=["a","b","c"])
+            c_old = Categorical([0,1,2,0,1,2], categories=["a","b","c"])
 
         with tm.assert_produces_warning(RuntimeWarning):
-            c_old = Categorical([0,1,2,0,1,2], levels=[3,4,5])
+            c_old = Categorical([0,1,2,0,1,2], categories=[3,4,5])
 
         # the next one are from the old docs, but unfortunately these don't trigger :-(
         with tm.assert_produces_warning(None):
             c_old2 = Categorical([0, 1, 2, 0, 1, 2], [1, 2, 3])
-            cat = Categorical([1,2], levels=[1,2,3])
+            cat = Categorical([1,2], categories=[1,2,3])
 
     def test_constructor_with_generator(self):
         # This was raising an Error in isnull(single_val).any() because isnull returned a scalar
@@ -181,16 +181,16 @@ class TestCategorical(tm.TestCase):
         from pandas.core.index import MultiIndex
         MultiIndex.from_product([range(5), ['a', 'b', 'c']])
 
-        # check that levels accept generators and sequences
-        cat = pd.Categorical([0,1,2], levels=(x for x in [0,1,2]))
+        # check that categories accept generators and sequences
+        cat = pd.Categorical([0,1,2], categories=(x for x in [0,1,2]))
         self.assertTrue(cat.equals(exp))
-        cat = pd.Categorical([0,1,2], levels=xrange(3))
+        cat = pd.Categorical([0,1,2], categories=xrange(3))
         self.assertTrue(cat.equals(exp))
 
 
     def test_from_codes(self):
 
-        # too few levels
+        # too few categories
         def f():
             Categorical.from_codes([1,2], [1,2])
         self.assertRaises(ValueError, f)
@@ -200,7 +200,7 @@ class TestCategorical(tm.TestCase):
             Categorical.from_codes(["a"], [1,2])
         self.assertRaises(ValueError, f)
 
-        # no unique levels
+        # no unique categories
         def f():
             Categorical.from_codes([0,1,2], ["a","a","b"])
         self.assertRaises(ValueError, f)
@@ -218,7 +218,7 @@ class TestCategorical(tm.TestCase):
         # Not available in earlier numpy versions
         if hasattr(np.random, "choice"):
             codes = np.random.choice([0,1], 5, p=[0.9,0.1])
-            pd.Categorical.from_codes(codes, levels=["train", "test"])
+            pd.Categorical.from_codes(codes, categories=["train", "test"])
 
     def test_comparisons(self):
         result = self.factor[self.factor == 'a']
@@ -257,12 +257,12 @@ class TestCategorical(tm.TestCase):
         self.assert_numpy_array_equal(result, expected)
 
         # comparisons with categoricals
-        cat_rev = pd.Categorical(["a","b","c"], levels=["c","b","a"])
-        cat_rev_base = pd.Categorical(["b","b","b"], levels=["c","b","a"])
+        cat_rev = pd.Categorical(["a","b","c"], categories=["c","b","a"])
+        cat_rev_base = pd.Categorical(["b","b","b"], categories=["c","b","a"])
         cat = pd.Categorical(["a","b","c"])
-        cat_base = pd.Categorical(["b","b","b"], levels=cat.levels)
+        cat_base = pd.Categorical(["b","b","b"], categories=cat.categories)
 
-        # comparisons need to take level ordering into account
+        # comparisons need to take categories ordering into account
         res_rev = cat_rev > cat_rev_base
         exp_rev = np.array([True, False, False])
         self.assert_numpy_array_equal(res_rev, exp_rev)
@@ -275,12 +275,12 @@ class TestCategorical(tm.TestCase):
         exp = np.array([False, False, True])
         self.assert_numpy_array_equal(res, exp)
 
-        # Only categories with same levels can be compared
+        # Only categories with same categories can be compared
         def f():
             cat > cat_rev
         self.assertRaises(TypeError, f)
 
-        cat_rev_base2 = pd.Categorical(["b","b","b"], levels=["c","b","a","d"])
+        cat_rev_base2 = pd.Categorical(["b","b","b"], categories=["c","b","a","d"])
         def f():
             cat_rev > cat_rev_base2
         self.assertRaises(TypeError, f)
@@ -312,19 +312,19 @@ class TestCategorical(tm.TestCase):
             self.assertRaises(TypeError, lambda: a < cat)
             self.assertRaises(TypeError, lambda: a < cat_rev)
 
-    def test_na_flags_int_levels(self):
+    def test_na_flags_int_categories(self):
         # #1457
 
-        levels = lrange(10)
+        categories = lrange(10)
         labels = np.random.randint(0, 10, 20)
         labels[::5] = -1
 
-        cat = Categorical(labels, levels, fastpath=True)
+        cat = Categorical(labels, categories, fastpath=True)
         repr(cat)
 
         self.assert_numpy_array_equal(com.isnull(cat), labels == -1)
 
-    def test_levels_none(self):
+    def test_categories_none(self):
         factor = Categorical(['a', 'b', 'b', 'a',
                               'a', 'c', 'c', 'c'])
         self.assertTrue(factor.equals(self.factor))
@@ -334,27 +334,27 @@ class TestCategorical(tm.TestCase):
         desc = self.factor.describe()
         expected = DataFrame.from_dict(dict(counts=[3, 2, 3],
                                             freqs=[3/8., 2/8., 3/8.],
-                                            levels=['a', 'b', 'c'])
-                                            ).set_index('levels')
+                                            categories=['a', 'b', 'c'])
+                                            ).set_index('categories')
         tm.assert_frame_equal(desc, expected)
 
-        # check unused levels
+        # check unused categories
         cat = self.factor.copy()
-        cat.levels = ["a","b","c","d"]
+        cat.categories = ["a","b","c","d"]
         desc = cat.describe()
         expected = DataFrame.from_dict(dict(counts=[3, 2, 3, np.nan],
                                             freqs=[3/8., 2/8., 3/8., np.nan],
-                                            levels=['a', 'b', 'c', 'd'])
-                                            ).set_index('levels')
+                                            categories=['a', 'b', 'c', 'd'])
+                                            ).set_index('categories')
         tm.assert_frame_equal(desc, expected)
 
         # check an integer one
         desc = Categorical([1,2,3,1,2,3,3,2,1,1,1]).describe()
         expected = DataFrame.from_dict(dict(counts=[5, 3, 3],
                                             freqs=[5/11., 3/11., 3/11.],
-                                            levels=[1,2,3]
+                                            categories=[1,2,3]
                                             )
-                                            ).set_index('levels')
+                                            ).set_index('categories')
         tm.assert_frame_equal(desc, expected)
 
         # https://github.com/pydata/pandas/issues/3678
@@ -363,44 +363,44 @@ class TestCategorical(tm.TestCase):
         desc = cat.describe()
         expected = DataFrame.from_dict(dict(counts=[1, 2, 1],
                                             freqs=[1/4., 2/4., 1/4.],
-                                            levels=[1,2,np.nan]
+                                            categories=[1,2,np.nan]
                                             )
-                                            ).set_index('levels')
+                                            ).set_index('categories')
         tm.assert_frame_equal(desc, expected)
 
-        # having NaN as level and as "not available" should also print two NaNs in describe!
+        # having NaN as category and as "not available" should also print two NaNs in describe!
         cat = pd.Categorical([np.nan,1, 2, 2])
-        cat.levels = [1,2,np.nan]
+        cat.categories = [1,2,np.nan]
         desc = cat.describe()
         expected = DataFrame.from_dict(dict(counts=[1, 2, np.nan, 1],
                                             freqs=[1/4., 2/4., np.nan, 1/4.],
-                                            levels=[1,2,np.nan,np.nan]
+                                            categories=[1,2,np.nan,np.nan]
                                             )
-                                            ).set_index('levels')
+                                            ).set_index('categories')
         tm.assert_frame_equal(desc, expected)
 
-        # empty levels show up as NA
-        cat = Categorical(["a","b","b","b"], levels=['a','b','c'], ordered=True)
+        # empty categories show up as NA
+        cat = Categorical(["a","b","b","b"], categories=['a','b','c'], ordered=True)
         result = cat.describe()
 
         expected = DataFrame([[1,0.25],[3,0.75],[np.nan,np.nan]],
                              columns=['counts','freqs'],
-                             index=Index(['a','b','c'],name='levels'))
+                             index=Index(['a','b','c'],name='categories'))
         tm.assert_frame_equal(result,expected)
 
-        # NA as a level
-        cat = pd.Categorical(["a","c","c",np.nan], levels=["b","a","c",np.nan] )
+        # NA as a category
+        cat = pd.Categorical(["a","c","c",np.nan], categories=["b","a","c",np.nan] )
         result = cat.describe()
 
         expected = DataFrame([[np.nan, np.nan],[1,0.25],[2,0.5], [1,0.25]],
                              columns=['counts','freqs'],
-                             index=Index(['b','a','c',np.nan],name='levels'))
+                             index=Index(['b','a','c',np.nan],name='categories'))
         tm.assert_frame_equal(result,expected)
 
 
     def test_print(self):
         expected = ["[a, b, b, a, a, c, c, c]",
-                    "Levels (3, object): [a < b < c]"]
+                    "Categories (3, object): [a < b < c]"]
         expected = "\n".join(expected)
         actual = repr(self.factor)
         self.assertEqual(actual, expected)
@@ -409,7 +409,7 @@ class TestCategorical(tm.TestCase):
         factor = Categorical([0,1,2,0,1,2]*100, ['a', 'b', 'c'], name='cat', fastpath=True)
         expected = ["[a, b, c, a, b, ..., b, c, a, b, c]",
                     "Name: cat, Length: 600",
-                    "Levels (3, object): [a, b, c]"]
+                    "Categories (3, object): [a, b, c]"]
         expected = "\n".join(expected)
 
         actual = repr(factor)
@@ -418,20 +418,20 @@ class TestCategorical(tm.TestCase):
 
     def test_empty_print(self):
         factor = Categorical([], ["a","b","c"], name="cat")
-        expected = ("[], Name: cat, Levels (3, object): [a < b < c]")
+        expected = ("[], Name: cat, Categories (3, object): [a < b < c]")
         # hack because array_repr changed in numpy > 1.6.x
         actual = repr(factor)
 
         self.assertEqual(actual, expected)
 
         factor = Categorical([], ["a","b","c"])
-        expected = ("[], Levels (3, object): [a < b < c]")
+        expected = ("[], Categories (3, object): [a < b < c]")
         actual = repr(factor)
 
         self.assertEqual(expected, actual)
 
         factor = Categorical([], [])
-        expected = ("[], Levels (0, object): []")
+        expected = ("[], Categories (0, object): []")
         self.assertEqual(expected, repr(factor))
 
     def test_periodindex(self):
@@ -443,7 +443,7 @@ class TestCategorical(tm.TestCase):
         exp_arr = np.array([0, 0, 1, 1, 2, 2],dtype='int64')
         exp_idx = PeriodIndex(['2014-01', '2014-02', '2014-03'], freq='M')
         self.assert_numpy_array_equal(cat1._codes, exp_arr)
-        self.assertTrue(cat1.levels.equals(exp_idx))
+        self.assertTrue(cat1.categories.equals(exp_idx))
 
         idx2 = PeriodIndex(['2014-03', '2014-03', '2014-02', '2014-01',
                             '2014-03', '2014-01'], freq='M')
@@ -452,7 +452,7 @@ class TestCategorical(tm.TestCase):
         exp_arr = np.array([2, 2, 1, 0, 2, 0],dtype='int64')
         exp_idx2 = PeriodIndex(['2014-01', '2014-02', '2014-03'], freq='M')
         self.assert_numpy_array_equal(cat2._codes, exp_arr)
-        self.assertTrue(cat2.levels.equals(exp_idx2))
+        self.assertTrue(cat2.categories.equals(exp_idx2))
 
         idx3 = PeriodIndex(['2013-12', '2013-11', '2013-10', '2013-09',
                             '2013-08', '2013-07', '2013-05'], freq='M')
@@ -461,92 +461,86 @@ class TestCategorical(tm.TestCase):
         exp_idx = PeriodIndex(['2013-05', '2013-07', '2013-08', '2013-09',
                                '2013-10', '2013-11', '2013-12'], freq='M')
         self.assert_numpy_array_equal(cat3._codes, exp_arr)
-        self.assertTrue(cat3.levels.equals(exp_idx))
+        self.assertTrue(cat3.categories.equals(exp_idx))
 
-    def test_level_assigments(self):
+    def test_categories_assigments(self):
         s = pd.Categorical(["a","b","c","a"])
         exp = np.array([1,2,3,1])
-        s.levels = [1,2,3]
+        s.categories = [1,2,3]
         self.assert_numpy_array_equal(s.__array__(), exp)
-        self.assert_numpy_array_equal(s.levels, np.array([1,2,3]))
+        self.assert_numpy_array_equal(s.categories, np.array([1,2,3]))
         # lengthen
-        s.levels = [1,2,3,4]
-        # does nothing to the values but only the the levels
+        s.categories = [1,2,3,4]
+        # does nothing to the values but only the the categories
         self.assert_numpy_array_equal(s.__array__(), exp)
-        self.assert_numpy_array_equal(s.levels, np.array([1,2,3,4]))
+        self.assert_numpy_array_equal(s.categories, np.array([1,2,3,4]))
         # shorten
         exp2 = np.array([1,2,np.nan,1])
-        s.levels = [1,2]
+        s.categories = [1,2]
         self.assert_numpy_array_equivalent(s.__array__(), exp2) # doesn't work with nan :-(
         self.assertTrue(np.isnan(s.__array__()[2]))
-        self.assert_numpy_array_equal(s.levels, np.array([1,2]))
+        self.assert_numpy_array_equal(s.categories, np.array([1,2]))
 
-    def test_reorder_levels(self):
+    def test_reorder_categories(self):
         cat = Categorical(["a","b","c","a"], ordered=True)
-        exp_levels = np.array(["c","b","a"])
+        exp_categories = np.array(["c","b","a"])
         exp_values = np.array(["a","b","c","a"])
 
-        res = cat.reorder_levels(["c","b","a"], inplace=True)
-        self.assert_numpy_array_equal(cat.levels, exp_levels)
+        res = cat.reorder_categories(["c","b","a"], inplace=True)
+        self.assert_numpy_array_equal(cat.categories, exp_categories)
         self.assert_numpy_array_equal(cat.__array__(), exp_values)
         self.assertIsNone(res)
 
-        res = cat.reorder_levels(["a","b","c"])
+        res = cat.reorder_categories(["a","b","c"])
         # cat must be the same as before
-        self.assert_numpy_array_equal(cat.levels, exp_levels)
+        self.assert_numpy_array_equal(cat.categories, exp_categories)
         self.assert_numpy_array_equal(cat.__array__(), exp_values)
         # only res is changed
-        exp_levels_back = np.array(["a","b","c"])
-        self.assert_numpy_array_equal(res.levels, exp_levels_back)
+        exp_categories_back = np.array(["a","b","c"])
+        self.assert_numpy_array_equal(res.categories, exp_categories_back)
         self.assert_numpy_array_equal(res.__array__(), exp_values)
 
-
-        # not all "old" included in "new"
-        def f():
-            cat.reorder_levels(["a"])
-        self.assertRaises(ValueError, f)
+        # not all "old" included in "new" -> all not included ones are now np.nan
+        cat = Categorical(["a","b","c","a"], ordered=True)
+        res = cat.reorder_categories(["a"])
+        self.assert_numpy_array_equal(res.codes, np.array([0,-1,-1,0]))
 
         # still not all "old" in "new"
-        def f():
-            cat.reorder_levels(["a","b","d"])
-        self.assertRaises(ValueError, f)
+        res = cat.reorder_categories(["a","b","d"])
+        self.assert_numpy_array_equal(res.codes, np.array([0,1,-1,0]))
+        self.assert_numpy_array_equal(res.categories, np.array(["a","b","d"]))
 
-        # This works: all "old" included in "new"
-        cat = cat.reorder_levels(["a","b","c","d"])
-        exp_levels = np.array(["a","b","c","d"])
-        self.assert_numpy_array_equal(cat.levels, exp_levels)
+        # all "old" included in "new"
+        cat = cat.reorder_categories(["a","b","c","d"])
+        exp_categories = np.array(["a","b","c","d"])
+        self.assert_numpy_array_equal(cat.categories, exp_categories)
 
         # internals...
-        c = Categorical([1,2,3,4,1], levels=[1,2,3,4])
+        c = Categorical([1,2,3,4,1], categories=[1,2,3,4])
         self.assert_numpy_array_equal(c._codes, np.array([0,1,2,3,0]))
-        self.assert_numpy_array_equal(c.levels , np.array([1,2,3,4] ))
-        self.assert_numpy_array_equal(c.get_values() , np.array([1,2,3,4,1] ))
-        c = c.reorder_levels([4,3,2,1]) # all "pointers" to '4' must be changed from 3 to 0,...
-        self.assert_numpy_array_equal(c._codes , np.array([3,2,1,0,3])) # positions are changed
-        self.assert_numpy_array_equal(c.levels , np.array([4,3,2,1])) # levels are now in new order
-        self.assert_numpy_array_equal(c.get_values() , np.array([1,2,3,4,1])) # output is the same
+        self.assert_numpy_array_equal(c.categories , np.array([1,2,3,4] ))
+        self.assert_numpy_array_equal(c.get_values(), np.array([1,2,3,4,1] ))
+        c = c.reorder_categories([4,3,2,1]) # all "pointers" to '4' must be changed from 3 to 0,...
+        self.assert_numpy_array_equal(c._codes, np.array([3,2,1,0,3])) # positions are changed
+        self.assert_numpy_array_equal(c.categories, np.array([4,3,2,1])) # categories are now in new order
+        self.assert_numpy_array_equal(c.get_values(), np.array([1,2,3,4,1])) # output is the same
         self.assertTrue(c.min(), 4)
         self.assertTrue(c.max(), 1)
 
-        def f():
-            c.reorder_levels([4,3,2,10]) # 1 vs 10 -> not all new in old
-        self.assertRaises(ValueError, f)
 
+    def test_remove_unused_categories(self):
+        c = Categorical(["a","b","c","d","a"], categories=["a","b","c","d","e"])
+        exp_categories_all = np.array(["a","b","c","d","e"])
+        exp_categories_dropped = np.array(["a","b","c","d"])
 
+        self.assert_numpy_array_equal(c.categories, exp_categories_all)
 
-    def test_remove_unused_levels(self):
-        c = Categorical(["a","b","c","d","a"], levels=["a","b","c","d","e"])
-        exp_levels_all = np.array(["a","b","c","d","e"])
-        exp_levels_dropped = np.array(["a","b","c","d"])
+        res = c.remove_unused_categories()
+        self.assert_numpy_array_equal(res.categories, exp_categories_dropped)
+        self.assert_numpy_array_equal(c.categories, exp_categories_all)
 
-        self.assert_numpy_array_equal(c.levels, exp_levels_all)
-
-        res = c.remove_unused_levels()
-        self.assert_numpy_array_equal(res.levels, exp_levels_dropped)
-        self.assert_numpy_array_equal(c.levels, exp_levels_all)
-
-        res = c.remove_unused_levels(inplace=True)
-        self.assert_numpy_array_equal(c.levels, exp_levels_dropped)
+        res = c.remove_unused_categories(inplace=True)
+        self.assert_numpy_array_equal(c.categories, exp_categories_dropped)
         self.assertIsNone(res)
 
 
@@ -554,35 +548,35 @@ class TestCategorical(tm.TestCase):
 
         # Nans are represented as -1 in codes
         c = Categorical(["a","b",np.nan,"a"])
-        self.assert_numpy_array_equal(c.levels , np.array(["a","b"]))
+        self.assert_numpy_array_equal(c.categories , np.array(["a","b"]))
         self.assert_numpy_array_equal(c._codes , np.array([0,1,-1,0]))
         c[1] = np.nan
-        self.assert_numpy_array_equal(c.levels , np.array(["a","b"]))
+        self.assert_numpy_array_equal(c.categories , np.array(["a","b"]))
         self.assert_numpy_array_equal(c._codes , np.array([0,-1,-1,0]))
 
-        # If levels have nan included, the code should point to that instead
-        c = Categorical(["a","b",np.nan,"a"], levels=["a","b",np.nan])
-        self.assert_numpy_array_equal(c.levels , np.array(["a","b",np.nan],dtype=np.object_))
+        # If categories have nan included, the code should point to that instead
+        c = Categorical(["a","b",np.nan,"a"], categories=["a","b",np.nan])
+        self.assert_numpy_array_equal(c.categories , np.array(["a","b",np.nan],dtype=np.object_))
         self.assert_numpy_array_equal(c._codes , np.array([0,1,2,0]))
         c[1] = np.nan
-        self.assert_numpy_array_equal(c.levels , np.array(["a","b",np.nan],dtype=np.object_))
+        self.assert_numpy_array_equal(c.categories , np.array(["a","b",np.nan],dtype=np.object_))
         self.assert_numpy_array_equal(c._codes , np.array([0,2,2,0]))
 
-        # Changing levels should also make the replaced level np.nan
+        # Changing categories should also make the replaced category np.nan
         c = Categorical(["a","b","c","a"])
-        c.levels = ["a","b",np.nan]
-        self.assert_numpy_array_equal(c.levels , np.array(["a","b",np.nan],dtype=np.object_))
+        c.categories = ["a","b",np.nan]
+        self.assert_numpy_array_equal(c.categories , np.array(["a","b",np.nan],dtype=np.object_))
         self.assert_numpy_array_equal(c._codes , np.array([0,1,2,0]))
 
-        # Adding nan to levels should make assigned nan point to the level!
+        # Adding nan to categories should make assigned nan point to the category!
         c = Categorical(["a","b",np.nan,"a"])
-        self.assert_numpy_array_equal(c.levels , np.array(["a","b"]))
+        self.assert_numpy_array_equal(c.categories , np.array(["a","b"]))
         self.assert_numpy_array_equal(c._codes , np.array([0,1,-1,0]))
-        c.levels = ["a","b",np.nan]
-        self.assert_numpy_array_equal(c.levels , np.array(["a","b",np.nan],dtype=np.object_))
+        c.categories = ["a","b",np.nan]
+        self.assert_numpy_array_equal(c.categories , np.array(["a","b",np.nan],dtype=np.object_))
         self.assert_numpy_array_equal(c._codes , np.array([0,1,-1,0]))
         c[1] = np.nan
-        self.assert_numpy_array_equal(c.levels , np.array(["a","b",np.nan],dtype=np.object_))
+        self.assert_numpy_array_equal(c.categories , np.array(["a","b",np.nan],dtype=np.object_))
         self.assert_numpy_array_equal(c._codes , np.array([0,2,-1,0]))
 
 
@@ -592,14 +586,14 @@ class TestCategorical(tm.TestCase):
         res = c.isnull()
         self.assert_numpy_array_equal(res, exp)
 
-        c = Categorical(["a","b",np.nan], levels=["a","b",np.nan])
+        c = Categorical(["a","b",np.nan], categories=["a","b",np.nan])
         res = c.isnull()
         self.assert_numpy_array_equal(res, exp)
 
-        # test both nan in levels and as -1
+        # test both nan in categories and as -1
         exp = np.array([True, False, True])
         c = Categorical(["a","b",np.nan])
-        c.levels = ["a","b",np.nan]
+        c.categories = ["a","b",np.nan]
         c[0] = np.nan
         res = c.isnull()
         self.assert_numpy_array_equal(res, exp)
@@ -643,12 +637,12 @@ class TestCategorical(tm.TestCase):
         _max = cat.max()
         self.assertEqual(_min, "a")
         self.assertEqual(_max, "d")
-        cat = Categorical(["a","b","c","d"], levels=['d','c','b','a'], ordered=True)
+        cat = Categorical(["a","b","c","d"], categories=['d','c','b','a'], ordered=True)
         _min = cat.min()
         _max = cat.max()
         self.assertEqual(_min, "d")
         self.assertEqual(_max, "a")
-        cat = Categorical([np.nan,"b","c",np.nan], levels=['d','c','b','a'], ordered=True)
+        cat = Categorical([np.nan,"b","c",np.nan], categories=['d','c','b','a'], ordered=True)
         _min = cat.min()
         _max = cat.max()
         self.assertTrue(np.isnan(_min))
@@ -659,7 +653,7 @@ class TestCategorical(tm.TestCase):
         _max = cat.max(numeric_only=True)
         self.assertEqual(_max, "b")
 
-        cat = Categorical([np.nan,1,2,np.nan], levels=[5,4,3,2,1], ordered=True)
+        cat = Categorical([np.nan,1,2,np.nan], categories=[5,4,3,2,1], ordered=True)
         _min = cat.min()
         _max = cat.max()
         self.assertTrue(np.isnan(_min))
@@ -678,30 +672,30 @@ class TestCategorical(tm.TestCase):
         self.assertEqual(type(res), type(exp))
 
     def test_mode(self):
-        s = Categorical([1,1,2,4,5,5,5], levels=[5,4,3,2,1], ordered=True)
+        s = Categorical([1,1,2,4,5,5,5], categories=[5,4,3,2,1], ordered=True)
         res = s.mode()
-        exp = Categorical([5], levels=[5,4,3,2,1], ordered=True)
+        exp = Categorical([5], categories=[5,4,3,2,1], ordered=True)
         self.assertTrue(res.equals(exp))
-        s = Categorical([1,1,1,4,5,5,5], levels=[5,4,3,2,1], ordered=True)
+        s = Categorical([1,1,1,4,5,5,5], categories=[5,4,3,2,1], ordered=True)
         res = s.mode()
-        exp = Categorical([5,1], levels=[5,4,3,2,1], ordered=True)
+        exp = Categorical([5,1], categories=[5,4,3,2,1], ordered=True)
         self.assertTrue(res.equals(exp))
-        s = Categorical([1,2,3,4,5], levels=[5,4,3,2,1], ordered=True)
+        s = Categorical([1,2,3,4,5], categories=[5,4,3,2,1], ordered=True)
         res = s.mode()
-        exp = Categorical([], levels=[5,4,3,2,1], ordered=True)
+        exp = Categorical([], categories=[5,4,3,2,1], ordered=True)
         self.assertTrue(res.equals(exp))
         # NaN should not become the mode!
-        s = Categorical([np.nan,np.nan,np.nan,4,5], levels=[5,4,3,2,1], ordered=True)
+        s = Categorical([np.nan,np.nan,np.nan,4,5], categories=[5,4,3,2,1], ordered=True)
         res = s.mode()
-        exp = Categorical([], levels=[5,4,3,2,1], ordered=True)
+        exp = Categorical([], categories=[5,4,3,2,1], ordered=True)
         self.assertTrue(res.equals(exp))
-        s = Categorical([np.nan,np.nan,np.nan,4,5,4], levels=[5,4,3,2,1], ordered=True)
+        s = Categorical([np.nan,np.nan,np.nan,4,5,4], categories=[5,4,3,2,1], ordered=True)
         res = s.mode()
-        exp = Categorical([4], levels=[5,4,3,2,1], ordered=True)
+        exp = Categorical([4], categories=[5,4,3,2,1], ordered=True)
         self.assertTrue(res.equals(exp))
-        s = Categorical([np.nan,np.nan,4,5,4], levels=[5,4,3,2,1], ordered=True)
+        s = Categorical([np.nan,np.nan,4,5,4], categories=[5,4,3,2,1], ordered=True)
         res = s.mode()
-        exp = Categorical([4], levels=[5,4,3,2,1], ordered=True)
+        exp = Categorical([4], categories=[5,4,3,2,1], ordered=True)
         self.assertTrue(res.equals(exp))
 
 
@@ -717,7 +711,7 @@ class TestCategorical(tm.TestCase):
         exp = np.array(["a","b","c","d"],dtype=object)
         self.assert_numpy_array_equal(res.__array__(), exp)
 
-        cat = Categorical(["a","c","b","d"], levels=["a","b","c","d"], ordered=True)
+        cat = Categorical(["a","c","b","d"], categories=["a","b","c","d"], ordered=True)
         res = cat.order()
         exp = np.array(["a","b","c","d"],dtype=object)
         self.assert_numpy_array_equal(res.__array__(), exp)
@@ -737,56 +731,68 @@ class TestCategorical(tm.TestCase):
         sliced = cat[3]
         tm.assert_equal(sliced, "d")
         sliced = cat[3:5]
-        expected = Categorical(["d","a"], levels=['a', 'b', 'c', 'd'])
+        expected = Categorical(["d","a"], categories=['a', 'b', 'c', 'd'])
         self.assert_numpy_array_equal(sliced._codes, expected._codes)
-        tm.assert_index_equal(sliced.levels, expected.levels)
+        tm.assert_index_equal(sliced.categories, expected.categories)
 
     def test_set_item_nan(self):
         cat = pd.Categorical([1,2,3])
-        exp = pd.Categorical([1,np.nan,3], levels=[1,2,3])
+        exp = pd.Categorical([1,np.nan,3], categories=[1,2,3])
         cat[1] = np.nan
         self.assertTrue(cat.equals(exp))
 
-        # if nan in levels, the proper code should be set!
-        cat = pd.Categorical([1,2,3, np.nan], levels=[1,2,3])
-        cat.levels = [1,2,3, np.nan]
+        # if nan in categories, the proper code should be set!
+        cat = pd.Categorical([1,2,3, np.nan], categories=[1,2,3])
+        cat.categories = [1,2,3, np.nan]
         cat[1] = np.nan
         exp = np.array([0,3,2,-1])
         self.assert_numpy_array_equal(cat.codes, exp)
 
-        cat = pd.Categorical([1,2,3, np.nan], levels=[1,2,3])
-        cat.levels = [1,2,3, np.nan]
+        cat = pd.Categorical([1,2,3, np.nan], categories=[1,2,3])
+        cat.categories = [1,2,3, np.nan]
         cat[1:3] = np.nan
         exp = np.array([0,3,3,-1])
         self.assert_numpy_array_equal(cat.codes, exp)
 
-        cat = pd.Categorical([1,2,3, np.nan], levels=[1,2,3])
-        cat.levels = [1,2,3, np.nan]
+        cat = pd.Categorical([1,2,3, np.nan], categories=[1,2,3])
+        cat.categories = [1,2,3, np.nan]
         cat[1:3] = [np.nan, 1]
         exp = np.array([0,3,0,-1])
         self.assert_numpy_array_equal(cat.codes, exp)
 
-        cat = pd.Categorical([1,2,3, np.nan], levels=[1,2,3])
-        cat.levels = [1,2,3, np.nan]
+        cat = pd.Categorical([1,2,3, np.nan], categories=[1,2,3])
+        cat.categories = [1,2,3, np.nan]
         cat[1:3] = [np.nan, np.nan]
         exp = np.array([0,3,3,-1])
         self.assert_numpy_array_equal(cat.codes, exp)
 
-        cat = pd.Categorical([1,2, np.nan, 3], levels=[1,2,3])
-        cat.levels = [1,2,3, np.nan]
+        cat = pd.Categorical([1,2, np.nan, 3], categories=[1,2,3])
+        cat.categories = [1,2,3, np.nan]
         cat[pd.isnull(cat)] = np.nan
         exp = np.array([0,1,3,2])
         self.assert_numpy_array_equal(cat.codes, exp)
 
     def test_deprecated_labels(self):
-        # labels is deprecated and should be removed in 0.18 or 2017, whatever is earlier
-        cat = pd.Categorical([1,2,3, np.nan], levels=[1,2,3])
+        # TODO: labels is deprecated and should be removed in 0.18 or 2017, whatever is earlier
+        cat = pd.Categorical([1,2,3, np.nan], categories=[1,2,3])
         exp = cat.codes
         with tm.assert_produces_warning(FutureWarning):
             res = cat.labels
         self.assert_numpy_array_equal(res, exp)
         self.assertFalse(LooseVersion(pd.__version__) >= '0.18')
 
+    def test_deprecated_levels(self):
+        # TODO: levels is deprecated and should be removed in 0.18 or 2017, whatever is earlier
+        cat = pd.Categorical([1,2,3, np.nan], categories=[1,2,3])
+        exp = cat.categories
+        with tm.assert_produces_warning(FutureWarning):
+            res = cat.levels
+        self.assert_numpy_array_equal(res, exp)
+        with tm.assert_produces_warning(FutureWarning):
+            res = pd.Categorical([1,2,3, np.nan], levels=[1,2,3])
+        self.assert_numpy_array_equal(res.categories, exp)
+
+        self.assertFalse(LooseVersion(pd.__version__) >= '0.18')
 
 
 class TestCategoricalAsBlock(tm.TestCase):
@@ -919,7 +925,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         # insert into frame with different index
         # GH 8076
         index = pd.date_range('20000101', periods=3)
-        expected = Series(Categorical(values=[np.nan,np.nan,np.nan],levels=['a', 'b', 'c']))
+        expected = Series(Categorical(values=[np.nan,np.nan,np.nan],categories=['a', 'b', 'c']))
         expected.index = index
 
         expected = DataFrame({'x': expected})
@@ -933,17 +939,17 @@ class TestCategoricalAsBlock(tm.TestCase):
         # reindexing to an invalid Categorical
         s = Series(['a', 'b', 'c'],dtype='category')
         result = s.reindex(index)
-        expected = Series(Categorical(values=[np.nan,np.nan,np.nan],levels=['a', 'b', 'c']))
+        expected = Series(Categorical(values=[np.nan,np.nan,np.nan],categories=['a', 'b', 'c']))
         expected.index = index
         tm.assert_series_equal(result, expected)
 
         # partial reindexing
-        expected = Series(Categorical(values=['b','c'],levels=['a', 'b', 'c']))
+        expected = Series(Categorical(values=['b','c'],categories=['a', 'b', 'c']))
         expected.index = [1,2]
         result = s.reindex([1,2])
         tm.assert_series_equal(result, expected)
 
-        expected = Series(Categorical(values=['c',np.nan],levels=['a', 'b', 'c']))
+        expected = Series(Categorical(values=['c',np.nan],categories=['a', 'b', 'c']))
         expected.index = [2,3]
         result = s.reindex([2,3])
         tm.assert_series_equal(result, expected)
@@ -957,7 +963,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         cat = Categorical(["a","b","c","a"])
         s =  pd.Series(cat, copy=True)
         self.assertFalse(s.cat is cat)
-        s.cat.levels = [1,2,3]
+        s.cat.categories = [1,2,3]
         exp_s = np.array([1,2,3,1])
         exp_cat = np.array(["a","b","c","a"])
         self.assert_numpy_array_equal(s.__array__(), exp_s)
@@ -974,7 +980,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         cat = Categorical(["a","b","c","a"])
         s =  pd.Series(cat)
         self.assertTrue(s.values is cat)
-        s.cat.levels = [1,2,3]
+        s.cat.categories = [1,2,3]
         exp_s = np.array([1,2,3,1])
         self.assert_numpy_array_equal(s.__array__(), exp_s)
         self.assert_numpy_array_equal(cat.__array__(), exp_s)
@@ -988,35 +994,35 @@ class TestCategoricalAsBlock(tm.TestCase):
 
         # Nans are represented as -1 in labels
         s = Series(Categorical(["a","b",np.nan,"a"]))
-        self.assert_numpy_array_equal(s.cat.levels, np.array(["a","b"]))
+        self.assert_numpy_array_equal(s.cat.categories, np.array(["a","b"]))
         self.assert_numpy_array_equal(s.values.codes, np.array([0,1,-1,0]))
 
-        # If levels have nan included, the label should point to that instead
-        s2 = Series(Categorical(["a","b",np.nan,"a"], levels=["a","b",np.nan]))
-        self.assert_numpy_array_equal(s2.cat.levels,
+        # If categories have nan included, the label should point to that instead
+        s2 = Series(Categorical(["a","b",np.nan,"a"], categories=["a","b",np.nan]))
+        self.assert_numpy_array_equal(s2.cat.categories,
                                       np.array(["a","b",np.nan], dtype=np.object_))
         self.assert_numpy_array_equal(s2.values.codes, np.array([0,1,2,0]))
 
-        # Changing levels should also make the replaced level np.nan
+        # Changing categories should also make the replaced category np.nan
         s3 = Series(Categorical(["a","b","c","a"]))
-        s3.cat.levels = ["a","b",np.nan]
-        self.assert_numpy_array_equal(s3.cat.levels,
+        s3.cat.categories = ["a","b",np.nan]
+        self.assert_numpy_array_equal(s3.cat.categories,
                                       np.array(["a","b",np.nan], dtype=np.object_))
         self.assert_numpy_array_equal(s3.values.codes, np.array([0,1,2,0]))
 
     def test_cat_accessor(self):
         s = Series(Categorical(["a","b",np.nan,"a"]))
-        self.assert_numpy_array_equal(s.cat.levels, np.array(["a","b"]))
+        self.assert_numpy_array_equal(s.cat.categories, np.array(["a","b"]))
         self.assertEqual(s.cat.ordered, True)
-        exp = Categorical(["a","b",np.nan,"a"], levels=["b","a"])
-        s.cat.reorder_levels(["b", "a"], inplace=True)
+        exp = Categorical(["a","b",np.nan,"a"], categories=["b","a"])
+        s.cat.reorder_categories(["b", "a"], inplace=True)
         self.assertTrue(s.values.equals(exp))
-        res = s.cat.reorder_levels(["b", "a"])
+        res = s.cat.reorder_categories(["b", "a"])
         self.assertTrue(res.values.equals(exp))
-        exp = Categorical(["a","b",np.nan,"a"], levels=["b","a"])
+        exp = Categorical(["a","b",np.nan,"a"], categories=["b","a"])
         s[:] = "a"
-        s = s.cat.remove_unused_levels()
-        self.assert_numpy_array_equal(s.cat.levels, np.array(["a"]))
+        s = s.cat.remove_unused_categories()
+        self.assert_numpy_array_equal(s.cat.categories, np.array(["a"]))
 
     def test_sequence_like(self):
 
@@ -1051,14 +1057,14 @@ class TestCategoricalAsBlock(tm.TestCase):
         self.assertRaises(TypeError, lambda : Series(np.arange(5.)).cat)
         self.assertRaises(TypeError, lambda : Series([Timestamp('20130101')]).cat)
 
-        # Series should delegate calls to '.level', '.codes', '.ordered' and the
-        # methods '.reorder_levels()' 'drop_unused_levels()' to the categorical
+        # Series should delegate calls to '.categories', '.codes', '.ordered' and the
+        # methods '.reorder_categories()' 'drop_unused_categories()' to the categorical
         s = Series(Categorical(["a","b","c","a"], ordered=True))
-        exp_levels = np.array(["a","b","c"])
-        self.assert_numpy_array_equal(s.cat.levels, exp_levels)
-        s.cat.levels = [1,2,3]
-        exp_levels = np.array([1,2,3])
-        self.assert_numpy_array_equal(s.cat.levels, exp_levels)
+        exp_categories = np.array(["a","b","c"])
+        self.assert_numpy_array_equal(s.cat.categories, exp_categories)
+        s.cat.categories = [1,2,3]
+        exp_categories = np.array([1,2,3])
+        self.assert_numpy_array_equal(s.cat.categories, exp_categories)
 
         exp_codes = Series(com._ensure_platform_int([0,1,2,0]))
         tm.assert_series_equal(s.cat.codes, exp_codes)
@@ -1069,27 +1075,27 @@ class TestCategoricalAsBlock(tm.TestCase):
 
         # reorder
         s = Series(Categorical(["a","b","c","a"], ordered=True))
-        exp_levels = np.array(["c","b","a"])
+        exp_categories = np.array(["c","b","a"])
         exp_values = np.array(["a","b","c","a"])
-        s = s.cat.reorder_levels(["c","b","a"])
-        self.assert_numpy_array_equal(s.cat.levels, exp_levels)
+        s = s.cat.reorder_categories(["c","b","a"])
+        self.assert_numpy_array_equal(s.cat.categories, exp_categories)
         self.assert_numpy_array_equal(s.values.__array__(), exp_values)
         self.assert_numpy_array_equal(s.__array__(), exp_values)
 
-        # remove unused levels
-        s = Series(Categorical(["a","b","b","a"], levels=["a","b","c"]))
-        exp_levels = np.array(["a","b"])
+        # remove unused categories
+        s = Series(Categorical(["a","b","b","a"], categories=["a","b","c"]))
+        exp_categories = np.array(["a","b"])
         exp_values = np.array(["a","b","b","a"])
-        s = s.cat.remove_unused_levels()
-        self.assert_numpy_array_equal(s.cat.levels, exp_levels)
+        s = s.cat.remove_unused_categories()
+        self.assert_numpy_array_equal(s.cat.categories, exp_categories)
         self.assert_numpy_array_equal(s.values.__array__(), exp_values)
         self.assert_numpy_array_equal(s.__array__(), exp_values)
 
         # This method is likely to be confused, so test that it raises an error on wrong inputs:
         def f():
-            s.reorder_levels([4,3,2,1])
+            s.reorder_categories([4,3,2,1])
         self.assertRaises(Exception, f)
-        # right: s.cat.reorder_levels([4,3,2,1])
+        # right: s.cat.reorder_categories([4,3,2,1])
 
     def test_series_functions_no_warnings(self):
         df = pd.DataFrame({'value': np.random.randint(0, 100, 20)})
@@ -1128,7 +1134,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         s.name = 'E'
         self.assertTrue(result2.sort_index().equals(s.sort_index()))
 
-        cat = pd.Categorical([1,2,3,10], levels=[1,2,3,4,10])
+        cat = pd.Categorical([1,2,3,10], categories=[1,2,3,4,10])
         df = pd.DataFrame(pd.Series(cat))
 
     def test_describe(self):
@@ -1141,7 +1147,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         # In a frame, describe() for the cat should be the same as for string arrays (count, unique,
         # top, freq)
 
-        cat = Categorical(["a","b","b","b"], levels=['a','b','c'], ordered=True)
+        cat = Categorical(["a","b","b","b"], categories=['a','b','c'], ordered=True)
         s = Series(cat)
         result = s.describe()
         expected = Series([4,2,"b",3],index=['count','unique','top', 'freq'])
@@ -1155,7 +1161,7 @@ class TestCategoricalAsBlock(tm.TestCase):
     def test_repr(self):
         a = pd.Series(pd.Categorical([1,2,3,4], name="a"))
         exp = u("0    1\n1    2\n2    3\n3    4\n" +
-              "Name: a, dtype: category\nLevels (4, int64): [1 < 2 < 3 < 4]")
+              "Name: a, dtype: category\nCategories (4, int64): [1 < 2 < 3 < 4]")
 
         self.assertEqual(exp, a.__unicode__())
 
@@ -1163,14 +1169,14 @@ class TestCategoricalAsBlock(tm.TestCase):
         exp = u("".join(["%s    a\n%s    b\n"%(i,i+1) for i in range(0,10,2)]) + "...\n" +
                 "".join(["%s    a\n%s    b\n"%(i,i+1) for i in range(40,50,2)]) +
                 "Name: a, Length: 50, dtype: category\n" +
-                "Levels (2, object): [a < b]")
+                "Categories (2, object): [a < b]")
         self.assertEqual(exp,a._tidy_repr())
 
         levs = list("abcdefghijklmnopqrstuvwxyz")
-        a = pd.Series(pd.Categorical(["a","b"], name="a", levels=levs))
+        a = pd.Series(pd.Categorical(["a","b"], name="a", categories=levs))
         exp = u("0    a\n1    b\n" +
                 "Name: a, dtype: category\n"
-                "Levels (26, object): [a < b < c < d ... w < x < y < z]")
+                "Categories (26, object): [a < b < c < d ... w < x < y < z]")
         self.assertEqual(exp,a.__unicode__())
 
 
@@ -1197,41 +1203,41 @@ class TestCategoricalAsBlock(tm.TestCase):
         self.assertEqual(_min, "a")
         self.assertEqual(_max, "d")
 
-        cat = Series(Categorical(["a","b","c","d"], levels=['d','c','b','a'], ordered=True))
+        cat = Series(Categorical(["a","b","c","d"], categories=['d','c','b','a'], ordered=True))
         _min = cat.min()
         _max = cat.max()
         self.assertEqual(_min, "d")
         self.assertEqual(_max, "a")
 
-        cat = Series(Categorical([np.nan,"b","c",np.nan], levels=['d','c','b','a'], ordered=True))
+        cat = Series(Categorical([np.nan,"b","c",np.nan], categories=['d','c','b','a'], ordered=True))
         _min = cat.min()
         _max = cat.max()
         self.assertTrue(np.isnan(_min))
         self.assertEqual(_max, "b")
 
-        cat = Series(Categorical([np.nan,1,2,np.nan], levels=[5,4,3,2,1], ordered=True))
+        cat = Series(Categorical([np.nan,1,2,np.nan], categories=[5,4,3,2,1], ordered=True))
         _min = cat.min()
         _max = cat.max()
         self.assertTrue(np.isnan(_min))
         self.assertEqual(_max, 1)
 
     def test_mode(self):
-        s = Series(Categorical([1,1,2,4,5,5,5], levels=[5,4,3,2,1], ordered=True))
+        s = Series(Categorical([1,1,2,4,5,5,5], categories=[5,4,3,2,1], ordered=True))
         res = s.mode()
-        exp = Series(Categorical([5], levels=[5,4,3,2,1], ordered=True))
+        exp = Series(Categorical([5], categories=[5,4,3,2,1], ordered=True))
         tm.assert_series_equal(res, exp)
-        s = Series(Categorical([1,1,1,4,5,5,5], levels=[5,4,3,2,1], ordered=True))
+        s = Series(Categorical([1,1,1,4,5,5,5], categories=[5,4,3,2,1], ordered=True))
         res = s.mode()
-        exp = Series(Categorical([5,1], levels=[5,4,3,2,1], ordered=True))
+        exp = Series(Categorical([5,1], categories=[5,4,3,2,1], ordered=True))
         tm.assert_series_equal(res, exp)
-        s = Series(Categorical([1,2,3,4,5], levels=[5,4,3,2,1], ordered=True))
+        s = Series(Categorical([1,2,3,4,5], categories=[5,4,3,2,1], ordered=True))
         res = s.mode()
-        exp = Series(Categorical([], levels=[5,4,3,2,1], ordered=True))
+        exp = Series(Categorical([], categories=[5,4,3,2,1], ordered=True))
         tm.assert_series_equal(res, exp)
 
     def test_value_counts(self):
 
-        s = pd.Series(pd.Categorical(["a","b","c","c","c","b"], levels=["c","a","b","d"]))
+        s = pd.Series(pd.Categorical(["a","b","c","c","c","b"], categories=["c","a","b","d"]))
         res = s.value_counts(sort=False)
         exp = Series([3,1,2,0], index=["c","a","b","d"])
         tm.assert_series_equal(res, exp)
@@ -1241,15 +1247,15 @@ class TestCategoricalAsBlock(tm.TestCase):
 
     def test_groupby(self):
 
-        cats = Categorical(["a", "a", "a", "b", "b", "b", "c", "c", "c"], levels=["a","b","c","d"])
+        cats = Categorical(["a", "a", "a", "b", "b", "b", "c", "c", "c"], categories=["a","b","c","d"])
         data = DataFrame({"a":[1,1,1,2,2,2,3,4,5], "b":cats})
 
         expected = DataFrame({ 'a' : Series([1,2,4,np.nan],index=Index(['a','b','c','d'],name='b')) })
         result = data.groupby("b").mean()
         tm.assert_frame_equal(result, expected)
 
-        raw_cat1 = Categorical(["a","a","b","b"], levels=["a","b","z"])
-        raw_cat2 = Categorical(["c","d","c","d"], levels=["c","d","y"])
+        raw_cat1 = Categorical(["a","a","b","b"], categories=["a","b","z"])
+        raw_cat2 = Categorical(["c","d","c","d"], categories=["c","d","y"])
         df = DataFrame({"A":raw_cat1,"B":raw_cat2, "values":[1,2,3,4]})
 
         # single grouper
@@ -1281,8 +1287,8 @@ class TestCategoricalAsBlock(tm.TestCase):
 
     def test_pivot_table(self):
 
-        raw_cat1 = Categorical(["a","a","b","b"], levels=["a","b","z"])
-        raw_cat2 = Categorical(["c","d","c","d"], levels=["c","d","y"])
+        raw_cat1 = Categorical(["a","a","b","b"], categories=["a","b","z"])
+        raw_cat2 = Categorical(["c","d","c","d"], categories=["c","d","y"])
         df = DataFrame({"A":raw_cat1,"B":raw_cat2, "values":[1,2,3,4]})
         result = pd.pivot_table(df, values='values', index=['A', 'B'])
 
@@ -1293,7 +1299,7 @@ class TestCategoricalAsBlock(tm.TestCase):
 
     def test_count(self):
 
-        s = Series(Categorical([np.nan,1,2,np.nan], levels=[5,4,3,2,1], ordered=True))
+        s = Series(Categorical([np.nan,1,2,np.nan], categories=[5,4,3,2,1], ordered=True))
         result = s.count()
         self.assertEqual(result, 2)
 
@@ -1309,7 +1315,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         exp = np.array(["a","b","c","d"])
         self.assert_numpy_array_equal(res.__array__(), exp)
 
-        cat = Series(Categorical(["a","c","b","d"], levels=["a","b","c","d"], ordered=True))
+        cat = Series(Categorical(["a","c","b","d"], categories=["a","b","c","d"], ordered=True))
         res = cat.order()
         exp = np.array(["a","b","c","d"])
         self.assert_numpy_array_equal(res.__array__(), exp)
@@ -1318,8 +1324,8 @@ class TestCategoricalAsBlock(tm.TestCase):
         exp = np.array(["d","c","b","a"])
         self.assert_numpy_array_equal(res.__array__(), exp)
 
-        raw_cat1 = Categorical(["a","b","c","d"], levels=["a","b","c","d"], ordered=False)
-        raw_cat2 = Categorical(["a","b","c","d"], levels=["d","c","b","a"])
+        raw_cat1 = Categorical(["a","b","c","d"], categories=["a","b","c","d"], ordered=False)
+        raw_cat2 = Categorical(["a","b","c","d"], categories=["d","c","b","a"])
         s = ["a","b","c","d"]
         df = DataFrame({"unsort":raw_cat1,"sort":raw_cat2, "string":s, "values":[1,2,3,4]})
 
@@ -1343,9 +1349,9 @@ class TestCategoricalAsBlock(tm.TestCase):
         # GH 7848
         df = DataFrame({"id":[6,5,4,3,2,1], "raw_grade":['a', 'b', 'b', 'a', 'a', 'e']})
         df["grade"] = pd.Categorical(df["raw_grade"])
-        df['grade'] = df['grade'].cat.reorder_levels(['b', 'e', 'a'])
+        df['grade'] = df['grade'].cat.reorder_categories(['b', 'e', 'a'])
 
-        # sorts 'grade' according to the order of the levels
+        # sorts 'grade' according to the order of the categories
         result = df.sort(columns=['grade'])
         expected = df.iloc[[1,2,5,0,3,4]]
         tm.assert_frame_equal(result,expected)
@@ -1359,39 +1365,39 @@ class TestCategoricalAsBlock(tm.TestCase):
         cat = Categorical(["a","c","c","b","d"], ordered=True)
         res = cat.order(ascending=False)
         exp_val = np.array(["d","c", "c", "b","a"],dtype=object)
-        exp_levels = np.array(["a","b","c","d"],dtype=object)
+        exp_categories = np.array(["a","b","c","d"],dtype=object)
         self.assert_numpy_array_equal(res.__array__(), exp_val)
-        self.assert_numpy_array_equal(res.levels, exp_levels)
+        self.assert_numpy_array_equal(res.categories, exp_categories)
 
         # some NaN positions
 
         cat = Categorical(["a","c","b","d", np.nan], ordered=True)
         res = cat.order(ascending=False, na_position='last')
         exp_val = np.array(["d","c","b","a", np.nan],dtype=object)
-        exp_levels = np.array(["a","b","c","d"],dtype=object)
+        exp_categories = np.array(["a","b","c","d"],dtype=object)
         self.assert_numpy_array_equal(res.__array__(), exp_val)
-        self.assert_numpy_array_equal(res.levels, exp_levels)
+        self.assert_numpy_array_equal(res.categories, exp_categories)
 
         cat = Categorical(["a","c","b","d", np.nan], ordered=True)
         res = cat.order(ascending=False, na_position='first')
         exp_val = np.array([np.nan, "d","c","b","a"],dtype=object)
-        exp_levels = np.array(["a","b","c","d"],dtype=object)
+        exp_categories = np.array(["a","b","c","d"],dtype=object)
         self.assert_numpy_array_equal(res.__array__(), exp_val)
-        self.assert_numpy_array_equal(res.levels, exp_levels)
+        self.assert_numpy_array_equal(res.categories, exp_categories)
 
         cat = Categorical(["a","c","b","d", np.nan], ordered=True)
         res = cat.order(ascending=False, na_position='first')
         exp_val = np.array([np.nan, "d","c","b","a"],dtype=object)
-        exp_levels = np.array(["a","b","c","d"],dtype=object)
+        exp_categories = np.array(["a","b","c","d"],dtype=object)
         self.assert_numpy_array_equal(res.__array__(), exp_val)
-        self.assert_numpy_array_equal(res.levels, exp_levels)
+        self.assert_numpy_array_equal(res.categories, exp_categories)
 
         cat = Categorical(["a","c","b","d", np.nan], ordered=True)
         res = cat.order(ascending=False, na_position='last')
         exp_val = np.array(["d","c","b","a",np.nan],dtype=object)
-        exp_levels = np.array(["a","b","c","d"],dtype=object)
+        exp_categories = np.array(["a","b","c","d"],dtype=object)
         self.assert_numpy_array_equal(res.__array__(), exp_val)
-        self.assert_numpy_array_equal(res.levels, exp_levels)
+        self.assert_numpy_array_equal(res.categories, exp_categories)
 
     def test_slicing(self):
         cat = Series(Categorical([1,2,3,4]))
@@ -1425,13 +1431,13 @@ class TestCategoricalAsBlock(tm.TestCase):
         #   - returning a row
         #   - returning a single value
 
-        cats = pd.Categorical(["a","c","b","c","c","c","c"], levels=["a","b","c"])
+        cats = pd.Categorical(["a","c","b","c","c","c","c"], categories=["a","b","c"])
         idx = pd.Index(["h","i","j","k","l","m","n"])
         values= [1,2,3,4,5,6,7]
         df = pd.DataFrame({"cats":cats,"values":values}, index=idx)
 
         # the expected values
-        cats2 = pd.Categorical(["b","c"], levels=["a","b","c"])
+        cats2 = pd.Categorical(["b","c"], categories=["a","b","c"])
         idx2 = pd.Index(["j","k"])
         values2= [3,4]
 
@@ -1556,13 +1562,13 @@ class TestCategoricalAsBlock(tm.TestCase):
     def test_slicing_doc_examples(self):
 
         #GH 7918
-        cats = Categorical(["a","b","b","b","c","c","c"], levels=["a","b","c"])
+        cats = Categorical(["a","b","b","b","c","c","c"], categories=["a","b","c"])
         idx = Index(["h","i","j","k","l","m","n",])
         values= [1,2,2,2,3,4,5]
         df = DataFrame({"cats":cats,"values":values}, index=idx)
 
         result = df.iloc[2:4,:]
-        expected = DataFrame({"cats":Categorical(['b','b'],levels=['a','b','c']),"values":[2,2]}, index=['j','k'])
+        expected = DataFrame({"cats":Categorical(['b','b'],categories=['a','b','c']),"values":[2,2]}, index=['j','k'])
         tm.assert_frame_equal(result, expected)
 
         result = df.iloc[2:4,:].dtypes
@@ -1570,50 +1576,50 @@ class TestCategoricalAsBlock(tm.TestCase):
         tm.assert_series_equal(result, expected)
 
         result = df.loc["h":"j","cats"]
-        expected = Series(Categorical(['a','b','b'],levels=['a','b','c']),index=['h','i','j'])
+        expected = Series(Categorical(['a','b','b'],categories=['a','b','c']),index=['h','i','j'])
         tm.assert_series_equal(result, expected)
 
         result = df.ix["h":"j",0:1]
-        expected = DataFrame({'cats' : Series(Categorical(['a','b','b'],levels=['a','b','c']),index=['h','i','j']) })
+        expected = DataFrame({'cats' : Series(Categorical(['a','b','b'],categories=['a','b','c']),index=['h','i','j']) })
         tm.assert_frame_equal(result, expected)
 
     def test_assigning_ops(self):
 
         # systematically test the assigning operations:
         # for all slicing ops:
-        #  for value in levels and value not in levels:
+        #  for value in categories and value not in categories:
         #   - assign a single value -> exp_single_cats_value
         #   - assign a complete row (mixed values) -> exp_single_row
         #   - assign multiple rows (mixed values) (-> array) -> exp_multi_row
         #   - assign a part of a column with dtype == categorical -> exp_parts_cats_col
         #   - assign a part of a column with dtype != categorical -> exp_parts_cats_col
 
-        cats = pd.Categorical(["a","a","a","a","a","a","a"], levels=["a","b"])
+        cats = pd.Categorical(["a","a","a","a","a","a","a"], categories=["a","b"])
         idx = pd.Index(["h","i","j","k","l","m","n"])
         values = [1,1,1,1,1,1,1]
         orig = pd.DataFrame({"cats":cats,"values":values}, index=idx)
 
         ### the expected values
         # changed single row
-        cats1 = pd.Categorical(["a","a","b","a","a","a","a"], levels=["a","b"])
+        cats1 = pd.Categorical(["a","a","b","a","a","a","a"], categories=["a","b"])
         idx1 = pd.Index(["h","i","j","k","l","m","n"])
         values1 = [1,1,2,1,1,1,1]
         exp_single_row = pd.DataFrame({"cats":cats1,"values":values1}, index=idx1)
 
         #changed multiple rows
-        cats2 = pd.Categorical(["a","a","b","b","a","a","a"], levels=["a","b"])
+        cats2 = pd.Categorical(["a","a","b","b","a","a","a"], categories=["a","b"])
         idx2 = pd.Index(["h","i","j","k","l","m","n"])
         values2 = [1,1,2,2,1,1,1]
         exp_multi_row = pd.DataFrame({"cats":cats2,"values":values2}, index=idx2)
 
         # changed part of the cats column
-        cats3 = pd.Categorical(["a","a","b","b","a","a","a"], levels=["a","b"])
+        cats3 = pd.Categorical(["a","a","b","b","a","a","a"], categories=["a","b"])
         idx3 = pd.Index(["h","i","j","k","l","m","n"])
         values3 = [1,1,1,1,1,1,1]
         exp_parts_cats_col = pd.DataFrame({"cats":cats3,"values":values3}, index=idx3)
 
         # changed single value in cats col
-        cats4 = pd.Categorical(["a","a","b","a","a","a","a"], levels=["a","b"])
+        cats4 = pd.Categorical(["a","a","b","a","a","a","a"], categories=["a","b"])
         idx4 = pd.Index(["h","i","j","k","l","m","n"])
         values4 = [1,1,1,1,1,1,1]
         exp_single_cats_value = pd.DataFrame({"cats":cats4,"values":values4}, index=idx4)
@@ -1631,7 +1637,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         tm.assert_frame_equal(df, exp_single_cats_value)
 
 
-        #   - assign a single value not in the current level set
+        #   - assign a single value not in the current categories set
         def f():
             df = orig.copy()
             df.iloc[2,0] = "c"
@@ -1642,7 +1648,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         df.iloc[2,:] = ["b",2]
         tm.assert_frame_equal(df, exp_single_row)
 
-        #   - assign a complete row (mixed values) not in level set
+        #   - assign a complete row (mixed values) not in categories set
         def f():
             df = orig.copy()
             df.iloc[2,:] = ["c",2]
@@ -1660,18 +1666,18 @@ class TestCategoricalAsBlock(tm.TestCase):
 
         #   - assign a part of a column with dtype == categorical -> exp_parts_cats_col
         df = orig.copy()
-        df.iloc[2:4,0] = pd.Categorical(["b","b"], levels=["a","b"])
+        df.iloc[2:4,0] = pd.Categorical(["b","b"], categories=["a","b"])
         tm.assert_frame_equal(df, exp_parts_cats_col)
 
         with tm.assertRaises(ValueError):
-            # different levels -> not sure if this should fail or pass
+            # different categories -> not sure if this should fail or pass
             df = orig.copy()
-            df.iloc[2:4,0] = pd.Categorical(["b","b"], levels=["a","b","c"])
+            df.iloc[2:4,0] = pd.Categorical(["b","b"], categories=["a","b","c"])
 
         with tm.assertRaises(ValueError):
             # different values
             df = orig.copy()
-            df.iloc[2:4,0] = pd.Categorical(["c","c"], levels=["a","b","c"])
+            df.iloc[2:4,0] = pd.Categorical(["c","c"], categories=["a","b","c"])
 
         #   - assign a part of a column with dtype != categorical -> exp_parts_cats_col
         df = orig.copy()
@@ -1692,7 +1698,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         df.loc[df.index == "j","cats"] = "b"
         tm.assert_frame_equal(df, exp_single_cats_value)
 
-        #   - assign a single value not in the current level set
+        #   - assign a single value not in the current categories set
         def f():
             df = orig.copy()
             df.loc["j","cats"] = "c"
@@ -1703,7 +1709,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         df.loc["j",:] = ["b",2]
         tm.assert_frame_equal(df, exp_single_row)
 
-        #   - assign a complete row (mixed values) not in level set
+        #   - assign a complete row (mixed values) not in categories set
         def f():
             df = orig.copy()
             df.loc["j",:] = ["c",2]
@@ -1721,18 +1727,18 @@ class TestCategoricalAsBlock(tm.TestCase):
 
         #   - assign a part of a column with dtype == categorical -> exp_parts_cats_col
         df = orig.copy()
-        df.loc["j":"k","cats"] = pd.Categorical(["b","b"], levels=["a","b"])
+        df.loc["j":"k","cats"] = pd.Categorical(["b","b"], categories=["a","b"])
         tm.assert_frame_equal(df, exp_parts_cats_col)
 
         with tm.assertRaises(ValueError):
-            # different levels -> not sure if this should fail or pass
+            # different categories -> not sure if this should fail or pass
             df = orig.copy()
-            df.loc["j":"k","cats"] = pd.Categorical(["b","b"], levels=["a","b","c"])
+            df.loc["j":"k","cats"] = pd.Categorical(["b","b"], categories=["a","b","c"])
 
         with tm.assertRaises(ValueError):
             # different values
             df = orig.copy()
-            df.loc["j":"k","cats"] = pd.Categorical(["c","c"], levels=["a","b","c"])
+            df.loc["j":"k","cats"] = pd.Categorical(["c","c"], categories=["a","b","c"])
 
         #   - assign a part of a column with dtype != categorical -> exp_parts_cats_col
         df = orig.copy()
@@ -1753,7 +1759,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         df.ix[df.index == "j",0] = "b"
         tm.assert_frame_equal(df, exp_single_cats_value)
 
-        #   - assign a single value not in the current level set
+        #   - assign a single value not in the current categories set
         def f():
             df = orig.copy()
             df.ix["j",0] = "c"
@@ -1764,7 +1770,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         df.ix["j",:] = ["b",2]
         tm.assert_frame_equal(df, exp_single_row)
 
-        #   - assign a complete row (mixed values) not in level set
+        #   - assign a complete row (mixed values) not in categories set
         def f():
             df = orig.copy()
             df.ix["j",:] = ["c",2]
@@ -1782,18 +1788,18 @@ class TestCategoricalAsBlock(tm.TestCase):
 
         #   - assign a part of a column with dtype == categorical -> exp_parts_cats_col
         df = orig.copy()
-        df.ix["j":"k",0] = pd.Categorical(["b","b"], levels=["a","b"])
+        df.ix["j":"k",0] = pd.Categorical(["b","b"], categories=["a","b"])
         tm.assert_frame_equal(df, exp_parts_cats_col)
 
         with tm.assertRaises(ValueError):
-            # different levels -> not sure if this should fail or pass
+            # different categories -> not sure if this should fail or pass
             df = orig.copy()
-            df.ix["j":"k",0] = pd.Categorical(["b","b"], levels=["a","b","c"])
+            df.ix["j":"k",0] = pd.Categorical(["b","b"], categories=["a","b","c"])
 
         with tm.assertRaises(ValueError):
             # different values
             df = orig.copy()
-            df.ix["j":"k",0] = pd.Categorical(["c","c"], levels=["a","b","c"])
+            df.ix["j":"k",0] = pd.Categorical(["c","c"], categories=["a","b","c"])
 
         #   - assign a part of a column with dtype != categorical -> exp_parts_cats_col
         df = orig.copy()
@@ -1808,7 +1814,7 @@ class TestCategoricalAsBlock(tm.TestCase):
         df.iat[2,0] = "b"
         tm.assert_frame_equal(df, exp_single_cats_value)
 
-        #   - assign a single value not in the current level set
+        #   - assign a single value not in the current categories set
         def f():
             df = orig.copy()
             df.iat[2,0] = "c"
@@ -1820,20 +1826,20 @@ class TestCategoricalAsBlock(tm.TestCase):
         df.at["j","cats"] = "b"
         tm.assert_frame_equal(df, exp_single_cats_value)
 
-        #   - assign a single value not in the current level set
+        #   - assign a single value not in the current categories set
         def f():
             df = orig.copy()
             df.at["j","cats"] = "c"
         self.assertRaises(ValueError, f)
 
         # fancy indexing
-        catsf = pd.Categorical(["a","a","c","c","a","a","a"], levels=["a","b","c"])
+        catsf = pd.Categorical(["a","a","c","c","a","a","a"], categories=["a","b","c"])
         idxf = pd.Index(["h","i","j","k","l","m","n"])
         valuesf = [1,1,3,3,1,1,1]
         df = pd.DataFrame({"cats":catsf,"values":valuesf}, index=idxf)
 
         exp_fancy = exp_multi_row.copy()
-        exp_fancy["cats"].cat.levels = ["a","b","c"]
+        exp_fancy["cats"].cat.categories = ["a","b","c"]
 
         df[df["cats"] == "c"] = ["b",2]
         tm.assert_frame_equal(df, exp_multi_row)
@@ -1851,36 +1857,36 @@ class TestCategoricalAsBlock(tm.TestCase):
         # Assigning a Category to parts of a int/... column uses the values of the Catgorical
         df = pd.DataFrame({"a":[1,1,1,1,1], "b":["a","a","a","a","a"]})
         exp = pd.DataFrame({"a":[1,"b","b",1,1], "b":["a","a","b","b","a"]})
-        df.loc[1:2,"a"] = pd.Categorical(["b","b"], levels=["a","b"])
-        df.loc[2:3,"b"] = pd.Categorical(["b","b"], levels=["a","b"])
+        df.loc[1:2,"a"] = pd.Categorical(["b","b"], categories=["a","b"])
+        df.loc[2:3,"b"] = pd.Categorical(["b","b"], categories=["a","b"])
         tm.assert_frame_equal(df, exp)
 
         ######### Series ##########
-        orig = Series(pd.Categorical(["b","b"], levels=["a","b"]))
+        orig = Series(pd.Categorical(["b","b"], categories=["a","b"]))
         s = orig.copy()
         s[:] = "a"
-        exp = Series(pd.Categorical(["a","a"], levels=["a","b"]))
+        exp = Series(pd.Categorical(["a","a"], categories=["a","b"]))
         tm.assert_series_equal(s, exp)
 
         s = orig.copy()
         s[1] = "a"
-        exp = Series(pd.Categorical(["b","a"], levels=["a","b"]))
+        exp = Series(pd.Categorical(["b","a"], categories=["a","b"]))
         tm.assert_series_equal(s, exp)
 
         s = orig.copy()
         s[s.index > 0] = "a"
-        exp = Series(pd.Categorical(["b","a"], levels=["a","b"]))
+        exp = Series(pd.Categorical(["b","a"], categories=["a","b"]))
         tm.assert_series_equal(s, exp)
 
         s = orig.copy()
         s[[False, True]] = "a"
-        exp = Series(pd.Categorical(["b","a"], levels=["a","b"]))
+        exp = Series(pd.Categorical(["b","a"], categories=["a","b"]))
         tm.assert_series_equal(s, exp)
 
         s = orig.copy()
         s.index = ["x", "y"]
         s["y"] = "a"
-        exp = Series(pd.Categorical(["b","a"], levels=["a","b"]), index=["x", "y"])
+        exp = Series(pd.Categorical(["b","a"], categories=["a","b"]), index=["x", "y"])
         tm.assert_series_equal(s, exp)
 
         # ensure that one can set something to np.nan
@@ -1894,14 +1900,14 @@ class TestCategoricalAsBlock(tm.TestCase):
         tests_data = [(list("abc"), list("cba"), list("bbb")),
                       ([1,2,3], [3,2,1], [2,2,2])]
         for data , reverse, base in tests_data:
-            cat_rev = pd.Series(pd.Categorical(data, levels=reverse))
-            cat_rev_base = pd.Series(pd.Categorical(base, levels=reverse))
+            cat_rev = pd.Series(pd.Categorical(data, categories=reverse))
+            cat_rev_base = pd.Series(pd.Categorical(base, categories=reverse))
             cat = pd.Series(pd.Categorical(data))
-            cat_base = pd.Series(pd.Categorical(base, levels=cat.cat.levels))
+            cat_base = pd.Series(pd.Categorical(base, categories=cat.cat.categories))
             s = Series(base)
             a = np.array(base)
 
-            # comparisons need to take level ordering into account
+            # comparisons need to take categories ordering into account
             res_rev = cat_rev > cat_rev_base
             exp_rev = Series([True, False, False])
             tm.assert_series_equal(res_rev, exp_rev)
@@ -1914,7 +1920,7 @@ class TestCategoricalAsBlock(tm.TestCase):
             exp = Series([False, False, True])
             tm.assert_series_equal(res, exp)
 
-            # Only categories with same levels can be compared
+            # Only categories with same categories can be compared
             def f():
                 cat > cat_rev
             self.assertRaises(TypeError, f)
@@ -1943,73 +1949,73 @@ class TestCategoricalAsBlock(tm.TestCase):
         tm.assert_series_equal(res, exp)
 
     def test_concat(self):
-        cat = pd.Categorical(["a","b"], levels=["a","b"])
+        cat = pd.Categorical(["a","b"], categories=["a","b"])
         vals = [1,2]
         df = pd.DataFrame({"cats":cat, "vals":vals})
-        cat2 = pd.Categorical(["a","b","a","b"], levels=["a","b"])
+        cat2 = pd.Categorical(["a","b","a","b"], categories=["a","b"])
         vals2 = [1,2,1,2]
         exp = pd.DataFrame({"cats":cat2, "vals":vals2}, index=pd.Index([0, 1, 0, 1]))
 
         res = pd.concat([df,df])
         tm.assert_frame_equal(exp, res)
 
-        # Concat should raise if the two categoricals do not have the same levels
-        cat3 = pd.Categorical(["a","b"], levels=["a","b","c"])
+        # Concat should raise if the two categoricals do not have the same categories
+        cat3 = pd.Categorical(["a","b"], categories=["a","b","c"])
         vals3 = [1,2]
-        df_wrong_levels = pd.DataFrame({"cats":cat3, "vals":vals3})
+        df_wrong_categories = pd.DataFrame({"cats":cat3, "vals":vals3})
 
         def f():
-            pd.concat([df,df_wrong_levels])
+            pd.concat([df,df_wrong_categories])
         self.assertRaises(ValueError, f)
 
         # GH 7864
         # make sure ordering is preserverd
         df = pd.DataFrame({"id":[1,2,3,4,5,6], "raw_grade":['a', 'b', 'b', 'a', 'a', 'e']})
         df["grade"] = pd.Categorical(df["raw_grade"])
-        df['grade'].cat.reorder_levels(['e', 'a', 'b'])
+        df['grade'].cat.reorder_categories(['e', 'a', 'b'])
 
         df1 = df[0:3]
         df2 = df[3:]
 
-        self.assert_numpy_array_equal(df['grade'].cat.levels, df1['grade'].cat.levels)
-        self.assert_numpy_array_equal(df['grade'].cat.levels, df2['grade'].cat.levels)
+        self.assert_numpy_array_equal(df['grade'].cat.categories, df1['grade'].cat.categories)
+        self.assert_numpy_array_equal(df['grade'].cat.categories, df2['grade'].cat.categories)
 
         dfx = pd.concat([df1, df2])
-        dfx['grade'].cat.levels
-        self.assert_numpy_array_equal(df['grade'].cat.levels, dfx['grade'].cat.levels)
+        dfx['grade'].cat.categories
+        self.assert_numpy_array_equal(df['grade'].cat.categories, dfx['grade'].cat.categories)
 
     def test_append(self):
-        cat = pd.Categorical(["a","b"], levels=["a","b"])
+        cat = pd.Categorical(["a","b"], categories=["a","b"])
         vals = [1,2]
         df = pd.DataFrame({"cats":cat, "vals":vals})
-        cat2 = pd.Categorical(["a","b","a","b"], levels=["a","b"])
+        cat2 = pd.Categorical(["a","b","a","b"], categories=["a","b"])
         vals2 = [1,2,1,2]
         exp = pd.DataFrame({"cats":cat2, "vals":vals2}, index=pd.Index([0, 1, 0, 1]))
 
         res = df.append(df)
         tm.assert_frame_equal(exp, res)
 
-        # Concat should raise if the two categoricals do not have the same levels
-        cat3 = pd.Categorical(["a","b"], levels=["a","b","c"])
+        # Concat should raise if the two categoricals do not have the same categories
+        cat3 = pd.Categorical(["a","b"], categories=["a","b","c"])
         vals3 = [1,2]
-        df_wrong_levels = pd.DataFrame({"cats":cat3, "vals":vals3})
+        df_wrong_categories = pd.DataFrame({"cats":cat3, "vals":vals3})
 
         def f():
-            df.append(df_wrong_levels)
+            df.append(df_wrong_categories)
         self.assertRaises(ValueError, f)
 
     def test_na_actions(self):
 
-        cat = pd.Categorical([1,2,3,np.nan], levels=[1,2,3])
+        cat = pd.Categorical([1,2,3,np.nan], categories=[1,2,3])
         vals = ["a","b",np.nan,"d"]
         df = pd.DataFrame({"cats":cat, "vals":vals})
-        cat2 = pd.Categorical([1,2,3,3], levels=[1,2,3])
+        cat2 = pd.Categorical([1,2,3,3], categories=[1,2,3])
         vals2 = ["a","b","b","d"]
         df_exp_fill = pd.DataFrame({"cats":cat2, "vals":vals2})
-        cat3 = pd.Categorical([1,2,3], levels=[1,2,3])
+        cat3 = pd.Categorical([1,2,3], categories=[1,2,3])
         vals3 = ["a","b",np.nan]
         df_exp_drop_cats = pd.DataFrame({"cats":cat3, "vals":vals3})
-        cat4 = pd.Categorical([1,2], levels=[1,2,3])
+        cat4 = pd.Categorical([1,2], categories=[1,2,3])
         vals4 = ["a","b"]
         df_exp_drop_all = pd.DataFrame({"cats":cat4, "vals":vals4})
 
@@ -2030,9 +2036,9 @@ class TestCategoricalAsBlock(tm.TestCase):
         res = df.dropna()
         tm.assert_frame_equal(res, df_exp_drop_all)
 
-        # make sure that fillna takes both missing values and NA levels into account
+        # make sure that fillna takes both missing values and NA categories into account
         c = Categorical(["a","b",np.nan])
-        c.levels = ["a","b",np.nan]
+        c.categories = ["a","b",np.nan]
         c[0] = np.nan
         df = pd.DataFrame({"cats":c, "vals":[1,2,3]})
         df_exp = pd.DataFrame({"cats": Categorical(["a","b","a"]), "vals": [1,2,3]})
@@ -2091,7 +2097,8 @@ class TestCategoricalAsBlock(tm.TestCase):
 
     def test_cat_tab_completition(self):
          # test the tab completion display
-        ok_for_cat = ['levels','codes','ordered','reorder_levels','remove_unused_levels']
+        ok_for_cat = ['categories','codes','ordered','reorder_categories',
+                      'remove_unused_categories']
         def get_dir(s):
             results = [ r for r in s.cat.__dir__() if not r.startswith('_') ]
             return list(sorted(set(results)))
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index f1b54ecd9..c6b5ff176 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -1764,11 +1764,14 @@ class TestGroupBy(tm.TestCase):
         df = pd.DataFrame(np.random.randint(1, 50, (1000, 2)),
                           columns=['jim', 'joe'])
         df['jolie'] = np.random.randn(1000)
+        print(df.head())
 
         for keys in ['jim', ['jim', 'joe']]:  # single key & multi-key
+            if keys == 'jim': continue
             for f in [max, min, sum]:
                 fname = f.__name__
                 result = df.groupby(keys).apply(f)
+                _shape = result.shape
                 ngroups = len(df.drop_duplicates(subset=keys))
                 assert result.shape == (ngroups, 3), 'invalid frame shape: '\
                         '{} (expected ({}, 3))'.format(result.shape, ngroups)
@@ -3267,10 +3270,11 @@ class TestGroupBy(tm.TestCase):
         cats = Categorical.from_codes(codes, [0, 1, 2, 3])
 
         result = data.groupby(cats).mean()
-        exp = data.groupby(codes).mean().reindex(cats.levels)
+        exp = data.groupby(codes).mean().reindex(cats.categories)
         assert_series_equal(result, exp)
 
-        cats = Categorical(["a", "a", "a", "b", "b", "b", "c", "c", "c"], levels=["a","b","c","d"])
+        cats = Categorical(["a", "a", "a", "b", "b", "b", "c", "c", "c"],
+                           categories=["a","b","c","d"])
         data = DataFrame({"a":[1,1,1,2,2,2,3,4,5], "b":cats})
 
         result = data.groupby("b").mean()
diff --git a/pandas/tools/merge.py b/pandas/tools/merge.py
index 7b7446a86..c9935bf39 100644
--- a/pandas/tools/merge.py
+++ b/pandas/tools/merge.py
@@ -997,7 +997,7 @@ def _make_concat_multiindex(indexes, keys, levels=None, names=None):
             names = [None] * len(zipped)
 
         if levels is None:
-            levels = [Categorical.from_array(zp).levels for zp in zipped]
+            levels = [Categorical.from_array(zp).categories for zp in zipped]
         else:
             levels = [_ensure_index(x) for x in levels]
     else:
@@ -1036,7 +1036,7 @@ def _make_concat_multiindex(indexes, keys, levels=None, names=None):
             label_list.extend(concat_index.labels)
         else:
             factor = Categorical.from_array(concat_index)
-            levels.append(factor.levels)
+            levels.append(factor.categories)
             label_list.append(factor.codes)
 
         if len(names) == len(levels):
diff --git a/pandas/tools/tests/test_tile.py b/pandas/tools/tests/test_tile.py
index 813682bee..3bdd49673 100644
--- a/pandas/tools/tests/test_tile.py
+++ b/pandas/tools/tests/test_tile.py
@@ -76,12 +76,12 @@ class TestCut(tm.TestCase):
         result, bins = cut(arr, 4, retbins=True)
         ex_levels = ['(-0.001, 0.25]', '(0.25, 0.5]', '(0.5, 0.75]',
                      '(0.75, 1]']
-        self.assert_numpy_array_equal(result.levels, ex_levels)
+        self.assert_numpy_array_equal(result.categories, ex_levels)
 
         result, bins = cut(arr, 4, retbins=True, right=False)
         ex_levels = ['[0, 0.25)', '[0.25, 0.5)', '[0.5, 0.75)',
                      '[0.75, 1.001)']
-        self.assert_numpy_array_equal(result.levels, ex_levels)
+        self.assert_numpy_array_equal(result.categories, ex_levels)
 
     def test_cut_pass_series_name_to_factor(self):
         s = Series(np.random.randn(100), name='foo')
@@ -95,7 +95,7 @@ class TestCut(tm.TestCase):
         result = cut(arr, 4, precision=2)
         ex_levels = ['(-0.00072, 0.18]', '(0.18, 0.36]', '(0.36, 0.54]',
                      '(0.54, 0.72]']
-        self.assert_numpy_array_equal(result.levels, ex_levels)
+        self.assert_numpy_array_equal(result.categories, ex_levels)
 
     def test_na_handling(self):
         arr = np.arange(0, 0.75, 0.01)
@@ -120,10 +120,10 @@ class TestCut(tm.TestCase):
         result = cut(data, [-np.inf, 2, 4, np.inf])
         result_ser = cut(data_ser, [-np.inf, 2, 4, np.inf])
 
-        ex_levels = ['(-inf, 2]', '(2, 4]', '(4, inf]']
+        ex_categories = ['(-inf, 2]', '(2, 4]', '(4, inf]']
 
-        np.testing.assert_array_equal(result.levels, ex_levels)
-        np.testing.assert_array_equal(result_ser.cat.levels, ex_levels)
+        np.testing.assert_array_equal(result.categories, ex_categories)
+        np.testing.assert_array_equal(result_ser.cat.categories, ex_categories)
         self.assertEqual(result[5], '(4, inf]')
         self.assertEqual(result[0], '(-inf, 2]')
         self.assertEqual(result_ser[5], '(4, inf]')
@@ -172,7 +172,7 @@ class TestCut(tm.TestCase):
         result = cut(arr, bins, labels=labels)
 
         exp = cut(arr, bins)
-        exp.levels = labels
+        exp.categories = labels
 
         self.assertTrue(result.equals(exp))
 
@@ -182,7 +182,7 @@ class TestCut(tm.TestCase):
         cats = qcut(values, 4)
 
         ex_levels = ['[0, 2.25]', '(2.25, 4.5]', '(4.5, 6.75]', '(6.75, 9]']
-        self.assertTrue((cats.levels == ex_levels).all())
+        self.assertTrue((cats.categories == ex_levels).all())
 
     def test_qcut_nas(self):
         arr = np.random.randn(100)
@@ -216,7 +216,7 @@ class TestCut(tm.TestCase):
 
         starts = []
         ends = []
-        for lev in result.levels:
+        for lev in result.categories:
             s, e = lev[1:-1].split(',')
 
             self.assertTrue(s != e)

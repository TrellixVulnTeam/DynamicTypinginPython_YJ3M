commit 2d134107ffc14c40ac9f7bd425ed55dfb7ba598d
Author: sinhrks <sinhrks@gmail.com>
Date:   Sun Apr 3 13:36:49 2016 +0900

    BUG: to_dense does not preserve dtype in SparseArray
    
    closes #12778
    closes #10648

diff --git a/doc/source/whatsnew/v0.18.1.txt b/doc/source/whatsnew/v0.18.1.txt
index 96f747b6e..4927180f3 100644
--- a/doc/source/whatsnew/v0.18.1.txt
+++ b/doc/source/whatsnew/v0.18.1.txt
@@ -72,13 +72,14 @@ Other Enhancements
 Sparse changes
 ~~~~~~~~~~~~~~
 
-These changes conform sparse handling to return the correct types & work smoother with indexing.
+These changes conform sparse handling to return the correct types and work to make a smoother experience with indexing.
 
 - Bug in ``SparseSeries.loc[]`` with list-like input raises ``TypeError`` (:issue:`10560`)
 - Bug in ``SparseSeries.iloc[]`` with scalar input may raise ``IndexError`` (:issue:`10560`)
 - Bug in ``SparseSeries.loc[]``, ``.iloc[]`` with ``slice`` returns ``SparseArray``, rather than ``SparseSeries`` (:issue:`10560`)
 - Bug in ``SparseSeries.__repr__`` raises ``TypeError`` when it is longer than ``max_rows`` (:issue:`10560`)
 - Bug in ``SparseSeries.shape`` ignores ``fill_value`` (:issue:`10452`)
+- Bug in ``SparseArray.to_dense()`` does not preserve ``dtype`` (:issue:`10648`)
 - ``SparseArray.take`` now returns scalar for scalar input, ``SparseArray`` for others (:issue:`10560`)
 
   .. ipython:: python
diff --git a/pandas/sparse/array.py b/pandas/sparse/array.py
index 35b2a4bf6..a01f9a96b 100644
--- a/pandas/sparse/array.py
+++ b/pandas/sparse/array.py
@@ -237,7 +237,7 @@ class SparseArray(PandasObject, np.ndarray):
         """
         Dense values
         """
-        output = np.empty(len(self), dtype=np.float64)
+        output = np.empty(len(self), dtype=self.dtype)
         int_index = self.sp_index.to_int_index()
         output.fill(self.fill_value)
         output.put(int_index.indices, self)
@@ -261,8 +261,8 @@ class SparseArray(PandasObject, np.ndarray):
         # fill the nans
         if fill is None:
             fill = self.fill_value
-        if not np.isnan(fill):
-            values[np.isnan(values)] = fill
+        if not com.isnull(fill):
+            values[com.isnull(values)] = fill
 
         return values
 
diff --git a/pandas/sparse/tests/test_array.py b/pandas/sparse/tests/test_array.py
index a0b505ff4..f1a0e0dc1 100644
--- a/pandas/sparse/tests/test_array.py
+++ b/pandas/sparse/tests/test_array.py
@@ -74,6 +74,34 @@ class TestSparseArray(tm.TestCase):
         not_copy.sp_values[:3] = 0
         self.assertTrue((self.arr.sp_values[:3] == 0).all())
 
+    def test_constructor_bool(self):
+        # GH 10648
+        data = np.array([False, False, True, True, False, False])
+        arr = SparseArray(data, fill_value=False, dtype=bool)
+
+        self.assertEqual(arr.dtype, bool)
+        tm.assert_numpy_array_equal(arr.sp_values, np.array([True, True]))
+        tm.assert_numpy_array_equal(arr.sp_values, np.asarray(arr))
+        tm.assert_numpy_array_equal(arr.sp_index.indices, np.array([2, 3]))
+
+        for dense in [arr.to_dense(), arr.values]:
+            self.assertEqual(dense.dtype, bool)
+            tm.assert_numpy_array_equal(dense, data)
+
+    def test_constructor_float32(self):
+        # GH 10648
+        data = np.array([1., np.nan, 3], dtype=np.float32)
+        arr = SparseArray(data, dtype=np.float32)
+
+        self.assertEqual(arr.dtype, np.float32)
+        tm.assert_numpy_array_equal(arr.sp_values, np.array([1, 3]))
+        tm.assert_numpy_array_equal(arr.sp_values, np.asarray(arr))
+        tm.assert_numpy_array_equal(arr.sp_index.indices, np.array([0, 2]))
+
+        for dense in [arr.to_dense(), arr.values]:
+            self.assertEqual(dense.dtype, np.float32)
+            self.assert_numpy_array_equal(dense, data)
+
     def test_astype(self):
         res = self.arr.astype('f8')
         res.sp_values[:3] = 27

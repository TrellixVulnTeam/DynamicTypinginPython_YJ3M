commit 9088f5ebbaf098bd7113bfba7eaa6dcdbf0b4c3d
Author: Abdullah İhsan Seçer <abdullahsecer@std.sehir.edu.tr>
Date:   Fri Jun 21 20:01:34 2019 +0300

    BUG: Fix rolling median and quantile with closed='left' and closed='neither' (#26005) (#26910)

diff --git a/doc/source/whatsnew/v0.25.0.rst b/doc/source/whatsnew/v0.25.0.rst
index 275be4ff5..5e5a2aed3 100644
--- a/doc/source/whatsnew/v0.25.0.rst
+++ b/doc/source/whatsnew/v0.25.0.rst
@@ -747,6 +747,7 @@ Groupby/Resample/Rolling
 - Bug in :meth:`pandas.core.frame.DataFrame.groupby` where passing a :class:`pandas.core.groupby.grouper.Grouper` would return incorrect groups when using the ``.groups`` accessor (:issue:`26326`)
 - Bug in :meth:`pandas.core.groupby.GroupBy.agg` where incorrect results are returned for uint64 columns. (:issue:`26310`)
 - Bug in :meth:`pandas.core.window.Rolling.median` and :meth:`pandas.core.window.Rolling.quantile` where MemoryError is raised with empty window (:issue:`26005`)
+- Bug in :meth:`pandas.core.window.Rolling.median` and :meth:`pandas.core.window.Rolling.quantile` where incorrect results are returned with ``closed='left'`` and ``closed='neither'`` (:issue:`26005`)
 
 Reshaping
 ^^^^^^^^^
diff --git a/pandas/_libs/window.pyx b/pandas/_libs/window.pyx
index 3305fea06..df86f395d 100644
--- a/pandas/_libs/window.pyx
+++ b/pandas/_libs/window.pyx
@@ -1116,21 +1116,15 @@ def roll_median_c(ndarray[float64_t] values, int64_t win, int64_t minp,
             if i == 0:
 
                 # setup
-                val = values[i]
-                if notnan(val):
-                    nobs += 1
-                    err = skiplist_insert(sl, val) != 1
-                    if err:
-                        break
-
-            else:
-
-                # calculate deletes
-                for j in range(start[i - 1], s):
+                for j in range(s, e):
                     val = values[j]
                     if notnan(val):
-                        skiplist_remove(sl, val)
-                        nobs -= 1
+                        nobs += 1
+                        err = skiplist_insert(sl, val) != 1
+                        if err:
+                            break
+
+            else:
 
                 # calculate adds
                 for j in range(end[i - 1], e):
@@ -1141,6 +1135,13 @@ def roll_median_c(ndarray[float64_t] values, int64_t win, int64_t minp,
                         if err:
                             break
 
+                # calculate deletes
+                for j in range(start[i - 1], s):
+                    val = values[j]
+                    if notnan(val):
+                        skiplist_remove(sl, val)
+                        nobs -= 1
+
             if nobs >= minp:
                 midpoint = <int>(nobs / 2)
                 if nobs % 2:
@@ -1507,19 +1508,13 @@ def roll_quantile(ndarray[float64_t, cast=True] values, int64_t win,
             if i == 0:
 
                 # setup
-                val = values[i]
-                if notnan(val):
-                    nobs += 1
-                    skiplist_insert(skiplist, val)
-
-            else:
-
-                # calculate deletes
-                for j in range(start[i - 1], s):
+                for j in range(s, e):
                     val = values[j]
                     if notnan(val):
-                        skiplist_remove(skiplist, val)
-                        nobs -= 1
+                        nobs += 1
+                        skiplist_insert(skiplist, val)
+
+            else:
 
                 # calculate adds
                 for j in range(end[i - 1], e):
@@ -1528,6 +1523,13 @@ def roll_quantile(ndarray[float64_t, cast=True] values, int64_t win,
                         nobs += 1
                         skiplist_insert(skiplist, val)
 
+                # calculate deletes
+                for j in range(start[i - 1], s):
+                    val = values[j]
+                    if notnan(val):
+                        skiplist_remove(skiplist, val)
+                        nobs -= 1
+
             if nobs >= minp:
                 if nobs == 1:
                     # Single value in skip list
diff --git a/pandas/tests/test_window.py b/pandas/tests/test_window.py
index 31baf4475..9524a78da 100644
--- a/pandas/tests/test_window.py
+++ b/pandas/tests/test_window.py
@@ -594,6 +594,25 @@ class TestRolling(Base):
         expected = pd.Series(expected, index=ser.index)
         tm.assert_series_equal(result, expected)
 
+    @pytest.mark.parametrize("closed,expected", [
+        ('right', [0, 0.5, 1, 2, 3, 4, 5, 6, 7, 8]),
+        ('both', [0, 0.5, 1, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5]),
+        ('neither', [np.nan, 0, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5]),
+        ('left', [np.nan, 0, 0.5, 1, 2, 3, 4, 5, 6, 7])
+    ])
+    def test_closed_median_quantile(self, closed, expected):
+        # GH 26005
+        ser = pd.Series(data=np.arange(10),
+                        index=pd.date_range('2000', periods=10))
+        roll = ser.rolling('3D', closed=closed)
+        expected = pd.Series(expected, index=ser.index)
+
+        result = roll.median()
+        tm.assert_series_equal(result, expected)
+
+        result = roll.quantile(0.5)
+        tm.assert_series_equal(result, expected)
+
     @pytest.mark.parametrize('roller', ['1s', 1])
     def tests_empty_df_rolling(self, roller):
         # GH 15819 Verifies that datetime and integer rolling windows can be

commit 2e38d5552a5c7b2c0091cecddd483f4f08ad1d2c
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon Feb 4 05:35:35 2019 -0800

    TST/REF: collect DataFrame reduction tests (#24914)

diff --git a/pandas/tests/frame/test_analytics.py b/pandas/tests/frame/test_analytics.py
index 456af34e7..2e690ebbf 100644
--- a/pandas/tests/frame/test_analytics.py
+++ b/pandas/tests/frame/test_analytics.py
@@ -231,9 +231,9 @@ def assert_bool_op_api(opname, bool_frame_with_na, float_string_frame,
         getattr(bool_frame_with_na, opname)(axis=1, bool_only=False)
 
 
-class TestDataFrameAnalytics():
+class TestDataFrameAnalytics(object):
 
-    # ---------------------------------------------------------------------=
+    # ---------------------------------------------------------------------
     # Correlation and covariance
 
     @td.skip_if_no_scipy
@@ -502,6 +502,9 @@ class TestDataFrameAnalytics():
         expected = Series(np.ones(len(result)))
         tm.assert_series_equal(result, expected)
 
+    # ---------------------------------------------------------------------
+    # Describe
+
     def test_bool_describe_in_mixed_frame(self):
         df = DataFrame({
             'string_data': ['a', 'b', 'c', 'd', 'e'],
@@ -693,82 +696,113 @@ class TestDataFrameAnalytics():
         result = df.describe(include='all')
         tm.assert_frame_equal(result, expected)
 
-    def test_reduce_mixed_frame(self):
-        # GH 6806
-        df = DataFrame({
-            'bool_data': [True, True, False, False, False],
-            'int_data': [10, 20, 30, 40, 50],
-            'string_data': ['a', 'b', 'c', 'd', 'e'],
-        })
-        df.reindex(columns=['bool_data', 'int_data', 'string_data'])
-        test = df.sum(axis=0)
-        tm.assert_numpy_array_equal(test.values,
-                                    np.array([2, 150, 'abcde'], dtype=object))
-        tm.assert_series_equal(test, df.T.sum(axis=1))
+    # ---------------------------------------------------------------------
+    # Reductions
 
-    def test_count(self, float_frame_with_na, float_frame, float_string_frame):
-        f = lambda s: notna(s).sum()
-        assert_stat_op_calc('count', f, float_frame_with_na, has_skipna=False,
-                            check_dtype=False, check_dates=True)
+    def test_stat_op_api(self, float_frame, float_string_frame):
         assert_stat_op_api('count', float_frame, float_string_frame,
                            has_numeric_only=True)
+        assert_stat_op_api('sum', float_frame, float_string_frame,
+                           has_numeric_only=True)
 
-        # corner case
-        frame = DataFrame()
-        ct1 = frame.count(1)
-        assert isinstance(ct1, Series)
+        assert_stat_op_api('nunique', float_frame, float_string_frame)
+        assert_stat_op_api('mean', float_frame, float_string_frame)
+        assert_stat_op_api('product', float_frame, float_string_frame)
+        assert_stat_op_api('median', float_frame, float_string_frame)
+        assert_stat_op_api('min', float_frame, float_string_frame)
+        assert_stat_op_api('max', float_frame, float_string_frame)
+        assert_stat_op_api('mad', float_frame, float_string_frame)
+        assert_stat_op_api('var', float_frame, float_string_frame)
+        assert_stat_op_api('std', float_frame, float_string_frame)
+        assert_stat_op_api('sem', float_frame, float_string_frame)
+        assert_stat_op_api('median', float_frame, float_string_frame)
 
-        ct2 = frame.count(0)
-        assert isinstance(ct2, Series)
+        try:
+            from scipy.stats import skew, kurtosis  # noqa:F401
+            assert_stat_op_api('skew', float_frame, float_string_frame)
+            assert_stat_op_api('kurt', float_frame, float_string_frame)
+        except ImportError:
+            pass
 
-        # GH 423
-        df = DataFrame(index=lrange(10))
-        result = df.count(1)
-        expected = Series(0, index=df.index)
-        tm.assert_series_equal(result, expected)
+    def test_stat_op_calc(self, float_frame_with_na, mixed_float_frame):
 
-        df = DataFrame(columns=lrange(10))
-        result = df.count(0)
-        expected = Series(0, index=df.columns)
-        tm.assert_series_equal(result, expected)
+        def count(s):
+            return notna(s).sum()
 
-        df = DataFrame()
-        result = df.count()
-        expected = Series(0, index=[])
-        tm.assert_series_equal(result, expected)
+        def nunique(s):
+            return len(algorithms.unique1d(s.dropna()))
 
-    def test_nunique(self, float_frame_with_na, float_frame,
-                     float_string_frame):
-        f = lambda s: len(algorithms.unique1d(s.dropna()))
-        assert_stat_op_calc('nunique', f, float_frame_with_na,
+        def mad(x):
+            return np.abs(x - x.mean()).mean()
+
+        def var(x):
+            return np.var(x, ddof=1)
+
+        def std(x):
+            return np.std(x, ddof=1)
+
+        def sem(x):
+            return np.std(x, ddof=1) / np.sqrt(len(x))
+
+        def skewness(x):
+            from scipy.stats import skew  # noqa:F811
+            if len(x) < 3:
+                return np.nan
+            return skew(x, bias=False)
+
+        def kurt(x):
+            from scipy.stats import kurtosis  # noqa:F811
+            if len(x) < 4:
+                return np.nan
+            return kurtosis(x, bias=False)
+
+        assert_stat_op_calc('nunique', nunique, float_frame_with_na,
                             has_skipna=False, check_dtype=False,
                             check_dates=True)
-        assert_stat_op_api('nunique', float_frame, float_string_frame)
 
-        df = DataFrame({'A': [1, 1, 1],
-                        'B': [1, 2, 3],
-                        'C': [1, np.nan, 3]})
-        tm.assert_series_equal(df.nunique(), Series({'A': 1, 'B': 3, 'C': 2}))
-        tm.assert_series_equal(df.nunique(dropna=False),
-                               Series({'A': 1, 'B': 3, 'C': 3}))
-        tm.assert_series_equal(df.nunique(axis=1), Series({0: 1, 1: 2, 2: 2}))
-        tm.assert_series_equal(df.nunique(axis=1, dropna=False),
-                               Series({0: 1, 1: 3, 2: 2}))
-
-    def test_sum(self, float_frame_with_na, mixed_float_frame,
-                 float_frame, float_string_frame):
-        assert_stat_op_api('sum', float_frame, float_string_frame,
-                           has_numeric_only=True)
-        assert_stat_op_calc('sum', np.sum, float_frame_with_na,
-                            skipna_alternative=np.nansum)
         # mixed types (with upcasting happening)
         assert_stat_op_calc('sum', np.sum, mixed_float_frame.astype('float32'),
                             check_dtype=False, check_less_precise=True)
 
+        assert_stat_op_calc('sum', np.sum, float_frame_with_na,
+                            skipna_alternative=np.nansum)
+        assert_stat_op_calc('mean', np.mean, float_frame_with_na,
+                            check_dates=True)
+        assert_stat_op_calc('product', np.prod, float_frame_with_na)
+
+        assert_stat_op_calc('mad', mad, float_frame_with_na)
+        assert_stat_op_calc('var', var, float_frame_with_na)
+        assert_stat_op_calc('std', std, float_frame_with_na)
+        assert_stat_op_calc('sem', sem, float_frame_with_na)
+
+        assert_stat_op_calc('count', count, float_frame_with_na,
+                            has_skipna=False, check_dtype=False,
+                            check_dates=True)
+
+        try:
+            from scipy import skew, kurtosis  # noqa:F401
+            assert_stat_op_calc('skew', skewness, float_frame_with_na)
+            assert_stat_op_calc('kurt', kurt, float_frame_with_na)
+        except ImportError:
+            pass
+
+    # TODO: Ensure warning isn't emitted in the first place
+    @pytest.mark.filterwarnings("ignore:All-NaN:RuntimeWarning")
+    def test_median(self, float_frame_with_na, int_frame):
+        def wrapper(x):
+            if isna(x).any():
+                return np.nan
+            return np.median(x)
+
+        assert_stat_op_calc('median', wrapper, float_frame_with_na,
+                            check_dates=True)
+        assert_stat_op_calc('median', wrapper, int_frame, check_dtype=False,
+                            check_dates=True)
+
     @pytest.mark.parametrize('method', ['sum', 'mean', 'prod', 'var',
                                         'std', 'skew', 'min', 'max'])
     def test_stat_operators_attempt_obj_array(self, method):
-        # GH 676
+        # GH#676
         data = {
             'a': [-0.00049987540199591344, -0.0016467257772919831,
                   0.00067695870775883013],
@@ -789,10 +823,44 @@ class TestDataFrameAnalytics():
             if method in ['sum', 'prod']:
                 tm.assert_series_equal(result, expected)
 
-    def test_mean(self, float_frame_with_na, float_frame, float_string_frame):
-        assert_stat_op_calc('mean', np.mean, float_frame_with_na,
-                            check_dates=True)
-        assert_stat_op_api('mean', float_frame, float_string_frame)
+    @pytest.mark.parametrize('op', ['mean', 'std', 'var',
+                                    'skew', 'kurt', 'sem'])
+    def test_mixed_ops(self, op):
+        # GH#16116
+        df = DataFrame({'int': [1, 2, 3, 4],
+                        'float': [1., 2., 3., 4.],
+                        'str': ['a', 'b', 'c', 'd']})
+
+        result = getattr(df, op)()
+        assert len(result) == 2
+
+        with pd.option_context('use_bottleneck', False):
+            result = getattr(df, op)()
+            assert len(result) == 2
+
+    def test_reduce_mixed_frame(self):
+        # GH 6806
+        df = DataFrame({
+            'bool_data': [True, True, False, False, False],
+            'int_data': [10, 20, 30, 40, 50],
+            'string_data': ['a', 'b', 'c', 'd', 'e'],
+        })
+        df.reindex(columns=['bool_data', 'int_data', 'string_data'])
+        test = df.sum(axis=0)
+        tm.assert_numpy_array_equal(test.values,
+                                    np.array([2, 150, 'abcde'], dtype=object))
+        tm.assert_series_equal(test, df.T.sum(axis=1))
+
+    def test_nunique(self):
+        df = DataFrame({'A': [1, 1, 1],
+                        'B': [1, 2, 3],
+                        'C': [1, np.nan, 3]})
+        tm.assert_series_equal(df.nunique(), Series({'A': 1, 'B': 3, 'C': 2}))
+        tm.assert_series_equal(df.nunique(dropna=False),
+                               Series({'A': 1, 'B': 3, 'C': 3}))
+        tm.assert_series_equal(df.nunique(axis=1), Series({0: 1, 1: 2, 2: 2}))
+        tm.assert_series_equal(df.nunique(axis=1, dropna=False),
+                               Series({0: 1, 1: 3, 2: 2}))
 
     @pytest.mark.parametrize('tz', [None, 'UTC'])
     def test_mean_mixed_datetime_numeric(self, tz):
@@ -813,103 +881,7 @@ class TestDataFrameAnalytics():
         expected = pd.Series()
         tm.assert_series_equal(result, expected)
 
-    def test_product(self, float_frame_with_na, float_frame,
-                     float_string_frame):
-        assert_stat_op_calc('product', np.prod, float_frame_with_na)
-        assert_stat_op_api('product', float_frame, float_string_frame)
-
-    # TODO: Ensure warning isn't emitted in the first place
-    @pytest.mark.filterwarnings("ignore:All-NaN:RuntimeWarning")
-    def test_median(self, float_frame_with_na, float_frame,
-                    float_string_frame):
-        def wrapper(x):
-            if isna(x).any():
-                return np.nan
-            return np.median(x)
-
-        assert_stat_op_calc('median', wrapper, float_frame_with_na,
-                            check_dates=True)
-        assert_stat_op_api('median', float_frame, float_string_frame)
-
-    def test_min(self, float_frame_with_na, int_frame,
-                 float_frame, float_string_frame):
-        with warnings.catch_warnings(record=True):
-            warnings.simplefilter("ignore", RuntimeWarning)
-            assert_stat_op_calc('min', np.min, float_frame_with_na,
-                                check_dates=True)
-        assert_stat_op_calc('min', np.min, int_frame)
-        assert_stat_op_api('min', float_frame, float_string_frame)
-
-    def test_cummin(self, datetime_frame):
-        datetime_frame.loc[5:10, 0] = np.nan
-        datetime_frame.loc[10:15, 1] = np.nan
-        datetime_frame.loc[15:, 2] = np.nan
-
-        # axis = 0
-        cummin = datetime_frame.cummin()
-        expected = datetime_frame.apply(Series.cummin)
-        tm.assert_frame_equal(cummin, expected)
-
-        # axis = 1
-        cummin = datetime_frame.cummin(axis=1)
-        expected = datetime_frame.apply(Series.cummin, axis=1)
-        tm.assert_frame_equal(cummin, expected)
-
-        # it works
-        df = DataFrame({'A': np.arange(20)}, index=np.arange(20))
-        result = df.cummin()  # noqa
-
-        # fix issue
-        cummin_xs = datetime_frame.cummin(axis=1)
-        assert np.shape(cummin_xs) == np.shape(datetime_frame)
-
-    def test_cummax(self, datetime_frame):
-        datetime_frame.loc[5:10, 0] = np.nan
-        datetime_frame.loc[10:15, 1] = np.nan
-        datetime_frame.loc[15:, 2] = np.nan
-
-        # axis = 0
-        cummax = datetime_frame.cummax()
-        expected = datetime_frame.apply(Series.cummax)
-        tm.assert_frame_equal(cummax, expected)
-
-        # axis = 1
-        cummax = datetime_frame.cummax(axis=1)
-        expected = datetime_frame.apply(Series.cummax, axis=1)
-        tm.assert_frame_equal(cummax, expected)
-
-        # it works
-        df = DataFrame({'A': np.arange(20)}, index=np.arange(20))
-        result = df.cummax()  # noqa
-
-        # fix issue
-        cummax_xs = datetime_frame.cummax(axis=1)
-        assert np.shape(cummax_xs) == np.shape(datetime_frame)
-
-    def test_max(self, float_frame_with_na, int_frame,
-                 float_frame, float_string_frame):
-        with warnings.catch_warnings(record=True):
-            warnings.simplefilter("ignore", RuntimeWarning)
-            assert_stat_op_calc('max', np.max, float_frame_with_na,
-                                check_dates=True)
-        assert_stat_op_calc('max', np.max, int_frame)
-        assert_stat_op_api('max', float_frame, float_string_frame)
-
-    def test_mad(self, float_frame_with_na, float_frame, float_string_frame):
-        f = lambda x: np.abs(x - x.mean()).mean()
-        assert_stat_op_calc('mad', f, float_frame_with_na)
-        assert_stat_op_api('mad', float_frame, float_string_frame)
-
-    def test_var_std(self, float_frame_with_na, datetime_frame, float_frame,
-                     float_string_frame):
-        alt = lambda x: np.var(x, ddof=1)
-        assert_stat_op_calc('var', alt, float_frame_with_na)
-        assert_stat_op_api('var', float_frame, float_string_frame)
-
-        alt = lambda x: np.std(x, ddof=1)
-        assert_stat_op_calc('std', alt, float_frame_with_na)
-        assert_stat_op_api('std', float_frame, float_string_frame)
-
+    def test_var_std(self, datetime_frame):
         result = datetime_frame.std(ddof=4)
         expected = datetime_frame.apply(lambda x: x.std(ddof=4))
         tm.assert_almost_equal(result, expected)
@@ -952,79 +924,7 @@ class TestDataFrameAnalytics():
         pytest.raises(TypeError, lambda: getattr(df2, meth)(
             axis=1, numeric_only=False))
 
-    @pytest.mark.parametrize('op', ['mean', 'std', 'var',
-                                    'skew', 'kurt', 'sem'])
-    def test_mixed_ops(self, op):
-        # GH 16116
-        df = DataFrame({'int': [1, 2, 3, 4],
-                        'float': [1., 2., 3., 4.],
-                        'str': ['a', 'b', 'c', 'd']})
-
-        result = getattr(df, op)()
-        assert len(result) == 2
-
-        with pd.option_context('use_bottleneck', False):
-            result = getattr(df, op)()
-            assert len(result) == 2
-
-    def test_cumsum(self, datetime_frame):
-        datetime_frame.loc[5:10, 0] = np.nan
-        datetime_frame.loc[10:15, 1] = np.nan
-        datetime_frame.loc[15:, 2] = np.nan
-
-        # axis = 0
-        cumsum = datetime_frame.cumsum()
-        expected = datetime_frame.apply(Series.cumsum)
-        tm.assert_frame_equal(cumsum, expected)
-
-        # axis = 1
-        cumsum = datetime_frame.cumsum(axis=1)
-        expected = datetime_frame.apply(Series.cumsum, axis=1)
-        tm.assert_frame_equal(cumsum, expected)
-
-        # works
-        df = DataFrame({'A': np.arange(20)}, index=np.arange(20))
-        result = df.cumsum()  # noqa
-
-        # fix issue
-        cumsum_xs = datetime_frame.cumsum(axis=1)
-        assert np.shape(cumsum_xs) == np.shape(datetime_frame)
-
-    def test_cumprod(self, datetime_frame):
-        datetime_frame.loc[5:10, 0] = np.nan
-        datetime_frame.loc[10:15, 1] = np.nan
-        datetime_frame.loc[15:, 2] = np.nan
-
-        # axis = 0
-        cumprod = datetime_frame.cumprod()
-        expected = datetime_frame.apply(Series.cumprod)
-        tm.assert_frame_equal(cumprod, expected)
-
-        # axis = 1
-        cumprod = datetime_frame.cumprod(axis=1)
-        expected = datetime_frame.apply(Series.cumprod, axis=1)
-        tm.assert_frame_equal(cumprod, expected)
-
-        # fix issue
-        cumprod_xs = datetime_frame.cumprod(axis=1)
-        assert np.shape(cumprod_xs) == np.shape(datetime_frame)
-
-        # ints
-        df = datetime_frame.fillna(0).astype(int)
-        df.cumprod(0)
-        df.cumprod(1)
-
-        # ints32
-        df = datetime_frame.fillna(0).astype(np.int32)
-        df.cumprod(0)
-        df.cumprod(1)
-
-    def test_sem(self, float_frame_with_na, datetime_frame,
-                 float_frame, float_string_frame):
-        alt = lambda x: np.std(x, ddof=1) / np.sqrt(len(x))
-        assert_stat_op_calc('sem', alt, float_frame_with_na)
-        assert_stat_op_api('sem', float_frame, float_string_frame)
-
+    def test_sem(self, datetime_frame):
         result = datetime_frame.sem(ddof=4)
         expected = datetime_frame.apply(
             lambda x: x.std(ddof=4) / np.sqrt(len(x)))
@@ -1039,29 +939,7 @@ class TestDataFrameAnalytics():
             assert not (result < 0).any()
 
     @td.skip_if_no_scipy
-    def test_skew(self, float_frame_with_na, float_frame, float_string_frame):
-        from scipy.stats import skew
-
-        def alt(x):
-            if len(x) < 3:
-                return np.nan
-            return skew(x, bias=False)
-
-        assert_stat_op_calc('skew', alt, float_frame_with_na)
-        assert_stat_op_api('skew', float_frame, float_string_frame)
-
-    @td.skip_if_no_scipy
-    def test_kurt(self, float_frame_with_na, float_frame, float_string_frame):
-        from scipy.stats import kurtosis
-
-        def alt(x):
-            if len(x) < 4:
-                return np.nan
-            return kurtosis(x, bias=False)
-
-        assert_stat_op_calc('kurt', alt, float_frame_with_na)
-        assert_stat_op_api('kurt', float_frame, float_string_frame)
-
+    def test_kurt(self):
         index = MultiIndex(levels=[['bar'], ['one', 'two', 'three'], [0, 1]],
                            codes=[[0, 0, 0, 0, 0, 0],
                                   [0, 1, 2, 0, 1, 2],
@@ -1323,20 +1201,146 @@ class TestDataFrameAnalytics():
         float_string_frame.mean(1)
         float_string_frame.skew(1)
 
-    # TODO: Ensure warning isn't emitted in the first place
-    @pytest.mark.filterwarnings("ignore:All-NaN:RuntimeWarning")
-    def test_median_corner(self, int_frame, float_frame, float_string_frame):
-        def wrapper(x):
-            if isna(x).any():
-                return np.nan
-            return np.median(x)
+    def test_sum_bools(self):
+        df = DataFrame(index=lrange(1), columns=lrange(10))
+        bools = isna(df)
+        assert bools.sum(axis=1)[0] == 10
 
-        assert_stat_op_calc('median', wrapper, int_frame, check_dtype=False,
-                            check_dates=True)
-        assert_stat_op_api('median', float_frame, float_string_frame)
+    # ---------------------------------------------------------------------
+    # Cumulative Reductions - cumsum, cummax, ...
+
+    def test_cumsum_corner(self):
+        dm = DataFrame(np.arange(20).reshape(4, 5),
+                       index=lrange(4), columns=lrange(5))
+        # ?(wesm)
+        result = dm.cumsum()  # noqa
+
+    def test_cumsum(self, datetime_frame):
+        datetime_frame.loc[5:10, 0] = np.nan
+        datetime_frame.loc[10:15, 1] = np.nan
+        datetime_frame.loc[15:, 2] = np.nan
+
+        # axis = 0
+        cumsum = datetime_frame.cumsum()
+        expected = datetime_frame.apply(Series.cumsum)
+        tm.assert_frame_equal(cumsum, expected)
+
+        # axis = 1
+        cumsum = datetime_frame.cumsum(axis=1)
+        expected = datetime_frame.apply(Series.cumsum, axis=1)
+        tm.assert_frame_equal(cumsum, expected)
+
+        # works
+        df = DataFrame({'A': np.arange(20)}, index=np.arange(20))
+        result = df.cumsum()  # noqa
+
+        # fix issue
+        cumsum_xs = datetime_frame.cumsum(axis=1)
+        assert np.shape(cumsum_xs) == np.shape(datetime_frame)
+
+    def test_cumprod(self, datetime_frame):
+        datetime_frame.loc[5:10, 0] = np.nan
+        datetime_frame.loc[10:15, 1] = np.nan
+        datetime_frame.loc[15:, 2] = np.nan
+
+        # axis = 0
+        cumprod = datetime_frame.cumprod()
+        expected = datetime_frame.apply(Series.cumprod)
+        tm.assert_frame_equal(cumprod, expected)
+
+        # axis = 1
+        cumprod = datetime_frame.cumprod(axis=1)
+        expected = datetime_frame.apply(Series.cumprod, axis=1)
+        tm.assert_frame_equal(cumprod, expected)
+
+        # fix issue
+        cumprod_xs = datetime_frame.cumprod(axis=1)
+        assert np.shape(cumprod_xs) == np.shape(datetime_frame)
 
+        # ints
+        df = datetime_frame.fillna(0).astype(int)
+        df.cumprod(0)
+        df.cumprod(1)
+
+        # ints32
+        df = datetime_frame.fillna(0).astype(np.int32)
+        df.cumprod(0)
+        df.cumprod(1)
+
+    def test_cummin(self, datetime_frame):
+        datetime_frame.loc[5:10, 0] = np.nan
+        datetime_frame.loc[10:15, 1] = np.nan
+        datetime_frame.loc[15:, 2] = np.nan
+
+        # axis = 0
+        cummin = datetime_frame.cummin()
+        expected = datetime_frame.apply(Series.cummin)
+        tm.assert_frame_equal(cummin, expected)
+
+        # axis = 1
+        cummin = datetime_frame.cummin(axis=1)
+        expected = datetime_frame.apply(Series.cummin, axis=1)
+        tm.assert_frame_equal(cummin, expected)
+
+        # it works
+        df = DataFrame({'A': np.arange(20)}, index=np.arange(20))
+        result = df.cummin()  # noqa
+
+        # fix issue
+        cummin_xs = datetime_frame.cummin(axis=1)
+        assert np.shape(cummin_xs) == np.shape(datetime_frame)
+
+    def test_cummax(self, datetime_frame):
+        datetime_frame.loc[5:10, 0] = np.nan
+        datetime_frame.loc[10:15, 1] = np.nan
+        datetime_frame.loc[15:, 2] = np.nan
+
+        # axis = 0
+        cummax = datetime_frame.cummax()
+        expected = datetime_frame.apply(Series.cummax)
+        tm.assert_frame_equal(cummax, expected)
+
+        # axis = 1
+        cummax = datetime_frame.cummax(axis=1)
+        expected = datetime_frame.apply(Series.cummax, axis=1)
+        tm.assert_frame_equal(cummax, expected)
+
+        # it works
+        df = DataFrame({'A': np.arange(20)}, index=np.arange(20))
+        result = df.cummax()  # noqa
+
+        # fix issue
+        cummax_xs = datetime_frame.cummax(axis=1)
+        assert np.shape(cummax_xs) == np.shape(datetime_frame)
+
+    # ---------------------------------------------------------------------
     # Miscellanea
 
+    def test_count(self):
+        # corner case
+        frame = DataFrame()
+        ct1 = frame.count(1)
+        assert isinstance(ct1, Series)
+
+        ct2 = frame.count(0)
+        assert isinstance(ct2, Series)
+
+        # GH#423
+        df = DataFrame(index=lrange(10))
+        result = df.count(1)
+        expected = Series(0, index=df.index)
+        tm.assert_series_equal(result, expected)
+
+        df = DataFrame(columns=lrange(10))
+        result = df.count(0)
+        expected = Series(0, index=df.columns)
+        tm.assert_series_equal(result, expected)
+
+        df = DataFrame()
+        result = df.count()
+        expected = Series(0, index=[])
+        tm.assert_series_equal(result, expected)
+
     def test_count_objects(self, float_string_frame):
         dm = DataFrame(float_string_frame._series)
         df = DataFrame(float_string_frame._series)
@@ -1344,17 +1348,23 @@ class TestDataFrameAnalytics():
         tm.assert_series_equal(dm.count(), df.count())
         tm.assert_series_equal(dm.count(1), df.count(1))
 
-    def test_cumsum_corner(self):
-        dm = DataFrame(np.arange(20).reshape(4, 5),
-                       index=lrange(4), columns=lrange(5))
-        # ?(wesm)
-        result = dm.cumsum()  # noqa
+    def test_pct_change(self):
+        # GH#11150
+        pnl = DataFrame([np.arange(0, 40, 10),
+                         np.arange(0, 40, 10),
+                         np.arange(0, 40, 10)]).astype(np.float64)
+        pnl.iat[1, 0] = np.nan
+        pnl.iat[1, 1] = np.nan
+        pnl.iat[2, 3] = 60
 
-    def test_sum_bools(self):
-        df = DataFrame(index=lrange(1), columns=lrange(10))
-        bools = isna(df)
-        assert bools.sum(axis=1)[0] == 10
+        for axis in range(2):
+            expected = pnl.ffill(axis=axis) / pnl.ffill(axis=axis).shift(
+                axis=axis) - 1
+            result = pnl.pct_change(axis=axis, fill_method='pad')
 
+            tm.assert_frame_equal(result, expected)
+
+    # ----------------------------------------------------------------------
     # Index of max / min
 
     def test_idxmin(self, float_frame, int_frame):
@@ -1700,7 +1710,9 @@ class TestDataFrameAnalytics():
         result = df1_td.isin(df3)
         tm.assert_frame_equal(result, expected)
 
+    # ---------------------------------------------------------------------
     # Rounding
+
     def test_round(self):
         # GH 2665
 
@@ -1888,22 +1900,9 @@ class TestDataFrameAnalytics():
 
         tm.assert_frame_equal(result, expected)
 
-    def test_pct_change(self):
-        # GH 11150
-        pnl = DataFrame([np.arange(0, 40, 10), np.arange(0, 40, 10), np.arange(
-            0, 40, 10)]).astype(np.float64)
-        pnl.iat[1, 0] = np.nan
-        pnl.iat[1, 1] = np.nan
-        pnl.iat[2, 3] = 60
-
-        for axis in range(2):
-            expected = pnl.ffill(axis=axis) / pnl.ffill(axis=axis).shift(
-                axis=axis) - 1
-            result = pnl.pct_change(axis=axis, fill_method='pad')
-
-            tm.assert_frame_equal(result, expected)
-
+    # ---------------------------------------------------------------------
     # Clip
+
     def test_clip(self, float_frame):
         median = float_frame.median().median()
         original = float_frame.copy()
@@ -2076,7 +2075,9 @@ class TestDataFrameAnalytics():
                               'col_2': [np.nan, np.nan, np.nan]})
         tm.assert_frame_equal(result, expected)
 
+    # ---------------------------------------------------------------------
     # Matrix-like
+
     def test_dot(self):
         a = DataFrame(np.random.randn(3, 4), index=['a', 'b', 'c'],
                       columns=['p', 'q', 'r', 's'])

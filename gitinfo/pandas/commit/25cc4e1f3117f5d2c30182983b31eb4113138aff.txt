commit 25cc4e1f3117f5d2c30182983b31eb4113138aff
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Nov 15 10:46:07 2012 -0500

    BUG: handle IO callback failure from read(...). close #2071

diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index 03caf90f8..40418ad3d 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -588,13 +588,8 @@ class TextFileReader(object):
             #     suppressed_warnings = True
             #     self._engine.set_error_bad_lines(False)
 
-        # index = None
-
         ret = self._engine.read(nrows)
 
-        # if suppressed_warnings:
-        #     self._engine.set_error_bad_lines(True)
-
         if self.options.get('as_recarray'):
             return ret
 
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index c650ba5e4..f36201959 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -1353,7 +1353,6 @@ KORD6,19990127, 23:00:00, 22:56:00, -0.5900, 1.7100, 4.6000, 0.0000, 280.0000"""
                              na_values=['NaN'])
         assert_almost_equal(df.values, expected)
 
-
 class TestPythonParser(ParserTests, unittest.TestCase):
 
     def read_csv(self, *args, **kwds):
@@ -1661,6 +1660,35 @@ eight,1,2,3"""
 
         self.assertEquals(got, expected)
 
+    def test_iteration_open_handle(self):
+        import itertools
+
+        with open('__foo__.txt', 'wb') as f:
+            f.write('AAA\nBBB\nCCC\nDDD\nEEE\nFFF\nGGG')
+
+        with open('__foo__.txt', 'rb') as f:
+            for line in f:
+                if 'CCC' in line:
+                    break
+
+            try:
+                read_table(f, squeeze=True, header=None, engine='c')
+            except Exception:
+                pass
+            else:
+                raise ValueError('this should not happen')
+
+            result = read_table(f, squeeze=True, header=None,
+                                engine='python')
+
+            expected = Series(['DDD', 'EEE', 'FFF', 'GGG'])
+            tm.assert_series_equal(result, expected)
+
+        try:
+            os.remove('__foo__.txt')
+        except os.error:
+            pass
+
 class TestCParserHighMemory(ParserTests, unittest.TestCase):
 
     def read_csv(self, *args, **kwds):
diff --git a/pandas/src/parser.pyx b/pandas/src/parser.pyx
index 91d642a0b..f685bfb17 100644
--- a/pandas/src/parser.pyx
+++ b/pandas/src/parser.pyx
@@ -642,6 +642,7 @@ cdef class TextReader:
         cdef int status
         with nogil:
             status = tokenize_nrows(self.parser, nrows)
+
         if status < 0:
             raise_parser_error('Error tokenizing data', self.parser)
 
diff --git a/pandas/src/parser/io.c b/pandas/src/parser/io.c
index 8c7d7ec1b..cb70ddf53 100644
--- a/pandas/src/parser/io.c
+++ b/pandas/src/parser/io.c
@@ -115,17 +115,23 @@ void* buffer_rd_bytes(void *source, size_t nbytes,
     Py_XDECREF(src->buffer);
     args = Py_BuildValue("(i)", nbytes);
 
-
     state = PyGILState_Ensure();
     func = PyObject_GetAttrString(src->obj, "read");
     /* printf("%s\n", PyBytes_AsString(PyObject_Repr(func))); */
 
     /* TODO: does this release the GIL? */
     result = PyObject_CallObject(func, args);
+    Py_XDECREF(args);
+    Py_XDECREF(func);
 
     /* PyObject_Print(PyObject_Type(result), stdout, 0); */
-
-    if (!PyBytes_Check(result)) {
+    if (result == NULL) {
+        PyGILState_Release(state);
+        *bytes_read = 0;
+        *status = CALLING_READ_FAILED;
+        return NULL;
+    }
+    else if (!PyBytes_Check(result)) {
         tmp = PyUnicode_AsUTF8String(result);
         Py_XDECREF(result);
         result = tmp;
@@ -142,8 +148,6 @@ void* buffer_rd_bytes(void *source, size_t nbytes,
     src->buffer = result;
     retval = (void*) PyBytes_AsString(result);
 
-    Py_XDECREF(args);
-    Py_XDECREF(func);
 
     PyGILState_Release(state);
 
@@ -267,4 +271,4 @@ void* buffer_mmap_bytes(void *source, size_t nbytes,
   return NULL;
 }
 
-#endif 
+#endif
diff --git a/pandas/src/parser/parser.c b/pandas/src/parser/parser.c
index 64a4861cf..8d6dffbc0 100644
--- a/pandas/src/parser/parser.c
+++ b/pandas/src/parser/parser.c
@@ -493,8 +493,19 @@ int parser_buffer_bytes(parser_t *self, size_t nbytes) {
     self->data = self->cb_io(self->source, nbytes, &bytes_read, &status);
     self->datalen = bytes_read;
 
+    if (status != REACHED_EOF && self->data == NULL) {
+        self->error_msg = (char*) malloc(200);
+
+        if (status == CALLING_READ_FAILED) {
+            sprintf(self->error_msg, ("Calling read(nbytes) on source failed. "
+                                      "Try engine='python'."));
+        } else {
+            sprintf(self->error_msg, "Unknown error in IO callback");
+        }
+        return -1;
+    }
+
     TRACE(("datalen: %d\n", self->datalen));
-    TRACE(("pos: %d, length: %d", (int) src->position, (int) src->length));
 
     return status;
 }
diff --git a/pandas/src/parser/parser.h b/pandas/src/parser/parser.h
index 54f80212d..5388d5059 100644
--- a/pandas/src/parser/parser.h
+++ b/pandas/src/parser/parser.h
@@ -29,6 +29,7 @@ See LICENSE for the license
 #define STREAM_INIT_SIZE 32
 
 #define REACHED_EOF 1
+#define CALLING_READ_FAILED 2
 
 
 /*
@@ -61,7 +62,7 @@ See LICENSE for the license
 #define ERROR_NO_DATA                  23
 
 
-// #define VERBOSE
+/* #define VERBOSE */
 
 #if defined(VERBOSE)
 #define TRACE(X) printf X;

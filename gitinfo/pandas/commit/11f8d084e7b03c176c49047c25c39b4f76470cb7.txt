commit 11f8d084e7b03c176c49047c25c39b4f76470cb7
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Jul 31 00:48:10 2011 -0400

    ENH: mixed-type WidePanel can make roundtrip to LongPanel without losing proper mixed-typeness

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index d5747e1be..693f5b29b 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -27,7 +27,7 @@ from pandas.core.common import (isnull, notnull, PandasError, _ensure_index,
 from pandas.core.daterange import DateRange
 from pandas.core.generic import AxisProperty, NDFrame
 from pandas.core.index import Index, MultiIndex, NULL_INDEX
-from pandas.core.internals import BlockManager, make_block
+from pandas.core.internals import BlockManager, make_block, form_blocks
 from pandas.core.series import Series, _is_bool_indexer
 import pandas.core.common as common
 import pandas.core.datetools as datetools
@@ -167,12 +167,8 @@ class DataFrame(NDFrame):
     def _init_dict(self, data, index, columns, dtype=None):
         """
         Segregate Series based on type and coerce into matrices.
-
         Needs to handle a lot of exceptional cases.
-
-        Somehow this got outrageously complicated
         """
-        from pandas.core.internals import form_blocks
         # prefilter if columns passed
         if columns is not None:
             columns = _ensure_index(columns)
@@ -183,15 +179,20 @@ class DataFrame(NDFrame):
         # figure out the index, if necessary
         if index is None:
             index = extract_index(data)
+        else:
+            index = _ensure_index(index)
 
         # don't force copy because getting jammed in an ndarray anyway
         homogenized = _homogenize(data, index, columns, dtype)
 
+        # from BlockManager perspective
+        axes = [columns, index]
+
         # segregates dtypes and forms blocks matching to columns
-        blocks, columns = form_blocks(homogenized, index, columns)
+        blocks = form_blocks(homogenized, axes)
 
         # consolidate for now
-        mgr = BlockManager(blocks, [columns, index])
+        mgr = BlockManager(blocks, axes)
         return mgr.consolidate()
 
     def _init_ndarray(self, values, index, columns, dtype=None,
@@ -1023,7 +1024,7 @@ class DataFrame(NDFrame):
 
     def sortlevel(self, level=0, axis=0, ascending=True):
         """
-        Sort value by chosen axis and primary level. Data will be
+        Sort multilevel index by chosen axis and primary level. Data will be
         lexicographically sorted by the chosen level followed by the other
         levels (in order)
 
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 430435c10..24fe25239 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -688,14 +688,10 @@ class BlockManager(object):
         return result
 
 _data_types = [np.float_, np.int_]
-def form_blocks(data, index, items):
+def form_blocks(data, axes):
     # pre-filter out items if we passed it
-    if items is None:
-        items = Index(_try_sort(data.keys()))
-        extra_items = NULL_INDEX
-    else:
-        items = _ensure_index(items)
-        extra_items = items - Index(data.keys())
+    items = axes[0]
+    extra_items = items - Index(data.keys())
 
     # put "leftover" items in float bucket, where else?
     # generalize?
@@ -731,14 +727,15 @@ def form_blocks(data, index, items):
         blocks.append(object_block)
 
     if len(extra_items):
-        block_values = np.empty((len(extra_items), len(index)), dtype=float)
+        shape = (len(extra_items),) + tuple(len(x) for x in axes[1:])
+        block_values = np.empty(shape, dtype=float)
         block_values.fill(nan)
 
         na_block = make_block(block_values, extra_items, items)
         blocks.append(na_block)
         blocks = _consolidate(blocks, items)
 
-    return blocks, items
+    return blocks
 
 def _simple_blockify(dct, ref_items, dtype):
     block_items, values = _stack_dict(dct, ref_items)
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 8d48de6cc..f75b9bbba 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -1,4 +1,4 @@
-sfromDict"""
+"""
 Contains data structures designed for manipulating panel (3-dimensional) data
 """
 # pylint: disable=E1103,W0231,W0212,W0621
@@ -11,9 +11,9 @@ import warnings
 import numpy as np
 
 from pandas.core.common import (PandasError, _mut_exclusive, _ensure_index,
-                                _default_index, _infer_dtype)
+                                _try_sort, _default_index, _infer_dtype)
 from pandas.core.index import Factor, Index, MultiIndex
-from pandas.core.internals import BlockManager, make_block
+from pandas.core.internals import BlockManager, make_block, form_blocks
 from pandas.core.frame import DataFrame
 from pandas.core.generic import AxisProperty, NDFrame
 import pandas.core.common as common
@@ -187,6 +187,7 @@ class WidePanel(Panel, NDFrame):
 
     def __init__(self, data, items=None, major_axis=None, minor_axis=None,
                  copy=False, dtype=None):
+        passed_axes = [items, major_axis, minor_axis]
         if isinstance(data, BlockManager):
             mgr = data
             if copy and dtype is None:
@@ -194,14 +195,73 @@ class WidePanel(Panel, NDFrame):
             elif dtype is not None:
                 # no choice but to copy
                 mgr = mgr.cast(dtype)
+        elif isinstance(data, dict):
+            mgr = self._init_dict(data, passed_axes, dtype=dtype)
         elif isinstance(data, (np.ndarray, list)):
-            mgr = self._init_matrix(data, [items, major_axis, minor_axis],
-                                    dtype=dtype, copy=copy)
+            mgr = self._init_matrix(data, passed_axes, dtype=dtype, copy=copy)
         else: # pragma: no cover
             raise PandasError('Panel constructor not properly called!')
 
         self._data = mgr
 
+    def _init_dict(self, data, axes, dtype=None):
+        items = axes[0]
+
+        # prefilter if items passed
+        if items is not None:
+            items = _ensure_index(items)
+            data = dict((k, v) for k, v in data.iteritems() if k in items)
+        else:
+            items = Index(_try_sort(data.keys()))
+
+        # figure out the index, if necessary
+        if index is None:
+            index = extract_index(data)
+
+        # don't force copy because getting jammed in an ndarray anyway
+        # homogenized = _homogenize(data, index, columns, dtype)
+
+        data, index, columns = _homogenize(data, intersect=intersect)
+
+        # segregates dtypes and forms blocks matching to columns
+        blocks = form_blocks(homogenized, index, columns)
+
+        # consolidate for now
+        mgr = BlockManager(blocks, [columns, index])
+        return mgr.consolidate()
+
+    @classmethod
+    def from_dict(cls, data, intersect=False, dtype=float):
+        """
+        Construct WidePanel from dict of DataFrame objects
+
+        Parameters
+        ----------
+        data : dict
+            {field : DataFrame}
+        intersect : boolean
+
+        Returns
+        -------
+        WidePanel
+        """
+        data, index, columns = _homogenize(data, intersect=intersect,
+                                           dtype=dtype)
+        items = Index(sorted(data.keys()))
+
+        axes = [items, index, columns]
+
+        reshaped_data = {}
+        for k, v in data.iteritems():
+            values = v.values
+            shape = values.shape
+            reshaped_data[k] = values.reshape((1,) + shape)
+
+        blocks = form_blocks(reshaped_data, axes)
+
+        mgr = BlockManager(blocks, axes).consolidate()
+        return WidePanel(mgr, items, index, columns)
+
     def _init_matrix(self, data, axes, dtype=None, copy=False):
         values = _prep_ndarray(data, copy=copy)
 
@@ -261,26 +321,6 @@ class WidePanel(Panel, NDFrame):
         """
         return WidePanel(self._data.copy())
 
-    @classmethod
-    def from_dict(cls, data, intersect=False, dtype=float):
-        """
-        Construct WidePanel from dict of DataFrame objects
-
-        Parameters
-        ----------
-        data : dict
-            {field : DataFrame}
-        intersect : boolean
-
-        Returns
-        -------
-        WidePanel
-        """
-        data, index, columns = _homogenize(data, intersect=intersect)
-        items = Index(sorted(data.keys()))
-        values = np.array([data[k].values for k in items], dtype=dtype)
-        return cls(values, items, index, columns)
-
     fromDict = from_dict
 
     def to_sparse(self, fill_value=None, kind='block'):
@@ -1127,8 +1167,10 @@ class LongPanel(Panel, DataFrame):
 
         data = {}
         for i, item in enumerate(self.items):
-            values = np.empty((N, K), dtype=self.values.dtype)
-            values.ravel()[mask] = self.values[:, i]
+            item_vals = self[item].values
+
+            values = np.empty((N, K), dtype=item_vals.dtype)
+            values.ravel()[mask] = item_vals
             data[item] = DataFrame(values, index=self.major_axis,
                                    columns=self.minor_axis)
         return WidePanel.from_dict(data)
@@ -1381,7 +1423,7 @@ def _prefix_item(item, prefix=None):
     template = '%s%s'
     return template % (prefix, item)
 
-def _homogenize(frames, intersect=True):
+def _homogenize(frames, intersect=True, dtype=None):
     """
     Conform set of DataFrame-like objects to either an intersection
     of indices / columns or a union.
@@ -1431,24 +1473,34 @@ def _get_combined_columns(frames, intersect=False):
     return Index(sorted(columns))
 
 def _get_combined_index(frames, intersect=False):
-    index = None
 
-    if intersect:
-        combine = Index.intersection
-        copy = Index
-        unique = lambda x: x
-    else:
-        combine = lambda a, b: np.concatenate((a, b))
-        copy = np.array
-        unique = lambda x: Index(np.unique(x))
+    # get the set of unique indexes (np.ndarray is unhashable so use the id)
+    indexes = dict(((id(frame.index), frame.index)
+                    for frame in frames.itervalues()))
+    indexes = indexes.values()
 
-    for _, frame in frames.iteritems():
-        if index is None:
-            index = copy(frame.index)
-        elif index is not frame.index:
-            index = combine(index, frame.index)
+    # if there's only one return it
+    if len(indexes) == 1:
+        return indexes[0]
+
+    # filter indexes so any equivalent indexes only appear once
+    for index in list(indexes):
+        if id(index) in set(id(x) for x in indexes):
+            indexes = [x for x in indexes
+                       if x is index or not x.equals(index)]
+
+    # if there's only one return it
+    if len(indexes) == 1:
+        return indexes[0]
+
+    if intersect:
+        index = indexes[0]
+        for other in indexes[1:]:
+            index = index.intersection(other)
+        return index
 
-    return unique(index)
+    union =  np.unique(np.concatenate(tuple(indexes)))
+    return Index(union)
 
 def pivot(index, columns, values):
     """

commit 756a096fdb0ded83803b67860938ee04ae60cdd7
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Aug 9 20:19:40 2011 -0400

    ENH: sparse formatting of multi-level indexes, and will print out columns, too

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index bc7187947..6fb073e71 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -487,7 +487,8 @@ class DataFrame(NDFrame):
         f.close()
 
     def toString(self, buf=sys.stdout, columns=None, colSpace=None,
-                 nanRep='NaN', formatters=None, float_format=None):
+                 nanRep='NaN', formatters=None, float_format=None,
+                 sparsify=True):
         from pandas.core.common import _format, adjoin
 
         if colSpace is None:
@@ -515,12 +516,36 @@ class DataFrame(NDFrame):
             print >> buf, 'Empty %s' % type(self).__name__
             print >> buf, repr(self.index)
         else:
-            fmt_index = self.index.format().split('\n')
-            fmt_columns = self.columns
-            str_index = [''] + fmt_index
-            stringified = [[' %s' % str(c)] + _stringify(c) for c in columns]
+            (str_index,
+             str_columns) = self._get_formatted_labels(sparsify=sparsify)
+            stringified = [str_columns[i] + _stringify(c)
+                           for i, c in enumerate(columns)]
             print >> buf, adjoin(2, str_index, *stringified)
 
+    def _get_formatted_labels(self, sparsify=True):
+        from pandas.core.index import _sparsify
+
+        if isinstance(self.index, MultiIndex):
+            fmt_index = self.index.format(sparsify=sparsify)
+        else:
+            fmt_index = self.index.format()
+
+        if isinstance(self.columns, MultiIndex):
+            fmt_columns = self.columns.format(sparsify=False)
+            str_columns = zip(*[[' %s' % y for y in x.split()]
+                                for x in fmt_columns])
+
+            if sparsify:
+                str_columns = [_sparsify(lev) for lev in str_columns]
+            str_columns = [list(x) for x in zip(*str_columns)]
+            str_index = [''] * self.columns.nlevels + fmt_index
+        else:
+            col_nlevels = 1
+            str_columns = [[' %s' % x] for x in self.columns.format()]
+            str_index = [''] + fmt_index
+
+        return str_index, str_columns
+
     def info(self, verbose=True, buf=sys.stdout):
         """
         Concise summary of a DataFrame, used in __repr__ when very large.
@@ -1045,16 +1070,19 @@ class DataFrame(NDFrame):
             raise Exception('can only sort by level with a hierarchical index')
 
         new_axis, indexer = the_axis.sortlevel(level, ascending=ascending)
-        new_values = self.values.take(indexer, axis=0)
+
+        # new_values = self.values.take(indexer, axis=axis)
 
         if axis == 0:
-            index = new_axis
-            columns = self.columns
+            return self.reindex(index=new_axis)
+            # index = new_axis
+            # columns = self.columns
         else:
-            index = self.index
-            columns = new_axis
+            return self.reindex(columns=new_axis)
+            # index = self.index
+            # columns = new_axis
 
-        return self._constructor(new_values, index=index, columns=columns)
+        # return self._constructor(new_values, index=index, columns=columns)
 
     #----------------------------------------------------------------------
     # Filling NA's
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 664489cf9..98e33b017 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -203,14 +203,11 @@ class GroupBy(object):
 
     def _aggregate_multi_group(self, arg):
         # want to cythonize?
-
-        if len(self.groupings) > 3:
-            raise Exception('can only handle 3 or fewer groupings for now')
-
         shape = self._result_shape
         result = np.empty(shape, dtype=float)
         result.fill(np.nan)
         counts = np.zeros(shape, dtype=int)
+
         def _doit(reschunk, ctchunk, gen):
             for i, (_, subgen) in enumerate(gen):
                 if isinstance(subgen, Series):
diff --git a/pandas/core/index.py b/pandas/core/index.py
index a4e81f5f1..629105a8c 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -109,7 +109,11 @@ class Index(np.ndarray):
 
             return Index(arr_idx[key])
 
-    def format(self):
+    def take(self, *args, **kwargs):
+        taken = self.view(np.ndarray).take(*args, **kwargs)
+        return Index(taken)
+
+    def format(self, vertical=False):
         """
         Render a string representation of the Index
         """
@@ -120,9 +124,9 @@ class Index(np.ndarray):
                 if dt.time() != zero_time or dt.tzinfo is not None:
                     return '\n'.join(str(x) for x in self)
                 to_join.append(dt.strftime("%Y-%m-%d"))
-            return '\n'.join(to_join)
+            return to_join
 
-        return '\n'.join(str(x) for x in self)
+        return [str(x) for x in self]
 
     def equals(self, other):
         """
@@ -233,10 +237,6 @@ class Index(np.ndarray):
 
     __sub__ = lambda self, other: self.diff(other)
 
-    def take(self, *args, **kwargs):
-        taken = self.view(np.ndarray).take(*args, **kwargs)
-        return Index(taken)
-
     def get_loc(self, key):
         return self.indexMap[key]
 
@@ -394,15 +394,17 @@ class MultiIndex(Index):
         except Exception:
             return False
 
-    def format(self, space=2):
-        stringified_levels = [lev.format().split('\n') for lev in self.levels]
+    def format(self, space=2, sparsify=True, vertical=False):
+        stringified_levels = [lev.format() for lev in self.levels]
 
         result_levels = []
         for lab, lev in zip(self.labels, stringified_levels):
             taken = np.array(lev, dtype=object).take(lab)
+            if sparsify:
+                taken = _sparsify(taken)
             result_levels.append(taken)
 
-        return adjoin(space, *result_levels)
+        return adjoin(space, *result_levels).split('\n')
 
     def is_all_dates(self):
         return False
@@ -496,6 +498,10 @@ class MultiIndex(Index):
 
             return result
 
+    def take(self, *args, **kwargs):
+        new_labels = [lab.take(*args, **kwargs) for lab in self.labels]
+        return MultiIndex(levels=self.levels, labels=new_labels)
+
     def __getslice__(self, i, j):
         return self.__getitem__(slice(i, j))
 
@@ -610,7 +616,7 @@ class MultiIndex(Index):
         if isinstance(key, tuple):
             return self._get_tuple_loc(key)
         else:
-            assert(self.sortorder == 0)
+            # assert(self.sortorder == 0)
             # slice level 0
             level = self.levels[0]
             labels = self.labels[0]
@@ -646,6 +652,9 @@ class MultiIndex(Index):
         -------
         MultiIndex
         """
+        if after and before and after < before:
+            raise ValueError('after < before')
+
         i, j = self.levels[0].slice_locs(before, after)
         left, right = self.slice_locs(before, after)
 
@@ -764,3 +773,17 @@ class MultiIndex(Index):
 
 NULL_INDEX = Index([])
 
+def _sparsify(labels):
+    if len(labels) == 0:
+        return []
+    result = [labels[0]]
+    prev = labels[0]
+    for label in labels[1:]:
+        if label == prev:
+            result.append('')
+        else:
+            result.append(label)
+            prev = label
+
+    return result
+
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 7c994640c..5fcef5615 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1588,7 +1588,7 @@ def remove_na(arr):
     return arr[notnull(arr)]
 
 def _seriesRepr(index, vals, nanRep='NaN'):
-    string_index = index.format().split('\n')
+    string_index = index.format()
     maxlen = max(len(x) for x in string_index)
     padSpace = min(maxlen, 60)
 
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index e181a8121..48eb3b8b7 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -169,6 +169,11 @@ class TestGroupBy(unittest.TestCase):
         # make sure raises error
         self.assertRaises(AttributeError, getattr, grouped, 'foo')
 
+    def test_series_describe_multikey(self):
+        ts = tm.makeTimeSeries()
+        grouped = ts.groupby([lambda x: x.year, lambda x: x.month])
+        grouped.describe()
+
     def test_frame_groupby(self):
         grouped = self.tsframe.groupby(lambda x: x.weekday())
 

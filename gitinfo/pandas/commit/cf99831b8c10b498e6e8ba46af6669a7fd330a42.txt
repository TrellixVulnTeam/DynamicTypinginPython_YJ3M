commit cf99831b8c10b498e6e8ba46af6669a7fd330a42
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon Dec 30 05:14:21 2019 -0800

    CLN: ops cleanups (#30530)

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index fc39b264d..cd55ee07d 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -5148,7 +5148,7 @@ class DataFrame(NDFrame):
     # Arithmetic / combination related
 
     def _combine_frame(self, other, func, fill_value=None, level=None):
-        this, other = self.align(other, join="outer", level=level, copy=False)
+        # at this point we have `self._indexed_same(other)`
 
         if fill_value is None:
             # since _arith_op may be called in a loop, avoid function call
@@ -5164,14 +5164,15 @@ class DataFrame(NDFrame):
                 left, right = ops.fill_binop(left, right, fill_value)
                 return func(left, right)
 
-        if ops.should_series_dispatch(this, other, func):
+        if ops.should_series_dispatch(self, other, func):
             # iterate over columns
-            new_data = ops.dispatch_to_series(this, other, _arith_op)
+            new_data = ops.dispatch_to_series(self, other, _arith_op)
         else:
             with np.errstate(all="ignore"):
-                res_values = _arith_op(this.values, other.values)
-            new_data = dispatch_fill_zeros(func, this.values, other.values, res_values)
-        return this._construct_result(new_data)
+                res_values = _arith_op(self.values, other.values)
+            new_data = dispatch_fill_zeros(func, self.values, other.values, res_values)
+
+        return new_data
 
     def _combine_match_index(self, other, func):
         # at this point we have `self.index.equals(other.index)`
diff --git a/pandas/core/ops/__init__.py b/pandas/core/ops/__init__.py
index be5e53eaa..1b868f7c1 100644
--- a/pandas/core/ops/__init__.py
+++ b/pandas/core/ops/__init__.py
@@ -302,7 +302,7 @@ def _get_op_name(op, special):
     """
     opname = op.__name__.strip("_")
     if special:
-        opname = "__{opname}__".format(opname=opname)
+        opname = f"__{opname}__"
     return opname
 
 
@@ -385,7 +385,7 @@ def dispatch_to_series(left, right, func, str_rep=None, axis=None):
             return {i: func(a.iloc[:, i], b.iloc[:, i]) for i in range(len(a.columns))}
 
     elif isinstance(right, ABCSeries) and axis == "columns":
-        # We only get here if called via _combine_frame_series,
+        # We only get here if called via _combine_series_frame,
         # in which case we specifically want to operate row-by-row
         assert right.index.equals(left.columns)
 
@@ -603,9 +603,7 @@ def _combine_series_frame(self, other, func, fill_value=None, axis=None, level=N
     result : DataFrame
     """
     if fill_value is not None:
-        raise NotImplementedError(
-            "fill_value {fill} not supported.".format(fill=fill_value)
-        )
+        raise NotImplementedError(f"fill_value {fill_value} not supported.")
 
     if axis is None:
         # default axis is columns
@@ -661,15 +659,13 @@ def _align_method_FRAME(left, right, axis):
             else:
                 raise ValueError(
                     "Unable to coerce to DataFrame, shape "
-                    "must be {req_shape}: given {given_shape}".format(
-                        req_shape=left.shape, given_shape=right.shape
-                    )
+                    f"must be {left.shape}: given {right.shape}"
                 )
 
         elif right.ndim > 2:
             raise ValueError(
                 "Unable to coerce to Series/DataFrame, dim "
-                "must be <= 2: {dim}".format(dim=right.shape)
+                f"must be <= 2: {right.shape}"
             )
 
     elif is_list_like(right) and not isinstance(right, (ABCSeries, ABCDataFrame)):
@@ -702,7 +698,11 @@ def _arith_method_FRAME(cls, op, special):
             # Another DataFrame
             pass_op = op if should_series_dispatch(self, other, op) else na_op
             pass_op = pass_op if not is_logical else op
-            return self._combine_frame(other, pass_op, fill_value, level)
+
+            left, right = self.align(other, join="outer", level=level, copy=False)
+            new_data = left._combine_frame(right, pass_op, fill_value)
+            return left._construct_result(new_data)
+
         elif isinstance(other, ABCSeries):
             # For these values of `axis`, we end up dispatching to Series op,
             # so do not want the masked op.
@@ -763,7 +763,7 @@ def _comp_method_FRAME(cls, op, special):
     str_rep = _get_opstr(op)
     op_name = _get_op_name(op, special)
 
-    @Appender("Wrapper for comparison method {name}".format(name=op_name))
+    @Appender(f"Wrapper for comparison method {op_name}")
     def f(self, other):
 
         other = _align_method_FRAME(self, other, axis=None)

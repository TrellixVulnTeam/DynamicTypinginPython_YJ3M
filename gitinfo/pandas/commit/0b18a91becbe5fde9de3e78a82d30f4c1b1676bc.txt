commit 0b18a91becbe5fde9de3e78a82d30f4c1b1676bc
Author: Chang She <changshe@gmail.com>
Date:   Tue Sep 18 22:26:35 2012 -0400

    BUG: allow non-numeric columns in groupby first/last #1809

diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index ae3a08476..555ea788f 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -24,10 +24,10 @@ class DataError(GroupByError):
 class SpecificationError(GroupByError):
     pass
 
-def _groupby_function(name, alias, npfunc):
+def _groupby_function(name, alias, npfunc, numeric_only=True):
     def f(self):
         try:
-            return self._cython_agg_general(alias)
+            return self._cython_agg_general(alias, numeric_only=numeric_only)
         except Exception:
             return self.aggregate(lambda x: npfunc(x, axis=self.axis))
 
@@ -350,8 +350,9 @@ class GroupBy(object):
     prod = _groupby_function('prod', 'prod', np.prod)
     min = _groupby_function('min', 'min', np.min)
     max = _groupby_function('max', 'max', np.max)
-    first = _groupby_function('first', 'first', _first_compat)
-    last = _groupby_function('last', 'last', _last_compat)
+    first = _groupby_function('first', 'first', _first_compat,
+                              numeric_only=False)
+    last = _groupby_function('last', 'last', _last_compat, numeric_only=False)
 
     def ohlc(self):
         """
@@ -370,10 +371,11 @@ class GroupBy(object):
                 return np.nan
         return self.agg(picker)
 
-    def _cython_agg_general(self, how):
+    def _cython_agg_general(self, how, numeric_only=True):
         output = {}
         for name, obj in self._iterate_slices():
-            if not issubclass(obj.dtype.type, (np.number, np.bool_)):
+            is_numeric = issubclass(obj.dtype.type, (np.number, np.bool_))
+            if numeric_only and not is_numeric:
                 continue
 
             result, names = self.grouper.aggregate(obj.values, how)
@@ -668,6 +670,11 @@ class Grouper(object):
         'last': lib.group_last
     }
 
+    _cython_object_functions = {
+        'first' : lambda a, b, c, d: lib.group_nth_object(a, b, c, d, 1),
+        'last' : lib.group_last_object
+    }
+
     _cython_transforms = {
         'std' : np.sqrt
     }
@@ -681,7 +688,13 @@ class Grouper(object):
     _filter_empty_groups = True
 
     def aggregate(self, values, how, axis=0):
-        values = com._ensure_float64(values)
+        values = com.ensure_float(values)
+        is_numeric = True
+
+        if not issubclass(values.dtype.type, (np.number, np.bool_)):
+            values = values.astype(object)
+            is_numeric = False
+
         arity = self._cython_arity.get(how, 1)
 
         vdim = values.ndim
@@ -698,15 +711,19 @@ class Grouper(object):
             out_shape = (self.ngroups,) + values.shape[1:]
 
         # will be filled in Cython function
-        result = np.empty(out_shape, dtype=np.float64)
+        result = np.empty(out_shape, dtype=values.dtype)
         counts = np.zeros(self.ngroups, dtype=np.int64)
 
-        result = self._aggregate(result, counts, values, how)
+        result = self._aggregate(result, counts, values, how, is_numeric)
 
         if self._filter_empty_groups:
             if result.ndim == 2:
-                result = lib.row_bool_subset(result,
-                                             (counts > 0).view(np.uint8))
+                if is_numeric:
+                    result = lib.row_bool_subset(result,
+                                                 (counts > 0).view(np.uint8))
+                else:
+                    result = lib.row_bool_subset_object(result,
+                                 (counts > 0).view(np.uint8))
             else:
                 result = result[counts > 0]
 
@@ -724,8 +741,11 @@ class Grouper(object):
 
         return result, names
 
-    def _aggregate(self, result, counts, values, how):
-        agg_func = self._cython_functions[how]
+    def _aggregate(self, result, counts, values, how, is_numeric):
+        fdict = self._cython_functions
+        if not is_numeric:
+            fdict = self._cython_object_functions
+        agg_func = fdict[how]
         trans_func = self._cython_transforms.get(how, lambda x: x)
 
         comp_ids, _, ngroups = self.group_info
@@ -734,8 +754,12 @@ class Grouper(object):
             raise NotImplementedError
         elif values.ndim > 2:
             for i, chunk in enumerate(values.transpose(2, 0, 1)):
+                if not is_numeric:
+                    print 'getting results for %d' % i
                 agg_func(result[:, :, i], counts, chunk.squeeze(),
                          comp_ids)
+                if not is_numeric:
+                    print 'got results for %d' % i
         else:
             agg_func(result, counts, values, comp_ids)
 
@@ -1385,8 +1409,8 @@ class NDFrameGroupBy(GroupBy):
 
             yield val, slicer(val)
 
-    def _cython_agg_general(self, how):
-        new_blocks = self._cython_agg_blocks(how)
+    def _cython_agg_general(self, how, numeric_only=True):
+        new_blocks = self._cython_agg_blocks(how, numeric_only=numeric_only)
         return self._wrap_agged_blocks(new_blocks)
 
     def _wrap_agged_blocks(self, blocks):
@@ -1408,18 +1432,20 @@ class NDFrameGroupBy(GroupBy):
 
     _block_agg_axis = 0
 
-    def _cython_agg_blocks(self, how):
+    def _cython_agg_blocks(self, how, numeric_only=True):
         data, agg_axis = self._get_data_to_aggregate()
 
         new_blocks = []
 
         for block in data.blocks:
             values = block.values
-            if not issubclass(values.dtype.type, (np.number, np.bool_)):
+            is_numeric = issubclass(values.dtype.type, (np.number, np.bool_))
+            if numeric_only and not is_numeric:
                 continue
 
-            values = com._ensure_float64(values)
-            result, names = self.grouper.aggregate(values, how, axis=agg_axis)
+            if is_numeric:
+                values = com.ensure_float(values)
+            result, _ = self.grouper.aggregate(values, how, axis=agg_axis)
             newb = make_block(result, block.items, block.ref_items)
             new_blocks.append(newb)
 
@@ -2210,5 +2236,3 @@ if "IPython" in sys.modules:  # pragma: no cover
         install_ipython_completers()
     except Exception:
         pass
-
-
diff --git a/pandas/src/groupby.pyx b/pandas/src/groupby.pyx
index 552f781e6..e390af97d 100644
--- a/pandas/src/groupby.pyx
+++ b/pandas/src/groupby.pyx
@@ -376,6 +376,49 @@ def group_nth(ndarray[float64_t, ndim=2] out,
             else:
                 out[i, j] = resx[i, j]
 
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def group_nth_object(ndarray[object, ndim=2] out,
+                     ndarray[int64_t] counts,
+                     ndarray[object, ndim=2] values,
+                     ndarray[int64_t] labels,
+                     int64_t rank):
+    '''
+    Only aggregates on axis=0
+    '''
+    cdef:
+        Py_ssize_t i, j, N, K, lab
+        object val
+        float64_t count
+        ndarray[int64_t, ndim=2] nobs
+        ndarray[object, ndim=2] resx
+
+    nobs = np.zeros((<object> out).shape, dtype=np.int64)
+    resx = np.empty((<object> out).shape, dtype=object)
+
+    N, K = (<object> values).shape
+
+    for i in range(N):
+        lab = labels[i]
+        if lab < 0:
+            continue
+
+        counts[lab] += 1
+        for j in range(K):
+            val = values[i, j]
+
+            # not nan
+            if val == val:
+                nobs[lab, j] += 1
+                if nobs[lab, j] == rank:
+                    resx[lab, j] = val
+
+    for i in range(len(counts)):
+        for j in range(K):
+            if nobs[i, j] == 0:
+                out[i, j] = <object> nan
+            else:
+                out[i, j] = resx[i, j]
 
 @cython.boundscheck(False)
 @cython.wraparound(False)
@@ -464,6 +507,48 @@ def group_last(ndarray[float64_t, ndim=2] out,
             else:
                 out[i, j] = resx[i, j]
 
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def group_last_object(ndarray[object, ndim=2] out,
+                      ndarray[int64_t] counts,
+                      ndarray[object, ndim=2] values,
+                      ndarray[int64_t] labels):
+    '''
+    Only aggregates on axis=0
+    '''
+    cdef:
+        Py_ssize_t i, j, N, K, lab
+        object val
+        float64_t count
+        ndarray[object, ndim=2] resx
+        ndarray[int64_t, ndim=2] nobs
+
+    nobs = np.zeros((<object> out).shape, dtype=np.int64)
+    resx = np.empty((<object> out).shape, dtype=object)
+
+    N, K = (<object> values).shape
+
+    for i in range(N):
+        lab = labels[i]
+        if lab < 0:
+            continue
+
+        counts[lab] += 1
+        for j in range(K):
+            val = values[i, j]
+
+            # not nan
+            if val == val:
+                nobs[lab, j] += 1
+                resx[lab, j] = val
+
+    for i in range(len(counts)):
+        for j in range(K):
+            if nobs[i, j] == 0:
+                out[i, j] = nan
+            else:
+                out[i, j] = resx[i, j]
+
 
 @cython.boundscheck(False)
 @cython.wraparound(False)
@@ -1321,6 +1406,26 @@ def row_bool_subset(ndarray[float64_t, ndim=2] values,
 
     return out
 
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def row_bool_subset_object(ndarray[object, ndim=2] values,
+                           ndarray[uint8_t, cast=True] mask):
+    cdef:
+        Py_ssize_t i, j, n, k, pos = 0
+        ndarray[object, ndim=2] out
+
+    n, k = (<object> values).shape
+    assert(n == len(mask))
+
+    out = np.empty((mask.sum(), k), dtype=object)
+
+    for i in range(n):
+        if mask[i]:
+            for j in range(k):
+                out[pos, j] = values[i, j]
+            pos += 1
+
+    return out
 
 
 def group_count(ndarray[int64_t] values, Py_ssize_t size):
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index b3f3bd95f..bf46ed4d2 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -127,12 +127,12 @@ class TestGroupBy(unittest.TestCase):
         # tests for first / last / nth
         grouped = self.df.groupby('A')
         first = grouped.first()
-        expected = self.df.ix[[1, 0], ['C', 'D']]
+        expected = self.df.ix[[1, 0], ['B', 'C', 'D']]
         expected.index = ['bar', 'foo']
         assert_frame_equal(first, expected)
 
         last = grouped.last()
-        expected = self.df.ix[[5, 7], ['C', 'D']]
+        expected = self.df.ix[[5, 7], ['B', 'C', 'D']]
         expected.index = ['bar', 'foo']
         assert_frame_equal(last, expected)
 

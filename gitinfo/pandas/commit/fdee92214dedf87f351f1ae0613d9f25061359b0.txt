commit fdee92214dedf87f351f1ae0613d9f25061359b0
Author: Matt Roeschke <emailformattr@gmail.com>
Date:   Tue Mar 7 08:23:18 2017 -0500

    BUG: Timestamp.round precision error for ns (#15578)
    
    closes #15578
    
    Author: Matt Roeschke <emailformattr@gmail.com>
    
    Closes #15588 from mroeschke/fix_15578 and squashes the following commits:
    
    af95baa [Matt Roeschke] BUG: Timestamp.round precision error for ns (#15578)

diff --git a/doc/source/whatsnew/v0.20.0.txt b/doc/source/whatsnew/v0.20.0.txt
index 725dc7fc5..f1df8f456 100644
--- a/doc/source/whatsnew/v0.20.0.txt
+++ b/doc/source/whatsnew/v0.20.0.txt
@@ -652,7 +652,7 @@ Bug Fixes
 - Bug in ``Index`` power operations with reversed operands (:issue:`14973`)
 - Bug in ``TimedeltaIndex`` addition where overflow was being allowed without error (:issue:`14816`)
 - Bug in ``TimedeltaIndex`` raising a ``ValueError`` when boolean indexing with ``loc`` (:issue:`14946`)
-- Bug in ``DatetimeIndex.round()`` and ``Timestamp.round()`` floating point accuracy when rounding by milliseconds (:issue: `14440`)
+- Bug in ``DatetimeIndex.round()`` and ``Timestamp.round()`` floating point accuracy when rounding by milliseconds or less (:issue: `14440`, :issue:`15578`)
 - Bug in ``astype()`` where ``inf`` values were incorrectly converted to integers. Now raises error now with ``astype()`` for Series and DataFrames (:issue:`14265`)
 - Bug in ``DataFrame(..).apply(to_numeric)`` when values are of type decimal.Decimal. (:issue:`14827`)
 - Bug in ``describe()`` when passing a numpy array which does not contain the median to the ``percentiles`` keyword argument (:issue:`14908`)
diff --git a/pandas/tests/indexes/datetimes/test_ops.py b/pandas/tests/indexes/datetimes/test_ops.py
index 3a6402ae8..312017eef 100644
--- a/pandas/tests/indexes/datetimes/test_ops.py
+++ b/pandas/tests/indexes/datetimes/test_ops.py
@@ -175,17 +175,29 @@ class TestDatetimeIndexOps(Ops):
             tm.assertRaisesRegexp(ValueError, msg, rng.round, freq='M')
             tm.assertRaisesRegexp(ValueError, msg, elt.round, freq='M')
 
-            # GH 14440
+            # GH 14440 & 15578
             index = pd.DatetimeIndex(['2016-10-17 12:00:00.0015'], tz=tz)
             result = index.round('ms')
             expected = pd.DatetimeIndex(['2016-10-17 12:00:00.002000'], tz=tz)
             tm.assert_index_equal(result, expected)
 
+            for freq in ['us', 'ns']:
+                tm.assert_index_equal(index, index.round(freq))
+
             index = pd.DatetimeIndex(['2016-10-17 12:00:00.00149'], tz=tz)
             result = index.round('ms')
             expected = pd.DatetimeIndex(['2016-10-17 12:00:00.001000'], tz=tz)
             tm.assert_index_equal(result, expected)
 
+            index = pd.DatetimeIndex(['2016-10-17 12:00:00.001501031'])
+            result = index.round('10ns')
+            expected = pd.DatetimeIndex(['2016-10-17 12:00:00.001501030'])
+            tm.assert_index_equal(result, expected)
+
+            with tm.assert_produces_warning():
+                ts = '2016-10-17 12:00:00.001501031'
+                pd.DatetimeIndex([ts]).round('1010ns')
+
     def test_repeat_range(self):
         rng = date_range('1/1/2000', '1/1/2001')
 
diff --git a/pandas/tests/scalar/test_timestamp.py b/pandas/tests/scalar/test_timestamp.py
index ae278ebfa..bbcdce922 100644
--- a/pandas/tests/scalar/test_timestamp.py
+++ b/pandas/tests/scalar/test_timestamp.py
@@ -732,7 +732,7 @@ class TestTimestamp(tm.TestCase):
         for freq in ['Y', 'M', 'foobar']:
             self.assertRaises(ValueError, lambda: dti.round(freq))
 
-        # GH 14440
+        # GH 14440 & 15578
         result = pd.Timestamp('2016-10-17 12:00:00.0015').round('ms')
         expected = pd.Timestamp('2016-10-17 12:00:00.002000')
         self.assertEqual(result, expected)
@@ -741,6 +741,17 @@ class TestTimestamp(tm.TestCase):
         expected = pd.Timestamp('2016-10-17 12:00:00.001000')
         self.assertEqual(result, expected)
 
+        ts = pd.Timestamp('2016-10-17 12:00:00.0015')
+        for freq in ['us', 'ns']:
+            self.assertEqual(ts, ts.round(freq))
+
+        result = pd.Timestamp('2016-10-17 12:00:00.001501031').round('10ns')
+        expected = pd.Timestamp('2016-10-17 12:00:00.001501030')
+        self.assertEqual(result, expected)
+
+        with tm.assert_produces_warning():
+            pd.Timestamp('2016-10-17 12:00:00.001501031').round('1010ns')
+
     def test_class_ops_pytz(self):
         tm._skip_if_no_pytz()
         from pytz import timezone
diff --git a/pandas/tseries/base.py b/pandas/tseries/base.py
index 589148167..2e22c3586 100644
--- a/pandas/tseries/base.py
+++ b/pandas/tseries/base.py
@@ -1,6 +1,7 @@
 """
 Base and utility classes for tseries type pandas objects.
 """
+import warnings
 
 from datetime import datetime, timedelta
 
@@ -79,11 +80,20 @@ class TimelikeOps(object):
 
         from pandas.tseries.frequencies import to_offset
         unit = to_offset(freq).nanos
-
         # round the local times
         values = _ensure_datetimelike_to_i8(self)
-
-        result = (unit * rounder(values / float(unit)).astype('i8'))
+        if unit < 1000 and unit % 1000 != 0:
+            # for nano rounding, work with the last 6 digits separately
+            # due to float precision
+            buff = 1000000
+            result = (buff * (values // buff) + unit *
+                      (rounder((values % buff) / float(unit))).astype('i8'))
+        elif unit >= 1000 and unit % 1000 != 0:
+            msg = 'Precision will be lost using frequency: {}'
+            warnings.warn(msg.format(freq))
+            result = (unit * rounder(values / float(unit)).astype('i8'))
+        else:
+            result = (unit * rounder(values / float(unit)).astype('i8'))
         result = self._maybe_mask_results(result, fill_value=tslib.NaT)
         attribs = self._get_attributes_dict()
         if 'freq' in attribs:
diff --git a/pandas/tslib.pyx b/pandas/tslib.pyx
index b96e9434e..8ee92e9fb 100644
--- a/pandas/tslib.pyx
+++ b/pandas/tslib.pyx
@@ -421,7 +421,18 @@ class Timestamp(_Timestamp):
             value = self.tz_localize(None).value
         else:
             value = self.value
-        result = (unit * rounder(value / float(unit)).astype('i8'))
+        if unit < 1000 and unit % 1000 != 0:
+            # for nano rounding, work with the last 6 digits separately
+            # due to float precision
+            buff = 1000000
+            result = (buff * (value // buff) + unit *
+                      (rounder((value % buff) / float(unit))).astype('i8'))
+        elif unit >= 1000 and unit % 1000 != 0:
+            msg = 'Precision will be lost using frequency: {}'
+            warnings.warn(msg.format(freq))
+            result = (unit * rounder(value / float(unit)).astype('i8'))
+        else:
+            result = (unit * rounder(value / float(unit)).astype('i8'))
         result = Timestamp(result, unit='ns')
         if self.tz is not None:
             result = result.tz_localize(self.tz)

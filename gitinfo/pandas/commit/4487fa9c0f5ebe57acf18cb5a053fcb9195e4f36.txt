commit 4487fa9c0f5ebe57acf18cb5a053fcb9195e4f36
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Apr 12 01:33:32 2010 +0000

    merge / join function cleanup
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@155 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index b67e89169..ea7ac31d1 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -244,10 +244,12 @@ class DateRange(Index):
 
     def __getitem__(self, key):
         """Override numpy.ndarray's __getitem__ method to work as desired"""
+        result = self.view(np.ndarray)[key]
+
         if isinstance(key, (int, np.int32)):
-            return self.view(np.ndarray)[key]
+            return result
         elif isinstance(key, slice):
-            newIndex = self.view(np.ndarray)[key].view(DateRange)
+            newIndex = result.view(DateRange)
 
             if key.step is not None:
                 newIndex.offset = key.step * self.offset
@@ -256,7 +258,7 @@ class DateRange(Index):
 
             return newIndex
         else:
-            return Index(self.view(np.ndarray)[key])
+            return Index(result)
 
     def __repr__(self):
         output = str(self.__class__) + '\n'
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index ebd0d701e..6311bb95c 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1289,56 +1289,24 @@ class DataFrame(Picklable, Groupable):
         """
         return self.combine(other, np.multiply, fill_value=1.)
 
-    def outerJoin(self, *frames):
-        unionIndex = self.index
-        for frame in frames:
-            unionIndex  = unionIndex + frame.index
-
-        joined = self.reindex(unionIndex)
-        for frame in frames:
-            frame = frame.reindex(unionIndex)
-            for col, series in frame.iteritems():
-                if col in joined:
-                    raise Exception('Overlapping columns!')
-                joined[col] = series
-
-        return joined
-
-    def leftJoin(self, *frames):
+    def join(self, other, on=None, how=None):
         """
-        Insert columns of input DataFrames / dicts into this one.
-
-        Columns must not overlap. Returns a copy.
-
-        Parameters
-        ----------
-        *frames : list-like
-            List of frames (DataMatrix or DataFrame) as function arguments
-
-        Returns
-        -------
-        DataFrame
-        """
-        joined = self.copy()
-
-        for frame in frames:
-            for col, series in frame.iteritems():
-                if col in joined:
-                    raise Exception('Overlapping columns!')
-                joined[col] = series.copy()
-
-        return joined
-
-    def merge(self, other, on=None):
-        """
-        Merge DataFrame or DataMatrix with this one on some many-to-one index
+        Join columns with other DataFrame either on index or on a key
+        column
 
         Parameters
         ----------
         other : DataFrame
             Index should be similar to one of the columns in this one
-        on : string
-            Column name to use
+        on : string, default None
+            Column name to use, otherwise join on index
+        how : {'left', 'right', 'outer', 'inner'}
+            default: 'left' for joining on index, None otherwise
+            How to handle indexes of the two objects.
+              * left: use calling frame's index
+              * right: use input frame's index
+              * outer: form union of indexes
+              * inner: use intersection of indexes
 
         Examples
         --------
@@ -1349,6 +1317,17 @@ class DataFrame(Picklable, Groupable):
         c   1
         d   0
         """
+        if on is not None:
+            if how is not None:
+                raise Exception('how parameter is not valid when '
+                                '*on* specified')
+            return self._join_on(other, on)
+        else:
+            return self._join_index(other, how)
+
+    merge = join
+
+    def _join_on(self, other, on):
         # Check for column overlap
         overlap = set(self.cols()) & set(other.cols())
 
@@ -1377,6 +1356,35 @@ class DataFrame(Picklable, Groupable):
 
         return self._constructor(newSeries, index=self.index)
 
+    def _join_index(self, other, how):
+        if how == 'left':
+            join_index = self.index
+        elif how == 'right':
+            join_index = other.index
+        elif how == 'inner':
+            join_index = self.index.intersection(other.index)
+        elif how == 'outer':
+            join_index = self.index.union(other.index)
+        else:
+            raise Exception('do not recognize join method %s' % how)
+
+        result_series = self.reindex(join_index)._series
+        other_series = other.reindex(join_index)._series
+
+        for col in other_series:
+            if col in result_series:
+                raise Exception('Overlapping columns!')
+
+        result_series.update(other_series)
+
+        return self._constructor(result_series, index=join_index)
+
+    def outerJoin(self, frame):
+        return self.join(frame, how='outer')
+
+    def leftJoin(self, frame):
+        return self.join(frame, how='left')
+
     def plot(self, kind='line', **kwds): # pragma: no cover
         """
         Plot the DataFrame's series with the index on the x-axis using
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 94201b554..a0a79674c 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -1009,32 +1009,7 @@ class DataMatrix(DataFrame):
 
         return result
 
-    def merge(self, other, on=None, how='left'):
-        """
-        Merge DataFrame or DataMatrix with this one on some many-to-one index
-
-        Parameters
-        ----------
-        other : DataFrame
-            Index should be similar to one of the columns in this one
-        on : string
-            Column name to use
-        how : {'left', 'right', 'outer', 'inner'}
-            How to handle indexes of the two objects.
-              * left: use calling frame's index
-              * right: use input frame's index
-              * outer: form union of indexes
-              * inner: use intersection of indexes
-
-        Examples
-        --------
-        This frame         Other frame
-            c1                 q1
-        a   1              0   v1
-        b   0              1   v2
-        c   1
-        d   0
-        """
+    def _join_on(self, other, on):
         if len(other.index) == 0:
             return self
 
@@ -1064,67 +1039,6 @@ class DataMatrix(DataFrame):
 
         return self.leftJoin(filledFrame)
 
-    def leftJoin(self, *frames):
-        """
-        Insert columns of input DataFrames / dicts into this one.
-
-        Columns must not overlap. Returns a copy.
-
-        Parameters
-        ----------
-        *frames : list-like
-            List of frames (DataMatrix or DataFrame) as function arguments
-
-        Returns
-        -------
-        DataMatrix
-        """
-        unionCols = set(self.columns)
-        frames = list(frames)
-
-        for frame in frames:
-            cols = set(frame.columns)
-            if unionCols & cols:
-                raise Exception('Overlapping columns!')
-            unionCols |= cols
-
-        seriesDict = self._series
-
-        for frame in frames:
-            frame = frame.reindex(self.index)
-            seriesDict.update(frame._series)
-
-        return DataMatrix(seriesDict, index=self.index)
-
-    def outerJoin(self, *frames):
-        """
-        Form union of input frames.
-
-        Columns must not overlap. Returns a copy.
-
-        Parameters
-        ----------
-        *frames : list-like
-            List of frames (DataMatrix or DataFrame) as function arguments
-
-        Returns
-        -------
-        DataMatrix
-        """
-        mergedSeries = self._series.copy()
-
-        unionIndex = self.index
-        for frame in frames:
-            unionIndex  = unionIndex + frame.index
-
-        for frame in frames:
-            for col, series in frame.iteritems():
-                if col in mergedSeries:
-                    raise Exception('Overlapping columns!')
-                mergedSeries[col] = series
-
-        return DataMatrix(mergedSeries)
-
     def _reindex_index(self, index, method):
         if index is self.index:
             return self.copy()
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index a1186e585..0d66f95d8 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -1057,14 +1057,14 @@ class TestDataFrame(unittest.TestCase):
         # corner case
         self.assertRaises(Exception, self.frame.outerJoin, self.frame)
 
-    def test_merge(self):
+    def test_join(self):
         index, data = common.getMixedTypeDict()
         target = self.klass(data, index=index)
 
-        # Merge on string value
+        # Join on string value
         source = self.klass({'MergedA' : data['A'], 'MergedD' : data['D']},
                             index=data['C'])
-        merged = target.merge(source, on='C')
+        merged = target.join(source, on='C')
 
         self.assert_(np.array_equal(merged['MergedA'], target['A']))
         self.assert_(np.array_equal(merged['MergedD'], target['D']))
@@ -1072,17 +1072,21 @@ class TestDataFrame(unittest.TestCase):
         # Test when some are missing
 
         # merge column not p resent
-        self.assertRaises(Exception, target.merge, source, on='E')
+        self.assertRaises(Exception, target.join, source, on='E')
 
         # corner cases
 
         # nothing to merge
-        merged = target.merge(source.reindex([]), on='C')
+        merged = target.join(source.reindex([]), on='C')
 
         # overlap
         source_copy = source.copy()
         source_copy['A'] = 0
-        self.assertRaises(Exception, target.merge, source_copy, on='A')
+        self.assertRaises(Exception, target.join, source_copy, on='A')
+
+        # can't specify how
+        self.assertRaises(Exception, target.join, source, on='C',
+                          how='left')
 
     def test_statistics(self):
         sumFrame = self.frame.apply(np.sum)

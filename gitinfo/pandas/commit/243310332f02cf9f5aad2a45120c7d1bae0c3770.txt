commit 243310332f02cf9f5aad2a45120c7d1bae0c3770
Author: Adam Klein <adamklein@gmail.com>
Date:   Thu Feb 16 22:07:58 2012 -0500

    killed some bugs from merge

diff --git a/pandas/core/common.py b/pandas/core/common.py
index 5d5f954eb..659b8b345 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -59,8 +59,7 @@ def isnull(obj):
             # Working around NumPy ticket 1542
             shape = obj.shape
             result = np.empty(shape, dtype=bool)
-            raveled = obj.ravel()
-            vec = lib.isnullobj(raveled)
+            vec = lib.isnullobj(obj.ravel())
             result[:] = vec.reshape(shape)
 
             if isinstance(obj, Series):
diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index e80cf39a9..04f5eece3 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -386,7 +386,7 @@ class DateRange(DatetimeIndex):
         end = min(left[-1], right[-1])
         start = right[0]
 
-        if left_end < right_start:
+        if end < start:
             return DatetimeIndex([])
         else:
             lslice = slice(*left.slice_locs(start, end))
diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index ab7dfd99a..cfd2433e8 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -35,6 +35,8 @@ def _dt_unbox(key):
     '''
     Timestamp-like => dt64
     '''
+    if type(key) == float:
+        raise TypeError("Cannot unbox a float to datetime")
     return np.datetime64(lib.pydt_to_i8(key))
 
 def _dt_unbox_array(arr):
diff --git a/pandas/core/format.py b/pandas/core/format.py
index c57277913..11ff79c6c 100644
--- a/pandas/core/format.py
+++ b/pandas/core/format.py
@@ -1,7 +1,7 @@
 from itertools import izip
 
 from StringIO import StringIO
-from pandas.core.common import adjoin, isnull, notnull, _stringify
+from pandas.core.common import adjoin, notnull, _stringify
 from pandas.core.index import MultiIndex, _ensure_index
 from pandas.util import py3compat
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 735174faa..da2827309 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1969,6 +1969,9 @@ class DataFrame(NDFrame):
         def _maybe_cast(values):
             if values.dtype == np.object_:
                 values = lib.maybe_convert_objects(values)
+            elif values.dtype == np.datetime64:
+                # converts to datetime
+                values = values.astype('O')
             return values
 
         if not drop:
@@ -1985,7 +1988,7 @@ class DataFrame(NDFrame):
                     new_obj.insert(0, col_name, level_values.take(lab))
             else:
                 name = self.index.name
-                if name is None:
+                if name is None or name == 'index':
                     name = 'index' if 'index' not in self else 'level_0'
                 new_obj.insert(0, name, _maybe_cast(self.index.values))
         new_obj.index = np.arange(len(new_obj))
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 32579b7f1..7344a2323 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -450,8 +450,6 @@ class GroupBy(object):
         result = None
 
         for label, group in self._generate_groups(obj, group_index, ngroups):
-            if group is None:
-                continue
             res = func(group)
             if result is None:
                 try:
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 702c0628c..65d033fca 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -5,16 +5,15 @@ from itertools import izip
 
 import numpy as np
 
-from pandas.core.common import (adjoin as _adjoin, _stringify, _try_sort,
-                                _is_bool_indexer, _asarray_tuplesafe,
-                                is_iterator)
-from pandas.core.datetools import (_dt_box, _dt_unbox, _dt_box_array,
-                                  _dt_unbox_array)
 from pandas.util.decorators import cache_readonly
 import pandas.core.common as com
 import pandas._tseries as lib
 import pandas._engines as _gin
 
+from datetime import datetime
+from pandas.core.datetools import (_dt_box, _dt_unbox, _dt_box_array,
+                                  _dt_unbox_array)
+
 __all__ = ['Index']
 
 
@@ -80,7 +79,6 @@ class Index(np.ndarray):
         else:
             # other iterable of some kind
             subarr = com._asarray_tuplesafe(data, dtype=object)
-            subarr = _asarray_tuplesafe(data, dtype=object)
 
         if dtype is None:
             if (lib.is_datetime_array(subarr)
@@ -878,7 +876,7 @@ class Index(np.ndarray):
         """
         index = np.asarray(self)
         # because numpy is fussy with tuples
-        item_idx = Index([item])
+        item_idx = Index([item], dtype=index.dtype)
         new_index = np.concatenate((index[:loc], item_idx, index[loc:]))
         return Index(new_index, name=self.name)
 
@@ -1200,17 +1198,17 @@ class DatetimeIndex(Int64Index):
                                   % (np.datetime64(failure), freq))
             return DatetimeIndex._quickbuilder(self.name, freq, self.values,
                                                self.first, regular)
-    def shift(self, n=1):
-        if self.freq is None:
-            raise ValueError("Cannot shift, frequency of index is empty")
-
-        if self.regular:
-            return self._construct_from_cache(self.name, self.freq, self.cache,
-                                              self.first+n, self.last+n)
-        else:
-            data = lib.fast_shift(self.asi8, self.freq, n)
-            return DatetimeIndex._quickbuilder(self.name, self.freq, data,
-                                               self.first)
+    #def shift(self, n=1):
+    #    if self.freq is None:
+    #        raise ValueError("Cannot shift, frequency of index is empty")
+
+    #    if self.regular:
+    #        return self._construct_from_cache(self.name, self.freq, self.cache,
+    #                                          self.first+n, self.last+n)
+    #    else:
+    #        data = lib.fast_shift(self.asi8, self.freq, n)
+    #        return DatetimeIndex._quickbuilder(self.name, self.freq, data,
+    #                                           self.first)
 
     def __getitem__(self, key):
         """Override numpy.ndarray's __getitem__ method to work as desired"""
@@ -1226,7 +1224,7 @@ class DatetimeIndex(Int64Index):
             else:
                 return _dt_box(val)
         else:
-            if _is_bool_indexer(key):
+            if com._is_bool_indexer(key):
                 key = np.asarray(key)
 
             result = arr_idx[key]
@@ -2122,7 +2120,7 @@ class MultiIndex(Index):
             section = labs[start:end]
 
             if lab not in lev:
-                if lib.infer_dtype([lab]) != lev.inferred_type:
+                if not lev.is_type_compatible(lib.infer_dtype([lab])):
                     raise Exception('Level type mismatch: %s' % lab)
 
                 # short circuit
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 99732149c..031a1a317 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -30,7 +30,6 @@ import pandas.core.nanops as nanops
 import pandas._tseries as lib
 from pandas.util.decorators import Appender, Substitution
 
-
 __all__ = ['Series', 'TimeSeries']
 
 _np_version = np.version.short_version
@@ -162,19 +161,6 @@ _doc_exclude_na = "NA/null values are excluded"
 _doc_ndarray_interface = ("Extra parameters are to preserve ndarray"
                           "interface.\n")
 
-def _series_dict_handler(data, index, dtype, copy):
-    if index is None:
-        index = Index(sorted(data))
-    else:
-        index = _ensure_index(index)
-
-    data_index = Index(data)
-    indexer = data_index.get_indexer(index)
-    values = _sanitize_array(data.values(), len(index), 
-                             dtype, copy, raise_cast_failure=True)
-    data = com.take_1d(values, indexer)
-    return data, index
-
 #-------------------------------------------------------------------------------
 # Series class
 
@@ -196,11 +182,16 @@ class Series(np.ndarray, generic.PandasObject):
             if index is None:
                 index = data.index
         elif isinstance(data, dict):
-            data, index = _series_dict_handler(data, index, dtype, copy)
-
-        idxlen = len(index) if index is not None else None
+            if index is None:
+                index = Index(sorted(data))
+            else:
+                index = _ensure_index(index)
+            try:
+                data = lib.fast_multiget(data, index, default=np.nan)
+            except TypeError:
+                data = [data.get(i, nan) for i in index]
 
-        subarr = _sanitize_array(data, idxlen, dtype, copy,
+        subarr = _sanitize_array(data, index, dtype, copy,
                                  raise_cast_failure=True)
 
         if not isinstance(subarr, np.ndarray):
@@ -2315,7 +2306,7 @@ def remove_na(arr):
     return arr[notnull(arr)]
 
 
-def _sanitize_array(data, idxlen, dtype=None, copy=False,
+def _sanitize_array(data, index, dtype=None, copy=False,
                     raise_cast_failure=False):
     if isinstance(data, ma.MaskedArray):
         mask = ma.getmaskarray(data)
@@ -2333,7 +2324,7 @@ def _sanitize_array(data, idxlen, dtype=None, copy=False,
     if subarr.ndim == 0:
         if isinstance(data, list):  # pragma: no cover
             subarr = np.array(data, dtype=object)
-        elif idxlen is not None:
+        elif index is not None:
             value = data
 
             # If we create an empty array using a string to infer
@@ -2345,9 +2336,9 @@ def _sanitize_array(data, idxlen, dtype=None, copy=False,
                 dtype = np.object_
 
             if dtype is None:
-                subarr = np.empty(idxlen, dtype=type(value))
+                subarr = np.empty(len(index), dtype=type(value))
             else:
-                subarr = np.empty(idxlen, dtype=dtype)
+                subarr = np.empty(len(index), dtype=dtype)
             subarr.fill(value)
         else:
             return subarr.item()
diff --git a/pandas/src/inference.pyx b/pandas/src/inference.pyx
index 2a3fe34b3..2c18c8b94 100644
--- a/pandas/src/inference.pyx
+++ b/pandas/src/inference.pyx
@@ -23,6 +23,7 @@ try:
     _TYPE_MAP[np.float128] = 'floating'
     _TYPE_MAP[np.complex256] = 'complex'
     _TYPE_MAP[np.float16] = 'floating'
+    _TYPE_MAP[np.datetime64] = 'datetime64'
 
 except AttributeError:
     pass
@@ -90,9 +91,6 @@ cdef inline bint is_datetime(object o):
 cdef inline bint is_timestamp(object o):
     return isinstance(o, Timestamp)
 
-cpdef is_array(object o):
-    return np.PyArray_Check(o)
-
 def is_bool_array(ndarray values):
     cdef:
         Py_ssize_t i, n = len(values)
diff --git a/pandas/tests/test_daterange.py b/pandas/tests/test_daterange.py
index 4c725a934..5eaa40289 100644
--- a/pandas/tests/test_daterange.py
+++ b/pandas/tests/test_daterange.py
@@ -371,7 +371,8 @@ class TestDateRange(unittest.TestCase):
 
         start = datetime(2011, 1, 1)
         exp_values = [start + i * offset for i in range(5)]
-        self.assert_(np.array_equal(result, exp_values))
+        self.assert_(np.array_equal(result, DatetimeIndex(exp_values)))
+
 class TestDatetimePyx(unittest.TestCase):
 
     def test_yearoffset(self):
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 78438fb45..b32be6bcf 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -2158,6 +2158,7 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
     def test_numpy_unique(self):
         # it works!
         result = np.unique(self.ts)
+
 if tm.PERFORM_DATETIME64_TESTS:
     class TestSeriesDatetime64(TestSeries):
         '''
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index 8d1654ce5..c141a39ae 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -278,7 +278,6 @@ class TestMerge(unittest.TestCase):
         tm.assert_frame_equal(result, expected)
 
     def test_join_index_mixed(self):
-
         df1 = DataFrame({'A': 1., 'B': 2, 'C': 'foo', 'D': True},
                         index=np.arange(10),
                         columns=['A', 'B', 'C', 'D'])
@@ -1147,6 +1146,8 @@ class TestConcatenate(unittest.TestCase):
         tm.assert_panel_equal(result, expected)
 
     def test_concat_series(self):
+        from pandas.core.index import DatetimeIndex
+
         ts = tm.makeTimeSeries()
         ts.name = 'foo'
 
@@ -1159,8 +1160,7 @@ class TestConcatenate(unittest.TestCase):
         result = concat(pieces, keys=[0, 1, 2])
         expected = ts.copy()
 
-        ts.index = DatetimeIndex(np.array(ts.index.values, 
-                                          dtype='M8[us]'))
+        ts.index = DatetimeIndex(np.array(ts.index.values, dtype='M8[us]'))
 
         exp_labels = [np.repeat([0, 1, 2], [len(x) for x in pieces]),
                       np.arange(len(ts))]

commit 3dceb4ada78fd005f92f9e49987ccb615d31ee87
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Mar 8 20:08:24 2011 -0500

    refactoring groupby a bit, some speed optimizations, unit tests. transform can propagate things like np.mean now

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 90cf9bbe9..1a24497f8 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1461,7 +1461,7 @@ class DataFrame(Picklable, Groupable):
 
         return indexer
 
-    def apply(self, func, axis=0):
+    def apply(self, func, axis=0, broadcast=False):
         """
         Applies func to columns (Series) of this DataFrame and returns either
         a DataFrame (if the function produces another series) or a Series
@@ -1473,6 +1473,9 @@ class DataFrame(Picklable, Groupable):
         func : function
             Function to apply to each column
         axis : {0, 1}
+        broadcast : bool, default False
+            For aggregation functions, return object of same size with values
+            propagated
 
         Examples
         --------
@@ -1486,6 +1489,12 @@ class DataFrame(Picklable, Groupable):
         if not len(self.cols()):
             return self
 
+        if not broadcast:
+            return self._apply_standard(func, axis)
+        else:
+            return self._apply_broadcast(func, axis)
+
+    def _apply_standard(self, func, axis):
         if axis == 0:
             target = self
             agg_index = self.cols()
@@ -1508,6 +1517,27 @@ class DataFrame(Picklable, Groupable):
         else:
             return Series(results, index=agg_index)
 
+    def _apply_broadcast(self, func, axis):
+        if axis == 0:
+            target = self
+            agg_index = self.cols()
+        elif axis == 1:
+            target = self.T
+            agg_index = self.index
+
+        result_values = np.empty_like(target.values)
+        columns = target.cols()
+        for i, col in enumerate(columns):
+            result_values[:, i] = func(target[col])
+
+        result = self._constructor(result_values, index=target.index,
+                                   columns=target.columns)
+
+        if axis == 1:
+            result = result.T
+
+        return result
+
     def tapply(self, func):
         """
         Apply func to the transposed DataFrame, results as per apply
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 02e68a7a1..e3f7bf5c4 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -1,8 +1,12 @@
+import numpy as np
+
 from cStringIO import StringIO
 
 from pandas.core.frame import DataFrame
 from pandas.core.matrix import DataMatrix
 from pandas.core.series import Series
+from pandas.core.panel import WidePanel
+import pandas.core.common as common
 import pandas.lib.tseries as tseries
 
 class GroupDict(dict):
@@ -117,6 +121,18 @@ class GroupBy(object):
     def transform(self, func):
         raise NotImplementedError
 
+    def mean(self):
+        """
+        Compute mean of groups, excluding missing values
+        """
+        return self.aggregate(np.mean)
+
+    def sum(self):
+        """
+        Compute sum of values, excluding missing values
+        """
+        return self.aggregate(np.sum)
+
     def __getitem__(self, key):
         return self.getGroup(self.groups[key])
 
@@ -218,21 +234,17 @@ class SeriesGroupBy(GroupBy):
         -------
         Series standardized by each unique value of mapping
         """
+        result = self.obj.copy()
 
-        result = {}
-        for val, subseries in self:
-            subseries.groupName = val
-            result[val] = applyfunc(subseries)
-
-        if not isinstance(result.values()[0], Series):
-            raise Exception('Given applyfunc did not return a Series from '
-                            ' the subseries as expected!')
+        for name, group in self:
+            # XXX
+            group.groupName = name
+            res = applyfunc(group)
 
-        allSeries = {}
-        for val, subseries in result.iteritems():
-            allSeries.update(subseries.iteritems())
+            indexer, _ = common.get_indexer(self.obj.index, group.index, None)
+            np.put(result, indexer, res)
 
-        return Series(allSeries)
+        return result
 
 class DataFrameGroupBy(GroupBy):
     _klass = DataFrame
@@ -293,10 +305,10 @@ class DataFrameGroupBy(GroupBy):
         else:
             return self.obj.reindex(columns=groupList)
 
-    def transform(self, applyfunc):
+    def transform(self, func):
         """
         For given DataFrame, group index by given mapper function or dict, take
-        the sub-DataFrame (reindex) for this group and call apply(applyfunc)
+        the sub-DataFrame (reindex) for this group and call apply(func)
         on this sub-DataFrame. Return a DataFrame of the results for each
         key.
 
@@ -309,7 +321,7 @@ class DataFrameGroupBy(GroupBy):
         mapper : function, dict-like, or string
             Mapping or mapping function. If string given, must be a column
             name in the frame
-        applyfunc : function
+        func : function
             Function to apply to each subframe
 
         Note
@@ -319,23 +331,101 @@ class DataFrameGroupBy(GroupBy):
 
         Example
         --------
-        df.fgroupby(lambda x: mapping[x],
-                    lambda x: (x - x.apply(mean)) / x.apply(std))
-
-            DataFrame standardized by each unique value of mapping
+        >>> grouped = df.groupby(lambda x: mapping[x])
+        >>> grouped.transform(lambda x: (x - x.mean()) / x.std())
         """
-        result = {}
+        # DataMatrix objects?
+        result_values = np.empty_like(self.obj.values)
+
+        if self.axis == 1:
+            result_values = result_values.T
+
+        # result = {}
         for val, group in self.groups.iteritems():
-            subframe = self.obj.reindex(list(group))
+            if not isinstance(group, list):
+                group = list(group)
+
+            if self.axis == 0:
+                indexer, _ = common.get_indexer(self.obj.index,
+                                                subframe.index, None)
+            else:
+                indexer, _ = common.get_indexer(self.obj.columns,
+                                                subframe.columns, None)
+
+            subframe = self.obj.reindex(group)
             subframe.groupName = val
-            result[val] = applyfunc(subframe).T
 
-        allSeries = {}
-        for val, frame in result.iteritems():
-            allSeries.update(frame._series)
+            try:
+                res = func(subframe)
+            except Exception:
+                res = subframe.apply(func, axis=self.axis)
+
+            result_values[indexer] = res
+
+            # result[val] = res
 
-        return self._klass(data=allSeries).T
+        if self.axis == 1:
+            result_values = result_values.T
+
+        return DataFrame(result_values, index=self.obj.index,
+                         columns=self.obj.columns)
+        # allSeries = {}
+        # for val, frame in result.iteritems():
+        #     allSeries.update(frame._series)
+
+        # return self._klass(data=allSeries).T
 
 
 class DataMatrixGroupBy(DataFrameGroupBy):
     _klass = DataMatrix
+
+
+class WidePanelGroupBy(GroupBy):
+
+    def __init__(self, obj, grouper, axis=0):
+        self.axis = axis
+
+        if axis not in (0, 1, 2): # pragma: no cover
+            raise ValueError('invalid axis')
+
+        GroupBy.__init__(self, obj, grouper)
+
+    @property
+    def _group_axis(self):
+        return self.obj._get_axis(self.axis)
+
+    def aggregate(self, func):
+        """
+        For given DataFrame, group index by given mapper function or dict, take
+        the sub-DataFrame (reindex) for this group and call apply(func)
+        on this sub-DataFrame. Return a DataFrame of the results for each
+        key.
+
+        Parameters
+        ----------
+        mapper : function, dict-like, or string
+            Mapping or mapping function. If string given, must be a column
+            name in the frame
+        func : function
+            Function to use for aggregating groups
+
+        N.B.: func must produce one value from a Series, otherwise
+        an error will occur.
+
+        Optional: provide set mapping as dictionary
+        """
+        axis_name = self.obj._get_axis_name(self.axis)
+        getter = lambda p, group: p.reindex(**{axis_name : group})
+        result_d = self._aggregate_generic(getter, func,
+                                           axis=self.axis)
+
+        result = WidePanel.fromDict(result_d, intersect=False)
+
+        if self.axis > 0:
+            result = result.swapaxes(0, self.axis)
+
+        return result
+
+class LongPanelGroupBy(GroupBy):
+    pass
+
diff --git a/pandas/core/mixins.py b/pandas/core/mixins.py
index 0f0ccb583..22a56f0d9 100644
--- a/pandas/core/mixins.py
+++ b/pandas/core/mixins.py
@@ -41,6 +41,5 @@ class Groupable(object):
         -------
         GroupBy object
         """
-
         from pandas.core.groupby import groupby
         return groupby(self, mapper)
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index effc1504c..2b2953a4f 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -9,11 +9,10 @@ import warnings
 
 import numpy as np
 
-from pandas.core.groupby import GroupBy
 from pandas.core.index import Index
 from pandas.core.frame import DataFrame
 from pandas.core.matrix import DataMatrix
-from pandas.core.mixins import Picklable
+from pandas.core.mixins import Picklable, Groupable
 import pandas.core.common as common
 import pandas.lib.tseries as tseries
 
@@ -156,7 +155,7 @@ _WIDE_AXIS_NUMBERS = {
 _WIDE_AXIS_NAMES = dict((v, k) for k, v in _WIDE_AXIS_NUMBERS.iteritems())
 
 
-class WidePanel(Panel):
+class WidePanel(Panel, Groupable):
     """
     Represents wide format panel data, stored as 3-dimensional array
 
@@ -578,6 +577,8 @@ class WidePanel(Panel):
 
     def groupby(self, function, axis='major'):
         """
+        Group data on given axis, returning GroupBy object
+
         Parameters
         ----------
         function : callable
@@ -586,8 +587,9 @@ class WidePanel(Panel):
 
         Returns
         -------
-        WidePanelGroupBy
+        grouped : WidePanelGroupBy
         """
+        from pandas.core.groupby import WidePanelGroupBy
         axis = self._get_axis_number(axis)
         return WidePanelGroupBy(self, function, axis=axis)
 
@@ -2008,55 +2010,3 @@ def _slow_pivot(index, columns, values):
 
 def _monotonic(arr):
     return not (arr[1:] < arr[:-1]).any()
-
-#-------------------------------------------------------------------------------
-# GroupBy
-
-class WidePanelGroupBy(GroupBy):
-
-    def __init__(self, obj, grouper, axis=0):
-        self.axis = axis
-
-        if axis not in (0, 1, 2): # pragma: no cover
-            raise ValueError('invalid axis')
-
-        GroupBy.__init__(self, obj, grouper)
-
-    @property
-    def _group_axis(self):
-        return self.obj._get_axis(self.axis)
-
-    def aggregate(self, applyfunc):
-        """
-        For given DataFrame, group index by given mapper function or dict, take
-        the sub-DataFrame (reindex) for this group and call apply(applyfunc)
-        on this sub-DataFrame. Return a DataFrame of the results for each
-        key.
-
-        Parameters
-        ----------
-        mapper : function, dict-like, or string
-            Mapping or mapping function. If string given, must be a column
-            name in the frame
-        applyfunc : function
-            Function to use for aggregating groups
-
-        N.B.: applyfunc must produce one value from a Series, otherwise
-        an error will occur.
-
-        Optional: provide set mapping as dictionary
-        """
-        axis_name = self.obj._get_axis_name(self.axis)
-        getter = lambda p, group: p.reindex(**{axis_name : group})
-        result_d = self._aggregate_generic(getter, applyfunc,
-                                           axis=self.axis)
-
-        result = WidePanel.fromDict(result_d, intersect=False)
-
-        if self.axis > 0:
-            result = result.swapaxes(0, self.axis)
-
-        return result
-
-class LongPanelGroupBy(GroupBy):
-    pass
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index e9bb693f3..38b2c5eb6 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -1204,6 +1204,13 @@ class TestDataFrame(unittest.TestCase):
         self.assertEqual(len(transformed), 30)
         self.assertEqual(len(transformed.cols()), 4)
 
+        # transform propagate
+        transformed = grouped.transform(lambda x: x.mean())
+        for name, group in grouped:
+            mean = group.mean()
+            for idx in group.index:
+                self.assertEqual(transformed[idx], mean)
+
         # iterate
         for weekday, group in grouped:
             self.assert_(group.index[0].weekday() == weekday)
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
index 6431ba9bc..6f928098f 100644
--- a/pandas/core/tests/test_series.py
+++ b/pandas/core/tests/test_series.py
@@ -861,9 +861,11 @@ class TestSeries(unittest.TestCase):
         transformed = grouped.transform(lambda x: x * x.sum())
         self.assertEqual(transformed[7], 12)
 
-        # corner cases
-        self.assertRaises(Exception, grouped.transform,
-                          lambda x: x.mean())
+        transformed = grouped.transform(np.mean)
+        for name, group in grouped:
+            mean = group.mean()
+            for idx in group.index:
+                self.assertEqual(transformed[idx], mean)
 
 if __name__ == '__main__':
     unittest.main()

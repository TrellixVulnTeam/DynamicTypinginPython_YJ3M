commit fbbcc10948e5847f1aa5f20684c15cdfc516f91c
Author: Jeff Reback <jeff@reback.net>
Date:   Tue Apr 11 06:29:30 2017 -0400

    TST/DEPR: fix bunch of Panel deprecation warnings (#15965)
    
    * TST: remove using .to_datetime w/Timestamp as deprecated
    
    * TST: split some sorting tests
    
    * fix isnan comparison deprecation warning
    
    * TST/DEPR: catch Panel deprecation warnings
    
    * close files in tests pickles with compression

diff --git a/pandas/tests/computation/test_eval.py b/pandas/tests/computation/test_eval.py
index 97ed88b1d..78aad90ca 100644
--- a/pandas/tests/computation/test_eval.py
+++ b/pandas/tests/computation/test_eval.py
@@ -1,4 +1,5 @@
 import warnings
+from warnings import catch_warnings
 import operator
 from itertools import product
 
@@ -1130,11 +1131,12 @@ class TestOperationsNumExprPandas(tm.TestCase):
             self.assertEqual(res, exp)
 
     def test_panel_fails(self):
-        x = Panel(randn(3, 4, 5))
-        y = Series(randn(10))
-        with pytest.raises(NotImplementedError):
-            self.eval('x + y',
-                      local_dict={'x': x, 'y': y})
+        with catch_warnings(record=True):
+            x = Panel(randn(3, 4, 5))
+            y = Series(randn(10))
+            with pytest.raises(NotImplementedError):
+                self.eval('x + y',
+                          local_dict={'x': x, 'y': y})
 
     def test_4d_ndarray_fails(self):
         x = randn(3, 4, 5, 6)
diff --git a/pandas/tests/frame/test_reshape.py b/pandas/tests/frame/test_reshape.py
index c8c7313dd..a0ee4ca2c 100644
--- a/pandas/tests/frame/test_reshape.py
+++ b/pandas/tests/frame/test_reshape.py
@@ -2,6 +2,7 @@
 
 from __future__ import print_function
 
+from warnings import catch_warnings
 from datetime import datetime
 import itertools
 
@@ -53,11 +54,12 @@ class TestDataFrameReshape(tm.TestCase, TestData):
         self.assertEqual(pivoted.index.name, 'index')
         self.assertEqual(pivoted.columns.names, (None, 'columns'))
 
-        # pivot multiple columns
-        wp = tm.makePanel()
-        lp = wp.to_frame()
-        df = lp.reset_index()
-        assert_frame_equal(df.pivot('major', 'minor'), lp.unstack())
+        with catch_warnings(record=True):
+            # pivot multiple columns
+            wp = tm.makePanel()
+            lp = wp.to_frame()
+            df = lp.reset_index()
+            assert_frame_equal(df.pivot('major', 'minor'), lp.unstack())
 
     def test_pivot_duplicates(self):
         data = DataFrame({'a': ['bar', 'bar', 'foo', 'foo', 'foo'],
diff --git a/pandas/tests/frame/test_subclass.py b/pandas/tests/frame/test_subclass.py
index 9052a16bf..7444490d1 100644
--- a/pandas/tests/frame/test_subclass.py
+++ b/pandas/tests/frame/test_subclass.py
@@ -2,6 +2,7 @@
 
 from __future__ import print_function
 
+from warnings import catch_warnings
 import numpy as np
 
 from pandas import DataFrame, Series, MultiIndex, Panel
@@ -128,24 +129,25 @@ class TestDataFrameSubclassing(tm.TestCase, TestData):
     def test_to_panel_expanddim(self):
         # GH 9762
 
-        class SubclassedFrame(DataFrame):
-
-            @property
-            def _constructor_expanddim(self):
-                return SubclassedPanel
-
-        class SubclassedPanel(Panel):
-            pass
-
-        index = MultiIndex.from_tuples([(0, 0), (0, 1), (0, 2)])
-        df = SubclassedFrame({'X': [1, 2, 3], 'Y': [4, 5, 6]}, index=index)
-        result = df.to_panel()
-        self.assertTrue(isinstance(result, SubclassedPanel))
-        expected = SubclassedPanel([[[1, 2, 3]], [[4, 5, 6]]],
-                                   items=['X', 'Y'], major_axis=[0],
-                                   minor_axis=[0, 1, 2],
-                                   dtype='int64')
-        tm.assert_panel_equal(result, expected)
+        with catch_warnings(record=True):
+            class SubclassedFrame(DataFrame):
+
+                @property
+                def _constructor_expanddim(self):
+                    return SubclassedPanel
+
+            class SubclassedPanel(Panel):
+                pass
+
+            index = MultiIndex.from_tuples([(0, 0), (0, 1), (0, 2)])
+            df = SubclassedFrame({'X': [1, 2, 3], 'Y': [4, 5, 6]}, index=index)
+            result = df.to_panel()
+            self.assertTrue(isinstance(result, SubclassedPanel))
+            expected = SubclassedPanel([[[1, 2, 3]], [[4, 5, 6]]],
+                                       items=['X', 'Y'], major_axis=[0],
+                                       minor_axis=[0, 1, 2],
+                                       dtype='int64')
+            tm.assert_panel_equal(result, expected)
 
     def test_subclass_attr_err_propagation(self):
         # GH 11808
diff --git a/pandas/tests/groupby/test_groupby.py b/pandas/tests/groupby/test_groupby.py
index c17c98c54..68955c954 100644
--- a/pandas/tests/groupby/test_groupby.py
+++ b/pandas/tests/groupby/test_groupby.py
@@ -1,6 +1,7 @@
 # -*- coding: utf-8 -*-
 from __future__ import print_function
 
+from warnings import catch_warnings
 from string import ascii_lowercase
 from datetime import datetime
 from numpy import nan
@@ -814,12 +815,14 @@ class TestGroupBy(MixIn, tm.TestCase):
         assert_series_equal(result, e)
 
     def test_get_group(self):
-        wp = tm.makePanel()
-        grouped = wp.groupby(lambda x: x.month, axis='major')
+        with catch_warnings(record=True):
+            wp = tm.makePanel()
+            grouped = wp.groupby(lambda x: x.month, axis='major')
 
-        gp = grouped.get_group(1)
-        expected = wp.reindex(major=[x for x in wp.major_axis if x.month == 1])
-        assert_panel_equal(gp, expected)
+            gp = grouped.get_group(1)
+            expected = wp.reindex(
+                major=[x for x in wp.major_axis if x.month == 1])
+            assert_panel_equal(gp, expected)
 
         # GH 5267
         # be datelike friendly
@@ -1317,16 +1320,17 @@ class TestGroupBy(MixIn, tm.TestCase):
             pass
 
     def test_multi_iter_panel(self):
-        wp = tm.makePanel()
-        grouped = wp.groupby([lambda x: x.month, lambda x: x.weekday()],
-                             axis=1)
-
-        for (month, wd), group in grouped:
-            exp_axis = [x
-                        for x in wp.major_axis
-                        if x.month == month and x.weekday() == wd]
-            expected = wp.reindex(major=exp_axis)
-            assert_panel_equal(group, expected)
+        with catch_warnings(record=True):
+            wp = tm.makePanel()
+            grouped = wp.groupby([lambda x: x.month, lambda x: x.weekday()],
+                                 axis=1)
+
+            for (month, wd), group in grouped:
+                exp_axis = [x
+                            for x in wp.major_axis
+                            if x.month == month and x.weekday() == wd]
+                expected = wp.reindex(major=exp_axis)
+                assert_panel_equal(group, expected)
 
     def test_multi_func(self):
         col1 = self.df['A']
@@ -1387,25 +1391,26 @@ class TestGroupBy(MixIn, tm.TestCase):
 
         def _check_op(op):
 
-            result1 = op(grouped)
-
-            expected = defaultdict(dict)
-            for n1, gp1 in data.groupby('A'):
-                for n2, gp2 in gp1.groupby('B'):
-                    expected[n1][n2] = op(gp2.loc[:, ['C', 'D']])
-            expected = dict((k, DataFrame(v))
-                            for k, v in compat.iteritems(expected))
-            expected = Panel.fromDict(expected).swapaxes(0, 1)
-            expected.major_axis.name, expected.minor_axis.name = 'A', 'B'
-
-            # a little bit crude
-            for col in ['C', 'D']:
-                result_col = op(grouped[col])
-                exp = expected[col]
-                pivoted = result1[col].unstack()
-                pivoted2 = result_col.unstack()
-                assert_frame_equal(pivoted.reindex_like(exp), exp)
-                assert_frame_equal(pivoted2.reindex_like(exp), exp)
+            with catch_warnings(record=True):
+                result1 = op(grouped)
+
+                expected = defaultdict(dict)
+                for n1, gp1 in data.groupby('A'):
+                    for n2, gp2 in gp1.groupby('B'):
+                        expected[n1][n2] = op(gp2.loc[:, ['C', 'D']])
+                expected = dict((k, DataFrame(v))
+                                for k, v in compat.iteritems(expected))
+                expected = Panel.fromDict(expected).swapaxes(0, 1)
+                expected.major_axis.name, expected.minor_axis.name = 'A', 'B'
+
+                # a little bit crude
+                for col in ['C', 'D']:
+                    result_col = op(grouped[col])
+                    exp = expected[col]
+                    pivoted = result1[col].unstack()
+                    pivoted2 = result_col.unstack()
+                    assert_frame_equal(pivoted.reindex_like(exp), exp)
+                    assert_frame_equal(pivoted2.reindex_like(exp), exp)
 
         _check_op(lambda x: x.sum())
         _check_op(lambda x: x.mean())
@@ -2980,8 +2985,9 @@ class TestGroupBy(MixIn, tm.TestCase):
 
     def test_sparse_friendly(self):
         sdf = self.df[['C', 'D']].to_sparse()
-        panel = tm.makePanel()
-        tm.add_nans(panel)
+        with catch_warnings(record=True):
+            panel = tm.makePanel()
+            tm.add_nans(panel)
 
         def _check_work(gp):
             gp.mean()
@@ -2997,27 +3003,28 @@ class TestGroupBy(MixIn, tm.TestCase):
         # _check_work(panel.groupby(lambda x: x.month, axis=1))
 
     def test_panel_groupby(self):
-        self.panel = tm.makePanel()
-        tm.add_nans(self.panel)
-        grouped = self.panel.groupby({'ItemA': 0, 'ItemB': 0, 'ItemC': 1},
-                                     axis='items')
-        agged = grouped.mean()
-        agged2 = grouped.agg(lambda x: x.mean('items'))
+        with catch_warnings(record=True):
+            self.panel = tm.makePanel()
+            tm.add_nans(self.panel)
+            grouped = self.panel.groupby({'ItemA': 0, 'ItemB': 0, 'ItemC': 1},
+                                         axis='items')
+            agged = grouped.mean()
+            agged2 = grouped.agg(lambda x: x.mean('items'))
 
-        tm.assert_panel_equal(agged, agged2)
+            tm.assert_panel_equal(agged, agged2)
 
-        self.assert_index_equal(agged.items, Index([0, 1]))
+            self.assert_index_equal(agged.items, Index([0, 1]))
 
-        grouped = self.panel.groupby(lambda x: x.month, axis='major')
-        agged = grouped.mean()
+            grouped = self.panel.groupby(lambda x: x.month, axis='major')
+            agged = grouped.mean()
 
-        exp = Index(sorted(list(set(self.panel.major_axis.month))))
-        self.assert_index_equal(agged.major_axis, exp)
+            exp = Index(sorted(list(set(self.panel.major_axis.month))))
+            self.assert_index_equal(agged.major_axis, exp)
 
-        grouped = self.panel.groupby({'A': 0, 'B': 0, 'C': 1, 'D': 1},
-                                     axis='minor')
-        agged = grouped.mean()
-        self.assert_index_equal(agged.minor_axis, Index([0, 1]))
+            grouped = self.panel.groupby({'A': 0, 'B': 0, 'C': 1, 'D': 1},
+                                         axis='minor')
+            agged = grouped.mean()
+            self.assert_index_equal(agged.minor_axis, Index([0, 1]))
 
     def test_groupby_2d_malformed(self):
         d = DataFrame(index=lrange(2))
diff --git a/pandas/tests/indexes/datetimes/test_tools.py b/pandas/tests/indexes/datetimes/test_tools.py
index 02630c76a..1260ee4e5 100644
--- a/pandas/tests/indexes/datetimes/test_tools.py
+++ b/pandas/tests/indexes/datetimes/test_tools.py
@@ -1533,7 +1533,8 @@ def units_from_epochs():
     return list(range(5))
 
 
-@pytest.fixture(params=[epoch_1960(), epoch_1960().to_datetime(),
+@pytest.fixture(params=[epoch_1960(),
+                        epoch_1960().to_pydatetime(),
                         epoch_1960().to_datetime64(),
                         str(epoch_1960())])
 def epochs(request):
diff --git a/pandas/tests/indexing/common.py b/pandas/tests/indexing/common.py
index c7637a009..0f8a9573a 100644
--- a/pandas/tests/indexing/common.py
+++ b/pandas/tests/indexing/common.py
@@ -37,41 +37,46 @@ class Base(object):
         self.frame_ints = DataFrame(np.random.randn(4, 4),
                                     index=lrange(0, 8, 2),
                                     columns=lrange(0, 12, 3))
-        self.panel_ints = Panel(np.random.rand(4, 4, 4),
-                                items=lrange(0, 8, 2),
-                                major_axis=lrange(0, 12, 3),
-                                minor_axis=lrange(0, 16, 4))
+        with catch_warnings(record=True):
+            self.panel_ints = Panel(np.random.rand(4, 4, 4),
+                                    items=lrange(0, 8, 2),
+                                    major_axis=lrange(0, 12, 3),
+                                    minor_axis=lrange(0, 16, 4))
 
         self.series_uints = Series(np.random.rand(4),
                                    index=UInt64Index(lrange(0, 8, 2)))
         self.frame_uints = DataFrame(np.random.randn(4, 4),
                                      index=UInt64Index(lrange(0, 8, 2)),
                                      columns=UInt64Index(lrange(0, 12, 3)))
-        self.panel_uints = Panel(np.random.rand(4, 4, 4),
-                                 items=UInt64Index(lrange(0, 8, 2)),
-                                 major_axis=UInt64Index(lrange(0, 12, 3)),
-                                 minor_axis=UInt64Index(lrange(0, 16, 4)))
+        with catch_warnings(record=True):
+            self.panel_uints = Panel(np.random.rand(4, 4, 4),
+                                     items=UInt64Index(lrange(0, 8, 2)),
+                                     major_axis=UInt64Index(lrange(0, 12, 3)),
+                                     minor_axis=UInt64Index(lrange(0, 16, 4)))
 
         self.series_labels = Series(np.random.randn(4), index=list('abcd'))
         self.frame_labels = DataFrame(np.random.randn(4, 4),
                                       index=list('abcd'), columns=list('ABCD'))
-        self.panel_labels = Panel(np.random.randn(4, 4, 4),
-                                  items=list('abcd'),
-                                  major_axis=list('ABCD'),
-                                  minor_axis=list('ZYXW'))
+        with catch_warnings(record=True):
+            self.panel_labels = Panel(np.random.randn(4, 4, 4),
+                                      items=list('abcd'),
+                                      major_axis=list('ABCD'),
+                                      minor_axis=list('ZYXW'))
 
         self.series_mixed = Series(np.random.randn(4), index=[2, 4, 'null', 8])
         self.frame_mixed = DataFrame(np.random.randn(4, 4),
                                      index=[2, 4, 'null', 8])
-        self.panel_mixed = Panel(np.random.randn(4, 4, 4),
-                                 items=[2, 4, 'null', 8])
+        with catch_warnings(record=True):
+            self.panel_mixed = Panel(np.random.randn(4, 4, 4),
+                                     items=[2, 4, 'null', 8])
 
         self.series_ts = Series(np.random.randn(4),
                                 index=date_range('20130101', periods=4))
         self.frame_ts = DataFrame(np.random.randn(4, 4),
                                   index=date_range('20130101', periods=4))
-        self.panel_ts = Panel(np.random.randn(4, 4, 4),
-                              items=date_range('20130101', periods=4))
+        with catch_warnings(record=True):
+            self.panel_ts = Panel(np.random.randn(4, 4, 4),
+                                  items=date_range('20130101', periods=4))
 
         dates_rev = (date_range('20130101', periods=4)
                      .sort_values(ascending=False))
@@ -79,12 +84,14 @@ class Base(object):
                                     index=dates_rev)
         self.frame_ts_rev = DataFrame(np.random.randn(4, 4),
                                       index=dates_rev)
-        self.panel_ts_rev = Panel(np.random.randn(4, 4, 4),
-                                  items=dates_rev)
+        with catch_warnings(record=True):
+            self.panel_ts_rev = Panel(np.random.randn(4, 4, 4),
+                                      items=dates_rev)
 
         self.frame_empty = DataFrame({})
         self.series_empty = Series({})
-        self.panel_empty = Panel({})
+        with catch_warnings(record=True):
+            self.panel_empty = Panel({})
 
         # form agglomerates
         for o in self._objs:
@@ -255,8 +262,18 @@ class Base(object):
                         continue
 
                     obj = d[t]
-                    if obj is not None:
+                    if obj is None:
+                        continue
+
+                    def _call(obj=obj):
                         obj = obj.copy()
 
                         k2 = key2
                         _eq(t, o, a, obj, key1, k2)
+
+                    # Panel deprecations
+                    if isinstance(obj, Panel):
+                        with catch_warnings(record=True):
+                            _call()
+                    else:
+                        _call()
diff --git a/pandas/tests/indexing/test_multiindex.py b/pandas/tests/indexing/test_multiindex.py
index 1fc0a8776..07786b9fb 100644
--- a/pandas/tests/indexing/test_multiindex.py
+++ b/pandas/tests/indexing/test_multiindex.py
@@ -1164,87 +1164,98 @@ class TestMultiIndexSlicers(tm.TestCase):
 class TestMultiIndexPanel(tm.TestCase):
 
     def test_iloc_getitem_panel_multiindex(self):
-        # GH 7199
-        # Panel with multi-index
-        multi_index = pd.MultiIndex.from_tuples([('ONE', 'one'),
-                                                 ('TWO', 'two'),
-                                                 ('THREE', 'three')],
-                                                names=['UPPER', 'lower'])
-
-        simple_index = [x[0] for x in multi_index]
-        wd1 = Panel(items=['First', 'Second'], major_axis=['a', 'b', 'c', 'd'],
-                    minor_axis=multi_index)
-
-        wd2 = Panel(items=['First', 'Second'], major_axis=['a', 'b', 'c', 'd'],
-                    minor_axis=simple_index)
-
-        expected1 = wd1['First'].iloc[[True, True, True, False], [0, 2]]
-        result1 = wd1.iloc[0, [True, True, True, False], [0, 2]]  # WRONG
-        tm.assert_frame_equal(result1, expected1)
-
-        expected2 = wd2['First'].iloc[[True, True, True, False], [0, 2]]
-        result2 = wd2.iloc[0, [True, True, True, False], [0, 2]]
-        tm.assert_frame_equal(result2, expected2)
-
-        expected1 = DataFrame(index=['a'], columns=multi_index,
-                              dtype='float64')
-        result1 = wd1.iloc[0, [0], [0, 1, 2]]
-        tm.assert_frame_equal(result1, expected1)
-
-        expected2 = DataFrame(index=['a'], columns=simple_index,
-                              dtype='float64')
-        result2 = wd2.iloc[0, [0], [0, 1, 2]]
-        tm.assert_frame_equal(result2, expected2)
-
-        # GH 7516
-        mi = MultiIndex.from_tuples([(0, 'x'), (1, 'y'), (2, 'z')])
-        p = Panel(np.arange(3 * 3 * 3, dtype='int64').reshape(3, 3, 3),
-                  items=['a', 'b', 'c'], major_axis=mi,
-                  minor_axis=['u', 'v', 'w'])
-        result = p.iloc[:, 1, 0]
-        expected = Series([3, 12, 21], index=['a', 'b', 'c'], name='u')
-        tm.assert_series_equal(result, expected)
 
-        result = p.loc[:, (1, 'y'), 'u']
-        tm.assert_series_equal(result, expected)
+        with catch_warnings(record=True):
+
+            # GH 7199
+            # Panel with multi-index
+            multi_index = pd.MultiIndex.from_tuples([('ONE', 'one'),
+                                                     ('TWO', 'two'),
+                                                     ('THREE', 'three')],
+                                                    names=['UPPER', 'lower'])
+
+            simple_index = [x[0] for x in multi_index]
+            wd1 = Panel(items=['First', 'Second'],
+                        major_axis=['a', 'b', 'c', 'd'],
+                        minor_axis=multi_index)
+
+            wd2 = Panel(items=['First', 'Second'],
+                        major_axis=['a', 'b', 'c', 'd'],
+                        minor_axis=simple_index)
+
+            expected1 = wd1['First'].iloc[[True, True, True, False], [0, 2]]
+            result1 = wd1.iloc[0, [True, True, True, False], [0, 2]]  # WRONG
+            tm.assert_frame_equal(result1, expected1)
+
+            expected2 = wd2['First'].iloc[[True, True, True, False], [0, 2]]
+            result2 = wd2.iloc[0, [True, True, True, False], [0, 2]]
+            tm.assert_frame_equal(result2, expected2)
+
+            expected1 = DataFrame(index=['a'], columns=multi_index,
+                                  dtype='float64')
+            result1 = wd1.iloc[0, [0], [0, 1, 2]]
+            tm.assert_frame_equal(result1, expected1)
+
+            expected2 = DataFrame(index=['a'], columns=simple_index,
+                                  dtype='float64')
+            result2 = wd2.iloc[0, [0], [0, 1, 2]]
+            tm.assert_frame_equal(result2, expected2)
+
+            # GH 7516
+            mi = MultiIndex.from_tuples([(0, 'x'), (1, 'y'), (2, 'z')])
+            p = Panel(np.arange(3 * 3 * 3, dtype='int64').reshape(3, 3, 3),
+                      items=['a', 'b', 'c'], major_axis=mi,
+                      minor_axis=['u', 'v', 'w'])
+            result = p.iloc[:, 1, 0]
+            expected = Series([3, 12, 21], index=['a', 'b', 'c'], name='u')
+            tm.assert_series_equal(result, expected)
+
+            result = p.loc[:, (1, 'y'), 'u']
+            tm.assert_series_equal(result, expected)
 
     def test_panel_setitem_with_multiindex(self):
 
-        # 10360
-        # failing with a multi-index
-        arr = np.array([[[1, 2, 3], [0, 0, 0]], [[0, 0, 0], [0, 0, 0]]],
-                       dtype=np.float64)
-
-        # reg index
-        axes = dict(items=['A', 'B'], major_axis=[0, 1],
-                    minor_axis=['X', 'Y', 'Z'])
-        p1 = Panel(0., **axes)
-        p1.iloc[0, 0, :] = [1, 2, 3]
-        expected = Panel(arr, **axes)
-        tm.assert_panel_equal(p1, expected)
-
-        # multi-indexes
-        axes['items'] = pd.MultiIndex.from_tuples([('A', 'a'), ('B', 'b')])
-        p2 = Panel(0., **axes)
-        p2.iloc[0, 0, :] = [1, 2, 3]
-        expected = Panel(arr, **axes)
-        tm.assert_panel_equal(p2, expected)
-
-        axes['major_axis'] = pd.MultiIndex.from_tuples([('A', 1), ('A', 2)])
-        p3 = Panel(0., **axes)
-        p3.iloc[0, 0, :] = [1, 2, 3]
-        expected = Panel(arr, **axes)
-        tm.assert_panel_equal(p3, expected)
-
-        axes['minor_axis'] = pd.MultiIndex.from_product([['X'], range(3)])
-        p4 = Panel(0., **axes)
-        p4.iloc[0, 0, :] = [1, 2, 3]
-        expected = Panel(arr, **axes)
-        tm.assert_panel_equal(p4, expected)
-
-        arr = np.array(
-            [[[1, 0, 0], [2, 0, 0]], [[0, 0, 0], [0, 0, 0]]], dtype=np.float64)
-        p5 = Panel(0., **axes)
-        p5.iloc[0, :, 0] = [1, 2]
-        expected = Panel(arr, **axes)
-        tm.assert_panel_equal(p5, expected)
+        with catch_warnings(record=True):
+            # 10360
+            # failing with a multi-index
+            arr = np.array([[[1, 2, 3], [0, 0, 0]],
+                            [[0, 0, 0], [0, 0, 0]]],
+                           dtype=np.float64)
+
+            # reg index
+            axes = dict(items=['A', 'B'], major_axis=[0, 1],
+                        minor_axis=['X', 'Y', 'Z'])
+            p1 = Panel(0., **axes)
+            p1.iloc[0, 0, :] = [1, 2, 3]
+            expected = Panel(arr, **axes)
+            tm.assert_panel_equal(p1, expected)
+
+            # multi-indexes
+            axes['items'] = pd.MultiIndex.from_tuples(
+                [('A', 'a'), ('B', 'b')])
+            p2 = Panel(0., **axes)
+            p2.iloc[0, 0, :] = [1, 2, 3]
+            expected = Panel(arr, **axes)
+            tm.assert_panel_equal(p2, expected)
+
+            axes['major_axis'] = pd.MultiIndex.from_tuples(
+                [('A', 1), ('A', 2)])
+            p3 = Panel(0., **axes)
+            p3.iloc[0, 0, :] = [1, 2, 3]
+            expected = Panel(arr, **axes)
+            tm.assert_panel_equal(p3, expected)
+
+            axes['minor_axis'] = pd.MultiIndex.from_product(
+                [['X'], range(3)])
+            p4 = Panel(0., **axes)
+            p4.iloc[0, 0, :] = [1, 2, 3]
+            expected = Panel(arr, **axes)
+            tm.assert_panel_equal(p4, expected)
+
+            arr = np.array(
+                [[[1, 0, 0], [2, 0, 0]], [[0, 0, 0], [0, 0, 0]]],
+                dtype=np.float64)
+            p5 = Panel(0., **axes)
+            p5.iloc[0, :, 0] = [1, 2]
+            expected = Panel(arr, **axes)
+            tm.assert_panel_equal(p5, expected)
diff --git a/pandas/tests/indexing/test_panel.py b/pandas/tests/indexing/test_panel.py
index 0677ea498..8daef6155 100644
--- a/pandas/tests/indexing/test_panel.py
+++ b/pandas/tests/indexing/test_panel.py
@@ -1,3 +1,4 @@
+import pytest
 from warnings import catch_warnings
 
 import numpy as np
@@ -9,201 +10,210 @@ class TestPanel(tm.TestCase):
 
     def test_iloc_getitem_panel(self):
 
-        # GH 7189
-        p = Panel(np.arange(4 * 3 * 2).reshape(4, 3, 2),
-                  items=['A', 'B', 'C', 'D'],
-                  major_axis=['a', 'b', 'c'],
-                  minor_axis=['one', 'two'])
+        with catch_warnings(record=True):
+            # GH 7189
+            p = Panel(np.arange(4 * 3 * 2).reshape(4, 3, 2),
+                      items=['A', 'B', 'C', 'D'],
+                      major_axis=['a', 'b', 'c'],
+                      minor_axis=['one', 'two'])
 
-        result = p.iloc[1]
-        expected = p.loc['B']
-        tm.assert_frame_equal(result, expected)
+            result = p.iloc[1]
+            expected = p.loc['B']
+            tm.assert_frame_equal(result, expected)
 
-        result = p.iloc[1, 1]
-        expected = p.loc['B', 'b']
-        tm.assert_series_equal(result, expected)
+            result = p.iloc[1, 1]
+            expected = p.loc['B', 'b']
+            tm.assert_series_equal(result, expected)
 
-        result = p.iloc[1, 1, 1]
-        expected = p.loc['B', 'b', 'two']
-        self.assertEqual(result, expected)
+            result = p.iloc[1, 1, 1]
+            expected = p.loc['B', 'b', 'two']
+            self.assertEqual(result, expected)
 
-        # slice
-        result = p.iloc[1:3]
-        expected = p.loc[['B', 'C']]
-        tm.assert_panel_equal(result, expected)
+            # slice
+            result = p.iloc[1:3]
+            expected = p.loc[['B', 'C']]
+            tm.assert_panel_equal(result, expected)
 
-        result = p.iloc[:, 0:2]
-        expected = p.loc[:, ['a', 'b']]
-        tm.assert_panel_equal(result, expected)
+            result = p.iloc[:, 0:2]
+            expected = p.loc[:, ['a', 'b']]
+            tm.assert_panel_equal(result, expected)
 
-        # list of integers
-        result = p.iloc[[0, 2]]
-        expected = p.loc[['A', 'C']]
-        tm.assert_panel_equal(result, expected)
+            # list of integers
+            result = p.iloc[[0, 2]]
+            expected = p.loc[['A', 'C']]
+            tm.assert_panel_equal(result, expected)
 
-        # neg indicies
-        result = p.iloc[[-1, 1], [-1, 1]]
-        expected = p.loc[['D', 'B'], ['c', 'b']]
-        tm.assert_panel_equal(result, expected)
+            # neg indicies
+            result = p.iloc[[-1, 1], [-1, 1]]
+            expected = p.loc[['D', 'B'], ['c', 'b']]
+            tm.assert_panel_equal(result, expected)
 
-        # dups indicies
-        result = p.iloc[[-1, -1, 1], [-1, 1]]
-        expected = p.loc[['D', 'D', 'B'], ['c', 'b']]
-        tm.assert_panel_equal(result, expected)
+            # dups indicies
+            result = p.iloc[[-1, -1, 1], [-1, 1]]
+            expected = p.loc[['D', 'D', 'B'], ['c', 'b']]
+            tm.assert_panel_equal(result, expected)
 
-        # combined
-        result = p.iloc[0, [True, True], [0, 1]]
-        expected = p.loc['A', ['a', 'b'], ['one', 'two']]
-        tm.assert_frame_equal(result, expected)
+            # combined
+            result = p.iloc[0, [True, True], [0, 1]]
+            expected = p.loc['A', ['a', 'b'], ['one', 'two']]
+            tm.assert_frame_equal(result, expected)
 
-        # out-of-bounds exception
-        self.assertRaises(IndexError, p.iloc.__getitem__, tuple([10, 5]))
+            # out-of-bounds exception
+            with pytest.raises(IndexError):
+                p.iloc[tuple([10, 5])]
 
-        def f():
-            p.iloc[0, [True, True], [0, 1, 2]]
+            def f():
+                p.iloc[0, [True, True], [0, 1, 2]]
 
-        self.assertRaises(IndexError, f)
+            self.assertRaises(IndexError, f)
 
-        # trying to use a label
-        self.assertRaises(ValueError, p.iloc.__getitem__, tuple(['j', 'D']))
+            # trying to use a label
+            with pytest.raises(ValueError):
+                p.iloc[tuple(['j', 'D'])]
 
-        # GH
-        p = Panel(
-            np.random.rand(4, 3, 2), items=['A', 'B', 'C', 'D'],
-            major_axis=['U', 'V', 'W'], minor_axis=['X', 'Y'])
-        expected = p['A']
+            # GH
+            p = Panel(
+                np.random.rand(4, 3, 2), items=['A', 'B', 'C', 'D'],
+                major_axis=['U', 'V', 'W'], minor_axis=['X', 'Y'])
+            expected = p['A']
 
-        result = p.iloc[0, :, :]
-        tm.assert_frame_equal(result, expected)
+            result = p.iloc[0, :, :]
+            tm.assert_frame_equal(result, expected)
 
-        result = p.iloc[0, [True, True, True], :]
-        tm.assert_frame_equal(result, expected)
+            result = p.iloc[0, [True, True, True], :]
+            tm.assert_frame_equal(result, expected)
 
-        result = p.iloc[0, [True, True, True], [0, 1]]
-        tm.assert_frame_equal(result, expected)
+            result = p.iloc[0, [True, True, True], [0, 1]]
+            tm.assert_frame_equal(result, expected)
 
-        def f():
-            p.iloc[0, [True, True, True], [0, 1, 2]]
+            def f():
+                p.iloc[0, [True, True, True], [0, 1, 2]]
 
-        self.assertRaises(IndexError, f)
+            self.assertRaises(IndexError, f)
 
-        def f():
-            p.iloc[0, [True, True, True], [2]]
+            def f():
+                p.iloc[0, [True, True, True], [2]]
 
-        self.assertRaises(IndexError, f)
+            self.assertRaises(IndexError, f)
 
     def test_iloc_panel_issue(self):
 
-        # GH 3617
-        p = Panel(np.random.randn(4, 4, 4))
+        with catch_warnings(record=True):
+            # GH 3617
+            p = Panel(np.random.randn(4, 4, 4))
 
-        self.assertEqual(p.iloc[:3, :3, :3].shape, (3, 3, 3))
-        self.assertEqual(p.iloc[1, :3, :3].shape, (3, 3))
-        self.assertEqual(p.iloc[:3, 1, :3].shape, (3, 3))
-        self.assertEqual(p.iloc[:3, :3, 1].shape, (3, 3))
-        self.assertEqual(p.iloc[1, 1, :3].shape, (3, ))
-        self.assertEqual(p.iloc[1, :3, 1].shape, (3, ))
-        self.assertEqual(p.iloc[:3, 1, 1].shape, (3, ))
+            self.assertEqual(p.iloc[:3, :3, :3].shape, (3, 3, 3))
+            self.assertEqual(p.iloc[1, :3, :3].shape, (3, 3))
+            self.assertEqual(p.iloc[:3, 1, :3].shape, (3, 3))
+            self.assertEqual(p.iloc[:3, :3, 1].shape, (3, 3))
+            self.assertEqual(p.iloc[1, 1, :3].shape, (3, ))
+            self.assertEqual(p.iloc[1, :3, 1].shape, (3, ))
+            self.assertEqual(p.iloc[:3, 1, 1].shape, (3, ))
 
     def test_panel_getitem(self):
-        # GH4016, date selection returns a frame when a partial string
-        # selection
-        ind = date_range(start="2000", freq="D", periods=1000)
-        df = DataFrame(
-            np.random.randn(
-                len(ind), 5), index=ind, columns=list('ABCDE'))
-        panel = Panel(dict([('frame_' + c, df) for c in list('ABC')]))
-
-        test2 = panel.loc[:, "2002":"2002-12-31"]
-        test1 = panel.loc[:, "2002"]
-        tm.assert_panel_equal(test1, test2)
 
-        # GH8710
-        # multi-element getting with a list
-        panel = tm.makePanel()
-
-        expected = panel.iloc[[0, 1]]
-
-        result = panel.loc[['ItemA', 'ItemB']]
-        tm.assert_panel_equal(result, expected)
+        with catch_warnings(record=True):
+            # GH4016, date selection returns a frame when a partial string
+            # selection
+            ind = date_range(start="2000", freq="D", periods=1000)
+            df = DataFrame(
+                np.random.randn(
+                    len(ind), 5), index=ind, columns=list('ABCDE'))
+            panel = Panel(dict([('frame_' + c, df) for c in list('ABC')]))
 
-        result = panel.loc[['ItemA', 'ItemB'], :, :]
-        tm.assert_panel_equal(result, expected)
+            test2 = panel.loc[:, "2002":"2002-12-31"]
+            test1 = panel.loc[:, "2002"]
+            tm.assert_panel_equal(test1, test2)
 
-        result = panel[['ItemA', 'ItemB']]
-        tm.assert_panel_equal(result, expected)
+            # GH8710
+            # multi-element getting with a list
+            panel = tm.makePanel()
 
-        result = panel.loc['ItemA':'ItemB']
-        tm.assert_panel_equal(result, expected)
+            expected = panel.iloc[[0, 1]]
 
-        with catch_warnings(record=True):
-            result = panel.ix[['ItemA', 'ItemB']]
-        tm.assert_panel_equal(result, expected)
+            result = panel.loc[['ItemA', 'ItemB']]
+            tm.assert_panel_equal(result, expected)
 
-        # with an object-like
-        # GH 9140
-        class TestObject:
+            result = panel.loc[['ItemA', 'ItemB'], :, :]
+            tm.assert_panel_equal(result, expected)
 
-            def __str__(self):
-                return "TestObject"
+            result = panel[['ItemA', 'ItemB']]
+            tm.assert_panel_equal(result, expected)
 
-        obj = TestObject()
+            result = panel.loc['ItemA':'ItemB']
+            tm.assert_panel_equal(result, expected)
 
-        p = Panel(np.random.randn(1, 5, 4), items=[obj],
-                  major_axis=date_range('1/1/2000', periods=5),
-                  minor_axis=['A', 'B', 'C', 'D'])
+            with catch_warnings(record=True):
+                result = panel.ix[['ItemA', 'ItemB']]
+            tm.assert_panel_equal(result, expected)
 
-        expected = p.iloc[0]
-        result = p[obj]
-        tm.assert_frame_equal(result, expected)
+            # with an object-like
+            # GH 9140
+            class TestObject:
 
-    def test_panel_setitem(self):
+                def __str__(self):
+                    return "TestObject"
 
-        # GH 7763
-        # loc and setitem have setting differences
-        np.random.seed(0)
-        index = range(3)
-        columns = list('abc')
+            obj = TestObject()
 
-        panel = Panel({'A': DataFrame(np.random.randn(3, 3),
-                                      index=index, columns=columns),
-                       'B': DataFrame(np.random.randn(3, 3),
-                                      index=index, columns=columns),
-                       'C': DataFrame(np.random.randn(3, 3),
-                                      index=index, columns=columns)})
+            p = Panel(np.random.randn(1, 5, 4), items=[obj],
+                      major_axis=date_range('1/1/2000', periods=5),
+                      minor_axis=['A', 'B', 'C', 'D'])
 
-        replace = DataFrame(np.eye(3, 3), index=range(3), columns=columns)
-        expected = Panel({'A': replace, 'B': replace, 'C': replace})
+            expected = p.iloc[0]
+            result = p[obj]
+            tm.assert_frame_equal(result, expected)
 
-        p = panel.copy()
-        for idx in list('ABC'):
-            p[idx] = replace
-        tm.assert_panel_equal(p, expected)
+    def test_panel_setitem(self):
 
-        p = panel.copy()
-        for idx in list('ABC'):
-            p.loc[idx, :, :] = replace
-        tm.assert_panel_equal(p, expected)
+        with catch_warnings(record=True):
+            # GH 7763
+            # loc and setitem have setting differences
+            np.random.seed(0)
+            index = range(3)
+            columns = list('abc')
+
+            panel = Panel({'A': DataFrame(np.random.randn(3, 3),
+                                          index=index, columns=columns),
+                           'B': DataFrame(np.random.randn(3, 3),
+                                          index=index, columns=columns),
+                           'C': DataFrame(np.random.randn(3, 3),
+                                          index=index, columns=columns)})
+
+            replace = DataFrame(np.eye(3, 3), index=range(3), columns=columns)
+            expected = Panel({'A': replace, 'B': replace, 'C': replace})
+
+            p = panel.copy()
+            for idx in list('ABC'):
+                p[idx] = replace
+            tm.assert_panel_equal(p, expected)
+
+            p = panel.copy()
+            for idx in list('ABC'):
+                p.loc[idx, :, :] = replace
+            tm.assert_panel_equal(p, expected)
 
     def test_panel_assignment(self):
-        # GH3777
-        wp = Panel(np.random.randn(2, 5, 4), items=['Item1', 'Item2'],
-                   major_axis=date_range('1/1/2000', periods=5),
-                   minor_axis=['A', 'B', 'C', 'D'])
-        wp2 = Panel(np.random.randn(2, 5, 4), items=['Item1', 'Item2'],
-                    major_axis=date_range('1/1/2000', periods=5),
-                    minor_axis=['A', 'B', 'C', 'D'])
-
-        # TODO: unused?
-        # expected = wp.loc[['Item1', 'Item2'], :, ['A', 'B']]
-
-        def f():
-            wp.loc[['Item1', 'Item2'], :, ['A', 'B']] = wp2.loc[
-                ['Item1', 'Item2'], :, ['A', 'B']]
-
-        self.assertRaises(NotImplementedError, f)
-
-        # to_assign = wp2.loc[['Item1', 'Item2'], :, ['A', 'B']]
-        # wp.loc[['Item1', 'Item2'], :, ['A', 'B']] = to_assign
-        # result = wp.loc[['Item1', 'Item2'], :, ['A', 'B']]
-        # tm.assert_panel_equal(result,expected)
+
+        with catch_warnings(record=True):
+            # GH3777
+            wp = Panel(np.random.randn(2, 5, 4), items=['Item1', 'Item2'],
+                       major_axis=date_range('1/1/2000', periods=5),
+                       minor_axis=['A', 'B', 'C', 'D'])
+            wp2 = Panel(np.random.randn(2, 5, 4), items=['Item1', 'Item2'],
+                        major_axis=date_range('1/1/2000', periods=5),
+                        minor_axis=['A', 'B', 'C', 'D'])
+
+            # TODO: unused?
+            # expected = wp.loc[['Item1', 'Item2'], :, ['A', 'B']]
+
+            def f():
+                wp.loc[['Item1', 'Item2'], :, ['A', 'B']] = wp2.loc[
+                    ['Item1', 'Item2'], :, ['A', 'B']]
+
+            self.assertRaises(NotImplementedError, f)
+
+            # to_assign = wp2.loc[['Item1', 'Item2'], :, ['A', 'B']]
+            # wp.loc[['Item1', 'Item2'], :, ['A', 'B']] = to_assign
+            # result = wp.loc[['Item1', 'Item2'], :, ['A', 'B']]
+            # tm.assert_panel_equal(result,expected)
diff --git a/pandas/tests/indexing/test_partial.py b/pandas/tests/indexing/test_partial.py
index 31fadcc88..f51f050c5 100644
--- a/pandas/tests/indexing/test_partial.py
+++ b/pandas/tests/indexing/test_partial.py
@@ -119,33 +119,34 @@ class TestPartialSetting(tm.TestCase):
             df.ix[:, 'C'] = df.ix[:, 'A']
         tm.assert_frame_equal(df, expected)
 
-        # ## panel ##
-        p_orig = Panel(np.arange(16).reshape(2, 4, 2),
-                       items=['Item1', 'Item2'],
-                       major_axis=pd.date_range('2001/1/12', periods=4),
-                       minor_axis=['A', 'B'], dtype='float64')
-
-        # panel setting via item
-        p_orig = Panel(np.arange(16).reshape(2, 4, 2),
-                       items=['Item1', 'Item2'],
-                       major_axis=pd.date_range('2001/1/12', periods=4),
-                       minor_axis=['A', 'B'], dtype='float64')
-        expected = p_orig.copy()
-        expected['Item3'] = expected['Item1']
-        p = p_orig.copy()
-        p.loc['Item3'] = p['Item1']
-        tm.assert_panel_equal(p, expected)
-
-        # panel with aligned series
-        expected = p_orig.copy()
-        expected = expected.transpose(2, 1, 0)
-        expected['C'] = DataFrame({'Item1': [30, 30, 30, 30],
-                                   'Item2': [32, 32, 32, 32]},
-                                  index=p_orig.major_axis)
-        expected = expected.transpose(2, 1, 0)
-        p = p_orig.copy()
-        p.loc[:, :, 'C'] = Series([30, 32], index=p_orig.items)
-        tm.assert_panel_equal(p, expected)
+        with catch_warnings(record=True):
+            # ## panel ##
+            p_orig = Panel(np.arange(16).reshape(2, 4, 2),
+                           items=['Item1', 'Item2'],
+                           major_axis=pd.date_range('2001/1/12', periods=4),
+                           minor_axis=['A', 'B'], dtype='float64')
+
+            # panel setting via item
+            p_orig = Panel(np.arange(16).reshape(2, 4, 2),
+                           items=['Item1', 'Item2'],
+                           major_axis=pd.date_range('2001/1/12', periods=4),
+                           minor_axis=['A', 'B'], dtype='float64')
+            expected = p_orig.copy()
+            expected['Item3'] = expected['Item1']
+            p = p_orig.copy()
+            p.loc['Item3'] = p['Item1']
+            tm.assert_panel_equal(p, expected)
+
+            # panel with aligned series
+            expected = p_orig.copy()
+            expected = expected.transpose(2, 1, 0)
+            expected['C'] = DataFrame({'Item1': [30, 30, 30, 30],
+                                       'Item2': [32, 32, 32, 32]},
+                                      index=p_orig.major_axis)
+            expected = expected.transpose(2, 1, 0)
+            p = p_orig.copy()
+            p.loc[:, :, 'C'] = Series([30, 32], index=p_orig.items)
+            tm.assert_panel_equal(p, expected)
 
         # GH 8473
         dates = date_range('1/1/2000', periods=8)
diff --git a/pandas/tests/io/generate_legacy_storage_files.py b/pandas/tests/io/generate_legacy_storage_files.py
index d0365cb2c..22c62b738 100644
--- a/pandas/tests/io/generate_legacy_storage_files.py
+++ b/pandas/tests/io/generate_legacy_storage_files.py
@@ -1,5 +1,6 @@
 """ self-contained to write legacy storage (pickle/msgpack) files """
 from __future__ import print_function
+from warnings import catch_warnings
 from distutils.version import LooseVersion
 from pandas import (Series, DataFrame, Panel,
                     SparseSeries, SparseDataFrame,
@@ -127,14 +128,16 @@ def create_data():
                      u'B': Timestamp('20130603', tz='CET')}, index=range(5))
                  )
 
-    mixed_dup_panel = Panel({u'ItemA': frame[u'float'],
-                             u'ItemB': frame[u'int']})
-    mixed_dup_panel.items = [u'ItemA', u'ItemA']
-    panel = dict(float=Panel({u'ItemA': frame[u'float'],
-                              u'ItemB': frame[u'float'] + 1}),
-                 dup=Panel(np.arange(30).reshape(3, 5, 2).astype(np.float64),
-                           items=[u'A', u'B', u'A']),
-                 mixed_dup=mixed_dup_panel)
+    with catch_warnings(record=True):
+        mixed_dup_panel = Panel({u'ItemA': frame[u'float'],
+                                 u'ItemB': frame[u'int']})
+        mixed_dup_panel.items = [u'ItemA', u'ItemA']
+        panel = dict(float=Panel({u'ItemA': frame[u'float'],
+                                  u'ItemB': frame[u'float'] + 1}),
+                     dup=Panel(
+                         np.arange(30).reshape(3, 5, 2).astype(np.float64),
+                         items=[u'A', u'B', u'A']),
+                     mixed_dup=mixed_dup_panel)
 
     cat = dict(int8=Categorical(list('abcdefg')),
                int16=Categorical(np.arange(1000)),
diff --git a/pandas/tests/io/msgpack/common.py b/pandas/tests/io/msgpack/common.py
new file mode 100644
index 000000000..b770d12cf
--- /dev/null
+++ b/pandas/tests/io/msgpack/common.py
@@ -0,0 +1,10 @@
+from pandas.compat import PY3
+
+
+# array compat
+if PY3:
+    frombytes = lambda obj, data: obj.frombytes(data)
+    tobytes = lambda obj: obj.tobytes()
+else:
+    frombytes = lambda obj, data: obj.fromstring(data)
+    tobytes = lambda obj: obj.tostring()
diff --git a/pandas/tests/io/msgpack/test_buffer.py b/pandas/tests/io/msgpack/test_buffer.py
index 5a2dc3dba..8ebec734f 100644
--- a/pandas/tests/io/msgpack/test_buffer.py
+++ b/pandas/tests/io/msgpack/test_buffer.py
@@ -1,12 +1,13 @@
 # coding: utf-8
 
 from pandas.io.msgpack import packb, unpackb
+from .common import frombytes
 
 
 def test_unpack_buffer():
     from array import array
     buf = array('b')
-    buf.fromstring(packb((b'foo', b'bar')))
+    frombytes(buf, packb((b'foo', b'bar')))
     obj = unpackb(buf, use_list=1)
     assert [b'foo', b'bar'] == obj
 
diff --git a/pandas/tests/io/msgpack/test_extension.py b/pandas/tests/io/msgpack/test_extension.py
index a5a111efb..26a611bea 100644
--- a/pandas/tests/io/msgpack/test_extension.py
+++ b/pandas/tests/io/msgpack/test_extension.py
@@ -1,7 +1,9 @@
 from __future__ import print_function
 import array
+
 import pandas.io.msgpack as msgpack
 from pandas.io.msgpack import ExtType
+from .common import frombytes, tobytes
 
 
 def test_pack_ext_type():
@@ -42,7 +44,7 @@ def test_extension_type():
         print('default called', obj)
         if isinstance(obj, array.array):
             typecode = 123  # application specific typecode
-            data = obj.tostring()
+            data = tobytes(obj)
             return ExtType(typecode, data)
         raise TypeError("Unknwon type object %r" % (obj, ))
 
@@ -50,7 +52,7 @@ def test_extension_type():
         print('ext_hook called', code, data)
         assert code == 123
         obj = array.array('d')
-        obj.fromstring(data)
+        frombytes(obj, data)
         return obj
 
     obj = [42, b'hello', array.array('d', [1.1, 2.2, 3.3])]
diff --git a/pandas/tests/io/test_excel.py b/pandas/tests/io/test_excel.py
index 256a37e92..d83e26995 100644
--- a/pandas/tests/io/test_excel.py
+++ b/pandas/tests/io/test_excel.py
@@ -7,6 +7,7 @@ import os
 from distutils.version import LooseVersion
 
 import warnings
+from warnings import catch_warnings
 import operator
 import functools
 import pytest
@@ -2340,9 +2341,13 @@ class ExcelWriterEngineTests(tm.TestCase):
             writer = ExcelWriter('something.test')
             tm.assertIsInstance(writer, DummyClass)
             df = tm.makeCustomDataframe(1, 1)
-            panel = tm.makePanel()
-            func = lambda: df.to_excel('something.test')
-            check_called(func)
-            check_called(lambda: panel.to_excel('something.test'))
-            check_called(lambda: df.to_excel('something.xlsx'))
-            check_called(lambda: df.to_excel('something.xls', engine='dummy'))
+
+            with catch_warnings(record=True):
+                panel = tm.makePanel()
+                func = lambda: df.to_excel('something.test')
+                check_called(func)
+                check_called(lambda: panel.to_excel('something.test'))
+                check_called(lambda: df.to_excel('something.xlsx'))
+                check_called(
+                    lambda: df.to_excel(
+                        'something.xls', engine='dummy'))
diff --git a/pandas/tests/io/test_packers.py b/pandas/tests/io/test_packers.py
index 1b6b0fc62..4856cd8c5 100644
--- a/pandas/tests/io/test_packers.py
+++ b/pandas/tests/io/test_packers.py
@@ -1,5 +1,6 @@
 import pytest
 
+from warnings import catch_warnings
 import os
 import datetime
 import numpy as np
@@ -452,9 +453,10 @@ class TestNDFrame(TestPackers):
             'int': DataFrame(dict(A=data['B'], B=Series(data['B']) + 1)),
             'mixed': DataFrame(data)}
 
-        self.panel = {
-            'float': Panel(dict(ItemA=self.frame['float'],
-                                ItemB=self.frame['float'] + 1))}
+        with catch_warnings(record=True):
+            self.panel = {
+                'float': Panel(dict(ItemA=self.frame['float'],
+                                    ItemB=self.frame['float'] + 1))}
 
     def test_basic_frame(self):
 
@@ -464,9 +466,10 @@ class TestNDFrame(TestPackers):
 
     def test_basic_panel(self):
 
-        for s, i in self.panel.items():
-            i_rec = self.encode_decode(i)
-            assert_panel_equal(i, i_rec)
+        with catch_warnings(record=True):
+            for s, i in self.panel.items():
+                i_rec = self.encode_decode(i)
+                assert_panel_equal(i, i_rec)
 
     def test_multi(self):
 
@@ -899,8 +902,9 @@ TestPackers
                 continue
             vf = os.path.join(pth, f)
             try:
-                self.compare(current_packers_data, all_packers_data,
-                             vf, version)
+                with catch_warnings(record=True):
+                    self.compare(current_packers_data, all_packers_data,
+                                 vf, version)
             except ImportError:
                 # blosc not installed
                 continue
diff --git a/pandas/tests/io/test_pickle.py b/pandas/tests/io/test_pickle.py
index f46f62e78..0746cacb0 100644
--- a/pandas/tests/io/test_pickle.py
+++ b/pandas/tests/io/test_pickle.py
@@ -14,6 +14,8 @@ $ python generate_legacy_storage_files.py <output_dir> pickle
 """
 
 import pytest
+from warnings import catch_warnings
+
 import os
 from distutils.version import LooseVersion
 import pandas as pd
@@ -202,7 +204,8 @@ def test_pickles(current_pickle_data, version):
     n = 0
     for f in os.listdir(pth):
         vf = os.path.join(pth, f)
-        data = compare(current_pickle_data, vf, version)
+        with catch_warnings(record=True):
+            data = compare(current_pickle_data, vf, version)
 
         if data is None:
             continue
@@ -339,7 +342,8 @@ class TestCompression(object):
             raise ValueError(msg)
 
         if compression != "zip":
-            f.write(open(src_path, "rb").read())
+            with open(src_path, "rb") as fh:
+                f.write(fh.read())
             f.close()
 
     def decompress_file(self, src_path, dest_path, compression):
@@ -369,7 +373,8 @@ class TestCompression(object):
             msg = 'Unrecognized compression type: {}'.format(compression)
             raise ValueError(msg)
 
-        open(dest_path, "wb").write(f.read())
+        with open(dest_path, "wb") as fh:
+            fh.write(f.read())
         f.close()
 
     @pytest.mark.parametrize('compression', [None, 'gzip', 'bz2', 'xz'])
diff --git a/pandas/tests/sparse/test_frame.py b/pandas/tests/sparse/test_frame.py
index e6482d70e..075d5efce 100644
--- a/pandas/tests/sparse/test_frame.py
+++ b/pandas/tests/sparse/test_frame.py
@@ -3,7 +3,7 @@
 import operator
 
 import pytest
-
+from warnings import catch_warnings
 from numpy import nan
 import numpy as np
 import pandas as pd
@@ -953,23 +953,25 @@ class TestSparseDataFrame(tm.TestCase, SharedWithSparse):
         self._check_all(_check)
 
     def test_stack_sparse_frame(self):
-        def _check(frame):
-            dense_frame = frame.to_dense()  # noqa
+        with catch_warnings(record=True):
+
+            def _check(frame):
+                dense_frame = frame.to_dense()  # noqa
 
-            wp = Panel.from_dict({'foo': frame})
-            from_dense_lp = wp.to_frame()
+                wp = Panel.from_dict({'foo': frame})
+                from_dense_lp = wp.to_frame()
 
-            from_sparse_lp = spf.stack_sparse_frame(frame)
+                from_sparse_lp = spf.stack_sparse_frame(frame)
 
-            self.assert_numpy_array_equal(from_dense_lp.values,
-                                          from_sparse_lp.values)
+                self.assert_numpy_array_equal(from_dense_lp.values,
+                                              from_sparse_lp.values)
 
-        _check(self.frame)
-        _check(self.iframe)
+            _check(self.frame)
+            _check(self.iframe)
 
-        # for now
-        self.assertRaises(Exception, _check, self.zframe)
-        self.assertRaises(Exception, _check, self.fill_frame)
+            # for now
+            self.assertRaises(Exception, _check, self.zframe)
+            self.assertRaises(Exception, _check, self.fill_frame)
 
     def test_transpose(self):
 
diff --git a/pandas/tests/test_categorical.py b/pandas/tests/test_categorical.py
index 63c1ae70e..adacbb95f 100644
--- a/pandas/tests/test_categorical.py
+++ b/pandas/tests/test_categorical.py
@@ -1,6 +1,7 @@
 # -*- coding: utf-8 -*-
 # pylint: disable=E1101,E1103,W0232
 
+from warnings import catch_warnings
 import pytest
 import sys
 from datetime import datetime
@@ -1816,9 +1817,11 @@ class TestCategoricalAsBlock(tm.TestCase):
 
     def test_reshaping(self):
 
-        p = tm.makePanel()
-        p['str'] = 'foo'
-        df = p.to_frame()
+        with catch_warnings(record=True):
+            p = tm.makePanel()
+            p['str'] = 'foo'
+            df = p.to_frame()
+
         df['category'] = df['str'].astype('category')
         result = df['category'].unstack()
 
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 914d26fca..e3193cddb 100755
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -1253,14 +1253,15 @@ Thur,Lunch,Yes,51.51,17"""
         tm.assert_frame_equal(swapped, exp)
 
     def test_swaplevel_panel(self):
-        panel = Panel({'ItemA': self.frame, 'ItemB': self.frame * 2})
-        expected = panel.copy()
-        expected.major_axis = expected.major_axis.swaplevel(0, 1)
-
-        for result in (panel.swaplevel(axis='major'),
-                       panel.swaplevel(0, axis='major'),
-                       panel.swaplevel(0, 1, axis='major')):
-            tm.assert_panel_equal(result, expected)
+        with catch_warnings(record=True):
+            panel = Panel({'ItemA': self.frame, 'ItemB': self.frame * 2})
+            expected = panel.copy()
+            expected.major_axis = expected.major_axis.swaplevel(0, 1)
+
+            for result in (panel.swaplevel(axis='major'),
+                           panel.swaplevel(0, axis='major'),
+                           panel.swaplevel(0, 1, axis='major')):
+                tm.assert_panel_equal(result, expected)
 
     def test_reorder_levels(self):
         result = self.ymd.reorder_levels(['month', 'day', 'year'])
diff --git a/pandas/tests/test_sorting.py b/pandas/tests/test_sorting.py
index 99361695b..fad1fbc52 100644
--- a/pandas/tests/test_sorting.py
+++ b/pandas/tests/test_sorting.py
@@ -18,6 +18,7 @@ from pandas.core.sorting import (is_int64_overflow_possible,
 
 class TestSorting(tm.TestCase):
 
+    @pytest.mark.slow
     def test_int64_overflow(self):
 
         B = np.concatenate((np.arange(1000), np.arange(1000), np.arange(500)))
@@ -51,9 +52,11 @@ class TestSorting(tm.TestCase):
         expected = df.groupby(tups).sum()['values']
 
         for k, v in compat.iteritems(expected):
-            self.assertEqual(left[k], right[k[::-1]])
-            self.assertEqual(left[k], v)
-        self.assertEqual(len(left), len(right))
+            assert left[k] == right[k[::-1]]
+            assert left[k] == v
+        assert len(left) == len(right)
+
+    def test_int64_overflow_moar(self):
 
         # GH9096
         values = range(55109)
@@ -62,7 +65,7 @@ class TestSorting(tm.TestCase):
                                        'c': values,
                                        'd': values})
         grouped = data.groupby(['a', 'b', 'c', 'd'])
-        self.assertEqual(len(grouped), len(values))
+        assert len(grouped) == len(values)
 
         arr = np.random.randint(-1 << 12, 1 << 12, (1 << 15, 5))
         i = np.random.choice(len(arr), len(arr) * 4)
@@ -76,7 +79,7 @@ class TestSorting(tm.TestCase):
         gr = df.groupby(list('abcde'))
 
         # verify this is testing what it is supposed to test!
-        self.assertTrue(is_int64_overflow_possible(gr.grouper.shape))
+        assert is_int64_overflow_possible(gr.grouper.shape)
 
         # mannually compute groupings
         jim, joe = defaultdict(list), defaultdict(list)
@@ -84,7 +87,7 @@ class TestSorting(tm.TestCase):
             jim[key].append(a)
             joe[key].append(b)
 
-        self.assertEqual(len(gr), len(jim))
+        assert len(gr) == len(jim)
         mi = MultiIndex.from_tuples(jim.keys(), names=list('abcde'))
 
         def aggr(func):
@@ -201,7 +204,7 @@ class TestMerge(tm.TestCase):
 
         # it works!
         result = merge(df1, df2, how='outer')
-        self.assertTrue(len(result) == 2000)
+        assert len(result) == 2000
 
         low, high, n = -1 << 10, 1 << 10, 1 << 20
         left = DataFrame(np.random.randint(low, high, (n, 7)),
@@ -216,11 +219,11 @@ class TestMerge(tm.TestCase):
         right['right'] *= -1
 
         out = merge(left, right, how='outer')
-        self.assertEqual(len(out), len(left))
+        assert len(out) == len(left)
         assert_series_equal(out['left'], - out['right'], check_names=False)
         result = out.iloc[:, :-2].sum(axis=1)
         assert_series_equal(out['left'], result, check_names=False)
-        self.assertTrue(result.name is None)
+        assert result.name is None
 
         out.sort_values(out.columns.tolist(), inplace=True)
         out.index = np.arange(len(out))
@@ -241,7 +244,7 @@ class TestMerge(tm.TestCase):
 
         # confirm that this is checking what it is supposed to check
         shape = left.apply(Series.nunique).values
-        self.assertTrue(is_int64_overflow_possible(shape))
+        assert is_int64_overflow_possible(shape)
 
         # add duplicates to left frame
         left = concat([left, left], ignore_index=True)
@@ -307,7 +310,7 @@ class TestMerge(tm.TestCase):
         for how in 'left', 'right', 'outer', 'inner':
             mask = jmask[how]
             frame = align(out[mask].copy())
-            self.assertTrue(mask.all() ^ mask.any() or how == 'outer')
+            assert mask.all() ^ mask.any() or how == 'outer'
 
             for sort in [False, True]:
                 res = merge(left, right, how=how, sort=sort)
diff --git a/pandas/tests/tools/test_concat.py b/pandas/tests/tools/test_concat.py
index c61f2a3dc..2ff287acc 100644
--- a/pandas/tests/tools/test_concat.py
+++ b/pandas/tests/tools/test_concat.py
@@ -1936,21 +1936,23 @@ bar2,12,13,14,15
 @pytest.mark.parametrize('pdt', [pd.Series, pd.DataFrame, pd.Panel])
 @pytest.mark.parametrize('dt', np.sctypes['float'])
 def test_concat_no_unnecessary_upcast(dt, pdt):
-    # GH 13247
-    dims = pdt().ndim
-    dfs = [pdt(np.array([1], dtype=dt, ndmin=dims)),
-           pdt(np.array([np.nan], dtype=dt, ndmin=dims)),
-           pdt(np.array([5], dtype=dt, ndmin=dims))]
-    x = pd.concat(dfs)
-    assert x.values.dtype == dt
+    with catch_warnings(record=True):
+        # GH 13247
+        dims = pdt().ndim
+        dfs = [pdt(np.array([1], dtype=dt, ndmin=dims)),
+               pdt(np.array([np.nan], dtype=dt, ndmin=dims)),
+               pdt(np.array([5], dtype=dt, ndmin=dims))]
+        x = pd.concat(dfs)
+        assert x.values.dtype == dt
 
 
 @pytest.mark.parametrize('pdt', [pd.Series, pd.DataFrame, pd.Panel])
 @pytest.mark.parametrize('dt', np.sctypes['int'])
 def test_concat_will_upcast(dt, pdt):
-    dims = pdt().ndim
-    dfs = [pdt(np.array([1], dtype=dt, ndmin=dims)),
-           pdt(np.array([np.nan], ndmin=dims)),
-           pdt(np.array([5], dtype=dt, ndmin=dims))]
-    x = pd.concat(dfs)
-    assert x.values.dtype == 'float64'
+    with catch_warnings(record=True):
+        dims = pdt().ndim
+        dfs = [pdt(np.array([1], dtype=dt, ndmin=dims)),
+               pdt(np.array([np.nan], ndmin=dims)),
+               pdt(np.array([5], dtype=dt, ndmin=dims))]
+        x = pd.concat(dfs)
+        assert x.values.dtype == 'float64'
diff --git a/pandas/tests/tools/test_hashing.py b/pandas/tests/tools/test_hashing.py
index 864b5018a..467b058fa 100644
--- a/pandas/tests/tools/test_hashing.py
+++ b/pandas/tests/tools/test_hashing.py
@@ -1,3 +1,6 @@
+import pytest
+
+from warnings import catch_warnings
 import numpy as np
 import pandas as pd
 
@@ -195,11 +198,14 @@ class TestHashing(tm.TestCase):
 
     def test_pandas_errors(self):
 
-        for obj in [pd.Timestamp('20130101'), tm.makePanel()]:
-            def f():
-                hash_pandas_object(f)
+        for obj in [pd.Timestamp('20130101')]:
+            with pytest.raises(TypeError):
+                hash_pandas_object(obj)
 
-            self.assertRaises(TypeError, f)
+        with catch_warnings(record=True):
+            obj = tm.makePanel()
+        with pytest.raises(TypeError):
+            hash_pandas_object(obj)
 
     def test_hash_keys(self):
         # using different hash keys, should have different hashes
diff --git a/pandas/tests/tools/test_join.py b/pandas/tests/tools/test_join.py
index b65f80080..8571a1ff1 100644
--- a/pandas/tests/tools/test_join.py
+++ b/pandas/tests/tools/test_join.py
@@ -1,5 +1,6 @@
 # pylint: disable=E1103
 
+from warnings import catch_warnings
 from numpy.random import randn
 import numpy as np
 
@@ -629,87 +630,90 @@ class TestJoin(tm.TestCase):
         assert_frame_equal(dta, expected)
 
     def test_panel_join(self):
-        panel = tm.makePanel()
-        tm.add_nans(panel)
-
-        p1 = panel.iloc[:2, :10, :3]
-        p2 = panel.iloc[2:, 5:, 2:]
-
-        # left join
-        result = p1.join(p2)
-        expected = p1.copy()
-        expected['ItemC'] = p2['ItemC']
-        tm.assert_panel_equal(result, expected)
-
-        # right join
-        result = p1.join(p2, how='right')
-        expected = p2.copy()
-        expected['ItemA'] = p1['ItemA']
-        expected['ItemB'] = p1['ItemB']
-        expected = expected.reindex(items=['ItemA', 'ItemB', 'ItemC'])
-        tm.assert_panel_equal(result, expected)
-
-        # inner join
-        result = p1.join(p2, how='inner')
-        expected = panel.iloc[:, 5:10, 2:3]
-        tm.assert_panel_equal(result, expected)
-
-        # outer join
-        result = p1.join(p2, how='outer')
-        expected = p1.reindex(major=panel.major_axis,
-                              minor=panel.minor_axis)
-        expected = expected.join(p2.reindex(major=panel.major_axis,
-                                            minor=panel.minor_axis))
-        tm.assert_panel_equal(result, expected)
+        with catch_warnings(record=True):
+            panel = tm.makePanel()
+            tm.add_nans(panel)
+
+            p1 = panel.iloc[:2, :10, :3]
+            p2 = panel.iloc[2:, 5:, 2:]
+
+            # left join
+            result = p1.join(p2)
+            expected = p1.copy()
+            expected['ItemC'] = p2['ItemC']
+            tm.assert_panel_equal(result, expected)
+
+            # right join
+            result = p1.join(p2, how='right')
+            expected = p2.copy()
+            expected['ItemA'] = p1['ItemA']
+            expected['ItemB'] = p1['ItemB']
+            expected = expected.reindex(items=['ItemA', 'ItemB', 'ItemC'])
+            tm.assert_panel_equal(result, expected)
+
+            # inner join
+            result = p1.join(p2, how='inner')
+            expected = panel.iloc[:, 5:10, 2:3]
+            tm.assert_panel_equal(result, expected)
+
+            # outer join
+            result = p1.join(p2, how='outer')
+            expected = p1.reindex(major=panel.major_axis,
+                                  minor=panel.minor_axis)
+            expected = expected.join(p2.reindex(major=panel.major_axis,
+                                                minor=panel.minor_axis))
+            tm.assert_panel_equal(result, expected)
 
     def test_panel_join_overlap(self):
-        panel = tm.makePanel()
-        tm.add_nans(panel)
-
-        p1 = panel.loc[['ItemA', 'ItemB', 'ItemC']]
-        p2 = panel.loc[['ItemB', 'ItemC']]
-
-        # Expected index is
-        #
-        # ItemA, ItemB_p1, ItemC_p1, ItemB_p2, ItemC_p2
-        joined = p1.join(p2, lsuffix='_p1', rsuffix='_p2')
-        p1_suf = p1.loc[['ItemB', 'ItemC']].add_suffix('_p1')
-        p2_suf = p2.loc[['ItemB', 'ItemC']].add_suffix('_p2')
-        no_overlap = panel.loc[['ItemA']]
-        expected = no_overlap.join(p1_suf.join(p2_suf))
-        tm.assert_panel_equal(joined, expected)
+        with catch_warnings(record=True):
+            panel = tm.makePanel()
+            tm.add_nans(panel)
+
+            p1 = panel.loc[['ItemA', 'ItemB', 'ItemC']]
+            p2 = panel.loc[['ItemB', 'ItemC']]
+
+            # Expected index is
+            #
+            # ItemA, ItemB_p1, ItemC_p1, ItemB_p2, ItemC_p2
+            joined = p1.join(p2, lsuffix='_p1', rsuffix='_p2')
+            p1_suf = p1.loc[['ItemB', 'ItemC']].add_suffix('_p1')
+            p2_suf = p2.loc[['ItemB', 'ItemC']].add_suffix('_p2')
+            no_overlap = panel.loc[['ItemA']]
+            expected = no_overlap.join(p1_suf.join(p2_suf))
+            tm.assert_panel_equal(joined, expected)
 
     def test_panel_join_many(self):
-        tm.K = 10
-        panel = tm.makePanel()
-        tm.K = 4
+        with catch_warnings(record=True):
+            tm.K = 10
+            panel = tm.makePanel()
+            tm.K = 4
 
-        panels = [panel.iloc[:2], panel.iloc[2:6], panel.iloc[6:]]
+            panels = [panel.iloc[:2], panel.iloc[2:6], panel.iloc[6:]]
 
-        joined = panels[0].join(panels[1:])
-        tm.assert_panel_equal(joined, panel)
+            joined = panels[0].join(panels[1:])
+            tm.assert_panel_equal(joined, panel)
 
-        panels = [panel.iloc[:2, :-5],
-                  panel.iloc[2:6, 2:],
-                  panel.iloc[6:, 5:-7]]
+            panels = [panel.iloc[:2, :-5],
+                      panel.iloc[2:6, 2:],
+                      panel.iloc[6:, 5:-7]]
 
-        data_dict = {}
-        for p in panels:
-            data_dict.update(p.iteritems())
+            data_dict = {}
+            for p in panels:
+                data_dict.update(p.iteritems())
 
-        joined = panels[0].join(panels[1:], how='inner')
-        expected = pd.Panel.from_dict(data_dict, intersect=True)
-        tm.assert_panel_equal(joined, expected)
+            joined = panels[0].join(panels[1:], how='inner')
+            expected = pd.Panel.from_dict(data_dict, intersect=True)
+            tm.assert_panel_equal(joined, expected)
 
-        joined = panels[0].join(panels[1:], how='outer')
-        expected = pd.Panel.from_dict(data_dict, intersect=False)
-        tm.assert_panel_equal(joined, expected)
+            joined = panels[0].join(panels[1:], how='outer')
+            expected = pd.Panel.from_dict(data_dict, intersect=False)
+            tm.assert_panel_equal(joined, expected)
 
-        # edge cases
-        self.assertRaises(ValueError, panels[0].join, panels[1:],
-                          how='outer', lsuffix='foo', rsuffix='bar')
-        self.assertRaises(ValueError, panels[0].join, panels[1:],
-                          how='right')
+            # edge cases
+            self.assertRaises(ValueError, panels[0].join, panels[1:],
+                              how='outer', lsuffix='foo', rsuffix='bar')
+            self.assertRaises(ValueError, panels[0].join, panels[1:],
+                              how='right')
 
 
 def _check_join(left, right, result, join_col, how='left',
diff --git a/pandas/tests/tseries/test_resample.py b/pandas/tests/tseries/test_resample.py
index 57e5a1631..9c66cae29 100755
--- a/pandas/tests/tseries/test_resample.py
+++ b/pandas/tests/tseries/test_resample.py
@@ -1,5 +1,6 @@
 # pylint: disable=E1101
 
+from warnings import catch_warnings
 from datetime import datetime, timedelta
 from functools import partial
 
@@ -1479,44 +1480,47 @@ class TestDatetimeIndex(Base, tm.TestCase):
         rng = date_range('1/1/2000', '6/30/2000')
         n = len(rng)
 
-        panel = Panel(np.random.randn(3, n, 5),
-                      items=['one', 'two', 'three'],
-                      major_axis=rng,
-                      minor_axis=['a', 'b', 'c', 'd', 'e'])
+        with catch_warnings(record=True):
+            panel = Panel(np.random.randn(3, n, 5),
+                          items=['one', 'two', 'three'],
+                          major_axis=rng,
+                          minor_axis=['a', 'b', 'c', 'd', 'e'])
 
-        result = panel.resample('M', axis=1).mean()
+            result = panel.resample('M', axis=1).mean()
 
-        def p_apply(panel, f):
-            result = {}
-            for item in panel.items:
-                result[item] = f(panel[item])
-            return Panel(result, items=panel.items)
+            def p_apply(panel, f):
+                result = {}
+                for item in panel.items:
+                    result[item] = f(panel[item])
+                return Panel(result, items=panel.items)
 
-        expected = p_apply(panel, lambda x: x.resample('M').mean())
-        tm.assert_panel_equal(result, expected)
+            expected = p_apply(panel, lambda x: x.resample('M').mean())
+            tm.assert_panel_equal(result, expected)
 
-        panel2 = panel.swapaxes(1, 2)
-        result = panel2.resample('M', axis=2).mean()
-        expected = p_apply(panel2, lambda x: x.resample('M', axis=1).mean())
-        tm.assert_panel_equal(result, expected)
+            panel2 = panel.swapaxes(1, 2)
+            result = panel2.resample('M', axis=2).mean()
+            expected = p_apply(panel2,
+                               lambda x: x.resample('M', axis=1).mean())
+            tm.assert_panel_equal(result, expected)
 
     def test_resample_panel_numpy(self):
         rng = date_range('1/1/2000', '6/30/2000')
         n = len(rng)
 
-        panel = Panel(np.random.randn(3, n, 5),
-                      items=['one', 'two', 'three'],
-                      major_axis=rng,
-                      minor_axis=['a', 'b', 'c', 'd', 'e'])
+        with catch_warnings(record=True):
+            panel = Panel(np.random.randn(3, n, 5),
+                          items=['one', 'two', 'three'],
+                          major_axis=rng,
+                          minor_axis=['a', 'b', 'c', 'd', 'e'])
 
-        result = panel.resample('M', axis=1).apply(lambda x: x.mean(1))
-        expected = panel.resample('M', axis=1).mean()
-        tm.assert_panel_equal(result, expected)
+            result = panel.resample('M', axis=1).apply(lambda x: x.mean(1))
+            expected = panel.resample('M', axis=1).mean()
+            tm.assert_panel_equal(result, expected)
 
-        panel = panel.swapaxes(1, 2)
-        result = panel.resample('M', axis=2).apply(lambda x: x.mean(2))
-        expected = panel.resample('M', axis=2).mean()
-        tm.assert_panel_equal(result, expected)
+            panel = panel.swapaxes(1, 2)
+            result = panel.resample('M', axis=2).apply(lambda x: x.mean(2))
+            expected = panel.resample('M', axis=2).mean()
+            tm.assert_panel_equal(result, expected)
 
     def test_resample_anchored_ticks(self):
         # If a fixed delta (5 minute, 4 hour) evenly divides a day, we should
@@ -3037,20 +3041,22 @@ class TestTimeGrouper(tm.TestCase):
     def test_panel_aggregation(self):
         ind = pd.date_range('1/1/2000', periods=100)
         data = np.random.randn(2, len(ind), 4)
-        wp = pd.Panel(data, items=['Item1', 'Item2'], major_axis=ind,
-                      minor_axis=['A', 'B', 'C', 'D'])
 
-        tg = TimeGrouper('M', axis=1)
-        _, grouper, _ = tg._get_grouper(wp)
-        bingrouped = wp.groupby(grouper)
-        binagg = bingrouped.mean()
+        with catch_warnings(record=True):
+            wp = Panel(data, items=['Item1', 'Item2'], major_axis=ind,
+                       minor_axis=['A', 'B', 'C', 'D'])
 
-        def f(x):
-            assert (isinstance(x, Panel))
-            return x.mean(1)
+            tg = TimeGrouper('M', axis=1)
+            _, grouper, _ = tg._get_grouper(wp)
+            bingrouped = wp.groupby(grouper)
+            binagg = bingrouped.mean()
+
+            def f(x):
+                assert (isinstance(x, Panel))
+                return x.mean(1)
 
-        result = bingrouped.agg(f)
-        tm.assert_panel_equal(result, binagg)
+            result = bingrouped.agg(f)
+            tm.assert_panel_equal(result, binagg)
 
     def test_fails_on_no_datetime_index(self):
         index_names = ('Int64Index', 'Index', 'Float64Index', 'MultiIndex')
diff --git a/pandas/tests/types/test_generic.py b/pandas/tests/types/test_generic.py
index c7c8b0bec..7994aa77b 100644
--- a/pandas/tests/types/test_generic.py
+++ b/pandas/tests/types/test_generic.py
@@ -1,5 +1,6 @@
 # -*- coding: utf-8 -*-
 
+from warnings import catch_warnings
 import numpy as np
 import pandas as pd
 import pandas.util.testing as tm
@@ -33,7 +34,8 @@ class TestABCClasses(tm.TestCase):
         self.assertIsInstance(pd.Int64Index([1, 2, 3]), gt.ABCIndexClass)
         self.assertIsInstance(pd.Series([1, 2, 3]), gt.ABCSeries)
         self.assertIsInstance(self.df, gt.ABCDataFrame)
-        self.assertIsInstance(self.df.to_panel(), gt.ABCPanel)
+        with catch_warnings(record=True):
+            self.assertIsInstance(self.df.to_panel(), gt.ABCPanel)
         self.assertIsInstance(self.sparse_series, gt.ABCSparseSeries)
         self.assertIsInstance(self.sparse_array, gt.ABCSparseArray)
         self.assertIsInstance(self.categorical, gt.ABCCategorical)
diff --git a/pandas/tests/types/test_inference.py b/pandas/tests/types/test_inference.py
index de3a2ca35..ec61903d3 100644
--- a/pandas/tests/types/test_inference.py
+++ b/pandas/tests/types/test_inference.py
@@ -5,7 +5,7 @@ These the test the public routines exposed in types/common.py
 related to inference and not otherwise tested in types/test_common.py
 
 """
-
+from warnings import catch_warnings
 import collections
 import re
 from datetime import datetime, date, timedelta, time
@@ -930,8 +930,9 @@ class Testisscalar(tm.TestCase):
         self.assertFalse(is_scalar(Series([1])))
         self.assertFalse(is_scalar(DataFrame()))
         self.assertFalse(is_scalar(DataFrame([[1]])))
-        self.assertFalse(is_scalar(Panel()))
-        self.assertFalse(is_scalar(Panel([[[1]]])))
+        with catch_warnings(record=True):
+            self.assertFalse(is_scalar(Panel()))
+            self.assertFalse(is_scalar(Panel([[[1]]])))
         self.assertFalse(is_scalar(Index([])))
         self.assertFalse(is_scalar(Index([1])))
 
diff --git a/pandas/types/missing.py b/pandas/types/missing.py
index cc8b5edc2..ea49af988 100644
--- a/pandas/types/missing.py
+++ b/pandas/types/missing.py
@@ -302,7 +302,7 @@ def array_equivalent(left, right, strict_nan=False):
 
     # NaNs can occur in float and complex arrays.
     if is_float_dtype(left) or is_complex_dtype(left):
-        return ((left == right) | (np.isnan(left) & np.isnan(right))).all()
+        return ((left == right) | (isnull(left) & isnull(right))).all()
 
     # numpy will will not allow this type of datetimelike vs integer comparison
     elif is_datetimelike_v_numeric(left, right):

commit 30bb0f01286751156d755755dfb920fc981baef3
Author: RaisaDZ <34237447+RaisaDZ@users.noreply.github.com>
Date:   Wed Feb 19 23:19:48 2020 +0000

    add messages to tests (#31852)
    
    * add messages to tests
    
    * changes to test_boolean.py
    
    * split error messages
    
    * change to test_isin.py
    
    * changes to test_boolean.py and test_indexing.py
    
    * revert changes to test_diff.py
    
    * cleanups to the code
    
    * changes to test_boolean.py and test_replace.py
    
    * change error message in test_to_dict.py

diff --git a/pandas/tests/extension/decimal/test_decimal.py b/pandas/tests/extension/decimal/test_decimal.py
index a78e4bb34..f4ffcb8d0 100644
--- a/pandas/tests/extension/decimal/test_decimal.py
+++ b/pandas/tests/extension/decimal/test_decimal.py
@@ -148,7 +148,8 @@ class Reduce:
     def check_reduce(self, s, op_name, skipna):
 
         if op_name in ["median", "skew", "kurt"]:
-            with pytest.raises(NotImplementedError):
+            msg = r"decimal does not support the .* operation"
+            with pytest.raises(NotImplementedError, match=msg):
                 getattr(s, op_name)(skipna=skipna)
 
         else:
diff --git a/pandas/tests/extension/json/test_json.py b/pandas/tests/extension/json/test_json.py
index f7ca99be2..d086896fb 100644
--- a/pandas/tests/extension/json/test_json.py
+++ b/pandas/tests/extension/json/test_json.py
@@ -136,10 +136,11 @@ class TestInterface(BaseJSON, base.BaseInterfaceTests):
         self.assert_frame_equal(a.to_frame(), a.to_frame())
 
         b = pd.Series(data.take([0, 0, 1]))
-        with pytest.raises(AssertionError):
+        msg = r"ExtensionArray are different"
+        with pytest.raises(AssertionError, match=msg):
             self.assert_series_equal(a, b)
 
-        with pytest.raises(AssertionError):
+        with pytest.raises(AssertionError, match=msg):
             self.assert_frame_equal(a.to_frame(), b.to_frame())
 
 
diff --git a/pandas/tests/extension/test_boolean.py b/pandas/tests/extension/test_boolean.py
index 0c6b187ea..e2331b699 100644
--- a/pandas/tests/extension/test_boolean.py
+++ b/pandas/tests/extension/test_boolean.py
@@ -112,9 +112,9 @@ class TestArithmeticOps(base.BaseArithmeticOpsTests):
                 # subtraction for bools raises TypeError (but not yet in 1.13)
                 if _np_version_under1p14:
                     pytest.skip("__sub__ does not yet raise in numpy 1.13")
-                with pytest.raises(TypeError):
+                msg = r"numpy boolean subtract"
+                with pytest.raises(TypeError, match=msg):
                     op(s, other)
-
                 return
 
             result = op(s, other)
diff --git a/pandas/tests/extension/test_categorical.py b/pandas/tests/extension/test_categorical.py
index 336b23e54..69a97f5c9 100644
--- a/pandas/tests/extension/test_categorical.py
+++ b/pandas/tests/extension/test_categorical.py
@@ -278,7 +278,8 @@ class TestComparisonOps(base.BaseComparisonOpsTests):
             assert (result == expected).all()
 
         else:
-            with pytest.raises(TypeError):
+            msg = "Unordered Categoricals can only compare equality or not"
+            with pytest.raises(TypeError, match=msg):
                 op(data, other)
 
 
diff --git a/pandas/tests/frame/indexing/test_categorical.py b/pandas/tests/frame/indexing/test_categorical.py
index 3a472a8b5..f5b3f980c 100644
--- a/pandas/tests/frame/indexing/test_categorical.py
+++ b/pandas/tests/frame/indexing/test_categorical.py
@@ -115,7 +115,12 @@ class TestDataFrameIndexingCategorical:
         tm.assert_frame_equal(df, exp_single_cats_value)
 
         #   - assign a single value not in the current categories set
-        with pytest.raises(ValueError):
+        msg1 = (
+            "Cannot setitem on a Categorical with a new category, "
+            "set the categories first"
+        )
+        msg2 = "Cannot set a Categorical with another, without identical categories"
+        with pytest.raises(ValueError, match=msg1):
             df = orig.copy()
             df.iloc[2, 0] = "c"
 
@@ -125,7 +130,7 @@ class TestDataFrameIndexingCategorical:
         tm.assert_frame_equal(df, exp_single_row)
 
         #   - assign a complete row (mixed values) not in categories set
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg1):
             df = orig.copy()
             df.iloc[2, :] = ["c", 2]
 
@@ -134,7 +139,7 @@ class TestDataFrameIndexingCategorical:
         df.iloc[2:4, :] = [["b", 2], ["b", 2]]
         tm.assert_frame_equal(df, exp_multi_row)
 
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg1):
             df = orig.copy()
             df.iloc[2:4, :] = [["c", 2], ["c", 2]]
 
@@ -144,12 +149,12 @@ class TestDataFrameIndexingCategorical:
         df.iloc[2:4, 0] = Categorical(["b", "b"], categories=["a", "b"])
         tm.assert_frame_equal(df, exp_parts_cats_col)
 
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg2):
             # different categories -> not sure if this should fail or pass
             df = orig.copy()
             df.iloc[2:4, 0] = Categorical(list("bb"), categories=list("abc"))
 
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg2):
             # different values
             df = orig.copy()
             df.iloc[2:4, 0] = Categorical(list("cc"), categories=list("abc"))
@@ -160,7 +165,7 @@ class TestDataFrameIndexingCategorical:
         df.iloc[2:4, 0] = ["b", "b"]
         tm.assert_frame_equal(df, exp_parts_cats_col)
 
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg1):
             df.iloc[2:4, 0] = ["c", "c"]
 
         #  loc
@@ -175,7 +180,7 @@ class TestDataFrameIndexingCategorical:
         tm.assert_frame_equal(df, exp_single_cats_value)
 
         #   - assign a single value not in the current categories set
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg1):
             df = orig.copy()
             df.loc["j", "cats"] = "c"
 
@@ -185,7 +190,7 @@ class TestDataFrameIndexingCategorical:
         tm.assert_frame_equal(df, exp_single_row)
 
         #   - assign a complete row (mixed values) not in categories set
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg1):
             df = orig.copy()
             df.loc["j", :] = ["c", 2]
 
@@ -194,7 +199,7 @@ class TestDataFrameIndexingCategorical:
         df.loc["j":"k", :] = [["b", 2], ["b", 2]]
         tm.assert_frame_equal(df, exp_multi_row)
 
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg1):
             df = orig.copy()
             df.loc["j":"k", :] = [["c", 2], ["c", 2]]
 
@@ -204,14 +209,14 @@ class TestDataFrameIndexingCategorical:
         df.loc["j":"k", "cats"] = Categorical(["b", "b"], categories=["a", "b"])
         tm.assert_frame_equal(df, exp_parts_cats_col)
 
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg2):
             # different categories -> not sure if this should fail or pass
             df = orig.copy()
             df.loc["j":"k", "cats"] = Categorical(
                 ["b", "b"], categories=["a", "b", "c"]
             )
 
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg2):
             # different values
             df = orig.copy()
             df.loc["j":"k", "cats"] = Categorical(
@@ -224,7 +229,7 @@ class TestDataFrameIndexingCategorical:
         df.loc["j":"k", "cats"] = ["b", "b"]
         tm.assert_frame_equal(df, exp_parts_cats_col)
 
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg1):
             df.loc["j":"k", "cats"] = ["c", "c"]
 
         #  loc
@@ -239,7 +244,7 @@ class TestDataFrameIndexingCategorical:
         tm.assert_frame_equal(df, exp_single_cats_value)
 
         #   - assign a single value not in the current categories set
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg1):
             df = orig.copy()
             df.loc["j", df.columns[0]] = "c"
 
@@ -249,7 +254,7 @@ class TestDataFrameIndexingCategorical:
         tm.assert_frame_equal(df, exp_single_row)
 
         #   - assign a complete row (mixed values) not in categories set
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg1):
             df = orig.copy()
             df.loc["j", :] = ["c", 2]
 
@@ -258,7 +263,7 @@ class TestDataFrameIndexingCategorical:
         df.loc["j":"k", :] = [["b", 2], ["b", 2]]
         tm.assert_frame_equal(df, exp_multi_row)
 
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg1):
             df = orig.copy()
             df.loc["j":"k", :] = [["c", 2], ["c", 2]]
 
@@ -268,14 +273,14 @@ class TestDataFrameIndexingCategorical:
         df.loc["j":"k", df.columns[0]] = Categorical(["b", "b"], categories=["a", "b"])
         tm.assert_frame_equal(df, exp_parts_cats_col)
 
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg2):
             # different categories -> not sure if this should fail or pass
             df = orig.copy()
             df.loc["j":"k", df.columns[0]] = Categorical(
                 ["b", "b"], categories=["a", "b", "c"]
             )
 
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg2):
             # different values
             df = orig.copy()
             df.loc["j":"k", df.columns[0]] = Categorical(
@@ -288,7 +293,7 @@ class TestDataFrameIndexingCategorical:
         df.loc["j":"k", df.columns[0]] = ["b", "b"]
         tm.assert_frame_equal(df, exp_parts_cats_col)
 
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg1):
             df.loc["j":"k", df.columns[0]] = ["c", "c"]
 
         # iat
@@ -297,7 +302,7 @@ class TestDataFrameIndexingCategorical:
         tm.assert_frame_equal(df, exp_single_cats_value)
 
         #   - assign a single value not in the current categories set
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg1):
             df = orig.copy()
             df.iat[2, 0] = "c"
 
@@ -308,7 +313,7 @@ class TestDataFrameIndexingCategorical:
         tm.assert_frame_equal(df, exp_single_cats_value)
 
         #   - assign a single value not in the current categories set
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg1):
             df = orig.copy()
             df.at["j", "cats"] = "c"
 
@@ -332,7 +337,7 @@ class TestDataFrameIndexingCategorical:
         df.at["j", "cats"] = "b"
         tm.assert_frame_equal(df, exp_single_cats_value)
 
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg1):
             df = orig.copy()
             df.at["j", "cats"] = "c"
 
diff --git a/pandas/tests/frame/indexing/test_indexing.py b/pandas/tests/frame/indexing/test_indexing.py
index d892e3d63..fcf0a41e0 100644
--- a/pandas/tests/frame/indexing/test_indexing.py
+++ b/pandas/tests/frame/indexing/test_indexing.py
@@ -481,7 +481,8 @@ class TestDataFrameIndexing:
         # so raise/warn
         smaller = float_frame[:2]
 
-        with pytest.raises(com.SettingWithCopyError):
+        msg = r"\nA value is trying to be set on a copy of a slice from a DataFrame"
+        with pytest.raises(com.SettingWithCopyError, match=msg):
             smaller["col10"] = ["1", "2"]
 
         assert smaller["col10"].dtype == np.object_
@@ -865,7 +866,8 @@ class TestDataFrameIndexing:
         # setting it triggers setting with copy
         sliced = float_frame.iloc[:, -3:]
 
-        with pytest.raises(com.SettingWithCopyError):
+        msg = r"\nA value is trying to be set on a copy of a slice from a DataFrame"
+        with pytest.raises(com.SettingWithCopyError, match=msg):
             sliced["C"] = 4.0
 
         assert (float_frame["C"] == 4).all()
@@ -992,7 +994,7 @@ class TestDataFrameIndexing:
         with pytest.raises(IndexingError, match="Too many indexers"):
             ix[:, :, :]
 
-        with pytest.raises(IndexingError):
+        with pytest.raises(IndexingError, match="Too many indexers"):
             ix[:, :, :] = 1
 
     def test_getitem_setitem_boolean_misaligned(self, float_frame):
@@ -1071,10 +1073,10 @@ class TestDataFrameIndexing:
 
         cp = df.copy()
 
-        with pytest.raises(TypeError):
+        with pytest.raises(TypeError, match=msg):
             cp.iloc[1.0:5] = 0
 
-        with pytest.raises(TypeError):
+        with pytest.raises(TypeError, match=msg):
             result = cp.iloc[1.0:5] == 0  # noqa
 
         assert result.values.all()
@@ -1470,7 +1472,8 @@ class TestDataFrameIndexing:
 
         # verify slice is view
         # setting it makes it raise/warn
-        with pytest.raises(com.SettingWithCopyError):
+        msg = r"\nA value is trying to be set on a copy of a slice from a DataFrame"
+        with pytest.raises(com.SettingWithCopyError, match=msg):
             result[2] = 0.0
 
         exp_col = df[2].copy()
@@ -1501,7 +1504,8 @@ class TestDataFrameIndexing:
 
         # verify slice is view
         # and that we are setting a copy
-        with pytest.raises(com.SettingWithCopyError):
+        msg = r"\nA value is trying to be set on a copy of a slice from a DataFrame"
+        with pytest.raises(com.SettingWithCopyError, match=msg):
             result[8] = 0.0
 
         assert (df[8] == 0).all()
diff --git a/pandas/tests/frame/indexing/test_where.py b/pandas/tests/frame/indexing/test_where.py
index 507b2e9cd..eee754a47 100644
--- a/pandas/tests/frame/indexing/test_where.py
+++ b/pandas/tests/frame/indexing/test_where.py
@@ -50,7 +50,8 @@ class TestDataFrameIndexingWhere:
         # check getting
         df = where_frame
         if df is float_string_frame:
-            with pytest.raises(TypeError):
+            msg = "'>' not supported between instances of 'str' and 'int'"
+            with pytest.raises(TypeError, match=msg):
                 df > 0
             return
         cond = df > 0
@@ -114,7 +115,8 @@ class TestDataFrameIndexingWhere:
 
         df = where_frame
         if df is float_string_frame:
-            with pytest.raises(TypeError):
+            msg = "'>' not supported between instances of 'str' and 'int'"
+            with pytest.raises(TypeError, match=msg):
                 df > 0
             return
 
@@ -172,7 +174,8 @@ class TestDataFrameIndexingWhere:
 
         df = where_frame
         if df is float_string_frame:
-            with pytest.raises(TypeError):
+            msg = "'>' not supported between instances of 'str' and 'int'"
+            with pytest.raises(TypeError, match=msg):
                 df > 0
             return
 
@@ -358,7 +361,8 @@ class TestDataFrameIndexingWhere:
         )
 
         stamp = datetime(2013, 1, 3)
-        with pytest.raises(TypeError):
+        msg = "'>' not supported between instances of 'float' and 'datetime.datetime'"
+        with pytest.raises(TypeError, match=msg):
             df > stamp
 
         result = df[df.iloc[:, :-1] > stamp]
diff --git a/pandas/tests/frame/methods/test_explode.py b/pandas/tests/frame/methods/test_explode.py
index 76c87ed35..bad8349ec 100644
--- a/pandas/tests/frame/methods/test_explode.py
+++ b/pandas/tests/frame/methods/test_explode.py
@@ -9,11 +9,11 @@ def test_error():
     df = pd.DataFrame(
         {"A": pd.Series([[0, 1, 2], np.nan, [], (3, 4)], index=list("abcd")), "B": 1}
     )
-    with pytest.raises(ValueError):
+    with pytest.raises(ValueError, match="column must be a scalar"):
         df.explode(list("AA"))
 
     df.columns = list("AA")
-    with pytest.raises(ValueError):
+    with pytest.raises(ValueError, match="columns must be unique"):
         df.explode("A")
 
 
diff --git a/pandas/tests/frame/methods/test_isin.py b/pandas/tests/frame/methods/test_isin.py
index 0eb94afc9..630773802 100644
--- a/pandas/tests/frame/methods/test_isin.py
+++ b/pandas/tests/frame/methods/test_isin.py
@@ -60,10 +60,14 @@ class TestDataFrameIsIn:
             },
             index=["foo", "bar", "baz", "qux"],
         )
-        with pytest.raises(TypeError):
+        msg = (
+            r"only list-like or dict-like objects are allowed "
+            r"to be passed to DataFrame.isin\(\), you passed a 'str'"
+        )
+        with pytest.raises(TypeError, match=msg):
             df.isin("a")
 
-        with pytest.raises(TypeError):
+        with pytest.raises(TypeError, match=msg):
             df.isin("aaa")
 
     def test_isin_df(self):
@@ -92,7 +96,8 @@ class TestDataFrameIsIn:
         df1 = DataFrame({"A": [1, 2, 3, 4], "B": [2, np.nan, 4, 4]})
         # just cols duped
         df2 = DataFrame([[0, 2], [12, 4], [2, np.nan], [4, 5]], columns=["B", "B"])
-        with pytest.raises(ValueError):
+        msg = r"cannot compute isin with a duplicate axis\."
+        with pytest.raises(ValueError, match=msg):
             df1.isin(df2)
 
         # just index duped
@@ -101,12 +106,12 @@ class TestDataFrameIsIn:
             columns=["A", "B"],
             index=[0, 0, 1, 1],
         )
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg):
             df1.isin(df2)
 
         # cols and index:
         df2.columns = ["B", "B"]
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match=msg):
             df1.isin(df2)
 
     def test_isin_dupe_self(self):
diff --git a/pandas/tests/frame/methods/test_quantile.py b/pandas/tests/frame/methods/test_quantile.py
index 64461c08d..9c52e8ec5 100644
--- a/pandas/tests/frame/methods/test_quantile.py
+++ b/pandas/tests/frame/methods/test_quantile.py
@@ -75,7 +75,8 @@ class TestDataFrameQuantile:
         tm.assert_series_equal(result, expected)
 
         # must raise
-        with pytest.raises(TypeError):
+        msg = "'<' not supported between instances of 'Timestamp' and 'float'"
+        with pytest.raises(TypeError, match=msg):
             df.quantile(0.5, axis=1, numeric_only=False)
 
     def test_quantile_axis_parameter(self):
diff --git a/pandas/tests/frame/methods/test_round.py b/pandas/tests/frame/methods/test_round.py
index 0865e03ce..6dcdf49e9 100644
--- a/pandas/tests/frame/methods/test_round.py
+++ b/pandas/tests/frame/methods/test_round.py
@@ -34,7 +34,8 @@ class TestDataFrameRound:
 
         # Round with a list
         round_list = [1, 2]
-        with pytest.raises(TypeError):
+        msg = "decimals must be an integer, a dict-like or a Series"
+        with pytest.raises(TypeError, match=msg):
             df.round(round_list)
 
         # Round with a dictionary
@@ -57,34 +58,37 @@ class TestDataFrameRound:
 
         # float input to `decimals`
         non_int_round_dict = {"col1": 1, "col2": 0.5}
-        with pytest.raises(TypeError):
+        msg = "integer argument expected, got float"
+        with pytest.raises(TypeError, match=msg):
             df.round(non_int_round_dict)
 
         # String input
         non_int_round_dict = {"col1": 1, "col2": "foo"}
-        with pytest.raises(TypeError):
+        msg = r"an integer is required \(got type str\)"
+        with pytest.raises(TypeError, match=msg):
             df.round(non_int_round_dict)
 
         non_int_round_Series = Series(non_int_round_dict)
-        with pytest.raises(TypeError):
+        with pytest.raises(TypeError, match=msg):
             df.round(non_int_round_Series)
 
         # List input
         non_int_round_dict = {"col1": 1, "col2": [1, 2]}
-        with pytest.raises(TypeError):
+        msg = r"an integer is required \(got type list\)"
+        with pytest.raises(TypeError, match=msg):
             df.round(non_int_round_dict)
 
         non_int_round_Series = Series(non_int_round_dict)
-        with pytest.raises(TypeError):
+        with pytest.raises(TypeError, match=msg):
             df.round(non_int_round_Series)
 
         # Non integer Series inputs
         non_int_round_Series = Series(non_int_round_dict)
-        with pytest.raises(TypeError):
+        with pytest.raises(TypeError, match=msg):
             df.round(non_int_round_Series)
 
         non_int_round_Series = Series(non_int_round_dict)
-        with pytest.raises(TypeError):
+        with pytest.raises(TypeError, match=msg):
             df.round(non_int_round_Series)
 
         # Negative numbers
@@ -103,7 +107,8 @@ class TestDataFrameRound:
             {"col1": [1.123, 2.123, 3.123], "col2": [1.2, 2.2, 3.2]}
         )
 
-        with pytest.raises(TypeError):
+        msg = "integer argument expected, got float"
+        with pytest.raises(TypeError, match=msg):
             df.round(nan_round_Series)
 
         # Make sure this doesn't break existing Series.round
diff --git a/pandas/tests/frame/methods/test_sort_values.py b/pandas/tests/frame/methods/test_sort_values.py
index 96f4d6ed9..5a25d1c2c 100644
--- a/pandas/tests/frame/methods/test_sort_values.py
+++ b/pandas/tests/frame/methods/test_sort_values.py
@@ -458,7 +458,7 @@ class TestDataFrameSortValues:
             }
         )
 
-        with pytest.raises(ValueError):
+        with pytest.raises(ValueError, match="invalid na_position: bad_position"):
             df.sort_values(by="c", ascending=False, na_position="bad_position")
 
     @pytest.mark.parametrize("inplace", [True, False])
diff --git a/pandas/tests/frame/methods/test_to_dict.py b/pandas/tests/frame/methods/test_to_dict.py
index 40393721c..cd9bd1693 100644
--- a/pandas/tests/frame/methods/test_to_dict.py
+++ b/pandas/tests/frame/methods/test_to_dict.py
@@ -132,7 +132,13 @@ class TestDataFrameToDict:
     def test_to_dict_errors(self, mapping):
         # GH#16122
         df = DataFrame(np.random.randn(3, 3))
-        with pytest.raises(TypeError):
+        msg = "|".join(
+            [
+                "unsupported type: <class 'list'>",
+                r"to_dict\(\) only accepts initialized defaultdicts",
+            ]
+        )
+        with pytest.raises(TypeError, match=msg):
             df.to_dict(into=mapping)
 
     def test_to_dict_not_unique_warning(self):

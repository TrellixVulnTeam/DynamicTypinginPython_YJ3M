commit ce77b79b97d7e827f50ebd0b7ca292fc2d966cc7
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Fri Feb 23 04:35:07 2018 -0800

    Separate TimedeltaIndex mul/div tests (#19848)

diff --git a/pandas/tests/indexes/datetimes/test_datetime.py b/pandas/tests/indexes/datetimes/test_datetime.py
index 2cf336443..b685584a2 100644
--- a/pandas/tests/indexes/datetimes/test_datetime.py
+++ b/pandas/tests/indexes/datetimes/test_datetime.py
@@ -2,7 +2,7 @@
 import pytest
 
 import numpy as np
-from datetime import date, timedelta, time
+from datetime import date
 
 import dateutil
 import pandas as pd
@@ -18,112 +18,6 @@ randn = np.random.randn
 
 class TestDatetimeIndex(object):
 
-    def test_get_loc(self):
-        idx = pd.date_range('2000-01-01', periods=3)
-
-        for method in [None, 'pad', 'backfill', 'nearest']:
-            assert idx.get_loc(idx[1], method) == 1
-            assert idx.get_loc(idx[1].to_pydatetime(), method) == 1
-            assert idx.get_loc(str(idx[1]), method) == 1
-
-            if method is not None:
-                assert idx.get_loc(idx[1], method,
-                                   tolerance=pd.Timedelta('0 days')) == 1
-
-        assert idx.get_loc('2000-01-01', method='nearest') == 0
-        assert idx.get_loc('2000-01-01T12', method='nearest') == 1
-
-        assert idx.get_loc('2000-01-01T12', method='nearest',
-                           tolerance='1 day') == 1
-        assert idx.get_loc('2000-01-01T12', method='nearest',
-                           tolerance=pd.Timedelta('1D')) == 1
-        assert idx.get_loc('2000-01-01T12', method='nearest',
-                           tolerance=np.timedelta64(1, 'D')) == 1
-        assert idx.get_loc('2000-01-01T12', method='nearest',
-                           tolerance=timedelta(1)) == 1
-        with tm.assert_raises_regex(ValueError,
-                                    'unit abbreviation w/o a number'):
-            idx.get_loc('2000-01-01T12', method='nearest', tolerance='foo')
-        with pytest.raises(KeyError):
-            idx.get_loc('2000-01-01T03', method='nearest', tolerance='2 hours')
-        with pytest.raises(
-                ValueError,
-                match='tolerance size must match target index size'):
-            idx.get_loc('2000-01-01', method='nearest',
-                        tolerance=[pd.Timedelta('1day').to_timedelta64(),
-                                   pd.Timedelta('1day').to_timedelta64()])
-
-        assert idx.get_loc('2000', method='nearest') == slice(0, 3)
-        assert idx.get_loc('2000-01', method='nearest') == slice(0, 3)
-
-        assert idx.get_loc('1999', method='nearest') == 0
-        assert idx.get_loc('2001', method='nearest') == 2
-
-        with pytest.raises(KeyError):
-            idx.get_loc('1999', method='pad')
-        with pytest.raises(KeyError):
-            idx.get_loc('2001', method='backfill')
-
-        with pytest.raises(KeyError):
-            idx.get_loc('foobar')
-        with pytest.raises(TypeError):
-            idx.get_loc(slice(2))
-
-        idx = pd.to_datetime(['2000-01-01', '2000-01-04'])
-        assert idx.get_loc('2000-01-02', method='nearest') == 0
-        assert idx.get_loc('2000-01-03', method='nearest') == 1
-        assert idx.get_loc('2000-01', method='nearest') == slice(0, 2)
-
-        # time indexing
-        idx = pd.date_range('2000-01-01', periods=24, freq='H')
-        tm.assert_numpy_array_equal(idx.get_loc(time(12)),
-                                    np.array([12]), check_dtype=False)
-        tm.assert_numpy_array_equal(idx.get_loc(time(12, 30)),
-                                    np.array([]), check_dtype=False)
-        with pytest.raises(NotImplementedError):
-            idx.get_loc(time(12, 30), method='pad')
-
-    def test_get_indexer(self):
-        idx = pd.date_range('2000-01-01', periods=3)
-        exp = np.array([0, 1, 2], dtype=np.intp)
-        tm.assert_numpy_array_equal(idx.get_indexer(idx), exp)
-
-        target = idx[0] + pd.to_timedelta(['-1 hour', '12 hours',
-                                           '1 day 1 hour'])
-        tm.assert_numpy_array_equal(idx.get_indexer(target, 'pad'),
-                                    np.array([-1, 0, 1], dtype=np.intp))
-        tm.assert_numpy_array_equal(idx.get_indexer(target, 'backfill'),
-                                    np.array([0, 1, 2], dtype=np.intp))
-        tm.assert_numpy_array_equal(idx.get_indexer(target, 'nearest'),
-                                    np.array([0, 1, 1], dtype=np.intp))
-        tm.assert_numpy_array_equal(
-            idx.get_indexer(target, 'nearest',
-                            tolerance=pd.Timedelta('1 hour')),
-            np.array([0, -1, 1], dtype=np.intp))
-        tol_raw = [pd.Timedelta('1 hour'),
-                   pd.Timedelta('1 hour'),
-                   pd.Timedelta('1 hour').to_timedelta64(), ]
-        tm.assert_numpy_array_equal(
-            idx.get_indexer(target, 'nearest',
-                            tolerance=[np.timedelta64(x) for x in tol_raw]),
-            np.array([0, -1, 1], dtype=np.intp))
-        tol_bad = [pd.Timedelta('2 hour').to_timedelta64(),
-                   pd.Timedelta('1 hour').to_timedelta64(),
-                   'foo', ]
-        with pytest.raises(
-                ValueError, match='abbreviation w/o a number'):
-            idx.get_indexer(target, 'nearest', tolerance=tol_bad)
-        with pytest.raises(ValueError):
-            idx.get_indexer(idx[[0]], method='nearest', tolerance='foo')
-
-    def test_reasonable_keyerror(self):
-        # GH #1062
-        index = DatetimeIndex(['1/3/2000'])
-        try:
-            index.get_loc('1/1/2000')
-        except KeyError as e:
-            assert '2000' in str(e)
-
     def test_roundtrip_pickle_with_tz(self):
 
         # GH 8367
diff --git a/pandas/tests/indexes/datetimes/test_indexing.py b/pandas/tests/indexes/datetimes/test_indexing.py
index a9f1a5e60..af65a8618 100644
--- a/pandas/tests/indexes/datetimes/test_indexing.py
+++ b/pandas/tests/indexes/datetimes/test_indexing.py
@@ -1,4 +1,4 @@
-from datetime import datetime
+from datetime import datetime, timedelta, time
 import pytest
 
 import pytz
@@ -12,10 +12,93 @@ from pandas.tseries.offsets import CDay, BDay
 START, END = datetime(2009, 1, 1), datetime(2010, 1, 1)
 
 
-class TestDatetimeIndex(object):
+class TestGetItem(object):
+    def test_getitem(self):
+        idx1 = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
+        idx2 = pd.date_range('2011-01-01', '2011-01-31', freq='D',
+                             tz='Asia/Tokyo', name='idx')
 
-    def test_where_other(self):
+        for idx in [idx1, idx2]:
+            result = idx[0]
+            assert result == Timestamp('2011-01-01', tz=idx.tz)
+
+            result = idx[0:5]
+            expected = pd.date_range('2011-01-01', '2011-01-05', freq='D',
+                                     tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx[0:10:2]
+            expected = pd.date_range('2011-01-01', '2011-01-09', freq='2D',
+                                     tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx[-20:-5:3]
+            expected = pd.date_range('2011-01-12', '2011-01-24', freq='3D',
+                                     tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx[4::-1]
+            expected = DatetimeIndex(['2011-01-05', '2011-01-04', '2011-01-03',
+                                      '2011-01-02', '2011-01-01'],
+                                     freq='-1D', tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+    def test_dti_business_getitem(self):
+        rng = pd.bdate_range(START, END)
+        smaller = rng[:5]
+        exp = DatetimeIndex(rng.view(np.ndarray)[:5])
+        tm.assert_index_equal(smaller, exp)
+
+        assert smaller.offset == rng.offset
+
+        sliced = rng[::5]
+        assert sliced.offset == BDay() * 5
 
+        fancy_indexed = rng[[4, 3, 2, 1, 0]]
+        assert len(fancy_indexed) == 5
+        assert isinstance(fancy_indexed, DatetimeIndex)
+        assert fancy_indexed.freq is None
+
+        # 32-bit vs. 64-bit platforms
+        assert rng[4] == rng[np.int_(4)]
+
+    def test_dti_business_getitem_matplotlib_hackaround(self):
+        rng = pd.bdate_range(START, END)
+        values = rng[:, None]
+        expected = rng.values[:, None]
+        tm.assert_numpy_array_equal(values, expected)
+
+    def test_dti_custom_getitem(self):
+        rng = pd.bdate_range(START, END, freq='C')
+        smaller = rng[:5]
+        exp = DatetimeIndex(rng.view(np.ndarray)[:5])
+        tm.assert_index_equal(smaller, exp)
+        assert smaller.offset == rng.offset
+
+        sliced = rng[::5]
+        assert sliced.offset == CDay() * 5
+
+        fancy_indexed = rng[[4, 3, 2, 1, 0]]
+        assert len(fancy_indexed) == 5
+        assert isinstance(fancy_indexed, DatetimeIndex)
+        assert fancy_indexed.freq is None
+
+        # 32-bit vs. 64-bit platforms
+        assert rng[4] == rng[np.int_(4)]
+
+    def test_dti_custom_getitem_matplotlib_hackaround(self):
+        rng = pd.bdate_range(START, END, freq='C')
+        values = rng[:, None]
+        expected = rng.values[:, None]
+        tm.assert_numpy_array_equal(values, expected)
+
+
+class TestWhere(object):
+    def test_where_other(self):
         # other is ndarray or Index
         i = pd.date_range('20130101', periods=3, tz='US/Eastern')
 
@@ -46,6 +129,152 @@ class TestDatetimeIndex(object):
         expected = i2
         tm.assert_index_equal(result, expected)
 
+
+class TestTake(object):
+    def test_take(self):
+        # GH#10295
+        idx1 = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
+        idx2 = pd.date_range('2011-01-01', '2011-01-31', freq='D',
+                             tz='Asia/Tokyo', name='idx')
+
+        for idx in [idx1, idx2]:
+            result = idx.take([0])
+            assert result == Timestamp('2011-01-01', tz=idx.tz)
+
+            result = idx.take([0, 1, 2])
+            expected = pd.date_range('2011-01-01', '2011-01-03', freq='D',
+                                     tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx.take([0, 2, 4])
+            expected = pd.date_range('2011-01-01', '2011-01-05', freq='2D',
+                                     tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx.take([7, 4, 1])
+            expected = pd.date_range('2011-01-08', '2011-01-02', freq='-3D',
+                                     tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx.take([3, 2, 5])
+            expected = DatetimeIndex(['2011-01-04', '2011-01-03',
+                                      '2011-01-06'],
+                                     freq=None, tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq is None
+
+            result = idx.take([-3, 2, 5])
+            expected = DatetimeIndex(['2011-01-29', '2011-01-03',
+                                      '2011-01-06'],
+                                     freq=None, tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq is None
+
+    def test_take_invalid_kwargs(self):
+        idx = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
+        indices = [1, 6, 5, 9, 10, 13, 15, 3]
+
+        msg = r"take\(\) got an unexpected keyword argument 'foo'"
+        tm.assert_raises_regex(TypeError, msg, idx.take,
+                               indices, foo=2)
+
+        msg = "the 'out' parameter is not supported"
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, out=indices)
+
+        msg = "the 'mode' parameter is not supported"
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, mode='clip')
+
+    # TODO: This method came from test_datetime; de-dup with version above
+    @pytest.mark.parametrize('tz', [None, 'US/Eastern', 'Asia/Tokyo'])
+    def test_take2(self, tz):
+        dates = [datetime(2010, 1, 1, 14), datetime(2010, 1, 1, 15),
+                 datetime(2010, 1, 1, 17), datetime(2010, 1, 1, 21)]
+
+        idx = DatetimeIndex(start='2010-01-01 09:00',
+                            end='2010-02-01 09:00', freq='H', tz=tz,
+                            name='idx')
+        expected = DatetimeIndex(dates, freq=None, name='idx', tz=tz)
+
+        taken1 = idx.take([5, 6, 8, 12])
+        taken2 = idx[[5, 6, 8, 12]]
+
+        for taken in [taken1, taken2]:
+            tm.assert_index_equal(taken, expected)
+            assert isinstance(taken, DatetimeIndex)
+            assert taken.freq is None
+            assert taken.tz == expected.tz
+            assert taken.name == expected.name
+
+    def test_take_fill_value(self):
+        # GH#12631
+        idx = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
+                               name='xxx')
+        result = idx.take(np.array([1, 0, -1]))
+        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
+                                    name='xxx')
+        tm.assert_index_equal(result, expected)
+
+        # fill_value
+        result = idx.take(np.array([1, 0, -1]), fill_value=True)
+        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', 'NaT'],
+                                    name='xxx')
+        tm.assert_index_equal(result, expected)
+
+        # allow_fill=False
+        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
+                          fill_value=True)
+        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
+                                    name='xxx')
+        tm.assert_index_equal(result, expected)
+
+        msg = ('When allow_fill=True and fill_value is not None, '
+               'all indices must be >= -1')
+        with tm.assert_raises_regex(ValueError, msg):
+            idx.take(np.array([1, 0, -2]), fill_value=True)
+        with tm.assert_raises_regex(ValueError, msg):
+            idx.take(np.array([1, 0, -5]), fill_value=True)
+
+        with pytest.raises(IndexError):
+            idx.take(np.array([1, -5]))
+
+    def test_take_fill_value_with_timezone(self):
+        idx = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
+                               name='xxx', tz='US/Eastern')
+        result = idx.take(np.array([1, 0, -1]))
+        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
+                                    name='xxx', tz='US/Eastern')
+        tm.assert_index_equal(result, expected)
+
+        # fill_value
+        result = idx.take(np.array([1, 0, -1]), fill_value=True)
+        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', 'NaT'],
+                                    name='xxx', tz='US/Eastern')
+        tm.assert_index_equal(result, expected)
+
+        # allow_fill=False
+        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
+                          fill_value=True)
+        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
+                                    name='xxx', tz='US/Eastern')
+        tm.assert_index_equal(result, expected)
+
+        msg = ('When allow_fill=True and fill_value is not None, '
+               'all indices must be >= -1')
+        with tm.assert_raises_regex(ValueError, msg):
+            idx.take(np.array([1, 0, -2]), fill_value=True)
+        with tm.assert_raises_regex(ValueError, msg):
+            idx.take(np.array([1, 0, -5]), fill_value=True)
+
+        with pytest.raises(IndexError):
+            idx.take(np.array([1, -5]))
+
+
+class TestDatetimeIndex(object):
     @pytest.mark.parametrize('null', [None, np.nan, pd.NaT])
     @pytest.mark.parametrize('tz', [None, 'UTC', 'US/Eastern'])
     def test_insert_nat(self, tz, null):
@@ -253,233 +482,108 @@ class TestDatetimeIndex(object):
             assert result.freq == expected.freq
             assert result.tz == expected.tz
 
-    def test_getitem(self):
-        idx1 = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
-        idx2 = pd.date_range('2011-01-01', '2011-01-31', freq='D',
-                             tz='Asia/Tokyo', name='idx')
-
-        for idx in [idx1, idx2]:
-            result = idx[0]
-            assert result == Timestamp('2011-01-01', tz=idx.tz)
-
-            result = idx[0:5]
-            expected = pd.date_range('2011-01-01', '2011-01-05', freq='D',
-                                     tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx[0:10:2]
-            expected = pd.date_range('2011-01-01', '2011-01-09', freq='2D',
-                                     tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx[-20:-5:3]
-            expected = pd.date_range('2011-01-12', '2011-01-24', freq='3D',
-                                     tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx[4::-1]
-            expected = DatetimeIndex(['2011-01-05', '2011-01-04', '2011-01-03',
-                                      '2011-01-02', '2011-01-01'],
-                                     freq='-1D', tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-    def test_take(self):
-        # GH 10295
-        idx1 = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
-        idx2 = pd.date_range('2011-01-01', '2011-01-31', freq='D',
-                             tz='Asia/Tokyo', name='idx')
-
-        for idx in [idx1, idx2]:
-            result = idx.take([0])
-            assert result == Timestamp('2011-01-01', tz=idx.tz)
-
-            result = idx.take([0, 1, 2])
-            expected = pd.date_range('2011-01-01', '2011-01-03', freq='D',
-                                     tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx.take([0, 2, 4])
-            expected = pd.date_range('2011-01-01', '2011-01-05', freq='2D',
-                                     tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx.take([7, 4, 1])
-            expected = pd.date_range('2011-01-08', '2011-01-02', freq='-3D',
-                                     tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx.take([3, 2, 5])
-            expected = DatetimeIndex(['2011-01-04', '2011-01-03',
-                                      '2011-01-06'],
-                                     freq=None, tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq is None
-
-            result = idx.take([-3, 2, 5])
-            expected = DatetimeIndex(['2011-01-29', '2011-01-03',
-                                      '2011-01-06'],
-                                     freq=None, tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq is None
-
-    def test_take_invalid_kwargs(self):
-        idx = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
-        indices = [1, 6, 5, 9, 10, 13, 15, 3]
-
-        msg = r"take\(\) got an unexpected keyword argument 'foo'"
-        tm.assert_raises_regex(TypeError, msg, idx.take,
-                               indices, foo=2)
-
-        msg = "the 'out' parameter is not supported"
-        tm.assert_raises_regex(ValueError, msg, idx.take,
-                               indices, out=indices)
-
-        msg = "the 'mode' parameter is not supported"
-        tm.assert_raises_regex(ValueError, msg, idx.take,
-                               indices, mode='clip')
-
-    # TODO: This method came from test_datetime; de-dup with version above
-    @pytest.mark.parametrize('tz', [None, 'US/Eastern', 'Asia/Tokyo'])
-    def test_take2(self, tz):
-        dates = [datetime(2010, 1, 1, 14), datetime(2010, 1, 1, 15),
-                 datetime(2010, 1, 1, 17), datetime(2010, 1, 1, 21)]
-
-        idx = DatetimeIndex(start='2010-01-01 09:00',
-                            end='2010-02-01 09:00', freq='H', tz=tz,
-                            name='idx')
-        expected = DatetimeIndex(dates, freq=None, name='idx', tz=tz)
-
-        taken1 = idx.take([5, 6, 8, 12])
-        taken2 = idx[[5, 6, 8, 12]]
-
-        for taken in [taken1, taken2]:
-            tm.assert_index_equal(taken, expected)
-            assert isinstance(taken, DatetimeIndex)
-            assert taken.freq is None
-            assert taken.tz == expected.tz
-            assert taken.name == expected.name
-
-    def test_take_fill_value(self):
-        # GH 12631
-        idx = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
-                               name='xxx')
-        result = idx.take(np.array([1, 0, -1]))
-        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
-                                    name='xxx')
-        tm.assert_index_equal(result, expected)
-
-        # fill_value
-        result = idx.take(np.array([1, 0, -1]), fill_value=True)
-        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', 'NaT'],
-                                    name='xxx')
-        tm.assert_index_equal(result, expected)
-
-        # allow_fill=False
-        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
-                          fill_value=True)
-        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
-                                    name='xxx')
-        tm.assert_index_equal(result, expected)
-
-        msg = ('When allow_fill=True and fill_value is not None, '
-               'all indices must be >= -1')
-        with tm.assert_raises_regex(ValueError, msg):
-            idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assert_raises_regex(ValueError, msg):
-            idx.take(np.array([1, 0, -5]), fill_value=True)
-
-        with pytest.raises(IndexError):
-            idx.take(np.array([1, -5]))
-
-    def test_take_fill_value_with_timezone(self):
-        idx = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
-                               name='xxx', tz='US/Eastern')
-        result = idx.take(np.array([1, 0, -1]))
-        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
-                                    name='xxx', tz='US/Eastern')
-        tm.assert_index_equal(result, expected)
-
-        # fill_value
-        result = idx.take(np.array([1, 0, -1]), fill_value=True)
-        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', 'NaT'],
-                                    name='xxx', tz='US/Eastern')
-        tm.assert_index_equal(result, expected)
-
-        # allow_fill=False
-        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
-                          fill_value=True)
-        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
-                                    name='xxx', tz='US/Eastern')
-        tm.assert_index_equal(result, expected)
-
-        msg = ('When allow_fill=True and fill_value is not None, '
-               'all indices must be >= -1')
-        with tm.assert_raises_regex(ValueError, msg):
-            idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assert_raises_regex(ValueError, msg):
-            idx.take(np.array([1, 0, -5]), fill_value=True)
-
-        with pytest.raises(IndexError):
-            idx.take(np.array([1, -5]))
-
-
-class TestBusinessDatetimeIndexIndexing(object):
-    def setup_method(self, method):
-        self.rng = pd.bdate_range(START, END)
-
-    def test_getitem(self):
-        smaller = self.rng[:5]
-        exp = DatetimeIndex(self.rng.view(np.ndarray)[:5])
-        tm.assert_index_equal(smaller, exp)
-
-        assert smaller.offset == self.rng.offset
-
-        sliced = self.rng[::5]
-        assert sliced.offset == BDay() * 5
-
-        fancy_indexed = self.rng[[4, 3, 2, 1, 0]]
-        assert len(fancy_indexed) == 5
-        assert isinstance(fancy_indexed, DatetimeIndex)
-        assert fancy_indexed.freq is None
-
-        # 32-bit vs. 64-bit platforms
-        assert self.rng[4] == self.rng[np.int_(4)]
-
-    def test_getitem_matplotlib_hackaround(self):
-        values = self.rng[:, None]
-        expected = self.rng.values[:, None]
-        tm.assert_numpy_array_equal(values, expected)
-
-
-class TestCustomDatetimeIndexIndexing(object):
-    def setup_method(self, method):
-        self.rng = pd.bdate_range(START, END, freq='C')
-
-    def test_getitem(self):
-        smaller = self.rng[:5]
-        exp = DatetimeIndex(self.rng.view(np.ndarray)[:5])
-        tm.assert_index_equal(smaller, exp)
-        assert smaller.offset == self.rng.offset
-
-        sliced = self.rng[::5]
-        assert sliced.offset == CDay() * 5
-
-        fancy_indexed = self.rng[[4, 3, 2, 1, 0]]
-        assert len(fancy_indexed) == 5
-        assert isinstance(fancy_indexed, DatetimeIndex)
-        assert fancy_indexed.freq is None
-
-        # 32-bit vs. 64-bit platforms
-        assert self.rng[4] == self.rng[np.int_(4)]
-
-    def test_getitem_matplotlib_hackaround(self):
-        values = self.rng[:, None]
-        expected = self.rng.values[:, None]
-        tm.assert_numpy_array_equal(values, expected)
+    def test_get_loc(self):
+        idx = pd.date_range('2000-01-01', periods=3)
+
+        for method in [None, 'pad', 'backfill', 'nearest']:
+            assert idx.get_loc(idx[1], method) == 1
+            assert idx.get_loc(idx[1].to_pydatetime(), method) == 1
+            assert idx.get_loc(str(idx[1]), method) == 1
+
+            if method is not None:
+                assert idx.get_loc(idx[1], method,
+                                   tolerance=pd.Timedelta('0 days')) == 1
+
+        assert idx.get_loc('2000-01-01', method='nearest') == 0
+        assert idx.get_loc('2000-01-01T12', method='nearest') == 1
+
+        assert idx.get_loc('2000-01-01T12', method='nearest',
+                           tolerance='1 day') == 1
+        assert idx.get_loc('2000-01-01T12', method='nearest',
+                           tolerance=pd.Timedelta('1D')) == 1
+        assert idx.get_loc('2000-01-01T12', method='nearest',
+                           tolerance=np.timedelta64(1, 'D')) == 1
+        assert idx.get_loc('2000-01-01T12', method='nearest',
+                           tolerance=timedelta(1)) == 1
+        with tm.assert_raises_regex(ValueError,
+                                    'unit abbreviation w/o a number'):
+            idx.get_loc('2000-01-01T12', method='nearest', tolerance='foo')
+        with pytest.raises(KeyError):
+            idx.get_loc('2000-01-01T03', method='nearest', tolerance='2 hours')
+        with pytest.raises(
+                ValueError,
+                match='tolerance size must match target index size'):
+            idx.get_loc('2000-01-01', method='nearest',
+                        tolerance=[pd.Timedelta('1day').to_timedelta64(),
+                                   pd.Timedelta('1day').to_timedelta64()])
+
+        assert idx.get_loc('2000', method='nearest') == slice(0, 3)
+        assert idx.get_loc('2000-01', method='nearest') == slice(0, 3)
+
+        assert idx.get_loc('1999', method='nearest') == 0
+        assert idx.get_loc('2001', method='nearest') == 2
+
+        with pytest.raises(KeyError):
+            idx.get_loc('1999', method='pad')
+        with pytest.raises(KeyError):
+            idx.get_loc('2001', method='backfill')
+
+        with pytest.raises(KeyError):
+            idx.get_loc('foobar')
+        with pytest.raises(TypeError):
+            idx.get_loc(slice(2))
+
+        idx = pd.to_datetime(['2000-01-01', '2000-01-04'])
+        assert idx.get_loc('2000-01-02', method='nearest') == 0
+        assert idx.get_loc('2000-01-03', method='nearest') == 1
+        assert idx.get_loc('2000-01', method='nearest') == slice(0, 2)
+
+        # time indexing
+        idx = pd.date_range('2000-01-01', periods=24, freq='H')
+        tm.assert_numpy_array_equal(idx.get_loc(time(12)),
+                                    np.array([12]), check_dtype=False)
+        tm.assert_numpy_array_equal(idx.get_loc(time(12, 30)),
+                                    np.array([]), check_dtype=False)
+        with pytest.raises(NotImplementedError):
+            idx.get_loc(time(12, 30), method='pad')
+
+    def test_get_indexer(self):
+        idx = pd.date_range('2000-01-01', periods=3)
+        exp = np.array([0, 1, 2], dtype=np.intp)
+        tm.assert_numpy_array_equal(idx.get_indexer(idx), exp)
+
+        target = idx[0] + pd.to_timedelta(['-1 hour', '12 hours',
+                                           '1 day 1 hour'])
+        tm.assert_numpy_array_equal(idx.get_indexer(target, 'pad'),
+                                    np.array([-1, 0, 1], dtype=np.intp))
+        tm.assert_numpy_array_equal(idx.get_indexer(target, 'backfill'),
+                                    np.array([0, 1, 2], dtype=np.intp))
+        tm.assert_numpy_array_equal(idx.get_indexer(target, 'nearest'),
+                                    np.array([0, 1, 1], dtype=np.intp))
+        tm.assert_numpy_array_equal(
+            idx.get_indexer(target, 'nearest',
+                            tolerance=pd.Timedelta('1 hour')),
+            np.array([0, -1, 1], dtype=np.intp))
+        tol_raw = [pd.Timedelta('1 hour'),
+                   pd.Timedelta('1 hour'),
+                   pd.Timedelta('1 hour').to_timedelta64(), ]
+        tm.assert_numpy_array_equal(
+            idx.get_indexer(target, 'nearest',
+                            tolerance=[np.timedelta64(x) for x in tol_raw]),
+            np.array([0, -1, 1], dtype=np.intp))
+        tol_bad = [pd.Timedelta('2 hour').to_timedelta64(),
+                   pd.Timedelta('1 hour').to_timedelta64(),
+                   'foo', ]
+        with pytest.raises(
+                ValueError, match='abbreviation w/o a number'):
+            idx.get_indexer(target, 'nearest', tolerance=tol_bad)
+        with pytest.raises(ValueError):
+            idx.get_indexer(idx[[0]], method='nearest', tolerance='foo')
+
+    def test_reasonable_keyerror(self):
+        # GH#1062
+        index = DatetimeIndex(['1/3/2000'])
+        try:
+            index.get_loc('1/1/2000')
+        except KeyError as e:
+            assert '2000' in str(e)
diff --git a/pandas/tests/indexes/period/test_indexing.py b/pandas/tests/indexes/period/test_indexing.py
index b91393419..6b8e2203e 100644
--- a/pandas/tests/indexes/period/test_indexing.py
+++ b/pandas/tests/indexes/period/test_indexing.py
@@ -6,9 +6,9 @@ import numpy as np
 import pandas as pd
 from pandas.util import testing as tm
 from pandas.compat import lrange
-from pandas._libs import tslib, tslibs
+from pandas._libs import tslibs
 from pandas import (PeriodIndex, Series, DatetimeIndex,
-                    period_range, Period)
+                    period_range, Period, notna)
 from pandas._libs.tslibs import period as libperiod
 
 
@@ -119,7 +119,7 @@ class TestGetItem(object):
     def test_getitem_nat(self):
         idx = pd.PeriodIndex(['2011-01', 'NaT', '2011-02'], freq='M')
         assert idx[0] == pd.Period('2011-01', freq='M')
-        assert idx[1] is tslib.NaT
+        assert idx[1] is pd.NaT
 
         s = pd.Series([0, 1, 2], index=idx)
         assert s[pd.NaT] == 1
@@ -127,7 +127,7 @@ class TestGetItem(object):
         s = pd.Series(idx, index=idx)
         assert (s[pd.Period('2011-01', freq='M')] ==
                 pd.Period('2011-01', freq='M'))
-        assert s[pd.NaT] is tslib.NaT
+        assert s[pd.NaT] is pd.NaT
 
     def test_getitem_list_periods(self):
         # GH 7710
@@ -190,31 +190,43 @@ class TestGetItem(object):
                     s[v]
 
 
-class TestIndexing(object):
+class TestWhere(object):
+    @pytest.mark.parametrize('klass', [list, tuple, np.array, Series])
+    def test_where(self, klass):
+        i = period_range('20130101', periods=5, freq='D')
+        cond = [True] * len(i)
+        expected = i
+        result = i.where(klass(cond))
+        tm.assert_index_equal(result, expected)
 
-    def test_get_loc_msg(self):
-        idx = period_range('2000-1-1', freq='A', periods=10)
-        bad_period = Period('2012', 'A')
-        pytest.raises(KeyError, idx.get_loc, bad_period)
+        cond = [False] + [True] * (len(i) - 1)
+        expected = PeriodIndex([pd.NaT] + i[1:].tolist(), freq='D')
+        result = i.where(klass(cond))
+        tm.assert_index_equal(result, expected)
 
-        try:
-            idx.get_loc(bad_period)
-        except KeyError as inst:
-            assert inst.args[0] == bad_period
+    def test_where_other(self):
+        i = period_range('20130101', periods=5, freq='D')
+        for arr in [np.nan, pd.NaT]:
+            result = i.where(notna(i), other=np.nan)
+            expected = i
+            tm.assert_index_equal(result, expected)
 
-    def test_get_loc_nat(self):
-        didx = DatetimeIndex(['2011-01-01', 'NaT', '2011-01-03'])
-        pidx = PeriodIndex(['2011-01-01', 'NaT', '2011-01-03'], freq='M')
+        i2 = i.copy()
+        i2 = pd.PeriodIndex([pd.NaT, pd.NaT] + i[2:].tolist(),
+                            freq='D')
+        result = i.where(notna(i2), i2)
+        tm.assert_index_equal(result, i2)
 
-        # check DatetimeIndex compat
-        for idx in [didx, pidx]:
-            assert idx.get_loc(pd.NaT) == 1
-            assert idx.get_loc(None) == 1
-            assert idx.get_loc(float('nan')) == 1
-            assert idx.get_loc(np.nan) == 1
+        i2 = i.copy()
+        i2 = pd.PeriodIndex([pd.NaT, pd.NaT] + i[2:].tolist(),
+                            freq='D')
+        result = i.where(notna(i2), i2.values)
+        tm.assert_index_equal(result, i2)
 
+
+class TestTake(object):
     def test_take(self):
-        # GH 10295
+        # GH#10295
         idx1 = pd.period_range('2011-01-01', '2011-01-31', freq='D',
                                name='idx')
 
@@ -278,7 +290,7 @@ class TestIndexing(object):
             assert taken.name == expected.name
 
     def test_take_fill_value(self):
-        # GH 12631
+        # GH#12631
         idx = pd.PeriodIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
                              name='xxx', freq='D')
         result = idx.take(np.array([1, 0, -1]))
@@ -309,6 +321,30 @@ class TestIndexing(object):
         with pytest.raises(IndexError):
             idx.take(np.array([1, -5]))
 
+
+class TestIndexing(object):
+
+    def test_get_loc_msg(self):
+        idx = period_range('2000-1-1', freq='A', periods=10)
+        bad_period = Period('2012', 'A')
+        pytest.raises(KeyError, idx.get_loc, bad_period)
+
+        try:
+            idx.get_loc(bad_period)
+        except KeyError as inst:
+            assert inst.args[0] == bad_period
+
+    def test_get_loc_nat(self):
+        didx = DatetimeIndex(['2011-01-01', 'NaT', '2011-01-03'])
+        pidx = PeriodIndex(['2011-01-01', 'NaT', '2011-01-03'], freq='M')
+
+        # check DatetimeIndex compat
+        for idx in [didx, pidx]:
+            assert idx.get_loc(pd.NaT) == 1
+            assert idx.get_loc(None) == 1
+            assert idx.get_loc(float('nan')) == 1
+            assert idx.get_loc(np.nan) == 1
+
     def test_get_loc(self):
         # GH 17717
         p0 = pd.Period('2017-09-01')
diff --git a/pandas/tests/indexes/period/test_period.py b/pandas/tests/indexes/period/test_period.py
index dd437363c..4548d7fa1 100644
--- a/pandas/tests/indexes/period/test_period.py
+++ b/pandas/tests/indexes/period/test_period.py
@@ -5,7 +5,7 @@ import numpy as np
 import pandas as pd
 import pandas.util._test_decorators as td
 from pandas.util import testing as tm
-from pandas import (PeriodIndex, period_range, notna, DatetimeIndex, NaT,
+from pandas import (PeriodIndex, period_range, DatetimeIndex, NaT,
                     Index, Period, Series, DataFrame, date_range,
                     offsets)
 
@@ -33,38 +33,9 @@ class TestPeriodIndex(DatetimeLike):
         result = tm.round_trip_pickle(idx)
         tm.assert_index_equal(result, idx)
 
-    @pytest.mark.parametrize('klass', [list, tuple, np.array, Series])
-    def test_where(self, klass):
-        i = self.create_index()
-        cond = [True] * len(i)
-        expected = i
-        result = i.where(klass(cond))
-        tm.assert_index_equal(result, expected)
-
-        cond = [False] + [True] * (len(i) - 1)
-        expected = PeriodIndex([NaT] + i[1:].tolist(), freq='D')
-        result = i.where(klass(cond))
-        tm.assert_index_equal(result, expected)
-
-    def test_where_other(self):
-
-        i = self.create_index()
-        for arr in [np.nan, pd.NaT]:
-            result = i.where(notna(i), other=np.nan)
-            expected = i
-            tm.assert_index_equal(result, expected)
-
-        i2 = i.copy()
-        i2 = pd.PeriodIndex([pd.NaT, pd.NaT] + i[2:].tolist(),
-                            freq='D')
-        result = i.where(notna(i2), i2)
-        tm.assert_index_equal(result, i2)
-
-        i2 = i.copy()
-        i2 = pd.PeriodIndex([pd.NaT, pd.NaT] + i[2:].tolist(),
-                            freq='D')
-        result = i.where(notna(i2), i2.values)
-        tm.assert_index_equal(result, i2)
+    def test_where(self):
+        # This is handled in test_indexing
+        pass
 
     def test_repeat(self):
         # GH10183
diff --git a/pandas/tests/indexes/timedeltas/test_arithmetic.py b/pandas/tests/indexes/timedeltas/test_arithmetic.py
index 24341b341..282501860 100644
--- a/pandas/tests/indexes/timedeltas/test_arithmetic.py
+++ b/pandas/tests/indexes/timedeltas/test_arithmetic.py
@@ -123,8 +123,149 @@ class TestTimedeltaIndexComparisons(object):
             tm.assert_numpy_array_equal(result, expected)
 
 
+class TestTimedeltaIndexMultiplicationDivision(object):
+    # __mul__, __rmul__,
+    # __div__, __rdiv__, __floordiv__, __rfloordiv__,
+    # __mod__, __rmod__, __divmod__, __rdivmod__
+
+    # -------------------------------------------------------------
+    # Multiplication
+    # organized with scalar others first, then array-like
+
+    def test_tdi_mul_int(self):
+        idx = TimedeltaIndex(np.arange(5, dtype='int64'))
+        result = idx * 1
+        tm.assert_index_equal(result, idx)
+
+    def test_tdi_rmul_int(self):
+        idx = TimedeltaIndex(np.arange(5, dtype='int64'))
+        result = 1 * idx
+        tm.assert_index_equal(result, idx)
+
+    def test_tdi_mul_tdlike_scalar_raises(self, delta):
+        rng = timedelta_range('1 days', '10 days', name='foo')
+        with pytest.raises(TypeError):
+            rng * delta
+
+    def test_tdi_mul_int_array_zerodim(self):
+        rng5 = np.arange(5, dtype='int64')
+        idx = TimedeltaIndex(rng5)
+        expected = TimedeltaIndex(rng5 * 5)
+        result = idx * np.array(5, dtype='int64')
+        tm.assert_index_equal(result, expected)
+
+    def test_tdi_mul_int_array(self):
+        rng5 = np.arange(5, dtype='int64')
+        idx = TimedeltaIndex(rng5)
+        didx = TimedeltaIndex(rng5 ** 2)
+
+        result = idx * rng5
+        tm.assert_index_equal(result, didx)
+
+    def test_tdi_mul_dti_raises(self):
+        idx = TimedeltaIndex(np.arange(5, dtype='int64'))
+        with pytest.raises(TypeError):
+            idx * idx
+
+    def test_tdi_mul_too_short_raises(self):
+        idx = TimedeltaIndex(np.arange(5, dtype='int64'))
+        with pytest.raises(TypeError):
+            idx * TimedeltaIndex(np.arange(3))
+        with pytest.raises(ValueError):
+            idx * np.array([1, 2])
+
+    def test_tdi_mul_int_series(self):
+        idx = TimedeltaIndex(np.arange(5, dtype='int64'))
+        didx = TimedeltaIndex(np.arange(5, dtype='int64') ** 2)
+
+        result = idx * Series(np.arange(5, dtype='int64'))
+
+        tm.assert_series_equal(result, Series(didx))
+
+    def test_tdi_mul_float_series(self):
+        idx = TimedeltaIndex(np.arange(5, dtype='int64'))
+
+        rng5f = np.arange(5, dtype='float64')
+        result = idx * Series(rng5f + 0.1)
+        expected = Series(TimedeltaIndex(rng5f * (rng5f + 0.1)))
+        tm.assert_series_equal(result, expected)
+
+    @pytest.mark.parametrize('other', [np.arange(1, 11),
+                                       pd.Int64Index(range(1, 11)),
+                                       pd.UInt64Index(range(1, 11)),
+                                       pd.Float64Index(range(1, 11)),
+                                       pd.RangeIndex(1, 11)])
+    def test_tdi_rmul_arraylike(self, other):
+        tdi = TimedeltaIndex(['1 Day'] * 10)
+        expected = timedelta_range('1 days', '10 days')
+
+        result = other * tdi
+        tm.assert_index_equal(result, expected)
+        commute = tdi * other
+        tm.assert_index_equal(commute, expected)
+
+    # -------------------------------------------------------------
+    # TimedeltaIndex.__div__
+
+    def test_tdi_div_int(self):
+        idx = TimedeltaIndex(np.arange(5, dtype='int64'))
+        result = idx / 1
+        tm.assert_index_equal(result, idx)
+
+    def test_tdi_div_tdlike_scalar(self, delta):
+        rng = timedelta_range('1 days', '10 days', name='foo')
+        expected = Int64Index((np.arange(10) + 1) * 12, name='foo')
+
+        result = rng / delta
+        tm.assert_index_equal(result, expected, exact=False)
+
+    def test_tdi_div_tdlike_scalar_with_nat(self, delta):
+        rng = TimedeltaIndex(['1 days', pd.NaT, '2 days'], name='foo')
+        expected = Float64Index([12, np.nan, 24], name='foo')
+        result = rng / delta
+        tm.assert_index_equal(result, expected)
+
+    def test_tdi_div_nat_raises(self):
+        # don't allow division by NaT (make could in the future)
+        rng = timedelta_range('1 days', '10 days', name='foo')
+        with pytest.raises(TypeError):
+            rng / pd.NaT
+
+    # -------------------------------------------------------------
+    # TimedeltaIndex.__floordiv__
+
+    def test_tdi_floordiv_int(self):
+        idx = TimedeltaIndex(np.arange(5, dtype='int64'))
+        result = idx // 1
+        tm.assert_index_equal(result, idx)
+
+    def test_tdi_floordiv_tdlike_scalar(self, delta):
+        tdi = timedelta_range('1 days', '10 days', name='foo')
+        expected = Int64Index((np.arange(10) + 1) * 12, name='foo')
+
+        result = tdi // delta
+        tm.assert_index_equal(result, expected, exact=False)
+
+    @pytest.mark.parametrize('scalar_td', [
+        timedelta(minutes=10, seconds=7),
+        Timedelta('10m7s'),
+        Timedelta('10m7s').to_timedelta64()])
+    def test_tdi_floordiv_timedelta_scalar(self, scalar_td):
+        # GH#19125
+        tdi = TimedeltaIndex(['00:05:03', '00:05:03', pd.NaT], freq=None)
+        expected = pd.Index([2.0, 2.0, np.nan])
+
+        res = tdi.__rfloordiv__(scalar_td)
+        tm.assert_index_equal(res, expected)
+
+        expected = pd.Index([0.0, 0.0, np.nan])
+
+        res = tdi // (scalar_td)
+        tm.assert_index_equal(res, expected)
+
+
 class TestTimedeltaIndexArithmetic(object):
-    _holder = TimedeltaIndex
+    # Addition and Subtraction Operations
 
     # -------------------------------------------------------------
     # Invalid Operations
@@ -138,6 +279,20 @@ class TestTimedeltaIndexArithmetic(object):
         with pytest.raises(TypeError):
             'a' + tdi
 
+    @pytest.mark.parametrize('freq', [None, 'H'])
+    def test_tdi_sub_period(self, freq):
+        # GH#13078
+        # not supported, check TypeError
+        p = pd.Period('2011-01-01', freq='D')
+
+        idx = pd.TimedeltaIndex(['1 hours', '2 hours'], freq=freq)
+
+        with pytest.raises(TypeError):
+            idx - p
+
+        with pytest.raises(TypeError):
+            p - idx
+
     # -------------------------------------------------------------
     # TimedeltaIndex.shift is used by __add__/__sub__
 
@@ -310,69 +465,6 @@ class TestTimedeltaIndexArithmetic(object):
             with tm.assert_produces_warning(PerformanceWarning):
                 anchored - tdi
 
-    def test_mul_int(self):
-        idx = self._holder(np.arange(5, dtype='int64'))
-        result = idx * 1
-        tm.assert_index_equal(result, idx)
-
-    def test_rmul_int(self):
-        idx = self._holder(np.arange(5, dtype='int64'))
-        result = 1 * idx
-        tm.assert_index_equal(result, idx)
-
-    def test_div_int(self):
-        idx = self._holder(np.arange(5, dtype='int64'))
-        result = idx / 1
-        tm.assert_index_equal(result, idx)
-
-    def test_floordiv_int(self):
-        idx = self._holder(np.arange(5, dtype='int64'))
-        result = idx // 1
-        tm.assert_index_equal(result, idx)
-
-    def test_mul_int_array_zerodim(self):
-        rng5 = np.arange(5, dtype='int64')
-        idx = self._holder(rng5)
-        expected = self._holder(rng5 * 5)
-        result = idx * np.array(5, dtype='int64')
-        tm.assert_index_equal(result, expected)
-
-    def test_mul_int_array(self):
-        rng5 = np.arange(5, dtype='int64')
-        idx = self._holder(rng5)
-        didx = self._holder(rng5 ** 2)
-
-        result = idx * rng5
-        tm.assert_index_equal(result, didx)
-
-    def test_mul_int_series(self):
-        idx = self._holder(np.arange(5, dtype='int64'))
-        didx = self._holder(np.arange(5, dtype='int64') ** 2)
-
-        result = idx * Series(np.arange(5, dtype='int64'))
-
-        tm.assert_series_equal(result, Series(didx))
-
-    def test_mul_float_series(self):
-        idx = self._holder(np.arange(5, dtype='int64'))
-
-        rng5f = np.arange(5, dtype='float64')
-        result = idx * Series(rng5f + 0.1)
-        expected = Series(self._holder(rng5f * (rng5f + 0.1)))
-        tm.assert_series_equal(result, expected)
-
-    def test_dti_mul_dti_raises(self):
-        idx = self._holder(np.arange(5, dtype='int64'))
-        with pytest.raises(TypeError):
-            idx * idx
-
-    def test_dti_mul_too_short_raises(self):
-        idx = self._holder(np.arange(5, dtype='int64'))
-        with pytest.raises(TypeError):
-            idx * self._holder(np.arange(3))
-        with pytest.raises(ValueError):
-            idx * np.array([1, 2])
-
     def test_ufunc_coercions(self):
         # normal ops are also tested in tseries/test_timedeltas.py
         idx = TimedeltaIndex(['2H', '4H', '6H', '8H', '10H'],
@@ -496,68 +588,6 @@ class TestTimedeltaIndexArithmetic(object):
 
     # -------------------------------------------------------------
 
-    @pytest.mark.parametrize('scalar_td', [
-        timedelta(minutes=10, seconds=7),
-        Timedelta('10m7s'),
-        Timedelta('10m7s').to_timedelta64()])
-    def test_tdi_floordiv_timedelta_scalar(self, scalar_td):
-        # GH#19125
-        tdi = TimedeltaIndex(['00:05:03', '00:05:03', pd.NaT], freq=None)
-        expected = pd.Index([2.0, 2.0, np.nan])
-
-        res = tdi.__rfloordiv__(scalar_td)
-        tm.assert_index_equal(res, expected)
-
-        expected = pd.Index([0.0, 0.0, np.nan])
-
-        res = tdi // (scalar_td)
-        tm.assert_index_equal(res, expected)
-
-    def test_tdi_floordiv_tdlike_scalar(self, delta):
-        tdi = timedelta_range('1 days', '10 days', name='foo')
-        expected = Int64Index((np.arange(10) + 1) * 12, name='foo')
-
-        result = tdi // delta
-        tm.assert_index_equal(result, expected, exact=False)
-
-    def test_tdi_mul_tdlike_scalar_raises(self, delta):
-        rng = timedelta_range('1 days', '10 days', name='foo')
-        with pytest.raises(TypeError):
-            rng * delta
-
-    def test_tdi_div_nat_raises(self):
-        # don't allow division by NaT (make could in the future)
-        rng = timedelta_range('1 days', '10 days', name='foo')
-        with pytest.raises(TypeError):
-            rng / pd.NaT
-
-    def test_tdi_div_tdlike_scalar(self, delta):
-        rng = timedelta_range('1 days', '10 days', name='foo')
-        expected = Int64Index((np.arange(10) + 1) * 12, name='foo')
-
-        result = rng / delta
-        tm.assert_index_equal(result, expected, exact=False)
-
-    def test_tdi_div_tdlike_scalar_with_nat(self, delta):
-        rng = TimedeltaIndex(['1 days', pd.NaT, '2 days'], name='foo')
-        expected = Float64Index([12, np.nan, 24], name='foo')
-        result = rng / delta
-        tm.assert_index_equal(result, expected)
-
-    @pytest.mark.parametrize('other', [np.arange(1, 11),
-                                       pd.Int64Index(range(1, 11)),
-                                       pd.UInt64Index(range(1, 11)),
-                                       pd.Float64Index(range(1, 11)),
-                                       pd.RangeIndex(1, 11)])
-    def test_tdi_rmul_arraylike(self, other):
-        tdi = TimedeltaIndex(['1 Day'] * 10)
-        expected = timedelta_range('1 days', '10 days')
-
-        result = other * tdi
-        tm.assert_index_equal(result, expected)
-        commute = tdi * other
-        tm.assert_index_equal(commute, expected)
-
     def test_subtraction_ops(self):
         # with datetimes/timedelta and tdi/dti
         tdi = TimedeltaIndex(['1 days', pd.NaT, '2 days'], name='foo')
@@ -685,20 +715,6 @@ class TestTimedeltaIndexArithmetic(object):
         expected = DatetimeIndex(['20121231', pd.NaT, '20130101'])
         tm.assert_index_equal(result, expected)
 
-    @pytest.mark.parametrize('freq', [None, 'H'])
-    def test_sub_period(self, freq):
-        # GH 13078
-        # not supported, check TypeError
-        p = pd.Period('2011-01-01', freq='D')
-
-        idx = pd.TimedeltaIndex(['1 hours', '2 hours'], freq=freq)
-
-        with pytest.raises(TypeError):
-            idx - p
-
-        with pytest.raises(TypeError):
-            p - idx
-
     def test_addition_ops(self):
         # with datetimes/timedelta and tdi/dti
         tdi = TimedeltaIndex(['1 days', pd.NaT, '2 days'], name='foo')
diff --git a/pandas/tests/indexes/timedeltas/test_indexing.py b/pandas/tests/indexes/timedeltas/test_indexing.py
index 59e38c2e7..089921882 100644
--- a/pandas/tests/indexes/timedeltas/test_indexing.py
+++ b/pandas/tests/indexes/timedeltas/test_indexing.py
@@ -8,116 +8,7 @@ import pandas.util.testing as tm
 from pandas import TimedeltaIndex, timedelta_range, compat, Index, Timedelta
 
 
-class TestTimedeltaIndex(object):
-
-    def test_insert(self):
-
-        idx = TimedeltaIndex(['4day', '1day', '2day'], name='idx')
-
-        result = idx.insert(2, timedelta(days=5))
-        exp = TimedeltaIndex(['4day', '1day', '5day', '2day'], name='idx')
-        tm.assert_index_equal(result, exp)
-
-        # insertion of non-datetime should coerce to object index
-        result = idx.insert(1, 'inserted')
-        expected = Index([Timedelta('4day'), 'inserted', Timedelta('1day'),
-                          Timedelta('2day')], name='idx')
-        assert not isinstance(result, TimedeltaIndex)
-        tm.assert_index_equal(result, expected)
-        assert result.name == expected.name
-
-        idx = timedelta_range('1day 00:00:01', periods=3, freq='s', name='idx')
-
-        # preserve freq
-        expected_0 = TimedeltaIndex(['1day', '1day 00:00:01', '1day 00:00:02',
-                                     '1day 00:00:03'],
-                                    name='idx', freq='s')
-        expected_3 = TimedeltaIndex(['1day 00:00:01', '1day 00:00:02',
-                                     '1day 00:00:03', '1day 00:00:04'],
-                                    name='idx', freq='s')
-
-        # reset freq to None
-        expected_1_nofreq = TimedeltaIndex(['1day 00:00:01', '1day 00:00:01',
-                                            '1day 00:00:02', '1day 00:00:03'],
-                                           name='idx', freq=None)
-        expected_3_nofreq = TimedeltaIndex(['1day 00:00:01', '1day 00:00:02',
-                                            '1day 00:00:03', '1day 00:00:05'],
-                                           name='idx', freq=None)
-
-        cases = [(0, Timedelta('1day'), expected_0),
-                 (-3, Timedelta('1day'), expected_0),
-                 (3, Timedelta('1day 00:00:04'), expected_3),
-                 (1, Timedelta('1day 00:00:01'), expected_1_nofreq),
-                 (3, Timedelta('1day 00:00:05'), expected_3_nofreq)]
-
-        for n, d, expected in cases:
-            result = idx.insert(n, d)
-            tm.assert_index_equal(result, expected)
-            assert result.name == expected.name
-            assert result.freq == expected.freq
-
-        # GH 18295 (test missing)
-        expected = TimedeltaIndex(['1day', pd.NaT, '2day', '3day'])
-        for na in (np.nan, pd.NaT, None):
-            result = timedelta_range('1day', '3day').insert(1, na)
-            tm.assert_index_equal(result, expected)
-
-    def test_delete(self):
-        idx = timedelta_range(start='1 Days', periods=5, freq='D', name='idx')
-
-        # prserve freq
-        expected_0 = timedelta_range(start='2 Days', periods=4, freq='D',
-                                     name='idx')
-        expected_4 = timedelta_range(start='1 Days', periods=4, freq='D',
-                                     name='idx')
-
-        # reset freq to None
-        expected_1 = TimedeltaIndex(
-            ['1 day', '3 day', '4 day', '5 day'], freq=None, name='idx')
-
-        cases = {0: expected_0,
-                 -5: expected_0,
-                 -1: expected_4,
-                 4: expected_4,
-                 1: expected_1}
-        for n, expected in compat.iteritems(cases):
-            result = idx.delete(n)
-            tm.assert_index_equal(result, expected)
-            assert result.name == expected.name
-            assert result.freq == expected.freq
-
-        with pytest.raises((IndexError, ValueError)):
-            # either depeidnig on numpy version
-            result = idx.delete(5)
-
-    def test_delete_slice(self):
-        idx = timedelta_range(start='1 days', periods=10, freq='D', name='idx')
-
-        # prserve freq
-        expected_0_2 = timedelta_range(start='4 days', periods=7, freq='D',
-                                       name='idx')
-        expected_7_9 = timedelta_range(start='1 days', periods=7, freq='D',
-                                       name='idx')
-
-        # reset freq to None
-        expected_3_5 = TimedeltaIndex(['1 d', '2 d', '3 d',
-                                       '7 d', '8 d', '9 d', '10d'],
-                                      freq=None, name='idx')
-
-        cases = {(0, 1, 2): expected_0_2,
-                 (7, 8, 9): expected_7_9,
-                 (3, 4, 5): expected_3_5}
-        for n, expected in compat.iteritems(cases):
-            result = idx.delete(n)
-            tm.assert_index_equal(result, expected)
-            assert result.name == expected.name
-            assert result.freq == expected.freq
-
-            result = idx.delete(slice(n[0], n[-1] + 1))
-            tm.assert_index_equal(result, expected)
-            assert result.name == expected.name
-            assert result.freq == expected.freq
-
+class TestGetItem(object):
     def test_getitem(self):
         idx1 = timedelta_range('1 day', '31 day', freq='D', name='idx')
 
@@ -150,6 +41,13 @@ class TestTimedeltaIndex(object):
             tm.assert_index_equal(result, expected)
             assert result.freq == expected.freq
 
+
+class TestWhere(object):
+    # placeholder for symmetry with DatetimeIndex and PeriodIndex tests
+    pass
+
+
+class TestTake(object):
     def test_take(self):
         # GH 10295
         idx1 = timedelta_range('1 day', '31 day', freq='D', name='idx')
@@ -252,6 +150,117 @@ class TestTimedeltaIndex(object):
         with pytest.raises(IndexError):
             idx.take(np.array([1, -5]))
 
+
+class TestTimedeltaIndex(object):
+
+    def test_insert(self):
+
+        idx = TimedeltaIndex(['4day', '1day', '2day'], name='idx')
+
+        result = idx.insert(2, timedelta(days=5))
+        exp = TimedeltaIndex(['4day', '1day', '5day', '2day'], name='idx')
+        tm.assert_index_equal(result, exp)
+
+        # insertion of non-datetime should coerce to object index
+        result = idx.insert(1, 'inserted')
+        expected = Index([Timedelta('4day'), 'inserted', Timedelta('1day'),
+                          Timedelta('2day')], name='idx')
+        assert not isinstance(result, TimedeltaIndex)
+        tm.assert_index_equal(result, expected)
+        assert result.name == expected.name
+
+        idx = timedelta_range('1day 00:00:01', periods=3, freq='s', name='idx')
+
+        # preserve freq
+        expected_0 = TimedeltaIndex(['1day', '1day 00:00:01', '1day 00:00:02',
+                                     '1day 00:00:03'],
+                                    name='idx', freq='s')
+        expected_3 = TimedeltaIndex(['1day 00:00:01', '1day 00:00:02',
+                                     '1day 00:00:03', '1day 00:00:04'],
+                                    name='idx', freq='s')
+
+        # reset freq to None
+        expected_1_nofreq = TimedeltaIndex(['1day 00:00:01', '1day 00:00:01',
+                                            '1day 00:00:02', '1day 00:00:03'],
+                                           name='idx', freq=None)
+        expected_3_nofreq = TimedeltaIndex(['1day 00:00:01', '1day 00:00:02',
+                                            '1day 00:00:03', '1day 00:00:05'],
+                                           name='idx', freq=None)
+
+        cases = [(0, Timedelta('1day'), expected_0),
+                 (-3, Timedelta('1day'), expected_0),
+                 (3, Timedelta('1day 00:00:04'), expected_3),
+                 (1, Timedelta('1day 00:00:01'), expected_1_nofreq),
+                 (3, Timedelta('1day 00:00:05'), expected_3_nofreq)]
+
+        for n, d, expected in cases:
+            result = idx.insert(n, d)
+            tm.assert_index_equal(result, expected)
+            assert result.name == expected.name
+            assert result.freq == expected.freq
+
+        # GH 18295 (test missing)
+        expected = TimedeltaIndex(['1day', pd.NaT, '2day', '3day'])
+        for na in (np.nan, pd.NaT, None):
+            result = timedelta_range('1day', '3day').insert(1, na)
+            tm.assert_index_equal(result, expected)
+
+    def test_delete(self):
+        idx = timedelta_range(start='1 Days', periods=5, freq='D', name='idx')
+
+        # prserve freq
+        expected_0 = timedelta_range(start='2 Days', periods=4, freq='D',
+                                     name='idx')
+        expected_4 = timedelta_range(start='1 Days', periods=4, freq='D',
+                                     name='idx')
+
+        # reset freq to None
+        expected_1 = TimedeltaIndex(
+            ['1 day', '3 day', '4 day', '5 day'], freq=None, name='idx')
+
+        cases = {0: expected_0,
+                 -5: expected_0,
+                 -1: expected_4,
+                 4: expected_4,
+                 1: expected_1}
+        for n, expected in compat.iteritems(cases):
+            result = idx.delete(n)
+            tm.assert_index_equal(result, expected)
+            assert result.name == expected.name
+            assert result.freq == expected.freq
+
+        with pytest.raises((IndexError, ValueError)):
+            # either depeidnig on numpy version
+            result = idx.delete(5)
+
+    def test_delete_slice(self):
+        idx = timedelta_range(start='1 days', periods=10, freq='D', name='idx')
+
+        # prserve freq
+        expected_0_2 = timedelta_range(start='4 days', periods=7, freq='D',
+                                       name='idx')
+        expected_7_9 = timedelta_range(start='1 days', periods=7, freq='D',
+                                       name='idx')
+
+        # reset freq to None
+        expected_3_5 = TimedeltaIndex(['1 d', '2 d', '3 d',
+                                       '7 d', '8 d', '9 d', '10d'],
+                                      freq=None, name='idx')
+
+        cases = {(0, 1, 2): expected_0_2,
+                 (7, 8, 9): expected_7_9,
+                 (3, 4, 5): expected_3_5}
+        for n, expected in compat.iteritems(cases):
+            result = idx.delete(n)
+            tm.assert_index_equal(result, expected)
+            assert result.name == expected.name
+            assert result.freq == expected.freq
+
+            result = idx.delete(slice(n[0], n[-1] + 1))
+            tm.assert_index_equal(result, expected)
+            assert result.name == expected.name
+            assert result.freq == expected.freq
+
     def test_get_loc(self):
         idx = pd.to_timedelta(['0 days', '1 days', '2 days'])
 

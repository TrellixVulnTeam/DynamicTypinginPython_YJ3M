commit f735a67561c2a316f6538d9fd344e861771d4916
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Jan 13 10:59:11 2012 -0500

    ENH: wrap up API changes and testing around #592

diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 26f6aa332..8bf5506d0 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -31,11 +31,14 @@ class _NDFrameIndexer(object):
         else:
             return self._getitem_axis(key, axis=0)
 
-    def _getitem_xs(self, idx, axis=0):
+    def _get(self, label, axis=0):
         try:
-            return self.obj.xs(idx, axis=axis, copy=False)
+            return self.obj.xs(label, axis=axis, copy=False)
         except Exception:
-            return self.obj.xs(idx, axis=axis, copy=True)
+            return self.obj.xs(label, axis=axis, copy=True)
+
+    def _slice(self, obj, axis=0):
+        return self.obj._slice(obj, axis=axis)
 
     def __setitem__(self, key, value):
         # kludgetastic
@@ -93,7 +96,7 @@ class _NDFrameIndexer(object):
         # a bit kludgy
         if isinstance(self.obj._get_axis(0), MultiIndex):
             try:
-                return self._getitem_xs(tup, axis=0)
+                return self._get(tup, axis=0)
             except (KeyError, TypeError):
                 pass
 
@@ -153,7 +156,7 @@ class _NDFrameIndexer(object):
             if com.is_integer(key):
                 if isinstance(labels, MultiIndex):
                     try:
-                        return self._getitem_xs(key, axis=0)
+                        return self._get(key, axis=0)
                     except (KeyError, TypeError):
                         if _is_integer_index(self.obj.index.levels[0]):
                             raise
@@ -161,13 +164,13 @@ class _NDFrameIndexer(object):
                 if not is_int_index:
                     idx = labels[key]
 
-            return self._getitem_xs(idx, axis=0)
+            return self._get(idx, axis=0)
         else:
             labels = self.obj._get_axis(axis)
             lab = key
             if com.is_integer(key) and not _is_integer_index(labels):
                 lab = labels[key]
-            return self._getitem_xs(lab, axis=axis)
+            return self._get(lab, axis=axis)
 
     def _getitem_iterable(self, key, axis=0):
         labels = self.obj._get_axis(axis)
@@ -298,7 +301,7 @@ class _NDFrameIndexer(object):
         if not _need_slice(slice_obj):
             return obj
 
-        return obj._slice(slicer, axis=axis)
+        return self._slice(slicer, axis=axis)
 
 def _is_integer_slice(obj):
     def _crit(v):
@@ -327,77 +330,14 @@ class _SeriesIndexer(_NDFrameIndexer):
     >>> ts.ix[date1:date2] = 0
     """
 
-    def __getitem__(self, key):
-        ax = self.obj.index
-
-        if isinstance(key, slice):
-            key = self._convert_slice(key)
-
-        if isinstance(ax, MultiIndex):
-            try:
-                # key = ax.get_loc(key)
-                return self._get_default(key)
-            except Exception:
-                pass
-
-        if _isboolarr(key):
-            self._check_boolean_key(key)
-        elif isinstance(key, slice):
-            pass
-        elif _is_list_like(key):
-            return self._get_list_like(key)
-        return self._get_default(key)
-
-    def __setitem__(self, key, value):
-        ax = self.obj.index
-        if isinstance(ax, MultiIndex):
-            try:
-                key = ax.get_loc(key)
-                self._set_default(key, value)
-                return
-            except Exception:
-                pass
-
-        if _isboolarr(key):
-            self._check_boolean_key(key)
-        elif isinstance(key, slice):
-            key = self._convert_slice(key)
-        elif _is_list_like(key):
-            return self._set_list_like(key, value)
-        return self._set_default(key, value)
-
-    def _check_boolean_key(self, key):
-        if _is_series(key):
-            if not key.index.equals(self.obj.index):
-                raise IndexingError('Cannot use boolean index with '
-                                    'misaligned or unequal labels')
-
-    def _convert_slice(self, key):
-        if _is_label_slice(self.obj.index, key):
-            i, j = self.obj.index.slice_locs(key.start, key.stop)
-            key = slice(i, j)
-        return key
-
-    def _get_default(self, key):
-        return self.obj[key]
-
-    def _get_list_like(self, key):
-        if isinstance(self.obj.index, MultiIndex):
-            try:
-                return self.obj[key]
-            except (KeyError, TypeError, IndexError):
-                pass
-        return self.obj.reindex(key)
+    def _get(self, label, axis=0):
+        return self.obj[label]
 
-    def _set_default(self, key, value):
-        self.obj[key] = value
+    def _slice(self, obj, axis=0):
+        return self.obj[obj]
 
-    def _set_list_like(self, key, value):
-        inds = self.obj.index.get_indexer(key)
-        mask = inds == -1
-        if mask.any():
-            raise IndexingError('Indices %s not found' % key[mask])
-        self.obj.put(inds, value)
+    def _setitem_with_indexer(self, indexer, value):
+        self.obj[indexer] = value
 
 def _is_series(obj):
     from pandas.core.series import Series
diff --git a/pandas/core/series.py b/pandas/core/series.py
index f2fa8e33c..7e9d1bb7d 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -295,7 +295,7 @@ copy : boolean, default False
                     pass
 
             if index.inferred_type == 'integer':
-                raise # AmbiguousIndexError(key)
+                raise
 
             try:
                 return _gin.get_value_at(self, key)
@@ -307,10 +307,6 @@ copy : boolean, default False
         except TypeError:
             pass
 
-        def _index_with(indexer):
-            return Series(self.values[indexer], index=self.index[indexer],
-                          name=self.name)
-
         # boolean
 
         # special handling of boolean data with NAs stored in object
@@ -318,15 +314,17 @@ copy : boolean, default False
         if _is_bool_indexer(key):
             key = self._check_bool_indexer(key)
             key = np.asarray(key, dtype=bool)
-            return _index_with(key)
 
-        # other: fancy integer or otherwise
+        return self._index_with(key)
 
+    def _index_with(self, key):
+        # other: fancy integer or otherwise
         # [slice(0, 5, None)] will break if you convert to ndarray,
         # e.g. as requested by np.median
 
         try:
-            return _index_with(key)
+            return Series(self.values[key], index=self.index[key],
+                          name=self.name)
         except Exception:
             return self.values[key]
 
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 1f4bee412..4ac78638b 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -472,6 +472,13 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self.assertEqual(len(sl), len(sl.index))
         self.assertEqual(len(sl.index.indexMap), len(sl.index))
 
+    # def test_getitem_reindex(self):
+    #     indices = self.ts.index[[5, 10, 15]]
+
+    #     result = self.ts[indices]
+    #     expected = self.ts.reindex(indices)
+    #     assert_series_equal(result, expected)
+
     def test_ix_getitem(self):
         inds = self.series.index[[3,4,7]]
         assert_series_equal(self.series.ix[inds], self.series.reindex(inds))
@@ -491,6 +498,39 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self.assertEquals(self.ts.ix[d1], self.ts[d1])
         self.assertEquals(self.ts.ix[d2], self.ts[d2])
 
+    def test_ix_getitem_not_monotonic(self):
+        d1, d2 = self.ts.index[[5, 15]]
+
+        ts2 = self.ts[::2][::-1]
+
+        self.assertRaises(KeyError, ts2.ix.__getitem__, slice(d1, d2))
+        self.assertRaises(KeyError, ts2.ix.__setitem__, slice(d1, d2), 0)
+
+    def test_ix_getitem_setitem_integer_slice_keyerrors(self):
+        s = Series(np.random.randn(10), index=range(0, 20, 2))
+
+        # this is OK
+        cp = s.copy()
+        cp.ix[4:10] = 0
+        self.assert_((cp.ix[4:10] == 0).all())
+
+        # so is this
+        cp = s.copy()
+        cp.ix[3:11] = 0
+        self.assert_((cp.ix[3:11] == 0).values.all())
+
+        result = s.ix[4:10]
+        result2 = s.ix[3:11]
+        expected = s.reindex([4, 6, 8, 10])
+
+        assert_series_equal(result, expected)
+        assert_series_equal(result2, expected)
+
+        # non-monotonic, raise KeyError
+        s2 = s[::-1]
+        self.assertRaises(KeyError, s2.ix.__getitem__, slice(3, 11))
+        self.assertRaises(KeyError, s2.ix.__setitem__, slice(3, 11), 0)
+
     def test_ix_getitem_iterator(self):
         idx = iter(self.series.index[:10])
         result = self.series.ix[idx]
diff --git a/pandas/tools/tests/test_pivot.py b/pandas/tools/tests/test_pivot.py
index 03d8a0424..3cdbba766 100644
--- a/pandas/tools/tests/test_pivot.py
+++ b/pandas/tools/tests/test_pivot.py
@@ -80,7 +80,6 @@ class TestPivotTable(unittest.TestCase):
         expected = concat([means, stds], keys=['mean', 'std'], axis=1)
         tm.assert_frame_equal(result, expected)
 
-
     def test_margins(self):
         def _check_output(res, col, rows=['A', 'B'], cols=['C']):
             cmarg = res['All'][:-1]

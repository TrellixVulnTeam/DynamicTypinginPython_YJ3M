commit 876df6fb67a9ac3cfe238045745a608aad3b3de4
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Apr 28 16:09:02 2012 -0400

    ENH: test cases for period upsampling, implement kind='timestamp' close #1109

diff --git a/pandas/tseries/frequencies.py b/pandas/tseries/frequencies.py
index 59e4279f6..c1b234d0c 100644
--- a/pandas/tseries/frequencies.py
+++ b/pandas/tseries/frequencies.py
@@ -872,18 +872,19 @@ def is_superperiod(source, target):
         return target in ['D', 'B', 'M', 'H', 'T', 'S']
     elif _is_quarterly(source):
         return target in ['D', 'B', 'M', 'H', 'T', 'S']
-    elif target == 'M':
-        return source in ['D', 'B', 'H', 'T', 'S']
+    elif source == 'M':
+        return target in ['D', 'B', 'H', 'T', 'S']
     elif _is_weekly(source):
-        return source in [target, 'D', 'B', 'H', 'T', 'S']
-    elif target == 'B':
-        return source in ['D', 'B', 'H', 'T', 'S']
-    elif target == 'D':
-        return source not in ['D', 'B', 'H', 'T', 'S']
+        return target in [source, 'D', 'B', 'H', 'T', 'S']
+    elif source == 'B':
+        return target in ['D', 'B', 'H', 'T', 'S']
+    elif source == 'D':
+        return target not in ['D', 'B', 'H', 'T', 'S']
 
 
 def _is_annual(rule):
-    return rule.upper().startswith('A-')
+    rule = rule.upper()
+    return rule == 'A' or rule.startswith('A-')
 
 
 def _is_quarterly(rule):
@@ -894,19 +895,13 @@ def _is_weekly(rule):
     return rule.upper().startswith('W-')
 
 
-_weekday_rule_aliases = {
-    0: 'MON',
-    1: 'TUE',
-    2: 'WED',
-    3: 'THU',
-    4: 'FRI',
-    5: 'SAT',
-    6: 'SUN'
-}
+DAYS = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
 
 MONTHS = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL',
           'AUG', 'SEP', 'OCT', 'NOV', 'DEC']
 
+
+_weekday_rule_aliases = dict((k, v) for k, v in enumerate(DAYS))
 _month_aliases = dict((k + 1, v) for k, v in enumerate(MONTHS))
 
 def _is_multiple(us, mult):
diff --git a/pandas/tseries/resample.py b/pandas/tseries/resample.py
index c5b7a6c6f..85fdb8901 100644
--- a/pandas/tseries/resample.py
+++ b/pandas/tseries/resample.py
@@ -60,7 +60,11 @@ class TimeGrouper(CustomGrouper):
         if isinstance(axis, DatetimeIndex):
             return self._resample_timestamps(obj)
         elif isinstance(axis, PeriodIndex):
-            return self._resample_periods(obj)
+            if self.kind is None or self.kind == 'period':
+                return self._resample_periods(obj)
+            else:
+                obj = obj.to_timestamp(how=self.convention)
+                return self._resample_timestamps(obj)
         else:
             raise TypeError('Only valid with DatetimeIndex or PeriodIndex')
 
diff --git a/pandas/tseries/tests/test_resample.py b/pandas/tseries/tests/test_resample.py
index 0180736ce..80ccc3ad4 100644
--- a/pandas/tseries/tests/test_resample.py
+++ b/pandas/tseries/tests/test_resample.py
@@ -300,7 +300,7 @@ def _simple_pts(start, end, freq='D'):
     return Series(np.random.randn(len(rng)), index=rng)
 
 
-from pandas.tseries.frequencies import MONTHS
+from pandas.tseries.frequencies import MONTHS, DAYS
 from pandas.util.compat import product
 
 class TestResamplePeriodIndex(unittest.TestCase):
@@ -316,6 +316,7 @@ class TestResamplePeriodIndex(unittest.TestCase):
 
         # this is ok
         assert_series_equal(ts.resample('a-dec'), result)
+        assert_series_equal(ts.resample('a'), result)
 
     def test_not_subperiod(self):
         # These are incompatible period rules for resampling
@@ -356,17 +357,49 @@ class TestResamplePeriodIndex(unittest.TestCase):
         assert_series_equal(rdf['a'], exp)
 
     def test_quarterly_upsample(self):
-        pass
+        targets = ['D', 'B', 'M']
+
+        for month in MONTHS:
+            ts = _simple_pts('1/1/1990', '12/31/1995', freq='Q-%s' % month)
+
+            for targ, conv in product(targets, ['start', 'end']):
+                result = ts.resample(targ, fill_method='ffill',
+                                     convention=conv)
+                expected = result.to_timestamp(targ, how=conv)
+                expected = expected.asfreq(targ, 'ffill').to_period()
+                assert_series_equal(result, expected)
 
     def test_monthly_upsample(self):
-        pass
+        targets = ['D', 'B']
+
+        ts = _simple_pts('1/1/1990', '12/31/1995', freq='M')
+
+        for targ, conv in product(targets, ['start', 'end']):
+            result = ts.resample(targ, fill_method='ffill',
+                                 convention=conv)
+            expected = result.to_timestamp(targ, how=conv)
+            expected = expected.asfreq(targ, 'ffill').to_period()
+            assert_series_equal(result, expected)
 
     def test_weekly_upsample(self):
-        pass
+        targets = ['D', 'B']
 
-    def test_resampl_to_timestamps(self):
-        pass
+        for day in DAYS:
+            ts = _simple_pts('1/1/1990', '12/31/1995', freq='W-%s' % day)
 
+            for targ, conv in product(targets, ['start', 'end']):
+                result = ts.resample(targ, fill_method='ffill',
+                                     convention=conv)
+                expected = result.to_timestamp(targ, how=conv)
+                expected = expected.asfreq(targ, 'ffill').to_period()
+                assert_series_equal(result, expected)
+
+    def test_resample_to_timestamps(self):
+        ts = _simple_pts('1/1/1990', '12/31/1995', freq='M')
+
+        result = ts.resample('A-DEC', kind='timestamp')
+        expected = ts.to_timestamp(how='end').resample('A-DEC')
+        assert_series_equal(result, expected)
 
 class TestTimeGrouper(unittest.TestCase):
 

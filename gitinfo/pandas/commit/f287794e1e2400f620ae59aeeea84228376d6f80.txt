commit f287794e1e2400f620ae59aeeea84228376d6f80
Author: MomIsBestFriend <50263213+MomIsBestFriend@users.noreply.github.com>
Date:   Wed Dec 11 13:33:49 2019 +0200

    STY: Underscores for long numbers (#30166)

diff --git a/pandas/_libs/testing.pyx b/pandas/_libs/testing.pyx
index 8b847350c..e41914f3a 100644
--- a/pandas/_libs/testing.pyx
+++ b/pandas/_libs/testing.pyx
@@ -66,7 +66,8 @@ cpdef assert_almost_equal(a, b,
                           check_less_precise=False,
                           bint check_dtype=True,
                           obj=None, lobj=None, robj=None):
-    """Check that left and right objects are almost equal.
+    """
+    Check that left and right objects are almost equal.
 
     Parameters
     ----------
@@ -89,7 +90,6 @@ cpdef assert_almost_equal(a, b,
         Specify right object name being compared, internally used to show
         appropriate assertion message
     """
-
     cdef:
         int decimal
         double diff = 0.0
@@ -127,9 +127,9 @@ cpdef assert_almost_equal(a, b,
             # classes can't be the same, to raise error
             assert_class_equal(a, b, obj=obj)
 
-        assert has_length(a) and has_length(b), (
-            f"Can't compare objects without length, one or both is invalid: "
-            f"({a}, {b})")
+        assert has_length(a) and has_length(b), ("Can't compare objects without "
+                                                 "length, one or both is invalid: "
+                                                 f"({a}, {b})")
 
         if a_is_ndarray and b_is_ndarray:
             na, nb = a.size, b.size
@@ -157,7 +157,7 @@ cpdef assert_almost_equal(a, b,
             else:
                 r = None
 
-            raise_assert_detail(obj, f'{obj} length are different', na, nb, r)
+            raise_assert_detail(obj, f"{obj} length are different", na, nb, r)
 
         for i in xrange(len(a)):
             try:
@@ -169,8 +169,8 @@ cpdef assert_almost_equal(a, b,
 
         if is_unequal:
             from pandas.util.testing import raise_assert_detail
-            msg = (f'{obj} values are different '
-                   f'({np.round(diff * 100.0 / na, 5)} %)')
+            msg = (f"{obj} values are different "
+                   f"({np.round(diff * 100.0 / na, 5)} %)")
             raise_assert_detail(obj, msg, lobj, robj)
 
         return True
diff --git a/pandas/core/algorithms.py b/pandas/core/algorithms.py
index 6ccd71a56..42cfd9d54 100644
--- a/pandas/core/algorithms.py
+++ b/pandas/core/algorithms.py
@@ -391,16 +391,15 @@ def isin(comps, values) -> np.ndarray:
     ndarray[bool]
         Same length as `comps`.
     """
-
     if not is_list_like(comps):
         raise TypeError(
-            "only list-like objects are allowed to be passed"
-            f" to isin(), you passed a [{type(comps).__name__}]"
+            "only list-like objects are allowed to be passed "
+            f"to isin(), you passed a [{type(comps).__name__}]"
         )
     if not is_list_like(values):
         raise TypeError(
-            "only list-like objects are allowed to be passed"
-            f" to isin(), you passed a [{type(values).__name__}]"
+            "only list-like objects are allowed to be passed "
+            f"to isin(), you passed a [{type(values).__name__}]"
         )
 
     if not isinstance(values, (ABCIndex, ABCSeries, np.ndarray)):
@@ -421,7 +420,7 @@ def isin(comps, values) -> np.ndarray:
 
     # GH16012
     # Ensure np.in1d doesn't get object types or it *may* throw an exception
-    if len(comps) > 1000000 and not is_object_dtype(comps):
+    if len(comps) > 1_000_000 and not is_object_dtype(comps):
         f = np.in1d
     elif is_integer_dtype(comps):
         try:
@@ -833,8 +832,8 @@ def mode(values, dropna: bool = True) -> ABCSeries:
     result = f(values, dropna=dropna)
     try:
         result = np.sort(result)
-    except TypeError as e:
-        warn(f"Unable to sort modes: {e}")
+    except TypeError as err:
+        warn(f"Unable to sort modes: {err}")
 
     result = _reconstruct_data(result, original.dtype, original)
     return Series(result)
@@ -1019,7 +1018,8 @@ def quantile(x, q, interpolation_method="fraction"):
     values = np.sort(x)
 
     def _interpolate(a, b, fraction):
-        """Returns the point at the given fraction between a and b, where
+        """
+        Returns the point at the given fraction between a and b, where
         'fraction' must be between 0 and 1.
         """
         return a + (b - a) * fraction
@@ -1192,7 +1192,8 @@ class SelectNFrame(SelectN):
                 )
 
         def get_indexer(current_indexer, other_indexer):
-            """Helper function to concat `current_indexer` and `other_indexer`
+            """
+            Helper function to concat `current_indexer` and `other_indexer`
             depending on `method`
             """
             if method == "nsmallest":
@@ -1660,7 +1661,7 @@ take_1d = take_nd
 
 def take_2d_multi(arr, indexer, fill_value=np.nan):
     """
-    Specialized Cython take which sets NaN values in one pass
+    Specialized Cython take which sets NaN values in one pass.
     """
     # This is only called from one place in DataFrame._reindex_multi,
     #  so we know indexer is well-behaved.
@@ -1988,8 +1989,8 @@ def safe_sort(
 
     if not is_list_like(codes):
         raise TypeError(
-            "Only list-like objects or None are allowed to be"
-            "passed to safe_sort as codes"
+            "Only list-like objects or None are allowed to "
+            "be passed to safe_sort as codes"
         )
     codes = ensure_platform_int(np.asarray(codes))
 
diff --git a/pandas/core/arrays/categorical.py b/pandas/core/arrays/categorical.py
index 1e470e44e..7170aec38 100644
--- a/pandas/core/arrays/categorical.py
+++ b/pandas/core/arrays/categorical.py
@@ -494,14 +494,13 @@ class Categorical(ExtensionArray, PandasObject):
         if is_extension_array_dtype(dtype):
             return array(self, dtype=dtype, copy=copy)  # type: ignore # GH 28770
         if is_integer_dtype(dtype) and self.isna().any():
-            msg = "Cannot convert float NaN to integer"
-            raise ValueError(msg)
+            raise ValueError("Cannot convert float NaN to integer")
         return np.array(self, dtype=dtype, copy=copy)
 
     @cache_readonly
     def size(self) -> int:
         """
-        return the len of myself
+        Return the len of myself.
         """
         return self._codes.size
 
diff --git a/pandas/core/computation/align.py b/pandas/core/computation/align.py
index 9390eb47d..57348ad3b 100644
--- a/pandas/core/computation/align.py
+++ b/pandas/core/computation/align.py
@@ -35,7 +35,9 @@ def _zip_axes_from_type(typ, new_axes):
 
 
 def _any_pandas_objects(terms) -> bool:
-    """Check a sequence of terms for instances of PandasObject."""
+    """
+    Check a sequence of terms for instances of PandasObject.
+    """
     return any(isinstance(term.value, PandasObject) for term in terms)
 
 
@@ -116,7 +118,9 @@ def _align_core(terms):
 
 
 def align_terms(terms):
-    """Align a set of terms"""
+    """
+    Align a set of terms.
+    """
     try:
         # flatten the parse tree (a nested list, really)
         terms = list(com.flatten(terms))
diff --git a/pandas/core/computation/common.py b/pandas/core/computation/common.py
index da47449d5..994f47094 100644
--- a/pandas/core/computation/common.py
+++ b/pandas/core/computation/common.py
@@ -9,15 +9,19 @@ _BACKTICK_QUOTED_STRING = 100
 
 
 def _ensure_decoded(s):
-    """ if we have bytes, decode them to unicode """
+    """
+    If we have bytes, decode them to unicode.
+    """
     if isinstance(s, (np.bytes_, bytes)):
         s = s.decode(get_option("display.encoding"))
     return s
 
 
 def result_type_many(*arrays_and_dtypes):
-    """ wrapper around numpy.result_type which overcomes the NPY_MAXARGS (32)
-    argument limit """
+    """
+    Wrapper around numpy.result_type which overcomes the NPY_MAXARGS (32)
+    argument limit.
+    """
     try:
         return np.result_type(*arrays_and_dtypes)
     except ValueError:
@@ -26,8 +30,10 @@ def result_type_many(*arrays_and_dtypes):
 
 
 def _remove_spaces_column_name(name):
-    """Check if name contains any spaces, if it contains any spaces
-    the spaces will be removed and an underscore suffix is added."""
+    """
+    Check if name contains any spaces, if it contains any spaces
+    the spaces will be removed and an underscore suffix is added.
+    """
     if not isinstance(name, str) or " " not in name:
         return name
 
diff --git a/pandas/core/computation/ops.py b/pandas/core/computation/ops.py
index 2215629ec..cb166ba65 100644
--- a/pandas/core/computation/ops.py
+++ b/pandas/core/computation/ops.py
@@ -506,8 +506,8 @@ class Div(BinOp):
 
         if not isnumeric(lhs.return_type) or not isnumeric(rhs.return_type):
             raise TypeError(
-                f"unsupported operand type(s) for {self.op}:"
-                f" '{lhs.return_type}' and '{rhs.return_type}'"
+                f"unsupported operand type(s) for {self.op}: "
+                f"'{lhs.return_type}' and '{rhs.return_type}'"
             )
 
         # do not upcast float32s to float64 un-necessarily
diff --git a/pandas/tests/io/formats/test_format.py b/pandas/tests/io/formats/test_format.py
index e875a6f13..6fd813c08 100644
--- a/pandas/tests/io/formats/test_format.py
+++ b/pandas/tests/io/formats/test_format.py
@@ -2376,7 +2376,8 @@ class TestSeriesFormatting:
 
             # object dtype, longer than unicode repr
             s = Series(
-                [1, 22, 3333, 44444], index=[1, "AB", pd.Timestamp("2011-01-01"), "あああ"]
+                [1, 22, 3333, 44444],
+                index=[1, "AB", pd.Timestamp("2011-01-01"), "あああ"],
             )
             expected = (
                 "1                          1\n"
diff --git a/pandas/tests/io/parser/test_usecols.py b/pandas/tests/io/parser/test_usecols.py
index afe19608e..539fdf247 100644
--- a/pandas/tests/io/parser/test_usecols.py
+++ b/pandas/tests/io/parser/test_usecols.py
@@ -199,7 +199,7 @@ def test_usecols_with_whitespace(all_parsers):
         # Column selection by index.
         ([0, 1], DataFrame(data=[[1000, 2000], [4000, 5000]], columns=["2", "0"])),
         # Column selection by name.
-        (["0", "1"], DataFrame(data=[[2000, 3000], [5000, 6000]], columns=["0", "1"])),
+        (["0", "1"], DataFrame(data=[[2000, 3000], [5000, 6000]], columns=["0", "1"]),),
     ],
 )
 def test_usecols_with_integer_like_header(all_parsers, usecols, expected):
diff --git a/pandas/tests/io/pytables/test_compat.py b/pandas/tests/io/pytables/test_compat.py
index 1e320e12a..a82e21532 100644
--- a/pandas/tests/io/pytables/test_compat.py
+++ b/pandas/tests/io/pytables/test_compat.py
@@ -9,21 +9,22 @@ tables = pytest.importorskip("tables")
 
 @pytest.fixture
 def pytables_hdf5_file():
-    """Use PyTables to create a simple HDF5 file."""
-
+    """
+    Use PyTables to create a simple HDF5 file.
+    """
     table_schema = {
         "c0": tables.Time64Col(pos=0),
         "c1": tables.StringCol(5, pos=1),
         "c2": tables.Int64Col(pos=2),
     }
 
-    t0 = 1561105000.0
+    t0 = 1_561_105_000.0
 
     testsamples = [
         {"c0": t0, "c1": "aaaaa", "c2": 1},
         {"c0": t0 + 1, "c1": "bbbbb", "c2": 2},
         {"c0": t0 + 2, "c1": "ccccc", "c2": 10 ** 5},
-        {"c0": t0 + 3, "c1": "ddddd", "c2": 4294967295},
+        {"c0": t0 + 3, "c1": "ddddd", "c2": 4_294_967_295},
     ]
 
     objname = "pandas_test_timeseries"

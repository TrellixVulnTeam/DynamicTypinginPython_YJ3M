commit d8c66107cb5b34694581f790cc4ec6780b8d82e5
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon Nov 25 14:58:23 2019 -0800

    CLN: avoid catching Exception in io.pytables (#29810)

diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index b229e5b4e..9dc955d8d 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -996,6 +996,8 @@ class HDFStore:
             # the key is not a valid store, re-raising KeyError
             raise
         except Exception:
+            # In tests we get here with ClosedFileError, TypeError, and
+            #  _table_mod.NoSuchNodeError.  TODO: Catch only these?
 
             if where is not None:
                 raise ValueError(
@@ -1806,8 +1808,7 @@ class IndexCol:
         # making an Index instance could throw a number of different errors
         try:
             self.values = Index(values, **kwargs)
-        except Exception:
-
+        except ValueError:
             # if the output freq is different that what we recorded,
             # it should be None (see also 'doc example part 2')
             if "freq" in kwargs:
@@ -4188,36 +4189,29 @@ class AppendableTable(Table):
             if not np.prod(v.shape):
                 return
 
-        try:
-            nrows = indexes[0].shape[0]
-            if nrows != len(rows):
-                rows = np.empty(nrows, dtype=self.dtype)
-            names = self.dtype.names
-            nindexes = len(indexes)
-
-            # indexes
-            for i, idx in enumerate(indexes):
-                rows[names[i]] = idx
+        nrows = indexes[0].shape[0]
+        if nrows != len(rows):
+            rows = np.empty(nrows, dtype=self.dtype)
+        names = self.dtype.names
+        nindexes = len(indexes)
 
-            # values
-            for i, v in enumerate(values):
-                rows[names[i + nindexes]] = v
+        # indexes
+        for i, idx in enumerate(indexes):
+            rows[names[i]] = idx
 
-            # mask
-            if mask is not None:
-                m = ~mask.ravel().astype(bool, copy=False)
-                if not m.all():
-                    rows = rows[m]
+        # values
+        for i, v in enumerate(values):
+            rows[names[i + nindexes]] = v
 
-        except Exception as detail:
-            raise Exception(f"cannot create row-data -> {detail}")
+        # mask
+        if mask is not None:
+            m = ~mask.ravel().astype(bool, copy=False)
+            if not m.all():
+                rows = rows[m]
 
-        try:
-            if len(rows):
-                self.table.append(rows)
-                self.table.flush()
-        except Exception as detail:
-            raise TypeError(f"tables cannot write this data -> {detail}")
+        if len(rows):
+            self.table.append(rows)
+            self.table.flush()
 
     def delete(
         self,

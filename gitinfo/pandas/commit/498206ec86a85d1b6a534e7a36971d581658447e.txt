commit 498206ec86a85d1b6a534e7a36971d581658447e
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Sep 28 16:29:29 2011 -0400

    ENH: Int64Index class, Cython codegen, refactoring to enable transparent use

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index a848ad408..4b23ec2bf 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -295,6 +295,9 @@ class DateRange(Index):
         else:
             return Index.union(self, other)
 
+    def _wrap_union_result(self, other, result):
+        return Index(result)
+
     def tz_normalize(self, tz):
         """
         Convert DateRange from one time zone to another (using pytz)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 237031c93..e5e3ee2e9 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1575,7 +1575,8 @@ class DataFrame(NDFrame):
             this = self.reindex(new_index)
             other = other.reindex(new_index)
 
-        new_columns = _try_sort(set(this.columns + other.columns))
+        # sorts if possible
+        new_columns = this.columns.union(other.columns)
         do_fill = fill_value is not None
 
         result = {}
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 2eb03342a..747589d96 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -115,7 +115,7 @@ class GroupBy(object):
             to_groupby = Index(to_groupby)
 
             axis = self.obj._get_axis(self.axis)
-            self._groups = _tseries.groupby(axis, to_groupby)
+            self._groups = axis.groupby(to_groupby)
 
         return self._groups
 
@@ -477,7 +477,7 @@ class Grouping(object):
             else:
                 self.grouper = labels
 
-        self.index = index.values
+        self.index = np.asarray(index.values, dtype=object)
 
         # no level passed
         if not isinstance(self.grouper, np.ndarray):
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 51d3568bf..c3de4a4a5 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -42,7 +42,7 @@ class Index(np.ndarray):
     """
     def __new__(cls, data, dtype=None, copy=False):
         if isinstance(data, np.ndarray):
-            if issubclass(data.dtype.type, np.integer):
+            if dtype is None and issubclass(data.dtype.type, np.integer):
                 subarr = data.astype(np.int64)
                 return subarr.view(Int64Index)
             subarr = np.array(data, dtype=object, copy=copy)
@@ -57,12 +57,18 @@ class Index(np.ndarray):
             subarr[:] = data
         return subarr.view(cls)
 
+    @property
+    def dtype(self):
+        return np.dtype('object')
+
     def summary(self):
         if len(self) > 0:
             index_summary = ', %s to %s' % (str(self[0]), str(self[-1]))
         else:
             index_summary = ''
-        return 'Index: %s entries%s' % (len(self), index_summary)
+
+        name = type(self).__name__
+        return '%s: %s entries%s' % (name, len(self), index_summary)
 
     @property
     def values(self):
@@ -70,14 +76,14 @@ class Index(np.ndarray):
 
     @cache_readonly
     def is_monotonic(self):
-        return lib.is_monotonic(self)
+        return lib.is_monotonic_object(self)
 
     _indexMap = None
     @property
     def indexMap(self):
         "{label -> location}"
         if self._indexMap is None:
-            self._indexMap = lib.map_indices_buf(self)
+            self._indexMap = lib.map_indices_object(self)
             self._verify_integrity()
 
         return self._indexMap
@@ -258,7 +264,14 @@ class Index(np.ndarray):
         except Exception:
             pass
 
-        return Index(result)
+        # for subclasses
+        return self._wrap_union_result(other, result)
+
+    def _wrap_union_result(self, other, result):
+        if type(self) == type(other):
+            return type(self)(result)
+        else:
+            return Index(result)
 
     def intersection(self, other):
         """
@@ -354,16 +367,24 @@ class Index(np.ndarray):
 
         method = self._get_method(method)
 
+        if self.dtype != target.dtype:
+            target = Index(target, dtype=object)
+
         if method == 'pad':
-            indexer = lib.pad(self, target, self.indexMap, target.indexMap)
+            indexer = lib.pad_object(self, target, self.indexMap,
+                                     target.indexMap)
         elif method == 'backfill':
-            indexer = lib.backfill(self, target, self.indexMap, target.indexMap)
+            indexer = lib.backfill_object(self, target, self.indexMap,
+                                          target.indexMap)
         elif method is None:
-            indexer = lib.merge_indexer(target, self.indexMap)
+            indexer = lib.merge_indexer_object(target, self.indexMap)
         else:
             raise ValueError('unrecognized method: %s' % method)
         return indexer
 
+    def groupby(self, to_groupby):
+        return lib.groupby(self, to_groupby)
+
     def _get_method(self, method):
         if method:
             method = method.lower()
@@ -487,6 +508,23 @@ class Index(np.ndarray):
 
 class Int64Index(Index):
 
+    def __new__(cls, data, dtype=None, copy=False):
+        if isinstance(data, np.ndarray):
+            subarr = np.array(data, dtype=np.int64, copy=copy)
+        elif np.isscalar(data):
+            raise ValueError('Index(...) must be called with a collection '
+                             'of some kind, %s was passed' % repr(data))
+        else:
+            # other iterable of some kind
+            if not isinstance(data, (list, tuple)):
+                data = list(data)
+            subarr = np.asarray(data, dtype=np.int64)
+        return subarr.view(cls)
+
+    @property
+    def dtype(self):
+        return np.dtype('int64')
+
     @cache_readonly
     def is_monotonic(self):
         return lib.is_monotonic_int64(self)
@@ -513,26 +551,36 @@ class Int64Index(Index):
         if self is other:
             return True
 
-        if not isinstance(other, Int64Index):
-            return False
+        # if not isinstance(other, Int64Index):
+        #     return False
 
         return np.array_equal(self, other)
 
     def get_indexer(self, target, method=None):
         target = _ensure_index(target)
 
+        if self.dtype != target.dtype:
+            this = Index(self, dtype=object)
+            target = Index(target, dtype=object)
+            return this.get_indexer(target, method=method)
+
         method = self._get_method(method)
 
         if method == 'pad':
-            indexer = lib.pad(self, target, self.indexMap, target.indexMap)
+            indexer = lib.pad_int64(self, target, self.indexMap,
+                                    target.indexMap)
         elif method == 'backfill':
-            indexer = lib.backfill(self, target, self.indexMap, target.indexMap)
+            indexer = lib.backfill_int64(self, target, self.indexMap,
+                                         target.indexMap)
         elif method is None:
             indexer = lib.merge_indexer_int64(target, self.indexMap)
         else:
             raise ValueError('unrecognized method: %s' % method)
         return indexer
-    get_indexer.__doc__ = Index.get_indexer__doc__
+    get_indexer.__doc__ = Index.get_indexer.__doc__
+
+    def groupby(self, to_groupby):
+        return lib.groupby(self.values.astype(object), to_groupby)
 
 class DateIndex(Index):
     pass
@@ -965,13 +1013,14 @@ class MultiIndex(Index):
         self_index = self.get_tuple_index()
 
         if method == 'pad':
-            indexer = lib.pad(self_index, target_index, self_index.indexMap,
-                              target.indexMap)
+            indexer = lib.pad_object(self_index, target_index,
+                                     self_index.indexMap, target.indexMap)
         elif method == 'backfill':
-            indexer = lib.backfill(self_index, target_index, self_index.indexMap,
-                                   target.indexMap)
+            indexer = lib.backfill_object(self_index, target_index,
+                                          self_index.indexMap, target.indexMap)
         else:
-            indexer = lib.merge_indexer(target_index, self_index.indexMap)
+            indexer = lib.merge_indexer_object(target_index,
+                                               self_index.indexMap)
         return indexer
 
     def reindex(self, target, method=None):
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 3d4af1b4f..a1eff3066 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -650,7 +650,8 @@ class BlockManager(object):
         this, other = self._maybe_rename_join(other, lsuffix, rsuffix)
 
         other_axis = other.axes[axis]
-        indexer = lib.merge_indexer(on.astype(object), other_axis.indexMap)
+        indexer = lib.merge_indexer_object(on.astype(object),
+                                           other_axis.indexMap)
 
         # TODO: deal with length-0 case? or does it fall out?
         mask = indexer == -1
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 7c464635d..bc71a625e 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1239,8 +1239,8 @@ copy : boolean, default False
             if isinstance(arg, dict):
                 arg = Series(arg)
 
-            indexer = lib.merge_indexer(self.values.astype(object),
-                                        arg.index.indexMap)
+            indexer = lib.merge_indexer_object(self.values.astype(object),
+                                               arg.index.indexMap)
 
             new_values = common.take_1d(np.asarray(arg), indexer)
             return Series(new_values, index=self.index)
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index ed410f365..28d25a1e2 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -663,12 +663,12 @@ class HDFStore(object):
 
             # need a better algorithm
             tuple_index = long_index.get_tuple_index()
-            index_map = lib.map_indices_buf(tuple_index)
+            index_map = lib.map_indices_object(tuple_index)
 
             unique_tuples = lib.fast_unique(tuple_index)
             unique_tuples = _asarray_tuplesafe(unique_tuples)
 
-            indexer = lib.merge_indexer(unique_tuples, index_map)
+            indexer = lib.merge_indexer_object(unique_tuples, index_map)
 
             new_index = long_index.take(indexer)
             new_values = lp.values.take(indexer, axis=0)
diff --git a/pandas/src/common.pyx b/pandas/src/common.pyx
index 7864227e2..0d8a3db9d 100644
--- a/pandas/src/common.pyx
+++ b/pandas/src/common.pyx
@@ -80,76 +80,6 @@ PyDateTime_IMPORT
 # initialize numpy
 import_array()
 
-cpdef map_indices(ndarray index):
-    '''
-    Produce a dict mapping the values of the input array to their respective
-    locations.
-
-    Example:
-        array(['hi', 'there']) --> {'hi' : 0 , 'there' : 1}
-
-    Better to do this with Cython because of the enormous speed boost.
-    '''
-    cdef int i, length
-    cdef flatiter iter
-    cdef dict result
-    cdef object idx
-
-    result = {}
-
-    iter = <flatiter> PyArray_IterNew(index)
-    length = PyArray_SIZE(index)
-
-    for i from 0 <= i < length:
-        idx = PyArray_GETITEM(index, PyArray_ITER_DATA(iter))
-        result[idx] = i
-        PyArray_ITER_NEXT(iter)
-
-    return result
-
-@cython.wraparound(False)
-@cython.boundscheck(False)
-cpdef map_indices_buf(ndarray[object] index):
-    '''
-    Produce a dict mapping the values of the input array to their respective
-    locations.
-
-    Example:
-        array(['hi', 'there']) --> {'hi' : 0 , 'there' : 1}
-
-    Better to do this with Cython because of the enormous speed boost.
-    '''
-    cdef Py_ssize_t i, length
-    cdef dict result = {}
-
-    length = len(index)
-
-    for i from 0 <= i < length:
-        result[index[i]] = i
-
-    return result
-
-@cython.wraparound(False)
-@cython.boundscheck(False)
-cpdef map_indices_int64(ndarray[int64_t] index):
-    '''
-    Produce a dict mapping the values of the input array to their respective
-    locations.
-
-    Example:
-        array(['hi', 'there']) --> {'hi' : 0 , 'there' : 1}
-
-    Better to do this with Cython because of the enormous speed boost.
-    '''
-    cdef Py_ssize_t i, length
-    cdef dict result = {}
-
-    length = len(index)
-
-    for i from 0 <= i < length:
-        result[index[i]] = i
-
-    return result
 
 cpdef map_indices_list(list index):
     '''
@@ -171,6 +101,7 @@ cpdef map_indices_list(list index):
 
     return result
 
+
 from libc.stdlib cimport malloc, free
 
 cdef class MultiMap:
@@ -235,40 +166,3 @@ def isAllDates(ndarray[object, ndim=1] arr):
             return False
 
     return True
-
-def is_monotonic(ndarray[object] arr):
-    cdef:
-        Py_ssize_t i, n
-        object prev, cur
-
-    n = len(arr)
-
-    if n < 2:
-        return True
-
-    prev = arr[0]
-    for i from 1 <= i < n:
-        cur = arr[i]
-        if cur < prev:
-            return False
-        prev = cur
-    return True
-
-
-def is_monotonic_int64(ndarray[int64_t] arr):
-    cdef:
-        Py_ssize_t i, n
-        int64_t prev, cur
-
-    n = len(arr)
-
-    if n < 2:
-        return True
-
-    prev = arr[0]
-    for i from 1 <= i < n:
-        cur = arr[i]
-        if cur < prev:
-            return False
-        prev = cur
-    return True
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index bab605a09..cd1439eb3 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -106,6 +106,205 @@ def merge_indexer_%(name)s(ndarray[%(c_type)s] values, dict oldMap):
 
 """
 
+backfill_template = """@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_%(name)s(ndarray[%(c_type)s] oldIndex,
+                      ndarray[%(c_type)s] newIndex,
+                      dict oldMap, dict newMap):
+    '''
+    Backfilling logic for generating fill vector
+
+    Diagram of what's going on
+
+    Old      New    Fill vector    Mask
+             .        0               1
+             .        0               1
+             .        0               1
+    A        A        0               1
+             .        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+    B        B        1               1
+             .        2               1
+             .        2               1
+             .        2               1
+    C        C        2               1
+             .                        0
+             .                        0
+    D
+    '''
+    cdef int i, j, oldLength, newLength, curLoc
+    cdef ndarray[int32_t, ndim=1] fill_vec
+    cdef int newPos, oldPos
+    cdef %(c_type)s prevOld, curOld
+
+    oldLength = len(oldIndex)
+    newLength = len(newIndex)
+
+    fill_vec = np.empty(len(newIndex), dtype = np.int32)
+    fill_vec.fill(-1)
+
+    oldPos = oldLength - 1
+    newPos = newLength - 1
+
+    if newIndex[0] > oldIndex[oldLength - 1]:
+        return fill_vec
+
+    while newPos >= 0:
+        curOld = oldIndex[oldPos]
+
+        while newIndex[newPos] > curOld:
+            newPos -= 1
+            if newPos < 0:
+                break
+
+        curLoc = oldMap[curOld]
+
+        if oldPos == 0:
+            if newIndex[newPos] <= curOld:
+                fill_vec[:newPos + 1] = curLoc
+            break
+        else:
+            prevOld = oldIndex[oldPos - 1]
+
+            while newIndex[newPos] > prevOld:
+                fill_vec[newPos] = curLoc
+
+                newPos -= 1
+                if newPos < 0:
+                    break
+        oldPos -= 1
+
+    return fill_vec
+
+"""
+
+pad_template = """@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_%(name)s(ndarray[%(c_type)s] oldIndex,
+                 ndarray[%(c_type)s] newIndex,
+                 dict oldMap, dict newMap):
+    '''
+    Padding logic for generating fill vector
+
+    Diagram of what's going on
+
+    Old      New    Fill vector    Mask
+             .                        0
+             .                        0
+             .                        0
+    A        A        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+    B        B        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+    C        C        2               1
+    '''
+    cdef int i, j, oldLength, newLength, curLoc
+    cdef ndarray[int32_t, ndim=1] fill_vec
+    cdef int newPos, oldPos
+    cdef %(c_type)s prevOld, curOld
+
+    oldLength = len(oldIndex)
+    newLength = len(newIndex)
+
+    fill_vec = np.empty(len(newIndex), dtype = np.int32)
+    fill_vec.fill(-1)
+
+    oldPos = 0
+    newPos = 0
+
+    if newIndex[newLength - 1] < oldIndex[0]:
+        return fill_vec
+
+    while newPos < newLength:
+        curOld = oldIndex[oldPos]
+
+        while newIndex[newPos] < curOld:
+            newPos += 1
+            if newPos > newLength - 1:
+                break
+
+        curLoc = oldMap[curOld]
+
+        if oldPos == oldLength - 1:
+            if newIndex[newPos] >= curOld:
+                fill_vec[newPos:] = curLoc
+            break
+        else:
+            nextOld = oldIndex[oldPos + 1]
+            done = 0
+
+            while newIndex[newPos] < nextOld:
+                fill_vec[newPos] = curLoc
+                newPos += 1
+
+                if newPos > newLength - 1:
+                    done = 1
+                    break
+
+            if done:
+                break
+
+        oldPos += 1
+
+    return fill_vec
+
+"""
+
+is_monotonic_template = """@cython.boundscheck(False)
+@cython.wraparound(False)
+def is_monotonic_%(name)s(ndarray[%(c_type)s] arr):
+    cdef:
+        Py_ssize_t i, n
+        %(c_type)s prev, cur
+
+    n = len(arr)
+
+    if n < 2:
+        return True
+
+    prev = arr[0]
+    for i from 1 <= i < n:
+        cur = arr[i]
+        if cur < prev:
+            return False
+        prev = cur
+    return True
+
+"""
+
+map_indices_template = """@cython.wraparound(False)
+@cython.boundscheck(False)
+cpdef map_indices_%(name)s(ndarray[%(c_type)s] index):
+    '''
+    Produce a dict mapping the values of the input array to their respective
+    locations.
+
+    Example:
+        array(['hi', 'there']) --> {'hi' : 0 , 'there' : 1}
+
+    Better to do this with Cython because of the enormous speed boost.
+    '''
+    cdef Py_ssize_t i, length
+    cdef dict result = {}
+
+    length = len(index)
+
+    for i from 0 <= i < length:
+        result[index[i]] = i
+
+    return result
+
+"""
+
 # name, ctype, capable of holding NA
 function_list = [
     ('float64', 'float64_t', True),
@@ -129,10 +328,14 @@ def generate_from_template(template, ndim=1):
 
 def generate_take_cython_file(path='generated.pyx'):
     with open(path, 'w') as f:
+        print >> f, generate_from_template(map_indices_template)
         print >> f, generate_from_template(merge_indexer_template)
+        print >> f, generate_from_template(pad_template)
+        print >> f, generate_from_template(backfill_template)
         print >> f, generate_from_template(take_1d_template)
         print >> f, generate_from_template(take_2d_axis0_template, ndim=2)
         print >> f, generate_from_template(take_2d_axis1_template, ndim=2)
+        print >> f, generate_from_template(is_monotonic_template)
 
 if __name__ == '__main__':
     generate_take_cython_file()
diff --git a/pandas/src/generated.pyx b/pandas/src/generated.pyx
index bcc45f8cb..f35a11fc2 100644
--- a/pandas/src/generated.pyx
+++ b/pandas/src/generated.pyx
@@ -1,3 +1,952 @@
+@cython.wraparound(False)
+@cython.boundscheck(False)
+cpdef map_indices_float64(ndarray[float64_t] index):
+    '''
+    Produce a dict mapping the values of the input array to their respective
+    locations.
+
+    Example:
+        array(['hi', 'there']) --> {'hi' : 0 , 'there' : 1}
+
+    Better to do this with Cython because of the enormous speed boost.
+    '''
+    cdef Py_ssize_t i, length
+    cdef dict result = {}
+
+    length = len(index)
+
+    for i from 0 <= i < length:
+        result[index[i]] = i
+
+    return result
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+cpdef map_indices_object(ndarray[object] index):
+    '''
+    Produce a dict mapping the values of the input array to their respective
+    locations.
+
+    Example:
+        array(['hi', 'there']) --> {'hi' : 0 , 'there' : 1}
+
+    Better to do this with Cython because of the enormous speed boost.
+    '''
+    cdef Py_ssize_t i, length
+    cdef dict result = {}
+
+    length = len(index)
+
+    for i from 0 <= i < length:
+        result[index[i]] = i
+
+    return result
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+cpdef map_indices_int32(ndarray[int32_t] index):
+    '''
+    Produce a dict mapping the values of the input array to their respective
+    locations.
+
+    Example:
+        array(['hi', 'there']) --> {'hi' : 0 , 'there' : 1}
+
+    Better to do this with Cython because of the enormous speed boost.
+    '''
+    cdef Py_ssize_t i, length
+    cdef dict result = {}
+
+    length = len(index)
+
+    for i from 0 <= i < length:
+        result[index[i]] = i
+
+    return result
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+cpdef map_indices_int64(ndarray[int64_t] index):
+    '''
+    Produce a dict mapping the values of the input array to their respective
+    locations.
+
+    Example:
+        array(['hi', 'there']) --> {'hi' : 0 , 'there' : 1}
+
+    Better to do this with Cython because of the enormous speed boost.
+    '''
+    cdef Py_ssize_t i, length
+    cdef dict result = {}
+
+    length = len(index)
+
+    for i from 0 <= i < length:
+        result[index[i]] = i
+
+    return result
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+cpdef map_indices_bool(ndarray[uint8_t] index):
+    '''
+    Produce a dict mapping the values of the input array to their respective
+    locations.
+
+    Example:
+        array(['hi', 'there']) --> {'hi' : 0 , 'there' : 1}
+
+    Better to do this with Cython because of the enormous speed boost.
+    '''
+    cdef Py_ssize_t i, length
+    cdef dict result = {}
+
+    length = len(index)
+
+    for i from 0 <= i < length:
+        result[index[i]] = i
+
+    return result
+
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def merge_indexer_float64(ndarray[float64_t] values, dict oldMap):
+    cdef int i, j, length, newLength
+    cdef float64_t idx
+    cdef ndarray[int32_t] fill_vec
+
+    newLength = len(values)
+    fill_vec = np.empty(newLength, dtype=np.int32)
+    for i from 0 <= i < newLength:
+        idx = values[i]
+        if idx in oldMap:
+            fill_vec[i] = oldMap[idx]
+        else:
+            fill_vec[i] = -1
+
+    return fill_vec
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def merge_indexer_object(ndarray[object] values, dict oldMap):
+    cdef int i, j, length, newLength
+    cdef object idx
+    cdef ndarray[int32_t] fill_vec
+
+    newLength = len(values)
+    fill_vec = np.empty(newLength, dtype=np.int32)
+    for i from 0 <= i < newLength:
+        idx = values[i]
+        if idx in oldMap:
+            fill_vec[i] = oldMap[idx]
+        else:
+            fill_vec[i] = -1
+
+    return fill_vec
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def merge_indexer_int32(ndarray[int32_t] values, dict oldMap):
+    cdef int i, j, length, newLength
+    cdef int32_t idx
+    cdef ndarray[int32_t] fill_vec
+
+    newLength = len(values)
+    fill_vec = np.empty(newLength, dtype=np.int32)
+    for i from 0 <= i < newLength:
+        idx = values[i]
+        if idx in oldMap:
+            fill_vec[i] = oldMap[idx]
+        else:
+            fill_vec[i] = -1
+
+    return fill_vec
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def merge_indexer_int64(ndarray[int64_t] values, dict oldMap):
+    cdef int i, j, length, newLength
+    cdef int64_t idx
+    cdef ndarray[int32_t] fill_vec
+
+    newLength = len(values)
+    fill_vec = np.empty(newLength, dtype=np.int32)
+    for i from 0 <= i < newLength:
+        idx = values[i]
+        if idx in oldMap:
+            fill_vec[i] = oldMap[idx]
+        else:
+            fill_vec[i] = -1
+
+    return fill_vec
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def merge_indexer_bool(ndarray[uint8_t] values, dict oldMap):
+    cdef int i, j, length, newLength
+    cdef uint8_t idx
+    cdef ndarray[int32_t] fill_vec
+
+    newLength = len(values)
+    fill_vec = np.empty(newLength, dtype=np.int32)
+    for i from 0 <= i < newLength:
+        idx = values[i]
+        if idx in oldMap:
+            fill_vec[i] = oldMap[idx]
+        else:
+            fill_vec[i] = -1
+
+    return fill_vec
+
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_float64(ndarray[float64_t] oldIndex,
+                 ndarray[float64_t] newIndex,
+                 dict oldMap, dict newMap):
+    '''
+    Padding logic for generating fill vector
+
+    Diagram of what's going on
+
+    Old      New    Fill vector    Mask
+             .                        0
+             .                        0
+             .                        0
+    A        A        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+    B        B        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+    C        C        2               1
+    '''
+    cdef int i, j, oldLength, newLength, curLoc
+    cdef ndarray[int32_t, ndim=1] fill_vec
+    cdef int newPos, oldPos
+    cdef float64_t prevOld, curOld
+
+    oldLength = len(oldIndex)
+    newLength = len(newIndex)
+
+    fill_vec = np.empty(len(newIndex), dtype = np.int32)
+    fill_vec.fill(-1)
+
+    oldPos = 0
+    newPos = 0
+
+    if newIndex[newLength - 1] < oldIndex[0]:
+        return fill_vec
+
+    while newPos < newLength:
+        curOld = oldIndex[oldPos]
+
+        while newIndex[newPos] < curOld:
+            newPos += 1
+            if newPos > newLength - 1:
+                break
+
+        curLoc = oldMap[curOld]
+
+        if oldPos == oldLength - 1:
+            if newIndex[newPos] >= curOld:
+                fill_vec[newPos:] = curLoc
+            break
+        else:
+            nextOld = oldIndex[oldPos + 1]
+            done = 0
+
+            while newIndex[newPos] < nextOld:
+                fill_vec[newPos] = curLoc
+                newPos += 1
+
+                if newPos > newLength - 1:
+                    done = 1
+                    break
+
+            if done:
+                break
+
+        oldPos += 1
+
+    return fill_vec
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_object(ndarray[object] oldIndex,
+                 ndarray[object] newIndex,
+                 dict oldMap, dict newMap):
+    '''
+    Padding logic for generating fill vector
+
+    Diagram of what's going on
+
+    Old      New    Fill vector    Mask
+             .                        0
+             .                        0
+             .                        0
+    A        A        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+    B        B        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+    C        C        2               1
+    '''
+    cdef int i, j, oldLength, newLength, curLoc
+    cdef ndarray[int32_t, ndim=1] fill_vec
+    cdef int newPos, oldPos
+    cdef object prevOld, curOld
+
+    oldLength = len(oldIndex)
+    newLength = len(newIndex)
+
+    fill_vec = np.empty(len(newIndex), dtype = np.int32)
+    fill_vec.fill(-1)
+
+    oldPos = 0
+    newPos = 0
+
+    if newIndex[newLength - 1] < oldIndex[0]:
+        return fill_vec
+
+    while newPos < newLength:
+        curOld = oldIndex[oldPos]
+
+        while newIndex[newPos] < curOld:
+            newPos += 1
+            if newPos > newLength - 1:
+                break
+
+        curLoc = oldMap[curOld]
+
+        if oldPos == oldLength - 1:
+            if newIndex[newPos] >= curOld:
+                fill_vec[newPos:] = curLoc
+            break
+        else:
+            nextOld = oldIndex[oldPos + 1]
+            done = 0
+
+            while newIndex[newPos] < nextOld:
+                fill_vec[newPos] = curLoc
+                newPos += 1
+
+                if newPos > newLength - 1:
+                    done = 1
+                    break
+
+            if done:
+                break
+
+        oldPos += 1
+
+    return fill_vec
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_int32(ndarray[int32_t] oldIndex,
+                 ndarray[int32_t] newIndex,
+                 dict oldMap, dict newMap):
+    '''
+    Padding logic for generating fill vector
+
+    Diagram of what's going on
+
+    Old      New    Fill vector    Mask
+             .                        0
+             .                        0
+             .                        0
+    A        A        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+    B        B        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+    C        C        2               1
+    '''
+    cdef int i, j, oldLength, newLength, curLoc
+    cdef ndarray[int32_t, ndim=1] fill_vec
+    cdef int newPos, oldPos
+    cdef int32_t prevOld, curOld
+
+    oldLength = len(oldIndex)
+    newLength = len(newIndex)
+
+    fill_vec = np.empty(len(newIndex), dtype = np.int32)
+    fill_vec.fill(-1)
+
+    oldPos = 0
+    newPos = 0
+
+    if newIndex[newLength - 1] < oldIndex[0]:
+        return fill_vec
+
+    while newPos < newLength:
+        curOld = oldIndex[oldPos]
+
+        while newIndex[newPos] < curOld:
+            newPos += 1
+            if newPos > newLength - 1:
+                break
+
+        curLoc = oldMap[curOld]
+
+        if oldPos == oldLength - 1:
+            if newIndex[newPos] >= curOld:
+                fill_vec[newPos:] = curLoc
+            break
+        else:
+            nextOld = oldIndex[oldPos + 1]
+            done = 0
+
+            while newIndex[newPos] < nextOld:
+                fill_vec[newPos] = curLoc
+                newPos += 1
+
+                if newPos > newLength - 1:
+                    done = 1
+                    break
+
+            if done:
+                break
+
+        oldPos += 1
+
+    return fill_vec
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_int64(ndarray[int64_t] oldIndex,
+                 ndarray[int64_t] newIndex,
+                 dict oldMap, dict newMap):
+    '''
+    Padding logic for generating fill vector
+
+    Diagram of what's going on
+
+    Old      New    Fill vector    Mask
+             .                        0
+             .                        0
+             .                        0
+    A        A        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+    B        B        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+    C        C        2               1
+    '''
+    cdef int i, j, oldLength, newLength, curLoc
+    cdef ndarray[int32_t, ndim=1] fill_vec
+    cdef int newPos, oldPos
+    cdef int64_t prevOld, curOld
+
+    oldLength = len(oldIndex)
+    newLength = len(newIndex)
+
+    fill_vec = np.empty(len(newIndex), dtype = np.int32)
+    fill_vec.fill(-1)
+
+    oldPos = 0
+    newPos = 0
+
+    if newIndex[newLength - 1] < oldIndex[0]:
+        return fill_vec
+
+    while newPos < newLength:
+        curOld = oldIndex[oldPos]
+
+        while newIndex[newPos] < curOld:
+            newPos += 1
+            if newPos > newLength - 1:
+                break
+
+        curLoc = oldMap[curOld]
+
+        if oldPos == oldLength - 1:
+            if newIndex[newPos] >= curOld:
+                fill_vec[newPos:] = curLoc
+            break
+        else:
+            nextOld = oldIndex[oldPos + 1]
+            done = 0
+
+            while newIndex[newPos] < nextOld:
+                fill_vec[newPos] = curLoc
+                newPos += 1
+
+                if newPos > newLength - 1:
+                    done = 1
+                    break
+
+            if done:
+                break
+
+        oldPos += 1
+
+    return fill_vec
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_bool(ndarray[uint8_t] oldIndex,
+                 ndarray[uint8_t] newIndex,
+                 dict oldMap, dict newMap):
+    '''
+    Padding logic for generating fill vector
+
+    Diagram of what's going on
+
+    Old      New    Fill vector    Mask
+             .                        0
+             .                        0
+             .                        0
+    A        A        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+             .        0               1
+    B        B        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+    C        C        2               1
+    '''
+    cdef int i, j, oldLength, newLength, curLoc
+    cdef ndarray[int32_t, ndim=1] fill_vec
+    cdef int newPos, oldPos
+    cdef uint8_t prevOld, curOld
+
+    oldLength = len(oldIndex)
+    newLength = len(newIndex)
+
+    fill_vec = np.empty(len(newIndex), dtype = np.int32)
+    fill_vec.fill(-1)
+
+    oldPos = 0
+    newPos = 0
+
+    if newIndex[newLength - 1] < oldIndex[0]:
+        return fill_vec
+
+    while newPos < newLength:
+        curOld = oldIndex[oldPos]
+
+        while newIndex[newPos] < curOld:
+            newPos += 1
+            if newPos > newLength - 1:
+                break
+
+        curLoc = oldMap[curOld]
+
+        if oldPos == oldLength - 1:
+            if newIndex[newPos] >= curOld:
+                fill_vec[newPos:] = curLoc
+            break
+        else:
+            nextOld = oldIndex[oldPos + 1]
+            done = 0
+
+            while newIndex[newPos] < nextOld:
+                fill_vec[newPos] = curLoc
+                newPos += 1
+
+                if newPos > newLength - 1:
+                    done = 1
+                    break
+
+            if done:
+                break
+
+        oldPos += 1
+
+    return fill_vec
+
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_float64(ndarray[float64_t] oldIndex,
+                      ndarray[float64_t] newIndex,
+                      dict oldMap, dict newMap):
+    '''
+    Backfilling logic for generating fill vector
+
+    Diagram of what's going on
+
+    Old      New    Fill vector    Mask
+             .        0               1
+             .        0               1
+             .        0               1
+    A        A        0               1
+             .        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+    B        B        1               1
+             .        2               1
+             .        2               1
+             .        2               1
+    C        C        2               1
+             .                        0
+             .                        0
+    D
+    '''
+    cdef int i, j, oldLength, newLength, curLoc
+    cdef ndarray[int32_t, ndim=1] fill_vec
+    cdef int newPos, oldPos
+    cdef float64_t prevOld, curOld
+
+    oldLength = len(oldIndex)
+    newLength = len(newIndex)
+
+    fill_vec = np.empty(len(newIndex), dtype = np.int32)
+    fill_vec.fill(-1)
+
+    oldPos = oldLength - 1
+    newPos = newLength - 1
+
+    if newIndex[0] > oldIndex[oldLength - 1]:
+        return fill_vec
+
+    while newPos >= 0:
+        curOld = oldIndex[oldPos]
+
+        while newIndex[newPos] > curOld:
+            newPos -= 1
+            if newPos < 0:
+                break
+
+        curLoc = oldMap[curOld]
+
+        if oldPos == 0:
+            if newIndex[newPos] <= curOld:
+                fill_vec[:newPos + 1] = curLoc
+            break
+        else:
+            prevOld = oldIndex[oldPos - 1]
+
+            while newIndex[newPos] > prevOld:
+                fill_vec[newPos] = curLoc
+
+                newPos -= 1
+                if newPos < 0:
+                    break
+        oldPos -= 1
+
+    return fill_vec
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_object(ndarray[object] oldIndex,
+                      ndarray[object] newIndex,
+                      dict oldMap, dict newMap):
+    '''
+    Backfilling logic for generating fill vector
+
+    Diagram of what's going on
+
+    Old      New    Fill vector    Mask
+             .        0               1
+             .        0               1
+             .        0               1
+    A        A        0               1
+             .        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+    B        B        1               1
+             .        2               1
+             .        2               1
+             .        2               1
+    C        C        2               1
+             .                        0
+             .                        0
+    D
+    '''
+    cdef int i, j, oldLength, newLength, curLoc
+    cdef ndarray[int32_t, ndim=1] fill_vec
+    cdef int newPos, oldPos
+    cdef object prevOld, curOld
+
+    oldLength = len(oldIndex)
+    newLength = len(newIndex)
+
+    fill_vec = np.empty(len(newIndex), dtype = np.int32)
+    fill_vec.fill(-1)
+
+    oldPos = oldLength - 1
+    newPos = newLength - 1
+
+    if newIndex[0] > oldIndex[oldLength - 1]:
+        return fill_vec
+
+    while newPos >= 0:
+        curOld = oldIndex[oldPos]
+
+        while newIndex[newPos] > curOld:
+            newPos -= 1
+            if newPos < 0:
+                break
+
+        curLoc = oldMap[curOld]
+
+        if oldPos == 0:
+            if newIndex[newPos] <= curOld:
+                fill_vec[:newPos + 1] = curLoc
+            break
+        else:
+            prevOld = oldIndex[oldPos - 1]
+
+            while newIndex[newPos] > prevOld:
+                fill_vec[newPos] = curLoc
+
+                newPos -= 1
+                if newPos < 0:
+                    break
+        oldPos -= 1
+
+    return fill_vec
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_int32(ndarray[int32_t] oldIndex,
+                      ndarray[int32_t] newIndex,
+                      dict oldMap, dict newMap):
+    '''
+    Backfilling logic for generating fill vector
+
+    Diagram of what's going on
+
+    Old      New    Fill vector    Mask
+             .        0               1
+             .        0               1
+             .        0               1
+    A        A        0               1
+             .        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+    B        B        1               1
+             .        2               1
+             .        2               1
+             .        2               1
+    C        C        2               1
+             .                        0
+             .                        0
+    D
+    '''
+    cdef int i, j, oldLength, newLength, curLoc
+    cdef ndarray[int32_t, ndim=1] fill_vec
+    cdef int newPos, oldPos
+    cdef int32_t prevOld, curOld
+
+    oldLength = len(oldIndex)
+    newLength = len(newIndex)
+
+    fill_vec = np.empty(len(newIndex), dtype = np.int32)
+    fill_vec.fill(-1)
+
+    oldPos = oldLength - 1
+    newPos = newLength - 1
+
+    if newIndex[0] > oldIndex[oldLength - 1]:
+        return fill_vec
+
+    while newPos >= 0:
+        curOld = oldIndex[oldPos]
+
+        while newIndex[newPos] > curOld:
+            newPos -= 1
+            if newPos < 0:
+                break
+
+        curLoc = oldMap[curOld]
+
+        if oldPos == 0:
+            if newIndex[newPos] <= curOld:
+                fill_vec[:newPos + 1] = curLoc
+            break
+        else:
+            prevOld = oldIndex[oldPos - 1]
+
+            while newIndex[newPos] > prevOld:
+                fill_vec[newPos] = curLoc
+
+                newPos -= 1
+                if newPos < 0:
+                    break
+        oldPos -= 1
+
+    return fill_vec
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_int64(ndarray[int64_t] oldIndex,
+                      ndarray[int64_t] newIndex,
+                      dict oldMap, dict newMap):
+    '''
+    Backfilling logic for generating fill vector
+
+    Diagram of what's going on
+
+    Old      New    Fill vector    Mask
+             .        0               1
+             .        0               1
+             .        0               1
+    A        A        0               1
+             .        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+    B        B        1               1
+             .        2               1
+             .        2               1
+             .        2               1
+    C        C        2               1
+             .                        0
+             .                        0
+    D
+    '''
+    cdef int i, j, oldLength, newLength, curLoc
+    cdef ndarray[int32_t, ndim=1] fill_vec
+    cdef int newPos, oldPos
+    cdef int64_t prevOld, curOld
+
+    oldLength = len(oldIndex)
+    newLength = len(newIndex)
+
+    fill_vec = np.empty(len(newIndex), dtype = np.int32)
+    fill_vec.fill(-1)
+
+    oldPos = oldLength - 1
+    newPos = newLength - 1
+
+    if newIndex[0] > oldIndex[oldLength - 1]:
+        return fill_vec
+
+    while newPos >= 0:
+        curOld = oldIndex[oldPos]
+
+        while newIndex[newPos] > curOld:
+            newPos -= 1
+            if newPos < 0:
+                break
+
+        curLoc = oldMap[curOld]
+
+        if oldPos == 0:
+            if newIndex[newPos] <= curOld:
+                fill_vec[:newPos + 1] = curLoc
+            break
+        else:
+            prevOld = oldIndex[oldPos - 1]
+
+            while newIndex[newPos] > prevOld:
+                fill_vec[newPos] = curLoc
+
+                newPos -= 1
+                if newPos < 0:
+                    break
+        oldPos -= 1
+
+    return fill_vec
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_bool(ndarray[uint8_t] oldIndex,
+                      ndarray[uint8_t] newIndex,
+                      dict oldMap, dict newMap):
+    '''
+    Backfilling logic for generating fill vector
+
+    Diagram of what's going on
+
+    Old      New    Fill vector    Mask
+             .        0               1
+             .        0               1
+             .        0               1
+    A        A        0               1
+             .        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+             .        1               1
+    B        B        1               1
+             .        2               1
+             .        2               1
+             .        2               1
+    C        C        2               1
+             .                        0
+             .                        0
+    D
+    '''
+    cdef int i, j, oldLength, newLength, curLoc
+    cdef ndarray[int32_t, ndim=1] fill_vec
+    cdef int newPos, oldPos
+    cdef uint8_t prevOld, curOld
+
+    oldLength = len(oldIndex)
+    newLength = len(newIndex)
+
+    fill_vec = np.empty(len(newIndex), dtype = np.int32)
+    fill_vec.fill(-1)
+
+    oldPos = oldLength - 1
+    newPos = newLength - 1
+
+    if newIndex[0] > oldIndex[oldLength - 1]:
+        return fill_vec
+
+    while newPos >= 0:
+        curOld = oldIndex[oldPos]
+
+        while newIndex[newPos] > curOld:
+            newPos -= 1
+            if newPos < 0:
+                break
+
+        curLoc = oldMap[curOld]
+
+        if oldPos == 0:
+            if newIndex[newPos] <= curOld:
+                fill_vec[:newPos + 1] = curLoc
+            break
+        else:
+            prevOld = oldIndex[oldPos - 1]
+
+            while newIndex[newPos] > prevOld:
+                fill_vec[newPos] = curLoc
+
+                newPos -= 1
+                if newPos < 0:
+                    break
+        oldPos -= 1
+
+    return fill_vec
+
+
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_1d_float64(ndarray[float64_t] values, ndarray[int32_t] indexer,
@@ -381,3 +1330,104 @@ def take_2d_axis1_bool(ndarray[uint8_t, ndim=2] values,
                 outbuf[i, j] = values[i, idx]
 
 
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def is_monotonic_float64(ndarray[float64_t] arr):
+    cdef:
+        Py_ssize_t i, n
+        float64_t prev, cur
+
+    n = len(arr)
+
+    if n < 2:
+        return True
+
+    prev = arr[0]
+    for i from 1 <= i < n:
+        cur = arr[i]
+        if cur < prev:
+            return False
+        prev = cur
+    return True
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def is_monotonic_object(ndarray[object] arr):
+    cdef:
+        Py_ssize_t i, n
+        object prev, cur
+
+    n = len(arr)
+
+    if n < 2:
+        return True
+
+    prev = arr[0]
+    for i from 1 <= i < n:
+        cur = arr[i]
+        if cur < prev:
+            return False
+        prev = cur
+    return True
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def is_monotonic_int32(ndarray[int32_t] arr):
+    cdef:
+        Py_ssize_t i, n
+        int32_t prev, cur
+
+    n = len(arr)
+
+    if n < 2:
+        return True
+
+    prev = arr[0]
+    for i from 1 <= i < n:
+        cur = arr[i]
+        if cur < prev:
+            return False
+        prev = cur
+    return True
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def is_monotonic_int64(ndarray[int64_t] arr):
+    cdef:
+        Py_ssize_t i, n
+        int64_t prev, cur
+
+    n = len(arr)
+
+    if n < 2:
+        return True
+
+    prev = arr[0]
+    for i from 1 <= i < n:
+        cur = arr[i]
+        if cur < prev:
+            return False
+        prev = cur
+    return True
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def is_monotonic_bool(ndarray[uint8_t] arr):
+    cdef:
+        Py_ssize_t i, n
+        uint8_t prev, cur
+
+    n = len(arr)
+
+    if n < 2:
+        return True
+
+    prev = arr[0]
+    for i from 1 <= i < n:
+        cur = arr[i]
+        if cur < prev:
+            return False
+        prev = cur
+    return True
+
+
diff --git a/pandas/src/isnull.pyx b/pandas/src/isnull.pyx
index b69b30562..725952b81 100644
--- a/pandas/src/isnull.pyx
+++ b/pandas/src/isnull.pyx
@@ -32,3 +32,4 @@ def isnullobj(ndarray input):
         PyArray_ITER_NEXT(iter)
 
     return result
+
diff --git a/pandas/src/reindex.pyx b/pandas/src/reindex.pyx
index fa3c17412..e1d7f550c 100644
--- a/pandas/src/reindex.pyx
+++ b/pandas/src/reindex.pyx
@@ -1,150 +1,3 @@
-@cython.boundscheck(False)
-@cython.wraparound(False)
-def backfill(ndarray[object] oldIndex, ndarray[object] newIndex,
-             dict oldMap, dict newMap):
-    '''
-    Backfilling logic for generating fill vector
-
-    Diagram of what's going on
-
-    Old      New    Fill vector    Mask
-             .        0               1
-             .        0               1
-             .        0               1
-    A        A        0               1
-             .        1               1
-             .        1               1
-             .        1               1
-             .        1               1
-             .        1               1
-    B        B        1               1
-             .        2               1
-             .        2               1
-             .        2               1
-    C        C        2               1
-             .                        0
-             .                        0
-    D
-    '''
-    cdef int i, j, oldLength, newLength, curLoc
-    cdef ndarray[int32_t, ndim=1] fill_vec
-    cdef int newPos, oldPos
-    cdef object prevOld, curOld
-
-    oldLength = len(oldIndex)
-    newLength = len(newIndex)
-
-    fill_vec = np.empty(len(newIndex), dtype = np.int32)
-    fill_vec.fill(-1)
-
-    oldPos = oldLength - 1
-    newPos = newLength - 1
-
-    if newIndex[0] > oldIndex[oldLength - 1]:
-        return fill_vec
-
-    while newPos >= 0:
-        curOld = oldIndex[oldPos]
-
-        while newIndex[newPos] > curOld:
-            newPos -= 1
-            if newPos < 0:
-                break
-
-        curLoc = oldMap[curOld]
-
-        if oldPos == 0:
-            if newIndex[newPos] <= curOld:
-                fill_vec[:newPos + 1] = curLoc
-            break
-        else:
-            prevOld = oldIndex[oldPos - 1]
-
-            while newIndex[newPos] > prevOld:
-                fill_vec[newPos] = curLoc
-
-                newPos -= 1
-                if newPos < 0:
-                    break
-        oldPos -= 1
-
-    return fill_vec
-
-@cython.boundscheck(False)
-@cython.wraparound(False)
-def pad(ndarray[object] oldIndex, ndarray[object] newIndex,
-        dict oldMap, dict newMap):
-    '''
-    Padding logic for generating fill vector
-
-    Diagram of what's going on
-
-    Old      New    Fill vector    Mask
-             .                        0
-             .                        0
-             .                        0
-    A        A        0               1
-             .        0               1
-             .        0               1
-             .        0               1
-             .        0               1
-             .        0               1
-    B        B        1               1
-             .        1               1
-             .        1               1
-             .        1               1
-    C        C        2               1
-    '''
-    cdef int i, j, oldLength, newLength, curLoc
-    cdef ndarray[int32_t, ndim=1] fill_vec
-    cdef int newPos, oldPos
-    cdef object prevOld, curOld
-
-    oldLength = len(oldIndex)
-    newLength = len(newIndex)
-
-    fill_vec = np.empty(len(newIndex), dtype = np.int32)
-    fill_vec.fill(-1)
-
-    oldPos = 0
-    newPos = 0
-
-    if newIndex[newLength - 1] < oldIndex[0]:
-        return fill_vec
-
-    while newPos < newLength:
-        curOld = oldIndex[oldPos]
-
-        while newIndex[newPos] < curOld:
-            newPos += 1
-            if newPos > newLength - 1:
-                break
-
-        curLoc = oldMap[curOld]
-
-        if oldPos == oldLength - 1:
-            if newIndex[newPos] >= curOld:
-                fill_vec[newPos:] = curLoc
-            break
-        else:
-            nextOld = oldIndex[oldPos + 1]
-            done = 0
-
-            while newIndex[newPos] < nextOld:
-                fill_vec[newPos] = curLoc
-                newPos += 1
-
-                if newPos > newLength - 1:
-                    done = 1
-                    break
-
-            if done:
-                break
-
-        oldPos += 1
-
-    return fill_vec
-
 def pad_inplace_float64(ndarray[float64_t] values,
                         ndarray[np.uint8_t, cast=True] mask):
     '''
@@ -232,44 +85,6 @@ def backfill_inplace_float64(ndarray[float64_t] values,
             val = values[i]
         i -= 1
 
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def merge_indexer(ndarray[object] values, dict oldMap):
-    cdef int i, j, length, newLength
-    cdef object idx
-    cdef ndarray[int32_t] fill_vec
-
-    newLength = len(values)
-    fill_vec = np.empty(newLength, dtype=np.int32)
-    mask = np.zeros(newLength, dtype=np.int8)
-    for i from 0 <= i < newLength:
-        idx = values[i]
-        if idx in oldMap:
-            fill_vec[i] = oldMap[idx]
-        else:
-            fill_vec[i] = -1
-
-    return fill_vec
-
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def merge_indexer_int64(ndarray[int64_t] values, dict oldMap):
-    cdef int i, j, length, newLength
-    cdef int64_t idx
-    cdef ndarray[int32_t] fill_vec
-
-    newLength = len(values)
-    fill_vec = np.empty(newLength, dtype=np.int32)
-    mask = np.zeros(newLength, dtype=np.int8)
-    for i from 0 <= i < newLength:
-        idx = values[i]
-        if idx in oldMap:
-            fill_vec[i] = oldMap[idx]
-        else:
-            fill_vec[i] = -1
-
-    return fill_vec
-
 def ordered_left_join(ndarray[object] left, ndarray[object] right):
     # cdef dict right_map = map_indices_buf(right)
     # return merge_indexer(left, right_map)
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index bddc46026..42e338688 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -112,12 +112,12 @@ class TestIndex(unittest.TestCase):
         boolIdx[5:30:2] = False
 
         subIndex = self.strIndex[boolIdx]
-        tm.assert_dict_equal(tseries.map_indices(subIndex),
-                                 subIndex.indexMap)
+        tm.assert_dict_equal(tseries.map_indices_object(subIndex),
+                             subIndex.indexMap)
 
         subIndex = self.strIndex[list(boolIdx)]
-        tm.assert_dict_equal(tseries.map_indices(subIndex),
-                                 subIndex.indexMap)
+        tm.assert_dict_equal(tseries.map_indices_object(subIndex),
+                             subIndex.indexMap)
 
     def test_fancy(self):
         sl = self.strIndex[[1,2,3]]
diff --git a/pandas/tests/test_tseries.py b/pandas/tests/test_tseries.py
index ff6cabd28..1c6093046 100644
--- a/pandas/tests/test_tseries.py
+++ b/pandas/tests/test_tseries.py
@@ -27,7 +27,7 @@ class TestTseriesUtil(unittest.TestCase):
         old = Index([1, 5, 10])
         new = Index(range(12))
 
-        filler = lib.merge_indexer(new, old.indexMap)
+        filler = lib.merge_indexer_object(new, old.indexMap)
 
         expect_filler = [-1, 0, -1, -1, -1, 1, -1, -1, -1, -1, 2, -1]
         self.assert_(np.array_equal(filler, expect_filler))
@@ -35,7 +35,7 @@ class TestTseriesUtil(unittest.TestCase):
         # corner case
         old = Index([1, 4])
         new = Index(range(5, 10))
-        filler = lib.merge_indexer(new, old.indexMap)
+        filler = lib.merge_indexer_object(new, old.indexMap)
         expect_filler = [-1, -1, -1, -1, -1]
         self.assert_(np.array_equal(filler, expect_filler))
 
@@ -43,7 +43,7 @@ class TestTseriesUtil(unittest.TestCase):
         old = Index([1, 5, 10])
         new = Index(range(12))
 
-        filler = lib.backfill(old, new, old.indexMap, new.indexMap)
+        filler = lib.backfill_object(old, new, old.indexMap, new.indexMap)
 
         expect_filler = [0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, -1]
         self.assert_(np.array_equal(filler, expect_filler))
@@ -51,7 +51,7 @@ class TestTseriesUtil(unittest.TestCase):
         # corner case
         old = Index([1, 4])
         new = Index(range(5, 10))
-        filler = lib.backfill(old, new, old.indexMap, new.indexMap)
+        filler = lib.backfill_object(old, new, old.indexMap, new.indexMap)
 
         expect_filler = [-1, -1, -1, -1, -1]
         self.assert_(np.array_equal(filler, expect_filler))
@@ -60,7 +60,7 @@ class TestTseriesUtil(unittest.TestCase):
         old = Index([1, 5, 10])
         new = Index(range(12))
 
-        filler = lib.pad(old, new, old.indexMap, new.indexMap)
+        filler = lib.pad_object(old, new, old.indexMap, new.indexMap)
 
         expect_filler = [-1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2]
         self.assert_(np.array_equal(filler, expect_filler))
@@ -68,7 +68,7 @@ class TestTseriesUtil(unittest.TestCase):
         # corner case
         old = Index([5, 10])
         new = Index(range(5))
-        filler = lib.pad(old, new, old.indexMap, new.indexMap)
+        filler = lib.pad_object(old, new, old.indexMap, new.indexMap)
         expect_filler = [-1, -1, -1, -1, -1]
         self.assert_(np.array_equal(filler, expect_filler))
 
diff --git a/scripts/bench_join.R b/scripts/bench_join.R
index 1d7db1f9e..edba277f0 100644
--- a/scripts/bench_join.R
+++ b/scripts/bench_join.R
@@ -47,3 +47,4 @@ for (i in 1:10) {
   gc()
   timing[i] = system.time(mat[indexer,])[3]
 }
+
diff --git a/scripts/preepoch_test.py b/scripts/preepoch_test.py
new file mode 100644
index 000000000..b65f09c81
--- /dev/null
+++ b/scripts/preepoch_test.py
@@ -0,0 +1,22 @@
+import numpy as np
+from pandas import *
+
+def panda_test():
+
+    # generate some data
+    data = np.random.rand(50,5)
+    # generate some dates
+    dates = DateRange('1/1/1969',periods=50)
+    # generate column headings
+    cols = ['A','B','C','D','E']
+
+    df = DataFrame(data,index=dates,columns=cols)
+
+    # save to HDF5Store
+    store = HDFStore('bugzilla.h5', mode='w')
+    store['df'] = df # This gives: OverflowError: mktime argument out of range
+    store.close()
+
+
+if __name__ == '__main__':
+    panda_test()

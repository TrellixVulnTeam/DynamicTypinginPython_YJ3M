commit f0ab1c565981c232b4a506c2eae75b5dbf944f7f
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon Apr 6 11:05:22 2020 -0700

    REF: rename _data->_mgr (#33054)

diff --git a/pandas/_libs/properties.pyx b/pandas/_libs/properties.pyx
index 0e04c5417..9b936eed7 100644
--- a/pandas/_libs/properties.pyx
+++ b/pandas/_libs/properties.pyx
@@ -56,10 +56,10 @@ cdef class AxisProperty:
             list axes
 
         if obj is None:
-            # Only instances have _data, not classes
+            # Only instances have _mgr, not classes
             return self
         else:
-            axes = obj._data.axes
+            axes = obj._mgr.axes
         return axes[self.axis]
 
     def __set__(self, obj, value):
diff --git a/pandas/_libs/reduction.pyx b/pandas/_libs/reduction.pyx
index 4a9c89848..a7b2d5d54 100644
--- a/pandas/_libs/reduction.pyx
+++ b/pandas/_libs/reduction.pyx
@@ -127,7 +127,7 @@ cdef class Reducer:
                     name = labels[i]
 
                     object.__setattr__(
-                        cached_typ._data._block, 'values', chunk)
+                        cached_typ._mgr._block, 'values', chunk)
                     object.__setattr__(cached_typ, 'name', name)
                     res = self.f(cached_typ)
                 else:
@@ -180,8 +180,8 @@ cdef class _BaseGrouper:
             # to a 1-d ndarray like datetime / timedelta / period.
             object.__setattr__(cached_ityp, '_index_data', islider.buf)
             cached_ityp._engine.clear_mapping()
-            object.__setattr__(cached_typ._data._block, 'values', vslider.buf)
-            object.__setattr__(cached_typ._data._block, 'mgr_locs',
+            object.__setattr__(cached_typ._mgr._block, 'values', vslider.buf)
+            object.__setattr__(cached_typ._mgr._block, 'mgr_locs',
                                slice(len(vslider.buf)))
             object.__setattr__(cached_typ, '_index', cached_ityp)
             object.__setattr__(cached_typ, 'name', self.name)
@@ -551,7 +551,7 @@ cdef class BlockSlider:
         self.dummy = frame[:0]
         self.index = self.dummy.index
 
-        self.blocks = [b.values for b in self.dummy._data.blocks]
+        self.blocks = [b.values for b in self.dummy._mgr.blocks]
 
         for x in self.blocks:
             util.set_array_not_contiguous(x)
diff --git a/pandas/_libs/src/ujson/python/objToJSON.c b/pandas/_libs/src/ujson/python/objToJSON.c
index 965d6aec2..0eae7a36a 100644
--- a/pandas/_libs/src/ujson/python/objToJSON.c
+++ b/pandas/_libs/src/ujson/python/objToJSON.c
@@ -279,7 +279,7 @@ static PyObject *get_sub_attr(PyObject *obj, char *attr, char *subAttr) {
 }
 
 static int is_simple_frame(PyObject *obj) {
-    PyObject *check = get_sub_attr(obj, "_data", "is_mixed_type");
+    PyObject *check = get_sub_attr(obj, "_mgr", "is_mixed_type");
     int ret = (check == Py_False);
 
     if (!check) {
@@ -760,7 +760,7 @@ void PdBlock_iterBegin(JSOBJ _obj, JSONTypeContext *tc) {
         goto BLKRET;
     }
 
-    blocks = get_sub_attr(obj, "_data", "blocks");
+    blocks = get_sub_attr(obj, "_mgr", "blocks");
     if (!blocks) {
         GET_TC(tc)->iterNext = NpyArr_iterNextNone;
         goto BLKRET;
diff --git a/pandas/core/algorithms.py b/pandas/core/algorithms.py
index d04fc6cb2..62a3808d3 100644
--- a/pandas/core/algorithms.py
+++ b/pandas/core/algorithms.py
@@ -1645,7 +1645,7 @@ def take_nd(
         if arr.flags.f_contiguous and axis == arr.ndim - 1:
             # minor tweak that can make an order-of-magnitude difference
             # for dataframes initialized directly from 2-d ndarrays
-            # (s.t. df.values is c-contiguous and df._data.blocks[0] is its
+            # (s.t. df.values is c-contiguous and df._mgr.blocks[0] is its
             # f-contiguous transpose)
             out = np.empty(out_shape, dtype=dtype, order="F")
         else:
diff --git a/pandas/core/apply.py b/pandas/core/apply.py
index ceb45bc71..a0351cb68 100644
--- a/pandas/core/apply.py
+++ b/pandas/core/apply.py
@@ -165,7 +165,7 @@ class FrameApply(metaclass=abc.ABCMeta):
         # ufunc
         elif isinstance(self.f, np.ufunc):
             with np.errstate(all="ignore"):
-                results = self.obj._data.apply("apply", func=self.f)
+                results = self.obj._mgr.apply("apply", func=self.f)
             return self.obj._constructor(
                 data=results, index=self.index, columns=self.columns, copy=False
             )
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index ddb7be405..67523facb 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -431,7 +431,7 @@ class DataFrame(NDFrame):
             dtype = self._validate_dtype(dtype)
 
         if isinstance(data, DataFrame):
-            data = data._data
+            data = data._mgr
 
         if isinstance(data, BlockManager):
             mgr = self._init_mgr(
@@ -590,10 +590,10 @@ class DataFrame(NDFrame):
         ...    "B": np.array([1, 2], dtype=np.int64)})._is_homogeneous_type
         False
         """
-        if self._data.any_extension_types:
-            return len({block.dtype for block in self._data.blocks}) == 1
+        if self._mgr.any_extension_types:
+            return len({block.dtype for block in self._mgr.blocks}) == 1
         else:
-            return not self._data.is_mixed_type
+            return not self._mgr.is_mixed_type
 
     # ----------------------------------------------------------------------
     # Rendering Methods
@@ -2537,7 +2537,7 @@ class DataFrame(NDFrame):
         """
         # irow
         if axis == 0:
-            new_values = self._data.fast_xs(i)
+            new_values = self._mgr.fast_xs(i)
 
             # if we are a copy, mark as such
             copy = isinstance(new_values, np.ndarray) and new_values.base is None
@@ -2554,7 +2554,7 @@ class DataFrame(NDFrame):
         else:
             label = self.columns[i]
 
-            values = self._data.iget(i)
+            values = self._mgr.iget(i)
             result = self._box_col_values(values, label)
 
             # this is a cached value, mark it so
@@ -2865,7 +2865,7 @@ class DataFrame(NDFrame):
                     "and a value that cannot be converted to a Series"
                 ) from err
 
-            self._data = self._data.reindex_axis(
+            self._mgr = self._mgr.reindex_axis(
                 value.index.copy(), axis=1, fill_value=np.nan
             )
 
@@ -3313,7 +3313,7 @@ class DataFrame(NDFrame):
         """
         self._ensure_valid_index(value)
         value = self._sanitize_column(column, value, broadcast=False)
-        self._data.insert(loc, column, value, allow_duplicates=allow_duplicates)
+        self._mgr.insert(loc, column, value, allow_duplicates=allow_duplicates)
 
     def assign(self, **kwargs) -> "DataFrame":
         r"""
@@ -3494,7 +3494,7 @@ class DataFrame(NDFrame):
     @property
     def _series(self):
         return {
-            item: Series(self._data.iget(idx), index=self.index, name=item)
+            item: Series(self._mgr.iget(idx), index=self.index, name=item)
             for idx, item in enumerate(self.columns)
         }
 
@@ -4403,7 +4403,7 @@ class DataFrame(NDFrame):
                     values_dtype = values.dtype
 
                     if issubclass(values_type, DatetimeLikeArray):
-                        values = values._data
+                        values = values._data  # TODO: can we de-kludge yet?
 
                     if mask.any():
                         values, _ = maybe_upcast_putmask(values, mask, np.nan)
@@ -4787,7 +4787,7 @@ class DataFrame(NDFrame):
                 k, kind=kind, ascending=ascending, na_position=na_position
             )
 
-        new_data = self._data.take(
+        new_data = self._mgr.take(
             indexer, axis=self._get_block_manager_axis(axis), verify=False
         )
 
@@ -4922,7 +4922,7 @@ class DataFrame(NDFrame):
             )
 
         baxis = self._get_block_manager_axis(axis)
-        new_data = self._data.take(indexer, axis=baxis, verify=False)
+        new_data = self._mgr.take(indexer, axis=baxis, verify=False)
 
         # reconstruct axis if needed
         new_data.axes[baxis] = new_data.axes[baxis]._sort_levels_monotonic()
@@ -6661,7 +6661,7 @@ Wild         185.0
         5  NaN  NaN   NaN
         """
         bm_axis = self._get_block_manager_axis(axis)
-        new_data = self._data.diff(n=periods, axis=bm_axis)
+        new_data = self._mgr.diff(n=periods, axis=bm_axis)
         return self._constructor(new_data)
 
     # ----------------------------------------------------------------------
@@ -7855,7 +7855,7 @@ Wild         185.0
         if len(frame._get_axis(axis)) == 0:
             result = Series(0, index=frame._get_agg_axis(axis))
         else:
-            if frame._is_mixed_type or frame._data.any_extension_types:
+            if frame._is_mixed_type or frame._mgr.any_extension_types:
                 # the or any_extension_types is really only hit for single-
                 # column frames with an extension array
                 result = notna(frame).sum(axis=axis)
@@ -7979,7 +7979,7 @@ Wild         185.0
 
             # After possibly _get_data and transposing, we are now in the
             #  simple case where we can use BlockManager._reduce
-            res = df._data.reduce(blk_func)
+            res = df._mgr.reduce(blk_func)
             assert isinstance(res, dict)
             if len(res):
                 assert len(res) == max(list(res.keys())) + 1, res.keys()
@@ -8421,7 +8421,7 @@ Wild         185.0
                 return self._constructor([], index=q, columns=cols)
             return self._constructor_sliced([], index=cols, name=q, dtype=np.float64)
 
-        result = data._data.quantile(
+        result = data._mgr.quantile(
             qs=q, axis=1, interpolation=interpolation, transposed=is_transposed
         )
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 82cc45ee1..fac4ca676 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -169,7 +169,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
     """
 
     _internal_names: List[str] = [
-        "_data",
+        "_mgr",
         "_cacher",
         "_item_cache",
         "_cache",
@@ -188,7 +188,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
     _deprecations: FrozenSet[str] = frozenset(["get_values"])
     _metadata: List[str] = []
     _is_copy = None
-    _data: BlockManager
+    _mgr: BlockManager
     _attrs: Dict[Optional[Hashable], Any]
     _typ: str
 
@@ -204,7 +204,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         # copy kwarg is retained for mypy compat, is not used
 
         object.__setattr__(self, "_is_copy", None)
-        object.__setattr__(self, "_data", data)
+        object.__setattr__(self, "_mgr", data)
         object.__setattr__(self, "_item_cache", {})
         if attrs is None:
             attrs = {}
@@ -291,6 +291,15 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         """
         raise NotImplementedError
 
+    # ----------------------------------------------------------------------
+    # Internals
+
+    @property
+    def _data(self):
+        # GH#33054 retained because some downstream packages uses this,
+        #  e.g. fastparquet
+        return self._mgr
+
     # ----------------------------------------------------------------------
     # Axis
     _AXIS_ALIASES = {"rows": 0}
@@ -483,7 +492,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         >>> df.ndim
         2
         """
-        return self._data.ndim
+        return self._mgr.ndim
 
     @property
     def size(self) -> int:
@@ -555,7 +564,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
 
     def _set_axis(self, axis: int, labels: Index) -> None:
         labels = ensure_index(labels)
-        self._data.set_axis(axis, labels)
+        self._mgr.set_axis(axis, labels)
         self._clear_item_cache()
 
     def swapaxes(self: FrameOrSeries, axis1, axis2, copy=True) -> FrameOrSeries:
@@ -1309,7 +1318,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         """
         if not isinstance(other, self._constructor):
             return False
-        return self._data.equals(other._data)
+        return self._mgr.equals(other._mgr)
 
     # -------------------------------------------------------------------------
     # Unary Methods
@@ -1347,7 +1356,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
             # inv fails with 0 len
             return self
 
-        new_data = self._data.apply(operator.invert)
+        new_data = self._mgr.apply(operator.invert)
         result = self._constructor(new_data).__finalize__(self)
         return result
 
@@ -1809,7 +1818,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
     def __getstate__(self) -> Dict[str, Any]:
         meta = {k: getattr(self, k, None) for k in self._metadata}
         return dict(
-            _data=self._data,
+            _mgr=self._mgr,
             _typ=self._typ,
             _metadata=self._metadata,
             attrs=self.attrs,
@@ -1819,8 +1828,11 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
     def __setstate__(self, state):
 
         if isinstance(state, BlockManager):
-            self._data = state
+            self._mgr = state
         elif isinstance(state, dict):
+            if "_data" in state and "_mgr" not in state:
+                # compat for older pickles
+                state["_mgr"] = state.pop("_data")
             typ = state.get("_typ")
             if typ is not None:
                 attrs = state.get("_attrs", {})
@@ -1828,7 +1840,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
 
                 # set in the order of internal names
                 # to avoid definitional recursion
-                # e.g. say fill_value needing _data to be
+                # e.g. say fill_value needing _mgr to be
                 # defined
                 meta = set(self._internal_names + self._metadata)
                 for k in list(meta):
@@ -3194,7 +3206,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         """
         The object has called back to us saying maybe it has changed.
         """
-        self._data.set(item, value)
+        self._mgr.set(item, value)
 
     @property
     def _is_cached(self) -> bool_t:
@@ -3236,7 +3248,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
                 try:
                     ref._maybe_cache_changed(cacher[0], self)
                 except AssertionError:
-                    # ref._data.setitem can raise
+                    # ref._mgr.setitem can raise
                     #  AssertionError because of shape mismatch
                     pass
 
@@ -3346,7 +3358,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
 
         self._consolidate_inplace()
 
-        new_data = self._data.take(
+        new_data = self._mgr.take(
             indices, axis=self._get_block_manager_axis(axis), verify=True
         )
         return self._constructor(new_data).__finalize__(self)
@@ -3507,7 +3519,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
                 # so just return them (GH 6394)
                 return self._values[loc]
 
-            new_values = self._data.fast_xs(loc)
+            new_values = self._mgr.fast_xs(loc)
 
             result = self._constructor_sliced(
                 new_values,
@@ -3535,7 +3547,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         cache = self._item_cache
         res = cache.get(item)
         if res is None:
-            values = self._data.get(item)
+            values = self._mgr.get(item)
             res = self._box_item_values(item, values)
             cache[item] = res
             res._set_as_cached(item, self)
@@ -3555,7 +3567,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         """
         assert isinstance(slobj, slice), type(slobj)
         axis = self._get_block_manager_axis(axis)
-        result = self._constructor(self._data.get_slice(slobj, axis=axis))
+        result = self._constructor(self._mgr.get_slice(slobj, axis=axis))
         result = result.__finalize__(self)
 
         # this could be a view
@@ -3565,11 +3577,11 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         return result
 
     def _iset_item(self, loc: int, value) -> None:
-        self._data.iset(loc, value)
+        self._mgr.iset(loc, value)
         self._clear_item_cache()
 
     def _set_item(self, key, value) -> None:
-        self._data.set(key, value)
+        self._mgr.set(key, value)
         self._clear_item_cache()
 
     def _set_is_copy(self, ref, copy: bool_t = True) -> None:
@@ -3701,7 +3713,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
             # If the above loop ran and didn't delete anything because
             # there was no match, this call should raise the appropriate
             # exception:
-            self._data.delete(key)
+            self._mgr.delete(key)
 
         # delete from the caches
         try:
@@ -3734,7 +3746,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
     @property
     def _is_view(self) -> bool_t:
         """Return boolean indicating if self is view of another array """
-        return self._data.is_view
+        return self._mgr.is_view
 
     def reindex_like(
         self: FrameOrSeries,
@@ -3952,7 +3964,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         # decision that we may revisit in the future.
         self._reset_cache()
         self._clear_item_cache()
-        self._data = result._data
+        self._mgr = result._mgr
         self._maybe_update_cacher(verify_is_copy=verify_is_copy)
 
     def add_prefix(self: FrameOrSeries, prefix: str) -> FrameOrSeries:
@@ -4466,7 +4478,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
     ) -> FrameOrSeries:
         """allow_dups indicates an internal call here """
         # reindex doing multiple operations on different axes if indicated
-        new_data = self._data
+        new_data = self._mgr
         for axis in sorted(reindexers.keys()):
             index, indexer = reindexers[axis]
             baxis = self._get_block_manager_axis(axis)
@@ -4488,7 +4500,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
                 copy=copy,
             )
 
-        if copy and new_data is self._data:
+        if copy and new_data is self._mgr:
             new_data = new_data.copy()
 
         return self._constructor(new_data).__finalize__(self)
@@ -5146,7 +5158,6 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         """
         # Note: obj.x will always call obj.__getattribute__('x') prior to
         # calling obj.__getattr__('x').
-
         if (
             name in self._internal_names_set
             or name in self._metadata
@@ -5216,12 +5227,12 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
 
     def _protect_consolidate(self, f):
         """
-        Consolidate _data -- if the blocks have changed, then clear the
+        Consolidate _mgr -- if the blocks have changed, then clear the
         cache
         """
-        blocks_before = len(self._data.blocks)
+        blocks_before = len(self._mgr.blocks)
         result = f()
-        if len(self._data.blocks) != blocks_before:
+        if len(self._mgr.blocks) != blocks_before:
             self._clear_item_cache()
         return result
 
@@ -5229,7 +5240,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         """Consolidate data in place and return None"""
 
         def f():
-            self._data = self._data.consolidate()
+            self._mgr = self._mgr.consolidate()
 
         self._protect_consolidate(f)
 
@@ -5251,18 +5262,18 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         if inplace:
             self._consolidate_inplace()
         else:
-            f = lambda: self._data.consolidate()
+            f = lambda: self._mgr.consolidate()
             cons_data = self._protect_consolidate(f)
             return self._constructor(cons_data).__finalize__(self)
 
     @property
     def _is_mixed_type(self) -> bool_t:
-        f = lambda: self._data.is_mixed_type
+        f = lambda: self._mgr.is_mixed_type
         return self._protect_consolidate(f)
 
     @property
     def _is_numeric_mixed_type(self) -> bool_t:
-        f = lambda: self._data.is_numeric_mixed_type
+        f = lambda: self._mgr.is_numeric_mixed_type
         return self._protect_consolidate(f)
 
     def _check_inplace_setting(self, value) -> bool_t:
@@ -5282,10 +5293,10 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         return True
 
     def _get_numeric_data(self):
-        return self._constructor(self._data.get_numeric_data()).__finalize__(self)
+        return self._constructor(self._mgr.get_numeric_data()).__finalize__(self)
 
     def _get_bool_data(self):
-        return self._constructor(self._data.get_bool_data()).__finalize__(self)
+        return self._constructor(self._mgr.get_bool_data()).__finalize__(self)
 
     # ----------------------------------------------------------------------
     # Internal Interface Methods
@@ -5365,7 +5376,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
                ['monkey', nan, None]], dtype=object)
         """
         self._consolidate_inplace()
-        return self._data.as_array(transpose=self._AXIS_REVERSED)
+        return self._mgr.as_array(transpose=self._AXIS_REVERSED)
 
     @property
     def _values(self) -> np.ndarray:
@@ -5402,7 +5413,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         """
         from pandas import Series
 
-        return Series(self._data.get_dtypes(), index=self._info_axis, dtype=np.object_)
+        return Series(self._mgr.get_dtypes(), index=self._info_axis, dtype=np.object_)
 
     def _to_dict_of_blocks(self, copy: bool_t = True):
         """
@@ -5413,7 +5424,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         """
         return {
             k: self._constructor(v).__finalize__(self)
-            for k, v, in self._data.to_dict(copy=copy).items()
+            for k, v, in self._mgr.to_dict(copy=copy).items()
         }
 
     def astype(
@@ -5551,7 +5562,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
 
         else:
             # else, only a single dtype is given
-            new_data = self._data.astype(dtype=dtype, copy=copy, errors=errors)
+            new_data = self._mgr.astype(dtype=dtype, copy=copy, errors=errors)
             return self._constructor(new_data).__finalize__(self)
 
         # GH 19920: retain column metadata after concat
@@ -5664,7 +5675,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         1     [3, 4]
         dtype: object
         """
-        data = self._data.copy(deep=deep)
+        data = self._mgr.copy(deep=deep)
         self._clear_item_cache()
         return self._constructor(data).__finalize__(self)
 
@@ -5718,7 +5729,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         validate_bool_kwarg(coerce, "coerce")
         validate_bool_kwarg(copy, "copy")
         return self._constructor(
-            self._data.convert(
+            self._mgr.convert(
                 datetime=datetime,
                 numeric=numeric,
                 timedelta=timedelta,
@@ -5769,7 +5780,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
         # python objects will still be converted to
         # native numpy numeric types
         return self._constructor(
-            self._data.convert(
+            self._mgr.convert(
                 datetime=True, numeric=False, timedelta=True, coerce=False, copy=True
             )
         ).__finalize__(self)
@@ -6037,11 +6048,11 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
                 result = self.T.fillna(method=method, limit=limit).T
 
                 # need to downcast here because of all of the transposes
-                result._data = result._data.downcast()
+                result._mgr = result._mgr.downcast()
 
                 return result
 
-            new_data = self._data.interpolate(
+            new_data = self._mgr.interpolate(
                 method=method,
                 axis=axis,
                 limit=limit,
@@ -6066,7 +6077,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
                         f'"{type(value).__name__}"'
                     )
 
-                new_data = self._data.fillna(
+                new_data = self._mgr.fillna(
                     value=value, limit=limit, inplace=inplace, downcast=downcast
                 )
 
@@ -6087,7 +6098,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
                 return result if not inplace else None
 
             elif not is_list_like(value):
-                new_data = self._data.fillna(
+                new_data = self._mgr.fillna(
                     value=value, limit=limit, inplace=inplace, downcast=downcast
                 )
             elif isinstance(value, ABCDataFrame) and self.ndim == 2:
@@ -6520,7 +6531,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
             if not self.size:
                 return self
 
-            new_data = self._data
+            new_data = self._mgr
             if is_dict_like(to_replace):
                 if is_dict_like(value):  # {'A' : NA} -> {'A' : 0}
                     res = self if inplace else self.copy()
@@ -6561,7 +6572,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
                             f"Expecting {len(to_replace)} got {len(value)} "
                         )
 
-                    new_data = self._data.replace_list(
+                    new_data = self._mgr.replace_list(
                         src_list=to_replace,
                         dest_list=value,
                         inplace=inplace,
@@ -6569,7 +6580,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
                     )
 
                 else:  # [NA, ''] -> 0
-                    new_data = self._data.replace(
+                    new_data = self._mgr.replace(
                         to_replace=to_replace, value=value, inplace=inplace, regex=regex
                     )
             elif to_replace is None:
@@ -6590,7 +6601,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
 
                 # dest iterable dict-like
                 if is_dict_like(value):  # NA -> {'A' : 0, 'B' : -1}
-                    new_data = self._data
+                    new_data = self._mgr
 
                     for k, v in value.items():
                         if k in self:
@@ -6603,7 +6614,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
                             )
 
                 elif not is_list_like(value):  # NA -> 0
-                    new_data = self._data.replace(
+                    new_data = self._mgr.replace(
                         to_replace=to_replace, value=value, inplace=inplace, regex=regex
                     )
                 else:
@@ -6862,7 +6873,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
                 "has not been implemented. Try filling "
                 "those NaNs before interpolating."
             )
-        data = df._data
+        data = df._mgr
         new_data = data.interpolate(
             method=method,
             axis=self._info_axis_number,
@@ -8459,7 +8470,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
 
         else:
             # one has > 1 ndim
-            fdata = self._data
+            fdata = self._mgr
             if axis == 0:
                 join_index = self.index
                 lidx, ridx = None, None
@@ -8484,7 +8495,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
             else:
                 raise ValueError("Must specify axis=0 or 1")
 
-            if copy and fdata is self._data:
+            if copy and fdata is self._mgr:
                 fdata = fdata.copy()
 
             left = self._constructor(fdata)
@@ -8633,14 +8644,14 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
             # reconstruct the block manager
 
             self._check_inplace_setting(other)
-            new_data = self._data.putmask(
+            new_data = self._mgr.putmask(
                 mask=cond, new=other, align=align, axis=block_axis,
             )
             result = self._constructor(new_data)
             return self._update_inplace(result)
 
         else:
-            new_data = self._data.where(
+            new_data = self._mgr.where(
                 other=other,
                 cond=cond,
                 align=align,
@@ -8915,7 +8926,7 @@ class NDFrame(PandasObject, SelectionMixin, indexing.IndexingMixin):
 
         block_axis = self._get_block_manager_axis(axis)
         if freq is None:
-            new_data = self._data.shift(
+            new_data = self._mgr.shift(
                 periods=periods, axis=block_axis, fill_value=fill_value
             )
         else:
@@ -11173,7 +11184,7 @@ def _make_cum_function(
             result = result.T if hasattr(result, "T") else result
             return result
 
-        result = self._data.apply(block_accum_func)
+        result = self._mgr.apply(block_accum_func)
 
         d = self._construct_axes_dict()
         d["copy"] = False
diff --git a/pandas/core/groupby/generic.py b/pandas/core/groupby/generic.py
index 88580f6eb..208cbfc5b 100644
--- a/pandas/core/groupby/generic.py
+++ b/pandas/core/groupby/generic.py
@@ -1057,7 +1057,7 @@ class DataFrameGroupBy(GroupBy[DataFrame]):
                 else:
                     result = cast(DataFrame, result)
                     # unwrap DataFrame to get array
-                    if len(result._data.blocks) != 1:
+                    if len(result._mgr.blocks) != 1:
                         # We've split an object block! Everything we've assumed
                         # about a single block input returning a single block output
                         # is a lie. To keep the code-path for the typical non-split case
@@ -1066,8 +1066,8 @@ class DataFrameGroupBy(GroupBy[DataFrame]):
                         split_frames.append(result)
                         continue
 
-                    assert len(result._data.blocks) == 1
-                    result = result._data.blocks[0].values
+                    assert len(result._mgr.blocks) == 1
+                    result = result._mgr.blocks[0].values
                     if isinstance(result, np.ndarray) and result.ndim == 1:
                         result = result.reshape(1, -1)
 
@@ -1107,7 +1107,7 @@ class DataFrameGroupBy(GroupBy[DataFrame]):
                 assert len(locs) == result.shape[1]
                 for i, loc in enumerate(locs):
                     new_items.append(np.array([loc], dtype=locs.dtype))
-                    agg_blocks.append(result.iloc[:, [i]]._data.blocks[0])
+                    agg_blocks.append(result.iloc[:, [i]]._mgr.blocks[0])
 
         # reset the locs in the blocks to correspond to our
         # current ordering
@@ -1651,9 +1651,9 @@ class DataFrameGroupBy(GroupBy[DataFrame]):
     def _get_data_to_aggregate(self) -> BlockManager:
         obj = self._obj_with_exclusions
         if self.axis == 1:
-            return obj.T._data
+            return obj.T._mgr
         else:
-            return obj._data
+            return obj._mgr
 
     def _insert_inaxis_grouper_inplace(self, result):
         # zip in reverse so we can always insert at loc 0
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 14c5c8ea0..06cd62c61 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -1555,8 +1555,8 @@ class _iLocIndexer(_LocationIndexer):
 
         # if there is only one block/type, still have to take split path
         # unless the block is one-dimensional or it can hold the value
-        if not take_split_path and self.obj._data.blocks:
-            (blk,) = self.obj._data.blocks
+        if not take_split_path and self.obj._mgr.blocks:
+            (blk,) = self.obj._mgr.blocks
             if 1 < blk.ndim:  # in case of dict, keys are indices
                 val = list(value.values()) if isinstance(value, dict) else value
                 take_split_path = not blk._can_hold_element(val)
@@ -1620,7 +1620,7 @@ class _iLocIndexer(_LocationIndexer):
                     # so the object is the same
                     index = self.obj._get_axis(i)
                     labels = index.insert(len(index), key)
-                    self.obj._data = self.obj.reindex(labels, axis=i)._data
+                    self.obj._mgr = self.obj.reindex(labels, axis=i)._mgr
                     self.obj._maybe_update_cacher(clear=True)
                     self.obj._is_copy = None
 
@@ -1701,7 +1701,7 @@ class _iLocIndexer(_LocationIndexer):
                     # set the item, possibly having a dtype change
                     ser._consolidate_inplace()
                     ser = ser.copy()
-                    ser._data = ser._data.setitem(indexer=pi, value=v)
+                    ser._mgr = ser._mgr.setitem(indexer=pi, value=v)
                     ser._maybe_update_cacher(clear=True)
 
                 # reset the sliced object if unique
@@ -1812,7 +1812,7 @@ class _iLocIndexer(_LocationIndexer):
 
             # actually do the set
             self.obj._consolidate_inplace()
-            self.obj._data = self.obj._data.setitem(indexer=indexer, value=value)
+            self.obj._mgr = self.obj._mgr.setitem(indexer=indexer, value=value)
             self.obj._maybe_update_cacher(clear=True)
 
     def _setitem_with_indexer_missing(self, indexer, value):
@@ -1844,9 +1844,9 @@ class _iLocIndexer(_LocationIndexer):
                 # GH#22717 handle casting compatibility that np.concatenate
                 #  does incorrectly
                 new_values = concat_compat([self.obj._values, new_values])
-            self.obj._data = self.obj._constructor(
+            self.obj._mgr = self.obj._constructor(
                 new_values, index=new_index, name=self.obj.name
-            )._data
+            )._mgr
             self.obj._maybe_update_cacher(clear=True)
 
         elif self.ndim == 2:
@@ -1869,7 +1869,7 @@ class _iLocIndexer(_LocationIndexer):
 
                 value = Series(value, index=self.obj.columns, name=indexer)
 
-            self.obj._data = self.obj.append(value)._data
+            self.obj._mgr = self.obj.append(value)._mgr
             self.obj._maybe_update_cacher(clear=True)
 
     def _align_series(self, indexer, ser: ABCSeries, multiindex_indexer: bool = False):
diff --git a/pandas/core/ops/__init__.py b/pandas/core/ops/__init__.py
index 10dcb5997..d6ba9d763 100644
--- a/pandas/core/ops/__init__.py
+++ b/pandas/core/ops/__init__.py
@@ -319,7 +319,7 @@ def dispatch_to_series(left, right, func, str_rep=None, axis=None):
 
         # Get the appropriate array-op to apply to each block's values.
         array_op = get_array_op(func, str_rep=str_rep)
-        bm = left._data.apply(array_op, right=right)
+        bm = left._mgr.apply(array_op, right=right)
         return type(left)(bm)
 
     elif isinstance(right, ABCDataFrame):
@@ -550,7 +550,7 @@ def _combine_series_frame(left, right, func, axis: int, str_rep: str):
             values = values.reshape(-1, 1)
 
             array_op = get_array_op(func, str_rep=str_rep)
-            bm = left._data.apply(array_op, right=values.T)
+            bm = left._mgr.apply(array_op, right=values.T)
             return type(left)(bm)
 
         new_data = dispatch_to_series(left, right, func)
diff --git a/pandas/core/resample.py b/pandas/core/resample.py
index b17092caa..281586879 100644
--- a/pandas/core/resample.py
+++ b/pandas/core/resample.py
@@ -1602,7 +1602,7 @@ def _take_new_index(obj, indexer, new_index, axis=0):
         if axis == 1:
             raise NotImplementedError("axis 1 is not supported")
         return obj._constructor(
-            obj._data.reindex_indexer(new_axis=new_index, indexer=indexer, axis=1)
+            obj._mgr.reindex_indexer(new_axis=new_index, indexer=indexer, axis=1)
         )
     else:
         raise ValueError("'obj' should be either a Series or a DataFrame")
diff --git a/pandas/core/reshape/concat.py b/pandas/core/reshape/concat.py
index fbc25a0dd..bd90592e5 100644
--- a/pandas/core/reshape/concat.py
+++ b/pandas/core/reshape/concat.py
@@ -458,8 +458,8 @@ class _Concatenator:
             if self.bm_axis == 0:
                 name = com.consensus_name_attr(self.objs)
 
-                mgr = self.objs[0]._data.concat(
-                    [x._data for x in self.objs], self.new_axes[0]
+                mgr = self.objs[0]._mgr.concat(
+                    [x._mgr for x in self.objs], self.new_axes[0]
                 )
                 cons = self.objs[0]._constructor
                 return cons(mgr, name=name).__finalize__(self, method="concat")
@@ -490,7 +490,7 @@ class _Concatenator:
                     if not new_labels.equals(obj_labels):
                         indexers[ax] = obj_labels.reindex(new_labels)[1]
 
-                mgrs_indexers.append((obj._data, indexers))
+                mgrs_indexers.append((obj._mgr, indexers))
 
             new_data = concatenate_block_managers(
                 mgrs_indexers, self.new_axes, concat_axis=self.bm_axis, copy=self.copy
diff --git a/pandas/core/reshape/merge.py b/pandas/core/reshape/merge.py
index c00da962d..47fa0627c 100644
--- a/pandas/core/reshape/merge.py
+++ b/pandas/core/reshape/merge.py
@@ -678,7 +678,7 @@ class _MergeOperation:
         rindexers = {1: right_indexer} if right_indexer is not None else {}
 
         result_data = concatenate_block_managers(
-            [(self.left._data, lindexers), (self.right._data, rindexers)],
+            [(self.left._mgr, lindexers), (self.right._mgr, rindexers)],
             axes=[llabels.append(rlabels), join_index],
             concat_axis=0,
             copy=self.copy,
@@ -1498,7 +1498,7 @@ class _OrderedMerge(_MergeOperation):
         rindexers = {1: right_join_indexer} if right_join_indexer is not None else {}
 
         result_data = concatenate_block_managers(
-            [(self.left._data, lindexers), (self.right._data, rindexers)],
+            [(self.left._mgr, lindexers), (self.right._mgr, rindexers)],
             axes=[llabels.append(rlabels), join_index],
             concat_axis=0,
             copy=self.copy,
diff --git a/pandas/core/reshape/reshape.py b/pandas/core/reshape/reshape.py
index 8e56cb263..d9e0206d7 100644
--- a/pandas/core/reshape/reshape.py
+++ b/pandas/core/reshape/reshape.py
@@ -431,7 +431,7 @@ def unstack(obj, level, fill_value=None):
 def _unstack_frame(obj, level, fill_value=None):
     if obj._is_mixed_type:
         unstacker = _Unstacker(obj.index, level=level)
-        blocks = obj._data.unstack(unstacker, fill_value=fill_value)
+        blocks = obj._mgr.unstack(unstacker, fill_value=fill_value)
         return obj._constructor(blocks)
     else:
         return _Unstacker(
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 2b073b3c5..5ed824110 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -193,7 +193,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
     hasnans = property(
         base.IndexOpsMixin.hasnans.func, doc=base.IndexOpsMixin.hasnans.__doc__
     )
-    _data: SingleBlockManager
+    _mgr: SingleBlockManager
     div: Callable[["Series", Any], "Series"]
     rdiv: Callable[["Series", Any], "Series"]
 
@@ -271,7 +271,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
                     index = data.index
                 else:
                     data = data.reindex(index, copy=copy)
-                data = data._data
+                data = data._mgr
             elif is_dict_like(data):
                 data, index = self._init_dict(data, index, dtype)
                 dtype = None
@@ -329,7 +329,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
 
     def _init_dict(self, data, index=None, dtype=None):
         """
-        Derive the "_data" and "index" attributes of a new Series from a
+        Derive the "_mgr" and "index" attributes of a new Series from a
         dictionary input.
 
         Parameters
@@ -369,7 +369,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         # Now we just make sure the order is respected, if any
         if data and index is not None:
             s = s.reindex(index, copy=False)
-        return s._data, s.index
+        return s._mgr, s.index
 
     # ----------------------------------------------------------------------
 
@@ -386,7 +386,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
     # types
     @property
     def _can_hold_na(self):
-        return self._data._can_hold_na
+        return self._mgr._can_hold_na
 
     _index = None
 
@@ -407,7 +407,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
                     labels = DatetimeIndex(labels)
                     # need to set here because we changed the index
                     if fastpath:
-                        self._data.set_axis(axis, labels)
+                        self._mgr.set_axis(axis, labels)
                 except (tslibs.OutOfBoundsDatetime, ValueError):
                     # labels may exceeds datetime bounds,
                     # or not be a DatetimeIndex
@@ -416,7 +416,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         object.__setattr__(self, "_index", labels)
         if not fastpath:
             # The ensure_index call aabove ensures we have an Index object
-            self._data.set_axis(axis, labels)
+            self._mgr.set_axis(axis, labels)
 
     # ndarray compatibility
     @property
@@ -424,7 +424,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         """
         Return the dtype object of the underlying data.
         """
-        return self._data.dtype
+        return self._mgr.dtype
 
     @property
     def dtypes(self) -> DtypeObj:
@@ -530,7 +530,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
                '2013-01-02T05:00:00.000000000',
                '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')
         """
-        return self._data.external_values()
+        return self._mgr.external_values()
 
     @property
     def _values(self):
@@ -564,12 +564,12 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         Nullable    | EA            | EA            | EA            |
 
         """
-        return self._data.internal_values()
+        return self._mgr.internal_values()
 
     @Appender(base.IndexOpsMixin.array.__doc__)  # type: ignore
     @property
     def array(self) -> ExtensionArray:
-        return self._data._block.array_values()
+        return self._mgr._block.array_values()
 
     # ops
     def ravel(self, order="C"):
@@ -591,7 +591,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         """
         Return the length of the Series.
         """
-        return len(self._data)
+        return len(self._mgr)
 
     def view(self, dtype=None) -> "Series":
         """
@@ -967,7 +967,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
 
     def _get_values(self, indexer):
         try:
-            return self._constructor(self._data.get_slice(indexer)).__finalize__(self)
+            return self._constructor(self._mgr.get_slice(indexer)).__finalize__(self)
         except ValueError:
             # mpl compat if we look up e.g. ser[:, np.newaxis];
             #  see tests.series.timeseries.test_mpl_compat_hack
@@ -1089,7 +1089,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
     def _set_values(self, key, value):
         if isinstance(key, Series):
             key = key._values
-        self._data = self._data.setitem(indexer=key, value=value)
+        self._mgr = self._mgr.setitem(indexer=key, value=value)
         self._maybe_update_cacher()
 
     def _set_value(self, label, value, takeable: bool = False):
@@ -2808,7 +2808,7 @@ Name: Max Speed, dtype: float64
         other = other.reindex_like(self)
         mask = notna(other)
 
-        self._data = self._data.putmask(mask=mask, new=other)
+        self._mgr = self._mgr.putmask(mask=mask, new=other)
         self._maybe_update_cacher()
 
     # ----------------------------------------------------------------------
diff --git a/pandas/io/formats/csvs.py b/pandas/io/formats/csvs.py
index 60691d1fe..091f76626 100644
--- a/pandas/io/formats/csvs.py
+++ b/pandas/io/formats/csvs.py
@@ -131,7 +131,6 @@ class CSVFormatter:
         self.cols = cols
 
         # preallocate data 2d list
-        self.blocks = self.obj._data.blocks
         ncols = self.obj.shape[-1]
         self.data = [None] * ncols
 
@@ -329,7 +328,7 @@ class CSVFormatter:
         slicer = slice(start_i, end_i)
 
         df = self.obj.iloc[slicer]
-        blocks = df._data.blocks
+        blocks = df._mgr.blocks
 
         for i in range(len(blocks)):
             b = blocks[i]
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 3e4b25088..a22251b29 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -3060,7 +3060,7 @@ class BlockManagerFixed(GenericFixed):
 
     def write(self, obj, **kwargs):
         super().write(obj, **kwargs)
-        data = obj._data
+        data = obj._mgr
         if not data.is_consolidated():
             data = data.consolidate()
 
@@ -3855,18 +3855,18 @@ class Table(Fixed):
         def get_blk_items(mgr, blocks):
             return [mgr.items.take(blk.mgr_locs) for blk in blocks]
 
-        blocks = block_obj._data.blocks
-        blk_items = get_blk_items(block_obj._data, blocks)
+        blocks = block_obj._mgr.blocks
+        blk_items = get_blk_items(block_obj._mgr, blocks)
 
         if len(data_columns):
             axis, axis_labels = new_non_index_axes[0]
             new_labels = Index(axis_labels).difference(Index(data_columns))
-            mgr = block_obj.reindex(new_labels, axis=axis)._data
+            mgr = block_obj.reindex(new_labels, axis=axis)._mgr
 
             blocks = list(mgr.blocks)
             blk_items = get_blk_items(mgr, blocks)
             for c in data_columns:
-                mgr = block_obj.reindex([c], axis=axis)._data
+                mgr = block_obj.reindex([c], axis=axis)._mgr
                 blocks.extend(mgr.blocks)
                 blk_items.extend(get_blk_items(mgr, mgr.blocks))
 
diff --git a/pandas/io/sql.py b/pandas/io/sql.py
index 3891afa5e..a2e66e9ab 100644
--- a/pandas/io/sql.py
+++ b/pandas/io/sql.py
@@ -692,7 +692,7 @@ class SQLTable(PandasObject):
         column_names = list(map(str, temp.columns))
         ncols = len(column_names)
         data_list = [None] * ncols
-        blocks = temp._data.blocks
+        blocks = temp._mgr.blocks
 
         for b in blocks:
             if b.is_datetime:
diff --git a/pandas/tests/extension/base/casting.py b/pandas/tests/extension/base/casting.py
index 58859fc6a..3b1e89685 100644
--- a/pandas/tests/extension/base/casting.py
+++ b/pandas/tests/extension/base/casting.py
@@ -12,7 +12,7 @@ class BaseCastingTests(BaseExtensionTests):
     def test_astype_object_series(self, all_data):
         ser = pd.Series({"A": all_data})
         result = ser.astype(object)
-        assert isinstance(result._data.blocks[0], ObjectBlock)
+        assert isinstance(result._mgr.blocks[0], ObjectBlock)
 
     def test_tolist(self, data):
         result = pd.Series(data).tolist()
diff --git a/pandas/tests/extension/base/constructors.py b/pandas/tests/extension/base/constructors.py
index c40646ca2..1ddc7af0f 100644
--- a/pandas/tests/extension/base/constructors.py
+++ b/pandas/tests/extension/base/constructors.py
@@ -25,13 +25,13 @@ class BaseConstructorsTests(BaseExtensionTests):
         result = pd.Series(data)
         assert result.dtype == data.dtype
         assert len(result) == len(data)
-        assert isinstance(result._data.blocks[0], ExtensionBlock)
-        assert result._data.blocks[0].values is data
+        assert isinstance(result._mgr.blocks[0], ExtensionBlock)
+        assert result._mgr.blocks[0].values is data
 
         # Series[EA] is unboxed / boxed correctly
         result2 = pd.Series(result)
         assert result2.dtype == data.dtype
-        assert isinstance(result2._data.blocks[0], ExtensionBlock)
+        assert isinstance(result2._mgr.blocks[0], ExtensionBlock)
 
     @pytest.mark.parametrize("from_series", [True, False])
     def test_dataframe_constructor_from_dict(self, data, from_series):
@@ -40,13 +40,13 @@ class BaseConstructorsTests(BaseExtensionTests):
         result = pd.DataFrame({"A": data})
         assert result.dtypes["A"] == data.dtype
         assert result.shape == (len(data), 1)
-        assert isinstance(result._data.blocks[0], ExtensionBlock)
+        assert isinstance(result._mgr.blocks[0], ExtensionBlock)
 
     def test_dataframe_from_series(self, data):
         result = pd.DataFrame(pd.Series(data))
         assert result.dtypes[0] == data.dtype
         assert result.shape == (len(data), 1)
-        assert isinstance(result._data.blocks[0], ExtensionBlock)
+        assert isinstance(result._mgr.blocks[0], ExtensionBlock)
 
     def test_series_given_mismatched_index_raises(self, data):
         msg = "Length of passed values is 3, index implies 5"
diff --git a/pandas/tests/extension/base/getitem.py b/pandas/tests/extension/base/getitem.py
index b08a64cc0..71c7198e3 100644
--- a/pandas/tests/extension/base/getitem.py
+++ b/pandas/tests/extension/base/getitem.py
@@ -356,7 +356,7 @@ class BaseGetitemTests(BaseExtensionTests):
         # see GH-27785 take_nd with indexer of len 1 resulting in wrong ndim
         df = pd.DataFrame({"A": data})
         res = df.loc[[0], "A"]
-        assert res._data._block.ndim == 1
+        assert res._mgr._block.ndim == 1
 
     def test_item(self, data):
         # https://github.com/pandas-dev/pandas/pull/30175
diff --git a/pandas/tests/extension/base/interface.py b/pandas/tests/extension/base/interface.py
index 95fb3d743..9ae4b0150 100644
--- a/pandas/tests/extension/base/interface.py
+++ b/pandas/tests/extension/base/interface.py
@@ -56,7 +56,7 @@ class BaseInterfaceTests(BaseExtensionTests):
 
     def test_is_numeric_honored(self, data):
         result = pd.Series(data)
-        assert result._data.blocks[0].is_numeric is data.dtype._is_numeric
+        assert result._mgr.blocks[0].is_numeric is data.dtype._is_numeric
 
     def test_isna_extension_array(self, data_missing):
         # If your `isna` returns an ExtensionArray, you must also implement
diff --git a/pandas/tests/extension/base/reshaping.py b/pandas/tests/extension/base/reshaping.py
index ec2189885..d2c3877de 100644
--- a/pandas/tests/extension/base/reshaping.py
+++ b/pandas/tests/extension/base/reshaping.py
@@ -27,7 +27,7 @@ class BaseReshapingTests(BaseExtensionTests):
             dtype = result.dtype
 
         assert dtype == data.dtype
-        assert isinstance(result._data.blocks[0], ExtensionBlock)
+        assert isinstance(result._mgr.blocks[0], ExtensionBlock)
 
     @pytest.mark.parametrize("in_frame", [True, False])
     def test_concat_all_na_block(self, data_missing, in_frame):
diff --git a/pandas/tests/extension/test_external_block.py b/pandas/tests/extension/test_external_block.py
index e9046be15..9925fd515 100644
--- a/pandas/tests/extension/test_external_block.py
+++ b/pandas/tests/extension/test_external_block.py
@@ -24,7 +24,7 @@ class CustomBlock(ExtensionBlock):
 @pytest.fixture
 def df():
     df1 = pd.DataFrame({"a": [1, 2, 3]})
-    blocks = df1._data.blocks
+    blocks = df1._mgr.blocks
     values = np.arange(3, dtype="int64")
     custom_block = CustomBlock(values, placement=slice(1, 2))
     blocks = blocks + (custom_block,)
@@ -35,11 +35,11 @@ def df():
 def test_concat_dataframe(df):
     # GH17728
     res = pd.concat([df, df])
-    assert isinstance(res._data.blocks[1], CustomBlock)
+    assert isinstance(res._mgr.blocks[1], CustomBlock)
 
 
 def test_concat_axis1(df):
     # GH17954
     df2 = pd.DataFrame({"c": [0.1, 0.2, 0.3]})
     res = pd.concat([df, df2], axis=1)
-    assert isinstance(res._data.blocks[1], CustomBlock)
+    assert isinstance(res._mgr.blocks[1], CustomBlock)
diff --git a/pandas/tests/frame/indexing/test_categorical.py b/pandas/tests/frame/indexing/test_categorical.py
index f5b3f980c..0ae2f8110 100644
--- a/pandas/tests/frame/indexing/test_categorical.py
+++ b/pandas/tests/frame/indexing/test_categorical.py
@@ -45,7 +45,7 @@ class TestDataFrameIndexingCategorical:
 
         result1 = df["D"]
         result2 = df["E"]
-        tm.assert_categorical_equal(result1._data._block.values, d)
+        tm.assert_categorical_equal(result1._mgr._block.values, d)
 
         # sorting
         s.name = "E"
diff --git a/pandas/tests/frame/indexing/test_datetime.py b/pandas/tests/frame/indexing/test_datetime.py
index 0fd60c151..c1a7cb9f4 100644
--- a/pandas/tests/frame/indexing/test_datetime.py
+++ b/pandas/tests/frame/indexing/test_datetime.py
@@ -20,8 +20,8 @@ class TestDataFrameIndexingDatetimeWithTZ:
 
         # assert that A & C are not sharing the same base (e.g. they
         # are copies)
-        b1 = df._data.blocks[1]
-        b2 = df._data.blocks[2]
+        b1 = df._mgr.blocks[1]
+        b2 = df._mgr.blocks[2]
         tm.assert_extension_array_equal(b1.values, b2.values)
         assert id(b1.values._data.base) != id(b2.values._data.base)
 
diff --git a/pandas/tests/frame/indexing/test_indexing.py b/pandas/tests/frame/indexing/test_indexing.py
index 406a01efb..a71b4a098 100644
--- a/pandas/tests/frame/indexing/test_indexing.py
+++ b/pandas/tests/frame/indexing/test_indexing.py
@@ -2170,7 +2170,7 @@ def test_object_casting_indexing_wraps_datetimelike():
     assert isinstance(ser.values[1], pd.Timestamp)
     assert isinstance(ser.values[2], pd.Timedelta)
 
-    mgr = df._data
+    mgr = df._mgr
     mgr._rebuild_blknos_and_blklocs()
     arr = mgr.fast_xs(0)
     assert isinstance(arr[1], pd.Timestamp)
diff --git a/pandas/tests/frame/methods/test_align.py b/pandas/tests/frame/methods/test_align.py
index 36a9a6b5b..5dae71928 100644
--- a/pandas/tests/frame/methods/test_align.py
+++ b/pandas/tests/frame/methods/test_align.py
@@ -9,10 +9,10 @@ import pandas._testing as tm
 class TestDataFrameAlign:
     def test_align_float(self, float_frame):
         af, bf = float_frame.align(float_frame)
-        assert af._data is not float_frame._data
+        assert af._mgr is not float_frame._mgr
 
         af, bf = float_frame.align(float_frame, copy=False)
-        assert af._data is float_frame._data
+        assert af._mgr is float_frame._mgr
 
         # axis = 0
         other = float_frame.iloc[:-5, :3]
diff --git a/pandas/tests/frame/test_arithmetic.py b/pandas/tests/frame/test_arithmetic.py
index 89f8bc433..d929d3e03 100644
--- a/pandas/tests/frame/test_arithmetic.py
+++ b/pandas/tests/frame/test_arithmetic.py
@@ -1319,7 +1319,7 @@ class TestFrameArithmeticUnsorted:
         tm.assert_series_equal(s, s2)
         tm.assert_series_equal(s_orig + 1, s)
         assert s is s2
-        assert s._data is s2._data
+        assert s._mgr is s2._mgr
 
         df = df_orig.copy()
         df2 = df
@@ -1327,7 +1327,7 @@ class TestFrameArithmeticUnsorted:
         tm.assert_frame_equal(df, df2)
         tm.assert_frame_equal(df_orig + 1, df)
         assert df is df2
-        assert df._data is df2._data
+        assert df._mgr is df2._mgr
 
         # dtype change
         s = s_orig.copy()
@@ -1342,7 +1342,7 @@ class TestFrameArithmeticUnsorted:
         tm.assert_frame_equal(df, df2)
         tm.assert_frame_equal(df_orig + 1.5, df)
         assert df is df2
-        assert df._data is df2._data
+        assert df._mgr is df2._mgr
 
         # mixed dtype
         arr = np.random.randint(0, 10, size=5)
@@ -1353,7 +1353,7 @@ class TestFrameArithmeticUnsorted:
         expected = DataFrame({"A": arr.copy() + 1, "B": "foo"})
         tm.assert_frame_equal(df, expected)
         tm.assert_frame_equal(df2, expected)
-        assert df._data is df2._data
+        assert df._mgr is df2._mgr
 
         df = df_orig.copy()
         df2 = df
@@ -1361,7 +1361,7 @@ class TestFrameArithmeticUnsorted:
         expected = DataFrame({"A": arr.copy() + 1.5, "B": "foo"})
         tm.assert_frame_equal(df, expected)
         tm.assert_frame_equal(df2, expected)
-        assert df._data is df2._data
+        assert df._mgr is df2._mgr
 
     @pytest.mark.parametrize(
         "op",
diff --git a/pandas/tests/frame/test_block_internals.py b/pandas/tests/frame/test_block_internals.py
index e67fef9ef..e2910a2eb 100644
--- a/pandas/tests/frame/test_block_internals.py
+++ b/pandas/tests/frame/test_block_internals.py
@@ -43,18 +43,18 @@ class TestDataFrameBlockInternals:
         assert dti[1] == ts
 
     def test_cast_internals(self, float_frame):
-        casted = DataFrame(float_frame._data, dtype=int)
+        casted = DataFrame(float_frame._mgr, dtype=int)
         expected = DataFrame(float_frame._series, dtype=int)
         tm.assert_frame_equal(casted, expected)
 
-        casted = DataFrame(float_frame._data, dtype=np.int32)
+        casted = DataFrame(float_frame._mgr, dtype=np.int32)
         expected = DataFrame(float_frame._series, dtype=np.int32)
         tm.assert_frame_equal(casted, expected)
 
     def test_consolidate(self, float_frame):
         float_frame["E"] = 7.0
         consolidated = float_frame._consolidate()
-        assert len(consolidated._data.blocks) == 1
+        assert len(consolidated._mgr.blocks) == 1
 
         # Ensure copy, do I want this?
         recons = consolidated._consolidate()
@@ -62,10 +62,10 @@ class TestDataFrameBlockInternals:
         tm.assert_frame_equal(recons, consolidated)
 
         float_frame["F"] = 8.0
-        assert len(float_frame._data.blocks) == 3
+        assert len(float_frame._mgr.blocks) == 3
 
         float_frame._consolidate(inplace=True)
-        assert len(float_frame._data.blocks) == 1
+        assert len(float_frame._mgr.blocks) == 1
 
     def test_consolidate_inplace(self, float_frame):
         frame = float_frame.copy()  # noqa
@@ -76,9 +76,9 @@ class TestDataFrameBlockInternals:
 
     def test_values_consolidate(self, float_frame):
         float_frame["E"] = 7.0
-        assert not float_frame._data.is_consolidated()
+        assert not float_frame._mgr.is_consolidated()
         _ = float_frame.values  # noqa
-        assert float_frame._data.is_consolidated()
+        assert float_frame._mgr.is_consolidated()
 
     def test_modify_values(self, float_frame):
         float_frame.values[5] = 5
@@ -300,7 +300,7 @@ class TestDataFrameBlockInternals:
         df1 = df0.reset_index()[["A", "B", "C"]]
         # this assert verifies that the above operations have
         # induced a block rearrangement
-        assert df0._data.blocks[0].dtype != df1._data.blocks[0].dtype
+        assert df0._mgr.blocks[0].dtype != df1._mgr.blocks[0].dtype
 
         # do the real tests
         tm.assert_frame_equal(df0, df1)
@@ -342,7 +342,7 @@ class TestDataFrameBlockInternals:
 
         # copy objects
         copy = float_string_frame.copy()
-        assert copy._data is not float_string_frame._data
+        assert copy._mgr is not float_string_frame._mgr
 
     def test_pickle(self, float_string_frame, timezone_frame):
         empty_frame = DataFrame()
@@ -351,7 +351,7 @@ class TestDataFrameBlockInternals:
         tm.assert_frame_equal(float_string_frame, unpickled)
 
         # buglet
-        float_string_frame._data.ndim
+        float_string_frame._mgr.ndim
 
         # empty
         unpickled = tm.round_trip_pickle(empty_frame)
@@ -604,7 +604,7 @@ class TestDataFrameBlockInternals:
         result = pd.DataFrame({"A": arr})
         expected = pd.DataFrame({"A": [1, 2, 3]})
         tm.assert_frame_equal(result, expected)
-        assert isinstance(result._data.blocks[0], IntBlock)
+        assert isinstance(result._mgr.blocks[0], IntBlock)
 
     def test_add_column_with_pandas_array(self):
         # GH 26390
@@ -617,6 +617,6 @@ class TestDataFrameBlockInternals:
                 "c": pd.arrays.PandasArray(np.array([1, 2, None, 3], dtype=object)),
             }
         )
-        assert type(df["c"]._data.blocks[0]) == ObjectBlock
-        assert type(df2["c"]._data.blocks[0]) == ObjectBlock
+        assert type(df["c"]._mgr.blocks[0]) == ObjectBlock
+        assert type(df2["c"]._mgr.blocks[0]) == ObjectBlock
         tm.assert_frame_equal(df, df2)
diff --git a/pandas/tests/frame/test_constructors.py b/pandas/tests/frame/test_constructors.py
index fcdc62753..fc27f1949 100644
--- a/pandas/tests/frame/test_constructors.py
+++ b/pandas/tests/frame/test_constructors.py
@@ -1569,7 +1569,7 @@ class TestDataFrameConstructors:
         index = list(float_frame.index[:5])
         columns = list(float_frame.columns[:3])
 
-        result = DataFrame(float_frame._data, index=index, columns=columns)
+        result = DataFrame(float_frame._mgr, index=index, columns=columns)
         tm.assert_index_equal(result.index, Index(index))
         tm.assert_index_equal(result.columns, Index(columns))
 
diff --git a/pandas/tests/frame/test_nonunique_indexes.py b/pandas/tests/frame/test_nonunique_indexes.py
index 253088680..a8b76f4d8 100644
--- a/pandas/tests/frame/test_nonunique_indexes.py
+++ b/pandas/tests/frame/test_nonunique_indexes.py
@@ -474,8 +474,8 @@ class TestDataFrameNonuniqueIndexes:
         )
         df = pd.concat([df_float, df_int, df_bool, df_object, df_dt], axis=1)
 
-        assert len(df._data.blknos) == len(df.columns)
-        assert len(df._data.blklocs) == len(df.columns)
+        assert len(df._mgr.blknos) == len(df.columns)
+        assert len(df._mgr.blklocs) == len(df.columns)
 
         # testing iloc
         for i in range(len(df.columns)):
diff --git a/pandas/tests/generic/test_generic.py b/pandas/tests/generic/test_generic.py
index 1a4a0b167..2c8261a6d 100644
--- a/pandas/tests/generic/test_generic.py
+++ b/pandas/tests/generic/test_generic.py
@@ -162,12 +162,12 @@ class Generic:
 
         o = self._construct(shape=4, value=9, dtype=np.int64)
         result = o.copy()
-        result._data = o._data.downcast()
+        result._mgr = o._mgr.downcast()
         self._compare(result, o)
 
         o = self._construct(shape=4, value=9.5)
         result = o.copy()
-        result._data = o._data.downcast()
+        result._mgr = o._mgr.downcast()
         self._compare(result, o)
 
     def test_constructor_compound_dtypes(self):
diff --git a/pandas/tests/groupby/test_bin_groupby.py b/pandas/tests/groupby/test_bin_groupby.py
index 152086c24..e999b88fc 100644
--- a/pandas/tests/groupby/test_bin_groupby.py
+++ b/pandas/tests/groupby/test_bin_groupby.py
@@ -53,7 +53,7 @@ def test_series_bin_grouper():
 
 
 def assert_block_lengths(x):
-    assert len(x) == len(x._data.blocks[0].mgr_locs)
+    assert len(x) == len(x._mgr.blocks[0].mgr_locs)
     return 0
 
 
diff --git a/pandas/tests/indexing/test_iloc.py b/pandas/tests/indexing/test_iloc.py
index 9664f8d72..c97cd81c8 100644
--- a/pandas/tests/indexing/test_iloc.py
+++ b/pandas/tests/indexing/test_iloc.py
@@ -486,7 +486,7 @@ class TestiLoc2:
         columns = list(range(0, 8, 2))
         df = DataFrame(arr, index=index, columns=columns)
 
-        df._data.blocks[0].mgr_locs
+        df._mgr.blocks[0].mgr_locs
         result = df.iloc[1:5, 2:4]
         str(result)
         result.dtypes
diff --git a/pandas/tests/internals/test_internals.py b/pandas/tests/internals/test_internals.py
index 57fbc9ab1..58a84f5a2 100644
--- a/pandas/tests/internals/test_internals.py
+++ b/pandas/tests/internals/test_internals.py
@@ -1174,7 +1174,7 @@ class TestShouldStore:
     def test_should_store_categorical(self):
         cat = pd.Categorical(["A", "B", "C"])
         df = pd.DataFrame(cat)
-        blk = df._data.blocks[0]
+        blk = df._mgr.blocks[0]
 
         # matching dtype
         assert blk.should_store(cat)
@@ -1216,7 +1216,7 @@ def test_block_shape():
     a = pd.Series([1, 2, 3]).reindex(idx)
     b = pd.Series(pd.Categorical([1, 2, 3])).reindex(idx)
 
-    assert a._data.blocks[0].mgr_locs.indexer == b._data.blocks[0].mgr_locs.indexer
+    assert a._mgr.blocks[0].mgr_locs.indexer == b._mgr.blocks[0].mgr_locs.indexer
 
 
 def test_make_block_no_pandas_array():
diff --git a/pandas/tests/io/pytables/test_store.py b/pandas/tests/io/pytables/test_store.py
index 9a0788ea0..536f4aa76 100644
--- a/pandas/tests/io/pytables/test_store.py
+++ b/pandas/tests/io/pytables/test_store.py
@@ -2382,7 +2382,7 @@ class TestHDFStore:
             df["foo"] = np.random.randn(len(df))
             store["df"] = df
             recons = store["df"]
-            assert recons._data.is_consolidated()
+            assert recons._mgr.is_consolidated()
 
         # empty
         self._check_roundtrip(df[:0], tm.assert_frame_equal, path=setup_path)
diff --git a/pandas/tests/reshape/merge/test_merge.py b/pandas/tests/reshape/merge/test_merge.py
index a6a76a107..29d3bf302 100644
--- a/pandas/tests/reshape/merge/test_merge.py
+++ b/pandas/tests/reshape/merge/test_merge.py
@@ -1364,7 +1364,7 @@ class TestMerge:
             np.arange(20).reshape((5, 4)) + 1, columns=["a", "b", "x", "y"]
         )
 
-        data1._data.blocks[0].values.flags.writeable = False
+        data1._mgr.blocks[0].values.flags.writeable = False
         data1.merge(data2)  # no error
 
 
diff --git a/pandas/tests/reshape/test_concat.py b/pandas/tests/reshape/test_concat.py
index a12395b32..bccae2c4c 100644
--- a/pandas/tests/reshape/test_concat.py
+++ b/pandas/tests/reshape/test_concat.py
@@ -1113,28 +1113,28 @@ class TestConcatenate:
         # These are actual copies.
         result = concat([df, df2, df3], axis=1, copy=True)
 
-        for b in result._data.blocks:
+        for b in result._mgr.blocks:
             assert b.values.base is None
 
         # These are the same.
         result = concat([df, df2, df3], axis=1, copy=False)
 
-        for b in result._data.blocks:
+        for b in result._mgr.blocks:
             if b.is_float:
-                assert b.values.base is df._data.blocks[0].values.base
+                assert b.values.base is df._mgr.blocks[0].values.base
             elif b.is_integer:
-                assert b.values.base is df2._data.blocks[0].values.base
+                assert b.values.base is df2._mgr.blocks[0].values.base
             elif b.is_object:
                 assert b.values.base is not None
 
         # Float block was consolidated.
         df4 = DataFrame(np.random.randn(4, 1))
         result = concat([df, df2, df3, df4], axis=1, copy=False)
-        for b in result._data.blocks:
+        for b in result._mgr.blocks:
             if b.is_float:
                 assert b.values.base is None
             elif b.is_integer:
-                assert b.values.base is df2._data.blocks[0].values.base
+                assert b.values.base is df2._mgr.blocks[0].values.base
             elif b.is_object:
                 assert b.values.base is not None
 
diff --git a/pandas/tests/series/test_block_internals.py b/pandas/tests/series/test_block_internals.py
index 18e75c3be..d0dfbe6f5 100644
--- a/pandas/tests/series/test_block_internals.py
+++ b/pandas/tests/series/test_block_internals.py
@@ -31,8 +31,8 @@ class TestSeriesBlockInternals:
         ser = pd.Series(dti)
         assert ser._values is not dti
         assert ser._values._data.base is not dti._data._data.base
-        assert ser._data.blocks[0].values is not dti
-        assert ser._data.blocks[0].values._data.base is not dti._data._data.base
+        assert ser._mgr.blocks[0].values is not dti
+        assert ser._mgr.blocks[0].values._data.base is not dti._data._data.base
 
         ser[::3] = pd.NaT
         assert ser[0] is pd.NaT
diff --git a/pandas/tests/series/test_constructors.py b/pandas/tests/series/test_constructors.py
index 55af73552..effb32429 100644
--- a/pandas/tests/series/test_constructors.py
+++ b/pandas/tests/series/test_constructors.py
@@ -626,7 +626,7 @@ class TestSeriesConstructors:
         s = pd.Series(index)
 
         # we make 1 copy; this is just a smoke test here
-        assert s._data.blocks[0].values is not index
+        assert s._mgr.blocks[0].values is not index
 
     def test_constructor_pass_none(self):
         with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):
@@ -1329,6 +1329,7 @@ class TestSeriesConstructors:
         )
         tm.assert_series_equal(s, Series(date_range("20130101", periods=3, freq="D")))
 
+        # FIXME: dont leave commented-out
         # s = Series(np.array(['2013-01-01 00:00:01','2013-01-01
         # 00:00:02','2013-01-01 00:00:03'],dtype='datetime64[s]'))
 
diff --git a/pandas/tests/series/test_internals.py b/pandas/tests/series/test_internals.py
index 3a1996b29..51410fce7 100644
--- a/pandas/tests/series/test_internals.py
+++ b/pandas/tests/series/test_internals.py
@@ -207,7 +207,7 @@ class TestSeriesInternals:
         ser = pd.Series([1, 2, 3])
         result = pd.Series(ser.array)
         tm.assert_series_equal(ser, result)
-        assert isinstance(result._data.blocks[0], IntBlock)
+        assert isinstance(result._mgr.blocks[0], IntBlock)
 
     def test_astype_no_pandas_dtype(self):
         # https://github.com/pandas-dev/pandas/pull/24866
@@ -219,17 +219,17 @@ class TestSeriesInternals:
 
     def test_from_array(self):
         result = pd.Series(pd.array(["1H", "2H"], dtype="timedelta64[ns]"))
-        assert result._data.blocks[0].is_extension is False
+        assert result._mgr.blocks[0].is_extension is False
 
         result = pd.Series(pd.array(["2015"], dtype="datetime64[ns]"))
-        assert result._data.blocks[0].is_extension is False
+        assert result._mgr.blocks[0].is_extension is False
 
     def test_from_list_dtype(self):
         result = pd.Series(["1H", "2H"], dtype="timedelta64[ns]")
-        assert result._data.blocks[0].is_extension is False
+        assert result._mgr.blocks[0].is_extension is False
 
         result = pd.Series(["2015"], dtype="datetime64[ns]")
-        assert result._data.blocks[0].is_extension is False
+        assert result._mgr.blocks[0].is_extension is False
 
 
 def test_hasnans_uncached_for_series():

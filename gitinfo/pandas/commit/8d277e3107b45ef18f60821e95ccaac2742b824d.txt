commit 8d277e3107b45ef18f60821e95ccaac2742b824d
Author: Chang She <chang@lambdafoundry.com>
Date:   Sat Nov 24 16:31:41 2012 -0500

    ENH: min_periods for corr/cov #2002 and TST tweak to use better sys.stderr idiom 5645be2

diff --git a/RELEASE.rst b/RELEASE.rst
index 260316b55..f1597b03f 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -31,6 +31,9 @@ pandas 0.10.0
 
   - Add error handling to Series.str.encode/decode (#2276)
   - Add ``where`` and ``mask`` to Series (#2337)
+  - Grouped histogram via `by` keyword in Series/DataFrame.hist (#2186)
+  - Support optional ``min_periods`` keyword in ``corr`` and ``cov``
+    for both Series and DataFrame (#2002)
 
 **API Changes**
 
@@ -42,7 +45,6 @@ pandas 0.10.0
 
 **Improvements to existing features**
 
-  - Grouped histogram via `by` keyword in Series/DataFrame.hist (#2186)
   - Add ``nrows`` option to DataFrame.from_records for iterators (#1794)
   - Unstack/reshape algorithm rewrite to avoid high memory use in cases where
     the number of observed key-tuples is much smaller than the total possible
diff --git a/doc/source/computation.rst b/doc/source/computation.rst
index 23bd05b15..a5df30333 100644
--- a/doc/source/computation.rst
+++ b/doc/source/computation.rst
@@ -62,6 +62,21 @@ among the series in the DataFrame, also excluding NA/null values.
    frame = DataFrame(randn(1000, 5), columns=['a', 'b', 'c', 'd', 'e'])
    frame.cov()
 
+``DataFrame.cov`` also supports an optional ``min_periods`` keyword that
+specifies the required minimum number of observations for each column pair
+in order to have a valid result.
+
+.. ipython:: python
+
+   frame = DataFrame(randn(20, 3), columns=['a', 'b', 'c'])
+   frame.ix[:5, 'a'] = np.nan
+   frame.ix[5:10, 'b'] = np.nan
+
+   frame.cov()
+
+   frame.cov(min_periods=12)
+
+
 .. _computation.correlation:
 
 Correlation
@@ -97,6 +112,19 @@ All of these are currently computed using pairwise complete observations.
 Note that non-numeric columns will be automatically excluded from the
 correlation calculation.
 
+Like ``cov``, ``corr`` also supports the optional ``min_periods`` keyword:
+
+.. ipython:: python
+
+   frame = DataFrame(randn(20, 3), columns=['a', 'b', 'c'])
+   frame.ix[:5, 'a'] = np.nan
+   frame.ix[5:10, 'b'] = np.nan
+
+   frame.corr()
+
+   frame.corr(min_periods=12)
+
+
 A related method ``corrwith`` is implemented on DataFrame to compute the
 correlation between like-labeled Series contained in different DataFrame
 objects.
@@ -290,9 +318,9 @@ columns using ``ix`` indexing:
 
 Expanding window moment functions
 ---------------------------------
-A common alternative to rolling statistics is to use an *expanding* window, 
-which yields the value of the statistic with all the data available up to that 
-point in time. As these calculations are a special case of rolling statistics, 
+A common alternative to rolling statistics is to use an *expanding* window,
+which yields the value of the statistic with all the data available up to that
+point in time. As these calculations are a special case of rolling statistics,
 they are implemented in pandas such that the following two calls are equivalent:
 
 .. ipython:: python
@@ -301,7 +329,7 @@ they are implemented in pandas such that the following two calls are equivalent:
 
    expanding_mean(df)[:5]
 
-Like the ``rolling_`` functions, the following methods are included in the 
+Like the ``rolling_`` functions, the following methods are included in the
 ``pandas`` namespace or can be located in ``pandas.stats.moments``.
 
 .. csv-table::
@@ -324,12 +352,12 @@ Like the ``rolling_`` functions, the following methods are included in the
     ``expanding_corr``, Correlation (binary)
     ``expanding_corr_pairwise``, Pairwise correlation of DataFrame columns
 
-Aside from not having a ``window`` parameter, these functions have the same 
-interfaces as their ``rolling_`` counterpart. Like above, the parameters they 
+Aside from not having a ``window`` parameter, these functions have the same
+interfaces as their ``rolling_`` counterpart. Like above, the parameters they
 all accept are:
 
-  - ``min_periods``: threshold of non-null data points to require. Defaults to 
-    minimum needed to compute statistic. No ``NaNs`` will be output once 
+  - ``min_periods``: threshold of non-null data points to require. Defaults to
+    minimum needed to compute statistic. No ``NaNs`` will be output once
     ``min_periods`` non-null data points have been seen.
   - ``freq``: optionally specify a :ref:`frequency string <timeseries.alias>`
     or :ref:`DateOffset <timeseries.offsets>` to pre-conform the data to.
@@ -338,15 +366,15 @@ all accept are:
 
 .. note::
 
-   The output of the ``rolling_`` and ``expanding_`` functions do not return a 
-   ``NaN`` if there are at least ``min_periods`` non-null values in the current 
-   window. This differs from ``cumsum``, ``cumprod``, ``cummax``, and 
-   ``cummin``, which return ``NaN`` in the output wherever a ``NaN`` is 
+   The output of the ``rolling_`` and ``expanding_`` functions do not return a
+   ``NaN`` if there are at least ``min_periods`` non-null values in the current
+   window. This differs from ``cumsum``, ``cumprod``, ``cummax``, and
+   ``cummin``, which return ``NaN`` in the output wherever a ``NaN`` is
    encountered in the input.
 
-An expanding window statistic will be more stable (and less responsive) than 
-its rolling window counterpart as the increasing window size decreases the 
-relative impact of an individual data point. As an example, here is the 
+An expanding window statistic will be more stable (and less responsive) than
+its rolling window counterpart as the increasing window size decreases the
+relative impact of an individual data point. As an example, here is the
 ``expanding_mean`` output for the previous time series dataset:
 
 .. ipython:: python
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 07460f217..aeed377e3 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -4241,7 +4241,7 @@ class DataFrame(NDFrame):
     #----------------------------------------------------------------------
     # Statistical methods, etc.
 
-    def corr(self, method='pearson'):
+    def corr(self, method='pearson', min_periods=None):
         """
         Compute pairwise correlation of columns, excluding NA/null values
 
@@ -4251,6 +4251,10 @@ class DataFrame(NDFrame):
             pearson : standard correlation coefficient
             kendall : Kendall Tau correlation coefficient
             spearman : Spearman rank correlation
+        min_periods : int, optional
+            Minimum number of observations required per pair of columns
+            to have a valid result. Currently only available for pearson
+            correlation
 
         Returns
         -------
@@ -4261,8 +4265,10 @@ class DataFrame(NDFrame):
         mat = numeric_df.values
 
         if method == 'pearson':
-            correl = lib.nancorr(com._ensure_float64(mat))
+            correl = lib.nancorr(com._ensure_float64(mat), minp=min_periods)
         else:
+            if min_periods is None:
+                min_periods = 1
             mat = mat.T
             corrf = nanops.get_corr_func(method)
             K = len(cols)
@@ -4271,7 +4277,7 @@ class DataFrame(NDFrame):
             for i, ac in enumerate(mat):
                 for j, bc in enumerate(mat):
                     valid = mask[i] & mask[j]
-                    if not valid.any():
+                    if valid.sum() < min_periods:
                         c = NA
                     elif not valid.all():
                         c = corrf(ac[valid], bc[valid])
@@ -4282,10 +4288,16 @@ class DataFrame(NDFrame):
 
         return self._constructor(correl, index=cols, columns=cols)
 
-    def cov(self):
+    def cov(self, min_periods=None):
         """
         Compute pairwise covariance of columns, excluding NA/null values
 
+        Parameters
+        ----------
+        min_periods : int, optional
+            Minimum number of observations required per pair of columns
+            to have a valid result.
+
         Returns
         -------
         y : DataFrame
@@ -4298,9 +4310,14 @@ class DataFrame(NDFrame):
         mat = numeric_df.values
 
         if notnull(mat).all():
-            baseCov = np.cov(mat.T)
+            if min_periods is not None and min_periods > len(mat):
+                baseCov = np.empty((mat.shape[1], mat.shape[1]))
+                baseCov.fill(np.nan)
+            else:
+                baseCov = np.cov(mat.T)
         else:
-            baseCov = lib.nancorr(com._ensure_float64(mat), cov=True)
+            baseCov = lib.nancorr(com._ensure_float64(mat), cov=True,
+                                  minp=min_periods)
 
         return self._constructor(baseCov, index=cols, columns=cols)
 
diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index f7d732507..073a58f8f 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -384,19 +384,22 @@ def _zero_out_fperr(arg):
         return 0 if np.abs(arg) < 1e-14 else arg
 
 
-def nancorr(a, b, method='pearson'):
+def nancorr(a, b, method='pearson', min_periods=None):
     """
     a, b: ndarrays
     """
     if len(a) != len(b):
         raise AssertionError('Operands to nancorr must have same size')
 
+    if min_periods is None:
+        min_periods = 1
+
     valid = notnull(a) & notnull(b)
     if not valid.all():
         a = a[valid]
         b = b[valid]
 
-    if len(a) == 0:
+    if len(a) < min_periods:
         return np.nan
 
     f = get_corr_func(method)
@@ -427,16 +430,19 @@ def get_corr_func(method):
     return _cor_methods[method]
 
 
-def nancov(a, b):
+def nancov(a, b, min_periods=None):
     if len(a) != len(b):
         raise AssertionError('Operands to nancov must have same size')
 
+    if min_periods is None:
+        min_periods = 1
+
     valid = notnull(a) & notnull(b)
     if not valid.all():
         a = a[valid]
         b = b[valid]
 
-    if len(a) == 0:
+    if len(a) < min_periods:
         return np.nan
 
     return np.cov(a, b)[0, 1]
diff --git a/pandas/core/series.py b/pandas/core/series.py
index fda78acaf..8101dace1 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1529,7 +1529,8 @@ copy : boolean, default False
 
         return Series(data, index=names)
 
-    def corr(self, other, method='pearson'):
+    def corr(self, other, method='pearson',
+             min_periods=None):
         """
         Compute correlation two Series, excluding missing values
 
@@ -1540,21 +1541,29 @@ copy : boolean, default False
             pearson : standard correlation coefficient
             kendall : Kendall Tau correlation coefficient
             spearman : Spearman rank correlation
+        min_periods : int, optional
+            Minimum number of observations needed to have a valid result
+
 
         Returns
         -------
         correlation : float
         """
         this, other = self.align(other, join='inner', copy=False)
-        return nanops.nancorr(this.values, other.values, method=method)
+        if len(this) == 0:
+            return np.nan
+        return nanops.nancorr(this.values, other.values, method=method,
+                              min_periods=min_periods)
 
-    def cov(self, other):
+    def cov(self, other, min_periods=None):
         """
         Compute covariance with Series, excluding missing values
 
         Parameters
         ----------
         other : Series
+        min_periods : int, optional
+            Minimum number of observations needed to have a valid result
 
         Returns
         -------
@@ -1565,7 +1574,8 @@ copy : boolean, default False
         this, other = self.align(other, join='inner')
         if len(this) == 0:
             return np.nan
-        return nanops.nancov(this.values, other.values)
+        return nanops.nancov(this.values, other.values,
+                             min_periods=min_periods)
 
     def diff(self, periods=1):
         """
diff --git a/pandas/sparse/tests/test_sparse.py b/pandas/sparse/tests/test_sparse.py
index f6412e09c..1b0c0dad5 100644
--- a/pandas/sparse/tests/test_sparse.py
+++ b/pandas/sparse/tests/test_sparse.py
@@ -822,9 +822,12 @@ class TestSparseDataFrame(TestCase, test_frame.SafeForSparse):
     def test_sparse_series_ops(self):
         import sys
         buf = StringIO()
+        tmp = sys.stderr
         sys.stderr = buf
-        self._check_all(self._check_frame_ops)
-        sys.stderr = sys.__stderr__
+        try:
+            self._check_all(self._check_frame_ops)
+        finally:
+            sys.stderr = tmp
 
     def _check_frame_ops(self, frame):
         fill = frame.default_fill_value
diff --git a/pandas/src/moments.pyx b/pandas/src/moments.pyx
index 037544683..efe42108d 100644
--- a/pandas/src/moments.pyx
+++ b/pandas/src/moments.pyx
@@ -300,7 +300,7 @@ def ewma(ndarray[double_t] input, double_t com, int adjust):
 
 @cython.boundscheck(False)
 @cython.wraparound(False)
-def nancorr(ndarray[float64_t, ndim=2] mat, cov=False):
+def nancorr(ndarray[float64_t, ndim=2] mat, cov=False, minp=None):
     cdef:
         Py_ssize_t i, j, xi, yi, N, K
         ndarray[float64_t, ndim=2] result
@@ -310,6 +310,9 @@ def nancorr(ndarray[float64_t, ndim=2] mat, cov=False):
 
     N, K = (<object> mat).shape
 
+    if minp is None:
+        minp = 1
+
     result = np.empty((K, K), dtype=np.float64)
     mask = np.isfinite(mat).view(np.uint8)
 
@@ -324,7 +327,7 @@ def nancorr(ndarray[float64_t, ndim=2] mat, cov=False):
                     sumx += vx
                     sumy += vy
 
-            if nobs == 0:
+            if nobs < minp:
                 result[xi, yi] = result[yi, xi] = np.NaN
             else:
                 meanx = sumx / nobs
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index e80ac2cac..be34294d1 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -3467,36 +3467,38 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         import sys
 
         buf = StringIO()
+        tmp = sys.stderr
         sys.stderr = buf
 
-        ts = self.tsframe['A']
-        added = self.tsframe + ts
-
-        for key, col in self.tsframe.iteritems():
-            assert_series_equal(added[key], col + ts)
+        try:
+            ts = self.tsframe['A']
+            added = self.tsframe + ts
 
-        smaller_frame = self.tsframe[:-5]
-        smaller_added = smaller_frame + ts
+            for key, col in self.tsframe.iteritems():
+                assert_series_equal(added[key], col + ts)
 
-        self.assert_(smaller_added.index.equals(self.tsframe.index))
+            smaller_frame = self.tsframe[:-5]
+            smaller_added = smaller_frame + ts
 
-        smaller_ts = ts[:-5]
-        smaller_added2 = self.tsframe + smaller_ts
-        assert_frame_equal(smaller_added, smaller_added2)
+            self.assert_(smaller_added.index.equals(self.tsframe.index))
 
-        # length 0
-        result = self.tsframe + ts[:0]
+            smaller_ts = ts[:-5]
+            smaller_added2 = self.tsframe + smaller_ts
+            assert_frame_equal(smaller_added, smaller_added2)
 
-        # Frame is length 0
-        result = self.tsframe[:0] + ts
-        self.assertEqual(len(result), 0)
+            # length 0
+            result = self.tsframe + ts[:0]
 
-        # empty but with non-empty index
-        frame = self.tsframe[:1].reindex(columns=[])
-        result = frame * ts
-        self.assertEqual(len(result), len(ts))
+            # Frame is length 0
+            result = self.tsframe[:0] + ts
+            self.assertEqual(len(result), 0)
 
-        sys.stderr = sys.__stderr__
+            # empty but with non-empty index
+            frame = self.tsframe[:1].reindex(columns=[])
+            result = frame * ts
+            self.assertEqual(len(result), len(ts))
+        finally:
+            sys.stderr = tmp
 
     def test_combineFunc(self):
         result = self.frame * 2
@@ -4226,12 +4228,17 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
     def test_corr(self):
         _skip_if_no_scipy()
         self.frame['A'][:5] = nan
-        self.frame['B'][:10] = nan
+        self.frame['B'][5:10] = nan
 
-        def _check_method(method='pearson'):
-            correls = self.frame.corr(method=method)
-            exp = self.frame['A'].corr(self.frame['C'], method=method)
-            assert_almost_equal(correls['A']['C'], exp)
+        def _check_method(method='pearson', check_minp=False):
+            if not check_minp:
+                correls = self.frame.corr(method=method)
+                exp = self.frame['A'].corr(self.frame['C'], method=method)
+                assert_almost_equal(correls['A']['C'], exp)
+            else:
+                result = self.frame.corr(min_periods=len(self.frame) - 8)
+                expected = self.frame.corr()
+                expected.ix['A', 'B'] = expected.ix['B', 'A'] = nan
 
         _check_method('pearson')
         _check_method('kendall')
@@ -4268,6 +4275,25 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         df3.corr()
 
     def test_cov(self):
+        # min_periods no NAs (corner case)
+        expected = self.frame.cov()
+        result = self.frame.cov(min_periods=len(self.frame))
+
+        assert_frame_equal(expected, result)
+
+        result = self.frame.cov(min_periods=len(self.frame) + 1)
+        self.assert_(isnull(result.values).all())
+
+        # with NAs
+        frame = self.frame.copy()
+        frame['A'][:5] = nan
+        frame['B'][5:10] = nan
+        result = self.frame.cov(min_periods=len(self.frame) - 8)
+        expected = self.frame.cov()
+        expected.ix['A', 'B'] = np.nan
+        expected.ix['B', 'A'] = np.nan
+
+        # regular
         self.frame['A'][:5] = nan
         self.frame['B'][:10] = nan
         cov = self.frame.cov()
@@ -4280,6 +4306,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         expected = self.mixed_frame.ix[:, ['A', 'B', 'C', 'D']].cov()
         assert_frame_equal(result, expected)
 
+
     def test_corrwith(self):
         a = self.tsframe
         noise = Series(randn(len(a)), index=a.index)
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index d7343c3ee..f09c01386 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -1092,10 +1092,13 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         import sys
 
         buf = StringIO()
+        tmp = sys.stderr
         sys.stderr = buf
+        try:
         # it works (with no Cython exception barf)!
-        repr(s)
-        sys.stderr = sys.__stderr__
+            repr(s)
+        finally:
+            sys.stderr = tmp
         self.assertEquals(buf.getvalue(), '')
 
     def test_repr_name_iterable_indexable(self):
@@ -1744,12 +1747,19 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self.assertRaises(TypeError, operator.add, datetime.now(), self.ts)
 
     def test_operators_frame(self):
+        import sys
+        buf = StringIO()
+        tmp = sys.stderr
+        sys.stderr = buf
         # rpow does not work with DataFrame
-        df = DataFrame({'A' : self.ts})
+        try:
+            df = DataFrame({'A' : self.ts})
 
-        tm.assert_almost_equal(self.ts + self.ts, (self.ts + df)['A'])
-        tm.assert_almost_equal(self.ts ** self.ts, (self.ts ** df)['A'])
-        tm.assert_almost_equal(self.ts < self.ts, (self.ts < df)['A'])
+            tm.assert_almost_equal(self.ts + self.ts, (self.ts + df)['A'])
+            tm.assert_almost_equal(self.ts ** self.ts, (self.ts ** df)['A'])
+            tm.assert_almost_equal(self.ts < self.ts, (self.ts < df)['A'])
+        finally:
+            sys.stderr = tmp
 
     def test_operators_combine(self):
         def _check_fill(meth, op, a, b, fill_value=0):
@@ -1849,6 +1859,12 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         # partial overlap
         self.assertAlmostEqual(self.ts[:15].corr(self.ts[5:]), 1)
 
+        self.assert_(isnull(self.ts[:15].corr(self.ts[5:], min_periods=12)))
+
+        ts1 = self.ts[:15].reindex(self.ts.index)
+        ts2 = self.ts[5:].reindex(self.ts.index)
+        self.assert_(isnull(ts1.corr(ts2, min_periods=12)))
+
         # No overlap
         self.assert_(np.isnan(self.ts[::2].corr(self.ts[1::2])))
 
@@ -1912,6 +1928,13 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         cp[:] = np.nan
         self.assert_(isnull(cp.cov(cp)))
 
+        # min_periods
+        self.assert_(isnull(self.ts[:15].cov(self.ts[5:], min_periods=12)))
+
+        ts1 = self.ts[:15].reindex(self.ts.index)
+        ts2 = self.ts[5:].reindex(self.ts.index)
+        self.assert_(isnull(ts1.cov(ts2, min_periods=12)))
+
     def test_copy(self):
         ts = self.ts.copy()
 

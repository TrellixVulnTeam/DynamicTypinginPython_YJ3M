commit 50bae9799192b1d2f8a99bb5097393d522de48ab
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Apr 4 18:26:57 2012 -0400

    ENH: implement limit option to reindex/fillna methods and related infrastructure/API methods, doc updates still needed #825

diff --git a/pandas/core/common.py b/pandas/core/common.py
index 5c6389330..d842ed960 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -301,6 +301,27 @@ def _need_upcast(values):
         return True
     return False
 
+def pad_1d(values, limit=None):
+    if is_float_dtype(values):
+        _method = lib.pad_inplace_float64
+    elif values.dtype == np.object_:
+        _method = lib.pad_inplace_object
+    else: # pragma: no cover
+        raise ValueError('Invalid dtype for padding')
+
+    _method(values, isnull(values).view(np.uint8), limit=limit)
+
+def backfill_1d(values, limit=None):
+    if is_float_dtype(values):
+        _method = lib.backfill_inplace_float64
+    elif values.dtype == np.object_:
+        _method = lib.backfill_inplace_object
+    else: # pragma: no cover
+        raise ValueError('Invalid dtype for padding')
+
+    _method(values, isnull(values).view(np.uint8), limit=limit)
+
+
 #-------------------------------------------------------------------------------
 # Lots of little utilities
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 194c3e78a..409464422 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1838,7 +1838,7 @@ class DataFrame(NDFrame):
             return left_result, right_result
 
     def reindex(self, index=None, columns=None, method=None, level=None,
-                fill_value=np.nan, copy=True):
+                fill_value=np.nan, limit=None, copy=True):
         """Conform DataFrame to new index with optional filling logic, placing
         NA/NaN in locations having no value in the previous index. A new object
         is produced unless the new index is equivalent to the current one and
@@ -1876,15 +1876,17 @@ class DataFrame(NDFrame):
         frame = self
 
         if index is not None:
-            frame = frame._reindex_index(index, method, copy, level, fill_value)
+            frame = frame._reindex_index(index, method, copy, level,
+                                         fill_value, limit)
 
         if columns is not None:
-            frame = frame._reindex_columns(columns, copy, level, fill_value)
+            frame = frame._reindex_columns(columns, copy, level,
+                                           fill_value, limit)
 
         return frame
 
     def reindex_axis(self, labels, axis=0, method=None, level=None, copy=True,
-                     fill_value=np.nan):
+                     limit=None, fill_value=np.nan):
         """Conform DataFrame to new index with optional filling logic, placing
         NA/NaN in locations having no value in the previous index. A new object
         is produced unless the new index is equivalent to the current one and
@@ -1923,20 +1925,26 @@ class DataFrame(NDFrame):
         self._consolidate_inplace()
         if axis == 0:
             return self._reindex_index(labels, method, copy, level,
-                                       fill_value=fill_value)
+                                       fill_value=fill_value,
+                                       limit=limit)
         elif axis == 1:
             return self._reindex_columns(labels, copy, level,
-                                         fill_value=fill_value)
+                                         fill_value=fill_value,
+                                         limit=limit)
         else:  # pragma: no cover
             raise ValueError('Must specify axis=0 or 1')
 
-    def _reindex_index(self, new_index, method, copy, level, fill_value=np.nan):
-        new_index, indexer = self.index.reindex(new_index, method, level)
+    def _reindex_index(self, new_index, method, copy, level, fill_value=np.nan,
+                       limit=None):
+        new_index, indexer = self.index.reindex(new_index, method, level,
+                                                limit=limit)
         return self._reindex_with_indexers(new_index, indexer, None, None,
                                            copy, fill_value)
 
-    def _reindex_columns(self, new_columns, copy, level, fill_value=np.nan):
-        new_columns, indexer = self.columns.reindex(new_columns, level=level)
+    def _reindex_columns(self, new_columns, copy, level, fill_value=np.nan,
+                         limit=None):
+        new_columns, indexer = self.columns.reindex(new_columns, level=level,
+                                                    limit=limit)
         return self._reindex_with_indexers(None, None, new_columns, indexer,
                                            copy, fill_value)
 
@@ -1965,7 +1973,7 @@ class DataFrame(NDFrame):
 
         return DataFrame(new_data)
 
-    def reindex_like(self, other, method=None, copy=True):
+    def reindex_like(self, other, method=None, copy=True, limit=None):
         """
         Reindex DataFrame to match indices of another DataFrame, optionally
         with filling logic
@@ -1986,7 +1994,7 @@ class DataFrame(NDFrame):
         reindexed : DataFrame
         """
         return self.reindex(index=other.index, columns=other.columns,
-                            method=method, copy=copy)
+                            method=method, copy=copy, limit=limit)
 
     truncate = generic.truncate
 
@@ -2406,7 +2414,8 @@ class DataFrame(NDFrame):
     #----------------------------------------------------------------------
     # Filling NA's
 
-    def fillna(self, value=None, method='pad', axis=0, inplace=False):
+    def fillna(self, value=None, method='pad', axis=0, inplace=False,
+               limit=None):
         """
         Fill NA/NaN values using the specified method
 
@@ -2443,13 +2452,14 @@ class DataFrame(NDFrame):
 
         if value is None:
             if self._is_mixed_type and axis == 1:
-                return self.T.fillna(method=method).T
+                return self.T.fillna(method=method, limit=limit).T
 
             new_blocks = []
             method = com._clean_fill_method(method)
             for block in self._data.blocks:
                 if isinstance(block, (FloatBlock, ObjectBlock)):
-                    newb = block.interpolate(method, axis=axis, inplace=inplace)
+                    newb = block.interpolate(method, axis=axis,
+                                             limit=limit, inplace=inplace)
                 else:
                     newb = block if inplace else block.copy()
                 new_blocks.append(newb)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index cc83e4678..bee04201c 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -62,8 +62,6 @@ class Index(np.ndarray):
     #     'groupby' : _gin.groupby_index,
     # }
 
-    # _map_indices = lib.map_indices_object
-
     # Cython methods
     _groupby = lib.groupby_object
     _arrmap = lib.arrmap_object
@@ -597,7 +595,7 @@ class Index(np.ndarray):
         """
         self._engine.set_value(arr, key, value)
 
-    def get_indexer(self, target, method=None):
+    def get_indexer(self, target, method=None, limit=None):
         """
         Compute indexer and mask for new index given the current index. The
         indexer should be then used as an input to ndarray.take to align the
@@ -632,14 +630,14 @@ class Index(np.ndarray):
         if self.dtype != target.dtype:
             this = Index(self, dtype=object)
             target = Index(target, dtype=object)
-            return this.get_indexer(target, method=method)
+            return this.get_indexer(target, method=method, limit=limit)
 
         if method == 'pad':
             assert(self.is_unique and self.is_monotonic)
-            indexer = self._engine.get_pad_indexer(target)
+            indexer = self._engine.get_pad_indexer(target, limit)
         elif method == 'backfill':
             assert(self.is_unique and self.is_monotonic)
-            indexer = self._engine.get_backfill_indexer(target)
+            indexer = self._engine.get_backfill_indexer(target, limit)
         elif method is None:
             indexer = self._engine.get_indexer(target)
         else:
@@ -686,7 +684,7 @@ class Index(np.ndarray):
         }
         return aliases.get(method, method)
 
-    def reindex(self, target, method=None, level=None):
+    def reindex(self, target, method=None, level=None, limit=None):
         """
         For Index, simply returns the new index and the results of
         get_indexer. Provided here to enable an interface that is amenable for
@@ -698,13 +696,16 @@ class Index(np.ndarray):
         """
         target = _ensure_index(target)
         if level is not None:
+            if method is not None:
+                raise ValueError('Fill method not supported if level passed')
             _, indexer, _ = self._join_level(target, level, how='right',
                                              return_indexers=True)
         else:
             if self.equals(target):
                 indexer = None
             else:
-                indexer = self.get_indexer(target, method=method)
+                indexer = self.get_indexer(target, method=method,
+                                           limit=limit)
         return target, indexer
 
     def join(self, other, how='left', level=None, return_indexers=False):
@@ -982,8 +983,6 @@ class Index(np.ndarray):
 
 class Int64Index(Index):
 
-    _map_indices = lib.map_indices_int64
-
     # _is_monotonic = lib.is_monotonic_int64
 
     _groupby = lib.groupby_int64
@@ -1179,7 +1178,6 @@ class DatetimeIndex(Int64Index):
     _outer_indexer = _join_i8_wrapper(lib.outer_join_indexer_int64)
     _left_indexer  = _join_i8_wrapper(lib.left_join_indexer_int64,
                                       with_indexers=False)
-    _map_indices   = _wrap_i8_function(lib.map_indices_int64)
     _groupby       = lib.groupby_arrays # _wrap_i8_function(lib.groupby_int64)
 
     _arrmap        = _wrap_dt_function(lib.arrmap_object)
@@ -2921,7 +2919,7 @@ class MultiIndex(Index):
 
         return new_index, indexer
 
-    def get_indexer(self, target, method=None):
+    def get_indexer(self, target, method=None, limit=None):
         """
         Compute indexer and mask for new index given the current index. The
         indexer should be then used as an input to ndarray.take to align the
@@ -2966,16 +2964,18 @@ class MultiIndex(Index):
 
         if method == 'pad':
             assert(self.is_unique and self.is_monotonic)
-            indexer = self_index._engine.get_pad_indexer(target_index)
+            indexer = self_index._engine.get_pad_indexer(target_index,
+                                                         limit=limit)
         elif method == 'backfill':
             assert(self.is_unique and self.is_monotonic)
-            indexer = self_index._engine.get_backfill_indexer(target_index)
+            indexer = self_index._engine.get_backfill_indexer(target_index,
+                                                              limit=limit)
         else:
             indexer = self_index._engine.get_indexer(target_index)
 
         return indexer
 
-    def reindex(self, target, method=None, level=None):
+    def reindex(self, target, method=None, level=None, limit=None):
         """
         Performs any necessary conversion on the input index and calls
         get_indexer. This method is here so MultiIndex and an Index of
@@ -2986,13 +2986,16 @@ class MultiIndex(Index):
         (new_index, indexer, mask) : (MultiIndex, ndarray, ndarray)
         """
         if level is not None:
+            if method is not None:
+                raise ValueError('Fill method not supported if level passed')
             target, indexer, _ = self._join_level(target, level, how='right',
                                                   return_indexers=True)
         else:
             if self.equals(target):
                 indexer = None
             else:
-                indexer = self.get_indexer(target, method=method)
+                indexer = self.get_indexer(target, method=method,
+                                           limit=limit)
 
         if not isinstance(target, MultiIndex):
             if indexer is None:
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 31595d260..9565f2f10 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -216,7 +216,7 @@ class Block(object):
         else:
             return make_block(new_values, self.items, self.ref_items)
 
-    def interpolate(self, method='pad', axis=0, inplace=False):
+    def interpolate(self, method='pad', axis=0, inplace=False, limit=None):
         values = self.values if inplace else self.values.copy()
 
         if values.ndim != 2:
@@ -225,13 +225,13 @@ class Block(object):
         transf = (lambda x: x) if axis == 0 else (lambda x: x.T)
 
         if method == 'pad':
-            _pad(transf(values))
+            _pad(transf(values), limit=limit)
         else:
-            _backfill(transf(values))
+            _backfill(transf(values), limit=limit)
 
         return make_block(values, self.items, self.ref_items)
 
-def _pad(values):
+def _pad(values, limit=None):
     if com.is_float_dtype(values):
         _method = lib.pad_2d_inplace_float64
     elif values.dtype == np.object_:
@@ -239,9 +239,10 @@ def _pad(values):
     else: # pragma: no cover
         raise ValueError('Invalid dtype for padding')
 
-    _method(values, com.isnull(values).view(np.uint8))
+    _method(values, com.isnull(values).view(np.uint8),
+            limit=limit)
 
-def _backfill(values):
+def _backfill(values, limit=None):
     if com.is_float_dtype(values):
         _method = lib.backfill_2d_inplace_float64
     elif values.dtype == np.object_:
@@ -249,7 +250,8 @@ def _backfill(values):
     else: # pragma: no cover
         raise ValueError('Invalid dtype for padding')
 
-    _method(values, com.isnull(values).view(np.uint8))
+    _method(values, com.isnull(values).view(np.uint8),
+            limit=limit)
 
 #-------------------------------------------------------------------------------
 # Is this even possible?
diff --git a/pandas/core/series.py b/pandas/core/series.py
index f8dff94e1..3b95ae5ff 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1867,7 +1867,7 @@ copy : boolean, default False
         return self._constructor(new_values, new_index, name=self.name)
 
     def reindex(self, index=None, method=None, level=None, fill_value=np.nan,
-                copy=True):
+                limit=None, copy=True):
         """Conform Series to new index with optional filling logic, placing
         NA/NaN in locations having no value in the previous index. A new object
         is produced unless the new index is equivalent to the current one and
@@ -1906,12 +1906,12 @@ copy : boolean, default False
             return Series(nan, index=index, name=self.name)
 
         new_index, fill_vec = self.index.reindex(index, method=method,
-                                                 level=level)
+                                                 level=level, limit=limit)
         fill_vec = com._ensure_int32(fill_vec)
         new_values = com.take_1d(self.values, fill_vec, fill_value=fill_value)
         return Series(new_values, index=new_index, name=self.name)
 
-    def reindex_like(self, other, method=None):
+    def reindex_like(self, other, method=None, limit=None):
         """
         Reindex Series to match index of another Series, optionally with
         filling logic
@@ -1930,7 +1930,7 @@ copy : boolean, default False
         -------
         reindexed : Series
         """
-        return self.reindex(other.index, method=method)
+        return self.reindex(other.index, method=method, limit=limit)
 
     def take(self, indices, axis=0):
         """
@@ -1951,7 +1951,8 @@ copy : boolean, default False
 
     truncate = generic.truncate
 
-    def fillna(self, value=None, method='pad', inplace=False):
+    def fillna(self, value=None, method='pad', inplace=False,
+               limit=None):
         """
         Fill NA/NaN values using the specified method
 
@@ -1986,21 +1987,22 @@ copy : boolean, default False
                 raise ValueError('must specify a fill method')
 
             method = com._clean_fill_method(method)
-
-            # sadness. for Python 2.5 compatibility
-            mask = mask.astype(np.uint8)
-
             if method == 'pad':
-                indexer = lib.get_pad_indexer(mask)
+                fill_f = com.pad_1d
             elif method == 'backfill':
-                indexer = lib.get_backfill_indexer(mask)
+                fill_f = com.backfill_1d
+
+            if inplace:
+                values = self.values
+            else:
+                values = self.values.copy()
+
+            fill_f(values, limit=limit)
 
             if inplace:
-                self.values[:] = self.values.take(indexer)
                 result = self
             else:
-                new_values = self.values.take(indexer)
-                result = Series(new_values, index=self.index, name=self.name)
+                result = Series(values, index=self.index, name=self.name)
 
         return result
 
diff --git a/pandas/sparse/frame.py b/pandas/sparse/frame.py
index 9cb7b6ddd..97b418e84 100644
--- a/pandas/sparse/frame.py
+++ b/pandas/sparse/frame.py
@@ -314,8 +314,8 @@ class SparseDataFrame(DataFrame):
             return s
         except (TypeError, KeyError):
             if isinstance(item, slice):
-                dateRange = self.index[item]
-                return self.reindex(dateRange)
+                date_rng = self.index[item]
+                return self.reindex(date_rng)
 
             elif isinstance(item, np.ndarray):
                 if len(item) != len(self.index):
@@ -487,7 +487,8 @@ class SparseDataFrame(DataFrame):
         return self._constructor(data=new_data, index=self.index,
                                  columns=self.columns)
 
-    def _reindex_index(self, index, method, copy, level, fill_value=np.nan):
+    def _reindex_index(self, index, method, copy, level, fill_value=np.nan,
+                       limit=None):
         if level is not None:
             raise Exception('Reindex by level not supported for sparse')
 
@@ -500,7 +501,7 @@ class SparseDataFrame(DataFrame):
         if len(self.index) == 0:
             return SparseDataFrame(index=index, columns=self.columns)
 
-        indexer = self.index.get_indexer(index, method)
+        indexer = self.index.get_indexer(index, method, limit=limit)
         mask = indexer == -1
         need_mask = mask.any()
 
@@ -517,13 +518,16 @@ class SparseDataFrame(DataFrame):
         return SparseDataFrame(new_series, index=index, columns=self.columns,
                                default_fill_value=self.default_fill_value)
 
-    def _reindex_columns(self, columns, copy, level, fill_value):
+    def _reindex_columns(self, columns, copy, level, fill_value, limit=None):
         if level is not None:
             raise Exception('Reindex by level not supported for sparse')
 
         if com.notnull(fill_value):
             raise NotImplementedError
 
+        if limit:
+            raise NotImplementedError
+
         # TODO: fill value handling
         sdict = dict((k, v) for k, v in self.iteritems() if k in columns)
         return SparseDataFrame(sdict, index=self.index, columns=columns,
diff --git a/pandas/sparse/series.py b/pandas/sparse/series.py
index 623760834..dfe78a81c 100644
--- a/pandas/sparse/series.py
+++ b/pandas/sparse/series.py
@@ -373,7 +373,7 @@ to sparse
                             sparse_index=self.sp_index,
                             fill_value=self.fill_value, name=self.name)
 
-    def reindex(self, index=None, method=None, copy=True):
+    def reindex(self, index=None, method=None, copy=True, limit=None):
         """
         Conform SparseSeries to new Index
 
@@ -398,7 +398,8 @@ to sparse
             return SparseSeries(values, index=new_index,
                                 fill_value=self.fill_value)
 
-        new_index, fill_vec = self.index.reindex(index, method=method)
+        new_index, fill_vec = self.index.reindex(index, method=method,
+                                                 limit=limit)
         new_values = common.take_1d(self.values, fill_vec)
         return SparseSeries(new_values, index=new_index,
                             fill_value=self.fill_value, name=self.name)
@@ -425,9 +426,9 @@ to sparse
                             fill_value=self.fill_value)
 
     @Appender(Series.fillna.__doc__)
-    def fillna(self, value=None, method='pad', inplace=False):
+    def fillna(self, value=None, method='pad', inplace=False, limit=None):
         dense = self.to_dense()
-        filled = dense.fillna(value=value, method=method)
+        filled = dense.fillna(value=value, method=method, limit=limit)
         result = filled.to_sparse(kind=self.kind,
                                   fill_value=self.fill_value)
 
diff --git a/pandas/src/engines.pyx b/pandas/src/engines.pyx
index 9595e0014..f96880473 100644
--- a/pandas/src/engines.pyx
+++ b/pandas/src/engines.pyx
@@ -237,11 +237,13 @@ cdef class Int64Engine(IndexEngine):
     def _call_monotonic(self, values):
         return _tseries.is_monotonic_int64(values)
 
-    def get_pad_indexer(self, other):
-        return _tseries.pad_int64(self._get_index_values(), other)
+    def get_pad_indexer(self, other, limit=None):
+        return _tseries.pad_int64(self._get_index_values(), other,
+                                  limit=limit)
 
-    def get_backfill_indexer(self, other):
-        return _tseries.backfill_int64(self._get_index_values(), other)
+    def get_backfill_indexer(self, other, limit=None):
+        return _tseries.backfill_int64(self._get_index_values(), other,
+                                       limit=limit)
 
     cdef _get_bool_indexer(self, object val):
         cdef:
@@ -283,12 +285,25 @@ cdef class Float64Engine(IndexEngine):
     def _call_monotonic(self, values):
         return _tseries.is_monotonic_float64(values)
 
-    def get_pad_indexer(self, other):
-        return _tseries.pad_float64(self._get_index_values(), other)
+    def get_pad_indexer(self, other, limit=None):
+        return _tseries.pad_float64(self._get_index_values(), other,
+                                    limit=limit)
 
-    def get_backfill_indexer(self, other):
-        return _tseries.backfill_float64(self._get_index_values(), other)
+    def get_backfill_indexer(self, other, limit=None):
+        return _tseries.backfill_float64(self._get_index_values(), other,
+                                         limit=limit)
 
+_pad_functions = {
+    'object' : _tseries.pad_object,
+    'int64' : _tseries.pad_int64,
+    'float64' : _tseries.pad_float64
+}
+
+_backfill_functions = {
+    'object': _tseries.backfill_object,
+    'int64': _tseries.backfill_int64,
+    'float64': _tseries.backfill_float64
+}
 
 cdef class ObjectEngine(IndexEngine):
 
@@ -300,11 +315,13 @@ cdef class ObjectEngine(IndexEngine):
     def _call_monotonic(self, values):
         return _tseries.is_monotonic_object(values)
 
-    def get_pad_indexer(self, other):
-        return _tseries.pad_object(self._get_index_values(), other)
+    def get_pad_indexer(self, other, limit=None):
+        return _tseries.pad_object(self._get_index_values(), other,
+                                   limit=limit)
 
-    def get_backfill_indexer(self, other):
-        return _tseries.backfill_object(self._get_index_values(), other)
+    def get_backfill_indexer(self, other, limit=None):
+        return _tseries.backfill_object(self._get_index_values(), other,
+                                        limit=limit)
 
 
 cdef class DatetimeEngine(Int64Engine):
@@ -361,17 +378,19 @@ cdef class DatetimeEngine(Int64Engine):
         values = np.asarray(values).view('i8')
         return self.mapping.lookup(values)
 
-    def get_pad_indexer(self, other):
+    def get_pad_indexer(self, other, limit=None):
         if other.dtype != 'M8':
             return np.repeat(-1, len(other)).astype('i4')
         other = np.asarray(other).view('i8')
-        return _tseries.pad_int64(self._get_index_values(), other)
+        return _tseries.pad_int64(self._get_index_values(), other,
+                                  limit=limit)
 
-    def get_backfill_indexer(self, other):
+    def get_backfill_indexer(self, other, limit=None):
         if other.dtype != 'M8':
             return np.repeat(-1, len(other)).astype('i4')
         other = np.asarray(other).view('i8')
-        return _tseries.backfill_int64(self._get_index_values(), other)
+        return _tseries.backfill_int64(self._get_index_values(), other,
+                                       limit=limit)
 
 
 # ctypedef fused idxvalue_t:
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index d22dfdbf6..fb466e6e6 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -157,7 +157,7 @@ def backfill_%(name)s(ndarray[%(c_type)s] old, ndarray[%(c_type)s] new,
     cdef Py_ssize_t i, j, nleft, nright
     cdef ndarray[int32_t, ndim=1] indexer
     cdef %(c_type)s cur, prev
-    cdef int lim
+    cdef int lim, fill_count = 0
 
     nleft = len(old)
     nright = len(new)
@@ -167,7 +167,8 @@ def backfill_%(name)s(ndarray[%(c_type)s] old, ndarray[%(c_type)s] new,
     if limit is None:
         lim = nright
     else:
-        # TODO: > 0?
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
         lim = limit
 
     if nleft == 0 or nright == 0 or new[0] > old[nleft - 1]:
@@ -186,17 +187,26 @@ def backfill_%(name)s(ndarray[%(c_type)s] old, ndarray[%(c_type)s] new,
             break
 
         if i == 0:
-            while j >= 0 and new[j] <= cur:
-                indexer[j] = i
+            while j >= 0:
+                if new[j] == cur:
+                    indexer[j] = i
+                elif new[j] < cur and fill_count < lim:
+                    indexer[j] = i
+                    fill_count += 1
                 j -= 1
             break
 
         prev = old[i - 1]
 
         while j >= 0 and prev < new[j] <= cur:
-            indexer[j] = i
+            if new[j] == cur:
+                indexer[j] = i
+            elif new[j] < cur and fill_count < lim:
+                indexer[j] = i
+                fill_count += 1
             j -= 1
 
+        fill_count = 0
         i -= 1
         cur = prev
 
@@ -204,28 +214,6 @@ def backfill_%(name)s(ndarray[%(c_type)s] old, ndarray[%(c_type)s] new,
 
 """
 
-'''
-Padding logic for generating fill vector
-
-Diagram of what's going on
-
-Old      New    Fill vector    Mask
-         .                        0
-         .                        0
-         .                        0
-A        A        0               1
-         .        0               1
-         .        0               1
-         .        0               1
-         .        0               1
-         .        0               1
-B        B        1               1
-         .        1               1
-         .        1               1
-         .        1               1
-C        C        2               1
-'''
-
 
 pad_template = """@cython.boundscheck(False)
 @cython.wraparound(False)
@@ -234,7 +222,7 @@ def pad_%(name)s(ndarray[%(c_type)s] old, ndarray[%(c_type)s] new,
     cdef Py_ssize_t i, j, nleft, nright
     cdef ndarray[int32_t, ndim=1] indexer
     cdef %(c_type)s cur, next
-    cdef int lim
+    cdef int lim, fill_count = 0
 
     nleft = len(old)
     nright = len(new)
@@ -244,7 +232,8 @@ def pad_%(name)s(ndarray[%(c_type)s] old, ndarray[%(c_type)s] new,
     if limit is None:
         lim = nright
     else:
-        # TODO: > 0?
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
         lim = limit
 
     if nleft == 0 or nright == 0 or new[nright - 1] < old[0]:
@@ -262,17 +251,26 @@ def pad_%(name)s(ndarray[%(c_type)s] old, ndarray[%(c_type)s] new,
             break
 
         if i == nleft - 1:
-            while j < nright and new[j] >= cur:
-                indexer[j] = i
+            while j < nright:
+                if new[j] == cur:
+                    indexer[j] = i
+                elif new[j] > cur and fill_count < lim:
+                    indexer[j] = i
+                    fill_count += 1
                 j += 1
             break
 
         next = old[i + 1]
 
         while j < nright and cur <= new[j] < next:
-            indexer[j] = i
+            if new[j] == cur:
+                indexer[j] = i
+            elif fill_count < lim:
+                indexer[j] = i
+                fill_count += 1
             j += 1
 
+        fill_count = 0
         i += 1
         cur = next
 
@@ -280,44 +278,132 @@ def pad_%(name)s(ndarray[%(c_type)s] old, ndarray[%(c_type)s] new,
 
 """
 
+pad_1d_template = """@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_inplace_%(name)s(ndarray[%(c_type)s] values,
+                         ndarray[uint8_t, cast=True] mask,
+                            limit=None):
+    cdef Py_ssize_t i, N
+    cdef %(c_type)s val
+    cdef int lim, fill_count = 0
+
+    N = len(values)
+    val = np.nan
+
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
+    val = values[0]
+    for i in range(N):
+        if mask[i]:
+            if fill_count >= lim:
+                continue
+            fill_count += 1
+            values[i] = val
+        else:
+            fill_count = 0
+            val = values[i]
+"""
+
 pad_2d_template = """@cython.boundscheck(False)
 @cython.wraparound(False)
 def pad_2d_inplace_%(name)s(ndarray[%(c_type)s, ndim=2] values,
-                            ndarray[uint8_t, ndim=2] mask):
+                            ndarray[uint8_t, ndim=2] mask,
+                            limit=None):
     cdef Py_ssize_t i, j, N, K
     cdef %(c_type)s val
+    cdef int lim, fill_count = 0
 
     K, N = (<object> values).shape
 
     val = np.nan
 
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
     for j in range(K):
+        fill_count = 0
         val = values[j, 0]
         for i in range(N):
             if mask[j, i]:
+                if fill_count >= lim:
+                    continue
+                fill_count += 1
                 values[j, i] = val
             else:
+                fill_count = 0
                 val = values[j, i]
 """
 
 backfill_2d_template = """@cython.boundscheck(False)
 @cython.wraparound(False)
 def backfill_2d_inplace_%(name)s(ndarray[%(c_type)s, ndim=2] values,
-                                 ndarray[uint8_t, ndim=2] mask):
+                                 ndarray[uint8_t, ndim=2] mask,
+                                 limit=None):
     cdef Py_ssize_t i, j, N, K
     cdef %(c_type)s val
+    cdef int lim, fill_count = 0
 
     K, N = (<object> values).shape
 
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
     for j in range(K):
+        fill_count = 0
         val = values[j, N - 1]
         for i in range(N - 1, -1 , -1):
             if mask[j, i]:
+                if fill_count >= lim:
+                    continue
+                fill_count += 1
                 values[j, i] = val
             else:
+                fill_count = 0
                 val = values[j, i]
 """
 
+backfill_1d_template = """@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_inplace_%(name)s(ndarray[%(c_type)s] values,
+                              ndarray[uint8_t, cast=True] mask,
+                              limit=None):
+    cdef Py_ssize_t i, N
+    cdef %(c_type)s val
+    cdef int lim, fill_count = 0
+
+    N = len(values)
+
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
+    val = values[N - 1]
+    for i in range(N - 1, -1 , -1):
+        if mask[i]:
+            if fill_count >= lim:
+                continue
+            fill_count += 1
+            values[i] = val
+        else:
+            fill_count = 0
+            val = values[i]
+"""
 
 is_monotonic_template = """@cython.boundscheck(False)
 @cython.wraparound(False)
@@ -693,6 +779,8 @@ def generate_from_template(template, ndim=1, exclude=None):
 templates_1d = [map_indices_template,
                 pad_template,
                 backfill_template,
+                pad_1d_template,
+                backfill_1d_template,
                 pad_2d_template,
                 backfill_2d_template,
                 take_1d_template,
diff --git a/pandas/src/generated.pyx b/pandas/src/generated.pyx
index 97041c706..c70019fda 100644
--- a/pandas/src/generated.pyx
+++ b/pandas/src/generated.pyx
@@ -116,7 +116,7 @@ def pad_float64(ndarray[float64_t] old, ndarray[float64_t] new,
     cdef Py_ssize_t i, j, nleft, nright
     cdef ndarray[int32_t, ndim=1] indexer
     cdef float64_t cur, next
-    cdef int lim
+    cdef int lim, fill_count = 0
 
     nleft = len(old)
     nright = len(new)
@@ -126,7 +126,8 @@ def pad_float64(ndarray[float64_t] old, ndarray[float64_t] new,
     if limit is None:
         lim = nright
     else:
-        # TODO: > 0?
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
         lim = limit
 
     if nleft == 0 or nright == 0 or new[nright - 1] < old[0]:
@@ -144,17 +145,26 @@ def pad_float64(ndarray[float64_t] old, ndarray[float64_t] new,
             break
 
         if i == nleft - 1:
-            while j < nright and new[j] >= cur:
-                indexer[j] = i
+            while j < nright:
+                if new[j] == cur:
+                    indexer[j] = i
+                elif new[j] > cur and fill_count < lim:
+                    indexer[j] = i
+                    fill_count += 1
                 j += 1
             break
 
         next = old[i + 1]
 
         while j < nright and cur <= new[j] < next:
-            indexer[j] = i
+            if new[j] == cur:
+                indexer[j] = i
+            elif fill_count < lim:
+                indexer[j] = i
+                fill_count += 1
             j += 1
 
+        fill_count = 0
         i += 1
         cur = next
 
@@ -167,7 +177,7 @@ def pad_object(ndarray[object] old, ndarray[object] new,
     cdef Py_ssize_t i, j, nleft, nright
     cdef ndarray[int32_t, ndim=1] indexer
     cdef object cur, next
-    cdef int lim
+    cdef int lim, fill_count = 0
 
     nleft = len(old)
     nright = len(new)
@@ -177,7 +187,8 @@ def pad_object(ndarray[object] old, ndarray[object] new,
     if limit is None:
         lim = nright
     else:
-        # TODO: > 0?
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
         lim = limit
 
     if nleft == 0 or nright == 0 or new[nright - 1] < old[0]:
@@ -195,17 +206,26 @@ def pad_object(ndarray[object] old, ndarray[object] new,
             break
 
         if i == nleft - 1:
-            while j < nright and new[j] >= cur:
-                indexer[j] = i
+            while j < nright:
+                if new[j] == cur:
+                    indexer[j] = i
+                elif new[j] > cur and fill_count < lim:
+                    indexer[j] = i
+                    fill_count += 1
                 j += 1
             break
 
         next = old[i + 1]
 
         while j < nright and cur <= new[j] < next:
-            indexer[j] = i
+            if new[j] == cur:
+                indexer[j] = i
+            elif fill_count < lim:
+                indexer[j] = i
+                fill_count += 1
             j += 1
 
+        fill_count = 0
         i += 1
         cur = next
 
@@ -218,7 +238,7 @@ def pad_int32(ndarray[int32_t] old, ndarray[int32_t] new,
     cdef Py_ssize_t i, j, nleft, nright
     cdef ndarray[int32_t, ndim=1] indexer
     cdef int32_t cur, next
-    cdef int lim
+    cdef int lim, fill_count = 0
 
     nleft = len(old)
     nright = len(new)
@@ -228,7 +248,8 @@ def pad_int32(ndarray[int32_t] old, ndarray[int32_t] new,
     if limit is None:
         lim = nright
     else:
-        # TODO: > 0?
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
         lim = limit
 
     if nleft == 0 or nright == 0 or new[nright - 1] < old[0]:
@@ -246,17 +267,26 @@ def pad_int32(ndarray[int32_t] old, ndarray[int32_t] new,
             break
 
         if i == nleft - 1:
-            while j < nright and new[j] >= cur:
-                indexer[j] = i
+            while j < nright:
+                if new[j] == cur:
+                    indexer[j] = i
+                elif new[j] > cur and fill_count < lim:
+                    indexer[j] = i
+                    fill_count += 1
                 j += 1
             break
 
         next = old[i + 1]
 
         while j < nright and cur <= new[j] < next:
-            indexer[j] = i
+            if new[j] == cur:
+                indexer[j] = i
+            elif fill_count < lim:
+                indexer[j] = i
+                fill_count += 1
             j += 1
 
+        fill_count = 0
         i += 1
         cur = next
 
@@ -269,7 +299,7 @@ def pad_int64(ndarray[int64_t] old, ndarray[int64_t] new,
     cdef Py_ssize_t i, j, nleft, nright
     cdef ndarray[int32_t, ndim=1] indexer
     cdef int64_t cur, next
-    cdef int lim
+    cdef int lim, fill_count = 0
 
     nleft = len(old)
     nright = len(new)
@@ -279,7 +309,8 @@ def pad_int64(ndarray[int64_t] old, ndarray[int64_t] new,
     if limit is None:
         lim = nright
     else:
-        # TODO: > 0?
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
         lim = limit
 
     if nleft == 0 or nright == 0 or new[nright - 1] < old[0]:
@@ -297,17 +328,26 @@ def pad_int64(ndarray[int64_t] old, ndarray[int64_t] new,
             break
 
         if i == nleft - 1:
-            while j < nright and new[j] >= cur:
-                indexer[j] = i
+            while j < nright:
+                if new[j] == cur:
+                    indexer[j] = i
+                elif new[j] > cur and fill_count < lim:
+                    indexer[j] = i
+                    fill_count += 1
                 j += 1
             break
 
         next = old[i + 1]
 
         while j < nright and cur <= new[j] < next:
-            indexer[j] = i
+            if new[j] == cur:
+                indexer[j] = i
+            elif fill_count < lim:
+                indexer[j] = i
+                fill_count += 1
             j += 1
 
+        fill_count = 0
         i += 1
         cur = next
 
@@ -320,7 +360,7 @@ def pad_bool(ndarray[uint8_t] old, ndarray[uint8_t] new,
     cdef Py_ssize_t i, j, nleft, nright
     cdef ndarray[int32_t, ndim=1] indexer
     cdef uint8_t cur, next
-    cdef int lim
+    cdef int lim, fill_count = 0
 
     nleft = len(old)
     nright = len(new)
@@ -330,7 +370,8 @@ def pad_bool(ndarray[uint8_t] old, ndarray[uint8_t] new,
     if limit is None:
         lim = nright
     else:
-        # TODO: > 0?
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
         lim = limit
 
     if nleft == 0 or nright == 0 or new[nright - 1] < old[0]:
@@ -348,17 +389,26 @@ def pad_bool(ndarray[uint8_t] old, ndarray[uint8_t] new,
             break
 
         if i == nleft - 1:
-            while j < nright and new[j] >= cur:
-                indexer[j] = i
+            while j < nright:
+                if new[j] == cur:
+                    indexer[j] = i
+                elif new[j] > cur and fill_count < lim:
+                    indexer[j] = i
+                    fill_count += 1
                 j += 1
             break
 
         next = old[i + 1]
 
         while j < nright and cur <= new[j] < next:
-            indexer[j] = i
+            if new[j] == cur:
+                indexer[j] = i
+            elif fill_count < lim:
+                indexer[j] = i
+                fill_count += 1
             j += 1
 
+        fill_count = 0
         i += 1
         cur = next
 
@@ -372,7 +422,7 @@ def backfill_float64(ndarray[float64_t] old, ndarray[float64_t] new,
     cdef Py_ssize_t i, j, nleft, nright
     cdef ndarray[int32_t, ndim=1] indexer
     cdef float64_t cur, prev
-    cdef int lim
+    cdef int lim, fill_count = 0
 
     nleft = len(old)
     nright = len(new)
@@ -382,7 +432,8 @@ def backfill_float64(ndarray[float64_t] old, ndarray[float64_t] new,
     if limit is None:
         lim = nright
     else:
-        # TODO: > 0?
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
         lim = limit
 
     if nleft == 0 or nright == 0 or new[0] > old[nleft - 1]:
@@ -401,17 +452,26 @@ def backfill_float64(ndarray[float64_t] old, ndarray[float64_t] new,
             break
 
         if i == 0:
-            while j >= 0 and new[j] <= cur:
-                indexer[j] = i
+            while j >= 0:
+                if new[j] == cur:
+                    indexer[j] = i
+                elif new[j] < cur and fill_count < lim:
+                    indexer[j] = i
+                    fill_count += 1
                 j -= 1
             break
 
         prev = old[i - 1]
 
         while j >= 0 and prev < new[j] <= cur:
-            indexer[j] = i
+            if new[j] == cur:
+                indexer[j] = i
+            elif new[j] < cur and fill_count < lim:
+                indexer[j] = i
+                fill_count += 1
             j -= 1
 
+        fill_count = 0
         i -= 1
         cur = prev
 
@@ -424,7 +484,7 @@ def backfill_object(ndarray[object] old, ndarray[object] new,
     cdef Py_ssize_t i, j, nleft, nright
     cdef ndarray[int32_t, ndim=1] indexer
     cdef object cur, prev
-    cdef int lim
+    cdef int lim, fill_count = 0
 
     nleft = len(old)
     nright = len(new)
@@ -434,7 +494,8 @@ def backfill_object(ndarray[object] old, ndarray[object] new,
     if limit is None:
         lim = nright
     else:
-        # TODO: > 0?
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
         lim = limit
 
     if nleft == 0 or nright == 0 or new[0] > old[nleft - 1]:
@@ -453,17 +514,26 @@ def backfill_object(ndarray[object] old, ndarray[object] new,
             break
 
         if i == 0:
-            while j >= 0 and new[j] <= cur:
-                indexer[j] = i
+            while j >= 0:
+                if new[j] == cur:
+                    indexer[j] = i
+                elif new[j] < cur and fill_count < lim:
+                    indexer[j] = i
+                    fill_count += 1
                 j -= 1
             break
 
         prev = old[i - 1]
 
         while j >= 0 and prev < new[j] <= cur:
-            indexer[j] = i
+            if new[j] == cur:
+                indexer[j] = i
+            elif new[j] < cur and fill_count < lim:
+                indexer[j] = i
+                fill_count += 1
             j -= 1
 
+        fill_count = 0
         i -= 1
         cur = prev
 
@@ -476,7 +546,7 @@ def backfill_int32(ndarray[int32_t] old, ndarray[int32_t] new,
     cdef Py_ssize_t i, j, nleft, nright
     cdef ndarray[int32_t, ndim=1] indexer
     cdef int32_t cur, prev
-    cdef int lim
+    cdef int lim, fill_count = 0
 
     nleft = len(old)
     nright = len(new)
@@ -486,7 +556,8 @@ def backfill_int32(ndarray[int32_t] old, ndarray[int32_t] new,
     if limit is None:
         lim = nright
     else:
-        # TODO: > 0?
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
         lim = limit
 
     if nleft == 0 or nright == 0 or new[0] > old[nleft - 1]:
@@ -505,17 +576,26 @@ def backfill_int32(ndarray[int32_t] old, ndarray[int32_t] new,
             break
 
         if i == 0:
-            while j >= 0 and new[j] <= cur:
-                indexer[j] = i
+            while j >= 0:
+                if new[j] == cur:
+                    indexer[j] = i
+                elif new[j] < cur and fill_count < lim:
+                    indexer[j] = i
+                    fill_count += 1
                 j -= 1
             break
 
         prev = old[i - 1]
 
         while j >= 0 and prev < new[j] <= cur:
-            indexer[j] = i
+            if new[j] == cur:
+                indexer[j] = i
+            elif new[j] < cur and fill_count < lim:
+                indexer[j] = i
+                fill_count += 1
             j -= 1
 
+        fill_count = 0
         i -= 1
         cur = prev
 
@@ -528,7 +608,7 @@ def backfill_int64(ndarray[int64_t] old, ndarray[int64_t] new,
     cdef Py_ssize_t i, j, nleft, nright
     cdef ndarray[int32_t, ndim=1] indexer
     cdef int64_t cur, prev
-    cdef int lim
+    cdef int lim, fill_count = 0
 
     nleft = len(old)
     nright = len(new)
@@ -538,7 +618,8 @@ def backfill_int64(ndarray[int64_t] old, ndarray[int64_t] new,
     if limit is None:
         lim = nright
     else:
-        # TODO: > 0?
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
         lim = limit
 
     if nleft == 0 or nright == 0 or new[0] > old[nleft - 1]:
@@ -557,17 +638,26 @@ def backfill_int64(ndarray[int64_t] old, ndarray[int64_t] new,
             break
 
         if i == 0:
-            while j >= 0 and new[j] <= cur:
-                indexer[j] = i
+            while j >= 0:
+                if new[j] == cur:
+                    indexer[j] = i
+                elif new[j] < cur and fill_count < lim:
+                    indexer[j] = i
+                    fill_count += 1
                 j -= 1
             break
 
         prev = old[i - 1]
 
         while j >= 0 and prev < new[j] <= cur:
-            indexer[j] = i
+            if new[j] == cur:
+                indexer[j] = i
+            elif new[j] < cur and fill_count < lim:
+                indexer[j] = i
+                fill_count += 1
             j -= 1
 
+        fill_count = 0
         i -= 1
         cur = prev
 
@@ -580,7 +670,7 @@ def backfill_bool(ndarray[uint8_t] old, ndarray[uint8_t] new,
     cdef Py_ssize_t i, j, nleft, nright
     cdef ndarray[int32_t, ndim=1] indexer
     cdef uint8_t cur, prev
-    cdef int lim
+    cdef int lim, fill_count = 0
 
     nleft = len(old)
     nright = len(new)
@@ -590,7 +680,8 @@ def backfill_bool(ndarray[uint8_t] old, ndarray[uint8_t] new,
     if limit is None:
         lim = nright
     else:
-        # TODO: > 0?
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
         lim = limit
 
     if nleft == 0 or nright == 0 or new[0] > old[nleft - 1]:
@@ -609,198 +700,635 @@ def backfill_bool(ndarray[uint8_t] old, ndarray[uint8_t] new,
             break
 
         if i == 0:
-            while j >= 0 and new[j] <= cur:
-                indexer[j] = i
+            while j >= 0:
+                if new[j] == cur:
+                    indexer[j] = i
+                elif new[j] < cur and fill_count < lim:
+                    indexer[j] = i
+                    fill_count += 1
                 j -= 1
             break
 
         prev = old[i - 1]
 
         while j >= 0 and prev < new[j] <= cur:
-            indexer[j] = i
+            if new[j] == cur:
+                indexer[j] = i
+            elif new[j] < cur and fill_count < lim:
+                indexer[j] = i
+                fill_count += 1
             j -= 1
 
+        fill_count = 0
         i -= 1
         cur = prev
 
     return indexer
 
 
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_inplace_float64(ndarray[float64_t] values,
+                         ndarray[uint8_t, cast=True] mask,
+                            limit=None):
+    cdef Py_ssize_t i, N
+    cdef float64_t val
+    cdef int lim, fill_count = 0
+
+    N = len(values)
+    val = np.nan
+
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
+    val = values[0]
+    for i in range(N):
+        if mask[i]:
+            if fill_count >= lim:
+                continue
+            fill_count += 1
+            values[i] = val
+        else:
+            fill_count = 0
+            val = values[i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_inplace_object(ndarray[object] values,
+                         ndarray[uint8_t, cast=True] mask,
+                            limit=None):
+    cdef Py_ssize_t i, N
+    cdef object val
+    cdef int lim, fill_count = 0
+
+    N = len(values)
+    val = np.nan
+
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
+    val = values[0]
+    for i in range(N):
+        if mask[i]:
+            if fill_count >= lim:
+                continue
+            fill_count += 1
+            values[i] = val
+        else:
+            fill_count = 0
+            val = values[i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_inplace_int32(ndarray[int32_t] values,
+                         ndarray[uint8_t, cast=True] mask,
+                            limit=None):
+    cdef Py_ssize_t i, N
+    cdef int32_t val
+    cdef int lim, fill_count = 0
+
+    N = len(values)
+    val = np.nan
+
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
+    val = values[0]
+    for i in range(N):
+        if mask[i]:
+            if fill_count >= lim:
+                continue
+            fill_count += 1
+            values[i] = val
+        else:
+            fill_count = 0
+            val = values[i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_inplace_int64(ndarray[int64_t] values,
+                         ndarray[uint8_t, cast=True] mask,
+                            limit=None):
+    cdef Py_ssize_t i, N
+    cdef int64_t val
+    cdef int lim, fill_count = 0
+
+    N = len(values)
+    val = np.nan
+
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
+    val = values[0]
+    for i in range(N):
+        if mask[i]:
+            if fill_count >= lim:
+                continue
+            fill_count += 1
+            values[i] = val
+        else:
+            fill_count = 0
+            val = values[i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def pad_inplace_bool(ndarray[uint8_t] values,
+                         ndarray[uint8_t, cast=True] mask,
+                            limit=None):
+    cdef Py_ssize_t i, N
+    cdef uint8_t val
+    cdef int lim, fill_count = 0
+
+    N = len(values)
+    val = np.nan
+
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
+    val = values[0]
+    for i in range(N):
+        if mask[i]:
+            if fill_count >= lim:
+                continue
+            fill_count += 1
+            values[i] = val
+        else:
+            fill_count = 0
+            val = values[i]
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_inplace_float64(ndarray[float64_t] values,
+                              ndarray[uint8_t, cast=True] mask,
+                              limit=None):
+    cdef Py_ssize_t i, N
+    cdef float64_t val
+    cdef int lim, fill_count = 0
+
+    N = len(values)
+
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
+    val = values[N - 1]
+    for i in range(N - 1, -1 , -1):
+        if mask[i]:
+            if fill_count >= lim:
+                continue
+            fill_count += 1
+            values[i] = val
+        else:
+            fill_count = 0
+            val = values[i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_inplace_object(ndarray[object] values,
+                              ndarray[uint8_t, cast=True] mask,
+                              limit=None):
+    cdef Py_ssize_t i, N
+    cdef object val
+    cdef int lim, fill_count = 0
+
+    N = len(values)
+
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
+    val = values[N - 1]
+    for i in range(N - 1, -1 , -1):
+        if mask[i]:
+            if fill_count >= lim:
+                continue
+            fill_count += 1
+            values[i] = val
+        else:
+            fill_count = 0
+            val = values[i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_inplace_int32(ndarray[int32_t] values,
+                              ndarray[uint8_t, cast=True] mask,
+                              limit=None):
+    cdef Py_ssize_t i, N
+    cdef int32_t val
+    cdef int lim, fill_count = 0
+
+    N = len(values)
+
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
+    val = values[N - 1]
+    for i in range(N - 1, -1 , -1):
+        if mask[i]:
+            if fill_count >= lim:
+                continue
+            fill_count += 1
+            values[i] = val
+        else:
+            fill_count = 0
+            val = values[i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_inplace_int64(ndarray[int64_t] values,
+                              ndarray[uint8_t, cast=True] mask,
+                              limit=None):
+    cdef Py_ssize_t i, N
+    cdef int64_t val
+    cdef int lim, fill_count = 0
+
+    N = len(values)
+
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
+    val = values[N - 1]
+    for i in range(N - 1, -1 , -1):
+        if mask[i]:
+            if fill_count >= lim:
+                continue
+            fill_count += 1
+            values[i] = val
+        else:
+            fill_count = 0
+            val = values[i]
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def backfill_inplace_bool(ndarray[uint8_t] values,
+                              ndarray[uint8_t, cast=True] mask,
+                              limit=None):
+    cdef Py_ssize_t i, N
+    cdef uint8_t val
+    cdef int lim, fill_count = 0
+
+    N = len(values)
+
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
+    val = values[N - 1]
+    for i in range(N - 1, -1 , -1):
+        if mask[i]:
+            if fill_count >= lim:
+                continue
+            fill_count += 1
+            values[i] = val
+        else:
+            fill_count = 0
+            val = values[i]
+
 @cython.boundscheck(False)
 @cython.wraparound(False)
 def pad_2d_inplace_float64(ndarray[float64_t, ndim=2] values,
-                            ndarray[uint8_t, ndim=2] mask):
+                            ndarray[uint8_t, ndim=2] mask,
+                            limit=None):
     cdef Py_ssize_t i, j, N, K
     cdef float64_t val
+    cdef int lim, fill_count = 0
 
     K, N = (<object> values).shape
 
     val = np.nan
 
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
     for j in range(K):
+        fill_count = 0
         val = values[j, 0]
         for i in range(N):
             if mask[j, i]:
+                if fill_count >= lim:
+                    continue
+                fill_count += 1
                 values[j, i] = val
             else:
+                fill_count = 0
                 val = values[j, i]
 @cython.boundscheck(False)
 @cython.wraparound(False)
 def pad_2d_inplace_object(ndarray[object, ndim=2] values,
-                            ndarray[uint8_t, ndim=2] mask):
+                            ndarray[uint8_t, ndim=2] mask,
+                            limit=None):
     cdef Py_ssize_t i, j, N, K
     cdef object val
+    cdef int lim, fill_count = 0
 
     K, N = (<object> values).shape
 
     val = np.nan
 
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
     for j in range(K):
+        fill_count = 0
         val = values[j, 0]
         for i in range(N):
             if mask[j, i]:
+                if fill_count >= lim:
+                    continue
+                fill_count += 1
                 values[j, i] = val
             else:
+                fill_count = 0
                 val = values[j, i]
 @cython.boundscheck(False)
 @cython.wraparound(False)
 def pad_2d_inplace_int32(ndarray[int32_t, ndim=2] values,
-                            ndarray[uint8_t, ndim=2] mask):
+                            ndarray[uint8_t, ndim=2] mask,
+                            limit=None):
     cdef Py_ssize_t i, j, N, K
     cdef int32_t val
+    cdef int lim, fill_count = 0
 
     K, N = (<object> values).shape
 
     val = np.nan
 
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
     for j in range(K):
+        fill_count = 0
         val = values[j, 0]
         for i in range(N):
             if mask[j, i]:
+                if fill_count >= lim:
+                    continue
+                fill_count += 1
                 values[j, i] = val
             else:
+                fill_count = 0
                 val = values[j, i]
 @cython.boundscheck(False)
 @cython.wraparound(False)
 def pad_2d_inplace_int64(ndarray[int64_t, ndim=2] values,
-                            ndarray[uint8_t, ndim=2] mask):
+                            ndarray[uint8_t, ndim=2] mask,
+                            limit=None):
     cdef Py_ssize_t i, j, N, K
     cdef int64_t val
+    cdef int lim, fill_count = 0
 
     K, N = (<object> values).shape
 
     val = np.nan
 
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
     for j in range(K):
+        fill_count = 0
         val = values[j, 0]
         for i in range(N):
             if mask[j, i]:
+                if fill_count >= lim:
+                    continue
+                fill_count += 1
                 values[j, i] = val
             else:
+                fill_count = 0
                 val = values[j, i]
 @cython.boundscheck(False)
 @cython.wraparound(False)
 def pad_2d_inplace_bool(ndarray[uint8_t, ndim=2] values,
-                            ndarray[uint8_t, ndim=2] mask):
+                            ndarray[uint8_t, ndim=2] mask,
+                            limit=None):
     cdef Py_ssize_t i, j, N, K
     cdef uint8_t val
+    cdef int lim, fill_count = 0
 
     K, N = (<object> values).shape
 
     val = np.nan
 
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
     for j in range(K):
+        fill_count = 0
         val = values[j, 0]
         for i in range(N):
             if mask[j, i]:
+                if fill_count >= lim:
+                    continue
+                fill_count += 1
                 values[j, i] = val
             else:
+                fill_count = 0
                 val = values[j, i]
 
 @cython.boundscheck(False)
 @cython.wraparound(False)
 def backfill_2d_inplace_float64(ndarray[float64_t, ndim=2] values,
-                                 ndarray[uint8_t, ndim=2] mask):
+                                 ndarray[uint8_t, ndim=2] mask,
+                                 limit=None):
     cdef Py_ssize_t i, j, N, K
     cdef float64_t val
+    cdef int lim, fill_count = 0
 
     K, N = (<object> values).shape
 
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
     for j in range(K):
+        fill_count = 0
         val = values[j, N - 1]
         for i in range(N - 1, -1 , -1):
             if mask[j, i]:
+                if fill_count >= lim:
+                    continue
+                fill_count += 1
                 values[j, i] = val
             else:
+                fill_count = 0
                 val = values[j, i]
 @cython.boundscheck(False)
 @cython.wraparound(False)
 def backfill_2d_inplace_object(ndarray[object, ndim=2] values,
-                                 ndarray[uint8_t, ndim=2] mask):
+                                 ndarray[uint8_t, ndim=2] mask,
+                                 limit=None):
     cdef Py_ssize_t i, j, N, K
     cdef object val
+    cdef int lim, fill_count = 0
 
     K, N = (<object> values).shape
 
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
     for j in range(K):
+        fill_count = 0
         val = values[j, N - 1]
         for i in range(N - 1, -1 , -1):
             if mask[j, i]:
+                if fill_count >= lim:
+                    continue
+                fill_count += 1
                 values[j, i] = val
             else:
+                fill_count = 0
                 val = values[j, i]
 @cython.boundscheck(False)
 @cython.wraparound(False)
 def backfill_2d_inplace_int32(ndarray[int32_t, ndim=2] values,
-                                 ndarray[uint8_t, ndim=2] mask):
+                                 ndarray[uint8_t, ndim=2] mask,
+                                 limit=None):
     cdef Py_ssize_t i, j, N, K
     cdef int32_t val
+    cdef int lim, fill_count = 0
 
     K, N = (<object> values).shape
 
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
     for j in range(K):
+        fill_count = 0
         val = values[j, N - 1]
         for i in range(N - 1, -1 , -1):
             if mask[j, i]:
+                if fill_count >= lim:
+                    continue
+                fill_count += 1
                 values[j, i] = val
             else:
+                fill_count = 0
                 val = values[j, i]
 @cython.boundscheck(False)
 @cython.wraparound(False)
 def backfill_2d_inplace_int64(ndarray[int64_t, ndim=2] values,
-                                 ndarray[uint8_t, ndim=2] mask):
+                                 ndarray[uint8_t, ndim=2] mask,
+                                 limit=None):
     cdef Py_ssize_t i, j, N, K
     cdef int64_t val
+    cdef int lim, fill_count = 0
 
     K, N = (<object> values).shape
 
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
     for j in range(K):
+        fill_count = 0
         val = values[j, N - 1]
         for i in range(N - 1, -1 , -1):
             if mask[j, i]:
+                if fill_count >= lim:
+                    continue
+                fill_count += 1
                 values[j, i] = val
             else:
+                fill_count = 0
                 val = values[j, i]
 @cython.boundscheck(False)
 @cython.wraparound(False)
 def backfill_2d_inplace_bool(ndarray[uint8_t, ndim=2] values,
-                                 ndarray[uint8_t, ndim=2] mask):
+                                 ndarray[uint8_t, ndim=2] mask,
+                                 limit=None):
     cdef Py_ssize_t i, j, N, K
     cdef uint8_t val
+    cdef int lim, fill_count = 0
 
     K, N = (<object> values).shape
 
+    if limit is None:
+        lim = N
+    else:
+        if limit < 0:
+            raise ValueError('Limit must be non-negative')
+        lim = limit
+
     for j in range(K):
+        fill_count = 0
         val = values[j, N - 1]
         for i in range(N - 1, -1 , -1):
             if mask[j, i]:
+                if fill_count >= lim:
+                    continue
+                fill_count += 1
                 values[j, i] = val
             else:
+                fill_count = 0
                 val = values[j, i]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_1d_float64(ndarray[float64_t] values, ndarray[int32_t] indexer,
+def take_1d_float64(ndarray[float64_t] values,
+                     ndarray[int32_t] indexer,
                      out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, n, idx
@@ -832,7 +1360,8 @@ def take_1d_float64(ndarray[float64_t] values, ndarray[int32_t] indexer,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_1d_object(ndarray[object] values, ndarray[int32_t] indexer,
+def take_1d_object(ndarray[object] values,
+                     ndarray[int32_t] indexer,
                      out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, n, idx
@@ -864,7 +1393,8 @@ def take_1d_object(ndarray[object] values, ndarray[int32_t] indexer,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_1d_int32(ndarray[int32_t] values, ndarray[int32_t] indexer,
+def take_1d_int32(ndarray[int32_t] values,
+                     ndarray[int32_t] indexer,
                      out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, n, idx
@@ -896,7 +1426,8 @@ def take_1d_int32(ndarray[int32_t] values, ndarray[int32_t] indexer,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_1d_int64(ndarray[int64_t] values, ndarray[int32_t] indexer,
+def take_1d_int64(ndarray[int64_t] values,
+                     ndarray[int32_t] indexer,
                      out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, n, idx
@@ -928,7 +1459,8 @@ def take_1d_int64(ndarray[int64_t] values, ndarray[int32_t] indexer,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def take_1d_bool(ndarray[uint8_t] values, ndarray[int32_t] indexer,
+def take_1d_bool(ndarray[uint8_t] values,
+                     ndarray[int32_t] indexer,
                      out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, n, idx
diff --git a/pandas/src/reindex.pyx b/pandas/src/reindex.pyx
index 4ca19f77f..c255aa5cd 100644
--- a/pandas/src/reindex.pyx
+++ b/pandas/src/reindex.pyx
@@ -1,90 +1,3 @@
-def pad_inplace_float64(ndarray[float64_t] values,
-                        ndarray[np.uint8_t, cast=True] mask):
-    '''
-    mask: True if needs to be padded otherwise False
-
-    e.g.
-    pad_inplace_float64(values, isnull(values))
-    '''
-    cdef:
-        Py_ssize_t i, n
-        float64_t val
-
-    n = len(values)
-    val = NaN
-    for i from 0 <= i < n:
-        if mask[i]:
-            values[i] = val
-        else:
-            val = values[i]
-
-def get_pad_indexer(ndarray[np.uint8_t, cast=True] mask):
-    '''
-    mask: True if needs to be padded otherwise False
-
-    e.g.
-    pad_inplace_float64(values, isnull(values))
-    '''
-    cdef:
-        Py_ssize_t i, n
-        int32_t idx
-        ndarray[int32_t] indexer
-
-    n = len(mask)
-    indexer = np.empty(n, dtype=np.int32)
-
-    idx = 0
-    for i from 0 <= i < n:
-        if not mask[i]:
-            idx = i
-        indexer[i] = idx
-
-    return indexer
-
-def get_backfill_indexer(ndarray[np.uint8_t, cast=True] mask):
-    '''
-    mask: True if needs to be padded otherwise False
-
-    e.g.
-    pad_inplace_float64(values, isnull(values))
-    '''
-    cdef:
-        Py_ssize_t i, n
-        int32_t idx
-        ndarray[int32_t] indexer
-
-    n = len(mask)
-    indexer = np.empty(n, dtype=np.int32)
-
-    idx = n - 1
-    i = n - 1
-    while i >= 0:
-        if not mask[i]:
-            idx = i
-        indexer[i] = idx
-        i -= 1
-
-    return indexer
-
-def backfill_inplace_float64(ndarray[float64_t] values,
-                             ndarray[np.uint8_t, cast=True] mask):
-    '''
-    mask: True if needs to be backfilled otherwise False
-    '''
-    cdef:
-        Py_ssize_t i, n
-        float64_t val
-
-    n = len(values)
-    val = NaN
-    i = n - 1
-    while i >= 0:
-        if mask[i]:
-            values[i] = val
-        else:
-            val = values[i]
-        i -= 1
-
 def ordered_left_join(ndarray[object] left, ndarray[object] right):
     # cdef dict right_map = map_indices_buf(right)
     # return merge_indexer(left, right_map)
@@ -224,21 +137,3 @@ def take_join_contiguous(ndarray[float64_t, ndim=2] lvalues,
             for j from 0 <= j < rk:
                 outbuf[0] = rvalues[ridx, j]
                 outbuf = outbuf + 1
-
-@cython.wraparound(False)
-@cython.boundscheck(False)
-def merge_indexer_list(list values, dict oldMap):
-    cdef int i, j, length, newLength
-    cdef object idx
-    cdef ndarray[int32_t] fill_vec
-
-    newLength = len(values)
-    fill_vec = np.empty(newLength, dtype=np.int32)
-    for i from 0 <= i < newLength:
-        idx = values[i]
-        if idx in oldMap:
-            fill_vec[i] = oldMap[idx]
-        else:
-            fill_vec[i] = -1
-
-    return fill_vec
diff --git a/pandas/tests/test_timeseries.py b/pandas/tests/test_timeseries.py
index 455166f37..f5af47ebf 100644
--- a/pandas/tests/test_timeseries.py
+++ b/pandas/tests/test_timeseries.py
@@ -81,6 +81,76 @@ class TestTimeSeriesDuplicates(unittest.TestCase):
         expected = s[indexer[0]]
         assert_series_equal(result, expected)
 
+    def test_series_pad_backfill_limit(self):
+        index = np.arange(10)
+        s = Series(np.random.randn(10), index=index)
+
+        result = s[:2].reindex(index, method='pad', limit=5)
+
+        expected = s[:2].reindex(index).fillna(method='pad')
+        expected[-3:] = np.nan
+        assert_series_equal(result, expected)
+
+        result = s[-2:].reindex(index, method='backfill', limit=5)
+
+        expected = s[-2:].reindex(index).fillna(method='backfill')
+        expected[:3] = np.nan
+        assert_series_equal(result, expected)
+
+    def test_series_fillna_limit(self):
+        index = np.arange(10)
+        s = Series(np.random.randn(10), index=index)
+
+        result = s[:2].reindex(index)
+        result = result.fillna(method='pad', limit=5)
+
+        expected = s[:2].reindex(index).fillna(method='pad')
+        expected[-3:] = np.nan
+        assert_series_equal(result, expected)
+
+        result = s[-2:].reindex(index)
+        result = result.fillna(method='bfill', limit=5)
+
+        expected = s[-2:].reindex(index).fillna(method='backfill')
+        expected[:3] = np.nan
+        assert_series_equal(result, expected)
+
+    def test_frame_pad_backfill_limit(self):
+        index = np.arange(10)
+        df = DataFrame(np.random.randn(10, 4), index=index)
+
+        result = df[:2].reindex(index, method='pad', limit=5)
+
+        expected = df[:2].reindex(index).fillna(method='pad')
+        expected.values[-3:] = np.nan
+        tm.assert_frame_equal(result, expected)
+
+        result = df[-2:].reindex(index, method='backfill', limit=5)
+
+        expected = df[-2:].reindex(index).fillna(method='backfill')
+        expected.values[:3] = np.nan
+        tm.assert_frame_equal(result, expected)
+
+    def test_frame_fillna_limit(self):
+        index = np.arange(10)
+        df = DataFrame(np.random.randn(10, 4), index=index)
+
+        result = df[:2].reindex(index)
+        result = result.fillna(method='pad', limit=5)
+
+        expected = df[:2].reindex(index).fillna(method='pad')
+        expected.values[-3:] = np.nan
+        tm.assert_frame_equal(result, expected)
+
+        result = df[-2:].reindex(index)
+        result = result.fillna(method='backfill', limit=5)
+
+        expected = df[-2:].reindex(index).fillna(method='backfill')
+        expected.values[:3] = np.nan
+        tm.assert_frame_equal(result, expected)
+
+
+
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)

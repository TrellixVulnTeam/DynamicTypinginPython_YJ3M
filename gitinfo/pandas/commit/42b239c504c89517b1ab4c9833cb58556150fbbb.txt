commit 42b239c504c89517b1ab4c9833cb58556150fbbb
Author: MomIsBestFriend <50263213+MomIsBestFriend@users.noreply.github.com>
Date:   Mon Dec 2 03:24:12 2019 +0200

    repr() (#29950)

diff --git a/pandas/core/computation/pytables.py b/pandas/core/computation/pytables.py
index 65e38ff29..8eef37a35 100644
--- a/pandas/core/computation/pytables.py
+++ b/pandas/core/computation/pytables.py
@@ -52,7 +52,7 @@ class Term(ops.Term):
         if self.side == "left":
             # Note: The behavior of __new__ ensures that self.name is a str here
             if self.name not in self.env.queryables:
-                raise NameError("name {name!r} is not defined".format(name=self.name))
+                raise NameError(f"name {repr(self.name)} is not defined")
             return self.name
 
         # resolve the rhs (and allow it to be None)
@@ -431,10 +431,7 @@ class PyTablesExprVisitor(BaseExprVisitor):
         try:
             return self.const_type(value[slobj], self.env)
         except TypeError:
-            raise ValueError(
-                "cannot subscript {value!r} with "
-                "{slobj!r}".format(value=value, slobj=slobj)
-            )
+            raise ValueError(f"cannot subscript {repr(value)} with {repr(slobj)}")
 
     def visit_Attribute(self, node, **kwargs):
         attr = node.attr
diff --git a/pandas/core/dtypes/common.py b/pandas/core/dtypes/common.py
index 43810df18..602d7d0da 100644
--- a/pandas/core/dtypes/common.py
+++ b/pandas/core/dtypes/common.py
@@ -1861,8 +1861,10 @@ def _validate_date_like_dtype(dtype) -> None:
     except ValueError as e:
         raise TypeError("{error}".format(error=e))
     if typ != "generic" and typ != "ns":
-        msg = "{name!r} is too specific of a frequency, try passing {type!r}"
-        raise ValueError(msg.format(name=dtype.name, type=dtype.type.__name__))
+        raise ValueError(
+            f"{repr(dtype.name)} is too specific of a frequency, "
+            f"try passing {repr(dtype.type.__name__)}"
+        )
 
 
 def pandas_dtype(dtype):
diff --git a/pandas/core/dtypes/dtypes.py b/pandas/core/dtypes/dtypes.py
index 89e80b3b4..6dc2b098f 100644
--- a/pandas/core/dtypes/dtypes.py
+++ b/pandas/core/dtypes/dtypes.py
@@ -319,8 +319,7 @@ class CategoricalDtype(PandasExtensionDtype, ExtensionDtype):
                 if dtype == "category":
                     dtype = CategoricalDtype(categories, ordered)
                 else:
-                    msg = "Unknown dtype {dtype!r}"
-                    raise ValueError(msg.format(dtype=dtype))
+                    raise ValueError(f"Unknown dtype {repr(dtype)}")
             elif categories is not None or ordered is not None:
                 raise ValueError(
                     "Cannot specify `categories` or `ordered` together with `dtype`."
@@ -512,8 +511,9 @@ class CategoricalDtype(PandasExtensionDtype, ExtensionDtype):
         from pandas.core.indexes.base import Index
 
         if not fastpath and not is_list_like(categories):
-            msg = "Parameter 'categories' must be list-like, was {!r}"
-            raise TypeError(msg.format(categories))
+            raise TypeError(
+                f"Parameter 'categories' must be list-like, was {repr(categories)}"
+            )
         elif not isinstance(categories, ABCIndexClass):
             categories = Index(categories, tupleize_cols=False)
 
@@ -549,11 +549,10 @@ class CategoricalDtype(PandasExtensionDtype, ExtensionDtype):
             # dtype='category' should not change anything
             return self
         elif not self.is_dtype(dtype):
-            msg = (
-                "a CategoricalDtype must be passed to perform an update, "
-                "got {dtype!r}"
-            ).format(dtype=dtype)
-            raise ValueError(msg)
+            raise ValueError(
+                f"a CategoricalDtype must be passed to perform an update, "
+                f"got {repr(dtype)}"
+            )
         else:
             # from here on, dtype is a CategoricalDtype
             dtype = cast(CategoricalDtype, dtype)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 0b690363a..fde3d1657 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -8123,10 +8123,9 @@ class DataFrame(NDFrame):
         else:
             if not is_list_like(values):
                 raise TypeError(
-                    "only list-like or dict-like objects are "
-                    "allowed to be passed to DataFrame.isin(), "
-                    "you passed a "
-                    "{0!r}".format(type(values).__name__)
+                    f"only list-like or dict-like objects are allowed "
+                    f"to be passed to DataFrame.isin(), "
+                    f"you passed a {repr(type(values).__name__)}"
                 )
             return DataFrame(
                 algorithms.isin(self.values.ravel(), values).reshape(self.shape),
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 59fd35666..e19bf9c1c 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -1864,8 +1864,8 @@ class NDFrame(PandasObject, SelectionMixin):
 
     def __hash__(self):
         raise TypeError(
-            "{0!r} objects are mutable, thus they cannot be"
-            " hashed".format(type(self).__name__)
+            f"{repr(type(self).__name__)} objects are mutable, "
+            f"thus they cannot be hashed"
         )
 
     def __iter__(self):
@@ -6567,11 +6567,9 @@ class NDFrame(PandasObject, SelectionMixin):
                     or is_dict_like(regex)
                 ):
                     raise TypeError(
-                        "'regex' must be a string or a compiled "
-                        "regular expression or a list or dict of "
-                        "strings or regular expressions, you "
-                        "passed a"
-                        " {0!r}".format(type(regex).__name__)
+                        f"'regex' must be a string or a compiled regular expression "
+                        f"or a list or dict of strings or regular expressions, "
+                        f"you passed a {repr(type(regex).__name__)}"
                     )
                 return self.replace(
                     regex, value, inplace=inplace, limit=limit, regex=True
@@ -6597,10 +6595,9 @@ class NDFrame(PandasObject, SelectionMixin):
                         to_replace=to_replace, value=value, inplace=inplace, regex=regex
                     )
                 else:
-                    msg = ('Invalid "to_replace" type: ' "{0!r}").format(
-                        type(to_replace).__name__
+                    raise TypeError(
+                        f'Invalid "to_replace" type: {repr(type(to_replace).__name__)}'
                     )
-                    raise TypeError(msg)  # pragma: no cover
 
         if inplace:
             self._update_inplace(new_data)
diff --git a/pandas/core/groupby/grouper.py b/pandas/core/groupby/grouper.py
index 9b2f43d8d..b0df04f18 100644
--- a/pandas/core/groupby/grouper.py
+++ b/pandas/core/groupby/grouper.py
@@ -206,7 +206,7 @@ class Grouper:
 
     def __repr__(self) -> str:
         attrs_list = (
-            f"{attr_name}={getattr(self, attr_name)!r}"
+            f"{attr_name}={repr(getattr(self, attr_name))}"
             for attr_name in self._attributes
             if getattr(self, attr_name) is not None
         )
diff --git a/pandas/core/indexes/datetimelike.py b/pandas/core/indexes/datetimelike.py
index 9dcf62d47..eb3728c1e 100644
--- a/pandas/core/indexes/datetimelike.py
+++ b/pandas/core/indexes/datetimelike.py
@@ -475,7 +475,7 @@ class DatetimeIndexOpsMixin(ExtensionOpsMixin):
             if attrib == "freq":
                 freq = self.freqstr
                 if freq is not None:
-                    freq = f"{freq!r}"
+                    freq = repr(freq)
                 attrs.append(("freq", freq))
         return attrs
 
diff --git a/pandas/core/indexes/interval.py b/pandas/core/indexes/interval.py
index 56957b2f8..2555caac2 100644
--- a/pandas/core/indexes/interval.py
+++ b/pandas/core/indexes/interval.py
@@ -83,9 +83,7 @@ def _get_next_label(label):
     elif is_float_dtype(dtype):
         return np.nextafter(label, np.infty)
     else:
-        raise TypeError(
-            "cannot determine next label for type {typ!r}".format(typ=type(label))
-        )
+        raise TypeError(f"cannot determine next label for type {repr(type(label))}")
 
 
 def _get_prev_label(label):
@@ -99,9 +97,7 @@ def _get_prev_label(label):
     elif is_float_dtype(dtype):
         return np.nextafter(label, -np.infty)
     else:
-        raise TypeError(
-            "cannot determine next label for type {typ!r}".format(typ=type(label))
-        )
+        raise TypeError(f"cannot determine next label for type {repr(type(label))}")
 
 
 def _get_interval_closed_bounds(interval):
diff --git a/pandas/core/internals/concat.py b/pandas/core/internals/concat.py
index 6c4ab2882..7cb693474 100644
--- a/pandas/core/internals/concat.py
+++ b/pandas/core/internals/concat.py
@@ -121,9 +121,7 @@ class JoinUnit:
         self.shape = shape
 
     def __repr__(self) -> str:
-        return "{name}({block!r}, {indexers})".format(
-            name=type(self).__name__, block=self.block, indexers=self.indexers
-        )
+        return f"{type(self).__name__}({repr(self.block)}, {self.indexers})"
 
     @cache_readonly
     def needs_filling(self):
diff --git a/pandas/core/internals/managers.py b/pandas/core/internals/managers.py
index 9adfe41b6..f312b88d9 100644
--- a/pandas/core/internals/managers.py
+++ b/pandas/core/internals/managers.py
@@ -1905,9 +1905,7 @@ def _compare_or_regex_search(a, b, regex=False):
             type_names[1] = "ndarray(dtype={dtype})".format(dtype=b.dtype)
 
         raise TypeError(
-            "Cannot compare types {a!r} and {b!r}".format(
-                a=type_names[0], b=type_names[1]
-            )
+            f"Cannot compare types {repr(type_names[0])} and {repr(type_names[1])}"
         )
     return result
 

commit a359a99595a27b9fb36daa8e299a27e2621ba743
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon Jul 8 05:43:10 2019 -0700

    BUG: Fix+test division by negative zero (#27278)

diff --git a/pandas/core/arrays/integer.py b/pandas/core/arrays/integer.py
index c999c4db2..867122964 100644
--- a/pandas/core/arrays/integer.py
+++ b/pandas/core/arrays/integer.py
@@ -1,5 +1,4 @@
 import numbers
-import sys
 from typing import Type
 import warnings
 
@@ -675,7 +674,7 @@ class IntegerArray(ExtensionArray, ExtensionOpsMixin):
         # a float result
         # or our op is a divide
         if (is_float_dtype(other) or is_float(other)) or (
-            op_name in ["rtruediv", "truediv", "rdiv", "div"]
+            op_name in ["rtruediv", "truediv"]
         ):
             result[mask] = np.nan
             return result
@@ -747,8 +746,6 @@ IntegerArray._add_arithmetic_ops()
 IntegerArray._add_comparison_ops()
 
 
-module = sys.modules[__name__]
-
 _dtype_docstring = """
 An ExtensionDtype for {dtype} integer data.
 
diff --git a/pandas/core/ops/missing.py b/pandas/core/ops/missing.py
index 4ca1861ba..608c25509 100644
--- a/pandas/core/ops/missing.py
+++ b/pandas/core/ops/missing.py
@@ -120,9 +120,13 @@ def mask_zero_div_zero(x, y, result, copy=False):
     if zmask.any():
         shape = result.shape
 
+        # Flip sign if necessary for -0.0
+        zneg_mask = zmask & np.signbit(y)
+        zpos_mask = zmask & ~zneg_mask
+
         nan_mask = (zmask & (x == 0)).ravel()
-        neginf_mask = (zmask & (x < 0)).ravel()
-        posinf_mask = (zmask & (x > 0)).ravel()
+        neginf_mask = ((zpos_mask & (x < 0)) | (zneg_mask & (x > 0))).ravel()
+        posinf_mask = ((zpos_mask & (x > 0)) | (zneg_mask & (x < 0))).ravel()
 
         if nan_mask.any() or neginf_mask.any() or posinf_mask.any():
             # Fill negative/0 with -inf, positive/0 with +inf, 0/0 with NaN
diff --git a/pandas/tests/arithmetic/conftest.py b/pandas/tests/arithmetic/conftest.py
index c67a67bb3..f047154f2 100644
--- a/pandas/tests/arithmetic/conftest.py
+++ b/pandas/tests/arithmetic/conftest.py
@@ -30,8 +30,12 @@ zeros = [
     for box_cls in [pd.Index, np.array]
     for dtype in [np.int64, np.uint64, np.float64]
 ]
+zeros.extend(
+    [box_cls([-0.0] * 5, dtype=np.float64) for box_cls in [pd.Index, np.array]]
+)
 zeros.extend([np.array(0, dtype=dtype) for dtype in [np.int64, np.uint64, np.float64]])
-zeros.extend([0, 0.0])
+zeros.extend([np.array(-0.0, dtype=np.float64)])
+zeros.extend([0, 0.0, -0.0])
 
 
 @pytest.fixture(params=zeros)
diff --git a/pandas/tests/arithmetic/test_numeric.py b/pandas/tests/arithmetic/test_numeric.py
index 8179ab088..1fbecbab4 100644
--- a/pandas/tests/arithmetic/test_numeric.py
+++ b/pandas/tests/arithmetic/test_numeric.py
@@ -14,6 +14,22 @@ from pandas import Index, Series, Timedelta, TimedeltaIndex
 from pandas.core import ops
 import pandas.util.testing as tm
 
+
+def adjust_negative_zero(zero, expected):
+    """
+    Helper to adjust the expected result if we are dividing by -0.0
+    as opposed to 0.0
+    """
+    if np.signbit(np.array(zero)).any():
+        # All entries in the `zero` fixture should be either
+        #  all-negative or no-negative.
+        assert np.signbit(np.array(zero)).all()
+
+        expected *= -1
+
+    return expected
+
+
 # ------------------------------------------------------------------
 # Comparisons
 
@@ -229,20 +245,27 @@ class TestDivisionByZero:
         idx = numeric_idx
 
         expected = pd.Index([np.nan, np.inf, np.inf, np.inf, np.inf], dtype=np.float64)
+        # We only adjust for Index, because Series does not yet apply
+        #  the adjustment correctly.
+        expected2 = adjust_negative_zero(zero, expected)
+
         result = idx / zero
-        tm.assert_index_equal(result, expected)
+        tm.assert_index_equal(result, expected2)
         ser_compat = Series(idx).astype("i8") / np.array(zero).astype("i8")
-        tm.assert_series_equal(ser_compat, Series(result))
+        tm.assert_series_equal(ser_compat, Series(expected))
 
     def test_floordiv_zero(self, zero, numeric_idx):
         idx = numeric_idx
 
         expected = pd.Index([np.nan, np.inf, np.inf, np.inf, np.inf], dtype=np.float64)
+        # We only adjust for Index, because Series does not yet apply
+        #  the adjustment correctly.
+        expected2 = adjust_negative_zero(zero, expected)
 
         result = idx // zero
-        tm.assert_index_equal(result, expected)
+        tm.assert_index_equal(result, expected2)
         ser_compat = Series(idx).astype("i8") // np.array(zero).astype("i8")
-        tm.assert_series_equal(ser_compat, Series(result))
+        tm.assert_series_equal(ser_compat, Series(expected))
 
     def test_mod_zero(self, zero, numeric_idx):
         idx = numeric_idx
@@ -258,11 +281,27 @@ class TestDivisionByZero:
 
         exleft = pd.Index([np.nan, np.inf, np.inf, np.inf, np.inf], dtype=np.float64)
         exright = pd.Index([np.nan, np.nan, np.nan, np.nan, np.nan], dtype=np.float64)
+        exleft = adjust_negative_zero(zero, exleft)
 
         result = divmod(idx, zero)
         tm.assert_index_equal(result[0], exleft)
         tm.assert_index_equal(result[1], exright)
 
+    @pytest.mark.parametrize("op", [operator.truediv, operator.floordiv])
+    def test_div_negative_zero(self, zero, numeric_idx, op):
+        # Check that -1 / -0.0 returns np.inf, not -np.inf
+        if isinstance(numeric_idx, pd.UInt64Index):
+            return
+        idx = numeric_idx - 3
+
+        expected = pd.Index(
+            [-np.inf, -np.inf, -np.inf, np.nan, np.inf], dtype=np.float64
+        )
+        expected = adjust_negative_zero(zero, expected)
+
+        result = op(idx, zero)
+        tm.assert_index_equal(result, expected)
+
     # ------------------------------------------------------------------
 
     @pytest.mark.parametrize("dtype1", [np.int64, np.float64, np.uint64])
@@ -896,6 +935,26 @@ class TestAdditionSubtraction:
         check(tser, tser[::2])
         check(tser, 5)
 
+    @pytest.mark.xfail(
+        reason="Series division does not yet fill 1/0 consistently; Index does."
+    )
+    def test_series_divmod_zero(self):
+        # Check that divmod uses pandas convention for division by zero,
+        #  which does not match numpy.
+        # pandas convention has
+        #  1/0 == np.inf
+        #  -1/0 == -np.inf
+        #  1/-0.0 == -np.inf
+        #  -1/-0.0 == np.inf
+        tser = tm.makeTimeSeries().rename("ts")
+        other = tser * 0
+
+        result = divmod(tser, other)
+        exp1 = pd.Series([np.inf] * len(tser), index=tser.index)
+        exp2 = pd.Series([np.nan] * len(tser), index=tser.index)
+        tm.assert_series_equal(result[0], exp1)
+        tm.assert_series_equal(result[1], exp2)
+
 
 class TestUFuncCompat:
     @pytest.mark.parametrize(
diff --git a/pandas/tests/io/pytables/test_pytables.py b/pandas/tests/io/pytables/test_pytables.py
index b9f4defb4..fb87749ea 100644
--- a/pandas/tests/io/pytables/test_pytables.py
+++ b/pandas/tests/io/pytables/test_pytables.py
@@ -4337,6 +4337,7 @@ class TestHDFStore(Base):
         df["d"] = ts.index[:3]
         self._check_roundtrip(df, tm.assert_frame_equal)
 
+    # FIXME: don't leave commented-out code
     # def test_cant_write_multiindex_table(self):
     #     # for now, #1848
     #     df = DataFrame(np.random.randn(10, 4),
diff --git a/setup.cfg b/setup.cfg
index fee0ab60f..7549bfe2e 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -84,6 +84,8 @@ plugins = Cython.Coverage
 [coverage:report]
 ignore_errors = False
 show_missing = True
+omit =
+    pandas/_version.py
 # Regexes for lines to exclude from consideration
 exclude_lines =
     # Have to re-enable the standard pragma

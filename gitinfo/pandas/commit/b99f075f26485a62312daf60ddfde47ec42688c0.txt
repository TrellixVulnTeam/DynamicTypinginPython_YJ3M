commit b99f075f26485a62312daf60ddfde47ec42688c0
Author: Stephen Lin <stephenwlin@gmail.com>
Date:   Fri Feb 1 02:18:35 2013 -0500

    BUG: Timestamp constructor not handling timezone conversions correctly

diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 069e0b642..2e1323ec1 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -2545,6 +2545,7 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self.assert_(np.isnan(self.ts.asof(d)))
 
     def test_getitem_setitem_datetimeindex(self):
+        from pytz import timezone as tz
         from pandas import date_range
         N = 50
         # testing with timezone, GH #2785
@@ -2598,6 +2599,27 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         result["1990-01-02"] = ts[24:48]
         assert_series_equal(result, ts)
 
+        # also test Timestamp tz handling, GH #2789
+        result = ts.copy()
+        result["1990-01-01 09:00:00+00:00"] = 0
+        result["1990-01-01 09:00:00+00:00"] = ts[4]
+        assert_series_equal(result, ts)
+
+        result = ts.copy()
+        result["1990-01-01 03:00:00-06:00"] = 0
+        result["1990-01-01 03:00:00-06:00"] = ts[4]
+        assert_series_equal(result, ts)
+
+        result = ts.copy()
+        result[datetime(1990, 1, 1, 9, 0, 0, tzinfo=tz('UTC'))] = 0
+        result[datetime(1990, 1, 1, 9, 0, 0, tzinfo=tz('UTC'))] = ts[4]
+        assert_series_equal(result, ts)
+
+        result = ts.copy()
+        result[datetime(1990, 1, 1, 3, 0, 0, tzinfo=tz('US/Central'))] = 0
+        result[datetime(1990, 1, 1, 3, 0, 0, tzinfo=tz('US/Central'))] = ts[4]
+        assert_series_equal(result, ts)
+
     def test_getitem_setitem_periodindex(self):
         from pandas import period_range, Period
         N = 50
diff --git a/pandas/tslib.pyx b/pandas/tslib.pyx
index bbbe09022..c0b500afe 100644
--- a/pandas/tslib.pyx
+++ b/pandas/tslib.pyx
@@ -616,27 +616,26 @@ cdef convert_to_tsobject(object ts, object tz):
         if tz is not None:
             # sort of a temporary hack
             if ts.tzinfo is not None:
-                if hasattr(tz, 'normalize'):
+                if (hasattr(tz, 'normalize') and
+                        hasattr(ts.tzinfo, '_utcoffset')):
                     ts = tz.normalize(ts)
                     obj.value = _pydatetime_to_dts(ts, &obj.dts)
                     obj.tzinfo = ts.tzinfo
                 else: #tzoffset
-                    ts_offset = _get_utcoffset(ts.tzinfo, ts)
                     obj.value = _pydatetime_to_dts(ts, &obj.dts)
+                    ts_offset = _get_utcoffset(ts.tzinfo, ts)
                     obj.value -= _delta_to_nanoseconds(ts_offset)
                     tz_offset = _get_utcoffset(tz, ts)
                     obj.value += _delta_to_nanoseconds(tz_offset)
-
+                    pandas_datetime_to_datetimestruct(obj.value,
+                                                      PANDAS_FR_ns, &obj.dts)
                     obj.tzinfo = tz
             elif not _is_utc(tz):
-                try:
+                if (hasattr(tz, 'localize')):
                     ts = tz.localize(ts)
-                except AttributeError:
+                else:
                     ts = ts.replace(tzinfo=tz)
-
                 obj.value = _pydatetime_to_dts(ts, &obj.dts)
-                offset = _get_utcoffset(ts.tzinfo, ts)
-                obj.value -= _delta_to_nanoseconds(offset)
                 obj.tzinfo = ts.tzinfo
             else:
                 # UTC
@@ -645,9 +644,10 @@ cdef convert_to_tsobject(object ts, object tz):
         else:
             obj.value = _pydatetime_to_dts(ts, &obj.dts)
             obj.tzinfo = ts.tzinfo
-            if obj.tzinfo is not None and not _is_utc(obj.tzinfo):
-                offset = _get_utcoffset(obj.tzinfo, ts)
-                obj.value -= _delta_to_nanoseconds(offset)
+
+        if obj.tzinfo is not None and not _is_utc(obj.tzinfo):
+            offset = _get_utcoffset(obj.tzinfo, ts)
+            obj.value -= _delta_to_nanoseconds(offset)
 
         if is_timestamp(ts):
             obj.value += ts.nanosecond

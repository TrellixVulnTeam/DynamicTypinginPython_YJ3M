commit ead3ca85b42e6d12855acecd347ef7cc94792c9d
Author: sinhrks <sinhrks@gmail.com>
Date:   Mon Sep 7 23:04:02 2015 +0900

    BUG: Index dtype may not be applied properly

diff --git a/doc/source/whatsnew/v0.17.0.txt b/doc/source/whatsnew/v0.17.0.txt
index da0559e99..35772b8f7 100644
--- a/doc/source/whatsnew/v0.17.0.txt
+++ b/doc/source/whatsnew/v0.17.0.txt
@@ -1100,3 +1100,4 @@ Bug Fixes
 - Bug in ``date_range`` results in empty if freq is negative annualy, quarterly and monthly (:issue:`11018`)
 - Bug in ``DatetimeIndex`` cannot infer negative freq (:issue:`11018`)
 - Remove use of some deprecated numpy comparison operations, mainly in tests. (:issue:`10569`)
+- Bug in ``Index`` dtype may not applied properly (:issue:`11017`)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index c60509f00..d64a20fc9 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -117,7 +117,9 @@ class Index(IndexOpsMixin, PandasObject):
         if fastpath:
             return cls._simple_new(data, name)
 
-        from pandas.tseries.period import PeriodIndex
+        if is_categorical_dtype(data) or is_categorical_dtype(dtype):
+            return CategoricalIndex(data, copy=copy, name=name, **kwargs)
+
         if isinstance(data, (np.ndarray, Index, ABCSeries)):
             if issubclass(data.dtype.type, np.datetime64) or is_datetimetz(data):
                 from pandas.tseries.index import DatetimeIndex
@@ -137,10 +139,11 @@ class Index(IndexOpsMixin, PandasObject):
             if dtype is not None:
                 try:
                     data = np.array(data, dtype=dtype, copy=copy)
-                except TypeError:
+                except (TypeError, ValueError):
                     pass
 
             # maybe coerce to a sub-class
+            from pandas.tseries.period import PeriodIndex
             if isinstance(data, PeriodIndex):
                 return PeriodIndex(data, copy=copy, name=name, **kwargs)
             if issubclass(data.dtype.type, np.integer):
@@ -149,8 +152,6 @@ class Index(IndexOpsMixin, PandasObject):
                 return Float64Index(data, copy=copy, dtype=dtype, name=name)
             elif issubclass(data.dtype.type, np.bool) or is_bool_dtype(data):
                 subarr = data.astype('object')
-            elif is_categorical_dtype(data) or is_categorical_dtype(dtype):
-                return CategoricalIndex(data, copy=copy, name=name, **kwargs)
             else:
                 subarr = com._asarray_tuplesafe(data, dtype=object)
 
@@ -159,8 +160,28 @@ class Index(IndexOpsMixin, PandasObject):
             if copy:
                 subarr = subarr.copy()
 
-        elif is_categorical_dtype(data) or is_categorical_dtype(dtype):
-            return CategoricalIndex(data, copy=copy, name=name, **kwargs)
+            if dtype is None:
+                inferred = lib.infer_dtype(subarr)
+                if inferred == 'integer':
+                    return Int64Index(subarr.astype('i8'), copy=copy, name=name)
+                elif inferred in ['floating', 'mixed-integer-float']:
+                    return Float64Index(subarr, copy=copy, name=name)
+                elif inferred == 'boolean':
+                    # don't support boolean explicity ATM
+                    pass
+                elif inferred != 'string':
+                    if (inferred.startswith('datetime') or
+                        tslib.is_timestamp_array(subarr)):
+                        from pandas.tseries.index import DatetimeIndex
+                        return DatetimeIndex(subarr, copy=copy, name=name, **kwargs)
+                    elif (inferred.startswith('timedelta') or
+                          lib.is_timedelta_array(subarr)):
+                        from pandas.tseries.tdi import TimedeltaIndex
+                        return TimedeltaIndex(subarr, copy=copy, name=name, **kwargs)
+                    elif inferred == 'period':
+                        return PeriodIndex(subarr, name=name, **kwargs)
+            return cls._simple_new(subarr, name)
+
         elif hasattr(data, '__array__'):
             return Index(np.asarray(data), dtype=dtype, copy=copy, name=name,
                          **kwargs)
@@ -172,9 +193,7 @@ class Index(IndexOpsMixin, PandasObject):
                 # we must be all tuples, otherwise don't construct
                 # 10697
                 if all( isinstance(e, tuple) for e in data ):
-
                     try:
-
                         # must be orderable in py3
                         if compat.PY3:
                             sorted(data)
@@ -183,32 +202,9 @@ class Index(IndexOpsMixin, PandasObject):
                     except (TypeError, KeyError):
                         # python2 - MultiIndex fails on mixed types
                         pass
-
             # other iterable of some kind
             subarr = com._asarray_tuplesafe(data, dtype=object)
-
-        if dtype is None:
-            inferred = lib.infer_dtype(subarr)
-            if inferred == 'integer':
-                return Int64Index(subarr.astype('i8'), copy=copy, name=name)
-            elif inferred in ['floating', 'mixed-integer-float']:
-                return Float64Index(subarr, copy=copy, name=name)
-            elif inferred == 'boolean':
-                # don't support boolean explicity ATM
-                pass
-            elif inferred != 'string':
-                if (inferred.startswith('datetime') or
-                        tslib.is_timestamp_array(subarr)):
-                    from pandas.tseries.index import DatetimeIndex
-                    return DatetimeIndex(subarr, copy=copy, name=name, **kwargs)
-                elif (inferred.startswith('timedelta') or
-                        lib.is_timedelta_array(subarr)):
-                    from pandas.tseries.tdi import TimedeltaIndex
-                    return TimedeltaIndex(subarr, copy=copy, name=name, **kwargs)
-                elif inferred == 'period':
-                    return PeriodIndex(subarr, name=name, **kwargs)
-
-        return cls._simple_new(subarr, name)
+            return Index(subarr, dtype=dtype, copy=copy, name=name, **kwargs)
 
     @classmethod
     def _simple_new(cls, values, name=None, dtype=None, **kwargs):
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 0ab80ad91..75daabe2d 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -651,6 +651,11 @@ class TestIndex(Base, tm.TestCase):
         df = pd.DataFrame(np.random.rand(5,3))
         df['date'] = ['1-1-1990', '2-1-1990', '3-1-1990', '4-1-1990', '5-1-1990']
         result = DatetimeIndex(df['date'], freq='MS')
+        self.assertTrue(result.equals(expected))
+        self.assertEqual(df['date'].dtype, object)
+
+        exp = pd.Series(['1-1-1990', '2-1-1990', '3-1-1990', '4-1-1990', '5-1-1990'], name='date')
+        self.assert_series_equal(df['date'], exp)
 
         # GH 6274
         # infer freq of same
@@ -693,6 +698,55 @@ class TestIndex(Base, tm.TestCase):
         result = idx._simple_new(idx, 'obj')
         self.assertTrue(result.equals(idx))
 
+    def test_constructor_dtypes(self):
+
+        for idx in [Index(np.array([1, 2, 3], dtype=int)),
+                    Index(np.array([1, 2, 3], dtype=int), dtype=int),
+                    Index(np.array([1., 2., 3.], dtype=float), dtype=int),
+                    Index([1, 2, 3], dtype=int),
+                    Index([1., 2., 3.], dtype=int)]:
+            self.assertIsInstance(idx, Int64Index)
+
+        for idx in [Index(np.array([1., 2., 3.], dtype=float)),
+                    Index(np.array([1, 2, 3], dtype=int), dtype=float),
+                    Index(np.array([1., 2., 3.], dtype=float), dtype=float),
+                    Index([1, 2, 3], dtype=float),
+                    Index([1., 2., 3.], dtype=float)]:
+            self.assertIsInstance(idx, Float64Index)
+
+        for idx in [Index(np.array([True, False, True], dtype=bool)),
+                    Index([True, False, True]),
+                    Index(np.array([True, False, True], dtype=bool), dtype=bool),
+                    Index([True, False, True], dtype=bool)]:
+            self.assertIsInstance(idx, Index)
+            self.assertEqual(idx.dtype, object)
+
+        for idx in [Index(np.array([1, 2, 3], dtype=int), dtype='category'),
+                    Index([1, 2, 3], dtype='category'),
+                    Index(np.array([np.datetime64('2011-01-01'), np.datetime64('2011-01-02')]), dtype='category'),
+                    Index([datetime(2011, 1, 1), datetime(2011, 1, 2)], dtype='category')]:
+            self.assertIsInstance(idx, CategoricalIndex)
+
+        for idx in [Index(np.array([np.datetime64('2011-01-01'), np.datetime64('2011-01-02')])),
+                    Index([datetime(2011, 1, 1), datetime(2011, 1, 2)])]:
+            self.assertIsInstance(idx, DatetimeIndex)
+
+        for idx in [Index(np.array([np.datetime64('2011-01-01'), np.datetime64('2011-01-02')]), dtype=object),
+                    Index([datetime(2011, 1, 1), datetime(2011, 1, 2)], dtype=object)]:
+            self.assertNotIsInstance(idx, DatetimeIndex)
+            self.assertIsInstance(idx, Index)
+            self.assertEqual(idx.dtype, object)
+
+        for idx in [Index(np.array([np.timedelta64(1, 'D'), np.timedelta64(1, 'D')])),
+                    Index([timedelta(1), timedelta(1)])]:
+            self.assertIsInstance(idx, TimedeltaIndex)
+
+        for idx in [Index(np.array([np.timedelta64(1, 'D'), np.timedelta64(1, 'D')]), dtype=object),
+                    Index([timedelta(1), timedelta(1)], dtype=object)]:
+            self.assertNotIsInstance(idx, TimedeltaIndex)
+            self.assertIsInstance(idx, Index)
+            self.assertEqual(idx.dtype, object)
+
     def test_view_with_args(self):
 
         restricted = ['unicodeIndex','strIndex','catIndex','boolIndex','empty']

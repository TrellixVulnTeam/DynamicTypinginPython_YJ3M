commit 859cf95bb55f3f210d33c3bef4eab2ba8341bd11
Author: Daniel Saxton <2658661+dsaxton@users.noreply.github.com>
Date:   Tue Apr 14 12:26:27 2020 -0500

    TST/CLN: Clean categorical min / max tests (#33512)
    
    * TST/CLN: Clean categorical min / max tests
    
    * Clean
    
    * Add error message

diff --git a/pandas/tests/arrays/categorical/test_analytics.py b/pandas/tests/arrays/categorical/test_analytics.py
index 67b491165..83ecebafb 100644
--- a/pandas/tests/arrays/categorical/test_analytics.py
+++ b/pandas/tests/arrays/categorical/test_analytics.py
@@ -53,40 +53,28 @@ class TestCategoricalAnalytics:
     @pytest.mark.parametrize("aggregation", ["min", "max"])
     def test_min_max_ordered_empty(self, categories, expected, aggregation):
         # GH 30227
-        cat = Categorical([], categories=list("ABC"), ordered=True)
+        cat = Categorical([], categories=categories, ordered=True)
 
         agg_func = getattr(cat, aggregation)
         result = agg_func()
         assert result is expected
 
+    @pytest.mark.parametrize(
+        "values, categories",
+        [(["a", "b", "c", np.nan], list("cba")), ([1, 2, 3, np.nan], [3, 2, 1])],
+    )
     @pytest.mark.parametrize("skipna", [True, False])
-    def test_min_max_with_nan(self, skipna):
+    @pytest.mark.parametrize("function", ["min", "max"])
+    def test_min_max_with_nan(self, values, categories, function, skipna):
         # GH 25303
-        cat = Categorical(
-            [np.nan, "b", "c", np.nan], categories=["d", "c", "b", "a"], ordered=True
-        )
-        _min = cat.min(skipna=skipna)
-        _max = cat.max(skipna=skipna)
-
-        if skipna is False:
-            assert np.isnan(_min)
-            assert np.isnan(_max)
-        else:
-            assert _min == "c"
-            assert _max == "b"
-
-        cat = Categorical(
-            [np.nan, 1, 2, np.nan], categories=[5, 4, 3, 2, 1], ordered=True
-        )
-        _min = cat.min(skipna=skipna)
-        _max = cat.max(skipna=skipna)
+        cat = Categorical(values, categories=categories, ordered=True)
+        result = getattr(cat, function)(skipna=skipna)
 
         if skipna is False:
-            assert np.isnan(_min)
-            assert np.isnan(_max)
+            assert result is np.nan
         else:
-            assert _min == 2
-            assert _max == 1
+            expected = categories[0] if function == "min" else categories[2]
+            assert result == expected
 
     @pytest.mark.parametrize("function", ["min", "max"])
     @pytest.mark.parametrize("skipna", [True, False])
diff --git a/pandas/tests/reductions/test_reductions.py b/pandas/tests/reductions/test_reductions.py
index fa62d5d8c..635b1a1cd 100644
--- a/pandas/tests/reductions/test_reductions.py
+++ b/pandas/tests/reductions/test_reductions.py
@@ -1072,67 +1072,45 @@ class TestCategoricalSeriesReductions:
     #  were moved from a series-specific test file, _not_ that these tests are
     #  intended long-term to be series-specific
 
-    def test_min_max(self):
+    @pytest.mark.parametrize("function", ["min", "max"])
+    def test_min_max_unordered_raises(self, function):
         # unordered cats have no min/max
         cat = Series(Categorical(["a", "b", "c", "d"], ordered=False))
-        with pytest.raises(TypeError):
-            cat.min()
-        with pytest.raises(TypeError):
-            cat.max()
-
-        cat = Series(Categorical(["a", "b", "c", "d"], ordered=True))
-        _min = cat.min()
-        _max = cat.max()
-        assert _min == "a"
-        assert _max == "d"
-
-        cat = Series(
-            Categorical(
-                ["a", "b", "c", "d"], categories=["d", "c", "b", "a"], ordered=True
-            )
-        )
-        _min = cat.min()
-        _max = cat.max()
-        assert _min == "d"
-        assert _max == "a"
-
-        cat = Series(
-            Categorical(
-                [np.nan, "b", "c", np.nan],
-                categories=["d", "c", "b", "a"],
-                ordered=True,
-            )
-        )
-        _min = cat.min()
-        _max = cat.max()
-        assert _min == "c"
-        assert _max == "b"
+        msg = f"Categorical is not ordered for operation {function}"
+        with pytest.raises(TypeError, match=msg):
+            getattr(cat, function)()
 
-        cat = Series(
-            Categorical(
-                [np.nan, 1, 2, np.nan], categories=[5, 4, 3, 2, 1], ordered=True
-            )
-        )
-        _min = cat.min()
-        _max = cat.max()
-        assert _min == 2
-        assert _max == 1
+    @pytest.mark.parametrize(
+        "values, categories",
+        [
+            (list("abc"), list("abc")),
+            (list("abc"), list("cba")),
+            (list("abc") + [np.nan], list("cba")),
+            ([1, 2, 3], [3, 2, 1]),
+            ([1, 2, 3, np.nan], [3, 2, 1]),
+        ],
+    )
+    @pytest.mark.parametrize("function", ["min", "max"])
+    def test_min_max_ordered(self, values, categories, function):
+        # GH 25303
+        cat = Series(Categorical(values, categories=categories, ordered=True))
+        result = getattr(cat, function)(skipna=True)
+        expected = categories[0] if function == "min" else categories[2]
+        assert result == expected
 
+    @pytest.mark.parametrize("function", ["min", "max"])
     @pytest.mark.parametrize("skipna", [True, False])
-    def test_min_max_skipna(self, skipna):
-        # GH 25303
+    def test_min_max_skipna(self, function, skipna):
         cat = Series(
             Categorical(["a", "b", np.nan, "a"], categories=["b", "a"], ordered=True)
         )
-        _min = cat.min(skipna=skipna)
-        _max = cat.max(skipna=skipna)
+        result = getattr(cat, function)(skipna=skipna)
 
         if skipna is True:
-            assert _min == "b"
-            assert _max == "a"
+            expected = "b" if function == "min" else "a"
+            assert result == expected
         else:
-            assert np.isnan(_min)
-            assert np.isnan(_max)
+            assert result is np.nan
 
 
 class TestSeriesMode:

commit 90499b48ad2908b813f902892f7bbcd9f42cda95
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun May 20 19:48:28 2012 -0400

    BUG: more NumPy 1.7 fixes

diff --git a/pandas/core/index.py b/pandas/core/index.py
index fc10ed86e..baa98e094 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -80,7 +80,11 @@ class Index(np.ndarray):
                 if issubclass(data.dtype.type, np.integer):
                     return Int64Index(data, copy=copy, name=name)
 
-            subarr = np.array(data, dtype=object, copy=copy)
+            if not copy:
+                subarr = com._ensure_object(data)
+            else:
+                subarr = data.astype(object)
+            # subarr = np.array(data, dtype=object, copy=copy)
         elif np.isscalar(data):
             raise ValueError('Index(...) must be called with a collection '
                              'of some kind, %s was passed' % repr(data))
diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index 4a777a92b..bfbdb6fae 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -121,7 +121,8 @@ def _nanvar(values, axis=None, skipna=True, ddof=1):
 
 def _nanmin(values, axis=None, skipna=True):
     mask = isnull(values)
-    if skipna and not issubclass(values.dtype.type, np.integer):
+    if skipna and not issubclass(values.dtype.type,
+                                 (np.integer, np.datetime64)):
         values = values.copy()
         np.putmask(values, mask, np.inf)
     # numpy 1.6.1 workaround in Python 3.x
@@ -140,7 +141,8 @@ def _nanmin(values, axis=None, skipna=True):
 
 def _nanmax(values, axis=None, skipna=True):
     mask = isnull(values)
-    if skipna and not issubclass(values.dtype.type, np.integer):
+    if skipna and not issubclass(values.dtype.type,
+                                 (np.integer, np.datetime64)):
         values = values.copy()
         np.putmask(values, mask, -np.inf)
     # numpy 1.6.1 workaround in Python 3.x
@@ -400,13 +402,15 @@ def unique1d(values):
         table = lib.Float64HashTable(len(values))
         uniques = np.array(table.unique(com._ensure_float64(values)),
                            dtype=np.float64)
+    elif np.issubdtype(values.dtype, np.datetime64):
+        table = lib.Int64HashTable(len(values))
+        uniques = np.array(table.unique(com._ensure_int64(values)),
+                           dtype=np.int64)
+        uniques = uniques.view('M8[ns]')
     elif np.issubdtype(values.dtype, np.integer):
         table = lib.Int64HashTable(len(values))
         uniques = np.array(table.unique(com._ensure_int64(values)),
                            dtype=np.int64)
-
-        if np.issubdtype(values.dtype, np.datetime64):
-            uniques = uniques.view('M8[ns]')
     else:
         table = lib.PyObjectHashTable(len(values))
         uniques = table.unique(com._ensure_object(values))
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index c0dfb4097..e4ad6c4d4 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -792,6 +792,7 @@ def string_to_datetime(ndarray[object] strings, raise_=False, dayfirst=False):
         object val
         ndarray[int64_t] iresult
         ndarray[object] oresult
+        pandas_datetimestruct dts
 
     from dateutil.parser import parse
 
@@ -804,6 +805,10 @@ def string_to_datetime(ndarray[object] strings, raise_=False, dayfirst=False):
                 iresult[i] = NaT
             elif PyDateTime_Check(val):
                 result[i] = val
+            elif PyDate_Check(val):
+                iresult[i] = _date_to_datetime64(val, &dts)
+            elif util.is_datetime64_object(val):
+                result[i] = val
             else:
                 if len(val) == 0:
                     iresult[i] = NaT
@@ -829,7 +834,8 @@ def string_to_datetime(ndarray[object] strings, raise_=False, dayfirst=False):
                 except Exception:
                     if raise_:
                         raise
-                    oresult[i] = val
+                    return strings
+                    # oresult[i] = val
 
         return oresult
 
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index 38641a27e..a3f705cf9 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -483,7 +483,7 @@ class TestGroupBy(unittest.TestCase):
                           'F' : np.random.randn(11)})
 
         def bad(x):
-            assert_equal(len(x.base), len(x))
+            assert(len(x.base) > 0)
             return 'foo'
 
         result = data.groupby(['A', 'B']).agg(bad)
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index c9c6f5e29..d0fd1a32b 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -970,7 +970,10 @@ x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
 
             grouped = frame.groupby(level=level, axis=axis)
 
-            aggf = lambda x: getattr(x, op)(skipna=skipna, axis=axis)
+            pieces = []
+            def aggf(x):
+                pieces.append(x)
+                return getattr(x, op)(skipna=skipna, axis=axis)
             leftside = grouped.agg(aggf)
             rightside = getattr(frame, op)(level=level, axis=axis,
                                            skipna=skipna)
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index c59f0a45a..75ee6762f 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -96,7 +96,7 @@ def _ensure_datetime64(other):
     if isinstance(other, np.datetime64):
         return other
     elif com.is_integer(other):
-        return np.datetime64(other)
+        return np.int64(other).view('M8[us]')
     else:
         raise TypeError(other)
 
@@ -226,6 +226,7 @@ class DatetimeIndex(Int64Index):
             if lib.is_string_array(data):
                 data = _str_to_dt_array(data, offset)
             else:
+                data = tools.to_datetime(data)
                 data = np.asarray(data, dtype='M8[ns]')
 
         if issubclass(data.dtype.type, basestring):
@@ -240,7 +241,10 @@ class DatetimeIndex(Int64Index):
         elif issubclass(data.dtype.type, np.integer):
             subarr = np.array(data, dtype='M8[ns]', copy=copy)
         else:
-            subarr = np.array(data, dtype='M8[ns]', copy=copy)
+            subarr = tools.to_datetime(data)
+            if not np.issubdtype(subarr.dtype, np.datetime64):
+                raise TypeError('Unable to convert %s to datetime dtype'
+                                % str(data))
 
         if tz is not None:
             tz = tools._maybe_get_tz(tz)
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index dbf7ac23e..95206d6b7 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -1091,12 +1091,10 @@ class TestDatetime64(unittest.TestCase):
                         '2005-01-04'], dtype='O')
         idx4 = DatetimeIndex(arr)
 
-        arr = np.array(['1/1/2005', '1/2/2005', '1/3/2005',
-                        '2005-01-04'], dtype='M8[ns]')
+        arr = to_datetime(['1/1/2005', '1/2/2005', '1/3/2005', '2005-01-04'])
         idx5 = DatetimeIndex(arr)
 
-        arr = np.array(['1/1/2005', '1/2/2005', 'Jan 3, 2005',
-                        '2005-01-04'], dtype='M8[ns]')
+        arr = to_datetime(['1/1/2005', '1/2/2005', 'Jan 3, 2005', '2005-01-04'])
         idx6 = DatetimeIndex(arr)
 
         for other in [idx2, idx3, idx4, idx5, idx6]:
@@ -1160,8 +1158,8 @@ class TestDatetime64(unittest.TestCase):
 class TestTimestamp(unittest.TestCase):
 
     def test_basics_nanos(self):
-        arr = np.array(['1/1/2000'], dtype='M8[ns]')
-        stamp = Timestamp(arr[0].view('i8') + 500)
+        val = np.int64(946684800000000000).view('M8[ns]')
+        stamp = Timestamp(val.view('i8') + 500)
         self.assert_(stamp.year == 2000)
         self.assert_(stamp.month == 1)
         self.assert_(stamp.microsecond == 0)

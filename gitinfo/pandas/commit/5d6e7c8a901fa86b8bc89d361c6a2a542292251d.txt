commit 5d6e7c8a901fa86b8bc89d361c6a2a542292251d
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Nov 23 19:14:37 2012 -0500

    ENH/BUG: setting multiple columns via hierarchical idnexing. close #2295

diff --git a/RELEASE.rst b/RELEASE.rst
index 43fbc7763..39fae49a2 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -57,6 +57,8 @@ pandas 0.10.0
   - Fix regression in Index console formatting (#2319)
   - Box Period data when assigning PeriodIndex to frame column (#2243, #2281)
   - Raise exception on calling reset_index on Series with inplace=True (#2277)
+  - Enable setting multiple columns in DataFrame with hierarchical columns
+    (#2295)
 
 pandas 0.9.1
 ============
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index d6aa2949c..4d066f94a 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2008,12 +2008,16 @@ class DataFrame(NDFrame):
         # Need to make sure new columns (which go into the BlockManager as new
         # blocks) are always copied
         if _is_sequence(value):
-            if isinstance(value, Series):
+            is_frame = isinstance(value, DataFrame)
+            if isinstance(value, Series) or is_frame:
                 if value.index.equals(self.index):
                     # copy the values
                     value = value.values.copy()
                 else:
                     value = value.reindex(self.index).values
+
+                if is_frame:
+                    value = value.T
             else:
                 if len(value) != len(self.index):
                     raise AssertionError('Length of values does not match '
@@ -2023,6 +2027,8 @@ class DataFrame(NDFrame):
                     value = com._asarray_tuplesafe(value)
                 elif isinstance(value, PeriodIndex):
                     value = value.asobject
+                elif value.ndim == 2:
+                    value = value.copy().T
                 else:
                     value = value.copy()
         else:
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index edde14cd5..a6eb95956 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -542,19 +542,8 @@ class NDFrame(PandasObject):
         self._item_cache.clear()
 
     def _set_item(self, key, value):
-        if hasattr(self, 'columns') and isinstance(self.columns, MultiIndex):
-            # Pad the key with empty strings if lower levels of the key
-            # aren't specified:
-            if not isinstance(key, tuple):
-                key = (key,)
-            if len(key) != self.columns.nlevels:
-                key += ('',) * (self.columns.nlevels - len(key))
         self._data.set(key, value)
-
-        try:
-            del self._item_cache[key]
-        except KeyError:
-            pass
+        self._clear_item_cache()
 
     def __delitem__(self, key):
         """
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 12d2574d5..7dd8e4100 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -2369,9 +2369,12 @@ class MultiIndex(Index):
         -------
         new_index : Index
         """
-        if not isinstance(item, tuple) or len(item) != self.nlevels:
-            raise Exception("%s cannot be inserted in this MultiIndex"
-                            % str(item))
+        # Pad the key with empty strings if lower levels of the key
+        # aren't specified:
+        if not isinstance(item, tuple):
+            item = (item,) + ('',) * (self.nlevels - 1)
+        elif len(item) != self.nlevels:
+            raise ValueError('Passed item incompatible tuple length')
 
         new_levels = []
         new_labels = []
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 5f4434d4d..d54154d0e 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -921,15 +921,27 @@ class BlockManager(object):
         if value.shape[1:] != self.shape[1:]:
             raise AssertionError('Shape of new values must be compatible '
                                  'with manager shape')
-        if item in self.items:
+
+        def _set_item(item, arr):
             i, block = self._find_block(item)
             if not block.should_store(value):
                 # delete from block, create and append new block
                 self._delete_from_block(i, item)
-                self._add_new_block(item, value, loc=None)
+                self._add_new_block(item, arr, loc=None)
             else:
-                block.set(item, value)
-        else:
+                block.set(item, arr)
+
+        try:
+            loc = self.items.get_loc(item)
+            if isinstance(loc, int):
+                _set_item(self.items[loc], value)
+            else:
+                subset = self.items[loc]
+                if len(value) != len(subset):
+                    raise AssertionError('Number of items to set did not match')
+                for i, (item, arr) in enumerate(zip(subset, value)):
+                    _set_item(item, arr[None, :])
+        except KeyError:
             # insert at end
             self.insert(len(self.items), item, value)
 
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 4a2a64ead..5f23d7153 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -849,7 +849,7 @@ class TestInt64Index(unittest.TestCase):
 
     def test_print_unicode_columns(self):
         df=pd.DataFrame({u"\u05d0":[1,2,3],"\u05d1":[4,5,6],"c":[7,8,9]})
-        print(df.columns) # should not raise UnicodeDecodeError
+        repr(df.columns) # should not raise UnicodeDecodeError
 
     def test_repr_summary(self):
         r = repr(pd.Index(np.arange(10000)))
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 6e73013e9..9bef76a68 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -274,6 +274,19 @@ class TestMultiLevel(unittest.TestCase):
         df.ix[:,:] = 10
         assert_frame_equal(df, result)
 
+    def test_frame_setitem_multi_column(self):
+        df = DataFrame(randn(10, 4), columns=[['a', 'a', 'b', 'b'],
+                                              [0, 1, 0, 1]])
+
+        cp = df.copy()
+        cp['a'] = cp['b']
+        assert_frame_equal(cp['a'], cp['b'])
+
+        # set with ndarray
+        cp = df.copy()
+        cp['a'] = cp['b'].values
+        assert_frame_equal(cp['a'], cp['b'])
+
     def test_getitem_tuple_plus_slice(self):
         # GH #671
         df = DataFrame({'a' : range(10),

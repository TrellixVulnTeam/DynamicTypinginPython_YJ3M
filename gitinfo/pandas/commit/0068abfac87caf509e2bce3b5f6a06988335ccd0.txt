commit 0068abfac87caf509e2bce3b5f6a06988335ccd0
Author: Jeff Reback <jeff@reback.net>
Date:   Sun Aug 23 08:48:13 2015 -0400

    DEPR: Remove unused keyword kind in read_excel/ExcelFile, #4712

diff --git a/doc/source/whatsnew/v0.17.0.txt b/doc/source/whatsnew/v0.17.0.txt
index c93dd6dda..a176c8b34 100644
--- a/doc/source/whatsnew/v0.17.0.txt
+++ b/doc/source/whatsnew/v0.17.0.txt
@@ -709,7 +709,7 @@ Removal of prior version deprecations/changes
 
 
 - Remove the ``table`` keyword in ``HDFStore.put/append``, in favor of using ``format=`` (:issue:`4645`)
-
+- Remove unused keyword ``kind`` in ``read_excel/ExcelFile`` (:issue:`4712`)
 
 
 .. _whatsnew_0170.performance:
diff --git a/pandas/io/excel.py b/pandas/io/excel.py
index d58d6590b..d5258cb32 100644
--- a/pandas/io/excel.py
+++ b/pandas/io/excel.py
@@ -78,17 +78,17 @@ def read_excel(io, sheetname=0, **kwds):
         and file. For file URLs, a host is expected. For instance, a local
         file could be file://localhost/path/to/workbook.xlsx
     sheetname : string, int, mixed list of strings/ints, or None, default 0
-        
-        Strings are used for sheet names, Integers are used in zero-indexed sheet 
-        positions. 
-        
+
+        Strings are used for sheet names, Integers are used in zero-indexed sheet
+        positions.
+
         Lists of strings/integers are used to request multiple sheets.
-        
+
         Specify None to get all sheets.
-        
+
         str|int -> DataFrame is returned.
         list|None -> Dict of DataFrames is returned, with keys representing sheets.
-               
+
         Available Cases
 
         * Defaults to 0 -> 1st sheet as a DataFrame
@@ -143,11 +143,6 @@ def read_excel(io, sheetname=0, **kwds):
         for more information on when a Dict of Dataframes is returned.
 
     """
-    if 'kind' in kwds:
-        kwds.pop('kind')
-        warn("kind keyword is no longer supported in read_excel and may be "
-             "removed in a future version", FutureWarning)
-
     engine = kwds.pop('engine', None)
 
     return ExcelFile(io, engine=engine).parse(sheetname=sheetname, **kwds)
@@ -207,19 +202,19 @@ class ExcelFile(object):
         Parameters
         ----------
         sheetname : string, int, mixed list of strings/ints, or None, default 0
-            
-            Strings are used for sheet names, Integers are used in zero-indexed sheet 
-            positions. 
-            
+
+            Strings are used for sheet names, Integers are used in zero-indexed sheet
+            positions.
+
             Lists of strings/integers are used to request multiple sheets.
-            
+
             Specify None to get all sheets.
-            
+
             str|int -> DataFrame is returned.
             list|None -> Dict of DataFrames is returned, with keys representing sheets.
-                   
+
             Available Cases
-    
+
             * Defaults to 0 -> 1st sheet as a DataFrame
             * 1 -> 2nd sheet as a DataFrame
             * "Sheet1" -> 1st sheet as a DataFrame
@@ -336,7 +331,7 @@ class ExcelFile(object):
         def _parse_cell(cell_contents,cell_typ):
             """converts the contents of the cell into a pandas
                appropriate object"""
-               
+
             if cell_typ == XL_CELL_DATE:
                 if xlrd_0_9_3:
                     # Use the newer xlrd datetime handling.
@@ -379,9 +374,9 @@ class ExcelFile(object):
             xlrd_0_9_3 = True
         else:
             xlrd_0_9_3 = False
-        
+
         ret_dict = False
-        
+
         #Keep sheetname to maintain backwards compatibility.
         if isinstance(sheetname, list):
             sheets = sheetname
@@ -391,31 +386,31 @@ class ExcelFile(object):
             ret_dict = True
         else:
             sheets = [sheetname]
-        
+
         #handle same-type duplicates.
         sheets = list(set(sheets))
-        
+
         output = {}
-        
+
         for asheetname in sheets:
             if verbose:
                 print("Reading sheet %s" % asheetname)
-            
+
             if isinstance(asheetname, compat.string_types):
                 sheet = self.book.sheet_by_name(asheetname)
-            else:  # assume an integer if not a string    
-                sheet = self.book.sheet_by_index(asheetname)   
-            
+            else:  # assume an integer if not a string
+                sheet = self.book.sheet_by_index(asheetname)
+
             data = []
             should_parse = {}
-            
+
             for i in range(sheet.nrows):
                 row = []
                 for j, (value, typ) in enumerate(zip(sheet.row_values(i),
                                                      sheet.row_types(i))):
                     if parse_cols is not None and j not in should_parse:
                         should_parse[j] = self._should_parse(j, parse_cols)
-    
+
                     if parse_cols is None or should_parse[j]:
                         row.append(_parse_cell(value,typ))
                 data.append(row)
@@ -436,14 +431,14 @@ class ExcelFile(object):
                                 skip_footer=skip_footer,
                                 chunksize=chunksize,
                                 **kwds)
-            
+
             output[asheetname] = parser.read()
-            
+
         if ret_dict:
             return output
         else:
             return output[asheetname]
-        
+
 
     @property
     def sheet_names(self):

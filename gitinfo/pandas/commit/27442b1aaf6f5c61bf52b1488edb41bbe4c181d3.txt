commit 27442b1aaf6f5c61bf52b1488edb41bbe4c181d3
Author: Tobias Brandt <Tobias.Brandt@gmail.com>
Date:   Thu Sep 26 11:34:48 2013 +0200

    DOC: Updated documentation for pairwise API changes.
    
    Added a release note and example usage for pairwise=True.

diff --git a/doc/source/computation.rst b/doc/source/computation.rst
index 66e0d457e..7bd3c1aa0 100644
--- a/doc/source/computation.rst
+++ b/doc/source/computation.rst
@@ -59,6 +59,19 @@ The ``Series`` object has a method ``cov`` to compute covariance between series
 Analogously, ``DataFrame`` has a method ``cov`` to compute pairwise covariances
 among the series in the DataFrame, also excluding NA/null values.
 
+.. _computation.covariance.caveats:
+
+.. note::
+
+    Assuming the missing data are missing at random this results in an estimate
+    for the covariance matrix which is unbiased. However, for many applications
+    this estimate may not be acceptable because the estimated covariance matrix
+    is not guaranteed to be positive semi-definite. This could lead to
+    estimated correlations having absolute values which are greater than one,
+    and/or a non-invertible covariance matrix. See `Estimation of covariance
+    matrices <http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices>`_
+    for more details.
+
 .. ipython:: python
 
    frame = DataFrame(randn(1000, 5), columns=['a', 'b', 'c', 'd', 'e'])
@@ -99,6 +112,12 @@ correlation methods are provided:
 
 All of these are currently computed using pairwise complete observations.
 
+.. note::
+
+    Please see the :ref:`caveats <computation.covariance.caveats>` associated
+    with this method of calculating correlation matrices in the 
+    :ref:`covariance section <computation.covariance>`.
+
 .. ipython:: python
 
    frame = DataFrame(randn(1000, 5), columns=['a', 'b', 'c', 'd', 'e'])
@@ -325,11 +344,14 @@ Binary rolling moments
 two ``Series`` or any combination of ``DataFrame/Series`` or
 ``DataFrame/DataFrame``. Here is the behavior in each case:
 
-- two ``Series``: compute the statistic for the pairing
+- two ``Series``: compute the statistic for the pairing.
 - ``DataFrame/Series``: compute the statistics for each column of the DataFrame
-  with the passed Series, thus returning a DataFrame
-- ``DataFrame/DataFrame``: compute statistic for matching column names,
-  returning a DataFrame
+  with the passed Series, thus returning a DataFrame.
+- ``DataFrame/DataFrame``: by default compute the statistic for matching column
+  names, returning a DataFrame. If the keyword argument ``pairwise=True`` is
+  passed then computes the statistic for each pair of columns, returning a
+  ``Panel`` whose ``items`` are the dates in question (see :ref:`the next section
+  <stats.moments.corr_pairwise>`).
 
 For example:
 
@@ -340,20 +362,42 @@ For example:
 
 .. _stats.moments.corr_pairwise:
 
-Computing rolling pairwise correlations
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+Computing rolling pairwise covariances and correlations
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-In financial data analysis and other fields it's common to compute correlation
-matrices for a collection of time series. More difficult is to compute a
-moving-window correlation matrix. This can be done using the
-``rolling_corr_pairwise`` function, which yields a ``Panel`` whose ``items``
-are the dates in question:
+In financial data analysis and other fields it's common to compute covariance
+and correlation matrices for a collection of time series. Often one is also
+interested in moving-window covariance and correlation matrices. This can be
+done by passing the ``pairwise`` keyword argument, which in the case of
+``DataFrame`` inputs will yield a ``Panel`` whose ``items`` are the dates in
+question. In the case of a single DataFrame argument the ``pairwise`` argument
+can even be omitted:
+
+.. note::
+
+    Missing values are ignored and each entry is computed using the pairwise
+    complete observations.  Please see the :ref:`covariance section
+    <computation.covariance>` for :ref:`caveats
+    <computation.covariance.caveats>` associated with this method of
+    calculating covariance and correlation matrices.
 
 .. ipython:: python
 
-   correls = rolling_corr_pairwise(df, 50)
+   covs = rolling_cov(df[['B','C','D']], df[['A','B','C']], 50, pairwise=True)
+   covs[df.index[-50]]
+
+.. ipython:: python
+
+   correls = rolling_corr(df, 50)
    correls[df.index[-50]]
 
+.. note::
+    
+    Prior to version 0.14 this was available through ``rolling_corr_pairwise``
+    which is now simply syntactic sugar for calling ``rolling_corr(...,
+    pairwise=True)`` and deprecated. This is likely to be removed in a future
+    release.
+
 You can efficiently retrieve the time series of correlations between two
 columns using ``ix`` indexing:
 
diff --git a/doc/source/v0.14.0.txt b/doc/source/v0.14.0.txt
index 955378788..344198d6e 100644
--- a/doc/source/v0.14.0.txt
+++ b/doc/source/v0.14.0.txt
@@ -183,6 +183,19 @@ These are out-of-bounds selections
 
    Because of the default `align` value changes, coordinates of bar plots are now located on integer values (0.0, 1.0, 2.0 ...). This is intended to make bar plot be located on the same coodinates as line plot. However, bar plot may differs unexpectedly when you manually adjust the bar location or drawing area, such as using `set_xlim`, `set_ylim`, etc. In this cases, please modify your script to meet with new coordinates. 
 
+- ``pairwise`` keyword was added to the statistical moment functions
+  ``rolling_cov``, ``rolling_corr``, ``ewmcov``, ``ewmcorr``,
+  ``expanding_cov``, ``expanding_corr`` to allow the calculation of moving
+  window covariance and correlation matrices (:issue:`4950`). See
+  :ref:`Computing rolling pairwise covariances and correlations
+  <stats.moments.corr_pairwise>` in the docs.
+
+  .. ipython:: python
+  
+    df = DataFrame(np.random.randn(10,4),columns=list('ABCD'))
+    covs = rolling_cov(df[['A','B','C']], df[['B','C','D']], 5, pairwise=True)
+    covs[df.index[-1]]
+
 
 MultiIndexing Using Slicers
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
diff --git a/pandas/stats/moments.py b/pandas/stats/moments.py
index 59f804815..5da5054d9 100644
--- a/pandas/stats/moments.py
+++ b/pandas/stats/moments.py
@@ -31,13 +31,22 @@ __all__ = ['rolling_count', 'rolling_max', 'rolling_min',
 #------------------------------------------------------------------------------
 # Docs
 
+# The order of arguments for the _doc_template is:
+# (header, args, kwargs, returns, notes)
+
 _doc_template = """
 %s
 
 Parameters
 ----------
+%s%s
+Returns
+-------
+%s
 %s
-window : int
+"""
+
+_roll_kw = """window : int
     Size of the moving window. This is the number of observations used for
     calculating the statistic.
 min_periods : int, default None
@@ -49,11 +58,9 @@ freq : string or DateOffset object, optional (default None)
     for `freq`.
 center : boolean, default False
     Set the labels at the center of the window.
-    
-Returns
--------
-%s
+"""
 
+_roll_notes = r"""
 Notes
 -----
 By default, the result is set to the right edge of the window. This can be
@@ -65,12 +72,7 @@ of :meth:`~pandas.Series.resample` (i.e. using the `mean`).
 """
 
 
-_ewm_doc = r"""%s
-
-Parameters
-----------
-%s
-com : float. optional
+_ewm_kw = r"""com : float. optional
     Center of mass: :math:`\alpha = 1 / (1 + com)`,
 span : float, optional
     Specify decay in terms of span, :math:`\alpha = 2 / (span + 1)`
@@ -85,8 +87,9 @@ freq : None or string alias / date offset object, default=None
 adjust : boolean, default True
     Divide by decaying adjustment factor in beginning periods to account for
     imbalance in relative weightings (viewing EWMA as a moving average)
+"""
 
-%s
+_ewm_notes = """
 Notes
 -----
 Either center of mass or span must be specified
@@ -99,60 +102,51 @@ where c is the center of mass. Given a span, the associated center of mass is
 :math:`c = (s - 1) / 2`
 
 So a "20-day EWMA" would have center 9.5.
-
-Returns
--------
-%s
 """
 
-
-_expanding_doc = """
-%s
-
-Parameters
-----------
-%s
-min_periods : int, default None
+_expanding_kw = """min_periods : int, default None
     Minimum number of observations in window required to have a value
     (otherwise result is NA).
 freq : string or DateOffset object, optional (default None)
     Frequency to conform the data to before computing the statistic. Specified
     as a frequency string or DateOffset object. `time_rule` is a legacy alias
     for `freq`.
-
-Returns
--------
-%s
-
-Notes
------
-The `freq` keyword is used to conform time series data to a specified
-frequency by resampling the data. This is done with the default parameters
-of :meth:`~pandas.Series.resample` (i.e. using the `mean`).
 """
 
 
-_type_of_input = "y : type of input argument"
+_type_of_input_retval = "y : type of input argument"
 
 _flex_retval = """y : type depends on inputs
-    DataFrame / DataFrame -> DataFrame (matches on columns)
+    DataFrame / DataFrame -> DataFrame (matches on columns) or Panel (pairwise)
     DataFrame / Series -> Computes result for each column
     Series / Series -> Series"""
 
 _pairwise_retval = "y : Panel whose items are df1.index values"
 
-_unary_arg = "arg : Series, DataFrame"
+_unary_arg = "arg : Series, DataFrame\n"
 
 _binary_arg_flex = """arg1 : Series, DataFrame, or ndarray
-arg2 : Series, DataFrame, or ndarray"""
+arg2 : Series, DataFrame, or ndarray, optional
+    if not supplied then will default to arg1 and produce pairwise output
+"""
 
 _binary_arg = """arg1 : Series, DataFrame, or ndarray
-arg2 : Series, DataFrame, or ndarray"""
+arg2 : Series, DataFrame, or ndarray
+"""
 
 _pairwise_arg = """df1 : DataFrame
-df2 : DataFrame"""
+df2 : DataFrame
+"""
+
+_pairwise_kw = """pairwise : bool, default False
+    If False then only matching columns between arg1 and arg2 will be used and
+    the output will be a DataFrame.
+    If True then all pairwise combinations will be calculated and the output
+    will be a Panel in the case of DataFrame inputs. In the case of missing
+    elements, only complete pairwise observations will be used.
+"""
 
-_bias_doc = r"""bias : boolean, default False
+_bias_kw = r"""bias : boolean, default False
     Use a standard estimation bias correction
 """
 
@@ -199,7 +193,8 @@ def rolling_count(arg, window, freq=None, center=False, time_rule=None):
     return return_hook(result)
 
 
-@Substitution("Unbiased moving covariance.", _binary_arg_flex, _flex_retval)
+@Substitution("Unbiased moving covariance.", _binary_arg_flex,
+              _roll_kw+_pairwise_kw, _flex_retval, _roll_notes)
 @Appender(_doc_template)
 def rolling_cov(arg1, arg2=None, window=None, min_periods=None, freq=None,
                 center=False, time_rule=None, pairwise=None):
@@ -223,7 +218,8 @@ def rolling_cov(arg1, arg2=None, window=None, min_periods=None, freq=None,
     return rs
 
 
-@Substitution("Moving sample correlation.", _binary_arg_flex, _flex_retval)
+@Substitution("Moving sample correlation.", _binary_arg_flex,
+              _roll_kw+_pairwise_kw, _flex_retval, _roll_notes)
 @Appender(_doc_template)
 def rolling_corr(arg1, arg2=None, window=None, min_periods=None, freq=None,
                  center=False, time_rule=None, pairwise=None):
@@ -296,7 +292,7 @@ def _flex_binary_moment(arg1, arg2, f, pairwise=False):
 
 
 @Substitution("Pairwise moving sample correlation", _pairwise_arg,
-              _pairwise_retval)
+              _roll_kw, _pairwise_retval, _roll_notes)
 @Appender(_doc_template)
 def rolling_corr_pairwise(df1, df2=None, window=None, min_periods=None,
                           freq=None, center=False, time_rule=None):
@@ -415,9 +411,9 @@ def _get_center_of_mass(com, span, halflife):
     return float(com)
 
 
-@Substitution("Exponentially-weighted moving average", _unary_arg, "",
-              _type_of_input)
-@Appender(_ewm_doc)
+@Substitution("Exponentially-weighted moving average", _unary_arg, _ewm_kw,
+              _type_of_input_retval, _ewm_notes)
+@Appender(_doc_template)
 def ewma(arg, com=None, span=None, halflife=None, min_periods=0, freq=None, time_rule=None,
          adjust=True):
     com = _get_center_of_mass(com, span, halflife)
@@ -439,9 +435,9 @@ def _first_valid_index(arr):
     return notnull(arr).argmax() if len(arr) else 0
 
 
-@Substitution("Exponentially-weighted moving variance", _unary_arg, _bias_doc,
-              _type_of_input)
-@Appender(_ewm_doc)
+@Substitution("Exponentially-weighted moving variance", _unary_arg,
+              _ewm_kw+_bias_kw, _type_of_input_retval, _ewm_notes)
+@Appender(_doc_template)
 def ewmvar(arg, com=None, span=None, halflife=None, min_periods=0, bias=False,
            freq=None, time_rule=None):
     com = _get_center_of_mass(com, span, halflife)
@@ -456,9 +452,9 @@ def ewmvar(arg, com=None, span=None, halflife=None, min_periods=0, bias=False,
     return result
 
 
-@Substitution("Exponentially-weighted moving std", _unary_arg, _bias_doc,
-              _type_of_input)
-@Appender(_ewm_doc)
+@Substitution("Exponentially-weighted moving std", _unary_arg,
+              _ewm_kw+_bias_kw, _type_of_input_retval, _ewm_notes)
+@Appender(_doc_template)
 def ewmstd(arg, com=None, span=None, halflife=None, min_periods=0, bias=False,
            time_rule=None):
     result = ewmvar(arg, com=com, span=span, halflife=halflife, time_rule=time_rule,
@@ -468,9 +464,9 @@ def ewmstd(arg, com=None, span=None, halflife=None, min_periods=0, bias=False,
 ewmvol = ewmstd
 
 
-@Substitution("Exponentially-weighted moving covariance", _binary_arg, "",
-              _type_of_input)
-@Appender(_ewm_doc)
+@Substitution("Exponentially-weighted moving covariance", _binary_arg_flex,
+              _ewm_kw+_pairwise_kw, _type_of_input_retval, _ewm_notes)
+@Appender(_doc_template)
 def ewmcov(arg1, arg2=None, com=None, span=None, halflife=None, min_periods=0, bias=False,
            freq=None, time_rule=None, pairwise=None):
     if arg2 is None:
@@ -495,9 +491,9 @@ def ewmcov(arg1, arg2=None, com=None, span=None, halflife=None, min_periods=0, b
     return result
 
 
-@Substitution("Exponentially-weighted moving correlation", _binary_arg, "",
-              _type_of_input)
-@Appender(_ewm_doc)
+@Substitution("Exponentially-weighted moving correlation", _binary_arg_flex,
+              _ewm_kw+_pairwise_kw, _type_of_input_retval, _ewm_notes)
+@Appender(_doc_template)
 def ewmcorr(arg1, arg2=None, com=None, span=None, halflife=None, min_periods=0,
             freq=None, time_rule=None, pairwise=None):
     if arg2 is None:
@@ -581,7 +577,7 @@ def _use_window(minp, window):
 
 
 def _rolling_func(func, desc, check_minp=_use_window):
-    @Substitution(desc, _unary_arg, _type_of_input)
+    @Substitution(desc, _unary_arg, _roll_kw, _type_of_input_retval, _roll_notes)
     @Appender(_doc_template)
     @wraps(func)
     def f(arg, window, min_periods=None, freq=None, center=False,
@@ -814,8 +810,8 @@ def _pop_args(win_type, arg_names, kwargs):
 
 
 def _expanding_func(func, desc, check_minp=_use_window):
-    @Substitution(desc, _unary_arg, _type_of_input)
-    @Appender(_expanding_doc)
+    @Substitution(desc, _unary_arg, _expanding_kw, _type_of_input_retval, "")
+    @Appender(_doc_template)
     @wraps(func)
     def f(arg, min_periods=1, freq=None, center=False, time_rule=None,
           **kwargs):
@@ -911,8 +907,9 @@ def expanding_quantile(arg, quantile, min_periods=1, freq=None,
                             freq=freq, center=center, time_rule=time_rule)
 
 
-@Substitution("Unbiased expanding covariance.", _binary_arg_flex, _flex_retval)
-@Appender(_expanding_doc)
+@Substitution("Unbiased expanding covariance.", _binary_arg_flex,
+              _expanding_kw+_pairwise_kw, _flex_retval, "")
+@Appender(_doc_template)
 def expanding_cov(arg1, arg2=None, min_periods=1, freq=None, center=False,
                   time_rule=None, pairwise=None):
     if arg2 is None:
@@ -928,8 +925,9 @@ def expanding_cov(arg1, arg2=None, min_periods=1, freq=None, center=False,
                        center=center, time_rule=time_rule, pairwise=pairwise)
 
 
-@Substitution("Expanding sample correlation.", _binary_arg_flex, _flex_retval)
-@Appender(_expanding_doc)
+@Substitution("Expanding sample correlation.", _binary_arg_flex,
+              _expanding_kw+_pairwise_kw, _flex_retval, "")
+@Appender(_doc_template)
 def expanding_corr(arg1, arg2=None, min_periods=1, freq=None, center=False,
                    time_rule=None, pairwise=None):
     if arg2 is None:
@@ -947,8 +945,8 @@ def expanding_corr(arg1, arg2=None, min_periods=1, freq=None, center=False,
 
 
 @Substitution("Pairwise expanding sample correlation", _pairwise_arg,
-              _pairwise_retval)
-@Appender(_expanding_doc)
+              _expanding_kw, _pairwise_retval, "")
+@Appender(_doc_template)
 def expanding_corr_pairwise(df1, df2=None, min_periods=1, freq=None,
                             center=False, time_rule=None):
     return expanding_corr(df1, df2, min_periods=min_periods,

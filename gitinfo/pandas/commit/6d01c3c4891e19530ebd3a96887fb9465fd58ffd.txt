commit 6d01c3c4891e19530ebd3a96887fb9465fd58ffd
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Jun 5 14:25:05 2012 -0400

    ENH: split out time zone localize logic from conversion, add tz_localize methods to Series, DataFrame. adjust unit tests. close #1403

diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index edd5d79d0..7845ee0e7 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -885,6 +885,43 @@ class NDFrame(PandasObject):
             new_obj._set_axis(1, new_ax)
         elif axis == 1:
             new_obj._set_axis(0, new_ax)
+            self._clear_item_cache()
+
+        return new_obj
+
+    def tz_localize(self, tz, axis=0, copy=True):
+        """
+        Localize tz-naive TimeSeries to target time zone
+
+        Parameters
+        ----------
+        tz : string or pytz.timezone object
+        copy : boolean, default True
+            Also make a copy of the underlying data
+
+        Returns
+        -------
+        """
+        axis = self._get_axis_number(axis)
+        ax = self._get_axis(axis)
+
+        if not hasattr(ax, 'tz_localize'):
+            ax_name = self._get_axis_name(axis)
+            raise TypeError('%s is not a valid DatetimeIndex or PeriodIndex' %
+                            ax_name)
+
+        new_data = self._data
+        if copy:
+            new_data = new_data.copy()
+
+        new_obj = self._constructor(new_data)
+        new_ax = ax.tz_localize(tz)
+
+        if axis == 0:
+            new_obj._set_axis(1, new_ax)
+        elif axis == 1:
+            new_obj._set_axis(0, new_ax)
+            self._clear_item_cache()
 
         return new_obj
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index e098bd0b5..7488f73c6 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2830,8 +2830,7 @@ class TimeSeries(Series):
 
     def tz_convert(self, tz, copy=True):
         """
-        Convert TimeSeries to target time zone. If it is time zone naive, it
-        will be localized to the passed time zone.
+        Convert TimeSeries to target time zone
 
         Parameters
         ----------
@@ -2841,6 +2840,7 @@ class TimeSeries(Series):
 
         Returns
         -------
+        converted : TimeSeries
         """
         new_index = self.index.tz_convert(tz)
 
@@ -2850,6 +2850,28 @@ class TimeSeries(Series):
 
         return Series(new_values, index=new_index, name=self.name)
 
+    def tz_localize(self, tz, copy=True):
+        """
+        Localize tz-naive TimeSeries to target time zone
+
+        Parameters
+        ----------
+        tz : string or pytz.timezone object
+        copy : boolean, default True
+            Also make a copy of the underlying data
+
+        Returns
+        -------
+        localized : TimeSeries
+        """
+        new_index = self.index.tz_localize(tz)
+
+        new_values = self.values
+        if copy:
+            new_values = new_values.copy()
+
+        return Series(new_values, index=new_index, name=self.name)
+
     def to_timestamp(self, freq=None, how='start', copy=True):
         """
         Cast to datetimeindex of timestamps, at *beginning* of period
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index dff3551dd..729483e78 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -181,7 +181,8 @@ class Timestamp(_Timestamp):
             # tz naive, localize
             return Timestamp(self.to_pydatetime(), tz=tz)
         else:
-            raise Exception('Cannot localize tz-aware Timestamp')
+            raise Exception('Cannot localize tz-aware Timestamp, use '
+                            'tz_convert for conversions')
 
     def tz_convert(self, tz):
         """
@@ -197,7 +198,10 @@ class Timestamp(_Timestamp):
         converted : Timestamp
         """
         if self.tzinfo is None:
-            # tz naive, localize
+            # tz naive, use tz_localize
+            raise Exception('Cannot convert tz-naive Timestamp, use '
+                            'tz_localize to localize')
+
             return Timestamp(self.to_pydatetime(), tz=tz)
         else:
             # Same UTC timestamp, different time zone
diff --git a/pandas/src/engines.pyx b/pandas/src/engines.pyx
index 289260b45..47c611487 100644
--- a/pandas/src/engines.pyx
+++ b/pandas/src/engines.pyx
@@ -454,11 +454,14 @@ cpdef convert_scalar(ndarray arr, object value):
 
 cdef inline _to_i8(object val):
     cdef pandas_datetimestruct dts
-    if util.is_datetime64_object(val):
-        val = get_datetime64_value(val)
-    elif PyDateTime_Check(val):
-        return _pydatetime_to_dts(val, &dts)
-    return val
+    try:
+        return val.value
+    except AttributeError:
+        if util.is_datetime64_object(val):
+            return get_datetime64_value(val)
+        elif PyDateTime_Check(val):
+            return _pydatetime_to_dts(val, &dts)
+        return val
 
 
 # ctypedef fused idxvalue_t:
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index a366da780..ae3ef3046 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -322,10 +322,6 @@ class DatetimeIndex(Int64Index):
             # Convert local to UTC
             ints = index.view('i8')
             index = lib.tz_localize_to_utc(ints, tz)
-
-            # lib.tz_localize_check(ints, tz)
-            # index = lib.tz_convert(ints, tz, _utc())
-
             index = index.view(_NS_DTYPE)
 
         index = index.view(cls)
@@ -1174,7 +1170,9 @@ class DatetimeIndex(Int64Index):
         tz = tools._maybe_get_tz(tz)
 
         if self.tz is None:
-            return self.tz_localize(tz)
+            # tz naive, use tz_localize
+            raise Exception('Cannot convert tz-naive timestamps, use '
+                            'tz_localize to localize')
 
         # No conversion since timestamps are all UTC to begin with
         return self._simple_new(self.values, self.name, self.offset, tz)
@@ -1188,15 +1186,13 @@ class DatetimeIndex(Int64Index):
         localized : DatetimeIndex
         """
         if self.tz is not None:
-            raise ValueError("Already have timezone info, "
-                             "use tz_convert to convert.")
+            raise ValueError("Already tz-aware, use tz_convert to convert.")
         tz = tools._maybe_get_tz(tz)
 
-        lib.tz_localize_check(self.asi8, tz)
-
         # Convert to UTC
-        new_dates = lib.tz_convert(self.asi8, tz, _utc())
+        new_dates = lib.tz_localize_to_utc(self.asi8, tz)
         new_dates = new_dates.view(_NS_DTYPE)
+
         return self._simple_new(new_dates, self.name, self.offset, tz)
 
     def tz_validate(self):
@@ -1355,111 +1351,3 @@ def _time_to_nanosecond(time):
     return (1000000 * seconds + time.microsecond) * 1000
 
 
-
-def tz_localize_to_utc(vals, tz):
-    """
-    Localize tzinfo-naive DateRange to given time zone (using pytz). If
-    there are ambiguities in the values, raise AmbiguousTimeError.
-
-    Returns
-    -------
-    localized : DatetimeIndex
-    """
-    # Vectorized version of DstTzInfo.localize
-
-    # if not have_pytz:
-    #     raise Exception("Could not find pytz module")
-    import pytz
-
-    n = len(vals)
-    DAY_NS = 86400000000000L
-    NPY_NAT = lib.iNaT
-
-    if tz == pytz.utc or tz is None:
-        return vals
-
-    trans = _get_transitions(tz)  # transition dates
-    deltas = _get_deltas(tz)      # utc offsets
-
-    result = np.empty(n, dtype=np.int64)
-    result_a = np.empty(n, dtype=np.int64)
-    result_b = np.empty(n, dtype=np.int64)
-    result_a.fill(NPY_NAT)
-    result_b.fill(NPY_NAT)
-
-    # left side
-    idx_shifted = np.maximum(0, trans.searchsorted(vals - DAY_NS,
-                                                   side='right') - 1)
-
-    for i in range(n):
-        v = vals[i] - deltas[idx_shifted[i]]
-        pos = trans.searchsorted(v, side='right') - 1
-
-        # timestamp falls to the left side of the DST transition
-        if v + deltas[pos] == vals[i]:
-            result_a[i] = v
-
-    # right side
-    idx_shifted = np.maximum(0, trans.searchsorted(vals + DAY_NS,
-                                                   side='right') - 1)
-
-    for i in range(n):
-        v = vals[i] - deltas[idx_shifted[i]]
-        pos = trans.searchsorted(v, side='right') - 1
-
-        # timestamp falls to the right side of the DST transition
-        if v + deltas[pos] == vals[i]:
-            result_b[i] = v
-
-    for i in range(n):
-        left = result_a[i]
-        right = result_b[i]
-        if left != NPY_NAT and right != NPY_NAT:
-            if left == right:
-                result[i] = left
-            else:
-                stamp = Timestamp(vals[i])
-                raise pytz.AmbiguousTimeError(stamp)
-        elif left != NPY_NAT:
-            result[i] = left
-        elif right != NPY_NAT:
-            result[i] = right
-        else:
-            stamp = Timestamp(vals[i])
-            raise pytz.NonExistentTimeError(stamp)
-
-    return result
-
-
-trans_cache = {}
-utc_offset_cache = {}
-
-def _get_transitions(tz):
-    """
-    Get UTC times of DST transitions
-    """
-    if tz not in trans_cache:
-        arr = np.array(tz._utc_transition_times, dtype='M8[ns]')
-        trans_cache[tz] = arr.view('i8')
-    return trans_cache[tz]
-
-def _get_deltas(tz):
-    """
-    Get UTC offsets in microseconds corresponding to DST transitions
-    """
-    if tz not in utc_offset_cache:
-        utc_offset_cache[tz] = _unbox_utcoffsets(tz._transition_info)
-    return utc_offset_cache[tz]
-
-def total_seconds(td): # Python 2.6 compat
-    return ((td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) //
-            10**6)
-
-def _unbox_utcoffsets(transinfo):
-    sz = len(transinfo)
-    arr = np.empty(sz, dtype='i8')
-
-    for i in range(sz):
-        arr[i] = int(total_seconds(transinfo[i][0])) * 1000000000
-
-    return arr
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index e57c1c727..aa7fbb946 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -92,6 +92,13 @@ def assert_range_equal(left, right):
     assert(left.tz == right.tz)
 
 
+def _skip_if_no_pytz():
+    try:
+        import pytz
+    except ImportError:
+        raise nose.SkipTest
+
+
 class TestTimeSeries(unittest.TestCase):
 
     def test_dti_slicing(self):
@@ -140,6 +147,7 @@ class TestTimeSeries(unittest.TestCase):
         self.assert_(isinstance(s[5], Timestamp))
 
     def test_timestamp_to_datetime(self):
+        _skip_if_no_pytz()
         rng = date_range('20090415', '20090519',
                          tz='US/Eastern')
 
@@ -149,6 +157,8 @@ class TestTimeSeries(unittest.TestCase):
         self.assertEquals(stamp.tzinfo, dtval.tzinfo)
 
     def test_index_convert_to_datetime_array(self):
+        _skip_if_no_pytz()
+
         def _check_rng(rng):
             converted = rng.to_pydatetime()
             self.assert_(isinstance(converted, np.ndarray))
@@ -1495,6 +1505,7 @@ class TestTimestamp(unittest.TestCase):
         self.assert_(other >= val)
 
     def test_cant_compare_tz_naive_w_aware(self):
+        _skip_if_no_pytz()
         # #1404
         a = Timestamp('3/12/2012')
         b = Timestamp('3/12/2012', tz='utc')
@@ -1516,27 +1527,6 @@ class TestTimestamp(unittest.TestCase):
         result = val + timedelta(1)
         self.assert_(result.nanosecond == val.nanosecond)
 
-    def test_tz_convert_localize(self):
-        stamp = Timestamp('3/11/2012 04:00')
-
-        result = stamp.tz_convert('US/Eastern')
-        expected = Timestamp('3/11/2012 04:00', tz='US/Eastern')
-        self.assertEquals(result.hour, expected.hour)
-        self.assertEquals(result, expected)
-
-    def test_timedelta_push_over_dst_boundary(self):
-        # #1389
-
-        # 4 hours before DST transition
-        stamp = Timestamp('3/10/2012 22:00', tz='US/Eastern')
-
-        result = stamp + timedelta(hours=6)
-
-        # spring forward, + "7" hours
-        expected = Timestamp('3/11/2012 05:00', tz='US/Eastern')
-
-        self.assertEquals(result, expected)
-
     def test_frequency_misc(self):
         self.assertEquals(fmod.get_freq_group('T'),
                           fmod.FreqGroup.FR_MIN)
diff --git a/pandas/tseries/tests/test_timezones.py b/pandas/tseries/tests/test_timezones.py
index ba38ef382..a91365c5c 100644
--- a/pandas/tseries/tests/test_timezones.py
+++ b/pandas/tseries/tests/test_timezones.py
@@ -74,6 +74,27 @@ class TestTimeZoneSupport(unittest.TestCase):
         rng = date_range('3/11/2012', '3/12/2012', freq='30T')
         self.assertRaises(Exception, rng.tz_localize, 'US/Eastern')
 
+    def test_timestamp_tz_localize(self):
+        stamp = Timestamp('3/11/2012 04:00')
+
+        result = stamp.tz_localize('US/Eastern')
+        expected = Timestamp('3/11/2012 04:00', tz='US/Eastern')
+        self.assertEquals(result.hour, expected.hour)
+        self.assertEquals(result, expected)
+
+    def test_timedelta_push_over_dst_boundary(self):
+        # #1389
+
+        # 4 hours before DST transition
+        stamp = Timestamp('3/10/2012 22:00', tz='US/Eastern')
+
+        result = stamp + timedelta(hours=6)
+
+        # spring forward, + "7" hours
+        expected = Timestamp('3/11/2012 05:00', tz='US/Eastern')
+
+        self.assertEquals(result, expected)
+
     def test_tz_localize_dti(self):
         from pandas.tseries.offsets import Hour
 
@@ -97,8 +118,7 @@ class TestTimeZoneSupport(unittest.TestCase):
 
         dti = DatetimeIndex(start='3/13/2011 1:59', end='3/13/2011 2:00',
                             freq='L')
-        self.assertRaises(pytz.AmbiguousTimeError, dti.tz_localize,
-                          'US/Eastern')
+        self.assertRaises(pytz.NonExistentTimeError, dti.tz_localize, 'US/Eastern')
 
     def test_create_with_tz(self):
         stamp = Timestamp('3/11/2012 05:00', tz='US/Eastern')
@@ -119,6 +139,10 @@ class TestTimeZoneSupport(unittest.TestCase):
         rng = date_range('3/11/2012 03:00', periods=15, freq='H', tz='US/Eastern')
         rng2 = DatetimeIndex(['3/11/2012 03:00', '3/11/2012 04:00'],
                              tz='US/Eastern')
+        rng3 = date_range('3/11/2012 03:00', periods=15, freq='H')
+        rng3 = rng3.tz_localize('US/Eastern')
+
+        self.assert_(rng.equals(rng3))
 
         # DST transition time
         val = rng[0]
@@ -169,11 +193,11 @@ class TestTimeZoneSupport(unittest.TestCase):
 
         self.assertEquals(conv, expected)
 
-    def test_pass_dates_convert_to_utc(self):
+    def test_pass_dates_localize_to_utc(self):
         strdates = ['1/1/2012', '3/1/2012', '4/1/2012']
 
         idx = DatetimeIndex(strdates)
-        conv = idx.tz_convert('US/Eastern')
+        conv = idx.tz_localize('US/Eastern')
 
         fromdates = DatetimeIndex(strdates, tz='US/Eastern')
 
@@ -227,7 +251,7 @@ class TestTimeZoneSupport(unittest.TestCase):
         # March 13, 2011, spring forward, skip from 2 AM to 3 AM
         dr = date_range(datetime(2011, 3, 13, 1, 30), periods=3,
                         freq=datetools.Hour())
-        self.assertRaises(pytz.AmbiguousTimeError, dr.tz_localize, tz)
+        self.assertRaises(pytz.NonExistentTimeError, dr.tz_localize, tz)
 
         # after dst transition, it works
         dr = date_range(datetime(2011, 3, 13, 3, 30), periods=3,
@@ -282,7 +306,7 @@ class TestTimeZoneSupport(unittest.TestCase):
     def test_index_with_timezone_repr(self):
         rng = date_range('4/13/2010', '5/6/2010')
 
-        rng_eastern = rng.tz_convert('US/Eastern')
+        rng_eastern = rng.tz_localize('US/Eastern')
 
         rng_repr = repr(rng)
         self.assert_('2010-04-13 00:00:00' in rng_repr)
@@ -317,31 +341,51 @@ class TestTimeZones(unittest.TestCase):
 
         self.assert_(not left.equals(right))
 
-    def test_tz_convert_naive(self):
+    def test_tz_localize_naive(self):
         rng = date_range('1/1/2011', periods=100, freq='H')
 
-        conv = rng.tz_convert('US/Pacific')
-        exp = rng.tz_localize('US/Pacific')
+        conv = rng.tz_localize('US/Pacific')
+        exp = date_range('1/1/2011', periods=100, freq='H', tz='US/Pacific')
+
         self.assert_(conv.equals(exp))
 
-    def test_tz_convert(self):
+    def test_series_frame_tz_localize(self):
         rng = date_range('1/1/2011', periods=100, freq='H')
         ts = Series(1, index=rng)
 
-        result = ts.tz_convert('utc')
+        result = ts.tz_localize('utc')
         self.assert_(result.index.tz.zone == 'UTC')
 
         df = DataFrame({'a': 1}, index=rng)
-        result = df.tz_convert('utc')
-        expected = DataFrame({'a': 1}, rng.tz_convert('UTC'))
+        result = df.tz_localize('utc')
+        expected = DataFrame({'a': 1}, rng.tz_localize('UTC'))
         self.assert_(result.index.tz.zone == 'UTC')
         assert_frame_equal(result, expected)
 
         df = df.T
-        result = df.tz_convert('utc', axis=1)
+        result = df.tz_localize('utc', axis=1)
         self.assert_(result.columns.tz.zone == 'UTC')
         assert_frame_equal(result, expected.T)
 
+    def test_series_frame_tz_convert(self):
+        rng = date_range('1/1/2011', periods=200, freq='D',
+                         tz='US/Eastern')
+        ts = Series(1, index=rng)
+
+        result = ts.tz_convert('Europe/Berlin')
+        self.assert_(result.index.tz.zone == 'Europe/Berlin')
+
+        df = DataFrame({'a': 1}, index=rng)
+        result = df.tz_convert('Europe/Berlin')
+        expected = DataFrame({'a': 1}, rng.tz_convert('Europe/Berlin'))
+        self.assert_(result.index.tz.zone == 'Europe/Berlin')
+        assert_frame_equal(result, expected)
+
+        df = df.T
+        result = df.tz_convert('Europe/Berlin', axis=1)
+        self.assert_(result.columns.tz.zone == 'Europe/Berlin')
+        assert_frame_equal(result, expected.T)
+
     def test_join_utc_convert(self):
         rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
 

commit 3cdc0cddd6eb68d5f0f47478c5fc46b5effa0f6c
Author: jreback <jeff@reback.net>
Date:   Sun Dec 23 16:06:54 2012 -0500

    BUG: added datetime64 support in columns

diff --git a/RELEASE.rst b/RELEASE.rst
index fd958ebb2..c57678fd0 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -41,12 +41,13 @@ pandas 0.10.1
     - added ``get_store`` context manager to automatically import with pandas
     - added column filtering via ``columns`` keyword in select
     - added methods append_to_multiple/select_as_multiple/select_as_coordinates to do multiple-table append/selection
+    - added support for datetime64 in columns
 
 **Bug fixes**
 
   - ``HDFStore``
     - correctly handle ``nan`` elements in string columns; serialize via the ``nan_rep`` keyword to append
-    - raise correctly on non-implemented column types (unicode/datetime64/date)
+    - raise correctly on non-implemented column types (unicode/date)
     - handle correctly ``Term`` passed types (e.g. ``index<1000``, when index is ``Int64``), (closes GH512_)
 
 .. _GH512: https://github.com/pydata/pandas/issues/512
diff --git a/doc/source/io.rst b/doc/source/io.rst
index 36ae14aaa..39251a6b0 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -1106,7 +1106,7 @@ Storing Mixed Types in a Table
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 Storing mixed-dtype data is supported. Strings are store as a fixed-width using the maximum size of the appended column. Subsequent appends will truncate strings at this length.
-Passing ``min_itemsize = { `values` : size }`` as a parameter to append will set a larger minimum for the string columns. Storing ``floats, strings, ints, bools`` are currently supported. For string columns, passing ``nan_rep = 'my_nan_rep'`` to append will change the default nan representation on disk (which converts to/from `np.nan`), this defaults to `nan`.
+Passing ``min_itemsize = { `values` : size }`` as a parameter to append will set a larger minimum for the string columns. Storing ``floats, strings, ints, bools, datetime64`` are currently supported. For string columns, passing ``nan_rep = 'my_nan_rep'`` to append will change the default nan representation on disk (which converts to/from `np.nan`), this defaults to `nan`.
 
 .. ipython:: python
 
@@ -1114,6 +1114,7 @@ Passing ``min_itemsize = { `values` : size }`` as a parameter to append will set
     df_mixed['string']   = 'string'
     df_mixed['int']      = 1
     df_mixed['bool']     = True
+    df_mixed['datetime64'] = Timestamp('20010102')
     df_mixed.ix[3:4,['A','B','string']] = np.nan
 
     store.append('df_mixed', df_mixed, min_itemsize = { 'values' : 50 })
@@ -1124,6 +1125,8 @@ Passing ``min_itemsize = { `values` : size }`` as a parameter to append will set
     # we have provided a minimum string column size
     store.root.df_mixed.table
 
+It is ok to store ``np.nan`` in a ``float or string``. Storing a column with a ``np.nan`` in a ``int, bool, or datetime64`` will currently throw an ``Exception`` as these columns will have converted to ``object`` type.
+
 Storing Multi-Index DataFrames
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
diff --git a/doc/source/v0.10.1.txt b/doc/source/v0.10.1.txt
index ebc343261..fd585d2a5 100644
--- a/doc/source/v0.10.1.txt
+++ b/doc/source/v0.10.1.txt
@@ -43,6 +43,18 @@ You can designate (and index) certain columns that you want to be able to perfor
    # this is in-memory version of this type of selection
    df[(df.B > 0) & (df.string == 'foo')]
 
+You can now store ``datetime64`` in data columns
+
+.. ipython:: python
+
+    df_mixed               = df.copy()
+    df_mixed['datetime64'] = Timestamp('20010102')
+    df_mixed.ix[3:4,['A','B']] = np.nan
+
+    store.append('df_mixed', df_mixed)
+    df_mixed1 = store.select('df_mixed')
+    df_mixed1
+    df_mixed1.get_dtype_counts()
 
 You can pass ``columns`` keyword to select to filter a list of the return columns, this is equivalent to passing a ``Term('columns',list_of_columns_to_filter)``
 
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 2c065d894..184fa7fb6 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -1246,10 +1246,13 @@ class DataCol(IndexCol):
         """ compare 2 col items """
         return all([ getattr(self,a,None) == getattr(other,a,None) for a in ['name','cname','dtype','pos'] ])
 
-    def set_data(self, data):
+    def set_data(self, data, dtype = None):
         self.data = data
         if data is not None:
-            if self.dtype is None:
+            if dtype is not None:
+                self.dtype = dtype
+                self.set_kind()
+            elif self.dtype is None:
                 self.dtype = data.dtype.name
                 self.set_kind()
 
@@ -1267,23 +1270,26 @@ class DataCol(IndexCol):
                 self.kind = 'float'
             elif self.dtype.startswith('int'):
                 self.kind = 'integer'
+            elif self.dtype.startswith('date'):
+                self.kind = 'datetime'
 
     def set_atom(self, block, existing_col, min_itemsize, nan_rep, **kwargs):
         """ create and setup my atom from the block b """
 
         self.values   = list(block.items)
         dtype         = block.dtype.name
+        inferred_type = lib.infer_dtype(block.values.flatten())
 
-        if dtype == 'object':
-            inferred_type = lib.infer_dtype(block.values.flatten())
-            if inferred_type == 'unicode':
-                raise NotImplementedError("unicode is not implemented as a table column")
-            elif inferred_type == 'date':
-                raise NotImplementedError("date is not implemented as a table column")
+        if inferred_type == 'datetime64':
+            self.set_atom_datetime64(block)
+        elif inferred_type == 'date':
+            raise NotImplementedError("date is not implemented as a table column")
+        elif inferred_type == 'unicode':
+            raise NotImplementedError("unicode is not implemented as a table column")
 
+        ### this is basically a catchall; if say a datetime64 has nans then will end up here ###
+        elif inferred_type == 'string' or dtype == 'object':
             self.set_atom_string(block, existing_col, min_itemsize, nan_rep)
-        elif dtype == 'datetime64[ns]':
-            raise NotImplementedError("datetime64[ns] is not implemented as a table column")
         else:
             self.set_atom_data(block)
 
@@ -1324,6 +1330,14 @@ class DataCol(IndexCol):
         self.typ    = self.get_atom_data(block)
         self.set_data(block.values.astype(self.typ._deftype))
 
+    def get_atom_datetime64(self, block):
+        return _tables().Int64Col(shape = block.shape[0])
+
+    def set_atom_datetime64(self, block):
+        self.kind   = 'datetime64'
+        self.typ    = self.get_atom_datetime64(block)
+        self.set_data(block.values.view('i8'),'datetime64')
+
     @property
     def shape(self):
         return getattr(self.data,'shape',None)
@@ -1354,10 +1368,21 @@ class DataCol(IndexCol):
 
         # convert to the correct dtype
         if self.dtype is not None:
-            try:
-                self.data = self.data.astype(self.dtype)
-            except:
-                self.data = self.data.astype('O')
+
+            # reverse converts
+            if self.dtype == 'datetime64':
+                self.data = np.asarray(self.data, dtype='M8[ns]')
+            elif self.dtype == 'date':
+                self.data = np.array([date.fromtimestamp(v) for v in self.data], dtype=object)
+            elif self.dtype == 'datetime':
+                self.data = np.array([datetime.fromtimestamp(v) for v in self.data],
+                                     dtype=object)
+            else:
+
+                try:
+                    self.data = self.data.astype(self.dtype)
+                except:
+                    self.data = self.data.astype('O')
 
         # convert nans
         if self.kind == 'string':
@@ -1389,6 +1414,9 @@ class DataIndexableCol(DataCol):
     def get_atom_data(self, block):
         return getattr(_tables(),"%sCol" % self.kind.capitalize())()
 
+    def get_atom_datetime64(self, block):
+        return _tables().Int64Col()
+
 class Table(object):
     """ represent a table:
           facilitate read/write of various types of tables
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index e62262656..296e807b5 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -13,7 +13,7 @@ from pandas.io.pytables import HDFStore, get_store, Term, IncompatibilityWarning
 import pandas.util.testing as tm
 from pandas.tests.test_series import assert_series_equal
 from pandas.tests.test_frame import assert_frame_equal
-from pandas import concat
+from pandas import concat, Timestamp
 
 try:
     import tables
@@ -482,10 +482,14 @@ class TestHDFStore(unittest.TestCase):
         df_dc.ix[4:6,'string'] = np.nan
         df_dc.ix[7:9,'string'] = 'bar'
         df_dc['string2'] = 'cool'
-        df_dc
+        df_dc['datetime'] = Timestamp('20010102')
         self.store.remove('df_dc')
-        self.store.append('df_dc', df_dc, data_columns = ['B','C','string','string2'])
+        self.store.append('df_dc', df_dc, data_columns = ['B','C','string','string2','datetime'])
         result = self.store.select('df_dc',[ Term('B>0') ])
+
+        # convert it
+        df_dc = df_dc.consolidate().convert_objects()
+
         expected = df_dc[df_dc.B > 0]
         tm.assert_frame_equal(result, expected)
 
@@ -699,61 +703,74 @@ class TestHDFStore(unittest.TestCase):
     def test_table_mixed_dtypes(self):
 
         # frame
-        def _make_one_df():
-            df = tm.makeDataFrame()
-            df['obj1'] = 'foo'
-            df['obj2'] = 'bar'
-            df['bool1'] = df['A'] > 0
-            df['bool2'] = df['B'] > 0
-            df['bool3'] = True
-            df['int1'] = 1
-            df['int2'] = 2
-            return df.consolidate()
-
-        df1 = _make_one_df()
-
-        self.store.append('df1_mixed', df1)
-        tm.assert_frame_equal(self.store.select('df1_mixed'), df1)
+        df = tm.makeDataFrame()
+        df['obj1'] = 'foo'
+        df['obj2'] = 'bar'
+        df['bool1'] = df['A'] > 0
+        df['bool2'] = df['B'] > 0
+        df['bool3'] = True
+        df['int1'] = 1
+        df['int2'] = 2
+        df['timestamp1'] = Timestamp('20010102')
+        df['timestamp2'] = Timestamp('20010103')
+        df['datetime1']  = datetime.datetime(2001,1,2,0,0)
+        df['datetime2']  = datetime.datetime(2001,1,3,0,0)
+        df.ix[3:6,['obj1']] = np.nan
+        df = df.consolidate().convert_objects()
+
+        self.store.append('df1_mixed', df)
+        tm.assert_frame_equal(self.store.select('df1_mixed'), df)
 
         # panel
-        def _make_one_panel():
-            wp = tm.makePanel()
-            wp['obj1'] = 'foo'
-            wp['obj2'] = 'bar'
-            wp['bool1'] = wp['ItemA'] > 0
-            wp['bool2'] = wp['ItemB'] > 0
-            wp['int1'] = 1
-            wp['int2'] = 2
-            return wp.consolidate()
-        p1 = _make_one_panel()
-
-        self.store.append('p1_mixed', p1)
-        tm.assert_panel_equal(self.store.select('p1_mixed'), p1)
+        wp = tm.makePanel()
+        wp['obj1'] = 'foo'
+        wp['obj2'] = 'bar'
+        wp['bool1'] = wp['ItemA'] > 0
+        wp['bool2'] = wp['ItemB'] > 0
+        wp['int1'] = 1
+        wp['int2'] = 2
+        wp = wp.consolidate()
+
+        self.store.append('p1_mixed', wp)
+        tm.assert_panel_equal(self.store.select('p1_mixed'), wp)
 
         # ndim
-        def _make_one_p4d():
-            wp = tm.makePanel4D()
-            wp['obj1'] = 'foo'
-            wp['obj2'] = 'bar'
-            wp['bool1'] = wp['l1'] > 0
-            wp['bool2'] = wp['l2'] > 0
-            wp['int1'] = 1
-            wp['int2'] = 2
-            return wp.consolidate()
-
-        p4d = _make_one_p4d()
-        self.store.append('p4d_mixed', p4d)
-        tm.assert_panel4d_equal(self.store.select('p4d_mixed'), p4d)
+        wp = tm.makePanel4D()
+        wp['obj1'] = 'foo'
+        wp['obj2'] = 'bar'
+        wp['bool1'] = wp['l1'] > 0
+        wp['bool2'] = wp['l2'] > 0
+        wp['int1'] = 1
+        wp['int2'] = 2
+        wp = wp.consolidate()
+    
+        self.store.append('p4d_mixed', wp)
+        tm.assert_panel4d_equal(self.store.select('p4d_mixed'), wp)
 
     def test_unimplemented_dtypes_table_columns(self):
         #### currently not supported dtypes ####
-        from pandas import Timestamp
-
-        for n,f in [ ('timestamp',Timestamp('20010102')), ('unicode',u'\u03c3'), ('datetime',datetime.datetime(2001,1,2)), ('date',datetime.date(2001,1,2)) ]:
+        for n,f in [ ('unicode',u'\u03c3'), ('date',datetime.date(2001,1,2)) ]:
             df = tm.makeDataFrame()
             df[n] = f
             self.assertRaises(NotImplementedError, self.store.append, 'df1_%s' % n, df)
 
+        # frame
+        df = tm.makeDataFrame()
+        df['obj1'] = 'foo'
+        df['obj2'] = 'bar'
+        df['datetime1']  = datetime.date(2001,1,2)
+        df = df.consolidate().convert_objects()
+
+        # datetime64 with nan
+        df = tm.makeDataFrame()
+        df['timestamp1'] = Timestamp('20010102')
+        df.ix[3:6,:] = np.nan
+        df = df.consolidate().convert_objects()
+        self.assertRaises(Exception, self.store.append, 'df_datetime64_with_nan', df)
+
+        # this fails because we have a date in the object block......
+        self.assertRaises(Exception, self.store.append, 'df_unimplemented', df)
+
     def test_remove(self):
         ts = tm.makeTimeSeries()
         df = tm.makeDataFrame()

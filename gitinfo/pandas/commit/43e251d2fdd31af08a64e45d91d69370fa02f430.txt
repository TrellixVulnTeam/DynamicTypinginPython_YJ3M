commit 43e251d2fdd31af08a64e45d91d69370fa02f430
Author: Kaiqi Dong <kaiqi@kth.se>
Date:   Fri Jan 3 14:10:48 2020 +0100

    ENH: Add ignore_index to sort_index (#30578)

diff --git a/doc/source/whatsnew/v1.0.0.rst b/doc/source/whatsnew/v1.0.0.rst
index 19ea72e9b..a5ea60d0a 100755
--- a/doc/source/whatsnew/v1.0.0.rst
+++ b/doc/source/whatsnew/v1.0.0.rst
@@ -222,6 +222,7 @@ Other enhancements
 - DataFrame constructor preserve `ExtensionArray` dtype with `ExtensionArray` (:issue:`11363`)
 - :meth:`DataFrame.sort_values` and :meth:`Series.sort_values` have gained ``ignore_index`` keyword to be able to reset index after sorting (:issue:`30114`)
 - :meth:`DataFrame.to_markdown` and :meth:`Series.to_markdown` added (:issue:`11052`)
+- :meth:`DataFrame.sort_index` and :meth:`Series.sort_index` have gained ``ignore_index`` keyword to reset index (:issue:`30114`)
 - :meth:`DataFrame.drop_duplicates` has gained ``ignore_index`` keyword to reset index (:issue:`30114`)
 - Added new writer for exporting Stata dta files in version 118, ``StataWriter118``.  This format supports exporting strings containing Unicode characters (:issue:`23573`)
 - :meth:`Series.map` now accepts ``collections.abc.Mapping`` subclasses as a mapper (:issue:`29733`)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 9b8bcbfa6..65b315167 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1992,7 +1992,7 @@ class DataFrame(NDFrame):
     @Substitution(klass="DataFrame")
     @Appender(_shared_docs["to_markdown"])
     def to_markdown(
-        self, buf: Optional[IO[str]] = None, mode: Optional[str] = None, **kwargs,
+        self, buf: Optional[IO[str]] = None, mode: Optional[str] = None, **kwargs
     ) -> Optional[str]:
         kwargs.setdefault("headers", "keys")
         kwargs.setdefault("tablefmt", "pipe")
@@ -4883,6 +4883,7 @@ class DataFrame(NDFrame):
         kind="quicksort",
         na_position="last",
         sort_remaining=True,
+        ignore_index: bool = False,
     ):
 
         # TODO: this can be combined with Series.sort_index impl as
@@ -4933,6 +4934,9 @@ class DataFrame(NDFrame):
         # reconstruct axis if needed
         new_data.axes[baxis] = new_data.axes[baxis]._sort_levels_monotonic()
 
+        if ignore_index:
+            new_data.axes[1] = ibase.default_index(len(indexer))
+
         if inplace:
             return self._update_inplace(new_data)
         else:
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index faad75b3d..89034973a 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -4185,6 +4185,7 @@ class NDFrame(PandasObject, SelectionMixin):
         kind: str = "quicksort",
         na_position: str = "last",
         sort_remaining: bool_t = True,
+        ignore_index: bool_t = False,
     ):
         """
         Sort object by labels (along an axis).
@@ -4211,6 +4212,10 @@ class NDFrame(PandasObject, SelectionMixin):
         sort_remaining : bool, default True
             If True and sorting by level and index is multilevel, sort by other
             levels too (in order) after sorting by specified level.
+        ignore_index : bool, default False
+            If True, the resulting axis will be labeled 0, 1, …, n - 1.
+
+            .. versionadded:: 1.0.0
 
         Returns
         -------
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 47bcc6d85..b81659920 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1418,7 +1418,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
     @Substitution(klass="Series")
     @Appender(generic._shared_docs["to_markdown"])
     def to_markdown(
-        self, buf: Optional[IO[str]] = None, mode: Optional[str] = None, **kwargs,
+        self, buf: Optional[IO[str]] = None, mode: Optional[str] = None, **kwargs
     ) -> Optional[str]:
         return self.to_frame().to_markdown(buf, mode, **kwargs)
 
@@ -2948,6 +2948,7 @@ Name: Max Speed, dtype: float64
         kind="quicksort",
         na_position="last",
         sort_remaining=True,
+        ignore_index: bool = False,
     ):
         """
         Sort Series by index labels.
@@ -2976,6 +2977,10 @@ Name: Max Speed, dtype: float64
         sort_remaining : bool, default True
             If True and sorting by level and index is multilevel, sort by other
             levels too (in order) after sorting by specified level.
+        ignore_index : bool, default False
+            If True, the resulting axis will be labeled 0, 1, …, n - 1.
+
+            .. versionadded:: 1.0.0
 
         Returns
         -------
@@ -3103,6 +3108,9 @@ Name: Max Speed, dtype: float64
         new_values = self._values.take(indexer)
         result = self._constructor(new_values, index=new_index)
 
+        if ignore_index:
+            result.index = ibase.default_index(len(result))
+
         if inplace:
             self._update_inplace(result)
         else:
@@ -4463,9 +4471,7 @@ Name: Max Speed, dtype: float64
     hist = pandas.plotting.hist_series
 
 
-Series._setup_axes(
-    ["index"], docs={"index": "The index (axis labels) of the Series."},
-)
+Series._setup_axes(["index"], docs={"index": "The index (axis labels) of the Series."})
 Series._add_numeric_operations()
 Series._add_series_or_dataframe_operations()
 
diff --git a/pandas/tests/frame/methods/test_sort_index.py b/pandas/tests/frame/methods/test_sort_index.py
index 4f311bbaa..6866aab11 100644
--- a/pandas/tests/frame/methods/test_sort_index.py
+++ b/pandas/tests/frame/methods/test_sort_index.py
@@ -229,3 +229,85 @@ class TestDataFrameSortIndex:
         )
         result = result.columns.levels[1].categories
         tm.assert_index_equal(result, expected)
+
+    @pytest.mark.parametrize(
+        "original_dict, sorted_dict, ascending, ignore_index, output_index",
+        [
+            ({"A": [1, 2, 3]}, {"A": [2, 3, 1]}, False, True, [0, 1, 2]),
+            ({"A": [1, 2, 3]}, {"A": [1, 3, 2]}, True, True, [0, 1, 2]),
+            ({"A": [1, 2, 3]}, {"A": [2, 3, 1]}, False, False, [5, 3, 2]),
+            ({"A": [1, 2, 3]}, {"A": [1, 3, 2]}, True, False, [2, 3, 5]),
+        ],
+    )
+    def test_sort_index_ignore_index(
+        self, original_dict, sorted_dict, ascending, ignore_index, output_index
+    ):
+        # GH 30114
+        original_index = [2, 5, 3]
+        df = DataFrame(original_dict, index=original_index)
+        expected_df = DataFrame(sorted_dict, index=output_index)
+
+        sorted_df = df.sort_index(ascending=ascending, ignore_index=ignore_index)
+        tm.assert_frame_equal(sorted_df, expected_df)
+        tm.assert_frame_equal(df, DataFrame(original_dict, index=original_index))
+
+        # Test when inplace is True
+        copied_df = df.copy()
+        copied_df.sort_index(
+            ascending=ascending, ignore_index=ignore_index, inplace=True
+        )
+        tm.assert_frame_equal(copied_df, expected_df)
+        tm.assert_frame_equal(df, DataFrame(original_dict, index=original_index))
+
+    @pytest.mark.parametrize(
+        "original_dict, sorted_dict, ascending, ignore_index, output_index",
+        [
+            (
+                {"M1": [1, 2], "M2": [3, 4]},
+                {"M1": [1, 2], "M2": [3, 4]},
+                True,
+                True,
+                [0, 1],
+            ),
+            (
+                {"M1": [1, 2], "M2": [3, 4]},
+                {"M1": [2, 1], "M2": [4, 3]},
+                False,
+                True,
+                [0, 1],
+            ),
+            (
+                {"M1": [1, 2], "M2": [3, 4]},
+                {"M1": [1, 2], "M2": [3, 4]},
+                True,
+                False,
+                MultiIndex.from_tuples([[2, 1], [3, 4]], names=list("AB")),
+            ),
+            (
+                {"M1": [1, 2], "M2": [3, 4]},
+                {"M1": [2, 1], "M2": [4, 3]},
+                False,
+                False,
+                MultiIndex.from_tuples([[3, 4], [2, 1]], names=list("AB")),
+            ),
+        ],
+    )
+    def test_sort_index_ignore_index_multi_index(
+        self, original_dict, sorted_dict, ascending, ignore_index, output_index
+    ):
+        # GH 30114, this is to test ignore_index on MulitIndex of index
+        mi = MultiIndex.from_tuples([[2, 1], [3, 4]], names=list("AB"))
+        df = DataFrame(original_dict, index=mi)
+        expected_df = DataFrame(sorted_dict, index=output_index)
+
+        sorted_df = df.sort_index(ascending=ascending, ignore_index=ignore_index)
+        tm.assert_frame_equal(sorted_df, expected_df)
+        tm.assert_frame_equal(df, DataFrame(original_dict, index=mi))
+
+        # Test when inplace is True
+        copied_df = df.copy()
+        copied_df.sort_index(
+            ascending=ascending, ignore_index=ignore_index, inplace=True
+        )
+        tm.assert_frame_equal(copied_df, expected_df)
+        tm.assert_frame_equal(df, DataFrame(original_dict, index=mi))
diff --git a/pandas/tests/series/methods/test_sort_index.py b/pandas/tests/series/methods/test_sort_index.py
index ab15b8c81..a9b73c234 100644
--- a/pandas/tests/series/methods/test_sort_index.py
+++ b/pandas/tests/series/methods/test_sort_index.py
@@ -135,3 +135,34 @@ class TestSeriesSortIndex:
             [3, 2, 1, np.nan], IntervalIndex.from_arrays([3, 2, 1, 0], [4, 3, 2, 1])
         )
         tm.assert_series_equal(result, expected)
+
+    @pytest.mark.parametrize(
+        "original_list, sorted_list, ascending, ignore_index, output_index",
+        [
+            ([2, 3, 6, 1], [2, 3, 6, 1], True, True, [0, 1, 2, 3]),
+            ([2, 3, 6, 1], [2, 3, 6, 1], True, False, [0, 1, 2, 3]),
+            ([2, 3, 6, 1], [1, 6, 3, 2], False, True, [0, 1, 2, 3]),
+            ([2, 3, 6, 1], [1, 6, 3, 2], False, False, [3, 2, 1, 0]),
+        ],
+    )
+    def test_sort_index_ignore_index(
+        self, original_list, sorted_list, ascending, ignore_index, output_index
+    ):
+        # GH 30114
+        ser = Series(original_list)
+        expected = Series(sorted_list, index=output_index)
+
+        # Test when inplace is False
+        sorted_sr = ser.sort_index(ascending=ascending, ignore_index=ignore_index)
+        tm.assert_series_equal(sorted_sr, expected)
+
+        tm.assert_series_equal(ser, Series(original_list))
+
+        # Test when inplace is True
+        copied_sr = ser.copy()
+        copied_sr.sort_index(
+            ascending=ascending, ignore_index=ignore_index, inplace=True
+        )
+        tm.assert_series_equal(copied_sr, expected)
+
+        tm.assert_series_equal(ser, Series(original_list))

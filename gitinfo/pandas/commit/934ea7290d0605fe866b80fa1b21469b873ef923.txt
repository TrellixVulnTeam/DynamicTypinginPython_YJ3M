commit 934ea7290d0605fe866b80fa1b21469b873ef923
Author: Adam Klein <adamklein@gmail.com>
Date:   Wed Feb 29 11:11:12 2012 -0500

    ENH: added toOffset convenience, scetching freq convert method

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 27ace1298..bb668131c 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -3,6 +3,7 @@ from datetime import datetime, timedelta
 import sys
 import numpy as np
 import pandas._tseries as lib
+import re
 
 from pandas._tseries import Timestamp
 
@@ -346,7 +347,7 @@ class BDay(DateOffset, CacheableOffset):
         return (self.n == 1)
 
     def apply(self, other):
-        if isinstance(other, (datetime, Timestamp)):
+        if isinstance(other, datetime):
             n = self.n
 
             if n == 0 and other.weekday() > 4:
@@ -898,7 +899,7 @@ class Tick(DateOffset):
                 + self.delta.microseconds)
 
     def apply(self, other):
-        if isinstance(other, (datetime, timedelta, Timestamp)):
+        if isinstance(other, (datetime, timedelta)):
             return other + self.delta
         elif isinstance(other, type(self)):
             return type(self)(self.n + other.n)
@@ -1150,6 +1151,37 @@ def inferTimeRule(index, _deprecated=True):
 
     raise Exception('Could not infer time rule from data!')
 
+opattern = re.compile(r'(\d*)\s*(\S+)')
+
+def toOffset(name):
+    """
+    Return DateOffset object from string representation
+
+    Example
+    -------
+    getOffset('5Min') -> Minute(5)
+    """
+    groups = opattern.match(name)
+
+    if groups.lastindex != 2:
+        raise ValueError("Could not evaluate %s" % name)
+
+    stride = groups.group(1)
+
+    if len(stride):
+        stride = int(stride)
+    else:
+        stride = 1
+
+    name = groups.group(2)
+
+    offset = _newOffsetMap.get(name)
+
+    if offset is None:
+        raise ValueError('Bad offset request: %s' % name)
+
+    return offset * stride
+
 def getOffset(name, _deprecated=True):
     """
     Return DateOffset object associated with rule name
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 50931df15..d6d775dc8 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -132,6 +132,13 @@ class PandasObject(Picklable):
         return groupby(self, by, axis=axis, level=level, as_index=as_index,
                        sort=sort)
 
+    def convert(self, rule, how='olhc', axis=0, as_index=True):
+        """
+        Convenience method for frequency conversion of timestamped data. Works
+        only with data indexed by a DatetimeIndex.
+        """
+        pass
+
     def select(self, crit, axis=0):
         """
         Return data corresponding to axis labels matching criteria
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 4ed5fb521..523171431 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1322,15 +1322,25 @@ class DatetimeIndex(Int64Index):
         # to do: cache me?
         return self.values.view('i8')
 
+    @property
+    def asstruct(self):
+        if self._sarr_cache is None:
+            self._sarr_cache = lib.build_field_sarray(self.asi8)
+        return self._sarr_cache
+
+    @property
     def asobject(self):
         """
         Unbox to an index of type object
         """
-        return Index(_dt_box_array(self.asi8), dtype='object')
+        if hasattr(self, 'offset') and self.offset is not None:
+            return Index(_dt_box_array(self.asi8, self.offset), dtype='object')
+        else:
+            return Index(_dt_box_array(self.asi8), dtype='object')
 
     def shift(self, n, offset=None):
         """
-        Specialized shift which produces a DateRange
+        Specialized shift which produces a DatetimeIndex
 
         Parameters
         ----------
@@ -1355,7 +1365,7 @@ class DatetimeIndex(Int64Index):
         start = self[0] + n * self.offset
         end = self[-1] + n * self.offset
         return DatetimeIndex(start=start, end=end, offset=self.offset,
-                                name=self.name)
+                             name=self.name)
 
     def union(self, other):
         """
@@ -1525,13 +1535,6 @@ class DatetimeIndex(Int64Index):
         except:
             return super(DatetimeIndex, self).map(func_to_map)
 
-    @property
-    def asstruct(self):
-        if self._sarr_cache is None:
-            self._sarr_cache = lib.build_field_sarray(self.asi8)
-        return self._sarr_cache
-
-
     # Fast field accessors for periods of datetime index
     # --------------------------------------------------------------
 
@@ -1580,10 +1583,7 @@ class DatetimeIndex(Int64Index):
         return lib.fast_field_accessor(self.asi8, 'q')
 
     def __iter__(self):
-        if hasattr(self, 'offset') and self.offset is not None:
-            return iter(_dt_box_array(self.asi8, self.offset))
-        else:
-            return iter(_dt_box_array(self.asi8))
+        return iter(self.asobject)
 
     def searchsorted(self, key, side='left'):
         if isinstance(key, np.ndarray):
diff --git a/pandas/core/series.py b/pandas/core/series.py
index d6b75024c..501d8c6b1 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2068,7 +2068,7 @@ copy : boolean, default False
         if kind == 'line':
             if use_index:
                 if isinstance(self.index, DatetimeIndex):
-                    x = np.asarray(self.index.asobject())
+                    x = np.asarray(self.index.asobject)
                 else:
                     x = np.asarray(self.index)
             else:

commit 46ff5a1007400f9363dbf6ec8575d421789017f6
Author: Chang She <chang@lambdafoundry.com>
Date:   Tue Sep 25 18:42:53 2012 -0400

    BUG: errors when tz is tzlocal

diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 0baf4ca9c..dc733a830 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -43,6 +43,12 @@ def ints_to_pydatetime(ndarray[int64_t] arr, tz=None):
                 pandas_datetime_to_datetimestruct(arr[i], PANDAS_FR_ns, &dts)
                 result[i] = datetime(dts.year, dts.month, dts.day, dts.hour,
                                      dts.min, dts.sec, dts.us, tz)
+        elif _is_tzlocal(tz):
+            for i in range(n):
+                pandas_datetime_to_datetimestruct(arr[i], PANDAS_FR_ns, &dts)
+                dt = datetime(dts.year, dts.month, dts.day, dts.hour,
+                              dts.min, dts.sec, dts.us, tz)
+                result[i] = dt + tz.utcoffset(dt)
         else:
             trans = _get_transitions(tz)
             deltas = _get_deltas(tz)
@@ -64,7 +70,10 @@ def ints_to_pydatetime(ndarray[int64_t] arr, tz=None):
 
     return result
 
+from dateutil.tz import tzlocal
 
+def _is_tzlocal(tz):
+    return isinstance(tz, tzlocal)
 
 # Python front end to C extension type _Timestamp
 # This serves as the box for datetime64
@@ -600,6 +609,14 @@ cpdef convert_to_tsobject(object ts, object tz=None):
     if tz is not None:
         if _is_utc(tz):
             obj.tzinfo = tz
+        elif _is_tzlocal(tz):
+            pandas_datetime_to_datetimestruct(obj.value, PANDAS_FR_ns, &obj.dts)
+            dt = datetime(obj.dts.year, obj.dts.month, obj.dts.day, obj.dts.hour,
+                          obj.dts.min, obj.dts.sec, obj.dts.us, tz)
+            delta = int(total_seconds(_get_utcoffset(tz, dt))) * 1000000000
+            pandas_datetime_to_datetimestruct(obj.value + delta,
+                                              PANDAS_FR_ns, &obj.dts)
+            obj.tzinfo = tz
         else:
             # Adjust datetime64 timestamp, recompute datetimestruct
             trans = _get_transitions(tz)
@@ -912,6 +929,7 @@ def tz_convert(ndarray[int64_t] vals, object tz1, object tz2):
         ndarray[int64_t] utc_dates, result, trans, deltas
         Py_ssize_t i, pos, n = len(vals)
         int64_t v, offset
+        pandas_datetimestruct dts
 
     if not have_pytz:
         import pytz
@@ -920,28 +938,46 @@ def tz_convert(ndarray[int64_t] vals, object tz1, object tz2):
 
     if _get_zone(tz1) != 'UTC':
         utc_dates = np.empty(n, dtype=np.int64)
-        deltas = _get_deltas(tz1)
-        trans = _get_transitions(tz1)
-        pos = trans.searchsorted(vals[0]) - 1
-        if pos < 0:
-            raise ValueError('First time before start of DST info')
+        if _is_tzlocal(tz1):
+            for i in range(n):
+                v = vals[i]
+                pandas_datetime_to_datetimestruct(v, PANDAS_FR_ns, &dts)
+                dt = datetime(dts.year, dts.month, dts.day, dts.hour,
+                              dts.min, dts.sec, dts.us, tz1)
+                delta = int(total_seconds(_get_utcoffset(tz1, dt))) * 1000000000
+                utc_dates[i] = v - delta
+        else:
+            deltas = _get_deltas(tz1)
+            trans = _get_transitions(tz1)
+            pos = trans.searchsorted(vals[0]) - 1
+            if pos < 0:
+                raise ValueError('First time before start of DST info')
 
-        offset = deltas[pos]
-        for i in range(n):
-            v = vals[i]
-            if v >= trans[pos + 1]:
-                pos += 1
-                offset = deltas[pos]
-            utc_dates[i] = v - offset
+            offset = deltas[pos]
+            for i in range(n):
+                v = vals[i]
+                if v >= [pos + 1]:
+                    pos += 1
+                    offset = deltas[pos]
+                utc_dates[i] = v - offset
     else:
         utc_dates = vals
 
     if _get_zone(tz2) == 'UTC':
         return utc_dates
 
-    # Convert UTC to other timezone
-
     result = np.empty(n, dtype=np.int64)
+    if _is_tzlocal(tz2):
+        for i in range(n):
+            v = utc_dates[i]
+            pandas_datetime_to_datetimestruct(v, PANDAS_FR_ns, &dts)
+            dt = datetime(dts.year, dts.month, dts.day, dts.hour,
+                          dts.min, dts.sec, dts.us, tz2)
+            delta = int(total_seconds(_get_utcoffset(tz2, dt))) * 1000000000
+            result[i] = v + delta
+            return result
+
+    # Convert UTC to other timezone
     trans = _get_transitions(tz2)
     deltas = _get_deltas(tz2)
     pos = trans.searchsorted(utc_dates[0])
@@ -968,14 +1004,19 @@ def tz_convert_single(int64_t val, object tz1, object tz2):
         ndarray[int64_t] trans, deltas
         Py_ssize_t pos
         int64_t v, offset, utc_date
-
+        pandas_datetimestruct dts
 
     if not have_pytz:
         import pytz
 
     # Convert to UTC
-
-    if _get_zone(tz1) != 'UTC':
+    if _is_tzlocal(tz1):
+        pandas_datetime_to_datetimestruct(val, PANDAS_FR_ns, &dts)
+        dt = datetime(dts.year, dts.month, dts.day, dts.hour,
+                      dts.min, dts.sec, dts.us, tz1)
+        delta = int(total_seconds(_get_utcoffset(tz1, dt))) * 1000000000
+        utc_date = val - delta
+    elif _get_zone(tz1) != 'UTC':
         deltas = _get_deltas(tz1)
         trans = _get_transitions(tz1)
         pos = trans.searchsorted(val) - 1
@@ -988,7 +1029,12 @@ def tz_convert_single(int64_t val, object tz1, object tz2):
 
     if _get_zone(tz2) == 'UTC':
         return utc_date
-
+    if _is_tzlocal(tz2):
+        pandas_datetime_to_datetimestruct(val, PANDAS_FR_ns, &dts)
+        dt = datetime(dts.year, dts.month, dts.day, dts.hour,
+                      dts.min, dts.sec, dts.us, tz2)
+        delta = int(total_seconds(_get_utcoffset(tz2, dt))) * 1000000000
+        return utc_date + delta
     # Convert UTC to other timezone
     trans = _get_transitions(tz2)
     deltas = _get_deltas(tz2)
@@ -1045,6 +1091,7 @@ def _get_deltas(tz):
             # static tzinfo
             num = int(total_seconds(_get_utcoffset(tz, None))) * 1000000000
             utc_offset_cache[tz] = np.array([num], dtype=np.int64)
+
     return utc_offset_cache[tz]
 
 cdef double total_seconds(object td): # Python 2.6 compat
@@ -1068,47 +1115,6 @@ cpdef ndarray _unbox_utcoffsets(object transinfo):
     return arr
 
 
-def tz_localize_check(ndarray[int64_t] vals, object tz):
-    """
-    Localize tzinfo-naive DateRange to given time zone (using pytz). If
-    there are ambiguities in the values, raise AmbiguousTimeError.
-
-    Returns
-    -------
-    localized : DatetimeIndex
-    """
-    cdef:
-        ndarray[int64_t] trans, deltas
-        Py_ssize_t i, pos, n = len(vals)
-        int64_t v, dst_start, dst_end
-
-    if not have_pytz:
-        raise Exception("Could not find pytz module")
-
-    if tz == UTC or tz is None:
-        return
-
-    trans = _get_transitions(tz)
-    deltas = _get_deltas(tz)
-
-    pos = np.searchsorted(trans, vals[0])
-    dst_start = trans[pos] + deltas[pos - 1]
-    dst_end = trans[pos] + deltas[pos]
-
-    for i in range(n):
-        v = vals[i]
-        if v >= trans[pos + 1]:
-            pos += 1
-            dst_start = trans[pos] + deltas[pos - 1]
-            dst_end = trans[pos] + deltas[pos]
-
-        if dst_start > dst_end:
-            dst_end, dst_start = dst_start, dst_end
-
-        if dst_start <= v and v <= dst_end:
-            msg = "Cannot localize, ambiguous time %s found" % Timestamp(v)
-            raise pytz.AmbiguousTimeError(msg)
-
 @cython.boundscheck(False)
 @cython.wraparound(False)
 def tz_localize_to_utc(ndarray[int64_t] vals, object tz):
@@ -1126,6 +1132,7 @@ def tz_localize_to_utc(ndarray[int64_t] vals, object tz):
         int64_t *tdata
         int64_t v, left, right
         ndarray[int64_t] result, result_a, result_b
+        pandas_datetimestruct dts
 
     # Vectorized version of DstTzInfo.localize
 
@@ -1135,13 +1142,24 @@ def tz_localize_to_utc(ndarray[int64_t] vals, object tz):
     if tz == UTC or tz is None:
         return vals
 
+    result = np.empty(n, dtype=np.int64)
+
+    if _is_tzlocal(tz):
+        for i in range(n):
+            v = vals[i]
+            pandas_datetime_to_datetimestruct(v, PANDAS_FR_ns, &dts)
+            dt = datetime(dts.year, dts.month, dts.day, dts.hour,
+                          dts.min, dts.sec, dts.us, tz)
+            delta = int(total_seconds(_get_utcoffset(tz, dt))) * 1000000000
+            result[i] = v - delta
+        return result
+
     trans = _get_transitions(tz)  # transition dates
     deltas = _get_deltas(tz)      # utc offsets
 
     tdata = <int64_t*> trans.data
     ntrans = len(trans)
 
-    result = np.empty(n, dtype=np.int64)
     result_a = np.empty(n, dtype=np.int64)
     result_b = np.empty(n, dtype=np.int64)
     result_a.fill(NPY_NAT)
diff --git a/pandas/tseries/tests/test_timezones.py b/pandas/tseries/tests/test_timezones.py
index 971023af1..d80c19fba 100644
--- a/pandas/tseries/tests/test_timezones.py
+++ b/pandas/tseries/tests/test_timezones.py
@@ -432,6 +432,9 @@ class TestTimeZoneSupport(unittest.TestCase):
         result = to_datetime(arr, utc=True)
         self.assert_(result.tz is pytz.utc)
 
+        rng = date_range('2012-11-03 03:00', '2012-11-05 03:00', tz=tzlocal())
+        rs1 = rng.to_pydatetime()
+
     def test_frame_no_datetime64_dtype(self):
         dr = date_range('2011/1/1', '2012/1/1', freq='W-FRI')
         dr_tz = dr.tz_localize('US/Eastern')

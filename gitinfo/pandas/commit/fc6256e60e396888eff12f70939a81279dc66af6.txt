commit fc6256e60e396888eff12f70939a81279dc66af6
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Mar 23 17:13:12 2010 +0000

    more test coverage
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@143 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 1acd63f17..3520a023e 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -267,13 +267,12 @@ class MonthEnd(DateOffset):
 
     def apply(self, other):
         n = self.n
-        __junk, nDaysInMonth = calendar.monthrange(other.year, other.month)
+        _, nDaysInMonth = calendar.monthrange(other.year, other.month)
         if other.day != nDaysInMonth:
             other = other + relativedelta(months=-1, day=31)
             if n <= 0:
                 n = n + 1
         other = other + relativedelta(months=n, day=31)
-        #other = datetime(other.year, other.month, nDaysInMonth)
         return other
 
     @classmethod
@@ -441,7 +440,7 @@ class YearEnd(DateOffset):
             other = datetime(other.year - 1, 12, 31)
             if n <= 0:
                 n = n + 1
-        other = other + relativedelta(years = n)
+        other = other + relativedelta(years=n)
         return other
 
     @classmethod
@@ -561,8 +560,8 @@ _offsetMap = {
 _offsetNames = dict([(v, k) for k, v in _offsetMap.iteritems()])
 
 def inferTimeRule(index):
-    if len(index) <= 1:
-        raise Exception('Need at least two dates to infer time rule!')
+    if len(index) < 3:
+        raise Exception('Need at least three dates to infer time rule!')
 
     first, second, third = index[:3]
     for rule, offset in _offsetMap.iteritems():
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index aa0889e21..3fd9465fd 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1346,8 +1346,6 @@ class DataFrame(Picklable, Groupable):
             raise Exception('Columns overlap: %s' % sorted(overlap))
 
         if len(other.index) == 0:
-            print other.cols()
-
             result = self.copy()
 
             for col in other:
@@ -1457,19 +1455,19 @@ class DataFrame(Picklable, Groupable):
         c1: 4
         c2: 6
         """
-        y = np.array(self.values, subok=True)
-
-        axis_labels = self._get_agg_axis(axis)
         try:
+            y = self.values.copy()
             mask = np.isfinite(y)
             if not issubclass(y.dtype.type, np.int_):
                 y[-mask] = 0
             theSum = y.sum(axis)
             theCount = mask.sum(axis)
             theSum[theCount == 0] = NaN
+
         except Exception:
             theSum = self.apply(np.sum, axis=axis)
 
+        axis_labels = self._get_agg_axis(axis)
         return Series(theSum, index=axis_labels)
 
     def cumsum(self, axis=0):
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 5aee5e11f..46c0572e9 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -49,6 +49,22 @@ class GroupDict(dict):
 
         return output.getvalue()
 
+def groupby(obj, grouper):
+    """
+    Intercepts creation and dispatches to the appropriate class based
+    on type.
+    """
+    if isinstance(obj, Series):
+        klass = SeriesGroupBy
+    elif isinstance(obj, DataMatrix):
+        klass = DataMatrixGroupBy
+    elif isinstance(obj, DataFrame):
+        klass = DataFrameGroupBy
+    else:
+        raise TypeError('invalid type: %s' % type(obj))
+
+    return klass(obj, grouper)
+
 class GroupBy(object):
     """
     Class for grouping and aggregating relational data.
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index c9329fcea..7d95917a2 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -45,7 +45,7 @@ class DataMatrix(DataFrame):
     def __init__(self, data=None, index=None, columns=None, dtype=None,
                  objects=None):
 
-        if isinstance(data, dict):
+        if isinstance(data, dict) and len(data) > 0:
             (index, columns,
              values, objects) = self._initDict(data, index, columns, objects,
                                                dtype)
@@ -55,12 +55,12 @@ class DataMatrix(DataFrame):
 
             if objects is not None:
                 if isinstance(objects, DataMatrix):
-                    if objects.index is not index:
+                    if not objects.index.equals(index):
                         objects = objects.reindex(index)
                 else:
                     objects = DataMatrix(objects, index=index)
 
-        elif data is None:
+        elif data is None or len(data) == 0:
             # this is a touch convoluted...
             if objects is not None:
                 if isinstance(objects, DataMatrix):
@@ -101,23 +101,6 @@ class DataMatrix(DataFrame):
 
         Somehow this got outrageously complicated
         """
-        if len(data) == 0:
-            if objects is not None:
-                if isinstance(objects, DataMatrix):
-                    if index is not None and objects.index is not index:
-                        objects = objects.reindex(index)
-                else:
-                    objects = DataMatrix(objects, index=index)
-
-                index = objects.index
-
-            if index is None:
-                index = NULL_INDEX
-
-            values = np.empty((len(index), 0), dtype=dtype)
-            columns = NULL_INDEX
-            return index, columns, values, objects
-
         # pre-filter out columns if we passed it
         if columns is not None:
             colset = set(columns)
@@ -202,7 +185,7 @@ class DataMatrix(DataFrame):
 
         if dtype is not None:
             try:
-                data = data.astype(dtype)
+                values = values.astype(dtype)
             except Exception:
                 pass
 
@@ -315,7 +298,7 @@ class DataMatrix(DataFrame):
             print 'CSV file written successfully: %s' % path
 
     def toString(self, buffer=sys.stdout, verbose=False,
-                 columns=None, colSpace=10, nanRep='NaN',
+                 columns=None, colSpace=15, nanRep='NaN',
                  formatters=None, float_format=None):
         """
         Output a string version of this DataMatrix
@@ -339,7 +322,7 @@ class DataMatrix(DataFrame):
 
         if len(self.cols()) == 0:
             buffer.write('DataMatrix is empty!\n')
-            buffer.write(self.index.__repr__())
+            buffer.write(repr(self.index))
         else:
             buffer.write(_pfixed('', idxSpace))
             for h in columns:
@@ -671,15 +654,6 @@ class DataMatrix(DataFrame):
         return series
     _series = property(_getSeriesDict)
 
-    def _firstTimeWithNValues(self):
-        # Need to test this!
-        N = len(self._series)
-        selector = (self.count(1) == N)
-        if not selector.any():
-            raise Exception('No time has %d values!' % N)
-
-        return self.index[selector][0]
-
     def _combineFrame(self, other, func):
         """
         Methodology, briefly
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 38e21c01d..d4902db22 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -1879,6 +1879,9 @@ def pivot(index, columns, values):
     if not (len(index) == len(columns) == len(values)):
         raise Exception('Pivot inputs must all be same length!')
 
+    if len(index) == 0:
+        return DataMatrix(index=[])
+
     major_axis = Index(sorted(set(index)))
     minor_axis = Index(sorted(set(columns)))
 
diff --git a/pandas/core/tests/test_datetools.py b/pandas/core/tests/test_datetools.py
index 157a52f35..71151224b 100644
--- a/pandas/core/tests/test_datetools.py
+++ b/pandas/core/tests/test_datetools.py
@@ -3,11 +3,12 @@ import unittest
 
 from pandas.core.datetools import (
     bday, BDay, BQuarterEnd, BMonthEnd, BYearEnd, MonthEnd,
-    DateOffset, Week)
+    DateOffset, Week, YearBegin, YearEnd, Hour, Minute, Second)
 
 from pandas.core.daterange import XDateRange, DateRange
 import pandas.core.datetools as datetools
 
+from nose.tools import assert_raises
 
 ####
 ## Misc function tests
@@ -20,12 +21,7 @@ def test_ole2datetime():
     actual = datetools.ole2datetime(60000)
     assert actual == datetime(2064, 4, 8)
 
-    try:
-        datetools.ole2datetime(60)
-    except Exception:
-        pass
-    else:
-        raise Exception('should have raised an exception')
+    assert_raises(Exception, datetools.ole2datetime, 60)
 
 def test_to_datetime1():
     actual = datetools.to_datetime(datetime(2008, 1, 15))
@@ -340,6 +336,54 @@ class TestBMonthEnd(unittest.TestCase):
         for offset, date, expected in tests:
             assertOnOffset(offset, date, expected)
 
+class TestMonthEnd(unittest.TestCase):
+
+    def test_offset(self):
+        tests = []
+
+        tests.append((MonthEnd(),
+                     {datetime(2008, 1, 1): datetime(2008, 1, 31),
+                      datetime(2008, 1, 31): datetime(2008, 2, 29),
+                      datetime(2006, 12, 29): datetime(2006, 12, 31),
+                      datetime(2006, 12, 31): datetime(2007, 1, 31),
+                      datetime(2007, 1, 1): datetime(2007, 1, 31),
+                      datetime(2006, 12, 1): datetime(2006, 12, 31)}))
+
+        tests.append((MonthEnd(0),
+                      {datetime(2008, 1, 1): datetime(2008, 1, 31),
+                       datetime(2008, 1, 31): datetime(2008, 1, 31),
+                       datetime(2006, 12, 29): datetime(2006, 12, 31),
+                       datetime(2006, 12, 31): datetime(2006, 12, 31),
+                       datetime(2007, 1, 1): datetime(2007, 1, 31)}))
+
+        tests.append((MonthEnd(2),
+                     {datetime(2008, 1, 1): datetime(2008, 2, 29),
+                      datetime(2008, 1, 31): datetime(2008, 3, 31),
+                      datetime(2006, 12, 29): datetime(2007, 1, 31),
+                      datetime(2006, 12, 31): datetime(2007, 2, 28),
+                      datetime(2007, 1, 1): datetime(2007, 2, 28),
+                      datetime(2006, 11, 1): datetime(2006, 12, 31)}))
+
+        tests.append((MonthEnd(-1),
+                     {datetime(2007, 1, 1): datetime(2006, 12, 31),
+                      datetime(2008, 6, 30): datetime(2008, 5, 31),
+                      datetime(2008, 12, 31): datetime(2008, 11, 30),
+                      datetime(2006, 12, 29): datetime(2006, 11, 30),
+                      datetime(2006, 12, 30): datetime(2006, 11, 30),
+                      datetime(2007, 1, 1): datetime(2006, 12, 31)}))
+
+        for dateOffset, cases in tests:
+            for baseDate, expected in cases.iteritems():
+                assertEq(dateOffset, baseDate, expected)
+
+    def test_onOffset(self):
+
+        tests = [(MonthEnd(), datetime(2007, 12, 31), True),
+                 (MonthEnd(), datetime(2008, 1, 1), False)]
+
+        for offset, date, expected in tests:
+            assertOnOffset(offset, date, expected)
+
 class TestBQuarterEnd(unittest.TestCase):
     def test_offset(self):
         tests = []
@@ -473,6 +517,17 @@ class TestYearBegin(unittest.TestCase):
                 assertEq(dateOffset, baseDate, expected)
 
 
+    def test_onOffset(self):
+
+        tests = [
+            (YearBegin(), datetime(2007, 1, 3), False),
+            (YearBegin(), datetime(2008, 1, 1), True),
+            (YearBegin(), datetime(2006, 12, 31), False),
+            (YearBegin(), datetime(2006, 1, 2), False),
+        ]
+
+        for offset, date, expected in tests:
+            assertOnOffset(offset, date, expected)
 
 class TestBYearEnd(unittest.TestCase):
 
@@ -522,12 +577,48 @@ class TestBYearEnd(unittest.TestCase):
             assertOnOffset(offset, date, expected)
 
 
-class TestMonthEnd(unittest.TestCase):
+class TestYearEnd(unittest.TestCase):
+
+    def test_offset(self):
+        tests = []
+
+        tests.append((YearEnd(),
+                      {datetime(2008, 1, 1): datetime(2008, 12, 31),
+                       datetime(2008, 6, 30): datetime(2008, 12, 31),
+                       datetime(2008, 12, 31): datetime(2009, 12, 31),
+                       datetime(2005, 12, 30): datetime(2005, 12, 31),
+                       datetime(2005, 12, 31): datetime(2006, 12, 31),}))
+
+        tests.append((YearEnd(0),
+                      {datetime(2008, 1, 1): datetime(2008, 12, 31),
+                       datetime(2008, 6, 30): datetime(2008, 12, 31),
+                       datetime(2008, 12, 31): datetime(2008, 12, 31),
+                       datetime(2005, 12, 30): datetime(2005, 12, 31),}))
+
+        tests.append((YearEnd(-1),
+                      {datetime(2007, 1, 1): datetime(2006, 12, 31),
+                       datetime(2008, 6, 30): datetime(2007, 12, 31),
+                       datetime(2008, 12, 31): datetime(2007, 12, 31),
+                       datetime(2006, 12, 29): datetime(2005, 12, 31),
+                       datetime(2006, 12, 30): datetime(2005, 12, 31),
+                       datetime(2007, 1, 1): datetime(2006, 12, 31),}))
+
+        tests.append((YearEnd(-2),
+                      {datetime(2007, 1, 1): datetime(2005, 12, 31),
+                       datetime(2008, 6, 30): datetime(2006, 12, 31),
+                       datetime(2008, 12, 31): datetime(2006, 12, 31),}))
+
+        for dateOffset, cases in tests:
+            for baseDate, expected in cases.iteritems():
+                assertEq(dateOffset, baseDate, expected)
+
     def test_onOffset(self):
 
         tests = [
-            (MonthEnd(), datetime(2007, 3, 30), False),
-            (MonthEnd(), datetime(2007, 3, 31), True),
+            (YearEnd(), datetime(2007, 12, 31), True),
+            (YearEnd(), datetime(2008, 1, 1), False),
+            (YearEnd(), datetime(2006, 12, 31), True),
+            (YearEnd(), datetime(2006, 12, 29), False),
         ]
 
         for offset, date, expected in tests:
@@ -573,14 +664,45 @@ def assertEq(dateOffset, baseDate, expected):
     actual = dateOffset + baseDate
     assert actual == expected
 
+def test_Hour():
+    assertEq(Hour(), datetime(2010, 1, 1), datetime(2010, 1, 1, 1))
+    assertEq(Hour(-1), datetime(2010, 1, 1, 1), datetime(2010, 1, 1))
+    assertEq(2 * Hour(), datetime(2010, 1, 1), datetime(2010, 1, 1, 2))
+    assertEq(-1 * Hour(), datetime(2010, 1, 1, 1), datetime(2010, 1, 1))
+
+def test_Minute():
+    assertEq(Minute(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 1))
+    assertEq(Minute(-1), datetime(2010, 1, 1, 0, 1), datetime(2010, 1, 1))
+    assertEq(2 * Minute(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 2))
+    assertEq(-1 * Minute(), datetime(2010, 1, 1, 0, 1), datetime(2010, 1, 1))
+
+def test_Second():
+    assertEq(Second(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 0, 1))
+    assertEq(Second(-1), datetime(2010, 1, 1, 0, 0, 1), datetime(2010, 1, 1))
+    assertEq(2 * Second(), datetime(2010, 1, 1), datetime(2010, 1, 1, 0, 0, 2))
+    assertEq(-1 * Second(), datetime(2010, 1, 1, 0, 0, 1), datetime(2010, 1, 1))
+
+def test_inferTimeRule():
+    index1 = [datetime(2010, 1, 29, 0, 0),
+              datetime(2010, 2, 26, 0, 0),
+              datetime(2010, 3, 31, 0, 0)]
+
+    index2 = [datetime(2010, 3, 26, 0, 0),
+              datetime(2010, 3, 29, 0, 0),
+              datetime(2010, 3, 30, 0, 0)]
+
+    index3 = [datetime(2010, 3, 26, 0, 0),
+              datetime(2010, 3, 27, 0, 0),
+              datetime(2010, 3, 29, 0, 0)]
+
+    assert datetools.inferTimeRule(index1) == 'EOM'
+    assert datetools.inferTimeRule(index2) == 'WEEKDAY'
+
+    assert_raises(Exception, datetools.inferTimeRule, index1[:2])
+    assert_raises(Exception, datetools.inferTimeRule, index3)
 
 def test_getOffsetName():
-    try:
-        datetools.getOffsetName(BDay(2))
-    except Exception:
-        pass
-    else:
-        raise Exception('failure')
+    assert_raises(Exception, datetools.getOffsetName, BDay(2))
 
     assert datetools.getOffsetName(BDay()) == 'WEEKDAY'
     assert datetools.getOffsetName(BMonthEnd()) == 'EOM'
@@ -591,6 +713,17 @@ def test_getOffsetName():
     assert datetools.getOffsetName(Week(dayOfWeek=4)) == 'W@FRI'
 
 
+def test_getOffset():
+    assert_raises(Exception, datetools.getOffset, 'gibberish')
+
+    assert datetools.getOffset('WEEKDAY') == BDay()
+    assert datetools.getOffset('EOM') == BMonthEnd()
+    assert datetools.getOffset('W@MON') == Week(dayOfWeek=0)
+    assert datetools.getOffset('W@TUE') == Week(dayOfWeek=1)
+    assert datetools.getOffset('W@WED') == Week(dayOfWeek=2)
+    assert datetools.getOffset('W@THU') == Week(dayOfWeek=3)
+    assert datetools.getOffset('W@FRI') == Week(dayOfWeek=4)
+
 ####
 ## XDateRange Tests
 ####
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index dbde3ebbb..bf79d389b 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -131,6 +131,11 @@ class TestDataFrame(unittest.TestCase):
         self.assertEqual(len(frame.index), 2)
         self.assertEqual(len(frame.cols()), 3)
 
+        # cast type
+        frame = self.klass(mat, columns=['A', 'B', 'C'],
+                           index=[1, 2], dtype=int)
+        self.assert_(frame.values.dtype == np.int_)
+
         # 1-D input
         frame = self.klass(np.zeros(3), columns=['A'], index=[1, 2, 3])
         self.assertEqual(len(frame.index), 3)
@@ -251,6 +256,8 @@ class TestDataFrame(unittest.TestCase):
         biggie.toString(buffer=buf, columns=['B', 'A'],
                         float_format=str)
 
+        frame = self.klass(index=np.arange(1000))
+        frame.toString(buffer=buf)
 
     def test_getitem(self):
         # slicing
@@ -308,6 +315,11 @@ class TestDataFrame(unittest.TestCase):
         self.frame['col8'] = 'foo'
         assert((self.frame['col8'] == 'foo').all())
 
+        smaller = self.frame[:2]
+        smaller['col10'] = ['1', '2']
+        self.assertEqual(smaller['col10'].dtype, np.object_)
+        self.assert_((smaller['col10'] == ['1', '2']).all())
+
     def test_delitem(self):
         del self.frame['A']
         self.assert_('A' not in self.frame)
diff --git a/pandas/core/tests/test_matrix.py b/pandas/core/tests/test_matrix.py
index 9fcab4939..ae9896db6 100644
--- a/pandas/core/tests/test_matrix.py
+++ b/pandas/core/tests/test_matrix.py
@@ -72,6 +72,28 @@ class TestDataMatrix(test_frame.TestDataFrame):
         self.assert_(isinstance(dm.objects, DataMatrix))
         self.assert_(dm.index is dm.objects.index)
 
+        index = self.mixed_frame.index
+        dm = DataMatrix(data=self.frame._series,
+                        objects=self.mixed_frame.objects._series)
+        self.assert_(isinstance(dm.objects, DataMatrix))
+        self.assert_(dm.objects.columns.equals(
+                self.mixed_frame.objects.columns))
+
+    def test_constructor_objects_corner(self):
+        obj = {'A' : {1 : '1', 2 : '2'}}
+        obj_dm = DataMatrix(obj)
+        mat = np.zeros((3, 3), dtype=float)
+
+        dm = DataMatrix(mat, index=[1, 2, 3], columns=['B', 'C', 'D'],
+                        objects=obj_dm)
+        assert dm.index is not obj_dm.index
+
+        dm = DataMatrix(mat, index=[1, 2, 3], columns=['B', 'C', 'D'],
+                        objects=obj)
+
+        dm = DataMatrix(index=[1, 2, 3], objects=obj_dm)
+        dm = DataMatrix(index=[1, 2, 3], objects=obj)
+
     def test_copy(self):
         # copy objects
         copy = self.mixed_frame.copy()
@@ -120,6 +142,17 @@ class TestDataMatrix(test_frame.TestDataFrame):
     def test_more_fromDict(self):
         pass
 
+    def test_more_asMatrix(self):
+        values = self.mixed_frame.asMatrix()
+        self.assertEqual(values.shape[1], len(self.mixed_frame.cols()))
+
+    def test_reindex_objects(self):
+        reindexed = self.mixed_frame.reindex(columns=['foo', 'A', 'B'])
+        self.assert_('foo' in reindexed)
+
+        reindexed = self.mixed_frame.reindex(columns=['A', 'B'])
+        self.assert_('foo' not in reindexed)
+
     def test_fill_corner(self):
         self.mixed_frame['foo'][5:20] = np.NaN
         self.mixed_frame['A'][-10:] = np.NaN
diff --git a/pandas/stats/plm.py b/pandas/stats/plm.py
index 23e397b9e..cc3e3664b 100644
--- a/pandas/stats/plm.py
+++ b/pandas/stats/plm.py
@@ -23,38 +23,45 @@ class PanelOLS(OLS):
 
     Parameters
     ----------
-    y: DataFrame
-    x: Dict of DataFrame or WidePanel
-    intercept: bool
+    y : DataFrame
+    x : Dict of DataFrame or WidePanel
+    intercept : bool
         True if you want an intercept.  True by default.
-    nw_lags: None or int
+    nw_lags : None or int
         Number of Newey-West lags.  None by default.
-    nw_overlap: bool
+    nw_overlap : bool
         Whether there are overlaps in the NW lags.  Defaults to False.
-    window_type: int
+    window_type : int
         FULL_SAMPLE, ROLLING, EXPANDING.  FULL_SAMPLE by default.
-    window: int
+    window : int
         size of window (for rolling/expanding OLS)
-    weights: DataFrame
+    weights : DataFrame
         Weight for each observation.  The weights are not normalized;
         they're multiplied directly by each observation.
-    pool: bool, default True
+    pool : bool, default True
         Whether to run pooled panel regression
-    entity_effects: bool, deafult False
+    entity_effects : bool, deafult False
         Whether to account for entity fixed effects
-    time_effects: bool, default False
+    time_effects : bool, default False
         Whether to account for time fixed effects
-    x_effects: list, default None
+    x_effects : list, default None
         List of x's to account for fixed effects
-    dropped_dummies: dict
+    dropped_dummies : dict
         Key is the name of the variable for the fixed effect.
         Value is the value of that variable for which we drop the dummy.
 
         For entity fixed effects, key equals 'entity', e.g. {'entity' : 'US'}
 
         By default, the first item is dropped if one is not specified.
-    cluster: int
+    cluster : int
         ENTITY or TIME, indicating entity/time clustering
+        A cluster is a grouping within which observations are correlated.
+
+        For example, if you have a panel data with countries over time and you suspect that:
+
+        1. Countries are correlated - use 'time'
+        2. There is autocorrelation - use 'entity' 
+        
     """
     def __init__(self, y, x, weights=None,
                  intercept=True, nw_lags=None, entity_effects=False,
@@ -584,6 +591,12 @@ class MovingPanelOLS(MovingOLS, PanelOLS):
         By default, the first dummy is dropped if no dummy is specified.
     cluster : int
         ENTITY or TIME, indicating entity/time clustering
+        A cluster is a grouping within which observations are correlated.
+
+        For example, if you have a panel data with countries over time and you suspect that:
+
+        1. Countries are correlated - use 'time'
+        2. There is autocorrelation - use 'entity' 
     """
     def __init__(self, y, x, weights=None,
                  window_type='expanding', window=None,

commit d66d1cb8ce8de16511b66b469118bc0da3e5db57
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Feb 18 21:19:19 2011 -0500

    whoohoo! 100% line coverage for pandas.core

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 5c30083c8..a4918b6e2 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1055,7 +1055,7 @@ class DataFrame(Picklable, Groupable):
         warnings.warn("fill is being replaced by fillna, and the fill function "
                       "behavior will disappear in the next release: please "
                       "modify your code accordingly",
-                      DeprecationWarning)
+                      FutureWarning)
         return self.fillna(value=value, method=method)
 
     def fillna(self, value=None, method='pad'):
@@ -1186,7 +1186,7 @@ class DataFrame(Picklable, Groupable):
         # TODO: remove this on next release
         if fillMethod is not None: # pragma: no cover
             warnings.warn("'fillMethod' is deprecated. Use 'method' instead",
-                          DeprecationWarning)
+                          FutureWarning)
 
             method = fillMethod
 
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 36be59e7f..b35bfa58a 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -476,7 +476,7 @@ class WidePanel(Panel):
         warnings.warn("fill is being replaced by fillna, and the fill function "
                       "behavior will disappear in the next release: please "
                       "modify your code accordingly",
-                      DeprecationWarning)
+                      FutureWarning)
         return self.fillna(value=value, method=method)
 
     def fillna(self, value=None, method='pad'):
@@ -1153,8 +1153,6 @@ class LongPanel(Panel):
             mat.fill(value)
         elif isinstance(value, np.ndarray):
             mat = value
-#             if value.ndim == 1:
-#                 value = value.reshape((len(value), 1))
         elif isinstance(value, LongPanel):
             if len(value.items) > 1:
                 raise Exception('input LongPanel must only have one column')
@@ -1338,9 +1336,6 @@ class LongPanel(Panel):
             row = format_row(major[major_i], minor[minor_i], self.values[i])
             print >> buffer, row
 
-    def _fill_factors(self):
-        values = self.values.astype(object)
-
     def swapaxes(self):
         """
         Swap major and minor axes and reorder values to be grouped by
@@ -1437,7 +1432,7 @@ class LongPanel(Panel):
             dim = len(self.major_axis)
             items = self.major_axis
             labels = self.index.major_labels
-        else:
+        else: # pragma: no cover
             raise Exception('Do not recognize axis %s' % axis)
 
         if transform:
@@ -1539,11 +1534,27 @@ class LongPanel(Panel):
 
         return panel
 
-    def count(self, axis=0):
-        if axis == 0:
+    def count(self, axis='major'):
+        """
+        Compute observation counts within each group
+
+        Parameters
+        ----------
+        axis : {'major', 'minor'}
+            major: compute minor_axis obs for each major axis value
+            minor: same but for each minor axis value
+
+        Returns
+        -------
+        counts : ndarray (1d)
+            Length will be length of input axis
+        """
+        if axis == 'major':
             lp = self
-        else:
+        elif axis == 'minor':
             lp = self.swapaxes()
+        else: # pragma: no cover
+            raise Exception('invalid axis')
 
         N = len(lp.values)
         bounds = lp.index._bounds
@@ -1564,7 +1575,7 @@ class LongPanel(Panel):
 
         return LongPanel(values, items, self.index)
 
-    def addPrefix(self, prefix):
+    def addPrefix(self, prefix=None):
         """
         Concatenate prefix string with panel items names.
 
@@ -1762,7 +1773,7 @@ class LongPanelIndex(object):
 
 class Factor(object):
     """
-    Represents a categorical variable in classic R / S+ fashion
+    Represents a categorical variable in classic R / S-plus fashion
     """
     def __init__(self, labels, levels):
         self.labels = labels
@@ -1775,17 +1786,19 @@ class Factor(object):
 
         return Factor(labels, levels=levels)
 
+    def asarray(self):
+        return self.levels[self.labels]
+
+    def __len__(self):
+        return len(self.labels)
+
     def __repr__(self):
         temp = 'Factor:\n%s\nLevels (%d): %s'
-
-        values = self.levels[self.labels]
+        values = self.asarray()
         return temp % (repr(values), len(self.levels), self.levels)
 
     def __getitem__(self, key):
-        if key is None and key not in self.index:
-            raise Exception('None/Null object requested of Series!')
-
-        if isinstance(key, int):
+        if isinstance(key, (int, np.integer)):
             i = self.labels[key]
             return self.levels[i]
         else:
@@ -1794,6 +1807,8 @@ class Factor(object):
 
 def factor_agg(factor, vec, func):
     """
+    Aggregate array based on Factor
+
     Parameters
     ----------
     factor : Factor
@@ -1855,11 +1870,7 @@ def _prefix_item(item, prefix=None):
     if prefix is None:
         return item
 
-    if isinstance(item, float):
-        template = '%g%s'
-    else:
-        template = '%s%s'
-
+    template = '%s%s'
     return template % (prefix, item)
 
 def _homogenize(frames, intersect=True):
@@ -1885,6 +1896,8 @@ def _homogenize(frames, intersect=True):
     for k, v in frames.iteritems():
         if isinstance(v, dict):
             adj_frames[k] = DataMatrix(v)
+        elif not isinstance(v, DataMatrix):
+            adj_frames[k] = v.toDataMatrix()
         else:
             adj_frames[k] = v
 
@@ -1918,9 +1931,6 @@ def _homogenize(frames, intersect=True):
             result[key] = frame.filter(columns).reindex(index)
     else:
         for key, frame in adj_frames.iteritems():
-            if not isinstance(frame, DataMatrix):
-                frame = frame.toDataMatrix()
-
             result[key] = frame.reindex(index=index, columns=columns)
 
     return result, index, columns
@@ -1947,8 +1957,7 @@ def pivot(index, columns, values):
     -------
     DataMatrix
     """
-    if not (len(index) == len(columns) == len(values)):
-        raise Exception('Pivot inputs must all be same length!')
+    assert(len(index) == len(columns) == len(values))
 
     if len(index) == 0:
         return DataMatrix(index=[])
diff --git a/pandas/core/series.py b/pandas/core/series.py
index dcefafd31..bc8822e26 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -809,7 +809,7 @@ class Series(np.ndarray, Picklable, Groupable):
         """
         if fillMethod is not None: # pragma: no cover
             warnings.warn("'fillMethod' is deprecated. Use 'method' instead",
-                          DeprecationWarning)
+                          FutureWarning)
 
             method = fillMethod
 
@@ -868,7 +868,7 @@ class Series(np.ndarray, Picklable, Groupable):
         warnings.warn("fill is being replaced by fillna, and the fill function "
                       "behavior will disappear in the next release: please "
                       "modify your code accordingly",
-                      DeprecationWarning)
+                      FutureWarning)
         return self.fillna(value=value, method=method)
 
     def fillna(self, value=None, method='pad'):
diff --git a/pandas/core/tests/test_panel.py b/pandas/core/tests/test_panel.py
index fb918de36..c41f71976 100644
--- a/pandas/core/tests/test_panel.py
+++ b/pandas/core/tests/test_panel.py
@@ -11,6 +11,8 @@ from pandas.core.api import DataFrame, Index, notnull
 from pandas.core.datetools import bday
 from pandas.core.panel import (WidePanel, LongPanelIndex, LongPanel,
                                group_agg, pivot)
+import pandas.core.panel as panelmod
+
 from pandas.util.testing import (assert_panel_equal,
                                  assert_frame_equal,
                                  assert_series_equal,
@@ -211,9 +213,15 @@ class TestWidePanel(unittest.TestCase, PanelTests):
         itemb = self.panel['ItemB']
 
         d = {'A' : itema, 'B' : itemb[5:]}
+        d2 = {'A' : itema._series, 'B' : itemb[5:]._series}
+        d3 = {'A' : DataFrame(itema._series),
+              'B' : DataFrame(itemb[5:]._series)}
 
         wp = WidePanel.fromDict(d)
+        wp2 = WidePanel.fromDict(d2) # nested Dict
+        wp3 = WidePanel.fromDict(d3)
         self.assert_(wp.major_axis.equals(self.panel.major_axis))
+        assert_panel_equal(wp, wp2)
 
         # intersect
         wp = WidePanel.fromDict(d, intersect=True)
@@ -693,6 +701,17 @@ class TestLongPanel(unittest.TestCase):
         lp2 = self.panel.filter(['ItemC', 'ItemE'])
         self.assertRaises(Exception, lp.__setitem__, 'foo', lp2)
 
+    def test_ops_differently_indexed(self):
+        # trying to set non-identically indexed panel
+        wp = self.panel.toWide()
+        wp2 = wp.reindex(major=wp.major_axis[:-1])
+        lp2 = wp2.toLong()
+
+        self.assertRaises(Exception, self.panel.__setitem__, 'foo',
+                          lp2.filter(['ItemA']))
+
+        self.assertRaises(Exception, self.panel.add, lp2)
+
     def test_combineFrame(self):
         wp = self.panel.toWide()
         result = self.panel.add(wp['ItemA'])
@@ -704,6 +723,9 @@ class TestLongPanel(unittest.TestCase):
         wide_result = result.toWide()
         assert_frame_equal(wp['ItemA'] * 2, wide_result['ItemA'])
 
+        # one item
+        result = self.panel.add(self.panel.filter(['ItemA']))
+
     def test_operators(self):
         wp = self.panel.toWide()
         result = (self.panel + 1).toWide()
@@ -759,6 +781,24 @@ class TestLongPanel(unittest.TestCase):
 
         assert_frame_equal(trunced['ItemA'], expected)
 
+        # truncate on dates that aren't in there
+        wp = self.panel.toWide()
+        new_index = wp.major_axis[::5]
+
+        wp2 = wp.reindex(major=new_index)
+
+        lp2 = wp2.toLong()
+        lp_trunc = lp2.truncate(wp.major_axis[2], wp.major_axis[-2])
+
+        wp_trunc = wp2.truncate(wp.major_axis[2], wp.major_axis[-2])
+
+        assert_panel_equal(wp_trunc, lp_trunc.toWide())
+
+        # throw proper exception
+        self.assertRaises(Exception, lp2.truncate, wp.major_axis[-2],
+                          wp.major_axis[2])
+
+
     def test_filter(self):
         pass
 
@@ -817,10 +857,28 @@ class TestLongPanel(unittest.TestCase):
         assert_frame_equal(sums, wide_sums)
 
     def test_count(self):
-        pass
+        index = self.panel.index
+
+        major_count = self.panel.count('major')
+        labels = index.major_labels
+        for i, idx in enumerate(index.major_axis):
+            self.assertEqual(major_count[i], (labels == i).sum())
+
+        minor_count = self.panel.count('minor')
+        labels = index.minor_labels
+        for i, idx in enumerate(index.minor_axis):
+            self.assertEqual(minor_count[i], (labels == i).sum())
 
     def test_leftJoin(self):
-        pass
+        lp1 = self.panel.filter(['ItemA', 'ItemB'])
+        lp2 = self.panel.filter(['ItemC'])
+
+        joined = lp1.leftJoin(lp2)
+
+        self.assertEqual(len(joined.items), 3)
+
+        self.assertRaises(Exception, lp1.leftJoin,
+                          self.panel.filter(['ItemB', 'ItemC']))
 
     def test_merge(self):
         pass
@@ -829,8 +887,10 @@ class TestLongPanel(unittest.TestCase):
         lp = self.panel.addPrefix('foo#')
         self.assertEqual(lp.items[0], 'foo#ItemA')
 
-    def test_pivot(self):
+        lp = self.panel.addPrefix()
+        assert_panel_equal(lp.toWide(), self.panel.toWide())
 
+    def test_pivot(self):
         df = pivot(np.array([1, 2, 3, 4, 5]),
                    np.array(['a', 'b', 'c', 'd', 'e']),
                    np.array([1, 2, 3, 5, 4.]))
@@ -840,12 +900,14 @@ class TestLongPanel(unittest.TestCase):
         self.assertEqual(df['d'][4], 5)
         self.assertEqual(df['e'][5], 4)
 
-
-        # weird overlap
+        # weird overlap, TODO: test?
         df = pivot(np.array([1, 2, 3, 4, 4]),
                    np.array(['a', 'a', 'a', 'a', 'a']),
                    np.array([1, 2, 3, 5, 4]))
 
+        # corner case, empty
+        df = pivot(np.array([]), np.array([]), np.array([]))
+
 def test_group_agg():
     values = np.ones((10, 2)) * np.arange(10).reshape((10, 1))
     bounds = np.arange(5) * 2
@@ -871,7 +933,25 @@ def test_monotonic():
 
 class TestFactor(unittest.TestCase):
 
-    def test_constructor(self):
-        pass
+    def setUp(self):
+        self.factor = panelmod.Factor.fromarray(['a', 'b', 'b', 'a',
+                                                 'a', 'c', 'c', 'c'])
+
+    def test_getitem(self):
+        self.assertEqual(self.factor[0], 'a')
+        self.assertEqual(self.factor[-1], 'c')
+
+        subf = self.factor[[0, 1, 2]]
+        common.assert_almost_equal(subf.labels, [0, 1, 1])
+
+        subf = self.factor[self.factor.asarray() == 'c']
+        common.assert_almost_equal(subf.labels, [2, 2, 2])
 
+    def test_factor_agg(self):
+        arr = np.arange(len(self.factor))
 
+        f = np.sum
+        agged = panelmod.factor_agg(self.factor, arr, f)
+        labels = self.factor.labels
+        for i, idx in enumerate(self.factor.levels):
+            self.assertEqual(f(arr[labels == i]), agged[i])

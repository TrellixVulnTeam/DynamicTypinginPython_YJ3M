commit d75fcd8696caa2f9d8365a8a821d4f76dcd28dc0
Author: Jeff Reback <jeff@reback.net>
Date:   Thu Nov 19 07:55:13 2015 -0500

    DOC: fix up doc-string creations in generic.py

diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 072a9f0da..3df81481f 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -4589,162 +4589,23 @@ class NDFrame(PandasObject):
     def _add_numeric_operations(cls):
         """ add the operations to the cls; evaluate the doc strings again """
 
-        axis_descr = "{%s}" % ', '.join([
-            "{0} ({1})".format(a, i) for i, a in enumerate(cls._AXIS_ORDERS)
-        ])
-        name = (cls._constructor_sliced.__name__
-                if cls._AXIS_LEN > 1 else 'scalar')
-
-        _num_doc = """
-
-%(desc)s
-
-Parameters
-----------
-axis : """ + axis_descr + """
-skipna : boolean, default True
-    Exclude NA/null values. If an entire row/column is NA, the result
-    will be NA
-level : int or level name, default None
-        If the axis is a MultiIndex (hierarchical), count along a
-        particular level, collapsing into a """ + name + """
-numeric_only : boolean, default None
-    Include only float, int, boolean data. If None, will attempt to use
-    everything, then use only numeric data
-
-Returns
--------
-%(outname)s : """ + name + " or " + cls.__name__ + " (if level specified)\n"
-
-        _bool_doc = """
-
-%(desc)s
-
-Parameters
-----------
-axis : """ + axis_descr + """
-skipna : boolean, default True
-    Exclude NA/null values. If an entire row/column is NA, the result
-    will be NA
-level : int or level name, default None
-        If the axis is a MultiIndex (hierarchical), count along a
-        particular level, collapsing into a """ + name + """
-bool_only : boolean, default None
-    Include only boolean data. If None, will attempt to use everything,
-    then use only boolean data
-
-Returns
--------
-%(outname)s : """ + name + " or " + cls.__name__ + " (if level specified)\n"
-
-        _cnum_doc = """
-
-Parameters
-----------
-axis : """ + axis_descr + """
-skipna : boolean, default True
-    Exclude NA/null values. If an entire row/column is NA, the result
-    will be NA
-
-Returns
--------
-%(outname)s : """ + name + "\n"
-
-        def _make_stat_function(name, desc, f):
-
-            @Substitution(outname=name, desc=desc)
-            @Appender(_num_doc)
-            def stat_func(self, axis=None, skipna=None, level=None,
-                          numeric_only=None, **kwargs):
-                if skipna is None:
-                    skipna = True
-                if axis is None:
-                    axis = self._stat_axis_number
-                if level is not None:
-                    return self._agg_by_level(name, axis=axis, level=level,
-                                              skipna=skipna)
-                return self._reduce(f, name, axis=axis,
-                                    skipna=skipna, numeric_only=numeric_only)
-            stat_func.__name__ = name
-            return stat_func
-
-        cls.sum = _make_stat_function(
-            'sum', 'Return the sum of the values for the requested axis',
-            nanops.nansum)
-        cls.mean = _make_stat_function(
-            'mean', 'Return the mean of the values for the requested axis',
-            nanops.nanmean)
-        cls.skew = _make_stat_function(
-            'skew',
-            'Return unbiased skew over requested axis\nNormalized by N-1',
-            nanops.nanskew)
-        cls.kurt = _make_stat_function(
-            'kurt',
-            'Return unbiased kurtosis over requested axis using Fisher''s '
-            'definition of\nkurtosis (kurtosis of normal == 0.0). Normalized '
-            'by N-1\n',
-            nanops.nankurt)
-        cls.kurtosis = cls.kurt
-        cls.prod = _make_stat_function(
-            'prod', 'Return the product of the values for the requested axis',
-            nanops.nanprod)
-        cls.product = cls.prod
-        cls.median = _make_stat_function(
-            'median', 'Return the median of the values for the requested axis',
-            nanops.nanmedian)
-        cls.max = _make_stat_function('max', """
-This method returns the maximum of the values in the object. If you
-want the *index* of the maximum, use ``idxmax``. This is the
-equivalent of the ``numpy.ndarray`` method ``argmax``.""", nanops.nanmax)
-        cls.min = _make_stat_function('min', """
-This method returns the minimum of the values in the object. If you
-want the *index* of the minimum, use ``idxmin``. This is the
-equivalent of the ``numpy.ndarray`` method ``argmin``.""", nanops.nanmin)
-
-        if cls.__name__ == 'Series':
-            def nanptp(values, axis=0, skipna=True):
-                nmax = nanops.nanmax(values, axis, skipna)
-                nmin = nanops.nanmin(values, axis, skipna)
-                return nmax - nmin
-
-            cls.ptp = _make_stat_function('ptp', """
-Returns the difference between the maximum value and the minimum
-value in the object. This is the equivalent of the ``numpy.ndarray``
-method ``ptp``.""", nanptp)
-
-        def _make_logical_function(name, desc, f):
-
-            @Substitution(outname=name, desc=desc)
-            @Appender(_bool_doc)
-            def logical_func(self, axis=None, bool_only=None, skipna=None,
-                             level=None, **kwargs):
-                if skipna is None:
-                    skipna = True
-                if axis is None:
-                    axis = self._stat_axis_number
-                if level is not None:
-                    if bool_only is not None:
-                        raise NotImplementedError(
-                            "Option bool_only is not implemented with option "
-                            "level.")
-                    return self._agg_by_level(name, axis=axis, level=level,
-                                              skipna=skipna)
-                return self._reduce(f, axis=axis, skipna=skipna,
-                                    numeric_only=bool_only, filter_type='bool',
-                                    name=name)
-            logical_func.__name__ = name
-            return logical_func
+        axis_descr, name, name2 = _doc_parms(cls)
 
         cls.any = _make_logical_function(
-            'any', 'Return whether any element is True over requested axis',
+            'any', name, name2, axis_descr,
+            'Return whether any element is True over requested axis',
             nanops.nanany)
         cls.all = _make_logical_function(
-            'all', 'Return whether all elements are True over requested axis',
+            'all', name, name2, axis_descr,
+            'Return whether all elements are True over requested axis',
             nanops.nanall)
 
         @Substitution(outname='mad',
                       desc="Return the mean absolute deviation of the values "
-                           "for the requested axis")
+                           "for the requested axis",
+                      name1=name,
+                      name2=name2,
+                      axis_descr=axis_descr)
         @Appender(_num_doc)
         def mad(self,  axis=None, skipna=None, level=None):
             if skipna is None:
@@ -4763,39 +4624,20 @@ method ``ptp``.""", nanptp)
             return np.abs(demeaned).mean(axis=axis, skipna=skipna)
         cls.mad = mad
 
-        def _make_stat_function_ddof(name, desc, f):
-
-            @Substitution(outname=name, desc=desc)
-            @Appender(_num_doc)
-            def stat_func(self, axis=None, skipna=None, level=None, ddof=1,
-                          numeric_only=None, **kwargs):
-                if skipna is None:
-                    skipna = True
-                if axis is None:
-                    axis = self._stat_axis_number
-                if level is not None:
-                    return self._agg_by_level(name, axis=axis, level=level,
-                                              skipna=skipna, ddof=ddof)
-                return self._reduce(f, name, axis=axis,
-                                    numeric_only=numeric_only,
-                                    skipna=skipna, ddof=ddof)
-            stat_func.__name__ = name
-            return stat_func
-
         cls.sem = _make_stat_function_ddof(
-            'sem',
+            'sem', name, name2, axis_descr,
             "Return unbiased standard error of the mean over "
             "requested axis.\n\nNormalized by N-1 by default. "
             "This can be changed using the ddof argument",
             nanops.nansem)
         cls.var = _make_stat_function_ddof(
-            'var',
+            'var', name, name2, axis_descr,
             "Return unbiased variance over requested "
             "axis.\n\nNormalized by N-1 by default. "
             "This can be changed using the ddof argument",
             nanops.nanvar)
         cls.std = _make_stat_function_ddof(
-            'std',
+            'std', name, name2, axis_descr,
             "Return unbiased standard deviation over requested "
             "axis.\n\nNormalized by N-1 by default. "
             "This can be changed using the ddof argument",
@@ -4803,7 +4645,10 @@ method ``ptp``.""", nanptp)
 
         @Substitution(outname='compounded',
                       desc="Return the compound percentage of the values for "
-                           "the requested axis")
+                           "the requested axis",
+                      name1=name,
+                      name2=name2,
+                      axis_descr=axis_descr)
         @Appender(_num_doc)
         def compound(self, axis=None, skipna=None, level=None):
             if skipna is None:
@@ -4811,51 +4656,264 @@ method ``ptp``.""", nanptp)
             return (1 + self).prod(axis=axis, skipna=skipna, level=level) - 1
         cls.compound = compound
 
-        def _make_cum_function(name, accum_func, mask_a, mask_b):
-
-            @Substitution(outname=name)
-            @Appender("Return cumulative {0} over requested axis.".format(name)
-                      + _cnum_doc)
-            def func(self, axis=None, dtype=None, out=None, skipna=True,
-                     **kwargs):
-                if axis is None:
-                    axis = self._stat_axis_number
-                else:
-                    axis = self._get_axis_number(axis)
-
-                y = _values_from_object(self).copy()
-
-                if skipna and issubclass(y.dtype.type,
-                                         (np.datetime64, np.timedelta64)):
-                    result = accum_func(y, axis)
-                    mask = isnull(self)
-                    np.putmask(result, mask, pd.tslib.iNaT)
-                elif skipna and not issubclass(y.dtype.type, (np.integer, np.bool_)):
-                    mask = isnull(self)
-                    np.putmask(y, mask, mask_a)
-                    result = accum_func(y, axis)
-                    np.putmask(result, mask, mask_b)
-                else:
-                    result = accum_func(y, axis)
-
-                d = self._construct_axes_dict()
-                d['copy'] = False
-                return self._constructor(result, **d).__finalize__(self)
-
-            func.__name__ = name
-            return func
-
         cls.cummin = _make_cum_function(
-            'min', lambda y, axis: np.minimum.accumulate(y, axis),
+            'min', name, name2, axis_descr,
+            "cumulative minimum",
+            lambda y, axis: np.minimum.accumulate(y, axis),
             np.inf, np.nan)
         cls.cumsum = _make_cum_function(
-            'sum', lambda y, axis: y.cumsum(axis), 0., np.nan)
+            'sum', name, name2, axis_descr,
+            "cumulative sum",
+            lambda y, axis: y.cumsum(axis), 0., np.nan)
         cls.cumprod = _make_cum_function(
-            'prod', lambda y, axis: y.cumprod(axis), 1., np.nan)
+            'prod', name, name2, axis_descr,
+            "cumulative product",
+            lambda y, axis: y.cumprod(axis), 1., np.nan)
         cls.cummax = _make_cum_function(
-            'max', lambda y, axis: np.maximum.accumulate(y, axis),
+            'max', name, name2, axis_descr,
+            "cumulative max",
+            lambda y, axis: np.maximum.accumulate(y, axis),
             -np.inf, np.nan)
 
+        cls.sum = _make_stat_function(
+            'sum', name, name2, axis_descr,
+            'Return the sum of the values for the requested axis',
+            nanops.nansum)
+        cls.mean = _make_stat_function(
+            'mean', name, name2, axis_descr,
+            'Return the mean of the values for the requested axis',
+            nanops.nanmean)
+        cls.skew = _make_stat_function(
+            'skew', name, name2, axis_descr,
+            'Return unbiased skew over requested axis\nNormalized by N-1',
+            nanops.nanskew)
+        cls.kurt = _make_stat_function(
+            'kurt', name, name2, axis_descr,
+            'Return unbiased kurtosis over requested axis using Fisher''s '
+            'definition of\nkurtosis (kurtosis of normal == 0.0). Normalized '
+            'by N-1\n',
+            nanops.nankurt)
+        cls.kurtosis = cls.kurt
+        cls.prod = _make_stat_function(
+            'prod', name, name2, axis_descr,
+            'Return the product of the values for the requested axis',
+            nanops.nanprod)
+        cls.product = cls.prod
+        cls.median = _make_stat_function(
+            'median', name, name2, axis_descr,
+            'Return the median of the values for the requested axis',
+            nanops.nanmedian)
+        cls.max = _make_stat_function('max',  name, name2, axis_descr,
+                                      """This method returns the maximum of the values in the object. If you
+                                      want the *index* of the maximum, use ``idxmax``. This is the
+                                      equivalent of the ``numpy.ndarray`` method ``argmax``.""",
+                                      nanops.nanmax)
+        cls.min = _make_stat_function('min',  name, name2, axis_descr,
+                                      """This method returns the minimum of the values in the object. If you
+                                      want the *index* of the minimum, use ``idxmin``. This is the
+                                      equivalent of the ``numpy.ndarray`` method ``argmin``.""",
+                                      nanops.nanmin)
+
+    @classmethod
+    def _add_series_only_operations(cls):
+        """ add the series only operations to the cls; evaluate the doc strings again """
+
+        axis_descr, name, name2 = _doc_parms(cls)
+
+        def nanptp(values, axis=0, skipna=True):
+            nmax = nanops.nanmax(values, axis, skipna)
+            nmin = nanops.nanmin(values, axis, skipna)
+            return nmax - nmin
+
+        cls.ptp = _make_stat_function('ptp', name, name2, axis_descr,
+                                      """
+                                      Returns the difference between the maximum value and the minimum
+                                      value in the object. This is the equivalent of the ``numpy.ndarray``
+                                      method ``ptp``.""", nanptp)
+
+
+def _doc_parms(cls):
+    """ return a tuple of the doc parms """
+    axis_descr = "{%s}" % ', '.join([
+        "{0} ({1})".format(a, i) for i, a in enumerate(cls._AXIS_ORDERS)
+        ])
+    name = (cls._constructor_sliced.__name__
+            if cls._AXIS_LEN > 1 else 'scalar')
+    name2 = cls.__name__
+    return axis_descr, name, name2
+
+_num_doc = """
+
+%(desc)s
+
+Parameters
+----------
+axis : %(axis_descr)s
+skipna : boolean, default True
+    Exclude NA/null values. If an entire row/column is NA, the result
+    will be NA
+level : int or level name, default None
+    If the axis is a MultiIndex (hierarchical), count along a
+    particular level, collapsing into a %(name1)s
+numeric_only : boolean, default None
+    Include only float, int, boolean data. If None, will attempt to use
+    everything, then use only numeric data
+
+Returns
+-------
+%(outname)s : %(name1)s or %(name2)s (if level specified)\n"""
+
+_num_ddof_doc = """
+
+%(desc)s
+
+Parameters
+----------
+axis : %(axis_descr)s
+skipna : boolean, default True
+    Exclude NA/null values. If an entire row/column is NA, the result
+    will be NA
+level : int or level name, default None
+    If the axis is a MultiIndex (hierarchical), count along a
+    particular level, collapsing into a %(name1)s
+ddof : int, default 1
+    degrees of freedom
+numeric_only : boolean, default None
+    Include only float, int, boolean data. If None, will attempt to use
+    everything, then use only numeric data
+
+Returns
+-------
+%(outname)s : %(name1)s or %(name2)s (if level specified)\n"""
+
+_bool_doc = """
+
+%(desc)s
+
+Parameters
+----------
+axis : %(axis_descr)s
+skipna : boolean, default True
+    Exclude NA/null values. If an entire row/column is NA, the result
+    will be NA
+level : int or level name, default None
+    If the axis is a MultiIndex (hierarchical), count along a
+    particular level, collapsing into a %(name1)s
+bool_only : boolean, default None
+    Include only boolean data. If None, will attempt to use everything,
+    then use only boolean data
+
+Returns
+-------
+%(outname)s : %(name1)s or %(name2)s (if level specified)\n"""
+
+_cnum_doc = """
+
+Parameters
+----------
+axis : %(axis_descr)s
+skipna : boolean, default True
+    Exclude NA/null values. If an entire row/column is NA, the result
+    will be NA
+
+Returns
+-------
+%(outname)s : %(name1)s\n"""
+
+def _make_stat_function(name, name1, name2, axis_descr, desc, f):
+
+    @Substitution(outname=name, desc=desc, name1=name1, name2=name2, axis_descr=axis_descr)
+    @Appender(_num_doc)
+    def stat_func(self, axis=None, skipna=None, level=None,
+                  numeric_only=None, **kwargs):
+        if skipna is None:
+            skipna = True
+        if axis is None:
+            axis = self._stat_axis_number
+        if level is not None:
+            return self._agg_by_level(name, axis=axis, level=level,
+                                      skipna=skipna)
+        return self._reduce(f, name, axis=axis,
+                            skipna=skipna, numeric_only=numeric_only)
+    stat_func.__name__ = name
+    return stat_func
+
+def _make_stat_function_ddof(name, name1, name2, axis_descr, desc, f):
+
+    @Substitution(outname=name, desc=desc, name1=name1, name2=name2, axis_descr=axis_descr)
+    @Appender(_num_ddof_doc)
+    def stat_func(self, axis=None, skipna=None, level=None, ddof=1,
+                  numeric_only=None, **kwargs):
+        if skipna is None:
+            skipna = True
+        if axis is None:
+            axis = self._stat_axis_number
+        if level is not None:
+            return self._agg_by_level(name, axis=axis, level=level,
+                                      skipna=skipna, ddof=ddof)
+        return self._reduce(f, name, axis=axis,
+                            numeric_only=numeric_only,
+                            skipna=skipna, ddof=ddof)
+    stat_func.__name__ = name
+    return stat_func
+
+def _make_cum_function(name, name1, name2, axis_descr, desc, accum_func, mask_a, mask_b):
+
+    @Substitution(outname=name, desc=desc, name1=name1, name2=name2, axis_descr=axis_descr)
+    @Appender("Return cumulative {0} over requested axis.".format(name)
+              + _cnum_doc)
+    def func(self, axis=None, dtype=None, out=None, skipna=True,
+             **kwargs):
+        if axis is None:
+            axis = self._stat_axis_number
+        else:
+            axis = self._get_axis_number(axis)
+
+        y = _values_from_object(self).copy()
+
+        if skipna and issubclass(y.dtype.type,
+                                 (np.datetime64, np.timedelta64)):
+            result = accum_func(y, axis)
+            mask = isnull(self)
+            np.putmask(result, mask, pd.tslib.iNaT)
+        elif skipna and not issubclass(y.dtype.type, (np.integer, np.bool_)):
+            mask = isnull(self)
+            np.putmask(y, mask, mask_a)
+            result = accum_func(y, axis)
+            np.putmask(result, mask, mask_b)
+        else:
+            result = accum_func(y, axis)
+
+        d = self._construct_axes_dict()
+        d['copy'] = False
+        return self._constructor(result, **d).__finalize__(self)
+
+    func.__name__ = name
+    return func
+
+def _make_logical_function(name, name1, name2, axis_descr, desc, f):
+
+    @Substitution(outname=name, desc=desc, name1=name1, name2=name2, axis_descr=axis_descr)
+    @Appender(_bool_doc)
+    def logical_func(self, axis=None, bool_only=None, skipna=None,
+                     level=None, **kwargs):
+        if skipna is None:
+            skipna = True
+        if axis is None:
+            axis = self._stat_axis_number
+        if level is not None:
+            if bool_only is not None:
+                raise NotImplementedError(
+                    "Option bool_only is not implemented with option "
+                    "level.")
+            return self._agg_by_level(name, axis=axis, level=level,
+                                              skipna=skipna)
+        return self._reduce(f, axis=axis, skipna=skipna,
+                            numeric_only=bool_only, filter_type='bool',
+                            name=name)
+    logical_func.__name__ = name
+    return logical_func
+
 # install the indexerse
 for _name, _indexer in indexing.get_indexers_list():
     NDFrame._create_indexer(_name, _indexer)
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index f05e5a835..d2fcd6ed1 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -1530,7 +1530,6 @@ ops.add_special_arithmetic_methods(Panel, **ops.panel_special_funcs)
 Panel._add_aggregate_operations()
 Panel._add_numeric_operations()
 
-
 # legacy
 class WidePanel(Panel):
     def __init__(self, *args, **kwargs):
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 15b3f9b7c..e603c6aa7 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2717,6 +2717,7 @@ class Series(base.IndexOpsMixin, strings.StringAccessorMixin, generic.NDFrame,):
 Series._setup_axes(['index'], info_axis=0, stat_axis=0,
                    aliases={'rows': 0})
 Series._add_numeric_operations()
+Series._add_series_only_operations()
 _INDEX_TYPES = ndarray, Index, list, tuple
 
 #------------------------------------------------------------------------------

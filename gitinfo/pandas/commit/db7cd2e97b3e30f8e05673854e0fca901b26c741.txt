commit db7cd2e97b3e30f8e05673854e0fca901b26c741
Author: Tobias Brandt <Tobias.Brandt@gmail.com>
Date:   Wed Jun 19 13:28:59 2013 +0200

    TST: Copied existing tests for BusinessDay for CustomBusinessDay to test that
    the CustomBusinessDay class can be used as a drop-in replacement of the
    BusinessDay class.
    
    TST: Added tests for the holidays and weekmask functionality of the
    CustomBusinessDay class.
    
    TST: Added checks to skip tests involving CustomBusinessDay when this class
    isn't available due to numpy requirements not being met.
    
    TST: Added tests for holidays and weekmask functionality in cdate_range.

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index f60085e7b..d6da94856 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -11,9 +11,9 @@ businessDay = bday
 try:
     cday = CDay()
     customBusinessDay = CustomBusinessDay()
-except ImportError:
-    # Don't create CustomBusinessDay instances when not available
-    pass
+except NotImplementedError:
+    cday = None
+    customBusinessDay = None
 monthEnd = MonthEnd()
 yearEnd = YearEnd()
 yearBegin = YearBegin()
diff --git a/pandas/tseries/frequencies.py b/pandas/tseries/frequencies.py
index 93dd25493..51b8e5d04 100644
--- a/pandas/tseries/frequencies.py
+++ b/pandas/tseries/frequencies.py
@@ -121,10 +121,14 @@ from pandas.tseries.offsets import (Micro, Milli, Second, Minute, Hour,
                                     BQuarterEnd, YearBegin, YearEnd,
                                     BYearBegin, BYearEnd,
                                     )
+try:
+    cday = CDay()
+except NotImplementedError:
+    cday = None
 
 _offset_map = {
     'D': Day(),
-    'C': CDay(),
+    'C': cday,
     'B': BDay(),
     'H': Hour(),
     'T': Minute(),
diff --git a/pandas/tseries/offsets.py b/pandas/tseries/offsets.py
index 1625a443f..81942bc99 100644
--- a/pandas/tseries/offsets.py
+++ b/pandas/tseries/offsets.py
@@ -385,8 +385,9 @@ class CustomBusinessDay(BusinessDay):
         # Check we have the required numpy version
         from distutils.version import LooseVersion
         if LooseVersion(np.__version__) < '1.7.0':
-            raise ImportError("CustomBusinessDay requires numpy >= 1.7.0. "
-                              "Current version: "+np.__version__)
+            raise NotImplementedError("CustomBusinessDay requires numpy >= "
+                                      "1.7.0. Current version: " +
+                                      np.__version__)
 
         self.n = int(n)
         self.kwds = kwds
diff --git a/pandas/tseries/tests/test_daterange.py b/pandas/tseries/tests/test_daterange.py
index 7fbdbbe32..4c46dcccb 100644
--- a/pandas/tseries/tests/test_daterange.py
+++ b/pandas/tseries/tests/test_daterange.py
@@ -1,6 +1,7 @@
 from datetime import datetime
 import pickle
 import unittest
+import nose
 
 import numpy as np
 
@@ -9,7 +10,7 @@ from pandas.tseries.index import DatetimeIndex
 
 from pandas import Timestamp
 from pandas.tseries.offsets import generate_range
-from pandas.tseries.index import bdate_range, date_range
+from pandas.tseries.index import cdate_range, bdate_range, date_range
 import pandas.tseries.tools as tools
 
 import pandas.core.datetools as datetools
@@ -23,6 +24,11 @@ def _skip_if_no_pytz():
         raise nose.SkipTest
 
 
+def _skip_if_no_cday():
+    if datetools.cday is None:
+        raise nose.SkipTest("CustomBusinessDay not available.")
+
+
 def eq_gen_range(kwargs, expected):
     rng = generate_range(**kwargs)
     assert(np.array_equal(list(rng), expected))
@@ -37,6 +43,12 @@ class TestGenRangeGeneration(unittest.TestCase):
         rng2 = list(generate_range(START, END, time_rule='B'))
         self.assert_(np.array_equal(rng1, rng2))
 
+    def test_generate_cday(self):
+        _skip_if_no_cday()
+        rng1 = list(generate_range(START, END, offset=datetools.cday))
+        rng2 = list(generate_range(START, END, time_rule='C'))
+        self.assert_(np.array_equal(rng1, rng2))
+
     def test_1(self):
         eq_gen_range(dict(start=datetime(2009, 3, 25), periods=2),
                      [datetime(2009, 3, 25), datetime(2009, 3, 26)])
@@ -364,7 +376,235 @@ class TestDateRange(unittest.TestCase):
         early_dr.union(late_dr)
 
 
+class TestCustomDateRange(unittest.TestCase):
+
+    def setUp(self):
+        _skip_if_no_cday()
+        self.rng = cdate_range(START, END)
+
+    def test_constructor(self):
+        rng = cdate_range(START, END, freq=datetools.cday)
+        rng = cdate_range(START, periods=20, freq=datetools.cday)
+        rng = cdate_range(end=START, periods=20, freq=datetools.cday)
+        self.assertRaises(ValueError, date_range, '2011-1-1', '2012-1-1', 'C')
+        self.assertRaises(ValueError, cdate_range, '2011-1-1', '2012-1-1', 'C')
+
+    def test_cached_range(self):
+        rng = DatetimeIndex._cached_range(START, END,
+                                          offset=datetools.cday)
+        rng = DatetimeIndex._cached_range(START, periods=20,
+                                          offset=datetools.cday)
+        rng = DatetimeIndex._cached_range(end=START, periods=20,
+                                          offset=datetools.cday)
+
+        self.assertRaises(Exception, DatetimeIndex._cached_range, START, END)
+
+        self.assertRaises(Exception, DatetimeIndex._cached_range, START,
+                          freq=datetools.cday)
+
+        self.assertRaises(Exception, DatetimeIndex._cached_range, end=END,
+                          freq=datetools.cday)
+
+        self.assertRaises(Exception, DatetimeIndex._cached_range, periods=20,
+                          freq=datetools.cday)
+
+    def test_comparison(self):
+        d = self.rng[10]
+
+        comp = self.rng > d
+        self.assert_(comp[11])
+        self.assert_(not comp[9])
+
+    def test_copy(self):
+        cp = self.rng.copy()
+        repr(cp)
+        self.assert_(cp.equals(self.rng))
+
+    def test_repr(self):
+        # only really care that it works
+        repr(self.rng)
+
+    def test_getitem(self):
+        smaller = self.rng[:5]
+        self.assert_(np.array_equal(smaller, self.rng.view(np.ndarray)[:5]))
+        self.assertEquals(smaller.offset, self.rng.offset)
+
+        sliced = self.rng[::5]
+        self.assertEquals(sliced.offset, datetools.cday * 5)
+
+        fancy_indexed = self.rng[[4, 3, 2, 1, 0]]
+        self.assertEquals(len(fancy_indexed), 5)
+        self.assert_(isinstance(fancy_indexed, DatetimeIndex))
+        self.assert_(fancy_indexed.freq is None)
+
+        # 32-bit vs. 64-bit platforms
+        self.assertEquals(self.rng[4], self.rng[np.int_(4)])
+
+    def test_getitem_matplotlib_hackaround(self):
+        values = self.rng[:, None]
+        expected = self.rng.values[:, None]
+        self.assert_(np.array_equal(values, expected))
+
+    def test_shift(self):
+        shifted = self.rng.shift(5)
+        self.assertEquals(shifted[0], self.rng[5])
+        self.assertEquals(shifted.offset, self.rng.offset)
+
+        shifted = self.rng.shift(-5)
+        self.assertEquals(shifted[5], self.rng[0])
+        self.assertEquals(shifted.offset, self.rng.offset)
+
+        shifted = self.rng.shift(0)
+        self.assertEquals(shifted[0], self.rng[0])
+        self.assertEquals(shifted.offset, self.rng.offset)
+
+        rng = date_range(START, END, freq=datetools.bmonthEnd)
+        shifted = rng.shift(1, freq=datetools.cday)
+        self.assertEquals(shifted[0], rng[0] + datetools.cday)
+
+    def test_pickle_unpickle(self):
+        pickled = pickle.dumps(self.rng)
+        unpickled = pickle.loads(pickled)
+
+        self.assert_(unpickled.offset is not None)
+
+    def test_union(self):
+        # overlapping
+        left = self.rng[:10]
+        right = self.rng[5:10]
+
+        the_union = left.union(right)
+        self.assert_(isinstance(the_union, DatetimeIndex))
+
+        # non-overlapping, gap in middle
+        left = self.rng[:5]
+        right = self.rng[10:]
+
+        the_union = left.union(right)
+        self.assert_(isinstance(the_union, Index))
+
+        # non-overlapping, no gap
+        left = self.rng[:5]
+        right = self.rng[5:10]
+
+        the_union = left.union(right)
+        self.assert_(isinstance(the_union, DatetimeIndex))
+
+        # order does not matter
+        self.assert_(np.array_equal(right.union(left), the_union))
+
+        # overlapping, but different offset
+        rng = date_range(START, END, freq=datetools.bmonthEnd)
+
+        the_union = self.rng.union(rng)
+        self.assert_(isinstance(the_union, DatetimeIndex))
+
+    def test_outer_join(self):
+        # should just behave as union
+
+        # overlapping
+        left = self.rng[:10]
+        right = self.rng[5:10]
+
+        the_join = left.join(right, how='outer')
+        self.assert_(isinstance(the_join, DatetimeIndex))
+
+        # non-overlapping, gap in middle
+        left = self.rng[:5]
+        right = self.rng[10:]
+
+        the_join = left.join(right, how='outer')
+        self.assert_(isinstance(the_join, DatetimeIndex))
+        self.assert_(the_join.freq is None)
+
+        # non-overlapping, no gap
+        left = self.rng[:5]
+        right = self.rng[5:10]
+
+        the_join = left.join(right, how='outer')
+        self.assert_(isinstance(the_join, DatetimeIndex))
+
+        # overlapping, but different offset
+        rng = date_range(START, END, freq=datetools.bmonthEnd)
+
+        the_join = self.rng.join(rng, how='outer')
+        self.assert_(isinstance(the_join, DatetimeIndex))
+        self.assert_(the_join.freq is None)
+
+    def test_intersection_bug(self):
+        # GH #771
+        a = cdate_range('11/30/2011', '12/31/2011')
+        b = cdate_range('12/10/2011', '12/20/2011')
+        result = a.intersection(b)
+        self.assert_(result.equals(b))
+
+    def test_summary(self):
+        self.rng.summary()
+        self.rng[2:2].summary()
+
+    def test_summary_pytz(self):
+        _skip_if_no_pytz()
+        import pytz
+        cdate_range('1/1/2005', '1/1/2009', tz=pytz.utc).summary()
+
+    def test_misc(self):
+        end = datetime(2009, 5, 13)
+        dr = cdate_range(end=end, periods=20)
+        firstDate = end - 19 * datetools.cday
+
+        assert len(dr) == 20
+        assert dr[0] == firstDate
+        assert dr[-1] == end
+
+    def test_date_parse_failure(self):
+        badly_formed_date = '2007/100/1'
+
+        self.assertRaises(ValueError, Timestamp, badly_formed_date)
+
+        self.assertRaises(ValueError, cdate_range, start=badly_formed_date,
+                          periods=10)
+        self.assertRaises(ValueError, cdate_range, end=badly_formed_date,
+                          periods=10)
+        self.assertRaises(ValueError, cdate_range, badly_formed_date,
+                          badly_formed_date)
+
+    def test_equals(self):
+        self.assertFalse(self.rng.equals(list(self.rng)))
+
+    def test_daterange_bug_456(self):
+        # GH #456
+        rng1 = cdate_range('12/5/2011', '12/5/2011')
+        rng2 = cdate_range('12/2/2011', '12/5/2011')
+        rng2.offset = datetools.CDay()
+
+        result = rng1.union(rng2)
+        self.assert_(isinstance(result, DatetimeIndex))
+
+    def test_cdaterange(self):
+        rng = cdate_range('2013-05-01', periods=3)
+        xp = DatetimeIndex(['2013-05-01', '2013-05-02', '2013-05-03'])
+        self.assert_(xp.equals(rng))
+
+    def test_cdaterange_weekmask(self):
+        rng = cdate_range('2013-05-01', periods=3,
+                          weekmask='Sun Mon Tue Wed Thu')
+        xp = DatetimeIndex(['2013-05-01', '2013-05-02', '2013-05-05'])
+        self.assert_(xp.equals(rng))
+
+    def test_cdaterange_holidays(self):
+        rng = cdate_range('2013-05-01', periods=3,
+                          holidays=['2013-05-01'])
+        xp = DatetimeIndex(['2013-05-02', '2013-05-03', '2013-05-06'])
+        self.assert_(xp.equals(rng))
+
+    def test_cdaterange_weekmask_and_holidays(self):
+        rng = cdate_range('2013-05-01', periods=3,
+                          weekmask='Sun Mon Tue Wed Thu',
+                          holidays=['2013-05-01'])
+        xp = DatetimeIndex(['2013-05-02', '2013-05-05', '2013-05-06'])
+        self.assert_(xp.equals(rng))
+
+
 if __name__ == '__main__':
-    import nose
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
                    exit=False)
diff --git a/pandas/tseries/tests/test_offsets.py b/pandas/tseries/tests/test_offsets.py
index bcd74e7e6..487a3091f 100644
--- a/pandas/tseries/tests/test_offsets.py
+++ b/pandas/tseries/tests/test_offsets.py
@@ -1,10 +1,13 @@
 from datetime import date, datetime, timedelta
 import unittest
+import nose
+from nose.tools import assert_raises
+
 import numpy as np
 
 from pandas.core.datetools import (
-    bday, BDay, BQuarterEnd, BMonthEnd, BYearEnd, MonthEnd, MonthBegin,
-    BYearBegin, QuarterBegin, BQuarterBegin, BMonthBegin,
+    bday, BDay, cday, CDay, BQuarterEnd, BMonthEnd, BYearEnd, MonthEnd,
+    MonthBegin, BYearBegin, QuarterBegin, BQuarterBegin, BMonthBegin,
     DateOffset, Week, YearBegin, YearEnd, Hour, Minute, Second, Day, Micro,
     Milli, Nano,
     WeekOfMonth, format, ole2datetime, QuarterEnd, to_datetime, normalize_date,
@@ -16,8 +19,6 @@ from pandas.tseries.index import _to_m8
 from pandas.tseries.tools import parse_time_string
 import pandas.tseries.offsets as offsets
 
-from nose.tools import assert_raises
-
 from pandas.tslib import monthrange
 from pandas.lib import Timestamp
 from pandas.util.testing import assertRaisesRegexp
@@ -31,6 +32,12 @@ def test_monthrange():
         for m in range(1, 13):
             assert monthrange(y, m) == calendar.monthrange(y, m)
 
+
+def _skip_if_no_cday():
+    if cday is None:
+        raise nose.SkipTest("CustomBusinessDay not available.")
+
+
 ####
 ## Misc function tests
 ####
@@ -295,6 +302,220 @@ class TestBusinessDay(unittest.TestCase):
         self.assertFalse(offset1 != offset2)
 
 
+class TestCustomBusinessDay(unittest.TestCase):
+    _multiprocess_can_split_ = True
+
+    def setUp(self):
+        self.d = datetime(2008, 1, 1)
+
+        _skip_if_no_cday()
+        self.offset = CDay()
+        self.offset2 = CDay(2)
+
+    def test_different_normalize_equals(self):
+        # equivalent in this special case
+        offset = CDay()
+        offset2 = CDay()
+        offset2.normalize = True
+        self.assertEqual(offset, offset2)
+
+    def test_repr(self):
+        assert repr(self.offset) == '<1 CustomBusinessDay>'
+        assert repr(self.offset2) == '<2 CustomBusinessDays>'
+
+        expected = '<1 BusinessDay: offset=datetime.timedelta(1)>'
+        assert repr(self.offset + timedelta(1)) == expected
+
+    def test_with_offset(self):
+        offset = self.offset + timedelta(hours=2)
+
+        assert (self.d + offset) == datetime(2008, 1, 2, 2)
+
+    def testEQ(self):
+        self.assertEqual(self.offset2, self.offset2)
+
+    def test_mul(self):
+        pass
+
+    def test_hash(self):
+        self.assertEqual(hash(self.offset2), hash(self.offset2))
+
+    def testCall(self):
+        self.assertEqual(self.offset2(self.d), datetime(2008, 1, 3))
+
+    def testRAdd(self):
+        self.assertEqual(self.d + self.offset2, self.offset2 + self.d)
+
+    def testSub(self):
+        off = self.offset2
+        self.assertRaises(Exception, off.__sub__, self.d)
+        self.assertEqual(2 * off - off, off)
+
+        self.assertEqual(self.d - self.offset2, self.d + CDay(-2))
+
+    def testRSub(self):
+        self.assertEqual(self.d - self.offset2, (-self.offset2).apply(self.d))
+
+    def testMult1(self):
+        self.assertEqual(self.d + 10 * self.offset, self.d + CDay(10))
+
+    def testMult2(self):
+        self.assertEqual(self.d + (-5 * CDay(-10)),
+                         self.d + CDay(50))
+
+    def testRollback1(self):
+        self.assertEqual(CDay(10).rollback(self.d), self.d)
+
+    def testRollback2(self):
+        self.assertEqual(
+            CDay(10).rollback(datetime(2008, 1, 5)), datetime(2008, 1, 4))
+
+    def testRollforward1(self):
+        self.assertEqual(CDay(10).rollforward(self.d), self.d)
+
+    def testRollforward2(self):
+        self.assertEqual(
+            CDay(10).rollforward(datetime(2008, 1, 5)), datetime(2008, 1, 7))
+
+    def test_roll_date_object(self):
+        offset = CDay()
+
+        dt = date(2012, 9, 15)
+
+        result = offset.rollback(dt)
+        self.assertEqual(result, datetime(2012, 9, 14))
+
+        result = offset.rollforward(dt)
+        self.assertEqual(result, datetime(2012, 9, 17))
+
+        offset = offsets.Day()
+        result = offset.rollback(dt)
+        self.assertEqual(result, datetime(2012, 9, 15))
+
+        result = offset.rollforward(dt)
+        self.assertEqual(result, datetime(2012, 9, 15))
+
+    def test_onOffset(self):
+        tests = [(CDay(), datetime(2008, 1, 1), True),
+                 (CDay(), datetime(2008, 1, 5), False)]
+
+        for offset, date, expected in tests:
+            assertOnOffset(offset, date, expected)
+
+    def test_apply(self):
+        from pandas.core.datetools import cday
+        tests = []
+
+        tests.append((cday,
+                      {datetime(2008, 1, 1): datetime(2008, 1, 2),
+                       datetime(2008, 1, 4): datetime(2008, 1, 7),
+                       datetime(2008, 1, 5): datetime(2008, 1, 7),
+                       datetime(2008, 1, 6): datetime(2008, 1, 7),
+                       datetime(2008, 1, 7): datetime(2008, 1, 8)}))
+
+        tests.append((2 * cday,
+                      {datetime(2008, 1, 1): datetime(2008, 1, 3),
+                       datetime(2008, 1, 4): datetime(2008, 1, 8),
+                       datetime(2008, 1, 5): datetime(2008, 1, 8),
+                       datetime(2008, 1, 6): datetime(2008, 1, 8),
+                       datetime(2008, 1, 7): datetime(2008, 1, 9)}))
+
+        tests.append((-cday,
+                      {datetime(2008, 1, 1): datetime(2007, 12, 31),
+                       datetime(2008, 1, 4): datetime(2008, 1, 3),
+                       datetime(2008, 1, 5): datetime(2008, 1, 4),
+                       datetime(2008, 1, 6): datetime(2008, 1, 4),
+                       datetime(2008, 1, 7): datetime(2008, 1, 4),
+                       datetime(2008, 1, 8): datetime(2008, 1, 7)}))
+
+        tests.append((-2 * cday,
+                      {datetime(2008, 1, 1): datetime(2007, 12, 28),
+                       datetime(2008, 1, 4): datetime(2008, 1, 2),
+                       datetime(2008, 1, 5): datetime(2008, 1, 3),
+                       datetime(2008, 1, 6): datetime(2008, 1, 3),
+                       datetime(2008, 1, 7): datetime(2008, 1, 3),
+                       datetime(2008, 1, 8): datetime(2008, 1, 4),
+                       datetime(2008, 1, 9): datetime(2008, 1, 7)}))
+
+        tests.append((CDay(0),
+                      {datetime(2008, 1, 1): datetime(2008, 1, 1),
+                       datetime(2008, 1, 4): datetime(2008, 1, 4),
+                       datetime(2008, 1, 5): datetime(2008, 1, 7),
+                       datetime(2008, 1, 6): datetime(2008, 1, 7),
+                       datetime(2008, 1, 7): datetime(2008, 1, 7)}))
+
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
+
+    def test_apply_large_n(self):
+        dt = datetime(2012, 10, 23)
+
+        result = dt + CDay(10)
+        self.assertEqual(result, datetime(2012, 11, 6))
+
+        result = dt + CDay(100) - CDay(100)
+        self.assertEqual(result, dt)
+
+        off = CDay() * 6
+        rs = datetime(2012, 1, 1) - off
+        xp = datetime(2011, 12, 23)
+        self.assertEqual(rs, xp)
+
+        st = datetime(2011, 12, 18)
+        rs = st + off
+        xp = datetime(2011, 12, 26)
+        self.assertEqual(rs, xp)
+
+    def test_apply_corner(self):
+        self.assertRaises(Exception, CDay().apply, BMonthEnd())
+
+    def test_offsets_compare_equal(self):
+        # root cause of #456
+        offset1 = CDay()
+        offset2 = CDay()
+        self.assertFalse(offset1 != offset2)
+
+    def test_holidays(self):
+        # Define a TradingDay offset
+        holidays = ['2012-05-01', datetime(2013, 5, 1),
+                    np.datetime64('2014-05-01')]
+        tday = CDay(holidays=holidays)
+        for year in range(2012, 2015):
+            dt = datetime(year, 4, 30)
+            xp = datetime(year, 5, 2)
+            rs = dt + tday
+            self.assertEqual(rs, xp)
+
+    def test_weekmask(self):
+        weekmask_saudi = 'Sat Sun Mon Tue Wed'  # Thu-Fri Weekend
+        weekmask_uae = '1111001'                # Fri-Sat Weekend
+        weekmask_egypt = [1,1,1,1,0,0,1]        # Fri-Sat Weekend
+        bday_saudi = CDay(weekmask=weekmask_saudi)
+        bday_uae = CDay(weekmask=weekmask_uae)
+        bday_egypt = CDay(weekmask=weekmask_egypt)
+        dt = datetime(2013, 5, 1)
+        xp_saudi = datetime(2013, 5, 4)
+        xp_uae = datetime(2013, 5, 2)
+        xp_egypt = datetime(2013, 5, 2)
+        self.assertEqual(xp_saudi, dt + bday_saudi)
+        self.assertEqual(xp_uae, dt + bday_uae)
+        self.assertEqual(xp_egypt, dt + bday_egypt)
+        xp2 = datetime(2013, 5, 5)
+        self.assertEqual(xp2, dt + 2 * bday_saudi)
+        self.assertEqual(xp2, dt + 2 * bday_uae)
+        self.assertEqual(xp2, dt + 2 * bday_egypt)
+
+    def test_weekmask_and_holidays(self):
+        weekmask_egypt = 'Sun Mon Tue Wed Thu'  # Fri-Sat Weekend
+        holidays = ['2012-05-01', datetime(2013, 5, 1),
+                    np.datetime64('2014-05-01')]
+        bday_egypt = CDay(holidays=holidays, weekmask=weekmask_egypt)
+        dt = datetime(2013, 4, 30)
+        xp_egypt = datetime(2013, 5, 5)
+        self.assertEqual(xp_egypt, dt + 2 * bday_egypt)
+
+
 def assertOnOffset(offset, date, expected):
     actual = offset.onOffset(date)
     assert actual == expected
@@ -1160,7 +1381,6 @@ class TestYearBegin(unittest.TestCase):
                        datetime(2007, 12, 15): datetime(2007, 4, 1),
                        datetime(2012, 1, 31): datetime(2011, 4, 1), }))
 
-
         for offset, cases in tests:
             for base, expected in cases.iteritems():
                 assertEq(offset, base, expected)

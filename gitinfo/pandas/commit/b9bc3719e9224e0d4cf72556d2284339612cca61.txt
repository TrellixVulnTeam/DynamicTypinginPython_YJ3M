commit b9bc3719e9224e0d4cf72556d2284339612cca61
Author: Shahul Hameed <sh9189@gmail.com>
Date:   Sat Sep 27 15:34:50 2014 -0400

    CLN: Remove core/array.py

diff --git a/pandas/core/array.py b/pandas/core/array.py
deleted file mode 100644
index 495f23192..000000000
--- a/pandas/core/array.py
+++ /dev/null
@@ -1,37 +0,0 @@
-"""
-Isolate pandas's exposure to NumPy
-"""
-
-import numpy as np
-
-Array = np.ndarray
-
-bool = np.bool_
-
-_dtypes = {
-    'int': [8, 16, 32, 64],
-    'uint': [8, 16, 32, 64],
-    'float': [16, 32, 64]
-}
-
-_lift_types = []
-
-for _k, _v in _dtypes.items():
-    for _i in _v:
-        _lift_types.append(_k + str(_i))
-
-for _t in _lift_types:
-    globals()[_t] = getattr(np, _t)
-
-_lift_function = ['empty', 'arange', 'array', 'putmask', 'where']
-
-for _f in _lift_function:
-    globals()[_f] = getattr(np, _f)
-
-_lift_random = ['randn', 'rand']
-
-for _f in _lift_random:
-    globals()[_f] = getattr(np.random, _f)
-
-NA = np.nan
-
diff --git a/pandas/core/common.py b/pandas/core/common.py
index e138668b3..a3698c569 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -22,7 +22,6 @@ from pandas import compat
 from pandas.compat import StringIO, BytesIO, range, long, u, zip, map
 
 from pandas.core.config import get_option
-from pandas.core import array as pa
 
 class PandasError(Exception):
     pass
@@ -999,7 +998,7 @@ def _infer_dtype_from_scalar(val):
     dtype = np.object_
 
     # a 1-element ndarray
-    if isinstance(val, pa.Array):
+    if isinstance(val, np.ndarray):
         if val.ndim != 0:
             raise ValueError(
                 "invalid ndarray passed to _infer_dtype_from_scalar")
@@ -1350,7 +1349,7 @@ def _fill_zeros(result, x, y, name, fill):
 
         if not isinstance(y, np.ndarray):
             dtype, value = _infer_dtype_from_scalar(y)
-            y = pa.empty(result.shape, dtype=dtype)
+            y = np.empty(result.shape, dtype=dtype)
             y.fill(value)
 
         if is_integer_dtype(y):
@@ -1575,7 +1574,7 @@ def interpolate_1d(xvalues, yvalues, method='linear', limit=None,
             inds = np.asarray(xvalues)
             # hack for DatetimeIndex, #1646
             if issubclass(inds.dtype.type, np.datetime64):
-                inds = inds.view(pa.int64)
+                inds = inds.view(np.int64)
 
             if inds.dtype == np.object_:
                 inds = lib.maybe_convert_objects(inds)
diff --git a/pandas/core/ops.py b/pandas/core/ops.py
index 7e0dae91f..2c7d92afe 100644
--- a/pandas/core/ops.py
+++ b/pandas/core/ops.py
@@ -12,7 +12,6 @@ from pandas import compat, lib, tslib
 import pandas.index as _index
 from pandas.util.decorators import Appender
 import pandas.core.common as com
-import pandas.core.array as pa
 import pandas.computation.expressions as expressions
 from pandas.core.common import(bind_method, is_list_like, notnull, isnull,
                                _values_from_object, _maybe_match_name)
@@ -332,7 +331,7 @@ class _TimeOp(object):
             # a datelike
             elif isinstance(values, pd.DatetimeIndex):
                 values = values.to_series()
-            elif not (isinstance(values, (pa.Array, pd.Series)) and
+            elif not (isinstance(values, (np.ndarray, pd.Series)) and
                       com.is_datetime64_dtype(values)):
                 values = tslib.array_to_datetime(values)
         elif inferred_type in ('timedelta', 'timedelta64'):
@@ -349,7 +348,7 @@ class _TimeOp(object):
                                 "operation [{0}]".format(name))
         elif isinstance(values[0], pd.DateOffset):
             # handle DateOffsets
-            os = pa.array([getattr(v, 'delta', None) for v in values])
+            os = np.array([getattr(v, 'delta', None) for v in values])
             mask = isnull(os)
             if mask.any():
                 raise TypeError("cannot use a non-absolute DateOffset in "
@@ -366,10 +365,10 @@ class _TimeOp(object):
             else:
                 raise TypeError(
                     'incompatible type [{0}] for a datetime/timedelta '
-                    'operation'.format(pa.array(values).dtype))
+                    'operation'.format(np.array(values).dtype))
         else:
             raise TypeError("incompatible type [{0}] for a datetime/timedelta"
-                            " operation".format(pa.array(values).dtype))
+                            " operation".format(np.array(values).dtype))
 
         return values
 
@@ -408,7 +407,7 @@ class _TimeOp(object):
         if mask is not None:
             if mask.any():
                 def f(x):
-                    x = pa.array(x, dtype=self.dtype)
+                    x = np.array(x, dtype=self.dtype)
                     np.putmask(x, mask, self.fill_value)
                     return x
                 self.wrap_results = f
@@ -449,19 +448,19 @@ def _arith_method_SERIES(op, name, str_rep, fill_zeros=None,
             result = expressions.evaluate(op, str_rep, x, y,
                                           raise_on_error=True, **eval_kwargs)
         except TypeError:
-            if isinstance(y, (pa.Array, pd.Series, pd.Index)):
+            if isinstance(y, (np.ndarray, pd.Series, pd.Index)):
                 dtype = np.find_common_type([x.dtype, y.dtype], [])
                 result = np.empty(x.size, dtype=dtype)
                 mask = notnull(x) & notnull(y)
                 result[mask] = op(x[mask], _values_from_object(y[mask]))
-            elif isinstance(x, pa.Array):
-                result = pa.empty(len(x), dtype=x.dtype)
+            elif isinstance(x, np.ndarray):
+                result = np.empty(len(x), dtype=x.dtype)
                 mask = notnull(x)
                 result[mask] = op(x[mask], y)
             else:
                 raise TypeError("{typ} cannot perform the operation {op}".format(typ=type(x).__name__,op=str_rep))
 
-            result, changed = com._maybe_upcast_putmask(result, ~mask, pa.NA)
+            result, changed = com._maybe_upcast_putmask(result, ~mask, np.nan)
 
         result = com._fill_zeros(result, x, y, name, fill_zeros)
         return result
@@ -531,7 +530,7 @@ def _comp_method_SERIES(op, name, str_rep, masker=False):
             if isinstance(y, list):
                 y = lib.list_to_object_array(y)
 
-            if isinstance(y, (pa.Array, pd.Series)):
+            if isinstance(y, (np.ndarray, pd.Series)):
                 if y.dtype != np.object_:
                     result = lib.vec_compare(x, y.astype(np.object_), op)
                 else:
@@ -558,7 +557,7 @@ def _comp_method_SERIES(op, name, str_rep, masker=False):
                                      index=self.index, name=name)
         elif isinstance(other, pd.DataFrame):  # pragma: no cover
             return NotImplemented
-        elif isinstance(other, (pa.Array, pd.Index)):
+        elif isinstance(other, (np.ndarray, pd.Index)):
             if len(self) != len(other):
                 raise ValueError('Lengths must match to compare')
             return self._constructor(na_op(self.values, np.asarray(other)),
@@ -610,7 +609,7 @@ def _bool_method_SERIES(op, name, str_rep):
             if isinstance(y, list):
                 y = lib.list_to_object_array(y)
 
-            if isinstance(y, (pa.Array, pd.Series)):
+            if isinstance(y, (np.ndarray, pd.Series)):
                 if (x.dtype == np.bool_ and
                         y.dtype == np.bool_):  # pragma: no cover
                     result = op(x, y)  # when would this be hit?
@@ -688,7 +687,7 @@ def _flex_method_SERIES(op, name, str_rep, default_axis=None,
         self._get_axis_number(axis)
         if isinstance(other, pd.Series):
             return self._binop(other, op, level=level, fill_value=fill_value)
-        elif isinstance(other, (pa.Array, pd.Series, list, tuple)):
+        elif isinstance(other, (np.ndarray, pd.Series, list, tuple)):
             if len(other) != len(self):
                 raise ValueError('Lengths must be equal')
             return self._binop(self._constructor(other, self.index), op,
@@ -925,10 +924,10 @@ def _arith_method_PANEL(op, name, str_rep=None, fill_zeros=None,
         except TypeError:
 
             # TODO: might need to find_common_type here?
-            result = pa.empty(len(x), dtype=x.dtype)
+            result = np.empty(len(x), dtype=x.dtype)
             mask = notnull(x)
             result[mask] = op(x[mask], y)
-            result, changed = com._maybe_upcast_putmask(result, ~mask, pa.NA)
+            result, changed = com._maybe_upcast_putmask(result, ~mask, np.nan)
 
         result = com._fill_zeros(result, x, y, name, fill_zeros)
         return result
diff --git a/pandas/core/series.py b/pandas/core/series.py
index f77d3a60a..37f66fc56 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -35,7 +35,6 @@ from pandas import compat
 from pandas.util.terminal import get_terminal_size
 from pandas.compat import zip, u, OrderedDict
 
-import pandas.core.array as pa
 import pandas.core.ops as ops
 from pandas.core.algorithms import select_n
 
@@ -145,7 +144,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
 
                 data = data._to_embed(keep_tz=True)
                 copy = True
-            elif isinstance(data, pa.Array):
+            elif isinstance(data, np.ndarray):
                 pass
             elif isinstance(data, Series):
                 if name is None:
@@ -165,12 +164,12 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
                     if isinstance(index, DatetimeIndex):
                         # coerce back to datetime objects for lookup
                         data = lib.fast_multiget(data, index.astype('O'),
-                                                 default=pa.NA)
+                                                 default=np.nan)
                     elif isinstance(index, PeriodIndex):
                         data = [data.get(i, nan) for i in index]
                     else:
                         data = lib.fast_multiget(data, index.values,
-                                                 default=pa.NA)
+                                                 default=np.nan)
                 except TypeError:
                     data = [data.get(i, nan) for i in index]
 
@@ -558,7 +557,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
                     raise
 
             # pragma: no cover
-            if not isinstance(key, (list, pa.Array, Series, Index)):
+            if not isinstance(key, (list, np.ndarray, Series, Index)):
                 key = list(key)
 
             if isinstance(key, Index):
@@ -688,7 +687,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
                 except Exception:
                     pass
 
-            if not isinstance(key, (list, Series, pa.Array, Series)):
+            if not isinstance(key, (list, Series, np.ndarray, Series)):
                 try:
                     key = list(key)
                 except:
@@ -839,7 +838,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         resetted : DataFrame, or Series if drop == True
         """
         if drop:
-            new_index = pa.arange(len(self))
+            new_index = np.arange(len(self))
             if level is not None and isinstance(self.index, MultiIndex):
                 if not isinstance(level, (tuple, list)):
                     level = [level]
@@ -1111,7 +1110,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
             # call cython function
             max_bin = len(level_index)
             labels = com._ensure_int64(self.index.labels[level])
-            counts = lib.count_level_1d(mask.view(pa.uint8),
+            counts = lib.count_level_1d(mask.view(np.uint8),
                                         labels, max_bin)
             return self._constructor(counts,
                                      index=level_index).__finalize__(self)
@@ -1171,7 +1170,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         """
         i = nanops.nanargmin(_values_from_object(self), skipna=skipna)
         if i == -1:
-            return pa.NA
+            return np.nan
         return self.index[i]
 
     def idxmax(self, axis=None, out=None, skipna=True):
@@ -1198,14 +1197,14 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         """
         i = nanops.nanargmax(_values_from_object(self), skipna=skipna)
         if i == -1:
-            return pa.NA
+            return np.nan
         return self.index[i]
 
     # ndarray compat
     argmin = idxmin
     argmax = idxmax
 
-    @Appender(pa.Array.round.__doc__)
+    @Appender(np.ndarray.round.__doc__)
     def round(self, decimals=0, out=None):
         """
 
@@ -1280,7 +1279,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         """
         this, other = self.align(other, join='inner', copy=False)
         if len(this) == 0:
-            return pa.NA
+            return np.nan
         return nanops.nancorr(this.values, other.values, method=method,
                               min_periods=min_periods)
 
@@ -1302,7 +1301,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         """
         this, other = self.align(other, join='inner', copy=False)
         if len(this) == 0:
-            return pa.NA
+            return np.nan
         return nanops.nancov(this.values, other.values,
                              min_periods=min_periods)
 
@@ -1466,7 +1465,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         if isinstance(other, Series):
             new_index = self.index.union(other.index)
             new_name = _maybe_match_name(self, other)
-            new_values = pa.empty(len(new_index), dtype=self.dtype)
+            new_values = np.empty(len(new_index), dtype=self.dtype)
             for i, idx in enumerate(new_index):
                 lv = self.get(idx, fill_value)
                 rv = other.get(idx, fill_value)
@@ -1692,12 +1691,12 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
                 return arr.argsort(kind='quicksort')
 
         arr = self.values
-        sortedIdx = pa.empty(len(self), dtype=np.int32)
+        sortedIdx = np.empty(len(self), dtype=np.int32)
 
         bad = isnull(arr)
 
         good = ~bad
-        idx = pa.arange(len(self))
+        idx = np.arange(len(self))
 
         argsorted = _try_kind_sort(arr[good])
 
@@ -1930,7 +1929,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
             mask = isnull(values)
 
             def map_f(values, f):
-                return lib.map_infer_mask(values, f, mask.view(pa.uint8))
+                return lib.map_infer_mask(values, f, mask.view(np.uint8))
         else:
             map_f = lib.map_infer
 
@@ -2361,7 +2360,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
                 start = start.ordinal
 
             if where < start:
-                return pa.NA
+                return np.nan
             loc = self.index.searchsorted(where, side='right')
             if loc > 0:
                 loc -= 1
@@ -2508,18 +2507,18 @@ def _sanitize_array(data, index, dtype=None, copy=False,
 
         try:
             arr = _possibly_cast_to_datetime(arr, dtype)
-            subarr = pa.array(arr, dtype=dtype, copy=copy)
+            subarr = np.array(arr, dtype=dtype, copy=copy)
         except (ValueError, TypeError):
             if com.is_categorical_dtype(dtype):
                 subarr = Categorical(arr)
             elif dtype is not None and raise_cast_failure:
                 raise
             else:
-                subarr = pa.array(arr, dtype=object, copy=copy)
+                subarr = np.array(arr, dtype=object, copy=copy)
         return subarr
 
     # GH #846
-    if isinstance(data, (pa.Array, Index, Series)):
+    if isinstance(data, (np.ndarray, Index, Series)):
         subarr = np.array(data, copy=False)
         if dtype is not None:
 
@@ -2564,7 +2563,7 @@ def _sanitize_array(data, index, dtype=None, copy=False,
             except Exception:
                 if raise_cast_failure:  # pragma: no cover
                     raise
-                subarr = pa.array(data, dtype=object, copy=copy)
+                subarr = np.array(data, dtype=object, copy=copy)
                 subarr = lib.maybe_convert_objects(subarr)
 
         else:
@@ -2578,7 +2577,7 @@ def _sanitize_array(data, index, dtype=None, copy=False,
     # scalar like
     if subarr.ndim == 0:
         if isinstance(data, list):  # pragma: no cover
-            subarr = pa.array(data, dtype=object)
+            subarr = np.array(data, dtype=object)
         elif index is not None:
             value = data
 
@@ -2589,7 +2588,7 @@ def _sanitize_array(data, index, dtype=None, copy=False,
                 # need to possibly convert the value here
                 value = _possibly_cast_to_datetime(value, dtype)
 
-            subarr = pa.empty(len(index), dtype=dtype)
+            subarr = np.empty(len(index), dtype=dtype)
             subarr.fill(value)
 
         else:
@@ -2602,11 +2601,11 @@ def _sanitize_array(data, index, dtype=None, copy=False,
             # a 1-element ndarray
             if len(subarr) != len(index) and len(subarr) == 1:
                 value = subarr[0]
-                subarr = pa.empty(len(index), dtype=subarr.dtype)
+                subarr = np.empty(len(index), dtype=subarr.dtype)
                 subarr.fill(value)
 
     elif subarr.ndim > 1:
-        if isinstance(data, pa.Array):
+        if isinstance(data, np.ndarray):
             raise Exception('Data must be 1-dimensional')
         else:
             subarr = _asarray_tuplesafe(data, dtype=dtype)
@@ -2614,7 +2613,7 @@ def _sanitize_array(data, index, dtype=None, copy=False,
     # This is to prevent mixed-type Series getting all casted to
     # NumPy string type, e.g. NaN --> '-1#IND'.
     if issubclass(subarr.dtype.type, compat.string_types):
-        subarr = pa.array(data, dtype=object, copy=copy)
+        subarr = np.array(data, dtype=object, copy=copy)
 
     return subarr
 

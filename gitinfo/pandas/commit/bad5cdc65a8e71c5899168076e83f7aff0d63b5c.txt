commit bad5cdc65a8e71c5899168076e83f7aff0d63b5c
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Jul 14 19:01:52 2010 +0000

    Series.order was failing on object dtype. misc other cleanup
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@198 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/common.py b/pandas/core/common.py
index efa8891f8..1472849f8 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -20,7 +20,8 @@ def isnull(input):
     '''
     if isinstance(input, np.ndarray):
         if input.dtype.kind in ('O', 'S'):
-            result = input.astype(bool)
+            # Working around NumPy ticket 1542
+            result = input.copy().astype(bool)
             result[:] = tseries.isnullobj(input)
         else:
             result = -np.isfinite(input)
@@ -62,7 +63,10 @@ def _unpickle_array(bytes):
 def _pfixed(s, space, nanRep=None, float_format=None):
     if isinstance(s, float):
         if nanRep is not None and isnull(s):
-            return nanRep.ljust(space)
+            if np.isnan(s):
+                return nanRep.ljust(space)
+            else:
+                return str(s).ljust(space)
 
         if float_format:
             formatted = float_format(s)
diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index edd0fdff0..5278ce441 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -287,3 +287,16 @@ class DateRange(Index):
         start = self[0] + n * self.offset
         end = self[-1] + n * self.offset
         return DateRange(start, end, offset=self.offset)
+
+    def union(self, other):
+        if isinstance(other, DateRange) and other.offset == self.offset:
+            # overlap condition
+            if self[-1] >= other[0] or other[-1] >= self[0]:
+                start = min(self[0], other[0])
+                end = max(self[-1], other[-1])
+
+                return DateRange(start, end, offset=self.offset)
+            else:
+                return Index.union(self, other)
+        else:
+            return Index.union(self, other)
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index f09e77b6b..d8e3eb63b 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -803,8 +803,8 @@ class DataMatrix(DataFrame):
                 for j, col in enumerate(columns):
                     formatter = formatters.get(col, ident)
                     buffer.write(_pf(formatter(values[i, j]), colSpace,
-                                         float_format=float_format,
-                                         nanRep=nanRep))
+                                     float_format=float_format,
+                                     nanRep=nanRep))
                 buffer.write('\n')
 
     def info(self, buffer=sys.stdout):
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 5627ea23c..f5f9ee749 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -695,6 +695,14 @@ class Series(np.ndarray, Picklable, Groupable):
         y : Series
             sorted by values
         """
+        def _try_mergesort(arr):
+            # easier to ask forgiveness than permission
+            try:
+                return arr.argsort(kind='mergesort')
+            except TypeError:
+                # stable sort not available for object dtype
+                return arr.argsort()
+
         arr = self.values
         sortedIdx = np.empty(len(self), dtype=np.int32)
 
@@ -704,11 +712,11 @@ class Series(np.ndarray, Picklable, Groupable):
         idx = np.arange(len(self))
         if missingAtEnd:
             n = sum(good)
-            sortedIdx[:n] = idx[good][arr[good].argsort(kind='mergesort')]
+            sortedIdx[:n] = idx[good][_try_mergesort(arr[good])]
             sortedIdx[n:] = idx[bad]
         else:
             n = sum(bad)
-            sortedIdx[n:] = idx[good][arr[good].argsort(kind='mergesort')]
+            sortedIdx[n:] = idx[good][_try_mergesort(arr[good])]
             sortedIdx[:n] = idx[bad]
 
         return Series(arr[sortedIdx], index=self.index[sortedIdx])
@@ -1145,14 +1153,17 @@ def _seriesRepr(index, vals, nanRep='NaN'):
     if vals.dtype == np.object_:
         def _format(k, v):
             return '%s    %s' % (str(k).ljust(padSpace), v)
-    else:
+    elif vals.dtype == np.float_:
         def _format(k, v):
-            if isnull(v):
+            if np.isnan(v):
                 v = nanRep
             else:
                 v = str(v)
 
             return '%s    %s' % (str(k).ljust(padSpace), v)
+    else:
+        def _format(k, v):
+            return '%s    %s' % (str(k).ljust(padSpace), v)
 
     it = itertools.starmap(_format,
                            itertools.izip(string_index, vals))
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
index 886a02582..4b51d515e 100644
--- a/pandas/core/tests/test_series.py
+++ b/pandas/core/tests/test_series.py
@@ -184,6 +184,7 @@ class TestSeries(unittest.TestCase):
     def test_repr(self):
         str(self.ts)
         str(self.series)
+        str(self.series.astype(int))
         str(self.objSeries)
 
         str(Series(common.randn(1000), index=np.arange(1000)))
@@ -443,6 +444,11 @@ class TestSeries(unittest.TestCase):
         self.assert_(np.isnan(result[:5]).all())
         self.assert_(np.array_equal(result[5:], np.sort(vals[5:])))
 
+        # something object-type
+        ser = Series(['A', 'B'], [1, 2])
+        # no failure
+        ser.order()
+
     def test_map(self):
         result = self.ts.map(lambda x: x * 2)
 
diff --git a/pandas/stats/moments.py b/pandas/stats/moments.py
index af443b1a4..c47387eeb 100644
--- a/pandas/stats/moments.py
+++ b/pandas/stats/moments.py
@@ -7,8 +7,7 @@ from functools import wraps
 from numpy import NaN
 import numpy as np
 
-from pandas.core.api import (DataFrame, TimeSeries, DataMatrix,
-                             Series, notnull)
+from pandas.core.api import (DataFrame, DataMatrix, Series, notnull)
 import pandas.lib.tseries as tseries
 
 __all__ = ['rolling_count', 'rolling_sum', 'rolling_mean',
@@ -55,7 +54,7 @@ def rolling_count(arg, window, time_rule=None):
     arg :  DataFrame or numpy ndarray-like
     window : Number of observations used for calculating statistic
     """
-    types = (DataFrame, DataMatrix, TimeSeries)
+    types = (DataFrame, DataMatrix, Series)
     if time_rule is not None and isinstance(arg, types):
         # Conform to whatever frequency needed.
         arg = arg.asfreq(time_rule)
@@ -138,7 +137,7 @@ def _rollingMoment(arg, window, func, minp=None, time_rule=None):
     if minp is None:
         minp = window
 
-    types = (DataFrame, DataMatrix, TimeSeries)
+    types = (DataFrame, DataMatrix, Series)
     if time_rule is not None and isinstance(arg, types):
         # Conform to whatever frequency needed.
         arg = arg.asfreq(time_rule)
@@ -158,7 +157,7 @@ def _rollingMoment(arg, window, func, minp=None, time_rule=None):
             series[np.isinf(series)] = NaN
             output[col] = Series(func(series, window, minp=minp),
                                      index = series.index)
-    elif isinstance(arg, TimeSeries):
+    elif isinstance(arg, Series):
         arg[np.isinf(arg)] = NaN
         output = Series(func(arg, window, minp=minp), index=arg.index)
     else:
@@ -204,12 +203,8 @@ def _ewmoment(values, func, min_periods=None, biasCorrection=None):
     -------
     Same type and length as values argument
     """
-    isSeries = isinstance(values, Series)
     okLocs = notnull(values)
 
-    if isSeries:
-        index = values.index
-
     cleanValues = values[okLocs]
 
     result = np.frompyfunc(func, 2, 1).accumulate(cleanValues)
@@ -257,7 +252,7 @@ def ewma(arg, com, minCom=0):
         result = Series(result, index=arg.index)
         return result
 
-    if isinstance(arg, TimeSeries):
+    if isinstance(arg, Series):
         output = ewmaFunc(arg)
     elif isinstance(arg, DataFrame):
         output = arg.apply(ewmaFunc)

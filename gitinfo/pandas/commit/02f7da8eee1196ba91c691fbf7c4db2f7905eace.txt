commit 02f7da8eee1196ba91c691fbf7c4db2f7905eace
Author: Jeff Reback <jeff@reback.net>
Date:   Fri Mar 23 10:48:19 2018 -0400

    TST: clean deprecation warnings & some parametrizing (#20467)

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 8ff2b6c85..9b09c8768 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2153,7 +2153,7 @@ class DataFrame(NDFrame):
                 lines.append(_put_str(col, space) + tmpl % (count, dtype))
 
         def _non_verbose_repr():
-            lines.append(self.columns.summary(name='Columns'))
+            lines.append(self.columns._summary(name='Columns'))
 
         def _sizeof_fmt(num, size_qualifier):
             # returns size in human readable format
diff --git a/pandas/tests/test_base.py b/pandas/tests/test_base.py
index 9f7b06ed2..c4c02c0bf 100644
--- a/pandas/tests/test_base.py
+++ b/pandas/tests/test_base.py
@@ -647,83 +647,83 @@ class TestIndexOps(Ops):
 
             assert s.nunique() == 0
 
-    def test_value_counts_datetime64(self):
-        klasses = [Index, Series]
-        for klass in klasses:
-            # GH 3002, datetime64[ns]
-            # don't test names though
-            txt = "\n".join(['xxyyzz20100101PIE', 'xxyyzz20100101GUM',
-                             'xxyyzz20100101EGG', 'xxyyww20090101EGG',
-                             'foofoo20080909PIE', 'foofoo20080909GUM'])
-            f = StringIO(txt)
-            df = pd.read_fwf(f, widths=[6, 8, 3],
-                             names=["person_id", "dt", "food"],
-                             parse_dates=["dt"])
-
-            s = klass(df['dt'].copy())
-            s.name = None
-
-            idx = pd.to_datetime(['2010-01-01 00:00:00Z',
-                                  '2008-09-09 00:00:00Z',
-                                  '2009-01-01 00:00:00X'])
-            expected_s = Series([3, 2, 1], index=idx)
-            tm.assert_series_equal(s.value_counts(), expected_s)
-
-            expected = np_array_datetime64_compat(['2010-01-01 00:00:00Z',
-                                                   '2009-01-01 00:00:00Z',
-                                                   '2008-09-09 00:00:00Z'],
-                                                  dtype='datetime64[ns]')
-            if isinstance(s, Index):
-                tm.assert_index_equal(s.unique(), DatetimeIndex(expected))
-            else:
-                tm.assert_numpy_array_equal(s.unique(), expected)
-
-            assert s.nunique() == 3
-
-            # with NaT
-            s = df['dt'].copy()
-            s = klass([v for v in s.values] + [pd.NaT])
-
-            result = s.value_counts()
-            assert result.index.dtype == 'datetime64[ns]'
-            tm.assert_series_equal(result, expected_s)
-
-            result = s.value_counts(dropna=False)
-            expected_s[pd.NaT] = 1
-            tm.assert_series_equal(result, expected_s)
-
-            unique = s.unique()
-            assert unique.dtype == 'datetime64[ns]'
-
-            # numpy_array_equal cannot compare pd.NaT
-            if isinstance(s, Index):
-                exp_idx = DatetimeIndex(expected.tolist() + [pd.NaT])
-                tm.assert_index_equal(unique, exp_idx)
-            else:
-                tm.assert_numpy_array_equal(unique[:3], expected)
-                assert pd.isna(unique[3])
-
-            assert s.nunique() == 3
-            assert s.nunique(dropna=False) == 4
-
-            # timedelta64[ns]
-            td = df.dt - df.dt + timedelta(1)
-            td = klass(td, name='dt')
-
-            result = td.value_counts()
-            expected_s = Series([6], index=[Timedelta('1day')], name='dt')
-            tm.assert_series_equal(result, expected_s)
-
-            expected = TimedeltaIndex(['1 days'], name='dt')
-            if isinstance(td, Index):
-                tm.assert_index_equal(td.unique(), expected)
-            else:
-                tm.assert_numpy_array_equal(td.unique(), expected.values)
-
-            td2 = timedelta(1) + (df.dt - df.dt)
-            td2 = klass(td2, name='dt')
-            result2 = td2.value_counts()
-            tm.assert_series_equal(result2, expected_s)
+    @pytest.mark.parametrize('klass', [Index, Series])
+    def test_value_counts_datetime64(self, klass):
+
+        # GH 3002, datetime64[ns]
+        # don't test names though
+        txt = "\n".join(['xxyyzz20100101PIE', 'xxyyzz20100101GUM',
+                         'xxyyzz20100101EGG', 'xxyyww20090101EGG',
+                         'foofoo20080909PIE', 'foofoo20080909GUM'])
+        f = StringIO(txt)
+        df = pd.read_fwf(f, widths=[6, 8, 3],
+                         names=["person_id", "dt", "food"],
+                         parse_dates=["dt"])
+
+        s = klass(df['dt'].copy())
+        s.name = None
+
+        idx = pd.to_datetime(['2010-01-01 00:00:00Z',
+                              '2008-09-09 00:00:00Z',
+                              '2009-01-01 00:00:00Z'])
+        expected_s = Series([3, 2, 1], index=idx)
+        tm.assert_series_equal(s.value_counts(), expected_s)
+
+        expected = np_array_datetime64_compat(['2010-01-01 00:00:00Z',
+                                               '2009-01-01 00:00:00Z',
+                                               '2008-09-09 00:00:00Z'],
+                                              dtype='datetime64[ns]')
+        if isinstance(s, Index):
+            tm.assert_index_equal(s.unique(), DatetimeIndex(expected))
+        else:
+            tm.assert_numpy_array_equal(s.unique(), expected)
+
+        assert s.nunique() == 3
+
+        # with NaT
+        s = df['dt'].copy()
+        s = klass([v for v in s.values] + [pd.NaT])
+
+        result = s.value_counts()
+        assert result.index.dtype == 'datetime64[ns]'
+        tm.assert_series_equal(result, expected_s)
+
+        result = s.value_counts(dropna=False)
+        expected_s[pd.NaT] = 1
+        tm.assert_series_equal(result, expected_s)
+
+        unique = s.unique()
+        assert unique.dtype == 'datetime64[ns]'
+
+        # numpy_array_equal cannot compare pd.NaT
+        if isinstance(s, Index):
+            exp_idx = DatetimeIndex(expected.tolist() + [pd.NaT])
+            tm.assert_index_equal(unique, exp_idx)
+        else:
+            tm.assert_numpy_array_equal(unique[:3], expected)
+            assert pd.isna(unique[3])
+
+        assert s.nunique() == 3
+        assert s.nunique(dropna=False) == 4
+
+        # timedelta64[ns]
+        td = df.dt - df.dt + timedelta(1)
+        td = klass(td, name='dt')
+
+        result = td.value_counts()
+        expected_s = Series([6], index=[Timedelta('1day')], name='dt')
+        tm.assert_series_equal(result, expected_s)
+
+        expected = TimedeltaIndex(['1 days'], name='dt')
+        if isinstance(td, Index):
+            tm.assert_index_equal(td.unique(), expected)
+        else:
+            tm.assert_numpy_array_equal(td.unique(), expected.values)
+
+        td2 = timedelta(1) + (df.dt - df.dt)
+        td2 = klass(td2, name='dt')
+        result2 = td2.value_counts()
+        tm.assert_series_equal(result2, expected_s)
 
     def test_factorize(self):
         for orig in self.objs:

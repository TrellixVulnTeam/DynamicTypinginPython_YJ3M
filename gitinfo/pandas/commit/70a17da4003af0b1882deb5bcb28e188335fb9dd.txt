commit 70a17da4003af0b1882deb5bcb28e188335fb9dd
Author: jreback <jeff@reback.net>
Date:   Wed Aug 6 19:14:03 2014 -0400

    COMPAT: capture chain indexing even on single-dtyped

diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index 8ec61496c..25233d970 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -1481,7 +1481,8 @@ which can take the values ``['raise','warn',None]``, where showing a warning is
                            'three', 'two', 'one', 'six'],
                     'c' : np.arange(7)})
 
-   # passed via reference (will stay)
+   # This will show the SettingWithCopyWarning
+   # but the frame values will be set
    dfb['c'][dfb.a.str.startswith('o')] = 42
 
 This however is operating on a copy and will not work.
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 5d4498a79..83110d143 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -1088,11 +1088,10 @@ class NDFrame(PandasObject):
     @property
     def _is_cached(self):
         """ boolean : return if I am cached """
-        cacher = getattr(self, '_cacher', None)
-        return cacher is not None
+        return getattr(self, '_cacher', None) is not None
 
     def _get_cacher(self):
-        """ return my cahcer or None """
+        """ return my cacher or None """
         cacher = getattr(self, '_cacher', None)
         if cacher is not None:
             cacher = cacher[1]()
@@ -1167,13 +1166,18 @@ class NDFrame(PandasObject):
         if so, then force a setitem_copy check
 
         should be called just near setting a value
+
+        will return a boolean if it we are a view and are cached, but a single-dtype
+        meaning that the cacher should be updated following setting
         """
         if self._is_view and self._is_cached:
             ref = self._get_cacher()
             if ref is not None and ref._is_mixed_type:
-                self._check_setitem_copy(stacklevel=5, t='referant', force=True)
+                self._check_setitem_copy(stacklevel=4, t='referant', force=True)
+            return True
         elif self.is_copy:
-            self._check_setitem_copy(stacklevel=5, t='referant')
+            self._check_setitem_copy(stacklevel=4, t='referant')
+        return False
 
     def _check_setitem_copy(self, stacklevel=4, t='setting', force=False):
         """
diff --git a/pandas/core/series.py b/pandas/core/series.py
index f915a7e0e..5a490992c 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -587,61 +587,68 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
             return self.values[indexer]
 
     def __setitem__(self, key, value):
-        try:
-            self._set_with_engine(key, value)
-            return
-        except (SettingWithCopyError):
-            raise
-        except (KeyError, ValueError):
-            values = self.values
-            if (com.is_integer(key)
-                    and not self.index.inferred_type == 'integer'):
 
-                values[key] = value
+        def setitem(key, value):
+            try:
+                self._set_with_engine(key, value)
                 return
-            elif key is Ellipsis:
-                self[:] = value
+            except (SettingWithCopyError):
+                raise
+            except (KeyError, ValueError):
+                values = self.values
+                if (com.is_integer(key)
+                                and not self.index.inferred_type == 'integer'):
+
+                    values[key] = value
+                    return
+                elif key is Ellipsis:
+                    self[:] = value
+                    return
+                elif _is_bool_indexer(key):
+                    pass
+                elif com.is_timedelta64_dtype(self.dtype):
+                    # reassign a null value to iNaT
+                    if isnull(value):
+                        value = tslib.iNaT
+
+                        try:
+                            self.index._engine.set_value(self.values, key, value)
+                            return
+                        except (TypeError):
+                            pass
+
+                self.loc[key] = value
                 return
-            elif _is_bool_indexer(key):
-                pass
-            elif com.is_timedelta64_dtype(self.dtype):
-                # reassign a null value to iNaT
-                if isnull(value):
-                    value = tslib.iNaT
-
-                    try:
-                        self.index._engine.set_value(self.values, key, value)
-                        return
-                    except (TypeError):
-                        pass
-
-            self.loc[key] = value
-            return
 
-        except TypeError as e:
-            if isinstance(key, tuple) and not isinstance(self.index,
-                                                         MultiIndex):
-                raise ValueError("Can only tuple-index with a MultiIndex")
+            except TypeError as e:
+                if isinstance(key, tuple) and not isinstance(self.index,
+                                                             MultiIndex):
+                    raise ValueError("Can only tuple-index with a MultiIndex")
 
-            # python 3 type errors should be raised
-            if 'unorderable' in str(e):  # pragma: no cover
-                raise IndexError(key)
+                # python 3 type errors should be raised
+                if 'unorderable' in str(e):  # pragma: no cover
+                    raise IndexError(key)
 
-        if _is_bool_indexer(key):
-            key = _check_bool_indexer(self.index, key)
-            try:
-                self.where(~key, value, inplace=True)
-                return
-            except (InvalidIndexError):
-                pass
+            if _is_bool_indexer(key):
+                key = _check_bool_indexer(self.index, key)
+                try:
+                    self.where(~key, value, inplace=True)
+                    return
+                except (InvalidIndexError):
+                    pass
+
+            self._set_with(key, value)
 
-        self._set_with(key, value)
+        # do the setitem
+        cacher_needs_updating = self._check_is_chained_assignment_possible()
+        setitem(key, value)
+        if cacher_needs_updating:
+            self._maybe_update_cacher()
 
     def _set_with_engine(self, key, value):
         values = self.values
         try:
             self.index._engine.set_value(values, key, value)
-            self._check_is_chained_assignment_possible()
             return
         except KeyError:
             values[self.index.get_loc(key)] = value
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index 4f76f72b8..89809b47d 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -1278,8 +1278,8 @@ class TestHDFStore(tm.TestCase):
             # data column selection with a string data_column
             df_new = df.copy()
             df_new['string'] = 'foo'
-            df_new['string'][1:4] = np.nan
-            df_new['string'][5:6] = 'bar'
+            df_new.loc[1:4,'string'] = np.nan
+            df_new.loc[5:6,'string'] = 'bar'
             _maybe_remove(store, 'df')
             store.append('df', df_new, data_columns=['string'])
             result = store.select('df', [Term('string=foo')])
@@ -1317,14 +1317,14 @@ class TestHDFStore(tm.TestCase):
         with ensure_clean_store(self.path) as store:
             # multiple data columns
             df_new = df.copy()
-            df_new.loc[:,'A'].iloc[0] = 1.
-            df_new.loc[:,'B'].iloc[0] = -1.
+            df_new.ix[0,'A'] = 1.
+            df_new.ix[0,'B'] = -1.
             df_new['string'] = 'foo'
-            df_new['string'][1:4] = np.nan
-            df_new['string'][5:6] = 'bar'
+            df_new.loc[1:4,'string'] = np.nan
+            df_new.loc[5:6,'string'] = 'bar'
             df_new['string2'] = 'foo'
-            df_new['string2'][2:5] = np.nan
-            df_new['string2'][7:8] = 'bar'
+            df_new.loc[2:5,'string2'] = np.nan
+            df_new.loc[7:8,'string2'] = 'bar'
             _maybe_remove(store, 'df')
             store.append(
                 'df', df_new, data_columns=['A', 'B', 'string', 'string2'])
diff --git a/pandas/tests/test_format.py b/pandas/tests/test_format.py
index 5d785df35..27f5ab3c6 100644
--- a/pandas/tests/test_format.py
+++ b/pandas/tests/test_format.py
@@ -1348,8 +1348,8 @@ class TestDataFrameFormatting(tm.TestCase):
                             'B': tm.makeStringIndex(200)},
                            index=lrange(200))
 
-        biggie['A'][:20] = nan
-        biggie['B'][:20] = nan
+        biggie.loc[:20,'A'] = nan
+        biggie.loc[:20,'B'] = nan
         s = biggie.to_string()
 
         buf = StringIO()
@@ -1597,8 +1597,8 @@ c  10  11  12  13  14\
                             'B': tm.makeStringIndex(200)},
                            index=lrange(200))
 
-        biggie['A'][:20] = nan
-        biggie['B'][:20] = nan
+        biggie.loc[:20,'A'] = nan
+        biggie.loc[:20,'B'] = nan
         s = biggie.to_html()
 
         buf = StringIO()
@@ -1624,8 +1624,8 @@ c  10  11  12  13  14\
                             'B': tm.makeStringIndex(200)},
                            index=lrange(200))
 
-        biggie['A'][:20] = nan
-        biggie['B'][:20] = nan
+        biggie.loc[:20,'A'] = nan
+        biggie.loc[:20,'B'] = nan
         with tm.ensure_clean('test.html') as path:
             biggie.to_html(path)
             with open(path, 'r') as f:
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 7b917afe0..7912debd0 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -4438,8 +4438,8 @@ class TestDataFrame(tm.TestCase, CheckIndexing,
         biggie = DataFrame({'A': randn(200),
                             'B': tm.makeStringIndex(200)},
                            index=lrange(200))
-        biggie['A'][:20] = nan
-        biggie['B'][:20] = nan
+        biggie.loc[:20,'A'] = nan
+        biggie.loc[:20,'B'] = nan
 
         foo = repr(biggie)
 
@@ -7412,19 +7412,19 @@ class TestDataFrame(tm.TestCase, CheckIndexing,
         assert_frame_equal(df,expected)
 
     def test_fillna(self):
-        self.tsframe['A'][:5] = nan
-        self.tsframe['A'][-5:] = nan
+        self.tsframe.ix[:5,'A'] = nan
+        self.tsframe.ix[-5:,'A'] = nan
 
         zero_filled = self.tsframe.fillna(0)
-        self.assertTrue((zero_filled['A'][:5] == 0).all())
+        self.assertTrue((zero_filled.ix[:5,'A'] == 0).all())
 
         padded = self.tsframe.fillna(method='pad')
-        self.assertTrue(np.isnan(padded['A'][:5]).all())
-        self.assertTrue((padded['A'][-5:] == padded['A'][-5]).all())
+        self.assertTrue(np.isnan(padded.ix[:5,'A']).all())
+        self.assertTrue((padded.ix[-5:,'A'] == padded.ix[-5,'A']).all())
 
         # mixed type
-        self.mixed_frame['foo'][5:20] = nan
-        self.mixed_frame['A'][-10:] = nan
+        self.mixed_frame.ix[5:20,'foo'] = nan
+        self.mixed_frame.ix[-10:,'A'] = nan
         result = self.mixed_frame.fillna(value=0)
         result = self.mixed_frame.fillna(method='pad')
 
@@ -7433,7 +7433,7 @@ class TestDataFrame(tm.TestCase, CheckIndexing,
 
         # mixed numeric (but no float16)
         mf = self.mixed_float.reindex(columns=['A','B','D'])
-        mf['A'][-10:] = nan
+        mf.ix[-10:,'A'] = nan
         result = mf.fillna(value=0)
         _check_mixed_float(result, dtype = dict(C = None))
 
@@ -7605,8 +7605,8 @@ class TestDataFrame(tm.TestCase, CheckIndexing,
         self.assertRaises(TypeError, self.tsframe.replace, nan)
 
         # mixed type
-        self.mixed_frame['foo'][5:20] = nan
-        self.mixed_frame['A'][-10:] = nan
+        self.mixed_frame.ix[5:20,'foo'] = nan
+        self.mixed_frame.ix[-10:,'A'] = nan
 
         result = self.mixed_frame.replace(np.nan, 0)
         expected = self.mixed_frame.fillna(value=0)
@@ -8194,8 +8194,8 @@ class TestDataFrame(tm.TestCase, CheckIndexing,
         assert_series_equal(expec, res)
 
     def test_replace_mixed(self):
-        self.mixed_frame['foo'][5:20] = nan
-        self.mixed_frame['A'][-10:] = nan
+        self.mixed_frame.ix[5:20,'foo'] = nan
+        self.mixed_frame.ix[-10:,'A'] = nan
 
         result = self.mixed_frame.replace(np.nan, -18)
         expected = self.mixed_frame.fillna(value=-18)
@@ -11717,11 +11717,11 @@ class TestDataFrame(tm.TestCase, CheckIndexing,
         self.assertNotIn('foo', renamed)
 
     def test_fill_corner(self):
-        self.mixed_frame['foo'][5:20] = nan
-        self.mixed_frame['A'][-10:] = nan
+        self.mixed_frame.ix[5:20,'foo'] = nan
+        self.mixed_frame.ix[-10:,'A'] = nan
 
         filled = self.mixed_frame.fillna(value=0)
-        self.assertTrue((filled['foo'][5:20] == 0).all())
+        self.assertTrue((filled.ix[5:20,'foo'] == 0).all())
         del self.mixed_frame['foo']
 
         empty_float = self.frame.reindex(columns=[])
@@ -12716,6 +12716,7 @@ starting,ending,measure
                 self.assertTrue(r1.all())
 
     def test_strange_column_corruption_issue(self):
+
         df = DataFrame(index=[0, 1])
         df[0] = nan
         wasCol = {}
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index 3def1b74a..6f39750de 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -1664,7 +1664,7 @@ class TestGroupBy(tm.TestCase):
                 'B': ['A', 'B'] * 6,
                 'C': np.random.randn(12)}
         df = DataFrame(data)
-        df['C'][2:10:2] = nan
+        df.loc[2:10:2,'C'] = nan
 
         def _testit(op):
             # single column
diff --git a/pandas/tests/test_indexing.py b/pandas/tests/test_indexing.py
index cd610abcc..3552c7590 100644
--- a/pandas/tests/test_indexing.py
+++ b/pandas/tests/test_indexing.py
@@ -3079,6 +3079,7 @@ class TestIndexing(tm.TestCase):
 
         # GH 7084
         # not updating cache on series setting with slices
+        expected = DataFrame({'A': [600, 600, 600]}, index=date_range('5/7/2014', '5/9/2014'))
         out = DataFrame({'A': [0, 0, 0]}, index=date_range('5/7/2014', '5/9/2014'))
         df = DataFrame({'C': ['A', 'A', 'A'], 'D': [100, 200, 300]})
 
@@ -3086,9 +3087,18 @@ class TestIndexing(tm.TestCase):
         six = Timestamp('5/7/2014')
         eix = Timestamp('5/9/2014')
         for ix, row in df.iterrows():
-            out[row['C']][six:eix] = out[row['C']][six:eix] + row['D']
+            out.loc[six:eix,row['C']] = out.loc[six:eix,row['C']] + row['D']
+
+        assert_frame_equal(out, expected)
+        assert_series_equal(out['A'], expected['A'])
+
+        # try via a chain indexing
+        # this actually works
+        out = DataFrame({'A': [0, 0, 0]}, index=date_range('5/7/2014', '5/9/2014'))
+        for ix, row in df.iterrows():
+            v = out[row['C']][six:eix] + row['D']
+            out[row['C']][six:eix] = v
 
-        expected = DataFrame({'A': [600, 600, 600]}, index=date_range('5/7/2014', '5/9/2014'))
         assert_frame_equal(out, expected)
         assert_series_equal(out['A'], expected['A'])
 
@@ -3176,8 +3186,6 @@ class TestIndexing(tm.TestCase):
             indexer = df.a.str.startswith('o')
             df[indexer]['c'] = 42
         self.assertRaises(com.SettingWithCopyError, f)
-        df['c'][df.a.str.startswith('o')] = 42
-        assert_frame_equal(df,expected)
 
         expected = DataFrame({'A':[111,'bbb','ccc'],'B':[1,2,3]})
         df = DataFrame({'A':['aaa','bbb','ccc'],'B':[1,2,3]})
@@ -3187,6 +3195,8 @@ class TestIndexing(tm.TestCase):
         def f():
             df.loc[0]['A'] = 111
         self.assertRaises(com.SettingWithCopyError, f)
+
+        df.loc[0,'A'] = 111
         assert_frame_equal(df,expected)
 
         # make sure that is_copy is picked up reconstruction
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index df2f27034..919f30ef2 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -930,8 +930,8 @@ class TestMergeMulti(tm.TestCase):
 
         expected = left.copy()
         expected['v2'] = np.nan
-        expected['v2'][(expected.k1 == 2) & (expected.k2 == 'bar')] = 5
-        expected['v2'][(expected.k1 == 1) & (expected.k2 == 'foo')] = 7
+        expected.loc[(expected.k1 == 2) & (expected.k2 == 'bar'),'v2'] = 5
+        expected.loc[(expected.k1 == 1) & (expected.k2 == 'foo'),'v2'] = 7
 
         tm.assert_frame_equal(result, expected)
 
@@ -948,8 +948,8 @@ class TestMergeMulti(tm.TestCase):
 
         expected = left.copy()
         expected['v2'] = np.nan
-        expected['v2'][(expected.k1 == 2) & (expected.k2 == 'bar')] = 5
-        expected['v2'][(expected.k1 == 1) & (expected.k2 == 'foo')] = 7
+        expected.loc[(expected.k1 == 2) & (expected.k2 == 'bar'),'v2'] = 5
+        expected.loc[(expected.k1 == 1) & (expected.k2 == 'foo'),'v2'] = 7
 
         tm.assert_frame_equal(result, expected)
 
@@ -976,8 +976,8 @@ class TestMergeMulti(tm.TestCase):
             if dtype2.kind == 'i':
                 dtype2 = np.dtype('float64')
             expected['v2'] = np.array(np.nan,dtype=dtype2)
-            expected['v2'][(expected.k1 == 2) & (expected.k2 == 'bar')] = 5
-            expected['v2'][(expected.k1 == 1) & (expected.k2 == 'foo')] = 7
+            expected.loc[(expected.k1 == 2) & (expected.k2 == 'bar'),'v2'] = 5
+            expected.loc[(expected.k1 == 1) & (expected.k2 == 'foo'),'v2'] = 7
 
             tm.assert_frame_equal(result, expected)
 
@@ -1683,7 +1683,7 @@ class TestConcatenate(tm.TestCase):
 
         expected = df.ix[:, ['a', 'b', 'c', 'd', 'foo']]
         expected['foo'] = expected['foo'].astype('O')
-        expected['foo'][:5] = 'bar'
+        expected.loc[0:4,'foo'] = 'bar'
 
         tm.assert_frame_equal(concatted, expected)
 

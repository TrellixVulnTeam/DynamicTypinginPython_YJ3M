commit 965b8649141a7ee0cdaadcf2d14bd84965456f93
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Jun 13 18:23:15 2012 -0400

    BUG: rename Factor->Categorical, make .levels a property to enable assignment / type checking, test labels argument and fix bugs. close #1460 and #1461

diff --git a/pandas/core/api.py b/pandas/core/api.py
index 194108f72..fc81161cb 100644
--- a/pandas/core/api.py
+++ b/pandas/core/api.py
@@ -6,7 +6,7 @@ import numpy as np
 from pandas.core.algorithms import factorize, match, unique, value_counts
 
 from pandas.core.common import isnull, notnull, save, load
-from pandas.core.factor import Factor
+from pandas.core.factor import Categorical, Factor
 from pandas.core.format import (set_printoptions, reset_printoptions,
                                 set_eng_float_format)
 from pandas.core.index import Index, Int64Index, MultiIndex
diff --git a/pandas/core/factor.py b/pandas/core/factor.py
index 6d889a8a0..6252cb4fd 100644
--- a/pandas/core/factor.py
+++ b/pandas/core/factor.py
@@ -6,9 +6,9 @@ from pandas.core.algorithms import factorize
 import pandas.core.common as com
 
 
-def _factor_compare_op(op):
+def _cat_compare_op(op):
     def f(self, other):
-        if isinstance(other, (Factor, np.ndarray)):
+        if isinstance(other, (Categorical, np.ndarray)):
             values = np.asarray(self)
             f = getattr(values, op)
             return f(np.asarray(other))
@@ -23,7 +23,7 @@ def _factor_compare_op(op):
 
     return f
 
-class Factor(object):
+class Categorical(object):
     """
     Represents a categorical variable in classic R / S-plus fashion
 
@@ -41,12 +41,6 @@ class Factor(object):
       * levels : ndarray
     """
     def __init__(self, labels, levels, name=None):
-        from pandas.core.index import _ensure_index
-
-        levels = _ensure_index(levels)
-        if not levels.is_unique:
-            raise ValueError('Factor levels must be unique')
-
         self.labels = labels
         self.levels = levels
         self.name = name
@@ -58,16 +52,28 @@ class Factor(object):
         except TypeError:
             labels, levels, _ = factorize(data, sort=False)
 
-        return Factor(labels, levels)
+        return Categorical(labels, levels)
+
+    _levels = None
+    def _set_levels(self, levels):
+        from pandas.core.index import _ensure_index
+
+        levels = _ensure_index(levels)
+        if not levels.is_unique:
+            raise ValueError('Categorical levels must be unique')
+        self._levels = levels
+
+    def _get_levels(self):
+        return self._levels
 
-    levels = None
+    levels = property(fget=_get_levels, fset=_set_levels)
 
-    __eq__ = _factor_compare_op('__eq__')
-    __ne__ = _factor_compare_op('__ne__')
-    __lt__ = _factor_compare_op('__lt__')
-    __gt__ = _factor_compare_op('__gt__')
-    __le__ = _factor_compare_op('__le__')
-    __ge__ = _factor_compare_op('__ge__')
+    __eq__ = _cat_compare_op('__eq__')
+    __ne__ = _cat_compare_op('__ne__')
+    __lt__ = _cat_compare_op('__lt__')
+    __gt__ = _cat_compare_op('__gt__')
+    __le__ = _cat_compare_op('__le__')
+    __ge__ = _cat_compare_op('__ge__')
 
     def __array__(self, dtype=None):
         return com.take_1d(self.levels, self.labels)
@@ -76,7 +82,7 @@ class Factor(object):
         return len(self.labels)
 
     def __repr__(self):
-        temp = 'Factor:%s\n%s\nLevels (%d): %s'
+        temp = 'Categorical: %s\n%s\nLevels (%d): %s'
         values = np.asarray(self)
         return temp % ('' if self.name is None else self.name,
                        repr(values), len(self.levels), self.levels)
@@ -89,22 +95,24 @@ class Factor(object):
             else:
                 return self.levels[i]
         else:
-            return Factor(self.labels[key], self.levels)
+            return Categorical(self.labels[key], self.levels)
 
     def equals(self, other):
         """
-        Returns True if factors are equal
+        Returns True if categorical arrays are equal
 
         Parameters
         ----------
-        other : Factor
+        other : Categorical
 
         Returns
         -------
         are_equal : boolean
         """
-        if not isinstance(other, Factor):
+        if not isinstance(other, Categorical):
             return False
 
         return (self.levels.equals(other.levels) and
                 np.array_equal(self.labels, other.labels))
+
+Factor = Categorical
diff --git a/pandas/tools/tests/test_tile.py b/pandas/tools/tests/test_tile.py
index 30c064e52..cdfc731a1 100644
--- a/pandas/tools/tests/test_tile.py
+++ b/pandas/tools/tests/test_tile.py
@@ -125,6 +125,18 @@ class TestCut(unittest.TestCase):
         arr = np.where(arr < -1, 0, arr)
         self.assertRaises(ValueError, cut, arr, [-1, 0, 1])
 
+    def test_cut_pass_labels(self):
+        arr = [50, 5, 10, 15, 20, 30, 70]
+        bins = [0, 25, 50, 100]
+        labels = ['Small', 'Medium', 'Large']
+
+        result = cut(arr, bins, labels=labels)
+
+        exp = cut(arr, bins)
+        exp.levels = labels
+
+        self.assert_(result.equals(exp))
+
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)
diff --git a/pandas/tools/tile.py b/pandas/tools/tile.py
index 8635a4177..8ffa9da4a 100644
--- a/pandas/tools/tile.py
+++ b/pandas/tools/tile.py
@@ -163,18 +163,18 @@ def _bins_to_cuts(x, bins, right=True, labels=None, retbins=False,
 
     if labels is not False:
         if labels is None:
-            labels = bins
-        else:
-            if len(labels) != len(bins):
-                raise ValueError('labels must be same length as bins')
-
-        fmt = lambda v: _format_label(v, precision=precision)
-        if right:
-            levels = ['(%s, %s]' % (fmt(a), fmt(b))
-                       for a, b in zip(labels, labels[1:])]
+            fmt = lambda v: _format_label(v, precision=precision)
+            if right:
+                levels = ['(%s, %s]' % (fmt(a), fmt(b))
+                           for a, b in zip(bins, bins[1:])]
+            else:
+                levels = ['[%s, %s)' % (fmt(a), fmt(b))
+                           for a, b in zip(bins, bins[1:])]
         else:
-            levels = ['[%s, %s)' % (fmt(a), fmt(b))
-                       for a, b in zip(labels, labels[1:])]
+            if len(labels) != len(bins) - 1:
+                raise ValueError('Bin labels must be one fewer than '
+                                 'the number of bin edges')
+            levels = labels
 
         levels = np.asarray(levels, dtype=object)
 

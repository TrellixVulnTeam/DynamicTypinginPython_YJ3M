commit b84efc13d56bb0652a7af1c3bad41aad65335da7
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Jan 24 12:25:16 2012 -0500

    BUG: catch zero division errors in nanops from object dtype arrays in all NA case, GH #676

diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index c0b4b9430..63ad11b74 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -3,6 +3,7 @@ import sys
 import numpy as np
 
 from pandas.core.common import isnull, notnull
+import pandas.core.common as com
 import pandas._tseries as lib
 
 try:
@@ -18,7 +19,7 @@ def _bottleneck_switch(bn_name, alt, **kwargs):
         bn_func = None
     def f(values, axis=None, skipna=True):
         try:
-            if _USE_BOTTLENECK and skipna:
+            if _USE_BOTTLENECK and skipna and values.dtype != np.object_:
                 result = bn_func(values, axis=axis, **kwargs)
                 # prefer to treat inf/-inf as NA
                 if _has_infs(result):
@@ -62,7 +63,7 @@ def _nanmean(values, axis=None, skipna=True):
         values = values.copy()
         np.putmask(values, mask, 0)
 
-    the_sum = values.sum(axis)
+    the_sum = _ensure_numeric(values.sum(axis))
     count = _get_counts(mask, axis)
 
     if axis is not None:
@@ -101,8 +102,8 @@ def _nanvar(values, axis=None, skipna=True, ddof=1):
         values = values.copy()
         np.putmask(values, mask, 0)
 
-    X = values.sum(axis)
-    XX = (values ** 2).sum(axis)
+    X = _ensure_numeric(values.sum(axis))
+    XX = _ensure_numeric((values ** 2).sum(axis))
     return (XX - X ** 2 / count) / (count - ddof)
 
 def _nanmin(values, axis=None, skipna=True):
@@ -307,6 +308,18 @@ def nancov(a, b):
 
     return np.cov(a, b)[0, 1]
 
+def _ensure_numeric(x):
+    if isinstance(x, np.ndarray):
+        if x.dtype == np.object_:
+            x = x.astype(np.float64)
+    elif not (com.is_float(x) or com.is_integer(x)):
+        try:
+            x = float(x)
+        except Exception:
+            raise TypeError('Could not convert %s to numeric' % str(x))
+
+    return x
+
 # NA-friendly array comparisons
 
 import operator
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 6d606ace7..98f4e033f 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -3750,15 +3750,20 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
             'c': [0.00031111847529610595, 0.0014902627951905339,
                   -0.00094099200035979691]
         }
-        df = DataFrame(data, index=['foo', 'bar', 'baz'],
+        df1 = DataFrame(data, index=['foo', 'bar', 'baz'],
                        dtype='O')
         methods = ['sum', 'mean', 'prod', 'var', 'std', 'skew', 'min', 'max']
 
-        for meth in methods:
-            self.assert_(df.values.dtype == np.object_)
-            result = getattr(df, meth)(1)
-            expected = getattr(df.astype('f8'), meth)(1)
-            assert_series_equal(result, expected)
+        # GH #676
+        df2 = DataFrame({0: [np.nan, 2], 1: [np.nan, 3],
+                        2: [np.nan, 4]}, dtype=object)
+
+        for df in [df1, df2]:
+            for meth in methods:
+                self.assert_(df.values.dtype == np.object_)
+                result = getattr(df, meth)(1)
+                expected = getattr(df.astype('f8'), meth)(1)
+                assert_series_equal(result, expected)
 
     def test_mean(self):
         self._check_stat_op('mean', np.mean)

commit 90bb1aa4840199d6bba5a76b438aff960f4b9497
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sun Mar 8 09:11:21 2020 -0700

    API: allow step!=1 slice with IntervalIndex (#31658)
    
    * Allow step!=1 in slicing Series with IntervalIndex
    
    * Whatsnew
    
    * doc suggestion
    
    * test for interval step
    
    * remove commented-out
    
    * reword whatsnew
    
    * disallow label-based with step!=1
    
    * black fixup
    
    * update error message
    
    * typo fixup

diff --git a/doc/source/whatsnew/v1.1.0.rst b/doc/source/whatsnew/v1.1.0.rst
index 58b0d0e5b..d644a995a 100644
--- a/doc/source/whatsnew/v1.1.0.rst
+++ b/doc/source/whatsnew/v1.1.0.rst
@@ -67,6 +67,7 @@ Other enhancements
 - When writing directly to a sqlite connection :func:`to_sql` now supports the ``multi`` method (:issue:`29921`)
 - `OptionError` is now exposed in `pandas.errors` (:issue:`27553`)
 - :func:`timedelta_range` will now infer a frequency when passed ``start``, ``stop``, and ``periods`` (:issue:`32377`)
+- Positional slicing on a :class:`IntervalIndex` now supports slices with ``step > 1`` (:issue:`31658`)
 -
 
 .. ---------------------------------------------------------------------------
@@ -248,7 +249,6 @@ Strings
 
 Interval
 ^^^^^^^^
-
 -
 -
 
diff --git a/pandas/core/indexers.py b/pandas/core/indexers.py
index 3858e7503..71fd5b6aa 100644
--- a/pandas/core/indexers.py
+++ b/pandas/core/indexers.py
@@ -11,6 +11,7 @@ from pandas.core.dtypes.common import (
     is_array_like,
     is_bool_dtype,
     is_extension_array_dtype,
+    is_integer,
     is_integer_dtype,
     is_list_like,
 )
@@ -20,6 +21,34 @@ from pandas.core.dtypes.generic import ABCIndexClass, ABCSeries
 # Indexer Identification
 
 
+def is_valid_positional_slice(slc: slice) -> bool:
+    """
+    Check if a slice object can be interpreted as a positional indexer.
+
+    Parameters
+    ----------
+    slc : slice
+
+    Returns
+    -------
+    bool
+
+    Notes
+    -----
+    A valid positional slice may also be interpreted as a label-based slice
+    depending on the index being sliced.
+    """
+
+    def is_int_or_none(val):
+        return val is None or is_integer(val)
+
+    return (
+        is_int_or_none(slc.start)
+        and is_int_or_none(slc.stop)
+        and is_int_or_none(slc.step)
+    )
+
+
 def is_list_like_indexer(key) -> bool:
     """
     Check if we have a list-like indexer that is *not* a NamedTuple.
diff --git a/pandas/core/indexes/interval.py b/pandas/core/indexes/interval.py
index 6968837fb..efdaf5a33 100644
--- a/pandas/core/indexes/interval.py
+++ b/pandas/core/indexes/interval.py
@@ -39,6 +39,7 @@ from pandas.core.dtypes.missing import isna
 from pandas.core.algorithms import take_1d
 from pandas.core.arrays.interval import IntervalArray, _interval_shared_docs
 import pandas.core.common as com
+from pandas.core.indexers import is_valid_positional_slice
 import pandas.core.indexes.base as ibase
 from pandas.core.indexes.base import (
     Index,
@@ -866,7 +867,16 @@ class IntervalIndex(IntervalMixin, ExtensionIndex):
 
     def _convert_slice_indexer(self, key: slice, kind: str):
         if not (key.step is None or key.step == 1):
-            raise ValueError("cannot support not-default step in a slice")
+            # GH#31658 if label-based, we require step == 1,
+            #  if positional, we disallow float start/stop
+            msg = "label-based slicing with step!=1 is not supported for IntervalIndex"
+            if kind == "loc":
+                raise ValueError(msg)
+            elif kind == "getitem":
+                if not is_valid_positional_slice(key):
+                    # i.e. this cannot be interpreted as a positional slice
+                    raise ValueError(msg)
+
         return super()._convert_slice_indexer(key, kind)
 
     @Appender(Index.where.__doc__)
diff --git a/pandas/tests/indexes/test_base.py b/pandas/tests/indexes/test_base.py
index 0c4a79064..73af98c16 100644
--- a/pandas/tests/indexes/test_base.py
+++ b/pandas/tests/indexes/test_base.py
@@ -2598,7 +2598,8 @@ def test_convert_almost_null_slice(indices):
     key = slice(None, None, "foo")
 
     if isinstance(idx, pd.IntervalIndex):
-        with pytest.raises(ValueError, match="cannot support not-default step"):
+        msg = "label-based slicing with step!=1 is not supported for IntervalIndex"
+        with pytest.raises(ValueError, match=msg):
             idx._convert_slice_indexer(key, "loc")
     else:
         msg = "'>=' not supported between instances of 'str' and 'int'"
diff --git a/pandas/tests/indexing/interval/test_interval_new.py b/pandas/tests/indexing/interval/test_interval_new.py
index 43036fbbd..03c303477 100644
--- a/pandas/tests/indexing/interval/test_interval_new.py
+++ b/pandas/tests/indexing/interval/test_interval_new.py
@@ -128,9 +128,6 @@ class TestIntervalIndex:
         with pytest.raises(NotImplementedError, match=msg):
             s[Interval(3, 4, closed="left") :]
 
-        # TODO with non-existing intervals ?
-        # s.loc[Interval(-1, 0):Interval(2, 3)]
-
         # slice of scalar
 
         expected = s.iloc[:3]
@@ -143,9 +140,32 @@ class TestIntervalIndex:
         tm.assert_series_equal(expected, s[:2.5])
         tm.assert_series_equal(expected, s[0.1:2.5])
 
-        # slice of scalar with step != 1
-        with pytest.raises(ValueError):
-            s[0:4:2]
+    def test_slice_step_ne1(self):
+        # GH#31658 slice of scalar with step != 1
+        s = self.s
+        expected = s.iloc[0:4:2]
+
+        result = s[0:4:2]
+        tm.assert_series_equal(result, expected)
+
+        result2 = s[0:4][::2]
+        tm.assert_series_equal(result2, expected)
+
+    def test_slice_float_start_stop(self):
+        # GH#31658 slicing with integers is positional, with floats is not
+        #  supported
+        ser = Series(np.arange(5), IntervalIndex.from_breaks(np.arange(6)))
+
+        msg = "label-based slicing with step!=1 is not supported for IntervalIndex"
+        with pytest.raises(ValueError, match=msg):
+            ser[1.5:9.5:2]
+
+    def test_slice_interval_step(self):
+        # GH#31658 allows for integer step!=1, not Interval step
+        s = self.s
+        msg = "label-based slicing with step!=1 is not supported for IntervalIndex"
+        with pytest.raises(ValueError, match=msg):
+            s[0 : 4 : Interval(0, 1)]
 
     def test_loc_with_overlap(self):
 

commit 388d22c3d1e6804dbc1390e41db1d7277b1d8c66
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Thu Jun 20 19:01:59 2019 -0700

    BUG: avoid overflow in Bday generate_range, closes #24252 (#26651)

diff --git a/doc/source/whatsnew/v0.25.0.rst b/doc/source/whatsnew/v0.25.0.rst
index 8767a0c2d..a6b74865f 100644
--- a/doc/source/whatsnew/v0.25.0.rst
+++ b/doc/source/whatsnew/v0.25.0.rst
@@ -600,6 +600,7 @@ Datetimelike
 - Bug in :meth:`isin` for datetimelike indexes; :class:`DatetimeIndex`, :class:`TimedeltaIndex` and :class:`PeriodIndex` where the ``levels`` parameter was ignored. (:issue:`26675`)
 - Bug in :func:`to_datetime` which raises ``TypeError`` for ``format='%Y%m%d'`` when called for invalid integer dates with length >= 6 digits with ``errors='ignore'``
 - Bug when comparing a :class:`PeriodIndex` against a zero-dimensional numpy array (:issue:`26689`)
+- Bug in :func:`date_range` with unnecessary ``OverflowError`` being raised for very large or very small dates (:issue:`26651`)
 
 Timedelta
 ^^^^^^^^^
diff --git a/pandas/_libs/tslibs/conversion.pyx b/pandas/_libs/tslibs/conversion.pyx
index 04bb44544..0a3f4ed3c 100644
--- a/pandas/_libs/tslibs/conversion.pyx
+++ b/pandas/_libs/tslibs/conversion.pyx
@@ -275,6 +275,10 @@ cdef convert_to_tsobject(object ts, object tz, object unit,
         - iso8601 string object
         - python datetime object
         - another timestamp object
+
+    Raises
+    ------
+    OutOfBoundsDatetime : ts cannot be converted within implementation bounds
     """
     cdef:
         _TSObject obj
@@ -294,6 +298,11 @@ cdef convert_to_tsobject(object ts, object tz, object unit,
         if obj.value != NPY_NAT:
             dt64_to_dtstruct(obj.value, &obj.dts)
     elif is_integer_object(ts):
+        try:
+            ts = <int64_t>ts
+        except OverflowError:
+            # GH#26651 re-raise as OutOfBoundsDatetime
+            raise OutOfBoundsDatetime(ts)
         if ts == NPY_NAT:
             obj.value = NPY_NAT
         else:
diff --git a/pandas/tests/arithmetic/test_timedelta64.py b/pandas/tests/arithmetic/test_timedelta64.py
index ead9876e7..2dff9a608 100644
--- a/pandas/tests/arithmetic/test_timedelta64.py
+++ b/pandas/tests/arithmetic/test_timedelta64.py
@@ -5,7 +5,8 @@ from datetime import datetime, timedelta
 import numpy as np
 import pytest
 
-from pandas.errors import NullFrequencyError, PerformanceWarning
+from pandas.errors import (
+    NullFrequencyError, OutOfBoundsDatetime, PerformanceWarning)
 
 import pandas as pd
 from pandas import (
@@ -479,10 +480,10 @@ class TestAddSubNaTMasking:
 
     def test_tdi_add_overflow(self):
         # See GH#14068
-        msg = "too (big|large) to convert"
-        with pytest.raises(OverflowError, match=msg):
+        # preliminary test scalar analogue of vectorized tests below
+        with pytest.raises(OutOfBoundsDatetime):
             pd.to_timedelta(106580, 'D') + Timestamp('2000')
-        with pytest.raises(OverflowError, match=msg):
+        with pytest.raises(OutOfBoundsDatetime):
             Timestamp('2000') + pd.to_timedelta(106580, 'D')
 
         _NaT = int(pd.NaT) + 1
diff --git a/pandas/tests/indexes/datetimes/test_date_range.py b/pandas/tests/indexes/datetimes/test_date_range.py
index 7f03793d8..1545cc52e 100644
--- a/pandas/tests/indexes/datetimes/test_date_range.py
+++ b/pandas/tests/indexes/datetimes/test_date_range.py
@@ -740,6 +740,19 @@ class TestBusinessDateRange:
         expected = pd.date_range(bday_start, bday_end, freq='D')
         tm.assert_index_equal(result, expected)
 
+    def test_bday_near_overflow(self):
+        # GH#24252 avoid doing unnecessary addition that _would_ overflow
+        start = pd.Timestamp.max.floor("D").to_pydatetime()
+        rng = pd.date_range(start, end=None, periods=1, freq='B')
+        expected = pd.DatetimeIndex([start], freq='B')
+        tm.assert_index_equal(rng, expected)
+
+    def test_bday_overflow_error(self):
+        # GH#24252 check that we get OutOfBoundsDatetime and not OverflowError
+        start = pd.Timestamp.max.floor("D").to_pydatetime()
+        with pytest.raises(OutOfBoundsDatetime):
+            pd.date_range(start, periods=2, freq='B')
+
 
 class TestCustomDateRange:
 
diff --git a/pandas/tests/scalar/timestamp/test_timestamp.py b/pandas/tests/scalar/timestamp/test_timestamp.py
index 773b4e6f2..4b6b0dac9 100644
--- a/pandas/tests/scalar/timestamp/test_timestamp.py
+++ b/pandas/tests/scalar/timestamp/test_timestamp.py
@@ -463,6 +463,13 @@ class TestTimestampConstructors:
         with pytest.raises(ValueError):
             Timestamp('2010-10-10 12:59:59.999999999', **kwarg)
 
+    def test_out_of_bounds_integer_value(self):
+        # GH#26651 check that we raise OutOfBoundsDatetime, not OverflowError
+        with pytest.raises(OutOfBoundsDatetime):
+            Timestamp(Timestamp.max.value * 2)
+        with pytest.raises(OutOfBoundsDatetime):
+            Timestamp(Timestamp.min.value * 2)
+
     def test_out_of_bounds_value(self):
         one_us = np.timedelta64(1).astype('timedelta64[us]')
 
diff --git a/pandas/tests/tseries/offsets/test_offsets.py b/pandas/tests/tseries/offsets/test_offsets.py
index 8c8a2f75c..a1ad792e5 100644
--- a/pandas/tests/tseries/offsets/test_offsets.py
+++ b/pandas/tests/tseries/offsets/test_offsets.py
@@ -115,7 +115,7 @@ class Base:
             assert t.tzinfo == result.tzinfo
 
         except OutOfBoundsDatetime:
-            raise
+            pass
         except (ValueError, KeyError):
             # we are creating an invalid offset
             # so ignore
diff --git a/pandas/tseries/offsets.py b/pandas/tseries/offsets.py
index c1764b384..00837d36d 100644
--- a/pandas/tseries/offsets.py
+++ b/pandas/tseries/offsets.py
@@ -97,6 +97,8 @@ def apply_wraps(func):
             if tz is not None and result.tzinfo is None:
                 result = conversion.localize_pydatetime(result, tz)
 
+            result = Timestamp(result)
+
         return result
     return wrapper
 
@@ -2330,7 +2332,7 @@ class Tick(liboffsets._Tick, SingleConstructorOffset):
             # an exception, when we call using the + operator,
             # we directly call the known method
             result = other.__add__(self)
-            if result == NotImplemented:
+            if result is NotImplemented:
                 raise OverflowError
             return result
         elif isinstance(other, (datetime, np.datetime64, date)):
@@ -2467,6 +2469,11 @@ def generate_range(start=None, end=None, periods=None, offset=BDay()):
         while cur <= end:
             yield cur
 
+            if cur == end:
+                # GH#24252 avoid overflows by not performing the addition
+                # in offset.apply unless we have to
+                break
+
             # faster than cur + offset
             next_date = offset.apply(cur)
             if next_date <= cur:
@@ -2477,6 +2484,11 @@ def generate_range(start=None, end=None, periods=None, offset=BDay()):
         while cur >= end:
             yield cur
 
+            if cur == end:
+                # GH#24252 avoid overflows by not performing the addition
+                # in offset.apply unless we have to
+                break
+
             # faster than cur + offset
             next_date = offset.apply(cur)
             if next_date >= cur:

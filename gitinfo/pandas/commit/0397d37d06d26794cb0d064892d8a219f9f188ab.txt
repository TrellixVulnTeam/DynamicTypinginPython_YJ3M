commit 0397d37d06d26794cb0d064892d8a219f9f188ab
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Sep 8 21:47:30 2011 -0400

    ENH: extensive indexing.py refactoring and implemented fancy/advanced indexing
    fro Panel. address GH #118

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index f0e07dfff..52cd0aa62 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -25,7 +25,7 @@ from pandas.core.common import (isnull, notnull, PandasError, _ensure_index,
 from pandas.core.daterange import DateRange
 from pandas.core.generic import AxisProperty, NDFrame
 from pandas.core.index import Index, MultiIndex, NULL_INDEX
-from pandas.core.indexing import _DataFrameIndexer, _maybe_droplevels
+from pandas.core.indexing import _NDFrameIndexer, _maybe_droplevels
 from pandas.core.internals import BlockManager, make_block, form_blocks
 from pandas.core.series import Series, _is_bool_indexer
 from pandas.util.decorators import deprecate
@@ -244,7 +244,7 @@ class DataFrame(NDFrame):
     @property
     def ix(self):
         if self._ix is None:
-            self._ix = _DataFrameIndexer(self)
+            self._ix = _NDFrameIndexer(self)
 
         return self._ix
 
@@ -948,19 +948,30 @@ class DataFrame(NDFrame):
     def _series(self):
         return self._data.get_series_dict()
 
-    def xs(self, key, copy=True):
+    def xs(self, key, axis=0, copy=True):
         """
-        Returns a row (cross-section) from the DataFrame as a Series object
+        Returns a cross-section (row or column) from the DataFrame as a Series
+        object. Defaults to returning a row (axis 0)
 
         Parameters
         ----------
         key : object
             Some label contained in the index, or partially in a MultiIndex
+        axis : int, default 0
+            Axis to retrieve cross-section on
+        copy : boolean, default True
+            Whether to make a copy of the data
 
         Returns
         -------
         xs : Series
         """
+        if axis == 1:
+            data = self[key]
+            if copy:
+                data = data.copy()
+            return data
+
         self._consolidate_inplace()
         new_data = self._data.xs(key, axis=1, copy=copy)
         if new_data.ndim == 1:
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index a010c0813..48f8d90af 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -1,142 +1,163 @@
+# pylint: disable=W0223
+
 from pandas.core.common import _asarray_tuplesafe
 from pandas.core.index import Index, MultiIndex
 
 import numpy as np
 
-class _SeriesIndexer(object):
-    """
-    Class to support fancy indexing, potentially using labels
+# "null slice"
+_NS = slice(None, None)
 
-    Notes
-    -----
-    Indexing based on labels is INCLUSIVE
-    Slicing uses PYTHON SEMANTICS (endpoint is excluded)
 
-    If Index contains int labels, these will be used rather than the locations,
-    so be very careful (ambiguous).
+class IndexingError(Exception):
+    pass
 
-    Examples
-    --------
-    >>> ts.ix[5:10] # equivalent to ts[5:10]
-    >>> ts.ix[[date1, date2, date3]]
-    >>> ts.ix[date1:date2] = 0
-    """
-    def __init__(self, series):
-        self.series = series
+
+class AmbiguousIndexError(Exception):
+    pass
+
+
+class _NDFrameIndexer(object):
+
+    def __init__(self, obj):
+        self.obj = obj
+        self.ndim = obj.ndim
 
     def __getitem__(self, key):
-        op = self._fancy_index(key, operation='get')
-        return op()
+        if isinstance(key, tuple):
+            return self._getitem_tuple(key)
+        else:
+            return self._getitem_axis(key, axis=0)
+
+    def _getitem_xs(self, idx, axis=0):
+        try:
+            return self.obj.xs(idx, axis=axis, copy=False)
+        except Exception:
+            return self.obj.xs(idx, axis=axis, copy=True)
 
     def __setitem__(self, key, value):
-        op = self._fancy_index(key, value, operation='set')
-        op()
+        # also has the side effect of consolidating in-place
+        if self.obj._is_mixed_type:
+            raise IndexingError('setting on mixed-type frames not '
+                                'yet supported')
 
-    def _fancy_index(self, key, value=None, operation='get'):
-        from pandas.core.series import Series
+        if isinstance(key, tuple):
+            if len(key) > self.ndim:
+                raise IndexingError('only tuples of length <= %d supported',
+                                    self.ndim)
+
+            keyidx = []
+            for i, k in enumerate(key):
+                idx = self._convert_to_indexer(k, axis=i)
+                keyidx.append(idx)
+            indexer = _maybe_convert_ix(*keyidx)
+        else:
+            indexer = self._convert_to_indexer(key)
 
-        # going to great lengths to avoid code dup
-        series = self.series
+        self.obj.values[indexer] = value
 
-        if operation == 'get':
-            def do_default():
-                return series[key]
+    def _getitem_tuple(self, tup):
+        # a bit kludgy
+        if isinstance(self.obj._get_axis(0), MultiIndex):
+            try:
+                return self._getitem_xs(tup, axis=0)
+            except (KeyError, TypeError):
+                pass
 
-            def do_list_like():
-                if isinstance(series.index, MultiIndex):
-                    try:
-                        return series[key]
-                    except (KeyError, TypeError, IndexError):
-                        pass
-                return series.reindex(key)
-        else:
-            def do_default():
-                series[key] = value
+        try:
+            return self._getitem_lowerdim(tup)
+        except IndexingError:
+            pass
 
-            def do_list_like():
-                inds, mask = series.index.get_indexer(key)
-                if not mask.all():
-                    raise Exception('Indices %s not found' % key[-mask])
-                series.put(inds, value)
-        op = do_default
-        if _isboolarr(key):
-            if isinstance(key, Series):
-                if not key.index.equals(series.index):
-                    raise Exception('Cannot use boolean index with misaligned '
-                                    'or unequal labels')
-        elif isinstance(key, slice):
-            if _is_label_slice(series.index, key):
-                i, j = series.index.slice_locs(key.start, key.stop)
-                key = slice(i, j)
-        elif _is_list_like(key):
-            op = do_list_like
-        return op
+        # no shortcut needed
+        retval = self.obj
+        for i, key in enumerate(tup):
+            # hack?
+            retval = retval.ix._getitem_axis(key, axis=i)
 
+        return retval
 
-class AmbiguousIndexError(Exception):
-    pass
+    def _getitem_lowerdim(self, tup):
+        from pandas.core.frame import DataFrame
 
-class _DataFrameIndexer(object):
-    """
-    Class to support fancy indexing, potentially using labels of DataFrame
+        # to avoid wasted computation
+        # df.ix[d1:d2, 0] -> columns first (True)
+        # df.ix[0, ['C', 'B', A']] -> rows first (False)
+        for i, key in enumerate(tup):
+            if _is_label_like(key):
+                section = self._getitem_axis(key, axis=i)
 
-    Notes
-    -----
-    Indexing based on labels is INCLUSIVE
-    Slicing uses PYTHON SEMANTICS (endpoint is excluded)
+                # might have been a MultiIndex
+                if section.ndim == self.ndim:
+                    new_key = tup[:i] + (_NS,) + tup[i+1:]
+                else:
+                    new_key = tup[:i] + tup[i+1:]
 
-    If Index contains int labels, these will be used rather than the locations,
-    so be very careful (ambiguous).
+                    # unfortunately need an odious kludge here because of
+                    # DataFrame transposing convention
+                    if (isinstance(section, DataFrame) and i > 0
+                        and len(new_key) == 2):
+                        a, b = new_key
+                        new_key = b, a
 
-    Examples
-    --------
-    >>> frame.ix[5:10, ['A', 'B']]
-    >>> frame.ix[date1:date2, 'A']
-    """
+                    if len(new_key) == 1:
+                        new_key, = new_key
 
-    def __init__(self, frame):
-        self.frame = frame
+                return section.ix[new_key]
 
-    def __getitem__(self, key):
+        raise IndexingError('not applicable')
+
+    def _getitem_axis(self, key, axis=0):
         if isinstance(key, slice):
-            return self._fancy_getitem_axis(key, axis=0)
-        elif isinstance(key, tuple):
-            return self._getitem_tuple(key)
+            return self._get_slice_axis(key, axis=axis)
         elif _is_list_like(key):
-            return self._fancy_getitem_iterable(key, axis=0)
-        else:
-            return self._fancy_getitem_axis(key, axis=0)
+            return self._getitem_iterable(key, axis=axis)
+        elif axis == 0:
+            labels = self.obj._get_axis(0)
+            is_int_index = _is_integer_index(labels)
 
-    def _getitem_tuple(self, key):
-        if isinstance(self.frame.index, MultiIndex):
-            try:
-                return self.frame.xs(key)
-            except (KeyError, TypeError):
-                # could do something more intelligent here? like raising the
-                # exception if each tuple value are in the levels?
-                pass
+            idx = key
+            if _is_int_like(key):
+                if isinstance(labels, MultiIndex):
+                    try:
+                        return self._getitem_xs(key, axis=0)
+                    except (KeyError, TypeError):
+                        if _is_integer_index(self.obj.index.levels[0]):
+                            raise
 
-        if len(key) != 2:
-            raise Exception('only length 2 tuple supported')
-        return self._fancy_getitem_tuple(*key)
+                if not is_int_index:
+                    idx = labels[key]
 
-    def __setitem__(self, key, value):
-        # also has the side effect of consolidating in-place
-        if self.frame._is_mixed_type:
-            raise Exception('setting on mixed-type frames not yet supported')
+            return self._getitem_xs(idx, axis=0)
+        else:
+            labels = self.obj._get_axis(axis)
+            lab = key
+            if _is_int_like(key) and not _is_integer_index(labels):
+                lab = labels[key]
+            return self._getitem_xs(lab, axis=axis)
 
-        if isinstance(key, tuple):
-            if len(key) != 2:
-                raise Exception('only length 2 tuple supported')
+    def _getitem_iterable(self, key, axis=0):
+        labels = self.obj._get_axis(axis)
+        axis_name = self.obj._get_axis_name(axis)
 
-            x, y = key
-            xidx = self._convert_to_indexer(x, axis=0)
-            yidx = self._convert_to_indexer(y, axis=1)
-            indexer = _maybe_convert_ix(xidx, yidx)
+        # asarray can be unsafe, NumPy strings are weird
+        if isinstance(key, Index):
+            # want Index objects to pass through untouched
+            keyarr = key
         else:
-            indexer = self._convert_to_indexer(key)
+            keyarr = _asarray_tuplesafe(key)
+
+        if keyarr.dtype == np.bool_:
+            if _is_series(key):
+                if not key.index.equals(labels):
+                    raise IndexingError('Cannot use boolean index with '
+                                        'misaligned or unequal labels')
+            return self.obj.reindex(**{axis_name : labels[np.asarray(key)]})
+        else:
+            if _is_integer_dtype(keyarr) and not _is_integer_index(labels):
+                keyarr = labels.take(keyarr)
 
-        self.frame.values[indexer] = value
+            return self.obj.reindex(**{axis_name : keyarr})
 
     def _convert_to_indexer(self, obj, axis=0):
         """
@@ -153,7 +174,7 @@ class _DataFrameIndexer(object):
         raise AmbiguousIndexError with integer labels?
         - No, prefer label-based indexing
         """
-        index = self.frame._get_axis(axis)
+        index = self.obj._get_axis(axis)
         is_int_index = _is_integer_index(index)
         if isinstance(obj, slice):
             if _is_label_slice(index, obj):
@@ -166,8 +187,8 @@ class _DataFrameIndexer(object):
 
             if objarr.dtype == np.bool_:
                 if not obj.index.equals(index):
-                    raise Exception('Cannot use boolean index with misaligned '
-                                    'or unequal labels')
+                    raise IndexingError('Cannot use boolean index with '
+                                        'misaligned or unequal labels')
                 return objarr
             else:
                 # If have integer labels, defer to label-based indexing
@@ -184,89 +205,90 @@ class _DataFrameIndexer(object):
                 return obj
             return index.get_loc(obj)
 
-    def _fancy_getitem_tuple(self, rowkey, colkey):
-        # to avoid wasted computation
-        # df.ix[d1:d2, 0] -> columns first (True)
-        # df.ix[0, ['C', 'B', A']] -> rows first (False)
-        if _is_label_like(colkey):
-            return self._fancy_getitem_axis(colkey, axis=1).ix[rowkey]
-        elif _is_label_like(rowkey):
-            return self._fancy_getitem_axis(rowkey, axis=0).ix[colkey]
+    def _get_slice_axis(self, slice_obj, axis=0):
+        obj = self.obj
 
-        result = self._fancy_getitem_axis(colkey, axis=1)
-        return result.ix[rowkey]
+        axis_name = obj._get_axis_name(axis)
+        labels = getattr(obj, axis_name)
+        if _is_label_slice(labels, slice_obj):
+            i, j = labels.slice_locs(slice_obj.start, slice_obj.stop)
+            slicer = slice(i, j)
+        else:
+            slicer = slice_obj
 
-    def _fancy_getitem_axis(self, key, axis=0):
-        if isinstance(key, slice):
-            return self._get_slice_axis(key, axis=axis)
-        elif _is_list_like(key):
-            return self._fancy_getitem_iterable(key, axis=axis)
-        elif axis == 0:
-            is_int_index = _is_integer_index(self.frame.index)
+        if not _need_slice(slice_obj):
+            return obj
 
-            idx = key
-            if _is_int_like(key):
-                if isinstance(self.frame.index, MultiIndex):
-                    try:
-                        return self.frame.xs(key)
-                    except (KeyError, TypeError):
-                        if _is_integer_index(self.frame.index.levels[0]):
-                            raise
+        return obj._slice(slicer, axis=axis)
 
-                if not is_int_index:
-                    idx = self.frame.index[key]
+class _SeriesIndexer(_NDFrameIndexer):
+    """
+    Class to support fancy indexing, potentially using labels
 
-            if self.frame._is_mixed_type:
-                return self.frame.xs(idx)
-            else:
-                # get a view if possible
-                return self.frame.xs(idx, copy=False)
-        else:
-            col = key
-            if _is_int_like(key) and not _is_integer_index(self.frame.columns):
-                col = self.frame.columns[key]
-            return self.frame[col]
+    Notes
+    -----
+    Indexing based on labels is INCLUSIVE
+    Slicing uses PYTHON SEMANTICS (endpoint is excluded)
 
-    def _fancy_getitem_iterable(self, key, axis=0):
-        from pandas.core.series import Series
+    If Index contains int labels, these will be used rather than the locations,
+    so be very careful (ambiguous).
 
-        labels = self.frame._get_axis(axis)
-        axis_name = self.frame._get_axis_name(axis)
+    Examples
+    --------
+    >>> ts.ix[5:10] # equivalent to ts[5:10]
+    >>> ts.ix[[date1, date2, date3]]
+    >>> ts.ix[date1:date2] = 0
+    """
 
-        # asarray can be unsafe, NumPy strings are weird
-        if isinstance(key, Index):
-            # want Index objects to pass through untouched
-            keyarr = key
-        else:
-            keyarr = _asarray_tuplesafe(key)
+    def __getitem__(self, key):
+        op = self._fancy_index(key, operation='get')
+        return op()
 
-        if keyarr.dtype == np.bool_:
-            if isinstance(key, Series):
-                if not key.index.equals(labels):
-                    raise Exception('Cannot use boolean index with misaligned '
-                                    'or unequal labels')
-            return self.frame.reindex(**{axis_name : labels[np.asarray(key)]})
-        else:
-            if _is_integer_dtype(keyarr) and not _is_integer_index(labels):
-                keyarr = labels.take(keyarr)
+    def __setitem__(self, key, value):
+        op = self._fancy_index(key, value, operation='set')
+        op()
 
-            return self.frame.reindex(**{axis_name : keyarr})
+    def _fancy_index(self, key, value=None, operation='get'):
+        # going to great lengths to avoid code dup
+        obj = self.obj
 
-    def _get_slice_axis(self, slice_obj, axis=0):
-        frame = self.frame
+        if operation == 'get':
+            def do_default():
+                return obj[key]
 
-        axis_name = frame._get_axis_name(axis)
-        labels = getattr(frame, axis_name)
-        if _is_label_slice(labels, slice_obj):
-            i, j = labels.slice_locs(slice_obj.start, slice_obj.stop)
-            slicer = slice(i, j)
+            def do_list_like():
+                if isinstance(obj.index, MultiIndex):
+                    try:
+                        return obj[key]
+                    except (KeyError, TypeError, IndexError):
+                        pass
+                return obj.reindex(key)
         else:
-            slicer = slice_obj
+            def do_default():
+                obj[key] = value
 
-        if not _need_slice(slice_obj):
-            return frame
+            def do_list_like():
+                inds, mask = obj.index.get_indexer(key)
+                if not mask.all():
+                    raise IndexingError('Indices %s not found' % key[-mask])
+                obj.put(inds, value)
+        op = do_default
+        if _isboolarr(key):
+            if _is_series(key):
+                if not key.index.equals(obj.index):
+                    raise IndexingError('Cannot use boolean index with '
+                                        'misaligned or unequal labels')
+        elif isinstance(key, slice):
+            if _is_label_slice(obj.index, key):
+                i, j = obj.index.slice_locs(key.start, key.stop)
+                key = slice(i, j)
+        elif _is_list_like(key):
+            op = do_list_like
+        return op
 
-        return frame._slice(slicer, axis=axis)
+def _is_series(obj):
+    from pandas.core.series import Series
+    return isinstance(obj, Series)
 
 def _maybe_convert_ix(*args):
     """
@@ -326,4 +348,3 @@ def _maybe_droplevels(index, key):
     return index
 
 _isboolarr = lambda x: np.asarray(x).dtype == np.bool_
-
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index c7d185715..fecaca042 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -13,6 +13,7 @@ import numpy as np
 from pandas.core.common import (PandasError, _mut_exclusive, _ensure_index,
                                 _try_sort, _default_index, _infer_dtype)
 from pandas.core.index import Factor, Index, MultiIndex
+from pandas.core.indexing import _NDFrameIndexer
 from pandas.core.internals import BlockManager, make_block, form_blocks
 from pandas.core.frame import DataFrame, _union_indexes
 from pandas.core.generic import AxisProperty, NDFrame
@@ -294,6 +295,16 @@ class Panel(NDFrame):
     def _constructor(self):
         return Panel
 
+    # Fancy indexing
+    _ix = None
+
+    @property
+    def ix(self):
+        if self._ix is None:
+            self._ix = _NDFrameIndexer(self)
+
+        return self._ix
+
     def _wrap_array(self, arr, axes, copy=False):
         items, major, minor = axes
         return self._constructor(arr, items=items, major_axis=major,
@@ -336,6 +347,10 @@ class Panel(NDFrame):
         mat = self._data.get(key)
         return DataFrame(mat, index=self.major_axis, columns=self.minor_axis)
 
+    def _slice(self, slobj, axis=0):
+        new_data = self._data.get_slice(slobj, axis=axis)
+        return self._constructor(new_data)
+
     def __setitem__(self, key, value):
         _, N, K = self.shape
 
@@ -581,15 +596,15 @@ class Panel(NDFrame):
         ----------
         key : object
             Major axis label
+        copy : boolean, default False
+            Copy data
 
         Returns
         -------
         y : DataFrame
             index -> minor axis, columns -> items
         """
-        self._consolidate_inplace()
-        new_data = self._data.xs(key, axis=1, copy=copy)
-        return DataFrame(new_data)
+        return self.xs(key, axis=1, copy=copy)
 
     def minor_xs(self, key, copy=True):
         """
@@ -599,14 +614,39 @@ class Panel(NDFrame):
         ----------
         key : object
             Minor axis label
+        copy : boolean, default False
+            Copy data
 
         Returns
         -------
         y : DataFrame
             index -> major axis, columns -> items
         """
+        return self.xs(key, axis=2, copy=copy)
+
+    def xs(self, key, axis=1, copy=False):
+        """
+        Return slice of panel along selected axis
+
+        Parameters
+        ----------
+        key : object
+            Label
+        axis : {'items', 'major', 'minor}
+
+        Returns
+        -------
+        y : DataFrame
+        """
+        if axis == 0:
+            data = self[key]
+            if copy:
+                data = data.copy()
+            return data
+
         self._consolidate_inplace()
-        new_data = self._data.xs(key, axis=2, copy=copy)
+        axis_number = self._get_axis_number(axis)
+        new_data = self._data.xs(key, axis=axis_number, copy=copy)
         return DataFrame(new_data)
 
     def groupby(self, function, axis='major'):
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index 137177452..fe89634f0 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -625,6 +625,8 @@ class SparseDataFrame(DataFrame):
     _columns = None
     _series = None
 
+    ndim = 2
+
     def __init__(self, data=None, index=None, columns=None,
                  default_kind='block', default_fill_value=None):
         if default_fill_value is None:
@@ -1302,6 +1304,8 @@ class SparsePanel(Panel):
     major_axis = PanelAxis('_major_axis')
     minor_axis = PanelAxis('_minor_axis')
 
+    ndim = 3
+
     def __init__(self, frames, items=None, major_axis=None, minor_axis=None,
                  default_fill_value=nan, default_kind='block'):
         assert(isinstance(frames, dict))
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index d0689f463..ef72d5615 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -312,9 +312,211 @@ class SafeForSparse(object):
         result = p.select(lambda x: x in ('foo',), axis='items')
         self.assert_panel_equal(result, p.reindex(items=[]))
 
-class TestPanel(unittest.TestCase, PanelTests,
-                    SafeForLongAndSparse,
-                    SafeForSparse):
+class CheckIndexing(object):
+
+
+    def test_getitem(self):
+        self.assertRaises(Exception, self.panel.__getitem__, 'ItemQ')
+
+    def test_delitem_and_pop(self):
+        expected = self.panel['ItemA']
+        result = self.panel.pop('ItemA')
+        assert_frame_equal(expected, result)
+        self.assert_('ItemA' not in self.panel.items)
+
+        del self.panel['ItemB']
+        self.assert_('ItemB' not in self.panel.items)
+        self.assertRaises(Exception, self.panel.__delitem__, 'ItemB')
+
+        values = np.empty((3, 3, 3))
+        values[0] = 0
+        values[1] = 1
+        values[2] = 2
+
+        panel = Panel(values, range(3), range(3), range(3))
+
+        # did we delete the right row?
+
+        panelc = panel.copy()
+        del panelc[0]
+        assert_frame_equal(panelc[1], panel[1])
+        assert_frame_equal(panelc[2], panel[2])
+
+        panelc = panel.copy()
+        del panelc[1]
+        assert_frame_equal(panelc[0], panel[0])
+        assert_frame_equal(panelc[2], panel[2])
+
+        panelc = panel.copy()
+        del panelc[2]
+        assert_frame_equal(panelc[1], panel[1])
+        assert_frame_equal(panelc[0], panel[0])
+
+    def test_setitem(self):
+
+        # LongPanel with one item
+        lp = self.panel.filter(['ItemA']).to_long()
+        self.panel['ItemE'] = lp
+
+        lp = self.panel.filter(['ItemA', 'ItemB']).to_long()
+        self.assertRaises(Exception, self.panel.__setitem__,
+                          'ItemE', lp)
+
+        # DataFrame
+        df = self.panel['ItemA'][2:].filter(items=['A', 'B'])
+        self.panel['ItemF'] = df
+        self.panel['ItemE'] = df
+
+        df2 = self.panel['ItemF']
+
+        assert_frame_equal(df, df2.reindex(index=df.index,
+                                           columns=df.columns))
+
+        # scalar
+        self.panel['ItemG'] = 1
+        self.panel['ItemE'] = 1
+
+        # object dtype
+        self.panel['ItemQ'] = 'foo'
+        self.assert_(self.panel['ItemQ'].values.dtype == np.object_)
+
+        # boolean dtype
+        self.panel['ItemP'] = self.panel['ItemA'] > 0
+        self.assert_(self.panel['ItemP'].values.dtype == np.bool_)
+
+
+    def test_major_xs(self):
+        ref = self.panel['ItemA']
+
+        idx = self.panel.major_axis[5]
+        xs = self.panel.major_xs(idx)
+
+        assert_series_equal(xs['ItemA'], ref.xs(idx))
+
+        # not contained
+        idx = self.panel.major_axis[0] - bday
+        self.assertRaises(Exception, self.panel.major_xs, idx)
+
+    def test_major_xs_mixed(self):
+        self.panel['ItemD'] = 'foo'
+        xs = self.panel.major_xs(self.panel.major_axis[0])
+        self.assert_(xs['ItemA'].dtype == np.float64)
+        self.assert_(xs['ItemD'].dtype == np.object_)
+
+    def test_minor_xs(self):
+        ref = self.panel['ItemA']
+
+        idx = self.panel.minor_axis[1]
+        xs = self.panel.minor_xs(idx)
+
+        assert_series_equal(xs['ItemA'], ref[idx])
+
+        # not contained
+        self.assertRaises(Exception, self.panel.minor_xs, 'E')
+
+    def test_minor_xs_mixed(self):
+        self.panel['ItemD'] = 'foo'
+
+        xs = self.panel.minor_xs('D')
+        self.assert_(xs['ItemA'].dtype == np.float64)
+        self.assert_(xs['ItemD'].dtype == np.object_)
+
+    def test_getitem_fancy_labels(self):
+        p = self.panel
+
+        items = p.items[[1, 0]]
+        dates = p.major_axis[::2]
+        cols = ['D', 'C', 'F']
+
+        # all 3 specified
+        assert_panel_equal(p.ix[items, dates, cols],
+                           p.reindex(items=items, major=dates, minor=cols))
+
+        # 2 specified
+        assert_panel_equal(p.ix[:, dates, cols],
+                           p.reindex(major=dates, minor=cols))
+
+        assert_panel_equal(p.ix[items, :, cols],
+                           p.reindex(items=items, minor=cols))
+
+        assert_panel_equal(p.ix[items, dates, :],
+                           p.reindex(items=items, major=dates))
+
+        # only 1
+        assert_panel_equal(p.ix[items, :, :],
+                           p.reindex(items=items))
+
+        assert_panel_equal(p.ix[:, dates, :],
+                           p.reindex(major=dates))
+
+        assert_panel_equal(p.ix[:, :, cols],
+                           p.reindex(minor=cols))
+
+    def test_getitem_fancy_slice(self):
+        pass
+
+    def test_getitem_fancy_ints(self):
+        pass
+
+    def test_getitem_fancy_xs(self):
+        p = self.panel
+        item = 'ItemB'
+        date = p.major_axis[5]
+        col = 'C'
+
+        # get DataFrame
+        # item
+        assert_frame_equal(p.ix[item], p[item])
+        assert_frame_equal(p.ix[item, :], p[item])
+        assert_frame_equal(p.ix[item, :, :], p[item])
+
+        # major axis, axis=1
+        assert_frame_equal(p.ix[:, date], p.major_xs(date))
+        assert_frame_equal(p.ix[:, date, :], p.major_xs(date))
+
+        # minor axis, axis=2
+        assert_frame_equal(p.ix[:, :, 'C'], p.minor_xs('C'))
+
+        # get Series
+        assert_series_equal(p.ix[item, date], p[item].ix[date])
+        assert_series_equal(p.ix[item, date, :], p[item].ix[date])
+        assert_series_equal(p.ix[item, :, col], p[item][col])
+        assert_series_equal(p.ix[:, date, col], p.major_xs(date).ix[col])
+
+    def test_getitem_fancy_xs_check_view(self):
+        item = 'ItemB'
+        date = self.panel.major_axis[5]
+        col = 'C'
+
+        # make sure it's always a view
+        NS = slice(None, None)
+
+        # DataFrames
+        comp = assert_frame_equal
+        self._check_view(item, comp)
+        self._check_view((item, NS), comp)
+        self._check_view((item, NS, NS), comp)
+        self._check_view((NS, date), comp)
+        self._check_view((NS, date, NS), comp)
+        self._check_view((NS, NS, 'C'), comp)
+
+        # Series
+        comp = assert_series_equal
+        self._check_view((item, date), comp)
+        self._check_view((item, date, NS), comp)
+        self._check_view((item, NS, 'C'), comp)
+        self._check_view((NS, date, 'C'), comp)
+
+    def _check_view(self, indexer, comp):
+        cp = self.panel.copy()
+        obj = cp.ix[indexer]
+        obj.values[:] = 0
+        self.assert_((obj.values == 0).all())
+        comp(cp.ix[indexer].reindex_like(obj), obj)
+
+class TestPanel(unittest.TestCase, PanelTests, CheckIndexing,
+                SafeForLongAndSparse,
+                SafeForSparse):
 
     @staticmethod
     def assert_panel_equal(x, y):
@@ -404,75 +606,6 @@ class TestPanel(unittest.TestCase, PanelTests,
         self.assertRaises(Exception, Panel, np.random.randn(5, 5, 5),
                           range(5), range(5), range(4))
 
-    def test_getitem(self):
-        self.assertRaises(Exception, self.panel.__getitem__, 'ItemQ')
-
-    def test_delitem_and_pop(self):
-        expected = self.panel['ItemA']
-        result = self.panel.pop('ItemA')
-        assert_frame_equal(expected, result)
-        self.assert_('ItemA' not in self.panel.items)
-
-        del self.panel['ItemB']
-        self.assert_('ItemB' not in self.panel.items)
-        self.assertRaises(Exception, self.panel.__delitem__, 'ItemB')
-
-        values = np.empty((3, 3, 3))
-        values[0] = 0
-        values[1] = 1
-        values[2] = 2
-
-        panel = Panel(values, range(3), range(3), range(3))
-
-        # did we delete the right row?
-
-        panelc = panel.copy()
-        del panelc[0]
-        assert_frame_equal(panelc[1], panel[1])
-        assert_frame_equal(panelc[2], panel[2])
-
-        panelc = panel.copy()
-        del panelc[1]
-        assert_frame_equal(panelc[0], panel[0])
-        assert_frame_equal(panelc[2], panel[2])
-
-        panelc = panel.copy()
-        del panelc[2]
-        assert_frame_equal(panelc[1], panel[1])
-        assert_frame_equal(panelc[0], panel[0])
-
-    def test_setitem(self):
-
-        # LongPanel with one item
-        lp = self.panel.filter(['ItemA']).to_long()
-        self.panel['ItemE'] = lp
-
-        lp = self.panel.filter(['ItemA', 'ItemB']).to_long()
-        self.assertRaises(Exception, self.panel.__setitem__,
-                          'ItemE', lp)
-
-        # DataFrame
-        df = self.panel['ItemA'][2:].filter(items=['A', 'B'])
-        self.panel['ItemF'] = df
-        self.panel['ItemE'] = df
-
-        df2 = self.panel['ItemF']
-
-        assert_frame_equal(df, df2.reindex(index=df.index,
-                                           columns=df.columns))
-
-        # scalar
-        self.panel['ItemG'] = 1
-        self.panel['ItemE'] = 1
-
-        # object dtype
-        self.panel['ItemQ'] = 'foo'
-        self.assert_(self.panel['ItemQ'].values.dtype == np.object_)
-
-        # boolean dtype
-        self.panel['ItemP'] = self.panel['ItemA'] > 0
-        self.assert_(self.panel['ItemP'].values.dtype == np.bool_)
-
     def test_conform(self):
         df = self.panel['ItemA'][:-5].filter(items=['A', 'B'])
         conformed = self.panel.conform(df)
@@ -578,42 +711,6 @@ class TestPanel(unittest.TestCase, PanelTests,
         result = self.panel.add(lng)
         self.assert_panel_equal(result, self.panel * 2)
 
-    def test_major_xs(self):
-        ref = self.panel['ItemA']
-
-        idx = self.panel.major_axis[5]
-        xs = self.panel.major_xs(idx)
-
-        assert_series_equal(xs['ItemA'], ref.xs(idx))
-
-        # not contained
-        idx = self.panel.major_axis[0] - bday
-        self.assertRaises(Exception, self.panel.major_xs, idx)
-
-    def test_major_xs_mixed(self):
-        self.panel['ItemD'] = 'foo'
-        xs = self.panel.major_xs(self.panel.major_axis[0])
-        self.assert_(xs['ItemA'].dtype == np.float64)
-        self.assert_(xs['ItemD'].dtype == np.object_)
-
-    def test_minor_xs(self):
-        ref = self.panel['ItemA']
-
-        idx = self.panel.minor_axis[1]
-        xs = self.panel.minor_xs(idx)
-
-        assert_series_equal(xs['ItemA'], ref[idx])
-
-        # not contained
-        self.assertRaises(Exception, self.panel.minor_xs, 'E')
-
-    def test_minor_xs_mixed(self):
-        self.panel['ItemD'] = 'foo'
-
-        xs = self.panel.minor_xs('D')
-        self.assert_(xs['ItemA'].dtype == np.float64)
-        self.assert_(xs['ItemD'].dtype == np.object_)
-
     def test_swapaxes(self):
         result = self.panel.swapaxes('items', 'minor')
         self.assert_(result.items is self.panel.minor_axis)

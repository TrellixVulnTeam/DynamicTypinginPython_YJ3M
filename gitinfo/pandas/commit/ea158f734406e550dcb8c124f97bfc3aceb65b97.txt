commit ea158f734406e550dcb8c124f97bfc3aceb65b97
Author: Chang She <chang@lambdafoundry.com>
Date:   Fri May 18 15:55:08 2012 -0400

    ENH: several custom date conversion methods. #1174

diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index 9d4242c60..50d585238 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -21,6 +21,7 @@ import datetime
 import pandas.core.common as com
 import pandas._tseries as lib
 from pandas.util import py3compat
+from pandas.io.date_converters import generic_parser
 
 from pandas.util.decorators import Appender
 
@@ -804,10 +805,13 @@ class TextParser(object):
         else:
             try:
                 return self.date_parser(*date_cols)
-            except:
-                return lib.try_parse_dates(_concat_date_cols(date_cols),
-                                           parser=self.date_parser,
-                                           dayfirst=self.dayfirst)
+            except Exception, inst:
+                try:
+                    return generic_parser(self.date_parser, *date_cols)
+                except Exception, inst:
+                    return lib.try_parse_dates(_concat_date_cols(date_cols),
+                                               parser=self.date_parser,
+                                               dayfirst=self.dayfirst)
 
     def _process_date_conversion(self, data_dict):
         new_cols = []
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index 6fcee987d..045877120 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -22,6 +22,9 @@ from pandas.util import py3compat
 from pandas._tseries import Timestamp
 
 from numpy.testing.decorators import slow
+from pandas.io.date_converters import (
+    parse_date_time, parse_date_fields, parse_all_fields
+)
 
 
 class TestParsers(unittest.TestCase):
@@ -150,7 +153,7 @@ KORD,19990127, 22:00:00, 21:56:00, -0.5900, 1.7100, 5.1000, 0.0000, 290.0000
 KORD,19990127, 23:00:00, 22:56:00, -0.5900, 1.7100, 4.6000, 0.0000, 280.0000
 """
         df = read_csv(StringIO(data), header=None,
-                        parse_dates=[[1, 2], [1,3]])
+                      parse_dates=[[1, 2], [1,3]])
         self.assert_('X.2_X.3' in df)
         self.assert_('X.2_X.4' in df)
         self.assert_('X.2' not in df)
diff --git a/pandas/src/inference.pyx b/pandas/src/inference.pyx
index 87fbb7076..712a482ba 100644
--- a/pandas/src/inference.pyx
+++ b/pandas/src/inference.pyx
@@ -432,6 +432,96 @@ def try_parse_dates(ndarray[object] values, parser=None,
 
     return result
 
+def try_parse_date_and_time(ndarray[object] dates, ndarray[object] times,
+                            date_parser=None, time_parser=None,
+                            dayfirst=False):
+    cdef:
+        Py_ssize_t i, n
+        ndarray[object] result
+
+    from datetime import date, time, datetime
+
+    n = len(dates)
+    if len(times) != n:
+        raise ValueError('Length of dates and times must be equal')
+    result = np.empty(n, dtype='O')
+
+    if date_parser is None:
+        try:
+            from dateutil.parser import parse
+            parse_date = lambda x: parse(x, dayfirst=dayfirst)
+        except ImportError: # pragma: no cover
+            def parse_date(s):
+                try:
+                    return date.strptime(s, '%m/%d/%Y')
+                except Exception:
+                    return s
+    else:
+        parse_date = date_parser
+
+    if time_parser is None:
+        try:
+            from dateutil.parser import parse
+            parse_time = lambda x: parse(x)
+        except ImportError: # pragma: no cover
+            def parse_time(s):
+                try:
+                    return time.strptime(s, '%H:%M:%S')
+                except Exception:
+                    return s
+
+    else:
+        parse_time = time_parser
+
+    for i from 0 <= i < n:
+        d = parse_date(dates[i])
+        t = parse_time(times[i])
+        result[i] = datetime(d.year, d.month, d.day,
+                             t.hour, t.minute, t.second)
+
+    return result
+
+
+def try_parse_year_month_day(ndarray[object] years, ndarray[object] months,
+                             ndarray[object] days):
+    cdef:
+        Py_ssize_t i, n
+        ndarray[object] result
+
+    from datetime import datetime
+
+    n = len(years)
+    if len(months) != n or len(days) != n:
+        raise ValueError('Length of years/months/days must all be equal')
+    result = np.empty(n, dtype='O')
+
+    for i from 0 <= i < n:
+        result[i] = datetime(int(years[i]), int(months[i]), int(days[i]))
+
+    return result
+
+def try_parse_datetime_components(ndarray[object] years, ndarray[object] months,
+    ndarray[object] days, ndarray[object] hours, ndarray[object] minutes,
+    ndarray[object] seconds):
+
+    cdef:
+        Py_ssize_t i, n
+        ndarray[object] result
+
+    from datetime import datetime
+
+    n = len(years)
+    if (len(months) != n and len(days) != n and len(hours) != n and
+        len(minutes) != n and len(seconds) != n):
+        raise ValueError('Length of all datetime components must be equal')
+    result = np.empty(n, dtype='O')
+
+    for i from 0 <= i < n:
+        result[i] = datetime(int(years[i]), int(months[i]), int(days[i]),
+                             int(hours[i]), int(minutes[i]), int(seconds[i]))
+
+    return result
+
 def sanitize_objects(ndarray[object] values, set na_values):
     cdef:
         Py_ssize_t i, n

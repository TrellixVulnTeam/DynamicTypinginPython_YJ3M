commit 77761288ad4d04f40826252b8556e2f360cda5bc
Author: y-p <yoval@gmx.com>
Date:   Mon Mar 18 18:18:01 2013 +0200

    ENH: add (undocumented) legacy kwd to df.to_csv, just in case

diff --git a/pandas/core/format.py b/pandas/core/format.py
index 644c08b6b..2237160ef 100644
--- a/pandas/core/format.py
+++ b/pandas/core/format.py
@@ -769,8 +769,9 @@ class CSVFormatter(object):
     def __init__(self, obj, path_or_buf, sep=",", na_rep='', float_format=None,
                cols=None, header=True, index=True, index_label=None,
                mode='w', nanRep=None, encoding=None, quoting=None,
-               line_terminator='\n', chunksize=None):
+               line_terminator='\n', chunksize=None,legacy=False):
 
+        self.legacy=legacy # remove for 0.12
         self.obj = obj
         self.path_or_buf = path_or_buf
         self.sep = sep
@@ -811,8 +812,86 @@ class CSVFormatter(object):
         if not index:
             self.nlevels = 0
 
-    def save(self):
+    # legacy to be removed in 0.12
+    def _helper_csv(self, writer, na_rep=None, cols=None,
+                    header=True, index=True,
+                    index_label=None, float_format=None):
+        if cols is None:
+            cols = self.columns
+
+        series = {}
+        for k, v in self.obj._series.iteritems():
+            series[k] = v.values
+
+
+        has_aliases = isinstance(header, (tuple, list, np.ndarray))
+        if has_aliases or header:
+            if index:
+                # should write something for index label
+                if index_label is not False:
+                    if index_label is None:
+                        if isinstance(self.obj.index, MultiIndex):
+                            index_label = []
+                            for i, name in enumerate(self.obj.index.names):
+                                if name is None:
+                                    name = ''
+                                index_label.append(name)
+                        else:
+                            index_label = self.obj.index.name
+                            if index_label is None:
+                                index_label = ['']
+                            else:
+                                index_label = [index_label]
+                    elif not isinstance(index_label, (list, tuple, np.ndarray)):
+                        # given a string for a DF with Index
+                        index_label = [index_label]
+
+                    encoded_labels = list(index_label)
+                else:
+                    encoded_labels = []
 
+                if has_aliases:
+                    if len(header) != len(cols):
+                        raise ValueError(('Writing %d cols but got %d aliases'
+                                          % (len(cols), len(header))))
+                    else:
+                        write_cols = header
+                else:
+                    write_cols = cols
+                encoded_cols = list(write_cols)
+
+                writer.writerow(encoded_labels + encoded_cols)
+            else:
+                encoded_cols = list(cols)
+                writer.writerow(encoded_cols)
+
+        data_index = self.obj.index
+        if isinstance(self.obj.index, PeriodIndex):
+            data_index = self.obj.index.to_timestamp()
+
+        nlevels = getattr(data_index, 'nlevels', 1)
+        for j, idx in enumerate(data_index):
+            row_fields = []
+            if index:
+                if nlevels == 1:
+                    row_fields = [idx]
+                else: # handle MultiIndex
+                    row_fields = list(idx)
+            for i, col in enumerate(cols):
+                val = series[col][j]
+                if lib.checknull(val):
+                    val = na_rep
+
+                if float_format is not None and com.is_float(val):
+                    val = float_format % val
+                elif isinstance(val, np.datetime64):
+                    val = lib.Timestamp(val)._repr_base
+
+                row_fields.append(val)
+
+            writer.writerow(row_fields)
+
+    def save(self):
         # create the writer & save
         if hasattr(self.path_or_buf, 'read'):
             f = self.path_or_buf
@@ -829,8 +908,17 @@ class CSVFormatter(object):
             else:
                 self.writer = csv.writer(f, lineterminator=self.line_terminator,
                                          delimiter=self.sep, quoting=self.quoting)
-                
-            self._save()
+
+
+            if self.legacy:
+            # to be removed in 0.12
+                self._helper_csv(self.writer, na_rep=self.na_rep,
+                                 float_format=self.float_format, cols=self.cols,
+                                 header=self.header, index=self.index,
+                                 index_label=self.index_label)
+
+            else:
+                self._save()
 
         finally:
             if close:
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index b2dc6715b..7cfb9ec03 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1291,7 +1291,7 @@ class DataFrame(NDFrame):
     def to_csv(self, path_or_buf, sep=",", na_rep='', float_format=None,
                cols=None, header=True, index=True, index_label=None,
                mode='w', nanRep=None, encoding=None, quoting=None,
-               line_terminator='\n', chunksize=None):
+               line_terminator='\n', chunksize=None,**kwds):
         """
         Write DataFrame to a comma-separated values (csv) file
 
@@ -1336,15 +1336,17 @@ class DataFrame(NDFrame):
                           FutureWarning)
             na_rep = nanRep
 
-        formatter = fmt.CSVFormatter(self, path_or_buf, 
-                                     line_terminator=line_terminator,
-                                     sep=sep, encoding=encoding,
-                                     quoting=quoting,na_rep=na_rep,
-                                     float_format=float_format, cols=cols,
-                                     header=header, index=index,
-                                     index_label=index_label,
-                                     chunksize=chunksize)
-        formatter.save()
+
+        else:
+            formatter = fmt.CSVFormatter(self, path_or_buf,
+                                         line_terminator=line_terminator,
+                                         sep=sep, encoding=encoding,
+                                         quoting=quoting,na_rep=na_rep,
+                                         float_format=float_format, cols=cols,
+                                         header=header, index=index,
+                                         index_label=index_label,
+                                         chunksize=chunksize,legacy=kwds.get("legacy",False) )
+            formatter.save()
 
     def to_excel(self, excel_writer, sheet_name='sheet1', na_rep='',
                  float_format=None, cols=None, header=True, index=True,

commit 3be34449584e04e597459b9ec45a64a2729f7c3f
Author: jreback <jeff@reback.net>
Date:   Fri Apr 25 17:26:54 2014 -0400

    COMPAT: fix warning for slice indexers when using floats in iloc that are convertible

diff --git a/pandas/core/index.py b/pandas/core/index.py
index 0d363ee2b..43d012922 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -480,10 +480,10 @@ class Index(IndexOpsMixin, FrozenNDArray):
             if is_integer(key):
                 return key
             elif is_float(key):
-                if not self.is_floating():
-                    warnings.warn("scalar indexers for index type {0} should be integers and not floating point".format(
-                        type(self).__name__),FutureWarning)
-                return to_int()
+                key = to_int()
+                warnings.warn("scalar indexers for index type {0} should be integers and not floating point".format(
+                    type(self).__name__),FutureWarning)
+                return key
             return self._convert_indexer_error(key, 'label')
 
         if is_float(key):
@@ -498,17 +498,9 @@ class Index(IndexOpsMixin, FrozenNDArray):
         """ validate and raise if needed on a slice indexers according to the
         passed in function """
 
-        if not f(key.start):
-            self._convert_indexer_error(key.start, 'slice start value')
-        if not f(key.stop):
-            self._convert_indexer_error(key.stop, 'slice stop value')
-        if not f(key.step):
-            self._convert_indexer_error(key.step, 'slice step value')
-
-    def _convert_slice_indexer_iloc(self, key):
-        """ convert a slice indexer for iloc only """
-        self._validate_slicer(key, lambda v: v is None or is_integer(v))
-        return key
+        for c in ['start','stop','step']:
+            if not f(getattr(key,c)):
+                self._convert_indexer_error(key.start, 'slice {0} value'.format(c))
 
     def _convert_slice_indexer_getitem(self, key, is_index_slice=False):
         """ called from the getitem slicers, determine how to treat the key
@@ -520,6 +512,25 @@ class Index(IndexOpsMixin, FrozenNDArray):
     def _convert_slice_indexer(self, key, typ=None):
         """ convert a slice indexer. disallow floats in the start/stop/step """
 
+        # validate iloc
+        if typ == 'iloc':
+
+            # need to coerce to_int if needed
+            def f(c):
+                v = getattr(key,c)
+                if v is None or is_integer(v):
+                    return v
+
+                # warn if its a convertible float
+                if v == int(v):
+                    warnings.warn("slice indexers when using iloc should be integers "
+                                  "and not floating point",FutureWarning)
+                    return int(v)
+
+                self._convert_indexer_error(v, 'slice {0} value'.format(c))
+
+            return slice(*[ f(c) for c in ['start','stop','step']])
+
         # validate slicers
         def validate(v):
             if v is None or is_integer(v):
@@ -530,7 +541,6 @@ class Index(IndexOpsMixin, FrozenNDArray):
                 return False
 
             return True
-
         self._validate_slicer(key, validate)
 
         # figure out if this is a positional indexer
@@ -543,9 +553,7 @@ class Index(IndexOpsMixin, FrozenNDArray):
         is_index_slice = is_int(start) and is_int(stop)
         is_positional = is_index_slice and not self.is_integer()
 
-        if typ == 'iloc':
-            return self._convert_slice_indexer_iloc(key)
-        elif typ == 'getitem':
+        if typ == 'getitem':
             return self._convert_slice_indexer_getitem(
                 key, is_index_slice=is_index_slice)
 
@@ -1980,7 +1988,7 @@ class Float64Index(Index):
         """ convert a slice indexer, by definition these are labels
             unless we are iloc """
         if typ == 'iloc':
-            return self._convert_slice_indexer_iloc(key)
+            return super(Float64Index, self)._convert_slice_indexer(key, typ=typ)
 
         # allow floats here
         self._validate_slicer(
@@ -2386,14 +2394,6 @@ class MultiIndex(Index):
     def __len__(self):
         return len(self.labels[0])
 
-    def _convert_slice_indexer(self, key, typ=None):
-        """ convert a slice indexer. disallow floats in the start/stop/step """
-
-        if typ == 'iloc':
-            return self._convert_slice_indexer_iloc(key)
-
-        return super(MultiIndex, self)._convert_slice_indexer(key, typ=typ)
-
     def _get_names(self):
         return FrozenList(level.name for level in self.levels)
 
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 459c6abbe..63988a597 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -7,7 +7,7 @@ import pandas.compat as compat
 import pandas.core.common as com
 from pandas.core.common import (_is_bool_indexer, is_integer_dtype,
                                 _asarray_tuplesafe, is_list_like, isnull,
-                                ABCSeries, ABCDataFrame, ABCPanel)
+                                ABCSeries, ABCDataFrame, ABCPanel, is_float)
 import pandas.lib as lib
 
 import numpy as np
@@ -1319,6 +1319,7 @@ class _iLocIndexer(_LocationIndexer):
         if not _need_slice(slice_obj):
             return obj
 
+        slice_obj = self._convert_slice_indexer(slice_obj, axis)
         if isinstance(slice_obj, slice):
             return self._slice(slice_obj, axis=axis, typ='iloc')
         else:
@@ -1363,7 +1364,15 @@ class _iLocIndexer(_LocationIndexer):
 
     def _convert_to_indexer(self, obj, axis=0, is_setter=False):
         """ much simpler as we only have to deal with our valid types """
-        if self._has_valid_type(obj, axis):
+
+        # make need to convert a float key
+        if isinstance(obj, slice):
+            return self._convert_slice_indexer(obj, axis)
+
+        elif is_float(obj):
+            return self._convert_scalar_indexer(obj, axis)
+
+        elif self._has_valid_type(obj, axis):
             return obj
 
         raise ValueError("Can only index by location with a [%s]" %
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index ddf155918..11c065a52 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -1270,7 +1270,9 @@ class CheckIndexing(object):
         df = DataFrame(np.random.randn(5, 5), index=index)
 
         # positional slicing only via iloc!
-        result = df.iloc[1.0:5]
+        with tm.assert_produces_warning(FutureWarning):
+            result = df.iloc[1.0:5]
+
         expected = df.reindex([2.5, 3.5, 4.5, 5.0])
         assert_frame_equal(result, expected)
         self.assertEqual(len(result), 4)
@@ -1280,15 +1282,26 @@ class CheckIndexing(object):
         assert_frame_equal(result, expected)
         self.assertEqual(len(result), 1)
 
+        # GH 4892, float indexers in iloc are deprecated
+        import warnings
+        warnings.filterwarnings(action='error', category=FutureWarning)
+
         cp = df.copy()
-        cp.iloc[1.0:5] = 0
-        self.assert_((cp.iloc[1.0:5] == 0).values.all())
-        self.assert_((cp.iloc[0:1] == df.iloc[0:1]).values.all())
+        def f():
+            cp.iloc[1.0:5] = 0
+        self.assertRaises(FutureWarning, f)
+        def f():
+            result = cp.iloc[1.0:5] == 0
+        self.assertRaises(FutureWarning, f)
+        self.assertTrue(result.values.all())
+        self.assertTrue((cp.iloc[0:1] == df.iloc[0:1]).values.all())
+
+        warnings.filterwarnings(action='ignore', category=FutureWarning)
 
         cp = df.copy()
         cp.iloc[4:5] = 0
-        self.assert_((cp.iloc[4:5] == 0).values.all())
-        self.assert_((cp.iloc[0:4] == df.iloc[0:4]).values.all())
+        self.assertTrue((cp.iloc[4:5] == 0).values.all())
+        self.assertTrue((cp.iloc[0:4] == df.iloc[0:4]).values.all())
 
         # float slicing
         result = df.ix[1.0:5]
@@ -1313,7 +1326,8 @@ class CheckIndexing(object):
 
         cp = df.copy()
         cp.ix[1.0:5.0] = 0
-        self.assert_((cp.ix[1.0:5.0] == 0).values.all())
+        result = cp.ix[1.0:5.0]
+        self.assertTrue((result == 0).values.all())
 
     def test_setitem_single_column_mixed(self):
         df = DataFrame(randn(5, 3), index=['a', 'b', 'c', 'd', 'e'],
diff --git a/pandas/tests/test_indexing.py b/pandas/tests/test_indexing.py
index a105b1779..d89a88138 100644
--- a/pandas/tests/test_indexing.py
+++ b/pandas/tests/test_indexing.py
@@ -3229,48 +3229,92 @@ class TestIndexing(tm.TestCase):
                        tm.makeDateIndex, tm.makePeriodIndex ]:
 
             i = index(5)
+
+            for s in  [ Series(np.arange(len(i)),index=i), DataFrame(np.random.randn(len(i),len(i)),index=i,columns=i) ]:
+                self.assertRaises(FutureWarning, lambda :
+                                  s.iloc[3.0])
+
+                # setting
+                def f():
+                    s.iloc[3.0] = 0
+                self.assertRaises(FutureWarning, f)
+
+            # fallsback to position selection ,series only
             s = Series(np.arange(len(i)),index=i)
-            self.assertRaises(FutureWarning, lambda :
-                              s.iloc[3.0])
+            s[3]
             self.assertRaises(FutureWarning, lambda :
                               s[3.0])
 
-            # this is ok!
-            s[3]
-
         # ints
         i = index(5)
-        s = Series(np.arange(len(i)))
-        self.assertRaises(FutureWarning, lambda :
-                          s.iloc[3.0])
+        for s in [ Series(np.arange(len(i))), DataFrame(np.random.randn(len(i),len(i)),index=i,columns=i) ]:
+            self.assertRaises(FutureWarning, lambda :
+                              s.iloc[3.0])
 
-        # on some arch's this doesn't provide a warning (and thus raise)
-        # and some it does
-        try:
-            s[3.0]
-        except:
-            pass
+            # on some arch's this doesn't provide a warning (and thus raise)
+            # and some it does
+            try:
+                s[3.0]
+            except:
+                pass
+
+            # setting
+            def f():
+                s.iloc[3.0] = 0
+            self.assertRaises(FutureWarning, f)
 
         # floats: these are all ok!
         i = np.arange(5.)
-        s = Series(np.arange(len(i)),index=i)
-        with tm.assert_produces_warning(False):
-            s[3.0]
 
-        with tm.assert_produces_warning(False):
-            s[3]
+        for s in [ Series(np.arange(len(i)),index=i), DataFrame(np.random.randn(len(i),len(i)),index=i,columns=i) ]:
+            with tm.assert_produces_warning(False):
+                s[3.0]
+
+            with tm.assert_produces_warning(False):
+                s[3]
+
+            self.assertRaises(FutureWarning, lambda :
+                              s.iloc[3.0])
+
+            with tm.assert_produces_warning(False):
+                s.iloc[3]
+
+            with tm.assert_produces_warning(False):
+                s.loc[3.0]
 
-        with tm.assert_produces_warning(False):
-            s.iloc[3.0]
+            with tm.assert_produces_warning(False):
+                s.loc[3]
 
-        with tm.assert_produces_warning(False):
-            s.iloc[3]
+            def f():
+                s.iloc[3.0] = 0
+            self.assertRaises(FutureWarning, f)
 
-        with tm.assert_produces_warning(False):
-            s.loc[3.0]
+        # slices
+        for index in [ tm.makeIntIndex, tm.makeFloatIndex,
+                       tm.makeStringIndex, tm.makeUnicodeIndex,
+                       tm.makeDateIndex, tm.makePeriodIndex ]:
 
-        with tm.assert_produces_warning(False):
-            s.loc[3]
+            index = index(5)
+            for s in [ Series(range(5),index=index), DataFrame(np.random.randn(5,2),index=index) ]:
+
+                # getitem
+                self.assertRaises(FutureWarning, lambda :
+                                  s.iloc[3.0:4])
+                self.assertRaises(FutureWarning, lambda :
+                                  s.iloc[3.0:4.0])
+                self.assertRaises(FutureWarning, lambda :
+                                  s.iloc[3:4.0])
+
+                # setitem
+                def f():
+                    s.iloc[3.0:4] = 0
+                self.assertRaises(FutureWarning, f)
+                def f():
+                    s.iloc[3:4.0] = 0
+                self.assertRaises(FutureWarning, f)
+                def f():
+                    s.iloc[3.0:4.0] = 0
+                self.assertRaises(FutureWarning, f)
 
         warnings.filterwarnings(action='ignore', category=FutureWarning)
 

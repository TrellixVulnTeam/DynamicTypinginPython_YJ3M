commit e2563cd602226095f2517133c12833f650046f9d
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Aug 21 22:32:55 2011 -0400

    ENH: copy option in reindex methods. cython fast_unique

diff --git a/RELEASE.rst b/RELEASE.rst
index 262493f58..3a231675d 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -37,7 +37,7 @@ Release notes
   `WidePanel`. See online documentation for more on these
 * Fancy indexing operator on Series / DataFrame, e.g. via .ix operator. Both
   getting and setting of values is supported; however, setting values will only
-  currently work on homogeneously-typed DataFrame objects
+  currently work on homogeneously-typed DataFrame objects. Things like:
   * series.ix[[d1, d2, d3]]
   * frame.ix[5:10, ['C', 'B', 'A']], frame.ix[5:10, 'A':'C']
   * frame.ix[date1:date2]
@@ -87,6 +87,8 @@ Release notes
 * Generic `rolling_apply` moving window function
 * New `drop` method added to `Series`, `DataFrame`, etc. which can drop a set of
   labels from an axis, producing a new object
+* `reindex` methods now sport a `copy` option so that data is not forced to be
+  copied then the resulting object is indexed the same
 
 **Improvements to existing features**
 
@@ -215,6 +217,10 @@ Thanks
 - Tony Roberts
 - Martin Felder
 - John Marino
+- Tim McNamara
+- Justin Berka
+- Dieter Vandenbussche
+
 
 ************************
 pandas 0.3 Release Notes
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index d6c06d2ff..6afe8e4b1 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -947,7 +947,7 @@ class DataFrame(NDFrame):
     #----------------------------------------------------------------------
     # Reindexing
 
-    def reindex(self, index=None, columns=None, method=None):
+    def reindex(self, index=None, columns=None, method=None, copy=True):
         """
         Reindex data inside, optionally filling according to some rule.
 
@@ -961,6 +961,8 @@ class DataFrame(NDFrame):
 
             pad / ffill: propagate last valid observation forward to next valid
             backfill / bfill: use NEXT valid observation to fill gap
+        copy : boolean, default True
+            Return a new object, even if the passed indexes are the same
 
         Returns
         -------
@@ -971,21 +973,29 @@ class DataFrame(NDFrame):
 
         if index is not None:
             index = _ensure_index(index)
-            frame = frame._reindex_index(index, method)
+            frame = frame._reindex_index(index, method, copy)
 
         if columns is not None:
             columns = _ensure_index(columns)
-            frame = frame._reindex_columns(columns)
+            frame = frame._reindex_columns(columns, copy)
 
         return frame
 
-    def _reindex_index(self, new_index, method):
-        if new_index is self.index:
-            return self.copy()
+    def _reindex_index(self, new_index, method, copy):
+        if new_index.equals(self.index):
+            if copy:
+                return self.copy()
+            else:
+                return self
         new_data = self._data.reindex_axis(new_index, method, axis=1)
         return self._constructor(new_data)
 
-    def _reindex_columns(self, new_columns):
+    def _reindex_columns(self, new_columns, copy):
+        if new_columns.equals(self.columns):
+            if copy:
+                return self.copy()
+            else:
+                return self
         new_data = self._data.reindex_axis(new_columns, axis=0)
         return self._constructor(new_data)
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 305907e81..b535ded0a 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -1,6 +1,7 @@
 import numpy as np
 import cPickle
 
+from pandas.core.common import _ensure_index
 import pandas.core.datetools as datetools
 
 #-------------------------------------------------------------------------------
@@ -221,11 +222,12 @@ class NDFrame(PandasObject):
         self._consolidate_inplace()
         return len(self._data.blocks) > 1
 
-    @property
-    def axes(self):
-        return self._data.axes
+    def _reindex_axis(self, new_index, fill_method, axis, copy):
+        new_index = _ensure_index(new_index)
+        cur_axis = self._data.axes[axis]
+        if cur_axis.equals(new_index) and not copy:
+            return self
 
-    def _reindex_axis(self, new_index, fill_method, axis):
         if axis == 0:
             new_data = self._data.reindex_items(new_index)
         else:
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 0f0c662d3..6c609d8ea 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -205,7 +205,7 @@ class WidePanel(Panel, NDFrame):
         self._data = mgr
 
     def _init_dict(self, data, axes, dtype=None):
-        items = axes[0]
+        items, major, minor = axes
 
         # prefilter if items passed
         if items is not None:
@@ -245,10 +245,9 @@ class WidePanel(Panel, NDFrame):
         -------
         WidePanel
         """
-        data, index, columns = _homogenize(data, intersect=intersect,
-                                           dtype=dtype)
+        data, index, columns = _homogenize_dict(data, intersect=intersect,
+                                                dtype=dtype)
         items = Index(sorted(data.keys()))
-
         axes = [items, index, columns]
 
         reshaped_data = {}
@@ -447,7 +446,7 @@ class WidePanel(Panel, NDFrame):
         return frame.reindex(index=index, columns=columns)
 
     def reindex(self, major=None, items=None, minor=None, method=None,
-                major_axis=None, minor_axis=None):
+                major_axis=None, minor_axis=None, copy=True):
         """
         Conform panel to new axis or axes
 
@@ -463,6 +462,8 @@ class WidePanel(Panel, NDFrame):
 
             pad / ffill: propagate last valid observation forward to next valid
             backfill / bfill: use NEXT valid observation to fill gap
+        copy : boolean, default True
+            Return a new object, even if the passed indexes are the same
 
         Returns
         -------
@@ -474,13 +475,13 @@ class WidePanel(Panel, NDFrame):
         minor = _mut_exclusive(minor, minor_axis)
 
         if major is not None:
-            result = result._reindex_axis(major, method, 1)
+            result = result._reindex_axis(major, method, 1, copy)
 
         if minor is not None:
-            result = result._reindex_axis(minor, method, 2)
+            result = result._reindex_axis(minor, method, 2, copy)
 
         if items is not None:
-            result = result._reindex_axis(items, method, 0)
+            result = result._reindex_axis(items, method, 0, copy)
 
         if result is self:
             raise ValueError('Must specify at least one axis')
@@ -1396,7 +1397,7 @@ def _prefix_item(item, prefix=None):
     template = '%s%s'
     return template % (prefix, item)
 
-def _homogenize(frames, intersect=True, dtype=None):
+def _homogenize_dict(frames, intersect=True, dtype=None):
     """
     Conform set of DataFrame-like objects to either an intersection
     of indices / columns or a union.
@@ -1446,7 +1447,6 @@ def _get_combined_columns(frames, intersect=False):
     return Index(sorted(columns))
 
 def _get_combined_index(frames, intersect=False):
-
     # get the set of unique indexes (np.ndarray is unhashable so use the id)
     indexes = dict(((id(frame.index), frame.index)
                     for frame in frames.itervalues()))
@@ -1472,9 +1472,14 @@ def _get_combined_index(frames, intersect=False):
             index = index.intersection(other)
         return index
 
-    union =  np.unique(np.concatenate(tuple(indexes)))
+    union =  _tseries.fast_unique(np.concatenate(tuple(indexes)))
     return Index(union)
 
+def _get_distinct_indexes(indexes):
+    from itertools import groupby
+    indexes = sorted(indexes, key=id)
+    return [gp[0] for _, gp in groupby(indexes, id)]
+
 def pivot(index, columns, values):
     """
     Produce 'pivot' table based on 3 columns of this DataFrame.
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 8a751a5d8..c50669758 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1036,7 +1036,7 @@ class Series(np.ndarray, PandasObject):
 
     applymap = apply
 
-    def reindex(self, index=None, method=None):
+    def reindex(self, index=None, method=None, copy=True):
         """Conform Series to new Index
 
         Parameters
@@ -1045,16 +1045,20 @@ class Series(np.ndarray, PandasObject):
             Preferably an Index object (to avoid duplicating data)
         method : {'backfill', 'bfill', 'pad', 'ffill', None}
             Method to use for filling holes in reindexed Series
-
             pad / ffill: propagate last valid observation forward to next valid
             backfill / bfill: use NEXT valid observation to fill gap
+        copy : boolean, default True
+            Return a new object, even if the passed indexes are the same
 
         Returns
         -------
         reindexed : Series
         """
         if self.index.equals(index):
-            return self.copy()
+            if copy:
+                return self.copy()
+            else:
+                return self
 
         index = _ensure_index(index)
         if len(self.index) == 0:
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index e90d0415a..fe62c4831 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -419,7 +419,7 @@ class SparseSeries(Series):
                             sparse_index=self.sp_index,
                             fill_value=self.fill_value)
 
-    def reindex(self, new_index, method=None):
+    def reindex(self, index=None, method=None, copy=True):
         """
         Conform SparseSeries to new Index
 
@@ -429,10 +429,13 @@ class SparseSeries(Series):
         -------
         reindexed : SparseSeries
         """
-        new_index = _ensure_index(new_index)
+        new_index = _ensure_index(index)
 
         if self.index.equals(new_index):
-            return self.copy()
+            if copy:
+                return self.copy()
+            else:
+                return self
 
         if len(self.index) == 0:
             # FIXME: inelegant / slow
@@ -989,9 +992,12 @@ class SparseDataFrame(DataFrame):
         return self._constructor(data=new_data, index=self.index,
                                  columns=self.columns)
 
-    def _reindex_index(self, index, method):
+    def _reindex_index(self, index, method, copy):
         if self.index.equals(index):
-            return self.copy()
+            if copy:
+                return self.copy()
+            else:
+                return self
 
         if len(self.index) == 0:
             return SparseDataFrame(index=index, columns=self.columns)
@@ -1013,7 +1019,7 @@ class SparseDataFrame(DataFrame):
         return SparseDataFrame(new_series, index=index, columns=self.columns,
                                default_fill_value=self.default_fill_value)
 
-    def _reindex_columns(self, columns):
+    def _reindex_columns(self, columns, copy):
         # TODO: fill value handling
         sdict = dict((k, v) for k, v in self.iteritems() if k in columns)
         return SparseDataFrame(sdict, index=self.index, columns=columns,
@@ -1440,7 +1446,7 @@ class SparseWidePanel(WidePanel):
         return lp.sortlevel(level=0)
 
     def reindex(self, major=None, items=None, minor=None, major_axis=None,
-                minor_axis=None):
+                minor_axis=None, copy=False):
         """
 
         Parameters
@@ -1470,6 +1476,9 @@ class SparseWidePanel(WidePanel):
         else:
             new_frames = self._frames
 
+        if copy:
+            new_frames = dict((k, v.copy()) for k, v in new_frames.iteritems())
+
         return SparseWidePanel(new_frames, items=items,
                                major_axis=major,
                                minor_axis=minor,
diff --git a/pandas/src/groupby.pyx b/pandas/src/groupby.pyx
index e5949a6c4..591185084 100644
--- a/pandas/src/groupby.pyx
+++ b/pandas/src/groupby.pyx
@@ -211,6 +211,23 @@ def group_labels2(ndarray[object] values):
 
     return reverse, labels
 
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def fast_unique(ndarray[object] values):
+    cdef:
+        Py_ssize_t i, n = len(values)
+        list uniques = []
+        dict table = {}
+        object val, stub = 0
+
+    for i from 0 <= i < n:
+        val = values[i]
+        if val not in table:
+            table[val] = stub
+            uniques.append(val)
+
+    return np.asarray(sorted(uniques), dtype=object)
+
 ctypedef double_t (* agg_func)(double_t *out, int32_t *counts, double_t *values,
                                int32_t *labels, int start, int end,
                                Py_ssize_t offset)

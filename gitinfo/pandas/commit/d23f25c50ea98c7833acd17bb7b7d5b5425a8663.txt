commit d23f25c50ea98c7833acd17bb7b7d5b5425a8663
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Dec 2 19:05:58 2009 +0000

    Series.interpolate, LongPanel.getAxisDummies improvements
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@63 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index 1ac9e252f..c508d06f3 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -111,6 +111,7 @@ class DateRange(Index):
         Number of periods to generate.
     offset: DateOffset, default is 1 BusinessDay
         Used to determine the dates returned
+    timeRule: timeRule to use
     """
     _cache = {}
     def __new__(cls, fromDate=None, toDate=None, periods=None,
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index db6b71e3b..e1223a07a 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -595,6 +595,24 @@ class WidePanel(Panel):
 
         return self._apply(_std, axis=axis)
 
+    def shift(self, lags, axis='major'):
+        values = self.values
+        items = self.items
+        major_axis = self.major_axis
+        minor_axis = self.minor_axis
+
+        if axis == 'major':
+            values = values[:, :-lags, :]
+            major_axis = major_axis[lags:]
+        elif axis == 'minor':
+            values = values[:, :, :-lags]
+            minor_axis = minor_axis[lags:]
+        else:
+            raise Exception('Invalid axis')
+
+        return WidePanel(values=values, items=items, major_axis=major_axis,
+                         minor_axis=minor_axis)
+
 class LongPanelIndex(object):
     """
     Parameters
@@ -917,8 +935,12 @@ class LongPanel(Panel):
         elif np.isscalar(other):
             pass
 
-    def _combineFrame(self, other, axis=0):
-        pass
+    def _combineFrame(self, other, func, axis=0):
+        wide = self.toWide()
+
+        result = wide._combineFrame(other, func, axis=axis)
+
+        return result.toLong()
 
     def _combinePanel(self, other, func):
         """
@@ -1144,7 +1166,8 @@ class LongPanel(Panel):
         new_values = self.values.take(indexer, axis=1)
         return LongPanel(new_values, intersection, self.index)
 
-    def getAxisDummies(self, axis='minor'):
+    def getAxisDummies(self, axis='minor', transform=None,
+                       prefix=None):
         """
         Construct 1-0 dummy variables corresponding to designated axis
         labels
@@ -1152,7 +1175,14 @@ class LongPanel(Panel):
         Parameters
         ----------
         axis: {'major', 'minor'}, default 'minor'
+        transform: function, default None
 
+            Function to apply to axis labels first. For example, to
+            get "day of week" dummies in a time series regression you might
+            call:
+
+                panel.getAxisDummies(axis='major',
+                                     transform=lambda d: d.weekday())
         Returns
         -------
         LongPanel, item names taken from chosen axis
@@ -1160,26 +1190,54 @@ class LongPanel(Panel):
         if axis == 'minor':
             dim = len(self.minor_axis)
             items = self.minor_axis
+            labels = self.index.minor_labels
         elif axis == 'major':
             dim = len(self.major_axis)
             items = self.major_axis
+            labels = self.index.major_labels
         else:
             raise Exception('Do not recognize axis %s' % axis)
 
-        vals = np.eye(dim, dtype=float)
+        if transform:
+            mapped = np.array([transform(val) for val in items])
+
+            items = np.array(sorted(set(mapped)))
+            labels = mapped[labels]
+            dim = len(items)
+
+        values = np.eye(dim, dtype=float)
+        values = values.take(labels, axis=0)
 
-        return self._makeDummyPanel(vals, items, axis=axis)
+        result = LongPanel(values, items, self.index)
+
+        if prefix is None:
+            prefix = ''
+
+        result = result.addPrefix(prefix)
+
+        return result
 
     def getFrameDummies(self, dataFrame, axis='minor', prefix=None):
+        """
+
+        Returns
+        -------
+        LongPanel
+        """
         if axis == 'minor':
             dataFrame = dataFrame.reindex(self.minor_axis)
+            labels = self.index.minor_labels
         elif axis == 'major':
             dataFrame = dataFrame.reindex(self.major_axis)
+            labels = self.index.major_labels
+
+        values = dataFrame.values.take(labels, axis=0)
+        result = LongPanel(values, dataFrame.columns, self.index)
 
-        items = dataFrame.columns
+        if prefix is not None:
+            result = result.addPrefix(prefix)
 
-        return self._makeDummyPanel(dataFrame.values, items, axis=axis,
-                                    prefix=prefix)
+        return result
 
     def getItemDummies(self, item):
         """
@@ -1207,39 +1265,6 @@ class LongPanel(Panel):
 
         return LongPanel(dummy_mat, distinct_values, self.index)
 
-    def _makeDummyPanel(self, values, items, axis='minor'):
-        """
-        Construct 1-0 dummy variables corresponding to designated axis
-        labels
-
-        Parameters
-        ----------
-        axis: {'major', 'minor'}, default 'minor'
-
-        Returns
-        -------
-        LongPanel, item names taken from chosen axis
-        """
-
-        N, K = values.shape
-
-        if len(items) != K:
-            raise Exception('items length does not match values matrix')
-
-        if axis == 'minor':
-            if len(self.minor_axis) != N:
-                raise Exception('Axis length does not match values matrix')
-            dummy_mat = values.take(self.index.minor_labels, axis=0)
-
-        elif axis == 'major':
-            if len(self.major_axis) != N:
-                raise Exception('Axis length does not match values matrix')
-            dummy_mat = values.take(self.index.major_labels, axis=0)
-        else:
-            raise Exception('Do not recognize axis %s' % axis)
-
-        return LongPanel(dummy_mat, items, self.index)
-
     def applyToAxis(self, f, axis='major', broadcast=False):
         """
         Aggregate over a particular axis
@@ -1310,8 +1335,12 @@ class LongPanel(Panel):
         ----------
         other: LongPanel
         """
-        if other.index is self.index:
-            pass
+        assert(self.index is other.index)
+
+        values = np.concatenate((self.values, other.values), axis=1).copy()
+        items = self.items.tolist() + other.items.tolist()
+
+        return LongPanel(values, items, self.index)
 
     def merge(self, other):
         """
@@ -1324,12 +1353,7 @@ class LongPanel(Panel):
         -------
         LongPanel
         """
-        assert(self.index is other.index)
-
-        values = np.concatenate((self.values, other.values), axis=1).copy()
-        items = self.items.tolist() + other.items.tolist()
-
-        return LongPanel(values, items, self.index)
+        return self.leftJoin(other)
 
     def addPrefix(self, prefix):
         """
diff --git a/pandas/core/series.py b/pandas/core/series.py
index daf2c89e6..5a0af81a4 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -993,6 +993,46 @@ class Series(np.ndarray, Picklable, Groupable):
 
         return self.reindex(dateRange, fillMethod=fillMethod)
 
+    def interpolate(self, method='linear'):
+        """
+        Interpolate missing values (after the first valid value)
+
+        Parameters
+        ----------
+        method: {'linear', 'time'}
+            Interpolation method.
+
+            Time interpolation works on daily and higher resolution
+            data to interpolate given length of interval
+
+        Returns
+        -------
+        Series with values interpolated
+        """
+        if method == 'time':
+            if not isinstance(self, TimeSeries):
+                raise Exception('time-weighted interpolation only works'
+                                'on TimeSeries')
+            inds = np.array([d.toordinal() for d in self.index])
+        else:
+            inds = np.arange(len(self))
+
+        values = self.view(np.ndarray)
+
+        invalid = isnull(values)
+        valid = -invalid
+
+        firstIndex = valid.argmax()
+        valid = valid[firstIndex:]
+        invalid = invalid[firstIndex:]
+        inds = inds[firstIndex:]
+
+        result = values.copy()
+        result[firstIndex:][invalid] = np.interp(inds[invalid], inds[valid],
+                                                 values[firstIndex:][valid])
+
+        return Series(result, index=self.index)
+
     def reindex(self, newIndex, fillMethod=None):
         """Overloaded version of reindex for TimeSeries. Supports filling
         with values based on new index.
@@ -1021,18 +1061,13 @@ class Series(np.ndarray, Picklable, Groupable):
             idxMap = self.index.indexMap
 
             if self.dtype == float:
-                return self.__class__(tseries.reindex(newIndex, self, idxMap),
-                                      index=newIndex)
+                vals = tseries.reindex(newIndex, self, idxMap)
             elif self.dtype == int:
                 # This could be unsafe, but NaN will not work in int arrays.
-                reindexed = tseries.reindex(newIndex, self.astype(float),
-                                            idxMap)
-                return self.__class__(reindexed, index=newIndex)
-
+                vals = tseries.reindex(newIndex, self.astype(float), idxMap)
             else:
                 if self.dtype.type == np.object_:
-                    result = tseries.reindexObj(newIndex, self, idxMap)
-                    return self.__class__(result, index=newIndex)
+                    vals = tseries.reindexObj(newIndex, self, idxMap)
                 else:
                     thisVals = self.view(np.ndarray).astype(object)
                     vals = tseries.reindexObj(newIndex, thisVals, idxMap)
@@ -1040,7 +1075,7 @@ class Series(np.ndarray, Picklable, Groupable):
                     if not isnull(vals).any():
                         vals = vals.astype(self.dtype)
 
-                    return self.__class__(vals, index=newIndex)
+            return self.__class__(vals, index=newIndex)
 
         if not isinstance(newIndex, Index):
             newIndex = Index(newIndex)

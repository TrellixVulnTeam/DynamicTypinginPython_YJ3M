commit e4b67ca725db373afe8f4565672eb16e1e8e3b31
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Fri Oct 12 14:50:47 2018 -0700

    REF: Simplify Period/Datetime Array/Index constructors (#23093)

diff --git a/pandas/core/arrays/datetimelike.py b/pandas/core/arrays/datetimelike.py
index 73c0c3c50..37fc451ba 100644
--- a/pandas/core/arrays/datetimelike.py
+++ b/pandas/core/arrays/datetimelike.py
@@ -18,6 +18,7 @@ from pandas.tseries import frequencies
 from pandas.tseries.offsets import Tick, DateOffset
 
 from pandas.core.dtypes.common import (
+    pandas_dtype,
     needs_i8_conversion,
     is_list_like,
     is_offsetlike,
@@ -901,3 +902,34 @@ def validate_tz_from_dtype(dtype, tz):
         except TypeError:
             pass
     return tz
+
+
+def validate_dtype_freq(dtype, freq):
+    """
+    If both a dtype and a freq are available, ensure they match.  If only
+    dtype is available, extract the implied freq.
+
+    Parameters
+    ----------
+    dtype : dtype
+    freq : DateOffset or None
+
+    Returns
+    -------
+    freq : DateOffset
+
+    Raises
+    ------
+    ValueError : non-period dtype
+    IncompatibleFrequency : mismatch between dtype and freq
+    """
+    if dtype is not None:
+        dtype = pandas_dtype(dtype)
+        if not is_period_dtype(dtype):
+            raise ValueError('dtype must be PeriodDtype')
+        if freq is None:
+            freq = dtype.freq
+        elif freq != dtype.freq:
+            raise IncompatibleFrequency('specified freq and dtype '
+                                        'are different')
+    return freq
diff --git a/pandas/core/arrays/datetimes.py b/pandas/core/arrays/datetimes.py
index 7daaa8de1..4c7592713 100644
--- a/pandas/core/arrays/datetimes.py
+++ b/pandas/core/arrays/datetimes.py
@@ -222,6 +222,12 @@ class DatetimeArrayMixin(dtl.DatetimeLikeArrayMixin):
     @classmethod
     def _generate_range(cls, start, end, periods, freq, tz=None,
                         normalize=False, ambiguous='raise', closed=None):
+
+        periods = dtl.validate_periods(periods)
+        if freq is None and any(x is None for x in [periods, start, end]):
+            raise ValueError('Must provide freq argument if no data is '
+                             'supplied')
+
         if com.count_not_none(start, end, periods, freq) != 3:
             raise ValueError('Of the four parameters: start, end, periods, '
                              'and freq, exactly three must be specified')
@@ -264,7 +270,7 @@ class DatetimeArrayMixin(dtl.DatetimeLikeArrayMixin):
         if freq is not None:
             if cls._use_cached_range(freq, _normalized, start, end):
                 # Currently always False; never hit
-                # Should be reimplemented as apart of GH 17914
+                # Should be reimplemented as a part of GH#17914
                 index = cls._cached_range(start, end, periods=periods,
                                           freq=freq)
             else:
diff --git a/pandas/core/arrays/period.py b/pandas/core/arrays/period.py
index 6d13fb9ec..d32ff76c0 100644
--- a/pandas/core/arrays/period.py
+++ b/pandas/core/arrays/period.py
@@ -27,6 +27,7 @@ import pandas.core.common as com
 from pandas.tseries import frequencies
 from pandas.tseries.offsets import Tick, DateOffset
 
+from pandas.core.arrays import datetimelike as dtl
 from pandas.core.arrays.datetimelike import DatetimeLikeArrayMixin
 
 
@@ -132,7 +133,7 @@ class PeriodArrayMixin(DatetimeLikeArrayMixin):
             # TODO: what if it has tz?
             values = dt64arr_to_periodarr(values, freq)
 
-        return cls._simple_new(values, freq, **kwargs)
+        return cls._simple_new(values, freq=freq, **kwargs)
 
     @classmethod
     def _simple_new(cls, values, freq=None, **kwargs):
@@ -141,21 +142,27 @@ class PeriodArrayMixin(DatetimeLikeArrayMixin):
         Ordinals in an ndarray are fastpath-ed to `_from_ordinals`
         """
 
+        if is_period_dtype(values):
+            freq = dtl.validate_dtype_freq(values.dtype, freq)
+            values = values.asi8
+
         if not is_integer_dtype(values):
             values = np.array(values, copy=False)
             if len(values) > 0 and is_float_dtype(values):
                 raise TypeError("{cls} can't take floats"
                                 .format(cls=cls.__name__))
-            return cls(values, freq=freq)
+            return cls(values, freq=freq, **kwargs)
 
-        return cls._from_ordinals(values, freq)
+        return cls._from_ordinals(values, freq=freq, **kwargs)
 
     @classmethod
-    def _from_ordinals(cls, values, freq=None):
+    def _from_ordinals(cls, values, freq=None, **kwargs):
         """
         Values should be int ordinals
         `__new__` & `_simple_new` cooerce to ordinals and call this method
         """
+        # **kwargs are included so that the signature matches PeriodIndex,
+        #  letting us share _simple_new
 
         values = np.array(values, dtype='int64', copy=False)
 
diff --git a/pandas/core/arrays/timedeltas.py b/pandas/core/arrays/timedeltas.py
index df9e57cb5..4904a90ab 100644
--- a/pandas/core/arrays/timedeltas.py
+++ b/pandas/core/arrays/timedeltas.py
@@ -131,15 +131,6 @@ class TimedeltaArrayMixin(dtl.DatetimeLikeArrayMixin):
 
         freq, freq_infer = dtl.maybe_infer_freq(freq)
 
-        if values is None:
-            # TODO: Remove this block and associated kwargs; GH#20535
-            if freq is None and com._any_none(periods, start, end):
-                raise ValueError('Must provide freq argument if no data is '
-                                 'supplied')
-            periods = dtl.validate_periods(periods)
-            return cls._generate_range(start, end, periods, freq,
-                                       closed=closed)
-
         result = cls._simple_new(values, freq=freq)
         if freq_infer:
             inferred = result.inferred_freq
@@ -151,6 +142,12 @@ class TimedeltaArrayMixin(dtl.DatetimeLikeArrayMixin):
     @classmethod
     def _generate_range(cls, start, end, periods, freq, closed=None, **kwargs):
         # **kwargs are for compat with TimedeltaIndex, which includes `name`
+
+        periods = dtl.validate_periods(periods)
+        if freq is None and any(x is None for x in [periods, start, end]):
+            raise ValueError('Must provide freq argument if no data is '
+                             'supplied')
+
         if com.count_not_none(start, end, periods, freq) != 3:
             raise ValueError('Of the four parameters: start, end, periods, '
                              'and freq, exactly three must be specified')
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index 87009d692..70140d2d9 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -241,10 +241,6 @@ class DatetimeIndex(DatetimeArrayMixin, DatelikeOps, TimelikeOps,
 
         if data is None:
             # TODO: Remove this block and associated kwargs; GH#20535
-            if freq is None and com._any_none(periods, start, end):
-                raise ValueError('Must provide freq argument if no data is '
-                                 'supplied')
-            periods = dtl.validate_periods(periods)
             return cls._generate_range(start, end, periods, name, freq,
                                        tz=tz, normalize=normalize,
                                        closed=closed, ambiguous=ambiguous)
diff --git a/pandas/core/indexes/period.py b/pandas/core/indexes/period.py
index bfb69b244..f452a57e8 100644
--- a/pandas/core/indexes/period.py
+++ b/pandas/core/indexes/period.py
@@ -8,7 +8,6 @@ from pandas.core.dtypes.common import (
     is_integer,
     is_float,
     is_integer_dtype,
-    is_float_dtype,
     is_scalar,
     is_datetime64_dtype,
     is_datetime64_any_dtype,
@@ -171,15 +170,7 @@ class PeriodIndex(PeriodArrayMixin, DatelikeOps, DatetimeIndexOpsMixin,
         if name is None and hasattr(data, 'name'):
             name = data.name
 
-        if dtype is not None:
-            dtype = pandas_dtype(dtype)
-            if not is_period_dtype(dtype):
-                raise ValueError('dtype must be PeriodDtype')
-            if freq is None:
-                freq = dtype.freq
-            elif freq != dtype.freq:
-                msg = 'specified freq and dtype are different'
-                raise IncompatibleFrequency(msg)
+        freq = dtl.validate_dtype_freq(dtype, freq)
 
         # coerce freq to freq object, otherwise it can be coerced elementwise
         # which is slow
@@ -192,7 +183,7 @@ class PeriodIndex(PeriodArrayMixin, DatelikeOps, DatetimeIndexOpsMixin,
             else:
                 data, freq = cls._generate_range(start, end, periods,
                                                  freq, fields)
-            return cls._from_ordinals(data, name=name, freq=freq)
+            return cls._simple_new(data, name=name, freq=freq)
 
         if isinstance(data, PeriodIndex):
             if freq is None or freq == data.freq:  # no freq change
@@ -208,7 +199,7 @@ class PeriodIndex(PeriodArrayMixin, DatelikeOps, DatetimeIndexOpsMixin,
         # not array / index
         if not isinstance(data, (np.ndarray, PeriodIndex,
                                  DatetimeIndex, Int64Index)):
-            if is_scalar(data) or isinstance(data, Period):
+            if is_scalar(data):
                 cls._scalar_data_error(data)
 
             # other iterable of some kind
@@ -220,7 +211,7 @@ class PeriodIndex(PeriodArrayMixin, DatelikeOps, DatetimeIndexOpsMixin,
         # datetime other than period
         if is_datetime64_dtype(data.dtype):
             data = dt64arr_to_periodarr(data, freq, tz)
-            return cls._from_ordinals(data, name=name, freq=freq)
+            return cls._simple_new(data, name=name, freq=freq)
 
         # check not floats
         if infer_dtype(data) == 'floating' and len(data) > 0:
@@ -231,33 +222,15 @@ class PeriodIndex(PeriodArrayMixin, DatelikeOps, DatetimeIndexOpsMixin,
         data = ensure_object(data)
         freq = freq or period.extract_freq(data)
         data = period.extract_ordinals(data, freq)
-        return cls._from_ordinals(data, name=name, freq=freq)
+        return cls._simple_new(data, name=name, freq=freq)
 
     @cache_readonly
     def _engine(self):
         return self._engine_type(lambda: self, len(self))
 
     @classmethod
-    def _simple_new(cls, values, name=None, freq=None, **kwargs):
-        """
-        Values can be any type that can be coerced to Periods.
-        Ordinals in an ndarray are fastpath-ed to `_from_ordinals`
-        """
-        if not is_integer_dtype(values):
-            values = np.array(values, copy=False)
-            if len(values) > 0 and is_float_dtype(values):
-                raise TypeError("PeriodIndex can't take floats")
-            return cls(values, name=name, freq=freq, **kwargs)
-
-        return cls._from_ordinals(values, name, freq, **kwargs)
-
-    @classmethod
-    def _from_ordinals(cls, values, name=None, freq=None, **kwargs):
-        """
-        Values should be int ordinals
-        `__new__` & `_simple_new` cooerce to ordinals and call this method
-        """
-        result = super(PeriodIndex, cls)._from_ordinals(values, freq)
+    def _simple_new(cls, values, freq=None, name=None, **kwargs):
+        result = super(PeriodIndex, cls)._simple_new(values, freq)
 
         result.name = name
         result._reset_identity()
@@ -702,8 +675,8 @@ class PeriodIndex(PeriodArrayMixin, DatelikeOps, DatetimeIndexOpsMixin,
 
     def _apply_meta(self, rawarr):
         if not isinstance(rawarr, PeriodIndex):
-            rawarr = PeriodIndex._from_ordinals(rawarr, freq=self.freq,
-                                                name=self.name)
+            rawarr = PeriodIndex._simple_new(rawarr, freq=self.freq,
+                                             name=self.name)
         return rawarr
 
     def _format_native_types(self, na_rep=u'NaT', date_format=None, **kwargs):
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index d2b523461..de193db84 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -2476,7 +2476,7 @@ class GenericFixed(Fixed):
         if klass == DatetimeIndex:
             def f(values, freq=None, tz=None):
                 # data are already in UTC, localize and convert if tz present
-                result = DatetimeIndex._simple_new(values.values, None,
+                result = DatetimeIndex._simple_new(values.values, name=None,
                                                    freq=freq)
                 if tz is not None:
                     result = result.tz_localize('UTC').tz_convert(tz)
@@ -2484,7 +2484,7 @@ class GenericFixed(Fixed):
             return f
         elif klass == PeriodIndex:
             def f(values, freq=None, tz=None):
-                return PeriodIndex._simple_new(values, None, freq=freq)
+                return PeriodIndex._simple_new(values, name=None, freq=freq)
             return f
 
         return klass
diff --git a/pandas/tests/indexes/period/test_construction.py b/pandas/tests/indexes/period/test_construction.py
index be741592e..d54dac586 100644
--- a/pandas/tests/indexes/period/test_construction.py
+++ b/pandas/tests/indexes/period/test_construction.py
@@ -264,20 +264,20 @@ class TestPeriodIndex(object):
 
     def test_constructor_simple_new(self):
         idx = period_range('2007-01', name='p', periods=2, freq='M')
-        result = idx._simple_new(idx, 'p', freq=idx.freq)
+        result = idx._simple_new(idx, name='p', freq=idx.freq)
         tm.assert_index_equal(result, idx)
 
-        result = idx._simple_new(idx.astype('i8'), 'p', freq=idx.freq)
+        result = idx._simple_new(idx.astype('i8'), name='p', freq=idx.freq)
         tm.assert_index_equal(result, idx)
 
         result = idx._simple_new([pd.Period('2007-01', freq='M'),
                                   pd.Period('2007-02', freq='M')],
-                                 'p', freq=idx.freq)
+                                 name='p', freq=idx.freq)
         tm.assert_index_equal(result, idx)
 
         result = idx._simple_new(np.array([pd.Period('2007-01', freq='M'),
                                            pd.Period('2007-02', freq='M')]),
-                                 'p', freq=idx.freq)
+                                 name='p', freq=idx.freq)
         tm.assert_index_equal(result, idx)
 
     def test_constructor_simple_new_empty(self):

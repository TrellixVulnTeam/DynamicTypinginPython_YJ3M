commit 309e1fef435dc8bc04ec84a0f3dff6024bb88879
Author: Jeff Reback <jeff@reback.net>
Date:   Mon Jul 25 19:33:25 2016 -0400

    DEPR: Panel4d and panelND
    
    closes #13564
    
    Author: Jeff Reback <jeff@reback.net>
    
    Closes #13776 from jreback/panelnd and squashes the following commits:
    
    3f55809 [Jeff Reback] DEPR: Panel4d and panelND

diff --git a/doc/source/dsintro.rst b/doc/source/dsintro.rst
index bbb43396a..6334167b2 100644
--- a/doc/source/dsintro.rst
+++ b/doc/source/dsintro.rst
@@ -941,6 +941,10 @@ method:
 Panel4D (Experimental)
 ----------------------
 
+.. warning::
+
+   In 0.19.0 ``Panel4D` is deprecated and will be removed in a future version. The recommended way to represent these types of n-dimensional data are with the `xarray package <http://xarray.pydata.org/en/stable/>`__. Pandas provides a :meth:`~Panel4D.to_xarray` method to automate this conversion.
+
 ``Panel4D`` is a 4-Dimensional named container very much like a ``Panel``, but
 having 4 named dimensions. It is intended as a test bed for more N-Dimensional named
 containers.
@@ -1026,6 +1030,10 @@ copy by default unless the data are heterogeneous):
 PanelND (Experimental)
 ----------------------
 
+.. warning::
+
+   In 0.19.0 ``PanelND` is deprecated and will be removed in a future version. The recommended way to represent these types of n-dimensional data are with the `xarray package <http://xarray.pydata.org/en/stable/>`__.
+
 PanelND is a module with a set of factory functions to enable a user to construct N-dimensional named
 containers like Panel4D, with a custom set of axis labels. Thus a domain-specific container can easily be
 created.
diff --git a/doc/source/whatsnew/v0.19.0.txt b/doc/source/whatsnew/v0.19.0.txt
index 089ff94bb..9aa206adc 100644
--- a/doc/source/whatsnew/v0.19.0.txt
+++ b/doc/source/whatsnew/v0.19.0.txt
@@ -613,7 +613,7 @@ Deprecations
 - ``Timestamp.offset`` property (and named arg in the constructor), has been deprecated in favor of ``freq`` (:issue:`12160`)
 - ``pd.tseries.util.pivot_annual`` is deprecated. Use ``pivot_table`` as alternative, an example is :ref:`here <cookbook.pivot>` (:issue:`736`)
 - ``pd.tseries.util.isleapyear`` has been deprecated and will be removed in a subsequent release. Datetime-likes now have a ``.is_leap_year`` property. (:issue:`13727`)
-
+- ``Panel4D`` and ``PanelND`` constructors are deprecated and will be removed in a future version. The recommended way to represent these types of n-dimensional data are with the `xarray package <http://xarray.pydata.org/en/stable/>`__. Pandas provides a :meth:`~Panel4D.to_xarray` method to automate this conversion. (:issue:`13564`)
 
 .. _whatsnew_0190.prior_deprecations:
 
diff --git a/pandas/api/tests/test_api.py b/pandas/api/tests/test_api.py
index 0aefdbeae..8143f925a 100644
--- a/pandas/api/tests/test_api.py
+++ b/pandas/api/tests/test_api.py
@@ -58,11 +58,10 @@ class TestPDApi(Base, tm.TestCase):
 
     # these are already deprecated; awaiting removal
     deprecated_classes = ['SparsePanel', 'TimeSeries', 'WidePanel',
-                          'SparseTimeSeries']
+                          'SparseTimeSeries', 'Panel4D']
 
     # these should be deperecated in the future
-    deprecated_classes_in_future = ['Panel', 'Panel4D',
-                                    'SparseList', 'Term']
+    deprecated_classes_in_future = ['SparseList', 'Term', 'Panel']
 
     # these should be removed from top-level namespace
     remove_classes_from_top_level_namespace = ['Expr']
diff --git a/pandas/core/common.py b/pandas/core/common.py
index 99dd2e9f5..054b899f1 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -14,7 +14,7 @@ from pandas import compat
 from pandas.compat import long, zip, iteritems
 from pandas.core.config import get_option
 from pandas.types.generic import ABCSeries
-from pandas.types.common import _NS_DTYPE, is_integer
+from pandas.types.common import _NS_DTYPE
 from pandas.types.inference import _iterable_not_string
 from pandas.types.missing import isnull
 from pandas.api import types
@@ -31,7 +31,7 @@ for t in [t for t in dir(types) if not t.startswith('_')]:
             warnings.warn("pandas.core.common.{t} is deprecated. "
                           "import from the public API: "
                           "pandas.api.types.{t} instead".format(t=t),
-                          FutureWarning, stacklevel=2)
+                          FutureWarning, stacklevel=3)
             return getattr(types, t)(*args, **kwargs)
         return wrapper
 
@@ -57,7 +57,7 @@ for t in ['is_datetime_arraylike',
                           "These are not longer public API functions, "
                           "but can be imported from "
                           "pandas.types.common.{t} instead".format(t=t),
-                          FutureWarning, stacklevel=2)
+                          FutureWarning, stacklevel=3)
             return getattr(common, t)(*args, **kwargs)
         return wrapper
 
@@ -578,7 +578,7 @@ def _random_state(state=None):
     np.random.RandomState
     """
 
-    if is_integer(state):
+    if types.is_integer(state):
         return np.random.RandomState(state)
     elif isinstance(state, np.random.RandomState):
         return state
diff --git a/pandas/core/panel4d.py b/pandas/core/panel4d.py
index 33bd79195..f32de29c5 100644
--- a/pandas/core/panel4d.py
+++ b/pandas/core/panel4d.py
@@ -1,5 +1,6 @@
 """ Panel4D: a 4-d dict like collection of panels """
 
+import warnings
 from pandas.core.panelnd import create_nd_panel_factory
 from pandas.core.panel import Panel
 
@@ -18,6 +19,11 @@ Panel4D = create_nd_panel_factory(klass_name='Panel4D',
     having 4 named dimensions. It is intended as a test bed for more
     N-Dimensional named containers.
 
+    DEPRECATED. Panel4D is deprecated and will be removed in a future version.
+    The recommended way to represent these types of n-dimensional data are with
+    the `xarray package <http://xarray.pydata.org/en/stable/>`__.
+    Pandas provides a `.to_xarray()` method to automate this conversion.
+
     Parameters
     ----------
     data : ndarray (labels x items x major x minor), or dict of Panels
@@ -37,6 +43,15 @@ Panel4D = create_nd_panel_factory(klass_name='Panel4D',
 def panel4d_init(self, data=None, labels=None, items=None, major_axis=None,
                  minor_axis=None, copy=False, dtype=None):
 
+    # deprecation GH13564
+    warnings.warn("\nPanel4D is deprecated and will be removed in a "
+                  "future version.\nThe recommended way to represent "
+                  "these types of n-dimensional data are with\n"
+                  "the `xarray package "
+                  "<http://xarray.pydata.org/en/stable/>`__.\n"
+                  "Pandas provides a `.to_xarray()` method to help "
+                  "automate this conversion.\n",
+                  FutureWarning, stacklevel=2)
     self._init_data(data=data, labels=labels, items=items,
                     major_axis=major_axis, minor_axis=minor_axis, copy=copy,
                     dtype=dtype)
diff --git a/pandas/core/panelnd.py b/pandas/core/panelnd.py
index 04fbaab30..26ceeea65 100644
--- a/pandas/core/panelnd.py
+++ b/pandas/core/panelnd.py
@@ -1,5 +1,6 @@
 """ Factory methods to create N-D panels """
 
+import warnings
 from pandas.compat import zip
 import pandas.compat as compat
 
@@ -8,6 +9,11 @@ def create_nd_panel_factory(klass_name, orders, slices, slicer, aliases=None,
                             stat_axis=2, info_axis=0, ns=None):
     """ manufacture a n-d class:
 
+    DEPRECATED. Panelnd is deprecated and will be removed in a future version.
+    The recommended way to represent these types of n-dimensional data are with
+    the `xarray package <http://xarray.pydata.org/en/stable/>`__.
+    Pandas provides a `.to_xarray()` method to automate this conversion.
+
     Parameters
     ----------
     klass_name : the klass name
@@ -44,6 +50,18 @@ def create_nd_panel_factory(klass_name, orders, slices, slicer, aliases=None,
 
     # define the methods ####
     def __init__(self, *args, **kwargs):
+
+        # deprecation GH13564
+        warnings.warn("\n{klass} is deprecated and will be removed in a "
+                      "future version.\nThe recommended way to represent "
+                      "these types of n-dimensional data are with the\n"
+                      "`xarray package "
+                      "<http://xarray.pydata.org/en/stable/>`__.\n"
+                      "Pandas provides a `.to_xarray()` method to help "
+                      "automate this conversion.\n".format(
+                          klass=self.__class__.__name__),
+                      FutureWarning, stacklevel=2)
+
         if not (kwargs.get('data') or len(args)):
             raise Exception("must supply at least a data argument to [%s]" %
                             klass_name)
diff --git a/pandas/io/tests/test_packers.py b/pandas/io/tests/test_packers.py
index 0a491a69a..fe5972d35 100644
--- a/pandas/io/tests/test_packers.py
+++ b/pandas/io/tests/test_packers.py
@@ -1,6 +1,5 @@
 import nose
 
-import warnings
 import os
 import datetime
 import numpy as np
@@ -545,7 +544,8 @@ class TestSparse(TestPackers):
 
     def test_sparse_panel(self):
 
-        with warnings.catch_warnings(record=True):
+        with tm.assert_produces_warning(FutureWarning,
+                                        check_stacklevel=False):
 
             items = ['x', 'y', 'z']
             p = Panel(dict((i, tm.makeDataFrame().ix[:2, :2]) for i in items))
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index ab5362da2..89d2f13f2 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -133,13 +133,15 @@ def _maybe_remove(store, key):
         pass
 
 
-def compat_assert_produces_warning(w, f):
+@contextmanager
+def compat_assert_produces_warning(w):
     """ don't produce a warning under PY3 """
     if compat.PY3:
-        f()
+        yield
     else:
-        with tm.assert_produces_warning(expected_warning=w):
-            f()
+        with tm.assert_produces_warning(expected_warning=w,
+                                        check_stacklevel=False):
+            yield
 
 
 class Base(tm.TestCase):
@@ -808,28 +810,30 @@ class TestHDFStore(Base, tm.TestCase):
             assert_panel_equal(store['wp1'], wp)
 
             # ndim
-            p4d = tm.makePanel4D()
-            _maybe_remove(store, 'p4d')
-            store.append('p4d', p4d.ix[:, :, :10, :])
-            store.append('p4d', p4d.ix[:, :, 10:, :])
-            assert_panel4d_equal(store['p4d'], p4d)
-
-            # test using axis labels
-            _maybe_remove(store, 'p4d')
-            store.append('p4d', p4d.ix[:, :, :10, :], axes=[
-                'items', 'major_axis', 'minor_axis'])
-            store.append('p4d', p4d.ix[:, :, 10:, :], axes=[
-                'items', 'major_axis', 'minor_axis'])
-            assert_panel4d_equal(store['p4d'], p4d)
-
-            # test using differnt number of items on each axis
-            p4d2 = p4d.copy()
-            p4d2['l4'] = p4d['l1']
-            p4d2['l5'] = p4d['l1']
-            _maybe_remove(store, 'p4d2')
-            store.append(
-                'p4d2', p4d2, axes=['items', 'major_axis', 'minor_axis'])
-            assert_panel4d_equal(store['p4d2'], p4d2)
+            with tm.assert_produces_warning(FutureWarning,
+                                            check_stacklevel=False):
+                p4d = tm.makePanel4D()
+                _maybe_remove(store, 'p4d')
+                store.append('p4d', p4d.ix[:, :, :10, :])
+                store.append('p4d', p4d.ix[:, :, 10:, :])
+                assert_panel4d_equal(store['p4d'], p4d)
+
+                # test using axis labels
+                _maybe_remove(store, 'p4d')
+                store.append('p4d', p4d.ix[:, :, :10, :], axes=[
+                    'items', 'major_axis', 'minor_axis'])
+                store.append('p4d', p4d.ix[:, :, 10:, :], axes=[
+                    'items', 'major_axis', 'minor_axis'])
+                assert_panel4d_equal(store['p4d'], p4d)
+
+                # test using differnt number of items on each axis
+                p4d2 = p4d.copy()
+                p4d2['l4'] = p4d['l1']
+                p4d2['l5'] = p4d['l1']
+                _maybe_remove(store, 'p4d2')
+                store.append(
+                    'p4d2', p4d2, axes=['items', 'major_axis', 'minor_axis'])
+                assert_panel4d_equal(store['p4d2'], p4d2)
 
             # test using differt order of items on the non-index axes
             _maybe_remove(store, 'wp1')
@@ -1220,72 +1224,74 @@ class TestHDFStore(Base, tm.TestCase):
             self.assertRaises(ValueError, store.append, 'df', df)
 
     def test_ndim_indexables(self):
-        """ test using ndim tables in new ways"""
-
-        with ensure_clean_store(self.path) as store:
-
-            p4d = tm.makePanel4D()
-
-            def check_indexers(key, indexers):
-                for i, idx in enumerate(indexers):
-                    self.assertTrue(getattr(getattr(
-                        store.root, key).table.description, idx)._v_pos == i)
-
-            # append then change (will take existing schema)
-            indexers = ['items', 'major_axis', 'minor_axis']
-
-            _maybe_remove(store, 'p4d')
-            store.append('p4d', p4d.ix[:, :, :10, :], axes=indexers)
-            store.append('p4d', p4d.ix[:, :, 10:, :])
-            assert_panel4d_equal(store.select('p4d'), p4d)
-            check_indexers('p4d', indexers)
-
-            # same as above, but try to append with differnt axes
-            _maybe_remove(store, 'p4d')
-            store.append('p4d', p4d.ix[:, :, :10, :], axes=indexers)
-            store.append('p4d', p4d.ix[:, :, 10:, :], axes=[
-                'labels', 'items', 'major_axis'])
-            assert_panel4d_equal(store.select('p4d'), p4d)
-            check_indexers('p4d', indexers)
-
-            # pass incorrect number of axes
-            _maybe_remove(store, 'p4d')
-            self.assertRaises(ValueError, store.append, 'p4d', p4d.ix[
-                :, :, :10, :], axes=['major_axis', 'minor_axis'])
-
-            # different than default indexables #1
-            indexers = ['labels', 'major_axis', 'minor_axis']
-            _maybe_remove(store, 'p4d')
-            store.append('p4d', p4d.ix[:, :, :10, :], axes=indexers)
-            store.append('p4d', p4d.ix[:, :, 10:, :])
-            assert_panel4d_equal(store['p4d'], p4d)
-            check_indexers('p4d', indexers)
-
-            # different than default indexables #2
-            indexers = ['major_axis', 'labels', 'minor_axis']
-            _maybe_remove(store, 'p4d')
-            store.append('p4d', p4d.ix[:, :, :10, :], axes=indexers)
-            store.append('p4d', p4d.ix[:, :, 10:, :])
-            assert_panel4d_equal(store['p4d'], p4d)
-            check_indexers('p4d', indexers)
-
-            # partial selection
-            result = store.select('p4d', ['labels=l1'])
-            expected = p4d.reindex(labels=['l1'])
-            assert_panel4d_equal(result, expected)
-
-            # partial selection2
-            result = store.select('p4d', [Term(
-                'labels=l1'), Term('items=ItemA'), Term('minor_axis=B')])
-            expected = p4d.reindex(
-                labels=['l1'], items=['ItemA'], minor_axis=['B'])
-            assert_panel4d_equal(result, expected)
-
-            # non-existant partial selection
-            result = store.select('p4d', [Term(
-                'labels=l1'), Term('items=Item1'), Term('minor_axis=B')])
-            expected = p4d.reindex(labels=['l1'], items=[], minor_axis=['B'])
-            assert_panel4d_equal(result, expected)
+        # test using ndim tables in new ways
+
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            with ensure_clean_store(self.path) as store:
+
+                p4d = tm.makePanel4D()
+
+                def check_indexers(key, indexers):
+                    for i, idx in enumerate(indexers):
+                        descr = getattr(store.root, key).table.description
+                        self.assertTrue(getattr(descr, idx)._v_pos == i)
+
+                # append then change (will take existing schema)
+                indexers = ['items', 'major_axis', 'minor_axis']
+
+                _maybe_remove(store, 'p4d')
+                store.append('p4d', p4d.ix[:, :, :10, :], axes=indexers)
+                store.append('p4d', p4d.ix[:, :, 10:, :])
+                assert_panel4d_equal(store.select('p4d'), p4d)
+                check_indexers('p4d', indexers)
+
+                # same as above, but try to append with differnt axes
+                _maybe_remove(store, 'p4d')
+                store.append('p4d', p4d.ix[:, :, :10, :], axes=indexers)
+                store.append('p4d', p4d.ix[:, :, 10:, :], axes=[
+                    'labels', 'items', 'major_axis'])
+                assert_panel4d_equal(store.select('p4d'), p4d)
+                check_indexers('p4d', indexers)
+
+                # pass incorrect number of axes
+                _maybe_remove(store, 'p4d')
+                self.assertRaises(ValueError, store.append, 'p4d', p4d.ix[
+                    :, :, :10, :], axes=['major_axis', 'minor_axis'])
+
+                # different than default indexables #1
+                indexers = ['labels', 'major_axis', 'minor_axis']
+                _maybe_remove(store, 'p4d')
+                store.append('p4d', p4d.ix[:, :, :10, :], axes=indexers)
+                store.append('p4d', p4d.ix[:, :, 10:, :])
+                assert_panel4d_equal(store['p4d'], p4d)
+                check_indexers('p4d', indexers)
+
+                # different than default indexables #2
+                indexers = ['major_axis', 'labels', 'minor_axis']
+                _maybe_remove(store, 'p4d')
+                store.append('p4d', p4d.ix[:, :, :10, :], axes=indexers)
+                store.append('p4d', p4d.ix[:, :, 10:, :])
+                assert_panel4d_equal(store['p4d'], p4d)
+                check_indexers('p4d', indexers)
+
+                # partial selection
+                result = store.select('p4d', ['labels=l1'])
+                expected = p4d.reindex(labels=['l1'])
+                assert_panel4d_equal(result, expected)
+
+                # partial selection2
+                result = store.select('p4d', [Term(
+                    'labels=l1'), Term('items=ItemA'), Term('minor_axis=B')])
+                expected = p4d.reindex(
+                    labels=['l1'], items=['ItemA'], minor_axis=['B'])
+                assert_panel4d_equal(result, expected)
+
+                # non-existant partial selection
+                result = store.select('p4d', [Term(
+                    'labels=l1'), Term('items=Item1'), Term('minor_axis=B')])
+                expected = p4d.reindex(labels=['l1'], items=[],
+                                       minor_axis=['B'])
+                assert_panel4d_equal(result, expected)
 
     def test_append_with_strings(self):
 
@@ -1816,24 +1822,27 @@ class TestHDFStore(Base, tm.TestCase):
 
         with ensure_clean_store(self.path) as store:
 
-            # unsuported data types for non-tables
-            p4d = tm.makePanel4D()
-            self.assertRaises(TypeError, store.put, 'p4d', p4d)
+            with tm.assert_produces_warning(FutureWarning,
+                                            check_stacklevel=False):
 
-            # unsuported data types
-            self.assertRaises(TypeError, store.put, 'abc', None)
-            self.assertRaises(TypeError, store.put, 'abc', '123')
-            self.assertRaises(TypeError, store.put, 'abc', 123)
-            self.assertRaises(TypeError, store.put, 'abc', np.arange(5))
+                # unsuported data types for non-tables
+                p4d = tm.makePanel4D()
+                self.assertRaises(TypeError, store.put, 'p4d', p4d)
 
-            df = tm.makeDataFrame()
-            store.append('df', df, chunksize=1)
-            result = store.select('df')
-            tm.assert_frame_equal(result, df)
+                # unsuported data types
+                self.assertRaises(TypeError, store.put, 'abc', None)
+                self.assertRaises(TypeError, store.put, 'abc', '123')
+                self.assertRaises(TypeError, store.put, 'abc', 123)
+                self.assertRaises(TypeError, store.put, 'abc', np.arange(5))
 
-            store.append('df1', df, expectedrows=10)
-            result = store.select('df1')
-            tm.assert_frame_equal(result, df)
+                df = tm.makeDataFrame()
+                store.append('df', df, chunksize=1)
+                result = store.select('df')
+                tm.assert_frame_equal(result, df)
+
+                store.append('df1', df, expectedrows=10)
+                result = store.select('df1')
+                tm.assert_frame_equal(result, df)
 
         # more chunksize in append tests
         def check(obj, comparator):
@@ -1855,8 +1864,9 @@ class TestHDFStore(Base, tm.TestCase):
         p = tm.makePanel()
         check(p, assert_panel_equal)
 
-        p4d = tm.makePanel4D()
-        check(p4d, assert_panel4d_equal)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            p4d = tm.makePanel4D()
+            check(p4d, assert_panel4d_equal)
 
         # empty frame, GH4273
         with ensure_clean_store(self.path) as store:
@@ -2022,19 +2032,20 @@ class TestHDFStore(Base, tm.TestCase):
             store.append('p1_mixed', wp)
             assert_panel_equal(store.select('p1_mixed'), wp)
 
-        # ndim
-        wp = tm.makePanel4D()
-        wp['obj1'] = 'foo'
-        wp['obj2'] = 'bar'
-        wp['bool1'] = wp['l1'] > 0
-        wp['bool2'] = wp['l2'] > 0
-        wp['int1'] = 1
-        wp['int2'] = 2
-        wp = wp.consolidate()
-
-        with ensure_clean_store(self.path) as store:
-            store.append('p4d_mixed', wp)
-            assert_panel4d_equal(store.select('p4d_mixed'), wp)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            # ndim
+            wp = tm.makePanel4D()
+            wp['obj1'] = 'foo'
+            wp['obj2'] = 'bar'
+            wp['bool1'] = wp['l1'] > 0
+            wp['bool2'] = wp['l2'] > 0
+            wp['int1'] = 1
+            wp['int2'] = 2
+            wp = wp.consolidate()
+
+            with ensure_clean_store(self.path) as store:
+                store.append('p4d_mixed', wp)
+                assert_panel4d_equal(store.select('p4d_mixed'), wp)
 
     def test_unimplemented_dtypes_table_columns(self):
 
@@ -2355,29 +2366,34 @@ class TestHDFStore(Base, tm.TestCase):
 
         with ensure_clean_store(self.path) as store:
 
-            df = tm.makeTimeDataFrame()
-            df['string'] = 'foo'
-            df.ix[0:4, 'string'] = 'bar'
-            wp = tm.makePanel()
-            p4d = tm.makePanel4D()
-            store.put('df', df, format='table')
-            store.put('wp', wp, format='table')
-            store.put('p4d', p4d, format='table')
-
-            # some invalid terms
-            self.assertRaises(ValueError, store.select,
-                              'wp', "minor=['A', 'B']")
-            self.assertRaises(ValueError, store.select,
-                              'wp', ["index=['20121114']"])
-            self.assertRaises(ValueError, store.select, 'wp', [
-                              "index=['20121114', '20121114']"])
-            self.assertRaises(TypeError, Term)
-
-            # more invalid
-            self.assertRaises(ValueError, store.select, 'df', 'df.index[3]')
-            self.assertRaises(SyntaxError, store.select, 'df', 'index>')
-            self.assertRaises(ValueError, store.select, 'wp',
-                              "major_axis<'20000108' & minor_axis['A', 'B']")
+            with compat_assert_produces_warning(FutureWarning):
+
+                df = tm.makeTimeDataFrame()
+                df['string'] = 'foo'
+                df.ix[0:4, 'string'] = 'bar'
+                wp = tm.makePanel()
+
+                p4d = tm.makePanel4D()
+                store.put('df', df, format='table')
+                store.put('wp', wp, format='table')
+                store.put('p4d', p4d, format='table')
+
+                # some invalid terms
+                self.assertRaises(ValueError, store.select,
+                                  'wp', "minor=['A', 'B']")
+                self.assertRaises(ValueError, store.select,
+                                  'wp', ["index=['20121114']"])
+                self.assertRaises(ValueError, store.select, 'wp', [
+                    "index=['20121114', '20121114']"])
+                self.assertRaises(TypeError, Term)
+
+                # more invalid
+                self.assertRaises(
+                    ValueError, store.select, 'df', 'df.index[3]')
+                self.assertRaises(SyntaxError, store.select, 'df', 'index>')
+                self.assertRaises(
+                    ValueError, store.select, 'wp',
+                    "major_axis<'20000108' & minor_axis['A', 'B']")
 
         # from the docs
         with ensure_clean_path(self.path) as path:
@@ -2404,12 +2420,16 @@ class TestHDFStore(Base, tm.TestCase):
         with ensure_clean_store(self.path) as store:
 
             wp = tm.makePanel()
-            p4d = tm.makePanel4D()
             wpneg = Panel.fromDict({-1: tm.makeDataFrame(),
                                     0: tm.makeDataFrame(),
                                     1: tm.makeDataFrame()})
+
+            with compat_assert_produces_warning(FutureWarning):
+
+                p4d = tm.makePanel4D()
+                store.put('p4d', p4d, format='table')
+
             store.put('wp', wp, format='table')
-            store.put('p4d', p4d, format='table')
             store.put('wpneg', wpneg, format='table')
 
             # panel
@@ -2425,12 +2445,15 @@ class TestHDFStore(Base, tm.TestCase):
             tm.assert_panel_equal(result, expected)
 
             # p4d
-            result = store.select('p4d', [Term('major_axis<"20000108"'),
-                                          Term("minor_axis=['A', 'B']"),
-                                          Term("items=['ItemA', 'ItemB']")])
-            expected = p4d.truncate(after='20000108').reindex(
-                minor=['A', 'B'], items=['ItemA', 'ItemB'])
-            assert_panel4d_equal(result, expected)
+            with compat_assert_produces_warning(FutureWarning):
+
+                result = store.select('p4d',
+                                      [Term('major_axis<"20000108"'),
+                                       Term("minor_axis=['A', 'B']"),
+                                       Term("items=['ItemA', 'ItemB']")])
+                expected = p4d.truncate(after='20000108').reindex(
+                    minor=['A', 'B'], items=['ItemA', 'ItemB'])
+                assert_panel4d_equal(result, expected)
 
             # back compat invalid terms
             terms = [dict(field='major_axis', op='>', value='20121114'),
@@ -2442,34 +2465,34 @@ class TestHDFStore(Base, tm.TestCase):
                                                 check_stacklevel=False):
                     Term(t)
 
-            # valid terms
-            terms = [
-                ('major_axis=20121114'),
-                ('major_axis>20121114'),
-                (("major_axis=['20121114', '20121114']"),),
-                ('major_axis=datetime.datetime(2012, 11, 14)'),
-                'major_axis> 20121114',
-                'major_axis >20121114',
-                'major_axis > 20121114',
-                (("minor_axis=['A', 'B']"),),
-                (("minor_axis=['A', 'B']"),),
-                ((("minor_axis==['A', 'B']"),),),
-                (("items=['ItemA', 'ItemB']"),),
-                ('items=ItemA'),
-            ]
-
-            for t in terms:
-                store.select('wp', t)
-                store.select('p4d', t)
-
-            # valid for p4d only
-            terms = [
-                (("labels=['l1', 'l2']"),),
-                Term("labels=['l1', 'l2']"),
-            ]
-
-            for t in terms:
-                store.select('p4d', t)
+            with compat_assert_produces_warning(FutureWarning):
+
+                # valid terms
+                terms = [('major_axis=20121114'),
+                         ('major_axis>20121114'),
+                         (("major_axis=['20121114', '20121114']"),),
+                         ('major_axis=datetime.datetime(2012, 11, 14)'),
+                         'major_axis> 20121114',
+                         'major_axis >20121114',
+                         'major_axis > 20121114',
+                         (("minor_axis=['A', 'B']"),),
+                         (("minor_axis=['A', 'B']"),),
+                         ((("minor_axis==['A', 'B']"),),),
+                         (("items=['ItemA', 'ItemB']"),),
+                         ('items=ItemA'),
+                         ]
+
+                for t in terms:
+                    store.select('wp', t)
+                    store.select('p4d', t)
+
+                # valid for p4d only
+                terms = [(("labels=['l1', 'l2']"),),
+                         Term("labels=['l1', 'l2']"),
+                         ]
+
+                for t in terms:
+                    store.select('p4d', t)
 
             with tm.assertRaisesRegexp(TypeError,
                                        'Only named functions are supported'):
@@ -4405,12 +4428,12 @@ class TestHDFStore(Base, tm.TestCase):
 
     def test_legacy_0_10_read(self):
         # legacy from 0.10
-        with ensure_clean_store(
-                tm.get_data_path('legacy_hdf/legacy_0.10.h5'),
-                mode='r') as store:
-            str(store)
-            for k in store.keys():
-                store.select(k)
+        with compat_assert_produces_warning(FutureWarning):
+            path = tm.get_data_path('legacy_hdf/legacy_0.10.h5')
+            with ensure_clean_store(path, mode='r') as store:
+                str(store)
+                for k in store.keys():
+                    store.select(k)
 
     def test_legacy_0_11_read(self):
         # legacy from 0.11
@@ -4429,65 +4452,69 @@ class TestHDFStore(Base, tm.TestCase):
 
     def test_copy(self):
 
-        def do_copy(f=None, new_f=None, keys=None, propindexes=True, **kwargs):
-            try:
-                if f is None:
-                    f = tm.get_data_path(os.path.join('legacy_hdf',
-                                                      'legacy_0.10.h5'))
-
-                store = HDFStore(f, 'r')
-
-                if new_f is None:
-                    import tempfile
-                    fd, new_f = tempfile.mkstemp()
-
-                tstore = store.copy(
-                    new_f, keys=keys, propindexes=propindexes, **kwargs)
+        with compat_assert_produces_warning(FutureWarning):
 
-                # check keys
-                if keys is None:
-                    keys = store.keys()
-                self.assertEqual(set(keys), set(tstore.keys()))
-
-                # check indicies & nrows
-                for k in tstore.keys():
-                    if tstore.get_storer(k).is_table:
-                        new_t = tstore.get_storer(k)
-                        orig_t = store.get_storer(k)
-
-                        self.assertEqual(orig_t.nrows, new_t.nrows)
-
-                        # check propindixes
-                        if propindexes:
-                            for a in orig_t.axes:
-                                if a.is_indexed:
-                                    self.assertTrue(new_t[a.name].is_indexed)
-
-            finally:
-                safe_close(store)
-                safe_close(tstore)
+            def do_copy(f=None, new_f=None, keys=None,
+                        propindexes=True, **kwargs):
                 try:
-                    os.close(fd)
-                except:
-                    pass
-                safe_remove(new_f)
-
-        do_copy()
-        do_copy(keys=['/a', '/b', '/df1_mixed'])
-        do_copy(propindexes=False)
-
-        # new table
-        df = tm.makeDataFrame()
+                    if f is None:
+                        f = tm.get_data_path(os.path.join('legacy_hdf',
+                                                          'legacy_0.10.h5'))
+
+                    store = HDFStore(f, 'r')
+
+                    if new_f is None:
+                        import tempfile
+                        fd, new_f = tempfile.mkstemp()
+
+                    tstore = store.copy(
+                        new_f, keys=keys, propindexes=propindexes, **kwargs)
+
+                    # check keys
+                    if keys is None:
+                        keys = store.keys()
+                    self.assertEqual(set(keys), set(tstore.keys()))
+
+                    # check indicies & nrows
+                    for k in tstore.keys():
+                        if tstore.get_storer(k).is_table:
+                            new_t = tstore.get_storer(k)
+                            orig_t = store.get_storer(k)
+
+                            self.assertEqual(orig_t.nrows, new_t.nrows)
+
+                            # check propindixes
+                            if propindexes:
+                                for a in orig_t.axes:
+                                    if a.is_indexed:
+                                        self.assertTrue(
+                                            new_t[a.name].is_indexed)
+
+                finally:
+                    safe_close(store)
+                    safe_close(tstore)
+                    try:
+                        os.close(fd)
+                    except:
+                        pass
+                    safe_remove(new_f)
+
+            do_copy()
+            do_copy(keys=['/a', '/b', '/df1_mixed'])
+            do_copy(propindexes=False)
+
+            # new table
+            df = tm.makeDataFrame()
 
-        try:
-            path = create_tempfile(self.path)
-            st = HDFStore(path)
-            st.append('df', df, data_columns=['A'])
-            st.close()
-            do_copy(f=path)
-            do_copy(f=path, propindexes=False)
-        finally:
-            safe_remove(path)
+            try:
+                path = create_tempfile(self.path)
+                st = HDFStore(path)
+                st.append('df', df, data_columns=['A'])
+                st.close()
+                do_copy(f=path)
+                do_copy(f=path, propindexes=False)
+            finally:
+                safe_remove(path)
 
     def test_legacy_table_write(self):
         raise nose.SkipTest("cannot write legacy tables")
@@ -4567,12 +4594,10 @@ class TestHDFStore(Base, tm.TestCase):
 
         unicode_values = [u('\u03c3'), u('\u03c3\u03c3')]
 
-        def f():
+        with compat_assert_produces_warning(PerformanceWarning):
             s = Series(np.random.randn(len(unicode_values)), unicode_values)
             self._check_roundtrip(s, tm.assert_series_equal)
 
-        compat_assert_produces_warning(PerformanceWarning, f)
-
     def test_unicode_longer_encoded(self):
         # GH 11234
         char = '\u0394'
@@ -5041,16 +5066,18 @@ class TestHDFComplexValues(Base):
         s = Series(complex128, index=list('abcd'))
         df = DataFrame({'A': s, 'B': s})
         p = Panel({'One': df, 'Two': df})
-        p4d = pd.Panel4D({'i': p, 'ii': p})
 
-        objs = [df, p, p4d]
-        comps = [tm.assert_frame_equal, tm.assert_panel_equal,
-                 tm.assert_panel4d_equal]
-        for obj, comp in zip(objs, comps):
-            with ensure_clean_path(self.path) as path:
-                obj.to_hdf(path, 'obj', format='table')
-                reread = read_hdf(path, 'obj')
-                comp(obj, reread)
+        with compat_assert_produces_warning(FutureWarning):
+            p4d = pd.Panel4D({'i': p, 'ii': p})
+
+            objs = [df, p, p4d]
+            comps = [tm.assert_frame_equal, tm.assert_panel_equal,
+                     tm.assert_panel4d_equal]
+            for obj, comp in zip(objs, comps):
+                with ensure_clean_path(self.path) as path:
+                    obj.to_hdf(path, 'obj', format='table')
+                    reread = read_hdf(path, 'obj')
+                    comp(obj, reread)
 
     def test_complex_indexing_error(self):
         complex128 = np.array([1.0 + 1.0j, 1.0 + 1.0j, 1.0 + 1.0j, 1.0 + 1.0j],
diff --git a/pandas/sparse/panel.py b/pandas/sparse/panel.py
index 0996cd3bd..4370d040d 100644
--- a/pandas/sparse/panel.py
+++ b/pandas/sparse/panel.py
@@ -71,7 +71,7 @@ class SparsePanel(Panel):
 
         # deprecation #11157
         warnings.warn("SparsePanel is deprecated and will be removed in a "
-                      "future version", FutureWarning, stacklevel=2)
+                      "future version", FutureWarning, stacklevel=3)
 
         if frames is None:
             frames = {}
diff --git a/pandas/sparse/tests/test_panel.py b/pandas/sparse/tests/test_panel.py
index e988ddebd..09d861fe0 100644
--- a/pandas/sparse/tests/test_panel.py
+++ b/pandas/sparse/tests/test_panel.py
@@ -55,7 +55,7 @@ class TestSparsePanel(tm.TestCase, test_panel.SafeForLongAndSparse,
             'ItemC': panel_data3(),
             'ItemD': panel_data1(),
         }
-        with tm.assert_produces_warning(FutureWarning):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             self.panel = SparsePanel(self.data_dict)
 
     @staticmethod
@@ -76,12 +76,12 @@ class TestSparsePanel(tm.TestCase, test_panel.SafeForLongAndSparse,
 
     # deprecation GH11157
     def test_deprecation(self):
-        with tm.assert_produces_warning(FutureWarning):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             SparsePanel()
 
     # GH 9272
     def test_constructor_empty(self):
-        with tm.assert_produces_warning(FutureWarning):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
             sp = SparsePanel()
         self.assertEqual(len(sp.items), 0)
         self.assertEqual(len(sp.major_axis), 0)
@@ -104,7 +104,8 @@ class TestSparsePanel(tm.TestCase, test_panel.SafeForLongAndSparse,
 
     def test_dense_to_sparse(self):
         wp = Panel.from_dict(self.data_dict)
-        dwp = wp.to_sparse()
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            dwp = wp.to_sparse()
         tm.assertIsInstance(dwp['ItemA']['A'], SparseSeries)
 
     def test_to_dense(self):
@@ -127,7 +128,8 @@ class TestSparsePanel(tm.TestCase, test_panel.SafeForLongAndSparse,
             _compare_with_dense(self.panel)
             _compare_with_dense(self.panel.reindex(items=['ItemA']))
 
-            with tm.assert_produces_warning(FutureWarning):
+            with tm.assert_produces_warning(FutureWarning,
+                                            check_stacklevel=False):
                 zero_panel = SparsePanel(self.data_dict, default_fill_value=0)
             self.assertRaises(Exception, zero_panel.to_frame)
 
@@ -154,15 +156,18 @@ class TestSparsePanel(tm.TestCase, test_panel.SafeForLongAndSparse,
         self.assertRaises(Exception, self.panel.__setitem__, 'item6', 1)
 
     def test_set_value(self):
-        def _check_loc(item, major, minor, val=1.5):
-            res = self.panel.set_value(item, major, minor, val)
-            self.assertIsNot(res, self.panel)
-            self.assertEqual(res.get_value(item, major, minor), val)
-
-        _check_loc('ItemA', self.panel.major_axis[4], self.panel.minor_axis[3])
-        _check_loc('ItemF', self.panel.major_axis[4], self.panel.minor_axis[3])
-        _check_loc('ItemF', 'foo', self.panel.minor_axis[3])
-        _check_loc('ItemE', 'foo', 'bar')
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            def _check_loc(item, major, minor, val=1.5):
+                res = self.panel.set_value(item, major, minor, val)
+                self.assertIsNot(res, self.panel)
+                self.assertEqual(res.get_value(item, major, minor), val)
+
+            _check_loc('ItemA', self.panel.major_axis[4],
+                       self.panel.minor_axis[3])
+            _check_loc('ItemF', self.panel.major_axis[4],
+                       self.panel.minor_axis[3])
+            _check_loc('ItemF', 'foo', self.panel.minor_axis[3])
+            _check_loc('ItemE', 'foo', 'bar')
 
     def test_delitem_pop(self):
         del self.panel['ItemB']
diff --git a/pandas/tests/test_generic.py b/pandas/tests/test_generic.py
index a53e79439..cdcd8b1bc 100644
--- a/pandas/tests/test_generic.py
+++ b/pandas/tests/test_generic.py
@@ -1532,17 +1532,41 @@ class TestPanel4D(tm.TestCase, Generic):
         tm._skip_if_no_xarray()
         from xarray import DataArray
 
-        p = tm.makePanel4D()
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            p = tm.makePanel4D()
 
-        result = p.to_xarray()
-        self.assertIsInstance(result, DataArray)
-        self.assertEqual(len(result.coords), 4)
-        assert_almost_equal(list(result.coords.keys()),
-                            ['labels', 'items', 'major_axis', 'minor_axis'])
-        self.assertEqual(len(result.dims), 4)
-
-        # non-convertible
-        self.assertRaises(ValueError, lambda: result.to_pandas())
+            result = p.to_xarray()
+            self.assertIsInstance(result, DataArray)
+            self.assertEqual(len(result.coords), 4)
+            assert_almost_equal(list(result.coords.keys()),
+                                ['labels', 'items', 'major_axis',
+                                 'minor_axis'])
+            self.assertEqual(len(result.dims), 4)
+
+            # non-convertible
+            self.assertRaises(ValueError, lambda: result.to_pandas())
+
+# run all the tests, but wrap each in a warning catcher
+for t in ['test_rename', 'test_rename_axis', 'test_get_numeric_data',
+          'test_get_default', 'test_nonzero',
+          'test_numpy_1_7_compat_numeric_methods',
+          'test_downcast', 'test_constructor_compound_dtypes',
+          'test_head_tail',
+          'test_size_compat', 'test_split_compat',
+          'test_unexpected_keyword',
+          'test_stat_unexpected_keyword', 'test_api_compat',
+          'test_stat_non_defaults_args',
+          'test_clip', 'test_truncate_out_of_bounds', 'test_numpy_clip',
+          'test_metadata_propagation']:
+
+    def f():
+        def tester(self):
+            with tm.assert_produces_warning(FutureWarning,
+                                            check_stacklevel=False):
+                return getattr(super(TestPanel4D, self), t)()
+        return tester
+
+    setattr(TestPanel4D, t, f())
 
 
 class TestNDFrame(tm.TestCase):
@@ -1674,8 +1698,9 @@ class TestNDFrame(tm.TestCase):
             tm.assert_frame_equal(df.squeeze(), df)
         for p in [tm.makePanel()]:
             tm.assert_panel_equal(p.squeeze(), p)
-        for p4d in [tm.makePanel4D()]:
-            tm.assert_panel4d_equal(p4d.squeeze(), p4d)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            for p4d in [tm.makePanel4D()]:
+                tm.assert_panel4d_equal(p4d.squeeze(), p4d)
 
         # squeezing
         df = tm.makeTimeDataFrame().reindex(columns=['A'])
@@ -1687,11 +1712,13 @@ class TestNDFrame(tm.TestCase):
         p = tm.makePanel().reindex(items=['ItemA'], minor_axis=['A'])
         tm.assert_series_equal(p.squeeze(), p.ix['ItemA', :, 'A'])
 
-        p4d = tm.makePanel4D().reindex(labels=['label1'])
-        tm.assert_panel_equal(p4d.squeeze(), p4d['label1'])
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            p4d = tm.makePanel4D().reindex(labels=['label1'])
+            tm.assert_panel_equal(p4d.squeeze(), p4d['label1'])
 
-        p4d = tm.makePanel4D().reindex(labels=['label1'], items=['ItemA'])
-        tm.assert_frame_equal(p4d.squeeze(), p4d.ix['label1', 'ItemA'])
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            p4d = tm.makePanel4D().reindex(labels=['label1'], items=['ItemA'])
+            tm.assert_frame_equal(p4d.squeeze(), p4d.ix['label1', 'ItemA'])
 
         # don't fail with 0 length dimensions GH11229 & GH8999
         empty_series = pd.Series([], name='five')
@@ -1726,11 +1753,13 @@ class TestNDFrame(tm.TestCase):
                                   .transpose(1, 2, 0), p)
             tm.assertRaisesRegexp(TypeError, msg, p.transpose,
                                   2, 0, 1, axes=(2, 0, 1))
-        for p4d in [tm.makePanel4D()]:
-            tm.assert_panel4d_equal(p4d.transpose(2, 0, 3, 1)
-                                    .transpose(1, 3, 0, 2), p4d)
-            tm.assertRaisesRegexp(TypeError, msg, p4d.transpose,
-                                  2, 0, 3, 1, axes=(2, 0, 3, 1))
+
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            for p4d in [tm.makePanel4D()]:
+                tm.assert_panel4d_equal(p4d.transpose(2, 0, 3, 1)
+                                        .transpose(1, 3, 0, 2), p4d)
+                tm.assertRaisesRegexp(TypeError, msg, p4d.transpose,
+                                      2, 0, 3, 1, axes=(2, 0, 3, 1))
 
     def test_numpy_transpose(self):
         msg = "the 'axes' parameter is not supported"
@@ -1752,10 +1781,11 @@ class TestNDFrame(tm.TestCase):
             np.transpose(p, axes=(2, 0, 1)),
             axes=(1, 2, 0)), p)
 
-        p4d = tm.makePanel4D()
-        tm.assert_panel4d_equal(np.transpose(
-            np.transpose(p4d, axes=(2, 0, 3, 1)),
-            axes=(1, 3, 0, 2)), p4d)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            p4d = tm.makePanel4D()
+            tm.assert_panel4d_equal(np.transpose(
+                np.transpose(p4d, axes=(2, 0, 3, 1)),
+                axes=(1, 3, 0, 2)), p4d)
 
     def test_take(self):
         indices = [1, 5, -2, 6, 3, -1]
@@ -1780,21 +1810,25 @@ class TestNDFrame(tm.TestCase):
                              major_axis=p.major_axis,
                              minor_axis=p.minor_axis)
             tm.assert_panel_equal(out, expected)
-        for p4d in [tm.makePanel4D()]:
-            out = p4d.take(indices)
-            expected = Panel4D(data=p4d.values.take(indices, axis=0),
-                               labels=p4d.labels.take(indices),
-                               major_axis=p4d.major_axis,
-                               minor_axis=p4d.minor_axis,
-                               items=p4d.items)
-            tm.assert_panel4d_equal(out, expected)
+
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            for p4d in [tm.makePanel4D()]:
+                out = p4d.take(indices)
+                expected = Panel4D(data=p4d.values.take(indices, axis=0),
+                                   labels=p4d.labels.take(indices),
+                                   major_axis=p4d.major_axis,
+                                   minor_axis=p4d.minor_axis,
+                                   items=p4d.items)
+                tm.assert_panel4d_equal(out, expected)
 
     def test_take_invalid_kwargs(self):
         indices = [-3, 2, 0, 1]
         s = tm.makeFloatSeries()
         df = tm.makeTimeDataFrame()
         p = tm.makePanel()
-        p4d = tm.makePanel4D()
+
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            p4d = tm.makePanel4D()
 
         for obj in (s, df, p, p4d):
             msg = "take\(\) got an unexpected keyword argument 'foo'"
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index a37e7ca73..46eba1772 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -157,16 +157,6 @@ class SafeForLongAndSparse(object):
 
         self._check_stat_op('sem', alt)
 
-    # def test_skew(self):
-    #     from scipy.stats import skew
-
-    #     def alt(x):
-    #         if len(x) < 3:
-    #             return np.nan
-    #         return skew(x, bias=False)
-
-    #     self._check_stat_op('skew', alt)
-
     def _check_stat_op(self, name, alternative, obj=None, has_skipna=True):
         if obj is None:
             obj = self.panel
diff --git a/pandas/tests/test_panel4d.py b/pandas/tests/test_panel4d.py
index 16a55c7ec..50ede3f2c 100644
--- a/pandas/tests/test_panel4d.py
+++ b/pandas/tests/test_panel4d.py
@@ -205,20 +205,22 @@ class SafeForSparse(object):
         self.assertEqual(self.panel4d._get_axis_name(3), 'minor_axis')
 
     def test_arith(self):
-        self._test_op(self.panel4d, operator.add)
-        self._test_op(self.panel4d, operator.sub)
-        self._test_op(self.panel4d, operator.mul)
-        self._test_op(self.panel4d, operator.truediv)
-        self._test_op(self.panel4d, operator.floordiv)
-        self._test_op(self.panel4d, operator.pow)
-
-        self._test_op(self.panel4d, lambda x, y: y + x)
-        self._test_op(self.panel4d, lambda x, y: y - x)
-        self._test_op(self.panel4d, lambda x, y: y * x)
-        self._test_op(self.panel4d, lambda x, y: y / x)
-        self._test_op(self.panel4d, lambda x, y: y ** x)
-
-        self.assertRaises(Exception, self.panel4d.__add__, self.panel4d['l1'])
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            self._test_op(self.panel4d, operator.add)
+            self._test_op(self.panel4d, operator.sub)
+            self._test_op(self.panel4d, operator.mul)
+            self._test_op(self.panel4d, operator.truediv)
+            self._test_op(self.panel4d, operator.floordiv)
+            self._test_op(self.panel4d, operator.pow)
+
+            self._test_op(self.panel4d, lambda x, y: y + x)
+            self._test_op(self.panel4d, lambda x, y: y - x)
+            self._test_op(self.panel4d, lambda x, y: y * x)
+            self._test_op(self.panel4d, lambda x, y: y / x)
+            self._test_op(self.panel4d, lambda x, y: y ** x)
+
+            self.assertRaises(Exception, self.panel4d.__add__,
+                              self.panel4d['l1'])
 
     @staticmethod
     def _test_op(panel4d, op):
@@ -235,41 +237,47 @@ class SafeForSparse(object):
                          len(self.panel4d.labels))
 
     def test_combinePanel4d(self):
-        result = self.panel4d.add(self.panel4d)
-        self.assert_panel4d_equal(result, self.panel4d * 2)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = self.panel4d.add(self.panel4d)
+            self.assert_panel4d_equal(result, self.panel4d * 2)
 
     def test_neg(self):
-        self.assert_panel4d_equal(-self.panel4d, self.panel4d * -1)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            self.assert_panel4d_equal(-self.panel4d, self.panel4d * -1)
 
     def test_select(self):
-        p = self.panel4d
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+
+            p = self.panel4d
 
-        # select labels
-        result = p.select(lambda x: x in ('l1', 'l3'), axis='labels')
-        expected = p.reindex(labels=['l1', 'l3'])
-        self.assert_panel4d_equal(result, expected)
+            # select labels
+            result = p.select(lambda x: x in ('l1', 'l3'), axis='labels')
+            expected = p.reindex(labels=['l1', 'l3'])
+            self.assert_panel4d_equal(result, expected)
 
-        # select items
-        result = p.select(lambda x: x in ('ItemA', 'ItemC'), axis='items')
-        expected = p.reindex(items=['ItemA', 'ItemC'])
-        self.assert_panel4d_equal(result, expected)
+            # select items
+            result = p.select(lambda x: x in ('ItemA', 'ItemC'), axis='items')
+            expected = p.reindex(items=['ItemA', 'ItemC'])
+            self.assert_panel4d_equal(result, expected)
 
-        # select major_axis
-        result = p.select(lambda x: x >= datetime(2000, 1, 15), axis='major')
-        new_major = p.major_axis[p.major_axis >= datetime(2000, 1, 15)]
-        expected = p.reindex(major=new_major)
-        self.assert_panel4d_equal(result, expected)
+            # select major_axis
+            result = p.select(lambda x: x >= datetime(2000, 1, 15),
+                              axis='major')
+            new_major = p.major_axis[p.major_axis >= datetime(2000, 1, 15)]
+            expected = p.reindex(major=new_major)
+            self.assert_panel4d_equal(result, expected)
 
-        # select minor_axis
-        result = p.select(lambda x: x in ('D', 'A'), axis=3)
-        expected = p.reindex(minor=['A', 'D'])
-        self.assert_panel4d_equal(result, expected)
+            # select minor_axis
+            result = p.select(lambda x: x in ('D', 'A'), axis=3)
+            expected = p.reindex(minor=['A', 'D'])
+            self.assert_panel4d_equal(result, expected)
 
-        # corner case, empty thing
-        result = p.select(lambda x: x in ('foo',), axis='items')
-        self.assert_panel4d_equal(result, p.reindex(items=[]))
+            # corner case, empty thing
+            result = p.select(lambda x: x in ('foo',), axis='items')
+            self.assert_panel4d_equal(result, p.reindex(items=[]))
 
     def test_get_value(self):
+
         for item in self.panel.items:
             for mjr in self.panel.major_axis[::2]:
                 for mnr in self.panel.minor_axis:
@@ -278,19 +286,21 @@ class SafeForSparse(object):
                     assert_almost_equal(result, expected)
 
     def test_abs(self):
-        result = self.panel4d.abs()
-        expected = np.abs(self.panel4d)
-        self.assert_panel4d_equal(result, expected)
 
-        p = self.panel4d['l1']
-        result = p.abs()
-        expected = np.abs(p)
-        assert_panel_equal(result, expected)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = self.panel4d.abs()
+            expected = np.abs(self.panel4d)
+            self.assert_panel4d_equal(result, expected)
+
+            p = self.panel4d['l1']
+            result = p.abs()
+            expected = np.abs(p)
+            assert_panel_equal(result, expected)
 
-        df = p['ItemA']
-        result = df.abs()
-        expected = np.abs(df)
-        assert_frame_equal(result, expected)
+            df = p['ItemA']
+            result = df.abs()
+            expected = np.abs(df)
+            assert_frame_equal(result, expected)
 
 
 class CheckIndexing(object):
@@ -301,48 +311,50 @@ class CheckIndexing(object):
         self.assertRaises(Exception, self.panel4d.__getitem__, 'ItemQ')
 
     def test_delitem_and_pop(self):
-        expected = self.panel4d['l2']
-        result = self.panel4d.pop('l2')
-        assert_panel_equal(expected, result)
-        self.assertNotIn('l2', self.panel4d.labels)
-
-        del self.panel4d['l3']
-        self.assertNotIn('l3', self.panel4d.labels)
-        self.assertRaises(Exception, self.panel4d.__delitem__, 'l3')
-
-        values = np.empty((4, 4, 4, 4))
-        values[0] = 0
-        values[1] = 1
-        values[2] = 2
-        values[3] = 3
-
-        panel4d = Panel4D(values, lrange(4), lrange(4), lrange(4), lrange(4))
-
-        # did we delete the right row?
-
-        panel4dc = panel4d.copy()
-        del panel4dc[0]
-        assert_panel_equal(panel4dc[1], panel4d[1])
-        assert_panel_equal(panel4dc[2], panel4d[2])
-        assert_panel_equal(panel4dc[3], panel4d[3])
-
-        panel4dc = panel4d.copy()
-        del panel4dc[1]
-        assert_panel_equal(panel4dc[0], panel4d[0])
-        assert_panel_equal(panel4dc[2], panel4d[2])
-        assert_panel_equal(panel4dc[3], panel4d[3])
-
-        panel4dc = panel4d.copy()
-        del panel4dc[2]
-        assert_panel_equal(panel4dc[1], panel4d[1])
-        assert_panel_equal(panel4dc[0], panel4d[0])
-        assert_panel_equal(panel4dc[3], panel4d[3])
-
-        panel4dc = panel4d.copy()
-        del panel4dc[3]
-        assert_panel_equal(panel4dc[1], panel4d[1])
-        assert_panel_equal(panel4dc[2], panel4d[2])
-        assert_panel_equal(panel4dc[0], panel4d[0])
+
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            expected = self.panel4d['l2']
+            result = self.panel4d.pop('l2')
+            assert_panel_equal(expected, result)
+            self.assertNotIn('l2', self.panel4d.labels)
+
+            del self.panel4d['l3']
+            self.assertNotIn('l3', self.panel4d.labels)
+            self.assertRaises(Exception, self.panel4d.__delitem__, 'l3')
+
+            values = np.empty((4, 4, 4, 4))
+            values[0] = 0
+            values[1] = 1
+            values[2] = 2
+            values[3] = 3
+
+            panel4d = Panel4D(values, lrange(4), lrange(4),
+                              lrange(4), lrange(4))
+
+            # did we delete the right row?
+            panel4dc = panel4d.copy()
+            del panel4dc[0]
+            assert_panel_equal(panel4dc[1], panel4d[1])
+            assert_panel_equal(panel4dc[2], panel4d[2])
+            assert_panel_equal(panel4dc[3], panel4d[3])
+
+            panel4dc = panel4d.copy()
+            del panel4dc[1]
+            assert_panel_equal(panel4dc[0], panel4d[0])
+            assert_panel_equal(panel4dc[2], panel4d[2])
+            assert_panel_equal(panel4dc[3], panel4d[3])
+
+            panel4dc = panel4d.copy()
+            del panel4dc[2]
+            assert_panel_equal(panel4dc[1], panel4d[1])
+            assert_panel_equal(panel4dc[0], panel4d[0])
+            assert_panel_equal(panel4dc[3], panel4d[3])
+
+            panel4dc = panel4d.copy()
+            del panel4dc[3]
+            assert_panel_equal(panel4dc[1], panel4d[1])
+            assert_panel_equal(panel4dc[2], panel4d[2])
+            assert_panel_equal(panel4dc[0], panel4d[0])
 
     def test_setitem(self):
         # LongPanel with one item
@@ -378,95 +390,83 @@ class CheckIndexing(object):
 
     def test_setitem_by_indexer(self):
 
-        # Panel
-        panel4dc = self.panel4d.copy()
-        p = panel4dc.iloc[0]
-
-        def func():
-            self.panel4d.iloc[0] = p
-        self.assertRaises(NotImplementedError, func)
-
-        # DataFrame
-        panel4dc = self.panel4d.copy()
-        df = panel4dc.iloc[0, 0]
-        df.iloc[:] = 1
-        panel4dc.iloc[0, 0] = df
-        self.assertTrue((panel4dc.iloc[0, 0].values == 1).all())
-
-        # Series
-        panel4dc = self.panel4d.copy()
-        s = panel4dc.iloc[0, 0, :, 0]
-        s.iloc[:] = 1
-        panel4dc.iloc[0, 0, :, 0] = s
-        self.assertTrue((panel4dc.iloc[0, 0, :, 0].values == 1).all())
-
-        # scalar
-        panel4dc = self.panel4d.copy()
-        panel4dc.iloc[0] = 1
-        panel4dc.iloc[1] = True
-        panel4dc.iloc[2] = 'foo'
-        self.assertTrue((panel4dc.iloc[0].values == 1).all())
-        self.assertTrue(panel4dc.iloc[1].values.all())
-        self.assertTrue((panel4dc.iloc[2].values == 'foo').all())
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+
+            # Panel
+            panel4dc = self.panel4d.copy()
+            p = panel4dc.iloc[0]
+
+            def func():
+                self.panel4d.iloc[0] = p
+            self.assertRaises(NotImplementedError, func)
+
+            # DataFrame
+            panel4dc = self.panel4d.copy()
+            df = panel4dc.iloc[0, 0]
+            df.iloc[:] = 1
+            panel4dc.iloc[0, 0] = df
+            self.assertTrue((panel4dc.iloc[0, 0].values == 1).all())
+
+            # Series
+            panel4dc = self.panel4d.copy()
+            s = panel4dc.iloc[0, 0, :, 0]
+            s.iloc[:] = 1
+            panel4dc.iloc[0, 0, :, 0] = s
+            self.assertTrue((panel4dc.iloc[0, 0, :, 0].values == 1).all())
+
+            # scalar
+            panel4dc = self.panel4d.copy()
+            panel4dc.iloc[0] = 1
+            panel4dc.iloc[1] = True
+            panel4dc.iloc[2] = 'foo'
+            self.assertTrue((panel4dc.iloc[0].values == 1).all())
+            self.assertTrue(panel4dc.iloc[1].values.all())
+            self.assertTrue((panel4dc.iloc[2].values == 'foo').all())
 
     def test_setitem_by_indexer_mixed_type(self):
-        # GH 8702
-        self.panel4d['foo'] = 'bar'
 
-        # scalar
-        panel4dc = self.panel4d.copy()
-        panel4dc.iloc[0] = 1
-        panel4dc.iloc[1] = True
-        panel4dc.iloc[2] = 'foo'
-        self.assertTrue((panel4dc.iloc[0].values == 1).all())
-        self.assertTrue(panel4dc.iloc[1].values.all())
-        self.assertTrue((panel4dc.iloc[2].values == 'foo').all())
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            # GH 8702
+            self.panel4d['foo'] = 'bar'
+
+            # scalar
+            panel4dc = self.panel4d.copy()
+            panel4dc.iloc[0] = 1
+            panel4dc.iloc[1] = True
+            panel4dc.iloc[2] = 'foo'
+            self.assertTrue((panel4dc.iloc[0].values == 1).all())
+            self.assertTrue(panel4dc.iloc[1].values.all())
+            self.assertTrue((panel4dc.iloc[2].values == 'foo').all())
 
     def test_comparisons(self):
-        p1 = tm.makePanel4D()
-        p2 = tm.makePanel4D()
-
-        tp = p1.reindex(labels=p1.labels.tolist() + ['foo'])
-        p = p1[p1.labels[0]]
-
-        def test_comp(func):
-            result = func(p1, p2)
-            self.assert_numpy_array_equal(result.values,
-                                          func(p1.values, p2.values))
-
-            # versus non-indexed same objs
-            self.assertRaises(Exception, func, p1, tp)
-
-            # versus different objs
-            self.assertRaises(Exception, func, p1, p)
-
-            result3 = func(self.panel4d, 0)
-            self.assert_numpy_array_equal(result3.values,
-                                          func(self.panel4d.values, 0))
-
-        test_comp(operator.eq)
-        test_comp(operator.ne)
-        test_comp(operator.lt)
-        test_comp(operator.gt)
-        test_comp(operator.ge)
-        test_comp(operator.le)
-
-    def test_setitem_ndarray(self):
-        raise nose.SkipTest("skipping for now")
-    #    from pandas import DateRange, datetools
-
-    #    timeidx = DateRange(start=datetime(2009,1,1),
-    #                        end=datetime(2009,12,31),
-    #                        offset=datetools.MonthEnd())
-    #    lons_coarse = np.linspace(-177.5, 177.5, 72)
-    #    lats_coarse = np.linspace(-87.5, 87.5, 36)
-    #    P = Panel(items=timeidx, major_axis=lons_coarse,
-    #              minor_axis=lats_coarse)
-    #    data = np.random.randn(72*36).reshape((72,36))
-    #    key = datetime(2009,2,28)
-    #    P[key] = data#
-
-    #    assert_almost_equal(P[key].values, data)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            p1 = tm.makePanel4D()
+            p2 = tm.makePanel4D()
+
+            tp = p1.reindex(labels=p1.labels.tolist() + ['foo'])
+            p = p1[p1.labels[0]]
+
+            def test_comp(func):
+                result = func(p1, p2)
+                self.assert_numpy_array_equal(result.values,
+                                              func(p1.values, p2.values))
+
+                # versus non-indexed same objs
+                self.assertRaises(Exception, func, p1, tp)
+
+                # versus different objs
+                self.assertRaises(Exception, func, p1, p)
+
+                result3 = func(self.panel4d, 0)
+                self.assert_numpy_array_equal(result3.values,
+                                              func(self.panel4d.values, 0))
+
+            test_comp(operator.eq)
+            test_comp(operator.ne)
+            test_comp(operator.lt)
+            test_comp(operator.gt)
+            test_comp(operator.ge)
+            test_comp(operator.le)
 
     def test_major_xs(self):
         ref = self.panel4d['l1']['ItemA']
@@ -521,42 +521,43 @@ class CheckIndexing(object):
         self.assertIsNotNone(result.is_copy)
 
     def test_getitem_fancy_labels(self):
-        panel4d = self.panel4d
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            panel4d = self.panel4d
 
-        labels = panel4d.labels[[1, 0]]
-        items = panel4d.items[[1, 0]]
-        dates = panel4d.major_axis[::2]
-        cols = ['D', 'C', 'F']
+            labels = panel4d.labels[[1, 0]]
+            items = panel4d.items[[1, 0]]
+            dates = panel4d.major_axis[::2]
+            cols = ['D', 'C', 'F']
 
-        # all 4 specified
-        assert_panel4d_equal(panel4d.ix[labels, items, dates, cols],
-                             panel4d.reindex(labels=labels, items=items,
-                                             major=dates, minor=cols))
+            # all 4 specified
+            assert_panel4d_equal(panel4d.ix[labels, items, dates, cols],
+                                 panel4d.reindex(labels=labels, items=items,
+                                                 major=dates, minor=cols))
 
-        # 3 specified
-        assert_panel4d_equal(panel4d.ix[:, items, dates, cols],
-                             panel4d.reindex(items=items, major=dates,
-                                             minor=cols))
+            # 3 specified
+            assert_panel4d_equal(panel4d.ix[:, items, dates, cols],
+                                 panel4d.reindex(items=items, major=dates,
+                                                 minor=cols))
 
-        # 2 specified
-        assert_panel4d_equal(panel4d.ix[:, :, dates, cols],
-                             panel4d.reindex(major=dates, minor=cols))
+            # 2 specified
+            assert_panel4d_equal(panel4d.ix[:, :, dates, cols],
+                                 panel4d.reindex(major=dates, minor=cols))
 
-        assert_panel4d_equal(panel4d.ix[:, items, :, cols],
-                             panel4d.reindex(items=items, minor=cols))
+            assert_panel4d_equal(panel4d.ix[:, items, :, cols],
+                                 panel4d.reindex(items=items, minor=cols))
 
-        assert_panel4d_equal(panel4d.ix[:, items, dates, :],
-                             panel4d.reindex(items=items, major=dates))
+            assert_panel4d_equal(panel4d.ix[:, items, dates, :],
+                                 panel4d.reindex(items=items, major=dates))
 
-        # only 1
-        assert_panel4d_equal(panel4d.ix[:, items, :, :],
-                             panel4d.reindex(items=items))
+            # only 1
+            assert_panel4d_equal(panel4d.ix[:, items, :, :],
+                                 panel4d.reindex(items=items))
 
-        assert_panel4d_equal(panel4d.ix[:, :, dates, :],
-                             panel4d.reindex(major=dates))
+            assert_panel4d_equal(panel4d.ix[:, :, dates, :],
+                                 panel4d.reindex(major=dates))
 
-        assert_panel4d_equal(panel4d.ix[:, :, :, cols],
-                             panel4d.reindex(minor=cols))
+            assert_panel4d_equal(panel4d.ix[:, :, :, cols],
+                                 panel4d.reindex(minor=cols))
 
     def test_getitem_fancy_slice(self):
         pass
@@ -564,11 +565,6 @@ class CheckIndexing(object):
     def test_getitem_fancy_ints(self):
         pass
 
-    def test_getitem_fancy_xs(self):
-        raise nose.SkipTest("skipping for now")
-        # self.assertRaises(NotImplementedError, self.panel4d.major_xs)
-        # self.assertRaises(NotImplementedError, self.panel4d.minor_xs)
-
     def test_get_value(self):
         for label in self.panel4d.labels:
             for item in self.panel4d.items:
@@ -580,22 +576,28 @@ class CheckIndexing(object):
                         assert_almost_equal(result, expected)
 
     def test_set_value(self):
-        for label in self.panel4d.labels:
-            for item in self.panel4d.items:
-                for mjr in self.panel4d.major_axis[::2]:
-                    for mnr in self.panel4d.minor_axis:
-                        self.panel4d.set_value(label, item, mjr, mnr, 1.)
-                        assert_almost_equal(
-                            self.panel4d[label][item][mnr][mjr], 1.)
 
-        # resize
-        res = self.panel4d.set_value('l4', 'ItemE', 'foo', 'bar', 1.5)
-        tm.assertIsInstance(res, Panel4D)
-        self.assertIsNot(res, self.panel4d)
-        self.assertEqual(res.get_value('l4', 'ItemE', 'foo', 'bar'), 1.5)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
 
-        res3 = self.panel4d.set_value('l4', 'ItemE', 'foobar', 'baz', 5)
-        self.assertTrue(is_float_dtype(res3['l4'].values))
+            for label in self.panel4d.labels:
+                for item in self.panel4d.items:
+                    for mjr in self.panel4d.major_axis[::2]:
+                        for mnr in self.panel4d.minor_axis:
+                            self.panel4d.set_value(label, item, mjr, mnr, 1.)
+                            assert_almost_equal(
+                                self.panel4d[label][item][mnr][mjr], 1.)
+
+            res3 = self.panel4d.set_value('l4', 'ItemE', 'foobar', 'baz', 5)
+            self.assertTrue(is_float_dtype(res3['l4'].values))
+
+            # resize
+            res = self.panel4d.set_value('l4', 'ItemE', 'foo', 'bar', 1.5)
+            tm.assertIsInstance(res, Panel4D)
+            self.assertIsNot(res, self.panel4d)
+            self.assertEqual(res.get_value('l4', 'ItemE', 'foo', 'bar'), 1.5)
+
+            res3 = self.panel4d.set_value('l4', 'ItemE', 'foobar', 'baz', 5)
+            self.assertTrue(is_float_dtype(res3['l4'].values))
 
 
 class TestPanel4d(tm.TestCase, CheckIndexing, SafeForSparse,
@@ -608,194 +610,150 @@ class TestPanel4d(tm.TestCase, CheckIndexing, SafeForSparse,
         assert_panel4d_equal(x, y)
 
     def setUp(self):
-        self.panel4d = tm.makePanel4D(nper=8)
-        add_nans(self.panel4d)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            self.panel4d = tm.makePanel4D(nper=8)
+            add_nans(self.panel4d)
 
     def test_constructor(self):
-        # with BlockManager
-        panel4d = Panel4D(self.panel4d._data)
-        self.assertIs(panel4d._data, self.panel4d._data)
-
-        panel4d = Panel4D(self.panel4d._data, copy=True)
-        self.assertIsNot(panel4d._data, self.panel4d._data)
-        assert_panel4d_equal(panel4d, self.panel4d)
-
-        # strings handled prop
-        # panel4d = Panel4D([[['foo', 'foo', 'foo',],
-        #                 ['foo', 'foo', 'foo']]])
-        # self.assertEqual(wp.values.dtype, np.object_)
-
-        vals = self.panel4d.values
-
-        # no copy
-        panel4d = Panel4D(vals)
-        self.assertIs(panel4d.values, vals)
-
-        # copy
-        panel4d = Panel4D(vals, copy=True)
-        self.assertIsNot(panel4d.values, vals)
-
-        # GH #8285, test when scalar data is used to construct a Panel4D
-        # if dtype is not passed, it should be inferred
-        value_and_dtype = [(1, 'int64'), (3.14, 'float64'),
-                           ('foo', np.object_)]
-        for (val, dtype) in value_and_dtype:
-            panel4d = Panel4D(val, labels=range(2), items=range(
-                3), major_axis=range(4), minor_axis=range(5))
-            vals = np.empty((2, 3, 4, 5), dtype=dtype)
-            vals.fill(val)
-            assert_panel4d_equal(panel4d, Panel4D(vals, dtype=dtype))
-
-        # test the case when dtype is passed
-        panel4d = Panel4D(1, labels=range(2), items=range(
-            3), major_axis=range(4), minor_axis=range(5), dtype='float32')
-        vals = np.empty((2, 3, 4, 5), dtype='float32')
-        vals.fill(1)
-        assert_panel4d_equal(panel4d, Panel4D(vals, dtype='float32'))
 
-    def test_constructor_cast(self):
-        zero_filled = self.panel4d.fillna(0)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            panel4d = Panel4D(self.panel4d._data)
+            self.assertIs(panel4d._data, self.panel4d._data)
+
+            panel4d = Panel4D(self.panel4d._data, copy=True)
+            self.assertIsNot(panel4d._data, self.panel4d._data)
+            assert_panel4d_equal(panel4d, self.panel4d)
+
+            vals = self.panel4d.values
+
+            # no copy
+            panel4d = Panel4D(vals)
+            self.assertIs(panel4d.values, vals)
+
+            # copy
+            panel4d = Panel4D(vals, copy=True)
+            self.assertIsNot(panel4d.values, vals)
+
+            # GH #8285, test when scalar data is used to construct a Panel4D
+            # if dtype is not passed, it should be inferred
+            value_and_dtype = [(1, 'int64'), (3.14, 'float64'),
+                               ('foo', np.object_)]
+            for (val, dtype) in value_and_dtype:
+                panel4d = Panel4D(val, labels=range(2), items=range(
+                    3), major_axis=range(4), minor_axis=range(5))
+                vals = np.empty((2, 3, 4, 5), dtype=dtype)
+                vals.fill(val)
+                expected = Panel4D(vals, dtype=dtype)
+                assert_panel4d_equal(panel4d, expected)
+
+            # test the case when dtype is passed
+            panel4d = Panel4D(1, labels=range(2), items=range(
+                3), major_axis=range(4), minor_axis=range(5), dtype='float32')
+            vals = np.empty((2, 3, 4, 5), dtype='float32')
+            vals.fill(1)
+
+            expected = Panel4D(vals, dtype='float32')
+            assert_panel4d_equal(panel4d, expected)
 
-        casted = Panel4D(zero_filled._data, dtype=int)
-        casted2 = Panel4D(zero_filled.values, dtype=int)
-
-        exp_values = zero_filled.values.astype(int)
-        assert_almost_equal(casted.values, exp_values)
-        assert_almost_equal(casted2.values, exp_values)
+    def test_constructor_cast(self):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            zero_filled = self.panel4d.fillna(0)
 
-        casted = Panel4D(zero_filled._data, dtype=np.int32)
-        casted2 = Panel4D(zero_filled.values, dtype=np.int32)
+            casted = Panel4D(zero_filled._data, dtype=int)
+            casted2 = Panel4D(zero_filled.values, dtype=int)
 
-        exp_values = zero_filled.values.astype(np.int32)
-        assert_almost_equal(casted.values, exp_values)
-        assert_almost_equal(casted2.values, exp_values)
+            exp_values = zero_filled.values.astype(int)
+            assert_almost_equal(casted.values, exp_values)
+            assert_almost_equal(casted2.values, exp_values)
 
-        # can't cast
-        data = [[['foo', 'bar', 'baz']]]
-        self.assertRaises(ValueError, Panel, data, dtype=float)
+            casted = Panel4D(zero_filled._data, dtype=np.int32)
+            casted2 = Panel4D(zero_filled.values, dtype=np.int32)
 
-    def test_constructor_empty_panel(self):
-        empty = Panel()
-        self.assertEqual(len(empty.items), 0)
-        self.assertEqual(len(empty.major_axis), 0)
-        self.assertEqual(len(empty.minor_axis), 0)
+            exp_values = zero_filled.values.astype(np.int32)
+            assert_almost_equal(casted.values, exp_values)
+            assert_almost_equal(casted2.values, exp_values)
 
-    def test_constructor_observe_dtype(self):
-        # GH #411
-        panel = Panel(items=lrange(3), major_axis=lrange(3),
-                      minor_axis=lrange(3), dtype='O')
-        self.assertEqual(panel.values.dtype, np.object_)
+            # can't cast
+            data = [[['foo', 'bar', 'baz']]]
+            self.assertRaises(ValueError, Panel, data, dtype=float)
 
     def test_consolidate(self):
-        self.assertTrue(self.panel4d._data.is_consolidated())
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            self.assertTrue(self.panel4d._data.is_consolidated())
 
-        self.panel4d['foo'] = 1.
-        self.assertFalse(self.panel4d._data.is_consolidated())
+            self.panel4d['foo'] = 1.
+            self.assertFalse(self.panel4d._data.is_consolidated())
 
-        panel4d = self.panel4d.consolidate()
-        self.assertTrue(panel4d._data.is_consolidated())
+            panel4d = self.panel4d.consolidate()
+            self.assertTrue(panel4d._data.is_consolidated())
 
     def test_ctor_dict(self):
-        l1 = self.panel4d['l1']
-        l2 = self.panel4d['l2']
-
-        d = {'A': l1, 'B': l2.ix[['ItemB'], :, :]}
-        # d2 = {'A' : itema._series, 'B' : itemb[5:]._series}
-        # d3 = {'A' : DataFrame(itema._series),
-        #      'B' : DataFrame(itemb[5:]._series)}
-
-        panel4d = Panel4D(d)
-        # wp2 = Panel.from_dict(d2) # nested Dict
-        # wp3 = Panel.from_dict(d3)
-        # self.assertTrue(wp.major_axis.equals(self.panel.major_axis))
-        assert_panel_equal(panel4d['A'], self.panel4d['l1'])
-        assert_frame_equal(panel4d.ix['B', 'ItemB', :, :],
-                           self.panel4d.ix['l2', ['ItemB'], :, :]['ItemB'])
-
-        # intersect
-        # wp = Panel.from_dict(d, intersect=True)
-        # self.assertTrue(wp.major_axis.equals(itemb.index[5:]))
-
-        # use constructor
-        # assert_panel_equal(Panel(d), Panel.from_dict(d))
-        # assert_panel_equal(Panel(d2), Panel.from_dict(d2))
-        # assert_panel_equal(Panel(d3), Panel.from_dict(d3))
-
-        # cast
-        # dcasted = dict((k, v.reindex(wp.major_axis).fillna(0))
-        #               for k, v in d.iteritems())
-        # result = Panel(dcasted, dtype=int)
-        # expected = Panel(dict((k, v.astype(int))
-        #                      for k, v in dcasted.iteritems()))
-        # assert_panel_equal(result, expected)
-
-    def test_constructor_dict_mixed(self):
-        data = dict((k, v.values) for k, v in self.panel4d.iteritems())
-        result = Panel4D(data)
-        exp_major = Index(np.arange(len(self.panel4d.major_axis)))
-        self.assert_index_equal(result.major_axis, exp_major)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            l1 = self.panel4d['l1']
+            l2 = self.panel4d['l2']
 
-        result = Panel4D(data,
-                         labels=self.panel4d.labels,
-                         items=self.panel4d.items,
-                         major_axis=self.panel4d.major_axis,
-                         minor_axis=self.panel4d.minor_axis)
-        assert_panel4d_equal(result, self.panel4d)
+            d = {'A': l1, 'B': l2.ix[['ItemB'], :, :]}
+            panel4d = Panel4D(d)
 
-        data['l2'] = self.panel4d['l2']
-        result = Panel4D(data)
-        assert_panel4d_equal(result, self.panel4d)
-
-        # corner, blow up
-        data['l2'] = data['l2']['ItemB']
-        self.assertRaises(Exception, Panel4D, data)
-
-        data['l2'] = self.panel4d['l2'].values[:, :, :-1]
-        self.assertRaises(Exception, Panel4D, data)
-
-    def test_constructor_resize(self):
-        data = self.panel4d._data
-        labels = self.panel4d.labels[:-1]
-        items = self.panel4d.items[:-1]
-        major = self.panel4d.major_axis[:-1]
-        minor = self.panel4d.minor_axis[:-1]
+            assert_panel_equal(panel4d['A'], self.panel4d['l1'])
+            assert_frame_equal(panel4d.ix['B', 'ItemB', :, :],
+                               self.panel4d.ix['l2', ['ItemB'], :, :]['ItemB'])
 
-        result = Panel4D(data, labels=labels, items=items,
-                         major_axis=major, minor_axis=minor)
-        expected = self.panel4d.reindex(
-            labels=labels, items=items, major=major, minor=minor)
-        assert_panel4d_equal(result, expected)
-
-        result = Panel4D(data, items=items, major_axis=major)
-        expected = self.panel4d.reindex(items=items, major=major)
-        assert_panel4d_equal(result, expected)
+    def test_constructor_dict_mixed(self):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            data = dict((k, v.values) for k, v in self.panel4d.iteritems())
+            result = Panel4D(data)
 
-        result = Panel4D(data, items=items)
-        expected = self.panel4d.reindex(items=items)
-        assert_panel4d_equal(result, expected)
+            exp_major = Index(np.arange(len(self.panel4d.major_axis)))
+            self.assert_index_equal(result.major_axis, exp_major)
 
-        result = Panel4D(data, minor_axis=minor)
-        expected = self.panel4d.reindex(minor=minor)
-        assert_panel4d_equal(result, expected)
+            result = Panel4D(data,
+                             labels=self.panel4d.labels,
+                             items=self.panel4d.items,
+                             major_axis=self.panel4d.major_axis,
+                             minor_axis=self.panel4d.minor_axis)
+            assert_panel4d_equal(result, self.panel4d)
 
-    def test_from_dict_mixed_orient(self):
-        raise nose.SkipTest("skipping for now")
-    #    df = tm.makeDataFrame()
-    #    df['foo'] = 'bar'
+            data['l2'] = self.panel4d['l2']
 
-    #    data = {'k1' : df,
-    #            'k2' : df}
+            result = Panel4D(data)
+            assert_panel4d_equal(result, self.panel4d)
 
-    #    panel = Panel.from_dict(data, orient='minor')
+            # corner, blow up
+            data['l2'] = data['l2']['ItemB']
+            self.assertRaises(Exception, Panel4D, data)
 
-    #    self.assertEqual(panel['foo'].values.dtype, np.object_)
-    #    self.assertEqual(panel['A'].values.dtype, np.float64)
+            data['l2'] = self.panel4d['l2'].values[:, :, :-1]
+            self.assertRaises(Exception, Panel4D, data)
 
-    def test_values(self):
-        self.assertRaises(Exception, Panel, np.random.randn(5, 5, 5),
-                          lrange(5), lrange(5), lrange(4))
+    def test_constructor_resize(self):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            data = self.panel4d._data
+            labels = self.panel4d.labels[:-1]
+            items = self.panel4d.items[:-1]
+            major = self.panel4d.major_axis[:-1]
+            minor = self.panel4d.minor_axis[:-1]
+
+            result = Panel4D(data, labels=labels, items=items,
+                             major_axis=major, minor_axis=minor)
+            expected = self.panel4d.reindex(
+                labels=labels, items=items, major=major, minor=minor)
+            assert_panel4d_equal(result, expected)
+
+            result = Panel4D(data, items=items, major_axis=major)
+            expected = self.panel4d.reindex(items=items, major=major)
+            assert_panel4d_equal(result, expected)
+
+            result = Panel4D(data, items=items)
+            expected = self.panel4d.reindex(items=items)
+            assert_panel4d_equal(result, expected)
+
+            result = Panel4D(data, minor_axis=minor)
+            expected = self.panel4d.reindex(minor=minor)
+            assert_panel4d_equal(result, expected)
 
     def test_conform(self):
+
         p = self.panel4d['l1'].filter(items=['ItemA', 'ItemB'])
         conformed = self.panel4d.conform(p)
 
@@ -804,208 +762,155 @@ class TestPanel4d(tm.TestCase, CheckIndexing, SafeForSparse,
         tm.assert_index_equal(conformed.minor_axis, self.panel4d.minor_axis)
 
     def test_reindex(self):
-        ref = self.panel4d['l2']
-
-        # labels
-        result = self.panel4d.reindex(labels=['l1', 'l2'])
-        assert_panel_equal(result['l2'], ref)
-
-        # items
-        result = self.panel4d.reindex(items=['ItemA', 'ItemB'])
-        assert_frame_equal(result['l2']['ItemB'], ref['ItemB'])
-
-        # major
-        new_major = list(self.panel4d.major_axis[:10])
-        result = self.panel4d.reindex(major=new_major)
-        assert_frame_equal(
-            result['l2']['ItemB'], ref['ItemB'].reindex(index=new_major))
-
-        # raise exception put both major and major_axis
-        self.assertRaises(Exception, self.panel4d.reindex,
-                          major_axis=new_major, major=new_major)
-
-        # minor
-        new_minor = list(self.panel4d.minor_axis[:2])
-        result = self.panel4d.reindex(minor=new_minor)
-        assert_frame_equal(
-            result['l2']['ItemB'], ref['ItemB'].reindex(columns=new_minor))
-
-        result = self.panel4d.reindex(labels=self.panel4d.labels,
-                                      items=self.panel4d.items,
-                                      major=self.panel4d.major_axis,
-                                      minor=self.panel4d.minor_axis)
-
-        # don't necessarily copy
-        result = self.panel4d.reindex()
-        assert_panel4d_equal(result, self.panel4d)
-        self.assertFalse(result is self.panel4d)
-
-        # with filling
-        smaller_major = self.panel4d.major_axis[::5]
-        smaller = self.panel4d.reindex(major=smaller_major)
-
-        larger = smaller.reindex(major=self.panel4d.major_axis,
-                                 method='pad')
-
-        assert_panel_equal(larger.ix[:, :, self.panel4d.major_axis[1], :],
-                           smaller.ix[:, :, smaller_major[0], :])
-
-        # don't necessarily copy
-        result = self.panel4d.reindex(
-            major=self.panel4d.major_axis, copy=False)
-        assert_panel4d_equal(result, self.panel4d)
-        self.assertTrue(result is self.panel4d)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            ref = self.panel4d['l2']
+
+            # labels
+            result = self.panel4d.reindex(labels=['l1', 'l2'])
+            assert_panel_equal(result['l2'], ref)
+
+            # items
+            result = self.panel4d.reindex(items=['ItemA', 'ItemB'])
+            assert_frame_equal(result['l2']['ItemB'], ref['ItemB'])
+
+            # major
+            new_major = list(self.panel4d.major_axis[:10])
+            result = self.panel4d.reindex(major=new_major)
+            assert_frame_equal(
+                result['l2']['ItemB'], ref['ItemB'].reindex(index=new_major))
+
+            # raise exception put both major and major_axis
+            self.assertRaises(Exception, self.panel4d.reindex,
+                              major_axis=new_major, major=new_major)
+
+            # minor
+            new_minor = list(self.panel4d.minor_axis[:2])
+            result = self.panel4d.reindex(minor=new_minor)
+            assert_frame_equal(
+                result['l2']['ItemB'], ref['ItemB'].reindex(columns=new_minor))
+
+            result = self.panel4d.reindex(labels=self.panel4d.labels,
+                                          items=self.panel4d.items,
+                                          major=self.panel4d.major_axis,
+                                          minor=self.panel4d.minor_axis)
+
+            # don't necessarily copy
+            result = self.panel4d.reindex()
+            assert_panel4d_equal(result, self.panel4d)
+            self.assertFalse(result is self.panel4d)
+
+            # with filling
+            smaller_major = self.panel4d.major_axis[::5]
+            smaller = self.panel4d.reindex(major=smaller_major)
+
+            larger = smaller.reindex(major=self.panel4d.major_axis,
+                                     method='pad')
+
+            assert_panel_equal(larger.ix[:, :, self.panel4d.major_axis[1], :],
+                               smaller.ix[:, :, smaller_major[0], :])
+
+            # don't necessarily copy
+            result = self.panel4d.reindex(
+                major=self.panel4d.major_axis, copy=False)
+            assert_panel4d_equal(result, self.panel4d)
+            self.assertTrue(result is self.panel4d)
 
     def test_not_hashable(self):
-        p4D_empty = Panel4D()
-        self.assertRaises(TypeError, hash, p4D_empty)
-        self.assertRaises(TypeError, hash, self.panel4d)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            p4D_empty = Panel4D()
+            self.assertRaises(TypeError, hash, p4D_empty)
+            self.assertRaises(TypeError, hash, self.panel4d)
 
     def test_reindex_like(self):
         # reindex_like
-        smaller = self.panel4d.reindex(labels=self.panel4d.labels[:-1],
-                                       items=self.panel4d.items[:-1],
-                                       major=self.panel4d.major_axis[:-1],
-                                       minor=self.panel4d.minor_axis[:-1])
-        smaller_like = self.panel4d.reindex_like(smaller)
-        assert_panel4d_equal(smaller, smaller_like)
-
-    def test_take(self):
-        raise nose.SkipTest("skipping for now")
-
-    #    # axis == 0
-    #    result = self.panel.take([2, 0, 1], axis=0)
-    #    expected = self.panel.reindex(items=['ItemC', 'ItemA', 'ItemB'])
-    #    assert_panel_equal(result, expected)#
-
-    #    # axis >= 1
-    #    result = self.panel.take([3, 0, 1, 2], axis=2)
-    #    expected = self.panel.reindex(minor=['D', 'A', 'B', 'C'])
-    #    assert_panel_equal(result, expected)
-
-    #    self.assertRaises(Exception, self.panel.take, [3, -1, 1, 2], axis=2)
-    #    self.assertRaises(Exception, self.panel.take, [4, 0, 1, 2], axis=2)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            smaller = self.panel4d.reindex(labels=self.panel4d.labels[:-1],
+                                           items=self.panel4d.items[:-1],
+                                           major=self.panel4d.major_axis[:-1],
+                                           minor=self.panel4d.minor_axis[:-1])
+            smaller_like = self.panel4d.reindex_like(smaller)
+            assert_panel4d_equal(smaller, smaller_like)
 
     def test_sort_index(self):
-        import random
-
-        rlabels = list(self.panel4d.labels)
-        ritems = list(self.panel4d.items)
-        rmajor = list(self.panel4d.major_axis)
-        rminor = list(self.panel4d.minor_axis)
-        random.shuffle(rlabels)
-        random.shuffle(ritems)
-        random.shuffle(rmajor)
-        random.shuffle(rminor)
-
-        random_order = self.panel4d.reindex(labels=rlabels)
-        sorted_panel4d = random_order.sort_index(axis=0)
-        assert_panel4d_equal(sorted_panel4d, self.panel4d)
-
-        # descending
-        # random_order = self.panel.reindex(items=ritems)
-        # sorted_panel = random_order.sort_index(axis=0, ascending=False)
-        # assert_panel_equal(sorted_panel,
-        #                   self.panel.reindex(items=self.panel.items[::-1]))
-
-        # random_order = self.panel.reindex(major=rmajor)
-        # sorted_panel = random_order.sort_index(axis=1)
-        # assert_panel_equal(sorted_panel, self.panel)
-
-        # random_order = self.panel.reindex(minor=rminor)
-        # sorted_panel = random_order.sort_index(axis=2)
-        # assert_panel_equal(sorted_panel, self.panel)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            import random
+
+            rlabels = list(self.panel4d.labels)
+            ritems = list(self.panel4d.items)
+            rmajor = list(self.panel4d.major_axis)
+            rminor = list(self.panel4d.minor_axis)
+            random.shuffle(rlabels)
+            random.shuffle(ritems)
+            random.shuffle(rmajor)
+            random.shuffle(rminor)
+
+            random_order = self.panel4d.reindex(labels=rlabels)
+            sorted_panel4d = random_order.sort_index(axis=0)
+            assert_panel4d_equal(sorted_panel4d, self.panel4d)
 
     def test_fillna(self):
-        self.assertFalse(np.isfinite(self.panel4d.values).all())
-        filled = self.panel4d.fillna(0)
-        self.assertTrue(np.isfinite(filled.values).all())
 
-        self.assertRaises(NotImplementedError,
-                          self.panel4d.fillna, method='pad')
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            self.assertFalse(np.isfinite(self.panel4d.values).all())
+            filled = self.panel4d.fillna(0)
+            self.assertTrue(np.isfinite(filled.values).all())
 
-    def test_swapaxes(self):
-        result = self.panel4d.swapaxes('labels', 'items')
-        self.assertIs(result.items, self.panel4d.labels)
+            self.assertRaises(NotImplementedError,
+                              self.panel4d.fillna, method='pad')
 
-        result = self.panel4d.swapaxes('labels', 'minor')
-        self.assertIs(result.labels, self.panel4d.minor_axis)
-
-        result = self.panel4d.swapaxes('items', 'minor')
-        self.assertIs(result.items, self.panel4d.minor_axis)
-
-        result = self.panel4d.swapaxes('items', 'major')
-        self.assertIs(result.items, self.panel4d.major_axis)
-
-        result = self.panel4d.swapaxes('major', 'minor')
-        self.assertIs(result.major_axis, self.panel4d.minor_axis)
-
-        # this should also work
-        result = self.panel4d.swapaxes(0, 1)
-        self.assertIs(result.labels, self.panel4d.items)
+    def test_swapaxes(self):
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            result = self.panel4d.swapaxes('labels', 'items')
+            self.assertIs(result.items, self.panel4d.labels)
 
-        # this works, but return a copy
-        result = self.panel4d.swapaxes('items', 'items')
-        assert_panel4d_equal(self.panel4d, result)
-        self.assertNotEqual(id(self.panel4d), id(result))
+            result = self.panel4d.swapaxes('labels', 'minor')
+            self.assertIs(result.labels, self.panel4d.minor_axis)
 
-    def test_to_frame(self):
-        raise nose.SkipTest("skipping for now")
-    #    # filtered
-    #    filtered = self.panel.to_frame()
-    #    expected = self.panel.to_frame().dropna(how='any')
-    #    assert_frame_equal(filtered, expected)
+            result = self.panel4d.swapaxes('items', 'minor')
+            self.assertIs(result.items, self.panel4d.minor_axis)
 
-    #    # unfiltered
-    #    unfiltered = self.panel.to_frame(filter_observations=False)
-    #    assert_panel_equal(unfiltered.to_panel(), self.panel)
+            result = self.panel4d.swapaxes('items', 'major')
+            self.assertIs(result.items, self.panel4d.major_axis)
 
-    #    # names
-    #    self.assertEqual(unfiltered.index.names, ('major', 'minor'))
+            result = self.panel4d.swapaxes('major', 'minor')
+            self.assertIs(result.major_axis, self.panel4d.minor_axis)
 
-    def test_to_frame_mixed(self):
-        raise nose.SkipTest("skipping for now")
-    #    panel = self.panel.fillna(0)
-    #    panel['str'] = 'foo'
-    #    panel['bool'] = panel['ItemA'] > 0
+            # this should also work
+            result = self.panel4d.swapaxes(0, 1)
+            self.assertIs(result.labels, self.panel4d.items)
 
-    #    lp = panel.to_frame()
-    #    wp = lp.to_panel()
-    #    self.assertEqual(wp['bool'].values.dtype, np.bool_)
-    #    assert_frame_equal(wp['bool'], panel['bool'])
+            # this works, but return a copy
+            result = self.panel4d.swapaxes('items', 'items')
+            assert_panel4d_equal(self.panel4d, result)
+            self.assertNotEqual(id(self.panel4d), id(result))
 
     def test_update(self):
 
-        p4d = Panel4D([[[[1.5, np.nan, 3.],
-                         [1.5, np.nan, 3.],
-                         [1.5, np.nan, 3.],
-                         [1.5, np.nan, 3.]],
-                        [[1.5, np.nan, 3.],
-                         [1.5, np.nan, 3.],
-                         [1.5, np.nan, 3.],
-                         [1.5, np.nan, 3.]]]])
-
-        other = Panel4D([[[[3.6, 2., np.nan]],
-                          [[np.nan, np.nan, 7]]]])
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            p4d = Panel4D([[[[1.5, np.nan, 3.],
+                             [1.5, np.nan, 3.],
+                             [1.5, np.nan, 3.],
+                             [1.5, np.nan, 3.]],
+                            [[1.5, np.nan, 3.],
+                             [1.5, np.nan, 3.],
+                             [1.5, np.nan, 3.],
+                             [1.5, np.nan, 3.]]]])
 
-        p4d.update(other)
+            other = Panel4D([[[[3.6, 2., np.nan]],
+                              [[np.nan, np.nan, 7]]]])
 
-        expected = Panel4D([[[[3.6, 2, 3.],
-                              [1.5, np.nan, 3.],
-                              [1.5, np.nan, 3.],
-                              [1.5, np.nan, 3.]],
-                             [[1.5, np.nan, 7],
-                              [1.5, np.nan, 3.],
-                              [1.5, np.nan, 3.],
-                              [1.5, np.nan, 3.]]]])
+            p4d.update(other)
 
-        assert_panel4d_equal(p4d, expected)
+            expected = Panel4D([[[[3.6, 2, 3.],
+                                  [1.5, np.nan, 3.],
+                                  [1.5, np.nan, 3.],
+                                  [1.5, np.nan, 3.]],
+                                 [[1.5, np.nan, 7],
+                                  [1.5, np.nan, 3.],
+                                  [1.5, np.nan, 3.],
+                                  [1.5, np.nan, 3.]]]])
 
-    def test_filter(self):
-        raise nose.SkipTest("skipping for now")
-
-    def test_apply(self):
-        raise nose.SkipTest("skipping for now")
+            assert_panel4d_equal(p4d, expected)
 
     def test_dtypes(self):
 
@@ -1013,98 +918,36 @@ class TestPanel4d(tm.TestCase, CheckIndexing, SafeForSparse,
         expected = Series(np.dtype('float64'), index=self.panel4d.labels)
         assert_series_equal(result, expected)
 
-    def test_compound(self):
-        raise nose.SkipTest("skipping for now")
-    #    compounded = self.panel.compound()
-
-    #    assert_series_equal(compounded['ItemA'],
-    #                        (1 + self.panel['ItemA']).product(0) - 1)
-
-    def test_shift(self):
-        raise nose.SkipTest("skipping for now")
-    #    # major
-    #    idx = self.panel.major_axis[0]
-    #    idx_lag = self.panel.major_axis[1]
-
-    #    shifted = self.panel.shift(1)
-
-    #    assert_frame_equal(self.panel.major_xs(idx),
-    #                       shifted.major_xs(idx_lag))
-
-    #    # minor
-    #    idx = self.panel.minor_axis[0]
-    #    idx_lag = self.panel.minor_axis[1]
-
-    #    shifted = self.panel.shift(1, axis='minor')
-
-    #    assert_frame_equal(self.panel.minor_xs(idx),
-    #                       shifted.minor_xs(idx_lag))
-
-    #    self.assertRaises(Exception, self.panel.shift, 1, axis='items')
-
-    def test_multiindex_get(self):
-        raise nose.SkipTest("skipping for now")
-    #    ind = MultiIndex.from_tuples([('a', 1), ('a', 2), ('b', 1), ('b',2)],
-    #                                 names=['first', 'second'])
-    #    wp = Panel(np.random.random((4,5,5)),
-    #                                items=ind,
-    #                                major_axis=np.arange(5),
-    #                                minor_axis=np.arange(5))
-    #    f1 = wp['a']
-    #    f2 = wp.ix['a']
-    #    assert_panel_equal(f1, f2)
-
-    #    self.assertTrue((f1.items == [1, 2]).all())
-    #    self.assertTrue((f2.items == [1, 2]).all())
-
-    #    ind = MultiIndex.from_tuples([('a', 1), ('a', 2), ('b', 1)],
-    #                                 names=['first', 'second'])
-
-    def test_multiindex_blocks(self):
-        raise nose.SkipTest("skipping for now")
-    #    ind = MultiIndex.from_tuples([('a', 1), ('a', 2), ('b', 1)],
-    #                                 names=['first', 'second'])
-    #    wp = Panel(self.panel._data)
-    #    wp.items = ind
-    #    f1 = wp['a']
-    #    self.assertTrue((f1.items == [1, 2]).all())
-
-    #    f1 = wp[('b',1)]
-    #    self.assertTrue((f1.columns == ['A', 'B', 'C', 'D']).all())
-
     def test_repr_empty(self):
-        empty = Panel4D()
-        repr(empty)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            empty = Panel4D()
+            repr(empty)
 
     def test_rename(self):
-        mapper = {
-            'l1': 'foo',
-            'l2': 'bar',
-            'l3': 'baz'
-        }
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+
+            mapper = {'l1': 'foo',
+                      'l2': 'bar',
+                      'l3': 'baz'}
 
-        renamed = self.panel4d.rename_axis(mapper, axis=0)
-        exp = Index(['foo', 'bar', 'baz'])
-        self.assert_index_equal(renamed.labels, exp)
+            renamed = self.panel4d.rename_axis(mapper, axis=0)
+            exp = Index(['foo', 'bar', 'baz'])
+            self.assert_index_equal(renamed.labels, exp)
 
-        renamed = self.panel4d.rename_axis(str.lower, axis=3)
-        exp = Index(['a', 'b', 'c', 'd'])
-        self.assert_index_equal(renamed.minor_axis, exp)
+            renamed = self.panel4d.rename_axis(str.lower, axis=3)
+            exp = Index(['a', 'b', 'c', 'd'])
+            self.assert_index_equal(renamed.minor_axis, exp)
 
-        # don't copy
-        renamed_nocopy = self.panel4d.rename_axis(mapper, axis=0, copy=False)
-        renamed_nocopy['foo'] = 3.
-        self.assertTrue((self.panel4d['l1'].values == 3).all())
+            # don't copy
+            renamed_nocopy = self.panel4d.rename_axis(mapper,
+                                                      axis=0,
+                                                      copy=False)
+            renamed_nocopy['foo'] = 3.
+            self.assertTrue((self.panel4d['l1'].values == 3).all())
 
     def test_get_attr(self):
         assert_panel_equal(self.panel4d['l1'], self.panel4d.l1)
 
-    def test_from_frame_level1_unsorted(self):
-        raise nose.SkipTest("skipping for now")
-
-    def test_to_excel(self):
-        raise nose.SkipTest("skipping for now")
-
 
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
diff --git a/pandas/tests/test_panelnd.py b/pandas/tests/test_panelnd.py
index ac497bc58..2a69a65e8 100644
--- a/pandas/tests/test_panelnd.py
+++ b/pandas/tests/test_panelnd.py
@@ -15,31 +15,35 @@ class TestPanelnd(tm.TestCase):
 
     def test_4d_construction(self):
 
-        # create a 4D
-        Panel4D = panelnd.create_nd_panel_factory(
-            klass_name='Panel4D',
-            orders=['labels', 'items', 'major_axis', 'minor_axis'],
-            slices={'items': 'items', 'major_axis': 'major_axis',
-                    'minor_axis': 'minor_axis'},
-            slicer=Panel,
-            aliases={'major': 'major_axis', 'minor': 'minor_axis'},
-            stat_axis=2)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+
+            # create a 4D
+            Panel4D = panelnd.create_nd_panel_factory(
+                klass_name='Panel4D',
+                orders=['labels', 'items', 'major_axis', 'minor_axis'],
+                slices={'items': 'items', 'major_axis': 'major_axis',
+                        'minor_axis': 'minor_axis'},
+                slicer=Panel,
+                aliases={'major': 'major_axis', 'minor': 'minor_axis'},
+                stat_axis=2)
 
-        p4d = Panel4D(dict(L1=tm.makePanel(), L2=tm.makePanel()))  # noqa
+            p4d = Panel4D(dict(L1=tm.makePanel(), L2=tm.makePanel()))  # noqa
 
     def test_4d_construction_alt(self):
 
-        # create a 4D
-        Panel4D = panelnd.create_nd_panel_factory(
-            klass_name='Panel4D',
-            orders=['labels', 'items', 'major_axis', 'minor_axis'],
-            slices={'items': 'items', 'major_axis': 'major_axis',
-                    'minor_axis': 'minor_axis'},
-            slicer='Panel',
-            aliases={'major': 'major_axis', 'minor': 'minor_axis'},
-            stat_axis=2)
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
 
-        p4d = Panel4D(dict(L1=tm.makePanel(), L2=tm.makePanel()))  # noqa
+            # create a 4D
+            Panel4D = panelnd.create_nd_panel_factory(
+                klass_name='Panel4D',
+                orders=['labels', 'items', 'major_axis', 'minor_axis'],
+                slices={'items': 'items', 'major_axis': 'major_axis',
+                        'minor_axis': 'minor_axis'},
+                slicer='Panel',
+                aliases={'major': 'major_axis', 'minor': 'minor_axis'},
+                stat_axis=2)
+
+            p4d = Panel4D(dict(L1=tm.makePanel(), L2=tm.makePanel()))  # noqa
 
     def test_4d_construction_error(self):
 
@@ -59,40 +63,44 @@ class TestPanelnd(tm.TestCase):
 
     def test_5d_construction(self):
 
-        # create a 4D
-        Panel4D = panelnd.create_nd_panel_factory(
-            klass_name='Panel4D',
-            orders=['labels1', 'items', 'major_axis', 'minor_axis'],
-            slices={'items': 'items', 'major_axis': 'major_axis',
-                    'minor_axis': 'minor_axis'},
-            slicer=Panel,
-            aliases={'major': 'major_axis', 'minor': 'minor_axis'},
-            stat_axis=2)
-
-        p4d = Panel4D(dict(L1=tm.makePanel(), L2=tm.makePanel()))
-
-        # create a 5D
-        Panel5D = panelnd.create_nd_panel_factory(
-            klass_name='Panel5D',
-            orders=['cool1', 'labels1', 'items', 'major_axis',
-                    'minor_axis'],
-            slices={'labels1': 'labels1', 'items': 'items',
-                    'major_axis': 'major_axis',
-                    'minor_axis': 'minor_axis'},
-            slicer=Panel4D,
-            aliases={'major': 'major_axis', 'minor': 'minor_axis'},
-            stat_axis=2)
-
-        p5d = Panel5D(dict(C1=p4d))
-
-        # slice back to 4d
-        results = p5d.ix['C1', :, :, 0:3, :]
-        expected = p4d.ix[:, :, 0:3, :]
-        assert_panel_equal(results['L1'], expected['L1'])
-
-        # test a transpose
-        # results  = p5d.transpose(1,2,3,4,0)
-        # expected =
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+
+            # create a 4D
+            Panel4D = panelnd.create_nd_panel_factory(
+                klass_name='Panel4D',
+                orders=['labels1', 'items', 'major_axis', 'minor_axis'],
+                slices={'items': 'items', 'major_axis': 'major_axis',
+                        'minor_axis': 'minor_axis'},
+                slicer=Panel,
+                aliases={'major': 'major_axis', 'minor': 'minor_axis'},
+                stat_axis=2)
+
+            # deprecation GH13564
+            p4d = Panel4D(dict(L1=tm.makePanel(), L2=tm.makePanel()))
+
+            # create a 5D
+            Panel5D = panelnd.create_nd_panel_factory(
+                klass_name='Panel5D',
+                orders=['cool1', 'labels1', 'items', 'major_axis',
+                        'minor_axis'],
+                slices={'labels1': 'labels1', 'items': 'items',
+                        'major_axis': 'major_axis',
+                        'minor_axis': 'minor_axis'},
+                slicer=Panel4D,
+                aliases={'major': 'major_axis', 'minor': 'minor_axis'},
+                stat_axis=2)
+
+            # deprecation GH13564
+            p5d = Panel5D(dict(C1=p4d))
+
+            # slice back to 4d
+            results = p5d.ix['C1', :, :, 0:3, :]
+            expected = p4d.ix[:, :, 0:3, :]
+            assert_panel_equal(results['L1'], expected['L1'])
+
+            # test a transpose
+            # results  = p5d.transpose(1,2,3,4,0)
+            # expected =
 
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],
diff --git a/pandas/tests/types/test_missing.py b/pandas/tests/types/test_missing.py
index edcb69de7..b0e1eb72b 100644
--- a/pandas/tests/types/test_missing.py
+++ b/pandas/tests/types/test_missing.py
@@ -73,10 +73,11 @@ def test_isnull():
         tm.assert_panel_equal(result, expected)
 
     # panel 4d
-    for p in [tm.makePanel4D(), tm.add_nans_panel4d(tm.makePanel4D())]:
-        result = isnull(p)
-        expected = p.apply(isnull)
-        tm.assert_panel4d_equal(result, expected)
+    with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+        for p in [tm.makePanel4D(), tm.add_nans_panel4d(tm.makePanel4D())]:
+            result = isnull(p)
+            expected = p.apply(isnull)
+            tm.assert_panel4d_equal(result, expected)
 
 
 def test_isnull_lists():
diff --git a/pandas/tools/tests/test_concat.py b/pandas/tools/tests/test_concat.py
index 13c6b72ad..2a8b0a47c 100644
--- a/pandas/tools/tests/test_concat.py
+++ b/pandas/tools/tests/test_concat.py
@@ -704,35 +704,37 @@ class TestConcatenate(ConcatenateBase):
         concat([panel1, panel3], axis=1, verify_integrity=True)
 
     def test_panel4d_concat(self):
-        p4d = tm.makePanel4D()
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            p4d = tm.makePanel4D()
 
-        p1 = p4d.ix[:, :, :5, :]
-        p2 = p4d.ix[:, :, 5:, :]
+            p1 = p4d.ix[:, :, :5, :]
+            p2 = p4d.ix[:, :, 5:, :]
 
-        result = concat([p1, p2], axis=2)
-        tm.assert_panel4d_equal(result, p4d)
+            result = concat([p1, p2], axis=2)
+            tm.assert_panel4d_equal(result, p4d)
 
-        p1 = p4d.ix[:, :, :, :2]
-        p2 = p4d.ix[:, :, :, 2:]
+            p1 = p4d.ix[:, :, :, :2]
+            p2 = p4d.ix[:, :, :, 2:]
 
-        result = concat([p1, p2], axis=3)
-        tm.assert_panel4d_equal(result, p4d)
+            result = concat([p1, p2], axis=3)
+            tm.assert_panel4d_equal(result, p4d)
 
     def test_panel4d_concat_mixed_type(self):
-        p4d = tm.makePanel4D()
+        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+            p4d = tm.makePanel4D()
 
-        # if things are a bit misbehaved
-        p1 = p4d.ix[:, :2, :, :2]
-        p2 = p4d.ix[:, :, :, 2:]
-        p1['L5'] = 'baz'
+            # if things are a bit misbehaved
+            p1 = p4d.ix[:, :2, :, :2]
+            p2 = p4d.ix[:, :, :, 2:]
+            p1['L5'] = 'baz'
 
-        result = concat([p1, p2], axis=3)
+            result = concat([p1, p2], axis=3)
 
-        p2['L5'] = np.nan
-        expected = concat([p1, p2], axis=3)
-        expected = expected.ix[result.labels]
+            p2['L5'] = np.nan
+            expected = concat([p1, p2], axis=3)
+            expected = expected.ix[result.labels]
 
-        tm.assert_panel4d_equal(result, expected)
+            tm.assert_panel4d_equal(result, expected)
 
     def test_concat_series(self):
 
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index 402613d3f..a7c66e18a 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -63,7 +63,6 @@ def set_testing_mode():
     # set the testing mode filters
     testing_mode = os.environ.get('PANDAS_TESTING_MODE', 'None')
     if 'deprecate' in testing_mode:
-
         warnings.simplefilter('always', _testing_mode_warnings)
 
 

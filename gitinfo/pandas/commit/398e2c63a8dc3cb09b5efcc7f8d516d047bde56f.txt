commit 398e2c63a8dc3cb09b5efcc7f8d516d047bde56f
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Jun 7 22:52:59 2011 +0200

    refactoring, refactoring. trying not to make a huge mess

diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 0e445d4e1..e08dfa79a 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -44,57 +44,19 @@ class DataMatrix(DataFrame):
     underlying ndarray to have to be reallocated!).
     """
     objects = None
-    def __init__(self, data=None, index=None, columns=None, dtype=None):
+    def __init__(self, data=None, index=None, columns=None):
         if isinstance(data, dict) and len(data) > 0:
-            (index, columns,
-             values, objects) = self._init_dict(data, index, columns, objects,
-                                                dtype)
+            index, columns, block_manager = _init_dict(data, index, columns)
         elif isinstance(data, (np.ndarray, list)):
-            (index, columns, values) = self._init_matrix(data, index,
-                                                         columns, dtype)
-
-            if objects is not None:
-                if isinstance(objects, DataMatrix):
-                    if not objects.index.equals(index):
-                        objects = objects.reindex(index)
-                else:
-                    objects = DataMatrix(objects, index=index)
-        elif isinstance(data, DataFrame):
-            if not isinstance(data, DataMatrix):
-                data = data.toDataMatrix()
-            values = data.values
-
-            if dtype is not None:
-                values = values.astype(dtype)
-
-            index = data.index
-            columns = data.columns
-            objects = data.objects
+            index, columns, block_manager = _init_matrix(data, index, columns)
         elif data is None or len(data) == 0:
-            # this is a touch convoluted...
-            if objects is not None:
-                if isinstance(objects, DataMatrix):
-                    if index is not None and objects.index is not index:
-                        objects = objects.reindex(index)
-                else:
-                    objects = DataMatrix(objects, index=index)
-
-                index = objects.index
-
-            values = _nan_array(index, columns)
+            raise Exception('TODO!')
         else:
             raise Exception('DataMatrix constructor not properly called!')
 
-        self._float_values = None
-        self._object_values = None
-
-        self._values_dict = {}
-        self._columns_dict = {}
-
-        self._float_values = values
+        self._data = block_manager
         self.index = index
         self.columns = columns
-        self.objects = objects
 
     def _get_values(self):
         return self._data.as_matrix()
@@ -428,10 +390,8 @@ class DataMatrix(DataFrame):
             new_index = self.index[item]
             return self.reindex(new_index)
         else:
-            if self.objects is not None and item in self.objects:
-                return self.objects[item]
-            else:
-                return self._getSeries(item)
+            values = self._data.get(item)
+            return Series(values, index=self.index)
 
     # __setitem__ logic
 
@@ -582,16 +542,9 @@ class DataMatrix(DataFrame):
                 raise Exception('%s not here!' % item)
         return Series(self.values[:, loc], index=self.index)
 
-    def _getSeriesDict(self):
-        series = {}
-        for i, col in enumerate(self.columns):
-            series[col] = self._getSeries(loc=i)
-        if self.objects is not None:
-            for i, col in enumerate(self.objects.columns):
-                series[col] = self.objects._getSeries(loc=i)
-
-        return series
-    _series = property(_getSeriesDict)
+    # to support old APIs
+    def _series(self):
+        return self._data.get_series_dict(self.index)
 
     def _output_columns(self):
         # for toString
@@ -1099,15 +1052,5 @@ def _reorder_columns(mat, current, desired):
     indexer, mask = common.get_indexer(current, desired, None)
     return mat.take(indexer[mask], axis=1)
 
-def _nan_array(index, columns):
-    if index is None:
-        index = NULL_INDEX
-    if columns is None:
-        columns = NULL_INDEX
-
-    values = np.empty((len(index), len(columns)), dtype=dtype)
-    values.fill(NaN)
-    return values
-
 if __name__ == '__main__':
     pass
diff --git a/pandas/core/proto.py b/pandas/core/proto.py
index 2b434f888..d139c78fe 100644
--- a/pandas/core/proto.py
+++ b/pandas/core/proto.py
@@ -3,7 +3,7 @@ import itertools
 from numpy import nan
 import numpy as np
 
-from pandas.core.index import Index
+from pandas.core.index import Index, NULL_INDEX
 from pandas.core.common import _ensure_index
 from pandas.core.series import Series
 import pandas.core.common as common
@@ -124,13 +124,16 @@ class ObjectBlock(Block):
 def make_block(values, columns):
     pass
 
+# TODO: flexible with index=None and/or columns=None
+
 class BlockManager(object):
     """
-    Manage a bunch of 2D mixed-type ndarrays
+    Manage a bunch of labeled 2D mixed-type ndarrays
 
     This is not a public API class
     """
-    def __init__(self, blocks, columns):
+    def __init__(self, blocks, index=None, columns=None):
+        self.index = index
         self.columns = columns
         self.blocks = blocks
 
@@ -146,16 +149,19 @@ class BlockManager(object):
         for block in self.blocks:
             assert(len(block) == length)
 
+    def get_series_dict(self, index):
+        return _blocks_to_series_dict(self.blocks, index)
+
     @property
     def block_length(self):
         return len(self.blocks[0])
 
     def __len__(self):
         # number of blocks
-        return len(self.blocks)
+        return len(self.index)
 
     @classmethod
-    def from_blocks(cls, blocks):
+    def from_blocks(cls, blocks, index):
         # also checks for overlap
         columns = _union_block_columns(blocks)
         return BlockManager(blocks, columns)
@@ -346,6 +352,22 @@ def _union_block_columns(blocks):
 
     return seen
 
+def _nan_manager_matching(index, columns):
+    # what if one of these is empty?
+    values = _nan_array(index, columns)
+    block = Block(values, columns)
+    return BlockManager([block], columns)
+
+def _nan_array(index, columns):
+    if index is None:
+        index = NULL_INDEX
+    if columns is None:
+        columns = NULL_INDEX
+
+    values = np.empty((len(index), len(columns)), dtype=dtype)
+    values.fill(NaN)
+    return values
+
 import unittest
 class TestBlockOperations(unittest.TestCase):
 

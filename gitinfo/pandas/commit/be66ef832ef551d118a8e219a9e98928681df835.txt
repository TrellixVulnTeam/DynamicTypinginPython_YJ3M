commit be66ef832ef551d118a8e219a9e98928681df835
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sat Nov 25 07:10:23 2017 -0800

    Cross off a few tslibs-TODOs (#18443)

diff --git a/pandas/_libs/lib.pyx b/pandas/_libs/lib.pyx
index 956aeaf39..2ec4b5cf1 100644
--- a/pandas/_libs/lib.pyx
+++ b/pandas/_libs/lib.pyx
@@ -929,19 +929,6 @@ def write_csv_rows(list data, ndarray data_index,
 # ------------------------------------------------------------------------------
 # Groupby-related functions
 
-@cython.boundscheck(False)
-def arrmap(ndarray[object] index, object func):
-    cdef int length = index.shape[0]
-    cdef int i = 0
-
-    cdef ndarray[object] result = np.empty(length, dtype=np.object_)
-
-    for i from 0 <= i < length:
-        result[i] = func(index[i])
-
-    return result
-
-
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def is_lexsorted(list list_of_arrays):
diff --git a/pandas/_libs/period.pyx b/pandas/_libs/period.pyx
index d09459898..2b09e9376 100644
--- a/pandas/_libs/period.pyx
+++ b/pandas/_libs/period.pyx
@@ -559,7 +559,6 @@ cdef class _Period(object):
         int64_t ordinal
         object freq
 
-    _comparables = ['name', 'freqstr']
     _typ = 'period'
 
     def __cinit__(self, ordinal, freq):
diff --git a/pandas/_libs/src/datetime/np_datetime.c b/pandas/_libs/src/datetime/np_datetime.c
index 7278cbaff..3c63f42f1 100644
--- a/pandas/_libs/src/datetime/np_datetime.c
+++ b/pandas/_libs/src/datetime/np_datetime.c
@@ -564,18 +564,15 @@ void pandas_datetime_to_datetimestruct(npy_datetime val, PANDAS_DATETIMEUNIT fr,
 
 void pandas_timedelta_to_timedeltastruct(npy_timedelta val,
                                          PANDAS_DATETIMEUNIT fr,
-                                          pandas_timedeltastruct *result) {
+                                         pandas_timedeltastruct *result) {
   pandas_datetime_metadata meta;
 
   meta.base = fr;
-  meta.num - 1;
+  meta.num = 1;
 
   convert_timedelta_to_timedeltastruct(&meta, val, result);
 }
 
-PANDAS_DATETIMEUNIT get_datetime64_unit(PyObject *obj) {
-    return (PANDAS_DATETIMEUNIT)((PyDatetimeScalarObject *)obj)->obmeta.base;
-}
 
 /*
  * Converts a datetime from a datetimestruct to a datetime based
@@ -1001,7 +998,6 @@ int convert_datetime_to_datetimestruct(pandas_datetime_metadata *meta,
 int convert_timedelta_to_timedeltastruct(pandas_timedelta_metadata *meta,
                                          npy_timedelta td,
                                          pandas_timedeltastruct *out) {
-    npy_int64 perday;
     npy_int64 frac;
     npy_int64 sfrac;
     npy_int64 ifrac;
@@ -1016,11 +1012,11 @@ int convert_timedelta_to_timedeltastruct(pandas_timedelta_metadata *meta,
 
         // put frac in seconds
         if (td < 0 && td % (1000LL * 1000LL * 1000LL) != 0)
-          frac = td / (1000LL * 1000LL * 1000LL) - 1;
+            frac = td / (1000LL * 1000LL * 1000LL) - 1;
         else
             frac = td / (1000LL * 1000LL * 1000LL);
 
-          if (frac < 0) {
+        if (frac < 0) {
             sign = -1;
 
             // even fraction
@@ -1030,66 +1026,66 @@ int convert_timedelta_to_timedeltastruct(pandas_timedelta_metadata *meta,
             } else {
               frac = -frac;
             }
-          } else {
+        } else {
             sign = 1;
             out->days = 0;
-          }
+        }
 
-          if (frac >= 86400) {
+        if (frac >= 86400) {
             out->days += frac / 86400LL;
             frac -= out->days * 86400LL;
-          }
+        }
 
-          if (frac >= 3600) {
+        if (frac >= 3600) {
             out->hrs = frac / 3600LL;
             frac -= out->hrs * 3600LL;
-          } else {
+        } else {
             out->hrs = 0;
-          }
+        }
 
-          if (frac >= 60) {
+        if (frac >= 60) {
             out->min = frac / 60LL;
             frac -= out->min * 60LL;
-          } else {
+        } else {
             out->min = 0;
-          }
+        }
 
-          if (frac >= 0) {
+        if (frac >= 0) {
             out->sec = frac;
             frac -= out->sec;
-          } else {
+        } else {
             out->sec = 0;
-          }
+        }
 
-          sfrac = (out->hrs * 3600LL + out->min * 60LL
-                   + out->sec) * (1000LL * 1000LL * 1000LL);
+        sfrac = (out->hrs * 3600LL + out->min * 60LL
+                 + out->sec) * (1000LL * 1000LL * 1000LL);
 
-          if (sign < 0)
+        if (sign < 0)
             out->days = -out->days;
 
-          ifrac = td - (out->days * DAY_NS + sfrac);
+        ifrac = td - (out->days * DAY_NS + sfrac);
 
-          if (ifrac != 0) {
+        if (ifrac != 0) {
             out->ms = ifrac / (1000LL * 1000LL);
             ifrac -= out->ms * 1000LL * 1000LL;
             out->us = ifrac / 1000LL;
             ifrac -= out->us * 1000LL;
             out->ns = ifrac;
-          } else {
+        } else {
             out->ms = 0;
             out->us = 0;
             out->ns = 0;
-          }
+        }
 
-          out->seconds = out->hrs * 3600 + out->min * 60 + out->sec;
-          out->microseconds = out->ms * 1000 + out->us;
-          out->nanoseconds = out->ns;
-          break;
+        out->seconds = out->hrs * 3600 + out->min * 60 + out->sec;
+        out->microseconds = out->ms * 1000 + out->us;
+        out->nanoseconds = out->ns;
+        break;
 
         default:
             PyErr_SetString(PyExc_RuntimeError,
-                            "NumPy datetime metadata is corrupted with invalid "
-                            "base unit");
+                            "NumPy timedelta metadata is corrupted with "
+                            "invalid base unit");
             return -1;
     }
 
diff --git a/pandas/_libs/src/datetime/np_datetime.h b/pandas/_libs/src/datetime/np_datetime.h
index c51a4bdda..7ee7e1e99 100644
--- a/pandas/_libs/src/datetime/np_datetime.h
+++ b/pandas/_libs/src/datetime/np_datetime.h
@@ -148,7 +148,4 @@ convert_timedelta_to_timedeltastruct(pandas_timedelta_metadata *meta,
                                      pandas_timedeltastruct *out);
 
 
-PANDAS_DATETIMEUNIT get_datetime64_unit(PyObject *obj);
-
-
 #endif  // PANDAS__LIBS_SRC_DATETIME_NP_DATETIME_H_
diff --git a/pandas/_libs/tslib.pyx b/pandas/_libs/tslib.pyx
index 2c43bed4a..6d8cf3911 100644
--- a/pandas/_libs/tslib.pyx
+++ b/pandas/_libs/tslib.pyx
@@ -60,7 +60,7 @@ from tslibs.conversion cimport (tz_convert_single, _TSObject,
 from tslibs.conversion import tz_convert_single
 
 from tslibs.nattype import NaT, nat_strings, iNaT
-from tslibs.nattype cimport _checknull_with_nat, NPY_NAT
+from tslibs.nattype cimport checknull_with_nat, NPY_NAT
 
 from tslibs.timestamps cimport (create_timestamp_from_ts,
                                 _NS_UPPER_BOUND, _NS_LOWER_BOUND)
@@ -409,7 +409,7 @@ cpdef array_with_unit_to_datetime(ndarray values, unit, errors='coerce'):
         for i in range(n):
             val = values[i]
 
-            if _checknull_with_nat(val):
+            if checknull_with_nat(val):
                 iresult[i] = NPY_NAT
 
             elif is_integer_object(val) or is_float_object(val):
@@ -475,7 +475,7 @@ cpdef array_with_unit_to_datetime(ndarray values, unit, errors='coerce'):
     for i in range(n):
         val = values[i]
 
-        if _checknull_with_nat(val):
+        if checknull_with_nat(val):
             oresult[i] = NaT
         elif is_integer_object(val) or is_float_object(val):
 
@@ -526,7 +526,7 @@ cpdef array_to_datetime(ndarray[object] values, errors='raise',
         for i in range(n):
             val = values[i]
 
-            if _checknull_with_nat(val):
+            if checknull_with_nat(val):
                 iresult[i] = NPY_NAT
 
             elif PyDateTime_Check(val):
@@ -686,7 +686,7 @@ cpdef array_to_datetime(ndarray[object] values, errors='raise',
             val = values[i]
 
             # set as nan except if its a NaT
-            if _checknull_with_nat(val):
+            if checknull_with_nat(val):
                 if PyFloat_Check(val):
                     oresult[i] = np.nan
                 else:
@@ -704,7 +704,7 @@ cpdef array_to_datetime(ndarray[object] values, errors='raise',
 
         for i in range(n):
             val = values[i]
-            if _checknull_with_nat(val):
+            if checknull_with_nat(val):
                 oresult[i] = val
             elif is_string_object(val):
 
diff --git a/pandas/_libs/tslibs/conversion.pyx b/pandas/_libs/tslibs/conversion.pyx
index f58ad0a86..7f3cc0a7e 100644
--- a/pandas/_libs/tslibs/conversion.pyx
+++ b/pandas/_libs/tslibs/conversion.pyx
@@ -40,7 +40,7 @@ from timezones cimport (
 from parsing import parse_datetime_string
 
 from nattype import nat_strings, NaT
-from nattype cimport NPY_NAT, _checknull_with_nat
+from nattype cimport NPY_NAT, checknull_with_nat
 
 # ----------------------------------------------------------------------
 # Constants
@@ -143,7 +143,7 @@ def datetime_to_datetime64(ndarray[object] values):
     iresult = result.view('i8')
     for i in range(n):
         val = values[i]
-        if _checknull_with_nat(val):
+        if checknull_with_nat(val):
             iresult[i] = NPY_NAT
         elif PyDateTime_Check(val):
             if val.tzinfo is not None:
diff --git a/pandas/_libs/tslibs/nattype.pxd b/pandas/_libs/tslibs/nattype.pxd
index 34fa1e703..96e02142d 100644
--- a/pandas/_libs/tslibs/nattype.pxd
+++ b/pandas/_libs/tslibs/nattype.pxd
@@ -6,4 +6,4 @@ cdef int64_t NPY_NAT
 
 cdef bint _nat_scalar_rules[6]
 
-cdef bint _checknull_with_nat(object val)
+cdef bint checknull_with_nat(object val)
diff --git a/pandas/_libs/tslibs/nattype.pyx b/pandas/_libs/tslibs/nattype.pyx
index d2f6006b4..2e7b861b2 100644
--- a/pandas/_libs/tslibs/nattype.pyx
+++ b/pandas/_libs/tslibs/nattype.pyx
@@ -572,7 +572,7 @@ NaT = NaTType()
 
 # ----------------------------------------------------------------------
 
-cdef inline bint _checknull_with_nat(object val):
+cdef inline bint checknull_with_nat(object val):
     """ utility to check if a value is a nat or not """
     return val is None or (
         PyFloat_Check(val) and val != val) or val is NaT
diff --git a/pandas/_libs/tslibs/strptime.pyx b/pandas/_libs/tslibs/strptime.pyx
index 439cc21a3..65594de58 100644
--- a/pandas/_libs/tslibs/strptime.pyx
+++ b/pandas/_libs/tslibs/strptime.pyx
@@ -38,7 +38,7 @@ from np_datetime cimport (check_dts_bounds,
 
 from util cimport is_string_object
 
-from nattype cimport _checknull_with_nat, NPY_NAT
+from nattype cimport checknull_with_nat, NPY_NAT
 from nattype import nat_strings
 
 
@@ -142,7 +142,7 @@ def array_strptime(ndarray[object] values, object fmt,
                 iresult[i] = NPY_NAT
                 continue
         else:
-            if _checknull_with_nat(val):
+            if checknull_with_nat(val):
                 iresult[i] = NPY_NAT
                 continue
             else:
diff --git a/pandas/_libs/tslibs/timedeltas.pyx b/pandas/_libs/tslibs/timedeltas.pyx
index 6ea306426..b37e5dc62 100644
--- a/pandas/_libs/tslibs/timedeltas.pyx
+++ b/pandas/_libs/tslibs/timedeltas.pyx
@@ -30,7 +30,7 @@ from np_datetime cimport (cmp_scalar, reverse_ops, td64_to_tdstruct,
                           pandas_timedeltastruct)
 
 from nattype import nat_strings, NaT
-from nattype cimport _checknull_with_nat, NPY_NAT
+from nattype cimport checknull_with_nat, NPY_NAT
 
 # ----------------------------------------------------------------------
 # Constants
@@ -111,7 +111,7 @@ cpdef convert_to_timedelta64(object ts, object unit):
     # kludgy here until we have a timedelta scalar
     # handle the numpy < 1.7 case
     """
-    if _checknull_with_nat(ts):
+    if checknull_with_nat(ts):
         return np.timedelta64(NPY_NAT)
     elif isinstance(ts, Timedelta):
         # already in the proper format
@@ -443,7 +443,7 @@ cdef inline timedelta_from_spec(object number, object frac, object unit):
 
 cdef bint _validate_ops_compat(other):
     # return True if we are compat with operating
-    if _checknull_with_nat(other):
+    if checknull_with_nat(other):
         return True
     elif PyDelta_Check(other) or is_timedelta64_object(other):
         return True
@@ -837,7 +837,7 @@ class Timedelta(_Timedelta):
         elif is_integer_object(value) or is_float_object(value):
             # unit=None is de-facto 'ns'
             value = convert_to_timedelta64(value, unit)
-        elif _checknull_with_nat(value):
+        elif checknull_with_nat(value):
             return NaT
         else:
             raise ValueError(

commit eab5f43da3b595ca2f15d36a58fa6536f75f4cce
Author: Adam Klein <adamklein@gmail.com>
Date:   Tue Jan 24 20:18:13 2012 -0500

    ported dateutil relativedelta to cython, sketching idea for filter class

diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index e8641544f..ca42f34fe 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -76,7 +76,8 @@ cdef extern from "np_datetime.h":
                                              int apply_tzinfo)
 
     int is_leapyear(int64_t year)
-
+    int _days_per_month_table[2][12]
+    int dayofweek(int y, int m, int d)
 
 cdef extern from "np_datetime_strings.h":
 
@@ -90,3 +91,7 @@ cdef extern from "np_datetime_strings.h":
                                NPY_CASTING casting)
 
     int get_datetime_iso_8601_strlen(int local, NPY_DATETIMEUNIT base)
+
+cdef extern from "stdint.h":
+    enum: INT64_MIN
+
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index eccbad36a..47ad429b4 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -3,7 +3,9 @@ import numpy as np
 
 from numpy cimport int32_t, int64_t, import_array, ndarray
 from cpython cimport *
+
 from libc.stdlib cimport malloc, free
+from libc.math cimport floor
 
 # this is our datetime.pxd
 from datetime cimport *
@@ -19,13 +21,14 @@ PyDateTime_IMPORT
 # in numpy 1.7, will prob need this
 # numpy_pydatetime_import
 
-# Objects to support date/time arithmetic, inspired by the architecture of the
-# lubridate R package, to eventually handle all datetime logic in pandas.
+# Objects to support date/time arithmetic
 # --------------------------------------------------------------------------------
 
 cdef class Timestamp:
     '''
-    A timestamp (absolute moment in time) to microsecond resolution, in UTC.
+    A timestamp (absolute moment in time) to microsecond resolution; number of
+    microseconds since the POSIX epoch, ignoring leap seconds (thereby different
+    from UTC).
     '''
     cdef:
         int64_t value
@@ -38,6 +41,7 @@ cdef class Timestamp:
             - python int or long object
             - iso8601 string object
             - python datetime object
+            - another timestamp object
         """
         cdef:
             Py_ssize_t strlen
@@ -52,35 +56,54 @@ cdef class Timestamp:
                                     &self.dts, &islocal, &out_bestunit, &special)
             self.value = PyArray_DatetimeStructToDatetime(NPY_FR_us, &self.dts)
         elif PyDateTime_Check(ts):
-            convert_pydatetime_to_datetimestruct(<PyObject *>ts, &self.dts, 
+            convert_pydatetime_to_datetimestruct(<PyObject *>ts, &self.dts,
                                                  &out_bestunit, 1)
             self.value = PyArray_DatetimeStructToDatetime(out_bestunit, &self.dts)
         else:
             raise ValueError("Could not construct Timestamp from argument")
 
     def __sub__(self, object other):
-        ''' 
+        '''
         Subtract two timestamps, results in an interval with the start being
-        the earlier of the two timestamps. 
+        the earlier of the two timestamps.
         '''
         if isinstance(other, Timestamp):
-            if other.value > self.value:
-                return Interval(self.value, other.value)
-            else:
-                return Interval(other.value, self.value)
+            return Interval(self, other)
+        elif isinstance(other, Delta):
+            return other.__sub__(self)
+        else:
+            raise NotImplementedError("Sub operation not supported")
+
+    def __richcmp__(self, object other, int op):
+        if not isinstance(other, Timestamp):
+            raise ValueError("Cannot compare to non-Timestamp")
+
+        if op == 0:
+            return self.asint < other.asint
+        if op == 2:
+            return self.asint == other.asint
+        if op == 4:
+            return self.asint > other.asint
+        if op == 1:
+            return self.asint <= other.asint
+        if op == 3:
+            return self.asint != other.asint
+        if op == 5:
+            return self.asint >= other.asint
+
+        raise NotImplementedError("Op %d not recognized" % op)
 
     def __add__(self, object other):
         '''
         Add an Interval, Duration, or Period to the Timestamp, resulting in 
         new Timestamp.
         '''
-        if isinstance(other, Interval):
-            return Timestamp(self.value + other.dur.length)
-        elif isinstance(other, Duration):
-            return Timestamp(self.value + other.length)
-        elif isinstance(other, Period):
-            # TODO: fix me
-            raise ValueError("TODO: Period needs to be implemented")
+        if isinstance(other, (Interval, Duration)):
+            return Timestamp(self.asint + other.length)
+        elif isinstance(other, Delta):
+            return other.__add__(self)
+        else:
+            raise NotImplementedError("Add operation not supported")
 
     def __str__(self):
         '''
@@ -101,7 +124,31 @@ cdef class Timestamp:
 
         return py_str
 
-    property value:
+    def replace(self, int year=-1, int month=-1, int day=-1, int hour=-1,
+                      int minute=-1, int second=-1, int microsecond=-1):
+        cdef:
+            npy_datetimestruct dts
+
+        dts = self.dts
+
+        if year >= 0:
+            dts.year = year
+        if month >= 1:
+            dts.month = month
+        if day >= 1:
+            dts.day = day
+        if hour >= 0:
+            dts.hour = hour
+        if minute >= 0:
+            dts.min = minute
+        if second >= 0:
+            dts.sec = second
+        if microsecond >= 0:
+            dts.us = microsecond
+
+        return Timestamp(PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts))
+
+    property asint:
         def __get__(self):
             return self.value
 
@@ -121,25 +168,26 @@ cdef class Timestamp:
         def __get__(self):
             return self.dts.hour
 
-    property min:
+    property minute:
         def __get__(self):
             return self.dts.min
 
-    property sec:
+    property second:
         def __get__(self):
             return self.dts.sec
 
-    property ms:
-        def __get__(self):
-            return self.dts.us // 1000.
-
-    property us:
+    property microsecond:
         def __get__(self):
             return self.dts.us
 
+    def weekday(self):
+        return dayofweek(self.dts.year, self.month, self.day)
+
+
 cdef class Interval:
     '''
-    An absolute time span, from one timestamp to another
+    An absolute time span, from one timestamp to another. Normalized
+    to seconds, microseconds, and days.
     '''
     cdef:
         Timestamp start
@@ -157,160 +205,585 @@ cdef class Interval:
         def __get__(self):
             return self.end
 
-    property us:
+    property length:
         def __get__(self):
-            return Duration(self.end - self.start).us
+            cdef int64_t diff = self.end.asint - self.start.asint
+            return diff
 
-    property ms:
+    property microseconds:
         def __get__(self):
-            return Duration(self.end - self.start).ms
+            cdef int64_t diff = self.end.asint - self.start.asint
+            return diff % 1000000
 
-    property secs:
+    property seconds:
         def __get__(self):
-            return Duration(self.end - self.start).secs
+            cdef int64_t diff = self.end.asint - self.start.asint
+            return (diff // 1000000) % 86400
+
+    property days:
+        def __get__(self):
+            cdef int64_t diff = self.end.asint - self.start.asint
+            return (diff // 1000000) // 86400
+
+    def __str__(self):
+        return "Interval(%s, %s)" % (str(self.start), str(self.end))
+
 
 cdef class Duration:
     '''
-    Absolute length of time, in microseconds
+    Absolute length of time, similar to timedelta (but faster!)
     '''
     cdef int64_t length
 
-    def __init__(self, int64_t us = 1):
-        self.length = us
+    def __init__(self, int64_t days = 0,
+                       int64_t seconds = 0,
+                       int64_t microseconds = 0,
+                       int64_t milliseconds = 0,
+                       int64_t minutes = 0,
+                       int64_t hours = 0,
+                       int64_t weeks = 0):
+
+        self.length =  (microseconds + 1000 * (milliseconds
+                                     + 1000 * (seconds
+                                     + 60   * (minutes
+                                     + 60   * (hours
+                                     + 24   * (days
+                                     +  7   * weeks))))))
+
+    @staticmethod
+    def from_micros(int64_t length):
+        return Duration(microseconds = length)
 
     def __str__(self):
         return "Duration (%d)" % self.length
 
-    property us:
+    property length:
         def __get__(self):
             return self.length
 
-    property ms:
+    property microseconds:
         def __get__(self):
-            return self.length // 1000
+            return self.length % 1000000
 
-    property secs:
+    property seconds:
         def __get__(self):
-            return self.length // 1000000
+            return (self.length // 1000000) % 86400
 
-cdef class Period:
-    '''
-    Relative length of time
-    '''
+    property days:
+        def __get__(self):
+            return (self.length // 1000000) // 86400
+
+    def __repr__(self):
+        return "Duration(%d, %d, %d)" % (self.days, self.seconds, self.microseconds)
+
+cdef class Filter:
+    """
+    The idea of this class is to select out, quickly, the timestamps within
+    an interval that satisfy some criteria.
+
+    The purpose is to allow us to construct a DatetimeIndex very quickly
+    between two points in time.
+
+    Some examples might be:
+    - Business days
+    - Business month ends
+    - Last friday before end of month
+    - Quarterly business month ends, where first quarter is Feb
+    """
+    def __init__(self):
+        pass
+
+
+# The following is derived from relativedelta.py in dateutil package
+# ------------------------------------------------------------------------------
+# Copyright (c) 2003-2010  Gustavo Niemeyer <gustavo@niemeyer.net>
+# under Simplified BSD
+
+cdef class Weekday:
     cdef:
-        npy_datetimestruct dts
-        int isbiz
+        int64_t weekday, n
+
+    def __init__(self, int64_t weekday, int64_t n = INT64_MIN):
+        if weekday < 0 or weekday > 6:
+            raise ValueError("Invalid weekday: %d", weekday)
+
+        self.weekday = weekday
+        self.n = n
+
+    def __call__(self, int n):
+        if n == self.n:
+            return self
+        else:
+            return self.__class__(self.weekday, n)
+
+    def __richcmp__(self, other, int op):
+        isequal = False
+
+        if not isinstance(other, Weekday):
+            isequal = False
+        else:
+            isequal = (self.weekday == other.weekday and self.n == other.n)
+
+        if op == 2: # equals
+            return isequal
+        if op == 3: # not equals
+            return not isequal
+
+        raise NotImplementedError("Comparison not supported")
+
+    property weekday:
+        def __get__(self):
+            return self.weekday
+
+    property n:
+        def __get__(self):
+            return self.n if self.n != INT64_MIN else None
+
+    def __repr__(self):
+        s = ("MO", "TU", "WE", "TH", "FR", "SA", "SU")[self.weekday]
+        if self.n == INT64_MIN:
+            return s
+        else:
+            return "%s(%+d)" % (s, self.n)
+
+MO, TU, WE, TH, FR, SA, SU = weekdays = tuple(Weekday(x) for x in range(7))
+
+cdef class Delta:
+    """
+    There's two different ways to build a Delta instance. The
+    first one is passing it two Timestamp classes:
+
+        Delta(Timestamp1, Timestamp1)
+
+    In which case the following holds:
+
+        Timestamp1 + Delta(Timestamp1, Timestamp2) == TimeStamp2
+
+    And the other way is to use the following keyword arguments:
+
+        year, month, day, hour, minute, second, microsecond:
+            Absolute information.
+
+        years, months, weeks, days, hours, minutes, seconds, microseconds:
+            Relative information, may be negative.
+
+        weekday:
+            One of the weekday instances (MO, TU, etc). These instances may
+            receive a parameter N, specifying the Nth weekday, which could
+            be positive or negative (like MO(+1) or MO(-2). Not specifying
+            it is the same as specifying +1. You can also use an integer,
+            where 0=MO.
+
+        leapdays:
+            Will add given days to the date found, if year is a leap
+            year, and the date found is post 28 of february.
+
+        yearday, nlyearday:
+            Set the yearday or the non-leap year day (jump leap days).
+            These are converted to day/month/leapdays information.
+
+    Here is the behavior of operations with Delta:
+
+    1) Calculate the absolute year, using the 'year' argument, or the
+    original datetime year, if the argument is not present.
+
+    2) Add the relative 'years' argument to the absolute year.
 
-    def __init__(self, int years = 0, int months = 0, int days = 0,
-                       int hours = 0, int mins = 0, int secs = 0):
-        self.dts.year = years
-        self.dts.month = months
-        self.dts.day = days
-        self.dts.hour = hours
-        self.dts.min = mins
-        self.dts.sec = secs
+    3) Do steps 1 and 2 for month/months.
+
+    4) Calculate the absolute day, using the 'day' argument, or the
+    original datetime day, if the argument is not present. Then,
+    subtract from the day until it fits in the year and month
+    found after their operations.
+
+    5) Add the relative 'days' argument to the absolute day. Notice
+    that the 'weeks' argument is multiplied by 7 and added to
+    'days'.
+
+    6) Do steps 1 and 2 for hour/hours, minute/minutes, second/seconds,
+    microsecond/microseconds.
+
+    7) If the 'weekday' argument is present, calculate the weekday,
+    with the given (wday, nth) tuple. wday is the index of the
+    weekday (0-6, 0=Mon), and nth is the number of weeks to add
+    forward or backward, depending on its signal. Notice that if
+    the calculated date is already Monday, for example, using
+    (0, 1) or (0, -1) won't change the day.
+    """
+
+    cdef:
+        int64_t years, months, days, leapdays, hours, minutes, seconds, microseconds
+        int64_t year, month, day, hour, minute, second, microsecond
+        object weekday
+
+    def __init__(self,
+
+                 object ts1=None,
+                 object ts2=None,
+
+                 int64_t years=0,
+                 int64_t months=0,
+                 int64_t days=0,
+                 int64_t leapdays=0,
+                 int64_t weeks=0,
+                 int64_t hours=0,
+                 int64_t minutes=0,
+                 int64_t seconds=0,
+                 int64_t microseconds=0,
+
+                 int64_t year=-1,
+                 int64_t month=-1,
+                 int64_t day=-1,
+                 int64_t yearday=-1,
+                 int64_t nlyearday=-1,
+                 int64_t hour=-1,
+                 int64_t minute=-1,
+                 int64_t second=-1,
+                 int64_t microsecond=-1,
+
+                 object weekday=None):
+
+        if ts1 and ts2:
+            if not (isinstance(ts1, Timestamp) and isinstance(ts2, Timestamp)):
+                raise TypeError("Delta only diffs Timestamp")
+
+            self.years = 0
+            self.months = 0
+            self.days = 0
+            self.leapdays = 0
+            self.hours = 0
+            self.minutes = 0
+            self.seconds = 0
+            self.microseconds = 0
+
+            self.year = -1
+            self.month = -1
+            self.day = -1
+            self.hour = -1
+            self.minute = -1
+            self.second = -1
+            self.microsecond = -1
+            self.weekday = None
+
+            # difference in months
+            months = (ts1.year * 12 + ts1.month) - (ts2.year * 12 + ts2.month)
+            self._set_months(months)
+
+            # add ourself (delta) to ts2
+            dtm = self.__add__(ts2)
+
+            if ts1 < ts2:
+                while ts1 > dtm:
+                    months += 1
+                    self._set_months(months)
+                    dtm = self.__add__(ts2)
+            else:
+                while ts1 < dtm:
+                    months -= 1
+                    self._set_months(months)
+                    dtm = self.__add__(ts2)
+            delta = ts1 - dtm
+            self.seconds = delta.seconds + delta.days * 86400
+            self.microseconds = delta.microseconds
+        else:
+            self.years = years
+            self.months = months
+            self.days = days + weeks * 7
+            self.leapdays = leapdays
+            self.hours = hours
+            self.minutes = minutes
+            self.seconds = seconds
+            self.microseconds = microseconds
+            self.year = year
+            self.month = month
+            self.day = day
+            self.hour = hour
+            self.minute = minute
+            self.second = second
+            self.microsecond = microsecond
+
+            if isinstance(weekday, Weekday):
+                self.weekday = weekday
+            elif isinstance(weekday, type(None)):
+                self.weekday = None
+            else:
+                self.weekday = weekdays[weekday]
+
+            yday = 0
+            if nlyearday != -1:
+                yday = nlyearday
+            elif yearday != -1:
+                yday = yearday
+                if yearday > 59:
+                    self.leapdays = -1
+            if yday != -1:
+                ydayidx = [31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,
+                           366]
+                for idx, ydays in enumerate(ydayidx):
+                    if yday <= ydays:
+                        self.month = idx + 1
+                        if idx == 0:
+                            self.day = yday
+                        else:
+                            self.day = yday - ydayidx[idx-1]
+                        break
+                else:
+                    raise ValueError("invalid year day (%d)" % yday)
+
+        self._fix()
+
+    def _fix(self):
+        if abs(self.microseconds) > 999999:
+            s = self.microseconds//abs(self.microseconds)
+            div, mod = divmod(self.microseconds*s, 1000000)
+            self.microseconds = mod*s
+            self.seconds += div*s
+        if abs(self.seconds) > 59:
+            s = self.seconds//abs(self.seconds)
+            div, mod = divmod(self.seconds*s, 60)
+            self.seconds = mod*s
+            self.minutes += div*s
+        if abs(self.minutes) > 59:
+            s = self.minutes//abs(self.minutes)
+            div, mod = divmod(self.minutes*s, 60)
+            self.minutes = mod*s
+            self.hours += div*s
+        if abs(self.hours) > 23:
+            s = self.hours//abs(self.hours)
+            div, mod = divmod(self.hours*s, 24)
+            self.hours = mod*s
+            self.days += div*s
+        if abs(self.months) > 11:
+            s = self.months//abs(self.months)
+            div, mod = divmod(self.months*s, 12)
+            self.months = mod*s
+            self.years += div*s
+
+    def _set_months(self, months):
+        self.months = months
+        if abs(self.months) > 11:
+            s = self.months//abs(self.months)
+            div, mod = divmod(self.months*s, 12)
+            self.months = mod*s
+            self.years = div*s
+        else:
+            self.years = 0
 
     def __add__(self, other):
-        if issubclass(other, Period):
-            return Period(years = self.years + other.years,
-                          months = self.months + other.months,
-                          days = self.days + other.days,
-                          hours = self.hours + other.hours,
-                          mins = self.mins + other.mins,
-                          secs = self.secs + other.secs)
-        raise ValueError("Could not add Period to operand")
+        if isinstance(other, Delta):
+            return self._add_delta(other)
 
-    def __str__(self):
-        strbuf = ""
-        if self.dts.year > 0:
-            strbuf += "%d " % self.dts.year
-            strbuf += "year"
-            if self.dts.year > 1:
-                strbuf += "s"
-        if self.dts.month > 0:
-            if len(strbuf):
-                strbuf += ", "
-            strbuf += "%d " % self.dts.month
-            strbuf += "month"
-            if self.dts.month > 1:
-                strbuf += "s"
-        if self.dts.day > 0:
-            if len(strbuf):
-                strbuf += ", "
-            strbuf += "%d " % self.dts.day
-            strbuf += "day"
-            if self.dts.day > 1:
-                strbuf += "s"
-        if self.dts.hour > 0:
-            if len(strbuf):
-                strbuf += ", "
-            strbuf += "%d " % self.dts.hour
-            strbuf += "hour"
-            if self.dts.hour > 1:
-                strbuf += "s"
-        if self.dts.min > 0:
-            if len(strbuf):
-                strbuf += ", "
-            strbuf += "%d " % self.dts.min
-            strbuf += "min"
-            if self.dts.min > 1:
-                strbuf += "s"
-        if self.dts.sec > 0:
-            if len(strbuf):
-                strbuf += ", "
-            strbuf += "%d " % self.dts.sec
-            strbuf += "sec"
-            if self.dts.sec > 1:
-                strbuf += "s"
-
-        return "Period: %s" % strbuf
+        if isinstance(other, Timestamp):
+            return self._add_timestamp(other)
+
+        raise ValueError("Cannot add to Delta")
+
+    def _add_timestamp(self, other):
+        year = (self.year if self.year != -1 else other.year) + self.years
+        month = (self.month if self.month != -1 else other.month)
+
+        if self.months:
+            assert 1 <= abs(self.months) <= 12
+            month += self.months
+            if month > 12:
+                year += 1
+                month -= 12
+            elif month < 1:
+                year -= 1
+                month += 12
+        day = min(monthrange(year, month)[1],
+                  self.day if self.day != -1 else other.day)
+        repl = {"year": year, "month": month, "day": day}
+        for attr in ["hour", "minute", "second", "microsecond"]:
+            value = getattr(self, attr)
+            if value != -1:
+                repl[attr] = value
+        days = self.days
+        if self.leapdays and month > 2 and isleapyear(year):
+            days += self.leapdays
+        ret = (other.replace(**repl)
+               + Duration(days=days,
+                          hours=self.hours,
+                          minutes=self.minutes,
+                          seconds=self.seconds,
+                          microseconds=self.microseconds))
+        if self.weekday:
+            weekday, nth = self.weekday.weekday, (self.weekday.n or 1)
+
+            jumpdays = (abs(nth)-1)*7
+            if nth > 0:
+                jumpdays += (7-ret.weekday()+weekday)%7
+            else:
+                jumpdays += (ret.weekday()-weekday)%7
+                jumpdays *= -1
+            ret += Duration(days=jumpdays)
+
+        return ret
+
+    def _add_delta(self, other):
+        return Delta(years=other.years+self.years,
+                    months=other.months+self.months,
+                    days=other.days+self.days,
+                    hours=other.hours+self.hours,
+                    minutes=other.minutes+self.minutes,
+                    seconds=other.seconds+self.seconds,
+                    microseconds=other.microseconds+self.microseconds,
+                    leapdays=other.leapdays if other.leapdays != -1 else self.leapdays,
+                    year=other.year if other.year != -1 else self.year,
+                    month=other.month if other.month != -1 else self.month,
+                    day=other.day if other.day != -1 else self.day,
+                    weekday=other.weekday or self.weekday,
+                    hour=other.hour if other.hour != -1 else self.hour,
+                    minute=other.minute if other.minute != -1 else self.minute,
+                    second=other.second if other.second != -1 else self.second,
+                    microsecond=(other.microsecond if other.microsecond != -1
+                                                    else self.microsecond))
+
+
+    def __sub__(self, other):
+        if isinstance(other, Delta):
+            return self._sub_delta(other)
+        else:
+            return self.__neg__().__add__(other)
+
+    def _sub_delta(self, other):
+        return Delta(years=other.years-self.years,
+                    months=other.months-self.months,
+                    days=other.days-self.days,
+                    hours=other.hours-self.hours,
+                    minutes=other.minutes-self.minutes,
+                    seconds=other.seconds-self.seconds,
+                    microseconds=other.microseconds-self.microseconds,
+                    leapdays=other.leapdays if other.leapdays != -1 else self.leapdays,
+                    year=other.year if other.year != -1 else self.year,
+                    month=other.month if other.month != -1 else self.month,
+                    day=other.day if other.day != -1 else self.day,
+                    weekday=other.weekday or self.weekday,
+                    hour=other.hour if other.hour != -1 else self.hour,
+                    minute=other.minute if other.minute != -1 else self.minute,
+                    second=other.second if other.second != -1 else self.second,
+                    microsecond=(other.microsecond if other.microsecond != -1
+                                                    else self.microsecond))
+
+    def __neg__(self):
+        return Delta(years=-self.years,
+                     months=-self.months,
+                     days=-self.days,
+                     hours=-self.hours,
+                     minutes=-self.minutes,
+                     seconds=-self.seconds,
+                     microseconds=-self.microseconds,
+                     leapdays=self.leapdays,
+                     year=self.year,
+                     month=self.month,
+                     day=self.day,
+                     weekday=self.weekday,
+                     hour=self.hour,
+                     minute=self.minute,
+                     second=self.second,
+                     microsecond=self.microsecond)
+
+
+    def __mul__(self, double f):
+        return Delta(years=self.years*f,
+                     months=self.months*f,
+                     days=self.days*f,
+                     hours=self.hours*f,
+                     minutes=self.minutes*f,
+                     seconds=self.seconds*f,
+                     microseconds=self.microseconds*f,
+                     leapdays=self.leapdays,
+                     year=self.year,
+                     month=self.month,
+                     day=self.day,
+                     weekday=self.weekday,
+                     hour=self.hour,
+                     minute=self.minute,
+                     second=self.second,
+                     microsecond=self.microsecond)
+
+    def __div__(self, double f):
+        return self.__mul__(1./f)
+
+    def __repr__(self):
+        l = []
+        for attr in ["years", "months", "days", "leapdays",
+                     "hours", "minutes", "seconds", "microseconds"]:
+            value = getattr(self, attr)
+            if value:
+                l.append("%s=%+d" % (attr, value))
+        for attr in ["year", "month", "day", "weekday",
+                     "hour", "minute", "second", "microsecond"]:
+            value = getattr(self, attr)
+            if value != -1:
+                l.append("%s=%s" % (attr, value))
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(l))
 
-    property years:
+    property year:
         def __get__(self):
-            return self.dts.year
-    property months:
+            return self.year
+
+    property month:
         def __get__(self):
-            return self.dts.month
-    property days:
+            return self.month
+
+    property day:
         def __get__(self):
-            return self.dts.day
-    property hours:
+            return self.day
+
+    property weekday:
         def __get__(self):
-            return self.dts.hour
-    property mins:
+            return self.weekday
+
+    property hour:
         def __get__(self):
-            return self.dts.min
-    property secs:
+            return self.hour
+
+    property minute:
         def __get__(self):
-            return self.dts.sec
+            return self.minute
+
+    property second:
+        def __get__(self):
+            return self.second
+
+    property microsecond:
+        def __get__(self):
+            return self.microsecond
 
-def seconds(int count):
-    return Period(secs = count)
+    property years:
+        def __get__(self):
+            return self.years
 
-def minutes(int count):
-    return Period(mins = count)
+    property months:
+        def __get__(self):
+            return self.months
 
-def hours(int count):
-    return Period(hours = count)
+    property days:
+        def __get__(self):
+            return self.days
 
-def days(int count):
-    return Period(days = count)
+    property leapdays:
+        def __get__(self):
+            return self.leapdays
 
-# TODO: fixme
-def bdays(int count):
-    return Period(days = count)
+    property hours:
+        def __get__(self):
+            return self.hours
 
-def weeks(int count):
-    return Period(days = 7 * count)
+    property minutes:
+        def __get__(self):
+            return self.minutes
 
-def months(int count):
-    return Period(months = count)
+    property seconds:
+        def __get__(self):
+            return self.seconds
 
-def quarters(int count):
-    return Period(months = 3 * count)
+    property microseconds:
+        def __get__(self):
+            return self.microseconds
 
-def years(int count):
-    return Period(years = count)
+# End derivation from dateutil
 
 
 # Conversion routines
@@ -416,3 +889,18 @@ def fast_field_accessor(ndarray[int64_t] dtindex, object field):
 
 def isleapyear(int64_t year):
     return is_leapyear(year)
+
+def monthrange(int64_t year, int64_t month):
+    cdef:
+        int64_t days
+        int64_t day_of_week
+
+    if month < 1 or month > 12:
+        raise ValueError("bad month number 0; must be 1-12")
+
+    days = _days_per_month_table[is_leapyear(year)][month-1]
+
+    return (dayofweek(year, month, 1), days)
+
+
+
diff --git a/pandas/src/np_datetime.c b/pandas/src/np_datetime.c
index 89e72a415..a191b5df5 100644
--- a/pandas/src/np_datetime.c
+++ b/pandas/src/np_datetime.c
@@ -49,6 +49,18 @@ int is_leapyear(npy_int64 year)
             (year % 400) == 0);
 }
 
+/*
+ * Sakamoto's method, from wikipedia
+ */
+int dayofweek(int y, int m, int d)
+{
+    static int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
+    y -= m < 3;
+    int day = (y + y/4 - y/100 + y/400 + t[m-1] + d) % 7;
+    // convert to python day
+    return (day + 6) % 7;
+}
+
 /*
  * Adjusts a datetimestruct based on a minutes offset. Assumes
  * the current values are valid.
diff --git a/pandas/src/np_datetime.h b/pandas/src/np_datetime.h
index d06fee460..97587aebd 100644
--- a/pandas/src/np_datetime.h
+++ b/pandas/src/np_datetime.h
@@ -17,6 +17,8 @@ int convert_pydatetime_to_datetimestruct(PyObject *obj, npy_datetimestruct *out,
 
 int is_leapyear(npy_int64 year);
 
+int dayofweek(int y, int m, int d);
+
 // stuff numpy needs in header
 // ----------------------------------------------------------------------------
 
diff --git a/pandas/tests/test_datetools.py b/pandas/tests/test_datetools.py
index d0eb15ec9..97071467f 100644
--- a/pandas/tests/test_datetools.py
+++ b/pandas/tests/test_datetools.py
@@ -11,6 +11,15 @@ from pandas.core.datetools import (
 
 from nose.tools import assert_raises
 
+import pandas._datetime as dtlib
+from pandas._datetime import Timestamp, Delta
+
+def test_monthrange():
+    import calendar
+    for y in range(2000,2013):
+        for m in range(1,13):
+            assert dtlib.monthrange(y,m) == calendar.monthrange(y,m)
+
 ####
 ## Misc function tests
 ####
@@ -94,6 +103,44 @@ class TestDateOffset(unittest.TestCase):
         self.assert_(offset1 != offset2)
         self.assert_(not (offset1 == offset2))
 
+class TestDelta(unittest.TestCase):
+
+    def setUp(self):
+        self.d = Timestamp(datetime(2008, 1, 2))
+
+    def test_repr(self):
+        repr(Delta())
+        repr(Delta(2))
+        repr(2 * Delta())
+        repr(2 * Delta(months=2))
+
+    def test_mul(self):
+        assert Delta(2) == 2 * Delta(1)
+        assert Delta(2) == Delta(1) * 2
+
+    def test_constructor(self):
+
+        assert((self.d + Delta(months=2)) == Timestamp(datetime(2008, 3, 2)))
+        assert((self.d - Delta(months=2)) == Timestamp(datetime(2007, 11, 2)))
+
+        assert((self.d + Delta(2)) == Timestamp(datetime(2008, 1, 4)))
+
+        assert not Delta(2).isAnchored()
+        assert Delta(1).isAnchored()
+
+        d = Timestamp(datetime(2008, 1, 31))
+        assert((d + Delta(months=1)) == Timestamp(datetime(2008, 2, 29)))
+
+    def test_copy(self):
+        assert(Delta(months=2).copy() == Delta(months=2))
+
+    def test_eq(self):
+        offset1 = Delta(days=1)
+        offset2 = Delta(days=365)
+
+        self.assert_(offset1 != offset2)
+        self.assert_(not (offset1 == offset2))
+
 class TestBusinessDay(unittest.TestCase):
 
     def setUp(self):

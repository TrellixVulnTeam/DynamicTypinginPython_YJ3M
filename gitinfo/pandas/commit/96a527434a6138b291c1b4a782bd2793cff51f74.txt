commit 96a527434a6138b291c1b4a782bd2793cff51f74
Author: Jeff Reback <jeff@reback.net>
Date:   Sat Nov 11 18:38:27 2017 -0500

    TST: clean up some tests issues & style (#18232)
    
    * STYLE: clean up flake8 exceptions
    
    * TST: skip if no bs4 for some html tests
    
    * TST: fix local timezone checking with .timestamp()

diff --git a/pandas/core/dtypes/cast.py b/pandas/core/dtypes/cast.py
index f3b11e52c..eae283e9b 100644
--- a/pandas/core/dtypes/cast.py
+++ b/pandas/core/dtypes/cast.py
@@ -136,7 +136,7 @@ def maybe_downcast_to_dtype(result, dtype):
                 try:
                     if np.allclose(new_result, result, rtol=0):
                         return new_result
-                except:
+                except Exception:
 
                     # comparison of an object dtype with a number type could
                     # hit here
@@ -151,14 +151,14 @@ def maybe_downcast_to_dtype(result, dtype):
         elif dtype.kind in ['M', 'm'] and result.dtype.kind in ['i', 'f']:
             try:
                 result = result.astype(dtype)
-            except:
+            except Exception:
                 if dtype.tz:
                     # convert to datetime and change timezone
                     from pandas import to_datetime
                     result = to_datetime(result).tz_localize('utc')
                     result = result.tz_convert(dtype.tz)
 
-    except:
+    except Exception:
         pass
 
     return result
@@ -210,7 +210,7 @@ def maybe_upcast_putmask(result, mask, other):
                     new_result[mask] = om_at
                     result[:] = new_result
                     return result, False
-            except:
+            except Exception:
                 pass
 
             # we are forced to change the dtype of the result as the input
@@ -243,7 +243,7 @@ def maybe_upcast_putmask(result, mask, other):
 
         try:
             np.place(result, mask, other)
-        except:
+        except Exception:
             return changeit()
 
     return result, False
@@ -274,14 +274,14 @@ def maybe_promote(dtype, fill_value=np.nan):
             if issubclass(dtype.type, np.datetime64):
                 try:
                     fill_value = tslib.Timestamp(fill_value).value
-                except:
+                except Exception:
                     # the proper thing to do here would probably be to upcast
                     # to object (but numpy 1.6.1 doesn't do this properly)
                     fill_value = iNaT
             elif issubclass(dtype.type, np.timedelta64):
                 try:
                     fill_value = lib.Timedelta(fill_value).value
-                except:
+                except Exception:
                     # as for datetimes, cannot upcast to object
                     fill_value = iNaT
             else:
@@ -592,12 +592,12 @@ def maybe_convert_scalar(values):
 
 def coerce_indexer_dtype(indexer, categories):
     """ coerce the indexer input array to the smallest dtype possible """
-    l = len(categories)
-    if l < _int8_max:
+    length = len(categories)
+    if length < _int8_max:
         return _ensure_int8(indexer)
-    elif l < _int16_max:
+    elif length < _int16_max:
         return _ensure_int16(indexer)
-    elif l < _int32_max:
+    elif length < _int32_max:
         return _ensure_int32(indexer)
     return _ensure_int64(indexer)
 
@@ -629,7 +629,7 @@ def coerce_to_dtypes(result, dtypes):
                 r = float(r)
             elif dtype.kind == 'i':
                 r = int(r)
-        except:
+        except Exception:
             pass
 
         return r
@@ -756,7 +756,7 @@ def maybe_convert_objects(values, convert_dates=True, convert_numeric=True,
                 if not isna(new_values).all():
                     values = new_values
 
-            except:
+            except Exception:
                 pass
         else:
             # soft-conversion
@@ -817,7 +817,7 @@ def soft_convert_objects(values, datetime=True, numeric=True, timedelta=True,
             # If all NaNs, then do not-alter
             values = converted if not isna(converted).all() else values
             values = values.copy() if copy else values
-        except:
+        except Exception:
             pass
 
     return values
@@ -888,10 +888,10 @@ def maybe_infer_to_datetimelike(value, convert_dates=False):
             try:
                 from pandas import to_datetime
                 return to_datetime(v)
-            except:
+            except Exception:
                 pass
 
-        except:
+        except Exception:
             pass
 
         return v.reshape(shape)
@@ -903,7 +903,7 @@ def maybe_infer_to_datetimelike(value, convert_dates=False):
         from pandas import to_timedelta
         try:
             return to_timedelta(v)._values.reshape(shape)
-        except:
+        except Exception:
             return v.reshape(shape)
 
     inferred_type = lib.infer_datetimelike_array(_ensure_object(v))
diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index 57d2d0729..eb96cbad7 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -2032,7 +2032,7 @@ class Index(IndexOpsMixin, PandasObject):
         try:
             return array_equivalent(_values_from_object(self),
                                     _values_from_object(other))
-        except:
+        except Exception:
             return False
 
     def identical(self, other):
@@ -2315,7 +2315,7 @@ class Index(IndexOpsMixin, PandasObject):
         try:
             indexer = Index(other._values).get_indexer(self._values)
             indexer = indexer.take((indexer != -1).nonzero()[0])
-        except:
+        except Exception:
             # duplicates
             indexer = algos.unique1d(
                 Index(other._values).get_indexer_non_unique(self._values)[0])
@@ -3022,13 +3022,13 @@ class Index(IndexOpsMixin, PandasObject):
         new_indexer = None
 
         if len(missing):
-            l = np.arange(len(indexer))
+            length = np.arange(len(indexer))
 
             missing = _ensure_platform_int(missing)
             missing_labels = target.take(missing)
-            missing_indexer = _ensure_int64(l[~check])
+            missing_indexer = _ensure_int64(length[~check])
             cur_labels = self.take(indexer[check]).values
-            cur_indexer = _ensure_int64(l[check])
+            cur_indexer = _ensure_int64(length[check])
 
             new_labels = np.empty(tuple([len(indexer)]), dtype=object)
             new_labels[cur_indexer] = cur_labels
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index 78869de31..aa99e8920 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -449,7 +449,7 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
 
         try:
             inferred_tz = timezones.infer_tzinfo(start, end)
-        except:
+        except Exception:
             raise TypeError('Start and end cannot both be tz-aware with '
                             'different timezones')
 
@@ -1176,12 +1176,12 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
 
         # convert in chunks of 10k for efficiency
         data = self.asi8
-        l = len(self)
+        length = len(self)
         chunksize = 10000
-        chunks = int(l / chunksize) + 1
+        chunks = int(length / chunksize) + 1
         for i in range(chunks):
             start_i = i * chunksize
-            end_i = min((i + 1) * chunksize, l)
+            end_i = min((i + 1) * chunksize, length)
             converted = libts.ints_to_pydatetime(data[start_i:end_i],
                                                  tz=self.tz, freq=self.freq,
                                                  box=True)
diff --git a/pandas/core/indexes/timedeltas.py b/pandas/core/indexes/timedeltas.py
index a4a5f7df9..604af1cfd 100644
--- a/pandas/core/indexes/timedeltas.py
+++ b/pandas/core/indexes/timedeltas.py
@@ -841,7 +841,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, TimelikeOps, Int64Index):
         if _is_convertible_to_td(item):
             try:
                 item = Timedelta(item)
-            except:
+            except Exception:
                 pass
 
         freq = None
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 1c92c4b88..c9a72bb68 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -597,7 +597,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
                 return values[i]
         except IndexError:
             raise
-        except:
+        except Exception:
             if isinstance(i, slice):
                 indexer = self.index._convert_slice_indexer(i, kind='iloc')
                 return self._get_values(indexer)
@@ -675,7 +675,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
             if isinstance(key, tuple):
                 try:
                     return self._get_values_tuple(key)
-                except:
+                except Exception:
                     if len(key) == 1:
                         key = key[0]
                         if isinstance(key, slice):
@@ -818,7 +818,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
             if not isinstance(key, (list, Series, np.ndarray, Series)):
                 try:
                     key = list(key)
-                except:
+                except Exception:
                     key = [key]
 
             if isinstance(key, Index):
diff --git a/pandas/tests/io/test_html.py b/pandas/tests/io/test_html.py
index 956f3c68e..0b268dcca 100644
--- a/pandas/tests/io/test_html.py
+++ b/pandas/tests/io/test_html.py
@@ -973,6 +973,7 @@ def test_importcheck_thread_safety():
 def test_parse_failure_unseekable():
     # Issue #17975
     _skip_if_no('lxml')
+    _skip_if_no('bs4')
 
     class UnseekableStringIO(StringIO):
         def seekable(self):
@@ -996,6 +997,7 @@ def test_parse_failure_unseekable():
 def test_parse_failure_rewinds():
     # Issue #17975
     _skip_if_no('lxml')
+    _skip_if_no('bs4')
 
     class MockFile(object):
         def __init__(self, data):
diff --git a/pandas/tests/scalar/test_timestamp.py b/pandas/tests/scalar/test_timestamp.py
index 4cd9a2fad..1d1eeb9da 100644
--- a/pandas/tests/scalar/test_timestamp.py
+++ b/pandas/tests/scalar/test_timestamp.py
@@ -1101,13 +1101,18 @@ class TestTimestamp(object):
 
         tsc = Timestamp('2014-10-11 11:00:01.12345678', tz='US/Central')
         utsc = tsc.tz_convert('UTC')
+
         # utsc is a different representation of the same time
         assert tsc.timestamp() == utsc.timestamp()
 
         if PY3:
-            # should agree with datetime.timestamp method
-            dt = ts.to_pydatetime()
-            assert dt.timestamp() == ts.timestamp()
+
+            # datetime.timestamp() converts in the local timezone
+            with tm.set_timezone('UTC'):
+
+                # should agree with datetime.timestamp method
+                dt = ts.to_pydatetime()
+                assert dt.timestamp() == ts.timestamp()
 
 
 class TestTimestampNsOperations(object):
diff --git a/pandas/tests/tseries/test_timezones.py b/pandas/tests/tseries/test_timezones.py
index ddcf1bb7d..724628649 100644
--- a/pandas/tests/tseries/test_timezones.py
+++ b/pandas/tests/tseries/test_timezones.py
@@ -13,7 +13,7 @@ from datetime import datetime, timedelta, tzinfo, date
 
 import pandas.util.testing as tm
 import pandas.tseries.offsets as offsets
-from pandas.compat import lrange, zip
+from pandas.compat import lrange, zip, PY3
 from pandas.core.indexes.datetimes import bdate_range, date_range
 from pandas.core.dtypes.dtypes import DatetimeTZDtype
 from pandas._libs import tslib
@@ -1278,16 +1278,22 @@ class TestTimeZones(object):
         result_dt = dt.replace(tzinfo=tzinfo)
         result_pd = Timestamp(dt).replace(tzinfo=tzinfo)
 
-        if hasattr(result_dt, 'timestamp'):  # New method in Py 3.3
-            assert result_dt.timestamp() == result_pd.timestamp()
+        if PY3:
+            # datetime.timestamp() converts in the local timezone
+            with tm.set_timezone('UTC'):
+                assert result_dt.timestamp() == result_pd.timestamp()
+
         assert result_dt == result_pd
         assert result_dt == result_pd.to_pydatetime()
 
         result_dt = dt.replace(tzinfo=tzinfo).replace(tzinfo=None)
         result_pd = Timestamp(dt).replace(tzinfo=tzinfo).replace(tzinfo=None)
 
-        if hasattr(result_dt, 'timestamp'):  # New method in Py 3.3
-            assert result_dt.timestamp() == result_pd.timestamp()
+        if PY3:
+            # datetime.timestamp() converts in the local timezone
+            with tm.set_timezone('UTC'):
+                assert result_dt.timestamp() == result_pd.timestamp()
+
         assert result_dt == result_pd
         assert result_dt == result_pd.to_pydatetime()
 

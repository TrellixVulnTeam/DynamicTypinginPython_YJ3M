commit 352ae44398eae5cdfd5de9700939303cc1ccb1bd
Author: Jeff Reback <jeff@reback.net>
Date:   Tue May 31 09:53:15 2016 -0400

    TST: more strict testing in lint.sh
    
    Author: Jeff Reback <jeff@reback.net>
    
    Closes #13334 from jreback/testing and squashes the following commits:
    
    7653af9 [Jeff Reback] TST: more strict testing in lint.sh

diff --git a/ci/lint.sh b/ci/lint.sh
index eb4c655e8..a4c960084 100755
--- a/ci/lint.sh
+++ b/ci/lint.sh
@@ -20,7 +20,7 @@ if [ "$LINT" ]; then
     echo "Linting DONE"
 
     echo "Check for invalid testing"
-    grep -r --include '*.py' --exclude nosetester.py --exclude testing.py 'numpy.testing' pandas
+    grep -r -E --include '*.py' --exclude nosetester.py --exclude testing.py '(numpy|np)\.testing' pandas
     if [ $? = "0" ]; then
         RET=1
     fi
diff --git a/pandas/io/tests/json/test_pandas.py b/pandas/io/tests/json/test_pandas.py
index 43b8d6b95..9f8aedc2e 100644
--- a/pandas/io/tests/json/test_pandas.py
+++ b/pandas/io/tests/json/test_pandas.py
@@ -100,7 +100,7 @@ class TestPandasContainer(tm.TestCase):
                                          orient='split'))
         unser = read_json(df.to_json(orient='records'), orient='records')
         self.assert_index_equal(df.columns, unser.columns)
-        np.testing.assert_equal(df.values, unser.values)
+        tm.assert_almost_equal(df.values, unser.values)
         unser = read_json(df.to_json(orient='values'), orient='values')
         tm.assert_numpy_array_equal(df.values, unser.values)
 
diff --git a/pandas/io/tests/test_packers.py b/pandas/io/tests/test_packers.py
index b647ec6b2..ad7d6c3c9 100644
--- a/pandas/io/tests/test_packers.py
+++ b/pandas/io/tests/test_packers.py
@@ -671,14 +671,14 @@ class TestCompression(TestPackers):
         with tm.assert_produces_warning(None):
             empty_unpacked = self.encode_decode(empty, compress=compress)
 
-        np.testing.assert_array_equal(empty_unpacked, empty)
+        tm.assert_numpy_array_equal(empty_unpacked, empty)
         self.assertTrue(empty_unpacked.flags.writeable)
 
         char = np.array([ord(b'a')], dtype='uint8')
         with tm.assert_produces_warning(None):
             char_unpacked = self.encode_decode(char, compress=compress)
 
-        np.testing.assert_array_equal(char_unpacked, char)
+        tm.assert_numpy_array_equal(char_unpacked, char)
         self.assertTrue(char_unpacked.flags.writeable)
         # if this test fails I am sorry because the interpreter is now in a
         # bad state where b'a' points to 98 == ord(b'b').
@@ -688,7 +688,7 @@ class TestCompression(TestPackers):
         # always be the same (unless we were able to mutate the shared
         # character singleton in which case ord(b'a') == ord(b'b').
         self.assertEqual(ord(b'a'), ord(u'a'))
-        np.testing.assert_array_equal(
+        tm.assert_numpy_array_equal(
             char_unpacked,
             np.array([ord(b'b')], dtype='uint8'),
         )
diff --git a/pandas/src/testing.pyx b/pandas/src/testing.pyx
index 9f102ded5..6780cf311 100644
--- a/pandas/src/testing.pyx
+++ b/pandas/src/testing.pyx
@@ -55,7 +55,9 @@ cpdef assert_dict_equal(a, b, bint compare_keys=True):
 
     return True
 
-cpdef assert_almost_equal(a, b, bint check_less_precise=False, check_dtype=True,
+cpdef assert_almost_equal(a, b,
+                          check_less_precise=False,
+                          bint check_dtype=True,
                           obj=None, lobj=None, robj=None):
     """Check that left and right objects are almost equal.
 
@@ -63,9 +65,10 @@ cpdef assert_almost_equal(a, b, bint check_less_precise=False, check_dtype=True,
     ----------
     a : object
     b : object
-    check_less_precise : bool, default False
+    check_less_precise : bool or int, default False
         Specify comparison precision.
         5 digits (False) or 3 digits (True) after decimal points are compared.
+        If an integer, then this will be the number of decimal points to compare
     check_dtype: bool, default True
         check dtype if both a and b are np.ndarray
     obj : str, default None
@@ -91,6 +94,8 @@ cpdef assert_almost_equal(a, b, bint check_less_precise=False, check_dtype=True,
     if robj is None:
         robj = b
 
+    assert isinstance(check_less_precise, (int, bool))
+
     if isinstance(a, dict) or isinstance(b, dict):
         return assert_dict_equal(a, b)
 
@@ -145,7 +150,7 @@ cpdef assert_almost_equal(a, b, bint check_less_precise=False, check_dtype=True,
 
         for i in xrange(len(a)):
             try:
-                assert_almost_equal(a[i], b[i], check_less_precise)
+                assert_almost_equal(a[i], b[i], check_less_precise=check_less_precise)
             except AssertionError:
                 is_unequal = True
                 diff += 1
@@ -173,11 +178,12 @@ cpdef assert_almost_equal(a, b, bint check_less_precise=False, check_dtype=True,
             # inf comparison
             return True
 
-        decimal = 5
-
-        # deal with differing dtypes
-        if check_less_precise:
+        if check_less_precise is True:
             decimal = 3
+        elif check_less_precise is False:
+            decimal = 5
+        else:
+            decimal = check_less_precise
 
         fa, fb = a, b
 
diff --git a/pandas/tests/test_algos.py b/pandas/tests/test_algos.py
index be8468d42..8af93ad0e 100644
--- a/pandas/tests/test_algos.py
+++ b/pandas/tests/test_algos.py
@@ -585,7 +585,7 @@ class GroupVarTestMixin(object):
         expected_counts = counts + 3
 
         self.algo(out, counts, values, labels)
-        np.testing.assert_allclose(out, expected_out, self.rtol)
+        self.assertTrue(np.allclose(out, expected_out, self.rtol))
         tm.assert_numpy_array_equal(counts, expected_counts)
 
     def test_group_var_generic_1d_flat_labels(self):
@@ -601,7 +601,7 @@ class GroupVarTestMixin(object):
 
         self.algo(out, counts, values, labels)
 
-        np.testing.assert_allclose(out, expected_out, self.rtol)
+        self.assertTrue(np.allclose(out, expected_out, self.rtol))
         tm.assert_numpy_array_equal(counts, expected_counts)
 
     def test_group_var_generic_2d_all_finite(self):
@@ -616,7 +616,7 @@ class GroupVarTestMixin(object):
         expected_counts = counts + 2
 
         self.algo(out, counts, values, labels)
-        np.testing.assert_allclose(out, expected_out, self.rtol)
+        self.assertTrue(np.allclose(out, expected_out, self.rtol))
         tm.assert_numpy_array_equal(counts, expected_counts)
 
     def test_group_var_generic_2d_some_nan(self):
@@ -631,11 +631,11 @@ class GroupVarTestMixin(object):
         expected_out = np.vstack([values[:, 0]
                                   .reshape(5, 2, order='F')
                                   .std(ddof=1, axis=1) ** 2,
-                                  np.nan * np.ones(5)]).T
+                                  np.nan * np.ones(5)]).T.astype(self.dtype)
         expected_counts = counts + 2
 
         self.algo(out, counts, values, labels)
-        np.testing.assert_allclose(out, expected_out, self.rtol)
+        tm.assert_almost_equal(out, expected_out, check_less_precise=6)
         tm.assert_numpy_array_equal(counts, expected_counts)
 
     def test_group_var_constant(self):
diff --git a/pandas/tests/test_nanops.py b/pandas/tests/test_nanops.py
index e244a0412..904bedde0 100644
--- a/pandas/tests/test_nanops.py
+++ b/pandas/tests/test_nanops.py
@@ -799,30 +799,31 @@ class TestNanvarFixedValues(tm.TestCase):
     def test_nanvar_all_finite(self):
         samples = self.samples
         actual_variance = nanops.nanvar(samples)
-        np.testing.assert_almost_equal(actual_variance, self.variance,
-                                       decimal=2)
+        tm.assert_almost_equal(actual_variance, self.variance,
+                               check_less_precise=2)
 
     def test_nanvar_nans(self):
         samples = np.nan * np.ones(2 * self.samples.shape[0])
         samples[::2] = self.samples
 
         actual_variance = nanops.nanvar(samples, skipna=True)
-        np.testing.assert_almost_equal(actual_variance, self.variance,
-                                       decimal=2)
+        tm.assert_almost_equal(actual_variance, self.variance,
+                               check_less_precise=2)
 
         actual_variance = nanops.nanvar(samples, skipna=False)
-        np.testing.assert_almost_equal(actual_variance, np.nan, decimal=2)
+        tm.assert_almost_equal(actual_variance, np.nan, check_less_precise=2)
 
     def test_nanstd_nans(self):
         samples = np.nan * np.ones(2 * self.samples.shape[0])
         samples[::2] = self.samples
 
         actual_std = nanops.nanstd(samples, skipna=True)
-        np.testing.assert_almost_equal(actual_std, self.variance ** 0.5,
-                                       decimal=2)
+        tm.assert_almost_equal(actual_std, self.variance ** 0.5,
+                               check_less_precise=2)
 
         actual_std = nanops.nanvar(samples, skipna=False)
-        np.testing.assert_almost_equal(actual_std, np.nan, decimal=2)
+        tm.assert_almost_equal(actual_std, np.nan,
+                               check_less_precise=2)
 
     def test_nanvar_axis(self):
         # Generate some sample data.
@@ -831,8 +832,8 @@ class TestNanvarFixedValues(tm.TestCase):
         samples = np.vstack([samples_norm, samples_unif])
 
         actual_variance = nanops.nanvar(samples, axis=1)
-        np.testing.assert_array_almost_equal(actual_variance, np.array(
-            [self.variance, 1.0 / 12]), decimal=2)
+        tm.assert_almost_equal(actual_variance, np.array(
+            [self.variance, 1.0 / 12]), check_less_precise=2)
 
     def test_nanvar_ddof(self):
         n = 5
@@ -845,13 +846,16 @@ class TestNanvarFixedValues(tm.TestCase):
 
         # The unbiased estimate.
         var = 1.0 / 12
-        np.testing.assert_almost_equal(variance_1, var, decimal=2)
+        tm.assert_almost_equal(variance_1, var,
+                               check_less_precise=2)
+
         # The underestimated variance.
-        np.testing.assert_almost_equal(variance_0, (n - 1.0) / n * var,
-                                       decimal=2)
+        tm.assert_almost_equal(variance_0, (n - 1.0) / n * var,
+                               check_less_precise=2)
+
         # The overestimated variance.
-        np.testing.assert_almost_equal(variance_2, (n - 1.0) / (n - 2.0) * var,
-                                       decimal=2)
+        tm.assert_almost_equal(variance_2, (n - 1.0) / (n - 2.0) * var,
+                               check_less_precise=2)
 
     def test_ground_truth(self):
         # Test against values that were precomputed with Numpy.
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index 7792a1f5d..b1f09ad26 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -2301,8 +2301,8 @@ class TestPanel(tm.TestCase, PanelTests, CheckIndexing, SafeForLongAndSparse,
                      [[1.5, np.nan, 3.], [1.5, np.nan, 3.], [1.5, np.nan, 3.],
                       [1.5, np.nan, 3.]]])
 
-        np.testing.assert_raises(Exception, pan.update, *(pan, ),
-                                 **{'raise_conflict': True})
+        self.assertRaises(Exception, pan.update, *(pan, ),
+                          **{'raise_conflict': True})
 
     def test_all_any(self):
         self.assertTrue((self.panel.all(axis=0).values == nanall(
diff --git a/pandas/tests/test_testing.py b/pandas/tests/test_testing.py
index 9cc76591e..c4e864a90 100644
--- a/pandas/tests/test_testing.py
+++ b/pandas/tests/test_testing.py
@@ -519,12 +519,18 @@ class TestAssertSeriesEqual(tm.TestCase):
 
         self.assertRaises(AssertionError, assert_series_equal, s1, s2)
         self._assert_equal(s1, s2, check_less_precise=True)
+        for i in range(4):
+            self._assert_equal(s1, s2, check_less_precise=i)
+        self.assertRaises(AssertionError, assert_series_equal, s1, s2, 10)
 
         s1 = Series([0.12345], dtype='float32')
         s2 = Series([0.12346], dtype='float32')
 
         self.assertRaises(AssertionError, assert_series_equal, s1, s2)
         self._assert_equal(s1, s2, check_less_precise=True)
+        for i in range(4):
+            self._assert_equal(s1, s2, check_less_precise=i)
+        self.assertRaises(AssertionError, assert_series_equal, s1, s2, 10)
 
         # even less than less precise
         s1 = Series([0.1235], dtype='float32')
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index f2b5bf7d2..ef94692ea 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -116,18 +116,40 @@ class TestCase(unittest.TestCase):
 
 
 def assert_almost_equal(left, right, check_exact=False,
-                        check_dtype='equiv', **kwargs):
+                        check_dtype='equiv', check_less_precise=False,
+                        **kwargs):
+    """Check that left and right Index are equal.
+
+    Parameters
+    ----------
+    left : object
+    right : object
+    check_exact : bool, default True
+        Whether to compare number exactly.
+    check_dtype: bool, default True
+        check dtype if both a and b are the same type
+    check_less_precise : bool or int, default False
+        Specify comparison precision. Only used when check_exact is False.
+        5 digits (False) or 3 digits (True) after decimal points are compared.
+        If int, then specify the digits to compare
+    """
     if isinstance(left, pd.Index):
         return assert_index_equal(left, right, check_exact=check_exact,
-                                  exact=check_dtype, **kwargs)
+                                  exact=check_dtype,
+                                  check_less_precise=check_less_precise,
+                                  **kwargs)
 
     elif isinstance(left, pd.Series):
         return assert_series_equal(left, right, check_exact=check_exact,
-                                   check_dtype=check_dtype, **kwargs)
+                                   check_dtype=check_dtype,
+                                   check_less_precise=check_less_precise,
+                                   **kwargs)
 
     elif isinstance(left, pd.DataFrame):
         return assert_frame_equal(left, right, check_exact=check_exact,
-                                  check_dtype=check_dtype, **kwargs)
+                                  check_dtype=check_dtype,
+                                  check_less_precise=check_less_precise,
+                                  **kwargs)
 
     else:
         # other sequences
@@ -142,8 +164,11 @@ def assert_almost_equal(left, right, check_exact=False,
                 else:
                     obj = 'Input'
                 assert_class_equal(left, right, obj=obj)
-        return _testing.assert_almost_equal(left, right,
-                                            check_dtype=check_dtype, **kwargs)
+        return _testing.assert_almost_equal(
+            left, right,
+            check_dtype=check_dtype,
+            check_less_precise=check_less_precise,
+            **kwargs)
 
 
 def assert_dict_equal(left, right, compare_keys=True):
@@ -690,9 +715,10 @@ def assert_index_equal(left, right, exact='equiv', check_names=True,
         Int64Index as well
     check_names : bool, default True
         Whether to check the names attribute.
-    check_less_precise : bool, default False
+    check_less_precise : bool or int, default False
         Specify comparison precision. Only used when check_exact is False.
         5 digits (False) or 3 digits (True) after decimal points are compared.
+        If int, then specify the digits to compare
     check_exact : bool, default True
         Whether to compare number exactly.
     check_categorical : bool, default True
@@ -1040,9 +1066,10 @@ def assert_series_equal(left, right, check_dtype=True,
         are identical.
     check_series_type : bool, default False
         Whether to check the Series class is identical.
-    check_less_precise : bool, default False
+    check_less_precise : bool or int, default False
         Specify comparison precision. Only used when check_exact is False.
         5 digits (False) or 3 digits (True) after decimal points are compared.
+        If int, then specify the digits to compare
     check_exact : bool, default False
         Whether to compare number exactly.
     check_names : bool, default True
@@ -1106,7 +1133,7 @@ def assert_series_equal(left, right, check_dtype=True,
                                      check_dtype=check_dtype)
     else:
         _testing.assert_almost_equal(left.get_values(), right.get_values(),
-                                     check_less_precise,
+                                     check_less_precise=check_less_precise,
                                      check_dtype=check_dtype,
                                      obj='{0}'.format(obj))
 
@@ -1150,9 +1177,10 @@ def assert_frame_equal(left, right, check_dtype=True,
         are identical.
     check_frame_type : bool, default False
         Whether to check the DataFrame class is identical.
-    check_less_precise : bool, default False
+    check_less_precise : bool or it, default False
         Specify comparison precision. Only used when check_exact is False.
         5 digits (False) or 3 digits (True) after decimal points are compared.
+        If int, then specify the digits to compare
     check_names : bool, default True
         Whether to check the Index names attribute.
     by_blocks : bool, default False
@@ -1259,9 +1287,10 @@ def assert_panelnd_equal(left, right,
         Whether to check the Panel dtype is identical.
     check_panel_type : bool, default False
         Whether to check the Panel class is identical.
-    check_less_precise : bool, default False
+    check_less_precise : bool or int, default False
         Specify comparison precision. Only used when check_exact is False.
         5 digits (False) or 3 digits (True) after decimal points are compared.
+        If int, then specify the digits to compare
     assert_func : function for comparing data
     check_names : bool, default True
         Whether to check the Index names attribute.

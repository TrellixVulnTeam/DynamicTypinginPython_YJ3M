commit 0ce9a27cbbae207e0b7babf111ea67d166281a2b
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Jun 24 23:49:27 2011 -0400

    little bit of fancy indexing refactoring

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index c958a3f44..ae701842e 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2466,6 +2466,71 @@ class DataFrame(PandasGeneric):
 
         return self._ix
 
+def _is_label_like(key):
+    # select a label or row
+    return not isinstance(key, slice) and not _is_list_like(key)
+
+class AmbiguousIndexError(Exception):
+    pass
+
+class _DataFrameIndexer(object):
+    """
+    Class to support fancy indexing, potentially using labels of DataFrame
+
+    Notes
+    -----
+    Indexing based on labels is INCLUSIVE
+    Slicing uses PYTHON SEMANTICS (endpoint is excluded)
+
+    If Index contains int labels, these will be used rather than the locations,
+    so be very careful (ambiguous).
+
+    Examples
+    --------
+    >>> frame.ix[5:10, ['A', 'B']]
+    >>> frame.ix[date1:date2, 'A']
+    """
+
+    def __init__(self, frame):
+        self.frame = frame
+
+    def __getitem__(self, key):
+        frame = self.frame
+        if isinstance(key, slice):
+            return self._fancy_getitem_axis(key, axis=0)
+        elif isinstance(key, tuple):
+            if len(key) != 2:
+                raise Exception('only length 2 tuple supported')
+            return self._fancy_getitem_tuple(*key)
+        elif _is_list_like(key):
+            return self._fancy_getitem(key, axis=0)
+        else:
+            return self._fancy_getitem_axis(key, axis=0)
+
+    def __setitem__(self, key, value):
+        # also has the side effect of consolidating in-place
+        if self.frame._is_mixed_type:
+            raise Exception('setting on mixed-type frames not yet supported')
+
+        frame = self.frame
+        if isinstance(key, slice):
+            return key
+        elif isinstance(key, tuple):
+            if len(key) != 2:
+                raise Exception('only length 2 tuple supported')
+            x, y = key
+            return frame._fancy_setitem_tuple(x, y, value)
+        elif _is_list_like(key):
+            return frame._fancy_setitem(key, value, axis=0)
+        else:
+            return frame._fancy_setitem_axis(key, value, axis=0)
+
+    def _convert_indexer(self, obj):
+        if isinstance(obj, slice):
+            return obj
+        elif _is_list_like(key):
+            pass
+
     def _fancy_getitem_tuple(self, rowkey, colkey):
         # to avoid wasted computation
         # df.ix[d1:d2, 0] -> columns first (True)
@@ -2476,9 +2541,7 @@ class DataFrame(PandasGeneric):
             return self._fancy_getitem_axis(rowkey, axis=0).ix[colkey]
 
         result = self._fancy_getitem_axis(colkey, axis=1)
-        result = result._fancy_getitem_axis(rowkey, axis=0)
-
-        return result
+        return result.ix[rowkey]
 
     def _fancy_setitem_tuple(self, rowkey, colkey, value):
         pass
@@ -2491,22 +2554,25 @@ class DataFrame(PandasGeneric):
         elif axis == 0:
             idx = key
             if isinstance(key, int):
-                idx = self.index[key]
+                idx = self.frame.index[key]
 
-            if self._is_mixed_type:
-                return self.xs(idx)
+            if self.frame._is_mixed_type:
+                return self.frame.xs(idx)
             else:
-                return self.xs(idx, copy=False)
+                return self.frame.xs(idx, copy=False)
         else:
             col = key
             if isinstance(key, int):
-                col = self.columns[key]
+                col = self.frame.columns[key]
 
-            return self[col]
+            return self.frame[col]
+
+    def _fancy_setitem_axis(self, key, value, axis=0):
+        pass
 
     def _fancy_getitem(self, key, axis=0):
-        labels = self._get_axis(axis)
-        axis_name = self._get_axis_name(axis)
+        labels = self.frame._get_axis(axis)
+        axis_name = self.frame._get_axis_name(axis)
 
         # asarray can be unsafe, NumPy strings are weird
         isbool = np.asarray(key).dtype == np.bool_
@@ -2515,94 +2581,38 @@ class DataFrame(PandasGeneric):
                 if not key.index.equals(labels):
                     raise Exception('Cannot use boolean index with misaligned '
                                     'or unequal labels')
-            return self.reindex(**{axis_name : labels[key]})
+            return self.frame.reindex(**{axis_name : labels[key]})
         else:
-            return self.reindex(**{axis_name : key})
+            return self.frame.reindex(**{axis_name : key})
 
-    def _fancy_setitem_axis(self, key, value, axis=0):
+    def _fancy_setitem(self, key, value, axis=0):
         pass
 
     def _get_slice_axis(self, slice_obj, axis=0):
         _check_step(slice_obj)
 
-        if not _need_slice(slice_obj):
-            return self
+        frame = self.frame
 
-        axis_name = self._get_axis_name(axis)
-        labels = getattr(self, axis_name)
+        axis_name = frame._get_axis_name(axis)
+        labels = getattr(frame, axis_name)
         if _is_label_slice(labels, slice_obj):
             i, j = labels.slice_locs(slice_obj.start, slice_obj.stop)
             slicer = slice(i, j)
         else:
             slicer = slice_obj
 
+        if not _need_slice(slice_obj):
+            return frame
         if axis == 0:
-            new_index = self.index[slicer]
-            new_columns = self.columns
-            new_values = self.values[slicer]
+            new_index = frame.index[slicer]
+            new_columns = frame.columns
+            new_values = frame.values[slicer]
         else:
-            new_index = self.index
-            new_columns = self.columns[slicer]
-            new_values = self.values[:, slicer]
-
-        return DataFrame(new_values, index=new_index, columns=new_columns)
-
-
-def _is_label_like(key):
-    # select a label or row
-    return not isinstance(key, slice) and not _is_list_like(key)
-
-
-class _DataFrameIndexer(object):
-    """
-    Class to support fancy indexing, potentially using labels of DataFrame
-
-    Notes
-    -----
-    Indexing based on labels is INCLUSIVE
-    Slicing uses PYTHON SEMANTICS (endpoint is excluded)
-
-    If Index contains int labels, these will be used rather than the locations,
-    so be very careful (ambiguous).
-
-    Examples
-    --------
-    >>> frame.ix[5:10, ['A', 'B']]
-    >>> frame.ix[date1:date2, 'A']
-    """
-
-    def __init__(self, frame):
-        self.frame = frame
-
-    def __getitem__(self, key):
-        frame = self.frame
-        if isinstance(key, slice):
-            return frame._fancy_getitem_axis(key, axis=0)
-        elif isinstance(key, tuple):
-            if len(key) != 2:
-                raise Exception('only length 2 tuple supported')
-            return frame._fancy_getitem_tuple(*key)
-        elif _is_list_like(key):
-            return frame._fancy_getitem(key, axis=0)
-        else:
-            return frame._fancy_getitem_axis(key, axis=0)
-
-    def __setitem__(self, key, value):
-        if self.frame._is_mixed_type:
-            raise Exception('setting on mixed-type frames not yet supported')
-
-        frame = self.frame
-        if isinstance(key, slice):
-            return frame._fancy_setitem_axis(key, value, axis=0)
-        elif isinstance(key, tuple):
-            if len(key) != 2:
-                raise Exception('only length 2 tuple supported')
-            x, y = key
-            return frame._fancy_setitem_tuple(x, y, value)
-        elif _is_list_like(key):
-            return frame._fancy_setitem(key, value, axis=0)
-        else:
-            return frame._fancy_setitem_axis(key, value, axis=0)
+            new_index = frame.index
+            new_columns = frame.columns[slicer]
+            new_values = frame.values[:, slicer]
+        return DataFrame(new_values, index=new_index,
+                         columns=new_columns)
 
 def extract_index(data):
     def _union_if(index, new_index):
diff --git a/pandas/core/series.py b/pandas/core/series.py
index c39bd0a47..6ed37eed8 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1427,37 +1427,6 @@ class Series(np.ndarray, PandasGeneric):
 
         return self._ix
 
-    def _fancy_index(self, key, value=None, operation='get'):
-        # going to great lengths to avoid code dup
-        if operation == 'get':
-            def do_default():
-                return self[key]
-
-            def do_list_like():
-                return self.reindex(key)
-        else:
-            def do_default():
-                self[key] = value
-
-            def do_list_like():
-                inds, mask = self.index.get_indexer(key)
-                if not mask.all():
-                    raise Exception('Indices %s not found' % key[-mask])
-                self.put(inds, value)
-        op = do_default
-        if _isboolarr(key):
-            if isinstance(key, Series):
-                if not key.index.equals(self.index):
-                    raise Exception('Cannot use boolean index with misaligned '
-                                    'or unequal labels')
-        elif isinstance(key, slice):
-            if _is_label_slice(self.index, key):
-                i, j = self.index.slice_locs(key.start, key.stop)
-                key = slice(i, j)
-        elif _is_list_like(key):
-            op = do_list_like
-        return op
-
 class TimeSeries(Series):
     pass
 
@@ -1484,13 +1453,46 @@ class _SeriesIndexer(object):
         self.series = series
 
     def __getitem__(self, key):
-        op = self.series._fancy_index(key, operation='get')
+        op = self._fancy_index(key, operation='get')
         return op()
 
     def __setitem__(self, key, value):
-        op = self.series._fancy_index(key, value, operation='set')
+        op = self._fancy_index(key, value, operation='set')
         op()
 
+    def _fancy_index(self, key, value=None, operation='get'):
+        # going to great lengths to avoid code dup
+        series = self.series
+
+        if operation == 'get':
+            def do_default():
+                return series[key]
+
+            def do_list_like():
+                return series.reindex(key)
+        else:
+            def do_default():
+                series[key] = value
+
+            def do_list_like():
+                inds, mask = series.index.get_indexer(key)
+                if not mask.all():
+                    raise Exception('Indices %s not found' % key[-mask])
+                series.put(inds, value)
+        op = do_default
+        if _isboolarr(key):
+            if isinstance(key, Series):
+                if not key.index.equals(series.index):
+                    raise Exception('Cannot use boolean index with misaligned '
+                                    'or unequal labels')
+        elif isinstance(key, slice):
+            if _is_label_slice(series.index, key):
+                i, j = series.index.slice_locs(key.start, key.stop)
+                key = slice(i, j)
+        elif _is_list_like(key):
+            op = do_list_like
+        return op
+
 #-------------------------------------------------------------------------------
 # Supplementary functions
 
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index a92052ab1..d51a0e1c6 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -2328,7 +2328,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         dm.xs(2)[:] = 10
         self.assert_((dm.xs(2) == 5).all())
 
-        # TODO: deal with mixed-type fiasco?
+        # TODO (?): deal with mixed-type fiasco?
         self.assertRaises(Exception, self.mixed_frame.xs,
                           self.mixed_frame.index[2], copy=False)
 

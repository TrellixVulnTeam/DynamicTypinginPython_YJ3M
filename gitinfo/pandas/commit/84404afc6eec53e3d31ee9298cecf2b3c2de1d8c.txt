commit 84404afc6eec53e3d31ee9298cecf2b3c2de1d8c
Author: sinhrks <sinhrks@gmail.com>
Date:   Sat Jul 5 19:37:51 2014 +0900

    CLN: cln tslib, frequencies

diff --git a/pandas/tools/plotting.py b/pandas/tools/plotting.py
index ea7f963f7..c40ff6778 100644
--- a/pandas/tools/plotting.py
+++ b/pandas/tools/plotting.py
@@ -16,7 +16,7 @@ from pandas.core.index import MultiIndex
 from pandas.core.series import Series, remove_na
 from pandas.tseries.index import DatetimeIndex
 from pandas.tseries.period import PeriodIndex, Period
-from pandas.tseries.frequencies import get_period_alias, get_base_alias
+import pandas.tseries.frequencies as frequencies
 from pandas.tseries.offsets import DateOffset
 from pandas.compat import range, lrange, lmap, map, zip, string_types
 import pandas.compat as compat
@@ -1504,8 +1504,8 @@ class LinePlot(MPLPlot):
         if isinstance(freq, DateOffset):
             freq = freq.rule_code
         else:
-            freq = get_base_alias(freq)
-        freq = get_period_alias(freq)
+            freq = frequencies.get_base_alias(freq)
+        freq = frequencies.get_period_alias(freq)
         return freq is not None and self._no_base(freq)
 
     def _no_base(self, freq):
@@ -1513,10 +1513,9 @@ class LinePlot(MPLPlot):
         from pandas.core.frame import DataFrame
         if (isinstance(self.data, (Series, DataFrame))
             and isinstance(self.data.index, DatetimeIndex)):
-            import pandas.tseries.frequencies as freqmod
-            base = freqmod.get_freq(freq)
+            base = frequencies.get_freq(freq)
             x = self.data.index
-            if (base <= freqmod.FreqGroup.FR_DAY):
+            if (base <= frequencies.FreqGroup.FR_DAY):
                 return x[:1].is_normalized
 
             return Period(x[0], freq).to_timestamp(tz=x.tz) == x[0]
@@ -1632,8 +1631,8 @@ class LinePlot(MPLPlot):
                 freq = getattr(data.index, 'inferred_freq', None)
             if isinstance(freq, DateOffset):
                 freq = freq.rule_code
-            freq = get_base_alias(freq)
-            freq = get_period_alias(freq)
+            freq = frequencies.get_base_alias(freq)
+            freq = frequencies.get_period_alias(freq)
 
             if freq is None:
                 ax = self._get_ax(0)
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 4aa424ea0..518bb4180 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -14,7 +14,7 @@ import pandas.compat as compat
 from pandas.compat import u
 from pandas.tseries.frequencies import (
     infer_freq, to_offset, get_period_alias,
-    Resolution, get_reso_string, _tz_convert_with_transitions)
+    Resolution, _tz_convert_with_transitions)
 from pandas.core.base import DatetimeIndexOpsMixin
 from pandas.tseries.offsets import DateOffset, generate_range, Tick, CDay
 from pandas.tseries.tools import parse_time_string, normalize_date
@@ -291,7 +291,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index):
                 tz = subarr.tz
         else:
             if tz is not None:
-                tz = tools._maybe_get_tz(tz)
+                tz = tslib.maybe_get_tz(tz)
 
                 if (not isinstance(data, DatetimeIndex) or
                         getattr(data, 'tz', None) is None):
@@ -361,10 +361,14 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index):
             raise ValueError('Start and end cannot both be tz-aware with '
                              'different timezones')
 
-        inferred_tz = tools._maybe_get_tz(inferred_tz)
+        inferred_tz = tslib.maybe_get_tz(inferred_tz)
 
         # these may need to be localized
-        tz = tools._maybe_get_tz(tz, start or end)
+        tz = tslib.maybe_get_tz(tz)
+        if tz is not None:
+            date = start or end
+            if date.tzinfo is not None and hasattr(tz, 'localize'):
+                tz = tz.localize(date.replace(tzinfo=None)).tzinfo
 
         if tz is not None and inferred_tz is not None:
             if not inferred_tz == tz:
@@ -477,7 +481,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index):
         result = values.view(cls)
         result.name = name
         result.offset = freq
-        result.tz = tools._maybe_get_tz(tz)
+        result.tz = tslib.maybe_get_tz(tz)
 
         return result
 
@@ -1620,7 +1624,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index):
         -------
         normalized : DatetimeIndex
         """
-        tz = tools._maybe_get_tz(tz)
+        tz = tslib.maybe_get_tz(tz)
 
         if self.tz is None:
             # tz naive, use tz_localize
@@ -1648,7 +1652,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index):
         """
         if self.tz is not None:
             raise TypeError("Already tz-aware, use tz_convert to convert.")
-        tz = tools._maybe_get_tz(tz)
+        tz = tslib.maybe_get_tz(tz)
 
         # Convert to UTC
         new_dates = tslib.tz_localize_to_utc(self.asi8, tz, infer_dst=infer_dst)
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index 887bf806d..7f865fd9a 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -5,12 +5,11 @@ from datetime import datetime, date
 import numpy as np
 from pandas.core.base import PandasObject
 
-from pandas.tseries.frequencies import (get_freq_code as _gfc,
-                                        _month_numbers, FreqGroup)
+import pandas.tseries.frequencies as frequencies
+from pandas.tseries.frequencies import get_freq_code as _gfc
 from pandas.tseries.index import DatetimeIndex, Int64Index, Index
 from pandas.core.base import DatetimeIndexOpsMixin
 from pandas.tseries.tools import parse_time_string
-import pandas.tseries.frequencies as _freq_mod
 
 import pandas.core.common as com
 from pandas.core.common import (isnull, _INT64_DTYPE, _maybe_box,
@@ -116,7 +115,7 @@ class Period(PandasObject):
             dt, _, reso = parse_time_string(value, freq)
             if freq is None:
                 try:
-                    freq = _freq_mod.Resolution.get_freq(reso)
+                    freq = frequencies.Resolution.get_freq(reso)
                 except KeyError:
                     raise ValueError("Invalid frequency or could not infer: %s" % reso)
 
@@ -142,7 +141,7 @@ class Period(PandasObject):
                                                 dt.hour, dt.minute, dt.second, dt.microsecond, 0,
                                                 base)
 
-        self.freq = _freq_mod._get_freq_str(base)
+        self.freq = frequencies._get_freq_str(base)
 
     def __eq__(self, other):
         if isinstance(other, Period):
@@ -267,7 +266,7 @@ class Period(PandasObject):
 
         if freq is None:
             base, mult = _gfc(self.freq)
-            freq = _freq_mod.get_to_timestamp_base(base)
+            freq = frequencies.get_to_timestamp_base(base)
 
         base, mult = _gfc(freq)
         val = self.asfreq(freq, how)
@@ -296,7 +295,7 @@ class Period(PandasObject):
     def __repr__(self):
         base, mult = _gfc(self.freq)
         formatted = tslib.period_format(self.ordinal, base)
-        freqstr = _freq_mod._reverse_period_code_map[base]
+        freqstr = frequencies._reverse_period_code_map[base]
 
         if not compat.PY3:
             encoding = com.get_option("display.encoding")
@@ -577,7 +576,7 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
                 quarter=None, day=None, hour=None, minute=None, second=None,
                 tz=None):
 
-        freq = _freq_mod.get_standard_freq(freq)
+        freq = frequencies.get_standard_freq(freq)
 
         if periods is not None:
             if com.is_float(periods):
@@ -767,7 +766,7 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
     def asfreq(self, freq=None, how='E'):
         how = _validate_end_alias(how)
 
-        freq = _freq_mod.get_standard_freq(freq)
+        freq = frequencies.get_standard_freq(freq)
 
         base1, mult1 = _gfc(self.freq)
         base2, mult2 = _gfc(freq)
@@ -845,7 +844,7 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
 
         if freq is None:
             base, mult = _gfc(self.freq)
-            freq = _freq_mod.get_to_timestamp_base(base)
+            freq = frequencies.get_to_timestamp_base(base)
 
         base, mult = _gfc(freq)
         new_data = self.asfreq(freq, how)
@@ -889,8 +888,8 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
         except (KeyError, IndexError):
             try:
                 asdt, parsed, reso = parse_time_string(key, self.freq)
-                grp = _freq_mod._infer_period_group(reso)
-                freqn = _freq_mod._period_group(self.freq)
+                grp = frequencies._infer_period_group(reso)
+                freqn = frequencies._period_group(self.freq)
 
                 vals = self.values
 
@@ -978,8 +977,8 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
 
         key, parsed, reso = parse_time_string(key, self.freq)
 
-        grp = _freq_mod._infer_period_group(reso)
-        freqn = _freq_mod._period_group(self.freq)
+        grp = frequencies._infer_period_group(reso)
+        freqn = frequencies._period_group(self.freq)
 
         if reso == 'year':
             t1 = Period(year=parsed.year, freq='A')
@@ -1216,12 +1215,12 @@ def _range_from_fields(year=None, month=None, quarter=None, day=None,
     if quarter is not None:
         if freq is None:
             freq = 'Q'
-            base = FreqGroup.FR_QTR
+            base = frequencies.FreqGroup.FR_QTR
         else:
             base, mult = _gfc(freq)
             if mult != 1:
                 raise ValueError('Only mult == 1 supported')
-            if base != FreqGroup.FR_QTR:
+            if base != frequencies.FreqGroup.FR_QTR:
                 raise AssertionError("base must equal FR_QTR")
 
         year, quarter = _make_field_arrays(year, quarter)
@@ -1273,7 +1272,7 @@ def _quarter_to_myear(year, quarter, freq):
         if quarter <= 0 or quarter > 4:
             raise ValueError('Quarter must be 1 <= q <= 4')
 
-        mnum = _month_numbers[_freq_mod._get_rule_month(freq)] + 1
+        mnum = frequencies._month_numbers[frequencies._get_rule_month(freq)] + 1
         month = (mnum + (quarter - 1) * 3) % 12 + 1
         if month > mnum:
             year -= 1
diff --git a/pandas/tseries/tests/test_frequencies.py b/pandas/tseries/tests/test_frequencies.py
index 10a8286f4..24deb8a29 100644
--- a/pandas/tseries/tests/test_frequencies.py
+++ b/pandas/tseries/tests/test_frequencies.py
@@ -9,9 +9,9 @@ import numpy as np
 
 from pandas import Index, DatetimeIndex, Timestamp, Series, date_range, period_range
 
-from pandas.tseries.frequencies import to_offset, infer_freq
+import pandas.tseries.frequencies as frequencies
 from pandas.tseries.tools import to_datetime
-import pandas.tseries.frequencies as fmod
+
 import pandas.tseries.offsets as offsets
 from pandas.tseries.period import PeriodIndex
 import pandas.compat as compat
@@ -23,40 +23,40 @@ def test_to_offset_multiple():
     freqstr = '2h30min'
     freqstr2 = '2h 30min'
 
-    result = to_offset(freqstr)
-    assert(result == to_offset(freqstr2))
+    result = frequencies.to_offset(freqstr)
+    assert(result == frequencies.to_offset(freqstr2))
     expected = offsets.Minute(150)
     assert(result == expected)
 
     freqstr = '2h30min15s'
-    result = to_offset(freqstr)
+    result = frequencies.to_offset(freqstr)
     expected = offsets.Second(150 * 60 + 15)
     assert(result == expected)
 
     freqstr = '2h 60min'
-    result = to_offset(freqstr)
+    result = frequencies.to_offset(freqstr)
     expected = offsets.Hour(3)
     assert(result == expected)
 
     freqstr = '15l500u'
-    result = to_offset(freqstr)
+    result = frequencies.to_offset(freqstr)
     expected = offsets.Micro(15500)
     assert(result == expected)
 
     freqstr = '10s75L'
-    result = to_offset(freqstr)
+    result = frequencies.to_offset(freqstr)
     expected = offsets.Milli(10075)
     assert(result == expected)
 
     if not _np_version_under1p7:
         freqstr = '2800N'
-        result = to_offset(freqstr)
+        result = frequencies.to_offset(freqstr)
         expected = offsets.Nano(2800)
         assert(result == expected)
 
     # malformed
     try:
-        to_offset('2h20m')
+        frequencies.to_offset('2h20m')
     except ValueError:
         pass
     else:
@@ -65,31 +65,31 @@ def test_to_offset_multiple():
 
 def test_to_offset_negative():
     freqstr = '-1S'
-    result = to_offset(freqstr)
+    result = frequencies.to_offset(freqstr)
     assert(result.n == -1)
 
     freqstr = '-5min10s'
-    result = to_offset(freqstr)
+    result = frequencies.to_offset(freqstr)
     assert(result.n == -310)
 
 
 def test_to_offset_leading_zero():
     freqstr = '00H 00T 01S'
-    result = to_offset(freqstr)
+    result = frequencies.to_offset(freqstr)
     assert(result.n == 1)
 
     freqstr = '-00H 03T 14S'
-    result = to_offset(freqstr)
+    result = frequencies.to_offset(freqstr)
     assert(result.n == -194)
 
 
 def test_anchored_shortcuts():
-    result = to_offset('W')
-    expected = to_offset('W-SUN')
+    result = frequencies.to_offset('W')
+    expected = frequencies.to_offset('W-SUN')
     assert(result == expected)
 
-    result = to_offset('Q')
-    expected = to_offset('Q-DEC')
+    result = frequencies.to_offset('Q')
+    expected = frequencies.to_offset('Q-DEC')
     assert(result == expected)
 
 
@@ -100,26 +100,26 @@ class TestFrequencyInference(tm.TestCase):
 
     def test_raise_if_period_index(self):
         index = PeriodIndex(start="1/1/1990", periods=20, freq="M")
-        self.assertRaises(TypeError, infer_freq, index)
+        self.assertRaises(TypeError, frequencies.infer_freq, index)
 
     def test_raise_if_too_few(self):
         index = _dti(['12/31/1998', '1/3/1999'])
-        self.assertRaises(ValueError, infer_freq, index)
+        self.assertRaises(ValueError, frequencies.infer_freq, index)
 
     def test_business_daily(self):
         index = _dti(['12/31/1998', '1/3/1999', '1/4/1999'])
-        self.assertEqual(infer_freq(index), 'B')
+        self.assertEqual(frequencies.infer_freq(index), 'B')
 
     def test_day(self):
         self._check_tick(timedelta(1), 'D')
 
     def test_day_corner(self):
         index = _dti(['1/1/2000', '1/2/2000', '1/3/2000'])
-        self.assertEqual(infer_freq(index), 'D')
+        self.assertEqual(frequencies.infer_freq(index), 'D')
 
     def test_non_datetimeindex(self):
         dates = to_datetime(['1/1/2000', '1/2/2000', '1/3/2000'])
-        self.assertEqual(infer_freq(dates), 'D')
+        self.assertEqual(frequencies.infer_freq(dates), 'D')
 
     def test_hour(self):
         self._check_tick(timedelta(hours=1), 'H')
@@ -149,15 +149,15 @@ class TestFrequencyInference(tm.TestCase):
                 exp_freq = '%d%s' % (i, code)
             else:
                 exp_freq = code
-            self.assertEqual(infer_freq(index), exp_freq)
+            self.assertEqual(frequencies.infer_freq(index), exp_freq)
 
         index = _dti([b + base_delta * 7] +
                      [b + base_delta * j for j in range(3)])
-        self.assertIsNone(infer_freq(index))
+        self.assertIsNone(frequencies.infer_freq(index))
 
         index = _dti([b + base_delta * j for j in range(3)] +
                      [b + base_delta * 7])
-        self.assertIsNone(infer_freq(index))
+        self.assertIsNone(frequencies.infer_freq(index))
 
     def test_weekly(self):
         days = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN']
@@ -175,7 +175,7 @@ class TestFrequencyInference(tm.TestCase):
     def test_week_of_month_fake(self):
         #All of these dates are on same day of week and are 4 or 5 weeks apart
         index = DatetimeIndex(["2013-08-27","2013-10-01","2013-10-29","2013-11-26"])
-        assert infer_freq(index) != 'WOM-4TUE'
+        assert frequencies.infer_freq(index) != 'WOM-4TUE'
 
     def test_monthly(self):
         self._check_generated_range('1/1/2000', 'M')
@@ -212,9 +212,9 @@ class TestFrequencyInference(tm.TestCase):
         gen = date_range(start, periods=7, freq=freq)
         index = _dti(gen.values)
         if not freq.startswith('Q-'):
-            self.assertEqual(infer_freq(index), gen.freqstr)
+            self.assertEqual(frequencies.infer_freq(index), gen.freqstr)
         else:
-            inf_freq = infer_freq(index)
+            inf_freq = frequencies.infer_freq(index)
             self.assertTrue((inf_freq == 'Q-DEC' and
                              gen.freqstr in ('Q', 'Q-DEC', 'Q-SEP', 'Q-JUN',
                                              'Q-MAR'))
@@ -228,9 +228,9 @@ class TestFrequencyInference(tm.TestCase):
         gen = date_range(start, periods=5, freq=freq)
         index = _dti(gen.values)
         if not freq.startswith('Q-'):
-            self.assertEqual(infer_freq(index), gen.freqstr)
+            self.assertEqual(frequencies.infer_freq(index), gen.freqstr)
         else:
-            inf_freq = infer_freq(index)
+            inf_freq = frequencies.infer_freq(index)
             self.assertTrue((inf_freq == 'Q-DEC' and
                              gen.freqstr in ('Q', 'Q-DEC', 'Q-SEP', 'Q-JUN',
                                              'Q-MAR'))
@@ -281,7 +281,7 @@ class TestFrequencyInference(tm.TestCase):
 
         vals = rng.to_pydatetime()
 
-        result = infer_freq(vals)
+        result = frequencies.infer_freq(vals)
         self.assertEqual(result, rng.inferred_freq)
 
     def test_invalid_index_types(self):
@@ -290,17 +290,17 @@ class TestFrequencyInference(tm.TestCase):
         for i in [ tm.makeIntIndex(10),
                    tm.makeFloatIndex(10),
                    tm.makePeriodIndex(10) ]:
-            self.assertRaises(TypeError, lambda : infer_freq(i))
+            self.assertRaises(TypeError, lambda : frequencies.infer_freq(i))
 
         for i in [ tm.makeStringIndex(10),
                    tm.makeUnicodeIndex(10) ]:
-            self.assertRaises(ValueError, lambda : infer_freq(i))
+            self.assertRaises(ValueError, lambda : frequencies.infer_freq(i))
 
     def test_string_datetimelike_compat(self):
 
         # GH 6463
-        expected = infer_freq(['2004-01', '2004-02', '2004-03', '2004-04'])
-        result = infer_freq(Index(['2004-01', '2004-02', '2004-03', '2004-04']))
+        expected = frequencies.infer_freq(['2004-01', '2004-02', '2004-03', '2004-04'])
+        result = frequencies.infer_freq(Index(['2004-01', '2004-02', '2004-03', '2004-04']))
         self.assertEqual(result,expected)
 
     def test_series(self):
@@ -311,24 +311,24 @@ class TestFrequencyInference(tm.TestCase):
         # invalid type of Series
         for s in [ Series(np.arange(10)),
                    Series(np.arange(10.))]:
-            self.assertRaises(TypeError, lambda : infer_freq(s))
+            self.assertRaises(TypeError, lambda : frequencies.infer_freq(s))
 
         # a non-convertible string
-        self.assertRaises(ValueError, lambda : infer_freq(Series(['foo','bar'])))
+        self.assertRaises(ValueError, lambda : frequencies.infer_freq(Series(['foo','bar'])))
 
         # cannot infer on PeriodIndex
         for freq in [None, 'L', 'Y']:
             s = Series(period_range('2013',periods=10,freq=freq))
-            self.assertRaises(TypeError, lambda : infer_freq(s))
+            self.assertRaises(TypeError, lambda : frequencies.infer_freq(s))
 
         # DateTimeIndex
         for freq in ['M', 'L', 'S']:
             s = Series(date_range('20130101',periods=10,freq=freq))
-            inferred = infer_freq(s)
+            inferred = frequencies.infer_freq(s)
             self.assertEqual(inferred,freq)
 
         s = Series(date_range('20130101','20130110'))
-        inferred = infer_freq(s)
+        inferred = frequencies.infer_freq(s)
         self.assertEqual(inferred,'D')
 
 MONTHS = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP',
@@ -336,20 +336,20 @@ MONTHS = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP',
 
 
 def test_is_superperiod_subperiod():
-    assert(fmod.is_superperiod(offsets.YearEnd(), offsets.MonthEnd()))
-    assert(fmod.is_subperiod(offsets.MonthEnd(), offsets.YearEnd()))
+    assert(frequencies.is_superperiod(offsets.YearEnd(), offsets.MonthEnd()))
+    assert(frequencies.is_subperiod(offsets.MonthEnd(), offsets.YearEnd()))
 
-    assert(fmod.is_superperiod(offsets.Hour(), offsets.Minute()))
-    assert(fmod.is_subperiod(offsets.Minute(), offsets.Hour()))
+    assert(frequencies.is_superperiod(offsets.Hour(), offsets.Minute()))
+    assert(frequencies.is_subperiod(offsets.Minute(), offsets.Hour()))
 
-    assert(fmod.is_superperiod(offsets.Second(), offsets.Milli()))
-    assert(fmod.is_subperiod(offsets.Milli(), offsets.Second()))
+    assert(frequencies.is_superperiod(offsets.Second(), offsets.Milli()))
+    assert(frequencies.is_subperiod(offsets.Milli(), offsets.Second()))
 
-    assert(fmod.is_superperiod(offsets.Milli(), offsets.Micro()))
-    assert(fmod.is_subperiod(offsets.Micro(), offsets.Milli()))
+    assert(frequencies.is_superperiod(offsets.Milli(), offsets.Micro()))
+    assert(frequencies.is_subperiod(offsets.Micro(), offsets.Milli()))
 
-    assert(fmod.is_superperiod(offsets.Micro(), offsets.Nano()))
-    assert(fmod.is_subperiod(offsets.Nano(), offsets.Micro()))
+    assert(frequencies.is_superperiod(offsets.Micro(), offsets.Nano()))
+    assert(frequencies.is_subperiod(offsets.Nano(), offsets.Micro()))
 
 
 if __name__ == '__main__':
diff --git a/pandas/tseries/tests/test_offsets.py b/pandas/tseries/tests/test_offsets.py
index d99cfb254..065aa9236 100644
--- a/pandas/tseries/tests/test_offsets.py
+++ b/pandas/tseries/tests/test_offsets.py
@@ -19,7 +19,7 @@ from pandas.core.datetools import (
 
 from pandas.tseries.frequencies import _offset_map
 from pandas.tseries.index import _to_m8, DatetimeIndex, _daterange_cache, date_range
-from pandas.tseries.tools import parse_time_string, _maybe_get_tz
+from pandas.tseries.tools import parse_time_string
 import pandas.tseries.offsets as offsets
 
 from pandas.tslib import NaT, Timestamp
@@ -243,7 +243,7 @@ class TestCommon(Base):
 
         for tz in self.timezones:
             expected_localize = expected.tz_localize(tz)
-            tz_obj = _maybe_get_tz(tz)
+            tz_obj = tslib.maybe_get_tz(tz)
             dt_tz = tslib._localize_pydatetime(dt, tz_obj)
 
             result = func(dt_tz)
diff --git a/pandas/tseries/tests/test_period.py b/pandas/tseries/tests/test_period.py
index f5f66a49c..b9d4dd804 100644
--- a/pandas/tseries/tests/test_period.py
+++ b/pandas/tseries/tests/test_period.py
@@ -15,7 +15,7 @@ from pandas.tseries.frequencies import MONTHS, DAYS, _period_code_map
 from pandas.tseries.period import Period, PeriodIndex, period_range
 from pandas.tseries.index import DatetimeIndex, date_range, Index
 from pandas.tseries.tools import to_datetime
-import pandas.tseries.period as pmod
+import pandas.tseries.period as period
 
 import pandas.core.datetools as datetools
 import pandas as pd
@@ -508,7 +508,7 @@ class TestPeriodProperties(tm.TestCase):
     def test_pnow(self):
         dt = datetime.now()
 
-        val = pmod.pnow('D')
+        val = period.pnow('D')
         exp = Period(dt, freq='D')
         self.assertEqual(val, exp)
 
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index f2bc66f15..9d5f45735 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -15,7 +15,7 @@ from pandas import (Index, Series, TimeSeries, DataFrame,
 import pandas.core.datetools as datetools
 import pandas.tseries.offsets as offsets
 import pandas.tseries.tools as tools
-import pandas.tseries.frequencies as fmod
+import pandas.tseries.frequencies as frequencies
 import pandas as pd
 
 from pandas.util.testing import assert_series_equal, assert_almost_equal
@@ -28,7 +28,6 @@ import pandas.tslib as tslib
 import pandas.index as _index
 
 from pandas.compat import range, long, StringIO, lrange, lmap, zip, product
-import pandas.core.datetools as dt
 from numpy.random import rand
 from numpy.testing import assert_array_equal
 from pandas.util.testing import assert_frame_equal
@@ -2961,7 +2960,7 @@ class TestDatetime64(tm.TestCase):
         edate = datetime(2000, 1, 1)
         idx = DatetimeIndex(start=sdate, freq='1B', periods=20)
         self.assertEqual(len(idx), 20)
-        self.assertEqual(idx[0], sdate + 0 * dt.bday)
+        self.assertEqual(idx[0], sdate + 0 * datetools.bday)
         self.assertEqual(idx.freq, 'B')
 
         idx = DatetimeIndex(end=edate, freq=('D', 5), periods=20)
@@ -2971,19 +2970,19 @@ class TestDatetime64(tm.TestCase):
 
         idx1 = DatetimeIndex(start=sdate, end=edate, freq='W-SUN')
         idx2 = DatetimeIndex(start=sdate, end=edate,
-                             freq=dt.Week(weekday=6))
+                             freq=datetools.Week(weekday=6))
         self.assertEqual(len(idx1), len(idx2))
         self.assertEqual(idx1.offset, idx2.offset)
 
         idx1 = DatetimeIndex(start=sdate, end=edate, freq='QS')
         idx2 = DatetimeIndex(start=sdate, end=edate,
-                             freq=dt.QuarterBegin(startingMonth=1))
+                             freq=datetools.QuarterBegin(startingMonth=1))
         self.assertEqual(len(idx1), len(idx2))
         self.assertEqual(idx1.offset, idx2.offset)
 
         idx1 = DatetimeIndex(start=sdate, end=edate, freq='BQ')
         idx2 = DatetimeIndex(start=sdate, end=edate,
-                             freq=dt.BQuarterEnd(startingMonth=12))
+                             freq=datetools.BQuarterEnd(startingMonth=12))
         self.assertEqual(len(idx1), len(idx2))
         self.assertEqual(idx1.offset, idx2.offset)
 
@@ -3474,31 +3473,31 @@ class TestTimestamp(tm.TestCase):
         self.assertEqual(result.nanosecond, val.nanosecond)
 
     def test_frequency_misc(self):
-        self.assertEqual(fmod.get_freq_group('T'),
-                          fmod.FreqGroup.FR_MIN)
+        self.assertEqual(frequencies.get_freq_group('T'),
+                          frequencies.FreqGroup.FR_MIN)
 
-        code, stride = fmod.get_freq_code(offsets.Hour())
-        self.assertEqual(code, fmod.FreqGroup.FR_HR)
+        code, stride = frequencies.get_freq_code(offsets.Hour())
+        self.assertEqual(code, frequencies.FreqGroup.FR_HR)
 
-        code, stride = fmod.get_freq_code((5, 'T'))
-        self.assertEqual(code, fmod.FreqGroup.FR_MIN)
+        code, stride = frequencies.get_freq_code((5, 'T'))
+        self.assertEqual(code, frequencies.FreqGroup.FR_MIN)
         self.assertEqual(stride, 5)
 
         offset = offsets.Hour()
-        result = fmod.to_offset(offset)
+        result = frequencies.to_offset(offset)
         self.assertEqual(result, offset)
 
-        result = fmod.to_offset((5, 'T'))
+        result = frequencies.to_offset((5, 'T'))
         expected = offsets.Minute(5)
         self.assertEqual(result, expected)
 
-        self.assertRaises(ValueError, fmod.get_freq_code, (5, 'baz'))
+        self.assertRaises(ValueError, frequencies.get_freq_code, (5, 'baz'))
 
-        self.assertRaises(ValueError, fmod.to_offset, '100foo')
+        self.assertRaises(ValueError, frequencies.to_offset, '100foo')
 
-        self.assertRaises(ValueError, fmod.to_offset, ('', ''))
+        self.assertRaises(ValueError, frequencies.to_offset, ('', ''))
 
-        result = fmod.get_standard_freq(offsets.Hour())
+        result = frequencies.get_standard_freq(offsets.Hour())
         self.assertEqual(result, 'H')
 
     def test_hash_equivalent(self):
@@ -3936,7 +3935,7 @@ class TimeConversionFormats(tm.TestCase):
         val = '01-Apr-2011 00:00:01.978'
         format = '%d-%b-%Y %H:%M:%S.%f'
         result = to_datetime(val, format=format)
-        exp = dt.datetime.strptime(val, format)
+        exp = datetime.strptime(val, format)
         self.assertEqual(result, exp)
 
     def test_to_datetime_format_time(self):
diff --git a/pandas/tseries/tools.py b/pandas/tseries/tools.py
index b4ab813d3..457a95deb 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/tseries/tools.py
@@ -56,20 +56,6 @@ def _infer_tzinfo(start, end):
     return tz
 
 
-def _maybe_get_tz(tz, date=None):
-    tz = tslib.maybe_get_tz(tz)
-    if com.is_integer(tz):
-        import pytz
-        tz = pytz.FixedOffset(tz / 60)
-
-    # localize and get the tz
-    if date is not None and tz is not None:
-        if date.tzinfo is not None and hasattr(tz,'localize'):
-            tz = tz.localize(date.replace(tzinfo=None)).tzinfo
-
-    return tz
-
-
 def _guess_datetime_format(dt_str, dayfirst=False,
                            dt_str_parse=compat.parse_date,
                            dt_str_split=_DATEUTIL_LEXER_SPLIT):
diff --git a/pandas/tslib.pyx b/pandas/tslib.pyx
index 655b92cfe..dc9f3fa25 100644
--- a/pandas/tslib.pyx
+++ b/pandas/tslib.pyx
@@ -1121,9 +1121,10 @@ cpdef inline object maybe_get_tz(object tz):
                 tz._filename = zone
         else:
             tz = pytz.timezone(tz)
-        return tz
-    else:
-        return tz
+    elif util.is_integer_object(tz):
+        tz = pytz.FixedOffset(tz / 60)
+    return tz
+
 
 
 class OutOfBoundsDatetime(ValueError):
@@ -2223,7 +2224,7 @@ def tz_localize_to_utc(ndarray[int64_t] vals, object tz, bint infer_dst=False):
     result_b.fill(NPY_NAT)
 
     # left side
-    idx_shifted = _ensure_int64(
+    idx_shifted = ensure_int64(
         np.maximum(0, trans.searchsorted(vals - DAY_NS, side='right') - 1))
 
     for i in range(n):
@@ -2235,7 +2236,7 @@ def tz_localize_to_utc(ndarray[int64_t] vals, object tz, bint infer_dst=False):
             result_a[i] = v
 
     # right side
-    idx_shifted = _ensure_int64(
+    idx_shifted = ensure_int64(
         np.maximum(0, trans.searchsorted(vals + DAY_NS, side='right') - 1))
 
     for i in range(n):
@@ -2313,14 +2314,8 @@ def tz_localize_to_utc(ndarray[int64_t] vals, object tz, bint infer_dst=False):
 
     return result
 
-cdef _ensure_int64(object arr):
-    if util.is_array(arr):
-        if (<ndarray> arr).descr.type_num == NPY_INT64:
-            return arr
-        else:
-            return arr.astype(np.int64)
-    else:
-        return np.array(arr, dtype=np.int64)
+import pandas.algos as algos
+ensure_int64 = algos.ensure_int64
 
 
 cdef inline bisect_right_i8(int64_t *data, int64_t val, Py_ssize_t n):

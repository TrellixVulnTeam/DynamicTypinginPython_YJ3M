commit ddcc30a7e6f7761638d0936e21bfae1144424e1c
Author: Chang She <changshe@gmail.com>
Date:   Sun Sep 9 22:08:02 2012 -0400

    BUG: start_time on Period fix #1857

diff --git a/pandas/io/sql.py b/pandas/io/sql.py
index 4601063c7..6d1628fd8 100644
--- a/pandas/io/sql.py
+++ b/pandas/io/sql.py
@@ -152,7 +152,7 @@ def read_frame(sql, con, index_col=None, coerce_float=True):
 
 frame_query = read_frame
 
-def write_frame(frame, name=None, con=None, flavor='sqlite'):
+def write_frame(frame, name=None, con=None, flavor='sqlite', append=False):
     """
     Write records stored in a DataFrame to SQLite. The index will currently be
     dropped
@@ -162,13 +162,19 @@ def write_frame(frame, name=None, con=None, flavor='sqlite'):
     else:
         raise NotImplementedError
 
-    con.execute(schema)
+    if not append and not has_table(name, con):
+        con.execute(schema)
 
     wildcards = ','.join(['?'] * len(frame.columns))
     insert_sql = 'INSERT INTO %s VALUES (%s)' % (name, wildcards)
     data = [tuple(x) for x in frame.values]
     con.executemany(insert_sql, data)
 
+def has_table(name, con):
+    sqlstr = "SELECT name FROM sqlite_master WHERE type='table' AND name='%s'" % name
+    rs = tquery(sqlstr, con)
+    return len(rs) > 0
+
 def get_sqlite_schema(frame, name, dtypes=None, keys=None):
     template = """
 CREATE TABLE %(name)s (
diff --git a/pandas/tseries/frequencies.py b/pandas/tseries/frequencies.py
index 8cb1fdfd8..77f03dc4d 100644
--- a/pandas/tseries/frequencies.py
+++ b/pandas/tseries/frequencies.py
@@ -20,6 +20,13 @@ class FreqGroup(object):
     FR_MIN = 8000
     FR_SEC = 9000
 
+def get_to_timestamp_base(base):
+    if base <= FreqGroup.FR_WK:
+        return FreqGroup.FR_DAY
+    if FreqGroup.FR_HR <= base <= FreqGroup.FR_SEC:
+        return FreqGroup.FR_SEC
+    return base
+
 def get_freq_group(freq):
     if isinstance(freq, basestring):
         base, mult = get_freq_code(freq)
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index 054bf36e0..7f1939ab3 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -19,7 +19,6 @@ import pandas._algos as _algos
 #---------------
 # Period logic
 
-
 def _period_field_accessor(name, alias):
     def f(self):
         base, mult = _gfc(self.freq)
@@ -201,14 +200,19 @@ class Period(object):
         """
         if freq is None:
             base, mult = _gfc(self.freq)
-            new_val = self
+            how = _validate_end_alias(how)
+            if how == 'S':
+                base = _freq_mod.get_to_timestamp_base(base)
+                freq = _freq_mod._get_freq_str(base)
+                new_val = self.asfreq(freq, how)
+            else:
+                new_val = self
         else:
             base, mult = _gfc(freq)
             new_val = self.asfreq(freq, how)
 
         dt64 = plib.period_ordinal_to_dt64(new_val.ordinal, base)
-        ts_freq = _period_rule_to_timestamp_rule(new_val.freq, how=how)
-        return Timestamp(dt64, offset=to_offset(ts_freq))
+        return Timestamp(dt64)
 
     year = _period_field_accessor('year', 0)
     month = _period_field_accessor('month', 3)
diff --git a/pandas/tseries/tests/test_period.py b/pandas/tseries/tests/test_period.py
index 07dfbfc77..d2f723677 100644
--- a/pandas/tseries/tests/test_period.py
+++ b/pandas/tseries/tests/test_period.py
@@ -62,7 +62,7 @@ class TestPeriodProperties(TestCase):
         for month in MONTHS:
             freq = 'A-%s' % month
             exp = Period('1989', freq=freq)
-            stamp = exp.to_timestamp('D', how='end') + 30
+            stamp = exp.to_timestamp('D', how='end') + timedelta(days=30)
             p = Period(stamp, freq=freq)
             self.assertEquals(p, exp + 1)
 
@@ -259,6 +259,43 @@ class TestPeriodProperties(TestCase):
 
         self.assertRaises(ValueError, p.to_timestamp, '5t')
 
+    def test_start_time(self):
+        freq_lst = ['A', 'Q', 'M', 'D', 'H', 'T', 'S']
+        xp = datetime(2012, 1, 1)
+        for f in freq_lst:
+            p = Period('2012', freq=f)
+            self.assertEquals(p.start_time, xp)
+        self.assertEquals(Period('2012', freq='B').start_time,
+                          datetime(2011, 12, 30))
+        self.assertEquals(Period('2012', freq='W').start_time,
+                          datetime(2011, 12, 26))
+
+    def test_end_time(self):
+        p = Period('2012', freq='A')
+        xp = datetime(2012, 12, 31)
+        self.assertEquals(xp, p.end_time)
+
+        p = Period('2012', freq='Q')
+        xp = datetime(2012, 3, 31)
+        self.assertEquals(xp, p.end_time)
+
+        p = Period('2012', freq='M')
+        xp = datetime(2012, 1, 31)
+        self.assertEquals(xp, p.end_time)
+
+        xp = datetime(2012, 1, 1)
+        freq_lst = ['D', 'H', 'T', 'S']
+        for f in freq_lst:
+            p = Period('2012', freq=f)
+            self.assertEquals(p.end_time, xp)
+
+        self.assertEquals(Period('2012', freq='B').end_time,
+                          datetime(2011, 12, 30))
+
+        self.assertEquals(Period('2012', freq='W').end_time,
+                          datetime(2012, 1, 1))
+
+
     def test_properties_annually(self):
         # Test properties on Periods with annually frequency.
         a_date = Period(freq='A', year=2007)

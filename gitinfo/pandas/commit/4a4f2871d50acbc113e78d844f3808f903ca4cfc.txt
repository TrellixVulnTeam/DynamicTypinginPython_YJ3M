commit 4a4f2871d50acbc113e78d844f3808f903ca4cfc
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Sep 5 21:36:54 2011 -0400

    ENH: stack/unstack bug fixes and unit tests

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 0e869761c..63ff17fb9 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -290,10 +290,6 @@ class DataFrame(NDFrame):
         """True if DataFrame has this column"""
         return key in self.columns
 
-    def copy(self):
-        """Make a deep copy of this DataFrame"""
-        return self._constructor(self._data.copy())
-
     #----------------------------------------------------------------------
     # Arithmetic methods
 
@@ -1256,6 +1252,22 @@ class DataFrame(NDFrame):
         new_values = self.values.take(indexer, axis=axis)
         return self._constructor(new_values, index=index, columns=columns)
 
+    def swaplevel(self, i, j, axis=0):
+        """
+        Swap levels i and j in a MultiIndex on a particular axis
+
+        Returns
+        -------
+        swapped : type of caller (new object)
+        """
+        result = self.copy()
+
+        if axis == 0:
+            result.index = result.index.swaplevel(i, j)
+        else:
+            result.columns = result.columns.swaplevel(i, j)
+        return result
+
     #----------------------------------------------------------------------
     # Filling NA's
 
@@ -1648,7 +1660,7 @@ class DataFrame(NDFrame):
 
         stacked = DataFrame(mat, index=mindex, columns=items)
 
-        if not mindex.is_lexsorted:
+        if not mindex.is_lexsorted():
             stacked = stacked.sortlevel(level=0)
 
         unstacked = stacked.unstack()
@@ -1665,28 +1677,46 @@ class DataFrame(NDFrame):
         -------
         stacked : Series
         """
+        N, K = self.shape
         if isinstance(self.columns, MultiIndex):
-            return self._stack_multi(level=level)
+            return self._stack_multi_columns(level=level)
+        elif isinstance(self.index, MultiIndex):
+
+            new_levels = list(self.index.levels)
+            new_levels.append(self.columns)
+
+            new_labels = [lab.repeat(K) for lab in self.index.labels]
+            new_labels.append(np.tile(np.arange(K), N).ravel())
+
+            new_names = list(self.index.names)
+            new_names.append('columns')
+            new_index = MultiIndex(levels=new_levels, labels=new_labels,
+                                   names=new_names)
+        else:
+            ilabels = np.arange(N).repeat(K)
+            clabels = np.tile(np.arange(K), N).ravel()
+            new_index = MultiIndex(levels=[self.index, self.columns],
+                                   labels=[ilabels, clabels])
 
-        N, K = len(self.index), len(self.columns)
-        ilabels = np.arange(N).repeat(K)
-        clabels = np.tile(np.arange(K), N).ravel()
-        new_index = MultiIndex(levels=[self.index, self.columns],
-                               labels=[ilabels, clabels])
         return Series(self.values.ravel(), index=new_index)
 
-    def _stack_multi(self, level=-1):
+    def _stack_multi_columns(self, level=-1):
         import itertools
-        this = self
+        this = self.copy()
         if level < 0:
             level += self.columns.nlevels
 
         # this makes life much simpler
         if level != self.columns.nlevels - 1:
             last = self.columns.nlevels - 1
-            this.columns = this.columns.swaplevel(level, last)
 
-        if not this.columns.is_lexsorted:
+            # roll levels to put selected level at end
+            roll_columns = this.columns
+            for i in range(level, self.columns.nlevels - 1):
+                roll_columns = roll_columns.swaplevel(i, i + 1)
+            this.columns = roll_columns
+
+        if not this.columns.is_lexsorted():
             this = this.sortlevel(0, axis=1)
 
         # tuple list excluding level for grouping columns
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 47619486b..89605f754 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -234,11 +234,49 @@ class TestMultiLevel(unittest.TestCase):
         unstacked = self.ymd.unstack()
         unstacked2 = unstacked.unstack()
 
-    def test_stack_roundtrip(self):
+    def test_stack(self):
+        # regular roundtrip
         unstacked = self.ymd.unstack()
         restacked = unstacked.stack()
         assert_frame_equal(restacked, self.ymd)
 
+        unlexsorted = self.ymd.sortlevel(2)
+
+        unstacked = unlexsorted.unstack(2)
+        restacked = unstacked.stack()
+        assert_frame_equal(restacked.sortlevel(0), self.ymd)
+
+        unlexsorted = unlexsorted[::-1]
+        unstacked = unlexsorted.unstack(1)
+        restacked = unstacked.stack().swaplevel(1, 2)
+        assert_frame_equal(restacked.sortlevel(0), self.ymd)
+
+        unlexsorted = unlexsorted.swaplevel(0, 1)
+        unstacked = unlexsorted.unstack(0).swaplevel(0, 1, axis=1)
+        restacked = unstacked.stack(0).swaplevel(1, 2)
+        assert_frame_equal(restacked.sortlevel(0), self.ymd)
+
+        # columns unsorted
+        unstacked = self.ymd.unstack()
+        unstacked = unstacked.sort(axis=1, ascending=False)
+        restacked = unstacked.stack()
+        assert_frame_equal(restacked, self.ymd)
+
+        # more than 2 levels in the columns
+        unstacked = self.ymd.unstack(1).unstack(1)
+
+        result = unstacked.stack(1)
+        expected = self.ymd.unstack()
+        assert_frame_equal(result, expected)
+
+        result = unstacked.stack(2)
+        expected = self.ymd.unstack(1)
+        assert_frame_equal(result, expected)
+
+        result = unstacked.stack(0)
+        expected = self.ymd.stack().unstack(1).unstack(1)
+        assert_frame_equal(result, expected)
+
     def test_insert_index(self):
         df = self.ymd[:5].T
         df[2000, 1, 10] = df[2000, 1, 7]

commit d0b25d772c40d4112e4ebab6e30678d326a71154
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Jun 25 00:10:26 2011 -0400

    created indexing.py to organize fancy indexing code

diff --git a/pandas/core/common.py b/pandas/core/common.py
index 2e9f5dfdc..dd91b9127 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -96,25 +96,6 @@ def _mut_exclusive(arg1, arg2):
     else:
         return arg2
 
-
-def _is_list_like(obj):
-    return isinstance(obj, (list, np.ndarray))
-
-def _is_label_slice(labels, obj):
-    def crit(x):
-        if x in labels:
-            return False
-        else:
-            return isinstance(x, int) or x is None
-    return not crit(obj.start) or not crit(obj.stop)
-
-def _need_slice(obj):
-    return obj.start is not None or obj.stop is not None
-
-def _check_step(obj):
-    if obj.step is not None and obj.step != 1:
-        raise Exception('steps other than 1 are not supported')
-
 def _ensure_index(index_like):
     from pandas.core.index import Index
     if not isinstance(index_like, Index):
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index ae701842e..d42463c58 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -21,8 +21,7 @@ import warnings
 from numpy import nan
 import numpy as np
 
-from pandas.core.common import (isnull, notnull, _check_step, _is_list_like,
-                                _need_slice, _is_label_slice, _ensure_index,
+from pandas.core.common import (isnull, notnull, _ensure_index,
                                 _try_sort, _pfixed)
 from pandas.core.daterange import DateRange
 from pandas.core.generic import PandasGeneric
@@ -166,7 +165,6 @@ class DataFrame(PandasGeneric):
         Somehow this got outrageously complicated
         """
         from pandas.core.internals import form_blocks
-        # TODO: deal with emptiness!
         # prefilter if columns passed
         if columns is not None:
             columns = _ensure_index(columns)
@@ -921,8 +919,6 @@ class DataFrame(PandasGeneric):
     def _reindex_index(self, new_index, method):
         if new_index is self.index:
             return self.copy()
-
-        # TODO: want to preserve dtypes though...
         new_data = self._data.reindex_index(new_index, method)
         return DataFrame(new_data)
 
@@ -1684,7 +1680,6 @@ class DataFrame(PandasGeneric):
 
         new_columns = self.columns
 
-        this = self
         if not new_columns.equals(other.columns):
             new_columns = self.columns + other.columns
 
@@ -2461,159 +2456,12 @@ class DataFrame(PandasGeneric):
     _ix = None
     @property
     def ix(self):
+        from pandas.core.indexing import _DataFrameIndexer
         if self._ix is None:
             self._ix = _DataFrameIndexer(self)
 
         return self._ix
 
-def _is_label_like(key):
-    # select a label or row
-    return not isinstance(key, slice) and not _is_list_like(key)
-
-class AmbiguousIndexError(Exception):
-    pass
-
-class _DataFrameIndexer(object):
-    """
-    Class to support fancy indexing, potentially using labels of DataFrame
-
-    Notes
-    -----
-    Indexing based on labels is INCLUSIVE
-    Slicing uses PYTHON SEMANTICS (endpoint is excluded)
-
-    If Index contains int labels, these will be used rather than the locations,
-    so be very careful (ambiguous).
-
-    Examples
-    --------
-    >>> frame.ix[5:10, ['A', 'B']]
-    >>> frame.ix[date1:date2, 'A']
-    """
-
-    def __init__(self, frame):
-        self.frame = frame
-
-    def __getitem__(self, key):
-        frame = self.frame
-        if isinstance(key, slice):
-            return self._fancy_getitem_axis(key, axis=0)
-        elif isinstance(key, tuple):
-            if len(key) != 2:
-                raise Exception('only length 2 tuple supported')
-            return self._fancy_getitem_tuple(*key)
-        elif _is_list_like(key):
-            return self._fancy_getitem(key, axis=0)
-        else:
-            return self._fancy_getitem_axis(key, axis=0)
-
-    def __setitem__(self, key, value):
-        # also has the side effect of consolidating in-place
-        if self.frame._is_mixed_type:
-            raise Exception('setting on mixed-type frames not yet supported')
-
-        frame = self.frame
-        if isinstance(key, slice):
-            return key
-        elif isinstance(key, tuple):
-            if len(key) != 2:
-                raise Exception('only length 2 tuple supported')
-            x, y = key
-            return frame._fancy_setitem_tuple(x, y, value)
-        elif _is_list_like(key):
-            return frame._fancy_setitem(key, value, axis=0)
-        else:
-            return frame._fancy_setitem_axis(key, value, axis=0)
-
-    def _convert_indexer(self, obj):
-        if isinstance(obj, slice):
-            return obj
-        elif _is_list_like(key):
-            pass
-
-    def _fancy_getitem_tuple(self, rowkey, colkey):
-        # to avoid wasted computation
-        # df.ix[d1:d2, 0] -> columns first (True)
-        # df.ix[0, ['C', 'B', A']] -> rows first (False)
-        if _is_label_like(colkey):
-            return self._fancy_getitem_axis(colkey, axis=1).ix[rowkey]
-        elif _is_label_like(rowkey):
-            return self._fancy_getitem_axis(rowkey, axis=0).ix[colkey]
-
-        result = self._fancy_getitem_axis(colkey, axis=1)
-        return result.ix[rowkey]
-
-    def _fancy_setitem_tuple(self, rowkey, colkey, value):
-        pass
-
-    def _fancy_getitem_axis(self, key, axis=0):
-        if isinstance(key, slice):
-            return self._get_slice_axis(key, axis=axis)
-        elif _is_list_like(key):
-            return self._fancy_getitem(key, axis=axis)
-        elif axis == 0:
-            idx = key
-            if isinstance(key, int):
-                idx = self.frame.index[key]
-
-            if self.frame._is_mixed_type:
-                return self.frame.xs(idx)
-            else:
-                return self.frame.xs(idx, copy=False)
-        else:
-            col = key
-            if isinstance(key, int):
-                col = self.frame.columns[key]
-
-            return self.frame[col]
-
-    def _fancy_setitem_axis(self, key, value, axis=0):
-        pass
-
-    def _fancy_getitem(self, key, axis=0):
-        labels = self.frame._get_axis(axis)
-        axis_name = self.frame._get_axis_name(axis)
-
-        # asarray can be unsafe, NumPy strings are weird
-        isbool = np.asarray(key).dtype == np.bool_
-        if isbool:
-            if isinstance(key, Series):
-                if not key.index.equals(labels):
-                    raise Exception('Cannot use boolean index with misaligned '
-                                    'or unequal labels')
-            return self.frame.reindex(**{axis_name : labels[key]})
-        else:
-            return self.frame.reindex(**{axis_name : key})
-
-    def _fancy_setitem(self, key, value, axis=0):
-        pass
-
-    def _get_slice_axis(self, slice_obj, axis=0):
-        _check_step(slice_obj)
-
-        frame = self.frame
-
-        axis_name = frame._get_axis_name(axis)
-        labels = getattr(frame, axis_name)
-        if _is_label_slice(labels, slice_obj):
-            i, j = labels.slice_locs(slice_obj.start, slice_obj.stop)
-            slicer = slice(i, j)
-        else:
-            slicer = slice_obj
-
-        if not _need_slice(slice_obj):
-            return frame
-        if axis == 0:
-            new_index = frame.index[slicer]
-            new_columns = frame.columns
-            new_values = frame.values[slicer]
-        else:
-            new_index = frame.index
-            new_columns = frame.columns[slicer]
-            new_values = frame.values[:, slicer]
-        return DataFrame(new_values, index=new_index,
-                         columns=new_columns)
-
 def extract_index(data):
     def _union_if(index, new_index):
         if index is None:
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
new file mode 100644
index 000000000..c23a54a8b
--- /dev/null
+++ b/pandas/core/indexing.py
@@ -0,0 +1,235 @@
+import numpy as np
+
+from pandas.core.frame import DataFrame
+from pandas.core.series import Series
+
+class _SeriesIndexer(object):
+    """
+    Class to support fancy indexing, potentially using labels
+
+    Notes
+    -----
+    Indexing based on labels is INCLUSIVE
+    Slicing uses PYTHON SEMANTICS (endpoint is excluded)
+
+    If Index contains int labels, these will be used rather than the locations,
+    so be very careful (ambiguous).
+
+    Examples
+    --------
+    >>> ts.ix[5:10] # equivalent to ts[5:10]
+    >>> ts.ix[[date1, date2, date3]]
+    >>> ts.ix[date1:date2] = 0
+    """
+    def __init__(self, series):
+        self.series = series
+
+    def __getitem__(self, key):
+        op = self._fancy_index(key, operation='get')
+        return op()
+
+    def __setitem__(self, key, value):
+        op = self._fancy_index(key, value, operation='set')
+        op()
+
+    def _fancy_index(self, key, value=None, operation='get'):
+        # going to great lengths to avoid code dup
+        series = self.series
+
+        if operation == 'get':
+            def do_default():
+                return series[key]
+
+            def do_list_like():
+                return series.reindex(key)
+        else:
+            def do_default():
+                series[key] = value
+
+            def do_list_like():
+                inds, mask = series.index.get_indexer(key)
+                if not mask.all():
+                    raise Exception('Indices %s not found' % key[-mask])
+                series.put(inds, value)
+        op = do_default
+        if _isboolarr(key):
+            if isinstance(key, Series):
+                if not key.index.equals(series.index):
+                    raise Exception('Cannot use boolean index with misaligned '
+                                    'or unequal labels')
+        elif isinstance(key, slice):
+            if _is_label_slice(series.index, key):
+                i, j = series.index.slice_locs(key.start, key.stop)
+                key = slice(i, j)
+        elif _is_list_like(key):
+            op = do_list_like
+        return op
+
+
+class AmbiguousIndexError(Exception):
+    pass
+
+class _DataFrameIndexer(object):
+    """
+    Class to support fancy indexing, potentially using labels of DataFrame
+
+    Notes
+    -----
+    Indexing based on labels is INCLUSIVE
+    Slicing uses PYTHON SEMANTICS (endpoint is excluded)
+
+    If Index contains int labels, these will be used rather than the locations,
+    so be very careful (ambiguous).
+
+    Examples
+    --------
+    >>> frame.ix[5:10, ['A', 'B']]
+    >>> frame.ix[date1:date2, 'A']
+    """
+
+    def __init__(self, frame):
+        self.frame = frame
+
+    def __getitem__(self, key):
+        frame = self.frame
+        if isinstance(key, slice):
+            return self._fancy_getitem_axis(key, axis=0)
+        elif isinstance(key, tuple):
+            if len(key) != 2:
+                raise Exception('only length 2 tuple supported')
+            return self._fancy_getitem_tuple(*key)
+        elif _is_list_like(key):
+            return self._fancy_getitem(key, axis=0)
+        else:
+            return self._fancy_getitem_axis(key, axis=0)
+
+    def __setitem__(self, key, value):
+        # also has the side effect of consolidating in-place
+        if self.frame._is_mixed_type:
+            raise Exception('setting on mixed-type frames not yet supported')
+
+        frame = self.frame
+        if isinstance(key, slice):
+            return key
+        elif isinstance(key, tuple):
+            if len(key) != 2:
+                raise Exception('only length 2 tuple supported')
+            x, y = key
+            return frame._fancy_setitem_tuple(x, y, value)
+        elif _is_list_like(key):
+            return frame._fancy_setitem(key, value, axis=0)
+        else:
+            return frame._fancy_setitem_axis(key, value, axis=0)
+
+    def _convert_indexer(self, obj):
+        if isinstance(obj, slice):
+            return obj
+        elif _is_list_like(key):
+            pass
+
+    def _fancy_getitem_tuple(self, rowkey, colkey):
+        # to avoid wasted computation
+        # df.ix[d1:d2, 0] -> columns first (True)
+        # df.ix[0, ['C', 'B', A']] -> rows first (False)
+        if _is_label_like(colkey):
+            return self._fancy_getitem_axis(colkey, axis=1).ix[rowkey]
+        elif _is_label_like(rowkey):
+            return self._fancy_getitem_axis(rowkey, axis=0).ix[colkey]
+
+        result = self._fancy_getitem_axis(colkey, axis=1)
+        return result.ix[rowkey]
+
+    def _fancy_setitem_tuple(self, rowkey, colkey, value):
+        pass
+
+    def _fancy_getitem_axis(self, key, axis=0):
+        if isinstance(key, slice):
+            return self._get_slice_axis(key, axis=axis)
+        elif _is_list_like(key):
+            return self._fancy_getitem(key, axis=axis)
+        elif axis == 0:
+            idx = key
+            if isinstance(key, int):
+                idx = self.frame.index[key]
+
+            if self.frame._is_mixed_type:
+                return self.frame.xs(idx)
+            else:
+                return self.frame.xs(idx, copy=False)
+        else:
+            col = key
+            if isinstance(key, int):
+                col = self.frame.columns[key]
+
+            return self.frame[col]
+
+    def _fancy_setitem_axis(self, key, value, axis=0):
+        pass
+
+    def _fancy_getitem(self, key, axis=0):
+        labels = self.frame._get_axis(axis)
+        axis_name = self.frame._get_axis_name(axis)
+
+        # asarray can be unsafe, NumPy strings are weird
+        isbool = np.asarray(key).dtype == np.bool_
+        if isbool:
+            if isinstance(key, Series):
+                if not key.index.equals(labels):
+                    raise Exception('Cannot use boolean index with misaligned '
+                                    'or unequal labels')
+            return self.frame.reindex(**{axis_name : labels[key]})
+        else:
+            return self.frame.reindex(**{axis_name : key})
+
+    def _fancy_setitem(self, key, value, axis=0):
+        pass
+
+    def _get_slice_axis(self, slice_obj, axis=0):
+        _check_step(slice_obj)
+
+        frame = self.frame
+
+        axis_name = frame._get_axis_name(axis)
+        labels = getattr(frame, axis_name)
+        if _is_label_slice(labels, slice_obj):
+            i, j = labels.slice_locs(slice_obj.start, slice_obj.stop)
+            slicer = slice(i, j)
+        else:
+            slicer = slice_obj
+
+        if not _need_slice(slice_obj):
+            return frame
+        if axis == 0:
+            new_index = frame.index[slicer]
+            new_columns = frame.columns
+            new_values = frame.values[slicer]
+        else:
+            new_index = frame.index
+            new_columns = frame.columns[slicer]
+            new_values = frame.values[:, slicer]
+        return DataFrame(new_values, index=new_index,
+                         columns=new_columns)
+
+def _is_label_like(key):
+    # select a label or row
+    return not isinstance(key, slice) and not _is_list_like(key)
+
+def _is_list_like(obj):
+    return isinstance(obj, (list, np.ndarray))
+
+def _is_label_slice(labels, obj):
+    def crit(x):
+        if x in labels:
+            return False
+        else:
+            return isinstance(x, int) or x is None
+    return not crit(obj.start) or not crit(obj.stop)
+
+def _need_slice(obj):
+    return obj.start is not None or obj.stop is not None
+
+def _check_step(obj):
+    if obj.step is not None and obj.step != 1:
+        raise Exception('steps other than 1 are not supported')
+
+_isboolarr = lambda x: np.asarray(x).dtype == np.bool_
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 6ed37eed8..fbc0f3972 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1422,6 +1422,8 @@ class Series(np.ndarray, PandasGeneric):
     _ix = None
     @property
     def ix(self):
+        from pandas.core.indexing import _SeriesIndexer
+
         if self._ix is None:
             self._ix = _SeriesIndexer(self)
 
@@ -1430,76 +1432,11 @@ class Series(np.ndarray, PandasGeneric):
 class TimeSeries(Series):
     pass
 
-
-class _SeriesIndexer(object):
-    """
-    Class to support fancy indexing, potentially using labels
-
-    Notes
-    -----
-    Indexing based on labels is INCLUSIVE
-    Slicing uses PYTHON SEMANTICS (endpoint is excluded)
-
-    If Index contains int labels, these will be used rather than the locations,
-    so be very careful (ambiguous).
-
-    Examples
-    --------
-    >>> ts.ix[5:10] # equivalent to ts[5:10]
-    >>> ts.ix[[date1, date2, date3]]
-    >>> ts.ix[date1:date2] = 0
-    """
-    def __init__(self, series):
-        self.series = series
-
-    def __getitem__(self, key):
-        op = self._fancy_index(key, operation='get')
-        return op()
-
-    def __setitem__(self, key, value):
-        op = self._fancy_index(key, value, operation='set')
-        op()
-
-    def _fancy_index(self, key, value=None, operation='get'):
-        # going to great lengths to avoid code dup
-        series = self.series
-
-        if operation == 'get':
-            def do_default():
-                return series[key]
-
-            def do_list_like():
-                return series.reindex(key)
-        else:
-            def do_default():
-                series[key] = value
-
-            def do_list_like():
-                inds, mask = series.index.get_indexer(key)
-                if not mask.all():
-                    raise Exception('Indices %s not found' % key[-mask])
-                series.put(inds, value)
-        op = do_default
-        if _isboolarr(key):
-            if isinstance(key, Series):
-                if not key.index.equals(series.index):
-                    raise Exception('Cannot use boolean index with misaligned '
-                                    'or unequal labels')
-        elif isinstance(key, slice):
-            if _is_label_slice(series.index, key):
-                i, j = series.index.slice_locs(key.start, key.stop)
-                key = slice(i, j)
-        elif _is_list_like(key):
-            op = do_list_like
-        return op
-
 #-------------------------------------------------------------------------------
 # Supplementary functions
 
 _ndgi = ndarray.__getitem__
 
-_isboolarr = lambda x: np.asarray(x).dtype == np.bool_
-
 def remove_na(arr):
     """
     Return array containing only true/non-NaN values, possibly empty.

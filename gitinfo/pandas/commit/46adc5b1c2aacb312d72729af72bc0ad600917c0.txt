commit 46adc5b1c2aacb312d72729af72bc0ad600917c0
Author: Joris Van den Bossche <jorisvandenbossche@gmail.com>
Date:   Mon Jul 1 10:57:41 2019 -0500

    DEPR: deprecate get_values (#26409)

diff --git a/doc/source/whatsnew/v0.25.0.rst b/doc/source/whatsnew/v0.25.0.rst
index 1390e6017..3b2375921 100644
--- a/doc/source/whatsnew/v0.25.0.rst
+++ b/doc/source/whatsnew/v0.25.0.rst
@@ -615,6 +615,9 @@ Other deprecations
   Use the public attributes :attr:`~RangeIndex.start`, :attr:`~RangeIndex.stop` and :attr:`~RangeIndex.step` instead (:issue:`26581`).
 - The :meth:`Series.ftype`, :meth:`Series.ftypes` and :meth:`DataFrame.ftypes` methods are deprecated and will be removed in a future version.
   Instead, use :meth:`Series.dtype` and :meth:`DataFrame.dtypes` (:issue:`26705`).
+- The :meth:`Series.get_values`, :meth:`DataFrame.get_values`, :meth:`Index.get_values`,
+  :meth:`SparseArray.get_values` and :meth:`Categorical.get_values` methods are deprecated.
+  One of ``np.asarray(..)`` or :meth:`~Series.to_numpy` can be used instead (:issue:`19617`).
 - :meth:`Timedelta.resolution` is deprecated and replaced with :meth:`Timedelta.resolution_string`.  In a future version, :meth:`Timedelta.resolution` will be changed to behave like the standard library :attr:`timedelta.resolution` (:issue:`21344`)
 - :func:`read_table` has been undeprecated. (:issue:`25220`)
 - :attr:`Index.dtype_str` is deprecated. (:issue:`18262`)
diff --git a/pandas/_libs/lib.pyx b/pandas/_libs/lib.pyx
index c09fb96eb..990ac7c96 100644
--- a/pandas/_libs/lib.pyx
+++ b/pandas/_libs/lib.pyx
@@ -76,7 +76,10 @@ def values_from_object(obj: object):
     """ return my values or the object if we are say an ndarray """
     func: object
 
-    func = getattr(obj, 'get_values', None)
+    if getattr(obj, '_typ', '') == 'dataframe':
+        return obj.values
+
+    func = getattr(obj, '_internal_get_values', None)
     if func is not None:
         obj = func()
 
diff --git a/pandas/_libs/src/ujson/python/objToJSON.c b/pandas/_libs/src/ujson/python/objToJSON.c
index cc87d95bf..926440218 100644
--- a/pandas/_libs/src/ujson/python/objToJSON.c
+++ b/pandas/_libs/src/ujson/python/objToJSON.c
@@ -269,9 +269,19 @@ static PyObject *get_values(PyObject *obj) {
         }
     }
 
-    if (!values && PyObject_HasAttrString(obj, "get_values")) {
+    if (!values && PyObject_HasAttrString(obj, "_internal_get_values")) {
         PRINTMARK();
-        values = PyObject_CallMethod(obj, "get_values", NULL);
+        values = PyObject_CallMethod(obj, "_internal_get_values", NULL);
+        if (values && !PyArray_CheckExact(values)) {
+            PRINTMARK();
+            Py_DECREF(values);
+            values = NULL;
+        }
+    }
+
+    if (!values && PyObject_HasAttrString(obj, "get_block_values")) {
+        PRINTMARK();
+        values = PyObject_CallMethod(obj, "get_block_values", NULL);
         if (values && !PyArray_CheckExact(values)) {
             PRINTMARK();
             Py_DECREF(values);
diff --git a/pandas/core/algorithms.py b/pandas/core/algorithms.py
index 98daae076..4e84d7b26 100644
--- a/pandas/core/algorithms.py
+++ b/pandas/core/algorithms.py
@@ -1590,7 +1590,7 @@ def take_nd(arr, indexer, axis=0, out=None, fill_value=np.nan, mask_info=None,
         return arr.take(indexer, fill_value=fill_value, allow_fill=allow_fill)
 
     if is_sparse(arr):
-        arr = arr.get_values()
+        arr = arr.to_dense()
     elif isinstance(arr, (ABCIndexClass, ABCSeries)):
         arr = arr.values
 
diff --git a/pandas/core/arrays/categorical.py b/pandas/core/arrays/categorical.py
index 3ef2f41f2..68c7b79be 100644
--- a/pandas/core/arrays/categorical.py
+++ b/pandas/core/arrays/categorical.py
@@ -1483,6 +1483,8 @@ class Categorical(ExtensionArray, PandasObject):
         """
         Return the values.
 
+        .. deprecated:: 0.25.0
+
         For internal compatibility with pandas formatting.
 
         Returns
@@ -1491,6 +1493,11 @@ class Categorical(ExtensionArray, PandasObject):
             A numpy array of the same dtype as categorical.categories.dtype or
             Index if datetime / periods.
         """
+        warn("The 'get_values' method is deprecated and will be removed in a "
+             "future version", FutureWarning, stacklevel=2)
+        return self._internal_get_values()
+
+    def _internal_get_values(self):
         # if we are a datetime and period index, return Index to keep metadata
         if is_datetimelike(self.categories):
             return self.categories.take(self._codes, fill_value=np.nan)
@@ -1923,7 +1930,7 @@ class Categorical(ExtensionArray, PandasObject):
         """
         Returns an Iterator over the values of this Categorical.
         """
-        return iter(self.get_values().tolist())
+        return iter(self._internal_get_values().tolist())
 
     def __contains__(self, key):
         """
diff --git a/pandas/core/arrays/sparse.py b/pandas/core/arrays/sparse.py
index 3512d4e9e..97ab6ec82 100644
--- a/pandas/core/arrays/sparse.py
+++ b/pandas/core/arrays/sparse.py
@@ -454,7 +454,7 @@ def _sparse_array_op(
 
     if left.sp_index.ngaps == 0 or right.sp_index.ngaps == 0:
         with np.errstate(all='ignore'):
-            result = op(left.get_values(), right.get_values())
+            result = op(left.to_dense(), right.to_dense())
             fill = op(_get_fill(left), _get_fill(right))
 
         if left.sp_index.ngaps == 0:
@@ -1468,8 +1468,21 @@ class SparseArray(PandasObject, ExtensionArray, ExtensionOpsMixin):
         """
         return np.asarray(self, dtype=self.sp_values.dtype)
 
-    # TODO: Look into deprecating this in favor of `to_dense`.
-    get_values = to_dense
+    def get_values(self):
+        """
+        Convert SparseArray to a NumPy array.
+
+        .. deprecated:: 0.25.0
+            Use `to_dense` instead.
+
+        """
+        warnings.warn(
+            "The 'get_values' method is deprecated and will be removed in a "
+            "future version. Use the 'to_dense' method instead.",
+            FutureWarning, stacklevel=2)
+        return self._internal_get_values()
+
+    _internal_get_values = to_dense
 
     # ------------------------------------------------------------------------
     # IO
diff --git a/pandas/core/dtypes/concat.py b/pandas/core/dtypes/concat.py
index 242885c7a..66f7a6365 100644
--- a/pandas/core/dtypes/concat.py
+++ b/pandas/core/dtypes/concat.py
@@ -194,7 +194,7 @@ def _concat_categorical(to_concat, axis=0):
             return union_categoricals(categoricals)
 
     # extract the categoricals & coerce to object if needed
-    to_concat = [x.get_values() if is_categorical_dtype(x.dtype)
+    to_concat = [x._internal_get_values() if is_categorical_dtype(x.dtype)
                  else np.asarray(x).ravel() if not is_datetime64tz_dtype(x)
                  else np.asarray(x.astype(object)) for x in to_concat]
     result = _concat_compat(to_concat)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index d7da65361..3ff3fff22 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1616,7 +1616,8 @@ class DataFrame(NDFrame):
                 else:
                     ix_vals = [self.index.values]
 
-            arrays = ix_vals + [self[c].get_values() for c in self.columns]
+            arrays = ix_vals + [self[c]._internal_get_values()
+                                for c in self.columns]
 
             count = 0
             index_names = list(self.index.names)
@@ -1632,7 +1633,7 @@ class DataFrame(NDFrame):
             names = [str(name) for name in itertools.chain(index_names,
                                                            self.columns)]
         else:
-            arrays = [self[c].get_values() for c in self.columns]
+            arrays = [self[c]._internal_get_values() for c in self.columns]
             names = [str(c) for c in self.columns]
             index_names = []
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 841131b69..957efa402 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -5220,6 +5220,9 @@ class NDFrame(PandasObject, SelectionMixin):
         """
         Return an ndarray after converting sparse values to dense.
 
+        .. deprecated:: 0.25.0
+            Use ``np.asarray(..)`` or :meth:`DataFrame.values` instead.
+
         This is the same as ``.values`` for non-sparse data. For sparse
         data contained in a `SparseArray`, the data are first
         converted to a dense representation.
@@ -5259,6 +5262,13 @@ class NDFrame(PandasObject, SelectionMixin):
                [nan,  2.],
                [nan,  3.]])
         """
+        warnings.warn(
+            "The 'get_values' method is deprecated and will be removed in a "
+            "future version. Use '.values' or 'np.asarray(..)' instead.",
+            FutureWarning, stacklevel=2)
+        return self._internal_get_values()
+
+    def _internal_get_values(self):
         return self.values
 
     def get_dtype_counts(self):
diff --git a/pandas/core/groupby/generic.py b/pandas/core/groupby/generic.py
index 72c8d3301..210e82837 100644
--- a/pandas/core/groupby/generic.py
+++ b/pandas/core/groupby/generic.py
@@ -1118,7 +1118,7 @@ class SeriesGroupBy(GroupBy):
         """
         ids, _, _ = self.grouper.group_info
 
-        val = self.obj.get_values()
+        val = self.obj._internal_get_values()
 
         try:
             sorter = np.lexsort((val, ids))
@@ -1192,7 +1192,7 @@ class SeriesGroupBy(GroupBy):
                               bins=bins)
 
         ids, _, _ = self.grouper.group_info
-        val = self.obj.get_values()
+        val = self.obj._internal_get_values()
 
         # groupby removes null keys from groupings
         mask = ids != -1
@@ -1306,7 +1306,7 @@ class SeriesGroupBy(GroupBy):
             Count of values within each group.
         """
         ids, _, ngroups = self.grouper.group_info
-        val = self.obj.get_values()
+        val = self.obj._internal_get_values()
 
         mask = (ids != -1) & ~isna(val)
         ids = ensure_platform_int(ids)
diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index 13e672cbc..0123e6a5f 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -3764,6 +3764,9 @@ class Index(IndexOpsMixin, PandasObject):
         """
         Return `Index` data as an `numpy.ndarray`.
 
+        .. deprecated:: 0.25.0
+            Use :meth:`Index.to_numpy` or :attr:`Index.array` instead.
+
         Returns
         -------
         numpy.ndarray
@@ -3802,6 +3805,13 @@ class Index(IndexOpsMixin, PandasObject):
         >>> midx.get_values().ndim
         1
         """
+        warnings.warn(
+            "The 'get_values' method is deprecated and will be removed in a "
+            "future version. Use '.to_numpy()' or '.array' instead.",
+            FutureWarning, stacklevel=2)
+        return self._internal_get_values()
+
+    def _internal_get_values(self):
         return self.values
 
     @Appender(IndexOpsMixin.memory_usage.__doc__)
diff --git a/pandas/core/indexes/category.py b/pandas/core/indexes/category.py
index 3d3774ce4..db4778f5e 100644
--- a/pandas/core/indexes/category.py
+++ b/pandas/core/indexes/category.py
@@ -355,9 +355,10 @@ class CategoricalIndex(Index, accessor.PandasDelegate):
         name = get_op_result_name(self, other)
         return self._shallow_copy(result, name=name)
 
-    def get_values(self):
-        """ return the underlying data as an ndarray """
-        return self._data.get_values()
+    def _internal_get_values(self):
+        # override base Index version to get the numpy array representation of
+        # the underlying Categorical
+        return self._data._internal_get_values()
 
     def tolist(self):
         return self._data.tolist()
diff --git a/pandas/core/indexes/multi.py b/pandas/core/indexes/multi.py
index a06d304fb..19ba147fe 100644
--- a/pandas/core/indexes/multi.py
+++ b/pandas/core/indexes/multi.py
@@ -1246,7 +1246,7 @@ class MultiIndex(Index):
         for i in range(self.nlevels):
             vals = self._get_level_values(i)
             if is_categorical_dtype(vals):
-                vals = vals.get_values()
+                vals = vals._internal_get_values()
             if (isinstance(vals.dtype, ExtensionDtype)
                     or hasattr(vals, '_box_values')):
                 vals = vals.astype(object)
diff --git a/pandas/core/internals/blocks.py b/pandas/core/internals/blocks.py
index 36390d467..b79f87461 100644
--- a/pandas/core/internals/blocks.py
+++ b/pandas/core/internals/blocks.py
@@ -177,6 +177,12 @@ class Block(PandasObject):
             return self.values.astype(object)
         return self.values
 
+    def get_block_values(self, dtype=None):
+        """
+        This is used in the JSON C code
+        """
+        return self.get_values(dtype=dtype)
+
     def to_dense(self):
         return self.values.view()
 
@@ -2921,7 +2927,7 @@ class CategoricalBlock(ExtensionBlock):
         # Categorical.get_values returns a DatetimeIndex for datetime
         # categories, so we can't simply use `np.asarray(self.values)` like
         # other types.
-        return self.values.get_values()
+        return self.values._internal_get_values()
 
     def to_native_types(self, slicer=None, na_rep='', quoting=None, **kwargs):
         """ convert to our native types format, slicing if desired """
@@ -3222,7 +3228,7 @@ def _putmask_smart(v, m, n):
     dtype, _ = maybe_promote(n.dtype)
 
     if is_extension_type(v.dtype) and is_object_dtype(dtype):
-        v = v.get_values(dtype)
+        v = v._internal_get_values(dtype)
     else:
         v = v.astype(dtype)
 
diff --git a/pandas/core/ops.py b/pandas/core/ops.py
index 0b9e56fd1..a4d31cb22 100644
--- a/pandas/core/ops.py
+++ b/pandas/core/ops.py
@@ -1891,7 +1891,7 @@ def _comp_method_SERIES(cls, op, special):
                                      name=res_name, dtype='bool')
 
         else:
-            values = self.get_values()
+            values = self.to_numpy()
 
             with np.errstate(all='ignore'):
                 res = na_op(values, other)
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 3d54fa448..f415bc9fd 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -506,11 +506,21 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         """
         Same as values (but handles sparseness conversions); is a view.
 
+        .. deprecated:: 0.25.0
+            Use :meth:`Series.to_numpy` or :attr:`Series.array` instead.
+
         Returns
         -------
         numpy.ndarray
             Data of the Series.
         """
+        warnings.warn(
+            "The 'get_values' method is deprecated and will be removed in a "
+            "future version. Use '.to_numpy()' or '.array' instead.",
+            FutureWarning, stacklevel=2)
+        return self._internal_get_values()
+
+    def _internal_get_values(self):
         return self._data.get_values()
 
     @property
diff --git a/pandas/core/sparse/frame.py b/pandas/core/sparse/frame.py
index 67ecbcbea..6a0ba5f93 100644
--- a/pandas/core/sparse/frame.py
+++ b/pandas/core/sparse/frame.py
@@ -493,7 +493,7 @@ class SparseDataFrame(DataFrame):
             return data
 
         i = self.index.get_loc(key)
-        data = self.take([i]).get_values()[0]
+        data = self.take([i])._internal_get_values()[0]
         return Series(data, index=self.columns)
 
     # ----------------------------------------------------------------------
@@ -694,9 +694,10 @@ class SparseDataFrame(DataFrame):
             if col not in self:
                 continue
             if row_indexer is not None:
-                new_arrays[col] = algos.take_1d(self[col].get_values(),
-                                                row_indexer,
-                                                fill_value=fill_value)
+                new_arrays[col] = algos.take_1d(
+                    self[col]._internal_get_values(),
+                    row_indexer,
+                    fill_value=fill_value)
             else:
                 new_arrays[col] = self[col]
 
diff --git a/pandas/core/sparse/series.py b/pandas/core/sparse/series.py
index 2e740c0ac..88b6634db 100644
--- a/pandas/core/sparse/series.py
+++ b/pandas/core/sparse/series.py
@@ -224,7 +224,7 @@ class SparseSeries(Series):
     def _reduce(self, op, name, axis=0, skipna=True, numeric_only=None,
                 filter_type=None, **kwds):
         """ perform a reduction operation """
-        return op(self.get_values(), skipna=skipna, **kwds)
+        return op(self.array.to_dense(), skipna=skipna, **kwds)
 
     def __getstate__(self):
         # pickling
diff --git a/pandas/io/formats/format.py b/pandas/io/formats/format.py
index c709ff876..3f98fc235 100644
--- a/pandas/io/formats/format.py
+++ b/pandas/io/formats/format.py
@@ -129,7 +129,7 @@ class CategoricalFormatter:
         return str(footer)
 
     def _get_formatted_values(self):
-        return format_array(self.categorical.get_values(), None,
+        return format_array(self.categorical._internal_get_values(), None,
                             float_format=None, na_rep=self.na_rep)
 
     def to_string(self):
@@ -1196,7 +1196,7 @@ class ExtensionArrayFormatter(GenericArrayFormatter):
 
         if is_categorical_dtype(values.dtype):
             # Categorical is special for now, so that we can preserve tzinfo
-            array = values.get_values()
+            array = values._internal_get_values()
         else:
             array = np.asarray(values)
 
diff --git a/pandas/tests/arrays/categorical/test_api.py b/pandas/tests/arrays/categorical/test_api.py
index 4be3919f1..d2f63268e 100644
--- a/pandas/tests/arrays/categorical/test_api.py
+++ b/pandas/tests/arrays/categorical/test_api.py
@@ -243,7 +243,7 @@ class TestCategoricalAPI:
         tm.assert_index_equal(c.categories, Index([1, 2, 3, 4]))
 
         exp = np.array([1, 2, 3, 4, 1], dtype=np.int64)
-        tm.assert_numpy_array_equal(c.get_values(), exp)
+        tm.assert_numpy_array_equal(c.to_dense(), exp)
 
         # all "pointers" to '4' must be changed from 3 to 0,...
         c = c.set_categories([4, 3, 2, 1])
@@ -257,7 +257,7 @@ class TestCategoricalAPI:
 
         # output is the same
         exp = np.array([1, 2, 3, 4, 1], dtype=np.int64)
-        tm.assert_numpy_array_equal(c.get_values(), exp)
+        tm.assert_numpy_array_equal(c.to_dense(), exp)
         assert c.min() == 4
         assert c.max() == 1
 
@@ -265,13 +265,13 @@ class TestCategoricalAPI:
         c2 = c.set_categories([4, 3, 2, 1], ordered=False)
         assert not c2.ordered
 
-        tm.assert_numpy_array_equal(c.get_values(), c2.get_values())
+        tm.assert_numpy_array_equal(c.to_dense(), c2.to_dense())
 
         # set_categories should pass thru the ordering
         c2 = c.set_ordered(False).set_categories([4, 3, 2, 1])
         assert not c2.ordered
 
-        tm.assert_numpy_array_equal(c.get_values(), c2.get_values())
+        tm.assert_numpy_array_equal(c.to_dense(), c2.to_dense())
 
     @pytest.mark.parametrize('values, categories, new_categories', [
         # No NaNs, same cats, same order
@@ -378,7 +378,7 @@ class TestCategoricalAPI:
         tm.assert_index_equal(out.categories, Index(['B', 'D', 'F']))
         exp_codes = np.array([2, -1, 1, 0, 1, 2, -1], dtype=np.int8)
         tm.assert_numpy_array_equal(out.codes, exp_codes)
-        assert out.get_values().tolist() == val
+        assert out.tolist() == val
 
         alpha = list('abcdefghijklmnopqrstuvwxyz')
         val = np.random.choice(alpha[::2], 10000).astype('object')
@@ -386,7 +386,7 @@ class TestCategoricalAPI:
 
         cat = Categorical(values=val, categories=alpha)
         out = cat.remove_unused_categories()
-        assert out.get_values().tolist() == val.tolist()
+        assert out.tolist() == val.tolist()
 
 
 class TestCategoricalAPIWithFactor(TestCategorical):
@@ -499,3 +499,9 @@ class TestPrivateCategoricalAPI:
         new = Index(expected)
         result = _recode_for_categories(codes, old, new)
         tm.assert_numpy_array_equal(result, expected)
+
+    def test_deprecated_get_values(self):
+        cat = Categorical(["a", "b", "c", "a"])
+        with tm.assert_produces_warning(FutureWarning):
+            res = cat.get_values()
+        tm.assert_numpy_array_equal(res, np.array(cat))
diff --git a/pandas/tests/arrays/sparse/test_array.py b/pandas/tests/arrays/sparse/test_array.py
index fbf86f66e..8a5170473 100644
--- a/pandas/tests/arrays/sparse/test_array.py
+++ b/pandas/tests/arrays/sparse/test_array.py
@@ -615,16 +615,19 @@ class TestSparseArray:
         [1, np.nan, np.nan, 3, np.nan],
         [1, np.nan, 0, 3, 0],
     ])
-    @pytest.mark.parametrize("method", ["to_dense", "get_values"])
     @pytest.mark.parametrize("fill_value", [None, 0])
-    def test_dense_repr(self, vals, fill_value, method):
+    def test_dense_repr(self, vals, fill_value):
         vals = np.array(vals)
         arr = SparseArray(vals, fill_value=fill_value)
-        dense_func = getattr(arr, method)
 
-        res = dense_func()
+        res = arr.to_dense()
         tm.assert_numpy_array_equal(res, vals)
 
+        with tm.assert_produces_warning(FutureWarning):
+            res2 = arr.get_values()
+
+        tm.assert_numpy_array_equal(res2, vals)
+
     def test_getitem(self):
         def _checkit(i):
             assert_almost_equal(self.arr[i], self.arr.to_dense()[i])
diff --git a/pandas/tests/frame/test_api.py b/pandas/tests/frame/test_api.py
index ce841b302..ed224e23f 100644
--- a/pandas/tests/frame/test_api.py
+++ b/pandas/tests/frame/test_api.py
@@ -547,3 +547,9 @@ class TestDataFrameMisc(SharedWithSparse):
         with tm.assert_produces_warning(None):
             with provisionalcompleter('ignore'):
                 list(ip.Completer.completions('df.', 1))
+
+    def test_get_values_deprecated(self):
+        df = DataFrame({'a': [1, 2], 'b': [.1, .2]})
+        with tm.assert_produces_warning(FutureWarning):
+            res = df.get_values()
+        tm.assert_numpy_array_equal(res, df.values)
diff --git a/pandas/tests/frame/test_reshape.py b/pandas/tests/frame/test_reshape.py
index a3b9e5294..ac8d1557a 100644
--- a/pandas/tests/frame/test_reshape.py
+++ b/pandas/tests/frame/test_reshape.py
@@ -804,7 +804,7 @@ class TestDataFrameReshape(TestData):
                     else:
                         assert_frame_equal(result, expected)
 
-                df.columns = MultiIndex.from_tuples(df.columns.get_values(),
+                df.columns = MultiIndex.from_tuples(df.columns.to_numpy(),
                                                     names=df.columns.names)
                 expected = df.stack(level=level, dropna=False)
                 if isinstance(expected, Series):
diff --git a/pandas/tests/indexes/multi/test_analytics.py b/pandas/tests/indexes/multi/test_analytics.py
index 5ac73a3c5..f886d78da 100644
--- a/pandas/tests/indexes/multi/test_analytics.py
+++ b/pandas/tests/indexes/multi/test_analytics.py
@@ -20,7 +20,7 @@ def test_shift(idx):
 
 def test_groupby(idx):
     groups = idx.groupby(np.array([1, 1, 1, 2, 2, 2]))
-    labels = idx.get_values().tolist()
+    labels = idx.tolist()
     exp = {1: labels[:3], 2: labels[3:]}
     tm.assert_dict_equal(groups, exp)
 
diff --git a/pandas/tests/indexes/period/test_period.py b/pandas/tests/indexes/period/test_period.py
index a70f67557..b33982f3d 100644
--- a/pandas/tests/indexes/period/test_period.py
+++ b/pandas/tests/indexes/period/test_period.py
@@ -164,7 +164,9 @@ class TestPeriodIndex(DatetimeLike):
 
         exp = np.array([], dtype=np.object)
         tm.assert_numpy_array_equal(idx.values, exp)
-        tm.assert_numpy_array_equal(idx.get_values(), exp)
+        tm.assert_numpy_array_equal(idx.to_numpy(), exp)
+        with tm.assert_produces_warning(FutureWarning):
+            tm.assert_numpy_array_equal(idx.get_values(), exp)
         exp = np.array([], dtype=np.int64)
         tm.assert_numpy_array_equal(idx._ndarray_values, exp)
 
@@ -172,7 +174,7 @@ class TestPeriodIndex(DatetimeLike):
 
         exp = np.array([pd.Period('2011-01', freq='M'), pd.NaT], dtype=object)
         tm.assert_numpy_array_equal(idx.values, exp)
-        tm.assert_numpy_array_equal(idx.get_values(), exp)
+        tm.assert_numpy_array_equal(idx.to_numpy(), exp)
         exp = np.array([492, -9223372036854775808], dtype=np.int64)
         tm.assert_numpy_array_equal(idx._ndarray_values, exp)
 
@@ -181,7 +183,7 @@ class TestPeriodIndex(DatetimeLike):
         exp = np.array([pd.Period('2011-01-01', freq='D'), pd.NaT],
                        dtype=object)
         tm.assert_numpy_array_equal(idx.values, exp)
-        tm.assert_numpy_array_equal(idx.get_values(), exp)
+        tm.assert_numpy_array_equal(idx.to_numpy(), exp)
         exp = np.array([14975, -9223372036854775808], dtype=np.int64)
         tm.assert_numpy_array_equal(idx._ndarray_values, exp)
 
diff --git a/pandas/tests/indexing/multiindex/test_slice.py b/pandas/tests/indexing/multiindex/test_slice.py
index 3394c4c06..2431f27bf 100644
--- a/pandas/tests/indexing/multiindex/test_slice.py
+++ b/pandas/tests/indexing/multiindex/test_slice.py
@@ -21,7 +21,7 @@ class TestMultiIndexSlicers:
         # example test case
         ix = MultiIndex.from_product([_mklbl('A', 5), _mklbl('B', 7), _mklbl(
             'C', 4), _mklbl('D', 2)])
-        df = DataFrame(np.arange(len(ix.get_values())), index=ix)
+        df = DataFrame(np.arange(len(ix.to_numpy())), index=ix)
 
         result = df.loc[(slice('A1', 'A3'), slice(None), ['C1', 'C3']), :]
         expected = df.loc[[tuple([a, b, c, d])
@@ -88,7 +88,7 @@ class TestMultiIndexSlicers:
         tm.assert_frame_equal(result, expected)
 
         # multi-level series
-        s = Series(np.arange(len(ix.get_values())), index=ix)
+        s = Series(np.arange(len(ix.to_numpy())), index=ix)
         result = s.loc['A1':'A3', :, ['C1', 'C3']]
         expected = s.loc[[tuple([a, b, c, d])
                           for a, b, c, d in s.index.values
diff --git a/pandas/tests/series/test_api.py b/pandas/tests/series/test_api.py
index 1cd5bd09a..71b0a2d9d 100644
--- a/pandas/tests/series/test_api.py
+++ b/pandas/tests/series/test_api.py
@@ -502,6 +502,12 @@ class TestSeriesMisc(TestData, SharedWithSparse):
         s = Series(range(9), dtype="Int64")
         assert s.size == 9
 
+    def test_get_values_deprecation(self):
+        s = Series(range(9))
+        with tm.assert_produces_warning(FutureWarning):
+            res = s.get_values()
+        tm.assert_numpy_array_equal(res, s.values)
+
 
 class TestCategoricalSeries:
 
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index 05e0a8df4..cec9416e5 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -1052,7 +1052,8 @@ def assert_series_equal(left, right, check_dtype=True,
             assert_attr_equal('dtype', left, right)
 
     if check_exact:
-        assert_numpy_array_equal(left.get_values(), right.get_values(),
+        assert_numpy_array_equal(left._internal_get_values(),
+                                 right._internal_get_values(),
                                  check_dtype=check_dtype,
                                  obj='{obj}'.format(obj=obj),)
     elif check_datetimelike_compat:
@@ -1071,11 +1072,11 @@ def assert_series_equal(left, right, check_dtype=True,
                        '{right}.').format(left=left.values, right=right.values)
                 raise AssertionError(msg)
         else:
-            assert_numpy_array_equal(left.get_values(), right.get_values(),
+            assert_numpy_array_equal(left._internal_get_values(),
+                                     right._internal_get_values(),
                                      check_dtype=check_dtype)
     elif is_interval_dtype(left) or is_interval_dtype(right):
         assert_interval_array_equal(left.array, right.array)
-
     elif (is_extension_array_dtype(left.dtype) and
           is_datetime64tz_dtype(left.dtype)):
         # .values is an ndarray, but ._values is the ExtensionArray.
@@ -1086,7 +1087,8 @@ def assert_series_equal(left, right, check_dtype=True,
           is_extension_array_dtype(right) and not is_categorical_dtype(right)):
         assert_extension_array_equal(left.array, right.array)
     else:
-        _testing.assert_almost_equal(left.get_values(), right.get_values(),
+        _testing.assert_almost_equal(left._internal_get_values(),
+                                     right._internal_get_values(),
                                      check_less_precise=check_less_precise,
                                      check_dtype=check_dtype,
                                      obj='{obj}'.format(obj=obj))

commit 9dc2bd08bedb2ee3972e1bec5d0c7c2188b1084c
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue May 8 18:52:19 2012 -0400

    ENH: special case reindexing both axes on homogeneous DataFrame for major speedup, vbenchmarks #836

diff --git a/pandas/core/common.py b/pandas/core/common.py
index f7e5d6069..7096e3204 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -163,11 +163,25 @@ _take2d_axis1_dict = {
                                      na_override=lib.NaT),
 }
 
+_take2d_multi_dict = {
+    'float64' : lib.take_2d_multi_float64,
+    'int32' : lib.take_2d_multi_int32,
+    'int64' : lib.take_2d_multi_int64,
+    'object' : lib.take_2d_multi_object,
+    'bool' : _view_wrapper(lib.take_2d_multi_bool, np.uint8),
+    'datetime64[us]' : _view_wrapper(lib.take_2d_multi_int64, np.int64,
+                                     na_override=lib.NaT),
+}
+
 def _get_take2d_function(dtype_str, axis=0):
     if axis == 0:
         return _take2d_axis0_dict[dtype_str]
-    else:
+    elif axis == 1:
         return _take2d_axis1_dict[dtype_str]
+    elif axis == 'multi':
+        return _take2d_multi_dict[dtype_str]
+    else:
+        raise ValueError('bad axis: %s' % axis)
 
 def take_1d(arr, indexer, out=None, fill_value=np.nan):
     """
@@ -219,6 +233,38 @@ def take_1d(arr, indexer, out=None, fill_value=np.nan):
 
     return out
 
+def take_2d_multi(arr, row_idx, col_idx, fill_value=np.nan):
+
+    dtype_str = arr.dtype.name
+
+    take_f = _get_take2d_function(dtype_str, axis='multi')
+
+    row_idx = _ensure_int32(row_idx)
+    col_idx = _ensure_int32(col_idx)
+
+    out_shape = len(row_idx), len(col_idx)
+
+    if dtype_str in ('int32', 'int64', 'bool'):
+        row_mask = row_idx == -1
+        col_mask=  col_idx == -1
+        needs_masking = row_mask.any() or col_mask.any()
+
+        if needs_masking:
+            return take_2d_multi(_maybe_upcast(arr), row_idx, col_idx,
+                                 fill_value=fill_value)
+        else:
+            out = np.empty(out_shape, dtype=arr.dtype)
+            take_f(arr, row_idx, col_idx, out=out, fill_value=fill_value)
+            return out
+    elif dtype_str in ('float64', 'object', 'datetime64[us]'):
+        out = np.empty(out_shape, dtype=arr.dtype)
+        take_f(arr, row_idx, col_idx, out=out, fill_value=fill_value)
+        return out
+    else:
+        return take_2d(take_2d(arr, row_idx, axis=0, fill_value=fill_value),
+                       col_idx, axis=1, fill_value=fill_value)
+
+
 def take_2d(arr, indexer, out=None, mask=None, needs_masking=None, axis=0,
             fill_value=np.nan):
     """
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 454f0cdff..e4f074208 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1959,14 +1959,19 @@ class DataFrame(NDFrame):
         self._consolidate_inplace()
         frame = self
 
-        if index is not None:
-            frame = frame._reindex_index(index, method, copy, level,
-                                         fill_value, limit)
+        if (index is not None and columns is not None
+            and method is None and level is None
+            and not self._is_mixed_type):
+            return self._reindex_multi(index, columns, copy, fill_value)
 
         if columns is not None:
             frame = frame._reindex_columns(columns, copy, level,
                                            fill_value, limit)
 
+        if index is not None:
+            frame = frame._reindex_index(index, method, copy, level,
+                                         fill_value, limit)
+
         return frame
 
     def reindex_axis(self, labels, axis=0, method=None, level=None, copy=True,
@@ -2020,6 +2025,24 @@ class DataFrame(NDFrame):
         else:  # pragma: no cover
             raise ValueError('Must specify axis=0 or 1')
 
+    def _reindex_multi(self, new_index, new_columns, copy, fill_value):
+        new_index, row_indexer = self.index.reindex(new_index)
+        new_columns, col_indexer = self.columns.reindex(new_columns)
+
+        if row_indexer is not None and col_indexer is not None:
+            new_values = com.take_2d_multi(self.values, row_indexer,
+                                           col_indexer, fill_value=fill_value)
+            return DataFrame(new_values, index=new_index, columns=new_columns)
+        elif row_indexer is not None:
+            return self._reindex_with_indexers(new_index, row_indexer,
+                                               None, None, copy, fill_value)
+        elif col_indexer is not None:
+            return self._reindex_with_indexers(None, None,
+                                               new_columns, col_indexer,
+                                               copy, fill_value)
+        else:
+            return self.copy() if copy else self
+
     def _reindex_index(self, new_index, method, copy, level, fill_value=np.nan,
                        limit=None):
         new_index, indexer = self.index.reindex(new_index, method, level,
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index 9ab8b7c08..419b467a7 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -67,10 +67,10 @@ def take_2d_axis0_%(name)s(ndarray[%(c_type)s, ndim=2] values,
         for i in range(n):
             idx = indexer[i]
             if idx == -1:
-                for j from 0 <= j < k:
+                for j in range(k):
                     outbuf[i, j] = fv
             else:
-                for j from 0 <= j < k:
+                for j in range(k):
                     outbuf[i, j] = values[idx, j]
 
 """
@@ -117,6 +117,55 @@ def take_2d_axis1_%(name)s(ndarray[%(c_type)s, ndim=2] values,
 
 """
 
+take_2d_multi_template = """@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_multi_%(name)s(ndarray[%(c_type)s, ndim=2] values,
+                           ndarray[int32_t] idx0,
+                           ndarray[int32_t] idx1,
+                           out=None, fill_value=np.nan):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[%(c_type)s, ndim=2] outbuf
+        %(c_type)s fv
+
+    n = len(idx0)
+    k = len(idx1)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+
+    if %(raise_on_na)s and _checknan(fill_value):
+        for i in range(n):
+            idx = idx0[i]
+            if idx == -1:
+                for j in range(k):
+                    raise ValueError('No NA values allowed')
+            else:
+                for j in range(k):
+                    if idx1[j] == -1:
+                        raise ValueError('No NA values allowed')
+                    else:
+                        outbuf[i, j] = values[idx, idx1[j]]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = idx0[i]
+            if idx == -1:
+                for j in range(k):
+                    outbuf[i, j] = fv
+            else:
+                for j in range(k):
+                    if idx1[j] == -1:
+                        outbuf[i, j] = fv
+                    else:
+                        outbuf[i, j] = values[idx, idx1[j]]
+
+"""
+
+
 def set_na(na ="NaN"):
     return "outbuf[i] = %s" % na
 
@@ -791,7 +840,8 @@ nobool_1d_templates = [left_join_template,
                        inner_join_template]
 
 templates_2d = [take_2d_axis0_template,
-                take_2d_axis1_template]
+                take_2d_axis1_template,
+                take_2d_multi_template]
 
 
 # templates_1d_datetime = [take_1d_template]
diff --git a/pandas/src/generated.pyx b/pandas/src/generated.pyx
index 626a7514e..f92cf0ef0 100644
--- a/pandas/src/generated.pyx
+++ b/pandas/src/generated.pyx
@@ -1841,10 +1841,10 @@ def take_2d_axis0_float64(ndarray[float64_t, ndim=2] values,
         for i in range(n):
             idx = indexer[i]
             if idx == -1:
-                for j from 0 <= j < k:
+                for j in range(k):
                     outbuf[i, j] = fv
             else:
-                for j from 0 <= j < k:
+                for j in range(k):
                     outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
@@ -1879,10 +1879,10 @@ def take_2d_axis0_object(ndarray[object, ndim=2] values,
         for i in range(n):
             idx = indexer[i]
             if idx == -1:
-                for j from 0 <= j < k:
+                for j in range(k):
                     outbuf[i, j] = fv
             else:
-                for j from 0 <= j < k:
+                for j in range(k):
                     outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
@@ -1917,10 +1917,10 @@ def take_2d_axis0_int32(ndarray[int32_t, ndim=2] values,
         for i in range(n):
             idx = indexer[i]
             if idx == -1:
-                for j from 0 <= j < k:
+                for j in range(k):
                     outbuf[i, j] = fv
             else:
-                for j from 0 <= j < k:
+                for j in range(k):
                     outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
@@ -1955,10 +1955,10 @@ def take_2d_axis0_int64(ndarray[int64_t, ndim=2] values,
         for i in range(n):
             idx = indexer[i]
             if idx == -1:
-                for j from 0 <= j < k:
+                for j in range(k):
                     outbuf[i, j] = fv
             else:
-                for j from 0 <= j < k:
+                for j in range(k):
                     outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
@@ -1993,10 +1993,10 @@ def take_2d_axis0_bool(ndarray[uint8_t, ndim=2] values,
         for i in range(n):
             idx = indexer[i]
             if idx == -1:
-                for j from 0 <= j < k:
+                for j in range(k):
                     outbuf[i, j] = fv
             else:
-                for j from 0 <= j < k:
+                for j in range(k):
                     outbuf[i, j] = values[idx, j]
 
 
@@ -2201,6 +2201,237 @@ def take_2d_axis1_bool(ndarray[uint8_t, ndim=2] values,
                     outbuf[i, j] = values[i, idx]
 
 
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_multi_float64(ndarray[float64_t, ndim=2] values,
+                           ndarray[int32_t] idx0,
+                           ndarray[int32_t] idx1,
+                           out=None, fill_value=np.nan):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[float64_t, ndim=2] outbuf
+        float64_t fv
+
+    n = len(idx0)
+    k = len(idx1)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+
+    if False and _checknan(fill_value):
+        for i in range(n):
+            idx = idx0[i]
+            if idx == -1:
+                for j in range(k):
+                    raise ValueError('No NA values allowed')
+            else:
+                for j in range(k):
+                    if idx1[j] == -1:
+                        raise ValueError('No NA values allowed')
+                    else:
+                        outbuf[i, j] = values[idx, idx1[j]]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = idx0[i]
+            if idx == -1:
+                for j in range(k):
+                    outbuf[i, j] = fv
+            else:
+                for j in range(k):
+                    if idx1[j] == -1:
+                        outbuf[i, j] = fv
+                    else:
+                        outbuf[i, j] = values[idx, idx1[j]]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_multi_object(ndarray[object, ndim=2] values,
+                           ndarray[int32_t] idx0,
+                           ndarray[int32_t] idx1,
+                           out=None, fill_value=np.nan):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[object, ndim=2] outbuf
+        object fv
+
+    n = len(idx0)
+    k = len(idx1)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+
+    if False and _checknan(fill_value):
+        for i in range(n):
+            idx = idx0[i]
+            if idx == -1:
+                for j in range(k):
+                    raise ValueError('No NA values allowed')
+            else:
+                for j in range(k):
+                    if idx1[j] == -1:
+                        raise ValueError('No NA values allowed')
+                    else:
+                        outbuf[i, j] = values[idx, idx1[j]]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = idx0[i]
+            if idx == -1:
+                for j in range(k):
+                    outbuf[i, j] = fv
+            else:
+                for j in range(k):
+                    if idx1[j] == -1:
+                        outbuf[i, j] = fv
+                    else:
+                        outbuf[i, j] = values[idx, idx1[j]]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_multi_int32(ndarray[int32_t, ndim=2] values,
+                           ndarray[int32_t] idx0,
+                           ndarray[int32_t] idx1,
+                           out=None, fill_value=np.nan):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[int32_t, ndim=2] outbuf
+        int32_t fv
+
+    n = len(idx0)
+    k = len(idx1)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+
+    if True and _checknan(fill_value):
+        for i in range(n):
+            idx = idx0[i]
+            if idx == -1:
+                for j in range(k):
+                    raise ValueError('No NA values allowed')
+            else:
+                for j in range(k):
+                    if idx1[j] == -1:
+                        raise ValueError('No NA values allowed')
+                    else:
+                        outbuf[i, j] = values[idx, idx1[j]]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = idx0[i]
+            if idx == -1:
+                for j in range(k):
+                    outbuf[i, j] = fv
+            else:
+                for j in range(k):
+                    if idx1[j] == -1:
+                        outbuf[i, j] = fv
+                    else:
+                        outbuf[i, j] = values[idx, idx1[j]]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_multi_int64(ndarray[int64_t, ndim=2] values,
+                           ndarray[int32_t] idx0,
+                           ndarray[int32_t] idx1,
+                           out=None, fill_value=np.nan):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[int64_t, ndim=2] outbuf
+        int64_t fv
+
+    n = len(idx0)
+    k = len(idx1)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+
+    if True and _checknan(fill_value):
+        for i in range(n):
+            idx = idx0[i]
+            if idx == -1:
+                for j in range(k):
+                    raise ValueError('No NA values allowed')
+            else:
+                for j in range(k):
+                    if idx1[j] == -1:
+                        raise ValueError('No NA values allowed')
+                    else:
+                        outbuf[i, j] = values[idx, idx1[j]]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = idx0[i]
+            if idx == -1:
+                for j in range(k):
+                    outbuf[i, j] = fv
+            else:
+                for j in range(k):
+                    if idx1[j] == -1:
+                        outbuf[i, j] = fv
+                    else:
+                        outbuf[i, j] = values[idx, idx1[j]]
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def take_2d_multi_bool(ndarray[uint8_t, ndim=2] values,
+                           ndarray[int32_t] idx0,
+                           ndarray[int32_t] idx1,
+                           out=None, fill_value=np.nan):
+    cdef:
+        Py_ssize_t i, j, k, n, idx
+        ndarray[uint8_t, ndim=2] outbuf
+        uint8_t fv
+
+    n = len(idx0)
+    k = len(idx1)
+
+    if out is None:
+        outbuf = np.empty((n, k), dtype=values.dtype)
+    else:
+        outbuf = out
+
+
+    if True and _checknan(fill_value):
+        for i in range(n):
+            idx = idx0[i]
+            if idx == -1:
+                for j in range(k):
+                    raise ValueError('No NA values allowed')
+            else:
+                for j in range(k):
+                    if idx1[j] == -1:
+                        raise ValueError('No NA values allowed')
+                    else:
+                        outbuf[i, j] = values[idx, idx1[j]]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = idx0[i]
+            if idx == -1:
+                for j in range(k):
+                    outbuf[i, j] = fv
+            else:
+                for j in range(k):
+                    if idx1[j] == -1:
+                        outbuf[i, j] = fv
+                    else:
+                        outbuf[i, j] = values[idx, idx1[j]]
+
+
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def left_join_indexer_float64(ndarray[float64_t] left,
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 557c88a55..b21bd0995 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -4992,6 +4992,21 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         expected = df.ix[[1]]
         assert_frame_equal(result, expected)
 
+    def test_reindex_multi(self):
+        df = DataFrame(np.random.randn(3, 3))
+
+        result = df.reindex(range(4), range(4))
+        expected = df.reindex(range(4)).reindex(columns=range(4))
+
+        assert_frame_equal(result, expected)
+
+        df = DataFrame(np.random.randint(0, 10, (3, 3)))
+
+        result = df.reindex(range(4), range(4))
+        expected = df.reindex(range(4)).reindex(columns=range(4))
+
+        assert_frame_equal(result, expected)
+
     def test_rename_objects(self):
         renamed = self.mixed_frame.rename(columns=str.upper)
         self.assert_('FOO' in renamed)
diff --git a/vb_suite/frame_methods.py b/vb_suite/frame_methods.py
index cf6967e32..9ccec5c16 100644
--- a/vb_suite/frame_methods.py
+++ b/vb_suite/frame_methods.py
@@ -39,17 +39,19 @@ frame_fillna_inplace = Benchmark('df.fillna(0, inplace=True)', setup)
 # reindex both axes
 
 setup = common_setup + """
-df = DataFrame(randn(10000, 100))
-idx = np.asarray(df.index.copy())
-np.random.shuffle(idx)
-idx = idx[0:9990]
-cols = np.asarray(df.columns.copy())
-np.random.shuffle(cols)
-cols = cols[0:99]
+df = DataFrame(randn(1000, 1000))
+idx = range(400, 700)
 """
 
-frame_multiaxis_reindex = Benchmark('df.reindex(index=idx, columns=cols)',
-                                    setup, start_date=datetime(2012, 5, 6))
+frame_reindex_axis0 = Benchmark('df.reindex(idx)', setup)
+
+frame_reindex_axis1 = Benchmark('df.reindex(columns=idx)', setup)
+
+frame_reindex_both_axes = Benchmark('df.reindex(index=idx, columns=idx)',
+                                    setup, start_date=datetime(2011, 1, 1))
+
+frame_reindex_both_axes_ix = Benchmark('df.ix[idx, idx]', setup,
+                                       start_date=datetime(2011, 1, 1))
 
 #----------------------------------------------------------------------
 # boolean indexing

commit 0085460adb38a864611f84d3edae7f1ffe02f0d1
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Dec 8 19:37:38 2011 -0500

    ENH: add get_value/set_value support to sparse data structures, #438

diff --git a/RELEASE.rst b/RELEASE.rst
index 0108a3145..18d7deac5 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -35,7 +35,8 @@ pandas 0.6.1
     DataFrame.corr (GH #428)
   - Add new `get_value` and `set_value` methods to Series, DataFrame, and Panel
     to very low-overhead access to scalar elements. df.get_value(row, column)
-    is about 3x faster than df[column][row] by handling fewer cases (GH #437)
+    is about 3x faster than df[column][row] by handling fewer cases (GH #437,
+    #438). Add similar methods to sparse data structures for compatibility
   - Add Qt table widget to sandbox (PR #435)
 
 **Improvements to existing features**
@@ -49,6 +50,7 @@ pandas 0.6.1
   - Override Index.astype to enable dtype casting (GH #412)
   - Use same float formatting function for Series.__repr__ (PR #420)
   - Use available console width to output DataFrame columns (PR #453)
+  - Accept ndarrays when setting items in Panel (GH #452)
 
 **Bug fixes**
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 60580f1e1..5e1a1d692 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -956,17 +956,9 @@ class DataFrame(NDFrame):
             engine.set_value(series, index, value)
             return self
         except KeyError:
-            if index not in self.index:
-                new_index = np.concatenate([self.index, [index]])
-            else:
-                new_index = self.index
-            if col not in self.columns:
-                new_columns = np.concatenate([self.columns, [col]])
-            else:
-                new_columns = self.columns
-            result = DataFrame(self._data, index=new_index,
-                               columns=new_columns)
-
+            new_index, new_columns = self._expand_axes((index, col))
+            result = self.reindex(index=new_index, columns=new_columns,
+                                  copy=False)
             likely_dtype = com._infer_dtype(value)
             if result[col].dtype != likely_dtype:
                 result[col] = result[col].astype(likely_dtype)
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 5e745d034..00d9cf9ed 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -318,6 +318,16 @@ class NDFrame(PandasObject):
         del self[item]
         return result
 
+    def _expand_axes(self, key):
+        new_axes = []
+        for k, ax in zip(key, self.axes):
+            if k not in ax:
+                new_axes.append(np.concatenate([ax, [k]]))
+            else:
+                new_axes.append(ax)
+
+        return new_axes
+
     #----------------------------------------------------------------------
     # Consolidation of internals
 
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index f8e7eb664..26890062a 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -489,8 +489,15 @@ class Panel(NDFrame):
             If label combo is contained, will be reference to calling Panel,
             otherwise a new object
         """
-        frame = self._get_item_cache(item)
-        return frame.set_value(major, minor, value)
+        try:
+            frame = self._get_item_cache(item)
+            frame.set_value(major, minor, value)
+            return self
+        except KeyError:
+            ax1, ax2, ax3 = self._expand_axes((item, major, minor))
+            result = self.reindex(items=ax1, major=ax2, minor=ax3, copy=False)
+            result = result.set_value(item, major, minor, value)
+            return result
 
     def _box_item_values(self, key, values):
         return DataFrame(values, index=self.major_axis, columns=self.minor_axis)
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 7de65689e..8fa6b937d 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -327,11 +327,15 @@ copy : boolean, default False
     def set_value(self, label, value):
         """
         Quickly set single value at passed label. If label is not contained, a
+        new object is created with the label placed at the end of the result
+        index
 
         Parameters
         ----------
         label : object
             Partial indexing with MultiIndex not allowed
+        value : object
+            Scalar value
 
         Returns
         -------
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index 62003e1f5..407889187 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -400,11 +400,44 @@ to sparse
             return ndarray.__getitem__(self, sp_loc)
 
     def get_value(self, label):
+        """
+        Retrieve single value at passed index label
+
+        Parameters
+        ----------
+        index : label
+
+        Returns
+        -------
+        value : scalar value
+        """
         loc = self.index.get_loc(label)
         return self._get_val_at(loc)
 
     def set_value(self, label, value):
-        raise Exception('SparseSeries is immutable')
+        """
+        Quickly set single value at passed label. If label is not contained, a
+        new object is created with the label placed at the end of the result
+        index
+
+        Parameters
+        ----------
+        label : object
+            Partial indexing with MultiIndex not allowed
+        value : object
+            Scalar value
+
+        Notes
+        -----
+        This method *always* returns a new object. It is not particularly
+        efficient but is provided for API compatibility with Series
+
+        Returns
+        -------
+        series : SparseSeries
+        """
+        dense = self.to_dense().set_value(label, value)
+        return dense.to_sparse(kind=self.kind, fill_value=self.fill_value)
 
     def take(self, indices):
         """
@@ -946,13 +979,32 @@ class SparseDataFrame(DataFrame):
     def get_value(self, index, col):
         s = self._series[col]
         return s.get_value(index)
-    if __debug__: get_value.__doc__ = DataFrame.get_value.__doc__
+    if __debug__:
+        get_value.__doc__ = DataFrame.get_value.__doc__
 
     def set_value(self, index, col, value):
         """
-        Not implemented for SparseDataFrame
+        Put single value at passed column and index
+
+        Parameters
+        ----------
+        index : row label
+        col : column label
+        value : scalar value
+
+        Notes
+        -----
+        This method *always* returns a new object. It is currently not
+        particularly efficient (and potentially very expensive) but is provided
+        for API compatibility with DataFrame
+
+        Returns
+        -------
+        frame : DataFrame
         """
-        raise Exception('Values in SparseDataFrame are immutable')
+        dense = self.to_dense().set_value(index, col, value)
+        return dense.to_sparse(kind=self.default_kind,
+                               fill_value=self.default_fill_value)
 
     def _slice(self, slobj, axis=0):
         if axis == 0:
@@ -1527,8 +1579,29 @@ class SparsePanel(Panel):
         if key not in self.items:
             self._items = Index(list(self.items) + [key])
 
-    def set_value(self, item, row, column, value):
-        raise Exception('Sparse object scalar values are immutable')
+    def set_value(self, item, major, minor, value):
+        """
+        Quickly set single value at (item, major, minor) location
+
+        Parameters
+        ----------
+        item : item label (panel item)
+        major : major axis label (panel item row)
+        minor : minor axis label (panel item column)
+        value : scalar
+
+        Notes
+        -----
+        This method *always* returns a new object. It is not particularly
+        efficient but is provided for API compatibility with Panel
+
+        Returns
+        -------
+        panel : SparsePanel
+        """
+        dense = self.to_dense().set_value(item, major, minor, value)
+        return dense.to_sparse(kind=self.default_kind,
+                               fill_value=self.default_fill_value)
 
     def __delitem__(self, key):
         loc = self.items.get_loc(key)
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index 4eb5ec043..728bf2a5e 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -565,6 +565,12 @@ class CheckIndexing(object):
                     self.panel.set_value(item, mjr, mnr, 1.)
                     assert_almost_equal(self.panel[item][mnr][mjr], 1.)
 
+        # resize
+        res = self.panel.set_value('ItemE', 'foo', 'bar', 1.5)
+        self.assert_(isinstance(res, Panel))
+        self.assert_(res is not self.panel)
+        self.assertEqual(res.get_value('ItemE', 'foo', 'bar'), 1.5)
+
 class TestPanel(unittest.TestCase, PanelTests, CheckIndexing,
                 SafeForLongAndSparse,
                 SafeForSparse):
diff --git a/pandas/tests/test_sparse.py b/pandas/tests/test_sparse.py
index 7b42b201f..afe81aee6 100644
--- a/pandas/tests/test_sparse.py
+++ b/pandas/tests/test_sparse.py
@@ -316,7 +316,15 @@ class TestSparseSeries(TestCase,
         assert_almost_equal(self.bseries.get_value(10), self.bseries[10])
 
     def test_set_value(self):
-        self.assertRaises(Exception, self.bseries.set_value, 10, 0)
+        idx = self.btseries.index[7]
+        res = self.btseries.set_value(idx, 0)
+        self.assert_(res is not self.btseries)
+        self.assertEqual(res[idx], 0)
+
+        res = self.iseries.set_value('foobar', 0)
+        self.assert_(res is not self.iseries)
+        self.assert_(res.index[-1] == 'foobar')
+        self.assertEqual(res['foobar'], 0)
 
     def test_getitem_fancy_index(self):
         idx = self.bseries.index
@@ -830,7 +838,16 @@ class TestSparseDataFrame(TestCase, test_frame.SafeForSparse):
         pass
 
     def test_set_value(self):
-        self.assertRaises(Exception, self.frame.set_value, 10, 0)
+        res = self.frame.set_value('foobar', 'B', 1.5)
+        self.assert_(res is not self.frame)
+        self.assert_(res.index[-1] == 'foobar')
+        self.assertEqual(res.get_value('foobar', 'B'), 1.5)
+
+        res2 = res.set_value('foobar', 'qux', 1.5)
+        self.assert_(res2 is not res)
+        self.assert_(np.array_equal(res2.columns,
+                                    list(self.frame.columns) + ['qux']))
+        self.assertEqual(res2.get_value('foobar', 'qux'), 1.5)
 
     def test_fancy_index_misc(self):
         # axis = 0
@@ -1273,11 +1290,15 @@ class TestSparsePanel(TestCase,
         self.assertRaises(Exception, self.panel.__setitem__, 'item6', 1)
 
     def test_set_value(self):
-        mjr = self.panel.major_axis[4]
-        mnr = self.panel.minor_axis[3]
-
-        self.assertRaises(Exception, self.panel.set_value, 'ItemA',
-                          )
+        def _check_loc(item, major, minor, val=1.5):
+            res = self.panel.set_value(item, major, minor, val)
+            self.assert_(res is not self.panel)
+            self.assertEquals(res.get_value(item, major, minor), val)
+
+        _check_loc('ItemA', self.panel.major_axis[4], self.panel.minor_axis[3])
+        _check_loc('ItemF', self.panel.major_axis[4], self.panel.minor_axis[3])
+        _check_loc('ItemF', 'foo', self.panel.minor_axis[3])
+        _check_loc('ItemE', 'foo', 'bar')
 
     def test_delitem_pop(self):
         del self.panel['ItemB']

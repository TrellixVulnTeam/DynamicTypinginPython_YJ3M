commit 9c06b30f9e6bc0c2ed15b851c85ae4077a189313
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Feb 18 04:38:28 2020 -0800

    CLN: remove unused from MultiIndex (#32030)

diff --git a/pandas/core/indexes/multi.py b/pandas/core/indexes/multi.py
index 02e11c0e7..0a79df0cc 100644
--- a/pandas/core/indexes/multi.py
+++ b/pandas/core/indexes/multi.py
@@ -58,7 +58,6 @@ from pandas.core.sorting import (
     indexer_from_factorized,
     lexsort_indexer,
 )
-from pandas.core.util.hashing import hash_tuple, hash_tuples
 
 from pandas.io.formats.printing import (
     format_object_attrs,
@@ -247,6 +246,7 @@ class MultiIndex(Index):
     rename = Index.set_names
 
     _tuples = None
+    sortorder: Optional[int]
 
     # --------------------------------------------------------------------
     # Constructors
@@ -1430,55 +1430,11 @@ class MultiIndex(Index):
         # monotonic decreasing if and only if reverse is monotonic increasing
         return self[::-1].is_monotonic_increasing
 
-    @cache_readonly
-    def _have_mixed_levels(self):
-        """ return a boolean list indicated if we have mixed levels """
-        return ["mixed" in l for l in self._inferred_type_levels]
-
     @cache_readonly
     def _inferred_type_levels(self):
         """ return a list of the inferred types, one for each level """
         return [i.inferred_type for i in self.levels]
 
-    @cache_readonly
-    def _hashed_values(self):
-        """ return a uint64 ndarray of my hashed values """
-        return hash_tuples(self)
-
-    def _hashed_indexing_key(self, key):
-        """
-        validate and return the hash for the provided key
-
-        *this is internal for use for the cython routines*
-
-        Parameters
-        ----------
-        key : string or tuple
-
-        Returns
-        -------
-        np.uint64
-
-        Notes
-        -----
-        we need to stringify if we have mixed levels
-        """
-        if not isinstance(key, tuple):
-            return hash_tuples(key)
-
-        if not len(key) == self.nlevels:
-            raise KeyError
-
-        def f(k, stringify):
-            if stringify and not isinstance(k, str):
-                k = str(k)
-            return k
-
-        key = tuple(
-            f(k, stringify) for k, stringify in zip(key, self._have_mixed_levels)
-        )
-        return hash_tuple(key)
-
     @Appender(Index.duplicated.__doc__)
     def duplicated(self, keep="first"):
         shape = map(len, self.levels)
@@ -1858,27 +1814,6 @@ class MultiIndex(Index):
         )
         return ibase._new_Index, (type(self), d), None
 
-    def __setstate__(self, state):
-        """Necessary for making this object picklable"""
-        if isinstance(state, dict):
-            levels = state.get("levels")
-            codes = state.get("codes")
-            sortorder = state.get("sortorder")
-            names = state.get("names")
-
-        elif isinstance(state, tuple):
-
-            nd_state, own_state = state
-            levels, codes, sortorder, names = own_state
-
-        self._set_levels([Index(x) for x in levels], validate=False)
-        self._set_codes(codes)
-        new_codes = self._verify_integrity()
-        self._set_codes(new_codes)
-        self._set_names(names)
-        self.sortorder = sortorder
-        self._reset_identity()
-
     # --------------------------------------------------------------------
 
     def __getitem__(self, key):
diff --git a/pandas/tests/util/test_hashing.py b/pandas/tests/util/test_hashing.py
index c856585f2..6411b9ab6 100644
--- a/pandas/tests/util/test_hashing.py
+++ b/pandas/tests/util/test_hashing.py
@@ -178,23 +178,6 @@ def test_multiindex_objects():
     assert mi.equals(recons)
     assert Index(mi.values).equals(Index(recons.values))
 
-    # _hashed_values and hash_pandas_object(..., index=False) equivalency.
-    expected = hash_pandas_object(mi, index=False).values
-    result = mi._hashed_values
-
-    tm.assert_numpy_array_equal(result, expected)
-
-    expected = hash_pandas_object(recons, index=False).values
-    result = recons._hashed_values
-
-    tm.assert_numpy_array_equal(result, expected)
-
-    expected = mi._hashed_values
-    result = recons._hashed_values
-
-    # Values should match, but in different order.
-    tm.assert_numpy_array_equal(np.sort(result), np.sort(expected))
-
 
 @pytest.mark.parametrize(
     "obj",

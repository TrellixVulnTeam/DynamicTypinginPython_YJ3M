commit 4d80049197503aadd65cb16566cf7793ff940b08
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat May 26 17:39:02 2012 -0400

    ENH: conversion to datetime64, per #1317

diff --git a/pandas/core/series.py b/pandas/core/series.py
index c01077b62..b97d4addd 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -114,12 +114,14 @@ def _comp_method(op, name):
         elif isinstance(other, DataFrame): # pragma: no cover
             return NotImplemented
         else:
+            values = self.values
+            other = lib.convert_scalar(values, other)
             # scalars
-            res = na_op(self.values, other)
+            res = na_op(values, other)
             if np.isscalar(res):
                 raise TypeError('Could not compare %s type with Series'
                                 % type(other))
-            return Series(na_op(self.values, other),
+            return Series(na_op(values, other),
                           index=self.index, name=self.name)
     return wrapper
 
@@ -815,7 +817,10 @@ copy : boolean, default False
         return repr(self)
 
     def __iter__(self):
-        return iter(self.values)
+        if np.issubdtype(self.dtype, np.datetime64):
+            return (lib.Timestamp(x) for x in self.values)
+        else:
+            return iter(self.values)
 
     def iteritems(self, index=True):
         """
@@ -959,7 +964,7 @@ copy : boolean, default False
                 numpy = False
         if not numpy:
             if orient == "split":
-                decoded = dict((str(k), v) 
+                decoded = dict((str(k), v)
                                for k, v in loads(json).iteritems())
                 s = Series(dtype=dtype, **decoded)
             else:
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index bd753f779..18f28c9f5 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -144,6 +144,10 @@ class Timestamp(_Timestamp):
     def freqstr(self):
         return getattr(self.offset, 'freqstr', self.offset)
 
+    @property
+    def asm8(self):
+        return np.int64(self.value).view('M8[ns]')
+
     def tz_convert(self, tz):
         if isinstance(tz, basestring):
             import pytz
diff --git a/pandas/src/engines.pyx b/pandas/src/engines.pyx
index a6c734ed9..6b180f4d5 100644
--- a/pandas/src/engines.pyx
+++ b/pandas/src/engines.pyx
@@ -435,6 +435,13 @@ cdef class DatetimeEngine(Int64Engine):
                                      limit=limit)
 
 
+cpdef convert_scalar(ndarray arr, object scalar):
+    if arr.descr.type_num == NPY_DATETIME:
+        if not isinstance(scalar, _Timestamp):
+            scalar = Timestamp(scalar)
+        return scalar.asm8
+    return scalar
+
 cdef inline _to_i8(object val):
     cdef pandas_datetimestruct dts
     if util.is_datetime64_object(val):
@@ -443,6 +450,7 @@ cdef inline _to_i8(object val):
         return _pydatetime_to_dts(val, &dts)
     return val
 
+
 # ctypedef fused idxvalue_t:
 #     object
 #     int
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index edad6e332..941f2fef2 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -1092,6 +1092,10 @@ class TestLegacyCompat(unittest.TestCase):
 
 
 class TestDatetime64(unittest.TestCase):
+    """
+    Also test supoprt for datetime64[ns] in Series / DataFrame
+    """
+
 
     def setUp(self):
         dti = DatetimeIndex(start=datetime(2005,1,1),
@@ -1253,6 +1257,33 @@ class TestDatetime64(unittest.TestCase):
     # TODO: test merge & concat with datetime64 block
 
 
+class TestSeriesDatetime64(unittest.TestCase):
+
+    def setUp(self):
+        self.series = Series(list(date_range('1/1/2000', periods=10)))
+
+    def test_series_comparison_scalars(self):
+        val = datetime(2000, 1, 4)
+        result = self.series > val
+        expected = np.array([x > val for x in self.series])
+        self.assert_(np.array_equal(result, expected))
+
+        val = self.series[5]
+        result = self.series > val
+        expected = np.array([x > val for x in self.series])
+        self.assert_(np.array_equal(result, expected))
+
+    def test_between(self):
+        left, right = self.series[[2, 7]]
+
+        result = self.series.between(left, right)
+        expected = (self.series >= left) & (self.series <= right)
+        assert_series_equal(result, expected)
+
+    #----------------------------------------------------------------------
+    # NaT support
+
+
 class TestTimestamp(unittest.TestCase):
 
     def test_basics_nanos(self):

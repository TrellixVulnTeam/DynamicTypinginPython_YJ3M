commit d3f607da23e01abe96bcf2409914130bf80e4647
Author: jreback <jeff@reback.net>
Date:   Sun Sep 21 18:25:21 2014 -0400

    ENH/BUG: allow timedelta resamples

diff --git a/doc/source/v0.15.0.txt b/doc/source/v0.15.0.txt
index c66cda58f..db55786ba 100644
--- a/doc/source/v0.15.0.txt
+++ b/doc/source/v0.15.0.txt
@@ -563,7 +563,7 @@ TimedeltaIndex/Scalar
 We introduce a new scalar type ``Timedelta``, which is a subclass of ``datetime.timedelta``, and behaves in a similar manner,
 but allows compatibility with ``np.timedelta64`` types as well as a host of custom representation, parsing, and attributes.
 This type is very similar to how ``Timestamp`` works for ``datetimes``. It is a nice-API box for the type. See the :ref:`docs <timedeltas.timedeltas>`.
-(:issue:`3009`, :issue:`4533`, :issue:`8209`, :issue:`8187`, :issue:`8190`, :issue:`7869`, :issue:`7661`)
+(:issue:`3009`, :issue:`4533`, :issue:`8209`, :issue:`8187`, :issue:`8190`, :issue:`7869`, :issue:`7661`, :issue:`8345`)
 
 .. warning::
 
diff --git a/pandas/tseries/resample.py b/pandas/tseries/resample.py
index 01aff164d..aa72113cb 100644
--- a/pandas/tseries/resample.py
+++ b/pandas/tseries/resample.py
@@ -5,6 +5,7 @@ import numpy as np
 from pandas.core.groupby import BinGrouper, Grouper
 from pandas.tseries.frequencies import to_offset, is_subperiod, is_superperiod
 from pandas.tseries.index import DatetimeIndex, date_range
+from pandas.tseries.tdi import TimedeltaIndex
 from pandas.tseries.offsets import DateOffset, Tick, _delta_to_nanoseconds
 from pandas.tseries.period import PeriodIndex, period_range
 import pandas.tseries.tools as tools
@@ -96,10 +97,12 @@ class TimeGrouper(Grouper):
                 obj = self.obj.to_timestamp(how=self.convention)
                 self._set_grouper(obj)
                 rs = self._resample_timestamps()
+        elif isinstance(ax, TimedeltaIndex):
+            rs = self._resample_timestamps(kind='timedelta')
         elif len(ax) == 0:
             return self.obj
         else:  # pragma: no cover
-            raise TypeError('Only valid with DatetimeIndex or PeriodIndex')
+            raise TypeError('Only valid with DatetimeIndex, TimedeltaIndex or PeriodIndex')
 
         rs_axis = rs._get_axis(self.axis)
         rs_axis.name = ax.name
@@ -109,13 +112,17 @@ class TimeGrouper(Grouper):
         self._set_grouper(obj)
         return self._get_binner_for_resample()
 
-    def _get_binner_for_resample(self):
+    def _get_binner_for_resample(self, kind=None):
         # create the BinGrouper
         # assume that self.set_grouper(obj) has already been called
 
         ax = self.ax
-        if self.kind is None or self.kind == 'timestamp':
+        if kind is None:
+            kind = self.kind
+        if kind is None or kind == 'timestamp':
             self.binner, bins, binlabels = self._get_time_bins(ax)
+        elif kind == 'timedelta':
+            self.binner, bins, binlabels = self._get_time_delta_bins(ax)
         else:
             self.binner, bins, binlabels = self._get_time_period_bins(ax)
 
@@ -217,6 +224,25 @@ class TimeGrouper(Grouper):
 
         return binner, bin_edges
 
+    def _get_time_delta_bins(self, ax):
+        if not isinstance(ax, TimedeltaIndex):
+            raise TypeError('axis must be a TimedeltaIndex, but got '
+                            'an instance of %r' % type(ax).__name__)
+
+        if not len(ax):
+            binner = labels = TimedeltaIndex(data=[], freq=self.freq, name=ax.name)
+            return binner, [], labels
+
+        labels = binner = TimedeltaIndex(start=ax[0],
+                                         end=ax[-1],
+                                         freq=self.freq,
+                                         name=ax.name)
+
+        end_stamps = labels + 1
+        bins = ax.searchsorted(end_stamps, side='left')
+
+        return binner, bins, labels
+
     def _get_time_period_bins(self, ax):
         if not isinstance(ax, DatetimeIndex):
             raise TypeError('axis must be a DatetimeIndex, but got '
@@ -242,11 +268,11 @@ class TimeGrouper(Grouper):
     def _agg_method(self):
         return self.how if self.how else _DEFAULT_METHOD
 
-    def _resample_timestamps(self):
+    def _resample_timestamps(self, kind=None):
         # assumes set_grouper(obj) already called
         axlabels = self.ax
 
-        self._get_binner_for_resample()
+        self._get_binner_for_resample(kind=kind)
         grouper = self.grouper
         binner = self.binner
         obj = self.obj
diff --git a/pandas/tseries/tests/test_resample.py b/pandas/tseries/tests/test_resample.py
index f4a96f5de..bafba8472 100644
--- a/pandas/tseries/tests/test_resample.py
+++ b/pandas/tseries/tests/test_resample.py
@@ -146,7 +146,7 @@ class TestResample(tm.TestCase):
         data = np.arange(5, dtype=np.int64)
         ind = pd.DatetimeIndex(start='2014-01-01', periods=len(data), freq='d')
         df = pd.DataFrame({"A": data, "B": data}, index=ind)
-        
+
         def fn(x, a=1):
             return str(type(x))
 
@@ -164,7 +164,18 @@ class TestResample(tm.TestCase):
         assert_frame_equal(df_standard, df_partial)
         assert_frame_equal(df_standard, df_partial2)
         assert_frame_equal(df_standard, df_class)
-        
+
+    def test_resample_with_timedeltas(self):
+
+        expected = DataFrame({'A' : np.arange(1480)})
+        expected = expected.groupby(expected.index // 30).sum()
+        expected.index = pd.timedelta_range('0 days',freq='30T',periods=50)
+
+        df = DataFrame({'A' : np.arange(1480)},index=pd.to_timedelta(np.arange(1480),unit='T'))
+        result = df.resample('30T',how='sum')
+
+        assert_frame_equal(result, expected)
+
     def test_resample_basic_from_daily(self):
         # from daily
         dti = DatetimeIndex(
diff --git a/pandas/tseries/tests/test_timedeltas.py b/pandas/tseries/tests/test_timedeltas.py
index 48d3f3a55..02d25bc71 100644
--- a/pandas/tseries/tests/test_timedeltas.py
+++ b/pandas/tseries/tests/test_timedeltas.py
@@ -265,6 +265,10 @@ class TestTimedeltas(tm.TestCase):
         result = timedelta_range('1 days, 00:00:02',periods=5,freq='2D')
         tm.assert_index_equal(result, expected)
 
+        expected = to_timedelta(np.arange(50),unit='T')*30
+        result = timedelta_range('0 days',freq='30T',periods=50)
+        tm.assert_index_equal(result, expected)
+
     def test_numeric_conversions(self):
         self.assertEqual(ct(0), np.timedelta64(0,'ns'))
         self.assertEqual(ct(10), np.timedelta64(10,'ns'))

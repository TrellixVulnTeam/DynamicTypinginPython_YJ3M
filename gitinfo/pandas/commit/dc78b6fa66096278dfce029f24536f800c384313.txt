commit dc78b6fa66096278dfce029f24536f800c384313
Author: Adam Klein <adamklein@gmail.com>
Date:   Mon Mar 5 14:58:49 2012 -0500

    BUG: fixed merge problems from latest master

diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 4ba16662b..b967cf930 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -644,6 +644,191 @@ class Grouper(object):
         result = lib.maybe_convert_objects(result, try_float=0)
         return result, counts
 
+def generate_bins_generic(values, binner, closed, label):
+    """
+    Generate bin edge offsets and bin labels for one array using another array
+    which has bin edge values. Both arrays must be sorted.
+
+    Parameters
+    ----------
+    values : array of values
+    binner : a comparable array of values representing bins into which to bin
+        the first array. Note, 'values' end-points must fall within 'binner'
+        end-points.
+    closed : which end of bin is closed; left (default), right
+    label : which end of bin to use as a label: left (default), right
+
+    Returns
+    -------
+    bins : array of offsets (into 'values' argument) of bins. 
+        Zero and last edge are excluded in result, so for instance the first
+        bin is values[0:bin[0]] and the last is values[bin[-1]:]
+    labels : array of labels of bins
+    """
+    lenidx = len(values)
+    lenbin = len(binner)
+
+    if lenidx <= 0 or lenbin <= 0:
+        raise ValueError("Invalid length for values or for binner")
+
+    # check binner fits data
+    if values[0] < binner[0]:
+        raise ValueError("Values falls before first bin")
+
+    if values[lenidx-1] > binner[lenbin-1]:
+        raise ValueError("Values falls after last bin")
+
+    labels = np.empty(lenbin, dtype=np.int64)
+    bins   = np.empty(lenbin, dtype=np.int32)
+
+    j  = 0 # index into values
+    bc = 0 # bin count
+    vc = 0 # value count
+
+    # linear scan, presume nothing about values/binner except that it
+    # fits ok
+    for i in range(0, lenbin-1):
+        l_bin = binner[i]
+        r_bin = binner[i+1]
+
+        # set label of bin
+        if label == 'left':
+            labels[bc] = l_bin
+        else:
+            labels[bc] = r_bin
+
+        # count values in current bin, advance to next bin
+        while values[j] < r_bin or closed == 'right' and values[j] == r_bin:
+            j += 1
+            vc += 1
+            if j >= lenidx:
+                break
+
+        # check we have data left to scan
+        if j >= lenidx:
+            break
+
+        # if we've seen some values or not ignoring empty bins
+        if vc != 0:
+            bins[bc] = j
+            bc += 1
+            vc = 0
+
+    labels = np.resize(labels, bc + 1)
+    bins = np.resize(bins, bc)
+
+    return bins, labels
+
+class CustomGrouper:
+    pass
+
+def _generate_time_binner(dtindex, offset,
+                          begin=None, end=None, nperiods=None):
+
+    if isinstance(offset, basestring):
+        offset = dt.getOffset(offset)
+
+    if begin is None:
+        first = lib.Timestamp(dtindex[0] - offset)
+    else:
+        first = lib.Timestamp(begin)
+
+    if end is None:
+        last = lib.Timestamp(dtindex[-1] + offset)
+    else:
+        last = lib.Timestamp(end)
+
+    if isinstance(offset, dt.Tick):
+        return np.arange(first.value, last.value+1, offset.us_stride(),
+                         dtype=np.int64)
+
+    return DatetimeIndex(offset=offset,
+                         start=first, end=last, periods=nperiods)
+
+class Tinterval(Grouper, CustomGrouper):
+    """
+    Custom groupby class for time-interval grouping
+
+    Parameters
+    ----------
+    interval : pandas offset string or object for identifying bin edges
+    closed : closed end of interval; left (default) or right
+    label : interval boundary to use for labeling; left (default) or right
+    begin : optional, timestamp-like
+    end : optional, timestamp-like
+    nperiods : optional, integer
+
+    Notes
+    -----
+    Use begin, end, nperiods to generate intervals that cannot be derived
+    directly from the associated object
+    """
+
+    obj = None
+    bins = None
+    binlabels = None
+    begin = None
+    end = None
+    nperiods = None
+    binner = None
+
+    def __init__(self, interval='Min', closed='left', label='left',
+                 begin=None, end=None, nperiods=None, _obj=None):
+        self.offset = interval
+        self.closed = closed
+        self.label = label
+        self.begin = begin
+        self.end = end
+        self.nperiods = None
+
+        if _obj is not None:
+            self.set_obj(_obj)
+
+    def set_obj(self, obj):
+        """
+        Injects the object we'll act on, which we use to initialize grouper
+        """
+        if id(self.obj) == id(obj):
+            return
+
+        self.obj = obj
+
+        if not isinstance(obj.index, DatetimeIndex):
+            raise ValueError("Cannot apply Tinterval to non-DatetimeIndex")
+
+        index = obj.index
+
+        if len(obj.index) < 1:
+            self.bins = []
+            self.binlabels = []
+            return
+
+        self.binner = _generate_time_binner(obj.index, self.offset, self.begin,
+                                            self.end, self.nperiods)
+
+        if isinstance(self.binner, DatetimeIndex):
+            self.binner = self.binner.asi8
+
+        # general version, knowing nothing about relative frequencies
+        bins, labels = lib.generate_bins_dt64(index.asi8, self.binner,
+                                              self.closed, self.label)
+
+        self.bins = bins
+        self.binlabels = labels.view('M8[us]')
+
+    @cache_readonly
+    def ngroups(self):
+        return len(self.binlabels)
+
+    @cache_readonly
+    def result_index(self):
+        return self.binlabels
+
+    def agg_series(self, obj, func):
+        dummy = obj[:0]
+        grouper = lib.SeriesBinGrouper(obj, func, self.bins, dummy)
+        return grouper.get_result()
+
 
 class Grouping(object):
     """
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 87c5c26ec..6120e4795 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1,6 +1,7 @@
 # pylint: disable=E1101,E1103,W0232
 
 from datetime import time, datetime, date
+from datetime import timedelta
 from itertools import izip
 
 import numpy as np

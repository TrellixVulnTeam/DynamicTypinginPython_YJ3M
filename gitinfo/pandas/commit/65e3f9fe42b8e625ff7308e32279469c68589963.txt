commit 65e3f9fe42b8e625ff7308e32279469c68589963
Author: Adam Klein <adamklein@gmail.com>
Date:   Wed Feb 8 16:52:17 2012 -0500

    working on timeseries ranges

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index dcf58dcd8..4c4378946 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -157,7 +157,7 @@ class DateRange(DatetimeIndex):
 
         if offset not in _daterange_cache:
             xdr = generate_range(_CACHE_START, _CACHE_END, offset=offset)
-            arr = np.array(_dt_unbox_array(list(xdr)), 
+            arr = np.array(_dt_unbox_array(list(xdr)),
                            dtype='M8[us]', copy=False)
 
             cachedRange = arr.view(DateRange)
diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 6ccc9eae4..b8162ae77 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -8,7 +8,6 @@ import pandas._tseries as lib
 try:
     import dateutil
     from dateutil import parser
-    from dateutil.relativedelta import relativedelta
 
     # raise exception if dateutil 2.0 install on 2.x platform
     if (sys.version_info[0] == 2 and
@@ -160,7 +159,7 @@ class DateOffset(object):
         self.n = int(n)
         self.kwds = kwds
         if len(kwds) > 0:
-            self._offset = relativedelta(**kwds)
+            self._offset = lib.Delta(**kwds)
         else:
             self._offset = timedelta(1)
 
@@ -356,10 +355,10 @@ class MonthEnd(DateOffset, CacheableOffset):
         n = self.n
         _, days_in_month = calendar.monthrange(other.year, other.month)
         if other.day != days_in_month:
-            other = other + relativedelta(months=-1, day=31)
+            other = other + lib.Delta(months=-1, day=31)
             if n <= 0:
                 n = n + 1
-        other = other + relativedelta(months=n, day=31)
+        other = other + lib.Delta(months=n, day=31)
         return other
 
     @classmethod
@@ -386,7 +385,7 @@ class BMonthEnd(DateOffset, CacheableOffset):
             n = n - 1
         elif n <= 0 and other.day > lastBDay:
             n = n + 1
-        other = other + relativedelta(months=n, day=31)
+        other = other + lib.Delta(months=n, day=31)
 
         if other.weekday() > 4:
             other = other - BDay()
@@ -482,7 +481,7 @@ class WeekOfMonth(DateOffset, CacheableOffset):
     def apply(self, other):
         offsetOfMonth = self.getOffsetOfMonth(other)
 
-        one_month = relativedelta(months=1, day=1)
+        one_month = lib.Delta(months=1, day=1)
 
         if offsetOfMonth > other:
             if self.n > 0:
@@ -497,7 +496,7 @@ class WeekOfMonth(DateOffset, CacheableOffset):
             else:
                 months = self.n + 1
 
-        return self.getOffsetOfMonth(other + relativedelta(months=months, day=1))
+        return self.getOffsetOfMonth(other + lib.Delta(months=months, day=1))
 
     def getOffsetOfMonth(self, someDate):
         w = Week(weekday=self.weekday)
@@ -551,7 +550,7 @@ class BQuarterEnd(DateOffset, CacheableOffset):
         elif n <= 0 and other.day > lastBDay and monthsToGo == 0:
             n = n + 1
 
-        other = other + relativedelta(months=monthsToGo + 3*n, day=31)
+        other = other + lib.Delta(months=monthsToGo + 3*n, day=31)
 
         if other.weekday() > 4:
             other = other - BDay()
@@ -597,7 +596,7 @@ class QuarterEnd(DateOffset, CacheableOffset):
         if n > 0 and not (other.day >= days_in_month and monthsToGo == 0):
             n = n - 1
 
-        other = other + relativedelta(months=monthsToGo + 3*n, day=31)
+        other = other + lib.Delta(months=monthsToGo + 3*n, day=31)
 
         return other
 
@@ -638,7 +637,7 @@ class BYearEnd(DateOffset, CacheableOffset):
                 (other.month == self.month and other.day > lastBDay)):
                 years += 1
 
-        other = other + relativedelta(years=years)
+        other = other + lib.Delta(years=years)
 
         _, days_in_month = calendar.monthrange(other.year, self.month)
         result = lib.Timestamp(datetime(other.year, self.month, days_in_month))
@@ -658,7 +657,7 @@ class YearEnd(DateOffset, CacheableOffset):
             other = lib.Timestamp(datetime(other.year - 1, 12, 31))
             if n <= 0:
                 n = n + 1
-        other = other + relativedelta(years=n)
+        other = other + lib.Delta(years=n)
         return other
 
     @classmethod
@@ -676,7 +675,7 @@ class YearBegin(DateOffset, CacheableOffset):
             other = lib.Timestamp(datetime(other.year, 1, 1))
             if n <= 0:
                 n = n + 1
-        other = other + relativedelta(years = n, day=1)
+        other = other + lib.Delta(years = n, day=1)
         return other
 
     @classmethod
diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index 10da34170..31db5a041 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -4,15 +4,9 @@ from cpython cimport PyObject
 cdef extern from "datetime.h":
 
     ctypedef class datetime.datetime [object PyDateTime_DateTime]:
-        # cdef int *data
-        # cdef long hashcode
-        # cdef char hastzinfo
         pass
 
     ctypedef class datetime.timedelta [object PyDateTime_Delta]:
-        # cdef int *data
-        # cdef long hashcode
-        # cdef char hastzinfo
         pass
 
     void PyDateTime_IMPORT()
@@ -80,7 +74,6 @@ cdef extern from "np_datetime.h":
     int convert_pydatetime_to_datetimestruct(PyObject *obj, npy_datetimestruct *out,
                                              NPY_DATETIMEUNIT *out_bestunit,
                                              int apply_tzinfo)
-
     int _days_per_month_table[2][12]
     int dayofweek(int y, int m, int d)
     int is_leapyear(int64_t year)
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 629307cff..ac92579ee 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -66,7 +66,7 @@ cdef class _Timestamp(datetime):
         int64_t value       # numpy int64
         object freq         # dateoffset object
 
-# lightweight C object to hold datetime, int64 pair
+# lightweight C object to hold datetime & int64 pair
 cdef class _TSObject:
     cdef:
         datetime dtval      # python datetime
@@ -213,6 +213,105 @@ cdef conversion_factor(time_res res1, time_res res2):
 
     return factor
 
+# Logic to generate ranges
+# -----------------------------------------------------------------------------
+
+def generate_annual_range(object start, Py_ssize_t periods, int64_t dayoffset=0,
+                          int64_t biz=0):
+    """
+    Generate yearly timestamps beginning with start time. Apply dayoffset to
+    each timestamp, which allows you to for instance generate month ends with
+    -1. If biz is 1, we choose the next business day if offset >= 0, else prev
+    business day if < 0.
+    """
+    cdef:
+        Py_ssize_t i, m, d, y, ly, w
+        int64_t us_in_day
+        ndarray[int64_t] dtindex
+        _TSObject ts
+
+    ts = convert_to_tsobject(start)
+
+    us_in_day = conversion_factor(r_microsecond, r_day)
+
+    dtindex = np.empty(periods, np.int64)
+
+    dayoffset *= us_in_day
+
+    dtindex[0] = ts.value + dayoffset
+    m = ts.dtval.month
+    d = ts.dtval.day
+    y = ts.dtval.year
+    ly = m >= 3
+    w = 0
+    # weekday logic needs fixing
+    for i in range(1, periods):
+        dtindex[i] = -w + dtindex[i-1] + (365 + is_leapyear(y + ly)) * us_in_day
+        y += 1
+        if biz != 0:
+            w = dayofweek(y,m,d)
+            if w > 4:
+                if dayoffset < 0:
+                    w = (w-7) * us_in_day
+                else:
+                    w = (7-w) * us_in_day
+            else:
+                w = 0
+            dtindex[i] += w
+
+    return dtindex.view(np.datetime64)
+
+def generate_quarterly_range(object start, Py_ssize_t periods, int64_t dayoffset=0,
+                             int64_t biz=0):
+    cdef:
+        Py_ssize_t i, m1, m2, m3, y1, y2, y3, l1, l2, l3
+        int64_t us_in_day
+        ndarray[int64_t] dtindex
+        _TSObject ts
+
+    ts = convert_to_tsobject(start)
+
+    us_in_day = conversion_factor(r_microsecond, r_day)
+
+    dtindex = np.empty(periods, np.int64)
+
+    dayoffset *= us_in_day
+
+    dtindex[0] = ts.value + dayoffset
+    m1 = ts.dtval.month - 1
+    m2 = m1 + 1
+    m3 = m2 + 1
+    y3 = y2 = y1 = ts.dtval.year
+    l3 = l2 = l1 = is_leapyear(y1)
+
+    for i in range(1, periods):
+        if m3 >= 12:
+            m3 -= 12
+            y3 += 1
+            l3 = is_leapyear(y3)
+        if m2 >= 12:
+            m2 -= 12
+            y2 += 1
+            l2 = is_leapyear(y2)
+        if m1 >= 12:
+            m1 -= 12
+            y1 += 1
+            l1 = is_leapyear(y1)
+
+        dtindex[i] = (dtindex[i-1] +
+                      us_in_day * (_days_per_month_table[l1][m1] +
+                                   _days_per_month_table[l2][m2] +
+                                   _days_per_month_table[l3][m3]))
+        m1 += 3
+        m2 += 3
+        m3 += 3
+
+    return dtindex.view(np.datetime64)
+
+def generate_daily_range(object start, Py_ssize_t periods, int64_t biz=0):
+    pass
+
+
 # The following is derived from relativedelta.py in dateutil package
 # ------------------------------------------------------------------------------
 # Copyright (c) 2003-2010  Gustavo Niemeyer <gustavo@niemeyer.net>
@@ -546,7 +645,7 @@ cdef class Delta:
                 jumpdays *= -1
             ret += timedelta(days=jumpdays)
 
-        return ret
+        return Timestamp(ret)
 
     def __richcmp__(self, other, op):
         if op == 3:
@@ -658,7 +757,7 @@ cdef class Delta:
 
         if not isinstance(self, Delta):
             tmp = self
-            self = v 
+            self = v
             v = tmp
 
         f = v
@@ -847,28 +946,6 @@ def fast_field_accessor(ndarray[int64_t] dtindex, object field):
     else:
         raise ValueError("Field %s not supported; not in (Y,M,D,h,m,s,us)" % field)
 
-# Another accessor, for datetime object -
-# ------------------------------------------------------------------------------
-
-def fast_field_accessor2(ndarray[object] dtindex, object field):
-    '''
-    Given a int64-based datetime index, extract the year, month, etc.,
-    field and return an array of these values.
-    '''
-    cdef:
-        npy_datetimestruct dts
-        Py_ssize_t i, count = 0
-        ndarray[int32_t] out
-
-    count = len(dtindex)
-    out = np.empty(count, dtype='i4')
-
-    if field == 'Y':
-        for i in range(count):
-                out[i] = PyDateTime_GET_YEAR(dtindex[i])
-        return out
-    else:
-        raise ValueError("Field %s not supported; not in (Y,M,D,h,m,s,us)" % field)
 
 # Some general helper functions
 # ------------------------------------------------------------------------------
diff --git a/pandas/src/np_datetime.h b/pandas/src/np_datetime.h
index a6e4a9b30..c0f471b37 100644
--- a/pandas/src/np_datetime.h
+++ b/pandas/src/np_datetime.h
@@ -41,8 +41,8 @@ static char *_datetime_strings[NPY_DATETIME_NUMUNITS];
  */
 int
 convert_datetimestruct_to_datetime(PyArray_DatetimeMetaData *meta,
-                                    const npy_datetimestruct *dts,
-                                    npy_datetime *out);
+                                   const npy_datetimestruct *dts,
+                                   npy_datetime *out);
 
 /*
  * Calculates the days offset from the 1970 epoch.

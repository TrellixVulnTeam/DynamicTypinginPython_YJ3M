commit 6046cc708af2fb416a209fda3774ff16508a4840
Author: Adam Klein <adamklein@gmail.com>
Date:   Fri Feb 3 18:28:06 2012 -0500

    hacking on timestamp box

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index bdc8acec0..dda6e62b5 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -1,4 +1,4 @@
-# pylint: disable=E1101,E1103
+# pylint: disable=E1101,E110a
 
 from datetime import datetime
 import operator
@@ -7,7 +7,8 @@ import numpy as np
 
 from pandas.core.index import DatetimeIndex
 import pandas.core.datetools as datetools
-from pandas.core.datetools import _dt_box
+from pandas.core.datetools import _dt_box, _dt_unbox_array
+from pandas._tseries import Timestamp
 
 __all__ = ['DateRange']
 
@@ -22,8 +23,8 @@ def _bin_op(op):
 
     return f
 
-_CACHE_START = datetime(1950, 1, 1)
-_CACHE_END   = datetime(2030, 1, 1)
+_CACHE_START = Timestamp(datetime(1950, 1, 1))
+_CACHE_END   = Timestamp(datetime(2030, 1, 1))
 
 _daterange_cache = {}
 
@@ -70,11 +71,11 @@ class DateRange(DatetimeIndex):
         end = datetools.to_datetime(end)
 
         if (start is not None
-            and not isinstance(start, (datetime, np.datetime64))):
+            and not isinstance(start, (datetime, np.datetime64, Timestamp))):
             raise ValueError('Failed to convert %s to datetime' % start)
 
         if (end is not None
-            and not isinstance(end, (datetime, np.datetime64))):
+            and not isinstance(end, (datetime, np.datetime64, Timestamp))):
             raise ValueError('Failed to convert %s to datetime' % end)
 
         # inside cache range. Handle UTC case
@@ -97,7 +98,7 @@ class DateRange(DatetimeIndex):
         if tzinfo is not None:
             index = [d.replace(tzinfo=tzinfo) for d in index]
 
-        index = np.array(index, dtype='M8[us]', copy=False)
+        index = np.array(_dt_unbox_array(index), dtype='M8[us]', copy=False)
         index = index.view(cls)
         index.name = name
         index.offset = offset
@@ -142,6 +143,10 @@ class DateRange(DatetimeIndex):
     @classmethod
     def _cached_range(cls, start=None, end=None, periods=None, offset=None,
                       time_rule=None, name=None):
+        if start is not None:
+            start = Timestamp(start)
+        if end is not None:
+            end = Timestamp(end)
 
         # HACK: fix this dependency later
         if time_rule is not None:
@@ -152,7 +157,8 @@ class DateRange(DatetimeIndex):
 
         if offset not in _daterange_cache:
             xdr = generate_range(_CACHE_START, _CACHE_END, offset=offset)
-            arr = np.array(list(xdr), dtype='M8[us]', copy=False)
+            arr = np.array(_dt_unbox_array(list(xdr)), 
+                           dtype='M8[us]', copy=False)
 
             cachedRange = arr.view(DateRange)
             cachedRange.offset = offset
diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 0a22310ce..2ec113085 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -4,7 +4,6 @@ from datetime import datetime, timedelta
 import sys
 import numpy as np
 import pandas._tseries as lib
-import pandas._datetime as dtlib
 
 try:
     import dateutil
@@ -28,38 +27,42 @@ import calendar
 _unbox_cache = dict()
 def _dt_unbox(key):
     '''
-    Unbox python datetime to datetime64
+    Unbox Timestamp to datetime64
     '''
     try:
         return _unbox_cache[key]
     except KeyError:
-        _unbox_cache[key] = np.datetime64(dtlib.pydt_to_i8(key))
+        _unbox_cache[key] = np.datetime64(lib.pydt_to_i8(key))
         return _unbox_cache[key]
 
+def _dt_unbox_array(arr):
+    unboxer = np.frompyfunc(_dt_unbox, 1, 1)
+    return unboxer(arr).astype('M8[us]')
+
 _box_cache = dict()
 def _dt_box(key):
     '''
-    Box datetime64 to python datetime
+    Box datetime64 to Timestamp
     '''
     try:
         return _box_cache[key]
     except KeyError:
-        _box_cache[key] = dtlib.i8_to_pydt(key.view('i8'))
+        _box_cache[key] = lib.Timestamp(key.view('i8'))
         return _box_cache[key]
 
-dtdtype = [('Y', '>i4'), # year
-           ('M', '>i4'), # month
-           ('D', '>i4'), # day
-           ('h', '>i4'), # hour
-           ('m', '>i4'), # min
-           ('s', '>i4'), # second
-           ('u', '>i4')] # microsecond
+#dtdtype = [('Y', '>i4'), # year
+#           ('M', '>i4'), # month
+#           ('D', '>i4'), # day
+#           ('h', '>i4'), # hour
+#           ('m', '>i4'), # min
+#           ('s', '>i4'), # second
+#           ('u', '>i4')] # microsecond
 
-def _dt_arr_to_sarr(arr):
-    return np.array(map(lambda x: (x.year, x.month, x.day, x.hour,
-                                   x.minute, x.second, x.microsecond),
-                        arr),
-                    dtype=dtdtype)
+#def _dt_arr_to_sarr(arr):
+#    return np.array(map(lambda x: (x.year, x.month, x.day, x.hour,
+#                                   x.minute, x.second, x.microsecond),
+#                        arr),
+#                    dtype=dtdtype)
 
 #-------------------------------------------------------------------------------
 # Miscellaneous date functions
@@ -79,21 +82,23 @@ def ole2datetime(oledt):
     if val < 61:
         raise Exception("Value is outside of acceptable range: %s " % val)
 
-    return OLE_TIME_ZERO + timedelta(days=val)
+    return lib.Timestamp(OLE_TIME_ZERO + timedelta(days=val))
 
 def to_datetime(arg):
     """Attempts to convert arg to datetime"""
-    if arg is None or isinstance(arg, datetime):
+    if arg is None:
         return arg
+    elif isinstance(arg, datetime):
+        return lib.Timestamp(arg)
     try:
-        return parser.parse(arg)
+        return lib.Timestamp(parser.parse(arg))
     except Exception:
         return arg
 
 def normalize_date(dt):
     if isinstance(dt, np.datetime64):
         dt = _dt_box(dt)
-    return datetime(dt.year, dt.month, dt.day)
+    return lib.Timestamp(datetime(dt.year, dt.month, dt.day))
 
 #-------------------------------------------------------------------------------
 # DateOffset
@@ -302,7 +307,7 @@ class BDay(DateOffset, CacheableOffset):
         return (self.n == 1)
 
     def apply(self, other):
-        if isinstance(other, datetime):
+        if isinstance(other, (datetime, lib.Timestamp)):
             n = self.n
 
             if n == 0 and other.weekday() > 4:
@@ -317,7 +322,8 @@ class BDay(DateOffset, CacheableOffset):
                     n -= k
 
             if self.normalize:
-                result = datetime(result.year, result.month, result.day)
+                result = lib.Timestamp(datetime(result.year, result.month, 
+                                                result.day))
 
             if self.offset:
                 result = result + self.offset
@@ -489,7 +495,7 @@ class WeekOfMonth(DateOffset, CacheableOffset):
 
     def getOffsetOfMonth(self, someDate):
         w = Week(weekday=self.weekday)
-        d = datetime(someDate.year, someDate.month, 1)
+        d = lib.Timestamp(datetime(someDate.year, someDate.month, 1))
 
         d = w.rollforward(d)
 
@@ -629,7 +635,7 @@ class BYearEnd(DateOffset, CacheableOffset):
         other = other + relativedelta(years=years)
 
         _, days_in_month = calendar.monthrange(other.year, self.month)
-        result = datetime(other.year, self.month, days_in_month)
+        result = lib.Timestamp(datetime(other.year, self.month, days_in_month))
 
         if result.weekday() > 4:
             result = result - BDay()
@@ -643,7 +649,7 @@ class YearEnd(DateOffset, CacheableOffset):
     def apply(self, other):
         n = self.n
         if other.month != 12 or other.day != 31:
-            other = datetime(other.year - 1, 12, 31)
+            other = lib.Timestamp(datetime(other.year - 1, 12, 31))
             if n <= 0:
                 n = n + 1
         other = other + relativedelta(years=n)
@@ -661,7 +667,7 @@ class YearBegin(DateOffset, CacheableOffset):
     def apply(self, other):
         n = self.n
         if other.month != 1 or other.day != 1:
-            other = datetime(other.year, 1, 1)
+            other = lib.Timestamp(datetime(other.year, 1, 1))
             if n <= 0:
                 n = n + 1
         other = other + relativedelta(years = n, day=1)
@@ -687,7 +693,7 @@ class Tick(DateOffset):
         return self._delta
 
     def apply(self, other):
-        if isinstance(other, (datetime, timedelta)):
+        if isinstance(other, (datetime, timedelta, lib.Timestamp)):
             return other + self.delta
         elif isinstance(other, type(self)):
             return type(self)(self.n + other.n)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 2838b8f45..63c05cbc2 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -8,11 +8,10 @@ import numpy as np
 from pandas.core.common import (adjoin as _adjoin, _stringify, _try_sort,
                                 _is_bool_indexer, _asarray_tuplesafe,
                                 is_iterator)
-from pandas.core.datetools import _dt_box, _dt_unbox
+from pandas.core.datetools import _dt_box, _dt_unbox, _dt_unbox_array
 from pandas.util.decorators import cache_readonly
 import pandas._tseries as lib
 import pandas._engines as _gin
-import pandas._datetime as _dt
 
 from datetime import datetime
 
@@ -77,10 +76,14 @@ class Index(np.ndarray):
             # other iterable of some kind
             subarr = _asarray_tuplesafe(data, dtype=object)
 
-        if (dtype is None
-            and (lib.is_datetime_array(subarr)
-                 or lib.is_datetime64_array(subarr))):
-            return DatetimeIndex(subarr.astype('M8[us]'), name=name)
+        if dtype is None:
+            if (lib.is_datetime_array(subarr) or 
+                lib.is_datetime64_array(subarr)):
+                return DatetimeIndex(subarr.astype('M8[us]'), name=name)
+
+            elif lib.is_timestamp_array(subarr):
+                return DatetimeIndex(_dt_unbox_array(subarr).astype('M8[us]'), 
+                                    name=name)
 
         if lib.is_integer_array(subarr) and dtype is None:
             return Int64Index(subarr.astype('i8'), name=name)
@@ -98,7 +101,7 @@ class Index(np.ndarray):
 
     @property
     def year(self):
-        return _dt.fast_field_accessor2(self.values, 'Y')
+        return lib.fast_field_accessor2(self.values, 'Y')
 
     @property
     def dtype(self):
@@ -988,13 +991,6 @@ def _wrap_dt_function(f):
         return f(*view_args, **kwargs)
     return wrapper
 
-def _wrap_dt_function(f):
-    @staticmethod
-    def wrapper(*args, **kwargs):
-        view_args = [_dt_index_box(arg) for arg in args]
-        return f(*view_args, **kwargs)
-    return wrapper
-
 def _join_i8_wrapper(joinf, with_indexers=True):
     @staticmethod
     def wrapper(left, right):
@@ -1125,31 +1121,31 @@ class DatetimeIndex(Int64Index):
 
     @property
     def year(self):
-        return _dt.fast_field_accessor(self.values.view('i8'), 'Y')
+        return lib.fast_field_accessor(self.values.view('i8'), 'Y')
 
     @property
     def month(self):
-        return _dt.fast_field_accessor(self.values.view('i8'), 'M')
+        return lib.fast_field_accessor(self.values.view('i8'), 'M')
 
     @property
     def day(self):
-        return _dt.fast_field_accessor(self.values.view('i8'), 'D')
+        return lib.fast_field_accessor(self.values.view('i8'), 'D')
 
     @property
     def hour(self):
-        return _dt.fast_field_accessor(self.values.view('i8'), 'h')
+        return lib.fast_field_accessor(self.values.view('i8'), 'h')
 
     @property
     def minute(self):
-        return _dt.fast_field_accessor(self.values.view('i8'), 'm')
+        return lib.fast_field_accessor(self.values.view('i8'), 'm')
 
     @property
     def second(self):
-        return _dt.fast_field_accessor(self.values.view('i8'), 's')
+        return lib.fast_field_accessor(self.values.view('i8'), 's')
 
     @property
     def microsecond(self):
-        return _dt.fast_field_accessor(self.values.view('i8'), 'us')
+        return lib.fast_field_accessor(self.values.view('i8'), 'us')
 
     def __iter__(self):
         # TODO: expose elements as nice datetime objects so you can do obj.year
@@ -1160,8 +1156,8 @@ class DatetimeIndex(Int64Index):
         """
         Workaround numpy coredump in searchsorted
         """
-        if isinstance(key, datetime):
-            key = _dt_unbox(key)
+        if isinstance(key, (datetime, lib.Timestamp)):
+            key = _dt_unbox(lib.Timestamp(key))
         elif isinstance(key, np.ndarray):
             key = np.array(key, dtype='M8[us]', copy=False)
         elif not isinstance(key, np.datetime64):
@@ -2090,7 +2086,7 @@ class MultiIndex(Index):
         -------
         truncated : MultiIndex
         """
-        if after and before and after < before:
+        if after and before and before > after:
             raise ValueError('after < before')
 
         i, j = self.levels[0].slice_locs(before, after)
diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index ccb0d00ec..3faa370b4 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -94,4 +94,3 @@ cdef extern from "np_datetime_strings.h":
 
 cdef extern from "stdint.h":
     enum: INT64_MIN
-
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index ded544a52..afdaedcd3 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -9,7 +9,7 @@ from libc.math cimport floor
 
 # this is our datetime.pxd
 from datetime cimport *
-from util cimport is_integer_object
+from util cimport is_integer_object, is_datetime64_object
 
 # initialize numpy
 np.import_array()
@@ -33,23 +33,18 @@ ctypedef enum time_res:
     r_max = 98
     r_invalid = 99
 
-# Objects to support date/time arithmetic
-# --------------------------------------------------------------------------------
-
-cdef class Timestamp:
-    """
-    A timestamp (absolute moment in time) to microsecond resolution; number of
-    microseconds since the POSIX epoch, ignoring leap seconds (thereby different
-    from UTC).
-    """
+cdef class Timestamp(object):
+    # defined in header
     cdef:
-        int64_t value
-        npy_datetimestruct dts
+        datetime dtval      # datetime repr; normally would derive, just wrap
+        int64_t value       # numpy dt64
+        object freq         # dateoffset object
 
-    def __init__(self, object ts):
+    def __init__(self, object ts, object freq=None):
         """
         Construct a timestamp that is datetime64-compatible from any of:
-            - int64 pyarray scalar object
+            - np.int64
+            - np.datetime64
             - python int or long object
             - iso8601 string object
             - python datetime object
@@ -59,170 +54,360 @@ cdef class Timestamp:
             Py_ssize_t strlen
             npy_bool islocal, special
             NPY_DATETIMEUNIT out_bestunit
-
-        if is_integer_object(ts) or PyInt_Check(ts) or PyLong_Check(ts):
+            npy_datetimestruct dts
+            Timestamp tmp
+
+        self.freq = freq
+
+        # pretty expensive - faster way to access as i8?
+        if is_datetime64_object(ts):
+            self.value = ts.view('i8')
+            PyArray_DatetimeToDatetimeStruct(self.value, NPY_FR_us, &dts)
+            self.dtval = <object>PyDateTime_FromDateAndTime(
+                                dts.year, dts.month,
+                                dts.day, dts.hour,
+                                dts.min, dts.sec, dts.us)
+        # this is cheap
+        elif is_integer_object(ts) or PyInt_Check(ts) or PyLong_Check(ts):
             self.value = ts
-            PyArray_DatetimeToDatetimeStruct(self.value, NPY_FR_us, &self.dts)
+            PyArray_DatetimeToDatetimeStruct(self.value, NPY_FR_us, &dts)
+            self.dtval = <object>PyDateTime_FromDateAndTime(
+                                dts.year, dts.month,
+                                dts.day, dts.hour,
+                                dts.min, dts.sec, dts.us)
+        # this is pretty cheap
         elif PyString_Check(ts):
+            # we might want to fall back on dateutil parser?
             parse_iso_8601_datetime(ts, len(ts), NPY_FR_us, NPY_UNSAFE_CASTING,
-                                    &self.dts, &islocal, &out_bestunit, &special)
-            self.value = PyArray_DatetimeStructToDatetime(NPY_FR_us, &self.dts)
+                                    &dts, &islocal, &out_bestunit, &special)
+            self.value = PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts)
+            self.dtval = <object>PyDateTime_FromDateAndTime(
+                                dts.year, dts.month,
+                                dts.day, dts.hour,
+                                dts.min, dts.sec, dts.us)
+        # pretty cheap
         elif PyDateTime_Check(ts):
-            convert_pydatetime_to_datetimestruct(<PyObject *>ts, &self.dts,
-                                                 &out_bestunit, 1)
-            self.value = PyArray_DatetimeStructToDatetime(out_bestunit, &self.dts)
+            self.dtval = ts
+            # to do this is expensive (10x other constructors)
+            # convert_pydatetime_to_datetimestruct(<PyObject *>ts, &dts,
+            #                                     &out_bestunit, 0)
+            dts.year = PyDateTime_GET_YEAR(ts)
+            dts.month = PyDateTime_GET_MONTH(ts)
+            dts.day = PyDateTime_GET_DAY(ts)
+            dts.hour = PyDateTime_DATE_GET_HOUR(ts)
+            dts.min = PyDateTime_DATE_GET_MINUTE(ts)
+            dts.sec = PyDateTime_DATE_GET_SECOND(ts)
+            dts.us = PyDateTime_DATE_GET_MICROSECOND(ts)
+            self.value = PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts)
+        # pretty cheap
+        elif isinstance(ts, Timestamp):
+            tmp = ts
+            self.value = tmp.value
+            self.dtval = tmp.dtval
+            self.freq = tmp.freq
         else:
-            raise ValueError("Could not construct Timestamp from argument")
+            raise ValueError("Could not construct Timestamp from argument %s" % type(ts))
 
-    def __repr__(self):
-        return "Timestamp(%d)" % self.value
+    property asint:
+        def __get__(Timestamp self):
+            return self.value
 
-    def __hash__(self):
-        return hash(self.value)
+    property year:
+        def __get__(Timestamp self):
+            return self.dtval.year
 
-    def __sub__(self, object other):
-        """
-        Subtract two timestamps, results in an duration.
-        """
-        if isinstance(other, Timestamp):
-            return self.value - other.asint
-        elif isinstance(other, Delta):
-            return other.__sub__(self)
-        else:
-            raise NotImplementedError("Sub operation not supported")
+    property month:
+        def __get__(Timestamp self):
+            return self.dtval.month
+
+    property day:
+        def __get__(Timestamp self):
+            return self.dtval.day
+
+    property hour:
+        def __get__(Timestamp self):
+            return self.dtval.hour
+
+    property minute:
+        def __get__(Timestamp self):
+            return self.dtval.minute
+
+    property second:
+        def __get__(Timestamp self):
+            return self.dtval.second
+
+    property microsecond:
+        def __get__(Timestamp self):
+            return self.dtval.microsecond
+
+    property tzinfo:
+        def __get__(Timestamp self):
+            return self.dtval.tzinfo
+
+    def replace(Timestamp self, *args, **kwargs):
+        return Timestamp(self.dtval.replace(*args, **kwargs))
+
+    def __richcmp__(self, object other, int op):
+        cdef:
+            Timestamp tmp
 
-    def __richcmp__(Timestamp self, object other, int op):
         if not isinstance(other, Timestamp):
-            raise ValueError("Cannot compare to non-Timestamp")
+            other = Timestamp(other)
+
+        if not isinstance(self, Timestamp):
+            tmp = Timestamp(self)
+        else:
+            tmp = self
 
         if op == 0:
-            return self.value < other.asint
+            return tmp.value < other.asint
         if op == 2:
-            return self.value == other.asint
+            return tmp.value == other.asint
         if op == 4:
-            return self.value > other.asint
+            return tmp.value > other.asint
         if op == 1:
-            return self.value <= other.asint
+            return tmp.value <= other.asint
         if op == 3:
-            return self.value != other.asint
+            return tmp.value != other.asint
         if op == 5:
-            return self.value >= other.asint
+            return tmp.value >= other.asint
 
         raise NotImplementedError("Op %d not recognized" % op)
 
-    def __add__(self, object other):
-        """
-        Add an Interval, Duration, or Period to the Timestamp, resulting in
-        new Timestamp.
-        """
-        if isinstance(other, Duration):
-            return Timestamp(self.asint + other.length)
-        elif isinstance(other, Delta):
-            return other.__add__(self)
-        else:
-            raise NotImplementedError("Add operation not supported")
-
-    def __str__(self):
-        """
-        Output ISO8601 format string representation of timestamp.
-        """
+    def __add__(self, other):
         cdef:
-            int outlen
-            char *isostr
-            bytes py_str
-
-        outlen = get_datetime_iso_8601_strlen(0, NPY_FR_us)
+            Timestamp tmp
 
-        isostr = <char *>malloc(outlen)
-        make_iso_8601_datetime(&self.dts, isostr, outlen, 0, NPY_FR_us,
-                               0, NPY_UNSAFE_CASTING)
-        py_str = isostr
-        free(isostr)
+        if isinstance(self, Timestamp):
+            tmp = self
+            result = tmp.dtval + other
+        else:
+            tmp = other
+            result = tmp.dtval + self
 
-        return py_str
+        return Timestamp(result)
 
-    def replace(Timestamp self, int year=-1, int month=-1, int day=-1,
-                                int hour=-1, int minute=-1, int second=-1,
-                                int microsecond=-1):
-        cdef:
-            npy_datetimestruct dts
-
-        dts = self.dts
-
-        if year >= 0:
-            dts.year = year
-        if month >= 1:
-            dts.month = month
-        if day >= 1:
-            dts.day = day
-        if hour >= 0:
-            dts.hour = hour
-        if minute >= 0:
-            dts.min = minute
-        if second >= 0:
-            dts.sec = second
-        if microsecond >= 0:
-            dts.us = microsecond
-
-        return Timestamp(PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts))
-
-    cdef normalize(Timestamp self, time_res res):
+    def __sub__(self, other):
         cdef:
-            npy_datetimestruct dts
+            Timestamp tmp
 
-        dts = self.dts
-
-        if res > r_microsecond:
-            dts.us = 0
-        if res > r_second:
-            dts.sec = 0
-        if res > r_minute:
-            dts.min = 0
-        if res > r_hour:
-            dts.hour = 0
-        if res > r_day:
-            dts.day = 1
-        if res > r_month:
-            dts.month = 1
-        if res > r_year:
-            raise ValueError("Invalid resolution")
-
-        return Timestamp(PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts))
+        if isinstance(self, Timestamp):
+            tmp = self
+            result = tmp.dtval - other
+        else:
+            tmp = other
+            result = tmp.dtval - self
 
-    property asint:
-        def __get__(Timestamp self):
-            return self.value
+        return Timestamp(result)
 
-    property year:
-        def __get__(Timestamp self):
-            return self.dts.year
+    def __hash__(Timestamp self):
+        return self.value
 
-    property month:
-        def __get__(Timestamp self):
-            return self.dts.month
+    def __str__(Timestamp self):
+        return self.dtval.__str__()
 
-    property day:
-        def __get__(Timestamp self):
-            return self.dts.day
+    def __repr__(Timestamp self):
+        return 'Timestamp(%s)' % self.dtval.__repr__()
 
-    property hour:
-        def __get__(Timestamp self):
-            return self.dts.hour
+    def strftime(Timestamp self, object fmtstr):
+        return self.dtval.strftime(fmtstr)
 
-    property minute:
-        def __get__(Timestamp self):
-            return self.dts.min
+    def weekday(Timestamp self):
+        return dayofweek(self.dtval.year, self.dtval.month, self.dtval.day)
 
-    property second:
-        def __get__(Timestamp self):
-            return self.dts.sec
+    #def __getattr__(self, object attrib):
+    #    return getattr(self.dtval, attrib)
 
-    property microsecond:
-        def __get__(Timestamp self):
-            return self.dts.us
+# Objects to support date/time arithmetic
+# --------------------------------------------------------------------------------
 
-    def weekday(Timestamp self):
-        return dayofweek(self.dts.year, self.dts.month, self.dts.day)
+#cdef class Timestamp:
+#    """
+#    A timestamp (absolute moment in time) to microsecond resolution; number of
+#    microseconds since the POSIX epoch, ignoring leap seconds (thereby different
+#    from UTC).
+#    """
+#    cdef:
+#        int64_t value
+#        npy_datetimestruct dts
+
+#    def __init__(self, object ts):
+#        """
+#        Construct a timestamp that is datetime64-compatible from any of:
+#            - int64 pyarray scalar object
+#            - python int or long object
+#            - iso8601 string object
+#            - python datetime object
+#            - another timestamp object
+#        """
+#        cdef:
+#            Py_ssize_t strlen
+#            npy_bool islocal, special
+#            NPY_DATETIMEUNIT out_bestunit
+
+#        if is_integer_object(ts) or PyInt_Check(ts) or PyLong_Check(ts):
+#            self.value = ts
+#            PyArray_DatetimeToDatetimeStruct(self.value, NPY_FR_us, &self.dts)
+#        elif PyString_Check(ts):
+#            parse_iso_8601_datetime(ts, len(ts), NPY_FR_us, NPY_UNSAFE_CASTING,
+#                                    &self.dts, &islocal, &out_bestunit, &special)
+#            self.value = PyArray_DatetimeStructToDatetime(NPY_FR_us, &self.dts)
+#        elif PyDateTime_Check(ts):
+#            convert_pydatetime_to_datetimestruct(<PyObject *>ts, &self.dts,
+#                                                 &out_bestunit, 1)
+#            self.value = PyArray_DatetimeStructToDatetime(out_bestunit, &self.dts)
+#        else:
+#            raise ValueError("Could not construct Timestamp from argument")
+
+#    def __repr__(self):
+#        return "Timestamp(%d)" % self.value
+
+#    def __hash__(self):
+#        return hash(self.value)
+
+#    def __sub__(self, object other):
+#        """
+#        Subtract two timestamps, results in an duration.
+#        """
+#        if isinstance(other, Timestamp):
+#            return self.value - other.asint
+#        elif isinstance(other, Delta):
+#            return other.__sub__(self)
+#        else:
+#            raise NotImplementedError("Sub operation not supported")
+
+#    def __richcmp__(Timestamp self, object other, int op):
+#        if not isinstance(other, Timestamp):
+#            raise ValueError("Cannot compare to non-Timestamp")
+
+#        if op == 0:
+#            return self.value < other.asint
+#        if op == 2:
+#            return self.value == other.asint
+#        if op == 4:
+#            return self.value > other.asint
+#        if op == 1:
+#            return self.value <= other.asint
+#        if op == 3:
+#            return self.value != other.asint
+#        if op == 5:
+#            return self.value >= other.asint
+
+#        raise NotImplementedError("Op %d not recognized" % op)
+
+#    def __add__(self, object other):
+#        """
+#        Add an Interval, Duration, or Period to the Timestamp, resulting in
+#        new Timestamp.
+#        """
+#        if isinstance(other, Duration):
+#            return Timestamp(self.asint + other.length)
+#        elif isinstance(other, Delta):
+#            return other.__add__(self)
+#        else:
+#            raise NotImplementedError("Add operation not supported")
+
+#    def __str__(self):
+#        """
+#        Output ISO8601 format string representation of timestamp.
+#        """
+#        cdef:
+#            int outlen
+#            char *isostr
+#            bytes py_str
+
+#        outlen = get_datetime_iso_8601_strlen(0, NPY_FR_us)
+
+#        isostr = <char *>malloc(outlen)
+#        make_iso_8601_datetime(&self.dts, isostr, outlen, 0, NPY_FR_us,
+#                               0, NPY_UNSAFE_CASTING)
+#        py_str = isostr
+#        free(isostr)
+
+#        return py_str
+
+#    def replace(Timestamp self, int year=-1, int month=-1, int day=-1,
+#                                int hour=-1, int minute=-1, int second=-1,
+#                                int microsecond=-1):
+#        cdef:
+#            npy_datetimestruct dts
+
+#        dts = self.dts
+
+#        if year >= 0:
+#            dts.year = year
+#        if month >= 1:
+#            dts.month = month
+#        if day >= 1:
+#            dts.day = day
+#        if hour >= 0:
+#            dts.hour = hour
+#        if minute >= 0:
+#            dts.min = minute
+#        if second >= 0:
+#            dts.sec = second
+#        if microsecond >= 0:
+#            dts.us = microsecond
+
+#        return Timestamp(PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts))
+
+#    cdef normalize(Timestamp self, time_res res):
+#        cdef:
+#            npy_datetimestruct dts
+
+#        dts = self.dts
+
+#        if res > r_microsecond:
+#            dts.us = 0
+#        if res > r_second:
+#            dts.sec = 0
+#        if res > r_minute:
+#            dts.min = 0
+#        if res > r_hour:
+#            dts.hour = 0
+#        if res > r_day:
+#            dts.day = 1
+#        if res > r_month:
+#            dts.month = 1
+#        if res > r_year:
+#            raise ValueError("Invalid resolution")
+
+#        return Timestamp(PyArray_DatetimeStructToDatetime(NPY_FR_us, &dts))
+
+#    property asint:
+#        def __get__(Timestamp self):
+#            return self.value
+
+#    property year:
+#        def __get__(Timestamp self):
+#            return self.dts.year
+
+#    property month:
+#        def __get__(Timestamp self):
+#            return self.dts.month
+
+#    property day:
+#        def __get__(Timestamp self):
+#            return self.dts.day
+
+#    property hour:
+#        def __get__(Timestamp self):
+#            return self.dts.hour
+
+#    property minute:
+#        def __get__(Timestamp self):
+#            return self.dts.min
+
+#    property second:
+#        def __get__(Timestamp self):
+#            return self.dts.sec
+
+#    property microsecond:
+#        def __get__(Timestamp self):
+#            return self.dts.us
+
+#    def weekday(Timestamp self):
+#        return dayofweek(self.dts.year, self.dts.month, self.dts.day)
 
 
 cdef class Duration:
@@ -821,32 +1006,21 @@ def pydt_to_i8(object pydt):
     numpy datetime64; converts to UTC
     '''
     cdef:
-        npy_datetimestruct dts
-        NPY_DATETIMEUNIT out_bestunit
+        Timestamp ts
 
-    if PyDateTime_Check(pydt):
-        # TODO: this function can prob be optimized
-        convert_pydatetime_to_datetimestruct(<PyObject *>pydt, &dts,
-                                             &out_bestunit, 1)
+    if (not PyDateTime_Check(pydt) and
+        not isinstance(pydt, Timestamp)):
+        raise ValueError("Expected a timestamp, received a %s" % type(pydt))
 
-        return PyArray_DatetimeStructToDatetime(out_bestunit, &dts)
+    ts = Timestamp(pydt)
 
-    raise ValueError("Expected a datetime, received a %s" % type(pydt))
+    return ts.value
 
 def i8_to_pydt(int64_t i8, object tzinfo = None):
     '''
     Inverse of pydt_to_i8
     '''
-    cdef:
-        npy_datetimestruct dts
-        object result
-
-    PyArray_DatetimeToDatetimeStruct(i8, NPY_FR_us, &dts)
-
-    result = <object>PyDateTime_FromDateAndTime(dts.year, dts.month, dts.day,
-                                                dts.hour, dts.min, dts.sec, dts.us)
-
-    return result
+    return Timestamp(i8)
 
 
 # Accessors
diff --git a/pandas/src/inference.pyx b/pandas/src/inference.pyx
index 044862b27..86643d1d2 100644
--- a/pandas/src/inference.pyx
+++ b/pandas/src/inference.pyx
@@ -85,6 +85,9 @@ def infer_dtype_list(list values):
 cdef inline bint is_datetime(object o):
     return PyDateTime_Check(o)
 
+cdef inline bint is_timestamp(object o):
+    return isinstance(o, Timestamp)
+
 cpdef is_array(object o):
     return np.PyArray_Check(o)
 
@@ -184,6 +187,15 @@ def is_datetime_array(ndarray[object] values):
             return False
     return True
 
+def is_timestamp_array(ndarray[object] values):
+    cdef int i, n = len(values)
+    if n == 0:
+        return False
+    for i in range(n):
+        if not is_timestamp(values[i]):
+            return False
+    return True
+
 def is_datetime64_array(ndarray values):
     cdef int i, n = len(values)
     if n == 0:
diff --git a/pandas/src/tseries.pyx b/pandas/src/tseries.pyx
index 57d693018..1010b90fc 100644
--- a/pandas/src/tseries.pyx
+++ b/pandas/src/tseries.pyx
@@ -450,6 +450,7 @@ def has_infs_f8(ndarray[float64_t] arr):
 #             return obj
 #         return self.factory(obj)
 
+include "datetime.pyx"
 include "skiplist.pyx"
 include "groupby.pyx"
 include "moments.pyx"
diff --git a/pandas/tests/test_datetools.py b/pandas/tests/test_datetools.py
index e78c3ec04..9073d030e 100644
--- a/pandas/tests/test_datetools.py
+++ b/pandas/tests/test_datetools.py
@@ -11,14 +11,13 @@ from pandas.core.datetools import (
 
 from nose.tools import assert_raises
 
-import pandas._datetime as dtlib
-from pandas._datetime import Timestamp, Delta
+import pandas._tseries as lib
 
 def test_monthrange():
     import calendar
     for y in range(2000,2013):
         for m in range(1,13):
-            assert dtlib.monthrange(y,m) == calendar.monthrange(y,m)
+            assert lib.monthrange(y,m) == calendar.monthrange(y,m)
 
 ####
 ## Misc function tests
diff --git a/setup.py b/setup.py
index e59602e7e..dd3298d5a 100755
--- a/setup.py
+++ b/setup.py
@@ -345,7 +345,9 @@ else:
 
 tseries_ext = Extension('pandas._tseries',
                         depends=tseries_depends + ['pandas/src/numpy_helper.h'],
-                        sources=[srcpath('tseries', suffix=suffix)],
+                        sources=[srcpath('tseries', suffix=suffix),
+                                 'pandas/src/np_datetime.c',
+                                 'pandas/src/np_datetime_strings.c'],
                         include_dirs=[np.get_include()],
                         pyrex_gdb=True,
                         # extra_compile_args=['-Wconversion']
@@ -364,12 +366,6 @@ sandbox_ext = Extension('pandas._sandbox',
                         sources=[srcpath('sandbox', suffix=suffix)],
                         include_dirs=[np.get_include()])
 
-datetime_ext = Extension('pandas._datetime',
-                         sources=[srcpath('datetime', suffix=suffix),
-                                          'pandas/src/np_datetime.c',
-                                          'pandas/src/np_datetime_strings.c'],
-                         include_dirs=[np.get_include(),
-                                       'pandas/src/timeseries'])
 skts_ext = Extension('pandas._skts',
                      sources= [os.path.join('pandas/src/timeseries', x)
                                for x in ('c_lib.c',
@@ -384,7 +380,7 @@ cppsandbox_ext = Extension('pandas._cppsandbox',
                            sources=[srcpath('cppsandbox', suffix=suffix)],
                            include_dirs=[np.get_include()])
 
-extensions = [tseries_ext, engines_ext, sparse_ext, datetime_ext, skts_ext]
+extensions = [tseries_ext, engines_ext, sparse_ext, skts_ext]
 
 if not ISRELEASED:
     extensions.extend([sandbox_ext])

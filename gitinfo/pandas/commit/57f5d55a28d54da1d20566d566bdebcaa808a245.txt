commit 57f5d55a28d54da1d20566d566bdebcaa808a245
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Apr 22 20:42:29 2012 -0400

    ENH: refactoring toward #1064, but broke something

diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 1682a43f7..8fb91a1c9 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -165,7 +165,7 @@ class PandasObject(Picklable):
                               axis=self.index, kind=kind)
 
         # since binner extends endpoints
-        if len(grouper.binner) - 2 <= len(idx):
+        if len(grouper.bins) <= len(idx):
             # down- or re-sampling
             grouped  = self.groupby(grouper, axis=axis, as_index=as_index)
             result = grouped.agg(how)
diff --git a/pandas/tseries/resample.py b/pandas/tseries/resample.py
index 348be998d..3d5a25f78 100644
--- a/pandas/tseries/resample.py
+++ b/pandas/tseries/resample.py
@@ -36,23 +36,17 @@ class TimeGrouper(BinGrouper):
     begin = None
     end = None
     nperiods = None
-    binner = None
 
     def __init__(self, offset='Min', closed='left', label='left',
                  begin=None, end=None, nperiods=None, axis=None,
                  kind=None):
-        if isinstance(offset, basestring):
-            offset = to_offset(offset)
-
-        if not isinstance(offset, DateOffset):
-            raise ValueError("Rule not a recognized offset")
-
         self.offset = offset
         self.closed = closed
         self.label = label
         self.begin = begin
         self.end = end
         self.nperiods = None
+        self.kind = kind
 
         if axis is not None:
             self.set_axis(axis)
@@ -67,28 +61,68 @@ class TimeGrouper(BinGrouper):
         self.axis = axis
 
         if len(self.axis) < 1:
+            # TODO: Should we be a bit more careful here?
             self.bins = []
             self.binlabels = []
             return
 
         if isinstance(self.axis, DatetimeIndex):
-            self.binner = _generate_time_binner(self.axis, self.offset,
-                                                self.begin, self.end,
-                                                self.nperiods)
+            self.bins, self.binlabels = self._group_timestamps()
+        elif isinstance(self.axis, PeriodIndex):
+            self.bins, self.binlabels = self._group_periods()
+        else:
+            raise ValueError('Invalid index: %s' % type(self.axis))
+
+    def _group_timestamps(self):
+        if self.kind is None or self.kind == 'timestamp':
+            binner = _generate_time_binner(self.axis, self.offset,
+                                           self.begin, self.end,
+                                           self.nperiods)
 
             int_axis = self.axis.asi8
-            int_binner = com._ensure_int64(self.binner)
+            int_binner = com._ensure_int64(binner)
 
             # general version, knowing nothing about relative frequencies
             bins, labels = lib.generate_bins_dt64(int_axis, int_binner,
                                                   self.closed, self.label)
+            return bins, labels.view('M8[us]')
+        elif self.kind == 'period':
+            index = PeriodIndex(start=self.axis[0], end=self.axis[-1],
+                                freq=self.offset)
 
-            self.bins = bins
-            self.binlabels = labels.view('M8[us]')
-        elif isinstance(self.axis, PeriodIndex):
-            pass
+            end_stamps = (index + 1).asfreq('D', 's').to_timestamp()
+            bins = self.axis.searchsorted(end_stamps, side='left')
+
+            return bins, index
+
+    def _group_periods(self):
+        raise NotImplementedError
+
+    def _generate_time_binner(self):
+        offset = self.offset
+        if isinstance(offset, basestring):
+            offset = to_offset(offset)
+
+        if not isinstance(offset, DateOffset):
+            raise ValueError("Rule not a recognized offset")
+
+        if self.begin is None:
+            first = Timestamp(self.axis[0] - self.offset)
         else:
-            raise ValueError('Invalid index: %s' % type(self.axis))
+            first = Timestamp(self.offset.rollback(self.begin))
+
+        if self.end is None:
+            last = Timestamp(self.axis[-1] + self.offset)
+        else:
+            last = Timestamp(self.offset.rollforward(self.end))
+
+        if isinstance(offset, Tick):
+            return np.arange(first.value, last.value + 1,
+                             self.offset.us_stride(), dtype=np.int64)
+
+        result = DatetimeIndex(freq=offset, start=first, end=last,
+                               periods=self.nperiods)
+        return result.asi8
 
 
     @property
@@ -133,22 +167,14 @@ def _generate_time_binner(dtindex, offset, begin=None, end=None, nperiods=None):
 
 def _generate_period_binner(dtindex, offset, begin=None, end=None,
                             nperiods=None):
-    if isinstance(offset, basestring):
-        offset = to_offset(offset)
-
-    if begin is None:
-        first = Timestamp(dtindex[0] - offset)
-    else:
-        first = Timestamp(offset.rollback(begin))
-
-    if end is None:
-        last = Timestamp(dtindex[-1] + offset)
-    else:
-        last = Timestamp(offset.rollforward(end))
+    # if isinstance(offset, basestring):
+    #     offset = to_offset(offset)
 
-    if isinstance(offset, Tick):
-        return np.arange(first.value, last.value+1, offset.us_stride(),
-                         dtype=np.int64)
+    first = dtindex[0]
+    last = dtindex[-1]
+    # if isinstance(offset, Tick):
+    #     return np.arange(first.value, last.value+1, offset.us_stride(),
+    #                      dtype=np.int64)
 
-    return DatetimeIndex(freq=offset, start=first, end=last, periods=nperiods)
+    return PeriodIndex(freq=offset, start=first, end=last, periods=nperiods)
 
diff --git a/pandas/tseries/tests/test_resample.py b/pandas/tseries/tests/test_resample.py
index 85928c4e0..8177ac215 100644
--- a/pandas/tseries/tests/test_resample.py
+++ b/pandas/tseries/tests/test_resample.py
@@ -4,7 +4,9 @@ import numpy as np
 
 from pandas import Series, DataFrame
 
+from pandas.tseries.index import date_range
 from pandas.tseries.offsets import Minute
+from pandas.tseries.period import period_range
 from pandas.tseries.resample import DatetimeIndex, TimeGrouper
 
 import unittest
@@ -153,8 +155,32 @@ class TestResample(unittest.TestCase):
         dti = DatetimeIndex(start=datetime(2005,1,1), end=datetime(2005,1,10),
                             freq='D')
         s = Series(np.random.rand(len(dti)), dti)
-        s = s.convert('B').convert('8H')
-        self.assertEquals(len(s), 22)
+        result = s.convert('B').convert('8H')
+        self.assertEquals(len(result), 22)
+
+    def test_resample_timestamp_to_period(self):
+        ts = _simple_ts('1/1/1990', '1/1/2000')
+
+        result = ts.convert('A-DEC', kind='period')
+        expected = ts.convert('A-DEC')
+        expected.index = period_range('1990', '2000', freq='a-dec')
+        assert_series_equal(result, expected)
+
+        result = ts.convert('M', kind='period')
+        expected = ts.convert('M')
+        expected.index = period_range('1990-01', '2000-01', freq='M')
+        assert_series_equal(result, expected)
+
+        result = ts.convert('BM', kind='period')
+        expected = ts.convert('BM')
+        expected.index = period_range('1990-01', '2000-01', freq='M')
+        assert_series_equal(result, expected)
+
+
+def _simple_ts(start, end, freq='D'):
+    rng = date_range(start, end, freq=freq)
+    return Series(np.random.randn(len(rng)), index=rng)
+
 
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 12adcfb19..80e4814ad 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -700,10 +700,8 @@ class TestDatetime64(unittest.TestCase):
     def setUp(self):
         dti = DatetimeIndex(start=datetime(2005,1,1),
                             end=datetime(2005,1,10), freq='Min')
-
         self.series = Series(rand(len(dti)), dti)
 
-
     def test_datetimeindex_accessors(self):
         dti = DatetimeIndex(freq='Q-JAN', start=datetime(1997,12,31),
                             periods=100)

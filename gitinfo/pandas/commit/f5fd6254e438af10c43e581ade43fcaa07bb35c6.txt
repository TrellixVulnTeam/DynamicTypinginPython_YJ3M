commit f5fd6254e438af10c43e581ade43fcaa07bb35c6
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Jun 7 23:30:28 2011 +0200

    trim trim trim. DataFrame unit tests still run. basic block structure prototype looking good, much implementation work remains...

diff --git a/pandas/core/common.py b/pandas/core/common.py
index 0dbcbb8ce..86d7d1d7a 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -149,3 +149,27 @@ def _try_sort(iterable):
         return sorted(listed)
     except Exception:
         return listed
+
+
+def _pfixed(s, space, nanRep=None, float_format=None):
+    if isinstance(s, float):
+        if nanRep is not None and isnull(s):
+            if np.isnan(s):
+                s = nanRep
+            return (' %s' % s).ljust(space)
+
+        if float_format:
+            formatted = float_format(s)
+        else:
+            is_neg = s < 0
+            formatted = '%.4g' % np.abs(s)
+
+            if is_neg:
+                formatted = '-' + formatted
+            else:
+                formatted = ' ' + formatted
+
+        return formatted.ljust(space)
+    else:
+        return (' %s' % s)[:space].ljust(space)
+
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 59df9ffd0..eb4b44f0b 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -12,7 +12,8 @@ import numpy as np
 
 from pandas.core.common import (_pickle_array, _unpickle_array, isnull, notnull,
                                 _check_step, _is_list_like, _need_slice,
-                                _is_label_slice, _ensure_index)
+                                _is_label_slice, _ensure_index, _try_sort,
+                                _pfixed)
 from pandas.core.daterange import DateRange
 from pandas.core.generic import PandasGeneric
 from pandas.core.index import Index, NULL_INDEX
@@ -123,10 +124,9 @@ class DataFrame(PandasGeneric):
 
     def __init__(self, data=None, index=None, columns=None, dtype=None):
         if isinstance(data, dict):
-            sdict, columns, index = self._init_dict(data, index, columns, dtype)
+            sdict, columns, index = _init_dict(data, index, columns, dtype)
         elif isinstance(data, (np.ndarray, list)):
-            sdict, columns, index = self._init_matrix(data, index, columns,
-                                                      dtype)
+            sdict, columns, index = _init_matrix(data, index, columns, dtype)
         elif isinstance(data, DataFrame):
             sdict = data._series.copy()
 
@@ -150,67 +150,6 @@ class DataFrame(PandasGeneric):
         self.columns = columns
         self.index = index
 
-    def _init_dict(self, data, index, columns, dtype):
-        # pre-filter out columns if we passed it
-        if columns is not None:
-            columns = _ensure_index(columns)
-            data = dict((k, v) for k, v in data.iteritems() if k in columns)
-        else:
-            columns = Index(_try_sort(data.keys()))
-
-        index = extract_index(data, index)
-
-        sdict = {}
-        for k, v in data.iteritems():
-            if isinstance(v, Series):
-                # Forces alignment and copies data
-                sdict[k] = v.reindex(index)
-            else:
-                if isinstance(v, dict):
-                    v = [v.get(i, NaN) for i in index]
-
-                try:
-                    v = Series(v, dtype=dtype, index=index)
-                except Exception:
-                    v = Series(v, index=index)
-
-                sdict[k] = v.copy()
-
-        # add in any other columns we want to have (completeness)
-        for c in columns:
-            if c not in sdict:
-                sdict[c] = Series(np.NaN, index=index)
-
-        return sdict, columns, index
-
-    def _init_matrix(self, data, index, columns, dtype):
-        if not isinstance(data, np.ndarray):
-            arr = np.array(data)
-            if issubclass(arr.dtype.type, basestring):
-                arr = np.array(data, dtype=object, copy=True)
-
-            data = arr
-
-        if data.ndim == 1:
-            data = data.reshape((len(data), 1))
-        elif data.ndim != 2:
-            raise Exception('Must pass 2-d input!')
-
-        N, K = data.shape
-
-        if index is None:
-            index = _default_index(N)
-
-        if columns is None:
-            columns = _default_index(K)
-
-        if len(columns) != K:
-            raise Exception('Column length mismatch: %d vs. %d' %
-                            (len(columns), K))
-
-        data = dict([(idx, data[:, i]) for i, idx in enumerate(columns)])
-        return self._init_dict(data, index, columns, dtype)
-
     @property
     def _constructor(self):
         return DataFrame
@@ -753,7 +692,7 @@ class DataFrame(PandasGeneric):
         """Output a tab-separated version of this DataFrame"""
         series = self._series
         if columns is None:
-            columns = self._output_columns()
+            columns = self.columns
         else:
             columns = [c for c in columns if c in self]
 
@@ -793,9 +732,6 @@ class DataFrame(PandasGeneric):
                                   float_format=float_format)
                 print >> buf, ot
 
-    def _output_columns(self):
-        return list(self.columns)
-
     def head(self):
         return self[:5]
 
@@ -2489,33 +2425,93 @@ def _check_data_types(data):
         raise Exception('Cannot mix Series / dict objects'
                         ' with ndarray / sequence input')
 
-def _default_index(n):
-    if n == 0:
-        return NULL_INDEX
-    else:
-        return np.arange(n)
+def _init_matrix(data, index, columns, dtype):
+    if not isinstance(data, np.ndarray):
+        arr = np.array(data)
+        if issubclass(arr.dtype.type, basestring):
+            arr = np.array(data, dtype=object, copy=True)
 
-def _pfixed(s, space, nanRep=None, float_format=None):
-    if isinstance(s, float):
-        if nanRep is not None and isnull(s):
-            if np.isnan(s):
-                s = nanRep
-            return (' %s' % s).ljust(space)
+        data = arr
 
-        if float_format:
-            formatted = float_format(s)
-        else:
-            is_neg = s < 0
-            formatted = '%.4g' % np.abs(s)
+    if data.ndim == 1:
+        data = data.reshape((len(data), 1))
+    elif data.ndim != 2:
+        raise Exception('Must pass 2-d input!')
+
+    N, K = data.shape
+
+    if index is None:
+        index = _default_index(N)
+
+    if columns is None:
+        columns = _default_index(K)
+
+    if len(columns) != K:
+        raise Exception('Column length mismatch: %d vs. %d' %
+                        (len(columns), K))
 
-            if is_neg:
-                formatted = '-' + formatted
+    data = dict([(idx, data[:, i]) for i, idx in enumerate(columns)])
+    return _init_dict(data, index, columns, dtype)
+
+def _init_dict(data, index, columns, dtype):
+    # pre-filter out columns if we passed it
+    if columns is not None:
+        columns = _ensure_index(columns)
+        data = dict((k, v) for k, v in data.iteritems() if k in columns)
+    else:
+        columns = Index(_try_sort(data.keys()))
+
+    if index is None:
+        index = extract_index(data)
+
+    sdict = _homogenize_series(data, index, dtype, force_copy=True)
+    # add in any other columns we want to have (completeness)
+    for c in columns:
+        if c not in sdict:
+            sdict[c] = Series(np.NaN, index=index)
+
+    return sdict, columns, index
+
+def _homogenize_series(data, index, dtype=None, force_copy=True):
+    homogenized = {}
+
+    for k, v in data.iteritems():
+        if isinstance(v, Series):
+            if v.index is not index:
+                # Forces alignment. No need to copy data since we
+                # are putting it into an ndarray later
+                v = v.reindex(index)
+            elif force_copy:
+                # same index, but want to copy
+                v = v.copy()
+        else:
+            if isinstance(v, dict):
+                v = [v.get(i, NaN) for i in index]
             else:
-                formatted = ' ' + formatted
+                assert(len(v) == len(index))
+            try:
+                v = Series(v, dtype=dtype, index=index)
+            except Exception:
+                v = Series(v, index=index)
+
+            if force_copy:
+                v = v.copy()
+
+        # OK, I will relent for now.
+        if not issubclass(v.dtype.type, (float, int)):
+        #     v = v.astype(np.float64)
+        # else:
+            v = v.astype(object)
+
+        homogenized[k] = v
 
-        return formatted.ljust(space)
+    return homogenized
+
+def _default_index(n):
+    if n == 0:
+        return NULL_INDEX
     else:
-        return (' %s' % s)[:space].ljust(space)
+        return np.arange(n)
 
 def _put_str(s, space):
     return ('%s' % s)[:space].ljust(space)
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index e08dfa79a..384012d94 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -8,9 +8,10 @@ from numpy import NaN
 import numpy as np
 
 from pandas.core.common import (_pickle_array, _unpickle_array, _try_sort)
-from pandas.core.frame import (DataFrame, extract_index,
+from pandas.core.frame import (DataFrame, extract_index, _homogenize_series,
                                _default_index, _ensure_index)
 from pandas.core.index import Index, NULL_INDEX
+from pandas.core.proto import BlockManager
 from pandas.core.series import Series
 import pandas.core.common as common
 import pandas.core.datetools as datetools
@@ -45,16 +46,20 @@ class DataMatrix(DataFrame):
     """
     objects = None
     def __init__(self, data=None, index=None, columns=None):
+        if isinstance(data, BlockManager):
+            mgr = data
+            index = data.index
+            columns = data.columns
         if isinstance(data, dict) and len(data) > 0:
-            index, columns, block_manager = _init_dict(data, index, columns)
+            index, columns, mgr = _init_dict(data, index, columns)
         elif isinstance(data, (np.ndarray, list)):
-            index, columns, block_manager = _init_matrix(data, index, columns)
+            index, columns, mgr = _init_matrix(data, index, columns)
         elif data is None or len(data) == 0:
             raise Exception('TODO!')
         else:
             raise Exception('DataMatrix constructor not properly called!')
 
-        self._data = block_manager
+        self._data = mgr
         self.index = index
         self.columns = columns
 
@@ -66,37 +71,6 @@ class DataMatrix(DataFrame):
 
     values = property(fget=_get_values)
 
-    def _init_matrix(self, values, index, columns, dtype):
-        if not isinstance(values, np.ndarray):
-            arr = np.array(values)
-            if issubclass(arr.dtype.type, basestring):
-                arr = np.array(values, dtype=object, copy=True)
-
-            values = arr
-
-        if values.ndim == 1:
-            N = values.shape[0]
-            if N == 0:
-                values = values.reshape((values.shape[0], 0))
-            else:
-                values = values.reshape((values.shape[0], 1))
-
-        if dtype is not None:
-            try:
-                values = values.astype(dtype)
-            except Exception:
-                pass
-
-        N, K = values.shape
-
-        if index is None:
-            index = _default_index(N)
-
-        if columns is None:
-            columns = _default_index(K)
-
-        return index, columns, values
-
     @property
     def _constructor(self):
         return DataMatrix
@@ -110,6 +84,7 @@ class DataMatrix(DataFrame):
 #-------------------------------------------------------------------------------
 # DataMatrix-specific implementation of private API
 
+    # TODO!
     def _join_on(self, other, on):
         if len(other.index) == 0:
             return self
@@ -141,33 +116,14 @@ class DataMatrix(DataFrame):
 
         return self.join(filledFrame, how='left')
 
-    def _reindex_index(self, index, method):
-        if index is self.index:
+    def _reindex_index(self, new_index, method):
+        if new_index is self.index:
             return self.copy()
-
         if len(self.index) == 0:
-            return DataMatrix(index=index, columns=self.columns)
-
-        indexer, mask = common.get_indexer(self.index, index, method)
-        mat = self.values.take(indexer, axis=0)
-
-        notmask = -mask
-        if len(index) > 0:
-            if notmask.any():
-                if issubclass(mat.dtype.type, np.int_):
-                    mat = mat.astype(float)
-                elif issubclass(mat.dtype.type, np.bool_):
-                    mat = mat.astype(float)
-
-                common.null_out_axis(mat, notmask, 0)
-
-        if self.objects is not None and len(self.objects.columns) > 0:
-            newObjects = self.objects.reindex(index)
-        else:
-            newObjects = None
-
-        return DataMatrix(mat, index=index, columns=self.columns,
-                          objects=newObjects)
+            return DataMatrix(index=new_index, columns=self.columns)
+        indexer, mask = self.index.get_indexer(new_index, method)
+        new_data = self._data.reindex(indexer, mask)
+        return DataMatrix(new_data, index=new_index, columns=self.columns)
 
     def _reindex_columns(self, columns):
         if len(columns) == 0:
@@ -337,16 +293,6 @@ class DataMatrix(DataFrame):
         else:
             self.objects = None
 
-    def __nonzero__(self):
-        N, K = self.values.shape
-        if N == 0 or K == 0:
-            if self.objects is None:
-                return False
-            else:
-                return self.objects.__nonzero__()
-        else:
-            return True
-
     def __getitem__(self, item):
         """
         Retrieve column, slice, or subset from DataMatrix.
@@ -371,18 +317,8 @@ class DataMatrix(DataFrame):
         This is a magic method. Do NOT call explicity.
         """
         if isinstance(item, slice):
-            new_index = self.index[item]
-            new_values = self.values[item].copy()
-
-            if self.objects is not None:
-                new_objects = self.objects.reindex(new_index)
-            else:
-                new_objects = None
-
-            return DataMatrix(new_values, index=new_index,
-                              columns=self.columns,
-                              objects=new_objects)
-
+            new_data = self._data.get_slice(item)
+            return DataMatrix(new_data)
         elif isinstance(item, np.ndarray):
             if len(item) != len(self.index):
                 raise Exception('Item wrong length %d instead of %d!' %
@@ -514,46 +450,18 @@ class DataMatrix(DataFrame):
         self._float_values = new_values
 
     def __iter__(self):
-        """Iterate over columns of the frame."""
+        """
+        Iterate over columns of the frame.
+        """
         return iter(self.columns)
 
-    def __contains__(self, key):
-        """True if DataMatrix has this column"""
-        hasCol = key in self.columns
-        if hasCol:
-            return True
-        else:
-            if self.objects is not None and key in self.objects:
-                return True
-            return False
-
     def iteritems(self):
         return self._series.iteritems()
 
-#-------------------------------------------------------------------------------
-# Helper methods
-
-    # For DataFrame compatibility
-    def _getSeries(self, item=None, loc=None):
-        if loc is None:
-            try:
-                loc = self.columns.indexMap[item]
-            except KeyError:
-                raise Exception('%s not here!' % item)
-        return Series(self.values[:, loc], index=self.index)
-
     # to support old APIs
     def _series(self):
         return self._data.get_series_dict(self.index)
 
-    def _output_columns(self):
-        # for toString
-        cols = list(self.columns)
-        if self.objects is None:
-            return cols
-        else:
-            return cols + list(self.objects.columns)
-
 #-------------------------------------------------------------------------------
 # Public methods
 
@@ -955,53 +863,18 @@ def _init_dict(data, index, columns):
     # figure out the index, if necessary
     if index is None:
         index = extract_index(data)
-    homogenized = _homogenize_series(data, index)
-    # segregates dtypes and forms blocks
-    blocks = _segregate_dtypes(data)
-
-    if columns is None:
-        columns = Index(_try_sort(valueDict))
-        objectColumns = Index(_try_sort(objectDict))
-    else:
-        objectColumns = Index([c for c in columns if c in objectDict])
-        columns = Index([c for c in columns if c not in objectDict])
 
-    values = np.empty((len(index), len(columns)), dtype=dtype)
-
-    for i, col in enumerate(columns):
-        if col in valueDict:
-            values[:, i] = valueDict[col].values
-        else:
-            values[:, i] = np.NaN
+    # TODO: deal with emptiness!
+    # TODO: dtype casting?
 
+    # don't force copy because getting jammed in an ndarray anyway
+    homogenized = _homogenize_series(data, index, force_copy=False)
+    # segregates dtypes and forms blocks matching to columns
+    blocks = _form_blocks(data, columns)
+    mgr = BlockManager(blocks, index, columns)
     return index, columns, values, objects
 
-def _homogenize_series(data, index):
-    homogenized = {}
-
-    for k, v in data.iteritems():
-        if isinstance(v, Series):
-            if v.index is not index:
-                # Forces alignment. No need to copy data since we
-                # are putting it into an ndarray later
-                v = v.reindex(index)
-        else:
-            if isinstance(v, dict):
-                v = [v.get(i, NaN) for i in index]
-            else:
-                assert(len(v) == len(index))
-            v = Series(v, index=index)
-
-        if issubclass(v.dtype.type, (float, int)):
-            v = v.astype(np.float64)
-        else:
-            v = v.astype(object)
-
-        homogenized[k] = v
-
-    return homogenized
-
-def _segregate_dtypes(data):
+def _form_blocks(data, columns):
     float_dict = {}
     object_dict = {}
     for k, v in data.iteritems():
@@ -1014,7 +887,7 @@ def _segregate_dtypes(data):
     object_block = _blockify(object_dict, np.object_)
     return [float_block, object_block]
 
-def _blockify(dct, dtype):
+def _blockify(dct, dtype, columns=None):
     pass
 
 def _init_matrix(self, values, index, columns, dtype):
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index edbaaad3f..5482f55a1 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -9,9 +9,9 @@ import warnings
 
 import numpy as np
 
-from pandas.core.common import _mut_exclusive, _ensure_index
+from pandas.core.common import _mut_exclusive, _ensure_index, _pfixed
 from pandas.core.index import Index
-from pandas.core.frame import DataFrame, _pfixed
+from pandas.core.frame import DataFrame
 from pandas.core.matrix import DataMatrix
 from pandas.core.generic import PandasGeneric, Picklable
 import pandas.core.common as common
diff --git a/pandas/core/proto.py b/pandas/core/proto.py
index d139c78fe..2d4af5872 100644
--- a/pandas/core/proto.py
+++ b/pandas/core/proto.py
@@ -128,9 +128,11 @@ def make_block(values, columns):
 
 class BlockManager(object):
     """
-    Manage a bunch of labeled 2D mixed-type ndarrays
+    Manage a bunch of labeled 2D mixed-type ndarrays. Essentially it's a
+    lightweight blocked set of labeled data to be manipulated by the DataFrame
+    public API class
 
-    This is not a public API class
+    This is *not* a public API class
     """
     def __init__(self, blocks, index=None, columns=None):
         self.index = index
@@ -149,6 +151,11 @@ class BlockManager(object):
         for block in self.blocks:
             assert(len(block) == length)
 
+    def get_slice(self, slice_obj):
+        new_blocks = _slice_blocks(self.blocks, slice_obj)
+        new_index = self.index[slice_obj]
+        return BlockManager(new_blocks, index=new_index, columns=self.columns)
+
     def get_series_dict(self, index):
         return _blocks_to_series_dict(self.blocks, index)
 
@@ -250,9 +257,30 @@ class BlockManager(object):
     def rename(self, mapper):
         pass
 
-    def reindex(self, indexer, mask):
+    def reindex_index(self, indexer, mask):
+        mat = self.values.take(indexer, axis=0)
+
+        notmask = -mask
+        if len(index) > 0:
+            if notmask.any():
+                if issubclass(mat.dtype.type, np.int_):
+                    mat = mat.astype(float)
+                elif issubclass(mat.dtype.type, np.bool_):
+                    mat = mat.astype(float)
+
+                common.null_out_axis(mat, notmask, 0)
+
+    def reindex_columns(self, new_columns):
         pass
 
+def _slice_blocks(blocks, slice_obj):
+    new_blocks = []
+    for block in blocks:
+        newb = Block(block.values[slice_obj], block.columns)
+        new_blocks.append(newb)
+    return new_blocks
+
+# TODO!
 def _needs_other_dtype(block, to_insert):
     if to_insert.dtype != block.dtype:
         pass
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index eccfb6936..a702e93c7 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -1843,6 +1843,9 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
 
 
 if __name__ == '__main__':
+    # unittest.main()
     import nose
-    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
+    nose.runmodule(argv=[__file__,'-vvs','-x', '--pdb-failure'],
                    exit=False)
+    # nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
+    #                exit=False)

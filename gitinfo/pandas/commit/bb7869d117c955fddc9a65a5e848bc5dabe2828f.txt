commit bb7869d117c955fddc9a65a5e848bc5dabe2828f
Author: Chang She <chang@lambdafoundry.com>
Date:   Tue May 8 17:54:29 2012 -0400

    ENH: Series.replace #929

diff --git a/pandas/core/common.py b/pandas/core/common.py
index 8449359ed..cb1e457fa 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -372,7 +372,7 @@ _pad_2d_datetime = _interp_wrapper(_algos.pad_2d_inplace_int64, np.int64)
 _backfill_1d_datetime = _interp_wrapper(_algos.backfill_inplace_int64, np.int64)
 _backfill_2d_datetime = _interp_wrapper(_algos.backfill_2d_inplace_int64, np.int64)
 
-def pad_1d(values, limit=None):
+def pad_1d(values, limit=None, mask=None):
     if is_float_dtype(values):
         _method = _algos.pad_inplace_float64
     elif is_datetime64_dtype(values):
@@ -382,9 +382,12 @@ def pad_1d(values, limit=None):
     else: # pragma: no cover
         raise ValueError('Invalid dtype for padding')
 
-    _method(values, isnull(values).view(np.uint8), limit=limit)
+    if mask is None:
+        mask = isnull(values)
+    mask = mask.view(np.uint8)
+    _method(values, mask, limit=limit)
 
-def backfill_1d(values, limit=None):
+def backfill_1d(values, limit=None, mask=None):
     if is_float_dtype(values):
         _method = _algos.backfill_inplace_float64
     elif is_datetime64_dtype(values):
@@ -394,9 +397,13 @@ def backfill_1d(values, limit=None):
     else: # pragma: no cover
         raise ValueError('Invalid dtype for padding')
 
-    _method(values, isnull(values).view(np.uint8), limit=limit)
+    if mask is None:
+        mask = isnull(values)
+    mask = mask.view(np.uint8)
 
-def pad_2d(values, limit=None):
+    _method(values, mask, limit=limit)
+
+def pad_2d(values, limit=None, mask=None):
     if is_float_dtype(values):
         _method = _algos.pad_2d_inplace_float64
     elif is_datetime64_dtype(values):
@@ -406,9 +413,13 @@ def pad_2d(values, limit=None):
     else: # pragma: no cover
         raise ValueError('Invalid dtype for padding')
 
-    _method(values, isnull(values).view(np.uint8), limit=limit)
+    if mask is None:
+        mask = isnull(values)
+    mask = mask.view(np.uint8)
+
+    _method(values, mask, limit=limit)
 
-def backfill_2d(values, limit=None):
+def backfill_2d(values, limit=None, mask=None):
     if is_float_dtype(values):
         _method = _algos.backfill_2d_inplace_float64
     elif is_datetime64_dtype(values):
@@ -418,8 +429,11 @@ def backfill_2d(values, limit=None):
     else: # pragma: no cover
         raise ValueError('Invalid dtype for padding')
 
-    _method(values, isnull(values).view(np.uint8), limit=limit)
+    if mask is None:
+        mask = isnull(values)
+    mask = mask.view(np.uint8)
 
+    _method(values, mask, limit=limit)
 
 def _consensus_name_attr(objs):
     name = objs[0].name
diff --git a/pandas/core/series.py b/pandas/core/series.py
index d8e4ad546..854e434e0 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2078,11 +2078,7 @@ copy : boolean, default False
             if method is None:  # pragma: no cover
                 raise ValueError('must specify a fill method')
 
-            method = com._clean_fill_method(method)
-            if method == 'pad':
-                fill_f = com.pad_1d
-            elif method == 'backfill':
-                fill_f = com.backfill_1d
+            fill_f = _get_fill_func(method)
 
             if inplace:
                 values = self.values
@@ -2098,6 +2094,91 @@ copy : boolean, default False
 
         return result
 
+
+    def replace(self, to_replace=None, value=None, method='pad', inplace=False,
+                limit=None):
+        """
+        Replace arbitrary values in a Series
+
+        Parameters
+        ----------
+        to_replace : list or dict, default None
+            list of values to be replaced or dict of replacement values
+        value : anything
+            if to_replace is a list then value is the replacement value
+        method : {'backfill', 'bfill', 'pad', 'ffill', None}, default 'pad'
+            Method to use for filling holes in reindexed Series
+            pad / ffill: propagate last valid observation forward to next valid
+            backfill / bfill: use NEXT valid observation to fill gap
+        inplace : boolean, default False
+            If True, fill the Series in place. Note: this will modify any other
+            views on this Series, for example a column in a DataFrame. Returns
+            a reference to the filled object, which is self if inplace=True
+        limit : int, default None
+            Maximum size gap to forward or backward fill
+
+        Notes
+        -----
+        replace does not distinguish between NaN and None
+
+        See also
+        --------
+        fillna, reindex, asfreq
+
+        Returns
+        -------
+        replaced : Series
+        """
+        result = self.copy() if not inplace else self
+        single_val = False
+
+        def _rep_one(s, to_rep, v): # replace single value
+            m = _mask_missing(s, to_rep)
+            np.putmask(s, m, v)
+            return s
+
+        def _rep_dict(rs, to_rep): # replace {[src] -> dest}
+
+            dd = {} # group by unique destination value
+            [dd.setdefault(d, []).append(s) for s, d in to_rep.iteritems()]
+
+            for d, sset in dd.iteritems(): # now replace by each dest
+                rs = _rep_one(rs, sset, d)
+            return rs
+
+        if isinstance(to_replace, dict):
+            return _rep_dict(result, to_replace)
+
+        if isinstance(to_replace, (list, np.ndarray)):
+
+            if isinstance(value, (list, np.ndarray)): # check same length
+
+                vl, rl = len(value), len(to_replace)
+                if vl == rl:
+                    return _rep_dict(result, dict(zip(to_replace, value)))
+                raise ValueError('Got %d to replace but %d values' % (rl, vl))
+
+            elif value is not None: # otherwise all replaced with same value
+
+                return _rep_one(result, to_replace, value)
+
+            else: # method
+                if method is None:  # pragma: no cover
+                    raise ValueError('must specify a fill method')
+                fill_f = _get_fill_func(method)
+
+                mask = _mask_missing(result, to_replace)
+                fill_f(result.values, limit=limit, mask=mask)
+
+                if not inplace:
+                    result = Series(result.values, index=self.index,
+                                    name=self.name)
+                return result
+
+
+        raise ValueError('Unrecognized to_replace type %s' %
+                         type(to_replace))
+
     def isin(self, values):
         """
         Return boolean vector showing whether each element in the Series is
@@ -2549,6 +2630,23 @@ def _resolve_offset(freq, kwds):
 
     return offset
 
+def _get_fill_func(method):
+    method = com._clean_fill_method(method)
+    if method == 'pad':
+        fill_f = com.pad_1d
+    elif method == 'backfill':
+        fill_f = com.backfill_1d
+    return fill_f
+
+def _mask_missing(series, missing_values):
+    missing_values = np.array(list(missing_values), dtype=object)
+    if isnull(missing_values).any():
+        missing_values = missing_values[notnull(missing_values)]
+        mask = isnull(series) | series.isin(missing_values)
+    else:
+        mask = series.isin(missing_values)
+    return mask
+
 
 #----------------------------------------------------------------------
 # Add plotting methods to Series
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 45ea0cacd..7adda04cc 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -2649,23 +2649,43 @@ class TestSeriesNonUnique(unittest.TestCase):
 
     def test_replace(self):
         N = 100
-        ser = Series(np.fabs(np.random.randn(len(N))), tm.makeDataIndex(N))
+        ser = Series(np.fabs(np.random.randn(N)), tm.makeDateIndex(N),
+                     dtype=object)
         ser[:5] = np.nan
         ser[6:10] = 'foo'
         ser[20:30] = 'bar'
 
+        # replace list with a single value
         rs = ser.replace([np.nan, 'foo', 'bar'], -1)
+
         self.assert_((rs[:5] == -1).all())
         self.assert_((rs[6:10] == -1).all())
         self.assert_((rs[20:30] == -1).all())
-        self.assert_((ser >= 0).all())
+        self.assert_((isnull(ser[:5])).all())
 
+        # replace with different values
         rs = ser.replace({np.nan : -1, 'foo' : -2, 'bar' : -3})
+
         self.assert_((rs[:5] == -1).all())
         self.assert_((rs[6:10] == -2).all())
         self.assert_((rs[20:30] == -3).all())
-        self.assert_((ser >= 0).all())
+        self.assert_((isnull(ser[:5])).all())
+
+        # replace with different values with 2 lists
+        rs2 = ser.replace([np.nan, 'foo', 'bar'], [-1, -2, -3])
+        assert_series_equal(rs, rs2)
+
+        # replace with forward fill not considering np.nan missing
+        s2 = ser.copy()
+        s2[5] = np.nan
+        rs3 = s2.replace(['foo', 'bar'])
+        self.assert_(isnull(rs3[6]))
+
+        # replace with back fill considering np.nan as missing
+        rs4 = ser.replace([np.nan, 'foo', 'bar'], method='bfill')
+        assert_almost_equal(rs4[4], ser[5])
 
+        # replace inplace
         ser.replace([np.nan, 'foo', 'bar'], -1, inplace=True)
         self.assert_((ser[:5] == -1).all())
         self.assert_((ser[6:10] == -1).all())

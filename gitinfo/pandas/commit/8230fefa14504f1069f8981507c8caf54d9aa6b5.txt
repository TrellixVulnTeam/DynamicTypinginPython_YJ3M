commit 8230fefa14504f1069f8981507c8caf54d9aa6b5
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jan 2 00:33:14 2012 -0500

    BUG: non-float rank does not handle NAs properly, test coverage

diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index 01590e424..14861a861 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -100,9 +100,14 @@ def nanskew(values, axis=None, skipna=True, copy=True):
               ((count - 2) * np.sqrt(B) ** 3))
 
     if isinstance(result, np.ndarray):
-        return np.where(B == 0, 0, result)
+        result = np.where(B == 0, 0, result)
+        result[count < 3] = np.nan
+        return result
     else:
-        return 0 if B == 0 else result
+        result = 0 if B == 0 else result
+        if count < 3:
+            return np.nan
+        return result
 
 def nanmin(values, axis=None, skipna=True, copy=True):
     mask = isnull(values)
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index a37f7462a..52f7c880e 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -920,26 +920,6 @@ class Panel(NDFrame):
         result = np.apply_along_axis(func, i, self.values)
         return self._wrap_result(result, axis=axis)
 
-    def _array_method(self, func, axis='major', fill_value=None, skipna=True):
-        """
-        Parameters
-        ----------
-        func : numpy function
-            Signature should match numpy.{sum, mean, var, std} etc.
-        axis : {'major', 'minor', 'items'}
-        fill_value : boolean, default True
-            Replace NaN values with specified first
-        skipna : boolean, default True
-            Exclude NA/null values. If an entire row/column is NA, the result
-            will be NA
-
-        Returns
-        -------
-        y : DataFrame
-        """
-        result = self._values_aggregate(func, axis, fill_value, skipna=skipna)
-        return self._wrap_result(result, axis=axis)
-
     def _reduce(self, op, axis=0, skipna=True):
         axis_name = self._get_axis_name(axis)
         axis_number = self._get_axis_number(axis_name)
diff --git a/pandas/core/reshape.py b/pandas/core/reshape.py
index ab6e2993d..216e59b98 100644
--- a/pandas/core/reshape.py
+++ b/pandas/core/reshape.py
@@ -486,6 +486,15 @@ def melt(frame, id_vars=None, value_vars=None):
     return DataFrame(mdata, columns=mcolumns)
 
 def make_dummies(data, cat_variables):
+    """
+
+    Parameters
+    ----------
+
+    Returns
+    -------
+    dummies : DataFrame
+    """
     result = data.drop(cat_variables, axis=1)
 
     for variable in cat_variables:
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 709d525d8..29247d65a 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -96,7 +96,8 @@ def _unbox(func):
         result = func(self, *args, **kwargs)
         if isinstance(result, np.ndarray) and result.ndim == 0:
             return result.item()
-        return result
+        else:  # pragma: no cover
+            return result
     f.__doc__ = func.__doc__
     f.__name__ = func.__name__
     return f
@@ -267,7 +268,16 @@ copy : boolean, default False
             return self.index._engine.get_value(self, key)
         except KeyError, e1:
             if isinstance(self.index, MultiIndex):
-                return self._multilevel_index(key)
+                values = self.values
+                try:
+                    loc = self.index.get_loc(key)
+                    # TODO: what if a level contains tuples??
+                    new_index = self.index[loc]
+                    new_index = _maybe_droplevels(new_index, key)
+                    return Series(values[loc], index=new_index,
+                                  name=self.name)
+                except KeyError:
+                    pass
 
             try:
                 return _gin.get_value_at(self, key)
@@ -364,22 +374,6 @@ copy : boolean, default False
             new_values = np.concatenate([self.values, [value]])
             return Series(new_values, index=new_index, name=self.name)
 
-    def _multilevel_index(self, key):
-        values = self.values
-        try:
-            loc = self.index.get_loc(key)
-            if isinstance(loc, (slice, np.ndarray)):
-                # TODO: what if a level contains tuples??
-                new_index = self.index[loc]
-                new_index = _maybe_droplevels(new_index, key)
-                return Series(values[loc], index=new_index, name=self.name)
-            else:
-                return values[loc]
-        except KeyError:
-            if isinstance(key, (int, np.integer)):
-                return values[key]
-            raise KeyError('%s not in this series!' % str(key))
-
     # help out SparseSeries
     _get_val_at = ndarray.__getitem__
 
diff --git a/pandas/src/stats.pyx b/pandas/src/stats.pyx
index 2a39050b3..6a5295d63 100644
--- a/pandas/src/stats.pyx
+++ b/pandas/src/stats.pyx
@@ -108,9 +108,8 @@ def rank_1d_generic(object in_arr):
 
     nan_value = np.inf
 
-    if isinstance(values.dtype.type, np.floating):
-        mask = np.isnan(values)
-        np.putmask(values, mask, nan_value)
+    mask = isnullobj(values.astype('O'))
+    np.putmask(values, mask, nan_value)
 
     n = len(values)
     ranks = np.empty(n, dtype='f8')
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index f0421af4c..15ba83c7c 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -72,6 +72,14 @@ class SafeForLongAndSparse(object):
     def test_max(self):
         self._check_stat_op('max', np.max)
 
+    def test_skew(self):
+        from scipy.stats import skew
+        def this_skew(x):
+            if len(x) < 3:
+                return np.nan
+            return skew(x, bias=False)
+        self._check_stat_op('skew', this_skew)
+
     # def test_mad(self):
     #     f = lambda x: np.abs(x - x.mean()).mean()
     #     self._check_stat_op('mad', f)
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 94397263d..fdd5f9dfb 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -761,6 +761,7 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
                       pos_only=True)
 
         check(self.ts * 2)
+        check(self.ts * 0)
         check(self.ts[::2])
         check(5)
 
@@ -1128,6 +1129,9 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self.ts[:10][::3] = 4.
 
         ranks = self.ts.rank()
+        oranks = self.ts.astype('O').rank()
+
+        assert_series_equal(ranks, oranks)
 
         mask =  np.isnan(self.ts)
         filled = self.ts.fillna(np.inf)

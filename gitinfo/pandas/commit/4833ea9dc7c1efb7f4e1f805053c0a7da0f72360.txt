commit 4833ea9dc7c1efb7f4e1f805053c0a7da0f72360
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Jun 30 15:49:19 2011 -0400

    biting the bullet, working to make generic n-dimensional structure to back DataFrame and WidePanel and friends

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index f1d72848e..dcf41febb 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -206,7 +206,7 @@ class DataFrame(PandasGeneric):
             columns = _default_index(K)
 
         columns = _ensure_index(columns)
-        block = make_block(values, columns, columns)
+        block = make_block(values.T, columns, columns)
         return BlockManager([block], index, columns)
 
     def astype(self, dtype):
@@ -594,7 +594,9 @@ class DataFrame(PandasGeneric):
 
     def _get_values(self):
         self._consolidate_inplace()
-        return self._data.as_matrix()
+        # returns items x index
+        values = self._data.as_matrix()
+        return values.T
 
     index = property(fget=lambda self: self._get_index(),
                      fset=lambda self, x: self._set_index(x))
@@ -665,7 +667,6 @@ class DataFrame(PandasGeneric):
 
         self._data = dm._data
 
-
     #----------------------------------------------------------------------
     # Private helper methods
 
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 148396227..14a1932ee 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -11,60 +11,63 @@ import pandas.core.common as common
 
 class Block(object):
     """
-    Canonical unit of homogeneous dtype contained in DataFrame
+    Canonical n-dimensional unit of homogeneous dtype contained in a pandas data
+    structure
 
     Index-ignorant; let the container take care of that
     """
-    def __init__(self, values, columns, ref_columns):
+    def __init__(self, values, items, ref_items, ndim=2):
         values = _convert_if_1d(values)
         if issubclass(values.dtype.type, basestring):
             values = np.array(values, dtype=object)
 
+        assert(len(items) == len(values))
+
         self.values = values
-        assert(len(columns) == values.shape[1])
-        self.columns = _ensure_index(columns)
-        self.ref_columns = _ensure_index(ref_columns)
+        self.ndim = 2
+        self.items = _ensure_index(items)
+        self.ref_items = _ensure_index(ref_items)
 
     _ref_locs = None
     @property
     def ref_locs(self):
         if self._ref_locs is None:
-            indexer, mask = self.ref_columns.get_indexer(self.columns)
+            indexer, mask = self.ref_items.get_indexer(self.items)
             assert(mask.all())
             self._ref_locs = indexer
         return self._ref_locs
 
-    def set_ref_columns(self, ref_columns, maybe_rename=True):
+    def set_ref_items(self, ref_items, maybe_rename=True):
         """
-        If maybe_rename=True, need to set the columns for this guy
+        If maybe_rename=True, need to set the items for this guy
         """
-        assert(isinstance(ref_columns, Index))
+        assert(isinstance(ref_items, Index))
         if maybe_rename:
-            self.columns = ref_columns.take(self.ref_locs)
-        self.ref_columns = ref_columns
+            self.items = ref_items.take(self.ref_locs)
+        self.ref_items = ref_items
 
     def __repr__(self):
         shape = ' x '.join([str(s) for s in self.shape])
         name = type(self).__name__
-        return '%s: %s, %s, dtype %s' % (name, self.columns,
+        return '%s: %s, %s, dtype %s' % (name, self.items,
                                          shape, self.dtype)
 
-    def __contains__(self, col):
-        return col in self.columns
+    def __contains__(self, item):
+        return item in self.items
 
     def __len__(self):
         return len(self.values)
 
     def __getstate__(self):
-        # should not pickle generally (want to share ref_columns), but here for
+        # should not pickle generally (want to share ref_items), but here for
         # completeness
-        return (np.asarray(self.columns), np.asarray(self.ref_columns),
+        return (np.asarray(self.items), np.asarray(self.ref_items),
                 self.values)
 
     def __setstate__(self, state):
-        columns, ref_columns, values = state
-        self.columns = Index(columns)
-        self.ref_columns = Index(ref_columns)
+        items, ref_items, values = state
+        self.items = Index(items)
+        self.ref_items = Index(ref_items)
         self.values = values
 
     @property
@@ -76,95 +79,16 @@ class Block(object):
         return self.values.dtype
 
     def copy(self):
-        return make_block(self.values.copy(), self.columns,
-                          self.ref_columns)
-
-    def merge(self, other):
-        assert(self.ref_columns.equals(other.ref_columns))
-
-        # Not sure whether to allow this or not
-        # if not union_ref.equals(other.ref_columns):
-        #     union_ref = self.ref_columns + other.ref_columns
-        return _merge_blocks([self, other], self.ref_columns)
-
-    def reindex_index(self, indexer, notmask, needs_masking):
-        """
-        Reindex using pre-computed indexer information
-        """
-        new_values = self.values.take(indexer, axis=0)
-        if needs_masking:
-            new_values = _cast_if_bool_int(new_values)
-            common.null_out_axis(new_values, notmask, 0)
-        return make_block(new_values, self.columns, self.ref_columns)
-
-    def reindex_columns_from(self, new_columns):
-        """
-        Reindex to only those columns contained in the input set of columns
-
-        E.g. if you have ['a', 'b'], and the input columns is ['b', 'c', 'd'],
-        then the resulting columns will be ['b']
-
-        Returns
-        -------
-        reindexed : Block
-        """
-        indexer, mask = self.columns.get_indexer(new_columns)
-        masked_idx = indexer[mask]
-        new_values = self.values.take(masked_idx, axis=1)
-        new_cols = self.columns.take(masked_idx)
-        return make_block(new_values, new_cols, new_columns)
-
-    def get(self, col):
-        loc = self.columns.get_loc(col)
-        return self.values[:, loc]
-
-    def set(self, col, value):
-        """
-        Modify Block in-place with new column value
-
-        Returns
-        -------
-        None
-        """
-        loc = self.columns.get_loc(col)
-        self.values[:, loc] = value
-
-    def delete(self, col):
-        """
-        Returns
-        -------
-        y : Block (new object)
-        """
-        loc = self.columns.get_loc(col)
-        new_cols = np.delete(np.asarray(self.columns), loc)
-        new_values = np.delete(self.values, loc, 1)
-        return make_block(new_values, new_cols, self.ref_columns)
-
-    def fillna(self, value):
-        new_values = self.values.copy()
-        mask = common.isnull(new_values.ravel())
-        new_values.flat[mask] = value
-        return make_block(new_values, self.columns, self.ref_columns)
-
-class NDBlock(Block):
-
-    def __init__(self, values, columns, ref_columns):
-        values = _convert_if_1d(values)
-        if issubclass(values.dtype.type, basestring):
-            values = np.array(values, dtype=object)
-
-        self.values = values
-        assert(len(columns) == values.shape[1])
-        self.columns = _ensure_index(columns)
-        self.ref_columns = _ensure_index(ref_columns)
+        return make_block(self.values.copy(), self.items,
+                          self.ref_items)
 
     def merge(self, other):
-        assert(self.ref_columns.equals(other.ref_columns))
+        assert(self.ref_items.equals(other.ref_items))
 
         # Not sure whether to allow this or not
-        # if not union_ref.equals(other.ref_columns):
-        #     union_ref = self.ref_columns + other.ref_columns
-        return _merge_blocks([self, other], self.ref_columns)
+        # if not union_ref.equals(other.ref_items):
+        #     union_ref = self.ref_items + other.ref_items
+        return _merge_blocks([self, other], self.ref_items)
 
     def reindex_axis(self, indexer, notmask, needs_masking, axis=0):
         """
@@ -174,61 +98,62 @@ class NDBlock(Block):
         if needs_masking:
             new_values = _cast_if_bool_int(new_values)
             common.null_out_axis(new_values, notmask, axis)
-        return make_block(new_values, self.columns, self.ref_columns)
+        return make_ndblock(new_values, self.items, self.ref_items)
 
-    def reindex_columns_from(self, new_columns):
+    def reindex_items_from(self, new_ref_items):
         """
-        Reindex to only those columns contained in the input set of columns
+        Reindex to only those items contained in the input set of items
 
-        E.g. if you have ['a', 'b'], and the input columns is ['b', 'c', 'd'],
-        then the resulting columns will be ['b']
+        E.g. if you have ['a', 'b'], and the input items is ['b', 'c', 'd'],
+        then the resulting items will be ['b']
 
         Returns
         -------
         reindexed : Block
         """
-        indexer, mask = self.columns.get_indexer(new_columns)
+        indexer, mask = self.items.get_indexer(new_ref_items)
         masked_idx = indexer[mask]
         new_values = self.values.take(masked_idx, axis=0)
-        new_cols = self.columns.take(masked_idx)
-        return make_block(new_values, new_cols, new_columns)
+        new_items = self.items.take(masked_idx)
+        return make_ndblock(new_values, new_items, new_ref_items)
 
-    def get(self, col):
-        loc = self.columns.get_loc(col)
+
+    def get(self, item):
+        loc = self.items.get_loc(item)
         return self.values[loc]
 
-    def set(self, col, value):
+    def set(self, item, value):
         """
-        Modify Block in-place with new column value
+        Modify Block in-place with new item value
 
         Returns
         -------
         None
         """
-        loc = self.columns.get_loc(col)
+        loc = self.items.get_loc(item)
         self.values[loc] = value
 
-    def delete(self, col):
+    def delete(self, item):
         """
         Returns
         -------
         y : Block (new object)
         """
-        loc = self.columns.get_loc(col)
-        new_cols = np.delete(np.asarray(self.columns), loc)
+        loc = self.items.get_loc(item)
+        new_items = np.delete(np.asarray(self.items), loc)
         new_values = np.delete(self.values, loc, 0)
-        return make_block(new_values, new_cols, self.ref_columns)
+        return make_block(new_values, new_items, self.ref_items)
 
     def fillna(self, value):
         new_values = self.values.copy()
         mask = common.isnull(new_values.ravel())
         new_values.flat[mask] = value
-        return make_block(new_values, self.columns, self.ref_columns)
+        return make_block(new_values, self.items, self.ref_items)
 
-def _insert_into_columns(columns, col, loc):
-    columns = np.asarray(columns)
-    new_columns = np.insert(columns, loc, col)
-    return Index(new_columns)
+def _insert_into_items(items, item, loc):
+    items = np.asarray(items)
+    new_items = np.insert(items, loc, item)
+    return Index(new_items)
 
 def _cast_if_bool_int(values):
     if issubclass(values.dtype.type, np.int_):
@@ -239,7 +164,7 @@ def _cast_if_bool_int(values):
 
 def _convert_if_1d(values):
     if values.ndim == 1:
-        values = np.atleast_2d(values).T
+        values = np.atleast_2d(values)
 
     return values
 
@@ -267,7 +192,7 @@ class ObjectBlock(Block):
         return not issubclass(value.dtype.type,
                               (np.integer, np.floating, np.bool_))
 
-def make_block(values, columns, ref_columns, ndim=2):
+def make_block(values, items, ref_items, ndim=2):
     dtype = values.dtype
     vtype = dtype.type
 
@@ -280,9 +205,9 @@ def make_block(values, columns, ref_columns, ndim=2):
     else:
         klass = ObjectBlock
 
-    return klass(values, columns, ref_columns)
+    return klass(values, items, ref_items, ndim=ndim)
 
-# TODO: flexible with index=None and/or columns=None
+# TODO: flexible with index=None and/or items=None
 
 class BlockManager(object):
     """
@@ -300,10 +225,10 @@ class BlockManager(object):
     -----
     This is *not* a public API class
     """
-    def __init__(self, blocks, index=None, columns=None,
+    def __init__(self, blocks, index=None, items=None,
                  skip_integrity_check=False):
         self._index = _ensure_index(index)
-        self._columns = _ensure_index(columns)
+        self._items = _ensure_index(items)
         self.blocks = blocks
 
         if not skip_integrity_check:
@@ -317,49 +242,45 @@ class BlockManager(object):
                 return True
         return False
 
-    _columns = None
-    def _set_columns(self, value):
-        if len(value) != len(self._columns):
-            raise Exception('Length mismatch (%d vs %d)'
-                            % (len(cols), len(self._columns)))
-
-        self._columns = _ensure_index(value)
+    def _set_items(self, value):
+        self.set_axis(0, value)
 
         for block in self.blocks:
-            block.set_ref_columns(self._columns, maybe_rename=True)
+            block.set_ref_items(self.items, maybe_rename=True)
 
-    columns = property(fget=attrgetter('_columns'), fset=_set_columns)
+    def _get_items(self):
+        return self.axes[0]
 
-    def _set_index(self, index):
-        if len(index) > 0:
-            if len(index) != len(self._index):
-                raise Exception('Length mismatch (%d vs %d)'
-                                % (len(index), len(self._index)))
-        self._index = _ensure_index(index)
+    items = property(fget=_get_items, fset=_set_items)
 
-    index = property(fget=attrgetter('_index'), fset=_set_index)
+    def set_axis(self, axis, value):
+        cur_axis = self.axes[axis]
+        if len(value) != len(cur_axis):
+            raise Exception('Length mismatch (%d vs %d)'
+                            % (len(index), len(cur_axis)))
+        self.axes[axis] = _ensure_index(value)
 
-    def set_columns_norename(self, value):
-        self._columns = _ensure_index(value)
+    def set_items_norename(self, value):
+        value = _ensure_index(value)
+        self.axes[0] = value
 
         for block in self.blocks:
-            block.set_ref_columns(self._columns, maybe_rename=False)
+            block.set_ref_items(value, maybe_rename=False)
 
     def __getstate__(self):
         block_values = [b.values for b in self.blocks]
-        block_columns = [np.asarray(b.columns) for b in self.blocks]
-        return (np.asarray(self.index),
-                np.asarray(self.columns),
-                block_values, block_columns)
+        block_items = [np.asarray(b.items) for b in self.blocks]
+        axes_array = [np.asarray(ax) for ax in self.axes]
+        return axes_array, block_values, block_items
 
     def __setstate__(self, state):
-        index, ref_columns, bvalues, bcolumns = state
-        self._index = _ensure_index(index)
-        self._columns = _ensure_index(ref_columns)
+        ax_arrays, bvalues, bitems = state
+        axes = [_ensure_index(ax) for ax in ax_arrays]
+        ref_items = axes[0]
 
         blocks = []
-        for values, columns in zip(bvalues, bcolumns):
-            blk = make_block(values, columns, self.columns)
+        for values, items in zip(bvalues, bitems):
+            blk = make_block(values, items, all_items)
             blocks.append(blk)
         self.blocks = blocks
 
@@ -370,22 +291,22 @@ class BlockManager(object):
         return output
 
     def _verify_integrity(self):
-        _union_block_columns(self.blocks)
+        _union_block_items(self.blocks)
         length = len(self)
         for block in self.blocks:
             assert(len(block) == length)
 
-        tot_cols = sum(len(x.columns) for x in self.blocks)
-        assert(len(self.columns) == tot_cols)
+        tot_items = sum(len(x.items) for x in self.blocks)
+        assert(len(self.items) == tot_items)
 
     def cast(self, dtype):
         new_blocks = []
         for block in self.blocks:
-            newb = make_block(block.values.astype(dtype), block.columns,
-                              block.ref_columns)
+            newb = make_block(block.values.astype(dtype), block.items,
+                              block.ref_items)
             new_blocks.append(newb)
 
-        new_mgr = BlockManager(new_blocks, self.index, self.columns)
+        new_mgr = BlockManager(new_blocks, self.index, self.items)
         return new_mgr.consolidate()
 
     def is_consolidated(self):
@@ -398,7 +319,7 @@ class BlockManager(object):
     def get_slice(self, slice_obj):
         new_blocks = _slice_blocks(self.blocks, slice_obj)
         new_index = self.index[slice_obj]
-        return BlockManager(new_blocks, index=new_index, columns=self.columns)
+        return BlockManager(new_blocks, index=new_index, items=self.items)
 
     def get_series_dict(self, index):
         return _blocks_to_series_dict(self.blocks, index)
@@ -410,11 +331,11 @@ class BlockManager(object):
     @classmethod
     def from_blocks(cls, blocks, index):
         # also checks for overlap
-        columns = _union_block_columns(blocks)
-        return BlockManager(blocks, index, columns)
+        items = _union_block_items(blocks)
+        return BlockManager(blocks, index, items)
 
-    def __contains__(self, column):
-        return column in self.columns
+    def __contains__(self, item):
+        return item in self.items
 
     @property
     def nblocks(self):
@@ -422,21 +343,21 @@ class BlockManager(object):
 
     def copy(self):
         copy_blocks = [block.copy() for block in self.blocks]
-        return BlockManager(copy_blocks, self.index, self.columns)
+        return BlockManager(copy_blocks, self.index, self.items)
 
-    def as_matrix(self, columns=None):
+    def as_matrix(self, items=None):
         if len(self.blocks) == 0:
             mat = np.empty((len(self.index), 0), dtype=float)
         elif len(self.blocks) == 1:
             blk = self.blocks[0]
-            if columns is None or blk.columns.equals(columns):
+            if items is None or blk.items.equals(items):
                 # if not, then just call interleave per below
                 mat = blk.values
         else:
-            if columns is None:
-                mat = _interleave(self.blocks, self.columns)
+            if items is None:
+                mat = _interleave(self.blocks, self.items)
             else:
-                mat = self.reindex_columns(columns).as_matrix()
+                mat = self.reindex_items(items).as_matrix()
 
         return mat
 
@@ -448,12 +369,12 @@ class BlockManager(object):
                 raise Exception('cannot get view of mixed-type or '
                                 'non-consolidated DataFrame')
             vals = np.concatenate([b.values[i] for b in self.blocks])
-            cols = np.concatenate([b.columns for b in self.blocks])
-            xs = Series(vals, index=cols).reindex(self.columns)
+            items = np.concatenate([b.items for b in self.blocks])
+            xs = Series(vals, index=items).reindex(self.items)
         else:
             vals = self.blocks[0].values[i]
-            cols = self.blocks[0].columns
-            xs = Series(vals, cols)
+            items = self.blocks[0].items
+            xs = Series(vals, items)
             if copy:
                 xs = xs.copy()
         return xs
@@ -469,69 +390,69 @@ class BlockManager(object):
         if self.is_consolidated():
             return self
 
-        new_blocks = _consolidate(self.blocks, self.columns)
-        return BlockManager(new_blocks, self.index, self.columns)
+        new_blocks = _consolidate(self.blocks, self.items)
+        return BlockManager(new_blocks, self.index, self.items)
 
-    def get(self, col):
-        _, block = self._find_block(col)
-        return block.get(col)
+    def get(self, item):
+        _, block = self._find_block(item)
+        return block.get(item)
 
-    def delete(self, col):
-        i, _ = self._find_block(col)
-        loc = self.columns.get_loc(col)
-        new_cols = Index(np.delete(np.asarray(self.columns), loc))
+    def delete(self, item):
+        i, _ = self._find_block(item)
+        loc = self.items.get_loc(item)
+        new_items = Index(np.delete(np.asarray(self.items), loc))
 
-        self._delete_from_block(i, col)
-        self.set_columns_norename(new_cols)
+        self._delete_from_block(i, item)
+        self.set_items_norename(new_items)
 
-    def set(self, col, value):
+    def set(self, item, value):
         """
-        Set new column in-place. Does not consolidate. Adds new Block if not
-        contained in the current set of columns
+        Set new item in-place. Does not consolidate. Adds new Block if not
+        contained in the current set of items
         """
         assert(len(value) == len(self))
-        if col in self.columns:
-            i, block = self._find_block(col)
+        if item in self.items:
+            i, block = self._find_block(item)
             if not block.can_store(value):
                 # delete from block, create and append new block
-                self._delete_from_block(i, col)
-                self._add_new_block(col, value)
+                self._delete_from_block(i, item)
+                self._add_new_block(item, value)
             else:
-                block.set(col, value)
+                block.set(item, value)
         else:
             # TODO: where to insert?
-            new_cols = _insert_into_columns(self.columns, col,
-                                            len(self.columns))
-            self.set_columns_norename(new_cols)
+            new_items = _insert_into_items(self.items, item,
+                                            len(self.items))
+            self.set_items_norename(new_items)
             # new block
-            self._add_new_block(col, value)
+            self._add_new_block(item, value)
 
-    def _delete_from_block(self, i, col):
+    def _delete_from_block(self, i, item):
         """
         Delete and maybe remove the whole block
         """
         block = self.blocks[i]
-        newb = block.delete(col)
+        newb = block.delete(item)
 
         if len(newb.ref_locs) == 0:
             self.blocks.pop(i)
         else:
             self.blocks[i] = newb
 
-    def _add_new_block(self, col, value):
+    def _add_new_block(self, item, value):
         # Do we care about dtype at the moment?
-        new_block = make_block(value, [col], self.columns)
+        new_block = make_block(value, [item], self.items)
         self.blocks.append(new_block)
 
-    def _find_block(self, col):
-        self._check_have(col)
+    def _find_block(self, item):
+        self._check_have(item)
         for i, block in enumerate(self.blocks):
-            if col in block:
+            if item in block:
                 return i, block
 
-    def _check_have(self, col):
-        if col not in self.columns:
-            raise KeyError('no column named %s' % col)
+    def _check_have(self, item):
+        if item not in self.items:
+            raise KeyError('no item named %s' % item)
 
     def reindex_index(self, new_index, method=None):
         new_index = _ensure_index(new_index)
@@ -546,83 +467,83 @@ class BlockManager(object):
             newb = block.reindex_index(indexer, notmask, needs_masking)
             new_blocks.append(newb)
 
-        return BlockManager(new_blocks, new_index, self.columns)
+        return BlockManager(new_blocks, new_index, self.items)
 
     def merge(self, other):
         # TODO
         assert(self.index.equals(other.index))
 
-        intersection = self.columns.intersection(other.columns)
+        intersection = self.items.intersection(other.items)
         try:
             assert(len(intersection) == 0)
         except AssertionError:
-            raise Exception('columns overlap: %s' % intersection)
+            raise Exception('items overlap: %s' % intersection)
 
-        cons_cols = self.columns + other.columns
-        consolidated = _consolidate(self.blocks + other.blocks, cons_cols)
-        return BlockManager(consolidated, self.index, cons_cols)
+        cons_items = self.items + other.items
+        consolidated = _consolidate(self.blocks + other.blocks, cons_items)
+        return BlockManager(consolidated, self.index, cons_items)
 
     def join_on(self, other, on):
         reindexed = other.reindex_index(on)
         reindexed.index = self.index
         return self.merge(reindexed)
 
-    def reindex_columns(self, new_columns):
+    def reindex_items(self, new_items):
         """
 
         """
-        new_columns = _ensure_index(new_columns)
+        new_items = _ensure_index(new_items)
         data = self
         if not data.is_consolidated():
             data = data.consolidate()
-            return data.reindex_columns(new_columns)
+            return data.reindex_items(new_items)
 
         new_blocks = []
         for block in self.blocks:
-            newb = block.reindex_columns_from(new_columns)
-            if len(newb.columns) > 0:
+            newb = block.reindex_items_from(new_items)
+            if len(newb.items) > 0:
                 new_blocks.append(newb)
 
         # TODO: this part could be faster (!)
-        _, mask = self.columns.get_indexer(new_columns)
+        _, mask = self.items.get_indexer(new_items)
         notmask = -mask
 
         if notmask.any():
-            extra_columns = new_columns[notmask]
-            na_block = add_na_columns(extra_columns, self.index, new_columns)
+            extra_items = new_items[notmask]
+            na_block = add_na_items(extra_items, self.index, new_items)
             new_blocks.append(na_block)
-            new_blocks = _consolidate(new_blocks, new_columns)
+            new_blocks = _consolidate(new_blocks, new_items)
 
-        return BlockManager(new_blocks, self.index, new_columns)
+        return BlockManager(new_blocks, self.index, new_items)
 
     def rename_index(self, mapper):
         new_index = [mapper(x) for x in self.index]
-        return BlockManager(self.blocks, new_index, self.columns)
+        return BlockManager(self.blocks, new_index, self.items)
 
-    def rename_columns(self, mapper):
-        new_columns = Index([mapper(x) for x in self.columns])
+    def rename_items(self, mapper):
+        new_items = Index([mapper(x) for x in self.items])
         new_blocks = []
         for block in self.blocks:
             newb = block.copy()
-            newb.set_ref_columns(new_columns, maybe_rename=True)
+            newb.set_ref_items(new_items, maybe_rename=True)
             new_blocks.append(newb)
-        return BlockManager(new_blocks, self.index, new_columns)
+        return BlockManager(new_blocks, self.index, new_items)
 
     def fillna(self, value):
         """
 
         """
         new_blocks = [b.fillna(value) for b in self.blocks]
-        return BlockManager(new_blocks, self.index, self.columns)
+        return BlockManager(new_blocks, self.index, self.items)
 
     @property
     def block_id_vector(self):
         # TODO
-        result = np.empty(len(self.columns), dtype=int)
+        result = np.empty(len(self.items), dtype=int)
         result.fill(-1)
 
         for i, blk in enumerate(self.blocks):
-            indexer, mask = self.columns.get_indexer(blk.columns)
+            indexer, mask = self.items.get_indexer(blk.items)
             assert(mask.all())
             result.put(indexer, i)
 
@@ -630,18 +551,18 @@ class BlockManager(object):
         return result
 
 _data_types = [np.float_, np.int_]
-def form_blocks(data, index, columns):
-    from pandas.core.internals import add_na_columns
+def form_blocks(data, index, items):
+    from pandas.core.internals import add_na_items
 
-    # pre-filter out columns if we passed it
-    if columns is None:
-        columns = Index(_try_sort(data.keys()))
-        extra_columns = NULL_INDEX
+    # pre-filter out items if we passed it
+    if items is None:
+        items = Index(_try_sort(data.keys()))
+        extra_items = NULL_INDEX
     else:
-        columns = _ensure_index(columns)
-        extra_columns = columns - Index(data.keys())
+        items = _ensure_index(items)
+        extra_items = items - Index(data.keys())
 
-    # put "leftover" columns in float bucket, where else?
+    # put "leftover" items in float bucket, where else?
     # generalize?
     num_dict = {}
     bool_dict = {}
@@ -665,47 +586,47 @@ def form_blocks(data, index, columns):
 
         # TODO: find corner cases
         # TODO: check type inference
-        num_block = _simple_blockify(num_dict, columns, num_dtype)
+        num_block = _simple_blockify(num_dict, items, num_dtype)
         blocks.append(num_block)
 
     if len(bool_dict):
-        bool_block = _simple_blockify(bool_dict, columns, np.bool_)
+        bool_block = _simple_blockify(bool_dict, items, np.bool_)
         blocks.append(bool_block)
 
     if len(object_dict) > 0:
-        object_block = _simple_blockify(object_dict, columns, np.object_)
+        object_block = _simple_blockify(object_dict, items, np.object_)
         blocks.append(object_block)
 
-    if len(extra_columns):
-        na_block = add_na_columns(extra_columns, index, columns)
+    if len(extra_items):
+        na_block = add_na_items(extra_items, index, items)
         blocks.append(na_block)
-        blocks = _consolidate(blocks, columns)
+        blocks = _consolidate(blocks, items)
 
-    return blocks, columns
+    return blocks, items
 
-def _simple_blockify(dct, ref_columns, dtype):
-    block_columns, values = _stack_dict(dct)
+def _simple_blockify(dct, ref_items, dtype):
+    block_items, values = _stack_dict(dct)
     # CHECK DTYPE?
     if values.dtype != dtype:
         values = values.astype(dtype)
 
-    return make_block(values, block_columns, ref_columns)
+    return make_block(values, block_items, ref_items)
 
 def _stack_dict(dct):
-    columns = Index(_try_sort(dct))
-    stacked = np.vstack([dct[k].values for k in columns]).T
-    return columns, stacked
+    items = Index(_try_sort(dct))
+    stacked = np.vstack([dct[k].values for k in items]).T
+    return items, stacked
 
-def add_na_columns(new_columns, index, ref_columns):
+def add_na_items(new_items, index, ref_items):
     # create new block, then consolidate
-    values = _nan_array(index, new_columns)
-    return make_block(values, new_columns, ref_columns)
+    values = _nan_array(index, new_items)
+    return make_block(values, new_items, ref_items)
 
 def _slice_blocks(blocks, slice_obj):
     new_blocks = []
     for block in blocks:
-        newb = make_block(block.values[slice_obj], block.columns,
-                          block.ref_columns)
+        newb = make_block(block.values[slice_obj], block.items,
+                          block.ref_items)
         new_blocks.append(newb)
     return new_blocks
 
@@ -713,28 +634,28 @@ def _blocks_to_series_dict(blocks, index=None):
     series_dict = {}
 
     for block in blocks:
-        for col, vec in zip(block.columns, block.values.T):
-            series_dict[col] = Series(vec, index=index)
+        for item, vec in zip(block.items, block.values.T):
+            series_dict[item] = Series(vec, index=index)
     return series_dict
 
-def _interleave(blocks, columns):
+def _interleave(blocks, items):
     """
-    Return ndarray from blocks with specified column order
-    Columns must be contained in the blocks
+    Return ndarray from blocks with specified item order
+    Items must be contained in the blocks
     """
     dtype = _interleaved_dtype(blocks)
-    columns = _ensure_index(columns)
+    items = _ensure_index(items)
 
-    result = np.empty((len(blocks[0]), len(columns)), dtype=dtype)
-    colmask = np.zeros(len(columns), dtype=bool)
+    result = np.empty((len(blocks[0]), len(items)), dtype=dtype)
+    itemmask = np.zeros(len(items), dtype=bool)
 
-    # By construction, all of the column should be covered by one of the blocks
+    # By construction, all of the item should be covered by one of the blocks
     for block in blocks:
-        indexer, mask = columns.get_indexer(block.columns)
+        indexer, mask = items.get_indexer(block.items)
         assert(mask.all())
         result[:, indexer] = block.values
-        colmask[indexer] = 1
-    assert(colmask.all())
+        itemmask[indexer] = 1
+    assert(itemmask.all())
     return result
 
 def _interleaved_dtype(blocks):
@@ -768,7 +689,7 @@ def _interleaved_dtype(blocks):
     else:
         return np.float64
 
-def _consolidate(blocks, columns):
+def _consolidate(blocks, items):
     """
     Merge blocks having same dtype
     """
@@ -780,43 +701,43 @@ def _consolidate(blocks, columns):
 
     new_blocks = []
     for dtype, group_blocks in grouper:
-        new_block = _merge_blocks(list(group_blocks), columns)
+        new_block = _merge_blocks(list(group_blocks), items)
         new_blocks.append(new_block)
 
     return new_blocks
 
-def _merge_blocks(blocks, columns):
+def _merge_blocks(blocks, items):
     new_values = np.hstack([b.values for b in blocks])
-    new_cols = np.concatenate([b.columns for b in blocks])
-    new_block = make_block(new_values, new_cols, columns)
-    return new_block.reindex_columns_from(columns)
+    new_items = np.concatenate([b.items for b in blocks])
+    new_block = make_block(new_values, new_items, items)
+    return new_block.reindex_items_from(items)
 
-def _merge_blocks2(blocks, columns):
+def _merge_blocks2(blocks, items):
     new_values = np.vstack([b.values for b in blocks])
-    new_cols = np.concatenate([b.columns for b in blocks])
-    new_block = make_block(new_values, new_cols, columns)
-    return new_block.reindex_columns_from(columns)
+    new_items = np.concatenate([b.items for b in blocks])
+    new_block = make_block(new_values, new_items, items)
+    return new_block.reindex_items_from(items)
 
-def _union_block_columns(blocks):
+def _union_block_items(blocks):
     seen = None
     for block in blocks:
         len_before = 0 if seen is None else len(seen)
         if seen is None:
-            seen = block.columns
+            seen = block.items
         else:
-            seen = seen.union(block.columns)
-        if len(seen) != len_before + len(block.columns):
-            raise Exception('column names overlap')
+            seen = seen.union(block.items)
+        if len(seen) != len_before + len(block.items):
+            raise Exception('item names overlap')
 
     return seen
 
-def _nan_array(index, columns, dtype=np.float64):
+def _nan_array(index, items, dtype=np.float64):
     if index is None:
         index = NULL_INDEX
-    if columns is None:
-        columns = NULL_INDEX
+    if items is None:
+        items = NULL_INDEX
 
-    values = np.empty((len(index), len(columns)), dtype=dtype)
+    values = np.empty((len(index), len(items)), dtype=dtype)
     values.fill(nan)
     return values
 
@@ -827,20 +748,20 @@ if __name__ == '__main__':
     objects[:, 0] = 'foo'
     objects[:, 1] = 'bar'
 
-    float_cols = Index(['a', 'c', 'e'])
-    object_cols = Index(['b', 'd'])
-    columns = Index(sorted(float_cols + object_cols))
+    float_items = Index(['a', 'c', 'e'])
+    object_items = Index(['b', 'd'])
+    items = Index(sorted(float_items + object_items))
     index = np.arange(n)
-    new_columns = Index(['a', 'c', 'e', 'b', 'd'])
+    new_items = Index(['a', 'c', 'e', 'b', 'd'])
 
-    float_locs = new_columns.get_indexer(float_cols)[0]
-    obj_locs = new_columns.get_indexer(object_cols)[0]
+    float_locs = new_items.get_indexer(float_items)[0]
+    obj_locs = new_items.get_indexer(object_items)[0]
 
-    fblock = make_block(floats, float_cols, float_cols)
-    oblock = make_block(objects, object_cols, object_cols)
+    fblock = make_block(floats, float_items, float_items)
+    oblock = make_block(objects, object_items, object_items)
 
     # blocks = [fblock, oblock]
 
-    # interleaved = _interleave(blocks, columns)
+    # interleaved = _interleave(blocks, items)
 
-    # mgr = BlockManager(blocks, index, columns)
+    # mgr = BlockManager(blocks, index, items)
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 7ad16935c..87e1d6a5e 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -11,6 +11,7 @@ import numpy as np
 
 from pandas.core.common import _mut_exclusive, _ensure_index, _pfixed
 from pandas.core.index import Index
+from pandas.core.internals import make_ndblock
 from pandas.core.frame import DataFrame
 from pandas.core.generic import PandasGeneric, Picklable
 import pandas.core.common as common
@@ -212,7 +213,6 @@ class WidePanel(Panel, PandasGeneric):
         self.values = values
 
     def _init_matrix(self, data, axes, dtype=None, copy=False):
-        from pandas.core.internals import make_block
         values = _prep_ndarray(values, copy=copy)
 
         if dtype is not None:

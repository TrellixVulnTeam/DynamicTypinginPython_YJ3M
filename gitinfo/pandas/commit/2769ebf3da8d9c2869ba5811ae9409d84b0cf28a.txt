commit 2769ebf3da8d9c2869ba5811ae9409d84b0cf28a
Author: Jeremy Schendel <jschendel@users.noreply.github.com>
Date:   Wed Apr 10 00:20:20 2019 -0600

    CLN: Remove PY35 flag from pandas.compat (#26036)

diff --git a/pandas/compat/__init__.py b/pandas/compat/__init__.py
index 5a52479a4..b1991e3fb 100644
--- a/pandas/compat/__init__.py
+++ b/pandas/compat/__init__.py
@@ -25,7 +25,6 @@ import struct
 
 PY2 = sys.version_info[0] == 2
 PY3 = sys.version_info[0] >= 3
-PY35 = sys.version_info >= (3, 5)
 PY36 = sys.version_info >= (3, 6)
 PY37 = sys.version_info >= (3, 7)
 PYPY = platform.python_implementation() == 'PyPy'
diff --git a/pandas/core/computation/expr.py b/pandas/core/computation/expr.py
index 81bc2530e..1463897a7 100644
--- a/pandas/core/computation/expr.py
+++ b/pandas/core/computation/expr.py
@@ -10,10 +10,9 @@ import tokenize
 
 import numpy as np
 
-from pandas.compat import lmap
+from pandas.compat import iteritems, lmap
 
 import pandas as pd
-from pandas import compat
 from pandas.core import common as com
 from pandas.core.base import StringMixin
 from pandas.core.computation.common import (
@@ -301,7 +300,7 @@ _op_classes = {'binary': BinOp, 'unary': UnaryOp}
 def add_ops(op_classes):
     """Decorator to add default implementation of ops."""
     def f(cls):
-        for op_attr_name, op_class in compat.iteritems(op_classes):
+        for op_attr_name, op_class in iteritems(op_classes):
             ops = getattr(cls, '{name}_ops'.format(name=op_attr_name))
             ops_map = getattr(cls, '{name}_op_nodes_map'.format(
                 name=op_attr_name))
@@ -590,9 +589,7 @@ class BaseExprVisitor(ast.NodeVisitor):
         raise ValueError("Invalid Attribute context {name}"
                          .format(name=ctx.__name__))
 
-    def visit_Call_35(self, node, side=None, **kwargs):
-        """ in 3.5 the starargs attribute was changed to be more flexible,
-        #11097 """
+    def visit_Call(self, node, side=None, **kwargs):
 
         if isinstance(node.func, ast.Attribute):
             res = self.visit_Attribute(node.func)
@@ -641,58 +638,6 @@ class BaseExprVisitor(ast.NodeVisitor):
 
             return self.const_type(res(*new_args, **kwargs), self.env)
 
-    def visit_Call_legacy(self, node, side=None, **kwargs):
-
-        # this can happen with: datetime.datetime
-        if isinstance(node.func, ast.Attribute):
-            res = self.visit_Attribute(node.func)
-        elif not isinstance(node.func, ast.Name):
-            raise TypeError("Only named functions are supported")
-        else:
-            try:
-                res = self.visit(node.func)
-            except UndefinedVariableError:
-                # Check if this is a supported function name
-                try:
-                    res = FuncNode(node.func.id)
-                except ValueError:
-                    # Raise original error
-                    raise
-
-        if res is None:
-            raise ValueError("Invalid function call {func}"
-                             .format(func=node.func.id))
-        if hasattr(res, 'value'):
-            res = res.value
-
-        if isinstance(res, FuncNode):
-            args = [self.visit(targ) for targ in node.args]
-
-            if node.starargs is not None:
-                args += self.visit(node.starargs)
-
-            if node.keywords or node.kwargs:
-                raise TypeError("Function \"{name}\" does not support keyword "
-                                "arguments".format(name=res.name))
-
-            return res(*args, **kwargs)
-
-        else:
-            args = [self.visit(targ).value for targ in node.args]
-            if node.starargs is not None:
-                args += self.visit(node.starargs).value
-
-            keywords = {}
-            for key in node.keywords:
-                if not isinstance(key, ast.keyword):
-                    raise ValueError("keyword error in function call "
-                                     "'{func}'".format(func=node.func.id))
-                keywords[key.arg] = self.visit(key.value).value
-            if node.kwargs is not None:
-                keywords.update(self.visit(node.kwargs).value)
-
-            return self.const_type(res(*args, **keywords), self.env)
-
     def translate_In(self, op):
         return op
 
@@ -734,14 +679,6 @@ class BaseExprVisitor(ast.NodeVisitor):
         return reduce(visitor, operands)
 
 
-# ast.Call signature changed on 3.5,
-# conditionally change which methods is named
-# visit_Call depending on Python version, #11097
-if compat.PY35:
-    BaseExprVisitor.visit_Call = BaseExprVisitor.visit_Call_35
-else:
-    BaseExprVisitor.visit_Call = BaseExprVisitor.visit_Call_legacy
-
 _python_not_supported = frozenset(['Dict', 'BoolOp', 'In', 'NotIn'])
 _numexpr_supported_calls = frozenset(_reductions + _mathops)
 
diff --git a/pandas/tests/io/test_pytables.py b/pandas/tests/io/test_pytables.py
index f7b81d1b0..ed070ce54 100644
--- a/pandas/tests/io/test_pytables.py
+++ b/pandas/tests/io/test_pytables.py
@@ -11,7 +11,7 @@ import numpy as np
 import pytest
 
 from pandas.compat import (
-    PY35, PY36, is_platform_little_endian, is_platform_windows, lrange)
+    PY36, is_platform_little_endian, is_platform_windows, lrange)
 import pandas.util._test_decorators as td
 
 from pandas.core.dtypes.common import is_categorical_dtype
@@ -4027,8 +4027,8 @@ class TestHDFStore(Base):
             d2 = store['detector/readout']
             assert isinstance(d2, DataFrame)
 
-    @pytest.mark.skipif(PY35 and is_platform_windows(),
-                        reason="native2 read fails oddly on windows / 3.5")
+    @pytest.mark.skipif(is_platform_windows(),
+                        reason="native2 read fails oddly on windows")
     def test_pytables_native2_read(self, datapath):
         with ensure_clean_store(
                 datapath('io', 'data', 'legacy_hdf', 'pytables_native2.h5'),

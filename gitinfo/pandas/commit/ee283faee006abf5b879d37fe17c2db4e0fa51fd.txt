commit ee283faee006abf5b879d37fe17c2db4e0fa51fd
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Nov 27 10:01:53 2018 -0800

    CLN: Remove/deprecate unused/misleading dtype functions (#23917)

diff --git a/doc/source/whatsnew/v0.24.0.rst b/doc/source/whatsnew/v0.24.0.rst
index b32d214c0..d0dddb19f 100644
--- a/doc/source/whatsnew/v0.24.0.rst
+++ b/doc/source/whatsnew/v0.24.0.rst
@@ -1048,6 +1048,8 @@ Deprecations
 - The ``keep_tz=False`` option (the default) of the ``keep_tz`` keyword of
   :meth:`DatetimeIndex.to_series` is deprecated (:issue:`17832`).
 - Timezone converting a tz-aware ``datetime.datetime`` or :class:`Timestamp` with :class:`Timestamp` and the ``tz`` argument is now deprecated. Instead, use :meth:`Timestamp.tz_convert` (:issue:`23579`)
+- :func:`pandas.types.is_period` is deprecated in favor of `pandas.types.is_period_dtype` (:issue:`23917`)
+- :func:`pandas.types.is_datetimetz` is deprecated in favor of `pandas.types.is_datetime64tz` (:issue:`23917`)
 
 .. _whatsnew_0240.deprecations.datetimelike_int_ops:
 
diff --git a/pandas/_libs/lib.pyx b/pandas/_libs/lib.pyx
index 874206378..0c081986d 100644
--- a/pandas/_libs/lib.pyx
+++ b/pandas/_libs/lib.pyx
@@ -1248,25 +1248,19 @@ def infer_dtype(value: object, skipna: bool=False) -> str:
     if util.is_datetime64_object(val):
         if is_datetime64_array(values):
             return 'datetime64'
-        elif is_timedelta_or_timedelta64_array(values):
-            return 'timedelta'
 
     elif is_timedelta(val):
         if is_timedelta_or_timedelta64_array(values):
             return 'timedelta'
 
     elif util.is_integer_object(val):
-        # a timedelta will show true here as well
-        if is_timedelta(val):
-            if is_timedelta_or_timedelta64_array(values):
-                return 'timedelta'
+        # ordering matters here; this check must come after the is_timedelta
+        #  check otherwise numpy timedelta64 objects would come through here
 
         if is_integer_array(values):
             return 'integer'
         elif is_integer_float_array(values):
             return 'mixed-integer-float'
-        elif is_timedelta_or_timedelta64_array(values):
-            return 'timedelta'
         return 'mixed-integer'
 
     elif PyDateTime_Check(val):
@@ -1699,27 +1693,6 @@ cdef class TimedeltaValidator(TemporalValidator):
         return is_null_timedelta64(value)
 
 
-# TODO: Not used outside of tests; remove?
-def is_timedelta_array(values: ndarray) -> bool:
-    cdef:
-        TimedeltaValidator validator = TimedeltaValidator(len(values),
-                                                          skipna=True)
-    return validator.validate(values)
-
-
-cdef class Timedelta64Validator(TimedeltaValidator):
-    cdef inline bint is_value_typed(self, object value) except -1:
-        return util.is_timedelta64_object(value)
-
-
-# TODO: Not used outside of tests; remove?
-def is_timedelta64_array(values: ndarray) -> bool:
-    cdef:
-        Timedelta64Validator validator = Timedelta64Validator(len(values),
-                                                              skipna=True)
-    return validator.validate(values)
-
-
 cdef class AnyTimedeltaValidator(TimedeltaValidator):
     cdef inline bint is_value_typed(self, object value) except -1:
         return is_timedelta(value)
diff --git a/pandas/core/algorithms.py b/pandas/core/algorithms.py
index 5f7995ac6..7aceef863 100644
--- a/pandas/core/algorithms.py
+++ b/pandas/core/algorithms.py
@@ -19,7 +19,7 @@ from pandas.core.dtypes.common import (
     ensure_float64, ensure_int64, ensure_object, ensure_platform_int,
     ensure_uint64, is_array_like, is_bool_dtype, is_categorical_dtype,
     is_complex_dtype, is_datetime64_any_dtype, is_datetime64tz_dtype,
-    is_datetimelike, is_datetimetz, is_extension_array_dtype, is_float_dtype,
+    is_datetimelike, is_extension_array_dtype, is_float_dtype,
     is_integer_dtype, is_interval_dtype, is_list_like, is_numeric_dtype,
     is_object_dtype, is_period_dtype, is_scalar, is_signed_integer_dtype,
     is_sparse, is_timedelta64_dtype, is_unsigned_integer_dtype,
@@ -1581,7 +1581,7 @@ def take_nd(arr, indexer, axis=0, out=None, fill_value=np.nan, mask_info=None,
     # dispatch to internal type takes
     if is_extension_array_dtype(arr):
         return arr.take(indexer, fill_value=fill_value, allow_fill=allow_fill)
-    elif is_datetimetz(arr):
+    elif is_datetime64tz_dtype(arr):
         return arr.take(indexer, fill_value=fill_value, allow_fill=allow_fill)
     elif is_interval_dtype(arr):
         return arr.take(indexer, fill_value=fill_value, allow_fill=allow_fill)
diff --git a/pandas/core/arrays/datetimes.py b/pandas/core/arrays/datetimes.py
index 41c28c5ee..4d3caaacc 100644
--- a/pandas/core/arrays/datetimes.py
+++ b/pandas/core/arrays/datetimes.py
@@ -1458,15 +1458,18 @@ def maybe_convert_dtype(data, copy):
     """
     Convert data based on dtype conventions, issuing deprecation warnings
     or errors where appropriate.
-     Parameters
+
+    Parameters
     ----------
     data : np.ndarray or pd.Index
     copy : bool
-     Returns
+
+    Returns
     -------
     data : np.ndarray or pd.Index
     copy : bool
-     Raises
+
+    Raises
     ------
     TypeError : PeriodDType data is passed
     """
diff --git a/pandas/core/dtypes/cast.py b/pandas/core/dtypes/cast.py
index afe6ba45b..eae9eb97f 100644
--- a/pandas/core/dtypes/cast.py
+++ b/pandas/core/dtypes/cast.py
@@ -13,11 +13,11 @@ from .common import (
     ensure_int8, ensure_int16, ensure_int32, ensure_int64, ensure_object,
     is_bool, is_bool_dtype, is_categorical_dtype, is_complex, is_complex_dtype,
     is_datetime64_dtype, is_datetime64_ns_dtype, is_datetime64tz_dtype,
-    is_datetime_or_timedelta_dtype, is_datetimelike, is_datetimetz,
-    is_dtype_equal, is_extension_array_dtype, is_extension_type, is_float,
-    is_float_dtype, is_integer, is_integer_dtype, is_object_dtype, is_scalar,
-    is_string_dtype, is_timedelta64_dtype, is_timedelta64_ns_dtype,
-    is_unsigned_integer_dtype, pandas_dtype)
+    is_datetime_or_timedelta_dtype, is_datetimelike, is_dtype_equal,
+    is_extension_array_dtype, is_extension_type, is_float, is_float_dtype,
+    is_integer, is_integer_dtype, is_object_dtype, is_scalar, is_string_dtype,
+    is_timedelta64_dtype, is_timedelta64_ns_dtype, is_unsigned_integer_dtype,
+    pandas_dtype)
 from .dtypes import (
     DatetimeTZDtype, ExtensionDtype, PandasExtensionDtype, PeriodDtype)
 from .generic import ABCDatetimeIndex, ABCPeriodIndex, ABCSeries
@@ -267,7 +267,7 @@ def maybe_promote(dtype, fill_value=np.nan):
         fill_value = tslibs.Timestamp(fill_value).value
     elif issubclass(dtype.type, np.timedelta64):
         fill_value = tslibs.Timedelta(fill_value).value
-    elif is_datetimetz(dtype):
+    elif is_datetime64tz_dtype(dtype):
         if isna(fill_value):
             fill_value = iNaT
     elif is_extension_array_dtype(dtype) and isna(fill_value):
@@ -310,7 +310,7 @@ def maybe_promote(dtype, fill_value=np.nan):
     # in case we have a string that looked like a number
     if is_extension_array_dtype(dtype):
         pass
-    elif is_datetimetz(dtype):
+    elif is_datetime64tz_dtype(dtype):
         pass
     elif issubclass(np.dtype(dtype).type, string_types):
         dtype = np.object_
@@ -546,34 +546,6 @@ def invalidate_string_dtypes(dtype_set):
         raise TypeError("string dtypes are not allowed, use 'object' instead")
 
 
-def maybe_convert_string_to_object(values):
-    """
-
-    Convert string-like and string-like array to convert object dtype.
-    This is to avoid numpy to handle the array as str dtype.
-    """
-    if isinstance(values, string_types):
-        values = np.array([values], dtype=object)
-    elif (isinstance(values, np.ndarray) and
-          issubclass(values.dtype.type, (np.string_, np.unicode_))):
-        values = values.astype(object)
-    return values
-
-
-def maybe_convert_scalar(values):
-    """
-    Convert a python scalar to the appropriate numpy dtype if possible
-    This avoids numpy directly converting according to platform preferences
-    """
-    if is_scalar(values):
-        dtype, values = infer_dtype_from_scalar(values)
-        try:
-            values = dtype(values)
-        except TypeError:
-            pass
-    return values
-
-
 def coerce_indexer_dtype(indexer, categories):
     """ coerce the indexer input array to the smallest dtype possible """
     length = len(categories)
@@ -1188,7 +1160,7 @@ def construct_1d_arraylike_from_scalar(value, length, dtype):
     np.ndarray / pandas type of length, filled with value
 
     """
-    if is_datetimetz(dtype):
+    if is_datetime64tz_dtype(dtype):
         from pandas import DatetimeIndex
         subarr = DatetimeIndex([value] * length, dtype=dtype)
     elif is_categorical_dtype(dtype):
diff --git a/pandas/core/dtypes/common.py b/pandas/core/dtypes/common.py
index de7e453e8..51b848831 100644
--- a/pandas/core/dtypes/common.py
+++ b/pandas/core/dtypes/common.py
@@ -1,4 +1,6 @@
 """ common type operations """
+import warnings
+
 import numpy as np
 
 from pandas._libs import algos, lib
@@ -287,6 +289,8 @@ def is_datetimetz(arr):
     Check whether an array-like is a datetime array-like with a timezone
     component in its dtype.
 
+    .. deprecated:: 0.24.0
+
     Parameters
     ----------
     arr : array-like
@@ -320,12 +324,10 @@ def is_datetimetz(arr):
     True
     """
 
-    # TODO: do we need this function?
-    # It seems like a repeat of is_datetime64tz_dtype.
-
-    return ((isinstance(arr, ABCDatetimeIndex) and
-             getattr(arr, 'tz', None) is not None) or
-            is_datetime64tz_dtype(arr))
+    warnings.warn("'is_datetimetz' is deprecated and will be removed in a "
+                  "future version.  Use 'is_datetime64tz_dtype' instead.",
+                  FutureWarning, stacklevel=2)
+    return is_datetime64tz_dtype(arr)
 
 
 def is_offsetlike(arr_or_obj):
@@ -363,6 +365,8 @@ def is_period(arr):
     """
     Check whether an array-like is a periodical index.
 
+    .. deprecated:: 0.24.0
+
     Parameters
     ----------
     arr : array-like
@@ -382,8 +386,10 @@ def is_period(arr):
     True
     """
 
-    # TODO: do we need this function?
-    # It seems like a repeat of is_period_arraylike.
+    warnings.warn("'is_period' is deprecated and will be removed in a future "
+                  "version.  Use 'is_period_dtype' or is_period_arraylike' "
+                  "instead.", FutureWarning, stacklevel=2)
+
     return isinstance(arr, ABCPeriodIndex) or is_period_arraylike(arr)
 
 
@@ -743,8 +749,7 @@ def is_datetimelike(arr):
 
     return (is_datetime64_dtype(arr) or is_datetime64tz_dtype(arr) or
             is_timedelta64_dtype(arr) or
-            isinstance(arr, ABCPeriodIndex) or
-            is_datetimetz(arr))
+            isinstance(arr, ABCPeriodIndex))
 
 
 def is_dtype_equal(source, target):
@@ -1050,54 +1055,6 @@ def is_int64_dtype(arr_or_dtype):
     return issubclass(tipo, np.int64)
 
 
-def is_int_or_datetime_dtype(arr_or_dtype):
-    """
-    Check whether the provided array or dtype is of an
-    integer, timedelta64, or datetime64 dtype.
-
-    Parameters
-    ----------
-    arr_or_dtype : array-like
-        The array or dtype to check.
-
-    Returns
-    -------
-    boolean : Whether or not the array or dtype is of an
-              integer, timedelta64, or datetime64 dtype.
-
-    Examples
-    --------
-    >>> is_int_or_datetime_dtype(str)
-    False
-    >>> is_int_or_datetime_dtype(int)
-    True
-    >>> is_int_or_datetime_dtype(float)
-    False
-    >>> is_int_or_datetime_dtype(np.uint64)
-    True
-    >>> is_int_or_datetime_dtype(np.datetime64)
-    True
-    >>> is_int_or_datetime_dtype(np.timedelta64)
-    True
-    >>> is_int_or_datetime_dtype(np.array(['a', 'b']))
-    False
-    >>> is_int_or_datetime_dtype(pd.Series([1, 2]))
-    True
-    >>> is_int_or_datetime_dtype(np.array([], dtype=np.timedelta64))
-    True
-    >>> is_int_or_datetime_dtype(np.array([], dtype=np.datetime64))
-    True
-    >>> is_int_or_datetime_dtype(pd.Index([1, 2.]))  # float
-    False
-    """
-
-    if arr_or_dtype is None:
-        return False
-    tipo = _get_dtype_type(arr_or_dtype)
-    return (issubclass(tipo, np.integer) or
-            issubclass(tipo, (np.datetime64, np.timedelta64)))
-
-
 def is_datetime64_any_dtype(arr_or_dtype):
     """
     Check whether the provided array or dtype is of the datetime64 dtype.
@@ -1619,22 +1576,6 @@ def is_float_dtype(arr_or_dtype):
     return issubclass(tipo, np.floating)
 
 
-def is_floating_dtype(arr_or_dtype):
-    """Check whether the provided array or dtype is an instance of
-    numpy's float dtype.
-
-    .. deprecated:: 0.20.0
-
-    Unlike, `is_float_dtype`, this check is a lot stricter, as it requires
-    `isinstance` of `np.floating` and not `issubclass`.
-    """
-
-    if arr_or_dtype is None:
-        return False
-    tipo = _get_dtype_type(arr_or_dtype)
-    return isinstance(tipo, np.floating)
-
-
 def is_bool_dtype(arr_or_dtype):
     """
     Check whether the provided array or dtype is of a boolean dtype.
@@ -1758,7 +1699,7 @@ def is_extension_type(arr):
         return True
     elif is_sparse(arr):
         return True
-    elif is_datetimetz(arr):
+    elif is_datetime64tz_dtype(arr):
         return True
     return False
 
@@ -1991,7 +1932,7 @@ def _get_dtype_from_object(dtype):
         return dtype
     elif is_categorical(dtype):
         return CategoricalDtype().type
-    elif is_datetimetz(dtype):
+    elif is_datetime64tz_dtype(dtype):
         return DatetimeTZDtype(dtype).type
     elif isinstance(dtype, np.dtype):  # dtype object
         try:
diff --git a/pandas/core/dtypes/concat.py b/pandas/core/dtypes/concat.py
index f482f7e19..098ac3e0c 100644
--- a/pandas/core/dtypes/concat.py
+++ b/pandas/core/dtypes/concat.py
@@ -8,7 +8,7 @@ from pandas._libs import tslib, tslibs
 
 from pandas.core.dtypes.common import (
     _NS_DTYPE, _TD_DTYPE, is_bool_dtype, is_categorical_dtype,
-    is_datetime64_dtype, is_datetimetz, is_dtype_equal,
+    is_datetime64_dtype, is_datetime64tz_dtype, is_dtype_equal,
     is_extension_array_dtype, is_interval_dtype, is_object_dtype,
     is_period_dtype, is_sparse, is_timedelta64_dtype)
 from pandas.core.dtypes.generic import (
@@ -39,7 +39,7 @@ def get_dtype_kinds(l):
             typ = 'sparse'
         elif isinstance(arr, ABCRangeIndex):
             typ = 'range'
-        elif is_datetimetz(arr):
+        elif is_datetime64tz_dtype(arr):
             # if to_concat contains different tz,
             # the result must be object dtype
             typ = str(arr.dtype)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 6a3c69c29..688f0226d 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -54,7 +54,7 @@ from pandas.core.dtypes.common import (
     is_object_dtype,
     is_extension_type,
     is_extension_array_dtype,
-    is_datetimetz,
+    is_datetime64tz_dtype,
     is_datetime64_any_dtype,
     is_bool_dtype,
     is_integer_dtype,
@@ -542,7 +542,8 @@ class DataFrame(NDFrame):
             index, columns = _get_axes(len(values), 1)
             return _arrays_to_mgr([values], columns, index, columns,
                                   dtype=dtype)
-        elif (is_datetimetz(values) or is_extension_array_dtype(values)):
+        elif (is_datetime64tz_dtype(values) or
+              is_extension_array_dtype(values)):
             # GH19157
             if columns is None:
                 columns = [0]
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index 61e8d6344..8b563a9b9 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -16,9 +16,9 @@ from pandas.util._decorators import Appender, Substitution, cache_readonly
 
 from pandas.core.dtypes.common import (
     _INT64_DTYPE, _NS_DTYPE, ensure_int64, is_datetime64_dtype,
-    is_datetime64_ns_dtype, is_datetime64tz_dtype, is_datetimetz,
-    is_dtype_equal, is_float, is_integer, is_integer_dtype, is_list_like,
-    is_period_dtype, is_scalar, is_string_like, pandas_dtype)
+    is_datetime64_ns_dtype, is_datetime64tz_dtype, is_dtype_equal, is_float,
+    is_integer, is_integer_dtype, is_list_like, is_period_dtype, is_scalar,
+    is_string_like, pandas_dtype)
 import pandas.core.dtypes.concat as _concat
 from pandas.core.dtypes.generic import ABCSeries
 from pandas.core.dtypes.missing import isna
@@ -267,8 +267,7 @@ class DatetimeIndex(DatetimeArray, DatelikeOps, TimelikeOps,
 
         # By this point we are assured to have either a numpy array or Index
         data, copy = maybe_convert_dtype(data, copy)
-
-        if not (is_datetime64_dtype(data) or is_datetimetz(data) or
+        if not (is_datetime64_dtype(data) or is_datetime64tz_dtype(data) or
                 is_integer_dtype(data) or lib.infer_dtype(data) == 'integer'):
             data = tools.to_datetime(data, dayfirst=dayfirst,
                                      yearfirst=yearfirst)
diff --git a/pandas/core/internals/blocks.py b/pandas/core/internals/blocks.py
index 21dae455c..4ae7a812e 100644
--- a/pandas/core/internals/blocks.py
+++ b/pandas/core/internals/blocks.py
@@ -20,7 +20,7 @@ from pandas.core.dtypes.cast import (
 from pandas.core.dtypes.common import (
     _NS_DTYPE, _TD_DTYPE, ensure_platform_int, is_bool_dtype, is_categorical,
     is_categorical_dtype, is_datetime64_dtype, is_datetime64tz_dtype,
-    is_datetimetz, is_dtype_equal, is_extension_array_dtype, is_extension_type,
+    is_dtype_equal, is_extension_array_dtype, is_extension_type,
     is_float_dtype, is_integer, is_integer_dtype, is_list_like,
     is_numeric_v_string_like, is_object_dtype, is_re, is_re_compilable,
     is_sparse, is_timedelta64_dtype, pandas_dtype)
@@ -2765,7 +2765,7 @@ class DatetimeBlock(DatetimeLikeBlockMixin, Block):
 
     def should_store(self, value):
         return (issubclass(value.dtype.type, np.datetime64) and
-                not is_datetimetz(value) and
+                not is_datetime64tz_dtype(value) and
                 not is_extension_array_dtype(value))
 
     def set(self, locs, values, check=False):
@@ -3017,9 +3017,9 @@ def get_block_type(values, dtype=None):
     elif issubclass(vtype, np.complexfloating):
         cls = ComplexBlock
     elif issubclass(vtype, np.datetime64):
-        assert not is_datetimetz(values)
+        assert not is_datetime64tz_dtype(values)
         cls = DatetimeBlock
-    elif is_datetimetz(values):
+    elif is_datetime64tz_dtype(values):
         cls = DatetimeTZBlock
     elif issubclass(vtype, np.integer):
         cls = IntBlock
@@ -3040,7 +3040,7 @@ def make_block(values, placement, klass=None, ndim=None, dtype=None,
         dtype = dtype or values.dtype
         klass = get_block_type(values, dtype)
 
-    elif klass is DatetimeTZBlock and not is_datetimetz(values):
+    elif klass is DatetimeTZBlock and not is_datetime64tz_dtype(values):
         return klass(values, ndim=ndim,
                      placement=placement, dtype=dtype)
 
diff --git a/pandas/core/internals/concat.py b/pandas/core/internals/concat.py
index 2fb533478..2441c6451 100644
--- a/pandas/core/internals/concat.py
+++ b/pandas/core/internals/concat.py
@@ -10,8 +10,9 @@ from pandas.util._decorators import cache_readonly
 
 from pandas.core.dtypes.cast import maybe_promote
 from pandas.core.dtypes.common import (
-    _get_dtype, is_categorical_dtype, is_datetime64_dtype, is_datetimetz,
-    is_float_dtype, is_numeric_dtype, is_sparse, is_timedelta64_dtype)
+    _get_dtype, is_categorical_dtype, is_datetime64_dtype,
+    is_datetime64tz_dtype, is_float_dtype, is_numeric_dtype, is_sparse,
+    is_timedelta64_dtype)
 import pandas.core.dtypes.concat as _concat
 from pandas.core.dtypes.missing import isna
 
@@ -179,7 +180,7 @@ class JoinUnit(object):
                         fill_value = None
 
                 if (getattr(self.block, 'is_datetimetz', False) or
-                        is_datetimetz(empty_dtype)):
+                        is_datetime64tz_dtype(empty_dtype)):
                     if self.block is None:
                         array = empty_dtype.construct_array_type()
                         missing_arr = array([fill_value], dtype=empty_dtype)
@@ -293,7 +294,7 @@ def get_empty_dtype_and_na(join_units):
 
         if is_categorical_dtype(dtype):
             upcast_cls = 'category'
-        elif is_datetimetz(dtype):
+        elif is_datetime64tz_dtype(dtype):
             upcast_cls = 'datetimetz'
         elif issubclass(dtype.type, np.bool_):
             upcast_cls = 'bool'
diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index 4369ac60a..027f45861 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -13,8 +13,8 @@ from pandas.core.dtypes.cast import _int64_max, maybe_upcast_putmask
 from pandas.core.dtypes.common import (
     _get_dtype, is_any_int_dtype, is_bool_dtype, is_complex, is_complex_dtype,
     is_datetime64_dtype, is_datetime_or_timedelta_dtype, is_float,
-    is_float_dtype, is_int_or_datetime_dtype, is_integer, is_integer_dtype,
-    is_numeric_dtype, is_object_dtype, is_scalar, is_timedelta64_dtype)
+    is_float_dtype, is_integer, is_integer_dtype, is_numeric_dtype,
+    is_object_dtype, is_scalar, is_timedelta64_dtype)
 from pandas.core.dtypes.missing import isna, na_value_for_dtype, notna
 
 import pandas.core.common as com
@@ -254,7 +254,9 @@ def _isfinite(values):
 
 
 def _na_ok_dtype(dtype):
-    return not is_int_or_datetime_dtype(dtype)
+    # TODO: what about datetime64tz?  PeriodDtype?
+    return not issubclass(dtype.type,
+                          (np.integer, np.timedelta64, np.datetime64))
 
 
 def _view_if_needed(values):
diff --git a/pandas/core/reshape/merge.py b/pandas/core/reshape/merge.py
index a7e83c88c..dfbee5656 100644
--- a/pandas/core/reshape/merge.py
+++ b/pandas/core/reshape/merge.py
@@ -18,8 +18,8 @@ from pandas.core.dtypes.common import (
     ensure_float64, ensure_int64, ensure_object, is_array_like, is_bool,
     is_bool_dtype, is_categorical_dtype, is_datetime64_dtype,
     is_datetime64tz_dtype, is_datetimelike, is_dtype_equal, is_float_dtype,
-    is_int64_dtype, is_int_or_datetime_dtype, is_integer, is_integer_dtype,
-    is_list_like, is_number, is_numeric_dtype, needs_i8_conversion)
+    is_int64_dtype, is_integer, is_integer_dtype, is_list_like, is_number,
+    is_numeric_dtype, needs_i8_conversion)
 from pandas.core.dtypes.missing import isnull, na_value_for_dtype
 
 from pandas import Categorical, DataFrame, Index, MultiIndex, Series, Timedelta
@@ -1604,7 +1604,15 @@ def _factorize_keys(lk, rk, sort=True):
 
         lk = ensure_int64(lk.codes)
         rk = ensure_int64(rk)
-    elif is_int_or_datetime_dtype(lk) and is_int_or_datetime_dtype(rk):
+    elif is_integer_dtype(lk) and is_integer_dtype(rk):
+        # GH#23917 TODO: needs tests for case where lk is integer-dtype
+        #  and rk is datetime-dtype
+        klass = libhashtable.Int64Factorizer
+        lk = ensure_int64(com.values_from_object(lk))
+        rk = ensure_int64(com.values_from_object(rk))
+    elif (issubclass(lk.dtype.type, (np.timedelta64, np.datetime64)) and
+          issubclass(rk.dtype.type, (np.timedelta64, np.datetime64))):
+        # GH#23917 TODO: Needs tests for non-matching dtypes
         klass = libhashtable.Int64Factorizer
         lk = ensure_int64(com.values_from_object(lk))
         rk = ensure_int64(com.values_from_object(rk))
diff --git a/pandas/io/formats/format.py b/pandas/io/formats/format.py
index ff9ee9ed7..b35f5d1e5 100644
--- a/pandas/io/formats/format.py
+++ b/pandas/io/formats/format.py
@@ -16,7 +16,7 @@ from pandas._libs.tslibs import NaT, Timedelta, Timestamp, iNaT
 from pandas.compat import StringIO, lzip, map, u, zip
 
 from pandas.core.dtypes.common import (
-    is_categorical_dtype, is_datetime64_dtype, is_datetimetz, is_float,
+    is_categorical_dtype, is_datetime64_dtype, is_datetime64tz_dtype, is_float,
     is_float_dtype, is_integer, is_integer_dtype, is_interval_dtype,
     is_list_like, is_numeric_dtype, is_period_arraylike, is_scalar,
     is_timedelta64_dtype)
@@ -852,7 +852,7 @@ def format_array(values, formatter, float_format=None, na_rep='NaN',
         fmt_klass = PeriodArrayFormatter
     elif is_integer_dtype(values.dtype):
         fmt_klass = IntArrayFormatter
-    elif is_datetimetz(values):
+    elif is_datetime64tz_dtype(values):
         fmt_klass = Datetime64TZFormatter
     elif is_datetime64_dtype(values.dtype):
         fmt_klass = Datetime64Formatter
diff --git a/pandas/tests/api/test_types.py b/pandas/tests/api/test_types.py
index c36af4404..3468a4db6 100644
--- a/pandas/tests/api/test_types.py
+++ b/pandas/tests/api/test_types.py
@@ -13,21 +13,21 @@ class TestTypes(Base):
                'is_categorical', 'is_categorical_dtype', 'is_complex',
                'is_complex_dtype', 'is_datetime64_any_dtype',
                'is_datetime64_dtype', 'is_datetime64_ns_dtype',
-               'is_datetime64tz_dtype', 'is_datetimetz', 'is_dtype_equal',
+               'is_datetime64tz_dtype', 'is_dtype_equal',
                'is_extension_type', 'is_float', 'is_float_dtype',
                'is_int64_dtype', 'is_integer',
                'is_integer_dtype', 'is_number', 'is_numeric_dtype',
                'is_object_dtype', 'is_scalar', 'is_sparse',
                'is_string_dtype', 'is_signed_integer_dtype',
                'is_timedelta64_dtype', 'is_timedelta64_ns_dtype',
-               'is_unsigned_integer_dtype', 'is_period',
+               'is_unsigned_integer_dtype',
                'is_period_dtype', 'is_interval', 'is_interval_dtype',
                'is_re', 'is_re_compilable',
                'is_dict_like', 'is_iterator', 'is_file_like',
                'is_list_like', 'is_hashable', 'is_array_like',
                'is_named_tuple',
                'pandas_dtype', 'union_categoricals', 'infer_dtype']
-    deprecated = []
+    deprecated = ['is_period', 'is_datetimetz']
     dtypes = ['CategoricalDtype', 'DatetimeTZDtype',
               'PeriodDtype', 'IntervalDtype']
 
diff --git a/pandas/tests/dtypes/test_cast.py b/pandas/tests/dtypes/test_cast.py
index 0d6382424..fcdcf9609 100644
--- a/pandas/tests/dtypes/test_cast.py
+++ b/pandas/tests/dtypes/test_cast.py
@@ -19,8 +19,6 @@ from pandas.core.dtypes.cast import (
     cast_scalar_to_array,
     infer_dtype_from_scalar,
     infer_dtype_from_array,
-    maybe_convert_string_to_object,
-    maybe_convert_scalar,
     find_common_type,
     construct_1d_object_array_from_listlike,
     construct_1d_ndarray_preserving_na,
@@ -243,61 +241,6 @@ class TestInferDtype(object):
 
 class TestMaybe(object):
 
-    def test_maybe_convert_string_to_array(self):
-        result = maybe_convert_string_to_object('x')
-        tm.assert_numpy_array_equal(result, np.array(['x'], dtype=object))
-        assert result.dtype == object
-
-        result = maybe_convert_string_to_object(1)
-        assert result == 1
-
-        arr = np.array(['x', 'y'], dtype=str)
-        result = maybe_convert_string_to_object(arr)
-        tm.assert_numpy_array_equal(result, np.array(['x', 'y'], dtype=object))
-        assert result.dtype == object
-
-        # unicode
-        arr = np.array(['x', 'y']).astype('U')
-        result = maybe_convert_string_to_object(arr)
-        tm.assert_numpy_array_equal(result, np.array(['x', 'y'], dtype=object))
-        assert result.dtype == object
-
-        # object
-        arr = np.array(['x', 2], dtype=object)
-        result = maybe_convert_string_to_object(arr)
-        tm.assert_numpy_array_equal(result, np.array(['x', 2], dtype=object))
-        assert result.dtype == object
-
-    def test_maybe_convert_scalar(self):
-
-        # pass thru
-        result = maybe_convert_scalar('x')
-        assert result == 'x'
-        result = maybe_convert_scalar(np.array([1]))
-        assert result == np.array([1])
-
-        # leave scalar dtype
-        result = maybe_convert_scalar(np.int64(1))
-        assert result == np.int64(1)
-        result = maybe_convert_scalar(np.int32(1))
-        assert result == np.int32(1)
-        result = maybe_convert_scalar(np.float32(1))
-        assert result == np.float32(1)
-        result = maybe_convert_scalar(np.int64(1))
-        assert result == np.float64(1)
-
-        # coerce
-        result = maybe_convert_scalar(1)
-        assert result == np.int64(1)
-        result = maybe_convert_scalar(1.0)
-        assert result == np.float64(1)
-        result = maybe_convert_scalar(Timestamp('20130101'))
-        assert result == Timestamp('20130101').value
-        result = maybe_convert_scalar(datetime(2013, 1, 1))
-        assert result == Timestamp('20130101').value
-        result = maybe_convert_scalar(Timedelta('1 day 1 min'))
-        assert result == Timedelta('1 day 1 min').value
-
     def test_maybe_infer_to_datetimelike(self):
         # GH16362
         # pandas=0.20.1 raises IndexError: tuple index out of range
diff --git a/pandas/tests/dtypes/test_common.py b/pandas/tests/dtypes/test_common.py
index 4dd55321d..a7390e0cf 100644
--- a/pandas/tests/dtypes/test_common.py
+++ b/pandas/tests/dtypes/test_common.py
@@ -10,6 +10,7 @@ from pandas.core.sparse.api import SparseDtype
 
 import pandas.core.dtypes.common as com
 import pandas.util._test_decorators as td
+import pandas.util.testing as tm
 
 
 class TestPandasDtype(object):
@@ -161,20 +162,22 @@ def test_is_categorical():
 
 
 def test_is_datetimetz():
-    assert not com.is_datetimetz([1, 2, 3])
-    assert not com.is_datetimetz(pd.DatetimeIndex([1, 2, 3]))
+    with tm.assert_produces_warning(FutureWarning):
+        assert not com.is_datetimetz([1, 2, 3])
+        assert not com.is_datetimetz(pd.DatetimeIndex([1, 2, 3]))
 
-    assert com.is_datetimetz(pd.DatetimeIndex([1, 2, 3], tz="US/Eastern"))
+        assert com.is_datetimetz(pd.DatetimeIndex([1, 2, 3], tz="US/Eastern"))
 
-    dtype = DatetimeTZDtype("ns", tz="US/Eastern")
-    s = pd.Series([], dtype=dtype)
-    assert com.is_datetimetz(s)
+        dtype = DatetimeTZDtype("ns", tz="US/Eastern")
+        s = pd.Series([], dtype=dtype)
+        assert com.is_datetimetz(s)
 
 
-def test_is_period():
-    assert not com.is_period([1, 2, 3])
-    assert not com.is_period(pd.Index([1, 2, 3]))
-    assert com.is_period(pd.PeriodIndex(["2017-01-01"], freq="D"))
+def test_is_period_deprecated():
+    with tm.assert_produces_warning(FutureWarning):
+        assert not com.is_period([1, 2, 3])
+        assert not com.is_period(pd.Index([1, 2, 3]))
+        assert com.is_period(pd.PeriodIndex(["2017-01-01"], freq="D"))
 
 
 def test_is_datetime64_dtype():
@@ -328,21 +331,6 @@ def test_is_int64_dtype():
     assert com.is_int64_dtype(np.array([1, 2], dtype=np.int64))
 
 
-def test_is_int_or_datetime_dtype():
-    assert not com.is_int_or_datetime_dtype(str)
-    assert not com.is_int_or_datetime_dtype(float)
-    assert not com.is_int_or_datetime_dtype(pd.Index([1, 2.]))
-    assert not com.is_int_or_datetime_dtype(np.array(['a', 'b']))
-
-    assert com.is_int_or_datetime_dtype(int)
-    assert com.is_int_or_datetime_dtype(np.uint64)
-    assert com.is_int_or_datetime_dtype(np.datetime64)
-    assert com.is_int_or_datetime_dtype(np.timedelta64)
-    assert com.is_int_or_datetime_dtype(pd.Series([1, 2]))
-    assert com.is_int_or_datetime_dtype(np.array([], dtype=np.datetime64))
-    assert com.is_int_or_datetime_dtype(np.array([], dtype=np.timedelta64))
-
-
 def test_is_datetime64_any_dtype():
     assert not com.is_datetime64_any_dtype(int)
     assert not com.is_datetime64_any_dtype(str)
diff --git a/pandas/tests/dtypes/test_dtypes.py b/pandas/tests/dtypes/test_dtypes.py
index c70a54923..4048e9814 100644
--- a/pandas/tests/dtypes/test_dtypes.py
+++ b/pandas/tests/dtypes/test_dtypes.py
@@ -229,20 +229,25 @@ class TestDatetimeTZDtype(Base):
         assert not is_datetime64tz_dtype(np.dtype('float64'))
         assert not is_datetime64tz_dtype(1.0)
 
-        assert is_datetimetz(s)
-        assert is_datetimetz(s.dtype)
-        assert not is_datetimetz(np.dtype('float64'))
-        assert not is_datetimetz(1.0)
+        with tm.assert_produces_warning(FutureWarning):
+            assert is_datetimetz(s)
+            assert is_datetimetz(s.dtype)
+            assert not is_datetimetz(np.dtype('float64'))
+            assert not is_datetimetz(1.0)
 
     def test_dst(self):
 
         dr1 = date_range('2013-01-01', periods=3, tz='US/Eastern')
         s1 = Series(dr1, name='A')
-        assert is_datetimetz(s1)
+        assert is_datetime64tz_dtype(s1)
+        with tm.assert_produces_warning(FutureWarning):
+            assert is_datetimetz(s1)
 
         dr2 = date_range('2013-08-01', periods=3, tz='US/Eastern')
         s2 = Series(dr2, name='A')
-        assert is_datetimetz(s2)
+        assert is_datetime64tz_dtype(s2)
+        with tm.assert_produces_warning(FutureWarning):
+            assert is_datetimetz(s2)
         assert s1.dtype == s2.dtype
 
     @pytest.mark.parametrize('tz', ['UTC', 'US/Eastern'])
@@ -378,18 +383,22 @@ class TestPeriodDtype(Base):
 
         assert is_period_dtype(pidx.dtype)
         assert is_period_dtype(pidx)
-        assert is_period(pidx)
+        with tm.assert_produces_warning(FutureWarning):
+            assert is_period(pidx)
 
         s = Series(pidx, name='A')
 
         assert is_period_dtype(s.dtype)
         assert is_period_dtype(s)
-        assert is_period(s)
+        with tm.assert_produces_warning(FutureWarning):
+            assert is_period(s)
 
         assert not is_period_dtype(np.dtype('float64'))
         assert not is_period_dtype(1.0)
-        assert not is_period(np.dtype('float64'))
-        assert not is_period(1.0)
+        with tm.assert_produces_warning(FutureWarning):
+            assert not is_period(np.dtype('float64'))
+        with tm.assert_produces_warning(FutureWarning):
+            assert not is_period(1.0)
 
     def test_empty(self):
         dt = PeriodDtype()
diff --git a/pandas/tests/dtypes/test_inference.py b/pandas/tests/dtypes/test_inference.py
index 20ad39e13..a13af123f 100644
--- a/pandas/tests/dtypes/test_inference.py
+++ b/pandas/tests/dtypes/test_inference.py
@@ -875,37 +875,27 @@ class TestTypeInference(object):
         arr = np.array([np.nan, pd.NaT, np.datetime64('nat')])
         assert lib.is_datetime_array(arr)
         assert lib.is_datetime64_array(arr)
-        assert not lib.is_timedelta_array(arr)
-        assert not lib.is_timedelta64_array(arr)
         assert not lib.is_timedelta_or_timedelta64_array(arr)
 
         arr = np.array([np.nan, pd.NaT, np.timedelta64('nat')])
         assert not lib.is_datetime_array(arr)
         assert not lib.is_datetime64_array(arr)
-        assert lib.is_timedelta_array(arr)
-        assert lib.is_timedelta64_array(arr)
         assert lib.is_timedelta_or_timedelta64_array(arr)
 
         arr = np.array([np.nan, pd.NaT, np.datetime64('nat'),
                         np.timedelta64('nat')])
         assert not lib.is_datetime_array(arr)
         assert not lib.is_datetime64_array(arr)
-        assert not lib.is_timedelta_array(arr)
-        assert not lib.is_timedelta64_array(arr)
         assert not lib.is_timedelta_or_timedelta64_array(arr)
 
         arr = np.array([np.nan, pd.NaT])
         assert lib.is_datetime_array(arr)
         assert lib.is_datetime64_array(arr)
-        assert lib.is_timedelta_array(arr)
-        assert lib.is_timedelta64_array(arr)
         assert lib.is_timedelta_or_timedelta64_array(arr)
 
         arr = np.array([np.nan, np.nan], dtype=object)
         assert not lib.is_datetime_array(arr)
         assert not lib.is_datetime64_array(arr)
-        assert not lib.is_timedelta_array(arr)
-        assert not lib.is_timedelta64_array(arr)
         assert not lib.is_timedelta_or_timedelta64_array(arr)
 
         assert lib.is_datetime_with_singletz_array(
@@ -923,8 +913,6 @@ class TestTypeInference(object):
             'is_datetime_array',
             'is_datetime64_array',
             'is_bool_array',
-            'is_timedelta_array',
-            'is_timedelta64_array',
             'is_timedelta_or_timedelta64_array',
             'is_date_array',
             'is_time_array',
diff --git a/pandas/tests/test_base.py b/pandas/tests/test_base.py
index c7efc1efa..7bc67dd99 100644
--- a/pandas/tests/test_base.py
+++ b/pandas/tests/test_base.py
@@ -10,7 +10,7 @@ import numpy as np
 import pandas as pd
 import pandas.compat as compat
 from pandas.core.dtypes.common import (
-    is_object_dtype, is_datetimetz, is_datetime64_dtype,
+    is_object_dtype, is_datetime64_dtype, is_datetime64tz_dtype,
     needs_i8_conversion)
 import pandas.util.testing as tm
 from pandas import (Series, Index, DatetimeIndex, TimedeltaIndex,
@@ -296,7 +296,7 @@ class TestIndexOps(Ops):
                 assert result.iat[0]
                 assert result.iat[1]
 
-                if (is_datetime64_dtype(o) or is_datetimetz(o)):
+                if (is_datetime64_dtype(o) or is_datetime64tz_dtype(o)):
                     # Following DatetimeIndex (and Timestamp) convention,
                     # inequality comparisons with Series[datetime64] raise
                     with pytest.raises(TypeError):
@@ -446,7 +446,7 @@ class TestIndexOps(Ops):
             if isinstance(o, Index):
                 assert isinstance(result, o.__class__)
                 tm.assert_index_equal(result, orig)
-            elif is_datetimetz(o):
+            elif is_datetime64tz_dtype(o):
                 # datetimetz Series returns array of Timestamp
                 assert result[0] == orig[0]
                 for r in result:
@@ -470,7 +470,7 @@ class TestIndexOps(Ops):
                     continue
 
                 # special assign to the numpy array
-                if is_datetimetz(o):
+                if is_datetime64tz_dtype(o):
                     if isinstance(o, DatetimeIndex):
                         v = o.asi8
                         v[0:2] = iNaT
@@ -499,7 +499,7 @@ class TestIndexOps(Ops):
                     o = klass(values.repeat(range(1, len(o) + 1)))
                     o.name = 'a'
                 else:
-                    if is_datetimetz(o):
+                    if is_datetime64tz_dtype(o):
                         expected_index = orig._values._shallow_copy(values)
                     else:
                         expected_index = Index(values)
@@ -538,7 +538,7 @@ class TestIndexOps(Ops):
                 if isinstance(o, Index):
                     tm.assert_index_equal(result,
                                           Index(values[1:], name='a'))
-                elif is_datetimetz(o):
+                elif is_datetime64tz_dtype(o):
                     # unable to compare NaT / nan
                     vals = values[2:].astype(object).values
                     tm.assert_numpy_array_equal(result[1:], vals)

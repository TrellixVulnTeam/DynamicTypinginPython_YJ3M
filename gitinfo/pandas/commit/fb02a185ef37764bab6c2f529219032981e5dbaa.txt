commit fb02a185ef37764bab6c2f529219032981e5dbaa
Author: Adam Klein <adamklein@gmail.com>
Date:   Fri Mar 2 19:23:30 2012 -0500

    ENH: fast time zone conversions and validation

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index c683a5619..3ae7718cb 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -32,7 +32,7 @@ def _dt_box(key, offset=None, tzinfo=None):
     '''
     timestamp-like (int64, python datetime, etc.) => Timestamp
     '''
-    return Timestamp(key, offset=offset, tzinfo=None)
+    return Timestamp(key, offset=offset, tzinfo=tzinfo)
 
 def _dt_box_array(arr, offset=None, tzinfo=None):
     if arr is None:
@@ -81,7 +81,7 @@ def ole2datetime(oledt):
 
     return OLE_TIME_ZERO + timedelta(days=val)
 
-def to_timestamp(arg, offset=None):
+def to_timestamp(arg, offset=None, tzinfo=None):
     """ Attempts to convert arg to timestamp """
     if arg is None:
         return arg
@@ -95,7 +95,7 @@ def to_timestamp(arg, offset=None):
         except Exception:
             pass
 
-    return lib.Timestamp(arg, offset=offset)
+    return lib.Timestamp(arg, offset=offset, tzinfo=tzinfo)
 
 def to_datetime(arg):
     """Attempts to convert arg to datetime"""
@@ -913,6 +913,12 @@ class Minute(Tick):
 class Second(Tick):
     _inc = timedelta(0, 1)
 
+class Milli(Tick):
+    pass
+
+class Micro(Tick):
+    _inc = timedelta(microseconds=1)
+
 day = DateOffset()
 bday = BDay()
 businessDay = bday
@@ -1108,7 +1114,8 @@ _newOffsetMap = {
        "H"     : Hour(),
        "Min"   : Minute(),
        "S"     : Second(),
-       "U"     : None,
+       "L"     : Milli(),
+       "U"     : Micro(),
        None    : None,
 }
 
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 0e82eef32..9cd4fc414 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1376,7 +1376,7 @@ class DatetimeIndex(Int64Index):
 
         start = self[0] + n * self.offset
         end = self[-1] + n * self.offset
-        return DatetimeIndex(start=start, end=end, offset=self.offset,
+        return DatetimeIndex(start=start, end=end, freq=self.offset,
                              name=self.name)
 
     def union(self, other):
@@ -1689,9 +1689,9 @@ class DatetimeIndex(Int64Index):
         -------
         normalized : DateRange
         """
-        new_dates = np.array([tz.normalize(x.replace(tzinfo=self.tzinfo))
-                              for x in self])
-        new_dates = new_dates.view(DatetimeIndex)
+        new_dates = lib.tz_normalize_array(self.asi8, self.tzinfo, tz)
+        new_dates = new_dates.view('M8[us]')
+        new_dates = new_dates.view(self.__class__)
         new_dates.offset = self.offset
         new_dates.tzinfo = tz
         new_dates.name = self.name
@@ -1703,12 +1703,15 @@ class DatetimeIndex(Int64Index):
 
         Returns
         -------
-        localized : DateRange
+        localized : DatetimeIndex
         """
-        new_dates = np.array(
-                [np.datetime64(tz.localize(x.replace(tzinfo=self.tzinfo)))
-                 for x in self])
-        new_dates = new_dates.view(DatetimeIndex)
+        if self.tzinfo is not None:
+            raise ValueError("Already have timezone info, "
+                             "use tz_normalize to convert.")
+
+        new_dates = lib.tz_localize_array(self.asi8, tz)
+        new_dates = new_dates.view('M8[us]')
+        new_dates = new_dates.view(self.__class__)
         new_dates.offset = self.offset
         new_dates.tzinfo = tz
         new_dates.name = self.name
@@ -1717,6 +1720,7 @@ class DatetimeIndex(Int64Index):
     def tz_validate(self):
         """
         For a localized time zone, verify that there are no DST ambiguities
+        (using pytz)
 
         Returns
         -------
@@ -1725,16 +1729,14 @@ class DatetimeIndex(Int64Index):
         """
         import pytz
 
-        tz = self.tzinfo
-        if tz is None or tz is pytz.utc:
+        if self.tzinfo is None or self.tzinfo is pytz.utc:
             return True
 
         # See if there are any DST resolution problems
-        for date in self:
-            try:
-                tz.utcoffset(date.replace(tzinfo=None))
-            except pytz.InvalidTimeError:
-                return False
+        try:
+            lib.tz_localize_array(self.asi8, self.tzinfo)
+        except:
+            return False
 
         return True
 
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 36524a295..119cc2ae7 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -1600,6 +1600,143 @@ def i8_to_pydt(int64_t i8, object tzinfo = None):
     '''
     return Timestamp(i8)
 
+# time zone conversion helpers
+
+try:
+    import pytz
+    have_pytz = True
+except:
+    have_pytz = False
+
+trans_cache = {}
+utc_offset_cache = {}
+
+cdef ndarray[int64_t] _get_transitions(object tz):
+    """
+    Get UTC times of DST transitions
+    """
+    if tz not in trans_cache:
+        arr = np.array(tz._utc_transition_times, dtype='M8[us]')
+        trans_cache[tz] = np.array(arr.view('i8'))
+    return trans_cache[tz]
+
+cdef ndarray[int64_t] _unbox_utcoffsets(object transinfo):
+    cdef:
+        Py_ssize_t i, sz
+        ndarray[int64_t] arr
+
+    sz = len(transinfo)
+    arr = np.empty(sz, dtype='i8')
+
+    for i in range(sz):
+        arr[i] = int(transinfo[i][0].total_seconds()) * 1000000
+
+    return arr
+
+cdef int64_t get_utcoffset(object tz, Py_ssize_t idx):
+    """
+    Get UTC offsets in microseconds corresponding to DST transitions
+    """
+    cdef:
+        ndarray[int64_t] arr
+    if tz not in utc_offset_cache:
+        utc_offset_cache[tz] = _unbox_utcoffsets(tz._transition_info)
+    arr = utc_offset_cache[tz]
+    return arr[idx]
+
+def tz_normalize_array(ndarray[int64_t] vals, object tz1, object tz2):
+    """
+    Convert DateRange from one time zone to another (using pytz)
+
+    Returns
+    -------
+    normalized : DateRange
+    """
+    cdef:
+        ndarray[int64_t] result
+        ndarray[int64_t] trans
+        Py_ssize_t i, sz, tzidx
+        int64_t v, tz1offset, tz2offset
+
+    if not have_pytz:
+        raise Exception("Could not find pytz module")
+
+    sz = len(vals)
+
+    if sz == 0:
+        return np.empty(0, dtype=np.int64)
+
+    result = np.empty(sz, dtype=np.int64)
+    trans = _get_transitions(tz1)
+
+    tzidx = np.searchsorted(trans, vals[0])
+
+    tz1offset = get_utcoffset(tz1, tzidx)
+    tz2offset = get_utcoffset(tz2, tzidx)
+
+    for i in range(sz):
+        v = vals[i]
+        if v >= trans[tzidx + 1]:
+            tzidx += 1
+            tz1offset = get_utcoffset(tz1, tzidx)
+            tz2offset = get_utcoffset(tz2, tzidx)
+
+        result[i] = (v - tz1offset) + tz2offset
+
+    return result
+
+def tz_localize_array(ndarray[int64_t] vals, object tz):
+    """
+    Localize tzinfo-naive DateRange to given time zone (using pytz). If
+    there are ambiguities in the values, raise AmbiguousTimeError.
+
+    Returns
+    -------
+    localized : DatetimeIndex
+    """
+    cdef:
+        ndarray[int64_t] trans
+        Py_ssize_t i, sz, tzidx
+        int64_t v, t1, t2, currtrans, tmp
+
+    if not have_pytz:
+        raise Exception("Could not find pytz module")
+
+    if tz == pytz.utc or tz is None:
+        return vals
+
+    sz = len(vals)
+
+    if sz == 0:
+        return np.empty(0, dtype=np.int64)
+
+    result = np.empty(sz, dtype=np.int64)
+    trans = _get_transitions(tz)
+    tzidx = np.searchsorted(trans, vals[0])
+
+    currtrans = trans[tzidx]
+    t1 = currtrans + get_utcoffset(tz, tzidx-1)
+    t2 = currtrans + get_utcoffset(tz, tzidx)
+
+    for i in range(sz):
+        v = vals[i]
+        if v >= trans[tzidx + 1]:
+            tzidx += 1
+            currtrans = trans[tzidx]
+            t1 = currtrans + get_utcoffset(tz, tzidx-1)
+            t2 = currtrans + get_utcoffset(tz, tzidx)
+
+        if t1 > t2:
+            tmp = t1
+            t1 = t2
+            t2 = tmp
+
+        if t1 <= v and v <= t2:
+            msg = "Cannot localize, ambiguous time %s found" % Timestamp(v)
+            raise pytz.AmbiguousTimeError(msg)
+
+    return vals
+
 # Accessors
 # ------------------------------------------------------------------------------
 
diff --git a/pandas/tests/test_datetime64.py b/pandas/tests/test_datetime64.py
index 757d9f1b6..03dc75c34 100644
--- a/pandas/tests/test_datetime64.py
+++ b/pandas/tests/test_datetime64.py
@@ -16,6 +16,18 @@ from pandas.util.testing import assert_series_equal
 from pandas.core.groupby import Tinterval
 from pandas.core.datetools import Minute
 
+try:
+    import pytz
+except ImportError:
+    pass
+
+def _skip_if_no_pytz():
+    try:
+        import pytz
+    except ImportError:
+        import nose
+        raise nose.SkipTest
+
 class TestDatetime64(unittest.TestCase):
 
     def setUp(self):
@@ -420,7 +432,7 @@ class TestDatetime64(unittest.TestCase):
 
         self.assertEquals(len(result), len(expect))
         self.assertEquals(len(result.columns), 4)
-        
+
         xs = result.irow(-1)
         self.assertEquals(xs['open'], s[-5])
         self.assertEquals(xs['high'], s[-5:].max())
@@ -440,6 +452,29 @@ class TestDatetime64(unittest.TestCase):
         s = s.convert('B').convert('8H')
         self.assertEquals(len(s), 22)
 
+    def test_tz_localize(self):
+        _skip_if_no_pytz()
+        from pandas.core.datetools import Hour
+
+        dti = DatetimeIndex(start='1/1/2005', end='1/1/2005 0:00:30.256',
+                            freq='L')
+        tz = pytz.timezone('US/Eastern')
+        dti2 = dti.tz_localize(tz)
+
+        self.assert_((dti.values == dti2.values).all())
+
+        tz2 = pytz.timezone('US/Pacific')
+        dti3 = dti2.tz_normalize(tz2)
+
+        self.assert_((dti2.shift(-3, Hour()).values == dti3.values).all())
+
+        dti = DatetimeIndex(start='11/6/2011 1:59', end='11/6/2011 2:00',
+                            freq='L')
+        self.assertRaises(pytz.AmbiguousTimeError, dti.tz_localize, tz)
+
+        dti = DatetimeIndex(start='3/13/2011 1:59', end='3/13/2011 2:00',
+                            freq='L')
+        self.assertRaises(pytz.AmbiguousTimeError, dti.tz_localize, tz)
 
 if __name__ == '__main__':
     import nose

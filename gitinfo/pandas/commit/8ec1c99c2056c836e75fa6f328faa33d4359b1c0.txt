commit 8ec1c99c2056c836e75fa6f328faa33d4359b1c0
Author: Jeff Reback <jeff@reback.net>
Date:   Wed Jul 22 12:09:41 2015 -0400

    DOC: use sub-headings in enhancedperformance.rst

diff --git a/doc/source/enhancingperf.rst b/doc/source/enhancingperf.rst
index 456ac5e79..88bb555a7 100644
--- a/doc/source/enhancingperf.rst
+++ b/doc/source/enhancingperf.rst
@@ -311,7 +311,10 @@ Numba works by generating optimized machine code using the LLVM compiler infrast
 
     As of ``numba`` version 0.20, pandas objects cannot be passed directly to numba-compiled functions. Instead, one must pass the ``numpy`` array underlying the ``pandas`` object to the numba-compiled function as demonstrated below.
 
-We simply take the plain python code from above and annotate with the ``@jit`` decorator.
+jit
+~~~
+
+Using ``numba`` to just-in-time compile your code. We simply take the plain python code from above and annotate with the ``@jit`` decorator.
 
 .. code-block:: python
 
@@ -349,41 +352,44 @@ Note that we directly pass ``numpy`` arrays to the numba function. ``compute_num
     In [4]: %timeit compute_numba(df)
     1000 loops, best of 3: 798 us per loop
 
-``numba`` can also be used to write vectorized functions that do not require the user to explicitly 
-loop over the observations of a vector; a vectorized function will be applied to each row automatically. 
-Consider the following toy example of doubling each observation: 
+vectorize
+~~~~~~~~~
+
+``numba`` can also be used to write vectorized functions that do not require the user to explicitly
+loop over the observations of a vector; a vectorized function will be applied to each row automatically.
+Consider the following toy example of doubling each observation:
 
 .. code-block:: python
 
     import numba
-    
+
     def double_every_value_nonumba(x):
         return x*2
-    
+
     @numba.vectorize
     def double_every_value_withnumba(x):
         return x*2
-    
-    
-    # Custom function without numba	
+
+
+    # Custom function without numba
     In [5]: %timeit df['col1_doubled'] = df.a.apply(double_every_value_nonumba)
     1000 loops, best of 3: 797 us per loop
-    
+
     # Standard implementation (faster than a custom function)
     In [6]: %timeit df['col1_doubled'] = df.a*2
     1000 loops, best of 3: 233 us per loop
-    
+
     # Custom function with numba
     In [7]: %timeit df['col1_doubled'] = double_every_value_withnumba(df.a.values)
     1000 loops, best of 3: 145 us per loop
 
 .. note::
 
-    ``numba`` will execute on any function, but can only accelerate certain classes of functions. 
+    ``numba`` will execute on any function, but can only accelerate certain classes of functions.
 
-``numba`` is best at accelerating functions that apply numerical functions to numpy arrays. When passed a function that only uses operations it knows how to accelerate, it will execute in ``nopython`` mode. 
+``numba`` is best at accelerating functions that apply numerical functions to numpy arrays. When passed a function that only uses operations it knows how to accelerate, it will execute in ``nopython`` mode.
 
-If ``numba`` is passed a function that includes something it doesn't know how to work with -- a category that currently includes sets, lists, dictionaries, or string functions -- it will revert to ``object mode``. In ``object mode``, numba will execute but your code will not speed up significantly. If you would prefer that ``numba`` throw an error if it cannot compile a function in a way that speeds up your code, pass numba the argument ``nopython=True`` (e.g.  ``@numba.jit(nopython=True)``). For more on troubleshooting ``numba`` modes, see the `numba troubleshooting page <http://numba.pydata.org/numba-doc/0.20.0/user/troubleshoot.html#the-compiled-code-is-too-slow>`__. 
+If ``numba`` is passed a function that includes something it doesn't know how to work with -- a category that currently includes sets, lists, dictionaries, or string functions -- it will revert to ``object mode``. In ``object mode``, numba will execute but your code will not speed up significantly. If you would prefer that ``numba`` throw an error if it cannot compile a function in a way that speeds up your code, pass numba the argument ``nopython=True`` (e.g.  ``@numba.jit(nopython=True)``). For more on troubleshooting ``numba`` modes, see the `numba troubleshooting page <http://numba.pydata.org/numba-doc/0.20.0/user/troubleshoot.html#the-compiled-code-is-too-slow>`__.
 
 Read more in the `numba docs <http://numba.pydata.org/>`__.
 

commit 35a1657bceeb62097ae6c64b11221f75d70f7ce2
Author: Kaiqi Dong <kaiqi@kth.se>
Date:   Sun May 17 23:16:51 2020 +0200

    Revert: REF: do length-checks in boilerplate decorator (#34137)

diff --git a/pandas/core/arrays/categorical.py b/pandas/core/arrays/categorical.py
index 737c13016..2a01ab380 100644
--- a/pandas/core/arrays/categorical.py
+++ b/pandas/core/arrays/categorical.py
@@ -64,6 +64,10 @@ def _cat_compare_op(op):
 
     @unpack_zerodim_and_defer(opname)
     def func(self, other):
+        if is_list_like(other) and len(other) != len(self):
+            # TODO: Could this fail if the categories are listlike objects?
+            raise ValueError("Lengths must match.")
+
         if not self.ordered:
             if opname in ["__lt__", "__gt__", "__le__", "__ge__"]:
                 raise TypeError(
diff --git a/pandas/core/arrays/datetimelike.py b/pandas/core/arrays/datetimelike.py
index bbaa64dae..145654805 100644
--- a/pandas/core/arrays/datetimelike.py
+++ b/pandas/core/arrays/datetimelike.py
@@ -84,6 +84,9 @@ def _datetimelike_array_cmp(cls, op):
         elif not is_list_like(other):
             raise InvalidComparison(other)
 
+        elif len(other) != len(self):
+            raise ValueError("Lengths must match")
+
         else:
             try:
                 other = self._validate_listlike(other, opname, allow_object=True)
@@ -1234,6 +1237,9 @@ class DatetimeLikeArrayMixin(
         """
         # overridden by PeriodArray
 
+        if len(self) != len(other):
+            raise ValueError("cannot add indices of unequal length")
+
         if isinstance(other, np.ndarray):
             # ndarray[timedelta64]; wrap in TimedeltaIndex for op
             from pandas.core.arrays import TimedeltaArray
diff --git a/pandas/core/arrays/datetimes.py b/pandas/core/arrays/datetimes.py
index 897c53c5c..90088c370 100644
--- a/pandas/core/arrays/datetimes.py
+++ b/pandas/core/arrays/datetimes.py
@@ -654,6 +654,9 @@ class DatetimeArray(dtl.DatetimeLikeArrayMixin, dtl.TimelikeOps, dtl.DatelikeOps
 
     def _sub_datetime_arraylike(self, other):
         """subtract DatetimeArray/Index or ndarray[datetime64]"""
+        if len(self) != len(other):
+            raise ValueError("cannot add indices of unequal length")
+
         if isinstance(other, np.ndarray):
             assert is_datetime64_dtype(other)
             other = type(self)(other)
diff --git a/pandas/core/arrays/integer.py b/pandas/core/arrays/integer.py
index 3ca7e0289..5a90ea4a3 100644
--- a/pandas/core/arrays/integer.py
+++ b/pandas/core/arrays/integer.py
@@ -517,6 +517,8 @@ class IntegerArray(BaseMaskedArray):
                     raise NotImplementedError(
                         "can only perform ops with 1-d structures"
                     )
+                if len(self) != len(other):
+                    raise ValueError("Lengths must match to compare")
 
             if other is libmissing.NA:
                 # numpy does not handle pd.NA well as "other" scalar (it returns
@@ -620,6 +622,8 @@ class IntegerArray(BaseMaskedArray):
                     raise NotImplementedError(
                         "can only perform ops with 1-d structures"
                     )
+                if len(self) != len(other):
+                    raise ValueError("Lengths must match")
                 if not (is_float_dtype(other) or is_integer_dtype(other)):
                     raise TypeError("can only perform ops with numeric values")
 
diff --git a/pandas/core/arrays/timedeltas.py b/pandas/core/arrays/timedeltas.py
index 4b84b3ea8..bc215eec4 100644
--- a/pandas/core/arrays/timedeltas.py
+++ b/pandas/core/arrays/timedeltas.py
@@ -471,6 +471,10 @@ class TimedeltaArray(dtl.DatetimeLikeArrayMixin, dtl.TimelikeOps):
         if not hasattr(other, "dtype"):
             # list, tuple
             other = np.array(other)
+        if len(other) != len(self) and not is_timedelta64_dtype(other.dtype):
+            # Exclude timedelta64 here so we correctly raise TypeError
+            #  for that instead of ValueError
+            raise ValueError("Cannot multiply with unequal lengths")
 
         if is_object_dtype(other.dtype):
             # this multiplication will succeed only if all elements of other
@@ -514,7 +518,10 @@ class TimedeltaArray(dtl.DatetimeLikeArrayMixin, dtl.TimelikeOps):
             # e.g. list, tuple
             other = np.array(other)
 
-        if is_timedelta64_dtype(other.dtype):
+        if len(other) != len(self):
+            raise ValueError("Cannot divide vectors with unequal lengths")
+
+        elif is_timedelta64_dtype(other.dtype):
             # let numpy handle it
             return self._data / other
 
@@ -564,7 +571,10 @@ class TimedeltaArray(dtl.DatetimeLikeArrayMixin, dtl.TimelikeOps):
             # e.g. list, tuple
             other = np.array(other)
 
-        if is_timedelta64_dtype(other.dtype):
+        if len(other) != len(self):
+            raise ValueError("Cannot divide vectors with unequal lengths")
+
+        elif is_timedelta64_dtype(other.dtype):
             # let numpy handle it
             return other / self._data
 
@@ -613,8 +623,10 @@ class TimedeltaArray(dtl.DatetimeLikeArrayMixin, dtl.TimelikeOps):
         if not hasattr(other, "dtype"):
             # list, tuple
             other = np.array(other)
+        if len(other) != len(self):
+            raise ValueError("Cannot divide with unequal lengths")
 
-        if is_timedelta64_dtype(other.dtype):
+        elif is_timedelta64_dtype(other.dtype):
             other = type(self)(other)
 
             # numpy timedelta64 does not natively support floordiv, so operate
@@ -666,7 +678,10 @@ class TimedeltaArray(dtl.DatetimeLikeArrayMixin, dtl.TimelikeOps):
             # list, tuple
             other = np.array(other)
 
-        if is_timedelta64_dtype(other.dtype):
+        if len(other) != len(self):
+            raise ValueError("Cannot divide with unequal lengths")
+
+        elif is_timedelta64_dtype(other.dtype):
             other = type(self)(other)
 
             # numpy timedelta64 does not natively support floordiv, so operate
diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index b8a9827b5..0f170738f 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -75,7 +75,6 @@ from pandas.core.indexers import deprecate_ndim_indexing
 from pandas.core.indexes.frozen import FrozenList
 import pandas.core.missing as missing
 from pandas.core.ops import get_op_result_name
-from pandas.core.ops.common import unpack_zerodim_and_defer
 from pandas.core.ops.invalid import make_invalid_op
 from pandas.core.sorting import ensure_key_mapped
 from pandas.core.strings import StringMethods
@@ -109,8 +108,10 @@ str_t = str
 
 
 def _make_comparison_op(op, cls):
-    @unpack_zerodim_and_defer(op.__name__)
     def cmp_method(self, other):
+        if isinstance(other, (np.ndarray, Index, ABCSeries, ExtensionArray)):
+            if other.ndim > 0 and len(self) != len(other):
+                raise ValueError("Lengths must match to compare")
 
         if is_object_dtype(self.dtype) and isinstance(other, ABCCategorical):
             left = type(other)(self._values, dtype=other.dtype)
diff --git a/pandas/core/ops/common.py b/pandas/core/ops/common.py
index 1fb939808..515a0a519 100644
--- a/pandas/core/ops/common.py
+++ b/pandas/core/ops/common.py
@@ -1,13 +1,10 @@
 """
 Boilerplate functions used in defining binary operations.
 """
-from collections import UserDict
 from functools import wraps
 from typing import Callable
 
-import numpy as np
-
-from pandas._libs.lib import is_list_like, item_from_zerodim
+from pandas._libs.lib import item_from_zerodim
 from pandas._typing import F
 
 from pandas.core.dtypes.generic import ABCDataFrame, ABCIndexClass, ABCSeries
@@ -65,25 +62,6 @@ def _unpack_zerodim_and_defer(method, name: str):
 
         other = item_from_zerodim(other)
 
-        if isinstance(self, (ABCSeries, ABCDataFrame)) and isinstance(
-            other, (ABCSeries, ABCDataFrame)
-        ):
-            # we dont require length matches
-            pass
-        elif is_list_like(other, allow_sets=False) and not isinstance(
-            other, (dict, UserDict)
-        ):
-            if len(other) != len(self):
-                if len(other) == 1 and not hasattr(other, "dtype"):
-                    # i.e. unpack scalar list, but leave e.g. Categorical,
-                    #  for which the scalar behavior doesnt match the
-                    #  array behavior
-                    other = other[0]
-                else:
-                    raise ValueError(
-                        "Lengths must match", self.shape, np.shape(other), type(other)
-                    )
-
         return method(self, other)
 
     return new_method
diff --git a/pandas/tests/arithmetic/test_datetime64.py b/pandas/tests/arithmetic/test_datetime64.py
index 0fb3cb102..8c480faa4 100644
--- a/pandas/tests/arithmetic/test_datetime64.py
+++ b/pandas/tests/arithmetic/test_datetime64.py
@@ -2206,7 +2206,7 @@ class TestDatetimeIndexArithmetic:
         # different length raises ValueError
         dti1 = date_range("20130101", periods=3)
         dti2 = date_range("20130101", periods=4)
-        msg = "Lengths must match"
+        msg = "cannot add indices of unequal length"
         with pytest.raises(ValueError, match=msg):
             dti1 - dti2
 
diff --git a/pandas/tests/arithmetic/test_numeric.py b/pandas/tests/arithmetic/test_numeric.py
index b6456a214..a37339c66 100644
--- a/pandas/tests/arithmetic/test_numeric.py
+++ b/pandas/tests/arithmetic/test_numeric.py
@@ -649,7 +649,7 @@ class TestMultiplicationDivision:
 
     def test_mul_size_mismatch_raises(self, numeric_idx):
         idx = numeric_idx
-        msg = "Lengths must match"
+        msg = "operands could not be broadcast together"
         with pytest.raises(ValueError, match=msg):
             idx * idx[0:3]
         with pytest.raises(ValueError, match=msg):
diff --git a/pandas/tests/arithmetic/test_timedelta64.py b/pandas/tests/arithmetic/test_timedelta64.py
index 180364420..65e3c6a07 100644
--- a/pandas/tests/arithmetic/test_timedelta64.py
+++ b/pandas/tests/arithmetic/test_timedelta64.py
@@ -451,7 +451,7 @@ class TestTimedelta64ArithmeticUnsorted:
         tm.assert_index_equal(result, expected)
 
         # unequal length
-        msg = "Lengths must match"
+        msg = "cannot add indices of unequal length"
         with pytest.raises(ValueError, match=msg):
             tdi + dti[0:1]
         with pytest.raises(ValueError, match=msg):
@@ -1723,7 +1723,7 @@ class TestTimedeltaArraylikeMulDivOps:
         mismatched = [1, 2, 3, 4]
 
         rng = tm.box_expected(rng, box_with_array)
-        msg = "Lengths must match|Unable to coerce to Series"
+        msg = "Cannot divide vectors|Unable to coerce to Series"
         for obj in [mismatched, mismatched[:2]]:
             # one shorter, one longer
             for other in [obj, np.array(obj), pd.Index(obj)]:
@@ -1905,14 +1905,12 @@ class TestTimedeltaArraylikeMulDivOps:
     def test_td64arr_mul_too_short_raises(self, box_with_array):
         idx = TimedeltaIndex(np.arange(5, dtype="int64"))
         idx = tm.box_expected(idx, box_with_array)
-        msg = "|".join(
-            [
-                "Lengths must match",  # <- EA, Index, Series
-                "cannot use operands with types dtype",  # <- DataFrame
-                "Unable to coerce to Series",  # <- Series
-            ]
+        msg = (
+            "cannot use operands with types dtype|"
+            "Cannot multiply with unequal lengths|"
+            "Unable to coerce to Series"
         )
-        with pytest.raises((ValueError, TypeError), match=msg):
+        with pytest.raises(TypeError, match=msg):
             # length check before dtype check
             idx * idx[:3]
         with pytest.raises(ValueError, match=msg):
diff --git a/pandas/tests/arrays/boolean/test_logical.py b/pandas/tests/arrays/boolean/test_logical.py
index a61746d46..bf4775bbd 100644
--- a/pandas/tests/arrays/boolean/test_logical.py
+++ b/pandas/tests/arrays/boolean/test_logical.py
@@ -46,7 +46,7 @@ class TestLogicalOps(BaseOpsUtil):
     def test_logical_length_mismatch_raises(self, all_logical_operators):
         op_name = all_logical_operators
         a = pd.array([True, False, None], dtype="boolean")
-        msg = "Lengths must match"
+        msg = "Lengths must match to compare"
 
         with pytest.raises(ValueError, match=msg):
             getattr(a, op_name)([True, False])
diff --git a/pandas/tests/arrays/integer/test_arithmetic.py b/pandas/tests/arrays/integer/test_arithmetic.py
index b7fdd8581..18f1dac3c 100644
--- a/pandas/tests/arrays/integer/test_arithmetic.py
+++ b/pandas/tests/arrays/integer/test_arithmetic.py
@@ -232,9 +232,8 @@ class TestArithmeticOps(BaseOpsUtil):
         result = opa(pd.DataFrame({"A": s}))
         assert result is NotImplemented
 
-        # msg = r"can only perform ops with 1-d structures"
-        msg = "Lengths must match"
-        with pytest.raises(ValueError, match=msg):
+        msg = r"can only perform ops with 1-d structures"
+        with pytest.raises(NotImplementedError, match=msg):
             opa(np.arange(len(s)).reshape(-1, len(s)))
 
     @pytest.mark.parametrize("zero, negative", [(0, False), (0.0, False), (-0.0, True)])
diff --git a/pandas/tests/arrays/string_/test_string.py b/pandas/tests/arrays/string_/test_string.py
index 2e047b5c4..6f9a1a5be 100644
--- a/pandas/tests/arrays/string_/test_string.py
+++ b/pandas/tests/arrays/string_/test_string.py
@@ -98,7 +98,7 @@ def test_add_2d():
         a + b
 
     s = pd.Series(a)
-    with pytest.raises(ValueError, match="Lengths must match"):
+    with pytest.raises(ValueError, match="3 != 1"):
         s + b
 
 
diff --git a/pandas/tests/indexes/interval/test_interval.py b/pandas/tests/indexes/interval/test_interval.py
index fac9eb1c3..997887cc1 100644
--- a/pandas/tests/indexes/interval/test_interval.py
+++ b/pandas/tests/indexes/interval/test_interval.py
@@ -579,7 +579,7 @@ class TestIntervalIndex:
         with pytest.raises(TypeError, match=msg):
             self.index > np.arange(2)
 
-        msg = "Lengths must match"
+        msg = "Lengths must match to compare"
         with pytest.raises(ValueError, match=msg):
             self.index > np.arange(3)
 
diff --git a/pandas/tests/indexes/test_base.py b/pandas/tests/indexes/test_base.py
index 9f235dcdb..466b491eb 100644
--- a/pandas/tests/indexes/test_base.py
+++ b/pandas/tests/indexes/test_base.py
@@ -2423,6 +2423,16 @@ class TestMixedIntIndex(Base):
         out2 = "Index([True, False, nan], dtype='object')"
         assert out2 == exp2
 
+    @pytest.mark.filterwarnings("ignore:elementwise comparison failed:FutureWarning")
+    def test_index_with_tuple_bool(self):
+        # GH34123
+        # TODO: remove tupleize_cols=False once correct behaviour is restored
+        # TODO: also this op right now produces FutureWarning from numpy
+        idx = Index([("a", "b"), ("b", "c"), ("c", "a")], tupleize_cols=False)
+        result = idx == ("c", "a",)
+        expected = np.array([False, False, True])
+        tm.assert_numpy_array_equal(result, expected)
+
 
 class TestIndexUtils:
     @pytest.mark.parametrize(

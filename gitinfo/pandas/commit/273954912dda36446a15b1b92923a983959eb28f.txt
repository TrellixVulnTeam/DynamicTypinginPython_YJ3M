commit 273954912dda36446a15b1b92923a983959eb28f
Author: Chang She <chang@lambdafoundry.com>
Date:   Wed May 9 10:12:51 2012 -0400

    ENH: DataFrame.replace and cython replace. Only works for floats and ints. Need to generate datetime64 and object versions.

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 2d834570e..f813e22bc 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2612,6 +2612,136 @@ class DataFrame(NDFrame):
         else:
             return self._constructor(new_data)
 
+    def replace(self, to_replace, value=None, method='pad', axis=0,
+                inplace=False, limit=None):
+        """
+        Replace values given in 'to_replace' with 'value' or using 'method'
+
+        Parameters
+        ----------
+        value : scalar or dict, default None
+            Value to use to fill holes (e.g. 0), alternately a dict of values
+            specifying which value to use for each column (columns not in the
+            dict will not be filled)
+        method : {'backfill', 'bfill', 'pad', 'ffill', None}, default 'pad'
+            Method to use for filling holes in reindexed Series
+            pad / ffill: propagate last valid observation forward to next valid
+            backfill / bfill: use NEXT valid observation to fill gap
+        axis : {0, 1}, default 0
+            0: fill column-by-column
+            1: fill row-by-row
+        inplace : boolean, default False
+            If True, fill the DataFrame in place. Note: this will modify any
+            other views on this DataFrame, like if you took a no-copy slice of
+            an existing DataFrame, for example a column in a DataFrame. Returns
+            a reference to the filled object, which is self if inplace=True
+        limit : int, default None
+            Maximum size gap to forward or backward fill
+
+        See also
+        --------
+        reindex, asfreq
+
+        Returns
+        -------
+        filled : DataFrame
+        """
+        self._consolidate_inplace()
+
+        if value is None:
+            if self._is_mixed_type and axis == 1:
+                return self.T.replace(to_replace, method=method, limit=limit).T
+
+            method = com._clean_fill_method(method)
+
+            if isinstance(to_replace, dict):
+                rs = self if inplace else self.copy()
+                for k, v in to_replace.iteritems():
+                    if k in rs:
+                        rs[k].replace(v, method=method, limit=limit,
+                                      inplace=True)
+                return rs
+
+            else:
+                new_blocks = []
+                for block in self._data.blocks:
+                    newb = block.interpolate(method, axis=axis,
+                                             limit=limit, inplace=inplace,
+                                             missing=to_replace)
+                    new_blocks.append(newb)
+                new_data = BlockManager(new_blocks, self._data.axes)
+        else:
+            # Float type values
+            if len(self.columns) == 0:
+                return self
+
+            if np.isscalar(to_replace):
+                if np.isscalar(value): # np.nan -> 0
+                    new_data = self._data.replace(to_replace, value,
+                                                  inplace=inplace)
+                    if inplace:
+                        self._data = new_data
+                        return self
+                    else:
+                        return self._constructor(new_data)
+
+                elif isinstance(value, dict): # np.nan -> {'A' : 0, 'B' : -1}
+                    return self._replace_dest_dict(to_replace, value, inplace)
+
+            elif isinstance(to_replace, dict):
+                if np.isscalar(value): # {'A' : np.nan, 'B' : ''} -> 0
+                    return self._replace_src_dict(to_replace, value, inplace)
+                elif isinstance(value, dict): # {'A' : np.nan} -> {'A' : 0}
+                    return self._replace_both_dict(to_replace, value, inplace)
+                else:
+                    raise ValueError('Fill value must be scalar or dict')
+                return rs
+
+            elif isinstance(to_replace, (list, np.ndarray)):
+                # [np.nan, ''] -> [0, 'missing']
+                if isinstance(value, (list, np.ndarray)):
+                    if len(to_replace) != len(value):
+                        raise ValueError('Replacement lists must match '
+                                         'in length. Expecting %d got %d ' %
+                                         (len(to_replace), len(value)))
+
+                    new_data = self._data if inplace else self.copy()._data
+                    for s, d in zip(to_replace, value):
+                        new_data = new_data.replace(s, d, inplace=True)
+
+                else: # [np.nan, ''] -> 0
+                    new_data = self._data.replace(to_replace, value,
+                                                  inplace=inplace)
+                if inplace:
+                    self._data = new_data
+                    return self
+                else:
+                    return self._constructor(new_data)
+            else:
+                raise ValueError('Invalid to_replace type: %s' %
+                                 type(to_replace))
+
+    def _replace_dest_dict(self, to_replace, value, inplace):
+        rs = self if inplace else self.copy()
+        for k, v in value.iteritems():
+            if k in rs:
+                rs[k].replace(to_replace, v, inplace=True)
+        return rs
+
+    def _replace_src_dict(self, to_replace, value, inplace):
+        rs = self if inplace else self.copy()
+        for k, src in to_replace.iteritems():
+            if k in rs:
+                rs[k].replace(src, value, inplace=True)
+        return rs
+
+    def _replace_both_dict(self, to_replace, value, inplace):
+        rs = self if inplace else self.copy()
+        for c, src in to_replace.iteritems():
+            if c in value and c in rs:
+                rs[c].replace(src, value[c], inplace=True)
+        return rs
+
     #----------------------------------------------------------------------
     # Rename
 
@@ -4388,7 +4518,6 @@ def _is_sequence(x):
     except Exception:
         return False
 
-
 def install_ipython_completers():  # pragma: no cover
     """Register the DataFrame type with IPython's tab completion machinery, so
     that it knows about accessing column names as attributes."""
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 77969ffa2..1bd644e9d 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -208,16 +208,18 @@ class Block(object):
         return left_block, right_block
 
     def fillna(self, value, inplace=False):
-        new_values = self.values if inplace else self.values.copy()
-        mask = com.isnull(new_values.ravel())
-        new_values.flat[mask] = value
+        return self.replace(np.nan, value, inplace)
 
+    def replace(self, to_replace, value, inplace=False):
+        new_values = self.values if inplace else self.values.copy()
+        lib.replace(new_values, to_replace, value)
         if inplace:
             return self
         else:
             return make_block(new_values, self.items, self.ref_items)
 
-    def interpolate(self, method='pad', axis=0, inplace=False, limit=None):
+    def interpolate(self, method='pad', axis=0, inplace=False,
+                    limit=None, missing=None):
         values = self.values if inplace else self.values.copy()
 
         if values.ndim != 2:
@@ -225,10 +227,15 @@ class Block(object):
 
         transf = (lambda x: x) if axis == 0 else (lambda x: x.T)
 
+        if missing is None:
+            mask = None
+        else: # todo create faster fill func without masking
+            mask = _mask_missing(values, missing)
+
         if method == 'pad':
-            com.pad_2d(transf(values), limit=limit)
+            com.pad_2d(transf(values), limit=limit, mask=mask)
         else:
-            com.backfill_2d(transf(values), limit=limit)
+            com.backfill_2d(transf(values), limit=limit, mask=mask)
 
         return make_block(values, self.items, self.ref_items)
 
@@ -239,6 +246,18 @@ class Block(object):
                                    fill_value=fill_value)
         return make_block(new_values, self.items, self.ref_items)
 
+def _mask_missing(array, missing_values):
+    missing_values = np.array(list(missing_values), dtype=object)
+    if com.isnull(missing_values).any():
+        mask = com.isnull(array)
+        missing_values = missing_values[com.notnull(missing_values)]
+    for v in missing_values:
+        if mask is None:
+            mask = array == missing_values
+        else:
+            mask |= array == missing_values
+    return mask
+
 #-------------------------------------------------------------------------------
 # Is this even possible?
 
@@ -949,10 +968,10 @@ class BlockManager(object):
         return self.rename_items(f)
 
     def fillna(self, value, inplace=False):
-        """
+        return self.replace(np.nan, value, inplace)
 
-        """
-        new_blocks = [b.fillna(value, inplace=inplace)
+    def replace(self, to_replace, value, inplace=False):
+        new_blocks = [b.replace(to_replace, value, inplace=inplace)
                       if b._can_hold_na else b
                       for b in self.blocks]
         if inplace:
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 854e434e0..434230a52 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2095,14 +2095,14 @@ copy : boolean, default False
         return result
 
 
-    def replace(self, to_replace=None, value=None, method='pad', inplace=False,
+    def replace(self, to_replace, value=None, method='pad', inplace=False,
                 limit=None):
         """
         Replace arbitrary values in a Series
 
         Parameters
         ----------
-        to_replace : list or dict, default None
+        to_replace : list or dict
             list of values to be replaced or dict of replacement values
         value : anything
             if to_replace is a list then value is the replacement value
@@ -2133,8 +2133,7 @@ copy : boolean, default False
         single_val = False
 
         def _rep_one(s, to_rep, v): # replace single value
-            m = _mask_missing(s, to_rep)
-            np.putmask(s, m, v)
+            lib.replace(s.values, to_rep, v)
             return s
 
         def _rep_dict(rs, to_rep): # replace {[src] -> dest}
@@ -2152,7 +2151,6 @@ copy : boolean, default False
         if isinstance(to_replace, (list, np.ndarray)):
 
             if isinstance(value, (list, np.ndarray)): # check same length
-
                 vl, rl = len(value), len(to_replace)
                 if vl == rl:
                     return _rep_dict(result, dict(zip(to_replace, value)))
diff --git a/pandas/src/codegen_replace.py b/pandas/src/codegen_replace.py
new file mode 100644
index 000000000..12593d8d3
--- /dev/null
+++ b/pandas/src/codegen_replace.py
@@ -0,0 +1,187 @@
+from copy import deepcopy
+import numpy as np
+
+#------------------------------------------------------------------------
+# Replace : slightly adapted from bottleneck
+
+loop_template = 'for iINDEX%d in range(nINDEX%d):'
+indent = '    '
+#replace_op = ('%sif mask[INDEXALL]:\n'
+#              '%s    a[INDEXALL] = new%s')
+
+nonna_op = ('%sai = a[INDEXALL]\n'
+            '%sif ai == old:\n'
+            '%s    a[INDEXALL] = new%s')
+na_op = ('%sai = a[INDEXALL]\n'
+         '%sif ai != ai:\n'
+         '%s    a[INDEXALL] = new%s')
+
+generic_top = """
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def NAME_NDIMd_DTYPE_axisAXIS(np.ndarray[np.DTYPE_t, ndim=NDIM] a,
+    double old, double new):
+    "replace (inplace) specified elements of NDIMd array of dtype=DTYPE."
+    cdef np.DTYPE_t ai
+"""
+
+int_check = """\
+        oldint = <np.DTYPE_t>old
+        newint = <np.DTYPE_t>new
+        if oldint != old:
+            raise ValueError('Cannot safely cast `old` to int.')
+        if newint != new:
+            raise ValueError('Cannot safely cast `new` to int.')
+"""
+
+def float_loop(ndims=3, type_suffix=''):
+    loop = {}
+    for n in range(1, ndims + 1):
+        loop_str = indent + 'if old==old: \n'
+        for i in range(n): # for i in range:
+            loop_str += indent * (i + 2) + (loop_template % (i, i)) + '\n'
+
+        dent = indent * (n + 2)
+        loop_str += nonna_op % (dent, dent, dent, type_suffix)
+
+        loop_str += '\n' + indent + 'else:\n'
+        for i in range(n): # for i in range:
+            loop_str += indent * (i + 2) + (loop_template % (i, i)) + '\n'
+
+        dent = indent * (n + 2)
+        loop_str += na_op % (dent, dent, dent, type_suffix)
+
+        loop[n] = loop_str + '\n'
+    return loop
+
+def int_loop(ndims=3, type_suffix='int'):
+    loop = {}
+    for n in range(1, ndims + 1):
+        loop_str = indent + 'if old==old: \n' + int_check
+        for i in range(n): # for i in range:
+            loop_str += indent * (i + 2) + (loop_template % (i, i)) + '\n'
+
+        dent = indent * (n + 2)
+        loop_str += nonna_op % (dent, dent, dent, type_suffix)
+        loop[n] = loop_str + '\n'
+    return loop
+
+
+# float type functions
+floats = {}
+floats['dtypes'] = ['float32', 'float64']
+floats['axisNone'] = True
+floats['force_output_dtype'] = False
+floats['reuse_non_nan_func'] = False
+floats['top'] = generic_top
+floats['loop'] = float_loop()
+
+# int type functions
+ints = deepcopy(floats)
+ints['dtypes'] = ['int32', 'int64']
+ints['top'] = generic_top + """
+    cdef np.DTYPE_t oldint, newint
+    newint = <np.DTYPE_t>new
+    if newint != new:
+        raise ValueError('Cannot safely cast `new` to int.')
+"""
+ints['loop'] = int_loop()
+
+# Slow, unaccelerated ndim/dtype --------------------------------------------
+def replace(arr, old, new):
+    "Slow replace (inplace) used for unaccelerated ndim/dtype combinations."
+    if type(arr) is not np.ndarray:
+        raise TypeError("`arr` must be a numpy array.")
+    if not issubclass(arr.dtype.type, np.inexact):
+        if int(old) != old:
+            raise ValueError("Cannot safely cast `old` to int.")
+        if int(new) != new:
+            raise ValueError("Cannot safely cast `new` to int.")
+    if old != old:
+        mask = np.isnan(arr)
+    else:
+        mask = arr == old
+    np.putmask(arr, mask, new)
+
+slow = {}
+slow['name'] = "replace"
+slow['signature'] = "arr, old, new"
+slow['func'] = "slow_replace(arr, old, new)"
+
+replace = {}
+replace['name'] = 'replace'
+replace['is_reducing_function'] = False
+replace['cdef_output'] = False
+replace['slow'] = slow
+replace['templates'] = {}
+replace['templates']['float_None'] = floats
+replace['templates']['int_None'] = ints
+replace['pyx_file'] = 'replace.pyx'
+
+replace['main'] = '''"replace auto-generated from template"
+
+def replace(arr, old, new):
+    """
+    Replace (inplace) given scalar values of an array with new values.
+
+    similar to putmask but faster
+
+    Parameters
+    ----------
+    arr : numpy.ndarray
+        The input array, which is also the output array since this functions
+        works inplace.
+    old : scalar
+    new : scalar
+        All masked elements in `arr` will be replaced by `new`.
+
+    Returns
+    -------
+    None, the operation is inplace.
+    """
+    func = replace_selector(arr)
+    if np.isscalar(old):
+        return func(arr, old, new)
+    else:
+        for o in old:
+            arr = func(arr, o, new)
+        return arr
+
+def replace_selector(arr):
+    """
+    Return replace function and array that matches `arr`.
+
+    Under the hood Bottleneck uses a separate replace() Cython function for
+    each combination of ndim and dtype. A lot of the overhead in bn.replace()
+    is inselecting the low level function to use.
+
+    You can get rid of the overhead by doing all this before you, for example,
+    enter an inner loop, by using this function.
+
+    Parameters
+    ----------
+    arr : numpy.ndarray
+        Input array.
+
+    Returns
+    -------
+    func : function
+        The replace() function that matches the number of dimensions and dtype
+        of the input array.
+    """
+    axis = None
+    if type(arr) is not np.ndarray:
+        raise TypeError("`arr` must be a numpy array.")
+    cdef int ndim = PyArray_NDIM(arr)
+    cdef int dtype = PyArray_TYPE(arr)
+    cdef tuple key = (ndim, dtype, axis)
+    try:
+        func = replace_dict[key]
+    except KeyError:
+        try:
+            func = replace_slow_dict[axis]
+        except KeyError:
+            tup = (str(ndim), str(arr.dtype), str(axis))
+            raise TypeError("Unsupported ndim/dtype/axis (%s/%s/%s)." % tup)
+    return func
+'''
diff --git a/pandas/src/codegen_template.py b/pandas/src/codegen_template.py
new file mode 100644
index 000000000..a43d936e7
--- /dev/null
+++ b/pandas/src/codegen_template.py
@@ -0,0 +1,408 @@
+"Copied from bottleneck: Turn templates into Cython pyx files."
+import os.path
+
+def template(func):
+    "'Convert template dictionary `func` to a pyx file.'\n"
+    codes = []
+    codes.append(func['main'])
+    select = Selector(func['name'])
+    for key in func['templates']:
+        f = func['templates'][key]
+        code = subtemplate(name=func['name'],
+                           top=f['top'],
+                           loop=f['loop'],
+                           axisNone=f['axisNone'],
+                           dtypes=f['dtypes'],
+                           force_output_dtype=f['force_output_dtype'],
+                           reuse_non_nan_func=f['reuse_non_nan_func'],
+                           is_reducing_function=func['is_reducing_function'],
+                           cdef_output=func['cdef_output'],
+                           select=select)
+        codes.append(code)
+    codes.append('\n' + str(select))
+    if 'slow' in func:
+        if func['slow'] is not None:
+            slow = func['slow']
+            code1 = slow_selector(slow['name'])
+            code2 = slow_functions(slow['name'],
+                                   slow['signature'],
+                                   slow['func'])
+            codes.append(code2)
+            codes.append(code1)
+    modpath = os.path.dirname(__file__)
+    fid = open(os.path.join(modpath, func['pyx_file']), 'w')
+    fid.write(''.join(codes))
+    fid.close()
+
+def subtemplate(name, top, loop, axisNone, dtypes, force_output_dtype,
+                reuse_non_nan_func, is_reducing_function, cdef_output, select):
+    "Assemble template"
+    ndims = sorted(loop.keys())
+    funcs = []
+    for ndim in ndims:
+        if axisNone:
+            axes = [None]
+        else:
+            axes = list(range(ndim))
+        for dtype in dtypes:
+            for axis in axes:
+
+                if reuse_non_nan_func:
+
+                    select.append(ndim, dtype, axis, True)
+
+                else:
+
+                    # Code template
+                    func = top
+
+                    # loop
+                    if force_output_dtype is not False:
+                        ydtype = force_output_dtype
+                    else:
+                        ydtype = dtype
+                    func += loop_cdef(ndim, ydtype, axis, is_reducing_function,
+                                      cdef_output)
+                    func += looper(loop[ndim], ndim, axis)
+
+                    # name, ndim, dtype, axis
+                    func = func.replace('NAME', name)
+                    func = func.replace('NDIM', str(ndim))
+                    func = func.replace('DTYPE', dtype)
+                    func = func.replace('AXIS', str(axis))
+
+                    funcs.append(func)
+                    select.append(ndim, dtype, axis)
+
+    return ''.join(funcs)
+
+def looper(loop, ndim, axis):
+    """
+    Given loop template, expand index markers for given `ndim` and `axis`.
+
+    Parameters
+    ----------
+    loop : str
+        Code of loop where the following template markers will be expanded
+        (example given is for 3d input, similarly for other nd):
+
+        ================= =================================================
+        INDEXALL          Replace with i0, i1, i2
+        INDEXPOP          If axis=1, e.g., replace with i0, i2
+        INDEXN            If N=1, e.g., replace with 1
+        INDEXREPLACE|exp| If exp = 'k - window' and axis=1, e.g., replace
+                          with i0, k - window, i2
+        NREPLACE|exp|     If exp = 'n - window' and axis=1, e.g., replace
+                          with n0, n - window, n2
+        ================= =================================================
+    ndim : int
+        Number of dimensions in the loop.
+    axis : {int, None}
+        Axis over which the loop is evaluated.
+
+    Returns
+    -------
+    code : str
+        Code for the loop with templated index markers expanded.
+
+    Examples
+    --------
+    Make a 3d loop template:
+
+    >>> loop = '''
+    .... for iINDEX0 in range(nINDEX0):
+    ....    for iINDEX1 in range(nINDEX1):
+    ....        amin = MAXDTYPE
+    ....        for iINDEX2 in range(nINDEX2):
+    ....            ai = a[INDEXALL]
+    ....            if ai <= amin:
+    ....                amin = ai
+    ....         y[INDEXPOP] = amin
+    .... '''
+
+    Import the looper function:
+
+    >>> from bottleneck.src.template.template import looper
+
+    Make a loop over axis=0:
+
+    >>> print(looper(loop, ndim=3, axis=0))
+    for i1 in range(n1):
+        for i2 in range(n2):
+            amin = MAXDTYPE
+            for i0 in range(n0):
+                ai = a[i0, i1, i2]
+                if ai <= amin:
+                    amin = ai
+            y[i1, i2] = amin
+
+    Make a loop over axis=1:
+
+    >>> print(looper(loop, ndim=3, axis=1))
+    for i0 in range(n0):
+        for i2 in range(n2):
+            amin = MAXDTYPE
+            for i1 in range(n1):
+                ai = a[i0, i1, i2]
+                if ai <= amin:
+                    amin = ai
+            y[i0, i2] = amin
+
+    Make a loop over axis=2:
+
+    >>> print(looper(loop, ndim=3, axis=2))
+    for i0 in range(n0):
+        for i1 in range(n1):
+            amin = MAXDTYPE
+            for i2 in range(n2):
+                ai = a[i0, i1, i2]
+                if ai <= amin:
+                    amin = ai
+            y[i0, i1] = amin
+
+    """
+
+    if ndim < 1:
+        raise ValueError("ndim(=%d) must be and integer greater than 0" % ndim)
+    if axis is not None:
+        if axis < 0:
+            raise ValueError("`axis` must be a non-negative integer or None")
+        elif axis >= ndim:
+            raise ValueError("`axis` must be less then `ndim`")
+
+    # INDEXALL
+    INDEXALL = ', '.join('i' + str(i) for i in range(ndim))
+    code = loop.replace('INDEXALL', INDEXALL)
+
+    # INDEXPOP
+    idx = list(range(ndim))
+    if axis is not None:
+        idx.pop(axis)
+    INDEXPOP = ', '.join(['i' + str(i) for i in idx])
+    code = code.replace('INDEXPOP', INDEXPOP)
+
+    # INDEXN
+    idx = list(range(ndim))
+    if axis is not None:
+        idxpop = idx.pop(axis)
+        idx.append(idxpop)
+    for i, j in enumerate(idx):
+        code = code.replace('INDEX%d' % i, '%d' % j)
+
+    # INDEXREPLACE|x|
+    mark = 'INDEXREPLACE|'
+    nreplace = code.count(mark)
+    if (nreplace > 0) and (axis is None):
+        raise ValueError("`INDEXREPLACE` cannot be used when axis is None.")
+    while mark in code:
+        idx0 = code.index(mark)
+        idx1 = idx0 + len(mark)
+        idx2 = idx1 + code[idx1:].index('|')
+        if (idx0 >= idx1) or (idx1 >= idx2):
+            raise RuntimeError("Parsing error or poorly formatted input.")
+        replacement = code[idx1:idx2]
+        idx = ['i' + str(i) for i in range(ndim)]
+        idx[axis] = replacement
+        idx = ', '.join(idx)
+        code = code[:idx0] + idx + code[idx2+1:]
+
+    # NREPLACE|x|
+    mark = 'NREPLACE|'
+    nreplace = code.count(mark)
+    # TODO: reuse while loop above, only difference is 'i' --> 'n'
+    while mark in code:
+        idx0 = code.index(mark)
+        idx1 = idx0 + len(mark)
+        idx2 = idx1 + code[idx1:].index('|')
+        if (idx0 >= idx1) or (idx1 >= idx2):
+            raise RuntimeError("Parsing error or poorly formatted input.")
+        replacement = code[idx1:idx2]
+        idx = ['n' + str(i) for i in range(ndim)]
+        idx[axis] = replacement
+        idx = ', '.join(idx)
+        code = code[:idx0] + idx + code[idx2+1:]
+
+    return code
+
+def loop_cdef(ndim, dtype, axis, is_reducing_function, cdef_output=True):
+    """
+    String of code that initializes variables needed in a for loop.
+
+    The output string contains code for: index array counters, one for each
+    dimension (cdef Py_size_t i0, i1, i2, ....); the length along each
+    dimension of the input array, `a` (cdef Py_ssize_t n0 = a.shape[0],...);
+    the initialized, empty output array, `y`.
+
+    Parameters
+    ----------
+    ndim = int
+        Number of dimensions.
+    dtype : str
+        The data type of the output. Used for initilizing the empty output
+        array, `y`.
+    is_reducing_function : bool
+        If True then remove the dimension given by `axis` when initializing
+        the output array, `y`.
+    cdef_output : bool, optional
+        If False then only initialize indices (i) and shapes (n). If True
+        (default) then also intialized output array `y`.
+
+    Returns
+    -------
+    cdefs : str
+        String of code to use to initialize variables needed for loop.
+
+    Examples
+    --------
+    Define parameters:
+
+    >>> ndim = 3
+    >>> dtype = 'float64'
+    >>> axis = 1
+    >>> is_reducing_function = True
+
+    Import loop_cdef:
+
+    >>> from bottleneck.src.template.template import loop_cdef
+
+    Make loop initialization code:
+
+    >>> print(loop_cdef(ndim, dtype, axis, is_reducing_function))
+        cdef Py_ssize_t i0, i1, i2
+        cdef np.npy_intp *dim
+        dim = PyArray_DIMS(a)
+        Py_ssize_t n0 = dim[0]
+        Py_ssize_t n1 = dim[1]
+        Py_ssize_t n2 = dim[2]
+        cdef np.npy_intp *dims = [n0, n2]
+        cdef np.ndarray[np.float64_t, ndim=2] y = PyArray_EMPTY(2, dims,
+                                                  NPY_float64, 0)
+
+    Repeat, but this time make the output non-reducing:
+
+    >>> is_reducing_function = False
+    >>> print(loop_cdef(ndim, dtype, axis, is_reducing_function))
+        cdef Py_ssize_t i0, i1, i2
+        cdef np.npy_intp *dim
+        dim = PyArray_DIMS(a)
+        Py_ssize_t n0 = dim[0]
+        Py_ssize_t n1 = dim[1]
+        Py_ssize_t n2 = dim[2]
+        cdef np.npy_intp *dims = [n0, n1, n2]
+        cdef np.ndarray[np.float64_t, ndim=3] y = PyArray_EMPTY(3, dims,
+                                                  NPY_float64, 0)
+
+    """
+
+    if ndim < 1:
+        raise ValueError("ndim(=%d) must be and integer greater than 0" % ndim)
+    if axis is not None:
+        if axis < 0:
+            raise ValueError("`axis` must be a non-negative integer or None")
+        elif axis >= ndim:
+            raise ValueError("`axis` must be less then `ndim`")
+
+    tab = '    '
+    cdefs = []
+
+    # cdef loop indices
+    idx = ', '.join('i'+str(i) for i in range(ndim))
+    cdefs.append(tab + 'cdef Py_ssize_t ' + idx)
+
+    # Length along each dimension
+    cdefs.append(tab + "cdef np.npy_intp *dim")
+    cdefs.append(tab + "dim = PyArray_DIMS(a)")
+    for dim in range(ndim):
+        cdefs.append(tab + "cdef Py_ssize_t n%d = dim[%d]" % (dim, dim))
+
+    if not cdef_output:
+        return '\n'.join(cdefs) + '\n'
+
+    # cdef initialize output
+    if is_reducing_function:
+        if (ndim > 1) and (axis is not None):
+            idx = list(range(ndim))
+            del idx[axis]
+            ns = ', '.join(['n'+str(i) for i in idx])
+            cdefs.append("%scdef np.npy_intp *dims = [%s]" % (tab, ns))
+            y = "%scdef np.ndarray[np.%s_t, ndim=%d] "
+            y += "y = PyArray_EMPTY(%d, dims,"
+            y += "\n                                              NPY_%s, 0)"
+            cdefs.append(y % (tab, dtype, ndim-1, ndim-1, dtype))
+    else:
+        idx = list(range(ndim))
+        ns = ', '.join('n'+str(i) for i in idx)
+        cdefs.append("%scdef np.npy_intp *dims = [%s]" % (tab, ns))
+        y = "%scdef np.ndarray[np.%s_t, ndim=%d] "
+        y += "y = PyArray_EMPTY(%d, dims,"
+        y += "\n                                              NPY_%s, 0)"
+        cdefs.append(y % (tab, dtype, ndim, ndim, dtype))
+
+    return '\n'.join(cdefs) + '\n'
+
+class Selector(object):
+    "String of code for dictionary that maps dtype to cython function."
+
+    def __init__(self, name):
+        self.name = name
+        self.data = []
+
+    def append(self, ndim, dtype, axis, reuse=False):
+        self.data.append((ndim, dtype, axis, reuse))
+
+    def __str__(self):
+        fmt = "%s_dict[(%s, NPY_%s, %s)] = %s_%sd_%s_axis%s"
+        src = []
+        src.append("cdef dict %s_dict = {}" % self.name)
+        for ndim, dtype, axis, reuse in self.data:
+            name = self.name
+            if reuse:
+                name = name.replace('nan', '')
+            if (ndim == 1) and (axis is None):
+                tup = (self.name, str(ndim), str(dtype), str(0),
+                       name, str(ndim), str(dtype), str(axis))
+                src.append(fmt % tup)
+            tup = (self.name, str(ndim), str(dtype), str(axis),
+                   name, str(ndim), str(dtype), str(axis))
+            src.append(fmt % tup)
+        return '\n'.join(src)
+
+def slow_selector(name, maxaxis=32):
+    "String of code for slow function mapping dictionary."
+    axes = list(range(maxaxis+1)) + [None]
+    src = ['\n']
+    src.append("cdef dict %s_slow_dict = {}" % name)
+    fmt = "%s_slow_dict[%s] = %s_slow_axis%s"
+    for axis in axes:
+        tup = 2 * (name, str(axis))
+        src.append(fmt % tup)
+    return '\n'.join(src)
+
+def slow_functions(name, signature, func, maxaxis=32):
+    "String of code for slow functions."
+    axes = list(range(maxaxis+1)) + [None]
+    tab = '    '
+    sig = "def %s_slow_axis%s(%s):"
+    doc = '%s"Unaccelerated (slow) %s along axis %s."'
+    function = "%sreturn %s\n"
+    src = ['\n']
+    for axis in axes:
+
+        axis = str(axis)
+
+        # signature
+        code = sig % (name, axis, signature)
+        code = code.replace('AXIS', axis)
+        src.append(code)
+
+        # docstring
+        code = doc % (tab, name, axis)
+        code = code.replace('AXIS', axis)
+        src.append(code)
+
+        # function
+        code = function % (tab, func)
+        code = code.replace('AXIS', axis)
+        src.append(code)
+
+    return '\n'.join(src)
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index 643d70831..eb458dd85 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -1,4 +1,7 @@
+import os
 from pandas.util.py3compat import StringIO
+from pandas.src.codegen_template import template as pyx_template
+from pandas.src.codegen_replace import replace
 
 header = """
 cimport numpy as np
@@ -867,6 +870,10 @@ def put2d_%(name)s_%(dest_type)s(ndarray[%(c_type)s, ndim=2, cast=True] values,
         out[i] = values[j, loc]
 """
 
+
+#-------------------------------------------------------------------------
+# Generators
+
 def generate_put_functions():
     function_list = [
         ('float64', 'float64_t', 'object'),
@@ -936,7 +943,9 @@ templates_2d = [take_2d_axis0_template,
 # templates_1d_datetime = [take_1d_template]
 # templates_2d_datetime = [take_2d_axis0_template,
 #                          take_2d_axis1_template]
-
+def codegen_pyx(funcs):
+    for func in funcs:
+        pyx_template(funcs[func])
 
 def generate_take_cython_file(path='generated.pyx'):
     with open(path, 'w') as f:
@@ -960,6 +969,7 @@ def generate_take_cython_file(path='generated.pyx'):
         print >> f, generate_ensure_dtypes()
 
         # print >> f, generate_put_functions()
+        codegen_pyx({'replace': replace})
 
 if __name__ == '__main__':
     generate_take_cython_file()
diff --git a/pandas/src/replace.pyx b/pandas/src/replace.pyx
new file mode 100644
index 000000000..c785518e9
--- /dev/null
+++ b/pandas/src/replace.pyx
@@ -0,0 +1,575 @@
+"replace auto-generated from template"
+
+def replace(arr, old, new):
+    """
+    Replace (inplace) given scalar values of an array with new values.
+
+    similar to putmask but faster
+
+    Parameters
+    ----------
+    arr : numpy.ndarray
+        The input array, which is also the output array since this functions
+        works inplace.
+    old : scalar
+    new : scalar
+        All masked elements in `arr` will be replaced by `new`.
+
+    Returns
+    -------
+    None, the operation is inplace.
+    """
+    func = replace_selector(arr)
+    if np.isscalar(old):
+        return func(arr, old, new)
+    else:
+        for o in old:
+            arr = func(arr, o, new)
+        return arr
+
+def replace_selector(arr):
+    """
+    Return replace function and array that matches `arr`.
+
+    Under the hood Bottleneck uses a separate replace() Cython function for
+    each combination of ndim and dtype. A lot of the overhead in bn.replace()
+    is inselecting the low level function to use.
+
+    You can get rid of the overhead by doing all this before you, for example,
+    enter an inner loop, by using this function.
+
+    Parameters
+    ----------
+    arr : numpy.ndarray
+        Input array.
+
+    Returns
+    -------
+    func : function
+        The replace() function that matches the number of dimensions and dtype
+        of the input array.
+    """
+    axis = None
+    if type(arr) is not np.ndarray:
+        raise TypeError("`arr` must be a numpy array.")
+    cdef int ndim = PyArray_NDIM(arr)
+    cdef int dtype = PyArray_TYPE(arr)
+    cdef tuple key = (ndim, dtype, axis)
+    try:
+        func = replace_dict[key]
+    except KeyError:
+        try:
+            func = replace_slow_dict[axis]
+        except KeyError:
+            tup = (str(ndim), str(arr.dtype), str(axis))
+            raise TypeError("Unsupported ndim/dtype/axis (%s/%s/%s)." % tup)
+    return func
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def replace_1d_int32_axisNone(np.ndarray[np.int32_t, ndim=1] a,
+    double old, double new):
+    "replace (inplace) specified elements of 1d array of dtype=int32."
+    cdef np.int32_t ai
+
+    cdef np.int32_t oldint, newint
+    newint = <np.int32_t>new
+    if newint != new:
+        raise ValueError('Cannot safely cast `new` to int.')
+    cdef Py_ssize_t i0
+    cdef np.npy_intp *dim
+    dim = PyArray_DIMS(a)
+    cdef Py_ssize_t n0 = dim[0]
+    if old==old: 
+        oldint = <np.int32_t>old
+        newint = <np.int32_t>new
+        if oldint != old:
+            raise ValueError('Cannot safely cast `old` to int.')
+        if newint != new:
+            raise ValueError('Cannot safely cast `new` to int.')
+        for i0 in range(n0):
+            ai = a[i0]
+            if ai == old:
+                a[i0] = newint
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def replace_1d_int64_axisNone(np.ndarray[np.int64_t, ndim=1] a,
+    double old, double new):
+    "replace (inplace) specified elements of 1d array of dtype=int64."
+    cdef np.int64_t ai
+
+    cdef np.int64_t oldint, newint
+    newint = <np.int64_t>new
+    if newint != new:
+        raise ValueError('Cannot safely cast `new` to int.')
+    cdef Py_ssize_t i0
+    cdef np.npy_intp *dim
+    dim = PyArray_DIMS(a)
+    cdef Py_ssize_t n0 = dim[0]
+    if old==old: 
+        oldint = <np.int64_t>old
+        newint = <np.int64_t>new
+        if oldint != old:
+            raise ValueError('Cannot safely cast `old` to int.')
+        if newint != new:
+            raise ValueError('Cannot safely cast `new` to int.')
+        for i0 in range(n0):
+            ai = a[i0]
+            if ai == old:
+                a[i0] = newint
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def replace_2d_int32_axisNone(np.ndarray[np.int32_t, ndim=2] a,
+    double old, double new):
+    "replace (inplace) specified elements of 2d array of dtype=int32."
+    cdef np.int32_t ai
+
+    cdef np.int32_t oldint, newint
+    newint = <np.int32_t>new
+    if newint != new:
+        raise ValueError('Cannot safely cast `new` to int.')
+    cdef Py_ssize_t i0, i1
+    cdef np.npy_intp *dim
+    dim = PyArray_DIMS(a)
+    cdef Py_ssize_t n0 = dim[0]
+    cdef Py_ssize_t n1 = dim[1]
+    if old==old: 
+        oldint = <np.int32_t>old
+        newint = <np.int32_t>new
+        if oldint != old:
+            raise ValueError('Cannot safely cast `old` to int.')
+        if newint != new:
+            raise ValueError('Cannot safely cast `new` to int.')
+        for i0 in range(n0):
+            for i1 in range(n1):
+                ai = a[i0, i1]
+                if ai == old:
+                    a[i0, i1] = newint
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def replace_2d_int64_axisNone(np.ndarray[np.int64_t, ndim=2] a,
+    double old, double new):
+    "replace (inplace) specified elements of 2d array of dtype=int64."
+    cdef np.int64_t ai
+
+    cdef np.int64_t oldint, newint
+    newint = <np.int64_t>new
+    if newint != new:
+        raise ValueError('Cannot safely cast `new` to int.')
+    cdef Py_ssize_t i0, i1
+    cdef np.npy_intp *dim
+    dim = PyArray_DIMS(a)
+    cdef Py_ssize_t n0 = dim[0]
+    cdef Py_ssize_t n1 = dim[1]
+    if old==old: 
+        oldint = <np.int64_t>old
+        newint = <np.int64_t>new
+        if oldint != old:
+            raise ValueError('Cannot safely cast `old` to int.')
+        if newint != new:
+            raise ValueError('Cannot safely cast `new` to int.')
+        for i0 in range(n0):
+            for i1 in range(n1):
+                ai = a[i0, i1]
+                if ai == old:
+                    a[i0, i1] = newint
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def replace_3d_int32_axisNone(np.ndarray[np.int32_t, ndim=3] a,
+    double old, double new):
+    "replace (inplace) specified elements of 3d array of dtype=int32."
+    cdef np.int32_t ai
+
+    cdef np.int32_t oldint, newint
+    newint = <np.int32_t>new
+    if newint != new:
+        raise ValueError('Cannot safely cast `new` to int.')
+    cdef Py_ssize_t i0, i1, i2
+    cdef np.npy_intp *dim
+    dim = PyArray_DIMS(a)
+    cdef Py_ssize_t n0 = dim[0]
+    cdef Py_ssize_t n1 = dim[1]
+    cdef Py_ssize_t n2 = dim[2]
+    if old==old: 
+        oldint = <np.int32_t>old
+        newint = <np.int32_t>new
+        if oldint != old:
+            raise ValueError('Cannot safely cast `old` to int.')
+        if newint != new:
+            raise ValueError('Cannot safely cast `new` to int.')
+        for i0 in range(n0):
+            for i1 in range(n1):
+                for i2 in range(n2):
+                    ai = a[i0, i1, i2]
+                    if ai == old:
+                        a[i0, i1, i2] = newint
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def replace_3d_int64_axisNone(np.ndarray[np.int64_t, ndim=3] a,
+    double old, double new):
+    "replace (inplace) specified elements of 3d array of dtype=int64."
+    cdef np.int64_t ai
+
+    cdef np.int64_t oldint, newint
+    newint = <np.int64_t>new
+    if newint != new:
+        raise ValueError('Cannot safely cast `new` to int.')
+    cdef Py_ssize_t i0, i1, i2
+    cdef np.npy_intp *dim
+    dim = PyArray_DIMS(a)
+    cdef Py_ssize_t n0 = dim[0]
+    cdef Py_ssize_t n1 = dim[1]
+    cdef Py_ssize_t n2 = dim[2]
+    if old==old: 
+        oldint = <np.int64_t>old
+        newint = <np.int64_t>new
+        if oldint != old:
+            raise ValueError('Cannot safely cast `old` to int.')
+        if newint != new:
+            raise ValueError('Cannot safely cast `new` to int.')
+        for i0 in range(n0):
+            for i1 in range(n1):
+                for i2 in range(n2):
+                    ai = a[i0, i1, i2]
+                    if ai == old:
+                        a[i0, i1, i2] = newint
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def replace_1d_float32_axisNone(np.ndarray[np.float32_t, ndim=1] a,
+    double old, double new):
+    "replace (inplace) specified elements of 1d array of dtype=float32."
+    cdef np.float32_t ai
+    cdef Py_ssize_t i0
+    cdef np.npy_intp *dim
+    dim = PyArray_DIMS(a)
+    cdef Py_ssize_t n0 = dim[0]
+    if old==old: 
+        for i0 in range(n0):
+            ai = a[i0]
+            if ai == old:
+                a[i0] = new
+    else:
+        for i0 in range(n0):
+            ai = a[i0]
+            if ai != ai:
+                a[i0] = new
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def replace_1d_float64_axisNone(np.ndarray[np.float64_t, ndim=1] a,
+    double old, double new):
+    "replace (inplace) specified elements of 1d array of dtype=float64."
+    cdef np.float64_t ai
+    cdef Py_ssize_t i0
+    cdef np.npy_intp *dim
+    dim = PyArray_DIMS(a)
+    cdef Py_ssize_t n0 = dim[0]
+    if old==old: 
+        for i0 in range(n0):
+            ai = a[i0]
+            if ai == old:
+                a[i0] = new
+    else:
+        for i0 in range(n0):
+            ai = a[i0]
+            if ai != ai:
+                a[i0] = new
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def replace_2d_float32_axisNone(np.ndarray[np.float32_t, ndim=2] a,
+    double old, double new):
+    "replace (inplace) specified elements of 2d array of dtype=float32."
+    cdef np.float32_t ai
+    cdef Py_ssize_t i0, i1
+    cdef np.npy_intp *dim
+    dim = PyArray_DIMS(a)
+    cdef Py_ssize_t n0 = dim[0]
+    cdef Py_ssize_t n1 = dim[1]
+    if old==old: 
+        for i0 in range(n0):
+            for i1 in range(n1):
+                ai = a[i0, i1]
+                if ai == old:
+                    a[i0, i1] = new
+    else:
+        for i0 in range(n0):
+            for i1 in range(n1):
+                ai = a[i0, i1]
+                if ai != ai:
+                    a[i0, i1] = new
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def replace_2d_float64_axisNone(np.ndarray[np.float64_t, ndim=2] a,
+    double old, double new):
+    "replace (inplace) specified elements of 2d array of dtype=float64."
+    cdef np.float64_t ai
+    cdef Py_ssize_t i0, i1
+    cdef np.npy_intp *dim
+    dim = PyArray_DIMS(a)
+    cdef Py_ssize_t n0 = dim[0]
+    cdef Py_ssize_t n1 = dim[1]
+    if old==old: 
+        for i0 in range(n0):
+            for i1 in range(n1):
+                ai = a[i0, i1]
+                if ai == old:
+                    a[i0, i1] = new
+    else:
+        for i0 in range(n0):
+            for i1 in range(n1):
+                ai = a[i0, i1]
+                if ai != ai:
+                    a[i0, i1] = new
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def replace_3d_float32_axisNone(np.ndarray[np.float32_t, ndim=3] a,
+    double old, double new):
+    "replace (inplace) specified elements of 3d array of dtype=float32."
+    cdef np.float32_t ai
+    cdef Py_ssize_t i0, i1, i2
+    cdef np.npy_intp *dim
+    dim = PyArray_DIMS(a)
+    cdef Py_ssize_t n0 = dim[0]
+    cdef Py_ssize_t n1 = dim[1]
+    cdef Py_ssize_t n2 = dim[2]
+    if old==old: 
+        for i0 in range(n0):
+            for i1 in range(n1):
+                for i2 in range(n2):
+                    ai = a[i0, i1, i2]
+                    if ai == old:
+                        a[i0, i1, i2] = new
+    else:
+        for i0 in range(n0):
+            for i1 in range(n1):
+                for i2 in range(n2):
+                    ai = a[i0, i1, i2]
+                    if ai != ai:
+                        a[i0, i1, i2] = new
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def replace_3d_float64_axisNone(np.ndarray[np.float64_t, ndim=3] a,
+    double old, double new):
+    "replace (inplace) specified elements of 3d array of dtype=float64."
+    cdef np.float64_t ai
+    cdef Py_ssize_t i0, i1, i2
+    cdef np.npy_intp *dim
+    dim = PyArray_DIMS(a)
+    cdef Py_ssize_t n0 = dim[0]
+    cdef Py_ssize_t n1 = dim[1]
+    cdef Py_ssize_t n2 = dim[2]
+    if old==old: 
+        for i0 in range(n0):
+            for i1 in range(n1):
+                for i2 in range(n2):
+                    ai = a[i0, i1, i2]
+                    if ai == old:
+                        a[i0, i1, i2] = new
+    else:
+        for i0 in range(n0):
+            for i1 in range(n1):
+                for i2 in range(n2):
+                    ai = a[i0, i1, i2]
+                    if ai != ai:
+                        a[i0, i1, i2] = new
+
+cdef dict replace_dict = {}
+replace_dict[(1, NPY_int32, 0)] = replace_1d_int32_axisNone
+replace_dict[(1, NPY_int32, None)] = replace_1d_int32_axisNone
+replace_dict[(1, NPY_int64, 0)] = replace_1d_int64_axisNone
+replace_dict[(1, NPY_int64, None)] = replace_1d_int64_axisNone
+replace_dict[(2, NPY_int32, None)] = replace_2d_int32_axisNone
+replace_dict[(2, NPY_int64, None)] = replace_2d_int64_axisNone
+replace_dict[(3, NPY_int32, None)] = replace_3d_int32_axisNone
+replace_dict[(3, NPY_int64, None)] = replace_3d_int64_axisNone
+replace_dict[(1, NPY_float32, 0)] = replace_1d_float32_axisNone
+replace_dict[(1, NPY_float32, None)] = replace_1d_float32_axisNone
+replace_dict[(1, NPY_float64, 0)] = replace_1d_float64_axisNone
+replace_dict[(1, NPY_float64, None)] = replace_1d_float64_axisNone
+replace_dict[(2, NPY_float32, None)] = replace_2d_float32_axisNone
+replace_dict[(2, NPY_float64, None)] = replace_2d_float64_axisNone
+replace_dict[(3, NPY_float32, None)] = replace_3d_float32_axisNone
+replace_dict[(3, NPY_float64, None)] = replace_3d_float64_axisNone
+
+def replace_slow_axis0(arr, old, new):
+    "Unaccelerated (slow) replace along axis 0."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis1(arr, old, new):
+    "Unaccelerated (slow) replace along axis 1."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis2(arr, old, new):
+    "Unaccelerated (slow) replace along axis 2."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis3(arr, old, new):
+    "Unaccelerated (slow) replace along axis 3."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis4(arr, old, new):
+    "Unaccelerated (slow) replace along axis 4."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis5(arr, old, new):
+    "Unaccelerated (slow) replace along axis 5."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis6(arr, old, new):
+    "Unaccelerated (slow) replace along axis 6."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis7(arr, old, new):
+    "Unaccelerated (slow) replace along axis 7."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis8(arr, old, new):
+    "Unaccelerated (slow) replace along axis 8."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis9(arr, old, new):
+    "Unaccelerated (slow) replace along axis 9."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis10(arr, old, new):
+    "Unaccelerated (slow) replace along axis 10."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis11(arr, old, new):
+    "Unaccelerated (slow) replace along axis 11."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis12(arr, old, new):
+    "Unaccelerated (slow) replace along axis 12."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis13(arr, old, new):
+    "Unaccelerated (slow) replace along axis 13."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis14(arr, old, new):
+    "Unaccelerated (slow) replace along axis 14."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis15(arr, old, new):
+    "Unaccelerated (slow) replace along axis 15."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis16(arr, old, new):
+    "Unaccelerated (slow) replace along axis 16."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis17(arr, old, new):
+    "Unaccelerated (slow) replace along axis 17."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis18(arr, old, new):
+    "Unaccelerated (slow) replace along axis 18."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis19(arr, old, new):
+    "Unaccelerated (slow) replace along axis 19."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis20(arr, old, new):
+    "Unaccelerated (slow) replace along axis 20."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis21(arr, old, new):
+    "Unaccelerated (slow) replace along axis 21."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis22(arr, old, new):
+    "Unaccelerated (slow) replace along axis 22."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis23(arr, old, new):
+    "Unaccelerated (slow) replace along axis 23."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis24(arr, old, new):
+    "Unaccelerated (slow) replace along axis 24."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis25(arr, old, new):
+    "Unaccelerated (slow) replace along axis 25."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis26(arr, old, new):
+    "Unaccelerated (slow) replace along axis 26."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis27(arr, old, new):
+    "Unaccelerated (slow) replace along axis 27."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis28(arr, old, new):
+    "Unaccelerated (slow) replace along axis 28."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis29(arr, old, new):
+    "Unaccelerated (slow) replace along axis 29."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis30(arr, old, new):
+    "Unaccelerated (slow) replace along axis 30."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis31(arr, old, new):
+    "Unaccelerated (slow) replace along axis 31."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axis32(arr, old, new):
+    "Unaccelerated (slow) replace along axis 32."
+    return slow_replace(arr, old, new)
+
+def replace_slow_axisNone(arr, old, new):
+    "Unaccelerated (slow) replace along axis None."
+    return slow_replace(arr, old, new)
+
+
+cdef dict replace_slow_dict = {}
+replace_slow_dict[0] = replace_slow_axis0
+replace_slow_dict[1] = replace_slow_axis1
+replace_slow_dict[2] = replace_slow_axis2
+replace_slow_dict[3] = replace_slow_axis3
+replace_slow_dict[4] = replace_slow_axis4
+replace_slow_dict[5] = replace_slow_axis5
+replace_slow_dict[6] = replace_slow_axis6
+replace_slow_dict[7] = replace_slow_axis7
+replace_slow_dict[8] = replace_slow_axis8
+replace_slow_dict[9] = replace_slow_axis9
+replace_slow_dict[10] = replace_slow_axis10
+replace_slow_dict[11] = replace_slow_axis11
+replace_slow_dict[12] = replace_slow_axis12
+replace_slow_dict[13] = replace_slow_axis13
+replace_slow_dict[14] = replace_slow_axis14
+replace_slow_dict[15] = replace_slow_axis15
+replace_slow_dict[16] = replace_slow_axis16
+replace_slow_dict[17] = replace_slow_axis17
+replace_slow_dict[18] = replace_slow_axis18
+replace_slow_dict[19] = replace_slow_axis19
+replace_slow_dict[20] = replace_slow_axis20
+replace_slow_dict[21] = replace_slow_axis21
+replace_slow_dict[22] = replace_slow_axis22
+replace_slow_dict[23] = replace_slow_axis23
+replace_slow_dict[24] = replace_slow_axis24
+replace_slow_dict[25] = replace_slow_axis25
+replace_slow_dict[26] = replace_slow_axis26
+replace_slow_dict[27] = replace_slow_axis27
+replace_slow_dict[28] = replace_slow_axis28
+replace_slow_dict[29] = replace_slow_axis29
+replace_slow_dict[30] = replace_slow_axis30
+replace_slow_dict[31] = replace_slow_axis31
+replace_slow_dict[32] = replace_slow_axis32
+replace_slow_dict[None] = replace_slow_axisNone
\ No newline at end of file
diff --git a/pandas/src/tseries.pyx b/pandas/src/tseries.pyx
index 55c0b3c5a..50eb07d62 100644
--- a/pandas/src/tseries.pyx
+++ b/pandas/src/tseries.pyx
@@ -2,6 +2,10 @@ cimport numpy as np
 cimport cython
 
 from numpy cimport *
+from numpy cimport NPY_INT32 as NPY_int32
+from numpy cimport NPY_INT64 as NPY_int64
+from numpy cimport NPY_FLOAT32 as NPY_float32
+from numpy cimport NPY_FLOAT64 as NPY_float64
 
 from cpython cimport (PyDict_New, PyDict_GetItem, PyDict_SetItem,
                       PyDict_Contains, PyDict_Keys,
@@ -665,6 +669,36 @@ def value_count_int64(ndarray[int64_t] values):
 
     return result_keys, result_counts
 
+def array_isnull(arr):
+    if np.isscalar(arr) or arr is None:
+        return checknull(arr)
+    if arr.dtype.kind in ('O', 'S'):
+        # Working around NumPy ticket 1542
+        shape = arr.shape
+        result = np.empty(shape, dtype=bool)
+        vec = isnullobj(arr.ravel())
+        result[:] = vec.reshape(shape)
+    elif arr.dtype == np.datetime64:
+        # this is the NaT pattern
+        result = np.array(arr).view('i8') == NaT
+    else:
+        result = -np.isfinite(arr)
+    return result
+
+def slow_replace(arr, old, new):
+    "Slow replace (inplace) used for unaccelerated ndim/dtype combinations."
+    if type(arr) is not np.ndarray:
+        raise TypeError("`arr` must be a numpy array.")
+    if not issubclass(arr.dtype.type, np.inexact):
+        if int(old) != old:
+            raise ValueError("Cannot safely cast `old` to int.")
+        if int(new) != new:
+            raise ValueError("Cannot safely cast `new` to int.")
+    if array_isnull(old):
+        mask = array_isnull(arr)
+    else:
+        mask = arr == old
+    np.putmask(arr, mask, new)
 
 include "hashtable.pyx"
 include "datetime.pyx"
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 27b1f8870..5b24f157d 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -3372,6 +3372,24 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         expected = df.astype(float).fillna(axis=1)
         assert_frame_equal(result, expected)
 
+    def test_replace(self):
+        pass
+
+    def test_replace_inplace(self):
+        pass
+
+    def test_replace_method(self):
+        pass
+
+    def test_replace_col_dict(self):
+        pass
+
+    def test_replace_axis(self):
+        pass
+
+    def test_replace_limit(self):
+        pass
+
     def test_truncate(self):
         offset = datetools.bday
 

commit c4c358ea422dcb64250112a669a23e94eab2ca6c
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Jan 3 18:20:03 2012 -0500

    BUG: handle list + Series combo in DataFrame constructor, still raise exception when mixing list with dict, GH #564

diff --git a/bench/bench_merge.R b/bench/bench_merge.R
index 38e0133d1..4a7266edf 100644
--- a/bench/bench_merge.R
+++ b/bench/bench_merge.R
@@ -1,3 +1,4 @@
+library(plyr)
 N <- 10000
 indices = rep(NA, N)
 indices2 = rep(NA, N)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index cbb33cf3e..727558902 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -40,6 +40,7 @@ import pandas.core.generic as generic
 import pandas.core.datetools as datetools
 import pandas._tseries as lib
 
+
 #----------------------------------------------------------------------
 # Docstring templates
 
@@ -3617,31 +3618,44 @@ def factor_agg(factor, vec, func):
 
 
 def extract_index(data):
-    def _get_index(v):
-        if isinstance(v, Series):
-            return v.index
-        elif isinstance(v, dict):
-            return v.keys()
-
     index = None
     if len(data) == 0:
         index = NULL_INDEX
     elif len(data) > 0 and index is None:
-        have_raw_arrays = _check_data_types(data)
-
+        raw_lengths = []
         indexes = []
 
-        # this is still kludgier than I'd like
+        have_raw_arrays = False
+        have_series = False
+        have_dicts = False
+
+        for v in data.values():
+            if isinstance(v, Series):
+                have_series = True
+                indexes.append(v.index)
+            elif isinstance(v, dict):
+                have_dicts = True
+                indexes.append(v.keys())
+            else:
+                have_raw_arrays = True
+                raw_lengths.append(len(v))
+
+        if have_series or have_dicts:
+            index = _union_indexes(indexes)
+
         if have_raw_arrays:
             lengths = list(set(len(x) for x in data.values()))
             if len(lengths) > 1:
                 raise ValueError('arrays must all be same length')
-            indexes.append(Index(np.arange(lengths[0])))
-        else:
-            for v in data.values():
-                indexes.append(_get_index(v))
 
-        index = _union_indexes(indexes)
+            if have_dicts:
+                raise ValueError('Mixing dicts with non-Series may lead to '
+                                 'ambiguous ordering.')
+
+            if have_series:
+                assert(lengths[0] == len(index))
+            else:
+                index = Index(np.arange(lengths[0]))
 
     if len(index) == 0:
         index = NULL_INDEX
@@ -3704,11 +3718,8 @@ def _check_data_types(data):
         else:
             have_series = True
 
-    if have_series and have_raw_arrays:
-        raise Exception('Cannot mix Series / dict objects'
-                        ' with ndarray / sequence input')
-
-    return have_raw_arrays
+    is_mixed = have_series and have_raw_arrays
+    return have_raw_arrays, is_mixed
 
 
 def _prep_ndarray(values, copy=True):
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 442ffcb6a..4c48527bc 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -446,7 +446,7 @@ class BlockManager(object):
         copy_blocks = [block.copy(deep=deep) for block in self.blocks]
         # copy_axes = [ax.copy() for ax in self.axes]
         copy_axes = list(self.axes)
-        return BlockManager(copy_blocks, copy_axes)
+        return BlockManager(copy_blocks, copy_axes, do_integrity_check=False)
 
     def as_matrix(self, items=None):
         if len(self.blocks) == 0:
diff --git a/pandas/src/hashtable.pyx b/pandas/src/hashtable.pyx
index 3601169c6..d86e1dbab 100644
--- a/pandas/src/hashtable.pyx
+++ b/pandas/src/hashtable.pyx
@@ -204,6 +204,24 @@ cdef class StringHashTable:
         else:
             raise KeyError(key)
 
+    def get_indexer(self, ndarray[object] values):
+        cdef:
+            Py_ssize_t i, n = len(values)
+            ndarray[int32_t] labels = np.empty(n, dtype=np.int32)
+            char *buf
+            int32_t *resbuf = <int32_t*> labels.data
+            khiter_t k
+            kh_str_t *table = self.table
+
+        for i in range(n):
+            buf = PyString_AsString(values[i])
+            k = kh_get_str(table, buf)
+            if k != table.n_buckets:
+                resbuf[i] = table.vals[k]
+            else:
+                resbuf[i] = -1
+        return labels
+
     def factorize(self, ndarray[object] values):
         cdef:
             Py_ssize_t i, n = len(values)
diff --git a/pandas/src/sandbox.pyx b/pandas/src/sandbox.pyx
index 12ad94a0c..b72a53425 100644
--- a/pandas/src/sandbox.pyx
+++ b/pandas/src/sandbox.pyx
@@ -118,3 +118,29 @@ def _check_minp(minp, N):
     elif minp < 0:
         raise ValueError('min_periods must be >= 0')
     return minp
+
+cdef extern from "Python.h":
+    bint PyDict_Contains(object, PyObject*)
+    PyObject* PyDict_GetItem(object, PyObject*)
+    long PyInt_AS_LONG(PyObject*)
+
+def get_indexer(ndarray values, dict mapping):
+    cdef:
+        Py_ssize_t i, length
+        ndarray fill_vec
+        PyObject **buf
+        int32_t *resbuf
+        PyObject* val
+
+    length = len(values)
+    buf = <PyObject**> values.data
+    fill_vec = np.empty(length, dtype='i4')
+    resbuf = <int32_t*> fill_vec.data
+
+    for i in range(length):
+        val = buf[i]
+        if PyDict_Contains(mapping, val):
+            resbuf[i] = PyInt_AS_LONG(PyDict_GetItem(mapping, val))
+        else:
+            resbuf[i] = -1
+    return fill_vec
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index e7956af08..ea8004c79 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -1008,18 +1008,11 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         self.assertEqual(len(DataFrame({})), 0)
         self.assertRaises(Exception, lambda x: DataFrame([self.ts1, self.ts2]))
 
-        # pass dict and array, nicht nicht
+        # mix dict and array, wrong size
         self.assertRaises(Exception, DataFrame,
                           {'A' : {'a' : 'a', 'b' : 'b'},
-                           'B' : ['a', 'b']})
+                           'B' : ['a', 'b', 'c']})
 
-        # can I rely on the order?
-        self.assertRaises(Exception, DataFrame,
-                          {'A' : ['a', 'b'],
-                           'B' : {'a' : 'a', 'b' : 'b'}})
-        self.assertRaises(Exception, DataFrame,
-                          {'A' : ['a', 'b'],
-                           'B' : Series(['a', 'b'], index=['a', 'b'])})
 
         # Length-one dict micro-optimization
         frame = DataFrame({'A' : {'1' : 1, '2' : 2}})
@@ -1307,6 +1300,17 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         result = DataFrame(data)
         self.assert_(result.index.is_monotonic)
 
+        # ordering ambiguous, raise exception
+        self.assertRaises(Exception, DataFrame,
+                          {'A' : ['a', 'b'], 'B' : {'a' : 'a', 'b' : 'b'}})
+
+        # this is OK though
+        result = DataFrame({'A' : ['a', 'b'],
+                            'B' : Series(['a', 'b'], index=['a', 'b'])})
+        expected = DataFrame({'A' : ['a', 'b'], 'B' : ['a', 'b']},
+                             index=['a', 'b'])
+        assert_frame_equal(result, expected)
+
     def test_constructor_tuples(self):
         result = DataFrame({'A': [(1, 2), (3, 4)]})
         expected = DataFrame({'A': Series([(1, 2), (3, 4)])})
@@ -1387,6 +1391,15 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         assert_frame_equal(recons, self.mixed_frame)
         self.assert_(isinstance(recons['foo'][0], tuple))
 
+    def test_constructor_mix_series_nonseries(self):
+        df = DataFrame({'A' : self.frame['A'],
+                        'B' : list(self.frame['B'])}, columns=['A', 'B'])
+        assert_frame_equal(df, self.frame.ix[:, ['A', 'B']])
+
+        self.assertRaises(Exception, DataFrame,
+                          {'A' : self.frame['A'],
+                           'B' : list(self.frame['B'])[:-2]})
+
     def test_astype(self):
         casted = self.frame.astype(int)
         expected = DataFrame(self.frame.values.astype(int),

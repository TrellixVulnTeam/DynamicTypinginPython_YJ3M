commit 12b97975961d4eb730a31d86f3e264c69d75f959
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Apr 26 15:34:49 2012 -0400

    BUG: implement take on PeriodIndex, close #1117

diff --git a/RELEASE.rst b/RELEASE.rst
index 6a34fc4f5..f8d2eef66 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -48,6 +48,7 @@ pandas 0.8.0
 
   - Fix OverflowError from storing pre-1970 dates in HDFStore by switching to
     datetime64 (GH #179)
+  - Fix logical error with February leap year end in YearEnd offset
 
 pandas 0.7.3
 ============
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index 7bb21a1b7..91aef9345 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -406,9 +406,6 @@ def _period_unbox_array(arr, check=None):
     unboxer = np.frompyfunc(lambda x: _period_unbox(x, check=check), 1, 1)
     return unboxer(arr)
 
-def _period_box(val, freq):
-    return Period(val, freq=freq)
-
 def _period_box_array(arr, freq):
     if arr is None:
         return arr
@@ -416,7 +413,7 @@ def _period_box_array(arr, freq):
     if not isinstance(arr, np.ndarray):
         return arr
 
-    boxfunc = lambda x: _period_box(x, freq)
+    boxfunc = lambda x: Period(x, freq)
     boxer = np.frompyfunc(boxfunc, 1, 1)
     return boxer(arr)
 
@@ -479,46 +476,8 @@ class PeriodIndex(Int64Index):
             freq = datetools.get_standard_freq(freq)
 
         if data is None:
-            if start is None and end is None:
-                raise ValueError('Must specify start, end, or data')
-
-            start = to_period(start, freq)
-            end = to_period(end, freq)
-
-            is_start_intv = isinstance(start, Period)
-            is_end_intv = isinstance(end, Period)
-            if (start is not None and not is_start_intv):
-                raise ValueError('Failed to convert %s to period' % start)
-
-            if (end is not None and not is_end_intv):
-                raise ValueError('Failed to convert %s to period' % end)
-
-            if is_start_intv and is_end_intv and (start.freq != end.freq):
-                raise ValueError('Start and end must have same freq')
-
-            if freq is None:
-                if is_start_intv:
-                    freq = start.freq
-                elif is_end_intv:
-                    freq = end.freq
-                else:
-                    raise ValueError('Could not infer freq from start/end')
-
-            if periods is not None:
-                if start is None:
-                    data = np.arange(end.ordinal - periods + 1,
-                                     end.ordinal + 1,
-                                     dtype=np.int64)
-                else:
-                    data = np.arange(start.ordinal, start.ordinal + periods,
-                                     dtype=np.int64)
-            else:
-                if start is None or end is None:
-                    msg = 'Must specify both start and end if periods is None'
-                    raise ValueError(msg)
-                data = np.arange(start.ordinal, end.ordinal+1, dtype=np.int64)
-
-            subarr = data.view(cls)
+            subarr, freq = _get_ordinal_range(start, end, periods, freq)
+            subarr = subarr.view(cls)
             subarr.name = name
             subarr.freq = freq
 
@@ -578,6 +537,10 @@ class PeriodIndex(Int64Index):
 
         return subarr
 
+    def __iter__(self):
+        for val in self.values:
+            yield Period(val, freq=self.freq)
+
     @property
     def is_all_dates(self):
         return True
@@ -746,7 +709,7 @@ class PeriodIndex(Int64Index):
         arr_idx = self.view(np.ndarray)
         if np.isscalar(key):
             val = arr_idx[key]
-            return _period_box(val, freq=self.freq)
+            return Period(val, freq=self.freq)
         else:
             if com._is_bool_indexer(key):
                 key = np.asarray(key)
@@ -766,7 +729,7 @@ class PeriodIndex(Int64Index):
         if name:
             header.append(str(self.name) if self.name is not None else '')
 
-        return header + ['%s' % _period_box(x, freq=self.freq) for x in self]
+        return header + ['%s' % Period(x, freq=self.freq) for x in self]
 
     def _view_like(self, ndarray):
         result = ndarray.view(type(self))
@@ -788,6 +751,58 @@ class PeriodIndex(Int64Index):
         output += 'length: %d' % len(self)
         return output
 
+    def take(self, indices, axis=None):
+        """
+        Analogous to ndarray.take
+        """
+        taken = self.values.take(indices, axis=axis)
+        taken = taken.view(PeriodIndex)
+        taken.freq = self.freq
+        taken.name = self.name
+        return taken
+
+def _get_ordinal_range(start, end, periods, freq):
+    if com._count_not_none(start, end, periods) < 2:
+        raise ValueError('Must specify 2 of start, end, periods')
+
+    start = to_period(start, freq)
+    end = to_period(end, freq)
+
+    is_start_per = isinstance(start, Period)
+    is_end_per = isinstance(end, Period)
+    if (start is not None and not is_start_per):
+        raise ValueError('Failed to convert %s to period' % start)
+
+    if (end is not None and not is_end_per):
+        raise ValueError('Failed to convert %s to period' % end)
+
+    if is_start_per and is_end_per and (start.freq != end.freq):
+        raise ValueError('Start and end must have same freq')
+
+    if freq is None:
+        if is_start_per:
+            freq = start.freq
+        elif is_end_per:
+            freq = end.freq
+        else:
+            raise ValueError('Could not infer freq from start/end')
+
+    if periods is not None:
+        if start is None:
+            data = np.arange(end.ordinal - periods + 1,
+                             end.ordinal + 1,
+                             dtype=np.int64)
+        else:
+            data = np.arange(start.ordinal, start.ordinal + periods,
+                             dtype=np.int64)
+    else:
+        if start is None or end is None:
+            msg = 'Must specify both start and end if periods is None'
+            raise ValueError(msg)
+        data = np.arange(start.ordinal, end.ordinal+1, dtype=np.int64)
+
+    return data, freq
+
 
 def _validate_end_alias(how):
     how_dict = {'S': 'S', 'E': 'E',
diff --git a/pandas/tests/test_datetools.py b/pandas/tseries/tests/test_offsets.py
similarity index 100%
rename from pandas/tests/test_datetools.py
rename to pandas/tseries/tests/test_offsets.py
diff --git a/pandas/tseries/tests/test_period.py b/pandas/tseries/tests/test_period.py
index 49f7e1734..c8c1fd1a3 100644
--- a/pandas/tseries/tests/test_period.py
+++ b/pandas/tseries/tests/test_period.py
@@ -1100,6 +1100,24 @@ class TestPeriodIndex(TestCase):
         self.assertEquals(i.asfreq('1S', how='E'),
                           Period('1/1/2010 12:05:19', '1S'))
 
+    def test_iteration(self):
+        index = PeriodIndex(start='1/1/10', periods=4, freq='B')
+
+        result = list(index)
+        self.assert_(isinstance(result[0], Period))
+        self.assert_(result[0].freq == index.freq)
+
+    def test_take(self):
+        index = PeriodIndex(start='1/1/10', end='12/31/12', freq='D')
+
+        taken = index.take([5, 6, 8, 12])
+        taken2 = index[[5, 6, 8, 12]]
+        self.assert_(isinstance(taken, PeriodIndex))
+        self.assert_(taken.freq == index.freq)
+        self.assert_(isinstance(taken2, PeriodIndex))
+        self.assert_(taken2.freq == index.freq)
+
+
 class TestMethods(TestCase):
     "Base test class for MaskedArrays."
 
@@ -1114,6 +1132,7 @@ class TestMethods(TestCase):
         self.assertRaises(ValueError, dt1.__add__, "str")
         self.assertRaises(ValueError, dt1.__add__, dt2)
 
+
 ###############################################################################
 #------------------------------------------------------------------------------
 

commit 3e9c3200fd173f29c090dfa52c87ceeeac4a01d3
Author: Jeff Reback <jeff@reback.net>
Date:   Sat Apr 30 14:08:54 2016 -0700

    COMPAT: ensure platform it on 32-bit
    
    TST: use 32bit_repr when printing formatting of sparse
    
    COMPAT: ensure consensus name when Indexes are union/intersected if possible
    
    COMPAT: skip some coercion tests on 32-bit
    
    closes #12927
    closes #13047

diff --git a/doc/source/whatsnew/v0.18.1.txt b/doc/source/whatsnew/v0.18.1.txt
index f42041097..de05a829e 100644
--- a/doc/source/whatsnew/v0.18.1.txt
+++ b/doc/source/whatsnew/v0.18.1.txt
@@ -584,7 +584,7 @@ Bug Fixes
 - Bug in ``groupby`` where complex types are coerced to float (:issue:`12902`)
 - Bug in ``Series.map`` raises ``TypeError`` if its dtype is ``category`` or tz-aware ``datetime`` (:issue:`12473`)
 
-
+- Bugs on 32bit platforms for some test comparisons (:issue:`12972`)
 - Bug in index coercion when falling back from ``RangeIndex`` construction (:issue:`12893`)
 - Better error message in window functions when invalid argument (e.g. a float window) is passed (:issue:`12669`)
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index d8e99f2bd..f31903f92 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1487,6 +1487,8 @@ class Series(base.IndexOpsMixin, strings.StringAccessorMixin,
     @Substitution(klass='Series', value='v')
     @Appender(base._shared_docs['searchsorted'])
     def searchsorted(self, v, side='left', sorter=None):
+        if sorter is not None:
+            sorter = com._ensure_platform_int(sorter)
         return self._values.searchsorted(Series(v)._values,
                                          side=side, sorter=sorter)
 
diff --git a/pandas/indexes/api.py b/pandas/indexes/api.py
index 3f0ee40a6..0b81c4748 100644
--- a/pandas/indexes/api.py
+++ b/pandas/indexes/api.py
@@ -76,6 +76,9 @@ def _union_indexes(indexes):
             if not index.equals(other):
                 return _unique_indices(indexes)
 
+        name = _get_consensus_names(indexes)[0]
+        if name != index.name:
+            index = index._shallow_copy(name=name)
         return index
     else:
         return _unique_indices(indexes)
diff --git a/pandas/indexes/base.py b/pandas/indexes/base.py
index 19c74f7a0..01d825a4c 100644
--- a/pandas/indexes/base.py
+++ b/pandas/indexes/base.py
@@ -1663,6 +1663,21 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
     def __xor__(self, other):
         return self.symmetric_difference(other)
 
+    def _get_consensus_name(self, other):
+        """
+        Given 2 indexes, give a consensus name meaning
+        we take the not None one, or None if the names differ.
+        Return a new object if we are resetting the name
+        """
+        if self.name != other.name:
+            if self.name is None or other.name is None:
+                name = self.name or other.name
+            else:
+                name = None
+            if self.name != name:
+                return other._shallow_copy(name=name)
+        return self
+
     def union(self, other):
         """
         Form the union of two Index objects and sorts if possible.
@@ -1688,10 +1703,10 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
         other = _ensure_index(other)
 
         if len(other) == 0 or self.equals(other):
-            return self
+            return self._get_consensus_name(other)
 
         if len(self) == 0:
-            return other
+            return other._get_consensus_name(self)
 
         if not com.is_dtype_equal(self.dtype, other.dtype):
             this = self.astype('O')
@@ -1774,7 +1789,7 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
         other = _ensure_index(other)
 
         if self.equals(other):
-            return self
+            return self._get_consensus_name(other)
 
         if not com.is_dtype_equal(self.dtype, other.dtype):
             this = self.astype('O')
diff --git a/pandas/tests/formats/test_format.py b/pandas/tests/formats/test_format.py
index fafc4d04d..4fcee32c4 100644
--- a/pandas/tests/formats/test_format.py
+++ b/pandas/tests/formats/test_format.py
@@ -8,7 +8,8 @@ from distutils.version import LooseVersion
 import re
 
 from pandas.compat import (range, zip, lrange, StringIO, PY3,
-                           u, lzip, is_platform_windows)
+                           u, lzip, is_platform_windows,
+                           is_platform_32bit)
 import pandas.compat as compat
 import itertools
 from operator import methodcaller
@@ -45,6 +46,8 @@ from datetime import datetime
 
 import nose
 
+use_32bit_repr = is_platform_windows() or is_platform_32bit()
+
 _frame = DataFrame(tm.getSeriesData())
 
 
@@ -3758,7 +3761,7 @@ class TestSeriesFormatting(tm.TestCase):
     def test_sparse_max_row(self):
         s = pd.Series([1, np.nan, np.nan, 3, np.nan]).to_sparse()
         result = repr(s)
-        dtype = '' if is_platform_windows() else ', dtype=int32'
+        dtype = '' if use_32bit_repr else ', dtype=int32'
         exp = ("0    1.0\n1    NaN\n2    NaN\n3    3.0\n"
                "4    NaN\ndtype: float64\nBlockIndex\n"
                "Block locations: array([0, 3]{0})\n"
diff --git a/pandas/tests/indexes/test_base.py b/pandas/tests/indexes/test_base.py
index b522340be..da7084eff 100644
--- a/pandas/tests/indexes/test_base.py
+++ b/pandas/tests/indexes/test_base.py
@@ -554,6 +554,23 @@ class TestIndex(Base, tm.TestCase):
         result = idx1.intersection(idx2)
         self.assertTrue(result.equals(expected))
 
+        # preserve names
+        first = self.strIndex[5:20]
+        second = self.strIndex[:10]
+        first.name = 'A'
+        second.name = 'A'
+        intersect = first.intersection(second)
+        self.assertEqual(intersect.name, 'A')
+
+        second.name = 'B'
+        intersect = first.intersection(second)
+        self.assertIsNone(intersect.name)
+
+        first.name = None
+        second.name = 'B'
+        intersect = first.intersection(second)
+        self.assertIsNone(intersect.name)
+
     def test_union(self):
         first = self.strIndex[5:20]
         second = self.strIndex[:10]
@@ -578,15 +595,51 @@ class TestIndex(Base, tm.TestCase):
         self.assertIs(union, first)
 
         # preserve names
-        first.name = 'A'
-        second.name = 'A'
+        first = Index(list('ab'), name='A')
+        second = Index(list('ab'), name='B')
         union = first.union(second)
-        self.assertEqual(union.name, 'A')
+        self.assertIsNone(union.name)
 
-        second.name = 'B'
+        first = Index(list('ab'), name='A')
+        second = Index([], name='B')
         union = first.union(second)
         self.assertIsNone(union.name)
 
+        first = Index([], name='A')
+        second = Index(list('ab'), name='B')
+        union = first.union(second)
+        self.assertIsNone(union.name)
+
+        first = Index(list('ab'))
+        second = Index(list('ab'), name='B')
+        union = first.union(second)
+        self.assertEqual(union.name, 'B')
+
+        first = Index([])
+        second = Index(list('ab'), name='B')
+        union = first.union(second)
+        self.assertEqual(union.name, 'B')
+
+        first = Index(list('ab'))
+        second = Index([], name='B')
+        union = first.union(second)
+        self.assertEqual(union.name, 'B')
+
+        first = Index(list('ab'), name='A')
+        second = Index(list('ab'))
+        union = first.union(second)
+        self.assertEqual(union.name, 'A')
+
+        first = Index(list('ab'), name='A')
+        second = Index([])
+        union = first.union(second)
+        self.assertEqual(union.name, 'A')
+
+        first = Index([], name='A')
+        second = Index(list('ab'))
+        union = first.union(second)
+        self.assertEqual(union.name, 'A')
+
     def test_add(self):
 
         # - API change GH 8226
diff --git a/pandas/tests/indexing/test_coercion.py b/pandas/tests/indexing/test_coercion.py
index 3585feacd..23600e1f4 100644
--- a/pandas/tests/indexing/test_coercion.py
+++ b/pandas/tests/indexing/test_coercion.py
@@ -473,6 +473,11 @@ class TestSeriesCoercion(tm.TestCase):
             # TODO_GH12747 The result must be int?
            (from_key == 'bool' and to_key in ('int64'))):
 
+            # buggy on 32-bit
+            if tm.is_platform_32bit():
+                raise nose.SkipTest("32-bit platform buggy: {0} -> {1}".format
+                                    (from_key, to_key))
+
             # Expected: do not downcast by replacement
             exp = pd.Series(self.rep[to_key], index=index,
                             name='yyy', dtype=from_key)

commit 357774695a4caf7b83506686f4c29cc38d2b9726
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon Aug 26 16:39:12 2019 -0700

    CLN: small ops optimizations (#28036)

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 9da799972..f636bb6db 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -5298,12 +5298,19 @@ class DataFrame(NDFrame):
         this, other = self.align(other, join="outer", level=level, copy=False)
         new_index, new_columns = this.index, this.columns
 
-        def _arith_op(left, right):
-            # for the mixed_type case where we iterate over columns,
-            # _arith_op(left, right) is equivalent to
-            # left._binop(right, func, fill_value=fill_value)
-            left, right = ops.fill_binop(left, right, fill_value)
-            return func(left, right)
+        if fill_value is None:
+            # since _arith_op may be called in a loop, avoid function call
+            #  overhead if possible by doing this check once
+            _arith_op = func
+
+        else:
+
+            def _arith_op(left, right):
+                # for the mixed_type case where we iterate over columns,
+                # _arith_op(left, right) is equivalent to
+                # left._binop(right, func, fill_value=fill_value)
+                left, right = ops.fill_binop(left, right, fill_value)
+                return func(left, right)
 
         if ops.should_series_dispatch(this, other, func):
             # iterate over columns
@@ -5318,7 +5325,7 @@ class DataFrame(NDFrame):
 
     def _combine_match_index(self, other, func, level=None):
         left, right = self.align(other, join="outer", axis=0, level=level, copy=False)
-        assert left.index.equals(right.index)
+        # at this point we have `left.index.equals(right.index)`
 
         if left._is_mixed_type or right._is_mixed_type:
             # operate column-wise; avoid costly object-casting in `.values`
@@ -5331,14 +5338,13 @@ class DataFrame(NDFrame):
                 new_data, index=left.index, columns=self.columns, copy=False
             )
 
-    def _combine_match_columns(self, other, func, level=None):
-        assert isinstance(other, Series)
+    def _combine_match_columns(self, other: Series, func, level=None):
         left, right = self.align(other, join="outer", axis=1, level=level, copy=False)
-        assert left.columns.equals(right.index)
+        # at this point we have `left.columns.equals(right.index)`
         return ops.dispatch_to_series(left, right, func, axis="columns")
 
     def _combine_const(self, other, func):
-        assert lib.is_scalar(other) or np.ndim(other) == 0
+        # scalar other or np.ndim(other) == 0
         return ops.dispatch_to_series(self, other, func)
 
     def combine(self, other, func, fill_value=None, overwrite=True):
diff --git a/pandas/core/ops/__init__.py b/pandas/core/ops/__init__.py
index 7e03b9544..86cd6e878 100644
--- a/pandas/core/ops/__init__.py
+++ b/pandas/core/ops/__init__.py
@@ -169,7 +169,7 @@ def maybe_upcast_for_op(obj, shape: Tuple[int, ...]):
         #  np.timedelta64(3, 'D') / 2 == np.timedelta64(1, 'D')
         return Timedelta(obj)
 
-    elif isinstance(obj, np.ndarray) and is_timedelta64_dtype(obj):
+    elif isinstance(obj, np.ndarray) and is_timedelta64_dtype(obj.dtype):
         # GH#22390 Unfortunately we need to special-case right-hand
         # timedelta64 dtypes because numpy casts integer dtypes to
         # timedelta64 when operating with timedelta64
@@ -415,7 +415,7 @@ def should_extension_dispatch(left: ABCSeries, right: Any) -> bool:
     ):
         return True
 
-    if is_extension_array_dtype(right) and not is_scalar(right):
+    if not is_scalar(right) and is_extension_array_dtype(right):
         # GH#22378 disallow scalar to exclude e.g. "category", "Int64"
         return True
 
@@ -755,7 +755,7 @@ def _bool_method_SERIES(cls, op, special):
             assert not isinstance(y, (list, ABCSeries, ABCIndexClass))
             if isinstance(y, np.ndarray):
                 # bool-bool dtype operations should be OK, should not get here
-                assert not (is_bool_dtype(x) and is_bool_dtype(y))
+                assert not (is_bool_dtype(x.dtype) and is_bool_dtype(y.dtype))
                 x = ensure_object(x)
                 y = ensure_object(y)
                 result = libops.vec_binop(x, y, op)
@@ -804,7 +804,7 @@ def _bool_method_SERIES(cls, op, special):
 
         else:
             # scalars, list, tuple, np.array
-            is_other_int_dtype = is_integer_dtype(np.asarray(other))
+            is_other_int_dtype = is_integer_dtype(np.asarray(other).dtype)
             if is_list_like(other) and not isinstance(other, np.ndarray):
                 # TODO: Can we do this before the is_integer_dtype check?
                 # could the is_integer_dtype check be checking the wrong
@@ -988,10 +988,10 @@ def _arith_method_FRAME(cls, op, special):
                 self, other, pass_op, fill_value=fill_value, axis=axis, level=level
             )
         else:
+            # in this case we always have `np.ndim(other) == 0`
             if fill_value is not None:
                 self = self.fillna(fill_value)
 
-            assert np.ndim(other) == 0
             return self._combine_const(other, op)
 
     f.__name__ = op_name
@@ -1032,7 +1032,7 @@ def _flex_comp_method_FRAME(cls, op, special):
                 self, other, na_op, fill_value=None, axis=axis, level=level
             )
         else:
-            assert np.ndim(other) == 0, other
+            # in this case we always have `np.ndim(other) == 0`
             return self._combine_const(other, na_op)
 
     f.__name__ = op_name
diff --git a/pandas/core/ops/array_ops.py b/pandas/core/ops/array_ops.py
index 523ba5d42..f5f6d7767 100644
--- a/pandas/core/ops/array_ops.py
+++ b/pandas/core/ops/array_ops.py
@@ -11,7 +11,7 @@ from pandas.core.dtypes.cast import (
     find_common_type,
     maybe_upcast_putmask,
 )
-from pandas.core.dtypes.common import is_object_dtype, is_period_dtype, is_scalar
+from pandas.core.dtypes.common import is_object_dtype, is_scalar
 from pandas.core.dtypes.generic import ABCIndex, ABCSeries
 from pandas.core.dtypes.missing import notna
 
@@ -57,9 +57,9 @@ def masked_arith_op(x, y, op):
         dtype = find_common_type([x.dtype, y.dtype])
         result = np.empty(x.size, dtype=dtype)
 
-        # PeriodIndex.ravel() returns int64 dtype, so we have
-        # to work around that case.  See GH#19956
-        yrav = y if is_period_dtype(y) else y.ravel()
+        # NB: ravel() is only safe since y is ndarray; for e.g. PeriodIndex
+        #  we would get int64 dtype, see GH#19956
+        yrav = y.ravel()
         mask = notna(xrav) & notna(yrav)
 
         if yrav.shape != mask.shape:
@@ -82,9 +82,9 @@ def masked_arith_op(x, y, op):
         mask = notna(xrav)
 
         # 1 ** np.nan is 1. So we have to unmask those.
-        if op == pow:
+        if op is pow:
             mask = np.where(x == 1, False, mask)
-        elif op == rpow:
+        elif op is rpow:
             mask = np.where(y == 1, False, mask)
 
         if mask.any():
diff --git a/pandas/core/ops/missing.py b/pandas/core/ops/missing.py
index 01bc345a4..45fa6a283 100644
--- a/pandas/core/ops/missing.py
+++ b/pandas/core/ops/missing.py
@@ -40,7 +40,7 @@ def fill_zeros(result, x, y, name, fill):
 
     Mask the nan's from x.
     """
-    if fill is None or is_float_dtype(result):
+    if fill is None or is_float_dtype(result.dtype):
         return result
 
     if name.startswith(("r", "__r")):
@@ -55,7 +55,7 @@ def fill_zeros(result, x, y, name, fill):
     if is_scalar_type:
         y = np.array(y)
 
-    if is_integer_dtype(y):
+    if is_integer_dtype(y.dtype):
 
         if (y == 0).any():
 
diff --git a/pandas/core/sparse/frame.py b/pandas/core/sparse/frame.py
index f5add4262..8fe6850c8 100644
--- a/pandas/core/sparse/frame.py
+++ b/pandas/core/sparse/frame.py
@@ -569,13 +569,13 @@ class SparseDataFrame(DataFrame):
         ).__finalize__(self)
 
     def _combine_match_index(self, other, func, level=None):
-        new_data = {}
 
         if level is not None:
             raise NotImplementedError("'level' argument is not supported")
 
         this, other = self.align(other, join="outer", axis=0, level=level, copy=False)
 
+        new_data = {}
         for col, series in this.items():
             new_data[col] = func(series.values, other.values)
 

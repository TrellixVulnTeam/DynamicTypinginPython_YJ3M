commit a56b005681784db1a54d487252215d33754dcd7b
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Dec 31 20:04:43 2009 +0000

    increased test coverage of DataFrame / DataMatrix, miscellaneous fixes
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@100 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 66c2fc1ec..0edd24233 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -220,15 +220,17 @@ class BDay(DateOffset):
     def apply(self, other):
         if isinstance(other, datetime):
             n = self.n
+
             if n == 0 and other.weekday() > 4:
                 n = 1
 
             result = other
 
             while n != 0:
-                result = result + timedelta(n/abs(n))
+                k = n // abs(n)
+                result = result + timedelta(k)
                 if result.weekday() < 5:
-                    n -= n/abs(n)
+                    n -= k
 
             if self.normalize:
                 result = datetime(result.year, result.month, result.day)
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 5626f8405..0998ec0cb 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -5,6 +5,7 @@ from cStringIO import StringIO
 import sys
 
 from numpy.lib.format import read_array, write_array
+from numpy import NaN
 import numpy as np
 
 from pandas.core.frame import DataFrame, _pfixed
@@ -147,7 +148,7 @@ class DataMatrix(DataFrame):
                 K = len(columns)
 
             values = np.empty((N, K), dtype=dtype)
-            values[:] = np.NaN
+            values[:] = NaN
         else:
             raise Exception('DataMatrix constructor not properly called!')
 
@@ -755,9 +756,9 @@ class DataMatrix(DataFrame):
         if not self and not other:
             return DataMatrix(index=newIndex)
         elif not self:
-            return other * np.NaN
+            return other * NaN
         elif not other:
-            return self * np.NaN
+            return self * NaN
 
         myValues = myReindex.values
         if self.columns.equals(other.columns):
@@ -774,7 +775,7 @@ class DataMatrix(DataFrame):
         else:
             T, N = len(newIndex), len(newCols)
             resultMatrix = np.empty((T, N), dtype=self.values.dtype)
-            resultMatrix.fill(np.NaN)
+            resultMatrix.fill(NaN)
 
             myIndexer = [self.columns.indexMap[idx] for idx in commonCols]
             hisIndexer =  [hisCols.indexMap[idx] for idx in commonCols]
@@ -804,11 +805,15 @@ class DataMatrix(DataFrame):
             resultMatrix = func(myReindex.values.T, other).T
         else:
             if len(other) == 0:
-                return self * np.NaN
+                return self * NaN
+
+            newCols = self.columns.union(other.index)
 
             # Operate column-wise
-            other = other.reindex(self.columns).view(np.ndarray)
-            resultMatrix = func(self.values, other)
+            this = self.reindex(columns=newCols)
+            other = other.reindex(newCols).values()
+
+            resultMatrix = func(this.values, other)
 
         # TODO: deal with objects
         return DataMatrix(resultMatrix, index=newIndex, columns=newCols)
@@ -1190,7 +1195,7 @@ class DataMatrix(DataFrame):
         fillVec, mask = tseries.getMergeVec(self[on], indexMap)
 
         tmpMatrix = otherM.take(fillVec, axis=0)
-        tmpMatrix[-mask] = np.NaN
+        tmpMatrix[-mask] = NaN
 
         seriesDict = dict((col, tmpMatrix[:, j])
                            for j, col in enumerate(otherFrame.columns))
@@ -1201,7 +1206,7 @@ class DataMatrix(DataFrame):
             objM = objects.asMatrix()
 
             tmpMat = objM.take(fillVec, axis=0)
-            tmpMat[-mask] = np.NaN
+            tmpMat[-mask] = NaN
             objDict = dict((col, tmpMat[:, j])
                            for j, col in enumerate(objects.columns))
 
@@ -1229,7 +1234,7 @@ class DataMatrix(DataFrame):
                                            index.indexMap, method)
 
         tmpMatrix = self.values.take(fillVec, axis=0)
-        tmpMatrix[-mask] = np.NaN
+        tmpMatrix[-mask] = NaN
 
         if self.objects is not None and len(self.objects.columns) > 0:
             newObjects = self.objects.reindex(index)
@@ -1252,37 +1257,11 @@ class DataMatrix(DataFrame):
                                            columns.indexMap, '')
 
         newValues = self.values.take(indexer, axis=1)
-        newValues[:, -mask] = np.NaN
+        newValues[:, -mask] = NaN
 
         return DataMatrix(newValues, index=self.index, columns=columns,
                           objects=self.objects)
 
-
-    def _withColumns(self, columns):
-        """
-        Utility method, force values matrix to have particular columns
-        Can make this as cute as we like
-        """
-        if len(columns) == 0:
-            return DataMatrix(index=self.index)
-
-        T, N = len(self.index), len(columns)
-
-        resultMatrix = np.empty((T, N), dtype=self.values.dtype)
-        resultMatrix.fill(np.NaN)
-
-        if not isinstance(columns, Index):
-            columns = Index(columns)
-
-        overlap = self.columns.intersection(columns)
-        thisIndexer = [self.columns.indexMap[col] for col in overlap]
-        resultIndexer = [columns.indexMap[idx] for idx in overlap]
-
-        resultMatrix[:, resultIndexer] = self.values[:, thisIndexer]
-
-        return DataMatrix(resultMatrix, index=self.index, columns=columns,
-                          objects=self.objects)
-
     @property
     def T(self):
         """
@@ -1324,17 +1303,27 @@ class DataMatrix(DataFrame):
         if timeRule is not None and offset is None:
             offset = datetools.getOffset(timeRule)
 
+        N = len(self)
+
         if offset is None:
+            newIndex = self.index
+            indexer = np.zeros(N, dtype=int)
             if periods > 0:
-                newIndex = self.index[periods:]
-                newValues = self.values[:-periods].copy()
+                indexer[periods:] = np.arange(N - periods)
+                newValues = self.values.take(indexer, axis=0)
+                newValues[:periods] = NaN
             else:
-                newIndex = self.index[:periods]
-                newValues = self.values[-periods:].copy()
+                indexer[:periods] = np.arange(-periods, N)
+                newValues = self.values.take(indexer, axis=0)
+                newValues[periods:] = NaN
         else:
             offset = periods * offset
-            newIndex = Index([idx + offset for idx in self.index])
+            newIndex = Index([x + offset for x in self.index])
             newValues = self.values.copy()
+
+        if self.objects is not None:
+            pass
+
         return DataMatrix(data=newValues, index=newIndex, columns=self.columns)
 
     def apply(self, func, axis=0):
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index dce5bde48..c6c20e192 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -1044,7 +1044,7 @@ class LongPanel(Panel):
 
         I, N, K = self.dims
 
-        values = np.empty((I, N, K), dtype=float)
+        values = np.empty((I, N, K), dtype=self.values.dtype)
 
         mask = self.index.mask
         notmask = -mask
diff --git a/pandas/core/tests/common.py b/pandas/core/tests/common.py
index 1e60f6a67..c683bf81e 100644
--- a/pandas/core/tests/common.py
+++ b/pandas/core/tests/common.py
@@ -70,7 +70,7 @@ def assert_frame_equal(left, right):
 
     for col in right:
         assert(col in left)
-    
+
 def assert_contains_all(iterable, dic):
     for k in iterable:
         assert(k in dic)
@@ -137,8 +137,8 @@ def makeTimeDataFrame():
 
 def makeDataMatrix():
     data = getSeriesData()
-    return DataFrame(data)
+    return DataMatrix(data)
 
 def makeTimeDataMatrix():
     data = getTimeSeriesData()
-    return DataFrame(data)
+    return DataMatrix(data)
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index 1af992611..916ddc7e4 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -7,7 +7,7 @@ import unittest
 from numpy import random
 import numpy as np
 
-from pandas.core.api import DateRange, DataFrame, Index, Series
+from pandas.core.api import DataFrame, Index, Series
 from pandas.core.datetools import bday
 import pandas.core.datetools as datetools
 
@@ -309,7 +309,36 @@ class TestDataFrame(unittest.TestCase):
         self.assert_(not empty_empty)
 
     def test_combineSeries(self):
-        pass
+
+        # Series
+        series = self.frame.getXS(self.frame.index[0])
+
+        added = self.frame + series
+
+        for key, s in added.iteritems():
+            assert_series_equal(s, self.frame[key] + series[key])
+
+        larger_series = series.toDict()
+        larger_series['E'] = 1
+        larger_series = Series.fromDict(larger_series)
+        larger_added = self.frame + larger_series
+
+        for key, s in self.frame.iteritems():
+            assert_series_equal(larger_added[key], s + series[key])
+        self.assert_('E' in larger_added)
+        self.assert_(np.isnan(larger_added['E']).all())
+
+        # TimeSeries
+        ts = self.tsframe['A']
+        added = self.tsframe + ts
+
+        for key, col in self.tsframe.iteritems():
+            assert_series_equal(added[key], col + ts)
+
+        smaller_frame = self.tsframe[:-5]
+        smaller_added = smaller_frame + ts
+
+        self.assert_(smaller_added.index.equals(self.tsframe.index))
 
     def test_combineFunc(self):
         pass
@@ -447,13 +476,13 @@ class TestDataFrame(unittest.TestCase):
         frame = self.tsframe
 
         tsFrame = frame.getTS(fromDate=frame.index[5], nPeriods=5)
-        common.assert_frame_equal(tsFrame, frame[5:10])
+        assert_frame_equal(tsFrame, frame[5:10])
 
         tsFrame = frame.getTS(fromDate=frame.index[5], toDate=frame.index[9])
-        common.assert_frame_equal(tsFrame, frame[5:10])
+        assert_frame_equal(tsFrame, frame[5:10])
 
         tsFrame = frame.getTS(nPeriods=5, toDate=frame.index[9])
-        common.assert_frame_equal(tsFrame, frame[5:10])
+        assert_frame_equal(tsFrame, frame[5:10])
 
         A = frame.getTS(colName='A', nPeriods=5, toDate=frame.index[9])
         assert_series_equal(A, frame['A'][5:10])
@@ -472,34 +501,34 @@ class TestDataFrame(unittest.TestCase):
 
         # neither specified
         truncated = ts.truncate()
-        common.assert_frame_equal(truncated, ts)
+        assert_frame_equal(truncated, ts)
 
         # both specified
         expected = ts[1:3]
 
         truncated = ts.truncate(start, end)
-        common.assert_frame_equal(truncated, expected)
+        assert_frame_equal(truncated, expected)
 
         truncated = ts.truncate(start_missing, end_missing)
-        common.assert_frame_equal(truncated, expected)
+        assert_frame_equal(truncated, expected)
 
         # start specified
         expected = ts[1:]
 
         truncated = ts.truncate(before=start)
-        common.assert_frame_equal(truncated, expected)
+        assert_frame_equal(truncated, expected)
 
         truncated = ts.truncate(before=start_missing)
-        common.assert_frame_equal(truncated, expected)
+        assert_frame_equal(truncated, expected)
 
         # end specified
         expected = ts[:3]
 
         truncated = ts.truncate(after=end)
-        common.assert_frame_equal(truncated, expected)
+        assert_frame_equal(truncated, expected)
 
         truncated = ts.truncate(after=end_missing)
-        common.assert_frame_equal(truncated, expected)
+        assert_frame_equal(truncated, expected)
 
     def test_getXS(self):
         idx = self.frame.index[5]
@@ -585,27 +614,71 @@ class TestDataFrame(unittest.TestCase):
         pass
 
     def test_shift(self):
+        # naive shift
         shiftedFrame = self.tsframe.shift(5)
-        for i, idx in enumerate(shiftedFrame.index):
-            self.assert_(idx-5*bday == self.tsframe.index[i])
-        series = shiftedFrame['A']
-        for i, idx in enumerate(series.index):
-            self.assert_(idx-5*bday == self.tsframe.index[i])
+        self.assert_(shiftedFrame.index.equals(self.tsframe.index))
+
+        shiftedSeries = self.tsframe['A'].shift(5)
+        assert_series_equal(shiftedFrame['A'], shiftedSeries)
+
+        shiftedFrame = self.tsframe.shift(-5)
+        self.assert_(shiftedFrame.index.equals(self.tsframe.index))
+
+        shiftedSeries = self.tsframe['A'].shift(-5)
+        assert_series_equal(shiftedFrame['A'], shiftedSeries)
+
+        # shift by DateOffset
+        shiftedFrame = self.tsframe.shift(5, offset=datetools.BDay())
+        self.assert_(len(shiftedFrame) == len(self.tsframe))
+
+        d = self.tsframe.index[0]
+        shifted_d = d + datetools.BDay(5)
+        assert_series_equal(self.tsframe.getXS(d),
+                            shiftedFrame.getXS(shifted_d))
 
     def test_apply(self):
-        pass
+        # ufunc
+        applied = self.frame.apply(np.sqrt)
+        assert_series_equal(np.sqrt(self.frame['A']), applied['A'])
+
+        # aggregator
+        applied = self.frame.apply(np.mean)
+        self.assertEqual(applied['A'], np.mean(self.frame['A']))
+
+        d = self.frame.index[0]
+        applied = self.frame.apply(np.mean, axis=1)
+        self.assertEqual(applied[d], np.mean(self.frame.getXS(d)))
 
     def test_tapply(self):
-        pass
+        d = self.frame.index[0]
+        tapplied = self.frame.tapply(np.mean)
+        self.assertEqual(tapplied[d], np.mean(self.frame.getXS(d)))
 
     def test_applymap(self):
-        pass
+        f = lambda x: x * 2
+        applied = self.frame.applymap(f)
+
+        assert_frame_equal(applied, self.frame * 2)
 
     def test_tgroupby(self):
         pass
 
-    def test_filterItems(self):
-        pass
+    def test_filter(self):
+        # items
+
+        filtered = self.frame.filterItems(['A', 'B', 'E'])
+        self.assertEqual(len(filtered.cols()), 2)
+        self.assert_('E' not in filtered)
+
+        # like
+        fcopy = self.frame.copy()
+        fcopy['AA'] = 1
+
+        filtered = fcopy.filterLike('A')
+        self.assertEqual(len(filtered.cols()), 2)
+        self.assert_('AA' in filtered)
+
+        # regex
 
     def test_sortUp(self):
         # what to do?
@@ -618,14 +691,64 @@ class TestDataFrame(unittest.TestCase):
 
         sorted_A = self.frame.sortDown(column='A')
 
-    def test_filterLike(self):
-        pass
-
     def test_combineFirst(self):
-        pass
+        # disjoint
+        head, tail = self.frame[:5], self.frame[5:]
+
+        combined = head.combineFirst(tail)
+        reordered_frame = self.frame.reindex(combined.index)
+        assert_frame_equal(combined, reordered_frame)
+        self.assert_(common.equalContents(combined.cols(), self.frame.cols()))
+        assert_series_equal(combined['A'], reordered_frame['A'])
+
+        # same index
+        fcopy = self.frame.copy()
+        fcopy['A'] = 1
+        del fcopy['C']
+
+        fcopy2 = self.frame.copy()
+        fcopy2['B'] = 0
+        del fcopy2['D']
+
+        combined = fcopy.combineFirst(fcopy2)
+
+        self.assert_((combined['A'] == 1).all())
+        assert_series_equal(combined['B'], fcopy['B'])
+        assert_series_equal(combined['C'], fcopy2['C'])
+        assert_series_equal(combined['D'], fcopy['D'])
+
+        # overlap
+        head, tail = reordered_frame[:10].copy(), reordered_frame
+        head['A'] = 1
+
+        combined = head.combineFirst(tail)
+        self.assert_((combined['A'][:10] == 1).all())
+
+        # reverse overlap
+        tail['A'][:10] = 0
+        combined = tail.combineFirst(head)
+        self.assert_((combined['A'][:10] == 0).all())
+
+        # corner cases
+        comb = self.frame.combineFirst(self.empty)
+        self.assert_(comb is self.frame)
+
+        comb = self.empty.combineFirst(self.frame)
+        self.assert_(comb is self.frame)
 
     def test_combineAdd(self):
-        pass
+        # trivial
+        comb = self.frame.combineAdd(self.frame)
+
+        assert_frame_equal(comb, self.frame * 2)
+
+
+        # corner cases
+        comb = self.frame.combineAdd(self.empty)
+        self.assert_(comb is self.frame)
+
+        comb = self.empty.combineAdd(self.frame)
+        self.assert_(comb is self.frame)
 
     def test_combineMult(self):
         pass
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
index 210cb760a..451a8b589 100644
--- a/pandas/core/tests/test_series.py
+++ b/pandas/core/tests/test_series.py
@@ -558,6 +558,10 @@ class TestSeries(unittest.TestCase):
         ts = self.ts[::2]
         self.assertRaises(Exception, ts.reindex, self.ts.index, fillMethod='foo')
 
+        # corner case: pad empty series
+        s = Series([], index=[])
+        reindexed = s.reindex(self.ts.index, fillMethod='pad')
+
     def test_reindex_bool(self):
 
         # A series other than float, int, string, or object

commit 370054e35ee4512ce247146daceba8af7bb99de3
Author: Joris Van den Bossche <jorisvandenbossche@gmail.com>
Date:   Tue Jun 11 17:47:38 2019 +0200

    DOC: fix old whatsnew examples + few sphinx warnings (#26780)

diff --git a/doc/source/whatsnew/v0.11.0.rst b/doc/source/whatsnew/v0.11.0.rst
index c919698d1..0dfcfca9a 100644
--- a/doc/source/whatsnew/v0.11.0.rst
+++ b/doc/source/whatsnew/v0.11.0.rst
@@ -105,27 +105,54 @@ Conversion
 
 Mixed Conversion
 
-.. ipython:: python
-   :okwarning:
+.. code-block:: ipython
 
-   df3['D'] = '1.'
-   df3['E'] = '1'
-   df3.convert_objects(convert_numeric=True).dtypes
+    In [12]: df3['D'] = '1.'
 
-   # same, but specific dtype conversion
-   df3['D'] = df3['D'].astype('float16')
-   df3['E'] = df3['E'].astype('int32')
-   df3.dtypes
+    In [13]: df3['E'] = '1'
+
+    In [14]: df3.convert_objects(convert_numeric=True).dtypes
+    Out[14]:
+    A    float32
+    B    float64
+    C    float64
+    D    float64
+    E      int64
+    dtype: object
+
+    # same, but specific dtype conversion
+    In [15]: df3['D'] = df3['D'].astype('float16')
+
+    In [16]: df3['E'] = df3['E'].astype('int32')
+
+    In [17]: df3.dtypes
+    Out[17]:
+    A    float32
+    B    float64
+    C    float64
+    D    float16
+    E      int32
+    dtype: object
 
 Forcing Date coercion (and setting ``NaT`` when not datelike)
 
-.. ipython:: python
-   :okwarning:
+.. code-block:: ipython
+
+    In [18]: import datetime
+
+    In [19]: s = pd.Series([datetime.datetime(2001, 1, 1, 0, 0), 'foo', 1.0, 1,
+       ....:                pd.Timestamp('20010104'), '20010105'], dtype='O')
+       ....:
 
-   import datetime
-   s = pd.Series([datetime.datetime(2001, 1, 1, 0, 0), 'foo', 1.0, 1,
-                  pd.Timestamp('20010104'), '20010105'], dtype='O')
-   s.convert_objects(convert_dates='coerce')
+    In [20]: s.convert_objects(convert_dates='coerce')
+    Out[20]:
+    0   2001-01-01
+    1          NaT
+    2          NaT
+    3          NaT
+    4   2001-01-04
+    5   2001-01-05
+    dtype: datetime64[ns]
 
 Dtype Gotchas
 ~~~~~~~~~~~~~
@@ -138,11 +165,22 @@ dtypes, they *WILL* be respected, however (:issue:`2837`)
 
 The following will all result in ``int64`` dtypes
 
-.. ipython:: python
+.. code-block:: ipython
+
+    In [21]: pd.DataFrame([1, 2], columns=['a']).dtypes
+    Out[21]:
+    a    int64
+    dtype: object
+
+    In [22]: pd.DataFrame({'a': [1, 2]}).dtypes
+    Out[22]:
+    a    int64
+    dtype: object
 
-    pd.DataFrame([1, 2], columns=['a']).dtypes
-    pd.DataFrame({'a': [1, 2]}).dtypes
-    pd.DataFrame({'a': 1}, index=range(2)).dtypes
+    In [23]: pd.DataFrame({'a': 1}, index=range(2)).dtypes
+    Out[23]:
+    a    int64
+    dtype: object
 
 Keep in mind that ``DataFrame(np.array([1,2]))`` **WILL** result in ``int32`` on 32-bit platforms!
 
@@ -152,28 +190,95 @@ Keep in mind that ``DataFrame(np.array([1,2]))`` **WILL** result in ``int32`` on
 Performing indexing operations on integer type data can easily upcast the data.
 The dtype of the input data will be preserved in cases where ``nans`` are not introduced.
 
-.. ipython:: python
-
-   dfi = df3.astype('int32')
-   dfi['D'] = dfi['D'].astype('int64')
-   dfi
-   dfi.dtypes
-
-   casted = dfi[dfi > 0]
-   casted
-   casted.dtypes
+.. code-block:: ipython
+
+    In [24]: dfi = df3.astype('int32')
+
+    In [25]: dfi['D'] = dfi['D'].astype('int64')
+
+    In [26]: dfi
+    Out[26]:
+      A  B  C  D  E
+    0  0  0  0  1  1
+    1 -2  0  1  1  1
+    2 -2  0  2  1  1
+    3  0 -1  3  1  1
+    4  1  0  4  1  1
+    5  0  0  5  1  1
+    6  0 -1  6  1  1
+    7  0  0  7  1  1
+
+    In [27]: dfi.dtypes
+    Out[27]:
+    A    int32
+    B    int32
+    C    int32
+    D    int64
+    E    int32
+    dtype: object
+
+    In [28]: casted = dfi[dfi > 0]
+
+    In [29]: casted
+    Out[29]:
+        A   B    C  D  E
+    0  NaN NaN  NaN  1  1
+    1  NaN NaN  1.0  1  1
+    2  NaN NaN  2.0  1  1
+    3  NaN NaN  3.0  1  1
+    4  1.0 NaN  4.0  1  1
+    5  NaN NaN  5.0  1  1
+    6  NaN NaN  6.0  1  1
+    7  NaN NaN  7.0  1  1
+
+    In [30]: casted.dtypes
+    Out[30]:
+    A    float64
+    B    float64
+    C    float64
+    D      int64
+    E      int32
+    dtype: object
 
 While float dtypes are unchanged.
 
-.. ipython:: python
-
-   df4 = df3.copy()
-   df4['A'] = df4['A'].astype('float32')
-   df4.dtypes
-
-   casted = df4[df4 > 0]
-   casted
-   casted.dtypes
+.. code-block:: ipython
+
+    In [31]: df4 = df3.copy()
+
+    In [32]: df4['A'] = df4['A'].astype('float32')
+
+    In [33]: df4.dtypes
+    Out[33]:
+    A    float32
+    B    float64
+    C    float64
+    D    float16
+    E      int32
+    dtype: object
+
+    In [34]: casted = df4[df4 > 0]
+
+    In [35]: casted
+    Out[35]:
+              A         B    C    D  E
+    0       NaN       NaN  NaN  1.0  1
+    1       NaN  0.567020  1.0  1.0  1
+    2       NaN  0.276232  2.0  1.0  1
+    3       NaN       NaN  3.0  1.0  1
+    4  1.933792       NaN  4.0  1.0  1
+    5       NaN  0.113648  5.0  1.0  1
+    6       NaN       NaN  6.0  1.0  1
+    7       NaN  0.524988  7.0  1.0  1
+
+    In [36]: casted.dtypes
+    Out[36]:
+    A    float32
+    B    float64
+    C    float64
+    D    float16
+    E      int32
+    dtype: object
 
 Datetimes Conversion
 ~~~~~~~~~~~~~~~~~~~~
diff --git a/doc/source/whatsnew/v0.13.0.rst b/doc/source/whatsnew/v0.13.0.rst
index 13a2f8792..095d1807c 100644
--- a/doc/source/whatsnew/v0.13.0.rst
+++ b/doc/source/whatsnew/v0.13.0.rst
@@ -271,17 +271,39 @@ This is like an ``append`` operation.
 
 A Panel setting operation on an arbitrary axis aligns the input to the Panel
 
-.. ipython:: python
-   :okwarning:
-
-   p = pd.Panel(np.arange(16).reshape(2, 4, 2),
-                items=['Item1', 'Item2'],
-                major_axis=pd.date_range('2001/1/12', periods=4),
-                minor_axis=['A', 'B'], dtype='float64')
-   p
-   p.loc[:, :, 'C'] = pd.Series([30, 32], index=p.items)
-   p
-   p.loc[:, :, 'C']
+.. code-block:: ipython
+
+   In [20]: p = pd.Panel(np.arange(16).reshape(2, 4, 2),
+      ....:              items=['Item1', 'Item2'],
+      ....:              major_axis=pd.date_range('2001/1/12', periods=4),
+      ....:              minor_axis=['A', 'B'], dtype='float64')
+      ....:
+
+   In [21]: p
+   Out[21]:
+   <class 'pandas.core.panel.Panel'>
+   Dimensions: 2 (items) x 4 (major_axis) x 2 (minor_axis)
+   Items axis: Item1 to Item2
+   Major_axis axis: 2001-01-12 00:00:00 to 2001-01-15 00:00:00
+   Minor_axis axis: A to B
+
+   In [22]: p.loc[:, :, 'C'] = pd.Series([30, 32], index=p.items)
+
+   In [23]: p
+   Out[23]:
+   <class 'pandas.core.panel.Panel'>
+   Dimensions: 2 (items) x 4 (major_axis) x 3 (minor_axis)
+   Items axis: Item1 to Item2
+   Major_axis axis: 2001-01-12 00:00:00 to 2001-01-15 00:00:00
+   Minor_axis axis: A to C
+
+   In [24]: p.loc[:, :, 'C']
+   Out[24]:
+               Item1  Item2
+   2001-01-12   30.0   32.0
+   2001-01-13   30.0   32.0
+   2001-01-14   30.0   32.0
+   2001-01-15   30.0   32.0
 
 Float64Index API Change
 ~~~~~~~~~~~~~~~~~~~~~~~
diff --git a/doc/source/whatsnew/v0.25.0.rst b/doc/source/whatsnew/v0.25.0.rst
index 7d123697d..8d8f1d312 100644
--- a/doc/source/whatsnew/v0.25.0.rst
+++ b/doc/source/whatsnew/v0.25.0.rst
@@ -146,29 +146,28 @@ Constructing a :class:`MultiIndex` with ``NaN`` levels or codes value < -1 was a
 Now, construction with codes value < -1 is not allowed and ``NaN`` levels' corresponding codes
 would be reassigned as -1. (:issue:`19387`)
 
-.. ipython:: python
-
-    mi1 = pd.MultiIndex(levels=[[np.nan, None, pd.NaT, 128, 2]],
-                        codes=[[0, -1, 1, 2, 3, 4]])
-    mi2 = pd.MultiIndex(levels=[[1, 2]], codes=[[0, -2]])
-
 *Previous Behavior*:
 
 .. code-block:: ipython
 
-    In [1]: mi1
+    In [1]: pd.MultiIndex(levels=[[np.nan, None, pd.NaT, 128, 2]],
+       ...:               codes=[[0, -1, 1, 2, 3, 4]])
+       ...:
     Out[1]: MultiIndex(levels=[[nan, None, NaT, 128, 2]],
                        codes=[[0, -1, 1, 2, 3, 4]])
-    In [2]: mi2
+
+    In [2]: pd.MultiIndex(levels=[[1, 2]], codes=[[0, -2]])
     Out[2]: MultiIndex(levels=[[1, 2]],
                        codes=[[0, -2]])
 
 *New Behavior*:
 
 .. ipython:: python
+    :okexcept:
 
-    mi1
-    mi2
+    pd.MultiIndex(levels=[[np.nan, None, pd.NaT, 128, 2]],
+                  codes=[[0, -1, 1, 2, 3, 4]])
+    pd.MultiIndex(levels=[[1, 2]], codes=[[0, -2]])
 
 
 .. _whatsnew_0250.api_breaking.groupby_apply_first_group_once:
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index bb3275c27..ef406ce3d 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -4000,6 +4000,7 @@ class DataFrame(NDFrame):
         intent.
 
         Rename columns using a mapping:
+
         >>> df = pd.DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]})
         >>> df.rename(columns={"A": "a", "B": "c"})
            a  c
@@ -4008,6 +4009,7 @@ class DataFrame(NDFrame):
         2  3  6
 
         Rename index using a mapping:
+
         >>> df.rename(index={0: "x", 1: "y", 2: "z"})
            A  B
         x  1  4
@@ -4015,6 +4017,7 @@ class DataFrame(NDFrame):
         z  3  6
 
         Cast index labels to a different type:
+
         >>> df.index
         RangeIndex(start=0, stop=3, step=1)
         >>> df.rename(index=str).index
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 81fe87f19..8ec8227d8 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -10867,6 +10867,7 @@ _min_examples = _shared_docs['stat_func_example'].format(
     level_output_1=0)
 
 _stat_func_see_also = """
+
 See Also
 --------
 Series.sum : Return the sum.

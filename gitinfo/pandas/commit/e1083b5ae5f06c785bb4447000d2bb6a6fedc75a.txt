commit e1083b5ae5f06c785bb4447000d2bb6a6fedc75a
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Dec 24 17:35:30 2009 +0000

    not weighting untransformed data in PanelOLS. changed DataFrame and DataMatrix.toString to take a buffer instead of a to_stdout flag
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@94 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 52b957c4c..314cac538 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1,8 +1,10 @@
 # pylint: disable-msg=E1101
 # pylint: disable-msg=E1103
-# pylint: disable-msg=W0212,W0703
+# pylint: disable-msg=W0212,W0703,W0622
 
+from cStringIO import StringIO
 import operator
+import sys
 
 from numpy import NaN
 import numpy as np
@@ -260,11 +262,14 @@ class DataFrame(Picklable, Groupable):
         """
         Return a string representation for a particular DataFrame
         """
-        if len(self.index) < 1000 and len(self._series) < 10:
-            return self.toString(to_stdout=False)
+        buf = StringIO()
+        if len(self.index) < 500 and len(self._series) < 10:
+            self.toString(buffer=buf)
         else:
-            output = str(self.__class__) + '\n'
-            return output + self.info(to_stdout=False)
+            buf.write(str(self.__class__) + '\n')
+            self.info(buffer=buf)
+
+        return buf.getvalue()
 
     def __getitem__(self, item):
         """
@@ -313,7 +318,7 @@ class DataFrame(Picklable, Groupable):
         """
         Delete column from DataFrame (only deletes the reference)
         """
-        r = self._series.pop(key, None)
+        self._series.pop(key, None)
 
     def pop(self, item):
         """
@@ -408,7 +413,6 @@ class DataFrame(Picklable, Groupable):
 
         for col, series in other.iteritems():
             if col not in self:
-                cls = series.__class__
                 newColumns[col] = series.fromValue(np.NaN, index=newIndex)
 
         return DataFrame(data=newColumns, index=newIndex)
@@ -514,54 +518,60 @@ class DataFrame(Picklable, Groupable):
 
         return DataMatrix(self._series, index=self.index)
 
-    def toString(self, to_stdout=True, verbose=False, colSpace=15, nanRep=None):
+    def toString(self, buffer=sys.stdout, verbose=False,
+                 colSpace=15, nanRep=None, formatters=None,
+                 float_format=None):
         """Output a tab-separated version of this DataFrame"""
         series = self._series
-        skeys = sorted(series.keys())
-        if len(skeys) == 0 or len(self.index) == 0:
-            output = 'Empty DataFrame\n'
-            output += self.index.__repr__()
+        columns = sorted(series.keys())
+        formatters = formatters or {}
+
+
+        # TODO
+
+        float_format = float_format or str
+        for c in columns:
+            if c not in formatters:
+                formatters[c] = str # float_format if c in self.columns else str
+
+        if len(columns) == 0 or len(self.index) == 0:
+            print >> buffer, 'Empty DataFrame'
+            print >> buffer, repr(self.index)
         else:
             idxSpace = max([len(str(idx)) for idx in self.index]) + 4
             head = _pfixed('', idxSpace)
             if verbose:
                 colSpace = max([len(c) for c in self.columns]) + 4
-            for h in skeys:
+            for h in columns:
                 head += _pfixed(h, colSpace)
-            output = head + '\n'
+            print >> buffer, head
             for idx in self.index:
                 ot = _pfixed(idx, idxSpace)
-                for k in skeys:
-                    ot += _pfixed(series[k][idx], colSpace, nanRep=nanRep)
-                output += ot + '\n'
-        if to_stdout:
-            print output
-        else:
-            return output
+                for k in columns:
+                    formatter = formatters.get(k, str)
+                    ot += _pfixed(formatter(series[k][idx]),
+                                  colSpace, nanRep=nanRep)
+                print >> buffer, ot
 
-    def info(self, to_stdout=True):
+    def info(self, buffer=sys.stdout):
         """Concise summary of a DataFrame, used in __repr__ when very large."""
         if len(self._series) == 0:
-            output = 'DataFrame is empty!\n'
-            output += self.index.__repr__()
-            return output
-
-        output = 'Index: %s entries, %s to %s\n' % (len(self.index),
-                                                    min(self.index),
-                                                    max(self.index))
-        output += 'Columns:\n'
+            print >> buffer, 'DataFrame is empty!'
+            print >> buffer, repr(self.index)
+
+        print >> buffer, 'Index: %s entries, %s to %s' % (len(self.index),
+                                                          min(self.index),
+                                                          max(self.index))
+        print >> buffer, 'Data columns:'
+
         series = self._series
-        skeys = sorted(self.cols())
-        space = max([len(str(k)) for k in skeys]) + 4
-        for k in skeys:
+        columns = sorted(self.cols())
+        space = max([len(str(k)) for k in columns]) + 4
+        for k in columns:
             out = _pfixed(k, space)
             N = notnull(series[k]).sum()
-            out += '%d  non-null values\n' % N
-            output += out
-        if to_stdout:
-            print output
-        else:
-            return output
+            out += '%d  non-null values' % N
+            print >> buffer, out
 
     def rows(self):
         """Alias for the frame's index"""
@@ -586,7 +596,7 @@ class DataFrame(Picklable, Groupable):
         """
         newIndex = np.concatenate((self.index, otherFrame.index))
         newValues = {}
-        
+
         for column, series in self.iteritems():
             if column in otherFrame:
                 newValues[column] = series.append(otherFrame[column])
@@ -793,7 +803,7 @@ class DataFrame(Picklable, Groupable):
         else:
             return self.reindex(dateRange)
 
-    def truncate(self, before=None, after=None, periods=None):
+    def truncate(self, before=None, after=None):
         """Function truncate a sorted DataFrame before and/or after
         some particular dates.
 
@@ -803,13 +813,13 @@ class DataFrame(Picklable, Groupable):
             Truncate before date
         after : date
             Truncate after date
-        
+
         Returns
         -------
         DataFrame
         """
         beg_slice, end_slice = self._getIndices(before, after)
-        
+
         return self[beg_slice:end_slice]
 
     def _getIndices(self, before, after):
@@ -833,8 +843,8 @@ class DataFrame(Picklable, Groupable):
         end_slice = self.index.indexMap[after] + 1
 
         return beg_slice, end_slice
-        
-    def getXS(self, key, subset=None, asOf=False):
+
+    def getXS(self, key, subset=None):
         """
         Returns a row from the DataFrame as a Series object.
 
@@ -843,9 +853,6 @@ class DataFrame(Picklable, Groupable):
         key : some index contained in the index
         subset : iterable (list, array, set, etc.), optional
             columns to be included
-        asOf : boolean, optional
-            Whether to use asOf values for TimeSeries objects
-            Won't do anything for Series objects.
 
         Note
         ----
@@ -1050,7 +1057,7 @@ class DataFrame(Picklable, Groupable):
         """
         results = {}
         for col, series in self.iteritems():
-            results[col] = map(func, series)
+            results[col] = [func(v) for v in series]
         return DataFrame(data=results, index=self.index)
 
     def tgroupby(self, keyfunc, applyfunc):
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index a5bc403a5..af69a4020 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -1,11 +1,10 @@
-# pylint: disable-msg=E1101
-# pylint: disable-msg=E1103
-# pylint: disable-msg=W0212,W0703,W0231
+# pylint: disable-msg=E1101,E1103
+# pylint: disable-msg=W0212,W0703,W0231,W0622
 
 from cStringIO import StringIO
+import sys
 
 from numpy.lib.format import read_array, write_array
-from numpy import isfinite, NaN
 import numpy as np
 
 from pandas.core.frame import DataFrame, _pfixed
@@ -152,7 +151,7 @@ class DataMatrix(DataFrame):
                 K = len(columns)
 
             values = np.empty((N, K), dtype=dtype)
-            values[:] = NaN
+            values[:] = np.NaN
         else:
             raise Exception('DataMatrix constructor not properly called!')
 
@@ -315,7 +314,6 @@ class DataMatrix(DataFrame):
             By default, prints all columns in lexicographical order.
         """
         if path is None:
-            import sys
             f = sys.stdout
         else:
             f = open(path, writeMode)
@@ -345,64 +343,63 @@ class DataMatrix(DataFrame):
         if verbose:
             print 'CSV file written successfully: %s' % path
 
-    def toString(self, to_stdout=True, verbose=False, colSpace=15):
+    def toString(self, buffer=sys.stdout, verbose=False,
+                 columns=None, colSpace=15, formatters=None,
+                 float_format=None):
         """
-        Output a tab-separated version of this DataMatrix
+        Output a string version of this DataMatrix
         """
-        output = StringIO()
+        formatters = formatters or {}
 
-        mat = self.values
-        cols = self.columns
+        if columns is None:
+            columns = self.columns
+            values = self.values
+            if self.objects:
+                columns = list(columns) + list(self.objects.columns)
+                values = np.column_stack((values.astype(object),
+                                          self.objects.values))
+        else:
+            columns = [c for c in columns if c in self]
+            values = self.asMatrix(columns)
+
+        float_format = float_format or str
+        for c in columns:
+            if c not in formatters:
+                formatters[c] = float_format if c in self.columns else str
 
         idxSpace = max([len(str(idx)) for idx in self.index]) + 4
-        if len(self.cols()) == 0:
-            output.write('DataMatrix is empty!\n')
-            output.write(self.index.__repr__())
 
+        if len(self.cols()) == 0:
+            buffer.write('DataMatrix is empty!\n')
+            buffer.write(self.index.__repr__())
         else:
-            output.write(_pfixed('', idxSpace))
-            for h in self.cols():
-                output.write(_pfixed(h, colSpace))
-
-            output.write('\n')
+            buffer.write(_pfixed('', idxSpace))
+            for h in columns:
+                buffer.write(_pfixed(h, colSpace))
+            buffer.write('\n')
 
             for i, idx in enumerate(self.index):
-                output.write(_pfixed(idx, idxSpace))
-                objcounter = 0
-                floatcounter = 0
-                for cName in self.cols():
-                    if cName in cols:
-                        vals = mat[i, floatcounter]
-                        output.write(_pfixed(vals, colSpace))
-                        floatcounter += 1
-                    else:
-                        vals = self.objects.values[i, objcounter]
-                        output.write(_pfixed(vals, colSpace))
-                        objcounter += 1
+                buffer.write(_pfixed(idx, idxSpace))
+                for j, col in enumerate(columns):
+                    formatter = formatters[col]
+                    buffer.write(_pfixed(formatter(values[i, j]), colSpace))
+                buffer.write('\n')
 
-                output.write('\n')
-
-        if to_stdout:
-            print output.getvalue()
-        else:
-            return output.getvalue()
-
-    def info(self, to_stdout=True):
+    def info(self, buffer=sys.stdout):
         """
         Concise summary of a DataMatrix, used in __repr__ when very large.
         """
         if len(self.columns) == 0:
-            output = 'DataMatrix is empty!\n'
-            output += repr(self.index)
-            return output
+            print >> buffer, 'DataMatrix is empty!'
+            print >> buffer, repr(self.index)
 
-        output = 'Index: %s entries' % len(self.index)
+        print >> buffer, 'Index: %s entries' % len(self.index),
         if len(self.index) > 0:
-            output += ', %s to %s\n' % (self.index[0], self.index[-1])
+            print >> buffer, ', %s to %s' % (self.index[0], self.index[-1])
         else:
-            output += '\n'
+            print >> buffer, ''
 
-        output += 'Data columns:\n'
+        print >> buffer, 'Data columns:'
         space = max([len(str(k)) for k in self.cols()]) + 4
 
         counts = self.apply(notnull).sum(0)
@@ -433,12 +430,7 @@ class DataMatrix(DataFrame):
         else:
             dtypeLine = '\ndtype: %s(%d)' % (df, nf)
 
-        output += '\n'.join(columns) + dtypeLine
-
-        if to_stdout:
-            print output
-        else:
-            return output
+        buffer.write('\n'.join(columns) + dtypeLine)
 
 #-------------------------------------------------------------------------------
 # Properties for index and columns
@@ -514,15 +506,17 @@ class DataMatrix(DataFrame):
 
     def __repr__(self):
         """Return a string representation for a particular DataMatrix"""
+        buffer = StringIO()
+
         if self.values is None or len(self.columns) == 0:
-            output = 'Empty DataMatrix\nIndex: %s' % repr(self.index)
-        elif 0 < len(self.index) < 1000 and self.values.shape[1] < 10:
-            output = self.toString(to_stdout=False)
+            buffer.write('Empty DataMatrix\nIndex: %s' % repr(self.index))
+        elif 0 < len(self.index) < 500 and self.values.shape[1] < 10:
+            self.toString(buffer=buffer)
         else:
-            output = str(self.__class__) + '\n'
-            output = output + self.info(to_stdout=False)
+            print >> buffer, str(self.__class__)
+            self.info(buffer=buffer)
 
-        return output
+        return buffer.getvalue()
 
     def __getitem__(self, item):
         """
@@ -747,7 +741,7 @@ class DataMatrix(DataFrame):
         T, N = len(self.index), len(newCols)
 
         resultMatrix = np.empty((T, N), dtype=self.values.dtype)
-        resultMatrix.fill(NaN)
+        resultMatrix.fill(np.NaN)
 
         if not isinstance(newCols, Index):
             newCols = Index(newCols)
@@ -786,9 +780,9 @@ class DataMatrix(DataFrame):
         if not self and not other:
             return DataMatrix(index=newIndex)
         elif not self:
-            return other * NaN
+            return other * np.NaN
         elif not other:
-            return self * NaN
+            return self * np.NaN
 
         myValues = myReindex.values
         if self.columns.equals(other.columns):
@@ -805,7 +799,7 @@ class DataMatrix(DataFrame):
         else:
             T, N = len(newIndex), len(newCols)
             resultMatrix = np.empty((T, N), dtype=self.values.dtype)
-            resultMatrix.fill(NaN)
+            resultMatrix.fill(np.NaN)
 
             myIndexer = [self.columns.indexMap[idx] for idx in commonCols]
             hisIndexer =  [hisCols.indexMap[idx] for idx in commonCols]
@@ -835,7 +829,7 @@ class DataMatrix(DataFrame):
             resultMatrix = func(myReindex.values.T, other).T
         else:
             if len(other) == 0:
-                return self * NaN
+                return self * np.NaN
 
             # Operate column-wise
             other = other.reindex(self.columns).view(np.ndarray)
@@ -904,8 +898,20 @@ class DataMatrix(DataFrame):
             return self.values.copy()
         else:
             idxMap = self.columns.indexMap
-            indexer = [idxMap[col] for col in columns]
-            return self.values[:, indexer].copy()
+            indexer = [idxMap[col] for col in columns if col in idxMap]
+            values = self.values.take(indexer, axis=1)
+
+            if self.objects:
+                idxMap = self.objects.columns.indexMap
+                indexer = [idxMap[col] for col in columns if col in idxMap]
+
+                obj_values = self.objects.values.take(indexer, axis=1)
+                values = np.column_stack((values, obj_values))
+
+                # now put in the right order
+                # XXX!
+
+            return values
 
     def cols(self):
         """Return sorted list of frame's columns"""
@@ -1142,7 +1148,7 @@ class DataMatrix(DataFrame):
             return DataMatrix(newValues, index=dateRange,
                               columns=self.columns, objects=newLinks)
 
-    def getXS(self, key, subset=None, asOf=False):
+    def getXS(self, key, subset=None):
         """
         Returns a row from the DataMatrix as a Series object.
 
@@ -1151,9 +1157,6 @@ class DataMatrix(DataFrame):
         key : some index contained in the index
         subset : iterable (list, array, set, etc.), optional
             columns to be included
-        asOf : boolean, optional
-            Whether to use asOf values for TimeSeries objects
-            Won't do anything for Series objects.
 
         Note
         ----
@@ -1212,7 +1215,7 @@ class DataMatrix(DataFrame):
         fillVec, mask = tseries.getMergeVec(self[on], indexMap)
 
         tmpMatrix = otherM.take(fillVec, axis=0)
-        tmpMatrix[-mask] = NaN
+        tmpMatrix[-mask] = np.NaN
 
         seriesDict = dict((col, tmpMatrix[:, j])
                            for j, col in enumerate(otherFrame.columns))
@@ -1223,7 +1226,7 @@ class DataMatrix(DataFrame):
             objM = objects.asMatrix()
 
             tmpMat = objM.take(fillVec, axis=0)
-            tmpMat[-mask] = NaN
+            tmpMat[-mask] = np.NaN
             objDict = dict((col, tmpMat[:, j])
                            for j, col in enumerate(objects.columns))
 
@@ -1276,7 +1279,7 @@ class DataMatrix(DataFrame):
                                            newMap, fillMethod)
 
         tmpMatrix = selfM.take(fillVec, axis=0)
-        tmpMatrix[-mask] = NaN
+        tmpMatrix[-mask] = np.NaN
 
         if self.objects is not None and len(self.objects.columns) > 0:
             newLinks = self.objects.reindex(newIndex)
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 60c5a0686..675477e2e 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -45,6 +45,7 @@ class Panel(Picklable):
     _major_axis = None
     _minor_axis = None
     _values = None
+    factors = None
 
     def __repr__(self):
         class_name = str(self.__class__)
@@ -193,7 +194,7 @@ class WidePanel(Panel):
         return index, columns
 
     @classmethod
-    def fromDict(cls, data, intersect=True):
+    def fromDict(cls, data, intersect=True, dtype=float):
         """
         Construct WidePanel from dict of DataFrame objects
 
@@ -210,7 +211,7 @@ class WidePanel(Panel):
         data, index, columns = _homogenize(data, intersect=intersect)
         items = Index(sorted(data.keys()))
 
-        values = np.array([data[k].values for k in items], dtype=float)
+        values = np.array([data[k].values for k in items], dtype=dtype)
 
         return cls(values, items, index, columns)
 
diff --git a/pandas/stats/ols.py b/pandas/stats/ols.py
index 72b559dc3..5a5ba3f97 100644
--- a/pandas/stats/ols.py
+++ b/pandas/stats/ols.py
@@ -503,8 +503,9 @@ class MovingOLS(OLS):
 
         OLS.__init__(self, y=y, x=x, **self._args)
 
+        self._window = int(window)
         self._window_type = common._get_window_type(window_type)
-        self._window = window
+
         self._min_periods = window if min_periods is None else min_periods
 
 #-------------------------------------------------------------------------------
diff --git a/pandas/stats/plm.py b/pandas/stats/plm.py
index 373b25f3d..d3008a416 100644
--- a/pandas/stats/plm.py
+++ b/pandas/stats/plm.py
@@ -76,7 +76,6 @@ class PanelOLS(OLS):
          self._x_filtered, self._y,
          self._y_trans) = self._prepare_data()
 
-        self._x_raw = self._x.values
         self._x_trans_raw = self._x_trans.values
         self._y_trans_raw = self._y_trans.values.squeeze()
 
@@ -115,7 +114,6 @@ class PanelOLS(OLS):
                                                 - self._x_effects)
 
         if self._time_effects:
-            x_filtered = x_filtered.subtract(x_filtered.mean(broadcast=True))
             x_regressor = x.subtract(x.mean(broadcast=True))
             y_regressor = y.subtract(y.mean(broadcast=True))
 
@@ -127,16 +125,12 @@ class PanelOLS(OLS):
             y_regressor = y
         else:
             self.log('No intercept added')
-
             x_regressor = x
             y_regressor = y
 
         if weights is not None:
-            x = x.multiply(weights)
-            x_regressor = x_regressor.multiply(weights)
-            x_filtered = x_filtered.multiply(weights_filt)
-            y = y.multiply(weights)
             y_regressor = y_regressor.multiply(weights)
+            x_regressor = x_regressor.multiply(weights)
 
         return x, x_regressor, x_filtered, y, y_regressor
 
@@ -610,7 +604,7 @@ class MovingPanelOLS(MovingOLS, PanelOLS):
         -------
         DataMatrix
         """
-        x = self._x_raw
+        x = self._x.values
         betas = self._beta_matrix(lag=lag)
         return self._unstack_y((betas * x).sum(1))
 
@@ -731,14 +725,14 @@ class MovingPanelOLS(MovingOLS, PanelOLS):
 
     @cache_readonly
     def _y_fitted_raw(self):
-        x = self._x_raw
+        x = self._x.values
         betas = self._beta_matrix(lag=0)
         return (betas * x).sum(1)
 
     @cache_readonly
     def _y_predict_raw(self):
         """Returns the raw predicted y values."""
-        x = self._x_raw
+        x = self._x.values
         betas = self._beta_matrix(lag=1)
         return (betas * x).sum(1)
 
diff --git a/pandas/stats/tests/test_ols.py b/pandas/stats/tests/test_ols.py
index aa2949c98..59b6bfdaf 100644
--- a/pandas/stats/tests/test_ols.py
+++ b/pandas/stats/tests/test_ols.py
@@ -180,7 +180,10 @@ class TestPanelOLS(BaseTest):
                  [30, 48, 1]]
         assert_almost_equal(exp_x, result._x.values)
 
-        exp_x_filtered = [[6, 14, 1], [9, 17, 1], [30, 48, 1], [11, 20, 1],
+        exp_x_filtered = [[6, 14, 1],
+                          [9, 17, 1],
+                          [30, 48, 1],
+                          [11, 20, 1],
                           [12, 21, 1]]
         assert_almost_equal(exp_x_filtered, result._x_filtered.values)
 
@@ -199,18 +202,24 @@ class TestPanelOLS(BaseTest):
 
         result = ols(y=self.panel_y2, x=self.panel_x2, weights=weights)
 
-        assert_almost_equal(result._y.values.flat, [0, 16, 25])
+        assert_almost_equal(result._y_trans.values.flat, [0, 16, 25])
 
         exp_x = [[0, 0, 0],
                  [36, 68, 4],
                  [150, 240, 5]]
-        assert_almost_equal(result._x.values, exp_x)
+        assert_almost_equal(result._x_trans.values, exp_x)
 
-        exp_x_filtered = [[0, 0, 0],
-                          [36, 68, 4],
-                          [150, 240, 5],
-                          [66, 120, 6],
-                          [84, 147, 7]]
+
+        exp_x_filtered = [[6, 14, 1],
+                          [9, 17, 1],
+                          [30, 48, 1],
+                          [11, 20, 1],
+                          [12, 21, 1]]
+#         exp_x_filtered = [[0, 0, 0],
+#                           [36, 68, 4],
+#                           [150, 240, 5],
+#                           [66, 120, 6],
+#                           [84, 147, 7]]
 
         assert_almost_equal(result._x_filtered.values, exp_x_filtered)
 
@@ -233,7 +242,7 @@ class TestPanelOLS(BaseTest):
         exp_x = [[6, 14, 0, 1], [9, 17, 0, 1], [30, 48, 1, 1]]
         assert_almost_equal(result._x.values, exp_x)
 
-        exp_index = Index(['x1', 'x2', 'fe_B', 'intercept'])
+        exp_index = Index(['x1', 'x2', 'FE_B', 'intercept'])
         self.assertTrue(exp_index.equals(result._x.items))
 
         # _check_non_raw_results(result)
@@ -246,7 +255,7 @@ class TestPanelOLS(BaseTest):
         exp_x = [[6, 14, 1, 1], [9, 17, 1, 1], [30, 48, 0, 1]]
         assert_almost_equal(result._x.values, exp_x)
 
-        exp_index = Index(['x1', 'x2', 'fe_A', 'intercept'])
+        exp_index = Index(['x1', 'x2', 'FE_A', 'intercept'])
         self.assertTrue(exp_index.equals(result._x.items))
 
         # _check_non_raw_results(result)

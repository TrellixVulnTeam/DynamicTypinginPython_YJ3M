commit 9c0dc26bb640ce26be3bad81ab4541b33d2d0a3e
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Mar 12 13:36:40 2012 -0400

    ENH: testing / tweaks for non-float dtype ranking #874

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 1f62c4244..fb553864b 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -3730,7 +3730,7 @@ class DataFrame(NDFrame):
         """
         return self.apply(lambda x: x.clip_lower(threshold))
 
-    def rank(self, axis=0, numeric_only=None, method='average'):
+    def rank(self, axis=0, numeric_only=None, method='average', na_option='keep'):
         """
         Compute numerical data ranks (1 through n) along axis. Equal values are
         assigned a rank that is the average of the ranks of those values
@@ -3741,6 +3741,13 @@ class DataFrame(NDFrame):
             Ranks over columns (0) or rows (1)
         numeric_only : boolean, default None
             Include only float, int, boolean data
+        method : {'average', 'min', 'max', 'first'}
+            average: average rank of group
+            min: lowest rank in group
+            max: highest rank in group
+            first: ranks assigned in order they appear in the array
+        na_option : {'keep'}
+            keep: leave NA values where they are
 
         Returns
         -------
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 74fc701b5..3979e697b 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1584,7 +1584,12 @@ copy : boolean, default False
         Parameters
         ----------
         method : {'average', 'min', 'max', 'first'}
+            average: average rank of group
+            min: lowest rank in group
+            max: highest rank in group
+            first: ranks assigned in order they appear in the array
         na_option : {'keep'}
+            keep: leave NA values where they are
 
         Returns
         -------
diff --git a/pandas/src/sandbox.pyx b/pandas/src/sandbox.pyx
index dd4d4fac8..5846ea04f 100644
--- a/pandas/src/sandbox.pyx
+++ b/pandas/src/sandbox.pyx
@@ -210,3 +210,62 @@ cdef class Int64HashTable:
                 count += 1
 
         return labels
+
+#----------------------------------------------------------------------
+# isnull / notnull related
+
+cdef double INF = <double> np.inf
+cdef double NEGINF = -INF
+
+cdef inline bint _checknull(object val):
+    return not np.PyArray_Check(val) and (val is None or val != val)
+
+cdef inline bint _checknan(object val):
+    return not np.PyArray_Check(val) and val != val
+
+cpdef checknull(object val):
+    if util.is_float_object(val):
+        return val != val or val == INF or val == NEGINF
+    elif is_array(val):
+        return False
+    else:
+        return _checknull(val)
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def isnullobj(ndarray[object] arr):
+    cdef Py_ssize_t i, n
+    cdef object val
+    cdef ndarray[uint8_t] result
+
+    n = len(arr)
+    result = np.zeros(n, dtype=np.uint8)
+    for i from 0 <= i < n:
+        result[i] = _checknull(arr[i])
+    return result.view(np.bool_)
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def isnullobj2d(ndarray[object, ndim=2] arr):
+    cdef Py_ssize_t i, j, n, m
+    cdef object val
+    cdef ndarray[uint8_t, ndim=2] result
+
+    n, m = (<object> arr).shape
+    result = np.zeros((n, m), dtype=np.uint8)
+    for i from 0 <= i < n:
+        for j from 0 <= j < m:
+            val = arr[i, j]
+            if checknull(val):
+                result[i, j] = 1
+    return result.view(np.bool_)
+
+from util cimport is_array
+
+from numpy import nan
+
+cdef extern from "math.h":
+    double sqrt(double x)
+    double fabs(double)
+
+cdef float64_t FP_ERR = 1e-13
diff --git a/pandas/src/stats.pyx b/pandas/src/stats.pyx
index 2a15383a5..61bc9fcea 100644
--- a/pandas/src/stats.pyx
+++ b/pandas/src/stats.pyx
@@ -188,8 +188,9 @@ def rank_1d_generic(object in_arr, bint retry=1, ties_method='average'):
                 for j in range(i - dups + 1, i + 1):
                     ranks[argsorted[j]] = i + 1
             elif tiebreak == TIEBREAK_FIRST:
-                for j in range(i - dups + 1, i + 1):
-                    ranks[argsorted[j]] = j + 1
+                raise ValueError('first not supported for non-numeric data')
+                # for j in range(i - dups + 1, i + 1):
+                #     ranks[argsorted[j]] = j + 1
             sum_ranks = dups = 0
     return ranks
 
@@ -278,8 +279,9 @@ def rank_2d_generic(object in_arr, axis=0, ties_method='average'):
                     for z in range(j - dups + 1, j + 1):
                         ranks[i, argsorted[i, z]] = j + 1
                 elif tiebreak == TIEBREAK_FIRST:
-                    for z in range(j - dups + 1, j + 1):
-                        ranks[i, argsorted[i, z]] = z + 1
+                    raise ValueError('first not supported for non-numeric data')
+                    # for z in range(j - dups + 1, j + 1):
+                    #     ranks[i, argsorted[i, z]] = z + 1
                 sum_ranks = dups = 0
 
     if axis == 0:
diff --git a/pandas/tests/test_stats.py b/pandas/tests/test_stats.py
index 69f7b2dad..63a112151 100644
--- a/pandas/tests/test_stats.py
+++ b/pandas/tests/test_stats.py
@@ -14,24 +14,27 @@ class TestStats(unittest.TestCase):
     def test_rank_tie_methods(self):
         s = Series([1, 3, 4, 2, nan, 2, 1, 5, nan, 3])
 
-        # c(1, 3, 4, 2, NA, 2, 1, 5, NA, 3)
+        def _check(s, expected, method='average'):
+            result = s.rank(method=method)
+            assert_almost_equal(result, expected)
 
-        ranks = s.rank()
-        expected = np.array([1.5, 5.5, 7.0, 3.5, nan,
-                             3.5, 1.5, 8.0, nan, 5.5])
-        assert_almost_equal(ranks, expected)
+        results = {
+            'average': np.array([1.5, 5.5, 7.0, 3.5, nan,
+                                 3.5, 1.5, 8.0, nan, 5.5]),
+            'min': np.array([1, 5, 7, 3, nan, 3, 1, 8, nan, 5]),
+            'max': np.array([2, 6, 7, 4, nan, 4, 2, 8, nan, 6]),
+            'first': np.array([1, 5, 7, 3, nan, 4, 2, 8, nan, 6])
+        }
 
-        ranks = s.rank(method='min')
-        expected = np.array([1, 5, 7, 3, nan, 3, 1, 8, nan, 5])
-        assert_almost_equal(ranks, expected)
+        dtypes = [None, object]
 
-        ranks = s.rank(method='max')
-        expected = np.array([2, 6, 7, 4, nan, 4, 2, 8, nan, 6])
-        assert_almost_equal(ranks, expected)
+        disabled = set([(object, 'first')])
 
-        ranks = s.rank(method='first')
-        expected = np.array([1, 5, 7, 3, nan, 4, 2, 8, nan, 6])
-        assert_almost_equal(ranks, expected)
+        for method, dtype in product(results, dtypes):
+            if (dtype, method) in disabled:
+                continue
+            series = s if dtype is None else s.astype(dtype)
+            _check(series, results[method], method=method)
 
     def test_rank_2d_tie_methods(self):
         s = Series([1, 3, 4, 2, nan, 2, 1, 5, nan, 3])
@@ -55,9 +58,13 @@ class TestStats(unittest.TestCase):
             'first': np.array([1, 5, 7, 3, nan, 4, 2, 8, nan, 6])
         }
 
-        dtypes = [None]
+        dtypes = [None, object]
+
+        disabled = set([(object, 'first')])
 
         for method, axis, dtype in product(results, [0, 1], dtypes):
+            if (dtype, method) in disabled:
+                continue
             frame = df if dtype is None else df.astype(dtype)
             _check2d(frame, results[method], method=method, axis=axis)
 

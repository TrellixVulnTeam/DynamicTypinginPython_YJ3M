commit b94524775432cc309c57bb82d52bd41e1beb693f
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Wed Feb 21 16:11:32 2018 -0800

    parametrize a whole mess of tests (#19785)

diff --git a/pandas/tests/indexes/datetimes/test_arithmetic.py b/pandas/tests/indexes/datetimes/test_arithmetic.py
index f252d6ec3..7900c983b 100644
--- a/pandas/tests/indexes/datetimes/test_arithmetic.py
+++ b/pandas/tests/indexes/datetimes/test_arithmetic.py
@@ -614,19 +614,19 @@ class TestDatetimeIndexArithmetic(object):
         result = dti2 - dti1
         tm.assert_index_equal(result, expected)
 
-    def test_sub_period(self):
-        # GH 13078
+    @pytest.mark.parametrize('freq', [None, 'D'])
+    def test_sub_period(self, freq):
+        # GH#13078
         # not supported, check TypeError
         p = pd.Period('2011-01-01', freq='D')
 
-        for freq in [None, 'D']:
-            idx = pd.DatetimeIndex(['2011-01-01', '2011-01-02'], freq=freq)
+        idx = pd.DatetimeIndex(['2011-01-01', '2011-01-02'], freq=freq)
 
-            with pytest.raises(TypeError):
-                idx - p
+        with pytest.raises(TypeError):
+            idx - p
 
-            with pytest.raises(TypeError):
-                p - idx
+        with pytest.raises(TypeError):
+            p - idx
 
     def test_ufunc_coercions(self):
         idx = date_range('2011-01-01', periods=3, freq='2D', name='x')
diff --git a/pandas/tests/indexes/datetimes/test_construction.py b/pandas/tests/indexes/datetimes/test_construction.py
index 197a42bda..176f5bd0c 100644
--- a/pandas/tests/indexes/datetimes/test_construction.py
+++ b/pandas/tests/indexes/datetimes/test_construction.py
@@ -351,52 +351,51 @@ class TestDatetimeIndex(object):
                       freq='B')
         pytest.raises(ValueError, DatetimeIndex, periods=10, freq='D')
 
-    def test_constructor_datetime64_tzformat(self):
-        # see gh-6572: ISO 8601 format results in pytz.FixedOffset
-        for freq in ['AS', 'W-SUN']:
-            idx = date_range('2013-01-01T00:00:00-05:00',
-                             '2016-01-01T23:59:59-05:00', freq=freq)
-            expected = date_range('2013-01-01T00:00:00', '2016-01-01T23:59:59',
-                                  freq=freq, tz=pytz.FixedOffset(-300))
-            tm.assert_index_equal(idx, expected)
-            # Unable to use `US/Eastern` because of DST
-            expected_i8 = date_range('2013-01-01T00:00:00',
-                                     '2016-01-01T23:59:59', freq=freq,
-                                     tz='America/Lima')
-            tm.assert_numpy_array_equal(idx.asi8, expected_i8.asi8)
-
-            idx = date_range('2013-01-01T00:00:00+09:00',
-                             '2016-01-01T23:59:59+09:00', freq=freq)
-            expected = date_range('2013-01-01T00:00:00', '2016-01-01T23:59:59',
-                                  freq=freq, tz=pytz.FixedOffset(540))
-            tm.assert_index_equal(idx, expected)
-            expected_i8 = date_range('2013-01-01T00:00:00',
-                                     '2016-01-01T23:59:59', freq=freq,
-                                     tz='Asia/Tokyo')
-            tm.assert_numpy_array_equal(idx.asi8, expected_i8.asi8)
+    @pytest.mark.parametrize('freq', ['AS', 'W-SUN'])
+    def test_constructor_datetime64_tzformat(self, freq):
+        # see GH#6572: ISO 8601 format results in pytz.FixedOffset
+        idx = date_range('2013-01-01T00:00:00-05:00',
+                         '2016-01-01T23:59:59-05:00', freq=freq)
+        expected = date_range('2013-01-01T00:00:00', '2016-01-01T23:59:59',
+                              freq=freq, tz=pytz.FixedOffset(-300))
+        tm.assert_index_equal(idx, expected)
+        # Unable to use `US/Eastern` because of DST
+        expected_i8 = date_range('2013-01-01T00:00:00',
+                                 '2016-01-01T23:59:59', freq=freq,
+                                 tz='America/Lima')
+        tm.assert_numpy_array_equal(idx.asi8, expected_i8.asi8)
+
+        idx = date_range('2013-01-01T00:00:00+09:00',
+                         '2016-01-01T23:59:59+09:00', freq=freq)
+        expected = date_range('2013-01-01T00:00:00', '2016-01-01T23:59:59',
+                              freq=freq, tz=pytz.FixedOffset(540))
+        tm.assert_index_equal(idx, expected)
+        expected_i8 = date_range('2013-01-01T00:00:00',
+                                 '2016-01-01T23:59:59', freq=freq,
+                                 tz='Asia/Tokyo')
+        tm.assert_numpy_array_equal(idx.asi8, expected_i8.asi8)
 
         # Non ISO 8601 format results in dateutil.tz.tzoffset
-        for freq in ['AS', 'W-SUN']:
-            idx = date_range('2013/1/1 0:00:00-5:00', '2016/1/1 23:59:59-5:00',
-                             freq=freq)
-            expected = date_range('2013-01-01T00:00:00', '2016-01-01T23:59:59',
-                                  freq=freq, tz=pytz.FixedOffset(-300))
-            tm.assert_index_equal(idx, expected)
-            # Unable to use `US/Eastern` because of DST
-            expected_i8 = date_range('2013-01-01T00:00:00',
-                                     '2016-01-01T23:59:59', freq=freq,
-                                     tz='America/Lima')
-            tm.assert_numpy_array_equal(idx.asi8, expected_i8.asi8)
-
-            idx = date_range('2013/1/1 0:00:00+9:00',
-                             '2016/1/1 23:59:59+09:00', freq=freq)
-            expected = date_range('2013-01-01T00:00:00', '2016-01-01T23:59:59',
-                                  freq=freq, tz=pytz.FixedOffset(540))
-            tm.assert_index_equal(idx, expected)
-            expected_i8 = date_range('2013-01-01T00:00:00',
-                                     '2016-01-01T23:59:59', freq=freq,
-                                     tz='Asia/Tokyo')
-            tm.assert_numpy_array_equal(idx.asi8, expected_i8.asi8)
+        idx = date_range('2013/1/1 0:00:00-5:00', '2016/1/1 23:59:59-5:00',
+                         freq=freq)
+        expected = date_range('2013-01-01T00:00:00', '2016-01-01T23:59:59',
+                              freq=freq, tz=pytz.FixedOffset(-300))
+        tm.assert_index_equal(idx, expected)
+        # Unable to use `US/Eastern` because of DST
+        expected_i8 = date_range('2013-01-01T00:00:00',
+                                 '2016-01-01T23:59:59', freq=freq,
+                                 tz='America/Lima')
+        tm.assert_numpy_array_equal(idx.asi8, expected_i8.asi8)
+
+        idx = date_range('2013/1/1 0:00:00+9:00',
+                         '2016/1/1 23:59:59+09:00', freq=freq)
+        expected = date_range('2013-01-01T00:00:00', '2016-01-01T23:59:59',
+                              freq=freq, tz=pytz.FixedOffset(540))
+        tm.assert_index_equal(idx, expected)
+        expected_i8 = date_range('2013-01-01T00:00:00',
+                                 '2016-01-01T23:59:59', freq=freq,
+                                 tz='Asia/Tokyo')
+        tm.assert_numpy_array_equal(idx.asi8, expected_i8.asi8)
 
     def test_constructor_dtype(self):
 
@@ -451,36 +450,35 @@ class TestTimeSeries(object):
         rng2 = DatetimeIndex(rng)
         assert rng.freq == rng2.freq
 
-    def test_dti_constructor_years_only(self):
+    @pytest.mark.parametrize('tz', [None, 'UTC', 'Asia/Tokyo',
+                                    'dateutil/US/Pacific'])
+    def test_dti_constructor_years_only(self, tz):
         # GH 6961
-        for tz in [None, 'UTC', 'Asia/Tokyo', 'dateutil/US/Pacific']:
-            rng1 = date_range('2014', '2015', freq='M', tz=tz)
-            expected1 = date_range('2014-01-31', '2014-12-31', freq='M', tz=tz)
+        rng1 = date_range('2014', '2015', freq='M', tz=tz)
+        expected1 = date_range('2014-01-31', '2014-12-31', freq='M', tz=tz)
 
-            rng2 = date_range('2014', '2015', freq='MS', tz=tz)
-            expected2 = date_range('2014-01-01', '2015-01-01', freq='MS',
-                                   tz=tz)
+        rng2 = date_range('2014', '2015', freq='MS', tz=tz)
+        expected2 = date_range('2014-01-01', '2015-01-01', freq='MS', tz=tz)
 
-            rng3 = date_range('2014', '2020', freq='A', tz=tz)
-            expected3 = date_range('2014-12-31', '2019-12-31', freq='A', tz=tz)
+        rng3 = date_range('2014', '2020', freq='A', tz=tz)
+        expected3 = date_range('2014-12-31', '2019-12-31', freq='A', tz=tz)
 
-            rng4 = date_range('2014', '2020', freq='AS', tz=tz)
-            expected4 = date_range('2014-01-01', '2020-01-01', freq='AS',
-                                   tz=tz)
+        rng4 = date_range('2014', '2020', freq='AS', tz=tz)
+        expected4 = date_range('2014-01-01', '2020-01-01', freq='AS', tz=tz)
 
-            for rng, expected in [(rng1, expected1), (rng2, expected2),
-                                  (rng3, expected3), (rng4, expected4)]:
-                tm.assert_index_equal(rng, expected)
+        for rng, expected in [(rng1, expected1), (rng2, expected2),
+                              (rng3, expected3), (rng4, expected4)]:
+            tm.assert_index_equal(rng, expected)
 
-    def test_dti_constructor_small_int(self):
+    @pytest.mark.parametrize('dtype', [np.int64, np.int32, np.int16, np.int8])
+    def test_dti_constructor_small_int(self, dtype):
         # GH 13721
         exp = DatetimeIndex(['1970-01-01 00:00:00.00000000',
                              '1970-01-01 00:00:00.00000001',
                              '1970-01-01 00:00:00.00000002'])
 
-        for dtype in [np.int64, np.int32, np.int16, np.int8]:
-            arr = np.array([0, 10, 20], dtype=dtype)
-            tm.assert_index_equal(DatetimeIndex(arr), exp)
+        arr = np.array([0, 10, 20], dtype=dtype)
+        tm.assert_index_equal(DatetimeIndex(arr), exp)
 
     def test_ctor_str_intraday(self):
         rng = DatetimeIndex(['1-1-2000 00:00:01'])
@@ -499,7 +497,7 @@ class TestTimeSeries(object):
         assert (idx.values == conversion.ensure_datetime64ns(arr)).all()
 
     def test_constructor_int64_nocopy(self):
-        # #1624
+        # GH#1624
         arr = np.arange(1000, dtype=np.int64)
         index = DatetimeIndex(arr)
 
@@ -512,19 +510,17 @@ class TestTimeSeries(object):
         arr[50:100] = -1
         assert (index.asi8[50:100] != -1).all()
 
-    def test_from_freq_recreate_from_data(self):
-        freqs = ['M', 'Q', 'A', 'D', 'B', 'BH', 'T', 'S', 'L', 'U', 'H', 'N',
-                 'C']
-
-        for f in freqs:
-            org = DatetimeIndex(start='2001/02/01 09:00', freq=f, periods=1)
-            idx = DatetimeIndex(org, freq=f)
-            tm.assert_index_equal(idx, org)
-
-            org = DatetimeIndex(start='2001/02/01 09:00', freq=f,
-                                tz='US/Pacific', periods=1)
-            idx = DatetimeIndex(org, freq=f, tz='US/Pacific')
-            tm.assert_index_equal(idx, org)
+    @pytest.mark.parametrize('freq', ['M', 'Q', 'A', 'D', 'B', 'BH',
+                                      'T', 'S', 'L', 'U', 'H', 'N', 'C'])
+    def test_from_freq_recreate_from_data(self, freq):
+        org = DatetimeIndex(start='2001/02/01 09:00', freq=freq, periods=1)
+        idx = DatetimeIndex(org, freq=freq)
+        tm.assert_index_equal(idx, org)
+
+        org = DatetimeIndex(start='2001/02/01 09:00', freq=freq,
+                            tz='US/Pacific', periods=1)
+        idx = DatetimeIndex(org, freq=freq, tz='US/Pacific')
+        tm.assert_index_equal(idx, org)
 
     def test_datetimeindex_constructor_misc(self):
         arr = ['1/1/2005', '1/2/2005', 'Jn 3, 2005', '2005-01-04']
diff --git a/pandas/tests/indexes/datetimes/test_date_range.py b/pandas/tests/indexes/datetimes/test_date_range.py
index 3738398d0..d2ec46546 100644
--- a/pandas/tests/indexes/datetimes/test_date_range.py
+++ b/pandas/tests/indexes/datetimes/test_date_range.py
@@ -222,16 +222,13 @@ class TestDateRanges(TestData):
         with tm.assert_raises_regex(ValueError, msg):
             date_range()
 
-    def test_compat_replace(self):
+    @pytest.mark.parametrize('f', [compat.long, int])
+    def test_compat_replace(self, f):
         # https://github.com/statsmodels/statsmodels/issues/3349
         # replace should take ints/longs for compat
-
-        for f in [compat.long, int]:
-            result = date_range(Timestamp('1960-04-01 00:00:00',
-                                          freq='QS-JAN'),
-                                periods=f(76),
-                                freq='QS-JAN')
-            assert len(result) == 76
+        result = date_range(Timestamp('1960-04-01 00:00:00', freq='QS-JAN'),
+                            periods=f(76), freq='QS-JAN')
+        assert len(result) == 76
 
     def test_catch_infinite_loop(self):
         offset = offsets.DateOffset(minute=5)
@@ -484,24 +481,24 @@ class TestBusinessDateRange(object):
         assert dr[0] == start
         assert dr[2] == end
 
-    def test_range_closed(self):
+    @pytest.mark.parametrize('freq', ["1D", "3D", "2M", "7W", "3H", "A"])
+    def test_range_closed(self, freq):
         begin = datetime(2011, 1, 1)
         end = datetime(2014, 1, 1)
 
-        for freq in ["1D", "3D", "2M", "7W", "3H", "A"]:
-            closed = date_range(begin, end, closed=None, freq=freq)
-            left = date_range(begin, end, closed="left", freq=freq)
-            right = date_range(begin, end, closed="right", freq=freq)
-            expected_left = left
-            expected_right = right
+        closed = date_range(begin, end, closed=None, freq=freq)
+        left = date_range(begin, end, closed="left", freq=freq)
+        right = date_range(begin, end, closed="right", freq=freq)
+        expected_left = left
+        expected_right = right
 
-            if end == closed[-1]:
-                expected_left = closed[:-1]
-            if begin == closed[0]:
-                expected_right = closed[1:]
+        if end == closed[-1]:
+            expected_left = closed[:-1]
+        if begin == closed[0]:
+            expected_right = closed[1:]
 
-            tm.assert_index_equal(expected_left, left)
-            tm.assert_index_equal(expected_right, right)
+        tm.assert_index_equal(expected_left, left)
+        tm.assert_index_equal(expected_right, right)
 
     def test_range_closed_with_tz_aware_start_end(self):
         # GH12409, GH12684
@@ -546,28 +543,28 @@ class TestBusinessDateRange(object):
             tm.assert_index_equal(expected_left, left)
             tm.assert_index_equal(expected_right, right)
 
-    def test_range_closed_boundary(self):
-        # GH 11804
-        for closed in ['right', 'left', None]:
-            right_boundary = date_range('2015-09-12', '2015-12-01',
-                                        freq='QS-MAR', closed=closed)
-            left_boundary = date_range('2015-09-01', '2015-09-12',
-                                       freq='QS-MAR', closed=closed)
-            both_boundary = date_range('2015-09-01', '2015-12-01',
-                                       freq='QS-MAR', closed=closed)
-            expected_right = expected_left = expected_both = both_boundary
-
-            if closed == 'right':
-                expected_left = both_boundary[1:]
-            if closed == 'left':
-                expected_right = both_boundary[:-1]
-            if closed is None:
-                expected_right = both_boundary[1:]
-                expected_left = both_boundary[:-1]
-
-            tm.assert_index_equal(right_boundary, expected_right)
-            tm.assert_index_equal(left_boundary, expected_left)
-            tm.assert_index_equal(both_boundary, expected_both)
+    @pytest.mark.parametrize('closed', ['right', 'left', None])
+    def test_range_closed_boundary(self, closed):
+        # GH#11804
+        right_boundary = date_range('2015-09-12', '2015-12-01',
+                                    freq='QS-MAR', closed=closed)
+        left_boundary = date_range('2015-09-01', '2015-09-12',
+                                   freq='QS-MAR', closed=closed)
+        both_boundary = date_range('2015-09-01', '2015-12-01',
+                                   freq='QS-MAR', closed=closed)
+        expected_right = expected_left = expected_both = both_boundary
+
+        if closed == 'right':
+            expected_left = both_boundary[1:]
+        if closed == 'left':
+            expected_right = both_boundary[:-1]
+        if closed is None:
+            expected_right = both_boundary[1:]
+            expected_left = both_boundary[:-1]
+
+        tm.assert_index_equal(right_boundary, expected_right)
+        tm.assert_index_equal(left_boundary, expected_left)
+        tm.assert_index_equal(both_boundary, expected_both)
 
     def test_years_only(self):
         # GH 6961
diff --git a/pandas/tests/indexes/datetimes/test_datetime.py b/pandas/tests/indexes/datetimes/test_datetime.py
index 05678b0c8..2cf336443 100644
--- a/pandas/tests/indexes/datetimes/test_datetime.py
+++ b/pandas/tests/indexes/datetimes/test_datetime.py
@@ -356,12 +356,11 @@ class TestDatetimeIndex(object):
         assert cols.dtype == joined.dtype
         tm.assert_numpy_array_equal(cols.values, joined.values)
 
-    def test_join_self(self):
+    @pytest.mark.parametrize('how', ['outer', 'inner', 'left', 'right'])
+    def test_join_self(self, how):
         index = date_range('1/1/2000', periods=10)
-        kinds = 'outer', 'inner', 'left', 'right'
-        for kind in kinds:
-            joined = index.join(index, how=kind)
-            assert index is joined
+        joined = index.join(index, how=how)
+        assert index is joined
 
     def assert_index_parameters(self, index):
         assert index.freq == '40960N'
@@ -381,18 +380,17 @@ class TestDatetimeIndex(object):
                                      freq=index.freq)
         self.assert_index_parameters(new_index)
 
-    def test_join_with_period_index(self):
+    @pytest.mark.parametrize('how', ['left', 'right', 'inner', 'outer'])
+    def test_join_with_period_index(self, how):
         df = tm.makeCustomDataframe(
             10, 10, data_gen_f=lambda *args: np.random.randint(2),
             c_idx_type='p', r_idx_type='dt')
         s = df.iloc[:5, 0]
-        joins = 'left', 'right', 'inner', 'outer'
 
-        for join in joins:
-            with tm.assert_raises_regex(ValueError,
-                                        'can only call with other '
-                                        'PeriodIndex-ed objects'):
-                df.columns.join(s.index, how=join)
+        with tm.assert_raises_regex(ValueError,
+                                    'can only call with other '
+                                    'PeriodIndex-ed objects'):
+            df.columns.join(s.index, how=how)
 
     def test_factorize(self):
         idx1 = DatetimeIndex(['2014-01', '2014-01', '2014-02', '2014-02',
@@ -439,18 +437,18 @@ class TestDatetimeIndex(object):
         tm.assert_numpy_array_equal(arr, exp_arr)
         tm.assert_index_equal(idx, idx3)
 
-    def test_factorize_tz(self):
-        # GH 13750
-        for tz in [None, 'UTC', 'US/Eastern', 'Asia/Tokyo']:
-            base = pd.date_range('2016-11-05', freq='H', periods=100, tz=tz)
-            idx = base.repeat(5)
+    @pytest.mark.parametrize('tz', [None, 'UTC', 'US/Eastern', 'Asia/Tokyo'])
+    def test_factorize_tz(self, tz):
+        # GH#13750
+        base = pd.date_range('2016-11-05', freq='H', periods=100, tz=tz)
+        idx = base.repeat(5)
 
-            exp_arr = np.arange(100, dtype=np.intp).repeat(5)
+        exp_arr = np.arange(100, dtype=np.intp).repeat(5)
 
-            for obj in [idx, pd.Series(idx)]:
-                arr, res = obj.factorize()
-                tm.assert_numpy_array_equal(arr, exp_arr)
-                tm.assert_index_equal(res, base)
+        for obj in [idx, pd.Series(idx)]:
+            arr, res = obj.factorize()
+            tm.assert_numpy_array_equal(arr, exp_arr)
+            tm.assert_index_equal(res, base)
 
     def test_factorize_dst(self):
         # GH 13750
diff --git a/pandas/tests/indexes/datetimes/test_indexing.py b/pandas/tests/indexes/datetimes/test_indexing.py
index 48ceefd63..a9f1a5e60 100644
--- a/pandas/tests/indexes/datetimes/test_indexing.py
+++ b/pandas/tests/indexes/datetimes/test_indexing.py
@@ -346,25 +346,25 @@ class TestDatetimeIndex(object):
                                indices, mode='clip')
 
     # TODO: This method came from test_datetime; de-dup with version above
-    def test_take2(self):
+    @pytest.mark.parametrize('tz', [None, 'US/Eastern', 'Asia/Tokyo'])
+    def test_take2(self, tz):
         dates = [datetime(2010, 1, 1, 14), datetime(2010, 1, 1, 15),
                  datetime(2010, 1, 1, 17), datetime(2010, 1, 1, 21)]
 
-        for tz in [None, 'US/Eastern', 'Asia/Tokyo']:
-            idx = DatetimeIndex(start='2010-01-01 09:00',
-                                end='2010-02-01 09:00', freq='H', tz=tz,
-                                name='idx')
-            expected = DatetimeIndex(dates, freq=None, name='idx', tz=tz)
+        idx = DatetimeIndex(start='2010-01-01 09:00',
+                            end='2010-02-01 09:00', freq='H', tz=tz,
+                            name='idx')
+        expected = DatetimeIndex(dates, freq=None, name='idx', tz=tz)
 
-            taken1 = idx.take([5, 6, 8, 12])
-            taken2 = idx[[5, 6, 8, 12]]
+        taken1 = idx.take([5, 6, 8, 12])
+        taken2 = idx[[5, 6, 8, 12]]
 
-            for taken in [taken1, taken2]:
-                tm.assert_index_equal(taken, expected)
-                assert isinstance(taken, DatetimeIndex)
-                assert taken.freq is None
-                assert taken.tz == expected.tz
-                assert taken.name == expected.name
+        for taken in [taken1, taken2]:
+            tm.assert_index_equal(taken, expected)
+            assert isinstance(taken, DatetimeIndex)
+            assert taken.freq is None
+            assert taken.tz == expected.tz
+            assert taken.name == expected.name
 
     def test_take_fill_value(self):
         # GH 12631
diff --git a/pandas/tests/indexes/datetimes/test_missing.py b/pandas/tests/indexes/datetimes/test_missing.py
index adc0b7b3d..c8d47caa7 100644
--- a/pandas/tests/indexes/datetimes/test_missing.py
+++ b/pandas/tests/indexes/datetimes/test_missing.py
@@ -1,50 +1,52 @@
+import pytest
+
 import pandas as pd
 import pandas.util.testing as tm
 
 
 class TestDatetimeIndex(object):
 
-    def test_fillna_datetime64(self):
+    @pytest.mark.parametrize('tz', ['US/Eastern', 'Asia/Tokyo'])
+    def test_fillna_datetime64(self, tz):
         # GH 11343
-        for tz in ['US/Eastern', 'Asia/Tokyo']:
-            idx = pd.DatetimeIndex(['2011-01-01 09:00', pd.NaT,
-                                    '2011-01-01 11:00'])
-
-            exp = pd.DatetimeIndex(['2011-01-01 09:00', '2011-01-01 10:00',
-                                    '2011-01-01 11:00'])
-            tm.assert_index_equal(
-                idx.fillna(pd.Timestamp('2011-01-01 10:00')), exp)
-
-            # tz mismatch
-            exp = pd.Index([pd.Timestamp('2011-01-01 09:00'),
-                            pd.Timestamp('2011-01-01 10:00', tz=tz),
-                            pd.Timestamp('2011-01-01 11:00')], dtype=object)
-            tm.assert_index_equal(
-                idx.fillna(pd.Timestamp('2011-01-01 10:00', tz=tz)), exp)
-
-            # object
-            exp = pd.Index([pd.Timestamp('2011-01-01 09:00'), 'x',
-                            pd.Timestamp('2011-01-01 11:00')], dtype=object)
-            tm.assert_index_equal(idx.fillna('x'), exp)
-
-            idx = pd.DatetimeIndex(['2011-01-01 09:00', pd.NaT,
-                                    '2011-01-01 11:00'], tz=tz)
-
-            exp = pd.DatetimeIndex(['2011-01-01 09:00', '2011-01-01 10:00',
-                                    '2011-01-01 11:00'], tz=tz)
-            tm.assert_index_equal(
-                idx.fillna(pd.Timestamp('2011-01-01 10:00', tz=tz)), exp)
-
-            exp = pd.Index([pd.Timestamp('2011-01-01 09:00', tz=tz),
-                            pd.Timestamp('2011-01-01 10:00'),
-                            pd.Timestamp('2011-01-01 11:00', tz=tz)],
-                           dtype=object)
-            tm.assert_index_equal(
-                idx.fillna(pd.Timestamp('2011-01-01 10:00')), exp)
-
-            # object
-            exp = pd.Index([pd.Timestamp('2011-01-01 09:00', tz=tz),
-                            'x',
-                            pd.Timestamp('2011-01-01 11:00', tz=tz)],
-                           dtype=object)
-            tm.assert_index_equal(idx.fillna('x'), exp)
+        idx = pd.DatetimeIndex(['2011-01-01 09:00', pd.NaT,
+                                '2011-01-01 11:00'])
+
+        exp = pd.DatetimeIndex(['2011-01-01 09:00', '2011-01-01 10:00',
+                                '2011-01-01 11:00'])
+        tm.assert_index_equal(
+            idx.fillna(pd.Timestamp('2011-01-01 10:00')), exp)
+
+        # tz mismatch
+        exp = pd.Index([pd.Timestamp('2011-01-01 09:00'),
+                        pd.Timestamp('2011-01-01 10:00', tz=tz),
+                        pd.Timestamp('2011-01-01 11:00')], dtype=object)
+        tm.assert_index_equal(
+            idx.fillna(pd.Timestamp('2011-01-01 10:00', tz=tz)), exp)
+
+        # object
+        exp = pd.Index([pd.Timestamp('2011-01-01 09:00'), 'x',
+                        pd.Timestamp('2011-01-01 11:00')], dtype=object)
+        tm.assert_index_equal(idx.fillna('x'), exp)
+
+        idx = pd.DatetimeIndex(['2011-01-01 09:00', pd.NaT,
+                                '2011-01-01 11:00'], tz=tz)
+
+        exp = pd.DatetimeIndex(['2011-01-01 09:00', '2011-01-01 10:00',
+                                '2011-01-01 11:00'], tz=tz)
+        tm.assert_index_equal(
+            idx.fillna(pd.Timestamp('2011-01-01 10:00', tz=tz)), exp)
+
+        exp = pd.Index([pd.Timestamp('2011-01-01 09:00', tz=tz),
+                        pd.Timestamp('2011-01-01 10:00'),
+                        pd.Timestamp('2011-01-01 11:00', tz=tz)],
+                       dtype=object)
+        tm.assert_index_equal(
+            idx.fillna(pd.Timestamp('2011-01-01 10:00')), exp)
+
+        # object
+        exp = pd.Index([pd.Timestamp('2011-01-01 09:00', tz=tz),
+                        'x',
+                        pd.Timestamp('2011-01-01 11:00', tz=tz)],
+                       dtype=object)
+        tm.assert_index_equal(idx.fillna('x'), exp)
diff --git a/pandas/tests/indexes/datetimes/test_ops.py b/pandas/tests/indexes/datetimes/test_ops.py
index b42cd4548..ed7e42592 100644
--- a/pandas/tests/indexes/datetimes/test_ops.py
+++ b/pandas/tests/indexes/datetimes/test_ops.py
@@ -96,111 +96,111 @@ class TestDatetimeIndexOps(Ops):
             tm.assert_raises_regex(
                 ValueError, errmsg, np.argmax, dr, out=0)
 
-    def test_repeat_range(self):
+    @pytest.mark.parametrize('tz', tz)
+    def test_repeat_range(self, tz):
         rng = date_range('1/1/2000', '1/1/2001')
 
         result = rng.repeat(5)
         assert result.freq is None
         assert len(result) == 5 * len(rng)
 
-        for tz in self.tz:
-            index = pd.date_range('2001-01-01', periods=2, freq='D', tz=tz)
-            exp = pd.DatetimeIndex(['2001-01-01', '2001-01-01',
-                                    '2001-01-02', '2001-01-02'], tz=tz)
-            for res in [index.repeat(2), np.repeat(index, 2)]:
-                tm.assert_index_equal(res, exp)
-                assert res.freq is None
-
-            index = pd.date_range('2001-01-01', periods=2, freq='2D', tz=tz)
-            exp = pd.DatetimeIndex(['2001-01-01', '2001-01-01',
-                                    '2001-01-03', '2001-01-03'], tz=tz)
-            for res in [index.repeat(2), np.repeat(index, 2)]:
-                tm.assert_index_equal(res, exp)
-                assert res.freq is None
-
-            index = pd.DatetimeIndex(['2001-01-01', 'NaT', '2003-01-01'],
-                                     tz=tz)
-            exp = pd.DatetimeIndex(['2001-01-01', '2001-01-01', '2001-01-01',
-                                    'NaT', 'NaT', 'NaT',
-                                    '2003-01-01', '2003-01-01', '2003-01-01'],
-                                   tz=tz)
-            for res in [index.repeat(3), np.repeat(index, 3)]:
-                tm.assert_index_equal(res, exp)
-                assert res.freq is None
-
-    def test_repeat(self):
+        index = pd.date_range('2001-01-01', periods=2, freq='D', tz=tz)
+        exp = pd.DatetimeIndex(['2001-01-01', '2001-01-01',
+                                '2001-01-02', '2001-01-02'], tz=tz)
+        for res in [index.repeat(2), np.repeat(index, 2)]:
+            tm.assert_index_equal(res, exp)
+            assert res.freq is None
+
+        index = pd.date_range('2001-01-01', periods=2, freq='2D', tz=tz)
+        exp = pd.DatetimeIndex(['2001-01-01', '2001-01-01',
+                                '2001-01-03', '2001-01-03'], tz=tz)
+        for res in [index.repeat(2), np.repeat(index, 2)]:
+            tm.assert_index_equal(res, exp)
+            assert res.freq is None
+
+        index = pd.DatetimeIndex(['2001-01-01', 'NaT', '2003-01-01'],
+                                 tz=tz)
+        exp = pd.DatetimeIndex(['2001-01-01', '2001-01-01', '2001-01-01',
+                                'NaT', 'NaT', 'NaT',
+                                '2003-01-01', '2003-01-01', '2003-01-01'],
+                               tz=tz)
+        for res in [index.repeat(3), np.repeat(index, 3)]:
+            tm.assert_index_equal(res, exp)
+            assert res.freq is None
+
+    @pytest.mark.parametrize('tz', tz)
+    def test_repeat(self, tz):
         reps = 2
         msg = "the 'axis' parameter is not supported"
 
-        for tz in self.tz:
-            rng = pd.date_range(start='2016-01-01', periods=2,
-                                freq='30Min', tz=tz)
-
-            expected_rng = DatetimeIndex([
-                Timestamp('2016-01-01 00:00:00', tz=tz, freq='30T'),
-                Timestamp('2016-01-01 00:00:00', tz=tz, freq='30T'),
-                Timestamp('2016-01-01 00:30:00', tz=tz, freq='30T'),
-                Timestamp('2016-01-01 00:30:00', tz=tz, freq='30T'),
-            ])
-
-            res = rng.repeat(reps)
-            tm.assert_index_equal(res, expected_rng)
-            assert res.freq is None
+        rng = pd.date_range(start='2016-01-01', periods=2,
+                            freq='30Min', tz=tz)
 
-            tm.assert_index_equal(np.repeat(rng, reps), expected_rng)
-            tm.assert_raises_regex(ValueError, msg, np.repeat,
-                                   rng, reps, axis=1)
+        expected_rng = DatetimeIndex([
+            Timestamp('2016-01-01 00:00:00', tz=tz, freq='30T'),
+            Timestamp('2016-01-01 00:00:00', tz=tz, freq='30T'),
+            Timestamp('2016-01-01 00:30:00', tz=tz, freq='30T'),
+            Timestamp('2016-01-01 00:30:00', tz=tz, freq='30T'),
+        ])
 
-    def test_resolution(self):
+        res = rng.repeat(reps)
+        tm.assert_index_equal(res, expected_rng)
+        assert res.freq is None
+
+        tm.assert_index_equal(np.repeat(rng, reps), expected_rng)
+        tm.assert_raises_regex(ValueError, msg, np.repeat,
+                               rng, reps, axis=1)
+
+    @pytest.mark.parametrize('tz', tz)
+    def test_resolution(self, tz):
         for freq, expected in zip(['A', 'Q', 'M', 'D', 'H', 'T',
                                    'S', 'L', 'U'],
                                   ['day', 'day', 'day', 'day', 'hour',
                                    'minute', 'second', 'millisecond',
                                    'microsecond']):
-            for tz in self.tz:
-                idx = pd.date_range(start='2013-04-01', periods=30, freq=freq,
-                                    tz=tz)
-                assert idx.resolution == expected
+            idx = pd.date_range(start='2013-04-01', periods=30, freq=freq,
+                                tz=tz)
+            assert idx.resolution == expected
 
-    def test_value_counts_unique(self):
+    @pytest.mark.parametrize('tz', tz)
+    def test_value_counts_unique(self, tz):
         # GH 7735
-        for tz in self.tz:
-            idx = pd.date_range('2011-01-01 09:00', freq='H', periods=10)
-            # create repeated values, 'n'th element is repeated by n+1 times
-            idx = DatetimeIndex(np.repeat(idx.values, range(1, len(idx) + 1)),
-                                tz=tz)
+        idx = pd.date_range('2011-01-01 09:00', freq='H', periods=10)
+        # create repeated values, 'n'th element is repeated by n+1 times
+        idx = DatetimeIndex(np.repeat(idx.values, range(1, len(idx) + 1)),
+                            tz=tz)
 
-            exp_idx = pd.date_range('2011-01-01 18:00', freq='-1H', periods=10,
-                                    tz=tz)
-            expected = Series(range(10, 0, -1), index=exp_idx, dtype='int64')
+        exp_idx = pd.date_range('2011-01-01 18:00', freq='-1H', periods=10,
+                                tz=tz)
+        expected = Series(range(10, 0, -1), index=exp_idx, dtype='int64')
 
-            for obj in [idx, Series(idx)]:
-                tm.assert_series_equal(obj.value_counts(), expected)
+        for obj in [idx, Series(idx)]:
+            tm.assert_series_equal(obj.value_counts(), expected)
 
-            expected = pd.date_range('2011-01-01 09:00', freq='H', periods=10,
-                                     tz=tz)
-            tm.assert_index_equal(idx.unique(), expected)
+        expected = pd.date_range('2011-01-01 09:00', freq='H', periods=10,
+                                 tz=tz)
+        tm.assert_index_equal(idx.unique(), expected)
 
-            idx = DatetimeIndex(['2013-01-01 09:00', '2013-01-01 09:00',
-                                 '2013-01-01 09:00', '2013-01-01 08:00',
-                                 '2013-01-01 08:00', pd.NaT], tz=tz)
+        idx = DatetimeIndex(['2013-01-01 09:00', '2013-01-01 09:00',
+                             '2013-01-01 09:00', '2013-01-01 08:00',
+                             '2013-01-01 08:00', pd.NaT], tz=tz)
 
-            exp_idx = DatetimeIndex(['2013-01-01 09:00', '2013-01-01 08:00'],
-                                    tz=tz)
-            expected = Series([3, 2], index=exp_idx)
+        exp_idx = DatetimeIndex(['2013-01-01 09:00', '2013-01-01 08:00'],
+                                tz=tz)
+        expected = Series([3, 2], index=exp_idx)
 
-            for obj in [idx, Series(idx)]:
-                tm.assert_series_equal(obj.value_counts(), expected)
+        for obj in [idx, Series(idx)]:
+            tm.assert_series_equal(obj.value_counts(), expected)
 
-            exp_idx = DatetimeIndex(['2013-01-01 09:00', '2013-01-01 08:00',
-                                     pd.NaT], tz=tz)
-            expected = Series([3, 2, 1], index=exp_idx)
+        exp_idx = DatetimeIndex(['2013-01-01 09:00', '2013-01-01 08:00',
+                                 pd.NaT], tz=tz)
+        expected = Series([3, 2, 1], index=exp_idx)
 
-            for obj in [idx, Series(idx)]:
-                tm.assert_series_equal(obj.value_counts(dropna=False),
-                                       expected)
+        for obj in [idx, Series(idx)]:
+            tm.assert_series_equal(obj.value_counts(dropna=False),
+                                   expected)
 
-            tm.assert_index_equal(idx.unique(), exp_idx)
+        tm.assert_index_equal(idx.unique(), exp_idx)
 
     def test_nonunique_contains(self):
         # GH 9512
@@ -324,15 +324,16 @@ class TestDatetimeIndexOps(Ops):
         res = Series(idx).drop_duplicates(keep=False)
         tm.assert_series_equal(res, Series(base[5:], index=np.arange(5, 31)))
 
-    def test_infer_freq(self):
+    @pytest.mark.parametrize('freq', [
+        'A', '2A', '-2A', 'Q', '-1Q', 'M', '-1M', 'D', '3D',
+        '-3D', 'W', '-1W', 'H', '2H', '-2H', 'T', '2T', 'S',
+        '-3S'])
+    def test_infer_freq(self, freq):
         # GH 11018
-        for freq in ['A', '2A', '-2A', 'Q', '-1Q', 'M', '-1M', 'D', '3D',
-                     '-3D', 'W', '-1W', 'H', '2H', '-2H', 'T', '2T', 'S',
-                     '-3S']:
-            idx = pd.date_range('2011-01-01 09:00:00', freq=freq, periods=10)
-            result = pd.DatetimeIndex(idx.asi8, freq='infer')
-            tm.assert_index_equal(idx, result)
-            assert result.freq == freq
+        idx = pd.date_range('2011-01-01 09:00:00', freq=freq, periods=10)
+        result = pd.DatetimeIndex(idx.asi8, freq='infer')
+        tm.assert_index_equal(idx, result)
+        assert result.freq == freq
 
     def test_nat_new(self):
         idx = pd.date_range('2011-01-01', freq='D', periods=5, name='x')
@@ -344,57 +345,57 @@ class TestDatetimeIndexOps(Ops):
         exp = np.array([tslib.iNaT] * 5, dtype=np.int64)
         tm.assert_numpy_array_equal(result, exp)
 
-    def test_nat(self):
+    @pytest.mark.parametrize('tz', [None, 'US/Eastern', 'UTC'])
+    def test_nat(self, tz):
         assert pd.DatetimeIndex._na_value is pd.NaT
         assert pd.DatetimeIndex([])._na_value is pd.NaT
 
-        for tz in [None, 'US/Eastern', 'UTC']:
-            idx = pd.DatetimeIndex(['2011-01-01', '2011-01-02'], tz=tz)
-            assert idx._can_hold_na
+        idx = pd.DatetimeIndex(['2011-01-01', '2011-01-02'], tz=tz)
+        assert idx._can_hold_na
 
-            tm.assert_numpy_array_equal(idx._isnan, np.array([False, False]))
-            assert not idx.hasnans
-            tm.assert_numpy_array_equal(idx._nan_idxs,
-                                        np.array([], dtype=np.intp))
+        tm.assert_numpy_array_equal(idx._isnan, np.array([False, False]))
+        assert not idx.hasnans
+        tm.assert_numpy_array_equal(idx._nan_idxs,
+                                    np.array([], dtype=np.intp))
 
-            idx = pd.DatetimeIndex(['2011-01-01', 'NaT'], tz=tz)
-            assert idx._can_hold_na
+        idx = pd.DatetimeIndex(['2011-01-01', 'NaT'], tz=tz)
+        assert idx._can_hold_na
 
-            tm.assert_numpy_array_equal(idx._isnan, np.array([False, True]))
-            assert idx.hasnans
-            tm.assert_numpy_array_equal(idx._nan_idxs,
-                                        np.array([1], dtype=np.intp))
+        tm.assert_numpy_array_equal(idx._isnan, np.array([False, True]))
+        assert idx.hasnans
+        tm.assert_numpy_array_equal(idx._nan_idxs,
+                                    np.array([1], dtype=np.intp))
 
-    def test_equals(self):
+    @pytest.mark.parametrize('tz', [None, 'UTC', 'US/Eastern', 'Asia/Tokyo'])
+    def test_equals(self, tz):
         # GH 13107
-        for tz in [None, 'UTC', 'US/Eastern', 'Asia/Tokyo']:
-            idx = pd.DatetimeIndex(['2011-01-01', '2011-01-02', 'NaT'])
-            assert idx.equals(idx)
-            assert idx.equals(idx.copy())
-            assert idx.equals(idx.astype(object))
-            assert idx.astype(object).equals(idx)
-            assert idx.astype(object).equals(idx.astype(object))
-            assert not idx.equals(list(idx))
-            assert not idx.equals(pd.Series(idx))
-
-            idx2 = pd.DatetimeIndex(['2011-01-01', '2011-01-02', 'NaT'],
-                                    tz='US/Pacific')
-            assert not idx.equals(idx2)
-            assert not idx.equals(idx2.copy())
-            assert not idx.equals(idx2.astype(object))
-            assert not idx.astype(object).equals(idx2)
-            assert not idx.equals(list(idx2))
-            assert not idx.equals(pd.Series(idx2))
-
-            # same internal, different tz
-            idx3 = pd.DatetimeIndex._simple_new(idx.asi8, tz='US/Pacific')
-            tm.assert_numpy_array_equal(idx.asi8, idx3.asi8)
-            assert not idx.equals(idx3)
-            assert not idx.equals(idx3.copy())
-            assert not idx.equals(idx3.astype(object))
-            assert not idx.astype(object).equals(idx3)
-            assert not idx.equals(list(idx3))
-            assert not idx.equals(pd.Series(idx3))
+        idx = pd.DatetimeIndex(['2011-01-01', '2011-01-02', 'NaT'])
+        assert idx.equals(idx)
+        assert idx.equals(idx.copy())
+        assert idx.equals(idx.astype(object))
+        assert idx.astype(object).equals(idx)
+        assert idx.astype(object).equals(idx.astype(object))
+        assert not idx.equals(list(idx))
+        assert not idx.equals(pd.Series(idx))
+
+        idx2 = pd.DatetimeIndex(['2011-01-01', '2011-01-02', 'NaT'],
+                                tz='US/Pacific')
+        assert not idx.equals(idx2)
+        assert not idx.equals(idx2.copy())
+        assert not idx.equals(idx2.astype(object))
+        assert not idx.astype(object).equals(idx2)
+        assert not idx.equals(list(idx2))
+        assert not idx.equals(pd.Series(idx2))
+
+        # same internal, different tz
+        idx3 = pd.DatetimeIndex._simple_new(idx.asi8, tz='US/Pacific')
+        tm.assert_numpy_array_equal(idx.asi8, idx3.asi8)
+        assert not idx.equals(idx3)
+        assert not idx.equals(idx3.copy())
+        assert not idx.equals(idx3.astype(object))
+        assert not idx.astype(object).equals(idx3)
+        assert not idx.equals(list(idx3))
+        assert not idx.equals(pd.Series(idx3))
 
 
 class TestBusinessDatetimeIndex(object):
diff --git a/pandas/tests/indexes/datetimes/test_scalar_compat.py b/pandas/tests/indexes/datetimes/test_scalar_compat.py
index 83e7a0cd6..6f0756949 100644
--- a/pandas/tests/indexes/datetimes/test_scalar_compat.py
+++ b/pandas/tests/indexes/datetimes/test_scalar_compat.py
@@ -38,18 +38,21 @@ class TestDatetimeIndexOps(object):
         pytest.raises(ValueError, DatetimeIndex, ['1400-01-01'])
         pytest.raises(ValueError, DatetimeIndex, [datetime(1400, 1, 1)])
 
-    def test_dti_timestamp_fields(self):
+    @pytest.mark.parametrize('field', [
+        'dayofweek', 'dayofyear', 'week', 'weekofyear', 'quarter',
+        'days_in_month', 'is_month_start', 'is_month_end',
+        'is_quarter_start', 'is_quarter_end', 'is_year_start',
+        'is_year_end', 'weekday_name'])
+    def test_dti_timestamp_fields(self, field):
         # extra fields from DatetimeIndex like quarter and week
         idx = tm.makeDateIndex(100)
+        expected = getattr(idx, field)[-1]
+        result = getattr(Timestamp(idx[-1]), field)
+        assert result == expected
 
-        fields = ['dayofweek', 'dayofyear', 'week', 'weekofyear', 'quarter',
-                  'days_in_month', 'is_month_start', 'is_month_end',
-                  'is_quarter_start', 'is_quarter_end', 'is_year_start',
-                  'is_year_end', 'weekday_name']
-        for f in fields:
-            expected = getattr(idx, f)[-1]
-            result = getattr(Timestamp(idx[-1]), f)
-            assert result == expected
+    def test_dti_timestamp_freq_fields(self):
+        # extra fields from DatetimeIndex like quarter and week
+        idx = tm.makeDateIndex(100)
 
         assert idx.freq == Timestamp(idx[-1], idx.freq).freq
         assert idx.freqstr == Timestamp(idx[-1], idx.freq).freqstr
diff --git a/pandas/tests/indexes/datetimes/test_timezones.py b/pandas/tests/indexes/datetimes/test_timezones.py
index 62854676d..217610b76 100644
--- a/pandas/tests/indexes/datetimes/test_timezones.py
+++ b/pandas/tests/indexes/datetimes/test_timezones.py
@@ -170,17 +170,17 @@ class TestDatetimeIndexTimezones(object):
         expected = Index([9, 9, 9])
         tm.assert_index_equal(ut.hour, expected)
 
-    def test_dti_tz_convert_trans_pos_plus_1__bug(self):
+    @pytest.mark.parametrize('freq, n', [('H', 1), ('T', 60), ('S', 3600)])
+    def test_dti_tz_convert_trans_pos_plus_1__bug(self, freq, n):
         # Regression test for tslib.tz_convert(vals, tz1, tz2).
         # See https://github.com/pandas-dev/pandas/issues/4496 for details.
-        for freq, n in [('H', 1), ('T', 60), ('S', 3600)]:
-            idx = date_range(datetime(2011, 3, 26, 23),
-                             datetime(2011, 3, 27, 1), freq=freq)
-            idx = idx.tz_localize('UTC')
-            idx = idx.tz_convert('Europe/Moscow')
+        idx = date_range(datetime(2011, 3, 26, 23),
+                         datetime(2011, 3, 27, 1), freq=freq)
+        idx = idx.tz_localize('UTC')
+        idx = idx.tz_convert('Europe/Moscow')
 
-            expected = np.repeat(np.array([3, 4, 5]), np.array([n, n, 1]))
-            tm.assert_index_equal(idx.hour, Index(expected))
+        expected = np.repeat(np.array([3, 4, 5]), np.array([n, n, 1]))
+        tm.assert_index_equal(idx.hour, Index(expected))
 
     def test_dti_tz_convert_dst(self):
         for freq, n in [('H', 1), ('T', 60), ('S', 3600)]:
@@ -700,20 +700,20 @@ class TestDatetimeIndexTimezones(object):
     # -------------------------------------------------------------
     # Unsorted
 
-    def test_join_utc_convert(self):
+    @pytest.mark.parametrize('how', ['inner', 'outer', 'left', 'right'])
+    def test_join_utc_convert(self, how):
         rng = date_range('1/1/2011', periods=100, freq='H', tz='utc')
 
         left = rng.tz_convert('US/Eastern')
         right = rng.tz_convert('Europe/Berlin')
 
-        for how in ['inner', 'outer', 'left', 'right']:
-            result = left.join(left[:-5], how=how)
-            assert isinstance(result, DatetimeIndex)
-            assert result.tz == left.tz
+        result = left.join(left[:-5], how=how)
+        assert isinstance(result, DatetimeIndex)
+        assert result.tz == left.tz
 
-            result = left.join(right[:-5], how=how)
-            assert isinstance(result, DatetimeIndex)
-            assert result.tz.zone == 'UTC'
+        result = left.join(right[:-5], how=how)
+        assert isinstance(result, DatetimeIndex)
+        assert result.tz.zone == 'UTC'
 
     def test_dti_drop_dont_lose_tz(self):
         # GH#2621
diff --git a/pandas/tests/indexes/datetimes/test_tools.py b/pandas/tests/indexes/datetimes/test_tools.py
index b59269335..fbf0977a0 100644
--- a/pandas/tests/indexes/datetimes/test_tools.py
+++ b/pandas/tests/indexes/datetimes/test_tools.py
@@ -1013,18 +1013,20 @@ class TestToDatetimeMisc(object):
         assert_series_equal(dresult, expected, check_names=False)
         assert dresult.name == 'foo'
 
+    @pytest.mark.parametrize('dtype', [
+        'datetime64[h]', 'datetime64[m]',
+        'datetime64[s]', 'datetime64[ms]',
+        'datetime64[us]', 'datetime64[ns]'])
     @pytest.mark.parametrize('cache', [True, False])
-    def test_dti_constructor_numpy_timeunits(self, cache):
+    def test_dti_constructor_numpy_timeunits(self, cache, dtype):
         # GH 9114
         base = pd.to_datetime(['2000-01-01T00:00', '2000-01-02T00:00', 'NaT'],
                               cache=cache)
 
-        for dtype in ['datetime64[h]', 'datetime64[m]', 'datetime64[s]',
-                      'datetime64[ms]', 'datetime64[us]', 'datetime64[ns]']:
-            values = base.values.astype(dtype)
+        values = base.values.astype(dtype)
 
-            tm.assert_index_equal(DatetimeIndex(values), base)
-            tm.assert_index_equal(to_datetime(values, cache=cache), base)
+        tm.assert_index_equal(DatetimeIndex(values), base)
+        tm.assert_index_equal(to_datetime(values, cache=cache), base)
 
     @pytest.mark.parametrize('cache', [True, False])
     def test_dayfirst(self, cache):
diff --git a/pandas/tests/indexes/period/test_arithmetic.py b/pandas/tests/indexes/period/test_arithmetic.py
index 5f8f9533e..e16d34654 100644
--- a/pandas/tests/indexes/period/test_arithmetic.py
+++ b/pandas/tests/indexes/period/test_arithmetic.py
@@ -613,7 +613,8 @@ class TestPeriodIndexSeriesMethods(object):
         exp = pd.Index([0, -1, -2, -3], name='idx')
         tm.assert_index_equal(result, exp)
 
-    def test_pi_ops_errors(self):
+    @pytest.mark.parametrize('ng', ["str", 1.5])
+    def test_pi_ops_errors(self, ng):
         idx = PeriodIndex(['2011-01', '2011-02', '2011-03', '2011-04'],
                           freq='M', name='idx')
         ser = pd.Series(idx)
@@ -621,34 +622,33 @@ class TestPeriodIndexSeriesMethods(object):
         msg = r"unsupported operand type\(s\)"
 
         for obj in [idx, ser]:
-            for ng in ["str", 1.5]:
-                with tm.assert_raises_regex(TypeError, msg):
-                    obj + ng
+            with tm.assert_raises_regex(TypeError, msg):
+                obj + ng
 
-                with pytest.raises(TypeError):
-                    # error message differs between PY2 and 3
-                    ng + obj
+            with pytest.raises(TypeError):
+                # error message differs between PY2 and 3
+                ng + obj
+
+            with tm.assert_raises_regex(TypeError, msg):
+                obj - ng
 
-                with tm.assert_raises_regex(TypeError, msg):
-                    obj - ng
+            with pytest.raises(TypeError):
+                np.add(obj, ng)
 
+            if _np_version_under1p10:
+                assert np.add(ng, obj) is NotImplemented
+            else:
                 with pytest.raises(TypeError):
-                    np.add(obj, ng)
+                    np.add(ng, obj)
 
-                if _np_version_under1p10:
-                    assert np.add(ng, obj) is NotImplemented
-                else:
-                    with pytest.raises(TypeError):
-                        np.add(ng, obj)
+            with pytest.raises(TypeError):
+                np.subtract(obj, ng)
 
+            if _np_version_under1p10:
+                assert np.subtract(ng, obj) is NotImplemented
+            else:
                 with pytest.raises(TypeError):
-                    np.subtract(obj, ng)
-
-                if _np_version_under1p10:
-                    assert np.subtract(ng, obj) is NotImplemented
-                else:
-                    with pytest.raises(TypeError):
-                        np.subtract(ng, obj)
+                    np.subtract(ng, obj)
 
     def test_pi_ops_nat(self):
         idx = PeriodIndex(['2011-01', '2011-02', 'NaT', '2011-04'],
diff --git a/pandas/tests/indexes/period/test_asfreq.py b/pandas/tests/indexes/period/test_asfreq.py
index c8724b2a3..ea59a5706 100644
--- a/pandas/tests/indexes/period/test_asfreq.py
+++ b/pandas/tests/indexes/period/test_asfreq.py
@@ -8,9 +8,6 @@ from pandas import PeriodIndex, Series, DataFrame
 
 class TestPeriodIndex(object):
 
-    def setup_method(self, method):
-        pass
-
     def test_asfreq(self):
         pi1 = PeriodIndex(freq='A', start='1/1/2001', end='1/1/2001')
         pi2 = PeriodIndex(freq='Q', start='1/1/2001', end='1/1/2001')
@@ -85,21 +82,21 @@ class TestPeriodIndex(object):
         expected = PeriodIndex(['2011Q1', '2011Q1', 'NaT', '2011Q2'], freq='Q')
         tm.assert_index_equal(result, expected)
 
-    def test_asfreq_mult_pi(self):
+    @pytest.mark.parametrize('freq', ['D', '3D'])
+    def test_asfreq_mult_pi(self, freq):
         pi = PeriodIndex(['2001-01', '2001-02', 'NaT', '2001-03'], freq='2M')
 
-        for freq in ['D', '3D']:
-            result = pi.asfreq(freq)
-            exp = PeriodIndex(['2001-02-28', '2001-03-31', 'NaT',
-                               '2001-04-30'], freq=freq)
-            tm.assert_index_equal(result, exp)
-            assert result.freq == exp.freq
-
-            result = pi.asfreq(freq, how='S')
-            exp = PeriodIndex(['2001-01-01', '2001-02-01', 'NaT',
-                               '2001-03-01'], freq=freq)
-            tm.assert_index_equal(result, exp)
-            assert result.freq == exp.freq
+        result = pi.asfreq(freq)
+        exp = PeriodIndex(['2001-02-28', '2001-03-31', 'NaT',
+                           '2001-04-30'], freq=freq)
+        tm.assert_index_equal(result, exp)
+        assert result.freq == exp.freq
+
+        result = pi.asfreq(freq, how='S')
+        exp = PeriodIndex(['2001-01-01', '2001-02-01', 'NaT',
+                           '2001-03-01'], freq=freq)
+        tm.assert_index_equal(result, exp)
+        assert result.freq == exp.freq
 
     def test_asfreq_combined_pi(self):
         pi = pd.PeriodIndex(['2001-01-01 00:00', '2001-01-02 02:00', 'NaT'],
diff --git a/pandas/tests/indexes/period/test_construction.py b/pandas/tests/indexes/period/test_construction.py
index eca80d17b..be741592e 100644
--- a/pandas/tests/indexes/period/test_construction.py
+++ b/pandas/tests/indexes/period/test_construction.py
@@ -286,14 +286,14 @@ class TestPeriodIndex(object):
         result = idx._simple_new(idx, name='p', freq='M')
         tm.assert_index_equal(result, idx)
 
-    def test_constructor_floats(self):
-        # GH13079
-        for floats in [[1.1, 2.1], np.array([1.1, 2.1])]:
-            with pytest.raises(TypeError):
-                pd.PeriodIndex._simple_new(floats, freq='M')
+    @pytest.mark.parametrize('floats', [[1.1, 2.1], np.array([1.1, 2.1])])
+    def test_constructor_floats(self, floats):
+        # GH#13079
+        with pytest.raises(TypeError):
+            pd.PeriodIndex._simple_new(floats, freq='M')
 
-            with pytest.raises(TypeError):
-                pd.PeriodIndex(floats, freq='M')
+        with pytest.raises(TypeError):
+            pd.PeriodIndex(floats, freq='M')
 
     def test_constructor_nat(self):
         pytest.raises(ValueError, period_range, start='NaT',
@@ -343,16 +343,14 @@ class TestPeriodIndex(object):
         with tm.assert_raises_regex(ValueError, msg):
             period_range('2011-01', periods=3, freq='0M')
 
-    def test_constructor_freq_mult_dti_compat(self):
-        import itertools
-        mults = [1, 2, 3, 4, 5]
-        freqs = ['A', 'M', 'D', 'T', 'S']
-        for mult, freq in itertools.product(mults, freqs):
-            freqstr = str(mult) + freq
-            pidx = PeriodIndex(start='2014-04-01', freq=freqstr, periods=10)
-            expected = date_range(start='2014-04-01', freq=freqstr,
-                                  periods=10).to_period(freqstr)
-            tm.assert_index_equal(pidx, expected)
+    @pytest.mark.parametrize('freq', ['A', 'M', 'D', 'T', 'S'])
+    @pytest.mark.parametrize('mult', [1, 2, 3, 4, 5])
+    def test_constructor_freq_mult_dti_compat(self, mult, freq):
+        freqstr = str(mult) + freq
+        pidx = PeriodIndex(start='2014-04-01', freq=freqstr, periods=10)
+        expected = date_range(start='2014-04-01', freq=freqstr,
+                              periods=10).to_period(freqstr)
+        tm.assert_index_equal(pidx, expected)
 
     def test_constructor_freq_combined(self):
         for freq in ['1D1H', '1H1D']:
@@ -445,11 +443,12 @@ class TestPeriodIndex(object):
         with tm.assert_raises_regex(ValueError, msg):
             PeriodIndex(start=start)
 
-    def test_recreate_from_data(self):
-        for o in ['M', 'Q', 'A', 'D', 'B', 'T', 'S', 'L', 'U', 'N', 'H']:
-            org = PeriodIndex(start='2001/04/01', freq=o, periods=1)
-            idx = PeriodIndex(org.values, freq=o)
-            tm.assert_index_equal(idx, org)
+    @pytest.mark.parametrize('freq', ['M', 'Q', 'A', 'D', 'B',
+                                      'T', 'S', 'L', 'U', 'N', 'H'])
+    def test_recreate_from_data(self, freq):
+        org = PeriodIndex(start='2001/04/01', freq=freq, periods=1)
+        idx = PeriodIndex(org.values, freq=freq)
+        tm.assert_index_equal(idx, org)
 
     def test_map_with_string_constructor(self):
         raw = [2005, 2007, 2009]
diff --git a/pandas/tests/indexes/period/test_ops.py b/pandas/tests/indexes/period/test_ops.py
index 3b6641bc7..7d117b0b6 100644
--- a/pandas/tests/indexes/period/test_ops.py
+++ b/pandas/tests/indexes/period/test_ops.py
@@ -1,5 +1,6 @@
 
 import numpy as np
+import pytest
 
 import pandas as pd
 import pandas._libs.tslib as tslib
@@ -368,37 +369,37 @@ class TestPeriodIndexOps(Ops):
         tm.assert_numpy_array_equal(idx._nan_idxs,
                                     np.array([1], dtype=np.intp))
 
-    def test_equals(self):
-        # GH 13107
-        for freq in ['D', 'M']:
-            idx = pd.PeriodIndex(['2011-01-01', '2011-01-02', 'NaT'],
-                                 freq=freq)
-            assert idx.equals(idx)
-            assert idx.equals(idx.copy())
-            assert idx.equals(idx.astype(object))
-            assert idx.astype(object).equals(idx)
-            assert idx.astype(object).equals(idx.astype(object))
-            assert not idx.equals(list(idx))
-            assert not idx.equals(pd.Series(idx))
-
-            idx2 = pd.PeriodIndex(['2011-01-01', '2011-01-02', 'NaT'],
-                                  freq='H')
-            assert not idx.equals(idx2)
-            assert not idx.equals(idx2.copy())
-            assert not idx.equals(idx2.astype(object))
-            assert not idx.astype(object).equals(idx2)
-            assert not idx.equals(list(idx2))
-            assert not idx.equals(pd.Series(idx2))
-
-            # same internal, different tz
-            idx3 = pd.PeriodIndex._simple_new(idx.asi8, freq='H')
-            tm.assert_numpy_array_equal(idx.asi8, idx3.asi8)
-            assert not idx.equals(idx3)
-            assert not idx.equals(idx3.copy())
-            assert not idx.equals(idx3.astype(object))
-            assert not idx.astype(object).equals(idx3)
-            assert not idx.equals(list(idx3))
-            assert not idx.equals(pd.Series(idx3))
+    @pytest.mark.parametrize('freq', ['D', 'M'])
+    def test_equals(self, freq):
+        # GH#13107
+        idx = pd.PeriodIndex(['2011-01-01', '2011-01-02', 'NaT'],
+                             freq=freq)
+        assert idx.equals(idx)
+        assert idx.equals(idx.copy())
+        assert idx.equals(idx.astype(object))
+        assert idx.astype(object).equals(idx)
+        assert idx.astype(object).equals(idx.astype(object))
+        assert not idx.equals(list(idx))
+        assert not idx.equals(pd.Series(idx))
+
+        idx2 = pd.PeriodIndex(['2011-01-01', '2011-01-02', 'NaT'],
+                              freq='H')
+        assert not idx.equals(idx2)
+        assert not idx.equals(idx2.copy())
+        assert not idx.equals(idx2.astype(object))
+        assert not idx.astype(object).equals(idx2)
+        assert not idx.equals(list(idx2))
+        assert not idx.equals(pd.Series(idx2))
+
+        # same internal, different tz
+        idx3 = pd.PeriodIndex._simple_new(idx.asi8, freq='H')
+        tm.assert_numpy_array_equal(idx.asi8, idx3.asi8)
+        assert not idx.equals(idx3)
+        assert not idx.equals(idx3.copy())
+        assert not idx.equals(idx3.astype(object))
+        assert not idx.astype(object).equals(idx3)
+        assert not idx.equals(list(idx3))
+        assert not idx.equals(pd.Series(idx3))
 
 
 class TestPeriodIndexSeriesMethods(object):
diff --git a/pandas/tests/indexes/period/test_period.py b/pandas/tests/indexes/period/test_period.py
index 4c0c86592..dd437363c 100644
--- a/pandas/tests/indexes/period/test_period.py
+++ b/pandas/tests/indexes/period/test_period.py
@@ -27,11 +27,11 @@ class TestPeriodIndex(DatetimeLike):
     def test_pickle_compat_construction(self):
         pass
 
-    def test_pickle_round_trip(self):
-        for freq in ['D', 'M', 'A']:
-            idx = PeriodIndex(['2016-05-16', 'NaT', NaT, np.NaN], freq=freq)
-            result = tm.round_trip_pickle(idx)
-            tm.assert_index_equal(result, idx)
+    @pytest.mark.parametrize('freq', ['D', 'M', 'A'])
+    def test_pickle_round_trip(self, freq):
+        idx = PeriodIndex(['2016-05-16', 'NaT', NaT, np.NaN], freq=freq)
+        result = tm.round_trip_pickle(idx)
+        tm.assert_index_equal(result, idx)
 
     @pytest.mark.parametrize('klass', [list, tuple, np.array, Series])
     def test_where(self, klass):
diff --git a/pandas/tests/indexes/period/test_setops.py b/pandas/tests/indexes/period/test_setops.py
index 1ac05f9fa..ec0836dfa 100644
--- a/pandas/tests/indexes/period/test_setops.py
+++ b/pandas/tests/indexes/period/test_setops.py
@@ -14,24 +14,21 @@ def _permute(obj):
 
 class TestPeriodIndex(object):
 
-    def setup_method(self, method):
-        pass
-
-    def test_joins(self):
+    @pytest.mark.parametrize('kind', ['inner', 'outer', 'left', 'right'])
+    def test_joins(self, kind):
         index = period_range('1/1/2000', '1/20/2000', freq='D')
 
-        for kind in ['inner', 'outer', 'left', 'right']:
-            joined = index.join(index[:-5], how=kind)
+        joined = index.join(index[:-5], how=kind)
 
-            assert isinstance(joined, PeriodIndex)
-            assert joined.freq == index.freq
+        assert isinstance(joined, PeriodIndex)
+        assert joined.freq == index.freq
 
-    def test_join_self(self):
+    @pytest.mark.parametrize('kind', ['inner', 'outer', 'left', 'right'])
+    def test_join_self(self, kind):
         index = period_range('1/1/2000', '1/20/2000', freq='D')
 
-        for kind in ['inner', 'outer', 'left', 'right']:
-            res = index.join(index, how=kind)
-            assert index is res
+        res = index.join(index, how=kind)
+        assert index is res
 
     def test_join_does_not_recur(self):
         df = tm.makeCustomDataframe(
diff --git a/pandas/tests/indexes/period/test_tools.py b/pandas/tests/indexes/period/test_tools.py
index 97500f2f5..38c6f257b 100644
--- a/pandas/tests/indexes/period/test_tools.py
+++ b/pandas/tests/indexes/period/test_tools.py
@@ -1,5 +1,6 @@
 import numpy as np
 from datetime import datetime, timedelta
+import pytest
 
 import pandas as pd
 import pandas.util.testing as tm
@@ -29,32 +30,10 @@ class TestPeriodRepresentation(object):
     def test_monthly(self):
         self._check_freq('M', '1970-01')
 
-    def test_weekly(self):
-        self._check_freq('W-THU', '1970-01-01')
-
-    def test_daily(self):
-        self._check_freq('D', '1970-01-01')
-
-    def test_business_daily(self):
-        self._check_freq('B', '1970-01-01')
-
-    def test_hourly(self):
-        self._check_freq('H', '1970-01-01')
-
-    def test_minutely(self):
-        self._check_freq('T', '1970-01-01')
-
-    def test_secondly(self):
-        self._check_freq('S', '1970-01-01')
-
-    def test_millisecondly(self):
-        self._check_freq('L', '1970-01-01')
-
-    def test_microsecondly(self):
-        self._check_freq('U', '1970-01-01')
-
-    def test_nanosecondly(self):
-        self._check_freq('N', '1970-01-01')
+    @pytest.mark.parametrize('freq', ['W-THU', 'D', 'B', 'H', 'T',
+                                      'S', 'L', 'U', 'N'])
+    def test_freq(self, freq):
+        self._check_freq(freq, '1970-01-01')
 
     def test_negone_ordinals(self):
         freqs = ['A', 'M', 'Q', 'D', 'H', 'T', 'S']
@@ -75,19 +54,6 @@ class TestPeriodRepresentation(object):
 
 
 class TestPeriodIndex(object):
-
-    def setup_method(self, method):
-        pass
-
-    def test_tolist(self):
-        index = PeriodIndex(freq='A', start='1/1/2001', end='12/1/2009')
-        rs = index.tolist()
-        for x in rs:
-            assert isinstance(x, Period)
-
-        recon = PeriodIndex(rs)
-        tm.assert_index_equal(index, recon)
-
     def test_to_timestamp(self):
         index = PeriodIndex(freq='A', start='1/1/2001', end='12/1/2009')
         series = Series(1, index=index, name='foo')
@@ -129,24 +95,6 @@ class TestPeriodIndex(object):
         tm.assert_index_equal(result.index, exp_index)
         assert result.name == 'foo'
 
-    def test_to_timestamp_quarterly_bug(self):
-        years = np.arange(1960, 2000).repeat(4)
-        quarters = np.tile(lrange(1, 5), 40)
-
-        pindex = PeriodIndex(year=years, quarter=quarters)
-
-        stamps = pindex.to_timestamp('D', 'end')
-        expected = DatetimeIndex([x.to_timestamp('D', 'end') for x in pindex])
-        tm.assert_index_equal(stamps, expected)
-
-    def test_to_timestamp_preserve_name(self):
-        index = PeriodIndex(freq='A', start='1/1/2001', end='12/1/2009',
-                            name='foo')
-        assert index.name == 'foo'
-
-        conv = index.to_timestamp('D')
-        assert conv.name == 'foo'
-
     def test_to_timestamp_repr_is_code(self):
         zs = [Timestamp('99-04-17 00:00:00', tz='UTC'),
               Timestamp('2001-04-17 00:00:00', tz='UTC'),
@@ -155,57 +103,6 @@ class TestPeriodIndex(object):
         for z in zs:
             assert eval(repr(z)) == z
 
-    def test_to_timestamp_pi_nat(self):
-        # GH 7228
-        index = PeriodIndex(['NaT', '2011-01', '2011-02'], freq='M',
-                            name='idx')
-
-        result = index.to_timestamp('D')
-        expected = DatetimeIndex([pd.NaT, datetime(2011, 1, 1),
-                                  datetime(2011, 2, 1)], name='idx')
-        tm.assert_index_equal(result, expected)
-        assert result.name == 'idx'
-
-        result2 = result.to_period(freq='M')
-        tm.assert_index_equal(result2, index)
-        assert result2.name == 'idx'
-
-        result3 = result.to_period(freq='3M')
-        exp = PeriodIndex(['NaT', '2011-01', '2011-02'], freq='3M', name='idx')
-        tm.assert_index_equal(result3, exp)
-        assert result3.freqstr == '3M'
-
-        msg = ('Frequency must be positive, because it'
-               ' represents span: -2A')
-        with tm.assert_raises_regex(ValueError, msg):
-            result.to_period(freq='-2A')
-
-    def test_to_timestamp_pi_mult(self):
-        idx = PeriodIndex(['2011-01', 'NaT', '2011-02'], freq='2M', name='idx')
-        result = idx.to_timestamp()
-        expected = DatetimeIndex(
-            ['2011-01-01', 'NaT', '2011-02-01'], name='idx')
-        tm.assert_index_equal(result, expected)
-        result = idx.to_timestamp(how='E')
-        expected = DatetimeIndex(
-            ['2011-02-28', 'NaT', '2011-03-31'], name='idx')
-        tm.assert_index_equal(result, expected)
-
-    def test_to_timestamp_pi_combined(self):
-        idx = PeriodIndex(start='2011', periods=2, freq='1D1H', name='idx')
-        result = idx.to_timestamp()
-        expected = DatetimeIndex(
-            ['2011-01-01 00:00', '2011-01-02 01:00'], name='idx')
-        tm.assert_index_equal(result, expected)
-        result = idx.to_timestamp(how='E')
-        expected = DatetimeIndex(
-            ['2011-01-02 00:59:59', '2011-01-03 01:59:59'], name='idx')
-        tm.assert_index_equal(result, expected)
-        result = idx.to_timestamp(how='E', freq='H')
-        expected = DatetimeIndex(
-            ['2011-01-02 00:00', '2011-01-03 01:00'], name='idx')
-        tm.assert_index_equal(result, expected)
-
     def test_to_timestamp_to_period_astype(self):
         idx = DatetimeIndex([pd.NaT, '2011-01-01', '2011-02-01'], name='idx')
 
@@ -238,47 +135,26 @@ class TestPeriodIndex(object):
         tm.assert_index_equal(pi3, period_range('1/1/2005', '11/1/2005',
                                                 freq='M').asfreq('3D'))
 
-    def test_period_astype_to_timestamp(self):
-        pi = pd.PeriodIndex(['2011-01', '2011-02', '2011-03'], freq='M')
-
-        exp = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'])
-        tm.assert_index_equal(pi.astype('datetime64[ns]'), exp)
-
-        exp = pd.DatetimeIndex(['2011-01-31', '2011-02-28', '2011-03-31'])
-        tm.assert_index_equal(pi.astype('datetime64[ns]', how='end'), exp)
-
-        exp = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
-                               tz='US/Eastern')
-        res = pi.astype('datetime64[ns, US/Eastern]')
-        tm.assert_index_equal(pi.astype('datetime64[ns, US/Eastern]'), exp)
-
-        exp = pd.DatetimeIndex(['2011-01-31', '2011-02-28', '2011-03-31'],
-                               tz='US/Eastern')
-        res = pi.astype('datetime64[ns, US/Eastern]', how='end')
-        tm.assert_index_equal(res, exp)
-
-    def test_to_period_quarterly(self):
+    @pytest.mark.parametrize('month', MONTHS)
+    def test_to_period_quarterly(self, month):
         # make sure we can make the round trip
-        for month in MONTHS:
-            freq = 'Q-%s' % month
-            rng = period_range('1989Q3', '1991Q3', freq=freq)
-            stamps = rng.to_timestamp()
-            result = stamps.to_period(freq)
-            tm.assert_index_equal(rng, result)
-
-    def test_to_period_quarterlyish(self):
-        offsets = ['BQ', 'QS', 'BQS']
-        for off in offsets:
-            rng = date_range('01-Jan-2012', periods=8, freq=off)
-            prng = rng.to_period()
-            assert prng.freq == 'Q-DEC'
+        freq = 'Q-%s' % month
+        rng = period_range('1989Q3', '1991Q3', freq=freq)
+        stamps = rng.to_timestamp()
+        result = stamps.to_period(freq)
+        tm.assert_index_equal(rng, result)
+
+    @pytest.mark.parametrize('off', ['BQ', 'QS', 'BQS'])
+    def test_to_period_quarterlyish(self, off):
+        rng = date_range('01-Jan-2012', periods=8, freq=off)
+        prng = rng.to_period()
+        assert prng.freq == 'Q-DEC'
 
-    def test_to_period_annualish(self):
-        offsets = ['BA', 'AS', 'BAS']
-        for off in offsets:
-            rng = date_range('01-Jan-2012', periods=8, freq=off)
-            prng = rng.to_period()
-            assert prng.freq == 'A-DEC'
+    @pytest.mark.parametrize('off', ['BA', 'AS', 'BAS'])
+    def test_to_period_annualish(self, off):
+        rng = date_range('01-Jan-2012', periods=8, freq=off)
+        prng = rng.to_period()
+        assert prng.freq == 'A-DEC'
 
     def test_to_period_monthish(self):
         offsets = ['MS', 'BM']
@@ -304,12 +180,6 @@ class TestPeriodIndex(object):
         pi = dti.to_period(freq='H')
         tm.assert_index_equal(pi.to_timestamp(), dti)
 
-    def test_to_timestamp_1703(self):
-        index = period_range('1/1/2012', periods=4, freq='D')
-
-        result = index.to_timestamp()
-        assert result[0] == Timestamp('1/1/2012')
-
     def test_combine_first(self):
         # GH 3367
         didx = pd.DatetimeIndex(start='1950-01-31', end='1950-07-31', freq='M')
@@ -325,26 +195,137 @@ class TestPeriodIndex(object):
                                  dtype=np.float64)
             tm.assert_series_equal(result, expected)
 
-    def test_searchsorted(self):
-        for freq in ['D', '2D']:
-            pidx = pd.PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03',
-                                   '2014-01-04', '2014-01-05'], freq=freq)
+    @pytest.mark.parametrize('freq', ['D', '2D'])
+    def test_searchsorted(self, freq):
+        pidx = pd.PeriodIndex(['2014-01-01', '2014-01-02', '2014-01-03',
+                               '2014-01-04', '2014-01-05'], freq=freq)
+
+        p1 = pd.Period('2014-01-01', freq=freq)
+        assert pidx.searchsorted(p1) == 0
+
+        p2 = pd.Period('2014-01-04', freq=freq)
+        assert pidx.searchsorted(p2) == 3
+
+        msg = "Input has different freq=H from PeriodIndex"
+        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
+            pidx.searchsorted(pd.Period('2014-01-01', freq='H'))
+
+        msg = "Input has different freq=5D from PeriodIndex"
+        with tm.assert_raises_regex(period.IncompatibleFrequency, msg):
+            pidx.searchsorted(pd.Period('2014-01-01', freq='5D'))
+
+        with tm.assert_produces_warning(FutureWarning):
+            pidx.searchsorted(key=p2)
+
+
+class TestPeriodIndexConversion(object):
+    def test_tolist(self):
+        index = PeriodIndex(freq='A', start='1/1/2001', end='12/1/2009')
+        rs = index.tolist()
+        for x in rs:
+            assert isinstance(x, Period)
+
+        recon = PeriodIndex(rs)
+        tm.assert_index_equal(index, recon)
+
+    def test_to_timestamp_pi_nat(self):
+        # GH#7228
+        index = PeriodIndex(['NaT', '2011-01', '2011-02'], freq='M',
+                            name='idx')
+
+        result = index.to_timestamp('D')
+        expected = DatetimeIndex([pd.NaT, datetime(2011, 1, 1),
+                                  datetime(2011, 2, 1)], name='idx')
+        tm.assert_index_equal(result, expected)
+        assert result.name == 'idx'
+
+        result2 = result.to_period(freq='M')
+        tm.assert_index_equal(result2, index)
+        assert result2.name == 'idx'
+
+        result3 = result.to_period(freq='3M')
+        exp = PeriodIndex(['NaT', '2011-01', '2011-02'],
+                          freq='3M', name='idx')
+        tm.assert_index_equal(result3, exp)
+        assert result3.freqstr == '3M'
+
+        msg = ('Frequency must be positive, because it'
+               ' represents span: -2A')
+        with tm.assert_raises_regex(ValueError, msg):
+            result.to_period(freq='-2A')
+
+    def test_to_timestamp_preserve_name(self):
+        index = PeriodIndex(freq='A', start='1/1/2001', end='12/1/2009',
+                            name='foo')
+        assert index.name == 'foo'
+
+        conv = index.to_timestamp('D')
+        assert conv.name == 'foo'
+
+    def test_to_timestamp_quarterly_bug(self):
+        years = np.arange(1960, 2000).repeat(4)
+        quarters = np.tile(lrange(1, 5), 40)
+
+        pindex = PeriodIndex(year=years, quarter=quarters)
+
+        stamps = pindex.to_timestamp('D', 'end')
+        expected = DatetimeIndex([x.to_timestamp('D', 'end') for x in pindex])
+        tm.assert_index_equal(stamps, expected)
+
+    def test_to_timestamp_pi_mult(self):
+        idx = PeriodIndex(['2011-01', 'NaT', '2011-02'],
+                          freq='2M', name='idx')
+
+        result = idx.to_timestamp()
+        expected = DatetimeIndex(['2011-01-01', 'NaT', '2011-02-01'],
+                                 name='idx')
+        tm.assert_index_equal(result, expected)
 
-            p1 = pd.Period('2014-01-01', freq=freq)
-            assert pidx.searchsorted(p1) == 0
+        result = idx.to_timestamp(how='E')
+        expected = DatetimeIndex(['2011-02-28', 'NaT', '2011-03-31'],
+                                 name='idx')
+        tm.assert_index_equal(result, expected)
 
-            p2 = pd.Period('2014-01-04', freq=freq)
-            assert pidx.searchsorted(p2) == 3
+    def test_to_timestamp_pi_combined(self):
+        idx = PeriodIndex(start='2011', periods=2, freq='1D1H', name='idx')
 
-            msg = "Input has different freq=H from PeriodIndex"
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                pidx.searchsorted(pd.Period('2014-01-01', freq='H'))
+        result = idx.to_timestamp()
+        expected = DatetimeIndex(['2011-01-01 00:00', '2011-01-02 01:00'],
+                                 name='idx')
+        tm.assert_index_equal(result, expected)
 
-            msg = "Input has different freq=5D from PeriodIndex"
-            with tm.assert_raises_regex(
-                    period.IncompatibleFrequency, msg):
-                pidx.searchsorted(pd.Period('2014-01-01', freq='5D'))
+        result = idx.to_timestamp(how='E')
+        expected = DatetimeIndex(['2011-01-02 00:59:59',
+                                  '2011-01-03 01:59:59'],
+                                 name='idx')
+        tm.assert_index_equal(result, expected)
 
-            with tm.assert_produces_warning(FutureWarning):
-                pidx.searchsorted(key=p2)
+        result = idx.to_timestamp(how='E', freq='H')
+        expected = DatetimeIndex(['2011-01-02 00:00', '2011-01-03 01:00'],
+                                 name='idx')
+        tm.assert_index_equal(result, expected)
+
+    def test_period_astype_to_timestamp(self):
+        pi = pd.PeriodIndex(['2011-01', '2011-02', '2011-03'], freq='M')
+
+        exp = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'])
+        tm.assert_index_equal(pi.astype('datetime64[ns]'), exp)
+
+        exp = pd.DatetimeIndex(['2011-01-31', '2011-02-28', '2011-03-31'])
+        tm.assert_index_equal(pi.astype('datetime64[ns]', how='end'), exp)
+
+        exp = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
+                               tz='US/Eastern')
+        res = pi.astype('datetime64[ns, US/Eastern]')
+        tm.assert_index_equal(pi.astype('datetime64[ns, US/Eastern]'), exp)
+
+        exp = pd.DatetimeIndex(['2011-01-31', '2011-02-28', '2011-03-31'],
+                               tz='US/Eastern')
+        res = pi.astype('datetime64[ns, US/Eastern]', how='end')
+        tm.assert_index_equal(res, exp)
+
+    def test_to_timestamp_1703(self):
+        index = period_range('1/1/2012', periods=4, freq='D')
+
+        result = index.to_timestamp()
+        assert result[0] == Timestamp('1/1/2012')
diff --git a/pandas/tests/indexes/timedeltas/test_arithmetic.py b/pandas/tests/indexes/timedeltas/test_arithmetic.py
index 029fdfcef..4141d66cb 100644
--- a/pandas/tests/indexes/timedeltas/test_arithmetic.py
+++ b/pandas/tests/indexes/timedeltas/test_arithmetic.py
@@ -671,19 +671,19 @@ class TestTimedeltaIndexArithmetic(object):
         expected = DatetimeIndex(['20121231', pd.NaT, '20130101'])
         tm.assert_index_equal(result, expected)
 
-    def test_sub_period(self):
+    @pytest.mark.parametrize('freq', [None, 'H'])
+    def test_sub_period(self, freq):
         # GH 13078
         # not supported, check TypeError
         p = pd.Period('2011-01-01', freq='D')
 
-        for freq in [None, 'H']:
-            idx = pd.TimedeltaIndex(['1 hours', '2 hours'], freq=freq)
+        idx = pd.TimedeltaIndex(['1 hours', '2 hours'], freq=freq)
 
-            with pytest.raises(TypeError):
-                idx - p
+        with pytest.raises(TypeError):
+            idx - p
 
-            with pytest.raises(TypeError):
-                p - idx
+        with pytest.raises(TypeError):
+            p - idx
 
     def test_addition_ops(self):
         # with datetimes/timedelta and tdi/dti
diff --git a/pandas/tests/indexes/timedeltas/test_ops.py b/pandas/tests/indexes/timedeltas/test_ops.py
index 690ba66b6..49737e535 100644
--- a/pandas/tests/indexes/timedeltas/test_ops.py
+++ b/pandas/tests/indexes/timedeltas/test_ops.py
@@ -227,14 +227,15 @@ class TestTimedeltaIndexOps(Ops):
         res = Series(idx).drop_duplicates(keep=False)
         tm.assert_series_equal(res, Series(base[5:], index=np.arange(5, 31)))
 
-    def test_infer_freq(self):
-        # GH 11018
-        for freq in ['D', '3D', '-3D', 'H', '2H', '-2H', 'T', '2T', 'S', '-3S'
-                     ]:
-            idx = pd.timedelta_range('1', freq=freq, periods=10)
-            result = pd.TimedeltaIndex(idx.asi8, freq='infer')
-            tm.assert_index_equal(idx, result)
-            assert result.freq == freq
+    @pytest.mark.parametrize('freq', ['D', '3D', '-3D',
+                                      'H', '2H', '-2H',
+                                      'T', '2T', 'S', '-3S'])
+    def test_infer_freq(self, freq):
+        # GH#11018
+        idx = pd.timedelta_range('1', freq=freq, periods=10)
+        result = pd.TimedeltaIndex(idx.asi8, freq='infer')
+        tm.assert_index_equal(idx, result)
+        assert result.freq == freq
 
     def test_nat_new(self):
 
diff --git a/pandas/tests/indexes/timedeltas/test_timedelta.py b/pandas/tests/indexes/timedeltas/test_timedelta.py
index ce0f3b89b..37db9d704 100644
--- a/pandas/tests/indexes/timedeltas/test_timedelta.py
+++ b/pandas/tests/indexes/timedeltas/test_timedelta.py
@@ -102,13 +102,11 @@ class TestTimedeltaIndex(DatetimeLike):
         tm.assert_numpy_array_equal(arr, exp_arr)
         tm.assert_index_equal(idx, idx3)
 
-    def test_join_self(self):
-
+    @pytest.mark.parametrize('kind', ['outer', 'inner', 'left', 'right'])
+    def test_join_self(self, kind):
         index = timedelta_range('1 day', periods=10)
-        kinds = 'outer', 'inner', 'left', 'right'
-        for kind in kinds:
-            joined = index.join(index, how=kind)
-            tm.assert_index_equal(index, joined)
+        joined = index.join(index, how=kind)
+        tm.assert_index_equal(index, joined)
 
     def test_does_not_convert_mixed_integer(self):
         df = tm.makeCustomDataframe(10, 10,
diff --git a/pandas/tests/scalar/period/test_period.py b/pandas/tests/scalar/period/test_period.py
index 41b3bb55b..dff5433ad 100644
--- a/pandas/tests/scalar/period/test_period.py
+++ b/pandas/tests/scalar/period/test_period.py
@@ -20,21 +20,21 @@ from pandas import Period, Timestamp, offsets
 class TestPeriodProperties(object):
     "Test properties such as year, month, weekday, etc...."
 
-    def test_is_leap_year(self):
+    @pytest.mark.parametrize('freq', ['A', 'M', 'D', 'H'])
+    def test_is_leap_year(self, freq):
         # GH 13727
-        for freq in ['A', 'M', 'D', 'H']:
-            p = Period('2000-01-01 00:00:00', freq=freq)
-            assert p.is_leap_year
-            assert isinstance(p.is_leap_year, bool)
+        p = Period('2000-01-01 00:00:00', freq=freq)
+        assert p.is_leap_year
+        assert isinstance(p.is_leap_year, bool)
 
-            p = Period('1999-01-01 00:00:00', freq=freq)
-            assert not p.is_leap_year
+        p = Period('1999-01-01 00:00:00', freq=freq)
+        assert not p.is_leap_year
 
-            p = Period('2004-01-01 00:00:00', freq=freq)
-            assert p.is_leap_year
+        p = Period('2004-01-01 00:00:00', freq=freq)
+        assert p.is_leap_year
 
-            p = Period('2100-01-01 00:00:00', freq=freq)
-            assert not p.is_leap_year
+        p = Period('2100-01-01 00:00:00', freq=freq)
+        assert not p.is_leap_year
 
     def test_quarterly_negative_ordinals(self):
         p = Period(ordinal=-1, freq='Q-DEC')
@@ -52,40 +52,40 @@ class TestPeriodProperties(object):
         assert p.month == 11
         assert isinstance(p, Period)
 
-    def test_period_cons_quarterly(self):
+    @pytest.mark.parametrize('month', MONTHS)
+    def test_period_cons_quarterly(self, month):
         # bugs in scikits.timeseries
-        for month in MONTHS:
-            freq = 'Q-%s' % month
-            exp = Period('1989Q3', freq=freq)
-            assert '1989Q3' in str(exp)
-            stamp = exp.to_timestamp('D', how='end')
-            p = Period(stamp, freq=freq)
-            assert p == exp
-
-            stamp = exp.to_timestamp('3D', how='end')
-            p = Period(stamp, freq=freq)
-            assert p == exp
-
-    def test_period_cons_annual(self):
+        freq = 'Q-%s' % month
+        exp = Period('1989Q3', freq=freq)
+        assert '1989Q3' in str(exp)
+        stamp = exp.to_timestamp('D', how='end')
+        p = Period(stamp, freq=freq)
+        assert p == exp
+
+        stamp = exp.to_timestamp('3D', how='end')
+        p = Period(stamp, freq=freq)
+        assert p == exp
+
+    @pytest.mark.parametrize('month', MONTHS)
+    def test_period_cons_annual(self, month):
         # bugs in scikits.timeseries
-        for month in MONTHS:
-            freq = 'A-%s' % month
-            exp = Period('1989', freq=freq)
-            stamp = exp.to_timestamp('D', how='end') + timedelta(days=30)
-            p = Period(stamp, freq=freq)
-            assert p == exp + 1
-            assert isinstance(p, Period)
-
-    def test_period_cons_weekly(self):
-        for num in range(10, 17):
-            daystr = '2011-02-%d' % num
-            for day in DAYS:
-                freq = 'W-%s' % day
-
-                result = Period(daystr, freq=freq)
-                expected = Period(daystr, freq='D').asfreq(freq)
-                assert result == expected
-                assert isinstance(result, Period)
+        freq = 'A-%s' % month
+        exp = Period('1989', freq=freq)
+        stamp = exp.to_timestamp('D', how='end') + timedelta(days=30)
+        p = Period(stamp, freq=freq)
+        assert p == exp + 1
+        assert isinstance(p, Period)
+
+    @pytest.mark.parametrize('day', DAYS)
+    @pytest.mark.parametrize('num', range(10, 17))
+    def test_period_cons_weekly(self, num, day):
+        daystr = '2011-02-%d' % num
+        freq = 'W-%s' % day
+
+        result = Period(daystr, freq=freq)
+        expected = Period(daystr, freq='D').asfreq(freq)
+        assert result == expected
+        assert isinstance(result, Period)
 
     def test_period_from_ordinal(self):
         p = pd.Period('2011-01', freq='M')
@@ -212,58 +212,59 @@ class TestPeriodProperties(object):
         with tm.assert_raises_regex(ValueError, msg):
             Period('2011-01', freq='1D1W')
 
-    def test_timestamp_tz_arg(self):
-        for case in ['Europe/Brussels', 'Asia/Tokyo', 'US/Pacific']:
-            p = Period('1/1/2005', freq='M').to_timestamp(tz=case)
-            exp = Timestamp('1/1/2005', tz='UTC').tz_convert(case)
-            exp_zone = pytz.timezone(case).normalize(p)
-
-            assert p == exp
-            assert p.tz == exp_zone.tzinfo
-            assert p.tz == exp.tz
-
-            p = Period('1/1/2005', freq='3H').to_timestamp(tz=case)
-            exp = Timestamp('1/1/2005', tz='UTC').tz_convert(case)
-            exp_zone = pytz.timezone(case).normalize(p)
-
-            assert p == exp
-            assert p.tz == exp_zone.tzinfo
-            assert p.tz == exp.tz
-
-            p = Period('1/1/2005', freq='A').to_timestamp(freq='A', tz=case)
-            exp = Timestamp('31/12/2005', tz='UTC').tz_convert(case)
-            exp_zone = pytz.timezone(case).normalize(p)
-
-            assert p == exp
-            assert p.tz == exp_zone.tzinfo
-            assert p.tz == exp.tz
-
-            p = Period('1/1/2005', freq='A').to_timestamp(freq='3H', tz=case)
-            exp = Timestamp('1/1/2005', tz='UTC').tz_convert(case)
-            exp_zone = pytz.timezone(case).normalize(p)
-
-            assert p == exp
-            assert p.tz == exp_zone.tzinfo
-            assert p.tz == exp.tz
-
-    def test_timestamp_tz_arg_dateutil(self):
+    @pytest.mark.parametrize('tzstr', ['Europe/Brussels',
+                                       'Asia/Tokyo', 'US/Pacific'])
+    def test_timestamp_tz_arg(self, tzstr):
+        p = Period('1/1/2005', freq='M').to_timestamp(tz=tzstr)
+        exp = Timestamp('1/1/2005', tz='UTC').tz_convert(tzstr)
+        exp_zone = pytz.timezone(tzstr).normalize(p)
+
+        assert p == exp
+        assert p.tz == exp_zone.tzinfo
+        assert p.tz == exp.tz
+
+        p = Period('1/1/2005', freq='3H').to_timestamp(tz=tzstr)
+        exp = Timestamp('1/1/2005', tz='UTC').tz_convert(tzstr)
+        exp_zone = pytz.timezone(tzstr).normalize(p)
+
+        assert p == exp
+        assert p.tz == exp_zone.tzinfo
+        assert p.tz == exp.tz
+
+        p = Period('1/1/2005', freq='A').to_timestamp(freq='A', tz=tzstr)
+        exp = Timestamp('31/12/2005', tz='UTC').tz_convert(tzstr)
+        exp_zone = pytz.timezone(tzstr).normalize(p)
+
+        assert p == exp
+        assert p.tz == exp_zone.tzinfo
+        assert p.tz == exp.tz
+
+        p = Period('1/1/2005', freq='A').to_timestamp(freq='3H', tz=tzstr)
+        exp = Timestamp('1/1/2005', tz='UTC').tz_convert(tzstr)
+        exp_zone = pytz.timezone(tzstr).normalize(p)
+
+        assert p == exp
+        assert p.tz == exp_zone.tzinfo
+        assert p.tz == exp.tz
+
+    @pytest.mark.parametrize('tzstr', ['dateutil/Europe/Brussels',
+                                       'dateutil/Asia/Tokyo',
+                                       'dateutil/US/Pacific'])
+    def test_timestamp_tz_arg_dateutil(self, tzstr):
         from pandas._libs.tslibs.timezones import dateutil_gettz
         from pandas._libs.tslibs.timezones import maybe_get_tz
-        for case in ['dateutil/Europe/Brussels', 'dateutil/Asia/Tokyo',
-                     'dateutil/US/Pacific']:
-            p = Period('1/1/2005', freq='M').to_timestamp(
-                tz=maybe_get_tz(case))
-            exp = Timestamp('1/1/2005', tz='UTC').tz_convert(case)
-            assert p == exp
-            assert p.tz == dateutil_gettz(case.split('/', 1)[1])
-            assert p.tz == exp.tz
-
-            p = Period('1/1/2005',
-                       freq='M').to_timestamp(freq='3H', tz=maybe_get_tz(case))
-            exp = Timestamp('1/1/2005', tz='UTC').tz_convert(case)
-            assert p == exp
-            assert p.tz == dateutil_gettz(case.split('/', 1)[1])
-            assert p.tz == exp.tz
+        tz = maybe_get_tz(tzstr)
+        p = Period('1/1/2005', freq='M').to_timestamp(tz=tz)
+        exp = Timestamp('1/1/2005', tz='UTC').tz_convert(tzstr)
+        assert p == exp
+        assert p.tz == dateutil_gettz(tzstr.split('/', 1)[1])
+        assert p.tz == exp.tz
+
+        p = Period('1/1/2005', freq='M').to_timestamp(freq='3H', tz=tz)
+        exp = Timestamp('1/1/2005', tz='UTC').tz_convert(tzstr)
+        assert p == exp
+        assert p.tz == dateutil_gettz(tzstr.split('/', 1)[1])
+        assert p.tz == exp.tz
 
     def test_timestamp_tz_arg_dateutil_from_string(self):
         from pandas._libs.tslibs.timezones import dateutil_gettz
@@ -1403,14 +1404,14 @@ class TestMethods(object):
                       timedelta(hours=23, minutes=30)]:
                 assert p - o is tslib.NaT
 
-    def test_nat_ops(self):
-        for freq in ['M', '2M', '3M']:
-            p = Period('NaT', freq=freq)
-            assert p + 1 is tslib.NaT
-            assert 1 + p is tslib.NaT
-            assert p - 1 is tslib.NaT
-            assert p - Period('2011-01', freq=freq) is tslib.NaT
-            assert Period('2011-01', freq=freq) - p is tslib.NaT
+    @pytest.mark.parametrize('freq', ['M', '2M', '3M'])
+    def test_nat_ops(self, freq):
+        p = Period('NaT', freq=freq)
+        assert p + 1 is tslib.NaT
+        assert 1 + p is tslib.NaT
+        assert p - 1 is tslib.NaT
+        assert p - Period('2011-01', freq=freq) is tslib.NaT
+        assert Period('2011-01', freq=freq) - p is tslib.NaT
 
     def test_period_ops_offset(self):
         p = Period('2011-04-01', freq='D')

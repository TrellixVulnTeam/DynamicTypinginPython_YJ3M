commit 9fc888f359f17d2666d84c2365ca2b45f2e67355
Author: jreback <jeff@reback.net>
Date:   Wed Feb 13 23:16:19 2013 -0500

    BUG: fixed bug in IntBlock splitting
         bug in internals.Block.putmask ; coercing unecessarily

diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index bfed5dbcd..bdcbca708 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -304,14 +304,15 @@ class Block(object):
         if self._can_hold_element(new):
             new = self._try_cast(new)
             np.putmask(new_values, mask, new)
-        # upcast me
-        else:
+
+        # maybe upcast me
+        elif mask.any():
             # type of the new block
             if ((isinstance(new, np.ndarray) and issubclass(new.dtype, np.number)) or
                     isinstance(new, float)):
-                typ = float
+                typ = np.float64
             else:
-                typ = object
+                typ = np.object_
 
             # we need to exiplicty astype here to make a copy
             new_values = new_values.astype(typ)
@@ -515,14 +516,15 @@ class Block(object):
             return make_block(result, items, self.ref_items)
 
         # see if we can operate on the entire block, or need item-by-item
-        if cond.all().any():
+        if not self._can_hold_na:
+            axis = cond.ndim-1
             result_blocks = []
             for item in self.items:
                 loc  = self.items.get_loc(item)
                 item = self.items.take([loc])
-                v    = values.take([loc])
-                c    = cond.take([loc])
-                o    = other.take([loc]) if hasattr(other,'shape') else other
+                v    = values.take([loc],axis=axis)
+                c    = cond.take([loc],axis=axis)
+                o    = other.take([loc],axis=axis) if hasattr(other,'shape') else other
 
                 result = func(c,v,o)
                 if len(result) == 1:
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 0782de4bc..d249e0f24 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -248,16 +248,22 @@ class CheckIndexing(object):
         df = self.tsframe.copy()
         df['E'] = 1
         df['E'] = df['E'].astype('int32')
+        df['E1'] = df['E'].copy()
         df['F'] = 1
         df['F'] = df['F'].astype('int64')
+        df['F1'] = df['F'].copy()
+
         casted = df[df>0]
         result = casted.get_dtype_counts()
-        expected = Series({'float64': 4, 'int32' : 1, 'int64' : 1})
-
-        ### when we always cast here's the result ###
-        #expected = Series({'float64': 6 })
+        expected = Series({'float64': 4, 'int32' : 2, 'int64' : 2})
         assert_series_equal(result, expected)
 
+        # int block splitting
+        df.ix[1:3,['E1','F1']] = 0
+        casted = df[df>0]
+        result = casted.get_dtype_counts()
+        expected = Series({'float64': 6, 'int32' : 1, 'int64' : 1})
+        assert_series_equal(result, expected)
 
     def test_getitem_boolean_list(self):
         df = DataFrame(np.arange(12).reshape(3, 4))
@@ -6031,6 +6037,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
             
             # dtypes
             # can't check dtype when other is an ndarray
+
             if check_dtypes and not isinstance(other,np.ndarray):
                 self.assert_((rs.dtypes == df.dtypes).all() == True)
 
@@ -6066,13 +6073,15 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
             dfi = df.copy()
             econd = cond.reindex_like(df).fillna(True)
             expected = dfi.mask(~econd)
+
+            #import pdb; pdb.set_trace()
             dfi.where(cond, np.nan, inplace=True)
             assert_frame_equal(dfi, expected)
 
             # dtypes (and confirm upcasts)x
             if check_dtypes:
                 for k, v in df.dtypes.iteritems():
-                    if issubclass(v.type,np.integer):
+                    if issubclass(v.type,np.integer) and not cond[k].all():
                         v = np.dtype('float64')
                     self.assert_(dfi[k].dtype == v)
 

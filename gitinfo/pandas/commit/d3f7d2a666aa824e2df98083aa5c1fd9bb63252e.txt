commit d3f7d2a666aa824e2df98083aa5c1fd9bb63252e
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Thu Jan 25 04:01:56 2018 -0800

    separate non-scalar tests from test_timestamps (#19385)

diff --git a/pandas/tests/frame/test_apply.py b/pandas/tests/frame/test_apply.py
index 65dd166e1..e0fc6c470 100644
--- a/pandas/tests/frame/test_apply.py
+++ b/pandas/tests/frame/test_apply.py
@@ -428,6 +428,16 @@ class TestDataFrameApply(TestData):
                 result = frame.applymap(func)
                 tm.assert_frame_equal(result, frame)
 
+    def test_applymap_box_timestamps(self):
+        # #2689, #2627
+        ser = pd.Series(date_range('1/1/2000', periods=10))
+
+        def func(x):
+            return (x.hour, x.day, x.month)
+
+        # it works!
+        pd.DataFrame(ser).applymap(func)
+
     def test_applymap_box(self):
         # ufunc will not be boxed. Same test cases as the test_map_box
         df = pd.DataFrame({'a': [pd.Timestamp('2011-01-01'),
diff --git a/pandas/tests/indexes/datetimes/test_ops.py b/pandas/tests/indexes/datetimes/test_ops.py
index a91dbd905..fb8dd1a43 100644
--- a/pandas/tests/indexes/datetimes/test_ops.py
+++ b/pandas/tests/indexes/datetimes/test_ops.py
@@ -144,6 +144,25 @@ class TestDatetimeIndexOps(Ops):
             tm.assert_raises_regex(
                 ValueError, errmsg, np.argmax, dr, out=0)
 
+    def test_round_daily(self):
+        dti = pd.date_range('20130101 09:10:11', periods=5)
+        result = dti.round('D')
+        expected = pd.date_range('20130101', periods=5)
+        tm.assert_index_equal(result, expected)
+
+        dti = dti.tz_localize('UTC').tz_convert('US/Eastern')
+        result = dti.round('D')
+        expected = pd.date_range('20130101',
+                                 periods=5).tz_localize('US/Eastern')
+        tm.assert_index_equal(result, expected)
+
+        result = dti.round('s')
+        tm.assert_index_equal(result, dti)
+
+        # invalid
+        for freq in ['Y', 'M', 'foobar']:
+            pytest.raises(ValueError, lambda: dti.round(freq))
+
     def test_round(self):
         for tz in self.tz:
             rng = pd.date_range(start='2016-01-01', periods=5,
diff --git a/pandas/tests/io/test_html.py b/pandas/tests/io/test_html.py
index fd0c2b9d0..151a0750b 100644
--- a/pandas/tests/io/test_html.py
+++ b/pandas/tests/io/test_html.py
@@ -868,6 +868,13 @@ class TestReadHtmlLxml(ReadHtmlMixin):
         banklist_data = os.path.join(DATA_PATH, 'banklist.html')
         self.read_html(banklist_data, '.*Water.*', flavor=['lxml', 'html5lib'])
 
+    def test_to_html_timestamp(self):
+        rng = date_range('2000-01-01', periods=10)
+        df = DataFrame(np.random.randn(10, 4), index=rng)
+
+        result = df.to_html()
+        assert '2000-01-01' in result
+
     def test_parse_dates_list(self):
         df = DataFrame({'date': date_range('1/1/2001', periods=10)})
         expected = df.to_html()
diff --git a/pandas/tests/scalar/test_timestamp.py b/pandas/tests/scalar/test_timestamp.py
index a3e9a0442..2b72eef2c 100644
--- a/pandas/tests/scalar/test_timestamp.py
+++ b/pandas/tests/scalar/test_timestamp.py
@@ -19,17 +19,13 @@ import pandas.util._test_decorators as td
 
 from pandas.tseries import offsets
 
-from pandas._libs.tslibs import conversion, period
+from pandas._libs.tslibs import conversion
 from pandas._libs.tslibs.timezones import get_timezone, dateutil_gettz as gettz
 from pandas._libs.tslibs.frequencies import _INVALID_FREQ_ERROR
 
 from pandas.compat import long, PY3
-from pandas.util.testing import assert_series_equal
 from pandas.compat.numpy import np_datetime64_compat
-from pandas import (Timestamp, date_range, Period, Timedelta, compat,
-                    Series, NaT, DataFrame)
-from pandas.tseries.frequencies import (RESO_DAY, RESO_HR, RESO_MIN, RESO_US,
-                                        RESO_MS, RESO_SEC)
+from pandas import Timestamp, Period, Timedelta, NaT
 
 
 class TestTimestampArithmetic(object):
@@ -54,6 +50,50 @@ class TestTimestampArithmetic(object):
         result = val + timedelta(1)
         assert result.nanosecond == val.nanosecond
 
+    def test_timestamp_sub_datetime(self):
+        dt = datetime(2013, 10, 12)
+        ts = Timestamp(datetime(2013, 10, 13))
+        assert (ts - dt).days == 1
+        assert (dt - ts).days == -1
+
+    def test_addition_subtraction_types(self):
+        # Assert on the types resulting from Timestamp +/- various date/time
+        # objects
+        dt = datetime(2014, 3, 4)
+        td = timedelta(seconds=1)
+        # build a timestamp with a frequency, since then it supports
+        # addition/subtraction of integers
+        ts = Timestamp(dt, freq='D')
+
+        assert type(ts + 1) == Timestamp
+        assert type(ts - 1) == Timestamp
+
+        # Timestamp + datetime not supported, though subtraction is supported
+        # and yields timedelta more tests in tseries/base/tests/test_base.py
+        assert type(ts - dt) == Timedelta
+        assert type(ts + td) == Timestamp
+        assert type(ts - td) == Timestamp
+
+        # Timestamp +/- datetime64 not supported, so not tested (could possibly
+        # assert error raised?)
+        td64 = np.timedelta64(1, 'D')
+        assert type(ts + td64) == Timestamp
+        assert type(ts - td64) == Timestamp
+
+    def test_addition_subtraction_preserve_frequency(self):
+        ts = Timestamp('2014-03-05', freq='D')
+        td = timedelta(days=1)
+        original_freq = ts.freq
+
+        assert (ts + 1).freq == original_freq
+        assert (ts - 1).freq == original_freq
+        assert (ts + td).freq == original_freq
+        assert (ts - td).freq == original_freq
+
+        td64 = np.timedelta64(1, 'D')
+        assert (ts + td64).freq == original_freq
+        assert (ts - td64).freq == original_freq
+
 
 class TestTimestampProperties(object):
 
@@ -76,6 +116,112 @@ class TestTimestampProperties(object):
         assert control.is_month_end
         assert control.is_quarter_end
 
+    def test_fields(self):
+        def check(value, equal):
+            # that we are int/long like
+            assert isinstance(value, (int, long))
+            assert value == equal
+
+        # GH 10050
+        ts = Timestamp('2015-05-10 09:06:03.000100001')
+        check(ts.year, 2015)
+        check(ts.month, 5)
+        check(ts.day, 10)
+        check(ts.hour, 9)
+        check(ts.minute, 6)
+        check(ts.second, 3)
+        pytest.raises(AttributeError, lambda: ts.millisecond)
+        check(ts.microsecond, 100)
+        check(ts.nanosecond, 1)
+        check(ts.dayofweek, 6)
+        check(ts.quarter, 2)
+        check(ts.dayofyear, 130)
+        check(ts.week, 19)
+        check(ts.daysinmonth, 31)
+        check(ts.daysinmonth, 31)
+
+        # GH 13303
+        ts = Timestamp('2014-12-31 23:59:00-05:00', tz='US/Eastern')
+        check(ts.year, 2014)
+        check(ts.month, 12)
+        check(ts.day, 31)
+        check(ts.hour, 23)
+        check(ts.minute, 59)
+        check(ts.second, 0)
+        pytest.raises(AttributeError, lambda: ts.millisecond)
+        check(ts.microsecond, 0)
+        check(ts.nanosecond, 0)
+        check(ts.dayofweek, 2)
+        check(ts.quarter, 4)
+        check(ts.dayofyear, 365)
+        check(ts.week, 1)
+        check(ts.daysinmonth, 31)
+
+        ts = Timestamp('2014-01-01 00:00:00+01:00')
+        starts = ['is_month_start', 'is_quarter_start', 'is_year_start']
+        for start in starts:
+            assert getattr(ts, start)
+        ts = Timestamp('2014-12-31 23:59:59+01:00')
+        ends = ['is_month_end', 'is_year_end', 'is_quarter_end']
+        for end in ends:
+            assert getattr(ts, end)
+
+    @pytest.mark.parametrize('data, expected',
+                             [(Timestamp('2017-08-28 23:00:00'), 'Monday'),
+                              (Timestamp('2017-08-28 23:00:00', tz='EST'),
+                               'Monday')])
+    def test_weekday_name(self, data, expected):
+        # GH 17354
+        assert data.weekday_name == expected
+
+    @pytest.mark.parametrize('tz', [None, 'UTC', 'US/Eastern', 'Asia/Tokyo'])
+    def test_is_leap_year(self, tz):
+        # GH 13727
+        dt = Timestamp('2000-01-01 00:00:00', tz=tz)
+        assert dt.is_leap_year
+        assert isinstance(dt.is_leap_year, bool)
+
+        dt = Timestamp('1999-01-01 00:00:00', tz=tz)
+        assert not dt.is_leap_year
+
+        dt = Timestamp('2004-01-01 00:00:00', tz=tz)
+        assert dt.is_leap_year
+
+        dt = Timestamp('2100-01-01 00:00:00', tz=tz)
+        assert not dt.is_leap_year
+
+    def test_woy_boundary(self):
+        # make sure weeks at year boundaries are correct
+        d = datetime(2013, 12, 31)
+        result = Timestamp(d).week
+        expected = 1  # ISO standard
+        assert result == expected
+
+        d = datetime(2008, 12, 28)
+        result = Timestamp(d).week
+        expected = 52  # ISO standard
+        assert result == expected
+
+        d = datetime(2009, 12, 31)
+        result = Timestamp(d).week
+        expected = 53  # ISO standard
+        assert result == expected
+
+        d = datetime(2010, 1, 1)
+        result = Timestamp(d).week
+        expected = 53  # ISO standard
+        assert result == expected
+
+        d = datetime(2010, 1, 3)
+        result = Timestamp(d).week
+        expected = 53  # ISO standard
+        assert result == expected
+
+        result = np.array([Timestamp(datetime(*args)).week
+                           for args in [(2000, 1, 1), (2000, 1, 2), (
+                               2005, 1, 1), (2005, 1, 2)]])
+        assert (result == [52, 52, 53, 53]).all()
+
 
 class TestTimestampConstructors(object):
 
@@ -310,24 +456,60 @@ class TestTimestampConstructors(object):
         ts = Timestamp.fromordinal(dt_tz.toordinal(), tz='US/Eastern')
         assert ts.to_pydatetime() == dt_tz
 
+    def test_out_of_bounds_value(self):
+        one_us = np.timedelta64(1).astype('timedelta64[us]')
 
-class TestTimestamp(object):
+        # By definition we can't go out of bounds in [ns], so we
+        # convert the datetime64s to [us] so we can go out of bounds
+        min_ts_us = np.datetime64(Timestamp.min).astype('M8[us]')
+        max_ts_us = np.datetime64(Timestamp.max).astype('M8[us]')
 
-    def test_conversion(self):
-        # GH 9255
-        ts = Timestamp('2000-01-01')
+        # No error for the min/max datetimes
+        Timestamp(min_ts_us)
+        Timestamp(max_ts_us)
 
-        result = ts.to_pydatetime()
-        expected = datetime(2000, 1, 1)
-        assert result == expected
-        assert type(result) == type(expected)
+        # One us less than the minimum is an error
+        with pytest.raises(ValueError):
+            Timestamp(min_ts_us - one_us)
 
-        result = ts.to_datetime64()
-        expected = np.datetime64(ts.value, 'ns')
-        assert result == expected
-        assert type(result) == type(expected)
-        assert result.dtype == expected.dtype
+        # One us more than the maximum is an error
+        with pytest.raises(ValueError):
+            Timestamp(max_ts_us + one_us)
+
+    def test_out_of_bounds_string(self):
+        with pytest.raises(ValueError):
+            Timestamp('1676-01-01')
+        with pytest.raises(ValueError):
+            Timestamp('2263-01-01')
 
+    def test_bounds_with_different_units(self):
+        out_of_bounds_dates = ('1677-09-21', '2262-04-12')
+
+        time_units = ('D', 'h', 'm', 's', 'ms', 'us')
+
+        for date_string in out_of_bounds_dates:
+            for unit in time_units:
+                dt64 = np.datetime64(date_string, dtype='M8[%s]' % unit)
+                with pytest.raises(ValueError):
+                    Timestamp(dt64)
+
+        in_bounds_dates = ('1677-09-23', '2262-04-11')
+
+        for date_string in in_bounds_dates:
+            for unit in time_units:
+                dt64 = np.datetime64(date_string, dtype='M8[%s]' % unit)
+                Timestamp(dt64)
+
+    def test_min_valid(self):
+        # Ensure that Timestamp.min is a valid Timestamp
+        Timestamp(Timestamp.min)
+
+    def test_max_valid(self):
+        # Ensure that Timestamp.max is a valid Timestamp
+        Timestamp(Timestamp.max)
+
+
+class TestTimestamp(object):
     @pytest.mark.parametrize('freq', ['D', 'M', 'S', 'N'])
     @pytest.mark.parametrize('date', ['2014-03-07', '2014-01-01 09:00',
                                       '2014-01-01 00:00:00.000000001'])
@@ -394,22 +576,6 @@ class TestTimestamp(object):
         result = repr(stamp)
         assert iso8601 in result
 
-    def test_bounds_with_different_units(self):
-        out_of_bounds_dates = ('1677-09-21', '2262-04-12', )
-
-        time_units = ('D', 'h', 'm', 's', 'ms', 'us')
-
-        for date_string in out_of_bounds_dates:
-            for unit in time_units:
-                pytest.raises(ValueError, Timestamp, np.datetime64(
-                    date_string, dtype='M8[%s]' % unit))
-
-        in_bounds_dates = ('1677-09-23', '2262-04-11', )
-
-        for date_string in in_bounds_dates:
-            for unit in time_units:
-                Timestamp(np.datetime64(date_string, dtype='M8[%s]' % unit))
-
     def test_tz(self):
         t = '2014-02-01 09:00'
         ts = Timestamp(t)
@@ -435,11 +601,9 @@ class TestTimestamp(object):
         ts_dst = ts.tz_localize('US/Eastern', ambiguous=True)
         ts_no_dst = ts.tz_localize('US/Eastern', ambiguous=False)
 
-        rng = date_range('2014-11-02', periods=3, freq='H', tz='US/Eastern')
-        assert rng[1] == ts_dst
-        assert rng[2] == ts_no_dst
-        pytest.raises(ValueError, ts.tz_localize, 'US/Eastern',
-                      ambiguous='infer')
+        assert (ts_no_dst.value - ts_dst.value) / 1e9 == 3600
+        with pytest.raises(ValueError):
+            ts.tz_localize('US/Eastern', ambiguous='infer')
 
         # GH 8025
         with tm.assert_raises_regex(TypeError,
@@ -501,24 +665,6 @@ class TestTimestamp(object):
             assert reset.tzinfo is None
             assert reset == converted.tz_convert('UTC').tz_localize(None)
 
-    def test_barely_oob_dts(self):
-        one_us = np.timedelta64(1).astype('timedelta64[us]')
-
-        # By definition we can't go out of bounds in [ns], so we
-        # convert the datetime64s to [us] so we can go out of bounds
-        min_ts_us = np.datetime64(Timestamp.min).astype('M8[us]')
-        max_ts_us = np.datetime64(Timestamp.max).astype('M8[us]')
-
-        # No error for the min/max datetimes
-        Timestamp(min_ts_us)
-        Timestamp(max_ts_us)
-
-        # One us less than the minimum is an error
-        pytest.raises(ValueError, Timestamp, min_ts_us - one_us)
-
-        # One us more than the maximum is an error
-        pytest.raises(ValueError, Timestamp, max_ts_us + one_us)
-
     def test_utc_z_designator(self):
         assert get_timezone(Timestamp('2014-11-02 01:00Z').tzinfo) == 'UTC'
 
@@ -569,64 +715,6 @@ class TestTimestamp(object):
         assert (Timestamp('nat').asm8.view('i8') ==
                 np.datetime64('nat', 'ns').view('i8'))
 
-    def test_fields(self):
-        def check(value, equal):
-            # that we are int/long like
-            assert isinstance(value, (int, compat.long))
-            assert value == equal
-
-        # GH 10050
-        ts = Timestamp('2015-05-10 09:06:03.000100001')
-        check(ts.year, 2015)
-        check(ts.month, 5)
-        check(ts.day, 10)
-        check(ts.hour, 9)
-        check(ts.minute, 6)
-        check(ts.second, 3)
-        pytest.raises(AttributeError, lambda: ts.millisecond)
-        check(ts.microsecond, 100)
-        check(ts.nanosecond, 1)
-        check(ts.dayofweek, 6)
-        check(ts.quarter, 2)
-        check(ts.dayofyear, 130)
-        check(ts.week, 19)
-        check(ts.daysinmonth, 31)
-        check(ts.daysinmonth, 31)
-
-        # GH 13303
-        ts = Timestamp('2014-12-31 23:59:00-05:00', tz='US/Eastern')
-        check(ts.year, 2014)
-        check(ts.month, 12)
-        check(ts.day, 31)
-        check(ts.hour, 23)
-        check(ts.minute, 59)
-        check(ts.second, 0)
-        pytest.raises(AttributeError, lambda: ts.millisecond)
-        check(ts.microsecond, 0)
-        check(ts.nanosecond, 0)
-        check(ts.dayofweek, 2)
-        check(ts.quarter, 4)
-        check(ts.dayofyear, 365)
-        check(ts.week, 1)
-        check(ts.daysinmonth, 31)
-
-        ts = Timestamp('2014-01-01 00:00:00+01:00')
-        starts = ['is_month_start', 'is_quarter_start', 'is_year_start']
-        for start in starts:
-            assert getattr(ts, start)
-        ts = Timestamp('2014-12-31 23:59:59+01:00')
-        ends = ['is_month_end', 'is_year_end', 'is_quarter_end']
-        for end in ends:
-            assert getattr(ts, end)
-
-    @pytest.mark.parametrize('data, expected',
-                             [(Timestamp('2017-08-28 23:00:00'), 'Monday'),
-                              (Timestamp('2017-08-28 23:00:00', tz='EST'),
-                               'Monday')])
-    def test_weekday_name(self, data, expected):
-        # GH 17354
-        assert data.weekday_name == expected
-
     def test_pprint(self):
         # GH12622
         import pprint
@@ -646,16 +734,6 @@ class TestTimestamp(object):
  'foo': 1}"""
         assert result == expected
 
-    def test_to_pydatetime_nonzero_nano(self):
-        ts = Timestamp('2011-01-01 9:00:00.123456789')
-
-        # Warn the user of data loss (nanoseconds).
-        with tm.assert_produces_warning(UserWarning,
-                                        check_stacklevel=False):
-            expected = datetime(2011, 1, 1, 9, 0, 0, 123456)
-            result = ts.to_pydatetime()
-            assert result == expected
-
     def test_round(self):
 
         # round
@@ -684,11 +762,6 @@ class TestTimestamp(object):
         expected = Timestamp('20130104 12:30:00')
         assert result == expected
 
-        dti = date_range('20130101 09:10:11', periods=5)
-        result = dti.round('D')
-        expected = date_range('20130101', periods=5)
-        tm.assert_index_equal(result, expected)
-
         # floor
         dt = Timestamp('20130101 09:10:11')
         result = dt.floor('D')
@@ -711,19 +784,6 @@ class TestTimestamp(object):
         result = dt.round('s')
         assert result == dt
 
-        dti = date_range('20130101 09:10:11',
-                         periods=5).tz_localize('UTC').tz_convert('US/Eastern')
-        result = dti.round('D')
-        expected = date_range('20130101', periods=5).tz_localize('US/Eastern')
-        tm.assert_index_equal(result, expected)
-
-        result = dti.round('s')
-        tm.assert_index_equal(result, dti)
-
-        # invalid
-        for freq in ['Y', 'M', 'foobar']:
-            pytest.raises(ValueError, lambda: dti.round(freq))
-
         # GH 14440 & 15578
         result = Timestamp('2016-10-17 12:00:00.0015').round('ms')
         expected = Timestamp('2016-10-17 12:00:00.002000')
@@ -845,7 +905,7 @@ class TestTimestamp(object):
         check(days, unit='D', h=0)
 
         # using truediv, so these are like floats
-        if compat.PY3:
+        if PY3:
             check((val + 500000) / long(1000000000), unit='s', us=500)
             check((val + 500000000) / long(1000000000), unit='s', us=500000)
             check((val + 500000) / long(1000000), unit='ms', us=500)
@@ -900,22 +960,6 @@ class TestTimestamp(object):
         stamp = Timestamp(datetime(2011, 1, 1))
         assert d[stamp] == 5
 
-    @pytest.mark.parametrize('tz', [None, 'UTC', 'US/Eastern', 'Asia/Tokyo'])
-    def test_is_leap_year(self, tz):
-        # GH 13727
-        dt = Timestamp('2000-01-01 00:00:00', tz=tz)
-        assert dt.is_leap_year
-        assert isinstance(dt.is_leap_year, bool)
-
-        dt = Timestamp('1999-01-01 00:00:00', tz=tz)
-        assert not dt.is_leap_year
-
-        dt = Timestamp('2004-01-01 00:00:00', tz=tz)
-        assert dt.is_leap_year
-
-        dt = Timestamp('2100-01-01 00:00:00', tz=tz)
-        assert not dt.is_leap_year
-
     @td.skip_if_windows
     def test_timestamp(self):
         # GH#17329
@@ -1017,13 +1061,6 @@ class TestTimestampComparison(object):
         assert val != np.float64(1)
         assert val != np.int64(1)
 
-        # ops testing
-        df = DataFrame(np.random.randn(5, 2))
-        a = df[0]
-        b = Series(np.random.randn(5))
-        b.name = Timestamp('2000-01-01')
-        tm.assert_series_equal(a / b, 1 / (b / a))
-
     def test_cant_compare_tz_naive_w_aware(self):
         # see gh-1404
         a = Timestamp('3/12/2012')
@@ -1112,41 +1149,6 @@ class TestTimestampComparison(object):
             result = right_f(nat, rhs)
             assert result == expected
 
-    def test_timestamp_compare_series(self):
-        # make sure we can compare Timestamps on the right AND left hand side
-        # GH4982
-        s = Series(date_range('20010101', periods=10), name='dates')
-        s_nat = s.copy(deep=True)
-
-        s[0] = Timestamp('nat')
-        s[3] = Timestamp('nat')
-
-        ops = {'lt': 'gt', 'le': 'ge', 'eq': 'eq', 'ne': 'ne'}
-
-        for left, right in ops.items():
-            left_f = getattr(operator, left)
-            right_f = getattr(operator, right)
-
-            # no nats
-            expected = left_f(s, Timestamp('20010109'))
-            result = right_f(Timestamp('20010109'), s)
-            tm.assert_series_equal(result, expected)
-
-            # nats
-            expected = left_f(s, Timestamp('nat'))
-            result = right_f(Timestamp('nat'), s)
-            tm.assert_series_equal(result, expected)
-
-            # compare to timestamp with series containing nats
-            expected = left_f(s_nat, Timestamp('20010109'))
-            result = right_f(Timestamp('20010109'), s_nat)
-            tm.assert_series_equal(result, expected)
-
-            # compare to nat with series containing nats
-            expected = left_f(s_nat, Timestamp('nat'))
-            result = right_f(Timestamp('nat'), s_nat)
-            tm.assert_series_equal(result, expected)
-
     def test_timestamp_compare_with_early_datetime(self):
         # e.g. datetime.min
         stamp = Timestamp('2012-01-01')
@@ -1250,79 +1252,6 @@ class TestTimestampNsOperations(object):
         assert t.nanosecond == 10
 
 
-class TestTimestampOps(object):
-
-    def test_timestamp_and_datetime(self):
-        assert ((Timestamp(datetime(2013, 10, 13)) -
-                 datetime(2013, 10, 12)).days == 1)
-        assert ((datetime(2013, 10, 12) -
-                 Timestamp(datetime(2013, 10, 13))).days == -1)
-
-    def test_timestamp_and_series(self):
-        timestamp_series = Series(date_range('2014-03-17', periods=2, freq='D',
-                                             tz='US/Eastern'))
-        first_timestamp = timestamp_series[0]
-
-        delta_series = Series([np.timedelta64(0, 'D'), np.timedelta64(1, 'D')])
-        assert_series_equal(timestamp_series - first_timestamp, delta_series)
-        assert_series_equal(first_timestamp - timestamp_series, -delta_series)
-
-    def test_addition_subtraction_types(self):
-        # Assert on the types resulting from Timestamp +/- various date/time
-        # objects
-        datetime_instance = datetime(2014, 3, 4)
-        timedelta_instance = timedelta(seconds=1)
-        # build a timestamp with a frequency, since then it supports
-        # addition/subtraction of integers
-        timestamp_instance = Timestamp(datetime_instance, freq='D')
-
-        assert type(timestamp_instance + 1) == Timestamp
-        assert type(timestamp_instance - 1) == Timestamp
-
-        # Timestamp + datetime not supported, though subtraction is supported
-        # and yields timedelta more tests in tseries/base/tests/test_base.py
-        assert type(timestamp_instance - datetime_instance) == Timedelta
-        assert type(timestamp_instance + timedelta_instance) == Timestamp
-        assert type(timestamp_instance - timedelta_instance) == Timestamp
-
-        # Timestamp +/- datetime64 not supported, so not tested (could possibly
-        # assert error raised?)
-        timedelta64_instance = np.timedelta64(1, 'D')
-        assert type(timestamp_instance + timedelta64_instance) == Timestamp
-        assert type(timestamp_instance - timedelta64_instance) == Timestamp
-
-    def test_addition_subtraction_preserve_frequency(self):
-        timestamp_instance = Timestamp('2014-03-05', freq='D')
-        timedelta_instance = timedelta(days=1)
-        original_freq = timestamp_instance.freq
-
-        assert (timestamp_instance + 1).freq == original_freq
-        assert (timestamp_instance - 1).freq == original_freq
-        assert (timestamp_instance + timedelta_instance).freq == original_freq
-        assert (timestamp_instance - timedelta_instance).freq == original_freq
-
-        timedelta64_instance = np.timedelta64(1, 'D')
-        assert (timestamp_instance +
-                timedelta64_instance).freq == original_freq
-        assert (timestamp_instance -
-                timedelta64_instance).freq == original_freq
-
-    @pytest.mark.parametrize('tz', [None, 'Asia/Tokyo', 'US/Eastern',
-                                    'dateutil/US/Eastern'])
-    def test_resolution(self, tz):
-
-        for freq, expected in zip(['A', 'Q', 'M', 'D', 'H', 'T',
-                                   'S', 'L', 'U'],
-                                  [RESO_DAY, RESO_DAY,
-                                   RESO_DAY, RESO_DAY,
-                                   RESO_HR, RESO_MIN,
-                                   RESO_SEC, RESO_MS,
-                                   RESO_US]):
-            idx = date_range(start='2013-04-01', periods=30, freq=freq, tz=tz)
-            result = period.resolution(idx.asi8, idx.tz)
-            assert result == expected
-
-
 class TestTimestampToJulianDate(object):
 
     def test_compare_1700(self):
@@ -1347,6 +1276,31 @@ class TestTimestampToJulianDate(object):
 
 
 class TestTimestampConversion(object):
+    def test_conversion(self):
+        # GH#9255
+        ts = Timestamp('2000-01-01')
+
+        result = ts.to_pydatetime()
+        expected = datetime(2000, 1, 1)
+        assert result == expected
+        assert type(result) == type(expected)
+
+        result = ts.to_datetime64()
+        expected = np.datetime64(ts.value, 'ns')
+        assert result == expected
+        assert type(result) == type(expected)
+        assert result.dtype == expected.dtype
+
+    def test_to_pydatetime_nonzero_nano(self):
+        ts = Timestamp('2011-01-01 9:00:00.123456789')
+
+        # Warn the user of data loss (nanoseconds).
+        with tm.assert_produces_warning(UserWarning,
+                                        check_stacklevel=False):
+            expected = datetime(2011, 1, 1, 9, 0, 0, 123456)
+            result = ts.to_pydatetime()
+            assert result == expected
+
     def test_timestamp_to_datetime(self):
         stamp = Timestamp('20090415', tz='US/Eastern', freq='D')
         dtval = stamp.to_pydatetime()
@@ -1384,102 +1338,3 @@ class TestTimestampConversion(object):
         with tm.assert_produces_warning(exp_warning, check_stacklevel=False):
             assert (Timestamp(Timestamp.min.to_pydatetime()).value / 1000 ==
                     Timestamp.min.value / 1000)
-
-
-class TestTimeSeries(object):
-
-    def test_timestamp_date_out_of_range(self):
-        pytest.raises(ValueError, Timestamp, '1676-01-01')
-        pytest.raises(ValueError, Timestamp, '2263-01-01')
-
-    def test_timestamp_equality(self):
-
-        # GH 11034
-        s = Series([Timestamp('2000-01-29 01:59:00'), 'NaT'])
-        result = s != s
-        assert_series_equal(result, Series([False, True]))
-        result = s != s[0]
-        assert_series_equal(result, Series([False, True]))
-        result = s != s[1]
-        assert_series_equal(result, Series([True, True]))
-
-        result = s == s
-        assert_series_equal(result, Series([True, False]))
-        result = s == s[0]
-        assert_series_equal(result, Series([True, False]))
-        result = s == s[1]
-        assert_series_equal(result, Series([False, False]))
-
-    def test_series_box_timestamp(self):
-        rng = date_range('20090415', '20090519', freq='B')
-        s = Series(rng)
-
-        assert isinstance(s[5], Timestamp)
-
-        rng = date_range('20090415', '20090519', freq='B')
-        s = Series(rng, index=rng)
-        assert isinstance(s[5], Timestamp)
-
-        assert isinstance(s.iat[5], Timestamp)
-
-    def test_to_html_timestamp(self):
-        rng = date_range('2000-01-01', periods=10)
-        df = DataFrame(np.random.randn(10, 4), index=rng)
-
-        result = df.to_html()
-        assert '2000-01-01' in result
-
-    def test_series_map_box_timestamps(self):
-        # #2689, #2627
-        s = Series(date_range('1/1/2000', periods=10))
-
-        def f(x):
-            return (x.hour, x.day, x.month)
-
-        # it works!
-        s.map(f)
-        s.apply(f)
-        DataFrame(s).applymap(f)
-
-    def test_woy_boundary(self):
-        # make sure weeks at year boundaries are correct
-        d = datetime(2013, 12, 31)
-        result = Timestamp(d).week
-        expected = 1  # ISO standard
-        assert result == expected
-
-        d = datetime(2008, 12, 28)
-        result = Timestamp(d).week
-        expected = 52  # ISO standard
-        assert result == expected
-
-        d = datetime(2009, 12, 31)
-        result = Timestamp(d).week
-        expected = 53  # ISO standard
-        assert result == expected
-
-        d = datetime(2010, 1, 1)
-        result = Timestamp(d).week
-        expected = 53  # ISO standard
-        assert result == expected
-
-        d = datetime(2010, 1, 3)
-        result = Timestamp(d).week
-        expected = 53  # ISO standard
-        assert result == expected
-
-        result = np.array([Timestamp(datetime(*args)).week
-                           for args in [(2000, 1, 1), (2000, 1, 2), (
-                               2005, 1, 1), (2005, 1, 2)]])
-        assert (result == [52, 52, 53, 53]).all()
-
-
-class TestTsUtil(object):
-
-    def test_min_valid(self):
-        # Ensure that Timestamp.min is a valid Timestamp
-        Timestamp(Timestamp.min)
-
-    def test_max_valid(self):
-        # Ensure that Timestamp.max is a valid Timestamp
-        Timestamp(Timestamp.max)
diff --git a/pandas/tests/series/test_apply.py b/pandas/tests/series/test_apply.py
index 8899ab585..3822ecd0a 100644
--- a/pandas/tests/series/test_apply.py
+++ b/pandas/tests/series/test_apply.py
@@ -77,6 +77,17 @@ class TestSeriesApply(TestData):
         assert result[0] == ['foo', 'bar']
         assert isinstance(result[0], list)
 
+    def test_series_map_box_timestamps(self):
+        # GH#2689, GH#2627
+        ser = Series(pd.date_range('1/1/2000', periods=10))
+
+        def func(x):
+            return (x.hour, x.day, x.month)
+
+        # it works!
+        ser.map(func)
+        ser.apply(func)
+
     def test_apply_box(self):
         # ufunc will not be boxed. Same test cases as the test_map_box
         vals = [pd.Timestamp('2011-01-01'), pd.Timestamp('2011-01-02')]
diff --git a/pandas/tests/series/test_arithmetic.py b/pandas/tests/series/test_arithmetic.py
index 9db05ff59..ca558dd6b 100644
--- a/pandas/tests/series/test_arithmetic.py
+++ b/pandas/tests/series/test_arithmetic.py
@@ -1,10 +1,77 @@
 # -*- coding: utf-8 -*-
 from datetime import timedelta
+import operator
+
+import numpy as np
 
 import pandas as pd
 import pandas.util.testing as tm
 
 
+class TestSeriesComparison(object):
+    def test_compare_invalid(self):
+        # GH#8058
+        # ops testing
+        a = pd.Series(np.random.randn(5), name=0)
+        b = pd.Series(np.random.randn(5))
+        b.name = pd.Timestamp('2000-01-01')
+        tm.assert_series_equal(a / b, 1 / (b / a))
+
+
+class TestTimestampSeriesComparison(object):
+    def test_timestamp_compare_series(self):
+        # make sure we can compare Timestamps on the right AND left hand side
+        # GH#4982
+        ser = pd.Series(pd.date_range('20010101', periods=10), name='dates')
+        s_nat = ser.copy(deep=True)
+
+        ser[0] = pd.Timestamp('nat')
+        ser[3] = pd.Timestamp('nat')
+
+        ops = {'lt': 'gt', 'le': 'ge', 'eq': 'eq', 'ne': 'ne'}
+
+        for left, right in ops.items():
+            left_f = getattr(operator, left)
+            right_f = getattr(operator, right)
+
+            # no nats
+            expected = left_f(ser, pd.Timestamp('20010109'))
+            result = right_f(pd.Timestamp('20010109'), ser)
+            tm.assert_series_equal(result, expected)
+
+            # nats
+            expected = left_f(ser, pd.Timestamp('nat'))
+            result = right_f(pd.Timestamp('nat'), ser)
+            tm.assert_series_equal(result, expected)
+
+            # compare to timestamp with series containing nats
+            expected = left_f(s_nat, pd.Timestamp('20010109'))
+            result = right_f(pd.Timestamp('20010109'), s_nat)
+            tm.assert_series_equal(result, expected)
+
+            # compare to nat with series containing nats
+            expected = left_f(s_nat, pd.Timestamp('nat'))
+            result = right_f(pd.Timestamp('nat'), s_nat)
+            tm.assert_series_equal(result, expected)
+
+    def test_timestamp_equality(self):
+        # GH#11034
+        ser = pd.Series([pd.Timestamp('2000-01-29 01:59:00'), 'NaT'])
+        result = ser != ser
+        tm.assert_series_equal(result, pd.Series([False, True]))
+        result = ser != ser[0]
+        tm.assert_series_equal(result, pd.Series([False, True]))
+        result = ser != ser[1]
+        tm.assert_series_equal(result, pd.Series([True, True]))
+
+        result = ser == ser
+        tm.assert_series_equal(result, pd.Series([True, False]))
+        result = ser == ser[0]
+        tm.assert_series_equal(result, pd.Series([True, False]))
+        result = ser == ser[1]
+        tm.assert_series_equal(result, pd.Series([False, False]))
+
+
 class TestTimedeltaSeriesComparisons(object):
     def test_compare_timedelta_series(self):
         # regresssion test for GH5963
@@ -55,3 +122,15 @@ class TestPeriodSeriesArithmetic(object):
         expected = pd.Series([4, 2], name='xxx', dtype=object)
         tm.assert_series_equal(s2 - ser, expected)
         tm.assert_series_equal(ser - s2, -expected)
+
+
+class TestTimestampSeriesArithmetic(object):
+    def test_timestamp_sub_series(self):
+        ser = pd.Series(pd.date_range('2014-03-17', periods=2, freq='D',
+                                      tz='US/Eastern'))
+        ts = ser[0]
+
+        delta_series = pd.Series([np.timedelta64(0, 'D'),
+                                  np.timedelta64(1, 'D')])
+        tm.assert_series_equal(ser - ts, delta_series)
+        tm.assert_series_equal(ts - ser, -delta_series)
diff --git a/pandas/tests/series/test_indexing.py b/pandas/tests/series/test_indexing.py
index bafc6d268..fbfbad547 100644
--- a/pandas/tests/series/test_indexing.py
+++ b/pandas/tests/series/test_indexing.py
@@ -610,6 +610,18 @@ class TestSeriesIndexing(TestData):
         value = self.ts[5]
         assert isinstance(value, np.float64)
 
+    def test_series_box_timestamp(self):
+        rng = pd.date_range('20090415', '20090519', freq='B')
+        ser = Series(rng)
+
+        assert isinstance(ser[5], pd.Timestamp)
+
+        rng = pd.date_range('20090415', '20090519', freq='B')
+        ser = Series(rng, index=rng)
+        assert isinstance(ser[5], pd.Timestamp)
+
+        assert isinstance(ser.iat[5], pd.Timestamp)
+
     def test_getitem_ambiguous_keyerror(self):
         s = Series(lrange(10), index=lrange(0, 20, 2))
         pytest.raises(KeyError, s.__getitem__, 1)

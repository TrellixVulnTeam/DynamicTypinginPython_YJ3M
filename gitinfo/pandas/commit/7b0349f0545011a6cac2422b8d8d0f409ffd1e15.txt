commit 7b0349f0545011a6cac2422b8d8d0f409ffd1e15
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Jan 13 12:53:56 2012 -0500

    ENH: API change / refactoring in Series.__getitem__ and __setitem__ to implement #86, related tightening of integer index handling from #592

diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 3f3ab5616..8ec6d9bf8 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -576,8 +576,7 @@ def truncate(self, before=None, after=None, copy=True):
     if before is not None and after is not None:
         assert(before <= after)
 
-    left, right = self.index.slice_locs(before, after)
-    result = self[left:right]
+    result = self.ix[before:after]
 
     if isinstance(self.index, MultiIndex):
         result.index = self.index.truncate(before, after)
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index d7140bdde..38508c068 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -1278,18 +1278,21 @@ def generate_groups(data, label_list, shape, axis=0, factory=lambda x: x):
     elif isinstance(data, DataFrame):
         sorted_data = data.take(indexer, axis=axis)
 
-    if isinstance(data, DataFrame):
-        def slicer(data, slob):
+    if isinstance(sorted_data, DataFrame):
+        def _get_slice(slob):
             if axis == 0:
-                return data[slob]
+                return sorted_data[slob]
             else:
-                return data.ix[:, slob]
-    elif isinstance(data, BlockManager):
-        def slicer(data, slob):
-            return factory(data.get_slice(slob, axis=axis))
-    else:
-        def slicer(data, slob):
-            return data[slob]
+                return sorted_data.ix[:, slob]
+    elif isinstance(sorted_data, BlockManager):
+        def _get_slice(slob):
+            return factory(sorted_data.get_slice(slob, axis=axis))
+    elif isinstance(sorted_data, Series):
+        def _get_slice(slob):
+            return sorted_data._get_values(slob)
+    else:  # pragma: no cover
+        def _get_slice(slob):
+            return sorted_data[slob]
 
     starts, ends = lib.generate_slices(group_index.astype('i4'),
                                        np.prod(shape))
@@ -1298,7 +1301,7 @@ def generate_groups(data, label_list, shape, axis=0, factory=lambda x: x):
         if start == end:
             yield i, None
         else:
-            yield i, slicer(sorted_data, slice(start, end))
+            yield i, _get_slice(slice(start, end))
 
 def get_group_index(label_list, shape):
     if len(label_list) == 1:
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 8bf5506d0..082dc3b5f 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -31,7 +31,7 @@ class _NDFrameIndexer(object):
         else:
             return self._getitem_axis(key, axis=0)
 
-    def _get(self, label, axis=0):
+    def _get_label(self, label, axis=0):
         try:
             return self.obj.xs(label, axis=axis, copy=False)
         except Exception:
@@ -96,7 +96,7 @@ class _NDFrameIndexer(object):
         # a bit kludgy
         if isinstance(self.obj._get_axis(0), MultiIndex):
             try:
-                return self._get(tup, axis=0)
+                return self._get_label(tup, axis=0)
             except (KeyError, TypeError):
                 pass
 
@@ -156,7 +156,7 @@ class _NDFrameIndexer(object):
             if com.is_integer(key):
                 if isinstance(labels, MultiIndex):
                     try:
-                        return self._get(key, axis=0)
+                        return self._get_label(key, axis=0)
                     except (KeyError, TypeError):
                         if _is_integer_index(self.obj.index.levels[0]):
                             raise
@@ -164,32 +164,28 @@ class _NDFrameIndexer(object):
                 if not is_int_index:
                     idx = labels[key]
 
-            return self._get(idx, axis=0)
+            return self._get_label(idx, axis=0)
         else:
             labels = self.obj._get_axis(axis)
             lab = key
             if com.is_integer(key) and not _is_integer_index(labels):
                 lab = labels[key]
-            return self._get(lab, axis=axis)
+            return self._get_label(lab, axis=axis)
 
     def _getitem_iterable(self, key, axis=0):
         labels = self.obj._get_axis(axis)
         axis_name = self.obj._get_axis_name(axis)
 
-        # asarray can be unsafe, NumPy strings are weird
-        if isinstance(key, Index):
-            # want Index objects to pass through untouched
-            keyarr = key
-        else:
-            keyarr = _asarray_tuplesafe(key)
-
-        if keyarr.dtype == np.bool_:
-            if _is_series(key):
-                if not key.index.equals(labels):
-                    raise IndexingError('Cannot use boolean index with '
-                                        'misaligned or unequal labels')
+        if com._is_bool_indexer(key):
+            key = _check_bool_indexer(labels, key)
             return self.obj.reindex(**{axis_name : labels[np.asarray(key)]})
         else:
+            if isinstance(key, Index):
+                # want Index objects to pass through untouched
+                keyarr = key
+            else:
+                # asarray can be unsafe, NumPy strings are weird
+                keyarr = _asarray_tuplesafe(key)
             if _is_integer_dtype(keyarr) and not _is_integer_index(labels):
                 keyarr = labels.take(keyarr)
 
@@ -244,14 +240,12 @@ class _NDFrameIndexer(object):
             return slicer
 
         elif _is_list_like(obj):
-            objarr = _asarray_tuplesafe(obj)
-
-            if objarr.dtype == np.bool_:
-                if not obj.index.equals(labels):
-                    raise IndexingError('Cannot use boolean index with '
-                                        'misaligned or unequal labels')
+            if com._is_bool_indexer(obj):
+                objarr = _check_bool_indexer(labels, obj)
                 return objarr
             else:
+                objarr = _asarray_tuplesafe(obj)
+
                 # If have integer labels, defer to label-based indexing
                 if _is_integer_dtype(objarr) and not is_int_index:
                     return objarr
@@ -330,14 +324,33 @@ class _SeriesIndexer(_NDFrameIndexer):
     >>> ts.ix[date1:date2] = 0
     """
 
-    def _get(self, label, axis=0):
-        return self.obj[label]
+    def _get_integer(self, indexer, axis=0):
+        return self.obj._get_values(indexer)
 
-    def _slice(self, obj, axis=0):
-        return self.obj[obj]
+    def _get_label(self, key, axis=0):
+        return self.obj[key]
+
+    def _slice(self, indexer, axis=0):
+        return self.obj._get_values(indexer)
 
     def _setitem_with_indexer(self, indexer, value):
-        self.obj[indexer] = value
+        self.obj._set_values(indexer, value)
+
+def _check_bool_indexer(ax, key):
+    # boolean indexing, need to check that the data are aligned, otherwise
+    # disallowed
+    result = key
+    if _is_series(key) and key.dtype == np.bool_:
+        if not key.index.equals(ax):
+            result = key.reindex(ax)
+
+    if isinstance(result, np.ndarray) and result.dtype == np.object_:
+        mask = com.isnull(result)
+        if mask.any():
+            raise IndexingError('cannot index with vector containing '
+                                'NA / NaN values')
+
+    return result
 
 def _is_series(obj):
     from pandas.core.series import Series
@@ -395,4 +408,3 @@ def _maybe_droplevels(index, key):
 
     return index
 
-_isboolarr = lambda x: np.asarray(x).dtype == np.bool_
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 7e9d1bb7d..09e0edb8d 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -220,21 +220,6 @@ copy : boolean, default False
     _index = None
     index = lib.SeriesIndex()
 
-    # def _get_index(self):
-    #     return self._index
-
-    # def _set_index(self, index):
-    #     if not isinstance(index, _INDEX_TYPES):
-    #         raise TypeError("Expected index to be in %s; was %s."
-    #                         % (_INDEX_TYPES, type(index)))
-
-    #     if len(self) != len(index):
-    #         raise AssertionError('Lengths of index and values did not match!')
-
-    #     self._index = _ensure_index(index)
-
-    # index = property(fget=_get_index, fset=_set_index)
-
     def __array_finalize__(self, obj):
         """
         Gets called after any ufunc or other array operations, necessary
@@ -315,18 +300,143 @@ copy : boolean, default False
             key = self._check_bool_indexer(key)
             key = np.asarray(key, dtype=bool)
 
-        return self._index_with(key)
+        return self._get_with(key)
 
-    def _index_with(self, key):
+    def _get_with(self, key):
         # other: fancy integer or otherwise
-        # [slice(0, 5, None)] will break if you convert to ndarray,
-        # e.g. as requested by np.median
+        if isinstance(key, slice):
+            indexer = self.ix._convert_to_indexer(key, axis=0)
+            return self._get_values(indexer)
+        else:
+            # mpl hackaround
+            if isinstance(key, tuple):
+                try:
+                    return self._get_values(key)
+                except Exception:
+                    pass
+
+            if not isinstance(key, (list, np.ndarray)):
+                key = list(key)
 
+            key_type = lib.infer_dtype(key)
+
+            if key_type == 'integer':
+                if self.index.inferred_type == 'integer':
+                    return self.reindex(key)
+                else:
+                    return self._get_values(key)
+            elif key_type == 'boolean':
+                return self._get_values(key)
+            else:
+                try:
+                    return self.reindex(key)
+                except Exception:
+                    # [slice(0, 5, None)] will break if you convert to ndarray,
+                    # e.g. as requested by np.median
+                    # hack
+                    if isinstance(key[0], slice):
+                        return self._get_values(key)
+                    raise
+
+    def __setitem__(self, key, value):
+        values = self.values
         try:
-            return Series(self.values[key], index=self.index[key],
+            values[self.index.get_loc(key)] = value
+            return
+        except KeyError:
+            if (com.is_integer(key)
+                and not self.index.inferred_type == 'integer'):
+
+                values[key] = value
+                return
+
+            raise KeyError('%s not in this series!' % str(key))
+        except TypeError:
+            # Could not hash item
+            pass
+
+        if _is_bool_indexer(key):
+            key = self._check_bool_indexer(key)
+            key = np.asarray(key, dtype=bool)
+
+        self._set_with(key, value)
+
+    def _set_with(self, key, value):
+        # other: fancy integer or otherwise
+        if isinstance(key, slice):
+            indexer = self.ix._convert_to_indexer(key, axis=0)
+            return self._set_values(indexer, value)
+        else:
+            if isinstance(key, tuple):
+                try:
+                    self._set_values(key, value)
+                except Exception:
+                    pass
+
+            if not isinstance(key, (list, np.ndarray)):
+                key = list(key)
+
+            key_type = lib.infer_dtype(key)
+
+            if key_type == 'integer':
+                if self.index.inferred_type == 'integer':
+                    self._set_labels(key, value)
+                else:
+                    return self._set_values(key, value)
+            elif key_type == 'boolean':
+                self._set_values(key, value)
+            else:
+                self._set_labels(key, value)
+
+    def _set_labels(self, key, value):
+        key = _asarray_tuplesafe(key)
+        indexer = self.index.get_indexer(key)
+        mask = indexer == -1
+        if mask.any():
+            raise ValueError('%s not contained in the index'
+                             % str(key[mask]))
+        self._set_values(indexer, value)
+
+    def _get_values(self, indexer):
+        try:
+            return Series(self.values[indexer], index=self.index[indexer],
                           name=self.name)
         except Exception:
-            return self.values[key]
+            return self.values[indexer]
+
+    def _set_values(self, key, value):
+        self.values[key] = value
+
+    # help out SparseSeries
+    _get_val_at = ndarray.__getitem__
+
+    def __getslice__(self, i, j):
+        if i < 0:
+            i = 0
+        if j < 0:
+            j = 0
+        slobj = slice(i, j)
+        return self.__getitem__(slobj)
+
+    def _check_bool_indexer(self, key):
+        # boolean indexing, need to check that the data are aligned, otherwise
+        # disallowed
+        result = key
+        if isinstance(key, Series) and key.dtype == np.bool_:
+            if not key.index.equals(self.index):
+                result = key.reindex(self.index)
+
+        if isinstance(result, np.ndarray) and result.dtype == np.object_:
+            mask = isnull(result)
+            if mask.any():
+                raise ValueError('cannot index with vector containing '
+                                 'NA / NaN values')
+
+        return result
+
+    def __setslice__(self, i, j, value):
+        """Set slice equal to given value(s)"""
+        ndarray.__setslice__(self, i, j, value)
 
     def get(self, label, default=None):
         """
@@ -390,67 +500,6 @@ copy : boolean, default False
             new_values = np.concatenate([self.values, [value]])
             return Series(new_values, index=new_index, name=self.name)
 
-    # help out SparseSeries
-    _get_val_at = ndarray.__getitem__
-
-    def __getslice__(self, i, j):
-        if i < 0:
-            i = 0
-        if j < 0:
-            j = 0
-        slobj = slice(i, j)
-        return self.__getitem__(slobj)
-
-    def __setitem__(self, key, value):
-        values = self.values
-        try:
-            values[self.index.get_loc(key)] = value
-            return
-        except KeyError:
-            if (com.is_integer(key)
-                and not self.index.inferred_type == 'integer'):
-
-                values[key] = value
-                return
-
-            raise KeyError('%s not in this series!' % str(key))
-        except TypeError:
-            # Could not hash item
-            pass
-
-        key = self._check_bool_indexer(key)
-
-        # special handling of boolean data with NAs stored in object
-        # arrays. Sort of an elaborate hack since we can't represent boolean
-        # NA. Hmm
-        if isinstance(key, np.ndarray) and key.dtype == np.object_:
-            if set([True, False]).issubset(set(key)):
-                key = np.asarray(key, dtype=bool)
-                values[key] = value
-                return
-
-        values[key] = value
-
-    def _check_bool_indexer(self, key):
-        # boolean indexing, need to check that the data are aligned, otherwise
-        # disallowed
-        result = key
-        if isinstance(key, Series) and key.dtype == np.bool_:
-            if not key.index.equals(self.index):
-                result = key.reindex(self.index)
-
-        if isinstance(result, np.ndarray) and result.dtype == np.object_:
-            mask = isnull(result)
-            if mask.any():
-                raise ValueError('cannot index with vector containing '
-                                 'NA / NaN values')
-
-        return result
-
-    def __setslice__(self, i, j, value):
-        """Set slice equal to given value(s)"""
-        ndarray.__setslice__(self, i, j, value)
-
     def __repr__(self):
         """Clean string representation of a Series"""
         width, height = get_terminal_size()
diff --git a/pandas/src/inference.pyx b/pandas/src/inference.pyx
index 4a3e3eb60..309a8f116 100644
--- a/pandas/src/inference.pyx
+++ b/pandas/src/inference.pyx
@@ -26,10 +26,20 @@ try:
 except AttributeError:
     pass
 
-def infer_dtype(ndarray values):
+def infer_dtype(object _values):
     cdef:
-        Py_ssize_t i, n = len(values)
+        Py_ssize_t i, n
         object test_val
+        ndarray values
+
+    if isinstance(_values, np.ndarray):
+        values = _values
+    else:
+        if not isinstance(_values, list):
+            _values = list(_values)
+        values = list_to_object_array(_values)
+
+    n = len(values)
 
     val_kind = values.dtype.type
     if val_kind in _TYPE_MAP:
diff --git a/pandas/stats/tests/test_moments.py b/pandas/stats/tests/test_moments.py
index 738abacb6..a68193e2a 100644
--- a/pandas/stats/tests/test_moments.py
+++ b/pandas/stats/tests/test_moments.py
@@ -298,8 +298,8 @@ class TestMoments(unittest.TestCase):
 
         result = func(A, B, 20, min_periods=5)
 
-        self.assert_(np.isnan(result[:15]).all())
-        self.assert_(not np.isnan(result[15:]).any())
+        self.assert_(np.isnan(result.values[:15]).all())
+        self.assert_(not np.isnan(result.values[15:]).any())
 
         self.assertRaises(Exception, func, A, randn(50), 20, min_periods=5)
 
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index ef09ee6c3..a1aaf42be 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -701,10 +701,19 @@ class CheckIndexing(object):
                            slice(None, None, None),
                            slice(None, None, None)), 1)
 
+    def test_getitem_setitem_boolean_misaligned(self):
         # boolean index misaligned labels
         mask = self.frame['A'][::-1] > 1
-        self.assertRaises(Exception, ix.__getitem__, mask)
-        self.assertRaises(Exception, ix.__setitem__, mask, 1.)
+
+        result = self.frame.ix[mask]
+        expected = self.frame.ix[mask[::-1]]
+        assert_frame_equal(result, expected)
+
+        cp = self.frame.copy()
+        expected = self.frame.copy()
+        cp.ix[mask] = 0
+        expected.ix[mask] = 0
+        assert_frame_equal(cp, expected)
 
     def test_setitem_single_column_mixed(self):
         df = DataFrame(randn(5, 3), index=['a', 'b', 'c', 'd', 'e'],
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index e45cda4b2..7d7fbaf73 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -159,7 +159,7 @@ class TestMultiLevel(unittest.TestCase):
 
         result = s[2000, 3]
         result2 = s.ix[2000, 3]
-        expected = s[42:65]
+        expected = s.reindex(s.index[42:65])
         expected.index = expected.index.droplevel(0).droplevel(0)
         assert_series_equal(result, expected)
 
@@ -169,7 +169,7 @@ class TestMultiLevel(unittest.TestCase):
 
         # fancy
         result = s.ix[[(2000, 3, 10), (2000, 3, 13)]]
-        expected = s[49:51]
+        expected = s.reindex(s.index[49:51])
         assert_series_equal(result, expected)
 
         # key error
@@ -179,9 +179,9 @@ class TestMultiLevel(unittest.TestCase):
         s = self.ymd['A']
 
         s[2000, 3] = np.nan
-        self.assert_(isnull(s[42:65]).all())
-        self.assert_(notnull(s[:42]).all())
-        self.assert_(notnull(s[65:]).all())
+        self.assert_(isnull(s.values[42:65]).all())
+        self.assert_(notnull(s.values[:42]).all())
+        self.assert_(notnull(s.values[65:]).all())
 
         s[2000, 3, 10] = np.nan
         self.assert_(isnull(s[49]))
@@ -243,7 +243,7 @@ class TestMultiLevel(unittest.TestCase):
         frame =  DataFrame(np.random.randn(len(index), 4), index=index,
                            columns=['a', 'b', 'c', 'd'])
         res = frame.ix[1:2]
-        exp = frame[2:]
+        exp = frame.reindex(frame.index[2:])
         assert_frame_equal(res, exp)
 
         frame.ix[1:2] = 7
@@ -252,7 +252,7 @@ class TestMultiLevel(unittest.TestCase):
         series =  Series(np.random.randn(len(index)), index=index)
 
         res = series.ix[1:2]
-        exp = series[2:]
+        exp = series.reindex(series.index[2:])
         assert_series_equal(res, exp)
 
         series.ix[1:2] = 7
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 4ac78638b..875a5cb65 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -472,12 +472,65 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self.assertEqual(len(sl), len(sl.index))
         self.assertEqual(len(sl.index.indexMap), len(sl.index))
 
-    # def test_getitem_reindex(self):
-    #     indices = self.ts.index[[5, 10, 15]]
+    def test_basic_getitem_with_labels(self):
+        indices = self.ts.index[[5, 10, 15]]
 
-    #     result = self.ts[indices]
-    #     expected = self.ts.reindex(indices)
-    #     assert_series_equal(result, expected)
+        result = self.ts[indices]
+        expected = self.ts.reindex(indices)
+        assert_series_equal(result, expected)
+
+        result = self.ts[indices[0]:indices[2]]
+        expected = self.ts.ix[indices[0]:indices[2]]
+        assert_series_equal(result, expected)
+
+        # integer indexes, be careful
+        s = Series(np.random.randn(10), index=range(0, 20, 2))
+        inds = [0, 2, 5, 7, 8]
+        arr_inds = np.array([0, 2, 5, 7, 8])
+        result = s[inds]
+        expected = s.reindex(inds)
+        assert_series_equal(result, expected)
+
+        result = s[arr_inds]
+        expected = s.reindex(arr_inds)
+        assert_series_equal(result, expected)
+
+    def test_basic_setitem_with_labels(self):
+        indices = self.ts.index[[5, 10, 15]]
+
+        cp = self.ts.copy()
+        exp = self.ts.copy()
+        cp[indices] = 0
+        exp.ix[indices] = 0
+        assert_series_equal(cp, exp)
+
+        cp = self.ts.copy()
+        exp = self.ts.copy()
+        cp[indices[0]:indices[2]] = 0
+        exp.ix[indices[0]:indices[2]] = 0
+        assert_series_equal(cp, exp)
+
+        # integer indexes, be careful
+        s = Series(np.random.randn(10), index=range(0, 20, 2))
+        inds = [0, 4, 6]
+        arr_inds = np.array([0, 4, 6])
+
+        cp = s.copy()
+        exp = s.copy()
+        s[inds] = 0
+        s.ix[inds] = 0
+        assert_series_equal(cp, exp)
+
+        cp = s.copy()
+        exp = s.copy()
+        s[arr_inds] = 0
+        s.ix[arr_inds] = 0
+        assert_series_equal(cp, exp)
+
+        inds_notfound = [0, 4, 5, 6]
+        arr_inds_notfound = np.array([0, 4, 5, 6])
+        self.assertRaises(Exception, s.__setitem__, inds_notfound, 0)
+        self.assertRaises(Exception, s.__setitem__, arr_inds_notfound, 0)
 
     def test_ix_getitem(self):
         inds = self.series.index[[3,4,7]]
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index af1262f37..8a2605c09 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -690,7 +690,7 @@ class TestConcatenate(unittest.TestCase):
         b = df[5:].ix[:, ['strings', 'ints', 'floats']]
 
         appended = a.append(b)
-        self.assert_(isnull(appended['strings'][:5]).all())
+        self.assert_(isnull(appended['strings'][0:4]).all())
         self.assert_(isnull(appended['bools'][5:]).all())
 
     def test_append_many(self):

commit de2e0864a1e333d1dc9385d788a375d1aaaae1a5
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Thu Oct 10 15:53:02 2019 -0700

    REF: simplify maybe_promote (#28899)

diff --git a/pandas/core/dtypes/cast.py b/pandas/core/dtypes/cast.py
index 1e353c97b..1e62527f9 100644
--- a/pandas/core/dtypes/cast.py
+++ b/pandas/core/dtypes/cast.py
@@ -423,57 +423,14 @@ def maybe_promote(dtype, fill_value=np.nan):
         if issubclass(dtype.type, np.bool_):
             dtype = np.dtype(np.object_)
         elif issubclass(dtype.type, np.integer):
-            # upcast to prevent overflow
-            mst = np.min_scalar_type(fill_value)
-            if mst > dtype:
-                # np.dtype ordering considers:
-                #  int[n] < int[2*n]
-                #  uint[n] < uint[2*n]
-                #  u?int[n] < object_
-                dtype = mst
-
-            elif np.can_cast(fill_value, dtype):
-                pass
-
-            elif dtype.kind == "u" and mst.kind == "i":
+            if not np.can_cast(fill_value, dtype):
+                # upcast to prevent overflow
+                mst = np.min_scalar_type(fill_value)
                 dtype = np.promote_types(dtype, mst)
                 if dtype.kind == "f":
                     # Case where we disagree with numpy
                     dtype = np.dtype(np.object_)
 
-            elif dtype.kind == "i" and mst.kind == "u":
-
-                if fill_value > np.iinfo(np.int64).max:
-                    # object is the only way to represent fill_value and keep
-                    #  the range allowed by the given dtype
-                    dtype = np.dtype(np.object_)
-
-                elif mst.itemsize < dtype.itemsize:
-                    pass
-
-                elif dtype.itemsize == mst.itemsize:
-                    # We never cast signed to unsigned because that loses
-                    #  parts of the original range, so find the smallest signed
-                    #  integer that can hold all of `mst`.
-                    ndt = {
-                        np.int64: np.object_,
-                        np.int32: np.int64,
-                        np.int16: np.int32,
-                        np.int8: np.int16,
-                    }[dtype.type]
-                    dtype = np.dtype(ndt)
-
-                else:
-                    # bump to signed integer dtype that holds all of `mst` range
-                    # Note: we have to use itemsize because some (windows)
-                    #  builds don't satisfiy e.g. np.uint32 == np.uint32
-                    ndt = {
-                        4: np.int64,
-                        2: np.int32,
-                        1: np.int16,  # TODO: Test for this case
-                    }[mst.itemsize]
-                    dtype = np.dtype(ndt)
-
             fill_value = dtype.type(fill_value)
 
         elif issubclass(dtype.type, np.floating):

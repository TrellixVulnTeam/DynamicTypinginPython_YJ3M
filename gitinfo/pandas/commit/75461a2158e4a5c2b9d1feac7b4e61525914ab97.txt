commit 75461a2158e4a5c2b9d1feac7b4e61525914ab97
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu May 24 21:56:09 2012 -0400

    ENH: work toward joins on non-unique indexes, many-to-one support per #1306

diff --git a/pandas/core/index.py b/pandas/core/index.py
index baa98e094..7eeadfd2d 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -59,6 +59,7 @@ class Index(np.ndarray):
     # Cython methods
     _groupby = _algos.groupby_object
     _arrmap = _algos.arrmap_object
+    _left_indexer_unique = _algos.left_join_indexer_unique_object
     _left_indexer = _algos.left_join_indexer_object
     _inner_indexer = _algos.inner_join_indexer_object
     _outer_indexer = _algos.outer_join_indexer_object
@@ -726,6 +727,7 @@ class Index(np.ndarray):
     def _get_indexer_standard(self, other):
         if (self.dtype != np.object_ and
             self.is_monotonic and other.is_monotonic):
+            # TODO: unique vs non unique
             return self._left_indexer(other, self)
         else:
             return self._engine.get_indexer(other)
@@ -938,21 +940,35 @@ class Index(np.ndarray):
             else:
                 return ret_index
 
-        if how == 'left':
-            join_index = self
-            lidx = None
-            ridx = self._left_indexer(self, other)
-        elif how == 'right':
-            join_index = other
-            lidx = self._left_indexer(other, self)
-            ridx = None
-        elif how == 'inner':
-            join_index, lidx, ridx = self._inner_indexer(self.values,
-                                                         other.values)
-            join_index = self._wrap_joined_index(join_index, other)
-        elif how == 'outer':
-            join_index, lidx, ridx = self._outer_indexer(self.values,
-                                                         other.values)
+        if self.is_unique and other.is_unique:
+            # We can perform much better than the general case
+            if how == 'left':
+                join_index = self
+                lidx = None
+                ridx = self._left_indexer_unique(self, other)
+            elif how == 'right':
+                join_index = other
+                lidx = self._left_indexer_unique(other, self)
+                ridx = None
+            elif how == 'inner':
+                join_index, lidx, ridx = self._inner_indexer(self.values,
+                                                             other.values)
+                join_index = self._wrap_joined_index(join_index, other)
+            elif how == 'outer':
+                join_index, lidx, ridx = self._outer_indexer(self.values,
+                                                             other.values)
+                join_index = self._wrap_joined_index(join_index, other)
+        else:
+            if how == 'left':
+                join_index, lidx, ridx = self._left_indexer(self, other)
+            elif how == 'right':
+                join_index, ridx, lidx = self._left_indexer(other, self)
+            elif how == 'inner':
+                join_index, lidx, ridx = self._inner_indexer(self.values,
+                                                             other.values)
+            elif how == 'outer':
+                join_index, lidx, ridx = self._outer_indexer(self.values,
+                                                             other.values)
             join_index = self._wrap_joined_index(join_index, other)
 
         if return_indexers:
@@ -1074,6 +1090,7 @@ class Int64Index(Index):
 
     _groupby = _algos.groupby_int64
     _arrmap = _algos.arrmap_int64
+    _left_indexer_unique = _algos.left_join_indexer_unique_int64
     _left_indexer = _algos.left_join_indexer_int64
     _inner_indexer = _algos.inner_join_indexer_int64
     _outer_indexer = _algos.outer_join_indexer_int64
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index 77c446995..0d9357e25 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -1,7 +1,5 @@
 import os
-from pandas.util.py3compat import StringIO
-from pandas.src.codegen_template import template as pyx_template
-from pandas.src.codegen_replace import replace
+from cStringIO import StringIO
 
 header = """
 cimport numpy as np
@@ -615,10 +613,10 @@ def arrmap_%(name)s(ndarray[%(c_type)s] index, object func):
 
 # right might contain non-unique values
 
-left_join_template = """@cython.wraparound(False)
+left_join_unique_template = """@cython.wraparound(False)
 @cython.boundscheck(False)
-def left_join_indexer_%(name)s(ndarray[%(c_type)s] left,
-                             ndarray[%(c_type)s] right):
+def left_join_indexer_unique_%(name)s(ndarray[%(c_type)s] left,
+                                      ndarray[%(c_type)s] right):
     cdef:
         Py_ssize_t i, j, nleft, nright
         ndarray[int64_t] indexer
@@ -662,12 +660,12 @@ def left_join_indexer_%(name)s(ndarray[%(c_type)s] left,
 
 """
 
-inner_join_template = """@cython.wraparound(False)
+left_join_template = """@cython.wraparound(False)
 @cython.boundscheck(False)
-def inner_join_indexer_%(name)s(ndarray[%(c_type)s] left,
+def left_join_indexer_%(name)s(ndarray[%(c_type)s] left,
                               ndarray[%(c_type)s] right):
     '''
-    Two-pass algorithm?
+    Two-pass algorithm for monotonic indexes. Handles many-to-one merges
     '''
     cdef:
         Py_ssize_t i, j, k, nright, nleft, count
@@ -681,20 +679,35 @@ def inner_join_indexer_%(name)s(ndarray[%(c_type)s] left,
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft or j == nright:
-             break
-        else:
+    if nleft > 0:
+        while True:
+            if j == nright:
+                count += nleft - i
+                break
+
             lval = left[i]
             rval = right[j]
+
             if lval == rval:
-                i += 1
-                j += 1
                 count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
             elif lval < rval:
-                i += 1
+                count += 1
+                if i < nleft:
+                    i += 1
             else:
-                j += 1
+                if j < nright:
+                    j += 1
 
     # do it again now that result size is known
 
@@ -705,22 +718,259 @@ def inner_join_indexer_%(name)s(ndarray[%(c_type)s] left,
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft or j == nright:
-             break
-        else:
+    if nleft > 0:
+        while i < nleft:
+            if j == nright:
+                while i < nleft:
+                    lindexer[count] = i
+                    rindexer[count] = -1
+                    result[count] = left[i]
+                    i += 1
+                    count += 1
+
             lval = left[i]
             rval = right[j]
+
             if lval == rval:
                 lindexer[count] = i
                 rindexer[count] = j
                 result[count] = lval
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
+            elif lval < rval:
+                lindexer[count] = i
+                rindexer[count] = -1
+                result[count] = left[i]
+                count += 1
+                if i < nleft:
+                    i += 1
+            else:
+                if j < nright:
+                    j += 1
+
+    return result, lindexer, rindexer
+
+"""
+
+
+inner_join_template = """@cython.wraparound(False)
+@cython.boundscheck(False)
+def inner_join_indexer_%(name)s(ndarray[%(c_type)s] left,
+                              ndarray[%(c_type)s] right):
+    '''
+    Two-pass algorithm for monotonic indexes. Handles many-to-one merges
+    '''
+    cdef:
+        Py_ssize_t i, j, k, nright, nleft, count
+        %(c_type)s lval, rval
+        ndarray[int64_t] lindexer, rindexer
+        ndarray[%(c_type)s] result
+
+    nleft = len(left)
+    nright = len(right)
+
+    i = 0
+    j = 0
+    count = 0
+    if nleft > 0 and nright > 0:
+        lval = left[0]
+        rval = right[0]
+        while True:
+            if lval == rval:
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                elif j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
+            elif lval < rval:
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                else:
+                    break
+            else:
+                if j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
+
+    # do it again now that result size is known
+
+    lindexer = np.empty(count, dtype=np.int64)
+    rindexer = np.empty(count, dtype=np.int64)
+    result = np.empty(count, dtype=%(dtype)s)
+
+    i = 0
+    j = 0
+    count = 0
+    if nleft > 0 and nright > 0:
+        lval = left[0]
+        rval = right[0]
+        while True:
+            if lval == rval:
+                lindexer[count] = i
+                rindexer[count] = j
+                result[count] = rval
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                elif j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
+            elif lval < rval:
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                else:
+                    break
+            else:
+                if j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
+
+    return result, lindexer, rindexer
+
+"""
+
+
+outer_join_template2 = """@cython.wraparound(False)
+@cython.boundscheck(False)
+def outer_join_indexer_%(name)s(ndarray[%(c_type)s] left,
+                                ndarray[%(c_type)s] right):
+    cdef:
+        Py_ssize_t i, j, nright, nleft, count
+        %(c_type)s lval, rval
+        ndarray[int64_t] lindexer, rindexer
+        ndarray[%(c_type)s] result
+
+    nleft = len(left)
+    nright = len(right)
+
+    i = 0
+    j = 0
+    count = 0
+    if nleft == 0:
+        count = nright
+    elif nright == 0:
+        count = nleft
+    else:
+        while True:
+            if i == nleft:
+                count += nright - j
+                break
+            if j == nright:
+                count += nleft - i
+                break
+
+            lval = left[i]
+            rval = right[j]
+            if lval == rval:
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
+            elif lval < rval:
+                count += 1
                 i += 1
+            else:
+                count += 1
                 j += 1
+
+    lindexer = np.empty(count, dtype=np.int64)
+    rindexer = np.empty(count, dtype=np.int64)
+    result = np.empty(count, dtype=%(dtype)s)
+
+    # do it again, but populate the indexers / result
+
+    i = 0
+    j = 0
+    count = 0
+    if nleft == 0:
+        for j in range(nright):
+            lindexer[j] = -1
+            rindexer[j] = j
+            result[j] = right[j]
+    elif nright == 0:
+        for i in range(nright):
+            lindexer[i] = i
+            rindexer[i] = -1
+            result[i] = left[i]
+    else:
+        while True:
+            if i == nleft:
+                while j < nright:
+                    lindexer[count] = -1
+                    rindexer[count] = j
+                    result[count] = right[j]
+                    count += 1
+                    j += 1
+                break
+            if j == nright:
+                while i < nleft:
+                    lindexer[count] = i
+                    rindexer[count] = -1
+                    result[count] = left[i]
+                    count += 1
+                    i += 1
+                break
+
+            lval = left[i]
+            rval = right[j]
+
+            if lval == rval:
+                lindexer[count] = i
+                rindexer[count] = j
+                result[count] = lval
                 count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    break
             elif lval < rval:
+                lindexer[count] = i
+                rindexer[count] = -1
+                result[count] = lval
+                count += 1
                 i += 1
             else:
+                lindexer[count] = -1
+                rindexer[count] = j
+                result[count] = rval
+                count += 1
                 j += 1
 
     return result, lindexer, rindexer
@@ -931,8 +1181,9 @@ templates_1d = [map_indices_template,
                 groupby_template,
                 arrmap_template]
 
-nobool_1d_templates = [left_join_template,
-                       outer_join_template,
+nobool_1d_templates = [left_join_unique_template,
+                       left_join_template,
+                       outer_join_template2,
                        inner_join_template]
 
 templates_2d = [take_2d_axis0_template,
@@ -943,6 +1194,8 @@ def generate_take_cython_file(path='generated.pyx'):
     with open(path, 'w') as f:
         print >> f, header
 
+        print >> f, generate_ensure_dtypes()
+
         for template in templates_1d:
             print >> f, generate_from_template(template)
 
diff --git a/pandas/src/generated.pyx b/pandas/src/generated.pyx
index 9a275c806..b9f7a643d 100644
--- a/pandas/src/generated.pyx
+++ b/pandas/src/generated.pyx
@@ -55,6 +55,47 @@ cpdef ensure_platform_int(object arr):
         return np.array(arr, dtype=np.int_)
 
 
+
+cpdef ensure_float64(object arr):
+    if util.is_array(arr):
+        if (<ndarray> arr).descr.type_num == NPY_FLOAT64:
+            return arr
+        else:
+            return arr.astype(np.float64)
+    else:
+        return np.array(arr, dtype=np.float64)
+
+
+cpdef ensure_int32(object arr):
+    if util.is_array(arr):
+        if (<ndarray> arr).descr.type_num == NPY_INT32:
+            return arr
+        else:
+            return arr.astype(np.int32)
+    else:
+        return np.array(arr, dtype=np.int32)
+
+
+cpdef ensure_int64(object arr):
+    if util.is_array(arr):
+        if (<ndarray> arr).descr.type_num == NPY_INT64:
+            return arr
+        else:
+            return arr.astype(np.int64)
+    else:
+        return np.array(arr, dtype=np.int64)
+
+
+cpdef ensure_object(object arr):
+    if util.is_array(arr):
+        if (<ndarray> arr).descr.type_num == NPY_OBJECT:
+            return arr
+        else:
+            return arr.astype(np.object_)
+    else:
+        return np.array(arr, dtype=np.object_)
+
+
 @cython.wraparound(False)
 @cython.boundscheck(False)
 cpdef map_indices_float64(ndarray[float64_t] index):
@@ -2501,8 +2542,8 @@ def take_2d_multi_bool(ndarray[uint8_t, ndim=2] values,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def left_join_indexer_float64(ndarray[float64_t] left,
-                             ndarray[float64_t] right):
+def left_join_indexer_unique_float64(ndarray[float64_t] left,
+                                      ndarray[float64_t] right):
     cdef:
         Py_ssize_t i, j, nleft, nright
         ndarray[int64_t] indexer
@@ -2546,8 +2587,8 @@ def left_join_indexer_float64(ndarray[float64_t] left,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def left_join_indexer_object(ndarray[object] left,
-                             ndarray[object] right):
+def left_join_indexer_unique_object(ndarray[object] left,
+                                      ndarray[object] right):
     cdef:
         Py_ssize_t i, j, nleft, nright
         ndarray[int64_t] indexer
@@ -2591,8 +2632,8 @@ def left_join_indexer_object(ndarray[object] left,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def left_join_indexer_int32(ndarray[int32_t] left,
-                             ndarray[int32_t] right):
+def left_join_indexer_unique_int32(ndarray[int32_t] left,
+                                      ndarray[int32_t] right):
     cdef:
         Py_ssize_t i, j, nleft, nright
         ndarray[int64_t] indexer
@@ -2636,8 +2677,8 @@ def left_join_indexer_int32(ndarray[int32_t] left,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def left_join_indexer_int64(ndarray[int64_t] left,
-                             ndarray[int64_t] right):
+def left_join_indexer_unique_int64(ndarray[int64_t] left,
+                                      ndarray[int64_t] right):
     cdef:
         Py_ssize_t i, j, nleft, nright
         ndarray[int64_t] indexer
@@ -2682,10 +2723,13 @@ def left_join_indexer_int64(ndarray[int64_t] left,
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def outer_join_indexer_float64(ndarray[float64_t] left,
-                                ndarray[float64_t] right):
+def left_join_indexer_float64(ndarray[float64_t] left,
+                              ndarray[float64_t] right):
+    '''
+    Two-pass algorithm for monotonic indexes. Handles many-to-one merges
+    '''
     cdef:
-        Py_ssize_t i, j, nright, nleft, count
+        Py_ssize_t i, j, k, nright, nleft, count
         float64_t lval, rval
         ndarray[int64_t] lindexer, rindexer
         ndarray[float64_t] result
@@ -2696,92 +2740,96 @@ def outer_join_indexer_float64(ndarray[float64_t] left,
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft:
+    if nleft > 0:
+        while True:
             if j == nright:
-                # we are done
+                count += nleft - i
                 break
-            else:
-                while j < nright:
+
+            lval = left[i]
+            rval = right[j]
+
+            if lval == rval:
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
                     j += 1
-                    count += 1
-                break
-        elif j == nright:
-            while i < nleft:
-                i += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
+            elif lval < rval:
                 count += 1
-            break
-        else:
-            if left[i] == right[j]:
-                i += 1
-                j += 1
-            elif left[i] < right[j]:
-                i += 1
+                if i < nleft:
+                    i += 1
             else:
-                j += 1
+                if j < nright:
+                    j += 1
 
-            count += 1
+    # do it again now that result size is known
 
     lindexer = np.empty(count, dtype=np.int64)
     rindexer = np.empty(count, dtype=np.int64)
     result = np.empty(count, dtype=np.float64)
 
-    # do it again, but populate the indexers / result
-
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft:
+    if nleft > 0:
+        while i < nleft:
             if j == nright:
-                # we are done
-                break
-            else:
-                while j < nright:
-                    lindexer[count] = -1
-                    rindexer[count] = j
-                    result[count] = right[j]
-                    j += 1
+                while i < nleft:
+                    lindexer[count] = i
+                    rindexer[count] = -1
+                    result[count] = left[i]
+                    i += 1
                     count += 1
-                break
-        elif j == nright:
-            while i < nleft:
-                lindexer[count] = i
-                rindexer[count] = -1
-                result[count] = left[i]
-                i += 1
-                count += 1
-            break
-        else:
+
             lval = left[i]
             rval = right[j]
+
             if lval == rval:
                 lindexer[count] = i
                 rindexer[count] = j
                 result[count] = lval
-                i += 1
-                j += 1
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
             elif lval < rval:
                 lindexer[count] = i
                 rindexer[count] = -1
-                result[count] = lval
-                i += 1
+                result[count] = left[i]
+                count += 1
+                if i < nleft:
+                    i += 1
             else:
-                lindexer[count] = -1
-                rindexer[count] = j
-                result[count] = rval
-                j += 1
-
-            count += 1
+                if j < nright:
+                    j += 1
 
     return result, lindexer, rindexer
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def outer_join_indexer_object(ndarray[object] left,
-                                ndarray[object] right):
+def left_join_indexer_object(ndarray[object] left,
+                              ndarray[object] right):
+    '''
+    Two-pass algorithm for monotonic indexes. Handles many-to-one merges
+    '''
     cdef:
-        Py_ssize_t i, j, nright, nleft, count
+        Py_ssize_t i, j, k, nright, nleft, count
         object lval, rval
         ndarray[int64_t] lindexer, rindexer
         ndarray[object] result
@@ -2792,92 +2840,96 @@ def outer_join_indexer_object(ndarray[object] left,
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft:
+    if nleft > 0:
+        while True:
             if j == nright:
-                # we are done
+                count += nleft - i
                 break
-            else:
-                while j < nright:
+
+            lval = left[i]
+            rval = right[j]
+
+            if lval == rval:
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
                     j += 1
-                    count += 1
-                break
-        elif j == nright:
-            while i < nleft:
-                i += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
+            elif lval < rval:
                 count += 1
-            break
-        else:
-            if left[i] == right[j]:
-                i += 1
-                j += 1
-            elif left[i] < right[j]:
-                i += 1
+                if i < nleft:
+                    i += 1
             else:
-                j += 1
+                if j < nright:
+                    j += 1
 
-            count += 1
+    # do it again now that result size is known
 
     lindexer = np.empty(count, dtype=np.int64)
     rindexer = np.empty(count, dtype=np.int64)
     result = np.empty(count, dtype=object)
 
-    # do it again, but populate the indexers / result
-
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft:
+    if nleft > 0:
+        while i < nleft:
             if j == nright:
-                # we are done
-                break
-            else:
-                while j < nright:
-                    lindexer[count] = -1
-                    rindexer[count] = j
-                    result[count] = right[j]
-                    j += 1
+                while i < nleft:
+                    lindexer[count] = i
+                    rindexer[count] = -1
+                    result[count] = left[i]
+                    i += 1
                     count += 1
-                break
-        elif j == nright:
-            while i < nleft:
-                lindexer[count] = i
-                rindexer[count] = -1
-                result[count] = left[i]
-                i += 1
-                count += 1
-            break
-        else:
+
             lval = left[i]
             rval = right[j]
+
             if lval == rval:
                 lindexer[count] = i
                 rindexer[count] = j
                 result[count] = lval
-                i += 1
-                j += 1
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
             elif lval < rval:
                 lindexer[count] = i
                 rindexer[count] = -1
-                result[count] = lval
-                i += 1
+                result[count] = left[i]
+                count += 1
+                if i < nleft:
+                    i += 1
             else:
-                lindexer[count] = -1
-                rindexer[count] = j
-                result[count] = rval
-                j += 1
-
-            count += 1
+                if j < nright:
+                    j += 1
 
     return result, lindexer, rindexer
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def outer_join_indexer_int32(ndarray[int32_t] left,
-                                ndarray[int32_t] right):
+def left_join_indexer_int32(ndarray[int32_t] left,
+                              ndarray[int32_t] right):
+    '''
+    Two-pass algorithm for monotonic indexes. Handles many-to-one merges
+    '''
     cdef:
-        Py_ssize_t i, j, nright, nleft, count
+        Py_ssize_t i, j, k, nright, nleft, count
         int32_t lval, rval
         ndarray[int64_t] lindexer, rindexer
         ndarray[int32_t] result
@@ -2888,92 +2940,96 @@ def outer_join_indexer_int32(ndarray[int32_t] left,
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft:
+    if nleft > 0:
+        while True:
             if j == nright:
-                # we are done
+                count += nleft - i
                 break
-            else:
-                while j < nright:
+
+            lval = left[i]
+            rval = right[j]
+
+            if lval == rval:
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
                     j += 1
-                    count += 1
-                break
-        elif j == nright:
-            while i < nleft:
-                i += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
+            elif lval < rval:
                 count += 1
-            break
-        else:
-            if left[i] == right[j]:
-                i += 1
-                j += 1
-            elif left[i] < right[j]:
-                i += 1
+                if i < nleft:
+                    i += 1
             else:
-                j += 1
+                if j < nright:
+                    j += 1
 
-            count += 1
+    # do it again now that result size is known
 
     lindexer = np.empty(count, dtype=np.int64)
     rindexer = np.empty(count, dtype=np.int64)
     result = np.empty(count, dtype=np.int32)
 
-    # do it again, but populate the indexers / result
-
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft:
+    if nleft > 0:
+        while i < nleft:
             if j == nright:
-                # we are done
-                break
-            else:
-                while j < nright:
-                    lindexer[count] = -1
-                    rindexer[count] = j
-                    result[count] = right[j]
-                    j += 1
+                while i < nleft:
+                    lindexer[count] = i
+                    rindexer[count] = -1
+                    result[count] = left[i]
+                    i += 1
                     count += 1
-                break
-        elif j == nright:
-            while i < nleft:
-                lindexer[count] = i
-                rindexer[count] = -1
-                result[count] = left[i]
-                i += 1
-                count += 1
-            break
-        else:
+
             lval = left[i]
             rval = right[j]
+
             if lval == rval:
                 lindexer[count] = i
                 rindexer[count] = j
                 result[count] = lval
-                i += 1
-                j += 1
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
             elif lval < rval:
                 lindexer[count] = i
                 rindexer[count] = -1
-                result[count] = lval
-                i += 1
+                result[count] = left[i]
+                count += 1
+                if i < nleft:
+                    i += 1
             else:
-                lindexer[count] = -1
-                rindexer[count] = j
-                result[count] = rval
-                j += 1
-
-            count += 1
+                if j < nright:
+                    j += 1
 
     return result, lindexer, rindexer
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
-def outer_join_indexer_int64(ndarray[int64_t] left,
-                                ndarray[int64_t] right):
+def left_join_indexer_int64(ndarray[int64_t] left,
+                              ndarray[int64_t] right):
+    '''
+    Two-pass algorithm for monotonic indexes. Handles many-to-one merges
+    '''
     cdef:
-        Py_ssize_t i, j, nright, nleft, count
+        Py_ssize_t i, j, k, nright, nleft, count
         int64_t lval, rval
         ndarray[int64_t] lindexer, rindexer
         ndarray[int64_t] result
@@ -2984,84 +3040,574 @@ def outer_join_indexer_int64(ndarray[int64_t] left,
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft:
+    if nleft > 0:
+        while True:
             if j == nright:
-                # we are done
-                break
-            else:
-                while j < nright:
-                    j += 1
-                    count += 1
+                count += nleft - i
                 break
-        elif j == nright:
-            while i < nleft:
-                i += 1
+
+            lval = left[i]
+            rval = right[j]
+
+            if lval == rval:
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
+            elif lval < rval:
+                count += 1
+                if i < nleft:
+                    i += 1
+            else:
+                if j < nright:
+                    j += 1
+
+    # do it again now that result size is known
+
+    lindexer = np.empty(count, dtype=np.int64)
+    rindexer = np.empty(count, dtype=np.int64)
+    result = np.empty(count, dtype=np.int64)
+
+    i = 0
+    j = 0
+    count = 0
+    if nleft > 0:
+        while i < nleft:
+            if j == nright:
+                while i < nleft:
+                    lindexer[count] = i
+                    rindexer[count] = -1
+                    result[count] = left[i]
+                    i += 1
+                    count += 1
+
+            lval = left[i]
+            rval = right[j]
+
+            if lval == rval:
+                lindexer[count] = i
+                rindexer[count] = j
+                result[count] = lval
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
+            elif lval < rval:
+                lindexer[count] = i
+                rindexer[count] = -1
+                result[count] = left[i]
+                count += 1
+                if i < nleft:
+                    i += 1
+            else:
+                if j < nright:
+                    j += 1
+
+    return result, lindexer, rindexer
+
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def outer_join_indexer_float64(ndarray[float64_t] left,
+                                ndarray[float64_t] right):
+    cdef:
+        Py_ssize_t i, j, nright, nleft, count
+        float64_t lval, rval
+        ndarray[int64_t] lindexer, rindexer
+        ndarray[float64_t] result
+
+    nleft = len(left)
+    nright = len(right)
+
+    i = 0
+    j = 0
+    count = 0
+    if nleft == 0:
+        count = nright
+    elif nright == 0:
+        count = nleft
+    else:
+        while True:
+            if i == nleft:
+                count += nright - j
+                break
+            if j == nright:
+                count += nleft - i
+                break
+
+            lval = left[i]
+            rval = right[j]
+            if lval == rval:
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
+            elif lval < rval:
                 count += 1
-            break
-        else:
-            if left[i] == right[j]:
                 i += 1
+            else:
+                count += 1
                 j += 1
-            elif left[i] < right[j]:
+
+    lindexer = np.empty(count, dtype=np.int64)
+    rindexer = np.empty(count, dtype=np.int64)
+    result = np.empty(count, dtype=np.float64)
+
+    # do it again, but populate the indexers / result
+
+    i = 0
+    j = 0
+    count = 0
+    if nleft == 0:
+        for j in range(nright):
+            lindexer[j] = -1
+            rindexer[j] = j
+            result[j] = right[j]
+    elif nright == 0:
+        for i in range(nright):
+            lindexer[i] = i
+            rindexer[i] = -1
+            result[i] = left[i]
+    else:
+        while True:
+            if i == nleft:
+                while j < nright:
+                    lindexer[count] = -1
+                    rindexer[count] = j
+                    result[count] = right[j]
+                    count += 1
+                    j += 1
+                break
+            if j == nright:
+                while i < nleft:
+                    lindexer[count] = i
+                    rindexer[count] = -1
+                    result[count] = left[i]
+                    count += 1
+                    i += 1
+                break
+
+            lval = left[i]
+            rval = right[j]
+
+            if lval == rval:
+                lindexer[count] = i
+                rindexer[count] = j
+                result[count] = lval
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    break
+            elif lval < rval:
+                lindexer[count] = i
+                rindexer[count] = -1
+                result[count] = lval
+                count += 1
                 i += 1
             else:
+                lindexer[count] = -1
+                rindexer[count] = j
+                result[count] = rval
+                count += 1
                 j += 1
 
-            count += 1
+    return result, lindexer, rindexer
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def outer_join_indexer_object(ndarray[object] left,
+                                ndarray[object] right):
+    cdef:
+        Py_ssize_t i, j, nright, nleft, count
+        object lval, rval
+        ndarray[int64_t] lindexer, rindexer
+        ndarray[object] result
+
+    nleft = len(left)
+    nright = len(right)
+
+    i = 0
+    j = 0
+    count = 0
+    if nleft == 0:
+        count = nright
+    elif nright == 0:
+        count = nleft
+    else:
+        while True:
+            if i == nleft:
+                count += nright - j
+                break
+            if j == nright:
+                count += nleft - i
+                break
+
+            lval = left[i]
+            rval = right[j]
+            if lval == rval:
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
+            elif lval < rval:
+                count += 1
+                i += 1
+            else:
+                count += 1
+                j += 1
 
     lindexer = np.empty(count, dtype=np.int64)
     rindexer = np.empty(count, dtype=np.int64)
-    result = np.empty(count, dtype=np.int64)
+    result = np.empty(count, dtype=object)
 
     # do it again, but populate the indexers / result
 
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft:
+    if nleft == 0:
+        for j in range(nright):
+            lindexer[j] = -1
+            rindexer[j] = j
+            result[j] = right[j]
+    elif nright == 0:
+        for i in range(nright):
+            lindexer[i] = i
+            rindexer[i] = -1
+            result[i] = left[i]
+    else:
+        while True:
+            if i == nleft:
+                while j < nright:
+                    lindexer[count] = -1
+                    rindexer[count] = j
+                    result[count] = right[j]
+                    count += 1
+                    j += 1
+                break
+            if j == nright:
+                while i < nleft:
+                    lindexer[count] = i
+                    rindexer[count] = -1
+                    result[count] = left[i]
+                    count += 1
+                    i += 1
+                break
+
+            lval = left[i]
+            rval = right[j]
+
+            if lval == rval:
+                lindexer[count] = i
+                rindexer[count] = j
+                result[count] = lval
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    break
+            elif lval < rval:
+                lindexer[count] = i
+                rindexer[count] = -1
+                result[count] = lval
+                count += 1
+                i += 1
+            else:
+                lindexer[count] = -1
+                rindexer[count] = j
+                result[count] = rval
+                count += 1
+                j += 1
+
+    return result, lindexer, rindexer
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def outer_join_indexer_int32(ndarray[int32_t] left,
+                                ndarray[int32_t] right):
+    cdef:
+        Py_ssize_t i, j, nright, nleft, count
+        int32_t lval, rval
+        ndarray[int64_t] lindexer, rindexer
+        ndarray[int32_t] result
+
+    nleft = len(left)
+    nright = len(right)
+
+    i = 0
+    j = 0
+    count = 0
+    if nleft == 0:
+        count = nright
+    elif nright == 0:
+        count = nleft
+    else:
+        while True:
+            if i == nleft:
+                count += nright - j
+                break
             if j == nright:
-                # we are done
+                count += nleft - i
                 break
+
+            lval = left[i]
+            rval = right[j]
+            if lval == rval:
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
+            elif lval < rval:
+                count += 1
+                i += 1
             else:
+                count += 1
+                j += 1
+
+    lindexer = np.empty(count, dtype=np.int64)
+    rindexer = np.empty(count, dtype=np.int64)
+    result = np.empty(count, dtype=np.int32)
+
+    # do it again, but populate the indexers / result
+
+    i = 0
+    j = 0
+    count = 0
+    if nleft == 0:
+        for j in range(nright):
+            lindexer[j] = -1
+            rindexer[j] = j
+            result[j] = right[j]
+    elif nright == 0:
+        for i in range(nright):
+            lindexer[i] = i
+            rindexer[i] = -1
+            result[i] = left[i]
+    else:
+        while True:
+            if i == nleft:
                 while j < nright:
                     lindexer[count] = -1
                     rindexer[count] = j
                     result[count] = right[j]
+                    count += 1
                     j += 1
+                break
+            if j == nright:
+                while i < nleft:
+                    lindexer[count] = i
+                    rindexer[count] = -1
+                    result[count] = left[i]
                     count += 1
+                    i += 1
                 break
-        elif j == nright:
-            while i < nleft:
+
+            lval = left[i]
+            rval = right[j]
+
+            if lval == rval:
+                lindexer[count] = i
+                rindexer[count] = j
+                result[count] = lval
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    break
+            elif lval < rval:
                 lindexer[count] = i
                 rindexer[count] = -1
-                result[count] = left[i]
+                result[count] = lval
+                count += 1
                 i += 1
+            else:
+                lindexer[count] = -1
+                rindexer[count] = j
+                result[count] = rval
                 count += 1
-            break
-        else:
+                j += 1
+
+    return result, lindexer, rindexer
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def outer_join_indexer_int64(ndarray[int64_t] left,
+                                ndarray[int64_t] right):
+    cdef:
+        Py_ssize_t i, j, nright, nleft, count
+        int64_t lval, rval
+        ndarray[int64_t] lindexer, rindexer
+        ndarray[int64_t] result
+
+    nleft = len(left)
+    nright = len(right)
+
+    i = 0
+    j = 0
+    count = 0
+    if nleft == 0:
+        count = nright
+    elif nright == 0:
+        count = nleft
+    else:
+        while True:
+            if i == nleft:
+                count += nright - j
+                break
+            if j == nright:
+                count += nleft - i
+                break
+
+            lval = left[i]
+            rval = right[j]
+            if lval == rval:
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    # end of the road
+                    break
+            elif lval < rval:
+                count += 1
+                i += 1
+            else:
+                count += 1
+                j += 1
+
+    lindexer = np.empty(count, dtype=np.int64)
+    rindexer = np.empty(count, dtype=np.int64)
+    result = np.empty(count, dtype=np.int64)
+
+    # do it again, but populate the indexers / result
+
+    i = 0
+    j = 0
+    count = 0
+    if nleft == 0:
+        for j in range(nright):
+            lindexer[j] = -1
+            rindexer[j] = j
+            result[j] = right[j]
+    elif nright == 0:
+        for i in range(nright):
+            lindexer[i] = i
+            rindexer[i] = -1
+            result[i] = left[i]
+    else:
+        while True:
+            if i == nleft:
+                while j < nright:
+                    lindexer[count] = -1
+                    rindexer[count] = j
+                    result[count] = right[j]
+                    count += 1
+                    j += 1
+                break
+            if j == nright:
+                while i < nleft:
+                    lindexer[count] = i
+                    rindexer[count] = -1
+                    result[count] = left[i]
+                    count += 1
+                    i += 1
+                break
+
             lval = left[i]
             rval = right[j]
+
             if lval == rval:
                 lindexer[count] = i
                 rindexer[count] = j
                 result[count] = lval
-                i += 1
-                j += 1
+                count += 1
+                if i < nleft - 1:
+                    i += 1
+                    if left[i] != rval:
+                        j += 1
+                elif j < nright - 1:
+                    j += 1
+                    if lval != right[j]:
+                        i += 1
+                else:
+                    break
             elif lval < rval:
                 lindexer[count] = i
                 rindexer[count] = -1
                 result[count] = lval
+                count += 1
                 i += 1
             else:
                 lindexer[count] = -1
                 rindexer[count] = j
                 result[count] = rval
+                count += 1
                 j += 1
 
-            count += 1
-
     return result, lindexer, rindexer
 
 
@@ -3070,7 +3616,7 @@ def outer_join_indexer_int64(ndarray[int64_t] left,
 def inner_join_indexer_float64(ndarray[float64_t] left,
                               ndarray[float64_t] right):
     '''
-    Two-pass algorithm?
+    Two-pass algorithm for monotonic indexes. Handles many-to-one merges
     '''
     cdef:
         Py_ssize_t i, j, k, nright, nleft, count
@@ -3084,20 +3630,32 @@ def inner_join_indexer_float64(ndarray[float64_t] left,
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft or j == nright:
-             break
-        else:
-            lval = left[i]
-            rval = right[j]
+    if nleft > 0 and nright > 0:
+        lval = left[0]
+        rval = right[0]
+        while True:
             if lval == rval:
-                i += 1
-                j += 1
                 count += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                elif j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
             elif lval < rval:
-                i += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                else:
+                    break
             else:
-                j += 1
+                if j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
 
     # do it again now that result size is known
 
@@ -3108,23 +3666,35 @@ def inner_join_indexer_float64(ndarray[float64_t] left,
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft or j == nright:
-             break
-        else:
-            lval = left[i]
-            rval = right[j]
+    if nleft > 0 and nright > 0:
+        lval = left[0]
+        rval = right[0]
+        while True:
             if lval == rval:
                 lindexer[count] = i
                 rindexer[count] = j
-                result[count] = lval
-                i += 1
-                j += 1
+                result[count] = rval
                 count += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                elif j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
             elif lval < rval:
-                i += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                else:
+                    break
             else:
-                j += 1
+                if j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
 
     return result, lindexer, rindexer
 
@@ -3133,7 +3703,7 @@ def inner_join_indexer_float64(ndarray[float64_t] left,
 def inner_join_indexer_object(ndarray[object] left,
                               ndarray[object] right):
     '''
-    Two-pass algorithm?
+    Two-pass algorithm for monotonic indexes. Handles many-to-one merges
     '''
     cdef:
         Py_ssize_t i, j, k, nright, nleft, count
@@ -3147,20 +3717,32 @@ def inner_join_indexer_object(ndarray[object] left,
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft or j == nright:
-             break
-        else:
-            lval = left[i]
-            rval = right[j]
+    if nleft > 0 and nright > 0:
+        lval = left[0]
+        rval = right[0]
+        while True:
             if lval == rval:
-                i += 1
-                j += 1
                 count += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                elif j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
             elif lval < rval:
-                i += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                else:
+                    break
             else:
-                j += 1
+                if j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
 
     # do it again now that result size is known
 
@@ -3171,23 +3753,35 @@ def inner_join_indexer_object(ndarray[object] left,
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft or j == nright:
-             break
-        else:
-            lval = left[i]
-            rval = right[j]
+    if nleft > 0 and nright > 0:
+        lval = left[0]
+        rval = right[0]
+        while True:
             if lval == rval:
                 lindexer[count] = i
                 rindexer[count] = j
-                result[count] = lval
-                i += 1
-                j += 1
+                result[count] = rval
                 count += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                elif j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
             elif lval < rval:
-                i += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                else:
+                    break
             else:
-                j += 1
+                if j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
 
     return result, lindexer, rindexer
 
@@ -3196,7 +3790,7 @@ def inner_join_indexer_object(ndarray[object] left,
 def inner_join_indexer_int32(ndarray[int32_t] left,
                               ndarray[int32_t] right):
     '''
-    Two-pass algorithm?
+    Two-pass algorithm for monotonic indexes. Handles many-to-one merges
     '''
     cdef:
         Py_ssize_t i, j, k, nright, nleft, count
@@ -3210,20 +3804,32 @@ def inner_join_indexer_int32(ndarray[int32_t] left,
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft or j == nright:
-             break
-        else:
-            lval = left[i]
-            rval = right[j]
+    if nleft > 0 and nright > 0:
+        lval = left[0]
+        rval = right[0]
+        while True:
             if lval == rval:
-                i += 1
-                j += 1
                 count += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                elif j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
             elif lval < rval:
-                i += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                else:
+                    break
             else:
-                j += 1
+                if j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
 
     # do it again now that result size is known
 
@@ -3234,23 +3840,35 @@ def inner_join_indexer_int32(ndarray[int32_t] left,
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft or j == nright:
-             break
-        else:
-            lval = left[i]
-            rval = right[j]
+    if nleft > 0 and nright > 0:
+        lval = left[0]
+        rval = right[0]
+        while True:
             if lval == rval:
                 lindexer[count] = i
                 rindexer[count] = j
-                result[count] = lval
-                i += 1
-                j += 1
+                result[count] = rval
                 count += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                elif j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
             elif lval < rval:
-                i += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                else:
+                    break
             else:
-                j += 1
+                if j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
 
     return result, lindexer, rindexer
 
@@ -3259,7 +3877,7 @@ def inner_join_indexer_int32(ndarray[int32_t] left,
 def inner_join_indexer_int64(ndarray[int64_t] left,
                               ndarray[int64_t] right):
     '''
-    Two-pass algorithm?
+    Two-pass algorithm for monotonic indexes. Handles many-to-one merges
     '''
     cdef:
         Py_ssize_t i, j, k, nright, nleft, count
@@ -3273,20 +3891,32 @@ def inner_join_indexer_int64(ndarray[int64_t] left,
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft or j == nright:
-             break
-        else:
-            lval = left[i]
-            rval = right[j]
+    if nleft > 0 and nright > 0:
+        lval = left[0]
+        rval = right[0]
+        while True:
             if lval == rval:
-                i += 1
-                j += 1
                 count += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                elif j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
             elif lval < rval:
-                i += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                else:
+                    break
             else:
-                j += 1
+                if j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
 
     # do it again now that result size is known
 
@@ -3297,65 +3927,36 @@ def inner_join_indexer_int64(ndarray[int64_t] left,
     i = 0
     j = 0
     count = 0
-    while True:
-        if i == nleft or j == nright:
-             break
-        else:
-            lval = left[i]
-            rval = right[j]
+    if nleft > 0 and nright > 0:
+        lval = left[0]
+        rval = right[0]
+        while True:
             if lval == rval:
                 lindexer[count] = i
                 rindexer[count] = j
-                result[count] = lval
-                i += 1
-                j += 1
+                result[count] = rval
                 count += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                elif j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
             elif lval < rval:
-                i += 1
+                if i < nleft - 1:
+                    i += 1
+                    lval = left[i]
+                else:
+                    break
             else:
-                j += 1
+                if j < nright - 1:
+                    j += 1
+                    rval = right[j]
+                else:
+                    break
 
     return result, lindexer, rindexer
 
 
-
-cpdef ensure_float64(object arr):
-    if util.is_array(arr):
-        if (<ndarray> arr).descr.type_num == NPY_FLOAT64:
-            return arr
-        else:
-            return arr.astype(np.float64)
-    else:
-        return np.array(arr, dtype=np.float64)
-
-
-cpdef ensure_int32(object arr):
-    if util.is_array(arr):
-        if (<ndarray> arr).descr.type_num == NPY_INT32:
-            return arr
-        else:
-            return arr.astype(np.int32)
-    else:
-        return np.array(arr, dtype=np.int32)
-
-
-cpdef ensure_int64(object arr):
-    if util.is_array(arr):
-        if (<ndarray> arr).descr.type_num == NPY_INT64:
-            return arr
-        else:
-            return arr.astype(np.int64)
-    else:
-        return np.array(arr, dtype=np.int64)
-
-
-cpdef ensure_object(object arr):
-    if util.is_array(arr):
-        if (<ndarray> arr).descr.type_num == NPY_OBJECT:
-            return arr
-        else:
-            return arr.astype(np.object_)
-    else:
-        return np.array(arr, dtype=np.object_)
-
-
diff --git a/pandas/tests/test_tseries.py b/pandas/tests/test_tseries.py
index a29f44127..cc43edd6d 100644
--- a/pandas/tests/test_tseries.py
+++ b/pandas/tests/test_tseries.py
@@ -59,11 +59,11 @@ class TestTseriesUtil(unittest.TestCase):
         expect_filler = [-1, -1, -1, -1, -1]
         self.assert_(np.array_equal(filler, expect_filler))
 
-def test_left_join_indexer():
+def test_left_join_indexer_unique():
     a = np.array([1, 2, 3, 4, 5], dtype=np.int64)
     b = np.array([2, 2, 3, 4, 4], dtype=np.int64)
 
-    result = algos.left_join_indexer_int64(b, a)
+    result = algos.left_join_indexer_unique_int64(b, a)
     expected = np.array([1, 1, 2, 3, 3], dtype=np.int64)
     assert(np.array_equal(result, expected))
 
@@ -102,6 +102,14 @@ def test_inner_join_indexer():
     assert_almost_equal(ares, aexp)
     assert_almost_equal(bres, bexp)
 
+    a = np.array([5], dtype=np.int64)
+    b = np.array([5], dtype=np.int64)
+
+    index, ares, bres = algos.inner_join_indexer_int64(a, b)
+    assert_almost_equal(index, [5])
+    assert_almost_equal(ares, [0])
+    assert_almost_equal(bres, [0])
+
 def test_outer_join_indexer():
     a = np.array([1, 2, 3, 4, 5], dtype=np.int64)
     b = np.array([0, 3, 5, 7, 9], dtype=np.int64)
@@ -116,6 +124,20 @@ def test_outer_join_indexer():
     assert_almost_equal(ares, aexp)
     assert_almost_equal(bres, bexp)
 
+def test_left_join_indexer():
+    a = np.array([1, 2, 3, 4, 5], dtype=np.int64)
+    b = np.array([0, 3, 5, 7, 9], dtype=np.int64)
+
+    index, ares, bres = algos.left_join_indexer_int64(a, b)
+
+    assert_almost_equal(index, a)
+
+    aexp = np.array([0, 1, 2, 3, 4], dtype=np.int64)
+    bexp = np.array([-1, -1, 1, -1, 2], dtype=np.int64)
+    assert_almost_equal(ares, aexp)
+    assert_almost_equal(bres, bexp)
+
+
 def test_is_lexsorted():
     failure = [
         np.array([3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index abdbd5e96..947892bbe 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -561,6 +561,56 @@ class TestMerge(unittest.TestCase):
         merged = merge(left, right, left_index=True, right_on=key, how='outer')
         self.assert_(np.array_equal(merged['key_0'], key))
 
+    def test_mixed_type_join_with_suffix(self):
+        # GH #916
+        df = DataFrame(np.random.randn(20, 6),
+                       columns=['a', 'b', 'c', 'd', 'e', 'f'])
+        df.insert(0, 'id', 0)
+        df.insert(5, 'dt', 'foo')
+
+        grouped = df.groupby('id')
+        mn = grouped.mean()
+        cn = grouped.count()
+
+        # it works!
+        mn.join(cn, rsuffix='_right')
+
+    def test_no_overlap_more_informative_error(self):
+        dt = datetime.now()
+        df1 = DataFrame({'x': ['a']}, index=[dt])
+
+        df2 = DataFrame({'y': ['b', 'c']}, index=[dt, dt])
+        self.assertRaises(MergeError, merge, df1, df2)
+
+    def test_merge_non_unique_indexes(self):
+        dt = datetime.now()
+        df1 = DataFrame({'x': ['a']}, index=[dt])
+        df2 = DataFrame({'y': ['b', 'c']}, index=[dt, dt])
+
+        for how in ['inner', 'left', 'outer']:
+            result = df1.join(df2, how=how)
+
+            expected = merge(df1.reset_index(), df2.reset_index(),
+                             how=how)
+            expected = expected.set_index('index')
+
+            assert_frame_equal(result, expected)
+
+    # def test_merge_many_to_many(self):
+    #     dt = datetime.now()
+    #     df1 = DataFrame({'x': ['a', 'b']}, index=[dt, dt])
+    #     df2 = DataFrame({'y': ['c', 'd']}, index=[dt, dt])
+
+    #     for how in ['inner', 'left', 'outer']:
+    #         result = df1.join(df2, how=how)
+
+    #         expected = merge(df1.reset_index(), df2.reset_index(),
+    #                          how=how)
+    #         expected = expected.set_index('index')
+
+    #         assert_frame_equal(result, expected)
+
+
 class TestMergeMulti(unittest.TestCase):
 
     def setUp(self):
@@ -657,26 +707,6 @@ class TestMergeMulti(unittest.TestCase):
         expected = left.join(rdf)
         tm.assert_frame_equal(merged, expected)
 
-    def test_mixed_type_join_with_suffix(self):
-        # GH #916
-        df = DataFrame(np.random.randn(20, 6),
-                       columns=['a', 'b', 'c', 'd', 'e', 'f'])
-        df.insert(0, 'id', 0)
-        df.insert(5, 'dt', 'foo')
-
-        grouped = df.groupby('id')
-        mn = grouped.mean()
-        cn = grouped.count()
-
-        # it works!
-        mn.join(cn, rsuffix='_right')
-
-    def test_no_overlap_more_informative_error(self):
-        dt = datetime.now()
-        df1 = DataFrame({'x': ['a']}, index=[dt])
-
-        df2 = DataFrame({'y': ['b', 'c']}, index=[dt, dt])
-        self.assertRaises(MergeError, merge, df1, df2)
 
 def _check_join(left, right, result, join_col, how='left',
                 lsuffix='_x', rsuffix='_y'):
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 97eb323db..9dec29a52 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -148,8 +148,9 @@ class DatetimeIndex(Int64Index):
 
     _inner_indexer = _join_i8_wrapper(_algos.inner_join_indexer_int64)
     _outer_indexer = _join_i8_wrapper(_algos.outer_join_indexer_int64)
-    _left_indexer  = _join_i8_wrapper(_algos.left_join_indexer_int64,
-                                      with_indexers=False)
+    _left_indexer  = _join_i8_wrapper(_algos.left_join_indexer_int64)
+    _left_indexer_unique  = _join_i8_wrapper(
+        _algos.left_join_indexer_unique_int64, with_indexers=False)
     _groupby = lib.groupby_arrays # _wrap_i8_function(lib.groupby_int64)
 
     _arrmap = _wrap_dt_function(_algos.arrmap_object)

commit d2064793087ccce7265829d9bb54ec6e0bbb0446
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Mar 3 07:27:17 2020 -0800

    REF: remove _convert_scalar_indexer (#31962)

diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index af6cbd0e9..0b9a29ec0 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -3078,48 +3078,6 @@ class Index(IndexOpsMixin, PandasObject):
         # GH#10331
         return key
 
-    def _convert_scalar_indexer(self, key, kind: str_t):
-        """
-        Convert a scalar indexer.
-
-        Parameters
-        ----------
-        key : label of the slice bound
-        kind : {'loc', 'getitem'}
-        """
-        assert kind in ["loc", "getitem"]
-
-        if len(self) and not isinstance(self, ABCMultiIndex):
-
-            # we can raise here if we are definitive that this
-            # is positional indexing (eg. .loc on with a float)
-            # or label indexing if we are using a type able
-            # to be represented in the index
-
-            if kind == "getitem" and is_float(key):
-                if not self.is_floating():
-                    raise KeyError(key)
-
-            elif kind == "loc" and is_float(key):
-
-                # we want to raise KeyError on string/mixed here
-                # technically we *could* raise a TypeError
-                # on anything but mixed though
-                if self.inferred_type not in [
-                    "floating",
-                    "mixed-integer-float",
-                    "integer-na",
-                    "string",
-                    "mixed",
-                ]:
-                    raise KeyError(key)
-
-            elif kind == "loc" and is_integer(key):
-                if not (is_integer_dtype(self.dtype) or is_object_dtype(self.dtype)):
-                    raise KeyError(key)
-
-        return key
-
     def _validate_positional_slice(self, key: slice):
         """
         For positional indexing, a slice must have either int or None
diff --git a/pandas/core/indexes/category.py b/pandas/core/indexes/category.py
index 8c2d7f4aa..d43ae8eb5 100644
--- a/pandas/core/indexes/category.py
+++ b/pandas/core/indexes/category.py
@@ -574,16 +574,6 @@ class CategoricalIndex(ExtensionIndex, accessor.PandasDelegate):
         indexer, missing = self._engine.get_indexer_non_unique(codes)
         return ensure_platform_int(indexer), missing
 
-    @Appender(Index._convert_scalar_indexer.__doc__)
-    def _convert_scalar_indexer(self, key, kind: str):
-        assert kind in ["loc", "getitem"]
-        if kind == "loc":
-            try:
-                return self.categories._convert_scalar_indexer(key, kind="loc")
-            except TypeError:
-                raise KeyError(key)
-        return super()._convert_scalar_indexer(key, kind=kind)
-
     @Appender(Index._convert_list_indexer.__doc__)
     def _convert_list_indexer(self, keyarr):
         # Return our indexer or raise if all of the values are not included in
diff --git a/pandas/core/indexes/datetimelike.py b/pandas/core/indexes/datetimelike.py
index d1e21a2fe..894e1d95a 100644
--- a/pandas/core/indexes/datetimelike.py
+++ b/pandas/core/indexes/datetimelike.py
@@ -18,7 +18,6 @@ from pandas.core.dtypes.common import (
     is_bool_dtype,
     is_categorical_dtype,
     is_dtype_equal,
-    is_float,
     is_integer,
     is_list_like,
     is_period_dtype,
@@ -377,32 +376,6 @@ class DatetimeIndexOpsMixin(ExtensionIndex):
     # --------------------------------------------------------------------
     # Indexing Methods
 
-    def _convert_scalar_indexer(self, key, kind: str):
-        """
-        We don't allow integer or float indexing on datetime-like when using
-        loc.
-
-        Parameters
-        ----------
-        key : label of the slice bound
-        kind : {'loc', 'getitem'}
-        """
-        assert kind in ["loc", "getitem"]
-
-        if not is_scalar(key):
-            raise TypeError(key)
-
-        # we don't allow integer/float indexing for loc
-        # we don't allow float indexing for getitem
-        is_int = is_integer(key)
-        is_flt = is_float(key)
-        if kind == "loc" and (is_int or is_flt):
-            raise KeyError(key)
-        elif kind == "getitem" and is_flt:
-            raise KeyError(key)
-
-        return super()._convert_scalar_indexer(key, kind=kind)
-
     def _validate_partial_date_slice(self, reso: str):
         raise NotImplementedError
 
diff --git a/pandas/core/indexes/interval.py b/pandas/core/indexes/interval.py
index d396d1c76..6968837fb 100644
--- a/pandas/core/indexes/interval.py
+++ b/pandas/core/indexes/interval.py
@@ -514,12 +514,6 @@ class IntervalIndex(IntervalMixin, ExtensionIndex):
         #  positional in this case
         return self.dtype.subtype.kind in ["m", "M"]
 
-    @Appender(Index._convert_scalar_indexer.__doc__)
-    def _convert_scalar_indexer(self, key, kind: str):
-        assert kind in ["getitem", "loc"]
-        # never iloc, so no-op
-        return key
-
     def _maybe_cast_slice_bound(self, label, side, kind):
         return getattr(self, side)._maybe_cast_slice_bound(label, side, kind)
 
diff --git a/pandas/core/indexes/numeric.py b/pandas/core/indexes/numeric.py
index 06a26cc90..cb6f68ae0 100644
--- a/pandas/core/indexes/numeric.py
+++ b/pandas/core/indexes/numeric.py
@@ -254,14 +254,6 @@ class IntegerIndex(NumericIndex):
         # do not cache or you'll create a memory leak
         return self.values.view(self._default_dtype)
 
-    @Appender(Index._convert_scalar_indexer.__doc__)
-    def _convert_scalar_indexer(self, key, kind: str):
-        assert kind in ["loc", "getitem"]
-
-        # never iloc, which we don't coerce to integers
-        key = self._maybe_cast_indexer(key)
-        return super()._convert_scalar_indexer(key, kind=kind)
-
 
 class Int64Index(IntegerIndex):
     __doc__ = _num_index_shared_docs["class_descr"] % _int64_descr_args
@@ -391,12 +383,6 @@ class Float64Index(NumericIndex):
     def _should_fallback_to_positional(self):
         return False
 
-    @Appender(Index._convert_scalar_indexer.__doc__)
-    def _convert_scalar_indexer(self, key, kind: str):
-        assert kind in ["loc", "getitem"]
-        # no-op for non-iloc
-        return key
-
     @Appender(Index._convert_slice_indexer.__doc__)
     def _convert_slice_indexer(self, key: slice, kind: str):
         assert kind in ["loc", "getitem"]
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 35e61ab6a..9a671c7fc 100755
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -866,16 +866,7 @@ class _LocIndexer(_LocationIndexer):
         # slice of labels (where start-end in labels)
         # slice of integers (only if in the labels)
         # boolean
-
-        if isinstance(key, slice):
-            return
-
-        if com.is_bool_indexer(key):
-            return
-
-        if not is_list_like_indexer(key):
-            labels = self.obj._get_axis(axis)
-            labels._convert_scalar_indexer(key, kind="loc")
+        pass
 
     def _has_valid_setitem_indexer(self, indexer) -> bool:
         return True
@@ -1139,15 +1130,6 @@ class _LocIndexer(_LocationIndexer):
         if isinstance(key, slice):
             return labels._convert_slice_indexer(key, kind="loc")
 
-        if is_scalar(key):
-            # try to find out correct indexer, if not type correct raise
-            try:
-                key = labels._convert_scalar_indexer(key, kind="loc")
-            except KeyError:
-                # but we will allow setting
-                if not is_setter:
-                    raise
-
         # see if we are positional in nature
         is_int_index = labels.is_integer()
         is_int_positional = is_integer(key) and not is_int_index
@@ -2029,11 +2011,17 @@ class _AtIndexer(_ScalarAccessIndexer):
         if is_setter:
             return list(key)
 
-        lkey = list(key)
-        for n, (ax, i) in enumerate(zip(self.obj.axes, key)):
-            lkey[n] = ax._convert_scalar_indexer(i, kind="loc")
+        return key
 
-        return tuple(lkey)
+    def __getitem__(self, key):
+        if self.ndim != 1 or not is_scalar(key):
+            # FIXME: is_scalar check is a kludge
+            return super().__getitem__(key)
+
+        # Like Index.get_value, but we do not allow positional fallback
+        obj = self.obj
+        loc = obj.index.get_loc(key)
+        return obj.index._get_values_for_loc(obj, loc, key)
 
 
 @Appender(IndexingMixin.iat.__doc__)
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 19b247466..db63e9205 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -852,9 +852,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
             return self
 
         key_is_scalar = is_scalar(key)
-        if key_is_scalar:
-            key = self.index._convert_scalar_indexer(key, kind="getitem")
-        elif isinstance(key, (list, tuple)):
+        if isinstance(key, (list, tuple)):
             key = unpack_1tuple(key)
 
         if key_is_scalar or isinstance(self.index, MultiIndex):
@@ -974,8 +972,6 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
 
         # Similar to Index.get_value, but we do not fall back to positional
         loc = self.index.get_loc(label)
-        # We assume that _convert_scalar_indexer has already been called,
-        #  with kind="loc", if necessary, by the time we get here
         return self.index._get_values_for_loc(self, loc, label)
 
     def __setitem__(self, key, value):

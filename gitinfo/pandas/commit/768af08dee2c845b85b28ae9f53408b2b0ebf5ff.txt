commit 768af08dee2c845b85b28ae9f53408b2b0ebf5ff
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Dec 5 15:39:29 2011 -0500

    ENH: refactoring and micro-optimizations to support #437, uncovered panel bug

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 90d51c087..c01f4a05f 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -25,7 +25,7 @@ import numpy.ma as ma
 from pandas.core.common import (isnull, notnull, PandasError, _try_sort,
                                 _default_index, _stringify, _maybe_upcast)
 from pandas.core.daterange import DateRange
-from pandas.core.generic import NDFrame
+from pandas.core.generic import NDFrame, AxisProperty
 from pandas.core.index import Index, MultiIndex, NULL_INDEX, _ensure_index
 from pandas.core.indexing import _NDFrameIndexer, _maybe_droplevels
 from pandas.core.internals import BlockManager, make_block, form_blocks
@@ -209,8 +209,7 @@ class DataFrame(NDFrame):
         else:
             raise PandasError('DataFrame constructor not properly called!')
 
-        self._data = mgr
-        self._series_cache = {}
+        NDFrame.__init__(self, mgr)
 
     def _init_dict(self, data, index, columns, dtype=None):
         """
@@ -790,28 +789,9 @@ class DataFrame(NDFrame):
     #----------------------------------------------------------------------
     # properties for index and columns
 
-    def _get_columns(self):
-        return self._data.axes[0]
 
-    def _set_columns(self, value):
-        self._data.set_axis(0, value)
-        self._clear_caches()
-    columns = property(fset=_set_columns, fget=_get_columns)
-
-    def _get_index(self):
-        return self._data.axes[1]
-
-    def _set_index(self, value):
-        self._data.set_axis(1, value)
-        self._clear_caches()
-    index = property(fset=_set_index, fget=_get_index)
-
-    def _clear_caches(self):
-        self._series_cache.clear()
-
-    def _consolidate_inplace(self):
-        self._clear_caches()
-        NDFrame._consolidate_inplace(self)
+    columns = AxisProperty(0)
+    index = AxisProperty(1)
 
     def as_matrix(self, columns=None):
         """
@@ -859,7 +839,9 @@ class DataFrame(NDFrame):
         else:  # pragma: no cover
             # old pickling format, for compatibility
             self._unpickle_matrix_compat(state)
-        self._series_cache = {}
+
+        # ordinarily created in NDFrame
+        self._item_cache = {}
 
     # legacy pickle formats
     def _unpickle_frame_compat(self, state):  # pragma: no cover
@@ -919,13 +901,11 @@ class DataFrame(NDFrame):
         -------
         element : scalar value
         """
-        iloc = self.index.get_loc(index)
-        vals = self._getitem_single(col).values
-        result = vals[iloc]
-        assert(not lib.is_array(result)) # a little faster than isinstance
-        return result
+        series = self._get_item_cache(col)
+        engine = self.index._engine
+        return engine.get_value(series, index)
 
-    def put_value(self, index, col, value):
+    def set_value(self, index, col, value):
         """
         Put single value at passed column and index
 
@@ -935,9 +915,9 @@ class DataFrame(NDFrame):
         col : column label
         value : scalar value
         """
-        iloc = self.index.get_loc(index)
-        vals = self._getitem_single(col).values
-        vals[iloc] = value
+        series = self._get_item_cache(col)
+        engine = self.index._engine
+        return engine.set_value(series, index, value)
 
     def __getitem__(self, key):
         # slice rows
@@ -956,7 +936,7 @@ class DataFrame(NDFrame):
         elif isinstance(self.columns, MultiIndex):
             return self._getitem_multilevel(key)
         else:
-            return self._getitem_single(key)
+            return self._get_item_cache(key)
 
     def _getitem_array(self, key):
         if key.dtype == np.bool_:
@@ -996,17 +976,10 @@ class DataFrame(NDFrame):
                                    columns=result_columns)
             return result
         else:
-            return self._getitem_single(key)
+            return self._get_item_cache(key)
 
-    def _getitem_single(self, key):
-        cache = self._series_cache
-        try:
-            return cache[key]
-        except:
-            values = self._data.get(key)
-            res = Series(values, index=self.index, name=key)
-            cache[key] = res
-            return res
+    def _box_item_values(self, key, values):
+        return Series(values, index=self.index, name=key)
 
     def __getattr__(self, name):
         """After regular attribute access, try looking up the name of a column.
@@ -1072,12 +1045,7 @@ class DataFrame(NDFrame):
         """
         value = self._sanitize_column(value)
         value = np.atleast_2d(value)
-        self._data.set(key, value)
-
-        try:
-            del self._series_cache[key]
-        except KeyError:
-            pass
+        NDFrame._set_item(self, key, value)
 
     def _sanitize_column(self, value):
         # Need to make sure new columns (which go into the BlockManager as new
@@ -1103,17 +1071,6 @@ class DataFrame(NDFrame):
 
         return value
 
-    def __delitem__(self, key):
-        """
-        Delete column from DataFrame
-        """
-        self._data.delete(key)
-
-        try:
-            del self._series_cache[key]
-        except KeyError:
-            pass
-
     def pop(self, item):
         """
         Return column and drop from frame. Raise KeyError if not found.
@@ -1122,9 +1079,7 @@ class DataFrame(NDFrame):
         -------
         column : Series
         """
-        result = self[item]
-        del self[item]
-        return result
+        return NDFrame.pop(self, item)
 
     # to support old APIs
     @property
@@ -1716,11 +1671,11 @@ class DataFrame(NDFrame):
 
     def _rename_index_inplace(self, mapper):
         self._data = self._data.rename_axis(mapper, axis=1)
-        self._clear_caches()
+        self._clear_item_cache()
 
     def _rename_columns_inplace(self, mapper):
         self._data = self._data.rename_items(mapper, copydata=False)
-        self._clear_caches()
+        self._clear_item_cache()
 
     #----------------------------------------------------------------------
     # Arithmetic / combination related
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 2f0deec34..87e9db4a5 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -30,8 +30,7 @@ class AxisProperty(object):
         return data.axes[self.axis]
 
     def __set__(self, obj, value):
-        data = getattr(obj, '_data')
-        data.set_axis(self.axis, value)
+        obj._set_axis(self.axis, value)
 
 class PandasObject(Picklable):
 
@@ -226,6 +225,7 @@ class NDFrame(PandasObject):
             data = data.astype(dtype)
 
         self._data = data
+        self._item_cache = {}
 
     def astype(self, dtype):
         """
@@ -260,10 +260,61 @@ class NDFrame(PandasObject):
     def ndim(self):
         return self._data.ndim
 
+    def _set_axis(self, axis, labels):
+        self._data.set_axis(axis, labels)
+        self._clear_item_cache()
+
+    def __getitem__(self, item):
+        return self._get_item_cache(item)
+
+    def _get_item_cache(self, item):
+        cache = self._item_cache
+        try:
+            return cache[item]
+        except Exception:
+            values = self._data.get(item)
+            res = self._box_item_values(item, values)
+            cache[item] = res
+            return res
+
+    def _box_item_values(self, key, values):
+        raise NotImplementedError
+
+    def _clear_item_cache(self):
+        self._item_cache.clear()
+
+    def _set_item(self, key, value):
+        self._data.set(key, value)
+
+        try:
+            del self._item_cache[key]
+        except KeyError:
+            pass
+
+    def __delitem__(self, key):
+        """
+        Delete item
+        """
+        self._data.delete(key)
+
+        try:
+            del self._item_cache[key]
+        except KeyError:
+            pass
+
+    def pop(self, item):
+        """
+        Return item and drop from frame. Raise KeyError if not found.
+        """
+        result = self[item]
+        del self[item]
+        return result
+
     #----------------------------------------------------------------------
     # Consolidation of internals
 
     def _consolidate_inplace(self):
+        self._clear_item_cache()
         self._data = self._data.consolidate()
 
     def consolidate(self):
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 540a3b3bf..e1e88a3f9 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -437,6 +437,20 @@ class Index(np.ndarray):
         """
         return self._engine.get_loc(key)
 
+    def get_value(self, arr, key):
+        """
+        Fast lookup of value from 1-dimensional ndarray. Only use this if you
+        know what you're doing
+        """
+        return self._engine.get_value(arr, key)
+
+    def put_value(self, arr, key, value):
+        """
+        Fast lookup of value from 1-dimensional ndarray. Only use this if you
+        know what you're doing
+        """
+        self._engine.put_value(arr, key, value)
+
     def get_indexer(self, target, method=None):
         """
         Compute indexer and mask for new index given the current index. The
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index f8b77a567..f2265539a 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -223,7 +223,7 @@ class Panel(NDFrame):
         else: # pragma: no cover
             raise PandasError('Panel constructor not properly called!')
 
-        self._data = mgr
+        NDFrame.__init__(self, mgr)
 
     def _init_dict(self, data, axes, dtype=None):
         items, major, minor = axes
@@ -447,9 +447,8 @@ class Panel(NDFrame):
 
     values = property(fget=_get_values)
 
-    def __getitem__(self, key):
-        mat = self._data.get(key)
-        return DataFrame(mat, index=self.major_axis, columns=self.minor_axis)
+    def _box_item_values(self, key, values):
+        return DataFrame(values, index=self.major_axis, columns=self.minor_axis)
 
     def _slice(self, slobj, axis=0):
         new_data = self._data.get_slice(slobj, axis=axis)
@@ -476,12 +475,9 @@ class Panel(NDFrame):
             mat.fill(value)
 
         mat = mat.reshape((1, N, K))
-        self._data.set(key, mat)
+        NDFrame._set_item(self, key, mat)
 
-    def __delitem__(self, key):
-        self._data.delete(key)
-
-    def pop(self, key):
+    def pop(self, item):
         """
         Return item slice from panel and delete from panel
 
@@ -494,9 +490,7 @@ class Panel(NDFrame):
         -------
         y : DataFrame
         """
-        result = self[key]
-        del self[key]
-        return result
+        return NDFrame.pop(self, item)
 
     def __getstate__(self):
         "Returned pickled representation of the panel"
@@ -510,6 +504,7 @@ class Panel(NDFrame):
             self._unpickle_panel_compat(state)
         else: # pragma: no cover
             raise ValueError('unrecognized pickle')
+        self._item_cache = {}
 
     def _unpickle_panel_compat(self, state): # pragma: no cover
         "Unpickle the panel"
diff --git a/pandas/core/series.py b/pandas/core/series.py
index c958fc23c..d64ef65c2 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -288,6 +288,43 @@ copy : boolean, default False
         except Exception:
             return self.values[key]
 
+    def get(self, label, default=None):
+        """
+        Returns value occupying requested label, default to specified
+        missing value if not present. Analogous to dict.get
+
+        Parameters
+        ----------
+        label : object
+            Label value looking for
+        default : object, optional
+            Value to return if label not in index
+
+        Returns
+        -------
+        y : scalar
+        """
+        try:
+            return self.index._engine.get_value(self, label)
+        except KeyError:
+            return default
+    get_value = get
+
+    def put_value(self, label, value):
+        """
+        Quickly set single value at passed label
+
+        Parameters
+        ----------
+        label : object
+            Partial indexing with MultiIndex not allowed
+
+        Returns
+        -------
+        element : scalar value
+        """
+        self.index._engine.put_value(self, label, value)
+
     def _multilevel_index(self, key):
         values = self.values
         try:
@@ -547,27 +584,6 @@ copy : boolean, default False
         return SparseSeries(self, kind=kind, fill_value=fill_value,
                             name=self.name)
 
-    def get(self, key, default=None):
-        """
-        Returns value occupying requested index, default to specified
-        missing value if not present. Analogous to dict.get
-
-        Parameters
-        ----------
-        key : object
-            Index value looking for
-        default : object, optional
-            Value to return if key not in index
-
-        Returns
-        -------
-        y : scalar
-        """
-        if key in self.index:
-            return self._get_val_at(self.index.get_loc(key))
-        else:
-            return default
-
     def head(self, n=5):
         """Returns first n rows of Series
         """
@@ -1075,8 +1091,15 @@ copy : boolean, default False
             new_name = _maybe_match_name(self, other)
             new_values = np.empty(len(new_index), dtype=self.dtype)
             for i, idx in enumerate(new_index):
-                new_values[i] = func(self.get(idx, fill_value),
-                                     other.get(idx, fill_value))
+                lv = self.get(idx, fill_value)
+                rv = other.get(idx, fill_value)
+
+                # not thrilled about this but...
+                try:
+                    res = func(lv, rv)
+                except Exception:
+                    res = np.nan
+                new_values[i] = res
         else:
             new_index = self.index
             new_values = func(self.values, other)
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index 78f894b47..81ede528c 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -363,6 +363,27 @@ to sparse
         new_index = Index(self.index.view(ndarray)[key])
         return self._constructor(dataSlice, index=new_index, name=self.name)
 
+    def get(self, label, default=None):
+        """
+        Returns value occupying requested label, default to specified
+        missing value if not present. Analogous to dict.get
+
+        Parameters
+        ----------
+        label : object
+            Label value looking for
+        default : object, optional
+            Value to return if label not in index
+
+        Returns
+        -------
+        y : scalar
+        """
+        if label in self.index:
+            return self._get_val_at(label)
+        else:
+            return default
+
     def _get_val_at(self, loc):
         n = len(self)
         if loc < 0:
diff --git a/pandas/src/engines.pyx b/pandas/src/engines.pyx
index d19843a67..eabfe363b 100644
--- a/pandas/src/engines.pyx
+++ b/pandas/src/engines.pyx
@@ -1,8 +1,47 @@
 from numpy cimport ndarray
+cimport numpy as cnp
+
+cdef extern from "numpy_helper.h":
+    inline int is_integer_object(object)
 
 cdef class IndexEngine:
 
-    pass
+    cpdef get_value(self, ndarray arr, object key):
+        '''
+        arr : 1-dimensional ndarray
+        '''
+        cdef:
+            Py_ssize_t loc
+            void* data_ptr
+
+        loc = self.get_loc(key)
+        assert(is_integer_object(loc))
+        data_ptr = cnp.PyArray_GETPTR1(arr, loc)
+        return cnp.PyArray_GETITEM(arr, data_ptr)
+
+    cpdef set_value(self, ndarray arr, object key, object value):
+        '''
+        arr : 1-dimensional ndarray
+        '''
+        cdef:
+            Py_ssize_t loc
+            void* data_ptr
+
+        loc = self.get_loc(key)
+        assert(is_integer_object(loc))
+        data_ptr = cnp.PyArray_GETPTR1(arr, loc)
+        cnp.PyArray_SETITEM(arr, data_ptr, value)
+
+cpdef get_value_at(ndarray arr, object loc):
+    assert(is_integer_object(loc))
+    data_ptr = cnp.PyArray_GETPTR1(arr, loc)
+    return cnp.PyArray_GETITEM(arr, data_ptr)
+
+cpdef set_value_at(ndarray arr, object loc, object value):
+    assert(is_integer_object(loc))
+    data_ptr = cnp.PyArray_GETPTR1(arr, loc)
+    cnp.PyArray_SETITEM(arr, data_ptr, value)
+
 
 cdef class DictIndexEngine(IndexEngine):
     '''
@@ -66,3 +105,4 @@ cdef class DictIndexEngine(IndexEngine):
         self._ensure_initialized()
         return self.mapping[val]
 
+
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 3b9980971..9c6c486a8 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -668,18 +668,22 @@ class CheckIndexing(object):
                 expected = self.frame[col][idx]
                 self.assertEqual(result, expected)
 
-    def test_put_value(self):
+        # partial w/ MultiIndex raise exception
+        index = MultiIndex.from_tuples([(0, 1), (0, 2), (1, 1), (1, 2)])
+
+    def test_set_value(self):
         for idx in self.frame.index:
             for col in self.frame.columns:
-                self.frame.put_value(idx, col, 1)
+                self.frame.set_value(idx, col, 1)
                 self.assertEqual(self.frame[col][idx], 1)
 
     def test_single_element_ix_dont_upcast(self):
         self.frame['E'] = 1
-        self.assert_(issubclass(self.frame['E'].dtype.type, np.integer))
+        self.assert_(issubclass(self.frame['E'].dtype.type,
+                                (int, np.integer)))
 
         result = self.frame.ix[self.frame.index[5], 'E']
-        self.assert_(isinstance(result, np.integer))
+        self.assert_(isinstance(result, (int, np.integer)))
 
 _seriesd = tm.getSeriesData()
 _tsd = tm.getTimeSeriesData()
@@ -859,6 +863,9 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
 
     def test_set_index(self):
         idx = Index(np.arange(len(self.mixed_frame)))
+
+        # cache it
+        _ = self.mixed_frame['foo']
         self.mixed_frame.index = idx
         self.assert_(self.mixed_frame['foo'].index  is idx)
         self.assertRaises(Exception, setattr, self.mixed_frame, 'index',
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index 841c5a040..e4641a719 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -148,13 +148,20 @@ class SafeForSparse(object):
         new_major = Index(np.arange(len(self.panel.major_axis)))
         new_minor = Index(np.arange(len(self.panel.minor_axis)))
 
+        # ensure propagate to potentially prior-cached items too
+        item = self.panel['ItemA']
         self.panel.items = new_items
+        self.assert_(self.panel[0] is not item)
         self.assert_(self.panel.items is new_items)
 
+        item = self.panel[0]
         self.panel.major_axis = new_major
+        self.assert_(self.panel[0].index is new_major)
         self.assert_(self.panel.major_axis is new_major)
 
+        item = self.panel[0]
         self.panel.minor_axis = new_minor
+        self.assert_(self.panel[0].columns is new_minor)
         self.assert_(self.panel.minor_axis is new_minor)
 
     def test_get_axis_number(self):
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 7de7763a4..f44e3c4c7 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -654,7 +654,6 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         def _check_op(other, op):
             cython_or_numpy = op(series, other)
             python = series.combine(other, op)
-
             tm.assert_almost_equal(cython_or_numpy, python)
 
         def check(other):

commit 1944ab8d4889cf0efb48b878766d8c79c77f5eb5
Author: Terji Petersen <contribute@tensortable.com>
Date:   Sun Aug 4 22:26:42 2019 +0100

    CLN: deprivatize names in pd.core.common (#27741)
    
    * deprivative funcs in pd.core.common
    
    * simplify all/any funcs

diff --git a/pandas/core/common.py b/pandas/core/common.py
index c12bfecc4..a507625cc 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -165,51 +165,39 @@ def cast_scalar_indexer(val):
     return val
 
 
-def _not_none(*args):
+def not_none(*args):
     """
     Returns a generator consisting of the arguments that are not None.
     """
     return (arg for arg in args if arg is not None)
 
 
-def _any_none(*args):
+def any_none(*args):
     """
     Returns a boolean indicating if any argument is None.
     """
-    for arg in args:
-        if arg is None:
-            return True
-    return False
+    return any(arg is None for arg in args)
 
 
-def _all_none(*args):
+def all_none(*args):
     """
     Returns a boolean indicating if all arguments are None.
     """
-    for arg in args:
-        if arg is not None:
-            return False
-    return True
+    return all(arg is None for arg in args)
 
 
-def _any_not_none(*args):
+def any_not_none(*args):
     """
     Returns a boolean indicating if any argument is not None.
     """
-    for arg in args:
-        if arg is not None:
-            return True
-    return False
+    return any(arg is not None for arg in args)
 
 
-def _all_not_none(*args):
+def all_not_none(*args):
     """
     Returns a boolean indicating if all arguments are not None.
     """
-    for arg in args:
-        if arg is None:
-            return False
-    return True
+    return all(arg is not None for arg in args)
 
 
 def count_not_none(*args):
@@ -447,7 +435,7 @@ def random_state(state=None):
         )
 
 
-def _pipe(obj, func, *args, **kwargs):
+def pipe(obj, func, *args, **kwargs):
     """
     Apply a function ``func`` to object ``obj`` either by passing obj as the
     first argument to the function or, in the case that the func is a tuple,
@@ -482,7 +470,7 @@ def _pipe(obj, func, *args, **kwargs):
         return func(obj, *args, **kwargs)
 
 
-def _get_rename_function(mapper):
+def get_rename_function(mapper):
     """
     Returns a function that will map names/labels, dependent if mapper
     is a dict, Series or just a function.
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 1d87a6937..9078e967b 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -1124,7 +1124,7 @@ class NDFrame(PandasObject, SelectionMixin):
             v = axes.get(self._AXIS_NAMES[axis])
             if v is None:
                 continue
-            f = com._get_rename_function(v)
+            f = com.get_rename_function(v)
             baxis = self._get_block_manager_axis(axis)
             if level is not None:
                 level = self.axes[axis]._get_level_number(level)
@@ -1312,7 +1312,7 @@ class NDFrame(PandasObject, SelectionMixin):
                 if non_mapper:
                     newnames = v
                 else:
-                    f = com._get_rename_function(v)
+                    f = com.get_rename_function(v)
                     curnames = self._get_axis(axis).names
                     newnames = [f(name) for name in curnames]
                 result._set_axis_name(newnames, axis=axis, inplace=True)
@@ -4993,7 +4993,7 @@ class NDFrame(PandasObject, SelectionMixin):
 
     @Appender(_shared_docs["pipe"] % _shared_doc_kwargs)
     def pipe(self, func, *args, **kwargs):
-        return com._pipe(self, func, *args, **kwargs)
+        return com.pipe(self, func, *args, **kwargs)
 
     _shared_docs["aggregate"] = dedent(
         """
diff --git a/pandas/core/groupby/generic.py b/pandas/core/groupby/generic.py
index 811836d0e..2ad85903b 100644
--- a/pandas/core/groupby/generic.py
+++ b/pandas/core/groupby/generic.py
@@ -361,7 +361,7 @@ class NDFrameGroupBy(GroupBy):
         # GH12824.
         def first_not_none(values):
             try:
-                return next(com._not_none(*values))
+                return next(com.not_none(*values))
             except StopIteration:
                 return None
 
diff --git a/pandas/core/groupby/groupby.py b/pandas/core/groupby/groupby.py
index 12b9cf256..ec526b338 100644
--- a/pandas/core/groupby/groupby.py
+++ b/pandas/core/groupby/groupby.py
@@ -590,7 +590,7 @@ b  2""",
     )
     @Appender(_pipe_template)
     def pipe(self, func, *args, **kwargs):
-        return com._pipe(self, func, *args, **kwargs)
+        return com.pipe(self, func, *args, **kwargs)
 
     plot = property(GroupByPlot)
 
@@ -928,7 +928,7 @@ b  2""",
         def reset_identity(values):
             # reset the identities of the components
             # of the values to prevent aliasing
-            for v in com._not_none(*values):
+            for v in com.not_none(*values):
                 ax = v._get_axis(self.axis)
                 ax._reset_identity()
             return values
diff --git a/pandas/core/indexes/api.py b/pandas/core/indexes/api.py
index a17f74286..86d55ce2e 100644
--- a/pandas/core/indexes/api.py
+++ b/pandas/core/indexes/api.py
@@ -283,7 +283,7 @@ def _get_consensus_names(indexes):
 
     # find the non-none names, need to tupleify to make
     # the set hashable, then reverse on return
-    consensus_names = {tuple(i.names) for i in indexes if com._any_not_none(*i.names)}
+    consensus_names = {tuple(i.names) for i in indexes if com.any_not_none(*i.names)}
     if len(consensus_names) == 1:
         return list(list(consensus_names)[0])
     return [None] * indexes[0].nlevels
diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index ce7b73a92..d0de99525 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -3588,8 +3588,8 @@ class Index(IndexOpsMixin, PandasObject):
         from pandas.core.reshape.merge import _restore_dropped_levels_multijoin
 
         # figure out join names
-        self_names = set(com._not_none(*self.names))
-        other_names = set(com._not_none(*other.names))
+        self_names = set(com.not_none(*self.names))
+        other_names = set(com.not_none(*other.names))
         overlap = self_names & other_names
 
         # need at least 1 in common
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index d6f0008a2..0f7f580e2 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -1569,7 +1569,7 @@ def date_range(
                   dtype='datetime64[ns]', freq='D')
     """
 
-    if freq is None and com._any_none(periods, start, end):
+    if freq is None and com.any_none(periods, start, end):
         freq = "D"
 
     dtarr = DatetimeArray._generate_range(
diff --git a/pandas/core/indexes/interval.py b/pandas/core/indexes/interval.py
index d941dc547..7a444683f 100644
--- a/pandas/core/indexes/interval.py
+++ b/pandas/core/indexes/interval.py
@@ -1318,7 +1318,7 @@ def _is_type_compatible(a, b):
         (is_number(a) and is_number(b))
         or (is_ts_compat(a) and is_ts_compat(b))
         or (is_td_compat(a) and is_td_compat(b))
-        or com._any_none(a, b)
+        or com.any_none(a, b)
     )
 
 
@@ -1416,7 +1416,7 @@ def interval_range(
     end = com.maybe_box_datetimelike(end)
     endpoint = start if start is not None else end
 
-    if freq is None and com._any_none(periods, start, end):
+    if freq is None and com.any_none(periods, start, end):
         freq = 1 if is_number(endpoint) else "D"
 
     if com.count_not_none(start, end, periods, freq) != 3:
@@ -1463,7 +1463,7 @@ def interval_range(
 
     if is_number(endpoint):
         # force consistency between start/end/freq (lower end if freq skips it)
-        if com._all_not_none(start, end, freq):
+        if com.all_not_none(start, end, freq):
             end -= (end - start) % freq
 
         # compute the period/start/end if unspecified (at most one)
@@ -1475,7 +1475,7 @@ def interval_range(
             end = start + (periods - 1) * freq
 
         breaks = np.linspace(start, end, periods)
-        if all(is_integer(x) for x in com._not_none(start, end, freq)):
+        if all(is_integer(x) for x in com.not_none(start, end, freq)):
             # np.linspace always produces float output
             breaks = maybe_downcast_to_dtype(breaks, "int64")
     else:
diff --git a/pandas/core/indexes/range.py b/pandas/core/indexes/range.py
index 16098c474..1389b0e31 100644
--- a/pandas/core/indexes/range.py
+++ b/pandas/core/indexes/range.py
@@ -110,7 +110,7 @@ class RangeIndex(Int64Index):
             return cls._simple_new(start, dtype=dtype, name=name)
 
         # validate the arguments
-        if com._all_none(start, stop, step):
+        if com.all_none(start, stop, step):
             raise TypeError("RangeIndex(...) must be called with integers")
 
         start = ensure_python_int(start) if start is not None else 0
diff --git a/pandas/core/indexes/timedeltas.py b/pandas/core/indexes/timedeltas.py
index a9f49ec8b..f2ce56253 100644
--- a/pandas/core/indexes/timedeltas.py
+++ b/pandas/core/indexes/timedeltas.py
@@ -780,7 +780,7 @@ def timedelta_range(
                 '5 days 00:00:00'],
                dtype='timedelta64[ns]', freq=None)
     """
-    if freq is None and com._any_none(periods, start, end):
+    if freq is None and com.any_none(periods, start, end):
         freq = "D"
 
     freq, freq_infer = dtl.maybe_infer_freq(freq)
diff --git a/pandas/core/internals/blocks.py b/pandas/core/internals/blocks.py
index 6d70fcfb6..2136d3d32 100644
--- a/pandas/core/internals/blocks.py
+++ b/pandas/core/internals/blocks.py
@@ -599,7 +599,7 @@ class Block(PandasObject):
 
             categories = kwargs.get("categories", None)
             ordered = kwargs.get("ordered", None)
-            if com._any_not_none(categories, ordered):
+            if com.any_not_none(categories, ordered):
                 dtype = CategoricalDtype(categories, ordered)
 
             if is_categorical_dtype(self.values):
diff --git a/pandas/core/reshape/concat.py b/pandas/core/reshape/concat.py
index ce2d2ac41..4446f27da 100644
--- a/pandas/core/reshape/concat.py
+++ b/pandas/core/reshape/concat.py
@@ -304,7 +304,7 @@ class _Concatenator:
             raise ValueError("No objects to concatenate")
 
         if keys is None:
-            objs = list(com._not_none(*objs))
+            objs = list(com.not_none(*objs))
         else:
             # #1649
             clean_keys = []
diff --git a/pandas/core/reshape/merge.py b/pandas/core/reshape/merge.py
index fc32a8f0d..f45c7693b 100644
--- a/pandas/core/reshape/merge.py
+++ b/pandas/core/reshape/merge.py
@@ -1958,7 +1958,7 @@ def _should_fill(lname, rname):
 
 
 def _any(x):
-    return x is not None and com._any_not_none(*x)
+    return x is not None and com.any_not_none(*x)
 
 
 def validate_operand(obj):
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 106bb3c7d..9e317d365 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1182,7 +1182,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
 
     def _get_values_tuple(self, key):
         # mpl hackaround
-        if com._any_none(*key):
+        if com.any_none(*key):
             return self._get_values(key)
 
         if not isinstance(self.index, MultiIndex):
diff --git a/pandas/io/formats/excel.py b/pandas/io/formats/excel.py
index 012d2d935..b9c847ad6 100644
--- a/pandas/io/formats/excel.py
+++ b/pandas/io/formats/excel.py
@@ -611,7 +611,7 @@ class ExcelFormatter:
                 self.rowcounter += 1
 
             # if index labels are not empty go ahead and dump
-            if com._any_not_none(*index_labels) and self.header is not False:
+            if com.any_not_none(*index_labels) and self.header is not False:
 
                 for cidx, name in enumerate(index_labels):
                     yield ExcelCell(self.rowcounter - 1, cidx, name, self.header_style)
diff --git a/pandas/io/formats/format.py b/pandas/io/formats/format.py
index 23c07ea72..a2a0e302d 100644
--- a/pandas/io/formats/format.py
+++ b/pandas/io/formats/format.py
@@ -1743,7 +1743,7 @@ def _trim_zeros_float(
 
 def _has_names(index: Index) -> bool:
     if isinstance(index, ABCMultiIndex):
-        return com._any_not_none(*index.names)
+        return com.any_not_none(*index.names)
     else:
         return index.name is not None
 
diff --git a/pandas/io/formats/style.py b/pandas/io/formats/style.py
index b736b978c..033d93d14 100644
--- a/pandas/io/formats/style.py
+++ b/pandas/io/formats/style.py
@@ -316,7 +316,7 @@ class Styler:
 
         if (
             self.data.index.names
-            and com._any_not_none(*self.data.index.names)
+            and com.any_not_none(*self.data.index.names)
             and not hidden_index
         ):
             index_header_row = []
@@ -1405,7 +1405,7 @@ class Styler:
         ...    .pipe(format_conversion)
         ...    .set_caption("Results with minimum conversion highlighted."))
         """
-        return com._pipe(self, func, *args, **kwargs)
+        return com.pipe(self, func, *args, **kwargs)
 
 
 def _is_visible(idx_row, idx_col, lengths):
diff --git a/pandas/io/json/_table_schema.py b/pandas/io/json/_table_schema.py
index 1e7cd54d9..b142dbf76 100644
--- a/pandas/io/json/_table_schema.py
+++ b/pandas/io/json/_table_schema.py
@@ -76,7 +76,7 @@ def as_json_table_type(x):
 
 def set_default_names(data):
     """Sets index names to 'index' for regular, or 'level_x' for Multi"""
-    if com._all_not_none(*data.index.names):
+    if com.all_not_none(*data.index.names):
         nms = data.index.names
         if len(nms) == 1 and data.index.name == "index":
             warnings.warn("Index name of 'index' is not round-trippable")
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 415cb5047..abc8a414e 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -998,7 +998,7 @@ class HDFStore:
                 return None
 
         # remove the node
-        if com._all_none(where, start, stop):
+        if com.all_none(where, start, stop):
             s.group._f_remove(recursive=True)
 
         # delete from the table
@@ -2634,7 +2634,7 @@ class Fixed:
         support fully deleting the node in its entirety (only) - where
         specification must be None
         """
-        if com._all_none(where, start, stop):
+        if com.all_none(where, start, stop):
             self._handle.remove_node(self.group, recursive=True)
             return None
 
diff --git a/pandas/plotting/_matplotlib/core.py b/pandas/plotting/_matplotlib/core.py
index 519465802..c2b37bb29 100644
--- a/pandas/plotting/_matplotlib/core.py
+++ b/pandas/plotting/_matplotlib/core.py
@@ -654,7 +654,7 @@ class MPLPlot:
     def _get_index_name(self):
         if isinstance(self.data.index, ABCMultiIndex):
             name = self.data.index.names
-            if com._any_not_none(*name):
+            if com.any_not_none(*name):
                 name = ",".join(pprint_thing(x) for x in name)
             else:
                 name = None
@@ -1054,7 +1054,7 @@ class LinePlot(MPLPlot):
             it = self._iter_data()
 
         stacking_id = self._get_stacking_id()
-        is_errorbar = com._any_not_none(*self.errors.values())
+        is_errorbar = com.any_not_none(*self.errors.values())
 
         colors = self._get_colors()
         for i, (label, y) in enumerate(it):
diff --git a/pandas/tests/frame/test_to_csv.py b/pandas/tests/frame/test_to_csv.py
index 28051d9b7..e2e4a82ff 100644
--- a/pandas/tests/frame/test_to_csv.py
+++ b/pandas/tests/frame/test_to_csv.py
@@ -655,7 +655,7 @@ class TestDataFrameToCSV(TestData):
             df = _make_frame(True)
             df.to_csv(path, index=False)
             result = read_csv(path, header=[0, 1])
-            assert com._all_none(*result.columns.names)
+            assert com.all_none(*result.columns.names)
             result.columns.names = df.columns.names
             assert_frame_equal(df, result)
 
diff --git a/pandas/tests/scalar/interval/test_interval.py b/pandas/tests/scalar/interval/test_interval.py
index e4987e448..b51429d03 100644
--- a/pandas/tests/scalar/interval/test_interval.py
+++ b/pandas/tests/scalar/interval/test_interval.py
@@ -254,6 +254,6 @@ class TestInterval:
         # GH 18538
         left = Timestamp("2017-01-01", tz=tz_left)
         right = Timestamp("2017-01-02", tz=tz_right)
-        error = TypeError if com._any_none(tz_left, tz_right) else ValueError
+        error = TypeError if com.any_none(tz_left, tz_right) else ValueError
         with pytest.raises(error):
             Interval(left, right)
diff --git a/pandas/tests/test_common.py b/pandas/tests/test_common.py
index d96f806bc..479e55c86 100644
--- a/pandas/tests/test_common.py
+++ b/pandas/tests/test_common.py
@@ -33,14 +33,14 @@ def test_get_callable_name():
 
 
 def test_any_none():
-    assert com._any_none(1, 2, 3, None)
-    assert not com._any_none(1, 2, 3, 4)
+    assert com.any_none(1, 2, 3, None)
+    assert not com.any_none(1, 2, 3, 4)
 
 
 def test_all_not_none():
-    assert com._all_not_none(1, 2, 3, 4)
-    assert not com._all_not_none(1, 2, 3, None)
-    assert not com._all_not_none(None, None, None, None)
+    assert com.all_not_none(1, 2, 3, 4)
+    assert not com.all_not_none(1, 2, 3, None)
+    assert not com.all_not_none(None, None, None, None)
 
 
 def test_random_state():

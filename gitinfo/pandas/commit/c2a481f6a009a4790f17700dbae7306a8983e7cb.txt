commit c2a481f6a009a4790f17700dbae7306a8983e7cb
Author: Jeff Reback <jeff@reback.net>
Date:   Sun Apr 3 11:25:10 2016 -0400

    CLN: make .quantile more datetimelike friendly

diff --git a/doc/source/whatsnew/v0.18.1.txt b/doc/source/whatsnew/v0.18.1.txt
index 1a0c16e2d..b4f8dab37 100644
--- a/doc/source/whatsnew/v0.18.1.txt
+++ b/doc/source/whatsnew/v0.18.1.txt
@@ -191,6 +191,8 @@ Bug Fixes
 
 - Bug in ``Timestamp.__repr__`` that caused ``pprint`` to fail in nested structures (:issue:`12622`)
 - Bug in ``Timedelta.min`` and ``Timedelta.max``, the properties now report the true minimum/maximum ``timedeltas`` as recognized by Pandas. See :ref:`documentation <timedeltas.limitations>`. (:issue:`12727`)
+- Bug in ``.quantile()`` with interpolation may coerce to ``float`` unexpectedly (:issue:`12772`)
+- Bug in ``.quantile()`` with empty Series may return scalar rather than empty Series (:issue:`12772`)
 
 
 
@@ -228,9 +230,3 @@ Bug Fixes
 - Bug in ``.describe()`` resets categorical columns information (:issue:`11558`)
 - Bug where ``loffset`` argument was not applied when calling ``resample().count()`` on a timeseries (:issue:`12725`)
 - ``pd.read_excel()`` now accepts path objects (e.g. ``pathlib.Path``, ``py.path.local``) for the file path, in line with other ``read_*`` functions (:issue:`12655`)
-
-
-
-
-- Bug in ``.quantile`` with interpolation may coerce to ``float`` unexpectedly (:issue:`12772`)
-- Bug in ``.quantile`` with empty Series may return scalar rather than empty Series (:issue:`12772`)
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 94bd1f115..613140e24 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -1255,18 +1255,32 @@ class Block(PandasObject):
             return False
         return array_equivalent(self.values, other.values)
 
-    def quantile(self, values, qs, **kwargs):
+    def quantile(self, qs, mgr=None, **kwargs):
+        """
+        compute the quantiles of the
+
+        Parameters
+        ----------
+        qs : a scalar or list of the quantiles to be computed
+        """
+
+        values = self.get_values()
+        values, mask, _, _ = self._try_coerce_args(values, values)
+        if not lib.isscalar(mask) and mask.any():
+            values = values[~mask]
+
         if len(values) == 0:
             if com.is_list_like(qs):
-                return np.array([self.fill_value])
+                result = np.array([self.fill_value])
             else:
-                return self._na_value
-
-        if com.is_list_like(qs):
+                result = self._na_value
+        elif com.is_list_like(qs):
             values = [_quantile(values, x * 100, **kwargs) for x in qs]
-            return np.array(values)
+            result = np.array(values)
         else:
-            return _quantile(values, qs * 100, **kwargs)
+            result = _quantile(values, qs * 100, **kwargs)
+
+        return self._try_coerce_result(result)
 
 
 class NonConsolidatableMixIn(object):
@@ -1499,22 +1513,6 @@ class DatetimeLikeBlockMixin(object):
                                  self._box_func).reshape(self.values.shape)
         return self.values
 
-    def quantile(self, values, qs, **kwargs):
-        values = values.view('i8')
-        mask = values == self.fill_value
-        if mask.any():
-            values = values[~mask]
-        result = Block.quantile(self, values, qs, **kwargs)
-
-        if com.is_datetime64tz_dtype(self):
-            # ToDo: Temp logic to avoid GH 12619 and GH 12772
-            # which affects to DatetimeBlockTZ_try_coerce_result for np.ndarray
-            if isinstance(result, np.ndarray) and values.ndim > 0:
-                result = self._holder(result, tz='UTC')
-                result = result.tz_convert(self.values.tz)
-                return result
-        return self._try_coerce_result(result)
-
 
 class TimeDeltaBlock(DatetimeLikeBlockMixin, IntBlock):
     __slots__ = ()
@@ -2274,12 +2272,14 @@ class DatetimeTZBlock(NonConsolidatableMixIn, DatetimeBlock):
 
     def _try_coerce_result(self, result):
         """ reverse of try_coerce_args """
-        result = super(DatetimeTZBlock, self)._try_coerce_result(result)
-
         if isinstance(result, np.ndarray):
-            result = self._holder(result, tz=self.values.tz)
+            if result.dtype.kind in ['i', 'f', 'O']:
+                result = result.astype('M8[ns]')
         elif isinstance(result, (np.integer, np.float, np.datetime64)):
-            result = lib.Timestamp(result, tz=self.values.tz)
+            result = lib.Timestamp(result).tz_localize(self.values.tz)
+        if isinstance(result, np.ndarray):
+            result = self._holder(result).tz_localize(self.values.tz)
+
         return result
 
     @property
@@ -2806,7 +2806,7 @@ class BlockManager(PandasObject):
                                      len(self.items), tot_items))
 
     def apply(self, f, axes=None, filter=None, do_integrity_check=False,
-              consolidate=True, **kwargs):
+              consolidate=True, raw=False, **kwargs):
         """
         iterate over the blocks, collect and create a new block manager
 
@@ -2820,6 +2820,7 @@ class BlockManager(PandasObject):
             integrity check
         consolidate: boolean, default True. Join together blocks having same
             dtype
+        raw: boolean, default False. Return the raw returned results
 
         Returns
         -------
@@ -2886,7 +2887,11 @@ class BlockManager(PandasObject):
             applied = getattr(b, f)(**kwargs)
             result_blocks = _extend_blocks(applied, result_blocks)
 
-        if len(result_blocks) == 0:
+        if raw:
+            if self._is_single_block:
+                return result_blocks[0]
+            return result_blocks
+        elif len(result_blocks) == 0:
             return self.make_empty(axes or self.axes)
         bm = self.__class__(result_blocks, axes or self.axes,
                             do_integrity_check=do_integrity_check)
@@ -2902,6 +2907,9 @@ class BlockManager(PandasObject):
     def eval(self, **kwargs):
         return self.apply('eval', **kwargs)
 
+    def quantile(self, **kwargs):
+        return self.apply('quantile', raw=True, **kwargs)
+
     def setitem(self, **kwargs):
         return self.apply('setitem', **kwargs)
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index ce0600b93..7c1d4663f 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1354,8 +1354,7 @@ class Series(base.IndexOpsMixin, strings.StringAccessorMixin,
         if not _np_version_under1p9:
             kwargs.update({'interpolation': interpolation})
 
-        result = self._data._block.quantile(self.dropna()._values,
-                                            q, **kwargs)
+        result = self._data.quantile(qs=q, **kwargs)
 
         if com.is_list_like(result):
             # explicitly use Float64Index to coerce empty result to float dtype

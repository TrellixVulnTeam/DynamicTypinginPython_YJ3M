commit d04468868c3e210c598f25e751572b412f3c351e
Author: Martin Blais <blais@furius.ca>
Date:   Sat Mar 24 13:27:57 2012 -0400

    Fixed various issues in read_fwf() implementation (applied merge comments from Thomas Kluyver).

diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index 22f11f9df..2f39a1d7d 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -81,50 +81,47 @@ Read general delimited file into DataFrame
 """ % (_parser_params % _table_sep)
 
 
-_fwf_widths = """widths : list of tuples/lists, giving the widths of
-    the fixed-width fields of each line, as [from, to] (inclusively)
+_fwf_widths = """\
+colspecs : a list of pairs (tuples), giving the extents
+    of the fixed-width fields of each line as half-open internals
+    (i.e.,  [from, to[  ).
+widths : a list of field widths, which can be used instead of
+    'colspecs' if the intervals are contiguous.
 """
 
 _read_fwf_doc = """
 Read a table of fixed-width formatted lines into DataFrame
-(Note: this reader ignores the header field.)
 
 %s
+
+Also, 'delimiter' is used to specify the filler character of the
+fields if it is not spaces (e.g., '~').
 """ % (_parser_params % _fwf_widths)
 
 
-def _read(cls, filepath_or_buffer, sep=',', header=0, index_col=None, names=None,
-          skiprows=None, na_values=None, parse_dates=False,
-          date_parser=None, nrows=None, iterator=False, chunksize=None,
-          skip_footer=0, converters=None, verbose=False, delimiter=None,
-          encoding=None):
+def _read(cls, filepath_or_buffer, kwds):
     "Generic reader of line files."
     if hasattr(filepath_or_buffer, 'read'):
         f = filepath_or_buffer
     else:
+        encoding = kwds.get('encoding', None)
         try:
             # universal newline mode
             f = com._get_handle(filepath_or_buffer, 'U', encoding=encoding)
         except Exception: # pragma: no cover
             f = com._get_handle(filepath_or_buffer, 'r', encoding=encoding)
 
-    if delimiter is not None:
-        sep = delimiter
+    if kwds.get('date_parser', None) is not None:
+        kwds['parse_dates'] = True
 
-    if date_parser is not None:
-        parse_dates = True
+    # Extract some of the arguments (pass chunksize on).
+    kwds.pop('filepath_or_buffer')
+    iterator = kwds.pop('iterator')
+    nrows = kwds.pop('nrows')
+    chunksize = kwds.get('chunksize', None)
 
-    parser = cls(f, header=header, index_col=index_col,
-                 names=names, na_values=na_values,
-                 parse_dates=parse_dates,
-                 date_parser=date_parser,
-                 skiprows=skiprows,
-                 delimiter=sep,
-                 chunksize=chunksize,
-                 skip_footer=skip_footer,
-                 converters=converters,
-                 verbose=verbose,
-                 encoding=encoding)
+    # Create the parser.
+    parser = cls(f, **kwds)
 
     if nrows is not None:
         return parser.get_chunk(nrows)
@@ -134,52 +131,99 @@ def _read(cls, filepath_or_buffer, sep=',', header=0, index_col=None, names=None
     return parser.get_chunk()
 
 @Appender(_read_csv_doc)
-def read_csv(filepath_or_buffer, sep=',', header=0, index_col=None, names=None,
-             skiprows=None, na_values=None, parse_dates=False,
-             date_parser=None, nrows=None, iterator=False, chunksize=None,
-             skip_footer=0, converters=None, verbose=False, delimiter=None,
+def read_csv(filepath_or_buffer,
+             sep=',',
+             header=0,
+             index_col=None,
+             names=None,
+             skiprows=None,
+             na_values=None,
+             parse_dates=False,
+             date_parser=None,
+             nrows=None,
+             iterator=False,
+             chunksize=None,
+             skip_footer=0,
+             converters=None,
+             verbose=False,
+             delimiter=None,
              encoding=None):
+    kwds = locals()
+
+    # Alias sep -> delimiter.
+    sep = kwds.pop('sep')
+    if kwds.get('delimiter', None) is None:
+        kwds['delimiter'] = sep
 
-    return _read(TextParser,
-                 filepath_or_buffer, sep=sep, header=header,
-                 skiprows=skiprows, index_col=index_col,
-                 na_values=na_values, date_parser=date_parser,
-                 names=names, parse_dates=parse_dates,
-                 nrows=nrows, iterator=iterator, chunksize=chunksize,
-                 skip_footer=skip_footer, converters=converters,
-                 verbose=verbose, delimiter=delimiter)
+    return _read(TextParser, filepath_or_buffer, kwds)
 
 @Appender(_read_table_doc)
-def read_table(filepath_or_buffer, sep='\t', header=0, index_col=None,
-               names=None, skiprows=None, na_values=None, parse_dates=False,
-               date_parser=None, nrows=None, iterator=False, chunksize=None,
-               skip_footer=0, converters=None, verbose=False, delimiter=None,
+def read_table(filepath_or_buffer,
+               sep='\t',
+               header=0,
+               index_col=None,
+               names=None,
+               skiprows=None,
+               na_values=None,
+               parse_dates=False,
+               date_parser=None,
+               nrows=None,
+               iterator=False,
+               chunksize=None,
+               skip_footer=0,
+               converters=None,
+               verbose=False,
+               delimiter=None,
                encoding=None):
+    kwds = locals()
+
+    # Alias sep -> delimiter.
+    sep = kwds.pop('sep')
+    if kwds.get('delimiter', None) is None:
+        kwds['delimiter'] = sep
 
-    return _read(TextParser,
-                 filepath_or_buffer, sep=sep, header=header,
-                 skiprows=skiprows, index_col=index_col,
-                 na_values=na_values, date_parser=date_parser,
-                 names=names, parse_dates=parse_dates,
-                 nrows=nrows, iterator=iterator, chunksize=chunksize,
-                 skip_footer=skip_footer, converters=converters,
-                 verbose=verbose, delimiter=delimiter, encoding=None)
+    # Override as default encoding.
+    kwds['encoding'] = None
+
+    return _read(TextParser, filepath_or_buffer, kwds)
 
 @Appender(_read_fwf_doc)
-def read_fwf(filepath_or_buffer, widths, index_col=None,
-             names=None, skiprows=None, na_values=None, parse_dates=False,
-             date_parser=None, nrows=None, iterator=False, chunksize=None,
-             skip_footer=0, converters=None, verbose=False,
+def read_fwf(filepath_or_buffer,
+             colspecs=None,
+             widths=None,
+             header=0,
+             index_col=None,
+             names=None,
+             skiprows=None,
+             na_values=None,
+             parse_dates=False,
+             date_parser=None,
+             nrows=None,
+             iterator=False,
+             chunksize=None,
+             skip_footer=0,
+             converters=None,
+             delimiter=None,
+             verbose=False,
              encoding=None):
 
-    return _read(FixedWidthFieldParser,
-                 filepath_or_buffer, sep=None, header=None,
-                 skiprows=skiprows, index_col=index_col,
-                 na_values=na_values, date_parser=date_parser,
-                 names=names, parse_dates=parse_dates,
-                 nrows=nrows, iterator=iterator, chunksize=chunksize,
-                 skip_footer=skip_footer, converters=converters,
-                 verbose=verbose, delimiter=widths, encoding=None)
+    kwds = locals()
+
+    # Check input arguments.
+    colspecs = kwds.get('colspecs', None)
+    widths = kwds.pop('widths', None)
+    if bool(colspecs is None) == bool(widths is None):
+        raise ValueError("You must specify only one of 'widths' and 'colspecs'")
+
+    # Compute 'colspec' from 'widths', if specified.
+    if widths is not None:
+        colspecs, col = [], 0
+        for w in widths:
+            colspecs.append( (col, col+w) )
+            col += w
+        kwds['colspecs'] = colspecs
+
+    return _read(FixedWidthFieldParser, filepath_or_buffer, kwds)
 
 
 
@@ -622,9 +666,10 @@ class FixedWidthReader(object):
     """
     A reader of fixed-width lines.
     """
-    def __init__(self, f, colspecs):
+    def __init__(self, f, colspecs, filler):
         self.f = f
         self.colspecs = colspecs
+        self.filler = filler # Empty characters between fields.
 
         assert isinstance(colspecs, (tuple, list))
         for colspec in colspecs:
@@ -635,8 +680,9 @@ class FixedWidthReader(object):
 
     def next(self):
         line = self.f.next()
-        return [line[fromm:to+1] for (fromm, to) in self.colspecs]
-      
+        # Note: 'colspecs' is a sequence of half-open intervals.
+        return [line[fromm:to].strip(self.filler or ' ') for (fromm, to) in self.colspecs]
+
 
 class FixedWidthFieldParser(TextParser):
     """
@@ -646,8 +692,14 @@ class FixedWidthFieldParser(TextParser):
     Note: this class is hijacking the 'delimiter' attribute to store the list of
     column specs.
     """
+    def __init__(self, f, **kwds):
+        # Support iterators, convert to a list.
+        self.colspecs = list(kwds.pop('colspecs'))
+
+        TextParser.__init__(self, f, **kwds)
+
     def _make_reader(self, f):
-        self.data = FixedWidthReader(f, self.delimiter)
+        self.data = FixedWidthReader(f, self.colspecs, self.delimiter)
 
 
 #-------------------------------------------------------------------------------
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index 081b114c1..ec1912cd0 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -720,23 +720,47 @@ bar"""
         assert_frame_equal(result, result2)
 
     def test_fwf(self):
-        data = """\
-2011 58   360.242940   149.910199   11950.7
-2011 59   444.953632   166.985655   11788.4
-2011 60   364.136849   183.628767   11806.2
-2011 61   413.836124   184.375703   11916.8
-2011 62   502.953953   173.237159   12468.3
-"""
-        data2 = """\
+        data_expected = """\
 2011,58,360.242940,149.910199,11950.7
 2011,59,444.953632,166.985655,11788.4
 2011,60,364.136849,183.628767,11806.2
 2011,61,413.836124,184.375703,11916.8
 2011,62,502.953953,173.237159,12468.3
 """
-        widths = [(0, 3), (5, 6), (8, 19), (21, 32), (34, 42)]
-        df = read_fwf(StringIO(data), widths)
-        expected = read_csv(StringIO(data2), header=None)
+        expected = read_csv(StringIO(data_expected), header=None)
+
+        data1 = """\
+201158    360.242940   149.910199   11950.7
+201159    444.953632   166.985655   11788.4
+201160    364.136849   183.628767   11806.2
+201161    413.836124   184.375703   11916.8
+201162    502.953953   173.237159   12468.3
+"""
+        colspecs = [(0, 4), (4, 8), (8, 20), (21, 33), (34, 43)]
+        df = read_fwf(StringIO(data1), colspecs=colspecs, header=None)
+        assert_frame_equal(df, expected)
+
+        data2 = """\
+2011 58   360.242940   149.910199   11950.7
+2011 59   444.953632   166.985655   11788.4
+2011 60   364.136849   183.628767   11806.2
+2011 61   413.836124   184.375703   11916.8
+2011 62   502.953953   173.237159   12468.3
+"""
+        df = read_fwf(StringIO(data2), widths=[5, 5, 13, 13, 7], header=None)
+        assert_frame_equal(df, expected)
+
+        # From Thomas Kluyver: apparently some non-space filler characters can
+        # be seen, this is supported by specifying the 'delimiter' character:
+        # http://publib.boulder.ibm.com/infocenter/dmndhelp/v6r1mx/index.jsp?topic=/com.ibm.wbit.612.help.config.doc/topics/rfixwidth.html
+        data3 = """\
+201158~~~~360.242940~~~149.910199~~~11950.7
+201159~~~~444.953632~~~166.985655~~~11788.4
+201160~~~~364.136849~~~183.628767~~~11806.2
+201161~~~~413.836124~~~184.375703~~~11916.8
+201162~~~~502.953953~~~173.237159~~~12468.3
+"""
+        df = read_fwf(StringIO(data3), colspecs=colspecs, delimiter='~', header=None)
         assert_frame_equal(df, expected)
 
 

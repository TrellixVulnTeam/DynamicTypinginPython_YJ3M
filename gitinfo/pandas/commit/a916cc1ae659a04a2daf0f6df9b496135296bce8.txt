commit a916cc1ae659a04a2daf0f6df9b496135296bce8
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed May 11 20:39:26 2011 -0400

    more sparse unit tests. barebones panel stacking routine written and decently optimized

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 56f3ac6fa..f65f96427 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -858,12 +858,11 @@ class DataFrame(Picklable, Groupable):
             print >> buf, 'Empty',
             return
 
-        print >> buf, 'Data columns:'
-        space = max([len(str(k)) for k in self.cols()]) + 4
-
         cols = self.cols()
 
         if verbose:
+            print >> buf, 'Data columns:'
+            space = max([len(str(k)) for k in self.cols()]) + 4
             col_counts = []
             counts = self.count()
             assert(len(cols) == len(counts))
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 116b6a805..3e7f8b7fc 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -180,7 +180,7 @@ class DataMatrix(DataFrame):
 
         for i, col in enumerate(columns):
             if col in valueDict:
-                values[:, i] = valueDict[col]
+                values[:, i] = valueDict[col].values
             else:
                 values[:, i] = np.NaN
 
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index c7d6db090..f983f0e0b 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -1615,9 +1615,17 @@ class LongPanel(Panel):
 
 class LongPanelIndex(object):
     """
+    Holds axis indexing information for a LongPanel instance
+
     Parameters
     ----------
-
+    major_axis : Index-like
+    minor_axis : Index-like
+    major_labels : ndarray
+    minor_labels : ndarray
+    mask : ndarray (bool), optional
+        observation selection vector using major and minor labels, for
+        converting to wide format.
     """
     def __init__(self, major_axis, minor_axis, major_labels,
                  minor_labels, mask=None):
@@ -1766,11 +1774,11 @@ class LongPanelIndex(object):
     @property
     def mask(self):
         if self._mask is None:
-            self._mask = self._makeMask()
+            self._mask = self._make_mask()
 
         return self._mask
 
-    def _makeMask(self):
+    def _make_mask(self):
         """
         Create observation selection vector using major and minor
         labels, for converting to wide format.
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index 41f4b6091..e55fb54f2 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -355,7 +355,31 @@ class SparseSeries(Series):
         if sp_loc == -1:
             return self.fill_value
         else:
-            return self.sp_values[sp_loc]
+            return ndarray.__getitem__(self, sp_loc)
+
+    def take(self, indices):
+        """
+        Sparse-compatible version of ndarray.take
+
+        Returns
+        -------
+        y : ndarray
+        """
+        indices = np.asarray(indices, dtype=int)
+
+        n = len(self)
+        if (indices < 0).any() or (indices >= n).any():
+            raise Exception('out of bounds access')
+
+        if self.sp_index.npoints > 0:
+            locs = np.array([self.sp_index.lookup(loc) for loc in indices])
+            result = self.sp_values.take(locs)
+            result[locs == -1] = self.fill_value
+        else:
+            result = np.empty(len(indices))
+            result.fill(self.fill_value)
+
+        return result
 
     def __getslice__(self, i, j):
         return self._constructor(self.values[i:j], index=self.index[i:j])
@@ -421,16 +445,6 @@ class SparseSeries(Series):
         return SparseSeries(new_values, index=new_index,
                             fill_value=self.fill_value)
 
-    def take(self, indices):
-        """
-        Sparse-compatible version of ndarray.take
-
-        Returns
-        -------
-        y : SparseSeries
-        """
-        pass
-
     def count(self):
         sp_values = self.sp_values
         valid_spvals = np.isfinite(sp_values).sum()
@@ -475,6 +489,14 @@ class SparseSeries(Series):
             nsparse = self.sp_index.npoints
             return (sp_sum + self.fill_value * nsparse) / (ct + nsparse)
 
+    def valid(self):
+        """
+        Analogous to Series.valid
+        """
+        # TODO: make more efficient
+        dense_valid = self.to_dense().valid()
+        return dense_valid.to_sparse(fill_value=self.fill_value)
+
 class SparseTimeSeries(SparseSeries, TimeSeries):
     pass
 
@@ -547,6 +569,20 @@ class SparseDataFrame(DataFrame):
 
         return sdict, columns, index
 
+    def __repr__(self):
+        """
+        Return a string representation for a particular DataFrame
+        """
+        from cStringIO import StringIO
+
+        buf = StringIO()
+        if len(self.index) < 500 and len(self.columns) < 10:
+            self.toString(buf=buf)
+        else:
+            self.info(buf=buf, verbose=False)
+
+        return buf.getvalue()
+
     def to_dense(self):
         """
         Convert to dense DataFrame
@@ -567,9 +603,21 @@ class SparseDataFrame(DataFrame):
                                default_fill_value=self.default_fill_value,
                                kind=self.default_kind)
 
+    @property
+    def density(self):
+        """
+        Ratio of non-sparse points to total (dense) data points
+        represented in the frame
+        """
+        tot_nonsparse = sum([ser.sp_index.npoints
+                             for _, ser in self.iteritems()])
+        tot = len(self.index) * len(self.columns)
+        return tot_nonsparse / float(tot)
+
     def _insert_item(self, key, value):
         sp_maker = lambda x: SparseSeries(x, index=self.index,
-                                          fill_value=self.default_fill_value)
+                                          fill_value=self.default_fill_value,
+                                          kind=self.default_kind)
         if hasattr(value, '__iter__'):
             if isinstance(value, Series):
                 cleanSeries = value.reindex(self.index)
@@ -637,54 +685,67 @@ class SparseDataFrame(DataFrame):
         return SparseDataFrame(sdict, index=self.index, columns=columns,
                                default_fill_value=self.default_fill_value)
 
-def stack_sparse_frame(frame, filter_observations=True):
-    """
+from pandas.core.panel import WidePanel
+
+from line_profiler import LineProfiler
+prof = LineProfiler()
 
+def stack_sparse_frame(frame):
+    """
+    Only makes sense when fill_value is NaN
     """
-    I, N, K = self.dims
+    from pandas.core.panel import LongPanelIndex, LongPanel
 
-    if filter_observations:
-        mask = np.isfinite(self.values).all(axis=0)
-        size = mask.sum()
-        selector = mask.ravel()
-    else:
-        size = N * K
-        selector = slice(None, None)
+    lengths = [s.sp_index.npoints for _, s in frame.iteritems()]
+    nobs = sum(lengths)
 
-    values = np.empty((size, I), dtype=float)
+    # this is pretty fast
+    minor_labels = np.repeat(np.arange(len(frame.columns)), lengths)
 
-    for i in xrange(len(self.items)):
-        values[:, i] = self.values[i].ravel()[selector]
+    # need to create
+    major_labels = np.empty(nobs, dtype=int)
+    stacked_values = np.empty(nobs, dtype=np.float64)
 
-    major_labels = np.arange(N).repeat(K)[selector]
+    inds_to_concat = []
+    vals_to_concat = []
+    for _, series in frame.iteritems():
+        if not np.isnan(series.fill_value):
+            raise Exception('This routine assumes NaN fill value')
 
-    # Anyone think of a better way to do this? np.repeat does not
-    # do what I want
-    minor_labels = np.arange(K).reshape(1, K)[np.zeros(N, dtype=int)]
-    minor_labels = minor_labels.ravel()[selector]
+        int_index = series.sp_index.to_int_index()
+        inds_to_concat.append(int_index.indices)
+        vals_to_concat.append(series.sp_values)
 
-    if filter_observations:
-        mask = selector
-    else:
-        mask = None
+    major_labels = np.concatenate(inds_to_concat)
+    stacked_values = np.concatenate(vals_to_concat)
+    index = LongPanelIndex(frame.index, frame.columns,
+                           major_labels, minor_labels)
 
-    index = LongPanelIndex(self.major_axis,
-                           self.minor_axis,
-                           major_labels,
-                           minor_labels,
-                           mask=mask)
+    lp = LongPanel(stacked_values.reshape((nobs, 1)), ['foo'], index)
+    return lp.sort('major')
 
-    return LongPanel(values, self.items, index)
+class SparseWidePanel(WidePanel):
+    """
 
-from pandas.core.panel import WidePanel
 
-class SparsePanel(WidePanel):
-    """
 
     """
-    def __init__(self, frames):
+    def __init__(self, frames, items=None, major_axis=None, minor_axis=None):
+        assert(isinstance(frames, dict))
+
         self.frames = frames
-        # self.items = Index(sorted(
+
+        self.items = Index(sorted(frames))
+        self.major_axis = foo
+
+    @classmethod
+    def from_dict(cls):
+        pass
+
+    @property
+    def values(self):
+        # return dense values
+        pass
 
     def __getitem__(self, key):
         """
diff --git a/pandas/core/tests/test_sparse.py b/pandas/core/tests/test_sparse.py
index e13c823e8..d8c6cfec6 100644
--- a/pandas/core/tests/test_sparse.py
+++ b/pandas/core/tests/test_sparse.py
@@ -13,7 +13,7 @@ from pandas.util.testing import (assert_almost_equal, assert_series_equal,
                                  assert_frame_equal)
 from numpy.testing import assert_equal
 
-from pandas import DataFrame, DateRange
+from pandas import DataFrame, DateRange, WidePanel
 from pandas.core.datetools import BDay
 from pandas.core.series import remove_na
 from pandas.core.sparse import (IntIndex, BlockIndex,
@@ -235,6 +235,8 @@ class TestSparseSeries(TestCase):
 
             for i in xrange(len(dense)):
                 assert_almost_equal(sp[i], dense[i])
+                # j = np.float64(i)
+                # assert_almost_equal(sp[j], dense[j])
 
             # negative getitem works
             for i in xrange(len(dense)):
@@ -272,6 +274,29 @@ class TestSparseSeries(TestCase):
         res = self.bseries[5:]
         assert_sp_series_equal(res, self.bseries.reindex(idx[5:]))
 
+    def test_take(self):
+        def _compare_with_dense(sp):
+            dense = sp.to_dense()
+
+            def _compare(idx):
+                dense_result = dense.take(idx)
+                sparse_result = sp.take(idx)
+                assert_almost_equal(dense_result, sparse_result)
+
+            _compare([1., 2., 3., 4., 5., 0.])
+            _compare([7, 2, 9, 0, 4])
+            _compare([3, 6, 3, 4, 7])
+
+        self._check_all(_compare_with_dense)
+
+        self.assertRaises(Exception, self.bseries.take, [-1, 0])
+        self.assertRaises(Exception, self.bseries.take,
+                          [0, len(self.bseries) + 1])
+
+        # Corner case
+        sp = SparseSeries(np.ones(10.) * nan)
+        assert_almost_equal(sp.take([0, 1, 2, 3, 4]), np.repeat(nan, 5))
+
     def test_getslice(self):
         pass
 
@@ -381,7 +406,7 @@ class TestSparseSeries(TestCase):
         pass
 
     def test_reductions(self):
-        def _compare_with_series(obj, op):
+        def _compare_with_dense(obj, op):
             sparse_result = getattr(obj, op)()
             series = obj.to_dense()
             dense_result = getattr(series, op)()
@@ -390,7 +415,7 @@ class TestSparseSeries(TestCase):
         to_compare = ['count', 'sum', 'mean', 'std', 'var', 'skew']
         def _compare_all(obj):
             for op in to_compare:
-                _compare_with_series(obj, op)
+                _compare_with_dense(obj, op)
 
         _compare_all(self.bseries)
         self.bseries.sp_values[5:10] = np.NaN
@@ -404,11 +429,20 @@ class TestSparseSeries(TestCase):
         series.fill_value = 2
         _compare_all(series)
 
-    def test_mean(self):
-        pass
-
     def test_valid(self):
-        pass
+        sp = SparseSeries([0, 0, 0, nan, nan, 5, 6],
+                          fill_value=0)
+
+        sp_valid = sp.valid()
+        assert_almost_equal(sp_valid, sp.to_dense().valid())
+        self.assert_(sp_valid.index.equals(sp.to_dense().valid().index))
+        self.assertEquals(len(sp_valid.sp_values), 2)
+
+    def _check_all(self, check_func):
+        check_func(self.bseries)
+        check_func(self.iseries)
+        check_func(self.zbseries)
+        check_func(self.ziseries)
 
 class TestSparseTimeSeries(TestCase):
     pass
@@ -497,10 +531,7 @@ class TestSparseDataFrame(TestCase):
         pass
 
     def test_sparse_series_ops(self):
-        self._check_frame_ops(self.frame)
-        self._check_frame_ops(self.iframe)
-        self._check_frame_ops(self.fill_frame)
-        self._check_frame_ops(self.zframe)
+        self._check_all(self._check_frame_ops)
 
     def _check_frame_ops(self, frame):
         def _compare_to_dense(a, b, da, db, op, fill=np.NaN):
@@ -594,9 +625,8 @@ class TestSparseDataFrame(TestCase):
             frame['K'] = frame.default_fill_value
             self.assertEquals(len(frame['K'].sp_values), 0)
 
-        _check_frame(self.frame)
-        _check_frame(self.zframe)
-        _check_frame(self.fill_frame)
+
+        self._check_all(_check_frame)
 
     def test_corr(self):
         res = self.frame.corr()
@@ -654,6 +684,48 @@ class TestSparseDataFrame(TestCase):
     def test_fillna(self):
         pass
 
+    def test_density(self):
+        df = SparseDataFrame({'A' : [nan, nan, nan, 0, 1, 2, 3, 4, 5, 6],
+                              'B' : [0, 1, 2, nan, nan, nan, 3, 4, 5, 6],
+                              'C' : np.arange(10),
+                              'D' : [0, 1, 2, 3, 4, 5, nan, nan, nan, nan]})
+
+        self.assertEquals(df.density, 0.75)
+
+    def test_toDataMatrix(self):
+        def _check(frame):
+            dm = frame.toDataMatrix()
+            dense_dm = frame.to_dense().toDataMatrix()
+            assert_frame_equal(dm, dense_dm)
+
+        self._check_all(_check)
+
+    def test_stack_sparse_frame(self):
+        def _check(frame):
+            dense_frame = frame.to_dense()
+
+            wp = WidePanel.from_dict({'foo' : frame})
+            from_dense_lp = wp.to_long()
+
+            from_sparse_lp = spm.stack_sparse_frame(frame)
+
+            self.assert_(np.array_equal(from_dense_lp.values,
+                                        from_sparse_lp.values))
+
+
+        _check(self.frame)
+        _check(self.iframe)
+
+        # for now
+        self.assertRaises(Exception, self.zframe)
+        self.assertRaises(Exception, self.fill_frame)
+
+    def _check_all(self, check_func):
+        check_func(self.frame)
+        check_func(self.iframe)
+        check_func(self.zframe)
+        check_func(self.fill_frame)
+
 class TestSparseWidePanel(TestCase):
     pass
 
diff --git a/pandas/lib/bench_sparse.py b/pandas/lib/bench_sparse.py
index cb68cbd14..238682e05 100644
--- a/pandas/lib/bench_sparse.py
+++ b/pandas/lib/bench_sparse.py
@@ -3,7 +3,7 @@ import numpy as np
 from pandas import *
 import pandas.core.sparse as spm
 reload(spm)
-from pandas.core.sparse import SparseSeries, SparseDataFrame
+from pandas.core.sparse import *
 
 N = 10000.
 
@@ -35,3 +35,5 @@ for col, ser in dm.iteritems():
     data[col] = SparseSeries(ser)
 
 sdf = SparseDataFrame(data)
+
+lp = stack_sparse_frame(sdf)

commit 4e9cb3cab1631bd411fca12b270dc542e2c4488a
Author: Adam Klein <adamklein@gmail.com>
Date:   Thu Feb 16 18:04:29 2012 -0500

    cleaned up a bit, fixed anchoring logic in cache extension

diff --git a/pandas/core/index.py b/pandas/core/index.py
index d562dd4de..939dee135 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1044,22 +1044,21 @@ class DatetimeIndex(Int64Index):
             if end is None and n is None:
                 raise ValueError("No data, must supply end or n")
 
-            dtcache = lib.get_dtcache_freq(freq)
-            buf = dtcache.get_cache()
+            tcache = lib.get_tcache(freq)
+            cache = tcache.cache()
             try:
-                first = dtcache.lookup(start)
+                first = tcache.lookup(start)
                 if n is not None:
-                    if first + n >= len(buf):
-                        ext = (first + n) - len(buf) + 1
-                        dtcache.extend(buf[0], buf[-1], ext)
-                        buf = dtcache.get_cache()
-                        first = dtcache.lookup(start)
+                    if first + n >= len(cache):
+                        ext = (first + n) - len(cache) + 1
+                        cache = tcache.extend(cache[0], cache[-1], ext)
+                        first = tcache.lookup(start)
 
-                    dti = cls._construct_from_cache(name, freq, buf,
+                    dti = cls._construct_from_cache(name, freq, cache,
                                                     first, first + n)
                 else:
-                    last = dtcache.lookup(end)
-                    dti = cls._construct_from_cache(name, freq, buf,
+                    last = tcache.lookup(end)
+                    dti = cls._construct_from_cache(name, freq, cache,
                                                     first, last + 1)
             except KeyError, e:
                 raise ValueError("Non-conforming time: %s"
@@ -1130,12 +1129,15 @@ class DatetimeIndex(Int64Index):
         return newdti
 
     @classmethod
-    def _quickbuilder(cls, name, freq, data, first):
+    def _quickbuilder(cls, name, freq, data, first, regular=None):
         newdti = data.view(cls)
         newdti.name = name
         newdti.freq = freq
         newdti.first = first
-        newdti.regular = False
+        if regular is None:
+            newdti.regular = False
+        else:
+            newdti.regular = regular
         return newdti
 
     @property
@@ -1143,6 +1145,14 @@ class DatetimeIndex(Int64Index):
         # to do: cache me?
         return self.values.view('i8')
 
+    def asfreq(self, freq):
+        if freq is not None:
+            failure, regular = lib.conformity_check(self.asi8, freq)
+            if failure is not None:
+                raise ValueError("%s does not satisfy frequency %s"
+                                  % (np.datetime64(failure), freq))
+            return DatetimeIndex._quickbuilder(self.name, freq, self.values,
+                                               self.first, regular)
     def shift(self, n=1):
         if self.freq is None:
             raise ValueError("Cannot shift, frequency of index is empty")
diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index 31db5a041..c2fcda827 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -93,3 +93,4 @@ cdef extern from "np_datetime_strings.h":
 
 cdef extern from "stdint.h":
     enum: INT64_MIN
+
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 9826e02c9..a0ac0428e 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -1,4 +1,4 @@
-# cython: profile=True
+# cython: profile=False
 
 cimport numpy as np
 import numpy as np
@@ -73,7 +73,7 @@ cdef class _Timestamp(datetime):
         cdef:
             int64_t idx
             ndarray[int64_t] buf
-            DatetimeCache dtcache
+            DatetimeCache tcache
 
         if is_integer_object(other):
             if self.freq is None:
@@ -81,9 +81,9 @@ cdef class _Timestamp(datetime):
                        "without both freq and offset.")
                 raise ValueError(msg)
             else:
-                dtcache = _tcaches[self.freq]
-                buf = dtcache.get_cache()
-                idx = dtcache._lookup(self.value)
+                tcache = _tcaches[self.freq]
+                buf = tcache.cache()
+                idx = tcache._lookup(self.value)
                 return Timestamp(buf[idx + other])
         else:
             return super(_Timestamp, self).__add__(other)
@@ -270,7 +270,7 @@ cdef class _Offset:
     def __cinit__(self):
         self.t=0
         self.dow=0
-        self.biz=0 
+        self.biz=0
         self.dayoffset=0
 
     cpdef anchor(self, object start=None):
@@ -301,6 +301,12 @@ cdef class _Offset:
         else:
             return self.t
 
+    cdef int64_t _get_anchor(self):
+        """
+        Retrieve an anchor relating to current offset we're on.
+        """
+        return self.t - self.dayoffset * us_in_day
+
     property ts:
         def __get__(self):
             return self._ts()
@@ -600,27 +606,32 @@ cdef class DatetimeCache:
     cdef:
         object start
         object end
-        object cache
+        object buf
         object periods
 
         _Offset offset
         Int64HashTable indexer
         object is_dirty
 
-    def __init__(self, _Offset offset, object start,
-                 object end=None, object periods=None):
+        int64_t end_anchor
+
+    def __init__(self, _Offset offset, object end=None, object periods=None):
         """
         Note, prefer 'periods' argument over 'end' for generating range.
         """
 
         self.offset = offset
-        self.start = convert_to_tsobject(start)
+        self.start = offset.ts
         self.end = convert_to_tsobject(end)
-        self.cache = None
+        self.buf = None
         self.periods = periods
         self.is_dirty = True
 
     cdef rebuild(self):
+        """
+        Rebuild cache so that start and end fall within the range of
+        times generated.
+        """
         cdef:
             int64_t periods
             Py_ssize_t i
@@ -630,8 +641,8 @@ cdef class DatetimeCache:
 
         if self.periods is not None:
             periods = self.periods
-            if self.cache is not None and periods < len(self.cache):
-                periods = len(self.cache)
+            if self.buf is not None and periods < len(self.buf):
+                periods = len(self.buf)
         else:
             periods = self.count()
 
@@ -639,8 +650,10 @@ cdef class DatetimeCache:
         buf = _generate_range(self.offset, periods)
 
         self.end = convert_to_tsobject(buf[-1])
+        self.buf = buf
 
-        self.cache = buf
+        self.offset.prev()
+        self.end_anchor = self.offset._get_anchor()
 
         self.indexer = Int64HashTable(size_hint=periods)
         for i in range(periods):
@@ -648,12 +661,12 @@ cdef class DatetimeCache:
 
         self.is_dirty = False
 
-    cdef set_start(self, object start):
-        self.start = convert_to_tsobject(start)
+    cdef set_start(self, _Offset off):
+        self.start = convert_to_tsobject(off._get_anchor())
         self.is_dirty = True
 
-    cdef set_end(self, object end):
-        self.end = convert_to_tsobject(end)
+    cdef set_end(self, _Offset off):
+        self.end = off._ts()
         self.is_dirty = True
 
     cdef set_periods(self, object periods):
@@ -671,7 +684,7 @@ cdef class DatetimeCache:
         else:
             return -1
 
-    cpdef extend(self, int64_t first, int64_t last, int n=0):
+    cpdef ndarray[int64_t] extend(self, int64_t first, int64_t last, int n=0):
         """
         Extend cache to at least n periods beyond first and last
         """
@@ -683,7 +696,7 @@ cdef class DatetimeCache:
         an = abs(n)
         offset = self.offset
 
-        offset.anchor(self.start.value)
+        offset.anchor()
         # if first is before current start
         if offset._ts() > first:
             # move back until on or just past first
@@ -692,7 +705,7 @@ cdef class DatetimeCache:
             # move back an additional n periods
             for i in range(an):
                 offset.prev()
-            self.set_start(offset._ts())
+            self.set_start(offset)
         # if first is after current start
         else:
             # move forward up to n periods until on or just past first
@@ -705,9 +718,9 @@ cdef class DatetimeCache:
                 offset.prev()
             # are we earlier than start?
             if offset._ts() < self.start.value:
-                self.set_start(offset._ts())
+                self.set_start(offset)
 
-        offset.anchor(self.end.value)
+        offset.anchor(self.end_anchor)
         # if last is after current end
         if offset._ts() < last:
             # move forward until on or just past last
@@ -716,7 +729,7 @@ cdef class DatetimeCache:
             # move forward an additional n periods
             for i in range(an):
                 offset.next()
-            self.set_end(offset._ts())
+            self.set_end(offset)
         # if last is before current end
         else:
             # move back up to n periods until on or just past last
@@ -729,16 +742,18 @@ cdef class DatetimeCache:
                 offset.next()
             # are we further than end?
             if offset._ts() > self.end.value:
-                self.set_end(offset._ts())
+                self.set_end(offset)
 
         if self.is_dirty:
             self.rebuild()
 
+        return self.buf
+
     # user/python-accessible methods
 
     cpdef Py_ssize_t count(self):
         if not self.is_dirty:
-            return len(self.cache)
+            return len(self.buf)
 
         self.offset.anchor(self.start)
         return _count_range(self.offset, self.end)
@@ -760,8 +775,8 @@ cdef class DatetimeCache:
         else:
             return idx
 
-    cpdef ndarray[int64_t] get_cache(self):
-        return self.cache
+    cpdef ndarray[int64_t] cache(self):
+        return self.buf
 
 _DEFAULT_BEGIN = Timestamp(datetime(1850, 1, 1))
 _DEFAULT_END = Timestamp(datetime(2050, 1, 1))
@@ -797,7 +812,24 @@ _weekdays = {
     'FRI' : 4
 }
 
-def get_dtcache_freq(freq, object first=None, object last=None):
+# first two letters of frequency determines major rank for considering up- or
+# down-sampling
+_freqrank = {
+    'DA' : 5,  # upsampling
+    'WE' : 4,
+    'W@' : 3,
+    'EO' : 2,
+    'Q@' : 1,
+    'A@' : 0,  # downsampling
+}
+
+def flush_tcache(object freq):
+    if freq in _tcaches:
+        del _tcaches[freq]
+
+# TODO: missing feature, user-provided striding
+
+cpdef DatetimeCache get_tcache(freq, object first=None, object last=None):
     """
     Retrieve from cache (or generate, first time through) times that correspond
     to the frequency we care about.
@@ -859,10 +891,10 @@ def get_dtcache_freq(freq, object first=None, object last=None):
         else:
             raise ValueError('Supplied frequency %s not implemented' % freq)
 
-        first = Timestamp(first)
+        offset.anchor(first)
         last = Timestamp(last)
 
-        _tcaches[freq] = DatetimeCache(offset, first.value, last.value)
+        _tcaches[freq] = DatetimeCache(offset, last.value)
 
     tc = _tcaches[freq]
 
@@ -871,6 +903,46 @@ def get_dtcache_freq(freq, object first=None, object last=None):
 
     return _tcaches[freq]
 
+# Helper methods for frequency-based analysis
+# -------------------------------------------------------------
+
+#def resample(ndarray[int64_t] data, object freq1, object freq2):
+#    """
+#    Handle frequency conversions from freq1 to freq2
+#    """
+#    cdef:
+#        int rank1, rank2
+#        int idx1, idx2
+#        DatetimeCache tc1, tc2
+#        ndarray[int64_t] cache
+
+#    if freq1 == freq2:
+#        return data
+
+#    rank1 = _freqrank[freq1[0:2]]
+#    rank2 = _freqrank[freq2[0:2]]
+
+#    if rank1 >= rank2:
+#        # same or lesser rank, shift forward to conform
+#        tc2 = get_tcache(freq2)
+#        cache = tc2.cache()
+
+#        if data[0] < cache[0] or data[-1] > cache[-1]:
+#            cache = tc2.extend(data[0], data[-1], 0)
+
+#        idx1 = cache.searchsorted(data[0])
+#        idx2 = cache.searchsorted(data[-1])
+#        return cache[idx1:(idx2+1)]
+
+#    if rank1 < rank2:
+#        # upsampling
+#        failure, regular = conformity_check(data, freq2)
+#        if failure is not None:
+#            raise ValueError("Upsample error: %s does not satisfy frequency %s"
+#                              % (np.datetime64(failure), freq2))
+#        return data
+
+
 @cython.wraparound(False)
 def conformity_check(ndarray[int64_t] data, object freq):
     """
@@ -890,8 +962,8 @@ def conformity_check(ndarray[int64_t] data, object freq):
     if ld == 0:
         return None, regular
 
-    tc = get_dtcache_freq(freq)
-    cache = tc.get_cache()
+    tc = get_tcache(freq)
+    cache = tc.cache()
 
     lc = len(cache)
 
@@ -915,7 +987,7 @@ def conformity_check(ndarray[int64_t] data, object freq):
     return None, regular
 
 @cython.wraparound(False)
-def fast_shift(ndarray[int64_t] data, object freq, int64_t n):
+cpdef ndarray[int64_t] fast_shift(ndarray[int64_t] data, object freq, int64_t n):
     """
     Shift times n periods according to the frequency.
     """
@@ -927,8 +999,8 @@ def fast_shift(ndarray[int64_t] data, object freq, int64_t n):
 
     ld = len(data)
 
-    tc = get_dtcache_freq(freq)
-    cache = tc.get_cache()
+    tc = get_tcache(freq)
+    cache = tc.cache()
 
     lc = len(cache)
 
@@ -939,9 +1011,7 @@ def fast_shift(ndarray[int64_t] data, object freq, int64_t n):
 
     if (data[0] < cache[0] or s + n < 0 or
         data[ld-1] > cache[lc-1] or e + n > lc):
-        tc.extend(data[0], data[ld-1], n)
-
-    cache = tc.get_cache()
+        cache = tc.extend(data[0], data[ld-1], n)
 
     result = np.empty(ld, dtype='i8')
     for i in range(ld):
diff --git a/pandas/tests/test_datetime64.py b/pandas/tests/test_datetime64.py
new file mode 100644
index 000000000..f48b591dc
--- /dev/null
+++ b/pandas/tests/test_datetime64.py
@@ -0,0 +1,247 @@
+import pandas._tseries as lib
+from datetime import datetime
+
+from pandas.core.index import DatetimeIndex
+
+import unittest
+import numpy as np
+
+from pandas import Series
+
+from numpy.random import rand, randn
+
+class TestDatetime64(unittest.TestCase):
+
+    def test_yearoffset(self):
+        off = lib.YearOffset(dayoffset=0, biz=0, anchor=datetime(2002,1,1))
+
+        for i in range(500):
+            t = lib.Timestamp(off.ts)
+            self.assert_(t.day == 1)
+            self.assert_(t.month == 1)
+            self.assert_(t.year == 2002 + i)
+            off.next()
+
+        for i in range(499, -1, -1):
+            off.prev()
+            t = lib.Timestamp(off.ts)
+            self.assert_(t.day == 1)
+            self.assert_(t.month == 1)
+            self.assert_(t.year == 2002 + i)
+
+        off = lib.YearOffset(dayoffset=-1, biz=0, anchor=datetime(2002,1,1))
+
+        for i in range(500):
+            t = lib.Timestamp(off.ts)
+            self.assert_(t.month == 12)
+            self.assert_(t.day == 31)
+            self.assert_(t.year == 2001 + i)
+            off.next()
+
+        for i in range(499, -1, -1):
+            off.prev()
+            t = lib.Timestamp(off.ts)
+            self.assert_(t.month == 12)
+            self.assert_(t.day == 31)
+            self.assert_(t.year == 2001 + i)
+
+        off = lib.YearOffset(dayoffset=-1, biz=-1, anchor=datetime(2002,1,1))
+
+        stack = []
+
+        for i in range(500):
+            t = lib.Timestamp(off.ts)
+            stack.append(t)
+            self.assert_(t.month == 12)
+            self.assert_(t.day == 31 or t.day == 30 or t.day == 29)
+            self.assert_(t.year == 2001 + i)
+            self.assert_(t.weekday() < 5)
+            off.next()
+
+        for i in range(499, -1, -1):
+            off.prev()
+            t = lib.Timestamp(off.ts)
+            self.assert_(t == stack.pop())
+            self.assert_(t.month == 12)
+            self.assert_(t.day == 31 or t.day == 30 or t.day == 29)
+            self.assert_(t.year == 2001 + i)
+            self.assert_(t.weekday() < 5)
+
+    def test_monthoffset(self):
+        off = lib.MonthOffset(dayoffset=0, biz=0, anchor=datetime(2002,1,1))
+
+        for i in range(12):
+            t = lib.Timestamp(off.ts)
+            self.assert_(t.day == 1)
+            self.assert_(t.month == 1 + i)
+            self.assert_(t.year == 2002)
+            off.next()
+
+        for i in range(11, -1, -1):
+            off.prev()
+            t = lib.Timestamp(off.ts)
+            self.assert_(t.day == 1)
+            self.assert_(t.month == 1 + i)
+            self.assert_(t.year == 2002)
+
+        off = lib.MonthOffset(dayoffset=-1, biz=0, anchor=datetime(2002,1,1))
+
+        for i in range(12):
+            t = lib.Timestamp(off.ts)
+            self.assert_(t.day >= 28)
+            self.assert_(t.month == (12 if i == 0 else i))
+            self.assert_(t.year == 2001 + (i != 0))
+            off.next()
+
+        for i in range(11, -1, -1):
+            off.prev()
+            t = lib.Timestamp(off.ts)
+            self.assert_(t.day >= 28)
+            self.assert_(t.month == (12 if i == 0 else i))
+            self.assert_(t.year == 2001 + (i != 0))
+
+        off = lib.MonthOffset(dayoffset=-1, biz=-1, anchor=datetime(2002,1,1))
+
+        stack = []
+
+        for i in range(500):
+            t = lib.Timestamp(off.ts)
+            stack.append(t)
+            if t.month != 2:
+                self.assert_(t.day >= 28)
+            else:
+                self.assert_(t.day >= 26)
+            self.assert_(t.weekday() < 5)
+            off.next()
+
+        for i in range(499, -1, -1):
+            off.prev()
+            t = lib.Timestamp(off.ts)
+            self.assert_(t == stack.pop())
+            if t.month != 2:
+                self.assert_(t.day >= 28)
+            else:
+                self.assert_(t.day >= 26)
+            self.assert_(t.weekday() < 5)
+
+        for i in (-2, -1, 1, 2):
+            for j in (-1, 0, 1):
+                off1 = lib.MonthOffset(dayoffset=i, biz=j, stride=12,
+                                       anchor=datetime(2002,1,1))
+                off2 = lib.YearOffset(dayoffset=i, biz=j,
+                                      anchor=datetime(2002,1,1))
+
+                for k in range(500):
+                    self.assert_(off1.ts == off2.ts)
+                    off1.next()
+                    off2.next()
+
+                for k in range(500):
+                    self.assert_(off1.ts == off2.ts)
+                    off1.prev()
+                    off2.prev()
+
+    def test_dayoffset(self):
+        off = lib.DayOffset(biz=0, anchor=datetime(2002,1,1))
+
+        us_in_day = 1e6 * 60 * 60 * 24
+
+        t0 = lib.Timestamp(off.ts)
+        for i in range(500):
+            off.next()
+            t1 = lib.Timestamp(off.ts)
+            self.assert_(t1.value - t0.value == us_in_day)
+            t0 = t1
+
+        t0 = lib.Timestamp(off.ts)
+        for i in range(499, -1, -1):
+            off.prev()
+            t1 = lib.Timestamp(off.ts)
+            self.assert_(t0.value - t1.value == us_in_day)
+            t0 = t1
+
+        off = lib.DayOffset(biz=1, anchor=datetime(2002,1,1))
+
+        t0 = lib.Timestamp(off.ts)
+        for i in range(500):
+            off.next()
+            t1 = lib.Timestamp(off.ts)
+            self.assert_(t1.weekday() < 5)
+            self.assert_(t1.value - t0.value == us_in_day or
+                         t1.value - t0.value == 3 * us_in_day)
+            t0 = t1
+
+        t0 = lib.Timestamp(off.ts)
+        for i in range(499, -1, -1):
+            off.prev()
+            t1 = lib.Timestamp(off.ts)
+            self.assert_(t1.weekday() < 5)
+            self.assert_(t0.value - t1.value == us_in_day or
+                         t0.value - t1.value == 3 * us_in_day)
+            t0 = t1
+
+
+    def test_dayofmonthoffset(self):
+        for week in (-1, 0, 1):
+            for day in (0, 2, 4):
+                off = lib.DayOfMonthOffset(week=-1, day=day, 
+                                           anchor=datetime(2002,1,1))
+
+                stack = []
+
+                for i in range(500):
+                    t = lib.Timestamp(off.ts)
+                    stack.append(t)
+                    self.assert_(t.weekday() == day) 
+                    off.next()
+
+                for i in range(499, -1, -1):
+                    off.prev()
+                    t = lib.Timestamp(off.ts)
+                    self.assert_(t == stack.pop())
+                    self.assert_(t.weekday() == day)
+
+    def test_datetimeindex_shift(self):
+        dti = DatetimeIndex(freq='W@TUE', start=datetime(2005,1,4), n=100)
+
+        # fast shift
+        self.assert_(dti.shift(1)[0] == datetime(2005,1,11))
+        self.assert_(dti.shift(-1)[0] == datetime(2004,12,28))
+
+        # slow shift
+        dti.contiguous = False
+        self.assert_(dti.shift(1)[0] == datetime(2005,1,11))
+        self.assert_(dti.shift(-1)[0] == datetime(2004,12,28))
+
+    def test_datetimecache(self):
+        lib.flush_tcache('W@TUE')
+
+        tc = lib.get_tcache('W@TUE', first = datetime(2004,1,6),
+                            last = datetime(2004,12,28))
+        cache = tc.cache()
+
+        self.assert_(lib.Timestamp(cache[0]) == datetime(2004,1,6))
+        self.assert_(lib.Timestamp(cache[-1]) == datetime(2004,12,28))
+
+        cache = tc.extend(cache[0], cache[-1], 1)
+
+        self.assert_(lib.Timestamp(cache[0]) == datetime(2003,12,30))
+        self.assert_(lib.Timestamp(cache[-1]) == datetime(2005,1,4))
+
+        cache = tc.extend(cache[0], cache[-1], 1)
+
+        self.assert_(lib.Timestamp(cache[0]) == datetime(2003,12,23))
+        self.assert_(lib.Timestamp(cache[-1]) == datetime(2005,1,11))
+
+        lib.flush_tcache('W@TUE')
+
+    def test_groupby_quarterly(self):
+        dti = DatetimeIndex(freq='W@TUE', start=datetime(2005,1,4), n=100)
+        s = Series(rand(100), index = dti)
+        # s.groupby('Q@FEB').mean()
+        s.groupby(lambda x: x.month).mean()
+
+if __name__ == '__main__':
+    import nose
+    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
+                   exit=False)

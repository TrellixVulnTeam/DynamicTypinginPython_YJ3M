commit b6df3f2945ba0585c1bdc97f2ad8346349dfbbcd
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Sep 9 18:37:08 2011 -0400

    ENH: skipna and unit testing for Panel

diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 043da9e40..6c751573d 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -866,34 +866,38 @@ class Panel(NDFrame):
 
     _add_docs(compound, 'compounded percentage', 'compounded')
 
-    def median(self, axis='major'):
+    def median(self, axis='major', skipna=True):
         def f(arr):
-            return _tseries.median(arr[common.notnull(arr)])
-
+            mask = common.notnull(arr)
+            if skipna:
+                return _tseries.median(arr[mask])
+            else:
+                if not mask.all():
+                    return np.nan
+                return _tseries.median(arr)
         return self.apply(f, axis=axis)
 
     _add_docs(median, 'median', 'median')
 
-    def max(self, axis='major'):
+    def max(self, axis='major', skipna=True):
         i = self._get_axis_number(axis)
 
         y = np.array(self.values)
-        mask = np.isfinite(y)
+        if skipna:
+            np.putmask(y, np.isnan(y), -np.inf)
 
-        y[-mask] = -np.inf
         result = y.max(axis=i)
         result = np.where(np.isneginf(result), np.nan, result)
         return self._wrap_result(result, axis)
 
     _add_docs(max, 'maximum', 'maximum')
 
-    def min(self, axis='major'):
+    def min(self, axis='major', skipna=True):
         i = self._get_axis_number(axis)
 
         y = np.array(self.values)
-        mask = np.isfinite(y)
-
-        y[-mask] = np.inf
+        if skipna:
+            np.putmask(y, np.isnan(y), np.inf)
 
         result = y.min(axis=i)
         result = np.where(np.isinf(result), np.nan, result)
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 65af36a0e..6c17c2b7e 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -607,6 +607,10 @@ _tsframe = DataFrame(_tsd)
 _mixed_frame = _frame.copy()
 _mixed_frame['foo'] = 'bar'
 
+class SafeForSparse(object):
+    pass
+
+
 class TestDataFrame(unittest.TestCase, CheckIndexing):
     klass = DataFrame
 
@@ -2356,54 +2360,11 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
     def test_sum(self):
         self._check_stat_op('sum', np.sum)
 
-        axis0 = self.empty.sum(0)
-        axis1 = self.empty.sum(1)
-        self.assert_(isinstance(axis0, Series))
-        self.assert_(isinstance(axis1, Series))
-        self.assertEquals(len(axis0), 0)
-        self.assertEquals(len(axis1), 0)
-
-    def test_sum_object(self):
-        values = self.frame.values.astype(int)
-        frame = DataFrame(values, index=self.frame.index,
-                           columns=self.frame.columns)
-        deltas = frame * timedelta(1)
-        deltas.sum()
-
-    def test_sum_bool(self):
-        # ensure this works, bug report
-        bools = np.isnan(self.frame)
-        bools.sum(1)
-        bools.sum(0)
-
-    def test_product(self):
-        self._check_stat_op('product', np.prod)
-
     def test_mean(self):
         self._check_stat_op('mean', np.mean)
 
-        # unit test when have object data
-        the_mean = self.mixed_frame.mean(axis=0)
-        the_sum = self.mixed_frame.sum(axis=0, numeric_only=True)
-        self.assert_(the_sum.index.equals(the_mean.index))
-        self.assert_(len(the_mean.index) < len(self.mixed_frame.columns))
-
-        # xs sum mixed type, just want to know it works...
-        the_mean = self.mixed_frame.mean(axis=1)
-        the_sum = self.mixed_frame.sum(axis=1, numeric_only=True)
-        self.assert_(the_sum.index.equals(the_mean.index))
-
-        # take mean of boolean column
-        self.frame['bool'] = self.frame['A'] > 0
-        means = self.frame.mean(0)
-        self.assertEqual(means['bool'], self.frame['bool'].values.mean())
-
-    def test_stats_mixed_type(self):
-        # don't blow up
-        self.mixed_frame.std(1)
-        self.mixed_frame.var(1)
-        self.mixed_frame.mean(1)
-        self.mixed_frame.skew(1)
+    def test_product(self):
+        self._check_stat_op('product', np.prod)
 
     def test_median(self):
         def wrapper(x):
@@ -2411,7 +2372,6 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
                 return np.nan
             return np.median(x)
 
-        self._check_stat_op('median', wrapper, frame=self.intframe)
         self._check_stat_op('median', wrapper)
 
     def test_min(self):
@@ -2480,6 +2440,59 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
 
         self.assertRaises(Exception, f, axis=2)
 
+    def test_sum_corner(self):
+        axis0 = self.empty.sum(0)
+        axis1 = self.empty.sum(1)
+        self.assert_(isinstance(axis0, Series))
+        self.assert_(isinstance(axis1, Series))
+        self.assertEquals(len(axis0), 0)
+        self.assertEquals(len(axis1), 0)
+
+    def test_sum_object(self):
+        values = self.frame.values.astype(int)
+        frame = DataFrame(values, index=self.frame.index,
+                           columns=self.frame.columns)
+        deltas = frame * timedelta(1)
+        deltas.sum()
+
+    def test_sum_bool(self):
+        # ensure this works, bug report
+        bools = np.isnan(self.frame)
+        bools.sum(1)
+        bools.sum(0)
+
+    def test_mean_corner(self):
+        # unit test when have object data
+        the_mean = self.mixed_frame.mean(axis=0)
+        the_sum = self.mixed_frame.sum(axis=0, numeric_only=True)
+        self.assert_(the_sum.index.equals(the_mean.index))
+        self.assert_(len(the_mean.index) < len(self.mixed_frame.columns))
+
+        # xs sum mixed type, just want to know it works...
+        the_mean = self.mixed_frame.mean(axis=1)
+        the_sum = self.mixed_frame.sum(axis=1, numeric_only=True)
+        self.assert_(the_sum.index.equals(the_mean.index))
+
+        # take mean of boolean column
+        self.frame['bool'] = self.frame['A'] > 0
+        means = self.frame.mean(0)
+        self.assertEqual(means['bool'], self.frame['bool'].values.mean())
+
+    def test_stats_mixed_type(self):
+        # don't blow up
+        self.mixed_frame.std(1)
+        self.mixed_frame.var(1)
+        self.mixed_frame.mean(1)
+        self.mixed_frame.skew(1)
+
+    def test_median_corner(self):
+        def wrapper(x):
+            if isnull(x).any():
+                return np.nan
+            return np.median(x)
+
+        self._check_stat_op('median', wrapper, frame=self.intframe)
+
     def test_quantile(self):
         try:
             from scipy.stats import scoreatpercentile
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index d58b73b4e..c03760498 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -8,10 +8,11 @@ import unittest
 
 import numpy as np
 
-from pandas.core.api import DataFrame, Index, notnull, pivot
+from pandas.core.api import DataFrame, Index, isnull, notnull, pivot
 from pandas.core.datetools import bday
 from pandas.core.frame import group_agg
 from pandas.core.panel import Panel, LongPanel
+from pandas.core.series import remove_na
 import pandas.core.panel as panelmod
 
 from pandas.util.testing import (assert_panel_equal,
@@ -44,114 +45,91 @@ class SafeForLongAndSparse(object):
 
     def test_count(self):
         f = lambda s: notnull(s).sum()
-
-        self._check_statistic(self.panel, 'count', f)
+        self._check_stat_op('count', f, obj=self.panel, has_skipna=False)
 
     def test_sum(self):
-        def f(x):
-            x = np.asarray(x)
-            nona = x[notnull(x)]
-
-            if len(nona) == 0:
-                return np.NaN
-            else:
-                return nona.sum()
-
-        self._check_statistic(self.panel, 'sum', f)
-
-    def test_prod(self):
-        def f(x):
-            x = np.asarray(x)
-            nona = x[notnull(x)]
-
-            if len(nona) == 0:
-                return np.NaN
-            else:
-                return np.prod(nona)
-
-        self._check_statistic(self.panel, 'prod', f)
+        self._check_stat_op('sum', np.sum)
 
     def test_mean(self):
-        def f(x):
-            x = np.asarray(x)
-            return x[notnull(x)].mean()
+        self._check_stat_op('mean', np.mean)
 
-        self._check_statistic(self.panel, 'mean', f)
+    def test_prod(self):
+        self._check_stat_op('prod', np.prod)
 
     def test_median(self):
-        def f(x):
-            x = np.asarray(x)
-            return np.median(x[notnull(x)])
+        def wrapper(x):
+            if isnull(x).any():
+                return np.nan
+            return np.median(x)
 
-        self._check_statistic(self.panel, 'median', f)
+        self._check_stat_op('median', wrapper)
 
     def test_min(self):
-        def f(x):
-            x = np.asarray(x)
-            nona = x[notnull(x)]
-
-            if len(nona) == 0:
-                return np.NaN
-            else:
-                return nona.min()
-
-        self._check_statistic(self.panel, 'min', f)
+        self._check_stat_op('min', np.min)
 
     def test_max(self):
-        def f(x):
-            x = np.asarray(x)
-            nona = x[notnull(x)]
-
-            if len(nona) == 0:
-                return np.NaN
-            else:
-                return nona.max()
+        self._check_stat_op('max', np.max)
 
-        self._check_statistic(self.panel, 'max', f)
+    # def test_mad(self):
+    #     f = lambda x: np.abs(x - x.mean()).mean()
+    #     self._check_stat_op('mad', f)
 
     def test_var(self):
-        def f(x):
-            x = np.asarray(x)
-            nona = x[notnull(x)]
-
-            if len(nona) < 2:
-                return np.NaN
-            else:
-                return nona.var(ddof=1)
-
-        self._check_statistic(self.panel, 'var', f)
+        def alt(x):
+            if len(x) < 2:
+                return np.nan
+            return np.var(x, ddof=1)
+        self._check_stat_op('var', alt)
 
     def test_std(self):
-        def f(x):
-            x = np.asarray(x)
-            nona = x[notnull(x)]
-
-            if len(nona) < 2:
-                return np.NaN
-            else:
-                return nona.std(ddof=1)
-
-        self._check_statistic(self.panel, 'std', f)
-
-    def test_skew(self):
-        return
-        try:
-            from scipy.stats import skew
-        except ImportError:
-            return
-
-        def f(x):
-            x = np.asarray(x)
-            return skew(x[notnull(x)], bias=False)
-
-        self._check_statistic(self.panel, 'skew', f)
-
-    def _check_statistic(self, frame, name, alternative):
-        f = getattr(frame, name)
-
-        for i, ax in enumerate(['items', 'major', 'minor']):
+        def alt(x):
+            if len(x) < 2:
+                return np.nan
+            return np.std(x, ddof=1)
+        self._check_stat_op('std', alt)
+
+    # def test_skew(self):
+    #     from scipy.stats import skew
+
+    #     def alt(x):
+    #         if len(x) < 3:
+    #             return np.nan
+    #         return skew(x, bias=False)
+
+    #     self._check_stat_op('skew', alt)
+
+    def _check_stat_op(self, name, alternative, obj=None, has_skipna=True):
+        if obj is None:
+            obj = self.panel
+
+            # # set some NAs
+            # obj.ix[5:10] = np.nan
+            # obj.ix[15:20, -2:] = np.nan
+
+        f = getattr(obj, name)
+
+        if has_skipna:
+            def skipna_wrapper(x):
+                nona = remove_na(x)
+                if len(nona) == 0:
+                    return np.nan
+                return alternative(nona)
+
+            def wrapper(x):
+                return alternative(np.asarray(x))
+
+            for i in range(obj.ndim):
+                result = f(axis=i, skipna=False)
+                assert_frame_equal(result, obj.apply(wrapper, axis=i))
+        else:
+            skipna_wrapper = alternative
+            wrapper = alternative
+
+        for i in range(obj.ndim):
             result = f(axis=i)
-            assert_frame_equal(result, frame.apply(alternative, axis=ax))
+            assert_frame_equal(result, obj.apply(skipna_wrapper, axis=i))
+
+        self.assertRaises(Exception, f, axis=obj.ndim)
 
 class SafeForSparse(object):
 

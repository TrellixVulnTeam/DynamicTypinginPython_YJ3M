commit 0f6d8b435670053a393b65c621d6eab090a36633
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Sep 1 15:10:47 2009 +0000

    latest edits, miscellaneous cleanup and bug fixes from development
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@8 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 88b35ed13..17c5cf22d 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -63,11 +63,7 @@ class DataFrame(Picklable, Groupable):
                     self._series[k] = v.reindex(self.index) # Forces homogoneity
                 else:
                     assert(len(v) == len(self.index))
-                    try:
-                        s = Series(v, index=self.index, dtype=float)
-                    except:
-                        s = Series(v, index=self.index)
-
+                    s = Series(v, index=self.index)
                     self._series[k] = s
         elif index is not None:
             if isinstance(index, Index):
@@ -504,7 +500,7 @@ class DataFrame(Picklable, Groupable):
     def toString(self, to_stdout=True, verbose=False, colSpace=15, nanRep=None):
         """Output a tab-separated version of this DataFrame"""
         series = self._series
-        skeys = sorted(series.keys())
+        skeys = sorted(self.cols())
         if len(skeys) == 0 or len(self.index) == 0:
             output = 'Empty DataFrame\n'
             output += self.index.__repr__()
@@ -601,7 +597,7 @@ class DataFrame(Picklable, Groupable):
             raise Exception('Must pass DateOffset!')
 
         dateRange = DateRange(self.index[0], self.index[-1], offset=freq)
-        
+
         return self.reindex(dateRange, fillMethod=fillMethod)
 
     def asMatrix(self, columns=None):
@@ -619,15 +615,12 @@ class DataFrame(Picklable, Groupable):
     # For DataMatrix compatibility
     values = property(asMatrix)
 
-    def copy(self, deep=False):
+    def copy(self):
         """
-        Make a shallow copy of this frame
-
-        Copies series dict but does not copy data / index.
+        Make a deep copy of this frame
         """
         newFrame = DataFrame(index=self.index)
-        newFrame._series = dict((k, v.copy())
-                                for k, v in self._series.iteritems())
+        newFrame._series = dict((k, v.copy()) for k, v in self.iteritems())
         return newFrame
 
     def corr(self):
@@ -1270,7 +1263,7 @@ class DataFrame(Picklable, Groupable):
 
         return mergedSeries
 
-    def merge(self, otherFrame, on):
+    def merge(self, otherFrame, on=None):
         """
         Merge DataFrame or DataMatrix with this one on some many-to-one index
 
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index b5d07df03..545eb0d4d 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -1,4 +1,7 @@
+from cStringIO import StringIO
+
 from numpy import NaN
+from numpy.lib.format import write_array, read_array
 import numpy as np
 
 from pandas.core.datetools import DateOffset
@@ -14,9 +17,9 @@ import pandas.lib.tseries as tseries
 class DataMatrix(DataFrame):
     """
     Matrix version of DataFrame, optimized for cross-section operations,
-    numerical computation, and other operations that do not require the 
+    numerical computation, and other operations that do not require the
     frame to change size.
-    
+
     Constructor params
     ------------------
     data: numpy ndarray or dict of Series
@@ -25,24 +28,24 @@ class DataMatrix(DataFrame):
         Index to use for resulting frame (optional if provided dict of Series)
     columns: Index or array-like
     dtype: dtype, default=float
-        Data type to use 
+        Data type to use
 
     Notes
     -----
     Transposing is much faster in this regime, as is calling getXS, so please
-    take note of this. 
+    take note of this.
     """
     values = None
     _columns = None
     _index = None
     objects = None
     def __init__(self, data=None, index=None, columns=None, dtype=None,
-                 objects=None):        
+                 objects=None):
 
         def handleDict(data, index, columns, objects, dtype):
             """
             Segregate Series based on type and coerce into matrices.
-            
+
             Needs to handle a lot of exceptional cases.
             """
             if len(data) == 0:
@@ -60,25 +63,25 @@ class DataMatrix(DataFrame):
 
                 if not isinstance(index, Index):
                     index = Index(index)
-                        
+
                 objectDict = {}
                 if objects is not None:
                     objectDict.update(objects)
-                
+
                 valueDict = {}
                 for k, v in data.iteritems():
                     # Forces homogoneity
                     if isinstance(v, Series):
-                        v = v.reindex(index) 
+                        v = v.reindex(index)
                     else:
                         assert(len(v) == len(index))
                         v = Series(v, index=index)
-                    
+
                     if issubclass(v.dtype.type, (float, int, bool)):
                         valueDict[k] = v
                     else:
                         objectDict[k] = v
-                
+
                 if len(valueDict) == 0:
                     dtype = np.object_
                     valueDict = objectDict
@@ -89,45 +92,90 @@ class DataMatrix(DataFrame):
                                              index=index)
                     else:
                         objects = None
-                
+
                 columns = Index(sorted(valueDict))
-                values = np.array([valueDict[k] for k in columns], 
-                                  dtype=dtype).T                  
-            
+                values = np.empty((len(index), len(columns)), dtype=dtype)
+
+                for i, col in enumerate(columns):
+                    values[:, i] = valueDict[col]
+
             return index, columns, values, objects
-        
+
         if isinstance(data, dict):
-            index, columns, values, objects = handleDict(data, index, 
-                                                         columns, objects, 
+            index, columns, values, objects = handleDict(data, index,
+                                                         columns, objects,
                                                          dtype)
         elif isinstance(data, np.ndarray):
             if data.ndim == 1:
                 # Assume is only one column
                 data = data.reshape((data.shape[0], 1))
             values = np.asarray(data)
-            
+
         elif data is None:
             if index is None:
-                values = np.empty((0, 0), dtype=dtype)
+                N = 0
                 index = NULL_INDEX
             else:
-                values = np.empty((len(index), 0), dtype=dtype)
-            columns = NULL_INDEX
+                N = len(index)
+
+            if columns is None:
+                K = 0
+                columns = NULL_INDEX
+            else:
+                K = len(columns)
+
+            values = np.empty((N, K), dtype=dtype)
+            values[:] = NaN
         else:
             raise Exception('DataMatrix constructor not properly called!')
-        
+
         if objects is not None:
             if isinstance(objects, DataMatrix):
                 if objects.index is not index:
                     self.objects = objects.reindex(index)
             else:
                 objects = DataMatrix(objects, index=index)
-        
+
         self.values = values
         self.index = index
         self.columns = columns
         self.objects = objects
-    
+
+    def __getstate__(self):
+        valsIO = StringIO()
+        colsIO = StringIO()
+        idxIO = StringIO()
+
+        write_array(valsIO, self.values)
+        write_array(colsIO, self.columns)
+        write_array(idxIO, self.index)
+
+        if self.objects is not None:
+            objects = self.objects.__getstate__()
+        else:
+            objects = None
+
+        return (valsIO.getvalue(), colsIO.getvalue(),
+                idxIO.getvalue(), objects)
+
+    def __setstate__(self, state):
+        vals, cols, idx, objects = state
+
+        def interpret(s):
+            arr = read_array(StringIO(s))
+            return arr
+
+        self.values = interpret(vals)
+        self.index = interpret(idx)
+        self.columns = interpret(cols)
+
+        if objects is not None:
+            ovals, ocols, oidx, _ = objects
+            self.objects = DataMatrix(interpret(ovals), index=self.index,
+                                      columns=interpret(ocols))
+        else:
+            self.objects = None
+
 #-------------------------------------------------------------------------------
 # Alternate constructors
 
@@ -158,33 +206,28 @@ class DataMatrix(DataFrame):
         df2 = DataMatrix.fromDict(A=seriesA, B=seriesB)
         """
         inputDict.update(kwds)
-        
+
         # Get set of indices
         indices = set([])
         for key, branch in inputDict.iteritems():
             indices = indices | set(branch.keys())
-        
+
         index = Index(sorted(indices))
-        columns = Index(sorted(inputDict))
-        
-        if castFloat:
-            mat = np.empty((len(index), len(columns)), dtype=float)
-            
-            for j, col in enumerate(columns):
-                values = inputDict[col]
-                for i, idx in enumerate(index):
-                    mat[i, j] = values.get(idx, NaN)
-            return DataMatrix(data=mat, index=index, columns=columns)
-        else:
-            df = DataFrame.fromDict(inputDict, castFloat=False)
-            return df.toDataMatrix()
+        # Convert to Series
+        series = {}
+        for col, mapping in inputDict.iteritems():
+            if not isinstance(mapping, Series):
+                mapping = Series.fromDict(mapping)
+            series[col] = mapping.reindex(index)
+
+        return DataMatrix(series, index=index)
 
     @classmethod
-    def fromMatrix(cls, mat, colNames, rowNames):        
+    def fromMatrix(cls, mat, colNames, rowNames):
         """
         Compatibility method for operations in DataFrame that use
         fromMatrix.
-        
+
         Parameters
         ----------
         mat: ndarray
@@ -193,11 +236,11 @@ class DataMatrix(DataFrame):
             Dimension N
         rowNames: iterable
             Dimension T
-        
+
         Returns
         -------
         DataMatrix
-        
+
         See also
         --------
         DataFrame.fromMatrix
@@ -207,26 +250,26 @@ class DataMatrix(DataFrame):
             assert(rows == len(rowNames))
             assert(cols == len(colNames))
         except AssertionError:
-            raise Exception('Dimensions do not match: %s, %s, %s' % 
+            raise Exception('Dimensions do not match: %s, %s, %s' %
                             (mat.shape, len(rowNames), len(colNames)))
-        
+
         index = Index(rowNames)
         colIndex = Index(colNames)
-                
+
         idxMap = colIndex.indexMap
-        
+
         return DataMatrix(mat, index=index, columns=colIndex)
-         
+
     @classmethod
     def load(cls, baseFile):
         """
         Load DataMatrix from file.
-        
+
         Parameters
         ----------
-        baseFile: string    
+        baseFile: string
             Filename base where index/values are stored.
-            e.g. baseFile='myfile' --> 'myfile_index.npy' and 
+            e.g. baseFile='myfile' --> 'myfile_index.npy' and
                                        'myfile_values.npy'
 
         Returns
@@ -234,18 +277,18 @@ class DataMatrix(DataFrame):
         DataMatrix
         """
         import os
-        
+
         objectsFile = baseFile + '_objects'
         cacheLoad = np.load(baseFile + '.npz')
-                
+
         if os.path.exists(objectsFile + '.npz'):
-            objectData = np.load(objectsFile + '.npz')        
-            objects = DataMatrix(objectData['v'], columns=objectData['c'], 
+            objectData = np.load(objectsFile + '.npz')
+            objects = DataMatrix(objectData['v'], columns=objectData['c'],
                                  index=Index(objectData['i']))
         else:
             objects = None
-                
-        return DataMatrix(cacheLoad['v'], index=Index(cacheLoad['i']), 
+
+        return DataMatrix(cacheLoad['v'], index=Index(cacheLoad['i']),
                           columns=cacheLoad['c'], objects=objects)
 
     def save(self, baseFile):
@@ -256,18 +299,18 @@ class DataMatrix(DataFrame):
         Note
         ----
         Saves data to 3 files, one for index, columns, and values matrix.
-        """        
-        
-        objectsFile = baseFile + '_objects'       
+        """
+
+        objectsFile = baseFile + '_objects'
         np.savez(baseFile, i=self.index, v=self.values, c=self.columns)
-        
+
         if self.objects is not None and len(self.objects.columns) > 0:
             self.objects.save(objectsFile)
 
 #-------------------------------------------------------------------------------
 # Outputting
-            
-    def toCSV(self, path=None, nanRep='', writeMode='wb', index=True, 
+
+    def toCSV(self, path=None, nanRep='', writeMode='wb', index=True,
               header=True, cols=None):
         """
         Write the DataMatrix to a CSV file
@@ -315,7 +358,7 @@ class DataMatrix(DataFrame):
             f.close()
         print 'CSV file written successfully: %s' % path
 
-    def toString(self, to_stdout=True, verbose=False, 
+    def toString(self, to_stdout=True, verbose=False,
                  colSpace=15, formatters=None):
         """
         Output a tab-separated version of this DataMatrix
@@ -326,12 +369,12 @@ class DataMatrix(DataFrame):
 
         if formatters is not None:
             return self._toStringFormatted(formatters)
-        
+
         mat = self.values
         cols = self.columns
         jinds = range(len(cols))
         totaljinds = range(len(self.cols()))
-        
+
         if self.objects is None:
             obj_jinds = range(0)
         else:
@@ -346,9 +389,9 @@ class DataMatrix(DataFrame):
             output.write(_pfixed('', idxSpace))
             for h in self.cols():
                 output.write(_pfixed(h, colSpace))
-          
+
             output.write('\n')
-            
+
             for i, idx in enumerate(self.index):
                 output.write(_pfixed(idx, idxSpace))
                 objcounter = 0
@@ -362,28 +405,32 @@ class DataMatrix(DataFrame):
                         vals = self.objects.values[i, objcounter]
                         output.write(_pfixed(vals, colSpace))
                         objcounter += 1
-                    
+
                 output.write('\n')
-                
+
         if to_stdout:
             print output.getvalue()
         else:
             return output.getvalue()
-        
+
     def info(self, to_stdout=True):
         """
         Concise summary of a DataMatrix, used in __repr__ when very large.
-        """        
+        """
         if len(self.columns) == 0:
             output = 'DataMatrix is empty!\n'
             output += repr(self.index)
             return output
 
-        output = 'Index: %s entries, %s to %s\n' \
-                    % (len(self.index), self.index[0], self.index[-1])
+        output = 'Index: %s entries' % len(self.index)
+        if len(self.index) > 0:
+            output += ', %s to %s\n' % (self.index[0], self.index[-1])
+        else:
+            output += '\n'
+
         output += 'Data columns:\n'
         space = max([len(str(k)) for k in self.columns]) + 4
-        
+
         isObjects = False
         try:
             counts = isfinite(self.values).sum(0)
@@ -394,34 +441,34 @@ class DataMatrix(DataFrame):
         columns = []
         if isObjects:
             for j, col in enumerate(self.columns):
-                columns.append('%s%d  non-null values' % 
+                columns.append('%s%d  non-null values' %
                                (_pfixed(col, space), counts[j]))
         else:
             for j, col in enumerate(self.columns):
-                columns.append('%s%d  non-null values' % 
+                columns.append('%s%d  non-null values' %
                                (_pfixed(col, space), counts[j]))
-    
+
         if self.objects is not None and len(self.objects.columns) > 0:
             n = len(self.objects.index)
             for col in self.objects:
                 line = '%s%d  non-null values' % (_pfixed(col, space), n)
                 columns.append(line)
-        
+
         columns.sort()
-        
+
         dtypeLine = ''
-        
+
         nf = len(self.columns)
-        df = self.values.dtype        
+        df = self.values.dtype
         if self.objects is not None:
             no = len(self.objects.columns)
             do = self.objects.values.dtype
             dtypeLine = '\ndtypes: %s(%d), %s(%d)' % (df, nf, do, no)
         else:
             dtypeLine = '\ndtype: %s(%d)' % (df, nf)
-        
+
         output += '\n'.join(columns) + dtypeLine
-        
+
         if to_stdout:
             print output
         else:
@@ -429,7 +476,7 @@ class DataMatrix(DataFrame):
 
 #-------------------------------------------------------------------------------
 # Properties for index and columns
-        
+
     def _get_columns(self):
         return self._columns
 
@@ -440,16 +487,16 @@ class DataMatrix(DataFrame):
             else:
                 self._columns = NULL_INDEX
                 return
-    
+
         if len(cols) != self.values.shape[1]:
             raise Exception('Columns length %d did not match values %d!' %
                             (len(cols), self.values.shape[1]))
-        
+
         if not isinstance(cols, Index):
             cols = Index(cols)
-            
+
         self._columns = cols
-    
+
     columns = property(fget=_get_columns, fset=_set_columns)
 
     def _set_index(self, index):
@@ -464,20 +511,20 @@ class DataMatrix(DataFrame):
             if len(index) != self.values.shape[0]:
                 raise Exception('Index length %d did not match values %d!' %
                                 (len(index), self.values.shape[0]))
-            
+
         if not isinstance(index, Index):
             index = Index(index)
-            
+
         self._index = index
-        
+
     def _get_index(self):
         return self._index
-    
+
     index = property(fget=_get_index, fset=_set_index)
 
 #-------------------------------------------------------------------------------
 # "Magic methods"
-        
+
     def __nonzero__(self):
         if self.values is not None:
             N, K = self.values.shape
@@ -493,46 +540,45 @@ class DataMatrix(DataFrame):
                 return False
             else:
                 return self.objects.__nonzero__()
-        
+
     def __neg__(self):
         mycopy = self.copy()
         mycopy.values = -mycopy.values
         return mycopy
 
     def __repr__(self):
-        """Return a string representation for a particular DataMatrix"""
-        if self.values is None or len(self.values) == 0:
-            return 'Empty DataMatrix\nIndex: %s' % repr(self.index)
-        if len(self.index) < 1000 and self.values.shape[1] < 10:
+        if self.values is None or len(self.columns) == 0:
+            output = 'Empty DataMatrix\nIndex: %s' % repr(self.index)
+        elif 0 < len(self.index) < 1000 and self.values.shape[1] < 10:
             output = self.toString(to_stdout=False)
         else:
             output = str(self.__class__) + '\n'
             output = output + self.info(to_stdout=False)
-                
+
         return output
-    
+
     def __getitem__(self, item):
         """
         Retrieve column, slice, or subset from DataMatrix.
-        
+
         Possible inputs
         ---------------
         single value: retrieve a column as a Series
         slice: reindex to indices specified by slice
         boolean vector: like slice but more general, reindex to indices
           where the input vector is True
-        
+
         Examples
         --------
         column = dm['A']
-        
+
         dmSlice = dm[:20] # First 20 rows
-        
+
         dmSelect = dm[dm.count(axis=1) > 10]
-        
+
         Note
         ----
-        This is a magic method. Do NOT call explicity. 
+        This is a magic method. Do NOT call explicity.
         """
         if isinstance(item, slice):
             start, stop = item.start, item.stop
@@ -548,7 +594,7 @@ class DataMatrix(DataFrame):
                 newObjects = self.objects.reindex(indexRange)
             else:
                 newObjects = None
-                
+
             return DataMatrix(data=self.values[start:stop], index=indexRange,
                               columns=self.columns, objects=newObjects)
         elif isinstance(item, np.ndarray):
@@ -562,7 +608,7 @@ class DataMatrix(DataFrame):
                 return self.objects[item]
             else:
                 return self._getSeries(item)
-    
+
     _dataTypes = [np.float_, np.bool_, np.int_]
     def __setitem__(self, key, value):
         """
@@ -572,18 +618,18 @@ class DataMatrix(DataFrame):
         same length as the DataMatrix's index or an error will be thrown.
 
         Series/TimeSeries will be conformed to the DataMatrix's index to
-        ensure homogeneity. 
+        ensure homogeneity.
         """
         import bisect
-        
+
         isObject = False
         if hasattr(value, '__iter__'):
             if isinstance(value, Series):
                 value = np.asarray(value.reindex(self.index))
-                
+
             else:
                 assert(len(value) == len(self.index))
-                
+
                 if not isinstance(value, np.ndarray):
                     value = np.array(value)
                     if value.dtype.type == np.str_:
@@ -596,7 +642,7 @@ class DataMatrix(DataFrame):
 
         if value.dtype not in self._dataTypes:
             isObject = True
-            
+
         if self.values is None:
             if isObject:
                 if self.objects is None:
@@ -608,7 +654,7 @@ class DataMatrix(DataFrame):
                 self.values = value.reshape((len(value), 1))
                 self.columns = Index([key])
             return
-                
+
         if self.values.dtype == np.object_:
             if key in self.columns:
                 loc = self.columns.indexMap[key]
@@ -625,11 +671,11 @@ class DataMatrix(DataFrame):
                     newValues = np.c_[value, self.values]
                     newColumns = Index(np.concatenate(([key], self.columns)))
                 else:
-                    newValues = np.c_[self.values[:, :loc], value, 
+                    newValues = np.c_[self.values[:, :loc], value,
                                       self.values[:, loc:]]
                     toConcat = (self.columns[:loc], [key], self.columns[loc:])
                     newColumns = Index(np.concatenate(toConcat))
-                self.values = newValues            
+                self.values = newValues
                 self.columns = newColumns
         else:
             if key in self.columns:
@@ -653,13 +699,13 @@ class DataMatrix(DataFrame):
                     newValues = np.c_[value, self.values]
                     newColumns = Index(np.concatenate(([key], self.columns)))
                 else:
-                    newValues = np.c_[self.values[:, :loc], value, 
+                    newValues = np.c_[self.values[:, :loc], value,
                                       self.values[:, loc:]]
                     toConcat = (self.columns[:loc], [key], self.columns[loc:])
                     newColumns = Index(np.concatenate(toConcat))
                 self.values = newValues
                 self.columns = newColumns
-        
+
     def __delitem__(self, key):
         """
         Delete column from DataMatrix
@@ -672,14 +718,14 @@ class DataMatrix(DataFrame):
                 newColumns = self.columns[:loc]
             else:
                 newValues = np.c_[self.values[:, :loc], self.values[:, loc+1:]]
-                newColumns = Index(np.concatenate((self.columns[:loc], 
+                newColumns = Index(np.concatenate((self.columns[:loc],
                                                    self.columns[loc+1:])))
             self.values = newValues
             self.columns = newColumns
-        
+
         if self.objects is not None and key in self.objects:
             del self.objects[key]
-                
+
     def __iter__(self):
         """Iterate over columns of the frame."""
         return iter(self.columns)
@@ -708,7 +754,7 @@ class DataMatrix(DataFrame):
             except KeyError:
                 raise Exception('%s not here!' % item)
         return Series(self.values[:, loc], index=self.index)
-        
+
     def _getSeriesDict(self):
         series = {}
         for i, col in enumerate(self.columns):
@@ -716,13 +762,13 @@ class DataMatrix(DataFrame):
         if self.objects is not None:
             for i, col in enumerate(self.objects.columns):
                 series[col] = self.objects._getSeries(loc=i)
-                
+
         return series
     _series = property(_getSeriesDict)
 
     def _firstTimeWithNValues(self):
         # Need to test this!
-        N = len(self._series)        
+        N = len(self._series)
         selector = (self.count(1) == N)
         if not selector.any():
             raise Exception('No time has %d values!' % N)
@@ -736,7 +782,7 @@ class DataMatrix(DataFrame):
         """
         if len(newCols) == 0:
             return DataMatrix(index=self.index)
-        
+
         T, N = len(self.index), len(newCols)
 
         resultMatrix = np.empty((T, N), dtype=self.values.dtype)
@@ -750,7 +796,7 @@ class DataMatrix(DataFrame):
         resultIndexer = [newCols.indexMap[idx] for idx in overlap]
 
         resultMatrix[:, resultIndexer] = self.values[:, thisIndexer]
-        
+
         return DataMatrix(resultMatrix, index=self.index, columns=newCols,
                           objects=self.objects)
 
@@ -758,13 +804,13 @@ class DataMatrix(DataFrame):
         """
         Methodology, briefly
         - Really concerned here about speed, space
-        
+
         - Get new index
         - Reindex to new index
         - Determine newColumns and commonColumns
         - Add common columns over all (new) indices
-        - Fill to new set of columns            
-        
+        - Fill to new set of columns
+
         Could probably deal with some Cython action in here at some point
         """
         if self.index is other.index:
@@ -772,7 +818,7 @@ class DataMatrix(DataFrame):
             myReindex = self
             hisReindex = other
         else:
-            newIndex = self.index.union(other.index)                
+            newIndex = self.index.union(other.index)
             myReindex = self.reindex(newIndex)
             hisReindex = other.reindex(newIndex)
 
@@ -782,7 +828,7 @@ class DataMatrix(DataFrame):
             return other * NaN
         elif not other:
             return self * NaN
-            
+
         myValues = myReindex.values
         if self.columns is other.columns:
             newCols = self.columns
@@ -799,12 +845,12 @@ class DataMatrix(DataFrame):
             T, N = len(newIndex), len(newCols)
             resultMatrix = np.empty((T, N), dtype=self.values.dtype)
             resultMatrix.fill(NaN)
-                
+
             myIndexer = [self.columns.indexMap[idx] for idx in commonCols]
             hisIndexer =  [hisCols.indexMap[idx] for idx in commonCols]
             resultIndexer = [newCols.indexMap[idx] for idx in commonCols]
-                
-            resultMatrix[:, resultIndexer] = func(myValues[:, myIndexer], 
+
+            resultMatrix[:, resultIndexer] = func(myValues[:, myIndexer],
                                                   hisValues[:, hisIndexer])
 
         # TODO: deal with objects
@@ -819,44 +865,44 @@ class DataMatrix(DataFrame):
                 newIndex = self.index
             else:
                 newIndex = self.index + other.index
-                
+
             if not self:
                 return DataMatrix(index=newIndex)
-                
+
             other = other.reindex(newIndex).view(np.ndarray)
             myReindex = self.reindex(newIndex)
             resultMatrix = func(myReindex.values.T, other).T
         else:
             if len(other) == 0:
                 return self * NaN
-            
+
             # Operate column-wise
             other = other.reindex(self.columns).view(np.ndarray)
-            resultMatrix = func(self.values, other)                
-        
+            resultMatrix = func(self.values, other)
+
         # TODO: deal with objects
         return DataMatrix(resultMatrix, index=newIndex, columns=newCols)
 
     def _combineFunc(self, other, func):
         """
         Combine DataMatrix objects with other Series- or DataFrame-like objects
-        
+
         This is the core method used for the overloaded arithmetic methods
 
         Result hierarchy
         ----------------
         DataMatrix + DataFrame --> DataMatrix
-        DataMatrix + DataMatrix --> DataMatrix 
+        DataMatrix + DataMatrix --> DataMatrix
         DataMatrix + Series --> DataMatrix
         DataMatrix + constant --> DataMatrix
 
         The reason for 'upcasting' the result is that if addition succeed,
-        we can assume that the input DataFrame was homogeneous. 
+        we can assume that the input DataFrame was homogeneous.
         """
         newIndex = self.index
         if isinstance(other, DataFrame):
             return self._combineFrame(other, func)
-        
+
         elif isinstance(other, Series):
             return self._combineSeries(other, func)
 
@@ -880,15 +926,15 @@ class DataMatrix(DataFrame):
     def asMatrix(self, columns=None):
         """
         Convert the DataMatrix to its Numpy-array matrix representation
-        
+
         Columns are presented in sorted order unless a specific list
         of columns is provided.
-        
+
         Parameters
         ----------
         columns: list-like
             columns to use in producing matrix, must all be contained
-            
+
         Returns
         -------
         ndarray
@@ -915,7 +961,7 @@ class DataMatrix(DataFrame):
             valsCopy = self.values.copy()
         else:
             valsCopy = None
-        return DataMatrix(valsCopy, index=self.index, 
+        return DataMatrix(valsCopy, index=self.index,
                           columns=self.columns, objects=self.objects)
 
     def cumsum(self, axis=0, asarray=False):
@@ -935,27 +981,27 @@ class DataMatrix(DataFrame):
         theSum = y.cumsum(axis)
         if asarray:
             return theSum
-        return DataMatrix(theSum, index=self.index, 
+        return DataMatrix(theSum, index=self.index,
                           columns=self.columns, objects=self.objects)
 
     def dropEmptyRows(self, specificColumns=None):
         """
-        Return DataMatrix with rows omitted containing ALL NaN values 
+        Return DataMatrix with rows omitted containing ALL NaN values
         for optionally specified set of columns.
 
         Parameters
         ----------
         specificColumns: list-like, optional keyword
-            Columns to consider in removing NaN values. As a typical 
-            application, you might provide the list of the columns involved in 
+            Columns to consider in removing NaN values. As a typical
+            application, you might provide the list of the columns involved in
             a regression to exclude all the missing data in one shot.
 
         Returns
         -------
-        DataMatrix with rows containing any NaN values deleted    
+        DataMatrix with rows containing any NaN values deleted
         """
         T, N = self.values.shape
-        
+
         if specificColumns:
             theCount = self.filterItems(specificColumns).count(axis=1,
                                                                asarray=True)
@@ -963,25 +1009,25 @@ class DataMatrix(DataFrame):
             theCount = self.count(axis=1, asarray=True)
 
         return self.reindex(self.index[theCount > 0])
-    
+
     def dropIncompleteRows(self, specificColumns=None, minObs=None):
         """
-        Return DataFrame with rows omitted containing ANY NaN values for 
+        Return DataFrame with rows omitted containing ANY NaN values for
         optionally specified set of columns.
-    
+
         Parameters
         ----------
         minObs: int or None (default)
            Instead of requiring all the columns to have observations, require
            only minObs observations
         specificColumns: list-like, optional keyword
-            Columns to consider in removing NaN values. As a typical 
-            application, you might provide the list of the columns involved in 
+            Columns to consider in removing NaN values. As a typical
+            application, you might provide the list of the columns involved in
             a regression to exlude all the missing data in one shot.
-        
+
         Returns
         -------
-        This DataFrame with rows containing any NaN values deleted    
+        This DataFrame with rows containing any NaN values deleted
         """
         T, N = self.values.shape
         if specificColumns:
@@ -990,7 +1036,7 @@ class DataMatrix(DataFrame):
             N = len(cols)
         else:
             theCount = self.count(axis=1, asarray=True)
-        
+
         if minObs is None:
             minObs = N
 
@@ -1001,19 +1047,19 @@ class DataMatrix(DataFrame):
         Fill NaN values using the specified method.
 
         Member Series / TimeSeries are filled separately.
-        
+
         Parameters
-        ----------        
+        ----------
         value: any kind (should be same type as array)
             Value to use to fill holes (e.g. 0)
-            
+
         method: {'backfill', 'pad', None}
             Method to use for filling holes in new inde
-        
+
         Returns
         -------
         DataMatrix with NaN's filled
-            
+
         See also
         --------
         reindex, asfreq
@@ -1023,8 +1069,8 @@ class DataMatrix(DataFrame):
             for col in self._series:
                 series = self._series[col]
                 filledSeries = series.fill(method=method, value=value)
-    
-                result[col] = filledSeries            
+
+                result[col] = filledSeries
             return DataMatrix(result, index=self.index, objects=self.objects)
         else:
             def fillfunc(vec):
@@ -1036,7 +1082,7 @@ class DataMatrix(DataFrame):
                 # Float type values
                 if len(self.columns) == 0:
                     return self
-                
+
                 vals = self.values.copy()
                 vals[-np.isfinite(self.values)] = value
                 objectsToUse = None
@@ -1044,36 +1090,36 @@ class DataMatrix(DataFrame):
                     objectsToUse = self.objects.copy()
                 return DataMatrix(vals, index=self.index, columns=self.columns,
                                   objects=objectsToUse)
-            
+
             elif self.values.dtype == np.object_:
                 # Object type values
                 if len(self.columns) == 0:
                     return self
-                
+
                 myCopy = self.copy()
-                                
+
                 vals = myCopy.values
                 myCopy.values = np.apply_along_axis(fillfunc, 0, vals)
-                
+
                 return myCopy
             else:
                 # Object type values
                 if len(self.objects.columns) == 0:
                     return self
-                
-                myCopy = self.copy()                    
+
+                myCopy = self.copy()
                 vals = myCopy.objects.values
                 myCopy.objects.values = np.apply_along_axis(fillfunc, 0, vals)
-                
-                return myCopy    
-        
+
+                return myCopy
+
     def getTS(self, colName=None, fromDate=None, toDate=None, nPeriods=None):
         """
         Return a DataMatrix / TimeSeries corresponding to given arguments
 
         Parameters
         ----------
-        colName: string or None 
+        colName: string or None
             particular column name requested, fine to leave blank
         fromDate: datetime
         toDate: datetime
@@ -1082,13 +1128,13 @@ class DataMatrix(DataFrame):
         Note
         ----
         Error thrown if all of fromDate, toDate, nPeriods specified.
-        
+
         Returns
         -------
-        DataMatrix or TimeSeries 
+        DataMatrix or TimeSeries
         """
         # Should use bisect in here
-        
+
         if toDate:
             if toDate not in self.index:
                 if toDate > self.index[0]:
@@ -1106,7 +1152,7 @@ class DataMatrix(DataFrame):
             if nPeriods:
                 raise Exception('fromDate/toDate, toDate/nPeriods, ' +
                                 'fromDate/nPeriods are mutually exclusive')
-            beg_slice = self.index.indexMap[fromDate]    
+            beg_slice = self.index.indexMap[fromDate]
             end_slice = self.index.indexMap[toDate] + 1
         elif fromDate and nPeriods:
             beg_slice = self.index.indexMap[fromDate]
@@ -1130,8 +1176,8 @@ class DataMatrix(DataFrame):
             newLinks = None
             if self.objects is not None and len(self.objects.columns) > 0:
                 newLinks = self.objects.reindex(dateRange)
-            
-            return DataMatrix(newValues, index=dateRange, 
+
+            return DataMatrix(newValues, index=dateRange,
                               columns=self.columns, objects=newLinks)
 
     def getXS(self, key, subset=None, asOf=False):
@@ -1144,7 +1190,7 @@ class DataMatrix(DataFrame):
         subset: iterable (list, array, set, etc.), optional
             columns to be included
         asOf: boolean, optional
-            Whether to use asOf values for TimeSeries objects 
+            Whether to use asOf values for TimeSeries objects
             Won't do anything for Series objects.
 
         Note
@@ -1153,9 +1199,9 @@ class DataMatrix(DataFrame):
         """
         if key not in self.index:
             raise Exception('No cross-section for %s' % key)
-        
+
         loc = self.index.indexMap[key]
-        
+
         if subset:
             subset = np.unique(subset)
             indexer = [self.columns.indexMap[col] for col in subset]
@@ -1164,30 +1210,30 @@ class DataMatrix(DataFrame):
         else:
             theSlice = self.values[loc, :].copy()
             xsIndex = self.columns
-            
+
         result = Series(theSlice, index=xsIndex)
-        
+
         if self.objects is not None and len(self.objects.columns) > 0:
             result = result.append(self.objects.getXS(key))
-        
+
         return result
 
     def merge(self, otherFrame, on=None):
         """
         Merge DataFrame or DataMatrix with this one on some many-to-one index
-        
+
         Parameters
         ----------
         otherFrame: DataFrame
             Index should be similar to one of the columns in this one
         on: string
             Column name to use
-        
+
         Example
         -------
         This frame         Other frame
             c1                 q1
-        a   1              0   v1  
+        a   1              0   v1
         b   0              1   v2
         c   1
         d   0
@@ -1197,33 +1243,33 @@ class DataMatrix(DataFrame):
 
         if on not in self:
             raise Exception('%s column not contained in this frame!' % on)
-        
+
         otherM = otherFrame.asMatrix()
         indexMap = otherFrame.index.indexMap
-        
+
         fillVec, mask = tseries.getMergeVec(self[on], indexMap)
 
         tmpMatrix = otherM[fillVec]
         tmpMatrix[-mask] = NaN
-        
-        seriesDict = dict((col, tmpMatrix[:, j]) 
+
+        seriesDict = dict((col, tmpMatrix[:, j])
                            for j, col in enumerate(otherFrame.columns))
-        
+
         if getattr(otherFrame, 'objects'):
             objects = otherFrame.objects
-            
+
             objM = objects.asMatrix()
             cols = objects.columns
-            
+
             tmpMat = objM[fillVec]
             tmpMat[-mask] = NaN
             objDict = dict((col, tmpMat[:, j])
                            for j, col in enumerate(objects.columns))
-            
+
             seriesDict.update(objDict)
-        
+
         filledFrame = DataFrame(data=seriesDict, index=self.index)
-        
+
         return self.leftJoin(filledFrame)
 
     def reindex(self, newIndex, fillMethod = None):
@@ -1243,7 +1289,7 @@ class DataMatrix(DataFrame):
         """
         if newIndex is self.index:
             return self
-        
+
         if len(newIndex) == 0:
             return DataMatrix(index=NULL_INDEX)
 
@@ -1251,10 +1297,9 @@ class DataMatrix(DataFrame):
             newIndex = Index(newIndex)
 
         if len(self.index) == 0:
-            return DataMatrix(index=newIndex)
-                    
-        selfM = self.values
+            return DataMatrix(index=newIndex, columns=self.columns)
 
+        selfM = self.values
         oldMap = self.index.indexMap
         newMap = newIndex.indexMap
 
@@ -1266,7 +1311,7 @@ class DataMatrix(DataFrame):
         if fillMethod not in ['BACKFILL', 'PAD', '']:
             raise Exception("Don't recognize fillMethod: %s" % fillMethod)
 
-        fillVec, mask = tseries.getFillVec(self.index, newIndex, oldMap, 
+        fillVec, mask = tseries.getFillVec(self.index, newIndex, oldMap,
                                            newMap, fillMethod)
 
         tmpMatrix = selfM[fillVec]
@@ -1277,13 +1322,13 @@ class DataMatrix(DataFrame):
         else:
             newLinks = None
 
-        return DataMatrix(tmpMatrix, index=newIndex, 
+        return DataMatrix(tmpMatrix, index=newIndex,
                           columns=self.columns, objects=newLinks)
 
     @property
     def T(self):
         """
-        Returns a DataMatrix with the rows/columns switched. 
+        Returns a DataMatrix with the rows/columns switched.
         """
         if self.objects is not None:
             objectsT = self.objects.values.T
@@ -1291,7 +1336,7 @@ class DataMatrix(DataFrame):
             newValues = np.concatenate((valuesT, objectsT), axis=0)
             newIndex = Index(np.concatenate((self.columns,
                                              self.objects.columns)))
-            
+
             return DataMatrix(newValues, index=newIndex, columns=self.index)
         else:
             return DataMatrix(data=self.values.T, index=self.columns,
@@ -1299,7 +1344,7 @@ class DataMatrix(DataFrame):
 
     def shift(self, periods, offset=None):
         """
-        Shift the underlying series of the DataMatrix and Series objects within 
+        Shift the underlying series of the DataMatrix and Series objects within
         by given number (positive or negative) of business/weekdays.
 
         Parameters
@@ -1332,7 +1377,7 @@ class DataMatrix(DataFrame):
     def apply(self, func, axis=0):
         """
         Applies func to columns (Series) of this DataMatrix and returns either
-        a DataMatrix (if the function produces another series) or a Series 
+        a DataMatrix (if the function produces another series) or a Series
         indexed on the column names of the DataFrame if the function produces
         a value.
 
@@ -1340,20 +1385,20 @@ class DataMatrix(DataFrame):
         ----------
         func: function
             Function to apply to each column
-        
+
         Example
         -------
-            
+
             >>> df.apply(numpy.sqrt) --> DataMatrix
             >>> df.apply(numpy.sum) --> Series
 
-        N.B.: Do NOT use functions that might toy with the index. 
+        N.B.: Do NOT use functions that might toy with the index.
         """
         if not len(self.cols()):
             return self
-        
+
         results = {}
-        
+
         if isinstance(func, np.ufunc):
             results = func(self.values)
         else:
@@ -1361,9 +1406,9 @@ class DataMatrix(DataFrame):
                 results = dict([(k, func(v)) for k, v in self.iteritems()])
             elif axis == 1:
                 results = dict([(k, func(v)) for k, v in self.T.iteritems()])
-                
+
         if isinstance(results, np.ndarray):
-            return DataMatrix(data=results, index=self.index, 
+            return DataMatrix(data=results, index=self.index,
                               columns=self.columns, objects=self.objects)
         elif isinstance(results, dict):
             if isinstance(results.values()[0], np.ndarray):
@@ -1372,7 +1417,7 @@ class DataMatrix(DataFrame):
                 return Series.fromDict(results)
         else:
             raise Exception('This is ridiculous')
-    
+
     def tapply(self, func):
         """
         Apply func to the transposed DataMatrix, results as per above.
@@ -1381,7 +1426,7 @@ class DataMatrix(DataFrame):
 
     def applymap(self, func):
         """
-        Apply a function to a DataMatrix that is intended to operate 
+        Apply a function to a DataMatrix that is intended to operate
         elementwise, i.e. like doing
             map(func, series) for each series in the DataMatrix
 
@@ -1389,7 +1434,7 @@ class DataMatrix(DataFrame):
         ----------
         func: function
             Python function, returns a single value from a single value
-        
+
         Note: try to avoid using this function if you can, very slow.
         """
         npfunc = np.frompyfunc(func, 1, 1)
@@ -1405,12 +1450,12 @@ class DataMatrix(DataFrame):
     def filterItems(self, items):
         """
         Restrict frame's columns to input set of items.
-        
+
         Parameters
         ----------
         items: list-like
             List of columns to restrict to (must not all be present)
-            
+
         Returns
         -------
         DataMatrix with filtered columns
@@ -1425,12 +1470,12 @@ class DataMatrix(DataFrame):
     def filterLike(self, arg):
         """
         Filter to columns partially matching the import argument.
-        
+
         Keep columns where "arg in col == True"
-        
+
         Parameter
         ---------
-        arg: string        
+        arg: string
 
         Return
         ------
@@ -1438,29 +1483,29 @@ class DataMatrix(DataFrame):
         """
         newCols = Index([c for c in self.columns if arg in c])
         return self._withColumns(newCols)
-        
+
     def combineFirst(self, otherFrame):
         """
         Combine two DataFrame / DataMatrix objects and default to value
         in frame calling the method.
-        
+
         Example: a.combineFirst(b)
             a's values prioritized, use values from b to fill holes
 
         Parameters
         ----------
         otherFrame: DataFrame / Matrix
-        
+
         Returns
         -------
         DataMatrix
         """
         if not otherFrame:
             return self
-        
+
         if not self:
             return otherFrame
-        
+
         if self.index is not otherFrame.index:
             unionIndex = self.index + otherFrame.index
             frame = self.reindex(unionIndex)
@@ -1468,16 +1513,12 @@ class DataMatrix(DataFrame):
         else:
             unionIndex = self.index
             frame = self
-        
-        colSet = set(frame.cols())
-        if colSet - set(otherFrame.cols()) == colSet:
-            return frame.T.append(otherFrame.T).T
-            
+
         result = {}
         for col, series in frame.iteritems():
             otherSeries = otherFrame[col] if col in otherFrame else None
             if otherSeries is not None:
-                result[col] = series.__class__(np.where(isnull(series), 
+                result[col] = series.__class__(np.where(isnull(series),
                                                         otherSeries, series),
                                                index=unionIndex)
             else:
@@ -1487,25 +1528,25 @@ class DataMatrix(DataFrame):
             if col not in self:
                 result[col] = series
 
-        return DataMatrix(result, index = unionIndex)    
-    
+        return DataMatrix(result, index = unionIndex)
+
     def combineAdd(self, otherFrame):
         """
         Add two DataFrame / DataMatrix objects and do not propagate NaN values,
-        so if for a (column, time) one frame is missing a value, it will 
+        so if for a (column, time) one frame is missing a value, it will
         default to the other frame's value (which might be NaN as well)
 
         Parameters
         ----------
         otherFrame: DataFrame / Matrix
-        
+
         Returns
         -------
         DataMatrix
         """
         if not otherFrame:
             return self
-        
+
         if not self:
             return otherFrame
 
@@ -1518,7 +1559,7 @@ class DataMatrix(DataFrame):
             frame = self
 
         unionCols = sorted(set(frame.cols() + otherFrame.cols()))
-        
+
         result = {}
         for col in unionCols:
             if col in frame and col in otherFrame:
@@ -1543,14 +1584,14 @@ class DataMatrix(DataFrame):
     def outerJoin(self, *frames):
         """
         Form union of input frames.
-        
+
         Columns must not overlap. Returns a copy.
-        
+
         Parameters
         ----------
         *frames: list-like
             List of frames (DataMatrix or DataFrame) as function arguments
-        
+
         Returns
         -------
         DataMatrix
@@ -1567,64 +1608,64 @@ class DataMatrix(DataFrame):
                     raise Exception('Overlapping columns!')
                 mergedSeries[col] = series
 
-        return DataMatrix.fromDict(mergedSeries)        
-    
+        return DataMatrix.fromDict(mergedSeries)
+
     def leftJoin(self, *frames, **kwds):
         """
         Insert columns of input DataFrames / dicts into this one.
-        
+
         Columns must not overlap. Returns a copy.
-        
+
         Parameters
         ----------
         *frames: list-like
             List of frames (DataMatrix or DataFrame) as function arguments
-        
+
         Keyword args
         ------------
         coerceTo: type or dtype
-            
+
         Returns
         -------
         DataMatrix
         """
-        
-        unionCols = set(self.columns)            
+
+        unionCols = set(self.columns)
         frames = list(frames)
-        
+
         for frame in frames:
             cols = set(frame.columns)
             if any(unionCols & cols):
                 raise Exception('Overlapping columns!')
-            unionCols |= cols                
-        
+            unionCols |= cols
+
         newColumns = Index(sorted(unionCols))
         seriesDict = self._series
-        
+
         for frame in frames:
             frame = frame.reindex(self.index)
             seriesDict.update(frame._series)
-            
+
         return DataMatrix(seriesDict, index=self.index)
 
-    def append(self, otherDM):
-        if not otherDM:
+    def append(self, otherFrame):
+        if not otherFrame:
             return self
         if not self:
             return otherFrame
-        if (isinstance(otherDM, DataMatrix) and
-            list(self.columns) == list(otherDM.columns)):
-            if len(self.index.diff(otherDM.index)) != len(self.index):
-                raise ValueError('Index cannot overlap')
-            idx = self.index + otherDM.index
-            mat = np.vstack((self.values, otherDM.values))
+        if (isinstance(otherFrame, DataMatrix) and
+            list(self.columns) == list(otherFrame.columns)):
+            #if len(self.index.diff(otherFrame.index)) != len(self.index):
+            #    raise ValueError('Index cannot overlap')
+            idx = Index(np.concatenate([self.index, otherFrame.index]))
+            mat = np.vstack((self.values, otherFrame.values))
             dm = DataMatrix(mat, idx, self.columns)
-            if otherDM.objects is None:                
+            if otherFrame.objects is None:
                 dm.objects = self.objects
             elif self.objects is None:
-                dm.objects = otherDM.objects
+                dm.objects = otherFrame.objects
             else:
-                dm.objects = self.objects.append(otherDM.objects)
+                dm.objects = self.objects.append(otherFrame.objects)
             return dm
         else:
-            return super(DataMatrix, self).append(otherDM)
+            return super(DataMatrix, self).append(otherFrame)
diff --git a/pandas/core/series.py b/pandas/core/series.py
index dfd6d14b9..c25883069 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -15,7 +15,7 @@ import pandas.lib.tseries as tseries
 
 #-------------------------------------------------------------------------------
 # Series class
-    
+
 class Series(np.ndarray, Picklable, Groupable):
     """Generic indexed series (time series or otherwise) object.
 
@@ -26,11 +26,11 @@ class Series(np.ndarray, Picklable, Groupable):
     index: array-like, optional
         Index object (or other iterable of same length as data)
 
-    Contains values in a numpy-ndarray with an optional bound index (also 
-    an array of dates, strings, or whatever you want the 'row names' of 
+    Contains values in a numpy-ndarray with an optional bound index (also
+    an array of dates, strings, or whatever you want the 'row names' of
     your series to be)
 
-    Rows can be retrieved by index value (date, string, etc.) or 
+    Rows can be retrieved by index value (date, string, etc.) or
     relative position in the underlying array.
 
     Operations between Series (+, -, /, *, **) objects are *index-safe*,
@@ -57,13 +57,13 @@ class Series(np.ndarray, Picklable, Groupable):
         if not isinstance(index, indexTypes):
             raise TypeError("Expected index to be in %s; was %s."
                             % (indexTypes, type(index)))
-        
+
         # Make a copy of the data, infer type
         subarr = np.array(data, dtype=dtype, copy=copy)
 
         if not subarr.shape:
             return np.float64(subarr)
-        
+
         """
         This is to prevent mixed-type Series getting all casted
         to NumPy string type, e.g. NaN --> '-1#IND'.
@@ -79,19 +79,19 @@ class Series(np.ndarray, Picklable, Groupable):
             try:
                 assert(len(data) == len(index))
             except AssertionError:
-                raise Exception('Lengths of index and values did not match!') 
+                raise Exception('Lengths of index and values did not match!')
             if isinstance(index, Index):
                 subarr.index = index
             else:
-                subarr.index = Index(index)        
+                subarr.index = Index(index)
         elif hasattr(data, 'index'):
             subarr.index = data.index
         else:
             raise Exception('Index cannot be None!')
-        
+
         if subarr.index._allDates:
             subarr = subarr.view(TimeSeries)
-            
+
         return subarr
 
     def __array_finalize__(self, obj):
@@ -100,25 +100,25 @@ class Series(np.ndarray, Picklable, Groupable):
         to pass on the index.
         """
         self.index = getattr(obj, 'index', None)
-        
+
     @classmethod
     def fromDict(cls, input={}, castFloat=True, **kwds):
         """
         Analogous to asDataFrame, but turns dict into Series
-        
+
         Parameters
         ----------
         input: dict object
             Keys become indices of returned Series
         kwds: optionally provide arguments as keywords
-        
+
         Returns
         -------
         Series
         """
         input = input.copy()
         input.update(kwds)
-        
+
         index = Index(sorted(input.keys()))
         if castFloat:
             try:
@@ -127,26 +127,26 @@ class Series(np.ndarray, Picklable, Groupable):
                 useData = [input[idx] for idx in index]
         else:
             useData = [input[idx] for idx in index]
-        return Series(useData, index=index) 
+        return Series(useData, index=index)
 
     @classmethod
     def fromValue(cls, value=np.NaN, index=None, dtype=None):
         """
         Analogous to asDataFrame, but turns dict into Series
-        
+
         Parameters
         ----------
         input: dict object
             Keys become indices of returned Series
         kwds: optionally provide arguments as keywords
-        
+
         Returns
         -------
         Series
-        """        
+        """
         if not isinstance(index, Index):
             index = Index(index)
-        
+
         # If we create an empty array using a string to infer
         # the dtype, NumPy will only allocate one character per entry
         # so this is kind of bad. Alternately we could use np.repeat
@@ -154,23 +154,23 @@ class Series(np.ndarray, Picklable, Groupable):
         # coming out as np.str_!
         if isinstance(value, basestring):
             dtype = np.object_
-        
-        if dtype is None:    
+
+        if dtype is None:
             arr = np.empty(len(index), dtype=type(value))
         else:
             arr = np.empty(len(index), dtype=dtype)
         arr.fill(value)
-        
-        return Series(arr, index=index) 
+
+        return Series(arr, index=index)
 
     @classmethod
     def load(cls, baseFile):
         """
         Load Series from file.
-        
+
         Parameters
         ----------
-        baseFile: string    
+        baseFile: string
             Filename base where index/values are stored.
             e.g. baseFile='myfile' --> 'myfile_index.npy', 'myfile_values.npy'
 
@@ -184,14 +184,14 @@ class Series(np.ndarray, Picklable, Groupable):
         values = np.load(valuesFile)
 
         return cls(values, index=index)
-    
+
     def save(self, baseFile):
         """
         Save Series to file.
-        
+
         Parameters
         ----------
-        baseFile: string    
+        baseFile: string
             Filename base where index/values are stored.
             e.g. baseFile='myfile' --> 'myfile_index.npy', 'myfile_values.npy'
         """
@@ -200,10 +200,10 @@ class Series(np.ndarray, Picklable, Groupable):
 
         np.save(indexFile, self.index)
         np.save(valuesFile, self)
-    
+
     def __contains__(self, key):
         return key in self.index
-        
+
     def __reduce__(self):
         """Necessary for making this object picklable"""
         object_state = list(ndarray.__reduce__(self))
@@ -221,14 +221,14 @@ class Series(np.ndarray, Picklable, Groupable):
     def __getitem__(self, key):
         """
         Returns item(s) for requested index/sequence, overrides default behavior
-        for series[key]. 
-        
+        for series[key].
+
         Logic is as follows:
-            - If key is in the index, return the value corresponding 
+            - If key is in the index, return the value corresponding
               to that index
-            - Otherwise, use key (presumably one integer or a sequence 
-              of integers) to obtain values from the series. In the case 
-              of a sequence, a 'slice' of the series (with corresponding dates) 
+            - Otherwise, use key (presumably one integer or a sequence
+              of integers) to obtain values from the series. In the case
+              of a sequence, a 'slice' of the series (with corresponding dates)
               will be returned, otherwise a single value.
         """
         if key is None and key not in self.index:
@@ -236,7 +236,7 @@ class Series(np.ndarray, Picklable, Groupable):
         if not hasattr(key, '__iter__'):
             try:
                 # Check that we can even look for this in the index
-                if key in self.index: 
+                if key in self.index:
                     return self.get(key)
                 if not isinstance(key, int):
                     raise Exception('Requested index not in this series!')
@@ -245,7 +245,7 @@ class Series(np.ndarray, Picklable, Groupable):
                 pass
         dataSlice = self.view(ndarray)[key]
         if self.index is not None:
-            indices = self.index.view(ndarray)[key]    
+            indices = self.index.view(ndarray)[key]
             if isinstance(indices, ndarray):
                 indexSlice = Index(indices)
                 return self.__class__(dataSlice, index=indexSlice)
@@ -259,16 +259,16 @@ class Series(np.ndarray, Picklable, Groupable):
 
     def __getslice__(self, i, j):
         """
-        Returns a slice of the Series. 
-        
+        Returns a slice of the Series.
+
         Note that the underlying values are COPIES.
-        
-        The reason that the getslice returns copies is that otherwise you 
-        will have a reference to the original series which could be 
+
+        The reason that the getslice returns copies is that otherwise you
+        will have a reference to the original series which could be
         inadvertently changed if the slice were altered (made mutable).
         """
         newArr = self.view(ndarray)[i:j].copy()
-    
+
         if self.index is not None:
             newIndex = self.index[i:j]
             return self.__class__(newArr, index = newIndex)
@@ -277,7 +277,7 @@ class Series(np.ndarray, Picklable, Groupable):
 
     def __setitem__(self, key, value):
         """
-        If this series is mutable, set specified indices equal to given values. 
+        If this series is mutable, set specified indices equal to given values.
         """
         if isinstance(key, int):
             ndarray.__setitem__(self, key, value)
@@ -302,48 +302,48 @@ class Series(np.ndarray, Picklable, Groupable):
         if index is not None and len(index) > 0:
             if len(index) > 500:
                 head = _seriesRepr(index[:50], vals[:50])
-                tail = _seriesRepr(index[-50:], vals[-50:])                
+                tail = _seriesRepr(index[-50:], vals[-50:])
                 return head + '\n...\n' + tail + '\nlength: %d' % len(vals)
             else:
                 return _seriesRepr(index, vals)
         else:
             return 'No index!\n' + ndarray.__repr__(self)
-    
+
     def __str__(self):
         return self.__repr__()
-    
+
     def __iter__(self):
         return self.view(ndarray).__iter__()
-    
+
 #-------------------------------------------------------------------------------
 #   Arithmetic operators
-    
+
     def _seriesOpWrap(opname, comp=False):
         """
         Wrapper function for Series arithmetic operations, to avoid
-        code duplication. 
+        code duplication.
         """
         MIRROR_OPS = {
-            '__add__' : '__radd__',    
-            '__sub__' : '__rsub__',    
-            '__div__' : '__rdiv__',    
+            '__add__' : '__radd__',
+            '__sub__' : '__rsub__',
+            '__div__' : '__rdiv__',
             '__mul__' : '__rmul__'
         }
         def wrapper(self, other):
             from pandas.core.frame import DataFrame
-            
+
             func = getattr(self.view(ndarray), opname)
             cls = self.__class__
             if isinstance(other, Series):
                 if self.index is other.index:
-                    return cls(func(other), index=self.index)    
+                    return cls(func(other), index=self.index)
                 if len(self.index) + len(other.index) > 0:
                     newIndex = self.index + other.index
                 else:
                     newIndex = NULL_INDEX
                 try:
-                    arr = tseries.combineFunc(opname, newIndex, self, other, 
-                                              self.index.indexMap, 
+                    arr = tseries.combineFunc(opname, newIndex, self, other,
+                                              self.index.indexMap,
                                               other.index.indexMap)
                 except:
                     arr = Series.combineFunc(self, other,
@@ -362,45 +362,45 @@ class Series(np.ndarray, Picklable, Groupable):
             else:
                 return cls(func(other), index=self.index)
         return wrapper
-    
+
     __add__ = _seriesOpWrap('__add__')
     __sub__ = _seriesOpWrap('__sub__')
     __mul__ = _seriesOpWrap('__mul__')
     __div__ = _seriesOpWrap('__div__')
     __pow__ = _seriesOpWrap('__pow__')
-    
+
     # Inplace operators
     __iadd__ = __add__
     __isub__ = __sub__
     __imul__ = __mul__
     __idiv__ = __div__
     __ipow__ = __pow__
-        
+
     del _seriesOpWrap
-    
+
 #-------------------------------------------------------------------------------
 # Overridden ndarray methods
-    
+
     def sum(self, axis=None, dtype=None, out=None):
-        arr = self.view(ndarray)       
+        arr = self.view(ndarray)
         retVal = arr.sum(axis, dtype, out)
-        
-        if isnull(retVal):    
+
+        if isnull(retVal):
             arr = remove_na(arr)
             retVal = arr.sum(axis, dtype, out)
-        
+
         return retVal
 
     def mean(self, axis=None, dtype=None, out=None):
-        arr = self.view(ndarray)       
+        arr = self.view(ndarray)
         retVal = arr.mean(axis, dtype, out)
-        
-        if isnull(retVal):    
+
+        if isnull(retVal):
             arr = remove_na(arr)
             retVal = arr.mean(axis, dtype, out)
-        
+
         return retVal
-    
+
     def std(self, axis=None, dtype=None, out=None, ddof=1):
         nona = remove_na(self.view(ndarray))
         if len(nona) < 2:
@@ -412,19 +412,45 @@ class Series(np.ndarray, Picklable, Groupable):
         if len(nona) < 2:
             return NaN
         return ndarray.var(nona, axis, dtype, out, ddof)
-        
+
+    def skew(self, bias=False):
+        """Computes the skewness of the Series
+
+        For normally distributed data, the skewness should be about 0.
+        A skewness value > 0 means that there is more weight in the left
+        tail of the distribution. The function skewtest() can be used to
+        determine if the skewness value is close enough to 0, statistically
+        speaking.
+
+        Parameters
+        ----------
+        bias : bool
+        If False, then the calculations are corrected for statistical bias.
+        """
+
+        from scipy.stats import skew
+        nona = remove_na(self.view(ndarray))
+        if len(nona) < 3:
+            return NaN
+        theSkew = skew(nona, bias=bias)
+
+        if isinstance(theSkew, ndarray):
+            theSkew = theSkew.item()
+
+        return theSkew
+
     def keys(self):
         """
         Return Series index
-        
+
         Analogous to dict.keys()
         """
         return self.index
-    
+
     def values(self):
         """
         Return Series values
-        
+
         Analogous to dict.values()
         """
         return self.view(ndarray)
@@ -436,13 +462,13 @@ class Series(np.ndarray, Picklable, Groupable):
         if self.index is not None:
             return izip(self.index.__iter__(), self.__iter__())
         else:
-            raise Exception('This series has no index!')    
-        
+            raise Exception('This series has no index!')
+
     def get(self, key, missingVal=None):
         """
         Returns value occupying requested index, and
         return missingVal if not in Index
-        
+
         Parameters
         ----------
         key: object
@@ -454,7 +480,7 @@ class Series(np.ndarray, Picklable, Groupable):
             return ndarray.__getitem__(self, self.index.indexMap[key])
         else:
             return missingVal
-                        
+
     def append(self, other):
         """
         Concatenate two Series
@@ -463,6 +489,32 @@ class Series(np.ndarray, Picklable, Groupable):
         newValues = np.concatenate((self, other))
         return self.__class__(newValues, index = newIndex)
 
+    def merge(self, other):
+        """
+        If self is {A}->{B} and other is another mapping of {B}->{C}
+        then returns a new Series that is {A}->{C}
+
+        Parameters
+        ----------
+        other: dict or Series
+
+        Returns
+        -------
+        Series having same index as calling instance, with values from
+        input Series
+        """
+        if isinstance(other, dict):
+            other = Series.fromDict(other)
+        if not isinstance(other, Series):
+            raise Exception('Argument must be a Series!')
+        fillVec, mask = tseries.getMergeVec(self, other.index.indexMap)
+
+        newValues = other.view(np.ndarray)[fillVec]
+        newValues[-mask] = np.nan
+
+        newSer = Series(newValues, index=self.index)
+        return newSer
+
     def combineFunc(self, other, func):
         """
         Combines this Series with another Series index by index using
@@ -474,18 +526,18 @@ class Series(np.ndarray, Picklable, Groupable):
             newIndex = self.index + other.index
         newArr = np.empty(len(newIndex), dtype = self.dtype)
         for i, idx in enumerate(newIndex):
-            newArr[i] = func(self.get(idx, nan), other.get(idx, nan))
+            newArr[i] = func(self.get(idx, NaN), other.get(idx, NaN))
         return self.__class__(newArr, index=newIndex)
-    
+
     def argsort(self, axis = 0, kind='quicksort', order=None):
         """
         Overriding numpy's built-in cumsum functionality
         """
         arr = self.view(ndarray).copy()
         okLocs = notnull(arr)
-        arr[okLocs] = np.argsort(arr[okLocs])        
+        arr[okLocs] = np.argsort(arr[okLocs])
         return self.__class__(arr, index=self.index)
-    
+
     def cumsum(self, axis = 0, dtype = None, out = None):
         """
         Overriding numpy's built-in cumsum functionality
@@ -496,7 +548,7 @@ class Series(np.ndarray, Picklable, Groupable):
         arr = arr.astype(result.dtype)
         arr[okLocs] = result
         return arr
-    
+
     def cumprod(self, axis = 0, dtype = None, out = None):
         """
         Overriding numpy's built-in cumprod functionality
@@ -508,34 +560,34 @@ class Series(np.ndarray, Picklable, Groupable):
 
     def copy(self):
         return self.__class__(self.view(ndarray).copy(), index=self.index)
-    
+
     def corr(self, other):
         """
         Correlation of this Series with another Series, NaN excluded
-        
+
         Parameters
         ----------
         other: Series object
-        
+
         Returns
         -------
         float (the correlation coefficient)
         """
-        commonIdx = list(set(remove_na(self).index) & 
+        commonIdx = list(set(remove_na(self).index) &
                          set(remove_na(other).index))
-        
+
         if len(commonIdx) == 0:
             return NaN
-                
+
         this = self.reindex(commonIdx)
         that = other.reindex(commonIdx)
-        
+
         return np.corrcoef(this, that)[0, 1]
 
     def median(self):
         """
-        Return median of Series. 
-        
+        Return median of Series.
+
         Returns
         -------
         The median value
@@ -547,7 +599,7 @@ class Series(np.ndarray, Picklable, Groupable):
         sortedSeries = self.order(missingAtEnd = True)
         self[:] = sortedSeries
         self.index = sortedSeries.index
-    
+
     def order(self, missingAtEnd = True):
         """
         Sorts Series object, by value, maintaining index-value object
@@ -556,9 +608,9 @@ class Series(np.ndarray, Picklable, Groupable):
         ----------
         missingAtEnd: boolean (optional, default=True)
             Put NaN's at beginning or end
-        
+
         In general, AVOID sorting Series unless you absolutely need to.
-        
+
         Returns
         -------
         SORTED series by values (indices correspond to the appropriate values)
@@ -572,25 +624,25 @@ class Series(np.ndarray, Picklable, Groupable):
         idx = np.arange(len(self))
         if missingAtEnd:
             n = sum(good)
-            sortedIdx[:n] = idx[good][arr[good].argsort()]        
+            sortedIdx[:n] = idx[good][arr[good].argsort()]
             sortedIdx[n:] = idx[bad]
         else:
             n = sum(bad)
-            sortedIdx[n:] = idx[good][arr[good].argsort()]        
+            sortedIdx[n:] = idx[good][arr[good].argsort()]
             sortedIdx[:n] = idx[bad]
-            
+
         return Series(arr[sortedIdx], index=self.index[sortedIdx])
 
     def map(self, func):
         """
-        Apply input Python function element-wise to each element of 
+        Apply input Python function element-wise to each element of
         Series.
-        
+
         Parameters
         ----------
         func: function
             Element-wise function to apply
-            
+
         Returns
         -------
         Series with same index
@@ -599,13 +651,13 @@ class Series(np.ndarray, Picklable, Groupable):
 
     def plot(self, label=None, kind='line', **kwds):
         """
-        Plot the input series with the index on the x-axis using 
+        Plot the input series with the index on the x-axis using
         matplotlib / pylab.
 
         Params
         ------
         label: label argument to provide to plot
-        
+
         kind: {'line', 'bar', 'hist'}
             Default: line for TimeSeries, hist for Series
 
@@ -615,7 +667,7 @@ class Series(np.ndarray, Picklable, Groupable):
             TimeSeries: line chart
             Series: histogram
                 Also support for bar charts
-    
+
         Type show() (make sure to do 'from pylab import *') to see graph if you
         do not.
 
@@ -627,19 +679,19 @@ class Series(np.ndarray, Picklable, Groupable):
 
         if label is not None:
             kwds = kwds.copy()
-            kwds['label'] = label 
-        
+            kwds['label'] = label
+
         # I can't get this to work
-        
+
         #fig = pylab.gcf()
         #fig.autofmt_xdate(bottom=0.1)
-        
+
         #ax = fig.gca()
         #if not ax.has_data():
             #ax = fig.add_subplot(111)
-        
+
         #ax.plot(self.index, self, **kwds)
-        
+
         pylab.plot(self.index, self, **kwds)
 
     def remapIndex(self, mapping):
@@ -658,12 +710,12 @@ class Series(np.ndarray, Picklable, Groupable):
             except:
                 pass
             data.setdefault(row, {})[col] = value
-        return DataFrame.fromDict(data)    
+        return DataFrame.fromDict(data)
 
     def toCSV(self, path=None):
         """
         Write the Series to a CSV file
-        
+
         Parameters
         ----------
         path: string or None
@@ -678,16 +730,10 @@ class Series(np.ndarray, Picklable, Groupable):
             f.write(str(idx) + ',' + str(value) + ',\n')
         if path is not None:
             f.close()
-            
-    def toClipboard(self):
-        txt = ''
-        for idx, value in self.iteritems():
-            txt += (str(idx) + '\t' + str(value) + '\n')
-        setText(txt)
 
     def toDict(self):
         return dict(self.iteritems())
-            
+
     def cap(self, value):
         """Return copy of series with values above given value truncated"""
         myCopy = self.copy()
@@ -705,7 +751,7 @@ class Series(np.ndarray, Picklable, Groupable):
 
     def shift(self, periods, offset=None):
         """
-        Shift the underlying series of the DataMatrix and Series objects within 
+        Shift the underlying series of the DataMatrix and Series objects within
         by given number (positive or negative) of business/weekdays.
 
         Parameters
@@ -721,52 +767,52 @@ class Series(np.ndarray, Picklable, Groupable):
         """
         if periods == 0:
             return self
-        
+
         if offset is None:
             if periods > 0:
                 newIndex = self.index[periods:]
                 newValues = np.array(self)[:-periods]
             else:
                 newIndex = self.index[:periods]
-                newValues = np.array(self)[-periods:]                
+                newValues = np.array(self)[-periods:]
             return self.__class__(newValues, index=newIndex)
         else:
             offset = periods * offset
             newIndex = Index([idx + offset for idx in self.index])
             return self.__class__(self, index=newIndex)
 
-    def slice(self, before, after): 
-        import bisect 
-         
-        if before is not None: 
-            binsearch = bisect.bisect_left(self.index, before) 
-            cur = self.index[binsearch] 
-            next = self.index[min(binsearch + 1, len(self.index) - 1)] 
-            leftDate = cur if cur >= before else next 
-        else: 
-            leftDate = self.index[0] 
-         
-        if after is not None: 
-            if after < self.index[-1]: 
-                binsearch = bisect.bisect_right(self.index, after) 
-                cur = self.index[binsearch] 
-                prior = self.index[max(binsearch - 1, 0)]             
-                rightDate = cur if cur <= after else prior 
-            else: 
-                rightDate = self.index[-1]             
-        else: 
-            rightDate = self.index[-1] 
-  
-        beg_slice = max(0, self.index.indexMap[leftDate])             
+    def slice(self, before, after):
+        import bisect
+
+        if before is not None:
+            binsearch = bisect.bisect_left(self.index, before)
+            cur = self.index[binsearch]
+            next = self.index[min(binsearch + 1, len(self.index) - 1)]
+            leftDate = cur if cur >= before else next
+        else:
+            leftDate = self.index[0]
+
+        if after is not None:
+            if after < self.index[-1]:
+                binsearch = bisect.bisect_right(self.index, after)
+                cur = self.index[binsearch]
+                prior = self.index[max(binsearch - 1, 0)]
+                rightDate = cur if cur <= after else prior
+            else:
+                rightDate = self.index[-1]
+        else:
+            rightDate = self.index[-1]
+
+        beg_slice = max(0, self.index.indexMap[leftDate])
         end_slice = min(len(self.index), self.index.indexMap[rightDate] + 1)
-        
+
         return self[beg_slice:end_slice]
 
     def asOf(self, date):
         """
-        Return last good (non-NaN) value in TimeSeries if value is NaN for 
-        requested date. 
-                
+        Return last good (non-NaN) value in TimeSeries if value is NaN for
+        requested date.
+
         If there is no good value, NaN is returned.
         """
         if isinstance(date, basestring):
@@ -778,7 +824,7 @@ class Series(np.ndarray, Picklable, Groupable):
             if any(candidates):
                 asOfDate = max(candidates)
             else:
-                return nan
+                return NaN
             return self.get(asOfDate)
         else:
             return v
@@ -791,14 +837,14 @@ class Series(np.ndarray, Picklable, Groupable):
         ----------
         value: any kind (should be same type as array)
             Value to use to fill holes (e.g. 0)
-        
+
         method: {'backfill', 'pad', None}
             Method to use for filling holes in new inde
-        
+
         Returns
         -------
         TimeSeries with NaN's filled
-            
+
         See also
         --------
         reindex, asfreq
@@ -807,10 +853,10 @@ class Series(np.ndarray, Picklable, Groupable):
             newSeries = self.copy()
             newSeries[isnull(newSeries)] = value
             return newSeries
-        else: # Using reindex to pad / backfill        
+        else: # Using reindex to pad / backfill
             withoutna = remove_na(self)
             return withoutna.reindex(self.index, fillMethod=method)
-        
+
     def asfreq(self, freq, fillMethod=None):
         """
         Convert this TimeSeries to the provided frequency using DateOffset
@@ -821,10 +867,10 @@ class Series(np.ndarray, Picklable, Groupable):
         ----------
         offset: DateOffset object, or string in {'WEEKDAY', 'EOM'}
             DateOffset object or subclass (e.g. monthEnd)
-        
+
         fillMethod: {'backfill', 'pad', 'interpolate', None}
                     Method to use for filling holes in new inde
-        
+
         Returns
         -------
         TimeSeries
@@ -833,12 +879,12 @@ class Series(np.ndarray, Picklable, Groupable):
             raise Exception('Must pass DateOffset!')
 
         dateRange = DateRange(self.index[0], self.index[-1], offset=freq)
-        
+
         return self.reindex(dateRange, fillMethod=fillMethod)
 
     def reindex(self, newIndex, fillMethod=None):
         """Overloaded version of reindex for TimeSeries. Supports filling
-        with values based on new index. 
+        with values based on new index.
 
         See analogous method for DataFrame, will be faster for multiple
         TimeSeries
@@ -849,7 +895,7 @@ class Series(np.ndarray, Picklable, Groupable):
                     duplicating data)
         fillMethod: {'backfill', 'pad', 'interpolate', None}
                     Method to use for filling holes in reindexed Series
-        
+
         Returns
         -------
         TimeSeries
@@ -860,17 +906,17 @@ class Series(np.ndarray, Picklable, Groupable):
             if not isinstance(newIndex, Index):
                 newIndex = Index(newIndex)
 
-            idxMap = self.index.indexMap        
+            idxMap = self.index.indexMap
 
             if self.dtype == float:
-                return self.__class__(tseries.reindex(newIndex, self, idxMap), 
+                return self.__class__(tseries.reindex(newIndex, self, idxMap),
                                       index=newIndex)
             elif self.dtype == int:
                 # This could be unsafe, but NaN will not work in int arrays.
-                reindexed = tseries.reindex(newIndex, self.astype(float), 
+                reindexed = tseries.reindex(newIndex, self.astype(float),
                                             idxMap)
                 return self.__class__(reindexed, index=newIndex)
-            
+
             else:
                 if self.dtype.type == np.object_:
                     result = tseries.reindexObj(newIndex, self, idxMap)
@@ -880,7 +926,7 @@ class Series(np.ndarray, Picklable, Groupable):
                     vals = tseries.reindexObj(newIndex, thisVals, idxMap)
                     vals = vals.astype(self.dtype)
                     return self.__class__(vals, index=newIndex)
-            
+
         if not isinstance(newIndex, Index):
             newIndex = Index(newIndex)
 
@@ -896,35 +942,34 @@ class Series(np.ndarray, Picklable, Groupable):
             raise Exception("Don't recognize fillMethod: %s" % fillMethod)
 
         # Cython for blazing speed
-        fillVec, mask = tseries.getFillVec(self.index, newIndex, oldMap, 
+        fillVec, mask = tseries.getFillVec(self.index, newIndex, oldMap,
                                            newMap, kind=fillMethod)
 
         newValues = self.view(ndarray)[fillVec]
-        newValues[-mask] = nan
+        newValues[-mask] = NaN
 
         return self.__class__(newValues, index = newIndex)
-    
-    def _weekday(self):
-        return self.__class__([d.weekday() for d in self.index], 
+
+    @property
+    def weekday(self):
+        return self.__class__([d.weekday() for d in self.index],
                               index = self.index)
-        
-    weekday = property(_weekday)
-    
+
     def truncate(self, before = None, after = None):
         """Function truncate a TimeSeries before and/or after some
         particular dates.
-        
+
         Parameters
         ----------
         before: date
             Truncate before date
         after: date
             Truncate after date
-        
+
         Note
         ----
         If TimeSeries is contained in a DataFrame, consider using the version
-        of the function there. 
+        of the function there.
 
         Returns
         -------
@@ -932,17 +977,17 @@ class Series(np.ndarray, Picklable, Groupable):
         """
         before = to_datetime(before)
         after = to_datetime(after)
-        
+
         if before is None:
             before = min(self.index)
         if after is None:
             after = max(self.index)
         return self.slice(before, after)
-        
+
     def autocorr(self):
         """
         1st period autocorrelation coefficient
-        
+
         Returns
         -------
         TimeSeries
@@ -951,20 +996,20 @@ class Series(np.ndarray, Picklable, Groupable):
 
     def _firstTimeWithValue(self):
         noNA = remove_na(self)
-        
-        if len(noNA) > 0:        
+
+        if len(noNA) > 0:
             return noNA.index[0]
         else:
             return None
 
     def _lastTimeWithValue(self):
         noNA = remove_na(self)
-        
-        if len(noNA) > 0:        
+
+        if len(noNA) > 0:
             return noNA.index[-1]
         else:
             return None
-        
+
 class TimeSeries(Series):
     pass
 

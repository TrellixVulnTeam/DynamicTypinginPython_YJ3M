commit bd1dbe7e0ee9db364a146eda74b0ddd050dd3903
Author: y-p <yoval@gmx.com>
Date:   Sat Oct 12 03:22:05 2013 +0300

    DOC: cleanups

diff --git a/doc/source/basics.rst b/doc/source/basics.rst
index 0e3b66715..e6bb084fc 100644
--- a/doc/source/basics.rst
+++ b/doc/source/basics.rst
@@ -1361,7 +1361,7 @@ and so passing in a substring will work - as long as it is unambiguous :
    get_option("display.max_rows")
 
 
-The following will **not work** because it matches multiple option names, e.g.``display.max_colwidth``, ``display.max_rows``, ``display.max_columns``:
+The following will **not work** because it matches multiple option names, e.g. ``display.max_colwidth``, ``display.max_rows``, ``display.max_columns``:
 
 .. ipython:: python
    :okexcept:
@@ -1372,12 +1372,18 @@ The following will **not work** because it matches multiple option names, e.g.``
        print(e)
 
 
-**Note:** Using this form of convenient shorthand may make your code break if new options with similar names are added in future versions.
+**Note:** Using this form of shorthand may cause your code to break if new options with similar names are added in future versions.
 
 
 You can get a list of available options and their descriptions with ``describe_option``. When called
 with no argument ``describe_option`` will print out the descriptions for all available options.
 
+.. ipython:: python
+   :suppress:
+
+   reset_option("all")
+
+
 .. ipython:: python
 
    describe_option()
@@ -1407,11 +1413,11 @@ All options also have a default value, and you can use the ``reset_option`` to d
    get_option("display.max_rows")
 
 
-It's also possible to reset multiple options at once:
+It's also possible to reset multiple options at once (using a regex):
 
 .. ipython:: python
 
-   reset_option("^display\.")
+   reset_option("^display")
 
 
 
diff --git a/scripts/use_build_cache.py b/scripts/use_build_cache.py
index f8c2df2a8..361ac59e5 100755
--- a/scripts/use_build_cache.py
+++ b/scripts/use_build_cache.py
@@ -39,7 +39,7 @@ except:
 
     args = Foo() # for 2.6, no argparse
 
-#print(args.accumulate(args.integers))
+#print args.accumulate(args.integers)
 
 shim="""
 import os
diff --git a/vb_suite/test_perf.py b/vb_suite/test_perf.py
index bb3a0d123..ca98b94e4 100755
--- a/vb_suite/test_perf.py
+++ b/vb_suite/test_perf.py
@@ -26,21 +26,6 @@ everything and calculate a ration for the timing information.
 
 """
 
-# IMPORTANT NOTE
-#
-# This script should run on pandas versions at least as far back as 0.9.1.
-# devs should be able to use the latest version of this script with
-# any dusty old commit and expect it to "just work".
-# One way in which this is useful is when collecting historical data,
-# where writing some logic around this script may prove easier
-# in some cases then running vbench directly (think perf bisection).
-#
-# *please*, when you modify this script for whatever reason,
-# make sure you do not break it's functionality when running under older
-# pandas versions.
-# Note that depreaction warnings are turned off in main(), so there's
-# no need to change the actual code to supress such warnings.
-
 import shutil
 import os
 import sys
@@ -52,25 +37,19 @@ import re
 import random
 import numpy as np
 
-import pandas as pd
 from pandas import DataFrame, Series
 
 from suite import REPO_PATH
-VB_DIR = os.path.dirname(os.path.abspath(__file__))
+
 DEFAULT_MIN_DURATION = 0.01
 HEAD_COL="head[ms]"
 BASE_COL="base[ms]"
 
-try:
-    import git # gitpython
-except Exception:
-    print("Error: Please install the `gitpython` package\n")
-    sys.exit(1)
 
 class RevParseAction(argparse.Action):
     def __call__(self, parser, namespace, values, option_string=None):
         import subprocess
-        cmd = 'git rev-parse --short {0}'.format(values)
+        cmd = 'git rev-parse {0}'.format(values)
         rev_parse = subprocess.check_output(cmd, shell=True)
         setattr(namespace, self.dest, rev_parse.strip())
 
@@ -87,14 +66,6 @@ parser.add_argument('-b', '--base-commit',
 parser.add_argument('-t', '--target-commit',
                     help='The commit to compare against the baseline (default: HEAD).',
                     type=str, action=RevParseAction)
-parser.add_argument('--base-pickle',
-                    help='name of pickle file with timings data generated by a former `-H -d FILE` run. '\
-                    'filename must be of the form <hash>-*.* or specify --base-commit seperately',
-                    type=str)
-parser.add_argument('--target-pickle',
-                    help='name of pickle file with timings data generated by a former `-H -d FILE` run '\
-                    'filename must be of the form <hash>-*.* or specify --target-commit seperately',
-                    type=str)
 parser.add_argument('-m', '--min-duration',
                     help='Minimum duration (in ms) of baseline test for inclusion in report (default: %.3f).' % DEFAULT_MIN_DURATION,
                     type=float,
@@ -216,7 +187,7 @@ def profile_comparative(benchmarks):
 
         # ARGH. reparse the repo, without discarding any commits,
         # then overwrite the previous parse results
-        # prprint("Slaughtering kittens...")
+        # prprint ("Slaughtering kittens..." )
         (repo.shas, repo.messages,
          repo.timestamps, repo.authors) = _parse_commit_log(None,REPO_PATH,
                                                                 args.base_commit)
@@ -242,82 +213,30 @@ def profile_comparative(benchmarks):
 
         head_res = get_results_df(db, h_head)
         baseline_res = get_results_df(db, h_baseline)
-
-        report_comparative(head_res,baseline_res)
-
+        ratio = head_res['timing'] / baseline_res['timing']
+        totals = DataFrame({HEAD_COL:head_res['timing'],
+                                BASE_COL:baseline_res['timing'],
+                                'ratio':ratio,
+                                'name':baseline_res.name},
+                                columns=[HEAD_COL, BASE_COL, "ratio", "name"])
+        totals = totals.ix[totals[HEAD_COL] > args.min_duration]
+            # ignore below threshold
+        totals = totals.dropna(
+        ).sort("ratio").set_index('name')  # sort in ascending order
+
+        h_msg =   repo.messages.get(h_head, "")
+        b_msg =   repo.messages.get(h_baseline, "")
+
+        print_report(totals,h_head=h_head,h_msg=h_msg,
+                     h_baseline=h_baseline,b_msg=b_msg)
+
+        if args.outdf:
+            prprint("The results DataFrame was written to '%s'\n" %  args.outdf)
+            totals.save(args.outdf)
     finally:
         #        print("Disposing of TMP_DIR: %s" % TMP_DIR)
         shutil.rmtree(TMP_DIR)
 
-def prep_pickle_for_total(df, agg_name='median'):
-    """
-    accepts a datafram resulting from invocation with -H -d o.pickle
-    If multiple data columns are present (-N was used), the
-    `agg_name` attr of the datafram will be used to reduce
-    them to a single value per vbench, df.median is used by defa
-    ult.
-
-    Returns a datadrame of the form expected by prep_totals
-    """
-    def prep(df):
-        agg = getattr(df,agg_name)
-        df = DataFrame(agg(1))
-        cols = list(df.columns)
-        cols[0]='timing'
-        df.columns=cols
-        df['name'] = list(df.index)
-        return df
-
-    return prep(df)
-
-def prep_totals(head_res, baseline_res):
-    """
-    Each argument should be a dataframe with  'timing' and 'name' columns
-    where name is the name of the vbench.
-
-    returns a 'totals' dataframe, suitable as input for print_report.
-    """
-    head_res, baseline_res = head_res.align(baseline_res)
-    ratio = head_res['timing'] / baseline_res['timing']
-    totals = DataFrame({HEAD_COL:head_res['timing'],
-                        BASE_COL:baseline_res['timing'],
-                        'ratio':ratio,
-                        'name':baseline_res.name},
-                        columns=[HEAD_COL, BASE_COL, "ratio", "name"])
-    totals = totals.ix[totals[HEAD_COL] > args.min_duration]
-    # ignore below threshold
-    totals = totals.dropna(
-    ).sort("ratio").set_index('name')  # sort in ascending order
-    return totals
-
-def report_comparative(head_res,baseline_res):
-    try:
-        r=git.Repo(VB_DIR)
-    except:
-        import pdb
-        pdb.set_trace()
-
-    totals = prep_totals(head_res,baseline_res)
-
-    h_head = args.target_commit
-    h_baseline = args.base_commit
-    h_msg = b_msg = "Unknown"
-    try:
-        h_msg =  r.commit(h_head).message.strip()
-    except git.exc.BadObject:
-        pass
-    try:
-        b_msg =  r.commit(h_baseline).message.strip()
-    except git.exc.BadObject:
-        pass
-
-
-    print_report(totals,h_head=h_head,h_msg=h_msg,
-             h_baseline=h_baseline,b_msg=b_msg)
-
-    if args.outdf:
-        prprint("The results DataFrame was written to '%s'\n" %  args.outdf)
-        totals.save(args.outdf)
 
 def profile_head_single(benchmark):
     import gc
@@ -454,6 +373,11 @@ def print_report(df,h_head=None,h_msg="",h_baseline=None,b_msg=""):
 
 def main():
     from suite import benchmarks
+    # GitRepo wants exactly 7 character hash?
+    if args.base_commit:
+        args.base_commit = args.base_commit[:7]
+    if args.target_commit:
+        args.target_commit = args.target_commit[:7]
 
     if not args.log_file:
         args.log_file = os.path.abspath(
@@ -471,22 +395,38 @@ def main():
     random.seed(args.seed)
     np.random.seed(args.seed)
 
-    if args.base_pickle and args.target_pickle:
-        baseline_res = prep_pickle_for_total(pd.load(args.base_pickle))
-        target_res = prep_pickle_for_total(pd.load(args.target_pickle))
+    affinity_set = False
 
-        report_comparative(target_res, baseline_res)
-        sys.exit(0)
+    # try psutil first since it is more commonly present and better
+    # maintained.  Some people experienced problems with affinity package
+    # (see https://code.google.com/p/psutil/issues/detail?id=238 for more references)
+    try:
+        import psutil
+        if hasattr(psutil.Process, 'set_cpu_affinity'):
+            psutil.Process(os.getpid()).set_cpu_affinity([args.affinity])
+            affinity_set = True
+    except ImportError:
+        pass
 
-    if args.affinity is not None:
-        try: # use psutil rather then stale affinity module. Thanks @yarikoptic
-            import psutil
-            if hasattr(psutil.Process, 'set_cpu_affinity'):
-                psutil.Process(os.getpid()).set_cpu_affinity([args.affinity])
-                print("CPU affinity set to %d" % args.affinity)
+    if not affinity_set:
+        try:
+            import affinity
+            affinity.set_process_affinity_mask(0, args.affinity)
+            assert affinity.get_process_affinity_mask(0) == args.affinity
+            affinity_set = True
         except ImportError:
-            print("-a/--affinity specified, but the 'psutil' module is not available, aborting.\n")
-            sys.exit(1)
+            pass
+
+    if not affinity_set:
+        import warnings
+        warnings.warn("\n\n"
+              "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
+              "The 'affinity' or 'psutil' >= 0.5.0 modules are not available, results may be unreliable\n"
+              "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n"
+            )
+        time.sleep(2)
+    else:
+        print("CPU affinity set to %d" % args.affinity)
 
     print("\n")
     prprint("LOG_FILE = %s" % args.log_file)
@@ -568,39 +508,10 @@ def _parse_wrapper(base_commit):
 
 if __name__ == '__main__':
     args = parser.parse_args()
-    if (not args.head
-        and not (args.base_commit and args.target_commit)
-        and not (args.base_pickle and args.target_pickle)):
+    if not args.head and (not args.base_commit and not args.target_commit):
         parser.print_help()
-        sys.exit(1)
-    elif ((args.base_pickle or args.target_pickle) and not
-        (args.base_pickle and args.target_pickle)):
-        print("Must specify Both --base-pickle and --target-pickle.")
-        sys.exit(1)
-
-    if ((args.base_pickle or args.target_pickle) and not
-        (args.base_commit and args.target_commit)):
-        if not args.base_commit:
-            print("base_commit not specified, Assuming base_pickle is named <commit>-foo.*")
-            args.base_commit = args.base_pickle.split('-')[0]
-        if not args.target_commit:
-            print("target_commit not specified, Assuming target_pickle is named <commit>-foo.*")
-            args.target_commit = args.target_pickle.split('-')[0]
-
-    import warnings
-    warnings.filterwarnings('ignore',category=FutureWarning)
-    warnings.filterwarnings('ignore',category=DeprecationWarning)
-
-    if args.base_commit and args.target_commit:
-        print("Verifying specified commits exist in repo...")
-        r=git.Repo(VB_DIR)
-        for c in [ args.base_commit, args.target_commit ]:
-            try:
-                msg =  r.commit(c).message.strip()
-            except git.BadObject:
-                print("The commit '%s' was not found, aborting..." % c)
-                sys.exit(1)
-            else:
-                print("%s: %s" % (c,msg))
-
-    main()
+    else:
+        import warnings
+        warnings.filterwarnings('ignore',category=FutureWarning)
+        warnings.filterwarnings('ignore',category=DeprecationWarning)
+        main()

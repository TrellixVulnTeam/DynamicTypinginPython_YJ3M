commit 28e70a75fa3278ff0463d7c8b75ee030dccc474e
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue May 18 16:11:14 2010 +0000

    DateRange enhancements. fixed failing fama-macbeth unit test
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@170 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index ea7ac31d1..be8306ef0 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -124,6 +124,13 @@ class DateRange(Index):
         # Allow us to circumvent hitting the cache
         index = kwds.get('index')
         if index is None:
+            if timeRule is not None:
+                offset = datetools.getOffset(timeRule)
+
+            if timeRule is None:
+                if offset in datetools._offsetNames:
+                    timeRule = datetools._offsetNames[offset]
+
             # Cachable
             if not fromDate:
                 fromDate = kwds.get('begin')
@@ -270,18 +277,9 @@ class DateRange(Index):
     __str__ = __repr__
 
     def shift(self, n):
-        if n > 0:
-            start = self[-1] + self.offset
-            tail = DateRange(fromDate=start, periods=n)
-            newArr = np.concatenate((self[n:], tail)).view(DateRange)
-            newArr.offset = self.offset
-            return newArr
-        elif n < 0:
-            end = self[0] - self.offset
-            head = DateRange(toDate=end, periods=-n)
-
-            newArr = np.concatenate((head, self[:n])).view(DateRange)
-            newArr.offset = self.offset
-            return newArr
-        else:
+        if n == 0:
             return self
+
+        start = self[0] + n * self.offset
+        end = self[-1] + n * self.offset
+        return DateRange(start, end, offset=self.offset)
diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index c9341b632..408741534 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -191,13 +191,11 @@ class DateOffset(object):
             someDate = someDate + self.__class__(1, **self.kwds)
         return someDate
 
-    @classmethod
-    def onOffset(cls, someDate):
+    def onOffset(self, someDate):
         # Default (slow) method for determining if some date is a
         # member of the DateRange generated by this offset. Subclasses
         # may have this re-implemented in a nicer way.
-        obj = cls()
-        return someDate == ((someDate + obj) - obj)
+        return someDate == ((someDate + self) - self)
 
 
 class BDay(DateOffset):
@@ -418,24 +416,42 @@ class BYearEnd(DateOffset):
     _outputName = 'BusinessYearEnd'
     _normalizeFirst = True
 
+    def __init__(self, n=1, **kwds):
+        self.month = kwds.get('month', 12)
+
+        if self.month < 1 or self.month > 12:
+            raise Exception('Month must go from 1 to 12')
+
+        DateOffset.__init__(self, n=n, **kwds)
+
     def apply(self, other):
         n = self.n
 
-        wkday, nDaysInMonth = calendar.monthrange(other.year, 12)
+        if self._normalizeFirst:
+            other = normalize_date(other)
+
+        wkday, nDaysInMonth = calendar.monthrange(other.year, self.month)
         lastBDay = nDaysInMonth - max(((wkday + nDaysInMonth - 1) % 7) - 4, 0)
 
-        if n > 0 and not (other.month == 12 and other.day >= lastBDay):
-            n = n - 1
-        elif n <= 0 and other.month == 12 and other.day > lastBDay:
-            n = n + 1
+        years = n
+        if n > 0:
+            if (other.month < self.month or
+                (other.month == self.month and other.day < lastBDay)):
+                years -= 1
+        elif n <= 0:
+            if (other.month > self.month or
+                (other.month == self.month and other.day > lastBDay)):
+                years += 1
 
-        other = other + relativedelta(years=n, month=12, day=31)
+        other = other + relativedelta(years=years)
 
-        if other.weekday() > 4:
-            other = other - BDay()
+        _, days_in_month = calendar.monthrange(other.year, self.month)
+        result = datetime(other.year, self.month, days_in_month)
 
-        return other
+        if result.weekday() > 4:
+            result = result - BDay()
 
+        return result
 
 class YearEnd(DateOffset):
     """DateOffset increments between calendar year ends"""
@@ -561,6 +577,17 @@ _offsetMap = {
     "Q@JAN"    : BQuarterEnd(startingMonth=1),
     "Q@FEB"    : BQuarterEnd(startingMonth=2),
     "Q@MAR"    : BQuarterEnd(startingMonth=3),
+    "A@JAN"    : BYearEnd(month=1),
+    "A@FEB"    : BYearEnd(month=2),
+    "A@MAR"    : BYearEnd(month=3),
+    "A@APR"    : BYearEnd(month=4),
+    "A@MAY"    : BYearEnd(month=5),
+    "A@JUN"    : BYearEnd(month=6),
+    "A@JUL"    : BYearEnd(month=7),
+    "A@AUG"    : BYearEnd(month=8),
+    "A@SEP"    : BYearEnd(month=9),
+    "A@OCT"    : BYearEnd(month=10),
+    "A@NOV"    : BYearEnd(month=11),
     "A@DEC"    : BYearEnd()
 }
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 2f12ecd8a..fd17d5b75 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1024,8 +1024,13 @@ class DataFrame(Picklable, Groupable):
             newValues = dict([(col, do_shift(series))
                               for col, series in self.iteritems()])
         else:
-            offset = periods * offset
-            newIndex = Index([idx + offset for idx in self.index])
+            if (isinstance(self.index, DateRange) and
+                offset == self.index.offset):
+                newIndex = self.index.shift(periods)
+            else:
+                offset = periods * offset
+                newIndex = Index([idx + offset for idx in self.index])
+
             newValues = dict([(col, np.asarray(series))
                                for col, series in self.iteritems()])
 
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index bc8b0cb33..f5a93f956 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -8,6 +8,7 @@ from numpy import NaN
 import numpy as np
 
 from pandas.core.common import _pfixed, _pickle_array, _unpickle_array
+from pandas.core.daterange import DateRange
 from pandas.core.frame import DataFrame, _try_sort, _extract_index
 from pandas.core.index import Index, NULL_INDEX
 from pandas.core.series import Series
@@ -1214,8 +1215,12 @@ class DataMatrix(DataFrame):
                 newValues = self.values.take(indexer, axis=0)
                 newValues[periods:] = NaN
         else:
-            offset = periods * offset
-            newIndex = Index([x + offset for x in self.index])
+            if (isinstance(self.index, DateRange) and
+                offset == self.index.offset):
+                newIndex = self.index.shift(periods)
+            else:
+                tot_offset = periods * offset
+                newIndex = Index([idx + tot_offset for idx in self.index])
             newValues = self.values.copy()
 
         if self.objects is not None:
diff --git a/pandas/core/tests/test_datetools.py b/pandas/core/tests/test_datetools.py
index 834e172b5..ec5f54869 100644
--- a/pandas/core/tests/test_datetools.py
+++ b/pandas/core/tests/test_datetools.py
@@ -556,6 +556,42 @@ class TestYearBegin(unittest.TestCase):
         for offset, date, expected in tests:
             assertOnOffset(offset, date, expected)
 
+class TestBYearEndLagged(unittest.TestCase):
+
+    def test_offset(self):
+        tests = []
+
+        tests.append((BYearEnd(month=6),
+                      {datetime(2008, 1, 1): datetime(2008, 6, 30),
+                      datetime(2007, 6, 30): datetime(2008, 6, 30)},
+                      ))
+
+        tests.append((BYearEnd(n=-1, month=6),
+                      {datetime(2008, 1, 1): datetime(2007, 6, 29),
+                      datetime(2007, 6, 30): datetime(2007, 6, 29)},
+                      ))
+
+        for dateOffset, cases in tests:
+            for baseDate, expected in cases.iteritems():
+                self.assertEqual(baseDate + dateOffset, expected)
+
+    def test_roll(self):
+        offset = BYearEnd(month=6)
+        date = datetime(2009, 11, 30)
+
+        self.assertEqual(offset.rollforward(date), datetime(2010, 6, 30))
+        self.assertEqual(offset.rollback(date), datetime(2009, 6, 30))
+
+    def test_onOffset(self):
+
+        tests = [
+            (BYearEnd(month=2), datetime(2007, 2, 28), True),
+            (BYearEnd(month=6), datetime(2007, 6, 30), False),
+        ]
+
+        for offset, date, expected in tests:
+            assertOnOffset(offset, date, expected)
+
 class TestBYearEnd(unittest.TestCase):
 
     def test_offset(self):
@@ -603,7 +639,6 @@ class TestBYearEnd(unittest.TestCase):
         for offset, date, expected in tests:
             assertOnOffset(offset, date, expected)
 
-
 class TestYearEnd(unittest.TestCase):
 
     def test_offset(self):
diff --git a/pandas/stats/fama_macbeth.py b/pandas/stats/fama_macbeth.py
index d78c8dfd9..35a5f10e9 100644
--- a/pandas/stats/fama_macbeth.py
+++ b/pandas/stats/fama_macbeth.py
@@ -3,8 +3,9 @@ from cStringIO import StringIO
 import numpy as np
 
 from pandas.core.api import Series, DataMatrix
-from pandas.stats.common import banner, FULL_SAMPLE, ROLLING, EXPANDING
+import pandas.stats.common as common
 from pandas.util.decorators import cache_readonly
+import pandas.lib.tseries as tseries
 
 def fama_macbeth(**kwargs):
     """Runs Fama-MacBeth regression.
@@ -33,7 +34,7 @@ class FamaMacBeth(object):
 
         from pandas.stats.plm import MovingPanelOLS
         self._ols_result = MovingPanelOLS(
-            y=y, x=x, weights=weights, window_type=ROLLING, window=1,
+            y=y, x=x, weights=weights, window_type='rolling', window=1,
             intercept=intercept,
             nw_lags=nw_lags, entity_effects=entity_effects,
             time_effects=time_effects, x_effects=x_effects, cluster=cluster,
@@ -78,7 +79,8 @@ class FamaMacBeth(object):
 
     @cache_readonly
     def _result_index(self):
-        return self._index[-len(self._stats[0]):]
+        mask = self._ols_result._rolling_ols_call[1]
+        return self._index[mask]
 
     @cache_readonly
     def _results(self):
@@ -97,7 +99,7 @@ class FamaMacBeth(object):
 
         for i, name in enumerate(self._cols):
             if i and not (i % 5):
-                buffer.write('\n' + banner(''))
+                buffer.write('\n' + common.banner(''))
 
             mean_beta = self._results['mean_beta'][i]
             std_beta = self._results['std_beta'][i]
@@ -140,53 +142,62 @@ Formula: Y ~ %(formulaRHS)s
         return template % params
 
 class MovingFamaMacBeth(FamaMacBeth):
-    def __init__(self, y, x, weights=None, window_type=ROLLING, window=10,
+    def __init__(self, y, x, weights=None, window_type='rolling', window=10,
                  intercept=True, nw_lags=None, nw_lags_beta=None,
                  entity_effects=False, time_effects=False, x_effects=None,
                  cluster=None, dropped_dummies={}, verbose=False):
-        self._window_type = window_type
+        self._window_type = common._get_window_type(window_type)
         self._window = window
 
         FamaMacBeth.__init__(
-            self, y=y, x=x, weights=weights, intercept=intercept, nw_lags=nw_lags,
-            nw_lags_beta=nw_lags_beta, entity_effects=entity_effects,
-            time_effects=time_effects, x_effects=x_effects, cluster=cluster,
+            self, y=y, x=x, weights=weights, intercept=intercept,
+            nw_lags=nw_lags, nw_lags_beta=nw_lags_beta,
+            entity_effects=entity_effects, time_effects=time_effects,
+            x_effects=x_effects, cluster=cluster,
             dropped_dummies=dropped_dummies, verbose=verbose)
 
         self._index = self._ols_result._y.major_axis
         self._T = len(self._index)
 
-    @cache_readonly
-    def _stats(self):
+    @property
+    def _is_rolling(self):
+        return self._window_type == common.ROLLING
+
+    def _calc_stats(self):
         mean_betas = []
         std_betas = []
         t_stats = []
 
-        start = self._window - 1
+        # XXX
 
+        mask = self._ols_result._rolling_ols_call[2]
+        obs_total = mask.astype(int).cumsum()
+
+        start = self._window - 1
+        betas = self._beta_raw
         for i in xrange(start, self._T):
-            if self._window_type == ROLLING:
+            if self._is_rolling:
                 begin = i - start
             else:
                 begin = 0
 
-            beta = self._beta_raw[begin : i + 1]
-            result = _calc_t_stat(beta, self._nw_lags_beta)
-
-            mean_beta, std_beta, t_stat = result
-
+            B = betas[max(obs_total[begin] - 1, 0) : obs_total[i]]
+            mean_beta, std_beta, t_stat = _calc_t_stat(B, self._nw_lags_beta)
             mean_betas.append(mean_beta)
             std_betas.append(std_beta)
             t_stats.append(t_stat)
 
         return np.array([mean_betas, std_betas, t_stats])
 
+    _stats = cache_readonly(_calc_stats)
+
     def _make_result(self, result):
         return DataMatrix(result, index=self._result_index, columns=self._cols)
 
     @cache_readonly
     def _result_index(self):
-        return self._index[-len(self._stats[0]):]
+        mask = self._ols_result._rolling_ols_call[1]
+        return self._index[mask]
 
     @cache_readonly
     def _results(self):
diff --git a/pandas/stats/ols.py b/pandas/stats/ols.py
index 8c294c654..46ff9dbce 100644
--- a/pandas/stats/ols.py
+++ b/pandas/stats/ols.py
@@ -660,7 +660,7 @@ class MovingOLS(OLS):
     @cache_readonly
     def _beta_raw(self):
         """Runs the regression and returns the beta."""
-        beta, indices = self._rolling_ols_call
+        beta, indices, mask = self._rolling_ols_call
 
         return beta[indices]
 
@@ -703,9 +703,10 @@ class MovingOLS(OLS):
 
             betas[i] = math.solve(xx, xy)
 
-        have_betas = np.arange(N)[-np.isnan(betas).any(axis=1)]
+        mask = -np.isnan(betas).any(axis=1)
+        have_betas = np.arange(N)[mask]
 
-        return betas, have_betas
+        return betas, have_betas, mask
 
     def _rolling_rank(self):
         dates = self._index

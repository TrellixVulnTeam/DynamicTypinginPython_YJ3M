commit c840591754e8db4889f0b19d609c0cc76a091064
Author: jreback <jeff@reback.net>
Date:   Tue Jun 11 09:37:55 2013 -0400

    BUG: add na_fvalues to parsers to enable matching of float values w/o relying on string matching
    
         for an exact match

diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index cc8d7f64a..e4fb478a2 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -297,6 +297,7 @@ def _make_parser_function(name, sep=','):
                  skipfooter=None,
                  skip_footer=0,
                  na_values=None,
+                 na_fvalues=None,
                  true_values=None,
                  false_values=None,
                  delimiter=None,
@@ -359,6 +360,7 @@ def _make_parser_function(name, sep=','):
                     prefix=prefix,
                     skiprows=skiprows,
                     na_values=na_values,
+                    na_fvalues=na_fvalues,
                     true_values=true_values,
                     false_values=false_values,
                     keep_default_na=keep_default_na,
@@ -554,7 +556,7 @@ class TextFileReader(object):
             converters = {}
 
         # Converting values to NA
-        na_values = _clean_na_values(na_values, keep_default_na)
+        na_values, na_fvalues = _clean_na_values(na_values, keep_default_na)
 
         if com.is_integer(skiprows):
             skiprows = range(skiprows)
@@ -565,6 +567,7 @@ class TextFileReader(object):
         result['names'] = names
         result['converters'] = converters
         result['na_values'] = na_values
+        result['na_fvalues'] = na_fvalues
         result['skiprows'] = skiprows
 
         return result, engine
@@ -644,6 +647,7 @@ class ParserBase(object):
         self.keep_date_col = kwds.pop('keep_date_col', False)
 
         self.na_values = kwds.get('na_values')
+        self.na_fvalues = kwds.get('na_fvalues')
         self.true_values = kwds.get('true_values')
         self.false_values = kwds.get('false_values')
         self.tupleize_cols = kwds.get('tupleize_cols',True)
@@ -837,31 +841,34 @@ class ParserBase(object):
                 arr = self._date_conv(arr)
 
             col_na_values = self.na_values
+            col_na_fvalues = self.na_fvalues
 
             if isinstance(self.na_values, dict):
                 col_name = self.index_names[i]
                 if col_name is not None:
-                    col_na_values = _get_na_values(col_name,
-                                                   self.na_values)
-
-            arr, _ = self._convert_types(arr, col_na_values)
+                    col_na_values, col_na_fvalues = _get_na_values(col_name,
+                                                                   self.na_values,
+                                                                   self.na_fvalues)
+                    
+            arr, _ = self._convert_types(arr, col_na_values | col_na_fvalues)
             arrays.append(arr)
 
         index = MultiIndex.from_arrays(arrays, names=self.index_names)
 
         return index
 
-    def _convert_to_ndarrays(self, dct, na_values, verbose=False,
+    def _convert_to_ndarrays(self, dct, na_values, na_fvalues, verbose=False,
                              converters=None):
         result = {}
         for c, values in dct.iteritems():
             conv_f = None if converters is None else converters.get(c, None)
-            col_na_values = _get_na_values(c, na_values)
+            col_na_values, col_na_fvalues = _get_na_values(c, na_values, na_fvalues)
             coerce_type = True
             if conv_f is not None:
                 values = lib.map_infer(values, conv_f)
                 coerce_type = False
-            cvals, na_count = self._convert_types(values, col_na_values,
+            cvals, na_count = self._convert_types(values,
+                                                  set(col_na_values) | col_na_fvalues,
                                                   coerce_type)
             result[c] = cvals
             if verbose and na_count:
@@ -1370,7 +1377,7 @@ class PythonParser(ParserBase):
                 col = self.orig_names[col]
             clean_conv[col] = f
 
-        return self._convert_to_ndarrays(data, self.na_values, self.verbose,
+        return self._convert_to_ndarrays(data, self.na_values, self.na_fvalues, self.verbose,
                                          clean_conv)
 
     def _infer_columns(self):
@@ -1754,43 +1761,26 @@ def _try_convert_dates(parser, colspec, data_dict, columns):
 
 
 def _clean_na_values(na_values, keep_default_na=True):
+
     if na_values is None and keep_default_na:
         na_values = _NA_VALUES
+        na_fvalues = set()
     elif isinstance(na_values, dict):
         if keep_default_na:
             for k, v in na_values.iteritems():
                 v = set(list(v)) | _NA_VALUES
                 na_values[k] = v
+        na_fvalues = dict([ (k, _floatify_na_values(v)) for k, v in na_values.items() ])
     else:
         if not com.is_list_like(na_values):
             na_values = [na_values]
-        na_values = set(_stringify_na_values(na_values))
+        na_values = _stringify_na_values(na_values)
         if keep_default_na:
             na_values = na_values | _NA_VALUES
 
-    return na_values
+        na_fvalues = _floatify_na_values(na_values)
 
-def _stringify_na_values(na_values):
-    """ return a stringified and numeric for these values """
-    result = []
-    for x in na_values:
-        result.append(str(x))
-        result.append(x)
-        try:
-            v = float(x)
-
-            # we are like 999 here
-            if v == int(v):
-                v = int(v)
-                result.append("%s.0" % v)
-                result.append(str(v))
-        except:
-            pass
-        try:
-            result.append(int(x))
-        except:
-            pass
-    return result
+    return na_values, na_fvalues
 
 def _clean_index_names(columns, index_col):
     if not _is_index_col(index_col):
@@ -1838,14 +1828,52 @@ def _get_empty_meta(columns, index_col, index_names):
     return index, columns, {}
 
 
-def _get_na_values(col, na_values):
+def _floatify_na_values(na_values):
+    # create float versions of the na_values
+    result = set()
+    for v in na_values:
+        try:
+            v = float(v)
+            if not np.isnan(v):
+                result.add(v)
+        except:
+            pass
+    return result
+
+def _stringify_na_values(na_values):
+    """ return a stringified and numeric for these values """
+    result = []
+    for x in na_values:
+        result.append(str(x))
+        result.append(x)
+        try:
+            v = float(x)
+
+            # we are like 999 here
+            if v == int(v):
+                v = int(v)
+                result.append("%s.0" % v)
+                result.append(str(v))
+
+            result.append(v)
+        except:
+            pass
+        try:
+            result.append(int(x))
+        except:
+            pass
+    return set(result)
+
+def _get_na_values(col, na_values, na_fvalues):
     if isinstance(na_values, dict):
         if col in na_values:
-            return set(_stringify_na_values(list(na_values[col])))
+            values = na_values[col]
+            fvalues = na_fvalues[col]
+            return na_values[col], na_fvalues[col]
         else:
-            return _NA_VALUES
+            return _NA_VALUES, set()
     else:
-        return na_values
+        return na_values, na_fvalues
 
 
 def _get_col_names(colspec, columns):
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index 0efb4c09e..cc2dddd82 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -549,6 +549,27 @@ Klosterdruckerei\tKlosterdruckerei <Kempten> (1609-1805)\tHochfurstliche Buchhan
             tm.assert_frame_equal(result6,result3)
             tm.assert_frame_equal(result7,result3)
 
+            good_compare = result3
+
+            # with an odd float format, so we can't match the string 999.0 exactly,
+            # but need float matching
+            df.to_csv(path, sep=' ', index=False, float_format = '%.3f')
+            result1 = read_csv(path, sep= ' ', header=0, na_values=['-999.0','-999'])
+            result2 = read_csv(path, sep= ' ', header=0, na_values=[-999,-999.0])
+            result3 = read_csv(path, sep= ' ', header=0, na_values=[-999.0,-999])
+            tm.assert_frame_equal(result1,good_compare)
+            tm.assert_frame_equal(result2,good_compare)
+            tm.assert_frame_equal(result3,good_compare)
+
+            result4 = read_csv(path, sep= ' ', header=0, na_values=['-999.0'])
+            result5 = read_csv(path, sep= ' ', header=0, na_values=['-999'])
+            result6 = read_csv(path, sep= ' ', header=0, na_values=[-999.0])
+            result7 = read_csv(path, sep= ' ', header=0, na_values=[-999])
+            tm.assert_frame_equal(result4,good_compare)
+            tm.assert_frame_equal(result5,good_compare)
+            tm.assert_frame_equal(result6,good_compare)
+            tm.assert_frame_equal(result7,good_compare)
+
     def test_custom_na_values(self):
         data = """A,B,C
 ignore,this,row
diff --git a/pandas/parser.pyx b/pandas/parser.pyx
index 004c23d09..eaa588ef4 100644
--- a/pandas/parser.pyx
+++ b/pandas/parser.pyx
@@ -231,7 +231,7 @@ cdef class TextReader:
 
     cdef:
         parser_t *parser
-        object file_handle
+        object file_handle, na_fvalues
         bint factorize, na_filter, verbose, has_usecols, has_mi_columns
         int parser_start
         list clocks
@@ -294,6 +294,7 @@ cdef class TextReader:
 
                   na_filter=True,
                   na_values=None,
+                  na_fvalues=None,
                   true_values=None,
                   false_values=None,
 
@@ -391,6 +392,9 @@ cdef class TextReader:
         self.delim_whitespace = delim_whitespace
 
         self.na_values = na_values
+        if na_fvalues is None:
+           na_fvalues = set()
+        self.na_fvalues = na_fvalues
 
         self.true_values = _maybe_encode(true_values)
         self.false_values = _maybe_encode(false_values)
@@ -834,7 +838,7 @@ cdef class TextReader:
             Py_ssize_t i, nused, ncols
             kh_str_t *na_hashset = NULL
             int start, end
-            object name
+            object name, na_flist
             bint na_filter = 0
 
         start = self.parser_start
@@ -863,8 +867,9 @@ cdef class TextReader:
             conv = self._get_converter(i, name)
 
             # XXX
+            na_flist = set()
             if self.na_filter:
-                na_list = self._get_na_list(i, name)
+                na_list, na_flist = self._get_na_list(i, name)
                 if na_list is None:
                     na_filter = 0
                 else:
@@ -880,7 +885,7 @@ cdef class TextReader:
 
             # Should return as the desired dtype (inferred or specified)
             col_res, na_count = self._convert_tokens(i, start, end, name,
-                                                     na_filter, na_hashset)
+                                                     na_filter, na_hashset, na_flist)
 
             if na_filter:
                 self._free_na_set(na_hashset)
@@ -906,7 +911,8 @@ cdef class TextReader:
 
     cdef inline _convert_tokens(self, Py_ssize_t i, int start, int end,
                                 object name, bint na_filter,
-                                kh_str_t *na_hashset):
+                                kh_str_t *na_hashset,
+                                object na_flist):
         cdef:
             object col_dtype = None
 
@@ -930,7 +936,7 @@ cdef class TextReader:
                         col_dtype = np.dtype(col_dtype).str
 
                 return self._convert_with_dtype(col_dtype, i, start, end,
-                                                na_filter, 1, na_hashset)
+                                                na_filter, 1, na_hashset, na_flist)
 
         if i in self.noconvert:
             return self._string_convert(i, start, end, na_filter, na_hashset)
@@ -939,10 +945,10 @@ cdef class TextReader:
             for dt in dtype_cast_order:
                 try:
                     col_res, na_count = self._convert_with_dtype(
-                        dt, i, start, end, na_filter, 0, na_hashset)
+                        dt, i, start, end, na_filter, 0, na_hashset, na_flist)
                 except OverflowError:
                     col_res, na_count = self._convert_with_dtype(
-                        '|O8', i, start, end, na_filter, 0, na_hashset)
+                        '|O8', i, start, end, na_filter, 0, na_hashset, na_flist)
 
                 if col_res is not None:
                     break
@@ -953,7 +959,8 @@ cdef class TextReader:
                              int start, int end,
                              bint na_filter,
                              bint user_dtype,
-                             kh_str_t *na_hashset):
+                             kh_str_t *na_hashset,
+                             object na_flist):
         cdef kh_str_t *true_set, *false_set
 
         if dtype[1] == 'i' or dtype[1] == 'u':
@@ -969,7 +976,7 @@ cdef class TextReader:
 
         elif dtype[1] == 'f':
             result, na_count = _try_double(self.parser, i, start, end,
-                                           na_filter, na_hashset)
+                                           na_filter, na_hashset, na_flist)
 
             if dtype[1:] != 'f8':
                 result = result.astype(dtype)
@@ -1060,7 +1067,7 @@ cdef class TextReader:
 
     cdef _get_na_list(self, i, name):
         if self.na_values is None:
-            return None
+            return None, set()
 
         if isinstance(self.na_values, dict):
             values = None
@@ -1068,18 +1075,23 @@ cdef class TextReader:
                 values = self.na_values[name]
                 if values is not None and not isinstance(values, list):
                     values = list(values)
+                fvalues = self.na_fvalues[name]
+                if fvalues is not None and not isinstance(fvalues, set):
+                    fvalues = set(fvalues)
             else:
                 if i in self.na_values:
-                    return self.na_values[i]
+                    return self.na_values[i], self.na_fvalues[i]
                 else:
-                    return _NA_VALUES
+                    return _NA_VALUES, set()
 
-            return _ensure_encoded(values)
+            return _ensure_encoded(values), fvalues
         else:
             if not isinstance(self.na_values, list):
                 self.na_values = list(self.na_values)
+            if not isinstance(self.na_fvalues, set):
+                self.na_fvalues = set(self.na_fvalues)
 
-            return _ensure_encoded(self.na_values)
+            return _ensure_encoded(self.na_values), self.na_fvalues
 
     cdef _free_na_set(self, kh_str_t *table):
         kh_destroy_str(table)
@@ -1163,8 +1175,6 @@ def _maybe_upcast(arr):
 # ----------------------------------------------------------------------
 # Type conversions / inference support code
 
-
-
 cdef _string_box_factorize(parser_t *parser, int col,
                            int line_start, int line_end,
                            bint na_filter, kh_str_t *na_hashset):
@@ -1357,7 +1367,7 @@ cdef char* cinf = b'inf'
 cdef char* cneginf = b'-inf'
 
 cdef _try_double(parser_t *parser, int col, int line_start, int line_end,
-                 bint na_filter, kh_str_t *na_hashset):
+                 bint na_filter, kh_str_t *na_hashset, object na_flist):
     cdef:
         int error, na_count = 0
         size_t i, lines
@@ -1367,6 +1377,7 @@ cdef _try_double(parser_t *parser, int col, int line_start, int line_end,
         double NA = na_values[np.float64]
         ndarray result
         khiter_t k
+        bint use_na_flist = len(na_flist) > 0
 
     lines = line_end - line_start
     result = np.empty(lines, dtype=np.float64)
@@ -1391,6 +1402,10 @@ cdef _try_double(parser_t *parser, int col, int line_start, int line_end,
                         data[0] = NEGINF
                     else:
                         return None, None
+                if use_na_flist:
+                    if data[0] in na_flist:
+                        na_count += 1
+                        data[0] = NA
             data += 1
     else:
         for i in range(lines):

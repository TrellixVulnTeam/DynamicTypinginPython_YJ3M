commit 6bc2dca9299b9a020a8f288ae41e01599c5f9e0d
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon Feb 10 02:39:24 2020 -0800

    CLN: assorted indexing-related cleanups (#31797)

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index b73bc5630..b733970dc 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2933,12 +2933,12 @@ class DataFrame(NDFrame):
             # set column
             self._set_item(key, value)
 
-    def _setitem_slice(self, key, value):
+    def _setitem_slice(self, key: slice, value):
         # NB: we can't just use self.loc[key] = value because that
         #  operates on labels and we need to operate positional for
         #  backwards-compat, xref GH#31469
         self._check_setitem_copy()
-        self.loc._setitem_with_indexer(key, value)
+        self.iloc._setitem_with_indexer(key, value)
 
     def _setitem_array(self, key, value):
         # also raises Exception if object array with NA values
@@ -2950,7 +2950,7 @@ class DataFrame(NDFrame):
             key = check_bool_indexer(self.index, key)
             indexer = key.nonzero()[0]
             self._check_setitem_copy()
-            self.loc._setitem_with_indexer(indexer, value)
+            self.iloc._setitem_with_indexer(indexer, value)
         else:
             if isinstance(value, DataFrame):
                 if len(value.columns) != len(key):
@@ -2962,7 +2962,7 @@ class DataFrame(NDFrame):
                     key, axis=1, raise_missing=False
                 )[1]
                 self._check_setitem_copy()
-                self.loc._setitem_with_indexer((slice(None), indexer), value)
+                self.iloc._setitem_with_indexer((slice(None), indexer), value)
 
     def _setitem_frame(self, key, value):
         # support boolean setting with DataFrame input, e.g.
diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index ff026583c..719bf13cb 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -3193,17 +3193,16 @@ class Index(IndexOpsMixin, PandasObject):
         # convert the slice to an indexer here
 
         # if we are mixed and have integers
-        try:
-            if is_positional and self.is_mixed():
+        if is_positional and self.is_mixed():
+            try:
                 # Validate start & stop
                 if start is not None:
                     self.get_loc(start)
                 if stop is not None:
                     self.get_loc(stop)
                 is_positional = False
-        except KeyError:
-            if self.inferred_type in ["mixed-integer-float", "integer-na"]:
-                raise
+            except KeyError:
+                pass
 
         if is_null_slicer:
             indexer = key
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index d7539210d..b2e5d0424 100755
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -26,8 +26,7 @@ from pandas.core.indexers import (
     is_list_like_indexer,
     length_of_indexer,
 )
-from pandas.core.indexes.api import Index
-from pandas.core.indexes.base import InvalidIndexError
+from pandas.core.indexes.api import Index, InvalidIndexError
 
 # "null slice"
 _NS = slice(None, None)
@@ -592,6 +591,9 @@ class _LocationIndexer(_NDFrameIndexerBase):
         return self.obj._xs(label, axis=axis)
 
     def _get_setitem_indexer(self, key):
+        """
+        Convert a potentially-label-based key into a positional indexer.
+        """
         if self.axis is not None:
             return self._convert_tuple(key, is_setter=True)
 
@@ -756,7 +758,7 @@ class _LocationIndexer(_NDFrameIndexerBase):
                                     "defined index and a scalar"
                                 )
                             self.obj[key] = value
-                            return self.obj
+                            return
 
                         # add a new item with the dtype setup
                         self.obj[key] = _infer_fill_value(value)
@@ -766,7 +768,7 @@ class _LocationIndexer(_NDFrameIndexerBase):
                         )
                         self._setitem_with_indexer(new_indexer, value)
 
-                        return self.obj
+                        return
 
                     # reindex the axis
                     # make sure to clear the cache because we are
@@ -789,7 +791,8 @@ class _LocationIndexer(_NDFrameIndexerBase):
             indexer, missing = convert_missing_indexer(indexer)
 
             if missing:
-                return self._setitem_with_indexer_missing(indexer, value)
+                self._setitem_with_indexer_missing(indexer, value)
+                return
 
         # set
         item_labels = self.obj._get_axis(info_axis)
@@ -1012,7 +1015,6 @@ class _LocationIndexer(_NDFrameIndexerBase):
                 new_values, index=new_index, name=self.obj.name
             )._data
             self.obj._maybe_update_cacher(clear=True)
-            return self.obj
 
         elif self.ndim == 2:
 
@@ -1036,7 +1038,6 @@ class _LocationIndexer(_NDFrameIndexerBase):
 
             self.obj._data = self.obj.append(value)._data
             self.obj._maybe_update_cacher(clear=True)
-            return self.obj
 
     def _align_series(self, indexer, ser: ABCSeries, multiindex_indexer: bool = False):
         """
diff --git a/pandas/core/series.py b/pandas/core/series.py
index fbf16d7a3..34ebbaf79 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -865,7 +865,9 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
 
                 return result
             except InvalidIndexError:
-                pass
+                if not isinstance(self.index, MultiIndex):
+                    raise
+
             except (KeyError, ValueError):
                 if isinstance(key, tuple) and isinstance(self.index, MultiIndex):
                     # kludge

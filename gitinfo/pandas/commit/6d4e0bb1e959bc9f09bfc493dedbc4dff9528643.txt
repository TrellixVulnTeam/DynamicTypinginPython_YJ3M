commit 6d4e0bb1e959bc9f09bfc493dedbc4dff9528643
Author: y-p <yoval@gmx.com>
Date:   Sat Mar 16 03:28:46 2013 +0200

    PERF: cythonize improved python version

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 896880995..1c69efe48 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1315,7 +1315,7 @@ class DataFrame(NDFrame):
                         values[imask] = np.array([ float_format % val for val in v[imask] ])
 
             series[k] = values
- 
+
         has_aliases = isinstance(header, (tuple, list, np.ndarray))
         if has_aliases or header:
             if index:
@@ -1362,7 +1362,10 @@ class DataFrame(NDFrame):
             data_index = self.index.to_timestamp()
 
         nlevels = getattr(data_index, 'nlevels', 1)
-        lib.write_csv_rows(series, list(data_index), index, nlevels, list(cols), writer)
+        if not index:
+            nlevels = 0
+
+        lib.write_csv_rows(series, list(data_index), nlevels, list(cols), writer)
 
     def to_csv(self, path_or_buf, sep=",", na_rep='', float_format=None,
                cols=None, header=True, index=True, index_label=None,
diff --git a/pandas/lib.pyx b/pandas/lib.pyx
index 4bb6e2df8..3ecf08df2 100644
--- a/pandas/lib.pyx
+++ b/pandas/lib.pyx
@@ -786,56 +786,56 @@ def array_replace_from_nan_rep(ndarray[object, ndim=1] arr, object nan_rep, obje
 
 @cython.boundscheck(False)
 @cython.wraparound(False)
-def write_csv_rows(dict series, list data_index, object index, int nlevels, list cols, object writer):
-    
-    cdef int N, j, i, l, ncols, ndata_index
-    cdef list rows, spaces
-    cdef object v, val
-    cdef ndarray row_fields
+def write_csv_rows(dict series, list data_index, int nlevels, list cols, object writer):
 
-    ncols = len(cols)
+    cdef int N, j, i
+    cdef list rows, all_cols
+    cdef object val
 
     # In crude testing, N>100 yields little marginal improvement
     N=100
-    rows = [None]*N
-
-    ndata_index = len(data_index)
 
-    if index:
-       row_fields = np.empty(ncols+nlevels,dtype=object)
+    # pre-allocate  rows
+    rows = [[None]*(nlevels+len(cols)) for x in range(N)]
+
+    all_cols = []
+    if len(cols) < 10000: # 10000 as in "usually"
+        all_cols = list(enumerate(cols))
+
+    j = -1
+    if nlevels == 1:
+        for j, idx in enumerate(data_index):
+            row = rows[j % N]
+            row[0] = idx
+            for i, col in (all_cols or enumerate(cols)):
+                val = series[col][j]
+                row[nlevels+i] = np.asscalar(val) if isinstance(val,np.number) else val
+
+            if j >= N-1 and j % N == N-1:
+                writer.writerows(rows)
+    elif nlevels > 1:
+        for j, idx in enumerate(data_index):
+            row = rows[j % N]
+            row[:nlevels] = list(idx)
+            for i, col in (all_cols or enumerate(cols)):
+                val = series[col][j]
+                row[nlevels+i] = np.asscalar(val) if isinstance(val,np.number) else val
+
+            if j >= N-1 and j % N == N-1:
+                writer.writerows(rows)
     else:
-       nlevels    = 0
-       row_fields = np.empty(ncols,dtype=object)
-
-    for j in range(ndata_index):
-
-       if index:
-           if nlevels == 1:
-              v = data_index[j]
-              if isinstance(v,np.number):
-                  v = np.asscalar(v)
-              row_fields[0] = v
-           else:
-              val = data_index[j]
-              for l in range(nlevels):
-                  v = val[l]
-                  if isinstance(v,np.number):
-                      v = np.asscalar(v)
-                  row_fields[l] = v
-
-       for i in range(ncols):
-           v = series[cols[i]][j]
-           if isinstance(v,np.number):
-              v = np.asscalar(v)
-           row_fields[i+nlevels] = v
-
-       rows[ j % N ] = row_fields.copy()
-
-       if j >= N-1 and j % N == N-1:
-            writer.writerows(rows)
-
-    if ndata_index and (j < N-1 or (j % N) != N-1 ):
-            writer.writerows(rows[:((j+1) % N)])
+        for j, idx in enumerate(data_index):
+            row = rows[j % N]
+            for i, col in (all_cols or enumerate(cols)):
+                val = series[col][j]
+                row[nlevels+i] = np.asscalar(val) if isinstance(val,np.number) else val
+
+            if j >= N-1 and j % N == N-1:
+                writer.writerows(rows)
+
+    if  j >= 0 and (j < N-1 or (j % N) != N-1 ):
+        writer.writerows(rows[:((j+1) % N)])
+
 
 @cython.boundscheck(False)
 @cython.wraparound(False)

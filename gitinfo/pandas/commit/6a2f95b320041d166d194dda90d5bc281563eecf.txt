commit 6a2f95b320041d166d194dda90d5bc281563eecf
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon Jan 20 07:35:41 2020 -0800

    REF: require PeriodArray in PeriodIndex._simple_new (#31128)

diff --git a/pandas/core/indexes/datetimelike.py b/pandas/core/indexes/datetimelike.py
index bf1272b22..d262fcdc9 100644
--- a/pandas/core/indexes/datetimelike.py
+++ b/pandas/core/indexes/datetimelike.py
@@ -193,20 +193,21 @@ class DatetimeIndexOpsMixin(ExtensionIndex):
             #  because the treatment of NaT has been changed to put NaT last
             #  instead of first.
             sorted_values = np.sort(self.asi8)
-            attribs = self._get_attributes_dict()
-            freq = attribs["freq"]
 
+            freq = self.freq
             if freq is not None and not is_period_dtype(self):
                 if freq.n > 0 and not ascending:
                     freq = freq * -1
                 elif freq.n < 0 and ascending:
                     freq = freq * -1
-            attribs["freq"] = freq
 
             if not ascending:
                 sorted_values = sorted_values[::-1]
 
-            return self._simple_new(sorted_values, **attribs)
+            arr = type(self._data)._simple_new(
+                sorted_values, dtype=self.dtype, freq=freq
+            )
+            return self._simple_new(arr, name=self.name)
 
     @Appender(_index_shared_docs["take"] % _index_doc_kwargs)
     def take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):
@@ -503,22 +504,21 @@ class DatetimeIndexOpsMixin(ExtensionIndex):
         """
         Concatenate to_concat which has the same class.
         """
-        attribs = self._get_attributes_dict()
-        attribs["name"] = name
+
         # do not pass tz to set because tzlocal cannot be hashed
         if len({str(x.dtype) for x in to_concat}) != 1:
             raise ValueError("to_concat must have the same tz")
 
-        new_data = type(self._values)._concat_same_type(to_concat).asi8
+        new_data = type(self._data)._concat_same_type(to_concat)
 
-        # GH 3232: If the concat result is evenly spaced, we can retain the
-        # original frequency
-        is_diff_evenly_spaced = len(unique_deltas(new_data)) == 1
-        if not is_period_dtype(self) and not is_diff_evenly_spaced:
-            # reset freq
-            attribs["freq"] = None
+        if not is_period_dtype(self.dtype):
+            # GH 3232: If the concat result is evenly spaced, we can retain the
+            # original frequency
+            is_diff_evenly_spaced = len(unique_deltas(new_data.asi8)) == 1
+            if is_diff_evenly_spaced:
+                new_data._freq = self.freq
 
-        return self._simple_new(new_data, **attribs)
+        return self._simple_new(new_data, name=name)
 
     def shift(self, periods=1, freq=None):
         """
diff --git a/pandas/core/indexes/period.py b/pandas/core/indexes/period.py
index 35f96e617..20e390f2d 100644
--- a/pandas/core/indexes/period.py
+++ b/pandas/core/indexes/period.py
@@ -15,7 +15,6 @@ from pandas.core.dtypes.common import (
     is_datetime64_any_dtype,
     is_dtype_equal,
     is_float,
-    is_float_dtype,
     is_integer,
     is_integer_dtype,
     is_list_like,
@@ -234,21 +233,12 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index, PeriodDelegateMixin):
 
         Parameters
         ----------
-        values : PeriodArray, PeriodIndex, Index[int64], ndarray[int64]
+        values : PeriodArray
             Values that can be converted to a PeriodArray without inference
             or coercion.
-
         """
-        # TODO: raising on floats is tested, but maybe not useful.
-        # Should the callers know not to pass floats?
-        # At the very least, I think we can ensure that lists aren't passed.
-        if isinstance(values, list):
-            values = np.asarray(values)
-        if is_float_dtype(values):
-            raise TypeError("PeriodIndex._simple_new does not accept floats.")
-        if freq:
-            freq = Period._maybe_convert_freq(freq)
-        values = PeriodArray(values, freq=freq)
+        assert isinstance(values, PeriodArray), type(values)
+        assert freq is None or freq == values.freq, (freq, values.freq)
 
         result = object.__new__(cls)
         result._data = values
@@ -834,7 +824,9 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index, PeriodDelegateMixin):
 
     def _apply_meta(self, rawarr):
         if not isinstance(rawarr, PeriodIndex):
-            rawarr = PeriodIndex._simple_new(rawarr, freq=self.freq, name=self.name)
+            if not isinstance(rawarr, PeriodArray):
+                rawarr = PeriodArray(rawarr, freq=self.freq)
+            rawarr = PeriodIndex._simple_new(rawarr, name=self.name)
         return rawarr
 
     def memory_usage(self, deep=False):
diff --git a/pandas/tests/arrays/test_datetimelike.py b/pandas/tests/arrays/test_datetimelike.py
index fa45db93c..87b825c8c 100644
--- a/pandas/tests/arrays/test_datetimelike.py
+++ b/pandas/tests/arrays/test_datetimelike.py
@@ -65,8 +65,8 @@ class SharedTests:
         #  to the case where one has length-1, which numpy would broadcast
         data = np.arange(10, dtype="i8") * 24 * 3600 * 10 ** 9
 
-        idx = self.index_cls._simple_new(data, freq="D")
-        arr = self.array_cls(idx)
+        idx = self.array_cls._simple_new(data, freq="D")
+        arr = self.index_cls(idx)
 
         with pytest.raises(ValueError, match="Lengths must match"):
             arr == arr[:1]
@@ -79,8 +79,8 @@ class SharedTests:
         data = np.arange(100, dtype="i8") * 24 * 3600 * 10 ** 9
         np.random.shuffle(data)
 
-        idx = self.index_cls._simple_new(data, freq="D")
-        arr = self.array_cls(idx)
+        arr = self.array_cls._simple_new(data, freq="D")
+        idx = self.index_cls._simple_new(arr)
 
         takers = [1, 4, 94]
         result = arr.take(takers)
@@ -97,8 +97,7 @@ class SharedTests:
     def test_take_fill(self):
         data = np.arange(10, dtype="i8") * 24 * 3600 * 10 ** 9
 
-        idx = self.index_cls._simple_new(data, freq="D")
-        arr = self.array_cls(idx)
+        arr = self.array_cls._simple_new(data, freq="D")
 
         result = arr.take([-1, 1], allow_fill=True, fill_value=None)
         assert result[0] is pd.NaT
@@ -121,7 +120,9 @@ class SharedTests:
     def test_concat_same_type(self):
         data = np.arange(10, dtype="i8") * 24 * 3600 * 10 ** 9
 
-        idx = self.index_cls._simple_new(data, freq="D").insert(0, pd.NaT)
+        arr = self.array_cls._simple_new(data, freq="D")
+        idx = self.index_cls(arr)
+        idx = idx.insert(0, pd.NaT)
         arr = self.array_cls(idx)
 
         result = arr._concat_same_type([arr[:-1], arr[1:], arr])
diff --git a/pandas/tests/indexes/period/test_constructors.py b/pandas/tests/indexes/period/test_constructors.py
index 27ee915e4..dcd3c8e94 100644
--- a/pandas/tests/indexes/period/test_constructors.py
+++ b/pandas/tests/indexes/period/test_constructors.py
@@ -322,22 +322,33 @@ class TestPeriodIndex:
 
     def test_constructor_simple_new(self):
         idx = period_range("2007-01", name="p", periods=2, freq="M")
-        result = idx._simple_new(idx, name="p", freq=idx.freq)
+
+        with pytest.raises(AssertionError, match="<class .*PeriodIndex'>"):
+            idx._simple_new(idx, name="p", freq=idx.freq)
+
+        result = idx._simple_new(idx._data, name="p", freq=idx.freq)
         tm.assert_index_equal(result, idx)
 
-        result = idx._simple_new(idx.astype("i8"), name="p", freq=idx.freq)
+        with pytest.raises(AssertionError):
+            # Need ndarray, not Int64Index
+            type(idx._data)._simple_new(idx.astype("i8"), freq=idx.freq)
+
+        arr = type(idx._data)._simple_new(idx.asi8, freq=idx.freq)
+        result = idx._simple_new(arr, name="p")
         tm.assert_index_equal(result, idx)
 
     def test_constructor_simple_new_empty(self):
         # GH13079
         idx = PeriodIndex([], freq="M", name="p")
-        result = idx._simple_new(idx, name="p", freq="M")
+        with pytest.raises(AssertionError, match="<class .*PeriodIndex'>"):
+            idx._simple_new(idx, name="p", freq="M")
+
+        result = idx._simple_new(idx._data, name="p", freq="M")
         tm.assert_index_equal(result, idx)
 
     @pytest.mark.parametrize("floats", [[1.1, 2.1], np.array([1.1, 2.1])])
     def test_constructor_floats(self, floats):
-        msg = r"PeriodIndex\._simple_new does not accept floats"
-        with pytest.raises(TypeError, match=msg):
+        with pytest.raises(AssertionError, match="<class "):
             pd.PeriodIndex._simple_new(floats, freq="M")
 
         msg = "PeriodIndex does not allow floating point in construction"

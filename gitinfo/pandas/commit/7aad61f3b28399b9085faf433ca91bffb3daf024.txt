commit 7aad61f3b28399b9085faf433ca91bffb3daf024
Author: Joris Van den Bossche <jorisvandenbossche@gmail.com>
Date:   Sun Apr 27 21:33:22 2014 +0200

    TST: Deprecation -> FutureWarning + catch in tests

diff --git a/pandas/io/sql.py b/pandas/io/sql.py
index 158ef7b7e..fbf18a8fa 100644
--- a/pandas/io/sql.py
+++ b/pandas/io/sql.py
@@ -130,7 +130,7 @@ def tquery(sql, con, cur=None, params=None, flavor='sqlite'):
     """
     warnings.warn(
         "tquery is depreciated, and will be removed in future versions",
-        DeprecationWarning)
+        FutureWarning)
 
     pandas_sql = pandasSQL_builder(con, flavor=flavor)
     args = _convert_params(sql, params)
@@ -163,7 +163,7 @@ def uquery(sql, con, cur=None, params=None, engine=None, flavor='sqlite'):
     """
     warnings.warn(
         "uquery is depreciated, and will be removed in future versions",
-        DeprecationWarning)
+        FutureWarning)
     pandas_sql = pandasSQL_builder(con, flavor=flavor)
     args = _convert_params(sql, params)
     return pandas_sql.uquery(*args)
@@ -212,7 +212,7 @@ def read_sql_table(table_name, con, meta=None, index_col=None,
     --------
     read_sql_query : Read SQL query into a DataFrame.
     read_sql
-    
+
 
     """
     pandas_sql = PandasSQLAlchemy(con, meta=meta)
@@ -322,8 +322,8 @@ def read_sql(sql, con, index_col=None, flavor='sqlite', coerce_float=True,
     Notes
     -----
     This function is a convenience wrapper around ``read_sql_table`` and
-    ``read_sql_query`` (and for backward compatibility) and will delegate 
-    to the specific function depending on the provided input (database 
+    ``read_sql_query`` (and for backward compatibility) and will delegate
+    to the specific function depending on the provided input (database
     table name or sql query).
 
     See also
@@ -423,13 +423,12 @@ def pandasSQL_builder(con, flavor=None, meta=None):
         if isinstance(con, sqlalchemy.engine.Engine):
             return PandasSQLAlchemy(con, meta=meta)
         else:
-            warnings.warn(
-                """Not an SQLAlchemy engine,
-                  attempting to use as legacy DBAPI connection""")
+            warnings.warn("Not an SQLAlchemy engine, "
+                          "attempting to use as legacy DBAPI connection")
             if flavor is None:
                 raise ValueError(
-                    """PandasSQL must be created with an SQLAlchemy engine
-                    or a DBAPI2 connection and SQL flavour""")
+                    "PandasSQL must be created with an SQLAlchemy engine "
+                    "or a DBAPI2 connection and SQL flavor")
             else:
                 return PandasSQLLegacy(con, flavor)
 
@@ -1006,7 +1005,7 @@ class PandasSQLLegacy(PandasSQL):
             fail: If table exists, do nothing.
             replace: If table exists, drop it, recreate it, and insert data.
             append: If table exists, insert data. Create if does not exist.
-        
+
         """
         table = PandasSQLTableLegacy(
             name, self, frame=frame, index=index, if_exists=if_exists,
@@ -1041,20 +1040,20 @@ def get_schema(frame, name, con, flavor='sqlite'):
     name: name of SQL table
     con: an open SQL database connection object
     engine: an SQLAlchemy engine - replaces connection and flavor
-    flavor: {'sqlite', 'mysql', 'postgres'}, default 'sqlite'
+    flavor: {'sqlite', 'mysql'}, default 'sqlite'
 
     """
-    warnings.warn(
-        "get_schema is depreciated", DeprecationWarning)
+    warnings.warn("get_schema is depreciated", FutureWarning)
+
     pandas_sql = pandasSQL_builder(con=con, flavor=flavor)
     return pandas_sql._create_sql_schema(frame, name)
 
 
+
 def read_frame(*args, **kwargs):
     """DEPRECIATED - use read_sql
     """
-    warnings.warn(
-        "read_frame is depreciated, use read_sql", DeprecationWarning)
+    warnings.warn("read_frame is depreciated, use read_sql", FutureWarning)
     return read_sql(*args, **kwargs)
 
 
@@ -1092,7 +1091,7 @@ def write_frame(frame, name, con, flavor='sqlite', if_exists='fail', **kwargs):
     pandas.DataFrame.to_sql
 
     """
-    warnings.warn("write_frame is depreciated, use to_sql", DeprecationWarning)
+    warnings.warn("write_frame is depreciated, use to_sql", FutureWarning)
 
     # for backwards compatibility, set index=False when not specified
     index = kwargs.pop('index', False)
diff --git a/pandas/io/tests/test_sql.py b/pandas/io/tests/test_sql.py
index ad3fa57ab..ee6d1d0b6 100644
--- a/pandas/io/tests/test_sql.py
+++ b/pandas/io/tests/test_sql.py
@@ -336,8 +336,9 @@ class _TestSQLApi(PandasSQLTest):
         self._check_iris_loaded_frame(iris_frame)
 
     def test_legacy_read_frame(self):
-        iris_frame = sql.read_frame(
-            "SELECT * FROM iris", self.conn, flavor='sqlite')
+        with tm.assert_produces_warning(FutureWarning):
+            iris_frame = sql.read_frame(
+                "SELECT * FROM iris", self.conn, flavor='sqlite')
         self._check_iris_loaded_frame(iris_frame)
 
     def test_to_sql(self):
@@ -402,8 +403,10 @@ class _TestSQLApi(PandasSQLTest):
     def test_legacy_write_frame(self):
         # Assume that functionality is already tested above so just do
         # quick check that it basically works
-        sql.write_frame(self.test_frame1, 'test_frame_legacy', self.conn,
-                        flavor='sqlite')
+        with tm.assert_produces_warning(FutureWarning):
+            sql.write_frame(self.test_frame1, 'test_frame_legacy', self.conn,
+                            flavor='sqlite')
+
         self.assertTrue(
             sql.has_table('test_frame_legacy', self.conn, flavor='sqlite'),
             'Table not written to DB')
@@ -431,11 +434,18 @@ class _TestSQLApi(PandasSQLTest):
         tm.equalContents(row, [5.1, 3.5, 1.4, 0.2, 'Iris-setosa'])
 
     def test_tquery(self):
-        iris_results = sql.tquery(
-            "SELECT * FROM iris", con=self.conn, flavor='sqlite')
+        with tm.assert_produces_warning(FutureWarning):
+            iris_results = sql.tquery(
+                "SELECT * FROM iris", con=self.conn, flavor='sqlite')
         row = iris_results[0]
         tm.equalContents(row, [5.1, 3.5, 1.4, 0.2, 'Iris-setosa'])
 
+    def test_uquery(self):
+        with tm.assert_produces_warning(FutureWarning):
+            rows = sql.uquery(
+                "SELECT * FROM iris LIMIT 1", con=self.conn, flavor='sqlite')
+        self.assertEqual(rows, -1)
+
     def test_date_parsing(self):
         # Test date parsing in read_sq
         # No Parsing

commit 50502fbd99f897aaa8c89c7f9e2fdabdd2888863
Author: Phillip Cloud <cpcloud@gmail.com>
Date:   Mon Sep 16 10:38:09 2013 -0400

    CLN/DOC: remove __getitem__ from docs

diff --git a/doc/source/comparison_with_r.rst b/doc/source/comparison_with_r.rst
index 012a6fe6b..ef609aaa7 100644
--- a/doc/source/comparison_with_r.rst
+++ b/doc/source/comparison_with_r.rst
@@ -49,7 +49,6 @@ index/slice as well as standard boolean indexing:
 
        df = DataFrame({'a': randn(10), 'b': randn(10)})
        df.query('a <= b')
-       df['a <= b']
        df[df.a <= df.b]
        df.loc[df.a <= df.b]
 
diff --git a/doc/source/enhancingperf.rst b/doc/source/enhancingperf.rst
index 6d5717e42..87b68248c 100644
--- a/doc/source/enhancingperf.rst
+++ b/doc/source/enhancingperf.rst
@@ -292,8 +292,8 @@ Read more in the `cython docs <http://docs.cython.org/>`__.
 
 .. _enhancingperf.eval:
 
-Expression Evaluation via :func:`~pandas.eval`
-----------------------------------------------
+Expression Evaluation via :func:`~pandas.eval` (Experimental)
+-------------------------------------------------------------
 
 .. versionadded:: 0.13
 
@@ -392,8 +392,8 @@ Now let's do the same thing but with comparisons:
    includes bitwise operations on scalars.* You should perform these kinds of
    operations in Python.
 
-The ``DataFrame.eval`` method
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+The ``DataFrame.eval`` method (Experimental)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 In addition to the top level :func:`~pandas.eval` function you can also
 evaluate an expression in the "context" of a ``DataFrame``.
@@ -447,13 +447,11 @@ You can refer to local variables the same way you would in vanilla Python
 
        df.eval('@a + b')
 
-   The same is true for :meth:`~pandas.DataFrame.query` and
-   :meth:`~pandas.DataFrame.__getitem__` passed an expression
+   The same is true for :meth:`~pandas.DataFrame.query`
 
     .. ipython:: python
 
        df.query('@a < b')
-       df['@a < b']
 
     .. ipython:: python
        :suppress:
diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index 7d22fb533..2f2a47d4b 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -26,48 +26,58 @@ The axis labeling information in pandas objects serves many purposes:
   - Enables automatic and explicit data alignment
   - Allows intuitive getting and setting of subsets of the data set
 
-In this section / chapter, we will focus on the final point: namely, how to
-slice, dice, and generally get and set subsets of pandas objects. The primary
-focus will be on Series and DataFrame as they have received more development
-attention in this area. Expect more work to be invested higher-dimensional data
-structures (including Panel) in the future, especially in label-based advanced
+In this section, we will focus on the final point: namely, how to slice, dice,
+and generally get and set subsets of pandas objects. The primary focus will be
+on Series and DataFrame as they have received more development attention in
+this area. Expect more work to be invested higher-dimensional data structures
+(including ``Panel``) in the future, especially in label-based advanced
 indexing.
 
 .. note::
 
-   The Python and NumPy indexing operators ``[]`` and attribute operator ``.`` provide quick and easy access to pandas data structures
-   across a wide range of use cases. This makes interactive work intuitive, as
-   there's little new to learn if you already know how to deal with Python
-   dictionaries and NumPy arrays. However, since the type of the data to be accessed
-   isn't known in advance, directly using
-   standard operators has some optimization limits. For production code, we recommended
-   that you take advantage of the optimized pandas data access methods exposed in this chapter.
+   The Python and NumPy indexing operators ``[]`` and attribute operator ``.``
+   provide quick and easy access to pandas data structures across a wide range
+   of use cases. This makes interactive work intuitive, as there's little new
+   to learn if you already know how to deal with Python dictionaries and NumPy
+   arrays. However, since the type of the data to be accessed isn't known in
+   advance, directly using standard operators has some optimization limits. For
+   production code, we recommended that you take advantage of the optimized
+   pandas data access methods exposed in this chapter.
 
 .. warning::
 
-   Whether a copy or a reference is returned for a setting operation, may depend on the context.
-   This is sometimes called ``chained assignment`` and should be avoided.
-   See :ref:`Returning a View versus Copy <indexing.view_versus_copy>`
+   Whether a copy or a reference is returned for a setting operation, may
+   depend on the context.  This is sometimes called ``chained assignment`` and
+   should be avoided.  See :ref:`Returning a View versus Copy
+   <indexing.view_versus_copy>`
 
 See the :ref:`cookbook<cookbook.selection>` for some advanced strategies
 
-Choice
-------
+Different Choices for Indexing (``loc``, ``iloc``, and ``ix``)
+--------------------------------------------------------------
 
-Starting in 0.11.0, object selection has had a number of user-requested additions in
-order to support more explicit location based indexing. Pandas now supports
-three types of multi-axis indexing.
+.. versionadded:: 0.11.0
 
-- ``.loc`` is strictly label based, will raise ``KeyError`` when the items are not found, allowed inputs are:
+Object selection has had a number of user-requested additions in order to
+support more explicit location based indexing. Pandas now supports three types
+of multi-axis indexing.
 
-  - A single label, e.g. ``5`` or ``'a'``, (note that ``5`` is interpreted as a *label* of the index. This use is **not** an integer position along the index)
+- ``.loc`` is strictly label based, will raise ``KeyError`` when the items are
+  not found, allowed inputs are:
+
+  - A single label, e.g. ``5`` or ``'a'``, (note that ``5`` is interpreted as a
+    *label* of the index. This use is **not** an integer position along the
+    index)
   - A list or array of labels ``['a', 'b', 'c']``
-  - A slice object with labels ``'a':'f'``, (note that contrary to usual python slices, **both** the start and the stop are included!)
+  - A slice object with labels ``'a':'f'``, (note that contrary to usual python
+    slices, **both** the start and the stop are included!)
   - A boolean array
 
   See more at :ref:`Selection by Label <indexing.label>`
 
-- ``.iloc`` is strictly integer position based (from ``0`` to ``length-1`` of the axis), will raise ``IndexError`` when the requested indicies are out of bounds. Allowed inputs are:
+- ``.iloc`` is strictly integer position based (from ``0`` to ``length-1`` of
+  the axis), will raise ``IndexError`` when the requested indicies are out of
+  bounds. Allowed inputs are:
 
   - An integer e.g. ``5``
   - A list or array of integers ``[4, 3, 0]``
@@ -75,20 +85,24 @@ three types of multi-axis indexing.
 
   See more at :ref:`Selection by Position <indexing.integer>`
 
-- ``.ix`` supports mixed integer and label based access. It is primarily label based, but will fallback to integer positional access. ``.ix`` is the most general
-  and will support any of the inputs to ``.loc`` and ``.iloc``, as well as support for floating point label schemes. ``.ix`` is especially useful when dealing with mixed positional and label
-  based hierarchial indexes.
-
-  As using integer slices with ``.ix`` have different behavior depending on whether the slice is interpreted as position based or label based, it's
+- ``.ix`` supports mixed integer and label based access. It is primarily label
+  based, but will fallback to integer positional access. ``.ix`` is the most
+  general and will support any of the inputs to ``.loc`` and ``.iloc``, as well
+  as support for floating point label schemes. ``.ix`` is especially useful
+  when dealing with mixed positional and label based hierarchial indexes.
+  As using integer slices with ``.ix`` have different behavior depending on
+  whether the slice is interpreted as position based or label based, it's
   usually better to be explicit and use ``.iloc`` or ``.loc``.
 
-  See more at :ref:`Advanced Indexing <indexing.advanced>`, :ref:`Advanced Hierarchical <indexing.advanced_hierarchical>` and :ref:`Fallback Indexing <indexing.fallback>`
+  See more at :ref:`Advanced Indexing <indexing.advanced>`, :ref:`Advanced
+  Hierarchical <indexing.advanced_hierarchical>` and :ref:`Fallback Indexing
+  <indexing.fallback>`
 
 Getting values from an object with multi-axes selection uses the following
 notation (using ``.loc`` as an example, but applies to ``.iloc`` and ``.ix`` as
 well). Any of the axes accessors may be the null slice ``:``. Axes left out of
 the specification are assumed to be ``:``. (e.g. ``p.loc['a']`` is equiv to
-``p.loc['a',:,:]``)
+``p.loc['a', :, :]``)
 
 .. csv-table::
     :header: "Object Type", "Indexers"
@@ -100,7 +114,7 @@ the specification are assumed to be ``:``. (e.g. ``p.loc['a']`` is equiv to
     Panel; ``p.loc[item_indexer,major_indexer,minor_indexer]``
 
 Deprecations
-~~~~~~~~~~~~
+------------
 
 Beginning with version 0.11.0, it's recommended that you transition away from
 the following methods as they *may* be deprecated in future versions.
@@ -168,7 +182,7 @@ You may find this useful for applying a transform (in-place) to a subset of the
 columns.
 
 Attribute Access
-~~~~~~~~~~~~~~~~
+----------------
 
 .. _indexing.columns.multiple:
 
@@ -213,7 +227,7 @@ If you are using the IPython environment, you may also use tab-completion to
 see these accessable attributes.
 
 Slicing ranges
-~~~~~~~~~~~~~~
+--------------
 
 The most robust and consistent way of slicing ranges along arbitrary axes is
 described in the :ref:`Selection by Position <indexing.integer>` section
@@ -247,7 +261,7 @@ largely as a convenience since it is such a common operation.
 .. _indexing.label:
 
 Selection By Label
-~~~~~~~~~~~~~~~~~~
+------------------
 
 .. warning::
 
@@ -318,7 +332,7 @@ For getting a value explicity (equiv to deprecated ``df.get_value('a','A')``)
 .. _indexing.integer:
 
 Selection By Position
-~~~~~~~~~~~~~~~~~~~~~
+---------------------
 
 .. warning::
 
@@ -415,7 +429,7 @@ Pandas will detect this and raise ``IndexError``, rather than return an empty st
 .. _indexing.basics.partial_setting:
 
 Setting With Enlargement
-~~~~~~~~~~~~~~~~~~~~~~~~
+------------------------
 
 .. versionadded:: 0.13
 
@@ -450,7 +464,7 @@ This is like an ``append`` operation on the ``DataFrame``.
 .. _indexing.basics.get_value:
 
 Fast scalar value getting and setting
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+-------------------------------------
 
 Since indexing with ``[]`` must handle a lot of cases (single-label access,
 slicing, boolean indexing, etc.), it has a bit of overhead in order to figure
@@ -481,7 +495,7 @@ You can also set using these same indexers.
    df
 
 Boolean indexing
-~~~~~~~~~~~~~~~~
+----------------
 
 .. _indexing.boolean:
 
@@ -572,8 +586,8 @@ You can also describe columns using integer location:
    df.isin(values, iloc=True)
 
 
-Where and Masking
-~~~~~~~~~~~~~~~~~
+The :meth:`~pandas.DataFrame.where` Method and Masking
+------------------------------------------------------
 
 Selecting values from a Series with a boolean vector generally returns a
 subset of the data. To guarantee that selection output has the same shape as
@@ -673,634 +687,634 @@ This is equivalent (but faster than) the following.
    s.mask(s >= 0)
    df.mask(df >= 0)
 
-Take Methods
-~~~~~~~~~~~~
+.. _indexing.query:
 
-.. _indexing.take:
+The :meth:`~pandas.DataFrame.query` Method (Experimental)
+---------------------------------------------------------
 
-Similar to numpy ndarrays, pandas Index, Series, and DataFrame also provides
-the ``take`` method that retrieves elements along a given axis at the given
-indices. The given indices must be either a list or an ndarray of integer
-index positions. ``take`` will also accept negative integers as relative positions to the end of the object.
+.. versionadded:: 0.13
+
+:class:`~pandas.DataFrame` objects have a :meth:`~pandas.DataFrame.query`
+method that allows selection using an expression.
+
+You can get the value of the frame where column ``b`` has values
+between the values of columns ``a`` and ``c``. For example:
 
 .. ipython:: python
+   :suppress:
 
-   index = Index(randint(0, 1000, 10))
-   index
+   from numpy.random import randint, rand
+   np.random.seed(1234)
 
-   positions = [0, 9, 3]
+.. ipython:: python
 
-   index[positions]
-   index.take(positions)
+   n = 10
+   df = DataFrame(rand(n, 3), columns=list('abc'))
+   df
 
-   ser = Series(randn(10))
+   # pure python
+   df[(df.a < df.b) & (df.b < df.c)]
 
-   ser.ix[positions]
-   ser.take(positions)
+   # query
+   df.query('(a < b) & (b < c)')
 
-For DataFrames, the given indices should be a 1d list or ndarray that specifies
-row or column positions.
+Do the same thing but fallback on a named index if there is no column
+with the name ``a``.
 
 .. ipython:: python
 
-   frm = DataFrame(randn(5, 3))
+   df = DataFrame(randint(n / 2, size=(n, 2)), columns=list('bc'))
+   df.index.name = 'a'
+   df
+   df.query('a < b and b < c')
 
-   frm.take([1, 4, 3])
+If instead you don't want to or cannot name your index, you can use the name
+``index`` in your query expression:
 
-   frm.take([0, 2], axis=1)
+.. ipython:: python
+   :suppress:
 
-It is important to note that the ``take`` method on pandas objects are not
-intended to work on boolean indices and may return unexpected results.
+   old_index = index
+   del index
 
 .. ipython:: python
 
-   arr = randn(10)
-   arr.take([False, False, True, True])
-   arr[[0, 1]]
+   df = DataFrame(randint(n, size=(n, 2)), columns=list('bc'))
+   df
+   df.query('index < b < c')
 
-   ser = Series(randn(10))
-   ser.take([False, False, True, True])
-   ser.ix[[0, 1]]
+.. ipython:: python
+   :suppress:
 
-Finally, as a small note on performance, because the ``take`` method handles
-a narrower range of inputs, it can offer performance that is a good deal
-faster than fancy indexing.
+   index = old_index
+   del old_index
 
-.. ipython::
 
-   arr = randn(10000, 5)
-   indexer = np.arange(10000)
-   random.shuffle(indexer)
+:class:`~pandas.MultiIndex` :meth:`~pandas.DataFrame.query` Syntax
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-   timeit arr[indexer]
-   timeit arr.take(indexer, axis=0)
+You can also use the levels of a ``DataFrame`` with a
+:class:`~pandas.MultiIndex` as if they were columns in the frame:
 
-   ser = Series(arr[:, 0])
-   timeit ser.ix[indexer]
-   timeit ser.take(indexer)
+.. ipython:: python
 
-Duplicate Data
-~~~~~~~~~~~~~~
+   import pandas.util.testing as tm
 
-.. _indexing.duplicate:
+   n = 10
+   colors = tm.choice(['red', 'green'], size=n)
+   foods = tm.choice(['eggs', 'ham'], size=n)
+   colors
+   foods
 
-If you want to identify and remove duplicate rows in a DataFrame,  there are
-two methods that will help: ``duplicated`` and ``drop_duplicates``. Each
-takes as an argument the columns to use to identify duplicated rows.
+   index = MultiIndex.from_arrays([colors, foods], names=['color', 'food'])
+   df = DataFrame(randn(n, 2), index=index)
+   df
+   df.query('color == "red"')
 
-- ``duplicated`` returns a boolean vector whose length is the number of rows, and which indicates whether a row is duplicated.
-- ``drop_duplicates`` removes duplicate rows.
+If the levels of the ``MultiIndex`` are unnamed, you can refer to them using
+special names:
 
-By default, the first observed row of a duplicate set is considered unique, but
-each method has a ``take_last`` parameter that indicates the last observed row
-should be taken instead.
 
 .. ipython:: python
 
-   df2 = DataFrame({'a' : ['one', 'one', 'two', 'three', 'two', 'one', 'six'],
-                    'b' : ['x', 'y', 'y', 'x', 'y', 'x', 'x'],
-                    'c' : np.random.randn(7)})
-   df2.duplicated(['a','b'])
-   df2.drop_duplicates(['a','b'])
-   df2.drop_duplicates(['a','b'], take_last=True)
-
-.. _indexing.dictionarylike:
+   df.index.names = [None, None]
+   df
+   df.query('ilevel_0 == "red"')
 
-Dictionary-like ``get`` method
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-Each of Series, DataFrame, and Panel have a ``get`` method which can return a
-default value.
+The convention is ``ilevel_0``, which means "index level 0" for the 0th level
+of the ``index``.
 
-.. ipython:: python
 
-   s = Series([1,2,3], index=['a','b','c'])
-   s.get('a')               # equivalent to s['a']
-   s.get('x', default=-1)
+:meth:`~pandas.DataFrame.query` Use Cases
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-.. _indexing.advanced:
+A use case for :meth:`~pandas.DataFrame.query` is when you have a collection of
+:class:`~pandas.DataFrame` objects that have a subset of column names (or index
+levels/names) in common. You can pass the same query to both frames *without*
+having to specify which frame you're interested in querying
 
-Advanced Indexing with ``.ix``
-------------------------------
+.. ipython:: python
 
-.. note::
+   df = DataFrame(rand(n, 3), columns=list('abc'))
+   df
+   df2 = DataFrame(rand(n + 2, 3), columns=df.columns)
+   df2
+   expr = '0.0 <= a <= c <= 0.5'
+   map(lambda frame: frame.query(expr), [df, df2])
 
-   The recent addition of ``.loc`` and ``.iloc`` have enabled users to be quite
-   explicit about indexing choices. ``.ix`` allows a great flexibility to
-   specify indexing locations by *label* and/or *integer position*. Pandas will
-   attempt to use any passed *integer* as *label* locations first (like what
-   ``.loc`` would do, then to fall back on *positional* indexing, like what
-   ``.iloc``  would do). See :ref:`Fallback Indexing <indexing.fallback>` for
-   an example.
+:meth:`~pandas.DataFrame.query` Python versus pandas Syntax Comparison
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-The syntax of using ``.ix`` is identical to ``.loc``, in :ref:`Selection by
-Label <indexing.label>`, and ``.iloc`` in :ref:`Selection by Position <indexing.integer>`.
+Full numpy-like syntax
 
-The ``.ix`` attribute takes the following inputs:
+.. ipython:: python
 
-- An integer or single label, e.g. ``5`` or ``'a'``
-- A list or array of labels ``['a', 'b', 'c']`` or integers ``[4, 3, 0]``
-- A slice object with ints ``1:7`` or labels ``'a':'f'``
-- A boolean array
+   df = DataFrame(randint(n, size=(n, 3)), columns=list('abc'))
+   df
+   df.query('(a < b) & (b < c)')
+   df[(df.a < df.b) & (df.b < df.c)]
 
-We'll illustrate all of these methods. First, note that this provides a concise
-way of reindexing on multiple axes at once:
+Slightly nicer by removing the parentheses (by binding making comparison
+operators bind tighter than ``&``/``|``)
 
 .. ipython:: python
 
-   subindex = dates[[3,4,5]]
-   df.reindex(index=subindex, columns=['C', 'B'])
-   df.ix[subindex, ['C', 'B']]
+   df.query('a < b & b < c')
 
-Assignment / setting values is possible when using ``ix``:
+Use English instead of symbols
 
 .. ipython:: python
 
-   df2 = df.copy()
-   df2.ix[subindex, ['C', 'B']] = 0
-   df2
+   df.query('a < b and b < c')
 
-Indexing with an array of integers can also be done:
+Pretty close to how you might write it on paper
 
 .. ipython:: python
 
-   df.ix[[4,3,1]]
-   df.ix[dates[[4,3,1]]]
+   df.query('a < b < c')
 
-**Slicing** has standard Python semantics for integer slices:
+The ``in`` and ``not in`` operators
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-.. ipython:: python
+:meth:`~pandas.DataFrame.query` also supports special use of Python's ``in`` and
+``not in`` comparison operators, providing a succint syntax for calling the
+``isin`` method of a ``Series`` or ``DataFrame``.
 
-   df.ix[1:7, :2]
+.. ipython:: python
+   :suppress:
 
-Slicing with labels is semantically slightly different because the slice start
-and stop are **inclusive** in the label-based case:
+   try:
+       old_d = d
+       del d
+   except NameError:
+       pass
 
 .. ipython:: python
 
-   date1, date2 = dates[[2, 4]]
-   print date1, date2
-   df.ix[date1:date2]
-   df['A'].ix[date1:date2]
+   # get all rows where columns "a" and "b" have overlapping values
+   df = DataFrame({'a': list('aabbccddeeff'), 'b': list('aaaabbbbcccc'),
+                   'c': randint(5, size=12), 'd': randint(9, size=12)})
+   df
+   df.query('a in b')
 
-Getting and setting rows in a DataFrame, especially by their location, is much
-easier:
+   # How you'd do it in pure Python
+   df[df.a.isin(df.b)]
 
-.. ipython:: python
+   df.query('a not in b')
 
-   df2 = df[:5].copy()
-   df2.ix[3]
-   df2.ix[3] = np.arange(len(df2.columns))
-   df2
+   # pure Python
+   df[~df.a.isin(df.b)]
+
+
+You can combine this with other expressions for very succinct queries:
 
-Column or row selection can be combined as you would expect with arrays of
-labels or even boolean vectors:
 
 .. ipython:: python
 
-   df.ix[df['A'] > 0, 'B']
-   df.ix[date1:date2, 'B']
-   df.ix[date1, 'B']
+   # rows where cols a and b have overlapping values and col c's values are less than col d's
+   df.query('a in b and c < d')
 
-Slicing with labels is closely related to the ``truncate`` method which does
-precisely ``.ix[start:stop]`` but returns a copy (for legacy reasons).
+   # pure Python
+   df[df.b.isin(df.a) & (df.c < df.d)]
 
-The ``select`` method
-~~~~~~~~~~~~~~~~~~~~~
 
-Another way to extract slices from an object is with the ``select`` method of
-Series, DataFrame, and Panel. This method should be used only when there is no
-more direct way.  ``select`` takes a function which operates on labels along
-``axis`` and returns a boolean.  For instance:
+.. note::
 
-.. ipython:: python
+   Note that ``in`` and ``not in`` are evaluated in Python, since ``numexpr``
+   has no equivalent of this operation. However, **only the** ``in``/``not in``
+   **expression itself** is evaluated in vanilla Python. For example, in the
+   expression
 
-   df.select(lambda x: x == 'A', axis=1)
+       .. code-block:: python
 
-The ``lookup`` method
-~~~~~~~~~~~~~~~~~~~~~
+          df.query('a in b + c + d')
 
-Sometimes you want to extract a set of values given a sequence of row labels
-and column labels, and the ``lookup`` method allows for this and returns a
-numpy array.  For instance,
+   ``(b + c + d)`` is evaluated by ``numexpr`` and *then* the ``in``
+   operation is evaluated in plain Python. In general, any operations that can
+   be evaluated using ``numexpr`` will be.
+
+Special use of the ``==`` operator with ``list`` objects
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Comparing a ``list`` of values to a column using ``==``/``!=`` works similarly
+to ``in``/``not in``
 
 .. ipython:: python
 
-  dflookup = DataFrame(np.random.rand(20,4), columns = ['A','B','C','D'])
-  dflookup.lookup(list(range(0,10,2)), ['B','C','A','B','D'])
+   df.query('b == ["a", "b", "c"]')
 
-Setting values in mixed-type DataFrame
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+   # pure Python
+   df[df.b.isin(["a", "b", "c"])]
 
-.. _indexing.mixed_type_setting:
+   df.query('c == [1, 2]')
 
-Setting values on a mixed-type DataFrame or Panel is supported when using
-scalar values, though setting arbitrary vectors is not yet supported:
+   df.query('c != [1, 2]')
 
-.. ipython:: python
+   # using in/not in
+   df.query('[1, 2] in c')
 
-   df2 = df[:4]
-   df2['foo'] = 'bar'
-   print df2
-   df2.ix[2] = np.nan
-   print df2
-   print df2.dtypes
+   df.query('[1, 2] not in c')
 
-.. _indexing.view_versus_copy:
+   # pure Python
+   df[df.c.isin([1, 2])]
 
-Returning a view versus a copy
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-The rules about when a view on the data is returned are entirely dependent on
-NumPy. Whenever an array of labels or a boolean vector are involved in the
-indexing operation, the result will be a copy. With single label / scalar
-indexing and slicing, e.g. ``df.ix[3:6]`` or ``df.ix[:, 'A']``, a view will be
-returned.
+Boolean Operators
+~~~~~~~~~~~~~~~~~
 
-In chained expressions, the order may determine whether a copy is returned or not:
+You can negate boolean expressions with the word ``not`` or the ``~`` operator.
 
 .. ipython:: python
 
+   df = DataFrame(rand(n, 3), columns=list('abc'))
+   df['bools'] = rand(len(df)) > 0.5
+   df.query('~bools')
+   df.query('not bools')
+   df.query('not bools') == df[~df.bools]
 
-   dfb = DataFrame({'a' : ['one', 'one', 'two',
-                           'three', 'two', 'one', 'six'],
-                    'b' : ['x', 'y', 'y',
-                           'x', 'y', 'x', 'x'],
-                    'c' : randn(7)})
-
-
-   # goes to copy (will be lost)
-   dfb[dfb.a.str.startswith('o')]['c'] = 42
+Of course, expressions can be arbitrarily complex too
 
-   # passed via reference (will stay)
-   dfb['c'][dfb.a.str.startswith('o')] = 42
+.. ipython:: python
 
-A chained assignment can also crop up in setting in a mixed dtype frame.
+   # short query syntax
+   shorter = df.query('a < b < c and (not bools) or bools > 2')
 
-.. note::
+   # equivalent in pure Python
+   longer = df[(df.a < df.b) & (df.b < df.c) & (~df.bools) | (df.bools > 2)]
 
-   These setting rules apply to all of ``.loc/.iloc/.ix``
+   shorter
+   longer
 
-This is the correct access method
+   shorter == longer
 
 .. ipython:: python
+   :suppress:
 
-   dfc = DataFrame({'A':['aaa','bbb','ccc'],'B':[1,2,3]})
-   dfc_copy = dfc.copy()
-   dfc_copy.loc[0,'A'] = 11
-   dfc_copy
-
-This *can* work at times, but is not guaranteed, and so should be avoided
+   try:
+       d = old_d
+       del old_d
+   except NameError:
+       pass
 
-.. ipython:: python
 
-   dfc_copy = dfc.copy()
-   dfc_copy['A'][0] = 111
-   dfc_copy
+Performance of :meth:`~pandas.DataFrame.query`
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-This will **not** work at all, and so should be avoided
-
-.. ipython:: python
+``DataFrame.query()`` using ``numexpr`` is slightly faster than Python for
+large frames
 
-   dfc_copy = dfc.copy()
-   dfc_copy.loc[0]['A'] = 1111
-   dfc_copy
+.. image:: _static/query-perf.png
 
-When assigning values to subsets of your data, thus, make sure to either use the
-pandas access methods or explicitly handle the assignment creating a copy.
+.. note::
 
-Fallback indexing
-~~~~~~~~~~~~~~~~~~~~
+   You will only see the performance benefits of using the ``numexpr`` engine
+   with ``DataFrame.query()`` if your frame has more than approximately 50,000
+   rows
 
-.. _indexing.fallback:
+      .. image:: _static/query-perf-small.png
 
-Float indexes should be used only with caution. If you have a float indexed
-``DataFrame`` and try to select using an integer, the row that Pandas returns
-might not be what you expect. Pandas first attempts to use the *integer*
-as a *label* location, but fails to find a match (because the types
-are not equal). Pandas then falls back to back to positional indexing.
+This plot was created using a ``DataFrame`` with 3 columns each containing
+floating point values generated using ``numpy.random.randn()``.
 
 .. ipython:: python
+   :suppress:
 
-    df = pd.DataFrame(np.random.randn(4,4),
-        columns=list('ABCD'), index=[1.0, 2.0, 3.0, 4.0])
-    df
-    df.ix[1]
-
-To select the row you do expect, instead use a float label or
-use ``iloc``.
+   df = DataFrame(randn(8, 4), index=dates, columns=['A', 'B', 'C', 'D'])
+   df2 = df.copy()
 
-.. ipython:: python
+Take Methods
+------------
 
-    df.ix[1.0]
-    df.iloc[0]
+.. _indexing.take:
 
-Instead of using a float index, it is often better to
-convert to an integer index:
+Similar to numpy ndarrays, pandas Index, Series, and DataFrame also provides
+the ``take`` method that retrieves elements along a given axis at the given
+indices. The given indices must be either a list or an ndarray of integer
+index positions. ``take`` will also accept negative integers as relative positions to the end of the object.
 
 .. ipython:: python
 
-    df_new = df.reset_index()
-    df_new[df_new['index'] == 1.0]
-    # now you can also do "float selection"
-    df_new[(df_new['index'] >= 1.0) & (df_new['index'] < 2)]
-
+   index = Index(randint(0, 1000, 10))
+   index
 
-.. _indexing.query:
+   positions = [0, 9, 3]
 
-The :meth:`~pandas.DataFrame.query` Method
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+   index[positions]
+   index.take(positions)
 
-.. versionadded:: 0.13
+   ser = Series(randn(10))
 
-:class:`~pandas.DataFrame` objects have a :meth:`~pandas.DataFrame.query`
-method that allows selection using a boolean expression.
+   ser.ix[positions]
+   ser.take(positions)
 
-You can get the value of the frame where column ``b`` has values
-between the values of columns ``a`` and ``c``.
+For DataFrames, the given indices should be a 1d list or ndarray that specifies
+row or column positions.
 
 .. ipython:: python
-   :suppress:
 
-   from numpy.random import randint, rand
+   frm = DataFrame(randn(5, 3))
 
-.. ipython:: python
+   frm.take([1, 4, 3])
 
-   n = 10
-   df = DataFrame(rand(n, 3), columns=list('abc'))
-   df
-   df[(df.a < df.b) & (df.b < df.c)]
-   df.query('(a < b) & (b < c)')
+   frm.take([0, 2], axis=1)
 
-Do the same thing but fallback on a named index if there is no column
-with the name ``a``.
+It is important to note that the ``take`` method on pandas objects are not
+intended to work on boolean indices and may return unexpected results.
 
 .. ipython:: python
 
-   df = DataFrame(randint(n / 2, size=(n, 2)), columns=list('bc'))
-   df.index.name = 'a'
-   df
-   df.query('a < b and b < c')
+   arr = randn(10)
+   arr.take([False, False, True, True])
+   arr[[0, 1]]
 
-If instead you don't want to or cannot name your index, you can use the name
-``index`` in your query expression:
+   ser = Series(randn(10))
+   ser.take([False, False, True, True])
+   ser.ix[[0, 1]]
 
-.. ipython:: python
-   :suppress:
+Finally, as a small note on performance, because the ``take`` method handles
+a narrower range of inputs, it can offer performance that is a good deal
+faster than fancy indexing.
 
-   old_index = index
-   del index
+.. ipython::
 
-.. ipython:: python
+   arr = randn(10000, 5)
+   indexer = np.arange(10000)
+   random.shuffle(indexer)
 
-   df = DataFrame(randint(n, size=(n, 2)), columns=list('bc'))
-   df
-   df.query('index < b < c')
+   timeit arr[indexer]
+   timeit arr.take(indexer, axis=0)
 
-.. ipython:: python
-   :suppress:
+   ser = Series(arr[:, 0])
+   timeit ser.ix[indexer]
+   timeit ser.take(indexer)
 
-   index = old_index
-   del old_index
+Duplicate Data
+--------------
 
+.. _indexing.duplicate:
 
-:class:`~pandas.MultiIndex` :meth:`~pandas.DataFrame.query` Syntax
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+If you want to identify and remove duplicate rows in a DataFrame,  there are
+two methods that will help: ``duplicated`` and ``drop_duplicates``. Each
+takes as an argument the columns to use to identify duplicated rows.
 
-You can also use the levels of a ``DataFrame`` with a
-:class:`~pandas.MultiIndex` as if they were columns in the frame:
+- ``duplicated`` returns a boolean vector whose length is the number of rows, and which indicates whether a row is duplicated.
+- ``drop_duplicates`` removes duplicate rows.
 
-.. ipython:: python
+By default, the first observed row of a duplicate set is considered unique, but
+each method has a ``take_last`` parameter that indicates the last observed row
+should be taken instead.
 
-   import pandas.util.testing as tm
+.. ipython:: python
 
-   n = 10
-   colors = tm.choice(['red', 'green'], size=n)
-   foods = tm.choice(['eggs', 'ham'], size=n)
-   colors
-   foods
+   df2 = DataFrame({'a' : ['one', 'one', 'two', 'three', 'two', 'one', 'six'],
+                    'b' : ['x', 'y', 'y', 'x', 'y', 'x', 'x'],
+                    'c' : np.random.randn(7)})
+   df2.duplicated(['a','b'])
+   df2.drop_duplicates(['a','b'])
+   df2.drop_duplicates(['a','b'], take_last=True)
 
-   index = MultiIndex.from_arrays([colors, foods], names=['color', 'food'])
-   df = DataFrame(randn(n, 2), index=index)
-   df
-   df.query('color == "red"')
+.. _indexing.dictionarylike:
 
-If the levels of the ``MultiIndex`` are unnamed, you can refer to them using
-special names:
+Dictionary-like :meth:`~pandas.DataFrame.get` method
+----------------------------------------------------
 
+Each of Series, DataFrame, and Panel have a ``get`` method which can return a
+default value.
 
 .. ipython:: python
 
-   df.index.names = [None, None]
-   df
-   df.query('ilevel_0 == "red"')
+   s = Series([1,2,3], index=['a','b','c'])
+   s.get('a')               # equivalent to s['a']
+   s.get('x', default=-1)
 
+.. _indexing.advanced:
 
-The convention is ``ilevel_0``, which means "index level 0" for the 0th level
-of the ``index``.
+Advanced Indexing with ``.ix``
+------------------------------
 
+.. note::
 
-:meth:`~pandas.DataFrame.query` Use Cases
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+   The recent addition of ``.loc`` and ``.iloc`` have enabled users to be quite
+   explicit about indexing choices. ``.ix`` allows a great flexibility to
+   specify indexing locations by *label* and/or *integer position*. Pandas will
+   attempt to use any passed *integer* as *label* locations first (like what
+   ``.loc`` would do, then to fall back on *positional* indexing, like what
+   ``.iloc``  would do). See :ref:`Fallback Indexing <indexing.fallback>` for
+   an example.
 
-One use case for :meth:`~pandas.DataFrame.query` is when you have a collection of
-:class:`~pandas.DataFrame` objects that have a subset of column names (or index
-levels/names) in common. You can pass the same query to both frames *without*
-having to specify which frame you're interested in querying
+The syntax of using ``.ix`` is identical to ``.loc``, in :ref:`Selection by
+Label <indexing.label>`, and ``.iloc`` in :ref:`Selection by Position <indexing.integer>`.
 
-.. ipython:: python
+The ``.ix`` attribute takes the following inputs:
 
-   df = DataFrame(randint(n / 2, size=(n, 2)), columns=list('bc'))
-   df.index.name = 'a'
-   df2 = DataFrame(randint(n + 5, size=(n + 5, 3)), columns=list('abc'))
-   df2
-   expr = 'a < b & b < c'
-   map(lambda frame: frame.query(expr), [df, df2])
+- An integer or single label, e.g. ``5`` or ``'a'``
+- A list or array of labels ``['a', 'b', 'c']`` or integers ``[4, 3, 0]``
+- A slice object with ints ``1:7`` or labels ``'a':'f'``
+- A boolean array
 
-A chained comparison would also work in this situation, yielding slightly
-cleaner syntax
+We'll illustrate all of these methods. First, note that this provides a concise
+way of reindexing on multiple axes at once:
 
 .. ipython:: python
 
-   expr = 'a < b < c'
-   map(lambda frame: frame.query(expr), [df, df2])
-
-One neat feature of :meth:`~pandas.DataFrame.query` is that you can pass an
-expression ``expr`` into ``df[]``, e.g., ``df[expr]``.
+   subindex = dates[[3,4,5]]
+   df.reindex(index=subindex, columns=['C', 'B'])
+   df.ix[subindex, ['C', 'B']]
 
-This functionality can of course be combined with a slightly modified and more
-readable Python syntax implemented in the workhorse function that underlies
-:meth:`~pandas.DataFrame.query`--:func:`~pandas.eval`.
+Assignment / setting values is possible when using ``ix``:
 
+.. ipython:: python
 
-:meth:`~pandas.DataFrame.query` Python versus pandas Syntax Comparison
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+   df2 = df.copy()
+   df2.ix[subindex, ['C', 'B']] = 0
+   df2
 
-Full numpy-like syntax
+Indexing with an array of integers can also be done:
 
 .. ipython:: python
 
-   df = DataFrame(randint(n / 2, size=(n, 3)), columns=list('abc'))
-   df
-   df['(a < b) & (b < c)']
-   df[(df.a < df.b) & (df.b < df.c)]
+   df.ix[[4,3,1]]
+   df.ix[dates[[4,3,1]]]
 
-Slightly nicer by removing the parentheses
+**Slicing** has standard Python semantics for integer slices:
 
 .. ipython:: python
 
-   df['a < b & b < c']
+   df.ix[1:7, :2]
 
-Use English instead of symbols
+Slicing with labels is semantically slightly different because the slice start
+and stop are **inclusive** in the label-based case:
 
 .. ipython:: python
 
-   df['a < b and b < c']
+   date1, date2 = dates[[2, 4]]
+   print date1, date2
+   df.ix[date1:date2]
+   df['A'].ix[date1:date2]
 
-Pretty close to how you might write it on paper
+Getting and setting rows in a DataFrame, especially by their location, is much
+easier:
 
 .. ipython:: python
 
-   df['a < b < c']
-
-The ``in`` and ``not in`` operators
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+   df2 = df[:5].copy()
+   df2.ix[3]
+   df2.ix[3] = np.arange(len(df2.columns))
+   df2
 
-:meth:`~pandas.DataFrame.query` also supports special use of Python's ``in`` and
-``not in`` comparison operators, providing a succint syntax for calling the
-``isin`` method of a ``Series`` or ``DataFrame``.
+Column or row selection can be combined as you would expect with arrays of
+labels or even boolean vectors:
 
 .. ipython:: python
-   :suppress:
 
-   old_d = d
-   del d
-
-.. ipython:: python
+   df.ix[df['A'] > 0, 'B']
+   df.ix[date1:date2, 'B']
+   df.ix[date1, 'B']
 
-   # get all rows where columns "a" and "b" have overlapping values
-   df = DataFrame({'a': list('aabbccddeeff'), 'b': list('aaaabbbbcccc'),
-                   'c': randint(5, size=12), 'd': randint(9, size=12)})
-   df
-   df['a in b']
+Slicing with labels is closely related to the ``truncate`` method which does
+precisely ``.ix[start:stop]`` but returns a copy (for legacy reasons).
 
-   # How you'd do it in pure Python
-   df[df.a.isin(df.b)]
+The :meth:`~pandas.DataFrame.select` Method
+-------------------------------------------
 
-   df['a not in b']
+Another way to extract slices from an object is with the ``select`` method of
+Series, DataFrame, and Panel. This method should be used only when there is no
+more direct way.  ``select`` takes a function which operates on labels along
+``axis`` and returns a boolean.  For instance:
 
-   # pure Python
-   df[~df.a.isin(df.b)]
+.. ipython:: python
 
+   df.select(lambda x: x == 'A', axis=1)
 
-You can, of course, combine this with other expressions for very succinct
-queries:
+The :meth:`~pandas.DataFrame.lookup` Method
+-------------------------------------------
 
+Sometimes you want to extract a set of values given a sequence of row labels
+and column labels, and the ``lookup`` method allows for this and returns a
+numpy array.  For instance,
 
 .. ipython:: python
 
-   # rows where cols a and b have overlapping values and col c's values are less than col d's
-   df['a in b and c < d']
+  dflookup = DataFrame(np.random.rand(20,4), columns = ['A','B','C','D'])
+  dflookup.lookup(list(range(0,10,2)), ['B','C','A','B','D'])
 
-   # pure Python
-   df[df.b.isin(df.a) & (df.c < df.d)]
+Setting values in mixed-type DataFrame
+--------------------------------------
 
+.. _indexing.mixed_type_setting:
 
-.. note::
+Setting values on a mixed-type DataFrame or Panel is supported when using
+scalar values, though setting arbitrary vectors is not yet supported:
 
-   Note that ``in`` and ``not in`` are evaluated in Python, since ``numexpr``
-   has no equivalent of this operation. However, **only the** ``in``/``not in``
-   **expression itself** is evaluated in vanilla Python. For example, in the
-   expression
+.. ipython:: python
 
-       .. code-block:: python
+   df2 = df[:4]
+   df2['foo'] = 'bar'
+   print df2
+   df2.ix[2] = np.nan
+   print df2
+   print df2.dtypes
 
-          df['a in b + c + d']
+.. _indexing.view_versus_copy:
 
-   ``(b + c + d)`` is evaluated by ``numexpr`` and *then* the ``in``
-   operation is evaluated in plain Python. In general, any operations that can
-   be evaluated using ``numexpr`` will be.
+Returning a view versus a copy
+------------------------------
 
-Special use of the ``==`` operator with ``list`` objects
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+The rules about when a view on the data is returned are entirely dependent on
+NumPy. Whenever an array of labels or a boolean vector are involved in the
+indexing operation, the result will be a copy. With single label / scalar
+indexing and slicing, e.g. ``df.ix[3:6]`` or ``df.ix[:, 'A']``, a view will be
+returned.
 
-Comparing a ``list`` of values to a column using ``==``/``!=`` works similarly
-to ``in``/``not in``
+In chained expressions, the order may determine whether a copy is returned or not:
 
 .. ipython:: python
 
-   df['b == ["a", "b", "c"]']
 
-   # pure Python
-   df[df.b.isin(["a", "b", "c"])]
+   dfb = DataFrame({'a' : ['one', 'one', 'two',
+                           'three', 'two', 'one', 'six'],
+                    'b' : ['x', 'y', 'y',
+                           'x', 'y', 'x', 'x'],
+                    'c' : randn(7)})
 
-   df['c == [1, 2]']
 
-   df['c != [1, 2]']
+   # goes to copy (will be lost)
+   dfb[dfb.a.str.startswith('o')]['c'] = 42
 
-   # using in/not in
-   df['[1, 2] in c']
+   # passed via reference (will stay)
+   dfb['c'][dfb.a.str.startswith('o')] = 42
 
-   df['[1, 2] not in c']
+A chained assignment can also crop up in setting in a mixed dtype frame.
 
-   # pure Python
-   df[df.c.isin([1, 2])]
+.. note::
 
+   These setting rules apply to all of ``.loc/.iloc/.ix``
 
-Boolean Operators
-~~~~~~~~~~~~~~~~~
+This is the correct access method
 
-You can negate boolean expressions with the word ``not`` or the ``~`` operator.
+.. ipython:: python
+
+   dfc = DataFrame({'A':['aaa','bbb','ccc'],'B':[1,2,3]})
+   dfc_copy = dfc.copy()
+   dfc_copy.loc[0,'A'] = 11
+   dfc_copy
+
+This *can* work at times, but is not guaranteed, and so should be avoided
 
 .. ipython:: python
 
-   df = DataFrame(rand(n, 3), columns=list('abc'))
-   df['bools'] = rand(len(df)) > 0.5
-   df['~bools']
-   df['not bools']
-   df['not bools'] == df['~bools']
-   df['not bools'] == df[~df.bools]
+   dfc_copy = dfc.copy()
+   dfc_copy['A'][0] = 111
+   dfc_copy
 
-Of course, expressions can be arbitrarily complex too
+This will **not** work at all, and so should be avoided
 
 .. ipython:: python
 
-   # short query syntax
-   shorter = df['a < b < c and (not bools) or bools > 2']
+   dfc_copy = dfc.copy()
+   dfc_copy.loc[0]['A'] = 1111
+   dfc_copy
 
-   # equivalent in pure Python
-   longer = df[(df.a < df.b) & (df.b < df.c) & (~df.bools) | (df.bools > 2)]
+When assigning values to subsets of your data, thus, make sure to either use the
+pandas access methods or explicitly handle the assignment creating a copy.
 
-   shorter
-   longer
+Fallback indexing
+-----------------
 
-   shorter == longer
+.. _indexing.fallback:
 
-.. ipython:: python
-   :suppress:
+Float indexes should be used only with caution. If you have a float indexed
+``DataFrame`` and try to select using an integer, the row that Pandas returns
+might not be what you expect. Pandas first attempts to use the *integer*
+as a *label* location, but fails to find a match (because the types
+are not equal). Pandas then falls back to back to positional indexing.
 
-   d = old_d
-   del old_d
+.. ipython:: python
 
+    df = pd.DataFrame(np.random.randn(4,4),
+        columns=list('ABCD'), index=[1.0, 2.0, 3.0, 4.0])
+    df
+    df.ix[1]
 
-Perfomance of ``DataFrame.query()``
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+To select the row you do expect, instead use a float label or
+use ``iloc``.
 
-``DataFrame.query()`` using ``numexpr`` is slightly faster than Python for
-large frames
+.. ipython:: python
 
-.. image:: _static/query-perf.png
+    df.ix[1.0]
+    df.iloc[0]
 
-.. note::
+Instead of using a float index, it is often better to
+convert to an integer index:
 
-   You will only see the performance benefits of using the ``numexpr`` engine
-   with ``DataFrame.query()`` if your frame has more than approximately 50,000
-   rows
+.. ipython:: python
 
-      .. image:: _static/query-perf-small.png
+    df_new = df.reset_index()
+    df_new[df_new['index'] == 1.0]
+    # now you can also do "float selection"
+    df_new[(df_new['index'] >= 1.0) & (df_new['index'] < 2)]
 
-This plot was created using a ``DataFrame`` with 3 columns each containing
-floating point values generated using ``numpy.random.randn()``.
 
 .. _indexing.class:
 
@@ -1361,8 +1375,8 @@ operators:
    a & b
    a - b
 
-``isin`` method of Index objects
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+The ``isin`` method of Index objects
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 One additional operation is the ``isin`` method that works analogously to the
 ``Series.isin`` method found :ref:`here <indexing.boolean>`.
@@ -1567,7 +1581,7 @@ mailing list.
 .. _indexing.xs:
 
 Cross-section with hierarchical index
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 The ``xs`` method of ``DataFrame`` additionally takes a level argument to make
 selecting data at a particular level of a MultiIndex easier.
@@ -1599,8 +1613,8 @@ instance:
    print df2_aligned
 
 
-The need for sortedness
-~~~~~~~~~~~~~~~~~~~~~~~
+The need for sortedness with :class:`~pandas.MultiIndex`
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 **Caveat emptor**: the present implementation of ``MultiIndex`` requires that
 the labels be sorted for some of the slicing / indexing routines to work
@@ -1672,8 +1686,8 @@ However:
         ...
    KeyError: Key length (3) was greater than MultiIndex lexsort depth (2)
 
-Swapping levels with ``swaplevel``
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+Swapping levels with :meth:`~pandas.MultiIndex.swaplevel`
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 The ``swaplevel`` function can switch the order of two levels:
 
@@ -1684,8 +1698,8 @@ The ``swaplevel`` function can switch the order of two levels:
 
 .. _indexing.reorderlevels:
 
-Reordering levels with ``reorder_levels``
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+Reordering levels with :meth:`~pandas.MultiIndex.reorder_levels`
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 The ``reorder_levels`` function generalizes the ``swaplevel`` function,
 allowing you to permute the hierarchical index levels in one step:
@@ -1717,7 +1731,7 @@ if you compute the levels and labels yourself, please be careful.
 
 
 Setting index metadata (``name(s)``, ``levels``, ``labels``)
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+------------------------------------------------------------
 
 .. _indexing.set_metadata:
 
@@ -1746,7 +1760,7 @@ add an index after you've already done so. There are a couple of different
 ways.
 
 Add an index using DataFrame columns
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+------------------------------------
 
 .. _indexing.set_index:
 
@@ -1789,7 +1803,7 @@ the index in-place (without creating a new object):
    data
 
 Remove / reset the index,  ``reset_index``
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+------------------------------------------
 
 As a convenience, there is a new function on DataFrame called ``reset_index``
 which transfers the index values into the DataFrame's columns and sets a simple
@@ -1820,7 +1834,7 @@ discards the index, instead of putting index values in the DataFrame's columns.
    deprecated.
 
 Adding an ad hoc index
-~~~~~~~~~~~~~~~~~~~~~~
+----------------------
 
 If you create an index yourself, you can just assign it to the ``index`` field:
 
@@ -1833,9 +1847,9 @@ Indexing internal details
 
 .. note::
 
-    The following is largely relevant for those actually working on the pandas
-    codebase. And the source code is still the best place to look at the
-    specifics of how things are implemented.
+   The following is largely relevant for those actually working on the pandas
+   codebase. The source code is still the best place to look at the specifics
+   of how things are implemented.
 
 In pandas there are a few objects implemented which can serve as valid
 containers for the axis labels:
@@ -1847,6 +1861,8 @@ containers for the axis labels:
   - ``Int64Index``: a version of ``Index`` highly optimized for 64-bit integer
     data, such as time stamps
   - ``MultiIndex``: the standard hierarchical index object
+  - ``PeriodIndex``: An Index object with Period elements
+  - ``DatetimeIndex``: An Index object with Timestamp elements
   - ``date_range``: fixed frequency date range generated from a time rule or
     DateOffset. An ndarray of Python datetime objects
 
diff --git a/doc/source/release.rst b/doc/source/release.rst
index 0ed1f39d7..b8a817a00 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -294,7 +294,15 @@ See :ref:`Internal Refactoring<whatsnew_0130.refactoring>`
 Experimental Features
 ~~~~~~~~~~~~~~~~~~~~~
 
-.. _release:bug_fixes-0.13.0:
+- The new :func:`~pandas.eval` function implements expression evaluation using
+  ``numexpr`` behind the scenes. This results in large speedups for complicated
+  expressions involving large DataFrames/Series.
+- :class:`~pandas.DataFrame` has a new :meth:`~pandas.DataFrame.eval` that
+  evaluates an expression in the context of the ``DataFrame``.
+- A :meth:`~pandas.DataFrame.query` method has been added that allows
+  you to select elements of a ``DataFrame`` using a natural query syntax nearly
+  identical to Python syntax.
+
 
 Bug Fixes
 ~~~~~~~~~
diff --git a/doc/source/v0.13.0.txt b/doc/source/v0.13.0.txt
index 4f43cd5e0..694281b81 100644
--- a/doc/source/v0.13.0.txt
+++ b/doc/source/v0.13.0.txt
@@ -362,10 +362,10 @@ Enhancements
   - DataFrame constructor now accepts a numpy masked record array (:issue:`3478`)
 
 
-.. _whatsnew_0130.enhancingperf:
+.. _whatsnew_0130.experimental:
 
-Performance Enhancments
-~~~~~~~~~~~~~~~~~~~~~~~
+Experimental
+~~~~~~~~~~~~
 
 - :func:`~pandas.eval`:
 
@@ -439,7 +439,7 @@ Performance Enhancments
 
          n = 20
          df = DataFrame(randint(n, size=(n, 3)), columns=['a', 'b', 'c'])
-         df['a < b < c']
+         df.query('a < b < c')
 
     selects all the rows of ``df`` where ``a < b < c`` evaluates to ``True``.
     For more details see the :ref:`indexing documentation on query
diff --git a/pandas/computation/pytables.py b/pandas/computation/pytables.py
index 753613e5c..9ffae5edd 100644
--- a/pandas/computation/pytables.py
+++ b/pandas/computation/pytables.py
@@ -571,5 +571,3 @@ def maybe_expression(s):
 
     # make sure we have an op at least
     return any(op in s for op in ops)
-
-
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 0f6323aef..4a1155abf 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1927,7 +1927,9 @@ class DataFrame(NDFrame):
         ----------
         expr : string
             The query string to evaluate. The result of the evaluation of this
-            expression is passed to
+            expression is first passed to :attr:`~pandas.DataFrame.loc` and if
+            that fails because of a multidimensional key (e.g., a DataFrame)
+            then the result will be passed to
             :meth:`~pandas.DataFrame.__getitem__`.
         kwargs : dict
             See the documentation for :func:`~pandas.eval` for complete details

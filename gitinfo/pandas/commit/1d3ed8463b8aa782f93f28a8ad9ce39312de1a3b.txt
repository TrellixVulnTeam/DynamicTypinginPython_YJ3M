commit 1d3ed8463b8aa782f93f28a8ad9ce39312de1a3b
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Apr 26 14:46:10 2012 -0400

    ENH: frequency inference and tests, close #391

diff --git a/RELEASE.rst b/RELEASE.rst
index e717a1152..6a34fc4f5 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -29,6 +29,8 @@ pandas 0.8.0
 
   - Add GroupBy.prod optimized aggregation function and 'prod' fast time series
     conversion method (#1018)
+  - Implement robust frequency inference function and `inferred_freq` attribute
+    on DatetimeIndex (#391)
 
 **Improvements to existing features**
 
diff --git a/pandas/core/algorithms.py b/pandas/core/algorithms.py
index 15232e2bd..4aec37144 100644
--- a/pandas/core/algorithms.py
+++ b/pandas/core/algorithms.py
@@ -5,7 +5,6 @@ intended for public consumption
 
 import numpy as np
 
-from pandas.core.series import Series
 import pandas.core.common as com
 import pandas._tseries as lib
 
@@ -26,6 +25,12 @@ def match(values, index):
 def unique(values):
     """
 
+    Parameters
+    ----------
+
+    Returns
+    -------
+
     """
     f = lambda htype, caster: _unique_generic(values, htype, caster)
     return _hashtable_algo(f, values.dtype)
@@ -52,6 +57,8 @@ def _hashtable_algo(f, dtype):
 
 
 def _count_generic(values, table_type, type_caster):
+    from pandas.core.series import Series
+
     values = type_caster(values)
     table = table_type(len(values))
     uniques, labels, counts = table.factorize(values)
@@ -113,6 +120,7 @@ def value_counts(values, sort=True, ascending=False):
     -------
     value_counts : Series
     """
+    from pandas.core.series import Series
     from collections import defaultdict
     if com.is_integer_dtype(values.dtype):
         values = com._ensure_int64(values)
diff --git a/pandas/tests/test_datetools.py b/pandas/tests/test_datetools.py
index 58730ba6a..26f178279 100644
--- a/pandas/tests/test_datetools.py
+++ b/pandas/tests/test_datetools.py
@@ -220,9 +220,9 @@ class TestBusinessDay(unittest.TestCase):
                        datetime(2008, 1, 6): datetime(2008, 1, 7),
                        datetime(2008, 1, 7): datetime(2008, 1, 7)}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
     def test_apply_corner(self):
         self.assertRaises(Exception, BDay().apply, BMonthEnd())
@@ -277,9 +277,9 @@ class TestWeek(unittest.TestCase):
                        datetime(2010, 4, 8): datetime(2010, 3, 30),
                        datetime(2010, 4, 5): datetime(2010, 3, 23)}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
     def test_onOffset(self):
         for weekday in range(7):
@@ -414,9 +414,9 @@ class TestBMonthBegin(unittest.TestCase):
                       datetime(2006, 12, 30): datetime(2006, 12, 1),
                       datetime(2007, 1, 1): datetime(2006, 12, 1)}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
     def test_onOffset(self):
 
@@ -470,9 +470,9 @@ class TestBMonthEnd(unittest.TestCase):
                       datetime(2006, 12, 30): datetime(2006, 12, 29),
                       datetime(2007, 1, 1): datetime(2006, 12, 29)}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
     def test_onOffset(self):
 
@@ -523,9 +523,9 @@ class TestMonthBegin(unittest.TestCase):
                       datetime(2006, 12, 29): datetime(2006, 12, 1),
                       datetime(2006, 1, 2): datetime(2006, 1, 1)}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
 class TestMonthEnd(unittest.TestCase):
 
@@ -563,9 +563,9 @@ class TestMonthEnd(unittest.TestCase):
                       datetime(2006, 12, 30): datetime(2006, 11, 30),
                       datetime(2007, 1, 1): datetime(2006, 12, 31)}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
     def test_onOffset(self):
 
@@ -651,9 +651,9 @@ class TestBQuarterBegin(unittest.TestCase):
                        datetime(2007, 4, 15): datetime(2007, 10, 1),
                        datetime(2008, 4, 30): datetime(2008, 10, 1),}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
         # corner
         offset = BQuarterBegin(n=-1, startingMonth=1)
@@ -718,9 +718,9 @@ class TestBQuarterEnd(unittest.TestCase):
                        datetime(2008, 4, 15): datetime(2008, 7, 31),
                        datetime(2008, 4, 30): datetime(2008, 10, 31),}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
         # corner
         offset = BQuarterEnd(n=-1, startingMonth=1)
@@ -822,9 +822,9 @@ class TestQuarterBegin(unittest.TestCase):
                        datetime(2008, 4, 15): datetime(2008, 10, 1),
                        datetime(2008, 4, 1): datetime(2008, 10, 1),}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
         # corner
         offset = QuarterBegin(n=-1, startingMonth=1)
@@ -890,9 +890,9 @@ class TestQuarterEnd(unittest.TestCase):
                        datetime(2008, 4, 15): datetime(2008, 7, 31),
                        datetime(2008, 4, 30): datetime(2008, 10, 31),}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
         # corner
         offset = QuarterEnd(n=-1, startingMonth=1)
@@ -974,9 +974,9 @@ class TestBYearBegin(unittest.TestCase):
                        datetime(2007, 6, 30): datetime(2006, 1, 2),
                        datetime(2008, 12, 31): datetime(2007, 1, 1),}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
 
 class TestYearBegin(unittest.TestCase):
@@ -1012,9 +1012,9 @@ class TestYearBegin(unittest.TestCase):
                        datetime(2008, 6, 30): datetime(2007, 1, 1),
                        datetime(2008, 12, 31): datetime(2007, 1, 1),}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
 
     def test_onOffset(self):
@@ -1048,9 +1048,9 @@ class TestBYearEndLagged(unittest.TestCase):
                       datetime(2007, 6, 30): datetime(2007, 6, 29)},
                       ))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                self.assertEqual(baseDate + dateOffset, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                self.assertEqual(base + offset, expected)
 
     def test_roll(self):
         offset = BYearEnd(month=6)
@@ -1100,9 +1100,9 @@ class TestBYearEnd(unittest.TestCase):
                        datetime(2008, 6, 30): datetime(2006, 12, 29),
                        datetime(2008, 12, 31): datetime(2006, 12, 29),}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
     def test_onOffset(self):
 
@@ -1147,9 +1147,9 @@ class TestYearEnd(unittest.TestCase):
                        datetime(2008, 6, 30): datetime(2006, 12, 31),
                        datetime(2008, 12, 31): datetime(2006, 12, 31),}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
     def test_onOffset(self):
 
@@ -1191,12 +1191,12 @@ class TestYearEndDiffMonth(unittest.TestCase):
 
         tests.append((YearEnd(-2, month=3),
                       {datetime(2007, 1, 1): datetime(2005, 3, 31),
-                       datetime(2008, 6, 30): datetime(2006, 3, 31),
+                       datetime(2008, 6, 30): datetime(2007, 3, 31),
                        datetime(2008, 3, 31): datetime(2006, 3, 31),}))
 
-        for dateOffset, cases in tests:
-            for baseDate, expected in cases.iteritems():
-                assertEq(dateOffset, baseDate, expected)
+        for offset, cases in tests:
+            for base, expected in cases.iteritems():
+                assertEq(offset, base, expected)
 
     def test_onOffset(self):
 
@@ -1210,14 +1210,14 @@ class TestYearEndDiffMonth(unittest.TestCase):
         for offset, date, expected in tests:
             assertOnOffset(offset, date, expected)
 
-def assertEq(dateOffset, baseDate, expected):
-    actual = dateOffset + baseDate
+def assertEq(offset, base, expected):
+    actual = offset + base
     try:
         assert actual == expected
     except AssertionError as err:
         raise AssertionError("\nExpected: %s\nActual: %s\nFor Offset: %s)"
                              "\nAt Date: %s"%
-                (expected, actual, dateOffset, baseDate))
+                (expected, actual, offset, base))
 
 def test_Hour():
     assertEq(Hour(), datetime(2010, 1, 1), datetime(2010, 1, 1, 1))
@@ -1249,25 +1249,6 @@ def test_Second():
     assert (Second(3) + Second(2)) == Second(5)
     assert (Second(3) - Second(2)) == Second()
 
-def test_inferTimeRule():
-    index1 = [datetime(2010, 1, 29, 0, 0),
-              datetime(2010, 2, 26, 0, 0),
-              datetime(2010, 3, 31, 0, 0)]
-
-    index2 = [datetime(2010, 3, 26, 0, 0),
-              datetime(2010, 3, 29, 0, 0),
-              datetime(2010, 3, 30, 0, 0)]
-
-    index3 = [datetime(2010, 3, 26, 0, 0),
-              datetime(2010, 3, 27, 0, 0),
-              datetime(2010, 3, 29, 0, 0)]
-
-    assert inferTimeRule(index1) == 'BM'
-    assert inferTimeRule(index2) == 'B'
-
-    assert_raises(Exception, inferTimeRule, index1[:2])
-    assert_raises(Exception, inferTimeRule, index3)
-
 def test_hasOffsetName():
     assert hasOffsetName(BDay())
     assert not hasOffsetName(BDay(2))
diff --git a/pandas/tseries/frequencies.py b/pandas/tseries/frequencies.py
index b676bd3e8..51b5ad796 100644
--- a/pandas/tseries/frequencies.py
+++ b/pandas/tseries/frequencies.py
@@ -1,8 +1,11 @@
+from datetime import datetime
+
 import re
 
 from pandas.tseries.offsets import DateOffset
-from pandas._tseries import Timestamp
+from pandas.util.decorators import cache_readonly
 import pandas.tseries.offsets as offsets
+import pandas._tseries as lib
 
 
 def get_freq_code(freqstr):
@@ -272,19 +275,17 @@ for name, offset in _offset_map.iteritems():
 
 
 def inferTimeRule(index):
-    if len(index) < 3:
-        raise Exception('Need at least three dates to infer time rule!')
-
-    first, second, third = index[:3]
-    items = _offset_map.iteritems()
+    from pandas.tseries.index import DatetimeIndex
+    import warnings
+    warnings.warn("This method is deprecated, use infer_freq or inferred_freq"
+                  " attribute of DatetimeIndex", FutureWarning)
 
-    for rule, offset in items:
-        if offset is None:
-            continue
-        if (first + offset) == second and (second + offset) == third:
-            return rule
+    freq = DatetimeIndex(index).inferred_freq
+    if freq is None:
+        raise Exception('Unable to infer time rule')
 
-    raise Exception('Could not infer time rule from data!')
+    offset = to_offset(freq)
+    return get_legacy_offset_name(offset)
 
 
 def to_offset(freqstr):
@@ -618,105 +619,194 @@ def _period_str_to_code(freqstr):
             raise "Could not interpret frequency %s" % freqstr
 
 
-def infer_freq(index):
+
+def infer_freq(index, warn=True):
+    """
+    Infer the most likely frequency given the input index. If the frequency is
+    uncertain, a warning will be printed
+
+    Parameters
+    ----------
+    index : DatetimeIndex
+
+    Returns
+    -------
+    freq : string or None
+        None if no discernable frequency
+    """
+
+    inferer = _FrequencyInferer(index, warn=warn)
+    return inferer.get_freq()
+
+
+class _FrequencyInferer(object):
     """
     Not sure if I can avoid the state machine here
     """
-    from pandas._sandbox import unique_deltas
 
-    if len(index) < 3:
-        raise ValueError('Need at least 3 dates to infer frequency')
+    def __init__(self, index, warn=True):
+        self.index = index
+        self.values = index.asi8
+        self.warn = warn
 
-    deltas = unique_deltas(index)
+        if len(index) < 3:
+            raise ValueError('Need at least 3 dates to infer frequency')
 
-    is_unique = len(deltas) == 1
+        self.deltas = lib.unique_deltas(self.values)
+        self.is_unique = len(self.deltas) == 1
 
-    if _is_multiple(deltas[0], _day_us):
-        if is_unique:
-            days = deltas[0] / _day_us
-            if days % 7 == 0:
-                # Weekly
-                alias = _weekday_rule_aliases[days]
-                return _maybe_add_count('W-%s' % alias, days / 7)
+    def get_freq(self):
+        if not self.index.is_monotonic:
+            return None
+
+        delta = self.deltas[0]
+        if _is_multiple(delta, _day_us):
+            return self._infer_daily_rule()
+        else:
+            # Possibly intraday frequency
+            if not self.is_unique:
+                return None
+            if _is_multiple(delta, 60 * 60 * 1000000):
+                # Hours
+                return _maybe_add_count('H', delta / (60 * 60 * 1000000))
+            elif _is_multiple(delta, 60 * 1000000):
+                # Minutes
+                return _maybe_add_count('T', delta / (60 * 1000000))
+            elif _is_multiple(delta, 1000000):
+                # Seconds
+                return _maybe_add_count('S', delta / 1000000)
+            elif _is_multiple(delta, 1000):
+                # Milliseconds
+                return _maybe_add_count('L', delta / 1000)
             else:
-                return _maybe_add_count('D', days)
+                # Microseconds
+                return _maybe_add_count('U', delta)
+
+    @cache_readonly
+    def day_deltas(self):
+        return [x / _day_us for x in self.deltas]
+
+    @cache_readonly
+    def fields(self):
+        return lib.build_field_sarray(self.values)
+
+    @cache_readonly
+    def rep_stamp(self):
+        return lib.Timestamp(self.values[0])
+
+    def month_position_check(self):
+        # TODO: cythonize this, very slow
+        calendar_end = True
+        business_end = True
+        calendar_start = True
+        business_start = True
+
+        years = self.fields['Y']
+        months = self.fields['M']
+        days = self.fields['D']
+        weekdays = self.index.dayofweek
+
+        from calendar import monthrange
+        for y, m, d, wd in zip(years, months, days, weekdays):
+            wd = datetime(y, m, d).weekday()
+
+            if calendar_start:
+                calendar_start &= d == 1
+            if business_start:
+                business_start &= d == 1 or (d < 3 and wd == 0)
+
+            _, daysinmonth = monthrange(y, m)
+            cal = d == daysinmonth
+            if calendar_end:
+                calendar_end &= cal
+            if business_end:
+                business_end &= cal or (daysinmonth - d < 3 and wd == 4)
+
+        if calendar_end:
+            return 'ce'
+        elif business_end:
+            return 'be'
+        elif calendar_start:
+            return 'cs'
+        elif business_start:
+            return 'bs'
+        else:
+            return None
 
-        fields = lib.build_field_sarray(index)
+    @cache_readonly
+    def mdiffs(self):
+        nmonths = self.fields['Y'] * 12 + self.fields['M']
+        return lib.unique_deltas(nmonths.astype('i8'))
 
-        day_list = [x / _day_us for x in deltas]
-        rstamp = Timestamp(index[0])
+    @cache_readonly
+    def ydiffs(self):
+        return lib.unique_deltas(self.fields['Y'].astype('i8'))
 
-        annual_rule = _get_annual_rule(fields)
+    def _infer_daily_rule(self):
+        annual_rule = self._get_annual_rule()
         if annual_rule:
-            nyears = day_list[0] // 365
-            month = _month_aliases[rstamp.month]
+            nyears = self.ydiffs[0]
+            month = _month_aliases[self.rep_stamp.month]
             return _maybe_add_count('%s-%s' % (annual_rule, month), nyears)
 
-        quarterly_rule = _get_quarterly_rule(fields)
+        quarterly_rule = self._get_quarterly_rule()
         if quarterly_rule:
-            month = _month_aliases[rstamp.month]
-            return '%s-%s' % (quarterly_rule, month)
+            nquarters = self.mdiffs[0] / 3
+            month = _month_aliases[self.rep_stamp.month]
+            return _maybe_add_count('%s-%s' % (quarterly_rule, month),
+                                    nquarters)
 
-        elif _is_quarterly_deltas(day_list):
-            pass
-        elif _is_monthly_deltas(day_list):
-            pass
-        else:
-            # Business daily. Maybe
-            pass
+        monthly_rule = self._get_monthly_rule()
+        if monthly_rule:
+            return monthly_rule
 
-    elif _is_multiple(deltas[0], 60 * 60 * 1000000):
-        if not is_unique:
-            return None
-        # Hours
-        return '%dH' % (deltas[0] / (60 * 60 * 1000000))
-    elif _is_multiple(deltas[0], 60 * 1000000):
-        if not is_unique:
-            return None
-        # Minutes
-        return '%dT' % (deltas[0] / (60 * 1000000))
-    elif _is_multiple(deltas[0], 1000000):
-        if not is_unique:
-            return None
-        # Seconds
-        return '%dS' % (deltas[0] / 1000000)
-    elif _is_multiple(deltas[0], 1000):
-        if not is_unique:
-            return None
-        # Milliseconds
-        return '%dL' % (deltas[0] / 1000)
-    else:
-        if not is_unique:
-            return None
-        # Microseconds
-        return '%dU' % deltas[0]
+        if self.is_unique:
+            days = self.deltas[0] / _day_us
+            if days % 7 == 0:
+                # Weekly
+                alias = _weekday_rule_aliases[self.rep_stamp.weekday()]
+                return _maybe_add_count('W-%s' % alias, days / 7)
+            else:
+                return _maybe_add_count('D', days)
 
+        # Business daily. Maybe
+        if self.day_deltas == [1, 3]:
+            return 'B'
 
-import pandas.core.algorithms as algos
+    def _get_annual_rule(self):
+        if len(self.ydiffs) > 1:
+            return None
 
+        if len(algos.unique(self.fields['M'])) > 1:
+            return None
 
-def _get_annual_rule(fields):
-    years = fields['Y']
-    months = fields['M']
-    days = fields['D']
+        pos_check = self.month_position_check()
+        return {'cs': 'AS', 'bs': 'BAS',
+                'ce': 'A', 'be': 'BA'}.get(pos_check)
 
-    ydiffs = unique_deltas(years.astype('i8'))
-    if len(ydiffs) > 1:
-        return False
+    def _get_quarterly_rule(self):
+        if len(self.mdiffs) > 1:
+            return None
 
-    if len(algos.unique(months)) == 1:
-        if _all_last_weekday(years, months, days):
-            return
+        if not self.mdiffs[0] % 3 == 0:
+            return None
 
+        pos_check = self.month_position_check()
+        return {'cs': 'QS', 'bs': 'BQS',
+                'ce': 'Q', 'be': 'BQ'}.get(pos_check)
 
-def _is_quarterly_deltas(day_list):
-    pass
+    def _get_monthly_rule(self):
+        if len(self.mdiffs) > 1:
+            return None
+        pos_check = self.month_position_check()
+        return {'cs': 'MS', 'bs': 'BMS',
+                'ce': 'M', 'be': 'BM'}.get(pos_check)
 
-def _is_monthly_deltas(day_list):
-    pass
 
-def _is_business_years(index):
-    pass
+def _is_weekday(y, m, d):
+    return datetime(y, m, d).weekday() < 5
+
+import pandas.core.algorithms as algos
 
 def _maybe_add_count(base, count):
     if count > 1:
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index a54c95f03..1cae0a8e9 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -842,7 +842,7 @@ class DatetimeIndex(Int64Index):
 
     @cache_readonly
     def inferred_freq(self):
-        return infer_freq(self.asi8)
+        return infer_freq(self)
 
     @property
     def freqstr(self):
diff --git a/pandas/tseries/offsets.py b/pandas/tseries/offsets.py
index 260e95b5e..76a85c495 100644
--- a/pandas/tseries/offsets.py
+++ b/pandas/tseries/offsets.py
@@ -827,16 +827,49 @@ class YearEnd(DateOffset, CacheableOffset):
         DateOffset.__init__(self, n=n, **kwds)
 
     def apply(self, other):
+        def _increment(date):
+            if date.month == self.month:
+                _, days_in_month = lib.monthrange(date.year, self.month)
+                if date.day != days_in_month:
+                    year = date.year
+                else:
+                    year = date.year + 1
+            elif date.month < self.month:
+                year = date.year
+            else:
+                year = date.year + 1
+            _, days_in_month = lib.monthrange(year, self.month)
+            return datetime(year, self.month, days_in_month,
+                            date.hour, date.minute, date.second,
+                            date.microsecond)
+        def _decrement(date):
+            year = date.year if date.month > self.month else date.year - 1
+            _, days_in_month = lib.monthrange(year, self.month)
+            return datetime(year, self.month, days_in_month,
+                            date.hour, date.minute, date.second,
+                            date.microsecond)
+
+        def _rollf(date):
+            if (date.month != self.month or
+                date.day < lib.monthrange(date.year, date.month)[1]):
+                date = _increment(date)
+            return date
+
         n = self.n
-        wkday, days_in_month = lib.monthrange(other.year, self.month)
-        if other.month != self.month or other.day != days_in_month:
-            other = datetime(other.year - 1, self.month, days_in_month,
-                             other.hour, other.minute, other.second,
-                             other.microsecond)
-            if n <= 0:
-                n = n + 1
-        other = other + relativedelta(years=n)
-        return other
+        result = other
+        if n > 0:
+            while n > 0:
+                result = _increment(result)
+                n -= 1
+        elif n < 0:
+            while n < 0:
+                result = _decrement(result)
+                n += 1
+        else:
+            # n == 0, roll forward
+            result = _rollf(result)
+
+        return result
 
     def onOffset(self, dt):
         wkday, days_in_month = lib.monthrange(dt.year, self.month)
diff --git a/pandas/tseries/tests/test_frequencies.py b/pandas/tseries/tests/test_frequencies.py
index 439225088..cc43efd5f 100644
--- a/pandas/tseries/tests/test_frequencies.py
+++ b/pandas/tseries/tests/test_frequencies.py
@@ -9,7 +9,7 @@ import numpy as np
 
 from pandas import Index, DatetimeIndex, date_range
 
-from pandas.tseries.frequencies import to_offset
+from pandas.tseries.frequencies import to_offset, infer_freq
 import pandas.tseries.offsets as offsets
 
 import pandas._tseries as lib
@@ -47,16 +47,20 @@ _dti = DatetimeIndex
 
 class TestFrequencyInference(unittest.TestCase):
 
+    def test_raise_if_too_few(self):
+        index = _dti(['12/31/1998', '1/3/1999'])
+        self.assertRaises(ValueError, infer_freq, index)
+
     def test_business_daily(self):
-        index = _dti(['12/31/1999', '1/3/1999', '1/4/1999'])
-        self.assert_(index.inferred_freq == 'B')
+        index = _dti(['12/31/1998', '1/3/1999', '1/4/1999'])
+        self.assert_(infer_freq(index) == 'B')
 
     def test_day(self):
         self._check_tick(timedelta(1), 'D')
 
     def test_day_corner(self):
         index = _dti(['1/1/2000', '1/2/2000', '1/3/2000'])
-        self.assert_(index.inferred_freq == 'D')
+        self.assert_(infer_freq(index) == 'D')
 
     def test_hour(self):
         self._check_tick(timedelta(hours=1), 'H')
@@ -78,15 +82,19 @@ class TestFrequencyInference(unittest.TestCase):
         for i in range(1, 5):
             inc = base_delta * i
             index = _dti([b + inc * j for j in range(3)])
-            self.assert_(index.inferred_freq == '%d%s' % (i, code))
+            if i > 1:
+                exp_freq = '%d%s' % (i, code)
+            else:
+                exp_freq = code
+            self.assert_(infer_freq(index) == exp_freq)
 
         index = _dti([b + base_delta * 7] +
                      [b + base_delta * j for j in range(3)])
-        self.assert_(index.inferred_freq is None)
+        self.assert_(infer_freq(index) is None)
 
         index = _dti([b + base_delta * j for j in range(3)] +
                      [b + base_delta * 7])
-        self.assert_(index.inferred_freq is None)
+        self.assert_(infer_freq(index) is None)
 
     def test_weekly(self):
         days = ['MON', 'TUE', 'WED', 'THU', 'FRI']
@@ -97,6 +105,10 @@ class TestFrequencyInference(unittest.TestCase):
     def test_monthly(self):
         self._check_generated_range('1/1/2000', 'M')
 
+    def test_monthly_ambiguous(self):
+        rng = _dti(['1/31/2000', '2/29/2000', '3/31/2000'])
+        self.assert_(rng.inferred_freq == 'M')
+
     def test_business_monthly(self):
         self._check_generated_range('1/1/2000', 'BM')
 
@@ -112,16 +124,20 @@ class TestFrequencyInference(unittest.TestCase):
         for month in MONTHS:
             self._check_generated_range('1/1/2000', 'BA-%s' % month)
 
+    def test_annual_ambiguous(self):
+        rng = _dti(['1/31/2000', '1/31/2001', '1/31/2002'])
+        self.assert_(rng.inferred_freq == 'A-JAN')
+
     def _check_generated_range(self, start, freq):
         freq = freq.upper()
 
-        gen = date_range(start, periods=3, freq=freq)
+        gen = date_range(start, periods=7, freq=freq)
         index = _dti(gen.values)
-        self.assert_(index.inferred_freq == gen.freq)
+        self.assert_(infer_freq(index) == gen.freqstr)
 
         gen = date_range(start, periods=5, freq=freq)
         index = _dti(gen.values)
-        self.assert_(index.inferred_freq == gen.freq)
+        self.assert_(infer_freq(index) == gen.freqstr)
 
 MONTHS = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP',
           'OCT', 'NOV', 'DEC']
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index bcff44179..77fd6da04 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -725,13 +725,35 @@ class TestLegacySupport(unittest.TestCase):
 
         self.assert_(result.index.equals(exp_index))
 
-class TestDateRangeCompat(unittest.TestCase):
+class TestLegacyCompat(unittest.TestCase):
 
     def setUp(self):
         from StringIO import StringIO
         # suppress deprecation warnings
         sys.stderr = StringIO()
 
+    def test_inferTimeRule(self):
+        from pandas.tseries.frequencies import inferTimeRule
+
+        index1 = [datetime(2010, 1, 29, 0, 0),
+                  datetime(2010, 2, 26, 0, 0),
+                  datetime(2010, 3, 31, 0, 0)]
+
+        index2 = [datetime(2010, 3, 26, 0, 0),
+                  datetime(2010, 3, 29, 0, 0),
+                  datetime(2010, 3, 30, 0, 0)]
+
+        index3 = [datetime(2010, 3, 26, 0, 0),
+                  datetime(2010, 3, 27, 0, 0),
+                  datetime(2010, 3, 29, 0, 0)]
+
+        # LEGACY
+        assert inferTimeRule(index1) == 'EOM'
+        assert inferTimeRule(index2) == 'WEEKDAY'
+
+        self.assertRaises(Exception, inferTimeRule, index1[:2])
+        self.assertRaises(Exception, inferTimeRule, index3)
+
     def test_time_rule(self):
         result = DateRange('1/1/2000', '1/30/2000', time_rule='WEEKDAY')
         result2 = DateRange('1/1/2000', '1/30/2000', timeRule='WEEKDAY')

commit 61aac3d0a98f748fd9fd4df9df0ef4bd8849f9b5
Author: Chang She <chang@lambdafoundry.com>
Date:   Wed Jun 27 12:50:48 2012 -0400

    ENH: datetime.time converters for plotting

diff --git a/pandas/src/datetime.pxd b/pandas/src/datetime.pxd
index 067c662e4..2147c2676 100644
--- a/pandas/src/datetime.pxd
+++ b/pandas/src/datetime.pxd
@@ -34,6 +34,7 @@ cdef extern from "datetime.h":
     int PyDateTime_TIME_GET_MICROSECOND(object o)
     bint PyDateTime_Check(object o)
     bint PyDate_Check(object o)
+    bint PyTime_Check(object o)
     object PyDateTime_FromDateAndTime(int year, int month, int day, int hour,
                                       int minute, int second, int us)
 
diff --git a/pandas/src/inference.pyx b/pandas/src/inference.pyx
index 451b998b0..4a4cac177 100644
--- a/pandas/src/inference.pyx
+++ b/pandas/src/inference.pyx
@@ -103,6 +103,9 @@ cdef inline bint is_datetime(object o):
 cdef inline bint is_date(object o):
     return PyDate_Check(o)
 
+cdef inline bint is_time(object o):
+    return PyTime_Check(o)
+
 def is_bool_array(ndarray values):
     cdef:
         Py_ssize_t i, n = len(values)
@@ -240,6 +243,14 @@ def is_date_array(ndarray[object] values):
             return False
     return True
 
+def is_time_array(ndarray[object] values):
+    cdef int i, n = len(values)
+    if n == 0:
+        return False
+    for i in range(n):
+        if not is_time(values[i]):
+            return False
+    return True
 
 def maybe_convert_numeric(ndarray[object] values, set na_values,
                           convert_empty=True):
diff --git a/pandas/tools/plotting.py b/pandas/tools/plotting.py
index e5ba885c8..5b96beba4 100644
--- a/pandas/tools/plotting.py
+++ b/pandas/tools/plotting.py
@@ -16,6 +16,12 @@ from pandas.tseries.offsets import DateOffset
 import pandas.tseries.tools as datetools
 import pandas.lib as lib
 
+try: # mpl optional
+    import pandas.tseries.converter as conv
+    conv.register()
+except ImportError:
+    pass
+
 def _get_standard_kind(kind):
     return {'density' : 'kde'}.get(kind, kind)
 
@@ -492,8 +498,9 @@ class MPLPlot(object):
 
     def _get_xticks(self, convert_period=False):
         index = self.data.index
-        is_datetype = index.inferred_type in ('datetime', 'date',
-                                              'datetime64')
+        is_datetype = (index.inferred_type in ('datetime', 'date',
+                                               'datetime64')
+                       or lib.is_time_array(index))
 
         if self.use_index:
             if convert_period and isinstance(index, PeriodIndex):
@@ -508,6 +515,7 @@ class MPLPlot(object):
                 """
                 x = index._mpl_repr()
             else:
+                foo
                 self._need_to_set_index = True
                 x = range(len(index))
         else:
@@ -578,40 +586,6 @@ class KdePlot(MPLPlot):
         if self.subplots and self.legend:
             self.axes[0].legend(loc='best')
 
-try: # matplotlib is optional dependency
-    import matplotlib.units as units
-    import matplotlib.dates as dates
-
-    class DatetimeConverter(dates.DateConverter):
-
-        @staticmethod
-        def convert(values, unit, axis):
-            def try_parse(values):
-                try:
-                    return datetools.to_datetime(values).toordinal()
-                except Exception:
-                    return values
-
-            if isinstance(values, (datetime.datetime, datetime.date)):
-                return values.toordinal()
-            elif isinstance(values, (datetime.time)):
-                return dates.date2num(values)
-            elif (com.is_integer(values) or com.is_float(values)):
-                return values
-            elif isinstance(values, str):
-                return try_parse(values)
-            elif isinstance(values, Index):
-                return values.map(try_parse)
-            elif isinstance(values, (list, tuple, np.ndarray)):
-                return [try_parse(x) for x in values]
-            return values
-
-    units.registry[lib.Timestamp] = DatetimeConverter()
-    units.registry[datetime.date] = DatetimeConverter()
-    units.registry[datetime.datetime] = DatetimeConverter()
-except ImportError:
-    pass
-
 class LinePlot(MPLPlot):
 
     def __init__(self, data, **kwargs):
diff --git a/pandas/tseries/converter.py b/pandas/tseries/converter.py
new file mode 100644
index 000000000..811d21ed1
--- /dev/null
+++ b/pandas/tseries/converter.py
@@ -0,0 +1,699 @@
+from datetime import datetime
+import datetime as pydt
+import numpy as np
+
+import matplotlib.units as units
+import matplotlib.dates as dates
+import matplotlib.cbook as cbook
+from matplotlib import pylab
+from matplotlib.ticker import Formatter, AutoLocator, Locator
+from matplotlib.transforms import nonsingular
+
+import pandas.lib as lib
+import pandas.core.common as com
+from pandas.core.index import Index
+
+import pandas.tseries.tools as tools
+import pandas.tseries.frequencies as frequencies
+from pandas.tseries.frequencies import FreqGroup
+from pandas.tseries.period import Period, PeriodIndex
+
+def register():
+    units.registry[pydt.time] = TimeConverter()
+    units.registry[lib.Timestamp] = DatetimeConverter()
+    units.registry[pydt.date] = DatetimeConverter()
+    units.registry[pydt.datetime] = DatetimeConverter()
+    units.registry[Period] = PeriodConverter()
+
+def _to_ordinalf(tm):
+    tot_sec = tm.hour * 3600 + tm.minute * 60 + tm.second + tm.microsecond
+    return tot_sec
+
+def time2num(d):
+    if isinstance(d, str):
+        parsed = tools.to_datetime(d)
+        if not isinstance(parsed, datetime):
+            raise ValueError('Could not parse time %s' % d)
+        return _to_ordinalf(parsed.time())
+    if isinstance(d, pydt.time):
+        return _to_ordinalf(d)
+    return d
+
+class TimeConverter(units.ConversionInterface):
+
+    @staticmethod
+    def convert(value, unit, axis):
+        valid_types = (str, pydt.time)
+        if (isinstance(value, valid_types) or com.is_integer(value) or
+            com.is_float(value)):
+            return time2num(value)
+        if isinstance(value, Index):
+            return value.map(time2num)
+        if isinstance(value, (list, tuple, np.ndarray)):
+            return [time2num(x) for x in value]
+        return value
+
+    @staticmethod
+    def axisinfo(unit, axis):
+        if unit != 'time':
+            return None
+
+        majloc = AutoLocator()
+        majfmt = TimeFormatter(majloc)
+        return units.AxisInfo(majloc=majloc, majfmt=majfmt, label='time')
+
+    @staticmethod
+    def default_units(x, axis):
+        return 'time'
+
+### time formatter
+class TimeFormatter(Formatter):
+
+    def __init__(self, locs):
+        self.locs = locs
+
+    def __call__(self, x, pos=0):
+        fmt = '%H:%M:%S'
+        s = int(x)
+        us = int((x - s) * 1e6)
+        m, s = divmod(s, 60)
+        h, m = divmod(m, 60)
+        return pydt.time(h, m, s, us).strftime(fmt)
+
+### Period Conversion
+
+class PeriodConverter(dates.DateConverter):
+
+    @staticmethod
+    def convert(values, units, axis):
+        if not hasattr(axis, 'freq'):
+            raise TypeError('Axis must have `freq` set to convert to Periods')
+        valid_types = (str, datetime, Period, pydt.date, pydt.time)
+        if (isinstance(values, valid_types) or com.is_integer(values) or
+            com.is_float(values)):
+            return get_datevalue(values, axis.freq)
+        if isinstance(values, Index):
+            return values.map(lambda x: get_datevalue(x, axis.freq))
+        if isinstance(values, (list, tuple, np.ndarray)):
+            return [get_datevalue(x, axis.freq) for x in values]
+        return values
+
+def get_datevalue(date, freq):
+    if isinstance(date, Period):
+        return date.asfreq(freq).ordinal
+    elif isinstance(date, (str, datetime, pydt.date, pydt.time)):
+        return Period(date, freq).ordinal
+    elif (com.is_integer(date) or com.is_float(date) or
+          (isinstance(date, np.ndarray) and (date.size == 1))):
+        return date
+    elif date is None:
+        return None
+    raise ValueError("Unrecognizable date '%s'" % date)
+
+### Datetime Conversion
+class DatetimeConverter(dates.DateConverter):
+
+    @staticmethod
+    def convert(values, unit, axis):
+        def try_parse(values):
+            try:
+                return tools.to_datetime(values).toordinal()
+            except Exception:
+                return values
+
+        if isinstance(values, (datetime, pydt.date)):
+            return values.toordinal()
+        elif isinstance(values, pydt.time):
+            return dates.date2num(values)
+        elif (com.is_integer(values) or com.is_float(values)):
+            return values
+        elif isinstance(values, str):
+            return try_parse(values)
+        elif isinstance(values, Index):
+            return values.map(try_parse)
+        elif isinstance(values, (list, tuple, np.ndarray)):
+            return [try_parse(x) for x in values]
+        return values
+
+### Fixed frequency dynamic tick locators and formatters
+
+##### -------------------------------------------------------------------------
+#---- --- Locators ---
+##### -------------------------------------------------------------------------
+
+def _get_default_annual_spacing(nyears):
+    """
+    Returns a default spacing between consecutive ticks for annual data.
+    """
+    if nyears < 11:
+        (min_spacing, maj_spacing) = (1, 1)
+    elif nyears < 20:
+        (min_spacing, maj_spacing) = (1, 2)
+    elif nyears < 50:
+        (min_spacing, maj_spacing) = (1, 5)
+    elif nyears < 100:
+        (min_spacing, maj_spacing) = (5, 10)
+    elif nyears < 200:
+        (min_spacing, maj_spacing) = (5, 25)
+    elif nyears < 600:
+        (min_spacing, maj_spacing) = (10, 50)
+    else:
+        factor = nyears // 1000 + 1
+        (min_spacing, maj_spacing) = (factor * 20, factor * 100)
+    return (min_spacing, maj_spacing)
+
+def period_break(dates, period):
+    """
+    Returns the indices where the given period changes.
+
+    Parameters
+    ----------
+    dates : PeriodIndex
+        Array of intervals to monitor.
+    period : string
+        Name of the period to monitor.
+    """
+    current = getattr(dates, period)
+    previous = getattr(dates - 1, period)
+    return (current - previous).nonzero()[0]
+
+def has_level_label(label_flags, vmin):
+    """
+    Returns true if the ``label_flags`` indicate there is at least one label
+    for this level.
+
+    if the minimum view limit is not an exact integer, then the first tick
+    label won't be shown, so we must adjust for that.
+    """
+    if label_flags.size == 0 or (label_flags.size == 1 and
+                                 label_flags[0] == 0 and
+                                 vmin % 1 > 0.0):
+        return False
+    else:
+        return True
+
+def _daily_finder(vmin, vmax, freq):
+    periodsperday = -1
+
+    if freq >= FreqGroup.FR_HR:
+        if freq == FreqGroup.FR_SEC:
+            periodsperday = 24 * 60 * 60
+        elif freq == FreqGroup.FR_MIN:
+            periodsperday = 24 * 60
+        elif freq == FreqGroup.FR_HR:
+            periodsperday = 24
+        else: # pragma: no cover
+            raise ValueError("unexpected frequency: %s" % freq)
+        periodsperyear = 365 * periodsperday
+        periodspermonth = 28 * periodsperday
+
+    elif freq == FreqGroup.FR_BUS:
+        periodsperyear = 261
+        periodspermonth = 19
+    elif freq == FreqGroup.FR_DAY:
+        periodsperyear = 365
+        periodspermonth = 28
+    elif frequencies.get_freq_group(freq) == FreqGroup.FR_WK:
+        periodsperyear = 52
+        periodspermonth = 3
+    elif freq == FreqGroup.FR_UND:
+        periodsperyear = 100
+        periodspermonth = 10
+    else: # pragma: no cover
+        raise ValueError("unexpected frequency")
+
+    # save this for later usage
+    vmin_orig = vmin
+
+    (vmin, vmax) = (Period(ordinal=int(vmin), freq=freq),
+                    Period(ordinal=int(vmax), freq=freq))
+    span = vmax.ordinal - vmin.ordinal + 1
+    dates_ = PeriodIndex(start=vmin, end=vmax, freq=freq)
+    # Initialize the output
+    info = np.zeros(span,
+                    dtype=[('val', np.int64), ('maj', bool),
+                           ('min', bool), ('fmt', '|S20')])
+    info['val'][:] = dates_.values
+    info['fmt'][:] = ''
+    info['maj'][[0, -1]] = True
+    # .. and set some shortcuts
+    info_maj = info['maj']
+    info_min = info['min']
+    info_fmt = info['fmt']
+
+    def first_label(label_flags):
+        if (label_flags[0] == 0) and (label_flags.size > 1) and \
+            ((vmin_orig % 1) > 0.0):
+                return label_flags[1]
+        else:
+            return label_flags[0]
+
+    # Case 1. Less than a month
+    if span <= periodspermonth:
+        day_start = period_break(dates_, 'day')
+        month_start = period_break(dates_, 'month')
+
+        def _hour_finder(label_interval, force_year_start):
+            _hour = dates_.hour
+            _prev_hour = (dates_-1).hour
+            hour_start = (_hour - _prev_hour) != 0
+            info_maj[day_start] = True
+            info_min[hour_start & (_hour % label_interval == 0)] = True
+            year_start = period_break(dates_, 'year')
+            info_fmt[hour_start & (_hour % label_interval == 0)] = '%H:%M'
+            info_fmt[day_start] = '%H:%M\n%d-%b'
+            info_fmt[year_start] = '%H:%M\n%d-%b\n%Y'
+            if force_year_start and not has_level_label(year_start, vmin_orig):
+                info_fmt[first_label(day_start)] = '%H:%M\n%d-%b\n%Y'
+
+        def _minute_finder(label_interval):
+            hour_start = period_break(dates_, 'hour')
+            _minute = dates_.minute
+            _prev_minute = (dates_-1).minute
+            minute_start = (_minute - _prev_minute) != 0
+            info_maj[hour_start] = True
+            info_min[minute_start & (_minute % label_interval == 0)] = True
+            year_start = period_break(dates_, 'year')
+            info_fmt = info['fmt']
+            info_fmt[minute_start & (_minute % label_interval == 0)] = '%H:%M'
+            info_fmt[day_start] = '%H:%M\n%d-%b'
+            info_fmt[year_start] = '%H:%M\n%d-%b\n%Y'
+
+        def _second_finder(label_interval):
+            minute_start = period_break(dates_, 'minute')
+            _second = dates_.second
+            _prev_second = (dates_-1).second
+            second_start = (_second - _prev_second) != 0
+            info['maj'][minute_start] = True
+            info['min'][second_start & (_second % label_interval == 0)] = True
+            year_start = period_break(dates_, 'year')
+            info_fmt = info['fmt']
+            info_fmt[second_start & (_second % label_interval == 0)] = '%H:%M:%S'
+            info_fmt[day_start] = '%H:%M:%S\n%d-%b'
+            info_fmt[year_start] = '%H:%M:%S\n%d-%b\n%Y'
+
+        if span < periodsperday / 12000.0: _second_finder(1)
+        elif span < periodsperday / 6000.0: _second_finder(2)
+        elif span < periodsperday / 2400.0: _second_finder(5)
+        elif span < periodsperday / 1200.0: _second_finder(10)
+        elif span < periodsperday / 800.0: _second_finder(15)
+        elif span < periodsperday / 400.0: _second_finder(30)
+        elif span < periodsperday / 150.0: _minute_finder(1)
+        elif span < periodsperday / 70.0: _minute_finder(2)
+        elif span < periodsperday / 24.0: _minute_finder(5)
+        elif span < periodsperday / 12.0: _minute_finder(15)
+        elif span < periodsperday / 6.0:  _minute_finder(30)
+        elif span < periodsperday / 2.5: _hour_finder(1, False)
+        elif span < periodsperday / 1.5: _hour_finder(2, False)
+        elif span < periodsperday * 1.25: _hour_finder(3, False)
+        elif span < periodsperday * 2.5: _hour_finder(6, True)
+        elif span < periodsperday * 4: _hour_finder(12, True)
+        else:
+            info_maj[month_start] = True
+            info_min[day_start] = True
+            year_start = period_break(dates_, 'year')
+            info_fmt = info['fmt']
+            info_fmt[day_start] = '%d'
+            info_fmt[month_start] = '%d\n%b'
+            info_fmt[year_start] = '%d\n%b\n%Y'
+            if not has_level_label(year_start, vmin_orig):
+                if not has_level_label(month_start, vmin_orig):
+                    info_fmt[first_label(day_start)] = '%d\n%b\n%Y'
+                else:
+                    info_fmt[first_label(month_start)] = '%d\n%b\n%Y'
+
+    # Case 2. Less than three months
+    elif span <= periodsperyear // 4:
+        month_start = period_break(dates_, 'month')
+        info_maj[month_start] = True
+        if freq < FreqGroup.FR_HR:
+            info['min'] = True
+        else:
+            day_start = period_break(dates_, 'day')
+            info['min'][day_start] = True
+        week_start = period_break(dates_, 'week')
+        year_start = period_break(dates_, 'year')
+        info_fmt[week_start] = '%d'
+        info_fmt[month_start] = '\n\n%b'
+        info_fmt[year_start] = '\n\n%b\n%Y'
+        if not has_level_label(year_start, vmin_orig):
+            if not has_level_label(month_start, vmin_orig):
+                info_fmt[first_label(week_start)] = '\n\n%b\n%Y'
+            else:
+                info_fmt[first_label(month_start)] = '\n\n%b\n%Y'
+    # Case 3. Less than 14 months ...............
+    elif span <= 1.15 * periodsperyear:
+        year_start = period_break(dates_, 'year')
+        month_start = period_break(dates_, 'month')
+        week_start = period_break(dates_, 'week')
+        info_maj[month_start] = True
+        info_min[week_start] = True
+        info_min[year_start] = False
+        info_min[month_start] = False
+        info_fmt[month_start] = '%b'
+        info_fmt[year_start] = '%b\n%Y'
+        if not has_level_label(year_start, vmin_orig):
+            info_fmt[first_label(month_start)] = '%b\n%Y'
+    # Case 4. Less than 2.5 years ...............
+    elif span <= 2.5 * periodsperyear:
+        year_start = period_break(dates_, 'year')
+        quarter_start = period_break(dates_, 'quarter')
+        month_start = period_break(dates_, 'month')
+        info_maj[quarter_start] = True
+        info_min[month_start] = True
+        info_fmt[quarter_start] = '%b'
+        info_fmt[year_start] = '%b\n%Y'
+    # Case 4. Less than 4 years .................
+    elif span <= 4 * periodsperyear:
+        year_start = period_break(dates_, 'year')
+        month_start = period_break(dates_, 'month')
+        info_maj[year_start] = True
+        info_min[month_start] = True
+        info_min[year_start] = False
+
+        month_break = dates_[month_start].month
+        jan_or_jul = month_start[(month_break == 1) | (month_break == 7)]
+        info_fmt[jan_or_jul] = '%b'
+        info_fmt[year_start] = '%b\n%Y'
+    # Case 5. Less than 11 years ................
+    elif span <= 11 * periodsperyear:
+        year_start = period_break(dates_, 'year')
+        quarter_start = period_break(dates_, 'quarter')
+        info_maj[year_start] = True
+        info_min[quarter_start] = True
+        info_min[year_start] = False
+        info_fmt[year_start] = '%Y'
+    # Case 6. More than 12 years ................
+    else:
+        year_start = period_break(dates_, 'year')
+        year_break = dates_[year_start].year
+        nyears = span / periodsperyear
+        (min_anndef, maj_anndef) = _get_default_annual_spacing(nyears)
+        major_idx = year_start[(year_break % maj_anndef == 0)]
+        info_maj[major_idx] = True
+        minor_idx = year_start[(year_break % min_anndef == 0)]
+        info_min[minor_idx] = True
+        info_fmt[major_idx] = '%Y'
+    #............................................
+
+    return info
+
+
+def _monthly_finder(vmin, vmax, freq):
+    periodsperyear = 12
+
+    vmin_orig = vmin
+    (vmin, vmax) = (int(vmin), int(vmax))
+    span = vmax - vmin + 1
+    #..............
+    # Initialize the output
+    info = np.zeros(span,
+                    dtype=[('val', int), ('maj', bool), ('min', bool),
+                           ('fmt', '|S8')])
+    info['val'] = np.arange(vmin, vmax + 1)
+    dates_ = info['val']
+    info['fmt'] = ''
+    year_start = (dates_ % 12 == 0).nonzero()[0]
+    info_maj = info['maj']
+    info_fmt = info['fmt']
+    #..............
+    if span <= 1.15 * periodsperyear:
+        info_maj[year_start] = True
+        info['min'] = True
+
+        info_fmt[:] = '%b'
+        info_fmt[year_start] = '%b\n%Y'
+
+        if not has_level_label(year_start, vmin_orig):
+            if dates_.size > 1:
+                idx = 1
+            else:
+                idx = 0
+            info_fmt[idx] = '%b\n%Y'
+    #..............
+    elif span <= 2.5 * periodsperyear:
+        quarter_start = (dates_ % 3 == 0).nonzero()
+        info_maj[year_start] = True
+        # TODO: Check the following : is it really info['fmt'] ?
+        info['fmt'][quarter_start] = True
+        info['min'] = True
+
+        info_fmt[quarter_start] = '%b'
+        info_fmt[year_start] = '%b\n%Y'
+    #..............
+    elif span <= 4 * periodsperyear:
+        info_maj[year_start] = True
+        info['min'] = True
+
+        jan_or_jul = (dates_ % 12 == 0) | (dates_ % 12 == 6)
+        info_fmt[jan_or_jul] = '%b'
+        info_fmt[year_start] = '%b\n%Y'
+    #..............
+    elif span <= 11 * periodsperyear:
+        quarter_start = (dates_ % 3 == 0).nonzero()
+        info_maj[year_start] = True
+        info['min'][quarter_start] = True
+
+        info_fmt[year_start] = '%Y'
+    #..................
+    else:
+        nyears = span / periodsperyear
+        (min_anndef, maj_anndef) = _get_default_annual_spacing(nyears)
+        years = dates_[year_start] // 12 + 1
+        major_idx = year_start[(years % maj_anndef == 0)]
+        info_maj[major_idx] = True
+        info['min'][year_start[(years % min_anndef == 0)]] = True
+
+        info_fmt[major_idx] = '%Y'
+    #..............
+    return info
+
+
+def _quarterly_finder(vmin, vmax, freq):
+    periodsperyear = 4
+    vmin_orig = vmin
+    (vmin, vmax) = (int(vmin), int(vmax))
+    span = vmax - vmin + 1
+    #............................................
+    info = np.zeros(span,
+                    dtype=[('val', int), ('maj', bool), ('min', bool),
+                           ('fmt', '|S8')])
+    info['val'] = np.arange(vmin, vmax + 1)
+    info['fmt'] = ''
+    dates_ = info['val']
+    info_maj = info['maj']
+    info_fmt = info['fmt']
+    year_start = (dates_ % 4 == 0).nonzero()[0]
+    #..............
+    if span <= 3.5 * periodsperyear:
+        info_maj[year_start] = True
+        info['min'] = True
+
+        info_fmt[:] = 'Q%q'
+        info_fmt[year_start] = 'Q%q\n%F'
+        if not has_level_label(year_start, vmin_orig):
+            if dates_.size > 1:
+                idx = 1
+            else:
+                idx = 0
+            info_fmt[idx] = 'Q%q\n%F'
+    #..............
+    elif span <= 11 * periodsperyear:
+        info_maj[year_start] = True
+        info['min'] = True
+        info_fmt[year_start] = '%F'
+    #..............
+    else:
+        years = dates_[year_start] // 4 + 1
+        nyears = span / periodsperyear
+        (min_anndef, maj_anndef) = _get_default_annual_spacing(nyears)
+        major_idx = year_start[(years % maj_anndef == 0)]
+        info_maj[major_idx] = True
+        info['min'][year_start[(years % min_anndef == 0)]] = True
+        info_fmt[major_idx] = '%F'
+    #..............
+    return info
+
+def _annual_finder(vmin, vmax, freq):
+    (vmin, vmax) = (int(vmin), int(vmax + 1))
+    span = vmax - vmin + 1
+    #..............
+    info = np.zeros(span,
+                    dtype=[('val', int), ('maj', bool), ('min', bool),
+                           ('fmt', '|S8')])
+    info['val'] = np.arange(vmin, vmax + 1)
+    info['fmt'] = ''
+    dates_ = info['val']
+    #..............
+    (min_anndef, maj_anndef) = _get_default_annual_spacing(span)
+    major_idx = dates_ % maj_anndef == 0
+    info['maj'][major_idx] = True
+    info['min'][(dates_ % min_anndef == 0)] = True
+    info['fmt'][major_idx] = '%Y'
+    #..............
+    return info
+
+def get_finder(freq):
+    if isinstance(freq, basestring):
+        freq = frequencies.get_freq(freq)
+    fgroup = frequencies.get_freq_group(freq)
+
+    if fgroup == FreqGroup.FR_ANN:
+        return _annual_finder
+    elif fgroup == FreqGroup.FR_QTR:
+        return _quarterly_finder
+    elif freq ==FreqGroup.FR_MTH:
+        return _monthly_finder
+    elif ((freq >= FreqGroup.FR_BUS) or (freq == FreqGroup.FR_UND) or
+          fgroup == FreqGroup.FR_WK):
+        return _daily_finder
+    else: # pragma: no cover
+        errmsg = "Unsupported frequency: %s" % (freq)
+        raise NotImplementedError(errmsg)
+
+class TimeSeries_DateLocator(Locator):
+    """
+    Locates the ticks along an axis controlled by a :class:`Series`.
+
+    Parameters
+    ----------
+    freq : {var}
+        Valid frequency specifier.
+    minor_locator : {False, True}, optional
+        Whether the locator is for minor ticks (True) or not.
+    dynamic_mode : {True, False}, optional
+        Whether the locator should work in dynamic mode.
+    base : {int}, optional
+    quarter : {int}, optional
+    month : {int}, optional
+    day : {int}, optional
+    """
+
+    def __init__(self, freq, minor_locator=False, dynamic_mode=True,
+                 base=1, quarter=1, month=1, day=1, plot_obj=None):
+        if isinstance(freq, basestring):
+            freq = frequencies.get_freq(freq)
+        self.freq = freq
+        self.base = base
+        (self.quarter, self.month, self.day) = (quarter, month, day)
+        self.isminor = minor_locator
+        self.isdynamic = dynamic_mode
+        self.offset = 0
+        self.plot_obj = plot_obj
+        self.finder = get_finder(freq)
+
+    def _get_default_locs(self, vmin, vmax):
+        "Returns the default locations of ticks."
+
+        if self.plot_obj.date_axis_info is None:
+            self.plot_obj.date_axis_info = self.finder(vmin, vmax, self.freq)
+
+        locator = self.plot_obj.date_axis_info
+
+        if self.isminor:
+            return np.compress(locator['min'], locator['val'])
+        return np.compress(locator['maj'], locator['val'])
+
+    def __call__(self):
+        'Return the locations of the ticks.'
+        # axis calls Locator.set_axis inside set_m<xxxx>_formatter
+        vi = tuple(self.axis.get_view_interval())
+        if vi != self.plot_obj.view_interval:
+            self.plot_obj.date_axis_info = None
+        self.plot_obj.view_interval = vi
+        vmin, vmax = vi
+        if vmax < vmin:
+            vmin, vmax = vmax, vmin
+        if self.isdynamic:
+            locs = self._get_default_locs(vmin, vmax)
+        else: # pragma: no cover
+            base = self.base
+            (d, m) = divmod(vmin, base)
+            vmin = (d + 1) * base
+            locs = range(vmin, vmax + 1, base)
+        return locs
+
+    def autoscale(self):
+        """
+        Sets the view limits to the nearest multiples of base that contain the
+        data.
+        """
+        # requires matplotlib >= 0.98.0
+        (vmin, vmax) = self.axis.get_data_interval()
+
+        locs = self._get_default_locs(vmin, vmax)
+        (vmin, vmax) = locs[[0, -1]]
+        if vmin == vmax:
+            vmin -= 1
+            vmax += 1
+        return nonsingular(vmin, vmax)
+
+#####-------------------------------------------------------------------------
+#---- --- Formatter ---
+#####-------------------------------------------------------------------------
+class TimeSeries_DateFormatter(Formatter):
+    """
+    Formats the ticks along an axis controlled by a :class:`PeriodIndex`.
+
+    Parameters
+    ----------
+    freq : {int, string}
+        Valid frequency specifier.
+    minor_locator : {False, True}
+        Whether the current formatter should apply to minor ticks (True) or
+        major ticks (False).
+    dynamic_mode : {True, False}
+        Whether the formatter works in dynamic mode or not.
+    """
+
+    def __init__(self, freq, minor_locator=False, dynamic_mode=True,
+                 plot_obj=None):
+        if isinstance(freq, basestring):
+            freq = frequencies.get_freq(freq)
+        self.format = None
+        self.freq = freq
+        self.locs = []
+        self.formatdict = None
+        self.isminor = minor_locator
+        self.isdynamic = dynamic_mode
+        self.offset = 0
+        self.plot_obj = plot_obj
+        self.finder = get_finder(freq)
+
+    def _set_default_format(self, vmin, vmax):
+        "Returns the default ticks spacing."
+
+        if self.plot_obj.date_axis_info is None:
+            self.plot_obj.date_axis_info = self.finder(vmin, vmax, self.freq)
+        info = self.plot_obj.date_axis_info
+
+        if self.isminor:
+            format = np.compress(info['min'] & np.logical_not(info['maj']),
+                                 info)
+        else:
+            format = np.compress(info['maj'], info)
+        self.formatdict = dict([(x, f) for (x, _, _, f) in format])
+        return self.formatdict
+
+    def set_locs(self, locs):
+        'Sets the locations of the ticks'
+        # don't actually use the locs. This is just needed to work with
+        # matplotlib. Force to use vmin, vmax
+        self.locs = locs
+
+        (vmin, vmax) = vi = tuple(self.axis.get_view_interval())
+        if vi != self.plot_obj.view_interval:
+            self.plot_obj.date_axis_info = None
+        self.plot_obj.view_interval = vi
+        if vmax < vmin:
+            (vmin, vmax) = (vmax, vmin)
+        self._set_default_format(vmin, vmax)
+    #
+    def __call__(self, x, pos=0):
+        if self.formatdict is None:
+            return ''
+        else:
+            fmt = self.formatdict.pop(x, '')
+            return Period(ordinal=int(x), freq=self.freq).strftime(fmt)
+
+
diff --git a/pandas/tseries/plotting.py b/pandas/tseries/plotting.py
index 152f677a5..678c272b2 100644
--- a/pandas/tseries/plotting.py
+++ b/pandas/tseries/plotting.py
@@ -7,24 +7,21 @@ import datetime as pydt
 from datetime import datetime
 
 from matplotlib import pylab
-from matplotlib.ticker import Formatter, Locator
-from matplotlib.transforms import nonsingular
+import matplotlib.units as units
 
 import numpy as np
 
 from pandas import isnull
+from pandas.tseries.period import Period
 from pandas.tseries.offsets import DateOffset
 import pandas.tseries.frequencies as frequencies
-from pandas.tseries.frequencies import FreqGroup
-
-from pandas.tseries.period import Period, PeriodIndex
 from pandas.tseries.index import DatetimeIndex
-from pandas.core.index import Index
-from pandas.core.series import Series
 import pandas.core.common as com
 
-import warnings
+from pandas.tseries.converter import (PeriodConverter, TimeSeries_DateLocator,
+                                      TimeSeries_DateFormatter)
 
+units.registry[Period] = PeriodConverter()
 #----------------------------------------------------------------------
 # Plotting functions and monkey patches
 
@@ -148,565 +145,6 @@ def get_datevalue(date, freq):
         return None
     raise ValueError("Unrecognizable date '%s'" % date)
 
-##### -------------------------------------------------------------------------
-#---- --- Locators ---
-##### -------------------------------------------------------------------------
-
-def _get_default_annual_spacing(nyears):
-    """
-    Returns a default spacing between consecutive ticks for annual data.
-    """
-    if nyears < 11:
-        (min_spacing, maj_spacing) = (1, 1)
-    elif nyears < 20:
-        (min_spacing, maj_spacing) = (1, 2)
-    elif nyears < 50:
-        (min_spacing, maj_spacing) = (1, 5)
-    elif nyears < 100:
-        (min_spacing, maj_spacing) = (5, 10)
-    elif nyears < 200:
-        (min_spacing, maj_spacing) = (5, 25)
-    elif nyears < 600:
-        (min_spacing, maj_spacing) = (10, 50)
-    else:
-        factor = nyears // 1000 + 1
-        (min_spacing, maj_spacing) = (factor * 20, factor * 100)
-    return (min_spacing, maj_spacing)
-
-def period_break(dates, period):
-    """
-    Returns the indices where the given period changes.
-
-    Parameters
-    ----------
-    dates : PeriodIndex
-        Array of intervals to monitor.
-    period : string
-        Name of the period to monitor.
-    """
-    current = getattr(dates, period)
-    previous = getattr(dates - 1, period)
-    return (current - previous).nonzero()[0]
-
-def has_level_label(label_flags, vmin):
-    """
-    Returns true if the ``label_flags`` indicate there is at least one label
-    for this level.
-
-    if the minimum view limit is not an exact integer, then the first tick
-    label won't be shown, so we must adjust for that.
-    """
-    if label_flags.size == 0 or (label_flags.size == 1 and
-                                 label_flags[0] == 0 and
-                                 vmin % 1 > 0.0):
-        return False
-    else:
-        return True
-
-def _daily_finder(vmin, vmax, freq):
-    periodsperday = -1
-
-    if freq >= FreqGroup.FR_HR:
-        if freq == FreqGroup.FR_SEC:
-            periodsperday = 24 * 60 * 60
-        elif freq == FreqGroup.FR_MIN:
-            periodsperday = 24 * 60
-        elif freq == FreqGroup.FR_HR:
-            periodsperday = 24
-        else: # pragma: no cover
-            raise ValueError("unexpected frequency: %s" % freq)
-        periodsperyear = 365 * periodsperday
-        periodspermonth = 28 * periodsperday
-
-    elif freq == FreqGroup.FR_BUS:
-        periodsperyear = 261
-        periodspermonth = 19
-    elif freq == FreqGroup.FR_DAY:
-        periodsperyear = 365
-        periodspermonth = 28
-    elif frequencies.get_freq_group(freq) == FreqGroup.FR_WK:
-        periodsperyear = 52
-        periodspermonth = 3
-    elif freq == FreqGroup.FR_UND:
-        periodsperyear = 100
-        periodspermonth = 10
-    else: # pragma: no cover
-        raise ValueError("unexpected frequency")
-
-    # save this for later usage
-    vmin_orig = vmin
-
-    (vmin, vmax) = (Period(ordinal=int(vmin), freq=freq),
-                    Period(ordinal=int(vmax), freq=freq))
-    span = vmax.ordinal - vmin.ordinal + 1
-    dates_ = PeriodIndex(start=vmin, end=vmax, freq=freq)
-    # Initialize the output
-    info = np.zeros(span,
-                    dtype=[('val', np.int64), ('maj', bool),
-                           ('min', bool), ('fmt', '|S20')])
-    info['val'][:] = dates_.values
-    info['fmt'][:] = ''
-    info['maj'][[0, -1]] = True
-    # .. and set some shortcuts
-    info_maj = info['maj']
-    info_min = info['min']
-    info_fmt = info['fmt']
-
-    def first_label(label_flags):
-        if (label_flags[0] == 0) and (label_flags.size > 1) and \
-            ((vmin_orig % 1) > 0.0):
-                return label_flags[1]
-        else:
-            return label_flags[0]
-
-    # Case 1. Less than a month
-    if span <= periodspermonth:
-        day_start = period_break(dates_, 'day')
-        month_start = period_break(dates_, 'month')
-
-        def _hour_finder(label_interval, force_year_start):
-            _hour = dates_.hour
-            _prev_hour = (dates_-1).hour
-            hour_start = (_hour - _prev_hour) != 0
-            info_maj[day_start] = True
-            info_min[hour_start & (_hour % label_interval == 0)] = True
-            year_start = period_break(dates_, 'year')
-            info_fmt[hour_start & (_hour % label_interval == 0)] = '%H:%M'
-            info_fmt[day_start] = '%H:%M\n%d-%b'
-            info_fmt[year_start] = '%H:%M\n%d-%b\n%Y'
-            if force_year_start and not has_level_label(year_start, vmin_orig):
-                info_fmt[first_label(day_start)] = '%H:%M\n%d-%b\n%Y'
-
-        def _minute_finder(label_interval):
-            hour_start = period_break(dates_, 'hour')
-            _minute = dates_.minute
-            _prev_minute = (dates_-1).minute
-            minute_start = (_minute - _prev_minute) != 0
-            info_maj[hour_start] = True
-            info_min[minute_start & (_minute % label_interval == 0)] = True
-            year_start = period_break(dates_, 'year')
-            info_fmt = info['fmt']
-            info_fmt[minute_start & (_minute % label_interval == 0)] = '%H:%M'
-            info_fmt[day_start] = '%H:%M\n%d-%b'
-            info_fmt[year_start] = '%H:%M\n%d-%b\n%Y'
-
-        def _second_finder(label_interval):
-            minute_start = period_break(dates_, 'minute')
-            _second = dates_.second
-            _prev_second = (dates_-1).second
-            second_start = (_second - _prev_second) != 0
-            info['maj'][minute_start] = True
-            info['min'][second_start & (_second % label_interval == 0)] = True
-            year_start = period_break(dates_, 'year')
-            info_fmt = info['fmt']
-            info_fmt[second_start & (_second % label_interval == 0)] = '%H:%M:%S'
-            info_fmt[day_start] = '%H:%M:%S\n%d-%b'
-            info_fmt[year_start] = '%H:%M:%S\n%d-%b\n%Y'
-
-        if span < periodsperday / 12000.0: _second_finder(1)
-        elif span < periodsperday / 6000.0: _second_finder(2)
-        elif span < periodsperday / 2400.0: _second_finder(5)
-        elif span < periodsperday / 1200.0: _second_finder(10)
-        elif span < periodsperday / 800.0: _second_finder(15)
-        elif span < periodsperday / 400.0: _second_finder(30)
-        elif span < periodsperday / 150.0: _minute_finder(1)
-        elif span < periodsperday / 70.0: _minute_finder(2)
-        elif span < periodsperday / 24.0: _minute_finder(5)
-        elif span < periodsperday / 12.0: _minute_finder(15)
-        elif span < periodsperday / 6.0:  _minute_finder(30)
-        elif span < periodsperday / 2.5: _hour_finder(1, False)
-        elif span < periodsperday / 1.5: _hour_finder(2, False)
-        elif span < periodsperday * 1.25: _hour_finder(3, False)
-        elif span < periodsperday * 2.5: _hour_finder(6, True)
-        elif span < periodsperday * 4: _hour_finder(12, True)
-        else:
-            info_maj[month_start] = True
-            info_min[day_start] = True
-            year_start = period_break(dates_, 'year')
-            info_fmt = info['fmt']
-            info_fmt[day_start] = '%d'
-            info_fmt[month_start] = '%d\n%b'
-            info_fmt[year_start] = '%d\n%b\n%Y'
-            if not has_level_label(year_start, vmin_orig):
-                if not has_level_label(month_start, vmin_orig):
-                    info_fmt[first_label(day_start)] = '%d\n%b\n%Y'
-                else:
-                    info_fmt[first_label(month_start)] = '%d\n%b\n%Y'
-
-    # Case 2. Less than three months
-    elif span <= periodsperyear // 4:
-        month_start = period_break(dates_, 'month')
-        info_maj[month_start] = True
-        if freq < FreqGroup.FR_HR:
-            info['min'] = True
-        else:
-            day_start = period_break(dates_, 'day')
-            info['min'][day_start] = True
-        week_start = period_break(dates_, 'week')
-        year_start = period_break(dates_, 'year')
-        info_fmt[week_start] = '%d'
-        info_fmt[month_start] = '\n\n%b'
-        info_fmt[year_start] = '\n\n%b\n%Y'
-        if not has_level_label(year_start, vmin_orig):
-            if not has_level_label(month_start, vmin_orig):
-                info_fmt[first_label(week_start)] = '\n\n%b\n%Y'
-            else:
-                info_fmt[first_label(month_start)] = '\n\n%b\n%Y'
-    # Case 3. Less than 14 months ...............
-    elif span <= 1.15 * periodsperyear:
-        year_start = period_break(dates_, 'year')
-        month_start = period_break(dates_, 'month')
-        week_start = period_break(dates_, 'week')
-        info_maj[month_start] = True
-        info_min[week_start] = True
-        info_min[year_start] = False
-        info_min[month_start] = False
-        info_fmt[month_start] = '%b'
-        info_fmt[year_start] = '%b\n%Y'
-        if not has_level_label(year_start, vmin_orig):
-            info_fmt[first_label(month_start)] = '%b\n%Y'
-    # Case 4. Less than 2.5 years ...............
-    elif span <= 2.5 * periodsperyear:
-        year_start = period_break(dates_, 'year')
-        quarter_start = period_break(dates_, 'quarter')
-        month_start = period_break(dates_, 'month')
-        info_maj[quarter_start] = True
-        info_min[month_start] = True
-        info_fmt[quarter_start] = '%b'
-        info_fmt[year_start] = '%b\n%Y'
-    # Case 4. Less than 4 years .................
-    elif span <= 4 * periodsperyear:
-        year_start = period_break(dates_, 'year')
-        month_start = period_break(dates_, 'month')
-        info_maj[year_start] = True
-        info_min[month_start] = True
-        info_min[year_start] = False
-
-        month_break = dates_[month_start].month
-        jan_or_jul = month_start[(month_break == 1) | (month_break == 7)]
-        info_fmt[jan_or_jul] = '%b'
-        info_fmt[year_start] = '%b\n%Y'
-    # Case 5. Less than 11 years ................
-    elif span <= 11 * periodsperyear:
-        year_start = period_break(dates_, 'year')
-        quarter_start = period_break(dates_, 'quarter')
-        info_maj[year_start] = True
-        info_min[quarter_start] = True
-        info_min[year_start] = False
-        info_fmt[year_start] = '%Y'
-    # Case 6. More than 12 years ................
-    else:
-        year_start = period_break(dates_, 'year')
-        year_break = dates_[year_start].year
-        nyears = span / periodsperyear
-        (min_anndef, maj_anndef) = _get_default_annual_spacing(nyears)
-        major_idx = year_start[(year_break % maj_anndef == 0)]
-        info_maj[major_idx] = True
-        minor_idx = year_start[(year_break % min_anndef == 0)]
-        info_min[minor_idx] = True
-        info_fmt[major_idx] = '%Y'
-    #............................................
-
-    return info
-
-
-def _monthly_finder(vmin, vmax, freq):
-    periodsperyear = 12
-
-    vmin_orig = vmin
-    (vmin, vmax) = (int(vmin), int(vmax))
-    span = vmax - vmin + 1
-    #..............
-    # Initialize the output
-    info = np.zeros(span,
-                    dtype=[('val', int), ('maj', bool), ('min', bool),
-                           ('fmt', '|S8')])
-    info['val'] = np.arange(vmin, vmax + 1)
-    dates_ = info['val']
-    info['fmt'] = ''
-    year_start = (dates_ % 12 == 0).nonzero()[0]
-    info_maj = info['maj']
-    info_fmt = info['fmt']
-    #..............
-    if span <= 1.15 * periodsperyear:
-        info_maj[year_start] = True
-        info['min'] = True
-
-        info_fmt[:] = '%b'
-        info_fmt[year_start] = '%b\n%Y'
-
-        if not has_level_label(year_start, vmin_orig):
-            if dates_.size > 1:
-                idx = 1
-            else:
-                idx = 0
-            info_fmt[idx] = '%b\n%Y'
-    #..............
-    elif span <= 2.5 * periodsperyear:
-        quarter_start = (dates_ % 3 == 0).nonzero()
-        info_maj[year_start] = True
-        # TODO: Check the following : is it really info['fmt'] ?
-        info['fmt'][quarter_start] = True
-        info['min'] = True
-
-        info_fmt[quarter_start] = '%b'
-        info_fmt[year_start] = '%b\n%Y'
-    #..............
-    elif span <= 4 * periodsperyear:
-        info_maj[year_start] = True
-        info['min'] = True
-
-        jan_or_jul = (dates_ % 12 == 0) | (dates_ % 12 == 6)
-        info_fmt[jan_or_jul] = '%b'
-        info_fmt[year_start] = '%b\n%Y'
-    #..............
-    elif span <= 11 * periodsperyear:
-        quarter_start = (dates_ % 3 == 0).nonzero()
-        info_maj[year_start] = True
-        info['min'][quarter_start] = True
-
-        info_fmt[year_start] = '%Y'
-    #..................
-    else:
-        nyears = span / periodsperyear
-        (min_anndef, maj_anndef) = _get_default_annual_spacing(nyears)
-        years = dates_[year_start] // 12 + 1
-        major_idx = year_start[(years % maj_anndef == 0)]
-        info_maj[major_idx] = True
-        info['min'][year_start[(years % min_anndef == 0)]] = True
-
-        info_fmt[major_idx] = '%Y'
-    #..............
-    return info
-
-
-def _quarterly_finder(vmin, vmax, freq):
-    periodsperyear = 4
-    vmin_orig = vmin
-    (vmin, vmax) = (int(vmin), int(vmax))
-    span = vmax - vmin + 1
-    #............................................
-    info = np.zeros(span,
-                    dtype=[('val', int), ('maj', bool), ('min', bool),
-                           ('fmt', '|S8')])
-    info['val'] = np.arange(vmin, vmax + 1)
-    info['fmt'] = ''
-    dates_ = info['val']
-    info_maj = info['maj']
-    info_fmt = info['fmt']
-    year_start = (dates_ % 4 == 0).nonzero()[0]
-    #..............
-    if span <= 3.5 * periodsperyear:
-        info_maj[year_start] = True
-        info['min'] = True
-
-        info_fmt[:] = 'Q%q'
-        info_fmt[year_start] = 'Q%q\n%F'
-        if not has_level_label(year_start, vmin_orig):
-            if dates_.size > 1:
-                idx = 1
-            else:
-                idx = 0
-            info_fmt[idx] = 'Q%q\n%F'
-    #..............
-    elif span <= 11 * periodsperyear:
-        info_maj[year_start] = True
-        info['min'] = True
-        info_fmt[year_start] = '%F'
-    #..............
-    else:
-        years = dates_[year_start] // 4 + 1
-        nyears = span / periodsperyear
-        (min_anndef, maj_anndef) = _get_default_annual_spacing(nyears)
-        major_idx = year_start[(years % maj_anndef == 0)]
-        info_maj[major_idx] = True
-        info['min'][year_start[(years % min_anndef == 0)]] = True
-        info_fmt[major_idx] = '%F'
-    #..............
-    return info
-
-def _annual_finder(vmin, vmax, freq):
-    (vmin, vmax) = (int(vmin), int(vmax + 1))
-    span = vmax - vmin + 1
-    #..............
-    info = np.zeros(span,
-                    dtype=[('val', int), ('maj', bool), ('min', bool),
-                           ('fmt', '|S8')])
-    info['val'] = np.arange(vmin, vmax + 1)
-    info['fmt'] = ''
-    dates_ = info['val']
-    #..............
-    (min_anndef, maj_anndef) = _get_default_annual_spacing(span)
-    major_idx = dates_ % maj_anndef == 0
-    info['maj'][major_idx] = True
-    info['min'][(dates_ % min_anndef == 0)] = True
-    info['fmt'][major_idx] = '%Y'
-    #..............
-    return info
-
-def get_finder(freq):
-    if isinstance(freq, basestring):
-        freq = frequencies.get_freq(freq)
-    fgroup = frequencies.get_freq_group(freq)
-
-    if fgroup == FreqGroup.FR_ANN:
-        return _annual_finder
-    elif fgroup == FreqGroup.FR_QTR:
-        return _quarterly_finder
-    elif freq ==FreqGroup.FR_MTH:
-        return _monthly_finder
-    elif ((freq >= FreqGroup.FR_BUS) or (freq == FreqGroup.FR_UND) or
-          fgroup == FreqGroup.FR_WK):
-        return _daily_finder
-    else: # pragma: no cover
-        errmsg = "Unsupported frequency: %s" % (freq)
-        raise NotImplementedError(errmsg)
-
-class TimeSeries_DateLocator(Locator):
-    """
-    Locates the ticks along an axis controlled by a :class:`Series`.
-
-    Parameters
-    ----------
-    freq : {var}
-        Valid frequency specifier.
-    minor_locator : {False, True}, optional
-        Whether the locator is for minor ticks (True) or not.
-    dynamic_mode : {True, False}, optional
-        Whether the locator should work in dynamic mode.
-    base : {int}, optional
-    quarter : {int}, optional
-    month : {int}, optional
-    day : {int}, optional
-    """
-
-    def __init__(self, freq, minor_locator=False, dynamic_mode=True,
-                 base=1, quarter=1, month=1, day=1, plot_obj=None):
-        if isinstance(freq, basestring):
-            freq = frequencies.get_freq(freq)
-        self.freq = freq
-        self.base = base
-        (self.quarter, self.month, self.day) = (quarter, month, day)
-        self.isminor = minor_locator
-        self.isdynamic = dynamic_mode
-        self.offset = 0
-        self.plot_obj = plot_obj
-        self.finder = get_finder(freq)
-
-    def _get_default_locs(self, vmin, vmax):
-        "Returns the default locations of ticks."
-
-        if self.plot_obj.date_axis_info is None:
-            self.plot_obj.date_axis_info = self.finder(vmin, vmax, self.freq)
-
-        locator = self.plot_obj.date_axis_info
-
-        if self.isminor:
-            return np.compress(locator['min'], locator['val'])
-        return np.compress(locator['maj'], locator['val'])
-
-    def __call__(self):
-        'Return the locations of the ticks.'
-        # axis calls Locator.set_axis inside set_m<xxxx>_formatter
-        vi = tuple(self.axis.get_view_interval())
-        if vi != self.plot_obj.view_interval:
-            self.plot_obj.date_axis_info = None
-        self.plot_obj.view_interval = vi
-        vmin, vmax = vi
-        if vmax < vmin:
-            vmin, vmax = vmax, vmin
-        if self.isdynamic:
-            locs = self._get_default_locs(vmin, vmax)
-        else: # pragma: no cover
-            base = self.base
-            (d, m) = divmod(vmin, base)
-            vmin = (d + 1) * base
-            locs = range(vmin, vmax + 1, base)
-        return locs
-
-    def autoscale(self):
-        """
-        Sets the view limits to the nearest multiples of base that contain the
-        data.
-        """
-        # requires matplotlib >= 0.98.0
-        (vmin, vmax) = self.axis.get_data_interval()
-
-        locs = self._get_default_locs(vmin, vmax)
-        (vmin, vmax) = locs[[0, -1]]
-        if vmin == vmax:
-            vmin -= 1
-            vmax += 1
-        return nonsingular(vmin, vmax)
-
-#####-------------------------------------------------------------------------
-#---- --- Formatter ---
-#####-------------------------------------------------------------------------
-class TimeSeries_DateFormatter(Formatter):
-    """
-    Formats the ticks along an axis controlled by a :class:`PeriodIndex`.
-
-    Parameters
-    ----------
-    freq : {int, string}
-        Valid frequency specifier.
-    minor_locator : {False, True}
-        Whether the current formatter should apply to minor ticks (True) or
-        major ticks (False).
-    dynamic_mode : {True, False}
-        Whether the formatter works in dynamic mode or not.
-    """
-
-    def __init__(self, freq, minor_locator=False, dynamic_mode=True,
-                 plot_obj=None):
-        if isinstance(freq, basestring):
-            freq = frequencies.get_freq(freq)
-        self.format = None
-        self.freq = freq
-        self.locs = []
-        self.formatdict = None
-        self.isminor = minor_locator
-        self.isdynamic = dynamic_mode
-        self.offset = 0
-        self.plot_obj = plot_obj
-        self.finder = get_finder(freq)
-
-    def _set_default_format(self, vmin, vmax):
-        "Returns the default ticks spacing."
-
-        if self.plot_obj.date_axis_info is None:
-            self.plot_obj.date_axis_info = self.finder(vmin, vmax, self.freq)
-        info = self.plot_obj.date_axis_info
-
-        if self.isminor:
-            format = np.compress(info['min'] & np.logical_not(info['maj']),
-                                 info)
-        else:
-            format = np.compress(info['maj'], info)
-        self.formatdict = dict([(x, f) for (x, _, _, f) in format])
-        return self.formatdict
-
-    def set_locs(self, locs):
-        'Sets the locations of the ticks'
-        # don't actually use the locs. This is just needed to work with
-        # matplotlib. Force to use vmin, vmax
-        self.locs = locs
-
-        (vmin, vmax) = vi = tuple(self.axis.get_view_interval())
-        if vi != self.plot_obj.view_interval:
-            self.plot_obj.date_axis_info = None
-        self.plot_obj.view_interval = vi
-        if vmax < vmin:
-            (vmin, vmax) = (vmax, vmin)
-        self._set_default_format(vmin, vmax)
-    #
-    def __call__(self, x, pos=0):
-        if self.formatdict is None:
-            return ''
-        else:
-            fmt = self.formatdict.pop(x, '')
-            return Period(ordinal=int(x), freq=self.freq).strftime(fmt)
-
 # Patch methods for subplot. Only format_dateaxis is currently used.
 # Do we need the rest for convenience?
 
@@ -739,23 +177,5 @@ def format_dateaxis(subplot, freq):
     pylab.draw_if_interactive()
 
 
-import matplotlib.units as units
-import matplotlib.dates as dates
-
-class PeriodConverter(dates.DateConverter):
-
-    @staticmethod
-    def convert(values, units, axis):
-        if not hasattr(axis, 'freq'):
-            raise TypeError('Axis must have `freq` set to convert to Periods')
-        valid_types = (str, datetime, Period, pydt.date, pydt.time)
-        if (isinstance(values, valid_types) or com.is_integer(values) or
-            com.is_float(values)):
-            return get_datevalue(values, axis.freq)
-        if isinstance(values, Index):
-            return values.map(lambda x: get_datevalue(x, axis.freq))
-        if isinstance(values, (list, tuple, np.ndarray)):
-            return [get_datevalue(x, axis.freq) for x in values]
-        return values
 
-units.registry[Period] = PeriodConverter()
+
diff --git a/pandas/tseries/tests/test_plotting.py b/pandas/tseries/tests/test_plotting.py
index af399ee83..2f2521140 100644
--- a/pandas/tseries/tests/test_plotting.py
+++ b/pandas/tseries/tests/test_plotting.py
@@ -201,42 +201,54 @@ class TestTSPlot(unittest.TestCase):
         idx = ax.get_lines()[0].get_xdata()
 
     @slow
-    def test_set_xlim(self):
+    def test_axis_limits(self):
+        def _test(ax):
+            xlim = ax.get_xlim()
+            ax.set_xlim(xlim[0] - 5, xlim[1] + 10)
+            ax.get_figure().canvas.draw()
+            result = ax.get_xlim()
+            self.assertEqual(result[0], xlim[0] - 5)
+            self.assertEqual(result[1], xlim[1] + 10)
+
+            # string
+            expected = (Period('1/1/2000', ax.freq),
+                        Period('4/1/2000', ax.freq))
+            ax.set_xlim('1/1/2000', '4/1/2000')
+            ax.get_figure().canvas.draw()
+            result = ax.get_xlim()
+            self.assertEqual(int(result[0]), expected[0].ordinal)
+            self.assertEqual(int(result[1]), expected[1].ordinal)
+
+            # datetim
+            expected = (Period('1/1/2000', ax.freq),
+                        Period('4/1/2000', ax.freq))
+            ax.set_xlim(datetime(2000, 1, 1), datetime(2000, 4, 1))
+            ax.get_figure().canvas.draw()
+            result = ax.get_xlim()
+            self.assertEqual(int(result[0]), expected[0].ordinal)
+            self.assertEqual(int(result[1]), expected[1].ordinal)
+
         ser = tm.makeTimeSeries()
         ax = ser.plot()
-        xlim = ax.get_xlim()
-        ax.set_xlim(xlim[0] - 5, xlim[1] + 10)
-        ax.get_figure().canvas.draw()
-        result = ax.get_xlim()
-        self.assertEqual(result[0], xlim[0] - 5)
-        self.assertEqual(result[1], xlim[1] + 10)
-
-        # string
-        expected = (Period('1/1/2000', ax.freq), Period('4/1/2000', ax.freq))
-        ax.set_xlim('1/1/2000', '4/1/2000')
-        ax.get_figure().canvas.draw()
-        result = ax.get_xlim()
-        self.assertEqual(int(result[0]), expected[0].ordinal)
-        self.assertEqual(int(result[1]), expected[1].ordinal)
-
-        # datetim
-        expected = (Period('1/1/2000', ax.freq), Period('4/1/2000', ax.freq))
-        ax.set_xlim(datetime(2000, 1, 1), datetime(2000, 4, 1))
-        ax.get_figure().canvas.draw()
-        result = ax.get_xlim()
-        self.assertEqual(int(result[0]), expected[0].ordinal)
-        self.assertEqual(int(result[1]), expected[1].ordinal)
+        _test(ax)
+
+        df = DataFrame({'a' : ser, 'b' : ser + 1})
+        ax = df.plot()
+        _test(ax)
+
+        df = DataFrame({'a' : ser, 'b' : ser + 1})
+        axes = df.plot(subplots=True)
+        [_test(ax) for ax in axes]
 
-    @slow
     def test_get_finder(self):
-        import pandas.tseries.plotting as plt
+        import pandas.tseries.converter as conv
 
-        self.assertEqual(plt.get_finder('B'), plt._daily_finder)
-        self.assertEqual(plt.get_finder('D'), plt._daily_finder)
-        self.assertEqual(plt.get_finder('M'), plt._monthly_finder)
-        self.assertEqual(plt.get_finder('Q'), plt._quarterly_finder)
-        self.assertEqual(plt.get_finder('A'), plt._annual_finder)
-        self.assertEqual(plt.get_finder('W'), plt._daily_finder)
+        self.assertEqual(conv.get_finder('B'), conv._daily_finder)
+        self.assertEqual(conv.get_finder('D'), conv._daily_finder)
+        self.assertEqual(conv.get_finder('M'), conv._monthly_finder)
+        self.assertEqual(conv.get_finder('Q'), conv._quarterly_finder)
+        self.assertEqual(conv.get_finder('A'), conv._annual_finder)
+        self.assertEqual(conv.get_finder('W'), conv._daily_finder)
 
     @slow
     def test_finder_daily(self):
@@ -409,6 +421,8 @@ class TestTSPlot(unittest.TestCase):
         ax2 = ser.plot(secondary_y=True)
         self.assert_(ax.get_yaxis().get_visible())
 
+        plt.close('all')
+
     @slow
     def test_secondary_y_ts(self):
         import matplotlib.pyplot as plt
@@ -585,6 +599,38 @@ class TestTSPlot(unittest.TestCase):
         for i in range(3):
             self.assert_(td[i].get_text() == str(idx[i]))
 
+    @slow
+    def test_time(self):
+        import matplotlib.pyplot as plt
+        plt.close('all')
+
+        t = datetime(1, 1, 1, 3, 30, 0)
+        deltas = np.random.randint(1, 20, 3).cumsum()
+        ts = np.array([(t + timedelta(minutes=int(x))).time() for x in deltas])
+        df = DataFrame({'a' : np.random.randn(len(ts)),
+                        'b' : np.random.randn(len(ts))},
+                       index=ts)
+        ax = df.plot()
+
+        # verify tick labels
+        ticks = ax.get_xticks()
+        labels = ax.get_xticklabels()
+        for t, l in zip(ticks, labels):
+            m, s = divmod(int(t), 60)
+            h, m = divmod(m, 60)
+            self.assert_(time(h, m, s).strftime('%H:%M:%S') == t.get_text())
+
+        # change xlim
+        ax.set_xlim('1:30', '5:00')
+
+        # check tick labels again
+        ticks = ax.get_xticks()
+        labels = ax.get_xticklabels()
+        for t, l in zip(ticks, labels):
+            m, s = divmod(int(t), 60)
+            h, m = divmod(m, 60)
+            self.assert_(time(h, m, s).strftime('%H:%M:%S') == t.get_text())
+
 PNG_PATH = 'tmp.png'
 def _check_plot_works(f, freq=None, series=None, *args, **kwargs):
     import matplotlib.pyplot as plt

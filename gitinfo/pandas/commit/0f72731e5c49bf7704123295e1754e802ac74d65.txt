commit 0f72731e5c49bf7704123295e1754e802ac74d65
Author: jreback <jeff@reback.net>
Date:   Wed Aug 7 15:04:26 2013 -0400

    BUG: (GH3830), panel assignment using loc with a transpose frame did not work

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 3d63e74fa..c43fcf3f7 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -131,6 +131,7 @@ pandas 0.13
     (:issue:`4170`, :issue:`4440`)
   - Fixed Panel slicing issued in ``xs`` that was returning an incorrect dimmed object
     (:issue:`4016`)
+  - Fixed Panel assignment with a transposed frame (:issue:`3830`)
 
 pandas 0.12
 ===========
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 4d64b058a..78567f871 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -208,12 +208,11 @@ class _NDFrameIndexer(object):
         raise ValueError('Incompatible indexer with Series')
 
     def _align_frame(self, indexer, df):
-        from pandas import DataFrame
-        is_frame = isinstance(self.obj, DataFrame)
-        if not is_frame:
-            df = df.T
+        is_frame = self.obj.ndim == 2
+        is_panel = self.obj.ndim >= 3
         if isinstance(indexer, tuple):
             idx, cols = None, None
+            sindexers = []
             for i, ix in enumerate(indexer):
                 ax = self.obj.axes[i]
                 if com._is_sequence(ix) or isinstance(ix, slice):
@@ -223,6 +222,16 @@ class _NDFrameIndexer(object):
                         cols = ax[ix].ravel()
                     else:
                         break
+                else:
+                    sindexers.append(i)
+
+            # panel
+            if is_panel:
+                if len(sindexers) == 1 and idx is None and cols is None:
+                    if sindexers[0] == 0:
+                        df = df.T
+                    return self.obj.conform(df,axis=sindexers[0])
+                df = df.T
 
             if idx is not None and cols is not None:
                 if df.index.equals(idx) and df.columns.equals(cols):
@@ -244,8 +253,18 @@ class _NDFrameIndexer(object):
             idx = self.obj.axes[1]
             cols = self.obj.axes[2]
 
+            # by definition we are indexing on the 0th axis
+            if is_panel:
+                df = df.T
+
             if idx.equals(df.index) and cols.equals(df.columns):
                 return df.copy().values
+
+            # a passed in dataframe which is actually a transpose
+            # of what is needed
+            elif idx.equals(df.columns) and cols.equals(df.index):
+                return df.T.copy().values
+
             return df.reindex(idx, columns=cols).values
 
         raise ValueError('Incompatible indexer with DataFrame')
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index 94afac7d9..3d2a5f2e5 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -655,6 +655,31 @@ class CheckIndexing(object):
         out = p.ix[0, [0, 1, 3, 5], -2:]
         assert_frame_equal(out, df.T.reindex([0, 1, 3, 5], p.minor_axis[-2:]))
 
+        # GH3830, panel assignent by values/frame
+        for dtype in ['float64','int64']:
+
+            panel = Panel(np.arange(40).reshape((2,4,5)), items=['a1','a2'], dtype=dtype)
+            df1 = panel.iloc[0]
+            df2 = panel.iloc[1]
+
+            tm.assert_frame_equal(panel.loc['a1'], df1)
+            tm.assert_frame_equal(panel.loc['a2'], df2)
+
+            # Assignment by Value Passes for 'a2'
+            panel.loc['a2'] = df1.values
+            tm.assert_frame_equal(panel.loc['a1'], df1)
+            tm.assert_frame_equal(panel.loc['a2'], df1)
+
+            # Assignment by DataFrame Ok w/o loc 'a2'
+            panel['a2'] = df2
+            tm.assert_frame_equal(panel.loc['a1'], df1)
+            tm.assert_frame_equal(panel.loc['a2'], df2)
+
+            # Assignment by DataFrame Fails for 'a2'
+            panel.loc['a2'] = df2
+            tm.assert_frame_equal(panel.loc['a1'], df1)
+            tm.assert_frame_equal(panel.loc['a2'], df2)
+
     def _check_view(self, indexer, comp):
         cp = self.panel.copy()
         obj = cp.ix[indexer]

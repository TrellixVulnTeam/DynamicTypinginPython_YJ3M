commit 7d2603d2244c6f82cda7f8e24c7f6bb0b1c37ede
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Apr 4 23:44:36 2012 -0400

    TST: interactions between array of datetime objects and DatetimeIndex, bug fixes

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 8d3e63c8a..d45d0f234 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -775,7 +775,7 @@ def ole2datetime(oledt):
     return OLE_TIME_ZERO + timedelta(days=val)
 
 
-class DateParseError(Exception):
+class DateParseError(ValueError):
     pass
 
 _dtparser = parser.parser()
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 134aa3650..f24b60a09 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1533,6 +1533,20 @@ class DatetimeIndex(Int64Index):
         else:
             return Index.union(self, other)
 
+    def join(self, other, how='left', level=None, return_indexers=False):
+        """
+        See Index.join
+        """
+        if not isinstance(other, DatetimeIndex) and len(other) > 0:
+            try:
+                other = DatetimeIndex(other)
+            except ValueError:
+                pass
+
+        return Index.join(self, other, how=how, level=level,
+                          return_indexers=return_indexers)
+
+
     def _wrap_joined_index(self, joined, other):
         name = self.name if self.name == other.name else None
         if (isinstance(other, DatetimeIndex)
@@ -1545,6 +1559,9 @@ class DatetimeIndex(Int64Index):
             return DatetimeIndex(joined, name=name)
 
     def _can_fast_union(self, other):
+        if not isinstance(other, DatetimeIndex):
+            return False
+
         offset = self.offset
 
         if offset is None:
@@ -1612,8 +1629,14 @@ class DatetimeIndex(Int64Index):
         -------
         y : Index or DatetimeIndex
         """
-        if other.offset != self.offset:
-            return super(DatetimeIndex, self).intersection(self, other)
+        if not isinstance(other, DatetimeIndex):
+            try:
+                other = DatetimeIndex(other)
+            except TypeError:
+                pass
+            return Index.intersection(self, other)
+        elif other.offset != self.offset:
+            return Index.intersection(self, other)
 
         # to make our life easier, "sort" the two ranges
         if self[0] <= other[0]:
diff --git a/pandas/tests/test_timeseries.py b/pandas/tests/test_timeseries.py
index 1b96f656a..9b72fb2bd 100644
--- a/pandas/tests/test_timeseries.py
+++ b/pandas/tests/test_timeseries.py
@@ -270,17 +270,82 @@ class TestLegacyInteraction(unittest.TestCase):
         self.assertEquals(unpickled.index.offset, BDay(1))
 
     def test_arithmetic_interaction(self):
-        pass
+        index = self.frame.index
+        obj_index = index.asobject
+
+        dseries = Series(rand(len(index)), index=index)
+        oseries = Series(dseries.values, index=obj_index)
+
+        result = dseries + oseries
+        expected = dseries * 2
+        self.assert_(isinstance(result.index, DatetimeIndex))
+        assert_series_equal(result, expected)
+
+        result = dseries + oseries[:5]
+        expected = dseries + dseries[:5]
+        self.assert_(isinstance(result.index, DatetimeIndex))
+        assert_series_equal(result, expected)
 
     def test_join_interaction(self):
-        pass
+        index = self.frame.index
+        obj_index = index.asobject
+
+        def _check_join(left, right, how='inner'):
+            ra, rb, rc = left.join(right, how=how, return_indexers=True)
+            ea, eb, ec = left.join(DatetimeIndex(right), how=how,
+                                   return_indexers=True)
+
+            self.assert_(isinstance(ra, DatetimeIndex))
+            self.assert_(ra.equals(ea))
+
+            assert_almost_equal(rb, eb)
+            assert_almost_equal(rc, ec)
+
+        _check_join(index[:15], obj_index[5:], how='inner')
+        _check_join(index[:15], obj_index[5:], how='outer')
+        _check_join(index[:15], obj_index[5:], how='right')
+        _check_join(index[:15], obj_index[5:], how='left')
 
     def test_setops(self):
-        pass
+        index = self.frame.index
+        obj_index = index.asobject
+
+        result = index[:5].union(obj_index[5:])
+        expected = index
+        self.assert_(isinstance(result, DatetimeIndex))
+        self.assert_(result.equals(expected))
+
+        result = index[:10].intersection(obj_index[5:])
+        expected = index[5:10]
+        self.assert_(isinstance(result, DatetimeIndex))
+        self.assert_(result.equals(expected))
+
+        result = index[:10] - obj_index[5:]
+        expected = index[:5]
+        self.assert_(isinstance(result, DatetimeIndex))
+        self.assert_(result.equals(expected))
 
     def test_index_conversion(self):
-        pass
+        index = self.frame.index
+        obj_index = index.asobject
+
+        conv = DatetimeIndex(obj_index)
+        self.assert_(conv.equals(index))
+
+        self.assertRaises(ValueError, DatetimeIndex, ['a', 'b', 'c', 'd'])
+
+    def test_setops_conversion_fail(self):
+        index = self.frame.index
+
+        right = Index(['a', 'b', 'c', 'd'])
+
+        result = index.union(right)
+        expected = Index(np.concatenate([index.asobject, right]))
+        self.assert_(result.equals(expected))
 
+        result = index.intersection(right)
+        expected = Index([])
+        self.assert_(result.equals(expected))
 
 
 class TestDatetime64(unittest.TestCase):

commit e4a553a1396e45b78a8ec9e01d3023f0ff97d1f8
Author: Kevin Bowey <kwbowey@gmail.com>
Date:   Wed Jun 24 00:08:39 2020 +0200

    TST: disallow bare pytest raises (#34940)

diff --git a/pandas/tests/frame/methods/test_assign.py b/pandas/tests/frame/methods/test_assign.py
index 63b9f031d..0ae501d43 100644
--- a/pandas/tests/frame/methods/test_assign.py
+++ b/pandas/tests/frame/methods/test_assign.py
@@ -65,9 +65,11 @@ class TestAssign:
         df = DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]})
 
         # non-keyword argument
-        with pytest.raises(TypeError):
+        msg = r"assign\(\) takes 1 positional argument but 2 were given"
+        with pytest.raises(TypeError, match=msg):
             df.assign(lambda x: x.A)
-        with pytest.raises(AttributeError):
+        msg = "'DataFrame' object has no attribute 'C'"
+        with pytest.raises(AttributeError, match=msg):
             df.assign(C=df.A, D=df.A + df.C)
 
     def test_assign_dependent(self):
diff --git a/pandas/tests/frame/methods/test_at_time.py b/pandas/tests/frame/methods/test_at_time.py
index 71368f270..ac98d632c 100644
--- a/pandas/tests/frame/methods/test_at_time.py
+++ b/pandas/tests/frame/methods/test_at_time.py
@@ -65,7 +65,8 @@ class TestAtTime:
     def test_at_time_raises(self):
         # GH#20725
         df = DataFrame([[1, 2, 3], [4, 5, 6]])
-        with pytest.raises(TypeError):  # index is not a DatetimeIndex
+        msg = "Index must be DatetimeIndex"
+        with pytest.raises(TypeError, match=msg):  # index is not a DatetimeIndex
             df.at_time("00:00")
 
     @pytest.mark.parametrize("axis", ["index", "columns", 0, 1])
diff --git a/pandas/tests/frame/methods/test_between_time.py b/pandas/tests/frame/methods/test_between_time.py
index b40604b4f..19e802d0f 100644
--- a/pandas/tests/frame/methods/test_between_time.py
+++ b/pandas/tests/frame/methods/test_between_time.py
@@ -68,7 +68,8 @@ class TestBetweenTime:
     def test_between_time_raises(self):
         # GH#20725
         df = DataFrame([[1, 2, 3], [4, 5, 6]])
-        with pytest.raises(TypeError):  # index is not a DatetimeIndex
+        msg = "Index must be DatetimeIndex"
+        with pytest.raises(TypeError, match=msg):  # index is not a DatetimeIndex
             df.between_time(start_time="00:00", end_time="12:00")
 
     def test_between_time_axis(self, axis):
diff --git a/pandas/tests/frame/methods/test_first_and_last.py b/pandas/tests/frame/methods/test_first_and_last.py
index 73e4128dd..2b3756969 100644
--- a/pandas/tests/frame/methods/test_first_and_last.py
+++ b/pandas/tests/frame/methods/test_first_and_last.py
@@ -31,7 +31,8 @@ class TestFirst:
     def test_first_raises(self):
         # GH#20725
         df = DataFrame([[1, 2, 3], [4, 5, 6]])
-        with pytest.raises(TypeError):  # index is not a DatetimeIndex
+        msg = "'first' only supports a DatetimeIndex index"
+        with pytest.raises(TypeError, match=msg):  # index is not a DatetimeIndex
             df.first("1D")
 
     def test_last_subset(self):
@@ -57,5 +58,6 @@ class TestFirst:
     def test_last_raises(self):
         # GH20725
         df = DataFrame([[1, 2, 3], [4, 5, 6]])
-        with pytest.raises(TypeError):  # index is not a DatetimeIndex
+        msg = "'last' only supports a DatetimeIndex index"
+        with pytest.raises(TypeError, match=msg):  # index is not a DatetimeIndex
             df.last("1D")
diff --git a/pandas/tests/frame/methods/test_interpolate.py b/pandas/tests/frame/methods/test_interpolate.py
index efb3d7190..facb11664 100644
--- a/pandas/tests/frame/methods/test_interpolate.py
+++ b/pandas/tests/frame/methods/test_interpolate.py
@@ -43,7 +43,14 @@ class TestDataFrameInterpolate:
                 "D": list("abcd"),
             }
         )
-        with pytest.raises(ValueError):
+        msg = (
+            r"method must be one of \['linear', 'time', 'index', 'values', "
+            r"'nearest', 'zero', 'slinear', 'quadratic', 'cubic', "
+            r"'barycentric', 'krogh', 'spline', 'polynomial', "
+            r"'from_derivatives', 'piecewise_polynomial', 'pchip', 'akima', "
+            r"'cubicspline'\]. Got 'not_a_method' instead."
+        )
+        with pytest.raises(ValueError, match=msg):
             df.interpolate(method="not_a_method")
 
     def test_interp_combo(self):
@@ -67,7 +74,11 @@ class TestDataFrameInterpolate:
     def test_interp_nan_idx(self):
         df = DataFrame({"A": [1, 2, np.nan, 4], "B": [np.nan, 2, 3, 4]})
         df = df.set_index("A")
-        with pytest.raises(NotImplementedError):
+        msg = (
+            "Interpolation with NaNs in the index has not been implemented. "
+            "Try filling those NaNs before interpolating."
+        )
+        with pytest.raises(NotImplementedError, match=msg):
             df.interpolate(method="values")
 
     @td.skip_if_no_scipy
diff --git a/pandas/tests/frame/methods/test_replace.py b/pandas/tests/frame/methods/test_replace.py
index 3bcc26e85..3b9a724d7 100644
--- a/pandas/tests/frame/methods/test_replace.py
+++ b/pandas/tests/frame/methods/test_replace.py
@@ -1314,7 +1314,11 @@ class TestDataFrameReplace:
         expected = DataFrame({"a": a, "b": b})
         result = df.replace(replace_dict, 3)
         tm.assert_frame_equal(result, expected)
-        with pytest.raises(AssertionError):
+        msg = (
+            r"Attributes of DataFrame.iloc\[:, 0\] \(column name=\"a\"\) are "
+            "different"
+        )
+        with pytest.raises(AssertionError, match=msg):
             # ensure non-inplace call does not affect original
             tm.assert_frame_equal(df, expected)
         df.replace(replace_dict, 3, inplace=True)
diff --git a/pandas/tests/frame/test_query_eval.py b/pandas/tests/frame/test_query_eval.py
index 89f268f8b..98a2a3382 100644
--- a/pandas/tests/frame/test_query_eval.py
+++ b/pandas/tests/frame/test_query_eval.py
@@ -71,9 +71,14 @@ class TestCompat:
             result = df.eval("A+1", engine="numexpr")
             tm.assert_series_equal(result, self.expected2, check_names=False)
         else:
-            with pytest.raises(ImportError):
+            msg = (
+                r"'numexpr' is not installed or an unsupported version. "
+                r"Cannot use engine='numexpr' for query/eval if 'numexpr' is "
+                r"not installed"
+            )
+            with pytest.raises(ImportError, match=msg):
                 df.query("A>0", engine="numexpr")
-            with pytest.raises(ImportError):
+            with pytest.raises(ImportError, match=msg):
                 df.eval("A+1", engine="numexpr")
 
 
@@ -452,14 +457,16 @@ class TestDataFrameQueryNumExprPandas:
         result = df.query("dates != nondate", parser=parser, engine=engine)
         tm.assert_frame_equal(result, df)
 
+        msg = r"Invalid comparison between dtype=datetime64\[ns\] and ndarray"
         for op in ["<", ">", "<=", ">="]:
-            with pytest.raises(TypeError):
+            with pytest.raises(TypeError, match=msg):
                 df.query(f"dates {op} nondate", parser=parser, engine=engine)
 
     def test_query_syntax_error(self):
         engine, parser = self.engine, self.parser
         df = DataFrame({"i": range(10), "+": range(3, 13), "r": range(4, 14)})
-        with pytest.raises(SyntaxError):
+        msg = "invalid syntax"
+        with pytest.raises(SyntaxError, match=msg):
             df.query("i - +", engine=engine, parser=parser)
 
     def test_query_scope(self):
@@ -781,7 +788,8 @@ class TestDataFrameQueryNumExprPython(TestDataFrameQueryNumExprPandas):
         df["dates3"] = date_range("1/1/2014", periods=n)
         df.loc[np.random.rand(n) > 0.5, "dates1"] = pd.NaT
         df.set_index("dates1", inplace=True, drop=True)
-        with pytest.raises(NotImplementedError):
+        msg = r"'BoolOp' nodes are not implemented"
+        with pytest.raises(NotImplementedError, match=msg):
             df.query("index < 20130101 < dates3", engine=engine, parser=parser)
 
     def test_nested_scope(self):
@@ -798,7 +806,8 @@ class TestDataFrameQueryNumExprPython(TestDataFrameQueryNumExprPandas):
         df2 = DataFrame(np.random.randn(5, 3))
 
         # don't have the pandas parser
-        with pytest.raises(SyntaxError):
+        msg = r"The '@' prefix is only supported by the pandas parser"
+        with pytest.raises(SyntaxError, match=msg):
             df.query("(@df>0) & (@df2>0)", engine=engine, parser=parser)
 
         with pytest.raises(UndefinedVariableError, match="name 'df' is not defined"):
@@ -867,10 +876,10 @@ class TestDataFrameQueryStrings:
 
             eq, ne = "==", "!="
             ops = 2 * ([eq] + [ne])
+            msg = r"'(Not)?In' nodes are not implemented"
 
             for lhs, op, rhs in zip(lhs, ops, rhs):
                 ex = f"{lhs} {op} {rhs}"
-                msg = r"'(Not)?In' nodes are not implemented"
                 with pytest.raises(NotImplementedError, match=msg):
                     df.query(
                         ex,
@@ -908,10 +917,11 @@ class TestDataFrameQueryStrings:
 
             eq, ne = "==", "!="
             ops = 2 * ([eq] + [ne])
+            msg = r"'(Not)?In' nodes are not implemented"
 
             for lhs, op, rhs in zip(lhs, ops, rhs):
                 ex = f"{lhs} {op} {rhs}"
-                with pytest.raises(NotImplementedError):
+                with pytest.raises(NotImplementedError, match=msg):
                     df.query(ex, engine=engine, parser=parser)
         else:
             res = df.query('strings == ["a", "b"]', engine=engine, parser=parser)
@@ -946,10 +956,12 @@ class TestDataFrameQueryStrings:
             expec = df[df.a.isin(df.b) & (df.c < df.d)]
             tm.assert_frame_equal(res, expec)
         else:
-            with pytest.raises(NotImplementedError):
+            msg = r"'(Not)?In' nodes are not implemented"
+            with pytest.raises(NotImplementedError, match=msg):
                 df.query("a in b", parser=parser, engine=engine)
 
-            with pytest.raises(NotImplementedError):
+            msg = r"'BoolOp' nodes are not implemented"
+            with pytest.raises(NotImplementedError, match=msg):
                 df.query("a in b and c < d", parser=parser, engine=engine)
 
     def test_object_array_eq_ne(self, parser, engine):
@@ -1186,15 +1198,18 @@ class TestDataFrameQueryBacktickQuoting:
             df.eval("@pd.thing")
 
     def test_failing_quote(self, df):
-        with pytest.raises(SyntaxError):
+        msg = r"(Could not convert ).*( to a valid Python identifier.)"
+        with pytest.raises(SyntaxError, match=msg):
             df.query("`it's` > `that's`")
 
     def test_failing_character_outside_range(self, df):
-        with pytest.raises(SyntaxError):
+        msg = r"(Could not convert ).*( to a valid Python identifier.)"
+        with pytest.raises(SyntaxError, match=msg):
             df.query("`☺` > 4")
 
     def test_failing_hashtag(self, df):
-        with pytest.raises(SyntaxError):
+        msg = "Failed to parse backticks"
+        with pytest.raises(SyntaxError, match=msg):
             df.query("`foo#bar` > 4")
 
     def test_call_non_named_expression(self, df):

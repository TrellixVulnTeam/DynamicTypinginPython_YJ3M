commit 10a5171fe82d6725e5502d45865be95ebb95d3ab
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Feb 17 20:48:35 2012 -0500

    BUG: disable position-based slicing altogether if a dtype=object contains any integer objects, augment infer_dtype, GH #798

diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 40eae0b49..6ed5d285d 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -243,23 +243,25 @@ class _NDFrameIndexer(object):
                               and not labels.inferred_type == 'integer'
                               and not isinstance(labels, MultiIndex))
 
+            start, stop = obj.start, obj.stop
 
             # last ditch effort: if we are mixed and have integers
             try:
-                if labels.inferred_type == 'mixed' and int_slice:
-                    if obj.start is not None:
-                        i = labels.get_loc(obj.start)
-                    if obj.stop is not None:
-                        j = labels.get_loc(obj.stop)
+                if 'mixed' in labels.inferred_type and int_slice:
+                    if start is not None:
+                        i = labels.get_loc(start)
+                    if stop is not None:
+                        j = labels.get_loc(stop)
                     position_slice = False
             except KeyError:
-                pass
+                if labels.inferred_type == 'mixed-integer':
+                    raise
 
             if null_slice or position_slice:
                 slicer = obj
             else:
                 try:
-                    i, j = labels.slice_locs(obj.start, obj.stop)
+                    i, j = labels.slice_locs(start, stop)
                     slicer = slice(i, j, obj.step)
                 except Exception:
                     if _is_index_slice(obj):
@@ -316,20 +318,22 @@ class _NDFrameIndexer(object):
 
         # could have integers in the first level of the MultiIndex, in which
         # case we wouldn't want to do position-based slicing
-        position_slice = (int_slice and not labels.inferred_type == 'integer'
+        position_slice = (int_slice
+                          and labels.inferred_type != 'integer'
                           and not isinstance(labels, MultiIndex)
                           and not float_slice)
 
         # last ditch effort: if we are mixed and have integers
         try:
-            if labels.inferred_type == 'mixed' and int_slice:
+            if 'mixed' in labels.inferred_type and int_slice:
                 if start is not None:
                     i = labels.get_loc(start)
                 if stop is not None:
                     j = labels.get_loc(stop)
                 position_slice = False
         except KeyError:
-            pass
+            if labels.inferred_type == 'mixed-integer':
+                raise
 
         if null_slice or position_slice:
             slicer = slice_obj
diff --git a/pandas/src/inference.pyx b/pandas/src/inference.pyx
index e10730757..281ad0eee 100644
--- a/pandas/src/inference.pyx
+++ b/pandas/src/inference.pyx
@@ -29,7 +29,7 @@ except AttributeError:
 def infer_dtype(object _values):
     cdef:
         Py_ssize_t i, n
-        object test_val
+        object val
         ndarray values
 
     if isinstance(_values, np.ndarray):
@@ -50,29 +50,34 @@ def infer_dtype(object _values):
     if values.dtype != np.object_:
         values = values.astype('O')
 
-    test_val = util.get_value_1d(values, 0)
+    val = util.get_value_1d(values, 0)
 
-    if util.is_integer_object(test_val):
+    if util.is_integer_object(val):
         if is_integer_array(values):
             return 'integer'
-
-    elif is_datetime(test_val):
+        return 'mixed-integer'
+    elif is_datetime(val):
         if is_datetime_array(values):
             return 'datetime'
 
-    elif util.is_float_object(test_val):
+    elif util.is_float_object(val):
         if is_float_array(values):
 
             return 'floating'
 
-    elif util.is_bool_object(test_val):
+    elif util.is_bool_object(val):
         if is_bool_array(values):
             return 'boolean'
 
-    elif util.is_string_object(test_val):
+    elif util.is_string_object(val):
         if is_string_array(values):
             return 'string'
 
+    for i in range(n):
+        val = util.get_value_1d(values, i)
+        if util.is_integer_object(val):
+            return 'mixed-integer'
+
     return 'mixed'
 
 def infer_dtype_list(list values):
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index a8dcd7229..5fd54466d 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -811,6 +811,10 @@ class CheckIndexing(object):
         assert_frame_equal(result, expected)
         self.assertEqual(len(result), 2)
 
+        # this should raise an exception
+        self.assertRaises(Exception, df.ix.__getitem__, slice(1, 2))
+        self.assertRaises(Exception, df.ix.__setitem__, slice(1, 2), 0)
+
     def test_setitem_single_column_mixed(self):
         df = DataFrame(randn(5, 3), index=['a', 'b', 'c', 'd', 'e'],
                        columns=['foo', 'bar', 'baz'])
diff --git a/pandas/tests/test_tseries.py b/pandas/tests/test_tseries.py
index 5f8f5c226..3083a9b12 100644
--- a/pandas/tests/test_tseries.py
+++ b/pandas/tests/test_tseries.py
@@ -299,7 +299,7 @@ class TestTypeInference(unittest.TestCase):
         arr = np.array([1, 2, 3, np.int64(4), np.int32(5), 'foo'],
                        dtype='O')
         result = lib.infer_dtype(arr)
-        self.assertEqual(result, 'mixed')
+        self.assertEqual(result, 'mixed-integer')
 
         arr = np.array([1, 2, 3, 4, 5], dtype='i4')
         result = lib.infer_dtype(arr)
@@ -330,7 +330,7 @@ class TestTypeInference(unittest.TestCase):
         arr = np.array([1, 2, 3, np.float64(4), np.float32(5), 'foo'],
                        dtype='O')
         result = lib.infer_dtype(arr)
-        self.assertEqual(result, 'mixed')
+        self.assertEqual(result, 'mixed-integer')
 
         arr = np.array([1, 2, 3, 4, 5], dtype='f4')
         result = lib.infer_dtype(arr)

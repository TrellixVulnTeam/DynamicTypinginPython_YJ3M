commit 712a085e3986ddc59af3f89e7f7fdf3578669ac2
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Wed Jul 11 17:13:55 2018 -0700

    CLN: miscellaneous cleanups / fixes (#21861)

diff --git a/doc/source/whatsnew/v0.24.0.txt b/doc/source/whatsnew/v0.24.0.txt
index 034a56b2a..00379c7e9 100644
--- a/doc/source/whatsnew/v0.24.0.txt
+++ b/doc/source/whatsnew/v0.24.0.txt
@@ -301,6 +301,7 @@ Datetimelike
 ^^^^^^^^^^^^
 
 - Fixed bug where two :class:`DateOffset` objects with different ``normalize`` attributes could evaluate as equal (:issue:`21404`)
+- Fixed bug where :meth:`Timestamp.resolution` incorrectly returned 1-microsecond ``timedelta`` instead of 1-nanosecond :class:`Timedelta` (:issue:`21336`,:issue:`21365`)
 
 Timedelta
 ^^^^^^^^^
@@ -369,6 +370,7 @@ Missing
 ^^^^^^^
 
 - Bug in :func:`DataFrame.fillna` where a ``ValueError`` would raise when one column contained a ``datetime64[ns, tz]`` dtype (:issue:`15522`)
+- Bug in :func:`Series.hasnans` that could be incorrectly cached and return incorrect answers if null elements are introduced after an initial call (:issue:`19700`)
 
 MultiIndex
 ^^^^^^^^^^
diff --git a/pandas/_libs/tslibs/timestamps.pyx b/pandas/_libs/tslibs/timestamps.pyx
index 711db7cc8..864950ff0 100644
--- a/pandas/_libs/tslibs/timestamps.pyx
+++ b/pandas/_libs/tslibs/timestamps.pyx
@@ -407,6 +407,15 @@ cdef class _Timestamp(datetime):
     def asm8(self):
         return np.datetime64(self.value, 'ns')
 
+    @property
+    def resolution(self):
+        """
+        Return resolution describing the smallest difference between two
+        times that can be represented by Timestamp object_state
+        """
+        # GH#21336, GH#21365
+        return Timedelta(nanoseconds=1)
+
     def timestamp(self):
         """Return POSIX timestamp as float."""
         # py27 compat, see GH#17329
diff --git a/pandas/core/dtypes/inference.py b/pandas/core/dtypes/inference.py
index d747e69d1..a0456630c 100644
--- a/pandas/core/dtypes/inference.py
+++ b/pandas/core/dtypes/inference.py
@@ -278,10 +278,15 @@ def is_list_like(obj):
     False
     >>> is_list_like(1)
     False
+    >>> is_list_like(np.array([2]))
+    True
+    >>> is_list_like(np.array(2)))
+    False
     """
 
     return (isinstance(obj, Iterable) and
-            not isinstance(obj, string_and_binary_types))
+            not isinstance(obj, string_and_binary_types) and
+            not (isinstance(obj, np.ndarray) and obj.ndim == 0))
 
 
 def is_array_like(obj):
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 4e6ddf641..638094433 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -7679,6 +7679,9 @@ def _prep_ndarray(values, copy=True):
         try:
             if is_list_like(values[0]) or hasattr(values[0], 'len'):
                 values = np.array([convert(v) for v in values])
+            elif isinstance(values[0], np.ndarray) and values[0].ndim == 0:
+                # GH#21861
+                values = np.array([convert(v) for v in values])
             else:
                 values = convert(values)
         except:
diff --git a/pandas/core/indexes/datetimes.py b/pandas/core/indexes/datetimes.py
index b8a89ac26..217bb3e7d 100644
--- a/pandas/core/indexes/datetimes.py
+++ b/pandas/core/indexes/datetimes.py
@@ -93,7 +93,7 @@ def _dt_index_cmp(opname, cls):
     def wrapper(self, other):
         func = getattr(super(DatetimeIndex, self), opname)
 
-        if isinstance(other, (datetime, compat.string_types)):
+        if isinstance(other, (datetime, np.datetime64, compat.string_types)):
             if isinstance(other, datetime):
                 # GH#18435 strings get a pass from tzawareness compat
                 self._assert_tzawareness_compat(other)
@@ -105,8 +105,7 @@ def _dt_index_cmp(opname, cls):
         else:
             if isinstance(other, list):
                 other = DatetimeIndex(other)
-            elif not isinstance(other, (np.datetime64, np.ndarray,
-                                        Index, ABCSeries)):
+            elif not isinstance(other, (np.ndarray, Index, ABCSeries)):
                 # Following Timestamp convention, __eq__ is all-False
                 # and __ne__ is all True, others raise TypeError.
                 if opname == '__eq__':
diff --git a/pandas/core/series.py b/pandas/core/series.py
index a63c4be98..0bdb9d9cc 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -166,6 +166,10 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         ['asobject', 'sortlevel', 'reshape', 'get_value', 'set_value',
          'from_csv', 'valid'])
 
+    # Override cache_readonly bc Series is mutable
+    hasnans = property(base.IndexOpsMixin.hasnans.func,
+                       doc=base.IndexOpsMixin.hasnans.__doc__)
+
     def __init__(self, data=None, index=None, dtype=None, name=None,
                  copy=False, fastpath=False):
 
diff --git a/pandas/core/tools/timedeltas.py b/pandas/core/tools/timedeltas.py
index 29618fb4d..ed2659973 100644
--- a/pandas/core/tools/timedeltas.py
+++ b/pandas/core/tools/timedeltas.py
@@ -85,7 +85,7 @@ def to_timedelta(arg, unit='ns', box=True, errors='raise'):
     elif isinstance(arg, ABCIndexClass):
         return _convert_listlike(arg, unit=unit, box=box,
                                  errors=errors, name=arg.name)
-    elif is_list_like(arg) and getattr(arg, 'ndim', 1) == 0:
+    elif isinstance(arg, np.ndarray) and arg.ndim == 0:
         # extract array scalar and process below
         arg = arg.item()
     elif is_list_like(arg) and getattr(arg, 'ndim', 1) == 1:
diff --git a/pandas/tests/dtypes/test_inference.py b/pandas/tests/dtypes/test_inference.py
index 65527ac1b..f81767156 100644
--- a/pandas/tests/dtypes/test_inference.py
+++ b/pandas/tests/dtypes/test_inference.py
@@ -67,13 +67,14 @@ def test_is_sequence():
     [
         [], [1], (1, ), (1, 2), {'a': 1},
         set([1, 'a']), Series([1]),
-        Series([]), Series(['a']).str])
+        Series([]), Series(['a']).str,
+        np.array([2])])
 def test_is_list_like_passes(ll):
     assert inference.is_list_like(ll)
 
 
 @pytest.mark.parametrize(
-    "ll", [1, '2', object(), str])
+    "ll", [1, '2', object(), str, np.array(2)])
 def test_is_list_like_fails(ll):
     assert not inference.is_list_like(ll)
 
diff --git a/pandas/tests/scalar/timestamp/test_timestamp.py b/pandas/tests/scalar/timestamp/test_timestamp.py
index 527205916..4172bfd41 100644
--- a/pandas/tests/scalar/timestamp/test_timestamp.py
+++ b/pandas/tests/scalar/timestamp/test_timestamp.py
@@ -172,6 +172,11 @@ class TestTimestampProperties(object):
                                2005, 1, 1), (2005, 1, 2)]])
         assert (result == [52, 52, 53, 53]).all()
 
+    def test_resolution(self):
+        # GH#21336, GH#21365
+        dt = Timestamp('2100-01-01 00:00:00')
+        assert dt.resolution == Timedelta(nanoseconds=1)
+
 
 class TestTimestampConstructors(object):
 
diff --git a/pandas/tests/series/test_internals.py b/pandas/tests/series/test_internals.py
index 79e23459a..506e7e14f 100644
--- a/pandas/tests/series/test_internals.py
+++ b/pandas/tests/series/test_internals.py
@@ -11,6 +11,7 @@ import numpy as np
 from pandas import Series
 from pandas.core.indexes.datetimes import Timestamp
 import pandas._libs.lib as lib
+import pandas as pd
 
 from pandas.util.testing import assert_series_equal
 import pandas.util.testing as tm
@@ -309,3 +310,16 @@ class TestSeriesInternals(object):
         r = s._convert(datetime=True, numeric=True)
         e = Series([False, True, False, False], dtype=bool)
         tm.assert_series_equal(r, e)
+
+
+def test_hasnans_unchached_for_series():
+    # GH#19700
+    idx = pd.Index([0, 1])
+    assert not idx.hasnans
+    assert 'hasnans' in idx._cache
+    ser = idx.to_series()
+    assert not ser.hasnans
+    assert not hasattr(ser, '_cache')
+    ser.iloc[-1] = np.nan
+    assert ser.hasnans
+    assert pd.Series.hasnans.__doc__ == pd.Index.hasnans.__doc__

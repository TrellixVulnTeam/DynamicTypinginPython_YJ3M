commit 6d7ba051508b93fbbc80f6929ed6f2254ab7b938
Author: topper-123 <contribute@tensortable.com>
Date:   Wed May 8 06:18:39 2019 +0200

    CLN;: remove compat.lzip (#26311)
    
    xref gh-25725

diff --git a/pandas/compat/__init__.py b/pandas/compat/__init__.py
index 8ff319802..90444efd2 100644
--- a/pandas/compat/__init__.py
+++ b/pandas/compat/__init__.py
@@ -5,7 +5,7 @@ compat
 Cross-compatible functions for different versions of Python.
 
 Key items to import for compatible code:
-* lists: lrange(), lmap(), lzip()
+* lists: lrange(), lmap()
 
 Other items:
 * platform checker
@@ -24,10 +24,6 @@ def lrange(*args, **kwargs):
     return list(range(*args, **kwargs))
 
 
-def lzip(*args, **kwargs):
-    return list(zip(*args, **kwargs))
-
-
 def lmap(*args, **kwargs):
     return list(map(*args, **kwargs))
 
diff --git a/pandas/core/arrays/categorical.py b/pandas/core/arrays/categorical.py
index 40d71c087..4ce2b0457 100644
--- a/pandas/core/arrays/categorical.py
+++ b/pandas/core/arrays/categorical.py
@@ -7,7 +7,6 @@ import numpy as np
 from pandas._config import get_option
 
 from pandas._libs import algos as libalgos, lib
-from pandas.compat import lzip
 from pandas.compat.numpy import function as nv
 from pandas.util._decorators import (
     Appender, Substitution, cache_readonly, deprecate_kwarg)
@@ -2706,4 +2705,4 @@ def _factorize_from_iterables(iterables):
     if len(iterables) == 0:
         # For consistency, it should return a list of 2 lists.
         return [[], []]
-    return map(list, lzip(*[_factorize_from_iterable(it) for it in iterables]))
+    return map(list, zip(*(_factorize_from_iterable(it) for it in iterables)))
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index ac4e1b8f1..805a35570 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -31,7 +31,7 @@ from pandas.util._decorators import (Appender, Substitution,
 from pandas.util._validators import (validate_bool_kwarg,
                                      validate_axis_style_args)
 
-from pandas.compat import PY36, lmap, lzip, raise_with_traceback
+from pandas.compat import PY36, lmap, raise_with_traceback
 from pandas.compat.numpy import function as nv
 from pandas.core.dtypes.cast import (
     maybe_upcast,
@@ -1752,7 +1752,7 @@ class DataFrame(NDFrame):
                       "preserve the key order.",
                       FutureWarning, stacklevel=2)
 
-        keys, values = lzip(*items)
+        keys, values = zip(*items)
 
         if orient == 'columns':
             if columns is not None:
@@ -4433,7 +4433,7 @@ class DataFrame(NDFrame):
             if isinstance(self.index, MultiIndex):
                 names = [n if n is not None else ('level_%d' % i)
                          for (i, n) in enumerate(self.index.names)]
-                to_insert = lzip(self.index.levels, self.index.codes)
+                to_insert = zip(self.index.levels, self.index.codes)
             else:
                 default = 'index' if 'index' not in self else 'level_0'
                 names = ([default] if self.index.name is None
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 12adc2272..016b0096a 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -15,7 +15,7 @@ import numpy as np
 from pandas._config import config
 
 from pandas._libs import Timestamp, iNaT, properties
-from pandas.compat import lzip, set_function_name, to_str
+from pandas.compat import set_function_name, to_str
 from pandas.compat.numpy import function as nv
 from pandas.errors import AbstractMethodError
 from pandas.util._decorators import (
@@ -6546,7 +6546,7 @@ class NDFrame(PandasObject, SelectionMixin):
                 regex = True
 
             items = list(to_replace.items())
-            keys, values = lzip(*items) or ([], [])
+            keys, values = zip(*items) if items else ([], [])
 
             are_mappings = [is_dict_like(v) for v in values]
 
@@ -6560,7 +6560,7 @@ class NDFrame(PandasObject, SelectionMixin):
                 value_dict = {}
 
                 for k, v in items:
-                    keys, values = lzip(*v.items()) or ([], [])
+                    keys, values = list(zip(*v.items())) or ([], [])
                     if set(keys) & set(values):
                         raise ValueError("Replacement not allowed with "
                                          "overlapping keys and values")
diff --git a/pandas/core/groupby/generic.py b/pandas/core/groupby/generic.py
index 21ce0fe1c..ab60bdd86 100644
--- a/pandas/core/groupby/generic.py
+++ b/pandas/core/groupby/generic.py
@@ -15,7 +15,6 @@ import warnings
 import numpy as np
 
 from pandas._libs import Timestamp, lib
-from pandas.compat import lzip
 from pandas.errors import AbstractMethodError
 from pandas.util._decorators import Appender, Substitution
 
@@ -781,13 +780,13 @@ class SeriesGroupBy(GroupBy):
                     FutureWarning, stacklevel=3)
 
             columns = list(arg.keys())
-            arg = list(arg.items())
+            arg = arg.items()
         elif any(isinstance(x, (tuple, list)) for x in arg):
             arg = [(x, x) if not isinstance(x, (tuple, list)) else x
                    for x in arg]
 
             # indicated column order
-            columns = lzip(*arg)[0]
+            columns = next(zip(*arg))
         else:
             # list of functions / function names
             columns = []
@@ -797,7 +796,7 @@ class SeriesGroupBy(GroupBy):
                 else:
                     # protect against callables without names
                     columns.append(com.get_callable_name(f))
-            arg = lzip(columns, arg)
+            arg = zip(columns, arg)
 
         results = OrderedDict()
         for name, func in arg:
diff --git a/pandas/core/groupby/ops.py b/pandas/core/groupby/ops.py
index e6b7577d9..235975a9b 100644
--- a/pandas/core/groupby/ops.py
+++ b/pandas/core/groupby/ops.py
@@ -13,7 +13,6 @@ import numpy as np
 from pandas._libs import NaT, iNaT, lib
 import pandas._libs.groupby as libgroupby
 import pandas._libs.reduction as reduction
-from pandas.compat import lzip
 from pandas.errors import AbstractMethodError
 from pandas.util._decorators import cache_readonly
 
@@ -259,7 +258,7 @@ class BaseGrouper:
         if len(self.groupings) == 1:
             return self.groupings[0].groups
         else:
-            to_groupby = lzip(*(ping.grouper for ping in self.groupings))
+            to_groupby = zip(*(ping.grouper for ping in self.groupings))
             to_groupby = Index(to_groupby)
             return self.axis.groupby(to_groupby)
 
diff --git a/pandas/core/indexes/multi.py b/pandas/core/indexes/multi.py
index 1b60f9b21..cd5ad1eaa 100644
--- a/pandas/core/indexes/multi.py
+++ b/pandas/core/indexes/multi.py
@@ -9,7 +9,6 @@ from pandas._config import get_option
 
 from pandas._libs import (
     Timestamp, algos as libalgos, index as libindex, lib, tslibs)
-from pandas.compat import lzip
 from pandas.compat.numpy import function as nv
 from pandas.errors import PerformanceWarning, UnsortedIndexError
 from pandas.util._decorators import Appender, cache_readonly, deprecate_kwarg
@@ -402,7 +401,7 @@ class MultiIndex(Index):
         elif isinstance(tuples, list):
             arrays = list(lib.to_object_array_tuples(tuples).T)
         else:
-            arrays = lzip(*tuples)
+            arrays = zip(*tuples)
 
         return MultiIndex.from_arrays(arrays, sortorder=sortorder, names=names)
 
@@ -511,7 +510,7 @@ class MultiIndex(Index):
         if not isinstance(df, ABCDataFrame):
             raise TypeError("Input must be a DataFrame")
 
-        column_names, columns = lzip(*df.iteritems())
+        column_names, columns = zip(*df.iteritems())
         names = column_names if names is None else names
         return cls.from_arrays(columns, sortorder=sortorder, names=names)
 
@@ -2941,7 +2940,7 @@ class MultiIndex(Index):
                                                 other._ndarray_values],
                                                sort=sort)
 
-        return MultiIndex.from_arrays(lzip(*uniq_tuples), sortorder=0,
+        return MultiIndex.from_arrays(zip(*uniq_tuples), sortorder=0,
                                       names=result_names)
 
     def intersection(self, other, sort=False):
@@ -2984,7 +2983,7 @@ class MultiIndex(Index):
                               codes=[[]] * self.nlevels,
                               names=result_names, verify_integrity=False)
         else:
-            return MultiIndex.from_arrays(lzip(*uniq_tuples), sortorder=0,
+            return MultiIndex.from_arrays(zip(*uniq_tuples), sortorder=0,
                                           names=result_names)
 
     def difference(self, other, sort=None):
@@ -3152,7 +3151,7 @@ MultiIndex._add_logical_methods_disabled()
 
 
 def _sparsify(label_list, start=0, sentinel=''):
-    pivoted = lzip(*label_list)
+    pivoted = list(zip(*label_list))
     k = len(label_list)
 
     result = pivoted[:start + 1]
@@ -3176,7 +3175,7 @@ def _sparsify(label_list, start=0, sentinel=''):
 
         prev = cur
 
-    return lzip(*result)
+    return list(zip(*result))
 
 
 def _get_na_rep(dtype):
diff --git a/pandas/core/reshape/concat.py b/pandas/core/reshape/concat.py
index c5fa5e42c..ee3ed3899 100644
--- a/pandas/core/reshape/concat.py
+++ b/pandas/core/reshape/concat.py
@@ -6,7 +6,7 @@ import numpy as np
 
 import pandas.core.dtypes.concat as _concat
 
-from pandas import DataFrame, Index, MultiIndex, Series, compat
+from pandas import DataFrame, Index, MultiIndex, Series
 from pandas.core import common as com
 from pandas.core.arrays.categorical import (
     _factorize_from_iterable, _factorize_from_iterables)
@@ -536,7 +536,7 @@ def _make_concat_multiindex(indexes, keys, levels=None, names=None):
 
     if ((levels is None and isinstance(keys[0], tuple)) or
             (levels is not None and len(levels) > 1)):
-        zipped = compat.lzip(*keys)
+        zipped = list(zip(*keys))
         if names is None:
             names = [None] * len(zipped)
 
diff --git a/pandas/core/reshape/merge.py b/pandas/core/reshape/merge.py
index e8c82feae..39b955ea7 100644
--- a/pandas/core/reshape/merge.py
+++ b/pandas/core/reshape/merge.py
@@ -9,7 +9,6 @@ import warnings
 import numpy as np
 
 from pandas._libs import hashtable as libhashtable, join as libjoin, lib
-from pandas.compat import lzip
 from pandas.errors import MergeError
 from pandas.util._decorators import Appender, Substitution
 
@@ -1512,7 +1511,7 @@ class _AsOfMerge(_OrderedMerge):
             labels = list(string.ascii_lowercase[:len(xs)])
             dtypes = [x.dtype for x in xs]
             labeled_dtypes = list(zip(labels, dtypes))
-            return np.array(lzip(*xs), labeled_dtypes)
+            return np.array(list(zip(*xs)), labeled_dtypes)
 
         # values to compare
         left_values = (self.left.index.values if self.left_index else
diff --git a/pandas/io/formats/format.py b/pandas/io/formats/format.py
index 9ebd0aa9a..da0f621e7 100644
--- a/pandas/io/formats/format.py
+++ b/pandas/io/formats/format.py
@@ -15,7 +15,6 @@ from pandas._config.config import get_option, set_option
 from pandas._libs import lib
 from pandas._libs.tslib import format_array_from_datetime
 from pandas._libs.tslibs import NaT, Timedelta, Timestamp, iNaT
-from pandas.compat import lzip
 
 from pandas.core.dtypes.common import (
     is_categorical_dtype, is_complex_dtype, is_datetime64_dtype,
@@ -753,7 +752,7 @@ class DataFrameFormatter(TableFormatter):
 
         if isinstance(columns, ABCMultiIndex):
             fmt_columns = columns.format(sparsify=False, adjoin=False)
-            fmt_columns = lzip(*fmt_columns)
+            fmt_columns = list(zip(*fmt_columns))
             dtypes = self.frame.dtypes._values
 
             # if we have a Float level, they don't use leading space at all
diff --git a/pandas/io/formats/html.py b/pandas/io/formats/html.py
index 50f188b2b..6fc363240 100644
--- a/pandas/io/formats/html.py
+++ b/pandas/io/formats/html.py
@@ -7,8 +7,6 @@ from textwrap import dedent
 
 from pandas._config import get_option
 
-from pandas.compat import lzip
-
 from pandas.core.dtypes.generic import ABCMultiIndex
 
 from pandas import option_context
@@ -414,7 +412,7 @@ class HTMLFormatter(TableFormatter):
 
         idx_values = frame.index.format(sparsify=False, adjoin=False,
                                         names=False)
-        idx_values = lzip(*idx_values)
+        idx_values = list(zip(*idx_values))
 
         if self.fmt.sparsify:
             # GH3547
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index f85863c43..a3fde2c2b 100755
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -18,7 +18,6 @@ import pandas._libs.ops as libops
 import pandas._libs.parsers as parsers
 from pandas._libs.tslibs import parsing
 import pandas.compat as compat
-from pandas.compat import lzip
 from pandas.errors import (
     AbstractMethodError, EmptyDataError, ParserError, ParserWarning)
 from pandas.util._decorators import Appender
@@ -1489,7 +1488,7 @@ class ParserBase:
         def extract(r):
             return tuple(r[i] for i in range(field_count) if i not in sic)
 
-        columns = lzip(*[extract(r) for r in header])
+        columns = list(zip(*(extract(r) for r in header)))
         names = ic + columns
 
         # If we find unnamed columns all in a single
diff --git a/pandas/io/stata.py b/pandas/io/stata.py
index 0cbde6d0d..7c42b46f4 100644
--- a/pandas/io/stata.py
+++ b/pandas/io/stata.py
@@ -23,7 +23,7 @@ import numpy as np
 
 from pandas._libs.lib import infer_dtype
 from pandas._libs.writers import max_len_string_array
-from pandas.compat import lmap, lzip
+from pandas.compat import lmap
 from pandas.util._decorators import Appender, deprecate_kwarg
 
 from pandas.core.dtypes.common import (
@@ -852,17 +852,16 @@ class StataParser:
         # NOTE: the byte type seems to be reserved for categorical variables
         # with a label, but the underlying variable is -127 to 100
         # we're going to drop the label and cast to int
-        self.DTYPE_MAP = \
-            dict(
-                lzip(range(1, 245), ['a' + str(i) for i in range(1, 245)]) +
-                [
-                    (251, np.int8),
-                    (252, np.int16),
-                    (253, np.int32),
-                    (254, np.float32),
-                    (255, np.float64)
-                ]
-            )
+        self.DTYPE_MAP = dict(
+            list(zip(range(1, 245), ['a' + str(i) for i in range(1, 245)])) +
+            [
+                (251, np.int8),
+                (252, np.int16),
+                (253, np.int32),
+                (254, np.float32),
+                (255, np.float64)
+            ]
+        )
         self.DTYPE_MAP_XML = \
             dict(
                 [
diff --git a/pandas/tests/frame/test_axis_select_reindex.py b/pandas/tests/frame/test_axis_select_reindex.py
index c3f3b3908..d1934c335 100644
--- a/pandas/tests/frame/test_axis_select_reindex.py
+++ b/pandas/tests/frame/test_axis_select_reindex.py
@@ -3,7 +3,7 @@ from datetime import datetime
 import numpy as np
 import pytest
 
-from pandas.compat import lrange, lzip
+from pandas.compat import lrange
 from pandas.errors import PerformanceWarning
 
 import pandas as pd
@@ -100,7 +100,7 @@ class TestDataFrameSelectReindex(TestData):
                            simple[['B']])
 
         # non-unique - wheee!
-        nu_df = DataFrame(lzip(range(3), range(-3, 1), list('abc')),
+        nu_df = DataFrame(list(zip(range(3), range(-3, 1), list('abc'))),
                           columns=['a', 'a', 'b'])
         assert_frame_equal(nu_df.drop('a', axis=1), nu_df[['b']])
         assert_frame_equal(nu_df.drop('b', axis='columns'), nu_df['a'])
diff --git a/pandas/tests/frame/test_constructors.py b/pandas/tests/frame/test_constructors.py
index f865ab68f..5786f1dcc 100644
--- a/pandas/tests/frame/test_constructors.py
+++ b/pandas/tests/frame/test_constructors.py
@@ -7,7 +7,7 @@ import numpy as np
 import numpy.ma as ma
 import pytest
 
-from pandas.compat import PY36, is_platform_little_endian, lmap, lrange, lzip
+from pandas.compat import PY36, is_platform_little_endian, lmap, lrange
 
 from pandas.core.dtypes.cast import construct_1d_object_array_from_listlike
 from pandas.core.dtypes.common import is_integer_dtype
@@ -132,12 +132,11 @@ class TestDataFrameConstructors(TestData):
                 arrays = [np.array(np.random.randint(
                     10, size=10), dtype=d) for d in dtypes]
 
-            zipper = lzip(dtypes, arrays)
-            for d, a in zipper:
+            for d, a in zip(dtypes, arrays):
                 assert(a.dtype == d)
             if ad is None:
                 ad = dict()
-            ad.update({d: a for d, a in zipper})
+            ad.update({d: a for d, a in zip(dtypes, arrays)})
             return DataFrame(ad)
 
         def _check_mixed_dtypes(df, dtypes=None):
diff --git a/pandas/tests/frame/test_indexing.py b/pandas/tests/frame/test_indexing.py
index cba656a28..3888739a0 100644
--- a/pandas/tests/frame/test_indexing.py
+++ b/pandas/tests/frame/test_indexing.py
@@ -5,7 +5,7 @@ import numpy as np
 import pytest
 
 from pandas._libs.tslib import iNaT
-from pandas.compat import lrange, lzip
+from pandas.compat import lrange
 
 from pandas.core.dtypes.common import is_float_dtype, is_integer, is_scalar
 from pandas.core.dtypes.dtypes import CategoricalDtype
@@ -178,7 +178,7 @@ class TestDataFrameIndexing(TestData):
         assert_almost_equal(self.frame[['A', 'B']].values, data)
 
     def test_setitem_list_of_tuples(self):
-        tuples = lzip(self.frame['A'], self.frame['B'])
+        tuples = list(zip(self.frame['A'], self.frame['B']))
         self.frame['tuples'] = tuples
 
         result = self.frame['tuples']
@@ -998,11 +998,11 @@ class TestDataFrameIndexing(TestData):
             assert_frame_equal(frame, expected)
 
         # new corner case of boolean slicing / setting
-        frame = DataFrame(lzip([2, 3, 9, 6, 7], [np.nan] * 5),
+        frame = DataFrame(zip([2, 3, 9, 6, 7], [np.nan] * 5),
                           columns=['a', 'b'])
         lst = [100]
         lst.extend([np.nan] * 4)
-        expected = DataFrame(lzip([100, 3, 9, 6, 7], lst),
+        expected = DataFrame(zip([100, 3, 9, 6, 7], lst),
                              columns=['a', 'b'])
         frame[frame['a'] == 2] = 100
         assert_frame_equal(frame, expected)
diff --git a/pandas/tests/groupby/test_groupby.py b/pandas/tests/groupby/test_groupby.py
index 4481f1fbb..31065cbb6 100644
--- a/pandas/tests/groupby/test_groupby.py
+++ b/pandas/tests/groupby/test_groupby.py
@@ -6,7 +6,7 @@ from io import StringIO
 import numpy as np
 import pytest
 
-from pandas.compat import lmap, lzip
+from pandas.compat import lmap
 from pandas.errors import PerformanceWarning
 
 import pandas as pd
@@ -652,7 +652,7 @@ def test_groupby_as_index_cython(df):
     result = grouped.mean()
     expected = data.groupby(['A', 'B']).mean()
 
-    arrays = lzip(*expected.index.values)
+    arrays = list(zip(*expected.index.values))
     expected.insert(0, 'A', arrays[0])
     expected.insert(1, 'B', arrays[1])
     expected.index = np.arange(len(expected))
diff --git a/pandas/tests/indexes/conftest.py b/pandas/tests/indexes/conftest.py
index 88b71d5dd..632d5b287 100644
--- a/pandas/tests/indexes/conftest.py
+++ b/pandas/tests/indexes/conftest.py
@@ -1,8 +1,6 @@
 import numpy as np
 import pytest
 
-from pandas.compat import lzip
-
 import pandas as pd
 from pandas.core.indexes.api import Index, MultiIndex
 import pandas.util.testing as tm
@@ -20,7 +18,7 @@ import pandas.util.testing as tm
                         Index([True, False]),
                         tm.makeCategoricalIndex(100),
                         Index([]),
-                        MultiIndex.from_tuples(lzip(
+                        MultiIndex.from_tuples(zip(
                             ['foo', 'bar', 'baz'], [1, 2, 3])),
                         Index([0, 0, 1, 1, 2, 2])],
                 ids=lambda x: type(x).__name__)
diff --git a/pandas/tests/indexes/interval/test_construction.py b/pandas/tests/indexes/interval/test_construction.py
index bd0fb4639..484a05800 100644
--- a/pandas/tests/indexes/interval/test_construction.py
+++ b/pandas/tests/indexes/interval/test_construction.py
@@ -3,8 +3,6 @@ from functools import partial
 import numpy as np
 import pytest
 
-from pandas.compat import lzip
-
 from pandas.core.dtypes.common import is_categorical_dtype
 from pandas.core.dtypes.dtypes import IntervalDtype
 
@@ -249,7 +247,7 @@ class TestFromTuples(Base):
         if len(breaks) == 0:
             return {'data': breaks}
 
-        tuples = lzip(breaks[:-1], breaks[1:])
+        tuples = list(zip(breaks[:-1], breaks[1:]))
         if isinstance(breaks, (list, tuple)):
             return {'data': tuples}
         elif is_categorical_dtype(breaks):
diff --git a/pandas/tests/indexes/interval/test_interval.py b/pandas/tests/indexes/interval/test_interval.py
index a22210268..61465d845 100644
--- a/pandas/tests/indexes/interval/test_interval.py
+++ b/pandas/tests/indexes/interval/test_interval.py
@@ -4,8 +4,6 @@ import re
 import numpy as np
 import pytest
 
-from pandas.compat import lzip
-
 import pandas as pd
 from pandas import (
     Index, Interval, IntervalIndex, Timedelta, Timestamp, date_range,
@@ -1192,11 +1190,11 @@ class TestIntervalIndex(Base):
         assert result is expected
 
     @pytest.mark.parametrize('tuples', [
-        lzip(range(10), range(1, 11)),
-        lzip(date_range('20170101', periods=10),
-             date_range('20170101', periods=10)),
-        lzip(timedelta_range('0 days', periods=10),
-             timedelta_range('1 day', periods=10))])
+        list(zip(range(10), range(1, 11))),
+        list(zip(date_range('20170101', periods=10),
+             date_range('20170101', periods=10))),
+        list(zip(timedelta_range('0 days', periods=10),
+             timedelta_range('1 day', periods=10)))])
     def test_to_tuples(self, tuples):
         # GH 18756
         idx = IntervalIndex.from_tuples(tuples)
@@ -1205,11 +1203,11 @@ class TestIntervalIndex(Base):
         tm.assert_index_equal(result, expected)
 
     @pytest.mark.parametrize('tuples', [
-        lzip(range(10), range(1, 11)) + [np.nan],
-        lzip(date_range('20170101', periods=10),
-             date_range('20170101', periods=10)) + [np.nan],
-        lzip(timedelta_range('0 days', periods=10),
-             timedelta_range('1 day', periods=10)) + [np.nan]])
+        list(zip(range(10), range(1, 11))) + [np.nan],
+        list(zip(date_range('20170101', periods=10),
+             date_range('20170101', periods=10))) + [np.nan],
+        list(zip(timedelta_range('0 days', periods=10),
+             timedelta_range('1 day', periods=10))) + [np.nan]])
     @pytest.mark.parametrize('na_tuple', [True, False])
     def test_to_tuples_na(self, tuples, na_tuple):
         # GH 18756
diff --git a/pandas/tests/indexes/multi/test_equivalence.py b/pandas/tests/indexes/multi/test_equivalence.py
index 8003c1e3a..eb34e2714 100644
--- a/pandas/tests/indexes/multi/test_equivalence.py
+++ b/pandas/tests/indexes/multi/test_equivalence.py
@@ -1,7 +1,7 @@
 import numpy as np
 import pytest
 
-from pandas.compat import lrange, lzip
+from pandas.compat import lrange
 
 import pandas as pd
 from pandas import Index, MultiIndex, Series
@@ -163,7 +163,7 @@ def test_equals_missing_values():
 
 
 def test_is_():
-    mi = MultiIndex.from_tuples(lzip(range(10), range(10)))
+    mi = MultiIndex.from_tuples(zip(range(10), range(10)))
     assert mi.is_(mi)
     assert mi.is_(mi.view())
     assert mi.is_(mi.view().view().view().view())
diff --git a/pandas/tests/indexes/test_base.py b/pandas/tests/indexes/test_base.py
index 73a389516..66f3b10d6 100644
--- a/pandas/tests/indexes/test_base.py
+++ b/pandas/tests/indexes/test_base.py
@@ -11,7 +11,7 @@ import pytest
 import pandas._config.config as cf
 
 from pandas._libs.tslib import Timestamp
-from pandas.compat import PY36, lrange, lzip
+from pandas.compat import PY36, lrange
 from pandas.compat.numpy import np_datetime64_compat
 
 from pandas.core.dtypes.common import is_unsigned_integer_dtype
@@ -46,7 +46,7 @@ class TestIndex(Base):
                             boolIndex=Index([True, False]),
                             catIndex=tm.makeCategoricalIndex(100),
                             empty=Index([]),
-                            tuples=MultiIndex.from_tuples(lzip(
+                            tuples=MultiIndex.from_tuples(zip(
                                 ['foo', 'bar', 'baz'], [1, 2, 3])),
                             repeats=Index([0, 0, 1, 1, 2, 2]))
         self.setup_indices()
@@ -967,7 +967,7 @@ class TestIndex(Base):
         # Test that returning a single object from a MultiIndex
         #   returns an Index.
         first_level = ['foo', 'bar', 'baz']
-        multi_index = MultiIndex.from_tuples(lzip(first_level, [1, 2, 3]))
+        multi_index = MultiIndex.from_tuples(zip(first_level, [1, 2, 3]))
         reduced_index = multi_index.map(lambda x: x[0])
         tm.assert_index_equal(reduced_index, Index(first_level))
 
diff --git a/pandas/tests/indexing/multiindex/test_chaining_and_caching.py b/pandas/tests/indexing/multiindex/test_chaining_and_caching.py
index 3f3a9d497..bba0d0b27 100644
--- a/pandas/tests/indexing/multiindex/test_chaining_and_caching.py
+++ b/pandas/tests/indexing/multiindex/test_chaining_and_caching.py
@@ -1,7 +1,7 @@
 import numpy as np
 import pytest
 
-from pandas.compat import lrange, lzip
+from pandas.compat import lrange
 
 from pandas import DataFrame, MultiIndex, Series
 from pandas.core import common as com
@@ -54,7 +54,7 @@ def test_indexer_caching():
     # make sure that indexers are in the _internal_names_set
     n = 1000001
     arrays = [lrange(n), lrange(n)]
-    index = MultiIndex.from_tuples(lzip(*arrays))
+    index = MultiIndex.from_tuples(zip(*arrays))
     s = Series(np.zeros(n), index=index)
     str(s)
 
diff --git a/pandas/tests/indexing/multiindex/test_sorted.py b/pandas/tests/indexing/multiindex/test_sorted.py
index b1db93076..7fb6c806a 100644
--- a/pandas/tests/indexing/multiindex/test_sorted.py
+++ b/pandas/tests/indexing/multiindex/test_sorted.py
@@ -1,8 +1,6 @@
 import numpy as np
 from numpy.random import randn
 
-from pandas.compat import lzip
-
 from pandas import DataFrame, MultiIndex, Series
 from pandas.util import testing as tm
 
@@ -78,7 +76,7 @@ class TestMultiIndexSorted:
     def test_series_getitem_not_sorted(self):
         arrays = [['bar', 'bar', 'baz', 'baz', 'qux', 'qux', 'foo', 'foo'],
                   ['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two']]
-        tuples = lzip(*arrays)
+        tuples = zip(*arrays)
         index = MultiIndex.from_tuples(tuples)
         s = Series(randn(8), index=index)
 
diff --git a/pandas/tests/io/formats/test_format.py b/pandas/tests/io/formats/test_format.py
index 9739fe580..90b638497 100644
--- a/pandas/tests/io/formats/test_format.py
+++ b/pandas/tests/io/formats/test_format.py
@@ -18,7 +18,7 @@ import numpy as np
 import pytest
 import pytz
 
-from pandas.compat import is_platform_32bit, is_platform_windows, lrange, lzip
+from pandas.compat import is_platform_32bit, is_platform_windows, lrange
 
 import pandas as pd
 from pandas import (
@@ -161,7 +161,7 @@ class TestDataFrameFormatting:
     def test_repr_tuples(self):
         buf = StringIO()
 
-        df = DataFrame({'tups': lzip(range(10), range(10))})
+        df = DataFrame({'tups': list(zip(range(10), range(10)))})
         repr(df)
         df.to_string(col_space=10, buf=buf)
 
@@ -177,7 +177,7 @@ class TestDataFrameFormatting:
 
             adj = fmt._get_adjustment()
 
-            for line, value in lzip(r.split('\n'), df['B']):
+            for line, value in zip(r.split('\n'), df['B']):
                 if adj.len(value) + 1 > max_len:
                     assert '...' in line
                 else:
@@ -508,7 +508,7 @@ class TestDataFrameFormatting:
                       ('float', lambda x: '[{x: 4.1f}]'.format(x=x)),
                       ('object', lambda x: '-{x!s}-'.format(x=x))]
         result = df.to_string(formatters=dict(formatters))
-        result2 = df.to_string(formatters=lzip(*formatters)[1])
+        result2 = df.to_string(formatters=list(zip(*formatters))[1])
         assert result == ('  int  float    object\n'
                           '0 0x1 [ 1.0]  -(1, 2)-\n'
                           '1 0x2 [ 2.0]    -True-\n'
diff --git a/pandas/tests/plotting/test_boxplot_method.py b/pandas/tests/plotting/test_boxplot_method.py
index 84d6e92b5..de1ac0c29 100644
--- a/pandas/tests/plotting/test_boxplot_method.py
+++ b/pandas/tests/plotting/test_boxplot_method.py
@@ -7,7 +7,6 @@ import numpy as np
 from numpy import random
 import pytest
 
-from pandas.compat import lzip
 import pandas.util._test_decorators as td
 
 from pandas import DataFrame, MultiIndex, Series
@@ -177,7 +176,7 @@ class TestDataFrameGroupByPlots(TestPlotBase):
 
     @pytest.mark.slow
     def test_boxplot_legacy2(self):
-        tuples = lzip(string.ascii_letters[:10], range(10))
+        tuples = zip(string.ascii_letters[:10], range(10))
         df = DataFrame(np.random.rand(10, 3),
                        index=MultiIndex.from_tuples(tuples))
         grouped = df.groupby(level=1)
@@ -191,7 +190,7 @@ class TestDataFrameGroupByPlots(TestPlotBase):
 
     @pytest.mark.slow
     def test_boxplot_legacy3(self):
-        tuples = lzip(string.ascii_letters[:10], range(10))
+        tuples = zip(string.ascii_letters[:10], range(10))
         df = DataFrame(np.random.rand(10, 3),
                        index=MultiIndex.from_tuples(tuples))
         grouped = df.unstack(level=1).groupby(level=0, axis=1)
diff --git a/pandas/tests/plotting/test_frame.py b/pandas/tests/plotting/test_frame.py
index 1556c4ff9..3bb49baf7 100644
--- a/pandas/tests/plotting/test_frame.py
+++ b/pandas/tests/plotting/test_frame.py
@@ -10,7 +10,7 @@ import numpy as np
 from numpy.random import rand, randn
 import pytest
 
-from pandas.compat import lmap, lrange, lzip
+from pandas.compat import lmap, lrange
 import pandas.util._test_decorators as td
 
 from pandas.core.dtypes.api import is_list_like
@@ -105,7 +105,7 @@ class TestDataFramePlots(TestPlotBase):
 
         _check_plot_works(df.plot, title='blah')
 
-        tuples = lzip(string.ascii_letters[:10], range(10))
+        tuples = zip(string.ascii_letters[:10], range(10))
         df = DataFrame(np.random.rand(10, 3),
                        index=MultiIndex.from_tuples(tuples))
         _check_plot_works(df.plot, use_index=True)
diff --git a/pandas/tests/series/test_api.py b/pandas/tests/series/test_api.py
index 2f9299193..316c193e9 100644
--- a/pandas/tests/series/test_api.py
+++ b/pandas/tests/series/test_api.py
@@ -5,8 +5,6 @@ import warnings
 import numpy as np
 import pytest
 
-from pandas.compat import lzip
-
 import pandas as pd
 from pandas import (
     Categorical, DataFrame, DatetimeIndex, Index, Series, TimedeltaIndex,
@@ -270,8 +268,8 @@ class TestSeriesMisc(TestData, SharedWithSparse):
         tm.makeFloatIndex(10),
         Index([True, False]),
         Index(['a{}'.format(i) for i in range(101)]),
-        pd.MultiIndex.from_tuples(lzip('ABCD', 'EFGH')),
-        pd.MultiIndex.from_tuples(lzip([0, 1, 2, 3], 'EFGH')), ])
+        pd.MultiIndex.from_tuples(zip('ABCD', 'EFGH')),
+        pd.MultiIndex.from_tuples(zip([0, 1, 2, 3], 'EFGH')), ])
     def test_index_tab_completion(self, index):
         # dir contains string-like values of the Index.
         s = pd.Series(index=index)
diff --git a/pandas/tests/test_compat.py b/pandas/tests/test_compat.py
index 579aa38df..1add28c1f 100644
--- a/pandas/tests/test_compat.py
+++ b/pandas/tests/test_compat.py
@@ -3,7 +3,7 @@ Testing that functions from compat work as expected
 """
 import builtins
 
-from pandas.compat import lmap, lrange, lzip
+from pandas.compat import lmap, lrange
 
 
 class TestBuiltinIterators:
@@ -32,10 +32,3 @@ class TestBuiltinIterators:
         expecteds = list(builtins.map(func, *lst)),
         lengths = 10,
         self.check_results(results, expecteds, lengths)
-
-    def test_lzip(self):
-        lst = [builtins.range(10), builtins.range(10), builtins.range(10)]
-        results = lzip(*lst),
-        expecteds = list(builtins.zip(*lst)),
-        lengths = 10,
-        self.check_results(results, expecteds, lengths)
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index b2b60a0fb..737445b3f 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -9,8 +9,6 @@ from numpy.random import randn
 import pytest
 import pytz
 
-from pandas.compat import lzip
-
 from pandas.core.dtypes.common import is_float_dtype, is_integer_dtype
 
 import pandas as pd
@@ -40,7 +38,7 @@ class Base:
         # create test series object
         arrays = [['bar', 'bar', 'baz', 'baz', 'qux', 'qux', 'foo', 'foo'],
                   ['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two']]
-        tuples = lzip(*arrays)
+        tuples = zip(*arrays)
         index = MultiIndex.from_tuples(tuples)
         s = Series(randn(8), index=index)
         s[3] = np.NaN
@@ -2038,7 +2036,7 @@ class TestSorted(Base):
         arrays = [['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'],
                   ['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'],
                   [4, 3, 2, 1, 4, 3, 2, 1]]
-        tuples = lzip(*arrays)
+        tuples = zip(*arrays)
         mi = MultiIndex.from_tuples(tuples, names=['first', 'second', 'third'])
         s = Series(range(8), index=mi)
 
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index 5ef68dcef..b7fa15984 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -22,7 +22,7 @@ from pandas._config.localization import (  # noqa:F401
     can_set_locale, get_locales, set_locale)
 
 from pandas._libs import testing as _testing
-from pandas.compat import lmap, lzip, raise_with_traceback
+from pandas.compat import lmap, raise_with_traceback
 
 from pandas.core.dtypes.common import (
     is_bool, is_categorical_dtype, is_datetime64_dtype, is_datetime64tz_dtype,
@@ -1827,7 +1827,7 @@ def makeCustomIndex(nentries, nlevels, prefix='#', names=False, ndupe_l=None,
         result = list(sorted(cnt.elements(), key=keyfunc))[:nentries]
         tuples.append(result)
 
-    tuples = lzip(*tuples)
+    tuples = list(zip(*tuples))
 
     # convert tuples to index
     if nentries == 1:

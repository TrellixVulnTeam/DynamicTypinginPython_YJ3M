commit ac3cdab926ae7e944720aa8e20622f4fad50a1b8
Author: jreback <jeff@reback.net>
Date:   Wed Feb 13 17:24:34 2013 -0500

    DOC: whatsnew updates

diff --git a/doc/source/v0.11.0.txt b/doc/source/v0.11.0.txt
index fd78ba7cf..0162ee85a 100644
--- a/doc/source/v0.11.0.txt
+++ b/doc/source/v0.11.0.txt
@@ -13,7 +13,8 @@ API changes
 
 Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passed (either directly via the ``dtype`` keyword, a passed ``ndarray``, or a passed ``Series``, then it will be preserved in DataFrame operations. Furthermore, different numeric dtypes will **NOT** be combined. The following example will give you a taste.
 
-**Dtype Specification**
+Dtype Specification
+~~~~~~~~~~~~~~~~~~~
 
 .. ipython:: python
 
@@ -29,7 +30,8 @@ Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passe
    df3
    df3.dtypes
 
-**Dtype conversion**
+Dtype Conversion
+~~~~~~~~~~~~~~~~
 
 .. ipython:: python
 
@@ -54,20 +56,22 @@ Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passe
                Timestamp('20010104'), '20010105'],dtype='O')
    s.convert_objects(convert_dates='coerce')
 
+Dtype Gotchas
+~~~~~~~~~~~~~
 
 **Platform Gotchas**
 
 Starting in 0.11.0, construction of DataFrame/Series will use default dtypes of ``int64`` and ``float64``,
 *regardless of platform*. This is not an apparent change from earlier versions of pandas. If you specify
-dtypes, they *WILL* be respected, however.
+dtypes, they *WILL* be respected, however (GH2837_)
 
 The following will all result in ``int64`` dtypes
 
 .. ipython:: python
 
     DataFrame([1,2],columns=['a']).dtypes
-    DataFrame({'a' : [1,2] }.dtypes
-    DataFrame({'a' : 1).dtypes
+    DataFrame({'a' : [1,2] }).dtypes
+    DataFrame({'a' : 1 }, index=range(2)).dtypes
 
 Keep in mind that ``DataFrame(np.array([1,2]))`` **WILL** result in ``int32`` on 32-bit platforms!
 
@@ -100,11 +104,13 @@ While float dtypes are unchanged.
    casted
    casted.dtypes
 
-**Datetimes conversion**
+Datetimes Conversion
+~~~~~~~~~~~~~~~~~~~~
 
 Datetime64[ns] columns in a DataFrame (or a Series) allow the use of ``np.nan`` to indicate a nan value, 
 in addition to the traditional ``NaT``, or not-a-time. This allows convenient nan setting in a generic way.
 Furthermore ``datetime64[ns]`` columns are created by default, when passed datetimelike objects (*this change was introduced in 0.10.1*)
+(GH2809_, GH2810_)
 
 .. ipython:: python
 
@@ -139,18 +145,19 @@ New features
 
 **Enhancements**
 
-  - In ``HDFStore``, provide dotted attribute access to ``get`` from stores (e.g. store.df == store['df'])
+  - In ``HDFStore``, provide dotted attribute access to ``get`` from stores
+    (e.g. store.df == store['df'])
 
-``Squeeze`` to possibly remove length 1 dimensions from an object.
+  - ``Squeeze`` to possibly remove length 1 dimensions from an object.
 
-.. ipython:: python
+    .. ipython:: python
 
-   p = Panel(randn(3,4,4),items=['ItemA','ItemB','ItemC'],
+       p = Panel(randn(3,4,4),items=['ItemA','ItemB','ItemC'],
                           major_axis=date_range('20010102',periods=4),
                           minor_axis=['A','B','C','D'])
-   p
-   p.reindex(items=['ItemA']).squeeze()
-   p.reindex(items=['ItemA'],minor=['B']).squeeze()
+       p
+       p.reindex(items=['ItemA']).squeeze()
+       p.reindex(items=['ItemA'],minor=['B']).squeeze()
 
 **Bug Fixes**
 
@@ -158,4 +165,7 @@ See the `full release notes
 <https://github.com/pydata/pandas/blob/master/RELEASE.rst>`__ or issue tracker
 on GitHub for a complete list.
 
+.. _GH2809: https://github.com/pydata/pandas/issues/2809
+.. _GH2810: https://github.com/pydata/pandas/issues/2810
+.. _GH2837: https://github.com/pydata/pandas/issues/2837
 
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 424d6e2e6..24883b335 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -2903,12 +2903,8 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         casted = mn.astype('float32')
         _check_cast(casted, 'float32')
 
-        # this is platform dependent overflow
-        if np.int_ == np.int32:
-            self.assertRaises(OverflowError, mn.astype, 'int32')
-        else:
-            casted = mn.astype('int32')
-            _check_cast(casted, 'int32')
+        casted = mn.astype('int32')
+        _check_cast(casted, 'int32')
 
         # to object
         casted = mn.astype('O')

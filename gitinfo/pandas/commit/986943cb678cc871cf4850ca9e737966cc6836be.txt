commit 986943cb678cc871cf4850ca9e737966cc6836be
Author: Jeff Reback <jeff@reback.net>
Date:   Wed Jan 18 21:01:44 2017 -0500

    DOC: fix doc-build for .ix deprecations (#15158)

diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index 9c653f6d9..e2916c2d9 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -586,7 +586,7 @@ Using ``.loc``. Here we will select the appropriate indexes from the index, then
 
 .. ipython:: python
 
-  dfd.loc[df.index[[0, 2]], 'A']
+  dfd.loc[dfd.index[[0, 2]], 'A']
 
 This can also be expressed using ``.iloc``, by explicitly getting locations on the indexers, and using
 *positional* indexing to select things.
diff --git a/doc/source/whatsnew/v0.10.1.txt b/doc/source/whatsnew/v0.10.1.txt
index b61d31932..edc628fe8 100644
--- a/doc/source/whatsnew/v0.10.1.txt
+++ b/doc/source/whatsnew/v0.10.1.txt
@@ -51,8 +51,8 @@ perform queries on a table, by passing a list to ``data_columns``
    df = DataFrame(randn(8, 3), index=date_range('1/1/2000', periods=8),
               columns=['A', 'B', 'C'])
    df['string'] = 'foo'
-   df.ix[4:6,'string'] = np.nan
-   df.ix[7:9,'string'] = 'bar'
+   df.loc[df.index[4:6], 'string'] = np.nan
+   df.loc[df.index[7:9], 'string'] = 'bar'
    df['string2'] = 'cool'
    df
 
@@ -78,7 +78,7 @@ You can now store ``datetime64`` in data columns
 
     df_mixed               = df.copy()
     df_mixed['datetime64'] = Timestamp('20010102')
-    df_mixed.ix[3:4,['A','B']] = np.nan
+    df_mixed.loc[df_mixed.index[3:4], ['A','B']] = np.nan
 
     store.append('df_mixed', df_mixed)
     df_mixed1 = store.select('df_mixed')
@@ -208,4 +208,3 @@ combined result, by using ``where`` on a selector table.
 See the :ref:`full release notes
 <release>` or issue tracker
 on GitHub for a complete list.
-
diff --git a/doc/source/whatsnew/v0.11.0.txt b/doc/source/whatsnew/v0.11.0.txt
index 50b74fc5a..ea149595e 100644
--- a/doc/source/whatsnew/v0.11.0.txt
+++ b/doc/source/whatsnew/v0.11.0.txt
@@ -190,7 +190,7 @@ Furthermore ``datetime64[ns]`` columns are created by default, when passed datet
    df.get_dtype_counts()
 
    # use the traditional nan, which is mapped to NaT internally
-   df.ix[2:4,['A','timestamp']] = np.nan
+   df.loc[df.index[2:4], ['A','timestamp']] = np.nan
    df
 
 Astype conversion on ``datetime64[ns]`` to ``object``, implicity converts ``NaT`` to ``np.nan``
diff --git a/doc/source/whatsnew/v0.13.0.txt b/doc/source/whatsnew/v0.13.0.txt
index 6ecd4b487..118632cc2 100644
--- a/doc/source/whatsnew/v0.13.0.txt
+++ b/doc/source/whatsnew/v0.13.0.txt
@@ -274,7 +274,6 @@ Float64Index API Change
   .. ipython:: python
 
      s[3]
-     s.ix[3]
      s.loc[3]
 
   The only positional indexing is via ``iloc``
@@ -290,7 +289,6 @@ Float64Index API Change
   .. ipython:: python
 
      s[2:4]
-     s.ix[2:4]
      s.loc[2:4]
      s.iloc[2:4]
 
diff --git a/doc/source/whatsnew/v0.13.1.txt b/doc/source/whatsnew/v0.13.1.txt
index 349acf508..d5d54ba43 100644
--- a/doc/source/whatsnew/v0.13.1.txt
+++ b/doc/source/whatsnew/v0.13.1.txt
@@ -36,7 +36,7 @@ Highlights include:
    .. ipython:: python
 
       df = DataFrame(dict(A = np.array(['foo','bar','bah','foo','bar'])))
-      df.ix[0,'A'] = np.nan
+      df.loc[0,'A'] = np.nan
       df
 
 Output Formatting Enhancements
@@ -121,7 +121,7 @@ API changes
 
   .. ipython:: python
       :okwarning:
-      
+
       df = DataFrame({'col':['foo', 0, np.nan]})
       df2 = DataFrame({'col':[np.nan, 0, 'foo']}, index=[2,1,0])
       df.equals(df2)
diff --git a/doc/source/whatsnew/v0.14.0.txt b/doc/source/whatsnew/v0.14.0.txt
index 78f96e3c0..f1feab4b9 100644
--- a/doc/source/whatsnew/v0.14.0.txt
+++ b/doc/source/whatsnew/v0.14.0.txt
@@ -516,7 +516,7 @@ See also issues (:issue:`6134`, :issue:`4036`, :issue:`3057`, :issue:`2598`, :is
                                       names=['lvl0', 'lvl1'])
    df = DataFrame(np.arange(len(index)*len(columns)).reshape((len(index),len(columns))),
                   index=index,
-                  columns=columns).sortlevel().sortlevel(axis=1)
+                  columns=columns).sort_index().sort_index(axis=1)
    df
 
 Basic multi-index slicing using slices, lists, and labels.
diff --git a/doc/source/whatsnew/v0.15.0.txt b/doc/source/whatsnew/v0.15.0.txt
index df1171fb3..aff8ec909 100644
--- a/doc/source/whatsnew/v0.15.0.txt
+++ b/doc/source/whatsnew/v0.15.0.txt
@@ -705,7 +705,7 @@ Other notable API changes:
      s = Series(np.arange(3,dtype='int64'),
                 index=MultiIndex.from_product([['A'],['foo','bar','baz']],
                                               names=['one','two'])
-               ).sortlevel()
+               ).sort_index()
      s
      try:
         s.loc[['D']]
diff --git a/doc/source/whatsnew/v0.15.2.txt b/doc/source/whatsnew/v0.15.2.txt
index 3a62ac38f..3bb472e93 100644
--- a/doc/source/whatsnew/v0.15.2.txt
+++ b/doc/source/whatsnew/v0.15.2.txt
@@ -35,7 +35,7 @@ API changes
     df.loc[(1, 'z')]
 
     # lexically sorting
-    df2 = df.sortlevel()
+    df2 = df.sort_index()
     df2
     df2.index.lexsort_depth
     df2.loc[(1,'z')]
diff --git a/doc/source/whatsnew/v0.16.0.txt b/doc/source/whatsnew/v0.16.0.txt
index 4255f4839..4d4366096 100644
--- a/doc/source/whatsnew/v0.16.0.txt
+++ b/doc/source/whatsnew/v0.16.0.txt
@@ -300,9 +300,14 @@ The behavior of a small sub-set of edge cases for using ``.loc`` have changed (:
 
   New Behavior
 
-  .. ipython:: python
+  .. code-block:: python
 
-     s.ix[-1.0:2]
+     In [2]: s.ix[-1.0:2]
+     Out[2]:
+     -1    1
+      1    2
+      2    3
+     dtype: int64
 
 - Provide a useful exception for indexing with an invalid type for that index when using ``.loc``. For example trying to use ``.loc`` on an index of type ``DatetimeIndex`` or ``PeriodIndex`` or ``TimedeltaIndex``, with an integer (or a float).
 
diff --git a/doc/source/whatsnew/v0.18.0.txt b/doc/source/whatsnew/v0.18.0.txt
index 7418cd0e6..893922b71 100644
--- a/doc/source/whatsnew/v0.18.0.txt
+++ b/doc/source/whatsnew/v0.18.0.txt
@@ -448,7 +448,7 @@ New Behavior:
                      columns=list('abc'),
                      index=[[4,4,8], [8,10,12]])
    df
-   df.ix[4, 'c'] = np.array([0., 1.])
+   df.loc[4, 'c'] = np.array([0., 1.])
    df
 
 .. _whatsnew_0180.enhancements.xarray:
@@ -1115,7 +1115,6 @@ Other indexers will coerce to a like integer for both getting and setting. The `
 
    s[5.0]
    s.loc[5.0]
-   s.ix[5.0]
 
 and setting
 
@@ -1127,30 +1126,31 @@ and setting
    s_copy = s.copy()
    s_copy.loc[5.0] = 10
    s_copy
-   s_copy = s.copy()
-   s_copy.ix[5.0] = 10
-   s_copy
 
 Positional setting with ``.ix`` and a float indexer will ADD this value to the index, rather than previously setting the value by position.
 
-.. ipython:: python
+.. code-block:: python
 
-   s2.ix[1.0] = 10
-   s2
+   In [3]: s2.ix[1.0] = 10
+   In [4]: s2
+   Out[4]:
+   a       1
+   b       2
+   c       3
+   1.0    10
+   dtype: int64
 
 Slicing will also coerce integer-like floats to integers for a non-``Float64Index``.
 
 .. ipython:: python
 
    s.loc[5.0:6]
-   s.ix[5.0:6]
 
 Note that for floats that are NOT coercible to ints, the label based bounds will be excluded
 
 .. ipython:: python
 
    s.loc[5.1:6]
-   s.ix[5.1:6]
 
 Float indexing on a ``Float64Index`` is unchanged.
 
diff --git a/doc/source/whatsnew/v0.7.0.txt b/doc/source/whatsnew/v0.7.0.txt
index cfba2ad3d..21d91950e 100644
--- a/doc/source/whatsnew/v0.7.0.txt
+++ b/doc/source/whatsnew/v0.7.0.txt
@@ -169,16 +169,30 @@ API tweaks regarding label-based slicing
 Label-based slicing using ``ix`` now requires that the index be sorted
 (monotonic) **unless** both the start and endpoint are contained in the index:
 
-.. ipython:: python
+.. code-block:: python
 
-   s = Series(randn(6), index=list('gmkaec'))
-   s
+   In [1]: s = Series(randn(6), index=list('gmkaec'))
+
+   In [2]: s
+   Out[2]:
+   g   -1.182230
+   m   -0.276183
+   k   -0.243550
+   a    1.628992
+   e    0.073308
+   c   -0.539890
+   dtype: float64
 
 Then this is OK:
 
-.. ipython:: python
+.. code-block:: python
 
-   s.ix['k':'e']
+   In [3]: s.ix['k':'e']
+   Out[3]:
+   k   -0.243550
+   a    1.628992
+   e    0.073308
+   dtype: float64
 
 But this is not:
 
@@ -189,11 +203,26 @@ But this is not:
 
 If the index had been sorted, the "range selection" would have been possible:
 
-.. ipython:: python
+.. code-block:: python
+
+   In [4]: s2 = s.sort_index()
 
-   s2 = s.sort_index()
-   s2
-   s2.ix['b':'h']
+   In [5]: s2
+   Out[5]:
+   a    1.628992
+   c   -0.539890
+   e    0.073308
+   g   -1.182230
+   k   -0.243550
+   m   -0.276183
+   dtype: float64
+
+   In [6]: s2.ix['b':'h']
+   Out[6]:
+   c   -0.539890
+   e    0.073308
+   g   -1.182230
+   dtype: float64
 
 Changes to Series ``[]`` operator
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -269,4 +298,3 @@ Performance improvements
   ``level`` parameter passed (:issue:`545`)
 - Ported skiplist data structure to C to speed up ``rolling_median`` by about
   5-10x in most typical use cases (:issue:`374`)
-
diff --git a/doc/source/whatsnew/v0.9.1.txt b/doc/source/whatsnew/v0.9.1.txt
index 51788f77a..9dd29a5fe 100644
--- a/doc/source/whatsnew/v0.9.1.txt
+++ b/doc/source/whatsnew/v0.9.1.txt
@@ -36,7 +36,7 @@ New features
 
         df = DataFrame(np.random.randn(6, 3), columns=['A', 'B', 'C'])
 
-        df.ix[2:4] = np.nan
+        df.loc[2:4] = np.nan
 
         df.rank()
 

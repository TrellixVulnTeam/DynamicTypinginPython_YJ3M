commit 34fe1d617d2f358b0be8a46ef143913a2c8b938f
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Apr 18 12:53:40 2011 -0400

    refactored to remove SparseVector class

diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index 01d67d1a5..6a27dcff5 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -6,12 +6,12 @@ from pandas.core.index import Index, NULL_INDEX
 from pandas.core.series import Series, TimeSeries
 from pandas.core.frame import DataFrame
 
-from pandas.lib.sparse import BlockIndex, IntIndex, SparseVector
+from pandas.lib.sparse import BlockIndex, IntIndex
 import pandas.lib.sparse as splib
 
 def make_sparse(arr, kind='block', sparse_value=np.NaN):
     """
-    Convert ndarray to SparseVector
+    Convert ndarray to sparse format
 
     Parameters
     ----------
@@ -44,7 +44,7 @@ def make_sparse(arr, kind='block', sparse_value=np.NaN):
         raise ValueError('must be block or integer type')
 
     sparsified_values = arr[mask]
-    return SparseVector(sparsified_values, index)
+    return sparsified_values, index
 
 class SparseSeries(Series):
     """
@@ -52,74 +52,76 @@ class SparseSeries(Series):
 
     Parameters
     ----------
-
+    kind : {'block', 'integer'}
+    sparse_value : float
+        Defaults to NaN (code for missing)
     """
-    _vector = None
-    _sparse_value = None
+    sparse_index = None
+    sparse_value = None
 
-    def __new__(cls, data, index=None, copy=False, kind='block',
-                sparse_value=np.NaN):
+    def __new__(cls, data, index=None, sparse_index=None, copy=False,
+                kind='block', sparse_value=None):
+
+        if isinstance(data, SparseSeries):
+            if index is None:
+                index = data.index
+
+            if sparse_value is None:
+                sparse_index = data.sparse_value
 
-        if isinstance(data, SparseVector):
             if index is not None:
                 assert(len(index) == data.length)
+
+            values = np.asarray(data)
         elif isinstance(data, (Series, dict)):
             data = Series(data)
 
             if index is None:
                 index = data.index
 
-            data = make_sparse(data.values, kind=kind)
+            values, sparse_index = make_sparse(data.values, kind=kind)
         elif isinstance(data, np.ndarray):
-            data = make_sparse(data, kind=kind)
-
-        if index is None:
-            index = Index(np.arange(data.length))
-
-        # Create array, do *not* copy data by default, infer type
-        subarr = np.array(data.values, dtype=np.float64, copy=False)
+            if sparse_index is None:
+                values, sparse_index = make_sparse(data, kind=kind)
+            else:
+                values = data
+                assert(len(values) == sparse_index.npoints)
 
         if index is None:
-            raise Exception('Index cannot be None!')
+            index = Index(np.arange(sparse_index.length))
 
-        # This is to prevent mixed-type Series getting all casted to
-        # NumPy string type, e.g. NaN --> '-1#IND'.
-        if issubclass(subarr.dtype.type, basestring):
-            subarr = np.array(data, dtype=object, copy=copy)
+        # Create array, do *not* copy data by default
+        subarr = np.array(values, dtype=np.float64, copy=False)
 
         if index._allDates:
             cls = SparseTimeSeries
 
         # Change the class of the array to be the subclass type.
         subarr = subarr.view(cls)
-        subarr._vector = data
-        subarr._sparse_value = sparse_value
+        subarr.sparse_index = sparse_index
+        subarr.sparse_value = sparse_value
         subarr.index = index
         return subarr
 
-    def __len__(self):
-        return self._vector.length
-
     def __array_finalize__(self, obj):
         """
         Gets called after any ufunc or other array operations, necessary
         to pass on the index.
         """
         self._index = getattr(obj, '_index', None)
-        self._vector = getattr(obj, '_vector', None)
-        self._sparse_value = getattr(obj, '_sparse_value', None)
+        self.sparse_index = getattr(obj, 'sparse_index', None)
+        self.sparse_value = getattr(obj, 'sparse_value', None)
 
-    def astype(self, dtype):
-        # HACK
-        return self.copy()
-
-    def copy(self):
-        vec_copy = self._vector.copy()
-        return SparseSeries(vec_copy, index=self.index)
+    def __len__(self):
+        return self.sparse_index.length
 
     @property
     def values(self):
-        return self._vector.to_ndarray()
+        output = np.empty(self.sparse_index.length, dtype=np.float64)
+        int_index = self.sparse_index.to_int_index()
+        output.fill(self.sparse_value)
+        output.put(int_index.indices, self)
+        return output
 
     def to_dense(self):
         """
@@ -127,6 +129,15 @@ class SparseSeries(Series):
         """
         return Series(self.values, index=self.index)
 
+    def astype(self, dtype):
+        # HACK
+        return self.copy()
+
+    def copy(self):
+        values = np.asarray(self).copy()
+        return SparseSeries(values, index=self.index,
+                            sparse_index=self.sparse_index)
+
 class SparseTimeSeries(SparseSeries, TimeSeries):
     pass
 
diff --git a/pandas/lib/src/sparse.pyx b/pandas/lib/src/sparse.pyx
index a7d93e234..b86c410a6 100644
--- a/pandas/lib/src/sparse.pyx
+++ b/pandas/lib/src/sparse.pyx
@@ -240,190 +240,152 @@ cdef class BlockIndex(SparseIndex):
 
         return IntIndex(self.length, indices)
 
-    cpdef BlockIndex intersect(self, BlockIndex other):
-        return block_intersect(self, other)
-
-cdef BlockIndex block_intersect(BlockIndex x, BlockIndex y):
-    cdef:
-        pyst out_length
-        ndarray[int32_t, ndim=1] xloc, xlen, yloc, ylen
-
-        list out_blocs = []
-        list out_blengths = []
-
-        pyst xi = 0, yi = 0
-        int32_t cur_loc, cur_length, xend, yend, diff
-
-    # unwise? should enforce same length?
-    out_length = int_max(x.length, y.length)
-
-    xloc = x.blocs
-    xlen = x.blengths
-    yloc = y.blocs
-    ylen = y.blengths
-
-    while True:
-        # we are done (or possibly never began)
-        if xi >= x.nblocks or yi >= y.nblocks:
-            break
-
-        # completely symmetric...would like to avoid code dup but oh well
-        if xloc[xi] >= yloc[yi]:
-            cur_loc = xloc[xi]
-            diff = xloc[xi] - yloc[yi]
-
-            if ylen[yi] - diff <= 0:
-                # have to skip this block
-                yi += 1
-                continue
-
-            if ylen[yi] - diff < xlen[xi]:
-                # take end of y block, move onward
-                cur_length = ylen[yi] - diff
-                yi += 1
-            else:
-                # take end of x block
-                cur_length = xlen[xi]
-                xi += 1
-
-        else: # xloc[xi] < yloc[yi]
-            cur_loc = yloc[yi]
-            diff = yloc[yi] - xloc[xi]
-
-            if xlen[xi] - diff <= 0:
-                # have to skip this block
-                xi += 1
-                continue
-
-            if xlen[xi] - diff < ylen[yi]:
-                # take end of x block, move onward
-                cur_length = xlen[xi] - diff
-                xi += 1
-            else:
-                # take end of y block
-                cur_length = ylen[yi]
-                yi += 1
-
-        out_blocs.append(cur_loc)
-        out_blengths.append(cur_length)
-
-    return BlockIndex(x.length, out_blocs, out_blengths)
-
-#-------------------------------------------------------------------------------
-# SparseVector
-
-cdef class SparseVector:
-    '''
-    Data structure for storing sparse representation of floating point data
+    cpdef BlockIndex intersect(self, SparseIndex other):
+        '''
+        Intersect two BlockIndex objects
 
-    Parameters
-    ----------
-    '''
+        Parameters
+        ----------
 
-    cdef readonly:
-        pyst length, npoints
-        ndarray values
+        Returns
+        -------
+        intersection : BlockIndex
+        '''
+        cdef:
+            BlockIndex y
+            pyst out_length
+            ndarray[int32_t, ndim=1] xloc, xlen, yloc, ylen
 
-    cdef public:
-        SparseIndex index
-        object fill_value
+            list out_blocs = []
+            list out_blengths = []
 
-    cdef:
-        float64_t* vbuf
+            pyst xi = 0, yi = 0
+            int32_t cur_loc, cur_length, xend, yend, diff
 
-    def __init__(self, ndarray values, SparseIndex index, fill_value=np.NaN):
-        self.values = np.ascontiguousarray(values, dtype=np.float64)
-        self.index = index
-        self.vbuf = <float64_t*> self.values.data
 
-        self.npoints= index.npoints
-        self.length = index.length
-        self.fill_value = fill_value
+        y = other.to_block_index()
 
-    def __repr__(self):
-        # just for devel...
-        output = 'sparse.SparseVector\n'
-        output += 'Values: %s\n' % repr(self.values)
-        output += 'Index: %s' % repr(self.index)
-        return output
+        # unwise? should enforce same length?
+        out_length = int_max(self.length, y.length)
 
-    def copy(self):
-        return SparseVector(self.values.copy(), self.index)
+        xloc = self.blocs
+        xlen = self.blengths
+        yloc = y.blocs
+        ylen = y.blengths
 
-    def to_ndarray(self):
-        output = np.empty(self.index.length, dtype=np.float64)
-        dense_index = self.index.to_int_index()
+        while True:
+            # we are done (or possibly never began)
+            if xi >= self.nblocks or yi >= y.nblocks:
+                break
 
-        output.fill(self.fill_value)
-        output.put(dense_index.indices, self.values)
+            # completely symmetric...would like to avoid code dup but oh well
+            if xloc[xi] >= yloc[yi]:
+                cur_loc = xloc[xi]
+                diff = xloc[xi] - yloc[yi]
+
+                if ylen[yi] - diff <= 0:
+                    # have to skip this block
+                    yi += 1
+                    continue
+
+                if ylen[yi] - diff < xlen[xi]:
+                    # take end of y block, move onward
+                    cur_length = ylen[yi] - diff
+                    yi += 1
+                else:
+                    # take end of x block
+                    cur_length = xlen[xi]
+                    xi += 1
+
+            else: # xloc[xi] < yloc[yi]
+                cur_loc = yloc[yi]
+                diff = yloc[yi] - xloc[xi]
+
+                if xlen[xi] - diff <= 0:
+                    # have to skip this block
+                    xi += 1
+                    continue
+
+                if xlen[xi] - diff < ylen[yi]:
+                    # take end of x block, move onward
+                    cur_length = xlen[xi] - diff
+                    xi += 1
+                else:
+                    # take end of y block
+                    cur_length = ylen[yi]
+                    yi += 1
+
+            out_blocs.append(cur_loc)
+            out_blengths.append(cur_length)
+
+        return BlockIndex(self.length, out_blocs, out_blengths)
+
+    cpdef BlockIndex make_union(self, SparseIndex other):
+        '''
+        Combine together two BlockIndex objects, accepting indices if contained
+        in one or the other
 
-        return output
+        Parameters
+        ----------
+        other : SparseIndex
 
-    def slice(self, start, end):
-        pass
+        Notes
+        -----
+        union is a protected keyword in Cython, hence make_union
 
-    cpdef reindex(self):
+        Returns
+        -------
+        union : BlockIndex
+        '''
         pass
 
-    def __add__(self, other):
-        return self.add(other)
-    def __sub__(self, other):
-        return self.sub(other)
-    def __mul__(self, other):
-        return self.mul(other)
-    def __div__(self, other):
-        return self.div(other)
-
-    cpdef add(self, other):
-        return self._combine(other, operator.add, __add)
-
-    cpdef sub(self, other):
-        return self._combine(other, operator.sub, __sub)
-
-    cpdef mul(self, other):
-        return self._combine(other, operator.mul, __mul)
-
-    cpdef div(self, other):
-        return self._combine(other, operator.div, __div)
-
-    cdef _combine(self, object other, object op, double_func cop):
-        if isinstance(other, SparseVector):
-            return self._combine_vector(other, cop)
-        elif np.isscalar(other):
-            return self._combine_scalar(other, op)
-
-    cdef SparseVector _combine_scalar(self, float64_t other, object op):
-        new_values = op(self.values, other)
-        return SparseVector(new_values, self.index)
-
-    cdef SparseVector _combine_vector(self, SparseVector other, double_func op):
-        if isinstance(self.index, BlockIndex):
-            return block_op(self, other, op)
-        elif isinstance(self.index, IntIndex):
-            return dense_op(self, other, op)
-
-# faster to convert everything to dense?
-
-cdef SparseVector block_op(SparseVector x, SparseVector y, double_func op):
+#-------------------------------------------------------------------------------
+# Sparse operations
+
+cpdef sparse_nanadd(ndarray x, SparseIndex xindex,
+                    ndarray y, SparseIndex yindex):
+    return sparse_nancombine(x, xindex, y, yindex, __add)
+
+cpdef sparse_nansub(ndarray x, SparseIndex xindex,
+                    ndarray y, SparseIndex yindex):
+    return sparse_nancombine(x, xindex, y, yindex, __sub)
+
+cpdef sparse_nanmul(ndarray x, SparseIndex xindex,
+                    ndarray y, SparseIndex yindex):
+    return sparse_nancombine(x, xindex, y, yindex, __mul)
+
+cpdef sparse_nandiv(ndarray x, SparseIndex xindex,
+                    ndarray y, SparseIndex yindex):
+    return sparse_nancombine(x, xindex, y, yindex, __div)
+
+cdef tuple sparse_nancombine(ndarray x, SparseIndex xindex,
+                             ndarray y, SparseIndex yindex, double_func op):
+    if isinstance(xindex, BlockIndex):
+        return block_nanop(x, xindex.to_block_index(),
+                           y, yindex.to_block_index(), op)
+    elif isinstance(xindex, IntIndex):
+        return int_nanop(x, xindex.to_int_index(),
+                         y, yindex.to_int_index(), op)
+
+# NaN-based arithmetic operation-- no handling of fill values
+# TODO: faster to convert everything to dense?
+
+cdef tuple block_nanop(ndarray[float64_t, ndim=1] x, BlockIndex xindex,
+                       ndarray[float64_t, ndim=1] y, BlockIndex yindex,
+                       double_func op):
     cdef:
-        BlockIndex xindex, yindex, out_index
+        BlockIndex out_index
         int xi = 0, yi = 0, out_i = 0 # fp buf indices
         int xbp = 0, ybp = 0, obp = 0 # block positions
         pyst xblock = 0, yblock = 0, outblock = 0 # block numbers
 
-        SparseVector out
-
-    xindex = x.index.to_block_index()
-    yindex = y.index.to_block_index()
-
-    # need to do this first to know size of result array
-    out_index = x.index.intersect(y.index).to_block_index()
+        ndarray[float64_t, ndim=1] out
 
-    outarr = np.empty(out_index.npoints, dtype=np.float64)
-    out = SparseVector(outarr, out_index)
+    out_index = xindex.intersect(yindex)
+    out = np.empty(out_index.npoints, dtype=np.float64)
 
     # walk the two SparseVectors, adding matched locations...
-    for out_i from 0 <= out_i < out.npoints:
+    for out_i from 0 <= out_i < out_index.npoints:
 
         # I have a feeling this is inefficient
 
@@ -443,7 +405,7 @@ cdef SparseVector block_op(SparseVector x, SparseVector y, double_func op):
                 yblock += 1
                 ybp = 0
 
-        out.vbuf[out_i] = op(x.vbuf[xi], y.vbuf[yi])
+        out[out_i] = op(x[xi], y[yi])
 
         # advance. strikes me as too complicated
         xi += 1
@@ -464,25 +426,22 @@ cdef SparseVector block_op(SparseVector x, SparseVector y, double_func op):
             outblock += 1
             obp = 0
 
-    return out
+    return out, out_index
 
-cdef SparseVector dense_op(SparseVector x, SparseVector y, double_func op):
+cdef tuple int_nanop(ndarray[float64_t, ndim=1] x, IntIndex xindex,
+                     ndarray[float64_t, ndim=1] y, IntIndex yindex,
+                     double_func op):
     cdef:
-        IntIndex xindex, yindex, out_index
+        IntIndex out_index
         int xi = 0, yi = 0, out_i = 0 # fp buf indices
-
-        SparseVector out
-
-    xindex = x.index.to_int_index()
-    yindex = y.index.to_int_index()
+        ndarray[float64_t, ndim=1] out
 
     # need to do this first to know size of result array
-    out_index = x.index.intersect(y.index).to_int_index()
-    outarr = np.empty(out_index.npoints, dtype=np.float64)
-    out = SparseVector(outarr, out_index)
+    out_index = xindex.intersect(yindex).to_int_index()
+    out = np.empty(out_index.npoints, dtype=np.float64)
 
     # walk the two SparseVectors, adding matched locations...
-    for out_i from 0 <= out_i < out.npoints:
+    for out_i from 0 <= out_i < out_index.npoints:
 
         # walk x
         while xindex.indp[xi] < out_index.indp[out_i]:
@@ -492,10 +451,10 @@ cdef SparseVector dense_op(SparseVector x, SparseVector y, double_func op):
         while yindex.indp[yi] < out_index.indp[out_i]:
             yi += 1
 
-        out.vbuf[out_i] = op(x.vbuf[xi], y.vbuf[yi])
+        out[out_i] = op(x[xi], y[yi])
 
         # advance
         xi += 1
         yi += 1
 
-    return out
+    return out, out_index
diff --git a/pandas/lib/tests/test_sparse.py b/pandas/lib/tests/test_sparse.py
index 71998abee..583c295b2 100644
--- a/pandas/lib/tests/test_sparse.py
+++ b/pandas/lib/tests/test_sparse.py
@@ -7,8 +7,8 @@ import numpy as np
 import operator
 from numpy.testing import assert_almost_equal, assert_equal
 
-from pandas.lib.sparse import IntIndex, BlockIndex, SparseVector
-import pandas.lib.sparse as sparse
+from pandas.lib.sparse import IntIndex, BlockIndex
+import pandas.lib.sparse as sparselib
 
 TEST_LENGTH = 20
 
@@ -16,38 +16,38 @@ plain_case = dict(xloc = [0, 7, 15],
                   xlen = [3, 5, 5],
                   yloc = [2, 9, 14],
                   ylen = [2, 3, 5],
-                  eloc = [2, 9, 15],
-                  elen = [1, 3, 4])
+                  intersect_loc = [2, 9, 15],
+                  intersect_len = [1, 3, 4])
 delete_blocks = dict(xloc = [0, 5],
                      xlen = [4, 4],
                      yloc = [1],
                      ylen = [4],
-                     eloc = [1],
-                     elen = [3])
+                     intersect_loc = [1],
+                     intersect_len = [3])
 split_blocks = dict(xloc = [0],
                     xlen = [10],
                     yloc = [0, 5],
                     ylen = [3, 7],
-                    eloc = [0, 5],
-                    elen = [3, 5])
+                    intersect_loc = [0, 5],
+                    intersect_len = [3, 5])
 skip_block = dict(xloc = [10],
                   xlen = [5],
                   yloc = [0, 12],
                   ylen = [5, 3],
-                  eloc = [12],
-                  elen = [3])
+                  intersect_loc = [12],
+                  intersect_len = [3])
 
 no_intersect = dict(xloc = [0, 10],
                     xlen = [4, 6],
                     yloc = [5, 17],
                     ylen = [4, 2],
-                    eloc = [],
-                    elen = [])
+                    intersect_loc = [],
+                    intersect_len = [])
 
 def check_cases(_check_case):
     def _check_case_dict(case):
         _check_case(case['xloc'], case['xlen'], case['yloc'], case['ylen'],
-                    case['eloc'], case['elen'])
+                    case['intersect_loc'], case['intersect_len'])
 
     _check_case_dict(plain_case)
     _check_case_dict(delete_blocks)
@@ -149,9 +149,12 @@ class TestIntIndex(TestCase):
 
         check_cases(_check_case)
 
-class TestSparseVector(TestCase):
+    def test_union(self):
+        pass
 
-    def _arith_op_tests(self, op):
+class TestSparseOperators(TestCase):
+
+    def _arith_op_tests(self, sparse_op, python_op):
         def _check_case(xloc, xlen, yloc, ylen, eloc, elen):
             xindex = BlockIndex(TEST_LENGTH, xloc, xlen)
             yindex = BlockIndex(TEST_LENGTH, yloc, ylen)
@@ -159,38 +162,37 @@ class TestSparseVector(TestCase):
             xdindex = xindex.to_int_index()
             ydindex = yindex.to_int_index()
 
-            xvals = np.arange(xindex.npoints) * 10 + 1
-            yvals = np.arange(yindex.npoints) * 100 + 1
-            x = SparseVector(xvals, xindex)
-            y = SparseVector(yvals, yindex)
-            xd = SparseVector(xvals, xdindex)
-            yd = SparseVector(yvals, ydindex)
+            x = np.arange(xindex.npoints) * 10. + 1
+            y = np.arange(yindex.npoints) * 100. + 1
 
-            result_block = op(x, y)
-            result_dense = op(xd, yd)
+            result_block_vals, rb_index = sparse_op(x, xindex, y, yindex)
+            result_int_vals, ri_index = sparse_op(x, xdindex, y, ydindex)
 
-            assert_equal(result_block.values, result_dense.values)
+            self.assert_(rb_index.to_int_index().equals(ri_index))
+            assert_equal(result_block_vals, result_int_vals)
 
             # check versus Series...
-            xseries = Series(xvals, xdindex.indices)
-            yseries = Series(yvals, ydindex.indices)
-            series_result = op(xseries, yseries).valid()
-            assert_equal(result_block.values, series_result.values)
+            xseries = Series(x, xdindex.indices)
+            yseries = Series(y, ydindex.indices)
+            series_result = python_op(xseries, yseries).valid()
+            assert_equal(result_block_vals, series_result.values)
 
         check_cases(_check_case)
 
 # too cute? oh but how I abhor code duplication
 
 check_ops = ['add', 'sub', 'mul', 'div']
-def make_optestf(op):
+def make_nanoptestf(op):
     def f(self):
-        self._arith_op_tests(getattr(operator, op))
-    f.__name__ = 'test_%s' % op
+        sparse_op = getattr(sparselib, 'sparse_nan%s' % op)
+        python_op = getattr(operator, op)
+        self._arith_op_tests(sparse_op, python_op)
+    f.__name__ = 'test_nan%s' % op
     return f
 
 for op in check_ops:
-    f = make_optestf(op)
-    setattr(TestSparseVector, f.__name__, f)
+    f = make_nanoptestf(op)
+    setattr(TestSparseOperators, f.__name__, f)
     del f
 
 if __name__ == '__main__':

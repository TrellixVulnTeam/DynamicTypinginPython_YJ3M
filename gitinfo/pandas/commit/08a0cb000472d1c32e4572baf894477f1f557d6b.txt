commit 08a0cb000472d1c32e4572baf894477f1f557d6b
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon May 11 11:51:49 2020 -0700

    PERF: use fast-paths for dtype checks (#34118)

diff --git a/pandas/core/arrays/interval.py b/pandas/core/arrays/interval.py
index 8cac909b7..32c170ba2 100644
--- a/pandas/core/arrays/interval.py
+++ b/pandas/core/arrays/interval.py
@@ -149,9 +149,16 @@ class IntervalArray(IntervalMixin, ExtensionArray):
     can_hold_na = True
     _na_value = _fill_value = np.nan
 
-    def __new__(cls, data, closed=None, dtype=None, copy=False, verify_integrity=True):
+    def __new__(
+        cls,
+        data,
+        closed=None,
+        dtype=None,
+        copy: bool = False,
+        verify_integrity: bool = True,
+    ):
 
-        if isinstance(data, ABCSeries) and is_interval_dtype(data):
+        if isinstance(data, ABCSeries) and is_interval_dtype(data.dtype):
             data = data._values
 
         if isinstance(data, (cls, ABCIntervalIndex)):
@@ -569,8 +576,8 @@ class IntervalArray(IntervalMixin, ExtensionArray):
 
         # determine the dtype of the elements we want to compare
         if isinstance(other, Interval):
-            other_dtype = "interval"
-        elif not is_categorical_dtype(other):
+            other_dtype = pandas_dtype("interval")
+        elif not is_categorical_dtype(other.dtype):
             other_dtype = other.dtype
         else:
             # for categorical defer to categories for dtype
@@ -674,7 +681,8 @@ class IntervalArray(IntervalMixin, ExtensionArray):
         array : ExtensionArray or ndarray
             ExtensionArray or NumPy ndarray with 'dtype' for its dtype.
         """
-        dtype = pandas_dtype(dtype)
+        if dtype is not None:
+            dtype = pandas_dtype(dtype)
         if is_interval_dtype(dtype):
             if dtype == self.dtype:
                 return self.copy() if copy else self
diff --git a/pandas/core/indexes/interval.py b/pandas/core/indexes/interval.py
index 6ae16db2e..7d7572973 100644
--- a/pandas/core/indexes/interval.py
+++ b/pandas/core/indexes/interval.py
@@ -410,7 +410,7 @@ class IntervalIndex(IntervalMixin, ExtensionIndex):
     def astype(self, dtype, copy=True):
         with rewrite_exception("IntervalArray", type(self).__name__):
             new_values = self._values.astype(dtype, copy=copy)
-        if is_interval_dtype(new_values):
+        if is_interval_dtype(new_values.dtype):
             return self._shallow_copy(new_values)
         return Index.astype(self, dtype, copy=copy)
 
diff --git a/pandas/core/reshape/merge.py b/pandas/core/reshape/merge.py
index bc612f891..0c796c8f4 100644
--- a/pandas/core/reshape/merge.py
+++ b/pandas/core/reshape/merge.py
@@ -1079,10 +1079,10 @@ class _MergeOperation:
             if (len(lk) and not len(rk)) or (not len(lk) and len(rk)):
                 continue
 
-            lk_is_cat = is_categorical_dtype(lk)
-            rk_is_cat = is_categorical_dtype(rk)
-            lk_is_object = is_object_dtype(lk)
-            rk_is_object = is_object_dtype(rk)
+            lk_is_cat = is_categorical_dtype(lk.dtype)
+            rk_is_cat = is_categorical_dtype(rk.dtype)
+            lk_is_object = is_object_dtype(lk.dtype)
+            rk_is_object = is_object_dtype(rk.dtype)
 
             # if either left or right is a categorical
             # then the must match exactly in categories & ordered
@@ -1105,12 +1105,12 @@ class _MergeOperation:
             # kinds to proceed, eg. int64 and int8, int and float
             # further if we are object, but we infer to
             # the same, then proceed
-            if is_numeric_dtype(lk) and is_numeric_dtype(rk):
+            if is_numeric_dtype(lk.dtype) and is_numeric_dtype(rk.dtype):
                 if lk.dtype.kind == rk.dtype.kind:
                     continue
 
                 # check whether ints and floats
-                elif is_integer_dtype(rk) and is_float_dtype(lk):
+                elif is_integer_dtype(rk.dtype) and is_float_dtype(lk.dtype):
                     if not (lk == lk.astype(rk.dtype))[~np.isnan(lk)].all():
                         warnings.warn(
                             "You are merging on int and float "
@@ -1120,7 +1120,7 @@ class _MergeOperation:
                         )
                     continue
 
-                elif is_float_dtype(rk) and is_integer_dtype(lk):
+                elif is_float_dtype(rk.dtype) and is_integer_dtype(lk.dtype):
                     if not (rk == rk.astype(lk.dtype))[~np.isnan(rk)].all():
                         warnings.warn(
                             "You are merging on int and float "
@@ -1140,14 +1140,14 @@ class _MergeOperation:
             # incompatible dtypes GH 9780, GH 15800
 
             # bool values are coerced to object
-            elif (lk_is_object and is_bool_dtype(rk)) or (
-                is_bool_dtype(lk) and rk_is_object
+            elif (lk_is_object and is_bool_dtype(rk.dtype)) or (
+                is_bool_dtype(lk.dtype) and rk_is_object
             ):
                 pass
 
             # object values are allowed to be merged
-            elif (lk_is_object and is_numeric_dtype(rk)) or (
-                is_numeric_dtype(lk) and rk_is_object
+            elif (lk_is_object and is_numeric_dtype(rk.dtype)) or (
+                is_numeric_dtype(lk.dtype) and rk_is_object
             ):
                 inferred_left = lib.infer_dtype(lk, skipna=False)
                 inferred_right = lib.infer_dtype(rk, skipna=False)
@@ -1167,13 +1167,17 @@ class _MergeOperation:
                     raise ValueError(msg)
 
             # datetimelikes must match exactly
-            elif needs_i8_conversion(lk) and not needs_i8_conversion(rk):
+            elif needs_i8_conversion(lk.dtype) and not needs_i8_conversion(rk.dtype):
                 raise ValueError(msg)
-            elif not needs_i8_conversion(lk) and needs_i8_conversion(rk):
+            elif not needs_i8_conversion(lk.dtype) and needs_i8_conversion(rk.dtype):
                 raise ValueError(msg)
-            elif is_datetime64tz_dtype(lk) and not is_datetime64tz_dtype(rk):
+            elif is_datetime64tz_dtype(lk.dtype) and not is_datetime64tz_dtype(
+                rk.dtype
+            ):
                 raise ValueError(msg)
-            elif not is_datetime64tz_dtype(lk) and is_datetime64tz_dtype(rk):
+            elif not is_datetime64tz_dtype(lk.dtype) and is_datetime64tz_dtype(
+                rk.dtype
+            ):
                 raise ValueError(msg)
 
             elif lk_is_object and rk_is_object:
diff --git a/pandas/core/reshape/tile.py b/pandas/core/reshape/tile.py
index 6eae54633..b6735282a 100644
--- a/pandas/core/reshape/tile.py
+++ b/pandas/core/reshape/tile.py
@@ -461,22 +461,22 @@ def _coerce_to_type(x):
     """
     dtype = None
 
-    if is_datetime64tz_dtype(x):
+    if is_datetime64tz_dtype(x.dtype):
         dtype = x.dtype
-    elif is_datetime64_dtype(x):
+    elif is_datetime64_dtype(x.dtype):
         x = to_datetime(x)
         dtype = np.dtype("datetime64[ns]")
-    elif is_timedelta64_dtype(x):
+    elif is_timedelta64_dtype(x.dtype):
         x = to_timedelta(x)
         dtype = np.dtype("timedelta64[ns]")
-    elif is_bool_dtype(x):
+    elif is_bool_dtype(x.dtype):
         # GH 20303
         x = x.astype(np.int64)
     # To support cut and qcut for IntegerArray we convert to float dtype.
     # Will properly support in the future.
     # https://github.com/pandas-dev/pandas/pull/31290
     # https://github.com/pandas-dev/pandas/issues/31389
-    elif is_extension_array_dtype(x) and is_integer_dtype(x):
+    elif is_extension_array_dtype(x.dtype) and is_integer_dtype(x.dtype):
         x = x.to_numpy(dtype=np.float64, na_value=np.nan)
 
     if dtype is not None:

commit d6774a7cc711c229f260513a77cb9388cc6c158f
Author: Jeff Reback <jeff@reback.net>
Date:   Sat Feb 28 10:59:45 2015 -0500

    API: consistency with .ix and .loc for getitem operations (GH8613)
    
    raise TypeError rather than KeyError on invalid scalar/slice indexing with that index type

diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index 5ab72f633..846285ef4 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -85,7 +85,7 @@ of multi-axis indexing.
 
 - ``.iloc`` is primarily integer position based (from ``0`` to
   ``length-1`` of the axis), but may also be used with a boolean
-  array.  ``.iloc`` will raise ``IndexError`` if a requested 
+  array.  ``.iloc`` will raise ``IndexError`` if a requested
   indexer is out-of-bounds, except *slice* indexers which allow
   out-of-bounds indexing.  (this conforms with python/numpy *slice*
   semantics).  Allowed inputs are:
@@ -292,6 +292,35 @@ Selection By Label
    This is sometimes called ``chained assignment`` and should be avoided.
    See :ref:`Returning a View versus Copy <indexing.view_versus_copy>`
 
+.. warning::
+
+   ``.loc`` is strict when you present slicers that are not compatible (or convertible) with the index type. For example
+   using integers in a ``DatetimeIndex`` or float indexers in an ``Int64Index``. These will raise a ``TypeError``.
+
+  .. ipython:: python
+
+     dfl = DataFrame(np.random.randn(5,4), columns=list('ABCD'), index=date_range('20130101',periods=5))
+     dfl
+     sl = Series(range(5),[-2,-1,1,2,3])
+     sl
+
+  .. code-block:: python
+
+     In [4]: dfl.loc[2:3]
+     TypeError: cannot do slice indexing on <class 'pandas.tseries.index.DatetimeIndex'> with these indexers [2] of <type 'int'>
+
+  .. code-block:: python
+
+     In [8]: sl.loc[-1.0:2]
+     TypeError: cannot do slice indexing on <class 'pandas.core.index.Int64Index'> with these indexers [-1.0] of <type 'float'>
+
+
+  String likes in slicing *can* be convertible to the type of the index and lead to natural slicing.
+
+  .. ipython:: python
+
+     dfl.loc['20130102':'20130104']
+
 pandas provides a suite of methods in order to have **purely label based indexing**. This is a strict inclusion based protocol.
 **at least 1** of the labels for which you ask, must be in the index or a ``KeyError`` will be raised! When slicing, the start bound is *included*, **AND** the stop bound is *included*. Integers are valid labels, but they refer to the label **and not the position**.
 
@@ -1486,5 +1515,3 @@ This will **not** work at all, and so should be avoided
    The chained assignment warnings / exceptions are aiming to inform the user of a possibly invalid
    assignment. There may be false positives; situations where a chained assignment is inadvertantly
    reported.
-
-
diff --git a/doc/source/whatsnew/v0.16.0.txt b/doc/source/whatsnew/v0.16.0.txt
index 155052770..1fcb60c86 100644
--- a/doc/source/whatsnew/v0.16.0.txt
+++ b/doc/source/whatsnew/v0.16.0.txt
@@ -211,6 +211,66 @@ Backwards incompatible API changes
      p // 0
 
 
+Indexing Changes
+~~~~~~~~~~~~~~~~
+
+.. _whatsnew_0160.api_breaking.indexing:
+
+The behavior of a small sub-set of edge cases for using ``.loc`` have changed (:issue:`8613`). Furthermore we have improved the content of the error messages that are raised:
+
+- slicing with ``.loc`` where the start and/or stop bound is not found in the index is now allowed; this previously would raise a ``KeyError``. This makes the behavior the same as ``.ix`` in this case. This change is only for slicing, not when indexing with a single label.
+
+  .. ipython:: python
+
+     df = DataFrame(np.random.randn(5,4), columns=list('ABCD'), index=date_range('20130101',periods=5))
+     df
+     s = Series(range(5),[-2,-1,1,2,3])
+     s
+
+  Previous Behavior
+
+  .. code-block:: python
+
+     In [4]: df.loc['2013-01-02':'2013-01-10']
+     KeyError: 'stop bound [2013-01-10] is not in the [index]'
+
+     In [6]: s.loc[-10:3]
+     KeyError: 'start bound [-10] is not the [index]'
+
+     In [8]: s.loc[-1.0:2]
+     Out[2]:
+     -1    1
+      1    2
+      2    3
+     dtype: int64
+
+  New Behavior
+
+  .. ipython:: python
+
+     df.loc['2013-01-02':'2013-01-10']
+     s.loc[-10:3]
+
+  .. code-block:: python
+
+     In [8]: s.loc[-1.0:2]
+     TypeError: cannot do slice indexing on <class 'pandas.core.index.Int64Index'> with these indexers [-1.0] of <type 'float'>
+
+- provide a useful exception for indexing with an invalid type for that index when using ``.loc``. For example trying to use ``.loc`` on an index of type ``DatetimeIndex`` or ``PeriodIndex`` or ``TimedeltaIndex``, with an integer (or a float).
+
+  Previous Behavior
+
+  .. code-block:: python
+
+     In [4]: df.loc[2:3]
+     KeyError: 'start bound [2] is not the [index]'
+
+  New Behavior
+
+  .. code-block:: python
+
+     In [4]: df.loc[2:3]
+     TypeError: Cannot do slice indexing on <class 'pandas.tseries.index.DatetimeIndex'> with <type 'int'> keys
 
 Deprecations
 ~~~~~~~~~~~~
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 0cad53785..94fe13124 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -640,7 +640,7 @@ class Index(IndexOpsMixin, PandasObject):
         def to_int():
             ikey = int(key)
             if ikey != key:
-                return self._convert_indexer_error(key, 'label')
+                return self._invalid_indexer('label', key)
             return ikey
 
         if typ == 'iloc':
@@ -651,7 +651,7 @@ class Index(IndexOpsMixin, PandasObject):
                 warnings.warn("scalar indexers for index type {0} should be integers and not floating point".format(
                     type(self).__name__),FutureWarning)
                 return key
-            return self._convert_indexer_error(key, 'label')
+            return self._invalid_indexer('label', key)
 
         if is_float(key):
             if not self.is_floating():
@@ -667,7 +667,7 @@ class Index(IndexOpsMixin, PandasObject):
 
         for c in ['start','stop','step']:
             if not f(getattr(key,c)):
-                self._convert_indexer_error(key.start, 'slice {0} value'.format(c))
+                self._invalid_indexer('slice {0} value'.format(c), key.start)
 
     def _convert_slice_indexer_getitem(self, key, is_index_slice=False):
         """ called from the getitem slicers, determine how to treat the key
@@ -698,7 +698,7 @@ class Index(IndexOpsMixin, PandasObject):
                                   "and not floating point",FutureWarning)
                     return int(v)
 
-                self._convert_indexer_error(v, 'slice {0} value'.format(c))
+                self._invalid_indexer('slice {0} value'.format(c), v)
 
             return slice(*[ f(c) for c in ['start','stop','step']])
 
@@ -787,11 +787,13 @@ class Index(IndexOpsMixin, PandasObject):
 
         return None
 
-    def _convert_indexer_error(self, key, msg=None):
-        if msg is None:
-            msg = 'label'
-        raise TypeError("the {0} [{1}] is not a proper indexer for this index "
-                        "type ({2})".format(msg, key, self.__class__.__name__))
+    def _invalid_indexer(self, form, key):
+        """ consistent invalid indexer message """
+        raise TypeError("cannot do {form} indexing on {klass} with these "
+                        "indexers [{key}] of {typ}".format(form=form,
+                                                           klass=type(self),
+                                                           key=key,
+                                                           typ=type(key)))
 
     def get_duplicates(self):
         from collections import defaultdict
@@ -2119,11 +2121,27 @@ class Index(IndexOpsMixin, PandasObject):
         label : object
         side : {'left', 'right'}
 
+        Returns
+        -------
+        label :  object
+
         Notes
         -----
         Value of `side` parameter should be validated in caller.
 
         """
+
+        # pass thru float indexers if we have a numeric type index
+        # which then can decide to process / or convert and warng
+        if is_float(label):
+            if not self.is_floating():
+                self._invalid_indexer('slice',label)
+
+        # we are not an integer based index, and we have an integer label
+        # treat as positional based slicing semantics
+        if not self.is_integer() and is_integer(label):
+            self._invalid_indexer('slice',label)
+
         return label
 
     def _searchsorted_monotonic(self, label, side='left'):
@@ -2158,10 +2176,12 @@ class Index(IndexOpsMixin, PandasObject):
                 " must be either 'left' or 'right': %s" % (side,))
 
         original_label = label
+
         # For datetime indices label may be a string that has to be converted
         # to datetime boundary according to its resolution.
         label = self._maybe_cast_slice_bound(label, side)
 
+        # we need to look up the label
         try:
             slc = self.get_loc(label)
         except KeyError as err:
@@ -2654,6 +2674,31 @@ class Float64Index(NumericIndex):
                             self.__class__)
         return Index(self.values, name=self.name, dtype=dtype)
 
+    def _maybe_cast_slice_bound(self, label, side):
+        """
+        This function should be overloaded in subclasses that allow non-trivial
+        casting on label-slice bounds, e.g. datetime-like indices allowing
+        strings containing formatted datetimes.
+
+        Parameters
+        ----------
+        label : object
+        side : {'left', 'right'}
+
+        Returns
+        -------
+        label :  object
+
+        Notes
+        -----
+        Value of `side` parameter should be validated in caller.
+
+        """
+        if not (is_integer(label) or is_float(label)):
+            self._invalid_indexer('slice',label)
+
+        return label
+
     def _convert_scalar_indexer(self, key, typ=None):
         if typ == 'iloc':
             return super(Float64Index, self)._convert_scalar_indexer(key,
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 1c951f58a..2e953fed2 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -1243,25 +1243,7 @@ class _LocIndexer(_LocationIndexer):
         # boolean
 
         if isinstance(key, slice):
-
-            if ax.is_floating():
-
-                # allowing keys to be slicers with no fallback
-                pass
-
-            else:
-                if key.start is not None:
-                    if key.start not in ax:
-                        raise KeyError(
-                            "start bound [%s] is not the [%s]" %
-                            (key.start, self.obj._get_axis_name(axis))
-                        )
-                if key.stop is not None:
-                    if key.stop not in ax:
-                        raise KeyError(
-                            "stop bound [%s] is not in the [%s]" %
-                            (key.stop, self.obj._get_axis_name(axis))
-                        )
+            return True
 
         elif is_bool_indexer(key):
             return True
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 901faef48..77a5d61ad 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -536,7 +536,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
             else:
 
                 # we can try to coerce the indexer (or this will raise)
-                new_key = self.index._convert_scalar_indexer(key)
+                new_key = self.index._convert_scalar_indexer(key,typ='getitem')
                 if type(new_key) != type(key):
                     return self.__getitem__(new_key)
                 raise
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 75c28681e..53732eb8b 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -950,16 +950,30 @@ class TestIndex(Base, tm.TestCase):
             self.assertEqual(idx.slice_locs(start=3), (3, n))
             self.assertEqual(idx.slice_locs(3, 8), (3, 6))
             self.assertEqual(idx.slice_locs(5, 10), (3, n))
-            self.assertEqual(idx.slice_locs(5.0, 10.0), (3, n))
-            self.assertEqual(idx.slice_locs(4.5, 10.5), (3, 8))
             self.assertEqual(idx.slice_locs(end=8), (0, 6))
             self.assertEqual(idx.slice_locs(end=9), (0, 7))
 
+            # reversed
             idx2 = idx[::-1]
             self.assertEqual(idx2.slice_locs(8, 2), (2, 6))
-            self.assertEqual(idx2.slice_locs(8.5, 1.5), (2, 6))
             self.assertEqual(idx2.slice_locs(7, 3), (2, 5))
-            self.assertEqual(idx2.slice_locs(10.5, -1), (0, n))
+
+        # float slicing
+        idx = Index(np.array([0, 1, 2, 5, 6, 7, 9, 10], dtype=float))
+        n = len(idx)
+        self.assertEqual(idx.slice_locs(5.0, 10.0), (3, n))
+        self.assertEqual(idx.slice_locs(4.5, 10.5), (3, 8))
+        idx2 = idx[::-1]
+        self.assertEqual(idx2.slice_locs(8.5, 1.5), (2, 6))
+        self.assertEqual(idx2.slice_locs(10.5, -1), (0, n))
+
+        # int slicing with floats
+        idx = Index(np.array([0, 1, 2, 5, 6, 7, 9, 10], dtype=int))
+        self.assertRaises(TypeError, lambda : idx.slice_locs(5.0, 10.0))
+        self.assertRaises(TypeError, lambda : idx.slice_locs(4.5, 10.5))
+        idx2 = idx[::-1]
+        self.assertRaises(TypeError, lambda : idx2.slice_locs(8.5, 1.5))
+        self.assertRaises(TypeError, lambda : idx2.slice_locs(10.5, -1))
 
     def test_slice_locs_dup(self):
         idx = Index(['a', 'a', 'b', 'c', 'd', 'd'])
diff --git a/pandas/tests/test_indexing.py b/pandas/tests/test_indexing.py
index 68c504b2a..8102ca5e7 100644
--- a/pandas/tests/test_indexing.py
+++ b/pandas/tests/test_indexing.py
@@ -20,7 +20,7 @@ from pandas.core.api import (DataFrame, Index, Series, Panel, isnull,
 from pandas.util.testing import (assert_almost_equal, assert_series_equal,
                                  assert_frame_equal, assert_panel_equal,
                                  assert_attr_equal)
-from pandas import concat
+from pandas import concat, lib
 from pandas.io.common import PerformanceWarning
 
 import pandas.util.testing as tm
@@ -211,8 +211,6 @@ class TestIndexing(tm.TestCase):
 
             except AssertionError:
                 raise
-            except TypeError:
-                raise AssertionError(_print('type error'))
             except Exception as detail:
 
                 # if we are in fails, the ok, otherwise raise it
@@ -608,7 +606,7 @@ class TestIndexing(tm.TestCase):
         expected = Series([0,1,0],index=[4,5,6])
         assert_series_equal(s, expected)
 
-    def test_ix_loc_setitem(self):
+    def test_ix_loc_setitem_consistency(self):
 
         # GH 5771
         # loc with slice and series
@@ -656,6 +654,84 @@ class TestIndexing(tm.TestCase):
         df2.ix[:,2] = pd.to_datetime(df['timestamp'], unit='s')
         assert_frame_equal(df2,expected)
 
+    def test_ix_loc_consistency(self):
+
+        # GH 8613
+        # some edge cases where ix/loc should return the same
+        # this is not an exhaustive case
+
+        def compare(result, expected):
+            if lib.isscalar(expected):
+                self.assertEqual(result, expected)
+            else:
+                self.assertTrue(expected.equals(result))
+
+        # failure cases for .loc, but these work for .ix
+        df = pd.DataFrame(np.random.randn(5,4), columns=list('ABCD'))
+        for key in [ slice(1,3), tuple([slice(0,2),slice(0,2)]), tuple([slice(0,2),df.columns[0:2]]) ]:
+
+            for index in [ tm.makeStringIndex, tm.makeUnicodeIndex,
+                           tm.makeDateIndex, tm.makePeriodIndex, tm.makeTimedeltaIndex ]:
+                df.index = index(len(df.index))
+                df.ix[key]
+
+                self.assertRaises(TypeError, lambda : df.loc[key])
+
+        df = pd.DataFrame(np.random.randn(5,4), columns=list('ABCD'), index=pd.date_range('2012-01-01', periods=5))
+
+        for key in [ '2012-01-03',
+                     '2012-01-31',
+                     slice('2012-01-03','2012-01-03'),
+                     slice('2012-01-03','2012-01-04'),
+                     slice('2012-01-03','2012-01-06',2),
+                     slice('2012-01-03','2012-01-31'),
+                     tuple([[True,True,True,False,True]]),
+                     ]:
+
+            # getitem
+
+            # if the expected raises, then compare the exceptions
+            try:
+                expected = df.ix[key]
+            except KeyError:
+                self.assertRaises(KeyError, lambda : df.loc[key])
+                continue
+
+            result = df.loc[key]
+            compare(result, expected)
+
+            # setitem
+            df1 = df.copy()
+            df2 = df.copy()
+
+            df1.ix[key] = 10
+            df2.loc[key] = 10
+            compare(df2, df1)
+
+        # edge cases
+        s = Series(['a','b','c','d'], [1,2,3,4])
+        self.assertRaises(TypeError, lambda : s.ix[1.5:5.5])
+        self.assertRaises(TypeError, lambda : s.loc[1.5:5.5])
+
+        s = Series([1,2,3,4], index=list('abde'))
+
+        result1 = s['a':'c']
+        result2 = s.ix['a':'c']
+        result3 = s.loc['a':'c']
+        assert_series_equal(result1,result2)
+        assert_series_equal(result1,result3)
+
+        # now work rather than raising KeyError
+        s = Series(range(5),[-2,-1,1,2,3])
+
+        result1 = s.ix[-10:3]
+        result2 = s.loc[-10:3]
+        assert_series_equal(result1,result2)
+
+        result1 = s.ix[0:3]
+        result2 = s.loc[0:3]
+        assert_series_equal(result1,result2)
+
     def test_loc_setitem_multiindex(self):
 
         # GH7190
@@ -776,7 +852,11 @@ class TestIndexing(tm.TestCase):
     def test_loc_getitem_label_out_of_range(self):
 
         # out of range label
-        self.check_result('label range', 'loc', 'f', 'ix', 'f', typs = ['ints','labels','mixed','ts','floats'], fails=KeyError)
+        self.check_result('label range', 'loc', 'f', 'ix', 'f', typs = ['ints','labels','mixed','ts'], fails=KeyError)
+        self.check_result('label range', 'loc', 'f', 'ix', 'f', typs = ['floats'], fails=TypeError)
+        self.check_result('label range', 'loc', 20, 'ix', 20, typs = ['ints','labels','mixed'], fails=KeyError)
+        self.check_result('label range', 'loc', 20, 'ix', 20, typs = ['ts'], axes=0, fails=TypeError)
+        self.check_result('label range', 'loc', 20, 'ix', 20, typs = ['floats'], axes=0, fails=TypeError)
 
     def test_loc_getitem_label_list(self):
 
@@ -814,9 +894,6 @@ class TestIndexing(tm.TestCase):
 
     def test_loc_getitem_int_slice(self):
 
-        # int slices in int
-        self.check_result('int slice1', 'loc', slice(2,4), 'ix', { 0 : [2,4], 1: [3,6], 2: [4,8] }, typs = ['ints'], fails=KeyError)
-
         # ok
         self.check_result('int slice2', 'loc', slice(2,4), 'ix', [2,4], typs = ['ints'], axes = 0)
         self.check_result('int slice2', 'loc', slice(3,6), 'ix', [3,6], typs = ['ints'], axes = 1)
@@ -920,7 +997,7 @@ class TestIndexing(tm.TestCase):
     def test_loc_getitem_label_slice(self):
 
         # label slices (with ints)
-        self.check_result('lab slice', 'loc', slice(1,3), 'ix', slice(1,3), typs = ['labels','mixed','ts','floats','empty'], fails=KeyError)
+        self.check_result('lab slice', 'loc', slice(1,3), 'ix', slice(1,3), typs = ['labels','mixed','empty','ts','floats'], fails=TypeError)
 
         # real label slices
         self.check_result('lab slice', 'loc', slice('a','c'), 'ix', slice('a','c'), typs = ['labels'], axes=0)
@@ -931,20 +1008,15 @@ class TestIndexing(tm.TestCase):
         self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=1, fails=KeyError)
         self.check_result('ts  slice', 'loc', slice('20130102','20130104'), 'ix', slice('20130102','20130104'), typs = ['ts'], axes=2, fails=KeyError)
 
-        self.check_result('mixed slice', 'loc', slice(2,8), 'ix', slice(2,8), typs = ['mixed'], axes=0, fails=KeyError)
+        self.check_result('mixed slice', 'loc', slice(2,8), 'ix', slice(2,8), typs = ['mixed'], axes=0, fails=TypeError)
         self.check_result('mixed slice', 'loc', slice(2,8), 'ix', slice(2,8), typs = ['mixed'], axes=1, fails=KeyError)
         self.check_result('mixed slice', 'loc', slice(2,8), 'ix', slice(2,8), typs = ['mixed'], axes=2, fails=KeyError)
 
-        self.check_result('mixed slice', 'loc', slice(2,4,2), 'ix', slice(2,4,2), typs = ['mixed'], axes=0)
+        self.check_result('mixed slice', 'loc', slice(2,4,2), 'ix', slice(2,4,2), typs = ['mixed'], axes=0, fails=TypeError)
 
     def test_loc_general(self):
 
-        # GH 2922 (these are fails)
-        df = DataFrame(np.random.rand(4,4),columns=['A','B','C','D'])
-        self.assertRaises(KeyError, df.loc.__getitem__, tuple([slice(0,2),slice(0,2)]))
-
         df = DataFrame(np.random.rand(4,4),columns=['A','B','C','D'], index=['A','B','C','D'])
-        self.assertRaises(KeyError, df.loc.__getitem__, tuple([slice(0,2),df.columns[0:2]]))
 
         # want this to work
         result = df.loc[:,"A":"B"].iloc[0:2,:]
@@ -3239,10 +3311,10 @@ class TestIndexing(tm.TestCase):
         # don't allow not string inserts
         def f():
             df.loc[100.0, :] = df.ix[0]
-        self.assertRaises(ValueError, f)
+        self.assertRaises(TypeError, f)
         def f():
             df.loc[100,:] = df.ix[0]
-        self.assertRaises(ValueError, f)
+        self.assertRaises(TypeError, f)
 
         def f():
             df.ix[100.0, :] = df.ix[0]
@@ -3887,8 +3959,8 @@ class TestIndexing(tm.TestCase):
             check_invalid(index())
         check_invalid(Index(np.arange(5) * 2.5),loc=KeyError, ix=KeyError, getitem=KeyError)
 
-        def check_getitem(index):
-
+        def check_index(index, error):
+            index = index()
             s = Series(np.arange(len(index)),index=index)
 
             # positional selection
@@ -3898,22 +3970,26 @@ class TestIndexing(tm.TestCase):
             result4 = s.iloc[5.0]
 
             # by value
-            self.assertRaises(KeyError, lambda : s.loc[5])
-            self.assertRaises(KeyError, lambda : s.loc[5.0])
+            self.assertRaises(error, lambda : s.loc[5])
+            self.assertRaises(error, lambda : s.loc[5.0])
 
             # this is fallback, so it works
             result5 = s.ix[5]
             result6 = s.ix[5.0]
+
             self.assertEqual(result1, result2)
             self.assertEqual(result1, result3)
             self.assertEqual(result1, result4)
             self.assertEqual(result1, result5)
             self.assertEqual(result1, result6)
 
-        # all index types except float/int
-        for index in [ tm.makeStringIndex, tm.makeUnicodeIndex,
-                       tm.makeDateIndex, tm.makePeriodIndex ]:
-            check_getitem(index())
+        # string-like
+        for index in [ tm.makeStringIndex, tm.makeUnicodeIndex ]:
+            check_index(index, KeyError)
+
+        # datetimelike
+        for index in [ tm.makeDateIndex, tm.makeTimedeltaIndex, tm.makePeriodIndex ]:
+            check_index(index, TypeError)
 
         # exact indexing when found on IntIndex
         s = Series(np.arange(10),dtype='int64')
@@ -3943,8 +4019,8 @@ class TestIndexing(tm.TestCase):
             assert_series_equal(result1, result2)
             assert_series_equal(result1, result3)
 
-            # not in the index
-            self.assertRaises(KeyError, lambda : s.loc[2:5])
+            # loc will fail
+            self.assertRaises(TypeError, lambda : s.loc[2:5])
 
             # make all float slicing fail
             self.assertRaises(TypeError, lambda : s[2.0:5])
@@ -3955,9 +4031,9 @@ class TestIndexing(tm.TestCase):
             self.assertRaises(TypeError, lambda : s.ix[2.0:5.0])
             self.assertRaises(TypeError, lambda : s.ix[2:5.0])
 
-            self.assertRaises(KeyError, lambda : s.loc[2.0:5])
-            self.assertRaises(KeyError, lambda : s.loc[2.0:5.0])
-            self.assertRaises(KeyError, lambda : s.loc[2:5.0])
+            self.assertRaises(TypeError, lambda : s.loc[2.0:5])
+            self.assertRaises(TypeError, lambda : s.loc[2.0:5.0])
+            self.assertRaises(TypeError, lambda : s.loc[2:5.0])
 
             # these work for now
             #self.assertRaises(TypeError, lambda : s.iloc[2.0:5])
@@ -3966,7 +4042,7 @@ class TestIndexing(tm.TestCase):
 
         # all index types except int, float
         for index in [ tm.makeStringIndex, tm.makeUnicodeIndex,
-                       tm.makeDateIndex, tm.makePeriodIndex ]:
+                       tm.makeDateIndex, tm.makeTimedeltaIndex, tm.makePeriodIndex ]:
             check_slicing_positional(index())
 
         # int
@@ -3981,15 +4057,12 @@ class TestIndexing(tm.TestCase):
         # these are all value based
         result2 = s.ix[2:5]
         result3 = s.loc[2:5]
-        result4 = s.loc[2.0:5]
-        result5 = s.loc[2.0:5.0]
-        result6 = s.loc[2:5.0]
         assert_series_equal(result2, result3)
-        assert_series_equal(result2, result4)
-        assert_series_equal(result2, result5)
-        assert_series_equal(result2, result6)
 
         # make all float slicing fail
+        self.assertRaises(TypeError, lambda : s.loc[2.0:5])
+        self.assertRaises(TypeError, lambda : s.loc[2.0:5.0])
+        self.assertRaises(TypeError, lambda : s.loc[2:5.0])
         self.assertRaises(TypeError, lambda : s[2.0:5])
         self.assertRaises(TypeError, lambda : s[2.0:5.0])
         self.assertRaises(TypeError, lambda : s[2:5.0])
@@ -4097,9 +4170,7 @@ class TestIndexing(tm.TestCase):
         import warnings
         warnings.filterwarnings(action='error', category=FutureWarning)
 
-        for index in [ tm.makeStringIndex, tm.makeUnicodeIndex,
-                       tm.makeDateIndex, tm.makePeriodIndex ]:
-
+        def check_index(index):
             i = index(5)
 
             for s in  [ Series(np.arange(len(i)),index=i), DataFrame(np.random.randn(len(i),len(i)),index=i,columns=i) ]:
@@ -4114,8 +4185,11 @@ class TestIndexing(tm.TestCase):
             # fallsback to position selection ,series only
             s = Series(np.arange(len(i)),index=i)
             s[3]
-            self.assertRaises(FutureWarning, lambda :
-                              s[3.0])
+            self.assertRaises(FutureWarning, lambda : s[3.0])
+
+        for index in [ tm.makeStringIndex, tm.makeUnicodeIndex,
+                       tm.makeDateIndex, tm.makeTimedeltaIndex, tm.makePeriodIndex ]:
+            check_index(index)
 
         # ints
         i = index(5)
diff --git a/pandas/tseries/base.py b/pandas/tseries/base.py
index a1904d38a..9664cef52 100644
--- a/pandas/tseries/base.py
+++ b/pandas/tseries/base.py
@@ -8,6 +8,7 @@ from datetime import datetime, time, timedelta
 from pandas import compat
 import numpy as np
 from pandas.core import common as com
+from pandas.core.common import is_integer, is_float
 import pandas.tslib as tslib
 import pandas.lib as lib
 from pandas.core.index import Index
@@ -297,6 +298,13 @@ class DatetimeIndexOpsMixin(object):
         from pandas.tseries.frequencies import get_reso_string
         return get_reso_string(self._resolution)
 
+    def _convert_scalar_indexer(self, key, typ=None):
+        """ we don't allow integer or float indexing on datetime-like when using loc """
+        if typ in ['loc'] and lib.isscalar(key) and (is_integer(key) or is_float(key)):
+            self._invalid_indexer('index',key)
+
+        return super(DatetimeIndexOpsMixin, self)._convert_scalar_indexer(key, typ=typ)
+
     def _add_datelike(self, other):
         raise NotImplementedError
 
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 60281b6b8..f733a7183 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -10,7 +10,7 @@ import warnings
 
 from pandas.core.common import (_NS_DTYPE, _INT64_DTYPE,
                                 _values_from_object, _maybe_box,
-                                ABCSeries)
+                                ABCSeries, is_integer, is_float)
 from pandas.core.index import Index, Int64Index, Float64Index
 import pandas.compat as compat
 from pandas.compat import u
@@ -215,9 +215,9 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index):
                 freq = None
 
         if periods is not None:
-            if com.is_float(periods):
+            if is_float(periods):
                 periods = int(periods)
-            elif not com.is_integer(periods):
+            elif not is_integer(periods):
                 raise ValueError('Periods must be a number, got %s' %
                                  str(periods))
 
@@ -1271,15 +1271,17 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index):
         label : object
         side : {'left', 'right'}
 
+        Returns
+        -------
+        label :  object
+
         Notes
         -----
         Value of `side` parameter should be validated in caller.
 
         """
-        if isinstance(label, float):
-            raise TypeError('Cannot index datetime64 with float keys')
-        if isinstance(label, time):
-            raise KeyError('Cannot index datetime64 with time keys')
+        if is_float(label) or isinstance(label, time) or is_integer(label):
+            self._invalid_indexer('slice',label)
 
         if isinstance(label, compat.string_types):
             freq = getattr(self, 'freqstr',
@@ -1556,7 +1558,7 @@ class DatetimeIndex(DatetimeIndexOpsMixin, Int64Index):
         new_dates = np.delete(self.asi8, loc)
 
         freq = None
-        if lib.is_integer(loc):
+        if is_integer(loc):
             if loc in (0, -len(self), -1, len(self) - 1):
                 freq = self.freq
         else:
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index 074ed7209..95bbf3825 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -22,7 +22,8 @@ from pandas._period import (
 
 import pandas.core.common as com
 from pandas.core.common import (isnull, _INT64_DTYPE, _maybe_box,
-                                _values_from_object, ABCSeries)
+                                _values_from_object, ABCSeries,
+                                is_integer, is_float)
 from pandas import compat
 from pandas.lib import Timestamp, Timedelta
 import pandas.lib as lib
@@ -166,9 +167,9 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
         freq = frequencies.get_standard_freq(freq)
 
         if periods is not None:
-            if com.is_float(periods):
+            if is_float(periods):
                 periods = int(periods)
-            elif not com.is_integer(periods):
+            elif not is_integer(periods):
                 raise ValueError('Periods must be a number, got %s' %
                                  str(periods))
 
@@ -533,7 +534,7 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
         try:
             return self._engine.get_loc(key)
         except KeyError:
-            if com.is_integer(key):
+            if is_integer(key):
                 raise
 
             try:
@@ -576,6 +577,8 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
                 return bounds[0 if side == 'left' else 1]
             except Exception:
                 raise KeyError(label)
+        elif is_integer(label) or is_float(label):
+            self._invalid_indexer('slice',label)
 
         return label
 
diff --git a/pandas/tseries/tdi.py b/pandas/tseries/tdi.py
index 897a28e8f..4e86bf9d9 100644
--- a/pandas/tseries/tdi.py
+++ b/pandas/tseries/tdi.py
@@ -7,7 +7,7 @@ import numpy as np
 
 from pandas.core.common import (ABCSeries, _TD_DTYPE, _INT64_DTYPE,
                                 is_timedelta64_dtype, _maybe_box,
-                                _values_from_object, isnull)
+                                _values_from_object, isnull, is_integer, is_float)
 from pandas.core.index import Index, Int64Index
 import pandas.compat as compat
 from pandas.compat import u
@@ -156,9 +156,9 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, Int64Index):
                 freq = None
 
         if periods is not None:
-            if com.is_float(periods):
+            if is_float(periods):
                 periods = int(periods)
-            elif not com.is_integer(periods):
+            elif not is_integer(periods):
                 raise ValueError('Periods must be a number, got %s' %
                                  str(periods))
 
@@ -687,7 +687,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, Int64Index):
 
         Returns
         -------
-        bound : Timedelta or object
+        label :  object
 
         """
         if isinstance(label, compat.string_types):
@@ -698,12 +698,16 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, Int64Index):
             else:
                 return (lbound + _resolution_map[parsed.resolution]() -
                         Timedelta(1, 'ns'))
+        elif is_integer(label) or is_float(label):
+            self._invalid_indexer('slice',label)
+
         return label
 
     def _get_string_slice(self, key, use_lhs=True, use_rhs=True):
         freq = getattr(self, 'freqstr',
                        getattr(self, 'inferred_freq', None))
-
+        if is_integer(key) or is_float(key):
+            self._invalid_indexer('slice',key)
         loc = self._partial_td_slice(key, freq, use_lhs=use_lhs,
                                      use_rhs=use_rhs)
         return loc
@@ -866,7 +870,7 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, Int64Index):
         new_tds = np.delete(self.asi8, loc)
 
         freq = 'infer'
-        if lib.is_integer(loc):
+        if is_integer(loc):
             if loc in (0, -len(self), -1, len(self) - 1):
                 freq = self.freq
         else:

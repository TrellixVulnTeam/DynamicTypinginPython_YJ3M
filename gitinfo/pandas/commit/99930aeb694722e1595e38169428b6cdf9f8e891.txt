commit 99930aeb694722e1595e38169428b6cdf9f8e891
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Apr 21 21:34:58 2011 -0400

    operators with fill values appear to be working

diff --git a/pandas/lib/src/sparse.pyx b/pandas/lib/src/sparse.pyx
index 04dfe2c39..ac87a64ac 100644
--- a/pandas/lib/src/sparse.pyx
+++ b/pandas/lib/src/sparse.pyx
@@ -67,17 +67,11 @@ cdef class IntIndex(SparseIndex):
         pyst length, npoints
         ndarray indices
 
-    cdef:
-        int32_t* indp
-
     def __init__(self, pyst length, indices):
         self.length = length
         self.indices = np.ascontiguousarray(indices, dtype=np.int32)
-
         self.npoints = len(self.indices)
 
-        self.indp = <int32_t*> self.indices.data
-
     def __repr__(self):
         output = 'sparse.IntIndex\n'
         output += 'Indices: %s\n' % repr(self.indices)
@@ -105,31 +99,79 @@ cdef class IntIndex(SparseIndex):
         locs, lens = get_blocks(self.indices)
         return BlockIndex(self.length, locs, lens)
 
-    cpdef intersect(self, SparseIndex y_):
+    cpdef IntIndex intersect(self, SparseIndex y_):
         cdef:
-            pyst i, xi, yi = 0
+            pyst out_length, xi, yi = 0
             int32_t xind
+            ndarray[int32_t, ndim=1] xindices, yindices
             list new_list = []
             IntIndex y
 
         # if is one already, returns self
         y = y_.to_int_index()
 
+        xindices = self.indices
+        yindices = y.indices
+
         for xi from 0 <= xi < self.npoints:
-            xind = self.indp[xi]
+            xind = xindices[xi]
 
-            while yi < y.npoints and y.indp[yi] < xind:
+            while yi < y.npoints and yindices[yi] < xind:
                 yi += 1
 
             if yi >= y.npoints:
                 break
 
             # TODO: would a two-pass algorithm be faster?
-            if y.indp[yi] == xind:
+            if yindices[yi] == xind:
                 new_list.append(xind)
 
         return IntIndex(self.length, new_list)
 
+    cpdef IntIndex make_union(self, SparseIndex y_):
+        cdef:
+            pyst out_length, i, xi, yi
+            int32_t xind
+            ndarray[int32_t, ndim=1] xindices, yindices
+            list new_list = []
+            IntIndex x, y
+
+        x = self
+
+        # if is one already, returns self
+        y = y_.to_int_index()
+
+        xindices = self.indices
+        yindices = y.indices
+
+        xi = yi = 0
+        while True:
+            if xi == x.npoints:
+                while yi < y.npoints:
+                    new_list.append(yindices[yi])
+                    yi += 1
+                break
+            elif yi == y.npoints:
+                while xi < x.npoints:
+                    new_list.append(xindices[xi])
+                    xi += 1
+                break
+
+            xind = xindices[xi]
+            yind = yindices[yi]
+
+            if xind == yind:
+                new_list.append(xind)
+                xi += 1
+                yi += 1
+            elif xind < yind:
+                new_list.append(xind)
+                xi += 1
+            else:
+                new_list.append(yind)
+                yi += 1
+
+        return IntIndex(x.length, new_list)
 
 cpdef get_blocks(ndarray[int32_t, ndim=1] indices):
     cdef:
@@ -280,7 +322,6 @@ cdef class BlockIndex(SparseIndex):
         '''
         cdef:
             BlockIndex y
-            pyst out_length
             ndarray[int32_t, ndim=1] xloc, xlen, yloc, ylen
 
             list out_blocs = []
@@ -291,9 +332,6 @@ cdef class BlockIndex(SparseIndex):
 
         y = other.to_block_index()
 
-        # unwise? should enforce same length?
-        out_length = int_max(self.length, y.length)
-
         xloc = self.blocs
         xlen = self.blengths
         yloc = y.blocs
@@ -309,7 +347,7 @@ cdef class BlockIndex(SparseIndex):
                 cur_loc = xloc[xi]
                 diff = xloc[xi] - yloc[yi]
 
-                if ylen[yi] - diff <= 0:
+                if ylen[yi] <= diff:
                     # have to skip this block
                     yi += 1
                     continue
@@ -327,7 +365,7 @@ cdef class BlockIndex(SparseIndex):
                 cur_loc = yloc[yi]
                 diff = yloc[yi] - xloc[xi]
 
-                if xlen[xi] - diff <= 0:
+                if xlen[xi] <= diff:
                     # have to skip this block
                     xi += 1
                     continue
@@ -344,9 +382,9 @@ cdef class BlockIndex(SparseIndex):
             out_blocs.append(cur_loc)
             out_blengths.append(cur_length)
 
-        return BlockIndex(out_length, out_blocs, out_blengths)
+        return BlockIndex(self.length, out_blocs, out_blengths)
 
-    cpdef BlockIndex make_union(self, SparseIndex other):
+    cpdef BlockIndex make_union(self, SparseIndex y):
         '''
         Combine together two BlockIndex objects, accepting indices if contained
         in one or the other
@@ -363,21 +401,17 @@ cdef class BlockIndex(SparseIndex):
         -------
         union : BlockIndex
         '''
-        return BlockUnion(self, other.to_block_index()).result
-
-# class BlockIntersection(object):
+        return BlockUnion(self, y.to_block_index()).result
 
-#     def __init__(self, BlockIndex x, BlockIndex y):
-#         pass
 
-cdef class BlockUnion(object):
+cdef class BlockMerge(object):
     '''
     Object-oriented approach makes sharing state between recursive functions a
     lot easier and reduces code duplication
     '''
     cdef:
         BlockIndex x, y, result
-        ndarray xstart, xend, ystart, yend
+        ndarray xstart, xlen, xend, ystart, ylen, yend
         int32_t xi, yi # block indices
 
     def __init__(self, BlockIndex x, BlockIndex y):
@@ -385,24 +419,48 @@ cdef class BlockUnion(object):
         self.y = y
 
         self.xstart = self.x.blocs
-        self.xend = self.x.blocs + self.x.blengths
         self.ystart = self.y.blocs
+
+        self.xend = self.x.blocs + self.x.blengths
         self.yend = self.y.blocs + self.y.blengths
 
+        # self.xlen = self.x.blengths
+        # self.ylen = self.y.blengths
+
         self.xi = 0
         self.yi = 0
 
         self.result = self._make_merged_blocks()
 
+    cdef _make_merged_blocks(self):
+        raise NotImplementedError
+
+    cdef _set_current_indices(self, int32_t xi, int32_t yi, bint mode):
+        if mode == 0:
+            self.xi = xi
+            self.yi = yi
+        else:
+            self.xi = yi
+            self.yi = xi
+
+cdef class BlockIntersection(BlockMerge):
+    '''
+    not done yet
+    '''
+    pass
+
+cdef class BlockUnion(BlockMerge):
+    '''
+    Object-oriented approach makes sharing state between recursive functions a
+    lot easier and reduces code duplication
+    '''
+
     cdef _make_merged_blocks(self):
         cdef:
-            pyst out_length
             ndarray[int32_t, ndim=1] xstart, xend, ystart, yend
             int32_t nstart, nend, diff
             list out_blocs = [], out_blengths = []
 
-        out_length = int_max(self.x.length, self.y.length)
-
         xstart = self.xstart
         xend = self.xend
         ystart = self.ystart
@@ -434,7 +492,7 @@ cdef class BlockUnion(object):
             out_blocs.append(nstart)
             out_blengths.append(nend - nstart)
 
-        return BlockIndex(out_length, out_blocs, out_blengths)
+        return BlockIndex(self.x.length, out_blocs, out_blengths)
 
     cdef int32_t _find_next_block_end(self, bint mode) except -1:
         '''
@@ -500,17 +558,13 @@ cdef class BlockUnion(object):
                 # this also catches the case where blocks
                 return self._find_next_block_end(1 - mode)
 
-    cdef _set_current_indices(self, int32_t xi, int32_t yi, bint mode):
-        if mode == 0:
-            self.xi = xi
-            self.yi = yi
-        else:
-            self.xi = yi
-            self.yi = xi
 
 #-------------------------------------------------------------------------------
 # Sparse arithmetic
 
+# This probably needs to be "templated" to achieve maximum performance.
+# TODO: quantify performance boost to "templating"
+
 cpdef sparse_nanadd(ndarray x, SparseIndex xindex,
                     ndarray y, SparseIndex yindex):
     return sparse_nancombine(x, xindex, y, yindex, __add)
@@ -531,8 +585,9 @@ cpdef sparse_nanpow(ndarray x, SparseIndex xindex,
                     ndarray y, SparseIndex yindex):
     return sparse_nancombine(x, xindex, y, yindex, __pow)
 
-cdef tuple sparse_nancombine(ndarray x, SparseIndex xindex,
-                             ndarray y, SparseIndex yindex, double_func op):
+cdef inline tuple sparse_nancombine(ndarray x, SparseIndex xindex,
+                                    ndarray y, SparseIndex yindex,
+                                    double_func op):
     if isinstance(xindex, BlockIndex):
         return block_nanop(x, xindex.to_block_index(),
                            y, yindex.to_block_index(), op)
@@ -565,9 +620,9 @@ cpdef sparse_pow(ndarray x, SparseIndex xindex, float64_t xfill,
     return sparse_combine(x, xindex, xfill,
                              y, yindex, yfill, __pow)
 
-cdef tuple sparse_combine(ndarray x, SparseIndex xindex, float64_t xfill,
-                          ndarray y, SparseIndex yindex, float64_t yfill,
-                          double_func op):
+cdef inline tuple sparse_combine(ndarray x, SparseIndex xindex, float64_t xfill,
+                                 ndarray y, SparseIndex yindex, float64_t yfill,
+                                 double_func op):
     if isinstance(xindex, BlockIndex):
         return block_op(x, xindex.to_block_index(), xfill,
                         y, yindex.to_block_index(), yfill, op)
@@ -579,17 +634,22 @@ cdef tuple sparse_combine(ndarray x, SparseIndex xindex, float64_t xfill,
 # TODO: faster to convert everything to dense?
 
 @cython.boundscheck(False)
-cdef tuple block_nanop(ndarray[float64_t, ndim=1] x, BlockIndex xindex,
-                       ndarray[float64_t, ndim=1] y, BlockIndex yindex,
-                       double_func op):
+cdef inline tuple block_nanop(ndarray x_, BlockIndex xindex,
+                              ndarray y_, BlockIndex yindex,
+                              double_func op):
     cdef:
         BlockIndex out_index
         int xi = 0, yi = 0, out_i = 0 # fp buf indices
         int xbp = 0, ybp = 0, obp = 0 # block positions
         pyst xblock = 0, yblock = 0, outblock = 0 # block numbers
 
+        ndarray[float64_t, ndim=1] x, y
         ndarray[float64_t, ndim=1] out
 
+    # suppress Cython compiler warnings due to inlining
+    x = x_
+    y = y_
+
     out_index = xindex.intersect(yindex)
     out = np.empty(out_index.npoints, dtype=np.float64)
 
@@ -638,27 +698,37 @@ cdef tuple block_nanop(ndarray[float64_t, ndim=1] x, BlockIndex xindex,
     return out, out_index
 
 @cython.boundscheck(False)
-cdef tuple int_nanop(ndarray[float64_t, ndim=1] x, IntIndex xindex,
-                     ndarray[float64_t, ndim=1] y, IntIndex yindex,
-                     double_func op):
+cdef inline tuple int_nanop(ndarray x_, IntIndex xindex,
+                            ndarray y_, IntIndex yindex,
+                            double_func op):
     cdef:
         IntIndex out_index
         int xi = 0, yi = 0, out_i = 0 # fp buf indices
+        ndarray[int32_t, ndim=1] xindices, yindices, out_indices
+        ndarray[float64_t, ndim=1] x, y
         ndarray[float64_t, ndim=1] out
 
+    # suppress Cython compiler warnings due to inlining
+    x = x_
+    y = y_
+
     # need to do this first to know size of result array
-    out_index = xindex.intersect(yindex).to_int_index()
+    out_index = xindex.intersect(yindex)
     out = np.empty(out_index.npoints, dtype=np.float64)
 
+    xindices = xindex.indices
+    yindices = yindex.indices
+    out_indices = out_index.indices
+
     # walk the two SparseVectors, adding matched locations...
     for out_i from 0 <= out_i < out_index.npoints:
 
         # walk x
-        while xindex.indp[xi] < out_index.indp[out_i]:
+        while xindices[xi] < out_indices[out_i]:
             xi += 1
 
         # walk y
-        while yindex.indp[yi] < out_index.indp[out_i]:
+        while yindices[yi] < out_indices[out_i]:
             yi += 1
 
         out[out_i] = op(x[xi], y[yi])
@@ -670,70 +740,159 @@ cdef tuple int_nanop(ndarray[float64_t, ndim=1] x, IntIndex xindex,
     return out, out_index
 
 
-cdef tuple block_op(ndarray[float64_t, ndim=1] x, BlockIndex xindex,
-                    float64_t xfill,
-                    ndarray[float64_t, ndim=1] y, BlockIndex yindex,
-                    float64_t yfill, double_func op):
+@cython.boundscheck(False)
+cdef inline tuple block_op(ndarray x_, BlockIndex xindex, float64_t xfill,
+                           ndarray y_, BlockIndex yindex, float64_t yfill,
+                           double_func op):
+    '''
+    Binary operator on BlockIndex objects with fill values
+    '''
+
     cdef:
         BlockIndex out_index
         int xi = 0, yi = 0, out_i = 0 # fp buf indices
-        int xbp = 0, ybp = 0, obp = 0 # block positions
-        pyst xblock = 0, yblock = 0, outblock = 0 # block numbers
+        int xbp = 0, ybp = 0 # block positions
+        int32_t xloc, yloc
+        pyst xblock = 0, yblock = 0 # block numbers
 
+        ndarray[float64_t, ndim=1] x, y
         ndarray[float64_t, ndim=1] out
 
+    # to suppress Cython warning
+    x = x_
+    y = y_
+
     out_index = xindex.make_union(yindex)
     out = np.empty(out_index.npoints, dtype=np.float64)
 
+    # Wow, what a hack job. Need to do something about this
+
     # walk the two SparseVectors, adding matched locations...
     for out_i from 0 <= out_i < out_index.npoints:
+        if yblock == yindex.nblocks:
+            # use y fill value
+            out[out_i] = op(x[xi], yfill)
+            xi += 1
 
-        # I have a feeling this is inefficient
-
-        # walk x
-        while xindex.locbuf[xblock] + xbp < out_index.locbuf[outblock] + obp:
+            # advance x location
             xbp += 1
+            if xbp == xindex.lenbuf[xblock]:
+                xblock += 1
+                xbp = 0
+            continue
+
+        if xblock == xindex.nblocks:
+            # use x fill value
+            out[out_i] = op(xfill, y[yi])
+            yi += 1
+
+            # advance y location
+            ybp += 1
+            if ybp == yindex.lenbuf[yblock]:
+                yblock += 1
+                ybp = 0
+            continue
+
+        yloc = yindex.locbuf[yblock] + ybp
+        xloc = xindex.locbuf[xblock] + xbp
+
+        # each index in the out_index had to come from either x, y, or both
+        if xloc == yloc:
+            out[out_i] = op(x[xi], y[yi])
             xi += 1
+            yi += 1
+
+            # advance both locations
+            xbp += 1
             if xbp == xindex.lenbuf[xblock]:
                 xblock += 1
                 xbp = 0
 
-        # walk y
-        while yindex.locbuf[yblock] + ybp < out_index.locbuf[outblock] + obp:
             ybp += 1
+            if ybp == yindex.lenbuf[yblock]:
+                yblock += 1
+                ybp = 0
+
+        elif xloc < yloc:
+            # use y fill value
+            out[out_i] = op(x[xi], yfill)
+            xi += 1
+
+            # advance x location
+            xbp += 1
+            if xbp == xindex.lenbuf[xblock]:
+                xblock += 1
+                xbp = 0
+        else:
+            # use x fill value
+            out[out_i] = op(xfill, y[yi])
             yi += 1
+
+            # advance y location
+            ybp += 1
             if ybp == yindex.lenbuf[yblock]:
                 yblock += 1
                 ybp = 0
 
-        out[out_i] = op(x[xi], y[yi])
+    return out, out_index
 
-        # advance. strikes me as too complicated
-        xi += 1
-        yi += 1
 
-        xbp += 1
-        if xbp == xindex.lenbuf[xblock]:
-            xblock += 1
-            xbp = 0
+@cython.boundscheck(False)
+cdef inline tuple int_op(ndarray x_, IntIndex xindex, float64_t xfill,
+                         ndarray y_, IntIndex yindex, float64_t yfill,
+                         double_func op):
+    cdef:
+        IntIndex out_index
+        int xi = 0, yi = 0, out_i = 0 # fp buf indices
+        int32_t xloc, yloc
+        ndarray[int32_t, ndim=1] xindices, yindices, out_indices
+        ndarray[float64_t, ndim=1] x, y
+        ndarray[float64_t, ndim=1] out
 
-        ybp += 1
-        if ybp == yindex.lenbuf[yblock]:
-            yblock += 1
-            ybp = 0
+    # suppress Cython compiler warnings due to inlining
+    x = x_
+    y = y_
 
-        obp += 1
-        if obp == out_index.lenbuf[outblock]:
-            outblock += 1
-            obp = 0
+    # need to do this first to know size of result array
+    out_index = xindex.make_union(yindex)
+    out = np.empty(out_index.npoints, dtype=np.float64)
 
-    return out, out_index
+    xindices = xindex.indices
+    yindices = yindex.indices
+    out_indices = out_index.indices
 
-cdef tuple int_op(ndarray[float64_t, ndim=1] x, BlockIndex xindex,
-                  float64_t xfill,
-                  ndarray[float64_t, ndim=1] y, BlockIndex yindex,
-                  float64_t yfill, double_func op):
-    pass
+    # walk the two SparseVectors, adding matched locations...
+    for out_i from 0 <= out_i < out_index.npoints:
+        if xi == xindex.npoints:
+            # use x fill value
+            out[out_i] = op(xfill, y[yi])
+            yi += 1
+            continue
+
+        if yi == yindex.npoints:
+            # use y fill value
+            out[out_i] = op(x[xi], yfill)
+            xi += 1
+            continue
+
+        xloc = xindices[xi]
+        yloc = yindices[yi]
+
+        # each index in the out_index had to come from either x, y, or both
+        if xloc == yloc:
+            out[out_i] = op(x[xi], y[yi])
+            xi += 1
+            yi += 1
+        elif xloc < yloc:
+            # use y fill value
+            out[out_i] = op(x[xi], yfill)
+            xi += 1
+        else:
+            # use x fill value
+            out[out_i] = op(xfill, y[yi])
+            yi += 1
+
+    return out, out_index
 
 #-------------------------------------------------------------------------------
 # Indexing operations
diff --git a/pandas/lib/tests/test_sparse.py b/pandas/lib/tests/test_sparse.py
index 5ab35a8ab..2cdf7600f 100644
--- a/pandas/lib/tests/test_sparse.py
+++ b/pandas/lib/tests/test_sparse.py
@@ -59,6 +59,101 @@ def check_cases(_check_case):
     _check_case([0], [5], [], [], [], [])
     _check_case([], [], [], [], [], [])
 
+def test_index_make_union():
+    def _check_case(xloc, xlen, yloc, ylen, eloc, elen):
+        xindex = BlockIndex(TEST_LENGTH, xloc, xlen)
+        yindex = BlockIndex(TEST_LENGTH, yloc, ylen)
+        bresult = xindex.make_union(yindex)
+        assert(isinstance(bresult, BlockIndex))
+        assert_equal(bresult.blocs, eloc)
+        assert_equal(bresult.blengths, elen)
+
+        ixindex = xindex.to_int_index()
+        iyindex = yindex.to_int_index()
+        iresult = ixindex.make_union(iyindex)
+        assert(isinstance(iresult, IntIndex))
+        assert_equal(iresult.indices, bresult.to_int_index().indices)
+
+    """
+    x: ----
+    y:     ----
+    r: --------
+    """
+    xloc = [0]; xlen = [5]
+    yloc = [5]; ylen = [4]
+    eloc = [0]; elen = [9]
+    _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+    """
+    x: -----     -----
+    y:   -----          --
+    """
+    xloc = [0, 10]; xlen = [5, 5]
+    yloc = [2, 17]; ylen = [5, 2]
+    eloc = [0, 10, 17]; elen = [7, 5, 2]
+    _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+    """
+    x: ------
+    y:    -------
+    r: ----------
+    """
+    xloc = [1]; xlen = [5]
+    yloc = [3]; ylen = [5]
+    eloc = [1]; elen = [7]
+    _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+    """
+    x: ------  -----
+    y:    -------
+    r: -------------
+    """
+    xloc = [2, 10]; xlen = [4, 4]
+    yloc = [4]; ylen = [8]
+    eloc = [2]; elen = [12]
+    _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+    """
+    x: ---  -----
+    y: -------
+    r: -------------
+    """
+    xloc = [0, 5]; xlen = [3, 5]
+    yloc = [0]; ylen = [7]
+    eloc = [0]; elen = [10]
+    _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+    """
+    x: ------  -----
+    y:    -------  ---
+    r: -------------
+    """
+    xloc = [2, 10]; xlen = [4, 4]
+    yloc = [4, 13]; ylen = [8, 4]
+    eloc = [2]; elen = [15]
+    _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+    """
+    x: ----------------------
+    y:   ----  ----   ---
+    r: ----------------------
+    """
+    xloc = [2]; xlen = [15]
+    yloc = [4, 9, 14]; ylen = [3, 2, 2]
+    eloc = [2]; elen = [15]
+    _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+    """
+    x: ----       ---
+    y:       ---       ---
+    """
+    xloc = [0, 10]; xlen = [3, 3]
+    yloc = [5, 15]; ylen = [2, 2]
+    eloc = [0, 5, 10, 15]; elen = [3, 2, 3, 2]
+    _check_case(xloc, xlen, yloc, ylen, eloc, elen)
+
+    # TODO: different-length index objects
+
 class TestBlockIndex(TestCase):
 
     def test_equals(self):
@@ -96,93 +191,6 @@ class TestBlockIndex(TestCase):
 
         check_cases(_check_case)
 
-    def test_make_union(self):
-        def _check_case(xloc, xlen, yloc, ylen, eloc, elen):
-            xindex = BlockIndex(TEST_LENGTH, xloc, xlen)
-            yindex = BlockIndex(TEST_LENGTH, yloc, ylen)
-            result = xindex.make_union(yindex)
-            self.assert_(isinstance(result, BlockIndex))
-            assert_equal(result.blocs, eloc)
-            assert_equal(result.blengths, elen)
-
-        """
-        x: ----
-        y:     ----
-        r: --------
-        """
-        xloc = [0]; xlen = [5]
-        yloc = [5]; ylen = [4]
-        eloc = [0]; elen = [9]
-        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
-
-        """
-        x: -----     -----
-        y:   -----          --
-        """
-        xloc = [0, 10]; xlen = [5, 5]
-        yloc = [2, 17]; ylen = [5, 2]
-        eloc = [0, 10, 17]; elen = [7, 5, 2]
-        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
-
-        """
-        x: ------
-        y:    -------
-        r: ----------
-        """
-        xloc = [1]; xlen = [5]
-        yloc = [3]; ylen = [5]
-        eloc = [1]; elen = [7]
-        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
-
-        """
-        x: ------  -----
-        y:    -------
-        r: -------------
-        """
-        xloc = [2, 10]; xlen = [4, 4]
-        yloc = [4]; ylen = [8]
-        eloc = [2]; elen = [12]
-        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
-
-        """
-        x: ---  -----
-        y: -------
-        r: -------------
-        """
-        xloc = [0, 5]; xlen = [3, 5]
-        yloc = [0]; ylen = [7]
-        eloc = [0]; elen = [10]
-        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
-
-        """
-        x: ------  -----
-        y:    -------  ---
-        r: -------------
-        """
-        xloc = [2, 10]; xlen = [4, 4]
-        yloc = [4, 13]; ylen = [8, 4]
-        eloc = [2]; elen = [15]
-        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
-
-        """
-        x: ----------------------
-        y:   ----  ----   ---
-        r: ----------------------
-        """
-        xloc = [2]; xlen = [15]
-        yloc = [4, 9, 14]; ylen = [3, 2, 2]
-        eloc = [2]; elen = [15]
-        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
-
-        """
-        x: ----       ---
-        y:       ---       ---
-        """
-        xloc = [0, 10]; xlen = [3, 3]
-        yloc = [5, 15]; ylen = [2, 2]
-        eloc = [0, 5, 10, 15]; elen = [3, 2, 3, 2]
-        _check_case(xloc, xlen, yloc, ylen, eloc, elen)
-
     def test_to_int_index(self):
         locs = [0, 10]
         lengths = [4, 6]
@@ -239,10 +247,12 @@ class TestIntIndex(TestCase):
     def test_make_union(self):
         pass
 
+from pandas.core.sparse import SparseSeries
+from pandas import DataFrame
 
 class TestSparseOperators(TestCase):
 
-    def _arith_op_tests(self, sparse_op, python_op):
+    def _nan_op_tests(self, sparse_op, python_op):
         def _check_case(xloc, xlen, yloc, ylen, eloc, elen):
             xindex = BlockIndex(TEST_LENGTH, xloc, xlen)
             yindex = BlockIndex(TEST_LENGTH, yloc, ylen)
@@ -264,6 +274,43 @@ class TestSparseOperators(TestCase):
             yseries = Series(y, ydindex.indices)
             series_result = python_op(xseries, yseries).valid()
             assert_equal(result_block_vals, series_result.values)
+            assert_equal(result_int_vals, series_result.values)
+
+        check_cases(_check_case)
+
+    def _op_tests(self, sparse_op, python_op):
+        def _check_case(xloc, xlen, yloc, ylen, eloc, elen):
+            xindex = BlockIndex(TEST_LENGTH, xloc, xlen)
+            yindex = BlockIndex(TEST_LENGTH, yloc, ylen)
+
+            xdindex = xindex.to_int_index()
+            ydindex = yindex.to_int_index()
+
+            x = np.arange(xindex.npoints) * 10. + 1
+            y = np.arange(yindex.npoints) * 100. + 1
+
+            xfill = 0
+            yfill = 2
+
+            result_block_vals, rb_index = sparse_op(x, xindex, xfill, y, yindex, yfill)
+            result_int_vals, ri_index = sparse_op(x, xdindex, xfill,
+                                                  y, ydindex, yfill)
+
+            self.assert_(rb_index.to_int_index().equals(ri_index))
+            assert_equal(result_block_vals, result_int_vals)
+
+            # check versus Series...
+            xseries = Series(x, xdindex.indices)
+            xseries = xseries.reindex(np.arange(TEST_LENGTH)).fillna(xfill)
+
+            yseries = Series(y, ydindex.indices)
+            yseries = yseries.reindex(np.arange(TEST_LENGTH)).fillna(yfill)
+
+            series_result = python_op(xseries, yseries)
+            series_result = series_result.reindex(ri_index.indices)
+
+            assert_equal(result_block_vals, series_result.values)
+            assert_equal(result_int_vals, series_result.values)
 
         check_cases(_check_case)
 
@@ -274,14 +321,25 @@ def make_nanoptestf(op):
     def f(self):
         sparse_op = getattr(sparselib, 'sparse_nan%s' % op)
         python_op = getattr(operator, op)
-        self._arith_op_tests(sparse_op, python_op)
+        self._nan_op_tests(sparse_op, python_op)
     f.__name__ = 'test_nan%s' % op
     return f
 
+def make_optestf(op):
+    def f(self):
+        sparse_op = getattr(sparselib, 'sparse_%s' % op)
+        python_op = getattr(operator, op)
+        self._op_tests(sparse_op, python_op)
+    f.__name__ = 'test_%s' % op
+    return f
+
 for op in check_ops:
     f = make_nanoptestf(op)
+    g = make_optestf(op)
     setattr(TestSparseOperators, f.__name__, f)
+    setattr(TestSparseOperators, g.__name__, g)
     del f
+    del g
 
 if __name__ == '__main__':
     import nose

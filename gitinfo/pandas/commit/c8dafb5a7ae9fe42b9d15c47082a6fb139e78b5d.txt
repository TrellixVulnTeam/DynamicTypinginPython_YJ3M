commit c8dafb5a7ae9fe42b9d15c47082a6fb139e78b5d
Author: Jeff Reback <jeff@reback.net>
Date:   Tue Apr 18 12:17:07 2017 +0000

    CLN: reorg pandas.tseries (#16040)
    
    * CLN: move pandas/tseries/resample.py -> pandas/core/resample.py
    
    closes #13634
    
    * CLN: move pandas.tseries.period -> pandas.core.indexes.period
    
    * CLN: move pandas.tseries.tdi -> pandas.core.indexes.timedeltas
    
    * CLN: move pandas.tseries.base -> pandas.core.indexes.datetimelike
    
    * CLN: pandas.tseries.common -> pandas.core.indexes.accessors
    
    * CLN: move pandas.tseries.index -> pandas.core.indexes.datetimes
    
    * CLN: move pandas.tseries.timedeltas, pandas.tseries.tools -> pandas.core.tools
    
    * move to_numeric to pandas.core.tools.numeric

diff --git a/doc/source/api.rst b/doc/source/api.rst
index 868f0d7f9..caa5498db 100644
--- a/doc/source/api.rst
+++ b/doc/source/api.rst
@@ -1761,7 +1761,7 @@ The following methods are available only for ``DataFrameGroupBy`` objects.
 
 Resampling
 ----------
-.. currentmodule:: pandas.tseries.resample
+.. currentmodule:: pandas.core.resample
 
 Resampler objects are returned by resample calls: :func:`pandas.DataFrame.resample`, :func:`pandas.Series.resample`.
 
diff --git a/pandas/_libs/period.pyx b/pandas/_libs/period.pyx
index f30035910..1db31387d 100644
--- a/pandas/_libs/period.pyx
+++ b/pandas/_libs/period.pyx
@@ -34,7 +34,7 @@ from tslib cimport (
 )
 
 from pandas.tseries import offsets
-from pandas.tseries.tools import parse_time_string
+from pandas.core.tools.datetimes import parse_time_string
 from pandas.tseries import frequencies
 
 cdef int64_t NPY_NAT = util.get_nat()
diff --git a/pandas/_libs/tslib.pyx b/pandas/_libs/tslib.pyx
index 47679966e..c471d4626 100644
--- a/pandas/_libs/tslib.pyx
+++ b/pandas/_libs/tslib.pyx
@@ -502,7 +502,7 @@ class Timestamp(_Timestamp):
         """
         Return an period of which this timestamp is an observation.
         """
-        from pandas.tseries.period import Period
+        from pandas import Period
 
         if freq is None:
             freq = self.freq
diff --git a/pandas/compat/pickle_compat.py b/pandas/compat/pickle_compat.py
index f7d451ce7..6df365a1c 100644
--- a/pandas/compat/pickle_compat.py
+++ b/pandas/compat/pickle_compat.py
@@ -94,7 +94,13 @@ _class_locations_map = {
     ('pandas.indexes.range', 'RangeIndex'):
         ('pandas.core.indexes.range', 'RangeIndex'),
     ('pandas.indexes.multi', 'MultiIndex'):
-        ('pandas.core.indexes.multi', 'MultiIndex')
+        ('pandas.core.indexes.multi', 'MultiIndex'),
+    ('pandas.tseries.index', '_new_DatetimeIndex'):
+        ('pandas.core.indexes.datetimes', '_new_DatetimeIndex'),
+    ('pandas.tseries.index', 'DatetimeIndex'):
+        ('pandas.core.indexes.datetimes', 'DatetimeIndex'),
+    ('pandas.tseries.period', 'PeriodIndex'):
+        ('pandas.core.indexes.period', 'PeriodIndex')
 }
 
 
diff --git a/pandas/core/api.py b/pandas/core/api.py
index f3191283b..3e84720c3 100644
--- a/pandas/core/api.py
+++ b/pandas/core/api.py
@@ -11,7 +11,12 @@ from pandas.core.groupby import Grouper
 from pandas.io.formats.format import set_eng_float_format
 from pandas.core.index import (Index, CategoricalIndex, Int64Index,
                                UInt64Index, RangeIndex, Float64Index,
-                               MultiIndex, IntervalIndex)
+                               MultiIndex, IntervalIndex,
+                               TimedeltaIndex, DatetimeIndex,
+                               PeriodIndex, NaT)
+from pandas.core.indexes.period import Period, period_range, pnow
+from pandas.core.indexes.timedeltas import Timedelta, timedelta_range
+from pandas.core.indexes.datetimes import Timestamp, date_range, bdate_range
 from pandas.core.indexes.interval import Interval, interval_range
 
 from pandas.core.series import Series
@@ -23,13 +28,11 @@ from pandas.core.reshape.reshape import (
     lreshape, wide_to_long)
 
 from pandas.core.indexing import IndexSlice
-from pandas.core.dtypes.cast import to_numeric
+from pandas.core.tools.numeric import to_numeric
 from pandas.tseries.offsets import DateOffset
-from pandas.tseries.tools import to_datetime
-from pandas.tseries.index import (DatetimeIndex, Timestamp,
-                                  date_range, bdate_range)
-from pandas.tseries.tdi import TimedeltaIndex, Timedelta
-from pandas.tseries.period import Period, PeriodIndex
+from pandas.core.tools.datetimes import to_datetime
+from pandas.core.tools.timedeltas import to_timedelta
+from pandas.core.resample import TimeGrouper
 
 # see gh-14094.
 from pandas.util.depr_module import _DeprecatedModule
diff --git a/pandas/core/computation/pytables.py b/pandas/core/computation/pytables.py
index 285ff3461..587009085 100644
--- a/pandas/core/computation/pytables.py
+++ b/pandas/core/computation/pytables.py
@@ -14,7 +14,7 @@ from pandas.core.computation import expr, ops
 from pandas.core.computation.ops import is_term, UndefinedVariableError
 from pandas.core.computation.expr import BaseExprVisitor
 from pandas.core.computation.common import _ensure_decoded
-from pandas.tseries.timedeltas import _coerce_scalar_to_timedelta_type
+from pandas.core.tools.timedeltas import _coerce_scalar_to_timedelta_type
 
 
 class Scope(expr.Scope):
diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index bfc3f3d4e..3444d09c6 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -4,7 +4,7 @@
 
 import warnings
 
-from pandas.tseries.tools import *
+from pandas.core.tools.datetimes import *
 from pandas.tseries.offsets import *
 from pandas.tseries.frequencies import *
 
diff --git a/pandas/core/dtypes/cast.py b/pandas/core/dtypes/cast.py
index 3c1f48078..a5e12e826 100644
--- a/pandas/core/dtypes/cast.py
+++ b/pandas/core/dtypes/cast.py
@@ -5,7 +5,6 @@ from datetime import datetime, timedelta
 import numpy as np
 import warnings
 
-import pandas as pd
 from pandas._libs import tslib, lib
 from pandas._libs.tslib import iNaT
 from pandas.compat import string_types, text_type, PY3
@@ -19,8 +18,6 @@ from .common import (_ensure_object, is_bool, is_integer, is_float,
                      is_integer_dtype,
                      is_datetime_or_timedelta_dtype,
                      is_bool_dtype, is_scalar,
-                     is_numeric_dtype, is_decimal,
-                     is_number,
                      _string_dtypes,
                      _coerce_to_dtype,
                      _ensure_int8, _ensure_int16,
@@ -29,7 +26,7 @@ from .common import (_ensure_object, is_bool, is_integer, is_float,
                      _POSSIBLY_CAST_DTYPES)
 from .dtypes import ExtensionDtype, DatetimeTZDtype, PeriodDtype
 from .generic import (ABCDatetimeIndex, ABCPeriodIndex,
-                      ABCSeries, ABCIndexClass)
+                      ABCSeries)
 from .missing import isnull, notnull
 from .inference import is_list_like
 
@@ -548,7 +545,7 @@ def coerce_to_dtypes(result, dtypes):
     if len(result) != len(dtypes):
         raise AssertionError("_coerce_to_dtypes requires equal len arrays")
 
-    from pandas.tseries.timedeltas import _coerce_scalar_to_timedelta_type
+    from pandas.core.tools.timedeltas import _coerce_scalar_to_timedelta_type
 
     def conv(r, dtype):
         try:
@@ -670,7 +667,7 @@ def maybe_convert_objects(values, convert_dates=True, convert_numeric=True,
     if convert_timedeltas and values.dtype == np.object_:
 
         if convert_timedeltas == 'coerce':
-            from pandas.tseries.timedeltas import to_timedelta
+            from pandas.core.tools.timedeltas import to_timedelta
             new_values = to_timedelta(values, coerce=True)
 
             # if we are all nans then leave me alone
@@ -872,8 +869,8 @@ def maybe_cast_to_datetime(value, dtype, errors='raise'):
     """ try to cast the array/value to a datetimelike dtype, converting float
     nan to iNaT
     """
-    from pandas.tseries.timedeltas import to_timedelta
-    from pandas.tseries.tools import to_datetime
+    from pandas.core.tools.timedeltas import to_timedelta
+    from pandas.core.tools.datetimes import to_datetime
 
     if dtype is not None:
         if isinstance(dtype, string_types):
@@ -1029,161 +1026,3 @@ def find_common_type(types):
             return np.object
 
     return np.find_common_type(types, [])
-
-
-def to_numeric(arg, errors='raise', downcast=None):
-    """
-    Convert argument to a numeric type.
-
-    Parameters
-    ----------
-    arg : list, tuple, 1-d array, or Series
-    errors : {'ignore', 'raise', 'coerce'}, default 'raise'
-        - If 'raise', then invalid parsing will raise an exception
-        - If 'coerce', then invalid parsing will be set as NaN
-        - If 'ignore', then invalid parsing will return the input
-    downcast : {'integer', 'signed', 'unsigned', 'float'} , default None
-        If not None, and if the data has been successfully cast to a
-        numerical dtype (or if the data was numeric to begin with),
-        downcast that resulting data to the smallest numerical dtype
-        possible according to the following rules:
-
-        - 'integer' or 'signed': smallest signed int dtype (min.: np.int8)
-        - 'unsigned': smallest unsigned int dtype (min.: np.uint8)
-        - 'float': smallest float dtype (min.: np.float32)
-
-        As this behaviour is separate from the core conversion to
-        numeric values, any errors raised during the downcasting
-        will be surfaced regardless of the value of the 'errors' input.
-
-        In addition, downcasting will only occur if the size
-        of the resulting data's dtype is strictly larger than
-        the dtype it is to be cast to, so if none of the dtypes
-        checked satisfy that specification, no downcasting will be
-        performed on the data.
-
-        .. versionadded:: 0.19.0
-
-    Returns
-    -------
-    ret : numeric if parsing succeeded.
-        Return type depends on input.  Series if Series, otherwise ndarray
-
-    Examples
-    --------
-    Take separate series and convert to numeric, coercing when told to
-
-    >>> import pandas as pd
-    >>> s = pd.Series(['1.0', '2', -3])
-    >>> pd.to_numeric(s)
-    0    1.0
-    1    2.0
-    2   -3.0
-    dtype: float64
-    >>> pd.to_numeric(s, downcast='float')
-    0    1.0
-    1    2.0
-    2   -3.0
-    dtype: float32
-    >>> pd.to_numeric(s, downcast='signed')
-    0    1
-    1    2
-    2   -3
-    dtype: int8
-    >>> s = pd.Series(['apple', '1.0', '2', -3])
-    >>> pd.to_numeric(s, errors='ignore')
-    0    apple
-    1      1.0
-    2        2
-    3       -3
-    dtype: object
-    >>> pd.to_numeric(s, errors='coerce')
-    0    NaN
-    1    1.0
-    2    2.0
-    3   -3.0
-    dtype: float64
-    """
-    if downcast not in (None, 'integer', 'signed', 'unsigned', 'float'):
-        raise ValueError('invalid downcasting method provided')
-
-    is_series = False
-    is_index = False
-    is_scalars = False
-
-    if isinstance(arg, ABCSeries):
-        is_series = True
-        values = arg.values
-    elif isinstance(arg, ABCIndexClass):
-        is_index = True
-        values = arg.asi8
-        if values is None:
-            values = arg.values
-    elif isinstance(arg, (list, tuple)):
-        values = np.array(arg, dtype='O')
-    elif is_scalar(arg):
-        if is_decimal(arg):
-            return float(arg)
-        if is_number(arg):
-            return arg
-        is_scalars = True
-        values = np.array([arg], dtype='O')
-    elif getattr(arg, 'ndim', 1) > 1:
-        raise TypeError('arg must be a list, tuple, 1-d array, or Series')
-    else:
-        values = arg
-
-    try:
-        if is_numeric_dtype(values):
-            pass
-        elif is_datetime_or_timedelta_dtype(values):
-            values = values.astype(np.int64)
-        else:
-            values = _ensure_object(values)
-            coerce_numeric = False if errors in ('ignore', 'raise') else True
-            values = lib.maybe_convert_numeric(values, set(),
-                                               coerce_numeric=coerce_numeric)
-
-    except Exception:
-        if errors == 'raise':
-            raise
-
-    # attempt downcast only if the data has been successfully converted
-    # to a numerical dtype and if a downcast method has been specified
-    if downcast is not None and is_numeric_dtype(values):
-        typecodes = None
-
-        if downcast in ('integer', 'signed'):
-            typecodes = np.typecodes['Integer']
-        elif downcast == 'unsigned' and np.min(values) >= 0:
-            typecodes = np.typecodes['UnsignedInteger']
-        elif downcast == 'float':
-            typecodes = np.typecodes['Float']
-
-            # pandas support goes only to np.float32,
-            # as float dtypes smaller than that are
-            # extremely rare and not well supported
-            float_32_char = np.dtype(np.float32).char
-            float_32_ind = typecodes.index(float_32_char)
-            typecodes = typecodes[float_32_ind:]
-
-        if typecodes is not None:
-            # from smallest to largest
-            for dtype in typecodes:
-                if np.dtype(dtype).itemsize <= values.dtype.itemsize:
-                    values = maybe_downcast_to_dtype(values, dtype)
-
-                    # successful conversion
-                    if values.dtype == dtype:
-                        break
-
-    if is_series:
-        return pd.Series(values, index=arg.index, name=arg.name)
-    elif is_index:
-        # because we want to coerce to numeric if possible,
-        # do not use _shallow_copy_with_infer
-        return pd.Index(values, name=arg.name)
-    elif is_scalars:
-        return values[0]
-    else:
-        return values
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 9b9039455..153042d4a 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -82,9 +82,9 @@ from pandas.compat.numpy import function as nv
 from pandas.util.decorators import Appender, Substitution
 from pandas.util.validators import validate_bool_kwarg
 
-from pandas.tseries.period import PeriodIndex
-from pandas.tseries.index import DatetimeIndex
-from pandas.tseries.tdi import TimedeltaIndex
+from pandas.core.indexes.period import PeriodIndex
+from pandas.core.indexes.datetimes import DatetimeIndex
+from pandas.core.indexes.timedeltas import TimedeltaIndex
 
 import pandas.core.base as base
 import pandas.core.common as com
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 841df3727..155515761 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -37,8 +37,8 @@ from pandas.core.base import PandasObject, SelectionMixin
 from pandas.core.index import (Index, MultiIndex, _ensure_index,
                                InvalidIndexError)
 import pandas.core.indexing as indexing
-from pandas.tseries.index import DatetimeIndex
-from pandas.tseries.period import PeriodIndex, Period
+from pandas.core.indexes.datetimes import DatetimeIndex
+from pandas.core.indexes.period import PeriodIndex, Period
 from pandas.core.internals import BlockManager
 import pandas.core.algorithms as algos
 import pandas.core.common as com
@@ -4363,7 +4363,7 @@ class NDFrame(PandasObject, SelectionMixin):
         To learn more about the frequency strings, please see `this link
         <http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases>`__.
         """
-        from pandas.tseries.resample import asfreq
+        from pandas.core.resample import asfreq
         return asfreq(self, freq, method=method, how=how, normalize=normalize,
                       fill_value=fill_value)
 
@@ -4573,8 +4573,8 @@ class NDFrame(PandasObject, SelectionMixin):
         2000-01-01 00:00:00  0  6  12  18
         2000-01-01 00:03:00  0  4   8  12
         """
-        from pandas.tseries.resample import (resample,
-                                             _maybe_process_deprecations)
+        from pandas.core.resample import (resample,
+                                          _maybe_process_deprecations)
         axis = self._get_axis_number(axis)
         r = resample(self, freq=rule, label=label, closed=closed,
                      axis=axis, kind=kind, loffset=loffset,
@@ -5361,7 +5361,7 @@ class NDFrame(PandasObject, SelectionMixin):
         # if we have a date index, convert to dates, otherwise
         # treat like a slice
         if ax.is_all_dates:
-            from pandas.tseries.tools import to_datetime
+            from pandas.core.tools.datetimes import to_datetime
             before = to_datetime(before)
             after = to_datetime(after)
 
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 8f788aed3..1f715c685 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -232,7 +232,7 @@ class Grouper(object):
 
     def __new__(cls, *args, **kwargs):
         if kwargs.get('freq') is not None:
-            from pandas.tseries.resample import TimeGrouper
+            from pandas.core.resample import TimeGrouper
             cls = TimeGrouper
         return super(Grouper, cls).__new__(cls)
 
@@ -1227,7 +1227,7 @@ class GroupBy(_GroupBy):
         Provide resampling when using a TimeGrouper
         Return a new grouper with our resampler appended
         """
-        from pandas.tseries.resample import get_resampler_for_grouping
+        from pandas.core.resample import get_resampler_for_grouping
         return get_resampler_for_grouping(self, rule, *args, **kwargs)
 
     @Substitution(name='groupby')
@@ -3509,7 +3509,7 @@ class NDFrameGroupBy(GroupBy):
 
     def _wrap_applied_output(self, keys, values, not_indexed_same=False):
         from pandas.core.index import _all_indexes_same
-        from pandas.core.dtypes.cast import to_numeric
+        from pandas.core.tools.numeric import to_numeric
 
         if len(keys) == 0:
             return DataFrame(index=keys)
diff --git a/pandas/tseries/common.py b/pandas/core/indexes/accessors.py
similarity index 97%
rename from pandas/tseries/common.py
rename to pandas/core/indexes/accessors.py
index 2154cfd4b..f1fb9a8ad 100644
--- a/pandas/tseries/common.py
+++ b/pandas/core/indexes/accessors.py
@@ -12,10 +12,10 @@ from pandas.core.dtypes.common import (
     is_list_like)
 
 from pandas.core.base import PandasDelegate, NoNewAttributesMixin
-from pandas.tseries.index import DatetimeIndex
+from pandas.core.indexes.datetimes import DatetimeIndex
 from pandas._libs.period import IncompatibleFrequency  # noqa
-from pandas.tseries.period import PeriodIndex
-from pandas.tseries.tdi import TimedeltaIndex
+from pandas.core.indexes.period import PeriodIndex
+from pandas.core.indexes.timedeltas import TimedeltaIndex
 from pandas.core.algorithms import take_1d
 
 
diff --git a/pandas/core/indexes/api.py b/pandas/core/indexes/api.py
index d40f6da4c..d90c681ab 100644
--- a/pandas/core/indexes/api.py
+++ b/pandas/core/indexes/api.py
@@ -7,16 +7,21 @@ from pandas.core.indexes.interval import IntervalIndex  # noqa
 from pandas.core.indexes.numeric import (NumericIndex, Float64Index,  # noqa
                                     Int64Index, UInt64Index)
 from pandas.core.indexes.range import RangeIndex  # noqa
+from pandas.core.indexes.timedeltas import TimedeltaIndex
+from pandas.core.indexes.period import PeriodIndex
+from pandas.core.indexes.datetimes import DatetimeIndex
 
 import pandas.core.common as com
-import pandas._libs.lib as lib
+from pandas._libs import lib
+from pandas._libs.tslib import NaT
 
 # TODO: there are many places that rely on these private methods existing in
 # pandas.core.index
 __all__ = ['Index', 'MultiIndex', 'NumericIndex', 'Float64Index', 'Int64Index',
            'CategoricalIndex', 'IntervalIndex', 'RangeIndex', 'UInt64Index',
-           'InvalidIndexError',
-           '_new_Index',
+           'InvalidIndexError', 'TimedeltaIndex',
+           'PeriodIndex', 'DatetimeIndex',
+           '_new_Index', 'NaT',
            '_ensure_index', '_get_na_value', '_get_combined_index',
            '_get_distinct_indexes', '_union_indexes',
            '_get_consensus_names',
diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index 705b7a186..dcb9f9a14 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -91,7 +91,7 @@ def _new_Index(cls, d):
     # required for backward compat, because PI can't be instantiated with
     # ordinals through __new__ GH #13277
     if issubclass(cls, ABCPeriodIndex):
-        from pandas.tseries.period import _new_PeriodIndex
+        from pandas.core.indexes.period import _new_PeriodIndex
         return _new_PeriodIndex(cls, **d)
     return cls.__new__(cls, **d)
 
@@ -184,7 +184,7 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
             if (is_datetime64_any_dtype(data) or
                 (dtype is not None and is_datetime64_any_dtype(dtype)) or
                     'tz' in kwargs):
-                from pandas.tseries.index import DatetimeIndex
+                from pandas.core.indexes.datetimes import DatetimeIndex
                 result = DatetimeIndex(data, copy=copy, name=name,
                                        dtype=dtype, **kwargs)
                 if dtype is not None and is_dtype_equal(_o_dtype, dtype):
@@ -194,7 +194,7 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
 
             elif (is_timedelta64_dtype(data) or
                   (dtype is not None and is_timedelta64_dtype(dtype))):
-                from pandas.tseries.tdi import TimedeltaIndex
+                from pandas.core.indexes.timedeltas import TimedeltaIndex
                 result = TimedeltaIndex(data, copy=copy, name=name, **kwargs)
                 if dtype is not None and _o_dtype == dtype:
                     return Index(result.to_pytimedelta(), dtype=_o_dtype)
@@ -250,8 +250,8 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
                         raise
 
             # maybe coerce to a sub-class
-            from pandas.tseries.period import (PeriodIndex,
-                                               IncompatibleFrequency)
+            from pandas.core.indexes.period import (
+                PeriodIndex, IncompatibleFrequency)
             if isinstance(data, PeriodIndex):
                 return PeriodIndex(data, copy=copy, name=name, **kwargs)
             if is_signed_integer_dtype(data.dtype):
@@ -299,7 +299,8 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
                         if (lib.is_datetime_with_singletz_array(subarr) or
                                 'tz' in kwargs):
                             # only when subarr has the same tz
-                            from pandas.tseries.index import DatetimeIndex
+                            from pandas.core.indexes.datetimes import (
+                                DatetimeIndex)
                             try:
                                 return DatetimeIndex(subarr, copy=copy,
                                                      name=name, **kwargs)
@@ -307,7 +308,8 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
                                 pass
 
                     elif inferred.startswith('timedelta'):
-                        from pandas.tseries.tdi import TimedeltaIndex
+                        from pandas.core.indexes.timedeltas import (
+                            TimedeltaIndex)
                         return TimedeltaIndex(subarr, copy=copy, name=name,
                                               **kwargs)
                     elif inferred == 'period':
@@ -1009,7 +1011,7 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
         warnings.warn("to_datetime is deprecated. Use pd.to_datetime(...)",
                       FutureWarning, stacklevel=2)
 
-        from pandas.tseries.index import DatetimeIndex
+        from pandas.core.indexes.datetimes import DatetimeIndex
         if self.inferred_type == 'string':
             from dateutil.parser import parse
             parser = lambda x: parse(x, dayfirst=dayfirst)
@@ -2664,7 +2666,7 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
 
     def _maybe_promote(self, other):
         # A hack, but it works
-        from pandas.tseries.index import DatetimeIndex
+        from pandas.core.indexes.datetimes import DatetimeIndex
         if self.inferred_type == 'date' and isinstance(other, DatetimeIndex):
             return DatetimeIndex(self), other
         elif self.inferred_type == 'boolean':
diff --git a/pandas/tseries/base.py b/pandas/core/indexes/datetimelike.py
similarity index 99%
rename from pandas/tseries/base.py
rename to pandas/core/indexes/datetimelike.py
index 3daa88fe3..387209ceb 100644
--- a/pandas/tseries/base.py
+++ b/pandas/core/indexes/datetimelike.py
@@ -27,8 +27,7 @@ from pandas._libs import (tslib as libts, lib,
                           Timedelta, Timestamp, iNaT, NaT)
 from pandas._libs.period import Period
 
-from pandas.core.index import Index
-from pandas.core.indexes.base import _index_shared_docs
+from pandas.core.indexes.base import Index, _index_shared_docs
 from pandas.util.decorators import Appender, cache_readonly
 import pandas.core.dtypes.concat as _concat
 import pandas.tseries.frequencies as frequencies
@@ -639,7 +638,7 @@ class DatetimeIndexOpsMixin(object):
 
         def __add__(self, other):
             from pandas.core.index import Index
-            from pandas.tseries.tdi import TimedeltaIndex
+            from pandas.core.indexes.timedeltas import TimedeltaIndex
             from pandas.tseries.offsets import DateOffset
             if isinstance(other, TimedeltaIndex):
                 return self._add_delta(other)
@@ -666,8 +665,8 @@ class DatetimeIndexOpsMixin(object):
 
         def __sub__(self, other):
             from pandas.core.index import Index
-            from pandas.tseries.index import DatetimeIndex
-            from pandas.tseries.tdi import TimedeltaIndex
+            from pandas.core.indexes.datetimes import DatetimeIndex
+            from pandas.core.indexes.timedeltas import TimedeltaIndex
             from pandas.tseries.offsets import DateOffset
             if isinstance(other, TimedeltaIndex):
                 return self._add_delta(-other)
diff --git a/pandas/tseries/index.py b/pandas/core/indexes/datetimes.py
similarity index 99%
rename from pandas/tseries/index.py
rename to pandas/core/indexes/datetimes.py
index d9aa72fe0..b92368ec1 100644
--- a/pandas/tseries/index.py
+++ b/pandas/core/indexes/datetimes.py
@@ -29,21 +29,23 @@ import pandas.core.dtypes.concat as _concat
 from pandas.errors import PerformanceWarning
 from pandas.core.common import _values_from_object, _maybe_box
 
-from pandas.core.index import Index, Int64Index, Float64Index
-from pandas.core.indexes.base import _index_shared_docs
+from pandas.core.indexes.base import Index, _index_shared_docs
+from pandas.core.indexes.numeric import Int64Index, Float64Index
 import pandas.compat as compat
 from pandas.tseries.frequencies import (
     to_offset, get_period_alias,
     Resolution)
-from pandas.tseries.base import DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin
+from pandas.core.indexes.datetimelike import (
+    DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin)
 from pandas.tseries.offsets import DateOffset, generate_range, Tick, CDay
-from pandas.tseries.tools import parse_time_string, normalize_date, to_time
-from pandas.tseries.timedeltas import to_timedelta
+from pandas.core.tools.datetimes import (
+    parse_time_string, normalize_date, to_time)
+from pandas.core.tools.timedeltas import to_timedelta
 from pandas.util.decorators import (Appender, cache_readonly,
                                     deprecate_kwarg, Substitution)
 import pandas.core.common as com
 import pandas.tseries.offsets as offsets
-import pandas.tseries.tools as tools
+import pandas.core.tools.datetimes as tools
 
 from pandas._libs import (lib, index as libindex, tslib as libts,
                           algos as libalgos, join as libjoin,
@@ -927,7 +929,7 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
         """
         Cast to PeriodIndex at a particular frequency
         """
-        from pandas.tseries.period import PeriodIndex
+        from pandas.core.indexes.period import PeriodIndex
 
         if freq is None:
             freq = self.freqstr or self.inferred_freq
diff --git a/pandas/tseries/period.py b/pandas/core/indexes/period.py
similarity index 98%
rename from pandas/tseries/period.py
rename to pandas/core/indexes/period.py
index b19e086b8..378661a49 100644
--- a/pandas/tseries/period.py
+++ b/pandas/core/indexes/period.py
@@ -24,10 +24,10 @@ from pandas.core.dtypes.generic import ABCSeries
 
 import pandas.tseries.frequencies as frequencies
 from pandas.tseries.frequencies import get_freq_code as _gfc
-from pandas.tseries.index import DatetimeIndex, Int64Index, Index
-from pandas.tseries.tdi import TimedeltaIndex
-from pandas.tseries.base import DatelikeOps, DatetimeIndexOpsMixin
-from pandas.tseries.tools import parse_time_string
+from pandas.core.indexes.datetimes import DatetimeIndex, Int64Index, Index
+from pandas.core.indexes.timedeltas import TimedeltaIndex
+from pandas.core.indexes.datetimelike import DatelikeOps, DatetimeIndexOpsMixin
+from pandas.core.tools.datetimes import parse_time_string
 import pandas.tseries.offsets as offsets
 
 from pandas._libs.lib import infer_dtype
@@ -528,17 +528,17 @@ class PeriodIndex(DatelikeOps, DatetimeIndexOpsMixin, Int64Index):
         --------
         >>> pidx = pd.period_range('2010-01-01', '2015-01-01', freq='A')
         >>> pidx
-        <class 'pandas.tseries.period.PeriodIndex'>
+        <class 'pandas.core.indexes.period.PeriodIndex'>
         [2010, ..., 2015]
         Length: 6, Freq: A-DEC
 
         >>> pidx.asfreq('M')
-        <class 'pandas.tseries.period.PeriodIndex'>
+        <class 'pandas.core.indexes.period.PeriodIndex'>
         [2010-12, ..., 2015-12]
         Length: 6, Freq: M
 
         >>> pidx.asfreq('M', how='S')
-        <class 'pandas.tseries.period.PeriodIndex'>
+        <class 'pandas.core.indexes.period.PeriodIndex'>
         [2010-01, ..., 2015-01]
         Length: 6, Freq: M
         """
@@ -1154,7 +1154,7 @@ def pnow(freq=None):
     # deprecation, xref #13790
     import warnings
 
-    warnings.warn("pd.pnow() and pandas.tseries.period.pnow() "
+    warnings.warn("pd.pnow() and pandas.core.indexes.period.pnow() "
                   "are deprecated. Please use Period.now()",
                   FutureWarning, stacklevel=2)
     return Period.now(freq=freq)
diff --git a/pandas/tseries/tdi.py b/pandas/core/indexes/timedeltas.py
similarity index 99%
rename from pandas/tseries/tdi.py
rename to pandas/core/indexes/timedeltas.py
index 7768b4a34..1081787b2 100644
--- a/pandas/tseries/tdi.py
+++ b/pandas/core/indexes/timedeltas.py
@@ -17,7 +17,8 @@ from pandas.core.dtypes.missing import isnull
 from pandas.core.dtypes.generic import ABCSeries
 from pandas.core.common import _maybe_box, _values_from_object, is_bool_indexer
 
-from pandas.core.index import Index, Int64Index
+from pandas.core.indexes.base import Index
+from pandas.core.indexes.numeric import Int64Index
 import pandas.compat as compat
 from pandas.compat import u
 from pandas.tseries.frequencies import to_offset
@@ -27,9 +28,9 @@ from pandas.core.indexes.base import _index_shared_docs
 import pandas.core.common as com
 import pandas.core.dtypes.concat as _concat
 from pandas.util.decorators import Appender, Substitution, deprecate_kwarg
-from pandas.tseries.base import TimelikeOps, DatetimeIndexOpsMixin
-from pandas.tseries.timedeltas import (to_timedelta,
-                                       _coerce_scalar_to_timedelta_type)
+from pandas.core.indexes.datetimelike import TimelikeOps, DatetimeIndexOpsMixin
+from pandas.core.tools.timedeltas import (
+    to_timedelta, _coerce_scalar_to_timedelta_type)
 from pandas.tseries.offsets import Tick, DateOffset
 from pandas._libs import (lib, index as libindex, tslib as libts,
                           join as libjoin, Timedelta, NaT, iNaT)
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 5a8757445..f265f5f43 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -54,7 +54,7 @@ import pandas.core.algorithms as algos
 from pandas.core.index import Index, MultiIndex, _ensure_index
 from pandas.core.indexing import maybe_convert_indices, length_of_indexer
 from pandas.core.categorical import Categorical, maybe_to_categorical
-from pandas.tseries.index import DatetimeIndex
+from pandas.core.indexes.datetimes import DatetimeIndex
 from pandas.io.formats.printing import pprint_thing
 
 import pandas.core.missing as missing
diff --git a/pandas/core/ops.py b/pandas/core/ops.py
index 50815498f..41a17a095 100644
--- a/pandas/core/ops.py
+++ b/pandas/core/ops.py
@@ -442,7 +442,7 @@ class _TimeOp(_Op):
 
     def _convert_to_array(self, values, name=None, other=None):
         """converts values to ndarray"""
-        from pandas.tseries.timedeltas import to_timedelta
+        from pandas.core.tools.timedeltas import to_timedelta
 
         ovalues = values
         supplied_dtype = None
@@ -508,7 +508,7 @@ class _TimeOp(_Op):
         return values
 
     def _convert_for_datetime(self, lvalues, rvalues):
-        from pandas.tseries.timedeltas import to_timedelta
+        from pandas.core.tools.timedeltas import to_timedelta
 
         mask = isnull(lvalues) | isnull(rvalues)
 
diff --git a/pandas/tseries/resample.py b/pandas/core/resample.py
old mode 100755
new mode 100644
similarity index 99%
rename from pandas/tseries/resample.py
rename to pandas/core/resample.py
index 2856b54ad..203ae0cb1
--- a/pandas/tseries/resample.py
+++ b/pandas/core/resample.py
@@ -10,10 +10,10 @@ from pandas.core.groupby import (BinGrouper, Grouper, _GroupBy, GroupBy,
                                  SeriesGroupBy, groupby, PanelGroupBy)
 
 from pandas.tseries.frequencies import to_offset, is_subperiod, is_superperiod
-from pandas.tseries.index import DatetimeIndex, date_range
-from pandas.tseries.tdi import TimedeltaIndex
+from pandas.core.indexes.datetimes import DatetimeIndex, date_range
+from pandas.core.indexes.timedeltas import TimedeltaIndex
 from pandas.tseries.offsets import DateOffset, Tick, Day, _delta_to_nanoseconds
-from pandas.tseries.period import PeriodIndex, period_range
+from pandas.core.indexes.period import PeriodIndex, period_range
 import pandas.core.common as com
 import pandas.core.algorithms as algos
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 69a2b35d8..8a2351527 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -52,11 +52,11 @@ from pandas.core import generic, base
 from pandas.core.internals import SingleBlockManager
 from pandas.core.categorical import Categorical, CategoricalAccessor
 import pandas.core.strings as strings
-from pandas.tseries.common import (maybe_to_datetimelike,
-                                   CombinedDatetimelikeProperties)
-from pandas.tseries.index import DatetimeIndex
-from pandas.tseries.tdi import TimedeltaIndex
-from pandas.tseries.period import PeriodIndex
+from pandas.core.indexes.accessors import (
+    maybe_to_datetimelike, CombinedDatetimelikeProperties)
+from pandas.core.indexes.datetimes import DatetimeIndex
+from pandas.core.indexes.timedeltas import TimedeltaIndex
+from pandas.core.indexes.period import PeriodIndex
 from pandas import compat
 from pandas.util.terminal import get_terminal_size
 from pandas.compat import zip, u, OrderedDict, StringIO
diff --git a/pandas/core/tools/__init__.py b/pandas/core/tools/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/tseries/tools.py b/pandas/core/tools/datetimes.py
similarity index 99%
rename from pandas/tseries/tools.py
rename to pandas/core/tools/datetimes.py
index db7aa5974..9c02a6212 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/core/tools/datetimes.py
@@ -336,7 +336,7 @@ def to_datetime(arg, errors='raise', dayfirst=False, yearfirst=False,
     2    1960-01-04
 
     """
-    from pandas.tseries.index import DatetimeIndex
+    from pandas.core.indexes.datetimes import DatetimeIndex
 
     tz = 'utc' if utc else None
 
diff --git a/pandas/core/tools/numeric.py b/pandas/core/tools/numeric.py
new file mode 100644
index 000000000..eda88a2f7
--- /dev/null
+++ b/pandas/core/tools/numeric.py
@@ -0,0 +1,170 @@
+import numpy as np
+import pandas as pd
+from pandas.core.dtypes.common import (
+    is_scalar,
+    is_numeric_dtype,
+    is_decimal,
+    is_datetime_or_timedelta_dtype,
+    is_number,
+    _ensure_object)
+from pandas.core.dtypes.generic import ABCSeries, ABCIndexClass
+from pandas.core.dtypes.cast import maybe_downcast_to_dtype
+from pandas._libs import lib
+
+
+def to_numeric(arg, errors='raise', downcast=None):
+    """
+    Convert argument to a numeric type.
+
+    Parameters
+    ----------
+    arg : list, tuple, 1-d array, or Series
+    errors : {'ignore', 'raise', 'coerce'}, default 'raise'
+        - If 'raise', then invalid parsing will raise an exception
+        - If 'coerce', then invalid parsing will be set as NaN
+        - If 'ignore', then invalid parsing will return the input
+    downcast : {'integer', 'signed', 'unsigned', 'float'} , default None
+        If not None, and if the data has been successfully cast to a
+        numerical dtype (or if the data was numeric to begin with),
+        downcast that resulting data to the smallest numerical dtype
+        possible according to the following rules:
+
+        - 'integer' or 'signed': smallest signed int dtype (min.: np.int8)
+        - 'unsigned': smallest unsigned int dtype (min.: np.uint8)
+        - 'float': smallest float dtype (min.: np.float32)
+
+        As this behaviour is separate from the core conversion to
+        numeric values, any errors raised during the downcasting
+        will be surfaced regardless of the value of the 'errors' input.
+
+        In addition, downcasting will only occur if the size
+        of the resulting data's dtype is strictly larger than
+        the dtype it is to be cast to, so if none of the dtypes
+        checked satisfy that specification, no downcasting will be
+        performed on the data.
+
+        .. versionadded:: 0.19.0
+
+    Returns
+    -------
+    ret : numeric if parsing succeeded.
+        Return type depends on input.  Series if Series, otherwise ndarray
+
+    Examples
+    --------
+    Take separate series and convert to numeric, coercing when told to
+
+    >>> import pandas as pd
+    >>> s = pd.Series(['1.0', '2', -3])
+    >>> pd.to_numeric(s)
+    0    1.0
+    1    2.0
+    2   -3.0
+    dtype: float64
+    >>> pd.to_numeric(s, downcast='float')
+    0    1.0
+    1    2.0
+    2   -3.0
+    dtype: float32
+    >>> pd.to_numeric(s, downcast='signed')
+    0    1
+    1    2
+    2   -3
+    dtype: int8
+    >>> s = pd.Series(['apple', '1.0', '2', -3])
+    >>> pd.to_numeric(s, errors='ignore')
+    0    apple
+    1      1.0
+    2        2
+    3       -3
+    dtype: object
+    >>> pd.to_numeric(s, errors='coerce')
+    0    NaN
+    1    1.0
+    2    2.0
+    3   -3.0
+    dtype: float64
+    """
+    if downcast not in (None, 'integer', 'signed', 'unsigned', 'float'):
+        raise ValueError('invalid downcasting method provided')
+
+    is_series = False
+    is_index = False
+    is_scalars = False
+
+    if isinstance(arg, ABCSeries):
+        is_series = True
+        values = arg.values
+    elif isinstance(arg, ABCIndexClass):
+        is_index = True
+        values = arg.asi8
+        if values is None:
+            values = arg.values
+    elif isinstance(arg, (list, tuple)):
+        values = np.array(arg, dtype='O')
+    elif is_scalar(arg):
+        if is_decimal(arg):
+            return float(arg)
+        if is_number(arg):
+            return arg
+        is_scalars = True
+        values = np.array([arg], dtype='O')
+    elif getattr(arg, 'ndim', 1) > 1:
+        raise TypeError('arg must be a list, tuple, 1-d array, or Series')
+    else:
+        values = arg
+
+    try:
+        if is_numeric_dtype(values):
+            pass
+        elif is_datetime_or_timedelta_dtype(values):
+            values = values.astype(np.int64)
+        else:
+            values = _ensure_object(values)
+            coerce_numeric = False if errors in ('ignore', 'raise') else True
+            values = lib.maybe_convert_numeric(values, set(),
+                                               coerce_numeric=coerce_numeric)
+
+    except Exception:
+        if errors == 'raise':
+            raise
+
+    # attempt downcast only if the data has been successfully converted
+    # to a numerical dtype and if a downcast method has been specified
+    if downcast is not None and is_numeric_dtype(values):
+        typecodes = None
+
+        if downcast in ('integer', 'signed'):
+            typecodes = np.typecodes['Integer']
+        elif downcast == 'unsigned' and np.min(values) >= 0:
+            typecodes = np.typecodes['UnsignedInteger']
+        elif downcast == 'float':
+            typecodes = np.typecodes['Float']
+
+            # pandas support goes only to np.float32,
+            # as float dtypes smaller than that are
+            # extremely rare and not well supported
+            float_32_char = np.dtype(np.float32).char
+            float_32_ind = typecodes.index(float_32_char)
+            typecodes = typecodes[float_32_ind:]
+
+        if typecodes is not None:
+            # from smallest to largest
+            for dtype in typecodes:
+                if np.dtype(dtype).itemsize <= values.dtype.itemsize:
+                    values = maybe_downcast_to_dtype(values, dtype)
+
+                    # successful conversion
+                    if values.dtype == dtype:
+                        break
+
+    if is_series:
+        return pd.Series(values, index=arg.index, name=arg.name)
+    elif is_index:
+        # because we want to coerce to numeric if possible,
+        # do not use _shallow_copy_with_infer
+        return pd.Index(values, name=arg.name)
+    elif is_scalars:
+        return values[0]
+    else:
+        return values
diff --git a/pandas/tseries/timedeltas.py b/pandas/core/tools/timedeltas.py
similarity index 100%
rename from pandas/tseries/timedeltas.py
rename to pandas/core/tools/timedeltas.py
diff --git a/pandas/io/excel.py b/pandas/io/excel.py
index 637635a64..fbb10ebdf 100644
--- a/pandas/io/excel.py
+++ b/pandas/io/excel.py
@@ -19,7 +19,7 @@ from pandas.io.parsers import TextParser
 from pandas.errors import EmptyDataError
 from pandas.io.common import (_is_url, _urlopen, _validate_header_arg,
                               get_filepath_or_buffer, _NA_VALUES)
-from pandas.tseries.period import Period
+from pandas.core.indexes.period import Period
 from pandas.io.json import libjson
 from pandas.compat import (map, zip, reduce, range, lrange, u, add_metaclass,
                            string_types, OrderedDict)
diff --git a/pandas/io/formats/format.py b/pandas/io/formats/format.py
index 6fbcbe7d6..d618fab08 100644
--- a/pandas/io/formats/format.py
+++ b/pandas/io/formats/format.py
@@ -38,8 +38,8 @@ import pandas.core.common as com
 import pandas._libs.lib as lib
 from pandas._libs.tslib import (iNaT, Timestamp, Timedelta,
                                 format_array_from_datetime)
-from pandas.tseries.index import DatetimeIndex
-from pandas.tseries.period import PeriodIndex
+from pandas.core.indexes.datetimes import DatetimeIndex
+from pandas.core.indexes.period import PeriodIndex
 import pandas as pd
 import numpy as np
 
@@ -2314,7 +2314,7 @@ class IntervalArrayFormatter(GenericArrayFormatter):
 class PeriodArrayFormatter(IntArrayFormatter):
 
     def _format_strings(self):
-        from pandas.tseries.period import IncompatibleFrequency
+        from pandas.core.indexes.period import IncompatibleFrequency
         try:
             values = PeriodIndex(self.values).to_native_types()
         except IncompatibleFrequency:
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index f2449e306..79595818b 100755
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -35,7 +35,7 @@ from pandas.io.common import (get_filepath_or_buffer, _validate_header_arg,
                               _get_handle, UnicodeReader, UTF8Recoder,
                               BaseIterator,
                               _NA_VALUES, _infer_compression)
-from pandas.tseries import tools
+from pandas.core.tools import datetimes as tools
 
 from pandas.util.decorators import Appender
 
diff --git a/pandas/io/sql.py b/pandas/io/sql.py
index de47a8ad5..ee992c6dd 100644
--- a/pandas/io/sql.py
+++ b/pandas/io/sql.py
@@ -22,7 +22,7 @@ from pandas.compat import (map, zip, raise_with_traceback,
                            string_types, text_type)
 from pandas.core.api import DataFrame, Series
 from pandas.core.base import PandasObject
-from pandas.tseries.tools import to_datetime
+from pandas.core.tools.datetimes import to_datetime
 
 from contextlib import contextmanager
 
diff --git a/pandas/plotting/_converter.py b/pandas/plotting/_converter.py
index 9621ee3d0..97295dfa7 100644
--- a/pandas/plotting/_converter.py
+++ b/pandas/plotting/_converter.py
@@ -26,11 +26,11 @@ import pandas.core.common as com
 from pandas.core.index import Index
 
 from pandas.core.series import Series
-from pandas.tseries.index import date_range
-import pandas.tseries.tools as tools
+from pandas.core.indexes.datetimes import date_range
+import pandas.core.tools.datetimes as tools
 import pandas.tseries.frequencies as frequencies
 from pandas.tseries.frequencies import FreqGroup
-from pandas.tseries.period import Period, PeriodIndex
+from pandas.core.indexes.period import Period, PeriodIndex
 
 from pandas.plotting._compat import _mpl_le_2_0_0
 
diff --git a/pandas/plotting/_core.py b/pandas/plotting/_core.py
index 934c05ba5..c3476d144 100644
--- a/pandas/plotting/_core.py
+++ b/pandas/plotting/_core.py
@@ -21,7 +21,7 @@ from pandas.core.common import AbstractMethodError, isnull, _try_sort
 from pandas.core.generic import _shared_docs, _shared_doc_kwargs
 from pandas.core.index import Index, MultiIndex
 from pandas.core.series import Series, remove_na
-from pandas.tseries.period import PeriodIndex
+from pandas.core.indexes.period import PeriodIndex
 from pandas.compat import range, lrange, map, zip, string_types
 import pandas.compat as compat
 from pandas.io.formats.printing import pprint_thing
diff --git a/pandas/plotting/_timeseries.py b/pandas/plotting/_timeseries.py
index f8c7c1ee9..3d04973ed 100644
--- a/pandas/plotting/_timeseries.py
+++ b/pandas/plotting/_timeseries.py
@@ -3,12 +3,12 @@
 import numpy as np
 
 from matplotlib import pylab
-from pandas.tseries.period import Period
+from pandas.core.indexes.period import Period
 from pandas.tseries.offsets import DateOffset
 import pandas.tseries.frequencies as frequencies
-from pandas.tseries.index import DatetimeIndex
-from pandas.tseries.period import PeriodIndex
-from pandas.tseries.tdi import TimedeltaIndex
+from pandas.core.indexes.datetimes import DatetimeIndex
+from pandas.core.indexes.period import PeriodIndex
+from pandas.core.indexes.timedeltas import TimedeltaIndex
 from pandas.io.formats.printing import pprint_thing
 import pandas.compat as compat
 
diff --git a/pandas/tests/dtypes/test_cast.py b/pandas/tests/dtypes/test_cast.py
index e59784d23..f3fdc54d4 100644
--- a/pandas/tests/dtypes/test_cast.py
+++ b/pandas/tests/dtypes/test_cast.py
@@ -6,13 +6,10 @@ These test the private routines in types/cast.py
 """
 
 import pytest
-import decimal
 from datetime import datetime, timedelta, date
 import numpy as np
 
-import pandas as pd
-from pandas import (Timedelta, Timestamp, DatetimeIndex,
-                    to_numeric, _np_version_under1p9)
+from pandas import Timedelta, Timestamp, DatetimeIndex
 
 from pandas.core.dtypes.cast import (
     maybe_downcast_to_dtype,
@@ -28,8 +25,6 @@ from pandas.core.dtypes.dtypes import (
     PeriodDtype)
 from pandas.util import testing as tm
 
-from numpy import iinfo
-
 
 class TestMaybeDowncast(tm.TestCase):
 
@@ -327,365 +322,3 @@ class TestCommonTypes(tm.TestCase):
                        np.dtype('datetime64[ns]'), np.object, np.int64]:
             self.assertEqual(find_common_type([dtype, dtype2]), np.object)
             self.assertEqual(find_common_type([dtype2, dtype]), np.object)
-
-
-class TestToNumeric(tm.TestCase):
-
-    def test_series(self):
-        s = pd.Series(['1', '-3.14', '7'])
-        res = to_numeric(s)
-        expected = pd.Series([1, -3.14, 7])
-        tm.assert_series_equal(res, expected)
-
-        s = pd.Series(['1', '-3.14', 7])
-        res = to_numeric(s)
-        tm.assert_series_equal(res, expected)
-
-    def test_series_numeric(self):
-        s = pd.Series([1, 3, 4, 5], index=list('ABCD'), name='XXX')
-        res = to_numeric(s)
-        tm.assert_series_equal(res, s)
-
-        s = pd.Series([1., 3., 4., 5.], index=list('ABCD'), name='XXX')
-        res = to_numeric(s)
-        tm.assert_series_equal(res, s)
-
-        # bool is regarded as numeric
-        s = pd.Series([True, False, True, True],
-                      index=list('ABCD'), name='XXX')
-        res = to_numeric(s)
-        tm.assert_series_equal(res, s)
-
-    def test_error(self):
-        s = pd.Series([1, -3.14, 'apple'])
-        msg = 'Unable to parse string "apple" at position 2'
-        with tm.assertRaisesRegexp(ValueError, msg):
-            to_numeric(s, errors='raise')
-
-        res = to_numeric(s, errors='ignore')
-        expected = pd.Series([1, -3.14, 'apple'])
-        tm.assert_series_equal(res, expected)
-
-        res = to_numeric(s, errors='coerce')
-        expected = pd.Series([1, -3.14, np.nan])
-        tm.assert_series_equal(res, expected)
-
-        s = pd.Series(['orange', 1, -3.14, 'apple'])
-        msg = 'Unable to parse string "orange" at position 0'
-        with tm.assertRaisesRegexp(ValueError, msg):
-            to_numeric(s, errors='raise')
-
-    def test_error_seen_bool(self):
-        s = pd.Series([True, False, 'apple'])
-        msg = 'Unable to parse string "apple" at position 2'
-        with tm.assertRaisesRegexp(ValueError, msg):
-            to_numeric(s, errors='raise')
-
-        res = to_numeric(s, errors='ignore')
-        expected = pd.Series([True, False, 'apple'])
-        tm.assert_series_equal(res, expected)
-
-        # coerces to float
-        res = to_numeric(s, errors='coerce')
-        expected = pd.Series([1., 0., np.nan])
-        tm.assert_series_equal(res, expected)
-
-    def test_list(self):
-        s = ['1', '-3.14', '7']
-        res = to_numeric(s)
-        expected = np.array([1, -3.14, 7])
-        tm.assert_numpy_array_equal(res, expected)
-
-    def test_list_numeric(self):
-        s = [1, 3, 4, 5]
-        res = to_numeric(s)
-        tm.assert_numpy_array_equal(res, np.array(s, dtype=np.int64))
-
-        s = [1., 3., 4., 5.]
-        res = to_numeric(s)
-        tm.assert_numpy_array_equal(res, np.array(s))
-
-        # bool is regarded as numeric
-        s = [True, False, True, True]
-        res = to_numeric(s)
-        tm.assert_numpy_array_equal(res, np.array(s))
-
-    def test_numeric(self):
-        s = pd.Series([1, -3.14, 7], dtype='O')
-        res = to_numeric(s)
-        expected = pd.Series([1, -3.14, 7])
-        tm.assert_series_equal(res, expected)
-
-        s = pd.Series([1, -3.14, 7])
-        res = to_numeric(s)
-        tm.assert_series_equal(res, expected)
-
-        # GH 14827
-        df = pd.DataFrame(dict(
-            a=[1.2, decimal.Decimal(3.14), decimal.Decimal("infinity"), '0.1'],
-            b=[1.0, 2.0, 3.0, 4.0],
-        ))
-        expected = pd.DataFrame(dict(
-            a=[1.2, 3.14, np.inf, 0.1],
-            b=[1.0, 2.0, 3.0, 4.0],
-        ))
-
-        # Test to_numeric over one column
-        df_copy = df.copy()
-        df_copy['a'] = df_copy['a'].apply(to_numeric)
-        tm.assert_frame_equal(df_copy, expected)
-
-        # Test to_numeric over multiple columns
-        df_copy = df.copy()
-        df_copy[['a', 'b']] = df_copy[['a', 'b']].apply(to_numeric)
-        tm.assert_frame_equal(df_copy, expected)
-
-    def test_numeric_lists_and_arrays(self):
-        # Test to_numeric with embedded lists and arrays
-        df = pd.DataFrame(dict(
-            a=[[decimal.Decimal(3.14), 1.0], decimal.Decimal(1.6), 0.1]
-        ))
-        df['a'] = df['a'].apply(to_numeric)
-        expected = pd.DataFrame(dict(
-            a=[[3.14, 1.0], 1.6, 0.1],
-        ))
-        tm.assert_frame_equal(df, expected)
-
-        df = pd.DataFrame(dict(
-            a=[np.array([decimal.Decimal(3.14), 1.0]), 0.1]
-        ))
-        df['a'] = df['a'].apply(to_numeric)
-        expected = pd.DataFrame(dict(
-            a=[[3.14, 1.0], 0.1],
-        ))
-        tm.assert_frame_equal(df, expected)
-
-    def test_all_nan(self):
-        s = pd.Series(['a', 'b', 'c'])
-        res = to_numeric(s, errors='coerce')
-        expected = pd.Series([np.nan, np.nan, np.nan])
-        tm.assert_series_equal(res, expected)
-
-    def test_type_check(self):
-        # GH 11776
-        df = pd.DataFrame({'a': [1, -3.14, 7], 'b': ['4', '5', '6']})
-        with tm.assertRaisesRegexp(TypeError, "1-d array"):
-            to_numeric(df)
-        for errors in ['ignore', 'raise', 'coerce']:
-            with tm.assertRaisesRegexp(TypeError, "1-d array"):
-                to_numeric(df, errors=errors)
-
-    def test_scalar(self):
-        self.assertEqual(pd.to_numeric(1), 1)
-        self.assertEqual(pd.to_numeric(1.1), 1.1)
-
-        self.assertEqual(pd.to_numeric('1'), 1)
-        self.assertEqual(pd.to_numeric('1.1'), 1.1)
-
-        with tm.assertRaises(ValueError):
-            to_numeric('XX', errors='raise')
-
-        self.assertEqual(to_numeric('XX', errors='ignore'), 'XX')
-        self.assertTrue(np.isnan(to_numeric('XX', errors='coerce')))
-
-    def test_numeric_dtypes(self):
-        idx = pd.Index([1, 2, 3], name='xxx')
-        res = pd.to_numeric(idx)
-        tm.assert_index_equal(res, idx)
-
-        res = pd.to_numeric(pd.Series(idx, name='xxx'))
-        tm.assert_series_equal(res, pd.Series(idx, name='xxx'))
-
-        res = pd.to_numeric(idx.values)
-        tm.assert_numpy_array_equal(res, idx.values)
-
-        idx = pd.Index([1., np.nan, 3., np.nan], name='xxx')
-        res = pd.to_numeric(idx)
-        tm.assert_index_equal(res, idx)
-
-        res = pd.to_numeric(pd.Series(idx, name='xxx'))
-        tm.assert_series_equal(res, pd.Series(idx, name='xxx'))
-
-        res = pd.to_numeric(idx.values)
-        tm.assert_numpy_array_equal(res, idx.values)
-
-    def test_str(self):
-        idx = pd.Index(['1', '2', '3'], name='xxx')
-        exp = np.array([1, 2, 3], dtype='int64')
-        res = pd.to_numeric(idx)
-        tm.assert_index_equal(res, pd.Index(exp, name='xxx'))
-
-        res = pd.to_numeric(pd.Series(idx, name='xxx'))
-        tm.assert_series_equal(res, pd.Series(exp, name='xxx'))
-
-        res = pd.to_numeric(idx.values)
-        tm.assert_numpy_array_equal(res, exp)
-
-        idx = pd.Index(['1.5', '2.7', '3.4'], name='xxx')
-        exp = np.array([1.5, 2.7, 3.4])
-        res = pd.to_numeric(idx)
-        tm.assert_index_equal(res, pd.Index(exp, name='xxx'))
-
-        res = pd.to_numeric(pd.Series(idx, name='xxx'))
-        tm.assert_series_equal(res, pd.Series(exp, name='xxx'))
-
-        res = pd.to_numeric(idx.values)
-        tm.assert_numpy_array_equal(res, exp)
-
-    def test_datetimelike(self):
-        for tz in [None, 'US/Eastern', 'Asia/Tokyo']:
-            idx = pd.date_range('20130101', periods=3, tz=tz, name='xxx')
-            res = pd.to_numeric(idx)
-            tm.assert_index_equal(res, pd.Index(idx.asi8, name='xxx'))
-
-            res = pd.to_numeric(pd.Series(idx, name='xxx'))
-            tm.assert_series_equal(res, pd.Series(idx.asi8, name='xxx'))
-
-            res = pd.to_numeric(idx.values)
-            tm.assert_numpy_array_equal(res, idx.asi8)
-
-    def test_timedelta(self):
-        idx = pd.timedelta_range('1 days', periods=3, freq='D', name='xxx')
-        res = pd.to_numeric(idx)
-        tm.assert_index_equal(res, pd.Index(idx.asi8, name='xxx'))
-
-        res = pd.to_numeric(pd.Series(idx, name='xxx'))
-        tm.assert_series_equal(res, pd.Series(idx.asi8, name='xxx'))
-
-        res = pd.to_numeric(idx.values)
-        tm.assert_numpy_array_equal(res, idx.asi8)
-
-    def test_period(self):
-        idx = pd.period_range('2011-01', periods=3, freq='M', name='xxx')
-        res = pd.to_numeric(idx)
-        tm.assert_index_equal(res, pd.Index(idx.asi8, name='xxx'))
-
-        # ToDo: enable when we can support native PeriodDtype
-        # res = pd.to_numeric(pd.Series(idx, name='xxx'))
-        # tm.assert_series_equal(res, pd.Series(idx.asi8, name='xxx'))
-
-    def test_non_hashable(self):
-        # Test for Bug #13324
-        s = pd.Series([[10.0, 2], 1.0, 'apple'])
-        res = pd.to_numeric(s, errors='coerce')
-        tm.assert_series_equal(res, pd.Series([np.nan, 1.0, np.nan]))
-
-        res = pd.to_numeric(s, errors='ignore')
-        tm.assert_series_equal(res, pd.Series([[10.0, 2], 1.0, 'apple']))
-
-        with self.assertRaisesRegexp(TypeError, "Invalid object type"):
-            pd.to_numeric(s)
-
-    def test_downcast(self):
-        # see gh-13352
-        mixed_data = ['1', 2, 3]
-        int_data = [1, 2, 3]
-        date_data = np.array(['1970-01-02', '1970-01-03',
-                              '1970-01-04'], dtype='datetime64[D]')
-
-        invalid_downcast = 'unsigned-integer'
-        msg = 'invalid downcasting method provided'
-
-        smallest_int_dtype = np.dtype(np.typecodes['Integer'][0])
-        smallest_uint_dtype = np.dtype(np.typecodes['UnsignedInteger'][0])
-
-        # support below np.float32 is rare and far between
-        float_32_char = np.dtype(np.float32).char
-        smallest_float_dtype = float_32_char
-
-        for data in (mixed_data, int_data, date_data):
-            with self.assertRaisesRegexp(ValueError, msg):
-                pd.to_numeric(data, downcast=invalid_downcast)
-
-            expected = np.array([1, 2, 3], dtype=np.int64)
-
-            res = pd.to_numeric(data)
-            tm.assert_numpy_array_equal(res, expected)
-
-            res = pd.to_numeric(data, downcast=None)
-            tm.assert_numpy_array_equal(res, expected)
-
-            expected = np.array([1, 2, 3], dtype=smallest_int_dtype)
-
-            for signed_downcast in ('integer', 'signed'):
-                res = pd.to_numeric(data, downcast=signed_downcast)
-                tm.assert_numpy_array_equal(res, expected)
-
-            expected = np.array([1, 2, 3], dtype=smallest_uint_dtype)
-            res = pd.to_numeric(data, downcast='unsigned')
-            tm.assert_numpy_array_equal(res, expected)
-
-            expected = np.array([1, 2, 3], dtype=smallest_float_dtype)
-            res = pd.to_numeric(data, downcast='float')
-            tm.assert_numpy_array_equal(res, expected)
-
-        # if we can't successfully cast the given
-        # data to a numeric dtype, do not bother
-        # with the downcast parameter
-        data = ['foo', 2, 3]
-        expected = np.array(data, dtype=object)
-        res = pd.to_numeric(data, errors='ignore',
-                            downcast='unsigned')
-        tm.assert_numpy_array_equal(res, expected)
-
-        # cannot cast to an unsigned integer because
-        # we have a negative number
-        data = ['-1', 2, 3]
-        expected = np.array([-1, 2, 3], dtype=np.int64)
-        res = pd.to_numeric(data, downcast='unsigned')
-        tm.assert_numpy_array_equal(res, expected)
-
-        # cannot cast to an integer (signed or unsigned)
-        # because we have a float number
-        data = (['1.1', 2, 3],
-                [10000.0, 20000, 3000, 40000.36, 50000, 50000.00])
-        expected = (np.array([1.1, 2, 3], dtype=np.float64),
-                    np.array([10000.0, 20000, 3000,
-                              40000.36, 50000, 50000.00], dtype=np.float64))
-
-        for _data, _expected in zip(data, expected):
-            for downcast in ('integer', 'signed', 'unsigned'):
-                res = pd.to_numeric(_data, downcast=downcast)
-                tm.assert_numpy_array_equal(res, _expected)
-
-        # the smallest integer dtype need not be np.(u)int8
-        data = ['256', 257, 258]
-
-        for downcast, expected_dtype in zip(
-                ['integer', 'signed', 'unsigned'],
-                [np.int16, np.int16, np.uint16]):
-            expected = np.array([256, 257, 258], dtype=expected_dtype)
-            res = pd.to_numeric(data, downcast=downcast)
-            tm.assert_numpy_array_equal(res, expected)
-
-    def test_downcast_limits(self):
-        # Test the limits of each downcast. Bug: #14401.
-        # Check to make sure numpy is new enough to run this test.
-        if _np_version_under1p9:
-            pytest.skip("Numpy version is under 1.9")
-
-        i = 'integer'
-        u = 'unsigned'
-        dtype_downcast_min_max = [
-            ('int8', i, [iinfo(np.int8).min, iinfo(np.int8).max]),
-            ('int16', i, [iinfo(np.int16).min, iinfo(np.int16).max]),
-            ('int32', i, [iinfo(np.int32).min, iinfo(np.int32).max]),
-            ('int64', i, [iinfo(np.int64).min, iinfo(np.int64).max]),
-            ('uint8', u, [iinfo(np.uint8).min, iinfo(np.uint8).max]),
-            ('uint16', u, [iinfo(np.uint16).min, iinfo(np.uint16).max]),
-            ('uint32', u, [iinfo(np.uint32).min, iinfo(np.uint32).max]),
-            ('uint64', u, [iinfo(np.uint64).min, iinfo(np.uint64).max]),
-            ('int16', i, [iinfo(np.int8).min, iinfo(np.int8).max + 1]),
-            ('int32', i, [iinfo(np.int16).min, iinfo(np.int16).max + 1]),
-            ('int64', i, [iinfo(np.int32).min, iinfo(np.int32).max + 1]),
-            ('int16', i, [iinfo(np.int8).min - 1, iinfo(np.int16).max]),
-            ('int32', i, [iinfo(np.int16).min - 1, iinfo(np.int32).max]),
-            ('int64', i, [iinfo(np.int32).min - 1, iinfo(np.int64).max]),
-            ('uint16', u, [iinfo(np.uint8).min, iinfo(np.uint8).max + 1]),
-            ('uint32', u, [iinfo(np.uint16).min, iinfo(np.uint16).max + 1]),
-            ('uint64', u, [iinfo(np.uint32).min, iinfo(np.uint32).max + 1])
-        ]
-
-        for dtype, downcast, min_max in dtype_downcast_min_max:
-            series = pd.to_numeric(pd.Series(min_max), downcast=downcast)
-            assert series.dtype == dtype
diff --git a/pandas/tests/frame/test_alter_axes.py b/pandas/tests/frame/test_alter_axes.py
index ce4dd6d38..3133a6883 100644
--- a/pandas/tests/frame/test_alter_axes.py
+++ b/pandas/tests/frame/test_alter_axes.py
@@ -8,7 +8,8 @@ import numpy as np
 
 from pandas.compat import lrange
 from pandas import (DataFrame, Series, Index, MultiIndex,
-                    RangeIndex, date_range, IntervalIndex)
+                    RangeIndex, date_range, IntervalIndex,
+                    to_datetime)
 from pandas.core.dtypes.common import (
     is_object_dtype,
     is_categorical_dtype,
@@ -202,8 +203,8 @@ class TestDataFrameAlterAxes(tm.TestCase, TestData):
         # don't cast a DatetimeIndex WITH a tz, leave as object
         # GH 6032
         i = (pd.DatetimeIndex(
-            pd.tseries.tools.to_datetime(['2013-1-1 13:00',
-                                          '2013-1-2 14:00'], errors="raise"))
+            to_datetime(['2013-1-1 13:00',
+                         '2013-1-2 14:00'], errors="raise"))
              .tz_localize('US/Pacific'))
         df = DataFrame(np.random.randn(2, 1), columns=['A'])
 
diff --git a/pandas/tests/frame/test_analytics.py b/pandas/tests/frame/test_analytics.py
index e165e30c5..979493b95 100644
--- a/pandas/tests/frame/test_analytics.py
+++ b/pandas/tests/frame/test_analytics.py
@@ -873,7 +873,7 @@ class TestDataFrameAnalytics(tm.TestCase, TestData):
         mixed['F'] = Timestamp('20130101')
 
         # results in an object array
-        from pandas.tseries.timedeltas import (
+        from pandas.core.tools.timedeltas import (
             _coerce_scalar_to_timedelta_type as _coerce)
 
         result = mixed.min()
diff --git a/pandas/tests/frame/test_timeseries.py b/pandas/tests/frame/test_timeseries.py
index 37b6f0c26..7765bac55 100644
--- a/pandas/tests/frame/test_timeseries.py
+++ b/pandas/tests/frame/test_timeseries.py
@@ -547,7 +547,7 @@ class TestDataFrameTimeSeriesMethods(tm.TestCase, TestData):
 
     def test_frame_to_period(self):
         K = 5
-        from pandas.tseries.period import period_range
+        from pandas.core.indexes.period import period_range
 
         dr = date_range('1/1/2000', '1/1/2001')
         pr = period_range('1/1/2000', '1/1/2001')
diff --git a/pandas/tests/groupby/test_groupby.py b/pandas/tests/groupby/test_groupby.py
index f486c70d8..880737392 100644
--- a/pandas/tests/groupby/test_groupby.py
+++ b/pandas/tests/groupby/test_groupby.py
@@ -8,7 +8,7 @@ from numpy import nan
 
 from pandas import (date_range, bdate_range, Timestamp,
                     isnull, Index, MultiIndex, DataFrame, Series,
-                    concat, Panel)
+                    concat, Panel, DatetimeIndex)
 from pandas.errors import UnsupportedFunctionCall, PerformanceWarning
 from pandas.util.testing import (assert_panel_equal, assert_frame_equal,
                                  assert_series_equal, assert_almost_equal,
@@ -3305,7 +3305,6 @@ class TestGroupBy(MixIn, tm.TestCase):
         assert_series_equal(result, mseries_result.sort_index())
 
     def test_groupby_reindex_inside_function(self):
-        from pandas.tseries.api import DatetimeIndex
 
         periods = 1000
         ind = DatetimeIndex(start='2012/1/1', freq='5min', periods=periods)
@@ -3559,7 +3558,7 @@ class TestGroupBy(MixIn, tm.TestCase):
         index = pd.DatetimeIndex(())
         data = ()
         series = pd.Series(data, index)
-        grouper = pd.tseries.resample.TimeGrouper('D')
+        grouper = pd.core.resample.TimeGrouper('D')
         grouped = series.groupby(grouper)
         assert next(iter(grouped), None) is None
 
diff --git a/pandas/tests/groupby/test_timegrouper.py b/pandas/tests/groupby/test_timegrouper.py
index 3142b74b5..f97f59cd9 100644
--- a/pandas/tests/groupby/test_timegrouper.py
+++ b/pandas/tests/groupby/test_timegrouper.py
@@ -5,7 +5,8 @@ import numpy as np
 from numpy import nan
 
 import pandas as pd
-from pandas import DataFrame, date_range, Index, Series, MultiIndex, Timestamp
+from pandas import (DataFrame, date_range, Index,
+                    Series, MultiIndex, Timestamp, DatetimeIndex)
 from pandas.compat import StringIO
 from pandas.util import testing as tm
 from pandas.util.testing import assert_frame_equal, assert_series_equal
@@ -361,7 +362,6 @@ class TestGroupBy(tm.TestCase):
 
     def test_groupby_groups_datetimeindex(self):
         # #1430
-        from pandas.tseries.api import DatetimeIndex
         periods = 1000
         ind = DatetimeIndex(start='2012/1/1', freq='5min', periods=periods)
         df = DataFrame({'high': np.arange(periods),
diff --git a/pandas/tests/indexes/common.py b/pandas/tests/indexes/common.py
index 9003a3707..d53f13182 100644
--- a/pandas/tests/indexes/common.py
+++ b/pandas/tests/indexes/common.py
@@ -9,6 +9,7 @@ from pandas import (Series, Index, Float64Index, Int64Index, UInt64Index,
                     RangeIndex, MultiIndex, CategoricalIndex, DatetimeIndex,
                     TimedeltaIndex, PeriodIndex, IntervalIndex,
                     notnull, isnull)
+from pandas.core.indexes.datetimelike import DatetimeIndexOpsMixin
 from pandas.core.dtypes.common import needs_i8_conversion
 from pandas.util.testing import assertRaisesRegexp
 from pandas._libs.tslib import iNaT
@@ -789,7 +790,7 @@ class Base(object):
                          np.arccos, np.arctan, np.sinh, np.cosh, np.tanh,
                          np.arcsinh, np.arccosh, np.arctanh, np.deg2rad,
                          np.rad2deg]:
-                if isinstance(idx, pd.tseries.base.DatetimeIndexOpsMixin):
+                if isinstance(idx, DatetimeIndexOpsMixin):
                     # raise TypeError or ValueError (PeriodIndex)
                     # PeriodIndex behavior should be changed in future version
                     with tm.assertRaises(Exception):
@@ -812,7 +813,7 @@ class Base(object):
                                 func(idx)
 
             for func in [np.isfinite, np.isinf, np.isnan, np.signbit]:
-                if isinstance(idx, pd.tseries.base.DatetimeIndexOpsMixin):
+                if isinstance(idx, DatetimeIndexOpsMixin):
                     # raise TypeError or ValueError (PeriodIndex)
                     with tm.assertRaises(Exception):
                         func(idx)
@@ -847,7 +848,7 @@ class Base(object):
 
                 if len(index) == 0:
                     continue
-                elif isinstance(index, pd.tseries.base.DatetimeIndexOpsMixin):
+                elif isinstance(index, DatetimeIndexOpsMixin):
                     values[1] = iNaT
                 elif isinstance(index, (Int64Index, UInt64Index)):
                     continue
@@ -887,7 +888,7 @@ class Base(object):
                 idx = index.copy()
                 values = idx.values
 
-                if isinstance(index, pd.tseries.base.DatetimeIndexOpsMixin):
+                if isinstance(index, DatetimeIndexOpsMixin):
                     values[1] = iNaT
                 elif isinstance(index, (Int64Index, UInt64Index)):
                     continue
diff --git a/pandas/tests/indexes/datetimes/test_date_range.py b/pandas/tests/indexes/datetimes/test_date_range.py
index 67e82e5c7..3eaeda965 100644
--- a/pandas/tests/indexes/datetimes/test_date_range.py
+++ b/pandas/tests/indexes/datetimes/test_date_range.py
@@ -9,7 +9,7 @@ from datetime import datetime, timedelta, time
 import pandas as pd
 import pandas.util.testing as tm
 from pandas import compat
-from pandas.tseries.index import bdate_range, cdate_range
+from pandas.core.indexes.datetimes import bdate_range, cdate_range
 from pandas import date_range, offsets, DatetimeIndex, Timestamp
 from pandas.tseries.offsets import (generate_range, CDay, BDay,
                                     DateOffset, MonthEnd)
diff --git a/pandas/tests/indexes/datetimes/test_ops.py b/pandas/tests/indexes/datetimes/test_ops.py
index 8ab29c0c0..5dcc49cf7 100644
--- a/pandas/tests/indexes/datetimes/test_ops.py
+++ b/pandas/tests/indexes/datetimes/test_ops.py
@@ -8,7 +8,7 @@ import pandas as pd
 import pandas._libs.tslib as tslib
 import pandas.util.testing as tm
 from pandas.errors import PerformanceWarning
-from pandas.tseries.index import cdate_range
+from pandas.core.indexes.datetimes import cdate_range
 from pandas import (DatetimeIndex, PeriodIndex, Series, Timestamp, Timedelta,
                     date_range, TimedeltaIndex, _np_version_under1p10, Index,
                     datetime, Float64Index, offsets, bdate_range)
diff --git a/pandas/tests/indexes/datetimes/test_setops.py b/pandas/tests/indexes/datetimes/test_setops.py
index a1ad147f8..2da37f939 100644
--- a/pandas/tests/indexes/datetimes/test_setops.py
+++ b/pandas/tests/indexes/datetimes/test_setops.py
@@ -4,7 +4,7 @@ import numpy as np
 
 import pandas as pd
 import pandas.util.testing as tm
-from pandas.tseries.index import cdate_range
+from pandas.core.indexes.datetimes import cdate_range
 from pandas import (DatetimeIndex, date_range, Series, bdate_range, DataFrame,
                     Int64Index, Index, to_datetime)
 from pandas.tseries.offsets import Minute, BMonthEnd, MonthEnd
diff --git a/pandas/tests/indexes/datetimes/test_tools.py b/pandas/tests/indexes/datetimes/test_tools.py
index f8eb923d5..a250a936b 100644
--- a/pandas/tests/indexes/datetimes/test_tools.py
+++ b/pandas/tests/indexes/datetimes/test_tools.py
@@ -10,8 +10,8 @@ from distutils.version import LooseVersion
 
 import pandas as pd
 from pandas._libs import tslib, lib
-from pandas.tseries import tools
-from pandas.tseries.tools import normalize_date
+from pandas.core.tools import datetimes as tools
+from pandas.core.tools.datetimes import normalize_date
 from pandas.compat import lmap
 from pandas.compat.numpy import np_array_datetime64_compat
 from pandas.core.dtypes.common import is_datetime64_ns_dtype
diff --git a/pandas/tests/indexes/period/test_construction.py b/pandas/tests/indexes/period/test_construction.py
index ab70ad598..1340c9cad 100644
--- a/pandas/tests/indexes/period/test_construction.py
+++ b/pandas/tests/indexes/period/test_construction.py
@@ -2,7 +2,7 @@ import numpy as np
 
 import pandas as pd
 import pandas.util.testing as tm
-import pandas.tseries.period as period
+import pandas.core.indexes.period as period
 from pandas.compat import lrange, PY3, text_type, lmap
 from pandas import (Period, PeriodIndex, period_range, offsets, date_range,
                     Series, Index)
diff --git a/pandas/tests/indexes/period/test_ops.py b/pandas/tests/indexes/period/test_ops.py
index 3b94992f2..50b2da380 100644
--- a/pandas/tests/indexes/period/test_ops.py
+++ b/pandas/tests/indexes/period/test_ops.py
@@ -4,7 +4,7 @@ from datetime import timedelta
 import pandas as pd
 import pandas._libs.tslib as tslib
 import pandas.util.testing as tm
-import pandas.tseries.period as period
+import pandas.core.indexes.period as period
 from pandas import (DatetimeIndex, PeriodIndex, period_range, Series, Period,
                     _np_version_under1p10, Index, Timedelta, offsets)
 
diff --git a/pandas/tests/indexes/period/test_setops.py b/pandas/tests/indexes/period/test_setops.py
index d4f06bae8..357eccccf 100644
--- a/pandas/tests/indexes/period/test_setops.py
+++ b/pandas/tests/indexes/period/test_setops.py
@@ -2,7 +2,7 @@ import numpy as np
 
 import pandas as pd
 import pandas.util.testing as tm
-import pandas.tseries.period as period
+import pandas.core.indexes.period as period
 from pandas import period_range, PeriodIndex, Index, date_range
 
 
diff --git a/pandas/tests/indexes/period/test_tools.py b/pandas/tests/indexes/period/test_tools.py
index f9a1df3d8..32fbf44bd 100644
--- a/pandas/tests/indexes/period/test_tools.py
+++ b/pandas/tests/indexes/period/test_tools.py
@@ -3,7 +3,7 @@ from datetime import datetime, timedelta
 
 import pandas as pd
 import pandas.util.testing as tm
-import pandas.tseries.period as period
+import pandas.core.indexes.period as period
 from pandas.compat import lrange
 from pandas.tseries.frequencies import get_freq, MONTHS
 from pandas._libs.period import period_ordinal, period_asfreq
diff --git a/pandas/tests/indexes/test_base.py b/pandas/tests/indexes/test_base.py
index de15abe89..c1b61bcd2 100644
--- a/pandas/tests/indexes/test_base.py
+++ b/pandas/tests/indexes/test_base.py
@@ -21,7 +21,7 @@ from pandas.compat.numpy import np_datetime64_compat
 
 import pandas.core.config as cf
 
-from pandas.tseries.index import _to_m8
+from pandas.core.indexes.datetimes import _to_m8
 
 import pandas as pd
 from pandas._libs.lib import Timestamp
diff --git a/pandas/tests/io/json/test_ujson.py b/pandas/tests/io/json/test_ujson.py
index dcfa939f8..545165be3 100644
--- a/pandas/tests/io/json/test_ujson.py
+++ b/pandas/tests/io/json/test_ujson.py
@@ -1452,7 +1452,7 @@ class PandasJSONTests(TestCase):
         tm.assert_index_equal(i, outp)
 
     def test_datetimeindex(self):
-        from pandas.tseries.index import date_range
+        from pandas.core.indexes.datetimes import date_range
 
         rng = date_range('1/1/2000', periods=20)
 
diff --git a/pandas/tests/io/parser/parse_dates.py b/pandas/tests/io/parser/parse_dates.py
index de4e3fbc0..8bb1d5ee3 100644
--- a/pandas/tests/io/parser/parse_dates.py
+++ b/pandas/tests/io/parser/parse_dates.py
@@ -15,7 +15,7 @@ from pandas._libs.lib import Timestamp
 
 import pandas as pd
 import pandas.io.parsers as parsers
-import pandas.tseries.tools as tools
+import pandas.core.tools.datetimes as tools
 import pandas.util.testing as tm
 
 import pandas.io.date_converters as conv
@@ -23,7 +23,7 @@ from pandas import DataFrame, Series, Index, DatetimeIndex, MultiIndex
 from pandas import compat
 from pandas.compat import parse_date, StringIO, lrange
 from pandas.compat.numpy import np_array_datetime64_compat
-from pandas.tseries.index import date_range
+from pandas.core.indexes.datetimes import date_range
 
 
 class ParseDatesTests(object):
diff --git a/pandas/tests/io/test_sql.py b/pandas/tests/io/test_sql.py
index ce411bb4d..b4c7f2ba8 100644
--- a/pandas/tests/io/test_sql.py
+++ b/pandas/tests/io/test_sql.py
@@ -38,7 +38,7 @@ from pandas import DataFrame, Series, Index, MultiIndex, isnull, concat
 from pandas import date_range, to_datetime, to_timedelta, Timestamp
 import pandas.compat as compat
 from pandas.compat import range, lrange, string_types, PY36
-from pandas.tseries.tools import format as date_format
+from pandas.core.tools.datetimes import format as date_format
 
 import pandas.io.sql as sql
 from pandas.io.sql import read_sql_table, read_sql_query
diff --git a/pandas/tests/plotting/test_datetimelike.py b/pandas/tests/plotting/test_datetimelike.py
index 4beb804ac..9946c3475 100644
--- a/pandas/tests/plotting/test_datetimelike.py
+++ b/pandas/tests/plotting/test_datetimelike.py
@@ -8,11 +8,11 @@ from pandas.compat import lrange, zip
 import numpy as np
 from pandas import Index, Series, DataFrame
 from pandas.compat import is_platform_mac
-from pandas.tseries.index import date_range, bdate_range
-from pandas.tseries.tdi import timedelta_range
+from pandas.core.indexes.datetimes import date_range, bdate_range
+from pandas.core.indexes.timedeltas import timedelta_range
 from pandas.tseries.offsets import DateOffset
-from pandas.tseries.period import period_range, Period, PeriodIndex
-from pandas.tseries.resample import DatetimeIndex
+from pandas.core.indexes.period import period_range, Period, PeriodIndex
+from pandas.core.resample import DatetimeIndex
 
 from pandas.util.testing import assert_series_equal, ensure_clean, slow
 import pandas.util.testing as tm
diff --git a/pandas/tests/reshape/test_concat.py b/pandas/tests/reshape/test_concat.py
index e6514a1e2..ed194cacb 100644
--- a/pandas/tests/reshape/test_concat.py
+++ b/pandas/tests/reshape/test_concat.py
@@ -1503,7 +1503,7 @@ class TestConcatenate(ConcatenateBase):
         self.assertRaises(ValueError, concat, [None, None])
 
     def test_concat_datetime64_block(self):
-        from pandas.tseries.index import date_range
+        from pandas.core.indexes.datetimes import date_range
 
         rng = date_range('1/1/2000', periods=10)
 
diff --git a/pandas/tests/scalar/test_period.py b/pandas/tests/scalar/test_period.py
index 98af00284..4c6784fb1 100644
--- a/pandas/tests/scalar/test_period.py
+++ b/pandas/tests/scalar/test_period.py
@@ -3,7 +3,7 @@ from datetime import datetime, date, timedelta
 
 import pandas as pd
 import pandas.util.testing as tm
-import pandas.tseries.period as period
+import pandas.core.indexes.period as period
 from pandas.compat import text_type, iteritems
 from pandas.compat.numpy import np_datetime64_compat
 
diff --git a/pandas/tests/scalar/test_timedelta.py b/pandas/tests/scalar/test_timedelta.py
index abdbf2900..227297709 100644
--- a/pandas/tests/scalar/test_timedelta.py
+++ b/pandas/tests/scalar/test_timedelta.py
@@ -4,7 +4,7 @@ from datetime import timedelta
 
 import pandas as pd
 import pandas.util.testing as tm
-from pandas.tseries.timedeltas import _coerce_scalar_to_timedelta_type as ct
+from pandas.core.tools.timedeltas import _coerce_scalar_to_timedelta_type as ct
 from pandas import (Timedelta, TimedeltaIndex, timedelta_range, Series,
                     to_timedelta, compat)
 from pandas._libs.tslib import iNaT, NaTType
diff --git a/pandas/tests/series/test_analytics.py b/pandas/tests/series/test_analytics.py
index a682e8643..671c04880 100644
--- a/pandas/tests/series/test_analytics.py
+++ b/pandas/tests/series/test_analytics.py
@@ -13,8 +13,8 @@ import pandas as pd
 from pandas import (Series, Categorical, DataFrame, isnull, notnull,
                     bdate_range, date_range, _np_version_under1p10)
 from pandas.core.index import MultiIndex
-from pandas.tseries.index import Timestamp
-from pandas.tseries.tdi import Timedelta
+from pandas.core.indexes.datetimes import Timestamp
+from pandas.core.indexes.timedeltas import Timedelta
 import pandas.core.config as cf
 
 import pandas.core.nanops as nanops
diff --git a/pandas/tests/series/test_api.py b/pandas/tests/series/test_api.py
index faf987c9b..25acd304e 100644
--- a/pandas/tests/series/test_api.py
+++ b/pandas/tests/series/test_api.py
@@ -5,7 +5,7 @@ import numpy as np
 import pandas as pd
 
 from pandas import Index, Series, DataFrame, date_range
-from pandas.tseries.index import Timestamp
+from pandas.core.indexes.datetimes import Timestamp
 
 from pandas.compat import range
 from pandas import compat
diff --git a/pandas/tests/series/test_combine_concat.py b/pandas/tests/series/test_combine_concat.py
index d4e5d36c1..15e7d97c7 100644
--- a/pandas/tests/series/test_combine_concat.py
+++ b/pandas/tests/series/test_combine_concat.py
@@ -204,7 +204,7 @@ class TestSeriesCombine(TestData, tm.TestCase):
         self.assertEqual(result.ftype, 'object:dense')
 
     def test_combine_first_dt64(self):
-        from pandas.tseries.tools import to_datetime
+        from pandas.core.tools.datetimes import to_datetime
         s0 = to_datetime(Series(["2010", np.NaN]))
         s1 = to_datetime(Series([np.NaN, "2011"]))
         rs = s0.combine_first(s1)
diff --git a/pandas/tests/series/test_constructors.py b/pandas/tests/series/test_constructors.py
index 24b2a12d7..6b16c607e 100644
--- a/pandas/tests/series/test_constructors.py
+++ b/pandas/tests/series/test_constructors.py
@@ -13,7 +13,7 @@ from pandas.core.dtypes.common import (
     is_datetime64tz_dtype)
 from pandas import (Index, Series, isnull, date_range,
                     NaT, period_range, MultiIndex, IntervalIndex)
-from pandas.tseries.index import Timestamp, DatetimeIndex
+from pandas.core.indexes.datetimes import Timestamp, DatetimeIndex
 
 from pandas._libs import lib
 from pandas._libs.tslib import iNaT
diff --git a/pandas/tests/series/test_datetime_values.py b/pandas/tests/series/test_datetime_values.py
index 8825ba560..a984f578b 100644
--- a/pandas/tests/series/test_datetime_values.py
+++ b/pandas/tests/series/test_datetime_values.py
@@ -364,8 +364,8 @@ class TestSeriesDatetimeValues(TestData, tm.TestCase):
 
     def test_dt_accessor_api(self):
         # GH 9322
-        from pandas.tseries.common import (CombinedDatetimelikeProperties,
-                                           DatetimeProperties)
+        from pandas.core.indexes.accessors import (
+            CombinedDatetimelikeProperties, DatetimeProperties)
         self.assertIs(Series.dt, CombinedDatetimelikeProperties)
 
         s = Series(date_range('2000-01-01', periods=3))
@@ -379,7 +379,7 @@ class TestSeriesDatetimeValues(TestData, tm.TestCase):
             self.assertFalse(hasattr(s, 'dt'))
 
     def test_sub_of_datetime_from_TimeSeries(self):
-        from pandas.tseries.timedeltas import to_timedelta
+        from pandas.core.tools.timedeltas import to_timedelta
         from datetime import datetime
         a = Timestamp(datetime(1993, 0o1, 0o7, 13, 30, 00))
         b = datetime(1993, 6, 22, 13, 30)
diff --git a/pandas/tests/series/test_internals.py b/pandas/tests/series/test_internals.py
index 4b1c30320..9ca7645e6 100644
--- a/pandas/tests/series/test_internals.py
+++ b/pandas/tests/series/test_internals.py
@@ -7,7 +7,7 @@ from numpy import nan
 import numpy as np
 
 from pandas import Series
-from pandas.tseries.index import Timestamp
+from pandas.core.indexes.datetimes import Timestamp
 import pandas._libs.lib as lib
 
 from pandas.util.testing import assert_series_equal
diff --git a/pandas/tests/series/test_operators.py b/pandas/tests/series/test_operators.py
index 3d609dec7..2e1ae7b81 100644
--- a/pandas/tests/series/test_operators.py
+++ b/pandas/tests/series/test_operators.py
@@ -13,8 +13,8 @@ import pandas as pd
 from pandas import (Index, Series, DataFrame, isnull, bdate_range,
                     NaT, date_range, timedelta_range,
                     _np_version_under1p8)
-from pandas.tseries.index import Timestamp
-from pandas.tseries.tdi import Timedelta
+from pandas.core.indexes.datetimes import Timestamp
+from pandas.core.indexes.timedeltas import Timedelta
 import pandas.core.nanops as nanops
 
 from pandas.compat import range, zip
diff --git a/pandas/tests/series/test_period.py b/pandas/tests/series/test_period.py
index f1ae77656..354010a5d 100644
--- a/pandas/tests/series/test_period.py
+++ b/pandas/tests/series/test_period.py
@@ -2,7 +2,7 @@ import numpy as np
 
 import pandas as pd
 import pandas.util.testing as tm
-import pandas.tseries.period as period
+import pandas.core.indexes.period as period
 from pandas import Series, period_range, DataFrame, Period
 
 
diff --git a/pandas/tests/series/test_quantile.py b/pandas/tests/series/test_quantile.py
index 339d871b6..e61297bdc 100644
--- a/pandas/tests/series/test_quantile.py
+++ b/pandas/tests/series/test_quantile.py
@@ -6,7 +6,7 @@ import numpy as np
 import pandas as pd
 
 from pandas import (Index, Series, _np_version_under1p9)
-from pandas.tseries.index import Timestamp
+from pandas.core.indexes.datetimes import Timestamp
 from pandas.core.dtypes.common import is_integer
 import pandas.util.testing as tm
 
diff --git a/pandas/tests/series/test_timeseries.py b/pandas/tests/series/test_timeseries.py
index 0f960a890..0322933e9 100644
--- a/pandas/tests/series/test_timeseries.py
+++ b/pandas/tests/series/test_timeseries.py
@@ -8,8 +8,8 @@ import pandas as pd
 import pandas.util.testing as tm
 from pandas._libs.tslib import iNaT
 from pandas.compat import lrange, StringIO, product
-from pandas.tseries.tdi import TimedeltaIndex
-from pandas.tseries.index import DatetimeIndex
+from pandas.core.indexes.timedeltas import TimedeltaIndex
+from pandas.core.indexes.datetimes import DatetimeIndex
 from pandas.tseries.offsets import BDay, BMonthEnd
 from pandas import (Index, Series, date_range, NaT, concat, DataFrame,
                     Timestamp, to_datetime, offsets,
@@ -739,7 +739,7 @@ class TestTimeSeries(TestData, tm.TestCase):
                              "%s - %s" % time_string)
 
     def test_to_period(self):
-        from pandas.tseries.period import period_range
+        from pandas.core.indexes.period import period_range
 
         ts = _simple_ts('1/1/2000', '1/1/2001')
 
diff --git a/pandas/tests/sparse/test_frame.py b/pandas/tests/sparse/test_frame.py
index 0a5871312..6ee8dacf1 100644
--- a/pandas/tests/sparse/test_frame.py
+++ b/pandas/tests/sparse/test_frame.py
@@ -14,7 +14,7 @@ from pandas.core.dtypes.common import (
     is_float_dtype,
     is_object_dtype,
     is_float)
-from pandas.tseries.index import DatetimeIndex
+from pandas.core.indexes.datetimes import DatetimeIndex
 from pandas.tseries.offsets import BDay
 from pandas.util import testing as tm
 from pandas.compat import lrange
diff --git a/pandas/tests/test_base.py b/pandas/tests/test_base.py
index 148f2ae42..6321dcce7 100644
--- a/pandas/tests/test_base.py
+++ b/pandas/tests/test_base.py
@@ -18,7 +18,7 @@ from pandas import (Series, Index, DatetimeIndex, TimedeltaIndex, PeriodIndex,
 from pandas.compat import StringIO
 from pandas.compat.numpy import np_array_datetime64_compat
 from pandas.core.base import PandasDelegate, NoNewAttributesMixin
-from pandas.tseries.base import DatetimeIndexOpsMixin
+from pandas.core.indexes.datetimelike import DatetimeIndexOpsMixin
 from pandas._libs.tslib import iNaT
 
 
diff --git a/pandas/tests/test_categorical.py b/pandas/tests/test_categorical.py
index 17f55b419..0594cc987 100644
--- a/pandas/tests/test_categorical.py
+++ b/pandas/tests/test_categorical.py
@@ -4312,7 +4312,7 @@ Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01
 
     def test_dt_accessor_api_for_categorical(self):
         # https://github.com/pandas-dev/pandas/issues/10661
-        from pandas.tseries.common import Properties
+        from pandas.core.indexes.accessors import Properties
 
         s_dr = Series(date_range('1/1/2015', periods=5, tz="MET"))
         c_dr = s_dr.astype("category")
diff --git a/pandas/tests/tseries/test_resample.py b/pandas/tests/test_resample.py
old mode 100755
new mode 100644
similarity index 99%
rename from pandas/tests/tseries/test_resample.py
rename to pandas/tests/test_resample.py
index e81dfd864..a39242c9d
--- a/pandas/tests/tseries/test_resample.py
+++ b/pandas/tests/test_resample.py
@@ -19,12 +19,12 @@ from pandas.errors import UnsupportedFunctionCall
 from pandas.core.groupby import DataError
 from pandas.tseries.frequencies import MONTHS, DAYS
 from pandas.tseries.frequencies import to_offset
-from pandas.tseries.index import date_range
+from pandas.core.indexes.datetimes import date_range
 from pandas.tseries.offsets import Minute, BDay
-from pandas.tseries.period import period_range, PeriodIndex, Period
-from pandas.tseries.resample import (DatetimeIndex, TimeGrouper,
-                                     DatetimeIndexResampler)
-from pandas.tseries.tdi import timedelta_range, TimedeltaIndex
+from pandas.core.indexes.period import period_range, PeriodIndex, Period
+from pandas.core.resample import (DatetimeIndex, TimeGrouper,
+                                  DatetimeIndexResampler)
+from pandas.core.indexes.timedeltas import timedelta_range, TimedeltaIndex
 from pandas.util.testing import (assert_series_equal, assert_almost_equal,
                                  assert_frame_equal, assert_index_equal)
 from pandas._libs.period import IncompatibleFrequency
diff --git a/pandas/tests/tools/__init__.py b/pandas/tests/tools/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/tests/tools/test_numeric.py b/pandas/tests/tools/test_numeric.py
new file mode 100644
index 000000000..96b49c5fb
--- /dev/null
+++ b/pandas/tests/tools/test_numeric.py
@@ -0,0 +1,371 @@
+import pytest
+import decimal
+
+import numpy as np
+import pandas as pd
+from pandas import to_numeric, _np_version_under1p9
+
+from pandas.util import testing as tm
+from numpy import iinfo
+
+
+class TestToNumeric(tm.TestCase):
+
+    def test_series(self):
+        s = pd.Series(['1', '-3.14', '7'])
+        res = to_numeric(s)
+        expected = pd.Series([1, -3.14, 7])
+        tm.assert_series_equal(res, expected)
+
+        s = pd.Series(['1', '-3.14', 7])
+        res = to_numeric(s)
+        tm.assert_series_equal(res, expected)
+
+    def test_series_numeric(self):
+        s = pd.Series([1, 3, 4, 5], index=list('ABCD'), name='XXX')
+        res = to_numeric(s)
+        tm.assert_series_equal(res, s)
+
+        s = pd.Series([1., 3., 4., 5.], index=list('ABCD'), name='XXX')
+        res = to_numeric(s)
+        tm.assert_series_equal(res, s)
+
+        # bool is regarded as numeric
+        s = pd.Series([True, False, True, True],
+                      index=list('ABCD'), name='XXX')
+        res = to_numeric(s)
+        tm.assert_series_equal(res, s)
+
+    def test_error(self):
+        s = pd.Series([1, -3.14, 'apple'])
+        msg = 'Unable to parse string "apple" at position 2'
+        with tm.assertRaisesRegexp(ValueError, msg):
+            to_numeric(s, errors='raise')
+
+        res = to_numeric(s, errors='ignore')
+        expected = pd.Series([1, -3.14, 'apple'])
+        tm.assert_series_equal(res, expected)
+
+        res = to_numeric(s, errors='coerce')
+        expected = pd.Series([1, -3.14, np.nan])
+        tm.assert_series_equal(res, expected)
+
+        s = pd.Series(['orange', 1, -3.14, 'apple'])
+        msg = 'Unable to parse string "orange" at position 0'
+        with tm.assertRaisesRegexp(ValueError, msg):
+            to_numeric(s, errors='raise')
+
+    def test_error_seen_bool(self):
+        s = pd.Series([True, False, 'apple'])
+        msg = 'Unable to parse string "apple" at position 2'
+        with tm.assertRaisesRegexp(ValueError, msg):
+            to_numeric(s, errors='raise')
+
+        res = to_numeric(s, errors='ignore')
+        expected = pd.Series([True, False, 'apple'])
+        tm.assert_series_equal(res, expected)
+
+        # coerces to float
+        res = to_numeric(s, errors='coerce')
+        expected = pd.Series([1., 0., np.nan])
+        tm.assert_series_equal(res, expected)
+
+    def test_list(self):
+        s = ['1', '-3.14', '7']
+        res = to_numeric(s)
+        expected = np.array([1, -3.14, 7])
+        tm.assert_numpy_array_equal(res, expected)
+
+    def test_list_numeric(self):
+        s = [1, 3, 4, 5]
+        res = to_numeric(s)
+        tm.assert_numpy_array_equal(res, np.array(s, dtype=np.int64))
+
+        s = [1., 3., 4., 5.]
+        res = to_numeric(s)
+        tm.assert_numpy_array_equal(res, np.array(s))
+
+        # bool is regarded as numeric
+        s = [True, False, True, True]
+        res = to_numeric(s)
+        tm.assert_numpy_array_equal(res, np.array(s))
+
+    def test_numeric(self):
+        s = pd.Series([1, -3.14, 7], dtype='O')
+        res = to_numeric(s)
+        expected = pd.Series([1, -3.14, 7])
+        tm.assert_series_equal(res, expected)
+
+        s = pd.Series([1, -3.14, 7])
+        res = to_numeric(s)
+        tm.assert_series_equal(res, expected)
+
+        # GH 14827
+        df = pd.DataFrame(dict(
+            a=[1.2, decimal.Decimal(3.14), decimal.Decimal("infinity"), '0.1'],
+            b=[1.0, 2.0, 3.0, 4.0],
+        ))
+        expected = pd.DataFrame(dict(
+            a=[1.2, 3.14, np.inf, 0.1],
+            b=[1.0, 2.0, 3.0, 4.0],
+        ))
+
+        # Test to_numeric over one column
+        df_copy = df.copy()
+        df_copy['a'] = df_copy['a'].apply(to_numeric)
+        tm.assert_frame_equal(df_copy, expected)
+
+        # Test to_numeric over multiple columns
+        df_copy = df.copy()
+        df_copy[['a', 'b']] = df_copy[['a', 'b']].apply(to_numeric)
+        tm.assert_frame_equal(df_copy, expected)
+
+    def test_numeric_lists_and_arrays(self):
+        # Test to_numeric with embedded lists and arrays
+        df = pd.DataFrame(dict(
+            a=[[decimal.Decimal(3.14), 1.0], decimal.Decimal(1.6), 0.1]
+        ))
+        df['a'] = df['a'].apply(to_numeric)
+        expected = pd.DataFrame(dict(
+            a=[[3.14, 1.0], 1.6, 0.1],
+        ))
+        tm.assert_frame_equal(df, expected)
+
+        df = pd.DataFrame(dict(
+            a=[np.array([decimal.Decimal(3.14), 1.0]), 0.1]
+        ))
+        df['a'] = df['a'].apply(to_numeric)
+        expected = pd.DataFrame(dict(
+            a=[[3.14, 1.0], 0.1],
+        ))
+        tm.assert_frame_equal(df, expected)
+
+    def test_all_nan(self):
+        s = pd.Series(['a', 'b', 'c'])
+        res = to_numeric(s, errors='coerce')
+        expected = pd.Series([np.nan, np.nan, np.nan])
+        tm.assert_series_equal(res, expected)
+
+    def test_type_check(self):
+        # GH 11776
+        df = pd.DataFrame({'a': [1, -3.14, 7], 'b': ['4', '5', '6']})
+        with tm.assertRaisesRegexp(TypeError, "1-d array"):
+            to_numeric(df)
+        for errors in ['ignore', 'raise', 'coerce']:
+            with tm.assertRaisesRegexp(TypeError, "1-d array"):
+                to_numeric(df, errors=errors)
+
+    def test_scalar(self):
+        self.assertEqual(pd.to_numeric(1), 1)
+        self.assertEqual(pd.to_numeric(1.1), 1.1)
+
+        self.assertEqual(pd.to_numeric('1'), 1)
+        self.assertEqual(pd.to_numeric('1.1'), 1.1)
+
+        with tm.assertRaises(ValueError):
+            to_numeric('XX', errors='raise')
+
+        self.assertEqual(to_numeric('XX', errors='ignore'), 'XX')
+        self.assertTrue(np.isnan(to_numeric('XX', errors='coerce')))
+
+    def test_numeric_dtypes(self):
+        idx = pd.Index([1, 2, 3], name='xxx')
+        res = pd.to_numeric(idx)
+        tm.assert_index_equal(res, idx)
+
+        res = pd.to_numeric(pd.Series(idx, name='xxx'))
+        tm.assert_series_equal(res, pd.Series(idx, name='xxx'))
+
+        res = pd.to_numeric(idx.values)
+        tm.assert_numpy_array_equal(res, idx.values)
+
+        idx = pd.Index([1., np.nan, 3., np.nan], name='xxx')
+        res = pd.to_numeric(idx)
+        tm.assert_index_equal(res, idx)
+
+        res = pd.to_numeric(pd.Series(idx, name='xxx'))
+        tm.assert_series_equal(res, pd.Series(idx, name='xxx'))
+
+        res = pd.to_numeric(idx.values)
+        tm.assert_numpy_array_equal(res, idx.values)
+
+    def test_str(self):
+        idx = pd.Index(['1', '2', '3'], name='xxx')
+        exp = np.array([1, 2, 3], dtype='int64')
+        res = pd.to_numeric(idx)
+        tm.assert_index_equal(res, pd.Index(exp, name='xxx'))
+
+        res = pd.to_numeric(pd.Series(idx, name='xxx'))
+        tm.assert_series_equal(res, pd.Series(exp, name='xxx'))
+
+        res = pd.to_numeric(idx.values)
+        tm.assert_numpy_array_equal(res, exp)
+
+        idx = pd.Index(['1.5', '2.7', '3.4'], name='xxx')
+        exp = np.array([1.5, 2.7, 3.4])
+        res = pd.to_numeric(idx)
+        tm.assert_index_equal(res, pd.Index(exp, name='xxx'))
+
+        res = pd.to_numeric(pd.Series(idx, name='xxx'))
+        tm.assert_series_equal(res, pd.Series(exp, name='xxx'))
+
+        res = pd.to_numeric(idx.values)
+        tm.assert_numpy_array_equal(res, exp)
+
+    def test_datetimelike(self):
+        for tz in [None, 'US/Eastern', 'Asia/Tokyo']:
+            idx = pd.date_range('20130101', periods=3, tz=tz, name='xxx')
+            res = pd.to_numeric(idx)
+            tm.assert_index_equal(res, pd.Index(idx.asi8, name='xxx'))
+
+            res = pd.to_numeric(pd.Series(idx, name='xxx'))
+            tm.assert_series_equal(res, pd.Series(idx.asi8, name='xxx'))
+
+            res = pd.to_numeric(idx.values)
+            tm.assert_numpy_array_equal(res, idx.asi8)
+
+    def test_timedelta(self):
+        idx = pd.timedelta_range('1 days', periods=3, freq='D', name='xxx')
+        res = pd.to_numeric(idx)
+        tm.assert_index_equal(res, pd.Index(idx.asi8, name='xxx'))
+
+        res = pd.to_numeric(pd.Series(idx, name='xxx'))
+        tm.assert_series_equal(res, pd.Series(idx.asi8, name='xxx'))
+
+        res = pd.to_numeric(idx.values)
+        tm.assert_numpy_array_equal(res, idx.asi8)
+
+    def test_period(self):
+        idx = pd.period_range('2011-01', periods=3, freq='M', name='xxx')
+        res = pd.to_numeric(idx)
+        tm.assert_index_equal(res, pd.Index(idx.asi8, name='xxx'))
+
+        # ToDo: enable when we can support native PeriodDtype
+        # res = pd.to_numeric(pd.Series(idx, name='xxx'))
+        # tm.assert_series_equal(res, pd.Series(idx.asi8, name='xxx'))
+
+    def test_non_hashable(self):
+        # Test for Bug #13324
+        s = pd.Series([[10.0, 2], 1.0, 'apple'])
+        res = pd.to_numeric(s, errors='coerce')
+        tm.assert_series_equal(res, pd.Series([np.nan, 1.0, np.nan]))
+
+        res = pd.to_numeric(s, errors='ignore')
+        tm.assert_series_equal(res, pd.Series([[10.0, 2], 1.0, 'apple']))
+
+        with self.assertRaisesRegexp(TypeError, "Invalid object type"):
+            pd.to_numeric(s)
+
+    def test_downcast(self):
+        # see gh-13352
+        mixed_data = ['1', 2, 3]
+        int_data = [1, 2, 3]
+        date_data = np.array(['1970-01-02', '1970-01-03',
+                              '1970-01-04'], dtype='datetime64[D]')
+
+        invalid_downcast = 'unsigned-integer'
+        msg = 'invalid downcasting method provided'
+
+        smallest_int_dtype = np.dtype(np.typecodes['Integer'][0])
+        smallest_uint_dtype = np.dtype(np.typecodes['UnsignedInteger'][0])
+
+        # support below np.float32 is rare and far between
+        float_32_char = np.dtype(np.float32).char
+        smallest_float_dtype = float_32_char
+
+        for data in (mixed_data, int_data, date_data):
+            with self.assertRaisesRegexp(ValueError, msg):
+                pd.to_numeric(data, downcast=invalid_downcast)
+
+            expected = np.array([1, 2, 3], dtype=np.int64)
+
+            res = pd.to_numeric(data)
+            tm.assert_numpy_array_equal(res, expected)
+
+            res = pd.to_numeric(data, downcast=None)
+            tm.assert_numpy_array_equal(res, expected)
+
+            expected = np.array([1, 2, 3], dtype=smallest_int_dtype)
+
+            for signed_downcast in ('integer', 'signed'):
+                res = pd.to_numeric(data, downcast=signed_downcast)
+                tm.assert_numpy_array_equal(res, expected)
+
+            expected = np.array([1, 2, 3], dtype=smallest_uint_dtype)
+            res = pd.to_numeric(data, downcast='unsigned')
+            tm.assert_numpy_array_equal(res, expected)
+
+            expected = np.array([1, 2, 3], dtype=smallest_float_dtype)
+            res = pd.to_numeric(data, downcast='float')
+            tm.assert_numpy_array_equal(res, expected)
+
+        # if we can't successfully cast the given
+        # data to a numeric dtype, do not bother
+        # with the downcast parameter
+        data = ['foo', 2, 3]
+        expected = np.array(data, dtype=object)
+        res = pd.to_numeric(data, errors='ignore',
+                            downcast='unsigned')
+        tm.assert_numpy_array_equal(res, expected)
+
+        # cannot cast to an unsigned integer because
+        # we have a negative number
+        data = ['-1', 2, 3]
+        expected = np.array([-1, 2, 3], dtype=np.int64)
+        res = pd.to_numeric(data, downcast='unsigned')
+        tm.assert_numpy_array_equal(res, expected)
+
+        # cannot cast to an integer (signed or unsigned)
+        # because we have a float number
+        data = (['1.1', 2, 3],
+                [10000.0, 20000, 3000, 40000.36, 50000, 50000.00])
+        expected = (np.array([1.1, 2, 3], dtype=np.float64),
+                    np.array([10000.0, 20000, 3000,
+                              40000.36, 50000, 50000.00], dtype=np.float64))
+
+        for _data, _expected in zip(data, expected):
+            for downcast in ('integer', 'signed', 'unsigned'):
+                res = pd.to_numeric(_data, downcast=downcast)
+                tm.assert_numpy_array_equal(res, _expected)
+
+        # the smallest integer dtype need not be np.(u)int8
+        data = ['256', 257, 258]
+
+        for downcast, expected_dtype in zip(
+                ['integer', 'signed', 'unsigned'],
+                [np.int16, np.int16, np.uint16]):
+            expected = np.array([256, 257, 258], dtype=expected_dtype)
+            res = pd.to_numeric(data, downcast=downcast)
+            tm.assert_numpy_array_equal(res, expected)
+
+    def test_downcast_limits(self):
+        # Test the limits of each downcast. Bug: #14401.
+        # Check to make sure numpy is new enough to run this test.
+        if _np_version_under1p9:
+            pytest.skip("Numpy version is under 1.9")
+
+        i = 'integer'
+        u = 'unsigned'
+        dtype_downcast_min_max = [
+            ('int8', i, [iinfo(np.int8).min, iinfo(np.int8).max]),
+            ('int16', i, [iinfo(np.int16).min, iinfo(np.int16).max]),
+            ('int32', i, [iinfo(np.int32).min, iinfo(np.int32).max]),
+            ('int64', i, [iinfo(np.int64).min, iinfo(np.int64).max]),
+            ('uint8', u, [iinfo(np.uint8).min, iinfo(np.uint8).max]),
+            ('uint16', u, [iinfo(np.uint16).min, iinfo(np.uint16).max]),
+            ('uint32', u, [iinfo(np.uint32).min, iinfo(np.uint32).max]),
+            ('uint64', u, [iinfo(np.uint64).min, iinfo(np.uint64).max]),
+            ('int16', i, [iinfo(np.int8).min, iinfo(np.int8).max + 1]),
+            ('int32', i, [iinfo(np.int16).min, iinfo(np.int16).max + 1]),
+            ('int64', i, [iinfo(np.int32).min, iinfo(np.int32).max + 1]),
+            ('int16', i, [iinfo(np.int8).min - 1, iinfo(np.int16).max]),
+            ('int32', i, [iinfo(np.int16).min - 1, iinfo(np.int32).max]),
+            ('int64', i, [iinfo(np.int32).min - 1, iinfo(np.int64).max]),
+            ('uint16', u, [iinfo(np.uint8).min, iinfo(np.uint8).max + 1]),
+            ('uint32', u, [iinfo(np.uint16).min, iinfo(np.uint16).max + 1]),
+            ('uint64', u, [iinfo(np.uint32).min, iinfo(np.uint32).max + 1])
+        ]
+
+        for dtype, downcast, min_max in dtype_downcast_min_max:
+            series = pd.to_numeric(pd.Series(min_max), downcast=downcast)
+            assert series.dtype == dtype
diff --git a/pandas/tests/tseries/test_frequencies.py b/pandas/tests/tseries/test_frequencies.py
index 5fbef465c..327dad6d4 100644
--- a/pandas/tests/tseries/test_frequencies.py
+++ b/pandas/tests/tseries/test_frequencies.py
@@ -7,10 +7,10 @@ from pandas import (Index, DatetimeIndex, Timestamp, Series,
                     date_range, period_range)
 
 import pandas.tseries.frequencies as frequencies
-from pandas.tseries.tools import to_datetime
+from pandas.core.tools.datetimes import to_datetime
 
 import pandas.tseries.offsets as offsets
-from pandas.tseries.period import PeriodIndex
+from pandas.core.indexes.period import PeriodIndex
 import pandas.compat as compat
 from pandas.compat import is_platform_windows
 
diff --git a/pandas/tests/tseries/test_offsets.py b/pandas/tests/tseries/test_offsets.py
index 2dc248555..b0c84cf55 100644
--- a/pandas/tests/tseries/test_offsets.py
+++ b/pandas/tests/tseries/test_offsets.py
@@ -15,7 +15,8 @@ from pandas.core.series import Series
 from pandas.tseries.frequencies import (_offset_map, get_freq_code,
                                         _get_freq_str, _INVALID_FREQ_ERROR,
                                         get_offset, get_standard_freq)
-from pandas.tseries.index import _to_m8, DatetimeIndex, _daterange_cache
+from pandas.core.indexes.datetimes import (
+    _to_m8, DatetimeIndex, _daterange_cache)
 from pandas.tseries.offsets import (BDay, CDay, BQuarterEnd, BMonthEnd,
                                     BusinessHour, WeekOfMonth, CBMonthEnd,
                                     CustomBusinessHour, WeekDay,
@@ -27,8 +28,9 @@ from pandas.tseries.offsets import (BDay, CDay, BQuarterEnd, BMonthEnd,
                                     QuarterEnd, BusinessMonthEnd, FY5253,
                                     Milli, Nano, Easter, FY5253Quarter,
                                     LastWeekOfMonth, CacheableOffset)
-from pandas.tseries.tools import (format, ole2datetime, parse_time_string,
-                                  to_datetime, DateParseError)
+from pandas.core.tools.datetimes import (
+    format, ole2datetime, parse_time_string,
+    to_datetime, DateParseError)
 import pandas.tseries.offsets as offsets
 from pandas.io.pickle import read_pickle
 from pandas._libs.tslib import normalize_date, NaT, Timestamp, Timedelta
diff --git a/pandas/tests/tseries/test_timezones.py b/pandas/tests/tseries/test_timezones.py
index 125e031b5..06b6bbbcb 100644
--- a/pandas/tests/tseries/test_timezones.py
+++ b/pandas/tests/tseries/test_timezones.py
@@ -7,10 +7,10 @@ from datetime import datetime, timedelta, tzinfo, date
 from pytz import NonExistentTimeError
 
 import pandas.util.testing as tm
-import pandas.tseries.tools as tools
+import pandas.core.tools.datetimes as tools
 import pandas.tseries.offsets as offsets
 from pandas.compat import lrange, zip
-from pandas.tseries.index import bdate_range, date_range
+from pandas.core.indexes.datetimes import bdate_range, date_range
 from pandas.core.dtypes.dtypes import DatetimeTZDtype
 from pandas._libs import tslib
 from pandas import (Index, Series, DataFrame, isnull, Timestamp, NaT,
diff --git a/pandas/tseries/api.py b/pandas/tseries/api.py
index a00ccf99e..71386c025 100644
--- a/pandas/tseries/api.py
+++ b/pandas/tseries/api.py
@@ -4,11 +4,5 @@
 
 # flake8: noqa
 
-from pandas.tseries.index import DatetimeIndex, date_range, bdate_range
 from pandas.tseries.frequencies import infer_freq
-from pandas.tseries.tdi import Timedelta, TimedeltaIndex, timedelta_range
-from pandas.tseries.period import Period, PeriodIndex, period_range, pnow
-from pandas.tseries.resample import TimeGrouper
-from pandas.tseries.timedeltas import to_timedelta
-from pandas._libs.lib import NaT
 import pandas.tseries.offsets as offsets
diff --git a/pandas/tseries/offsets.py b/pandas/tseries/offsets.py
index a097c56a0..f9f4adc1b 100644
--- a/pandas/tseries/offsets.py
+++ b/pandas/tseries/offsets.py
@@ -4,7 +4,7 @@ from pandas import compat
 import numpy as np
 
 from pandas.core.dtypes.generic import ABCSeries, ABCDatetimeIndex, ABCPeriod
-from pandas.tseries.tools import to_datetime, normalize_date
+from pandas.core.tools.datetimes import to_datetime, normalize_date
 from pandas.core.common import AbstractMethodError
 
 # import after tools, dateutil check
diff --git a/setup.py b/setup.py
index 69b9a974b..830968768 100755
--- a/setup.py
+++ b/setup.py
@@ -644,6 +644,7 @@ setup(name=DISTNAME,
                 'pandas.core.computation',
                 'pandas.core.reshape',
                 'pandas.core.sparse',
+                'pandas.core.tools',
                 'pandas.errors',
                 'pandas.io',
                 'pandas.io.json',
@@ -675,6 +676,7 @@ setup(name=DISTNAME,
                 'pandas.tests.scalar',
                 'pandas.tests.tseries',
                 'pandas.tests.plotting',
+                'pandas.tests.tools',
                 'pandas.tools',
                 'pandas.tseries',
                 'pandas.util.clipboard'

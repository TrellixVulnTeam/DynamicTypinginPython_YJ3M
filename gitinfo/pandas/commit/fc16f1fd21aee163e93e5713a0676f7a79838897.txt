commit fc16f1fd21aee163e93e5713a0676f7a79838897
Author: Joris Van den Bossche <jorisvandenbossche@gmail.com>
Date:   Thu Jul 21 13:06:59 2016 +0200

    CLN: remove deprecated io.sql uquery and tquery functions (#13616)
    
    * CLN: remove deprecated io.sql uquery and tquery functions
    
    * linter -> remove ununsed imports

diff --git a/doc/source/whatsnew/v0.19.0.txt b/doc/source/whatsnew/v0.19.0.txt
index eb22cbd7d..0d8c658a0 100644
--- a/doc/source/whatsnew/v0.19.0.txt
+++ b/doc/source/whatsnew/v0.19.0.txt
@@ -622,6 +622,9 @@ Removal of prior version deprecations/changes
 
   Now legacy time rules raises ``ValueError``. For the list of currently supported offsets, see :ref:`here <timeseries.alias>`
 
+- The ``tquery`` and ``uquery`` functions in the ``pandas.io.sql`` module are removed (:issue:`5950`).
+
+
 .. _whatsnew_0190.performance:
 
 Performance Improvements
diff --git a/pandas/io/sql.py b/pandas/io/sql.py
index b9eaa0e4d..dfc9e80aa 100644
--- a/pandas/io/sql.py
+++ b/pandas/io/sql.py
@@ -8,7 +8,6 @@ from __future__ import print_function, division
 from datetime import datetime, date, time
 
 import warnings
-import traceback
 import re
 import numpy as np
 
@@ -18,7 +17,7 @@ from pandas.types.dtypes import DatetimeTZDtype
 from pandas.types.common import (is_list_like,
                                  is_datetime64tz_dtype)
 
-from pandas.compat import (lzip, map, zip, raise_with_traceback,
+from pandas.compat import (map, zip, raise_with_traceback,
                            string_types, text_type)
 from pandas.core.api import DataFrame, Series
 from pandas.core.base import PandasObject
@@ -192,125 +191,6 @@ def execute(sql, con, cur=None, params=None):
     return pandas_sql.execute(*args)
 
 
-# -----------------------------------------------------------------------------
-# -- Deprecated tquery and uquery
-
-def _safe_fetch(cur):
-    try:
-        result = cur.fetchall()
-        if not isinstance(result, list):
-            result = list(result)
-        return result
-    except Exception as e:  # pragma: no cover
-        excName = e.__class__.__name__
-        if excName == 'OperationalError':
-            return []
-
-
-def tquery(sql, con=None, cur=None, retry=True):
-    """
-    DEPRECATED. Returns list of tuples corresponding to each row in given sql
-    query.
-
-    If only one column selected, then plain list is returned.
-
-    To obtain the same result in the future, you can use the following:
-
-    >>> execute(sql, con, params).fetchall()
-
-    Parameters
-    ----------
-    sql: string
-        SQL query to be executed
-    con: DBAPI2 connection, default: None
-    cur: deprecated, cursor is obtained from connection, default: None
-    retry: boolean value to specify whether to retry after failure
-        default: True
-
-    Returns
-    -------
-    Results Iterable
-
-    """
-    warnings.warn(
-        "tquery is deprecated, and will be removed in future versions. "
-        "You can use ``execute(...).fetchall()`` instead.",
-        FutureWarning, stacklevel=2)
-
-    cur = execute(sql, con, cur=cur)
-    result = _safe_fetch(cur)
-
-    if con is not None:
-        try:
-            cur.close()
-            con.commit()
-        except Exception as e:
-            excName = e.__class__.__name__
-            if excName == 'OperationalError':  # pragma: no cover
-                print('Failed to commit, may need to restart interpreter')
-            else:
-                raise
-
-            traceback.print_exc()
-            if retry:
-                return tquery(sql, con=con, retry=False)
-
-    if result and len(result[0]) == 1:
-        # python 3 compat
-        result = list(lzip(*result)[0])
-    elif result is None:  # pragma: no cover
-        result = []
-
-    return result
-
-
-def uquery(sql, con=None, cur=None, retry=True, params=None):
-    """
-    DEPRECATED. Does the same thing as tquery, but instead of returning
-    results, it returns the number of rows affected.  Good for update queries.
-
-    To obtain the same result in the future, you can use the following:
-
-    >>> execute(sql, con).rowcount
-
-    Parameters
-    ----------
-    sql: string
-        SQL query to be executed
-    con: DBAPI2 connection, default: None
-    cur: deprecated, cursor is obtained from connection, default: None
-    retry: boolean value to specify whether to retry after failure
-        default: True
-    params: list or tuple, optional, default: None
-        List of parameters to pass to execute method.
-
-    Returns
-    -------
-    Number of affected rows
-
-    """
-    warnings.warn(
-        "uquery is deprecated, and will be removed in future versions. "
-        "You can use ``execute(...).rowcount`` instead.",
-        FutureWarning, stacklevel=2)
-
-    cur = execute(sql, con, cur=cur, params=params)
-
-    result = cur.rowcount
-    try:
-        con.commit()
-    except Exception as e:
-        excName = e.__class__.__name__
-        if excName != 'OperationalError':
-            raise
-
-        traceback.print_exc()
-        if retry:
-            print('Looks like your connection failed, reconnecting...')
-            return uquery(sql, con, retry=False)
-    return result
-
-
 # -----------------------------------------------------------------------------
 # -- Read and write to DataFrames
 
diff --git a/pandas/io/tests/test_sql.py b/pandas/io/tests/test_sql.py
index 41be39f9a..f4001420a 100644
--- a/pandas/io/tests/test_sql.py
+++ b/pandas/io/tests/test_sql.py
@@ -1070,17 +1070,6 @@ class TestSQLiteFallbackApi(SQLiteMixIn, _TestSQLApi):
         create_sql = sql.get_schema(self.test_frame1, 'test')
         self.assertTrue('CREATE' in create_sql)
 
-    def test_tquery(self):
-        with tm.assert_produces_warning(FutureWarning):
-            iris_results = sql.tquery("SELECT * FROM iris", con=self.conn)
-        row = iris_results[0]
-        tm.equalContents(row, [5.1, 3.5, 1.4, 0.2, 'Iris-setosa'])
-
-    def test_uquery(self):
-        with tm.assert_produces_warning(FutureWarning):
-            rows = sql.uquery("SELECT * FROM iris LIMIT 1", con=self.conn)
-        self.assertEqual(rows, -1)
-
     def _get_sqlite_column_type(self, schema, column):
 
         for col in schema.split('\n'):
@@ -2091,6 +2080,15 @@ def format_query(sql, *args):
     return sql % tuple(processed_args)
 
 
+def tquery(query, con=None, cur=None):
+    """Replace removed sql.tquery function"""
+    res = sql.execute(query, con=con, cur=cur).fetchall()
+    if res is None:
+        return None
+    else:
+        return list(res)
+
+
 def _skip_if_no_pymysql():
     try:
         import pymysql  # noqa
@@ -2120,7 +2118,7 @@ class TestXSQLite(SQLiteMixIn, tm.TestCase):
         ins = "INSERT INTO test VALUES (%s, %s, %s, %s)"
         for idx, row in frame.iterrows():
             fmt_sql = format_query(ins, *row)
-            sql.tquery(fmt_sql, cur=cur)
+            tquery(fmt_sql, cur=cur)
 
         self.conn.commit()
 
@@ -2200,7 +2198,7 @@ class TestXSQLite(SQLiteMixIn, tm.TestCase):
         self.conn.close()
         try:
             sys.stdout = StringIO()
-            self.assertRaises(Exception, sql.tquery, "select * from test",
+            self.assertRaises(Exception, tquery, "select * from test",
                               con=self.conn)
         finally:
             sys.stdout = sys.__stdout__
@@ -2232,42 +2230,6 @@ class TestXSQLite(SQLiteMixIn, tm.TestCase):
         expected.index.name = 'Idx'
         tm.assert_frame_equal(expected, result)
 
-    def test_tquery(self):
-        frame = tm.makeTimeDataFrame()
-        sql.to_sql(frame, name='test_table', con=self.conn, index=False)
-        result = sql.tquery("select A from test_table", self.conn)
-        expected = Series(frame.A.values, frame.index)  # not to have name
-        result = Series(result, frame.index)
-        tm.assert_series_equal(result, expected)
-
-        try:
-            sys.stdout = StringIO()
-            self.assertRaises(sql.DatabaseError, sql.tquery,
-                              'select * from blah', con=self.conn)
-
-            self.assertRaises(sql.DatabaseError, sql.tquery,
-                              'select * from blah', con=self.conn, retry=True)
-        finally:
-            sys.stdout = sys.__stdout__
-
-    def test_uquery(self):
-        frame = tm.makeTimeDataFrame()
-        sql.to_sql(frame, name='test_table', con=self.conn, index=False)
-        stmt = 'INSERT INTO test_table VALUES(2.314, -123.1, 1.234, 2.3)'
-        self.assertEqual(sql.uquery(stmt, con=self.conn), 1)
-
-        try:
-            sys.stdout = StringIO()
-
-            self.assertRaises(sql.DatabaseError, sql.tquery,
-                              'insert into blah values (1)', con=self.conn)
-
-            self.assertRaises(sql.DatabaseError, sql.tquery,
-                              'insert into blah values (1)', con=self.conn,
-                              retry=True)
-        finally:
-            sys.stdout = sys.__stdout__
-
     def test_keyword_as_column_names(self):
         df = DataFrame({'From': np.ones(5)})
         sql.to_sql(df, con=self.conn, name='testkeywords', index=False)
@@ -2324,22 +2286,22 @@ class TestXSQLite(SQLiteMixIn, tm.TestCase):
         # test if_exists='replace'
         sql.to_sql(frame=df_if_exists_1, con=self.conn, name=table_name,
                    if_exists='replace', index=False)
-        self.assertEqual(sql.tquery(sql_select, con=self.conn),
+        self.assertEqual(tquery(sql_select, con=self.conn),
                          [(1, 'A'), (2, 'B')])
         sql.to_sql(frame=df_if_exists_2, con=self.conn, name=table_name,
                    if_exists='replace', index=False)
-        self.assertEqual(sql.tquery(sql_select, con=self.conn),
+        self.assertEqual(tquery(sql_select, con=self.conn),
                          [(3, 'C'), (4, 'D'), (5, 'E')])
         clean_up(table_name)
 
         # test if_exists='append'
         sql.to_sql(frame=df_if_exists_1, con=self.conn, name=table_name,
                    if_exists='fail', index=False)
-        self.assertEqual(sql.tquery(sql_select, con=self.conn),
+        self.assertEqual(tquery(sql_select, con=self.conn),
                          [(1, 'A'), (2, 'B')])
         sql.to_sql(frame=df_if_exists_2, con=self.conn, name=table_name,
                    if_exists='append', index=False)
-        self.assertEqual(sql.tquery(sql_select, con=self.conn),
+        self.assertEqual(tquery(sql_select, con=self.conn),
                          [(1, 'A'), (2, 'B'), (3, 'C'), (4, 'D'), (5, 'E')])
         clean_up(table_name)
 
@@ -2445,7 +2407,7 @@ class TestXMySQL(MySQLMixIn, tm.TestCase):
         ins = "INSERT INTO test VALUES (%s, %s, %s, %s)"
         for idx, row in frame.iterrows():
             fmt_sql = format_query(ins, *row)
-            sql.tquery(fmt_sql, cur=cur)
+            tquery(fmt_sql, cur=cur)
 
         self.conn.commit()
 
@@ -2554,7 +2516,7 @@ class TestXMySQL(MySQLMixIn, tm.TestCase):
         self.conn.close()
         try:
             sys.stdout = StringIO()
-            self.assertRaises(Exception, sql.tquery, "select * from test",
+            self.assertRaises(Exception, tquery, "select * from test",
                               con=self.conn)
         finally:
             sys.stdout = sys.__stdout__
@@ -2603,58 +2565,6 @@ class TestXMySQL(MySQLMixIn, tm.TestCase):
         expected.index.names = result.index.names
         tm.assert_frame_equal(expected, result)
 
-    def test_tquery(self):
-        try:
-            import pymysql  # noqa
-        except ImportError:
-            raise nose.SkipTest("no pymysql")
-        frame = tm.makeTimeDataFrame()
-        drop_sql = "DROP TABLE IF EXISTS test_table"
-        cur = self.conn.cursor()
-        cur.execute(drop_sql)
-        sql.to_sql(frame, name='test_table',
-                   con=self.conn, index=False)
-        result = sql.tquery("select A from test_table", self.conn)
-        expected = Series(frame.A.values, frame.index)  # not to have name
-        result = Series(result, frame.index)
-        tm.assert_series_equal(result, expected)
-
-        try:
-            sys.stdout = StringIO()
-            self.assertRaises(sql.DatabaseError, sql.tquery,
-                              'select * from blah', con=self.conn)
-
-            self.assertRaises(sql.DatabaseError, sql.tquery,
-                              'select * from blah', con=self.conn, retry=True)
-        finally:
-            sys.stdout = sys.__stdout__
-
-    def test_uquery(self):
-        try:
-            import pymysql  # noqa
-        except ImportError:
-            raise nose.SkipTest("no pymysql")
-        frame = tm.makeTimeDataFrame()
-        drop_sql = "DROP TABLE IF EXISTS test_table"
-        cur = self.conn.cursor()
-        cur.execute(drop_sql)
-        sql.to_sql(frame, name='test_table',
-                   con=self.conn, index=False)
-        stmt = 'INSERT INTO test_table VALUES(2.314, -123.1, 1.234, 2.3)'
-        self.assertEqual(sql.uquery(stmt, con=self.conn), 1)
-
-        try:
-            sys.stdout = StringIO()
-
-            self.assertRaises(sql.DatabaseError, sql.tquery,
-                              'insert into blah values (1)', con=self.conn)
-
-            self.assertRaises(sql.DatabaseError, sql.tquery,
-                              'insert into blah values (1)', con=self.conn,
-                              retry=True)
-        finally:
-            sys.stdout = sys.__stdout__
-
     def test_keyword_as_column_names(self):
         _skip_if_no_pymysql()
         df = DataFrame({'From': np.ones(5)})
@@ -2698,22 +2608,22 @@ class TestXMySQL(MySQLMixIn, tm.TestCase):
         # test if_exists='replace'
         sql.to_sql(frame=df_if_exists_1, con=self.conn, name=table_name,
                    if_exists='replace', index=False)
-        self.assertEqual(sql.tquery(sql_select, con=self.conn),
+        self.assertEqual(tquery(sql_select, con=self.conn),
                          [(1, 'A'), (2, 'B')])
         sql.to_sql(frame=df_if_exists_2, con=self.conn, name=table_name,
                    if_exists='replace', index=False)
-        self.assertEqual(sql.tquery(sql_select, con=self.conn),
+        self.assertEqual(tquery(sql_select, con=self.conn),
                          [(3, 'C'), (4, 'D'), (5, 'E')])
         clean_up(table_name)
 
         # test if_exists='append'
         sql.to_sql(frame=df_if_exists_1, con=self.conn, name=table_name,
                    if_exists='fail', index=False)
-        self.assertEqual(sql.tquery(sql_select, con=self.conn),
+        self.assertEqual(tquery(sql_select, con=self.conn),
                          [(1, 'A'), (2, 'B')])
         sql.to_sql(frame=df_if_exists_2, con=self.conn, name=table_name,
                    if_exists='append', index=False)
-        self.assertEqual(sql.tquery(sql_select, con=self.conn),
+        self.assertEqual(tquery(sql_select, con=self.conn),
                          [(1, 'A'), (2, 'B'), (3, 'C'), (4, 'D'), (5, 'E')])
         clean_up(table_name)
 

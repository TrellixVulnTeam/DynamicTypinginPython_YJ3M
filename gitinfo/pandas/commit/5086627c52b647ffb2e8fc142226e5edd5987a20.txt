commit 5086627c52b647ffb2e8fc142226e5edd5987a20
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun Aug 28 14:06:49 2011 -0400

    DOC: more docs work on tutorial

diff --git a/doc/source/basics.rst b/doc/source/basics.rst
index ecdb74775..a4a55cfc9 100644
--- a/doc/source/basics.rst
+++ b/doc/source/basics.rst
@@ -18,12 +18,18 @@ objects. To get started, import numpy and load pandas into your namespace:
 Here is a basic tenet to keep in mind: **data alignment is intrinsic**. Link
 between labels and data will not be broken unless done so explicitly by you.
 
+We'll give a brief intro to the data structures, then consider all of the broad
+categories of functionality and methods in separate sections.
+
+.. _basics.series:
+
 Series
 ------
 
-:class:`Series` is a one-dimensional labeled array. The axis labels are
-collectively referred to as the **index**. The basic method to create a Series
-is to call:
+:class:`Series` is a one-dimensional labeled array (technically a subclass of
+ndarray) capable of holding any data type (integers, strings, floating point
+numbers, Python objects, etc.). The axis labels are collectively referred to as
+the **index**. The basic method to create a Series is to call:
 
 ::
 
@@ -46,12 +52,13 @@ len(data) - 1]``.
 
    s = Series(np.random.randn(5), index=['a', 'b', 'c', 'd', 'e'])
    s
+   s.index
 
    Series(np.random.randn(5))
 
-**Case 2:** If **data** is a dict, if **index** is passed the values in data**
-**corresponding to the labels in the index will be pulled out. Otherwise, an
-**index will be constructed from the sorted keys of the dict, if possible.
+**Case 2:** If **data** is a dict, if **index** is passed the values in data
+corresponding to the labels in the index will be pulled out. Otherwise, an
+index will be constructed from the sorted keys of the dict, if possible.
 
 .. ipython:: python
 
@@ -96,6 +103,8 @@ label:
     s['a']
     s['e'] = 12.
     s
+    'e' in s
+    'f' in s
 
 If a label is not contained, an exception
 
@@ -107,7 +116,38 @@ If a label is not contained, an exception
     >>> s.get('f')
     nan
 
+Vectorized operations and label alignment with Series
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+When doing data analysis, as with raw NumPy arrays looping through Series
+value-by-value is usually not necessary. Series can be also be passed into most
+NumPy methods expecting an ndarray.
+
+
+.. ipython:: python
+
+    s + s
+    s * 2
+    np.exp(s)
 
+A key difference between Series and ndarray is that operations between Series
+automatically align the data based on label. Thus, you can write computations
+without giving consideration to whether the Series involved have the same
+labels.
+
+.. ipython:: python
+
+    s[1:] + s[:-1]
+
+The result of an operation between unaligned Series will have the **union** of
+the indexes involved. If a label is not found in one Series or the other, the
+result will be marked as missing (NaN). Being able to write code without doing
+any explicit data alignment grants immense freedom and flexibility in
+interactive data analysis and research. The integrated data alignment features
+of the pandas data structures set pandas apart from the majority of related
+tools for working with labeled data.
+
+.. _basics.dataframe:
 
 DataFrame
 ---------
@@ -140,7 +180,9 @@ the sorted list of dict keys.
 
     d = {'one' : Series([1., 2., 3.], index=['a', 'b', 'c']),
          'two' : Series([1., 2., 3., 4.], index=['a', 'b', 'c', 'd'])}
-    DataFrame(d)
+    df = DataFrame(d)
+    df
+
     DataFrame(d, index=['d', 'b', 'a'])
     DataFrame(d, index=['d', 'b', 'a'], columns=['two', 'three'])
 
@@ -151,10 +193,10 @@ the array length.
 
 .. ipython:: python
 
-    d = {'one' : [1., 2., 3., 4.],
-         'two' : [4., 3., 2., 1.]}
-    DataFrame(d)
-    DataFrame(d, index=['a', 'b', 'c', 'd'])
+   d = {'one' : [1., 2., 3., 4.],
+        'two' : [4., 3., 2., 1.]}
+   DataFrame(d)
+   DataFrame(d, index=['a', 'b', 'c', 'd'])
 
 **Case 3, structured or record array**: This case is handled identically to a
 dict of arrays.
@@ -168,9 +210,54 @@ dict of arrays.
    DataFrame(data, index=['first', 'second'])
    DataFrame(data, columns=['C', 'A', 'B'])
 
+.. note::
+
+    DataFrame is not intended to work exactly like a 2-dimensional NumPy
+    ndarray.
+
 Column selection, addition, deletion
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
+You can treat a DataFrame semantically like a dict of like-indexed Series
+objects. Getting, setting, and deleting columns works with the same syntax as
+the analogous dict operations:
+
+.. ipython:: python
+
+   df['one']
+   df['three'] = df['one'] * df['two']
+   df['flag'] = df['one'] > 2
+   df
+   del df['two']
+   df
+
+When inserting a scalar value, it will naturally be propagated to fill the
+column:
+
+.. ipython:: python
+
+   df['foo'] = 'bar'
+   df
+
+When inserting a Series that does not have the same index as the DataFrame, it
+will be conformed to the DataFrame's index:
+
+.. ipython:: python
+
+   df['one_trunc'] = df['one'][:2]
+   df
+
+You can insert raw ndarrays but their length must match the length of the
+DataFrame's index.
+
+By default, columns get inserted at the end. The **insert**
+function is available to insert at a particular location in the columns:
+
+.. ipython:: python
+
+   df.insert(1, 'bar', df['one'])
+   df
+
 Indexing / Selection
 ~~~~~~~~~~~~~~~~~~~~
 The basics of indexing are as follows:
@@ -185,33 +272,130 @@ The basics of indexing are as follows:
     Slice rows, ``df[5:10]``, DataFrame
     Select rows by boolean vector, ``df[bool_vec]``, DataFrame
 
+Row selection, for example, returns a Series whose index is the columns of the
+DataFrame:
+
+.. ipython:: python
+
+   df.xs('b')
+   df.ix[2]
+
+Note if a DataFrame contains columns of multiple dtypes, the dtype of the row
+will be chosen to accommodate all of the data types (dtype=object is the most
+general).
+
 For a more exhaustive treatment of more sophisticated label-based indexing and
-slicing, see the `section on indexing <indexing>`__.
+slicing, see the :ref:`section on indexing <indexing>`.
+
+Data alignment and arithmetic
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Data alignment between DataFrame objects automatically align on **both the
+columns and the index (row labels)**. Again, the resulting object will have the
+union of the column and row labels.
+
+.. ipython:: python
+
+    df = DataFrame(np.random.randn(10, 4), columns=['A', 'B', 'C', 'D'])
+    df2 = DataFrame(np.random.randn(7, 3), columns=['A', 'B', 'C'])
+	df + df2
+
+When doing an operation between DataFrame and Series, the default behavior is
+to align the Series **index** on the DataFrame **columns**, thus `broadcasting
+<http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html>`__
+row-wise. For example:
+
+.. ipython:: python
+
+   df - df.ix[0]
+
+In the special case of working with time series data, if the Series is a
+TimeSeries (which it will be automatically if the index contains datetime
+objects), and the DataFrame index also contains dates, the broadcasting will be
+column-wise:
+
+.. ipython:: python
+
+   index = DateRange('1/1/2000', periods=8)
+   df = DataFrame(np.random.randn(8, 3), index=index,
+                  columns=['A', 'B', 'C'])
+   df
+   type(df['A'])
+   df - df['A']
+
+Technical purity aside, this case is so common in practice that supporting the
+special case is preferable to the alternative of forcing the user to transpose
+and do column-based alignment like so:
+
+.. ipython:: python
+
+   (df.T - df['A']).T
+
+For explicit control over the matching and broadcasting behavior, see the
+section on :ref:`flexible binary operations <basics.binop>`.
+
+.. _basics.panel:
 
 WidePanel
 ---------
 
-WidePanel is a less-used, but still important container for 3-dimensional
-data. The term `panel data <http://en.wikipedia.org/wiki/Panel_data>`__ is
-derived from econometrics and is partially responsible for the name pandas:
-pan(el)-da(ta)-s.
+WidePanel is a somewhat less-used, but still important container for
+3-dimensional data. The term `panel data
+<http://en.wikipedia.org/wiki/Panel_data>`__ is derived from econometrics and
+is partially responsible for the name pandas: pan(el)-da(ta)-s. The names for
+the 3 axes are intended to give some semantic meaning to describing operations
+involving panel data and, in particular, econometric analysis of panel
+data. However, for the strict purposes of slicing and dicing a collection of
+DataFrame objects, the axis names are slightly arbitrary:
+
+  - **items**: axis 0, each item corresponds to a DataFrame contained inside
+  - **major_axis**: axis 1, it is the **index** (rows) of each of the
+    DataFrames
+  - **minor_axis**: axis 2, it is the **columns** of each of the DataFrames
+
+.. note::
+
+    The "wide" in **WidePanel** name comes from the notion of "long" and "wide"
+    formats of grouped data. The R `reshape function
+    <http://stat.ethz.ch/R-manual/R-patched/library/stats/html/reshape.html>`__
+    has some more to say about these.
 
-Binary operations between objects
+
+.. _basics.attrs:
+
+Attributes and the raw ndarray(s)
 ---------------------------------
 
-Alignment and reindexing
-------------------------
+.. _basics.binop:
+
+Flexible binary operations
+--------------------------
+
+Combining with fill values
+~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. _basics.reindexing:
+
+Reindexing
+----------
+
+
 
-Deleting labels from an axis
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+Dropping labels from an axis
+----------------------------
+
+.. _basics.apply:
 
 Function application and basic stats
 ------------------------------------
 
+.. _basics.cast:
+
 Copying, type casting
 ---------------------
 
+.. _basics.serialize:
+
 Pickling and serialization
 --------------------------
 
-
diff --git a/doc/source/dataframe.rst b/doc/source/dataframe.rst
index 9695a9eb0..6e1a1bbe5 100644
--- a/doc/source/dataframe.rst
+++ b/doc/source/dataframe.rst
@@ -6,35 +6,6 @@
 DataFrame
 *********
 
-**DataFrame** is a both 2D-matrix- and dict-like object implementing a named
-collection of identically-indexed Series objects. It supports columns having
-different types, so you can use it to store and manipulate floating point,
-integer, boolean, and arbitrary Python object data.
-
-.. note::
-
-    DataFrame is the most commonly used object for most pandas users.
-
-.. class:: DataFrame
-
-   :Parameters:
-       **data** : dict, 2-D ndarray, or DataFrame
-           * If the dict contains Series, an index need not be specified.
-             The resulting frame will be the union of all the contained
-             Series indices.
-
-       **index** : {array_like}
-           Explicit index to conform to, defaults to range(N) if not input
-
-       **columns** : {array_like}
-           Explicit set of columns to include, defaults to range(N) if not input
-
-       **dtype** : Python type alias or :class:`~numpy.dtype`
-           Data type to force, otherwise infer
-
-       **copy** : boolean, default False
-	       Copy data from inputs. Only affects DataFrame / 2d ndarray input
-
 Basics
 ------
 
diff --git a/doc/source/missing_data.rst b/doc/source/missing_data.rst
index 174b385ef..a3b6f2d25 100644
--- a/doc/source/missing_data.rst
+++ b/doc/source/missing_data.rst
@@ -5,6 +5,14 @@
 Working with missing data
 *************************
 
+.. note::
+
+    The choice of using NaN for missing data was largely for
+    simplicity and performance reasons. IIt differs from the
+    MaskedArray approach of, for example,
+    :mod:`scikits.timeseries`. For a discussion of the issues with the
+    various approaches, :ref:`see here <missing_data>`
+
 Calculations with missing data
 ------------------------------
 
diff --git a/doc/source/series.rst b/doc/source/series.rst
index 3e5fb6b64..8088b8837 100644
--- a/doc/source/series.rst
+++ b/doc/source/series.rst
@@ -1,190 +1,6 @@
 .. currentmodule:: pandas
 .. _series:
 
-*******************
-Series / TimeSeries
-*******************
-
-:class:`Series` is a NumPy ndarray subclass which contains a vector
-of labels corresponding to the data values. The labels, which will be
-referred to everywhere as the **index**, can be any Python object;
-common examples are datetimes or strings. The object is designed to
-handle missing observations and support arithmetic between
-different-sized Series by matching index values.
-
-Because Series is an ndarray, it can be used interchangeably in
-NumPy-based functions expecting one-dimensional ndarrays.
-
-.. class:: Series
-
-   A subclass of :class:`~numpy.ndarray` designed for labeled
-   1-dimensional data.
-
-   :Parameters:
-       **data** : {array_like, dict, scalar value}
-           Data to store in the array. Any data that is valid for
-           constructing a 1-D :class:`~numpy.ndarray` can be used
-           here.
-
-           * a sequence of objects (numbers, characters, objects)
-           * an :class:`~numpy.ndarray` or one of its subclass.
-
-	   Additionally, :class:`dict` is a valid input, allowing the
-	   user to optionally forgo specifying an index.
-
-       **index** : {array_like}
-           Sequence of labels for input data.
-
-
-Construction
-------------
-
-There are a number of ways to create Series objects. The most common
-is to use the default constructor and pass two equal-length sequences:
-one for the values, one for the index:
-
-::
-
-    >>> import numpy as np; from pandas import *
-
-    >>> values = np.arange(5.)
-    >>> labels = ['a', 'b', 'c', 'd', 'e']
-    >>> s = Series(values, index=labels)
-    >>> s
-    a    0.0
-    b    1.0
-    c    2.0
-    d    3.0
-    e    4.0
-
-We could also create this Series from a dict representing the data:
-
-::
-
-    >>> data = {'a': 0.0, 'b': 1.0, 'c': 2.0, 'd': 3.0, 'e': 4.0}
-    >>> Series(data)
-    a    0.0
-    b    1.0
-    c    2.0
-    d    3.0
-    e    4.0
-
-
-Any Series instance has the attribute **index** which is an Index
-object containing the value labels:
-
-::
-
-    >>> s.index
-    Index([a, b, c, d, e], dtype=object)
-
-The index defines the *__contains__* behavior of the Series:
-
-::
-
-    >>> 'a' in s
-    True
-
-    >>> 'a' in s.index
-    True
-
-If an index contains all Python datetime objects, the created series
-will be of type TimeSeries (so it is never necessary to explicitly use
-the TimeSeries constructor):
-
-::
-
-    >>> dates
-    [datetime.datetime(2009, 1, 1, 0, 0),
-     datetime.datetime(2009, 1, 2, 0, 0),
-     datetime.datetime(2009, 1, 5, 0, 0),
-     datetime.datetime(2009, 1, 6, 0, 0),
-     datetime.datetime(2009, 1, 7, 0, 0)]
-
-    >>> ts = Series(values, index=dates)
-    2009-01-01 00:00:00    0.0
-    2009-01-02 00:00:00    1.0
-    2009-01-05 00:00:00    2.0
-    2009-01-06 00:00:00    3.0
-    2009-01-07 00:00:00    4.0
-
-    >>> type(ts)
-    <class 'pandas.core.series.TimeSeries'>
-
-Series can also be constructed from a single value, though it is necessary in
-this case to pass an index so it knows how long to make the resulting Series.
-
-::
-
-    >>> Series(1, index=labels)
-    a    1
-    b    1
-    c    1
-    d    1
-    e    1
-
-Indexing
---------
-
-A Series operations similar to both an ndarray and a Python dict. For
-example, values can be accessed either by integer location or by
-index value:
-
-::
-
-    >>> s[1]
-    1.0
-    >>> s['b']
-    1.0
-
-If the index contains integers and there is ambiguity, the index will
-be preferred.
-
-For completeness of the dict-like interface, :func:`Series.get` is
-provided for analogous behavior:
-
-::
-
-    >>> s.get('f')
-    None
-
-    >>> s.get('f', 0)
-    0
-
-Standard Python boolean indexing works as expected, as do slicing and
-NumPy fancy indexing:
-
-::
-
-    >>> s[s > 2]
-    d    3.0
-    e    4.0
-
-    >>> s[-3:]
-    c    2.0
-    d    3.0
-    e    4.0
-
-    >>> s[[4, 3, 1]]
-    e    4.0
-    d    3.0
-    b    1.0
-
-Observe that a new Index has been constructed corresponding to the
-selected data.
-
-Of course, the same behavior applies to *setting* values:
-
-::
-
-    >>> s[s > 2] = -1
-    >>> print s
-    a    0.0
-    b    1.0
-    c    2.0
-    d    -1.0
-    e    -1.0
-
 .. _series.arithmetic:
 
 Accessing underlying data
@@ -195,35 +11,6 @@ attribute (which is a property returning a view of the Series as an
 ndarray). The higher dimensional pandas data structures observe the
 same interface for accessing the underlying data.
 
-Arithmetic, data alignment
---------------------------
-
-Binary operations between Series objects ensure that two values being
-combined have the same index value. This serves to prevent a lot of
-the headache generally associated with heterogeneous data; the user is
-**not** to ensure that all Series have the same index.
-
-::
-
-    >>> s + 2 * s
-    a    0.0
-    b    3.0
-    c    6.0
-    d    9.0
-    e    12.0
-
-    >>> s + s[2:]
-    a    nan
-    b    nan
-    c    4.0
-    d    6.0
-    e    8.0
-
-In this latter example, you can see that, since the **a** and **b**
-values were missing in the second Series, the sum has NaN in those
-locations. In general, pandas represents missing data as NaN (more on
-this below).
-
 Handling missing data and reindexing
 ------------------------------------
 
@@ -237,14 +24,6 @@ functions are implemented in Cython and provide reasonably good
 performance on object arrays. For numerical arrays, the performance
 will be equivalent to *numpy.isfinite*.
 
-.. note::
-
-    The choice of using NaN for missing data was largely for
-    simplicity and performance reasons. IIt differs from the
-    MaskedArray approach of, for example,
-    :mod:`scikits.timeseries`. For a discussion of the issues with the
-    various approaches, :ref:`see here <missing_data>`
-
 ::
 
     >>> s
@@ -528,28 +307,6 @@ can be used safely:
     >>> np.mean(s)
     2.0
 
-Method summary
-~~~~~~~~~~~~~~
-
-.. autosummary::
-   :toctree: generated/
-
-   Series.count
-   Series.sum
-   Series.mean
-   Series.min
-   Series.max
-   Series.std
-   Series.var
-   Series.skew
-   Series.median
-   Series.cumsum
-   Series.cumprod
-   Series.clip
-   Series.clip_upper
-   Series.clip_lower
-   Series.corr
-
 Merging Series based on key
 ---------------------------
 
@@ -756,37 +513,3 @@ A convenience method for selecting weekdays, similar to
    Series.shift
    Series.asOf
    Series.weekday
-
-.. _series.groupby:
-
-GroupBy functionality
----------------------
-
-.. seealso::
-    :ref:`GroupBy operations <groupby>`
-
-Plotting
---------
-
-TODO
-
-.. autosummary::
-   :toctree: generated/
-
-   Series.plot
-
-Misc methods
-------------
-
-TODO
-
-.. autosummary::
-   :toctree: generated/
-
-   Series.append
-   Series.combine
-   Series.combineFirst
-   Series.map
-   Series.copy
-   Series.toCSV
-   Series.diff
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 70eda99e7..a667f4f6e 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -36,7 +36,7 @@ def _arith_method(func, name):
 
     return f
 
-def _long_arith_method(op, name):
+def _panel_arith_method(op, name):
     def f(self, other, axis='items'):
         """
         Wrapper method for %s
@@ -57,26 +57,6 @@ def _long_arith_method(op, name):
 
     return f
 
-def _wide_arith_method(op, name):
-    def f(self, other, axis='items'):
-        """
-        Wrapper method for %s
-
-        Parameters
-        ----------
-        other : DataFrame or WidePanel
-        axis : {'items', 'major', 'minor'}
-
-        Returns
-        -------
-        WidePanel
-        """
-        return self._combine(other, op, axis=axis)
-
-    f.__name__ = name
-    f.__doc__ = f.__doc__ % str(op)
-
-    return f
 
 _agg_doc = """
 Return %(desc)s over requested axis.%(na_info)s
@@ -95,6 +75,7 @@ _na_info = """
 NA/null values are %s.
 If all values are NA, result will be NA"""
 
+
 def _add_docs(method, desc, outname, na_info=None):
     if na_info is not None:
         na_info = _na_info % na_info
@@ -103,11 +84,11 @@ def _add_docs(method, desc, outname, na_info=None):
     doc = _agg_doc % locals()
     method.__doc__ = doc
 
+
 class Panel(object):
     """
     Abstract superclass for LongPanel and WidePanel data structures
     """
-    _values = None
 
     __add__ = _arith_method(operator.add, '__add__')
     __sub__ = _arith_method(operator.sub, '__sub__')
@@ -121,21 +102,8 @@ class Panel(object):
     __rdiv__ = _arith_method(lambda x, y: y / x, '__rdiv__')
     __rpow__ = _arith_method(lambda x, y: y ** x, '__rpow__')
 
-    @property
-    def shape(self):
-        return len(self.items), len(self.major_axis), len(self.minor_axis)
 
 class WidePanel(Panel, NDFrame):
-    """
-    Represents wide format panel data, stored as 3-dimensional array
-
-    Parameters
-    ----------
-    values : ndarray (items x major x minor)
-    items : sequence
-    major_axis : sequence
-    minor_axis : sequence
-    """
     _AXIS_NUMBERS = {
         'items' : 0,
         'major_axis' : 1,
@@ -162,6 +130,23 @@ class WidePanel(Panel, NDFrame):
 
     def __init__(self, data, items=None, major_axis=None, minor_axis=None,
                  copy=False, dtype=None):
+        """
+        Represents wide format panel data, stored as 3-dimensional array
+
+        Parameters
+        ----------
+        values : ndarray (items x major x minor)
+        items : Index or array-like
+            axis=1
+        major_axis : Index or array-like
+            axis=1
+        minor_axis : Index or array-like
+            axis=2
+        dtype : dtype, default None
+            Data type to force, otherwise infer
+        copy : boolean, default False
+            Copy data from inputs. Only affects DataFrame / 2d ndarray input
+        """
         passed_axes = [items, major_axis, minor_axis]
         if isinstance(data, BlockManager):
             mgr = data
@@ -218,6 +203,10 @@ class WidePanel(Panel, NDFrame):
         mgr = BlockManager(blocks, axes).consolidate()
         return mgr
 
+    @property
+    def shape(self):
+        return len(self.items), len(self.major_axis), len(self.minor_axis)
+
     @classmethod
     def from_dict(cls, data, intersect=False, dtype=float):
         """
@@ -236,7 +225,6 @@ class WidePanel(Panel, NDFrame):
         data, index, columns = _homogenize_dict(data, intersect=intersect,
                                                 dtype=dtype)
         items = Index(sorted(data.keys()))
-        axes = [items, index, columns]
         return WidePanel(data, items, index, columns)
 
     def _init_matrix(self, data, axes, dtype=None, copy=False):
@@ -596,10 +584,10 @@ class WidePanel(Panel, NDFrame):
             new_data = self._data.fillna(value)
             return WidePanel(new_data)
 
-    add = _wide_arith_method(operator.add, 'add')
-    subtract = _wide_arith_method(operator.sub, 'subtract')
-    divide = _wide_arith_method(operator.div, 'divide')
-    multiply = _wide_arith_method(operator.mul, 'multiply')
+    add = _panel_arith_method(operator.add, 'add')
+    subtract = _panel_arith_method(operator.sub, 'subtract')
+    divide = _panel_arith_method(operator.div, 'divide')
+    multiply = _panel_arith_method(operator.mul, 'multiply')
 
     def major_xs(self, key, copy=True):
         """
@@ -1011,6 +999,9 @@ class LongPanel(Panel, DataFrame):
     DataFrame objects with hierarchical indexes. You should be careful about
     writing production code depending on LongPanel
     """
+    @property
+    def wide_shape(self):
+        return (len(self.items), len(self.major_axis), len(self.minor_axis))
 
     @property
     def items(self):
@@ -1142,10 +1133,10 @@ class LongPanel(Panel, DataFrame):
         return LongPanel(new_values, columns=self.items,
                          index=self.index)
 
-    add = _long_arith_method(operator.add, 'add')
-    subtract = _long_arith_method(operator.sub, 'subtract')
-    divide = _long_arith_method(operator.div, 'divide')
-    multiply = _long_arith_method(operator.mul, 'multiply')
+    add = _panel_arith_method(operator.add, 'add')
+    subtract = _panel_arith_method(operator.sub, 'subtract')
+    divide = _panel_arith_method(operator.div, 'divide')
+    multiply = _panel_arith_method(operator.mul, 'multiply')
 
     def to_wide(self):
         """
@@ -1162,7 +1153,7 @@ class LongPanel(Panel, DataFrame):
             return self._to_wide_homogeneous(mask)
 
     def _to_wide_homogeneous(self, mask):
-        values = np.empty(self.shape, dtype=self.values.dtype)
+        values = np.empty(self.wide_shape, dtype=self.values.dtype)
 
         if not issubclass(self.values.dtype.type, np.integer):
             values.fill(np.nan)
@@ -1173,7 +1164,7 @@ class LongPanel(Panel, DataFrame):
         return WidePanel(values, self.items, self.major_axis, self.minor_axis)
 
     def _to_wide_mixed(self, mask):
-        _, N, K = self.shape
+        _, N, K = self.wide_shape
 
         # TODO: make much more efficient
 
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 2c95ceae3..314d96dba 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -1344,7 +1344,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         test_comp(operator.ge)
         test_comp(operator.le)
 
-    def test_to_csv_fromcsv(self):
+    def test_to_csv_from_csv(self):
         path = '__tmp__'
 
         self.frame['A'][:5] = nan
@@ -1357,24 +1357,24 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         # test roundtrip
 
         self.tsframe.to_csv(path)
-        recons = DataFrame.fromcsv(path)
+        recons = DataFrame.from_csv(path)
 
         assert_frame_equal(self.tsframe, recons)
 
-        recons = DataFrame.fromcsv(path, index_col=None)
+        recons = DataFrame.from_csv(path, index_col=None)
         assert(len(recons.columns) == len(self.tsframe.columns) + 1)
 
 
         # no index
         self.tsframe.to_csv(path, index=False)
-        recons = DataFrame.fromcsv(path, index_col=None)
+        recons = DataFrame.from_csv(path, index_col=None)
         assert_almost_equal(self.tsframe.values, recons.values)
 
         # corner case
         dm = DataFrame({'s1' : Series(range(3),range(3)),
                         's2' : Series(range(2),range(2))})
         dm.to_csv(path)
-        recons = DataFrame.fromcsv(path)
+        recons = DataFrame.from_csv(path)
         assert_frame_equal(dm, recons)
 
         os.remove(path)

commit a8351183f778812d45c2976c3417e77c68637429
Author: Dan Allan <daniel.b.allan@gmail.com>
Date:   Mon Jan 21 17:21:22 2013 -0500

    Merging in MySQL support #2482

diff --git a/pandas/io/sql.py b/pandas/io/sql.py
index 75f5db358..0caf83838 100644
--- a/pandas/io/sql.py
+++ b/pandas/io/sql.py
@@ -2,7 +2,7 @@
 Collection of query wrappers / abstractions to both facilitate data
 retrieval and to reduce dependency on DB-specific API.
 """
-from datetime import datetime
+from datetime import datetime, date
 
 import numpy as np
 import traceback
@@ -158,99 +158,150 @@ def read_frame(sql, con, index_col=None, coerce_float=True):
 frame_query = read_frame
 
 
-def write_frame(frame, name=None, con=None, flavor='sqlite', append=False):
+def write_frame(frame, name, con, flavor='sqlite', if_exists='fail', **kwargs):
     """
-    Write records stored in a DataFrame to SQLite. The index will currently be
-    dropped
+    Write records stored in a DataFrame to a SQL database.
+
+    Parameters
+    ----------
+    frame: DataFrame
+    name: name of SQL table
+    conn: an open SQL database connection object
+    flavor: {'sqlite', 'mysql', 'oracle'}, default 'sqlite'
+    if_exists: {'fail', 'replace', 'append'}, default 'fail'
+        fail: If table exists, do nothing.
+        replace: If table exists, drop it, recreate it, and insert data.
+        append: If table exists, insert data. Create if does not exist.
     """
-    if flavor == 'sqlite':
-        schema = get_sqlite_schema(frame, name)
-    else:
-        raise NotImplementedError
 
-    if not append and not has_table(name, con):
-        con.execute(schema)
+    if 'append' in kwargs:
+        import warnings
+        warnings.warn("append is deprecated, use if_exists instead",
+                      FutureWarning)
+        if kwargs['append']:
+            if_exists='append'
+        else:
+            if_exists='fail'
+    exists = table_exists(name, con, flavor)
+    if if_exists == 'fail' and exists:
+        raise ValueError, "Table '%s' already exists." % name
+
+    #create or drop-recreate if necessary
+    create = None
+    if exists and if_exists == 'replace':
+        create = "DROP TABLE %s" % name
+    elif not exists:
+        create = get_schema(frame, name, flavor)
+
+    if create is not None:
+        cur = con.cursor()
+        cur.execute(create)
+        cur.close()
+
+    cur = con.cursor()
+    # Replace spaces in DataFrame column names with _.
+    safe_names = [s.replace(' ', '_').strip() for s in frame.columns]
+    flavor_picker = {'sqlite' : _write_sqlite,
+                     'mysql' : _write_mysql}
+
+    func = flavor_picker.get(flavor, None)
+    if func is None:
+        raise NotImplementedError
+    func(frame, name, safe_names, cur)
+    cur.close()
+    con.commit()
 
-    wildcards = ','.join(['?'] * len(frame.columns))
-    insert_sql = 'INSERT INTO %s VALUES (%s)' % (name, wildcards)
+def _write_sqlite(frame, table, names, cur):
+    bracketed_names = ['[' + column + ']' for column in names]
+    col_names = ','.join(bracketed_names)
+    wildcards = ','.join(['?'] * len(names))
+    insert_query = 'INSERT INTO %s (%s) VALUES (%s)' % (
+        table, col_names, wildcards)
     data = [tuple(x) for x in frame.values]
-    con.executemany(insert_sql, data)
-
-
-def has_table(name, con):
-    """
-    Check if a given SQLite table exists.
+    cur.executemany(insert_query, data)
+
+def _write_mysql(frame, table, names, cur):
+    bracketed_names = ['`' + column + '`' for column in names]
+    col_names = ','.join(bracketed_names)
+    wildcards = ','.join([r'%s'] * len(names))
+    insert_query = "INSERT INTO %s (%s) VALUES (%s)" % (
+        table, col_names, wildcards)
+    data = [tuple(x) for x in frame.values]
+    cur.executemany(insert_query, data)
+
+def table_exists(name, con, flavor):
+    flavor_map = {
+        'sqlite': ("SELECT name FROM sqlite_master "
+                   "WHERE type='table' AND name='%s';") % name,
+        'mysql' : "SHOW TABLES LIKE '%s'" % name}
+    query = flavor_map.get(flavor, None)
+    if query is None:
+        raise NotImplementedError
+    return len(tquery(query, con)) > 0
 
-    Parameters
-    ----------
-    name: string
-        SQLite table name
-    con: DB connection object
-    """
-    sqlstr = "SELECT name FROM sqlite_master WHERE type='table' AND name='%s'" % name
-    rs = tquery(sqlstr, con)
-    return len(rs) > 0
+def get_sqltype(pytype, flavor):
+    sqltype = {'mysql': 'VARCHAR (63)',
+               'sqlite': 'TEXT'}
 
+    if issubclass(pytype, np.floating):
+        sqltype['mysql'] = 'FLOAT'
+        sqltype['sqlite'] = 'REAL'
 
-def get_sqlite_schema(frame, name, dtypes=None, keys=None):
-    template = """
-CREATE TABLE %(name)s (
-  %(columns)s%(keystr)s
-);"""
+    if issubclass(pytype, np.integer):
+        #TODO: Refine integer size.
+        sqltype['mysql'] = 'BIGINT'
+        sqltype['sqlite'] = 'INTEGER'
 
-    column_types = []
+    if issubclass(pytype, np.datetime64) or pytype is datetime:
+        # Caution: np.datetime64 is also a subclass of np.number.
+        sqltype['mysql'] = 'DATETIME'
+        sqltype['sqlite'] = 'TIMESTAMP'
 
-    frame_types = frame.dtypes
-    for k in frame_types.index:
-        dt = frame_types[k]
+    if pytype is datetime.date:
+        sqltype['mysql'] = 'DATE'
+        sqltype['sqlite'] = 'TIMESTAMP'
 
-        if issubclass(dt.type, (np.integer, np.bool_)):
-            sqltype = 'INTEGER'
-        elif issubclass(dt.type, np.floating):
-            sqltype = 'REAL'
-        else:
-            sqltype = 'TEXT'
+    if issubclass(pytype, np.bool_):
+        sqltype['sqlite'] = 'INTEGER'
 
-        if dtypes is not None:
-            sqltype = dtypes.get(k, sqltype)
+    return sqltype[flavor]
 
-        column_types.append((k, sqltype))
-    columns = ',\n  '.join('[%s] %s' % x for x in column_types)
+def get_schema(frame, name, flavor, keys=None):
+    "Return a CREATE TABLE statement to suit the contents of a DataFrame."
+    lookup_type = lambda dtype: get_sqltype(dtype.type, flavor)
+    # Replace spaces in DataFrame column names with _.
+    safe_columns = [s.replace(' ', '_').strip() for s in frame.dtypes.index]
+    column_types = zip(safe_columns, map(lookup_type, frame.dtypes))
+    if flavor == 'sqlite':
+        columns = ',\n  '.join('[%s] %s' % x for x in column_types)
+    else:
+        columns = ',\n  '.join('`%s` %s' % x for x in column_types)
 
     keystr = ''
     if keys is not None:
         if isinstance(keys, basestring):
             keys = (keys,)
         keystr = ', PRIMARY KEY (%s)' % ','.join(keys)
-    return template % {'name': name, 'columns': columns, 'keystr': keystr}
-
-
-#------------------------------------------------------------------------------
-# Query formatting
-
-_formatters = {
-    datetime: lambda dt: "'%s'" % date_format(dt),
-    str: lambda x: "'%s'" % x,
-    np.str_: lambda x: "'%s'" % x,
-    unicode: lambda x: "'%s'" % x,
-    float: lambda x: "%.8f" % x,
-    int: lambda x: "%s" % x,
-    type(None): lambda x: "NULL",
-    np.float64: lambda x: "%.10f" % x,
-    bool: lambda x: "'%s'" % x,
-}
-
-
-def format_query(sql, *args):
+    template = """CREATE TABLE %(name)s (
+                  %(columns)s
+                  %(keystr)s
+                  );"""
+    create_statement = template % {'name': name, 'columns': columns,
+                                   'keystr': keystr}
+    return create_statement
+
+def sequence2dict(seq):
+    """Helper function for cx_Oracle.
+
+    For each element in the sequence, creates a dictionary item equal
+    to the element and keyed by the position of the item in the list.
+    >>> sequence2dict(("Matt", 1))
+    {'1': 'Matt', '2': 1}
+
+    Source:
+    http://www.gingerandjohn.com/archives/2004/02/26/cx_oracle-executemany-example/
     """
-
-    """
-    processed_args = []
-    for arg in args:
-        if isinstance(arg, float) and isnull(arg):
-            arg = None
-
-        formatter = _formatters[type(arg)]
-        processed_args.append(formatter(arg))
-
-    return sql % tuple(processed_args)
+    d = {}
+    for k,v in zip(range(1, 1 + len(seq)), seq):
+        d[str(k)] = v
+    return d
diff --git a/pandas/io/tests/test_sql.py b/pandas/io/tests/test_sql.py
index b2348ec39..3216a7dbb 100644
--- a/pandas/io/tests/test_sql.py
+++ b/pandas/io/tests/test_sql.py
@@ -3,15 +3,51 @@ import unittest
 import sqlite3
 import sys
 
+import nose
+
 import numpy as np
 
+from pandas.core.datetools import format as date_format
+from pandas.core.api import DataFrame, isnull
+
 import pandas.io.sql as sql
 import pandas.util.testing as tm
 from pandas import Series, Index, DataFrame
-
+from datetime import datetime
+
+_formatters = {
+    datetime: lambda dt: "'%s'" % date_format(dt),
+    str: lambda x: "'%s'" % x,
+    np.str_: lambda x: "'%s'" % x,
+    unicode: lambda x: "'%s'" % x,
+    float: lambda x: "%.8f" % x,
+    int: lambda x: "%s" % x,
+    type(None): lambda x: "NULL",
+    np.float64: lambda x: "%.10f" % x,
+    bool: lambda x: "'%s'" % x,
+}
+
+def format_query(sql, *args):
+    """
+
+    """
+    processed_args = []
+    for arg in args:
+        if isinstance(arg, float) and isnull(arg):
+            arg = None
+
+        formatter = _formatters[type(arg)]
+        processed_args.append(formatter(arg))
+
+    return sql % tuple(processed_args)
+
+def _skip_if_no_MySQLdb():
+    try:
+        import MySQLdb
+    except ImportError:
+        raise nose.SkipTest('MySQLdb not installed, skipping')
 
 class TestSQLite(unittest.TestCase):
-    _multiprocess_can_split_ = True
 
     def setUp(self):
         self.db = sqlite3.connect(':memory:')
@@ -23,14 +59,15 @@ class TestSQLite(unittest.TestCase):
     def test_write_row_by_row(self):
         frame = tm.makeTimeDataFrame()
         frame.ix[0, 0] = np.nan
-        create_sql = sql.get_sqlite_schema(frame, 'test')
-        self.db.execute(create_sql)
+        create_sql = sql.get_schema(frame, 'test', 'sqlite')
+        cur = self.db.cursor()
+        cur.execute(create_sql)
 
         cur = self.db.cursor()
 
         ins = "INSERT INTO test VALUES (%s, %s, %s, %s)"
         for idx, row in frame.iterrows():
-            fmt_sql = sql.format_query(ins, *row)
+            fmt_sql = format_query(ins, *row)
             sql.tquery(fmt_sql, cur=cur)
 
         self.db.commit()
@@ -41,8 +78,9 @@ class TestSQLite(unittest.TestCase):
 
     def test_execute(self):
         frame = tm.makeTimeDataFrame()
-        create_sql = sql.get_sqlite_schema(frame, 'test')
-        self.db.execute(create_sql)
+        create_sql = sql.get_schema(frame, 'test', 'sqlite')
+        cur = self.db.cursor()
+        cur.execute(create_sql)
         ins = "INSERT INTO test VALUES (?, ?, ?, ?)"
 
         row = frame.ix[0]
@@ -55,7 +93,7 @@ class TestSQLite(unittest.TestCase):
 
     def test_schema(self):
         frame = tm.makeTimeDataFrame()
-        create_sql = sql.get_sqlite_schema(frame, 'test', {'A': 'DATETIME'})
+        create_sql = sql.get_schema(frame, 'test', 'sqlite')
         lines = create_sql.splitlines()
         for l in lines:
             tokens = l.split(' ')
@@ -63,10 +101,11 @@ class TestSQLite(unittest.TestCase):
                 self.assert_(tokens[1] == 'DATETIME')
 
         frame = tm.makeTimeDataFrame()
-        create_sql = sql.get_sqlite_schema(frame, 'test', keys=['A', 'B'])
+        create_sql = sql.get_schema(frame, 'test', 'sqlite', keys=['A', 'B'],)
         lines = create_sql.splitlines()
         self.assert_('PRIMARY KEY (A,B)' in create_sql)
-        self.db.execute(create_sql)
+        cur = self.db.cursor()
+        cur.execute(create_sql)
 
     def test_execute_fail(self):
         create_sql = """
@@ -78,7 +117,8 @@ class TestSQLite(unittest.TestCase):
         PRIMARY KEY (a, b)
         );
         """
-        self.db.execute(create_sql)
+        cur = self.db.cursor()
+        cur.execute(create_sql)
 
         sql.execute('INSERT INTO test VALUES("foo", "bar", 1.234)', self.db)
         sql.execute('INSERT INTO test VALUES("foo", "baz", 2.567)', self.db)
@@ -101,7 +141,8 @@ class TestSQLite(unittest.TestCase):
         PRIMARY KEY (a, b)
         );
         """
-        self.db.execute(create_sql)
+        cur = self.db.cursor()
+        cur.execute(create_sql)
 
         sql.execute('INSERT INTO test VALUES("foo", "bar", 1.234)', self.db)
         self.db.close()
@@ -174,13 +215,237 @@ class TestSQLite(unittest.TestCase):
     def test_keyword_as_column_names(self):
         '''
         '''
-        df = DataFrame({'From': np.ones(5)})
-        # print sql.get_sqlite_schema(df, 'testkeywords')
-        sql.write_frame(df, con=self.db, name='testkeywords')
+        df = DataFrame({'From':np.ones(5)})
+        sql.write_frame(df, con = self.db, name = 'testkeywords')
+
+
+class TestMySQL(unittest.TestCase):
+
+    def setUp(self):
+        try:
+            import MySQLdb
+        except ImportError:
+            raise nose.SkipTest
+        try:
+            self.db = MySQLdb.connect(read_default_group='pandas')
+        except MySQLdb.Error, e:
+            raise nose.SkipTest(
+                "Cannot connect to database. "
+                "Create a group of connection parameters under the heading "
+                "[pandas] in your system's mysql default file, "
+                "typically located at ~/.my.cnf or /etc/.my.cnf. ")
+        except MySQLdb.ProgrammingError, e:
+            raise nose.SkipTest(
+                "Create a group of connection parameters under the heading "
+                "[pandas] in your system's mysql default file, "
+                "typically located at ~/.my.cnf or /etc/.my.cnf. ")
+
+    def test_basic(self):
+        _skip_if_no_MySQLdb()
+        frame = tm.makeTimeDataFrame()
+        self._check_roundtrip(frame)
+
+    def test_write_row_by_row(self):
+        _skip_if_no_MySQLdb()
+        frame = tm.makeTimeDataFrame()
+        frame.ix[0, 0] = np.nan
+        drop_sql = "DROP TABLE IF EXISTS test"
+        create_sql = sql.get_schema(frame, 'test', 'mysql')
+        cur = self.db.cursor()
+        cur.execute(drop_sql)
+        cur.execute(create_sql)
+        ins = "INSERT INTO test VALUES (%s, %s, %s, %s)"
+        for idx, row in frame.iterrows():
+            fmt_sql = format_query(ins, *row)
+            sql.tquery(fmt_sql, cur=cur)
+
+        self.db.commit()
+
+        result = sql.read_frame("select * from test", con=self.db)
+        result.index = frame.index
+        tm.assert_frame_equal(result, frame)
+
+    def test_execute(self):
+        _skip_if_no_MySQLdb()
+        frame = tm.makeTimeDataFrame()
+        drop_sql = "DROP TABLE IF EXISTS test"
+        create_sql = sql.get_schema(frame, 'test', 'mysql')
+        cur = self.db.cursor()
+        cur.execute(drop_sql)
+        cur.execute(create_sql)
+        ins = "INSERT INTO test VALUES (%s, %s, %s, %s)"
+
+        row = frame.ix[0]
+        sql.execute(ins, self.db, params=tuple(row))
+        self.db.commit()
+
+        result = sql.read_frame("select * from test", self.db)
+        result.index = frame.index[:1]
+        tm.assert_frame_equal(result, frame[:1])
+
+    def test_schema(self):
+        _skip_if_no_MySQLdb()
+        frame = tm.makeTimeDataFrame()
+        create_sql = sql.get_schema(frame, 'test', 'mysql')
+        lines = create_sql.splitlines()
+        for l in lines:
+            tokens = l.split(' ')
+            if len(tokens) == 2 and tokens[0] == 'A':
+                self.assert_(tokens[1] == 'DATETIME')
+
+        frame = tm.makeTimeDataFrame()
+        drop_sql = "DROP TABLE IF EXISTS test"
+        create_sql = sql.get_schema(frame, 'test', 'mysql', keys=['A', 'B'],)
+        lines = create_sql.splitlines()
+        self.assert_('PRIMARY KEY (A,B)' in create_sql)
+        cur = self.db.cursor()
+        cur.execute(drop_sql)
+        cur.execute(create_sql)
+
+    def test_execute_fail(self):
+        _skip_if_no_MySQLdb()
+        drop_sql = "DROP TABLE IF EXISTS test"
+        create_sql = """
+        CREATE TABLE test
+        (
+        a TEXT,
+        b TEXT,
+        c REAL,
+        PRIMARY KEY (a(5), b(5))
+        );
+        """
+        cur = self.db.cursor()
+        cur.execute(drop_sql)
+        cur.execute(create_sql)
+
+        sql.execute('INSERT INTO test VALUES("foo", "bar", 1.234)', self.db)
+        sql.execute('INSERT INTO test VALUES("foo", "baz", 2.567)', self.db)
+
+        try:
+            sys.stdout = StringIO()
+            self.assertRaises(Exception, sql.execute,
+                              'INSERT INTO test VALUES("foo", "bar", 7)',
+                              self.db)
+        finally:
+            sys.stdout = sys.__stdout__
+
+    def test_execute_closed_connection(self):
+        _skip_if_no_MySQLdb()
+        drop_sql = "DROP TABLE IF EXISTS test"
+        create_sql = """
+        CREATE TABLE test
+        (
+        a TEXT,
+        b TEXT,
+        c REAL,
+        PRIMARY KEY (a(5), b(5))
+        );
+        """
+        cur = self.db.cursor()
+        cur.execute(drop_sql)
+        cur.execute(create_sql)
+
+        sql.execute('INSERT INTO test VALUES("foo", "bar", 1.234)', self.db)
+        self.db.close()
+        try:
+            sys.stdout = StringIO()
+            self.assertRaises(Exception, sql.tquery, "select * from test",
+                              con=self.db)
+        finally:
+            sys.stdout = sys.__stdout__
+
+    def test_na_roundtrip(self):
+        _skip_if_no_MySQLdb()
+        pass
+
+    def _check_roundtrip(self, frame):
+        _skip_if_no_MySQLdb()
+        drop_sql = "DROP TABLE IF EXISTS test_table"
+        cur = self.db.cursor()
+        cur.execute(drop_sql)
+        sql.write_frame(frame, name='test_table', con=self.db, flavor='mysql')
+        result = sql.read_frame("select * from test_table", self.db)
+
+        # HACK!
+        result.index = frame.index
+
+        expected = frame
+        tm.assert_frame_equal(result, expected)
+
+        frame['txt'] = ['a'] * len(frame)
+        frame2 = frame.copy()
+        frame2['Idx'] = Index(range(len(frame2))) + 10
+        drop_sql = "DROP TABLE IF EXISTS test_table2"
+        cur = self.db.cursor()
+        cur.execute(drop_sql)
+        sql.write_frame(frame2, name='test_table2', con=self.db, flavor='mysql')
+        result = sql.read_frame("select * from test_table2", self.db,
+                                index_col='Idx')
+        expected = frame.copy()
+        expected.index = Index(range(len(frame2))) + 10
+        tm.assert_frame_equal(expected, result)
+
+    def test_tquery(self):
+        try:
+            import MySQLdb
+        except ImportError:
+            raise nose.SkipTest
+        frame = tm.makeTimeDataFrame()
+        drop_sql = "DROP TABLE IF EXISTS test_table"
+        cur = self.db.cursor()
+        cur.execute(drop_sql)
+        sql.write_frame(frame, name='test_table', con=self.db, flavor='mysql')
+        result = sql.tquery("select A from test_table", self.db)
+        expected = frame.A
+        result = Series(result, frame.index)
+        tm.assert_series_equal(result, expected)
+
+        try:
+            sys.stdout = StringIO()
+            self.assertRaises(MySQLdb.ProgrammingError, sql.tquery,
+                              'select * from blah', con=self.db)
+
+            self.assertRaises(MySQLdb.ProgrammingError, sql.tquery,
+                              'select * from blah', con=self.db, retry=True)
+        finally:
+            sys.stdout = sys.__stdout__
+
+    def test_uquery(self):
+        try:
+            import MySQLdb
+        except ImportError:
+            raise nose.SkipTest
+        frame = tm.makeTimeDataFrame()
+        drop_sql = "DROP TABLE IF EXISTS test_table"
+        cur = self.db.cursor()
+        cur.execute(drop_sql)
+        sql.write_frame(frame, name='test_table', con=self.db, flavor='mysql')
+        stmt = 'INSERT INTO test_table VALUES(2.314, -123.1, 1.234, 2.3)'
+        self.assertEqual(sql.uquery(stmt, con=self.db), 1)
+
+        try:
+            sys.stdout = StringIO()
+
+            self.assertRaises(MySQLdb.ProgrammingError, sql.tquery,
+                              'insert into blah values (1)', con=self.db)
+
+            self.assertRaises(MySQLdb.ProgrammingError, sql.tquery,
+                              'insert into blah values (1)', con=self.db,
+                              retry=True)
+        finally:
+            sys.stdout = sys.__stdout__
+
+    def test_keyword_as_column_names(self):
+        '''
+        '''
+        _skip_if_no_MySQLdb()
+        df = DataFrame({'From':np.ones(5)})
+        sql.write_frame(df, con = self.db, name = 'testkeywords',
+                        if_exists='replace', flavor='mysql')
+
 
 if __name__ == '__main__':
     # unittest.main()
-    import nose
     # nose.runmodule(argv=[__file__,'-vvs','-x', '--pdb-failure'],
     #                exit=False)
     nose.runmodule(argv=[__file__, '-vvs', '-x', '--pdb', '--pdb-failure'],

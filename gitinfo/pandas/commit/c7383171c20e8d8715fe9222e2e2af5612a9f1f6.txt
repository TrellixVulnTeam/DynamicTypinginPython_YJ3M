commit c7383171c20e8d8715fe9222e2e2af5612a9f1f6
Author: jreback <jeff@reback.net>
Date:   Sun Dec 15 18:50:47 2013 -0500

    BUG: Bug in fillna with Series and a passed series/dict (GH5703)

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 5d40cbe82..0a853938f 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -822,6 +822,7 @@ Bug Fixes
   - Bug in groupby returning non-consistent types when user function returns a ``None``, (:issue:`5592`)
   - Work around regression in numpy 1.7.0 which erroneously raises IndexError from ``ndarray.item`` (:issue:`5666`)
   - Bug in repeated indexing of object with resultant non-unique index (:issue:`5678`)
+  - Bug in fillna with Series and a passed series/dict (:issue:`5703`)
 
 pandas 0.12.0
 -------------
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 253136b9a..5e79d0514 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -1905,7 +1905,16 @@ class NDFrame(PandasObject):
 
             if len(self._get_axis(axis)) == 0:
                 return self
-            if isinstance(value, (dict, com.ABCSeries)):
+
+            if self.ndim == 1 and value is not None:
+                if isinstance(value, (dict, com.ABCSeries)):
+                    from pandas import Series
+                    value = Series(value)
+
+                new_data = self._data.fillna(value, inplace=inplace,
+                                             downcast=downcast)
+
+            elif isinstance(value, (dict, com.ABCSeries)):
                 if axis == 1:
                     raise NotImplementedError('Currently only can fill '
                                               'with dict/Series column '
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index dbad353ba..f1919f1bc 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -664,7 +664,7 @@ class Block(PandasObject):
 
         # if we are passed a scalar None, convert it here
         if not is_list_like(new) and isnull(new):
-            new = np.nan
+            new = self.fill_value
 
         if self._can_hold_element(new):
             new = self._try_cast(new)
@@ -830,7 +830,7 @@ class Block(PandasObject):
             data = data.astype(np.float64)
 
         if fill_value is None:
-            fill_value = np.nan
+            fill_value = self.fill_value
 
         if method in ('krogh', 'piecewise_polynomial', 'pchip'):
             if not index.is_monotonic:
@@ -1196,6 +1196,10 @@ class TimeDeltaBlock(IntBlock):
     _can_hold_na = True
     is_numeric = False
 
+    @property
+    def fill_value(self):
+        return tslib.iNaT
+
     def _try_fill(self, value):
         """ if we are a NaT, return the actual fill value """
         if isinstance(value, type(tslib.NaT)) or isnull(value):
@@ -1532,6 +1536,10 @@ class DatetimeBlock(Block):
             result = lib.Timestamp(result)
         return result
 
+    @property
+    def fill_value(self):
+        return tslib.iNaT
+
     def _try_fill(self, value):
         """ if we are a NaT, return the actual fill value """
         if isinstance(value, type(tslib.NaT)) or isnull(value):
@@ -3183,6 +3191,13 @@ class BlockManager(PandasObject):
         new_axes = [new_items] + self.axes[1:]
 
         # could have so me pathological (MultiIndex) issues here
+        def _valid_blocks(newb):
+            if newb is None:
+                return []
+            if not isinstance(newb, list):
+                newb = [ newb ]
+            return [ b for b in newb if len(b.items) > 0 ]
+
         new_blocks = []
         if indexer is None:
             for blk in self.blocks:
@@ -3190,18 +3205,15 @@ class BlockManager(PandasObject):
                     blk = blk.reindex_items_from(new_items)
                 else:
                     blk.ref_items = new_items
-                if blk is not None:
-                    new_blocks.append(blk)
+                new_blocks.extend(_valid_blocks(blk))
         else:
 
             # unique
             if self.axes[0].is_unique and new_items.is_unique:
 
                 for block in self.blocks:
-
-                    newb = block.reindex_items_from(new_items, copy=copy)
-                    if newb is not None and len(newb.items) > 0:
-                        new_blocks.append(newb)
+                    blk = block.reindex_items_from(new_items, copy=copy)
+                    new_blocks.extend(_valid_blocks(blk))
 
             # non-unique
             else:
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index d3104cdfa..9c0f0ff36 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -2760,6 +2760,29 @@ class TestSeries(tm.TestCase, CheckNameIntegration):
         self.assertRaises(ValueError, ts.fillna)
         self.assertRaises(ValueError, self.ts.fillna, value=0, method='ffill')
 
+        # GH 5703
+        s1 = Series([np.nan])
+        s2 = Series([1])
+        result = s1.fillna(s2)
+        expected = Series([1.])
+        assert_series_equal(result,expected)
+        result = s1.fillna({})
+        assert_series_equal(result,s1)
+        result = s1.fillna(Series(()))
+        assert_series_equal(result,s1)
+        result = s2.fillna(s1)
+        assert_series_equal(result,s2)
+        result = s1.fillna({ 0 : 1})
+        assert_series_equal(result,expected)
+        result = s1.fillna({ 1 : 1})
+        assert_series_equal(result,Series([np.nan]))
+        result = s1.fillna({ 0 : 1, 1 : 1})
+        assert_series_equal(result,expected)
+        result = s1.fillna(Series({ 0 : 1, 1 : 1}))
+        assert_series_equal(result,expected)
+        result = s1.fillna(Series({ 0 : 1, 1 : 1},index=[4,5]))
+        assert_series_equal(result,s1)
+
     def test_fillna_bug(self):
         x = Series([nan, 1., nan, 3., nan], ['z', 'a', 'b', 'c', 'd'])
         filled = x.fillna(method='ffill')

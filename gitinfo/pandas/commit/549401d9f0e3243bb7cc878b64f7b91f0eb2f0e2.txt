commit 549401d9f0e3243bb7cc878b64f7b91f0eb2f0e2
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Sep 5 18:02:16 2011 -0400

    ENH: stacking starting with MultiIndex implemented, more unit testing needed

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 96c1dacfa..0e869761c 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1656,7 +1656,7 @@ class DataFrame(NDFrame):
             unstacked.columns = unstacked.columns.droplevel(0)
         return unstacked
 
-    def stack(self):
+    def stack(self, level=-1):
         """
         Convert DataFrame to Series with multi-level Index. Columns become the
         second level of the resulting hierarchical index
@@ -1665,13 +1665,83 @@ class DataFrame(NDFrame):
         -------
         stacked : Series
         """
-        # TODO: what if already have MultiIndex?
+        if isinstance(self.columns, MultiIndex):
+            return self._stack_multi(level=level)
+
         N, K = len(self.index), len(self.columns)
         ilabels = np.arange(N).repeat(K)
         clabels = np.tile(np.arange(K), N).ravel()
-        index = MultiIndex(levels=[self.index, self.columns],
-                           labels=[ilabels, clabels])
-        return Series(self.values.ravel(), index=index)
+        new_index = MultiIndex(levels=[self.index, self.columns],
+                               labels=[ilabels, clabels])
+        return Series(self.values.ravel(), index=new_index)
+
+    def _stack_multi(self, level=-1):
+        import itertools
+        this = self
+        if level < 0:
+            level += self.columns.nlevels
+
+        # this makes life much simpler
+        if level != self.columns.nlevels - 1:
+            last = self.columns.nlevels - 1
+            this.columns = this.columns.swaplevel(level, last)
+
+        if not this.columns.is_lexsorted:
+            this = this.sortlevel(0, axis=1)
+
+        # tuple list excluding level for grouping columns
+        if len(self.columns.levels) > 2:
+            tuples = zip(*[lev.values.take(lab)
+                           for lev, lab in zip(this.columns.levels[:-1],
+                                               this.columns.labels[:-1])])
+            unique_groups = [key for key, _ in itertools.groupby(tuples)]
+            new_names = this.columns.names[:-1]
+            new_columns = MultiIndex.from_tuples(unique_groups, names=new_names)
+        else:
+            new_columns = unique_groups = this.columns.levels[0]
+
+        # time to ravel the values
+        new_data = {}
+        level_vals = this.columns.levels[-1]
+        levsize = len(level_vals)
+        for key in unique_groups:
+            loc = this.columns.get_loc(key)
+
+            # can make more efficient?
+            if loc.stop - loc.start != levsize:
+                chunk = this.ix[:, this.columns[loc]]
+                chunk.columns = level_vals.take(chunk.columns.labels[-1])
+                value_slice = chunk.reindex(columns=level_vals).value
+            else:
+                if self._is_mixed_type:
+                    value_slice = this.ix[:, this.columns[loc]].values
+                else:
+                    value_slice = this.values[:, loc]
+
+            new_data[key] = value_slice.ravel()
+
+        N = len(this)
+
+        if isinstance(this.index, MultiIndex):
+            new_levels = list(this.index.levels)
+            new_names = list(this.index.names)
+            new_labels = [lab.repeat(levsize) for lab in this.index.labels]
+        else:
+            new_levels = [this.index]
+            new_labels = [np.arange(N).repeat(levsize)]
+            new_names = ['index'] # something better?
+
+        new_levels.append(self.columns.levels[level])
+        new_labels.append(np.tile(np.arange(levsize), N))
+        new_names.append(self.columns.names[level])
+
+        new_index = MultiIndex(levels=new_levels, labels=new_labels,
+                               names=new_names)
+
+        result = DataFrame(new_data, index=new_index, columns=new_columns)
+        # more efficient way to go about this?
+        result = result.dropna(axis=0, how='all')
+        return result
 
     def unstack(self, level=-1):
         """
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 21e5c1cbc..423a01fef 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -763,6 +763,25 @@ class MultiIndex(Index):
         else:
             return MultiIndex(levels=new_levels, labels=new_labels)
 
+    def swaplevel(self, i, j):
+        """
+        Swap level i with level j. Do not change the ordering of anything
+
+        Returns
+        -------
+        swapped : MultiIndex
+        """
+        new_levels = list(self.levels)
+        new_labels = list(self.labels)
+        new_names = list(self.names)
+
+        new_levels[i], new_levels[j] = new_levels[j], new_levels[i]
+        new_labels[i], new_labels[j] = new_labels[j], new_labels[i]
+        new_names[i], new_names[j] = new_names[j], new_names[i]
+
+        return MultiIndex(levels=new_levels, labels=new_labels,
+                          names=new_names)
+
     def __getslice__(self, i, j):
         return self.__getitem__(slice(i, j))
 
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 9c6ab511e..47619486b 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -234,6 +234,11 @@ class TestMultiLevel(unittest.TestCase):
         unstacked = self.ymd.unstack()
         unstacked2 = unstacked.unstack()
 
+    def test_stack_roundtrip(self):
+        unstacked = self.ymd.unstack()
+        restacked = unstacked.stack()
+        assert_frame_equal(restacked, self.ymd)
+
     def test_insert_index(self):
         df = self.ymd[:5].T
         df[2000, 1, 10] = df[2000, 1, 7]

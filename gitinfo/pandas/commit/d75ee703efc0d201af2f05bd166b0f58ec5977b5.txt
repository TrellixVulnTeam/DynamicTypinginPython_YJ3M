commit d75ee703efc0d201af2f05bd166b0f58ec5977b5
Author: William Ayd <william.ayd@gmail.com>
Date:   Sat Aug 24 00:38:17 2019 +0200

    Remove Encoding of values in char** For Labels (#27618)

diff --git a/doc/source/whatsnew/v1.0.0.rst b/doc/source/whatsnew/v1.0.0.rst
index 4decc9908..8e25857e5 100644
--- a/doc/source/whatsnew/v1.0.0.rst
+++ b/doc/source/whatsnew/v1.0.0.rst
@@ -159,6 +159,7 @@ I/O
 ^^^
 
 - :meth:`read_csv` now accepts binary mode file buffers when using the Python csv engine (:issue:`23779`)
+- Bug in :meth:`DataFrame.to_json` where using a Tuple as a column or index value and using ``orient="columns"`` or ``orient="index"`` would produce invalid JSON (:issue:`20500`)
 -
 
 Plotting
diff --git a/pandas/_libs/src/ujson/lib/ultrajson.h b/pandas/_libs/src/ujson/lib/ultrajson.h
index 0470fef45..ee6e7081b 100644
--- a/pandas/_libs/src/ujson/lib/ultrajson.h
+++ b/pandas/_libs/src/ujson/lib/ultrajson.h
@@ -307,11 +307,4 @@ EXPORTFUNCTION JSOBJ JSON_DecodeObject(JSONObjectDecoder *dec,
                                        const char *buffer, size_t cbBuffer);
 EXPORTFUNCTION void encode(JSOBJ, JSONObjectEncoder *, const char *, size_t);
 
-#define Buffer_Reserve(__enc, __len)                                  \
-    if ((size_t)((__enc)->end - (__enc)->offset) < (size_t)(__len)) { \
-        Buffer_Realloc((__enc), (__len));                             \
-    }
-
-void Buffer_Realloc(JSONObjectEncoder *enc, size_t cbNeeded);
-
 #endif  // PANDAS__LIBS_SRC_UJSON_LIB_ULTRAJSON_H_
diff --git a/pandas/_libs/src/ujson/lib/ultrajsonenc.c b/pandas/_libs/src/ujson/lib/ultrajsonenc.c
index 2d6c823a4..d5b379bee 100644
--- a/pandas/_libs/src/ujson/lib/ultrajsonenc.c
+++ b/pandas/_libs/src/ujson/lib/ultrajsonenc.c
@@ -714,6 +714,12 @@ int Buffer_EscapeStringValidated(JSOBJ obj, JSONObjectEncoder *enc,
     }
 }
 
+#define Buffer_Reserve(__enc, __len) \
+    if ( (size_t) ((__enc)->end - (__enc)->offset) < (size_t) (__len))  \
+    {   \
+      Buffer_Realloc((__enc), (__len));\
+    }   \
+
 #define Buffer_AppendCharUnchecked(__enc, __chr) *((__enc)->offset++) = __chr;
 
 FASTCALL_ATTR INLINE_PREFIX void FASTCALL_MSVC strreverse(char *begin,
diff --git a/pandas/_libs/src/ujson/python/objToJSON.c b/pandas/_libs/src/ujson/python/objToJSON.c
index 926440218..de336fb3a 100644
--- a/pandas/_libs/src/ujson/python/objToJSON.c
+++ b/pandas/_libs/src/ujson/python/objToJSON.c
@@ -48,13 +48,13 @@ http://www.opensource.apple.com/source/tcl/tcl-14/tcl/license.terms
 #include <../../../tslibs/src/datetime/np_datetime_strings.h>
 #include "datetime.h"
 
-#define NPY_JSON_BUFSIZE 32768
-
 static PyTypeObject *type_decimal;
 static PyTypeObject *cls_dataframe;
 static PyTypeObject *cls_series;
 static PyTypeObject *cls_index;
 static PyTypeObject *cls_nat;
+PyObject *cls_timestamp;
+PyObject *cls_timedelta;
 
 npy_int64 get_nat(void) { return NPY_MIN_INT64; }
 
@@ -166,6 +166,8 @@ void *initObjToJSON(void)
         cls_index = (PyTypeObject *)PyObject_GetAttrString(mod_pandas, "Index");
         cls_series =
             (PyTypeObject *)PyObject_GetAttrString(mod_pandas, "Series");
+        cls_timestamp = PyObject_GetAttrString(mod_pandas, "Timestamp");
+	cls_timedelta = PyObject_GetAttrString(mod_pandas, "Timedelta");
         Py_DECREF(mod_pandas);
     }
 
@@ -787,30 +789,23 @@ JSOBJ NpyArr_iterGetValue(JSOBJ obj, JSONTypeContext *tc) {
     return GET_TC(tc)->itemValue;
 }
 
-static void NpyArr_getLabel(JSOBJ obj, JSONTypeContext *tc, size_t *outLen,
-                            npy_intp idx, char **labels) {
-    JSONObjectEncoder *enc = (JSONObjectEncoder *)tc->encoder;
-    PRINTMARK();
-    *outLen = strlen(labels[idx]);
-    Buffer_Reserve(enc, *outLen);
-    memcpy(enc->offset, labels[idx], sizeof(char) * (*outLen));
-    enc->offset += *outLen;
-    *outLen = 0;
-}
-
 char *NpyArr_iterGetName(JSOBJ obj, JSONTypeContext *tc, size_t *outLen) {
     NpyArrContext *npyarr = GET_TC(tc)->npyarr;
     npy_intp idx;
     PRINTMARK();
+    char *cStr;
 
     if (GET_TC(tc)->iterNext == NpyArr_iterNextItem) {
         idx = npyarr->index[npyarr->stridedim] - 1;
-        NpyArr_getLabel(obj, tc, outLen, idx, npyarr->columnLabels);
+	cStr = npyarr->columnLabels[idx];
     } else {
         idx = npyarr->index[npyarr->stridedim - npyarr->inc] - 1;
-        NpyArr_getLabel(obj, tc, outLen, idx, npyarr->rowLabels);
+	cStr = npyarr->rowLabels[idx];
     }
-    return NULL;
+
+    *outLen = strlen(cStr);
+
+    return cStr;
 }
 
 //=============================================================================
@@ -852,19 +847,22 @@ char *PdBlock_iterGetName(JSOBJ obj, JSONTypeContext *tc, size_t *outLen) {
     PdBlockContext *blkCtxt = GET_TC(tc)->pdblock;
     NpyArrContext *npyarr = blkCtxt->npyCtxts[0];
     npy_intp idx;
+    char *cStr;
     PRINTMARK();
 
     if (GET_TC(tc)->iterNext == PdBlock_iterNextItem) {
         idx = blkCtxt->colIdx - 1;
-        NpyArr_getLabel(obj, tc, outLen, idx, npyarr->columnLabels);
+	cStr = npyarr->columnLabels[idx];
     } else {
         idx = GET_TC(tc)->iterNext != PdBlock_iterNext
                   ? npyarr->index[npyarr->stridedim - npyarr->inc] - 1
                   : npyarr->index[npyarr->stridedim];
 
-        NpyArr_getLabel(obj, tc, outLen, idx, npyarr->rowLabels);
+	cStr = npyarr->rowLabels[idx];
     }
-    return NULL;
+
+    *outLen = strlen(cStr);
+    return cStr;
 }
 
 char *PdBlock_iterGetName_Transpose(JSOBJ obj, JSONTypeContext *tc,
@@ -872,16 +870,19 @@ char *PdBlock_iterGetName_Transpose(JSOBJ obj, JSONTypeContext *tc,
     PdBlockContext *blkCtxt = GET_TC(tc)->pdblock;
     NpyArrContext *npyarr = blkCtxt->npyCtxts[blkCtxt->colIdx];
     npy_intp idx;
+    char *cStr;
     PRINTMARK();
 
     if (GET_TC(tc)->iterNext == NpyArr_iterNextItem) {
         idx = npyarr->index[npyarr->stridedim] - 1;
-        NpyArr_getLabel(obj, tc, outLen, idx, npyarr->columnLabels);
+	cStr = npyarr->columnLabels[idx];
     } else {
         idx = blkCtxt->colIdx;
-        NpyArr_getLabel(obj, tc, outLen, idx, npyarr->rowLabels);
+	cStr = npyarr->rowLabels[idx];
     }
-    return NULL;
+
+    *outLen = strlen(cStr);
+    return cStr;
 }
 
 int PdBlock_iterNext(JSOBJ obj, JSONTypeContext *tc) {
@@ -1578,16 +1579,30 @@ void NpyArr_freeLabels(char **labels, npy_intp len) {
     }
 }
 
-char **NpyArr_encodeLabels(PyArrayObject *labels, JSONObjectEncoder *enc,
+/*
+ * Function: NpyArr_encodeLabels
+ * -----------------------------
+ *
+ * Builds an array of "encoded" labels.
+ *
+ * labels: PyArrayObject pointer for labels to be "encoded"
+ * num : number of labels
+ *
+ * "encode" is quoted above because we aren't really doing encoding
+ * For historical reasons this function would actually encode the entire
+ * array into a separate buffer with a separate call to JSON_Encode
+ * and would leave it to complex pointer manipulation from there to
+ * unpack values as needed. To make things simpler and more idiomatic
+ * this has instead just stringified any input save for datetime values,
+ * which may need to be represented in various formats.
+ */
+char **NpyArr_encodeLabels(PyArrayObject *labels, PyObjectEncoder *enc,
                            npy_intp num) {
     // NOTE this function steals a reference to labels.
-    PyObjectEncoder *pyenc = (PyObjectEncoder *)enc;
     PyObject *item = NULL;
-    npy_intp i, stride, len, need_quotes;
+    npy_intp i, stride, len;
     char **ret;
-    char *dataptr, *cLabel, *origend, *origst, *origoffset;
-    char labelBuffer[NPY_JSON_BUFSIZE];
-    PyArray_GetItemFunc *getitem;
+    char *dataptr, *cLabel;
     int type_num;
     PRINTMARK();
 
@@ -1614,68 +1629,136 @@ char **NpyArr_encodeLabels(PyArrayObject *labels, JSONObjectEncoder *enc,
         ret[i] = NULL;
     }
 
-    origst = enc->start;
-    origend = enc->end;
-    origoffset = enc->offset;
-
     stride = PyArray_STRIDE(labels, 0);
     dataptr = PyArray_DATA(labels);
-    getitem = (PyArray_GetItemFunc *)PyArray_DESCR(labels)->f->getitem;
     type_num = PyArray_TYPE(labels);
 
     for (i = 0; i < num; i++) {
-        if (PyTypeNum_ISDATETIME(type_num) || PyTypeNum_ISNUMBER(type_num))
-        {
-            item = (PyObject *)labels;
-            pyenc->npyType = type_num;
-            pyenc->npyValue = dataptr;
-        } else {
-            item = getitem(dataptr, labels);
-            if (!item) {
-                NpyArr_freeLabels(ret, num);
-                ret = 0;
-                break;
-            }
-        }
-
-        cLabel = JSON_EncodeObject(item, enc, labelBuffer, NPY_JSON_BUFSIZE);
-
-        if (item != (PyObject *)labels) {
-            Py_DECREF(item);
-        }
-
-        if (PyErr_Occurred() || enc->errorMsg) {
+      item = PyArray_GETITEM(labels, dataptr);
+        if (!item) {
+	  NpyArr_freeLabels(ret, num);
+	  ret = 0;
+	  break;
+	}
+
+	// TODO: for any matches on type_num (date and timedeltas) should use a
+	// vectorized solution to convert to epoch or iso formats
+	if (enc->datetimeIso && (type_num == NPY_TIMEDELTA || PyDelta_Check(item))) {
+	  PyObject *td = PyObject_CallFunction(cls_timedelta, "(O)", item);
+	  if (td == NULL) {
+	    Py_DECREF(item);
+            NpyArr_freeLabels(ret, num);
+            ret = 0;
+            break;
+	  }	  
+
+	  PyObject *iso = PyObject_CallMethod(td, "isoformat", NULL);
+	  Py_DECREF(td);
+	  if (iso == NULL) {
+	    Py_DECREF(item);
+	    NpyArr_freeLabels(ret, num);
+	    ret = 0;
+	    break;
+	  }
+
+	  cLabel = (char *)PyUnicode_AsUTF8(iso);
+	  Py_DECREF(iso);
+	  len = strlen(cLabel);
+	}
+	else if (PyTypeNum_ISDATETIME(type_num) || 
+	    PyDateTime_Check(item) || PyDate_Check(item)) {
+	  PyObject *ts = PyObject_CallFunction(cls_timestamp, "(O)", item);
+	  if (ts == NULL) {
+	    Py_DECREF(item);
+            NpyArr_freeLabels(ret, num);
+            ret = 0;
+            break;
+	  }
+
+	  if (enc->datetimeIso) {
+	    PyObject *iso = PyObject_CallMethod(ts, "isoformat", NULL);
+	    Py_DECREF(ts);
+	    if (iso == NULL) {
+	      Py_DECREF(item);
+	      NpyArr_freeLabels(ret, num);
+	      ret = 0;
+	      break;
+	    }
+
+	    cLabel = (char *)PyUnicode_AsUTF8(iso);
+	    Py_DECREF(iso);
+	    len = strlen(cLabel);
+	  } else {
+	    npy_int64 value;
+	    // TODO: refactor to not duplicate what goes on in beginTypeContext
+	    if (PyObject_HasAttrString(ts, "value")) {
+	      PRINTMARK();
+	      value = get_long_attr(ts, "value");
+	    } else {
+	      PRINTMARK();
+	      value =
+                total_seconds(ts) * 1000000000LL;  // nanoseconds per second
+	    }
+	    Py_DECREF(ts);
+
+	    switch (enc->datetimeUnit) {
+            case NPY_FR_ns:
+	      break;
+            case NPY_FR_us:
+	      value /= 1000LL;
+	      break;
+            case NPY_FR_ms:
+	      value /= 1000000LL;
+	      break;
+            case NPY_FR_s:
+	      value /= 1000000000LL;
+	      break;
+	    default:
+	      Py_DECREF(item);
+	      NpyArr_freeLabels(ret, num);
+	      ret = 0;
+	      break;	      
+	    }
+
+	    char buf[21] = {0};  // 21 chars for 2**63 as string
+	    cLabel = buf;
+	    sprintf(buf, "%" NPY_INT64_FMT, value);
+	    len = strlen(cLabel);
+	  }
+	} else {  // Fallack to string representation
+	  PyObject *str = PyObject_Str(item);
+	  if (str == NULL) {
+	    Py_DECREF(item);
+	    NpyArr_freeLabels(ret, num);
+	    ret = 0;
+	    break;
+	  }
+
+	  cLabel = (char *)PyUnicode_AsUTF8(str);
+	  Py_DECREF(str);	  
+	  len = strlen(cLabel);
+	}
+
+	Py_DECREF(item);
+	// Add 1 to include NULL terminator
+	ret[i] = PyObject_Malloc(len + 1);
+	memcpy(ret[i], cLabel, len + 1);
+
+        if (PyErr_Occurred()) {
             NpyArr_freeLabels(ret, num);
             ret = 0;
             break;
         }
 
-        need_quotes = ((*cLabel) != '"');
-        len = enc->offset - cLabel + 1 + 2 * need_quotes;
-        ret[i] = PyObject_Malloc(sizeof(char) * len);
-
         if (!ret[i]) {
             PyErr_NoMemory();
             ret = 0;
             break;
         }
 
-        if (need_quotes) {
-            ret[i][0] = '"';
-            memcpy(ret[i] + 1, cLabel, sizeof(char) * (len - 4));
-            ret[i][len - 3] = '"';
-        } else {
-            memcpy(ret[i], cLabel, sizeof(char) * (len - 2));
-        }
-        ret[i][len - 2] = ':';
-        ret[i][len - 1] = '\0';
         dataptr += stride;
     }
 
-    enc->start = origst;
-    enc->end = origend;
-    enc->offset = origoffset;
-
     Py_DECREF(labels);
     return ret;
 }
@@ -1972,7 +2055,7 @@ ISITERABLE:
             }
             pc->columnLabelsLen = PyArray_DIM(pc->newObj, 0);
             pc->columnLabels = NpyArr_encodeLabels((PyArrayObject *)values,
-                                                   (JSONObjectEncoder *)enc,
+                                                   enc,
                                                    pc->columnLabelsLen);
             if (!pc->columnLabels) {
                 goto INVALID;
@@ -2075,7 +2158,7 @@ ISITERABLE:
             }
             pc->columnLabelsLen = PyObject_Size(tmpObj);
             pc->columnLabels = NpyArr_encodeLabels((PyArrayObject *)values,
-                                                   (JSONObjectEncoder *)enc,
+                                                   enc,
                                                    pc->columnLabelsLen);
             Py_DECREF(tmpObj);
             if (!pc->columnLabels) {
@@ -2098,7 +2181,7 @@ ISITERABLE:
             pc->rowLabelsLen = PyObject_Size(tmpObj);
             pc->rowLabels =
                 NpyArr_encodeLabels((PyArrayObject *)values,
-                                    (JSONObjectEncoder *)enc, pc->rowLabelsLen);
+                                    enc, pc->rowLabelsLen);
             Py_DECREF(tmpObj);
             tmpObj = (enc->outputFormat == INDEX
                           ? PyObject_GetAttrString(obj, "columns")
@@ -2117,7 +2200,7 @@ ISITERABLE:
             }
             pc->columnLabelsLen = PyObject_Size(tmpObj);
             pc->columnLabels = NpyArr_encodeLabels((PyArrayObject *)values,
-                                                   (JSONObjectEncoder *)enc,
+                                                   enc,
                                                    pc->columnLabelsLen);
             Py_DECREF(tmpObj);
             if (!pc->columnLabels) {
@@ -2429,7 +2512,6 @@ PyObject *objToJSON(PyObject *self, PyObject *args, PyObject *kwargs) {
     PRINTMARK();
     ret = JSON_EncodeObject(oinput, encoder, buffer, sizeof(buffer));
     PRINTMARK();
-
     if (PyErr_Occurred()) {
         PRINTMARK();
         return NULL;
diff --git a/pandas/tests/io/json/test_pandas.py b/pandas/tests/io/json/test_pandas.py
index 9c687f036..9842a706f 100644
--- a/pandas/tests/io/json/test_pandas.py
+++ b/pandas/tests/io/json/test_pandas.py
@@ -1012,60 +1012,70 @@ class TestPandasContainer:
             result = read_json(dumps(data))[["id", infer_word]]
             assert_frame_equal(result, expected)
 
-    def test_date_format_frame(self):
+    @pytest.mark.parametrize(
+        "date,date_unit",
+        [
+            ("20130101 20:43:42.123", None),
+            ("20130101 20:43:42", "s"),
+            ("20130101 20:43:42.123", "ms"),
+            ("20130101 20:43:42.123456", "us"),
+            ("20130101 20:43:42.123456789", "ns"),
+        ],
+    )
+    def test_date_format_frame(self, date, date_unit):
         df = self.tsframe.copy()
 
-        def test_w_date(date, date_unit=None):
-            df["date"] = Timestamp(date)
-            df.iloc[1, df.columns.get_loc("date")] = pd.NaT
-            df.iloc[5, df.columns.get_loc("date")] = pd.NaT
-            if date_unit:
-                json = df.to_json(date_format="iso", date_unit=date_unit)
-            else:
-                json = df.to_json(date_format="iso")
-            result = read_json(json)
-            expected = df.copy()
-            expected.index = expected.index.tz_localize("UTC")
-            expected["date"] = expected["date"].dt.tz_localize("UTC")
-            assert_frame_equal(result, expected)
-
-        test_w_date("20130101 20:43:42.123")
-        test_w_date("20130101 20:43:42", date_unit="s")
-        test_w_date("20130101 20:43:42.123", date_unit="ms")
-        test_w_date("20130101 20:43:42.123456", date_unit="us")
-        test_w_date("20130101 20:43:42.123456789", date_unit="ns")
+        df["date"] = Timestamp(date)
+        df.iloc[1, df.columns.get_loc("date")] = pd.NaT
+        df.iloc[5, df.columns.get_loc("date")] = pd.NaT
+        if date_unit:
+            json = df.to_json(date_format="iso", date_unit=date_unit)
+        else:
+            json = df.to_json(date_format="iso")
+        result = read_json(json)
+        expected = df.copy()
+        # expected.index = expected.index.tz_localize("UTC")
+        expected["date"] = expected["date"].dt.tz_localize("UTC")
+        assert_frame_equal(result, expected)
 
+    def test_date_format_frame_raises(self):
+        df = self.tsframe.copy()
         msg = "Invalid value 'foo' for option 'date_unit'"
         with pytest.raises(ValueError, match=msg):
             df.to_json(date_format="iso", date_unit="foo")
 
-    def test_date_format_series(self):
-        def test_w_date(date, date_unit=None):
-            ts = Series(Timestamp(date), index=self.ts.index)
-            ts.iloc[1] = pd.NaT
-            ts.iloc[5] = pd.NaT
-            if date_unit:
-                json = ts.to_json(date_format="iso", date_unit=date_unit)
-            else:
-                json = ts.to_json(date_format="iso")
-            result = read_json(json, typ="series")
-            expected = ts.copy()
-            expected.index = expected.index.tz_localize("UTC")
-            expected = expected.dt.tz_localize("UTC")
-            assert_series_equal(result, expected)
-
-        test_w_date("20130101 20:43:42.123")
-        test_w_date("20130101 20:43:42", date_unit="s")
-        test_w_date("20130101 20:43:42.123", date_unit="ms")
-        test_w_date("20130101 20:43:42.123456", date_unit="us")
-        test_w_date("20130101 20:43:42.123456789", date_unit="ns")
+    @pytest.mark.parametrize(
+        "date,date_unit",
+        [
+            ("20130101 20:43:42.123", None),
+            ("20130101 20:43:42", "s"),
+            ("20130101 20:43:42.123", "ms"),
+            ("20130101 20:43:42.123456", "us"),
+            ("20130101 20:43:42.123456789", "ns"),
+        ],
+    )
+    def test_date_format_series(self, date, date_unit):
+        ts = Series(Timestamp(date), index=self.ts.index)
+        ts.iloc[1] = pd.NaT
+        ts.iloc[5] = pd.NaT
+        if date_unit:
+            json = ts.to_json(date_format="iso", date_unit=date_unit)
+        else:
+            json = ts.to_json(date_format="iso")
+        result = read_json(json, typ="series")
+        expected = ts.copy()
+        # expected.index = expected.index.tz_localize("UTC")
+        expected = expected.dt.tz_localize("UTC")
+        assert_series_equal(result, expected)
 
+    def test_date_format_series_raises(self):
         ts = Series(Timestamp("20130101 20:43:42.123"), index=self.ts.index)
         msg = "Invalid value 'foo' for option 'date_unit'"
         with pytest.raises(ValueError, match=msg):
             ts.to_json(date_format="iso", date_unit="foo")
 
-    def test_date_unit(self):
+    @pytest.mark.parametrize("unit", ["s", "ms", "us", "ns"])
+    def test_date_unit(self, unit):
         df = self.tsframe.copy()
         df["date"] = Timestamp("20130101 20:43:42")
         dl = df.columns.get_loc("date")
@@ -1073,16 +1083,15 @@ class TestPandasContainer:
         df.iloc[2, dl] = Timestamp("21460101 20:43:42")
         df.iloc[4, dl] = pd.NaT
 
-        for unit in ("s", "ms", "us", "ns"):
-            json = df.to_json(date_format="epoch", date_unit=unit)
+        json = df.to_json(date_format="epoch", date_unit=unit)
 
-            # force date unit
-            result = read_json(json, date_unit=unit)
-            assert_frame_equal(result, df)
+        # force date unit
+        result = read_json(json, date_unit=unit)
+        assert_frame_equal(result, df)
 
-            # detect date unit
-            result = read_json(json, date_unit=None)
-            assert_frame_equal(result, df)
+        # detect date unit
+        result = read_json(json, date_unit=None)
+        assert_frame_equal(result, df)
 
     def test_weird_nested_json(self):
         # this used to core dump the parser
@@ -1611,3 +1620,30 @@ DataFrame\\.index values are different \\(100\\.0 %\\)
         )
         expected = Series([88], index=DatetimeIndex(["2019-01-01 11:00:00"], tz="UTC"))
         assert_series_equal(result, expected)
+
+    @pytest.mark.parametrize(
+        "date_format,key", [("epoch", 86400000), ("iso", "P1DT0H0M0S")]
+    )
+    def test_timedelta_as_label(self, date_format, key):
+        df = pd.DataFrame([[1]], columns=[pd.Timedelta("1D")])
+        expected = '{{"{key}":{{"0":1}}}}'.format(key=key)
+        result = df.to_json(date_format=date_format)
+
+        assert result == expected
+
+    @pytest.mark.parametrize(
+        "orient,expected",
+        [
+            ("index", "{\"('a', 'b')\":{\"('c', 'd')\":1}}"),
+            ("columns", "{\"('c', 'd')\":{\"('a', 'b')\":1}}"),
+            # TODO: the below have separate encoding procedures
+            # They produce JSON but not in a consistent manner
+            pytest.param("split", "", marks=pytest.mark.skip),
+            pytest.param("table", "", marks=pytest.mark.skip),
+        ],
+    )
+    def test_tuple_labels(self, orient, expected):
+        # GH 20500
+        df = pd.DataFrame([[1]], index=[("a", "b")], columns=[("c", "d")])
+        result = df.to_json(orient=orient)
+        assert result == expected

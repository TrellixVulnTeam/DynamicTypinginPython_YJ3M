commit a19ab47cc008d77217f4c3f1d72e4f1e945c5312
Author: Jeffrey Tratner <jeffrey.tratner@gmail.com>
Date:   Fri Jun 28 18:07:12 2013 -0400

    BUG/ENH: Make names, levels and labels properties.
    
    * `names` is now a property *and* is set up as an immutable tuple.
    * `levels` are always (shallow) copied now and it is deprecated to set directly
    * `labels` are set up as a property now, moving all the processing of
      labels out of `__new__` + shallow-copied.
    * `levels` and `labels` are immutable.
    * Add names tests, motivating example from #3742, reflect tuple-ish
      output from names, and level names check to reindex test.
    * Add set_levels, set_labels, set_names and rename to index
    * Deprecate setting labels and levels directly
    
    Similar to other set_* methods...allows mutation if necessary but
    otherwise returns same object.
    
    Labels are now converted to `FrozenNDArray` and wrapped in a
    `FrozenList`. Should mostly resolve #3714 because you have to work to
    actually make assignments to an `Index`.
    
    BUG: Give MultiIndex its own astype method
    
    Fixes issue with set_value forgetting names.

diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index 29a7f84cd..0cfc954e3 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -868,66 +868,6 @@ convert to an integer index:
     df_new[(df_new['index'] >= 1.0) & (df_new['index'] < 2)]
 
 
-.. _indexing.class:
-
-Index objects
--------------
-
-The pandas Index class and its subclasses can be viewed as implementing an
-*ordered set* in addition to providing the support infrastructure necessary for
-lookups, data alignment, and reindexing. The easiest way to create one directly
-is to pass a list or other sequence to ``Index``:
-
-.. ipython:: python
-
-   index = Index(['e', 'd', 'a', 'b'])
-   index
-   'd' in index
-
-You can also pass a ``name`` to be stored in the index:
-
-
-.. ipython:: python
-
-   index = Index(['e', 'd', 'a', 'b'], name='something')
-   index.name
-
-Starting with pandas 0.5, the name, if set, will be shown in the console
-display:
-
-.. ipython:: python
-
-   index = Index(list(range(5)), name='rows')
-   columns = Index(['A', 'B', 'C'], name='cols')
-   df = DataFrame(np.random.randn(5, 3), index=index, columns=columns)
-   df
-   df['A']
-
-
-Set operations on Index objects
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-.. _indexing.set_ops:
-
-The three main operations are ``union (|)``, ``intersection (&)``, and ``diff
-(-)``. These can be directly called as instance methods or used via overloaded
-operators:
-
-.. ipython:: python
-
-   a = Index(['c', 'b', 'a'])
-   b = Index(['c', 'e', 'd'])
-   a.union(b)
-   a | b
-   a & b
-   a - b
-
-``isin`` method of Index objects
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-One additional operation is the ``isin`` method that works analogously to the
-``Series.isin`` method found :ref:`here <indexing.boolean>`.
-
 .. _indexing.hierarchical:
 
 Hierarchical indexing (MultiIndex)
@@ -1189,7 +1129,7 @@ are named.
 
 .. ipython:: python
 
-   s.index.names = ['L1', 'L2']
+   s.index.set_names(['L1', 'L2'], inplace=True)
    s.sortlevel(level='L1')
    s.sortlevel(level='L2')
 
@@ -1276,6 +1216,88 @@ not check (or care) whether the levels themselves are sorted. Fortunately, the
 constructors ``from_tuples`` and ``from_arrays`` ensure that this is true, but
 if you compute the levels and labels yourself, please be careful.
 
+.. _indexing.class:
+
+Index objects
+-------------
+
+The pandas Index class and its subclasses can be viewed as implementing an
+*ordered set* in addition to providing the support infrastructure necessary for
+lookups, data alignment, and reindexing. The easiest way to create one directly
+is to pass a list or other sequence to ``Index``:
+
+.. ipython:: python
+
+   index = Index(['e', 'd', 'a', 'b'])
+   index
+   'd' in index
+
+You can also pass a ``name`` to be stored in the index:
+
+
+.. ipython:: python
+
+   index = Index(['e', 'd', 'a', 'b'], name='something')
+   index.name
+
+Starting with pandas 0.5, the name, if set, will be shown in the console
+display:
+
+.. ipython:: python
+
+   index = Index(list(range(5)), name='rows')
+   columns = Index(['A', 'B', 'C'], name='cols')
+   df = DataFrame(np.random.randn(5, 3), index=index, columns=columns)
+   df
+   df['A']
+
+
+Set operations on Index objects
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. _indexing.set_ops:
+
+The three main operations are ``union (|)``, ``intersection (&)``, and ``diff
+(-)``. These can be directly called as instance methods or used via overloaded
+operators:
+
+.. ipython:: python
+
+   a = Index(['c', 'b', 'a'])
+   b = Index(['c', 'e', 'd'])
+   a.union(b)
+   a | b
+   a & b
+   a - b
+
+``isin`` method of Index objects
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+One additional operation is the ``isin`` method that works analogously to the
+``Series.isin`` method found :ref:`here <indexing.boolean>`.
+
+Setting index metadata (``name(s)``, ``levels``, ``labels``)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. _indexing.set_metadata:
+
+Indexes are "mostly immutable", but it is possible to set and change their
+metadata, like the index ``name`` (or, for ``MultiIndex``, ``levels`` and
+``labels``).
+
+You can use the ``rename``, ``set_names``, ``set_levels``, and ``set_labels``
+to set these attributes directly. They default to returning a copy; however,
+you can specify ``inplace=True`` to have the data change inplace.
+
+.. ipython:: python
+
+  ind = Index([1, 2, 3])
+  ind.rename("apple")
+  ind
+  ind.set_names(["apple"], inplace=True)
+  ind.name = "bob"
+  ind
+
 Adding an index to an existing DataFrame
 ----------------------------------------
 
diff --git a/doc/source/release.rst b/doc/source/release.rst
index 769b47b18..58dcce9b9 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -47,6 +47,9 @@ pandas 0.13
   - Added a more informative error message when plot arguments contain
     overlapping color and style arguments (:issue:`4402`)
   - Significant table writing performance improvements in ``HDFStore``
+  - Add ``rename`` and ``set_names`` methods to ``Index`` as well as
+    ``set_names``, ``set_levels``, ``set_labels`` to ``MultiIndex``.
+    (:issue:`4039`)
 
 **API Changes**
 
@@ -66,6 +69,7 @@ pandas 0.13
     an alias of iteritems used to get around ``2to3``'s changes).
     (:issue:`4384`, :issue:`4375`, :issue:`4372`)
   - ``Series.get`` with negative indexers now returns the same as ``[]`` (:issue:`4390`)
+
   - ``HDFStore``
 
     - added an ``is_open`` property to indicate if the underlying file handle is_open;
@@ -83,6 +87,21 @@ pandas 0.13
       be raised if you try to use ``mode='w'`` with an OPEN file handle (:issue:`4367`)
     - allow a passed locations array or mask as a ``where`` condition (:issue:`4467`)
 
+  - ``Index`` and ``MultiIndex`` changes (:issue:`4039`):
+
+    - Setting ``levels`` and ``labels`` directly on ``MultiIndex`` is now
+      deprecated. Instead, you can use the ``set_levels()`` and
+      ``set_labels()`` methods.
+    - ``levels``, ``labels`` and ``names`` properties no longer return lists,
+      but instead return containers that do not allow setting of items
+      ('mostly immutable')
+    - ``levels``, ``labels`` and ``names`` are validated upon setting and are
+      either copied or shallow-copied.
+    - ``__deepcopy__`` now returns a shallow copy (currently: a view) of the
+      data - allowing metadata changes.
+    - ``MultiIndex.astype()`` now only allows ``np.object_``-like dtypes and
+      now returns a ``MultiIndex`` rather than an ``Index``. (:issue:`4039`)
+
 **Experimental Features**
 
 **Bug Fixes**
@@ -136,6 +155,10 @@ pandas 0.13
   - frozenset objects now raise in the ``Series`` constructor (:issue:`4482`,
     :issue:`4480`)
   - Fixed issue with sorting a duplicate multi-index that has multiple dtypes (:issue:`4516`)
+  - Fixed bug in ``DataFrame.set_values`` which was causing name attributes to
+    be lost when expanding the index. (:issue:`3742`, :issue:`4039`)
+  - Fixed issue where individual ``names``, ``levels`` and ``labels`` could be
+    set on ``MultiIndex`` without validation (:issue:`3714`, :issue:`4039`)
 
 pandas 0.12
 ===========
diff --git a/doc/source/v0.13.0.txt b/doc/source/v0.13.0.txt
index 7da2f03ad..05bae7a95 100644
--- a/doc/source/v0.13.0.txt
+++ b/doc/source/v0.13.0.txt
@@ -72,6 +72,24 @@ API changes
          import os
          os.remove(path)
 
+  - Changes to how ``Index`` and ``MultiIndex`` handle metadata (``levels``,
+    ``labels``, and ``names``) (:issue:`4039`):
+
+    ..code-block ::
+
+        # previously, you would have set levels or labels directly
+        index.levels = [[1, 2, 3, 4], [1, 2, 4, 4]]
+
+        # now, you use the set_levels or set_labels methods
+        index = index.set_levels([[1, 2, 3, 4], [1, 2, 4, 4]])
+
+        # similarly, for names, you can rename the object
+        # but setting names is not deprecated.
+        index = index.set_names(["bob", "cranberry"])
+
+        # and all methods take an inplace kwarg
+        index.set_names(["bob", "cranberry"], inplace=True)
+
 Enhancements
 ~~~~~~~~~~~~
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 0f3bcb32f..20a2dab06 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1150,7 +1150,7 @@ class DataFrame(NDFrame):
             arrays = ix_vals+ [self[c].values for c in self.columns]
 
             count = 0
-            index_names = self.index.names
+            index_names = list(self.index.names)
             if isinstance(self.index, MultiIndex):
                 for i, n in enumerate(index_names):
                     if n is None:
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 0eaae228d..2ee7f791c 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -404,7 +404,7 @@ class PandasContainer(PandasObject):
                 new_axis = axis.drop(labels)
             dropped = self.reindex(**{axis_name: new_axis})
             try:
-                dropped.axes[axis_].names = axis.names
+                dropped.axes[axis_].set_names(axis.names, inplace=True)
             except AttributeError:
                 pass
             return dropped
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 3e24788ec..9b7960389 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1,5 +1,5 @@
 # pylint: disable=E1101,E1103,W0232
-
+from functools import partial
 from pandas.compat import range, zip, lrange, lzip
 from pandas import compat
 import numpy as np
@@ -11,10 +11,11 @@ import pandas.index as _index
 from pandas.lib import Timestamp
 from pandas.core.base import FrozenList, FrozenNDArray
 
-from pandas.util.decorators import cache_readonly
+from pandas.util.decorators import cache_readonly, deprecate
 from pandas.core.common import isnull
 import pandas.core.common as com
 from pandas.core.config import get_option
+import warnings
 
 
 __all__ = ['Index']
@@ -38,6 +39,7 @@ def _indexOp(opname):
 class InvalidIndexError(Exception):
     pass
 
+
 _o_dtype = np.dtype(object)
 
 
@@ -129,7 +131,8 @@ class Index(FrozenNDArray):
                     return PeriodIndex(subarr, name=name, **kwargs)
 
         subarr = subarr.view(cls)
-        subarr.name = name
+        # could also have a _set_name, but I don't think it's really necessary
+        subarr._set_names([name])
         return subarr
 
     def __array_finalize__(self, obj):
@@ -197,7 +200,7 @@ class Index(FrozenNDArray):
     # for compat with multindex code
 
     def _get_names(self):
-        return [self.name]
+        return FrozenList((self.name,))
 
     def _set_names(self, values):
         if len(values) != 1:
@@ -207,6 +210,31 @@ class Index(FrozenNDArray):
 
     names = property(fset=_set_names, fget=_get_names)
 
+    def set_names(self, names, inplace=False):
+        """
+        Set new names on index. Defaults to returning new index.
+
+        Parameters
+        ----------
+        names : sequence
+            names to set
+        inplace : bool
+            if True, mutates in place
+
+        Returns
+        -------
+        new index (of same type and class...etc)
+        """
+        if inplace:
+            idx = self
+        else:
+            idx = self._shallow_copy()
+        idx._set_names(names)
+        return idx
+
+    def rename(self, name, inplace=False):
+        return self.set_names([name], inplace=inplace)
+
     @property
     def _has_complex_internals(self):
         # to disable groupby tricks in MultiIndex
@@ -761,7 +789,8 @@ class Index(FrozenNDArray):
         -------
         values : ndarray
         """
-        num = self._get_level_number(level)
+        # checks that level number is actually just 1
+        self._get_level_number(level)
         return self
 
     def get_indexer(self, target, method=None, limit=None):
@@ -804,8 +833,8 @@ class Index(FrozenNDArray):
             return this.get_indexer(target, method=method, limit=limit)
 
         if not self.is_unique:
-            raise InvalidIndexError('Reindexing only valid with uniquely valued Index '
-                            'objects')
+            raise InvalidIndexError('Reindexing only valid with uniquely'
+                                    ' valued Index objects')
 
         if method == 'pad':
             if not self.is_monotonic:
@@ -1421,8 +1450,10 @@ class MultiIndex(Index):
     names : optional sequence of objects
         Names for each of the index levels.
     """
-    # shadow property
-    names = None
+    # initialize to zero-length tuples to make everything work
+    _names = FrozenList()
+    _levels = FrozenList()
+    _labels = FrozenList()
 
     def __new__(cls, levels=None, labels=None, sortorder=None, names=None):
         if len(levels) != len(labels):
@@ -1438,26 +1469,14 @@ class MultiIndex(Index):
 
             return Index(levels[0], name=name).take(labels[0])
 
-        levels = [_ensure_index(lev) for lev in levels]
-        labels = [np.asarray(labs, dtype=np.int_) for labs in labels]
-
         # v3, 0.8.0
         subarr = np.empty(0, dtype=object).view(cls)
-        subarr.levels = levels
-        subarr.labels = labels
+        subarr._set_levels(levels)
+        subarr._set_labels(labels)
 
-        if names is None:
-            subarr.names = [None] * subarr.nlevels
-        else:
-            if len(names) != subarr.nlevels:
-                raise AssertionError(('Length of names (%d) must be same as level '
-                                      '(%d)') % (len(names),subarr.nlevels))
+        if names is not None:
+            subarr._set_names(names)
 
-            subarr.names = list(names)
-
-        # set the name
-        for i, name in enumerate(subarr.names):
-            subarr.levels[i].name = name
 
         if sortorder is not None:
             subarr.sortorder = int(sortorder)
@@ -1466,6 +1485,123 @@ class MultiIndex(Index):
 
         return subarr
 
+    def _get_levels(self):
+        return self._levels
+
+
+    def _set_levels(self, levels):
+        # This is NOT part of the levels property because it should be
+        # externally not allowed to set levels. User beware if you change
+        # _levels directly
+        if len(levels) == 0:
+            raise ValueError("Must set non-zero number of levels.")
+        levels = FrozenList(_ensure_index(lev)._shallow_copy()
+                            for lev in levels)
+        names = self.names
+        self._levels = levels
+        if len(names):
+            self._set_names(names)
+
+    def set_levels(self, levels, inplace=False):
+        """
+        Set new levels on MultiIndex. Defaults to returning
+        new index.
+
+        Parameters
+        ----------
+        levels : sequence
+            new levels to apply
+        inplace : bool
+            if True, mutates in place
+
+        Returns
+        -------
+        new index (of same type and class...etc)
+        """
+        if inplace:
+            idx = self
+        else:
+            idx = self._shallow_copy()
+        idx._set_levels(levels)
+        return idx
+
+    # remove me in 0.14 and change to read only property
+    __set_levels = deprecate("setting `levels` directly",
+                             partial(set_levels, inplace=True),
+                             alt_name="set_levels")
+    levels = property(fget=_get_levels, fset=__set_levels)
+
+    def _get_labels(self):
+        return self._labels
+
+    def _set_labels(self, labels):
+        if len(labels) != self.nlevels:
+            raise ValueError("Length of levels and labels must be the same.")
+        self._labels = FrozenList(_ensure_frozen(labs)._shallow_copy() for labs in labels)
+
+    def set_labels(self, labels, inplace=False):
+        """
+        Set new labels on MultiIndex. Defaults to returning
+        new index.
+
+        Parameters
+        ----------
+        labels : sequence
+            new levels to apply
+        inplace : bool
+            if True, mutates in place
+
+        Returns
+        -------
+        new index (of same type and class...etc)
+        """
+        if inplace:
+            idx = self
+        else:
+            idx = self._shallow_copy()
+        idx._set_labels(labels)
+        return idx
+
+    # remove me in 0.14 and change to readonly property
+    __set_labels = deprecate("setting labels directly",
+                             partial(set_labels, inplace=True),
+                             alt_name="set_labels")
+    labels = property(fget=_get_labels, fset=__set_labels)
+
+    def copy(self, names=None, dtype=None, levels=None, labels=None,
+             deep=False):
+        """
+        Make a copy of this object. Names, dtype, levels and labels can be
+        passed and will be set on new copy.
+
+        Parameters
+        ----------
+        names : sequence, optional
+        dtype : numpy dtype or pandas type, optional
+        levels : sequence, optional
+        labels : sequence, optional
+
+        Returns
+        -------
+        copy : MultiIndex
+
+        Notes
+        -----
+        In most cases, there should be no functional difference from using
+        ``deep``, but if ``deep`` is passed it will attempt to deepcopy.
+        This could be potentially expensive on large MultiIndex objects.
+        """
+        new_index = np.ndarray.copy(self)
+        if levels is not None:
+            new_index = new_index.set_levels(levels)
+        if labels is not None:
+            new_index = new_index.set_labels(labels)
+        if names is not None:
+            new_index = new_index.set_names(names)
+        if dtype:
+            new_index = new_index.astype(dtype)
+        return new_index
+
     def __array_finalize__(self, obj):
         """
         Update custom MultiIndex attributes when a new array is created by
@@ -1476,9 +1612,9 @@ class MultiIndex(Index):
             # instance.
             return
 
-        self.levels = list(getattr(obj, 'levels', []))
-        self.labels = list(getattr(obj, 'labels', []))
-        self.names = list(getattr(obj, 'names', []))
+        self._set_levels(getattr(obj, 'levels', []))
+        self._set_labels(getattr(obj, 'labels', []))
+        self._set_names(getattr(obj, 'names', []))
         self.sortorder = getattr(obj, 'sortorder', None)
 
     def _array_values(self):
@@ -1505,6 +1641,26 @@ class MultiIndex(Index):
     def __len__(self):
         return len(self.labels[0])
 
+    def _get_names(self):
+        return FrozenList(level.name for level in self.levels)
+
+    def _set_names(self, values):
+        """
+        sets names on levels. WARNING: mutates!
+
+        Note that you generally want to set this *after* changing levels, so that it only
+        acts on copies"""
+        values = list(values)
+        if len(values) != self.nlevels:
+            raise ValueError('Length of names (%d) must be same as level '
+                              '(%d)' % (len(values),self.nlevels))
+        # set the name
+        for name, level in zip(values, self.levels):
+            level.rename(name, inplace=True)
+
+
+    names = property(fset=_set_names, fget=_get_names, doc="Names of levels in MultiIndex")
+
     def _format_native_types(self, **kwargs):
         return self.tolist()
 
@@ -1520,9 +1676,9 @@ class MultiIndex(Index):
     def _from_elements(values, labels=None, levels=None, names=None,
                        sortorder=None):
         index = values.view(MultiIndex)
-        index.levels = levels
-        index.labels = labels
-        index.names = names
+        index._set_levels(levels)
+        index._set_labels(labels)
+        index._set_names(names)
         index.sortorder = sortorder
         return index
 
@@ -1832,9 +1988,9 @@ class MultiIndex(Index):
         np.ndarray.__setstate__(self, nd_state)
         levels, labels, sortorder, names = own_state
 
-        self.levels = [Index(x) for x in levels]
-        self.labels = labels
-        self.names = names
+        self._set_levels([Index(x) for x in levels])
+        self._set_labels(labels)
+        self._set_names(names)
         self.sortorder = sortorder
 
     def __getitem__(self, key):
@@ -1859,10 +2015,10 @@ class MultiIndex(Index):
             new_labels = [lab[key] for lab in self.labels]
 
             # an optimization
-            result.levels = list(self.levels)
-            result.labels = new_labels
+            result._set_levels(self.levels)
+            result._set_labels(new_labels)
             result.sortorder = sortorder
-            result.names = self.names
+            result._set_names(self.names)
 
             return result
 
@@ -2155,7 +2311,6 @@ class MultiIndex(Index):
         """
         if level is not None:
             if method is not None:
-                # FIXME: Should this actually be a TypeError [given that it's a signature issue] or ValueError
                 raise TypeError('Fill method not supported if level passed')
             target, indexer, _ = self._join_level(target, level, how='right',
                                                   return_indexers=True)
@@ -2545,7 +2700,8 @@ class MultiIndex(Index):
             try:
                 other = MultiIndex.from_tuples(other)
             except:
-                raise TypeError("other must be a MultiIndex or a list of tuples")
+                raise TypeError('other must be a MultiIndex or a list of'
+                                ' tuples')
             result_names = self.names
         else:
             result_names = self.names if self.names == other.names else None
@@ -2568,6 +2724,11 @@ class MultiIndex(Index):
     def _assert_can_do_setop(self, other):
         pass
 
+    def astype(self, dtype):
+        if np.dtype(dtype) != np.object_:
+            raise TypeError("Setting %s dtype to anything other than object is not supported" % self.__class__)
+        return self._shallow_copy()
+
     def insert(self, loc, item):
         """
         Make new MultiIndex inserting new item at location
@@ -2676,7 +2837,11 @@ def _ensure_index(index_like):
     if hasattr(index_like, 'name'):
         return Index(index_like, name=index_like.name)
 
+    # must check for exactly list here because of strict type
+    # check in clean_index_list
     if isinstance(index_like, list):
+        if type(index_like) != list:
+            index_like = list(index_like)
         # #2200 ?
         converted, all_arrays = lib.clean_index_list(index_like)
 
@@ -2687,6 +2852,13 @@ def _ensure_index(index_like):
 
     return Index(index_like)
 
+def _ensure_frozen(nd_array_like):
+    if isinstance(nd_array_like, FrozenNDArray):
+        return nd_array_like
+    else:
+        arr = np.asarray(nd_array_like, dtype=np.int_)
+        return arr.view(FrozenNDArray)
+
 
 def _validate_join_method(method):
     if method not in ['left', 'right', 'inner', 'outer']:
diff --git a/pandas/core/reshape.py b/pandas/core/reshape.py
index b69e4a6a9..4596b93d7 100644
--- a/pandas/core/reshape.py
+++ b/pandas/core/reshape.py
@@ -92,8 +92,8 @@ class _Unstacker(object):
     def _make_sorted_values_labels(self):
         v = self.level
 
-        labs = self.index.labels
-        levs = self.index.levels
+        labs = list(self.index.labels)
+        levs = list(self.index.levels)
         to_sort = labs[:v] + labs[v + 1:] + [labs[v]]
         sizes = [len(x) for x in levs[:v] + levs[v + 1:] + [levs[v]]]
 
@@ -206,8 +206,8 @@ class _Unstacker(object):
         width = len(self.value_columns)
         propagator = np.repeat(np.arange(width), stride)
         if isinstance(self.value_columns, MultiIndex):
-            new_levels = self.value_columns.levels + [self.removed_level]
-            new_names = self.value_columns.names + [self.removed_name]
+            new_levels = self.value_columns.levels + (self.removed_level,)
+            new_names = self.value_columns.names + (self.removed_name,)
 
             new_labels = [lab.take(propagator)
                           for lab in self.value_columns.labels]
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index a6c858444..3b132be80 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -774,7 +774,7 @@ class ParserBase(object):
         # add names for the index
         if indexnamerow:
             coffset = len(indexnamerow) - len(columns)
-            index.names = indexnamerow[:coffset]
+            index = index.set_names(indexnamerow[:coffset])
 
         # maybe create a mi on the columns
         columns = self._maybe_make_multi_index_columns(columns, self.col_names)
diff --git a/pandas/io/tests/test_excel.py b/pandas/io/tests/test_excel.py
index 1ac4d4e31..3f41be6ae 100644
--- a/pandas/io/tests/test_excel.py
+++ b/pandas/io/tests/test_excel.py
@@ -675,7 +675,7 @@ class ExcelTests(unittest.TestCase):
             recons = reader.parse('test1', index_col=[0, 1])
 
             tm.assert_frame_equal(tsframe, recons, check_names=False)
-            self.assertEquals(recons.index.names, ['time', 'foo'])
+            self.assertEquals(recons.index.names, ('time', 'foo'))
 
             # infer index
             tsframe.to_excel(path, 'test1')
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index d9a4196a6..41345352b 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -821,7 +821,7 @@ c,4,5
         levels[0] = lev.to_datetime(dayfirst=True)
         # hack to get this to work - remove for final test
         levels[0].name = lev.name
-        expected.index.levels = levels
+        expected.index.set_levels(levels, inplace=True)
         expected['aux_date'] = to_datetime(expected['aux_date'],
                                            dayfirst=True)
         expected['aux_date'] = lmap(Timestamp, expected['aux_date'])
@@ -1339,7 +1339,7 @@ x   q   30      3    -0.6662 -0.5243 -0.3580  0.89145  2.5838"""
 
         # it works!
         df = self.read_table(StringIO(text), sep='\s+')
-        self.assertEquals(df.index.names, ['one', 'two', 'three', 'four'])
+        self.assertEquals(df.index.names, ('one', 'two', 'three', 'four'))
 
     def test_read_csv_parse_simple_list(self):
         text = """foo
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index 9575d9922..3bc32fb3f 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -1921,7 +1921,7 @@ class TestHDFStore(unittest.TestCase):
         with ensure_clean(self.path) as store:
             store['frame'] = frame
             recons = store['frame']
-            assert(recons.index.names == ['foo', 'bar'])
+            assert(recons.index.names == ('foo', 'bar'))
 
     def test_store_index_name(self):
         df = tm.makeDataFrame()
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 9e49d79de..7043698ea 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -3526,7 +3526,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         # MultiIndex
         result = DataFrame.from_records(documents,
                                         index=['order_id', 'quantity'])
-        self.assert_(result.index.names == ['order_id', 'quantity'])
+        self.assert_(result.index.names == ('order_id', 'quantity'))
 
     def test_from_records_misc_brokenness(self):
         # #2179
@@ -7239,7 +7239,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         # don't specify values
         pivoted = frame.pivot(index='index', columns='columns')
         self.assertEqual(pivoted.index.name, 'index')
-        self.assertEqual(pivoted.columns.names, [None, 'columns'])
+        self.assertEqual(pivoted.columns.names, (None, 'columns'))
 
         # pivot multiple columns
         wp = tm.makePanel()
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index 19f15e44d..9e7cdf9df 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -1283,13 +1283,13 @@ class TestGroupBy(unittest.TestCase):
             return result
 
         result = grouped.apply(desc)
-        self.assertEquals(result.index.names, ['A', 'B', 'stat'])
+        self.assertEquals(result.index.names, ('A', 'B', 'stat'))
 
         result2 = grouped.apply(desc2)
-        self.assertEquals(result2.index.names, ['A', 'B', 'stat'])
+        self.assertEquals(result2.index.names, ('A', 'B', 'stat'))
 
         result3 = grouped.apply(desc3)
-        self.assertEquals(result3.index.names, ['A', 'B', None])
+        self.assertEquals(result3.index.names, ('A', 'B', None))
 
     def test_nonsense_func(self):
         df = DataFrame([0])
@@ -1519,7 +1519,7 @@ class TestGroupBy(unittest.TestCase):
 
     def test_apply_series_yield_constant(self):
         result = self.df.groupby(['A', 'B'])['C'].apply(len)
-        self.assertEquals(result.index.names[:2], ['A', 'B'])
+        self.assertEquals(result.index.names[:2], ('A', 'B'))
 
     def test_apply_frame_to_series(self):
         grouped = self.df.groupby(['A', 'B'])
@@ -1836,7 +1836,7 @@ class TestGroupBy(unittest.TestCase):
         result = self.df.groupby([self.df['A'], self.df['B']]).mean()
         result2 = self.df.groupby([self.df['A'], self.df['B']],
                                   as_index=False).mean()
-        self.assertEquals(result.index.names, ['A', 'B'])
+        self.assertEquals(result.index.names, ('A', 'B'))
         self.assert_('A' in result2)
         self.assert_('B' in result2)
 
@@ -2332,7 +2332,7 @@ class TestGroupBy(unittest.TestCase):
 
         result = self.df.groupby([self.df['A'].values,
                                   self.df['B'].values]).sum()
-        self.assert_(result.index.names == [None, None])
+        self.assert_(result.index.names == (None, None))
 
     def test_groupby_categorical(self):
         levels = ['foo', 'bar', 'baz', 'qux']
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 7f889f464..b6c32a1e4 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -12,7 +12,8 @@ import numpy as np
 from numpy.testing import assert_array_equal
 
 from pandas.core.index import Index, Int64Index, MultiIndex, InvalidIndexError
-from pandas.util.testing import assert_almost_equal, assertRaisesRegexp
+from pandas.util.testing import(assert_almost_equal, assertRaisesRegexp,
+                                assert_copy)
 from pandas import compat
 
 import pandas.util.testing as tm
@@ -465,7 +466,7 @@ class TestIndex(unittest.TestCase):
         rs = idx.slice_locs('a', 'd')
         self.assert_(rs == (0, 6))
 
-        rs2 = idx.slice_locs(end='d')
+        rs = idx.slice_locs(end='d')
         self.assert_(rs == (0, 6))
 
         rs = idx.slice_locs('a', 'c')
@@ -496,11 +497,10 @@ class TestIndex(unittest.TestCase):
         import pandas
         import numpy as np
 
-        aidx1 = np.array(
-            [(1, 'A'), (2, 'A'), (1, 'B'), (2, 'B')], dtype=[('num',
-                                                              int), ('let', 'a1')])
+        aidx1 = np.array([(1, 'A'), (2, 'A'), (1, 'B'), (2, 'B')],
+                         dtype=[('num', int), ('let', 'a1')])
         aidx2 = np.array([(1, 'A'), (2, 'A'), (1, 'B'), (2, 'B'), (1, 'C'), (2,
-                                                                             'C')], dtype=[('num', int), ('let', 'a1')])
+                         'C')], dtype=[('num', int), ('let', 'a1')])
 
         idx1 = pandas.Index(aidx1)
         idx2 = pandas.Index(aidx2)
@@ -931,7 +931,7 @@ class TestInt64Index(unittest.TestCase):
         repr(df.columns)  # should not raise UnicodeDecodeError
 
     def test_repr_summary(self):
-        with cf.option_context('display.max_seq_items',10):
+        with cf.option_context('display.max_seq_items', 10):
             r = repr(pd.Index(np.arange(1000)))
             self.assertTrue(len(r) < 100)
             self.assertTrue("..." in r)
@@ -965,10 +965,52 @@ class TestMultiIndex(unittest.TestCase):
 
         major_labels = np.array([0, 0, 1, 2, 3, 3])
         minor_labels = np.array([0, 1, 0, 1, 0, 1])
-
+        self.index_names = ['first', 'second']
         self.index = MultiIndex(levels=[major_axis, minor_axis],
                                 labels=[major_labels, minor_labels],
-                                names=['first', 'second'])
+                                names=self.index_names)
+
+    def test_names(self):
+
+        # names are assigned in __init__
+        names = self.index_names
+        level_names = [level.name for level in self.index.levels]
+        self.assertEqual(names, level_names)
+
+        # setting bad names on existing
+        index = self.index
+        assertRaisesRegexp(ValueError, "^Length of names", setattr, index,
+                           "names", list(index.names) + ["third"])
+        assertRaisesRegexp(ValueError, "^Length of names", setattr, index,
+                           "names", [])
+
+        # initializing with bad names (should always be equivalent)
+        major_axis, minor_axis = self.index.levels
+        major_labels, minor_labels = self.index.labels
+        assertRaisesRegexp(ValueError, "^Length of names", MultiIndex,
+                           levels=[major_axis, minor_axis],
+                           labels=[major_labels, minor_labels],
+                           names=['first'])
+        assertRaisesRegexp(ValueError, "^Length of names", MultiIndex,
+                           levels=[major_axis, minor_axis],
+                           labels=[major_labels, minor_labels],
+                           names=['first', 'second', 'third'])
+
+        # names are assigned
+        index.names = ["a", "b"]
+        ind_names = list(index.names)
+        level_names = [level.name for level in index.levels]
+        self.assertEqual(ind_names, level_names)
+
+    def test_astype(self):
+        expected = self.index.copy()
+        actual = self.index.astype('O')
+        assert_copy(actual.levels, expected.levels)
+        assert_copy(actual.labels, expected.labels)
+        self.check_level_names(actual, expected.names)
+
+        assertRaisesRegexp(TypeError, "^Setting.*dtype.*object", self.index.astype, np.dtype(int))
+
 
     def test_constructor_single_level(self):
         single_level = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux']],
@@ -993,49 +1035,64 @@ class TestMultiIndex(unittest.TestCase):
                            " the same", MultiIndex, levels=levels,
                            labels=labels)
 
-    def test_copy(self):
-        i_copy = self.index.copy()
+    def assert_multiindex_copied(self, copy, original):
+        # levels shoudl be (at least, shallow copied)
+        assert_copy(copy.levels, original.levels)
 
-        # Equal...but not the same object
-        self.assert_(i_copy.levels == self.index.levels)
-        self.assert_(i_copy.levels is not self.index.levels)
+        assert_almost_equal(copy.labels, original.labels)
 
-        self.assert_(i_copy.labels == self.index.labels)
-        self.assert_(i_copy.labels is not self.index.labels)
+        # labels doesn't matter which way copied
+        assert_almost_equal(copy.labels, original.labels)
+        self.assert_(copy.labels is not original.labels)
 
-        self.assert_(i_copy.names == self.index.names)
-        self.assert_(i_copy.names is not self.index.names)
+        # names doesn't matter which way copied
+        self.assert_(copy.names == original.names)
+        self.assert_(copy.names is not original.names)
 
-        self.assert_(i_copy.sortorder == self.index.sortorder)
+        # sort order should be copied
+        self.assert_(copy.sortorder == original.sortorder)
 
-    def test_shallow_copy(self):
-        i_copy = self.index._shallow_copy()
+    def test_copy(self):
+        i_copy = self.index.copy()
 
-        # Equal...but not the same object
-        self.assert_(i_copy.levels == self.index.levels)
-        self.assert_(i_copy.levels is not self.index.levels)
+        self.assert_multiindex_copied(i_copy, self.index)
 
-        self.assert_(i_copy.labels == self.index.labels)
-        self.assert_(i_copy.labels is not self.index.labels)
 
-        self.assert_(i_copy.names == self.index.names)
-        self.assert_(i_copy.names is not self.index.names)
+    def test_shallow_copy(self):
+        i_copy = self.index._shallow_copy()
 
-        self.assert_(i_copy.sortorder == self.index.sortorder)
+        self.assert_multiindex_copied(i_copy, self.index)
 
     def test_view(self):
         i_view = self.index.view()
 
-        # Equal...but not the same object
-        self.assert_(i_view.levels == self.index.levels)
-        self.assert_(i_view.levels is not self.index.levels)
+        self.assert_multiindex_copied(i_view, self.index)
+
+    def check_level_names(self, index, names):
+        self.assertEqual([level.name for level in index.levels], list(names))
+
+    def test_changing_names(self):
+        # names should be applied to levels
+        level_names = [level.name for level in self.index.levels]
+        self.check_level_names(self.index, self.index.names)
 
-        self.assert_(i_view.labels == self.index.labels)
-        self.assert_(i_view.labels is not self.index.labels)
+        view = self.index.view()
+        copy = self.index.copy()
+        shallow_copy = self.index._shallow_copy()
 
-        self.assert_(i_view.names == self.index.names)
-        self.assert_(i_view.names is not self.index.names)
-        self.assert_(i_view.sortorder == self.index.sortorder)
+        # changing names should change level names on object
+        new_names = [name + "a" for name in self.index.names]
+        self.index.names = new_names
+        self.check_level_names(self.index, new_names)
+
+        # but not on copies
+        self.check_level_names(view, level_names)
+        self.check_level_names(copy, level_names)
+        self.check_level_names(shallow_copy, level_names)
+
+        # and copies shouldn't change original
+        shallow_copy.names = [name + "c" for name in shallow_copy.names]
+        self.check_level_names(self.index, new_names)
 
     def test_duplicate_names(self):
         self.index.names = ['foo', 'foo']
@@ -1287,7 +1344,8 @@ class TestMultiIndex(unittest.TestCase):
 
         # works
         sorted_index, _ = index.sortlevel(0)
-        result = sorted_index.slice_locs((1, 0, 1), (2, 1, 0))
+        # should there be a test case here???
+        sorted_index.slice_locs((1, 0, 1), (2, 1, 0))
 
     def test_slice_locs_partial(self):
         sorted_idx, _ = self.index.sortlevel(0)
@@ -1589,7 +1647,7 @@ class TestMultiIndex(unittest.TestCase):
         chunklet = self.index[-3:]
         chunklet.names = ['foo', 'baz']
         result = first - chunklet
-        self.assertEqual(result.names, [None, None])
+        self.assertEqual(result.names, (None, None))
 
         # empty, but non-equal
         result = self.index - self.index.sortlevel(1)[0]
@@ -1606,13 +1664,30 @@ class TestMultiIndex(unittest.TestCase):
 
         # name from non-empty array
         result = first.diff([('foo', 'one')])
-        expected = pd.MultiIndex.from_tuples([('bar', 'one'), ('baz', 'two'), ('foo', 'two'),
-                                              ('qux', 'one'), ('qux', 'two')])
+        expected = pd.MultiIndex.from_tuples([('bar', 'one'), ('baz', 'two'),
+                                            ('foo', 'two'), ('qux', 'one'),
+                                            ('qux', 'two')])
         expected.names = first.names
         self.assertEqual(first.names, result.names)
         assertRaisesRegexp(TypeError, "other must be a MultiIndex or a list"
                            " of tuples", first.diff, [1,2,3,4,5])
 
+    def test_set_value_keeps_names(self):
+        # motivating example from #3742
+        lev1 = ['hans', 'hans', 'hans', 'grethe', 'grethe', 'grethe']
+        lev2 = ['1', '2', '3'] * 2
+        idx = pd.MultiIndex.from_arrays(
+            [lev1, lev2],
+            names=['Name', 'Number'])
+        df = pd.DataFrame(
+            np.random.randn(6, 4),
+            columns=['one', 'two', 'three', 'four'],
+            index=idx)
+        df = df.sortlevel()
+        self.assertEqual(tuple(df.index.names), ('Name', 'Number'))
+        df = df.set_value(('grethe', 'hans'), 'one', 99.34)
+        self.assertEqual(tuple(df.index.names), ('Name', 'Number'))
+
     def test_from_tuples(self):
         assertRaisesRegexp(TypeError, 'Cannot infer number of levels from'
                            ' empty list', MultiIndex.from_tuples, [])
@@ -1708,7 +1783,7 @@ class TestMultiIndex(unittest.TestCase):
                                    np.array([1, 0, 1, 1, 0, 0, 1, 0])],
                            names=['one', 'two', 'three'])
         dropped = index.droplevel(0)
-        self.assertEqual(dropped.names, ['two', 'three'])
+        self.assertEqual(dropped.names, ('two', 'three'))
 
         dropped = index.droplevel('two')
         expected = index.droplevel(1)
@@ -1803,10 +1878,12 @@ class TestMultiIndex(unittest.TestCase):
     def test_reindex(self):
         result, indexer = self.index.reindex(list(self.index[:4]))
         tm.assert_isinstance(result, MultiIndex)
+        self.check_level_names(result, self.index[:4].names)
 
         result, indexer = self.index.reindex(list(self.index))
         tm.assert_isinstance(result, MultiIndex)
         self.assert_(indexer is None)
+        self.check_level_names(result, self.index.names)
 
     def test_reindex_level(self):
         idx = Index(['one'])
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 7379bf5d1..c903af186 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -55,9 +55,11 @@ class TestMultiLevel(unittest.TestCase):
                                      lambda x: x.day]).sum()
 
         # use Int64Index, to make sure things work
-        self.ymd.index.levels = [lev.astype('i8')
-                                 for lev in self.ymd.index.levels]
-        self.ymd.index.names = ['year', 'month', 'day']
+        self.ymd.index.set_levels([lev.astype('i8')
+                                 for lev in self.ymd.index.levels],
+                                 inplace=True)
+        self.ymd.index.set_names(['year', 'month', 'day'],
+                                 inplace=True)
 
     def test_append(self):
         a, b = self.frame[:5], self.frame[5:]
@@ -1667,7 +1669,7 @@ Thur,Lunch,Yes,51.51,17"""
         df = DataFrame(np.random.randn(6, 3), index=index)
 
         result = df.drop([(0, 2)])
-        self.assert_(result.index.names == ['one', 'two'])
+        self.assert_(result.index.names == ('one', 'two'))
 
     def test_unicode_repr_issues(self):
         levels = [Index([u('a/\u03c3'), u('b/\u03c3'), u('c/\u03c3')]),
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index e8b50e21f..c5f9f962f 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -1227,7 +1227,7 @@ class TestPanel(unittest.TestCase, PanelTests, CheckIndexing,
         assert_panel_equal(unfiltered.to_panel(), self.panel)
 
         # names
-        self.assertEqual(unfiltered.index.names, ['major', 'minor'])
+        self.assertEqual(unfiltered.index.names, ('major', 'minor'))
 
         # unsorted, round trip
         df = self.panel.to_frame(filter_observations=False)
diff --git a/pandas/tests/test_panel4d.py b/pandas/tests/test_panel4d.py
index 3c6ab1812..eddddb42b 100644
--- a/pandas/tests/test_panel4d.py
+++ b/pandas/tests/test_panel4d.py
@@ -898,7 +898,7 @@ class TestPanel4d(unittest.TestCase, CheckIndexing, SafeForSparse,
     #    assert_panel_equal(unfiltered.to_panel(), self.panel)
 
     #    # names
-    #    self.assertEqual(unfiltered.index.names, ['major', 'minor'])
+    #    self.assertEqual(unfiltered.index.names, ('major', 'minor'))
 
     def test_to_frame_mixed(self):
         raise nose.SkipTest
diff --git a/pandas/tools/pivot.py b/pandas/tools/pivot.py
index effcc3ff7..9f497e50d 100644
--- a/pandas/tools/pivot.py
+++ b/pandas/tools/pivot.py
@@ -217,7 +217,7 @@ def _add_margins(table, data, values, rows=None, cols=None, aggfunc=np.mean):
 
     row_names = result.index.names
     result = result.append(margin_dummy)
-    result.index.names = row_names
+    result.index = result.index.set_names(row_names)
 
     return result
 
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index 1008e23c3..67adc6bf8 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -1299,7 +1299,7 @@ class TestConcatenate(unittest.TestCase):
                           columns=Index(['A', 'B', 'C'], name='exp'))
         result = concat([frame, frame], keys=[0, 1], names=['iteration'])
 
-        self.assertEqual(result.index.names, ['iteration'] + index.names)
+        self.assertEqual(result.index.names, ('iteration',) + index.names)
         tm.assert_frame_equal(result.ix[0], frame)
         tm.assert_frame_equal(result.ix[1], frame)
         self.assertEqual(result.index.nlevels, 3)
@@ -1330,14 +1330,14 @@ class TestConcatenate(unittest.TestCase):
                         keys=[('foo', 'one'), ('foo', 'two'),
                               ('baz', 'one'), ('baz', 'two')],
                         levels=levels)
-        self.assertEqual(result.index.names, [None] * 3)
+        self.assertEqual(result.index.names, (None,) * 3)
 
         # no levels
         result = concat([df, df2, df, df2],
                         keys=[('foo', 'one'), ('foo', 'two'),
                               ('baz', 'one'), ('baz', 'two')],
                         names=['first', 'second'])
-        self.assertEqual(result.index.names, ['first', 'second'] + [None])
+        self.assertEqual(result.index.names, ('first', 'second') + (None,))
         self.assert_(np.array_equal(result.index.levels[0], ['baz', 'foo']))
 
     def test_concat_keys_levels_no_overlap(self):
@@ -1363,7 +1363,9 @@ class TestConcatenate(unittest.TestCase):
                         names=['lvl0', 'lvl1'])
 
         exp = concat([a, b], keys=['key0', 'key1'], names=['lvl0'])
-        exp.index.names[1] = 'lvl1'
+        names = list(exp.index.names)
+        names[1] = 'lvl1'
+        exp.index.set_names(names, inplace=True)
 
         tm.assert_frame_equal(result, exp)
         self.assertEqual(result.index.names, exp.index.names)
@@ -1391,7 +1393,7 @@ class TestConcatenate(unittest.TestCase):
         df2 = DataFrame(np.random.randn(1, 4), index=['b'])
         result = concat(
             [df, df2], keys=['one', 'two'], names=['first', 'second'])
-        self.assertEqual(result.index.names, ['first', 'second'])
+        self.assertEqual(result.index.names, ('first', 'second'))
 
     def test_handle_empty_objects(self):
         df = DataFrame(np.random.randn(10, 4), columns=list('abcd'))
diff --git a/pandas/tools/tests/test_pivot.py b/pandas/tools/tests/test_pivot.py
index 57e7d2f7f..1718648f8 100644
--- a/pandas/tools/tests/test_pivot.py
+++ b/pandas/tools/tests/test_pivot.py
@@ -42,7 +42,7 @@ class TestPivotTable(unittest.TestCase):
         pivot_table(self.data, values='D', rows=rows)
 
         if len(rows) > 1:
-            self.assertEqual(table.index.names, rows)
+            self.assertEqual(table.index.names, tuple(rows))
         else:
             self.assertEqual(table.index.name, rows[0])
 
@@ -365,7 +365,7 @@ class TestCrosstab(unittest.TestCase):
         result = crosstab(a, [b, c], rownames=['a'], colnames=('b', 'c'),
                           margins=True)
 
-        self.assertEqual(result.index.names, ['a'])
+        self.assertEqual(result.index.names, ('a',))
         self.assertEqual(result.columns.names, ['b', 'c'])
 
         all_cols = result['All', '']
diff --git a/pandas/util/decorators.py b/pandas/util/decorators.py
index 8c6744cbf..d83b1eb77 100644
--- a/pandas/util/decorators.py
+++ b/pandas/util/decorators.py
@@ -4,8 +4,8 @@ import sys
 import warnings
 
 
-def deprecate(name, alternative):
-    alt_name = alternative.__name__
+def deprecate(name, alternative, alt_name=None):
+    alt_name = alt_name or alternative.__name__
 
     def wrapper(*args, **kwargs):
         warnings.warn("%s is deprecated. Use %s instead" % (name, alt_name),

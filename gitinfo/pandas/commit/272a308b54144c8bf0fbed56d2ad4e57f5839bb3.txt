commit 272a308b54144c8bf0fbed56d2ad4e57f5839bb3
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Aug 29 19:20:57 2011 -0400

    ENH: isnull/notnull return Series now. doc edits

diff --git a/pandas/core/common.py b/pandas/core/common.py
index 34d7b7e0a..c150cf322 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -32,6 +32,8 @@ def isnull(input):
     -------
     boolean ndarray or boolean
     '''
+    from pandas.core.generic import PandasObject
+    from pandas import Series
     if isinstance(input, np.ndarray):
         if input.dtype.kind in ('O', 'S'):
             # Working around NumPy ticket 1542
@@ -39,8 +41,14 @@ def isnull(input):
             result = np.empty(shape, dtype=bool)
             vec = _tseries.isnullobj(input.ravel())
             result[:] = vec.reshape(shape)
+
+            if isinstance(input, Series):
+                result = Series(result, index=input.index, copy=False)
         else:
             result = -np.isfinite(input)
+    elif isinstance(input, PandasObject):
+        # TODO: optimize for DataFrame, etc.
+        return input.apply(isnull)
     else:
         result = _tseries.checknull(input)
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index f91114bc2..c7fc01c56 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -341,8 +341,8 @@ class DataFrame(NDFrame):
         """
         Convert DataFrame to nested dictionary
 
-        Return
-        ------
+        Returns
+        -------
         result : dict like {column -> {index -> value}}
         """
         return dict((k, v.to_dict()) for k, v in self.iteritems())
@@ -2311,7 +2311,7 @@ class DataFrame(NDFrame):
         np.putmask(values, -np.isfinite(values), -np.inf)
         return Series(values.max(axis), index=self._get_agg_axis(axis))
 
-    def product(self, axis=0):
+    def prod(self, axis=0):
         """
         Return product over requested axis. NA/null values are treated as 1
 
@@ -2337,6 +2337,8 @@ class DataFrame(NDFrame):
 
         return Series(theProd, index=self._get_agg_axis(axis))
 
+    product = prod
+
     def mean(self, axis=0):
         """
         Return mean over requested axis. NA/null values are excluded
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 0ffe717ac..7e40b0ff8 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -20,6 +20,10 @@ class GroupBy(object):
 
     It's easiest to use obj.groupby(...) to use GroupBy, but you can also do:
 
+    ::
+
+        grouped = groupby(obj, ...)
+
     Parameters
     ----------
     obj : pandas object
@@ -35,30 +39,34 @@ class GroupBy(object):
 
     Notes
     -----
-    After grouping, see aggregate, apply, and transform functions. Here are
-    some other brief notes about usage:
+    After grouping, see aggregate, apply, and transform functions. Here are some
+    other brief notes about usage. When grouping by multiple groups, the result
+    index will be a MultiIndex (hierarhical) by default.
 
-      * When grouping by multiple groups, the result index will be a MultiIndex
-        (hierarhical) by default.
+    Iteration produces (key, group) tuples, i.e. chunking the data by group. So
+    you can write code like:
 
-      * Iteration produces (key, group) tuples, i.e. chunking the data by
-        group. So you can write code like:
+    ::
 
         grouped = obj.groupby(grouper, axis=axis)
         for key, group in grouped:
             # do something with the data
 
-      * Function calls on GroupBy, if not specially implemented, "dispatch" to
-        the grouped data. So if you group a DataFrame and wish to invoke the
-        std() method on each group, you can simply do:
+    Function calls on GroupBy, if not specially implemented, "dispatch" to the
+    grouped data. So if you group a DataFrame and wish to invoke the std()
+    method on each group, you can simply do:
+
+    ::
 
         df.groupby(mapper).std()
 
-        rather than
+    rather than
+
+    ::
 
         df.groupby(mapper).aggregate(np.std)
 
-        You can pass arguments to these "wrapped" functions, too.
+    You can pass arguments to these "wrapped" functions, too.
 
     See the online documentation for full exposition on these topics and much
     more
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 8cd17f213..7b6731518 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -81,33 +81,6 @@ def _flex_method(op, name):
 # Series class
 
 class Series(np.ndarray, PandasObject):
-    """
-    One-dimensional ndarray with axis labels (including time series). Labels
-    must be unique and can any hashable type. The object supports both integer-
-    and label-based indexing and provides a host of methods for performing
-    operations involving the index. Statistical methods from ndarray have been
-    overridden to automatically exclude missing data (currently represented as
-    NaN)
-
-    Operations between Series (+, -, /, *, **) align values based on their
-    associated index values-- they need not be the same length. The result
-    index will be the sorted union of the two indexes.
-
-    Parameters
-    ----------
-    data : array-like, dict, or scalar value
-        Contains data stored in Series
-    index : array-like or Index (1d)
-        Values must be unique and hashable, same length as data. Index object
-        (or other iterable of same length as data) Will default to
-        np.arange(len(data)) if not provided. If both a dict and index sequence
-        are used, the index will override the keys found in the dict.
-    dtype : numpy.dtype or None
-        If None, dtype will be inferred copy : boolean, default False Copy
-        input data
-    copy : boolean, default False
-
-    """
     _AXIS_NUMBERS = {
         'index' : 0
     }
@@ -175,7 +148,34 @@ class Series(np.ndarray, PandasObject):
 
         return subarr
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, data, index=None, dtype=None, name=None, copy=False):
+        """One-dimensional ndarray with axis labels (including time
+series). Labels must be unique and can any hashable type. The object supports
+both integer- and label-based indexing and provides a host of methods for
+performing operations involving the index. Statistical methods from ndarray have
+been overridden to automatically exclude missing data (currently represented as
+NaN)
+
+Operations between Series (+, -, /, *, **) align values based on their
+associated index values-- they need not be the same length. The result
+index will be the sorted union of the two indexes.
+
+Parameters
+----------
+data : array-like, dict, or scalar value
+    Contains data stored in Series
+index : array-like or Index (1d)
+
+    Values must be unique and hashable, same length as data. Index object
+    (or other iterable of same length as data) Will default to
+    np.arange(len(data)) if not provided. If both a dict and index sequence
+    are used, the index will override the keys found in the dict.
+
+dtype : numpy.dtype or None
+    If None, dtype will be inferred copy : boolean, default False Copy
+    input data
+copy : boolean, default False
+        """
         pass
 
     def __hash__(self):
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index 8ff8c574e..557c077d0 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -136,24 +136,6 @@ def _sparse_fillop(this, other, name):
 
 
 class SparseSeries(Series):
-    """
-    Data structure for labeled, sparse floating point data
-
-    Parameters
-    ----------
-    data : {array-like, Series, SparseSeries, dict}
-    kind : {'block', 'integer'}
-    fill_value : float
-        Defaults to NaN (code for missing)
-    sparse_index : {BlockIndex, IntIndex}, optional
-        Only if you have one. Mainly used internally
-
-    Notes
-    -----
-    SparseSeries objects are immutable via the typical Python means. If you
-    must change values, convert to dense, make your changes, then convert back
-    to sparse
-    """
     __array_priority__ = 15
 
     sp_index = None
@@ -226,6 +208,27 @@ class SparseSeries(Series):
         output.index = index
         return output
 
+    def __init__(self, data, index=None, sparse_index=None, kind='block',
+                 fill_value=None, copy=False):
+        """Data structure for labeled, sparse floating point data
+
+Parameters
+----------
+data : {array-like, Series, SparseSeries, dict}
+kind : {'block', 'integer'}
+fill_value : float
+    Defaults to NaN (code for missing)
+sparse_index : {BlockIndex, IntIndex}, optional
+    Only if you have one. Mainly used internally
+
+Notes
+-----
+SparseSeries objects are immutable via the typical Python means. If you
+must change values, convert to dense, make your changes, then convert back
+to sparse
+        """
+        pass
+
     @property
     def _constructor(self):
         def make_sp_series(data, index=None):
diff --git a/pandas/tests/test_common.py b/pandas/tests/test_common.py
index 2f3b1707b..371dc1c7e 100644
--- a/pandas/tests/test_common.py
+++ b/pandas/tests/test_common.py
@@ -1,3 +1,4 @@
+from pandas import Series
 from pandas.core.common import notnull, isnull
 import pandas.core.common as common
 
@@ -10,6 +11,11 @@ def test_notnull():
     assert not notnull(np.inf)
     assert not notnull(-np.inf)
 
+    float_series = Series(np.random.randn(5))
+    obj_series = Series(np.random.randn(5), dtype=object)
+    assert(isinstance(notnull(float_series), Series))
+    assert(isinstance(notnull(obj_series), Series))
+
 def test_isnull():
     assert not isnull(1.)
     assert isnull(None)
@@ -17,6 +23,11 @@ def test_isnull():
     assert isnull(np.inf)
     assert isnull(-np.inf)
 
+    float_series = Series(np.random.randn(5))
+    obj_series = Series(np.random.randn(5), dtype=object)
+    assert(isinstance(isnull(float_series), Series))
+    assert(isinstance(isnull(obj_series), Series))
+
 def test_any_none():
     assert(common._any_none(1, 2, 3, None))
     assert(not common._any_none(1, 2, 3, 4))

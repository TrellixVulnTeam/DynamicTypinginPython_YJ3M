commit ca55949b8d5421a4b0f789fae43020bed5574836
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Sep 28 18:06:07 2011 -0400

    ENH: bug fixes and fixed up benchmark script

diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 747589d96..ebc6130bb 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -10,7 +10,7 @@ from pandas.core.internals import BlockManager
 from pandas.core.series import Series
 from pandas.core.panel import Panel
 from pandas.util.decorators import cache_readonly
-import pandas._tseries as _tseries
+import pandas._tseries as lib
 
 
 class GroupBy(object):
@@ -313,8 +313,8 @@ class GroupBy(object):
                 cannot_agg.append(name)
                 continue
 
-            result, counts =  _tseries.group_aggregate(obj, label_list,
-                                                       shape, how=how)
+            result, counts =  lib.group_aggregate(obj, label_list,
+                                                  shape, how=how)
             result = result.ravel()
             mask = counts.ravel() > 0
             output[name] = result[mask]
@@ -470,18 +470,20 @@ class Grouping(object):
 
         if level is not None:
             inds = index.labels[level]
-            labels = index.levels[level].values.take(inds)
+            labels = index.levels[level].take(inds)
 
             if grouper is not None:
-                self.grouper = _tseries.arrmap(labels, self.grouper)
+                self.grouper = labels.map(self.grouper)
             else:
                 self.grouper = labels
 
-        self.index = np.asarray(index.values, dtype=object)
+        if not isinstance(index, Index):
+            index = Index(index)
+        self.index = index
 
         # no level passed
         if not isinstance(self.grouper, np.ndarray):
-            self.grouper = _tseries.arrmap(self.index, self.grouper)
+            self.grouper = self.index.map(self.grouper)
 
     def __repr__(self):
         return 'Grouping(%s)' % self.name
@@ -495,7 +497,7 @@ class Grouping(object):
 
     @cache_readonly
     def indices(self):
-        return _tseries.groupby_indices(self.grouper)
+        return lib.groupby_indices(self.grouper)
 
     @property
     def labels(self):
@@ -524,7 +526,7 @@ class Grouping(object):
         return Index([self.ids[i] for i in range(len(self.ids))])
 
     def _make_labels(self):
-        ids, labels, counts  = _tseries.group_labels(self.grouper)
+        ids, labels, counts  = lib.group_labels(self.grouper)
         sids, slabels, scounts = sort_group_labels(ids, labels, counts)
         self._labels = slabels
         self._ids = sids
@@ -534,7 +536,7 @@ class Grouping(object):
     @property
     def groups(self):
         if self._groups is None:
-            self._groups = _tseries.groupby(self.index, self.grouper)
+            self._groups = self.index.groupby(self.grouper)
         return self._groups
 
 def _get_groupings(obj, grouper=None, axis=0, level=None):
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 03a26f1e5..e41ca6bc7 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -383,7 +383,10 @@ class Index(np.ndarray):
         return indexer
 
     def groupby(self, to_groupby):
-        return lib.groupby(self, to_groupby)
+        return lib.groupby_object(self.values, to_groupby)
+
+    def map(self, mapper):
+        return lib.arrmap_object(self.values, mapper)
 
     def _get_method(self, method):
         if method:
@@ -646,7 +649,10 @@ class Int64Index(Index):
             return join_index
 
     def groupby(self, to_groupby):
-        return lib.groupby(self.values.astype(object), to_groupby)
+        return lib.groupby_int64(self, to_groupby)
+
+    def map(self, mapper):
+        return lib.arrmap_int64(self, mapper)
 
     def take(self, *args, **kwargs):
         """
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index 346352422..88b941d49 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -308,6 +308,49 @@ cpdef map_indices_%(name)s(ndarray[%(c_type)s] index):
 
 """
 
+groupby_template = """@cython.wraparound(False)
+@cython.boundscheck(False)
+def groupby_%(name)s(ndarray[%(c_type)s] index, ndarray[object] labels):
+    cdef dict result = {}
+    cdef ndarray[int8_t] mask
+    cdef int i, length
+    cdef list members
+    cdef object idx, key
+
+    length = len(index)
+    mask = isnullobj(labels)
+
+    for i from 0 <= i < length:
+        if mask[i]:
+            continue
+
+        key = labels[i]
+        idx = index[i]
+        if key in result:
+            members = result[key]
+            members.append(idx)
+        else:
+            result[key] = [idx]
+
+    return result
+
+"""
+
+arrmap_template = """@cython.wraparound(False)
+@cython.boundscheck(False)
+def arrmap_%(name)s(ndarray[%(c_type)s] index, object func):
+    cdef int length = index.shape[0]
+    cdef int i = 0
+
+    cdef ndarray[object] result = np.empty(length, dtype=np.object_)
+
+    for i from 0 <= i < length:
+        result[i] = func(index[i])
+
+    return result
+
+"""
+
 # name, ctype, capable of holding NA
 function_list = [
     ('float64', 'float64_t', True),
@@ -339,6 +382,8 @@ def generate_take_cython_file(path='generated.pyx'):
         print >> f, generate_from_template(take_2d_axis0_template, ndim=2)
         print >> f, generate_from_template(take_2d_axis1_template, ndim=2)
         print >> f, generate_from_template(is_monotonic_template)
+        print >> f, generate_from_template(groupby_template)
+        print >> f, generate_from_template(arrmap_template)
 
 if __name__ == '__main__':
     generate_take_cython_file()
diff --git a/pandas/src/generated.pyx b/pandas/src/generated.pyx
index ddb6e5191..9ce6efba8 100644
--- a/pandas/src/generated.pyx
+++ b/pandas/src/generated.pyx
@@ -1206,3 +1206,200 @@ def is_monotonic_bool(ndarray[uint8_t] arr):
     return True
 
 
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def groupby_float64(ndarray[float64_t] index, ndarray[object] labels):
+    cdef dict result = {}
+    cdef ndarray[int8_t] mask
+    cdef int i, length
+    cdef list members
+    cdef object idx, key
+
+    length = len(index)
+    mask = isnullobj(labels)
+
+    for i from 0 <= i < length:
+        if mask[i]:
+            continue
+
+        key = labels[i]
+        idx = index[i]
+        if key in result:
+            members = result[key]
+            members.append(idx)
+        else:
+            result[key] = [idx]
+
+    return result
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def groupby_object(ndarray[object] index, ndarray[object] labels):
+    cdef dict result = {}
+    cdef ndarray[int8_t] mask
+    cdef int i, length
+    cdef list members
+    cdef object idx, key
+
+    length = len(index)
+    mask = isnullobj(labels)
+
+    for i from 0 <= i < length:
+        if mask[i]:
+            continue
+
+        key = labels[i]
+        idx = index[i]
+        if key in result:
+            members = result[key]
+            members.append(idx)
+        else:
+            result[key] = [idx]
+
+    return result
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def groupby_int32(ndarray[int32_t] index, ndarray[object] labels):
+    cdef dict result = {}
+    cdef ndarray[int8_t] mask
+    cdef int i, length
+    cdef list members
+    cdef object idx, key
+
+    length = len(index)
+    mask = isnullobj(labels)
+
+    for i from 0 <= i < length:
+        if mask[i]:
+            continue
+
+        key = labels[i]
+        idx = index[i]
+        if key in result:
+            members = result[key]
+            members.append(idx)
+        else:
+            result[key] = [idx]
+
+    return result
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def groupby_int64(ndarray[int64_t] index, ndarray[object] labels):
+    cdef dict result = {}
+    cdef ndarray[int8_t] mask
+    cdef int i, length
+    cdef list members
+    cdef object idx, key
+
+    length = len(index)
+    mask = isnullobj(labels)
+
+    for i from 0 <= i < length:
+        if mask[i]:
+            continue
+
+        key = labels[i]
+        idx = index[i]
+        if key in result:
+            members = result[key]
+            members.append(idx)
+        else:
+            result[key] = [idx]
+
+    return result
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def groupby_bool(ndarray[uint8_t] index, ndarray[object] labels):
+    cdef dict result = {}
+    cdef ndarray[int8_t] mask
+    cdef int i, length
+    cdef list members
+    cdef object idx, key
+
+    length = len(index)
+    mask = isnullobj(labels)
+
+    for i from 0 <= i < length:
+        if mask[i]:
+            continue
+
+        key = labels[i]
+        idx = index[i]
+        if key in result:
+            members = result[key]
+            members.append(idx)
+        else:
+            result[key] = [idx]
+
+    return result
+
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def arrmap_float64(ndarray[float64_t] index, object func):
+    cdef int length = index.shape[0]
+    cdef int i = 0
+
+    cdef ndarray[object] result = np.empty(length, dtype=np.object_)
+
+    for i from 0 <= i < length:
+        result[i] = func(index[i])
+
+    return result
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def arrmap_object(ndarray[object] index, object func):
+    cdef int length = index.shape[0]
+    cdef int i = 0
+
+    cdef ndarray[object] result = np.empty(length, dtype=np.object_)
+
+    for i from 0 <= i < length:
+        result[i] = func(index[i])
+
+    return result
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def arrmap_int32(ndarray[int32_t] index, object func):
+    cdef int length = index.shape[0]
+    cdef int i = 0
+
+    cdef ndarray[object] result = np.empty(length, dtype=np.object_)
+
+    for i from 0 <= i < length:
+        result[i] = func(index[i])
+
+    return result
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def arrmap_int64(ndarray[int64_t] index, object func):
+    cdef int length = index.shape[0]
+    cdef int i = 0
+
+    cdef ndarray[object] result = np.empty(length, dtype=np.object_)
+
+    for i from 0 <= i < length:
+        result[i] = func(index[i])
+
+    return result
+
+@cython.wraparound(False)
+@cython.boundscheck(False)
+def arrmap_bool(ndarray[uint8_t] index, object func):
+    cdef int length = index.shape[0]
+    cdef int i = 0
+
+    cdef ndarray[object] result = np.empty(length, dtype=np.object_)
+
+    for i from 0 <= i < length:
+        result[i] = func(index[i])
+
+    return result
+
+
diff --git a/pandas/src/groupby.pyx b/pandas/src/groupby.pyx
index 8b09613da..5c45b02df 100644
--- a/pandas/src/groupby.pyx
+++ b/pandas/src/groupby.pyx
@@ -46,31 +46,6 @@ def groupby_func(object index, object mapper):
 
     return result
 
-@cython.boundscheck(False)
-def groupby(ndarray[object] index, ndarray[object] labels):
-    cdef dict result = {}
-    cdef ndarray[int8_t] mask
-    cdef int i, length
-    cdef list members
-    cdef object idx, key
-
-    length = len(index)
-    mask = isnullobj(labels)
-
-    for i from 0 <= i < length:
-        if mask[i]:
-            continue
-
-        key = labels[i]
-        idx = index[i]
-        if key in result:
-            members = result[key]
-            members.append(idx)
-        else:
-            result[key] = [idx]
-
-    return result
-
 
 def func_groupby_indices(object index, object mapper):
     return groupby_indices_naive(arrmap(index, mapper))
diff --git a/pandas/src/reindex.pyx b/pandas/src/reindex.pyx
index 270b194a8..6ab690304 100644
--- a/pandas/src/reindex.pyx
+++ b/pandas/src/reindex.pyx
@@ -197,18 +197,21 @@ def left_join_indexer(ndarray[int64_t] left, ndarray[int64_t] right):
     n = len(left)
     k = len(right)
 
-    indexer = np.zeros(n, dtype=np.int32)
+    indexer = np.empty(n, dtype=np.int32)
     for i from 0 <= i < n:
+        if j == k:
+            indexer[i] = -1
+            continue
+
         val = left[i]
 
         while j < k and right[j] < val:
             j += 1
 
-        if j == k:
-            break
-
         if val == right[j]:
             indexer[i] = j
+        else:
+            indexer[i] = -1
 
     return indexer
 
diff --git a/scripts/bench_join.py b/scripts/bench_join.py
index 4ab81067c..c214d0901 100644
--- a/scripts/bench_join.py
+++ b/scripts/bench_join.py
@@ -5,7 +5,7 @@ from copy import deepcopy
 import time
 
 n = 1000000
-K = 1
+K = 5
 pct_overlap = 0.2
 
 a = np.arange(n, dtype=np.int64)
@@ -26,8 +26,8 @@ bvf = np.random.randn(n, K)
 a_series = Series(av, index=a)
 b_series = Series(bv, index=b)
 
-a_frame = DataFrame(avf, index=dr1, columns=range(K))
-b_frame = DataFrame(bvf, index=dr2, columns=range(K, 2 * K))
+a_frame = DataFrame(avf, index=a, columns=range(K))
+b_frame = DataFrame(bvf, index=b, columns=range(K, 2 * K))
 
 def do_left_join(a, b, av, bv):
     out = np.empty((len(a), 2))
@@ -137,7 +137,7 @@ def bench_python(n=100000, pct_overlap=0.20):
     import gc
     ns = [2, 3, 4, 5, 6]
     iterations = 50
-    K = 5
+    K = 1
     pct_overlap = 0.2
     kinds = ['outer', 'left', 'inner']
 
@@ -150,13 +150,17 @@ def bench_python(n=100000, pct_overlap=0.20):
         avf = np.random.randn(n, K)
         bvf = np.random.randn(n, K)
 
+        a_frame = DataFrame(avf, index=a, columns=range(K))
+        b_frame = DataFrame(bvf, index=b, columns=range(K, 2 * K))
+
         all_results[logn] = result = {}
 
         for kind in kinds:
             gc.disable()
             _s = time.clock()
             for _ in range(iterations):
-                join(a, b, avf, bvf, how=kind)
+                a_frame.join(b_frame, how=kind)
+                # join(a, b, avf, bvf, how=kind)
             elapsed = time.clock() - _s
             gc.enable()
             result[kind] = (elapsed / iterations) * 1000

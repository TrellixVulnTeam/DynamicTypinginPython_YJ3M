commit efce4928ece189ceed43729b826f89021ea7988f
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sun Feb 11 06:48:36 2018 -0800

    Fix uncaught OutOfBounds in array_to_datetime (#19612)

diff --git a/doc/source/whatsnew/v0.23.0.txt b/doc/source/whatsnew/v0.23.0.txt
index 6fdd551ac..acab9d0bb 100644
--- a/doc/source/whatsnew/v0.23.0.txt
+++ b/doc/source/whatsnew/v0.23.0.txt
@@ -703,7 +703,7 @@ Datetimelike
 - Bug in :class:`Series` floor-division where operating on a scalar ``timedelta`` raises an exception (:issue:`18846`)
 - Bug in :class:`Series`` with ``dtype='timedelta64[ns]`` where addition or subtraction of ``TimedeltaIndex`` had results cast to ``dtype='int64'`` (:issue:`17250`)
 - Bug in :class:`TimedeltaIndex` where division by a ``Series`` would return a ``TimedeltaIndex`` instead of a ``Series`` (issue:`19042`)
-- Bug in :class:`Series` with ``dtype='timedelta64[ns]`` where addition or subtraction of ``TimedeltaIndex`` could return a ``Series`` with an incorrect name (issue:`19043`)
+- Bug in :class:`Series` with ``dtype='timedelta64[ns]`` where addition or subtraction of ``TimedeltaIndex`` could return a ``Series`` with an incorrect name (:issue:`19043`)
 - Bug in :class:`DatetimeIndex` where the repr was not showing high-precision time values at the end of a day (e.g., 23:59:59.999999999) (:issue:`19030`)
 - Bug where dividing a scalar timedelta-like object with :class:`TimedeltaIndex` performed the reciprocal operation (:issue:`19125`)
 - Bug in ``.astype()`` to non-ns timedelta units would hold the incorrect dtype (:issue:`19176`, :issue:`19223`, :issue:`12425`)
@@ -713,6 +713,7 @@ Datetimelike
 - Bug in comparison of :class:`DatetimeIndex` against ``None`` or ``datetime.date`` objects raising ``TypeError`` for ``==`` and ``!=`` comparisons instead of all-``False`` and all-``True``, respectively (:issue:`19301`)
 - Bug in :class:`Timestamp` and :func:`to_datetime` where a string representing a barely out-of-bounds timestamp would be incorrectly rounded down instead of raising ``OutOfBoundsDatetime`` (:issue:`19382`)
 - Bug in :func:`Timestamp.floor` :func:`DatetimeIndex.floor` where time stamps far in the future and past were not rounded correctly (:issue:`19206`)
+- Bug in :func:`to_datetime` where passing an out-of-bounds datetime with ``errors='coerce'`` and ``utc=True`` would raise ``OutOfBoundsDatetime`` instead of parsing to ``NaT`` (:issue:`19612`)
 -
 
 Timezones
diff --git a/pandas/_libs/tslib.pyx b/pandas/_libs/tslib.pyx
index a035bab2a..85e667521 100644
--- a/pandas/_libs/tslib.pyx
+++ b/pandas/_libs/tslib.pyx
@@ -524,11 +524,10 @@ cpdef array_to_datetime(ndarray[object] values, errors='raise',
                 seen_datetime = 1
                 if val.tzinfo is not None:
                     if utc_convert:
-                        _ts = convert_datetime_to_tsobject(val, None)
-                        iresult[i] = _ts.value
                         try:
-                            check_dts_bounds(&_ts.dts)
-                        except ValueError:
+                            _ts = convert_datetime_to_tsobject(val, None)
+                            iresult[i] = _ts.value
+                        except OutOfBoundsDatetime:
                             if is_coerce:
                                 iresult[i] = NPY_NAT
                                 continue
@@ -544,7 +543,7 @@ cpdef array_to_datetime(ndarray[object] values, errors='raise',
                         iresult[i] += val.nanosecond
                     try:
                         check_dts_bounds(&dts)
-                    except ValueError:
+                    except OutOfBoundsDatetime:
                         if is_coerce:
                             iresult[i] = NPY_NAT
                             continue
@@ -555,7 +554,7 @@ cpdef array_to_datetime(ndarray[object] values, errors='raise',
                 iresult[i] = pydate_to_dt64(val, &dts)
                 try:
                     check_dts_bounds(&dts)
-                except ValueError:
+                except OutOfBoundsDatetime:
                     if is_coerce:
                         iresult[i] = NPY_NAT
                         continue
@@ -568,7 +567,7 @@ cpdef array_to_datetime(ndarray[object] values, errors='raise',
                 else:
                     try:
                         iresult[i] = get_datetime64_nanos(val)
-                    except ValueError:
+                    except OutOfBoundsDatetime:
                         if is_coerce:
                             iresult[i] = NPY_NAT
                             continue
diff --git a/pandas/tests/indexes/datetimes/test_tools.py b/pandas/tests/indexes/datetimes/test_tools.py
index 35f34dc3a..bd3fa5e73 100644
--- a/pandas/tests/indexes/datetimes/test_tools.py
+++ b/pandas/tests/indexes/datetimes/test_tools.py
@@ -8,7 +8,7 @@ import calendar
 import dateutil
 import numpy as np
 from dateutil.parser import parse
-from datetime import datetime, date, time
+from datetime import datetime, date, time, timedelta
 from distutils.version import LooseVersion
 
 import pandas as pd
@@ -1503,6 +1503,15 @@ class TestDatetimeParsingWrappers(object):
 
 
 class TestArrayToDatetime(object):
+    def test_coerce_out_of_bounds_utc(self):
+        # GH#19612
+        ts = Timestamp('1900-01-01', tz='US/Pacific')
+        dt = ts.to_pydatetime() - timedelta(days=365 * 300)  # ~1600AD
+        arr = np.array([dt])
+        result = tslib.array_to_datetime(arr, utc=True, errors='coerce')
+        expected = np.array(['NaT'], dtype='datetime64[ns]')
+        tm.assert_numpy_array_equal(result, expected)
+
     def test_parsing_valid_dates(self):
         arr = np.array(['01-01-2013', '01-02-2013'], dtype=object)
         tm.assert_numpy_array_equal(

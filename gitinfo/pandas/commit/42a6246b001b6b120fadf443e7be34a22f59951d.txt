commit 42a6246b001b6b120fadf443e7be34a22f59951d
Author: Simon Hawkins <simonjayhawkins@gmail.com>
Date:   Thu Feb 28 13:34:21 2019 +0000

    STY: use pytest.raises context manager (tests/test_*) (#25452)
    
    * STY: use pytest.raises context manager (tests/test_*)
    
    * fix ci failures
    
    * skip py2 ci failure

diff --git a/pandas/tests/test_algos.py b/pandas/tests/test_algos.py
index cb7426ce2..c56bf9446 100644
--- a/pandas/tests/test_algos.py
+++ b/pandas/tests/test_algos.py
@@ -11,7 +11,7 @@ import pytest
 
 from pandas._libs import (
     algos as libalgos, groupby as libgroupby, hashtable as ht)
-from pandas.compat import lrange, range
+from pandas.compat import PY2, lrange, range
 from pandas.compat.numpy import np_array_datetime64_compat
 import pandas.util._test_decorators as td
 
@@ -224,11 +224,16 @@ class TestFactorize(object):
                                                      dtype=object)
         tm.assert_numpy_array_equal(result[1], expected_level_array)
 
+    @pytest.mark.skipif(PY2, reason="pytest.raises match regex fails")
     def test_complex_sorting(self):
         # gh 12666 - check no segfault
         x17 = np.array([complex(i) for i in range(17)], dtype=object)
 
-        pytest.raises(TypeError, algos.factorize, x17[::-1], sort=True)
+        msg = ("'<' not supported between instances of 'complex' and"
+               r" 'complex'|"
+               r"unorderable types: complex\(\) > complex\(\)")
+        with pytest.raises(TypeError, match=msg):
+            algos.factorize(x17[::-1], sort=True)
 
     def test_float64_factorize(self, writable):
         data = np.array([1.0, 1e8, 1.0, 1e-8, 1e8, 1.0], dtype=np.float64)
@@ -589,9 +594,14 @@ class TestIsin(object):
 
     def test_invalid(self):
 
-        pytest.raises(TypeError, lambda: algos.isin(1, 1))
-        pytest.raises(TypeError, lambda: algos.isin(1, [1]))
-        pytest.raises(TypeError, lambda: algos.isin([1], 1))
+        msg = (r"only list-like objects are allowed to be passed to isin\(\),"
+               r" you passed a \[int\]")
+        with pytest.raises(TypeError, match=msg):
+            algos.isin(1, 1)
+        with pytest.raises(TypeError, match=msg):
+            algos.isin(1, [1])
+        with pytest.raises(TypeError, match=msg):
+            algos.isin([1], 1)
 
     def test_basic(self):
 
@@ -819,8 +829,9 @@ class TestValueCounts(object):
         result = algos.value_counts(Series([1, 1., '1']))  # object
         assert len(result) == 2
 
-        pytest.raises(TypeError, lambda s: algos.value_counts(s, bins=1),
-                      ['1', 1])
+        msg = "bins argument only works with numeric data"
+        with pytest.raises(TypeError, match=msg):
+            algos.value_counts(['1', 1], bins=1)
 
     def test_value_counts_nat(self):
         td = Series([np.timedelta64(10000), pd.NaT], dtype='timedelta64[ns]')
diff --git a/pandas/tests/test_config.py b/pandas/tests/test_config.py
index 54db38878..baca66e03 100644
--- a/pandas/tests/test_config.py
+++ b/pandas/tests/test_config.py
@@ -3,7 +3,10 @@ import warnings
 
 import pytest
 
+from pandas.compat import PY2
+
 import pandas as pd
+from pandas.core.config import OptionError
 
 
 class TestConfig(object):
@@ -48,26 +51,35 @@ class TestConfig(object):
 
         v(12)
         v(None)
-        pytest.raises(ValueError, v, 1.1)
+        msg = r"Value must be one of None\|12"
+        with pytest.raises(ValueError, match=msg):
+            v(1.1)
 
     def test_register_option(self):
         self.cf.register_option('a', 1, 'doc')
 
         # can't register an already registered option
-        pytest.raises(KeyError, self.cf.register_option, 'a', 1, 'doc')
+        msg = "Option 'a' has already been registered"
+        with pytest.raises(OptionError, match=msg):
+            self.cf.register_option('a', 1, 'doc')
 
         # can't register an already registered option
-        pytest.raises(KeyError, self.cf.register_option, 'a.b.c.d1', 1,
-                      'doc')
-        pytest.raises(KeyError, self.cf.register_option, 'a.b.c.d2', 1,
-                      'doc')
+        msg = "Path prefix to option 'a' is already an option"
+        with pytest.raises(OptionError, match=msg):
+            self.cf.register_option('a.b.c.d1', 1, 'doc')
+        with pytest.raises(OptionError, match=msg):
+            self.cf.register_option('a.b.c.d2', 1, 'doc')
 
         # no python keywords
-        pytest.raises(ValueError, self.cf.register_option, 'for', 0)
-        pytest.raises(ValueError, self.cf.register_option, 'a.for.b', 0)
+        msg = "for is a python keyword"
+        with pytest.raises(ValueError, match=msg):
+            self.cf.register_option('for', 0)
+        with pytest.raises(ValueError, match=msg):
+            self.cf.register_option('a.for.b', 0)
         # must be valid identifier (ensure attribute access works)
-        pytest.raises(ValueError, self.cf.register_option,
-                      'Oh my Goddess!', 0)
+        msg = "oh my goddess! is not a valid identifier"
+        with pytest.raises(ValueError, match=msg):
+            self.cf.register_option('Oh my Goddess!', 0)
 
         # we can register options several levels deep
         # without predefining the intermediate steps
@@ -90,7 +102,9 @@ class TestConfig(object):
         self.cf.register_option('l', "foo")
 
         # non-existent keys raise KeyError
-        pytest.raises(KeyError, self.cf.describe_option, 'no.such.key')
+        msg = r"No such keys\(s\)"
+        with pytest.raises(OptionError, match=msg):
+            self.cf.describe_option('no.such.key')
 
         # we can get the description for any key we registered
         assert 'doc' in self.cf.describe_option('a', _print_desc=False)
@@ -122,7 +136,9 @@ class TestConfig(object):
         assert self.cf.get_option('kAnBaN') == 2
 
         # gets of non-existent keys fail
-        pytest.raises(KeyError, self.cf.get_option, 'no_such_option')
+        msg = r"No such keys\(s\): 'no_such_option'"
+        with pytest.raises(OptionError, match=msg):
+            self.cf.get_option('no_such_option')
         self.cf.deprecate_option('KanBan')
 
         assert self.cf._is_deprecated('kAnBaN')
@@ -138,7 +154,9 @@ class TestConfig(object):
         assert self.cf.get_option('b.b') is None
 
         # gets of non-existent keys fail
-        pytest.raises(KeyError, self.cf.get_option, 'no_such_option')
+        msg = r"No such keys\(s\): 'no_such_option'"
+        with pytest.raises(OptionError, match=msg):
+            self.cf.get_option('no_such_option')
 
     def test_set_option(self):
         self.cf.register_option('a', 1, 'doc')
@@ -157,16 +175,24 @@ class TestConfig(object):
         assert self.cf.get_option('b.c') == 'wurld'
         assert self.cf.get_option('b.b') == 1.1
 
-        pytest.raises(KeyError, self.cf.set_option, 'no.such.key', None)
+        msg = r"No such keys\(s\): 'no.such.key'"
+        with pytest.raises(OptionError, match=msg):
+            self.cf.set_option('no.such.key', None)
 
     def test_set_option_empty_args(self):
-        pytest.raises(ValueError, self.cf.set_option)
+        msg = "Must provide an even number of non-keyword arguments"
+        with pytest.raises(ValueError, match=msg):
+            self.cf.set_option()
 
     def test_set_option_uneven_args(self):
-        pytest.raises(ValueError, self.cf.set_option, 'a.b', 2, 'b.c')
+        msg = "Must provide an even number of non-keyword arguments"
+        with pytest.raises(ValueError, match=msg):
+            self.cf.set_option('a.b', 2, 'b.c')
 
     def test_set_option_invalid_single_argument_type(self):
-        pytest.raises(ValueError, self.cf.set_option, 2)
+        msg = "Must provide an even number of non-keyword arguments"
+        with pytest.raises(ValueError, match=msg):
+            self.cf.set_option(2)
 
     def test_set_option_multiple(self):
         self.cf.register_option('a', 1, 'doc')
@@ -183,27 +209,36 @@ class TestConfig(object):
         assert self.cf.get_option('b.c') is None
         assert self.cf.get_option('b.b') == 10.0
 
+    @pytest.mark.skipif(PY2, reason="pytest.raises match regex fails")
     def test_validation(self):
         self.cf.register_option('a', 1, 'doc', validator=self.cf.is_int)
         self.cf.register_option('b.c', 'hullo', 'doc2',
                                 validator=self.cf.is_text)
-        pytest.raises(ValueError, self.cf.register_option, 'a.b.c.d2',
-                      'NO', 'doc', validator=self.cf.is_int)
+        msg = "Value must have type '<class 'int'>'"
+        with pytest.raises(ValueError, match=msg):
+            self.cf.register_option(
+                'a.b.c.d2', 'NO', 'doc', validator=self.cf.is_int)
 
         self.cf.set_option('a', 2)  # int is_int
         self.cf.set_option('b.c', 'wurld')  # str is_str
 
-        pytest.raises(
-            ValueError, self.cf.set_option, 'a', None)  # None not is_int
-        pytest.raises(ValueError, self.cf.set_option, 'a', 'ab')
-        pytest.raises(ValueError, self.cf.set_option, 'b.c', 1)
+        # None not is_int
+        with pytest.raises(ValueError, match=msg):
+            self.cf.set_option('a', None)
+        with pytest.raises(ValueError, match=msg):
+            self.cf.set_option('a', 'ab')
+
+        msg = r"Value must be an instance of <class 'str'>\|<class 'bytes'>"
+        with pytest.raises(ValueError, match=msg):
+            self.cf.set_option('b.c', 1)
 
         validator = self.cf.is_one_of_factory([None, self.cf.is_callable])
         self.cf.register_option('b', lambda: None, 'doc',
                                 validator=validator)
         self.cf.set_option('b', '%.1f'.format)  # Formatter is callable
         self.cf.set_option('b', None)  # Formatter is none (default)
-        pytest.raises(ValueError, self.cf.set_option, 'b', '%.1f')
+        with pytest.raises(ValueError, match="Value must be a callable"):
+            self.cf.set_option('b', '%.1f')
 
     def test_reset_option(self):
         self.cf.register_option('a', 1, 'doc', validator=self.cf.is_int)
@@ -267,8 +302,9 @@ class TestConfig(object):
             assert 'eprecated' in str(w[-1])  # we get the default message
             assert 'nifty_ver' in str(w[-1])  # with the removal_ver quoted
 
-            pytest.raises(
-                KeyError, self.cf.deprecate_option, 'a')  # can't depr. twice
+            msg = "Option 'a' has already been defined as deprecated"
+            with pytest.raises(OptionError, match=msg):
+                self.cf.deprecate_option('a')
 
         self.cf.deprecate_option('b.c', 'zounds!')
         with warnings.catch_warnings(record=True) as w:
@@ -374,12 +410,6 @@ class TestConfig(object):
     def test_attribute_access(self):
         holder = []
 
-        def f():
-            options.b = 1
-
-        def f2():
-            options.display = 1
-
         def f3(key):
             holder.append(True)
 
@@ -397,8 +427,11 @@ class TestConfig(object):
         self.cf.reset_option("a")
         assert options.a == self.cf.get_option("a", 0)
 
-        pytest.raises(KeyError, f)
-        pytest.raises(KeyError, f2)
+        msg = "You can only set the value of existing options"
+        with pytest.raises(OptionError, match=msg):
+            options.b = 1
+        with pytest.raises(OptionError, match=msg):
+            options.display = 1
 
         # make sure callback kicks when using this form of setting
         options.c = 1
@@ -429,5 +462,6 @@ class TestConfig(object):
     def test_dictwrapper_getattr(self):
         options = self.cf.options
         # GH 19789
-        pytest.raises(self.cf.OptionError, getattr, options, 'bananas')
+        with pytest.raises(OptionError, match="No such option"):
+            options.bananas
         assert not hasattr(options, 'bananas')
diff --git a/pandas/tests/test_multilevel.py b/pandas/tests/test_multilevel.py
index 4ea7e9b8e..a9a59c6d9 100644
--- a/pandas/tests/test_multilevel.py
+++ b/pandas/tests/test_multilevel.py
@@ -886,8 +886,11 @@ Thur,Lunch,Yes,51.51,17"""
         tm.assert_series_equal(result, expect, check_names=False)
         assert result.index.name == 'a'
 
-        pytest.raises(KeyError, series.count, 'x')
-        pytest.raises(KeyError, frame.count, level='x')
+        msg = "Level x not found"
+        with pytest.raises(KeyError, match=msg):
+            series.count('x')
+        with pytest.raises(KeyError, match=msg):
+            frame.count(level='x')
 
     @pytest.mark.parametrize('op', AGG_FUNCTIONS)
     @pytest.mark.parametrize('level', [0, 1])
@@ -1119,7 +1122,8 @@ Thur,Lunch,Yes,51.51,17"""
         tm.assert_series_equal(result, expected)
         tm.assert_series_equal(result2, expected)
 
-        pytest.raises(KeyError, series.__getitem__, (('foo', 'bar', 0), 2))
+        with pytest.raises(KeyError, match=r"^\(\('foo', 'bar', 0\), 2\)$"):
+            series[('foo', 'bar', 0), 2]
 
         result = frame.loc[('foo', 'bar', 0)]
         result2 = frame.xs(('foo', 'bar', 0))
diff --git a/pandas/tests/test_nanops.py b/pandas/tests/test_nanops.py
index cf5ef6cf1..d1893b7ef 100644
--- a/pandas/tests/test_nanops.py
+++ b/pandas/tests/test_nanops.py
@@ -7,6 +7,7 @@ import warnings
 import numpy as np
 import pytest
 
+from pandas.compat import PY2
 from pandas.compat.numpy import _np_version_under1p13
 import pandas.util._test_decorators as td
 
@@ -728,6 +729,7 @@ class TestEnsureNumeric(object):
         # Test complex
         assert nanops._ensure_numeric(1 + 2j) == 1 + 2j
 
+    @pytest.mark.skipif(PY2, reason="pytest.raises match regex fails")
     def test_ndarray(self):
         # Test numeric ndarray
         values = np.array([1, 2, 3])
@@ -743,7 +745,9 @@ class TestEnsureNumeric(object):
 
         # Test non-convertible string ndarray
         s_values = np.array(['foo', 'bar', 'baz'], dtype=object)
-        pytest.raises(ValueError, lambda: nanops._ensure_numeric(s_values))
+        msg = r"could not convert string to float: '(foo|baz)'"
+        with pytest.raises(ValueError, match=msg):
+            nanops._ensure_numeric(s_values)
 
     def test_convertable_values(self):
         assert np.allclose(nanops._ensure_numeric('1'), 1.0)
@@ -751,9 +755,15 @@ class TestEnsureNumeric(object):
         assert np.allclose(nanops._ensure_numeric('1+1j'), 1 + 1j)
 
     def test_non_convertable_values(self):
-        pytest.raises(TypeError, lambda: nanops._ensure_numeric('foo'))
-        pytest.raises(TypeError, lambda: nanops._ensure_numeric({}))
-        pytest.raises(TypeError, lambda: nanops._ensure_numeric([]))
+        msg = "Could not convert foo to numeric"
+        with pytest.raises(TypeError, match=msg):
+            nanops._ensure_numeric('foo')
+        msg = "Could not convert {} to numeric"
+        with pytest.raises(TypeError, match=msg):
+            nanops._ensure_numeric({})
+        msg = r"Could not convert \[\] to numeric"
+        with pytest.raises(TypeError, match=msg):
+            nanops._ensure_numeric([])
 
 
 class TestNanvarFixedValues(object):
diff --git a/pandas/tests/test_sorting.py b/pandas/tests/test_sorting.py
index 7500cbb3c..e83bdb1af 100644
--- a/pandas/tests/test_sorting.py
+++ b/pandas/tests/test_sorting.py
@@ -7,6 +7,8 @@ import numpy as np
 from numpy import nan
 import pytest
 
+from pandas.compat import PY2
+
 from pandas import DataFrame, MultiIndex, Series, compat, concat, merge
 from pandas.core import common as com
 from pandas.core.sorting import (
@@ -403,15 +405,21 @@ class TestSafeSort(object):
         expected = np.array([0, 0, 1, 'a', 'b', 'b'], dtype=object)
         tm.assert_numpy_array_equal(result, expected)
 
+    @pytest.mark.skipif(PY2, reason="pytest.raises match regex fails")
     def test_unsortable(self):
         # GH 13714
         arr = np.array([1, 2, datetime.now(), 0, 3], dtype=object)
+        msg = ("'<' not supported between instances of 'datetime.datetime'"
+               r" and 'int'|"
+               r"unorderable types: int\(\) > datetime.datetime\(\)")
         if compat.PY2:
             # RuntimeWarning: tp_compare didn't return -1 or -2 for exception
             with warnings.catch_warnings():
-                pytest.raises(TypeError, safe_sort, arr)
+                with pytest.raises(TypeError, match=msg):
+                    safe_sort(arr)
         else:
-            pytest.raises(TypeError, safe_sort, arr)
+            with pytest.raises(TypeError, match=msg):
+                safe_sort(arr)
 
     def test_exceptions(self):
         with pytest.raises(TypeError,
diff --git a/pandas/tests/test_strings.py b/pandas/tests/test_strings.py
index 7cea3be03..bbcdc24f5 100644
--- a/pandas/tests/test_strings.py
+++ b/pandas/tests/test_strings.py
@@ -10,7 +10,7 @@ from numpy.random import randint
 import pytest
 
 import pandas.compat as compat
-from pandas.compat import PY3, range, u
+from pandas.compat import PY2, PY3, range, u
 
 from pandas import DataFrame, Index, MultiIndex, Series, concat, isna, notna
 import pandas.core.strings as strings
@@ -1002,11 +1002,13 @@ class TestStringMethods(object):
         tm.assert_series_equal(result, exp)
 
         # GH 13438
+        msg = "repl must be a string or callable"
         for klass in (Series, Index):
             for repl in (None, 3, {'a': 'b'}):
                 for data in (['a', 'b', None], ['a', 'b', 'c', 'ad']):
                     values = klass(data)
-                    pytest.raises(TypeError, values.str.replace, 'a', repl)
+                    with pytest.raises(TypeError, match=msg):
+                        values.str.replace('a', repl)
 
     def test_replace_callable(self):
         # GH 15055
@@ -1123,10 +1125,14 @@ class TestStringMethods(object):
         callable_repl = lambda m: m.group(0).swapcase()
         compiled_pat = re.compile('[a-z][A-Z]{2}')
 
-        pytest.raises(ValueError, values.str.replace, 'abc', callable_repl,
-                      regex=False)
-        pytest.raises(ValueError, values.str.replace, compiled_pat, '',
-                      regex=False)
+        msg = "Cannot use a callable replacement when regex=False"
+        with pytest.raises(ValueError, match=msg):
+            values.str.replace('abc', callable_repl, regex=False)
+
+        msg = ("Cannot use a compiled regex as replacement pattern with"
+               " regex=False")
+        with pytest.raises(ValueError, match=msg):
+            values.str.replace(compiled_pat, '', regex=False)
 
     def test_repeat(self):
         values = Series(['a', 'b', NA, 'c', NA, 'd'])
@@ -1242,12 +1248,13 @@ class TestStringMethods(object):
         for klass in [Series, Index]:
             # no groups
             s_or_idx = klass(['A1', 'B2', 'C3'])
-            f = lambda: s_or_idx.str.extract('[ABC][123]', expand=False)
-            pytest.raises(ValueError, f)
+            msg = "pattern contains no capture groups"
+            with pytest.raises(ValueError, match=msg):
+                s_or_idx.str.extract('[ABC][123]', expand=False)
 
             # only non-capturing groups
-            f = lambda: s_or_idx.str.extract('(?:[AB]).*', expand=False)
-            pytest.raises(ValueError, f)
+            with pytest.raises(ValueError, match=msg):
+                s_or_idx.str.extract('(?:[AB]).*', expand=False)
 
             # single group renames series/index properly
             s_or_idx = klass(['A1', 'A2'])
@@ -1387,12 +1394,13 @@ class TestStringMethods(object):
         for klass in [Series, Index]:
             # no groups
             s_or_idx = klass(['A1', 'B2', 'C3'])
-            f = lambda: s_or_idx.str.extract('[ABC][123]', expand=True)
-            pytest.raises(ValueError, f)
+            msg = "pattern contains no capture groups"
+            with pytest.raises(ValueError, match=msg):
+                s_or_idx.str.extract('[ABC][123]', expand=True)
 
             # only non-capturing groups
-            f = lambda: s_or_idx.str.extract('(?:[AB]).*', expand=True)
-            pytest.raises(ValueError, f)
+            with pytest.raises(ValueError, match=msg):
+                s_or_idx.str.extract('(?:[AB]).*', expand=True)
 
             # single group renames series/index properly
             s_or_idx = klass(['A1', 'A2'])
@@ -3315,10 +3323,14 @@ class TestStringMethods(object):
 
         tm.assert_series_equal(result, exp)
 
+    @pytest.mark.skipif(PY2, reason="pytest.raises match regex fails")
     def test_encode_decode_errors(self):
         encodeBase = Series([u('a'), u('b'), u('a\x9d')])
 
-        pytest.raises(UnicodeEncodeError, encodeBase.str.encode, 'cp1252')
+        msg = (r"'charmap' codec can't encode character '\\x9d' in position 1:"
+               " character maps to <undefined>")
+        with pytest.raises(UnicodeEncodeError, match=msg):
+            encodeBase.str.encode('cp1252')
 
         f = lambda x: x.encode('cp1252', 'ignore')
         result = encodeBase.str.encode('cp1252', 'ignore')
@@ -3327,7 +3339,10 @@ class TestStringMethods(object):
 
         decodeBase = Series([b'a', b'b', b'a\x9d'])
 
-        pytest.raises(UnicodeDecodeError, decodeBase.str.decode, 'cp1252')
+        msg = ("'charmap' codec can't decode byte 0x9d in position 1:"
+               " character maps to <undefined>")
+        with pytest.raises(UnicodeDecodeError, match=msg):
+            decodeBase.str.decode('cp1252')
 
         f = lambda x: x.decode('cp1252', 'ignore')
         result = decodeBase.str.decode('cp1252', 'ignore')
@@ -3418,7 +3433,8 @@ class TestStringMethods(object):
         lhs = Series(np.array(list('abc'), 'S1').astype(object))
         rhs = Series(np.array(list('def'), 'S1').astype(object))
         if compat.PY3:
-            pytest.raises(TypeError, lhs.str.cat, rhs)
+            with pytest.raises(TypeError, match="can't concat str to bytes"):
+                lhs.str.cat(rhs)
         else:
             result = lhs.str.cat(rhs)
             expected = Series(np.array(
diff --git a/pandas/tests/test_window.py b/pandas/tests/test_window.py
index e816d4c04..ce9d1888b 100644
--- a/pandas/tests/test_window.py
+++ b/pandas/tests/test_window.py
@@ -89,9 +89,8 @@ class TestApi(Base):
     def test_select_bad_cols(self):
         df = DataFrame([[1, 2]], columns=['A', 'B'])
         g = df.rolling(window=5)
-        pytest.raises(KeyError, g.__getitem__, ['C'])  # g[['C']]
-
-        pytest.raises(KeyError, g.__getitem__, ['A', 'C'])  # g[['A', 'C']]
+        with pytest.raises(KeyError, match="Columns not found: 'C'"):
+            g[['C']]
         with pytest.raises(KeyError, match='^[^A]+$'):
             # A should not be referenced as a bad column...
             # will have to rethink regex if you change message!
@@ -102,7 +101,9 @@ class TestApi(Base):
         df = DataFrame([[1, 2]], columns=['A', 'B'])
         r = df.rolling(window=5)
         tm.assert_series_equal(r.A.sum(), r['A'].sum())
-        pytest.raises(AttributeError, lambda: r.F)
+        msg = "'Rolling' object has no attribute 'F'"
+        with pytest.raises(AttributeError, match=msg):
+            r.F
 
     def tests_skip_nuisance(self):
 
@@ -217,12 +218,11 @@ class TestApi(Base):
         df = DataFrame({'A': range(5), 'B': range(0, 10, 2)})
         r = df.rolling(window=3)
 
-        def f():
+        msg = r"cannot perform renaming for (r1|r2) with a nested dictionary"
+        with pytest.raises(SpecificationError, match=msg):
             r.aggregate({'r1': {'A': ['mean', 'sum']},
                          'r2': {'B': ['mean', 'sum']}})
 
-        pytest.raises(SpecificationError, f)
-
         expected = concat([r['A'].mean(), r['A'].std(),
                            r['B'].mean(), r['B'].std()], axis=1)
         expected.columns = pd.MultiIndex.from_tuples([('ra', 'mean'), (
@@ -1806,26 +1806,38 @@ class TestMoments(Base):
     def test_ewm_domain_checks(self):
         # GH 12492
         s = Series(self.arr)
-        # com must satisfy: com >= 0
-        pytest.raises(ValueError, s.ewm, com=-0.1)
+        msg = "comass must satisfy: comass >= 0"
+        with pytest.raises(ValueError, match=msg):
+            s.ewm(com=-0.1)
         s.ewm(com=0.0)
         s.ewm(com=0.1)
-        # span must satisfy: span >= 1
-        pytest.raises(ValueError, s.ewm, span=-0.1)
-        pytest.raises(ValueError, s.ewm, span=0.0)
-        pytest.raises(ValueError, s.ewm, span=0.9)
+
+        msg = "span must satisfy: span >= 1"
+        with pytest.raises(ValueError, match=msg):
+            s.ewm(span=-0.1)
+        with pytest.raises(ValueError, match=msg):
+            s.ewm(span=0.0)
+        with pytest.raises(ValueError, match=msg):
+            s.ewm(span=0.9)
         s.ewm(span=1.0)
         s.ewm(span=1.1)
-        # halflife must satisfy: halflife > 0
-        pytest.raises(ValueError, s.ewm, halflife=-0.1)
-        pytest.raises(ValueError, s.ewm, halflife=0.0)
+
+        msg = "halflife must satisfy: halflife > 0"
+        with pytest.raises(ValueError, match=msg):
+            s.ewm(halflife=-0.1)
+        with pytest.raises(ValueError, match=msg):
+            s.ewm(halflife=0.0)
         s.ewm(halflife=0.1)
-        # alpha must satisfy: 0 < alpha <= 1
-        pytest.raises(ValueError, s.ewm, alpha=-0.1)
-        pytest.raises(ValueError, s.ewm, alpha=0.0)
+
+        msg = "alpha must satisfy: 0 < alpha <= 1"
+        with pytest.raises(ValueError, match=msg):
+            s.ewm(alpha=-0.1)
+        with pytest.raises(ValueError, match=msg):
+            s.ewm(alpha=0.0)
         s.ewm(alpha=0.1)
         s.ewm(alpha=1.0)
-        pytest.raises(ValueError, s.ewm, alpha=1.1)
+        with pytest.raises(ValueError, match=msg):
+            s.ewm(alpha=1.1)
 
     @pytest.mark.parametrize('method', ['mean', 'vol', 'var'])
     def test_ew_empty_series(self, method):
@@ -2598,7 +2610,10 @@ class TestMomentsConsistency(Base):
     def test_flex_binary_moment(self):
         # GH3155
         # don't blow the stack
-        pytest.raises(TypeError, rwindow._flex_binary_moment, 5, 6, None)
+        msg = ("arguments to moment function must be of type"
+               " np.ndarray/Series/DataFrame")
+        with pytest.raises(TypeError, match=msg):
+            rwindow._flex_binary_moment(5, 6, None)
 
     def test_corr_sanity(self):
         # GH 3155
@@ -2682,7 +2697,10 @@ class TestMomentsConsistency(Base):
                 Series([1.]), Series([1.]), 50, min_periods=min_periods)
             tm.assert_series_equal(result, Series([np.NaN]))
 
-        pytest.raises(Exception, func, A, randn(50), 20, min_periods=5)
+        msg = "Input arrays must be of the same type!"
+        # exception raised is Exception
+        with pytest.raises(Exception, match=msg):
+            func(A, randn(50), 20, min_periods=5)
 
     def test_expanding_apply_args_kwargs(self, raw):
 
@@ -3266,9 +3284,9 @@ class TestGrouperGrouping(object):
 
     def test_mutated(self):
 
-        def f():
+        msg = r"group\(\) got an unexpected keyword argument 'foo'"
+        with pytest.raises(TypeError, match=msg):
             self.frame.groupby('A', foo=1)
-        pytest.raises(TypeError, f)
 
         g = self.frame.groupby('A')
         assert not g.mutated

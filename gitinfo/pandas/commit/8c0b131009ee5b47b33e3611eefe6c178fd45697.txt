commit 8c0b131009ee5b47b33e3611eefe6c178fd45697
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Fri Jul 26 04:45:35 2019 -0700

    CLN: simplify indexing code (#27604)

diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index cb33044c4..a1a8619fa 100755
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -164,7 +164,7 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
 
     def _get_setitem_indexer(self, key):
         if self.axis is not None:
-            return self._convert_tuple(key, is_setter=True)
+            return self._convert_tuple(key)
 
         ax = self.obj._get_axis(0)
 
@@ -176,7 +176,7 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
 
         if isinstance(key, tuple):
             try:
-                return self._convert_tuple(key, is_setter=True)
+                return self._convert_tuple(key)
             except IndexingError:
                 pass
 
@@ -185,7 +185,7 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
 
         axis = self.axis or 0
         try:
-            return self._convert_to_indexer(key, axis=axis, is_setter=True)
+            return self._convert_to_indexer(key, axis=axis)
         except TypeError as e:
 
             # invalid indexer type vs 'other' indexing errors
@@ -241,22 +241,20 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
             return any(is_nested_tuple(tup, ax) for ax in self.obj.axes)
         return False
 
-    def _convert_tuple(self, key, is_setter: bool = False):
+    def _convert_tuple(self, key):
         keyidx = []
         if self.axis is not None:
             axis = self.obj._get_axis_number(self.axis)
             for i in range(self.ndim):
                 if i == axis:
-                    keyidx.append(
-                        self._convert_to_indexer(key, axis=axis, is_setter=is_setter)
-                    )
+                    keyidx.append(self._convert_to_indexer(key, axis=axis))
                 else:
                     keyidx.append(slice(None))
         else:
             for i, k in enumerate(key):
                 if i >= self.ndim:
                     raise IndexingError("Too many indexers")
-                idx = self._convert_to_indexer(k, axis=i, is_setter=is_setter)
+                idx = self._convert_to_indexer(k, axis=i)
                 keyidx.append(idx)
         return tuple(keyidx)
 
@@ -1184,9 +1182,7 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
             if not (ax.is_categorical() or ax.is_interval()):
                 warnings.warn(_missing_key_warning, FutureWarning, stacklevel=6)
 
-    def _convert_to_indexer(
-        self, obj, axis: int, is_setter: bool = False, raise_missing: bool = False
-    ):
+    def _convert_to_indexer(self, obj, axis: int, raise_missing: bool = False):
         """
         Convert indexing key into something we can use to do actual fancy
         indexing on an ndarray
@@ -1210,10 +1206,8 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
         try:
             obj = self._convert_scalar_indexer(obj, axis)
         except TypeError:
-
             # but we will allow setting
-            if is_setter:
-                pass
+            pass
 
         # see if we are positional in nature
         is_int_index = labels.is_integer()
@@ -1224,7 +1218,7 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
             return labels.get_loc(obj)
         except LookupError:
             if isinstance(obj, tuple) and isinstance(labels, MultiIndex):
-                if is_setter and len(obj) == labels.nlevels:
+                if len(obj) == labels.nlevels:
                     return {"key": obj}
                 raise
         except TypeError:
@@ -1238,17 +1232,14 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
 
             # if we are setting and its not a valid location
             # its an insert which fails by definition
-            if is_setter:
 
+            if self.name == "loc":
                 # always valid
-                if self.name == "loc":
-                    return {"key": obj}
+                return {"key": obj}
 
+            if obj >= self.obj.shape[axis] and not isinstance(labels, MultiIndex):
                 # a positional
-                if obj >= self.obj.shape[axis] and not isinstance(labels, MultiIndex):
-                    raise ValueError(
-                        "cannot set by positional indexing with enlargement"
-                    )
+                raise ValueError("cannot set by positional indexing with enlargement")
 
             return obj
 
@@ -1263,14 +1254,13 @@ class _NDFrameIndexer(_NDFrameIndexerBase):
                 return inds
             else:
                 # When setting, missing keys are not allowed, even with .loc:
-                kwargs = {"raise_missing": True if is_setter else raise_missing}
-                return self._get_listlike_indexer(obj, axis, **kwargs)[1]
+                return self._get_listlike_indexer(obj, axis, raise_missing=True)[1]
         else:
             try:
                 return labels.get_loc(obj)
             except LookupError:
                 # allow a not found key only if we are a setter
-                if not is_list_like_indexer(obj) and is_setter:
+                if not is_list_like_indexer(obj):
                     return {"key": obj}
                 raise
 
@@ -2127,9 +2117,7 @@ class _iLocIndexer(_LocationIndexer):
             return self._get_loc(key, axis=axis)
 
     # raise_missing is included for compat with the parent class signature
-    def _convert_to_indexer(
-        self, obj, axis: int, is_setter: bool = False, raise_missing: bool = False
-    ):
+    def _convert_to_indexer(self, obj, axis: int, raise_missing: bool = False):
         """ much simpler as we only have to deal with our valid types """
 
         # make need to convert a float key
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 6054f592f..c7fcab56e 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1077,7 +1077,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         else:
             return values[i]
 
-    def _slice(self, slobj, axis=0, kind=None):
+    def _slice(self, slobj: slice, axis: int = 0, kind=None):
         slobj = self.index._convert_slice_indexer(slobj, kind=kind or "getitem")
         return self._get_values(slobj)
 
diff --git a/pandas/core/sparse/series.py b/pandas/core/sparse/series.py
index 0c9c3a682..fc51c06b1 100644
--- a/pandas/core/sparse/series.py
+++ b/pandas/core/sparse/series.py
@@ -20,7 +20,6 @@ from pandas.core.dtypes.missing import isna, notna
 from pandas.core import generic
 from pandas.core.arrays import SparseArray
 from pandas.core.arrays.sparse import SparseAccessor
-from pandas.core.index import Index
 from pandas.core.internals import SingleBlockManager
 import pandas.core.ops as ops
 from pandas.core.series import Series
@@ -318,23 +317,23 @@ class SparseSeries(Series):
     # ----------------------------------------------------------------------
     # Indexing Methods
 
-    def _ixs(self, i, axis=0):
+    def _ixs(self, i: int, axis: int = 0):
         """
         Return the i-th value or values in the SparseSeries by location
 
         Parameters
         ----------
-        i : int, slice, or sequence of integers
+        i : int
+        axis: int
+            default 0, ignored
 
         Returns
         -------
         value : scalar (int) or Series (slice, sequence)
         """
-        label = self.index[i]
-        if isinstance(label, Index):
-            return self.take(i, axis=axis)
-        else:
-            return self._get_val_at(i)
+        assert is_integer(i), i
+        # equiv: self._get_val_at(i) since we have an integer
+        return self.values[i]
 
     def _get_val_at(self, loc):
         """ forward to the array """

commit bf6be7cbcf2ef2b4b9aec22f8647e674b17ca5b4
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Wed Apr 29 15:37:10 2020 -0700

    TST/REF: collect Index tests by method (#33870)

diff --git a/pandas/tests/indexes/datetimes/test_datetime.py b/pandas/tests/indexes/datetimes/test_datetime.py
index e0e5beaf4..50983dbd8 100644
--- a/pandas/tests/indexes/datetimes/test_datetime.py
+++ b/pandas/tests/indexes/datetimes/test_datetime.py
@@ -5,46 +5,13 @@ import numpy as np
 import pytest
 
 import pandas as pd
-from pandas import DataFrame, DatetimeIndex, Index, NaT, Timestamp, date_range, offsets
+from pandas import DataFrame, DatetimeIndex, Index, Timestamp, date_range, offsets
 import pandas._testing as tm
 
 randn = np.random.randn
 
 
 class TestDatetimeIndex:
-    def test_roundtrip_pickle_with_tz(self):
-
-        # GH 8367
-        # round-trip of timezone
-        index = date_range("20130101", periods=3, tz="US/Eastern", name="foo")
-        unpickled = tm.round_trip_pickle(index)
-        tm.assert_index_equal(index, unpickled)
-
-    def test_pickle(self):
-
-        # GH#4606
-        p = tm.round_trip_pickle(NaT)
-        assert p is NaT
-
-        idx = pd.to_datetime(["2013-01-01", NaT, "2014-01-06"])
-        idx_p = tm.round_trip_pickle(idx)
-        assert idx_p[0] == idx[0]
-        assert idx_p[1] is NaT
-        assert idx_p[2] == idx[2]
-
-        # GH#11002
-        # don't infer freq
-        idx = date_range("1750-1-1", "2050-1-1", freq="7D")
-        idx_p = tm.round_trip_pickle(idx)
-        tm.assert_index_equal(idx, idx_p)
-
-    def test_pickle_after_set_freq(self):
-        dti = date_range("20130101", periods=3, tz="US/Eastern", name="foo")
-        dti = dti._with_freq(None)
-
-        res = tm.round_trip_pickle(dti)
-        tm.assert_index_equal(res, dti)
-
     def test_reindex_preserves_tz_if_target_is_empty_list_or_array(self):
         # GH7774
         index = date_range("20130101", periods=3, tz="US/Eastern")
@@ -164,23 +131,6 @@ class TestDatetimeIndex:
         result = rng.append(idx)
         assert isinstance(result[0], Timestamp)
 
-    def test_map(self):
-        rng = date_range("1/1/2000", periods=10)
-
-        f = lambda x: x.strftime("%Y%m%d")
-        result = rng.map(f)
-        exp = Index([f(x) for x in rng], dtype="<U8")
-        tm.assert_index_equal(result, exp)
-
-    def test_map_fallthrough(self, capsys):
-        # GH#22067, check we don't get warnings about silently ignored errors
-        dti = date_range("2017-01-01", "2018-01-01", freq="B")
-
-        dti.map(lambda x: pd.Period(year=x.year, month=x.month, freq="M"))
-
-        captured = capsys.readouterr()
-        assert captured.err == ""
-
     def test_iteration_preserves_tz(self):
         # see gh-8890
         index = date_range("2012-01-01", periods=3, freq="H", tz="US/Eastern")
@@ -264,14 +214,6 @@ class TestDatetimeIndex:
         assert ordered[::-1].is_monotonic
         tm.assert_numpy_array_equal(dexer, np.array([0, 2, 1], dtype=np.intp))
 
-    def test_map_bug_1677(self):
-        index = DatetimeIndex(["2012-04-25 09:30:00.393000"])
-        f = index.asof
-
-        result = index.map(f)
-        expected = Index([f(index[0])])
-        tm.assert_index_equal(result, expected)
-
     def test_groupby_function_tuple_1677(self):
         df = DataFrame(np.random.rand(100), index=date_range("1/1/2000", periods=100))
         monthly_group = df.groupby(lambda x: (x.year, x.month))
@@ -454,18 +396,6 @@ class TestDatetimeIndex:
         expected = DataFrame(idx, index=idx)
         tm.assert_frame_equal(result, expected)
 
-    @pytest.mark.parametrize("name", [None, "name"])
-    def test_index_map(self, name):
-        # see GH20990
-        count = 6
-        index = pd.date_range("2018-01-01", periods=count, freq="M", name=name).map(
-            lambda x: (x.year, x.month)
-        )
-        exp_index = pd.MultiIndex.from_product(
-            ((2018,), range(1, 7)), names=[name, name]
-        )
-        tm.assert_index_equal(index, exp_index)
-
     def test_split_non_utc(self):
         # GH 14042
         indices = pd.date_range("2016-01-01 00:00:00+0200", freq="S", periods=10)
diff --git a/pandas/tests/indexes/datetimes/test_indexing.py b/pandas/tests/indexes/datetimes/test_indexing.py
index d81360440..d74b2bd03 100644
--- a/pandas/tests/indexes/datetimes/test_indexing.py
+++ b/pandas/tests/indexes/datetimes/test_indexing.py
@@ -518,6 +518,21 @@ class TestContains:
         ix = DatetimeIndex([d, d])
         assert d in ix
 
+    @pytest.mark.parametrize(
+        "vals",
+        [
+            [0, 1, 0],
+            [0, 0, -1],
+            [0, -1, -1],
+            ["2015", "2015", "2016"],
+            ["2015", "2015", "2014"],
+        ],
+    )
+    def test_contains_nonunique(self, vals):
+        # GH#9512
+        idx = DatetimeIndex(vals)
+        assert idx[0] in idx
+
 
 class TestGetIndexer:
     def test_get_indexer(self):
diff --git a/pandas/tests/indexes/datetimes/test_map.py b/pandas/tests/indexes/datetimes/test_map.py
new file mode 100644
index 000000000..2644ad761
--- /dev/null
+++ b/pandas/tests/indexes/datetimes/test_map.py
@@ -0,0 +1,41 @@
+import pytest
+
+from pandas import DatetimeIndex, Index, MultiIndex, Period, date_range
+import pandas._testing as tm
+
+
+class TestMap:
+    def test_map(self):
+        rng = date_range("1/1/2000", periods=10)
+
+        f = lambda x: x.strftime("%Y%m%d")
+        result = rng.map(f)
+        exp = Index([f(x) for x in rng], dtype="<U8")
+        tm.assert_index_equal(result, exp)
+
+    def test_map_fallthrough(self, capsys):
+        # GH#22067, check we don't get warnings about silently ignored errors
+        dti = date_range("2017-01-01", "2018-01-01", freq="B")
+
+        dti.map(lambda x: Period(year=x.year, month=x.month, freq="M"))
+
+        captured = capsys.readouterr()
+        assert captured.err == ""
+
+    def test_map_bug_1677(self):
+        index = DatetimeIndex(["2012-04-25 09:30:00.393000"])
+        f = index.asof
+
+        result = index.map(f)
+        expected = Index([f(index[0])])
+        tm.assert_index_equal(result, expected)
+
+    @pytest.mark.parametrize("name", [None, "name"])
+    def test_index_map(self, name):
+        # see GH#20990
+        count = 6
+        index = date_range("2018-01-01", periods=count, freq="M", name=name).map(
+            lambda x: (x.year, x.month)
+        )
+        exp_index = MultiIndex.from_product(((2018,), range(1, 7)), names=[name, name])
+        tm.assert_index_equal(index, exp_index)
diff --git a/pandas/tests/indexes/datetimes/test_ops.py b/pandas/tests/indexes/datetimes/test_ops.py
index 603a0a452..ea6381547 100644
--- a/pandas/tests/indexes/datetimes/test_ops.py
+++ b/pandas/tests/indexes/datetimes/test_ops.py
@@ -170,20 +170,6 @@ class TestDatetimeIndexOps:
 
         tm.assert_index_equal(idx.unique(), exp_idx)
 
-    def test_nonunique_contains(self):
-        # GH 9512
-        for idx in map(
-            DatetimeIndex,
-            (
-                [0, 1, 0],
-                [0, 0, -1],
-                [0, -1, -1],
-                ["2015", "2015", "2016"],
-                ["2015", "2015", "2014"],
-            ),
-        ):
-            assert idx[0] in idx
-
     @pytest.mark.parametrize(
         "idx",
         [
@@ -432,10 +418,6 @@ class TestBusinessDatetimeIndex:
         assert comp[11]
         assert not comp[9]
 
-    def test_pickle_unpickle(self):
-        unpickled = tm.round_trip_pickle(self.rng)
-        assert unpickled.freq is not None
-
     def test_copy(self):
         cp = self.rng.copy()
         repr(cp)
@@ -478,9 +460,5 @@ class TestCustomDatetimeIndex:
         repr(cp)
         tm.assert_index_equal(cp, self.rng)
 
-    def test_pickle_unpickle(self):
-        unpickled = tm.round_trip_pickle(self.rng)
-        assert unpickled.freq is not None
-
     def test_equals(self):
         assert not self.rng.equals(list(self.rng))
diff --git a/pandas/tests/indexes/datetimes/test_pickle.py b/pandas/tests/indexes/datetimes/test_pickle.py
new file mode 100644
index 000000000..bb08d4c66
--- /dev/null
+++ b/pandas/tests/indexes/datetimes/test_pickle.py
@@ -0,0 +1,41 @@
+import pytest
+
+from pandas import NaT, date_range, to_datetime
+import pandas._testing as tm
+
+
+class TestPickle:
+    def test_pickle(self):
+        # GH#4606
+        idx = to_datetime(["2013-01-01", NaT, "2014-01-06"])
+        idx_p = tm.round_trip_pickle(idx)
+        assert idx_p[0] == idx[0]
+        assert idx_p[1] is NaT
+        assert idx_p[2] == idx[2]
+
+    def test_pickle_dont_infer_freq(self):
+        # GH##11002
+        # don't infer freq
+        idx = date_range("1750-1-1", "2050-1-1", freq="7D")
+        idx_p = tm.round_trip_pickle(idx)
+        tm.assert_index_equal(idx, idx_p)
+
+    def test_pickle_after_set_freq(self):
+        dti = date_range("20130101", periods=3, tz="US/Eastern", name="foo")
+        dti = dti._with_freq(None)
+
+        res = tm.round_trip_pickle(dti)
+        tm.assert_index_equal(res, dti)
+
+    def test_roundtrip_pickle_with_tz(self):
+        # GH#8367
+        # round-trip of timezone
+        index = date_range("20130101", periods=3, tz="US/Eastern", name="foo")
+        unpickled = tm.round_trip_pickle(index)
+        tm.assert_index_equal(index, unpickled)
+
+    @pytest.mark.parametrize("freq", ["B", "C"])
+    def test_pickle_unpickle(self, freq):
+        rng = date_range("2009-01-01", "2010-01-01", freq=freq)
+        unpickled = tm.round_trip_pickle(rng)
+        assert unpickled.freq == freq
diff --git a/pandas/tests/indexes/period/test_factorize.py b/pandas/tests/indexes/period/test_factorize.py
new file mode 100644
index 000000000..7c9367a10
--- /dev/null
+++ b/pandas/tests/indexes/period/test_factorize.py
@@ -0,0 +1,37 @@
+import numpy as np
+
+from pandas import PeriodIndex
+import pandas._testing as tm
+
+
+class TestFactorize:
+    def test_factorize(self):
+        idx1 = PeriodIndex(
+            ["2014-01", "2014-01", "2014-02", "2014-02", "2014-03", "2014-03"], freq="M"
+        )
+
+        exp_arr = np.array([0, 0, 1, 1, 2, 2], dtype=np.intp)
+        exp_idx = PeriodIndex(["2014-01", "2014-02", "2014-03"], freq="M")
+
+        arr, idx = idx1.factorize()
+        tm.assert_numpy_array_equal(arr, exp_arr)
+        tm.assert_index_equal(idx, exp_idx)
+
+        arr, idx = idx1.factorize(sort=True)
+        tm.assert_numpy_array_equal(arr, exp_arr)
+        tm.assert_index_equal(idx, exp_idx)
+
+        idx2 = PeriodIndex(
+            ["2014-03", "2014-03", "2014-02", "2014-01", "2014-03", "2014-01"], freq="M"
+        )
+
+        exp_arr = np.array([2, 2, 1, 0, 2, 0], dtype=np.intp)
+        arr, idx = idx2.factorize(sort=True)
+        tm.assert_numpy_array_equal(arr, exp_arr)
+        tm.assert_index_equal(idx, exp_idx)
+
+        exp_arr = np.array([0, 0, 1, 2, 0, 2], dtype=np.intp)
+        exp_idx = PeriodIndex(["2014-03", "2014-02", "2014-01"], freq="M")
+        arr, idx = idx2.factorize()
+        tm.assert_numpy_array_equal(arr, exp_arr)
+        tm.assert_index_equal(idx, exp_idx)
diff --git a/pandas/tests/indexes/period/test_indexing.py b/pandas/tests/indexes/period/test_indexing.py
index f0efff4bb..2779cd92f 100644
--- a/pandas/tests/indexes/period/test_indexing.py
+++ b/pandas/tests/indexes/period/test_indexing.py
@@ -764,6 +764,27 @@ class TestContains:
 
         assert p3 not in idx0
 
+    def test_contains_freq_mismatch(self):
+        rng = period_range("2007-01", freq="M", periods=10)
+
+        assert Period("2007-01", freq="M") in rng
+        assert not Period("2007-01", freq="D") in rng
+        assert not Period("2007-01", freq="2M") in rng
+
+    def test_contains_nat(self):
+        # see gh-13582
+        idx = period_range("2007-01", freq="M", periods=10)
+        assert NaT not in idx
+        assert None not in idx
+        assert float("nan") not in idx
+        assert np.nan not in idx
+
+        idx = PeriodIndex(["2011-01", "NaT", "2011-02"], freq="M")
+        assert NaT in idx
+        assert None in idx
+        assert float("nan") in idx
+        assert np.nan in idx
+
 
 class TestAsOfLocs:
     def test_asof_locs_mismatched_type(self):
diff --git a/pandas/tests/indexes/period/test_period.py b/pandas/tests/indexes/period/test_period.py
index 0ce10fb87..d247d6571 100644
--- a/pandas/tests/indexes/period/test_period.py
+++ b/pandas/tests/indexes/period/test_period.py
@@ -318,37 +318,6 @@ class TestPeriodIndex(DatetimeLike):
         expected = pd.Series(expected_values, index=object_index)
         tm.assert_series_equal(result, expected)
 
-    def test_factorize(self):
-        idx1 = PeriodIndex(
-            ["2014-01", "2014-01", "2014-02", "2014-02", "2014-03", "2014-03"], freq="M"
-        )
-
-        exp_arr = np.array([0, 0, 1, 1, 2, 2], dtype=np.intp)
-        exp_idx = PeriodIndex(["2014-01", "2014-02", "2014-03"], freq="M")
-
-        arr, idx = idx1.factorize()
-        tm.assert_numpy_array_equal(arr, exp_arr)
-        tm.assert_index_equal(idx, exp_idx)
-
-        arr, idx = idx1.factorize(sort=True)
-        tm.assert_numpy_array_equal(arr, exp_arr)
-        tm.assert_index_equal(idx, exp_idx)
-
-        idx2 = PeriodIndex(
-            ["2014-03", "2014-03", "2014-02", "2014-01", "2014-03", "2014-01"], freq="M"
-        )
-
-        exp_arr = np.array([2, 2, 1, 0, 2, 0], dtype=np.intp)
-        arr, idx = idx2.factorize(sort=True)
-        tm.assert_numpy_array_equal(arr, exp_arr)
-        tm.assert_index_equal(idx, exp_idx)
-
-        exp_arr = np.array([0, 0, 1, 2, 0, 2], dtype=np.intp)
-        exp_idx = PeriodIndex(["2014-03", "2014-02", "2014-01"], freq="M")
-        arr, idx = idx2.factorize()
-        tm.assert_numpy_array_equal(arr, exp_arr)
-        tm.assert_index_equal(idx, exp_idx)
-
     def test_is_(self):
         create_index = lambda: period_range(freq="A", start="1/1/2001", end="12/1/2009")
         index = create_index()
@@ -367,27 +336,6 @@ class TestPeriodIndex(DatetimeLike):
         assert not index.is_(index - 2)
         assert not index.is_(index - 0)
 
-    def test_contains(self):
-        rng = period_range("2007-01", freq="M", periods=10)
-
-        assert Period("2007-01", freq="M") in rng
-        assert not Period("2007-01", freq="D") in rng
-        assert not Period("2007-01", freq="2M") in rng
-
-    def test_contains_nat(self):
-        # see gh-13582
-        idx = period_range("2007-01", freq="M", periods=10)
-        assert NaT not in idx
-        assert None not in idx
-        assert float("nan") not in idx
-        assert np.nan not in idx
-
-        idx = PeriodIndex(["2011-01", "NaT", "2011-02"], freq="M")
-        assert NaT in idx
-        assert None in idx
-        assert float("nan") in idx
-        assert np.nan in idx
-
     def test_periods_number_check(self):
         msg = (
             "Of the three parameters: start, end, and periods, exactly two "
diff --git a/pandas/tests/indexes/timedeltas/test_searchsorted.py b/pandas/tests/indexes/timedeltas/test_searchsorted.py
new file mode 100644
index 000000000..4806a9acf
--- /dev/null
+++ b/pandas/tests/indexes/timedeltas/test_searchsorted.py
@@ -0,0 +1,26 @@
+import numpy as np
+import pytest
+
+from pandas import Series, TimedeltaIndex, Timestamp, array
+import pandas._testing as tm
+
+
+class TestSearchSorted:
+    @pytest.mark.parametrize("klass", [list, np.array, array, Series])
+    def test_searchsorted_different_argument_classes(self, klass):
+        idx = TimedeltaIndex(["1 day", "2 days", "3 days"])
+        result = idx.searchsorted(klass(idx))
+        expected = np.arange(len(idx), dtype=result.dtype)
+        tm.assert_numpy_array_equal(result, expected)
+
+        result = idx._data.searchsorted(klass(idx))
+        tm.assert_numpy_array_equal(result, expected)
+
+    @pytest.mark.parametrize(
+        "arg", [[1, 2], ["a", "b"], [Timestamp("2020-01-01", tz="Europe/London")] * 2],
+    )
+    def test_searchsorted_invalid_argument_dtype(self, arg):
+        idx = TimedeltaIndex(["1 day", "2 days", "3 days"])
+        msg = "searchsorted requires compatible dtype"
+        with pytest.raises(TypeError, match=msg):
+            idx.searchsorted(arg)
diff --git a/pandas/tests/indexes/timedeltas/test_timedelta.py b/pandas/tests/indexes/timedeltas/test_timedelta.py
index 5efa1a757..a0521658f 100644
--- a/pandas/tests/indexes/timedeltas/test_timedelta.py
+++ b/pandas/tests/indexes/timedeltas/test_timedelta.py
@@ -11,7 +11,6 @@ from pandas import (
     Series,
     Timedelta,
     TimedeltaIndex,
-    array,
     date_range,
     timedelta_range,
 )
@@ -108,26 +107,6 @@ class TestTimedeltaIndex(DatetimeLike):
 
         tm.assert_numpy_array_equal(dexer, np.array([0, 2, 1]), check_dtype=False)
 
-    @pytest.mark.parametrize("klass", [list, np.array, array, Series])
-    def test_searchsorted_different_argument_classes(self, klass):
-        idx = TimedeltaIndex(["1 day", "2 days", "3 days"])
-        result = idx.searchsorted(klass(idx))
-        expected = np.arange(len(idx), dtype=result.dtype)
-        tm.assert_numpy_array_equal(result, expected)
-
-        result = idx._data.searchsorted(klass(idx))
-        tm.assert_numpy_array_equal(result, expected)
-
-    @pytest.mark.parametrize(
-        "arg",
-        [[1, 2], ["a", "b"], [pd.Timestamp("2020-01-01", tz="Europe/London")] * 2],
-    )
-    def test_searchsorted_invalid_argument_dtype(self, arg):
-        idx = TimedeltaIndex(["1 day", "2 days", "3 days"])
-        msg = "searchsorted requires compatible dtype"
-        with pytest.raises(TypeError, match=msg):
-            idx.searchsorted(arg)
-
     def test_argmin_argmax(self):
         idx = TimedeltaIndex(["1 day 00:00:05", "1 day 00:00:01", "1 day 00:00:02"])
         assert idx.argmin() == 1
diff --git a/pandas/tests/indexing/test_coercion.py b/pandas/tests/indexing/test_coercion.py
index 5b73118cf..5cc2399b6 100644
--- a/pandas/tests/indexing/test_coercion.py
+++ b/pandas/tests/indexing/test_coercion.py
@@ -102,14 +102,15 @@ class TestSetitemCoercion(CoercionBase):
         "val,exp_dtype",
         [(1, np.int64), (1.1, np.float64), (1 + 1j, np.complex128), (True, np.object)],
     )
-    def test_setitem_series_int64(self, val, exp_dtype):
+    def test_setitem_series_int64(self, val, exp_dtype, request):
         obj = pd.Series([1, 2, 3, 4])
         assert obj.dtype == np.int64
 
         if exp_dtype is np.float64:
             exp = pd.Series([1, 1, 3, 4])
             self._assert_setitem_series_conversion(obj, 1.1, exp, np.int64)
-            pytest.xfail("GH12747 The result must be float")
+            mark = pytest.mark.xfail(reason="GH12747 The result must be float")
+            request.node.add_marker(mark)
 
         exp = pd.Series([1, val, 3, 4])
         self._assert_setitem_series_conversion(obj, val, exp, exp_dtype)
@@ -117,14 +118,17 @@ class TestSetitemCoercion(CoercionBase):
     @pytest.mark.parametrize(
         "val,exp_dtype", [(np.int32(1), np.int8), (np.int16(2 ** 9), np.int16)]
     )
-    def test_setitem_series_int8(self, val, exp_dtype):
+    def test_setitem_series_int8(self, val, exp_dtype, request):
         obj = pd.Series([1, 2, 3, 4], dtype=np.int8)
         assert obj.dtype == np.int8
 
         if exp_dtype is np.int16:
             exp = pd.Series([1, 0, 3, 4], dtype=np.int8)
             self._assert_setitem_series_conversion(obj, val, exp, np.int8)
-            pytest.xfail("BUG: it must be Series([1, 1, 3, 4], dtype=np.int16")
+            mark = pytest.mark.xfail(
+                reason="BUG: it must be Series([1, 1, 3, 4], dtype=np.int16"
+            )
+            request.node.add_marker(mark)
 
         exp = pd.Series([1, val, 3, 4], dtype=np.int8)
         self._assert_setitem_series_conversion(obj, val, exp, exp_dtype)
@@ -171,22 +175,25 @@ class TestSetitemCoercion(CoercionBase):
             (True, np.bool),
         ],
     )
-    def test_setitem_series_bool(self, val, exp_dtype):
+    def test_setitem_series_bool(self, val, exp_dtype, request):
         obj = pd.Series([True, False, True, False])
         assert obj.dtype == np.bool
 
+        mark = None
         if exp_dtype is np.int64:
             exp = pd.Series([True, True, True, False])
             self._assert_setitem_series_conversion(obj, val, exp, np.bool)
-            pytest.xfail("TODO_GH12747 The result must be int")
+            mark = pytest.mark.xfail(reason="TODO_GH12747 The result must be int")
         elif exp_dtype is np.float64:
             exp = pd.Series([True, True, True, False])
             self._assert_setitem_series_conversion(obj, val, exp, np.bool)
-            pytest.xfail("TODO_GH12747 The result must be float")
+            mark = pytest.mark.xfail(reason="TODO_GH12747 The result must be float")
         elif exp_dtype is np.complex128:
             exp = pd.Series([True, True, True, False])
             self._assert_setitem_series_conversion(obj, val, exp, np.bool)
-            pytest.xfail("TODO_GH12747 The result must be complex")
+            mark = pytest.mark.xfail(reason="TODO_GH12747 The result must be complex")
+        if mark is not None:
+            request.node.add_marker(mark)
 
         exp = pd.Series([True, val, True, False])
         self._assert_setitem_series_conversion(obj, val, exp, exp_dtype)
@@ -318,7 +325,7 @@ class TestSetitemCoercion(CoercionBase):
     @pytest.mark.parametrize(
         "val,exp_dtype", [(5, IndexError), (5.1, np.float64), ("x", np.object)]
     )
-    def test_setitem_index_float64(self, val, exp_dtype):
+    def test_setitem_index_float64(self, val, exp_dtype, request):
         obj = pd.Series([1, 2, 3, 4], index=[1.1, 2.1, 3.1, 4.1])
         assert obj.index.dtype == np.float64
 
@@ -327,31 +334,31 @@ class TestSetitemCoercion(CoercionBase):
             temp = obj.copy()
             with pytest.raises(exp_dtype):
                 temp[5] = 5
-            pytest.xfail("TODO_GH12747 The result must be float")
-
+            mark = pytest.mark.xfail(reason="TODO_GH12747 The result must be float")
+            request.node.add_marker(mark)
         exp_index = pd.Index([1.1, 2.1, 3.1, 4.1, val])
         self._assert_setitem_index_conversion(obj, val, exp_index, exp_dtype)
 
     def test_setitem_series_period(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_setitem_index_complex128(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_setitem_index_bool(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_setitem_index_datetime64(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_setitem_index_datetime64tz(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_setitem_index_timedelta64(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_setitem_index_period(self):
-        pass
+        pytest.xfail("Test not implemented")
 
 
 class TestInsertIndexCoercion(CoercionBase):
@@ -503,10 +510,10 @@ class TestInsertIndexCoercion(CoercionBase):
                 pd.Index(data, freq="M")
 
     def test_insert_index_complex128(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_insert_index_bool(self):
-        pass
+        pytest.xfail("Test not implemented")
 
 
 class TestWhereCoercion(CoercionBase):
@@ -757,16 +764,16 @@ class TestWhereCoercion(CoercionBase):
         self._assert_where_conversion(obj, cond, values, exp, exp_dtype)
 
     def test_where_index_complex128(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_where_index_bool(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_where_series_timedelta64(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_where_series_period(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     @pytest.mark.parametrize(
         "value", [pd.Timedelta(days=9), timedelta(days=9), np.timedelta64(9, "D")]
@@ -818,7 +825,7 @@ class TestFillnaSeriesCoercion(CoercionBase):
     method = "fillna"
 
     def test_has_comprehensive_tests(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def _assert_fillna_conversion(self, original, value, expected, expected_dtype):
         """ test coercion triggered by fillna """
@@ -943,28 +950,28 @@ class TestFillnaSeriesCoercion(CoercionBase):
         self._assert_fillna_conversion(obj, fill_val, exp, fill_dtype)
 
     def test_fillna_series_int64(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_fillna_index_int64(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_fillna_series_bool(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_fillna_index_bool(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_fillna_series_timedelta64(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_fillna_series_period(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_fillna_index_timedelta64(self):
-        pass
+        pytest.xfail("Test not implemented")
 
     def test_fillna_index_period(self):
-        pass
+        pytest.xfail("Test not implemented")
 
 
 class TestReplaceSeriesCoercion(CoercionBase):
@@ -1121,4 +1128,4 @@ class TestReplaceSeriesCoercion(CoercionBase):
         tm.assert_series_equal(result, exp)
 
     def test_replace_series_period(self):
-        pass
+        pytest.xfail("Test not implemented")
diff --git a/pandas/tests/scalar/test_nat.py b/pandas/tests/scalar/test_nat.py
index 0e5414a8b..edda0391f 100644
--- a/pandas/tests/scalar/test_nat.py
+++ b/pandas/tests/scalar/test_nat.py
@@ -546,3 +546,9 @@ def test_nat_addsub_tdlike_scalar(obj):
     assert NaT + obj is NaT
     assert obj + NaT is NaT
     assert NaT - obj is NaT
+
+
+def test_pickle():
+    # GH#4606
+    p = tm.round_trip_pickle(NaT)
+    assert p is NaT

commit 9159d9804fca85166f6aefde4267be5d0c161082
Author: jreback <jeff@reback.net>
Date:   Wed Aug 20 08:44:37 2014 -0400

    BUG: fix reindexing to an all-nan Categorical (GH8076)

diff --git a/doc/source/v0.15.0.txt b/doc/source/v0.15.0.txt
index 851a4f458..b987104ac 100644
--- a/doc/source/v0.15.0.txt
+++ b/doc/source/v0.15.0.txt
@@ -346,7 +346,7 @@ Categoricals in Series/DataFrame
 
 :class:`~pandas.Categorical` can now be included in `Series` and `DataFrames` and gained new
 methods to manipulate. Thanks to Jan Schultz for much of this API/implementation. (:issue:`3943`, :issue:`5313`, :issue:`5314`,
-:issue:`7444`, :issue:`7839`, :issue:`7848`, :issue:`7864`, :issue:`7914`, :issue:`7768`, :issue:`8006`, :issue:`3678`, :issue:`8075`).
+:issue:`7444`, :issue:`7839`, :issue:`7848`, :issue:`7864`, :issue:`7914`, :issue:`7768`, :issue:`8006`, :issue:`3678`, :issue:`8075`, :issue:`8076`).
 
 For full docs, see the :ref:`Categorical introduction <categorical>` and the
 :ref:`API documentation <api.categorical>`.
diff --git a/pandas/core/categorical.py b/pandas/core/categorical.py
index 853feb27d..ec1de70e1 100644
--- a/pandas/core/categorical.py
+++ b/pandas/core/categorical.py
@@ -743,12 +743,14 @@ class Categorical(PandasObject):
                            name=self.name, fastpath=True)
 
     def take_nd(self, indexer, allow_fill=True, fill_value=None):
-        """ Take the values by the indexer, fill with the fill_value. """
-        if allow_fill and fill_value is None:
-            fill_value = np.nan
+        """ Take the codes by the indexer, fill with the fill_value. """
+
+        # filling must always be None/nan here
+        # but is passed thru internally
+        assert isnull(fill_value)
 
-        values = com.take_1d(self._codes, indexer, allow_fill=allow_fill, fill_value=fill_value)
-        result = Categorical(values=values, levels=self.levels, ordered=self.ordered,
+        codes = com.take_1d(self._codes, indexer, allow_fill=True, fill_value=-1)
+        result = Categorical(codes, levels=self.levels, ordered=self.ordered,
                              name=self.name, fastpath=True)
         return result
 
diff --git a/pandas/tests/test_categorical.py b/pandas/tests/test_categorical.py
index 5ee9fdb11..7bc2eeb97 100644
--- a/pandas/tests/test_categorical.py
+++ b/pandas/tests/test_categorical.py
@@ -858,6 +858,40 @@ class TestCategoricalAsBlock(tm.TestCase):
         res = Series(l,dtype='category')
         tm.assert_series_equal(res, exp)
 
+        # insert into frame with different index
+        # GH 8076
+        index = pd.date_range('20000101', periods=3)
+        expected = Series(Categorical(values=[np.nan,np.nan,np.nan],levels=['a', 'b', 'c']))
+        expected.index = index
+
+        expected = DataFrame({'x': expected})
+        df = DataFrame({'x': Series(['a', 'b', 'c'],dtype='category')}, index=index)
+        tm.assert_frame_equal(df, expected)
+
+    def test_reindex(self):
+
+        index = pd.date_range('20000101', periods=3)
+
+        # reindexing to an invalid Categorical
+        s = Series(['a', 'b', 'c'],dtype='category')
+        result = s.reindex(index)
+        expected = Series(Categorical(values=[np.nan,np.nan,np.nan],levels=['a', 'b', 'c']))
+        expected.index = index
+        tm.assert_series_equal(result, expected)
+
+        # partial reindexing
+        expected = Series(Categorical(values=['b','c'],levels=['a', 'b', 'c']))
+        expected.index = [1,2]
+        result = s.reindex([1,2])
+        tm.assert_series_equal(result, expected)
+
+        expected = Series(Categorical(values=['c',np.nan],levels=['a', 'b', 'c']))
+        expected.index = [2,3]
+        result = s.reindex([2,3])
+        tm.assert_series_equal(result, expected)
+
+
+
     def test_sideeffects_free(self):
 
         # Passing a categorical to a Series and then changing values in either the series or the

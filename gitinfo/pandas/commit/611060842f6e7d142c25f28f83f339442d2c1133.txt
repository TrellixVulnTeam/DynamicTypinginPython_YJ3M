commit 611060842f6e7d142c25f28f83f339442d2c1133
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Sep 17 09:42:30 2019 -0700

    TST: Parametrize and cleanup Exception (#28478)

diff --git a/pandas/tests/arithmetic/test_datetime64.py b/pandas/tests/arithmetic/test_datetime64.py
index bc7b979d2..6f7222f52 100644
--- a/pandas/tests/arithmetic/test_datetime64.py
+++ b/pandas/tests/arithmetic/test_datetime64.py
@@ -78,17 +78,6 @@ def assert_invalid_comparison(left, right, box):
         right >= left
 
 
-def assert_all(obj):
-    """
-    Test helper to call call obj.all() the appropriate number of times on
-    a Series or DataFrame.
-    """
-    if isinstance(obj, pd.DataFrame):
-        assert obj.all().all()
-    else:
-        assert obj.all()
-
-
 # ------------------------------------------------------------------
 # Comparisons
 
@@ -578,17 +567,17 @@ class TestDatetimeIndexComparisons:
             op(dz, np.array(list(dr), dtype=object))
 
         # The aware==aware and naive==naive comparisons should *not* raise
-        assert_all(dr == dr)
-        assert_all(dr == list(dr))
-        assert_all(list(dr) == dr)
-        assert_all(np.array(list(dr), dtype=object) == dr)
-        assert_all(dr == np.array(list(dr), dtype=object))
-
-        assert_all(dz == dz)
-        assert_all(dz == list(dz))
-        assert_all(list(dz) == dz)
-        assert_all(np.array(list(dz), dtype=object) == dz)
-        assert_all(dz == np.array(list(dz), dtype=object))
+        assert np.all(dr == dr)
+        assert np.all(dr == list(dr))
+        assert np.all(list(dr) == dr)
+        assert np.all(np.array(list(dr), dtype=object) == dr)
+        assert np.all(dr == np.array(list(dr), dtype=object))
+
+        assert np.all(dz == dz)
+        assert np.all(dz == list(dz))
+        assert np.all(list(dz) == dz)
+        assert np.all(np.array(list(dz), dtype=object) == dz)
+        assert np.all(dz == np.array(list(dz), dtype=object))
 
     @pytest.mark.parametrize(
         "op",
@@ -606,12 +595,12 @@ class TestDatetimeIndexComparisons:
         ts = pd.Timestamp("2000-03-14 01:59")
         ts_tz = pd.Timestamp("2000-03-14 01:59", tz="Europe/Amsterdam")
 
-        assert_all(dr > ts)
+        assert np.all(dr > ts)
         msg = "Cannot compare tz-naive and tz-aware"
         with pytest.raises(TypeError, match=msg):
             op(dr, ts_tz)
 
-        assert_all(dz > ts_tz)
+        assert np.all(dz > ts_tz)
         with pytest.raises(TypeError, match=msg):
             op(dz, ts)
 
diff --git a/pandas/tests/frame/test_indexing.py b/pandas/tests/frame/test_indexing.py
index a78b2ab7d..9175a1532 100644
--- a/pandas/tests/frame/test_indexing.py
+++ b/pandas/tests/frame/test_indexing.py
@@ -2160,23 +2160,6 @@ class TestDataFrameIndexing(TestData):
                 expected = float_frame.at[row, col]
                 assert result == expected
 
-    def test_nested_exception(self):
-        # Ignore the strange way of triggering the problem
-        # (which may get fixed), it's just a way to trigger
-        # the issue or reraising an outer exception without
-        # a named argument
-        df = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6], "c": [7, 8, 9]}).set_index(
-            ["a", "b"]
-        )
-        index = list(df.index)
-        index[0] = ["a", "b"]
-        df.index = index
-
-        try:
-            repr(df)
-        except Exception as e:
-            assert type(e) != UnboundLocalError
-
     @pytest.mark.parametrize(
         "method,expected_values",
         [
diff --git a/pandas/tests/indexing/common.py b/pandas/tests/indexing/common.py
index 9ceeb06b6..78764e676 100644
--- a/pandas/tests/indexing/common.py
+++ b/pandas/tests/indexing/common.py
@@ -210,22 +210,23 @@ class Base:
             try:
                 rs = getattr(obj, method1).__getitem__(_axify(obj, k1, a))
 
-                try:
-                    xp = self.get_result(obj, method2, k2, a)
-                except Exception:
-                    result = "no comp"
-                    _print(result)
-                    return
+                with catch_warnings(record=True):
+                    filterwarnings("ignore", "\\n.ix", FutureWarning)
+                    try:
+                        xp = self.get_result(obj, method2, k2, a)
+                    except (KeyError, IndexError):
+                        # TODO: why is this allowed?
+                        result = "no comp"
+                        _print(result)
+                        return
 
                 detail = None
 
                 try:
                     if is_scalar(rs) and is_scalar(xp):
                         assert rs == xp
-                    elif xp.ndim == 1:
-                        tm.assert_series_equal(rs, xp)
-                    elif xp.ndim == 2:
-                        tm.assert_frame_equal(rs, xp)
+                    else:
+                        tm.assert_equal(rs, xp)
                     result = "ok"
                 except AssertionError as e:
                     detail = str(e)
@@ -242,7 +243,7 @@ class Base:
 
             except AssertionError:
                 raise
-            except Exception as detail:
+            except (IndexError, TypeError, KeyError) as detail:
 
                 # if we are in fails, the ok, otherwise raise it
                 if fails is not None:
diff --git a/pandas/tests/series/test_api.py b/pandas/tests/series/test_api.py
index d204d7d2a..a3845fcbd 100644
--- a/pandas/tests/series/test_api.py
+++ b/pandas/tests/series/test_api.py
@@ -697,6 +697,7 @@ class TestCategoricalSeries:
             ("floor", ("D",), {}),
             ("ceil", ("D",), {}),
             ("asfreq", ("D",), {}),
+            # FIXME: don't leave commented-out
             # ('tz_localize', ("UTC",), {}),
         ]
         _special_func_names = [f[0] for f in special_func_defs]
@@ -729,20 +730,11 @@ class TestCategoricalSeries:
                     res = getattr(c.dt, func)(*args, **kwargs)
                     exp = getattr(s.dt, func)(*args, **kwargs)
 
-                if isinstance(res, DataFrame):
-                    tm.assert_frame_equal(res, exp)
-                elif isinstance(res, Series):
-                    tm.assert_series_equal(res, exp)
-                else:
-                    tm.assert_almost_equal(res, exp)
+                tm.assert_equal(res, exp)
 
             for attr in attr_names:
-                try:
-                    res = getattr(c.dt, attr)
-                    exp = getattr(s.dt, attr)
-                except Exception as e:
-                    print(name, attr)
-                    raise e
+                res = getattr(c.dt, attr)
+                exp = getattr(s.dt, attr)
 
             if isinstance(res, DataFrame):
                 tm.assert_frame_equal(res, exp)
diff --git a/pandas/tests/test_expressions.py b/pandas/tests/test_expressions.py
index ca514f62f..4c977d7fb 100644
--- a/pandas/tests/test_expressions.py
+++ b/pandas/tests/test_expressions.py
@@ -151,6 +151,7 @@ class TestExpressions:
     def run_series(self, ser, other, binary_comp=None, **kwargs):
         self.run_arithmetic(ser, other, assert_series_equal, test_flex=False, **kwargs)
         self.run_arithmetic(ser, other, assert_almost_equal, test_flex=True, **kwargs)
+        # FIXME: dont leave commented-out
         # series doesn't uses vec_compare instead of numexpr...
         # if binary_comp is None:
         #     binary_comp = other + 1
@@ -228,40 +229,36 @@ class TestExpressions:
         )
         assert result
 
-    def test_binary_ops(self):
+    @pytest.mark.parametrize(
+        "opname,op_str",
+        [("add", "+"), ("sub", "-"), ("mul", "*"), ("div", "/"), ("pow", "**")],
+    )
+    def test_binary_ops(self, opname, op_str):
         def testit():
 
             for f, f2 in [(self.frame, self.frame2), (self.mixed, self.mixed2)]:
 
-                for op, op_str in [
-                    ("add", "+"),
-                    ("sub", "-"),
-                    ("mul", "*"),
-                    ("div", "/"),
-                    ("pow", "**"),
-                ]:
+                if opname == "pow":
+                    continue
 
-                    if op == "pow":
-                        continue
-
-                    if op == "div":
-                        op = getattr(operator, "truediv", None)
-                    else:
-                        op = getattr(operator, op, None)
-                    if op is not None:
-                        result = expr._can_use_numexpr(op, op_str, f, f, "evaluate")
-                        assert result != f._is_mixed_type
+                if opname == "div":
+                    op = getattr(operator, "truediv", None)
+                else:
+                    op = getattr(operator, opname, None)
+                if op is not None:
+                    result = expr._can_use_numexpr(op, op_str, f, f, "evaluate")
+                    assert result != f._is_mixed_type
 
-                        result = expr.evaluate(op, op_str, f, f, use_numexpr=True)
-                        expected = expr.evaluate(op, op_str, f, f, use_numexpr=False)
+                    result = expr.evaluate(op, op_str, f, f, use_numexpr=True)
+                    expected = expr.evaluate(op, op_str, f, f, use_numexpr=False)
 
-                        if isinstance(result, DataFrame):
-                            tm.assert_frame_equal(result, expected)
-                        else:
-                            tm.assert_numpy_array_equal(result, expected.values)
+                    if isinstance(result, DataFrame):
+                        tm.assert_frame_equal(result, expected)
+                    else:
+                        tm.assert_numpy_array_equal(result, expected.values)
 
-                        result = expr._can_use_numexpr(op, op_str, f2, f2, "evaluate")
-                        assert not result
+                    result = expr._can_use_numexpr(op, op_str, f2, f2, "evaluate")
+                    assert not result
 
         expr.set_use_numexpr(False)
         testit()
@@ -271,7 +268,18 @@ class TestExpressions:
         expr.set_numexpr_threads()
         testit()
 
-    def test_boolean_ops(self):
+    @pytest.mark.parametrize(
+        "opname,op_str",
+        [
+            ("gt", ">"),
+            ("lt", "<"),
+            ("ge", ">="),
+            ("le", "<="),
+            ("eq", "=="),
+            ("ne", "!="),
+        ],
+    )
+    def test_comparison_ops(self, opname, op_str):
         def testit():
             for f, f2 in [(self.frame, self.frame2), (self.mixed, self.mixed2)]:
 
@@ -281,29 +289,20 @@ class TestExpressions:
                 f21 = f2
                 f22 = f2 + 1
 
-                for op, op_str in [
-                    ("gt", ">"),
-                    ("lt", "<"),
-                    ("ge", ">="),
-                    ("le", "<="),
-                    ("eq", "=="),
-                    ("ne", "!="),
-                ]:
+                op = getattr(operator, opname)
 
-                    op = getattr(operator, op)
+                result = expr._can_use_numexpr(op, op_str, f11, f12, "evaluate")
+                assert result != f11._is_mixed_type
 
-                    result = expr._can_use_numexpr(op, op_str, f11, f12, "evaluate")
-                    assert result != f11._is_mixed_type
-
-                    result = expr.evaluate(op, op_str, f11, f12, use_numexpr=True)
-                    expected = expr.evaluate(op, op_str, f11, f12, use_numexpr=False)
-                    if isinstance(result, DataFrame):
-                        tm.assert_frame_equal(result, expected)
-                    else:
-                        tm.assert_numpy_array_equal(result, expected.values)
+                result = expr.evaluate(op, op_str, f11, f12, use_numexpr=True)
+                expected = expr.evaluate(op, op_str, f11, f12, use_numexpr=False)
+                if isinstance(result, DataFrame):
+                    tm.assert_frame_equal(result, expected)
+                else:
+                    tm.assert_numpy_array_equal(result, expected.values)
 
-                    result = expr._can_use_numexpr(op, op_str, f21, f22, "evaluate")
-                    assert not result
+                result = expr._can_use_numexpr(op, op_str, f21, f22, "evaluate")
+                assert not result
 
         expr.set_use_numexpr(False)
         testit()
@@ -313,16 +312,16 @@ class TestExpressions:
         expr.set_numexpr_threads()
         testit()
 
-    def test_where(self):
+    @pytest.mark.parametrize("cond", [True, False])
+    def test_where(self, cond):
         def testit():
             for f in [self.frame, self.frame2, self.mixed, self.mixed2]:
 
-                for cond in [True, False]:
-                    c = np.empty(f.shape, dtype=np.bool_)
-                    c.fill(cond)
-                    result = expr.where(c, f.values, f.values + 1)
-                    expected = np.where(c, f.values, f.values + 1)
-                    tm.assert_numpy_array_equal(result, expected)
+                c = np.empty(f.shape, dtype=np.bool_)
+                c.fill(cond)
+                result = expr.where(c, f.values, f.values + 1)
+                expected = np.where(c, f.values, f.values + 1)
+                tm.assert_numpy_array_equal(result, expected)
 
         expr.set_use_numexpr(False)
         testit()
@@ -332,78 +331,81 @@ class TestExpressions:
         expr.set_numexpr_threads()
         testit()
 
-    def test_bool_ops_raise_on_arithmetic(self):
+    @pytest.mark.parametrize(
+        "op_str,opname", list(zip(["/", "//", "**"], ["truediv", "floordiv", "pow"]))
+    )
+    def test_bool_ops_raise_on_arithmetic(self, op_str, opname):
         df = DataFrame({"a": np.random.rand(10) > 0.5, "b": np.random.rand(10) > 0.5})
-        names = "truediv", "floordiv", "pow"
-        ops = "/", "//", "**"
+
         msg = "operator %r not implemented for bool dtypes"
-        for op, name in zip(ops, names):
-            f = getattr(operator, name)
-            err_msg = re.escape(msg % op)
+        f = getattr(operator, opname)
+        err_msg = re.escape(msg % op_str)
 
-            with pytest.raises(NotImplementedError, match=err_msg):
-                f(df, df)
+        with pytest.raises(NotImplementedError, match=err_msg):
+            f(df, df)
 
-            with pytest.raises(NotImplementedError, match=err_msg):
-                f(df.a, df.b)
+        with pytest.raises(NotImplementedError, match=err_msg):
+            f(df.a, df.b)
 
-            with pytest.raises(NotImplementedError, match=err_msg):
-                f(df.a, True)
+        with pytest.raises(NotImplementedError, match=err_msg):
+            f(df.a, True)
 
-            with pytest.raises(NotImplementedError, match=err_msg):
-                f(False, df.a)
+        with pytest.raises(NotImplementedError, match=err_msg):
+            f(False, df.a)
 
-            with pytest.raises(NotImplementedError, match=err_msg):
-                f(False, df)
+        with pytest.raises(NotImplementedError, match=err_msg):
+            f(False, df)
 
-            with pytest.raises(NotImplementedError, match=err_msg):
-                f(df, True)
+        with pytest.raises(NotImplementedError, match=err_msg):
+            f(df, True)
 
-    def test_bool_ops_warn_on_arithmetic(self):
+    @pytest.mark.parametrize(
+        "op_str,opname", list(zip(["+", "*", "-"], ["add", "mul", "sub"]))
+    )
+    def test_bool_ops_warn_on_arithmetic(self, op_str, opname):
         n = 10
         df = DataFrame({"a": np.random.rand(n) > 0.5, "b": np.random.rand(n) > 0.5})
-        names = "add", "mul", "sub"
-        ops = "+", "*", "-"
+
         subs = {"+": "|", "*": "&", "-": "^"}
         sub_funcs = {"|": "or_", "&": "and_", "^": "xor"}
-        for op, name in zip(ops, names):
-            f = getattr(operator, name)
-            fe = getattr(operator, sub_funcs[subs[op]])
-
-            if op == "-":
-                # raises TypeError
-                continue
-
-            with tm.use_numexpr(True, min_elements=5):
-                with tm.assert_produces_warning(check_stacklevel=False):
-                    r = f(df, df)
-                    e = fe(df, df)
-                    tm.assert_frame_equal(r, e)
-
-                with tm.assert_produces_warning(check_stacklevel=False):
-                    r = f(df.a, df.b)
-                    e = fe(df.a, df.b)
-                    tm.assert_series_equal(r, e)
-
-                with tm.assert_produces_warning(check_stacklevel=False):
-                    r = f(df.a, True)
-                    e = fe(df.a, True)
-                    tm.assert_series_equal(r, e)
-
-                with tm.assert_produces_warning(check_stacklevel=False):
-                    r = f(False, df.a)
-                    e = fe(False, df.a)
-                    tm.assert_series_equal(r, e)
-
-                with tm.assert_produces_warning(check_stacklevel=False):
-                    r = f(False, df)
-                    e = fe(False, df)
-                    tm.assert_frame_equal(r, e)
-
-                with tm.assert_produces_warning(check_stacklevel=False):
-                    r = f(df, True)
-                    e = fe(df, True)
-                    tm.assert_frame_equal(r, e)
+
+        f = getattr(operator, opname)
+        fe = getattr(operator, sub_funcs[subs[op_str]])
+
+        if op_str == "-":
+            # raises TypeError
+            return
+
+        with tm.use_numexpr(True, min_elements=5):
+            with tm.assert_produces_warning(check_stacklevel=False):
+                r = f(df, df)
+                e = fe(df, df)
+                tm.assert_frame_equal(r, e)
+
+            with tm.assert_produces_warning(check_stacklevel=False):
+                r = f(df.a, df.b)
+                e = fe(df.a, df.b)
+                tm.assert_series_equal(r, e)
+
+            with tm.assert_produces_warning(check_stacklevel=False):
+                r = f(df.a, True)
+                e = fe(df.a, True)
+                tm.assert_series_equal(r, e)
+
+            with tm.assert_produces_warning(check_stacklevel=False):
+                r = f(False, df.a)
+                e = fe(False, df.a)
+                tm.assert_series_equal(r, e)
+
+            with tm.assert_produces_warning(check_stacklevel=False):
+                r = f(False, df)
+                e = fe(False, df)
+                tm.assert_frame_equal(r, e)
+
+            with tm.assert_produces_warning(check_stacklevel=False):
+                r = f(df, True)
+                e = fe(df, True)
+                tm.assert_frame_equal(r, e)
 
     @pytest.mark.parametrize(
         "test_input,expected",
diff --git a/pandas/tests/tseries/offsets/test_offsets.py b/pandas/tests/tseries/offsets/test_offsets.py
index 1abc8aece..3ed25b8d3 100644
--- a/pandas/tests/tseries/offsets/test_offsets.py
+++ b/pandas/tests/tseries/offsets/test_offsets.py
@@ -132,10 +132,7 @@ class Base:
         elif klass is DateOffset:
             klass = klass(days=value, normalize=normalize)
         else:
-            try:
-                klass = klass(value, normalize=normalize)
-            except Exception:
-                klass = klass(normalize=normalize)
+            klass = klass(value, normalize=normalize)
         return klass
 
     def test_apply_out_of_range(self, tz_naive_fixture):

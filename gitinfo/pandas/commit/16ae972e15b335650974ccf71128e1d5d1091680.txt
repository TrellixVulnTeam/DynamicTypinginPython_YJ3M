commit 16ae972e15b335650974ccf71128e1d5d1091680
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sun May 23 23:28:58 2010 +0000

    unit tests
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@172 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index be8306ef0..455d12b11 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -276,8 +276,12 @@ class DateRange(Index):
 
     __str__ = __repr__
 
-    def shift(self, n):
+    def shift(self, n, offset=None):
+        if offset is not None and offset != self.offset:
+            return Index.shift(self, n, offset)
+
         if n == 0:
+            # immutable so OK
             return self
 
         start = self[0] + n * self.offset
diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 408741534..b7ee84dc6 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -154,11 +154,11 @@ class DateOffset(object):
 
     def __sub__(self, other):
         if isinstance(other, datetime):
-            raise Exception('Cannot subtract datetime from offset!')
+            raise TypeError('Cannot subtract datetime from offset!')
         elif type(other) == type(self):
             return self.__class__(self.n - other.n, **self.kwds)
-        else:
-            raise Exception('Cannot subtract %s from %s'
+        else: # pragma: no cover
+            raise TypeError('Cannot subtract %s from %s'
                             % (type(other), type(self)))
 
     def __rsub__(self, other):
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index fd17d5b75..2006306b6 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -918,6 +918,25 @@ class DataFrame(Picklable, Groupable):
 
         return result
 
+    def groupby(self, mapper, axis=0):
+        """
+        Goup series using mapper (dict or key function, apply given
+        function to group, return result as series).
+
+        Parameters
+        ----------
+        mapper : function, dict or Series
+            Called on each element of the object index to determine
+            the groups.  If a dict or Series is passed, the Series or
+            dict VALUES will be used to determine the groups
+
+        Returns
+        -------
+        GroupBy object
+        """
+        from pandas.core.groupby import groupby
+        return groupby(self, mapper, axis=axis)
+
     def rename(self, index=None, columns=None):
         """
         Alter index and / or columns using input function or functions
@@ -964,7 +983,13 @@ class DataFrame(Picklable, Groupable):
         self.index = [mapper(x) for x in self.index]
 
     def _rename_columns_inplace(self, mapper):
-        self._series = dict((mapper(k), v) for k, v in self._series.iteritems())
+        new_series = {}
+        for k, v in self._series.iteritems():
+            new_k = mapper(k)
+            if new_k in new_series:
+                raise Exception('Non-unique mapping!')
+            new_series[new_k] = v
+        self._series = new_series
 
     @property
     def T(self):
@@ -1024,13 +1049,7 @@ class DataFrame(Picklable, Groupable):
             newValues = dict([(col, do_shift(series))
                               for col, series in self.iteritems()])
         else:
-            if (isinstance(self.index, DateRange) and
-                offset == self.index.offset):
-                newIndex = self.index.shift(periods)
-            else:
-                offset = periods * offset
-                newIndex = Index([idx + offset for idx in self.index])
-
+            newIndex = self.index.shift(periods, offset)
             newValues = dict([(col, np.asarray(series))
                                for col, series in self.iteritems()])
 
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index b0adb4c4d..98b33f2c7 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -1,4 +1,4 @@
-import numpy as np
+from cStringIO import StringIO
 
 from pandas.core.frame import DataFrame
 from pandas.core.matrix import DataMatrix
@@ -7,8 +7,6 @@ import pandas.lib.tseries as tseries
 
 class GroupDict(dict):
     def __repr__(self):
-        from cStringIO import StringIO
-
         stringDict = dict([(str(x), x) for x in self])
         sortedKeys = sorted(stringDict)
 
@@ -24,7 +22,7 @@ class GroupDict(dict):
 
         return output.getvalue()
 
-def groupby(obj, grouper):
+def groupby(obj, grouper, **kwds):
     """
     Intercepts creation and dispatches to the appropriate class based
     on type.
@@ -38,16 +36,13 @@ def groupby(obj, grouper):
     else: # pragma: no cover
         raise TypeError('invalid type: %s' % type(obj))
 
-    return klass(obj, grouper)
+    return klass(obj, grouper, **kwds)
 
 class GroupBy(object):
     """
     Class for grouping and aggregating relational data.
 
-    Supported classes
-    -----------------
-    Series / TimeSeries
-    DataFrame / DataMatrix (and derivatives thereof)
+    Supported classes: Series, DataFrame, DataMatrix
     """
     _groups = None
     _group_indices = None
@@ -61,7 +56,8 @@ class GroupBy(object):
     @property
     def groups(self):
         if self._groups is None:
-            self._groups = tseries.groupby(self.obj.index, self.grouper,
+            axis = self._group_axis
+            self._groups = tseries.groupby(axis, self.grouper,
                                            output=GroupDict())
 
         return self._groups
@@ -69,11 +65,17 @@ class GroupBy(object):
     @property
     def group_indices(self):
         if self._group_indices is None:
-            self._group_indices = tseries.groupby_indices(self.obj.index,
+            axis = self._group_axis
+            self._group_indices = tseries.groupby_indices(axis,
                                                           self.grouper)
 
         return self._group_indices
 
+    @property
+    def _group_axis(self):
+        # default
+        return self.obj.index
+
     def getGroup(self, groupList):
         return self.obj.reindex(groupList)
 
@@ -220,12 +222,24 @@ class SeriesGroupBy(GroupBy):
         return Series(allSeries)
 
 class DataFrameGroupBy(GroupBy):
-    def __init__(self, obj, grouper):
-        if isinstance(grouper, basestring) and grouper in obj:
+    def __init__(self, obj, grouper, axis=0):
+        if isinstance(grouper, basestring):
             grouper = obj[grouper].get
 
+        self.axis = axis
+
+        if axis not in (0, 1): # pragma: no cover
+            raise Exception('invalid axis')
+
         GroupBy.__init__(self, obj, grouper)
 
+    @property
+    def _group_axis(self):
+        if self.axis == 0:
+            return self.obj.index
+        else:
+            return self.obj.columns
+
     def aggregate(self, applyfunc):
         """
         For given DataFrame, group index by given mapper function or dict, take
@@ -246,6 +260,12 @@ class DataFrameGroupBy(GroupBy):
 
         Optional: provide set mapping as dictionary
         """
+        if self.axis == 0:
+            return self._aggregate_index(applyfunc)
+        else:
+            return self._aggregate_columns(applyfunc)
+
+    def _aggregate_index(self, applyfunc):
         result = {}
         for groupName in self.groups:
             result[groupName] = self[groupName].apply(applyfunc)
@@ -253,6 +273,9 @@ class DataFrameGroupBy(GroupBy):
 
         return DataFrame(data=result).T
 
+    def _aggregate_columns(self, applyfunc):
+        pass
+
     def transform(self, applyfunc):
         """
         For given DataFrame, group index by given mapper function or dict, take
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 72d5468a4..525d93911 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -3,6 +3,7 @@
 # pylint: disable-msg=W0232
 
 import numpy as np
+from pandas.core.datetools import DateOffset
 from pandas.lib.tseries import map_indices, isAllDates
 
 def _indexOp(opname):
@@ -131,6 +132,17 @@ class Index(np.ndarray):
     def sort(self, *args, **kwargs):
         raise Exception('Cannot sort an Index object')
 
+    def shift(self, periods, offset):
+        if not isinstance(offset, DateOffset):
+            raise TypeError('must pass DateOffset')
+
+        if periods == 0:
+            # OK because immutable
+            return self
+
+        offset = periods * offset
+        return Index([idx + offset for idx in self])
+
     def argsort(self, *args, **kwargs):
         return self.view(np.ndarray).argsort(*args, **kwargs)
 
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index f5a93f956..1d6cb8f40 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -60,7 +60,13 @@ class DataMatrix(DataFrame):
                         objects = objects.reindex(index)
                 else:
                     objects = DataMatrix(objects, index=index)
-
+        elif isinstance(data, DataFrame):
+            if not isinstance(data, DataMatrix):
+                data = data.toDataMatrix()
+            values = data.values
+            index = data.index
+            columns = data.columns
+            objects = data.objects
         elif data is None or len(data) == 0:
             # this is a touch convoluted...
             if objects is not None:
@@ -382,8 +388,10 @@ class DataMatrix(DataFrame):
             hisIndexer =  [hisCols.indexMap[idx] for idx in commonCols]
             resultIndexer = [newCols.indexMap[idx] for idx in commonCols]
 
-            resultMatrix[:, resultIndexer] = func(myValues[:, myIndexer],
-                                                  hisValues[:, hisIndexer])
+            left = myValues.take(myIndexer, axis=1)
+            right = hisValues.take(hisIndexer, axis=1)
+
+            resultMatrix[:, resultIndexer] = func(left, right)
 
         # TODO: deal with objects
         return DataMatrix(resultMatrix, index=newIndex, columns=newCols)
@@ -1215,12 +1223,7 @@ class DataMatrix(DataFrame):
                 newValues = self.values.take(indexer, axis=0)
                 newValues[periods:] = NaN
         else:
-            if (isinstance(self.index, DateRange) and
-                offset == self.index.offset):
-                newIndex = self.index.shift(periods)
-            else:
-                tot_offset = periods * offset
-                newIndex = Index([idx + tot_offset for idx in self.index])
+            newIndex = self.index.shift(periods, offset)
             newValues = self.values.copy()
 
         if self.objects is not None:
diff --git a/pandas/core/tests/test_datetools.py b/pandas/core/tests/test_datetools.py
index ec5f54869..7177a6eb6 100644
--- a/pandas/core/tests/test_datetools.py
+++ b/pandas/core/tests/test_datetools.py
@@ -41,9 +41,6 @@ def test_normalize_date():
 ### DateOffset Tests
 #####
 
-def myAssert(actual, expected):
-    assert actual == expected
-
 class TestDateOffset(object):
 
     def setUp(self):
@@ -96,45 +93,49 @@ class TestBusinessDay(unittest.TestCase):
         assert (self.d + offset) == datetime(2008, 1, 2, 2)
 
     def testEQ(self):
-        myAssert(self.offset2, self.offset2)
+        self.assertEqual(self.offset2, self.offset2)
 
     def test_mul(self):
         pass
 
     def test_hash(self):
-        myAssert(hash(self.offset2), hash(self.offset2))
+        self.assertEqual(hash(self.offset2), hash(self.offset2))
 
     def testCall(self):
-        myAssert(self.offset2(self.d), datetime(2008, 1, 3))
+        self.assertEqual(self.offset2(self.d), datetime(2008, 1, 3))
 
     def testRAdd(self):
-        myAssert(self.d + self.offset2, self.offset2 + self.d)
+        self.assertEqual(self.d + self.offset2, self.offset2 + self.d)
 
     def testSub(self):
-        myAssert(self.d - self.offset2,  self.d + BDay(-2))
+        off = self.offset2
+        self.assertRaises(Exception, off.__sub__, self.d)
+        self.assertEqual(2 * off - off, off)
+
+        self.assertEqual(self.d - self.offset2,  self.d + BDay(-2))
 
     def testRSub(self):
-        myAssert(self.d - self.offset2, (-self.offset2).apply(self.d))
+        self.assertEqual(self.d - self.offset2, (-self.offset2).apply(self.d))
 
     def testMult1(self):
-        myAssert(self.d + 10*self.offset, self.d + BDay(10))
+        self.assertEqual(self.d + 10*self.offset, self.d + BDay(10))
 
     def testMult2(self):
-        myAssert(self.d + (-5*BDay(-10)),
-                 self.d + BDay(50))
+        self.assertEqual(self.d + (-5*BDay(-10)),
+                         self.d + BDay(50))
 
 
     def testRollback1(self):
-        myAssert(BDay(10).rollback(self.d), self.d)
+        self.assertEqual(BDay(10).rollback(self.d), self.d)
 
     def testRollback2(self):
-        myAssert(BDay(10).rollback(datetime(2008, 1, 5)), datetime(2008, 1, 4))
+        self.assertEqual(BDay(10).rollback(datetime(2008, 1, 5)), datetime(2008, 1, 4))
 
     def testRollforward1(self):
-        myAssert(BDay(10).rollforward(self.d), self.d)
+        self.assertEqual(BDay(10).rollforward(self.d), self.d)
 
     def testRollforward2(self):
-        myAssert(BDay(10).rollforward(datetime(2008, 1, 5)), datetime(2008, 1, 7))
+        self.assertEqual(BDay(10).rollforward(datetime(2008, 1, 5)), datetime(2008, 1, 7))
 
     def test_onOffset(self):
         tests = [(BDay(), datetime(2008, 1, 1), True),
@@ -558,6 +559,10 @@ class TestYearBegin(unittest.TestCase):
 
 class TestBYearEndLagged(unittest.TestCase):
 
+    def test_bad_month_fail(self):
+        self.assertRaises(Exception, BYearEnd, month=13)
+        self.assertRaises(Exception, BYearEnd, month=0)
+
     def test_offset(self):
         tests = []
 
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index 6f0e99e39..a3b565bea 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -68,6 +68,9 @@ class TestDataFrame(unittest.TestCase):
         df = self.klass(data={})
         self.assert_(len(df.index) == 0)
 
+        df = self.klass(self.frame)
+        assert_frame_equal(df, self.frame)
+
     def test_constructor_mixed(self):
         index, data = common.getMixedTypeDict()
 
@@ -798,6 +801,47 @@ class TestDataFrame(unittest.TestCase):
         newFrame = self.frame.reindex(list(self.ts1.index))
         self.assert_(newFrame.index.equals(self.ts1.index))
 
+    def test_rename(self):
+        mapping = {
+            'A' : 'a',
+            'B' : 'b',
+            'C' : 'c',
+            'D' : 'd'
+        }
+        bad_mapping = {
+            'A' : 'a',
+            'B' : 'b',
+            'C' : 'b',
+            'D' : 'd'
+        }
+
+        renamed = self.frame.rename(columns=mapping)
+        renamed2 = self.frame.rename(columns=str.lower)
+
+        assert_frame_equal(renamed, renamed2)
+        assert_frame_equal(renamed2.rename(columns=str.upper),
+                           self.frame)
+
+        self.assertRaises(Exception, self.frame.rename,
+                          columns=bad_mapping)
+
+        # index
+
+        data = {
+            'A' : {'foo' : 0, 'bar' : 1}
+        }
+
+        # gets sorted alphabetical
+        df = self.klass(data)
+        renamed = df.rename(index={'foo' : 'bar', 'bar' : 'foo'})
+        self.assert_(np.array_equal(renamed.index, ['foo', 'bar']))
+
+        renamed = df.rename(index=str.upper)
+        self.assert_(np.array_equal(renamed.index, ['BAR', 'FOO']))
+
+        # have to pass something
+        self.assertRaises(Exception, self.frame.rename)
+
     def test_reindex_columns(self):
         newFrame = self.frame.reindex(columns=['A', 'B', 'E'])
 

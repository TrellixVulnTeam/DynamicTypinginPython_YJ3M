commit fb178fc5e9793a0684d486c37d5bd8c2c54bcbf5
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon Dec 18 04:34:09 2017 -0800

    Centralize arithmetic tests for datetime/timedelta series (#18809)

diff --git a/pandas/tests/series/test_operators.py b/pandas/tests/series/test_operators.py
index 6cc866a35..89a631115 100644
--- a/pandas/tests/series/test_operators.py
+++ b/pandas/tests/series/test_operators.py
@@ -28,8 +28,7 @@ import pandas.util.testing as tm
 from .common import TestData
 
 
-class TestSeriesOperators(TestData):
-
+class TestSeriesComparisons(object):
     def test_series_comparison_scalars(self):
         series = Series(date_range('1/1/2000', periods=10))
 
@@ -63,1326 +62,1410 @@ class TestSeriesOperators(TestData):
         assert_series_equal(s == s2, exp)
         assert_series_equal(s2 == s, exp)
 
-    def test_op_method(self):
-        def check(series, other, check_reverse=False):
-            simple_ops = ['add', 'sub', 'mul', 'floordiv', 'truediv', 'pow']
-            if not compat.PY3:
-                simple_ops.append('div')
+    def test_operator_series_comparison_zerorank(self):
+        # GH 13006
+        result = np.float64(0) > pd.Series([1, 2, 3])
+        expected = 0.0 > pd.Series([1, 2, 3])
+        tm.assert_series_equal(result, expected)
+        result = pd.Series([1, 2, 3]) < np.float64(0)
+        expected = pd.Series([1, 2, 3]) < 0.0
+        tm.assert_series_equal(result, expected)
+        result = np.array([0, 1, 2])[0] > pd.Series([0, 1, 2])
+        expected = 0.0 > pd.Series([1, 2, 3])
+        tm.assert_series_equal(result, expected)
 
-            for opname in simple_ops:
-                op = getattr(Series, opname)
+    def test_object_comparisons(self):
+        s = Series(['a', 'b', np.nan, 'c', 'a'])
 
-                if op == 'div':
-                    alt = operator.truediv
-                else:
-                    alt = getattr(operator, opname)
+        result = s == 'a'
+        expected = Series([True, False, False, False, True])
+        assert_series_equal(result, expected)
 
-                result = op(series, other)
-                expected = alt(series, other)
-                assert_almost_equal(result, expected)
-                if check_reverse:
-                    rop = getattr(Series, "r" + opname)
-                    result = rop(series, other)
-                    expected = alt(other, series)
-                    assert_almost_equal(result, expected)
+        result = s < 'a'
+        expected = Series([False, False, False, False, False])
+        assert_series_equal(result, expected)
 
-        check(self.ts, self.ts * 2)
-        check(self.ts, self.ts[::2])
-        check(self.ts, 5, check_reverse=True)
-        check(tm.makeFloatSeries(), tm.makeFloatSeries(), check_reverse=True)
+        result = s != 'a'
+        expected = -(s == 'a')
+        assert_series_equal(result, expected)
 
-    def test_neg(self):
-        assert_series_equal(-self.series, -1 * self.series)
+    def test_categorical_comparisons(self):
+        # GH 8938
+        # allow equality comparisons
+        a = Series(list('abc'), dtype="category")
+        b = Series(list('abc'), dtype="object")
+        c = Series(['a', 'b', 'cc'], dtype="object")
+        d = Series(list('acb'), dtype="object")
+        e = Categorical(list('abc'))
+        f = Categorical(list('acb'))
 
-    def test_invert(self):
-        assert_series_equal(-(self.series < 0), ~(self.series < 0))
+        # vs scalar
+        assert not (a == 'a').all()
+        assert ((a != 'a') == ~(a == 'a')).all()
 
-    def test_div(self):
-        with np.errstate(all='ignore'):
-            # no longer do integer div for any ops, but deal with the 0's
-            p = DataFrame({'first': [3, 4, 5, 8], 'second': [0, 0, 0, 3]})
-            result = p['first'] / p['second']
-            expected = Series(
-                p['first'].values.astype(float) / p['second'].values,
-                dtype='float64')
-            expected.iloc[0:3] = np.inf
-            assert_series_equal(result, expected)
+        assert not ('a' == a).all()
+        assert (a == 'a')[0]
+        assert ('a' == a)[0]
+        assert not ('a' != a)[0]
 
-            result = p['first'] / 0
-            expected = Series(np.inf, index=p.index, name='first')
-            assert_series_equal(result, expected)
+        # vs list-like
+        assert (a == a).all()
+        assert not (a != a).all()
 
-            p = p.astype('float64')
-            result = p['first'] / p['second']
-            expected = Series(p['first'].values / p['second'].values)
-            assert_series_equal(result, expected)
+        assert (a == list(a)).all()
+        assert (a == b).all()
+        assert (b == a).all()
+        assert ((~(a == b)) == (a != b)).all()
+        assert ((~(b == a)) == (b != a)).all()
 
-            p = DataFrame({'first': [3, 4, 5, 8], 'second': [1, 1, 1, 1]})
-            result = p['first'] / p['second']
-            assert_series_equal(result, p['first'].astype('float64'),
-                                check_names=False)
-            assert result.name is None
-            assert not result.equals(p['second'] / p['first'])
+        assert not (a == c).all()
+        assert not (c == a).all()
+        assert not (a == d).all()
+        assert not (d == a).all()
 
-            # inf signing
-            s = Series([np.nan, 1., -1.])
-            result = s / 0
-            expected = Series([np.nan, np.inf, -np.inf])
-            assert_series_equal(result, expected)
+        # vs a cat-like
+        assert (a == e).all()
+        assert (e == a).all()
+        assert not (a == f).all()
+        assert not (f == a).all()
 
-            # float/integer issue
-            # GH 7785
-            p = DataFrame({'first': (1, 0), 'second': (-0.01, -0.02)})
-            expected = Series([-0.01, -np.inf])
+        assert ((~(a == e) == (a != e)).all())
+        assert ((~(e == a) == (e != a)).all())
+        assert ((~(a == f) == (a != f)).all())
+        assert ((~(f == a) == (f != a)).all())
 
-            result = p['second'].div(p['first'])
-            assert_series_equal(result, expected, check_names=False)
+        # non-equality is not comparable
+        pytest.raises(TypeError, lambda: a < b)
+        pytest.raises(TypeError, lambda: b < a)
+        pytest.raises(TypeError, lambda: a > b)
+        pytest.raises(TypeError, lambda: b > a)
 
-            result = p['second'] / p['first']
-            assert_series_equal(result, expected)
+    def test_comparison_tuples(self):
+        # GH11339
+        # comparisons vs tuple
+        s = Series([(1, 1), (1, 2)])
 
-            # GH 9144
-            s = Series([-1, 0, 1])
+        result = s == (1, 2)
+        expected = Series([False, True])
+        assert_series_equal(result, expected)
 
-            result = 0 / s
-            expected = Series([0.0, nan, 0.0])
-            assert_series_equal(result, expected)
+        result = s != (1, 2)
+        expected = Series([True, False])
+        assert_series_equal(result, expected)
 
-            result = s / 0
-            expected = Series([-inf, nan, inf])
-            assert_series_equal(result, expected)
+        result = s == (0, 0)
+        expected = Series([False, False])
+        assert_series_equal(result, expected)
 
-            result = s // 0
-            expected = Series([-inf, nan, inf])
-            assert_series_equal(result, expected)
+        result = s != (0, 0)
+        expected = Series([True, True])
+        assert_series_equal(result, expected)
 
-            # GH 8674
-            zero_array = np.array([0] * 5)
-            data = np.random.randn(5)
-            expected = pd.Series([0.] * 5)
-            result = zero_array / pd.Series(data)
-            assert_series_equal(result, expected)
+        s = Series([(1, 1), (1, 1)])
 
-            result = pd.Series(zero_array) / data
-            assert_series_equal(result, expected)
+        result = s == (1, 1)
+        expected = Series([True, True])
+        assert_series_equal(result, expected)
 
-            result = pd.Series(zero_array) / pd.Series(data)
-            assert_series_equal(result, expected)
+        result = s != (1, 1)
+        expected = Series([False, False])
+        assert_series_equal(result, expected)
 
-    def test_operators(self):
-        def _check_op(series, other, op, pos_only=False,
-                      check_dtype=True):
-            left = np.abs(series) if pos_only else series
-            right = np.abs(other) if pos_only else other
+        s = Series([frozenset([1]), frozenset([1, 2])])
 
-            cython_or_numpy = op(left, right)
-            python = left.combine(right, op)
-            assert_series_equal(cython_or_numpy, python,
-                                check_dtype=check_dtype)
+        result = s == frozenset([1])
+        expected = Series([True, False])
+        assert_series_equal(result, expected)
 
-        def check(series, other):
-            simple_ops = ['add', 'sub', 'mul', 'truediv', 'floordiv', 'mod']
+    def test_comparison_operators_with_nas(self):
+        s = Series(bdate_range('1/1/2000', periods=10), dtype=object)
+        s[::2] = np.nan
 
-            for opname in simple_ops:
-                _check_op(series, other, getattr(operator, opname))
+        # test that comparisons work
+        ops = ['lt', 'le', 'gt', 'ge', 'eq', 'ne']
+        for op in ops:
+            val = s[5]
 
-            _check_op(series, other, operator.pow, pos_only=True)
+            f = getattr(operator, op)
+            result = f(s, val)
 
-            _check_op(series, other, lambda x, y: operator.add(y, x))
-            _check_op(series, other, lambda x, y: operator.sub(y, x))
-            _check_op(series, other, lambda x, y: operator.truediv(y, x))
-            _check_op(series, other, lambda x, y: operator.floordiv(y, x))
-            _check_op(series, other, lambda x, y: operator.mul(y, x))
-            _check_op(series, other, lambda x, y: operator.pow(y, x),
-                      pos_only=True)
-            _check_op(series, other, lambda x, y: operator.mod(y, x))
+            expected = f(s.dropna(), val).reindex(s.index)
 
-        check(self.ts, self.ts * 2)
-        check(self.ts, self.ts * 0)
-        check(self.ts, self.ts[::2])
-        check(self.ts, 5)
+            if op == 'ne':
+                expected = expected.fillna(True).astype(bool)
+            else:
+                expected = expected.fillna(False).astype(bool)
 
-        def check_comparators(series, other, check_dtype=True):
-            _check_op(series, other, operator.gt, check_dtype=check_dtype)
-            _check_op(series, other, operator.ge, check_dtype=check_dtype)
-            _check_op(series, other, operator.eq, check_dtype=check_dtype)
-            _check_op(series, other, operator.lt, check_dtype=check_dtype)
-            _check_op(series, other, operator.le, check_dtype=check_dtype)
+            assert_series_equal(result, expected)
 
-        check_comparators(self.ts, 5)
-        check_comparators(self.ts, self.ts + 1, check_dtype=False)
+            # fffffffuuuuuuuuuuuu
+            # result = f(val, s)
+            # expected = f(val, s.dropna()).reindex(s.index)
+            # assert_series_equal(result, expected)
 
-    def test_divmod(self):
-        def check(series, other):
-            results = divmod(series, other)
-            if isinstance(other, Iterable) and len(series) != len(other):
-                # if the lengths don't match, this is the test where we use
-                # `self.ts[::2]`. Pad every other value in `other_np` with nan.
-                other_np = []
-                for n in other:
-                    other_np.append(n)
-                    other_np.append(np.nan)
-            else:
-                other_np = other
-            other_np = np.asarray(other_np)
-            with np.errstate(all='ignore'):
-                expecteds = divmod(series.values, np.asarray(other_np))
+            # boolean &, |, ^ should work with object arrays and propagate NAs
 
-            for result, expected in zip(results, expecteds):
-                # check the values, name, and index separatly
-                assert_almost_equal(np.asarray(result), expected)
+        ops = ['and_', 'or_', 'xor']
+        mask = s.isna()
+        for bool_op in ops:
+            f = getattr(operator, bool_op)
 
-                assert result.name == series.name
-                assert_index_equal(result.index, series.index)
+            filled = s.fillna(s[0])
 
-        check(self.ts, self.ts * 2)
-        check(self.ts, self.ts * 0)
-        check(self.ts, self.ts[::2])
-        check(self.ts, 5)
+            result = f(s < s[9], s > s[3])
 
-    def test_operators_empty_int_corner(self):
-        s1 = Series([], [], dtype=np.int32)
-        s2 = Series({'x': 0.})
-        assert_series_equal(s1 * s2, Series([np.nan], index=['x']))
+            expected = f(filled < filled[9], filled > filled[3])
+            expected[mask] = False
+            assert_series_equal(result, expected)
 
-    def test_operators_timedelta64(self):
+    def test_comparison_object_numeric_nas(self):
+        s = Series(np.random.randn(10), dtype=object)
+        shifted = s.shift(2)
 
-        # invalid ops
-        pytest.raises(Exception, self.objSeries.__add__, 1)
-        pytest.raises(Exception, self.objSeries.__add__,
-                      np.array(1, dtype=np.int64))
-        pytest.raises(Exception, self.objSeries.__sub__, 1)
-        pytest.raises(Exception, self.objSeries.__sub__,
-                      np.array(1, dtype=np.int64))
+        ops = ['lt', 'le', 'gt', 'ge', 'eq', 'ne']
+        for op in ops:
+            f = getattr(operator, op)
 
-        # seriese ops
-        v1 = date_range('2012-1-1', periods=3, freq='D')
-        v2 = date_range('2012-1-2', periods=3, freq='D')
-        rs = Series(v2) - Series(v1)
-        xp = Series(1e9 * 3600 * 24,
-                    rs.index).astype('int64').astype('timedelta64[ns]')
-        assert_series_equal(rs, xp)
-        assert rs.dtype == 'timedelta64[ns]'
+            result = f(s, shifted)
+            expected = f(s.astype(float), shifted.astype(float))
+            assert_series_equal(result, expected)
 
-        df = DataFrame(dict(A=v1))
-        td = Series([timedelta(days=i) for i in range(3)])
-        assert td.dtype == 'timedelta64[ns]'
+    def test_comparison_invalid(self):
+        # GH4968
+        # invalid date/int comparisons
+        s = Series(range(5))
+        s2 = Series(date_range('20010101', periods=5))
 
-        # series on the rhs
-        result = df['A'] - df['A'].shift()
-        assert result.dtype == 'timedelta64[ns]'
+        for (x, y) in [(s, s2), (s2, s)]:
+            pytest.raises(TypeError, lambda: x == y)
+            pytest.raises(TypeError, lambda: x != y)
+            pytest.raises(TypeError, lambda: x >= y)
+            pytest.raises(TypeError, lambda: x > y)
+            pytest.raises(TypeError, lambda: x < y)
+            pytest.raises(TypeError, lambda: x <= y)
 
-        result = df['A'] + td
-        assert result.dtype == 'M8[ns]'
+    def test_unequal_categorical_comparison_raises_type_error(self):
+        # unequal comparison should raise for unordered cats
+        cat = Series(Categorical(list("abc")))
 
-        # scalar Timestamp on rhs
-        maxa = df['A'].max()
-        assert isinstance(maxa, Timestamp)
+        def f():
+            cat > "b"
 
-        resultb = df['A'] - df['A'].max()
-        assert resultb.dtype == 'timedelta64[ns]'
+        pytest.raises(TypeError, f)
+        cat = Series(Categorical(list("abc"), ordered=False))
 
-        # timestamp on lhs
-        result = resultb + df['A']
-        values = [Timestamp('20111230'), Timestamp('20120101'),
-                  Timestamp('20120103')]
-        expected = Series(values, name='A')
-        assert_series_equal(result, expected)
+        def f():
+            cat > "b"
 
-        # datetimes on rhs
-        result = df['A'] - datetime(2001, 1, 1)
-        expected = Series(
-            [timedelta(days=4017 + i) for i in range(3)], name='A')
-        assert_series_equal(result, expected)
-        assert result.dtype == 'm8[ns]'
+        pytest.raises(TypeError, f)
 
-        d = datetime(2001, 1, 1, 3, 4)
-        resulta = df['A'] - d
-        assert resulta.dtype == 'm8[ns]'
+        # https://github.com/pandas-dev/pandas/issues/9836#issuecomment-92123057
+        # and following comparisons with scalars not in categories should raise
+        # for unequal comps, but not for equal/not equal
+        cat = Series(Categorical(list("abc"), ordered=True))
 
-        # roundtrip
-        resultb = resulta + d
-        assert_series_equal(df['A'], resultb)
+        pytest.raises(TypeError, lambda: cat < "d")
+        pytest.raises(TypeError, lambda: cat > "d")
+        pytest.raises(TypeError, lambda: "d" < cat)
+        pytest.raises(TypeError, lambda: "d" > cat)
 
-        # timedeltas on rhs
-        td = timedelta(days=1)
-        resulta = df['A'] + td
-        resultb = resulta - td
-        assert_series_equal(resultb, df['A'])
-        assert resultb.dtype == 'M8[ns]'
+        tm.assert_series_equal(cat == "d", Series([False, False, False]))
+        tm.assert_series_equal(cat != "d", Series([True, True, True]))
 
-        # roundtrip
-        td = timedelta(minutes=5, seconds=3)
-        resulta = df['A'] + td
-        resultb = resulta - td
-        assert_series_equal(df['A'], resultb)
-        assert resultb.dtype == 'M8[ns]'
+    def test_more_na_comparisons(self):
+        for dtype in [None, object]:
+            left = Series(['a', np.nan, 'c'], dtype=dtype)
+            right = Series(['a', np.nan, 'd'], dtype=dtype)
 
-        # inplace
-        value = rs[2] + np.timedelta64(timedelta(minutes=5, seconds=1))
-        rs[2] += np.timedelta64(timedelta(minutes=5, seconds=1))
-        assert rs[2] == value
+            result = left == right
+            expected = Series([True, False, False])
+            assert_series_equal(result, expected)
 
-    def test_operator_series_comparison_zerorank(self):
-        # GH 13006
-        result = np.float64(0) > pd.Series([1, 2, 3])
-        expected = 0.0 > pd.Series([1, 2, 3])
-        tm.assert_series_equal(result, expected)
-        result = pd.Series([1, 2, 3]) < np.float64(0)
-        expected = pd.Series([1, 2, 3]) < 0.0
-        tm.assert_series_equal(result, expected)
-        result = np.array([0, 1, 2])[0] > pd.Series([0, 1, 2])
-        expected = 0.0 > pd.Series([1, 2, 3])
-        tm.assert_series_equal(result, expected)
+            result = left != right
+            expected = Series([False, True, True])
+            assert_series_equal(result, expected)
 
-    def test_timedeltas_with_DateOffset(self):
+            result = left == np.nan
+            expected = Series([False, False, False])
+            assert_series_equal(result, expected)
 
-        # GH 4532
-        # operate with pd.offsets
-        s = Series([Timestamp('20130101 9:01'), Timestamp('20130101 9:02')])
+            result = left != np.nan
+            expected = Series([True, True, True])
+            assert_series_equal(result, expected)
 
-        result = s + pd.offsets.Second(5)
-        result2 = pd.offsets.Second(5) + s
-        expected = Series([Timestamp('20130101 9:01:05'), Timestamp(
-            '20130101 9:02:05')])
-        assert_series_equal(result, expected)
-        assert_series_equal(result2, expected)
+    def test_nat_comparisons(self):
+        data = [([pd.Timestamp('2011-01-01'), pd.NaT,
+                  pd.Timestamp('2011-01-03')],
+                 [pd.NaT, pd.NaT, pd.Timestamp('2011-01-03')]),
 
-        result = s - pd.offsets.Second(5)
-        result2 = -pd.offsets.Second(5) + s
-        expected = Series([Timestamp('20130101 9:00:55'), Timestamp(
-            '20130101 9:01:55')])
-        assert_series_equal(result, expected)
-        assert_series_equal(result2, expected)
+                ([pd.Timedelta('1 days'), pd.NaT,
+                  pd.Timedelta('3 days')],
+                 [pd.NaT, pd.NaT, pd.Timedelta('3 days')]),
 
-        result = s + pd.offsets.Milli(5)
-        result2 = pd.offsets.Milli(5) + s
-        expected = Series([Timestamp('20130101 9:01:00.005'), Timestamp(
-            '20130101 9:02:00.005')])
-        assert_series_equal(result, expected)
-        assert_series_equal(result2, expected)
+                ([pd.Period('2011-01', freq='M'), pd.NaT,
+                  pd.Period('2011-03', freq='M')],
+                 [pd.NaT, pd.NaT, pd.Period('2011-03', freq='M')])]
 
-        result = s + pd.offsets.Minute(5) + pd.offsets.Milli(5)
-        expected = Series([Timestamp('20130101 9:06:00.005'), Timestamp(
-            '20130101 9:07:00.005')])
-        assert_series_equal(result, expected)
+        # add lhs / rhs switched data
+        data = data + [(r, l) for l, r in data]
 
-        # operate with np.timedelta64 correctly
-        result = s + np.timedelta64(1, 's')
-        result2 = np.timedelta64(1, 's') + s
-        expected = Series([Timestamp('20130101 9:01:01'), Timestamp(
-            '20130101 9:02:01')])
-        assert_series_equal(result, expected)
-        assert_series_equal(result2, expected)
+        for l, r in data:
+            for dtype in [None, object]:
+                left = Series(l, dtype=dtype)
 
-        result = s + np.timedelta64(5, 'ms')
-        result2 = np.timedelta64(5, 'ms') + s
-        expected = Series([Timestamp('20130101 9:01:00.005'), Timestamp(
-            '20130101 9:02:00.005')])
-        assert_series_equal(result, expected)
-        assert_series_equal(result2, expected)
+                # Series, Index
+                for right in [Series(r, dtype=dtype), Index(r, dtype=dtype)]:
+                    expected = Series([False, False, True])
+                    assert_series_equal(left == right, expected)
 
-        # valid DateOffsets
-        for do in ['Hour', 'Minute', 'Second', 'Day', 'Micro', 'Milli',
-                   'Nano']:
-            op = getattr(pd.offsets, do)
-            s + op(5)
-            op(5) + s
+                    expected = Series([True, True, False])
+                    assert_series_equal(left != right, expected)
 
-    def test_timedelta_series_ops(self):
-        # GH11925
+                    expected = Series([False, False, False])
+                    assert_series_equal(left < right, expected)
 
-        s = Series(timedelta_range('1 day', periods=3))
-        ts = Timestamp('2012-01-01')
-        expected = Series(date_range('2012-01-02', periods=3))
-        assert_series_equal(ts + s, expected)
-        assert_series_equal(s + ts, expected)
+                    expected = Series([False, False, False])
+                    assert_series_equal(left > right, expected)
 
-        expected2 = Series(date_range('2011-12-31', periods=3, freq='-1D'))
-        assert_series_equal(ts - s, expected2)
-        assert_series_equal(ts + (-s), expected2)
+                    expected = Series([False, False, True])
+                    assert_series_equal(left >= right, expected)
 
-    def test_timedelta64_operations_with_DateOffset(self):
-        # GH 10699
-        td = Series([timedelta(minutes=5, seconds=3)] * 3)
-        result = td + pd.offsets.Minute(1)
-        expected = Series([timedelta(minutes=6, seconds=3)] * 3)
-        assert_series_equal(result, expected)
+                    expected = Series([False, False, True])
+                    assert_series_equal(left <= right, expected)
 
-        result = td - pd.offsets.Minute(1)
-        expected = Series([timedelta(minutes=4, seconds=3)] * 3)
-        assert_series_equal(result, expected)
+    def test_nat_comparisons_scalar(self):
+        data = [[pd.Timestamp('2011-01-01'), pd.NaT,
+                 pd.Timestamp('2011-01-03')],
 
-        result = td + Series([pd.offsets.Minute(1), pd.offsets.Second(3),
-                              pd.offsets.Hour(2)])
-        expected = Series([timedelta(minutes=6, seconds=3), timedelta(
-            minutes=5, seconds=6), timedelta(hours=2, minutes=5, seconds=3)])
-        assert_series_equal(result, expected)
+                [pd.Timedelta('1 days'), pd.NaT, pd.Timedelta('3 days')],
 
-        result = td + pd.offsets.Minute(1) + pd.offsets.Second(12)
-        expected = Series([timedelta(minutes=6, seconds=15)] * 3)
-        assert_series_equal(result, expected)
+                [pd.Period('2011-01', freq='M'), pd.NaT,
+                 pd.Period('2011-03', freq='M')]]
 
-        # valid DateOffsets
-        for do in ['Hour', 'Minute', 'Second', 'Day', 'Micro', 'Milli',
-                   'Nano']:
-            op = getattr(pd.offsets, do)
-            td + op(5)
-            op(5) + td
-            td - op(5)
-            op(5) - td
+        for l in data:
+            for dtype in [None, object]:
+                left = Series(l, dtype=dtype)
 
-    def test_timedelta64_operations_with_timedeltas(self):
+                expected = Series([False, False, False])
+                assert_series_equal(left == pd.NaT, expected)
+                assert_series_equal(pd.NaT == left, expected)
 
-        # td operate with td
-        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)
-        td2 = timedelta(minutes=5, seconds=4)
-        result = td1 - td2
-        expected = Series([timedelta(seconds=0)] * 3) - Series([timedelta(
-            seconds=1)] * 3)
-        assert result.dtype == 'm8[ns]'
-        assert_series_equal(result, expected)
+                expected = Series([True, True, True])
+                assert_series_equal(left != pd.NaT, expected)
+                assert_series_equal(pd.NaT != left, expected)
 
-        result2 = td2 - td1
-        expected = (Series([timedelta(seconds=1)] * 3) - Series([timedelta(
-            seconds=0)] * 3))
-        assert_series_equal(result2, expected)
+                expected = Series([False, False, False])
+                assert_series_equal(left < pd.NaT, expected)
+                assert_series_equal(pd.NaT > left, expected)
+                assert_series_equal(left <= pd.NaT, expected)
+                assert_series_equal(pd.NaT >= left, expected)
 
-        # roundtrip
-        assert_series_equal(result + td2, td1)
+                assert_series_equal(left > pd.NaT, expected)
+                assert_series_equal(pd.NaT < left, expected)
+                assert_series_equal(left >= pd.NaT, expected)
+                assert_series_equal(pd.NaT <= left, expected)
 
-        # Now again, using pd.to_timedelta, which should build
-        # a Series or a scalar, depending on input.
-        td1 = Series(pd.to_timedelta(['00:05:03'] * 3))
-        td2 = pd.to_timedelta('00:05:04')
-        result = td1 - td2
-        expected = Series([timedelta(seconds=0)] * 3) - Series([timedelta(
-            seconds=1)] * 3)
-        assert result.dtype == 'm8[ns]'
-        assert_series_equal(result, expected)
+    def test_comparison_different_length(self):
+        a = Series(['a', 'b', 'c'])
+        b = Series(['b', 'a'])
+        pytest.raises(ValueError, a.__lt__, b)
 
-        result2 = td2 - td1
-        expected = (Series([timedelta(seconds=1)] * 3) - Series([timedelta(
-            seconds=0)] * 3))
-        assert_series_equal(result2, expected)
+        a = Series([1, 2])
+        b = Series([2, 3, 4])
+        pytest.raises(ValueError, a.__eq__, b)
 
-        # roundtrip
-        assert_series_equal(result + td2, td1)
+    def test_comparison_label_based(self):
 
-    def test_timedelta64_operations_with_integers(self):
+        # GH 4947
+        # comparisons should be label based
 
-        # GH 4521
-        # divide/multiply by integers
-        startdate = Series(date_range('2013-01-01', '2013-01-03'))
-        enddate = Series(date_range('2013-03-01', '2013-03-03'))
+        a = Series([True, False, True], list('bca'))
+        b = Series([False, True, False], list('abc'))
 
-        s1 = enddate - startdate
-        s1[2] = np.nan
-        s2 = Series([2, 3, 4])
-        expected = Series(s1.values.astype(np.int64) / s2, dtype='m8[ns]')
-        expected[2] = np.nan
-        result = s1 / s2
+        expected = Series([False, True, False], list('abc'))
+        result = a & b
         assert_series_equal(result, expected)
 
-        s2 = Series([20, 30, 40])
-        expected = Series(s1.values.astype(np.int64) / s2, dtype='m8[ns]')
-        expected[2] = np.nan
-        result = s1 / s2
+        expected = Series([True, True, False], list('abc'))
+        result = a | b
         assert_series_equal(result, expected)
 
-        result = s1 / 2
-        expected = Series(s1.values.astype(np.int64) / 2, dtype='m8[ns]')
-        expected[2] = np.nan
+        expected = Series([True, False, False], list('abc'))
+        result = a ^ b
         assert_series_equal(result, expected)
 
-        s2 = Series([20, 30, 40])
-        expected = Series(s1.values.astype(np.int64) * s2, dtype='m8[ns]')
-        expected[2] = np.nan
-        result = s1 * s2
+        # rhs is bigger
+        a = Series([True, False, True], list('bca'))
+        b = Series([False, True, False, True], list('abcd'))
+
+        expected = Series([False, True, False, False], list('abcd'))
+        result = a & b
         assert_series_equal(result, expected)
 
-        for dtype in ['int32', 'int16', 'uint32', 'uint64', 'uint32', 'uint16',
-                      'uint8']:
-            s2 = Series([20, 30, 40], dtype=dtype)
-            expected = Series(
-                s1.values.astype(np.int64) * s2.astype(np.int64),
-                dtype='m8[ns]')
-            expected[2] = np.nan
-            result = s1 * s2
-            assert_series_equal(result, expected)
+        expected = Series([True, True, False, False], list('abcd'))
+        result = a | b
+        assert_series_equal(result, expected)
 
-        result = s1 * 2
-        expected = Series(s1.values.astype(np.int64) * 2, dtype='m8[ns]')
-        expected[2] = np.nan
+        # filling
+
+        # vs empty
+        result = a & Series([])
+        expected = Series([False, False, False], list('bca'))
         assert_series_equal(result, expected)
 
-        result = s1 * -1
-        expected = Series(s1.values.astype(np.int64) * -1, dtype='m8[ns]')
-        expected[2] = np.nan
+        result = a | Series([])
+        expected = Series([True, False, True], list('bca'))
         assert_series_equal(result, expected)
 
-        # invalid ops
-        assert_series_equal(s1 / s2.astype(float),
-                            Series([Timedelta('2 days 22:48:00'), Timedelta(
-                                '1 days 23:12:00'), Timedelta('NaT')]))
-        assert_series_equal(s1 / 2.0,
-                            Series([Timedelta('29 days 12:00:00'), Timedelta(
-                                '29 days 12:00:00'), Timedelta('NaT')]))
+        # vs non-matching
+        result = a & Series([1], ['z'])
+        expected = Series([False, False, False, False], list('abcz'))
+        assert_series_equal(result, expected)
 
-        for op in ['__add__', '__sub__']:
-            sop = getattr(s1, op, None)
-            if sop is not None:
-                pytest.raises(TypeError, sop, 1)
-                pytest.raises(TypeError, sop, s2.values)
+        result = a | Series([1], ['z'])
+        expected = Series([True, True, False, False], list('abcz'))
+        assert_series_equal(result, expected)
 
-    def test_timedelta64_conversions(self):
-        startdate = Series(date_range('2013-01-01', '2013-01-03'))
-        enddate = Series(date_range('2013-03-01', '2013-03-03'))
+        # identity
+        # we would like s[s|e] == s to hold for any e, whether empty or not
+        for e in [Series([]), Series([1], ['z']),
+                  Series(np.nan, b.index), Series(np.nan, a.index)]:
+            result = a[a | e]
+            assert_series_equal(result, a[a])
 
-        s1 = enddate - startdate
-        s1[2] = np.nan
+        for e in [Series(['z'])]:
+            if compat.PY3:
+                with tm.assert_produces_warning(RuntimeWarning):
+                    result = a[a | e]
+            else:
+                result = a[a | e]
+            assert_series_equal(result, a[a])
 
-        for m in [1, 3, 10]:
-            for unit in ['D', 'h', 'm', 's', 'ms', 'us', 'ns']:
+        # vs scalars
+        index = list('bca')
+        t = Series([True, False, True])
 
-                # op
-                expected = s1.apply(lambda x: x / np.timedelta64(m, unit))
-                result = s1 / np.timedelta64(m, unit)
-                assert_series_equal(result, expected)
+        for v in [True, 1, 2]:
+            result = Series([True, False, True], index=index) | v
+            expected = Series([True, True, True], index=index)
+            assert_series_equal(result, expected)
 
-                if m == 1 and unit != 'ns':
+        for v in [np.nan, 'foo']:
+            pytest.raises(TypeError, lambda: t | v)
 
-                    # astype
-                    result = s1.astype("timedelta64[{0}]".format(unit))
-                    assert_series_equal(result, expected)
+        for v in [False, 0]:
+            result = Series([True, False, True], index=index) | v
+            expected = Series([True, False, True], index=index)
+            assert_series_equal(result, expected)
 
-                # reverse op
-                expected = s1.apply(
-                    lambda x: Timedelta(np.timedelta64(m, unit)) / x)
-                result = np.timedelta64(m, unit) / s1
+        for v in [True, 1]:
+            result = Series([True, False, True], index=index) & v
+            expected = Series([True, False, True], index=index)
+            assert_series_equal(result, expected)
 
-        # astype
-        s = Series(date_range('20130101', periods=3))
-        result = s.astype(object)
-        assert isinstance(result.iloc[0], datetime)
-        assert result.dtype == np.object_
+        for v in [False, 0]:
+            result = Series([True, False, True], index=index) & v
+            expected = Series([False, False, False], index=index)
+            assert_series_equal(result, expected)
+        for v in [np.nan]:
+            pytest.raises(TypeError, lambda: t & v)
 
-        result = s1.astype(object)
-        assert isinstance(result.iloc[0], timedelta)
-        assert result.dtype == np.object_
+    def test_comparison_flex_basic(self):
+        left = pd.Series(np.random.randn(10))
+        right = pd.Series(np.random.randn(10))
 
-    def test_timedelta64_equal_timedelta_supported_ops(self):
-        ser = Series([Timestamp('20130301'), Timestamp('20130228 23:00:00'),
-                      Timestamp('20130228 22:00:00'), Timestamp(
-                          '20130228 21:00:00')])
+        assert_series_equal(left.eq(right), left == right)
+        assert_series_equal(left.ne(right), left != right)
+        assert_series_equal(left.le(right), left < right)
+        assert_series_equal(left.lt(right), left <= right)
+        assert_series_equal(left.gt(right), left > right)
+        assert_series_equal(left.ge(right), left >= right)
 
-        intervals = 'D', 'h', 'm', 's', 'us'
+        # axis
+        for axis in [0, None, 'index']:
+            assert_series_equal(left.eq(right, axis=axis), left == right)
+            assert_series_equal(left.ne(right, axis=axis), left != right)
+            assert_series_equal(left.le(right, axis=axis), left < right)
+            assert_series_equal(left.lt(right, axis=axis), left <= right)
+            assert_series_equal(left.gt(right, axis=axis), left > right)
+            assert_series_equal(left.ge(right, axis=axis), left >= right)
 
-        # TODO: unused
-        # npy16_mappings = {'D': 24 * 60 * 60 * 1000000,
-        #                   'h': 60 * 60 * 1000000,
-        #                   'm': 60 * 1000000,
-        #                   's': 1000000,
-        #                   'us': 1}
+        #
+        msg = 'No axis named 1 for object type'
+        for op in ['eq', 'ne', 'le', 'le', 'gt', 'ge']:
+            with tm.assert_raises_regex(ValueError, msg):
+                getattr(left, op)(right, axis=1)
 
-        def timedelta64(*args):
-            return sum(starmap(np.timedelta64, zip(args, intervals)))
+    def test_comparison_flex_alignment(self):
+        left = Series([1, 3, 2], index=list('abc'))
+        right = Series([2, 2, 2], index=list('bcd'))
 
-        for op, d, h, m, s, us in product([operator.add, operator.sub],
-                                          *([range(2)] * 5)):
-            nptd = timedelta64(d, h, m, s, us)
-            pytd = timedelta(days=d, hours=h, minutes=m, seconds=s,
-                             microseconds=us)
-            lhs = op(ser, nptd)
-            rhs = op(ser, pytd)
+        exp = pd.Series([False, False, True, False], index=list('abcd'))
+        assert_series_equal(left.eq(right), exp)
 
-            try:
-                assert_series_equal(lhs, rhs)
-            except:
-                raise AssertionError(
-                    "invalid comparsion [op->{0},d->{1},h->{2},m->{3},"
-                    "s->{4},us->{5}]\n{6}\n{7}\n".format(op, d, h, m, s,
-                                                         us, lhs, rhs))
+        exp = pd.Series([True, True, False, True], index=list('abcd'))
+        assert_series_equal(left.ne(right), exp)
 
-    def test_operators_datetimelike(self):
-        def run_ops(ops, get_ser, test_ser):
+        exp = pd.Series([False, False, True, False], index=list('abcd'))
+        assert_series_equal(left.le(right), exp)
 
-            # check that we are getting a TypeError
-            # with 'operate' (from core/ops.py) for the ops that are not
-            # defined
-            for op_str in ops:
-                op = getattr(get_ser, op_str, None)
-                with tm.assert_raises_regex(TypeError, 'operate'):
-                    op(test_ser)
+        exp = pd.Series([False, False, False, False], index=list('abcd'))
+        assert_series_equal(left.lt(right), exp)
 
-        # ## timedelta64 ###
-        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)
-        td1.iloc[2] = np.nan
-        td2 = timedelta(minutes=5, seconds=4)
-        ops = ['__mul__', '__floordiv__', '__pow__', '__rmul__',
-               '__rfloordiv__', '__rpow__']
-        run_ops(ops, td1, td2)
-        td1 + td2
-        td2 + td1
-        td1 - td2
-        td2 - td1
-        td1 / td2
-        td2 / td1
+        exp = pd.Series([False, True, True, False], index=list('abcd'))
+        assert_series_equal(left.ge(right), exp)
 
-        # ## datetime64 ###
-        dt1 = Series([Timestamp('20111230'), Timestamp('20120101'),
-                      Timestamp('20120103')])
-        dt1.iloc[2] = np.nan
-        dt2 = Series([Timestamp('20111231'), Timestamp('20120102'),
-                      Timestamp('20120104')])
-        ops = ['__add__', '__mul__', '__floordiv__', '__truediv__', '__div__',
-               '__pow__', '__radd__', '__rmul__', '__rfloordiv__',
-               '__rtruediv__', '__rdiv__', '__rpow__']
-        run_ops(ops, dt1, dt2)
-        dt1 - dt2
-        dt2 - dt1
+        exp = pd.Series([False, True, False, False], index=list('abcd'))
+        assert_series_equal(left.gt(right), exp)
 
-        # ## datetime64 with timetimedelta ###
-        ops = ['__mul__', '__floordiv__', '__truediv__', '__div__', '__pow__',
-               '__rmul__', '__rfloordiv__', '__rtruediv__', '__rdiv__',
-               '__rpow__']
-        run_ops(ops, dt1, td1)
-        dt1 + td1
-        td1 + dt1
-        dt1 - td1
-        # TODO: Decide if this ought to work.
-        # td1 - dt1
+    def test_comparison_flex_alignment_fill(self):
+        left = Series([1, 3, 2], index=list('abc'))
+        right = Series([2, 2, 2], index=list('bcd'))
 
-        # ## timetimedelta with datetime64 ###
-        ops = ['__sub__', '__mul__', '__floordiv__', '__truediv__', '__div__',
-               '__pow__', '__rmul__', '__rfloordiv__', '__rtruediv__',
-               '__rdiv__', '__rpow__']
-        run_ops(ops, td1, dt1)
-        td1 + dt1
-        dt1 + td1
+        exp = pd.Series([False, False, True, True], index=list('abcd'))
+        assert_series_equal(left.eq(right, fill_value=2), exp)
 
-        # 8260, 10763
-        # datetime64 with tz
-        ops = ['__mul__', '__floordiv__', '__truediv__', '__div__', '__pow__',
-               '__rmul__', '__rfloordiv__', '__rtruediv__', '__rdiv__',
-               '__rpow__']
+        exp = pd.Series([True, True, False, False], index=list('abcd'))
+        assert_series_equal(left.ne(right, fill_value=2), exp)
 
-        tz = 'US/Eastern'
-        dt1 = Series(date_range('2000-01-01 09:00:00', periods=5,
-                                tz=tz), name='foo')
-        dt2 = dt1.copy()
-        dt2.iloc[2] = np.nan
-        td1 = Series(timedelta_range('1 days 1 min', periods=5, freq='H'))
-        td2 = td1.copy()
-        td2.iloc[1] = np.nan
-        run_ops(ops, dt1, td1)
+        exp = pd.Series([False, False, True, True], index=list('abcd'))
+        assert_series_equal(left.le(right, fill_value=0), exp)
 
-        result = dt1 + td1[0]
-        exp = (dt1.dt.tz_localize(None) + td1[0]).dt.tz_localize(tz)
-        assert_series_equal(result, exp)
+        exp = pd.Series([False, False, False, True], index=list('abcd'))
+        assert_series_equal(left.lt(right, fill_value=0), exp)
 
-        result = dt2 + td2[0]
-        exp = (dt2.dt.tz_localize(None) + td2[0]).dt.tz_localize(tz)
-        assert_series_equal(result, exp)
+        exp = pd.Series([True, True, True, False], index=list('abcd'))
+        assert_series_equal(left.ge(right, fill_value=0), exp)
 
-        # odd numpy behavior with scalar timedeltas
-        result = td1[0] + dt1
-        exp = (dt1.dt.tz_localize(None) + td1[0]).dt.tz_localize(tz)
-        assert_series_equal(result, exp)
+        exp = pd.Series([True, True, False, False], index=list('abcd'))
+        assert_series_equal(left.gt(right, fill_value=0), exp)
 
-        result = td2[0] + dt2
-        exp = (dt2.dt.tz_localize(None) + td2[0]).dt.tz_localize(tz)
-        assert_series_equal(result, exp)
+    def test_ne(self):
+        ts = Series([3, 4, 5, 6, 7], [3, 4, 5, 6, 7], dtype=float)
+        expected = [True, True, False, True, True]
+        assert tm.equalContents(ts.index != 5, expected)
+        assert tm.equalContents(~(ts.index == 5), expected)
 
-        result = dt1 - td1[0]
-        exp = (dt1.dt.tz_localize(None) - td1[0]).dt.tz_localize(tz)
-        assert_series_equal(result, exp)
-        pytest.raises(TypeError, lambda: td1[0] - dt1)
+    def test_comp_ops_df_compat(self):
+        # GH 1134
+        s1 = pd.Series([1, 2, 3], index=list('ABC'), name='x')
+        s2 = pd.Series([2, 2, 2], index=list('ABD'), name='x')
 
-        result = dt2 - td2[0]
-        exp = (dt2.dt.tz_localize(None) - td2[0]).dt.tz_localize(tz)
-        assert_series_equal(result, exp)
-        pytest.raises(TypeError, lambda: td2[0] - dt2)
+        s3 = pd.Series([1, 2, 3], index=list('ABC'), name='x')
+        s4 = pd.Series([2, 2, 2, 2], index=list('ABCD'), name='x')
 
-        result = dt1 + td1
-        exp = (dt1.dt.tz_localize(None) + td1).dt.tz_localize(tz)
-        assert_series_equal(result, exp)
+        for l, r in [(s1, s2), (s2, s1), (s3, s4), (s4, s3)]:
 
-        result = dt2 + td2
-        exp = (dt2.dt.tz_localize(None) + td2).dt.tz_localize(tz)
-        assert_series_equal(result, exp)
+            msg = "Can only compare identically-labeled Series objects"
+            with tm.assert_raises_regex(ValueError, msg):
+                l == r
 
-        result = dt1 - td1
-        exp = (dt1.dt.tz_localize(None) - td1).dt.tz_localize(tz)
-        assert_series_equal(result, exp)
+            with tm.assert_raises_regex(ValueError, msg):
+                l != r
 
-        result = dt2 - td2
-        exp = (dt2.dt.tz_localize(None) - td2).dt.tz_localize(tz)
-        assert_series_equal(result, exp)
+            with tm.assert_raises_regex(ValueError, msg):
+                l < r
 
-        pytest.raises(TypeError, lambda: td1 - dt1)
-        pytest.raises(TypeError, lambda: td2 - dt2)
+            msg = "Can only compare identically-labeled DataFrame objects"
+            with tm.assert_raises_regex(ValueError, msg):
+                l.to_frame() == r.to_frame()
 
-    def test_sub_datetime_compat(self):
-        # see gh-14088
-        s = Series([datetime(2016, 8, 23, 12, tzinfo=pytz.utc), pd.NaT])
-        dt = datetime(2016, 8, 22, 12, tzinfo=pytz.utc)
-        exp = Series([Timedelta('1 days'), pd.NaT])
-        assert_series_equal(s - dt, exp)
-        assert_series_equal(s - Timestamp(dt), exp)
+            with tm.assert_raises_regex(ValueError, msg):
+                l.to_frame() != r.to_frame()
 
-    def test_sub_single_tz(self):
-        # GH12290
-        s1 = Series([pd.Timestamp('2016-02-10', tz='America/Sao_Paulo')])
-        s2 = Series([pd.Timestamp('2016-02-08', tz='America/Sao_Paulo')])
-        result = s1 - s2
-        expected = Series([Timedelta('2days')])
-        assert_series_equal(result, expected)
-        result = s2 - s1
-        expected = Series([Timedelta('-2days')])
-        assert_series_equal(result, expected)
+            with tm.assert_raises_regex(ValueError, msg):
+                l.to_frame() < r.to_frame()
 
-    def test_ops_nat(self):
-        # GH 11349
-        timedelta_series = Series([NaT, Timedelta('1s')])
-        datetime_series = Series([NaT, Timestamp('19900315')])
-        nat_series_dtype_timedelta = Series(
-            [NaT, NaT], dtype='timedelta64[ns]')
-        nat_series_dtype_timestamp = Series([NaT, NaT], dtype='datetime64[ns]')
-        single_nat_dtype_datetime = Series([NaT], dtype='datetime64[ns]')
-        single_nat_dtype_timedelta = Series([NaT], dtype='timedelta64[ns]')
 
-        # subtraction
-        assert_series_equal(timedelta_series - NaT, nat_series_dtype_timedelta)
-        assert_series_equal(-NaT + timedelta_series,
-                            nat_series_dtype_timedelta)
+class TestSeriesArithmetic(object):
+    def test_divide_decimal(self):
+        """ resolves issue #9787 """
+        from decimal import Decimal
 
-        assert_series_equal(timedelta_series - single_nat_dtype_timedelta,
-                            nat_series_dtype_timedelta)
-        assert_series_equal(-single_nat_dtype_timedelta + timedelta_series,
-                            nat_series_dtype_timedelta)
+        expected = Series([Decimal(5)])
 
-        assert_series_equal(datetime_series - NaT, nat_series_dtype_timestamp)
-        assert_series_equal(-NaT + datetime_series, nat_series_dtype_timestamp)
+        s = Series([Decimal(10)])
+        s = s / Decimal(2)
 
-        assert_series_equal(datetime_series - single_nat_dtype_datetime,
-                            nat_series_dtype_timedelta)
-        with pytest.raises(TypeError):
-            -single_nat_dtype_datetime + datetime_series
+        assert_series_equal(expected, s)
 
-        assert_series_equal(datetime_series - single_nat_dtype_timedelta,
-                            nat_series_dtype_timestamp)
-        assert_series_equal(-single_nat_dtype_timedelta + datetime_series,
-                            nat_series_dtype_timestamp)
+        s = Series([Decimal(10)])
+        s = s // Decimal(2)
 
-        # without a Series wrapping the NaT, it is ambiguous
-        # whether it is a datetime64 or timedelta64
-        # defaults to interpreting it as timedelta64
-        assert_series_equal(nat_series_dtype_timestamp - NaT,
-                            nat_series_dtype_timestamp)
-        assert_series_equal(-NaT + nat_series_dtype_timestamp,
-                            nat_series_dtype_timestamp)
+        assert_series_equal(expected, s)
 
-        assert_series_equal(nat_series_dtype_timestamp -
-                            single_nat_dtype_datetime,
-                            nat_series_dtype_timedelta)
-        with pytest.raises(TypeError):
-            -single_nat_dtype_datetime + nat_series_dtype_timestamp
+    def test_div(self):
+        with np.errstate(all='ignore'):
+            # no longer do integer div for any ops, but deal with the 0's
+            p = DataFrame({'first': [3, 4, 5, 8], 'second': [0, 0, 0, 3]})
+            result = p['first'] / p['second']
+            expected = Series(
+                p['first'].values.astype(float) / p['second'].values,
+                dtype='float64')
+            expected.iloc[0:3] = np.inf
+            assert_series_equal(result, expected)
 
-        assert_series_equal(nat_series_dtype_timestamp -
-                            single_nat_dtype_timedelta,
-                            nat_series_dtype_timestamp)
-        assert_series_equal(-single_nat_dtype_timedelta +
-                            nat_series_dtype_timestamp,
-                            nat_series_dtype_timestamp)
+            result = p['first'] / 0
+            expected = Series(np.inf, index=p.index, name='first')
+            assert_series_equal(result, expected)
 
-        with pytest.raises(TypeError):
-            timedelta_series - single_nat_dtype_datetime
+            p = p.astype('float64')
+            result = p['first'] / p['second']
+            expected = Series(p['first'].values / p['second'].values)
+            assert_series_equal(result, expected)
 
-        # addition
-        assert_series_equal(nat_series_dtype_timestamp + NaT,
-                            nat_series_dtype_timestamp)
-        assert_series_equal(NaT + nat_series_dtype_timestamp,
-                            nat_series_dtype_timestamp)
+            p = DataFrame({'first': [3, 4, 5, 8], 'second': [1, 1, 1, 1]})
+            result = p['first'] / p['second']
+            assert_series_equal(result, p['first'].astype('float64'),
+                                check_names=False)
+            assert result.name is None
+            assert not result.equals(p['second'] / p['first'])
 
-        assert_series_equal(nat_series_dtype_timestamp +
-                            single_nat_dtype_timedelta,
-                            nat_series_dtype_timestamp)
-        assert_series_equal(single_nat_dtype_timedelta +
-                            nat_series_dtype_timestamp,
-                            nat_series_dtype_timestamp)
+            # inf signing
+            s = Series([np.nan, 1., -1.])
+            result = s / 0
+            expected = Series([np.nan, np.inf, -np.inf])
+            assert_series_equal(result, expected)
 
-        assert_series_equal(nat_series_dtype_timedelta + NaT,
-                            nat_series_dtype_timedelta)
-        assert_series_equal(NaT + nat_series_dtype_timedelta,
-                            nat_series_dtype_timedelta)
+            # float/integer issue
+            # GH 7785
+            p = DataFrame({'first': (1, 0), 'second': (-0.01, -0.02)})
+            expected = Series([-0.01, -np.inf])
 
-        assert_series_equal(nat_series_dtype_timedelta +
-                            single_nat_dtype_timedelta,
-                            nat_series_dtype_timedelta)
-        assert_series_equal(single_nat_dtype_timedelta +
-                            nat_series_dtype_timedelta,
-                            nat_series_dtype_timedelta)
+            result = p['second'].div(p['first'])
+            assert_series_equal(result, expected, check_names=False)
 
-        assert_series_equal(timedelta_series + NaT, nat_series_dtype_timedelta)
-        assert_series_equal(NaT + timedelta_series, nat_series_dtype_timedelta)
+            result = p['second'] / p['first']
+            assert_series_equal(result, expected)
 
-        assert_series_equal(timedelta_series + single_nat_dtype_timedelta,
-                            nat_series_dtype_timedelta)
-        assert_series_equal(single_nat_dtype_timedelta + timedelta_series,
-                            nat_series_dtype_timedelta)
+            # GH 9144
+            s = Series([-1, 0, 1])
 
-        assert_series_equal(nat_series_dtype_timestamp + NaT,
-                            nat_series_dtype_timestamp)
-        assert_series_equal(NaT + nat_series_dtype_timestamp,
-                            nat_series_dtype_timestamp)
+            result = 0 / s
+            expected = Series([0.0, nan, 0.0])
+            assert_series_equal(result, expected)
 
-        assert_series_equal(nat_series_dtype_timestamp +
-                            single_nat_dtype_timedelta,
-                            nat_series_dtype_timestamp)
-        assert_series_equal(single_nat_dtype_timedelta +
-                            nat_series_dtype_timestamp,
-                            nat_series_dtype_timestamp)
+            result = s / 0
+            expected = Series([-inf, nan, inf])
+            assert_series_equal(result, expected)
 
-        assert_series_equal(nat_series_dtype_timedelta + NaT,
-                            nat_series_dtype_timedelta)
-        assert_series_equal(NaT + nat_series_dtype_timedelta,
-                            nat_series_dtype_timedelta)
+            result = s // 0
+            expected = Series([-inf, nan, inf])
+            assert_series_equal(result, expected)
 
-        assert_series_equal(nat_series_dtype_timedelta +
-                            single_nat_dtype_timedelta,
-                            nat_series_dtype_timedelta)
-        assert_series_equal(single_nat_dtype_timedelta +
-                            nat_series_dtype_timedelta,
-                            nat_series_dtype_timedelta)
+            # GH 8674
+            zero_array = np.array([0] * 5)
+            data = np.random.randn(5)
+            expected = pd.Series([0.] * 5)
+            result = zero_array / pd.Series(data)
+            assert_series_equal(result, expected)
 
-        assert_series_equal(nat_series_dtype_timedelta +
-                            single_nat_dtype_datetime,
-                            nat_series_dtype_timestamp)
-        assert_series_equal(single_nat_dtype_datetime +
-                            nat_series_dtype_timedelta,
-                            nat_series_dtype_timestamp)
+            result = pd.Series(zero_array) / data
+            assert_series_equal(result, expected)
 
-        # multiplication
-        assert_series_equal(nat_series_dtype_timedelta * 1.0,
-                            nat_series_dtype_timedelta)
-        assert_series_equal(1.0 * nat_series_dtype_timedelta,
-                            nat_series_dtype_timedelta)
+            result = pd.Series(zero_array) / pd.Series(data)
+            assert_series_equal(result, expected)
 
-        assert_series_equal(timedelta_series * 1, timedelta_series)
-        assert_series_equal(1 * timedelta_series, timedelta_series)
 
-        assert_series_equal(timedelta_series * 1.5,
-                            Series([NaT, Timedelta('1.5s')]))
-        assert_series_equal(1.5 * timedelta_series,
-                            Series([NaT, Timedelta('1.5s')]))
+class TestTimedeltaSeriesArithmetic(object):
+    def test_timedelta_series_ops(self):
+        # GH11925
+        s = Series(timedelta_range('1 day', periods=3))
+        ts = Timestamp('2012-01-01')
+        expected = Series(date_range('2012-01-02', periods=3))
+        assert_series_equal(ts + s, expected)
+        assert_series_equal(s + ts, expected)
 
-        assert_series_equal(timedelta_series * nan, nat_series_dtype_timedelta)
-        assert_series_equal(nan * timedelta_series, nat_series_dtype_timedelta)
+        expected2 = Series(date_range('2011-12-31', periods=3, freq='-1D'))
+        assert_series_equal(ts - s, expected2)
+        assert_series_equal(ts + (-s), expected2)
 
-        with pytest.raises(TypeError):
-            datetime_series * 1
-        with pytest.raises(TypeError):
-            nat_series_dtype_timestamp * 1
-        with pytest.raises(TypeError):
-            datetime_series * 1.0
-        with pytest.raises(TypeError):
-            nat_series_dtype_timestamp * 1.0
+    def test_timedelta64_operations_with_integers(self):
+        # GH 4521
+        # divide/multiply by integers
+        startdate = Series(date_range('2013-01-01', '2013-01-03'))
+        enddate = Series(date_range('2013-03-01', '2013-03-03'))
 
-        # division
-        assert_series_equal(timedelta_series / 2,
-                            Series([NaT, Timedelta('0.5s')]))
-        assert_series_equal(timedelta_series / 2.0,
-                            Series([NaT, Timedelta('0.5s')]))
-        assert_series_equal(timedelta_series / nan, nat_series_dtype_timedelta)
-        with pytest.raises(TypeError):
-            nat_series_dtype_timestamp / 1.0
-        with pytest.raises(TypeError):
-            nat_series_dtype_timestamp / 1
+        s1 = enddate - startdate
+        s1[2] = np.nan
+        s2 = Series([2, 3, 4])
+        expected = Series(s1.values.astype(np.int64) / s2, dtype='m8[ns]')
+        expected[2] = np.nan
+        result = s1 / s2
+        assert_series_equal(result, expected)
 
-    def test_ops_datetimelike_align(self):
-        # GH 7500
-        # datetimelike ops need to align
-        dt = Series(date_range('2012-1-1', periods=3, freq='D'))
-        dt.iloc[2] = np.nan
-        dt2 = dt[::-1]
+        s2 = Series([20, 30, 40])
+        expected = Series(s1.values.astype(np.int64) / s2, dtype='m8[ns]')
+        expected[2] = np.nan
+        result = s1 / s2
+        assert_series_equal(result, expected)
 
-        expected = Series([timedelta(0), timedelta(0), pd.NaT])
-        # name is reset
-        result = dt2 - dt
+        result = s1 / 2
+        expected = Series(s1.values.astype(np.int64) / 2, dtype='m8[ns]')
+        expected[2] = np.nan
         assert_series_equal(result, expected)
 
-        expected = Series(expected, name=0)
-        result = (dt2.to_frame() - dt.to_frame())[0]
+        s2 = Series([20, 30, 40])
+        expected = Series(s1.values.astype(np.int64) * s2, dtype='m8[ns]')
+        expected[2] = np.nan
+        result = s1 * s2
         assert_series_equal(result, expected)
 
-    def test_object_comparisons(self):
-        s = Series(['a', 'b', np.nan, 'c', 'a'])
+        for dtype in ['int32', 'int16', 'uint32', 'uint64', 'uint32', 'uint16',
+                      'uint8']:
+            s2 = Series([20, 30, 40], dtype=dtype)
+            expected = Series(
+                s1.values.astype(np.int64) * s2.astype(np.int64),
+                dtype='m8[ns]')
+            expected[2] = np.nan
+            result = s1 * s2
+            assert_series_equal(result, expected)
 
-        result = s == 'a'
-        expected = Series([True, False, False, False, True])
+        result = s1 * 2
+        expected = Series(s1.values.astype(np.int64) * 2, dtype='m8[ns]')
+        expected[2] = np.nan
         assert_series_equal(result, expected)
 
-        result = s < 'a'
-        expected = Series([False, False, False, False, False])
+        result = s1 * -1
+        expected = Series(s1.values.astype(np.int64) * -1, dtype='m8[ns]')
+        expected[2] = np.nan
         assert_series_equal(result, expected)
 
-        result = s != 'a'
-        expected = -(s == 'a')
+        # invalid ops
+        assert_series_equal(s1 / s2.astype(float),
+                            Series([Timedelta('2 days 22:48:00'), Timedelta(
+                                '1 days 23:12:00'), Timedelta('NaT')]))
+        assert_series_equal(s1 / 2.0,
+                            Series([Timedelta('29 days 12:00:00'), Timedelta(
+                                '29 days 12:00:00'), Timedelta('NaT')]))
+
+        for op in ['__add__', '__sub__']:
+            sop = getattr(s1, op, None)
+            if sop is not None:
+                pytest.raises(TypeError, sop, 1)
+                pytest.raises(TypeError, sop, s2.values)
+
+    def test_timedelta64_operations_with_DateOffset(self):
+        # GH 10699
+        td = Series([timedelta(minutes=5, seconds=3)] * 3)
+        result = td + pd.offsets.Minute(1)
+        expected = Series([timedelta(minutes=6, seconds=3)] * 3)
         assert_series_equal(result, expected)
 
-    def test_categorical_comparisons(self):
+        result = td - pd.offsets.Minute(1)
+        expected = Series([timedelta(minutes=4, seconds=3)] * 3)
+        assert_series_equal(result, expected)
 
-        # GH 8938
-        # allow equality comparisons
-        a = Series(list('abc'), dtype="category")
-        b = Series(list('abc'), dtype="object")
-        c = Series(['a', 'b', 'cc'], dtype="object")
-        d = Series(list('acb'), dtype="object")
-        e = Categorical(list('abc'))
-        f = Categorical(list('acb'))
+        result = td + Series([pd.offsets.Minute(1), pd.offsets.Second(3),
+                              pd.offsets.Hour(2)])
+        expected = Series([timedelta(minutes=6, seconds=3), timedelta(
+            minutes=5, seconds=6), timedelta(hours=2, minutes=5, seconds=3)])
+        assert_series_equal(result, expected)
 
-        # vs scalar
-        assert not (a == 'a').all()
-        assert ((a != 'a') == ~(a == 'a')).all()
+        result = td + pd.offsets.Minute(1) + pd.offsets.Second(12)
+        expected = Series([timedelta(minutes=6, seconds=15)] * 3)
+        assert_series_equal(result, expected)
 
-        assert not ('a' == a).all()
-        assert (a == 'a')[0]
-        assert ('a' == a)[0]
-        assert not ('a' != a)[0]
+        # valid DateOffsets
+        for do in ['Hour', 'Minute', 'Second', 'Day', 'Micro', 'Milli',
+                   'Nano']:
+            op = getattr(pd.offsets, do)
+            td + op(5)
+            op(5) + td
+            td - op(5)
+            op(5) - td
 
-        # vs list-like
-        assert (a == a).all()
-        assert not (a != a).all()
+    def test_timedelta64_operations_with_timedeltas(self):
+        # td operate with td
+        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)
+        td2 = timedelta(minutes=5, seconds=4)
+        result = td1 - td2
+        expected = (Series([timedelta(seconds=0)] * 3) -
+                    Series([timedelta(seconds=1)] * 3))
+        assert result.dtype == 'm8[ns]'
+        assert_series_equal(result, expected)
 
-        assert (a == list(a)).all()
-        assert (a == b).all()
-        assert (b == a).all()
-        assert ((~(a == b)) == (a != b)).all()
-        assert ((~(b == a)) == (b != a)).all()
+        result2 = td2 - td1
+        expected = (Series([timedelta(seconds=1)] * 3) -
+                    Series([timedelta(seconds=0)] * 3))
+        assert_series_equal(result2, expected)
 
-        assert not (a == c).all()
-        assert not (c == a).all()
-        assert not (a == d).all()
-        assert not (d == a).all()
+        # roundtrip
+        assert_series_equal(result + td2, td1)
 
-        # vs a cat-like
-        assert (a == e).all()
-        assert (e == a).all()
-        assert not (a == f).all()
-        assert not (f == a).all()
+        # Now again, using pd.to_timedelta, which should build
+        # a Series or a scalar, depending on input.
+        td1 = Series(pd.to_timedelta(['00:05:03'] * 3))
+        td2 = pd.to_timedelta('00:05:04')
+        result = td1 - td2
+        expected = (Series([timedelta(seconds=0)] * 3) -
+                    Series([timedelta(seconds=1)] * 3))
+        assert result.dtype == 'm8[ns]'
+        assert_series_equal(result, expected)
 
-        assert ((~(a == e) == (a != e)).all())
-        assert ((~(e == a) == (e != a)).all())
-        assert ((~(a == f) == (a != f)).all())
-        assert ((~(f == a) == (f != a)).all())
+        result2 = td2 - td1
+        expected = (Series([timedelta(seconds=1)] * 3) -
+                    Series([timedelta(seconds=0)] * 3))
+        assert_series_equal(result2, expected)
 
-        # non-equality is not comparable
-        pytest.raises(TypeError, lambda: a < b)
-        pytest.raises(TypeError, lambda: b < a)
-        pytest.raises(TypeError, lambda: a > b)
-        pytest.raises(TypeError, lambda: b > a)
+        # roundtrip
+        assert_series_equal(result + td2, td1)
 
-    def test_comparison_tuples(self):
-        # GH11339
-        # comparisons vs tuple
-        s = Series([(1, 1), (1, 2)])
+    def test_operators_timedelta64(self):
+        # series ops
+        v1 = date_range('2012-1-1', periods=3, freq='D')
+        v2 = date_range('2012-1-2', periods=3, freq='D')
+        rs = Series(v2) - Series(v1)
+        xp = Series(1e9 * 3600 * 24,
+                    rs.index).astype('int64').astype('timedelta64[ns]')
+        assert_series_equal(rs, xp)
+        assert rs.dtype == 'timedelta64[ns]'
 
-        result = s == (1, 2)
-        expected = Series([False, True])
-        assert_series_equal(result, expected)
+        df = DataFrame(dict(A=v1))
+        td = Series([timedelta(days=i) for i in range(3)])
+        assert td.dtype == 'timedelta64[ns]'
 
-        result = s != (1, 2)
-        expected = Series([True, False])
-        assert_series_equal(result, expected)
+        # series on the rhs
+        result = df['A'] - df['A'].shift()
+        assert result.dtype == 'timedelta64[ns]'
 
-        result = s == (0, 0)
-        expected = Series([False, False])
+        result = df['A'] + td
+        assert result.dtype == 'M8[ns]'
+
+        # scalar Timestamp on rhs
+        maxa = df['A'].max()
+        assert isinstance(maxa, Timestamp)
+
+        resultb = df['A'] - df['A'].max()
+        assert resultb.dtype == 'timedelta64[ns]'
+
+        # timestamp on lhs
+        result = resultb + df['A']
+        values = [Timestamp('20111230'), Timestamp('20120101'),
+                  Timestamp('20120103')]
+        expected = Series(values, name='A')
         assert_series_equal(result, expected)
 
-        result = s != (0, 0)
-        expected = Series([True, True])
+        # datetimes on rhs
+        result = df['A'] - datetime(2001, 1, 1)
+        expected = Series(
+            [timedelta(days=4017 + i) for i in range(3)], name='A')
         assert_series_equal(result, expected)
+        assert result.dtype == 'm8[ns]'
+
+        d = datetime(2001, 1, 1, 3, 4)
+        resulta = df['A'] - d
+        assert resulta.dtype == 'm8[ns]'
+
+        # roundtrip
+        resultb = resulta + d
+        assert_series_equal(df['A'], resultb)
+
+        # timedeltas on rhs
+        td = timedelta(days=1)
+        resulta = df['A'] + td
+        resultb = resulta - td
+        assert_series_equal(resultb, df['A'])
+        assert resultb.dtype == 'M8[ns]'
+
+        # roundtrip
+        td = timedelta(minutes=5, seconds=3)
+        resulta = df['A'] + td
+        resultb = resulta - td
+        assert_series_equal(df['A'], resultb)
+        assert resultb.dtype == 'M8[ns]'
+
+        # inplace
+        value = rs[2] + np.timedelta64(timedelta(minutes=5, seconds=1))
+        rs[2] += np.timedelta64(timedelta(minutes=5, seconds=1))
+        assert rs[2] == value
+
+    def test_timedelta64_ops_nat(self):
+        # GH 11349
+        timedelta_series = Series([NaT, Timedelta('1s')])
+        nat_series_dtype_timedelta = Series([NaT, NaT],
+                                            dtype='timedelta64[ns]')
+        single_nat_dtype_timedelta = Series([NaT], dtype='timedelta64[ns]')
+
+        # subtraction
+        assert_series_equal(timedelta_series - NaT,
+                            nat_series_dtype_timedelta)
+        assert_series_equal(-NaT + timedelta_series,
+                            nat_series_dtype_timedelta)
+
+        assert_series_equal(timedelta_series - single_nat_dtype_timedelta,
+                            nat_series_dtype_timedelta)
+        assert_series_equal(-single_nat_dtype_timedelta + timedelta_series,
+                            nat_series_dtype_timedelta)
+
+        # addition
+        assert_series_equal(nat_series_dtype_timedelta + NaT,
+                            nat_series_dtype_timedelta)
+        assert_series_equal(NaT + nat_series_dtype_timedelta,
+                            nat_series_dtype_timedelta)
+
+        assert_series_equal(nat_series_dtype_timedelta +
+                            single_nat_dtype_timedelta,
+                            nat_series_dtype_timedelta)
+        assert_series_equal(single_nat_dtype_timedelta +
+                            nat_series_dtype_timedelta,
+                            nat_series_dtype_timedelta)
 
-        s = Series([(1, 1), (1, 1)])
+        assert_series_equal(timedelta_series + NaT,
+                            nat_series_dtype_timedelta)
+        assert_series_equal(NaT + timedelta_series,
+                            nat_series_dtype_timedelta)
 
-        result = s == (1, 1)
-        expected = Series([True, True])
-        assert_series_equal(result, expected)
+        assert_series_equal(timedelta_series + single_nat_dtype_timedelta,
+                            nat_series_dtype_timedelta)
+        assert_series_equal(single_nat_dtype_timedelta + timedelta_series,
+                            nat_series_dtype_timedelta)
 
-        result = s != (1, 1)
-        expected = Series([False, False])
-        assert_series_equal(result, expected)
+        assert_series_equal(nat_series_dtype_timedelta + NaT,
+                            nat_series_dtype_timedelta)
+        assert_series_equal(NaT + nat_series_dtype_timedelta,
+                            nat_series_dtype_timedelta)
 
-        s = Series([frozenset([1]), frozenset([1, 2])])
+        assert_series_equal(nat_series_dtype_timedelta +
+                            single_nat_dtype_timedelta,
+                            nat_series_dtype_timedelta)
+        assert_series_equal(single_nat_dtype_timedelta +
+                            nat_series_dtype_timedelta,
+                            nat_series_dtype_timedelta)
 
-        result = s == frozenset([1])
-        expected = Series([True, False])
-        assert_series_equal(result, expected)
+        # multiplication
+        assert_series_equal(nat_series_dtype_timedelta * 1.0,
+                            nat_series_dtype_timedelta)
+        assert_series_equal(1.0 * nat_series_dtype_timedelta,
+                            nat_series_dtype_timedelta)
 
-    def test_comparison_operators_with_nas(self):
-        s = Series(bdate_range('1/1/2000', periods=10), dtype=object)
-        s[::2] = np.nan
+        assert_series_equal(timedelta_series * 1, timedelta_series)
+        assert_series_equal(1 * timedelta_series, timedelta_series)
 
-        # test that comparisons work
-        ops = ['lt', 'le', 'gt', 'ge', 'eq', 'ne']
-        for op in ops:
-            val = s[5]
+        assert_series_equal(timedelta_series * 1.5,
+                            Series([NaT, Timedelta('1.5s')]))
+        assert_series_equal(1.5 * timedelta_series,
+                            Series([NaT, Timedelta('1.5s')]))
 
-            f = getattr(operator, op)
-            result = f(s, val)
+        assert_series_equal(timedelta_series * nan,
+                            nat_series_dtype_timedelta)
+        assert_series_equal(nan * timedelta_series,
+                            nat_series_dtype_timedelta)
 
-            expected = f(s.dropna(), val).reindex(s.index)
+        # division
+        assert_series_equal(timedelta_series / 2,
+                            Series([NaT, Timedelta('0.5s')]))
+        assert_series_equal(timedelta_series / 2.0,
+                            Series([NaT, Timedelta('0.5s')]))
+        assert_series_equal(timedelta_series / nan,
+                            nat_series_dtype_timedelta)
 
-            if op == 'ne':
-                expected = expected.fillna(True).astype(bool)
-            else:
-                expected = expected.fillna(False).astype(bool)
 
-            assert_series_equal(result, expected)
+class TestDatetimeSeriesArithmetic(object):
+    def test_operators_datetimelike(self):
+        def run_ops(ops, get_ser, test_ser):
 
-            # fffffffuuuuuuuuuuuu
-            # result = f(val, s)
-            # expected = f(val, s.dropna()).reindex(s.index)
-            # assert_series_equal(result, expected)
+            # check that we are getting a TypeError
+            # with 'operate' (from core/ops.py) for the ops that are not
+            # defined
+            for op_str in ops:
+                op = getattr(get_ser, op_str, None)
+                with tm.assert_raises_regex(TypeError, 'operate'):
+                    op(test_ser)
 
-            # boolean &, |, ^ should work with object arrays and propagate NAs
+        # ## timedelta64 ###
+        td1 = Series([timedelta(minutes=5, seconds=3)] * 3)
+        td1.iloc[2] = np.nan
+        td2 = timedelta(minutes=5, seconds=4)
+        ops = ['__mul__', '__floordiv__', '__pow__', '__rmul__',
+               '__rfloordiv__', '__rpow__']
+        run_ops(ops, td1, td2)
+        td1 + td2
+        td2 + td1
+        td1 - td2
+        td2 - td1
+        td1 / td2
+        td2 / td1
 
-        ops = ['and_', 'or_', 'xor']
-        mask = s.isna()
-        for bool_op in ops:
-            f = getattr(operator, bool_op)
+        # ## datetime64 ###
+        dt1 = Series([Timestamp('20111230'), Timestamp('20120101'),
+                      Timestamp('20120103')])
+        dt1.iloc[2] = np.nan
+        dt2 = Series([Timestamp('20111231'), Timestamp('20120102'),
+                      Timestamp('20120104')])
+        ops = ['__add__', '__mul__', '__floordiv__', '__truediv__', '__div__',
+               '__pow__', '__radd__', '__rmul__', '__rfloordiv__',
+               '__rtruediv__', '__rdiv__', '__rpow__']
+        run_ops(ops, dt1, dt2)
+        dt1 - dt2
+        dt2 - dt1
 
-            filled = s.fillna(s[0])
+        # ## datetime64 with timetimedelta ###
+        ops = ['__mul__', '__floordiv__', '__truediv__', '__div__', '__pow__',
+               '__rmul__', '__rfloordiv__', '__rtruediv__', '__rdiv__',
+               '__rpow__']
+        run_ops(ops, dt1, td1)
+        dt1 + td1
+        td1 + dt1
+        dt1 - td1
+        # TODO: Decide if this ought to work.
+        # td1 - dt1
 
-            result = f(s < s[9], s > s[3])
+        # ## timetimedelta with datetime64 ###
+        ops = ['__sub__', '__mul__', '__floordiv__', '__truediv__', '__div__',
+               '__pow__', '__rmul__', '__rfloordiv__', '__rtruediv__',
+               '__rdiv__', '__rpow__']
+        run_ops(ops, td1, dt1)
+        td1 + dt1
+        dt1 + td1
 
-            expected = f(filled < filled[9], filled > filled[3])
-            expected[mask] = False
-            assert_series_equal(result, expected)
+        # 8260, 10763
+        # datetime64 with tz
+        ops = ['__mul__', '__floordiv__', '__truediv__', '__div__', '__pow__',
+               '__rmul__', '__rfloordiv__', '__rtruediv__', '__rdiv__',
+               '__rpow__']
 
-    def test_comparison_object_numeric_nas(self):
-        s = Series(np.random.randn(10), dtype=object)
-        shifted = s.shift(2)
+        tz = 'US/Eastern'
+        dt1 = Series(date_range('2000-01-01 09:00:00', periods=5,
+                                tz=tz), name='foo')
+        dt2 = dt1.copy()
+        dt2.iloc[2] = np.nan
+        td1 = Series(timedelta_range('1 days 1 min', periods=5, freq='H'))
+        td2 = td1.copy()
+        td2.iloc[1] = np.nan
+        run_ops(ops, dt1, td1)
 
-        ops = ['lt', 'le', 'gt', 'ge', 'eq', 'ne']
-        for op in ops:
-            f = getattr(operator, op)
+        result = dt1 + td1[0]
+        exp = (dt1.dt.tz_localize(None) + td1[0]).dt.tz_localize(tz)
+        assert_series_equal(result, exp)
 
-            result = f(s, shifted)
-            expected = f(s.astype(float), shifted.astype(float))
-            assert_series_equal(result, expected)
+        result = dt2 + td2[0]
+        exp = (dt2.dt.tz_localize(None) + td2[0]).dt.tz_localize(tz)
+        assert_series_equal(result, exp)
 
-    def test_comparison_invalid(self):
+        # odd numpy behavior with scalar timedeltas
+        result = td1[0] + dt1
+        exp = (dt1.dt.tz_localize(None) + td1[0]).dt.tz_localize(tz)
+        assert_series_equal(result, exp)
 
-        # GH4968
-        # invalid date/int comparisons
-        s = Series(range(5))
-        s2 = Series(date_range('20010101', periods=5))
+        result = td2[0] + dt2
+        exp = (dt2.dt.tz_localize(None) + td2[0]).dt.tz_localize(tz)
+        assert_series_equal(result, exp)
 
-        for (x, y) in [(s, s2), (s2, s)]:
-            pytest.raises(TypeError, lambda: x == y)
-            pytest.raises(TypeError, lambda: x != y)
-            pytest.raises(TypeError, lambda: x >= y)
-            pytest.raises(TypeError, lambda: x > y)
-            pytest.raises(TypeError, lambda: x < y)
-            pytest.raises(TypeError, lambda: x <= y)
+        result = dt1 - td1[0]
+        exp = (dt1.dt.tz_localize(None) - td1[0]).dt.tz_localize(tz)
+        assert_series_equal(result, exp)
+        pytest.raises(TypeError, lambda: td1[0] - dt1)
 
-    def test_unequal_categorical_comparison_raises_type_error(self):
-        # unequal comparison should raise for unordered cats
-        cat = Series(Categorical(list("abc")))
+        result = dt2 - td2[0]
+        exp = (dt2.dt.tz_localize(None) - td2[0]).dt.tz_localize(tz)
+        assert_series_equal(result, exp)
+        pytest.raises(TypeError, lambda: td2[0] - dt2)
 
-        def f():
-            cat > "b"
+        result = dt1 + td1
+        exp = (dt1.dt.tz_localize(None) + td1).dt.tz_localize(tz)
+        assert_series_equal(result, exp)
 
-        pytest.raises(TypeError, f)
-        cat = Series(Categorical(list("abc"), ordered=False))
+        result = dt2 + td2
+        exp = (dt2.dt.tz_localize(None) + td2).dt.tz_localize(tz)
+        assert_series_equal(result, exp)
 
-        def f():
-            cat > "b"
+        result = dt1 - td1
+        exp = (dt1.dt.tz_localize(None) - td1).dt.tz_localize(tz)
+        assert_series_equal(result, exp)
 
-        pytest.raises(TypeError, f)
+        result = dt2 - td2
+        exp = (dt2.dt.tz_localize(None) - td2).dt.tz_localize(tz)
+        assert_series_equal(result, exp)
 
-        # https://github.com/pandas-dev/pandas/issues/9836#issuecomment-92123057
-        # and following comparisons with scalars not in categories should raise
-        # for unequal comps, but not for equal/not equal
-        cat = Series(Categorical(list("abc"), ordered=True))
+        pytest.raises(TypeError, lambda: td1 - dt1)
+        pytest.raises(TypeError, lambda: td2 - dt2)
 
-        pytest.raises(TypeError, lambda: cat < "d")
-        pytest.raises(TypeError, lambda: cat > "d")
-        pytest.raises(TypeError, lambda: "d" < cat)
-        pytest.raises(TypeError, lambda: "d" > cat)
+    def test_sub_single_tz(self):
+        # GH12290
+        s1 = Series([pd.Timestamp('2016-02-10', tz='America/Sao_Paulo')])
+        s2 = Series([pd.Timestamp('2016-02-08', tz='America/Sao_Paulo')])
+        result = s1 - s2
+        expected = Series([Timedelta('2days')])
+        assert_series_equal(result, expected)
+        result = s2 - s1
+        expected = Series([Timedelta('-2days')])
+        assert_series_equal(result, expected)
 
-        tm.assert_series_equal(cat == "d", Series([False, False, False]))
-        tm.assert_series_equal(cat != "d", Series([True, True, True]))
+    def test_sub_datetime_compat(self):
+        # see gh-14088
+        s = Series([datetime(2016, 8, 23, 12, tzinfo=pytz.utc), pd.NaT])
+        dt = datetime(2016, 8, 22, 12, tzinfo=pytz.utc)
+        exp = Series([Timedelta('1 days'), pd.NaT])
+        assert_series_equal(s - dt, exp)
+        assert_series_equal(s - Timestamp(dt), exp)
 
-    def test_more_na_comparisons(self):
-        for dtype in [None, object]:
-            left = Series(['a', np.nan, 'c'], dtype=dtype)
-            right = Series(['a', np.nan, 'd'], dtype=dtype)
+    def test_datetime_series_with_timedelta(self):
+        # scalar timedeltas/np.timedelta64 objects
+        # operate with np.timedelta64 correctly
+        s = Series([Timestamp('20130101 9:01'), Timestamp('20130101 9:02')])
 
-            result = left == right
-            expected = Series([True, False, False])
-            assert_series_equal(result, expected)
+        result = s + np.timedelta64(1, 's')
+        result2 = np.timedelta64(1, 's') + s
+        expected = Series([Timestamp('20130101 9:01:01'),
+                           Timestamp('20130101 9:02:01')])
+        assert_series_equal(result, expected)
+        assert_series_equal(result2, expected)
 
-            result = left != right
-            expected = Series([False, True, True])
-            assert_series_equal(result, expected)
+        result = s + np.timedelta64(5, 'ms')
+        result2 = np.timedelta64(5, 'ms') + s
+        expected = Series([Timestamp('20130101 9:01:00.005'),
+                           Timestamp('20130101 9:02:00.005')])
+        assert_series_equal(result, expected)
+        assert_series_equal(result2, expected)
 
-            result = left == np.nan
-            expected = Series([False, False, False])
-            assert_series_equal(result, expected)
+    def test_datetime_series_with_DateOffset(self):
+        # GH 4532
+        # operate with pd.offsets
+        s = Series([Timestamp('20130101 9:01'), Timestamp('20130101 9:02')])
 
-            result = left != np.nan
-            expected = Series([True, True, True])
-            assert_series_equal(result, expected)
+        result = s + pd.offsets.Second(5)
+        result2 = pd.offsets.Second(5) + s
+        expected = Series([Timestamp('20130101 9:01:05'),
+                           Timestamp('20130101 9:02:05')])
+        assert_series_equal(result, expected)
+        assert_series_equal(result2, expected)
 
-    def test_nat_comparisons(self):
-        data = [([pd.Timestamp('2011-01-01'), pd.NaT,
-                  pd.Timestamp('2011-01-03')],
-                 [pd.NaT, pd.NaT, pd.Timestamp('2011-01-03')]),
+        result = s - pd.offsets.Second(5)
+        result2 = -pd.offsets.Second(5) + s
+        expected = Series([Timestamp('20130101 9:00:55'),
+                           Timestamp('20130101 9:01:55')])
+        assert_series_equal(result, expected)
+        assert_series_equal(result2, expected)
 
-                ([pd.Timedelta('1 days'), pd.NaT,
-                  pd.Timedelta('3 days')],
-                 [pd.NaT, pd.NaT, pd.Timedelta('3 days')]),
+        result = s + pd.offsets.Milli(5)
+        result2 = pd.offsets.Milli(5) + s
+        expected = Series([Timestamp('20130101 9:01:00.005'),
+                           Timestamp('20130101 9:02:00.005')])
+        assert_series_equal(result, expected)
+        assert_series_equal(result2, expected)
 
-                ([pd.Period('2011-01', freq='M'), pd.NaT,
-                  pd.Period('2011-03', freq='M')],
-                 [pd.NaT, pd.NaT, pd.Period('2011-03', freq='M')])]
+        result = s + pd.offsets.Minute(5) + pd.offsets.Milli(5)
+        expected = Series([Timestamp('20130101 9:06:00.005'),
+                           Timestamp('20130101 9:07:00.005')])
+        assert_series_equal(result, expected)
 
-        # add lhs / rhs switched data
-        data = data + [(r, l) for l, r in data]
+        # valid DateOffsets
+        for do in ['Hour', 'Minute', 'Second', 'Day', 'Micro', 'Milli',
+                   'Nano']:
+            op = getattr(pd.offsets, do)
+            s + op(5)
+            op(5) + s
 
-        for l, r in data:
-            for dtype in [None, object]:
-                left = Series(l, dtype=dtype)
+    def test_datetime64_ops_nat(self):
+        # GH 11349
+        datetime_series = Series([NaT, Timestamp('19900315')])
+        nat_series_dtype_timestamp = Series([NaT, NaT], dtype='datetime64[ns]')
+        single_nat_dtype_datetime = Series([NaT], dtype='datetime64[ns]')
 
-                # Series, Index
-                for right in [Series(r, dtype=dtype), Index(r, dtype=dtype)]:
-                    expected = Series([False, False, True])
-                    assert_series_equal(left == right, expected)
+        # subtraction
+        assert_series_equal(datetime_series - NaT, nat_series_dtype_timestamp)
+        assert_series_equal(-NaT + datetime_series, nat_series_dtype_timestamp)
+        with pytest.raises(TypeError):
+            -single_nat_dtype_datetime + datetime_series
 
-                    expected = Series([True, True, False])
-                    assert_series_equal(left != right, expected)
+        assert_series_equal(nat_series_dtype_timestamp - NaT,
+                            nat_series_dtype_timestamp)
+        assert_series_equal(-NaT + nat_series_dtype_timestamp,
+                            nat_series_dtype_timestamp)
+        with pytest.raises(TypeError):
+            -single_nat_dtype_datetime + nat_series_dtype_timestamp
 
-                    expected = Series([False, False, False])
-                    assert_series_equal(left < right, expected)
+        # addition
+        assert_series_equal(nat_series_dtype_timestamp + NaT,
+                            nat_series_dtype_timestamp)
+        assert_series_equal(NaT + nat_series_dtype_timestamp,
+                            nat_series_dtype_timestamp)
 
-                    expected = Series([False, False, False])
-                    assert_series_equal(left > right, expected)
+        assert_series_equal(nat_series_dtype_timestamp + NaT,
+                            nat_series_dtype_timestamp)
+        assert_series_equal(NaT + nat_series_dtype_timestamp,
+                            nat_series_dtype_timestamp)
 
-                    expected = Series([False, False, True])
-                    assert_series_equal(left >= right, expected)
+        # multiplication
+        with pytest.raises(TypeError):
+            datetime_series * 1
+        with pytest.raises(TypeError):
+            nat_series_dtype_timestamp * 1
+        with pytest.raises(TypeError):
+            datetime_series * 1.0
+        with pytest.raises(TypeError):
+            nat_series_dtype_timestamp * 1.0
 
-                    expected = Series([False, False, True])
-                    assert_series_equal(left <= right, expected)
+        # division
+        with pytest.raises(TypeError):
+            nat_series_dtype_timestamp / 1.0
+        with pytest.raises(TypeError):
+            nat_series_dtype_timestamp / 1
 
-    def test_nat_comparisons_scalar(self):
-        data = [[pd.Timestamp('2011-01-01'), pd.NaT,
-                 pd.Timestamp('2011-01-03')],
 
-                [pd.Timedelta('1 days'), pd.NaT, pd.Timedelta('3 days')],
+class TestSeriesOperators(TestData):
+    def test_op_method(self):
+        def check(series, other, check_reverse=False):
+            simple_ops = ['add', 'sub', 'mul', 'floordiv', 'truediv', 'pow']
+            if not compat.PY3:
+                simple_ops.append('div')
 
-                [pd.Period('2011-01', freq='M'), pd.NaT,
-                 pd.Period('2011-03', freq='M')]]
+            for opname in simple_ops:
+                op = getattr(Series, opname)
 
-        for l in data:
-            for dtype in [None, object]:
-                left = Series(l, dtype=dtype)
+                if op == 'div':
+                    alt = operator.truediv
+                else:
+                    alt = getattr(operator, opname)
 
-                expected = Series([False, False, False])
-                assert_series_equal(left == pd.NaT, expected)
-                assert_series_equal(pd.NaT == left, expected)
+                result = op(series, other)
+                expected = alt(series, other)
+                assert_almost_equal(result, expected)
+                if check_reverse:
+                    rop = getattr(Series, "r" + opname)
+                    result = rop(series, other)
+                    expected = alt(other, series)
+                    assert_almost_equal(result, expected)
 
-                expected = Series([True, True, True])
-                assert_series_equal(left != pd.NaT, expected)
-                assert_series_equal(pd.NaT != left, expected)
+        check(self.ts, self.ts * 2)
+        check(self.ts, self.ts[::2])
+        check(self.ts, 5, check_reverse=True)
+        check(tm.makeFloatSeries(), tm.makeFloatSeries(), check_reverse=True)
 
-                expected = Series([False, False, False])
-                assert_series_equal(left < pd.NaT, expected)
-                assert_series_equal(pd.NaT > left, expected)
-                assert_series_equal(left <= pd.NaT, expected)
-                assert_series_equal(pd.NaT >= left, expected)
+    def test_neg(self):
+        assert_series_equal(-self.series, -1 * self.series)
 
-                assert_series_equal(left > pd.NaT, expected)
-                assert_series_equal(pd.NaT < left, expected)
-                assert_series_equal(left >= pd.NaT, expected)
-                assert_series_equal(pd.NaT <= left, expected)
+    def test_invert(self):
+        assert_series_equal(-(self.series < 0), ~(self.series < 0))
 
-    def test_comparison_different_length(self):
-        a = Series(['a', 'b', 'c'])
-        b = Series(['b', 'a'])
-        pytest.raises(ValueError, a.__lt__, b)
+    def test_operators(self):
+        def _check_op(series, other, op, pos_only=False,
+                      check_dtype=True):
+            left = np.abs(series) if pos_only else series
+            right = np.abs(other) if pos_only else other
 
-        a = Series([1, 2])
-        b = Series([2, 3, 4])
-        pytest.raises(ValueError, a.__eq__, b)
+            cython_or_numpy = op(left, right)
+            python = left.combine(right, op)
+            assert_series_equal(cython_or_numpy, python,
+                                check_dtype=check_dtype)
 
-    def test_comparison_label_based(self):
+        def check(series, other):
+            simple_ops = ['add', 'sub', 'mul', 'truediv', 'floordiv', 'mod']
 
-        # GH 4947
-        # comparisons should be label based
+            for opname in simple_ops:
+                _check_op(series, other, getattr(operator, opname))
 
-        a = Series([True, False, True], list('bca'))
-        b = Series([False, True, False], list('abc'))
+            _check_op(series, other, operator.pow, pos_only=True)
 
-        expected = Series([False, True, False], list('abc'))
-        result = a & b
-        assert_series_equal(result, expected)
+            _check_op(series, other, lambda x, y: operator.add(y, x))
+            _check_op(series, other, lambda x, y: operator.sub(y, x))
+            _check_op(series, other, lambda x, y: operator.truediv(y, x))
+            _check_op(series, other, lambda x, y: operator.floordiv(y, x))
+            _check_op(series, other, lambda x, y: operator.mul(y, x))
+            _check_op(series, other, lambda x, y: operator.pow(y, x),
+                      pos_only=True)
+            _check_op(series, other, lambda x, y: operator.mod(y, x))
 
-        expected = Series([True, True, False], list('abc'))
-        result = a | b
-        assert_series_equal(result, expected)
+        check(self.ts, self.ts * 2)
+        check(self.ts, self.ts * 0)
+        check(self.ts, self.ts[::2])
+        check(self.ts, 5)
 
-        expected = Series([True, False, False], list('abc'))
-        result = a ^ b
-        assert_series_equal(result, expected)
+        def check_comparators(series, other, check_dtype=True):
+            _check_op(series, other, operator.gt, check_dtype=check_dtype)
+            _check_op(series, other, operator.ge, check_dtype=check_dtype)
+            _check_op(series, other, operator.eq, check_dtype=check_dtype)
+            _check_op(series, other, operator.lt, check_dtype=check_dtype)
+            _check_op(series, other, operator.le, check_dtype=check_dtype)
 
-        # rhs is bigger
-        a = Series([True, False, True], list('bca'))
-        b = Series([False, True, False, True], list('abcd'))
+        check_comparators(self.ts, 5)
+        check_comparators(self.ts, self.ts + 1, check_dtype=False)
 
-        expected = Series([False, True, False, False], list('abcd'))
-        result = a & b
-        assert_series_equal(result, expected)
+    def test_divmod(self):
+        def check(series, other):
+            results = divmod(series, other)
+            if isinstance(other, Iterable) and len(series) != len(other):
+                # if the lengths don't match, this is the test where we use
+                # `self.ts[::2]`. Pad every other value in `other_np` with nan.
+                other_np = []
+                for n in other:
+                    other_np.append(n)
+                    other_np.append(np.nan)
+            else:
+                other_np = other
+            other_np = np.asarray(other_np)
+            with np.errstate(all='ignore'):
+                expecteds = divmod(series.values, np.asarray(other_np))
 
-        expected = Series([True, True, False, False], list('abcd'))
-        result = a | b
-        assert_series_equal(result, expected)
+            for result, expected in zip(results, expecteds):
+                # check the values, name, and index separatly
+                assert_almost_equal(np.asarray(result), expected)
 
-        # filling
+                assert result.name == series.name
+                assert_index_equal(result.index, series.index)
 
-        # vs empty
-        result = a & Series([])
-        expected = Series([False, False, False], list('bca'))
-        assert_series_equal(result, expected)
+        check(self.ts, self.ts * 2)
+        check(self.ts, self.ts * 0)
+        check(self.ts, self.ts[::2])
+        check(self.ts, 5)
 
-        result = a | Series([])
-        expected = Series([True, False, True], list('bca'))
-        assert_series_equal(result, expected)
+    def test_operators_empty_int_corner(self):
+        s1 = Series([], [], dtype=np.int32)
+        s2 = Series({'x': 0.})
+        assert_series_equal(s1 * s2, Series([np.nan], index=['x']))
 
-        # vs non-matching
-        result = a & Series([1], ['z'])
-        expected = Series([False, False, False, False], list('abcz'))
-        assert_series_equal(result, expected)
+    def test_invalid_ops(self):
+        # invalid ops
+        pytest.raises(Exception, self.objSeries.__add__, 1)
+        pytest.raises(Exception, self.objSeries.__add__,
+                      np.array(1, dtype=np.int64))
+        pytest.raises(Exception, self.objSeries.__sub__, 1)
+        pytest.raises(Exception, self.objSeries.__sub__,
+                      np.array(1, dtype=np.int64))
 
-        result = a | Series([1], ['z'])
-        expected = Series([True, True, False, False], list('abcz'))
-        assert_series_equal(result, expected)
+    def test_timedelta64_conversions(self):
+        startdate = Series(date_range('2013-01-01', '2013-01-03'))
+        enddate = Series(date_range('2013-03-01', '2013-03-03'))
 
-        # identity
-        # we would like s[s|e] == s to hold for any e, whether empty or not
-        for e in [Series([]), Series([1], ['z']),
-                  Series(np.nan, b.index), Series(np.nan, a.index)]:
-            result = a[a | e]
-            assert_series_equal(result, a[a])
+        s1 = enddate - startdate
+        s1[2] = np.nan
 
-        for e in [Series(['z'])]:
-            if compat.PY3:
-                with tm.assert_produces_warning(RuntimeWarning):
-                    result = a[a | e]
-            else:
-                result = a[a | e]
-            assert_series_equal(result, a[a])
+        for m in [1, 3, 10]:
+            for unit in ['D', 'h', 'm', 's', 'ms', 'us', 'ns']:
 
-        # vs scalars
-        index = list('bca')
-        t = Series([True, False, True])
+                # op
+                expected = s1.apply(lambda x: x / np.timedelta64(m, unit))
+                result = s1 / np.timedelta64(m, unit)
+                assert_series_equal(result, expected)
 
-        for v in [True, 1, 2]:
-            result = Series([True, False, True], index=index) | v
-            expected = Series([True, True, True], index=index)
-            assert_series_equal(result, expected)
+                if m == 1 and unit != 'ns':
 
-        for v in [np.nan, 'foo']:
-            pytest.raises(TypeError, lambda: t | v)
+                    # astype
+                    result = s1.astype("timedelta64[{0}]".format(unit))
+                    assert_series_equal(result, expected)
 
-        for v in [False, 0]:
-            result = Series([True, False, True], index=index) | v
-            expected = Series([True, False, True], index=index)
-            assert_series_equal(result, expected)
+                # reverse op
+                expected = s1.apply(
+                    lambda x: Timedelta(np.timedelta64(m, unit)) / x)
+                result = np.timedelta64(m, unit) / s1
 
-        for v in [True, 1]:
-            result = Series([True, False, True], index=index) & v
-            expected = Series([True, False, True], index=index)
-            assert_series_equal(result, expected)
+        # astype
+        s = Series(date_range('20130101', periods=3))
+        result = s.astype(object)
+        assert isinstance(result.iloc[0], datetime)
+        assert result.dtype == np.object_
 
-        for v in [False, 0]:
-            result = Series([True, False, True], index=index) & v
-            expected = Series([False, False, False], index=index)
-            assert_series_equal(result, expected)
-        for v in [np.nan]:
-            pytest.raises(TypeError, lambda: t & v)
+        result = s1.astype(object)
+        assert isinstance(result.iloc[0], timedelta)
+        assert result.dtype == np.object_
 
-    def test_comparison_flex_basic(self):
-        left = pd.Series(np.random.randn(10))
-        right = pd.Series(np.random.randn(10))
+    @pytest.mark.parametrize('op', [operator.add, operator.sub])
+    def test_timedelta64_equal_timedelta_supported_ops(self, op):
+        ser = Series([Timestamp('20130301'), Timestamp('20130228 23:00:00'),
+                      Timestamp('20130228 22:00:00'),
+                      Timestamp('20130228 21:00:00')])
 
-        assert_series_equal(left.eq(right), left == right)
-        assert_series_equal(left.ne(right), left != right)
-        assert_series_equal(left.le(right), left < right)
-        assert_series_equal(left.lt(right), left <= right)
-        assert_series_equal(left.gt(right), left > right)
-        assert_series_equal(left.ge(right), left >= right)
+        intervals = 'D', 'h', 'm', 's', 'us'
 
-        # axis
-        for axis in [0, None, 'index']:
-            assert_series_equal(left.eq(right, axis=axis), left == right)
-            assert_series_equal(left.ne(right, axis=axis), left != right)
-            assert_series_equal(left.le(right, axis=axis), left < right)
-            assert_series_equal(left.lt(right, axis=axis), left <= right)
-            assert_series_equal(left.gt(right, axis=axis), left > right)
-            assert_series_equal(left.ge(right, axis=axis), left >= right)
+        # TODO: unused
+        # npy16_mappings = {'D': 24 * 60 * 60 * 1000000,
+        #                   'h': 60 * 60 * 1000000,
+        #                   'm': 60 * 1000000,
+        #                   's': 1000000,
+        #                   'us': 1}
 
-        #
-        msg = 'No axis named 1 for object type'
-        for op in ['eq', 'ne', 'le', 'le', 'gt', 'ge']:
-            with tm.assert_raises_regex(ValueError, msg):
-                getattr(left, op)(right, axis=1)
+        def timedelta64(*args):
+            return sum(starmap(np.timedelta64, zip(args, intervals)))
 
-    def test_comparison_flex_alignment(self):
-        left = Series([1, 3, 2], index=list('abc'))
-        right = Series([2, 2, 2], index=list('bcd'))
+        for d, h, m, s, us in product(*([range(2)] * 5)):
+            nptd = timedelta64(d, h, m, s, us)
+            pytd = timedelta(days=d, hours=h, minutes=m, seconds=s,
+                             microseconds=us)
+            lhs = op(ser, nptd)
+            rhs = op(ser, pytd)
 
-        exp = pd.Series([False, False, True, False], index=list('abcd'))
-        assert_series_equal(left.eq(right), exp)
+            try:
+                assert_series_equal(lhs, rhs)
+            except:
+                raise AssertionError(
+                    "invalid comparsion [op->{0},d->{1},h->{2},m->{3},"
+                    "s->{4},us->{5}]\n{6}\n{7}\n".format(op, d, h, m, s,
+                                                         us, lhs, rhs))
 
-        exp = pd.Series([True, True, False, True], index=list('abcd'))
-        assert_series_equal(left.ne(right), exp)
+    def test_ops_nat_mixed_datetime64_timedelta64(self):
+        # GH 11349
+        timedelta_series = Series([NaT, Timedelta('1s')])
+        datetime_series = Series([NaT, Timestamp('19900315')])
+        nat_series_dtype_timedelta = Series([NaT, NaT],
+                                            dtype='timedelta64[ns]')
+        nat_series_dtype_timestamp = Series([NaT, NaT], dtype='datetime64[ns]')
+        single_nat_dtype_datetime = Series([NaT], dtype='datetime64[ns]')
+        single_nat_dtype_timedelta = Series([NaT], dtype='timedelta64[ns]')
 
-        exp = pd.Series([False, False, True, False], index=list('abcd'))
-        assert_series_equal(left.le(right), exp)
+        # subtraction
+        assert_series_equal(datetime_series - single_nat_dtype_datetime,
+                            nat_series_dtype_timedelta)
 
-        exp = pd.Series([False, False, False, False], index=list('abcd'))
-        assert_series_equal(left.lt(right), exp)
+        assert_series_equal(datetime_series - single_nat_dtype_timedelta,
+                            nat_series_dtype_timestamp)
+        assert_series_equal(-single_nat_dtype_timedelta + datetime_series,
+                            nat_series_dtype_timestamp)
 
-        exp = pd.Series([False, True, True, False], index=list('abcd'))
-        assert_series_equal(left.ge(right), exp)
+        # without a Series wrapping the NaT, it is ambiguous
+        # whether it is a datetime64 or timedelta64
+        # defaults to interpreting it as timedelta64
+        assert_series_equal(nat_series_dtype_timestamp -
+                            single_nat_dtype_datetime,
+                            nat_series_dtype_timedelta)
 
-        exp = pd.Series([False, True, False, False], index=list('abcd'))
-        assert_series_equal(left.gt(right), exp)
+        assert_series_equal(nat_series_dtype_timestamp -
+                            single_nat_dtype_timedelta,
+                            nat_series_dtype_timestamp)
+        assert_series_equal(-single_nat_dtype_timedelta +
+                            nat_series_dtype_timestamp,
+                            nat_series_dtype_timestamp)
 
-    def test_comparison_flex_alignment_fill(self):
-        left = Series([1, 3, 2], index=list('abc'))
-        right = Series([2, 2, 2], index=list('bcd'))
+        with pytest.raises(TypeError):
+            timedelta_series - single_nat_dtype_datetime
 
-        exp = pd.Series([False, False, True, True], index=list('abcd'))
-        assert_series_equal(left.eq(right, fill_value=2), exp)
+        # addition
+        assert_series_equal(nat_series_dtype_timestamp +
+                            single_nat_dtype_timedelta,
+                            nat_series_dtype_timestamp)
+        assert_series_equal(single_nat_dtype_timedelta +
+                            nat_series_dtype_timestamp,
+                            nat_series_dtype_timestamp)
 
-        exp = pd.Series([True, True, False, False], index=list('abcd'))
-        assert_series_equal(left.ne(right, fill_value=2), exp)
+        assert_series_equal(nat_series_dtype_timestamp +
+                            single_nat_dtype_timedelta,
+                            nat_series_dtype_timestamp)
+        assert_series_equal(single_nat_dtype_timedelta +
+                            nat_series_dtype_timestamp,
+                            nat_series_dtype_timestamp)
 
-        exp = pd.Series([False, False, True, True], index=list('abcd'))
-        assert_series_equal(left.le(right, fill_value=0), exp)
+        assert_series_equal(nat_series_dtype_timedelta +
+                            single_nat_dtype_datetime,
+                            nat_series_dtype_timestamp)
+        assert_series_equal(single_nat_dtype_datetime +
+                            nat_series_dtype_timedelta,
+                            nat_series_dtype_timestamp)
 
-        exp = pd.Series([False, False, False, True], index=list('abcd'))
-        assert_series_equal(left.lt(right, fill_value=0), exp)
+    def test_ops_datetimelike_align(self):
+        # GH 7500
+        # datetimelike ops need to align
+        dt = Series(date_range('2012-1-1', periods=3, freq='D'))
+        dt.iloc[2] = np.nan
+        dt2 = dt[::-1]
 
-        exp = pd.Series([True, True, True, False], index=list('abcd'))
-        assert_series_equal(left.ge(right, fill_value=0), exp)
+        expected = Series([timedelta(0), timedelta(0), pd.NaT])
+        # name is reset
+        result = dt2 - dt
+        assert_series_equal(result, expected)
 
-        exp = pd.Series([True, True, False, False], index=list('abcd'))
-        assert_series_equal(left.gt(right, fill_value=0), exp)
+        expected = Series(expected, name=0)
+        result = (dt2.to_frame() - dt.to_frame())[0]
+        assert_series_equal(result, expected)
 
     def test_return_dtypes_bool_op_costant(self):
         # gh15115
@@ -1605,36 +1688,6 @@ class TestSeriesOperators(TestData):
         assert_frame_equal(s3.to_frame() + s4.to_frame(), exp)
         assert_frame_equal(s4.to_frame() + s3.to_frame(), exp)
 
-    def test_comp_ops_df_compat(self):
-        # GH 1134
-        s1 = pd.Series([1, 2, 3], index=list('ABC'), name='x')
-        s2 = pd.Series([2, 2, 2], index=list('ABD'), name='x')
-
-        s3 = pd.Series([1, 2, 3], index=list('ABC'), name='x')
-        s4 = pd.Series([2, 2, 2, 2], index=list('ABCD'), name='x')
-
-        for l, r in [(s1, s2), (s2, s1), (s3, s4), (s4, s3)]:
-
-            msg = "Can only compare identically-labeled Series objects"
-            with tm.assert_raises_regex(ValueError, msg):
-                l == r
-
-            with tm.assert_raises_regex(ValueError, msg):
-                l != r
-
-            with tm.assert_raises_regex(ValueError, msg):
-                l < r
-
-            msg = "Can only compare identically-labeled DataFrame objects"
-            with tm.assert_raises_regex(ValueError, msg):
-                l.to_frame() == r.to_frame()
-
-            with tm.assert_raises_regex(ValueError, msg):
-                l.to_frame() != r.to_frame()
-
-            with tm.assert_raises_regex(ValueError, msg):
-                l.to_frame() < r.to_frame()
-
     def test_bool_ops_df_compat(self):
         # GH 1134
         s1 = pd.Series([True, False, True], index=list('ABC'), name='x')
@@ -1851,12 +1904,6 @@ class TestSeriesOperators(TestData):
             # should accept axis=0 or axis='rows'
             op(a, b, axis=0)
 
-    def test_ne(self):
-        ts = Series([3, 4, 5, 6, 7], [3, 4, 5, 6, 7], dtype=float)
-        expected = [True, True, False, True, True]
-        assert tm.equalContents(ts.index != 5, expected)
-        assert tm.equalContents(~(ts.index == 5), expected)
-
     def test_operators_na_handling(self):
         from decimal import Decimal
         from datetime import date
@@ -1877,22 +1924,6 @@ class TestSeriesOperators(TestData):
         expected = Series(['foo_suffix', 'bar_suffix', 'baz_suffix', np.nan])
         assert_series_equal(result, expected)
 
-    def test_divide_decimal(self):
-        """ resolves issue #9787 """
-        from decimal import Decimal
-
-        expected = Series([Decimal(5)])
-
-        s = Series([Decimal(10)])
-        s = s / Decimal(2)
-
-        assert_series_equal(expected, s)
-
-        s = Series([Decimal(10)])
-        s = s // Decimal(2)
-
-        assert_series_equal(expected, s)
-
     def test_datetime64_with_index(self):
 
         # arithmetic integer ops with an index

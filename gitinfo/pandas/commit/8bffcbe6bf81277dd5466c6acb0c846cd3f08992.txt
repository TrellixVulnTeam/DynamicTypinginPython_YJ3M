commit 8bffcbe6bf81277dd5466c6acb0c846cd3f08992
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jun 4 10:27:20 2012 -0400

    BLD: break period code into separate extension for sanity

diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 3efef8312..edac630f3 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -870,34 +870,6 @@ cdef class DayOffset(_Offset):
                 self.t += (4 - self.dow) * us_in_day
                 self.dow = 4
 
-#cdef ndarray[int64_t] _generate_range(_Offset offset, Py_ssize_t periods):
-#    """
-#    Generate timestamps according to offset.
-#    """
-#    cdef:
-#        Py_ssize_t i
-#        ndarray[int64_t] dtindex
-
-#    dtindex = np.empty(periods, np.int64)
-#    for i in range(periods):
-#        dtindex[i] = offset._ts()
-#        offset.next()
-#    return dtindex
-
-#cdef int64_t _count_range(_Offset offset, object end):
-#    """
-#    Count timestamps in range according to offset up to (and including)
-#    end time.
-#    """
-#    cdef:
-#        Py_ssize_t i=0
-#        _TSObject e
-
-#    e = convert_to_tsobject(end)
-#    while offset._ts() <= e.value:
-#        i += 1
-#        offset.next()
-#    return i
 
 def array_to_datetime(ndarray[object] values, raise_=False, dayfirst=False):
     cdef:
@@ -1530,216 +1502,3 @@ def monthrange(int64_t year, int64_t month):
 cdef inline int64_t ts_dayofweek(_TSObject ts):
     return dayofweek(ts.dts.year, ts.dts.month, ts.dts.day)
 
-# Period logic
-#----------------------------------------------------------------------
-
-cdef inline int64_t apply_mult(int64_t period_ord, int64_t mult):
-    """
-    Get freq+multiple ordinal value from corresponding freq-only ordinal value.
-    For example, 5min ordinal will be 1/5th the 1min ordinal (rounding down to
-    integer).
-    """
-    if mult == 1:
-        return period_ord
-
-    return (period_ord - 1) // mult
-
-cdef inline int64_t remove_mult(int64_t period_ord_w_mult, int64_t mult):
-    """
-    Get freq-only ordinal value from corresponding freq+multiple ordinal.
-    """
-    if mult == 1:
-        return period_ord_w_mult
-
-    return period_ord_w_mult * mult + 1;
-
-def dt64arr_to_periodarr(ndarray[int64_t] dtarr, int freq):
-    """
-    Convert array of datetime64 values (passed in as 'i8' dtype) to a set of
-    periods corresponding to desired frequency, per period convention.
-    """
-    cdef:
-        ndarray[int64_t] out
-        Py_ssize_t i, l
-        pandas_datetimestruct dts
-
-    l = len(dtarr)
-
-    out = np.empty(l, dtype='i8')
-
-    for i in range(l):
-        pandas_datetime_to_datetimestruct(dtarr[i], PANDAS_FR_ns, &dts)
-        out[i] = get_period_ordinal(dts.year, dts.month, dts.day,
-                                    dts.hour, dts.min, dts.sec, freq)
-    return out
-
-def periodarr_to_dt64arr(ndarray[int64_t] periodarr, int freq):
-    """
-    Convert array to datetime64 values from a set of ordinals corresponding to
-    periods per period convention.
-    """
-    cdef:
-        ndarray[int64_t] out
-        Py_ssize_t i, l
-
-    l = len(periodarr)
-
-    out = np.empty(l, dtype='i8')
-
-    for i in range(l):
-        out[i] = period_ordinal_to_dt64(periodarr[i], freq)
-
-    return out
-
-cdef char START = 'S'
-cdef char END = 'E'
-
-cpdef int64_t period_asfreq(int64_t period_ordinal, int freq1, int freq2,
-                            bint end):
-    """
-    Convert period ordinal from one frequency to another, and if upsampling,
-    choose to use start ('S') or end ('E') of period.
-    """
-    cdef:
-        int64_t retval
-
-    if end:
-        retval = asfreq(period_ordinal, freq1, freq2, END)
-    else:
-        retval = asfreq(period_ordinal, freq1, freq2, START)
-
-    if retval == INT32_MIN:
-        raise ValueError('Frequency conversion failed')
-
-    return retval
-
-def period_asfreq_arr(ndarray[int64_t] arr, int freq1, int freq2, bint end):
-    """
-    Convert int64-array of period ordinals from one frequency to another, and
-    if upsampling, choose to use start ('S') or end ('E') of period.
-    """
-    cdef:
-        ndarray[int64_t] result
-        Py_ssize_t i, n
-        freq_conv_func func
-        asfreq_info finfo
-        int64_t val, ordinal
-        char relation
-
-    n = len(arr)
-    result = np.empty(n, dtype=np.int64)
-
-    func = get_asfreq_func(freq1, freq2)
-    get_asfreq_info(freq1, freq2, &finfo)
-
-    if end:
-        relation = END
-    else:
-        relation = START
-
-    for i in range(n):
-        val = func(arr[i], relation, &finfo)
-        if val == -1:
-            raise ValueError("Unable to convert to desired frequency.")
-        result[i] = val
-
-    return result
-
-def period_ordinal(int y, int m, int d, int h, int min, int s, int freq):
-    cdef:
-        int64_t ordinal
-
-    return get_period_ordinal(y, m, d, h, min, s, freq)
-
-
-cpdef int64_t period_ordinal_to_dt64(int64_t ordinal, int freq):
-    cdef:
-        pandas_datetimestruct dts
-        date_info dinfo
-
-    get_date_info(ordinal, freq, &dinfo)
-
-    dts.year = dinfo.year
-    dts.month = dinfo.month
-    dts.day = dinfo.day
-    dts.hour = dinfo.hour
-    dts.min = dinfo.minute
-    dts.sec = int(dinfo.second)
-    dts.us = dts.ps = 0
-
-    return pandas_datetimestruct_to_datetime(PANDAS_FR_ns, &dts)
-
-def period_ordinal_to_string(int64_t value, int freq):
-    cdef:
-        char *ptr
-
-    ptr = period_to_string(value, freq)
-
-    if ptr == NULL:
-        raise ValueError("Could not create string from ordinal '%s'" % value)
-
-    return <object> ptr
-
-def period_strftime(int64_t value, int freq, object fmt):
-    cdef:
-        char *ptr
-
-    ptr = period_to_string2(value, freq, <char*>fmt)
-
-    if ptr == NULL:
-        raise ValueError("Could not create string with fmt '%s'" % fmt)
-
-    return <object> ptr
-
-# period accessors
-
-ctypedef int (*accessor)(int64_t ordinal, int freq) except INT32_MIN
-
-def get_period_field(int code, int64_t value, int freq):
-    cdef accessor f = _get_accessor_func(code)
-    return f(value, freq)
-
-def get_period_field_arr(int code, ndarray[int64_t] arr, int freq):
-    cdef:
-        Py_ssize_t i, sz
-        ndarray[int64_t] out
-        accessor f
-
-    f = _get_accessor_func(code)
-
-    sz = len(arr)
-    out = np.empty(sz, dtype=np.int64)
-
-    for i in range(sz):
-        out[i] = f(arr[i], freq)
-
-    return out
-
-
-
-cdef accessor _get_accessor_func(int code):
-    if code == 0:
-        return &pyear
-    elif code == 1:
-        return &pqyear
-    elif code == 2:
-        return &pquarter
-    elif code == 3:
-        return &pmonth
-    elif code == 4:
-        return &pday
-    elif code == 5:
-        return &phour
-    elif code == 6:
-        return &pminute
-    elif code == 7:
-        return &psecond
-    elif code == 8:
-        return &pweek
-    elif code == 9:
-        return &pday_of_year
-    elif code == 10:
-        return &pweekday
-    else:
-        raise ValueError('Unrecognized code: %s' % code)
-
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index 83d14ebb1..23a164ec3 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -13,6 +13,7 @@ import pandas.core.common as com
 
 from pandas.lib import Timestamp
 import pandas.lib as lib
+import pandas._period as plib
 
 
 #---------------
@@ -24,7 +25,7 @@ def _period_field_accessor(name, alias=None):
         alias = name
     def f(self):
         base, mult = _gfc(self.freq)
-        return lib.get_period_field(alias, self.ordinal, base)
+        return plib.get_period_field(alias, self.ordinal, base)
     f.__name__ = name
     return property(f)
 
@@ -33,7 +34,7 @@ def _field_accessor(name, alias=None):
         alias = name
     def f(self):
         base, mult = _gfc(self.freq)
-        return lib.get_period_field_arr(alias, self.values, base)
+        return plib.get_period_field_arr(alias, self.values, base)
     f.__name__ = name
     return property(f)
 
@@ -138,9 +139,9 @@ class Period(object):
             raise ValueError('Only mult == 1 supported')
 
         if self.ordinal is None:
-            self.ordinal = lib.period_ordinal(dt.year, dt.month, dt.day,
-                                              dt.hour, dt.minute, dt.second,
-                                              base)
+            self.ordinal = plib.period_ordinal(dt.year, dt.month, dt.day,
+                                               dt.hour, dt.minute, dt.second,
+                                               base)
 
         self.freq = _freq_mod._get_freq_str(base)
 
@@ -191,7 +192,7 @@ class Period(object):
             raise ValueError('relation argument must be one of S or E')
 
         end = how == 'E'
-        new_ordinal = lib.period_asfreq(self.ordinal, base1, base2, end)
+        new_ordinal = plib.period_asfreq(self.ordinal, base1, base2, end)
 
         return Period(ordinal=new_ordinal, freq=base2)
 
@@ -230,7 +231,7 @@ class Period(object):
         if mult != 1:
             raise ValueError('Only mult == 1 supported')
 
-        dt64 = lib.period_ordinal_to_dt64(new_val.ordinal, base)
+        dt64 = plib.period_ordinal_to_dt64(new_val.ordinal, base)
         ts_freq = _period_rule_to_timestamp_rule(new_val.freq, how=how)
         return Timestamp(dt64, offset=to_offset(ts_freq))
 
@@ -254,13 +255,13 @@ class Period(object):
 
     def __repr__(self):
         base, mult = _gfc(self.freq)
-        formatted = lib.period_ordinal_to_string(self.ordinal, base)
+        formatted = plib.period_ordinal_to_string(self.ordinal, base)
         freqstr = _freq_mod._reverse_period_code_map[base]
         return "Period('%s', '%s')" % (formatted, freqstr)
 
     def __str__(self):
         base, mult = _gfc(self.freq)
-        formatted = lib.period_ordinal_to_string(self.ordinal, base)
+        formatted = plib.period_ordinal_to_string(self.ordinal, base)
         return ("%s" % formatted)
 
     def strftime(self, fmt):
@@ -402,9 +403,9 @@ class Period(object):
         """
         base, mult = _gfc(self.freq)
         if fmt is not None:
-            return lib.period_strftime(self.ordinal, base, fmt)
+            return plib.period_strftime(self.ordinal, base, fmt)
         else:
-            return lib.period_ordinal_to_string(self.ordinal, base)
+            return plib.period_ordinal_to_string(self.ordinal, base)
 
 
 def _get_date_and_freq(value, freq):
@@ -472,7 +473,7 @@ def dt64arr_to_periodarr(data, freq):
     else:
         base, mult = freq
 
-    return lib.dt64arr_to_periodarr(data.view('i8'), base)
+    return plib.dt64arr_to_periodarr(data.view('i8'), base)
 
 # --- Period index sketch
 
@@ -641,7 +642,7 @@ class PeriodIndex(Int64Index):
                 else:
                     base1, _ = _gfc(data.freq)
                     base2, _ = _gfc(freq)
-                    data = lib.period_asfreq_arr(data.values, base1, base2, 1)
+                    data = plib.period_asfreq_arr(data.values, base1, base2, 1)
             else:
                 if freq is None and len(data) > 0:
                     freq = getattr(data[0], 'freq')
@@ -726,7 +727,7 @@ class PeriodIndex(Int64Index):
             raise ValueError('relation argument must be one of S or E')
 
         end = how == 'E'
-        new_data = lib.period_asfreq_arr(self.values, base1, base2, end)
+        new_data = plib.period_asfreq_arr(self.values, base1, base2, end)
 
         result = new_data.view(PeriodIndex)
         result.name = self.name
@@ -783,7 +784,7 @@ class PeriodIndex(Int64Index):
         if mult != 1:
             raise ValueError('Only mult == 1 supported')
 
-        new_data = lib.periodarr_to_dt64arr(new_data.values, base)
+        new_data = plib.periodarr_to_dt64arr(new_data.values, base)
         return DatetimeIndex(new_data, freq='infer')
 
     def shift(self, n):
@@ -1043,7 +1044,7 @@ def _range_from_fields(year=None, month=None, quarter=None, day=None,
         year, quarter = _make_field_arrays(year, quarter)
         for y, q in zip(year, quarter):
             y, m = _quarter_to_myear(y, q, freq)
-            val = lib.period_ordinal(y, m, 1, 1, 1, 1, base)
+            val = plib.period_ordinal(y, m, 1, 1, 1, 1, base)
             ordinals.append(val)
     else:
         base, mult = _gfc(freq)
@@ -1052,7 +1053,7 @@ def _range_from_fields(year=None, month=None, quarter=None, day=None,
 
         arrays = _make_field_arrays(year, month, day, hour, minute, second)
         for y, m, d, h, m, s in zip(*arrays):
-            ordinals.append(lib.period_ordinal(y, m, d, h, m, s, base))
+            ordinals.append(plib.period_ordinal(y, m, d, h, m, s, base))
 
     return np.array(ordinals, dtype=np.int64), freq
 
@@ -1078,8 +1079,7 @@ def _ordinal_from_fields(year, month, quarter, day, hour, minute,
     if quarter is not None:
         year, month = _quarter_to_myear(year, quarter, freq)
 
-    return lib.period_ordinal(year, month, day, hour,
-                              minute, second, base)
+    return plib.period_ordinal(year, month, day, hour, minute, second, base)
 
 def _quarter_to_myear(year, quarter, freq):
     if quarter is not None:
diff --git a/pandas/tseries/tests/test_period.py b/pandas/tseries/tests/test_period.py
index 7b779cd9d..b28486df1 100644
--- a/pandas/tseries/tests/test_period.py
+++ b/pandas/tseries/tests/test_period.py
@@ -1457,28 +1457,29 @@ class TestPeriodIndex(TestCase):
         # year, month, day, hour, minute
         # second, weekofyear, week, dayofweek, weekday, dayofyear, quarter
         # qyear
-        pi = PeriodIndex(freq='A', start='1/1/2001', end='12/1/2009')
+        pi = PeriodIndex(freq='A', start='1/1/2001', end='12/1/2005')
         self._check_all_fields(pi)
 
-        pi = PeriodIndex(freq='Q', start='1/1/2001', end='12/1/2003')
+        pi = PeriodIndex(freq='Q', start='1/1/2001', end='12/1/2002')
         self._check_all_fields(pi)
 
         pi = PeriodIndex(freq='M', start='1/1/2001', end='1/1/2002')
         self._check_all_fields(pi)
 
-        pi = PeriodIndex(freq='D', start='12/1/2001', end='1/1/2002')
+        pi = PeriodIndex(freq='D', start='12/1/2001', end='6/1/2001')
         self._check_all_fields(pi)
 
-        pi = PeriodIndex(freq='B', start='12/1/2001', end='1/1/2002')
+        pi = PeriodIndex(freq='B', start='12/1/2001', end='6/1/2001')
         self._check_all_fields(pi)
 
         pi = PeriodIndex(freq='H', start='12/31/2001', end='1/1/2002 23:00')
         self._check_all_fields(pi)
 
-        pi = PeriodIndex(freq='Min', start='12/31/2001', end='1/1/2002 00:59')
+        pi = PeriodIndex(freq='Min', start='12/31/2001', end='1/1/2002 00:20')
         self._check_all_fields(pi)
 
-        pi = PeriodIndex(freq='S', start='12/31/2001', end='1/1/2001 00:00:01')
+        pi = PeriodIndex(freq='S', start='12/31/2001 00:00:00',
+                         end='12/31/2001 00:05:00')
         self._check_all_fields(pi)
 
         end_intv = Period('2006-12-31', 'W')
@@ -1489,13 +1490,14 @@ class TestPeriodIndex(TestCase):
         fields = ['year', 'month', 'day', 'hour', 'minute',
                   'second', 'weekofyear', 'week', 'dayofweek',
                   'weekday', 'dayofyear', 'quarter', 'qyear']
-        [self._check_field(periodindex, x) for x in fields]
 
-    def _check_field(self, periodindex, fieldname):
-        field_idx = getattr(periodindex, fieldname)
-        assert_equal(len(periodindex), len(field_idx))
-        for x, val in zip(periodindex, field_idx):
-            assert_equal(getattr(x, fieldname), val)
+        periods = list(periodindex)
+
+        for field in fields:
+            field_idx = getattr(periodindex, field)
+            assert_equal(len(periodindex), len(field_idx))
+            for x, val in zip(periods, field_idx):
+                assert_equal(getattr(x, field), val)
 
     def test_is_full(self):
         index = PeriodIndex([2005, 2007, 2009], freq='A')
diff --git a/setup.py b/setup.py
index 6a0b2b8d1..f35921d1f 100755
--- a/setup.py
+++ b/setup.py
@@ -363,7 +363,6 @@ algos_ext = Extension('pandas._algos',
 lib_ext = Extension('pandas.lib',
                     depends=tseries_depends + ['pandas/src/numpy_helper.h'],
                     sources=[srcpath('tseries', suffix=suffix),
-                             'pandas/src/period.c',
                              'pandas/src/datetime/np_datetime.c',
                              'pandas/src/datetime/np_datetime_strings.c'],
                     include_dirs=[np.get_include()],
@@ -371,6 +370,13 @@ lib_ext = Extension('pandas.lib',
                     # extra_compile_args=['-Wconversion']
                     )
 
+period_ext = Extension('pandas._period',
+                       depends=tseries_depends + ['pandas/src/numpy_helper.h'],
+                       sources=[srcpath('plib', suffix=suffix),
+                                'pandas/src/datetime/np_datetime.c',
+                                'pandas/src/period.c'],
+                       include_dirs=[np.get_include()])
+
 
 sparse_ext = Extension('pandas._sparse',
                        sources=[srcpath('sparse', suffix=suffix)],
@@ -391,9 +397,7 @@ ujson_ext = Extension('pandas._ujson',
                       )
 
 sandbox_ext = Extension('pandas._sandbox',
-                        sources=[srcpath('sandbox', suffix=suffix),
-                                 'pandas/src/period.c',
-                                 ],
+                        sources=[srcpath('sandbox', suffix=suffix)],
                         include_dirs=[np.get_include()])
 
 cppsandbox_ext = Extension('pandas._cppsandbox',
@@ -401,7 +405,7 @@ cppsandbox_ext = Extension('pandas._cppsandbox',
                            sources=[srcpath('cppsandbox', suffix=suffix)],
                            include_dirs=[np.get_include()])
 
-extensions = [algos_ext, lib_ext, sparse_ext, ujson_ext]
+extensions = [algos_ext, lib_ext, period_ext, sparse_ext, ujson_ext]
 
 if not ISRELEASED:
     extensions.extend([sandbox_ext])

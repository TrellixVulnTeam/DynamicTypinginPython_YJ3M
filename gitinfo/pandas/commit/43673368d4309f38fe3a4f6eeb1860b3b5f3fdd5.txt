commit 43673368d4309f38fe3a4f6eeb1860b3b5f3fdd5
Author: jreback <jeff@reback.net>
Date:   Fri Dec 28 11:48:06 2012 -0500

    BUG: fixed old version compatibility warnings
         added copy_to method to allow file upgrades to new version

diff --git a/RELEASE.rst b/RELEASE.rst
index ee5bd0619..542ea12e9 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -50,6 +50,7 @@ pandas 0.10.1
       to do multiple-table append/selection
     - added support for datetime64 in columns
     - added method ``unique`` to select the unique values in an indexable or data column
+    - added method ``copy_to`` to copy an existing store (and possibly upgrade)
   - Add ``logx`` option to DataFrame/Series.plot (GH2327_, #2565)
   - Support reading gzipped data from file-like object
   - ``pivot_table`` aggfunc can be anything used in GroupBy.aggregate (GH2643_)
diff --git a/doc/source/io.rst b/doc/source/io.rst
index bf9c91390..c54dab290 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -1372,11 +1372,31 @@ Notes & Caveats
 Compatibility
 ~~~~~~~~~~~~~
 
-0.10 of ``HDFStore`` is backwards compatible for reading tables created in a prior version of pandas,
+0.10.1 of ``HDFStore`` is backwards compatible for reading tables created in a prior version of pandas
 however, query terms using the prior (undocumented) methodology are unsupported. ``HDFStore`` will issue a warning if you try to use a prior-version format file. You must read in the entire
 file and write it out using the new format to take advantage of the updates. The group attribute ``pandas_version`` contains the version information.
 
 
+     .. ipython:: python
+
+        # a legacy store
+	import os
+        legacy_store = HDFStore('legacy_0.10.h5', 'r')
+        legacy_store
+
+        # copy (and return the new handle)
+	new_store = legacy_store.copy_to('store_new.h5')
+	new_store
+        new_store.close()
+
+     .. ipython:: python
+        :suppress:
+ 
+        legacy_store.close()
+        import os
+        os.remove('store_new.h5')
+     
+
 Performance
 ~~~~~~~~~~~
 
diff --git a/doc/source/v0.10.1.txt b/doc/source/v0.10.1.txt
index b8137fda5..2eb40b282 100644
--- a/doc/source/v0.10.1.txt
+++ b/doc/source/v0.10.1.txt
@@ -17,6 +17,9 @@ New features
 HDFStore
 ~~~~~~~~
 
+You may need to upgrade your existing data files. Please visit the **compatibility** section in the main docs.
+
+
 .. ipython:: python
    :suppress:
    :okexcept:
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 1469620ea..fec80a185 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -37,9 +37,11 @@ from contextlib import contextmanager
 # versioning attribute
 _version = '0.10.1'
 
-
-class IncompatibilityWarning(Warning):
-    pass
+class IncompatibilityWarning(Warning): pass
+incompatibility_doc = """
+where criteria is being ignored as this version [%s] is too old (or not-defined),
+read the file in and write it out to a new file to upgrade (with the copy_to method)
+"""
 
 # reading and writing the full object in one go
 _TYPE_MAP = {
@@ -259,6 +261,15 @@ class HDFStore(object):
         """
         return [n._v_pathname for n in self.groups()]
 
+    def items(self):
+        """
+        iterate on key->group
+        """
+        for g in self.groups():
+            yield g._v_pathname, g
+
+    iteritems = items
+
     def open(self, mode='a', warn=True):
         """
         Open the file in the specified mode
@@ -619,6 +630,17 @@ class HDFStore(object):
         t.infer_axes()
         return t
 
+    def copy_to(self, file):
+        """ copy the existing store to a new file, upgrading in place """
+        new_store = HDFStore(file, mode = 'w')
+        for k, g in self.iteritems():
+            data = self.select(k)
+            if _is_table_type(g):
+                new_store.append(k,data)
+            else:
+                new_store.put(k,data)
+        return new_store
+
     ###### private methods ######
 
     def _get_handler(self, op, kind):
@@ -1492,6 +1514,10 @@ class Table(object):
         self.nan_rep = None
         self.selection = None
 
+    @property
+    def is_old_version(self):
+        return self.version[0] <= 0 and self.version[1] <= 10 and self.version[2] < 1
+
     @property
     def table_type_short(self):
         return self.table_type.split('_')[0]
@@ -1503,14 +1529,18 @@ class Table(object):
     def __repr__(self):
         """ return a pretty representatgion of myself """
         self.infer_axes()
-        dc = ",dc->[%s]" % ','.join(
-            self.data_columns) if len(self.data_columns) else ''
-        return "%s (typ->%s,nrows->%s,indexers->[%s]%s)" % (self.pandas_type,
-                                                            self.table_type_short,
-                                                            self.nrows,
-                                                            ','.join([a.name for a in self.index_axes]),
-                                                            dc)
-
+        dc = ",dc->[%s]" % ','.join(self.data_columns) if len(self.data_columns) else ''
+        ver = ''
+        if self.is_old_version:
+            ver = "[%s]" % '.'.join([ str(x) for x in self.version ])
+
+        return "%s%s (typ->%s,nrows->%s,indexers->[%s]%s)" % (self.pandas_type,
+                                                              ver,
+                                                              self.table_type_short,
+                                                              self.nrows,
+                                                              ','.join([ a.name for a in self.index_axes ]),
+                                                              dc)
+    
     __str__ = __repr__
 
     def copy(self):
@@ -1621,8 +1651,8 @@ class Table(object):
         """ are we trying to operate on an old version? """
         if where is not None:
             if self.version[0] <= 0 and self.version[1] <= 10 and self.version[2] < 1:
-                warnings.warn("where criteria is being ignored as we this version is too old (or not-defined) [%s]"
-                    % '.'.join([str(x) for x in self.version]), IncompatibilityWarning)
+                ws = incompatibility_doc % '.'.join([ str(x) for x in self.version ])
+                warnings.warn(ws, IncompatibilityWarning)
 
     @property
     def indexables(self):
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index f2490505b..b790d3270 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -1735,6 +1735,26 @@ class TestHDFStore(unittest.TestCase):
             store.select(k)
         store.close()
 
+    def test_legacy_copy_to(self):
+        pth = curpath()
+        try:
+            import os
+            store = HDFStore(os.path.join(pth, 'legacy_0.10.h5'), 'r')
+            import tempfile
+            tmp = tempfile.mkstemp()[1]
+            tstore = store.copy_to(tmp)
+            
+            # the tmp store
+            for k in tstore.keys():
+                self.assert_(k in store)
+        except:
+            pass
+        finally:
+            store.close()
+            tstore.close()
+            import os
+            os.remove(tmp)
+
     def test_legacy_table_write(self):
         raise nose.SkipTest
         # legacy table types

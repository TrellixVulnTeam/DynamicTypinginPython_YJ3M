commit b94186d4c58ee055656a84f55618be537db0095a
Author: Peter Csizsek <peter.csizsek@gmail.com>
Date:   Thu Feb 23 08:23:11 2017 -0500

    BUG: The roll_quantile function now throws an exception instead of causing a segfault when quantile is out of range
    
    closes #15463
    
    Author: Peter Csizsek <peter.csizsek@gmail.com>
    
    Closes #15476 from csizsek/fix-rolling-quantile-segfault and squashes the following commits:
    
    e31e5be [Peter Csizsek] Correctly catching exception in the test for Rolling.quantile.
    4eea34a [Peter Csizsek] Refactored and moved exception throwing test to a new function for Rolling.quantile().
    8b1e020 [Peter Csizsek] Added a note about the Rolling.quantile bug fix to the changelog.
    f39b122 [Peter Csizsek] Added a new test case to roll_quantile_test to trigger a TypeError when called with a string.
    f736ca2 [Peter Csizsek] The roll_quantile function in window.pyx now raises a ValueError when the quantile value is not in [0.0, 1.0]

diff --git a/doc/source/whatsnew/v0.20.0.txt b/doc/source/whatsnew/v0.20.0.txt
index e65276fe5..fa24c973a 100644
--- a/doc/source/whatsnew/v0.20.0.txt
+++ b/doc/source/whatsnew/v0.20.0.txt
@@ -539,7 +539,7 @@ Bug Fixes
 - Bug in using ``__deepcopy__`` on empty NDFrame objects (:issue:`15370`)
 - Bug in ``DataFrame.loc`` with indexing a ``MultiIndex`` with a ``Series`` indexer (:issue:`14730`, :issue:`15424`)
 - Bug in ``DataFrame.loc`` with indexing a ``MultiIndex`` with a numpy array (:issue:`15434`)
-
+- Bug in ``Rolling.quantile`` function that caused a segmentation fault when called with a quantile value outside of the range [0, 1] (:issue:`15463`)
 
 
 - Bug in the display of ``.info()`` where a qualifier (+) would always be displayed with a ``MultiIndex`` that contains only non-strings (:issue:`15245`)
diff --git a/pandas/tests/test_window.py b/pandas/tests/test_window.py
index 452e8999a..3f2973a98 100644
--- a/pandas/tests/test_window.py
+++ b/pandas/tests/test_window.py
@@ -1063,7 +1063,7 @@ class TestMoments(Base):
                               window=3, min_periods=5)
 
     def test_rolling_quantile(self):
-        qs = [.1, .5, .9]
+        qs = [0.0, .1, .5, .9, 1.0]
 
         def scoreatpercentile(a, per):
             values = np.sort(a, axis=0)
@@ -1084,6 +1084,18 @@ class TestMoments(Base):
 
             self._check_moment_func(f, alt, name='quantile', quantile=q)
 
+    def test_rolling_quantile_param(self):
+        ser = Series([0.0, .1, .5, .9, 1.0])
+
+        with self.assertRaises(ValueError):
+            ser.rolling(3).quantile(-0.1)
+
+        with self.assertRaises(ValueError):
+            ser.rolling(3).quantile(10.0)
+
+        with self.assertRaises(TypeError):
+            ser.rolling(3).quantile('foo')
+
     def test_rolling_apply(self):
         # suppress warnings about empty slices, as we are deliberately testing
         # with a 0-length Series
diff --git a/pandas/window.pyx b/pandas/window.pyx
index 8235d68e2..005d42c9f 100644
--- a/pandas/window.pyx
+++ b/pandas/window.pyx
@@ -134,8 +134,8 @@ cdef class WindowIndexer:
         bint is_variable
 
     def get_data(self):
-        return (self.start, self.end, <int64_t>self.N, 
-                <int64_t>self.win, <int64_t>self.minp, 
+        return (self.start, self.end, <int64_t>self.N,
+                <int64_t>self.win, <int64_t>self.minp,
                 self.is_variable)
 
 
@@ -1285,6 +1285,9 @@ def roll_quantile(ndarray[float64_t, cast=True] input, int64_t win,
         ndarray[int64_t] start, end
         ndarray[double_t] output
 
+    if quantile < 0.0 or quantile > 1.0:
+        raise ValueError("quantile value {0} not in [0, 1]".format(quantile))
+
     # we use the Fixed/Variable Indexer here as the
     # actual skiplist ops outweigh any window computation costs
     start, end, N, win, minp, is_variable = get_window_indexer(

commit 0d9f4d955af2219157399906229c0d7875384ba2
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Jan 13 16:15:57 2012 -0500

    ENH: test coverage and a bugfix in concat

diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 38508c068..89de475fc 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -462,7 +462,7 @@ class GroupBy(object):
         raise NotImplementedError
 
     def _wrap_frames(self, keys, values, not_indexed_same=False):
-        from pandas.tools.merge import concat, _concat_frames_hierarchical
+        from pandas.tools.merge import concat
 
         if not_indexed_same:
             group_keys = keys
@@ -574,7 +574,6 @@ class Grouping(object):
                 self._was_factor = True
                 self._labels = inds
                 self._group_index = level_index
-                self._counts = lib.group_count(inds, len(level_index))
                 self.grouper = level_values
         else:
             # no level passed
@@ -626,11 +625,6 @@ class Grouping(object):
     def group_index(self):
         if self._group_index is None:
             self._make_labels()
-
-            # ids = self.ids
-            # values = np.arange(len(self.ids), dtype='O')
-            # self._group_index = Index(lib.lookup_values(values, ids),
-            #                           name=self.name)
         return self._group_index
 
     def _make_labels(self):
@@ -1332,25 +1326,6 @@ def decons_group_index(comp_labels, shape):
         factor *= shape[i]
     return label_list[::-1]
 
-def test_decons():
-    def testit(label_list, shape):
-        group_index = get_group_index(label_list, shape)
-        label_list2 = decons_group_index(group_index, shape)
-
-        for a, b in zip(label_list, label_list2):
-            assert(np.array_equal(a, b))
-
-    shape = (4, 5, 6)
-    label_list = [np.tile([0, 1, 2, 3, 0, 1, 2, 3], 100),
-                  np.tile([0, 2, 4, 3, 0, 1, 2, 3], 100),
-                  np.tile([5, 1, 0, 2, 3, 0, 5, 4], 100)]
-    testit(label_list, shape)
-
-    shape = (10000, 10000)
-    label_list = [np.tile(np.arange(10000), 5),
-                  np.tile(np.arange(10000), 5)]
-    testit(label_list, shape)
-
 def _aggregate_series_fast(obj, func, group_index, ngroups):
     if obj.index._has_complex_internals:
         raise TypeError('Incompatible index for Cython grouper')
@@ -1426,11 +1401,11 @@ def _groupby_indices(values):
     return lib.groupby_indices(values)
 
 def _ensure_platform_int(labels):
-    if labels.dtype != np.int_:
+    if labels.dtype != np.int_:  # pragma: no cover
         labels = labels.astype(np.int_)
     return labels
 
 def _ensure_int64(labels):
-    if labels.dtype != np.int64:
+    if labels.dtype != np.int64:  # pragma: no cover
         labels = labels.astype(np.int64)
     return labels
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 082dc3b5f..ef606919a 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -324,9 +324,6 @@ class _SeriesIndexer(_NDFrameIndexer):
     >>> ts.ix[date1:date2] = 0
     """
 
-    def _get_integer(self, indexer, axis=0):
-        return self.obj._get_values(indexer)
-
     def _get_label(self, key, axis=0):
         return self.obj[key]
 
@@ -383,16 +380,6 @@ def _is_label_like(key):
 def _is_list_like(obj):
     return np.iterable(obj) and not isinstance(obj, basestring)
 
-def _is_label_slice(labels, obj):
-    def crit(x):
-        try:
-            _ = labels.get_loc(x)
-            return False
-        except KeyError:
-            return com.is_integer(x) or x is None
-
-    return not crit(obj.start) or not crit(obj.stop)
-
 def _need_slice(obj):
     return (obj.start is not None or
             obj.stop is not None or
diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index b00e1ec95..c9ba4f7cf 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -14,7 +14,7 @@ except ImportError:  # pragma: no cover
 def _bottleneck_switch(bn_name, alt, **kwargs):
     try:
         bn_func = getattr(bn, bn_name)
-    except NameError:
+    except NameError:  # pragma: no cover
         bn_func = None
     def f(values, axis=None, skipna=True):
         try:
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index 7534c8710..ca6a90c0d 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -2,6 +2,7 @@ from cStringIO import StringIO
 from datetime import datetime
 import csv
 import os
+import sys
 import re
 import unittest
 
@@ -513,6 +514,47 @@ c   1   2   3   4
         self.assert_(expected.index.name is None)
         assert_frame_equal(df, expected)
 
+    def test_verbose_import(self):
+        text = """a,b,c,d
+one,1,2,3
+one,1,2,3
+,1,2,3
+one,1,2,3
+,1,2,3
+,1,2,3
+one,1,2,3
+two,1,2,3"""
+
+        buf = StringIO()
+        sys.stdout = buf
+
+        try:
+            # it works!
+            df = read_csv(StringIO(text), verbose=True)
+            self.assert_(buf.getvalue() == 'Filled 3 NA values in column a\n')
+        finally:
+            sys.stdout = sys.__stdout__
+
+        buf = StringIO()
+        sys.stdout = buf
+
+        text = """a,b,c,d
+one,1,2,3
+two,1,2,3
+three,1,2,3
+four,1,2,3
+five,1,2,3
+,1,2,3
+seven,1,2,3
+eight,1,2,3"""
+
+        try:
+            # it works!
+            df = read_csv(StringIO(text), verbose=True, index_col=0)
+            self.assert_(buf.getvalue() == 'Found 1 NA values in the index\n')
+        finally:
+            sys.stdout = sys.__stdout__
+
 class TestParseSQL(unittest.TestCase):
 
     def test_convert_sql_column_floats(self):
diff --git a/pandas/sparse/tests/test_array.py b/pandas/sparse/tests/test_array.py
index 65294ab97..600ef241d 100644
--- a/pandas/sparse/tests/test_array.py
+++ b/pandas/sparse/tests/test_array.py
@@ -61,6 +61,14 @@ class TestSparseArray(unittest.TestCase):
         assert_almost_equal(self.arr.to_dense(), self.arr_data)
         assert_almost_equal(self.arr.sp_values, np.asarray(self.arr))
 
+    def test_getitem(self):
+        def _checkit(i):
+            assert_almost_equal(self.arr[i], self.arr.values[i])
+
+        for i in range(len(self.arr)):
+            _checkit(i)
+            _checkit(-i)
+
     def test_getslice(self):
         result = self.arr[:-3]
         exp = SparseArray(self.arr.values[:-3])
diff --git a/pandas/tests/test_groupby.py b/pandas/tests/test_groupby.py
index 3bd79652d..6ebd9e739 100644
--- a/pandas/tests/test_groupby.py
+++ b/pandas/tests/test_groupby.py
@@ -883,6 +883,14 @@ class TestGroupBy(unittest.TestCase):
             assert_almost_equal(the_counts,
                                 other_counts.reindex(the_counts.index))
 
+        # compute counts when group by level
+        grouped = self.mframe.groupby(level=0)
+        ping = grouped.groupings[0]
+        the_counts = grouped.size()
+        other_counts = Series(ping.counts, ping.group_index)
+        assert_almost_equal(the_counts,
+                            other_counts.reindex(the_counts.index))
+
     def test_groupby_level(self):
         frame = self.mframe
         deleveled = frame.reset_index()
@@ -1245,11 +1253,27 @@ class TestPanelGroupBy(unittest.TestCase):
         self.assert_(np.array_equal(agged.minor_axis, [0, 1]))
 
 
-class TestAggregate(unittest.TestCase):
-    setUp = commonSetUp
+def test_decons():
+    from pandas.core.groupby import decons_group_index, get_group_index
+
+    def testit(label_list, shape):
+        group_index = get_group_index(label_list, shape)
+        label_list2 = decons_group_index(group_index, shape)
+
+        for a, b in zip(label_list, label_list2):
+            assert(np.array_equal(a, b))
+
+    shape = (4, 5, 6)
+    label_list = [np.tile([0, 1, 2, 3, 0, 1, 2, 3], 100),
+                  np.tile([0, 2, 4, 3, 0, 1, 2, 3], 100),
+                  np.tile([5, 1, 0, 2, 3, 0, 5, 4], 100)]
+    testit(label_list, shape)
+
+    shape = (10000, 10000)
+    label_list = [np.tile(np.arange(10000), 5),
+                  np.tile(np.arange(10000), 5)]
+    testit(label_list, shape)
 
-class TestTransform(unittest.TestCase):
-    setUp = commonSetUp
 
 if __name__ == '__main__':
     import nose
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index 472e80c38..4fe12df73 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -333,6 +333,10 @@ class TestIndex(unittest.TestCase):
         self.assertEquals(idx.slice_locs(end=8), (0, 6))
         self.assertEquals(idx.slice_locs(end=9), (0, 7))
 
+        idx2 = idx[::-1]
+        self.assertRaises(KeyError, idx2.slice_locs, 8, 2)
+        self.assertRaises(KeyError, idx2.slice_locs, 7, 3)
+
     def test_drop(self):
         n = len(self.strIndex)
 
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 875a5cb65..e88b5262d 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -472,6 +472,24 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         self.assertEqual(len(sl), len(sl.index))
         self.assertEqual(len(sl.index.indexMap), len(sl.index))
 
+    def test_basic_getitem_setitem_corner(self):
+        # invalid tuples, e.g. self.ts[:, None] vs. self.ts[:, 2]
+        self.assertRaises(Exception, self.ts.__getitem__,
+                          (slice(None, None), 2))
+        self.assertRaises(Exception, self.ts.__setitem__,
+                          (slice(None, None), 2), 2)
+
+        # weird lists. [slice(0, 5)] will work but not two slices
+        result = self.ts[[slice(None, 5)]]
+        expected = self.ts[:5]
+        assert_series_equal(result, expected)
+
+        # OK
+        self.assertRaises(Exception, self.ts.__getitem__,
+                          [5, slice(None, None)])
+        self.assertRaises(Exception, self.ts.__setitem__,
+                          [5, slice(None, None)], 2)
+
     def test_basic_getitem_with_labels(self):
         indices = self.ts.index[[5, 10, 15]]
 
@@ -903,6 +921,12 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
 
         self.assertRaises(Exception, self.ts.append, self.ts)
 
+    def test_append_many(self):
+        pieces = [self.ts[:5], self.ts[5:10], self.ts[10:]]
+
+        result = pieces[0].append(pieces[1:])
+        assert_series_equal(result, self.ts)
+
     def test_all_any(self):
         np.random.seed(12345)
         ts = tm.makeTimeSeries()
diff --git a/pandas/tools/merge.py b/pandas/tools/merge.py
index 823430e8c..a053a6b7c 100644
--- a/pandas/tools/merge.py
+++ b/pandas/tools/merge.py
@@ -865,26 +865,6 @@ class _Concatenator(object):
                                 % str(overlap))
 
 
-def _concat_frames_hierarchical(frames, keys, names, levels, axis=0):
-    if axis == 0:
-        indexes = [x.index for x in frames]
-        new_index = _make_concat_multiindex(indexes, keys, levels, names)
-        new_columns = frames[0].columns
-    else:
-        all_columns = [x.columns for x in frames]
-        new_columns = _make_concat_multiindex(all_columns, keys,
-                                              levels, names)
-        new_index = frames[0].index
-
-    if frames[0]._is_mixed_type:
-        new_data = {}
-        for col in new_columns:
-            new_data[col] = np.concatenate([x[col].values for x in frames])
-        return DataFrame(new_data, index=new_index, columns=new_columns)
-    else:
-        new_values = np.concatenate([x.values for x in frames], axis=axis)
-        return DataFrame(new_values, index=new_index, columns=new_columns)
-
 def _concat_indexes(indexes):
     return indexes[0].append(indexes[1:])
 
@@ -898,7 +878,7 @@ def _make_concat_multiindex(indexes, keys, levels=None, names=None):
     else:
         zipped = zip(*keys)
         if names is None:
-            names = [None] * len(keys)
+            names = [None] * len(zipped)
 
     if levels is None:
         if single_level:
diff --git a/pandas/tools/tests/test_merge.py b/pandas/tools/tests/test_merge.py
index 8a2605c09..54baecff0 100644
--- a/pandas/tools/tests/test_merge.py
+++ b/pandas/tools/tests/test_merge.py
@@ -857,6 +857,14 @@ class TestConcatenate(unittest.TestCase):
 
         assert_frame_equal(result, expected)
 
+        # no names
+
+        result = concat([df, df2, df, df2],
+                        keys=[('foo', 'one'), ('foo', 'two'),
+                              ('baz', 'one'), ('baz', 'two')],
+                        levels=levels)
+        self.assertEqual(result.index.names, [None] * 3)
+
     def test_crossed_dtypes_weird_corner(self):
         columns = ['A', 'B', 'C', 'D']
         df1 = DataFrame({'A' : np.array([1, 2, 3, 4], dtype='f8'),
diff --git a/pandas/util/decorators.py b/pandas/util/decorators.py
index 4c00427f0..142f1239f 100644
--- a/pandas/util/decorators.py
+++ b/pandas/util/decorators.py
@@ -1,4 +1,7 @@
+from cStringIO import StringIO
+
 from pandas._tseries import cache_readonly
+import sys
 import warnings
 
 def deprecate(name, alternative):
@@ -10,7 +13,7 @@ def deprecate(name, alternative):
     return wrapper
 
 # Substitution and Appender are derived from matplotlib.docstring (1.1.0)
-# module http://matplotlib.sourceforge.net/users/license.html 
+# module http://matplotlib.sourceforge.net/users/license.html
 
 class Substitution(object):
     """
@@ -100,3 +103,13 @@ def indent(text, indents=1):
         return ''
     jointext = ''.join(['\n'] + ['    '] * indents)
     return jointext.join(text.split('\n'))
+
+def suppress_stdout(f):
+    def wrapped(*args, **kwargs):
+        try:
+            sys.stdout = StringIO()
+            f(*args, **kwargs)
+        finally:
+            sys.stdout = sys.__stdout__
+
+    return wrapped

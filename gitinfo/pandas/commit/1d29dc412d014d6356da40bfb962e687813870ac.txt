commit 1d29dc412d014d6356da40bfb962e687813870ac
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Jul 10 17:03:58 2018 -0700

    [CLN] cy cleanup, de-duplication (#21826)

diff --git a/pandas/_libs/index.pyx b/pandas/_libs/index.pyx
index 5b41057c5..e408e02b9 100644
--- a/pandas/_libs/index.pyx
+++ b/pandas/_libs/index.pyx
@@ -43,9 +43,9 @@ cdef inline bint is_definitely_invalid_key(object val):
             or PyList_Check(val) or hasattr(val, '_data'))
 
 
-def get_value_at(ndarray arr, object loc):
+cpdef get_value_at(ndarray arr, object loc, object tz=None):
     if arr.descr.type_num == NPY_DATETIME:
-        return Timestamp(util.get_value_at(arr, loc))
+        return Timestamp(util.get_value_at(arr, loc), tz=tz)
     elif arr.descr.type_num == NPY_TIMEDELTA:
         return Timedelta(util.get_value_at(arr, loc))
     return util.get_value_at(arr, loc)
@@ -68,12 +68,7 @@ cpdef object get_value_box(ndarray arr, object loc):
     if i >= sz or sz == 0 or i < 0:
         raise IndexError('index out of bounds')
 
-    if arr.descr.type_num == NPY_DATETIME:
-        return Timestamp(util.get_value_1d(arr, i))
-    elif arr.descr.type_num == NPY_TIMEDELTA:
-        return Timedelta(util.get_value_1d(arr, i))
-    else:
-        return util.get_value_1d(arr, i)
+    return get_value_at(arr, i, tz=None)
 
 
 # Don't populate hash tables in monotonic indexes larger than this
@@ -114,11 +109,7 @@ cdef class IndexEngine:
         if PySlice_Check(loc) or cnp.PyArray_Check(loc):
             return arr[loc]
         else:
-            if arr.descr.type_num == NPY_DATETIME:
-                return Timestamp(util.get_value_at(arr, loc), tz=tz)
-            elif arr.descr.type_num == NPY_TIMEDELTA:
-                return Timedelta(util.get_value_at(arr, loc))
-            return util.get_value_at(arr, loc)
+            return get_value_at(arr, loc, tz=tz)
 
     cpdef set_value(self, ndarray arr, object key, object value):
         """
diff --git a/pandas/_libs/indexing.pyx b/pandas/_libs/indexing.pyx
index fb707a3c3..c680706b7 100644
--- a/pandas/_libs/indexing.pyx
+++ b/pandas/_libs/indexing.pyx
@@ -1,10 +1,10 @@
 # cython: profile=False
 
 cdef class _NDFrameIndexerBase:
-    '''
+    """
     A base class for _NDFrameIndexer for fast instantiation and attribute
     access.
-    '''
+    """
     cdef public object obj, name, _ndim
 
     def __init__(self, name, obj):
diff --git a/pandas/_libs/tslibs/ccalendar.pyx b/pandas/_libs/tslibs/ccalendar.pyx
index 0901d474d..12d35f7ce 100644
--- a/pandas/_libs/tslibs/ccalendar.pyx
+++ b/pandas/_libs/tslibs/ccalendar.pyx
@@ -8,9 +8,7 @@ Cython implementations of functions resembling the stdlib calendar module
 cimport cython
 from cython cimport Py_ssize_t
 
-cimport numpy as cnp
 from numpy cimport int64_t, int32_t
-cnp.import_array()
 
 from locale import LC_TIME
 from strptime import LocaleTime
diff --git a/pandas/_libs/tslibs/conversion.pyx b/pandas/_libs/tslibs/conversion.pyx
index 9964ca084..a3b7d6c59 100644
--- a/pandas/_libs/tslibs/conversion.pyx
+++ b/pandas/_libs/tslibs/conversion.pyx
@@ -556,6 +556,9 @@ cdef inline void localize_tso(_TSObject obj, tzinfo tz):
         elif treat_tz_as_dateutil(tz):
             dt64_to_dtstruct(obj.value + deltas[pos], &obj.dts)
         else:
+            # TODO: this case is never reached in the tests, but get_dst_info
+            #   has a path that returns typ = None and empty deltas.
+            #   --> Is this path possible?
             pass
 
     obj.tzinfo = tz
@@ -1145,10 +1148,7 @@ cdef ndarray[int64_t] _normalize_local(ndarray[int64_t] stamps, object tz):
         # Adjust datetime64 timestamp, recompute datetimestruct
         trans, deltas, typ = get_dst_info(tz)
 
-        _pos = trans.searchsorted(stamps, side='right') - 1
-        if _pos.dtype != np.int64:
-            _pos = _pos.astype(np.int64)
-        pos = _pos
+        pos = trans.searchsorted(stamps, side='right') - 1
 
         # statictzinfo
         if typ not in ['pytz', 'dateutil']:
diff --git a/pandas/_libs/tslibs/period.pyx b/pandas/_libs/tslibs/period.pyx
index 21a025464..1796a764a 100644
--- a/pandas/_libs/tslibs/period.pyx
+++ b/pandas/_libs/tslibs/period.pyx
@@ -960,10 +960,7 @@ cdef ndarray[int64_t] localize_dt64arr_to_period(ndarray[int64_t] stamps,
         # Adjust datetime64 timestamp, recompute datetimestruct
         trans, deltas, typ = get_dst_info(tz)
 
-        _pos = trans.searchsorted(stamps, side='right') - 1
-        if _pos.dtype != np.int64:
-            _pos = _pos.astype(np.int64)
-        pos = _pos
+        pos = trans.searchsorted(stamps, side='right') - 1
 
         # statictzinfo
         if typ not in ['pytz', 'dateutil']:
diff --git a/pandas/_libs/tslibs/resolution.pyx b/pandas/_libs/tslibs/resolution.pyx
index c10e10808..a0be630aa 100644
--- a/pandas/_libs/tslibs/resolution.pyx
+++ b/pandas/_libs/tslibs/resolution.pyx
@@ -101,10 +101,7 @@ cdef _reso_local(ndarray[int64_t] stamps, object tz):
         # Adjust datetime64 timestamp, recompute datetimestruct
         trans, deltas, typ = get_dst_info(tz)
 
-        _pos = trans.searchsorted(stamps, side='right') - 1
-        if _pos.dtype != np.int64:
-            _pos = _pos.astype(np.int64)
-        pos = _pos
+        pos = trans.searchsorted(stamps, side='right') - 1
 
         # statictzinfo
         if typ not in ['pytz', 'dateutil']:
diff --git a/pandas/_libs/tslibs/timezones.pyx b/pandas/_libs/tslibs/timezones.pyx
index 74fadbdb6..b3fab83fe 100644
--- a/pandas/_libs/tslibs/timezones.pyx
+++ b/pandas/_libs/tslibs/timezones.pyx
@@ -188,7 +188,7 @@ cdef object get_utc_trans_times_from_dateutil_tz(object tz):
     return new_trans
 
 
-cpdef ndarray unbox_utcoffsets(object transinfo):
+cpdef ndarray[int64_t, ndim=1] unbox_utcoffsets(object transinfo):
     cdef:
         Py_ssize_t i, sz
         ndarray[int64_t] arr
@@ -216,6 +216,8 @@ cdef object get_dst_info(object tz):
     """
     cache_key = tz_cache_key(tz)
     if cache_key is None:
+        # e.g. pytz.FixedOffset, matplotlib.dates._UTC,
+        # psycopg2.tz.FixedOffsetTimezone
         num = int(get_utcoffset(tz, None).total_seconds()) * 1000000000
         return (np.array([NPY_NAT + 1], dtype=np.int64),
                 np.array([num], dtype=np.int64),

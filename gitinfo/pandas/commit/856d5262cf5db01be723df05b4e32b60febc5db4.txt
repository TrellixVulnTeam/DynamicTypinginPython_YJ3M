commit 856d5262cf5db01be723df05b4e32b60febc5db4
Author: Adam Klein <adamklein@gmail.com>
Date:   Mon Mar 5 17:20:06 2012 -0500

    ENH: enable DatetimeIndex from string array

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 101f9c582..4a1f7c531 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -61,6 +61,12 @@ def _dt_unbox_array(arr):
     unboxer = np.frompyfunc(_dt_unbox, 1, 1)
     return unboxer(arr)
 
+def _from_string_array(arr):
+    from dateutil import parser
+    p_ufunc = np.frompyfunc(lambda x: parser.parse(x), 1, 1)
+    data = p_ufunc(arr)
+    return np.array(data, dtype='M8[us]')
+
 #-------------------------------------------------------------------------------
 # Miscellaneous date functions
 
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 1d5224afe..791cf9cd5 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1076,6 +1076,7 @@ def _maybe_box_dtindex(idx):
         return Index(_dt_box_array(idx.asi8), dtype='object')
     return idx
 
+
 class DatetimeIndex(Int64Index):
     """
     Immutable ndarray of datetime64 data, represented internally as int64, and
@@ -1089,7 +1090,7 @@ class DatetimeIndex(Int64Index):
     dtype : NumPy dtype (default: M8[us])
     copy  : bool
         Make a copy of input ndarray
-    offset : string or offset object, optional
+    freq : string or pandas offset object, optional
         One of pandas date offset strings or corresponding objects
     start : starting value, datetime-like, optional
         If data is None, start is used as the start point in generating regular
@@ -1224,8 +1225,7 @@ class DatetimeIndex(Int64Index):
                 data = np.asarray(_dt_unbox_array(data), dtype='M8[us]')
 
         if issubclass(data.dtype.type, basestring):
-            raise TypeError('String dtype not supported, you may need '
-                            'to explicitly cast to datetime64')
+            subarr = datetools._from_string_array(data)
         elif issubclass(data.dtype.type, np.integer):
             subarr = np.array(data, dtype='M8[us]', copy=copy)
         elif issubclass(data.dtype.type, np.datetime64):
@@ -1233,9 +1233,11 @@ class DatetimeIndex(Int64Index):
         else:
             subarr = np.array(data, dtype='M8[us]', copy=copy)
 
+        # TODO: this is horribly inefficient. If user passes data + offset,
+        # we need to make sure data points conform. Punting on this
+
         if offset is not None:
             for i, ts in enumerate(subarr):
-                # make sure data points conform
                 if not offset.onOffset(Timestamp(ts)):
                     val = Timestamp(offset.rollforward(ts)).value
                     subarr[i] = val
diff --git a/pandas/tests/test_datetime64.py b/pandas/tests/test_datetime64.py
index f3e5dde30..08eb970f3 100644
--- a/pandas/tests/test_datetime64.py
+++ b/pandas/tests/test_datetime64.py
@@ -529,6 +529,14 @@ class TestDatetime64(unittest.TestCase):
         self.assert_((unpickled.index == dtindex).all())
         self.assertEquals(unpickled.index.offset, BDay(1))
 
+    def test_from_string_array(self):
+        arr = ['1/1/2005', '1/2/2005', 'Jan 3, 2005', '2005-01-04']
+        idx = DatetimeIndex(arr)
+        self.assertEquals(len(idx), 4)
+        self.assertEquals(idx[0], lib.Timestamp(datetime(2005,1,1)))
+
+
+
 if __name__ == '__main__':
     import nose
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],

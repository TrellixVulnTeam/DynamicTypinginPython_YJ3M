commit 2b76426b7355b609fd4fa4482039ceb5a90f21e4
Author: jreback <jeff@reback.net>
Date:   Fri Dec 14 21:41:47 2012 -0500

    BUG/DOC: ndim not currectly implementing axes that are non-default
             updated docs relating to how best to orient your data for optimal deletion/appending

diff --git a/doc/source/io.rst b/doc/source/io.rst
index 4015159e2..eac64eae1 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -1161,6 +1161,21 @@ You can create an index for a table with ``create_table_index`` after data is al
 
 Delete from a Table
 ~~~~~~~~~~~~~~~~~~~
+You can delete from a table selectively by specifying a ``where``. In deleting rows, it is important to understand the ``PyTables`` deletes rows by erasing the rows, then **moving** the following data. Thus deleting can potentially be a very expensive operation depending on the orientation of your data. This is especially true in higher dimensional objects (``Panel`` and ``Panel4D``). To get optimal deletion speed, it pays to have the dimension you are deleting be the first of the ``indexables``.
+
+Data is ordered (on the disk) in terms of the ``indexables``. Here's a simple use case. You store panel type data, with dates in the ``major_axis`` and ids in the ``minor_axis``. The data is then interleaved like this:
+
+   - date_1
+        - id_1
+        - id_2
+        -  .
+        - id_n
+   - date_2
+        - id_1
+        -  .
+        - id_n
+
+It should be clear that a delete operation on the ``major_axis`` will be fairly quick, as one chunk is removed, then the following data moved. On the other hand a delete operation on the ``minor_axis`` will be very expensive. In this case it would almost certainly be faster to rewrite the table using a ``where`` that selects all but the missing data.
 
 .. ipython:: python
 
@@ -1205,7 +1220,6 @@ Performance
      - ``AppendableTable`` which is a similiar table to past versions (this is the default).
      - ``WORMTable`` (pending implementation) - is available to faciliate very fast writing of tables that are also queryable (but CANNOT support appends)
 
-   - To delete a lot of data, it is sometimes better to erase the table and rewrite it. ``PyTables`` tends to increase the file size with deletions
    - ``Tables`` offer better performance when compressed after writing them (as opposed to turning on compression at the very beginning)
      use the pytables utilities ``ptrepack`` to rewrite the file (and also can change compression methods)
    - Duplicate rows can be written, but are filtered out in selection (with the last items being selected; thus a table is unique on major, minor pairs)
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index ce843f907..3c8478e9f 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -1381,7 +1381,7 @@ class Table(object):
         """
 
         # map axes to numbers
-        axes = set([ obj._get_axis_number(a) for a in axes ])
+        axes = [ obj._get_axis_number(a) for a in axes ]
 
         # do we have an existing table (if so, use its axes)?
         if self.infer_axes():
@@ -1395,18 +1395,15 @@ class Table(object):
             raise Exception("currenctly only support ndim-1 indexers in an AppendableTable")
 
         # create according to the new data
-        self.index_axes       = []
         self.non_index_axes   = []
 
         # create axes to index and non_index
-        j = 0
+        index_axes_map = dict()
         for i, a in enumerate(obj.axes):
 
             if i in axes:
                 name = obj._AXIS_NAMES[i]
-                self.index_axes.append(_convert_index(a).set_name(name).set_axis(i).set_pos(j))
-                j += 1
-
+                index_axes_map[i] = _convert_index(a).set_name(name).set_axis(i)
             else:
 
                 # we might be able to change the axes on the appending data if necessary
@@ -1421,6 +1418,10 @@ class Table(object):
                             append_axis = exist_axis
 
                 self.non_index_axes.append((i,append_axis))
+        
+        # set axis positions (based on the axes)
+        self.index_axes = [ index_axes_map[a].set_pos(j) for j, a in enumerate(axes) ]
+        j = len(self.index_axes)
 
         # check for column conflicts
         if validate:

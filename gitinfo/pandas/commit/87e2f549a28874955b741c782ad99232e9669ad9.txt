commit 87e2f549a28874955b741c782ad99232e9669ad9
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sat Sep 23 12:44:52 2017 -0700

    Remove unused cimports (#17585)

diff --git a/pandas/_libs/groupby.pyx b/pandas/_libs/groupby.pyx
index 9500e6853..1cb7b18fa 100644
--- a/pandas/_libs/groupby.pyx
+++ b/pandas/_libs/groupby.pyx
@@ -7,8 +7,6 @@ cimport cython
 
 cnp.import_array()
 
-cimport util
-
 from numpy cimport (ndarray,
                     double_t,
                     int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t,
diff --git a/pandas/_libs/join.pyx b/pandas/_libs/join.pyx
index 503bdda75..33c3650fa 100644
--- a/pandas/_libs/join.pyx
+++ b/pandas/_libs/join.pyx
@@ -8,8 +8,6 @@ from cython cimport Py_ssize_t
 
 np.import_array()
 
-cimport util
-
 from numpy cimport (ndarray,
                     int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t,
                     uint32_t, uint64_t, float16_t, float32_t, float64_t)
diff --git a/pandas/_libs/period.pyx b/pandas/_libs/period.pyx
index 49353f7b0..751647481 100644
--- a/pandas/_libs/period.pyx
+++ b/pandas/_libs/period.pyx
@@ -27,13 +27,12 @@ from datetime cimport (
     INT32_MIN)
 
 
-cimport util, lib
+cimport util
 from util cimport is_period_object, is_string_object
 
-from lib cimport is_null_datetimelike, is_period
-from pandas._libs import tslib, lib
-from pandas._libs.tslib import (Timedelta, Timestamp, iNaT,
-                                NaT)
+from lib cimport is_null_datetimelike
+from pandas._libs import tslib
+from pandas._libs.tslib import Timestamp, iNaT, NaT
 from tslibs.timezones cimport (
     is_utc, is_tzlocal, get_utcoffset, _get_dst_info, maybe_get_tz)
 from tslib cimport _nat_scalar_rules
@@ -485,7 +484,7 @@ def extract_freq(ndarray[object] values):
 
         try:
             # now Timestamp / NaT has freq attr
-            if is_period(p):
+            if is_period_object(p):
                 return p.freq
         except AttributeError:
             pass
@@ -728,8 +727,7 @@ cdef class _Period(object):
         return hash((self.ordinal, self.freqstr))
 
     def _add_delta(self, other):
-        if isinstance(other, (timedelta, np.timedelta64,
-                              offsets.Tick, Timedelta)):
+        if isinstance(other, (timedelta, np.timedelta64, offsets.Tick)):
             offset = frequencies.to_offset(self.freq.rule_code)
             if isinstance(offset, offsets.Tick):
                 nanos = tslib._delta_to_nanoseconds(other)
@@ -754,12 +752,11 @@ cdef class _Period(object):
     def __add__(self, other):
         if is_period_object(self):
             if isinstance(other, (timedelta, np.timedelta64,
-                                  offsets.DateOffset,
-                                  Timedelta)):
+                                  offsets.DateOffset)):
                 return self._add_delta(other)
             elif other is NaT:
                 return NaT
-            elif lib.is_integer(other):
+            elif util.is_integer_object(other):
                 ordinal = self.ordinal + other * self.freq.n
                 return Period(ordinal=ordinal, freq=self.freq)
             else:  # pragma: no cover
@@ -772,11 +769,10 @@ cdef class _Period(object):
     def __sub__(self, other):
         if is_period_object(self):
             if isinstance(other, (timedelta, np.timedelta64,
-                                  offsets.DateOffset,
-                                  Timedelta)):
+                                  offsets.DateOffset)):
                 neg_other = -other
                 return self + neg_other
-            elif lib.is_integer(other):
+            elif util.is_integer_object(other):
                 ordinal = self.ordinal - other * self.freq.n
                 return Period(ordinal=ordinal, freq=self.freq)
             elif is_period_object(other):
@@ -1159,7 +1155,7 @@ class Period(_Period):
             raise ValueError(("Only value or ordinal but not both should be "
                               "given but not both"))
         elif ordinal is not None:
-            if not lib.is_integer(ordinal):
+            if not util.is_integer_object(ordinal):
                 raise ValueError("Ordinal must be an integer")
             if freq is None:
                 raise ValueError('Must supply freq for ordinal value')
@@ -1196,8 +1192,8 @@ class Period(_Period):
         elif is_null_datetimelike(value) or value in tslib._nat_strings:
             ordinal = iNaT
 
-        elif is_string_object(value) or lib.is_integer(value):
-            if lib.is_integer(value):
+        elif is_string_object(value) or util.is_integer_object(value):
+            if util.is_integer_object(value):
                 value = str(value)
             value = value.upper()
             dt, _, reso = parse_time_string(value, freq)
diff --git a/pandas/_libs/reshape.pyx b/pandas/_libs/reshape.pyx
index d6996add3..db2e8b43d 100644
--- a/pandas/_libs/reshape.pyx
+++ b/pandas/_libs/reshape.pyx
@@ -8,8 +8,6 @@ from cython cimport Py_ssize_t
 
 np.import_array()
 
-cimport util
-
 from numpy cimport (ndarray,
                     int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t,
                     uint32_t, uint64_t, float16_t, float32_t, float64_t)
diff --git a/pandas/_libs/src/offsets.pyx b/pandas/_libs/src/offsets.pyx
deleted file mode 100644
index c963e256d..000000000
--- a/pandas/_libs/src/offsets.pyx
+++ /dev/null
@@ -1,367 +0,0 @@
-
-ctypedef enum time_res:
-    r_min = 0
-    r_microsecond
-    r_second
-    r_minute
-    r_hour
-    r_day
-    r_month
-    r_year
-    r_max = 98
-    r_invalid = 99
-
-
-cdef conversion_factor(time_res res1, time_res res2):
-    cdef:
-        time_res min_res, max_res
-        int64_t factor
-
-    min_res = min(res1, res2)
-    max_res = max(res1, res2)
-    factor = 1
-
-    if min_res == max_res:
-        return factor
-
-    while min_res < max_res:
-        if min_res < r_microsecond:
-            raise "Cannot convert from less than us"
-        elif min_res == r_microsecond:
-            factor *= 1000000
-            min_res = r_second
-        elif min_res == r_second:
-            factor *= 60
-            min_res = r_minute
-        elif min_res == r_minute:
-            factor *= 60
-            min_res = r_hour
-        elif min_res == r_hour:
-            factor *= 24
-            min_res = r_day
-        else:
-            raise "Cannot convert to month or year"
-
-    return factor
-
-# Logic to generate ranges
-# -----------------------------------------------------------------------------
-
-cdef inline int64_t weekend_adjustment(int64_t dow, int bkwd):
-    if dow > 4:                         # sat or sun?
-        if bkwd:                        # roll back 1 or 2 days
-            return (4 - dow)
-        else:                           # roll forward 2 or 1 days
-            return (7 - dow)
-    return 0
-
-cdef int64_t us_in_day = conversion_factor(r_microsecond, r_day)
-
-cdef class _Offset:
-    """
-    Base class to generate timestamps. Set the anchor, and then move offsets
-    with next & prev. Retrieve timestamp with ts attribute.
-    """
-    cdef:
-        int64_t t, dow, biz, dayoffset
-        object start
-        _TSObject ts
-
-    def __cinit__(self):
-        self.t=0
-        self.dow=0
-        self.biz=0
-        self.dayoffset=0
-
-    cpdef anchor(self, object start=None):
-        if start is not None:
-            self.start = start
-        self.ts = convert_to_tsobject(self.start, None, None)
-        self._setup()
-
-    cdef _setup(self):
-        pass
-
-    cpdef next(self):
-        pass
-
-    cpdef __next__(self):
-        """wrapper around next"""
-        return self.next()
-
-    cpdef prev(self):
-        pass
-
-    cdef int64_t _ts(self):
-        """
-        Access the current timestamp value, with a possible weekday
-        adjustment.
-        """
-        cdef int64_t adj
-
-        if self.biz != 0:
-            adj = weekend_adjustment(self.dow, self.biz < 0)
-            return self.t + us_in_day * adj
-        else:
-            return self.t
-
-    cdef int64_t _get_anchor(self):
-        """
-        Retrieve an anchor relating to current offset we're on.
-        """
-        return self.t - self.dayoffset * us_in_day
-
-    property ts:
-        def __get__(self):
-            return self._ts()
-
-cdef class YearOffset(_Offset):
-    """
-    Generate annual timestamps from provided start time; apply dayoffset to
-    each timestamp. If biz > 0, we choose the next business day at each time;
-    previous if < 0.
-
-    Parameters
-    ----------
-    dayoffset : int
-    biz : int
-    """
-    cdef:
-        int64_t y, ly
-
-    def __init__(self, int64_t dayoffset=0, int64_t biz=0, object anchor=None):
-        self.dayoffset = dayoffset
-        self.biz = biz
-
-        if anchor is not None:
-            self.anchor(anchor)
-
-    cdef _setup(self):
-        cdef _TSObject ts = self.ts
-
-        self.t = ts.value + self.dayoffset * us_in_day
-        self.y = ts.dts.year
-
-        self.ly = (ts.dts.month > 2 or
-                   ts.dts.month == 2 and ts.dts.day == 29)
-
-        if self.biz != 0:
-            self.dow = (ts_dayofweek(ts) + self.dayoffset) % 7
-
-    cpdef next(self):
-        cdef int64_t days
-
-        days = 365 + is_leapyear(self.y + self.ly)
-
-        self.t += days * us_in_day
-        self.y += 1
-
-        if self.biz != 0:
-            self.dow = (self.dow + days) % 7
-
-    cpdef prev(self):
-        cdef int64_t days
-
-        days = 365 + is_leapyear(self.y - (1 - self.ly))
-
-        self.t -= days * us_in_day
-        self.y -= 1
-
-        if self.biz != 0:
-            self.dow = (self.dow - days) % 7
-
-cdef class MonthOffset(_Offset):
-    """
-    Generate monthly timestamps from provided start time, and apply dayoffset
-    to each timestamp.  Stride to construct strided timestamps (eg quarterly).
-    If biz > 0, we choose the next business day at each time; previous if < 0.
-
-    Parameters
-    ----------
-    dayoffset : int
-    stride : int, > 0
-    biz : int
-    """
-    cdef:
-        Py_ssize_t stride, ly, m
-        int64_t y
-
-    def __init__(self, int64_t dayoffset=0, Py_ssize_t stride=1,
-                 int64_t biz=0, object anchor=None):
-        self.dayoffset = dayoffset
-        self.stride = stride
-        self.biz = biz
-
-        if stride <= 0:
-            raise ValueError("Stride must be positive")
-
-        if anchor is not None:
-            self.anchor(anchor)
-
-    cdef _setup(self):
-        cdef _TSObject ts = self.ts
-
-        self.t = ts.value + (self.dayoffset * us_in_day)
-
-        # for day counting
-        self.m = ts.dts.month - 1
-        self.y = ts.dts.year
-        self.ly = is_leapyear(self.y)
-
-        if self.biz != 0:
-            self.dow = (ts_dayofweek(ts) + self.dayoffset) % 7
-
-    cpdef next(self):
-        cdef:
-            int64_t tmp, days
-            Py_ssize_t j
-
-        days = 0
-        for j in range(0, self.stride):
-            if self.m >= 12:
-                self.m -= 12
-                self.y += 1
-                self.ly = is_leapyear(self.y)
-            days += days_per_month_table[self.ly][self.m]
-            self.m += 1
-
-        self.t += days * us_in_day
-
-        if self.biz != 0:
-            self.dow = (self.dow + days) % 7
-
-    cpdef prev(self):
-        cdef:
-            int64_t tmp, days
-            Py_ssize_t j
-
-        days = 0
-        for j in range(0, self.stride):
-            self.m -= 1
-            if self.m < 0:
-                self.m += 12
-                self.y -= 1
-                self.ly = is_leapyear(self.y)
-            days += days_per_month_table[self.ly][self.m]
-
-        self.t -= days * us_in_day
-
-        if self.biz != 0:
-            self.dow = (self.dow - days) % 7
-
-cdef class DayOfMonthOffset(_Offset):
-    """
-    Generate relative monthly timestamps from month & year of provided start
-    time. For example, fridays of the third week of each month (week=3, day=4);
-    or, thursdays of the last week of each month (week=-1, day=3).
-
-    Parameters
-    ----------
-    week : int
-    day : int, 0 to 6
-    """
-    cdef:
-        Py_ssize_t ly, m
-        int64_t y, day, week
-
-    def __init__(self, int64_t week=0, int64_t day=0, object anchor=None):
-        self.week = week
-        self.day = day
-
-        if self.day < 0 or self.day > 6:
-            raise ValueError("Day offset must be 0 to 6")
-
-        if anchor is not None:
-            self.anchor(anchor)
-
-    cdef _setup(self):
-        cdef _TSObject ts = self.ts
-
-        # rewind to beginning of month
-        self.t = ts.value - (ts.dts.day - 1) * us_in_day
-        self.dow = dayofweek(ts.dts.year, ts.dts.month, 1)
-
-        # for day counting
-        self.m = ts.dts.month - 1
-        self.y = ts.dts.year
-        self.ly = is_leapyear(self.y)
-
-    cpdef next(self):
-        cdef:
-            int64_t tmp, days
-
-        days = days_per_month_table[self.ly][self.m]
-        self.t += days * us_in_day
-        self.dow = (self.dow + days) % 7
-
-        self.m += 1
-        if self.m >= 12:
-            self.m -= 12
-            self.y += 1
-            self.ly = is_leapyear(self.y)
-
-    cpdef prev(self):
-        cdef:
-            int64_t tmp, days
-
-        days = days_per_month_table[self.ly][(self.m - 1) % 12]
-        self.t -= days * us_in_day
-        self.dow = (self.dow - days) % 7
-
-        self.m -= 1
-        if self.m < 0:
-            self.m += 12
-            self.y -= 1
-            self.ly = is_leapyear(self.y)
-
-    cdef int64_t _ts(self):
-        """
-        Overwrite default adjustment
-        """
-        cdef int64_t adj = (self.week * 7) + (self.day - self.dow) % 7
-        return self.t + us_in_day * adj
-
-cdef class DayOffset(_Offset):
-    """
-    Generate daily timestamps beginning with first valid time >= start time. If
-    biz != 0, we skip weekends. Stride, to construct weekly timestamps.
-
-    Parameters
-    ----------
-    stride : int, > 0
-    biz : boolean
-    """
-    cdef:
-        Py_ssize_t stride
-
-    def __init__(self, int64_t stride=1, int64_t biz=0, object anchor=None):
-        self.stride = stride
-        self.biz = biz
-
-        if self.stride <= 0:
-            raise ValueError("Stride must be positive")
-
-        if anchor is not None:
-            self.anchor(anchor)
-
-    cdef _setup(self):
-        cdef _TSObject ts = self.ts
-        self.t = ts.value
-        if self.biz != 0:
-            self.dow = ts_dayofweek(ts)
-
-    cpdef next(self):
-        self.t += (self.stride * us_in_day)
-        if self.biz != 0:
-            self.dow = (self.dow + self.stride) % 7
-            if self.dow >= 5:
-                self.t += (7 - self.dow) * us_in_day
-                self.dow = 0
-
-    cpdef prev(self):
-        self.t -= (self.stride * us_in_day)
-        if self.biz != 0:
-            self.dow = (self.dow - self.stride) % 7
-            if self.dow >= 5:
-                self.t += (4 - self.dow) * us_in_day
-                self.dow = 4
diff --git a/setup.py b/setup.py
index d28c4ba8b..555cf9dc4 100755
--- a/setup.py
+++ b/setup.py
@@ -512,7 +512,7 @@ ext_data = {
                    'pxdfiles': ['_libs/src/util', '_libs/hashtable'],
                    'depends': _pxi_dep['join']},
     '_libs.reshape': {'pyxfile': '_libs/reshape',
-                      'depends': _pxi_dep['reshape']},
+                      'depends': _pxi_dep['reshape'], 'include': []},
     '_libs.interval': {'pyxfile': '_libs/interval',
                        'pxdfiles': ['_libs/hashtable'],
                        'depends': _pxi_dep['interval']},
@@ -528,7 +528,7 @@ ext_data = {
                                   'pandas/_libs/src/parser/io.c']},
     '_libs.sparse': {'pyxfile': '_libs/sparse',
                      'depends': (['pandas/_libs/sparse.pyx'] +
-                                 _pxi_dep['sparse'])},
+                                 _pxi_dep['sparse']), 'include': []},
     '_libs.testing': {'pyxfile': '_libs/testing',
                       'depends': ['pandas/_libs/testing.pyx']},
     '_libs.hashing': {'pyxfile': '_libs/hashing',

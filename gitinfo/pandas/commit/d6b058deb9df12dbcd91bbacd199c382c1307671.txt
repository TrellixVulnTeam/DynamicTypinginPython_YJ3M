commit d6b058deb9df12dbcd91bbacd199c382c1307671
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sat Oct 12 10:00:18 2019 -0700

    CLN: try/except cleanups (#28939)

diff --git a/pandas/core/apply.py b/pandas/core/apply.py
index 605d179e7..91f3e878c 100644
--- a/pandas/core/apply.py
+++ b/pandas/core/apply.py
@@ -396,15 +396,11 @@ class FrameRowApply(FrameApply):
         result = self.obj._constructor(data=results)
 
         if not isinstance(results[0], ABCSeries):
-            try:
+            if len(result.index) == len(self.res_columns):
                 result.index = self.res_columns
-            except ValueError:
-                pass
 
-        try:
+        if len(result.columns) == len(self.res_index):
             result.columns = self.res_index
-        except ValueError:
-            pass
 
         return result
 
diff --git a/pandas/core/base.py b/pandas/core/base.py
index 4d5b20c56..2d798dd15 100644
--- a/pandas/core/base.py
+++ b/pandas/core/base.py
@@ -16,6 +16,7 @@ from pandas.errors import AbstractMethodError
 from pandas.util._decorators import Appender, Substitution, cache_readonly
 from pandas.util._validators import validate_bool_kwarg
 
+from pandas.core.dtypes.cast import is_nested_object
 from pandas.core.dtypes.common import (
     is_categorical_dtype,
     is_datetime64_ns_dtype,
@@ -566,25 +567,27 @@ class SelectionMixin:
         # degenerate case
         if obj.ndim == 1:
             for a in arg:
+                colg = self._gotitem(obj.name, ndim=1, subset=obj)
                 try:
-                    colg = self._gotitem(obj.name, ndim=1, subset=obj)
-                    results.append(colg.aggregate(a))
+                    new_res = colg.aggregate(a)
 
-                    # make sure we find a good name
-                    name = com.get_callable_name(a) or a
-                    keys.append(name)
                 except (TypeError, DataError):
                     pass
                 except SpecificationError:
                     raise
+                else:
+                    results.append(new_res)
+
+                    # make sure we find a good name
+                    name = com.get_callable_name(a) or a
+                    keys.append(name)
 
         # multiples
         else:
             for index, col in enumerate(obj):
+                colg = self._gotitem(col, ndim=1, subset=obj.iloc[:, index])
                 try:
-                    colg = self._gotitem(col, ndim=1, subset=obj.iloc[:, index])
-                    results.append(colg.aggregate(arg))
-                    keys.append(col)
+                    new_res = colg.aggregate(arg)
                 except (TypeError, DataError):
                     pass
                 except ValueError:
@@ -592,6 +595,9 @@ class SelectionMixin:
                     continue
                 except SpecificationError:
                     raise
+                else:
+                    results.append(new_res)
+                    keys.append(col)
 
         # if we are empty
         if not len(results):
@@ -604,7 +610,6 @@ class SelectionMixin:
             # we are concatting non-NDFrame objects,
             # e.g. a list of scalars
 
-            from pandas.core.dtypes.cast import is_nested_object
             from pandas import Series
 
             result = Series(results, index=keys, name=self.name)
diff --git a/pandas/core/groupby/generic.py b/pandas/core/groupby/generic.py
index 5200d33c6..7be11696b 100644
--- a/pandas/core/groupby/generic.py
+++ b/pandas/core/groupby/generic.py
@@ -505,9 +505,7 @@ class SeriesGroupBy(GroupBy):
             indices = [
                 self._get_index(name) for name, group in self if true_and_notna(group)
             ]
-        except ValueError:
-            raise TypeError("the filter must return a boolean result")
-        except TypeError:
+        except (ValueError, TypeError):
             raise TypeError("the filter must return a boolean result")
 
         filtered = self._apply_filter(indices, dropna)
@@ -1052,8 +1050,8 @@ class DataFrameGroupBy(GroupBy):
             data = obj[item]
             colg = SeriesGroupBy(data, selection=item, grouper=self.grouper)
 
+            cast = self._transform_should_cast(func)
             try:
-                cast = self._transform_should_cast(func)
 
                 result[item] = colg.aggregate(func, *args, **kwargs)
                 if cast:

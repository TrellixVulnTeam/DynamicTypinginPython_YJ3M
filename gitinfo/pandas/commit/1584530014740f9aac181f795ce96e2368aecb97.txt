commit 1584530014740f9aac181f795ce96e2368aecb97
Author: Joris Van den Bossche <jorisvandenbossche@gmail.com>
Date:   Wed Aug 22 12:08:23 2018 +0200

    BUG fix IntegerArray.astype int -> uint (#22441)

diff --git a/doc/source/whatsnew/v0.24.0.txt b/doc/source/whatsnew/v0.24.0.txt
index d7feb6e54..7f19bf9cf 100644
--- a/doc/source/whatsnew/v0.24.0.txt
+++ b/doc/source/whatsnew/v0.24.0.txt
@@ -42,7 +42,7 @@ Pandas has gained the ability to hold integer dtypes with missing values. This l
 Here is an example of the usage.
 
 We can construct a ``Series`` with the specified dtype. The dtype string ``Int64`` is a pandas ``ExtensionDtype``. Specifying a list or array using the traditional missing value
-marker of ``np.nan`` will infer to integer dtype. The display of the ``Series`` will also use the ``NaN`` to indicate missing values in string outputs. (:issue:`20700`, :issue:`20747`)
+marker of ``np.nan`` will infer to integer dtype. The display of the ``Series`` will also use the ``NaN`` to indicate missing values in string outputs. (:issue:`20700`, :issue:`20747`, :issue:`22441`)
 
 .. ipython:: python
 
diff --git a/pandas/core/arrays/integer.py b/pandas/core/arrays/integer.py
index 3dffabbe4..5f6a96833 100644
--- a/pandas/core/arrays/integer.py
+++ b/pandas/core/arrays/integer.py
@@ -409,8 +409,7 @@ class IntegerArray(ExtensionArray, ExtensionOpsMixin):
 
         # if we are astyping to an existing IntegerDtype we can fastpath
         if isinstance(dtype, _IntegerDtype):
-            result = self._data.astype(dtype.numpy_dtype,
-                                       casting='same_kind', copy=False)
+            result = self._data.astype(dtype.numpy_dtype, copy=False)
             return type(self)(result, mask=self._mask, copy=False)
 
         # coerce
diff --git a/pandas/tests/extension/integer/test_integer.py b/pandas/tests/extension/integer/test_integer.py
index e2248285f..3af127091 100644
--- a/pandas/tests/extension/integer/test_integer.py
+++ b/pandas/tests/extension/integer/test_integer.py
@@ -566,16 +566,17 @@ class TestCasting(BaseInteger, base.BaseCastingTests):
         expected = pd.Series(np.asarray(mixed))
         tm.assert_series_equal(result, expected)
 
-    @pytest.mark.parametrize('dtype', [Int8Dtype(), 'Int8'])
+    @pytest.mark.parametrize('dtype', [Int8Dtype(), 'Int8',
+                                       UInt32Dtype(), 'UInt32'])
     def test_astype_specific_casting(self, dtype):
         s = pd.Series([1, 2, 3], dtype='Int64')
         result = s.astype(dtype)
-        expected = pd.Series([1, 2, 3], dtype='Int8')
+        expected = pd.Series([1, 2, 3], dtype=dtype)
         self.assert_series_equal(result, expected)
 
         s = pd.Series([1, 2, 3, None], dtype='Int64')
         result = s.astype(dtype)
-        expected = pd.Series([1, 2, 3, None], dtype='Int8')
+        expected = pd.Series([1, 2, 3, None], dtype=dtype)
         self.assert_series_equal(result, expected)
 
     def test_construct_cast_invalid(self, dtype):

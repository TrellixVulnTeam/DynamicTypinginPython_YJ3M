commit 4a6fd010184643cb2dbb82e55aed34bee2821c5e
Author: Chang She <chang@lambdafoundry.com>
Date:   Sun Jun 3 16:42:25 2012 -0400

    BUG: DataFrame.replace later values clobber earlier ones

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 39ba9614c..03a9f364e 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2896,8 +2896,7 @@ class DataFrame(NDFrame):
                                          (len(to_replace), len(value)))
 
                     new_data = self._data if inplace else self.copy()._data
-                    for s, d in zip(to_replace, value):
-                        new_data = new_data.replace(s, d, inplace=True)
+                    new_data._replace_list(to_replace, value)
 
                 else: # [np.nan, ''] -> 0
                     new_data = self._data.replace(to_replace, value,
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 392b5d3a7..0b0ed779e 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -253,6 +253,16 @@ class Block(object):
         else:
             return make_block(new_values, self.items, self.ref_items)
 
+    def putmask(self, mask, new, inplace=False):
+        new_values = self.values if inplace else self.values.copy()
+        if self._can_hold_element(new):
+            new = self._try_cast(new)
+            np.putmask(new_values, mask, new)
+        if inplace:
+            return self
+        else:
+            return make_block(new_values, self.items, self.ref_items)
+
     def interpolate(self, method='pad', axis=0, inplace=False,
                     limit=None, missing=None):
         values = self.values if inplace else self.values.copy()
@@ -1127,6 +1137,22 @@ class BlockManager(object):
             return self
         return BlockManager(new_blocks, self.axes)
 
+    def _replace_list(self, src_lst, dest_lst):
+        sset = set(src_lst)
+        if any([k in sset for k in dest_lst]):
+            masks = {}
+            for s in src_lst:
+                masks[s] = [b.values == s for b in self.blocks]
+
+            for s, d in zip(src_lst, dest_lst):
+                [b.putmask(masks[s][i], d, inplace=True) for i, b in
+                 enumerate(self.blocks)]
+        else:
+            for s, d in zip(src_lst, dest_lst):
+                self.replace(s, d, inplace=True)
+
+        return self
+
     @property
     def block_id_vector(self):
         # TODO
diff --git a/pandas/core/series.py b/pandas/core/series.py
index a124fbc4c..6d9737cc6 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2239,15 +2239,23 @@ copy : boolean, default False
 
         def _rep_dict(rs, to_rep): # replace {[src] -> dest}
 
+            all_src = set()
             dd = {} # group by unique destination value
-            [dd.setdefault(d, []).append(s) for s, d in to_rep.iteritems()]
-
-            masks = {}
-            for d, sset in dd.iteritems(): # now replace by each dest
-                masks[d] = com.mask_missing(rs.values, sset)
-
-            for d, m in masks.iteritems():
-                np.putmask(rs.values, m, d)
+            for s, d in to_rep.iteritems():
+                dd.setdefault(d, []).append(s)
+                all_src.add(s)
+
+            if any(d in all_src for d in dd.keys()):
+                # don't clobber each other at the cost of temporaries
+                masks = {}
+                for d, sset in dd.iteritems(): # now replace by each dest
+                    masks[d] = com.mask_missing(rs.values, sset)
+
+                for d, m in masks.iteritems():
+                    np.putmask(rs.values, m, d)
+            else: # if no risk of clobbering then simple
+                for d, sset in dd.iteritems():
+                    _rep_one(rs, sset, d)
             return rs
 
         if np.isscalar(to_replace):
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index a640c5fc6..349177ac4 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -3974,6 +3974,11 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
             expected[k] = v.replace(to_rep[k], values[k])
         assert_frame_equal(filled, DataFrame(expected))
 
+        result = df.replace([0, 2, 5], [5, 2, 0])
+        expected = DataFrame({'A' : [np.nan, 5, np.inf], 'B' : [5, 2, 0],
+                              'C' : ['', 'asdf', 'fd']})
+        assert_frame_equal(result, expected)
+
         # dict to scalar
         filled = df.replace(to_rep, 0)
         expected = {}

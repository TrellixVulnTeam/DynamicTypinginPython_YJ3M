commit 759b0db9436999877791e25bf524c9c40202bc6d
Author: Stephen Lin <stephenwlin@gmail.com>
Date:   Tue Feb 12 18:10:23 2013 -0500

    ENH: Consolidate and further improve performance of take functions

diff --git a/pandas/core/common.py b/pandas/core/common.py
index b7cea4e30..68cf9fa09 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -247,7 +247,7 @@ def _unpickle_array(bytes):
     return arr
 
 
-def _view_wrapper(f, arr_dtype, out_dtype, fill_wrap=None):
+def _view_wrapper(f, arr_dtype=None, out_dtype=None, fill_wrap=None):
     def wrapper(arr, indexer, out, fill_value=np.nan):
         if arr_dtype is not None:
             arr = arr.view(arr_dtype)
@@ -259,17 +259,6 @@ def _view_wrapper(f, arr_dtype, out_dtype, fill_wrap=None):
     return wrapper
 
 
-def _datetime64_fill_wrap(fill_value):
-    if isnull(fill_value):
-        return tslib.iNaT
-    try:
-        return lib.Timestamp(fill_value).value
-    except:
-        # the proper thing to do here would probably be to upcast to object
-        # (but numpy 1.6.1 doesn't do this properly)
-        return tslib.iNaT
-
-
 def _convert_wrapper(f, conv_dtype):
     def wrapper(arr, indexer, out, fill_value=np.nan):
         arr = arr.astype(conv_dtype)
@@ -277,18 +266,21 @@ def _convert_wrapper(f, conv_dtype):
     return wrapper
 
 
-def _take_2d_multi_generic(arr, indexer, out, fill_value=np.nan):
-    # this is not ideal, performance-wise, but it's better than
-    #   raising an exception
-    if arr.shape[0] == 0 or arr.shape[1] == 0:
-        return
+def _take_2d_multi_generic(arr, indexer, out, fill_value, mask_info):
+    # this is not ideal, performance-wise, but it's better than raising
+    # an exception (best to optimize in Cython to avoid getting here)
     row_idx, col_idx = indexer
-    row_mask = row_idx == -1
-    col_mask = col_idx == -1
+    if mask_info is not None:
+        (row_mask, col_mask), (row_needs, col_needs) = mask_info
+    else:
+        row_mask = row_idx == -1
+        col_mask = col_idx == -1
+        row_needs = row_mask.any()
+        col_needs = col_mask.any()
     if fill_value is not None:
-        if row_mask.any():
+        if row_needs:
             out[row_mask, :] = fill_value
-        if col_mask.any():
+        if col_needs:
             out[:, col_mask] = fill_value
     for i in range(len(row_idx)):
         u = row_idx[i]
@@ -297,14 +289,16 @@ def _take_2d_multi_generic(arr, indexer, out, fill_value=np.nan):
             out[i, j] = arr[u, v]
 
 
-def _take_nd_generic(arr, indexer, out, axis=0, fill_value=np.nan):
-    if arr.shape[axis] == 0:
-        return
-    mask = indexer == -1
-    needs_masking = mask.any()
+def _take_nd_generic(arr, indexer, out, axis, fill_value, mask_info):
+    if mask_info is not None:
+        mask, needs_masking = mask_info
+    else:
+        mask = indexer == -1
+        needs_masking = mask.any()
     if arr.dtype != out.dtype:
         arr = arr.astype(out.dtype)
-    ndtake(arr, indexer, axis=axis, out=out)
+    if arr.shape[axis] > 0:
+        arr.take(_ensure_platform_int(indexer), axis=axis, out=out)
     if needs_masking:
         outindexer = [slice(None)] * arr.ndim
         outindexer[axis] = mask
@@ -334,8 +328,7 @@ _take_1d_dict = {
     ('bool', 'object'):
         _view_wrapper(algos.take_1d_bool_object, np.uint8, None),
     ('datetime64[ns]','datetime64[ns]'):
-        _view_wrapper(algos.take_1d_int64_int64, np.int64, np.int64,
-                      fill_wrap=_datetime64_fill_wrap)
+        _view_wrapper(algos.take_1d_int64_int64, np.int64, np.int64, np.int64)
 }
 
 
@@ -363,7 +356,7 @@ _take_2d_axis0_dict = {
         _view_wrapper(algos.take_2d_axis0_bool_object, np.uint8, None),
     ('datetime64[ns]','datetime64[ns]'):
         _view_wrapper(algos.take_2d_axis0_int64_int64, np.int64, np.int64,
-                      fill_wrap=_datetime64_fill_wrap)
+                      fill_wrap=np.int64)
 }
 
 
@@ -391,7 +384,7 @@ _take_2d_axis1_dict = {
         _view_wrapper(algos.take_2d_axis1_bool_object, np.uint8, None),
     ('datetime64[ns]','datetime64[ns]'):
         _view_wrapper(algos.take_2d_axis1_int64_int64, np.int64, np.int64,
-                      fill_wrap=_datetime64_fill_wrap)
+                      fill_wrap=np.int64)
 }
 
 
@@ -419,159 +412,187 @@ _take_2d_multi_dict = {
         _view_wrapper(algos.take_2d_multi_bool_object, np.uint8, None),
     ('datetime64[ns]','datetime64[ns]'):
         _view_wrapper(algos.take_2d_multi_int64_int64, np.int64, np.int64,
-                      fill_wrap=_datetime64_fill_wrap)
+                      fill_wrap=np.int64)
 }
 
 
-def _get_take_1d_function(dtype, out_dtype):
-    try:
-        return _take_1d_dict[dtype.name, out_dtype.name]
-    except KeyError:
-        pass
-
-    if dtype != out_dtype: 
-        try:
-            func = _take_1d_dict[out_dtype.name, out_dtype.name]
-            return _convert_wrapper(func, out_dtype)
-        except KeyError:
-            pass
-
-    def wrapper(arr, indexer, out, fill_value=np.nan):
-        return _take_nd_generic(arr, indexer, out, axis=0,
-                                fill_value=fill_value)
-    return wrapper
-
-
-def _get_take_2d_function(dtype, out_dtype, axis=0):
-    try:
-        if axis == 0:
-            return _take_2d_axis0_dict[dtype.name, out_dtype.name]
-        elif axis == 1:
-            return _take_2d_axis1_dict[dtype.name, out_dtype.name]
-        elif axis == 'multi':
-            return _take_2d_multi_dict[dtype.name, out_dtype.name]
-        else:  # pragma: no cover
-            raise ValueError('bad axis: %s' % axis)
-    except KeyError:
-        pass
-
-    if dtype != out_dtype: 
-        try:
+def _get_take_nd_function(ndim, arr_dtype, out_dtype, axis=0, mask_info=None):
+    if ndim <= 2:
+        tup = (arr_dtype.name, out_dtype.name)
+        if ndim == 1:
+            func = _take_1d_dict.get(tup, None)
+        elif ndim == 2:
             if axis == 0:
-                func = _take_2d_axis0_dict[out_dtype.name, out_dtype.name]
-            elif axis == 1:
-                func = _take_2d_axis1_dict[out_dtype.name, out_dtype.name]
+                func = _take_2d_axis0_dict.get(tup, None)
             else:
-                func = _take_2d_multi_dict[out_dtype.name, out_dtype.name]
-            return _convert_wrapper(func, out_dtype)
-        except KeyError:
-            pass
-
-    if axis == 'multi':
-        return _take_2d_multi_generic
-
-    def wrapper(arr, indexer, out, fill_value=np.nan):
-        return _take_nd_generic(arr, indexer, out, axis=axis,
-                                fill_value=fill_value)
-    return wrapper
-
-
-def _get_take_nd_function(ndim, dtype, out_dtype, axis=0):
-    if ndim == 2:
-        return _get_take_2d_function(dtype, out_dtype, axis=axis)
-    elif ndim == 1:
-        if axis != 0:
-            raise ValueError('axis must be 0 for one dimensional array')
-        return _get_take_1d_function(dtype, out_dtype)
-    elif ndim <= 0:
-        raise ValueError('ndim must be >= 1')
-
-    def wrapper(arr, indexer, out, fill_value=np.nan):
-        return _take_nd_generic(arr, indexer, out, axis=axis,
-                                fill_value=fill_value)
-    if (dtype.name, out_dtype.name) == ('datetime64[ns]','datetime64[ns]'):
-        wrapper = _view_wrapper(wrapper, np.int64, np.int64,
-                                fill_wrap=_datetime64_fill_wrap)
-    return wrapper
+                func = _take_2d_axis1_dict.get(tup, None)
+        if func is not None:
+            return func
+
+        tup = (out_dtype.name, out_dtype.name)
+        if ndim == 1:
+            func = _take_1d_dict.get(tup, None)
+        elif ndim == 2:
+            if axis == 0:
+                func = _take_2d_axis0_dict.get(tup, None)
+            else:
+                func = _take_2d_axis1_dict.get(tup, None)
+        if func is not None:
+            func = _convert_wrapper(func, out_dtype)
+            return func
+    
+    def func(arr, indexer, out, fill_value=np.nan):
+        _take_nd_generic(arr, indexer, out, axis=axis,
+                         fill_value=fill_value, mask_info=mask_info)
+    return func
 
 
-def take_1d(arr, indexer, out=None, fill_value=np.nan):
+def take_nd(arr, indexer, axis=0, out=None, fill_value=np.nan,
+            mask_info=None, allow_fill=True):
     """
     Specialized Cython take which sets NaN values in one pass
+
+    Parameters
+    ----------
+    arr : ndarray
+        Input array
+    indexer : ndarray
+        1-D array of indices to take, subarrays corresponding to -1 value
+        indicies are filed with fill_value
+    axis : int, default 0
+        Axis to take from
+    out : ndarray or None, default None
+        Optional output array, must be appropriate type to hold input and
+        fill_value together, if indexer has any -1 value entries; call
+        common._maybe_promote to determine this type for any fill_value
+    fill_value : any, default np.nan
+        Fill value to replace -1 values with
+    mask_info : tuple of (ndarray, boolean)
+        If provided, value should correspond to:
+            (indexer != -1, (indexer != -1).any())
+        If not provided, it will be computed internally if necessary
+    allow_fill : boolean, default True
+        If False, indexer is assumed to contain no -1 values so no filling
+        will be done.  This short-circuits computation of a mask.  Result is
+        undefined if allow_fill == False and -1 is present in indexer.
     """
     if indexer is None:
-        indexer = np.arange(len(arr), dtype=np.int64)
+        indexer = np.arange(arr.shape[axis], dtype=np.int64)
         dtype, fill_value = arr.dtype, arr.dtype.type()
     else:
         indexer = _ensure_int64(indexer)
-        dtype = _maybe_promote(arr.dtype, fill_value)[0]
-        if dtype != arr.dtype:
-            mask = indexer == -1
-            needs_masking = mask.any()
-            if needs_masking:
-                if out is not None and out.dtype != dtype:
-                    raise Exception('Incompatible type for fill_value')
-            else:
-                dtype, fill_value = arr.dtype, arr.dtype.type()
-
+        if not allow_fill:
+            dtype, fill_value = arr.dtype, arr.dtype.type()
+            mask_info = None, False
+        else:
+            # check for promotion based on types only (do this first because
+            # it's faster than computing a mask)
+            dtype, fill_value = _maybe_promote(arr.dtype, fill_value)
+            if dtype != arr.dtype and (out is None or out.dtype != dtype):
+                # check if promotion is actually required based on indexer
+                if mask_info is not None:
+                    mask, needs_masking = mask_info
+                else:
+                    mask = indexer == -1
+                    needs_masking = mask.any()
+                    mask_info = mask, needs_masking
+                if needs_masking:
+                    if out is not None and out.dtype != dtype:
+                        raise Exception('Incompatible type for fill_value')
+                else:
+                    # if not, then depromote, set fill_value to dummy
+                    # (it won't be used but we don't want the cython code
+                    # to crash when trying to cast it to dtype)
+                    dtype, fill_value = arr.dtype, arr.dtype.type()
+
+    # at this point, it's guaranteed that dtype can hold both the arr values
+    # and the fill_value
     if out is None:
-        out = np.empty(len(indexer), dtype=dtype)
-    take_f = _get_take_1d_function(arr.dtype, out.dtype)
-    take_f(arr, indexer, out=out, fill_value=fill_value)
+        out_shape = list(arr.shape)
+        out_shape[axis] = len(indexer)
+        out_shape = tuple(out_shape)
+        if arr.flags.f_contiguous and axis == arr.ndim - 1:
+            # minor tweak that can make an order-of-magnitude difference
+            # for dataframes initialized directly from 2-d ndarrays
+            # (s.t. df.values is c-contiguous and df._data.blocks[0] is its
+            # f-contiguous transpose)
+            out = np.empty(out_shape, dtype=dtype, order='F')
+        else:
+            out = np.empty(out_shape, dtype=dtype)
+
+    func = _get_take_nd_function(arr.ndim, arr.dtype, out.dtype,
+                                 axis=axis, mask_info=mask_info)
+    func(arr, indexer, out, fill_value)
     return out
 
 
-def take_nd(arr, indexer, out=None, axis=0, fill_value=np.nan):
-    """
-    Specialized Cython take which sets NaN values in one pass
-    """
-    if indexer is None:
-        mask = None
-        needs_masking = False
-        fill_value = arr.dtype.type()
-    else:
-        indexer = _ensure_int64(indexer)
-        mask = indexer == -1
-        needs_masking = mask.any()
-        if not needs_masking:
-            fill_value = arr.dtype.type()
-    return take_fast(arr, indexer, mask, needs_masking, axis, out, fill_value)
+take_1d = take_nd
 
 
-def take_2d_multi(arr, row_idx, col_idx, fill_value=np.nan, out=None):
+def take_2d_multi(arr, indexer, out=None, fill_value=np.nan,
+                  mask_info=None, allow_fill=True):
     """
     Specialized Cython take which sets NaN values in one pass
     """
-    if row_idx is None:
+    if indexer is None or (indexer[0] is None and indexer[1] is None):
         row_idx = np.arange(arr.shape[0], dtype=np.int64)
-    else:
-        row_idx = _ensure_int64(row_idx)
-
-    if col_idx is None:
         col_idx = np.arange(arr.shape[1], dtype=np.int64)
+        indexer = row_idx, col_idx
+        dtype, fill_value = arr.dtype, arr.dtype.type()
     else:
-        col_idx = _ensure_int64(col_idx)
-
-    dtype = _maybe_promote(arr.dtype, fill_value)[0]
-    if dtype != arr.dtype:
-        row_mask = row_idx == -1
-        col_mask = col_idx == -1
-        needs_masking = row_mask.any() or col_mask.any()
-        if needs_masking:
-            if out is not None and out.dtype != dtype:
-                raise Exception('Incompatible type for fill_value')
+        row_idx, col_idx = indexer
+        if row_idx is None:
+            row_idx = np.arange(arr.shape[0], dtype=np.int64)
         else:
+            row_idx = _ensure_int64(row_idx)
+        if col_idx is None:
+            col_idx = np.arange(arr.shape[1], dtype=np.int64)
+        else:
+            col_idx = _ensure_int64(col_idx)
+        indexer = row_idx, col_idx
+        if not allow_fill:
             dtype, fill_value = arr.dtype, arr.dtype.type()
+            mask_info = None, False
+        else:
+            # check for promotion based on types only (do this first because
+            # it's faster than computing a mask)
+            dtype, fill_value = _maybe_promote(arr.dtype, fill_value)
+            if dtype != arr.dtype and (out is None or out.dtype != dtype):
+                # check if promotion is actually required based on indexer
+                if mask_info is not None:
+                    (row_mask, col_mask), (row_needs, col_needs) = mask_info
+                else:
+                    row_mask = row_idx == -1
+                    col_mask = col_idx == -1
+                    row_needs = row_mask.any()
+                    col_needs = col_mask.any()
+                    mask_info = (row_mask, col_mask), (row_needs, col_needs)
+                if row_needs or col_needs:
+                    if out is not None and out.dtype != dtype:
+                        raise Exception('Incompatible type for fill_value')
+                else:
+                    # if not, then depromote, set fill_value to dummy
+                    # (it won't be used but we don't want the cython code
+                    # to crash when trying to cast it to dtype)
+                    dtype, fill_value = arr.dtype, arr.dtype.type()
+
+    # at this point, it's guaranteed that dtype can hold both the arr values
+    # and the fill_value
     if out is None:
         out_shape = len(row_idx), len(col_idx)
         out = np.empty(out_shape, dtype=dtype)
-    take_f = _get_take_2d_function(arr.dtype, out.dtype, axis='multi')
-    take_f(arr, (row_idx, col_idx), out=out, fill_value=fill_value)
-    return out
 
-
-def ndtake(arr, indexer, axis=0, out=None):
-    return arr.take(_ensure_platform_int(indexer), axis=axis, out=out)
+    func = _take_2d_multi_dict.get((arr.dtype.name, out.dtype.name), None)
+    if func is None and arr.dtype != out.dtype:
+        func = _take_2d_multi_dict.get((out.dtype.name, out.dtype.name), None)
+        if func is not None:
+            func = _convert_wrapper(func, out.dtype)
+    if func is None:
+        def func(arr, indexer, out, fill_value=np.nan):
+            _take_2d_multi_generic(arr, indexer, out,
+                                   fill_value=fill_value, mask_info=mask_info)
+    func(arr, indexer, out=out, fill_value=fill_value)
+    return out
 
 
 _diff_special = {
@@ -615,36 +636,6 @@ def diff(arr, n, axis=0):
     return out_arr
 
 
-def take_fast(arr, indexer, mask, needs_masking, axis=0, out=None,
-              fill_value=np.nan):
-    """
-    Specialized Cython take which sets NaN values in one pass
-
-    (equivalent to take_nd but requires mask and needs_masking
-     to be set appropriately already; slightly more efficient)
-    """
-    if indexer is None:
-        indexer = np.arange(arr.shape[axis], dtype=np.int64)
-        dtype = arr.dtype
-    else:
-        indexer = _ensure_int64(indexer)
-        if needs_masking:
-            dtype = _maybe_promote(arr.dtype, fill_value)[0]
-            if dtype != arr.dtype and out is not None and out.dtype != dtype:
-                raise Exception('Incompatible type for fill_value')
-        else:
-            dtype = arr.dtype
-
-    if out is None:
-        out_shape = list(arr.shape)
-        out_shape[axis] = len(indexer)
-        out_shape = tuple(out_shape)
-        out = np.empty(out_shape, dtype=dtype)
-    take_f = _get_take_nd_function(arr.ndim, arr.dtype, out.dtype, axis=axis)
-    take_f(arr, indexer, out=out, fill_value=fill_value)
-    return out
-
-
 def _infer_dtype_from_scalar(val):
     """ interpret the dtype from a scalar, upcast floats and ints
         return the new value and the dtype """
@@ -689,6 +680,7 @@ def _infer_dtype_from_scalar(val):
 
     return dtype, val
 
+
 def _maybe_promote(dtype, fill_value=np.nan):
     # returns tuple of (dtype, fill_value)
     if issubclass(dtype.type, np.datetime64):
@@ -953,22 +945,6 @@ def _possibly_cast_to_datetime(value, dtype, coerce = False):
     return value
 
 
-<<<<<<< HEAD
-=======
-def _infer_dtype(value):
-    if isinstance(value, (float, np.floating)):
-        return np.float64
-    elif isinstance(value, (bool, np.bool_)):
-        return np.bool_
-    elif isinstance(value, (int, long, np.integer)):
-        return np.int64
-    elif isinstance(value, (complex, np.complexfloating)):
-        return np.complex128
-    else:
-        return np.object_
-
-
->>>>>>> e2b4ccd... CLN: add fill_value return value to common._maybe_promote
 def _is_bool_indexer(key):
     if isinstance(key, np.ndarray) and key.dtype == np.object_:
         key = np.asarray(key)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index ecd7d57a0..676c684f9 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2644,8 +2644,9 @@ class DataFrame(NDFrame):
         new_columns, col_indexer = self.columns.reindex(new_columns)
 
         if row_indexer is not None and col_indexer is not None:
-            new_values = com.take_2d_multi(self.values, row_indexer,
-                                           col_indexer, fill_value=fill_value)
+            indexer = row_indexer, col_indexer
+            new_values = com.take_2d_multi(self.values, indexer,
+                                           fill_value=fill_value)
             return DataFrame(new_values, index=new_index, columns=new_columns)
         elif row_indexer is not None:
             return self._reindex_with_indexers(new_index, row_indexer,
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index e89175ef7..fe7c281af 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -897,7 +897,7 @@ class Grouper(object):
         dummy = obj[:0].copy()
         indexer = _algos.groupsort_indexer(group_index, ngroups)[0]
         obj = obj.take(indexer)
-        group_index = com.ndtake(group_index, indexer)
+        group_index = com.take_nd(group_index, indexer, allow_fill=False)
         grouper = lib.SeriesGrouper(obj, func, group_index, ngroups,
                                     dummy)
         result, counts = grouper.get_result()
@@ -1686,7 +1686,9 @@ class NDFrameGroupBy(GroupBy):
                 zipped = zip(result.index.levels, result.index.labels,
                              result.index.names)
                 for i, (lev, lab, name) in enumerate(zipped):
-                    result.insert(i, name, com.ndtake(lev.values, lab))
+                    result.insert(i, name,
+                                  com.take_nd(lev.values, lab,
+                                              allow_fill=False))
                 result = result.consolidate()
             else:
                 values = result.index.values
@@ -2133,7 +2135,7 @@ class DataSplitter(object):
     @cache_readonly
     def slabels(self):
         # Sorted labels
-        return com.ndtake(self.labels, self.sort_idx)
+        return com.take_nd(self.labels, self.sort_idx, allow_fill=False)
 
     @cache_readonly
     def sort_idx(self):
@@ -2411,11 +2413,11 @@ def _reorder_by_uniques(uniques, labels):
     mask = labels < 0
 
     # move labels to right locations (ie, unsort ascending labels)
-    labels = com.ndtake(reverse_indexer, labels)
+    labels = com.take_nd(reverse_indexer, labels, allow_fill=False)
     np.putmask(labels, mask, -1)
 
     # sort observed ids
-    uniques = com.ndtake(uniques, sorter)
+    uniques = com.take_nd(uniques, sorter, allow_fill=False)
 
     return uniques, labels
 
diff --git a/pandas/core/index.py b/pandas/core/index.py
index bcd45a9fa..3a5f1d814 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -12,7 +12,6 @@ import pandas.algos as _algos
 import pandas.index as _index
 from pandas.lib import Timestamp
 
-from pandas.core.common import ndtake
 from pandas.util.decorators import cache_readonly
 import pandas.core.common as com
 from pandas.util import py3compat
@@ -608,7 +607,8 @@ class Index(np.ndarray):
             indexer = (indexer == -1).nonzero()[0]
 
             if len(indexer) > 0:
-                other_diff = ndtake(other.values, indexer)
+                other_diff = com.take_nd(other.values, indexer,
+                                         allow_fill=False)
                 result = com._concat_compat((self.values, other_diff))
                 try:
                     result.sort()
@@ -1037,7 +1037,8 @@ class Index(np.ndarray):
             rev_indexer = lib.get_reverse_indexer(left_lev_indexer,
                                                   len(old_level))
 
-            new_lev_labels = ndtake(rev_indexer, left.labels[level])
+            new_lev_labels = com.take_nd(rev_indexer, left.labels[level],
+                                         allow_fill=False)
             omit_mask = new_lev_labels != -1
 
             new_labels = list(left.labels)
@@ -1057,8 +1058,9 @@ class Index(np.ndarray):
             left_indexer = None
 
         if right_lev_indexer is not None:
-            right_indexer = ndtake(right_lev_indexer,
-                                   join_index.labels[level])
+            right_indexer = com.take_nd(right_lev_indexer,
+                                        join_index.labels[level],
+                                        allow_fill=False)
         else:
             right_indexer = join_index.labels[level]
 
@@ -2369,8 +2371,10 @@ class MultiIndex(Index):
             return False
 
         for i in xrange(self.nlevels):
-            svalues = ndtake(self.levels[i].values, self.labels[i])
-            ovalues = ndtake(other.levels[i].values, other.labels[i])
+            svalues = com.take_nd(self.levels[i].values, self.labels[i],
+                                  allow_fill=False)
+            ovalues = com.take_nd(other.levels[i].values, other.labels[i],
+                                  allow_fill=False)
             if not np.array_equal(svalues, ovalues):
                 return False
 
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 56802c2cb..cd7404532 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -120,14 +120,14 @@ class Block(object):
         #     union_ref = self.ref_items + other.ref_items
         return _merge_blocks([self, other], self.ref_items)
 
-    def reindex_axis(self, indexer, mask, needs_masking, axis=0,
-                     fill_value=np.nan):
+    def reindex_axis(self, indexer, axis=1, fill_value=np.nan, mask_info=None):
         """
         Reindex using pre-computed indexer information
         """
-        new_values = com.take_fast(self.values, indexer,
-                                   mask, needs_masking, axis=axis,
-                                   fill_value=fill_value)
+        if axis < 1:
+            raise AssertionError('axis must be at least 1, got %d' % axis)
+        new_values = com.take_nd(self.values, indexer, axis,
+                                 fill_value=fill_value, mask_info=mask_info)
         return make_block(new_values, self.items, self.ref_items)
 
     def reindex_items_from(self, new_ref_items, copy=True):
@@ -146,12 +146,9 @@ class Block(object):
             new_items = new_ref_items
             new_values = self.values.copy() if copy else self.values
         else:
-            mask = indexer != -1
-            masked_idx = indexer[mask]
-
-            new_values = com.take_fast(self.values, masked_idx,
-                                       mask=None, needs_masking=False,
-                                       axis=0)
+            masked_idx = indexer[indexer != -1]
+            new_values = com.take_nd(self.values, masked_idx, axis=0,
+                                     allow_fill=False)
             new_items = self.items.take(masked_idx)
         return make_block(new_values, new_items, new_ref_items)
 
@@ -221,7 +218,10 @@ class Block(object):
             return make_block(new_values, self.items, self.ref_items)
 
     def astype(self, dtype, copy = True, raise_on_error = True):
-        """ coerce to the new type (if copy=True, return a new copy) raise on an except if raise == True """
+        """
+        Coerce to the new type (if copy=True, return a new copy)
+        raise on an except if raise == True
+        """
         try:
             newb = make_block(com._astype_nansafe(self.values, dtype, copy = copy),
                               self.items, self.ref_items)
@@ -231,12 +231,12 @@ class Block(object):
             newb = self.copy() if copy else self
 
         if newb.is_numeric and self.is_numeric:
-            if newb.shape != self.shape or (not copy and newb.itemsize < self.itemsize):
-                raise TypeError("cannot set astype for copy = [%s] for dtype (%s [%s]) with smaller itemsize that current (%s [%s])" % (copy,
-                                                                                                                                        self.dtype.name,
-                                                                                                                                        self.itemsize,
-                                                                                                                                        newb.dtype.name,
-                                                                                                                                        newb.itemsize))
+            if (newb.shape != self.shape or
+                    (not copy and newb.itemsize < self.itemsize)):
+                raise TypeError("cannot set astype for copy = [%s] for dtype "
+                                "(%s [%s]) with smaller itemsize that current "
+                                "(%s [%s])" % (copy, self.dtype.name,
+                                self.itemsize, newb.dtype.name, newb.itemsize))
         return newb
 
     def convert(self, copy = True, **kwargs):
@@ -356,11 +356,11 @@ class Block(object):
 
         return make_block(values, self.items, self.ref_items)
 
-    def take(self, indexer, axis=1, fill_value=np.nan):
+    def take(self, indexer, axis=1):
         if axis < 1:
             raise AssertionError('axis must be at least 1, got %d' % axis)
-        new_values = com.take_fast(self.values, indexer, None, False,
-                                   axis=axis, fill_value=fill_value)
+        new_values = com.take_nd(self.values, indexer, axis=axis,
+                                 allow_fill=False)
         return make_block(new_values, self.items, self.ref_items)
 
     def get_values(self, dtype):
@@ -1320,15 +1320,9 @@ class BlockManager(object):
         if axis == 0:
             return self._reindex_indexer_items(new_axis, indexer, fill_value)
 
-        mask = indexer == -1
-
-        # TODO: deal with length-0 case? or does it fall out?
-        needs_masking = len(new_axis) > 0 and mask.any()
-
         new_blocks = []
         for block in self.blocks:
-            newb = block.reindex_axis(indexer, mask, needs_masking,
-                                      axis=axis, fill_value=fill_value)
+            newb = block.reindex_axis(indexer, axis=axis, fill_value=fill_value)
             new_blocks.append(newb)
 
         new_axes = list(self.axes)
@@ -1354,8 +1348,8 @@ class BlockManager(object):
                 continue
 
             new_block_items = new_items.take(selector.nonzero()[0])
-            new_values = com.take_fast(blk.values, blk_indexer[selector],
-                                       None, False, axis=0)
+            new_values = com.take_nd(blk.values, blk_indexer[selector], axis=0,
+                                     allow_fill=False)
             new_blocks.append(make_block(new_values, new_block_items,
                                          new_items))
 
@@ -1419,8 +1413,8 @@ class BlockManager(object):
         return na_block
 
     def take(self, indexer, axis=1):
-        if axis == 0:
-            raise NotImplementedError
+        if axis < 1:
+            raise AssertionError('axis must be at least 1, got %d' % axis)
 
         indexer = com._ensure_platform_int(indexer)
 
@@ -1433,8 +1427,8 @@ class BlockManager(object):
         new_axes[axis] = self.axes[axis].take(indexer)
         new_blocks = []
         for blk in self.blocks:
-            new_values = com.take_fast(blk.values, indexer, None, False,
-                                       axis=axis)
+            new_values = com.take_nd(blk.values, indexer, axis=axis,
+                                     allow_fill=False)
             newb = make_block(new_values, blk.items, self.items)
             new_blocks.append(newb)
 
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 6e52193a2..b418995ce 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -838,7 +838,7 @@ class Panel(NDFrame):
             indexer2 = range(len(new_minor))
 
         for i, ind in enumerate(indexer0):
-            com.take_2d_multi(values[ind], indexer1, indexer2,
+            com.take_2d_multi(values[ind], (indexer1, indexer2),
                               out=new_values[i])
 
         return Panel(new_values, items=new_items, major_axis=new_major,
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index c68154b27..11fbf5371 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -62,21 +62,13 @@ def take_1d_%(name)s_%(dest)s(ndarray[%(c_type_in)s] values,
 
     n = len(indexer)
 
-    if %(raise_on_na)s and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = %(preval)svalues[idx]%(postval)s
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = %(preval)svalues[idx]%(postval)s
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = %(preval)svalues[idx]%(postval)s
 
 """
 
@@ -93,25 +85,15 @@ def take_2d_axis0_%(name)s_%(dest)s(ndarray[%(c_type_in)s, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if %(raise_on_na)s and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = %(preval)svalues[idx, j]%(postval)s
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = %(preval)svalues[idx, j]%(postval)s
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = %(preval)svalues[idx, j]%(postval)s
 
 """
 
@@ -128,25 +110,15 @@ def take_2d_axis1_%(name)s_%(dest)s(ndarray[%(c_type_in)s, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if %(raise_on_na)s and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = %(preval)svalues[i, idx]%(postval)s
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = %(preval)svalues[i, idx]%(postval)s
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = %(preval)svalues[i, idx]%(postval)s
 
 """
 
@@ -165,31 +137,18 @@ def take_2d_multi_%(name)s_%(dest)s(ndarray[%(c_type_in)s, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if %(raise_on_na)s and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = %(preval)svalues[idx, idx1[j]]%(postval)s
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = %(preval)svalues[idx, idx1[j]]%(postval)s
+                else:
+                    outbuf[i, j] = %(preval)svalues[idx, idx1[j]]%(postval)s
 
 """
 
@@ -2156,40 +2115,39 @@ def generate_put_template(template, use_ints = True, use_floats = True):
     return output.getvalue()
 
 def generate_take_template(template, exclude=None):
-    # name, dest, ctypein, ctypeout, preval, postval, capable of holding NA
+    # name, dest, ctypein, ctypeout, preval, postval
     function_list = [
-        ('bool', 'bool', 'uint8_t', 'uint8_t', '', '', False),
+        ('bool', 'bool', 'uint8_t', 'uint8_t', '', ''),
         ('bool', 'object', 'uint8_t', 'object',
-         'True if ', ' > 0 else False', True),
-        ('int8', 'int8', 'int8_t', 'int8_t', '', '', False),
-        ('int8', 'int32', 'int8_t', 'int32_t', '', '', False),
-        ('int8', 'int64', 'int8_t', 'int64_t', '', '', False),
-        ('int8', 'float64', 'int8_t', 'float64_t', '', '', True),
-        ('int16', 'int16', 'int16_t', 'int16_t', '', '', False),
-        ('int16', 'int32', 'int16_t', 'int32_t', '', '', False),
-        ('int16', 'int64', 'int16_t', 'int64_t', '', '', False),
-        ('int16', 'float64', 'int16_t', 'float64_t', '', '', True),
-        ('int32', 'int32', 'int32_t', 'int32_t', '', '', False),
-        ('int32', 'int64', 'int32_t', 'int64_t', '', '', False),
-        ('int32', 'float64', 'int32_t', 'float64_t', '', '', True),
-        ('int64', 'int64', 'int64_t', 'int64_t', '', '', False),
-        ('int64', 'float64', 'int64_t', 'float64_t', '', '', True),
-        ('float32', 'float32', 'float32_t', 'float32_t', '', '', True),
-        ('float32', 'float64', 'float32_t', 'float64_t', '', '', True),
-        ('float64', 'float64', 'float64_t', 'float64_t', '', '', True),
-        ('object', 'object', 'object', 'object', '', '', True)
+         'True if ', ' > 0 else False'),
+        ('int8', 'int8', 'int8_t', 'int8_t', '', ''),
+        ('int8', 'int32', 'int8_t', 'int32_t', '', ''),
+        ('int8', 'int64', 'int8_t', 'int64_t', '', ''),
+        ('int8', 'float64', 'int8_t', 'float64_t', '', ''),
+        ('int16', 'int16', 'int16_t', 'int16_t', '', ''),
+        ('int16', 'int32', 'int16_t', 'int32_t', '', ''),
+        ('int16', 'int64', 'int16_t', 'int64_t', '', ''),
+        ('int16', 'float64', 'int16_t', 'float64_t', '', ''),
+        ('int32', 'int32', 'int32_t', 'int32_t', '', ''),
+        ('int32', 'int64', 'int32_t', 'int64_t', '', ''),
+        ('int32', 'float64', 'int32_t', 'float64_t', '', ''),
+        ('int64', 'int64', 'int64_t', 'int64_t', '', ''),
+        ('int64', 'float64', 'int64_t', 'float64_t', '', ''),
+        ('float32', 'float32', 'float32_t', 'float32_t', '', ''),
+        ('float32', 'float64', 'float32_t', 'float64_t', '', ''),
+        ('float64', 'float64', 'float64_t', 'float64_t', '', ''),
+        ('object', 'object', 'object', 'object', '', '')
     ]
 
     output = StringIO()
     for (name, dest, c_type_in, c_type_out, 
-            preval, postval, can_hold_na) in function_list:
+         preval, postval) in function_list:
         if exclude is not None and name in exclude:
             continue
 
         func = template % {'name': name, 'dest': dest,
                            'c_type_in': c_type_in, 'c_type_out': c_type_out,
-                           'preval': preval, 'postval': postval,
-                           'raise_on_na': 'False' if can_hold_na else 'True'}
+                           'preval': preval, 'postval': postval}
         output.write(func)
     return output.getvalue()
 
diff --git a/pandas/src/generated.pyx b/pandas/src/generated.pyx
index 1723f2fb8..af79ebfc1 100644
--- a/pandas/src/generated.pyx
+++ b/pandas/src/generated.pyx
@@ -2208,21 +2208,13 @@ def take_1d_bool_bool(ndarray[uint8_t] values,
 
     n = len(indexer)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_bool_object(ndarray[uint8_t] values,
@@ -2235,21 +2227,13 @@ def take_1d_bool_object(ndarray[uint8_t] values,
 
     n = len(indexer)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = True if values[idx] > 0 else False
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = True if values[idx] > 0 else False
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = True if values[idx] > 0 else False
 
 @cython.wraparound(False)
 def take_1d_int8_int8(ndarray[int8_t] values,
@@ -2262,21 +2246,13 @@ def take_1d_int8_int8(ndarray[int8_t] values,
 
     n = len(indexer)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_int8_int32(ndarray[int8_t] values,
@@ -2289,21 +2265,13 @@ def take_1d_int8_int32(ndarray[int8_t] values,
 
     n = len(indexer)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_int8_int64(ndarray[int8_t] values,
@@ -2316,21 +2284,13 @@ def take_1d_int8_int64(ndarray[int8_t] values,
 
     n = len(indexer)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_int8_float64(ndarray[int8_t] values,
@@ -2343,21 +2303,13 @@ def take_1d_int8_float64(ndarray[int8_t] values,
 
     n = len(indexer)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_int16_int16(ndarray[int16_t] values,
@@ -2370,21 +2322,13 @@ def take_1d_int16_int16(ndarray[int16_t] values,
 
     n = len(indexer)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_int16_int32(ndarray[int16_t] values,
@@ -2397,21 +2341,13 @@ def take_1d_int16_int32(ndarray[int16_t] values,
 
     n = len(indexer)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_int16_int64(ndarray[int16_t] values,
@@ -2424,21 +2360,13 @@ def take_1d_int16_int64(ndarray[int16_t] values,
 
     n = len(indexer)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_int16_float64(ndarray[int16_t] values,
@@ -2451,21 +2379,13 @@ def take_1d_int16_float64(ndarray[int16_t] values,
 
     n = len(indexer)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_int32_int32(ndarray[int32_t] values,
@@ -2478,21 +2398,13 @@ def take_1d_int32_int32(ndarray[int32_t] values,
 
     n = len(indexer)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_int32_int64(ndarray[int32_t] values,
@@ -2505,21 +2417,13 @@ def take_1d_int32_int64(ndarray[int32_t] values,
 
     n = len(indexer)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_int32_float64(ndarray[int32_t] values,
@@ -2532,21 +2436,13 @@ def take_1d_int32_float64(ndarray[int32_t] values,
 
     n = len(indexer)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_int64_int64(ndarray[int64_t] values,
@@ -2559,21 +2455,13 @@ def take_1d_int64_int64(ndarray[int64_t] values,
 
     n = len(indexer)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_int64_float64(ndarray[int64_t] values,
@@ -2586,21 +2474,13 @@ def take_1d_int64_float64(ndarray[int64_t] values,
 
     n = len(indexer)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_float32_float32(ndarray[float32_t] values,
@@ -2613,21 +2493,13 @@ def take_1d_float32_float32(ndarray[float32_t] values,
 
     n = len(indexer)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_float32_float64(ndarray[float32_t] values,
@@ -2640,21 +2512,13 @@ def take_1d_float32_float64(ndarray[float32_t] values,
 
     n = len(indexer)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_float64_float64(ndarray[float64_t] values,
@@ -2667,21 +2531,13 @@ def take_1d_float64_float64(ndarray[float64_t] values,
 
     n = len(indexer)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 @cython.wraparound(False)
 def take_1d_object_object(ndarray[object] values,
@@ -2694,21 +2550,13 @@ def take_1d_object_object(ndarray[object] values,
 
     n = len(indexer)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                raise ValueError('No NA values allowed')
-            else:
-                outbuf[i] = values[idx]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                outbuf[i] = fv
-            else:
-                outbuf[i] = values[idx]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            outbuf[i] = fv
+        else:
+            outbuf[i] = values[idx]
 
 
 @cython.wraparound(False)
@@ -2724,25 +2572,15 @@ def take_2d_axis0_bool_bool(ndarray[uint8_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -2757,25 +2595,15 @@ def take_2d_axis0_bool_object(ndarray[uint8_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = True if values[idx, j] > 0 else False
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = True if values[idx, j] > 0 else False
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = True if values[idx, j] > 0 else False
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -2790,25 +2618,15 @@ def take_2d_axis0_int8_int8(ndarray[int8_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -2823,25 +2641,15 @@ def take_2d_axis0_int8_int32(ndarray[int8_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -2856,25 +2664,15 @@ def take_2d_axis0_int8_int64(ndarray[int8_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -2889,25 +2687,15 @@ def take_2d_axis0_int8_float64(ndarray[int8_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -2922,25 +2710,15 @@ def take_2d_axis0_int16_int16(ndarray[int16_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -2955,25 +2733,15 @@ def take_2d_axis0_int16_int32(ndarray[int16_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -2988,25 +2756,15 @@ def take_2d_axis0_int16_int64(ndarray[int16_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3021,25 +2779,15 @@ def take_2d_axis0_int16_float64(ndarray[int16_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3054,25 +2802,15 @@ def take_2d_axis0_int32_int32(ndarray[int32_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3087,25 +2825,15 @@ def take_2d_axis0_int32_int64(ndarray[int32_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3120,25 +2848,15 @@ def take_2d_axis0_int32_float64(ndarray[int32_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3153,25 +2871,15 @@ def take_2d_axis0_int64_int64(ndarray[int64_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3186,25 +2894,15 @@ def take_2d_axis0_int64_float64(ndarray[int64_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3219,25 +2917,15 @@ def take_2d_axis0_float32_float32(ndarray[float32_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3252,25 +2940,15 @@ def take_2d_axis0_float32_float64(ndarray[float32_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3285,25 +2963,15 @@ def take_2d_axis0_float64_float64(ndarray[float64_t, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3318,25 +2986,15 @@ def take_2d_axis0_object_object(ndarray[object, ndim=2] values,
     n = len(indexer)
     k = values.shape[1]
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = indexer[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    outbuf[i, j] = values[idx, j]
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = indexer[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                outbuf[i, j] = values[idx, j]
 
 
 @cython.wraparound(False)
@@ -3352,25 +3010,15 @@ def take_2d_axis1_bool_bool(ndarray[uint8_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if True and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3385,25 +3033,15 @@ def take_2d_axis1_bool_object(ndarray[uint8_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if False and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = True if values[i, idx] > 0 else False
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = True if values[i, idx] > 0 else False
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = True if values[i, idx] > 0 else False
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3418,25 +3056,15 @@ def take_2d_axis1_int8_int8(ndarray[int8_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if True and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3451,25 +3079,15 @@ def take_2d_axis1_int8_int32(ndarray[int8_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if True and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3484,25 +3102,15 @@ def take_2d_axis1_int8_int64(ndarray[int8_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if True and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3517,25 +3125,15 @@ def take_2d_axis1_int8_float64(ndarray[int8_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if False and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3550,25 +3148,15 @@ def take_2d_axis1_int16_int16(ndarray[int16_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if True and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3583,25 +3171,15 @@ def take_2d_axis1_int16_int32(ndarray[int16_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if True and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3616,25 +3194,15 @@ def take_2d_axis1_int16_int64(ndarray[int16_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if True and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3649,25 +3217,15 @@ def take_2d_axis1_int16_float64(ndarray[int16_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if False and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3682,25 +3240,15 @@ def take_2d_axis1_int32_int32(ndarray[int32_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if True and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3715,25 +3263,15 @@ def take_2d_axis1_int32_int64(ndarray[int32_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if True and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3748,25 +3286,15 @@ def take_2d_axis1_int32_float64(ndarray[int32_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if False and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3781,25 +3309,15 @@ def take_2d_axis1_int64_int64(ndarray[int64_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if True and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3814,25 +3332,15 @@ def take_2d_axis1_int64_float64(ndarray[int64_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if False and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3847,25 +3355,15 @@ def take_2d_axis1_float32_float32(ndarray[float32_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if False and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3880,25 +3378,15 @@ def take_2d_axis1_float32_float64(ndarray[float32_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if False and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3913,25 +3401,15 @@ def take_2d_axis1_float64_float64(ndarray[float64_t, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if False and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -3946,25 +3424,15 @@ def take_2d_axis1_object_object(ndarray[object, ndim=2] values,
     n = len(values)
     k = len(indexer)
 
-    if False and _checknan(fill_value):
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    raise ValueError('No NA values allowed')
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
-    else:
-        fv = fill_value
-        for j from 0 <= j < k:
-            idx = indexer[j]
-            if idx == -1:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = fv
-            else:
-                for i from 0 <= i < n:
-                    outbuf[i, j] = values[i, idx]
+    fv = fill_value
+    for j from 0 <= j < k:
+        idx = indexer[j]
+        if idx == -1:
+            for i from 0 <= i < n:
+                outbuf[i, j] = fv
+        else:
+            for i from 0 <= i < n:
+                outbuf[i, j] = values[i, idx]
 
 
 @cython.wraparound(False)
@@ -3982,31 +3450,18 @@ def take_2d_multi_bool_bool(ndarray[uint8_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4023,31 +3478,18 @@ def take_2d_multi_bool_object(ndarray[uint8_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = True if values[idx, idx1[j]] > 0 else False
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = True if values[idx, idx1[j]] > 0 else False
+                else:
+                    outbuf[i, j] = True if values[idx, idx1[j]] > 0 else False
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4064,31 +3506,18 @@ def take_2d_multi_int8_int8(ndarray[int8_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4105,31 +3534,18 @@ def take_2d_multi_int8_int32(ndarray[int8_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4146,31 +3562,18 @@ def take_2d_multi_int8_int64(ndarray[int8_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4187,31 +3590,18 @@ def take_2d_multi_int8_float64(ndarray[int8_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4228,31 +3618,18 @@ def take_2d_multi_int16_int16(ndarray[int16_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4269,31 +3646,18 @@ def take_2d_multi_int16_int32(ndarray[int16_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4310,31 +3674,18 @@ def take_2d_multi_int16_int64(ndarray[int16_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4351,31 +3702,18 @@ def take_2d_multi_int16_float64(ndarray[int16_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4392,31 +3730,18 @@ def take_2d_multi_int32_int32(ndarray[int32_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4433,31 +3758,18 @@ def take_2d_multi_int32_int64(ndarray[int32_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4474,31 +3786,18 @@ def take_2d_multi_int32_float64(ndarray[int32_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4515,31 +3814,18 @@ def take_2d_multi_int64_int64(ndarray[int64_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if True and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4556,31 +3842,18 @@ def take_2d_multi_int64_float64(ndarray[int64_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4597,31 +3870,18 @@ def take_2d_multi_float32_float32(ndarray[float32_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4638,31 +3898,18 @@ def take_2d_multi_float32_float64(ndarray[float32_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4679,31 +3926,18 @@ def take_2d_multi_float64_float64(ndarray[float64_t, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
@@ -4720,31 +3954,18 @@ def take_2d_multi_object_object(ndarray[object, ndim=2] values,
     n = len(idx0)
     k = len(idx1)
 
-    if False and _checknan(fill_value):
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
-                    raise ValueError('No NA values allowed')
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        raise ValueError('No NA values allowed')
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
-    else:
-        fv = fill_value
-        for i from 0 <= i < n:
-            idx = idx0[i]
-            if idx == -1:
-                for j from 0 <= j < k:
+    fv = fill_value
+    for i from 0 <= i < n:
+        idx = idx0[i]
+        if idx == -1:
+            for j from 0 <= j < k:
+                outbuf[i, j] = fv
+        else:
+            for j from 0 <= j < k:
+                if idx1[j] == -1:
                     outbuf[i, j] = fv
-            else:
-                for j from 0 <= j < k:
-                    if idx1[j] == -1:
-                        outbuf[i, j] = fv
-                    else:
-                        outbuf[i, j] = values[idx, idx1[j]]
+                else:
+                    outbuf[i, j] = values[idx, idx1[j]]
 
 
 @cython.boundscheck(False)
diff --git a/pandas/tools/merge.py b/pandas/tools/merge.py
index 6d6999679..b62e307b1 100644
--- a/pandas/tools/merge.py
+++ b/pandas/tools/merge.py
@@ -715,9 +715,7 @@ class _BlockJoinOperation(object):
         sofar = 0
         for unit, blk in merge_chunks:
             out_chunk = out[sofar: sofar + len(blk)]
-            com.take_fast(blk.values, unit.indexer,
-                          None, False, axis=self.axis,
-                          out=out_chunk)
+            com.take_nd(blk.values, unit.indexer, self.axis, out=out_chunk)
             sofar += len(blk)
 
         # does not sort
@@ -737,36 +735,24 @@ class _JoinUnit(object):
     @cache_readonly
     def mask_info(self):
         if self.indexer is None or not _may_need_upcasting(self.blocks):
-            mask = None
-            need_masking = False
+            return None
         else:
             mask = self.indexer == -1
-            need_masking = mask.any()
-
-        return mask, need_masking
-
-    @property
-    def need_masking(self):
-        return self.mask_info[1]
+            needs_masking = mask.any()
+            return (mask, needs_masking)
 
     def get_upcasted_blocks(self):
-        # will short-circuit and not compute lneed_masking if indexer is None
-        if self.need_masking:
+        # will short-circuit and not compute needs_masking if indexer is None
+        if self.mask_info is not None and self.mask_info[1]:
             return _upcast_blocks(self.blocks)
         return self.blocks
 
     def reindex_block(self, block, axis, ref_items, copy=True):
-        # still some inefficiency here for bool/int64 because in the case where
-        # no masking is needed, take_fast will recompute the mask
-
-        mask, need_masking = self.mask_info
-
         if self.indexer is None:
             result = block.copy() if copy else block
         else:
-            result = block.reindex_axis(self.indexer, mask, need_masking,
-                                        axis=axis)
-
+            result = block.reindex_axis(self.indexer, axis=axis,
+                                        mask_info=self.mask_info)
         result.ref_items = ref_items
         return result
 

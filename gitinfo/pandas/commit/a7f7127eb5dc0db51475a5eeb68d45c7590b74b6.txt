commit a7f7127eb5dc0db51475a5eeb68d45c7590b74b6
Author: Jeff Reback <jeff@reback.net>
Date:   Sat Feb 4 11:31:12 2017 -0500

    TST: making test files a bit more balanced
    TST: move parts of test_datetimelike.py to indexes/datetimes

diff --git a/pandas/sparse/tests/test_frame.py b/pandas/sparse/tests/test_frame.py
index b9e8a3139..23bb82797 100644
--- a/pandas/sparse/tests/test_frame.py
+++ b/pandas/sparse/tests/test_frame.py
@@ -705,6 +705,50 @@ class TestSparseDataFrame(tm.TestCase, SharedWithSparse):
         tm.assert_frame_equal(sparse.fillna(-1).to_dense(),
                               df.fillna(-1), check_dtype=False)
 
+    def test_sparse_frame_pad_backfill_limit(self):
+        index = np.arange(10)
+        df = DataFrame(np.random.randn(10, 4), index=index)
+        sdf = df.to_sparse()
+
+        result = sdf[:2].reindex(index, method='pad', limit=5)
+
+        expected = sdf[:2].reindex(index).fillna(method='pad')
+        expected = expected.to_dense()
+        expected.values[-3:] = np.nan
+        expected = expected.to_sparse()
+        tm.assert_frame_equal(result, expected)
+
+        result = sdf[-2:].reindex(index, method='backfill', limit=5)
+
+        expected = sdf[-2:].reindex(index).fillna(method='backfill')
+        expected = expected.to_dense()
+        expected.values[:3] = np.nan
+        expected = expected.to_sparse()
+        tm.assert_frame_equal(result, expected)
+
+    def test_sparse_frame_fillna_limit(self):
+        index = np.arange(10)
+        df = DataFrame(np.random.randn(10, 4), index=index)
+        sdf = df.to_sparse()
+
+        result = sdf[:2].reindex(index)
+        result = result.fillna(method='pad', limit=5)
+
+        expected = sdf[:2].reindex(index).fillna(method='pad')
+        expected = expected.to_dense()
+        expected.values[-3:] = np.nan
+        expected = expected.to_sparse()
+        tm.assert_frame_equal(result, expected)
+
+        result = sdf[-2:].reindex(index)
+        result = result.fillna(method='backfill', limit=5)
+
+        expected = sdf[-2:].reindex(index).fillna(method='backfill')
+        expected = expected.to_dense()
+        expected.values[:3] = np.nan
+        expected = expected.to_sparse()
+        tm.assert_frame_equal(result, expected)
+
     def test_rename(self):
         # just check this works
         renamed = self.frame.rename(index=str)  # noqa
diff --git a/pandas/tests/frame/test_missing.py b/pandas/tests/frame/test_missing.py
index c4f037e85..a8c9c7295 100644
--- a/pandas/tests/frame/test_missing.py
+++ b/pandas/tests/frame/test_missing.py
@@ -322,6 +322,40 @@ class TestDataFrameMissingData(tm.TestCase, TestData):
         assert_frame_equal(self.tsframe.bfill(),
                            self.tsframe.fillna(method='bfill'))
 
+    def test_frame_pad_backfill_limit(self):
+        index = np.arange(10)
+        df = DataFrame(np.random.randn(10, 4), index=index)
+
+        result = df[:2].reindex(index, method='pad', limit=5)
+
+        expected = df[:2].reindex(index).fillna(method='pad')
+        expected.values[-3:] = np.nan
+        tm.assert_frame_equal(result, expected)
+
+        result = df[-2:].reindex(index, method='backfill', limit=5)
+
+        expected = df[-2:].reindex(index).fillna(method='backfill')
+        expected.values[:3] = np.nan
+        tm.assert_frame_equal(result, expected)
+
+    def test_frame_fillna_limit(self):
+        index = np.arange(10)
+        df = DataFrame(np.random.randn(10, 4), index=index)
+
+        result = df[:2].reindex(index)
+        result = result.fillna(method='pad', limit=5)
+
+        expected = df[:2].reindex(index).fillna(method='pad')
+        expected.values[-3:] = np.nan
+        tm.assert_frame_equal(result, expected)
+
+        result = df[-2:].reindex(index)
+        result = result.fillna(method='backfill', limit=5)
+
+        expected = df[-2:].reindex(index).fillna(method='backfill')
+        expected.values[:3] = np.nan
+        tm.assert_frame_equal(result, expected)
+
     def test_fillna_skip_certain_blocks(self):
         # don't try to fill boolean, int blocks
 
diff --git a/pandas/tests/frame/test_timeseries.py b/pandas/tests/frame/test_timeseries.py
index 85967e9ed..934aafc50 100644
--- a/pandas/tests/frame/test_timeseries.py
+++ b/pandas/tests/frame/test_timeseries.py
@@ -8,7 +8,9 @@ from numpy import nan
 from numpy.random import randn
 import numpy as np
 
-from pandas import DataFrame, Series, Index, Timestamp, DatetimeIndex
+from pandas import (DataFrame, Series, Index,
+                    Timestamp, DatetimeIndex,
+                    to_datetime, date_range)
 import pandas as pd
 import pandas.tseries.offsets as offsets
 
@@ -117,6 +119,60 @@ class TestDataFrameTimeSeriesMethods(tm.TestCase, TestData):
         edf = DataFrame({'a': expected, 'b': expected})
         assert_frame_equal(chg, edf)
 
+    def test_frame_ctor_datetime64_column(self):
+        rng = date_range('1/1/2000 00:00:00', '1/1/2000 1:59:50', freq='10s')
+        dates = np.asarray(rng)
+
+        df = DataFrame({'A': np.random.randn(len(rng)), 'B': dates})
+        self.assertTrue(np.issubdtype(df['B'].dtype, np.dtype('M8[ns]')))
+
+    def test_frame_add_datetime64_column(self):
+        rng = date_range('1/1/2000 00:00:00', '1/1/2000 1:59:50', freq='10s')
+        df = DataFrame(index=np.arange(len(rng)))
+
+        df['A'] = rng
+        self.assertTrue(np.issubdtype(df['A'].dtype, np.dtype('M8[ns]')))
+
+    def test_frame_datetime64_pre1900_repr(self):
+        df = DataFrame({'year': date_range('1/1/1700', periods=50,
+                                           freq='A-DEC')})
+        # it works!
+        repr(df)
+
+    def test_frame_add_datetime64_col_other_units(self):
+        n = 100
+
+        units = ['h', 'm', 's', 'ms', 'D', 'M', 'Y']
+
+        ns_dtype = np.dtype('M8[ns]')
+
+        for unit in units:
+            dtype = np.dtype('M8[%s]' % unit)
+            vals = np.arange(n, dtype=np.int64).view(dtype)
+
+            df = DataFrame({'ints': np.arange(n)}, index=np.arange(n))
+            df[unit] = vals
+
+            ex_vals = to_datetime(vals.astype('O')).values
+
+            self.assertEqual(df[unit].dtype, ns_dtype)
+            self.assertTrue((df[unit].values == ex_vals).all())
+
+        # Test insertion into existing datetime64 column
+        df = DataFrame({'ints': np.arange(n)}, index=np.arange(n))
+        df['dates'] = np.arange(n, dtype=np.int64).view(ns_dtype)
+
+        for unit in units:
+            dtype = np.dtype('M8[%s]' % unit)
+            vals = np.arange(n, dtype=np.int64).view(dtype)
+
+            tmp = df.copy()
+
+            tmp['dates'] = vals
+            ex_vals = to_datetime(vals.astype('O')).values
+
+            self.assertTrue((tmp['dates'].values == ex_vals).all())
+
     def test_shift(self):
         # naive shift
         shiftedFrame = self.tsframe.shift(5)
diff --git a/pandas/tests/indexes/datetimelike.py b/pandas/tests/indexes/datetimelike.py
new file mode 100644
index 000000000..964511a2e
--- /dev/null
+++ b/pandas/tests/indexes/datetimelike.py
@@ -0,0 +1,40 @@
+""" generic datetimelike tests """
+
+from .common import Base
+import pandas.util.testing as tm
+
+
+class DatetimeLike(Base):
+
+    def test_shift_identity(self):
+
+        idx = self.create_index()
+        self.assert_index_equal(idx, idx.shift(0))
+
+    def test_str(self):
+
+        # test the string repr
+        idx = self.create_index()
+        idx.name = 'foo'
+        self.assertFalse("length=%s" % len(idx) in str(idx))
+        self.assertTrue("'foo'" in str(idx))
+        self.assertTrue(idx.__class__.__name__ in str(idx))
+
+        if hasattr(idx, 'tz'):
+            if idx.tz is not None:
+                self.assertTrue(idx.tz in str(idx))
+        if hasattr(idx, 'freq'):
+            self.assertTrue("freq='%s'" % idx.freqstr in str(idx))
+
+    def test_view(self):
+        super(DatetimeLike, self).test_view()
+
+        i = self.create_index()
+
+        i_view = i.view('i8')
+        result = self._holder(i)
+        tm.assert_index_equal(result, i)
+
+        i_view = i.view(self._holder)
+        result = self._holder(i)
+        tm.assert_index_equal(result, i_view)
diff --git a/pandas/tests/indexes/datetimes/test_astype.py b/pandas/tests/indexes/datetimes/test_astype.py
index f64d18a69..d452a7e18 100644
--- a/pandas/tests/indexes/datetimes/test_astype.py
+++ b/pandas/tests/indexes/datetimes/test_astype.py
@@ -1,5 +1,6 @@
 import numpy as np
 
+from datetime import datetime
 import pandas as pd
 import pandas.util.testing as tm
 from pandas import (DatetimeIndex, date_range, Series, NaT, Index, Timestamp,
@@ -120,3 +121,64 @@ class TestDatetimeIndex(tm.TestCase):
         self.assertRaises(ValueError, idx.astype, 'timedelta64[ns]')
         self.assertRaises(ValueError, idx.astype, 'datetime64')
         self.assertRaises(ValueError, idx.astype, 'datetime64[D]')
+
+    def test_index_convert_to_datetime_array(self):
+        tm._skip_if_no_pytz()
+
+        def _check_rng(rng):
+            converted = rng.to_pydatetime()
+            tm.assertIsInstance(converted, np.ndarray)
+            for x, stamp in zip(converted, rng):
+                tm.assertIsInstance(x, datetime)
+                self.assertEqual(x, stamp.to_pydatetime())
+                self.assertEqual(x.tzinfo, stamp.tzinfo)
+
+        rng = date_range('20090415', '20090519')
+        rng_eastern = date_range('20090415', '20090519', tz='US/Eastern')
+        rng_utc = date_range('20090415', '20090519', tz='utc')
+
+        _check_rng(rng)
+        _check_rng(rng_eastern)
+        _check_rng(rng_utc)
+
+    def test_index_convert_to_datetime_array_explicit_pytz(self):
+        tm._skip_if_no_pytz()
+        import pytz
+
+        def _check_rng(rng):
+            converted = rng.to_pydatetime()
+            tm.assertIsInstance(converted, np.ndarray)
+            for x, stamp in zip(converted, rng):
+                tm.assertIsInstance(x, datetime)
+                self.assertEqual(x, stamp.to_pydatetime())
+                self.assertEqual(x.tzinfo, stamp.tzinfo)
+
+        rng = date_range('20090415', '20090519')
+        rng_eastern = date_range('20090415', '20090519',
+                                 tz=pytz.timezone('US/Eastern'))
+        rng_utc = date_range('20090415', '20090519', tz=pytz.utc)
+
+        _check_rng(rng)
+        _check_rng(rng_eastern)
+        _check_rng(rng_utc)
+
+    def test_index_convert_to_datetime_array_dateutil(self):
+        tm._skip_if_no_dateutil()
+        import dateutil
+
+        def _check_rng(rng):
+            converted = rng.to_pydatetime()
+            tm.assertIsInstance(converted, np.ndarray)
+            for x, stamp in zip(converted, rng):
+                tm.assertIsInstance(x, datetime)
+                self.assertEqual(x, stamp.to_pydatetime())
+                self.assertEqual(x.tzinfo, stamp.tzinfo)
+
+        rng = date_range('20090415', '20090519')
+        rng_eastern = date_range('20090415', '20090519',
+                                 tz='dateutil/US/Eastern')
+        rng_utc = date_range('20090415', '20090519', tz=dateutil.tz.tzutc())
+
+        _check_rng(rng)
+        _check_rng(rng_eastern)
+        _check_rng(rng_utc)
diff --git a/pandas/tests/indexes/datetimes/test_construction.py b/pandas/tests/indexes/datetimes/test_construction.py
index f8eca0f0d..03bc0e0c5 100644
--- a/pandas/tests/indexes/datetimes/test_construction.py
+++ b/pandas/tests/indexes/datetimes/test_construction.py
@@ -2,6 +2,7 @@ import numpy as np
 from datetime import timedelta
 
 import pandas as pd
+from pandas import tslib
 import pandas.util.testing as tm
 from pandas.tslib import OutOfBoundsDatetime
 from pandas import (DatetimeIndex, Index, Timestamp, datetime, date_range,
@@ -477,6 +478,22 @@ class TestTimeSeries(tm.TestCase):
             tm.assert_index_equal(DatetimeIndex(values), base)
             tm.assert_index_equal(to_datetime(values), base)
 
+    def test_ctor_str_intraday(self):
+        rng = DatetimeIndex(['1-1-2000 00:00:01'])
+        self.assertEqual(rng[0].second, 1)
+
+    def test_is_(self):
+        dti = DatetimeIndex(start='1/1/2005', end='12/1/2005', freq='M')
+        self.assertTrue(dti.is_(dti))
+        self.assertTrue(dti.is_(dti.view()))
+        self.assertFalse(dti.is_(dti.copy()))
+
+    def test_index_cast_datetime64_other_units(self):
+        arr = np.arange(0, 100, 10, dtype=np.int64).view('M8[D]')
+        idx = Index(arr)
+
+        self.assertTrue((idx.values == tslib.cast_to_nanoseconds(arr)).all())
+
     def test_constructor_int64_nocopy(self):
         # #1624
         arr = np.arange(1000, dtype=np.int64)
diff --git a/pandas/tests/indexes/datetimes/test_datetime.py b/pandas/tests/indexes/datetimes/test_datetime.py
index f92fca6ec..628cb9df9 100644
--- a/pandas/tests/indexes/datetimes/test_datetime.py
+++ b/pandas/tests/indexes/datetimes/test_datetime.py
@@ -94,6 +94,14 @@ class TestDatetimeIndex(tm.TestCase):
         with tm.assertRaises(ValueError):
             idx.get_indexer(idx[[0]], method='nearest', tolerance='foo')
 
+    def test_reasonable_keyerror(self):
+        # GH #1062
+        index = DatetimeIndex(['1/3/2000'])
+        try:
+            index.get_loc('1/1/2000')
+        except KeyError as e:
+            self.assertIn('2000', str(e))
+
     def test_roundtrip_pickle_with_tz(self):
 
         # GH 8367
diff --git a/pandas/tests/indexes/datetimes/test_datetimelike.py b/pandas/tests/indexes/datetimes/test_datetimelike.py
new file mode 100644
index 000000000..b32801a8b
--- /dev/null
+++ b/pandas/tests/indexes/datetimes/test_datetimelike.py
@@ -0,0 +1,76 @@
+""" generic tests from the Datetimelike class """
+
+import numpy as np
+import pandas as pd
+from pandas.util import testing as tm
+from pandas import Series, Index, DatetimeIndex, date_range
+
+from ..datetimelike import DatetimeLike
+
+class TestDatetimeIndex(DatetimeLike, tm.TestCase):
+    _holder = DatetimeIndex
+    _multiprocess_can_split_ = True
+
+    def setUp(self):
+        self.indices = dict(index=tm.makeDateIndex(10))
+        self.setup_indices()
+
+    def create_index(self):
+        return date_range('20130101', periods=5)
+
+    def test_shift(self):
+
+        # test shift for datetimeIndex and non datetimeIndex
+        # GH8083
+
+        drange = self.create_index()
+        result = drange.shift(1)
+        expected = DatetimeIndex(['2013-01-02', '2013-01-03', '2013-01-04',
+                                  '2013-01-05',
+                                  '2013-01-06'], freq='D')
+        self.assert_index_equal(result, expected)
+
+        result = drange.shift(-1)
+        expected = DatetimeIndex(['2012-12-31', '2013-01-01', '2013-01-02',
+                                  '2013-01-03', '2013-01-04'],
+                                 freq='D')
+        self.assert_index_equal(result, expected)
+
+        result = drange.shift(3, freq='2D')
+        expected = DatetimeIndex(['2013-01-07', '2013-01-08', '2013-01-09',
+                                  '2013-01-10',
+                                  '2013-01-11'], freq='D')
+        self.assert_index_equal(result, expected)
+
+    def test_pickle_compat_construction(self):
+        pass
+
+    def test_intersection(self):
+        first = self.index
+        second = self.index[5:]
+        intersect = first.intersection(second)
+        self.assertTrue(tm.equalContents(intersect, second))
+
+        # GH 10149
+        cases = [klass(second.values) for klass in [np.array, Series, list]]
+        for case in cases:
+            result = first.intersection(case)
+            self.assertTrue(tm.equalContents(result, second))
+
+        third = Index(['a', 'b', 'c'])
+        result = first.intersection(third)
+        expected = pd.Index([], dtype=object)
+        self.assert_index_equal(result, expected)
+
+    def test_union(self):
+        first = self.index[:5]
+        second = self.index[5:]
+        everything = self.index
+        union = first.union(second)
+        self.assertTrue(tm.equalContents(union, everything))
+
+        # GH 10149
+        cases = [klass(second.values) for klass in [np.array, Series, list]]
+        for case in cases:
+            result = first.union(case)
+            self.assertTrue(tm.equalContents(result, everything))
diff --git a/pandas/tests/indexes/datetimes/test_misc.py b/pandas/tests/indexes/datetimes/test_misc.py
index 4685df580..92aad5a0b 100644
--- a/pandas/tests/indexes/datetimes/test_misc.py
+++ b/pandas/tests/indexes/datetimes/test_misc.py
@@ -4,8 +4,9 @@ import pandas as pd
 import pandas.lib as lib
 import pandas.util.testing as tm
 from pandas import (Index, DatetimeIndex, datetime, offsets, to_datetime,
-                    Series, DataFrame, Float64Index, date_range, Timestamp)
-
+                    Series, DataFrame, Float64Index, date_range,
+                    Timestamp, isnull)
+from pandas import tslib
 from pandas.util.testing import assert_series_equal
 
 
@@ -143,6 +144,63 @@ class TestTimeSeries(tm.TestCase):
         expected = rng.shift(-5)
         tm.assert_index_equal(result, expected)
 
+    def test_string_na_nat_conversion(self):
+        # GH #999, #858
+
+        from pandas.compat import parse_date
+
+        strings = np.array(['1/1/2000', '1/2/2000', np.nan,
+                            '1/4/2000, 12:34:56'], dtype=object)
+
+        expected = np.empty(4, dtype='M8[ns]')
+        for i, val in enumerate(strings):
+            if isnull(val):
+                expected[i] = tslib.iNaT
+            else:
+                expected[i] = parse_date(val)
+
+        result = tslib.array_to_datetime(strings)
+        tm.assert_almost_equal(result, expected)
+
+        result2 = to_datetime(strings)
+        tm.assertIsInstance(result2, DatetimeIndex)
+        tm.assert_numpy_array_equal(result, result2.values)
+
+        malformed = np.array(['1/100/2000', np.nan], dtype=object)
+
+        # GH 10636, default is now 'raise'
+        self.assertRaises(ValueError,
+                          lambda: to_datetime(malformed, errors='raise'))
+
+        result = to_datetime(malformed, errors='ignore')
+        tm.assert_numpy_array_equal(result, malformed)
+
+        self.assertRaises(ValueError, to_datetime, malformed, errors='raise')
+
+        idx = ['a', 'b', 'c', 'd', 'e']
+        series = Series(['1/1/2000', np.nan, '1/3/2000', np.nan,
+                         '1/5/2000'], index=idx, name='foo')
+        dseries = Series([to_datetime('1/1/2000'), np.nan,
+                          to_datetime('1/3/2000'), np.nan,
+                          to_datetime('1/5/2000')], index=idx, name='foo')
+
+        result = to_datetime(series)
+        dresult = to_datetime(dseries)
+
+        expected = Series(np.empty(5, dtype='M8[ns]'), index=idx)
+        for i in range(5):
+            x = series[i]
+            if isnull(x):
+                expected[i] = tslib.iNaT
+            else:
+                expected[i] = to_datetime(x)
+
+        assert_series_equal(result, expected, check_names=False)
+        self.assertEqual(result.name, 'foo')
+
+        assert_series_equal(dresult, expected, check_names=False)
+        self.assertEqual(dresult.name, 'foo')
+
     def test_datetimeindex_repr_short(self):
         dr = date_range(start='1/1/2012', periods=1)
         repr(dr)
diff --git a/pandas/tests/indexes/test_datetimelike.py b/pandas/tests/indexes/test_datetimelike.py
index 32e4029a5..e5a4ced4c 100644
--- a/pandas/tests/indexes/test_datetimelike.py
+++ b/pandas/tests/indexes/test_datetimelike.py
@@ -4,119 +4,14 @@ import numpy as np
 from datetime import timedelta
 
 import pandas as pd
-import pandas.util.testing as tm
+from pandas.util import testing as tm
 from pandas import (DatetimeIndex, Float64Index, Index, Int64Index,
                     NaT, Period, PeriodIndex, Series, Timedelta,
-                    TimedeltaIndex, date_range, period_range,
+                    TimedeltaIndex, period_range,
                     timedelta_range, notnull)
 
 
-from .common import Base
-
-
-class DatetimeLike(Base):
-
-    def test_shift_identity(self):
-
-        idx = self.create_index()
-        self.assert_index_equal(idx, idx.shift(0))
-
-    def test_str(self):
-
-        # test the string repr
-        idx = self.create_index()
-        idx.name = 'foo'
-        self.assertFalse("length=%s" % len(idx) in str(idx))
-        self.assertTrue("'foo'" in str(idx))
-        self.assertTrue(idx.__class__.__name__ in str(idx))
-
-        if hasattr(idx, 'tz'):
-            if idx.tz is not None:
-                self.assertTrue(idx.tz in str(idx))
-        if hasattr(idx, 'freq'):
-            self.assertTrue("freq='%s'" % idx.freqstr in str(idx))
-
-    def test_view(self):
-        super(DatetimeLike, self).test_view()
-
-        i = self.create_index()
-
-        i_view = i.view('i8')
-        result = self._holder(i)
-        tm.assert_index_equal(result, i)
-
-        i_view = i.view(self._holder)
-        result = self._holder(i)
-        tm.assert_index_equal(result, i_view)
-
-
-class TestDatetimeIndex(DatetimeLike, tm.TestCase):
-    _holder = DatetimeIndex
-    _multiprocess_can_split_ = True
-
-    def setUp(self):
-        self.indices = dict(index=tm.makeDateIndex(10))
-        self.setup_indices()
-
-    def create_index(self):
-        return date_range('20130101', periods=5)
-
-    def test_shift(self):
-
-        # test shift for datetimeIndex and non datetimeIndex
-        # GH8083
-
-        drange = self.create_index()
-        result = drange.shift(1)
-        expected = DatetimeIndex(['2013-01-02', '2013-01-03', '2013-01-04',
-                                  '2013-01-05',
-                                  '2013-01-06'], freq='D')
-        self.assert_index_equal(result, expected)
-
-        result = drange.shift(-1)
-        expected = DatetimeIndex(['2012-12-31', '2013-01-01', '2013-01-02',
-                                  '2013-01-03', '2013-01-04'],
-                                 freq='D')
-        self.assert_index_equal(result, expected)
-
-        result = drange.shift(3, freq='2D')
-        expected = DatetimeIndex(['2013-01-07', '2013-01-08', '2013-01-09',
-                                  '2013-01-10',
-                                  '2013-01-11'], freq='D')
-        self.assert_index_equal(result, expected)
-
-    def test_pickle_compat_construction(self):
-        pass
-
-    def test_intersection(self):
-        first = self.index
-        second = self.index[5:]
-        intersect = first.intersection(second)
-        self.assertTrue(tm.equalContents(intersect, second))
-
-        # GH 10149
-        cases = [klass(second.values) for klass in [np.array, Series, list]]
-        for case in cases:
-            result = first.intersection(case)
-            self.assertTrue(tm.equalContents(result, second))
-
-        third = Index(['a', 'b', 'c'])
-        result = first.intersection(third)
-        expected = pd.Index([], dtype=object)
-        self.assert_index_equal(result, expected)
-
-    def test_union(self):
-        first = self.index[:5]
-        second = self.index[5:]
-        everything = self.index
-        union = first.union(second)
-        self.assertTrue(tm.equalContents(union, everything))
-
-        # GH 10149
-        cases = [klass(second.values) for klass in [np.array, Series, list]]
-        for case in cases:
-            result = first.union(case)
-            self.assertTrue(tm.equalContents(result, everything))
+from .datetimelike import DatetimeLike
 
 
 class TestPeriodIndex(DatetimeLike, tm.TestCase):
diff --git a/pandas/tests/scalar/test_timestamp.py b/pandas/tests/scalar/test_timestamp.py
index 94369ebbd..f686f1aa6 100644
--- a/pandas/tests/scalar/test_timestamp.py
+++ b/pandas/tests/scalar/test_timestamp.py
@@ -566,6 +566,65 @@ class TestTimestamp(tm.TestCase):
         self.assertTrue(np.isnan(ts.daysinmonth))
         self.assertTrue(np.isnan(ts.days_in_month))
 
+    def test_nat_vector_field_access(self):
+        idx = DatetimeIndex(['1/1/2000', None, None, '1/4/2000'])
+
+        fields = ['year', 'quarter', 'month', 'day', 'hour', 'minute',
+                  'second', 'microsecond', 'nanosecond', 'week', 'dayofyear',
+                  'days_in_month', 'is_leap_year']
+
+        for field in fields:
+            result = getattr(idx, field)
+            expected = [getattr(x, field) for x in idx]
+            self.assert_numpy_array_equal(result, np.array(expected))
+
+        s = pd.Series(idx)
+
+        for field in fields:
+            result = getattr(s.dt, field)
+            expected = [getattr(x, field) for x in idx]
+            self.assert_series_equal(result, pd.Series(expected))
+
+    def test_nat_scalar_field_access(self):
+        fields = ['year', 'quarter', 'month', 'day', 'hour', 'minute',
+                  'second', 'microsecond', 'nanosecond', 'week', 'dayofyear',
+                  'days_in_month', 'daysinmonth', 'dayofweek', 'weekday_name']
+        for field in fields:
+            result = getattr(NaT, field)
+            self.assertTrue(np.isnan(result))
+
+    def test_NaT_methods(self):
+        # GH 9513
+        raise_methods = ['astimezone', 'combine', 'ctime', 'dst',
+                         'fromordinal', 'fromtimestamp', 'isocalendar',
+                         'strftime', 'strptime', 'time', 'timestamp',
+                         'timetuple', 'timetz', 'toordinal', 'tzname',
+                         'utcfromtimestamp', 'utcnow', 'utcoffset',
+                         'utctimetuple']
+        nat_methods = ['date', 'now', 'replace', 'to_datetime', 'today']
+        nan_methods = ['weekday', 'isoweekday']
+
+        for method in raise_methods:
+            if hasattr(NaT, method):
+                self.assertRaises(ValueError, getattr(NaT, method))
+
+        for method in nan_methods:
+            if hasattr(NaT, method):
+                self.assertTrue(np.isnan(getattr(NaT, method)()))
+
+        for method in nat_methods:
+            if hasattr(NaT, method):
+                # see gh-8254
+                exp_warning = None
+                if method == 'to_datetime':
+                    exp_warning = FutureWarning
+                with tm.assert_produces_warning(
+                        exp_warning, check_stacklevel=False):
+                    self.assertIs(getattr(NaT, method)(), NaT)
+
+        # GH 12300
+        self.assertEqual(NaT.isoformat(), 'NaT')
+
     def test_pprint(self):
         # GH12622
         import pprint
diff --git a/pandas/tests/series/test_indexing.py b/pandas/tests/series/test_indexing.py
index e6209a853..d4b6e7dd5 100644
--- a/pandas/tests/series/test_indexing.py
+++ b/pandas/tests/series/test_indexing.py
@@ -346,6 +346,135 @@ class TestSeriesIndexing(TestData, tm.TestCase):
         self.assertTrue((s[:4] == 0).all())
         self.assertTrue(not (s[4:] == 0).any())
 
+    def test_getitem_setitem_datetime_tz_pytz(self):
+        tm._skip_if_no_pytz()
+        from pytz import timezone as tz
+
+        from pandas import date_range
+
+        N = 50
+        # testing with timezone, GH #2785
+        rng = date_range('1/1/1990', periods=N, freq='H', tz='US/Eastern')
+        ts = Series(np.random.randn(N), index=rng)
+
+        # also test Timestamp tz handling, GH #2789
+        result = ts.copy()
+        result["1990-01-01 09:00:00+00:00"] = 0
+        result["1990-01-01 09:00:00+00:00"] = ts[4]
+        assert_series_equal(result, ts)
+
+        result = ts.copy()
+        result["1990-01-01 03:00:00-06:00"] = 0
+        result["1990-01-01 03:00:00-06:00"] = ts[4]
+        assert_series_equal(result, ts)
+
+        # repeat with datetimes
+        result = ts.copy()
+        result[datetime(1990, 1, 1, 9, tzinfo=tz('UTC'))] = 0
+        result[datetime(1990, 1, 1, 9, tzinfo=tz('UTC'))] = ts[4]
+        assert_series_equal(result, ts)
+
+        result = ts.copy()
+
+        # comparison dates with datetime MUST be localized!
+        date = tz('US/Central').localize(datetime(1990, 1, 1, 3))
+        result[date] = 0
+        result[date] = ts[4]
+        assert_series_equal(result, ts)
+
+    def test_getitem_setitem_datetime_tz_dateutil(self):
+        tm._skip_if_no_dateutil()
+        from dateutil.tz import tzutc
+        from pandas.tslib import _dateutil_gettz as gettz
+
+        tz = lambda x: tzutc() if x == 'UTC' else gettz(
+            x)  # handle special case for utc in dateutil
+
+        from pandas import date_range
+
+        N = 50
+
+        # testing with timezone, GH #2785
+        rng = date_range('1/1/1990', periods=N, freq='H',
+                         tz='America/New_York')
+        ts = Series(np.random.randn(N), index=rng)
+
+        # also test Timestamp tz handling, GH #2789
+        result = ts.copy()
+        result["1990-01-01 09:00:00+00:00"] = 0
+        result["1990-01-01 09:00:00+00:00"] = ts[4]
+        assert_series_equal(result, ts)
+
+        result = ts.copy()
+        result["1990-01-01 03:00:00-06:00"] = 0
+        result["1990-01-01 03:00:00-06:00"] = ts[4]
+        assert_series_equal(result, ts)
+
+        # repeat with datetimes
+        result = ts.copy()
+        result[datetime(1990, 1, 1, 9, tzinfo=tz('UTC'))] = 0
+        result[datetime(1990, 1, 1, 9, tzinfo=tz('UTC'))] = ts[4]
+        assert_series_equal(result, ts)
+
+        result = ts.copy()
+        result[datetime(1990, 1, 1, 3, tzinfo=tz('America/Chicago'))] = 0
+        result[datetime(1990, 1, 1, 3, tzinfo=tz('America/Chicago'))] = ts[4]
+        assert_series_equal(result, ts)
+
+    def test_getitem_setitem_periodindex(self):
+        from pandas import period_range
+
+        N = 50
+        rng = period_range('1/1/1990', periods=N, freq='H')
+        ts = Series(np.random.randn(N), index=rng)
+
+        result = ts["1990-01-01 04"]
+        expected = ts[4]
+        self.assertEqual(result, expected)
+
+        result = ts.copy()
+        result["1990-01-01 04"] = 0
+        result["1990-01-01 04"] = ts[4]
+        assert_series_equal(result, ts)
+
+        result = ts["1990-01-01 04":"1990-01-01 07"]
+        expected = ts[4:8]
+        assert_series_equal(result, expected)
+
+        result = ts.copy()
+        result["1990-01-01 04":"1990-01-01 07"] = 0
+        result["1990-01-01 04":"1990-01-01 07"] = ts[4:8]
+        assert_series_equal(result, ts)
+
+        lb = "1990-01-01 04"
+        rb = "1990-01-01 07"
+        result = ts[(ts.index >= lb) & (ts.index <= rb)]
+        expected = ts[4:8]
+        assert_series_equal(result, expected)
+
+        # GH 2782
+        result = ts[ts.index[4]]
+        expected = ts[4]
+        self.assertEqual(result, expected)
+
+        result = ts[ts.index[4:8]]
+        expected = ts[4:8]
+        assert_series_equal(result, expected)
+
+        result = ts.copy()
+        result[ts.index[4:8]] = 0
+        result[4:8] = ts[4:8]
+        assert_series_equal(result, ts)
+
+    def test_getitem_median_slice_bug(self):
+        index = date_range('20090415', '20090519', freq='2B')
+        s = Series(np.random.randn(13), index=index)
+
+        indexer = [slice(6, 7, None)]
+        result = s[indexer]
+        expected = s[indexer[0]]
+        assert_series_equal(result, expected)
+
     def test_getitem_out_of_bounds(self):
         # don't segfault, GH #495
         self.assertRaises(IndexError, self.ts.__getitem__, len(self.ts))
diff --git a/pandas/tests/series/test_missing.py b/pandas/tests/series/test_missing.py
index 91da36161..8cf0d190a 100644
--- a/pandas/tests/series/test_missing.py
+++ b/pandas/tests/series/test_missing.py
@@ -8,11 +8,11 @@ from numpy import nan
 import numpy as np
 import pandas as pd
 
-from pandas import (Series, isnull, date_range,
-                    MultiIndex, Index)
-from pandas.tseries.index import Timestamp
+from pandas import (Series, DataFrame, isnull, date_range,
+                    MultiIndex, Index, Timestamp)
 from pandas.compat import range
-from pandas.util.testing import assert_series_equal
+from pandas import tslib
+from pandas.util.testing import assert_series_equal, assert_frame_equal
 import pandas.util.testing as tm
 
 from .common import TestData
@@ -283,6 +283,43 @@ class TestSeriesMissingData(TestData, tm.TestCase):
         self.assertRaises(TypeError, s.fillna, [1, 2])
         self.assertRaises(TypeError, s.fillna, (1, 2))
 
+    def test_fillna_nat(self):
+        series = Series([0, 1, 2, tslib.iNaT], dtype='M8[ns]')
+
+        filled = series.fillna(method='pad')
+        filled2 = series.fillna(value=series.values[2])
+
+        expected = series.copy()
+        expected.values[3] = expected.values[2]
+
+        assert_series_equal(filled, expected)
+        assert_series_equal(filled2, expected)
+
+        df = DataFrame({'A': series})
+        filled = df.fillna(method='pad')
+        filled2 = df.fillna(value=series.values[2])
+        expected = DataFrame({'A': expected})
+        assert_frame_equal(filled, expected)
+        assert_frame_equal(filled2, expected)
+
+        series = Series([tslib.iNaT, 0, 1, 2], dtype='M8[ns]')
+
+        filled = series.fillna(method='bfill')
+        filled2 = series.fillna(value=series[1])
+
+        expected = series.copy()
+        expected[0] = expected[1]
+
+        assert_series_equal(filled, expected)
+        assert_series_equal(filled2, expected)
+
+        df = DataFrame({'A': series})
+        filled = df.fillna(method='bfill')
+        filled2 = df.fillna(value=series[1])
+        expected = DataFrame({'A': expected})
+        assert_frame_equal(filled, expected)
+        assert_frame_equal(filled2, expected)
+
     def test_isnull_for_inf(self):
         s = Series(['a', np.inf, np.nan, 1.0])
         with pd.option_context('mode.use_inf_as_null', True):
@@ -518,6 +555,14 @@ class TestSeriesMissingData(TestData, tm.TestCase):
         assert_series_equal(x[1:], expected[1:])
         self.assertTrue(np.isnan(x[0]), np.isnan(expected[0]))
 
+    def test_pad_require_monotonicity(self):
+        rng = date_range('1/1/2000', '3/1/2000', freq='B')
+
+        # neither monotonic increasing or decreasing
+        rng2 = rng[[1, 0, 2]]
+
+        self.assertRaises(ValueError, rng2.get_indexer, rng, method='pad')
+
     def test_dropna_preserve_name(self):
         self.ts[:5] = np.nan
         result = self.ts.dropna()
diff --git a/pandas/tests/series/test_timeseries.py b/pandas/tests/series/test_timeseries.py
index 073b8bfee..571a802e3 100644
--- a/pandas/tests/series/test_timeseries.py
+++ b/pandas/tests/series/test_timeseries.py
@@ -230,126 +230,6 @@ class TestTimeSeries(TestData, tm.TestCase):
                           before=self.ts.index[-1] + offset,
                           after=self.ts.index[0] - offset)
 
-    def test_getitem_setitem_datetime_tz_pytz(self):
-        tm._skip_if_no_pytz()
-        from pytz import timezone as tz
-
-        from pandas import date_range
-
-        N = 50
-        # testing with timezone, GH #2785
-        rng = date_range('1/1/1990', periods=N, freq='H', tz='US/Eastern')
-        ts = Series(np.random.randn(N), index=rng)
-
-        # also test Timestamp tz handling, GH #2789
-        result = ts.copy()
-        result["1990-01-01 09:00:00+00:00"] = 0
-        result["1990-01-01 09:00:00+00:00"] = ts[4]
-        assert_series_equal(result, ts)
-
-        result = ts.copy()
-        result["1990-01-01 03:00:00-06:00"] = 0
-        result["1990-01-01 03:00:00-06:00"] = ts[4]
-        assert_series_equal(result, ts)
-
-        # repeat with datetimes
-        result = ts.copy()
-        result[datetime(1990, 1, 1, 9, tzinfo=tz('UTC'))] = 0
-        result[datetime(1990, 1, 1, 9, tzinfo=tz('UTC'))] = ts[4]
-        assert_series_equal(result, ts)
-
-        result = ts.copy()
-
-        # comparison dates with datetime MUST be localized!
-        date = tz('US/Central').localize(datetime(1990, 1, 1, 3))
-        result[date] = 0
-        result[date] = ts[4]
-        assert_series_equal(result, ts)
-
-    def test_getitem_setitem_datetime_tz_dateutil(self):
-        tm._skip_if_no_dateutil()
-        from dateutil.tz import tzutc
-        from pandas.tslib import _dateutil_gettz as gettz
-
-        tz = lambda x: tzutc() if x == 'UTC' else gettz(
-            x)  # handle special case for utc in dateutil
-
-        from pandas import date_range
-
-        N = 50
-
-        # testing with timezone, GH #2785
-        rng = date_range('1/1/1990', periods=N, freq='H',
-                         tz='America/New_York')
-        ts = Series(np.random.randn(N), index=rng)
-
-        # also test Timestamp tz handling, GH #2789
-        result = ts.copy()
-        result["1990-01-01 09:00:00+00:00"] = 0
-        result["1990-01-01 09:00:00+00:00"] = ts[4]
-        assert_series_equal(result, ts)
-
-        result = ts.copy()
-        result["1990-01-01 03:00:00-06:00"] = 0
-        result["1990-01-01 03:00:00-06:00"] = ts[4]
-        assert_series_equal(result, ts)
-
-        # repeat with datetimes
-        result = ts.copy()
-        result[datetime(1990, 1, 1, 9, tzinfo=tz('UTC'))] = 0
-        result[datetime(1990, 1, 1, 9, tzinfo=tz('UTC'))] = ts[4]
-        assert_series_equal(result, ts)
-
-        result = ts.copy()
-        result[datetime(1990, 1, 1, 3, tzinfo=tz('America/Chicago'))] = 0
-        result[datetime(1990, 1, 1, 3, tzinfo=tz('America/Chicago'))] = ts[4]
-        assert_series_equal(result, ts)
-
-    def test_getitem_setitem_periodindex(self):
-        from pandas import period_range
-
-        N = 50
-        rng = period_range('1/1/1990', periods=N, freq='H')
-        ts = Series(np.random.randn(N), index=rng)
-
-        result = ts["1990-01-01 04"]
-        expected = ts[4]
-        self.assertEqual(result, expected)
-
-        result = ts.copy()
-        result["1990-01-01 04"] = 0
-        result["1990-01-01 04"] = ts[4]
-        assert_series_equal(result, ts)
-
-        result = ts["1990-01-01 04":"1990-01-01 07"]
-        expected = ts[4:8]
-        assert_series_equal(result, expected)
-
-        result = ts.copy()
-        result["1990-01-01 04":"1990-01-01 07"] = 0
-        result["1990-01-01 04":"1990-01-01 07"] = ts[4:8]
-        assert_series_equal(result, ts)
-
-        lb = "1990-01-01 04"
-        rb = "1990-01-01 07"
-        result = ts[(ts.index >= lb) & (ts.index <= rb)]
-        expected = ts[4:8]
-        assert_series_equal(result, expected)
-
-        # GH 2782
-        result = ts[ts.index[4]]
-        expected = ts[4]
-        self.assertEqual(result, expected)
-
-        result = ts[ts.index[4:8]]
-        expected = ts[4:8]
-        assert_series_equal(result, expected)
-
-        result = ts.copy()
-        result[ts.index[4:8]] = 0
-        result[4:8] = ts[4:8]
-        assert_series_equal(result, ts)
-
     def test_asfreq(self):
         ts = Series([0., 1., 2.], index=[datetime(2009, 10, 30), datetime(
             2009, 11, 30), datetime(2009, 12, 31)])
@@ -513,12 +393,6 @@ class TestTimeSeries(TestData, tm.TestCase):
         assert_series_equal(a, b + a)
         self.assertRaises(TypeError, lambda x, y: x - y, b, a)
 
-    def test_is_(self):
-        dti = DatetimeIndex(start='1/1/2005', end='12/1/2005', freq='M')
-        self.assertTrue(dti.is_(dti))
-        self.assertTrue(dti.is_(dti.view()))
-        self.assertFalse(dti.is_(dti.copy()))
-
     def test_contiguous_boolean_preserve_freq(self):
         rng = date_range('1/1/2000', '3/1/2000', freq='B')
 
@@ -534,159 +408,6 @@ class TestTimeSeries(TestData, tm.TestCase):
         masked = rng[mask]
         self.assertIsNone(masked.freq)
 
-    def test_getitem_median_slice_bug(self):
-        index = date_range('20090415', '20090519', freq='2B')
-        s = Series(np.random.randn(13), index=index)
-
-        indexer = [slice(6, 7, None)]
-        result = s[indexer]
-        expected = s[indexer[0]]
-        assert_series_equal(result, expected)
-
-    def test_ctor_str_intraday(self):
-        rng = DatetimeIndex(['1-1-2000 00:00:01'])
-        self.assertEqual(rng[0].second, 1)
-
-    def test_frame_pad_backfill_limit(self):
-        index = np.arange(10)
-        df = DataFrame(np.random.randn(10, 4), index=index)
-
-        result = df[:2].reindex(index, method='pad', limit=5)
-
-        expected = df[:2].reindex(index).fillna(method='pad')
-        expected.values[-3:] = np.nan
-        tm.assert_frame_equal(result, expected)
-
-        result = df[-2:].reindex(index, method='backfill', limit=5)
-
-        expected = df[-2:].reindex(index).fillna(method='backfill')
-        expected.values[:3] = np.nan
-        tm.assert_frame_equal(result, expected)
-
-    def test_frame_fillna_limit(self):
-        index = np.arange(10)
-        df = DataFrame(np.random.randn(10, 4), index=index)
-
-        result = df[:2].reindex(index)
-        result = result.fillna(method='pad', limit=5)
-
-        expected = df[:2].reindex(index).fillna(method='pad')
-        expected.values[-3:] = np.nan
-        tm.assert_frame_equal(result, expected)
-
-        result = df[-2:].reindex(index)
-        result = result.fillna(method='backfill', limit=5)
-
-        expected = df[-2:].reindex(index).fillna(method='backfill')
-        expected.values[:3] = np.nan
-        tm.assert_frame_equal(result, expected)
-
-    def test_sparse_frame_pad_backfill_limit(self):
-        index = np.arange(10)
-        df = DataFrame(np.random.randn(10, 4), index=index)
-        sdf = df.to_sparse()
-
-        result = sdf[:2].reindex(index, method='pad', limit=5)
-
-        expected = sdf[:2].reindex(index).fillna(method='pad')
-        expected = expected.to_dense()
-        expected.values[-3:] = np.nan
-        expected = expected.to_sparse()
-        tm.assert_frame_equal(result, expected)
-
-        result = sdf[-2:].reindex(index, method='backfill', limit=5)
-
-        expected = sdf[-2:].reindex(index).fillna(method='backfill')
-        expected = expected.to_dense()
-        expected.values[:3] = np.nan
-        expected = expected.to_sparse()
-        tm.assert_frame_equal(result, expected)
-
-    def test_sparse_frame_fillna_limit(self):
-        index = np.arange(10)
-        df = DataFrame(np.random.randn(10, 4), index=index)
-        sdf = df.to_sparse()
-
-        result = sdf[:2].reindex(index)
-        result = result.fillna(method='pad', limit=5)
-
-        expected = sdf[:2].reindex(index).fillna(method='pad')
-        expected = expected.to_dense()
-        expected.values[-3:] = np.nan
-        expected = expected.to_sparse()
-        tm.assert_frame_equal(result, expected)
-
-        result = sdf[-2:].reindex(index)
-        result = result.fillna(method='backfill', limit=5)
-
-        expected = sdf[-2:].reindex(index).fillna(method='backfill')
-        expected = expected.to_dense()
-        expected.values[:3] = np.nan
-        expected = expected.to_sparse()
-        tm.assert_frame_equal(result, expected)
-
-    def test_pad_require_monotonicity(self):
-        rng = date_range('1/1/2000', '3/1/2000', freq='B')
-
-        # neither monotonic increasing or decreasing
-        rng2 = rng[[1, 0, 2]]
-
-        self.assertRaises(ValueError, rng2.get_indexer, rng, method='pad')
-
-    def test_frame_ctor_datetime64_column(self):
-        rng = date_range('1/1/2000 00:00:00', '1/1/2000 1:59:50', freq='10s')
-        dates = np.asarray(rng)
-
-        df = DataFrame({'A': np.random.randn(len(rng)), 'B': dates})
-        self.assertTrue(np.issubdtype(df['B'].dtype, np.dtype('M8[ns]')))
-
-    def test_frame_add_datetime64_column(self):
-        rng = date_range('1/1/2000 00:00:00', '1/1/2000 1:59:50', freq='10s')
-        df = DataFrame(index=np.arange(len(rng)))
-
-        df['A'] = rng
-        self.assertTrue(np.issubdtype(df['A'].dtype, np.dtype('M8[ns]')))
-
-    def test_frame_datetime64_pre1900_repr(self):
-        df = DataFrame({'year': date_range('1/1/1700', periods=50,
-                                           freq='A-DEC')})
-        # it works!
-        repr(df)
-
-    def test_frame_add_datetime64_col_other_units(self):
-        n = 100
-
-        units = ['h', 'm', 's', 'ms', 'D', 'M', 'Y']
-
-        ns_dtype = np.dtype('M8[ns]')
-
-        for unit in units:
-            dtype = np.dtype('M8[%s]' % unit)
-            vals = np.arange(n, dtype=np.int64).view(dtype)
-
-            df = DataFrame({'ints': np.arange(n)}, index=np.arange(n))
-            df[unit] = vals
-
-            ex_vals = to_datetime(vals.astype('O')).values
-
-            self.assertEqual(df[unit].dtype, ns_dtype)
-            self.assertTrue((df[unit].values == ex_vals).all())
-
-        # Test insertion into existing datetime64 column
-        df = DataFrame({'ints': np.arange(n)}, index=np.arange(n))
-        df['dates'] = np.arange(n, dtype=np.int64).view(ns_dtype)
-
-        for unit in units:
-            dtype = np.dtype('M8[%s]' % unit)
-            vals = np.arange(n, dtype=np.int64).view(dtype)
-
-            tmp = df.copy()
-
-            tmp['dates'] = vals
-            ex_vals = to_datetime(vals.astype('O')).values
-
-            self.assertTrue((tmp['dates'].values == ex_vals).all())
-
     def test_to_datetime_unit(self):
 
         epoch = 1370745748
@@ -756,13 +477,6 @@ class TestTimeSeries(TestData, tm.TestCase):
         series = Series(dates)
         self.assertTrue(np.issubdtype(series.dtype, np.dtype('M8[ns]')))
 
-    def test_index_cast_datetime64_other_units(self):
-        arr = np.arange(0, 100, 10, dtype=np.int64).view('M8[D]')
-
-        idx = Index(arr)
-
-        self.assertTrue((idx.values == tslib.cast_to_nanoseconds(arr)).all())
-
     def test_reindex_series_add_nat(self):
         rng = date_range('1/1/2000 00:00:00', periods=10, freq='10s')
         series = Series(rng)
@@ -796,159 +510,6 @@ class TestTimeSeries(TestData, tm.TestCase):
                     'dtype: datetime64[ns]')
         self.assertEqual(result, expected)
 
-    def test_fillna_nat(self):
-        series = Series([0, 1, 2, iNaT], dtype='M8[ns]')
-
-        filled = series.fillna(method='pad')
-        filled2 = series.fillna(value=series.values[2])
-
-        expected = series.copy()
-        expected.values[3] = expected.values[2]
-
-        assert_series_equal(filled, expected)
-        assert_series_equal(filled2, expected)
-
-        df = DataFrame({'A': series})
-        filled = df.fillna(method='pad')
-        filled2 = df.fillna(value=series.values[2])
-        expected = DataFrame({'A': expected})
-        assert_frame_equal(filled, expected)
-        assert_frame_equal(filled2, expected)
-
-        series = Series([iNaT, 0, 1, 2], dtype='M8[ns]')
-
-        filled = series.fillna(method='bfill')
-        filled2 = series.fillna(value=series[1])
-
-        expected = series.copy()
-        expected[0] = expected[1]
-
-        assert_series_equal(filled, expected)
-        assert_series_equal(filled2, expected)
-
-        df = DataFrame({'A': series})
-        filled = df.fillna(method='bfill')
-        filled2 = df.fillna(value=series[1])
-        expected = DataFrame({'A': expected})
-        assert_frame_equal(filled, expected)
-        assert_frame_equal(filled2, expected)
-
-    def test_string_na_nat_conversion(self):
-        # GH #999, #858
-
-        from pandas.compat import parse_date
-
-        strings = np.array(['1/1/2000', '1/2/2000', np.nan,
-                            '1/4/2000, 12:34:56'], dtype=object)
-
-        expected = np.empty(4, dtype='M8[ns]')
-        for i, val in enumerate(strings):
-            if com.isnull(val):
-                expected[i] = iNaT
-            else:
-                expected[i] = parse_date(val)
-
-        result = tslib.array_to_datetime(strings)
-        assert_almost_equal(result, expected)
-
-        result2 = to_datetime(strings)
-        tm.assertIsInstance(result2, DatetimeIndex)
-        tm.assert_numpy_array_equal(result, result2.values)
-
-        malformed = np.array(['1/100/2000', np.nan], dtype=object)
-
-        # GH 10636, default is now 'raise'
-        self.assertRaises(ValueError,
-                          lambda: to_datetime(malformed, errors='raise'))
-
-        result = to_datetime(malformed, errors='ignore')
-        tm.assert_numpy_array_equal(result, malformed)
-
-        self.assertRaises(ValueError, to_datetime, malformed, errors='raise')
-
-        idx = ['a', 'b', 'c', 'd', 'e']
-        series = Series(['1/1/2000', np.nan, '1/3/2000', np.nan,
-                         '1/5/2000'], index=idx, name='foo')
-        dseries = Series([to_datetime('1/1/2000'), np.nan,
-                          to_datetime('1/3/2000'), np.nan,
-                          to_datetime('1/5/2000')], index=idx, name='foo')
-
-        result = to_datetime(series)
-        dresult = to_datetime(dseries)
-
-        expected = Series(np.empty(5, dtype='M8[ns]'), index=idx)
-        for i in range(5):
-            x = series[i]
-            if isnull(x):
-                expected[i] = iNaT
-            else:
-                expected[i] = to_datetime(x)
-
-        assert_series_equal(result, expected, check_names=False)
-        self.assertEqual(result.name, 'foo')
-
-        assert_series_equal(dresult, expected, check_names=False)
-        self.assertEqual(dresult.name, 'foo')
-
-    def test_nat_vector_field_access(self):
-        idx = DatetimeIndex(['1/1/2000', None, None, '1/4/2000'])
-
-        fields = ['year', 'quarter', 'month', 'day', 'hour', 'minute',
-                  'second', 'microsecond', 'nanosecond', 'week', 'dayofyear',
-                  'days_in_month', 'is_leap_year']
-
-        for field in fields:
-            result = getattr(idx, field)
-            expected = [getattr(x, field) for x in idx]
-            self.assert_numpy_array_equal(result, np.array(expected))
-
-        s = pd.Series(idx)
-
-        for field in fields:
-            result = getattr(s.dt, field)
-            expected = [getattr(x, field) for x in idx]
-            self.assert_series_equal(result, pd.Series(expected))
-
-    def test_nat_scalar_field_access(self):
-        fields = ['year', 'quarter', 'month', 'day', 'hour', 'minute',
-                  'second', 'microsecond', 'nanosecond', 'week', 'dayofyear',
-                  'days_in_month', 'daysinmonth', 'dayofweek', 'weekday_name']
-        for field in fields:
-            result = getattr(NaT, field)
-            self.assertTrue(np.isnan(result))
-
-    def test_NaT_methods(self):
-        # GH 9513
-        raise_methods = ['astimezone', 'combine', 'ctime', 'dst',
-                         'fromordinal', 'fromtimestamp', 'isocalendar',
-                         'strftime', 'strptime', 'time', 'timestamp',
-                         'timetuple', 'timetz', 'toordinal', 'tzname',
-                         'utcfromtimestamp', 'utcnow', 'utcoffset',
-                         'utctimetuple']
-        nat_methods = ['date', 'now', 'replace', 'to_datetime', 'today']
-        nan_methods = ['weekday', 'isoweekday']
-
-        for method in raise_methods:
-            if hasattr(NaT, method):
-                self.assertRaises(ValueError, getattr(NaT, method))
-
-        for method in nan_methods:
-            if hasattr(NaT, method):
-                self.assertTrue(np.isnan(getattr(NaT, method)()))
-
-        for method in nat_methods:
-            if hasattr(NaT, method):
-                # see gh-8254
-                exp_warning = None
-                if method == 'to_datetime':
-                    exp_warning = FutureWarning
-                with tm.assert_produces_warning(
-                        exp_warning, check_stacklevel=False):
-                    self.assertIs(getattr(NaT, method)(), NaT)
-
-        # GH 12300
-        self.assertEqual(NaT.isoformat(), 'NaT')
-
     def test_index_convert_to_datetime_array(self):
         tm._skip_if_no_pytz()
 
@@ -968,56 +529,6 @@ class TestTimeSeries(TestData, tm.TestCase):
         _check_rng(rng_eastern)
         _check_rng(rng_utc)
 
-    def test_index_convert_to_datetime_array_explicit_pytz(self):
-        tm._skip_if_no_pytz()
-        import pytz
-
-        def _check_rng(rng):
-            converted = rng.to_pydatetime()
-            tm.assertIsInstance(converted, np.ndarray)
-            for x, stamp in zip(converted, rng):
-                tm.assertIsInstance(x, datetime)
-                self.assertEqual(x, stamp.to_pydatetime())
-                self.assertEqual(x.tzinfo, stamp.tzinfo)
-
-        rng = date_range('20090415', '20090519')
-        rng_eastern = date_range('20090415', '20090519',
-                                 tz=pytz.timezone('US/Eastern'))
-        rng_utc = date_range('20090415', '20090519', tz=pytz.utc)
-
-        _check_rng(rng)
-        _check_rng(rng_eastern)
-        _check_rng(rng_utc)
-
-    def test_index_convert_to_datetime_array_dateutil(self):
-        tm._skip_if_no_dateutil()
-        import dateutil
-
-        def _check_rng(rng):
-            converted = rng.to_pydatetime()
-            tm.assertIsInstance(converted, np.ndarray)
-            for x, stamp in zip(converted, rng):
-                tm.assertIsInstance(x, datetime)
-                self.assertEqual(x, stamp.to_pydatetime())
-                self.assertEqual(x.tzinfo, stamp.tzinfo)
-
-        rng = date_range('20090415', '20090519')
-        rng_eastern = date_range('20090415', '20090519',
-                                 tz='dateutil/US/Eastern')
-        rng_utc = date_range('20090415', '20090519', tz=dateutil.tz.tzutc())
-
-        _check_rng(rng)
-        _check_rng(rng_eastern)
-        _check_rng(rng_utc)
-
-    def test_reasonable_keyerror(self):
-        # GH #1062
-        index = DatetimeIndex(['1/3/2000'])
-        try:
-            index.get_loc('1/1/2000')
-        except KeyError as e:
-            self.assertIn('2000', str(e))
-
     def test_reindex_with_datetimes(self):
         rng = date_range('1/1/2000', periods=20)
         ts = Series(np.random.randn(20), index=rng)

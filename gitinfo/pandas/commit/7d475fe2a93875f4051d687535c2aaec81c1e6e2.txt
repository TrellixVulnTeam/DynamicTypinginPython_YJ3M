commit 7d475fe2a93875f4051d687535c2aaec81c1e6e2
Author: Chang She <chang@lambdafoundry.com>
Date:   Mon May 7 15:25:37 2012 -0400

    ENH: print err with row number with malformed CSV. #1105

diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index 6a9476f61..e218fdce9 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -57,6 +57,7 @@ thousands : str, default None
     Thousands separator
 comment : str, default None
     Indicates remainder of line should not be parsed
+    Does not support line commenting (will return empty line)
 nrows : int, default None
     Number of rows of file to read. Useful for reading pieces of large files
 iterator : boolean, default False
@@ -408,6 +409,7 @@ class TextParser(object):
 
         self.thousands = thousands
         self.comment = comment
+        self._comment_lines = []
 
         if hasattr(f, 'readline'):
             self._make_reader(f)
@@ -421,6 +423,7 @@ class TextParser(object):
         self.index_name = self._get_index_name()
         self._first_chunk = True
 
+
     def _make_reader(self, f):
         import csv
 
@@ -560,8 +563,7 @@ class TextParser(object):
                     if len(x) > 0:
                         rl.append(x)
                     break
-            if len(rl) > 0:
-                ret.append(rl)
+            ret.append(rl)
         return ret
 
     def _check_thousands(self, lines):
@@ -712,7 +714,19 @@ class TextParser(object):
 
         col_len, zip_len = len(self.columns), len(zipped_content)
         if col_len != zip_len:
-            raise Exception('Expecting %d columns, got %d' % (col_len, zip_len))
+            row_num = -1
+            for (i, l) in enumerate(content):
+                if len(l) != col_len:
+                    break
+
+            footers = 0
+            if self.skip_footer:
+                footers = self.skip_footer
+            row_num = self.pos - (len(content) - i + footers)
+
+            msg = ('Expecting %d columns, got %d in row %d' %
+                   (col_len, zip_len, row_num))
+            raise ValueError(msg)
 
         data = dict((k, v) for k, v in izip(self.columns, zipped_content))
 
@@ -735,6 +749,24 @@ class TextParser(object):
 
         return DataFrame(data=data, columns=self.columns, index=index)
 
+    def _find_line_number(self, exp_len, chunk_len, chunk_i):
+        if exp_len is None:
+            prev_pos = 0
+        else:
+            prev_pos = self.pos - exp_len
+
+        # add in skip rows in this chunk appearing before chunk_i
+        if self.skiprows is not None and len(self.skiprows) > 0:
+            skipped = Index(self.skiprows)
+            skipped = skipped[skipped > prev_pos & skipped < self.pos]
+
+
+        row_num = prev_pos + chunk_i
+
+        # add in comments in this chunk appearing before chunk_i
+
+        return row_num
+
     def _should_parse_dates(self, i):
         if isinstance(self.parse_dates, bool):
             return self.parse_dates
@@ -764,17 +796,20 @@ class TextParser(object):
                 lines.extend(source[self.pos:self.pos+rows])
                 self.pos += rows
         else:
+            new_rows = []
             try:
                 if rows is not None:
                     for _ in xrange(rows):
-                        lines.append(next(source))
+                        new_rows.append(next(source))
+                    lines.extend(new_rows)
                 else:
                     while True:
-                        lines.append(next(source))
+                        new_rows.append(next(source))
             except StopIteration:
+                lines.extend(new_rows)
                 if len(lines) == 0:
                     raise
-            self.pos += len(lines)
+            self.pos += len(new_rows)
 
         self.buf = []
 
diff --git a/pandas/io/tests/test_parsers.py b/pandas/io/tests/test_parsers.py
index d9d6d01a9..02fc25329 100644
--- a/pandas/io/tests/test_parsers.py
+++ b/pandas/io/tests/test_parsers.py
@@ -69,7 +69,6 @@ bar2,12,13,14,15
     def test_comment(self):
         data = """A,B,C
 1,2.,4.#hello world
-#hello self
 5.,NaN,10.0
 """
         expected = [[1., 2., 4.],
@@ -83,7 +82,6 @@ bar2,12,13,14,15
     def test_comment_fwf(self):
         data = """
   1   2.   4  #hello world
-#hello self
   5  NaN  10.0
 """
         expected = [[1, 2., 4],
@@ -93,11 +91,78 @@ bar2,12,13,14,15
         assert_almost_equal(df.values, expected)
 
     def test_malformed(self):
-        data = """A,B,C
+        # all
+        data = """ignore
+A,B,C
+1,2,3 # comment
+1,2,3,4,5
+2,3,4
+footer
+"""
+
+        try:
+            df = read_table(StringIO(data), sep=',', header=1, comment='#')
+            self.assert_(False)
+        except ValueError, inst:
+            self.assert_('Expecting 3 columns, got 5 in row 3' in str(inst))
+
+        # first chunk
+        data = """ignore
+A,B,C
+skip
+1,2,3
+3,5,10 # comment
 1,2,3,4,5
+2,3,4
 """
-        self.assertRaises(Exception, 'read_table', StringIO(data),
-                          names=['A','B','C'], index_col=0)
+        try:
+            it = read_table(StringIO(data), sep=',',
+                            header=1, comment='#', iterator=True, chunksize=1,
+                            skiprows=[2])
+            df = it.get_chunk(5)
+            self.assert_(False)
+        except ValueError, inst:
+            self.assert_('Expecting 3 columns, got 5 in row 5' in str(inst))
+
+
+        # middle chunk
+        data = """ignore
+A,B,C
+skip
+1,2,3
+3,5,10 # comment
+1,2,3,4,5
+2,3,4
+"""
+        try:
+            it = read_table(StringIO(data), sep=',',
+                            header=1, comment='#', iterator=True, chunksize=1,
+                            skiprows=[2])
+            df = it.get_chunk(1)
+            it.get_chunk(2)
+            self.assert_(False)
+        except ValueError, inst:
+            self.assert_('Expecting 3 columns, got 5 in row 5' in str(inst))
+
+
+        # last chunk
+        data = """ignore
+A,B,C
+skip
+1,2,3
+3,5,10 # comment
+1,2,3,4,5
+2,3,4
+"""
+        try:
+            it = read_table(StringIO(data), sep=',',
+                            header=1, comment='#', iterator=True, chunksize=1,
+                            skiprows=[2])
+            df = it.get_chunk(1)
+            it.get_chunk()
+            self.assert_(False)
+        except ValueError, inst:
+            self.assert_('Expecting 3 columns, got 5 in row 5' in str(inst))
 
     def test_custom_na_values(self):
         data = """A,B,C

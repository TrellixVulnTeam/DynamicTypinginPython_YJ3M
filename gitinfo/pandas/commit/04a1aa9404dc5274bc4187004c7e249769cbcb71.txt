commit 04a1aa9404dc5274bc4187004c7e249769cbcb71
Author: jreback <jeff@reback.net>
Date:   Sat Dec 22 09:14:05 2012 -0500

    ENH: added column filtering via keyword 'columns' passed to select

diff --git a/RELEASE.rst b/RELEASE.rst
index a182f5a7f..f07a7b67b 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -39,6 +39,7 @@ pandas 0.10.1
     - support ``expectedrows`` keyword in append to inform ``PyTables`` about the expected tablesize
     - support ``start`` and ``stop`` keywords in select to limit the row selection space
     - added ``get_store`` context manager to automatically import with pandas
+    - added column filtering via ``columns`` keyword in select
 
 **Bug fixes**
 
diff --git a/doc/source/io.rst b/doc/source/io.rst
index 802256174..7d8cbfa57 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -1175,6 +1175,12 @@ Queries are built up using a list of ``Terms`` (currently only **anding** of ter
    store
    store.select('wp',[ Term('major_axis>20000102'), Term('minor_axis', '=', ['A','B']) ])
 
+The ``columns`` keyword can be supplied to select to filter a list of the return columns, this is equivalent to passing a ``Term('columns',list_of_columns_to_filter)``
+
+.. ipython:: python
+
+   store.select('df', columns = ['A','B'])
+
 Start and Stop parameters can be specified to limit the total search space. These are in terms of the total number of rows in a table.
 
 .. ipython:: python
diff --git a/doc/source/v0.10.1.txt b/doc/source/v0.10.1.txt
index 5b8db8963..e43cd5a21 100644
--- a/doc/source/v0.10.1.txt
+++ b/doc/source/v0.10.1.txt
@@ -47,6 +47,12 @@ You can designate (and index) certain columns that you want to be able to perfor
    df[(df.B > 0) & (df.C > 0) & (df.string == 'foo')]
 
 
+You can pass ``columns`` keyword to select to filter a list of the return columns, this is equivalent to passing a ``Term('columns',list_of_columns_to_filter)``
+
+.. ipython:: python
+
+   store.select('df',columns = ['A','B'])
+
 ``HDFStore`` now serializes multi-index dataframes.
 
 .. ipython:: python
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index eb5e24838..5b31d46e2 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -336,7 +336,7 @@ class HDFStore(object):
             raise KeyError('No object named %s in the file' % key)
         return self._read_group(group)
 
-    def select(self, key, where=None, start=None, stop=None, **kwargs):
+    def select(self, key, where=None, start=None, stop=None, columns=None, **kwargs):
         """
         Retrieve pandas object stored in file, optionally based on where
         criteria
@@ -350,12 +350,13 @@ class HDFStore(object):
         where : list of Term (or convertable) objects, optional
         start : integer (defaults to None), row number to start selection
         stop  : integer (defaults to None), row number to stop selection
+        columns : a list of columns that if not None, will limit the return columns
 
         """
         group = self.get_node(key)
         if group is None:
             raise KeyError('No object named %s in the file' % key)
-        return self._read_group(group, where=where, start=start, stop=stop, **kwargs)
+        return self._read_group(group, where=where, start=start, stop=stop, columns=columns, **kwargs)
 
     def put(self, key, value, table=False, append=False,
             compression=None, **kwargs):
@@ -1317,11 +1318,12 @@ class Table(object):
     def __repr__(self):
         """ return a pretty representatgion of myself """
         self.infer_axes()
-        return "%s (typ->%s,nrows->%s,indexers->[%s],data->[%s])" % (self.pandas_type,
+        dc = ",dc->%s" % ','.join(self.data_columns) if len(self.data_columns) else ''
+        return "%s (typ->%s,nrows->%s,indexers->[%s]%s)" % (self.pandas_type,
                                                                      self.table_type_short,
                                                                      self.nrows,
                                                                      ','.join([ a.name for a in self.index_axes ]),
-                                                                     ','.join(self.data_columns))
+                                                                     dc)
 
     __str__ = __repr__
 
@@ -1681,9 +1683,15 @@ class Table(object):
         if validate:
             self.validate(existing_table)
 
-    def process_axes(self, obj):
+    def process_axes(self, obj, columns=None):
         """ process axes filters """
 
+        # reorder by any non_index_axes & limit to the select columns
+        for axis,labels in self.non_index_axes:
+            if columns is not None:
+                labels = Index(labels) & Index(columns)
+            obj = obj.reindex_axis(labels,axis=axis,copy=False)
+
         def reindex(obj, axis, filt, ordered):
             axis_name = obj._get_axis_name(axis)
             ordd = ordered & filt
@@ -1767,7 +1775,7 @@ class LegacyTable(Table):
     def write(self, **kwargs):
         raise Exception("write operations are not allowed on legacy tables!")
 
-    def read(self, where=None, **kwargs):
+    def read(self, where=None, columns=None, **kwargs):
         """ we have n indexable columns, with an arbitrary number of data axes """
 
         
@@ -1840,12 +1848,8 @@ class LegacyTable(Table):
         else:
             wp = concat(objs, axis = 0, verify_integrity = True)
 
-        # reorder by any non_index_axes
-        for axis,labels in self.non_index_axes:
-            wp = wp.reindex_axis(labels,axis=axis,copy=False)
-
         # apply the selection filters & axis orderings
-        wp = self.process_axes(wp)
+        wp = self.process_axes(wp, columns=columns)
 
         return wp
 
@@ -2017,40 +2021,40 @@ class AppendableFrameTable(AppendableTable):
             obj = obj.T
         return obj
 
-    def read(self, where=None, **kwargs):
+    def read(self, where=None, columns=None, **kwargs):
 
         if not self.read_axes(where=where, **kwargs): return None
 
         index   = self.index_axes[0].values
         frames  = []
         for a in self.values_axes:
-            columns = Index(a.values)
+            cols = Index(a.values)
 
             if self.is_transposed:
                 values   = a.cvalues
-                index_   = columns
-                columns_ = Index(index)
+                index_   = cols
+                cols_    = Index(index)
             else:
                 values   = a.cvalues.T
                 index_   = Index(index)
-                columns_ = columns
+                cols_    = cols
 
 
             # if we have a DataIndexableCol, its shape will only be 1 dim
             if values.ndim == 1:
                 values = values.reshape(1,values.shape[0])
 
-            block   = make_block(values, columns_, columns_)
-            mgr     = BlockManager([ block ], [ columns_, index_ ])
+            block   = make_block(values, cols_, cols_)
+            mgr     = BlockManager([ block ], [ cols_, index_ ])
             frames.append(DataFrame(mgr))
-        df = concat(frames, axis = 1, verify_integrity = True)
 
-        # sort the indicies & reorder the columns
-        for axis,labels in self.non_index_axes:
-            df = df.reindex_axis(labels,axis=axis,copy=False)
+        if len(frames) == 1:
+            df = frames[0]
+        else:
+            df = concat(frames, axis = 1, verify_integrity = True)
 
         # apply the selection filters & axis orderings
-        df = self.process_axes(df)
+        df = self.process_axes(df, columns=columns)
 
         return df
 
@@ -2073,8 +2077,8 @@ class AppendableMultiFrameTable(AppendableFrameTable):
         self.levels = obj.index.names
         return super(AppendableMultiFrameTable, self).write(obj = obj.reset_index(), columns = columns, **kwargs)
 
-    def read(self, where=None, **kwargs):
-        df = super(AppendableMultiFrameTable, self).read(where = where, **kwargs)
+    def read(self, *args, **kwargs):
+        df = super(AppendableMultiFrameTable, self).read(*args, **kwargs)
         df.set_index(self.levels, inplace=True)
         return df
 
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index 0dbd9000e..fbcbe7e17 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -1284,6 +1284,33 @@ class TestHDFStore(unittest.TestCase):
         #self.assertRaises(Exception, self.store.select,
         #                  'wp2', ('column', ['A', 'D']))
 
+        # select with columns=
+        df = tm.makeTimeDataFrame()
+        self.store.remove('df')
+        self.store.append('df',df)
+        result = self.store.select('df', columns = ['A','B'])
+        expected = df.reindex(columns = ['A','B'])
+        tm.assert_frame_equal(expected, result)
+
+        # equivalentsly
+        result = self.store.select('df', [ ('columns', ['A','B']) ])
+        expected = df.reindex(columns = ['A','B'])
+        tm.assert_frame_equal(expected, result)
+
+        # with a data column
+        self.store.remove('df')
+        self.store.append('df',df, columns = ['A'])
+        result = self.store.select('df', [ 'A > 0' ], columns = ['A','B'])
+        expected = df[df.A > 0].reindex(columns = ['A','B'])
+        tm.assert_frame_equal(expected, result)
+
+        # with a data column, but different columns
+        self.store.remove('df')
+        self.store.append('df',df, columns = ['A'])
+        result = self.store.select('df', [ 'A > 0' ], columns = ['C','D'])
+        expected = df[df.A > 0].reindex(columns = ['C','D'])
+        tm.assert_frame_equal(expected, result)
+
     def test_panel_select(self):
         wp = tm.makePanel()
         self.store.put('wp', wp, table=True)

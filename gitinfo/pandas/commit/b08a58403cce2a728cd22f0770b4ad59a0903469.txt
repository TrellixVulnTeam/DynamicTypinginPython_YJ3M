commit b08a58403cce2a728cd22f0770b4ad59a0903469
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Fri Feb 8 15:33:31 2019 -0800

    DEPR: remove tm.makePanel and all usages (#25231)

diff --git a/pandas/tests/frame/test_reshape.py b/pandas/tests/frame/test_reshape.py
index 28222a829..daac084f6 100644
--- a/pandas/tests/frame/test_reshape.py
+++ b/pandas/tests/frame/test_reshape.py
@@ -4,7 +4,6 @@ from __future__ import print_function
 
 from datetime import datetime
 import itertools
-from warnings import catch_warnings, simplefilter
 
 import numpy as np
 import pytest
@@ -49,14 +48,6 @@ class TestDataFrameReshape(TestData):
         assert pivoted.index.name == 'index'
         assert pivoted.columns.names == (None, 'columns')
 
-        with catch_warnings(record=True):
-            # pivot multiple columns
-            simplefilter("ignore", FutureWarning)
-            wp = tm.makePanel()
-            lp = wp.to_frame()
-            df = lp.reset_index()
-            tm.assert_frame_equal(df.pivot('major', 'minor'), lp.unstack())
-
     def test_pivot_duplicates(self):
         data = DataFrame({'a': ['bar', 'bar', 'foo', 'foo', 'foo'],
                           'b': ['one', 'two', 'one', 'one', 'two'],
diff --git a/pandas/tests/generic/test_generic.py b/pandas/tests/generic/test_generic.py
index 7183fea85..fb17b4794 100644
--- a/pandas/tests/generic/test_generic.py
+++ b/pandas/tests/generic/test_generic.py
@@ -740,23 +740,11 @@ class TestNDFrame(object):
             tm.assert_series_equal(s.squeeze(), s)
         for df in [tm.makeTimeDataFrame()]:
             tm.assert_frame_equal(df.squeeze(), df)
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            for p in [tm.makePanel()]:
-                tm.assert_panel_equal(p.squeeze(), p)
 
         # squeezing
         df = tm.makeTimeDataFrame().reindex(columns=['A'])
         tm.assert_series_equal(df.squeeze(), df['A'])
 
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            p = tm.makePanel().reindex(items=['ItemA'])
-            tm.assert_frame_equal(p.squeeze(), p['ItemA'])
-
-            p = tm.makePanel().reindex(items=['ItemA'], minor_axis=['A'])
-            tm.assert_series_equal(p.squeeze(), p.loc['ItemA', :, 'A'])
-
         # don't fail with 0 length dimensions GH11229 & GH8999
         empty_series = Series([], name='five')
         empty_frame = DataFrame([empty_series])
@@ -789,8 +777,6 @@ class TestNDFrame(object):
         tm.assert_series_equal(np.squeeze(df), df['A'])
 
     def test_transpose(self):
-        msg = (r"transpose\(\) got multiple values for "
-               r"keyword argument 'axes'")
         for s in [tm.makeFloatSeries(), tm.makeStringSeries(),
                   tm.makeObjectSeries()]:
             # calls implementation in pandas/core/base.py
@@ -798,14 +784,6 @@ class TestNDFrame(object):
         for df in [tm.makeTimeDataFrame()]:
             tm.assert_frame_equal(df.transpose().transpose(), df)
 
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            for p in [tm.makePanel()]:
-                tm.assert_panel_equal(p.transpose(2, 0, 1)
-                                      .transpose(1, 2, 0), p)
-                with pytest.raises(TypeError, match=msg):
-                    p.transpose(2, 0, 1, axes=(2, 0, 1))
-
     def test_numpy_transpose(self):
         msg = "the 'axes' parameter is not supported"
 
@@ -821,13 +799,6 @@ class TestNDFrame(object):
         with pytest.raises(ValueError, match=msg):
             np.transpose(df, axes=1)
 
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            p = tm.makePanel()
-            tm.assert_panel_equal(np.transpose(
-                np.transpose(p, axes=(2, 0, 1)),
-                axes=(1, 2, 0)), p)
-
     def test_take(self):
         indices = [1, 5, -2, 6, 3, -1]
         for s in [tm.makeFloatSeries(), tm.makeStringSeries(),
@@ -843,27 +814,12 @@ class TestNDFrame(object):
                                  columns=df.columns)
             tm.assert_frame_equal(out, expected)
 
-        indices = [-3, 2, 0, 1]
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            for p in [tm.makePanel()]:
-                out = p.take(indices)
-                expected = Panel(data=p.values.take(indices, axis=0),
-                                 items=p.items.take(indices),
-                                 major_axis=p.major_axis,
-                                 minor_axis=p.minor_axis)
-                tm.assert_panel_equal(out, expected)
-
     def test_take_invalid_kwargs(self):
         indices = [-3, 2, 0, 1]
         s = tm.makeFloatSeries()
         df = tm.makeTimeDataFrame()
 
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            p = tm.makePanel()
-
-        for obj in (s, df, p):
+        for obj in (s, df):
             msg = r"take\(\) got an unexpected keyword argument 'foo'"
             with pytest.raises(TypeError, match=msg):
                 obj.take(indices, foo=2)
@@ -966,12 +922,6 @@ class TestNDFrame(object):
         assert a.equals(e)
         assert e.equals(f)
 
-    def test_describe_raises(self):
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            with pytest.raises(NotImplementedError):
-                tm.makePanel().describe()
-
     def test_pipe(self):
         df = DataFrame({'A': [1, 2, 3]})
         f = lambda x, y: x ** y
diff --git a/pandas/tests/generic/test_panel.py b/pandas/tests/generic/test_panel.py
index 8b090d951..73b879866 100644
--- a/pandas/tests/generic/test_panel.py
+++ b/pandas/tests/generic/test_panel.py
@@ -3,11 +3,8 @@
 
 from warnings import catch_warnings, simplefilter
 
-import pandas.util._test_decorators as td
-
 from pandas import Panel
-import pandas.util.testing as tm
-from pandas.util.testing import assert_almost_equal, assert_panel_equal
+from pandas.util.testing import assert_panel_equal
 
 from .test_generic import Generic
 
@@ -16,24 +13,6 @@ class TestPanel(Generic):
     _typ = Panel
     _comparator = lambda self, x, y: assert_panel_equal(x, y, by_blocks=True)
 
-    @td.skip_if_no('xarray', min_version='0.7.0')
-    def test_to_xarray(self):
-        from xarray import DataArray
-
-        with catch_warnings(record=True):
-            simplefilter("ignore", FutureWarning)
-            p = tm.makePanel()
-
-            result = p.to_xarray()
-            assert isinstance(result, DataArray)
-            assert len(result.coords) == 3
-            assert_almost_equal(list(result.coords.keys()),
-                                ['items', 'major_axis', 'minor_axis'])
-            assert len(result.dims) == 3
-
-            # idempotency
-            assert_panel_equal(result.to_pandas(), p)
-
 
 # run all the tests, but wrap each in a warning catcher
 for t in ['test_rename', 'test_get_numeric_data',
diff --git a/pandas/tests/indexing/test_panel.py b/pandas/tests/indexing/test_panel.py
index 34708e114..8530adec0 100644
--- a/pandas/tests/indexing/test_panel.py
+++ b/pandas/tests/indexing/test_panel.py
@@ -122,28 +122,6 @@ class TestPanel(object):
             test1 = panel.loc[:, "2002"]
             tm.assert_panel_equal(test1, test2)
 
-            # GH8710
-            # multi-element getting with a list
-            panel = tm.makePanel()
-
-            expected = panel.iloc[[0, 1]]
-
-            result = panel.loc[['ItemA', 'ItemB']]
-            tm.assert_panel_equal(result, expected)
-
-            result = panel.loc[['ItemA', 'ItemB'], :, :]
-            tm.assert_panel_equal(result, expected)
-
-            result = panel[['ItemA', 'ItemB']]
-            tm.assert_panel_equal(result, expected)
-
-            result = panel.loc['ItemA':'ItemB']
-            tm.assert_panel_equal(result, expected)
-
-            with catch_warnings(record=True):
-                result = panel.ix[['ItemA', 'ItemB']]
-            tm.assert_panel_equal(result, expected)
-
             # with an object-like
             # GH 9140
             class TestObject(object):
diff --git a/pandas/tests/io/test_sql.py b/pandas/tests/io/test_sql.py
index 75a6d8d00..9d0bce3b3 100644
--- a/pandas/tests/io/test_sql.py
+++ b/pandas/tests/io/test_sql.py
@@ -605,12 +605,6 @@ class _TestSQLApi(PandasSQLTest):
         s2 = sql.read_sql_query("SELECT * FROM test_series", self.conn)
         tm.assert_frame_equal(s.to_frame(), s2)
 
-    @pytest.mark.filterwarnings("ignore:\\nPanel:FutureWarning")
-    def test_to_sql_panel(self):
-        panel = tm.makePanel()
-        pytest.raises(NotImplementedError, sql.to_sql, panel,
-                      'test_panel', self.conn)
-
     def test_roundtrip(self):
         sql.to_sql(self.test_frame1, 'test_frame_roundtrip',
                    con=self.conn)
diff --git a/pandas/tests/reshape/test_reshape.py b/pandas/tests/reshape/test_reshape.py
index 7b544b798..a5b6cffd1 100644
--- a/pandas/tests/reshape/test_reshape.py
+++ b/pandas/tests/reshape/test_reshape.py
@@ -580,23 +580,28 @@ class TestGetDummies(object):
 
 class TestCategoricalReshape(object):
 
-    @pytest.mark.filterwarnings("ignore:\\nPanel:FutureWarning")
-    def test_reshaping_panel_categorical(self):
+    def test_reshaping_multi_index_categorical(self):
 
-        p = tm.makePanel()
-        p['str'] = 'foo'
-        df = p.to_frame()
+        # construct a MultiIndexed DataFrame formerly created
+        #  via `tm.makePanel().to_frame()`
+        cols = ['ItemA', 'ItemB', 'ItemC']
+        data = {c: tm.makeTimeDataFrame() for c in cols}
+        df = pd.concat({c: data[c].stack() for c in data}, axis='columns')
+        df.index.names = ['major', 'minor']
+        df['str'] = 'foo'
+
+        dti = df.index.levels[0]
 
         df['category'] = df['str'].astype('category')
         result = df['category'].unstack()
 
-        c = Categorical(['foo'] * len(p.major_axis))
+        c = Categorical(['foo'] * len(dti))
         expected = DataFrame({'A': c.copy(),
                               'B': c.copy(),
                               'C': c.copy(),
                               'D': c.copy()},
                              columns=Index(list('ABCD'), name='minor'),
-                             index=p.major_axis.set_names('major'))
+                             index=dti)
         tm.assert_frame_equal(result, expected)
 
 
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index 5d8de3e1f..bfcafda1d 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -2,56 +2,28 @@
 # pylint: disable=W0612,E1101
 from collections import OrderedDict
 from datetime import datetime
-import operator
-from warnings import catch_warnings, simplefilter
 
 import numpy as np
 import pytest
 
-from pandas.compat import StringIO, lrange, range, signature
-import pandas.util._test_decorators as td
+from pandas.compat import lrange
 
-from pandas.core.dtypes.common import is_float_dtype
-
-from pandas import (
-    DataFrame, Index, MultiIndex, Series, compat, date_range, isna, notna)
-from pandas.core.nanops import nanall, nanany
+from pandas import DataFrame, MultiIndex, Series, date_range, notna
 import pandas.core.panel as panelm
 from pandas.core.panel import Panel
 import pandas.util.testing as tm
 from pandas.util.testing import (
     assert_almost_equal, assert_frame_equal, assert_panel_equal,
-    assert_series_equal, ensure_clean, makeCustomDataframe as mkdf,
-    makeMixedDataFrame)
+    assert_series_equal, makeCustomDataframe as mkdf, makeMixedDataFrame)
 
 from pandas.io.formats.printing import pprint_thing
-from pandas.tseries.offsets import BDay, MonthEnd
-
-
-def make_test_panel():
-    with catch_warnings(record=True):
-        simplefilter("ignore", FutureWarning)
-        _panel = tm.makePanel()
-        tm.add_nans(_panel)
-        _panel = _panel.copy()
-    return _panel
+from pandas.tseries.offsets import MonthEnd
 
 
 @pytest.mark.filterwarnings("ignore:\\nPanel:FutureWarning")
 class PanelTests(object):
     panel = None
 
-    def test_pickle(self):
-        unpickled = tm.round_trip_pickle(self.panel)
-        assert_frame_equal(unpickled['ItemA'], self.panel['ItemA'])
-
-    def test_rank(self):
-        pytest.raises(NotImplementedError, lambda: self.panel.rank())
-
-    def test_cumsum(self):
-        cumsum = self.panel.cumsum()
-        assert_frame_equal(cumsum['ItemA'], self.panel['ItemA'].cumsum())
-
     def not_hashable(self):
         c_empty = Panel()
         c = Panel(Panel([[[1]]]))
@@ -59,298 +31,9 @@ class PanelTests(object):
         pytest.raises(TypeError, hash, c)
 
 
-@pytest.mark.filterwarnings("ignore:\\nPanel:FutureWarning")
-class SafeForLongAndSparse(object):
-
-    def test_repr(self):
-        repr(self.panel)
-
-    def test_copy_names(self):
-        for attr in ('major_axis', 'minor_axis'):
-            getattr(self.panel, attr).name = None
-            cp = self.panel.copy()
-            getattr(cp, attr).name = 'foo'
-            assert getattr(self.panel, attr).name is None
-
-    def test_iter(self):
-        tm.equalContents(list(self.panel), self.panel.items)
-
-    def test_count(self):
-        f = lambda s: notna(s).sum()
-        self._check_stat_op('count', f, obj=self.panel, has_skipna=False)
-
-    def test_sum(self):
-        self._check_stat_op('sum', np.sum, skipna_alternative=np.nansum)
-
-    def test_mean(self):
-        self._check_stat_op('mean', np.mean)
-
-    def test_prod(self):
-        self._check_stat_op('prod', np.prod, skipna_alternative=np.nanprod)
-
-    @pytest.mark.filterwarnings("ignore:Invalid value:RuntimeWarning")
-    @pytest.mark.filterwarnings("ignore:All-NaN:RuntimeWarning")
-    def test_median(self):
-        def wrapper(x):
-            if isna(x).any():
-                return np.nan
-            return np.median(x)
-
-        self._check_stat_op('median', wrapper)
-
-    @pytest.mark.filterwarnings("ignore:Invalid value:RuntimeWarning")
-    def test_min(self):
-        self._check_stat_op('min', np.min)
-
-    @pytest.mark.filterwarnings("ignore:Invalid value:RuntimeWarning")
-    def test_max(self):
-        self._check_stat_op('max', np.max)
-
-    @td.skip_if_no_scipy
-    def test_skew(self):
-        from scipy.stats import skew
-
-        def this_skew(x):
-            if len(x) < 3:
-                return np.nan
-            return skew(x, bias=False)
-
-        self._check_stat_op('skew', this_skew)
-
-    def test_var(self):
-        def alt(x):
-            if len(x) < 2:
-                return np.nan
-            return np.var(x, ddof=1)
-
-        self._check_stat_op('var', alt)
-
-    def test_std(self):
-        def alt(x):
-            if len(x) < 2:
-                return np.nan
-            return np.std(x, ddof=1)
-
-        self._check_stat_op('std', alt)
-
-    def test_sem(self):
-        def alt(x):
-            if len(x) < 2:
-                return np.nan
-            return np.std(x, ddof=1) / np.sqrt(len(x))
-
-        self._check_stat_op('sem', alt)
-
-    def _check_stat_op(self, name, alternative, obj=None, has_skipna=True,
-                       skipna_alternative=None):
-        if obj is None:
-            obj = self.panel
-
-            # # set some NAs
-            # obj.loc[5:10] = np.nan
-            # obj.loc[15:20, -2:] = np.nan
-
-        f = getattr(obj, name)
-
-        if has_skipna:
-
-            skipna_wrapper = tm._make_skipna_wrapper(alternative,
-                                                     skipna_alternative)
-
-            def wrapper(x):
-                return alternative(np.asarray(x))
-
-            for i in range(obj.ndim):
-                result = f(axis=i, skipna=False)
-                assert_frame_equal(result, obj.apply(wrapper, axis=i))
-        else:
-            skipna_wrapper = alternative
-            wrapper = alternative
-
-        for i in range(obj.ndim):
-            result = f(axis=i)
-            if name in ['sum', 'prod']:
-                assert_frame_equal(result, obj.apply(skipna_wrapper, axis=i))
-
-        pytest.raises(Exception, f, axis=obj.ndim)
-
-        # Unimplemented numeric_only parameter.
-        if 'numeric_only' in signature(f).args:
-            with pytest.raises(NotImplementedError, match=name):
-                f(numeric_only=True)
-
-
 @pytest.mark.filterwarnings("ignore:\\nPanel:FutureWarning")
 class SafeForSparse(object):
 
-    def test_get_axis(self):
-        assert (self.panel._get_axis(0) is self.panel.items)
-        assert (self.panel._get_axis(1) is self.panel.major_axis)
-        assert (self.panel._get_axis(2) is self.panel.minor_axis)
-
-    def test_set_axis(self):
-        new_items = Index(np.arange(len(self.panel.items)))
-        new_major = Index(np.arange(len(self.panel.major_axis)))
-        new_minor = Index(np.arange(len(self.panel.minor_axis)))
-
-        # ensure propagate to potentially prior-cached items too
-        item = self.panel['ItemA']
-        self.panel.items = new_items
-
-        if hasattr(self.panel, '_item_cache'):
-            assert 'ItemA' not in self.panel._item_cache
-        assert self.panel.items is new_items
-
-        # TODO: unused?
-        item = self.panel[0]  # noqa
-
-        self.panel.major_axis = new_major
-        assert self.panel[0].index is new_major
-        assert self.panel.major_axis is new_major
-
-        # TODO: unused?
-        item = self.panel[0]  # noqa
-
-        self.panel.minor_axis = new_minor
-        assert self.panel[0].columns is new_minor
-        assert self.panel.minor_axis is new_minor
-
-    def test_get_axis_number(self):
-        assert self.panel._get_axis_number('items') == 0
-        assert self.panel._get_axis_number('major') == 1
-        assert self.panel._get_axis_number('minor') == 2
-
-        with pytest.raises(ValueError, match="No axis named foo"):
-            self.panel._get_axis_number('foo')
-
-        with pytest.raises(ValueError, match="No axis named foo"):
-            self.panel.__ge__(self.panel, axis='foo')
-
-    def test_get_axis_name(self):
-        assert self.panel._get_axis_name(0) == 'items'
-        assert self.panel._get_axis_name(1) == 'major_axis'
-        assert self.panel._get_axis_name(2) == 'minor_axis'
-
-    def test_get_plane_axes(self):
-        # what to do here?
-
-        index, columns = self.panel._get_plane_axes('items')
-        index, columns = self.panel._get_plane_axes('major_axis')
-        index, columns = self.panel._get_plane_axes('minor_axis')
-        index, columns = self.panel._get_plane_axes(0)
-
-    def test_truncate(self):
-        dates = self.panel.major_axis
-        start, end = dates[1], dates[5]
-
-        trunced = self.panel.truncate(start, end, axis='major')
-        expected = self.panel['ItemA'].truncate(start, end)
-
-        assert_frame_equal(trunced['ItemA'], expected)
-
-        trunced = self.panel.truncate(before=start, axis='major')
-        expected = self.panel['ItemA'].truncate(before=start)
-
-        assert_frame_equal(trunced['ItemA'], expected)
-
-        trunced = self.panel.truncate(after=end, axis='major')
-        expected = self.panel['ItemA'].truncate(after=end)
-
-        assert_frame_equal(trunced['ItemA'], expected)
-
-    def test_arith(self):
-        self._test_op(self.panel, operator.add)
-        self._test_op(self.panel, operator.sub)
-        self._test_op(self.panel, operator.mul)
-        self._test_op(self.panel, operator.truediv)
-        self._test_op(self.panel, operator.floordiv)
-        self._test_op(self.panel, operator.pow)
-
-        self._test_op(self.panel, lambda x, y: y + x)
-        self._test_op(self.panel, lambda x, y: y - x)
-        self._test_op(self.panel, lambda x, y: y * x)
-        self._test_op(self.panel, lambda x, y: y / x)
-        self._test_op(self.panel, lambda x, y: y ** x)
-
-        self._test_op(self.panel, lambda x, y: x + y)  # panel + 1
-        self._test_op(self.panel, lambda x, y: x - y)  # panel - 1
-        self._test_op(self.panel, lambda x, y: x * y)  # panel * 1
-        self._test_op(self.panel, lambda x, y: x / y)  # panel / 1
-        self._test_op(self.panel, lambda x, y: x ** y)  # panel ** 1
-
-        pytest.raises(Exception, self.panel.__add__,
-                      self.panel['ItemA'])
-
-    @staticmethod
-    def _test_op(panel, op):
-        result = op(panel, 1)
-        assert_frame_equal(result['ItemA'], op(panel['ItemA'], 1))
-
-    def test_keys(self):
-        tm.equalContents(list(self.panel.keys()), self.panel.items)
-
-    def test_iteritems(self):
-        # Test panel.iteritems(), aka panel.iteritems()
-        # just test that it works
-        for k, v in self.panel.iteritems():
-            pass
-
-        assert len(list(self.panel.iteritems())) == len(self.panel.items)
-
-    def test_combineFrame(self):
-        def check_op(op, name):
-            # items
-            df = self.panel['ItemA']
-
-            func = getattr(self.panel, name)
-
-            result = func(df, axis='items')
-
-            assert_frame_equal(
-                result['ItemB'], op(self.panel['ItemB'], df))
-
-            # major
-            xs = self.panel.major_xs(self.panel.major_axis[0])
-            result = func(xs, axis='major')
-
-            idx = self.panel.major_axis[1]
-
-            assert_frame_equal(result.major_xs(idx),
-                               op(self.panel.major_xs(idx), xs))
-
-            # minor
-            xs = self.panel.minor_xs(self.panel.minor_axis[0])
-            result = func(xs, axis='minor')
-
-            idx = self.panel.minor_axis[1]
-
-            assert_frame_equal(result.minor_xs(idx),
-                               op(self.panel.minor_xs(idx), xs))
-
-        ops = ['add', 'sub', 'mul', 'truediv', 'floordiv', 'pow', 'mod']
-        if not compat.PY3:
-            ops.append('div')
-
-        for op in ops:
-            try:
-                check_op(getattr(operator, op), op)
-            except AttributeError:
-                pprint_thing("Failing operation: %r" % op)
-                raise
-        if compat.PY3:
-            try:
-                check_op(operator.truediv, 'div')
-            except AttributeError:
-                pprint_thing("Failing operation: %r" % 'div')
-                raise
-
-    def test_combinePanel(self):
-        result = self.panel.add(self.panel)
-        assert_panel_equal(result, self.panel * 2)
-
-    def test_neg(self):
-        assert_panel_equal(-self.panel, self.panel * -1)
-
     # issue 7692
     def test_raise_when_not_implemented(self):
         p = Panel(np.arange(3 * 4 * 5).reshape(3, 4, 5),
@@ -364,84 +47,11 @@ class SafeForSparse(object):
             with pytest.raises(NotImplementedError):
                 getattr(p, op)(d, axis=0)
 
-    def test_select(self):
-        p = self.panel
-
-        # select items
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            result = p.select(lambda x: x in ('ItemA', 'ItemC'), axis='items')
-        expected = p.reindex(items=['ItemA', 'ItemC'])
-        assert_panel_equal(result, expected)
-
-        # select major_axis
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            result = p.select(lambda x: x >= datetime(
-                2000, 1, 15), axis='major')
-        new_major = p.major_axis[p.major_axis >= datetime(2000, 1, 15)]
-        expected = p.reindex(major=new_major)
-        assert_panel_equal(result, expected)
-
-        # select minor_axis
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            result = p.select(lambda x: x in ('D', 'A'), axis=2)
-        expected = p.reindex(minor=['A', 'D'])
-        assert_panel_equal(result, expected)
-
-        # corner case, empty thing
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
-            result = p.select(lambda x: x in ('foo', ), axis='items')
-        assert_panel_equal(result, p.reindex(items=[]))
-
-    def test_get_value(self):
-        for item in self.panel.items:
-            for mjr in self.panel.major_axis[::2]:
-                for mnr in self.panel.minor_axis:
-                    with tm.assert_produces_warning(FutureWarning,
-                                                    check_stacklevel=False):
-                        result = self.panel.get_value(item, mjr, mnr)
-                    expected = self.panel[item][mnr][mjr]
-                    assert_almost_equal(result, expected)
-
-    def test_abs(self):
-
-        result = self.panel.abs()
-        result2 = abs(self.panel)
-        expected = np.abs(self.panel)
-        assert_panel_equal(result, expected)
-        assert_panel_equal(result2, expected)
-
-        df = self.panel['ItemA']
-        result = df.abs()
-        result2 = abs(df)
-        expected = np.abs(df)
-        assert_frame_equal(result, expected)
-        assert_frame_equal(result2, expected)
-
-        s = df['A']
-        result = s.abs()
-        result2 = abs(s)
-        expected = np.abs(s)
-        assert_series_equal(result, expected)
-        assert_series_equal(result2, expected)
-        assert result.name == 'A'
-        assert result2.name == 'A'
-
 
 @pytest.mark.filterwarnings("ignore:\\nPanel:FutureWarning")
 class CheckIndexing(object):
 
-    def test_getitem(self):
-        pytest.raises(Exception, self.panel.__getitem__, 'ItemQ')
-
     def test_delitem_and_pop(self):
-        expected = self.panel['ItemA']
-        result = self.panel.pop('ItemA')
-        assert_frame_equal(expected, result)
-        assert 'ItemA' not in self.panel.items
-
-        del self.panel['ItemB']
-        assert 'ItemB' not in self.panel.items
-        pytest.raises(Exception, self.panel.__delitem__, 'ItemB')
 
         values = np.empty((3, 3, 3))
         values[0] = 0
@@ -468,38 +78,6 @@ class CheckIndexing(object):
         tm.assert_frame_equal(panelc[0], panel[0])
 
     def test_setitem(self):
-        lp = self.panel.filter(['ItemA', 'ItemB']).to_frame()
-
-        with pytest.raises(TypeError):
-            self.panel['ItemE'] = lp
-
-        # DataFrame
-        df = self.panel['ItemA'][2:].filter(items=['A', 'B'])
-        self.panel['ItemF'] = df
-        self.panel['ItemE'] = df
-
-        df2 = self.panel['ItemF']
-
-        assert_frame_equal(df, df2.reindex(
-            index=df.index, columns=df.columns))
-
-        # scalar
-        self.panel['ItemG'] = 1
-        self.panel['ItemE'] = True
-        assert self.panel['ItemG'].values.dtype == np.int64
-        assert self.panel['ItemE'].values.dtype == np.bool_
-
-        # object dtype
-        self.panel['ItemQ'] = 'foo'
-        assert self.panel['ItemQ'].values.dtype == np.object_
-
-        # boolean dtype
-        self.panel['ItemP'] = self.panel['ItemA'] > 0
-        assert self.panel['ItemP'].values.dtype == np.bool_
-
-        pytest.raises(TypeError, self.panel.__setitem__, 'foo',
-                      self.panel.loc[['ItemP']])
-
         # bad shape
         p = Panel(np.random.randn(4, 3, 2))
         msg = (r"shape of value must be \(3, 2\), "
@@ -537,159 +115,9 @@ class CheckIndexing(object):
         assert_frame_equal(panel.loc[:, 'NewMajor', :],
                            newmajor.astype(object))
 
-    def test_major_xs(self):
-        ref = self.panel['ItemA']
-
-        idx = self.panel.major_axis[5]
-        xs = self.panel.major_xs(idx)
-
-        result = xs['ItemA']
-        assert_series_equal(result, ref.xs(idx), check_names=False)
-        assert result.name == 'ItemA'
-
-        # not contained
-        idx = self.panel.major_axis[0] - BDay()
-        pytest.raises(Exception, self.panel.major_xs, idx)
-
-    def test_major_xs_mixed(self):
-        self.panel['ItemD'] = 'foo'
-        xs = self.panel.major_xs(self.panel.major_axis[0])
-        assert xs['ItemA'].dtype == np.float64
-        assert xs['ItemD'].dtype == np.object_
-
-    def test_minor_xs(self):
-        ref = self.panel['ItemA']
-
-        idx = self.panel.minor_axis[1]
-        xs = self.panel.minor_xs(idx)
-
-        assert_series_equal(xs['ItemA'], ref[idx], check_names=False)
-
-        # not contained
-        pytest.raises(Exception, self.panel.minor_xs, 'E')
-
-    def test_minor_xs_mixed(self):
-        self.panel['ItemD'] = 'foo'
-
-        xs = self.panel.minor_xs('D')
-        assert xs['ItemA'].dtype == np.float64
-        assert xs['ItemD'].dtype == np.object_
-
-    def test_xs(self):
-        itemA = self.panel.xs('ItemA', axis=0)
-        expected = self.panel['ItemA']
-        tm.assert_frame_equal(itemA, expected)
-
-        # Get a view by default.
-        itemA_view = self.panel.xs('ItemA', axis=0)
-        itemA_view.values[:] = np.nan
-
-        assert np.isnan(self.panel['ItemA'].values).all()
-
-        # Mixed-type yields a copy.
-        self.panel['strings'] = 'foo'
-        result = self.panel.xs('D', axis=2)
-        assert result._is_copy is not None
-
-    def test_getitem_fancy_labels(self):
-        p = self.panel
-
-        items = p.items[[1, 0]]
-        dates = p.major_axis[::2]
-        cols = ['D', 'C', 'F']
-
-        # all 3 specified
-        with catch_warnings():
-            simplefilter("ignore", FutureWarning)
-            # XXX: warning in _validate_read_indexer
-            assert_panel_equal(p.loc[items, dates, cols],
-                               p.reindex(items=items, major=dates, minor=cols))
-
-            # 2 specified
-            assert_panel_equal(p.loc[:, dates, cols],
-                               p.reindex(major=dates, minor=cols))
-
-            assert_panel_equal(p.loc[items, :, cols],
-                               p.reindex(items=items, minor=cols))
-
-            assert_panel_equal(p.loc[items, dates, :],
-                               p.reindex(items=items, major=dates))
-
-            # only 1
-            assert_panel_equal(p.loc[items, :, :], p.reindex(items=items))
-
-            assert_panel_equal(p.loc[:, dates, :], p.reindex(major=dates))
-
-            assert_panel_equal(p.loc[:, :, cols], p.reindex(minor=cols))
-
     def test_getitem_fancy_slice(self):
         pass
 
-    def test_getitem_fancy_ints(self):
-        p = self.panel
-
-        # #1603
-        result = p.iloc[:, -1, :]
-        expected = p.loc[:, p.major_axis[-1], :]
-        assert_frame_equal(result, expected)
-
-    def test_getitem_fancy_xs(self):
-        p = self.panel
-        item = 'ItemB'
-
-        date = p.major_axis[5]
-        col = 'C'
-
-        # get DataFrame
-        # item
-        assert_frame_equal(p.loc[item], p[item])
-        assert_frame_equal(p.loc[item, :], p[item])
-        assert_frame_equal(p.loc[item, :, :], p[item])
-
-        # major axis, axis=1
-        assert_frame_equal(p.loc[:, date], p.major_xs(date))
-        assert_frame_equal(p.loc[:, date, :], p.major_xs(date))
-
-        # minor axis, axis=2
-        assert_frame_equal(p.loc[:, :, 'C'], p.minor_xs('C'))
-
-        # get Series
-        assert_series_equal(p.loc[item, date], p[item].loc[date])
-        assert_series_equal(p.loc[item, date, :], p[item].loc[date])
-        assert_series_equal(p.loc[item, :, col], p[item][col])
-        assert_series_equal(p.loc[:, date, col], p.major_xs(date).loc[col])
-
-    def test_getitem_fancy_xs_check_view(self):
-        item = 'ItemB'
-        date = self.panel.major_axis[5]
-
-        # make sure it's always a view
-        NS = slice(None, None)
-
-        # DataFrames
-        comp = assert_frame_equal
-        self._check_view(item, comp)
-        self._check_view((item, NS), comp)
-        self._check_view((item, NS, NS), comp)
-        self._check_view((NS, date), comp)
-        self._check_view((NS, date, NS), comp)
-        self._check_view((NS, NS, 'C'), comp)
-
-        # Series
-        comp = assert_series_equal
-        self._check_view((item, date), comp)
-        self._check_view((item, date, NS), comp)
-        self._check_view((item, NS, 'C'), comp)
-        self._check_view((NS, date, 'C'), comp)
-
-    def test_getitem_callable(self):
-        p = self.panel
-        # GH 12533
-
-        assert_frame_equal(p[lambda x: 'ItemB'], p.loc['ItemB'])
-        assert_panel_equal(p[lambda x: ['ItemB', 'ItemC']],
-                           p.loc[['ItemB', 'ItemC']])
-
     def test_ix_setitem_slice_dataframe(self):
         a = Panel(items=[1, 2, 3], major_axis=[11, 22, 33],
                   minor_axis=[111, 222, 333])
@@ -719,43 +147,6 @@ class CheckIndexing(object):
         assert_series_equal(df.loc[0, 0, :].reindex(b.index), b)
 
     def test_ix_frame_align(self):
-        p_orig = tm.makePanel()
-        df = p_orig.iloc[0].copy()
-        assert_frame_equal(p_orig['ItemA'], df)
-
-        p = p_orig.copy()
-        p.iloc[0, :, :] = df
-        assert_panel_equal(p, p_orig)
-
-        p = p_orig.copy()
-        p.iloc[0] = df
-        assert_panel_equal(p, p_orig)
-
-        p = p_orig.copy()
-        p.iloc[0, :, :] = df
-        assert_panel_equal(p, p_orig)
-
-        p = p_orig.copy()
-        p.iloc[0] = df
-        assert_panel_equal(p, p_orig)
-
-        p = p_orig.copy()
-        p.loc['ItemA'] = df
-        assert_panel_equal(p, p_orig)
-
-        p = p_orig.copy()
-        p.loc['ItemA', :, :] = df
-        assert_panel_equal(p, p_orig)
-
-        p = p_orig.copy()
-        p['ItemA'] = df
-        assert_panel_equal(p, p_orig)
-
-        p = p_orig.copy()
-        p.iloc[0, [0, 1, 3, 5], -2:] = df
-        out = p.iloc[0, [0, 1, 3, 5], -2:]
-        assert_frame_equal(out, df.iloc[[0, 1, 3, 5], [2, 3]])
-
         # GH3830, panel assignent by values/frame
         for dtype in ['float64', 'int64']:
 
@@ -782,13 +173,6 @@ class CheckIndexing(object):
             tm.assert_frame_equal(panel.loc['a1'], df1)
             tm.assert_frame_equal(panel.loc['a2'], df2)
 
-    def _check_view(self, indexer, comp):
-        cp = self.panel.copy()
-        obj = cp.loc[indexer]
-        obj.values[:] = 0
-        assert (obj.values == 0).all()
-        comp(cp.loc[indexer].reindex_like(obj), obj)
-
     def test_logical_with_nas(self):
         d = Panel({'ItemA': {'a': [np.nan, False]},
                    'ItemB': {'a': [True, True]}})
@@ -802,157 +186,11 @@ class CheckIndexing(object):
         expected = DataFrame({'a': [True, True]})
         assert_frame_equal(result, expected)
 
-    def test_neg(self):
-        assert_panel_equal(-self.panel, -1 * self.panel)
-
-    def test_invert(self):
-        assert_panel_equal(-(self.panel < 0), ~(self.panel < 0))
-
-    def test_comparisons(self):
-        p1 = tm.makePanel()
-        p2 = tm.makePanel()
-
-        tp = p1.reindex(items=p1.items + ['foo'])
-        df = p1[p1.items[0]]
-
-        def test_comp(func):
-
-            # versus same index
-            result = func(p1, p2)
-            tm.assert_numpy_array_equal(result.values,
-                                        func(p1.values, p2.values))
-
-            # versus non-indexed same objs
-            pytest.raises(Exception, func, p1, tp)
-
-            # versus different objs
-            pytest.raises(Exception, func, p1, df)
-
-            # versus scalar
-            result3 = func(self.panel, 0)
-            tm.assert_numpy_array_equal(result3.values,
-                                        func(self.panel.values, 0))
-
-        with np.errstate(invalid='ignore'):
-            test_comp(operator.eq)
-            test_comp(operator.ne)
-            test_comp(operator.lt)
-            test_comp(operator.gt)
-            test_comp(operator.ge)
-            test_comp(operator.le)
-
-    def test_get_value(self):
-        for item in self.panel.items:
-            for mjr in self.panel.major_axis[::2]:
-                for mnr in self.panel.minor_axis:
-                    with tm.assert_produces_warning(FutureWarning,
-                                                    check_stacklevel=False):
-                        result = self.panel.get_value(item, mjr, mnr)
-                    expected = self.panel[item][mnr][mjr]
-                    assert_almost_equal(result, expected)
-        with catch_warnings():
-            simplefilter("ignore", FutureWarning)
-            msg = "There must be an argument for each axis"
-            with pytest.raises(TypeError, match=msg):
-                self.panel.get_value('a')
-
-    def test_set_value(self):
-        for item in self.panel.items:
-            for mjr in self.panel.major_axis[::2]:
-                for mnr in self.panel.minor_axis:
-                    with tm.assert_produces_warning(FutureWarning,
-                                                    check_stacklevel=False):
-                        self.panel.set_value(item, mjr, mnr, 1.)
-                    tm.assert_almost_equal(self.panel[item][mnr][mjr], 1.)
-
-        # resize
-        with catch_warnings():
-            simplefilter("ignore", FutureWarning)
-            res = self.panel.set_value('ItemE', 'foo', 'bar', 1.5)
-            assert isinstance(res, Panel)
-            assert res is not self.panel
-            assert res.get_value('ItemE', 'foo', 'bar') == 1.5
-
-            res3 = self.panel.set_value('ItemE', 'foobar', 'baz', 5)
-            assert is_float_dtype(res3['ItemE'].values)
-
-            msg = ("There must be an argument for each "
-                   "axis plus the value provided")
-            with pytest.raises(TypeError, match=msg):
-                self.panel.set_value('a')
-
 
 @pytest.mark.filterwarnings("ignore:\\nPanel:FutureWarning")
-class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
-                SafeForSparse):
-
-    def setup_method(self, method):
-        self.panel = make_test_panel()
-        self.panel.major_axis.name = None
-        self.panel.minor_axis.name = None
-        self.panel.items.name = None
-
-    def test_constructor(self):
-        # with BlockManager
-        wp = Panel(self.panel._data)
-        assert wp._data is self.panel._data
-
-        wp = Panel(self.panel._data, copy=True)
-        assert wp._data is not self.panel._data
-        tm.assert_panel_equal(wp, self.panel)
-
-        # strings handled prop
-        wp = Panel([[['foo', 'foo', 'foo', ], ['foo', 'foo', 'foo']]])
-        assert wp.values.dtype == np.object_
-
-        vals = self.panel.values
-
-        # no copy
-        wp = Panel(vals)
-        assert wp.values is vals
-
-        # copy
-        wp = Panel(vals, copy=True)
-        assert wp.values is not vals
-
-        # GH #8285, test when scalar data is used to construct a Panel
-        # if dtype is not passed, it should be inferred
-        value_and_dtype = [(1, 'int64'), (3.14, 'float64'),
-                           ('foo', np.object_)]
-        for (val, dtype) in value_and_dtype:
-            wp = Panel(val, items=range(2), major_axis=range(3),
-                       minor_axis=range(4))
-            vals = np.empty((2, 3, 4), dtype=dtype)
-            vals.fill(val)
-
-            tm.assert_panel_equal(wp, Panel(vals, dtype=dtype))
-
-        # test the case when dtype is passed
-        wp = Panel(1, items=range(2), major_axis=range(3),
-                   minor_axis=range(4),
-                   dtype='float32')
-        vals = np.empty((2, 3, 4), dtype='float32')
-        vals.fill(1)
-
-        tm.assert_panel_equal(wp, Panel(vals, dtype='float32'))
+class TestPanel(PanelTests, CheckIndexing, SafeForSparse):
 
     def test_constructor_cast(self):
-        zero_filled = self.panel.fillna(0)
-
-        casted = Panel(zero_filled._data, dtype=int)
-        casted2 = Panel(zero_filled.values, dtype=int)
-
-        exp_values = zero_filled.values.astype(int)
-        assert_almost_equal(casted.values, exp_values)
-        assert_almost_equal(casted2.values, exp_values)
-
-        casted = Panel(zero_filled._data, dtype=np.int32)
-        casted2 = Panel(zero_filled.values, dtype=np.int32)
-
-        exp_values = zero_filled.values.astype(np.int32)
-        assert_almost_equal(casted.values, exp_values)
-        assert_almost_equal(casted2.values, exp_values)
-
         # can't cast
         data = [[['foo', 'bar', 'baz']]]
         pytest.raises(ValueError, Panel, data, dtype=float)
@@ -1017,86 +255,6 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
         with pytest.raises(ValueError, match=msg):
                 Panel(np.random.randn(10, 2))
 
-    def test_consolidate(self):
-        assert self.panel._data.is_consolidated()
-
-        self.panel['foo'] = 1.
-        assert not self.panel._data.is_consolidated()
-
-        panel = self.panel._consolidate()
-        assert panel._data.is_consolidated()
-
-    def test_ctor_dict(self):
-        itema = self.panel['ItemA']
-        itemb = self.panel['ItemB']
-
-        d = {'A': itema, 'B': itemb[5:]}
-        d2 = {'A': itema._series, 'B': itemb[5:]._series}
-        d3 = {'A': None,
-              'B': DataFrame(itemb[5:]._series),
-              'C': DataFrame(itema._series)}
-
-        wp = Panel.from_dict(d)
-        wp2 = Panel.from_dict(d2)  # nested Dict
-
-        # TODO: unused?
-        wp3 = Panel.from_dict(d3)  # noqa
-
-        tm.assert_index_equal(wp.major_axis, self.panel.major_axis)
-        assert_panel_equal(wp, wp2)
-
-        # intersect
-        wp = Panel.from_dict(d, intersect=True)
-        tm.assert_index_equal(wp.major_axis, itemb.index[5:])
-
-        # use constructor
-        assert_panel_equal(Panel(d), Panel.from_dict(d))
-        assert_panel_equal(Panel(d2), Panel.from_dict(d2))
-        assert_panel_equal(Panel(d3), Panel.from_dict(d3))
-
-        # a pathological case
-        d4 = {'A': None, 'B': None}
-
-        # TODO: unused?
-        wp4 = Panel.from_dict(d4)  # noqa
-
-        assert_panel_equal(Panel(d4), Panel(items=['A', 'B']))
-
-        # cast
-        dcasted = {k: v.reindex(wp.major_axis).fillna(0)
-                   for k, v in compat.iteritems(d)}
-        result = Panel(dcasted, dtype=int)
-        expected = Panel({k: v.astype(int)
-                          for k, v in compat.iteritems(dcasted)})
-        assert_panel_equal(result, expected)
-
-        result = Panel(dcasted, dtype=np.int32)
-        expected = Panel({k: v.astype(np.int32)
-                          for k, v in compat.iteritems(dcasted)})
-        assert_panel_equal(result, expected)
-
-    def test_constructor_dict_mixed(self):
-        data = {k: v.values for k, v in self.panel.iteritems()}
-        result = Panel(data)
-        exp_major = Index(np.arange(len(self.panel.major_axis)))
-        tm.assert_index_equal(result.major_axis, exp_major)
-
-        result = Panel(data, items=self.panel.items,
-                       major_axis=self.panel.major_axis,
-                       minor_axis=self.panel.minor_axis)
-        assert_panel_equal(result, self.panel)
-
-        data['ItemC'] = self.panel['ItemC']
-        result = Panel(data)
-        assert_panel_equal(result, self.panel)
-
-        # corner, blow up
-        data['ItemB'] = data['ItemB'][:-1]
-        pytest.raises(Exception, Panel, data)
-
-        data['ItemB'] = self.panel['ItemB'].values[:, :-1]
-        pytest.raises(Exception, Panel, data)
-
     def test_ctor_orderedDict(self):
         keys = list(set(np.random.randint(0, 5000, 100)))[
             :50]  # unique random int  keys
@@ -1107,30 +265,6 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
         p = Panel.from_dict(d)
         assert list(p.items) == keys
 
-    def test_constructor_resize(self):
-        data = self.panel._data
-        items = self.panel.items[:-1]
-        major = self.panel.major_axis[:-1]
-        minor = self.panel.minor_axis[:-1]
-
-        result = Panel(data, items=items,
-                       major_axis=major, minor_axis=minor)
-        expected = self.panel.reindex(
-            items=items, major=major, minor=minor)
-        assert_panel_equal(result, expected)
-
-        result = Panel(data, items=items, major_axis=major)
-        expected = self.panel.reindex(items=items, major=major)
-        assert_panel_equal(result, expected)
-
-        result = Panel(data, items=items)
-        expected = self.panel.reindex(items=items)
-        assert_panel_equal(result, expected)
-
-        result = Panel(data, minor_axis=minor)
-        expected = self.panel.reindex(minor=minor)
-        assert_panel_equal(result, expected)
-
     def test_from_dict_mixed_orient(self):
         df = tm.makeDataFrame()
         df['foo'] = 'bar'
@@ -1161,13 +295,6 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
             Panel(np.random.randn(3, 4, 5),
                   lrange(5), lrange(5), lrange(4))
 
-    def test_conform(self):
-        df = self.panel['ItemA'][:-5].filter(items=['A', 'B'])
-        conformed = self.panel.conform(df)
-
-        tm.assert_index_equal(conformed.index, self.panel.major_axis)
-        tm.assert_index_equal(conformed.columns, self.panel.minor_axis)
-
     def test_convert_objects(self):
         # GH 4937
         p = Panel(dict(A=dict(a=['1', '1.0'])))
@@ -1175,12 +302,6 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
         result = p._convert(numeric=True, coerce=True)
         assert_panel_equal(result, expected)
 
-    def test_dtypes(self):
-
-        result = self.panel.dtypes
-        expected = Series(np.dtype('float64'), index=self.panel.items)
-        assert_series_equal(result, expected)
-
     def test_astype(self):
         # GH7271
         data = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
@@ -1193,121 +314,7 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
 
         pytest.raises(NotImplementedError, panel.astype, {0: str})
 
-    def test_apply(self):
-        # GH1148
-
-        # ufunc
-        applied = self.panel.apply(np.sqrt)
-        with np.errstate(invalid='ignore'):
-            expected = np.sqrt(self.panel.values)
-        assert_almost_equal(applied.values, expected)
-
-        # ufunc same shape
-        result = self.panel.apply(lambda x: x * 2, axis='items')
-        expected = self.panel * 2
-        assert_panel_equal(result, expected)
-        result = self.panel.apply(lambda x: x * 2, axis='major_axis')
-        expected = self.panel * 2
-        assert_panel_equal(result, expected)
-        result = self.panel.apply(lambda x: x * 2, axis='minor_axis')
-        expected = self.panel * 2
-        assert_panel_equal(result, expected)
-
-        # reduction to DataFrame
-        result = self.panel.apply(lambda x: x.dtype, axis='items')
-        expected = DataFrame(np.dtype('float64'),
-                             index=self.panel.major_axis,
-                             columns=self.panel.minor_axis)
-        assert_frame_equal(result, expected)
-        result = self.panel.apply(lambda x: x.dtype, axis='major_axis')
-        expected = DataFrame(np.dtype('float64'),
-                             index=self.panel.minor_axis,
-                             columns=self.panel.items)
-        assert_frame_equal(result, expected)
-        result = self.panel.apply(lambda x: x.dtype, axis='minor_axis')
-        expected = DataFrame(np.dtype('float64'),
-                             index=self.panel.major_axis,
-                             columns=self.panel.items)
-        assert_frame_equal(result, expected)
-
-        # reductions via other dims
-        expected = self.panel.sum(0)
-        result = self.panel.apply(lambda x: x.sum(), axis='items')
-        assert_frame_equal(result, expected)
-        expected = self.panel.sum(1)
-        result = self.panel.apply(lambda x: x.sum(), axis='major_axis')
-        assert_frame_equal(result, expected)
-        expected = self.panel.sum(2)
-        result = self.panel.apply(lambda x: x.sum(), axis='minor_axis')
-        assert_frame_equal(result, expected)
-
-        # pass kwargs
-        result = self.panel.apply(
-            lambda x, y: x.sum() + y, axis='items', y=5)
-        expected = self.panel.sum(0) + 5
-        assert_frame_equal(result, expected)
-
     def test_apply_slabs(self):
-
-        # same shape as original
-        result = self.panel.apply(lambda x: x * 2,
-                                  axis=['items', 'major_axis'])
-        expected = (self.panel * 2).transpose('minor_axis', 'major_axis',
-                                              'items')
-        assert_panel_equal(result, expected)
-        result = self.panel.apply(lambda x: x * 2,
-                                  axis=['major_axis', 'items'])
-        assert_panel_equal(result, expected)
-
-        result = self.panel.apply(lambda x: x * 2,
-                                  axis=['items', 'minor_axis'])
-        expected = (self.panel * 2).transpose('major_axis', 'minor_axis',
-                                              'items')
-        assert_panel_equal(result, expected)
-        result = self.panel.apply(lambda x: x * 2,
-                                  axis=['minor_axis', 'items'])
-        assert_panel_equal(result, expected)
-
-        result = self.panel.apply(lambda x: x * 2,
-                                  axis=['major_axis', 'minor_axis'])
-        expected = self.panel * 2
-        assert_panel_equal(result, expected)
-        result = self.panel.apply(lambda x: x * 2,
-                                  axis=['minor_axis', 'major_axis'])
-        assert_panel_equal(result, expected)
-
-        # reductions
-        result = self.panel.apply(lambda x: x.sum(0), axis=[
-            'items', 'major_axis'
-        ])
-        expected = self.panel.sum(1).T
-        assert_frame_equal(result, expected)
-
-        result = self.panel.apply(lambda x: x.sum(1), axis=[
-            'items', 'major_axis'
-        ])
-        expected = self.panel.sum(0)
-        assert_frame_equal(result, expected)
-
-        # transforms
-        f = lambda x: ((x.T - x.mean(1)) / x.std(1)).T
-
-        # make sure that we don't trigger any warnings
-        result = self.panel.apply(f, axis=['items', 'major_axis'])
-        expected = Panel({ax: f(self.panel.loc[:, :, ax])
-                          for ax in self.panel.minor_axis})
-        assert_panel_equal(result, expected)
-
-        result = self.panel.apply(f, axis=['major_axis', 'minor_axis'])
-        expected = Panel({ax: f(self.panel.loc[ax])
-                          for ax in self.panel.items})
-        assert_panel_equal(result, expected)
-
-        result = self.panel.apply(f, axis=['minor_axis', 'items'])
-        expected = Panel({ax: f(self.panel.loc[:, ax])
-                          for ax in self.panel.major_axis})
-        assert_panel_equal(result, expected)
-
         # with multi-indexes
         # GH7469
         index = MultiIndex.from_tuples([('one', 'a'), ('one', 'b'), (
@@ -1343,53 +350,6 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
         assert_series_equal(result_float, expected_float)
         assert_series_equal(result_float64, expected_float64)
 
-    def test_reindex(self):
-        ref = self.panel['ItemB']
-
-        # items
-        result = self.panel.reindex(items=['ItemA', 'ItemB'])
-        assert_frame_equal(result['ItemB'], ref)
-
-        # major
-        new_major = list(self.panel.major_axis[:10])
-        result = self.panel.reindex(major=new_major)
-        assert_frame_equal(result['ItemB'], ref.reindex(index=new_major))
-
-        # raise exception put both major and major_axis
-        pytest.raises(Exception, self.panel.reindex,
-                      major_axis=new_major,
-                      major=new_major)
-
-        # minor
-        new_minor = list(self.panel.minor_axis[:2])
-        result = self.panel.reindex(minor=new_minor)
-        assert_frame_equal(result['ItemB'], ref.reindex(columns=new_minor))
-
-        # raise exception put both major and major_axis
-        pytest.raises(Exception, self.panel.reindex,
-                      minor_axis=new_minor,
-                      minor=new_minor)
-
-        # this ok
-        result = self.panel.reindex()
-        assert_panel_equal(result, self.panel)
-        assert result is not self.panel
-
-        # with filling
-        smaller_major = self.panel.major_axis[::5]
-        smaller = self.panel.reindex(major=smaller_major)
-
-        larger = smaller.reindex(major=self.panel.major_axis, method='pad')
-
-        assert_frame_equal(larger.major_xs(self.panel.major_axis[1]),
-                           smaller.major_xs(smaller_major[0]))
-
-        # don't necessarily copy
-        result = self.panel.reindex(
-            major=self.panel.major_axis, copy=False)
-        assert_panel_equal(result, self.panel)
-        assert result is self.panel
-
     def test_reindex_axis_style(self):
         panel = Panel(np.random.rand(5, 5, 5))
         expected0 = Panel(panel.values).iloc[[0, 1]]
@@ -1410,22 +370,6 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
 
     def test_reindex_multi(self):
 
-        # with and without copy full reindexing
-        result = self.panel.reindex(
-            items=self.panel.items,
-            major=self.panel.major_axis,
-            minor=self.panel.minor_axis, copy=False)
-
-        assert result.items is self.panel.items
-        assert result.major_axis is self.panel.major_axis
-        assert result.minor_axis is self.panel.minor_axis
-
-        result = self.panel.reindex(
-            items=self.panel.items,
-            major=self.panel.major_axis,
-            minor=self.panel.minor_axis, copy=False)
-        assert_panel_equal(result, self.panel)
-
         # multi-axis indexing consistency
         # GH 5900
         df = DataFrame(np.random.randn(4, 3))
@@ -1454,86 +398,7 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
         for i, r in enumerate(results):
             assert_panel_equal(expected, r)
 
-    def test_reindex_like(self):
-        # reindex_like
-        smaller = self.panel.reindex(items=self.panel.items[:-1],
-                                     major=self.panel.major_axis[:-1],
-                                     minor=self.panel.minor_axis[:-1])
-        smaller_like = self.panel.reindex_like(smaller)
-        assert_panel_equal(smaller, smaller_like)
-
-    def test_take(self):
-        # axis == 0
-        result = self.panel.take([2, 0, 1], axis=0)
-        expected = self.panel.reindex(items=['ItemC', 'ItemA', 'ItemB'])
-        assert_panel_equal(result, expected)
-
-        # axis >= 1
-        result = self.panel.take([3, 0, 1, 2], axis=2)
-        expected = self.panel.reindex(minor=['D', 'A', 'B', 'C'])
-        assert_panel_equal(result, expected)
-
-        # neg indices ok
-        expected = self.panel.reindex(minor=['D', 'D', 'B', 'C'])
-        result = self.panel.take([3, -1, 1, 2], axis=2)
-        assert_panel_equal(result, expected)
-
-        pytest.raises(Exception, self.panel.take, [4, 0, 1, 2], axis=2)
-
-    def test_sort_index(self):
-        import random
-
-        ritems = list(self.panel.items)
-        rmajor = list(self.panel.major_axis)
-        rminor = list(self.panel.minor_axis)
-        random.shuffle(ritems)
-        random.shuffle(rmajor)
-        random.shuffle(rminor)
-
-        random_order = self.panel.reindex(items=ritems)
-        sorted_panel = random_order.sort_index(axis=0)
-        assert_panel_equal(sorted_panel, self.panel)
-
-        # descending
-        random_order = self.panel.reindex(items=ritems)
-        sorted_panel = random_order.sort_index(axis=0, ascending=False)
-        assert_panel_equal(
-            sorted_panel,
-            self.panel.reindex(items=self.panel.items[::-1]))
-
-        random_order = self.panel.reindex(major=rmajor)
-        sorted_panel = random_order.sort_index(axis=1)
-        assert_panel_equal(sorted_panel, self.panel)
-
-        random_order = self.panel.reindex(minor=rminor)
-        sorted_panel = random_order.sort_index(axis=2)
-        assert_panel_equal(sorted_panel, self.panel)
-
     def test_fillna(self):
-        filled = self.panel.fillna(0)
-        assert np.isfinite(filled.values).all()
-
-        filled = self.panel.fillna(method='backfill')
-        assert_frame_equal(filled['ItemA'],
-                           self.panel['ItemA'].fillna(method='backfill'))
-
-        panel = self.panel.copy()
-        panel['str'] = 'foo'
-
-        filled = panel.fillna(method='backfill')
-        assert_frame_equal(filled['ItemA'],
-                           panel['ItemA'].fillna(method='backfill'))
-
-        empty = self.panel.reindex(items=[])
-        filled = empty.fillna(0)
-        assert_panel_equal(filled, empty)
-
-        pytest.raises(ValueError, self.panel.fillna)
-        pytest.raises(ValueError, self.panel.fillna, 5, method='ffill')
-
-        pytest.raises(TypeError, self.panel.fillna, [1, 2])
-        pytest.raises(TypeError, self.panel.fillna, (1, 2))
-
         # limit not implemented when only value is specified
         p = Panel(np.random.randn(3, 4, 5))
         p.iloc[0:2, 0:2, 0:2] = np.nan
@@ -1559,100 +424,6 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
         p2.fillna(method='bfill', inplace=True)
         assert_panel_equal(p2, expected)
 
-    def test_ffill_bfill(self):
-        assert_panel_equal(self.panel.ffill(),
-                           self.panel.fillna(method='ffill'))
-        assert_panel_equal(self.panel.bfill(),
-                           self.panel.fillna(method='bfill'))
-
-    def test_truncate_fillna_bug(self):
-        # #1823
-        result = self.panel.truncate(before=None, after=None, axis='items')
-
-        # it works!
-        result.fillna(value=0.0)
-
-    def test_swapaxes(self):
-        result = self.panel.swapaxes('items', 'minor')
-        assert result.items is self.panel.minor_axis
-
-        result = self.panel.swapaxes('items', 'major')
-        assert result.items is self.panel.major_axis
-
-        result = self.panel.swapaxes('major', 'minor')
-        assert result.major_axis is self.panel.minor_axis
-
-        panel = self.panel.copy()
-        result = panel.swapaxes('major', 'minor')
-        panel.values[0, 0, 1] = np.nan
-        expected = panel.swapaxes('major', 'minor')
-        assert_panel_equal(result, expected)
-
-        # this should also work
-        result = self.panel.swapaxes(0, 1)
-        assert result.items is self.panel.major_axis
-
-        # this works, but return a copy
-        result = self.panel.swapaxes('items', 'items')
-        assert_panel_equal(self.panel, result)
-        assert id(self.panel) != id(result)
-
-    def test_transpose(self):
-        result = self.panel.transpose('minor', 'major', 'items')
-        expected = self.panel.swapaxes('items', 'minor')
-        assert_panel_equal(result, expected)
-
-        # test kwargs
-        result = self.panel.transpose(items='minor', major='major',
-                                      minor='items')
-        expected = self.panel.swapaxes('items', 'minor')
-        assert_panel_equal(result, expected)
-
-        # text mixture of args
-        result = self.panel.transpose(
-            'minor', major='major', minor='items')
-        expected = self.panel.swapaxes('items', 'minor')
-        assert_panel_equal(result, expected)
-
-        result = self.panel.transpose('minor',
-                                      'major',
-                                      minor='items')
-        expected = self.panel.swapaxes('items', 'minor')
-        assert_panel_equal(result, expected)
-
-        # duplicate axes
-        with pytest.raises(TypeError,
-                           match='not enough/duplicate arguments'):
-            self.panel.transpose('minor', maj='major', minor='items')
-
-        with pytest.raises(ValueError,
-                           match='repeated axis in transpose'):
-            self.panel.transpose('minor', 'major', major='minor',
-                                 minor='items')
-
-        result = self.panel.transpose(2, 1, 0)
-        assert_panel_equal(result, expected)
-
-        result = self.panel.transpose('minor', 'items', 'major')
-        expected = self.panel.swapaxes('items', 'minor')
-        expected = expected.swapaxes('major', 'minor')
-        assert_panel_equal(result, expected)
-
-        result = self.panel.transpose(2, 0, 1)
-        assert_panel_equal(result, expected)
-
-        pytest.raises(ValueError, self.panel.transpose, 0, 0, 1)
-
-    def test_transpose_copy(self):
-        panel = self.panel.copy()
-        result = panel.transpose(2, 0, 1, copy=True)
-        expected = panel.swapaxes('items', 'minor')
-        expected = expected.swapaxes('major', 'minor')
-        assert_panel_equal(result, expected)
-
-        panel.values[0, 1, 1] = np.nan
-        assert notna(result.values[1, 0, 1])
-
     def test_to_frame_multi_major(self):
         idx = MultiIndex.from_tuples(
             [(1, 'one'), (1, 'two'), (2, 'one'), (2, 'two')])
@@ -1815,40 +586,7 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
     def test_filter(self):
         pass
 
-    def test_compound(self):
-        compounded = self.panel.compound()
-
-        assert_series_equal(compounded['ItemA'],
-                            (1 + self.panel['ItemA']).product(0) - 1,
-                            check_names=False)
-
     def test_shift(self):
-        # major
-        idx = self.panel.major_axis[0]
-        idx_lag = self.panel.major_axis[1]
-        shifted = self.panel.shift(1)
-        assert_frame_equal(self.panel.major_xs(idx),
-                           shifted.major_xs(idx_lag))
-
-        # minor
-        idx = self.panel.minor_axis[0]
-        idx_lag = self.panel.minor_axis[1]
-        shifted = self.panel.shift(1, axis='minor')
-        assert_frame_equal(self.panel.minor_xs(idx),
-                           shifted.minor_xs(idx_lag))
-
-        # items
-        idx = self.panel.items[0]
-        idx_lag = self.panel.items[1]
-        shifted = self.panel.shift(1, axis='items')
-        assert_frame_equal(self.panel[idx], shifted[idx_lag])
-
-        # negative numbers, #2164
-        result = self.panel.shift(-1)
-        expected = Panel({i: f.shift(-1)[:-1]
-                          for i, f in self.panel.iteritems()})
-        assert_panel_equal(result, expected)
-
         # mixed dtypes #6959
         data = [('item ' + ch, makeMixedDataFrame())
                 for ch in list('abcde')]
@@ -1857,29 +595,6 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
         shifted = mixed_panel.shift(1)
         assert_series_equal(mixed_panel.dtypes, shifted.dtypes)
 
-    def test_tshift(self):
-
-        # DatetimeIndex
-        panel = make_test_panel()
-        shifted = panel.tshift(1)
-        unshifted = shifted.tshift(-1)
-
-        assert_panel_equal(panel, unshifted)
-
-        shifted2 = panel.tshift(freq=panel.major_axis.freq)
-        assert_panel_equal(shifted, shifted2)
-
-        inferred_ts = Panel(panel.values, items=panel.items,
-                            major_axis=Index(np.asarray(panel.major_axis)),
-                            minor_axis=panel.minor_axis)
-        shifted = inferred_ts.tshift(1)
-        unshifted = shifted.tshift(-1)
-        assert_panel_equal(shifted, panel.tshift(1))
-        assert_panel_equal(unshifted, inferred_ts)
-
-        no_freq = panel.iloc[:, [0, 5, 7], :]
-        pytest.raises(ValueError, no_freq.tshift)
-
     def test_pct_change(self):
         df1 = DataFrame({'c1': [1, 2, 5], 'c2': [3, 4, 6]})
         df2 = df1 + 1
@@ -1992,89 +707,10 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
         MultiIndex.from_tuples([('a', 1), ('a', 2), ('b', 1)],
                                names=['first', 'second'])
 
-    @pytest.mark.filterwarnings("ignore:Using a non-tuple:FutureWarning")
-    def test_multiindex_blocks(self):
-        ind = MultiIndex.from_tuples([('a', 1), ('a', 2), ('b', 1)],
-                                     names=['first', 'second'])
-        wp = Panel(self.panel._data)
-        wp.items = ind
-        f1 = wp['a']
-        assert (f1.items == [1, 2]).all()
-
-        f1 = wp[('b', 1)]
-        assert (f1.columns == ['A', 'B', 'C', 'D']).all()
-
     def test_repr_empty(self):
         empty = Panel()
         repr(empty)
 
-    # ignore warning from us, because removing panel
-    @pytest.mark.filterwarnings("ignore:Using:FutureWarning")
-    def test_rename(self):
-        mapper = {'ItemA': 'foo', 'ItemB': 'bar', 'ItemC': 'baz'}
-
-        renamed = self.panel.rename(items=mapper)
-        exp = Index(['foo', 'bar', 'baz'])
-        tm.assert_index_equal(renamed.items, exp)
-
-        renamed = self.panel.rename(minor_axis=str.lower)
-        exp = Index(['a', 'b', 'c', 'd'])
-        tm.assert_index_equal(renamed.minor_axis, exp)
-
-        # don't copy
-        renamed_nocopy = self.panel.rename(items=mapper, copy=False)
-        renamed_nocopy['foo'] = 3.
-        assert (self.panel['ItemA'].values == 3).all()
-
-    def test_get_attr(self):
-        assert_frame_equal(self.panel['ItemA'], self.panel.ItemA)
-
-        # specific cases from #3440
-        self.panel['a'] = self.panel['ItemA']
-        assert_frame_equal(self.panel['a'], self.panel.a)
-        self.panel['i'] = self.panel['ItemA']
-        assert_frame_equal(self.panel['i'], self.panel.i)
-
-    def test_to_excel(self):
-        try:
-            import xlwt  # noqa
-            import xlrd  # noqa
-            import openpyxl  # noqa
-            from pandas.io.excel import ExcelFile
-        except ImportError:
-            pytest.skip("need xlwt xlrd openpyxl")
-
-        for ext in ['xls', 'xlsx']:
-            with ensure_clean('__tmp__.' + ext) as path:
-                self.panel.to_excel(path)
-                try:
-                    reader = ExcelFile(path)
-                except ImportError:
-                    pytest.skip("need xlwt xlrd openpyxl")
-
-                for item, df in self.panel.iteritems():
-                    recdf = reader.parse(str(item), index_col=0)
-                    assert_frame_equal(df, recdf)
-
-    def test_to_excel_xlsxwriter(self):
-        try:
-            import xlrd  # noqa
-            import xlsxwriter  # noqa
-            from pandas.io.excel import ExcelFile
-        except ImportError:
-            pytest.skip("Requires xlrd and xlsxwriter. Skipping test.")
-
-        with ensure_clean('__tmp__.xlsx') as path:
-            self.panel.to_excel(path, engine='xlsxwriter')
-            try:
-                reader = ExcelFile(path)
-            except ImportError as e:
-                pytest.skip("cannot write excel file: %s" % e)
-
-            for item, df in self.panel.iteritems():
-                recdf = reader.parse(str(item), index_col=0)
-                assert_frame_equal(df, recdf)
-
     @pytest.mark.filterwarnings("ignore:'.reindex:FutureWarning")
     def test_dropna(self):
         p = Panel(np.random.randn(4, 5, 6), major_axis=list('abcde'))
@@ -2275,132 +911,6 @@ class TestPanel(PanelTests, CheckIndexing, SafeForLongAndSparse,
         with tm.assert_produces_warning(FutureWarning):
             pan.update(other, raise_conflict=raise_conflict)
 
-    def test_all_any(self):
-        assert (self.panel.all(axis=0).values == nanall(
-            self.panel, axis=0)).all()
-        assert (self.panel.all(axis=1).values == nanall(
-            self.panel, axis=1).T).all()
-        assert (self.panel.all(axis=2).values == nanall(
-            self.panel, axis=2).T).all()
-        assert (self.panel.any(axis=0).values == nanany(
-            self.panel, axis=0)).all()
-        assert (self.panel.any(axis=1).values == nanany(
-            self.panel, axis=1).T).all()
-        assert (self.panel.any(axis=2).values == nanany(
-            self.panel, axis=2).T).all()
-
-    def test_all_any_unhandled(self):
-        pytest.raises(NotImplementedError, self.panel.all, bool_only=True)
-        pytest.raises(NotImplementedError, self.panel.any, bool_only=True)
-
-    # GH issue 15960
-    def test_sort_values(self):
-        pytest.raises(NotImplementedError, self.panel.sort_values)
-        pytest.raises(NotImplementedError, self.panel.sort_values, 'ItemA')
-
-
-@pytest.mark.filterwarnings("ignore:\\nPanel:FutureWarning")
-class TestPanelFrame(object):
-    """
-    Check that conversions to and from Panel to DataFrame work.
-    """
-
-    def setup_method(self, method):
-        panel = make_test_panel()
-        self.panel = panel.to_frame()
-        self.unfiltered_panel = panel.to_frame(filter_observations=False)
-
-    def test_ops_scalar(self):
-        result = self.panel.mul(2)
-        expected = DataFrame.__mul__(self.panel, 2)
-        assert_frame_equal(result, expected)
-
-    def test_combine_scalar(self):
-        result = self.panel.mul(2)
-        expected = DataFrame(self.panel._data) * 2
-        assert_frame_equal(result, expected)
-
-    def test_combine_series(self):
-        s = self.panel['ItemA'][:10]
-        result = self.panel.add(s, axis=0)
-        expected = DataFrame.add(self.panel, s, axis=0)
-        assert_frame_equal(result, expected)
-
-        s = self.panel.iloc[5]
-        result = self.panel + s
-        expected = DataFrame.add(self.panel, s, axis=1)
-        assert_frame_equal(result, expected)
-
-    def test_sort(self):
-        def is_sorted(arr):
-            return (arr[1:] > arr[:-1]).any()
-
-        sorted_minor = self.panel.sort_index(level=1)
-        assert is_sorted(sorted_minor.index.codes[1])
-
-        sorted_major = sorted_minor.sort_index(level=0)
-        assert is_sorted(sorted_major.index.codes[0])
-
-    def test_to_string(self):
-        buf = StringIO()
-        self.panel.to_string(buf)
-
-    def test_to_sparse(self):
-        if isinstance(self.panel, Panel):
-            msg = 'sparsifying is not supported'
-            with pytest.raises(NotImplementedError, match=msg):
-                self.panel.to_sparse
-
-    def test_axis_dummies(self):
-        from pandas.core.reshape.reshape import make_axis_dummies
-
-        minor_dummies = make_axis_dummies(self.panel, 'minor').astype(np.uint8)
-        assert len(minor_dummies.columns) == len(self.panel.index.levels[1])
-
-        major_dummies = make_axis_dummies(self.panel, 'major').astype(np.uint8)
-        assert len(major_dummies.columns) == len(self.panel.index.levels[0])
-
-        mapping = {'A': 'one', 'B': 'one', 'C': 'two', 'D': 'two'}
-
-        transformed = make_axis_dummies(self.panel, 'minor',
-                                        transform=mapping.get).astype(np.uint8)
-        assert len(transformed.columns) == 2
-        tm.assert_index_equal(transformed.columns, Index(['one', 'two']))
-
-        # TODO: test correctness
-
-    def test_get_dummies(self):
-        from pandas.core.reshape.reshape import get_dummies, make_axis_dummies
-
-        self.panel['Label'] = self.panel.index.codes[1]
-        minor_dummies = make_axis_dummies(self.panel, 'minor').astype(np.uint8)
-        dummies = get_dummies(self.panel['Label'])
-        tm.assert_numpy_array_equal(dummies.values, minor_dummies.values)
-
-    def test_count(self):
-        index = self.panel.index
-
-        major_count = self.panel.count(level=0)['ItemA']
-        level_codes = index.codes[0]
-        for i, idx in enumerate(index.levels[0]):
-            assert major_count[i] == (level_codes == i).sum()
-
-        minor_count = self.panel.count(level=1)['ItemA']
-        level_codes = index.codes[1]
-        for i, idx in enumerate(index.levels[1]):
-            assert minor_count[i] == (level_codes == i).sum()
-
-    def test_join(self):
-        lp1 = self.panel.filter(['ItemA', 'ItemB'])
-        lp2 = self.panel.filter(['ItemC'])
-
-        joined = lp1.join(lp2)
-
-        assert len(joined.columns) == 3
-
-        pytest.raises(Exception, lp1.join,
-                      self.panel.filter(['ItemB', 'ItemC']))
-
 
 def test_panel_index():
     index = panelm.panel_index([1, 2, 3, 4], [1, 2, 3])
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index 053927a77..387f40234 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -34,7 +34,7 @@ from pandas.core.dtypes.missing import array_equivalent
 import pandas as pd
 from pandas import (
     Categorical, CategoricalIndex, DataFrame, DatetimeIndex, Index,
-    IntervalIndex, MultiIndex, Panel, RangeIndex, Series, bdate_range)
+    IntervalIndex, MultiIndex, RangeIndex, Series, bdate_range)
 from pandas.core.algorithms import take_1d
 from pandas.core.arrays import (
     DatetimeArray, ExtensionArray, IntervalArray, PeriodArray, TimedeltaArray,
@@ -2052,14 +2052,6 @@ def makePeriodFrame(nper=None):
     return DataFrame(data)
 
 
-def makePanel(nper=None):
-    with warnings.catch_warnings(record=True):
-        warnings.filterwarnings("ignore", "\\nPanel", FutureWarning)
-        cols = ['Item' + c for c in string.ascii_uppercase[:K - 1]]
-        data = {c: makeTimeDataFrame(nper) for c in cols}
-        return Panel.fromDict(data)
-
-
 def makeCustomIndex(nentries, nlevels, prefix='#', names=False, ndupe_l=None,
                     idx_type=None):
     """Create an index/multindex with given dimensions, levels, names, etc'
@@ -2307,15 +2299,6 @@ def makeMissingDataframe(density=.9, random_state=None):
     return df
 
 
-def add_nans(panel):
-    I, J, N = panel.shape
-    for i, item in enumerate(panel.items):
-        dm = panel[item]
-        for j, col in enumerate(dm.columns):
-            dm[col][:i + j] = np.NaN
-    return panel
-
-
 class TestSubDict(dict):
 
     def __init__(self, *args, **kwargs):

commit 99eab4b7330edc19034096a72acdc4e616833c26
Author: Adam Klein <adamklein@gmail.com>
Date:   Sun Mar 11 18:28:44 2012 -0700

    ENH: add very basic interval slicing to intervalindex

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index ea2f73052..fa379c4cc 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -123,13 +123,13 @@ def dt64arr_to_sktsarr(data, freq):
         return data
 
     if isinstance(freq, basestring):
-        freq = _interval_freq_map[freq]
+        freq = _interval_code_map[freq]
 
     return lib.dt64arr_to_sktsarr(data.view('i8'), freq)
 
 # interval frequency constants corresponding to scikits timeseries
 # originals
-_interval_freq_map = {
+_interval_code_map = {
     "A"     : 1000,  # Annual
     "A@DEC" : 1000,  # Annual - December year end
     "A@JAN" : 1001,  # Annual - January year end
@@ -194,9 +194,18 @@ _interval_freq_map = {
     None     : -10000  # Undefined
 }
 
-_reverse_interval_map = {}
-for k, v in _interval_freq_map.iteritems():
-    _reverse_interval_map[v] = k
+_reverse_interval_code_map = {}
+for k, v in _interval_code_map.iteritems():
+    _reverse_interval_code_map[v] = k
+
+_reso_interval_map = {
+    "year"   : "A",
+    "month"  : "M",
+    "day"    : "D",
+    "hour"   : "H",
+    "minute" : "Min",
+    "second" : "S",
+}
 
 class Interval:
     def __init__(self, value=None, freq=None,
@@ -208,7 +217,7 @@ class Interval:
 
         if freq is not None:
             if isinstance(freq, basestring):
-                self.freq = _interval_freq_map[freq]
+                self.freq = _interval_code_map[freq]
             else:
                 self.freq = freq
 
@@ -241,21 +250,21 @@ class Interval:
 
             if freq is None:
                 if reso == 'year':
-                    self.freq = _interval_freq_map['A']
+                    self.freq = _interval_code_map['A']
                 elif reso == 'month':
-                    self.freq = _interval_freq_map['M']
+                    self.freq = _interval_code_map['M']
                 elif reso == 'day':
-                    self.freq = _interval_freq_map['D']
+                    self.freq = _interval_code_map['D']
                 elif reso == 'hour':
-                    self.freq = _interval_freq_map['H']
+                    self.freq = _interval_code_map['H']
                 elif reso == 'minute':
-                    self.freq = _interval_freq_map['Min']
+                    self.freq = _interval_code_map['Min']
                 elif reso == 'second':
-                    self.freq = _interval_freq_map['S']
+                    self.freq = _interval_code_map['S']
                 else:
                     raise ValueError("Could not infer frequency for interval")
             else:
-                self.freq = _interval_freq_map[freq]
+                self.freq = _interval_code_map[freq]
         elif isinstance(value, datetime):
             dt = value
         elif isinstance(value, (int, long)):
@@ -291,7 +300,7 @@ class Interval:
             raise ValueError('How must be one of S or E')
 
         if isinstance(freq, basestring):
-            freq = _interval_freq_map[freq]
+            freq = _interval_code_map[freq]
 
         new_ordinal = lib.skts_freq_conv(self.ordinal,
                                          self.freq, freq, how)
@@ -301,9 +310,9 @@ class Interval:
     @classmethod
     def now(cls, freq=None):
         if isinstance(freq, basestring):
-            freq = _interval_freq_map[freq]
+            freq = _interval_code_map[freq]
 
-        sfreq = _interval_freq_map['S']
+        sfreq = _interval_code_map['S']
 
         dt = datetime.now()
 
@@ -314,13 +323,19 @@ class Interval:
 
     def __repr__(self):
         formatted = lib.skts_ordinal_to_string(self.ordinal, self.freq)
-        freqstr = _reverse_interval_map[self.freq]
+        freqstr = _reverse_interval_code_map[self.freq]
         return ("Interval('%s', '%s')" % (formatted, freqstr))
 
     def __str__(self):
         formatted = lib.skts_ordinal_to_string(self.ordinal, self.freq)
         return ("%s" % formatted)
 
+def _infer_interval_group(freqstr):
+    return _interval_group(_reso_interval_map[freqstr])
+
+def _interval_group(freqstr):
+    grp = _interval_code_map[freqstr]
+    return grp // 1000 * 1000
 
 #-------------------------------------------------------------------------------
 # Miscellaneous date functions
@@ -396,7 +411,7 @@ def parse_time_string(arg):
                 if not stopped:
                     reso = attr
                 else:
-                    raise DateParseError("Missing attribute before %s", attr)
+                    raise DateParseError("Missing attribute before %s" % attr)
             else:
                 stopped = True
         ret = default.replace(**repl)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 101e29d75..c2aa52db8 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1809,10 +1809,10 @@ class DatetimeIndex(Int64Index):
 
 class IntervalIndex(Int64Index):
     """
-    Immutable ndarray holding ordinal values which represent intervals of a
-    particular frequency. A value of 1 represents the interval containing the
-    Gregorian proleptic date/time Jan 1, 0001 00:00:00. This representation
-    is borrowed from the scikits.timeseries project.
+    Immutable ndarray holding ordinal values indicating regular intervals in
+    time such as particular years, quarters, months, etc. A value of 1 is the
+    interval containing the Gregorian proleptic datetime Jan 1, 0001 00:00:00.
+    This ordinal representation is from the scikits.timeseries project.
 
     For instance,
         # construct interval for day 1/1/1 and get the first second
@@ -1934,8 +1934,18 @@ class IntervalIndex(Int64Index):
         except KeyError:
             try:
                 asdt, parsed, reso = datetools.parse_time_string(key)
-                # TODO: add partial date slicing
-                key = to_interval(asdt, freq=self.freq).ordinal
+                grp = datetools._infer_interval_group(reso)
+                freqn = datetools._interval_group(self.freq)
+
+                # if our data is higher resolution than requested key, slice
+                if grp < freqn:
+                    iv = Interval(asdt, freq=grp)
+                    ord1 = iv.asfreq(self.freq, how='S').ordinal
+                    ord2 = iv.asfreq(self.freq, how='E').ordinal
+                    pos = np.searchsorted(self.values, [ord1, ord2])
+                    key = slice(pos[0], pos[1]+1)
+                else:
+                    key = to_interval(asdt, freq=self.freq).ordinal
                 return series[key]
             except TypeError:
                 pass
diff --git a/pandas/tests/test_datetime64.py b/pandas/tests/test_datetime64.py
index 8dd1361d1..01f5e3883 100644
--- a/pandas/tests/test_datetime64.py
+++ b/pandas/tests/test_datetime64.py
@@ -248,10 +248,10 @@ class TestDatetime64(unittest.TestCase):
         self.assertEquals(dti.dayofweek[0], 5)
 
         self.assertEquals(dti.dayofyear[0], 31)
-        self.assertEquals(dti.dayofyear[1], 120) 
+        self.assertEquals(dti.dayofyear[1], 120)
 
         self.assertEquals(dti.weekofyear[0], 5)
-        self.assertEquals(dti.weekofyear[1], 18) 
+        self.assertEquals(dti.weekofyear[1], 18)
 
         self.assertEquals(dti.quarter[0], 1)
         self.assertEquals(dti.quarter[1], 2)
@@ -607,6 +607,16 @@ class TestDatetime64(unittest.TestCase):
         i1 = Interval('3/10/12')
         self.assertRaises(Exception, i1.asfreq, 'B')
 
+    def test_interval_slice_index(self):
+        ii = IntervalIndex(start='1/1/10', end='12/31/12', freq='M')
+        s = Series(np.random.rand(len(ii)), index=ii)
+        res = s['2010']
+        exp = s[0:12]
+        assert_series_equal(res, exp)
+        res = s['2011']
+        exp = s[12:24]
+        assert_series_equal(res, exp)
+
     def test_intervalindex_constructor(self):
         pass
         #ii = IntervalIndex(freq='M', start='1/1/2005', end='12/1/2005')

commit fe34b32b0014979eba6e8b6a714c5e2b76c1612b
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Mon Dec 4 03:21:49 2017 -0800

    timestamp/timedelta test cleanup (#18619)

diff --git a/pandas/tests/scalar/test_timedelta.py b/pandas/tests/scalar/test_timedelta.py
index 17c818779..001f6c1fd 100644
--- a/pandas/tests/scalar/test_timedelta.py
+++ b/pandas/tests/scalar/test_timedelta.py
@@ -15,6 +15,28 @@ from pandas._libs.tslib import iNaT, NaT
 class TestTimedeltaArithmetic(object):
     _multiprocess_can_split_ = True
 
+    def test_arithmetic_overflow(self):
+        with pytest.raises(OverflowError):
+            pd.Timestamp('1700-01-01') + pd.Timedelta(13 * 19999, unit='D')
+
+        with pytest.raises(OverflowError):
+            pd.Timestamp('1700-01-01') + timedelta(days=13 * 19999)
+
+    def test_ops_error_str(self):
+        # GH 13624
+        td = Timedelta('1 day')
+
+        for left, right in [(td, 'a'), ('a', td)]:
+
+            with pytest.raises(TypeError):
+                left + right
+
+            with pytest.raises(TypeError):
+                left > right
+
+            assert not left == right
+            assert left != right
+
     def test_to_timedelta_on_nanoseconds(self):
         # GH 9273
         result = Timedelta(nanoseconds=100)
@@ -93,38 +115,53 @@ class TestTimedeltaArithmetic(object):
         assert Timedelta(239, unit='h') == td - pd.offsets.Hour(1)
         assert Timedelta(-239, unit='h') == pd.offsets.Hour(1) - td
 
-    # TODO: Split by op, better name
-    def test_ops(self):
+    def test_unary_ops(self):
         td = Timedelta(10, unit='d')
+
+        # __neg__, __pos__
         assert -td == Timedelta(-10, unit='d')
+        assert -td == Timedelta('-10d')
         assert +td == Timedelta(10, unit='d')
-        assert td - td == Timedelta(0, unit='ns')
+
+        # __abs__, __abs__(__neg__)
+        assert abs(td) == td
+        assert abs(-td) == td
+        assert abs(-td) == Timedelta('10d')
+
+    def test_binary_ops_nat(self):
+        td = Timedelta(10, unit='d')
+
         assert (td - pd.NaT) is pd.NaT
-        assert td + td == Timedelta(20, unit='d')
         assert (td + pd.NaT) is pd.NaT
-        assert td * 2 == Timedelta(20, unit='d')
         assert (td * pd.NaT) is pd.NaT
-        assert td / 2 == Timedelta(5, unit='d')
-        assert td // 2 == Timedelta(5, unit='d')
-        assert abs(td) == td
-        assert abs(-td) == td
-        assert td / td == 1
         assert (td / pd.NaT) is np.nan
         assert (td // pd.NaT) is np.nan
 
+    def test_binary_ops_integers(self):
+        td = Timedelta(10, unit='d')
+
+        assert td * 2 == Timedelta(20, unit='d')
+        assert td / 2 == Timedelta(5, unit='d')
+        assert td // 2 == Timedelta(5, unit='d')
+
         # invert
-        assert -td == Timedelta('-10d')
         assert td * -1 == Timedelta('-10d')
         assert -1 * td == Timedelta('-10d')
-        assert abs(-td) == Timedelta('10d')
-
-        # invalid multiply with another timedelta
-        pytest.raises(TypeError, lambda: td * td)
 
         # can't operate with integers
         pytest.raises(TypeError, lambda: td + 2)
         pytest.raises(TypeError, lambda: td - 2)
 
+    def test_binary_ops_with_timedelta(self):
+        td = Timedelta(10, unit='d')
+
+        assert td - td == Timedelta(0, unit='ns')
+        assert td + td == Timedelta(20, unit='d')
+        assert td / td == 1
+
+        # invalid multiply with another timedelta
+        pytest.raises(TypeError, lambda: td * td)
+
 
 class TestTimedeltas(object):
     _multiprocess_can_split_ = True
@@ -733,14 +770,6 @@ class TestTimedeltas(object):
             tm.assert_series_equal(result_operator, expected)
             tm.assert_series_equal(result_method, expected)
 
-    def test_arithmetic_overflow(self):
-
-        with pytest.raises(OverflowError):
-            pd.Timestamp('1700-01-01') + pd.Timedelta(13 * 19999, unit='D')
-
-        with pytest.raises(OverflowError):
-            pd.Timestamp('1700-01-01') + timedelta(days=13 * 19999)
-
     def test_apply_to_timedelta(self):
         timedelta_NaT = pd.to_timedelta('NaT')
 
@@ -803,18 +832,3 @@ class TestTimedeltas(object):
         result = Timedelta(minutes=1).isoformat()
         expected = 'P0DT0H1M0S'
         assert result == expected
-
-    def test_ops_error_str(self):
-        # GH 13624
-        td = Timedelta('1 day')
-
-        for l, r in [(td, 'a'), ('a', td)]:
-
-            with pytest.raises(TypeError):
-                l + r
-
-            with pytest.raises(TypeError):
-                l > r
-
-            assert not l == r
-            assert l != r
diff --git a/pandas/tests/scalar/test_timestamp.py b/pandas/tests/scalar/test_timestamp.py
index 9d9705756..dab508de3 100644
--- a/pandas/tests/scalar/test_timestamp.py
+++ b/pandas/tests/scalar/test_timestamp.py
@@ -45,6 +45,11 @@ class TestTimestampArithmetic(object):
         with pytest.raises(OverflowError):
             stamp - offset
 
+    def test_delta_preserve_nanos(self):
+        val = Timestamp(long(1337299200000000123))
+        result = val + timedelta(1)
+        assert result.nanosecond == val.nanosecond
+
 
 class TestTimestampProperties(object):
 
@@ -68,7 +73,7 @@ class TestTimestampProperties(object):
         assert control.is_quarter_end
 
 
-class TestTimestamp(object):
+class TestTimestampConstructors(object):
 
     def test_constructor(self):
         base_str = '2014-07-01 09:00'
@@ -290,6 +295,17 @@ class TestTimestamp(object):
         assert Timestamp('2000-01-01', tz='US/Eastern') == ts
         assert base.toordinal() == ts.toordinal()
 
+        # GH#3042
+        dt = datetime(2011, 4, 16, 0, 0)
+        ts = Timestamp.fromordinal(dt.toordinal())
+        assert ts.to_pydatetime() == dt
+
+        # with a tzinfo
+        stamp = Timestamp('2011-4-16', tz='US/Eastern')
+        dt_tz = stamp.to_pydatetime()
+        ts = Timestamp.fromordinal(dt_tz.toordinal(), tz='US/Eastern')
+        assert ts.to_pydatetime() == dt_tz
+
     def test_constructor_offset_depr(self):
         # see gh-12160
         with tm.assert_produces_warning(FutureWarning,
@@ -320,6 +336,9 @@ class TestTimestamp(object):
         with tm.assert_raises_regex(TypeError, msg):
             Timestamp.fromordinal(base.toordinal(), offset='D', freq='D')
 
+
+class TestTimestamp(object):
+
     def test_conversion(self):
         # GH 9255
         ts = Timestamp('2000-01-01')
@@ -335,10 +354,10 @@ class TestTimestamp(object):
         assert type(result) == type(expected)
         assert result.dtype == expected.dtype
 
-    def test_repr(self):
-        dates = ['2014-03-07', '2014-01-01 09:00',
-                 '2014-01-01 00:00:00.000000001']
-
+    @pytest.mark.parametrize('freq', ['D', 'M', 'S', 'N'])
+    @pytest.mark.parametrize('date', ['2014-03-07', '2014-01-01 09:00',
+                                      '2014-01-01 00:00:00.000000001'])
+    def test_repr(self, date, freq):
         # dateutil zone change (only matters for repr)
         if (dateutil.__version__ >= LooseVersion('2.3') and
             (dateutil.__version__ <= LooseVersion('2.4.0') or
@@ -349,43 +368,40 @@ class TestTimestamp(object):
             timezones = ['UTC', 'Asia/Tokyo', 'US/Eastern',
                          'dateutil/America/Los_Angeles']
 
-        freqs = ['D', 'M', 'S', 'N']
-
-        for date in dates:
-            for tz in timezones:
-                for freq in freqs:
-
-                    # avoid to match with timezone name
-                    freq_repr = "'{0}'".format(freq)
-                    if tz.startswith('dateutil'):
-                        tz_repr = tz.replace('dateutil', '')
-                    else:
-                        tz_repr = tz
-
-                    date_only = Timestamp(date)
-                    assert date in repr(date_only)
-                    assert tz_repr not in repr(date_only)
-                    assert freq_repr not in repr(date_only)
-                    assert date_only == eval(repr(date_only))
-
-                    date_tz = Timestamp(date, tz=tz)
-                    assert date in repr(date_tz)
-                    assert tz_repr in repr(date_tz)
-                    assert freq_repr not in repr(date_tz)
-                    assert date_tz == eval(repr(date_tz))
-
-                    date_freq = Timestamp(date, freq=freq)
-                    assert date in repr(date_freq)
-                    assert tz_repr not in repr(date_freq)
-                    assert freq_repr in repr(date_freq)
-                    assert date_freq == eval(repr(date_freq))
-
-                    date_tz_freq = Timestamp(date, tz=tz, freq=freq)
-                    assert date in repr(date_tz_freq)
-                    assert tz_repr in repr(date_tz_freq)
-                    assert freq_repr in repr(date_tz_freq)
-                    assert date_tz_freq == eval(repr(date_tz_freq))
+        for tz in timezones:
 
+            # avoid to match with timezone name
+            freq_repr = "'{0}'".format(freq)
+            if tz.startswith('dateutil'):
+                tz_repr = tz.replace('dateutil', '')
+            else:
+                tz_repr = tz
+
+            date_only = Timestamp(date)
+            assert date in repr(date_only)
+            assert tz_repr not in repr(date_only)
+            assert freq_repr not in repr(date_only)
+            assert date_only == eval(repr(date_only))
+
+            date_tz = Timestamp(date, tz=tz)
+            assert date in repr(date_tz)
+            assert tz_repr in repr(date_tz)
+            assert freq_repr not in repr(date_tz)
+            assert date_tz == eval(repr(date_tz))
+
+            date_freq = Timestamp(date, freq=freq)
+            assert date in repr(date_freq)
+            assert tz_repr not in repr(date_freq)
+            assert freq_repr in repr(date_freq)
+            assert date_freq == eval(repr(date_freq))
+
+            date_tz_freq = Timestamp(date, tz=tz, freq=freq)
+            assert date in repr(date_tz_freq)
+            assert tz_repr in repr(date_tz_freq)
+            assert freq_repr in repr(date_tz_freq)
+            assert date_tz_freq == eval(repr(date_tz_freq))
+
+    def test_repr_utcoffset(self):
         # This can cause the tz field to be populated, but it's redundant to
         # include this information in the date-string.
         date_with_utc_offset = Timestamp('2014-03-13 00:00:00-0400', tz=None)
@@ -396,6 +412,16 @@ class TestTimestamp(object):
                                                   'pytz.FixedOffset(-240)')
         assert date_with_utc_offset == eval(expr)
 
+    def test_timestamp_repr_pre1900(self):
+        # pre-1900
+        stamp = Timestamp('1850-01-01', tz='US/Eastern')
+        repr(stamp)
+
+        iso8601 = '1850-01-01 01:23:45.012345'
+        stamp = Timestamp(iso8601, tz='US/Eastern')
+        result = repr(stamp)
+        assert iso8601 in result
+
     def test_bounds_with_different_units(self):
         out_of_bounds_dates = ('1677-09-21', '2262-04-12', )
 
@@ -474,32 +500,34 @@ class TestTimestamp(object):
         pytest.raises(AmbiguousTimeError,
                       ts.tz_localize, 'US/Pacific', errors='coerce')
 
-    def test_tz_localize_roundtrip(self):
-        for tz in ['UTC', 'Asia/Tokyo', 'US/Eastern', 'dateutil/US/Pacific']:
-            for t in ['2014-02-01 09:00', '2014-07-08 09:00',
-                      '2014-11-01 17:00', '2014-11-05 00:00']:
-                ts = Timestamp(t)
-                localized = ts.tz_localize(tz)
-                assert localized == Timestamp(t, tz=tz)
-
-                with pytest.raises(TypeError):
-                    localized.tz_localize(tz)
-
-                reset = localized.tz_localize(None)
-                assert reset == ts
-                assert reset.tzinfo is None
-
-    def test_tz_convert_roundtrip(self):
-        for tz in ['UTC', 'Asia/Tokyo', 'US/Eastern', 'dateutil/US/Pacific']:
-            for t in ['2014-02-01 09:00', '2014-07-08 09:00',
-                      '2014-11-01 17:00', '2014-11-05 00:00']:
-                ts = Timestamp(t, tz='UTC')
-                converted = ts.tz_convert(tz)
-
-                reset = converted.tz_convert(None)
-                assert reset == Timestamp(t)
-                assert reset.tzinfo is None
-                assert reset == converted.tz_convert('UTC').tz_localize(None)
+    @pytest.mark.parametrize('tz', ['UTC', 'Asia/Tokyo',
+                                    'US/Eastern', 'dateutil/US/Pacific'])
+    def test_tz_localize_roundtrip(self, tz):
+        for t in ['2014-02-01 09:00', '2014-07-08 09:00',
+                  '2014-11-01 17:00', '2014-11-05 00:00']:
+            ts = Timestamp(t)
+            localized = ts.tz_localize(tz)
+            assert localized == Timestamp(t, tz=tz)
+
+            with pytest.raises(TypeError):
+                localized.tz_localize(tz)
+
+            reset = localized.tz_localize(None)
+            assert reset == ts
+            assert reset.tzinfo is None
+
+    @pytest.mark.parametrize('tz', ['UTC', 'Asia/Tokyo',
+                                    'US/Eastern', 'dateutil/US/Pacific'])
+    def test_tz_convert_roundtrip(self, tz):
+        for t in ['2014-02-01 09:00', '2014-07-08 09:00',
+                  '2014-11-01 17:00', '2014-11-05 00:00']:
+            ts = Timestamp(t, tz='UTC')
+            converted = ts.tz_convert(tz)
+
+            reset = converted.tz_convert(None)
+            assert reset == Timestamp(t)
+            assert reset.tzinfo is None
+            assert reset == converted.tz_convert('UTC').tz_localize(None)
 
     def test_barely_oob_dts(self):
         one_us = np.timedelta64(1).astype('timedelta64[us]')
@@ -906,6 +934,51 @@ class TestTimestamp(object):
         assert result == Timestamp(str(base) + ".200005")
         assert result.microsecond == 5 + 200 * 1000
 
+    def test_hash_equivalent(self):
+        d = {datetime(2011, 1, 1): 5}
+        stamp = Timestamp(datetime(2011, 1, 1))
+        assert d[stamp] == 5
+
+    @pytest.mark.parametrize('tz', [None, 'UTC', 'US/Eastern', 'Asia/Tokyo'])
+    def test_is_leap_year(self, tz):
+        # GH 13727
+        dt = Timestamp('2000-01-01 00:00:00', tz=tz)
+        assert dt.is_leap_year
+        assert isinstance(dt.is_leap_year, bool)
+
+        dt = Timestamp('1999-01-01 00:00:00', tz=tz)
+        assert not dt.is_leap_year
+
+        dt = Timestamp('2004-01-01 00:00:00', tz=tz)
+        assert dt.is_leap_year
+
+        dt = Timestamp('2100-01-01 00:00:00', tz=tz)
+        assert not dt.is_leap_year
+
+    def test_timestamp(self):
+        # GH#17329
+        # tz-naive --> treat it as if it were UTC for purposes of timestamp()
+        ts = Timestamp.now()
+        uts = ts.replace(tzinfo=utc)
+        assert ts.timestamp() == uts.timestamp()
+
+        tsc = Timestamp('2014-10-11 11:00:01.12345678', tz='US/Central')
+        utsc = tsc.tz_convert('UTC')
+
+        # utsc is a different representation of the same time
+        assert tsc.timestamp() == utsc.timestamp()
+
+        if PY3:
+
+            # datetime.timestamp() converts in the local timezone
+            with tm.set_timezone('UTC'):
+
+                # should agree with datetime.timestamp method
+                dt = ts.to_pydatetime()
+                assert dt.timestamp() == ts.timestamp()
+
+
+class TestTimestampComparison(object):
     def test_comparison(self):
         # 5-18-2012 00:00:00.000
         stamp = long(1337299200000000000)
@@ -937,7 +1010,6 @@ class TestTimestamp(object):
         assert other >= val
 
     def test_compare_invalid(self):
-
         # GH 8058
         val = Timestamp('20130101 12:01:02')
         assert not val == 'foo'
@@ -1028,16 +1100,6 @@ class TestTimestamp(object):
             assert not a == b.to_pydatetime()
             assert not a.to_pydatetime() == b
 
-    def test_delta_preserve_nanos(self):
-        val = Timestamp(long(1337299200000000123))
-        result = val + timedelta(1)
-        assert result.nanosecond == val.nanosecond
-
-    def test_hash_equivalent(self):
-        d = {datetime(2011, 1, 1): 5}
-        stamp = Timestamp(datetime(2011, 1, 1))
-        assert d[stamp] == 5
-
     def test_timestamp_compare_scalars(self):
         # case where ndim == 0
         lhs = np.datetime64(datetime(2013, 12, 6))
@@ -1098,43 +1160,20 @@ class TestTimestamp(object):
             result = right_f(Timestamp('nat'), s_nat)
             tm.assert_series_equal(result, expected)
 
-    def test_is_leap_year(self):
-        # GH 13727
-        for tz in [None, 'UTC', 'US/Eastern', 'Asia/Tokyo']:
-            dt = Timestamp('2000-01-01 00:00:00', tz=tz)
-            assert dt.is_leap_year
-            assert isinstance(dt.is_leap_year, bool)
-
-            dt = Timestamp('1999-01-01 00:00:00', tz=tz)
-            assert not dt.is_leap_year
-
-            dt = Timestamp('2004-01-01 00:00:00', tz=tz)
-            assert dt.is_leap_year
-
-            dt = Timestamp('2100-01-01 00:00:00', tz=tz)
-            assert not dt.is_leap_year
-
-    def test_timestamp(self):
-        # GH#17329
-        # tz-naive --> treat it as if it were UTC for purposes of timestamp()
-        ts = Timestamp.now()
-        uts = ts.replace(tzinfo=utc)
-        assert ts.timestamp() == uts.timestamp()
-
-        tsc = Timestamp('2014-10-11 11:00:01.12345678', tz='US/Central')
-        utsc = tsc.tz_convert('UTC')
-
-        # utsc is a different representation of the same time
-        assert tsc.timestamp() == utsc.timestamp()
-
-        if PY3:
-
-            # datetime.timestamp() converts in the local timezone
-            with tm.set_timezone('UTC'):
+    def test_timestamp_compare_with_early_datetime(self):
+        # e.g. datetime.min
+        stamp = Timestamp('2012-01-01')
 
-                # should agree with datetime.timestamp method
-                dt = ts.to_pydatetime()
-                assert dt.timestamp() == ts.timestamp()
+        assert not stamp == datetime.min
+        assert not stamp == datetime(1600, 1, 1)
+        assert not stamp == datetime(2700, 1, 1)
+        assert stamp != datetime.min
+        assert stamp != datetime(1600, 1, 1)
+        assert stamp != datetime(2700, 1, 1)
+        assert stamp > datetime(1600, 1, 1)
+        assert stamp >= datetime(1600, 1, 1)
+        assert stamp < datetime(2700, 1, 1)
+        assert stamp <= datetime(2700, 1, 1)
 
 
 class TestTimestampNsOperations(object):
@@ -1281,7 +1320,9 @@ class TestTimestampOps(object):
         assert (timestamp_instance -
                 timedelta64_instance).freq == original_freq
 
-    def test_resolution(self):
+    @pytest.mark.parametrize('tz', [None, 'Asia/Tokyo', 'US/Eastern',
+                                    'dateutil/US/Eastern'])
+    def test_resolution(self, tz):
 
         for freq, expected in zip(['A', 'Q', 'M', 'D', 'H', 'T',
                                    'S', 'L', 'U'],
@@ -1290,12 +1331,9 @@ class TestTimestampOps(object):
                                    RESO_HR, RESO_MIN,
                                    RESO_SEC, RESO_MS,
                                    RESO_US]):
-            for tz in [None, 'Asia/Tokyo', 'US/Eastern',
-                       'dateutil/US/Eastern']:
-                idx = date_range(start='2013-04-01', periods=30, freq=freq,
-                                 tz=tz)
-                result = period.resolution(idx.asi8, idx.tz)
-                assert result == expected
+            idx = date_range(start='2013-04-01', periods=30, freq=freq, tz=tz)
+            result = period.resolution(idx.asi8, idx.tz)
+            assert result == expected
 
 
 class TestTimestampToJulianDate(object):
@@ -1321,8 +1359,7 @@ class TestTimestampToJulianDate(object):
         assert r == 2451769.0416666666666666
 
 
-class TestTimeSeries(object):
-
+class TestTimestampConversion(object):
     def test_timestamp_to_datetime(self):
         stamp = Timestamp('20090415', tz='US/Eastern', freq='D')
         dtval = stamp.to_pydatetime()
@@ -1350,47 +1387,25 @@ class TestTimeSeries(object):
         assert stamp == dtval
         assert stamp.tzinfo == dtval.tzinfo
 
-    def test_timestamp_date_out_of_range(self):
-        pytest.raises(ValueError, Timestamp, '1676-01-01')
-        pytest.raises(ValueError, Timestamp, '2263-01-01')
-
-    def test_timestamp_repr(self):
-        # pre-1900
-        stamp = Timestamp('1850-01-01', tz='US/Eastern')
-        repr(stamp)
-
-        iso8601 = '1850-01-01 01:23:45.012345'
-        stamp = Timestamp(iso8601, tz='US/Eastern')
-        result = repr(stamp)
-        assert iso8601 in result
-
-    def test_timestamp_from_ordinal(self):
+    def test_to_datetime_bijective(self):
+        # Ensure that converting to datetime and back only loses precision
+        # by going from nanoseconds to microseconds.
+        exp_warning = None if Timestamp.max.nanosecond == 0 else UserWarning
+        with tm.assert_produces_warning(exp_warning, check_stacklevel=False):
+            assert (Timestamp(Timestamp.max.to_pydatetime()).value / 1000 ==
+                    Timestamp.max.value / 1000)
 
-        # GH 3042
-        dt = datetime(2011, 4, 16, 0, 0)
-        ts = Timestamp.fromordinal(dt.toordinal())
-        assert ts.to_pydatetime() == dt
+        exp_warning = None if Timestamp.min.nanosecond == 0 else UserWarning
+        with tm.assert_produces_warning(exp_warning, check_stacklevel=False):
+            assert (Timestamp(Timestamp.min.to_pydatetime()).value / 1000 ==
+                    Timestamp.min.value / 1000)
 
-        # with a tzinfo
-        stamp = Timestamp('2011-4-16', tz='US/Eastern')
-        dt_tz = stamp.to_pydatetime()
-        ts = Timestamp.fromordinal(dt_tz.toordinal(), tz='US/Eastern')
-        assert ts.to_pydatetime() == dt_tz
 
-    def test_timestamp_compare_with_early_datetime(self):
-        # e.g. datetime.min
-        stamp = Timestamp('2012-01-01')
+class TestTimeSeries(object):
 
-        assert not stamp == datetime.min
-        assert not stamp == datetime(1600, 1, 1)
-        assert not stamp == datetime(2700, 1, 1)
-        assert stamp != datetime.min
-        assert stamp != datetime(1600, 1, 1)
-        assert stamp != datetime(2700, 1, 1)
-        assert stamp > datetime(1600, 1, 1)
-        assert stamp >= datetime(1600, 1, 1)
-        assert stamp < datetime(2700, 1, 1)
-        assert stamp <= datetime(2700, 1, 1)
+    def test_timestamp_date_out_of_range(self):
+        pytest.raises(ValueError, Timestamp, '1676-01-01')
+        pytest.raises(ValueError, Timestamp, '2263-01-01')
 
     def test_timestamp_equality(self):
 
@@ -1483,16 +1498,3 @@ class TestTsUtil(object):
     def test_max_valid(self):
         # Ensure that Timestamp.max is a valid Timestamp
         Timestamp(Timestamp.max)
-
-    def test_to_datetime_bijective(self):
-        # Ensure that converting to datetime and back only loses precision
-        # by going from nanoseconds to microseconds.
-        exp_warning = None if Timestamp.max.nanosecond == 0 else UserWarning
-        with tm.assert_produces_warning(exp_warning, check_stacklevel=False):
-            assert (Timestamp(Timestamp.max.to_pydatetime()).value / 1000 ==
-                    Timestamp.max.value / 1000)
-
-        exp_warning = None if Timestamp.min.nanosecond == 0 else UserWarning
-        with tm.assert_produces_warning(exp_warning, check_stacklevel=False):
-            assert (Timestamp(Timestamp.min.to_pydatetime()).value / 1000 ==
-                    Timestamp.min.value / 1000)

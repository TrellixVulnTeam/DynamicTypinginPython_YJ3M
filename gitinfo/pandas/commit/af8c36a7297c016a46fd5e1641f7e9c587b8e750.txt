commit af8c36a7297c016a46fd5e1641f7e9c587b8e750
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon May 14 21:01:02 2012 -0400

    ENH: support different 'bases' when resampling regular intervals like 5 minute, close #1119

diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 5bd41423c..41b293c17 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -155,9 +155,9 @@ class PandasObject(object):
         from pandas.tseries.resample import asfreq
         return asfreq(self, freq, method=method, how=how)
 
-    def resample(self, rule, how='mean', axis=0,
-                 fill_method=None, closed='right', label='right',
-                 convention=None, kind=None, loffset=None, limit=None):
+    def resample(self, rule, how='mean', axis=0, fill_method=None,
+                 closed='right', label='right', convention=None,
+                 kind=None, loffset=None, limit=None, base=0):
         """
         Convenience method for frequency conversion and resampling of regular
         time-series data.
@@ -175,12 +175,16 @@ class PandasObject(object):
         convention : {'start', 'end', 's', 'e'}
         loffset : timedelta
             Adjust the resampled time labels
+        base : int, default 0
+            For frequencies that evenly subdivide 1 day, the "origin" of the
+            aggregated intervals. For example, for '5min' frequency, base could
+            range from 0 through 4. Defaults to 0
         """
         from pandas.tseries.resample import TimeGrouper
         sampler = TimeGrouper(rule, label=label, closed=closed, how=how,
                               axis=axis, kind=kind, loffset=loffset,
                               fill_method=fill_method, convention=convention,
-                              limit=limit)
+                              limit=limit, base=base)
         return sampler.resample(self)
 
     def first(self, offset):
diff --git a/pandas/tseries/resample.py b/pandas/tseries/resample.py
index 081375f82..20ad5e0ce 100644
--- a/pandas/tseries/resample.py
+++ b/pandas/tseries/resample.py
@@ -37,7 +37,7 @@ class TimeGrouper(CustomGrouper):
     def __init__(self, freq='Min', closed='right', label='right', how='mean',
                  begin=None, end=None, nperiods=None, axis=0,
                  fill_method=None, limit=None, loffset=None, kind=None,
-                 convention=None):
+                 convention=None, base=0):
         self.freq = freq
         self.closed = closed
         self.label = label
@@ -51,6 +51,7 @@ class TimeGrouper(CustomGrouper):
         self.how = how
         self.fill_method = fill_method
         self.limit = limit
+        self.base = base
 
     def resample(self, obj):
         axis = obj._get_axis(self.axis)
@@ -88,9 +89,33 @@ class TimeGrouper(CustomGrouper):
         return binner, grouper
 
     def _get_time_bins(self, axis):
-        return _make_time_bins(axis, self.freq, begin=self.begin,
-                               end=self.end, closed=self.closed,
-                               label=self.label)
+        assert(isinstance(axis, DatetimeIndex))
+
+        if len(axis) == 0:
+            # TODO: Should we be a bit more careful here?
+            return [], [], []
+
+        first, last = _get_range_edges(axis, self.begin, self.end, self.freq,
+                                       closed=self.closed, base=self.base)
+        binner = DatetimeIndex(freq=self.freq, start=first, end=last)
+
+        # a little hack
+        trimmed = False
+        if len(binner) > 2 and binner[-2] == axis[-1]:
+            binner = binner[:-1]
+            trimmed = True
+
+        # general version, knowing nothing about relative frequencies
+        bins = lib.generate_bins_dt64(axis.asi8, binner.asi8, self.closed)
+
+        if self.label == 'right':
+            labels = binner[1:]
+        elif not trimmed:
+            labels = binner[:-1]
+        else:
+            labels = binner
+
+        return binner, bins, labels
 
     def _get_time_period_bins(self, axis):
         return _make_period_bins(axis, self.freq, begin=self.begin,
@@ -210,36 +235,8 @@ def _make_period_bins(axis, freq, begin=None, end=None,
     return binner, bins, labels
 
 
-def _make_time_bins(axis, freq, begin=None, end=None,
-                    closed='right', label='right'):
-    assert(isinstance(axis, DatetimeIndex))
-
-    if len(axis) == 0:
-        # TODO: Should we be a bit more careful here?
-        return [], [], []
-
-    first, last = _get_range_edges(axis, begin, end, freq, closed=closed)
-    binner = DatetimeIndex(freq=freq, start=first, end=last)
-
-    # a little hack
-    trimmed = False
-    if len(binner) > 2 and binner[-2] == axis[-1]:
-        binner = binner[:-1]
-        trimmed = True
-
-    # general version, knowing nothing about relative frequencies
-    bins = lib.generate_bins_dt64(axis.asi8, binner.asi8, closed)
-
-    if label == 'right':
-        labels = binner[1:]
-    elif not trimmed:
-        labels = binner[:-1]
-    else:
-        labels = binner
-
-    return binner, bins, labels
-
-def _get_range_edges(axis, begin, end, offset, closed='left'):
+def _get_range_edges(axis, begin, end, offset, closed='left',
+                     base=0):
     from pandas.tseries.offsets import Tick, _delta_to_microseconds
     if isinstance(offset, basestring):
         offset = to_offset(offset)
@@ -253,7 +250,7 @@ def _get_range_edges(axis, begin, end, offset, closed='left'):
         if ((day_micros % offset.micros) == 0 and begin is None
             and end is None):
             return _adjust_dates_anchored(axis[0], axis[-1], offset,
-                                          closed=closed)
+                                          closed=closed, base=base)
 
     if begin is None:
         if closed == 'left':
@@ -271,12 +268,16 @@ def _get_range_edges(axis, begin, end, offset, closed='left'):
     return first, last
 
 
-def _adjust_dates_anchored(first, last, offset, closed='right'):
+def _adjust_dates_anchored(first, last, offset, closed='right', base=0):
     from pandas.tseries.tools import normalize_date
 
     start_day_micros = Timestamp(normalize_date(first)).value
     last_day_micros = Timestamp(normalize_date(last)).value
 
+    base_micros = (base % offset.n) * offset.micros / offset.n
+    start_day_micros += base_micros
+    last_day_micros += base_micros
+
     foffset = (first.value - start_day_micros) % offset.micros
     loffset = (last.value - last_day_micros) % offset.micros
 
diff --git a/pandas/tseries/tests/test_resample.py b/pandas/tseries/tests/test_resample.py
index 5b3613e57..875b5c94f 100644
--- a/pandas/tseries/tests/test_resample.py
+++ b/pandas/tseries/tests/test_resample.py
@@ -363,6 +363,15 @@ class TestResample(unittest.TestCase):
             expected = ts.resample(freq, closed='left', label='left')
             assert_series_equal(result, expected)
 
+    def test_resample_base(self):
+        rng = date_range('1/1/2000 00:00:00', '1/1/2000 02:00', freq='s')
+        ts = Series(np.random.randn(len(rng)), index=rng)
+
+        resampled = ts.resample('5min', base=2)
+        exp_rng = date_range('1/1/2000 00:02:00', '1/1/2000 02:02',
+                             freq='5min')
+        self.assert_(resampled.index.equals(exp_rng))
+
     def test_resample_daily_anchored(self):
         rng = date_range('1/1/2000 0:00:00', periods=10000, freq='T')
         ts = Series(np.random.randn(len(rng)), index=rng)

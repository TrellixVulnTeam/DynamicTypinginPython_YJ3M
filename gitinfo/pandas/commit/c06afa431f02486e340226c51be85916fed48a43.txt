commit c06afa431f02486e340226c51be85916fed48a43
Author: Adam Klein <adamklein@gmail.com>
Date:   Fri Dec 30 16:59:06 2011 -0500

    added test coverage, fixed DateRange join bug

diff --git a/RELEASE.rst b/RELEASE.rst
index e470ebaa9..c37001441 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -115,6 +115,8 @@ pandas 0.6.2
     #546)
   - Fix exception when setting scalar value using .ix on a DataFrame with a
     MultiIndex (GH #551)
+  - Fix outer join between two DateRanges with different offsets that returned
+    an invalid DateRange
 
 Thanks
 ------
diff --git a/pandas/core/common.py b/pandas/core/common.py
index de91a2767..06c794bdb 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -299,8 +299,8 @@ def _possibly_cast_item(obj, item, dtype):
     if chunk.values.dtype != dtype:
         if dtype in (np.object_, np.bool_):
             obj[item] = chunk.astype(np.object_)
-        elif not issubclass(dtype, (np.integer, np.bool_)):
-            obj[item] = chunk.astype(np.object_)
+        elif not issubclass(dtype, (np.integer, np.bool_)): # pragma: no cover
+            raise ValueError("Unexpected dtype encountered: %s" % dtype)
 
 def _is_bool_indexer(key):
     if isinstance(key, np.ndarray) and key.dtype == np.object_:
@@ -672,7 +672,8 @@ def _asarray_tuplesafe(values, dtype=None):
         if isinstance(values, list):
             return lib.list_to_object_array(values)
         else:
-            # give it our best shot
+            # Making a 1D array that safely contains tuples is a bit tricky
+            # in numpy, leading to the following
             result = np.empty(len(values), dtype=object)
             result[:] = values
 
diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index 4b7be2342..a55e2eb59 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -292,17 +292,16 @@ class DateRange(Index):
             return Index.union(self, other)
 
     def _wrap_union_result(self, other, result):
+        # If we are here, _can_fast_union is false or other is not a
+        # DateRange, so their union has to be an Index.
         name = self.name if self.name == other.name else None
-        if isinstance(other, DateRange) and self._can_fast_union(other):
-            result = self._view_like(result)
-            result.name = name
-            return result
-        else:
-            return Index(result, name=name)
+        return Index(result, name=name)
 
     def _wrap_joined_index(self, joined, other):
         name = self.name if self.name == other.name else None
-        if isinstance(other, DateRange) and self._can_fast_union(other):
+        if (isinstance(other, DateRange)
+            and self.offset == other.offset
+            and self._can_fast_union(other)):
             joined = self._view_like(joined)
             joined.name = name
             return joined
diff --git a/pandas/tests/test_daterange.py b/pandas/tests/test_daterange.py
index d5e237135..b6acadd2c 100644
--- a/pandas/tests/test_daterange.py
+++ b/pandas/tests/test_daterange.py
@@ -162,6 +162,36 @@ class TestDateRange(unittest.TestCase):
         the_union = self.rng.union(rng)
         self.assert_(not isinstance(the_union, DateRange))
 
+    def test_outer_join(self):
+        """ should behave just as union test"""
+        # overlapping
+        left = self.rng[:10]
+        right = self.rng[5:10]
+
+        the_join = left.join(right, how='outer')
+        self.assert_(isinstance(the_join, DateRange))
+
+        # non-overlapping, gap in middle
+        left = self.rng[:5]
+        right = self.rng[10:]
+
+        the_join = left.join(right, how='outer')
+        self.assert_(isinstance(the_join, Index))
+        self.assert_(not isinstance(the_join, DateRange))
+
+        # non-overlapping, no gap
+        left = self.rng[:5]
+        right = self.rng[5:10]
+
+        the_join = left.join(right, how='outer')
+        self.assert_(isinstance(the_join, DateRange))
+
+        # overlapping, but different offset
+        rng = DateRange(START, END, offset=datetools.bmonthEnd)
+
+        the_join = self.rng.join(rng, how='outer')
+        self.assert_(not isinstance(the_join, DateRange))
+
     def test_union_not_cacheable(self):
         rng = DateRange('1/1/2000', periods=50, offset=datetools.Minute())
         rng1 = rng[10:]
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 04e164114..3e71ac643 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -1553,6 +1553,9 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         com.set_printoptions(precision=3, column_space=10)
         repr(self.frame)
 
+        com.set_printoptions(max_rows=10, max_columns=2)
+        repr(self.frame)
+
     def test_repr_embedded_ndarray(self):
         arr = np.empty(10, dtype=[('err', object)])
         for i in range(len(arr)):
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index f09fd6346..9b48ea7a8 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -208,11 +208,16 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         expected = Series([1, 2, nan, 0], index=['b', 'c', 'd', 'a'])
         assert_series_equal(result, expected)
 
-    def test_constructor_tuples(self):
+    def test_constructor_list_of_tuples(self):
         data = [(1, 1), (2, 2), (2, 3)]
         s = Series(data)
         self.assertEqual(list(s), data)
 
+    def test_constructor_tuple_of_tuples(self):
+        data = ((1, 1), (2, 2), (2, 3))
+        s = Series(data)
+        self.assertEqual(tuple(s), data)
+
     def test_fromDict(self):
         data = {'a' : 0, 'b' : 1, 'c' : 2, 'd' : 3}
 

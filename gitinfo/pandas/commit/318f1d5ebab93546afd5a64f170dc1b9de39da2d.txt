commit 318f1d5ebab93546afd5a64f170dc1b9de39da2d
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jan 2 16:11:02 2012 -0500

    ENH: logy option to Seires.plot, release notes, bump dev version to 0.7.0

diff --git a/RELEASE.rst b/RELEASE.rst
index 5d6588ea4..ac43ae7ab 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -38,14 +38,18 @@ pandas 0.7.0
     constructor (GH #526)
   - Add ``reorder_levels`` method to Series and DataFrame (PR #534)
   - Add dict-like ``get`` function to DataFrame and Panel (PR #521)
-  - DataFrame.iterrows method for efficiently iterating through the rows of a
-    DataFrame
+  - ``DataFrame.iterrows`` method for efficiently iterating through the rows of
+    a DataFrame
   - Added ``DataFrame.to_panel`` with code adapted from ``LongPanel.to_long``
   - ``reindex_axis`` method added to DataFrame
   - Add ``level`` option to binary arithmetic functions on ``DataFrame`` and
     ``Series``
   - Add ``level`` option to the ``reindex`` and ``align`` methods on Series and
     DataFrame for broadcasting values across a level (GH #542, PR #552, others)
+  - Add attribute-based item access to ``Panel`` and add IPython completion (PR
+    #563)
+  - Can pass list of dicts to DataFrame constructor (GH #526)
+  - Add ``logy`` option to ``Series.plot`` for log-scaling on the Y axis
 
 **API Changes**
 
@@ -80,6 +84,8 @@ pandas 0.7.0
     also (GH #536)
   - Default name assignment when calling ``reset_index`` on DataFrame with a
     regular (non-hierarchical) index (GH #476)
+  - Use Cythonized groupers when possible in Series/DataFrame stat ops with
+    ``level`` parameter passed (GH #545)
 
 **Bug fixes**
 
@@ -111,7 +117,7 @@ pandas 0.7.0
   - Fix type inference logic with boolean lists and arrays in DataFrame indexing
   - Use centered sum of squares in R-square computation if entity_effects=True
     in panel regression
-  - Handle all NA case in Series.corr, was raising exception (GH #548)
+  - Handle all NA case in Series.{corr, cov}, was raising exception (GH #548)
   - Aggregating by multiple levels with ``level`` argument to DataFrame, Series
     stat method, was broken (GH #545)
   - Fix Cython buf when converter passed to read_csv produced a numeric array
@@ -123,6 +129,11 @@ pandas 0.7.0
     an invalid DateRange
   - Cleanup DataFrame.from_records failure where index argument is an integer
   - Fix Data.from_records failure when passed a dictionary
+  - Fix NA handling in {Series, DataFrame}.rank with non-floating point dtypes
+  - Fix bug related to integer type-checking in .ix-based indexing
+  - Handle non-string index name passed to DataFrame.from_records
+  - DataFrame.insert caused the columns name(s) field to be discarded (GH #527)
+
 
 Thanks
 ------
@@ -205,6 +216,7 @@ pandas 0.6.1
   - MultiIndex.get_level_values can take the level name
   - More helpful error message when DataFrame.plot fails on one of the columns
     (GH #478)
+  - Improve performance of DataFrame.{index, columns} attribute lookup
 
 **Bug fixes**
 
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 971b9cdba..784fd1867 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1657,7 +1657,7 @@ copy : boolean, default False
 # Miscellaneous
 
     def plot(self, label=None, kind='line', use_index=True, rot=30, ax=None,
-             style='-', grid=True, **kwds):
+             style='-', grid=True, logy=False, **kwds):
         """
         Plot the input series with the index on the x-axis using matplotlib
 
@@ -1698,7 +1698,10 @@ copy : boolean, default False
             else:
                 x = range(len(self))
 
-            ax.plot(x, self.values.astype(float), style, **kwds)
+            if logy:
+                ax.semilogy(x, self.values.astype(float), style, **kwds)
+            else:
+                ax.plot(x, self.values.astype(float), style, **kwds)
         elif kind == 'bar':
             xinds = np.arange(N) + 0.25
             ax.bar(xinds, self.values.astype(float), 0.5,
diff --git a/pandas/src/moments.pyx b/pandas/src/moments.pyx
index 91bf73525..0cbe0ebb5 100644
--- a/pandas/src/moments.pyx
+++ b/pandas/src/moments.pyx
@@ -439,7 +439,64 @@ cdef _roll_skiplist_op(ndarray arg, int win, int minp, skiplist_f op):
 
     return output
 
-def roll_median(ndarray input, int win, int minp):
+from skiplist cimport *
+
+def roll_median_c(ndarray[float64_t] arg, int win, int minp):
+    cdef double val, res, prev
+    cdef:
+        int ret
+        skiplist_t *sl
+        Py_ssize_t midpoint, nobs = 0, i
+
+
+    cdef Py_ssize_t N = len(arg)
+    cdef ndarray[double_t] output = np.empty(N, dtype=float)
+
+    sl = skiplist_init(win)
+
+    minp = _check_minp(minp, N)
+
+    for i from 0 <= i < minp - 1:
+        val = arg[i]
+
+        # Not NaN
+        if val == val:
+            nobs += 1
+            skiplist_insert(sl, val)
+
+        output[i] = NaN
+
+    for i from minp - 1 <= i < N:
+        val = arg[i]
+
+        if i > win - 1:
+            prev = arg[i - win]
+
+            if prev == prev:
+                skiplist_remove(sl, prev)
+                nobs -= 1
+
+        if val == val:
+            nobs += 1
+            skiplist_insert(sl, val)
+
+        if nobs >= minp:
+            midpoint = nobs / 2
+            if nobs % 2:
+                res = skiplist_get(sl, midpoint, &ret)
+            else:
+                res = (skiplist_get(sl, midpoint, &ret) +
+                       skiplist_get(sl, (midpoint - 1), &ret)) / 2
+        else:
+            res = NaN
+
+        output[i] = res
+
+    skiplist_destroy(sl)
+
+    return output
+
+def roll_median_cython(ndarray input, int win, int minp):
     '''
     O(N log(window)) implementation using skip list
     '''
diff --git a/pandas/src/sandbox.pyx b/pandas/src/sandbox.pyx
index 5d7cc8167..12ad94a0c 100644
--- a/pandas/src/sandbox.pyx
+++ b/pandas/src/sandbox.pyx
@@ -118,58 +118,3 @@ def _check_minp(minp, N):
     elif minp < 0:
         raise ValueError('min_periods must be >= 0')
     return minp
-
-def roll_median(ndarray[float64_t] arg, int win, int minp):
-    cdef double val, res, prev
-    cdef:
-        int ret
-        skiplist_t *sl
-        Py_ssize_t midpoint, nobs = 0, i
-
-
-    cdef Py_ssize_t N = len(arg)
-    cdef ndarray[double_t] output = np.empty(N, dtype=float)
-
-    sl = skiplist_init(win)
-
-    minp = _check_minp(minp, N)
-
-    for i from 0 <= i < minp - 1:
-        val = arg[i]
-
-        # Not NaN
-        if val == val:
-            nobs += 1
-            skiplist_insert(sl, val)
-
-        output[i] = NaN
-
-    for i from minp - 1 <= i < N:
-        val = arg[i]
-
-        if i > win - 1:
-            prev = arg[i - win]
-
-            if prev == prev:
-                skiplist_remove(sl, prev)
-                nobs -= 1
-
-        if val == val:
-            nobs += 1
-            skiplist_insert(sl, val)
-
-        if nobs >= minp:
-            midpoint = nobs / 2
-            if nobs % 2:
-                res = skiplist_get(sl, midpoint, &ret)
-            else:
-                res = (skiplist_get(sl, midpoint, &ret) +
-                       skiplist_get(sl, (midpoint - 1), &ret)) / 2
-        else:
-            res = NaN
-
-        output[i] = res
-
-    skiplist_destroy(sl)
-
-    return output
diff --git a/pandas/stats/moments.py b/pandas/stats/moments.py
index 5b57f3b0e..93b99474e 100644
--- a/pandas/stats/moments.py
+++ b/pandas/stats/moments.py
@@ -391,7 +391,7 @@ rolling_max = _rolling_func(_tseries.roll_max, 'Moving maximum')
 rolling_min = _rolling_func(_tseries.roll_min, 'Moving minimum')
 rolling_sum = _rolling_func(_tseries.roll_sum, 'Moving sum')
 rolling_mean = _rolling_func(_tseries.roll_mean, 'Moving mean')
-rolling_median = _rolling_func(_tseries.roll_median, 'Moving median')
+rolling_median = _rolling_func(_tseries.roll_median_cython, 'Moving median')
 
 _ts_std = lambda *a, **kw: np.sqrt(_tseries.roll_var(*a, **kw))
 rolling_std = _rolling_func(_ts_std, 'Unbiased moving standard deviation',
diff --git a/setup.py b/setup.py
index 710e149f3..72b059d40 100755
--- a/setup.py
+++ b/setup.py
@@ -138,8 +138,8 @@ CLASSIFIERS = [
 ]
 
 MAJOR = 0
-MINOR = 6
-MICRO = 2
+MINOR = 7
+MICRO = 0
 ISRELEASED = False
 VERSION = '%d.%d.%d' % (MAJOR, MINOR, MICRO)
 QUALIFIER = ''
diff --git a/vb_suite/binary_ops.py b/vb_suite/binary_ops.py
index 2aff7672e..585100cf4 100644
--- a/vb_suite/binary_ops.py
+++ b/vb_suite/binary_ops.py
@@ -23,4 +23,4 @@ ts2 = Series(np.random.randn(sz), idx2)
 stmt = "ts1 + ts2"
 bm_align1 = Benchmark(stmt, setup,
                       name="series_align_int64_index",
-                      start_date=datetime(2010, 6, 1))
+                      start_date=datetime(2010, 6, 1), logy=True)
diff --git a/vb_suite/panel_ctor.py b/vb_suite/panel_ctor.py
index f37471382..1a468847c 100644
--- a/vb_suite/panel_ctor.py
+++ b/vb_suite/panel_ctor.py
@@ -22,7 +22,7 @@ for x in xrange(1000):
 panel_from_dict_same_index = \
     Benchmark("Panel.from_dict(data_frames)",
               setup_same_index, name='panel_from_dict_same_index',
-              start_date=START_DATE, repeat=1)
+              start_date=START_DATE, repeat=1, logy=True)
 
 setup_equiv_indexes = common_setup + """
 data_frames = {}
@@ -36,7 +36,7 @@ for x in xrange(1000):
 panel_from_dict_equiv_indexes = \
     Benchmark("Panel.from_dict(data_frames)",
               setup_equiv_indexes, name='panel_from_dict_equiv_indexes',
-              start_date=START_DATE, repeat=1)
+              start_date=START_DATE, repeat=1, logy=True)
 
 setup_all_different_indexes = common_setup + """
 data_frames = {}
@@ -53,7 +53,7 @@ panel_from_dict_all_different_indexes = \
     Benchmark("Panel.from_dict(data_frames)",
               setup_all_different_indexes,
               name='panel_from_dict_all_different_indexes',
-              start_date=START_DATE, repeat=1)
+              start_date=START_DATE, repeat=1, logy=True)
 
 setup_two_different_indexes = common_setup + """
 data_frames = {}
@@ -71,4 +71,4 @@ panel_from_dict_two_different_indexes = \
     Benchmark("Panel.from_dict(data_frames)",
               setup_two_different_indexes,
               name='panel_from_dict_two_different_indexes',
-              start_date=START_DATE, repeat=1)
+              start_date=START_DATE, repeat=1, logy=True)

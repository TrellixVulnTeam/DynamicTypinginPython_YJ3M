commit 428c177695894af8a706d3eff3d9969bf0c7bdef
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Apr 23 13:14:49 2012 -0400

    ENH: implement first/last subset functions, more tests probably needed. close #865

diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 7c8eabb1f..7705cbd9b 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -4,8 +4,6 @@ import numpy as np
 
 from pandas.core.common import save, load
 from pandas.core.index import MultiIndex
-import pandas.core.datetools as datetools
-
 from pandas.tseries.index import DatetimeIndex
 
 #-------------------------------------------------------------------------------
@@ -175,6 +173,70 @@ class PandasObject(Picklable):
 
         return result
 
+    def first(self, offset):
+        """
+        Convenience method for subsetting initial periods of time series data
+        based on a date offset
+
+        Parameters
+        ----------
+        offset : string, DateOffset, dateutil.relativedelta
+
+        Examples
+        --------
+        ts.last('10D') -> First 10 days
+
+        Returns
+        -------
+        subset : type of caller
+        """
+        from pandas.tseries.frequencies import to_offset
+        if not isinstance(self.index, DatetimeIndex):
+            raise NotImplementedError
+
+        if len(self.index) == 0:
+            return self
+
+        offset = to_offset(offset)
+        end_date = end = self.index[0] + offset
+
+        # Tick-like, e.g. 3 weeks
+        if not offset.isAnchored() and hasattr(offset, 'delta'):
+            if end_date in self.index:
+                end = self.index.searchsorted(end_date, side='left')
+
+        return self.ix[:end]
+
+    def last(self, offset):
+        """
+        Convenience method for subsetting final periods of time series data
+        based on a date offset
+
+        Parameters
+        ----------
+        offset : string, DateOffset, dateutil.relativedelta
+
+        Examples
+        --------
+        ts.last('5M') -> Last 5 months
+
+        Returns
+        -------
+        subset : type of caller
+        """
+        from pandas.tseries.frequencies import to_offset
+        if not isinstance(self.index, DatetimeIndex):
+            raise NotImplementedError
+
+        if len(self.index) == 0:
+            return self
+
+        offset = to_offset(offset)
+
+        start_date = start = self.index[-1] - offset
+        start = self.index.searchsorted(start_date, side='right')
+        return self.ix[start:]
+
     def select(self, crit, axis=0):
         """
         Return data corresponding to axis labels matching criteria
@@ -735,8 +797,9 @@ def truncate(self, before=None, after=None, copy=True):
     -------
     truncated : type of caller
     """
-    before = datetools.to_datetime(before)
-    after = datetools.to_datetime(after)
+    from pandas.tseries.tools import to_datetime
+    before = to_datetime(before)
+    after = to_datetime(after)
 
     if before is not None and after is not None:
         assert(before <= after)
diff --git a/pandas/tseries/frequencies.py b/pandas/tseries/frequencies.py
index 3c4320cd5..f2c4b426b 100644
--- a/pandas/tseries/frequencies.py
+++ b/pandas/tseries/frequencies.py
@@ -57,10 +57,10 @@ _unknown_freq = 'Unknown'
 
 
 from pandas.tseries.offsets import (Day, BDay, Hour, Minute, Second, Milli,
-                                    Micro, MonthEnd, MonthBegin, BMonthBegin,
-                                    BMonthEnd, YearBegin, YearEnd, BYearBegin,
-                                    BYearEnd, QuarterBegin, QuarterEnd,
-                                    BQuarterBegin, BQuarterEnd)
+                                    Week, Micro, MonthEnd, MonthBegin,
+                                    BMonthBegin, BMonthEnd, YearBegin, YearEnd,
+                                    BYearBegin, BYearEnd, QuarterBegin,
+                                    QuarterEnd, BQuarterBegin, BQuarterEnd)
 
 _offset_map = {
     'D'     : Day(),
@@ -202,13 +202,15 @@ _offset_map = {
     'BQS-DEC' : BQuarterBegin(startingMonth=12),
 
     # Weekly
-    'W-MON' : offsets.Week(weekday=0),
-    'W-TUE' : offsets.Week(weekday=1),
-    'W-WED' : offsets.Week(weekday=2),
-    'W-THU' : offsets.Week(weekday=3),
-    'W-FRI' : offsets.Week(weekday=4),
-    'W-SAT' : offsets.Week(weekday=5),
-    'W-SUN' : offsets.Week(weekday=6),
+    'W-MON' : Week(weekday=0),
+    'W-TUE' : Week(weekday=1),
+    'W-WED' : Week(weekday=2),
+    'W-THU' : Week(weekday=3),
+    'W-FRI' : Week(weekday=4),
+    'W-SAT' : Week(weekday=5),
+    'W-SUN' : Week(weekday=6),
+
+    'W': Week()
 }
 
 _rule_aliases = {
diff --git a/pandas/tseries/offsets.py b/pandas/tseries/offsets.py
index 0f822a382..bdf3d48d9 100644
--- a/pandas/tseries/offsets.py
+++ b/pandas/tseries/offsets.py
@@ -388,7 +388,7 @@ class Week(DateOffset, CacheableOffset):
                 raise Exception('Day must be 0<=day<=6, got %d' %
                                 self.weekday)
 
-        self.inc = timedelta(weeks=1)
+        self.delta = timedelta(weeks=1)
         self.kwds = kwds
 
     def isAnchored(self):
@@ -396,7 +396,7 @@ class Week(DateOffset, CacheableOffset):
 
     def apply(self, other):
         if self.weekday is None:
-            return other + self.n * self.inc
+            return other + self.n * self.delta
 
         if self.n > 0:
             k = self.n
@@ -405,14 +405,14 @@ class Week(DateOffset, CacheableOffset):
                 other = other + timedelta((self.weekday - otherDay) % 7)
                 k = k - 1
             for i in xrange(k):
-                other = other + self.inc
+                other = other + self.delta
         else:
             k = self.n
             otherDay = other.weekday()
             if otherDay != self.weekday:
                 other = other + timedelta((self.weekday - otherDay) % 7)
             for i in xrange(-k):
-                other = other - self.inc
+                other = other - self.delta
         return other
 
     def onOffset(self, dt):
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index f0b34d51e..cc27bdada 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -419,6 +419,50 @@ class TestTimeSeries(unittest.TestCase):
         rng = date_range('1/1/2000 00:00', '1/1/2000 00:18', freq='5min')
         self.assertEquals(len(rng), 4)
 
+    def test_first_subset(self):
+        ts = _simple_ts('1/1/2000', '1/1/2010', freq='12h')
+        result = ts.first('10d')
+        self.assert_(len(result) == 20)
+
+        ts = _simple_ts('1/1/2000', '1/1/2010')
+        result = ts.first('10d')
+        self.assert_(len(result) == 10)
+
+        result = ts.first('3M')
+        expected = ts[:'3/31/2000']
+        assert_series_equal(result, expected)
+
+        result = ts.first('3W')
+        expected = ts.first('21D')
+        assert_series_equal(result, expected)
+
+        result = ts[:0].first('3M')
+        assert_series_equal(result, ts[:0])
+
+    def test_last_subset(self):
+        ts = _simple_ts('1/1/2000', '1/1/2010', freq='12h')
+        result = ts.last('10d')
+        self.assert_(len(result) == 20)
+
+        ts = _simple_ts('1/1/2000', '1/1/2010')
+        result = ts.last('10d')
+        self.assert_(len(result) == 10)
+
+        result = ts.last('3M')
+        expected = ts['11/1/2009':]
+        assert_series_equal(result, expected)
+
+        result = ts.last('3W')
+        expected = ts.last('21D')
+        assert_series_equal(result, expected)
+
+        result = ts[:0].last('3M')
+        assert_series_equal(result, ts[:0])
+
+def _simple_ts(start, end, freq='D'):
+    rng = date_range(start, end, freq=freq)
+    return Series(np.random.randn(len(rng)), index=rng)
+
 def _skip_if_no_pytz():
     try:
         import pytz

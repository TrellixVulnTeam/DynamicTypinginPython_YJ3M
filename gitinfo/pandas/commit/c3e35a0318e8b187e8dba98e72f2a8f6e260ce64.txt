commit c3e35a0318e8b187e8dba98e72f2a8f6e260ce64
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Fri Feb 23 03:35:00 2018 -0800

    Continue porting period_helper; fix leftover asfreq bug (#19834)

diff --git a/doc/source/whatsnew/v0.23.0.txt b/doc/source/whatsnew/v0.23.0.txt
index 603e4e6ce..ca5749afd 100644
--- a/doc/source/whatsnew/v0.23.0.txt
+++ b/doc/source/whatsnew/v0.23.0.txt
@@ -765,7 +765,7 @@ Timedelta
 - Bug in :class:`TimedeltaIndex` where division by a ``Series`` would return a ``TimedeltaIndex`` instead of a ``Series`` (:issue:`19042`)
 - Bug in :func:`Timedelta.__add__`, :func:`Timedelta.__sub__` where adding or subtracting a ``np.timedelta64`` object would return another ``np.timedelta64`` instead of a ``Timedelta`` (:issue:`19738`)
 - Bug in :func:`Timedelta.__floordiv__`, :func:`Timedelta.__rfloordiv__` where operating with a ``Tick`` object would raise a ``TypeError`` instead of returning a numeric value (:issue:`19738`)
-- Bug in :func:`Period.asfreq` where periods near ``datetime(1, 1, 1)`` could be converted incorrectly (:issue:`19643`)
+- Bug in :func:`Period.asfreq` where periods near ``datetime(1, 1, 1)`` could be converted incorrectly (:issue:`19643`, :issue:`19834`)
 - Bug in :func:`Timedelta.total_seconds()` causing precision errors i.e. ``Timedelta('30S').total_seconds()==30.000000000000004`` (:issue:`19458`)
 - Bug in :func: `Timedelta.__rmod__` where operating with a ``numpy.timedelta64`` returned a ``timedelta64`` object instead of a ``Timedelta`` (:issue:`19820`)
 - Multiplication of :class:`TimedeltaIndex` by ``TimedeltaIndex`` will now raise ``TypeError`` instead of raising ``ValueError`` in cases of length mis-match (:issue`19333`)
diff --git a/pandas/_libs/src/period_helper.c b/pandas/_libs/src/period_helper.c
index a812ed2e7..e3d250aa4 100644
--- a/pandas/_libs/src/period_helper.c
+++ b/pandas/_libs/src/period_helper.c
@@ -42,10 +42,10 @@ static int floordiv(int x, int divisor) {
 static int monthToQuarter(int month) { return ((month - 1) / 3) + 1; }
 
 
-/* Find the absdate (days elapsed since datetime(1, 1, 1)
+/* Find the unix_date (days elapsed since datetime(1970, 1, 1)
  * for the given year/month/day.
  * Assumes GREGORIAN_CALENDAR */
-npy_int64 absdate_from_ymd(int year, int month, int day) {
+npy_int64 unix_date_from_ymd(int year, int month, int day) {
     /* Calculate the absolute date */
     pandas_datetimestruct dts;
     npy_int64 unix_date;
@@ -55,16 +55,16 @@ npy_int64 absdate_from_ymd(int year, int month, int day) {
     dts.month = month;
     dts.day = day;
     unix_date = pandas_datetimestruct_to_datetime(PANDAS_FR_D, &dts);
-    return ORD_OFFSET + unix_date;
+    return unix_date;
 }
 
 /* Sets the date part of the date_info struct
    Assumes GREGORIAN_CALENDAR */
 static int dInfoCalc_SetFromAbsDate(register struct date_info *dinfo,
-                                    npy_int64 absdate) {
+                                    npy_int64 unix_date) {
     pandas_datetimestruct dts;
 
-    pandas_datetime_to_datetimestruct(absdate - ORD_OFFSET, PANDAS_FR_D, &dts);
+    pandas_datetime_to_datetimestruct(unix_date, PANDAS_FR_D, &dts);
     dinfo->year = dts.year;
     dinfo->month = dts.month;
     dinfo->day = dts.day;
@@ -137,26 +137,26 @@ PANDAS_INLINE npy_int64 transform_via_day(npy_int64 ordinal,
     return result;
 }
 
-static npy_int64 DtoB_weekday(npy_int64 absdate) {
-    return floordiv(absdate, 7) * 5 + mod_compat(absdate, 7) - BDAY_OFFSET;
+static npy_int64 DtoB_weekday(npy_int64 unix_date) {
+    return floordiv(unix_date + 4, 7) * 5 + mod_compat(unix_date + 4, 7) - 4;
 }
 
 static npy_int64 DtoB(struct date_info *dinfo,
-                      int roll_back, npy_int64 absdate) {
+                      int roll_back, npy_int64 unix_date) {
     int day_of_week = dayofweek(dinfo->year, dinfo->month, dinfo->day);
 
     if (roll_back == 1) {
         if (day_of_week > 4) {
             // change to friday before weekend
-            absdate -= (day_of_week - 4);
+            unix_date -= (day_of_week - 4);
         }
     } else {
         if (day_of_week > 4) {
             // change to Monday after weekend
-            absdate += (7 - day_of_week);
+            unix_date += (7 - day_of_week);
         }
     }
-    return DtoB_weekday(absdate);
+    return DtoB_weekday(unix_date);
 }
 
 
@@ -165,18 +165,19 @@ static npy_int64 DtoB(struct date_info *dinfo,
 static npy_int64 asfreq_DTtoA(npy_int64 ordinal, asfreq_info *af_info) {
     struct date_info dinfo;
     ordinal = downsample_daytime(ordinal, af_info);
-    dInfoCalc_SetFromAbsDate(&dinfo, ordinal + ORD_OFFSET);
+    dInfoCalc_SetFromAbsDate(&dinfo, ordinal);
     if (dinfo.month > af_info->to_a_year_end) {
-        return (npy_int64)(dinfo.year + 1 - BASE_YEAR);
+        return (npy_int64)(dinfo.year + 1 - 1970);
     } else {
-        return (npy_int64)(dinfo.year - BASE_YEAR);
+        return (npy_int64)(dinfo.year - 1970);
     }
 }
 
-static npy_int64 DtoQ_yq(npy_int64 ordinal, asfreq_info *af_info, int *year,
-                         int *quarter) {
+static int DtoQ_yq(npy_int64 ordinal, asfreq_info *af_info, int *year) {
     struct date_info dinfo;
-    dInfoCalc_SetFromAbsDate(&dinfo, ordinal + ORD_OFFSET);
+    int quarter;
+
+    dInfoCalc_SetFromAbsDate(&dinfo, ordinal);
     if (af_info->to_q_year_end != 12) {
         dinfo.month -= af_info->to_q_year_end;
         if (dinfo.month <= 0) {
@@ -187,9 +188,8 @@ static npy_int64 DtoQ_yq(npy_int64 ordinal, asfreq_info *af_info, int *year,
     }
 
     *year = dinfo.year;
-    *quarter = monthToQuarter(dinfo.month);
-
-    return 0;
+    quarter = monthToQuarter(dinfo.month);
+    return quarter;
 }
 
 static npy_int64 asfreq_DTtoQ(npy_int64 ordinal, asfreq_info *af_info) {
@@ -197,8 +197,8 @@ static npy_int64 asfreq_DTtoQ(npy_int64 ordinal, asfreq_info *af_info) {
 
     ordinal = downsample_daytime(ordinal, af_info);
 
-    DtoQ_yq(ordinal, af_info, &year, &quarter);
-    return (npy_int64)((year - BASE_YEAR) * 4 + quarter - 1);
+    quarter = DtoQ_yq(ordinal, af_info, &year);
+    return (npy_int64)((year - 1970) * 4 + quarter - 1);
 }
 
 static npy_int64 asfreq_DTtoM(npy_int64 ordinal, asfreq_info *af_info) {
@@ -206,28 +206,25 @@ static npy_int64 asfreq_DTtoM(npy_int64 ordinal, asfreq_info *af_info) {
 
     ordinal = downsample_daytime(ordinal, af_info);
 
-    dInfoCalc_SetFromAbsDate(&dinfo, ordinal + ORD_OFFSET);
-    return (npy_int64)((dinfo.year - BASE_YEAR) * 12 + dinfo.month - 1);
+    dInfoCalc_SetFromAbsDate(&dinfo, ordinal);
+    return (npy_int64)((dinfo.year - 1970) * 12 + dinfo.month - 1);
 }
 
 static npy_int64 asfreq_DTtoW(npy_int64 ordinal, asfreq_info *af_info) {
     ordinal = downsample_daytime(ordinal, af_info);
-    return (ordinal + ORD_OFFSET - (1 + af_info->to_week_end)) / 7 + 1 -
-           WEEK_OFFSET;
+    return floordiv(ordinal + 3 - af_info->to_week_end, 7) + 1;
 }
 
 static npy_int64 asfreq_DTtoB(npy_int64 ordinal, asfreq_info *af_info) {
     struct date_info dinfo;
-    npy_int64 absdate;
     int roll_back;
 
     ordinal = downsample_daytime(ordinal, af_info);
-    absdate = ordinal + ORD_OFFSET;
-    dInfoCalc_SetFromAbsDate(&dinfo, absdate);
+    dInfoCalc_SetFromAbsDate(&dinfo, ordinal);
 
     // This usage defines roll_back the opposite way from the others
     roll_back = 1 - af_info->is_end;
-    return DtoB(&dinfo, roll_back, absdate);
+    return DtoB(&dinfo, roll_back, ordinal);
 }
 
 // all intra day calculations are now done within one function
@@ -243,10 +240,7 @@ static npy_int64 asfreq_UpsampleWithinDay(npy_int64 ordinal,
 //************ FROM BUSINESS ***************
 
 static npy_int64 asfreq_BtoDT(npy_int64 ordinal, asfreq_info *af_info) {
-    ordinal += BDAY_OFFSET;
-    ordinal =
-        (floordiv(ordinal - 1, 5) * 7 + mod_compat(ordinal - 1, 5) + 1 -
-         ORD_OFFSET);
+    ordinal = floordiv(ordinal + 3, 5) * 7 + mod_compat(ordinal + 3, 5) - 3;
 
     return upsample_daytime(ordinal, af_info);
 }
@@ -270,8 +264,7 @@ static npy_int64 asfreq_BtoW(npy_int64 ordinal, asfreq_info *af_info) {
 //************ FROM WEEKLY ***************
 
 static npy_int64 asfreq_WtoDT(npy_int64 ordinal, asfreq_info *af_info) {
-    ordinal = (ordinal + WEEK_OFFSET) * 7 +
-               af_info->from_week_end - ORD_OFFSET +
+    ordinal = ordinal * 7 + af_info->from_week_end - 4 +
                (7 - 1) * (af_info->is_end - 1);
     return upsample_daytime(ordinal, af_info);
 }
@@ -294,30 +287,29 @@ static npy_int64 asfreq_WtoW(npy_int64 ordinal, asfreq_info *af_info) {
 
 static npy_int64 asfreq_WtoB(npy_int64 ordinal, asfreq_info *af_info) {
     struct date_info dinfo;
-    npy_int64 absdate = asfreq_WtoDT(ordinal, af_info) + ORD_OFFSET;
+    npy_int64 unix_date = asfreq_WtoDT(ordinal, af_info);
     int roll_back = af_info->is_end;
-    dInfoCalc_SetFromAbsDate(&dinfo, absdate);
+    dInfoCalc_SetFromAbsDate(&dinfo, unix_date);
 
-    return DtoB(&dinfo, roll_back, absdate);
+    return DtoB(&dinfo, roll_back, unix_date);
 }
 
 //************ FROM MONTHLY ***************
 static void MtoD_ym(npy_int64 ordinal, int *y, int *m) {
-    *y = floordiv(ordinal, 12) + BASE_YEAR;
+    *y = floordiv(ordinal, 12) + 1970;
     *m = mod_compat(ordinal, 12) + 1;
 }
 
 static npy_int64 asfreq_MtoDT(npy_int64 ordinal, asfreq_info *af_info) {
-    npy_int64 absdate;
+    npy_int64 unix_date;
     int y, m;
 
     ordinal += af_info->is_end;
     MtoD_ym(ordinal, &y, &m);
-    absdate = absdate_from_ymd(y, m, 1);
-    ordinal = absdate - ORD_OFFSET;
+    unix_date = unix_date_from_ymd(y, m, 1);
 
-    ordinal -= af_info->is_end;
-    return upsample_daytime(ordinal, af_info);
+    unix_date -= af_info->is_end;
+    return upsample_daytime(unix_date, af_info);
 }
 
 static npy_int64 asfreq_MtoA(npy_int64 ordinal, asfreq_info *af_info) {
@@ -334,18 +326,18 @@ static npy_int64 asfreq_MtoW(npy_int64 ordinal, asfreq_info *af_info) {
 
 static npy_int64 asfreq_MtoB(npy_int64 ordinal, asfreq_info *af_info) {
     struct date_info dinfo;
-    npy_int64 absdate = asfreq_MtoDT(ordinal, af_info) + ORD_OFFSET;
+    npy_int64 unix_date = asfreq_MtoDT(ordinal, af_info);
     int roll_back = af_info->is_end;
 
-    dInfoCalc_SetFromAbsDate(&dinfo, absdate);
+    dInfoCalc_SetFromAbsDate(&dinfo, unix_date);
 
-    return DtoB(&dinfo, roll_back, absdate);
+    return DtoB(&dinfo, roll_back, unix_date);
 }
 
 //************ FROM QUARTERLY ***************
 
 static void QtoD_ym(npy_int64 ordinal, int *y, int *m, asfreq_info *af_info) {
-    *y = floordiv(ordinal, 4) + BASE_YEAR;
+    *y = floordiv(ordinal, 4) + 1970;
     *m = mod_compat(ordinal, 4) * 3 + 1;
 
     if (af_info->from_q_year_end != 12) {
@@ -359,16 +351,16 @@ static void QtoD_ym(npy_int64 ordinal, int *y, int *m, asfreq_info *af_info) {
 }
 
 static npy_int64 asfreq_QtoDT(npy_int64 ordinal, asfreq_info *af_info) {
-    npy_int64 absdate;
+    npy_int64 unix_date;
     int y, m;
 
     ordinal += af_info->is_end;
     QtoD_ym(ordinal, &y, &m, af_info);
 
-    absdate = absdate_from_ymd(y, m, 1);
+    unix_date = unix_date_from_ymd(y, m, 1);
 
-    absdate -= af_info->is_end;
-    return upsample_daytime(absdate - ORD_OFFSET, af_info);
+    unix_date -= af_info->is_end;
+    return upsample_daytime(unix_date, af_info);
 }
 
 static npy_int64 asfreq_QtoQ(npy_int64 ordinal, asfreq_info *af_info) {
@@ -389,21 +381,21 @@ static npy_int64 asfreq_QtoW(npy_int64 ordinal, asfreq_info *af_info) {
 
 static npy_int64 asfreq_QtoB(npy_int64 ordinal, asfreq_info *af_info) {
     struct date_info dinfo;
-    npy_int64 absdate = asfreq_QtoDT(ordinal, af_info) + ORD_OFFSET;
+    npy_int64 unix_date = asfreq_QtoDT(ordinal, af_info);
     int roll_back = af_info->is_end;
 
-    dInfoCalc_SetFromAbsDate(&dinfo, absdate);
+    dInfoCalc_SetFromAbsDate(&dinfo, unix_date);
 
-    return DtoB(&dinfo, roll_back, absdate);
+    return DtoB(&dinfo, roll_back, unix_date);
 }
 
 //************ FROM ANNUAL ***************
 
 static npy_int64 asfreq_AtoDT(npy_int64 ordinal, asfreq_info *af_info) {
-    npy_int64 absdate;
+    npy_int64 unix_date;
 
     // start from 1970
-    npy_int64 year = ordinal + BASE_YEAR;
+    npy_int64 year = ordinal + 1970;
 
     int month = (af_info->from_a_year_end % 12) + 1;
     if (af_info->from_a_year_end != 12) {
@@ -411,10 +403,10 @@ static npy_int64 asfreq_AtoDT(npy_int64 ordinal, asfreq_info *af_info) {
     }
 
     year += af_info->is_end;
-    absdate = absdate_from_ymd(year, month, 1);
+    unix_date = unix_date_from_ymd(year, month, 1);
 
-    absdate -= af_info->is_end;
-    return upsample_daytime(absdate - ORD_OFFSET, af_info);
+    unix_date -= af_info->is_end;
+    return upsample_daytime(unix_date, af_info);
 }
 
 static npy_int64 asfreq_AtoA(npy_int64 ordinal, asfreq_info *af_info) {
@@ -435,11 +427,11 @@ static npy_int64 asfreq_AtoW(npy_int64 ordinal, asfreq_info *af_info) {
 
 static npy_int64 asfreq_AtoB(npy_int64 ordinal, asfreq_info *af_info) {
     struct date_info dinfo;
-    npy_int64 absdate = asfreq_AtoDT(ordinal, af_info) + ORD_OFFSET;
+    npy_int64 unix_date = asfreq_AtoDT(ordinal, af_info);
     int roll_back = af_info->is_end;
-    dInfoCalc_SetFromAbsDate(&dinfo, absdate);
+    dInfoCalc_SetFromAbsDate(&dinfo, unix_date);
 
-    return DtoB(&dinfo, roll_back, absdate);
+    return DtoB(&dinfo, roll_back, unix_date);
 }
 
 static npy_int64 nofunc(npy_int64 ordinal, asfreq_info *af_info) {
diff --git a/pandas/_libs/src/period_helper.h b/pandas/_libs/src/period_helper.h
index 1573b1eee..7163dc960 100644
--- a/pandas/_libs/src/period_helper.h
+++ b/pandas/_libs/src/period_helper.h
@@ -20,32 +20,8 @@ frequency conversion routines.
 #include "limits.h"
 #include "numpy/ndarraytypes.h"
 
-/*
- * declarations from period here
- */
-
-#define Py_Error(errortype, errorstr)         \
-    {                                         \
-        PyErr_SetString(errortype, errorstr); \
-        goto onError;                         \
-    }
-
 /*** FREQUENCY CONSTANTS ***/
 
-// HIGHFREQ_ORIG is the datetime ordinal from which to begin the second
-// frequency ordinal sequence
-
-// #define HIGHFREQ_ORIG 62135683200LL
-#define BASE_YEAR 1970
-#define ORD_OFFSET 719163LL   // days until 1970-01-01
-#define BDAY_OFFSET 513689LL  // days until 1970-01-01
-#define WEEK_OFFSET 102737LL
-#define BASE_WEEK_TO_DAY_OFFSET \
-    1  // difference between day 0 and end of week in days
-#define DAYS_PER_WEEK 7
-#define BUSINESS_DAYS_PER_WEEK 5
-#define HIGHFREQ_ORIG 0  // ORD_OFFSET * 86400LL // days until 1970-01-01
-
 #define FR_ANN 1000      /* Annual */
 #define FR_ANNDEC FR_ANN /* Annual - December year end*/
 #define FR_ANNJAN 1001   /* Annual - January year end*/
diff --git a/pandas/_libs/tslibs/period.pyx b/pandas/_libs/tslibs/period.pyx
index e1c783ac9..f1a193706 100644
--- a/pandas/_libs/tslibs/period.pyx
+++ b/pandas/_libs/tslibs/period.pyx
@@ -75,10 +75,6 @@ cdef extern from "period_helper.h":
     int FR_BUS
     int FR_UND
 
-    int ORD_OFFSET
-    int WEEK_OFFSET
-    int BDAY_OFFSET
-
     ctypedef struct date_info:
         double second
         int minute
@@ -181,7 +177,7 @@ cdef int64_t get_period_ordinal(int year, int month, int day,
     period_ordinal : int64_t
     """
     cdef:
-        int64_t absdays, unix_date, seconds, delta
+        int64_t unix_date, seconds, delta
         int64_t weeks
         int64_t day_adj
         int freq_group, fmonth, mdiff
@@ -215,8 +211,7 @@ cdef int64_t get_period_ordinal(int year, int month, int day,
     elif freq == FR_MTH:
         return (year - 1970) * 12 + month - 1
 
-    absdays = absdate_from_ymd(year, month, day)
-    unix_date = absdays - ORD_OFFSET
+    unix_date = unix_date_from_ymd(year, month, day)
 
     if freq >= FR_SEC:
         seconds = unix_date * 86400 + hour * 3600 + minute * 60 + second
@@ -247,48 +242,48 @@ cdef int64_t get_period_ordinal(int year, int month, int day,
         return unix_date
 
     elif freq == FR_BUS:
-        # calculate the current week assuming sunday as last day of a week
-        # Jan 1 0001 is a Monday, so subtract 1 to get to end-of-week
-        weeks = (unix_date + ORD_OFFSET - 1) // 7
+        # calculate the current week (counting from 1970-01-01) treating
+        # sunday as last day of a week
+        weeks = (unix_date + 3) // 7
         # calculate the current weekday (in range 1 .. 7)
-        delta = (unix_date + ORD_OFFSET - 1) % 7 + 1
+        delta = (unix_date + 3) % 7 + 1
         # return the number of business days in full weeks plus the business
         # days in the last - possible partial - week
         if delta <= 5:
-            return (weeks * 5) + delta - BDAY_OFFSET
+            return (5 * weeks) + delta - 4
         else:
-            return (weeks * 5) + (5 + 1) - BDAY_OFFSET
+            return (5 * weeks) + (5 + 1) - 4
 
     elif freq_group == FR_WK:
         day_adj = freq - FR_WK
-        return (unix_date + ORD_OFFSET - (1 + day_adj)) // 7 + 1 - WEEK_OFFSET
+        return (unix_date + 3 - day_adj) // 7 + 1
 
     # raise ValueError
 
 
 cdef void get_date_info(int64_t ordinal, int freq, date_info *dinfo) nogil:
     cdef:
-        int64_t absdate
+        int64_t unix_date
         double abstime
 
-    absdate = get_python_ordinal(ordinal, freq);
-    abstime = get_abs_time(freq, absdate - ORD_OFFSET, ordinal)
+    unix_date = get_unix_date(ordinal, freq)
+    abstime = get_abs_time(freq, unix_date, ordinal)
 
     while abstime < 0:
         abstime += 86400
-        absdate -= 1
+        unix_date -= 1
 
     while abstime >= 86400:
         abstime -= 86400
-        absdate += 1
+        unix_date += 1
 
-    dInfoCalc_SetFromAbsDateTime(dinfo, absdate, abstime)
+    date_info_from_days_and_time(dinfo, unix_date, abstime)
 
 
-cdef int64_t get_python_ordinal(int64_t period_ordinal, int freq) nogil:
+cdef int64_t get_unix_date(int64_t period_ordinal, int freq) nogil:
     """
     Returns the proleptic Gregorian ordinal of the date, as an integer.
-    This corresponds to the number of days since Jan., 1st, 1AD.
+    This corresponds to the number of days since Jan., 1st, 1970 AD.
     When the instance has a frequency less than daily, the proleptic date
     is calculated for the last day of the period.
 
@@ -299,92 +294,56 @@ cdef int64_t get_python_ordinal(int64_t period_ordinal, int freq) nogil:
 
     Returns
     -------
-    absdate : int64_t number of days since datetime(1, 1, 1)
+    unix_date : int64_t number of days since datetime(1970, 1, 1)
     """
     cdef:
         asfreq_info af_info
         freq_conv_func toDaily = NULL
 
     if freq == FR_DAY:
-        return period_ordinal + ORD_OFFSET
+        return period_ordinal
 
     toDaily = get_asfreq_func(freq, FR_DAY)
     get_asfreq_info(freq, FR_DAY, 'E', &af_info)
-    return toDaily(period_ordinal, &af_info) + ORD_OFFSET
+    return toDaily(period_ordinal, &af_info)
 
 
-cdef void dInfoCalc_SetFromAbsDateTime(date_info *dinfo,
-                                       int64_t absdate, double abstime) nogil:
+@cython.cdivision
+cdef void date_info_from_days_and_time(date_info *dinfo,
+                                       int64_t unix_date,
+                                       double abstime) nogil:
     """
     Set the instance's value using the given date and time.
-    Assumes GREGORIAN_CALENDAR.
 
     Parameters
     ----------
     dinfo : date_info*
-    absdate : int64_t
-        days elapsed since datetime(1, 1, 1)
+    unix_date : int64_t
+        days elapsed since datetime(1970, 1, 1)
     abstime : double
-        seconds elapsed since beginning of day described by absdate
+        seconds elapsed since beginning of day described by unix_date
 
     Notes
     -----
     Updates dinfo inplace
     """
+    cdef:
+        pandas_datetimestruct dts
+        int inttime
+        int hour, minute
+        double second
+
     # Bounds check
     # The calling function is responsible for ensuring that
     # abstime >= 0.0 and abstime <= 86400
 
     # Calculate the date
-    dInfoCalc_SetFromAbsDate(dinfo, absdate)
-
-    # Calculate the time
-    dInfoCalc_SetFromAbsTime(dinfo, abstime)
-
-
-cdef void dInfoCalc_SetFromAbsDate(date_info *dinfo, int64_t absdate) nogil:
-    """
-    Sets the date part of the date_info struct
-    Assumes GREGORIAN_CALENDAR
-
-    Parameters
-    ----------
-    dinfo : date_info*
-    unix_date : int64_t
-
-    Notes
-    -----
-    Updates dinfo inplace
-    """
-    cdef:
-        pandas_datetimestruct dts
-
-    pandas_datetime_to_datetimestruct(absdate - ORD_OFFSET, PANDAS_FR_D, &dts)
+    pandas_datetime_to_datetimestruct(unix_date, PANDAS_FR_D, &dts)
     dinfo.year = dts.year
     dinfo.month = dts.month
     dinfo.day = dts.day
 
-
-@cython.cdivision
-cdef void dInfoCalc_SetFromAbsTime(date_info *dinfo, double abstime) nogil:
-    """
-    Sets the time part of the DateTime object.
-
-    Parameters
-    ----------
-    dinfo : date_info*
-    abstime : double
-        seconds elapsed since beginning of day described by absdate
-
-    Notes
-    -----
-    Updates dinfo inplace
-    """
-    cdef:
-        int inttime
-        int hour, minute
-        double second
-
+    # Calculate the time
     inttime = <int>abstime
     hour = inttime / 3600
     minute = (inttime % 3600) / 60
@@ -396,8 +355,7 @@ cdef void dInfoCalc_SetFromAbsTime(date_info *dinfo, double abstime) nogil:
 
 
 @cython.cdivision
-cdef double get_abs_time(int freq, int64_t date_ordinal,
-                         int64_t ordinal) nogil:
+cdef double get_abs_time(int freq, int64_t unix_date, int64_t ordinal) nogil:
     cdef:
         int freq_index, day_index, base_index
         int64_t per_day, start_ord
@@ -416,16 +374,15 @@ cdef double get_abs_time(int freq, int64_t date_ordinal,
     if base_index < freq_index:
         unit = 1 / unit
 
-    start_ord = date_ordinal * per_day
+    start_ord = unix_date * per_day
     result = <double>(unit * (ordinal - start_ord))
     return result
 
 
-cdef int64_t absdate_from_ymd(int year, int month, int day) nogil:
+cdef int64_t unix_date_from_ymd(int year, int month, int day) nogil:
     """
-    Find the absdate (days elapsed since datetime(1, 1, 1)
+    Find the unix_date (days elapsed since datetime(1970, 1, 1)
     for the given year/month/day.
-    Assumes GREGORIAN_CALENDAR
 
     Parameters
     ----------
@@ -435,11 +392,9 @@ cdef int64_t absdate_from_ymd(int year, int month, int day) nogil:
 
     Returns
     -------
-    absdate : int
-        days elapsed since datetime(1, 1, 1)
+    unix_date : int
+        days elapsed since datetime(1970, 1, 1)
     """
-
-    # /* Calculate the absolute date
     cdef:
         pandas_datetimestruct dts
         int64_t unix_date
@@ -449,7 +404,7 @@ cdef int64_t absdate_from_ymd(int year, int month, int day) nogil:
     dts.month = month
     dts.day = day
     unix_date = pandas_datetimestruct_to_datetime(PANDAS_FR_D, &dts)
-    return ORD_OFFSET + unix_date
+    return unix_date
 
 
 cdef int get_yq(int64_t ordinal, int freq, int *quarter, int *year):
@@ -475,9 +430,9 @@ cdef int get_yq(int64_t ordinal, int freq, int *quarter, int *year):
     cdef:
         asfreq_info af_info
         int qtr_freq
-        int64_t daily_ord
+        int64_t unix_date
 
-    daily_ord = get_python_ordinal(ordinal, freq) - ORD_OFFSET
+    unix_date = get_unix_date(ordinal, freq)
 
     if get_freq_group(freq) == FR_QTR:
         qtr_freq = freq
@@ -486,16 +441,16 @@ cdef int get_yq(int64_t ordinal, int freq, int *quarter, int *year):
 
     get_asfreq_info(FR_DAY, qtr_freq, 'E', &af_info)
 
-    DtoQ_yq(daily_ord, &af_info, year, quarter)
+    quarter[0] = DtoQ_yq(unix_date, &af_info, year)
     return qtr_freq
 
 
-cdef void DtoQ_yq(int64_t ordinal, asfreq_info *af_info,
-                  int *year, int *quarter):
+cdef int DtoQ_yq(int64_t unix_date, asfreq_info *af_info, int *year):
     cdef:
         date_info dinfo
+        int quarter
 
-    dInfoCalc_SetFromAbsDate(&dinfo, ordinal + ORD_OFFSET)
+    date_info_from_days_and_time(&dinfo, unix_date, 0)
 
     if af_info.to_q_year_end != 12:
         dinfo.month -= af_info.to_q_year_end
@@ -505,10 +460,11 @@ cdef void DtoQ_yq(int64_t ordinal, asfreq_info *af_info,
             dinfo.year += 1
 
     year[0] = dinfo.year
-    quarter[0] = monthToQuarter(dinfo.month)
+    quarter = month_to_quarter(dinfo.month)
+    return quarter
 
 
-cdef inline int monthToQuarter(int month):
+cdef inline int month_to_quarter(int month):
     return (month - 1) // 3 + 1
 
 
@@ -678,7 +634,7 @@ def period_format(int64_t value, int freq, object fmt=None):
         return repr(NaT)
 
     if fmt is None:
-        freq_group = (freq // 1000) * 1000
+        freq_group = get_freq_group(freq)
         if freq_group == 1000:    # FR_ANN
             fmt = b'%Y'
         elif freq_group == 2000:  # FR_QTR
@@ -1620,8 +1576,8 @@ class Period(_Period):
         return cls._from_ordinal(ordinal, freq)
 
 
-def _ordinal_from_fields(year, month, quarter, day,
-                         hour, minute, second, freq):
+cdef int64_t _ordinal_from_fields(year, month, quarter, day,
+                                  hour, minute, second, freq):
     base, mult = get_freq_code(freq)
     if quarter is not None:
         year, month = _quarter_to_myear(year, quarter, freq)
diff --git a/pandas/tests/scalar/period/test_period.py b/pandas/tests/scalar/period/test_period.py
index dff5433ad..f43ab0704 100644
--- a/pandas/tests/scalar/period/test_period.py
+++ b/pandas/tests/scalar/period/test_period.py
@@ -1440,3 +1440,10 @@ def test_period_immutable():
     freq = per.freq
     with pytest.raises(AttributeError):
         per.freq = 2 * freq
+
+
+@pytest.mark.xfail(reason='GH#19834 Period parsing error')
+def test_small_year_parsing():
+    per1 = Period('0001-01-07', 'D')
+    assert per1.year == 1
+    assert per1.day == 7
diff --git a/pandas/tests/scalar/period/test_period_asfreq.py b/pandas/tests/scalar/period/test_period_asfreq.py
index 9f8b2562e..474d19809 100644
--- a/pandas/tests/scalar/period/test_period_asfreq.py
+++ b/pandas/tests/scalar/period/test_period_asfreq.py
@@ -21,6 +21,16 @@ class TestFreqConversion(object):
         tup2 = (prev.year, prev.month, prev.day)
         assert tup2 < tup1
 
+    def test_asfreq_near_zero_weekly(self):
+        # GH#19834
+        per1 = Period('0001-01-01', 'D') + 6
+        per2 = Period('0001-01-01', 'D') - 6
+        week1 = per1.asfreq('W')
+        week2 = per2.asfreq('W')
+        assert week1 != week2
+        assert week1.asfreq('D', 'E') >= per1
+        assert week2.asfreq('D', 'S') <= per2
+
     @pytest.mark.xfail(reason='GH#19643 period_helper asfreq functions fail '
                               'to check for overflows')
     def test_to_timestamp_out_of_bounds(self):

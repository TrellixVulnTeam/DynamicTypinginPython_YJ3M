commit 5602b98a913269a4aca3a51ca06d9ede04fc9d96
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Feb 6 11:00:14 2012 -0500

    ENH: refactor formatting stuff. also close #755

diff --git a/pandas/__init__.py b/pandas/__init__.py
index 0a1daaa99..f0d602360 100644
--- a/pandas/__init__.py
+++ b/pandas/__init__.py
@@ -23,8 +23,8 @@ from pandas.core.api import *
 from pandas.sparse.api import *
 from pandas.stats.api import *
 
-from pandas.core.common import set_printoptions, reset_printoptions
-from pandas.core.common import set_eng_float_format
+from pandas.core.format import (set_printoptions, reset_printoptions,
+                                set_eng_float_format)
 from pandas.io.parsers import read_csv, read_table, read_clipboard, ExcelFile
 from pandas.io.pytables import HDFStore
 from pandas.util.testing import debug
diff --git a/pandas/core/api.py b/pandas/core/api.py
index 1201bde94..efff23035 100644
--- a/pandas/core/api.py
+++ b/pandas/core/api.py
@@ -5,7 +5,8 @@ import numpy as np
 from pandas.core.datetools import DateOffset
 import pandas.core.datetools as datetools
 
-from pandas.core.common import isnull, notnull, set_printoptions, save, load
+from pandas.core.common import isnull, notnull, save, load
+from pandas.core.format import set_printoptions
 from pandas.core.index import Index, Int64Index, Factor, MultiIndex
 from pandas.core.daterange import DateRange
 from pandas.core.series import Series, TimeSeries
diff --git a/pandas/core/common.py b/pandas/core/common.py
index 8bd91cc0a..e5aed4ef0 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -16,9 +16,6 @@ import itertools
 from numpy.lib.format import read_array, write_array
 import numpy as np
 
-import decimal
-import math
-
 import pandas._tseries as lib
 from pandas.util import py3compat
 import codecs
@@ -370,260 +367,6 @@ def _try_sort(iterable):
     except Exception:
         return listed
 
-#-------------------------------------------------------------------------------
-# Global formatting options
-
-def set_printoptions(precision=None, column_space=None, max_rows=None,
-                     max_columns=None, colheader_justify='right'):
-    """
-    Alter default behavior of DataFrame.toString
-
-    precision : int
-        Floating point output precision (number of significant digits)
-    column_space : int
-        Default space for DataFrame columns, defaults to 12
-    max_rows : int
-    max_columns : int
-        max_rows and max_columns are used in __repr__() methods to decide if
-        to_string() or info() is used to render an object to a string.
-        Either one, or both can be set to 0 (experimental). Pandas will figure
-        out how big the terminal is and will not display more rows or/and
-        columns that can fit on it.
-    """
-    if precision is not None:
-        print_config.precision = precision
-    if column_space is not None:
-        print_config.column_space = column_space
-    if max_rows is not None:
-        print_config.max_rows = max_rows
-    if max_columns is not None:
-        print_config.max_columns = max_columns
-    if colheader_justify is not None:
-        print_config.colheader_justify = colheader_justify
-
-def reset_printoptions():
-    print_config.reset()
-
-class EngFormatter(object):
-    """
-    Formats float values according to engineering format.
-
-    Based on matplotlib.ticker.EngFormatter
-    """
-
-    # The SI engineering prefixes
-    ENG_PREFIXES = {
-        -24: "y",
-        -21: "z",
-        -18: "a",
-        -15: "f",
-        -12: "p",
-         -9: "n",
-         -6: "u",
-         -3: "m",
-          0: "",
-          3: "k",
-          6: "M",
-          9: "G",
-         12: "T",
-         15: "P",
-         18: "E",
-         21: "Z",
-         24: "Y"
-      }
-
-    def __init__(self, accuracy=None, use_eng_prefix=False):
-        self.accuracy = accuracy
-        self.use_eng_prefix = use_eng_prefix
-
-    def __call__(self, num):
-        """ Formats a number in engineering notation, appending a letter
-        representing the power of 1000 of the original number. Some examples:
-
-        >>> format_eng(0)       # for self.accuracy = 0
-        ' 0'
-
-        >>> format_eng(1000000) # for self.accuracy = 1,
-                                #     self.use_eng_prefix = True
-        ' 1.0M'
-
-        >>> format_eng("-1e-6") # for self.accuracy = 2
-                                #     self.use_eng_prefix = False
-        '-1.00E-06'
-
-        @param num: the value to represent
-        @type num: either a numeric value or a string that can be converted to
-                   a numeric value (as per decimal.Decimal constructor)
-
-        @return: engineering formatted string
-        """
-
-        dnum = decimal.Decimal(str(num))
-
-        sign = 1
-
-        if dnum < 0:  # pragma: no cover
-            sign = -1
-            dnum = -dnum
-
-        if dnum != 0:
-            pow10 = decimal.Decimal(int(math.floor(dnum.log10()/3)*3))
-        else:
-            pow10 = decimal.Decimal(0)
-
-        pow10 = pow10.min(max(self.ENG_PREFIXES.keys()))
-        pow10 = pow10.max(min(self.ENG_PREFIXES.keys()))
-        int_pow10 = int(pow10)
-
-        if self.use_eng_prefix:
-            prefix = self.ENG_PREFIXES[int_pow10]
-        else:
-            if int_pow10 < 0:
-                prefix = 'E-%02d' % (-int_pow10)
-            else:
-                prefix = 'E+%02d' % int_pow10
-
-        mant = sign*dnum/(10**pow10)
-
-        if self.accuracy is None:  # pragma: no cover
-            format_str = u"% g%s"
-        else:
-            format_str = (u"%% .%if%%s" % self.accuracy )
-
-        formatted = format_str % (mant, prefix)
-
-        return formatted #.strip()
-
-def set_eng_float_format(precision=None, accuracy=3, use_eng_prefix=False):
-    """
-    Alter default behavior on how float is formatted in DataFrame.
-    Format float in engineering format. By accuracy, we mean the number of
-    decimal digits after the floating point.
-
-    See also EngFormatter.
-    """
-    if precision is not None: # pragma: no cover
-        import warnings
-        warnings.warn("'precision' parameter in set_eng_float_format is "
-                      "being renamed to 'accuracy'" , FutureWarning)
-        accuracy = precision
-
-    print_config.float_format = EngFormatter(accuracy, use_eng_prefix)
-    print_config.column_space = max(12, accuracy + 9)
-
-def _stringify(col):
-    # unicode workaround
-    return unicode(col)
-    #if isinstance(col, tuple):
-    #    return str(col)
-    #else:
-    #    return '%s' % console_encode(col)
-
-def _float_format_default(v, width=None):
-    """
-    Take a float and its formatted representation and if it needs extra space
-    to fit the width, reformat it to that width.
-    """
-
-    fmt_str   = '%% .%dg' % print_config.precision
-    formatted = fmt_str % v
-
-    if width is None:
-        return formatted
-
-    extra_spc = width - len(formatted)
-
-    if extra_spc <= 0:
-        return formatted
-
-    if 'e' in formatted:
-        # we have something like 1e13 or 1.23e13
-        base, exp = formatted.split('e')
-
-        if '.' in base:
-            # expand fraction by extra space
-            whole, frac = base.split('.')
-            fmt_str = '%%.%df' % (len(frac) + extra_spc)
-            frac = fmt_str % float("0.%s" % frac)
-            base = whole + frac[1:]
-        else:
-            if extra_spc > 1:
-                # enough room for fraction
-                fmt_str = '%% .%df' % (extra_spc - 1)
-                base = fmt_str % float(base)
-            else:
-                # enough room for decimal point only
-                base += '.'
-
-        return base + 'e' + exp
-    else:
-        # we have something like 123 or 123.456
-        if '.' in formatted:
-            # expand fraction by extra space
-            wholel, fracl = map(len, formatted.split("."))
-            fmt_str = '%% .%df' % (fracl + extra_spc)
-        else:
-            if extra_spc > 1:
-                # enough room for fraction
-                fmt_str = '%% .%df' % (extra_spc - 1)
-            else:
-                # enough room for decimal point only
-                fmt_str = '% d.'
-
-        return fmt_str % v
-
-def _format(s, dtype, space=None, na_rep=None, float_format=None,
-            col_width=None):
-    def _just_help(x):
-        if space is None:
-            return x
-        return x[:space].ljust(space)
-
-    def _make_float_format(x):
-        if na_rep is not None and isnull(x):
-            if np.isnan(x):
-                x = ' ' + na_rep
-            return _just_help('%s' % x)
-
-        if float_format:
-            formatted = float_format(x)
-        elif print_config.float_format:
-            formatted = print_config.float_format(x)
-        else:
-            formatted = _float_format_default(x, col_width)
-
-        return _just_help(formatted)
-
-    def _make_int_format(x):
-        return _just_help('% d' % x)
-
-    if is_float_dtype(dtype):
-        return _make_float_format(s)
-    elif is_integer_dtype(dtype):
-        return _make_int_format(s)
-    else:
-        if na_rep is not None and lib.checknull(s):
-            if s is None:
-                return 'None'
-            return na_rep
-        else:
-            # object dtype
-            return _just_help('%s' % _stringify(s))
-
-class _GlobalPrintConfig(object):
-    def __init__(self):
-        self.precision = 4
-        self.float_format = None
-        self.column_space = 12
-        self.max_rows = 200
-        self.max_columns = 0
-        self.colheader_justify = 'right'
-
-    def reset(self):
-        self.__init__()
-
-print_config = _GlobalPrintConfig()
-
 #------------------------------------------------------------------------------
 # miscellaneous python tools
 
@@ -755,6 +498,10 @@ def _asarray_tuplesafe(values, dtype=None):
 
     return result
 
+def _stringify(col):
+    # unicode workaround
+    return unicode(col)
+
 def _maybe_make_list(obj):
     if obj is not None and not isinstance(obj, (tuple, list)):
         return [obj]
diff --git a/pandas/core/format.py b/pandas/core/format.py
index a699935f9..393a46c4d 100644
--- a/pandas/core/format.py
+++ b/pandas/core/format.py
@@ -1,11 +1,13 @@
 from itertools import izip
 
 from StringIO import StringIO
-from pandas.core.common import adjoin, _format
+from pandas.core.common import adjoin, isnull, notnull, _stringify
 from pandas.core.index import MultiIndex, _ensure_index
 from pandas.util import py3compat
 
 import pandas.core.common as com
+import pandas._tseries as lib
+
 import numpy as np
 
 docstring_to_string = """
@@ -93,9 +95,9 @@ class SeriesFormatter(object):
         vals = series.values
 
         if self.float_format is None:
-            float_format = com.print_config.float_format
+            float_format = print_config.float_format
             if float_format is None:
-                float_format = com._float_format_default
+                float_format = _float_format_default
 
         # floating point handling
         if series.dtype == 'O':
@@ -139,6 +141,25 @@ class SeriesFormatter(object):
         return '\n'.join(result)
 
 
+def format_array(values, formatter, float_format):
+    # floating point handling
+    if values.dtype == 'O':
+        is_float = (lib.map_infer(values, com.is_float) & notnull(values))
+        leading_space = is_float.any()
+
+        fmt_values = []
+        for i, v in enumerate(values):
+            if not is_float[i] and leading_space:
+                fmt_values.append(' %s' % formatter(v))
+            elif is_float[i]:
+                fmt_values.append(float_format(v))
+            else:
+                fmt_values.append(' %s' % formatter(v))
+    else:
+        fmt_values = _format_fixed_width(values, formatter)
+    return fmt_values
+
+
 class DataFrameFormatter(object):
     """
     Render a DataFrame
@@ -166,7 +187,7 @@ class DataFrameFormatter(object):
         self.index = index
 
         if justify is None:
-            self.justify = com.print_config.colheader_justify
+            self.justify = print_config.colheader_justify
         else:
             self.justify = justify
 
@@ -438,6 +459,7 @@ class DataFrameFormatter(object):
             names.append('' if columns.name is None else columns.name)
         return names
 
+
 def _format_fixed_width(values, formatter):
     formatted = [formatter(x) for x in values]
     max_len = max(len(x) for x in formatted)
@@ -462,3 +484,252 @@ def _has_names(index):
         return any([x is not None for x in index.names])
     else:
         return index.name is not None
+
+
+
+#-------------------------------------------------------------------------------
+# Global formatting options
+
+def set_printoptions(precision=None, column_space=None, max_rows=None,
+                     max_columns=None, colheader_justify='right'):
+    """
+    Alter default behavior of DataFrame.toString
+
+    precision : int
+        Floating point output precision (number of significant digits)
+    column_space : int
+        Default space for DataFrame columns, defaults to 12
+    max_rows : int
+    max_columns : int
+        max_rows and max_columns are used in __repr__() methods to decide if
+        to_string() or info() is used to render an object to a string.
+        Either one, or both can be set to 0 (experimental). Pandas will figure
+        out how big the terminal is and will not display more rows or/and
+        columns that can fit on it.
+    """
+    if precision is not None:
+        print_config.precision = precision
+    if column_space is not None:
+        print_config.column_space = column_space
+    if max_rows is not None:
+        print_config.max_rows = max_rows
+    if max_columns is not None:
+        print_config.max_columns = max_columns
+    if colheader_justify is not None:
+        print_config.colheader_justify = colheader_justify
+
+def reset_printoptions():
+    print_config.reset()
+
+class EngFormatter(object):
+    """
+    Formats float values according to engineering format.
+
+    Based on matplotlib.ticker.EngFormatter
+    """
+
+    # The SI engineering prefixes
+    ENG_PREFIXES = {
+        -24: "y",
+        -21: "z",
+        -18: "a",
+        -15: "f",
+        -12: "p",
+         -9: "n",
+         -6: "u",
+         -3: "m",
+          0: "",
+          3: "k",
+          6: "M",
+          9: "G",
+         12: "T",
+         15: "P",
+         18: "E",
+         21: "Z",
+         24: "Y"
+      }
+
+    def __init__(self, accuracy=None, use_eng_prefix=False):
+        self.accuracy = accuracy
+        self.use_eng_prefix = use_eng_prefix
+
+    def __call__(self, num):
+        """ Formats a number in engineering notation, appending a letter
+        representing the power of 1000 of the original number. Some examples:
+
+        >>> format_eng(0)       # for self.accuracy = 0
+        ' 0'
+
+        >>> format_eng(1000000) # for self.accuracy = 1,
+                                #     self.use_eng_prefix = True
+        ' 1.0M'
+
+        >>> format_eng("-1e-6") # for self.accuracy = 2
+                                #     self.use_eng_prefix = False
+        '-1.00E-06'
+
+        @param num: the value to represent
+        @type num: either a numeric value or a string that can be converted to
+                   a numeric value (as per decimal.Decimal constructor)
+
+        @return: engineering formatted string
+        """
+        import decimal
+        import math
+        dnum = decimal.Decimal(str(num))
+
+        sign = 1
+
+        if dnum < 0:  # pragma: no cover
+            sign = -1
+            dnum = -dnum
+
+        if dnum != 0:
+            pow10 = decimal.Decimal(int(math.floor(dnum.log10()/3)*3))
+        else:
+            pow10 = decimal.Decimal(0)
+
+        pow10 = pow10.min(max(self.ENG_PREFIXES.keys()))
+        pow10 = pow10.max(min(self.ENG_PREFIXES.keys()))
+        int_pow10 = int(pow10)
+
+        if self.use_eng_prefix:
+            prefix = self.ENG_PREFIXES[int_pow10]
+        else:
+            if int_pow10 < 0:
+                prefix = 'E-%02d' % (-int_pow10)
+            else:
+                prefix = 'E+%02d' % int_pow10
+
+        mant = sign*dnum/(10**pow10)
+
+        if self.accuracy is None:  # pragma: no cover
+            format_str = u"% g%s"
+        else:
+            format_str = (u"%% .%if%%s" % self.accuracy )
+
+        formatted = format_str % (mant, prefix)
+
+        return formatted #.strip()
+
+def set_eng_float_format(precision=None, accuracy=3, use_eng_prefix=False):
+    """
+    Alter default behavior on how float is formatted in DataFrame.
+    Format float in engineering format. By accuracy, we mean the number of
+    decimal digits after the floating point.
+
+    See also EngFormatter.
+    """
+    if precision is not None: # pragma: no cover
+        import warnings
+        warnings.warn("'precision' parameter in set_eng_float_format is "
+                      "being renamed to 'accuracy'" , FutureWarning)
+        accuracy = precision
+
+    print_config.float_format = EngFormatter(accuracy, use_eng_prefix)
+    print_config.column_space = max(12, accuracy + 9)
+
+def _float_format_default(v, width=None):
+    """
+    Take a float and its formatted representation and if it needs extra space
+    to fit the width, reformat it to that width.
+    """
+
+    fmt_str   = '%% .%dg' % print_config.precision
+    formatted = fmt_str % v
+
+    if width is None:
+        return formatted
+
+    extra_spc = width - len(formatted)
+
+    if extra_spc <= 0:
+        return formatted
+
+    if 'e' in formatted:
+        # we have something like 1e13 or 1.23e13
+        base, exp = formatted.split('e')
+
+        if '.' in base:
+            # expand fraction by extra space
+            whole, frac = base.split('.')
+            fmt_str = '%%.%df' % (len(frac) + extra_spc)
+            frac = fmt_str % float("0.%s" % frac)
+            base = whole + frac[1:]
+        else:
+            if extra_spc > 1:
+                # enough room for fraction
+                fmt_str = '%% .%df' % (extra_spc - 1)
+                base = fmt_str % float(base)
+            else:
+                # enough room for decimal point only
+                base += '.'
+
+        return base + 'e' + exp
+    else:
+        # we have something like 123 or 123.456
+        if '.' in formatted:
+            # expand fraction by extra space
+            wholel, fracl = map(len, formatted.split("."))
+            fmt_str = '%% .%df' % (fracl + extra_spc)
+        else:
+            if extra_spc > 1:
+                # enough room for fraction
+                fmt_str = '%% .%df' % (extra_spc - 1)
+            else:
+                # enough room for decimal point only
+                fmt_str = '% d.'
+
+        return fmt_str % v
+
+def _format(s, dtype, space=None, na_rep=None, float_format=None,
+            col_width=None):
+    def _just_help(x):
+        if space is None:
+            return x
+        return x[:space].ljust(space)
+
+    def _make_float_format(x):
+        if na_rep is not None and isnull(x):
+            if np.isnan(x):
+                x = ' ' + na_rep
+            return _just_help('%s' % x)
+
+        if float_format:
+            formatted = float_format(x)
+        elif print_config.float_format:
+            formatted = print_config.float_format(x)
+        else:
+            formatted = _float_format_default(x, col_width)
+
+        return _just_help(formatted)
+
+    def _make_int_format(x):
+        return _just_help('% d' % x)
+
+    if com.is_float_dtype(dtype):
+        return _make_float_format(s)
+    elif com.is_integer_dtype(dtype):
+        return _make_int_format(s)
+    else:
+        if na_rep is not None and lib.checknull(s):
+            if s is None:
+                return 'None'
+            return na_rep
+        else:
+            # object dtype
+            return _just_help('%s' % _stringify(s))
+
+class _GlobalPrintConfig(object):
+    def __init__(self):
+        self.precision = 4
+        self.float_format = None
+        self.column_space = 12
+        self.max_rows = 200
+        self.max_columns = 0
+        self.colheader_justify = 'right'
+
+    def reset(self):
+        self.__init__()
+
+print_config = _GlobalPrintConfig()
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 29f866d87..59d348315 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -34,7 +34,7 @@ from pandas.util import py3compat
 from pandas.util.terminal import get_terminal_size
 from pandas.util.decorators import deprecate, Appender, Substitution
 
-from pandas.core.format import DataFrameFormatter, docstring_to_string
+import pandas.core.format as fmt
 
 import pandas.core.nanops as nanops
 import pandas.core.common as com
@@ -433,7 +433,7 @@ class DataFrame(NDFrame):
         """
         Return a string representation for a particular DataFrame
         """
-        config = com.print_config
+        config = fmt.print_config
 
         terminal_width, terminal_height = get_terminal_size()
         max_rows = (terminal_height if config.max_rows == 0
@@ -474,7 +474,6 @@ class DataFrame(NDFrame):
         """
         Iterate over rows of DataFrame as (index, Series) pairs
         """
-        from itertools import izip
         columns = self.columns
         for k, v in izip(self.index, self.values):
             s = v.view(Series)
@@ -946,7 +945,7 @@ class DataFrame(NDFrame):
 
         f.close()
 
-    @Appender(docstring_to_string, indents=1)
+    @Appender(fmt.docstring_to_string, indents=1)
     def to_string(self, buf=None, columns=None, col_space=None, colSpace=None,
                   header=True, index=True, na_rep='NaN', formatters=None,
                   float_format=None, sparsify=True, nanRep=None,
@@ -967,20 +966,20 @@ class DataFrame(NDFrame):
                           FutureWarning)
             col_space = colSpace
 
-        formatter = DataFrameFormatter(self, buf=buf, columns=columns,
-                                       col_space=col_space, na_rep=na_rep,
-                                       formatters=formatters,
-                                       float_format=float_format,
-                                       sparsify=sparsify,
-                                       justify=justify,
-                                       index_names=index_names,
-                                       header=header, index=index)
+        formatter = fmt.DataFrameFormatter(self, buf=buf, columns=columns,
+                                           col_space=col_space, na_rep=na_rep,
+                                           formatters=formatters,
+                                           float_format=float_format,
+                                           sparsify=sparsify,
+                                           justify=justify,
+                                           index_names=index_names,
+                                           header=header, index=index)
         formatter.to_string(force_unicode=force_unicode)
 
         if buf is None:
             return formatter.buf.getvalue()
 
-    @Appender(docstring_to_string, indents=1)
+    @Appender(fmt.docstring_to_string, indents=1)
     def to_html(self, buf=None, columns=None, col_space=None, colSpace=None,
                 header=True, index=True, na_rep='NaN', formatters=None,
                 float_format=None, sparsify=True, index_names=True,
@@ -999,14 +998,14 @@ class DataFrame(NDFrame):
                           FutureWarning)
             col_space = colSpace
 
-        formatter = DataFrameFormatter(self, buf=buf, columns=columns,
-                                       col_space=col_space, na_rep=na_rep,
-                                       header=header, index=index,
-                                       formatters=formatters,
-                                       float_format=float_format,
-                                       bold_rows=bold_rows,
-                                       sparsify=sparsify,
-                                       index_names=index_names)
+        formatter = fmt.DataFrameFormatter(self, buf=buf, columns=columns,
+                                           col_space=col_space, na_rep=na_rep,
+                                           header=header, index=index,
+                                           formatters=formatters,
+                                           float_format=float_format,
+                                           bold_rows=bold_rows,
+                                           sparsify=sparsify,
+                                           index_names=index_names)
         formatter.to_html()
 
         if buf is None:
@@ -2842,7 +2841,7 @@ class DataFrame(NDFrame):
     def _apply_raw(self, func, axis):
         try:
             result = lib.reduce(self.values, func, axis=axis)
-        except Exception, e:
+        except Exception:
             result = np.apply_along_axis(func, axis, self.values)
 
         # TODO: mixed type case
@@ -3760,7 +3759,6 @@ class DataFrame(NDFrame):
             To be passed to hist function
         """
         import pandas.tools.plotting as gfx
-        import matplotlib.pyplot as plt
 
         n = len(self.columns)
         k = 1
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 1888060b7..1c2ba32f2 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -5,8 +5,6 @@ from itertools import izip
 
 import numpy as np
 
-from pandas.core.common import (adjoin as _adjoin, _stringify, _try_sort,
-                                _is_bool_indexer, _asarray_tuplesafe)
 from pandas.util.decorators import cache_readonly
 import pandas.core.common as com
 import pandas._tseries as lib
@@ -68,7 +66,7 @@ class Index(np.ndarray):
                              'of some kind, %s was passed' % repr(data))
         else:
             # other iterable of some kind
-            subarr = _asarray_tuplesafe(data, dtype=object)
+            subarr = com._asarray_tuplesafe(data, dtype=object)
 
         if lib.is_integer_array(subarr) and dtype is None:
             return Int64Index(subarr.astype('i8'), name=name)
@@ -223,7 +221,7 @@ class Index(np.ndarray):
         if np.isscalar(key):
             return arr_idx[key]
         else:
-            if _is_bool_indexer(key):
+            if com._is_bool_indexer(key):
                 key = np.asarray(key)
 
             result = arr_idx[key]
@@ -274,7 +272,7 @@ class Index(np.ndarray):
                 result.append(dt.strftime("%Y-%m-%d"))
             return result
 
-        result.extend(_stringify(x) for x in self)
+        result.extend(com._stringify(x) for x in self)
 
         return result
 
@@ -1247,7 +1245,7 @@ class MultiIndex(Index):
             result_levels = _sparsify(result_levels)
 
         if adjoin:
-            return _adjoin(space, *result_levels).split('\n')
+            return com.adjoin(space, *result_levels).split('\n')
         else:
             return result_levels
 
@@ -1360,7 +1358,7 @@ class MultiIndex(Index):
             return tuple(lev[lab[key]]
                          for lev, lab in zip(self.levels, self.labels))
         else:
-            if _is_bool_indexer(key):
+            if com._is_bool_indexer(key):
                 key = np.asarray(key)
                 sortorder = self.sortorder
             else:
@@ -1424,7 +1422,7 @@ class MultiIndex(Index):
         """
         try:
             if not isinstance(labels, np.ndarray):
-                labels = _asarray_tuplesafe(labels)
+                labels = com._asarray_tuplesafe(labels)
             indexer = self.get_indexer(labels)
             mask = indexer == -1
             if mask.any():
@@ -2168,7 +2166,8 @@ def _sanitize_and_check(indexes):
 
     if list in kinds:
         if len(kinds) > 1:
-            indexes = [Index(_try_sort(x)) if not isinstance(x, Index) else x
+            indexes = [Index(com._try_sort(x))
+                       if not isinstance(x, Index) else x
                        for x in indexes]
             kinds.remove(list)
         else:
diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index 8c1a8993e..4c32e67b7 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -15,7 +15,7 @@ except ImportError:  # pragma: no cover
 def _bottleneck_switch(bn_name, alt, **kwargs):
     try:
         bn_func = getattr(bn, bn_name)
-    except AttributeError:  # pragma: no cover
+    except (AttributeError, NameError):  # pragma: no cover
         bn_func = None
     def f(values, axis=None, skipna=True):
         try:
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 8def81a12..c574b1e93 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -17,7 +17,6 @@ from pandas.core.common import (isnull, notnull, _is_bool_indexer,
                                 _default_index, _maybe_upcast,
                                 _asarray_tuplesafe)
 from pandas.core.daterange import DateRange
-from pandas.core.format import SeriesFormatter
 from pandas.core.index import (Index, MultiIndex, InvalidIndexError,
                                _ensure_index)
 from pandas.core.indexing import _SeriesIndexer
@@ -25,6 +24,7 @@ from pandas.util import py3compat
 from pandas.util.terminal import get_terminal_size
 import pandas.core.common as com
 import pandas.core.datetools as datetools
+import pandas.core.format as fmt
 import pandas.core.generic as generic
 import pandas.core.nanops as nanops
 import pandas._tseries as lib
@@ -583,8 +583,8 @@ copy : boolean, default False
     def __repr__(self):
         """Clean string representation of a Series"""
         width, height = get_terminal_size()
-        max_rows = (height if com.print_config.max_rows == 0
-                    else com.print_config.max_rows)
+        max_rows = (height if fmt.print_config.max_rows == 0
+                    else fmt.print_config.max_rows)
         if len(self.index) > max_rows:
             result = self._tidy_repr(min(30, max_rows - 4))
         elif len(self.index) > 0:
@@ -647,9 +647,9 @@ copy : boolean, default False
 
     def _get_repr(self, name=False, print_header=False, length=True,
                   na_rep='NaN', float_format=None):
-        formatter = SeriesFormatter(self, name=name, header=print_header,
-                                    length=length, na_rep=na_rep,
-                                    float_format=float_format)
+        formatter = fmt.SeriesFormatter(self, name=name, header=print_header,
+                                        length=length, na_rep=na_rep,
+                                        float_format=float_format)
         return formatter.to_string()
 
     def __str__(self):
diff --git a/pandas/tests/test_common.py b/pandas/tests/test_common.py
index 3976986e7..40a800227 100644
--- a/pandas/tests/test_common.py
+++ b/pandas/tests/test_common.py
@@ -267,167 +267,6 @@ class TestTake(unittest.TestCase):
         expected[:, [2, 4]] = np.nan
         tm.assert_almost_equal(result, expected)
 
-class TestEngFormatter(unittest.TestCase):
-     def compare(self, formatter, input, output):
-         formatted_input = formatter(input)
-         msg = "formatting of %s results in '%s', expected '%s'" % (str(input),
-                 formatted_input, output)
-         self.assertEqual(formatted_input, output, msg)
-
-     def compare_all(self, formatter, in_out):
-         """
-         Parameters:
-         -----------
-         formatter: EngFormatter under test
-         in_out: list of tuples. Each tuple = (number, expected_formatting)
-
-         It is tested if 'formatter(number) == expected_formatting'.
-         *number* should be >= 0 because formatter(-number) == fmt is also
-         tested. *fmt* is derived from *expected_formatting*
-         """
-         for input, output in in_out:
-             self.compare(formatter, input, output)
-             self.compare(formatter, -input, "-" + output[1:])
-
-     def test_exponents_with_eng_prefix(self):
-         formatter = common.EngFormatter(accuracy=3, use_eng_prefix=True)
-         f = np.sqrt(2)
-         in_out = [(f * 10 ** -24, " 1.414y"),
-                   (f * 10 ** -23, " 14.142y"),
-                   (f * 10 ** -22, " 141.421y"),
-                   (f * 10 ** -21, " 1.414z"),
-                   (f * 10 ** -20, " 14.142z"),
-                   (f * 10 ** -19, " 141.421z"),
-                   (f * 10 ** -18, " 1.414a"),
-                   (f * 10 ** -17, " 14.142a"),
-                   (f * 10 ** -16, " 141.421a"),
-                   (f * 10 ** -15, " 1.414f"),
-                   (f * 10 ** -14, " 14.142f"),
-                   (f * 10 ** -13, " 141.421f"),
-                   (f * 10 ** -12, " 1.414p"),
-                   (f * 10 ** -11, " 14.142p"),
-                   (f * 10 ** -10, " 141.421p"),
-                   (f * 10 ** -9, " 1.414n"),
-                   (f * 10 ** -8, " 14.142n"),
-                   (f * 10 ** -7, " 141.421n"),
-                   (f * 10 ** -6, " 1.414u"),
-                   (f * 10 ** -5, " 14.142u"),
-                   (f * 10 ** -4, " 141.421u"),
-                   (f * 10 ** -3, " 1.414m"),
-                   (f * 10 ** -2, " 14.142m"),
-                   (f * 10 ** -1, " 141.421m"),
-                   (f * 10 ** 0, " 1.414"),
-                   (f * 10 ** 1, " 14.142"),
-                   (f * 10 ** 2, " 141.421"),
-                   (f * 10 ** 3, " 1.414k"),
-                   (f * 10 ** 4, " 14.142k"),
-                   (f * 10 ** 5, " 141.421k"),
-                   (f * 10 ** 6, " 1.414M"),
-                   (f * 10 ** 7, " 14.142M"),
-                   (f * 10 ** 8, " 141.421M"),
-                   (f * 10 ** 9, " 1.414G"),
-                   (f * 10 ** 10, " 14.142G"),
-                   (f * 10 ** 11, " 141.421G"),
-                   (f * 10 ** 12, " 1.414T"),
-                   (f * 10 ** 13, " 14.142T"),
-                   (f * 10 ** 14, " 141.421T"),
-                   (f * 10 ** 15, " 1.414P"),
-                   (f * 10 ** 16, " 14.142P"),
-                   (f * 10 ** 17, " 141.421P"),
-                   (f * 10 ** 18, " 1.414E"),
-                   (f * 10 ** 19, " 14.142E"),
-                   (f * 10 ** 20, " 141.421E"),
-                   (f * 10 ** 21, " 1.414Z"),
-                   (f * 10 ** 22, " 14.142Z"),
-                   (f * 10 ** 23, " 141.421Z"),
-                   (f * 10 ** 24, " 1.414Y"),
-                   (f * 10 ** 25, " 14.142Y"),
-                   (f * 10 ** 26, " 141.421Y")]
-         self.compare_all(formatter, in_out)
-
-     def test_exponents_without_eng_prefix(self):
-         formatter = common.EngFormatter(accuracy=4, use_eng_prefix=False)
-         f = np.pi
-         in_out = [(f * 10 ** -24, " 3.1416E-24"),
-                   (f * 10 ** -23, " 31.4159E-24"),
-                   (f * 10 ** -22, " 314.1593E-24"),
-                   (f * 10 ** -21, " 3.1416E-21"),
-                   (f * 10 ** -20, " 31.4159E-21"),
-                   (f * 10 ** -19, " 314.1593E-21"),
-                   (f * 10 ** -18, " 3.1416E-18"),
-                   (f * 10 ** -17, " 31.4159E-18"),
-                   (f * 10 ** -16, " 314.1593E-18"),
-                   (f * 10 ** -15, " 3.1416E-15"),
-                   (f * 10 ** -14, " 31.4159E-15"),
-                   (f * 10 ** -13, " 314.1593E-15"),
-                   (f * 10 ** -12, " 3.1416E-12"),
-                   (f * 10 ** -11, " 31.4159E-12"),
-                   (f * 10 ** -10, " 314.1593E-12"),
-                   (f * 10 ** -9, " 3.1416E-09"),
-                   (f * 10 ** -8, " 31.4159E-09"),
-                   (f * 10 ** -7, " 314.1593E-09"),
-                   (f * 10 ** -6, " 3.1416E-06"),
-                   (f * 10 ** -5, " 31.4159E-06"),
-                   (f * 10 ** -4, " 314.1593E-06"),
-                   (f * 10 ** -3, " 3.1416E-03"),
-                   (f * 10 ** -2, " 31.4159E-03"),
-                   (f * 10 ** -1, " 314.1593E-03"),
-                   (f * 10 ** 0, " 3.1416E+00"),
-                   (f * 10 ** 1, " 31.4159E+00"),
-                   (f * 10 ** 2, " 314.1593E+00"),
-                   (f * 10 ** 3, " 3.1416E+03"),
-                   (f * 10 ** 4, " 31.4159E+03"),
-                   (f * 10 ** 5, " 314.1593E+03"),
-                   (f * 10 ** 6, " 3.1416E+06"),
-                   (f * 10 ** 7, " 31.4159E+06"),
-                   (f * 10 ** 8, " 314.1593E+06"),
-                   (f * 10 ** 9, " 3.1416E+09"),
-                   (f * 10 ** 10, " 31.4159E+09"),
-                   (f * 10 ** 11, " 314.1593E+09"),
-                   (f * 10 ** 12, " 3.1416E+12"),
-                   (f * 10 ** 13, " 31.4159E+12"),
-                   (f * 10 ** 14, " 314.1593E+12"),
-                   (f * 10 ** 15, " 3.1416E+15"),
-                   (f * 10 ** 16, " 31.4159E+15"),
-                   (f * 10 ** 17, " 314.1593E+15"),
-                   (f * 10 ** 18, " 3.1416E+18"),
-                   (f * 10 ** 19, " 31.4159E+18"),
-                   (f * 10 ** 20, " 314.1593E+18"),
-                   (f * 10 ** 21, " 3.1416E+21"),
-                   (f * 10 ** 22, " 31.4159E+21"),
-                   (f * 10 ** 23, " 314.1593E+21"),
-                   (f * 10 ** 24, " 3.1416E+24"),
-                   (f * 10 ** 25, " 31.4159E+24"),
-                   (f * 10 ** 26, " 314.1593E+24")]
-         self.compare_all(formatter, in_out)
-
-     def test_rounding(self):
-         formatter = common.EngFormatter(accuracy=3, use_eng_prefix=True)
-         in_out = [(5.55555, ' 5.556'),
-                   (55.5555, ' 55.556'),
-                   (555.555, ' 555.555'),
-                   (5555.55, ' 5.556k'),
-                   (55555.5, ' 55.556k'),
-                   (555555, ' 555.555k')]
-         self.compare_all(formatter, in_out)
-
-         formatter = common.EngFormatter(accuracy=1, use_eng_prefix=True)
-         in_out = [(5.55555, ' 5.6'),
-                   (55.5555, ' 55.6'),
-                   (555.555, ' 555.6'),
-                   (5555.55, ' 5.6k'),
-                   (55555.5, ' 55.6k'),
-                   (555555, ' 555.6k')]
-         self.compare_all(formatter, in_out)
-
-         formatter = common.EngFormatter(accuracy=0, use_eng_prefix=True)
-         in_out = [(5.55555, ' 6'),
-                   (55.5555, ' 56'),
-                   (555.555, ' 556'),
-                   (5555.55, ' 6k'),
-                   (55555.5, ' 56k'),
-                   (555555, ' 556k')]
-         self.compare_all(formatter, in_out)
 
 if __name__ == '__main__':
     import nose
diff --git a/pandas/tests/test_format.py b/pandas/tests/test_format.py
new file mode 100644
index 000000000..7c6c3c6b2
--- /dev/null
+++ b/pandas/tests/test_format.py
@@ -0,0 +1,443 @@
+from StringIO import StringIO
+import sys
+import unittest
+
+from numpy import nan
+from numpy.random import randn
+import numpy as np
+
+from pandas import DataFrame, Series
+import pandas.core.format as fmt
+import pandas.util.testing as tm
+
+_frame = DataFrame(tm.getSeriesData())
+
+class TestDataFrameFormatting(unittest.TestCase):
+
+    def setUp(self):
+        self.frame = _frame.copy()
+
+    def test_repr_embedded_ndarray(self):
+        arr = np.empty(10, dtype=[('err', object)])
+        for i in range(len(arr)):
+            arr['err'][i] = np.random.randn(i)
+
+        df = DataFrame(arr)
+        repr(df['err'])
+        repr(df)
+        df.to_string()
+
+    def test_eng_float_formatter(self):
+        self.frame.ix[5] = 0
+
+        fmt.set_eng_float_format()
+        repr(self.frame)
+
+        fmt.set_eng_float_format(use_eng_prefix=True)
+        repr(self.frame)
+
+        fmt.set_eng_float_format(accuracy=0)
+        repr(self.frame)
+
+        fmt.reset_printoptions()
+
+    def test_repr_tuples(self):
+        buf = StringIO()
+
+        df = DataFrame({'tups' : zip(range(10), range(10))})
+        repr(df)
+        df.to_string(col_space=10, buf=buf)
+
+    def test_to_string_repr_unicode(self):
+        buf = StringIO()
+
+        unicode_values = [u'\u03c3'] * 10
+        unicode_values = np.array(unicode_values, dtype=object)
+        df = DataFrame({'unicode' : unicode_values})
+        df.to_string(col_space=10, buf=buf)
+
+        # it works!
+        repr(df)
+
+        # it works even if sys.stdin in None
+        sys.stdin = None
+        repr(df)
+        sys.stdin = sys.__stdin__
+
+    def test_to_string_unicode_columns(self):
+        df = DataFrame({u'\u03c3' : np.arange(10.)})
+
+        buf = StringIO()
+        df.to_string(buf=buf)
+        buf.getvalue()
+
+        buf = StringIO()
+        df.info(buf=buf)
+        buf.getvalue()
+
+        result = self.frame.to_string(force_unicode=True)
+        self.assert_(isinstance(result, unicode))
+
+    def test_to_string_unicode_two(self):
+        dm = DataFrame({u'c/\u03c3': []})
+        buf = StringIO()
+        dm.to_string(buf)
+
+    def test_to_string_with_formatters_unicode(self):
+        df = DataFrame({u'c/\u03c3':[1,2,3]})
+        result = df.to_string(formatters={u'c/\u03c3': lambda x: '%s' % x})
+        self.assertEqual(result, u'  c/\u03c3\n0 1  \n1 2  \n2 3  ')
+
+    def test_to_string_buffer_all_unicode(self):
+        buf = StringIO()
+
+        empty = DataFrame({u'c/\u03c3':Series()})
+        nonempty = DataFrame({u'c/\u03c3':Series([1,2,3])})
+
+        print >>buf, empty
+        print >>buf, nonempty
+
+        # this should work
+        buf.getvalue()
+
+    def test_unicode_problem_decoding_as_ascii(self):
+        dm = DataFrame({u'c/\u03c3': Series({'test':np.NaN})})
+        unicode(dm.to_string())
+
+    def test_repr_corner(self):
+        # representing infs poses no problems
+        df = DataFrame({'foo' : np.inf * np.empty(10)})
+        foo = repr(df)
+
+    def test_to_string(self):
+        from pandas import read_table
+        import re
+
+        # big mixed
+        biggie = DataFrame({'A' : randn(200),
+                            'B' : tm.makeStringIndex(200)},
+                            index=range(200))
+
+        biggie['A'][:20] = nan
+        biggie['B'][:20] = nan
+        s = biggie.to_string()
+
+        buf = StringIO()
+        retval = biggie.to_string(buf=buf)
+        self.assert_(retval is None)
+        self.assertEqual(buf.getvalue(), s)
+
+        self.assert_(isinstance(s, basestring))
+
+        # print in right order
+        result = biggie.to_string(columns=['B', 'A'], col_space=17,
+                                  float_format='%.6f'.__mod__)
+        lines = result.split('\n')
+        header = lines[0].strip().split()
+        joined = '\n'.join([re.sub('\s+', ' ', x).strip() for x in lines[1:]])
+        recons = read_table(StringIO(joined), names=header, sep=' ')
+        tm.assert_series_equal(recons['B'], biggie['B'])
+        self.assertEqual(recons['A'].count(), biggie['A'].count())
+        self.assert_((np.abs(recons['A'].dropna() -
+                             biggie['A'].dropna()) < 0.1).all())
+
+        # expected = ['B', 'A']
+        # self.assertEqual(header, expected)
+
+        result = biggie.to_string(columns=['A'], col_space=17)
+        header = result.split('\n')[0].strip().split()
+        expected = ['A']
+        self.assertEqual(header, expected)
+
+        biggie.to_string(columns=['B', 'A'],
+                         formatters={'A' : lambda x: '%.1f' % x})
+
+        biggie.to_string(columns=['B', 'A'], float_format=str)
+        biggie.to_string(columns=['B', 'A'], col_space=12,
+                         float_format=str)
+
+        frame = DataFrame(index=np.arange(200))
+        frame.to_string()
+
+    def test_to_string_no_header(self):
+        df = DataFrame({'x' : [1, 2, 3],
+                        'y' : [4, 5, 6]})
+
+        df_s = df.to_string(header=False)
+        expected = "0  1  4\n1  2  5\n2  3  6"
+
+        assert(df_s == expected)
+
+    def test_to_string_no_index(self):
+        df = DataFrame({'x' : [1, 2, 3],
+                        'y' : [4, 5, 6]})
+
+        df_s = df.to_string(index=False)
+        expected = " x  y\n 1  4\n 2  5\n 3  6"
+
+        assert(df_s == expected)
+
+    def test_to_string_float_formatting(self):
+        fmt.reset_printoptions()
+        fmt.set_printoptions(precision=6, column_space=12)
+
+        df = DataFrame({'x' : [0, 0.25, 3456.000, 12e+45, 1.64e+6,
+                               1.7e+8, 1.253456, np.pi, -1e6]})
+
+        df_s = df.to_string()
+
+        # Python 2.5 just wants me to be sad. And debian 32-bit
+        #sys.version_info[0] == 2 and sys.version_info[1] < 6:
+        if '%.4g' % 1.7e8 == '1.7e+008':
+            expected = ('   x        \n0  0.0000000\n1  0.2500000\n'
+                        '2  3456.0000\n3  1.20e+046\n4  1.64e+006\n'
+                        '5  1.70e+008\n6  1.2534560\n7  3.1415927\n'
+                        '8 -1.00e+006')
+        else:
+            expected = ('   x       \n0  0.000000\n1  0.250000\n'
+                        '2  3456.000\n3  1.20e+46\n4  1.64e+06\n'
+                        '5  1.70e+08\n6  1.253456\n7  3.141593\n'
+                        '8 -1.00e+06')
+        assert(df_s == expected)
+
+        df = DataFrame({'x' : [3234, 0.253]})
+        df_s = df.to_string()
+
+        expected = '   x    \n0  3234.\n1  0.253'
+        assert(df_s == expected)
+
+        fmt.reset_printoptions()
+        self.assertEqual(fmt.print_config.precision, 4)
+
+        df = DataFrame({'x': [1e9, 0.2512]})
+        df_s = df.to_string()
+        if sys.version_info[0] == 2 and sys.version_info[1] < 6:
+            expected = '   x     \n0  1e+009\n1  0.2512'
+        else:
+            expected = '   x     \n0  1.e+09\n1  0.2512'
+        assert(df_s == expected)
+
+    def test_to_string_right_justify_cols(self):
+        fmt.reset_printoptions()
+        df = DataFrame({'x' : [3234, 0.253]})
+        df_s = df.to_string(justify='right')
+        expected = '       x\n0  3234.\n1  0.253'
+        assert(df_s == expected)
+
+    def test_to_string_format_na(self):
+        fmt.reset_printoptions()
+        df = DataFrame({'A' : [np.nan, -1, -2.1234, 3, 4],
+                        'B' : [np.nan, 'foo', 'foooo', 'fooooo', 'bar']})
+        result = df.to_string()
+
+        expected = ('   A     B     \n'
+                    '0  NaN   NaN   \n'
+                    '1 -1.000 foo   \n'
+                    '2 -2.123 foooo \n'
+                    '3  3.000 fooooo\n'
+                    '4  4.000 bar   ')
+        self.assertEqual(result, expected)
+
+    def test_to_html(self):
+        # big mixed
+        biggie = DataFrame({'A' : randn(200),
+                            'B' : tm.makeStringIndex(200)},
+                            index=range(200))
+
+        biggie['A'][:20] = nan
+        biggie['B'][:20] = nan
+        s = biggie.to_html()
+
+        buf = StringIO()
+        retval = biggie.to_html(buf=buf)
+        self.assert_(retval is None)
+        self.assertEqual(buf.getvalue(), s)
+
+        self.assert_(isinstance(s, basestring))
+
+        biggie.to_html(columns=['B', 'A'], col_space=17)
+        biggie.to_html(columns=['B', 'A'],
+                       formatters={'A' : lambda x: '%.1f' % x})
+
+        biggie.to_html(columns=['B', 'A'], float_format=str)
+        biggie.to_html(columns=['B', 'A'], col_space=12,
+                       float_format=str)
+
+        frame = DataFrame(index=np.arange(200))
+        frame.to_html()
+
+    def test_to_html_with_no_bold(self):
+        x = DataFrame({'x': randn(5)})
+        ashtml = x.to_html(bold_rows=False)
+        assert('<strong>' not in ashtml)
+
+
+class TestEngFormatter(unittest.TestCase):
+
+     def compare(self, formatter, input, output):
+         formatted_input = formatter(input)
+         msg = "formatting of %s results in '%s', expected '%s'" % (str(input),
+                 formatted_input, output)
+         self.assertEqual(formatted_input, output, msg)
+
+     def compare_all(self, formatter, in_out):
+         """
+         Parameters:
+         -----------
+         formatter: EngFormatter under test
+         in_out: list of tuples. Each tuple = (number, expected_formatting)
+
+         It is tested if 'formatter(number) == expected_formatting'.
+         *number* should be >= 0 because formatter(-number) == fmt is also
+         tested. *fmt* is derived from *expected_formatting*
+         """
+         for input, output in in_out:
+             self.compare(formatter, input, output)
+             self.compare(formatter, -input, "-" + output[1:])
+
+     def test_exponents_with_eng_prefix(self):
+         formatter = fmt.EngFormatter(accuracy=3, use_eng_prefix=True)
+         f = np.sqrt(2)
+         in_out = [(f * 10 ** -24, " 1.414y"),
+                   (f * 10 ** -23, " 14.142y"),
+                   (f * 10 ** -22, " 141.421y"),
+                   (f * 10 ** -21, " 1.414z"),
+                   (f * 10 ** -20, " 14.142z"),
+                   (f * 10 ** -19, " 141.421z"),
+                   (f * 10 ** -18, " 1.414a"),
+                   (f * 10 ** -17, " 14.142a"),
+                   (f * 10 ** -16, " 141.421a"),
+                   (f * 10 ** -15, " 1.414f"),
+                   (f * 10 ** -14, " 14.142f"),
+                   (f * 10 ** -13, " 141.421f"),
+                   (f * 10 ** -12, " 1.414p"),
+                   (f * 10 ** -11, " 14.142p"),
+                   (f * 10 ** -10, " 141.421p"),
+                   (f * 10 ** -9, " 1.414n"),
+                   (f * 10 ** -8, " 14.142n"),
+                   (f * 10 ** -7, " 141.421n"),
+                   (f * 10 ** -6, " 1.414u"),
+                   (f * 10 ** -5, " 14.142u"),
+                   (f * 10 ** -4, " 141.421u"),
+                   (f * 10 ** -3, " 1.414m"),
+                   (f * 10 ** -2, " 14.142m"),
+                   (f * 10 ** -1, " 141.421m"),
+                   (f * 10 ** 0, " 1.414"),
+                   (f * 10 ** 1, " 14.142"),
+                   (f * 10 ** 2, " 141.421"),
+                   (f * 10 ** 3, " 1.414k"),
+                   (f * 10 ** 4, " 14.142k"),
+                   (f * 10 ** 5, " 141.421k"),
+                   (f * 10 ** 6, " 1.414M"),
+                   (f * 10 ** 7, " 14.142M"),
+                   (f * 10 ** 8, " 141.421M"),
+                   (f * 10 ** 9, " 1.414G"),
+                   (f * 10 ** 10, " 14.142G"),
+                   (f * 10 ** 11, " 141.421G"),
+                   (f * 10 ** 12, " 1.414T"),
+                   (f * 10 ** 13, " 14.142T"),
+                   (f * 10 ** 14, " 141.421T"),
+                   (f * 10 ** 15, " 1.414P"),
+                   (f * 10 ** 16, " 14.142P"),
+                   (f * 10 ** 17, " 141.421P"),
+                   (f * 10 ** 18, " 1.414E"),
+                   (f * 10 ** 19, " 14.142E"),
+                   (f * 10 ** 20, " 141.421E"),
+                   (f * 10 ** 21, " 1.414Z"),
+                   (f * 10 ** 22, " 14.142Z"),
+                   (f * 10 ** 23, " 141.421Z"),
+                   (f * 10 ** 24, " 1.414Y"),
+                   (f * 10 ** 25, " 14.142Y"),
+                   (f * 10 ** 26, " 141.421Y")]
+         self.compare_all(formatter, in_out)
+
+     def test_exponents_without_eng_prefix(self):
+         formatter = fmt.EngFormatter(accuracy=4, use_eng_prefix=False)
+         f = np.pi
+         in_out = [(f * 10 ** -24, " 3.1416E-24"),
+                   (f * 10 ** -23, " 31.4159E-24"),
+                   (f * 10 ** -22, " 314.1593E-24"),
+                   (f * 10 ** -21, " 3.1416E-21"),
+                   (f * 10 ** -20, " 31.4159E-21"),
+                   (f * 10 ** -19, " 314.1593E-21"),
+                   (f * 10 ** -18, " 3.1416E-18"),
+                   (f * 10 ** -17, " 31.4159E-18"),
+                   (f * 10 ** -16, " 314.1593E-18"),
+                   (f * 10 ** -15, " 3.1416E-15"),
+                   (f * 10 ** -14, " 31.4159E-15"),
+                   (f * 10 ** -13, " 314.1593E-15"),
+                   (f * 10 ** -12, " 3.1416E-12"),
+                   (f * 10 ** -11, " 31.4159E-12"),
+                   (f * 10 ** -10, " 314.1593E-12"),
+                   (f * 10 ** -9, " 3.1416E-09"),
+                   (f * 10 ** -8, " 31.4159E-09"),
+                   (f * 10 ** -7, " 314.1593E-09"),
+                   (f * 10 ** -6, " 3.1416E-06"),
+                   (f * 10 ** -5, " 31.4159E-06"),
+                   (f * 10 ** -4, " 314.1593E-06"),
+                   (f * 10 ** -3, " 3.1416E-03"),
+                   (f * 10 ** -2, " 31.4159E-03"),
+                   (f * 10 ** -1, " 314.1593E-03"),
+                   (f * 10 ** 0, " 3.1416E+00"),
+                   (f * 10 ** 1, " 31.4159E+00"),
+                   (f * 10 ** 2, " 314.1593E+00"),
+                   (f * 10 ** 3, " 3.1416E+03"),
+                   (f * 10 ** 4, " 31.4159E+03"),
+                   (f * 10 ** 5, " 314.1593E+03"),
+                   (f * 10 ** 6, " 3.1416E+06"),
+                   (f * 10 ** 7, " 31.4159E+06"),
+                   (f * 10 ** 8, " 314.1593E+06"),
+                   (f * 10 ** 9, " 3.1416E+09"),
+                   (f * 10 ** 10, " 31.4159E+09"),
+                   (f * 10 ** 11, " 314.1593E+09"),
+                   (f * 10 ** 12, " 3.1416E+12"),
+                   (f * 10 ** 13, " 31.4159E+12"),
+                   (f * 10 ** 14, " 314.1593E+12"),
+                   (f * 10 ** 15, " 3.1416E+15"),
+                   (f * 10 ** 16, " 31.4159E+15"),
+                   (f * 10 ** 17, " 314.1593E+15"),
+                   (f * 10 ** 18, " 3.1416E+18"),
+                   (f * 10 ** 19, " 31.4159E+18"),
+                   (f * 10 ** 20, " 314.1593E+18"),
+                   (f * 10 ** 21, " 3.1416E+21"),
+                   (f * 10 ** 22, " 31.4159E+21"),
+                   (f * 10 ** 23, " 314.1593E+21"),
+                   (f * 10 ** 24, " 3.1416E+24"),
+                   (f * 10 ** 25, " 31.4159E+24"),
+                   (f * 10 ** 26, " 314.1593E+24")]
+         self.compare_all(formatter, in_out)
+
+     def test_rounding(self):
+         formatter = fmt.EngFormatter(accuracy=3, use_eng_prefix=True)
+         in_out = [(5.55555, ' 5.556'),
+                   (55.5555, ' 55.556'),
+                   (555.555, ' 555.555'),
+                   (5555.55, ' 5.556k'),
+                   (55555.5, ' 55.556k'),
+                   (555555, ' 555.555k')]
+         self.compare_all(formatter, in_out)
+
+         formatter = fmt.EngFormatter(accuracy=1, use_eng_prefix=True)
+         in_out = [(5.55555, ' 5.6'),
+                   (55.5555, ' 55.6'),
+                   (555.555, ' 555.6'),
+                   (5555.55, ' 5.6k'),
+                   (55555.5, ' 55.6k'),
+                   (555555, ' 555.6k')]
+         self.compare_all(formatter, in_out)
+
+         formatter = fmt.EngFormatter(accuracy=0, use_eng_prefix=True)
+         in_out = [(5.55555, ' 6'),
+                   (55.5555, ' 56'),
+                   (555.555, ' 556'),
+                   (5555.55, ' 6k'),
+                   (55555.5, ' 56k'),
+                   (555555, ' 556k')]
+         self.compare_all(formatter, in_out)
+
+
+if __name__ == '__main__':
+    import nose
+    nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
+                   exit=False)
+
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index af8c4a7cd..56a3ff3c5 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -13,7 +13,9 @@ from numpy.random import randn
 import numpy as np
 import numpy.ma as ma
 
+import pandas as pan
 import pandas.core.common as com
+import pandas.core.format as fmt
 import pandas.core.datetools as datetools
 from pandas.core.index import NULL_INDEX
 from pandas.core.api import (DataFrame, Index, Series, notnull, isnull,
@@ -1786,274 +1788,17 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
                                index=np.arange(50))
         foo = repr(unsortable)
 
-        com.set_printoptions(precision=3, column_space=10)
+        fmt.set_printoptions(precision=3, column_space=10)
         repr(self.frame)
 
-        com.set_printoptions(max_rows=10, max_columns=2)
+        fmt.set_printoptions(max_rows=10, max_columns=2)
         repr(self.frame)
-        com.reset_printoptions()
-
-    def test_repr_embedded_ndarray(self):
-        arr = np.empty(10, dtype=[('err', object)])
-        for i in range(len(arr)):
-            arr['err'][i] = np.random.randn(i)
-
-        df = DataFrame(arr)
-        repr(df['err'])
-        repr(df)
-        df.to_string()
-
-    def test_eng_float_formatter(self):
-        self.frame.ix[5] = 0
-
-        com.set_eng_float_format()
-
-        repr(self.frame)
-
-        com.set_eng_float_format(use_eng_prefix=True)
-
-        repr(self.frame)
-
-        com.set_eng_float_format(accuracy=0)
-
-        repr(self.frame)
-
-        com.reset_printoptions()
-
-    def test_repr_tuples(self):
-        buf = StringIO()
-
-        df = DataFrame({'tups' : zip(range(10), range(10))})
-        repr(df)
-        df.to_string(col_space=10, buf=buf)
-
-    def test_to_string_repr_unicode(self):
-        buf = StringIO()
-
-        unicode_values = [u'\u03c3'] * 10
-        unicode_values = np.array(unicode_values, dtype=object)
-        df = DataFrame({'unicode' : unicode_values})
-        df.to_string(col_space=10, buf=buf)
-
-        # it works!
-        repr(df)
-
-        # it works even if sys.stdin in None
-        sys.stdin = None
-        repr(df)
-        sys.stdin = sys.__stdin__
-
-    def test_to_string_unicode_columns(self):
-        df = DataFrame({u'\u03c3' : np.arange(10.)})
-
-        buf = StringIO()
-        df.to_string(buf=buf)
-        buf.getvalue()
-
-        buf = StringIO()
-        df.info(buf=buf)
-        buf.getvalue()
-
-        result = self.frame.to_string(force_unicode=True)
-        self.assert_(isinstance(result, unicode))
-
-    def test_to_string_unicode_two(self):
-        dm = DataFrame({u'c/\u03c3': []})
-        buf = StringIO()
-        dm.to_string(buf)
-
-    def test_to_string_with_formatters_unicode(self):
-        df = DataFrame({u'c/\u03c3':[1,2,3]})
-        result = df.to_string(formatters={u'c/\u03c3': lambda x: '%s' % x})
-        self.assertEqual(result, u'  c/\u03c3\n0 1  \n1 2  \n2 3  ')
-
-    def test_to_string_buffer_all_unicode(self):
-        buf = StringIO()
-
-        empty = DataFrame({u'c/\u03c3':Series()})
-        nonempty = DataFrame({u'c/\u03c3':Series([1,2,3])})
-
-        print >>buf, empty
-        print >>buf, nonempty
-
-        # this should work
-        buf.getvalue()
-
-    def test_unicode_problem_decoding_as_ascii(self):
-        dm = DataFrame({u'c/\u03c3': Series({'test':np.NaN})})
-        unicode(dm.to_string())
+        fmt.reset_printoptions()
 
     def test_head_tail(self):
         assert_frame_equal(self.frame.head(), self.frame[:5])
         assert_frame_equal(self.frame.tail(), self.frame[-5:])
 
-    def test_repr_corner(self):
-        # representing infs poses no problems
-        df = DataFrame({'foo' : np.inf * np.empty(10)})
-        foo = repr(df)
-
-    def test_to_string(self):
-        from pandas import read_table
-        import re
-
-        # big mixed
-        biggie = DataFrame({'A' : randn(200),
-                            'B' : tm.makeStringIndex(200)},
-                            index=range(200))
-
-        biggie['A'][:20] = nan
-        biggie['B'][:20] = nan
-        s = biggie.to_string()
-
-        buf = StringIO()
-        retval = biggie.to_string(buf=buf)
-        self.assert_(retval is None)
-        self.assertEqual(buf.getvalue(), s)
-
-        self.assert_(isinstance(s, basestring))
-
-        # print in right order
-        result = biggie.to_string(columns=['B', 'A'], col_space=17,
-                                  float_format='%.6f'.__mod__)
-        lines = result.split('\n')
-        header = lines[0].strip().split()
-        joined = '\n'.join([re.sub('\s+', ' ', x).strip() for x in lines[1:]])
-        recons = read_table(StringIO(joined), names=header, sep=' ')
-        assert_series_equal(recons['B'], biggie['B'])
-        self.assertEqual(recons['A'].count(), biggie['A'].count())
-        self.assert_((np.abs(recons['A'].dropna() -
-                             biggie['A'].dropna()) < 0.1).all())
-
-        # expected = ['B', 'A']
-        # self.assertEqual(header, expected)
-
-        result = biggie.to_string(columns=['A'], col_space=17)
-        header = result.split('\n')[0].strip().split()
-        expected = ['A']
-        self.assertEqual(header, expected)
-
-        biggie.to_string(columns=['B', 'A'],
-                         formatters={'A' : lambda x: '%.1f' % x})
-
-        biggie.to_string(columns=['B', 'A'], float_format=str)
-        biggie.to_string(columns=['B', 'A'], col_space=12,
-                         float_format=str)
-
-        frame = DataFrame(index=np.arange(200))
-        frame.to_string()
-
-    def test_to_string_no_header(self):
-        df = DataFrame({'x' : [1, 2, 3],
-                        'y' : [4, 5, 6]})
-
-        df_s = df.to_string(header=False)
-        expected = "0  1  4\n1  2  5\n2  3  6"
-
-        assert(df_s == expected)
-
-    def test_to_string_no_index(self):
-        df = DataFrame({'x' : [1, 2, 3],
-                        'y' : [4, 5, 6]})
-
-        df_s = df.to_string(index=False)
-        expected = " x  y\n 1  4\n 2  5\n 3  6"
-
-        assert(df_s == expected)
-
-    def test_to_string_float_formatting(self):
-        com.reset_printoptions()
-        com.set_printoptions(precision=6, column_space=12)
-
-        df = DataFrame({'x' : [0, 0.25, 3456.000, 12e+45, 1.64e+6,
-                               1.7e+8, 1.253456, np.pi, -1e6]})
-
-        df_s = df.to_string()
-
-        # Python 2.5 just wants me to be sad. And debian 32-bit
-        #sys.version_info[0] == 2 and sys.version_info[1] < 6:
-        if '%.4g' % 1.7e8 == '1.7e+008':
-            expected = ('   x        \n0  0.0000000\n1  0.2500000\n'
-                        '2  3456.0000\n3  1.20e+046\n4  1.64e+006\n'
-                        '5  1.70e+008\n6  1.2534560\n7  3.1415927\n'
-                        '8 -1.00e+006')
-        else:
-            expected = ('   x       \n0  0.000000\n1  0.250000\n'
-                        '2  3456.000\n3  1.20e+46\n4  1.64e+06\n'
-                        '5  1.70e+08\n6  1.253456\n7  3.141593\n'
-                        '8 -1.00e+06')
-        assert(df_s == expected)
-
-        df = DataFrame({'x' : [3234, 0.253]})
-        df_s = df.to_string()
-
-        expected = '   x    \n0  3234.\n1  0.253'
-        assert(df_s == expected)
-
-        com.reset_printoptions()
-        self.assertEqual(com.print_config.precision, 4)
-
-        df = DataFrame({'x': [1e9, 0.2512]})
-        df_s = df.to_string()
-        if sys.version_info[0] == 2 and sys.version_info[1] < 6:
-            expected = '   x     \n0  1e+009\n1  0.2512'
-        else:
-            expected = '   x     \n0  1.e+09\n1  0.2512'
-        assert(df_s == expected)
-
-    def test_to_string_right_justify_cols(self):
-        com.reset_printoptions()
-        df = DataFrame({'x' : [3234, 0.253]})
-        df_s = df.to_string(justify='right')
-        expected = '       x\n0  3234.\n1  0.253'
-        assert(df_s == expected)
-
-    def test_to_string_format_na(self):
-        com.reset_printoptions()
-        df = DataFrame({'A' : [np.nan, -1, -2.1234, 3, 4],
-                        'B' : [np.nan, 'foo', 'foooo', 'fooooo', 'bar']})
-        result = df.to_string()
-
-        expected = ('   A     B     \n'
-                    '0  NaN   NaN   \n'
-                    '1 -1.000 foo   \n'
-                    '2 -2.123 foooo \n'
-                    '3  3.000 fooooo\n'
-                    '4  4.000 bar   ')
-        self.assertEqual(result, expected)
-
-    def test_to_html(self):
-        # big mixed
-        biggie = DataFrame({'A' : randn(200),
-                            'B' : tm.makeStringIndex(200)},
-                            index=range(200))
-
-        biggie['A'][:20] = nan
-        biggie['B'][:20] = nan
-        s = biggie.to_html()
-
-        buf = StringIO()
-        retval = biggie.to_html(buf=buf)
-        self.assert_(retval is None)
-        self.assertEqual(buf.getvalue(), s)
-
-        self.assert_(isinstance(s, basestring))
-
-        biggie.to_html(columns=['B', 'A'], col_space=17)
-        biggie.to_html(columns=['B', 'A'],
-                       formatters={'A' : lambda x: '%.1f' % x})
-
-        biggie.to_html(columns=['B', 'A'], float_format=str)
-        biggie.to_html(columns=['B', 'A'], col_space=12,
-                       float_format=str)
-
-        frame = DataFrame(index=np.arange(200))
-        frame.to_html()
-
-    def test_to_html_with_no_bold(self):
-        x = DataFrame({'x': randn(5)})
-        ashtml = x.to_html(bold_rows=False)
-        assert('<strong>' not in ashtml)
-
     def test_insert(self):
         df = DataFrame(np.random.randn(5, 3), index=np.arange(5),
                        columns=['c', 'b', 'a'])

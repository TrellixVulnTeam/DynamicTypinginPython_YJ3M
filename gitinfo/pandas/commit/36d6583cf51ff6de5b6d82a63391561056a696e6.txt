commit 36d6583cf51ff6de5b6d82a63391561056a696e6
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sat Mar 28 20:24:35 2020 -0700

    REF: DataFrame delitem, take, pop, filter tests (#33109)

diff --git a/pandas/tests/frame/indexing/test_delitem.py b/pandas/tests/frame/indexing/test_delitem.py
new file mode 100644
index 000000000..f6c7b6ed5
--- /dev/null
+++ b/pandas/tests/frame/indexing/test_delitem.py
@@ -0,0 +1,57 @@
+import re
+
+import numpy as np
+import pytest
+
+from pandas import DataFrame, MultiIndex
+
+
+class TestDataFrameDelItem:
+    def test_delitem(self, float_frame):
+        del float_frame["A"]
+        assert "A" not in float_frame
+
+    def test_delitem_multiindex(self):
+        midx = MultiIndex.from_product([["A", "B"], [1, 2]])
+        df = DataFrame(np.random.randn(4, 4), columns=midx)
+        assert len(df.columns) == 4
+        assert ("A",) in df.columns
+        assert "A" in df.columns
+
+        result = df["A"]
+        assert isinstance(result, DataFrame)
+        del df["A"]
+
+        assert len(df.columns) == 2
+
+        # A still in the levels, BUT get a KeyError if trying
+        # to delete
+        assert ("A",) not in df.columns
+        with pytest.raises(KeyError, match=re.escape("('A',)")):
+            del df[("A",)]
+
+        # behavior of dropped/deleted MultiIndex levels changed from
+        # GH 2770 to GH 19027: MultiIndex no longer '.__contains__'
+        # levels which are dropped/deleted
+        assert "A" not in df.columns
+        with pytest.raises(KeyError, match=re.escape("('A',)")):
+            del df["A"]
+
+    def test_delitem_corner(self, float_frame):
+        f = float_frame.copy()
+        del f["D"]
+        assert len(f.columns) == 3
+        with pytest.raises(KeyError, match=r"^'D'$"):
+            del f["D"]
+        del f["B"]
+        assert len(f.columns) == 2
+
+    def test_delitem_col_still_multiindex(self):
+        arrays = [["a", "b", "c", "top"], ["", "", "", "OD"], ["", "", "", "wx"]]
+
+        tuples = sorted(zip(*arrays))
+        index = MultiIndex.from_tuples(tuples)
+
+        df = DataFrame(np.random.randn(3, 4), columns=index)
+        del df[("a", "", "")]
+        assert isinstance(df.columns, MultiIndex)
diff --git a/pandas/tests/frame/indexing/test_indexing.py b/pandas/tests/frame/indexing/test_indexing.py
index a7aacc9e0..4fa5e4196 100644
--- a/pandas/tests/frame/indexing/test_indexing.py
+++ b/pandas/tests/frame/indexing/test_indexing.py
@@ -854,15 +854,6 @@ class TestDataFrameIndexing:
         df2 = df[df > 0]
         tm.assert_frame_equal(df, df2)
 
-    def test_delitem_corner(self, float_frame):
-        f = float_frame.copy()
-        del f["D"]
-        assert len(f.columns) == 3
-        with pytest.raises(KeyError, match=r"^'D'$"):
-            del f["D"]
-        del f["B"]
-        assert len(f.columns) == 2
-
     def test_slice_floats(self):
         index = [52195.504153, 52196.303147, 52198.369883]
         df = DataFrame(np.random.rand(3, 2), index=index)
diff --git a/pandas/tests/frame/indexing/test_take.py b/pandas/tests/frame/indexing/test_take.py
new file mode 100644
index 000000000..3b59d3cf1
--- /dev/null
+++ b/pandas/tests/frame/indexing/test_take.py
@@ -0,0 +1,88 @@
+import pytest
+
+import pandas._testing as tm
+
+
+class TestDataFrameTake:
+    def test_take(self, float_frame):
+        # homogeneous
+        order = [3, 1, 2, 0]
+        for df in [float_frame]:
+
+            result = df.take(order, axis=0)
+            expected = df.reindex(df.index.take(order))
+            tm.assert_frame_equal(result, expected)
+
+            # axis = 1
+            result = df.take(order, axis=1)
+            expected = df.loc[:, ["D", "B", "C", "A"]]
+            tm.assert_frame_equal(result, expected, check_names=False)
+
+        # negative indices
+        order = [2, 1, -1]
+        for df in [float_frame]:
+
+            result = df.take(order, axis=0)
+            expected = df.reindex(df.index.take(order))
+            tm.assert_frame_equal(result, expected)
+
+            result = df.take(order, axis=0)
+            tm.assert_frame_equal(result, expected)
+
+            # axis = 1
+            result = df.take(order, axis=1)
+            expected = df.loc[:, ["C", "B", "D"]]
+            tm.assert_frame_equal(result, expected, check_names=False)
+
+        # illegal indices
+        msg = "indices are out-of-bounds"
+        with pytest.raises(IndexError, match=msg):
+            df.take([3, 1, 2, 30], axis=0)
+        with pytest.raises(IndexError, match=msg):
+            df.take([3, 1, 2, -31], axis=0)
+        with pytest.raises(IndexError, match=msg):
+            df.take([3, 1, 2, 5], axis=1)
+        with pytest.raises(IndexError, match=msg):
+            df.take([3, 1, 2, -5], axis=1)
+
+    def test_take_mixed_type(self, float_string_frame):
+
+        # mixed-dtype
+        order = [4, 1, 2, 0, 3]
+        for df in [float_string_frame]:
+
+            result = df.take(order, axis=0)
+            expected = df.reindex(df.index.take(order))
+            tm.assert_frame_equal(result, expected)
+
+            # axis = 1
+            result = df.take(order, axis=1)
+            expected = df.loc[:, ["foo", "B", "C", "A", "D"]]
+            tm.assert_frame_equal(result, expected)
+
+        # negative indices
+        order = [4, 1, -2]
+        for df in [float_string_frame]:
+
+            result = df.take(order, axis=0)
+            expected = df.reindex(df.index.take(order))
+            tm.assert_frame_equal(result, expected)
+
+            # axis = 1
+            result = df.take(order, axis=1)
+            expected = df.loc[:, ["foo", "B", "D"]]
+            tm.assert_frame_equal(result, expected)
+
+    def test_take_mixed_numeric(self, mixed_float_frame, mixed_int_frame):
+        # by dtype
+        order = [1, 2, 0, 3]
+        for df in [mixed_float_frame, mixed_int_frame]:
+
+            result = df.take(order, axis=0)
+            expected = df.reindex(df.index.take(order))
+            tm.assert_frame_equal(result, expected)
+
+            # axis = 1
+            result = df.take(order, axis=1)
+            expected = df.loc[:, ["B", "C", "A", "D"]]
+            tm.assert_frame_equal(result, expected)
diff --git a/pandas/tests/frame/methods/test_filter.py b/pandas/tests/frame/methods/test_filter.py
new file mode 100644
index 000000000..569b2fe21
--- /dev/null
+++ b/pandas/tests/frame/methods/test_filter.py
@@ -0,0 +1,139 @@
+import numpy as np
+import pytest
+
+import pandas as pd
+from pandas import DataFrame
+import pandas._testing as tm
+
+
+class TestDataFrameFilter:
+    def test_filter(self, float_frame, float_string_frame):
+        # Items
+        filtered = float_frame.filter(["A", "B", "E"])
+        assert len(filtered.columns) == 2
+        assert "E" not in filtered
+
+        filtered = float_frame.filter(["A", "B", "E"], axis="columns")
+        assert len(filtered.columns) == 2
+        assert "E" not in filtered
+
+        # Other axis
+        idx = float_frame.index[0:4]
+        filtered = float_frame.filter(idx, axis="index")
+        expected = float_frame.reindex(index=idx)
+        tm.assert_frame_equal(filtered, expected)
+
+        # like
+        fcopy = float_frame.copy()
+        fcopy["AA"] = 1
+
+        filtered = fcopy.filter(like="A")
+        assert len(filtered.columns) == 2
+        assert "AA" in filtered
+
+        # like with ints in column names
+        df = DataFrame(0.0, index=[0, 1, 2], columns=[0, 1, "_A", "_B"])
+        filtered = df.filter(like="_")
+        assert len(filtered.columns) == 2
+
+        # regex with ints in column names
+        # from PR #10384
+        df = DataFrame(0.0, index=[0, 1, 2], columns=["A1", 1, "B", 2, "C"])
+        expected = DataFrame(
+            0.0, index=[0, 1, 2], columns=pd.Index([1, 2], dtype=object)
+        )
+        filtered = df.filter(regex="^[0-9]+$")
+        tm.assert_frame_equal(filtered, expected)
+
+        expected = DataFrame(0.0, index=[0, 1, 2], columns=[0, "0", 1, "1"])
+        # shouldn't remove anything
+        filtered = expected.filter(regex="^[0-9]+$")
+        tm.assert_frame_equal(filtered, expected)
+
+        # pass in None
+        with pytest.raises(TypeError, match="Must pass"):
+            float_frame.filter()
+        with pytest.raises(TypeError, match="Must pass"):
+            float_frame.filter(items=None)
+        with pytest.raises(TypeError, match="Must pass"):
+            float_frame.filter(axis=1)
+
+        # test mutually exclusive arguments
+        with pytest.raises(TypeError, match="mutually exclusive"):
+            float_frame.filter(items=["one", "three"], regex="e$", like="bbi")
+        with pytest.raises(TypeError, match="mutually exclusive"):
+            float_frame.filter(items=["one", "three"], regex="e$", axis=1)
+        with pytest.raises(TypeError, match="mutually exclusive"):
+            float_frame.filter(items=["one", "three"], regex="e$")
+        with pytest.raises(TypeError, match="mutually exclusive"):
+            float_frame.filter(items=["one", "three"], like="bbi", axis=0)
+        with pytest.raises(TypeError, match="mutually exclusive"):
+            float_frame.filter(items=["one", "three"], like="bbi")
+
+        # objects
+        filtered = float_string_frame.filter(like="foo")
+        assert "foo" in filtered
+
+        # unicode columns, won't ascii-encode
+        df = float_frame.rename(columns={"B": "\u2202"})
+        filtered = df.filter(like="C")
+        assert "C" in filtered
+
+    def test_filter_regex_search(self, float_frame):
+        fcopy = float_frame.copy()
+        fcopy["AA"] = 1
+
+        # regex
+        filtered = fcopy.filter(regex="[A]+")
+        assert len(filtered.columns) == 2
+        assert "AA" in filtered
+
+        # doesn't have to be at beginning
+        df = DataFrame(
+            {"aBBa": [1, 2], "BBaBB": [1, 2], "aCCa": [1, 2], "aCCaBB": [1, 2]}
+        )
+
+        result = df.filter(regex="BB")
+        exp = df[[x for x in df.columns if "BB" in x]]
+        tm.assert_frame_equal(result, exp)
+
+    @pytest.mark.parametrize(
+        "name,expected",
+        [
+            ("a", DataFrame({"a": [1, 2]})),
+            ("a", DataFrame({"a": [1, 2]})),
+            ("あ", DataFrame({"あ": [3, 4]})),
+        ],
+    )
+    def test_filter_unicode(self, name, expected):
+        # GH13101
+        df = DataFrame({"a": [1, 2], "あ": [3, 4]})
+
+        tm.assert_frame_equal(df.filter(like=name), expected)
+        tm.assert_frame_equal(df.filter(regex=name), expected)
+
+    @pytest.mark.parametrize("name", ["a", "a"])
+    def test_filter_bytestring(self, name):
+        # GH13101
+        df = DataFrame({b"a": [1, 2], b"b": [3, 4]})
+        expected = DataFrame({b"a": [1, 2]})
+
+        tm.assert_frame_equal(df.filter(like=name), expected)
+        tm.assert_frame_equal(df.filter(regex=name), expected)
+
+    def test_filter_corner(self):
+        empty = DataFrame()
+
+        result = empty.filter([])
+        tm.assert_frame_equal(result, empty)
+
+        result = empty.filter(like="foo")
+        tm.assert_frame_equal(result, empty)
+
+    def test_filter_regex_non_string(self):
+        # GH#5798 trying to filter on non-string columns should drop,
+        #  not raise
+        df = pd.DataFrame(np.random.random((3, 2)), columns=["STRING", 123])
+        result = df.filter(regex="STRING")
+        expected = df[["STRING"]]
+        tm.assert_frame_equal(result, expected)
diff --git a/pandas/tests/frame/methods/test_pop.py b/pandas/tests/frame/methods/test_pop.py
new file mode 100644
index 000000000..fccb3f10d
--- /dev/null
+++ b/pandas/tests/frame/methods/test_pop.py
@@ -0,0 +1,40 @@
+from pandas import DataFrame, Series
+import pandas._testing as tm
+
+
+class TestDataFramePop:
+    def test_pop(self, float_frame):
+        float_frame.columns.name = "baz"
+
+        float_frame.pop("A")
+        assert "A" not in float_frame
+
+        float_frame["foo"] = "bar"
+        float_frame.pop("foo")
+        assert "foo" not in float_frame
+        assert float_frame.columns.name == "baz"
+
+        # gh-10912: inplace ops cause caching issue
+        a = DataFrame([[1, 2, 3], [4, 5, 6]], columns=["A", "B", "C"], index=["X", "Y"])
+        b = a.pop("B")
+        b += 1
+
+        # original frame
+        expected = DataFrame([[1, 3], [4, 6]], columns=["A", "C"], index=["X", "Y"])
+        tm.assert_frame_equal(a, expected)
+
+        # result
+        expected = Series([2, 5], index=["X", "Y"], name="B") + 1
+        tm.assert_series_equal(b, expected)
+
+    def test_pop_non_unique_cols(self):
+        df = DataFrame({0: [0, 1], 1: [0, 1], 2: [4, 5]})
+        df.columns = ["a", "b", "a"]
+
+        res = df.pop("a")
+        assert type(res) == DataFrame
+        assert len(res) == 2
+        assert len(df.columns) == 1
+        assert "b" in df.columns
+        assert "a" not in df.columns
+        assert len(df.index) == 2
diff --git a/pandas/tests/frame/test_axis_select_reindex.py b/pandas/tests/frame/test_axis_select_reindex.py
index d1d55d38f..42fb722c9 100644
--- a/pandas/tests/frame/test_axis_select_reindex.py
+++ b/pandas/tests/frame/test_axis_select_reindex.py
@@ -12,16 +12,6 @@ class TestDataFrameSelectReindex:
     # These are specific reindex-based tests; other indexing tests should go in
     # test_indexing
 
-    def test_delitem_col_still_multiindex(self):
-        arrays = [["a", "b", "c", "top"], ["", "", "", "OD"], ["", "", "", "wx"]]
-
-        tuples = sorted(zip(*arrays))
-        index = MultiIndex.from_tuples(tuples)
-
-        df = DataFrame(np.random.randn(3, 4), columns=index)
-        del df[("a", "", "")]
-        assert isinstance(df.columns, MultiIndex)
-
     def test_merge_join_different_levels(self):
         # GH 9455
 
@@ -410,220 +400,6 @@ class TestDataFrameSelectReindex:
         expected = df2 - df2.mean()
         tm.assert_frame_equal(result, expected)
 
-    def test_filter(self, float_frame, float_string_frame):
-        # Items
-        filtered = float_frame.filter(["A", "B", "E"])
-        assert len(filtered.columns) == 2
-        assert "E" not in filtered
-
-        filtered = float_frame.filter(["A", "B", "E"], axis="columns")
-        assert len(filtered.columns) == 2
-        assert "E" not in filtered
-
-        # Other axis
-        idx = float_frame.index[0:4]
-        filtered = float_frame.filter(idx, axis="index")
-        expected = float_frame.reindex(index=idx)
-        tm.assert_frame_equal(filtered, expected)
-
-        # like
-        fcopy = float_frame.copy()
-        fcopy["AA"] = 1
-
-        filtered = fcopy.filter(like="A")
-        assert len(filtered.columns) == 2
-        assert "AA" in filtered
-
-        # like with ints in column names
-        df = DataFrame(0.0, index=[0, 1, 2], columns=[0, 1, "_A", "_B"])
-        filtered = df.filter(like="_")
-        assert len(filtered.columns) == 2
-
-        # regex with ints in column names
-        # from PR #10384
-        df = DataFrame(0.0, index=[0, 1, 2], columns=["A1", 1, "B", 2, "C"])
-        expected = DataFrame(
-            0.0, index=[0, 1, 2], columns=pd.Index([1, 2], dtype=object)
-        )
-        filtered = df.filter(regex="^[0-9]+$")
-        tm.assert_frame_equal(filtered, expected)
-
-        expected = DataFrame(0.0, index=[0, 1, 2], columns=[0, "0", 1, "1"])
-        # shouldn't remove anything
-        filtered = expected.filter(regex="^[0-9]+$")
-        tm.assert_frame_equal(filtered, expected)
-
-        # pass in None
-        with pytest.raises(TypeError, match="Must pass"):
-            float_frame.filter()
-        with pytest.raises(TypeError, match="Must pass"):
-            float_frame.filter(items=None)
-        with pytest.raises(TypeError, match="Must pass"):
-            float_frame.filter(axis=1)
-
-        # test mutually exclusive arguments
-        with pytest.raises(TypeError, match="mutually exclusive"):
-            float_frame.filter(items=["one", "three"], regex="e$", like="bbi")
-        with pytest.raises(TypeError, match="mutually exclusive"):
-            float_frame.filter(items=["one", "three"], regex="e$", axis=1)
-        with pytest.raises(TypeError, match="mutually exclusive"):
-            float_frame.filter(items=["one", "three"], regex="e$")
-        with pytest.raises(TypeError, match="mutually exclusive"):
-            float_frame.filter(items=["one", "three"], like="bbi", axis=0)
-        with pytest.raises(TypeError, match="mutually exclusive"):
-            float_frame.filter(items=["one", "three"], like="bbi")
-
-        # objects
-        filtered = float_string_frame.filter(like="foo")
-        assert "foo" in filtered
-
-        # unicode columns, won't ascii-encode
-        df = float_frame.rename(columns={"B": "\u2202"})
-        filtered = df.filter(like="C")
-        assert "C" in filtered
-
-    def test_filter_regex_search(self, float_frame):
-        fcopy = float_frame.copy()
-        fcopy["AA"] = 1
-
-        # regex
-        filtered = fcopy.filter(regex="[A]+")
-        assert len(filtered.columns) == 2
-        assert "AA" in filtered
-
-        # doesn't have to be at beginning
-        df = DataFrame(
-            {"aBBa": [1, 2], "BBaBB": [1, 2], "aCCa": [1, 2], "aCCaBB": [1, 2]}
-        )
-
-        result = df.filter(regex="BB")
-        exp = df[[x for x in df.columns if "BB" in x]]
-        tm.assert_frame_equal(result, exp)
-
-    @pytest.mark.parametrize(
-        "name,expected",
-        [
-            ("a", DataFrame({"a": [1, 2]})),
-            ("a", DataFrame({"a": [1, 2]})),
-            ("あ", DataFrame({"あ": [3, 4]})),
-        ],
-    )
-    def test_filter_unicode(self, name, expected):
-        # GH13101
-        df = DataFrame({"a": [1, 2], "あ": [3, 4]})
-
-        tm.assert_frame_equal(df.filter(like=name), expected)
-        tm.assert_frame_equal(df.filter(regex=name), expected)
-
-    @pytest.mark.parametrize("name", ["a", "a"])
-    def test_filter_bytestring(self, name):
-        # GH13101
-        df = DataFrame({b"a": [1, 2], b"b": [3, 4]})
-        expected = DataFrame({b"a": [1, 2]})
-
-        tm.assert_frame_equal(df.filter(like=name), expected)
-        tm.assert_frame_equal(df.filter(regex=name), expected)
-
-    def test_filter_corner(self):
-        empty = DataFrame()
-
-        result = empty.filter([])
-        tm.assert_frame_equal(result, empty)
-
-        result = empty.filter(like="foo")
-        tm.assert_frame_equal(result, empty)
-
-    def test_filter_regex_non_string(self):
-        # GH#5798 trying to filter on non-string columns should drop,
-        #  not raise
-        df = pd.DataFrame(np.random.random((3, 2)), columns=["STRING", 123])
-        result = df.filter(regex="STRING")
-        expected = df[["STRING"]]
-        tm.assert_frame_equal(result, expected)
-
-    def test_take(self, float_frame):
-        # homogeneous
-        order = [3, 1, 2, 0]
-        for df in [float_frame]:
-
-            result = df.take(order, axis=0)
-            expected = df.reindex(df.index.take(order))
-            tm.assert_frame_equal(result, expected)
-
-            # axis = 1
-            result = df.take(order, axis=1)
-            expected = df.loc[:, ["D", "B", "C", "A"]]
-            tm.assert_frame_equal(result, expected, check_names=False)
-
-        # negative indices
-        order = [2, 1, -1]
-        for df in [float_frame]:
-
-            result = df.take(order, axis=0)
-            expected = df.reindex(df.index.take(order))
-            tm.assert_frame_equal(result, expected)
-
-            result = df.take(order, axis=0)
-            tm.assert_frame_equal(result, expected)
-
-            # axis = 1
-            result = df.take(order, axis=1)
-            expected = df.loc[:, ["C", "B", "D"]]
-            tm.assert_frame_equal(result, expected, check_names=False)
-
-        # illegal indices
-        msg = "indices are out-of-bounds"
-        with pytest.raises(IndexError, match=msg):
-            df.take([3, 1, 2, 30], axis=0)
-        with pytest.raises(IndexError, match=msg):
-            df.take([3, 1, 2, -31], axis=0)
-        with pytest.raises(IndexError, match=msg):
-            df.take([3, 1, 2, 5], axis=1)
-        with pytest.raises(IndexError, match=msg):
-            df.take([3, 1, 2, -5], axis=1)
-
-    def test_take_mixed_type(self, float_string_frame):
-
-        # mixed-dtype
-        order = [4, 1, 2, 0, 3]
-        for df in [float_string_frame]:
-
-            result = df.take(order, axis=0)
-            expected = df.reindex(df.index.take(order))
-            tm.assert_frame_equal(result, expected)
-
-            # axis = 1
-            result = df.take(order, axis=1)
-            expected = df.loc[:, ["foo", "B", "C", "A", "D"]]
-            tm.assert_frame_equal(result, expected)
-
-        # negative indices
-        order = [4, 1, -2]
-        for df in [float_string_frame]:
-
-            result = df.take(order, axis=0)
-            expected = df.reindex(df.index.take(order))
-            tm.assert_frame_equal(result, expected)
-
-            # axis = 1
-            result = df.take(order, axis=1)
-            expected = df.loc[:, ["foo", "B", "D"]]
-            tm.assert_frame_equal(result, expected)
-
-    def test_take_mixed_numeric(self, mixed_float_frame, mixed_int_frame):
-        # by dtype
-        order = [1, 2, 0, 3]
-        for df in [mixed_float_frame, mixed_int_frame]:
-
-            result = df.take(order, axis=0)
-            expected = df.reindex(df.index.take(order))
-            tm.assert_frame_equal(result, expected)
-
-            # axis = 1
-            result = df.take(order, axis=1)
-            expected = df.loc[:, ["B", "C", "A", "D"]]
-            tm.assert_frame_equal(result, expected)
-
     def test_reindex_boolean(self):
         frame = DataFrame(
             np.ones((10, 2), dtype=bool), index=np.arange(0, 20, 2), columns=[0, 2]
diff --git a/pandas/tests/frame/test_mutate_columns.py b/pandas/tests/frame/test_mutate_columns.py
index 9d1b6abff..e3f2a67c2 100644
--- a/pandas/tests/frame/test_mutate_columns.py
+++ b/pandas/tests/frame/test_mutate_columns.py
@@ -1,9 +1,7 @@
-import re
-
 import numpy as np
 import pytest
 
-from pandas import DataFrame, MultiIndex, Series
+from pandas import DataFrame, Series
 import pandas._testing as tm
 
 # Column add, remove, delete.
@@ -83,69 +81,3 @@ class TestDataFrameMutateColumns:
         df["X"] = ["x", "y", "z"]
         exp = DataFrame(data={"X": ["x", "y", "z"]}, index=["A", "B", "C"])
         tm.assert_frame_equal(df, exp)
-
-    def test_delitem(self, float_frame):
-        del float_frame["A"]
-        assert "A" not in float_frame
-
-    def test_delitem_multiindex(self):
-        midx = MultiIndex.from_product([["A", "B"], [1, 2]])
-        df = DataFrame(np.random.randn(4, 4), columns=midx)
-        assert len(df.columns) == 4
-        assert ("A",) in df.columns
-        assert "A" in df.columns
-
-        result = df["A"]
-        assert isinstance(result, DataFrame)
-        del df["A"]
-
-        assert len(df.columns) == 2
-
-        # A still in the levels, BUT get a KeyError if trying
-        # to delete
-        assert ("A",) not in df.columns
-        with pytest.raises(KeyError, match=re.escape("('A',)")):
-            del df[("A",)]
-
-        # behavior of dropped/deleted MultiIndex levels changed from
-        # GH 2770 to GH 19027: MultiIndex no longer '.__contains__'
-        # levels which are dropped/deleted
-        assert "A" not in df.columns
-        with pytest.raises(KeyError, match=re.escape("('A',)")):
-            del df["A"]
-
-    def test_pop(self, float_frame):
-        float_frame.columns.name = "baz"
-
-        float_frame.pop("A")
-        assert "A" not in float_frame
-
-        float_frame["foo"] = "bar"
-        float_frame.pop("foo")
-        assert "foo" not in float_frame
-        assert float_frame.columns.name == "baz"
-
-        # gh-10912: inplace ops cause caching issue
-        a = DataFrame([[1, 2, 3], [4, 5, 6]], columns=["A", "B", "C"], index=["X", "Y"])
-        b = a.pop("B")
-        b += 1
-
-        # original frame
-        expected = DataFrame([[1, 3], [4, 6]], columns=["A", "C"], index=["X", "Y"])
-        tm.assert_frame_equal(a, expected)
-
-        # result
-        expected = Series([2, 5], index=["X", "Y"], name="B") + 1
-        tm.assert_series_equal(b, expected)
-
-    def test_pop_non_unique_cols(self):
-        df = DataFrame({0: [0, 1], 1: [0, 1], 2: [4, 5]})
-        df.columns = ["a", "b", "a"]
-
-        res = df.pop("a")
-        assert type(res) == DataFrame
-        assert len(res) == 2
-        assert len(df.columns) == 1
-        assert "b" in df.columns
-        assert "a" not in df.columns
-        assert len(df.index) == 2
diff --git a/pandas/tests/series/indexing/test_delitem.py b/pandas/tests/series/indexing/test_delitem.py
new file mode 100644
index 000000000..6c7e3f2b0
--- /dev/null
+++ b/pandas/tests/series/indexing/test_delitem.py
@@ -0,0 +1,49 @@
+import pytest
+
+from pandas import Index, Series
+import pandas._testing as tm
+
+
+class TestSeriesDelItem:
+    def test_delitem(self):
+        # GH#5542
+        # should delete the item inplace
+        s = Series(range(5))
+        del s[0]
+
+        expected = Series(range(1, 5), index=range(1, 5))
+        tm.assert_series_equal(s, expected)
+
+        del s[1]
+        expected = Series(range(2, 5), index=range(2, 5))
+        tm.assert_series_equal(s, expected)
+
+        # only 1 left, del, add, del
+        s = Series(1)
+        del s[0]
+        tm.assert_series_equal(s, Series(dtype="int64", index=Index([], dtype="int64")))
+        s[0] = 1
+        tm.assert_series_equal(s, Series(1))
+        del s[0]
+        tm.assert_series_equal(s, Series(dtype="int64", index=Index([], dtype="int64")))
+
+    def test_delitem_object_index(self):
+        # Index(dtype=object)
+        s = Series(1, index=["a"])
+        del s["a"]
+        tm.assert_series_equal(
+            s, Series(dtype="int64", index=Index([], dtype="object"))
+        )
+        s["a"] = 1
+        tm.assert_series_equal(s, Series(1, index=["a"]))
+        del s["a"]
+        tm.assert_series_equal(
+            s, Series(dtype="int64", index=Index([], dtype="object"))
+        )
+
+    def test_delitem_missing_key(self):
+        # empty
+        s = Series(dtype=object)
+
+        with pytest.raises(KeyError, match=r"^0$"):
+            del s[0]
diff --git a/pandas/tests/series/indexing/test_numeric.py b/pandas/tests/series/indexing/test_numeric.py
index 7e73e6366..5a648cc58 100644
--- a/pandas/tests/series/indexing/test_numeric.py
+++ b/pandas/tests/series/indexing/test_numeric.py
@@ -5,44 +5,6 @@ from pandas import DataFrame, Index, Series
 import pandas._testing as tm
 
 
-def test_delitem():
-    # GH 5542
-    # should delete the item inplace
-    s = Series(range(5))
-    del s[0]
-
-    expected = Series(range(1, 5), index=range(1, 5))
-    tm.assert_series_equal(s, expected)
-
-    del s[1]
-    expected = Series(range(2, 5), index=range(2, 5))
-    tm.assert_series_equal(s, expected)
-
-    # empty
-    s = Series(dtype=object)
-
-    with pytest.raises(KeyError, match=r"^0$"):
-        del s[0]
-
-    # only 1 left, del, add, del
-    s = Series(1)
-    del s[0]
-    tm.assert_series_equal(s, Series(dtype="int64", index=Index([], dtype="int64")))
-    s[0] = 1
-    tm.assert_series_equal(s, Series(1))
-    del s[0]
-    tm.assert_series_equal(s, Series(dtype="int64", index=Index([], dtype="int64")))
-
-    # Index(dtype=object)
-    s = Series(1, index=["a"])
-    del s["a"]
-    tm.assert_series_equal(s, Series(dtype="int64", index=Index([], dtype="object")))
-    s["a"] = 1
-    tm.assert_series_equal(s, Series(1, index=["a"]))
-    del s["a"]
-    tm.assert_series_equal(s, Series(dtype="int64", index=Index([], dtype="object")))
-
-
 def test_slice_float64():
     values = np.arange(10.0, 50.0, 2)
     index = Index(values)

commit bac78176ea6efb8399d913608cd4ab3e90de6f00
Author: jreback <jeff@reback.net>
Date:   Mon Jul 29 22:53:07 2013 -0400

    BLD: py3 compat
    TST: removed pytest in favor of nosetest for tests/test_msgpack

diff --git a/doc/source/io.rst b/doc/source/io.rst
index 67ed21112..41a29e7a4 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -36,7 +36,7 @@ object.
     * ``read_hdf``
     * ``read_sql``
     * ``read_json``
-    * ``read_msgpack``
+    * ``read_msgpack`` (experimental)
     * ``read_html``
     * ``read_stata``
     * ``read_clipboard``
@@ -49,7 +49,7 @@ The corresponding ``writer`` functions are object methods that are accessed like
     * ``to_hdf``
     * ``to_sql``
     * ``to_json``
-    * ``to_msgpack``
+    * ``to_msgpack`` (experimental)
     * ``to_html``
     * ``to_stata``
     * ``to_clipboard``
@@ -1737,23 +1737,23 @@ module is installed you can use it as a xlsx writer engine as follows:
 Serialization
 -------------
 
-msgpack
-~~~~~~~
+msgpack (experimental)
+~~~~~~~~~~~~~~~~~~~~~~
 
 .. _io.msgpack:
 
-.. versionadded:: 0.11.1
+.. versionadded:: 0.13.0
 
-Starting in 0.11.1, pandas is supporting the ``msgpack`` format for 
+Starting in 0.13.0, pandas is supporting the ``msgpack`` format for
 object serialization. This is a lightweight portable binary format, similar
-to binary JSON, that is highly space efficient, and provides good performance 
+to binary JSON, that is highly space efficient, and provides good performance
 both on the writing (serialization), and reading (deserialization).
 
 .. warning::
 
-   This is a very new feature of pandas. We intend to provide certain 
+   This is a very new feature of pandas. We intend to provide certain
    optimizations in the io of the ``msgpack`` data. We do not intend this
-   format to change (and will be backward compatible if we do).
+   format to change (however it is experimental)
 
 .. ipython:: python
 
diff --git a/doc/source/v0.13.0.txt b/doc/source/v0.13.0.txt
index 9ee1ce12e..a21f4a318 100644
--- a/doc/source/v0.13.0.txt
+++ b/doc/source/v0.13.0.txt
@@ -464,6 +464,15 @@ Enhancements
         t = Timestamp('20130101 09:01:02')
         t + pd.datetools.Nano(123)
 
+  - The ``isin`` method plays nicely with boolean indexing. To get the rows where each condition is met:
+
+      .. ipython:: python
+
+         mask = df.isin({'A': [1, 2], 'B': ['e', 'f']})
+         df[mask.all(1)]
+
+      See the :ref:`documentation<indexing.basics.indexing_isin>` for more.
+
 .. _whatsnew_0130.experimental:
 
 Experimental
@@ -553,21 +562,35 @@ Experimental
     For more details see the :ref:`indexing documentation on query
     <indexing.query>`.
 
-  - DataFrame now has an ``isin`` method that can be used to easily check whether the DataFrame's values are contained in an iterable.  Use a dictionary if you'd like to check specific iterables for specific columns or rows.
+- ``pd.read_msgpack()`` and ``pd.to_msgpack()`` are now a supported method of serialization
+  of arbitrary pandas (and python objects) in a lightweight portable binary format. :ref:`See the docs<io.msgpack>`
 
-    .. ipython:: python
+  .. warning::
 
-      df = pd.DataFrame({'A': [1, 2, 3], 'B': ['d', 'e', 'f']})
-      df.isin({'A': [1, 2], 'B': ['e', 'f']})
+     Since this is EXPERIMENTAL LIBRARY, the storage format may not be stable until a future release.
 
-  The ``isin`` method plays nicely with boolean indexing. To get the rows where each condition is met:
+  .. ipython:: python
 
-    .. ipython:: python
+     df = DataFrame(np.random.rand(5,2),columns=list('AB'))
+     df.to_msgpack('foo.msg')
+     pd.read_msgpack('foo.msg')
+
+     s = Series(np.random.rand(5),index=date_range('20130101',periods=5))
+     pd.to_msgpack('foo.msg', df, s)
+     pd.read_msgpack('foo.msg')
+
+  You can pass ``iterator=True`` to iterator over the unpacked results
 
-      mask = df.isin({'A': [1, 2], 'B': ['e', 'f']})
-      df[mask.all(1)]
+  .. ipython:: python
+
+     for o in pd.read_msgpack('foo.msg',iterator=True):
+        print o
+
+  .. ipython:: python
+     :suppress:
+     :okexcept:
 
-  See the :ref:`documentation<indexing.basics.indexing_isin>` for more.
+     os.remove('foo.msg')
 
 .. _whatsnew_0130.refactoring:
 
@@ -686,35 +709,6 @@ to unify methods and behaviors. Series formerly subclassed directly from
      s.a = 5
      s
 
-IO Enhancements
-~~~~~~~~~~~~~~~
-
-- ``pd.read_msgpack()`` and ``pd.to_msgpack()`` are now a supported method of serialization
-  of arbitrary pandas (and python objects) in a lightweight portable binary format. :ref:`See the docs<io.msgpack>`
-
-  .. ipython:: python
-
-        df = DataFrame(np.random.rand(5,2),columns=list('AB'))
-        df.to_msgpack('foo.msg')
-        pd.read_msgpack('foo.msg')
-
-        s = Series(np.random.rand(5),index=date_range('20130101',periods=5))
-        pd.to_msgpack('foo.msg', df, s)
-        pd.read_msgpack('foo.msg')
-
-  You can pass ``iterator=True`` to iterator over the unpacked results
-
-  .. ipython:: python
-
-        for o in pd.read_msgpack('foo.msg',iterator=True):
-            print o
-
-  .. ipython:: python
-        :suppress:
-        :okexcept:
-
-        os.remove('foo.msg')
-
 Bug Fixes
 ~~~~~~~~~
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index e96d159c2..3142f74f2 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -806,6 +806,21 @@ class NDFrame(PandasObject):
         return pytables.to_hdf(path_or_buf, key, self, **kwargs)
 
     def to_msgpack(self, path_or_buf, **kwargs):
+        """
+        msgpack (serialize) object to input file path
+
+        THIS IS AN EXPERIMENTAL LIBRARY and the storage format
+        may not be stable until a future release.
+
+        Parameters
+        ----------
+        path : string File path
+        args : an object or objects to serialize
+        append : boolean whether to append to an existing msgpack
+                (default is False)
+        compress : type of compressor (zlib or blosc), default to None (no compression)
+        """
+
         from pandas.io import packers
         return packers.to_msgpack(path_or_buf, self, **kwargs)
 
diff --git a/pandas/io/packers.py b/pandas/io/packers.py
index 68d1563d3..34ffc0ae5 100644
--- a/pandas/io/packers.py
+++ b/pandas/io/packers.py
@@ -49,9 +49,11 @@ import warnings
 from dateutil.parser import parse
 
 import numpy as np
+from pandas import compat
+from pandas.compat import u
 from pandas import (
     Timestamp, Period, Series, TimeSeries, DataFrame, Panel, Panel4D,
-    Index, MultiIndex, Int64Index, PeriodIndex, DatetimeIndex, NaT
+    Index, MultiIndex, Int64Index, PeriodIndex, DatetimeIndex, Float64Index, NaT
 )
 from pandas.sparse.api import SparseSeries, SparseDataFrame, SparsePanel
 from pandas.sparse.array import BlockIndex, IntIndex
@@ -80,12 +82,13 @@ def to_msgpack(path, *args, **kwargs):
     """
     msgpack (serialize) object to input file path
 
+    THIS IS AN EXPERIMENTAL LIBRARY and the storage format
+    may not be stable until a future release.
+
     Parameters
     ----------
-    path : string
-        File path
+    path : string File path
     args : an object or objects to serialize
-
     append : boolean whether to append to an existing msgpack
              (default is False)
     compress : type of compressor (zlib or blosc), default to None (no compression)
@@ -112,6 +115,9 @@ def read_msgpack(path, iterator=False, **kwargs):
     Load msgpack pandas object from the specified
     file path
 
+    THIS IS AN EXPERIMENTAL LIBRARY and the storage format
+    may not be stable until a future release.
+
     Parameters
     ----------
     path : string
@@ -134,11 +140,11 @@ def read_msgpack(path, iterator=False, **kwargs):
         return l
 
 dtype_dict = { 21 : np.dtype('M8[ns]'),
-               u'datetime64[ns]' : np.dtype('M8[ns]'),
-               u'datetime64[us]' : np.dtype('M8[us]'),
+               u('datetime64[ns]') : np.dtype('M8[ns]'),
+               u('datetime64[us]') : np.dtype('M8[us]'),
                22 : np.dtype('m8[ns]'),
-               u'timedelta64[ns]' : np.dtype('m8[ns]'),
-               u'timedelta64[us]' : np.dtype('m8[us]') }
+               u('timedelta64[ns]') : np.dtype('m8[ns]'),
+               u('timedelta64[us]') : np.dtype('m8[us]') }
 
 def dtype_for(t):
     if t in dtype_dict:
@@ -157,7 +163,7 @@ def c2f(r, i, ctype_name):
     """
     Convert strings to complex number instance with specified numpy type.
     """
-    
+
     ftype = c2f_dict[ctype_name]
     return np.typeDict[ctype_name](ftype(r)+1j*ftype(i))
 
@@ -224,7 +230,7 @@ def encode(obj):
     """
     Data encoder
     """
-        
+
     tobj = type(obj)
     if isinstance(obj, Index):
         if isinstance(obj, PeriodIndex):
@@ -281,7 +287,7 @@ def encode(obj):
                  'columns' : obj.columns }
             for f in ['default_fill_value','default_kind']:
                 d[f] = getattr(obj,f,None)
-            d['data'] = dict([ (name,ss) for name,ss in obj.iterkv() ])
+            d['data'] = dict([ (name,ss) for name,ss in compat.iteritems(obj) ])
             return d
         elif isinstance(obj, SparsePanel):
             d = {'typ' : 'sparse_panel',
@@ -289,7 +295,7 @@ def encode(obj):
                  'items' : obj.items }
             for f in ['default_fill_value','default_kind']:
                 d[f] = getattr(obj,f,None)
-            d['data'] = dict([ (name,df) for name,df in obj.iterkv() ])
+            d['data'] = dict([ (name,df) for name,df in compat.iteritems(obj) ])
             return d
         else:
 
@@ -301,8 +307,8 @@ def encode(obj):
             return {'typ' : 'block_manager',
                     'klass'  : obj.__class__.__name__,
                     'axes'   : data.axes,
-                    'blocks' : [ { 'items'  : b.items, 
-                                   'values' : convert(b.values), 
+                    'blocks' : [ { 'items'  : b.items,
+                                   'values' : convert(b.values),
                                    'shape'  : b.values.shape,
                                    'dtype'  : b.dtype.num,
                                    'klass' : b.__class__.__name__,
@@ -381,7 +387,7 @@ def decode(obj):
     """
     Decoder for deserializing numpy data types.
     """
-    
+
     typ = obj.get('typ')
     if typ is None:
         return obj
@@ -408,7 +414,7 @@ def decode(obj):
 
         def create_block(b):
             dtype = dtype_for(b['dtype'])
-            return make_block(unconvert(b['values'],dtype,b['compress']).reshape(b['shape']),b['items'],axes[0],klass=getattr(internals,b['klass'])) 
+            return make_block(unconvert(b['values'],dtype,b['compress']).reshape(b['shape']),b['items'],axes[0],klass=getattr(internals,b['klass']))
 
         blocks = [ create_block(b) for b in obj['blocks'] ]
         return globals()[obj['klass']](BlockManager(blocks, axes))
@@ -454,17 +460,17 @@ def decode(obj):
     else:
         return obj
 
-def pack(o, default=encode, 
+def pack(o, default=encode,
          encoding='utf-8', unicode_errors='strict', use_single_float=False):
     """
     Pack an object and return the packed bytes.
     """
 
     return Packer(default=default, encoding=encoding,
-           unicode_errors=unicode_errors, 
+           unicode_errors=unicode_errors,
            use_single_float=use_single_float).pack(o)
 
-def unpack(packed, object_hook=decode, 
+def unpack(packed, object_hook=decode,
            list_hook=None, use_list=False, encoding='utf-8',
            unicode_errors='strict', object_pairs_hook=None):
     """
@@ -473,17 +479,17 @@ def unpack(packed, object_hook=decode,
     """
 
     return Unpacker(packed, object_hook=object_hook,
-                    list_hook=list_hook, 
+                    list_hook=list_hook,
                     use_list=use_list, encoding=encoding,
-                    unicode_errors=unicode_errors, 
+                    unicode_errors=unicode_errors,
                     object_pairs_hook=object_pairs_hook)
 
 class Packer(_Packer):
-    def __init__(self, default=encode, 
+    def __init__(self, default=encode,
                  encoding='utf-8',
                  unicode_errors='strict',
                  use_single_float=False):
-        super(Packer, self).__init__(default=default, 
+        super(Packer, self).__init__(default=default,
                                      encoding=encoding,
                                      unicode_errors=unicode_errors,
                                      use_single_float=use_single_float)
@@ -493,14 +499,14 @@ class Unpacker(_Unpacker):
                  object_hook=decode,
                  object_pairs_hook=None, list_hook=None, encoding='utf-8',
                  unicode_errors='strict', max_buffer_size=0):
-        super(Unpacker, self).__init__(file_like=file_like, 
-                                       read_size=read_size,    
-                                       use_list=use_list, 
-                                       object_hook=object_hook, 
-                                       object_pairs_hook=object_pairs_hook, 
+        super(Unpacker, self).__init__(file_like=file_like,
+                                       read_size=read_size,
+                                       use_list=use_list,
+                                       object_hook=object_hook,
+                                       object_pairs_hook=object_pairs_hook,
                                        list_hook=list_hook,
-                                       encoding=encoding, 
-                                       unicode_errors=unicode_errors, 
+                                       encoding=encoding,
+                                       unicode_errors=unicode_errors,
                                        max_buffer_size=max_buffer_size)
 
 class Iterator(object):
diff --git a/pandas/io/tests/test_packers.py b/pandas/io/tests/test_packers.py
index 7575c1e31..f8325ef6d 100644
--- a/pandas/io/tests/test_packers.py
+++ b/pandas/io/tests/test_packers.py
@@ -7,6 +7,8 @@ import warnings
 import datetime
 import numpy as np
 
+from pandas import compat
+from pandas.compat import u
 from pandas import (Series, DataFrame, Panel, MultiIndex, bdate_range,
                     date_range, period_range, Index, SparseSeries, SparseDataFrame,
                     SparsePanel)
@@ -146,7 +148,7 @@ class TestNumpy(Test):
                        x.dtype == x_rec.dtype)
 
     def test_list_mixed(self):
-        x = [1.0, np.float32(3.5), np.complex128(4.25), u'foo']
+        x = [1.0, np.float32(3.5), np.complex128(4.25), u('foo')]
         x_rec = self.encode_decode(x)
         self.assert_(all(map(lambda x,y: x == y, x, x_rec)) and \
                            all(map(lambda x,y: type(x) == type(y), x, x_rec)))
diff --git a/pandas/msgpack.pyx b/pandas/msgpack.pyx
index 7d492b6dd..7af31e2b8 100644
--- a/pandas/msgpack.pyx
+++ b/pandas/msgpack.pyx
@@ -110,7 +110,7 @@ cdef class Packer(object):
     * *defaut* - Convert user type to builtin type that Packer supports.
       See also simplejson's document.
     * *encoding* - Convert unicode to bytes with this encoding. (default: 'utf-8')
-    * *unicode_erros* - Error handler for encoding unicode. (default: 'strict')
+    * *unicode_errors* - Error handler for encoding unicode. (default: 'strict')
     * *use_single_float* - Use single precision float type for float. (default: False)
     * *autoreset* - Reset buffer after each pack and return it's content as `bytes`. (default: True).
       If set this to false, use `bytes()` to get content and `.reset()` to clear buffer.
@@ -242,7 +242,7 @@ cdef class Packer(object):
                     if ret != 0: break
 
         # ndarray support ONLY (and float64/int64) for now
-        elif isinstance(o, np.ndarray) and not hasattr(o,'values') and (o.dtype == 'float64' or o.dtype == 'int64'): 
+        elif isinstance(o, np.ndarray) and not hasattr(o,'values') and (o.dtype == 'float64' or o.dtype == 'int64'):
 
             ret = msgpack_pack_map(&self.pk, 5)
             if ret != 0: return -1
@@ -276,7 +276,7 @@ cdef class Packer(object):
                 for i in range(n):
 
                    i8val = array_int[i]
-                   ret = msgpack_pack_long(&self.pk, i8val)
+                   ret = msgpack_pack_long_long(&self.pk, i8val)
                    if ret != 0: break
 
         elif self._default:
diff --git a/pandas/tests/test_msgpack/__init__.py b/pandas/tests/test_msgpack/__init__.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/pandas/tests/test_msgpack/test_except.py b/pandas/tests/test_msgpack/test_except.py
index 2e1652a6b..a0239336c 100644
--- a/pandas/tests/test_msgpack/test_except.py
+++ b/pandas/tests/test_msgpack/test_except.py
@@ -1,31 +1,29 @@
 #!/usr/bin/env python
 # coding: utf-8
 
-from pytest import raises
-from pandas.msgpack import packb, unpackb
+import unittest
+import nose
 
 import datetime
-
+from pandas.msgpack import packb, unpackb
 
 class DummyException(Exception):
     pass
 
+class TestExceptions(unittest.TestCase):
 
-def test_raise_on_find_unsupported_value():
-    with raises(TypeError):
-        packb(datetime.datetime.now())
-
-
-def test_raise_from_object_hook():
-    def hook(obj):
-        raise DummyException
-    raises(DummyException, unpackb, packb({}), object_hook=hook)
-    raises(DummyException, unpackb, packb({'fizz': 'buzz'}), object_hook=hook)
-    raises(DummyException, unpackb, packb({'fizz': 'buzz'}), object_pairs_hook=hook)
-    raises(DummyException, unpackb, packb({'fizz': {'buzz': 'spam'}}), object_hook=hook)
-    raises(DummyException, unpackb, packb({'fizz': {'buzz': 'spam'}}), object_pairs_hook=hook)
+    def test_raise_on_find_unsupported_value(self):
+        import datetime
+        self.assertRaises(TypeError, packb, datetime.datetime.now())
 
+    def test_raise_from_object_hook(self):
+        def hook(obj):
+            raise DummyException
+        self.assertRaises(DummyException, unpackb, packb({}), object_hook=hook)
+        self.assertRaises(DummyException, unpackb, packb({'fizz': 'buzz'}), object_hook=hook)
+        self.assertRaises(DummyException, unpackb, packb({'fizz': 'buzz'}), object_pairs_hook=hook)
+        self.assertRaises(DummyException, unpackb, packb({'fizz': {'buzz': 'spam'}}), object_hook=hook)
+        self.assertRaises(DummyException, unpackb, packb({'fizz': {'buzz': 'spam'}}), object_pairs_hook=hook)
 
-def test_invalidvalue():
-    with raises(ValueError):
-        unpackb(b'\xd9\x97#DL_')
+    def test_invalidvalue(self):
+        self.assertRaises(ValueError, unpackb, b'\xd9\x97#DL_')
diff --git a/pandas/tests/test_msgpack/test_obj.py b/pandas/tests/test_msgpack/test_obj.py
index 967baa244..4a018bc8b 100644
--- a/pandas/tests/test_msgpack/test_obj.py
+++ b/pandas/tests/test_msgpack/test_obj.py
@@ -1,67 +1,71 @@
-#!/usr/bin/env python
 # coding: utf-8
 
-from pytest import raises
-from pandas.msgpack import packb, unpackb
-
-def _decode_complex(obj):
-    if b'__complex__' in obj:
-        return complex(obj[b'real'], obj[b'imag'])
-    return obj
-
-def _encode_complex(obj):
-    if isinstance(obj, complex):
-        return {b'__complex__': True, b'real': 1, b'imag': 2}
-    return obj
-
-def test_encode_hook():
-    packed = packb([3, 1+2j], default=_encode_complex)
-    unpacked = unpackb(packed, use_list=1)
-    assert unpacked[1] == {b'__complex__': True, b'real': 1, b'imag': 2}
-
-def test_decode_hook():
-    packed = packb([3, {b'__complex__': True, b'real': 1, b'imag': 2}])
-    unpacked = unpackb(packed, object_hook=_decode_complex, use_list=1)
-    assert unpacked[1] == 1+2j
-
-def test_decode_pairs_hook():
-    packed = packb([3, {1: 2, 3: 4}])
-    prod_sum = 1 * 2 + 3 * 4
-    unpacked = unpackb(packed, object_pairs_hook=lambda l: sum(k * v for k, v in l), use_list=1)
-    assert unpacked[1] == prod_sum
-
-def test_only_one_obj_hook():
-    with raises(ValueError):
-        unpackb(b'', object_hook=lambda x: x, object_pairs_hook=lambda x: x)
-
-def test_bad_hook():
-    with raises(ValueError):
-        packed = packb([3, 1+2j], default=lambda o: o)
-        unpacked = unpackb(packed, use_list=1)
-
-def _arr_to_str(arr):
-    return ''.join(str(c) for c in arr)
-
-def test_array_hook():
-    packed = packb([1,2,3])
-    unpacked = unpackb(packed, list_hook=_arr_to_str, use_list=1)
-    assert unpacked == '123'
+import unittest
+import nose
 
+import datetime
+from pandas.msgpack import packb, unpackb
 
 class DecodeError(Exception):
     pass
 
-def bad_complex_decoder(o):
-    raise DecodeError("Ooops!")
+class TestObj(unittest.TestCase):
 
+    def _arr_to_str(self, arr):
+        return ''.join(str(c) for c in arr)
 
-def test_an_exception_in_objecthook1():
-    with raises(DecodeError):
-        packed = packb({1: {'__complex__': True, 'real': 1, 'imag': 2}})
-        unpackb(packed, object_hook=bad_complex_decoder)
+    def bad_complex_decoder(self, o):
+        raise DecodeError("Ooops!")
 
+    def _decode_complex(self, obj):
+        if b'__complex__' in obj:
+            return complex(obj[b'real'], obj[b'imag'])
+        return obj
 
-def test_an_exception_in_objecthook2():
-    with raises(DecodeError):
-        packed = packb({1: [{'__complex__': True, 'real': 1, 'imag': 2}]})
-        unpackb(packed, list_hook=bad_complex_decoder, use_list=1)
+    def _encode_complex(self, obj):
+        if isinstance(obj, complex):
+            return {b'__complex__': True, b'real': 1, b'imag': 2}
+        return obj
+
+    def test_encode_hook(self):
+        packed = packb([3, 1+2j], default=self._encode_complex)
+        unpacked = unpackb(packed, use_list=1)
+        assert unpacked[1] == {b'__complex__': True, b'real': 1, b'imag': 2}
+
+    def test_decode_hook(self):
+        packed = packb([3, {b'__complex__': True, b'real': 1, b'imag': 2}])
+        unpacked = unpackb(packed, object_hook=self._decode_complex, use_list=1)
+        assert unpacked[1] == 1+2j
+
+    def test_decode_pairs_hook(self):
+        packed = packb([3, {1: 2, 3: 4}])
+        prod_sum = 1 * 2 + 3 * 4
+        unpacked = unpackb(packed, object_pairs_hook=lambda l: sum(k * v for k, v in l), use_list=1)
+        assert unpacked[1] == prod_sum
+
+    def test_only_one_obj_hook(self):
+        self.assertRaises(ValueError, unpackb, b'', object_hook=lambda x: x, object_pairs_hook=lambda x: x)
+
+    def test_bad_hook(self):
+        def f():
+            packed = packb([3, 1+2j], default=lambda o: o)
+            unpacked = unpackb(packed, use_list=1)
+        self.assertRaises(ValueError, f)
+
+    def test_array_hook(self):
+        packed = packb([1,2,3])
+        unpacked = unpackb(packed, list_hook=self._arr_to_str, use_list=1)
+        assert unpacked == '123'
+
+    def test_an_exception_in_objecthook1(self):
+        def f():
+            packed = packb({1: {'__complex__': True, 'real': 1, 'imag': 2}})
+            unpackb(packed, object_hook=self.bad_complex_decoder)
+        self.assertRaises(DecodeError, f)
+
+
+    def test_an_exception_in_objecthook2(self):
+        def f():
+            packed = packb({1: [{'__complex__': True, 'real': 1, 'imag': 2}]})
+            unpackb(packed, list_hook=self.bad_complex_decoder, use_list=1)
+        self.assertRaises(DecodeError, f)
diff --git a/pandas/tests/test_msgpack/test_pack.py b/pandas/tests/test_msgpack/test_pack.py
index 90979db60..22df6df5e 100644
--- a/pandas/tests/test_msgpack/test_pack.py
+++ b/pandas/tests/test_msgpack/test_pack.py
@@ -1,163 +1,144 @@
 #!/usr/bin/env python
 # coding: utf-8
 
-import six
-import struct
-from pytest import raises, xfail
+import unittest
+import nose
 
+import struct
+from pandas import compat
+from pandas.compat import u, OrderedDict
 from pandas.msgpack import packb, unpackb, Unpacker, Packer
 
-from io import BytesIO
+class TestPack(unittest.TestCase):
 
-def check(data, use_list=False):
-    re = unpackb(packb(data), use_list=use_list)
-    assert re == data
+    def check(self, data, use_list=False):
+        re = unpackb(packb(data), use_list=use_list)
+        assert re == data
 
-def testPack():
-    test_data = [
+    def testPack(self):
+        test_data = [
             0, 1, 127, 128, 255, 256, 65535, 65536,
             -1, -32, -33, -128, -129, -32768, -32769,
             1.0,
-        b"", b"a", b"a"*31, b"a"*32,
-        None, True, False,
-        (), ((),), ((), None,),
-        {None: 0},
-        (1<<23),
-        ]
-    for td in test_data:
-        check(td)
-
-def testPackUnicode():
-    test_data = [
-        six.u(""), six.u("abcd"), [six.u("defgh")], six.u("Русский текст"),
-        ]
-    for td in test_data:
-        re = unpackb(packb(td, encoding='utf-8'), use_list=1, encoding='utf-8')
-        assert re == td
-        packer = Packer(encoding='utf-8')
-        data = packer.pack(td)
-        re = Unpacker(BytesIO(data), encoding='utf-8', use_list=1).unpack()
-        assert re == td
-
-def testPackUTF32():
-    try:
+            b"", b"a", b"a"*31, b"a"*32,
+            None, True, False,
+            (), ((),), ((), None,),
+            {None: 0},
+            (1<<23),
+            ]
+        for td in test_data:
+            self.check(td)
+
+    def testPackUnicode(self):
+        test_data = [
+            u(""), u("abcd"), [u("defgh")], u("Русский текст"),
+            ]
+        for td in test_data:
+            re = unpackb(packb(td, encoding='utf-8'), use_list=1, encoding='utf-8')
+            assert re == td
+            packer = Packer(encoding='utf-8')
+            data = packer.pack(td)
+            re = Unpacker(compat.BytesIO(data), encoding='utf-8', use_list=1).unpack()
+            assert re == td
+
+    def testPackUTF32(self):
         test_data = [
-            six.u(""),
-            six.u("abcd"),
-            [six.u("defgh")],
-            six.u("Русский текст"),
+            compat.u(""),
+            compat.u("abcd"),
+            [compat.u("defgh")],
+            compat.u("Русский текст"),
             ]
         for td in test_data:
             re = unpackb(packb(td, encoding='utf-32'), use_list=1, encoding='utf-32')
             assert re == td
-    except LookupError as e:
-        xfail(e)
-
-def testPackBytes():
-    test_data = [
-        b"", b"abcd", (b"defgh",),
-        ]
-    for td in test_data:
-        check(td)
-
-def testIgnoreUnicodeErrors():
-    re = unpackb(packb(b'abc\xeddef'), encoding='utf-8', unicode_errors='ignore', use_list=1)
-    assert re == "abcdef"
-
-def testStrictUnicodeUnpack():
-    with raises(UnicodeDecodeError):
-        unpackb(packb(b'abc\xeddef'), encoding='utf-8', use_list=1)
-
-def testStrictUnicodePack():
-    with raises(UnicodeEncodeError):
-        packb(six.u("abc\xeddef"), encoding='ascii', unicode_errors='strict')
-
-def testIgnoreErrorsPack():
-    re = unpackb(packb(six.u("abcФФФdef"), encoding='ascii', unicode_errors='ignore'), encoding='utf-8', use_list=1)
-    assert re == six.u("abcdef")
-
-def testNoEncoding():
-    with raises(TypeError):
-        packb(six.u("abc"), encoding=None)
-
-def testDecodeBinary():
-    re = unpackb(packb("abc"), encoding=None, use_list=1)
-    assert re == b"abc"
-
-def testPackFloat():
-    assert packb(1.0, use_single_float=True)  == b'\xca' + struct.pack('>f', 1.0)
-    assert packb(1.0, use_single_float=False) == b'\xcb' + struct.pack('>d', 1.0)
-
-def testArraySize(sizes=[0, 5, 50, 1000]):
-    bio = six.BytesIO()
-    packer = Packer()
-    for size in sizes:
-        bio.write(packer.pack_array_header(size))
-        for i in range(size):
-            bio.write(packer.pack(i))
-
-    bio.seek(0)
-    unpacker = Unpacker(bio, use_list=1)
-    for size in sizes:
-        assert unpacker.unpack() == list(range(size))
-
-def test_manualreset(sizes=[0, 5, 50, 1000]):
-    packer = Packer(autoreset=False)
-    for size in sizes:
-        packer.pack_array_header(size)
-        for i in range(size):
-            packer.pack(i)
-
-    bio = six.BytesIO(packer.bytes())
-    unpacker = Unpacker(bio, use_list=1)
-    for size in sizes:
-        assert unpacker.unpack() == list(range(size))
-
-    packer.reset()
-    assert packer.bytes() == b''
-
-def testMapSize(sizes=[0, 5, 50, 1000]):
-    bio = six.BytesIO()
-    packer = Packer()
-    for size in sizes:
-        bio.write(packer.pack_map_header(size))
-        for i in range(size):
-            bio.write(packer.pack(i)) # key
-            bio.write(packer.pack(i * 2)) # value
-
-    bio.seek(0)
-    unpacker = Unpacker(bio)
-    for size in sizes:
-        assert unpacker.unpack() == dict((i, i * 2) for i in range(size))
-
-
-class odict(dict):
-    '''Reimplement OrderedDict to run test on Python 2.6'''
-    def __init__(self, seq):
-        self._seq = seq
-        dict.__init__(self, seq)
-
-    def items(self):
-        return self._seq[:]
-
-    def iteritems(self):
-        return iter(self._seq)
-
-    def keys(self):
-        return [x[0] for x in self._seq]
-
-def test_odict():
-    seq = [(b'one', 1), (b'two', 2), (b'three', 3), (b'four', 4)]
-    od = odict(seq)
-    assert unpackb(packb(od), use_list=1) == dict(seq)
-    def pair_hook(seq):
-        return list(seq)
-    assert unpackb(packb(od), object_pairs_hook=pair_hook, use_list=1) == seq
-
-
-def test_pairlist():
-    pairlist = [(b'a', 1), (2, b'b'), (b'foo', b'bar')]
-    packer = Packer()
-    packed = packer.pack_map_pairs(pairlist)
-    unpacked = unpackb(packed, object_pairs_hook=list)
-    assert pairlist == unpacked
+
+    def testPackBytes(self):
+        test_data = [
+            b"", b"abcd", (b"defgh",),
+            ]
+        for td in test_data:
+            self.check(td)
+
+    def testIgnoreUnicodeErrors(self):
+        re = unpackb(packb(b'abc\xeddef'), encoding='utf-8', unicode_errors='ignore', use_list=1)
+        assert re == "abcdef"
+
+    def testStrictUnicodeUnpack(self):
+        self.assertRaises(UnicodeDecodeError, unpackb, packb(b'abc\xeddef'), encoding='utf-8', use_list=1)
+
+    def testStrictUnicodePack(self):
+        self.assertRaises(UnicodeEncodeError, packb, compat.u("abc\xeddef"), encoding='ascii', unicode_errors='strict')
+
+    def testIgnoreErrorsPack(self):
+        re = unpackb(packb(compat.u("abcФФФdef"), encoding='ascii', unicode_errors='ignore'), encoding='utf-8', use_list=1)
+        assert re == compat.u("abcdef")
+
+    def testNoEncoding(self):
+        self.assertRaises(TypeError, packb, compat.u("abc"), encoding=None)
+
+    def testDecodeBinary(self):
+        re = unpackb(packb("abc"), encoding=None, use_list=1)
+        assert re == b"abc"
+
+    def testPackFloat(self):
+        assert packb(1.0, use_single_float=True)  == b'\xca' + struct.pack('>f', 1.0)
+        assert packb(1.0, use_single_float=False) == b'\xcb' + struct.pack('>d', 1.0)
+
+    def testArraySize(self, sizes=[0, 5, 50, 1000]):
+        bio = compat.BytesIO()
+        packer = Packer()
+        for size in sizes:
+            bio.write(packer.pack_array_header(size))
+            for i in range(size):
+                bio.write(packer.pack(i))
+
+        bio.seek(0)
+        unpacker = Unpacker(bio, use_list=1)
+        for size in sizes:
+            assert unpacker.unpack() == list(range(size))
+
+    def test_manualreset(self, sizes=[0, 5, 50, 1000]):
+        packer = Packer(autoreset=False)
+        for size in sizes:
+            packer.pack_array_header(size)
+            for i in range(size):
+                packer.pack(i)
+
+        bio = compat.BytesIO(packer.bytes())
+        unpacker = Unpacker(bio, use_list=1)
+        for size in sizes:
+            assert unpacker.unpack() == list(range(size))
+
+        packer.reset()
+        assert packer.bytes() == b''
+
+    def testMapSize(self, sizes=[0, 5, 50, 1000]):
+        bio = compat.BytesIO()
+        packer = Packer()
+        for size in sizes:
+            bio.write(packer.pack_map_header(size))
+            for i in range(size):
+                bio.write(packer.pack(i)) # key
+                bio.write(packer.pack(i * 2)) # value
+
+        bio.seek(0)
+        unpacker = Unpacker(bio)
+        for size in sizes:
+            assert unpacker.unpack() == dict((i, i * 2) for i in range(size))
+
+
+    def test_odict(self):
+        seq = [(b'one', 1), (b'two', 2), (b'three', 3), (b'four', 4)]
+        od = OrderedDict(seq)
+        assert unpackb(packb(od), use_list=1) == dict(seq)
+        def pair_hook(seq):
+            return list(seq)
+        assert unpackb(packb(od), object_pairs_hook=pair_hook, use_list=1) == seq
+
+
+    def test_pairlist(self):
+        pairlist = [(b'a', 1), (2, b'b'), (b'foo', b'bar')]
+        packer = Packer()
+        packed = packer.pack_map_pairs(pairlist)
+        unpacked = unpackb(packed, object_pairs_hook=list)
+        assert pairlist == unpacked
diff --git a/pandas/tests/test_msgpack/test_seq.py b/pandas/tests/test_msgpack/test_seq.py
index d1639bd51..e5ee68c4c 100644
--- a/pandas/tests/test_msgpack/test_seq.py
+++ b/pandas/tests/test_msgpack/test_seq.py
@@ -1,19 +1,21 @@
 #!/usr/bin/env python
 # coding: utf-8
 
-import six
-import io
+from pandas import compat
+from pandas.compat import u
 import pandas.msgpack as msgpack
 
 binarydata = [chr(i) for i in range(256)]
-binarydata = six.b("".join(binarydata))
+binarydata = "".join(binarydata)
+if compat.PY3:
+    binarydata = binarydata.encode('utf-8')
 
 def gen_binary_data(idx):
     data = binarydata[:idx % 300]
     return data
 
 def test_exceeding_unpacker_read_size():
-    dumpf = io.BytesIO()
+    dumpf = compat.BytesIO()
 
     packer = msgpack.Packer()
 
@@ -28,7 +30,7 @@ def test_exceeding_unpacker_read_size():
         data = gen_binary_data(idx)
         dumpf.write(packer.pack(data))
 
-    f = io.BytesIO(dumpf.getvalue())
+    f = compat.BytesIO(dumpf.getvalue())
     dumpf.close()
 
     unpacker = msgpack.Unpacker(f, read_size=read_size, use_list=1)
diff --git a/pandas/tests/test_msgpack/test_sequnpack.py b/pandas/tests/test_msgpack/test_sequnpack.py
index add7e211e..4c3ad363e 100644
--- a/pandas/tests/test_msgpack/test_sequnpack.py
+++ b/pandas/tests/test_msgpack/test_sequnpack.py
@@ -1,86 +1,84 @@
 #!/usr/bin/env python
 # coding: utf-8
 
-import six
+import unittest
+import nose
+
+from pandas import compat
 from pandas.msgpack import Unpacker, BufferFull
 from pandas.msgpack import OutOfData
-from pytest import raises
-
 
-def test_partialdata():
-    unpacker = Unpacker()
-    unpacker.feed(b'\xa5')
-    with raises(StopIteration): next(iter(unpacker))
-    unpacker.feed(b'h')
-    with raises(StopIteration): next(iter(unpacker))
-    unpacker.feed(b'a')
-    with raises(StopIteration): next(iter(unpacker))
-    unpacker.feed(b'l')
-    with raises(StopIteration): next(iter(unpacker))
-    unpacker.feed(b'l')
-    with raises(StopIteration): next(iter(unpacker))
-    unpacker.feed(b'o')
-    assert next(iter(unpacker)) == b'hallo'
+class TestPack(unittest.TestCase):
 
-def test_foobar():
-    unpacker = Unpacker(read_size=3, use_list=1)
-    unpacker.feed(b'foobar')
-    assert unpacker.unpack() == ord(b'f')
-    assert unpacker.unpack() == ord(b'o')
-    assert unpacker.unpack() == ord(b'o')
-    assert unpacker.unpack() == ord(b'b')
-    assert unpacker.unpack() == ord(b'a')
-    assert unpacker.unpack() == ord(b'r')
-    with raises(OutOfData):
-        unpacker.unpack()
+    def test_partialdata(self):
+        unpacker = Unpacker()
+        unpacker.feed(b'\xa5')
+        self.assertRaises(StopIteration, next, iter(unpacker))
+        unpacker.feed(b'h')
+        self.assertRaises(StopIteration, next, iter(unpacker))
+        unpacker.feed(b'a')
+        self.assertRaises(StopIteration, next, iter(unpacker))
+        unpacker.feed(b'l')
+        self.assertRaises(StopIteration, next, iter(unpacker))
+        unpacker.feed(b'l')
+        self.assertRaises(StopIteration, next, iter(unpacker))
+        unpacker.feed(b'o')
+        assert next(iter(unpacker)) == b'hallo'
 
-    unpacker.feed(b'foo')
-    unpacker.feed(b'bar')
+    def test_foobar(self):
+        unpacker = Unpacker(read_size=3, use_list=1)
+        unpacker.feed(b'foobar')
+        assert unpacker.unpack() == ord(b'f')
+        assert unpacker.unpack() == ord(b'o')
+        assert unpacker.unpack() == ord(b'o')
+        assert unpacker.unpack() == ord(b'b')
+        assert unpacker.unpack() == ord(b'a')
+        assert unpacker.unpack() == ord(b'r')
+        self.assertRaises(OutOfData, unpacker.unpack)
 
-    k = 0
-    for o, e in zip(unpacker, 'foobarbaz'):
-        assert o == ord(e)
-        k += 1
-    assert k == len(b'foobar')
+        unpacker.feed(b'foo')
+        unpacker.feed(b'bar')
 
-def test_foobar_skip():
-    unpacker = Unpacker(read_size=3, use_list=1)
-    unpacker.feed(b'foobar')
-    assert unpacker.unpack() == ord(b'f')
-    unpacker.skip()
-    assert unpacker.unpack() == ord(b'o')
-    unpacker.skip()
-    assert unpacker.unpack() == ord(b'a')
-    unpacker.skip()
-    with raises(OutOfData):
-        unpacker.unpack()
+        k = 0
+        for o, e in zip(unpacker, 'foobarbaz'):
+            assert o == ord(e)
+            k += 1
+        assert k == len(b'foobar')
 
-def test_maxbuffersize():
-    with raises(ValueError):
-        Unpacker(read_size=5, max_buffer_size=3)
-    unpacker = Unpacker(read_size=3, max_buffer_size=3, use_list=1)
-    unpacker.feed(b'fo')
-    with raises(BufferFull):
-        unpacker.feed(b'ob')
-    unpacker.feed(b'o')
-    assert ord('f') == next(unpacker)
-    unpacker.feed(b'b')
-    assert ord('o') == next(unpacker)
-    assert ord('o') == next(unpacker)
-    assert ord('b') == next(unpacker)
+    def test_foobar_skip(self):
+        unpacker = Unpacker(read_size=3, use_list=1)
+        unpacker.feed(b'foobar')
+        assert unpacker.unpack() == ord(b'f')
+        unpacker.skip()
+        assert unpacker.unpack() == ord(b'o')
+        unpacker.skip()
+        assert unpacker.unpack() == ord(b'a')
+        unpacker.skip()
+        self.assertRaises(OutOfData, unpacker.unpack)
 
+    def test_maxbuffersize(self):
+        self.assertRaises(ValueError, Unpacker, read_size=5, max_buffer_size=3)
+        unpacker = Unpacker(read_size=3, max_buffer_size=3, use_list=1)
+        unpacker.feed(b'fo')
+        self.assertRaises(BufferFull, unpacker.feed, b'ob')
+        unpacker.feed(b'o')
+        assert ord('f') == next(unpacker)
+        unpacker.feed(b'b')
+        assert ord('o') == next(unpacker)
+        assert ord('o') == next(unpacker)
+        assert ord('b') == next(unpacker)
 
-def test_readbytes():
-    unpacker = Unpacker(read_size=3)
-    unpacker.feed(b'foobar')
-    assert unpacker.unpack() == ord(b'f')
-    assert unpacker.read_bytes(3) == b'oob'
-    assert unpacker.unpack() == ord(b'a')
-    assert unpacker.unpack() == ord(b'r')
+    def test_readbytes(self):
+        unpacker = Unpacker(read_size=3)
+        unpacker.feed(b'foobar')
+        assert unpacker.unpack() == ord(b'f')
+        assert unpacker.read_bytes(3) == b'oob'
+        assert unpacker.unpack() == ord(b'a')
+        assert unpacker.unpack() == ord(b'r')
 
-    # Test buffer refill
-    unpacker = Unpacker(six.BytesIO(b'foobar'), read_size=3)
-    assert unpacker.unpack() == ord(b'f')
-    assert unpacker.read_bytes(3) == b'oob'
-    assert unpacker.unpack() == ord(b'a')
-    assert unpacker.unpack() == ord(b'r')
+        # Test buffer refill
+        unpacker = Unpacker(compat.BytesIO(b'foobar'), read_size=3)
+        assert unpacker.unpack() == ord(b'f')
+        assert unpacker.read_bytes(3) == b'oob'
+        assert unpacker.unpack() == ord(b'a')
+        assert unpacker.unpack() == ord(b'r')
diff --git a/pandas/tests/test_msgpack/test_unpack_raw.py b/pandas/tests/test_msgpack/test_unpack_raw.py
index fc95f36f4..0e96a79cf 100644
--- a/pandas/tests/test_msgpack/test_unpack_raw.py
+++ b/pandas/tests/test_msgpack/test_unpack_raw.py
@@ -1,19 +1,18 @@
 """Tests for cases where the user seeks to obtain packed msgpack objects"""
 
-import six
+from pandas import compat
 from pandas.msgpack import Unpacker, packb
 
-
 def test_write_bytes():
     unpacker = Unpacker()
     unpacker.feed(b'abc')
-    f = six.BytesIO()
+    f = compat.BytesIO()
     assert unpacker.unpack(f.write) == ord('a')
     assert f.getvalue() == b'a'
-    f = six.BytesIO()
+    f = compat.BytesIO()
     assert unpacker.skip(f.write) is None
     assert f.getvalue() == b'b'
-    f = six.BytesIO()
+    f = compat.BytesIO()
     assert unpacker.skip() is None
     assert f.getvalue() == b''
 
@@ -21,9 +20,9 @@ def test_write_bytes():
 def test_write_bytes_multi_buffer():
     long_val = (5) * 100
     expected = packb(long_val)
-    unpacker = Unpacker(six.BytesIO(expected), read_size=3, max_buffer_size=3)
+    unpacker = Unpacker(compat.BytesIO(expected), read_size=3, max_buffer_size=3)
 
-    f = six.BytesIO()
+    f = compat.BytesIO()
     unpacked = unpacker.unpack(f.write)
     assert unpacked == long_val
     assert f.getvalue() == expected
diff --git a/setup.py b/setup.py
index 4f01e357d..c326d14f5 100755
--- a/setup.py
+++ b/setup.py
@@ -534,6 +534,7 @@ setup(name=DISTNAME,
                 'pandas.stats',
                 'pandas.util',
                 'pandas.tests',
+                'pandas.tests.test_msgpack',
                 'pandas.tools',
                 'pandas.tools.tests',
                 'pandas.tseries',

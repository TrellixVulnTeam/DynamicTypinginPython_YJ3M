commit 49260b99e7fa1f46a3d9e25d67b6784e74d73a5f
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Feb 27 20:43:58 2012 -0500

    ENH: fill_value arg in DataFrame.reindex/reindex_axis, add fillna to sparse objects, GH #784

diff --git a/pandas/core/common.py b/pandas/core/common.py
index b253d24ee..24f71215d 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -108,15 +108,15 @@ def _take_1d_bool(arr, indexer, out, fill_value=np.nan):
     outview = out.view(np.uint8)
     lib.take_1d_bool(view, indexer, outview, fill_value=fill_value)
 
-def _take_2d_axis0_bool(arr, indexer, out):
+def _take_2d_axis0_bool(arr, indexer, out, fill_value=np.nan):
     view = arr.view(np.uint8)
     outview = out.view(np.uint8)
-    lib.take_2d_axis0_bool(view, indexer, outview)
+    lib.take_2d_axis0_bool(view, indexer, outview, fill_value=fill_value)
 
-def _take_2d_axis1_bool(arr, indexer, out):
+def _take_2d_axis1_bool(arr, indexer, out, fill_value=np.nan):
     view = arr.view(np.uint8)
     outview = out.view(np.uint8)
-    lib.take_2d_axis1_bool(view, indexer, outview)
+    lib.take_2d_axis1_bool(view, indexer, outview, fill_value=fill_value)
 
 _take1d_dict = {
     'float64' : lib.take_1d_float64,
@@ -198,7 +198,8 @@ def take_1d(arr, indexer, out=None, fill_value=np.nan):
 
     return out
 
-def take_2d(arr, indexer, out=None, mask=None, needs_masking=None, axis=0):
+def take_2d(arr, indexer, out=None, mask=None, needs_masking=None, axis=0,
+            fill_value=np.nan):
     """
     Specialized Cython take which sets NaN values in one pass
     """
@@ -221,19 +222,20 @@ def take_2d(arr, indexer, out=None, mask=None, needs_masking=None, axis=0):
             # upcasting may be required
             result = arr.take(indexer, axis=axis, out=out)
             result = _maybe_mask(result, mask, needs_masking, axis=axis,
-                                 out_passed=out is not None)
+                                 out_passed=out is not None,
+                                 fill_value=fill_value)
             return result
         else:
             if out is None:
                 out = np.empty(out_shape, dtype=arr.dtype)
             take_f = _get_take2d_function(dtype_str, axis=axis)
-            take_f(arr, indexer, out=out)
+            take_f(arr, indexer, out=out, fill_value=fill_value)
             return out
     elif dtype_str in ('float64', 'object'):
         if out is None:
             out = np.empty(out_shape, dtype=arr.dtype)
         take_f = _get_take2d_function(dtype_str, axis=axis)
-        take_f(arr, indexer, out=out)
+        take_f(arr, indexer, out=out, fill_value=fill_value)
         return out
     else:
         if mask is None:
@@ -246,34 +248,37 @@ def take_2d(arr, indexer, out=None, mask=None, needs_masking=None, axis=0):
 
         result = arr.take(indexer, axis=axis, out=out)
         result = _maybe_mask(result, mask, needs_masking, axis=axis,
-                             out_passed=out is not None)
+                             out_passed=out is not None,
+                             fill_value=fill_value)
         return result
 
-def null_out_axis(arr, mask, axis):
+def mask_out_axis(arr, mask, axis, fill_value=np.nan):
     indexer = [slice(None)] * arr.ndim
     indexer[axis] = mask
 
-    arr[tuple(indexer)] = np.NaN
+    arr[tuple(indexer)] = fill_value
 
-def take_fast(arr, indexer, mask, needs_masking, axis=0, out=None):
+def take_fast(arr, indexer, mask, needs_masking, axis=0, out=None,
+              fill_value=np.nan):
     if arr.ndim == 2:
         return take_2d(arr, indexer, out=out, mask=mask,
                        needs_masking=needs_masking,
-                       axis=axis)
+                       axis=axis, fill_value=fill_value)
 
     result = arr.take(indexer, axis=axis, out=out)
     result = _maybe_mask(result, mask, needs_masking, axis=axis,
-                         out_passed=out is not None)
+                         out_passed=out is not None, fill_value=fill_value)
     return result
 
-def _maybe_mask(result, mask, needs_masking, axis=0, out_passed=False):
+def _maybe_mask(result, mask, needs_masking, axis=0, out_passed=False,
+                fill_value=np.nan):
     if needs_masking:
         if out_passed and _need_upcast(result):
             raise Exception('incompatible type for NAs')
         else:
             # a bit spaghettified
             result = _maybe_upcast(result)
-            null_out_axis(result, mask, axis)
+            mask_out_axis(result, mask, axis, fill_value)
     return result
 
 def _maybe_upcast(values):
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 8a69fb0be..7958e7fc3 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1693,7 +1693,7 @@ class DataFrame(NDFrame):
     # Reindexing and alignment
 
     def align(self, other, join='outer', axis=None, level=None, copy=True,
-              fill_value=None, method=None):
+              fill_value=np.nan, method=None):
         """
         Align two DataFrame object on their index and columns with the
         specified join method for each axis Index
@@ -1710,7 +1710,9 @@ class DataFrame(NDFrame):
         copy : boolean, default True
             Always returns new objects. If copy=False and no reindexing is
             required then original objects are returned.
-        fill_value : object, default None
+        fill_value : scalar, default np.NaN
+            Value to use for missing values. Defaults to NaN, but can be any
+            "compatible" value
         method : str, default None
 
         Returns
@@ -1730,7 +1732,7 @@ class DataFrame(NDFrame):
             raise TypeError('unsupported type: %s' % type(other))
 
     def _align_frame(self, other, join='outer', axis=None, level=None,
-                     copy=True, fill_value=None, method=None):
+                     copy=True, fill_value=np.nan, method=None):
         # defaults
         join_index, join_columns = None, None
         ilidx, iridx = None, None
@@ -1749,15 +1751,17 @@ class DataFrame(NDFrame):
                                       return_indexers=True)
 
         left = self._reindex_with_indexers(join_index, ilidx,
-                                           join_columns, clidx, copy)
+                                           join_columns, clidx, copy,
+                                           fill_value=fill_value)
         right = other._reindex_with_indexers(join_index, iridx,
-                                             join_columns, cridx, copy)
-        fill_na = (fill_value is not None) or (method is not None)
-        if fill_na:
-            return (left.fillna(fill_value, method=method),
-                    right.fillna(fill_value, method=method))
-        else:
-            return left, right
+                                             join_columns, cridx, copy,
+                                             fill_value=fill_value)
+
+        if method is not None:
+            left = left.fillna(method=method)
+            right = right.fillna(method=method)
+
+        return left, right
 
     def _align_series(self, other, join='outer', axis=None, level=None,
                       copy=True, fill_value=None, method=None):
@@ -1798,7 +1802,7 @@ class DataFrame(NDFrame):
             return left_result, right_result
 
     def reindex(self, index=None, columns=None, method=None, level=None,
-                copy=True):
+                fill_value=np.nan, copy=True):
         """Conform DataFrame to new index with optional filling logic, placing
         NA/NaN in locations having no value in the previous index. A new object
         is produced unless the new index is equivalent to the current one and
@@ -1820,6 +1824,9 @@ class DataFrame(NDFrame):
         level : int or name
             Broadcast across a level, matching Index values on the
             passed MultiIndex level
+        fill_value : scalar, default np.NaN
+            Value to use for missing values. Defaults to NaN, but can be any
+            "compatible" value
 
         Examples
         --------
@@ -1833,14 +1840,15 @@ class DataFrame(NDFrame):
         frame = self
 
         if index is not None:
-            frame = frame._reindex_index(index, method, copy, level)
+            frame = frame._reindex_index(index, method, copy, level, fill_value)
 
         if columns is not None:
-            frame = frame._reindex_columns(columns, copy, level)
+            frame = frame._reindex_columns(columns, copy, level, fill_value)
 
         return frame
 
-    def reindex_axis(self, labels, axis=0, method=None, level=None, copy=True):
+    def reindex_axis(self, labels, axis=0, method=None, level=None, copy=True,
+                     fill_value=np.nan):
         """Conform DataFrame to new index with optional filling logic, placing
         NA/NaN in locations having no value in the previous index. A new object
         is produced unless the new index is equivalent to the current one and
@@ -1878,42 +1886,45 @@ class DataFrame(NDFrame):
         """
         self._consolidate_inplace()
         if axis == 0:
-            df = self._reindex_index(labels, method, copy, level)
-            return df
+            return self._reindex_index(labels, method, copy, level,
+                                       fill_value=fill_value)
         elif axis == 1:
-            df = self._reindex_columns(labels, copy, level)
-            return df
+            return self._reindex_columns(labels, copy, level,
+                                         fill_value=fill_value)
         else:  # pragma: no cover
             raise ValueError('Must specify axis=0 or 1')
 
-    def _reindex_index(self, new_index, method, copy, level):
+    def _reindex_index(self, new_index, method, copy, level, fill_value=np.nan):
         if level is not None:
             assert(isinstance(new_index, MultiIndex))
         new_index, indexer = self.index.reindex(new_index, method, level)
         return self._reindex_with_indexers(new_index, indexer, None, None,
-                                           copy)
+                                           copy, fill_value)
 
-    def _reindex_columns(self, new_columns, copy, level):
+    def _reindex_columns(self, new_columns, copy, level, fill_value=np.nan):
         if level is not None:
             assert(isinstance(new_columns, MultiIndex))
         new_columns, indexer = self.columns.reindex(new_columns, level=level)
         return self._reindex_with_indexers(None, None, new_columns, indexer,
-                                           copy)
+                                           copy, fill_value)
 
     def _reindex_with_indexers(self, index, row_indexer, columns, col_indexer,
-                               copy):
+                               copy, fill_value):
         new_data = self._data
         if row_indexer is not None:
-            new_data = new_data.reindex_indexer(index, row_indexer, axis=1)
+            new_data = new_data.reindex_indexer(index, row_indexer, axis=1,
+                                                fill_value=fill_value)
         elif index is not None and index is not new_data.axes[1]:
             new_data = new_data.copy(deep=copy)
             new_data.axes[1] = index
 
         if col_indexer is not None:
             # TODO: speed up on homogeneous DataFrame objects
-            new_data = new_data.reindex_indexer(columns, col_indexer, axis=0)
+            new_data = new_data.reindex_indexer(columns, col_indexer, axis=0,
+                                                fill_value=fill_value)
         elif columns is not None and columns is not new_data.axes[0]:
-            new_data = new_data.reindex_items(columns, copy=copy)
+            new_data = new_data.reindex_items(columns, copy=copy,
+                                              fill_value=fill_value)
 
         if copy and new_data is self._data:
             new_data = new_data.copy()
@@ -2361,8 +2372,7 @@ class DataFrame(NDFrame):
 
     def fillna(self, value=None, method='pad', inplace=False):
         """
-        Fill NA/NaN values using the specified method. Member Series /
-        TimeSeries are filled separately
+        Fill NA/NaN values using the specified method
 
         Parameters
         ----------
@@ -2402,12 +2412,6 @@ class DataFrame(NDFrame):
                 new_blocks.append(newb)
 
             new_data = BlockManager(new_blocks, self._data.axes)
-
-            # series = self._series
-            # for col, s in series.iteritems():
-            #     result[col] = s.fillna(method=method, value=value)
-            # return self._constructor(result, index=self.index,
-            #                          columns=self.columns)
         else:
             # Float type values
             if len(self.columns) == 0:
diff --git a/pandas/core/internals.py b/pandas/core/internals.py
index 556826dc8..4ef644e90 100644
--- a/pandas/core/internals.py
+++ b/pandas/core/internals.py
@@ -101,18 +101,20 @@ class Block(object):
         #     union_ref = self.ref_items + other.ref_items
         return _merge_blocks([self, other], self.ref_items)
 
-    def reindex_axis(self, indexer, mask, needs_masking, axis=0):
+    def reindex_axis(self, indexer, mask, needs_masking, axis=0,
+                     fill_value=np.nan):
         """
         Reindex using pre-computed indexer information
         """
         if self.values.size > 0:
             new_values = com.take_fast(self.values, indexer, mask,
-                                       needs_masking, axis=axis)
+                                       needs_masking, axis=axis,
+                                       fill_value=fill_value)
         else:
             shape = list(self.shape)
             shape[axis] = len(indexer)
             new_values = np.empty(shape)
-            new_values.fill(np.nan)
+            new_values.fill(fill_value)
         return make_block(new_values, self.items, self.ref_items)
 
     def reindex_items_from(self, new_ref_items, copy=True):
@@ -730,12 +732,12 @@ class BlockManager(object):
         new_axis, indexer = cur_axis.reindex(new_axis, method)
         return self.reindex_indexer(new_axis, indexer, axis=axis)
 
-    def reindex_indexer(self, new_axis, indexer, axis=1):
+    def reindex_indexer(self, new_axis, indexer, axis=1, fill_value=np.nan):
         """
         pandas-indexer with -1's only.
         """
         if axis == 0:
-            return self._reindex_indexer_items(new_axis, indexer)
+            return self._reindex_indexer_items(new_axis, indexer, fill_value)
 
         mask = indexer == -1
 
@@ -745,14 +747,14 @@ class BlockManager(object):
         new_blocks = []
         for block in self.blocks:
             newb = block.reindex_axis(indexer, mask, needs_masking,
-                                      axis=axis)
+                                      axis=axis, fill_value=fill_value)
             new_blocks.append(newb)
 
         new_axes = list(self.axes)
         new_axes[axis] = new_axis
         return BlockManager(new_blocks, new_axes)
 
-    def _reindex_indexer_items(self, new_items, indexer):
+    def _reindex_indexer_items(self, new_items, indexer, fill_value):
         # TODO: less efficient than I'd like
 
         item_order = com.take_1d(self.items.values, indexer)
@@ -778,13 +780,14 @@ class BlockManager(object):
 
         if not mask.all():
             na_items = new_items[-mask]
-            na_block = self._make_na_block(na_items, new_items)
+            na_block = self._make_na_block(na_items, new_items,
+                                           fill_value=fill_value)
             new_blocks.append(na_block)
             new_blocks = _consolidate(new_blocks, new_items)
 
         return BlockManager(new_blocks, [new_items] + self.axes[1:])
 
-    def reindex_items(self, new_items, copy=True):
+    def reindex_items(self, new_items, copy=True, fill_value=np.nan):
         """
 
         """
@@ -814,17 +817,22 @@ class BlockManager(object):
             mask = indexer == -1
             if mask.any():
                 extra_items = new_items[mask]
-                na_block = self._make_na_block(extra_items, new_items)
+                na_block = self._make_na_block(extra_items, new_items,
+                                               fill_value=fill_value)
                 new_blocks.append(na_block)
                 new_blocks = _consolidate(new_blocks, new_items)
 
         return BlockManager(new_blocks, [new_items] + self.axes[1:])
 
-    def _make_na_block(self, items, ref_items):
+    def _make_na_block(self, items, ref_items, fill_value=np.nan):
+        # TODO: infer dtypes other than float64 from fill_value
+
         block_shape = list(self.shape)
         block_shape[0] = len(items)
-        block_values = np.empty(block_shape, dtype=np.float64)
-        block_values.fill(nan)
+
+        dtype = com._infer_dtype(fill_value)
+        block_values = np.empty(block_shape, dtype=dtype)
+        block_values.fill(fill_value)
         na_block = make_block(block_values, items, ref_items,
                               do_integrity_check=True)
         return na_block
diff --git a/pandas/sparse/frame.py b/pandas/sparse/frame.py
index d0749ea59..3e9649dbd 100644
--- a/pandas/sparse/frame.py
+++ b/pandas/sparse/frame.py
@@ -477,7 +477,7 @@ class SparseDataFrame(DataFrame):
         return self._constructor(data=new_data, index=self.index,
                                  columns=self.columns)
 
-    def _reindex_index(self, index, method, copy, level):
+    def _reindex_index(self, index, method, copy, level, fill_value=np.nan):
         if level is not None:
             raise Exception('Reindex by level not supported for sparse')
 
@@ -500,24 +500,27 @@ class SparseDataFrame(DataFrame):
             new = values.take(indexer)
 
             if need_mask:
-                np.putmask(new, mask, nan)
+                np.putmask(new, mask, fill_value)
 
             new_series[col] = new
 
         return SparseDataFrame(new_series, index=index, columns=self.columns,
                                default_fill_value=self.default_fill_value)
 
-    def _reindex_columns(self, columns, copy, level):
+    def _reindex_columns(self, columns, copy, level, fill_value):
         if level is not None:
             raise Exception('Reindex by level not supported for sparse')
 
+        if com.notnull(fill_value):
+            raise NotImplementedError
+
         # TODO: fill value handling
         sdict = dict((k, v) for k, v in self.iteritems() if k in columns)
         return SparseDataFrame(sdict, index=self.index, columns=columns,
                                default_fill_value=self.default_fill_value)
 
     def _reindex_with_indexers(self, index, row_indexer, columns, col_indexer,
-                               copy):
+                               copy, fill_value):
         if columns is None:
             columns = self.columns
 
@@ -526,7 +529,8 @@ class SparseDataFrame(DataFrame):
             if col not in self:
                 continue
             if row_indexer is not None:
-                new_arrays[col] = com.take_1d(self[col].values, row_indexer)
+                new_arrays[col] = com.take_1d(self[col].values, row_indexer,
+                                              fill_value=fill_value)
             else:
                 new_arrays[col] = self[col]
 
@@ -720,8 +724,18 @@ class SparseDataFrame(DataFrame):
             else:
                 return self._apply_broadcast(func, axis)
 
-    def fillna(self, *args, **kwargs):
-        raise NotImplementedError
+    @Appender(DataFrame.fillna.__doc__)
+    def fillna(self, value=None, method='pad', inplace=False):
+        new_series = {}
+        for k, v in self.iterkv():
+            new_series[k] = v.fillna(value=value, method=method)
+
+        if inplace:
+            self._series = new_series
+            return self
+        else:
+            return self._constructor(new_series, index=self.index,
+                                     columns=self.columns)
 
 def stack_sparse_frame(frame):
     """
diff --git a/pandas/sparse/series.py b/pandas/sparse/series.py
index e3359aad2..29a9805b4 100644
--- a/pandas/sparse/series.py
+++ b/pandas/sparse/series.py
@@ -23,6 +23,7 @@ from pandas.sparse.array import (make_sparse, _sparse_array_op, SparseArray)
 from pandas._sparse import BlockIndex, IntIndex
 import pandas._sparse as splib
 
+from pandas.util.decorators import Appender
 
 #-------------------------------------------------------------------------------
 # Wrapper function for Series arithmetic methods
@@ -423,6 +424,19 @@ to sparse
                             sparse_index=new_index,
                             fill_value=self.fill_value)
 
+    @Appender(Series.fillna.__doc__)
+    def fillna(self, value=None, method='pad', inplace=False):
+        dense = self.to_dense()
+        filled = dense.fillna(value=value, method=method)
+        result = filled.to_sparse(kind=self.kind,
+                                  fill_value=self.fill_value)
+
+        if inplace:
+            self.sp_values[:] = result.sp_values
+            return self
+        else:
+            return result
+
     def take(self, indices, axis=0):
         """
         Sparse-compatible version of ndarray.take
diff --git a/pandas/sparse/tests/test_sparse.py b/pandas/sparse/tests/test_sparse.py
index eb989b012..8dcd09e06 100644
--- a/pandas/sparse/tests/test_sparse.py
+++ b/pandas/sparse/tests/test_sparse.py
@@ -1048,7 +1048,10 @@ class TestSparseDataFrame(TestCase, test_frame.SafeForSparse):
         self.assertRaises(Exception, self.frame.astype, np.int64)
 
     def test_fillna(self):
-        self.assertRaises(NotImplementedError, self.frame.fillna, 0)
+        df = self.zframe.reindex(range(5))
+        result = df.fillna(0)
+        expected = df.to_dense().fillna(0).to_sparse(fill_value=0)
+        assert_sp_frame_equal(result, expected)
 
     def test_rename(self):
         # just check this works
@@ -1129,6 +1132,12 @@ class TestSparseDataFrame(TestCase, test_frame.SafeForSparse):
         reindexed['G'] = reindexed['A']
         self.assert_('G' not in self.frame)
 
+    def test_reindex_fill_value(self):
+        rng = DateRange('20110110', periods=20)
+        result = self.zframe.reindex(rng, fill_value=0)
+        expected = self.zframe.reindex(rng).fillna(0)
+        assert_sp_frame_equal(result, expected)
+
     def test_take(self):
         result = self.frame.take([1, 0, 2], axis=1)
         expected = self.frame.reindex(columns=['B', 'A', 'C'])
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index ba156a019..57a141d38 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -38,10 +38,11 @@ take_2d_axis0_template = """@cython.wraparound(False)
 @cython.boundscheck(False)
 def take_2d_axis0_%(name)s(ndarray[%(c_type)s, ndim=2] values,
                            ndarray[int32_t] indexer,
-                           out=None):
+                           out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
         ndarray[%(c_type)s, ndim=2] outbuf
+        %(c_type)s fv
 
     n = len(indexer)
     k = values.shape[1]
@@ -51,15 +52,25 @@ def take_2d_axis0_%(name)s(ndarray[%(c_type)s, ndim=2] values,
     else:
         outbuf = out
 
-    for i in range(n):
-        idx = indexer[i]
-
-        if idx == -1:
-            for j from 0 <= j < k:
-                %(na_action)s
-        else:
-            for j from 0 <= j < k:
-                outbuf[i, j] = values[idx, j]
+    if %(raise_on_na)s and _checknan(fill_value):
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                for j from 0 <= j < k:
+                    raise ValueError('No NA values allowed')
+            else:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = values[idx, j]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = fv
+            else:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = values[idx, j]
 
 """
 
@@ -67,10 +78,11 @@ take_2d_axis1_template = """@cython.wraparound(False)
 @cython.boundscheck(False)
 def take_2d_axis1_%(name)s(ndarray[%(c_type)s, ndim=2] values,
                            ndarray[int32_t] indexer,
-                           out=None):
+                           out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
         ndarray[%(c_type)s, ndim=2] outbuf
+        %(c_type)s fv
 
     n = len(values)
     k = len(indexer)
@@ -80,21 +92,29 @@ def take_2d_axis1_%(name)s(ndarray[%(c_type)s, ndim=2] values,
     else:
         outbuf = out
 
-    for j in range(k):
-        idx = indexer[j]
+    if %(raise_on_na)s and _checknan(fill_value):
+        for j in range(k):
+            idx = indexer[j]
 
-        if idx == -1:
-            for i in range(n):
-                %(na_action)s
-        else:
-            for i in range(n):
-                outbuf[i, j] = values[i, idx]
+            if idx == -1:
+                for i in range(n):
+                    raise ValueError('No NA values allowed')
+            else:
+                for i in range(n):
+                    outbuf[i, j] = values[i, idx]
+    else:
+        fv = fill_value
+        for j in range(k):
+            idx = indexer[j]
 
-"""
+            if idx == -1:
+                for i in range(n):
+                    outbuf[i, j] = fv
+            else:
+                for i in range(n):
+                    outbuf[i, j] = values[i, idx]
 
-set_na = "outbuf[i] = NaN"
-set_na_2d = "outbuf[i, j] = NaN"
-raise_on_na = "raise ValueError('No NA values allowed')"
+"""
 
 merge_indexer_template = """@cython.wraparound(False)
 @cython.boundscheck(False)
@@ -734,14 +754,9 @@ def generate_from_template(template, ndim=1, exclude=None):
         if exclude is not None and name in exclude:
             continue
 
-        raise_on_na = 'False' if can_hold_na else 'True'
-        if ndim == 1:
-            na_action = set_na if can_hold_na else raise_on_na
-        elif ndim == 2:
-            na_action = set_na_2d if can_hold_na else raise_on_na
         func = template % {'name': name, 'c_type': c_type,
-                           'dtype': dtype, 'na_action': na_action,
-                           'raise_on_na': raise_on_na}
+                           'dtype': dtype,
+                           'raise_on_na': 'False' if can_hold_na else 'True'}
         output.write(func)
     return output.getvalue()
 
diff --git a/pandas/src/generated.pyx b/pandas/src/generated.pyx
index 9d1a3e1d9..e07fbead5 100644
--- a/pandas/src/generated.pyx
+++ b/pandas/src/generated.pyx
@@ -1382,10 +1382,11 @@ def arrmap_bool(ndarray[uint8_t] index, object func):
 @cython.boundscheck(False)
 def take_2d_axis0_float64(ndarray[float64_t, ndim=2] values,
                            ndarray[int32_t] indexer,
-                           out=None):
+                           out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
         ndarray[float64_t, ndim=2] outbuf
+        float64_t fv
 
     n = len(indexer)
     k = values.shape[1]
@@ -1395,24 +1396,35 @@ def take_2d_axis0_float64(ndarray[float64_t, ndim=2] values,
     else:
         outbuf = out
 
-    for i in range(n):
-        idx = indexer[i]
-
-        if idx == -1:
-            for j from 0 <= j < k:
-                outbuf[i, j] = NaN
-        else:
-            for j from 0 <= j < k:
-                outbuf[i, j] = values[idx, j]
+    if False and _checknan(fill_value):
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                for j from 0 <= j < k:
+                    raise ValueError('No NA values allowed')
+            else:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = values[idx, j]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = fv
+            else:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_2d_axis0_object(ndarray[object, ndim=2] values,
                            ndarray[int32_t] indexer,
-                           out=None):
+                           out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
         ndarray[object, ndim=2] outbuf
+        object fv
 
     n = len(indexer)
     k = values.shape[1]
@@ -1422,24 +1434,35 @@ def take_2d_axis0_object(ndarray[object, ndim=2] values,
     else:
         outbuf = out
 
-    for i in range(n):
-        idx = indexer[i]
-
-        if idx == -1:
-            for j from 0 <= j < k:
-                outbuf[i, j] = NaN
-        else:
-            for j from 0 <= j < k:
-                outbuf[i, j] = values[idx, j]
+    if False and _checknan(fill_value):
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                for j from 0 <= j < k:
+                    raise ValueError('No NA values allowed')
+            else:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = values[idx, j]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = fv
+            else:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_2d_axis0_int32(ndarray[int32_t, ndim=2] values,
                            ndarray[int32_t] indexer,
-                           out=None):
+                           out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
         ndarray[int32_t, ndim=2] outbuf
+        int32_t fv
 
     n = len(indexer)
     k = values.shape[1]
@@ -1449,24 +1472,35 @@ def take_2d_axis0_int32(ndarray[int32_t, ndim=2] values,
     else:
         outbuf = out
 
-    for i in range(n):
-        idx = indexer[i]
-
-        if idx == -1:
-            for j from 0 <= j < k:
-                True
-        else:
-            for j from 0 <= j < k:
-                outbuf[i, j] = values[idx, j]
+    if True and _checknan(fill_value):
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                for j from 0 <= j < k:
+                    raise ValueError('No NA values allowed')
+            else:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = values[idx, j]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = fv
+            else:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_2d_axis0_int64(ndarray[int64_t, ndim=2] values,
                            ndarray[int32_t] indexer,
-                           out=None):
+                           out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
         ndarray[int64_t, ndim=2] outbuf
+        int64_t fv
 
     n = len(indexer)
     k = values.shape[1]
@@ -1476,24 +1510,35 @@ def take_2d_axis0_int64(ndarray[int64_t, ndim=2] values,
     else:
         outbuf = out
 
-    for i in range(n):
-        idx = indexer[i]
-
-        if idx == -1:
-            for j from 0 <= j < k:
-                True
-        else:
-            for j from 0 <= j < k:
-                outbuf[i, j] = values[idx, j]
+    if True and _checknan(fill_value):
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                for j from 0 <= j < k:
+                    raise ValueError('No NA values allowed')
+            else:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = values[idx, j]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = fv
+            else:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = values[idx, j]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_2d_axis0_bool(ndarray[uint8_t, ndim=2] values,
                            ndarray[int32_t] indexer,
-                           out=None):
+                           out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
         ndarray[uint8_t, ndim=2] outbuf
+        uint8_t fv
 
     n = len(indexer)
     k = values.shape[1]
@@ -1503,25 +1548,36 @@ def take_2d_axis0_bool(ndarray[uint8_t, ndim=2] values,
     else:
         outbuf = out
 
-    for i in range(n):
-        idx = indexer[i]
-
-        if idx == -1:
-            for j from 0 <= j < k:
-                True
-        else:
-            for j from 0 <= j < k:
-                outbuf[i, j] = values[idx, j]
+    if True and _checknan(fill_value):
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                for j from 0 <= j < k:
+                    raise ValueError('No NA values allowed')
+            else:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = values[idx, j]
+    else:
+        fv = fill_value
+        for i in range(n):
+            idx = indexer[i]
+            if idx == -1:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = fv
+            else:
+                for j from 0 <= j < k:
+                    outbuf[i, j] = values[idx, j]
 
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_2d_axis1_float64(ndarray[float64_t, ndim=2] values,
                            ndarray[int32_t] indexer,
-                           out=None):
+                           out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
         ndarray[float64_t, ndim=2] outbuf
+        float64_t fv
 
     n = len(values)
     k = len(indexer)
@@ -1531,24 +1587,37 @@ def take_2d_axis1_float64(ndarray[float64_t, ndim=2] values,
     else:
         outbuf = out
 
-    for j in range(k):
-        idx = indexer[j]
+    if False and _checknan(fill_value):
+        for j in range(k):
+            idx = indexer[j]
 
-        if idx == -1:
-            for i in range(n):
-                outbuf[i, j] = NaN
-        else:
-            for i in range(n):
-                outbuf[i, j] = values[i, idx]
+            if idx == -1:
+                for i in range(n):
+                    raise ValueError('No NA values allowed')
+            else:
+                for i in range(n):
+                    outbuf[i, j] = values[i, idx]
+    else:
+        fv = fill_value
+        for j in range(k):
+            idx = indexer[j]
+
+            if idx == -1:
+                for i in range(n):
+                    outbuf[i, j] = fv
+            else:
+                for i in range(n):
+                    outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_2d_axis1_object(ndarray[object, ndim=2] values,
                            ndarray[int32_t] indexer,
-                           out=None):
+                           out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
         ndarray[object, ndim=2] outbuf
+        object fv
 
     n = len(values)
     k = len(indexer)
@@ -1558,24 +1627,37 @@ def take_2d_axis1_object(ndarray[object, ndim=2] values,
     else:
         outbuf = out
 
-    for j in range(k):
-        idx = indexer[j]
+    if False and _checknan(fill_value):
+        for j in range(k):
+            idx = indexer[j]
 
-        if idx == -1:
-            for i in range(n):
-                outbuf[i, j] = NaN
-        else:
-            for i in range(n):
-                outbuf[i, j] = values[i, idx]
+            if idx == -1:
+                for i in range(n):
+                    raise ValueError('No NA values allowed')
+            else:
+                for i in range(n):
+                    outbuf[i, j] = values[i, idx]
+    else:
+        fv = fill_value
+        for j in range(k):
+            idx = indexer[j]
+
+            if idx == -1:
+                for i in range(n):
+                    outbuf[i, j] = fv
+            else:
+                for i in range(n):
+                    outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_2d_axis1_int32(ndarray[int32_t, ndim=2] values,
                            ndarray[int32_t] indexer,
-                           out=None):
+                           out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
         ndarray[int32_t, ndim=2] outbuf
+        int32_t fv
 
     n = len(values)
     k = len(indexer)
@@ -1585,24 +1667,37 @@ def take_2d_axis1_int32(ndarray[int32_t, ndim=2] values,
     else:
         outbuf = out
 
-    for j in range(k):
-        idx = indexer[j]
+    if True and _checknan(fill_value):
+        for j in range(k):
+            idx = indexer[j]
 
-        if idx == -1:
-            for i in range(n):
-                True
-        else:
-            for i in range(n):
-                outbuf[i, j] = values[i, idx]
+            if idx == -1:
+                for i in range(n):
+                    raise ValueError('No NA values allowed')
+            else:
+                for i in range(n):
+                    outbuf[i, j] = values[i, idx]
+    else:
+        fv = fill_value
+        for j in range(k):
+            idx = indexer[j]
+
+            if idx == -1:
+                for i in range(n):
+                    outbuf[i, j] = fv
+            else:
+                for i in range(n):
+                    outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_2d_axis1_int64(ndarray[int64_t, ndim=2] values,
                            ndarray[int32_t] indexer,
-                           out=None):
+                           out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
         ndarray[int64_t, ndim=2] outbuf
+        int64_t fv
 
     n = len(values)
     k = len(indexer)
@@ -1612,24 +1707,37 @@ def take_2d_axis1_int64(ndarray[int64_t, ndim=2] values,
     else:
         outbuf = out
 
-    for j in range(k):
-        idx = indexer[j]
+    if True and _checknan(fill_value):
+        for j in range(k):
+            idx = indexer[j]
 
-        if idx == -1:
-            for i in range(n):
-                True
-        else:
-            for i in range(n):
-                outbuf[i, j] = values[i, idx]
+            if idx == -1:
+                for i in range(n):
+                    raise ValueError('No NA values allowed')
+            else:
+                for i in range(n):
+                    outbuf[i, j] = values[i, idx]
+    else:
+        fv = fill_value
+        for j in range(k):
+            idx = indexer[j]
+
+            if idx == -1:
+                for i in range(n):
+                    outbuf[i, j] = fv
+            else:
+                for i in range(n):
+                    outbuf[i, j] = values[i, idx]
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
 def take_2d_axis1_bool(ndarray[uint8_t, ndim=2] values,
                            ndarray[int32_t] indexer,
-                           out=None):
+                           out=None, fill_value=np.nan):
     cdef:
         Py_ssize_t i, j, k, n, idx
         ndarray[uint8_t, ndim=2] outbuf
+        uint8_t fv
 
     n = len(values)
     k = len(indexer)
@@ -1639,15 +1747,27 @@ def take_2d_axis1_bool(ndarray[uint8_t, ndim=2] values,
     else:
         outbuf = out
 
-    for j in range(k):
-        idx = indexer[j]
+    if True and _checknan(fill_value):
+        for j in range(k):
+            idx = indexer[j]
 
-        if idx == -1:
-            for i in range(n):
-                True
-        else:
-            for i in range(n):
-                outbuf[i, j] = values[i, idx]
+            if idx == -1:
+                for i in range(n):
+                    raise ValueError('No NA values allowed')
+            else:
+                for i in range(n):
+                    outbuf[i, j] = values[i, idx]
+    else:
+        fv = fill_value
+        for j in range(k):
+            idx = indexer[j]
+
+            if idx == -1:
+                for i in range(n):
+                    outbuf[i, j] = fv
+            else:
+                for i in range(n):
+                    outbuf[i, j] = values[i, idx]
 
 
 @cython.wraparound(False)
diff --git a/pandas/src/sandbox.pyx b/pandas/src/sandbox.pyx
index b8d9bcea2..dd4d4fac8 100644
--- a/pandas/src/sandbox.pyx
+++ b/pandas/src/sandbox.pyx
@@ -166,3 +166,47 @@ def fancy_inc(ndarray[int64_t, ndim=2] values,
 
 
 cimport util
+
+from khash cimport *
+
+cdef class Int64HashTable:
+
+    cdef:
+        kh_int64_t *table
+
+    def __init__(self, size_hint=1):
+        if size_hint is not None:
+            kh_resize_int64(self.table, size_hint)
+
+    def __cinit__(self):
+        self.table = kh_init_int64()
+
+    def __dealloc__(self):
+        kh_destroy_int64(self.table)
+
+    @cython.boundscheck(False)
+    @cython.wraparound(False)
+    def get_labels(self, ndarray[int64_t] values):
+        cdef:
+            Py_ssize_t i, n = len(values)
+            ndarray[int32_t] labels
+            Py_ssize_t idx, count = 0
+            int ret = 0
+            int64_t val
+            khiter_t k
+
+        labels = np.empty(n, dtype=np.int32)
+
+        for i in range(n):
+            val = values[i]
+            k = kh_get_int64(self.table, val)
+            if k != self.table.n_buckets:
+                idx = self.table.vals[k]
+                labels[i] = idx
+            else:
+                k = kh_put_int64(self.table, val, &ret)
+                self.table.vals[k] = count
+                labels[i] = count
+                count += 1
+
+        return labels
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 21afaedac..1812635a5 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -3159,7 +3159,49 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         newFrame = self.frame.reindex(columns=[])
         self.assert_(not newFrame)
 
-    def test_add_index(self):
+    def test_reindex_fill_value(self):
+        df = DataFrame(np.random.randn(10, 4))
+
+        # axis=0
+        result = df.reindex(range(15))
+        self.assert_(np.isnan(result.values[-5:]).all())
+
+        result = df.reindex(range(15), fill_value=0)
+        expected = df.reindex(range(15)).fillna(0)
+        assert_frame_equal(result, expected)
+
+        # axis=1
+        result = df.reindex(columns=range(5), fill_value=0.)
+        expected = df.copy()
+        expected[4] = 0.
+        assert_frame_equal(result, expected)
+
+        result = df.reindex(columns=range(5), fill_value=0)
+        expected = df.copy()
+        expected[4] = 0
+        assert_frame_equal(result, expected)
+
+        result = df.reindex(columns=range(5), fill_value='foo')
+        expected = df.copy()
+        expected[4] = 'foo'
+        assert_frame_equal(result, expected)
+
+        # reindex_axis
+        result = df.reindex_axis(range(15), fill_value=0., axis=0)
+        expected = df.reindex(range(15)).fillna(0)
+        assert_frame_equal(result, expected)
+
+        result = df.reindex_axis(range(5), fill_value=0., axis=1)
+        expected = df.reindex(columns=range(5)).fillna(0)
+        assert_frame_equal(result, expected)
+
+        # other dtypes
+        df['foo'] = 'foo'
+        result = df.reindex(range(15), fill_value=0)
+        expected = df.reindex(range(15)).fillna(0)
+        assert_frame_equal(result, expected)
+
+    def test_set_index2(self):
         df = DataFrame({'A' : ['foo', 'foo', 'foo', 'bar', 'bar'],
                         'B' : ['one', 'two', 'three', 'one', 'two'],
                         'C' : ['a', 'b', 'c', 'd', 'e'],
@@ -3229,7 +3271,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         # axis = 0
         other = self.frame.ix[:-5, :3]
         af, bf = self.frame.align(other, axis=0, fill_value=-1)
-        self.assert_(bf.columns.equals(other.columns))        
+        self.assert_(bf.columns.equals(other.columns))
         #test fill value
         join_idx = self.frame.index.join(other.index)
         diff_a = self.frame.index.diff(join_idx)

commit 56e35a9e855d9e20024195c31e89b51e07fa41fe
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Oct 8 16:36:05 2011 -0400

    ENH: Series.name integration, working on sparse compat and adding unit
    tests. Also refactored Series.__repr__

diff --git a/TODO.rst b/TODO.rst
index 68240da35..836c2791e 100644
--- a/TODO.rst
+++ b/TODO.rst
@@ -4,3 +4,4 @@
 - Is there a way to write hierarchical columns to csv?
 - Possible to blow away existing name when creating MultiIndex?
 - prettytable output with index names
+- Add load/save functions to top level pandas namespace
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index c02ba3b97..ec33dfc64 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2156,9 +2156,14 @@ class DataFrame(NDFrame):
         else:
             if how is None:
                 how = 'left'
+
             return self._join_index(other, how, lsuffix, rsuffix)
 
     def _join_on(self, other, on, lsuffix, rsuffix):
+        if isinstance(other, Series):
+            assert(other.name is not None)
+            other = DataFrame({other.name : other})
+
         if len(other.index) == 0:
             return self
 
@@ -2169,6 +2174,10 @@ class DataFrame(NDFrame):
     def _join_index(self, other, how, lsuffix, rsuffix):
         from pandas.core.internals import join_managers
 
+        if isinstance(other, Series):
+            assert(other.name is not None)
+            other = DataFrame({other.name : other})
+
         thisdata, otherdata = self._data._maybe_rename_join(
             other._data, lsuffix, rsuffix, copydata=False)
 
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index b4f258927..b06f90b24 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -3,11 +3,7 @@ Contains data structures designed for manipulating panel (3-dimensional) data
 """
 # pylint: disable=E1103,W0231,W0212,W0621
 
-from cStringIO import StringIO
 import operator
-import sys
-import warnings
-
 import numpy as np
 
 from pandas.core.common import (PandasError, _mut_exclusive,
diff --git a/pandas/core/series.py b/pandas/core/series.py
index e59a0d04a..30bd68ab8 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -186,6 +186,10 @@ copy : boolean, default False
         """
         pass
 
+    @property
+    def _constructor(self):
+        return Series
+
     def __hash__(self):
         raise TypeError('unhashable type')
 
@@ -304,7 +308,8 @@ copy : boolean, default False
     _get_val_at = ndarray.__getitem__
 
     def __getslice__(self, i, j):
-        return Series(self.values[i:j], index=self.index[i:j], name=self.name)
+        return self._constructor(self.values[i:j], index=self.index[i:j],
+                                 name=self.name)
 
     def __setitem__(self, key, value):
         values = self.values
@@ -354,24 +359,52 @@ copy : boolean, default False
     def __repr__(self):
         """Clean string representation of a Series"""
         if len(self.index) > 500:
-            return self._make_repr(50)
+            return self._tidy_repr(30)
         elif len(self.index) > 0:
-            return _seriesRepr(self.index, self.values)
+            return self._get_repr(name=True)
         else:
             return '%s' % ndarray.__repr__(self)
 
-    def _make_repr(self, max_vals=50):
+    def _tidy_repr(self, max_vals=20):
+        num = max_vals // 2
+        head = self[:num]._get_repr(name=False)
+        tail = self[-(max_vals - num):]._get_repr(name=False)
+        result = head + '\n...\n' + tail
+        result = '%s\nName: %s, Length: %d' % (result, self.name, len(self))
+        return result
+
+    def to_string(self, buffer=sys.stdout, nanRep='NaN'):
+        print >> buffer, self._get_repr(nanRep=nanRep)
+
+    def _get_repr(self, name=False, nanRep='NaN'):
         vals = self.values
         index = self.index
 
-        num = max_vals // 2
-        head = _seriesRepr(index[:num], vals[:num])
-        tail = _seriesRepr(index[-(max_vals - num):], vals[-(max_vals - num):])
-        return head + '\n...\n' + tail + '\nlength: %d' % len(vals)
+        string_index = index.format()
+        maxlen = max(len(x) for x in string_index)
+        padSpace = min(maxlen, 60)
 
-    def toString(self, buffer=sys.stdout, nanRep='NaN'):
-        print >> buffer, _seriesRepr(self.index, self.values,
-                                     nanRep=nanRep)
+        def _format_float(k, v):
+            if np.isnan(v):
+                v = nanRep
+            else:
+                v = str(v)
+            return '%s    %s' % (str(k).ljust(padSpace), v)
+
+        def _format_nonfloat(k, v):
+            return '%s    %s' % (str(k).ljust(padSpace), v)
+
+        if vals.dtype == np.float_:
+            _format = _format_float
+        else:
+            _format = _format_nonfloat
+
+        it = itertools.starmap(_format,
+                               itertools.izip(string_index, vals))
+        it = list(it)
+        if name:
+            it.append('Name: %s, Length: %d' % (str(self.name), len(self)))
+        return '\n'.join(it)
 
     def __str__(self):
         return repr(self)
@@ -462,7 +495,8 @@ copy : boolean, default False
         sp : SparseSeries
         """
         from pandas.core.sparse import SparseSeries
-        return SparseSeries(self, kind=kind, fill_value=fill_value)
+        return SparseSeries(self, kind=kind, fill_value=fill_value,
+                            name=self.name)
 
     def get(self, key, default=None):
         """
@@ -946,9 +980,9 @@ copy : boolean, default False
         new_index = self.index.append(other.index)
         new_index._verify_integrity()
 
-        new_values = np.concatenate((self, other))
+        new_values = np.concatenate((self.values, other.values))
         name = _maybe_match_name(self, other)
-        return Series(new_values, index=new_index, name=name)
+        return self._constructor(new_values, index=new_index, name=name)
 
     def _binop(self, other, func, fill_value=None):
         """
@@ -1804,6 +1838,7 @@ copy : boolean, default False
 
     asOf = deprecate('asOf', asof)
     toDict = deprecate('toDict', to_dict)
+    toString = deprecate('toString', to_string)
     merge = deprecate('merge', map)
     applymap = deprecate('applymap', apply)
     combineFirst = deprecate('combineFirst', combine_first)
@@ -1822,28 +1857,3 @@ def remove_na(arr):
     Return array containing only true/non-NaN values, possibly empty.
     """
     return arr[notnull(arr)]
-
-def _seriesRepr(index, vals, nanRep='NaN'):
-    string_index = index.format()
-    maxlen = max(len(x) for x in string_index)
-    padSpace = min(maxlen, 60)
-
-    if vals.dtype == np.object_:
-        def _format(k, v):
-            return '%s    %s' % (str(k).ljust(padSpace), v)
-    elif vals.dtype == np.float_:
-        def _format(k, v):
-            if np.isnan(v):
-                v = nanRep
-            else:
-                v = str(v)
-
-            return '%s    %s' % (str(k).ljust(padSpace), v)
-    else:
-        def _format(k, v):
-            return '%s    %s' % (str(k).ljust(padSpace), v)
-
-    it = itertools.starmap(_format,
-                           itertools.izip(string_index, vals))
-
-    return '\n'.join(it)
diff --git a/pandas/core/sparse.py b/pandas/core/sparse.py
index 24dc5ab85..f77bdff56 100644
--- a/pandas/core/sparse.py
+++ b/pandas/core/sparse.py
@@ -13,7 +13,7 @@ import operator
 from pandas.core.common import (isnull, _pickle_array, _unpickle_array,
                                 _mut_exclusive, _try_sort)
 from pandas.core.index import Index, MultiIndex, NULL_INDEX, _ensure_index
-from pandas.core.series import Series, TimeSeries
+from pandas.core.series import Series, TimeSeries, _maybe_match_name
 from pandas.core.frame import (DataFrame, extract_index, _prep_ndarray,
                                _default_index)
 from pandas.core.panel import Panel, LongPanel
@@ -80,7 +80,8 @@ def _sparse_op_wrap(op, name):
             return SparseSeries(op(self.sp_values, other),
                                 index=self.index,
                                 sparse_index=self.sp_index,
-                                fill_value=new_fill_value)
+                                fill_value=new_fill_value,
+                                name=self.name)
         else: # pragma: no cover
             raise TypeError('operation with %s not supported' % type(other))
 
@@ -111,9 +112,10 @@ def _sparse_series_op(left, right, op, name):
     except ZeroDivisionError:
         fill_value = nan
 
+    new_name = _maybe_match_name(left, right)
     return SparseSeries(result, index=new_index,
                         sparse_index=result_index,
-                        fill_value=fill_value)
+                        fill_value=fill_value, name=new_name)
 
 def _sparse_nanop(this, other, name):
     sparse_op = getattr(splib, 'sparse_nan%s' % name)
@@ -143,7 +145,7 @@ class SparseSeries(Series):
     fill_value = None
 
     def __new__(cls, data, index=None, sparse_index=None, kind='block',
-                fill_value=None, copy=False):
+                fill_value=None, name=None, copy=False):
 
         is_sparse_series = isinstance(data, SparseSeries)
         if fill_value is None:
@@ -207,10 +209,11 @@ class SparseSeries(Series):
         output.sp_index = sparse_index
         output.fill_value = np.float64(fill_value)
         output.index = index
+        output.name = name
         return output
 
     def __init__(self, data, index=None, sparse_index=None, kind='block',
-                 fill_value=None, copy=False):
+                 fill_value=None, name=None, copy=False):
         """Data structure for labeled, sparse floating point data
 
 Parameters
@@ -232,9 +235,9 @@ to sparse
 
     @property
     def _constructor(self):
-        def make_sp_series(data, index=None):
+        def make_sp_series(data, index=None, name=None):
             return SparseSeries(data, index=index, fill_value=self.fill_value,
-                                kind=self.kind)
+                                kind=self.kind, name=name)
 
         return make_sp_series
 
@@ -251,6 +254,7 @@ to sparse
         to pass on the index.
         """
         self._index = getattr(obj, '_index', None)
+        self.name = getattr(obj, 'name', None)
         self.sp_index = getattr(obj, 'sp_index', None)
         self.fill_value = getattr(obj, 'fill_value', None)
 
@@ -258,7 +262,8 @@ to sparse
         """Necessary for making this object picklable"""
         object_state = list(ndarray.__reduce__(self))
 
-        subclass_state = (self.index, self.fill_value, self.sp_index)
+        subclass_state = (self.index, self.fill_value, self.sp_index,
+                          self.name)
         object_state[2] = (object_state[2], subclass_state)
         return tuple(object_state)
 
@@ -267,11 +272,16 @@ to sparse
         nd_state, own_state = state
         ndarray.__setstate__(self, nd_state)
 
-        index, fill_value, sp_index = own_state
+
+        index, fill_value, sp_index = own_state[:3]
+        name = None
+        if len(own_state) > 3:
+            name = own_state[3]
 
         self.sp_index = sp_index
         self.fill_value = fill_value
         self.index = index
+        self.name = name
 
     def __len__(self):
         return self.sp_index.length
@@ -342,7 +352,7 @@ to sparse
 
         dataSlice = self.values[key]
         new_index = Index(self.index.view(ndarray)[key])
-        return self._constructor(dataSlice, index=new_index)
+        return self._constructor(dataSlice, index=new_index, name=self.name)
 
     def _get_val_at(self, loc):
         n = len(self)
@@ -382,9 +392,6 @@ to sparse
 
         return result
 
-    def __getslice__(self, i, j):
-        return self._constructor(self.values[i:j], index=self.index[i:j])
-
     def __setitem__(self, key, value):
         raise Exception('SparseSeries objects are immutable')
 
@@ -398,9 +405,9 @@ to sparse
         if sparse_only:
             int_index = self.sp_index.to_int_index()
             index = self.index.take(int_index.indices)
-            return Series(self.sp_values, index=index)
+            return Series(self.sp_values, index=index, name=self.name)
         else:
-            return Series(self.values, index=self.index)
+            return Series(self.values, index=self.index, name=self.name)
 
     def astype(self, dtype=None):
         """
@@ -422,7 +429,7 @@ to sparse
             values = self.sp_values
         return SparseSeries(values, index=self.index,
                             sparse_index=self.sp_index,
-                            fill_value=self.fill_value)
+                            fill_value=self.fill_value, name=self.name)
 
     def reindex(self, index=None, method=None, copy=True):
         """
@@ -452,7 +459,7 @@ to sparse
         new_index, fill_vec = self.index.reindex(index, method=method)
         new_values = common.take_1d(self.values, fill_vec)
         return SparseSeries(new_values, index=new_index,
-                            fill_value=self.fill_value)
+                            fill_value=self.fill_value, name=self.name)
 
     def sparse_reindex(self, new_index):
         """
@@ -599,6 +606,22 @@ to sparse
                             sparse_index=new_sp_index,
                             fill_value=self.fill_value)
 
+    def combine_first(self, other):
+        """
+        Combine Series values, choosing the calling Series's values
+        first. Result index will be the union of the two indexes
+
+        Parameters
+        ----------
+        other : Series
+
+        Returns
+        -------
+        y : Series
+        """
+        dense_combined = self.to_dense().combine_first(other.to_dense())
+        return dense_combined.to_sparse(fill_value=self.fill_value)
+
 class SparseTimeSeries(SparseSeries, TimeSeries):
     pass
 
@@ -861,7 +884,10 @@ class SparseDataFrame(DataFrame):
         Retrieve column or slice from DataFrame
         """
         try:
-            return self._series[item]
+            # unsure about how kludgy this is
+            s = self._series[item]
+            s.name = item
+            return s
         except (TypeError, KeyError):
             if isinstance(item, slice):
                 dateRange = self.index[item]
@@ -903,7 +929,7 @@ class SparseDataFrame(DataFrame):
 
     values = property(as_matrix)
 
-    def xs(self, key):
+    def xs(self, key, axis=0, copy=False):
         """
         Returns a row (cross-section) from the SparseDataFrame as a Series
         object.
@@ -916,6 +942,10 @@ class SparseDataFrame(DataFrame):
         -------
         xs : Series
         """
+        if axis == 1:
+            data = self[key]
+            return data
+
         i = self.index.get_loc(key)
         series = self._series
         values = [series[k][i] for k in self.columns]
@@ -1070,6 +1100,11 @@ class SparseDataFrame(DataFrame):
         raise NotImplementedError
 
     def _join_index(self, other, how, lsuffix, rsuffix):
+        if isinstance(other, Series):
+            assert(other.name is not None)
+            other = SparseDataFrame({other.name : other},
+                                    default_fill_value=self.default_fill_value)
+
         join_index = self.index.join(other.index, how=how)
 
         this = self.reindex(join_index)
diff --git a/pandas/io/parsers.py b/pandas/io/parsers.py
index c4e1c962c..1ec552555 100644
--- a/pandas/io/parsers.py
+++ b/pandas/io/parsers.py
@@ -4,9 +4,6 @@ Module contains tools for processing files into DataFrames or other objects
 
 from datetime import datetime
 from itertools import izip
-import re
-import string
-
 import numpy as np
 
 from pandas.core.index import Index, MultiIndex
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index a292fc7bc..119cf2968 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -18,8 +18,7 @@ from pandas.core.api import (DataFrame, Index, Series, notnull, isnull,
 
 from pandas.util.testing import (assert_almost_equal,
                                  assert_series_equal,
-                                 assert_frame_equal,
-                                 randn)
+                                 assert_frame_equal)
 
 import pandas.util.testing as tm
 
@@ -48,16 +47,6 @@ class CheckIndexing(object):
         self.assert_('random' not in self.frame)
         self.assertRaises(Exception, self.frame.__getitem__, 'random')
 
-    def test_getitem_pop_assign_name(self):
-        s = self.frame['A']
-        self.assertEqual(s.name, 'A')
-
-        s = self.frame.pop('A')
-        self.assertEqual(s.name, 'A')
-
-        s = self.frame.ix[:, 'B']
-        self.assertEqual(s.name, 'B')
-
     def test_getitem_iterator(self):
         idx = iter(['A', 'B', 'C'])
         result = self.frame.ix[:, idx]
@@ -648,6 +637,19 @@ _mixed_frame['foo'] = 'bar'
 
 class SafeForSparse(object):
 
+    def test_getitem_pop_assign_name(self):
+        s = self.frame['A']
+        self.assertEqual(s.name, 'A')
+
+        s = self.frame.pop('A')
+        self.assertEqual(s.name, 'A')
+
+        s = self.frame.ix[:, 'B']
+        self.assertEqual(s.name, 'B')
+
+        s2 = s.ix[:]
+        self.assertEqual(s2.name, 'B')
+
     def test_join_index(self):
         # left / right
 
@@ -698,6 +700,15 @@ class SafeForSparse(object):
 
         self.assertRaises(Exception, f.join, f2, how='foo')
 
+    def test_join_index_series(self):
+        df = self.frame.copy()
+        s = df.pop(self.frame.columns[-1])
+        joined = df.join(s)
+        assert_frame_equal(joined, self.frame)
+
+        s.name = None
+        self.assertRaises(Exception, df.join, s)
+
     def test_join_overlap(self):
         df1 = self.frame.ix[:, ['A', 'B', 'C']]
         df2 = self.frame.ix[:, ['B', 'C', 'D']]
@@ -2552,6 +2563,9 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
             expected = _join_by_hand(df2, df1, how=kind)
             assert_frame_equal(joined, expected)
 
+    def test_join_on_series(self):
+        pass
+
     def test_clip(self):
         median = self.frame.median().median()
 
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 616f5608d..9bbc2e33d 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -75,9 +75,14 @@ class CheckNameIntegration(object):
         self.assertEquals(result2.name, s.name)
 
     def test_pickle_preserve_name(self):
-        s = Series(1, index=np.arange(10), name='foo')
-        unpickled = self._pickle_roundtrip(s)
-        self.assertEquals(s.name, unpickled.name)
+        unpickled = self._pickle_roundtrip(self.ts)
+        self.assertEquals(unpickled.name, self.ts.name)
+
+    def _pickle_roundtrip(self, obj):
+        obj.save('__tmp__')
+        unpickled = Series.load('__tmp__')
+        os.remove('__tmp__')
+        return unpickled
 
     def test_argsort_preserve_name(self):
         result = self.ts.argsort()
@@ -87,6 +92,10 @@ class CheckNameIntegration(object):
         result = self.ts.sort_index(ascending=False)
         self.assertEquals(result.name, self.ts.name)
 
+    def test_to_sparse_pass_name(self):
+        result = self.ts.to_sparse()
+        self.assertEquals(result.name, self.ts.name)
+
 class TestSeries(unittest.TestCase, CheckNameIntegration):
 
     def setUp(self):
diff --git a/pandas/tests/test_sparse.py b/pandas/tests/test_sparse.py
index 025ec042d..a7794d80c 100644
--- a/pandas/tests/test_sparse.py
+++ b/pandas/tests/test_sparse.py
@@ -26,6 +26,7 @@ from pandas.core.sparse import (IntIndex, BlockIndex,
 
 import test_frame
 import test_panel
+import test_series
 
 def _test_data1():
     # nan-based
@@ -101,7 +102,8 @@ def assert_sp_panel_equal(left, right, exact_indices=True):
     for item in right:
         assert(item in left)
 
-class TestSparseSeries(TestCase):
+class TestSparseSeries(TestCase,
+                       test_series.CheckNameIntegration):
 
     def setUp(self):
         arr, index = _test_data1()
@@ -109,6 +111,10 @@ class TestSparseSeries(TestCase):
         date_index = DateRange('1/1/2011', periods=len(index))
 
         self.bseries = SparseSeries(arr, index=index, kind='block')
+        self.bseries.name = 'bseries'
+
+        self.ts = self.bseries
+
         self.btseries = SparseSeries(arr, index=date_index, kind='block')
 
         self.iseries = SparseSeries(arr, index=index, kind='integer')
@@ -161,6 +167,11 @@ class TestSparseSeries(TestCase):
         assert_sp_series_equal(zbseries, self.zbseries)
         assert_sp_series_equal(ziseries, self.ziseries)
 
+    def test_to_dense_preserve_name(self):
+        assert(self.bseries.name is not None)
+        result = self.bseries.to_dense()
+        self.assertEquals(result.name, self.bseries.name)
+
     def test_constructor(self):
         # test setup guys
         self.assert_(np.isnan(self.bseries.fill_value))

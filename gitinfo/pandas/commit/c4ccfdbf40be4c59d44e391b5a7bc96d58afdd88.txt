commit c4ccfdbf40be4c59d44e391b5a7bc96d58afdd88
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Sep 6 11:50:06 2011 -0400

    DOC: time series docs, timeRule->time_rule renaming

diff --git a/RELEASE.rst b/RELEASE.rst
index 370a77bf0..3ae6988a3 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -104,7 +104,7 @@ Release notes
     copied then the resulting object is indexed the same
   - Added `sort_index` methods to Series and WidePanel. Renamed `DataFrame.sort`
     to `sort_index`. Leaving `DataFrame.sort` for now.
-
+v
 **Improvements to existing features**
 
   * The 2-dimensional `DataFrame` and `DataMatrix` classes have been extensively
@@ -217,6 +217,7 @@ Release notes
     anymore since the output file can be read back without it. However, there
     is a new ``index_label`` argument. So you can do ``index_label='index'`` to
     emulate the old behavior
+  * `datetools.Week` argument renamed from `dayOfWeek` to `weekday`
 
 **Bug fixes**
 
diff --git a/doc/source/datetools.rst b/doc/source/datetools.rst
deleted file mode 100644
index f98f4124e..000000000
--- a/doc/source/datetools.rst
+++ /dev/null
@@ -1,208 +0,0 @@
-.. currentmodule:: pandas
-
-.. _datetools:
-
-************************
-Date and frequency tools
-************************
-
-In dealing with the economic realities of time series data, we will
-frequently seek to:
-
-* generate sequences of fixed-frequency dates
-
-* conform or convert time series to a particular frequency
-
-* compute "relative" dates based on various non-standard time
-  increments (e.g. 5 business days before the last business day of the
-  year), or "roll" dates forward or backward
-
-pandas provides a relatively compact and self-contained set of tools
-for performing the above tasks. The functionality revolves around the
-**DateOffset** class and its subclasses, which are objects which can
-be added and subtracted from regular Python **datetime** objects.
-
-.. _datetools.offsets:
-
-DateOffset and subclasses
--------------------------
-
-A **DateOffset** instance represents a frequency increment. Different
-offset logic via subclasses. The vanilla version of the DateOffset
-works identically to an object in the dateutil package,
-dateutil.relativedelta, which works like:
-
-::
-
-    >>> d = datetime(2008, 8, 18)
-    >>> d + relativedelta(months=4, days=5)
-    datetime.datetime(2008, 12, 23, 0, 0)
-
-The basic DateOffset class accepts the same set of arguments that
-relativedelta does:
-
-::
-
-    >>> d + DateOffset(months=4, days=5)
-    datetime.datetime(2008, 12, 23, 0, 0)
-
-The key characteristics of a DateOffset are:
-
-* it can be added / subtracted to/from a datetime object to obtain a
-  shifted date
-
-* it can be multiplied by an integer to multiple the effect as
-  desired
-
-Subclasses of DateOffset define specialized logic for various
-increments of interest, such a weekday / business day.
-
-::
-
-    class BDay(DateOffset):
-	"""DateOffset increments between business days"""
-	def apply(self, other):
-	    ...
-
-::
-
-    >>> d - 5 * BDay()
-    datetime.datetime(2008, 8, 11, 0, 0)
-
-A subclass need only redefine the method 'apply' which describes the
-interaction with a datetime object.
-
-::
-
-    >>> d + BMonthEnd(0)
-    datetime.datetime(2008, 8, 29, 0, 0)
-
-An offset is also *callable* as functions to avoid those times where
-you might otherwise create a lambda, for example:
-
-::
-
-    map(BDay(), dateList) versus
-    map(lambda x: x + BDay(), dateList)
-
-.. csv-table::
-    :header: "Class name", "Description"
-    :widths: 15, 65
-
-    DateOffset, "Generic offset, arguments as **datetime.relativedelta**"
-    BDay, "business day (weekday)"
-    Week, "one week, optionally anchored on a day of the week"
-    MonthEnd, "calendar month end"
-    BMonthEnd, "business month end"
-    YearEnd, "calendar year end"
-    YearBegin, "calendar year begin"
-    BYearEnd, "business year end"
-    Hour, "one hour"
-    Minute, "one minute"
-    Second, "one second"
-
-.. _daterange:
-
-Creating date ranges (DateRange)
---------------------------------
-
-The DateRange class utilizes these offsets (and any ones that we might
-add) to generate lists of dates for general purposes:
-
-::
-
-    In [327]: DateRange(start=d, nPeriods=10, offset=daterange.bmonthEnd)
-    Out[327]:
-    [datetime.datetime(2008, 8, 29, 0, 0),
-     datetime.datetime(2008, 9, 30, 0, 0),
-     datetime.datetime(2008, 10, 31, 0, 0),
-     datetime.datetime(2008, 11, 28, 0, 0),
-     datetime.datetime(2008, 12, 31, 0, 0),
-     datetime.datetime(2009, 1, 30, 0, 0),
-     datetime.datetime(2009, 2, 27, 0, 0),
-     datetime.datetime(2009, 3, 31, 0, 0),
-     datetime.datetime(2009, 4, 30, 0, 0),
-     datetime.datetime(2009, 5, 29, 0, 0)]
-
-
-One can also specify a 'toDate', the endpoints are included if and
-only if they lie on the offset (so here, d was today, and is not
-included)
-
-There's a lot of general usefulness in these date ranges and offsets,
-among others:
-
-1) you can reindex a TimeSeries or DataFrame with them
-
-2) you can use them to do groupby statistics (use a 0-parameter offset
-to 'roll' all your dates to the next offset, e.g. EOM date)
-
-3) you can use them to shift the index of your TimeSeries or DataFrame
-by some amount:
-
-::
-
-    In [334]: ts
-    Out[334]:
-    2007-09-28 00:00:00     0.01025
-    2007-10-31 00:00:00     0.0059684
-    2007-11-30 00:00:00     -0.063186
-    2007-12-31 00:00:00     -0.037049
-    2008-01-31 00:00:00     -0.10556
-    2008-02-29 00:00:00     -0.020221
-    2008-03-31 00:00:00     -0.046154
-    2008-04-30 00:00:00     0.095594
-    2008-05-30 00:00:00     0.031957
-    2008-06-30 00:00:00     -0.058455
-
-    In [335]: ts.shift(5, offset=daterange.bday)
-    Out[335]:
-    2007-10-05 00:00:00     0.01025
-    2007-11-07 00:00:00     0.0059684
-    2007-12-07 00:00:00     -0.063186
-    2008-01-07 00:00:00     -0.037049
-    2008-02-07 00:00:00     -0.10556
-    2008-03-07 00:00:00     -0.020221
-    2008-04-07 00:00:00     -0.046154
-    2008-05-07 00:00:00     0.095594
-    2008-06-06 00:00:00     0.031957
-    2008-07-07 00:00:00     -0.058455
-
-Tips for custom frequencies
----------------------------
-
-.. _datetools.timerules:
-
-Time rules
-----------
-
-A number of string aliases are given to useful common time series
-frequencies. We will refer to these aliases as *time rules*.
-
-.. csv-table::
-    :header: "Rule name", "Description"
-    :widths: 15, 65
-
-    "WEEKDAY", "business day frequency"
-    "EOM", "business month end frequency"
-    "W\@MON", "weekly frequency (mondays)"
-    "W\@TUE", "weekly frequency (tuesdays)"
-    "W\@WED", "weekly frequency (wednesdays)"
-    "W\@THU", "weekly frequency (thursdays)"
-    "W\@FRI", "weekly frequency (fridays)"
-    "Q\@JAN", "quarterly frequency, starting January"
-    "Q\@FEB", "quarterly frequency, starting February"
-    "Q\@MAR", "quarterly frequency, starting March"
-    "A\@DEC", "annual frequency, year end (December)"
-    "A\@JAN", "annual frequency, anchored end of January"
-    "A\@FEB", "annual frequency, anchored end of February"
-    "A\@MAR", "annual frequency, anchored end of March"
-    "A\@APR", "annual frequency, anchored end of April"
-    "A\@MAY", "annual frequency, anchored end of May"
-    "A\@JUN", "annual frequency, anchored end of June"
-    "A\@JUL", "annual frequency, anchored end of July"
-    "A\@AUG", "annual frequency, anchored end of August"
-    "A\@SEP", "annual frequency, anchored end of September"
-    "A\@OCT", "annual frequency, anchored end of October"
-    "A\@NOV", "annual frequency, anchored end of November"
-
diff --git a/doc/source/index.rst b/doc/source/index.rst
index dcf71731c..c05a23064 100755
--- a/doc/source/index.rst
+++ b/doc/source/index.rst
@@ -119,7 +119,6 @@ See the package overview for more detail about what's in the library.
     merging
     reshaping
     timeseries
-    datetools
     visualization
     stats
     io
diff --git a/doc/source/timeseries.rst b/doc/source/timeseries.rst
index 71b6ced69..32214a3f0 100644
--- a/doc/source/timeseries.rst
+++ b/doc/source/timeseries.rst
@@ -1,27 +1,258 @@
 .. currentmodule:: pandas
 .. _timeseries:
 
+.. ipython:: python
+   :suppress:
+
+   import numpy as np
+   np.random.seed(123456)
+   from pandas import *
+   randn = np.random.randn
+   np.set_printoptions(precision=4, suppress=True)
+   from dateutil import relativedelta
+   from pandas.core.datetools import *
+
 ********************************
 Time Series / Date functionality
 ********************************
 
+pandas has proven very successful as a tool for working with time series data,
+especially in the financial data analysis space. Over the coming year we will
+be looking to consolidate the various Python libraries for time series data,
+e.g. ``scikits.timeseries``, using the new NumPy ``datetime64`` dtype, to
+create a very nice integrated solution. Everything in pandas at the moment is
+based on using Python ``datetime`` objects.
 
-TimeSeries-oriented methods
----------------------------
+In working with time series data, we will frequently seek to:
+
+  - generate sequences of fixed-frequency dates
+  - conform or convert time series to a particular frequency
+  - compute "relative" dates based on various non-standard time increments
+    (e.g. 5 business days before the last business day of the year), or "roll"
+    dates forward or backward
+
+pandas provides a relatively compact and self-contained set of tools for
+performing the above tasks.
+
+.. note::
+
+   This area of pandas has gotten less development attention recently, though
+   this should change in the near future.
+
+.. _timeseries.offsets:
+
+DateOffset objects
+------------------
+
+A ``DateOffset`` instance represents a frequency increment. Different offset
+logic via subclasses:
+
+.. csv-table::
+    :header: "Class name", "Description"
+    :widths: 15, 65
+
+    DateOffset, "Generic offset class, defaults to 1 calendar day"
+    BDay, "business day (weekday)"
+    Week, "one week, optionally anchored on a day of the week"
+    MonthEnd, "calendar month end"
+    BMonthEnd, "business month end"
+    BQuarterEnd, "business quarter end"
+    YearEnd, "calendar year end"
+    YearBegin, "calendar year begin"
+    BYearEnd, "business year end"
+    Hour, "one hour"
+    Minute, "one minute"
+    Second, "one second"
+
+The basic ``DateOffset`` takes the same arguments as
+``dateutil.relativedelta``, which works like:
+
+.. ipython:: python
+
+   d = datetime(2008, 8, 18)
+   d + relativedelta(months=4, days=5)
+
+We could have done the same thing with ``DateOffset``:
+
+.. ipython:: python
+
+   d + DateOffset(months=4, days=5)
+
+The key features of a ``DateOffset`` object are:
+
+  - it can be added / subtracted to/from a datetime object to obtain a
+    shifted date
+  - it can be multiplied by an integer (positive or negative) so that the
+    increment will be applied multiple times
+  - it has ``rollforward`` and ``rollback`` methods for moving a date forward
+    or backward to the next or previous "offset date"
+
+Subclasses of ``DateOffset`` define the ``apply`` function which dictates
+custom date increment logic, such as adding business days:
+
+.. code-block:: python
+
+    class BDay(DateOffset):
+	"""DateOffset increments between business days"""
+        def apply(self, other):
+            ...
+
+.. ipython:: python
+
+   d - 5 * BDay()
+   d + BMonthEnd()
+
+The ``rollforward`` and ``rollback`` methods do exactly what you would expect:
+
+.. ipython:: python
+
+   d
+   offset = BMonthEnd()
+   offset.rollforward(d)
+   offset.rollback(d)
+
+It's definitely worth exploring the ``pandas.core.datetools`` module and the
+various docstrings for the classes.
+
+Parametric offsets
+~~~~~~~~~~~~~~~~~~
+
+Some of the offsets can be "parameterized" when created to result in different
+behavior. For example, the ``Week`` offset for generating weekly data accepts a
+``weekday`` parameter which results in the generated dates always lying on a
+particular day of the week:
+
+.. ipython:: python
+
+   d + Week()
+   d + Week(weekday=4)
+   (d + Week(weekday=4)).weekday()
+
+Time rules
+~~~~~~~~~~
+
+A number of string aliases are given to useful common time series
+frequencies. We will refer to these aliases as *time rules*.
+
+.. csv-table::
+    :header: "Rule name", "Description"
+    :widths: 15, 65
+
+    "WEEKDAY", "business day frequency"
+    "EOM", "business month end frequency"
+    "W\@MON", "weekly frequency (mondays)"
+    "W\@TUE", "weekly frequency (tuesdays)"
+    "W\@WED", "weekly frequency (wednesdays)"
+    "W\@THU", "weekly frequency (thursdays)"
+    "W\@FRI", "weekly frequency (fridays)"
+    "Q\@JAN", "quarterly frequency, starting January"
+    "Q\@FEB", "quarterly frequency, starting February"
+    "Q\@MAR", "quarterly frequency, starting March"
+    "A\@DEC", "annual frequency, year end (December)"
+    "A\@JAN", "annual frequency, anchored end of January"
+    "A\@FEB", "annual frequency, anchored end of February"
+    "A\@MAR", "annual frequency, anchored end of March"
+    "A\@APR", "annual frequency, anchored end of April"
+    "A\@MAY", "annual frequency, anchored end of May"
+    "A\@JUN", "annual frequency, anchored end of June"
+    "A\@JUL", "annual frequency, anchored end of July"
+    "A\@AUG", "annual frequency, anchored end of August"
+    "A\@SEP", "annual frequency, anchored end of September"
+    "A\@OCT", "annual frequency, anchored end of October"
+    "A\@NOV", "annual frequency, anchored end of November"
+
+These can be used as arguments to ``DateRange`` and various other time
+series-related functions in pandas.
+
+.. _timeseries.daterange:
+
+Generating date ranges (DateRange)
+----------------------------------
+
+The ``DateRange`` class utilizes these offsets (and any ones that we might add)
+to generate fixed-frequency date ranges:
+
+.. ipython:: python
+
+   start = datetime(2009, 1, 1)
+   end = datetime(2010, 1, 1)
+
+   rng = DateRange(start, end, offset=BDay())
+   rng
+   DateRange(start, end, offset=BMonthEnd())
+
+**Business day frequency** is the default for ``DateRange``. You can also
+strictly generate a ``DateRange`` of a certain length by providing either a
+start or end date and a ``periods`` argument:
+
+.. ipython:: python
+
+   DateRange(start, periods=20)
+   DateRange(end=end, periods=20)
+
+The start and end dates are strictly inclusive. So it will not generate any
+dates outside of those dates if specified.
+
+DateRange is a valid Index
+~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+One of the main uses for ``DateRange`` is as an index for pandas objects. When
+working with a lot of time series data, there are several reasons to use
+``DateRange`` objects when possible:
+
+  - A large range of dates for various offsets are pre-computed and cached
+    under the hood in order to make generating subsequent date ranges very fast
+    (just have to grab a slice)
+  - Fast shifting using the ``shift`` method on pandas objects
+  - Unioning of overlapping DateRange objects with the same frequency is very
+    fast (important for fast data alignment)
+
+The ``DateRange`` is a valid index and can even be intelligent when doing
+slicing, etc.
+
+.. ipython:: python
+
+   rng = DateRange(start, end, offset=BMonthEnd())
+   ts = Series(randn(len(rng)), index=rng)
+   ts.index
+   ts[:5].index
+   ts[::2].index
+
+More complicated fancy indexing will result in an ``Index`` that is no longer a
+``DateRange``, however:
+
+.. ipython:: python
+
+   ts[[0, 2, 6]].index
+
+Time series-related instance methods
+------------------------------------
 
 .. seealso::
-    :ref:`Reindexing methods <series.reindexing>`;
-    :ref:`DateRange and date offsets / time rules <datetools>`
+    :ref:`Reindexing methods <basics.reindexing>`
 
 .. note::
 
-    While pandas does not force you to sort your dates, many of these
-    methods may have unexpected or incorrect behavior in that case. In
-    other words, *be careful*.
+    While pandas does not force you to have a sorted date index, some of these
+    methods may have unexpected or incorrect behavior if the dates are
+    unsorted. So please be careful.
+
+Shifting / lagging
+~~~~~~~~~~~~~~~~~~
+
+One may want to *shift* or *lag* the values in a TimeSeries back and forward in
+time. The method for this is ``shift``, which is available on all of the pandas
+objects. In DataFrame, ``shift`` will currently only shift along the ``index``
+and in Panel along the ``major_axis``.
+
+.. ipython:: python
 
-When working with time series data, a number of different
-time-oriented operations may be useful. The first is **frequency
-conversion**, which has similar options to :func:`Series.reindex`:
+   ts = ts[:5]
+   ts.shift(1)
+   ts.shift(5, offset=datetools.bday)
+
+Frequency conversion
+~~~~~~~~~~~~~~~~~~~~
 
 ::
 
@@ -54,43 +285,8 @@ conversion**, which has similar options to :func:`Series.reindex`:
     2010-10-28 00:00:00    8.0
     2010-10-29 00:00:00    9.0
 
-We often will also want to **shift** or *lag* a TimeSeries:
-
-::
+Filling forward / backward
+~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-    >>> ts.shift(1)
-    2010-01-29 00:00:00    NaN
-    2010-02-26 00:00:00    0.0
-    2010-03-31 00:00:00    1.0
-    2010-04-30 00:00:00    2.0
-    2010-05-31 00:00:00    3.0
-    2010-06-30 00:00:00    4.0
-    2010-07-30 00:00:00    5.0
-    2010-08-31 00:00:00    6.0
-    2010-09-30 00:00:00    7.0
-    2010-10-29 00:00:00    8.0
-
-    >>> ts.shift(5, offset=datetools.bday)
-    2010-02-05 00:00:00    0.0
-    2010-03-05 00:00:00    1.0
-    2010-04-07 00:00:00    2.0
-    2010-05-07 00:00:00    3.0
-    2010-06-07 00:00:00    4.0
-    2010-07-07 00:00:00    5.0
-    2010-08-06 00:00:00    6.0
-    2010-09-07 00:00:00    7.0
-    2010-10-07 00:00:00    8.0
-    2010-11-05 00:00:00    9.0
-
-In the presence of missing data with sorted dates
-
-A convenience method for selecting weekdays, similar to
-:mod:`scikits.timeseries` is also provided:
-
-::
-
-    >>> dr = DateRange('1/1/2010', periods=10, offset=datetools.bday)
-    >>> ts = Series(np.arange(10.), index=dr)
-    >>> ts[ts.weekday == 2]
-    2010-01-06 00:00:00    3.0
-    2010-01-13 00:00:00    8.0
+TimeSeries-oriented methods
+---------------------------
diff --git a/pandas/core/common.py b/pandas/core/common.py
index c150cf322..7206a2555 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -67,10 +67,7 @@ def notnull(input):
     -------
     boolean ndarray or boolean
     '''
-    if isinstance(input, np.ndarray):
-        return -isnull(input)
-    else:
-        return not _tseries.checknull(input)
+    return np.negative(isnull(input))
 
 def _pickle_array(arr):
     arr = arr.view(np.ndarray)
diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index 0123f0ca1..eb6c55342 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -39,20 +39,22 @@ class DateRange(Index):
         Number of periods to generate.
     offset : DateOffset, default is 1 BusinessDay
         Used to determine the dates returned
-    timeRule : timeRule to use
+    time_rule : time_rule to use
     tzinfo : pytz.timezone
         To endow DateRange with time zone information
     """
     _cache = {}
     def __new__(cls, start=None, end=None, periods=None,
-                offset=datetools.bday, timeRule=None,
+                offset=datetools.bday, time_rule=None,
                 tzinfo=None, **kwds):
-        if timeRule is not None:
-            offset = datetools.getOffset(timeRule)
 
-        if timeRule is None:
+        time_rule = kwds.get('timeRule', time_rule)
+        if time_rule is not None:
+            offset = datetools.getOffset(time_rule)
+
+        if time_rule is None:
             if offset in datetools._offsetNames:
-                timeRule = datetools._offsetNames[offset]
+                time_rule = datetools._offsetNames[offset]
 
         # Cachable
         if not start:
@@ -73,12 +75,12 @@ class DateRange(Index):
 
         if useCache:
             index = cls._cached_range(start, end, periods=periods,
-                                      offset=offset, timeRule=timeRule)
+                                      offset=offset, time_rule=time_rule)
             if tzinfo is None:
                 return index
         else:
             xdr = generate_range(start=start, end=end, periods=periods,
-                                 offset=offset, timeRule=timeRule)
+                                 offset=offset, time_rule=time_rule)
             index = list(xdr)
 
         if tzinfo is not None:
@@ -117,11 +119,11 @@ class DateRange(Index):
 
     @classmethod
     def _cached_range(cls, start=None, end=None, periods=None, offset=None,
-                      timeRule=None):
+                      time_rule=None):
 
         # HACK: fix this dependency later
-        if timeRule is not None:
-            offset = datetools.getOffset(timeRule)
+        if time_rule is not None:
+            offset = datetools.getOffset(time_rule)
 
         if offset is None:
             raise Exception('Must provide a DateOffset!')
@@ -337,7 +339,7 @@ class DateRange(Index):
         return True
 
 def generate_range(start=None, end=None, periods=None,
-                   offset=datetools.BDay(), timeRule=None):
+                   offset=datetools.BDay(), time_rule=None):
     """
     Generates a sequence of dates corresponding to the specified time
     offset. Similar to dateutil.rrule except uses pandas DateOffset
@@ -365,12 +367,12 @@ def generate_range(start=None, end=None, periods=None,
     DateRange, dateutil.rrule
     """
 
-    if timeRule is not None:
-        offset = datetools.getOffset(timeRule)
+    if time_rule is not None:
+        offset = datetools.getOffset(time_rule)
 
-    if timeRule is None:
+    if time_rule is None:
         if offset in datetools._offsetNames:
-            timeRule = datetools._offsetNames[offset]
+            time_rule = datetools._offsetNames[offset]
 
     start = datetools.to_datetime(start)
     end = datetools.to_datetime(end)
diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index c92fd91d8..7a3a82065 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -326,14 +326,10 @@ class Week(DateOffset, CacheableOffset):
     """
     Weekly offset
 
-    weekday
-    0: Mondays
-    1: Tuedays
-    2: Wednesdays
-    3: Thursdays
-    4: Fridays
-    5: Saturdays
-    6: Sundays
+    Parameters
+    ----------
+    weekday : int, default None
+        Always generate specific day of week. 0 for Monday
     """
     _normalizeFirst = True
     def __init__(self, n=1, **kwds):
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index f852682f8..f49f2da3d 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -1754,7 +1754,7 @@ class DataFrame(NDFrame):
         if isinstance(freq, datetools.DateOffset):
             dateRange = DateRange(self.index[0], self.index[-1], offset=freq)
         else:
-            dateRange = DateRange(self.index[0], self.index[-1], timeRule=freq)
+            dateRange = DateRange(self.index[0], self.index[-1], time_rule=freq)
 
         return self.reindex(dateRange, method=method)
 
@@ -1773,7 +1773,7 @@ class DataFrame(NDFrame):
         """
         return self - self.shift(periods)
 
-    def shift(self, periods, offset=None, timeRule=None):
+    def shift(self, periods, offset=None, time_rule=None, **kwds):
         """
         Shift the index of the DataFrame by desired number of periods with an
         optional time offset
@@ -1784,7 +1784,7 @@ class DataFrame(NDFrame):
             Number of periods to move, can be positive or negative
         offset : DateOffset, optional
             Increment to use from datetools module
-        timeRule : string
+        time_rule : string
             Time rule to use by name
 
         Returns
@@ -1794,8 +1794,9 @@ class DataFrame(NDFrame):
         if periods == 0:
             return self
 
-        if timeRule is not None and offset is None:
-            offset = datetools.getOffset(timeRule)
+        time_rule = kwds.get('timeRule', time_rule)
+        if time_rule is not None and offset is None:
+            offset = datetools.getOffset(time_rule)
 
         def _shift_block(blk, indexer):
             new_values = blk.values.take(indexer, axis=1)
@@ -2213,14 +2214,17 @@ class DataFrame(NDFrame):
             return self._count_level(level, axis=axis,
                                      numeric_only=numeric_only)
 
-        try:
-            y, axis_labels = self._get_agg_data(axis,
-                                                numeric_only=numeric_only)
-            mask = notnull(y)
-            return Series(mask.sum(axis), index=axis_labels)
-        except Exception:
-            f = lambda s: notnull(s).sum()
-            return self.apply(f, axis=axis)
+        if numeric_only:
+            try:
+                y, axis_labels = self._get_agg_data(axis, numeric_only=True)
+                mask = notnull(y)
+                return Series(mask.sum(axis), index=axis_labels)
+            except Exception:
+                f = lambda s: notnull(s).sum()
+                return self.apply(f, axis=axis)
+        else:
+            result = notnull(self.values).sum(axis)
+            return Series(result, index=self._get_agg_axis(axis))
 
     def _count_level(self, level, axis=0, numeric_only=False):
         # TODO: deal with sortedness??
diff --git a/pandas/core/reshape.py b/pandas/core/reshape.py
index 3c1d79738..28944b4db 100644
--- a/pandas/core/reshape.py
+++ b/pandas/core/reshape.py
@@ -128,8 +128,10 @@ class _Unstacker(object):
         new_values = np.empty((length, result_width), dtype=self.values.dtype)
         new_mask = np.zeros((length, result_width), dtype=bool)
 
-        if not issubclass(self.values.dtype.type, np.integer):
-            new_values.fill(np.nan)
+        if issubclass(self.values.dtype.type, np.integer):
+            new_values = new_values.astype(float)
+
+        new_values.fill(np.nan)
 
         # is there a simpler / faster way of doing this?
         for i in xrange(self.values.shape[1]):
diff --git a/pandas/core/series.py b/pandas/core/series.py
index c4b95a066..7108c4257 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1446,7 +1446,7 @@ copy : boolean, default False
     #----------------------------------------------------------------------
     # Time series-oriented methods
 
-    def shift(self, periods, offset=None, timeRule=None):
+    def shift(self, periods, offset=None, time_rule=None, **kwds):
         """
         Shift the index of the Series by desired number of periods with an
         optional time offset
@@ -1457,7 +1457,7 @@ copy : boolean, default False
             Number of periods to move, can be positive or negative
         offset : DateOffset or timedelta, optional
             Increment to use from datetools module
-        timeRule : string, optional
+        time_rule : string, optional
             time rule name to use by name (e.g. 'WEEKDAY')
 
         Returns
@@ -1467,8 +1467,9 @@ copy : boolean, default False
         if periods == 0:
             return self.copy()
 
-        if timeRule is not None and offset is None:
-            offset = datetools.getOffset(timeRule)
+        time_rule = kwds.get('timeRule', time_rule)
+        if time_rule is not None and offset is None:
+            offset = datetools.getOffset(time_rule)
 
         if offset is None:
             new_values = np.empty(len(self), dtype=self.dtype)
@@ -1541,7 +1542,7 @@ copy : boolean, default False
         if isinstance(freq, datetools.DateOffset):
             dateRange = DateRange(self.index[0], self.index[-1], offset=freq)
         else:
-            dateRange = DateRange(self.index[0], self.index[-1], timeRule=freq)
+            dateRange = DateRange(self.index[0], self.index[-1], time_rule=freq)
 
         return self.reindex(dateRange, method=method)
 
diff --git a/pandas/tests/test_daterange.py b/pandas/tests/test_daterange.py
index 95603bcd6..bcb408ab4 100644
--- a/pandas/tests/test_daterange.py
+++ b/pandas/tests/test_daterange.py
@@ -23,7 +23,7 @@ START, END = datetime(2009, 1, 1), datetime(2010, 1, 1)
 class TestDateRangeGeneration(unittest.TestCase):
     def test_generate(self):
         rng1 = list(generate_range(START, END, offset=datetools.bday))
-        rng2 = list(generate_range(START, END, timeRule='WEEKDAY'))
+        rng2 = list(generate_range(START, END, time_rule='WEEKDAY'))
         self.assert_(np.array_equal(rng1, rng2))
 
     def test_1(self):
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index 1db65f0cb..42d73390c 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -983,7 +983,7 @@ class TestLongPanel(unittest.TestCase):
         # weird overlap, TODO: test?
         a, b, c = (np.array([1, 2, 3, 4, 4]),
                    np.array(['a', 'a', 'a', 'a', 'a']),
-                   np.array([1, 2, 3, 5, 4]))
+                   np.array([1., 2., 3., 4., 5.]))
         df = pivot(a, b, c)
         expected = _slow_pivot(a, b, c)
         assert_frame_equal(df, expected)

commit ee6262d08603c4e3e82d3e91ee8c1eefe90a6012
Author: Adam Klein <adamklein@gmail.com>
Date:   Thu Mar 1 17:14:26 2012 -0500

    ENH: deprecate timeRule and offset in shift method, clean up cython build

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index baf36f5cd..8e927c616 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -2849,7 +2849,7 @@ class DataFrame(NDFrame):
         """
         return self - self.shift(periods)
 
-    def shift(self, periods, offset=None, **kwds):
+    def shift(self, periods, freq=None, **kwds):
         """
         Shift the index of the DataFrame by desired number of periods with an
         optional time offset
@@ -2868,13 +2868,23 @@ class DataFrame(NDFrame):
         if periods == 0:
             return self
 
-        offset = kwds.get('timeRule', offset)
-        if isinstance(offset, basestring):
-            # deprecated code path
-            if isinstance(self.index, DateRange):
+        if 'timeRule' in kwds or 'offset' in kwds:
+            offset = kwds.get('offset')
+            offset = kwds.get('timeRule', offset)
+            if isinstance(offset, basestring):
                 offset = datetools.getOffset(offset)
-            else:
-                offset = datetools.to_offset(offset)
+            warn = True
+        else:
+            offset = freq
+            warn = False
+
+        if warn:
+            import warnings
+            warnings.warn("'timeRule' and 'offset' parameters are deprecated,"
+                          " please use 'freq' instead", FutureWarning)
+
+        if isinstance(offset, basestring):
+            offset = datetools.to_offset(offset)
 
         def _shift_block(blk, indexer):
             new_values = blk.values.take(indexer, axis=1)
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 523171431..ae1f56add 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1125,7 +1125,10 @@ class DatetimeIndex(Int64Index):
                 _deprecated=False, **kwds):
 
         if isinstance(offset, basestring):
-            offset = datetools.getOffset(offset, _deprecated=_deprecated)
+            if _deprecated:
+                offset = datetools.getOffset(offset)
+            else:
+                offset = datetools.to_offset(offset)
 
         if data is None and offset is None:
             raise ValueError("Must provide offset argument if no data is "
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 331f9f30b..dd0176c48 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2236,7 +2236,7 @@ copy : boolean, default False
     #----------------------------------------------------------------------
     # Time series-oriented methods
 
-    def shift(self, periods, offset=None, **kwds):
+    def shift(self, periods, freq=None, **kwds):
         """
         Shift the index of the Series by desired number of periods with an
         optional time offset
@@ -2245,7 +2245,7 @@ copy : boolean, default False
         ----------
         periods : int
             Number of periods to move, can be positive or negative
-        offset : DateOffset, timedelta, or time rule string, optional
+        freq : DateOffset, timedelta, or time rule string, optional
             Increment to use from datetools module or time rule (e.g. 'EOM')
 
         Returns
@@ -2255,13 +2255,23 @@ copy : boolean, default False
         if periods == 0:
             return self.copy()
 
-        offset = kwds.get('timeRule', offset)
-        if isinstance(offset, basestring):
-            # deprecated code path
-            if isinstance(self.index, DateRange):
+        if 'timeRule' in kwds or 'offset' in kwds:
+            offset = kwds.get('offset')
+            offset = kwds.get('timeRule', offset)
+            if isinstance(offset, basestring):
                 offset = datetools.getOffset(offset)
-            else:
-                offset = datetools.to_offset(offset)
+            warn = True
+        else:
+            offset = freq
+            warn = False
+
+        if warn:
+            import warnings
+            warnings.warn("'timeRule' and 'offset' parameters are deprecated,"
+                          " please use 'freq' instead", FutureWarning)
+
+        if isinstance(offset, basestring):
+            offset = datetools.to_offset(offset)
 
         if offset is None:
             new_values = np.empty(len(self), dtype=self.dtype)
@@ -2326,7 +2336,7 @@ copy : boolean, default False
 
         Parameters
         ----------
-        offset : DateOffset object, or corresponding string
+        freq : DateOffset object, or corresponding string
             DateOffset object or subclass (e.g. monthEnd)
         method : {'backfill', 'pad', None}
             Method to use for filling holes in new index
@@ -2336,8 +2346,6 @@ copy : boolean, default False
         converted : TimeSeries
         """
 
-        # TODO: this uses deprecated API, add new method?
-
         if isinstance(freq, datetools.DateOffset):
             dateRange = DateRange(self.index[0], self.index[-1], offset=freq)
         else:
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index cb5144c7c..36524a295 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -14,8 +14,8 @@ from datetime cimport *
 from util cimport is_integer_object, is_datetime64_object
 
 # initialize numpy
-np.import_array()
-np.import_ufunc()
+import_array()
+import_ufunc()
 
 # import datetime C API
 PyDateTime_IMPORT
@@ -199,22 +199,22 @@ cdef convert_to_tsobject(object ts, object tzinfo=None):
 
     return retval
 
-cdef convert_to_res(object res):
-    if res == 'microsecond':
-        return r_microsecond
-    if res == 'second':
-        return r_second
-    if res == 'minute':
-        return r_minute
-    if res == 'hour':
-        return r_hour
-    if res == 'day':
-        return r_day
-    if res == 'month':
-        return r_month
-    if res == 'year':
-        return r_year
-    return r_invalid
+#cdef convert_to_res(object res):
+#    if res == 'microsecond':
+#        return r_microsecond
+#    if res == 'second':
+#        return r_second
+#    if res == 'minute':
+#        return r_minute
+#    if res == 'hour':
+#        return r_hour
+#    if res == 'day':
+#        return r_day
+#    if res == 'month':
+#        return r_month
+#    if res == 'year':
+#        return r_year
+#    return r_invalid
 
 cdef conversion_factor(time_res res1, time_res res2):
     cdef:
diff --git a/pandas/src/groupby.pyx b/pandas/src/groupby.pyx
index 16f1fa3f3..ebf61dfe0 100644
--- a/pandas/src/groupby.pyx
+++ b/pandas/src/groupby.pyx
@@ -452,25 +452,25 @@ def generate_bins_dt64(ndarray[int64_t] values, ndarray[int64_t] binner,
 
     return bins, labels
 
-@cython.boundscheck(False)
-@cython.wraparound(False)
-cdef ndarray[int32_t] counts_by_bins(ndarray[int32_t] bins,
-                                     Py_ssize_t datalen):
-    cdef:
-        Py_ssize_t ngroups = len(bins)
-        i = 0
-
-    counts = np.zeros(ngroups, dtype='i4')
-
-    if ngroups > 0:
-        counts[0] = bins[0]
-        for i in range(1, ngroups):
-            if i == ngroups - 1:
-                counts[i] = datalen - bins[i-1]
-            else:
-                counts[i] = bins[i] - bins[i-1]
-
-    return counts
+#@cython.boundscheck(False)
+#@cython.wraparound(False)
+#cdef ndarray[int32_t] counts_by_bins(ndarray[int32_t] bins,
+#                                     Py_ssize_t datalen):
+#    cdef:
+#        Py_ssize_t ngroups = len(bins)
+#        i = 0
+
+#    counts = np.zeros(ngroups, dtype='i4')
+
+#    if ngroups > 0:
+#        counts[0] = bins[0]
+#        for i in range(1, ngroups):
+#            if i == ngroups - 1:
+#                counts[i] = datalen - bins[i-1]
+#            else:
+#                counts[i] = bins[i] - bins[i-1]
+
+#    return counts
 
 # add passing bin edges, instead of labels
 
diff --git a/pandas/src/np_datetime.c b/pandas/src/np_datetime.c
index fefe29567..dcd67f9ff 100644
--- a/pandas/src/np_datetime.c
+++ b/pandas/src/np_datetime.c
@@ -4,19 +4,15 @@
  * See NP_LICENSE.txt
  */
 
-#include <Python.h>
-#include <datetime.h>
+#define NO_IMPORT
 
+#include <Python.h>
 #include <time.h>
-
-#include <numpy/arrayobject.h>
 #include <numpy/ndarrayobject.h>
-
-#include "numpy/arrayscalars.h"
 #include "np_datetime.h"
 
 /* Exported as DATETIMEUNITS in multiarraymodule.c */
-static char *_datetime_strings[NPY_DATETIME_NUMUNITS] = {
+char *_datetime_strings[NPY_DATETIME_NUMUNITS] = {
     NPY_STR_Y,
     NPY_STR_M,
     NPY_STR_W,
@@ -33,6 +29,16 @@ static char *_datetime_strings[NPY_DATETIME_NUMUNITS] = {
     "generic"
 };
 
+int _days_per_month_table[2][12] = {
+    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
+    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
+};
+
+int _month_offset[2][13] = {
+    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
+    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
+};
+
 /*
  * Returns 1 if the given year is a leap year, 0 otherwise.
  */
diff --git a/pandas/src/np_datetime.h b/pandas/src/np_datetime.h
index 3a795d469..713f383a9 100644
--- a/pandas/src/np_datetime.h
+++ b/pandas/src/np_datetime.h
@@ -1,12 +1,12 @@
 /*
- * This is derived from numpy 1.7  
+ * This is derived from numpy 1.7
  * See NP_LICENSE.TXT
  */
 
 #ifndef _PANDAS_DATETIME_H_
 #define _PANDAS_DATETIME_H_
 
-#define NPY_DATETIME_MAX_ISO8601_STRLEN (21+3*5+1+3*6+6+1)  
+#define NPY_DATETIME_MAX_ISO8601_STRLEN (21+3*5+1+3*6+6+1)
 
 // stuff pandas needs
 // ----------------------------------------------------------------------------
@@ -19,23 +19,17 @@ int convert_pydatetime_to_datetimestruct(PyObject *obj, npy_datetimestruct *out,
 int dayofweek(int y, int m, int d);
 
 /* Days per month, regular year and leap year */
-static int _days_per_month_table[2][12] = {
-    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
-    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
-};
+int _days_per_month_table[2][12];
 
 /* Table with day offsets for each month (0-based, without and with leap) */
-static int _month_offset[2][13] = {
-    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
-    { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
-};
+int _month_offset[2][13];
 
 // stuff numpy needs in header
 // ----------------------------------------------------------------------------
 
 int is_leapyear(npy_int64 year);
 
-static char *_datetime_strings[NPY_DATETIME_NUMUNITS];
+char *_datetime_strings[NPY_DATETIME_NUMUNITS];
 
 /*
  * Converts a datetime from a datetimestruct to a datetime based
diff --git a/pandas/src/np_datetime_strings.c b/pandas/src/np_datetime_strings.c
index 7722f29e1..d6f680037 100644
--- a/pandas/src/np_datetime_strings.c
+++ b/pandas/src/np_datetime_strings.c
@@ -8,14 +8,13 @@
  */
 
 #define PY_SSIZE_T_CLEAN
+#define NO_IMPORT
+
 #include <Python.h>
 
 #include <time.h>
 
 #include <numpy/arrayobject.h>
-
-//#include "numpy/npy_3kcompat.h"
-
 #include "numpy/arrayscalars.h"
 
 #include "np_datetime.h"
diff --git a/pandas/tests/test_daterange.py b/pandas/tests/test_daterange.py
index 5fb18dccb..dbaaa3f2d 100644
--- a/pandas/tests/test_daterange.py
+++ b/pandas/tests/test_daterange.py
@@ -58,8 +58,7 @@ class TestDateRange(unittest.TestCase):
     def test_cached_range(self):
         rng = DateRange._cached_range(START, END, offset=datetools.bday)
         rng = DateRange._cached_range(START, periods=20, offset=datetools.bday)
-        rng = DateRange._cached_range(end=START, periods=20,
-                                       offset=datetools.bday)
+        rng = DateRange._cached_range(end=START, periods=20, offset=datetools.bday)
 
         self.assertRaises(Exception, DateRange._cached_range, START, END)
 
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index a325714cb..21afaedac 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -3379,7 +3379,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing,
         shiftedFrame = self.tsframe.shift(5, offset=datetools.BDay())
         self.assert_(len(shiftedFrame) == len(self.tsframe))
 
-        shiftedFrame2 = self.tsframe.shift(5, timeRule='B')
+        shiftedFrame2 = self.tsframe.shift(5, timeRule='WEEKDAY')
         assert_frame_equal(shiftedFrame, shiftedFrame2)
 
         d = self.tsframe.index[0]
diff --git a/pandas/tests/test_series.py b/pandas/tests/test_series.py
index 8d69cc5f9..ae5c4c95f 100644
--- a/pandas/tests/test_series.py
+++ b/pandas/tests/test_series.py
@@ -1645,8 +1645,8 @@ class TestSeries(unittest.TestCase, CheckNameIntegration):
         unshifted = self.ts.shift(0, offset=offset)
         assert_series_equal(unshifted, self.ts)
 
-        shifted = self.ts.shift(1, timeRule='B')
-        unshifted = shifted.shift(-1, timeRule='B')
+        shifted = self.ts.shift(1, timeRule='WEEKDAY')
+        unshifted = shifted.shift(-1, timeRule='WEEKDAY')
 
         assert_series_equal(unshifted, self.ts)
 

commit 09e16d7a66247951c8596ff519f67b606075816c
Author: MomIsBestFriend <50263213+MomIsBestFriend@users.noreply.github.com>
Date:   Sat Nov 16 22:30:04 2019 +0200

    F-strings (#29662)

diff --git a/pandas/compat/__init__.py b/pandas/compat/__init__.py
index 684fbbc23..f95dd8679 100644
--- a/pandas/compat/__init__.py
+++ b/pandas/compat/__init__.py
@@ -30,7 +30,7 @@ def set_function_name(f, name, cls):
     Bind the name/qualname attributes of the function.
     """
     f.__name__ = name
-    f.__qualname__ = "{klass}.{name}".format(klass=cls.__name__, name=name)
+    f.__qualname__ = f"{cls.__name__}.{name}"
     f.__module__ = cls.__module__
     return f
 
diff --git a/pandas/compat/_optional.py b/pandas/compat/_optional.py
index 144255787..fc6650271 100644
--- a/pandas/compat/_optional.py
+++ b/pandas/compat/_optional.py
@@ -28,15 +28,6 @@ VERSIONS = {
     "xlsxwriter": "0.9.8",
 }
 
-message = (
-    "Missing optional dependency '{name}'. {extra} "
-    "Use pip or conda to install {name}."
-)
-version_message = (
-    "Pandas requires version '{minimum_version}' or newer of '{name}' "
-    "(version '{actual_version}' currently installed)."
-)
-
 
 def _get_version(module: types.ModuleType) -> str:
     version = getattr(module, "__version__", None)
@@ -45,7 +36,7 @@ def _get_version(module: types.ModuleType) -> str:
         version = getattr(module, "__VERSION__", None)
 
     if version is None:
-        raise ImportError("Can't determine version for {}".format(module.__name__))
+        raise ImportError(f"Can't determine version for {module.__name__}")
     return version
 
 
@@ -86,11 +77,15 @@ def import_optional_dependency(
         is False, or when the package's version is too old and `on_version`
         is ``'warn'``.
     """
+    msg = (
+        f"Missing optional dependency '{name}'. {extra} "
+        f"Use pip or conda to install {name}."
+    )
     try:
         module = importlib.import_module(name)
     except ImportError:
         if raise_on_missing:
-            raise ImportError(message.format(name=name, extra=extra)) from None
+            raise ImportError(msg) from None
         else:
             return None
 
@@ -99,8 +94,9 @@ def import_optional_dependency(
         version = _get_version(module)
         if distutils.version.LooseVersion(version) < minimum_version:
             assert on_version in {"warn", "raise", "ignore"}
-            msg = version_message.format(
-                minimum_version=minimum_version, name=name, actual_version=version
+            msg = (
+                f"Pandas requires version '{minimum_version}' or newer of '{name}' "
+                f"(version '{version}' currently installed)."
             )
             if on_version == "warn":
                 warnings.warn(msg, UserWarning)
diff --git a/pandas/compat/numpy/__init__.py b/pandas/compat/numpy/__init__.py
index 402ed62f2..27f1c3205 100644
--- a/pandas/compat/numpy/__init__.py
+++ b/pandas/compat/numpy/__init__.py
@@ -18,11 +18,11 @@ _is_numpy_dev = ".dev" in str(_nlv)
 
 if _nlv < "1.13.3":
     raise ImportError(
-        "this version of pandas is incompatible with "
-        "numpy < 1.13.3\n"
-        "your numpy version is {0}.\n"
-        "Please upgrade numpy to >= 1.13.3 to use "
-        "this pandas version".format(_np_version)
+        f"this version of pandas is incompatible with "
+        f"numpy < 1.13.3\n"
+        f"your numpy version is {_np_version}.\n"
+        f"Please upgrade numpy to >= 1.13.3 to use "
+        f"this pandas version"
     )
 
 
diff --git a/pandas/compat/numpy/function.py b/pandas/compat/numpy/function.py
index c2fe7d1dd..ea5aaf6b6 100644
--- a/pandas/compat/numpy/function.py
+++ b/pandas/compat/numpy/function.py
@@ -58,9 +58,7 @@ class CompatValidator:
                     fname, args, kwargs, max_fname_arg_count, self.defaults
                 )
             else:
-                raise ValueError(
-                    "invalid validation method '{method}'".format(method=method)
-                )
+                raise ValueError(f"invalid validation method '{method}'")
 
 
 ARGMINMAX_DEFAULTS = dict(out=None)
@@ -312,9 +310,8 @@ validate_transpose = CompatValidator(
 def validate_window_func(name, args, kwargs):
     numpy_args = ("axis", "dtype", "out")
     msg = (
-        "numpy operations are not "
-        "valid with window objects. "
-        "Use .{func}() directly instead ".format(func=name)
+        f"numpy operations are not valid with window objects. "
+        f"Use .{name}() directly instead "
     )
 
     if len(args) > 0:
@@ -328,9 +325,8 @@ def validate_window_func(name, args, kwargs):
 def validate_rolling_func(name, args, kwargs):
     numpy_args = ("axis", "dtype", "out")
     msg = (
-        "numpy operations are not "
-        "valid with window objects. "
-        "Use .rolling(...).{func}() instead ".format(func=name)
+        f"numpy operations are not valid with window objects. "
+        f"Use .rolling(...).{name}() instead "
     )
 
     if len(args) > 0:
@@ -344,9 +340,8 @@ def validate_rolling_func(name, args, kwargs):
 def validate_expanding_func(name, args, kwargs):
     numpy_args = ("axis", "dtype", "out")
     msg = (
-        "numpy operations are not "
-        "valid with window objects. "
-        "Use .expanding(...).{func}() instead ".format(func=name)
+        f"numpy operations are not valid with window objects. "
+        f"Use .expanding(...).{name}() instead "
     )
 
     if len(args) > 0:
@@ -371,11 +366,9 @@ def validate_groupby_func(name, args, kwargs, allowed=None):
 
     if len(args) + len(kwargs) > 0:
         raise UnsupportedFunctionCall(
-            (
-                "numpy operations are not valid "
-                "with groupby. Use .groupby(...)."
-                "{func}() instead".format(func=name)
-            )
+            f"numpy operations are not valid with "
+            f"groupby. Use .groupby(...).{name}() "
+            f"instead"
         )
 
 
@@ -391,11 +384,9 @@ def validate_resampler_func(method, args, kwargs):
     if len(args) + len(kwargs) > 0:
         if method in RESAMPLER_NUMPY_OPS:
             raise UnsupportedFunctionCall(
-                (
-                    "numpy operations are not valid "
-                    "with resample. Use .resample(...)."
-                    "{func}() instead".format(func=method)
-                )
+                f"numpy operations are not "
+                f"valid with resample. Use "
+                f".resample(...).{method}() instead"
             )
         else:
             raise TypeError("too many arguments passed in")
@@ -418,7 +409,4 @@ def validate_minmax_axis(axis):
     if axis is None:
         return
     if axis >= ndim or (axis < 0 and ndim + axis < 0):
-        raise ValueError(
-            "`axis` must be fewer than the number of "
-            "dimensions ({ndim})".format(ndim=ndim)
-        )
+        raise ValueError(f"`axis` must be fewer than the number of dimensions ({ndim})")

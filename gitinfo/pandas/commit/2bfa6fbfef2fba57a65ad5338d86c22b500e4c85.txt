commit 2bfa6fbfef2fba57a65ad5338d86c22b500e4c85
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Sep 12 13:53:25 2011 -0400

    BUG: to_wide was returning incorrect results with inconsistent long panel index. added HDFStore handling for duplicates in table format

diff --git a/pandas/core/index.py b/pandas/core/index.py
index 3fdb88253..99b2ff809 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -511,7 +511,8 @@ class MultiIndex(Index):
     def __new__(cls, levels=None, labels=None, sortorder=None, names=None):
         return np.arange(len(labels[0]), dtype=object).view(cls)
 
-    def __init__(self, levels, labels, sortorder=None, names=None):
+    def __init__(self, levels, labels, sortorder=None, names=None,
+                 consistent=None):
         self.levels = [_ensure_index(lev) for lev in levels]
         self.labels = [np.asarray(labs, dtype=np.int32) for labs in labels]
 
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 8f9218b05..c87dbf6f9 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -1036,6 +1036,25 @@ class LongPanel(DataFrame):
     DataFrame objects with hierarchical indexes. You should be careful about
     writing production code depending on LongPanel
     """
+
+    @property
+    def consistent(self):
+        offset = max(len(self.major_axis), len(self.minor_axis))
+
+        # overflow risk
+        if (offset + 1) ** 2 > 2**32:
+            keys = (self.major_labels.astype(np.int64) * offset +
+                    self.minor_labels.astype(np.int64))
+        else:
+            keys = self.major_labels * offset + self.minor_labels
+
+        unique_keys = np.unique(keys)
+
+        if len(unique_keys) < len(keys):
+            return False
+
+        return True
+
     @property
     def wide_shape(self):
         return (len(self.items), len(self.major_axis), len(self.minor_axis))
@@ -1145,6 +1164,7 @@ class LongPanel(DataFrame):
         -------
         Panel
         """
+        assert(self.consistent)
         mask = make_mask(self.index)
         if self._data.is_mixed_dtype():
             return self._to_wide_mixed(mask)
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index 9b1e96178..38e6c30a3 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -97,6 +97,8 @@ class HDFStore(object):
     >>> bar = store['foo']   # retrieve
     >>> store.close()
     """
+    _quiet = False
+
     def __init__(self, path, mode='a', complevel=None, complib=None,
                  fletcher32=False):
         try:
@@ -625,6 +627,8 @@ class HDFStore(object):
         return self._read_panel_table(group, where)['value']
 
     def _read_panel_table(self, group, where=None):
+        from pandas.core.common import _asarray_tuplesafe
+
         table = getattr(group, 'table')
 
         # create the selection
@@ -640,8 +644,29 @@ class HDFStore(object):
         long_index = MultiIndex.from_arrays([index, columns])
         lp = LongPanel(sel.values['values'], index=long_index,
                        columns=fields)
-        lp = lp.sortlevel(level=0)
-        wp = lp.to_wide()
+
+        if lp.consistent:
+            lp = lp.sortlevel(level=0)
+            wp = lp.to_wide()
+        else:
+            if not self._quiet:
+                print ('Duplicate entries in table, taking most recently '
+                       'appended')
+
+            # need a better algorithm
+            tuple_index = long_index.get_tuple_index()
+            index_map = _tseries.map_indices_buf(tuple_index)
+
+            unique_tuples = _tseries.fast_unique(tuple_index)
+            unique_tuples = _asarray_tuplesafe(unique_tuples)
+
+            indexer, _ = _tseries.getMergeVec(unique_tuples, index_map)
+
+            new_index = long_index.take(indexer)
+            new_values = lp.values.take(indexer, axis=0)
+
+            lp = LongPanel(new_values, index=new_index, columns=lp.columns)
+            wp = lp.to_wide()
 
         if sel.column_filter:
             new_minor = sorted(set(wp.minor_axis) & sel.column_filter)
diff --git a/pandas/io/tests/__init__.py b/pandas/io/tests/__init__.py
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/pandas/io/tests/__init__.py
@@ -0,0 +1 @@
+
diff --git a/pandas/io/tests/test_pytables.py b/pandas/io/tests/test_pytables.py
index 3a01c6724..fb809956c 100644
--- a/pandas/io/tests/test_pytables.py
+++ b/pandas/io/tests/test_pytables.py
@@ -248,6 +248,19 @@ class TesttHDFStore(unittest.TestCase):
         wp = tm.makePanel()
         self._check_roundtrip_table(wp, tm.assert_panel_equal)
 
+    def test_wide_table_dups(self):
+        wp = tm.makePanel()
+        try:
+            store = HDFStore(self.scratchpath)
+            store._quiet = True
+            store.put('panel', wp, table=True)
+            store.put('panel', wp, table=True, append=True)
+            recons = store['panel']
+            tm.assert_panel_equal(recons, wp)
+        finally:
+            store.close()
+            os.remove(self.scratchpath)
+
     def test_long(self):
         def _check(left, right):
             tm.assert_panel_equal(left.to_wide(),
diff --git a/pandas/src/groupby.pyx b/pandas/src/groupby.pyx
index d070e3258..8b09613da 100644
--- a/pandas/src/groupby.pyx
+++ b/pandas/src/groupby.pyx
@@ -260,7 +260,7 @@ def fast_unique(ndarray[object] values):
     except Exception:
         pass
 
-    return np.asarray(uniques, dtype=object)
+    return uniques
 
 @cython.wraparound(False)
 @cython.boundscheck(False)
diff --git a/pandas/stats/tests/__init__.py b/pandas/stats/tests/__init__.py
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/pandas/stats/tests/__init__.py
@@ -0,0 +1 @@
+
diff --git a/pandas/tests/__init__.py b/pandas/tests/__init__.py
new file mode 100644
index 000000000..8b1378917
--- /dev/null
+++ b/pandas/tests/__init__.py
@@ -0,0 +1 @@
+

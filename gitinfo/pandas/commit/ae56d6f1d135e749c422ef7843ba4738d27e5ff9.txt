commit ae56d6f1d135e749c422ef7843ba4738d27e5ff9
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Jun 19 16:01:25 2012 -0400

    ENH: at_time/between_time work with tz-localized time series. refactoring and cleanup close #1481

diff --git a/pandas/core/series.py b/pandas/core/series.py
index 7279f48cc..b858bd326 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -2773,26 +2773,23 @@ class TimeSeries(Series):
         namestr = "Name: %s, " % str(self.name) if self.name else ""
         return '%s%sLength: %d' % (freqstr, namestr, len(self))
 
-    def at_time(self, time, tz=None, asof=False):
+    def at_time(self, time, asof=False):
         """
         Select values at particular time of day (e.g. 9:30AM)
 
         Parameters
         ----------
         time : datetime.time or string
-        tz : string or pytz.timezone
-            Time zone for time. Corresponding timestamps would be converted to
-            time zone of the TimeSeries
 
         Returns
         -------
         values_at_time : TimeSeries
         """
-        from pandas.tseries.resample import values_at_time
-        return values_at_time(self, time, tz=tz, asof=asof)
+        indexer = self.index.indexer_at_time(time, asof=asof)
+        return self.take(indexer)
 
     def between_time(self, start_time, end_time, include_start=True,
-                     include_end=True, tz=None):
+                     include_end=True):
         """
         Select values between particular times of the day (e.g., 9:00-9:30 AM)
 
@@ -2802,16 +2799,15 @@ class TimeSeries(Series):
         end_time : datetime.time or string
         include_start : boolean, default True
         include_end : boolean, default True
-        tz : string or pytz.timezone, default None
 
         Returns
         -------
         values_between_time : TimeSeries
         """
-        from pandas.tseries.resample import values_between_time
-        return values_between_time(self, start_time, end_time, tz=tz,
-                                   include_start=include_start,
-                                   include_end=include_end)
+        indexer = self.index.indexer_between_time(
+            start_time, end_time, include_start=include_start,
+            include_end=include_end)
+        return self.take(indexer)
 
     def to_timestamp(self, freq=None, how='start', copy=True):
         """
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index e70b9ae85..ec50275cc 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -409,8 +409,7 @@ cdef class _Timestamp(datetime):
             return datetime.__sub__(self, other)
 
     cpdef _get_field(self, field):
-        out = fast_field_accessor(np.array([self.value], dtype=np.int64),
-                                  field)
+        out = get_date_field(np.array([self.value], dtype=np.int64), field)
         return out[0]
 
 
@@ -1049,8 +1048,26 @@ def build_field_sarray(ndarray[int64_t] dtindex):
 
     return out
 
+def get_time_micros(ndarray[int64_t] dtindex):
+    '''
+    Datetime as int64 representation to a structured array of fields
+    '''
+    cdef:
+        Py_ssize_t i, n = len(dtindex)
+        pandas_datetimestruct dts
+        ndarray[int64_t] micros
+
+    micros = np.empty(n, dtype=np.int64)
+
+    for i in range(n):
+        pandas_datetime_to_datetimestruct(dtindex[i], PANDAS_FR_ns, &dts)
+        micros[i] = 1000000LL * (dts.hour * 60 * 60 +
+                                 60 * dts.min + dts.sec) + dts.us
+
+    return micros
+
 @cython.wraparound(False)
-def fast_field_accessor(ndarray[int64_t] dtindex, object field):
+def get_date_field(ndarray[int64_t] dtindex, object field):
     '''
     Given a int64-based datetime index, extract the year, month, etc.,
     field and return an array of these values.
@@ -1178,107 +1195,6 @@ cdef inline int m8_weekday(int64_t val):
 
 cdef int64_t DAY_NS = 86400000000000LL
 
-def values_at_time(ndarray[int64_t] stamps, int64_t time):
-    cdef:
-        Py_ssize_t i, j, count, n = len(stamps)
-        ndarray[int64_t] indexer, times
-        int64_t last, cur
-
-    # Assumes stamps is sorted
-
-    if len(stamps) == 0:
-        return np.empty(0, dtype=np.int64)
-
-    # is this OK?
-    # days = stamps // DAY_NS
-    times = stamps % DAY_NS
-
-    # Nanosecond resolution
-    count = 0
-    for i in range(n):
-        if times[i] == time:
-            count += 1
-
-    indexer = np.empty(count, dtype=np.int64)
-
-    j = 0
-    # last = days[0]
-    for i in range(n):
-        if times[i] == time:
-            indexer[j] = i
-            j += 1
-
-    return indexer
-
-def values_between_time(ndarray[int64_t] stamps, int64_t stime, int64_t etime,
-                        bint include_start, bint include_end):
-    cdef:
-        Py_ssize_t i, j, count, n = len(stamps)
-        ndarray[int64_t] indexer, times
-        int64_t last, cur
-
-    # Assumes stamps is sorted
-
-    if len(stamps) == 0:
-        return np.empty(0, dtype=np.int64)
-
-    # is this OK?
-    # days = stamps // DAY_NS
-    times = stamps % DAY_NS
-
-    # Nanosecond resolution
-    count = 0
-    if include_start and include_end:
-        for i in range(n):
-            cur = times[i]
-            if cur >= stime and cur <= etime:
-                count += 1
-    elif include_start:
-        for i in range(n):
-            cur = times[i]
-            if cur >= stime and cur < etime:
-                count += 1
-    elif include_end:
-        for i in range(n):
-            cur = times[i]
-            if cur > stime and cur <= etime:
-                count += 1
-    else:
-        for i in range(n):
-            cur = times[i]
-            if cur > stime and cur < etime:
-                count += 1
-
-    indexer = np.empty(count, dtype=np.int64)
-
-    j = 0
-    # last = days[0]
-    if include_start and include_end:
-        for i in range(n):
-            cur = times[i]
-            if cur >= stime and cur <= etime:
-                indexer[j] = i
-                j += 1
-    elif include_start:
-        for i in range(n):
-            cur = times[i]
-            if cur >= stime and cur < etime:
-                indexer[j] = i
-                j += 1
-    elif include_end:
-        for i in range(n):
-            cur = times[i]
-            if cur > stime and cur <= etime:
-                indexer[j] = i
-                j += 1
-    else:
-        for i in range(n):
-            cur = times[i]
-            if cur > stime and cur < etime:
-                indexer[j] = i
-                j += 1
-
-    return indexer
 
 def date_normalize(ndarray[int64_t] stamps):
     cdef:
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 8aebe7d92..0a9b7bd90 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -39,7 +39,7 @@ def _field_accessor(name, field):
             utc = _utc()
             if self.tz is not utc:
                 values = lib.tz_convert(values, utc, self.tz)
-        return lib.fast_field_accessor(values, field)
+        return lib.get_date_field(values, field)
     f.__name__ = name
     return property(f)
 
@@ -578,9 +578,23 @@ class DatetimeIndex(Int64Index):
     @property
     def asstruct(self):
         if self._sarr_cache is None:
-            self._sarr_cache = lib.build_field_sarray(self.asi8)
+            self._sarr_cache = self._get_field_sarr()
         return self._sarr_cache
 
+    def _get_field_sarr(self):
+        utc = _utc()
+        values = self.asi8
+        if self.tz is not None and self.tz is not utc:
+            values = lib.tz_convert(values, utc, self.tz)
+        return lib.build_field_sarray(values)
+
+    def _get_time_micros(self):
+        utc = _utc()
+        values = self.asi8
+        if self.tz is not None and self.tz is not utc:
+            values = lib.tz_convert(values, utc, self.tz)
+        return lib.get_time_micros(values)
+
     @property
     def asobject(self):
         """
@@ -712,7 +726,7 @@ class DatetimeIndex(Int64Index):
             return self[maybe_slice]
         indices = com._ensure_platform_int(indices)
         taken = self.values.take(indices, axis=axis)
-        return DatetimeIndex(taken, tz=self.tz, name=self.name)
+        return self._simple_new(taken, self.name, None, self.tz)
 
     def union(self, other):
         """
@@ -943,7 +957,7 @@ class DatetimeIndex(Int64Index):
                 pass
 
             if isinstance(key, time):
-                locs = self._indices_at_time(key)
+                locs = self.indexer_at_time(key)
                 return series.take(locs)
 
             stamp = Timestamp(key)
@@ -969,22 +983,13 @@ class DatetimeIndex(Int64Index):
                 pass
 
             if isinstance(key, time):
-                return self._indices_at_time(key)
+                return self.indexer_at_time(key)
 
             try:
                 return self._engine.get_loc(Timestamp(key))
             except (KeyError, ValueError):
                 raise KeyError(key)
 
-    def _indices_at_time(self, key):
-        from dateutil.parser import parse
-
-        # TODO: time object with tzinfo?
-
-        nanos = _time_to_nanosecond(key)
-        indexer = lib.values_at_time(self.asi8, nanos)
-        return com._ensure_platform_int(indexer)
-
     def _get_string_slice(self, key):
         freq = getattr(self, 'freqstr',
                        getattr(self, 'inferred_freq', None))
@@ -1246,6 +1251,84 @@ class DatetimeIndex(Int64Index):
 
         return True
 
+    def indexer_at_time(self, time, asof=False):
+        """
+        Select values at particular time of day (e.g. 9:30AM)
+
+        Parameters
+        ----------
+        time : datetime.time or string
+        tz : string or pytz.timezone
+            Time zone for time. Corresponding timestamps would be converted to
+            time zone of the TimeSeries
+
+        Returns
+        -------
+        values_at_time : TimeSeries
+        """
+        from dateutil.parser import parse
+
+        if asof:
+            raise NotImplementedError
+
+        if isinstance(time, basestring):
+            time = parse(time).time()
+
+        if time.tzinfo:
+            # TODO
+            raise NotImplementedError
+
+        time_micros = self._get_time_micros()
+        micros = _time_to_micros(time)
+        return (micros == time_micros).nonzero()[0]
+
+    def indexer_between_time(self, start_time, end_time, include_start=True,
+                             include_end=True):
+        """
+        Select values between particular times of day (e.g., 9:00-9:30AM)
+
+        Parameters
+        ----------
+        start_time : datetime.time or string
+        end_time : datetime.time or string
+        include_start : boolean, default True
+        include_end : boolean, default True
+        tz : string or pytz.timezone, default None
+
+        Returns
+        -------
+        values_between_time : TimeSeries
+        """
+        from dateutil.parser import parse
+
+        if isinstance(start_time, basestring):
+            start_time = parse(start_time).time()
+
+        if isinstance(end_time, basestring):
+            end_time = parse(end_time).time()
+
+        if start_time.tzinfo or end_time.tzinfo:
+            raise NotImplementedError
+
+        time_micros = self._get_time_micros()
+        start_micros = _time_to_micros(start_time)
+        end_micros = _time_to_micros(end_time)
+
+        if include_start and include_end:
+            mask = ((start_micros <= time_micros) &
+                    (time_micros <= end_micros))
+        elif include_start:
+            mask = ((start_micros <= time_micros) &
+                    (time_micros < end_micros))
+        elif include_end:
+            mask = ((start_micros < time_micros) &
+                    (time_micros <= end_micros))
+        else:
+            mask = ((start_micros < time_micros) &
+                    (time_micros < end_micros))
+
+        return mask.nonzero()[0]
+
 def _generate_regular_range(start, end, periods, offset):
     if com._count_not_none(start, end, periods) < 2:
         raise ValueError('Must specify two of start, end, or periods')
@@ -1399,8 +1482,11 @@ def _in_range(start, end, rng_start, rng_end):
     return start > rng_start and end < rng_end
 
 def _time_to_nanosecond(time):
+    return _time_to_micros(time) * 1000
+
+def _time_to_micros(time):
     seconds = time.hour * 60 * 60 + 60 * time.minute + time.second
-    return (1000000 * seconds + time.microsecond) * 1000
+    return 1000000 * seconds + time.microsecond
 
 
 def _concat(to_concat):
@@ -1410,3 +1496,4 @@ def _concat(to_concat):
         return new_values.view(_NS_DTYPE)
     else:
         return np.concatenate(to_concat)
+
diff --git a/pandas/tseries/resample.py b/pandas/tseries/resample.py
index 507270b1f..dfe08ecb2 100644
--- a/pandas/tseries/resample.py
+++ b/pandas/tseries/resample.py
@@ -6,8 +6,7 @@ from pandas.core.groupby import BinGrouper, CustomGrouper
 from pandas.tseries.frequencies import to_offset, is_subperiod, is_superperiod
 from pandas.tseries.index import DatetimeIndex, date_range
 from pandas.tseries.offsets import DateOffset, Tick, _delta_to_nanoseconds
-from pandas.tseries.period import Period, PeriodIndex, period_range
-from pandas.util.decorators import cache_readonly
+from pandas.tseries.period import PeriodIndex, period_range
 import pandas.core.common as com
 
 from pandas.lib import Timestamp
@@ -344,80 +343,3 @@ def asfreq(obj, freq, method=None, how=None):
             return obj.copy()
         dti = date_range(obj.index[0], obj.index[-1], freq=freq)
         return obj.reindex(dti, method=method)
-
-def values_at_time(obj, time, tz=None, asof=False):
-    """
-    Select values at particular time of day (e.g. 9:30AM)
-
-    Parameters
-    ----------
-    time : datetime.time or string
-    tz : string or pytz.timezone
-        Time zone for time. Corresponding timestamps would be converted to
-        time zone of the TimeSeries
-
-    Returns
-    -------
-    values_at_time : TimeSeries
-    """
-    from dateutil.parser import parse
-
-    if asof:
-        raise NotImplementedError
-    if tz:
-        raise NotImplementedError
-
-    if not isinstance(obj.index, DatetimeIndex):
-        raise NotImplementedError
-
-    if isinstance(time, basestring):
-        time = parse(time).time()
-
-    # TODO: time object with tzinfo?
-
-    mus = _time_to_nanosecond(time)
-    indexer = lib.values_at_time(obj.index.asi8, mus)
-    indexer = com._ensure_platform_int(indexer)
-    return obj.take(indexer)
-
-def values_between_time(obj, start_time, end_time, include_start=True,
-                        include_end=True, tz=None):
-    """
-    Select values between particular times of day (e.g., 9:00-9:30AM)
-
-    Parameters
-    ----------
-    start_time : datetime.time or string
-    end_time : datetime.time or string
-    include_start : boolean, default True
-    include_end : boolean, default True
-    tz : string or pytz.timezone, default None
-
-    Returns
-    -------
-    values_between_time : TimeSeries
-    """
-    from dateutil.parser import parse
-
-    if tz:
-        raise NotImplementedError
-
-    if not isinstance(obj.index, DatetimeIndex):
-        raise NotImplementedError
-
-    if isinstance(start_time, basestring):
-        start_time = parse(start_time).time()
-
-    if isinstance(end_time, basestring):
-        end_time = parse(end_time).time()
-
-    start_ns = _time_to_nanosecond(start_time)
-    end_ns = _time_to_nanosecond(end_time)
-    indexer = lib.values_between_time(obj.index.asi8, start_ns, end_ns,
-                                      include_start, include_end)
-    indexer = com._ensure_platform_int(indexer)
-    return obj.take(indexer)
-
-def _time_to_nanosecond(time):
-    seconds = time.hour * 60 * 60 + 60 * time.minute + time.second
-    return 1000000000L * seconds + time.microsecond * 1000
diff --git a/pandas/tseries/tests/test_timezones.py b/pandas/tseries/tests/test_timezones.py
index d68284f3e..58bc4837b 100644
--- a/pandas/tseries/tests/test_timezones.py
+++ b/pandas/tseries/tests/test_timezones.py
@@ -329,6 +329,26 @@ class TestTimeZoneSupport(unittest.TestCase):
             self.assertEquals(x, exval)
             self.assertEquals(x.tzinfo, exval.tzinfo)
 
+    def test_localized_at_time_between_time(self):
+        from datetime import time
+
+        rng = date_range('4/16/2012', '5/1/2012', freq='H')
+        ts = Series(np.random.randn(len(rng)), index=rng)
+
+        ts_local = ts.tz_localize('US/Eastern')
+
+        result = ts_local.at_time(time(10, 0))
+        expected = ts.at_time(time(10, 0)).tz_localize('US/Eastern')
+        assert_series_equal(result, expected)
+        self.assert_(result.index.tz.zone == 'US/Eastern')
+
+        t1, t2 = time(10, 0), time(11, 0)
+        result = ts_local.between_time(t1, t2)
+        expected = ts.between_time(t1, t2).tz_localize('US/Eastern')
+        assert_series_equal(result, expected)
+        self.assert_(result.index.tz.zone == 'US/Eastern')
+
+
 class TestTimeZones(unittest.TestCase):
 
     def setUp(self):

commit 422869fe71986a602283d538762ecb450bb80ac3
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Jun 4 20:55:43 2012 -0400

    BUG: Cython time zone localization, numerous bug fixes and Timestamp behavior improvements. close #1389

diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index edac630f3..15e4753f3 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -28,18 +28,6 @@ PyDateTime_IMPORT
 
 cdef bint numpy_16 = np.__version__ < '1.7'
 
-ctypedef enum time_res:
-    r_min = 0
-    r_microsecond
-    r_second
-    r_minute
-    r_hour
-    r_day
-    r_month
-    r_year
-    r_max = 98
-    r_invalid = 99
-
 try:
     basestring
 except NameError: # py3
@@ -172,12 +160,24 @@ class Timestamp(_Timestamp):
         return np.int64(self.value).view('M8[ns]')
 
     def tz_convert(self, tz):
-        if isinstance(tz, basestring):
-            import pytz
-            tz = pytz.timezone(tz)
+        """
+        Convert Timestamp to another time zone or localize to requested time
+        zone
+
+        Parameters
+        ----------
+        tz : pytz.timezone
 
-        conv = tz.normalize(self)
-        return Timestamp(conv)
+        Returns
+        -------
+        converted : Timestamp
+        """
+        if self.tzinfo is None:
+            # tz naive, localize
+            return Timestamp(self.to_pydatetime(), tz=tz)
+        else:
+            # Same UTC timestamp, different time zone
+            return Timestamp(self.value, tz=tz)
 
     def replace(self, **kwds):
         return Timestamp(datetime.replace(self, **kwds),
@@ -341,7 +341,7 @@ cdef class _Timestamp(datetime):
         else:
             if isinstance(other, timedelta) or hasattr(other, 'delta'):
                 nanos = _delta_to_nanoseconds(other)
-                return Timestamp(self.value + nanos)
+                return Timestamp(self.value + nanos, tz=self.tzinfo)
             else:
                 result = datetime.__add__(self, other)
                 if isinstance(result, datetime):
@@ -419,6 +419,10 @@ cpdef convert_to_tsobject(object ts, object tz=None):
         _TSObject obj
         bint utc_convert = 1
 
+    if tz is not None:
+        if isinstance(tz, basestring):
+            tz = pytz.timezone(tz)
+
     obj = _TSObject()
 
     if is_datetime64_object(ts):
@@ -431,10 +435,22 @@ cpdef convert_to_tsobject(object ts, object tz=None):
         _string_to_dts(ts, &obj.dts)
         obj.value = pandas_datetimestruct_to_datetime(PANDAS_FR_ns, &obj.dts)
     elif PyDateTime_Check(ts):
-        obj.value = _pydatetime_to_dts(ts, &obj.dts)
-        obj.tzinfo = ts.tzinfo
-        if obj.tzinfo is not None:
+        if tz is not None:
+            # sort of a temporary hack
+            if ts.tzinfo is not None:
+                ts = tz.normalize(ts)
+            elif tz is not pytz.utc:
+                ts = tz.localize(ts)
+
+            obj.value = _pydatetime_to_dts(ts, &obj.dts)
+            obj.tzinfo = ts.tzinfo
             obj.value -= _delta_to_nanoseconds(obj.tzinfo._utcoffset)
+        else:
+            obj.value = _pydatetime_to_dts(ts, &obj.dts)
+            obj.tzinfo = ts.tzinfo
+            if obj.tzinfo is not None:
+                obj.value -= _delta_to_nanoseconds(obj.tzinfo._utcoffset)
+        return obj
     elif PyDate_Check(ts):
         obj.value  = _date_to_datetime64(ts, &obj.dts)
     else:
@@ -448,7 +464,7 @@ cpdef convert_to_tsobject(object ts, object tz=None):
             # Adjust datetime64 timestamp, recompute datetimestruct
             trans = _get_transitions(tz)
             deltas = _get_deltas(tz)
-            pos = trans.searchsorted(obj.value) - 1
+            pos = trans.searchsorted(obj.value, side='right') - 1
             inf = tz._transition_info[pos]
 
             pandas_datetime_to_datetimestruct(obj.value + deltas[pos],
@@ -520,356 +536,6 @@ cdef inline int _string_to_dts(object val, pandas_datetimestruct* dts) except -1
                             dts, &islocal, &out_bestunit, &special)
     return 0
 
-cdef conversion_factor(time_res res1, time_res res2):
-    cdef:
-        time_res min_res, max_res
-        int64_t factor
-
-    min_res = min(res1, res2)
-    max_res = max(res1, res2)
-    factor = 1
-
-    if min_res == max_res:
-        return factor
-
-    while min_res < max_res:
-        if min_res < r_microsecond:
-            raise "Cannot convert from less than us"
-        elif min_res == r_microsecond:
-            factor *= 1000000
-            min_res = r_second
-        elif min_res == r_second:
-            factor *= 60
-            min_res = r_minute
-        elif min_res == r_minute:
-            factor *= 60
-            min_res = r_hour
-        elif min_res == r_hour:
-            factor *= 24
-            min_res = r_day
-        else:
-            raise "Cannot convert to month or year"
-
-    return factor
-
-# Logic to generate ranges
-# -----------------------------------------------------------------------------
-
-cdef inline int64_t weekend_adjustment(int64_t dow, int bkwd):
-    if dow > 4:                         # sat or sun?
-        if bkwd:                        # roll back 1 or 2 days
-            return (4 - dow)
-        else:                           # roll forward 2 or 1 days
-            return (7 - dow)
-    return 0
-
-cdef int64_t us_in_day = conversion_factor(r_microsecond, r_day)
-
-cdef class _Offset:
-    """
-    Base class to generate timestamps. Set the anchor, and then move offsets
-    with next & prev. Retrieve timestamp with ts attribute.
-    """
-    cdef:
-        int64_t t, dow, biz, dayoffset
-        object start
-        _TSObject ts
-
-    def __cinit__(self):
-        self.t=0
-        self.dow=0
-        self.biz=0
-        self.dayoffset=0
-
-    cpdef anchor(self, object start=None):
-        if start is not None:
-            self.start = start
-        self.ts = convert_to_tsobject(self.start)
-        self._setup()
-
-    cdef _setup(self):
-        pass
-
-    cpdef next(self):
-        pass
-
-    cpdef prev(self):
-        pass
-
-    cdef int64_t _ts(self):
-        """
-        Access the current timestamp value, with a possible weekday
-        adjustment.
-        """
-        cdef int64_t adj
-
-        if self.biz != 0:
-            adj = weekend_adjustment(self.dow, self.biz < 0)
-            return self.t + us_in_day * adj
-        else:
-            return self.t
-
-    cdef int64_t _get_anchor(self):
-        """
-        Retrieve an anchor relating to current offset we're on.
-        """
-        return self.t - self.dayoffset * us_in_day
-
-    property ts:
-        def __get__(self):
-            return self._ts()
-
-cdef class YearOffset(_Offset):
-    """
-    Generate annual timestamps from provided start time; apply dayoffset to
-    each timestamp. If biz > 0, we choose the next business day at each time;
-    previous if < 0.
-
-    Parameters
-    ----------
-    dayoffset : int
-    biz : int
-    """
-    cdef:
-        int64_t y, ly
-
-    def __init__(self, int64_t dayoffset=0, int64_t biz=0, object anchor=None):
-        self.dayoffset = dayoffset
-        self.biz = biz
-
-        if anchor is not None:
-            self.anchor(anchor)
-
-    cdef _setup(self):
-        cdef _TSObject ts = self.ts
-
-        self.t = ts.value + self.dayoffset * us_in_day
-        self.y = ts.dts.year
-
-        self.ly = (ts.dts.month > 2 or
-                   ts.dts.month == 2 and ts.dts.day == 29)
-
-        if self.biz != 0:
-            self.dow = (ts_dayofweek(ts) + self.dayoffset) % 7
-
-    cpdef next(self):
-        cdef int64_t days
-
-        days = 365 + is_leapyear(self.y + self.ly)
-
-        self.t += days * us_in_day
-        self.y += 1
-
-        if self.biz != 0:
-            self.dow = (self.dow + days) % 7
-
-    cpdef prev(self):
-        cdef int64_t days
-
-        days = 365 + is_leapyear(self.y - (1-self.ly))
-
-        self.t -= days * us_in_day
-        self.y -= 1
-
-        if self.biz != 0:
-            self.dow = (self.dow - days) % 7
-
-cdef class MonthOffset(_Offset):
-    """
-    Generate monthly timestamps from provided start time, and apply dayoffset
-    to each timestamp.  Stride to construct strided timestamps (eg quarterly).
-    If biz > 0, we choose the next business day at each time; previous if < 0.
-
-    Parameters
-    ----------
-    dayoffset : int
-    stride : int, > 0
-    biz : int
-    """
-    cdef:
-        Py_ssize_t stride, ly, m
-        int64_t y
-
-    def __init__(self, int64_t dayoffset=0, Py_ssize_t stride=1,
-                 int64_t biz=0, object anchor=None):
-        self.dayoffset = dayoffset
-        self.stride = stride
-        self.biz = biz
-
-        if stride <= 0:
-            raise ValueError("Stride must be positive")
-
-        if anchor is not None:
-            self.anchor(anchor)
-
-    cdef _setup(self):
-        cdef _TSObject ts = self.ts
-
-        self.t = ts.value + (self.dayoffset * us_in_day)
-
-        # for day counting
-        self.m  = ts.dts.month - 1
-        self.y  = ts.dts.year
-        self.ly = is_leapyear(self.y)
-
-        if self.biz != 0:
-            self.dow = (ts_dayofweek(ts) + self.dayoffset) % 7
-
-    cpdef next(self):
-        cdef:
-            int64_t tmp, days
-            Py_ssize_t j
-
-        days = 0
-        for j in range(0, self.stride):
-            if self.m >= 12:
-                self.m -= 12
-                self.y += 1
-                self.ly = is_leapyear(self.y)
-            days += _days_per_month_table[self.ly][self.m]
-            self.m += 1
-
-        self.t += days * us_in_day
-
-        if self.biz != 0:
-            self.dow = (self.dow + days) % 7
-
-    cpdef prev(self):
-        cdef:
-            int64_t tmp, days
-            Py_ssize_t j
-
-        days = 0
-        for j in range(0, self.stride):
-            self.m -= 1
-            if self.m < 0:
-                self.m += 12
-                self.y -= 1
-                self.ly = is_leapyear(self.y)
-            days += _days_per_month_table[self.ly][self.m]
-
-        self.t -= days * us_in_day
-
-        if self.biz != 0:
-            self.dow = (self.dow - days) % 7
-
-cdef class DayOfMonthOffset(_Offset):
-    """
-    Generate relative monthly timestamps from month & year of provided start
-    time. For example, fridays of the third week of each month (week=3, day=4);
-    or, thursdays of the last week of each month (week=-1, day=3).
-
-    Parameters
-    ----------
-    week : int
-    day : int, 0 to 6
-    """
-    cdef:
-        Py_ssize_t ly, m
-        int64_t y, day, week
-
-    def __init__(self, int64_t week=0, int64_t day=0, object anchor=None):
-        self.week = week
-        self.day = day
-
-        if self.day < 0 or self.day > 6:
-            raise ValueError("Day offset must be 0 to 6")
-
-        if anchor is not None:
-            self.anchor(anchor)
-
-    cdef _setup(self):
-        cdef _TSObject ts = self.ts
-
-        # rewind to beginning of month
-        self.t = ts.value - (ts.dts.day - 1) * us_in_day
-        self.dow = dayofweek(ts.dts.year, ts.dts.month, 1)
-
-        # for day counting
-        self.m = ts.dts.month - 1
-        self.y = ts.dts.year
-        self.ly = is_leapyear(self.y)
-
-    cpdef next(self):
-        cdef:
-            int64_t tmp, days
-
-        days = _days_per_month_table[self.ly][self.m]
-        self.t += days * us_in_day
-        self.dow = (self.dow + days) % 7
-
-        self.m += 1
-        if self.m >= 12:
-            self.m -= 12
-            self.y += 1
-            self.ly = is_leapyear(self.y)
-
-    cpdef prev(self):
-        cdef:
-            int64_t tmp, days
-
-        days = _days_per_month_table[self.ly][(self.m - 1) % 12]
-        self.t -= days * us_in_day
-        self.dow = (self.dow - days) % 7
-
-        self.m -= 1
-        if self.m < 0:
-            self.m += 12
-            self.y -= 1
-            self.ly = is_leapyear(self.y)
-
-    cdef int64_t _ts(self):
-        """
-        Overwrite default adjustment
-        """
-        cdef int64_t adj = (self.week * 7) + (self.day - self.dow) % 7
-        return self.t + us_in_day * adj
-
-cdef class DayOffset(_Offset):
-    """
-    Generate daily timestamps beginning with first valid time >= start time. If
-    biz != 0, we skip weekends. Stride, to construct weekly timestamps.
-
-    Parameters
-    ----------
-    stride : int, > 0
-    biz : boolean
-    """
-    cdef:
-        Py_ssize_t stride
-
-    def __init__(self, int64_t stride=1, int64_t biz=0, object anchor=None):
-        self.stride = stride
-        self.biz = biz
-
-        if self.stride <= 0:
-            raise ValueError("Stride must be positive")
-
-        if anchor is not None:
-            self.anchor(anchor)
-
-    cdef _setup(self):
-        cdef _TSObject ts = self.ts
-        self.t = ts.value
-        if self.biz != 0:
-            self.dow = ts_dayofweek(ts)
-
-    cpdef next(self):
-        self.t += (self.stride * us_in_day)
-        if self.biz != 0:
-            self.dow = (self.dow + self.stride) % 7
-            if self.dow >= 5:
-                self.t += (7 - self.dow) * us_in_day
-                self.dow = 0
-
-    cpdef prev(self):
-        self.t -= (self.stride * us_in_day)
-        if self.biz != 0:
-            self.dow = (self.dow - self.stride) % 7
-            if self.dow >= 5:
-                self.t += (4 - self.dow) * us_in_day
-                self.dow = 4
-
 
 def array_to_datetime(ndarray[object] values, raise_=False, dayfirst=False):
     cdef:
@@ -1176,6 +842,107 @@ def tz_localize_check(ndarray[int64_t] vals, object tz):
             msg = "Cannot localize, ambiguous time %s found" % Timestamp(v)
             raise pytz.AmbiguousTimeError(msg)
 
+@cython.boundscheck(False)
+@cython.wraparound(False)
+def tz_localize_to_utc(ndarray[int64_t] vals, object tz):
+    """
+    Localize tzinfo-naive DateRange to given time zone (using pytz). If
+    there are ambiguities in the values, raise AmbiguousTimeError.
+
+    Returns
+    -------
+    localized : DatetimeIndex
+    """
+    cdef:
+        ndarray[int64_t] trans, deltas, idx_shifted
+        Py_ssize_t i, idx, pos, ntrans, n = len(vals)
+        int64_t *tdata
+        int64_t v, left, right
+        ndarray[int64_t] result, result_a, result_b
+
+    # Vectorized version of DstTzInfo.localize
+
+    if not have_pytz:
+        raise Exception("Could not find pytz module")
+
+    if tz == pytz.utc or tz is None:
+        return vals
+
+    trans = _get_transitions(tz)  # transition dates
+    deltas = _get_deltas(tz)      # utc offsets
+
+    tdata = <int64_t*> trans.data
+    ntrans = len(trans)
+
+    result = np.empty(n, dtype=np.int64)
+    result_a = np.empty(n, dtype=np.int64)
+    result_b = np.empty(n, dtype=np.int64)
+    result_a.fill(NPY_NAT)
+    result_b.fill(NPY_NAT)
+
+    # left side
+    idx_shifted = np.maximum(0, trans.searchsorted(vals - DAY_NS,
+                                                   side='right') - 1)
+
+    for i in range(n):
+        v = vals[i] - deltas[idx_shifted[i]]
+        pos = bisect_right_i8(tdata, v, ntrans) - 1
+
+        # timestamp falls to the left side of the DST transition
+        if v + deltas[pos] == vals[i]:
+            result_a[i] = v
+
+    # right side
+    idx_shifted = np.maximum(0, trans.searchsorted(vals + DAY_NS,
+                                                   side='right') - 1)
+
+    for i in range(n):
+        v = vals[i] - deltas[idx_shifted[i]]
+        pos = bisect_right_i8(tdata, v, ntrans) - 1
+
+        # timestamp falls to the right side of the DST transition
+        if v + deltas[pos] == vals[i]:
+            result_b[i] = v
+
+    for i in range(n):
+        left = result_a[i]
+        right = result_b[i]
+        if left != NPY_NAT and right != NPY_NAT:
+            if left == right:
+                result[i] = left
+            else:
+                stamp = Timestamp(vals[i])
+                raise pytz.AmbiguousTimeError(stamp)
+        elif left != NPY_NAT:
+            result[i] = left
+        elif right != NPY_NAT:
+            result[i] = right
+        else:
+            stamp = Timestamp(vals[i])
+            raise pytz.NonExistentTimeError(stamp)
+
+    return result
+
+cdef inline bisect_right_i8(int64_t *data, int64_t val, Py_ssize_t n):
+    cdef Py_ssize_t pivot, left = 0, right = n
+
+    # edge cases
+    if val > data[n - 1]:
+        return n
+
+    if val < data[0]:
+        return 0
+
+    while left < right:
+        pivot = left + (right - left) // 2
+
+        if data[pivot] <= val:
+            left = pivot + 1
+        else:
+            right = pivot
+
+    return left
+
 
 # Accessors
 #----------------------------------------------------------------------
diff --git a/pandas/src/offsets.pyx b/pandas/src/offsets.pyx
new file mode 100644
index 000000000..687495018
--- /dev/null
+++ b/pandas/src/offsets.pyx
@@ -0,0 +1,363 @@
+
+ctypedef enum time_res:
+    r_min = 0
+    r_microsecond
+    r_second
+    r_minute
+    r_hour
+    r_day
+    r_month
+    r_year
+    r_max = 98
+    r_invalid = 99
+
+
+cdef conversion_factor(time_res res1, time_res res2):
+    cdef:
+        time_res min_res, max_res
+        int64_t factor
+
+    min_res = min(res1, res2)
+    max_res = max(res1, res2)
+    factor = 1
+
+    if min_res == max_res:
+        return factor
+
+    while min_res < max_res:
+        if min_res < r_microsecond:
+            raise "Cannot convert from less than us"
+        elif min_res == r_microsecond:
+            factor *= 1000000
+            min_res = r_second
+        elif min_res == r_second:
+            factor *= 60
+            min_res = r_minute
+        elif min_res == r_minute:
+            factor *= 60
+            min_res = r_hour
+        elif min_res == r_hour:
+            factor *= 24
+            min_res = r_day
+        else:
+            raise "Cannot convert to month or year"
+
+    return factor
+
+# Logic to generate ranges
+# -----------------------------------------------------------------------------
+
+cdef inline int64_t weekend_adjustment(int64_t dow, int bkwd):
+    if dow > 4:                         # sat or sun?
+        if bkwd:                        # roll back 1 or 2 days
+            return (4 - dow)
+        else:                           # roll forward 2 or 1 days
+            return (7 - dow)
+    return 0
+
+cdef int64_t us_in_day = conversion_factor(r_microsecond, r_day)
+
+cdef class _Offset:
+    """
+    Base class to generate timestamps. Set the anchor, and then move offsets
+    with next & prev. Retrieve timestamp with ts attribute.
+    """
+    cdef:
+        int64_t t, dow, biz, dayoffset
+        object start
+        _TSObject ts
+
+    def __cinit__(self):
+        self.t=0
+        self.dow=0
+        self.biz=0
+        self.dayoffset=0
+
+    cpdef anchor(self, object start=None):
+        if start is not None:
+            self.start = start
+        self.ts = convert_to_tsobject(self.start)
+        self._setup()
+
+    cdef _setup(self):
+        pass
+
+    cpdef next(self):
+        pass
+
+    cpdef prev(self):
+        pass
+
+    cdef int64_t _ts(self):
+        """
+        Access the current timestamp value, with a possible weekday
+        adjustment.
+        """
+        cdef int64_t adj
+
+        if self.biz != 0:
+            adj = weekend_adjustment(self.dow, self.biz < 0)
+            return self.t + us_in_day * adj
+        else:
+            return self.t
+
+    cdef int64_t _get_anchor(self):
+        """
+        Retrieve an anchor relating to current offset we're on.
+        """
+        return self.t - self.dayoffset * us_in_day
+
+    property ts:
+        def __get__(self):
+            return self._ts()
+
+cdef class YearOffset(_Offset):
+    """
+    Generate annual timestamps from provided start time; apply dayoffset to
+    each timestamp. If biz > 0, we choose the next business day at each time;
+    previous if < 0.
+
+    Parameters
+    ----------
+    dayoffset : int
+    biz : int
+    """
+    cdef:
+        int64_t y, ly
+
+    def __init__(self, int64_t dayoffset=0, int64_t biz=0, object anchor=None):
+        self.dayoffset = dayoffset
+        self.biz = biz
+
+        if anchor is not None:
+            self.anchor(anchor)
+
+    cdef _setup(self):
+        cdef _TSObject ts = self.ts
+
+        self.t = ts.value + self.dayoffset * us_in_day
+        self.y = ts.dts.year
+
+        self.ly = (ts.dts.month > 2 or
+                   ts.dts.month == 2 and ts.dts.day == 29)
+
+        if self.biz != 0:
+            self.dow = (ts_dayofweek(ts) + self.dayoffset) % 7
+
+    cpdef next(self):
+        cdef int64_t days
+
+        days = 365 + is_leapyear(self.y + self.ly)
+
+        self.t += days * us_in_day
+        self.y += 1
+
+        if self.biz != 0:
+            self.dow = (self.dow + days) % 7
+
+    cpdef prev(self):
+        cdef int64_t days
+
+        days = 365 + is_leapyear(self.y - (1-self.ly))
+
+        self.t -= days * us_in_day
+        self.y -= 1
+
+        if self.biz != 0:
+            self.dow = (self.dow - days) % 7
+
+cdef class MonthOffset(_Offset):
+    """
+    Generate monthly timestamps from provided start time, and apply dayoffset
+    to each timestamp.  Stride to construct strided timestamps (eg quarterly).
+    If biz > 0, we choose the next business day at each time; previous if < 0.
+
+    Parameters
+    ----------
+    dayoffset : int
+    stride : int, > 0
+    biz : int
+    """
+    cdef:
+        Py_ssize_t stride, ly, m
+        int64_t y
+
+    def __init__(self, int64_t dayoffset=0, Py_ssize_t stride=1,
+                 int64_t biz=0, object anchor=None):
+        self.dayoffset = dayoffset
+        self.stride = stride
+        self.biz = biz
+
+        if stride <= 0:
+            raise ValueError("Stride must be positive")
+
+        if anchor is not None:
+            self.anchor(anchor)
+
+    cdef _setup(self):
+        cdef _TSObject ts = self.ts
+
+        self.t = ts.value + (self.dayoffset * us_in_day)
+
+        # for day counting
+        self.m  = ts.dts.month - 1
+        self.y  = ts.dts.year
+        self.ly = is_leapyear(self.y)
+
+        if self.biz != 0:
+            self.dow = (ts_dayofweek(ts) + self.dayoffset) % 7
+
+    cpdef next(self):
+        cdef:
+            int64_t tmp, days
+            Py_ssize_t j
+
+        days = 0
+        for j in range(0, self.stride):
+            if self.m >= 12:
+                self.m -= 12
+                self.y += 1
+                self.ly = is_leapyear(self.y)
+            days += _days_per_month_table[self.ly][self.m]
+            self.m += 1
+
+        self.t += days * us_in_day
+
+        if self.biz != 0:
+            self.dow = (self.dow + days) % 7
+
+    cpdef prev(self):
+        cdef:
+            int64_t tmp, days
+            Py_ssize_t j
+
+        days = 0
+        for j in range(0, self.stride):
+            self.m -= 1
+            if self.m < 0:
+                self.m += 12
+                self.y -= 1
+                self.ly = is_leapyear(self.y)
+            days += _days_per_month_table[self.ly][self.m]
+
+        self.t -= days * us_in_day
+
+        if self.biz != 0:
+            self.dow = (self.dow - days) % 7
+
+cdef class DayOfMonthOffset(_Offset):
+    """
+    Generate relative monthly timestamps from month & year of provided start
+    time. For example, fridays of the third week of each month (week=3, day=4);
+    or, thursdays of the last week of each month (week=-1, day=3).
+
+    Parameters
+    ----------
+    week : int
+    day : int, 0 to 6
+    """
+    cdef:
+        Py_ssize_t ly, m
+        int64_t y, day, week
+
+    def __init__(self, int64_t week=0, int64_t day=0, object anchor=None):
+        self.week = week
+        self.day = day
+
+        if self.day < 0 or self.day > 6:
+            raise ValueError("Day offset must be 0 to 6")
+
+        if anchor is not None:
+            self.anchor(anchor)
+
+    cdef _setup(self):
+        cdef _TSObject ts = self.ts
+
+        # rewind to beginning of month
+        self.t = ts.value - (ts.dts.day - 1) * us_in_day
+        self.dow = dayofweek(ts.dts.year, ts.dts.month, 1)
+
+        # for day counting
+        self.m = ts.dts.month - 1
+        self.y = ts.dts.year
+        self.ly = is_leapyear(self.y)
+
+    cpdef next(self):
+        cdef:
+            int64_t tmp, days
+
+        days = _days_per_month_table[self.ly][self.m]
+        self.t += days * us_in_day
+        self.dow = (self.dow + days) % 7
+
+        self.m += 1
+        if self.m >= 12:
+            self.m -= 12
+            self.y += 1
+            self.ly = is_leapyear(self.y)
+
+    cpdef prev(self):
+        cdef:
+            int64_t tmp, days
+
+        days = _days_per_month_table[self.ly][(self.m - 1) % 12]
+        self.t -= days * us_in_day
+        self.dow = (self.dow - days) % 7
+
+        self.m -= 1
+        if self.m < 0:
+            self.m += 12
+            self.y -= 1
+            self.ly = is_leapyear(self.y)
+
+    cdef int64_t _ts(self):
+        """
+        Overwrite default adjustment
+        """
+        cdef int64_t adj = (self.week * 7) + (self.day - self.dow) % 7
+        return self.t + us_in_day * adj
+
+cdef class DayOffset(_Offset):
+    """
+    Generate daily timestamps beginning with first valid time >= start time. If
+    biz != 0, we skip weekends. Stride, to construct weekly timestamps.
+
+    Parameters
+    ----------
+    stride : int, > 0
+    biz : boolean
+    """
+    cdef:
+        Py_ssize_t stride
+
+    def __init__(self, int64_t stride=1, int64_t biz=0, object anchor=None):
+        self.stride = stride
+        self.biz = biz
+
+        if self.stride <= 0:
+            raise ValueError("Stride must be positive")
+
+        if anchor is not None:
+            self.anchor(anchor)
+
+    cdef _setup(self):
+        cdef _TSObject ts = self.ts
+        self.t = ts.value
+        if self.biz != 0:
+            self.dow = ts_dayofweek(ts)
+
+    cpdef next(self):
+        self.t += (self.stride * us_in_day)
+        if self.biz != 0:
+            self.dow = (self.dow + self.stride) % 7
+            if self.dow >= 5:
+                self.t += (7 - self.dow) * us_in_day
+                self.dow = 0
+
+    cpdef prev(self):
+        self.t -= (self.stride * us_in_day)
+        if self.biz != 0:
+            self.dow = (self.dow - self.stride) % 7
+            if self.dow >= 5:
+                self.t += (4 - self.dow) * us_in_day
+                self.dow = 4
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 73c79c54e..97aba73dc 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -256,8 +256,8 @@ class DatetimeIndex(Int64Index):
             tz = tools._maybe_get_tz(tz)
             # Convert local to UTC
             ints = subarr.view('i8')
-            lib.tz_localize_check(ints, tz)
-            subarr = lib.tz_convert(ints, tz, _utc())
+
+            subarr = lib.tz_localize_to_utc(ints, tz)
             subarr = subarr.view(_NS_DTYPE)
 
         subarr = subarr.view(cls)
@@ -321,8 +321,11 @@ class DatetimeIndex(Int64Index):
         if tz is not None:
             # Convert local to UTC
             ints = index.view('i8')
-            lib.tz_localize_check(ints, tz)
-            index = lib.tz_convert(ints, tz, _utc())
+            index = lib.tz_localize_to_utc(ints, tz)
+
+            # lib.tz_localize_check(ints, tz)
+            # index = lib.tz_convert(ints, tz, _utc())
+
             index = index.view(_NS_DTYPE)
 
         index = index.view(cls)
@@ -1346,3 +1349,113 @@ def _in_range(start, end, rng_start, rng_end):
 def _time_to_nanosecond(time):
     seconds = time.hour * 60 * 60 + 60 * time.minute + time.second
     return (1000000 * seconds + time.microsecond) * 1000
+
+
+
+def tz_localize_to_utc(vals, tz):
+    """
+    Localize tzinfo-naive DateRange to given time zone (using pytz). If
+    there are ambiguities in the values, raise AmbiguousTimeError.
+
+    Returns
+    -------
+    localized : DatetimeIndex
+    """
+    # Vectorized version of DstTzInfo.localize
+
+    # if not have_pytz:
+    #     raise Exception("Could not find pytz module")
+    import pytz
+
+    n = len(vals)
+    DAY_NS = 86400000000000L
+    NPY_NAT = lib.iNaT
+
+    if tz == pytz.utc or tz is None:
+        return vals
+
+    trans = _get_transitions(tz)  # transition dates
+    deltas = _get_deltas(tz)      # utc offsets
+
+    result = np.empty(n, dtype=np.int64)
+    result_a = np.empty(n, dtype=np.int64)
+    result_b = np.empty(n, dtype=np.int64)
+    result_a.fill(NPY_NAT)
+    result_b.fill(NPY_NAT)
+
+    # left side
+    idx_shifted = np.maximum(0, trans.searchsorted(vals - DAY_NS,
+                                                   side='right') - 1)
+
+    for i in range(n):
+        v = vals[i] - deltas[idx_shifted[i]]
+        pos = trans.searchsorted(v, side='right') - 1
+
+        # timestamp falls to the left side of the DST transition
+        if v + deltas[pos] == vals[i]:
+            result_a[i] = v
+
+    # right side
+    idx_shifted = np.maximum(0, trans.searchsorted(vals + DAY_NS,
+                                                   side='right') - 1)
+
+    for i in range(n):
+        v = vals[i] - deltas[idx_shifted[i]]
+        pos = trans.searchsorted(v, side='right') - 1
+
+        # timestamp falls to the right side of the DST transition
+        if v + deltas[pos] == vals[i]:
+            result_b[i] = v
+
+    for i in range(n):
+        left = result_a[i]
+        right = result_b[i]
+        if left != NPY_NAT and right != NPY_NAT:
+            if left == right:
+                result[i] = left
+            else:
+                stamp = Timestamp(vals[i])
+                raise pytz.AmbiguousTimeError(stamp)
+        elif left != NPY_NAT:
+            result[i] = left
+        elif right != NPY_NAT:
+            result[i] = right
+        else:
+            stamp = Timestamp(vals[i])
+            raise pytz.NonExistentTimeError(stamp)
+
+    return result
+
+
+trans_cache = {}
+utc_offset_cache = {}
+
+def _get_transitions(tz):
+    """
+    Get UTC times of DST transitions
+    """
+    if tz not in trans_cache:
+        arr = np.array(tz._utc_transition_times, dtype='M8[ns]')
+        trans_cache[tz] = arr.view('i8')
+    return trans_cache[tz]
+
+def _get_deltas(tz):
+    """
+    Get UTC offsets in microseconds corresponding to DST transitions
+    """
+    if tz not in utc_offset_cache:
+        utc_offset_cache[tz] = _unbox_utcoffsets(tz._transition_info)
+    return utc_offset_cache[tz]
+
+def total_seconds(td): # Python 2.6 compat
+    return ((td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) //
+            10**6)
+
+def _unbox_utcoffsets(transinfo):
+    sz = len(transinfo)
+    arr = np.empty(sz, dtype='i8')
+
+    for i in range(sz):
+        arr[i] = int(total_seconds(transinfo[i][0])) * 1000000000
+
+    return arr
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 42db2c73e..83c1a5933 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -1482,6 +1482,35 @@ class TestTimestamp(unittest.TestCase):
         result = val + timedelta(1)
         self.assert_(result.nanosecond == val.nanosecond)
 
+    def test_create_with_tz(self):
+        stamp = Timestamp('3/11/2012 05:00', tz='US/Eastern')
+        self.assertEquals(stamp.hour, 5)
+
+        rng = date_range('3/11/2012 04:00', periods=10, freq='H', tz='US/Eastern')
+
+        self.assertEquals(stamp, rng[1])
+
+    def test_tz_convert_localize(self):
+        stamp = Timestamp('3/11/2012 04:00')
+
+        result = stamp.tz_convert('US/Eastern')
+        expected = Timestamp('3/11/2012 04:00', tz='US/Eastern')
+        self.assertEquals(result.hour, expected.hour)
+        self.assertEquals(result, expected)
+
+    def test_timedelta_push_over_dst_boundary(self):
+        # #1389
+
+        # 4 hours before DST transition
+        stamp = Timestamp('3/10/2012 22:00', tz='US/Eastern')
+
+        result = stamp + timedelta(hours=6)
+
+        # spring forward, + "7" hours
+        expected = Timestamp('3/11/2012 05:00', tz='US/Eastern')
+
+        self.assertEquals(result, expected)
+
     def test_frequency_misc(self):
         self.assertEquals(fmod.get_freq_group('T'),
                           fmod.FreqGroup.FR_MIN)
diff --git a/pandas/tseries/tests/test_timezones.py b/pandas/tseries/tests/test_timezones.py
index 5851fb486..2e481f4d8 100644
--- a/pandas/tseries/tests/test_timezones.py
+++ b/pandas/tseries/tests/test_timezones.py
@@ -100,6 +100,35 @@ class TestTimeZoneSupport(unittest.TestCase):
         self.assertRaises(pytz.AmbiguousTimeError, dti.tz_localize,
                           'US/Eastern')
 
+    def test_date_range_localize(self):
+        rng = date_range('3/11/2012 03:00', periods=15, freq='H', tz='US/Eastern')
+        rng2 = DatetimeIndex(['3/11/2012 03:00', '3/11/2012 04:00'],
+                             tz='US/Eastern')
+
+        # DST transition time
+        val = rng[0]
+        exp = Timestamp('3/11/2012 03:00', tz='US/Eastern')
+
+        self.assertEquals(val.hour, 3)
+        self.assertEquals(exp.hour, 3)
+        self.assertEquals(val, exp)  # same UTC value
+        self.assert_(rng[:2].equals(rng2))
+
+        # Right before the DST transition
+        rng = date_range('3/11/2012 00:00', periods=2, freq='H', tz='US/Eastern')
+        rng2 = DatetimeIndex(['3/11/2012 00:00', '3/11/2012 01:00'],
+                             tz='US/Eastern')
+        self.assert_(rng.equals(rng2))
+        exp = Timestamp('3/11/2012 00:00', tz='US/Eastern')
+        self.assertEquals(exp.hour, 0)
+        self.assertEquals(rng[0], exp)
+        exp = Timestamp('3/11/2012 01:00', tz='US/Eastern')
+        self.assertEquals(exp.hour, 1)
+        self.assertEquals(rng[1], exp)
+
+        self.assertRaises(pytz.NonExistentTimeError, date_range,
+                          '3/11/2012 00:00', periods=10, freq='H', tz='US/Eastern')
+
     def test_utc_box_timestamp_and_localize(self):
         rng = date_range('3/11/2012', '3/12/2012', freq='H', tz='utc')
         rng_eastern = rng.tz_convert('US/Eastern')
diff --git a/pandas/tseries/tools.py b/pandas/tseries/tools.py
index 68129ba60..4e4077ff9 100644
--- a/pandas/tseries/tools.py
+++ b/pandas/tseries/tools.py
@@ -48,6 +48,8 @@ def _maybe_get_tz(tz):
 
 def _figure_out_timezone(start, end, tzinfo):
     inferred_tz = _infer_tzinfo(start, end)
+    tzinfo = _maybe_get_tz(tzinfo)
+
     tz = inferred_tz
     if inferred_tz is None and tzinfo is not None:
         tz = tzinfo
@@ -55,7 +57,7 @@ def _figure_out_timezone(start, end, tzinfo):
         assert(inferred_tz == tzinfo)
         # make tz naive for now
 
-    tz = _maybe_get_tz(tz)
+    # tz = _maybe_get_tz(tz)
 
     start = start if start is None else start.replace(tzinfo=None)
     end = end if end is None else end.replace(tzinfo=None)
diff --git a/setup.py b/setup.py
index 4d5bb96ae..fa213483b 100755
--- a/setup.py
+++ b/setup.py
@@ -345,7 +345,7 @@ tseries_depends = ['reindex', 'groupby', 'skiplist', 'moments',
                    'reduce', 'stats', 'datetime',
                    'hashtable', 'inference', 'properties', 'join', 'engines']
 
-plib_depends = ['period']
+plib_depends = ['plib']
 
 def srcpath(name=None, suffix='.pyx', subdir='src'):
     return pjoin('pandas', subdir, name+suffix)

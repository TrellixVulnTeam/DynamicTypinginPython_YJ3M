commit b28f8b4ddece656600d8bb5ec13f61742024e02e
Author: jreback <jeff@reback.net>
Date:   Mon Dec 3 12:22:53 2012 -0500

    added boolean comparison methods to panel

diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index dfffc4d8c..cf88a1be0 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -104,7 +104,7 @@ def _arith_method(func, name):
 
 def _panel_arith_method(op, name):
     @Substitution(op)
-    def f(self, other, axis='items'):
+    def f(self, other, axis = 0):
         """
         Wrapper method for %s
 
@@ -123,6 +123,42 @@ def _panel_arith_method(op, name):
     f.__name__ = name
     return f
 
+def _comp_method(func, name):
+
+    def na_op(x, y):
+        try:
+            result = func(x, y)
+        except TypeError:
+            xrav = x.ravel()
+            result = np.empty(x.size, dtype=x.dtype)
+            if isinstance(y, np.ndarray):
+                yrav = y.ravel()
+                mask = notnull(xrav) & notnull(yrav)
+                result[mask] = func(np.array(list(xrav[mask])),
+                                  np.array(list(yrav[mask])))
+            else:
+                mask = notnull(xrav)
+                result[mask] = func(np.array(list(xrav[mask])), y)
+
+            if func == operator.ne:  # pragma: no cover
+                np.putmask(result, -mask, True)
+            else:
+                np.putmask(result, -mask, False)
+            result = result.reshape(x.shape)
+
+        return result
+
+    @Appender('Wrapper for comparison method %s' % name)
+    def f(self, other):
+        if isinstance(other, self._constructor):
+            return self._compare_constructor(other, func)
+        else:
+            return self._combine_const(other, na_op)
+
+
+    f.__name__ = name
+
+    return f
 
 _agg_doc = """
 Return %(desc)s over requested axis
@@ -400,6 +436,49 @@ class Panel(NDFrame):
         d['copy'] = False
         return self._constructor(result, **d)
 
+    #----------------------------------------------------------------------
+    # Comparison methods
+
+    def _indexed_same(self, other):
+        return all([ getattr(self,a).equals(getattr(other,a)) for a in self._AXIS_ORDERS ])
+  
+    def _compare_constructor(self, other, func):
+        new_data = {}
+        for col in getattr(self,self._info_axis):
+            new_data[col] = func(self[col], other[col])
+
+        d = self._construct_axes_dict()
+        d['copy'] = False
+        return self._constructor(data=new_data, **d)
+
+    # boolean operators
+    __and__ = _arith_method(operator.and_, '__and__')
+    __or__ = _arith_method(operator.or_, '__or__')
+    __xor__ = _arith_method(operator.xor, '__xor__')
+
+    def __neg__(self):
+        arr = operator.neg(self.values)
+        return self._wrap_array(arr, self.axes, copy=False)
+
+    def __invert__(self):
+        arr = operator.inv(self.values)
+        return self._wrap_array(arr, self.axes, copy=False)
+    
+    # Comparison methods
+    __eq__ = _comp_method(operator.eq, '__eq__')
+    __ne__ = _comp_method(operator.ne, '__ne__')
+    __lt__ = _comp_method(operator.lt, '__lt__')
+    __gt__ = _comp_method(operator.gt, '__gt__')
+    __le__ = _comp_method(operator.le, '__le__')
+    __ge__ = _comp_method(operator.ge, '__ge__')
+
+    eq = _comp_method(operator.eq, 'eq')
+    ne = _comp_method(operator.ne, 'ne')
+    gt = _comp_method(operator.gt, 'gt')
+    lt = _comp_method(operator.lt, 'lt')
+    ge = _comp_method(operator.ge, 'ge')
+    le = _comp_method(operator.le, 'le')
+
     #----------------------------------------------------------------------
     # Magic methods
 
@@ -741,7 +820,10 @@ class Panel(NDFrame):
         if (method is None and not self._is_mixed_type and al <= 3):
             items = kwargs.get('items')
             if com._count_not_none(items, major, minor) == 3:
-                return self._reindex_multi(items, major, minor)
+                try:
+                    return self._reindex_multi(items, major, minor)
+                except:
+                    pass
 
         if major is not None:
             result = result._reindex_axis(major, method, al-2, copy)
@@ -873,12 +955,12 @@ class Panel(NDFrame):
         elif isinstance(other, DataFrame):
             return self._combine_frame(other, func, axis=axis)
         elif np.isscalar(other):
-            new_values = func(self.values, other)
-            d = self._construct_axes_dict()
-            return self._constructor(new_values, **d)
+            return self._combine_const(other, func)
 
-    def __neg__(self):
-        return -1 * self
+    def _combine_const(self, other, func):
+        new_values = func(self.values, other)
+        d = self._construct_axes_dict()
+        return self._constructor(new_values, **d)
 
     def _combine_frame(self, other, func, axis=0):
         index, columns = self._get_plane_axes(axis)
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index 1d8b40d34..653d9599b 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -642,6 +642,44 @@ class CheckIndexing(object):
         self.assert_((obj.values == 0).all())
         comp(cp.ix[indexer].reindex_like(obj), obj)
 
+    def test_logical_with_nas(self):
+        d = Panel({ 'ItemA' : {'a': [np.nan, False] }, 'ItemB' : { 'a': [True, True] } })
+
+        result = d['ItemA'] | d['ItemB']
+        expected = DataFrame({ 'a' : [np.nan, True] })
+        assert_frame_equal(result, expected)
+
+        result = d['ItemA'].fillna(False) | d['ItemB']
+        expected = DataFrame({ 'a' : [True, True] }, dtype=object)
+        assert_frame_equal(result, expected)
+
+    def test_neg(self):
+        # what to do?
+        assert_panel_equal(-self.panel, -1 * self.panel)
+
+    def test_invert(self):
+        assert_panel_equal(-(self.panel < 0), ~(self.panel <0))
+
+    def test_comparisons(self):
+        p1 = tm.makePanel()
+        p2 = tm.makePanel()
+
+        def test_comp(func):
+            result = func(p1, p2)
+            self.assert_(np.array_equal(result.values,
+                                        func(p1.values, p2.values)))
+
+            result3 = func(self.panel, 0)
+            self.assert_(np.array_equal(result3.values,
+                                        func(self.panel.values, 0)))
+
+        test_comp(operator.eq)
+        test_comp(operator.ne)
+        test_comp(operator.lt)
+        test_comp(operator.gt)
+        test_comp(operator.ge)
+        test_comp(operator.le)
+
     def test_get_value(self):
         for item in self.panel.items:
             for mjr in self.panel.major_axis[::2]:
diff --git a/pandas/tests/test_panel4d.py b/pandas/tests/test_panel4d.py
index 8340d5560..9399786c2 100644
--- a/pandas/tests/test_panel4d.py
+++ b/pandas/tests/test_panel4d.py
@@ -368,6 +368,42 @@ class CheckIndexing(object):
         self.panel4d['lP'] = self.panel4d['l1'] > 0
         self.assert_(self.panel4d['lP'].values.dtype == np.bool_)
 
+    def test_comparisons(self):
+        p1 = tm.makePanel4D()
+        p2 = tm.makePanel4D()
+
+        def test_comp(func):
+            result = func(p1, p2)
+            self.assert_(np.array_equal(result.values,
+                                        func(p1.values, p2.values)))
+
+            result3 = func(self.panel4d, 0)
+            self.assert_(np.array_equal(result3.values,
+                                        func(self.panel4d.values, 0)))
+
+        test_comp(operator.eq)
+        test_comp(operator.ne)
+        test_comp(operator.lt)
+        test_comp(operator.gt)
+        test_comp(operator.ge)
+        test_comp(operator.le)
+
+    def test_setitem_ndarray(self):
+        raise nose.SkipTest
+    #    from pandas import DateRange, datetools
+
+    #    timeidx = DateRange(start=datetime(2009,1,1),
+    #                        end=datetime(2009,12,31),
+    #                        offset=datetools.MonthEnd())
+    #    lons_coarse = np.linspace(-177.5, 177.5, 72)
+    #    lats_coarse = np.linspace(-87.5, 87.5, 36)
+    #    P = Panel(items=timeidx, major_axis=lons_coarse, minor_axis=lats_coarse)
+    #    data = np.random.randn(72*36).reshape((72,36))
+    #    key = datetime(2009,2,28)
+    #    P[key] = data#
+
+    #    assert_almost_equal(P[key].values, data)
+
     def test_major_xs(self):
         ref = self.panel4d['l1']['ItemA']
 

commit da8dd9544590b5b4bd210d7eb18bd14ed10e14d3
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu May 10 10:12:51 2012 -0400

    REF: working toward #1150, broke apart Cython module into generated _algos extension

diff --git a/pandas/core/common.py b/pandas/core/common.py
index cad17087a..bc9873b6c 100644
--- a/pandas/core/common.py
+++ b/pandas/core/common.py
@@ -18,6 +18,7 @@ except NameError:  # pragma: no cover
 from numpy.lib.format import read_array, write_array
 import numpy as np
 
+import pandas._algos as _algos
 import pandas._tseries as lib
 from pandas.util import py3compat
 import codecs
@@ -111,17 +112,17 @@ def _unpickle_array(bytes):
 def _take_1d_datetime(arr, indexer, out, fill_value=np.nan):
     view = arr.view(np.int64)
     outview = out.view(np.int64)
-    lib.take_1d_bool(view, indexer, outview, fill_value=fill_value)
+    _algos.take_1d_bool(view, indexer, outview, fill_value=fill_value)
 
 def _take_2d_axis0_datetime(arr, indexer, out, fill_value=np.nan):
     view = arr.view(np.int64)
     outview = out.view(np.int64)
-    lib.take_1d_bool(view, indexer, outview, fill_value=fill_value)
+    _algos.take_1d_bool(view, indexer, outview, fill_value=fill_value)
 
 def _take_2d_axis1_datetime(arr, indexer, out, fill_value=np.nan):
     view = arr.view(np.uint8)
     outview = out.view(np.uint8)
-    lib.take_1d_bool(view, indexer, outview, fill_value=fill_value)
+    _algos.take_1d_bool(view, indexer, outview, fill_value=fill_value)
 
 def _view_wrapper(f, wrap_dtype, na_override=None):
     def wrapper(arr, indexer, out, fill_value=np.nan):
@@ -134,42 +135,42 @@ def _view_wrapper(f, wrap_dtype, na_override=None):
 
 
 _take1d_dict = {
-    'float64' : lib.take_1d_float64,
-    'int32' : lib.take_1d_int32,
-    'int64' : lib.take_1d_int64,
-    'object' : lib.take_1d_object,
-    'bool' : _view_wrapper(lib.take_1d_bool, np.uint8),
-    'datetime64[us]' : _view_wrapper(lib.take_1d_int64, np.int64,
+    'float64' : _algos.take_1d_float64,
+    'int32' : _algos.take_1d_int32,
+    'int64' : _algos.take_1d_int64,
+    'object' : _algos.take_1d_object,
+    'bool' : _view_wrapper(_algos.take_1d_bool, np.uint8),
+    'datetime64[us]' : _view_wrapper(_algos.take_1d_int64, np.int64,
                                      na_override=lib.NaT),
 }
 
 _take2d_axis0_dict = {
-    'float64' : lib.take_2d_axis0_float64,
-    'int32' : lib.take_2d_axis0_int32,
-    'int64' : lib.take_2d_axis0_int64,
-    'object' : lib.take_2d_axis0_object,
-    'bool' : _view_wrapper(lib.take_2d_axis0_bool, np.uint8),
-    'datetime64[us]' : _view_wrapper(lib.take_2d_axis0_int64, np.int64,
+    'float64' : _algos.take_2d_axis0_float64,
+    'int32' : _algos.take_2d_axis0_int32,
+    'int64' : _algos.take_2d_axis0_int64,
+    'object' : _algos.take_2d_axis0_object,
+    'bool' : _view_wrapper(_algos.take_2d_axis0_bool, np.uint8),
+    'datetime64[us]' : _view_wrapper(_algos.take_2d_axis0_int64, np.int64,
                                      na_override=lib.NaT),
 }
 
 _take2d_axis1_dict = {
-    'float64' : lib.take_2d_axis1_float64,
-    'int32' : lib.take_2d_axis1_int32,
-    'int64' : lib.take_2d_axis1_int64,
-    'object' : lib.take_2d_axis1_object,
-    'bool' : _view_wrapper(lib.take_2d_axis1_bool, np.uint8),
-    'datetime64[us]' : _view_wrapper(lib.take_2d_axis1_int64, np.int64,
+    'float64' : _algos.take_2d_axis1_float64,
+    'int32' : _algos.take_2d_axis1_int32,
+    'int64' : _algos.take_2d_axis1_int64,
+    'object' : _algos.take_2d_axis1_object,
+    'bool' : _view_wrapper(_algos.take_2d_axis1_bool, np.uint8),
+    'datetime64[us]' : _view_wrapper(_algos.take_2d_axis1_int64, np.int64,
                                      na_override=lib.NaT),
 }
 
 _take2d_multi_dict = {
-    'float64' : lib.take_2d_multi_float64,
-    'int32' : lib.take_2d_multi_int32,
-    'int64' : lib.take_2d_multi_int64,
-    'object' : lib.take_2d_multi_object,
-    'bool' : _view_wrapper(lib.take_2d_multi_bool, np.uint8),
-    'datetime64[us]' : _view_wrapper(lib.take_2d_multi_int64, np.int64,
+    'float64' : _algos.take_2d_multi_float64,
+    'int32' : _algos.take_2d_multi_int32,
+    'int64' : _algos.take_2d_multi_int64,
+    'object' : _algos.take_2d_multi_object,
+    'bool' : _view_wrapper(_algos.take_2d_multi_bool, np.uint8),
+    'datetime64[us]' : _view_wrapper(_algos.take_2d_multi_int64, np.int64,
                                      na_override=lib.NaT),
 }
 
@@ -366,18 +367,18 @@ def _interp_wrapper(f, wrap_dtype, na_override=None):
         f(view, mask, limit=limit)
     return wrapper
 
-_pad_1d_datetime = _interp_wrapper(lib.pad_inplace_int64, np.int64)
-_pad_2d_datetime = _interp_wrapper(lib.pad_2d_inplace_int64, np.int64)
-_backfill_1d_datetime = _interp_wrapper(lib.backfill_inplace_int64, np.int64)
-_backfill_2d_datetime = _interp_wrapper(lib.backfill_2d_inplace_int64, np.int64)
+_pad_1d_datetime = _interp_wrapper(_algos.pad_inplace_int64, np.int64)
+_pad_2d_datetime = _interp_wrapper(_algos.pad_2d_inplace_int64, np.int64)
+_backfill_1d_datetime = _interp_wrapper(_algos.backfill_inplace_int64, np.int64)
+_backfill_2d_datetime = _interp_wrapper(_algos.backfill_2d_inplace_int64, np.int64)
 
 def pad_1d(values, limit=None):
     if is_float_dtype(values):
-        _method = lib.pad_inplace_float64
+        _method = _algos.pad_inplace_float64
     elif is_datetime64_dtype(values):
         _method = _pad_1d_datetime
     elif values.dtype == np.object_:
-        _method = lib.pad_inplace_object
+        _method = _algos.pad_inplace_object
     else: # pragma: no cover
         raise ValueError('Invalid dtype for padding')
 
@@ -385,11 +386,11 @@ def pad_1d(values, limit=None):
 
 def backfill_1d(values, limit=None):
     if is_float_dtype(values):
-        _method = lib.backfill_inplace_float64
+        _method = _algos.backfill_inplace_float64
     elif is_datetime64_dtype(values):
         _method = _backfill_1d_datetime
     elif values.dtype == np.object_:
-        _method = lib.backfill_inplace_object
+        _method = _algos.backfill_inplace_object
     else: # pragma: no cover
         raise ValueError('Invalid dtype for padding')
 
@@ -397,11 +398,11 @@ def backfill_1d(values, limit=None):
 
 def pad_2d(values, limit=None):
     if is_float_dtype(values):
-        _method = lib.pad_2d_inplace_float64
+        _method = _algos.pad_2d_inplace_float64
     elif is_datetime64_dtype(values):
         _method = _pad_2d_datetime
     elif values.dtype == np.object_:
-        _method = lib.pad_2d_inplace_object
+        _method = _algos.pad_2d_inplace_object
     else: # pragma: no cover
         raise ValueError('Invalid dtype for padding')
 
@@ -409,11 +410,11 @@ def pad_2d(values, limit=None):
 
 def backfill_2d(values, limit=None):
     if is_float_dtype(values):
-        _method = lib.backfill_2d_inplace_float64
+        _method = _algos.backfill_2d_inplace_float64
     elif is_datetime64_dtype(values):
         _method = _backfill_2d_datetime
     elif values.dtype == np.object_:
-        _method = lib.backfill_2d_inplace_object
+        _method = _algos.backfill_2d_inplace_object
     else: # pragma: no cover
         raise ValueError('Invalid dtype for padding')
 
diff --git a/pandas/core/index.py b/pandas/core/index.py
index d0b9ef4fb..dee176472 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -12,6 +12,7 @@ from pandas.util.decorators import cache_readonly
 from pandas.util import py3compat
 import pandas.core.common as com
 import pandas._tseries as lib
+import pandas._algos as _algos
 
 
 __all__ = ['Index']
@@ -56,11 +57,11 @@ class Index(np.ndarray):
     _join_precedence = 1
 
     # Cython methods
-    _groupby = lib.groupby_object
-    _arrmap = lib.arrmap_object
-    _left_indexer = lib.left_join_indexer_object
-    _inner_indexer = lib.inner_join_indexer_object
-    _outer_indexer = lib.outer_join_indexer_object
+    _groupby = _algos.groupby_object
+    _arrmap = _algos.arrmap_object
+    _left_indexer = _algos.left_join_indexer_object
+    _inner_indexer = _algos.inner_join_indexer_object
+    _outer_indexer = _algos.outer_join_indexer_object
 
     _box_scalars = False
 
@@ -1067,11 +1068,11 @@ class Index(np.ndarray):
 
 class Int64Index(Index):
 
-    _groupby = lib.groupby_int64
-    _arrmap = lib.arrmap_int64
-    _left_indexer = lib.left_join_indexer_int64
-    _inner_indexer = lib.inner_join_indexer_int64
-    _outer_indexer = lib.outer_join_indexer_int64
+    _groupby = _algos.groupby_int64
+    _arrmap = _algos.arrmap_int64
+    _left_indexer = _algos.left_join_indexer_int64
+    _inner_indexer = _algos.inner_join_indexer_int64
+    _outer_indexer = _algos.outer_join_indexer_int64
 
     _engine_type = lib.Int64Engine
 
@@ -1378,7 +1379,7 @@ class MultiIndex(Index):
                 return self.nlevels
             else:
                 return 0
-        
+
         int64_labels = [com._ensure_int64(lab) for lab in self.labels]
         for k in range(self.nlevels, 0, -1):
             if lib.is_lexsorted(int64_labels[:k]):
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 42bc2a8fd..823439b71 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -1388,55 +1388,45 @@ def period_strftime(int64_t value, int freq, int64_t mult, object fmt):
 
 ctypedef int (*accessor)(int64_t ordinal, int freq) except -1
 
-cdef int apply_accessor(accessor func, int64_t value, int freq,
-                        int64_t mult) except -1:
+def get_period_field(int code, int64_t value, int freq,
+                     int64_t mult):
+    cdef accessor f = _get_accessor_func(code)
     value = remove_mult(value, mult)
-    return func(value, freq)
-
-cpdef int get_period_year(int64_t value, int freq, int64_t mult) except -1:
-    return apply_accessor(&pyear, value, freq, mult)
-
-cpdef int get_period_qyear(int64_t value, int freq, int64_t mult) except -1:
-    return apply_accessor(&pqyear, value, freq, mult)
+    return f(value, freq)
 
-cpdef int get_period_quarter(int64_t value, int freq, int64_t mult) except -1:
-    return apply_accessor(&pquarter, value, freq, mult)
-
-cpdef int get_period_month(int64_t value, int freq, int64_t mult) except -1:
-    return apply_accessor(&pmonth, value, freq, mult)
-
-cpdef int get_period_day(int64_t value, int freq, int64_t mult) except -1:
-    return apply_accessor(&pday, value, freq, mult)
-
-cpdef int get_period_hour(int64_t value, int freq, int64_t mult) except -1:
-    return apply_accessor(&phour, value, freq, mult)
+def get_period_field_arr(int code, ndarray[int64_t] arr,
+                         int freq, int64_t mult):
+    cdef:
+        Py_ssize_t i, sz
+        ndarray[int64_t] out
+        accessor f
 
-cpdef int get_period_minute(int64_t value, int freq, int64_t mult) except -1:
-    return apply_accessor(&pminute, value, freq, mult)
+    f = _get_accessor_func(code)
 
-cpdef int get_period_second(int64_t value, int freq, int64_t mult) except -1:
-    return apply_accessor(&psecond, value, freq, mult)
+    sz = len(arr)
+    out = np.empty(sz, dtype=np.int64)
 
-cpdef int get_period_dow(int64_t value, int freq, int64_t mult) except -1:
-    return apply_accessor(&pday_of_week, value, freq, mult)
+    for i in range(sz):
+        out[i] = f(remove_mult(arr[i], mult), freq)
 
-cpdef int get_period_week(int64_t value, int freq, int64_t mult) except -1:
-    return apply_accessor(&pweek, value, freq, mult)
+    return out
 
-cpdef int get_period_weekday(int64_t value, int freq, int64_t mult) except -1:
-    return apply_accessor(&pweekday, value, freq, mult)
 
-cpdef int get_period_doy(int64_t value, int freq, int64_t mult) except -1:
-    return apply_accessor(&pday_of_year, value, freq, mult)
+cdef int apply_accessor(accessor func, int64_t value, int freq,
+                        int64_t mult) except -1:
+    value = remove_mult(value, mult)
+    return func(value, freq)
 
 # same but for arrays
 
-cdef ndarray[int64_t] apply_accessor_arr(accessor func,
-                                         ndarray[int64_t] arr,
+cdef ndarray[int64_t] apply_accessor_arr(accessor func, ndarray[int64_t] arr,
                                          int freq, int64_t mult):
     cdef:
         Py_ssize_t i, sz
         ndarray[int64_t] out
+        # accessor f
+
+    # f = _get_accessor_func(code)
 
     sz = len(arr)
     out = np.empty(sz, dtype=np.int64)
@@ -1447,41 +1437,106 @@ cdef ndarray[int64_t] apply_accessor_arr(accessor func,
 
     return out
 
-def get_period_year_arr(ndarray[int64_t] arr, int freq, int64_t mult):
-    return apply_accessor_arr(&pyear, arr, freq, mult)
 
-def get_period_qyear_arr(ndarray[int64_t] arr, int freq, int64_t mult):
-    return apply_accessor_arr(&pqyear, arr, freq, mult)
+cdef accessor _get_accessor_func(int code):
+    if code == 0:
+        return &pyear
+    elif code == 1:
+        return &pqyear
+    elif code == 2:
+        return &pquarter
+    elif code == 3:
+        return &pmonth
+    elif code == 4:
+        return &pday
+    elif code == 5:
+        return &phour
+    elif code == 6:
+        return &pminute
+    elif code == 7:
+        return &psecond
+    elif code == 8:
+        return &pweek
+    elif code == 9:
+        return &pday_of_year
+    elif code == 10:
+        return &pweekday
+    else:
+        raise ValueError('Unrecognized code: %s' % code)
+
+
+# def get_period_year_arr(ndarray[int64_t] arr, int freq, int64_t mult):
+#     return apply_accessor_arr(pyear, arr, freq, mult)
+
+# def get_period_qyear_arr(ndarray[int64_t] arr, int freq, int64_t mult):
+#     return apply_accessor_arr(pqyear, arr, freq, mult)
+
+# def get_period_quarter_arr(ndarray[int64_t] arr, int freq, int64_t mult):
+#     return apply_accessor_arr(pquarter, arr, freq, mult)
+
+# def get_period_month_arr(ndarray[int64_t] arr, int freq, int64_t mult):
+#     return apply_accessor_arr(pmonth, arr, freq, mult)
+
+# def get_period_day_arr(ndarray[int64_t] arr, int freq, int64_t mult):
+#     return apply_accessor_arr(pday, arr, freq, mult)
+
+# def get_period_hour_arr(ndarray[int64_t] arr, int freq, int64_t mult):
+#     return apply_accessor_arr(phour, arr, freq, mult)
+
+# def get_period_minute_arr(ndarray[int64_t] arr, int freq, int64_t mult):
+#     return apply_accessor_arr(pminute, arr, freq, mult)
+
+# def get_period_second_arr(ndarray[int64_t] arr, int freq, int64_t mult):
+#     return apply_accessor_arr(psecond, arr, freq, mult)
+
+# def get_period_dow_arr(ndarray[int64_t] arr, int freq, int64_t mult):
+#     return apply_accessor_arr(pday_of_week, arr, freq, mult)
+
+# def get_period_week_arr(ndarray[int64_t] arr, int freq, int64_t mult):
+#     return apply_accessor_arr(pweek, arr, freq, mult)
+
+# def get_period_weekday_arr(ndarray[int64_t] arr, int freq, int64_t mult):
+#     return apply_accessor_arr(pweekday, arr, freq, mult)
+
+# def get_period_doy_arr(ndarray[int64_t] arr, int freq, int64_t mult):
+#     return apply_accessor_arr(pday_of_year, arr, freq, mult)
+
+# def get_abs_time(freq, dailyDate, originalDate):
+#     return getAbsTime(freq, dailyDate, originalDate)
+
+
+# cpdef int get_period_year(int64_t value, int freq, int64_t mult) except -1:
+#     return apply_accessor(pyear, value, freq, mult)
 
-def get_period_quarter_arr(ndarray[int64_t] arr, int freq, int64_t mult):
-    return apply_accessor_arr(&pquarter, arr, freq, mult)
+# cpdef int get_period_qyear(int64_t value, int freq, int64_t mult) except -1:
+#     return apply_accessor(pqyear, value, freq, mult)
 
-def get_period_month_arr(ndarray[int64_t] arr, int freq, int64_t mult):
-    return apply_accessor_arr(&pmonth, arr, freq, mult)
+# cpdef int get_period_quarter(int64_t value, int freq, int64_t mult) except -1:
+#     return apply_accessor(pquarter, value, freq, mult)
 
-def get_period_day_arr(ndarray[int64_t] arr, int freq, int64_t mult):
-    return apply_accessor_arr(&pday, arr, freq, mult)
+# cpdef int get_period_month(int64_t value, int freq, int64_t mult) except -1:
+#     return apply_accessor(pmonth, value, freq, mult)
 
-def get_period_hour_arr(ndarray[int64_t] arr, int freq, int64_t mult):
-    return apply_accessor_arr(&phour, arr, freq, mult)
+# cpdef int get_period_day(int64_t value, int freq, int64_t mult) except -1:
+#     return apply_accessor(pday, value, freq, mult)
 
-def get_period_minute_arr(ndarray[int64_t] arr, int freq, int64_t mult):
-    return apply_accessor_arr(&pminute, arr, freq, mult)
+# cpdef int get_period_hour(int64_t value, int freq, int64_t mult) except -1:
+#     return apply_accessor(phour, value, freq, mult)
 
-def get_period_second_arr(ndarray[int64_t] arr, int freq, int64_t mult):
-    return apply_accessor_arr(&psecond, arr, freq, mult)
+# cpdef int get_period_minute(int64_t value, int freq, int64_t mult) except -1:
+#     return apply_accessor(pminute, value, freq, mult)
 
-def get_period_dow_arr(ndarray[int64_t] arr, int freq, int64_t mult):
-    return apply_accessor_arr(&pday_of_week, arr, freq, mult)
+# cpdef int get_period_second(int64_t value, int freq, int64_t mult) except -1:
+#     return apply_accessor(psecond, value, freq, mult)
 
-def get_period_week_arr(ndarray[int64_t] arr, int freq, int64_t mult):
-    return apply_accessor_arr(&pweek, arr, freq, mult)
+# cpdef int get_period_dow(int64_t value, int freq, int64_t mult) except -1:
+#     return apply_accessor(pday_of_week, value, freq, mult)
 
-def get_period_weekday_arr(ndarray[int64_t] arr, int freq, int64_t mult):
-    return apply_accessor_arr(&pweekday, arr, freq, mult)
+# cpdef int get_period_week(int64_t value, int freq, int64_t mult) except -1:
+#     return apply_accessor(pweek, value, freq, mult)
 
-def get_period_doy_arr(ndarray[int64_t] arr, int freq, int64_t mult):
-    return apply_accessor_arr(&pday_of_year, arr, freq, mult)
+# cpdef int get_period_weekday(int64_t value, int freq, int64_t mult) except -1:
+#     return apply_accessor(pweekday, value, freq, mult)
 
-def get_abs_time(freq, dailyDate, originalDate):
-    return getAbsTime(freq, dailyDate, originalDate)
+# cpdef int get_period_doy(int64_t value, int freq, int64_t mult) except -1:
+#     return apply_accessor(pday_of_year, value, freq, mult)
diff --git a/pandas/src/engines.pyx b/pandas/src/engines.pyx
index 07a547de8..df92cce1c 100644
--- a/pandas/src/engines.pyx
+++ b/pandas/src/engines.pyx
@@ -12,7 +12,7 @@ cimport util
 
 import numpy as np
 
-# import _tseries
+import _algos
 
 # include "hashtable.pyx"
 
@@ -243,14 +243,14 @@ cdef class Int64Engine(IndexEngine):
         return Int64HashTable(n)
 
     def _call_monotonic(self, values):
-        return is_monotonic_int64(values)
+        return _algos.is_monotonic_int64(values)
 
     def get_pad_indexer(self, other, limit=None):
-        return pad_int64(self._get_index_values(), other,
+        return _algos.pad_int64(self._get_index_values(), other,
                                   limit=limit)
 
     def get_backfill_indexer(self, other, limit=None):
-        return backfill_int64(self._get_index_values(), other,
+        return _algos.backfill_int64(self._get_index_values(), other,
                                        limit=limit)
 
     cdef _get_bool_indexer(self, object val):
@@ -292,26 +292,26 @@ cdef class Float64Engine(IndexEngine):
         return Float64HashTable(n)
 
     def _call_monotonic(self, values):
-        return is_monotonic_float64(values)
+        return _algos.is_monotonic_float64(values)
 
     def get_pad_indexer(self, other, limit=None):
-        return pad_float64(self._get_index_values(), other,
+        return _algos.pad_float64(self._get_index_values(), other,
                                     limit=limit)
 
     def get_backfill_indexer(self, other, limit=None):
-        return backfill_float64(self._get_index_values(), other,
+        return _algos.backfill_float64(self._get_index_values(), other,
                                          limit=limit)
 
 _pad_functions = {
-    'object' : pad_object,
-    'int64' : pad_int64,
-    'float64' : pad_float64
+    'object' : _algos.pad_object,
+    'int64' : _algos.pad_int64,
+    'float64' : _algos.pad_float64
 }
 
 _backfill_functions = {
-    'object': backfill_object,
-    'int64': backfill_int64,
-    'float64': backfill_float64
+    'object': _algos.backfill_object,
+    'int64': _algos.backfill_int64,
+    'float64': _algos.backfill_float64
 }
 
 cdef class ObjectEngine(IndexEngine):
@@ -322,14 +322,14 @@ cdef class ObjectEngine(IndexEngine):
         return PyObjectHashTable(n)
 
     def _call_monotonic(self, values):
-        return is_monotonic_object(values)
+        return _algos.is_monotonic_object(values)
 
     def get_pad_indexer(self, other, limit=None):
-        return pad_object(self._get_index_values(), other,
+        return _algos.pad_object(self._get_index_values(), other,
                                    limit=limit)
 
     def get_backfill_indexer(self, other, limit=None):
-        return backfill_object(self._get_index_values(), other,
+        return _algos.backfill_object(self._get_index_values(), other,
                                         limit=limit)
 
 
@@ -353,7 +353,7 @@ cdef class DatetimeEngine(Int64Engine):
         return self.index_weakref().values.view('i8')
 
     def _call_monotonic(self, values):
-        return is_monotonic_int64(values)
+        return _algos.is_monotonic_int64(values)
 
     cpdef get_loc(self, object val):
         if is_definitely_invalid_key(val):
@@ -404,15 +404,15 @@ cdef class DatetimeEngine(Int64Engine):
         if other.dtype != 'M8':
             return np.repeat(-1, len(other)).astype('i4')
         other = np.asarray(other).view('i8')
-        return pad_int64(self._get_index_values(), other,
-                                  limit=limit)
+        return _algos.pad_int64(self._get_index_values(), other,
+                                limit=limit)
 
     def get_backfill_indexer(self, other, limit=None):
         if other.dtype != 'M8':
             return np.repeat(-1, len(other)).astype('i4')
         other = np.asarray(other).view('i8')
-        return backfill_int64(self._get_index_values(), other,
-                                       limit=limit)
+        return _algos.backfill_int64(self._get_index_values(), other,
+                                     limit=limit)
 
 
 # ctypedef fused idxvalue_t:
diff --git a/pandas/src/generate_code.py b/pandas/src/generate_code.py
index ee151b6eb..7650cdb11 100644
--- a/pandas/src/generate_code.py
+++ b/pandas/src/generate_code.py
@@ -1,5 +1,51 @@
 from pandas.util.py3compat import StringIO
 
+header = """
+cimport numpy as np
+cimport cython
+
+from numpy cimport *
+
+from cpython cimport (PyDict_New, PyDict_GetItem, PyDict_SetItem,
+                      PyDict_Contains, PyDict_Keys,
+                      Py_INCREF, PyTuple_SET_ITEM,
+                      PyTuple_SetItem,
+                      PyTuple_New)
+from cpython cimport PyFloat_Check
+cimport cpython
+
+import numpy as np
+isnan = np.isnan
+cdef double NaN = <double> np.NaN
+cdef double nan = NaN
+
+from datetime import datetime as pydatetime
+
+# this is our datetime.pxd
+from datetime cimport *
+
+from khash cimport *
+
+cdef inline int int_max(int a, int b): return a if a >= b else b
+cdef inline int int_min(int a, int b): return a if a <= b else b
+
+ctypedef unsigned char UChar
+
+cimport util
+from util cimport is_array, _checknull, _checknan
+
+cdef extern from "math.h":
+    double sqrt(double x)
+    double fabs(double)
+
+# import datetime C API
+PyDateTime_IMPORT
+
+# initialize numpy
+import_array()
+import_ufunc()
+"""
+
 take_1d_template = """@cython.wraparound(False)
 @cython.boundscheck(False)
 def take_1d_%(name)s(ndarray[%(c_type)s] values,
@@ -540,6 +586,8 @@ def arrmap_%(name)s(ndarray[%(c_type)s] index, object func):
 
     cdef ndarray[object] result = np.empty(length, dtype=np.object_)
 
+    from _tseries import maybe_convert_objects
+
     for i in range(length):
         result[i] = func(index[i])
 
@@ -851,6 +899,8 @@ templates_2d = [take_2d_axis0_template,
 
 def generate_take_cython_file(path='generated.pyx'):
     with open(path, 'w') as f:
+        print >> f, header
+
         for template in templates_1d:
             print >> f, generate_from_template(template)
 
diff --git a/pandas/src/generated.pyx b/pandas/src/generated.pyx
index ed5f12791..44442210b 100644
--- a/pandas/src/generated.pyx
+++ b/pandas/src/generated.pyx
@@ -1,3 +1,48 @@
+
+cimport numpy as np
+cimport cython
+
+from numpy cimport *
+
+from cpython cimport (PyDict_New, PyDict_GetItem, PyDict_SetItem,
+                      PyDict_Contains, PyDict_Keys,
+                      Py_INCREF, PyTuple_SET_ITEM,
+                      PyTuple_SetItem,
+                      PyTuple_New)
+from cpython cimport PyFloat_Check
+cimport cpython
+
+import numpy as np
+isnan = np.isnan
+cdef double NaN = <double> np.NaN
+cdef double nan = NaN
+
+from datetime import datetime as pydatetime
+
+# this is our datetime.pxd
+from datetime cimport *
+
+from khash cimport *
+
+cdef inline int int_max(int a, int b): return a if a >= b else b
+cdef inline int int_min(int a, int b): return a if a <= b else b
+
+ctypedef unsigned char UChar
+
+cimport util
+from util cimport is_array, _checknull, _checknan
+
+cdef extern from "math.h":
+    double sqrt(double x)
+    double fabs(double)
+
+# import datetime C API
+PyDateTime_IMPORT
+
+# initialize numpy
+import_array()
+import_ufunc()
+
 @cython.wraparound(False)
 @cython.boundscheck(False)
 cpdef map_indices_float64(ndarray[float64_t] index):
@@ -1751,6 +1796,8 @@ def arrmap_float64(ndarray[float64_t] index, object func):
 
     cdef ndarray[object] result = np.empty(length, dtype=np.object_)
 
+    from _tseries import maybe_convert_objects
+
     for i in range(length):
         result[i] = func(index[i])
 
@@ -1764,6 +1811,8 @@ def arrmap_object(ndarray[object] index, object func):
 
     cdef ndarray[object] result = np.empty(length, dtype=np.object_)
 
+    from _tseries import maybe_convert_objects
+
     for i in range(length):
         result[i] = func(index[i])
 
@@ -1777,6 +1826,8 @@ def arrmap_int32(ndarray[int32_t] index, object func):
 
     cdef ndarray[object] result = np.empty(length, dtype=np.object_)
 
+    from _tseries import maybe_convert_objects
+
     for i in range(length):
         result[i] = func(index[i])
 
@@ -1790,6 +1841,8 @@ def arrmap_int64(ndarray[int64_t] index, object func):
 
     cdef ndarray[object] result = np.empty(length, dtype=np.object_)
 
+    from _tseries import maybe_convert_objects
+
     for i in range(length):
         result[i] = func(index[i])
 
@@ -1803,6 +1856,8 @@ def arrmap_bool(ndarray[uint8_t] index, object func):
 
     cdef ndarray[object] result = np.empty(length, dtype=np.object_)
 
+    from _tseries import maybe_convert_objects
+
     for i in range(length):
         result[i] = func(index[i])
 
diff --git a/pandas/src/period.c b/pandas/src/period.c
index d7c3260f7..ee44720a5 100644
--- a/pandas/src/period.c
+++ b/pandas/src/period.c
@@ -1,6 +1,5 @@
 #include "period.h"
-#include "limits.h"
-// #include "numpy/ndarraytypes.h"
+
 
 /*
  * Borrowed and derived code from scikits.timeseries that we will expose via
@@ -29,7 +28,7 @@ static int days_in_month[2][12] = {
 };
 
 /* Return 1/0 iff year points to a leap year in calendar. */
-static int dInfoCalc_Leapyear(int64_t year, int calendar)
+static int dInfoCalc_Leapyear(npy_int64 year, int calendar)
 {
     if (calendar == GREGORIAN_CALENDAR) {
         return (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0));
@@ -39,7 +38,7 @@ static int dInfoCalc_Leapyear(int64_t year, int calendar)
 }
 
 /* Return the day of the week for the given absolute date. */
-static int dInfoCalc_DayOfWeek(int64_t absdate)
+static int dInfoCalc_DayOfWeek(npy_int64 absdate)
 {
     int day_of_week;
 
@@ -61,7 +60,7 @@ static int monthToQuarter(int month) { return ((month-1)/3)+1; }
    using the Gregorian Epoch) value by two days because the Epoch
    (0001-01-01) in the Julian calendar lies 2 days before the Epoch in
    the Gregorian calendar. */
-static int dInfoCalc_YearOffset(int64_t year, int calendar)
+static int dInfoCalc_YearOffset(npy_int64 year, int calendar)
 {
     year--;
     if (calendar == GREGORIAN_CALENDAR) {
@@ -93,7 +92,8 @@ static int dInfoCalc_SetFromDateAndTime(struct date_info *dinfo,
     /* Calculate the absolute date */
     {
         int leap;
-        int64_t yearoffset,absdate;
+		npy_int64 absdate;
+        int yearoffset;
 
         /* Range check */
         Py_AssertWithArg(year > -(INT_MAX / 366) && year < (INT_MAX / 366),
@@ -173,19 +173,18 @@ static int dInfoCalc_SetFromDateAndTime(struct date_info *dinfo,
        than with this iterative approach... */
 static
 int dInfoCalc_SetFromAbsDate(register struct date_info *dinfo,
-                  int64_t absdate,
-                  int calendar)
+							 npy_int64 absdate, int calendar)
 {
-    register int64_t year;
-    int64_t yearoffset;
+    register npy_int64 year;
+    npy_int64 yearoffset;
     int leap,dayoffset;
     int *monthoffset;
 
     /* Approximate year */
     if (calendar == GREGORIAN_CALENDAR) {
-        year = (int64_t)(((double)absdate) / 365.2425);
+        year = (npy_int64)(((double)absdate) / 365.2425);
     } else if (calendar == JULIAN_CALENDAR) {
-        year = (int64_t)(((double)absdate) / 365.25);
+        year = (npy_int64)(((double)absdate) / 365.25);
     } else {
         Py_Error(PyExc_ValueError, "unknown calendar");
     }
@@ -194,7 +193,7 @@ int dInfoCalc_SetFromAbsDate(register struct date_info *dinfo,
     /* Apply corrections to reach the correct year */
     while (1) {
         /* Calculate the year offset */
-        yearoffset = dInfoCalc_YearOffset(year,calendar);
+        yearoffset = dInfoCalc_YearOffset(year, calendar);
         if (PyErr_Occurred())
             goto onError;
 
@@ -254,28 +253,27 @@ int dInfoCalc_SetFromAbsDate(register struct date_info *dinfo,
 
 // helpers for frequency conversion routines //
 
-static int64_t DtoB_weekday(int64_t fromDate) {
-    return (((fromDate) / 7) * 5) + (fromDate)%7;
+static npy_int64 DtoB_weekday(npy_int64 ordinal) {
+    return (((ordinal) / 7) * 5) + (ordinal) % 7;
 }
 
-static int64_t DtoB_WeekendToMonday(int64_t absdate, int day_of_week) {
-
+static npy_int64 DtoB_WeekendToMonday(npy_int64 ordinal, int day_of_week) {
     if (day_of_week > 4) {
         //change to Monday after weekend
-        absdate += (7 - day_of_week);
+        ordinal += (7 - day_of_week);
     }
-    return DtoB_weekday(absdate);
+    return DtoB_weekday(ordinal);
 }
 
-static int64_t DtoB_WeekendToFriday(int64_t absdate, int day_of_week) {
+static npy_int64 DtoB_WeekendToFriday(npy_int64 ordinal, int day_of_week) {
     if (day_of_week > 4) {
         //change to friday before weekend
-        absdate -= (day_of_week - 4);
+        ordinal -= (day_of_week - 4);
     }
-    return DtoB_weekday(absdate);
+    return DtoB_weekday(ordinal);
 }
 
-static int64_t absdate_from_ymd(int y, int m, int d) {
+static npy_int64 absdate_from_ymd(int y, int m, int d) {
     struct date_info tempDate;
     if (dInfoCalc_SetFromDateAndTime(&tempDate, y, m, d, 0, 0, 0, GREGORIAN_CALENDAR)) {
         return INT_ERR_CODE;
@@ -285,20 +283,24 @@ static int64_t absdate_from_ymd(int y, int m, int d) {
 
 //************ FROM DAILY ***************
 
-static int64_t asfreq_DtoA(int64_t fromDate, char relation, asfreq_info *af_info) {
+static npy_int64 asfreq_DtoA(npy_int64 ordinal, char relation, asfreq_info *af_info) {
 
     struct date_info dinfo;
-    if (dInfoCalc_SetFromAbsDate(&dinfo, fromDate,
-                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
-    if (dinfo.month > af_info->to_a_year_end) { return (int64_t)(dinfo.year + 1); }
-    else { return (int64_t)(dinfo.year); }
+    if (dInfoCalc_SetFromAbsDate(&dinfo, ordinal + ORD_OFFSET,
+								 GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+    if (dinfo.month > af_info->to_a_year_end) {
+	  return (npy_int64)(dinfo.year + 1 - BASE_YEAR);
+	}
+    else {
+	  return (npy_int64)(dinfo.year - BASE_YEAR);
+	}
 }
 
-static int64_t DtoQ_yq(int64_t fromDate, asfreq_info *af_info,
-                              int *year, int *quarter) {
+static npy_int64 DtoQ_yq(npy_int64 ordinal, asfreq_info *af_info,
+					   int *year, int *quarter) {
     struct date_info dinfo;
-    if (dInfoCalc_SetFromAbsDate(&dinfo, fromDate,
-                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+    if (dInfoCalc_SetFromAbsDate(&dinfo, ordinal + ORD_OFFSET,
+								 GREGORIAN_CALENDAR)) return INT_ERR_CODE;
     if (af_info->to_q_year_end != 12) {
         dinfo.month -= af_info->to_q_year_end;
         if (dinfo.month <= 0) { dinfo.month += 12; }
@@ -313,34 +315,34 @@ static int64_t DtoQ_yq(int64_t fromDate, asfreq_info *af_info,
 }
 
 
-static int64_t asfreq_DtoQ(int64_t fromDate, char relation, asfreq_info *af_info) {
+static npy_int64 asfreq_DtoQ(npy_int64 ordinal, char relation, asfreq_info *af_info) {
 
     int year, quarter;
 
-    if (DtoQ_yq(fromDate, af_info, &year, &quarter) == INT_ERR_CODE) {
+    if (DtoQ_yq(ordinal, af_info, &year, &quarter) == INT_ERR_CODE) {
         return INT_ERR_CODE;
     }
 
-    return (int64_t)((year - 1) * 4 + quarter);
+    return (npy_int64)((year - BASE_YEAR) * 4 + quarter - 1);
 }
 
-static int64_t asfreq_DtoM(int64_t fromDate, char relation, asfreq_info *af_info) {
+static npy_int64 asfreq_DtoM(npy_int64 ordinal, char relation, asfreq_info *af_info) {
 
     struct date_info dinfo;
-    if (dInfoCalc_SetFromAbsDate(&dinfo, fromDate, GREGORIAN_CALENDAR))
+    if (dInfoCalc_SetFromAbsDate(&dinfo, ordinal + ORD_OFFSET, GREGORIAN_CALENDAR))
         return INT_ERR_CODE;
-    return (int64_t)((dinfo.year - 1) * 12 + dinfo.month);
+    return (npy_int64)((dinfo.year - BASE_YEAR) * 12 + dinfo.month - 1);
 }
 
-static int64_t asfreq_DtoW(int64_t fromDate, char relation, asfreq_info *af_info) {
-    return (fromDate - (1 + af_info->to_week_end))/7 + 1;
+static npy_int64 asfreq_DtoW(npy_int64 ordinal, char relation, asfreq_info *af_info) {
+    return (ordinal + ORD_OFFSET - (1 + af_info->to_week_end))/7 + 1;
 }
 
-static int64_t asfreq_DtoB(int64_t fromDate, char relation, asfreq_info *af_info) {
+static npy_int64 asfreq_DtoB(npy_int64 ordinal, char relation, asfreq_info *af_info) {
 
     struct date_info dinfo;
-    if (dInfoCalc_SetFromAbsDate(&dinfo, fromDate,
-                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+    if (dInfoCalc_SetFromAbsDate(&dinfo, ordinal + ORD_OFFSET,
+								 GREGORIAN_CALENDAR)) return INT_ERR_CODE;
 
     if (relation == 'S') {
         return DtoB_WeekendToFriday(dinfo.absdate, dinfo.day_of_week);
@@ -349,222 +351,241 @@ static int64_t asfreq_DtoB(int64_t fromDate, char relation, asfreq_info *af_info
     }
 }
 
-static int64_t asfreq_DtoB_forConvert(int64_t fromDate, char relation, asfreq_info *af_info) {
+static npy_int64 asfreq_DtoB_forConvert(npy_int64 ordinal, char relation, asfreq_info *af_info) {
 
     struct date_info dinfo;
-    if (dInfoCalc_SetFromAbsDate(&dinfo, fromDate, GREGORIAN_CALENDAR))
+    if (dInfoCalc_SetFromAbsDate(&dinfo, ordinal + ORD_OFFSET, GREGORIAN_CALENDAR))
         return INT_ERR_CODE;
 
     if (dinfo.day_of_week > 4) {
         return INT_ERR_CODE;
     } else {
-        return DtoB_weekday(fromDate);
+        return DtoB_weekday(ordinal);
     }
 }
 
 // needed for getDateInfo function
-static int64_t asfreq_DtoD(int64_t fromDate, char relation, asfreq_info *af_info) { return fromDate; }
-
-static int64_t asfreq_DtoHIGHFREQ(int64_t fromDate, char relation, int64_t periodsPerDay) {
-    if (fromDate >= HIGHFREQ_ORIG) {
-        if (relation == 'S') { return (fromDate - HIGHFREQ_ORIG)*(periodsPerDay) + 1; }
-        else                 { return (fromDate - HIGHFREQ_ORIG + 1)*(periodsPerDay); }
+static npy_int64 asfreq_DtoD(npy_int64 ordinal, char relation, asfreq_info *af_info) { return ordinal; }
+
+static npy_int64 asfreq_DtoHIGHFREQ(npy_int64 ordinal, char relation, npy_int64 periodsPerDay) {
+    if (ordinal >= HIGHFREQ_ORIG) {
+        if (relation == 'S') {
+		  return (ordinal - HIGHFREQ_ORIG)*(periodsPerDay) + 1;
+		}
+        else {
+		  return (ordinal - HIGHFREQ_ORIG + 1)*(periodsPerDay);
+		}
     } else { return INT_ERR_CODE; }
 }
 
-static int64_t asfreq_DtoH(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoHIGHFREQ(fromDate, relation, 24); }
-static int64_t asfreq_DtoT(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoHIGHFREQ(fromDate, relation, 24*60); }
-static int64_t asfreq_DtoS(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoHIGHFREQ(fromDate, relation, 24*60*60); }
+static npy_int64 asfreq_DtoH(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoHIGHFREQ(ordinal, relation, 24); }
+static npy_int64 asfreq_DtoT(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoHIGHFREQ(ordinal, relation, 24*60); }
+static npy_int64 asfreq_DtoS(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoHIGHFREQ(ordinal, relation, 24*60*60); }
 
 //************ FROM SECONDLY ***************
 
-static int64_t asfreq_StoD(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return (fromDate - 1)/(60*60*24) + HIGHFREQ_ORIG; }
-
-static int64_t asfreq_StoA(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoA(asfreq_StoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
-static int64_t asfreq_StoQ(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoQ(asfreq_StoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
-static int64_t asfreq_StoM(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoM(asfreq_StoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
-static int64_t asfreq_StoW(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoW(asfreq_StoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
-static int64_t asfreq_StoB(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoB(asfreq_StoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
-static int64_t asfreq_StoB_forConvert(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoB_forConvert(asfreq_StoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
-static int64_t asfreq_StoT(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return (fromDate - 1)/60 + 1; }
-static int64_t asfreq_StoH(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return (fromDate - 1)/(60*60) + 1; }
+static npy_int64 asfreq_StoD(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return (ordinal - 1)/(60*60*24) + HIGHFREQ_ORIG; }
+
+static npy_int64 asfreq_StoA(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoA(asfreq_StoD(ordinal, relation, &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_StoQ(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoQ(asfreq_StoD(ordinal, relation, &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_StoM(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoM(asfreq_StoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_StoW(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_StoD(ordinal, relation, &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_StoB(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoB(asfreq_StoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_StoB_forConvert(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoB_forConvert(asfreq_StoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_StoT(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return (ordinal - 1)/60 + 1; }
+static npy_int64 asfreq_StoH(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return (ordinal - 1)/(60*60) + 1; }
 
 //************ FROM MINUTELY ***************
 
-static int64_t asfreq_TtoD(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return (fromDate - 1)/(60*24) + HIGHFREQ_ORIG; }
-
-static int64_t asfreq_TtoA(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoA(asfreq_TtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
-static int64_t asfreq_TtoQ(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoQ(asfreq_TtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
-static int64_t asfreq_TtoM(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoM(asfreq_TtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
-static int64_t asfreq_TtoW(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoW(asfreq_TtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
-static int64_t asfreq_TtoB(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoB(asfreq_TtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
-
-static int64_t asfreq_TtoB_forConvert(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoB_forConvert(asfreq_TtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
-
-static int64_t asfreq_TtoH(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return (fromDate - 1)/60 + 1; }
-static int64_t asfreq_TtoS(int64_t fromDate, char relation, asfreq_info *af_info) {
-    if (relation == 'S') {  return fromDate*60 - 59; }
-    else                 {  return fromDate*60;      }}
+static npy_int64 asfreq_TtoD(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return (ordinal - 1)/(60*24) + HIGHFREQ_ORIG; }
+
+static npy_int64 asfreq_TtoA(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoA(asfreq_TtoD(ordinal, relation, &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_TtoQ(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoQ(asfreq_TtoD(ordinal, relation, &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_TtoM(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoM(asfreq_TtoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_TtoW(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_TtoD(ordinal, relation, &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_TtoB(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoB(asfreq_TtoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+
+static npy_int64 asfreq_TtoB_forConvert(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoB_forConvert(asfreq_TtoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+
+static npy_int64 asfreq_TtoH(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return (ordinal - 1)/60 + 1; }
+static npy_int64 asfreq_TtoS(npy_int64 ordinal, char relation, asfreq_info *af_info) {
+    if (relation == 'S') {  return ordinal*60 - 59; }
+    else                 {  return ordinal*60;      }}
 
 //************ FROM HOURLY ***************
 
-static int64_t asfreq_HtoD(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return (fromDate - 1)/24 + HIGHFREQ_ORIG; }
-static int64_t asfreq_HtoA(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoA(asfreq_HtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
-static int64_t asfreq_HtoQ(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoQ(asfreq_HtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
-static int64_t asfreq_HtoM(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoM(asfreq_HtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
-static int64_t asfreq_HtoW(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoW(asfreq_HtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
-static int64_t asfreq_HtoB(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoB(asfreq_HtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
-
-static int64_t asfreq_HtoB_forConvert(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoB_forConvert(asfreq_HtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_HtoD(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return (ordinal - 1)/24 + HIGHFREQ_ORIG; }
+static npy_int64 asfreq_HtoA(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoA(asfreq_HtoD(ordinal, relation, &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_HtoQ(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoQ(asfreq_HtoD(ordinal, relation, &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_HtoM(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoM(asfreq_HtoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_HtoW(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_HtoD(ordinal, relation, &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_HtoB(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoB(asfreq_HtoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+
+static npy_int64 asfreq_HtoB_forConvert(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoB_forConvert(asfreq_HtoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
 
 // calculation works out the same as TtoS, so we just call that function for HtoT
-static int64_t asfreq_HtoT(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_TtoS(fromDate, relation, &NULL_AF_INFO); }
-static int64_t asfreq_HtoS(int64_t fromDate, char relation, asfreq_info *af_info) {
-    if (relation == 'S') {  return fromDate*60*60 - 60*60 + 1; }
-    else                 {  return fromDate*60*60;             }}
+static npy_int64 asfreq_HtoT(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_TtoS(ordinal, relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_HtoS(npy_int64 ordinal, char relation, asfreq_info *af_info) {
+    if (relation == 'S') {  return ordinal*60*60 - 60*60 + 1; }
+    else                 {  return ordinal*60*60;             }}
 
 //************ FROM BUSINESS ***************
 
-static int64_t asfreq_BtoD(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return ((fromDate-1)/5)*7 + (fromDate-1)%5 + 1; }
+static npy_int64 asfreq_BtoD(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    {
+	  return ((ordinal-1)/5)*7 + (ordinal-1)%5 + 1- ORD_OFFSET;
+	}
 
-static int64_t asfreq_BtoA(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoA(asfreq_BtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_BtoA(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoA(asfreq_BtoD(ordinal, relation, &NULL_AF_INFO), relation, af_info); }
 
-static int64_t asfreq_BtoQ(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoQ(asfreq_BtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_BtoQ(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoQ(asfreq_BtoD(ordinal, relation, &NULL_AF_INFO), relation, af_info); }
 
-static int64_t asfreq_BtoM(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoM(asfreq_BtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_BtoM(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoM(asfreq_BtoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
 
-static int64_t asfreq_BtoW(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoW(asfreq_BtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_BtoW(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_BtoD(ordinal, relation, &NULL_AF_INFO), relation, af_info); }
 
-static int64_t asfreq_BtoH(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoH(asfreq_BtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_BtoH(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoH(asfreq_BtoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
 
-static int64_t asfreq_BtoT(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoT(asfreq_BtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_BtoT(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoT(asfreq_BtoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
 
-static int64_t asfreq_BtoS(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoS(asfreq_BtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_BtoS(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoS(asfreq_BtoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
 
 //************ FROM WEEKLY ***************
 
-static int64_t asfreq_WtoD(int64_t fromDate, char relation, asfreq_info *af_info) {
-    if (relation == 'S') { return fromDate * 7 - 6 + af_info->from_week_end;}
-    else                 { return fromDate * 7 + af_info->from_week_end; }
+static npy_int64 asfreq_WtoD(npy_int64 ordinal, char relation, asfreq_info *af_info) {
+    if (relation == 'S') {
+	  return ordinal * 7 - 6 + af_info->from_week_end - ORD_OFFSET;
+	}
+    else {
+	  return ordinal * 7 + af_info->from_week_end - ORD_OFFSET;
+	}
 }
 
-static int64_t asfreq_WtoA(int64_t fromDate, char relation, asfreq_info *af_info) {
-    return asfreq_DtoA(asfreq_WtoD(fromDate, 'E', af_info), relation, af_info); }
-static int64_t asfreq_WtoQ(int64_t fromDate, char relation, asfreq_info *af_info) {
-    return asfreq_DtoQ(asfreq_WtoD(fromDate, 'E', af_info), relation, af_info); }
-static int64_t asfreq_WtoM(int64_t fromDate, char relation, asfreq_info *af_info) {
-    return asfreq_DtoM(asfreq_WtoD(fromDate, 'E', af_info), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_WtoA(npy_int64 ordinal, char relation, asfreq_info *af_info) {
+    return asfreq_DtoA(asfreq_WtoD(ordinal, 'E', af_info), relation, af_info); }
+static npy_int64 asfreq_WtoQ(npy_int64 ordinal, char relation, asfreq_info *af_info) {
+    return asfreq_DtoQ(asfreq_WtoD(ordinal, 'E', af_info), relation, af_info); }
+static npy_int64 asfreq_WtoM(npy_int64 ordinal, char relation, asfreq_info *af_info) {
+    return asfreq_DtoM(asfreq_WtoD(ordinal, 'E', af_info), relation, &NULL_AF_INFO); }
 
-static int64_t asfreq_WtoW(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoW(asfreq_WtoD(fromDate, relation, af_info), relation, af_info); }
+static npy_int64 asfreq_WtoW(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_WtoD(ordinal, relation, af_info), relation, af_info); }
 
-static int64_t asfreq_WtoB(int64_t fromDate, char relation, asfreq_info *af_info) {
+static npy_int64 asfreq_WtoB(npy_int64 ordinal, char relation, asfreq_info *af_info) {
 
     struct date_info dinfo;
-    if (dInfoCalc_SetFromAbsDate(&dinfo, asfreq_WtoD(fromDate, relation, af_info),
+    if (dInfoCalc_SetFromAbsDate(&dinfo,
+								 asfreq_WtoD(ordinal, relation, af_info) + ORD_OFFSET,
                     GREGORIAN_CALENDAR)) return INT_ERR_CODE;
 
     if (relation == 'S') { return DtoB_WeekendToMonday(dinfo.absdate, dinfo.day_of_week); }
     else                 { return DtoB_WeekendToFriday(dinfo.absdate, dinfo.day_of_week); }
 }
 
-static int64_t asfreq_WtoH(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoH(asfreq_WtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
-static int64_t asfreq_WtoT(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoT(asfreq_WtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
-static int64_t asfreq_WtoS(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoS(asfreq_WtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_WtoH(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoH(asfreq_WtoD(ordinal, relation, af_info), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_WtoT(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoT(asfreq_WtoD(ordinal, relation, af_info), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_WtoS(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoS(asfreq_WtoD(ordinal, relation, af_info), relation, &NULL_AF_INFO); }
 
 //************ FROM MONTHLY ***************
 
-static void MtoD_ym(int64_t fromDate, int64_t *y, int64_t *m) {
-    *y = (fromDate - 1) / 12 + 1;
-    *m = fromDate - 12 * (*y) - 1;
+static int mod_compat(int x, int m) {
+  int result = x % m;
+  if (result < 0) return result + m;
+  return result;
+}
+
+static void MtoD_ym(npy_int64 ordinal, int *y, int *m) {
+    *y = ordinal / 12 + BASE_YEAR;
+    *m = mod_compat(ordinal + 1, 12);
 }
 
-static int64_t asfreq_MtoD(int64_t fromDate, char relation, asfreq_info *af_info) {
 
-    int64_t y, m, absdate;
+static npy_int64 asfreq_MtoD(npy_int64 ordinal, char relation, asfreq_info *af_info) {
+
+    npy_int64 absdate;
+    int y, m;
 
     if (relation == 'S') {
-        MtoD_ym(fromDate, &y, &m);
+        MtoD_ym(ordinal, &y, &m);
         if ((absdate = absdate_from_ymd(y, m, 1)) == INT_ERR_CODE) return INT_ERR_CODE;
-        return absdate;
+        return absdate - ORD_OFFSET;
     } else {
-        MtoD_ym(fromDate+1, &y, &m);
+        MtoD_ym(ordinal+1, &y, &m);
         if ((absdate = absdate_from_ymd(y, m, 1)) == INT_ERR_CODE) return INT_ERR_CODE;
-        return absdate-1;
+        return absdate - 1 - ORD_OFFSET;
     }
 }
 
-static int64_t asfreq_MtoA(int64_t fromDate, char relation, asfreq_info *af_info) {
-    return asfreq_DtoA(asfreq_MtoD(fromDate, 'E', &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_MtoA(npy_int64 ordinal, char relation, asfreq_info *af_info) {
+    return asfreq_DtoA(asfreq_MtoD(ordinal, 'E', &NULL_AF_INFO), relation, af_info); }
 
-static int64_t asfreq_MtoQ(int64_t fromDate, char relation, asfreq_info *af_info) {
-    return asfreq_DtoQ(asfreq_MtoD(fromDate, 'E', &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_MtoQ(npy_int64 ordinal, char relation, asfreq_info *af_info) {
+    return asfreq_DtoQ(asfreq_MtoD(ordinal, 'E', &NULL_AF_INFO), relation, af_info); }
 
-static int64_t asfreq_MtoW(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoW(asfreq_MtoD(fromDate, relation, &NULL_AF_INFO), relation, af_info); }
+static npy_int64 asfreq_MtoW(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_MtoD(ordinal, relation, &NULL_AF_INFO), relation, af_info); }
 
-static int64_t asfreq_MtoB(int64_t fromDate, char relation, asfreq_info *af_info) {
+static npy_int64 asfreq_MtoB(npy_int64 ordinal, char relation, asfreq_info *af_info) {
 
     struct date_info dinfo;
-    if (dInfoCalc_SetFromAbsDate(&dinfo, asfreq_MtoD(fromDate, relation, &NULL_AF_INFO),
-                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+    if (dInfoCalc_SetFromAbsDate(&dinfo,
+								 asfreq_MtoD(ordinal, relation, &NULL_AF_INFO) + ORD_OFFSET,
+								 GREGORIAN_CALENDAR)) return INT_ERR_CODE;
 
     if (relation == 'S') { return DtoB_WeekendToMonday(dinfo.absdate, dinfo.day_of_week); }
     else                 { return DtoB_WeekendToFriday(dinfo.absdate, dinfo.day_of_week); }
 }
 
-static int64_t asfreq_MtoH(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoH(asfreq_MtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
-static int64_t asfreq_MtoT(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoT(asfreq_MtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
-static int64_t asfreq_MtoS(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoS(asfreq_MtoD(fromDate, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_MtoH(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoH(asfreq_MtoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_MtoT(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoT(asfreq_MtoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_MtoS(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoS(asfreq_MtoD(ordinal, relation, &NULL_AF_INFO), relation, &NULL_AF_INFO); }
 
 //************ FROM QUARTERLY ***************
 
-static void QtoD_ym(int64_t fromDate, int64_t *y, int64_t *m, asfreq_info *af_info) {
-
-    *y = (fromDate - 1) / 4 + 1;
-    *m = (fromDate + 4) * 3 - 12 * (*y) - 2;
+static void QtoD_ym(npy_int64 ordinal, int *y, int *m, asfreq_info *af_info) {
+    *y = ordinal / 4 + BASE_YEAR;
+    *m = (ordinal % 4) * 3 + 1;
 
     if (af_info->from_q_year_end != 12) {
         *m += af_info->from_q_year_end;
@@ -573,106 +594,117 @@ static void QtoD_ym(int64_t fromDate, int64_t *y, int64_t *m, asfreq_info *af_in
     }
 }
 
-static int64_t asfreq_QtoD(int64_t fromDate, char relation, asfreq_info *af_info) {
+static npy_int64 asfreq_QtoD(npy_int64 ordinal, char relation, asfreq_info *af_info) {
 
-    int64_t y, m, absdate;
+    npy_int64 absdate;
+    int y, m;
 
     if (relation == 'S') {
-        QtoD_ym(fromDate, &y, &m, af_info);
+        QtoD_ym(ordinal, &y, &m, af_info);
+		// printf("ordinal: %d, year: %d, month: %d\n", (int) ordinal, y, m);
         if ((absdate = absdate_from_ymd(y, m, 1)) == INT_ERR_CODE) return INT_ERR_CODE;
-        return absdate;
+        return absdate - ORD_OFFSET;
     } else {
-        QtoD_ym(fromDate+1, &y, &m, af_info);
+        QtoD_ym(ordinal+1, &y, &m, af_info);
+		// printf("ordinal: %d, year: %d, month: %d\n", (int) ordinal, y, m);
         if ((absdate = absdate_from_ymd(y, m, 1)) == INT_ERR_CODE) return INT_ERR_CODE;
-        return absdate - 1;
+        return absdate - 1 - ORD_OFFSET;
     }
 }
 
-static int64_t asfreq_QtoQ(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoQ(asfreq_QtoD(fromDate, relation, af_info), relation, af_info); }
+static npy_int64 asfreq_QtoQ(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoQ(asfreq_QtoD(ordinal, relation, af_info), relation, af_info); }
 
-static int64_t asfreq_QtoA(int64_t fromDate, char relation, asfreq_info *af_info) {
-    return asfreq_DtoA(asfreq_QtoD(fromDate, relation, af_info), relation, af_info); }
+static npy_int64 asfreq_QtoA(npy_int64 ordinal, char relation, asfreq_info *af_info) {
+    return asfreq_DtoA(asfreq_QtoD(ordinal, relation, af_info), relation, af_info); }
 
-static int64_t asfreq_QtoM(int64_t fromDate, char relation, asfreq_info *af_info) {
-    return asfreq_DtoM(asfreq_QtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_QtoM(npy_int64 ordinal, char relation, asfreq_info *af_info) {
+    return asfreq_DtoM(asfreq_QtoD(ordinal, relation, af_info), relation, &NULL_AF_INFO); }
 
-static int64_t asfreq_QtoW(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoW(asfreq_QtoD(fromDate, relation, af_info), relation, af_info); }
+static npy_int64 asfreq_QtoW(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_QtoD(ordinal, relation, af_info), relation, af_info); }
 
-static int64_t asfreq_QtoB(int64_t fromDate, char relation, asfreq_info *af_info) {
+static npy_int64 asfreq_QtoB(npy_int64 ordinal, char relation, asfreq_info *af_info) {
 
     struct date_info dinfo;
-    if (dInfoCalc_SetFromAbsDate(&dinfo, asfreq_QtoD(fromDate, relation, af_info),
-                    GREGORIAN_CALENDAR)) return INT_ERR_CODE;
+    if (dInfoCalc_SetFromAbsDate(&dinfo,
+								 asfreq_QtoD(ordinal, relation, af_info) + ORD_OFFSET,
+								 GREGORIAN_CALENDAR)) return INT_ERR_CODE;
 
     if (relation == 'S') { return DtoB_WeekendToMonday(dinfo.absdate, dinfo.day_of_week); }
     else                 { return DtoB_WeekendToFriday(dinfo.absdate, dinfo.day_of_week); }
 }
 
 
-static int64_t asfreq_QtoH(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoH(asfreq_QtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
-static int64_t asfreq_QtoT(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoT(asfreq_QtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
-static int64_t asfreq_QtoS(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoS(asfreq_QtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_QtoH(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoH(asfreq_QtoD(ordinal, relation, af_info), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_QtoT(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoT(asfreq_QtoD(ordinal, relation, af_info), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_QtoS(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoS(asfreq_QtoD(ordinal, relation, af_info), relation, &NULL_AF_INFO); }
 
 
 //************ FROM ANNUAL ***************
 
-static int64_t asfreq_AtoD(int64_t fromDate, char relation, asfreq_info *af_info) {
-    int64_t absdate, year, final_adj;
+static npy_int64 asfreq_AtoD(npy_int64 ordinal, char relation, asfreq_info *af_info) {
+    npy_int64 absdate, final_adj;
+	int year;
     int month = (af_info->from_a_year_end) % 12;
 
+	// start from 1970
+	ordinal += BASE_YEAR;
+
     if (month == 0) { month = 1; }
     else { month += 1; }
 
     if (relation == 'S') {
-        if (af_info->from_a_year_end == 12) {year = fromDate;}
-        else {year = fromDate - 1;}
+        if (af_info->from_a_year_end == 12) {year = ordinal;}
+        else {year = ordinal - 1;}
         final_adj = 0;
     } else {
-        if (af_info->from_a_year_end == 12) {year = fromDate+1;}
-        else {year = fromDate;}
+        if (af_info->from_a_year_end == 12) {year = ordinal+1;}
+        else {year = ordinal;}
         final_adj = -1;
     }
     absdate = absdate_from_ymd(year, month, 1);
-    if (absdate  == INT_ERR_CODE) return INT_ERR_CODE;
-    return absdate + final_adj;
+    if (absdate  == INT_ERR_CODE) {
+	  return INT_ERR_CODE;
+	}
+    return absdate + final_adj - ORD_OFFSET;
 }
 
-static int64_t asfreq_AtoA(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoA(asfreq_AtoD(fromDate, relation, af_info), relation, af_info); }
+static npy_int64 asfreq_AtoA(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoA(asfreq_AtoD(ordinal, relation, af_info), relation, af_info); }
 
-static int64_t asfreq_AtoQ(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoQ(asfreq_AtoD(fromDate, relation, af_info), relation, af_info); }
+static npy_int64 asfreq_AtoQ(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoQ(asfreq_AtoD(ordinal, relation, af_info), relation, af_info); }
 
-static int64_t asfreq_AtoM(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoM(asfreq_AtoD(fromDate, relation, af_info), relation, af_info); }
+static npy_int64 asfreq_AtoM(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoM(asfreq_AtoD(ordinal, relation, af_info), relation, af_info); }
 
-static int64_t asfreq_AtoW(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoW(asfreq_AtoD(fromDate, relation, af_info), relation, af_info); }
+static npy_int64 asfreq_AtoW(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoW(asfreq_AtoD(ordinal, relation, af_info), relation, af_info); }
 
-static int64_t asfreq_AtoB(int64_t fromDate, char relation, asfreq_info *af_info) {
+static npy_int64 asfreq_AtoB(npy_int64 ordinal, char relation, asfreq_info *af_info) {
 
     struct date_info dinfo;
-    if (dInfoCalc_SetFromAbsDate(&dinfo, asfreq_AtoD(fromDate, relation, af_info),
+    if (dInfoCalc_SetFromAbsDate(&dinfo,
+								 asfreq_AtoD(ordinal, relation, af_info) + ORD_OFFSET,
                     GREGORIAN_CALENDAR)) return INT_ERR_CODE;
 
     if (relation == 'S') { return DtoB_WeekendToMonday(dinfo.absdate, dinfo.day_of_week); }
     else                 { return DtoB_WeekendToFriday(dinfo.absdate, dinfo.day_of_week); }
 }
 
-static int64_t asfreq_AtoH(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoH(asfreq_AtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
-static int64_t asfreq_AtoT(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoT(asfreq_AtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
-static int64_t asfreq_AtoS(int64_t fromDate, char relation, asfreq_info *af_info)
-    { return asfreq_DtoS(asfreq_AtoD(fromDate, relation, af_info), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_AtoH(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoH(asfreq_AtoD(ordinal, relation, af_info), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_AtoT(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoT(asfreq_AtoD(ordinal, relation, af_info), relation, &NULL_AF_INFO); }
+static npy_int64 asfreq_AtoS(npy_int64 ordinal, char relation, asfreq_info *af_info)
+    { return asfreq_DtoS(asfreq_AtoD(ordinal, relation, af_info), relation, &NULL_AF_INFO); }
 
-static int64_t nofunc(int64_t fromDate, char relation, asfreq_info *af_info) { return INT_ERR_CODE; }
-static int64_t no_op(int64_t fromDate, char relation, asfreq_info *af_info) { return fromDate; }
+static npy_int64 nofunc(npy_int64 ordinal, char relation, asfreq_info *af_info) { return INT_ERR_CODE; }
+static npy_int64 no_op(npy_int64 ordinal, char relation, asfreq_info *af_info) { return ordinal; }
 
 // end of frequency specific conversion routines
 
@@ -875,9 +907,9 @@ freq_conv_func get_asfreq_func(int fromFreq, int toFreq, int forConvert)
     }
 }
 
-double getAbsTime(int freq, int64_t dailyDate, int64_t originalDate) {
+double getAbsTime(int freq, npy_int64 dailyDate, npy_int64 originalDate) {
 
-    int64_t startOfDay, periodsPerDay;
+    npy_int64 startOfDay, periodsPerDay;
 
     switch(freq)
     {
@@ -894,7 +926,8 @@ double getAbsTime(int freq, int64_t dailyDate, int64_t originalDate) {
 		  return 0; // 24*60*60 - 1;
     }
 
-    startOfDay = asfreq_DtoHIGHFREQ(dailyDate, 'S', periodsPerDay);
+    startOfDay = asfreq_DtoHIGHFREQ(dailyDate- ORD_OFFSET, 'S',
+									periodsPerDay);
     return (24*60*60)*((double)(originalDate - startOfDay))/((double)periodsPerDay);
 }
 
@@ -926,7 +959,7 @@ int dInfoCalc_SetFromAbsTime(struct date_info *dinfo,
    indicate the calendar to be used. */
 static
 int dInfoCalc_SetFromAbsDateTime(struct date_info *dinfo,
-                  int64_t absdate,
+                  npy_int64 absdate,
                   double abstime,
                   int calendar)
 {
@@ -957,9 +990,9 @@ int dInfoCalc_SetFromAbsDateTime(struct date_info *dinfo,
  * New pandas API-helper code, to expose to cython
  * ------------------------------------------------------------------*/
 
-int64_t asfreq(int64_t period_ordinal, int freq1, int freq2, char relation)
+npy_int64 asfreq(npy_int64 period_ordinal, int freq1, int freq2, char relation)
 {
-    int64_t val;
+    npy_int64 val;
     freq_conv_func func;
     asfreq_info finfo;
 
@@ -977,27 +1010,28 @@ onError:
     return INT_ERR_CODE;
 }
 
+
 /* generate an ordinal in period space */
-int64_t get_period_ordinal(int year, int month, int day,
+npy_int64 get_period_ordinal(int year, int month, int day,
                       int hour, int minute, int second,
                       int freq)
 {
-	  int64_t absdays, delta;
-    int64_t weeks, days;
-    int64_t adj_ordinal, ordinal, day_adj;
+	  npy_int64 absdays, delta;
+    npy_int64 weeks, days;
+    npy_int64 adj_ordinal, ordinal, day_adj;
     int freq_group, fmonth, mdiff, quarter;
     freq_group = get_freq_group(freq);
 
     if (freq == FR_SEC) {
         absdays = absdate_from_ymd(year, month, day);
-        delta = (absdays - HIGHFREQ_ORIG);
-        return (int64_t)(delta*86400 + hour*3600 + minute*60 + second + 1);
+        delta = (absdays - ORD_OFFSET - HIGHFREQ_ORIG);
+        return (npy_int64)(delta*86400 + hour*3600 + minute*60 + second + 1);
     }
 
     if (freq == FR_MIN) {
         absdays = absdate_from_ymd(year, month, day);
-        delta = (absdays - HIGHFREQ_ORIG);
-        return (int64_t)(delta*1440 + hour*60 + minute + 1);
+        delta = (absdays - ORD_OFFSET - HIGHFREQ_ORIG);
+        return (npy_int64)(delta*1440 + hour*60 + minute + 1);
     }
 
     if (freq == FR_HR) {
@@ -1005,18 +1039,18 @@ int64_t get_period_ordinal(int year, int month, int day,
         {
             goto onError;
         }
-        delta = (absdays - HIGHFREQ_ORIG);
-        return (int64_t)(delta*24 + hour + 1);
+        delta = (absdays - ORD_OFFSET - HIGHFREQ_ORIG);
+        return (npy_int64)(delta*24 + hour + 1);
     }
 
     if (freq == FR_DAY)
     {
-        return (int64_t)absdate_from_ymd(year, month, day);
+	  return (npy_int64) (absdate_from_ymd(year, month, day) - ORD_OFFSET);
     }
 
     if (freq == FR_UND)
     {
-        return (int64_t)absdate_from_ymd(year, month, day);
+	  return (npy_int64) (absdate_from_ymd(year, month, day) - ORD_OFFSET);
     }
 
     if (freq == FR_BUS)
@@ -1025,13 +1059,13 @@ int64_t get_period_ordinal(int year, int month, int day,
         {
             goto onError;
         }
-        weeks = days/7;
-        return (int64_t)(days - weeks*2);
+        weeks = days / 7;
+        return (npy_int64)(days - weeks*2);
     }
 
     if (freq_group == FR_WK)
     {
-        if((ordinal = (int64_t)absdate_from_ymd(year, month, day)) == INT_ERR_CODE)
+        if((ordinal = (npy_int64)absdate_from_ymd(year, month, day)) == INT_ERR_CODE)
         {
             goto onError;
         }
@@ -1042,7 +1076,7 @@ int64_t get_period_ordinal(int year, int month, int day,
 
     if (freq == FR_MTH)
     {
-        return (year-1)*12 + month;
+        return (year - BASE_YEAR) * 12 + month - 1;
     }
 
     if (freq_group == FR_QTR)
@@ -1054,7 +1088,7 @@ int64_t get_period_ordinal(int year, int month, int day,
       if (mdiff < 0) mdiff += 12;
       if (month >= fmonth) mdiff += 12;
 
-      return 1 + (year - 1) * 4 + (mdiff - 1) / 3;
+      return (year - BASE_YEAR) * 4 + (mdiff - 1) / 3;
     }
 
     if (freq_group == FR_ANN)
@@ -1062,10 +1096,10 @@ int64_t get_period_ordinal(int year, int month, int day,
       fmonth = freq - FR_ANN;
       if (fmonth == 0) fmonth = 12;
       if (month <= fmonth) {
-        return year;
+        return year - BASE_YEAR;
       }
       else {
-        return year + 1;
+        return year - BASE_YEAR + 1;
       }
     }
 
@@ -1082,17 +1116,17 @@ onError:
     is calculated for the last day of the period.
 */
 
-int64_t get_python_ordinal(int64_t period_ordinal, int freq)
+npy_int64 get_python_ordinal(npy_int64 period_ordinal, int freq)
 {
     asfreq_info af_info;
-    int64_t (*toDaily)(int64_t, char, asfreq_info*);
+    npy_int64 (*toDaily)(npy_int64, char, asfreq_info*);
 
     if (freq == FR_DAY)
-        return period_ordinal;
+        return period_ordinal + ORD_OFFSET;
 
     toDaily = get_asfreq_func(freq, FR_DAY, 0);
     get_asfreq_info(freq, FR_DAY, &af_info);
-    return toDaily(period_ordinal, 'E', &af_info);
+    return toDaily(period_ordinal, 'E', &af_info) + ORD_OFFSET;
 }
 
 char *str_replace(const char *s, const char *old, const char *new) {
@@ -1129,7 +1163,7 @@ char *str_replace(const char *s, const char *old, const char *new) {
 // function to generate a nice string representation of the period
 // object, originally from DateObject_strftime
 
-char *skts_strftime(int64_t value, int freq, PyObject *args)
+char *skts_strftime(npy_int64 ordinal, int freq, PyObject *args)
 {
     char *orig_fmt_str, *fmt_str;
     char *result;
@@ -1144,12 +1178,12 @@ char *skts_strftime(int64_t value, int freq, PyObject *args)
     int extra_fmts_found_one = 0;
     struct tm c_date;
     struct date_info tempDate;
-    int64_t absdate;
+    npy_int64 absdate, daily_ord;
     double abstime;
     int i, result_len;
     PyObject *py_result;
 
-    int64_t (*toDaily)(int64_t, char, asfreq_info*) = NULL;
+    npy_int64 (*toDaily)(npy_int64, char, asfreq_info*) = NULL;
     asfreq_info af_info;
 
     if (!PyArg_ParseTuple(args, "s:strftime(fmt)", &orig_fmt_str))
@@ -1158,10 +1192,12 @@ char *skts_strftime(int64_t value, int freq, PyObject *args)
     toDaily = get_asfreq_func(freq, FR_DAY, 0);
     get_asfreq_info(freq, FR_DAY, &af_info);
 
-    absdate = toDaily(value, 'E', &af_info);
-    abstime = getAbsTime(freq, absdate, value);
+    daily_ord = toDaily(ordinal, 'E', &af_info);
+    abstime = getAbsTime(freq, daily_ord + ORD_OFFSET, ordinal);
+
+	// printf("daily_ord: %d\n", (int) daily_ord);
 
-    if(dInfoCalc_SetFromAbsDateTime(&tempDate, absdate, abstime,
+    if(dInfoCalc_SetFromAbsDateTime(&tempDate, daily_ord + ORD_OFFSET, abstime,
                                     GREGORIAN_CALENDAR)) return NULL;
 
     // populate standard C date struct with info from our date_info struct
@@ -1221,7 +1257,7 @@ char *skts_strftime(int64_t value, int freq, PyObject *args)
                 } else { qtr_freq = FR_QTR; }
                 get_asfreq_info(FR_DAY, qtr_freq, &af_info);
 
-                if(DtoQ_yq(absdate, &af_info, &year, &quarter) == INT_ERR_CODE)
+                if(DtoQ_yq(daily_ord, &af_info, &year, &quarter) == INT_ERR_CODE)
                 { return NULL; }
 
                 if(strcmp(extra_fmts[i][0], "%q") == 0) {
@@ -1263,7 +1299,7 @@ char *skts_strftime(int64_t value, int freq, PyObject *args)
     return result;
 }
 
-char *period_to_string(int64_t value, int freq)
+char *period_to_string(npy_int64 value, int freq)
 {
     int freq_group = get_freq_group(freq);
     PyObject *string_arg;
@@ -1275,7 +1311,7 @@ char *period_to_string(int64_t value, int freq)
         if ((retval = PyArray_malloc(digits * sizeof(char))) == NULL) {
             return (char *)PyErr_NoMemory();
         }
-        sprintf(retval, "%ld", value);
+        sprintf(retval, "%ld", (long int) value);
         return retval;
     }
     else if (freq_group == FR_ANN) { string_arg = Py_BuildValue("(s)", "%Y"); }
@@ -1296,7 +1332,7 @@ char *period_to_string(int64_t value, int freq)
     return retval;
 }
 
-char *period_to_string2(int64_t value, int freq, char *fmt)
+char *period_to_string2(npy_int64 value, int freq, char *fmt)
 {
     PyObject *string_arg;
     char *retval;
@@ -1307,7 +1343,7 @@ char *period_to_string2(int64_t value, int freq, char *fmt)
     return retval;
 }
 
-static int _quarter_year(int64_t ordinal, int freq, int *year, int *quarter) {
+static int _quarter_year(npy_int64 ordinal, int freq, int *year, int *quarter) {
     asfreq_info af_info;
     int qtr_freq;
 
@@ -1355,94 +1391,95 @@ static int _ISOWeek(struct date_info *dinfo)
     return week;
 }
 
-int get_date_info(int64_t ordinal, int freq, struct date_info *dinfo)
+int get_date_info(npy_int64 ordinal, int freq, struct date_info *dinfo)
 {
-    int64_t absdate = get_python_ordinal(ordinal, freq);
+    npy_int64 absdate = get_python_ordinal(ordinal, freq);
     double abstime = getAbsTime(freq, absdate, ordinal);
 
-    if(dInfoCalc_SetFromAbsDateTime(dinfo, absdate, abstime, GREGORIAN_CALENDAR))
+    if(dInfoCalc_SetFromAbsDateTime(dinfo, absdate,
+									abstime, GREGORIAN_CALENDAR))
         return INT_ERR_CODE;
 
     return 0;
 }
 
-int pyear(int64_t ordinal, int freq) {
+int pyear(npy_int64 ordinal, int freq) {
     struct date_info dinfo;
     get_date_info(ordinal, freq, &dinfo);
     return dinfo.year;
 }
 
-int pqyear(int64_t ordinal, int freq) {
+int pqyear(npy_int64 ordinal, int freq) {
     int year, quarter;
     if( _quarter_year(ordinal, freq, &year, &quarter) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return year;
 }
 
-int pquarter(int64_t ordinal, int freq) {
+int pquarter(npy_int64 ordinal, int freq) {
     int year, quarter;
     if(_quarter_year(ordinal, freq, &year, &quarter) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return quarter;
 }
 
-int pmonth(int64_t ordinal, int freq) {
+int pmonth(npy_int64 ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return dinfo.month;
 }
 
-int pday(int64_t ordinal, int freq) {
+int pday(npy_int64 ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return dinfo.day;
 }
 
-int pweekday(int64_t ordinal, int freq) {
+int pweekday(npy_int64 ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return dinfo.day_of_week;
 }
 
-int pday_of_week(int64_t ordinal, int freq) {
+int pday_of_week(npy_int64 ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return dinfo.day_of_week;
 }
 
-int pday_of_year(int64_t ordinal, int freq) {
+int pday_of_year(npy_int64 ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return dinfo.day_of_year;
 }
 
-int pweek(int64_t ordinal, int freq) {
+int pweek(npy_int64 ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return _ISOWeek(&dinfo);
 }
 
-int phour(int64_t ordinal, int freq) {
+int phour(npy_int64 ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return dinfo.hour;
 }
 
-int pminute(int64_t ordinal, int freq) {
+int pminute(npy_int64 ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
     return dinfo.minute;
 }
 
-int psecond(int64_t ordinal, int freq) {
+int psecond(npy_int64 ordinal, int freq) {
     struct date_info dinfo;
     if(get_date_info(ordinal, freq, &dinfo) == INT_ERR_CODE)
         return INT_ERR_CODE;
diff --git a/pandas/src/period.h b/pandas/src/period.h
index f1e4f476e..e3bc190dd 100644
--- a/pandas/src/period.h
+++ b/pandas/src/period.h
@@ -10,6 +10,7 @@
 #include <Python.h>
 #include "numpy/ndarraytypes.h"
 #include "stdint.h"
+#include "limits.h"
 
 /*
  * declarations from period here
@@ -28,13 +29,13 @@
 // HIGHFREQ_ORIG is the datetime ordinal from which to begin the second
 // frequency ordinal sequence
 
-// begins second ordinal at 1/1/1AD gregorian proleptic calendar
-#define HIGHFREQ_ORIG 1
-
 // typedef int64_t npy_int64;
-
 // begins second ordinal at 1/1/1970 unix epoch
-// #define HIGHFREQ_ORIG 719163
+
+// #define HIGHFREQ_ORIG 62135683200LL
+#define BASE_YEAR 1970
+#define ORD_OFFSET 719163LL // days until 1970-01-01
+#define HIGHFREQ_ORIG 0 // ORD_OFFSET * 86400LL // days until 1970-01-01
 
 #define FR_ANN  1000  /* Annual */
 #define FR_ANNDEC  FR_ANN  /* Annual - December year end*/
@@ -103,7 +104,7 @@ typedef struct asfreq_info {
 
 
 typedef struct date_info {
-    int64_t absdate;
+    npy_int64 absdate;
     double abstime;
 
     double second;
@@ -118,40 +119,40 @@ typedef struct date_info {
     int calendar;
 } date_info;
 
-typedef int64_t (*freq_conv_func)(int64_t, char, asfreq_info*);
+typedef npy_int64 (*freq_conv_func)(npy_int64, char, asfreq_info*);
 
 /*
  * new pandas API helper functions here
  */
 
-int64_t asfreq(int64_t period_ordinal, int freq1, int freq2, char relation);
+npy_int64 asfreq(npy_int64 period_ordinal, int freq1, int freq2, char relation);
 
-int64_t get_period_ordinal(int year, int month, int day,
+npy_int64 get_period_ordinal(int year, int month, int day,
                       int hour, int minute, int second,
                       int freq);
 
-int64_t get_python_ordinal(int64_t period_ordinal, int freq);
+npy_int64 get_python_ordinal(npy_int64 period_ordinal, int freq);
 
-char *skts_strftime(int64_t value, int freq, PyObject *args);
-char *period_to_string(int64_t value, int freq);
-char *period_to_string2(int64_t value, int freq, char *fmt);
+char *skts_strftime(npy_int64 value, int freq, PyObject *args);
+char *period_to_string(npy_int64 value, int freq);
+char *period_to_string2(npy_int64 value, int freq, char *fmt);
 
-int get_date_info(int64_t ordinal, int freq, struct date_info *dinfo);
+int get_date_info(npy_int64 ordinal, int freq, struct date_info *dinfo);
 freq_conv_func get_asfreq_func(int fromFreq, int toFreq, int forConvert);
 void get_asfreq_info(int fromFreq, int toFreq, asfreq_info *af_info);
 
-int pyear(int64_t ordinal, int freq);
-int pqyear(int64_t ordinal, int freq);
-int pquarter(int64_t ordinal, int freq);
-int pmonth(int64_t ordinal, int freq);
-int pday(int64_t ordinal, int freq);
-int pweekday(int64_t ordinal, int freq);
-int pday_of_week(int64_t ordinal, int freq);
-int pday_of_year(int64_t ordinal, int freq);
-int pweek(int64_t ordinal, int freq);
-int phour(int64_t ordinal, int freq);
-int pminute(int64_t ordinal, int freq);
-int psecond(int64_t ordinal, int freq);
-double getAbsTime(int freq, int64_t dailyDate, int64_t originalDate);
+int pyear(npy_int64 ordinal, int freq);
+int pqyear(npy_int64 ordinal, int freq);
+int pquarter(npy_int64 ordinal, int freq);
+int pmonth(npy_int64 ordinal, int freq);
+int pday(npy_int64 ordinal, int freq);
+int pweekday(npy_int64 ordinal, int freq);
+int pday_of_week(npy_int64 ordinal, int freq);
+int pday_of_year(npy_int64 ordinal, int freq);
+int pweek(npy_int64 ordinal, int freq);
+int phour(npy_int64 ordinal, int freq);
+int pminute(npy_int64 ordinal, int freq);
+int psecond(npy_int64 ordinal, int freq);
+double getAbsTime(int freq, npy_int64 dailyDate, npy_int64 originalDate);
 
 #endif
diff --git a/pandas/src/tseries.pyx b/pandas/src/tseries.pyx
index 8f8ce424d..65bc784fd 100644
--- a/pandas/src/tseries.pyx
+++ b/pandas/src/tseries.pyx
@@ -671,7 +671,6 @@ include "skiplist.pyx"
 include "groupby.pyx"
 include "moments.pyx"
 include "reindex.pyx"
-include "generated.pyx"
 include "reduce.pyx"
 include "stats.pyx"
 include "properties.pyx"
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 96dc5f1c2..8a77cde76 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -14,6 +14,7 @@ import pandas.tseries.tools as tools
 
 from pandas._tseries import Timestamp
 import pandas._tseries as lib
+import pandas._algos as _algos
 
 def _utc():
     import pytz
@@ -144,13 +145,13 @@ class DatetimeIndex(Int64Index):
     """
     _join_precedence = 10
 
-    _inner_indexer = _join_i8_wrapper(lib.inner_join_indexer_int64)
-    _outer_indexer = _join_i8_wrapper(lib.outer_join_indexer_int64)
-    _left_indexer  = _join_i8_wrapper(lib.left_join_indexer_int64,
+    _inner_indexer = _join_i8_wrapper(_algos.inner_join_indexer_int64)
+    _outer_indexer = _join_i8_wrapper(_algos.outer_join_indexer_int64)
+    _left_indexer  = _join_i8_wrapper(_algos.left_join_indexer_int64,
                                       with_indexers=False)
     _groupby = lib.groupby_arrays # _wrap_i8_function(lib.groupby_int64)
 
-    _arrmap = _wrap_dt_function(lib.arrmap_object)
+    _arrmap = _wrap_dt_function(_algos.arrmap_object)
 
     __eq__ = _dt_index_cmp('__eq__')
     __ne__ = _dt_index_cmp('__ne__')
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index f443ab6d9..f6f9f3c6c 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -25,8 +25,7 @@ def _period_field_accessor(name, alias=None):
         alias = name
     def f(self):
         base, mult = _gfc(self.freq)
-        g = getattr(lib, 'get_period_%s' % alias)
-        return g(self.ordinal, base, mult)
+        return lib.get_period_field(alias, self.ordinal, base, mult)
     f.__name__ = name
     return property(f)
 
@@ -35,8 +34,7 @@ def _field_accessor(name, alias=None):
         alias = name
     def f(self):
         base, mult = _gfc(self.freq)
-        g = getattr(lib, 'get_period_%s_arr' % alias)
-        return g(self.values, base, mult)
+        return lib.get_period_field_arr(alias, self.values, base, mult)
     f.__name__ = name
     return property(f)
 
@@ -99,8 +97,6 @@ class Period(object):
         elif ordinal is not None:
             if not com.is_integer(ordinal):
                 raise ValueError("Ordinal must be an integer")
-            if ordinal <= 0:
-                raise ValueError("Ordinal must be positive")
             if freq is None:
                 raise ValueError('Must supply freq for ordinal value')
             self.ordinal = ordinal
@@ -259,19 +255,19 @@ class Period(object):
         ts_freq = _period_rule_to_timestamp_rule(new_val.freq, how=how)
         return Timestamp(dt64, offset=to_offset(ts_freq))
 
-    year = _period_field_accessor('year')
-    month = _period_field_accessor('month')
-    day = _period_field_accessor('day')
-    hour = _period_field_accessor('hour')
-    minute = _period_field_accessor('minute')
-    second = _period_field_accessor('second')
-    weekofyear = _period_field_accessor('week')
+    year = _period_field_accessor('year', 0)
+    month = _period_field_accessor('month', 3)
+    day = _period_field_accessor('day', 4)
+    hour = _period_field_accessor('hour', 5)
+    minute = _period_field_accessor('minute', 6)
+    second = _period_field_accessor('second', 7)
+    weekofyear = _period_field_accessor('week', 8)
     week = weekofyear
-    dayofweek = _period_field_accessor('dayofweek', 'dow')
+    dayofweek = _period_field_accessor('dayofweek', 10)
     weekday = dayofweek
-    dayofyear = day_of_year = _period_field_accessor('dayofyear', 'doy')
-    quarter = _period_field_accessor('quarter')
-    qyear = _period_field_accessor('qyear')
+    dayofyear = day_of_year = _period_field_accessor('dayofyear', 9)
+    quarter = _period_field_accessor('quarter', 2)
+    qyear = _period_field_accessor('qyear', 1)
 
     @classmethod
     def now(cls, freq=None):
@@ -650,19 +646,19 @@ class PeriodIndex(Int64Index):
         result.freq = freq
         return result
 
-    year = _field_accessor('year')
-    month = _field_accessor('month')
-    day = _field_accessor('day')
-    hour = _field_accessor('hour')
-    minute = _field_accessor('minute')
-    second = _field_accessor('second')
-    weekofyear = _field_accessor('week')
+    year = _field_accessor('year', 0)
+    month = _field_accessor('month', 3)
+    day = _field_accessor('day', 4)
+    hour = _field_accessor('hour', 5)
+    minute = _field_accessor('minute', 6)
+    second = _field_accessor('second', 7)
+    weekofyear = _field_accessor('week', 8)
     week = weekofyear
-    dayofweek = _field_accessor('dayofweek', 'dow')
+    dayofweek = _field_accessor('dayofweek', 10)
     weekday = dayofweek
-    dayofyear = day_of_year = _field_accessor('dayofyear', 'doy')
-    quarter = _field_accessor('quarter')
-    qyear = _field_accessor('qyear')
+    dayofyear = day_of_year = _field_accessor('dayofyear', 9)
+    quarter = _field_accessor('quarter', 2)
+    qyear = _field_accessor('qyear', 1)
 
     # Try to run function on index first, and then on elements of index
     # Especially important for group-by functionality
diff --git a/pandas/tseries/tests/test_period.py b/pandas/tseries/tests/test_period.py
index 771d6387c..695faa52d 100644
--- a/pandas/tseries/tests/test_period.py
+++ b/pandas/tseries/tests/test_period.py
@@ -8,6 +8,7 @@ Parts derived from scikits.timeseries code, original authors:
 
 from unittest import TestCase
 from datetime import datetime, timedelta
+import unittest
 
 from numpy.ma.testutils import assert_equal
 
@@ -1478,8 +1479,34 @@ class TestMethods(TestCase):
         self.assertRaises(ValueError, dt1.__add__, dt2)
 
 
-###############################################################################
-#------------------------------------------------------------------------------
+class TestPeriodRepresentation(unittest.TestCase):
+    """
+    Wish to match NumPy units
+    """
+
+    def test_annual(self):
+        self._check_freq('A', 1970)
+
+    def test_monthly(self):
+        self._check_freq('M', '1970-01')
+
+    def test_daily(self):
+        self._check_freq('D', '1970-01-01')
+
+    def test_hourly(self):
+        self._check_freq('D', '1970-01-01')
+
+    def test_minutely(self):
+        self._check_freq('H', '1970-01-01 00:00:00')
+
+    def test_secondly(self):
+        self._check_freq('T', '1970-01-01 00:00:00')
+
+    def _check_freq(self, freq, base_date):
+        rng = PeriodIndex(start=base_date, periods=10, freq=freq)
+        exp = np.arange(10, dtype=np.int64)
+        self.assert_(np.array_equal(rng.values, exp))
+
 
 if __name__ == '__main__':
     import nose
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 4eff342e5..262838666 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -1327,6 +1327,7 @@ class TestNewOffsets(unittest.TestCase):
                           datetime(2011,11,12), freq=offset)
 
 
+
 if __name__ == '__main__':
     nose.runmodule(argv=[__file__,'-vvs','-x','--pdb', '--pdb-failure'],
                    exit=False)
diff --git a/setup.py b/setup.py
index 75747e1d9..925b6984b 100755
--- a/setup.py
+++ b/setup.py
@@ -335,7 +335,7 @@ else:
     cmdclass['sdist'] =  CheckSDist
 
 tseries_depends = ['reindex', 'groupby', 'skiplist', 'moments',
-                   'generated', 'reduce', 'stats', 'datetime',
+                   'reduce', 'stats', 'datetime',
                    'hashtable', 'inference', 'properties', 'join', 'engines']
 
 def srcpath(name=None, suffix='.pyx', subdir='src'):
@@ -348,6 +348,11 @@ if suffix == '.pyx':
 else:
     tseries_depends = []
 
+algos_ext = Extension('pandas._algos',
+                      sources=[srcpath('generated', suffix=suffix)],
+                      include_dirs=[np.get_include()],
+                      )
+
 tseries_ext = Extension('pandas._tseries',
                         depends=tseries_depends + ['pandas/src/numpy_helper.h'],
                         sources=[srcpath('tseries', suffix=suffix),
@@ -374,7 +379,7 @@ cppsandbox_ext = Extension('pandas._cppsandbox',
                            sources=[srcpath('cppsandbox', suffix=suffix)],
                            include_dirs=[np.get_include()])
 
-extensions = [tseries_ext, sparse_ext]
+extensions = [algos_ext, tseries_ext, sparse_ext]
 
 if not ISRELEASED:
     extensions.extend([sandbox_ext])

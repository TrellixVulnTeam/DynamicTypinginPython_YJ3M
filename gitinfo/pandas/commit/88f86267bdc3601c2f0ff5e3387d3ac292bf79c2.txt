commit 88f86267bdc3601c2f0ff5e3387d3ac292bf79c2
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon May 28 12:11:09 2012 -0400

    ENH: return -1 in NaT field access, vector and scalar. close #1310

diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 0f25e44a1..3577680d1 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -177,6 +177,20 @@ class NaTType(_NaT):
     def __repr__(self):
         return 'NaT'
 
+    def weekday(self):
+        return -1
+
+    def toordinal(self):
+        return -1
+
+fields = ['year', 'quarter', 'month', 'day', 'hour',
+          'minute', 'second', 'microsecond', 'nanosecond',
+          'week', 'dayofyear']
+for field in fields:
+    prop = property(fget=lambda self: -1)
+    setattr(NaTType, field, prop)
+
+
 NaT = NaTType()
 
 iNaT = util.get_nat()
@@ -331,6 +345,7 @@ cdef class _NaT(_Timestamp):
 
 
 
+
 def _delta_to_nanoseconds(delta):
     try:
         delta = delta.delta
@@ -1193,52 +1208,70 @@ def fast_field_accessor(ndarray[int64_t] dtindex, object field):
 
     if field == 'Y':
         for i in range(count):
+            if dtindex[i] == NPY_NAT: out[i] = -1; continue
+
             pandas_datetime_to_datetimestruct(dtindex[i], PANDAS_FR_ns, &dts)
             out[i] = dts.year
         return out
 
     elif field == 'M':
         for i in range(count):
+            if dtindex[i] == NPY_NAT: out[i] = -1; continue
+
             pandas_datetime_to_datetimestruct(dtindex[i], PANDAS_FR_ns, &dts)
             out[i] = dts.month
         return out
 
     elif field == 'D':
         for i in range(count):
+            if dtindex[i] == NPY_NAT: out[i] = -1; continue
+
             pandas_datetime_to_datetimestruct(dtindex[i], PANDAS_FR_ns, &dts)
             out[i] = dts.day
         return out
 
     elif field == 'h':
         for i in range(count):
+            if dtindex[i] == NPY_NAT: out[i] = -1; continue
+
             pandas_datetime_to_datetimestruct(dtindex[i], PANDAS_FR_ns, &dts)
             out[i] = dts.hour
         return out
 
     elif field == 'm':
         for i in range(count):
+            if dtindex[i] == NPY_NAT: out[i] = -1; continue
+
             pandas_datetime_to_datetimestruct(dtindex[i], PANDAS_FR_ns, &dts)
             out[i] = dts.min
         return out
 
     elif field == 's':
         for i in range(count):
+            if dtindex[i] == NPY_NAT: out[i] = -1; continue
+
             pandas_datetime_to_datetimestruct(dtindex[i], PANDAS_FR_ns, &dts)
             out[i] = dts.sec
         return out
 
     elif field == 'us':
         for i in range(count):
+            if dtindex[i] == NPY_NAT: out[i] = -1; continue
+
             pandas_datetime_to_datetimestruct(dtindex[i], PANDAS_FR_ns, &dts)
             out[i] = dts.us
         return out
     elif field == 'ns':
         for i in range(count):
+            if dtindex[i] == NPY_NAT: out[i] = -1; continue
+
             pandas_datetime_to_datetimestruct(dtindex[i], PANDAS_FR_ns, &dts)
             out[i] = dts.ps / 1000
         return out
     elif field == 'doy':
         for i in range(count):
+            if dtindex[i] == NPY_NAT: out[i] = -1; continue
+
             pandas_datetime_to_datetimestruct(dtindex[i], PANDAS_FR_ns, &dts)
             isleap = is_leapyear(dts.year)
             out[i] = _month_offset[isleap, dts.month-1] + dts.day
@@ -1246,12 +1279,16 @@ def fast_field_accessor(ndarray[int64_t] dtindex, object field):
 
     elif field == 'dow':
         for i in range(count):
+            if dtindex[i] == NPY_NAT: out[i] = -1; continue
+
             ts = convert_to_tsobject(dtindex[i])
             out[i] = ts_dayofweek(ts)
         return out
 
     elif field == 'woy':
         for i in range(count):
+            if dtindex[i] == NPY_NAT: out[i] = -1; continue
+
             pandas_datetime_to_datetimestruct(dtindex[i], PANDAS_FR_ns, &dts)
             isleap = is_leapyear(dts.year)
             out[i] = _month_offset[isleap, dts.month - 1] + dts.day
@@ -1260,6 +1297,8 @@ def fast_field_accessor(ndarray[int64_t] dtindex, object field):
 
     elif field == 'q':
         for i in range(count):
+            if dtindex[i] == NPY_NAT: out[i] = -1; continue
+
             pandas_datetime_to_datetimestruct(dtindex[i], PANDAS_FR_ns, &dts)
             out[i] = dts.month
             out[i] = ((out[i] - 1) / 3) + 1
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 9d1cf965d..63706f0a9 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -24,6 +24,7 @@ import pandas.tseries.frequencies as fmod
 from pandas.util.testing import assert_series_equal, assert_almost_equal
 import pandas.util.testing as tm
 
+from pandas.lib import NaT, iNaT
 import pandas.lib as lib
 import cPickle as pickle
 import pandas.core.datetools as dt
@@ -33,8 +34,6 @@ import pandas.util.py3compat as py3compat
 from pandas.core.datetools import BDay
 import pandas.core.common as com
 
-iNaT = lib.iNaT
-
 
 class TestTimeSeriesDuplicates(unittest.TestCase):
 
@@ -453,6 +452,28 @@ class TestTimeSeries(unittest.TestCase):
         assert_series_equal(dresult, expected)
         self.assertEquals(dresult.name, 'foo')
 
+    def test_nat_vector_field_access(self):
+        idx = DatetimeIndex(['1/1/2000', None, None, '1/4/2000'])
+
+        fields = ['year', 'quarter', 'month', 'day', 'hour',
+                  'minute', 'second', 'microsecond', 'nanosecond',
+                  'week', 'dayofyear']
+        for field in fields:
+            result = getattr(idx, field)
+            expected = [getattr(x, field) if x is not NaT else -1
+                        for x in idx]
+            self.assert_(np.array_equal(result, expected))
+
+    def test_nat_scalar_field_access(self):
+        fields = ['year', 'quarter', 'month', 'day', 'hour',
+                  'minute', 'second', 'microsecond', 'nanosecond',
+                  'week', 'dayofyear']
+        for field in fields:
+            result = getattr(NaT, field)
+            self.assertEquals(result, -1)
+
+        self.assertEquals(NaT.weekday(), -1)
+
     def test_to_datetime_empty_string(self):
         result = to_datetime('')
         self.assert_(result == '')

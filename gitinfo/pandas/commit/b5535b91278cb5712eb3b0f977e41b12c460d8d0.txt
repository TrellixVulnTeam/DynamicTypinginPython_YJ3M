commit b5535b91278cb5712eb3b0f977e41b12c460d8d0
Author: Roman Pekar <ormeugensson@gmail.com>
Date:   Mon Oct 28 23:26:04 2013 +0400

    API: added 'p' code into _parse_code_table (GH5361)

diff --git a/doc/source/release.rst b/doc/source/release.rst
index 50b39b4f1..98c2a90e4 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -66,7 +66,7 @@ API Changes
     timedeltas (:issue:`5458`,:issue:`5689`)
   - Add ``-NaN`` and ``-nan`` to the default set of NA values
     (:issue:`5952`).  See :ref:`NA Values <io.na_values>`.
-  - ``NDFrame`` now has an ``equals`` method. (:issue:`5283`) 
+  - ``NDFrame`` now has an ``equals`` method. (:issue:`5283`)
 
 Experimental Features
 ~~~~~~~~~~~~~~~~~~~~~
@@ -95,6 +95,8 @@ Improvements to existing features
   - pd.to_csv and pd.to_datetime learned a new ``infer_datetime_format`` keyword which greatly
     improves parsing perf in many cases. Thanks to @lexual for suggesting and @danbirken
     for rapidly implementing. (:issue:`5490`,:issue:`6021`)
+  - add ability to recognize '%p' format code (am/pm) to date parsers when the specific format
+    is supplied (:issue:`5361`)
 
 .. _release.bug_fixes-0.13.1:
 
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 8cce0162e..4bdba55f2 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -810,103 +810,10 @@ class TestTimeSeries(tm.TestCase):
         xp = datetime(2001, 1, 1)
         self.assert_(rs, xp)
 
-
-    def test_to_datetime_mixed(self):
-
-        # 5863
-        # passing a string format with embedded np.nan
-
-        ts = Series([np.nan, '2013-04-08 00:00:00.000', '9999-12-31 00:00:00.000'])
-        expected = Series([NaT,Timestamp('20130408'),NaT])
-
-        result = to_datetime(ts, format='%Y-%m-%d %H:%M:%S.%f')
-        assert_series_equal(result, ts)
-
-        # raises if specified
-        self.assertRaises(pd.tslib.OutOfBoundsDatetime, to_datetime, ts, format='%Y-%m-%d %H:%M:%S.%f', errors='raise')
-
-        result = to_datetime(ts, format='%Y-%m-%d %H:%M:%S.%f',coerce=True)
-        expected = Series([NaT,Timestamp('20130408'),NaT])
-        assert_series_equal(result,expected)
-
-        # passing integers
-        ts = Series([np.nan, 20130408, '20130409'])
-        result = to_datetime(ts, format='%Y%m%d')
-        expected = Series([NaT,Timestamp('20130408'),Timestamp('20130409')])
-        assert_series_equal(result,expected)
-
-        # mixed datetime/np.datetime64('NaT')
-        result = Series(to_datetime([dt.datetime(2000,1,1),np.datetime64('NaT')]))
-        expected = Series([dt.datetime(2000,1,1),NaT])
-        assert_series_equal(result, expected)
-
-    def test_dayfirst(self):
-
-        # GH 3341
-        result = to_datetime('13-01-2012', dayfirst=True)
-        expected = Timestamp('20120113')
-        self.assert_(result == expected)
-
         #### dayfirst is essentially broken
         #### to_datetime('01-13-2012', dayfirst=True)
         #### self.assertRaises(ValueError, to_datetime('01-13-2012', dayfirst=True))
 
-    def test_to_datetime_format(self):
-        values = ['1/1/2000', '1/2/2000', '1/3/2000']
-
-        results1 = [ Timestamp('20000101'), Timestamp('20000201'),
-                     Timestamp('20000301') ]
-        results2 = [ Timestamp('20000101'), Timestamp('20000102'),
-                     Timestamp('20000103') ]
-        for vals, expecteds in [ (values, (Index(results1), Index(results2))),
-                                 (Series(values),(Series(results1), Series(results2))),
-                                 (values[0], (results1[0], results2[0])),
-                                 (values[1], (results1[1], results2[1])),
-                                 (values[2], (results1[2], results2[2])) ]:
-
-            for i, fmt in enumerate(['%d/%m/%Y', '%m/%d/%Y']):
-                result = to_datetime(vals, format=fmt)
-                expected = expecteds[i]
-
-                if isinstance(expected, Series):
-                    assert_series_equal(result, Series(expected))
-                elif isinstance(expected, Timestamp):
-                    self.assert_(result == expected)
-                else:
-                    self.assert_(result.equals(expected))
-
-    def test_to_datetime_format_YYYYMMDD(self):
-        s = Series([19801222,19801222] + [19810105]*5)
-        expected = Series([ Timestamp(x) for x in s.apply(str) ])
-
-        result = to_datetime(s,format='%Y%m%d')
-        assert_series_equal(result, expected)
-
-        result = to_datetime(s.apply(str),format='%Y%m%d')
-        assert_series_equal(result, expected)
-
-        # with NaT
-        expected = Series([Timestamp("19801222"),Timestamp("19801222")] + [Timestamp("19810105")]*5)
-        expected[2] = np.nan
-        s[2] = np.nan
-
-        result = to_datetime(s,format='%Y%m%d')
-        assert_series_equal(result, expected)
-
-        # string with NaT
-        s = s.apply(str)
-        s[2] = 'nat'
-        result = to_datetime(s,format='%Y%m%d')
-        assert_series_equal(result, expected)
-
-
-    def test_to_datetime_format_microsecond(self):
-        val = '01-Apr-2011 00:00:01.978'
-        format = '%d-%b-%Y %H:%M:%S.%f'
-        result = to_datetime(val, format=format)
-        exp = dt.datetime.strptime(val, format)
-        self.assert_(result == exp)
-
     def test_to_datetime_on_datetime64_series(self):
         # #2699
         s = Series(date_range('1/1/2000', periods=10))
@@ -3125,6 +3032,82 @@ class TestSlicing(tm.TestCase):
         self.assertEqual(dr[0], Timestamp('2013-01-31'))
         self.assertEqual(dr[1], Timestamp('2014-01-30'))
 
+class TimeConversionFormats(tm.TestCase):
+    def test_to_datetime_format(self):
+        values = ['1/1/2000', '1/2/2000', '1/3/2000']
+
+        results1 = [ Timestamp('20000101'), Timestamp('20000201'),
+                     Timestamp('20000301') ]
+        results2 = [ Timestamp('20000101'), Timestamp('20000102'),
+                     Timestamp('20000103') ]
+        for vals, expecteds in [ (values, (Index(results1), Index(results2))),
+                                 (Series(values),(Series(results1), Series(results2))),
+                                 (values[0], (results1[0], results2[0])),
+                                 (values[1], (results1[1], results2[1])),
+                                 (values[2], (results1[2], results2[2])) ]:
+
+            for i, fmt in enumerate(['%d/%m/%Y', '%m/%d/%Y']):
+                result = to_datetime(vals, format=fmt)
+                expected = expecteds[i]
+
+                if isinstance(expected, Series):
+                    assert_series_equal(result, Series(expected))
+                elif isinstance(expected, Timestamp):
+                    self.assert_(result == expected)
+                else:
+                    self.assert_(result.equals(expected))
+
+    def test_to_datetime_format_YYYYMMDD(self):
+        s = Series([19801222,19801222] + [19810105]*5)
+        expected = Series([ Timestamp(x) for x in s.apply(str) ])
+
+        result = to_datetime(s,format='%Y%m%d')
+        assert_series_equal(result, expected)
+
+        result = to_datetime(s.apply(str),format='%Y%m%d')
+        assert_series_equal(result, expected)
+
+        # with NaT
+        expected = Series([Timestamp("19801222"),Timestamp("19801222")] + [Timestamp("19810105")]*5)
+        expected[2] = np.nan
+        s[2] = np.nan
+
+        result = to_datetime(s,format='%Y%m%d')
+        assert_series_equal(result, expected)
+
+        # string with NaT
+        s = s.apply(str)
+        s[2] = 'nat'
+        result = to_datetime(s,format='%Y%m%d')
+        assert_series_equal(result, expected)
+
+
+    def test_to_datetime_format_microsecond(self):
+        val = '01-Apr-2011 00:00:01.978'
+        format = '%d-%b-%Y %H:%M:%S.%f'
+        result = to_datetime(val, format=format)
+        exp = dt.datetime.strptime(val, format)
+        self.assert_(result == exp)
+
+    def test_to_datetime_format_time(self):
+        data = [
+                ['01/10/2010 15:20', '%m/%d/%Y %H:%M', Timestamp('2010-01-10 15:20')],
+	            ['01/10/2010 05:43', '%m/%d/%Y %I:%M', Timestamp('2010-01-10 05:43')],
+	            ['01/10/2010 13:56:01', '%m/%d/%Y %H:%M:%S', Timestamp('2010-01-10 13:56:01')]#,
+	            #['01/10/2010 08:14 PM', '%m/%d/%Y %I:%M %p', Timestamp('2010-01-10 20:14')],
+	            #['01/10/2010 07:40 AM', '%m/%d/%Y %I:%M %p', Timestamp('2010-01-10 07:40')],
+	            #['01/10/2010 09:12:56 AM', '%m/%d/%Y %I:%M:%S %p', Timestamp('2010-01-10 09:12:56')]
+            ]
+        for s, format, dt in data:
+            self.assertEqual(to_datetime(s, format=format), dt)
+
+    def test_to_datetime_format_weeks(self):
+        data = [
+                ['2009324', '%Y%W%w', Timestamp('2009-08-13')],
+                ['2013020', '%Y%U%w', Timestamp('2013-01-13')]
+            ]
+        for s, format, dt in data:
+            self.assertEqual(to_datetime(s, format=format), dt)
 
 class TestToDatetimeInferFormat(tm.TestCase):
     def test_to_datetime_infer_datetime_format_consistent_format(self):
diff --git a/pandas/tslib.pyx b/pandas/tslib.pyx
index ccf7174c7..98baaa48a 100644
--- a/pandas/tslib.pyx
+++ b/pandas/tslib.pyx
@@ -1367,7 +1367,8 @@ def array_strptime(ndarray[object] values, object fmt, coerce=False):
         'j': 14,
         'U': 15,
         'W': 16,
-        'Z': 17
+        'Z': 17,
+        'p': 18   # just an additional key, works only with I
     }
     cdef int parse_code
 

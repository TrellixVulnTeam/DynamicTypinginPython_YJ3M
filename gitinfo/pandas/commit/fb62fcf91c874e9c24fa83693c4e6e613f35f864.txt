commit fb62fcf91c874e9c24fa83693c4e6e613f35f864
Author: Connor Charles <ccharles.gb@gmail.com>
Date:   Mon Aug 19 18:20:23 2019 +0100

    BUG: _can_use_numexpr fails when passed large Series (#27773)
    
    * BUG: _can_use_numexpr did not handle Series case correctly

diff --git a/doc/source/whatsnew/v0.25.1.rst b/doc/source/whatsnew/v0.25.1.rst
index 4e1bfac77..bb28ce9b6 100644
--- a/doc/source/whatsnew/v0.25.1.rst
+++ b/doc/source/whatsnew/v0.25.1.rst
@@ -53,7 +53,7 @@ Numeric
 ^^^^^^^
 - Bug in :meth:`Series.interpolate` when using a timezone aware :class:`DatetimeIndex` (:issue:`27548`)
 - Bug when printing negative floating point complex numbers would raise an ``IndexError`` (:issue:`27484`)
--
+- Bug where :class:`DataFrame` arithmetic operators such as :meth:`DataFrame.mul` with a :class:`Series` with axis=1 would raise an ``AttributeError`` on :class:`DataFrame` larger than the minimum threshold to invoke numexpr (:issue:`27636`)
 -
 
 Conversion
diff --git a/pandas/core/computation/expressions.py b/pandas/core/computation/expressions.py
index 5b6d27500..29c8239fa 100644
--- a/pandas/core/computation/expressions.py
+++ b/pandas/core/computation/expressions.py
@@ -76,16 +76,17 @@ def _can_use_numexpr(op, op_str, a, b, dtype_check):
 
         # required min elements (otherwise we are adding overhead)
         if np.prod(a.shape) > _MIN_ELEMENTS:
-
             # check for dtype compatibility
             dtypes = set()
             for o in [a, b]:
-                if hasattr(o, "dtypes"):
+                # Series implements dtypes, check for dimension count as well
+                if hasattr(o, "dtypes") and o.ndim > 1:
                     s = o.dtypes.value_counts()
                     if len(s) > 1:
                         return False
                     dtypes |= set(s.index.astype(str))
-                elif isinstance(o, np.ndarray):
+                # ndarray and Series Case
+                elif hasattr(o, "dtype"):
                     dtypes |= {o.dtype.name}
 
             # allowed are a superset
diff --git a/pandas/tests/test_expressions.py b/pandas/tests/test_expressions.py
index 407062498..ca514f62f 100644
--- a/pandas/tests/test_expressions.py
+++ b/pandas/tests/test_expressions.py
@@ -66,7 +66,7 @@ class TestExpressions:
                 operator_name = "truediv"
 
             if test_flex:
-                op = lambda x, y: getattr(df, arith)(y)
+                op = lambda x, y: getattr(x, arith)(y)
                 op.__name__ = arith
             else:
                 op = getattr(operator, operator_name)
@@ -318,7 +318,6 @@ class TestExpressions:
             for f in [self.frame, self.frame2, self.mixed, self.mixed2]:
 
                 for cond in [True, False]:
-
                     c = np.empty(f.shape, dtype=np.bool_)
                     c.fill(cond)
                     result = expr.where(c, f.values, f.values + 1)
@@ -431,3 +430,29 @@ class TestExpressions:
         # GH 22383 - .ne fails if columns containing column name 'dtype'
         result = test_input.loc[:, ["a", "dtype"]].ne(test_input.loc[:, ["a", "dtype"]])
         assert_frame_equal(result, expected)
+
+    @pytest.mark.parametrize(
+        "arith", ("add", "sub", "mul", "mod", "truediv", "floordiv")
+    )
+    @pytest.mark.parametrize("axis", (0, 1))
+    def test_frame_series_axis(self, axis, arith):
+        # GH#26736 Dataframe.floordiv(Series, axis=1) fails
+        if axis == 1 and arith == "floordiv":
+            pytest.xfail("'floordiv' does not succeed with axis=1 #27636")
+
+        df = self.frame
+        if axis == 1:
+            other = self.frame.iloc[0, :]
+        else:
+            other = self.frame.iloc[:, 0]
+
+        expr._MIN_ELEMENTS = 0
+
+        op_func = getattr(df, arith)
+
+        expr.set_use_numexpr(False)
+        expected = op_func(other, axis=axis)
+        expr.set_use_numexpr(True)
+
+        result = op_func(other, axis=axis)
+        assert_frame_equal(expected, result)

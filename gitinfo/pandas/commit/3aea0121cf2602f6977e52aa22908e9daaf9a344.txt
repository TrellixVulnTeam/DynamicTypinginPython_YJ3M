commit 3aea0121cf2602f6977e52aa22908e9daaf9a344
Author: Graham Jeffries <graham.r.jeffries@gmail.com>
Date:   Thu Dec 17 17:52:21 2015 -0500

    get chunked mysql rows as lists of tuples

diff --git a/doc/source/whatsnew/v0.18.0.txt b/doc/source/whatsnew/v0.18.0.txt
index de5439885..6d891ce32 100644
--- a/doc/source/whatsnew/v0.18.0.txt
+++ b/doc/source/whatsnew/v0.18.0.txt
@@ -238,3 +238,4 @@ Bug Fixes
 - Bug in ``df.replace`` while replacing value in mixed dtype ``Dataframe`` (:issue:`11698`)
 
 - Bug in ``read_excel`` failing to read any non-empty sheets when empty sheets exist and ``sheetname=None`` (:issue:`11711`)
+- Bug in ``read_sql`` with pymysql connections failing to return chunked data (:issue:`11522`)
diff --git a/pandas/io/sql.py b/pandas/io/sql.py
index bedc71379..95a6d02b1 100644
--- a/pandas/io/sql.py
+++ b/pandas/io/sql.py
@@ -1556,6 +1556,8 @@ class SQLiteDatabase(PandasSQL):
 
         while True:
             data = cursor.fetchmany(chunksize)
+            if type(data) == tuple:
+               data = list(data)
             if not data:
                 cursor.close()
                 break
diff --git a/pandas/io/tests/test_sql.py b/pandas/io/tests/test_sql.py
index fe65dd4bd..bfd1ac3f0 100644
--- a/pandas/io/tests/test_sql.py
+++ b/pandas/io/tests/test_sql.py
@@ -2477,6 +2477,21 @@ class TestXMySQL(MySQLMixIn, tm.TestCase):
         result.index = frame.index
         tm.assert_frame_equal(result, frame)
 
+    def test_chunksize_read_type(self):
+        _skip_if_no_pymysql()
+        frame = tm.makeTimeDataFrame()
+        frame.index.name = "index"
+        drop_sql = "DROP TABLE IF EXISTS test"
+        cur = self.conn.cursor()
+        cur.execute(drop_sql)
+        sql.to_sql(frame, name='test', con=self.conn, flavor='mysql')
+        query = "select * from test"
+        chunksize = 5
+        chunk_gen = pd.read_sql_query(sql=query, con=self.conn,
+                                      chunksize=chunksize, index_col="index")
+        chunk_df = next(chunk_gen)
+        tm.assert_frame_equal(frame[:chunksize], chunk_df)
+
     def test_execute(self):
         _skip_if_no_pymysql()
         frame = tm.makeTimeDataFrame()

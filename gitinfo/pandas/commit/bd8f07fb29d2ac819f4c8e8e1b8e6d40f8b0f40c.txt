commit bd8f07fb29d2ac819f4c8e8e1b8e6d40f8b0f40c
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Sat Nov 2 08:23:46 2019 -0700

    BUG: Series[timdelta64].var() should _not_ work (#28289)

diff --git a/doc/source/whatsnew/v1.0.0.rst b/doc/source/whatsnew/v1.0.0.rst
index fa1669b1f..2e2c5281e 100644
--- a/doc/source/whatsnew/v1.0.0.rst
+++ b/doc/source/whatsnew/v1.0.0.rst
@@ -304,6 +304,8 @@ Datetimelike
 - Bug in :class:`DataFrame` arithmetic operations when operating with a :class:`Series` with dtype `'timedelta64[ns]'` (:issue:`28049`)
 - Bug in :func:`pandas.core.groupby.generic.SeriesGroupBy.apply` raising ``ValueError`` when a column in the original DataFrame is a datetime and the column labels are not standard integers (:issue:`28247`)
 - Bug in :func:`pandas._config.localization.get_locales` where the ``locales -a`` encodes the locales list as windows-1252 (:issue:`23638`, :issue:`24760`, :issue:`27368`)
+- Bug in :meth:`Series.var` failing to raise ``TypeError`` when called with ``timedelta64[ns]`` dtype (:issue:`28289`)
+-
 
 Timedelta
 ^^^^^^^^^
diff --git a/pandas/core/nanops.py b/pandas/core/nanops.py
index b9267db76..f6555f390 100644
--- a/pandas/core/nanops.py
+++ b/pandas/core/nanops.py
@@ -705,11 +705,14 @@ def nanstd(values, axis=None, skipna=True, ddof=1, mask=None):
     >>> nanops.nanstd(s)
     1.0
     """
+    orig_dtype = values.dtype
+    values, mask, dtype, dtype_max, fill_value = _get_values(values, skipna, mask=mask)
+
     result = np.sqrt(nanvar(values, axis=axis, skipna=skipna, ddof=ddof, mask=mask))
-    return _wrap_results(result, values.dtype)
+    return _wrap_results(result, orig_dtype)
 
 
-@disallow("M8")
+@disallow("M8", "m8")
 @bottleneck_switch(ddof=1)
 def nanvar(values, axis=None, skipna=True, ddof=1, mask=None):
     """
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 3e9d3d5c0..4c7fb4d41 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -3988,6 +3988,7 @@ class Series(base.IndexOpsMixin, generic.NDFrame):
         If we have an ndarray as a value, then simply perform the operation,
         otherwise delegate to the object.
         """
+
         delegate = self._values
 
         if axis is not None:
diff --git a/pandas/tests/reductions/test_reductions.py b/pandas/tests/reductions/test_reductions.py
index 05ebff438..a04f8f0df 100644
--- a/pandas/tests/reductions/test_reductions.py
+++ b/pandas/tests/reductions/test_reductions.py
@@ -300,11 +300,14 @@ class TestIndexReductions:
         assert result[0] == expected
 
         # invalid ops
-        for op in ["skew", "kurt", "sem", "prod"]:
+        for op in ["skew", "kurt", "sem", "prod", "var"]:
             msg = "reduction operation '{}' not allowed for this dtype"
             with pytest.raises(TypeError, match=msg.format(op)):
                 getattr(td, op)()
 
+            with pytest.raises(TypeError, match=msg.format(op)):
+                getattr(td.to_frame(), op)(numeric_only=False)
+
         # GH#10040
         # make sure NaT is properly handled by median()
         s = Series([Timestamp("2015-02-03"), Timestamp("2015-02-07")])
@@ -636,8 +639,13 @@ class TestSeriesReductions:
         assert pd.isna(result)
 
         # timedelta64[ns]
-        result = getattr(Series(dtype="m8[ns]"), method)()
-        assert result is pd.NaT
+        tdser = Series([], dtype="m8[ns]")
+        if method == "var":
+            with pytest.raises(TypeError, match="operation 'var' not allowed"):
+                getattr(tdser, method)()
+        else:
+            result = getattr(tdser, method)()
+            assert result is pd.NaT
 
     def test_nansum_buglet(self):
         ser = Series([1.0, np.nan], index=[0, 1])

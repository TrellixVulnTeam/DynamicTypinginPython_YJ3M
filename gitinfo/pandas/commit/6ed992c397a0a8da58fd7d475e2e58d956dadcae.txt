commit 6ed992c397a0a8da58fd7d475e2e58d956dadcae
Author: Adam Klein <adamklein@gmail.com>
Date:   Mon Mar 19 11:28:08 2012 -0400

    ENH: added interval/dti conversion code, tests

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index 9d1a5d227..2fa0109ab 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -657,6 +657,12 @@ class DateOffset(object):
         if other is None:
             return False
 
+        if isinstance(other, basestring):
+            other = to_offset(other)
+
+        if not isinstance(other, DateOffset):
+            return False
+
         return self._params() == other._params()
 
     def __ne__(self, other):
@@ -1556,7 +1562,7 @@ for name, offset in _newOffsetMap.iteritems():
     if offset is None:
         continue
     offset.name = name
-    _newOffsetNames[offset] = offset
+    _newOffsetNames[offset] = name
 
 def inferTimeRule(index, _deprecated=True):
     if len(index) < 3:
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 2fd1ec3c4..c471801a7 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -1388,6 +1388,19 @@ class DatetimeIndex(Int64Index):
         else:
             return Index(_dt_box_array(self.asi8), dtype='object')
 
+    def to_interval(self, freq=None):
+        """
+        Cast to IntervalIndex at a particular frequency
+        """
+        if self.freq is None and freq is None:
+            msg = "You must pass a freq argument as current index has none."
+            raise ValueError(msg)
+
+        if freq is None:
+            freq = self.freq
+
+        return IntervalIndex(self.values, freq=freq)
+
     def shift(self, n, freq=None):
         """
         Specialized shift which produces a DatetimeIndex
@@ -1403,6 +1416,8 @@ class DatetimeIndex(Int64Index):
         shifted : DatetimeIndex
         """
         if freq is not None and freq != self.offset:
+            if isinstance(freq, basestring):
+                freq = datetools.to_offset(freq)
             return Index.shift(self, n, freq)
 
         if n == 0:
@@ -1596,10 +1611,12 @@ class DatetimeIndex(Int64Index):
             else:
                 return _dt_box(val, tzinfo=self.tzinfo)
         else:
-            new_offset = self.offset
-            if (type(key) == slice and new_offset is not None
-                and key.step is not None):
-                new_offset = key.step * self.offset
+            new_offset = None
+            if (type(key) == slice):
+                if self.offset is not None and key.step is not None:
+                    new_offset = key.step * self.offset
+                else:
+                    new_offset = self.offset
 
             if com._is_bool_indexer(key):
                 key = np.asarray(key)
@@ -1619,6 +1636,11 @@ class DatetimeIndex(Int64Index):
         except:
             return super(DatetimeIndex, self).map(func_to_map)
 
+    # alias to offset
+    @property
+    def freq(self):
+        return self.offset
+
     # Fast field accessors for periods of datetime index
     # --------------------------------------------------------------
 
@@ -1916,6 +1938,9 @@ class IntervalIndex(Int64Index):
                 if freq is None:
                     raise ValueError('freq cannot be none')
 
+                if isinstance(freq, datetools.DateOffset):
+                    freq = datetools._newOffsetNames[freq]
+
                 if data.dtype == np.datetime64:
                     data = datetools.dt64arr_to_sktsarr(data, freq)
                 elif data.dtype == np.int64:
@@ -2018,6 +2043,13 @@ class IntervalIndex(Int64Index):
         # how to represent ourselves to matplotlib
         return datetools._skts_box_array(self, self.freq), False
 
+    def to_timestamp(self, how='E'):
+        """
+        Cast to datetimeindex of timestamps, either at end or beginning of
+        interval
+        """
+        raise NotImplementedError
+
     def shift(self, n):
         """
         Specialized shift which produces an IntervalIndex
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 87880c5d3..f0d1a9e21 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -1885,11 +1885,34 @@ def dt64arr_to_sktsarr(ndarray[int64_t] dtarr, int base, long mult):
 
     for i in range(l):
         PyArray_DatetimeToDatetimeStruct(dtarr[i], NPY_FR_us, &dts)
-        out[i] = skts_ordinal(dts.year, dts.month, dts.day,
-                              dts.hour, dts.min, dts.sec, base)
+        out[i] = get_skts_ordinal(dts.year, dts.month, dts.day,
+                                  dts.hour, dts.min, dts.sec, base)
         out[i] = apply_mult(out[i], mult)
     return out
 
+def sktsarr_to_dt64arr(ndarray[int64_t] sktsarr, int base, long mult):
+    """
+    Convert array to datetime64 values from a set of ordinals corresponding to
+    intervals per skts convention.
+    """
+    cdef:
+        ndarray[int64_t] out
+        Py_ssize_t i, l
+        long ordinal
+
+    l = len(sktsarr)
+
+    out = np.empty(l, dtype='i8')
+
+    for i in range(l):
+        ordinal = remove_mult(sktsarr[i], mult)
+        # TODO: allow to select begin, not just end as is default
+        ordinal = get_python_ordinal(ordinal, base)
+        # TODO: python ordinal -> dt64 fast?
+        out[i] = 0
+
+    return out
+
 cpdef long skts_resample(long skts_ordinal, int base1, long mult1, int base2, long mult2,
                           object relation='E'):
     """
diff --git a/pandas/tests/test_datetime64.py b/pandas/tests/test_datetime64.py
index 8b91e37b6..6628d56df 100644
--- a/pandas/tests/test_datetime64.py
+++ b/pandas/tests/test_datetime64.py
@@ -561,6 +561,28 @@ class TestDatetime64(unittest.TestCase):
         for other in [idx2, idx3, idx4, idx5, idx6]:
             self.assert_( (idx1.values == other.values).all() )
 
+    def test_dti_slicing(self):
+        from pandas.core.datetools import Ts
+
+        dti = DatetimeIndex(start='1/1/2005', end='12/1/2005', freq='M')
+        dti2 = dti[[1,3,5]]
+
+        v1 = dti2[0]
+        v2 = dti2[1]
+        v3 = dti2[2]
+
+        self.assertEquals(v1, Ts('2/28/2005'))
+        self.assertEquals(v2, Ts('4/30/2005'))
+        self.assertEquals(v3, Ts('6/30/2005'))
+
+        # don't carry freq through irregular slicing
+        self.assertEquals(dti2.freq, None)
+
+        # don't carry freq through boolean slicing
+        dti2 = dti[[True]*len(dti)]
+        self.assertEquals(len(dti2), len(dti))
+        self.assertEquals(dti2.freq, None)
+
     def test_iindex_slice_index(self):
         ii = IntervalIndex(start='1/1/10', end='12/31/12', freq='M')
         s = Series(np.random.rand(len(ii)), index=ii)
@@ -570,7 +592,7 @@ class TestDatetime64(unittest.TestCase):
         res = s['2011']
         exp = s[12:24]
         assert_series_equal(res, exp)
-        
+
     def test_iindex_multiples(self):
         ii = IntervalIndex(start='1/1/10', end='12/31/12', freq='2M')
         self.assertEquals(ii[0], Interval('1/1/10', '2M'))

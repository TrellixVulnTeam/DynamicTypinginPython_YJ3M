commit b62a3a4f5f88ed5ebaabdff626828521b95053b9
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Fri May 1 12:35:43 2020 -0700

    CLN: address TODOs (#33886)

diff --git a/pandas/_libs/lib.pyx b/pandas/_libs/lib.pyx
index 14efab735..e3b1e1ec8 100644
--- a/pandas/_libs/lib.pyx
+++ b/pandas/_libs/lib.pyx
@@ -589,7 +589,7 @@ def array_equivalent_object(left: object[:], right: object[:]) -> bool:
         except TypeError as err:
             # Avoid raising TypeError on tzawareness mismatch
             # TODO: This try/except can be removed if/when Timestamp
-            #  comparisons are change dto match datetime, see GH#28507
+            #  comparisons are changed to match datetime, see GH#28507
             if "tz-naive and tz-aware" in str(err):
                 return False
             raise
@@ -2346,8 +2346,6 @@ def map_infer_mask(ndarray arr, object f, const uint8_t[:] mask, bint convert=Tr
 
             if cnp.PyArray_IsZeroDim(val):
                 # unbox 0-dim arrays, GH#690
-                # TODO: is there a faster way to unbox?
-                #   item_from_zerodim?
                 val = val.item()
 
         result[i] = val
@@ -2388,8 +2386,6 @@ def map_infer(ndarray arr, object f, bint convert=True):
 
         if cnp.PyArray_IsZeroDim(val):
             # unbox 0-dim arrays, GH#690
-            # TODO: is there a faster way to unbox?
-            #   item_from_zerodim?
             val = val.item()
 
         result[i] = val
diff --git a/pandas/_libs/tslibs/timedeltas.pyx b/pandas/_libs/tslibs/timedeltas.pyx
index c5092c863..7fc22ebf1 100644
--- a/pandas/_libs/tslibs/timedeltas.pyx
+++ b/pandas/_libs/tslibs/timedeltas.pyx
@@ -1516,10 +1516,6 @@ class Timedelta(_Timedelta):
 
     def __rmod__(self, other):
         # Naive implementation, room for optimization
-        if hasattr(other, 'dtype') and other.dtype.kind == 'i':
-            # TODO: Remove this check with backwards-compat shim
-            # for integer / Timedelta is removed.
-            raise TypeError(f'Invalid dtype {other.dtype} for __mod__')
         return self.__rdivmod__(other)[1]
 
     def __divmod__(self, other):
@@ -1529,10 +1525,6 @@ class Timedelta(_Timedelta):
 
     def __rdivmod__(self, other):
         # Naive implementation, room for optimization
-        if hasattr(other, 'dtype') and other.dtype.kind == 'i':
-            # TODO: Remove this check with backwards-compat shim
-            # for integer / Timedelta is removed.
-            raise TypeError(f'Invalid dtype {other.dtype} for __mod__')
         div = other // self
         return div, other - div * self
 
diff --git a/pandas/core/arrays/datetimelike.py b/pandas/core/arrays/datetimelike.py
index fbaa4e36d..e07e2da16 100644
--- a/pandas/core/arrays/datetimelike.py
+++ b/pandas/core/arrays/datetimelike.py
@@ -1511,13 +1511,9 @@ class DatetimeLikeArrayMixin(
             # TODO: Can we simplify/generalize these cases at all?
             raise TypeError(f"cannot subtract {type(self).__name__} from {other.dtype}")
         elif is_timedelta64_dtype(self.dtype):
-            if lib.is_integer(other) or is_integer_dtype(other):
-                # need to subtract before negating, since that flips freq
-                # -self flips self.freq, messing up results
-                return -(self - other)
-
             return (-self) + other
 
+        # We get here with e.g. datetime objects
         return -(self - other)
 
     def __iadd__(self, other):
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 3d563f48d..1bff17b40 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -8989,7 +8989,6 @@ ops.add_special_arithmetic_methods(DataFrame)
 
 
 def _from_nested_dict(data):
-    # TODO: this should be seriously cythonized
     new_data = collections.defaultdict(dict)
     for index, s in data.items():
         for col, v in s.items():
diff --git a/pandas/core/indexes/base.py b/pandas/core/indexes/base.py
index 4e74f3e58..79af28dc5 100644
--- a/pandas/core/indexes/base.py
+++ b/pandas/core/indexes/base.py
@@ -151,7 +151,6 @@ def _make_arithmetic_op(op, cls):
         return Index(result)
 
     name = f"__{op.__name__}__"
-    # TODO: docstring?
     return set_function_name(index_arithmetic_method, name, cls)
 
 
diff --git a/pandas/core/indexes/period.py b/pandas/core/indexes/period.py
index 135361c8c..54892d565 100644
--- a/pandas/core/indexes/period.py
+++ b/pandas/core/indexes/period.py
@@ -668,10 +668,14 @@ class PeriodIndex(DatetimeIndexOpsMixin, Int64Index):
         if self.equals(other):
             return self._get_reconciled_name_object(other)
 
-        if not is_dtype_equal(self.dtype, other.dtype):
-            # TODO: fastpath for if we have a different PeriodDtype
-            this = self.astype("O")
-            other = other.astype("O")
+        elif is_object_dtype(other.dtype):
+            return self.astype("O").intersection(other, sort=sort)
+
+        elif not is_dtype_equal(self.dtype, other.dtype):
+            # We can infer that the intersection is empty.
+            # assert_can_do_setop ensures that this is not just a mismatched freq
+            this = self[:0].astype("O")
+            other = other[:0].astype("O")
             return this.intersection(other, sort=sort)
 
         return self._setop(other, sort, opname="intersection")
diff --git a/pandas/core/internals/concat.py b/pandas/core/internals/concat.py
index e9bbd915d..0913c4702 100644
--- a/pandas/core/internals/concat.py
+++ b/pandas/core/internals/concat.py
@@ -1,4 +1,3 @@
-# TODO: Needs a better name; too many modules are already called "concat"
 from collections import defaultdict
 import copy
 from typing import List
diff --git a/pandas/io/sas/sasreader.py b/pandas/io/sas/sasreader.py
index 6ebcaf6b7..bd8c3be27 100644
--- a/pandas/io/sas/sasreader.py
+++ b/pandas/io/sas/sasreader.py
@@ -7,7 +7,7 @@ from abc import ABCMeta, abstractmethod
 from pandas.io.common import stringify_path
 
 
-# TODO: replace with Protocol in Python 3.8
+# TODO(PY38): replace with Protocol in Python 3.8
 class ReaderBase(metaclass=ABCMeta):
     """
     Protocol for XportReader and SAS7BDATReader classes.

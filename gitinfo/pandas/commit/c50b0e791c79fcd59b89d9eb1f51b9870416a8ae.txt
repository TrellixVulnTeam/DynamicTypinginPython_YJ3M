commit c50b0e791c79fcd59b89d9eb1f51b9870416a8ae
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Thu Jul 18 05:56:15 2019 -0500

    CLN: Trim unused/unnecessary code (#27440)

diff --git a/pandas/core/dtypes/cast.py b/pandas/core/dtypes/cast.py
index f483cf520..44a3fefb1 100644
--- a/pandas/core/dtypes/cast.py
+++ b/pandas/core/dtypes/cast.py
@@ -571,18 +571,6 @@ def maybe_upcast(values, fill_value=np.nan, dtype=None, copy=False):
     return values, fill_value
 
 
-def maybe_cast_item(obj, item, dtype):
-    chunk = obj[item]
-
-    if chunk.values.dtype != dtype:
-        if dtype in (np.object_, np.bool_):
-            obj[item] = chunk.astype(np.object_)
-        elif not issubclass(dtype, (np.integer, np.bool_)):  # pragma: no cover
-            raise ValueError(
-                "Unexpected dtype encountered: {dtype}".format(dtype=dtype)
-            )
-
-
 def invalidate_string_dtypes(dtype_set):
     """Change string like dtypes to object for
     ``DataFrame.select_dtypes()``.
diff --git a/pandas/core/dtypes/common.py b/pandas/core/dtypes/common.py
index d0e4bd9b4..f2571573b 100644
--- a/pandas/core/dtypes/common.py
+++ b/pandas/core/dtypes/common.py
@@ -898,41 +898,6 @@ def is_dtype_equal(source, target):
         return False
 
 
-def is_dtype_union_equal(source, target):
-    """
-    Check whether two arrays have compatible dtypes to do a union.
-    numpy types are checked with ``is_dtype_equal``. Extension types are
-    checked separately.
-
-    Parameters
-    ----------
-    source : The first dtype to compare
-    target : The second dtype to compare
-
-    Returns
-    -------
-    boolean
-        Whether or not the two dtypes are equal.
-
-    >>> is_dtype_equal("int", int)
-    True
-
-    >>> is_dtype_equal(CategoricalDtype(['a', 'b'],
-    ...                CategoricalDtype(['b', 'c']))
-    True
-
-    >>> is_dtype_equal(CategoricalDtype(['a', 'b'],
-    ...                CategoricalDtype(['b', 'c'], ordered=True))
-    False
-    """
-    source = _get_dtype(source)
-    target = _get_dtype(target)
-    if is_categorical_dtype(source) and is_categorical_dtype(target):
-        # ordered False for both
-        return source.ordered is target.ordered
-    return is_dtype_equal(source, target)
-
-
 def is_any_int_dtype(arr_or_dtype):
     """Check whether the provided array or dtype is of an integer dtype.
 
@@ -1498,60 +1463,6 @@ def is_datetimelike_v_numeric(a, b):
     )
 
 
-def is_datetimelike_v_object(a, b):
-    """
-    Check if we are comparing a datetime-like object to an object instance.
-
-    Parameters
-    ----------
-    a : array-like, scalar
-        The first object to check.
-    b : array-like, scalar
-        The second object to check.
-
-    Returns
-    -------
-    boolean
-        Whether we return a comparing a datetime-like to an object instance.
-
-    Examples
-    --------
-    >>> obj = object()
-    >>> dt = np.datetime64(pd.datetime(2017, 1, 1))
-    >>>
-    >>> is_datetimelike_v_object(obj, obj)
-    False
-    >>> is_datetimelike_v_object(dt, dt)
-    False
-    >>> is_datetimelike_v_object(obj, dt)
-    True
-    >>> is_datetimelike_v_object(dt, obj)  # symmetric check
-    True
-    >>> is_datetimelike_v_object(np.array([dt]), obj)
-    True
-    >>> is_datetimelike_v_object(np.array([obj]), dt)
-    True
-    >>> is_datetimelike_v_object(np.array([dt]), np.array([obj]))
-    True
-    >>> is_datetimelike_v_object(np.array([obj]), np.array([obj]))
-    False
-    >>> is_datetimelike_v_object(np.array([dt]), np.array([1]))
-    False
-    >>> is_datetimelike_v_object(np.array([dt]), np.array([dt]))
-    False
-    """
-
-    if not hasattr(a, "dtype"):
-        a = np.asarray(a)
-    if not hasattr(b, "dtype"):
-        b = np.asarray(b)
-
-    is_datetimelike = needs_i8_conversion
-    return (is_datetimelike(a) and is_object_dtype(b)) or (
-        is_datetimelike(b) and is_object_dtype(a)
-    )
-
-
 def needs_i8_conversion(arr_or_dtype):
     """
     Check whether the array or dtype should be converted to int64.
diff --git a/pandas/tests/dtypes/test_common.py b/pandas/tests/dtypes/test_common.py
index 27ae918b0..36548f351 100644
--- a/pandas/tests/dtypes/test_common.py
+++ b/pandas/tests/dtypes/test_common.py
@@ -527,23 +527,6 @@ def test_is_datetimelike_v_numeric():
     assert com.is_datetimelike_v_numeric(np.array([dt]), np.array([1]))
 
 
-def test_is_datetimelike_v_object():
-    obj = object()
-    dt = np.datetime64(pd.datetime(2017, 1, 1))
-
-    assert not com.is_datetimelike_v_object(dt, dt)
-    assert not com.is_datetimelike_v_object(obj, obj)
-    assert not com.is_datetimelike_v_object(np.array([dt]), np.array([1]))
-    assert not com.is_datetimelike_v_object(np.array([dt]), np.array([dt]))
-    assert not com.is_datetimelike_v_object(np.array([obj]), np.array([obj]))
-
-    assert com.is_datetimelike_v_object(dt, obj)
-    assert com.is_datetimelike_v_object(obj, dt)
-    assert com.is_datetimelike_v_object(np.array([dt]), obj)
-    assert com.is_datetimelike_v_object(np.array([obj]), dt)
-    assert com.is_datetimelike_v_object(np.array([dt]), np.array([obj]))
-
-
 def test_needs_i8_conversion():
     assert not com.needs_i8_conversion(str)
     assert not com.needs_i8_conversion(np.int64)
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index 037c885e4..cf8452cdd 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -33,8 +33,6 @@ from pandas.core.dtypes.common import (
     is_categorical_dtype,
     is_datetime64_dtype,
     is_datetime64tz_dtype,
-    is_datetimelike_v_numeric,
-    is_datetimelike_v_object,
     is_extension_array_dtype,
     is_interval_dtype,
     is_list_like,
@@ -1172,12 +1170,7 @@ def assert_series_equal(
         # we want to check only if we have compat dtypes
         # e.g. integer and M|m are NOT compat, but we can simply check
         # the values in that case
-        if (
-            is_datetimelike_v_numeric(left, right)
-            or is_datetimelike_v_object(left, right)
-            or needs_i8_conversion(left)
-            or needs_i8_conversion(right)
-        ):
+        if needs_i8_conversion(left) or needs_i8_conversion(right):
 
             # datetimelike may have different objects (e.g. datetime.datetime
             # vs Timestamp) but will compare equal

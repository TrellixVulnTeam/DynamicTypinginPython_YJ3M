commit e944d01d47fb8413c5a74e64dd58d69e9452421b
Author: jreback <jeff@reback.net>
Date:   Sat Sep 28 21:46:40 2013 -0400

    CLN: refactor cum methods to core/generic.py

diff --git a/doc/source/release.rst b/doc/source/release.rst
index fe3fb726d..2c975e58d 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -349,7 +349,9 @@ See :ref:`Internal Refactoring<whatsnew_0130.refactoring>`
 - Complex compat for ``Series`` with ``ndarray``. (:issue:`4819`)
 - Removed unnecessary ``rwproperty`` from codebase in favor of builtin property. (:issue:`4843`)
 - Refactor object level numeric methods (mean/sum/min/max...) from object level modules to
-  ``core/generic.py``(:issue:`4435`)
+  ``core/generic.py``(:issue:`4435`).
+- Refactor cum objects to core/generic.py (:issue:`4435`), note that these have a more numpy-like
+  function signature.
 
 .. _release.bug_fixes-0.13.0:
 
diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index 6c7165abe..819a56c5b 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -2816,6 +2816,22 @@ skipna : boolean, default True
 level : int, default None
         If the axis is a MultiIndex (hierarchical), count along a
         particular level, collapsing into a """ + name + """
+numeric_only : boolean, default None
+    Include only float, int, boolean data. If None, will attempt to use
+    everything, then use only numeric data
+
+Returns
+-------
+%(outname)s : """ + name + "\n"
+
+        _cnum_doc = """
+
+Parameters
+----------
+axis : """ + axis_descr + """
+skipna : boolean, default True
+    Exclude NA/null values. If an entire row/column is NA, the result
+    will be NA
 
 Returns
 -------
@@ -3001,148 +3017,37 @@ Returns
             return self._reduce(nanops.nanmin, axis=axis, skipna=skipna)
         cls.min = min
 
-    def cumsum(self, axis=None, skipna=True, **kwargs):
-        """
-        Return DataFrame of cumulative sums over requested axis.
-
-        Parameters
-        ----------
-        axis : {0, 1}
-            0 for row-wise, 1 for column-wise
-        skipna : boolean, default True
-            Exclude NA/null values. If an entire row/column is NA, the result
-            will be NA
-
-        Returns
-        -------
-        y : DataFrame
-        """
-        if axis is None:
-            axis = self._stat_axis_number
-        else:
-            axis = self._get_axis_number(axis)
-
-        y = _values_from_object(self).copy()
-        if not issubclass(y.dtype.type, np.integer):
-            mask = np.isnan(_values_from_object(self))
-
-            if skipna:
-                np.putmask(y, mask, 0.)
-
-            result = y.cumsum(axis)
-
-            if skipna:
-                np.putmask(result, mask, np.nan)
-        else:
-            result = y.cumsum(axis)
-        return self._wrap_array(result, self.axes, copy=False)
-
-    def cumprod(self, axis=None, skipna=True, **kwargs):
-        """
-        Return cumulative product over requested axis as DataFrame
-
-        Parameters
-        ----------
-        axis : {0, 1}
-            0 for row-wise, 1 for column-wise
-        skipna : boolean, default True
-            Exclude NA/null values. If an entire row/column is NA, the result
-            will be NA
-
-        Returns
-        -------
-        y : DataFrame
-        """
-        if axis is None:
-            axis = self._stat_axis_number
-        else:
-            axis = self._get_axis_number(axis)
-
-        y = _values_from_object(self).copy()
-        if not issubclass(y.dtype.type, np.integer):
-            mask = np.isnan(_values_from_object(self))
-
-            if skipna:
-                np.putmask(y, mask, 1.)
-            result = y.cumprod(axis)
-
-            if skipna:
-                np.putmask(result, mask, np.nan)
-        else:
-            result = y.cumprod(axis)
-        return self._wrap_array(result, self.axes, copy=False)
-
-    def cummax(self, axis=None, skipna=True, **kwargs):
-        """
-        Return DataFrame of cumulative max over requested axis.
-
-        Parameters
-        ----------
-        axis : {0, 1}
-            0 for row-wise, 1 for column-wise
-        skipna : boolean, default True
-            Exclude NA/null values. If an entire row/column is NA, the result
-            will be NA
-
-        Returns
-        -------
-        y : DataFrame
-        """
-        if axis is None:
-            axis = self._stat_axis_number
-        else:
-            axis = self._get_axis_number(axis)
-
-        y = _values_from_object(self).copy()
-        if not issubclass(y.dtype.type, np.integer):
-            mask = np.isnan(_values_from_object(self))
+        def _make_cum_function(name, accum_func, mask_a, mask_b):
 
-            if skipna:
-                np.putmask(y, mask, -np.inf)
-
-            result = np.maximum.accumulate(y, axis)
-
-            if skipna:
-                np.putmask(result, mask, np.nan)
-        else:
-            result = np.maximum.accumulate(y, axis)
-        return self._wrap_array(result, self.axes, copy=False)
-
-    def cummin(self, axis=None, skipna=True, **kwargs):
-        """
-        Return DataFrame of cumulative min over requested axis.
-
-        Parameters
-        ----------
-        axis : {0, 1}
-            0 for row-wise, 1 for column-wise
-        skipna : boolean, default True
-            Exclude NA/null values. If an entire row/column is NA, the result
-            will be NA
-
-        Returns
-        -------
-        y : DataFrame
-        """
-        if axis is None:
-            axis = self._stat_axis_number
-        else:
-            axis = self._get_axis_number(axis)
-
-        y = _values_from_object(self).copy()
-        if not issubclass(y.dtype.type, np.integer):
-            mask = np.isnan(_values_from_object(self))
+            @Substitution(outname=name)
+            @Appender("Return cumulative {0} over requested axis.".format(name) + _cnum_doc)
+            def func(self, axis=None, dtype=None, out=None, skipna=True, **kwargs):
+                if axis is None:
+                    axis = self._stat_axis_number
+                else:
+                    axis = self._get_axis_number(axis)
+
+                y = _values_from_object(self).copy()
+                if not issubclass(y.dtype.type, (np.integer,np.bool_)):
+                    mask = isnull(self)
+                    if skipna:
+                        np.putmask(y, mask, mask_a)
+                    result = accum_func(y, axis)
+                    if skipna:
+                        np.putmask(result, mask, mask_b)
+                else:
+                    result = accum_func(y, axis)
 
-            if skipna:
-                np.putmask(y, mask, np.inf)
+                d = self._construct_axes_dict()
+                d['copy'] = False
+                return self._constructor(result, **d)._propogate_attributes(self)
+            return func
 
-            result = np.minimum.accumulate(y, axis)
 
-            if skipna:
-                np.putmask(result, mask, np.nan)
-        else:
-            result = np.minimum.accumulate(y, axis)
-        return self._wrap_array(result, self.axes, copy=False)
+        cls.cummin  = _make_cum_function('min', lambda y, axis: np.minimum.accumulate(y, axis), np.inf, np.nan)
+        cls.cumsum  = _make_cum_function('sum',  lambda y, axis: y.cumsum(axis), 0., np.nan)
+        cls.cumprod = _make_cum_function('prod', lambda y, axis: y.cumprod(axis), 1., np.nan)
+        cls.cummax  = _make_cum_function('max',  lambda y, axis: np.maximum.accumulate(y, axis), -np.inf, np.nan)
 
 # install the indexerse
 for _name, _indexer in indexing.get_indexers_list():
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 01a11ed6d..90d535e51 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -1216,124 +1216,6 @@ class Series(generic.NDFrame):
     argmin = idxmin
     argmax = idxmax
 
-    def cumsum(self, axis=0, dtype=None, out=None, skipna=True):
-        """
-        Cumulative sum of values. Preserves locations of NaN values
-
-        Extra parameters are to preserve ndarray interface.
-
-        Parameters
-        ----------
-        skipna : boolean, default True
-            Exclude NA/null values
-
-        Returns
-        -------
-        cumsum : Series
-        """
-        arr = _values_from_object(self).copy()
-
-        do_mask = skipna and not issubclass(self.dtype.type,
-                                            (np.integer, np.bool_))
-        if do_mask:
-            mask = isnull(arr)
-            np.putmask(arr, mask, 0.)
-
-        result = arr.cumsum()
-
-        if do_mask:
-            np.putmask(result, mask, pa.NA)
-
-        return self._constructor(result, index=self.index, name=self.name)
-
-    def cumprod(self, axis=0, dtype=None, out=None, skipna=True):
-        """
-        Cumulative product of values. Preserves locations of NaN values
-
-        Extra parameters are to preserve ndarray interface.
-
-        Parameters
-        ----------
-        skipna : boolean, default True
-            Exclude NA/null values
-
-        Returns
-        -------
-        cumprod : Series
-        """
-        arr = _values_from_object(self).copy()
-
-        do_mask = skipna and not issubclass(self.dtype.type,
-                                            (np.integer, np.bool_))
-        if do_mask:
-            mask = isnull(arr)
-            np.putmask(arr, mask, 1.)
-
-        result = arr.cumprod()
-
-        if do_mask:
-            np.putmask(result, mask, pa.NA)
-
-        return self._constructor(result, index=self.index, name=self.name)
-
-    def cummax(self, axis=0, dtype=None, out=None, skipna=True):
-        """
-        Cumulative max of values. Preserves locations of NaN values
-
-        Extra parameters are to preserve ndarray interface.
-
-        Parameters
-        ----------
-        skipna : boolean, default True
-            Exclude NA/null values
-
-        Returns
-        -------
-        cummax : Series
-        """
-        arr = _values_from_object(self).copy()
-
-        do_mask = skipna and not issubclass(self.dtype.type, np.integer)
-        if do_mask:
-            mask = isnull(arr)
-            np.putmask(arr, mask, -np.inf)
-
-        result = np.maximum.accumulate(arr)
-
-        if do_mask:
-            np.putmask(result, mask, pa.NA)
-
-        return self._constructor(result, index=self.index, name=self.name)
-
-    def cummin(self, axis=0, dtype=None, out=None, skipna=True):
-        """
-        Cumulative min of values. Preserves locations of NaN values
-
-        Extra parameters are to preserve ndarray interface.
-
-        Parameters
-        ----------
-        skipna : boolean, default True
-            Exclude NA/null values
-
-        Returns
-        -------
-        cummin : Series
-        """
-        arr = _values_from_object(self).copy()
-
-        do_mask = skipna and not issubclass(self.dtype.type, np.integer)
-        if do_mask:
-            mask = isnull(arr)
-            np.putmask(arr, mask, np.inf)
-
-        result = np.minimum.accumulate(arr)
-
-        if do_mask:
-            np.putmask(result, mask, pa.NA)
-
-        return self._constructor(result, index=self.index, name=self.name)
-
     @Appender(pa.Array.round.__doc__)
     def round(self, decimals=0, out=None):
         """

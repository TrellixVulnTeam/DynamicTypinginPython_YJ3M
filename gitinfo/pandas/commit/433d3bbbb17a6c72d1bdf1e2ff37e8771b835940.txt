commit 433d3bbbb17a6c72d1bdf1e2ff37e8771b835940
Author: Adam Klein <adamklein@gmail.com>
Date:   Mon Feb 13 21:10:46 2012 -0500

    datetime enhancements, cleaned offset logic, made datetimecache backed by khash for quick index lookup

diff --git a/pandas/core/datetools.py b/pandas/core/datetools.py
index b38d9922d..2bd96c7a9 100644
--- a/pandas/core/datetools.py
+++ b/pandas/core/datetools.py
@@ -25,36 +25,32 @@ import calendar
 #-------------------------------------------------------------------------------
 # Boxing and unboxing
 
-_unbox_cache = dict()
+def _dt_box(key, freq=None, offset=-1):
+    '''
+    timestamp-like (int64, python datetime, etc.) => Timestamp
+    '''
+    return lib.Timestamp(key, freq=freq, offset=offset)
+
 def _dt_unbox(key):
     '''
-    Unbox Timestamp to datetime64
+    Timestamp-like => dt64
     '''
-    try:
-        return _unbox_cache[key]
-    except KeyError:
-        _unbox_cache[key] = np.datetime64(lib.pydt_to_i8(key))
-        return _unbox_cache[key]
+    return np.datetime64(lib.pydt_to_i8(key))
 
 def _dt_unbox_array(arr):
+    if arr is None:
+        return arr
+
     unboxer = np.frompyfunc(_dt_unbox, 1, 1)
     return unboxer(arr)
 
-def _dt_box_array(arr):
-    boxer = np.frompyfunc(lib.Timestamp, 1, 1)
-    return boxer(arr)
+def _dt_box_array(arr, freq=None, offset=-1):
+    if arr is None:
+        return arr
 
-_box_cache = dict()
-def _dt_box(key, freq=None, offset=-1):
-    '''
-    Box datetime64 to Timestamp
-    '''
-    try:
-        return _box_cache[key]
-    except KeyError:
-        _box_cache[key] = lib.Timestamp(key.view('i8'),
-                                        freq=freq, offset=offset)
-        return _box_cache[key]
+    boxfunc = lambda x: _dt_box(x, freq=freq, offset=offset)
+    boxer = np.frompyfunc(boxfunc, 1, 1)
+    return boxer(arr)
 
 #-------------------------------------------------------------------------------
 # Miscellaneous date functions
diff --git a/pandas/core/index.py b/pandas/core/index.py
index e09ac0692..3999e6afa 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -60,14 +60,16 @@ class Index(np.ndarray):
     _backfill = lib.backfill_object
 
     name = None
+    asi8 = None
 
     def __new__(cls, data, dtype=None, copy=False, name=None):
         if isinstance(data, np.ndarray):
-            if dtype is None and issubclass(data.dtype.type, np.datetime64):
-                return DatetimeIndex(data, copy=copy, name=name)
+            if dtype is None:
+                if issubclass(data.dtype.type, np.datetime64):
+                    return DatetimeIndex(data, copy=copy, name=name)
 
-            if dtype is None and issubclass(data.dtype.type, np.integer):
-                return Int64Index(data, copy=copy, name=name)
+                if issubclass(data.dtype.type, np.integer):
+                    return Int64Index(data, copy=copy, name=name)
 
             subarr = np.array(data, dtype=object, copy=copy)
         elif np.isscalar(data):
@@ -78,16 +80,13 @@ class Index(np.ndarray):
             subarr = _asarray_tuplesafe(data, dtype=object)
 
         if dtype is None:
-            if (lib.is_datetime_array(subarr) or 
-                lib.is_datetime64_array(subarr)):
-                return DatetimeIndex(subarr.astype('M8[us]'), name=name)
+            if (lib.is_datetime_array(subarr)
+                or lib.is_datetime64_array(subarr)
+                or lib.is_timestamp_array(subarr)):
+                return DatetimeIndex(subarr, copy=copy, name=name)
 
-            elif lib.is_timestamp_array(subarr):
-                return DatetimeIndex(_dt_unbox_array(subarr).astype('M8[us]'), 
-                                    name=name)
-
-        if lib.is_integer_array(subarr) and dtype is None:
-            return Int64Index(subarr.astype('i8'), name=name)
+            if lib.is_integer_array(subarr):
+                return Int64Index(subarr.astype('i8'), name=name)
 
         subarr = subarr.view(cls)
         subarr.name = name
@@ -944,7 +943,7 @@ class Int64Index(Index):
         name = self.name if self.name == other.name else None
         return Int64Index(joined, name=name)
 
-# -------- some conversion functions for datetime <--> datetime64
+# -------- some conversion wrapper functions
 
 def _as_i8(arg):
     if isinstance(arg, np.ndarray):
@@ -959,16 +958,10 @@ def _wrap_i8_function(f):
         return f(*view_args, **kwargs)
     return wrapper
 
-def _dt_index_box(arg):
-    if isinstance(arg, np.ndarray):
-        return arg.astype('O')
-    else:
-        return arg
-
 def _wrap_dt_function(f):
     @staticmethod
     def wrapper(*args, **kwargs):
-        view_args = [_dt_index_box(arg) for arg in args]
+        view_args = [_dt_box_array(arg) for arg in args]
         return f(*view_args, **kwargs)
     return wrapper
 
@@ -989,7 +982,7 @@ def _join_i8_wrapper(joinf, with_indexers=True):
 
 def _dt_index_cmp(opname):
     """
-    Wrap comparison operations to unbox a datetime to a datetime64.
+    Wrap comparison operations to unbox datetime-like to a datetime64.
     """
     def wrapper(self, other):
         if isinstance(other, datetime):
@@ -1002,7 +995,7 @@ def _dt_index_cmp(opname):
 
 def _dt_index_op(opname):
     """
-    Wrap arithmetic operations to unbox a datetime to a datetime64.
+    Wrap arithmetic operations to unbox a timedelta to a timedelta64.
     """
     def wrapper(self, other):
         if isinstance(other, timedelta):
@@ -1013,9 +1006,6 @@ def _dt_index_op(opname):
             return func(other)
     return wrapper
 
-# TODO: there is too much view/M8us stuff going on. better to just
-# have as integer internals probably
-
 class DatetimeIndex(Int64Index):
 
     _is_monotonic  = _wrap_i8_function(lib.is_monotonic_int64)
@@ -1054,8 +1044,21 @@ class DatetimeIndex(Int64Index):
             if end is None and n is None:
                 raise ValueError("No data, must supply end or n")
 
-            cached, first, last = lib._get_freq(freq, start, end, n)
-            dti = cls._construct_from_cache(name, freq, cached, first, last+1)
+            dtcache = lib.get_dtcache_freq(freq, start, end, n)
+            buf = dtcache.get_cache()
+            try:
+                first = dtcache.lookup(start)
+                if n is not None:
+                    dti = cls._construct_from_cache(name, freq, buf,
+                                                    first, first + n)
+                else:
+                    last = dtcache.lookup(end)
+                    dti = cls._construct_from_cache(name, freq, buf,
+                                                    first, last + 1)
+            except KeyError, e:
+                raise ValueError("Non-conforming time: %s"
+                                 % np.datetime64(e.message))
+
             return dti
 
         if not isinstance(data, np.ndarray):
@@ -1084,22 +1087,17 @@ class DatetimeIndex(Int64Index):
             subarr = np.array(data, dtype='M8[us]', copy=copy)
         else:
             subarr = np.array(data, dtype='M8[us]', copy=copy)
-            if len(data) > 0:
-                test = (subarr != data)
-                if (type(test) == bool and test == True) or test.any():
-                    raise TypeError('Unsafe NumPy casting, you must '
-                                    'explicitly cast')
+
+        subarr = subarr.view(cls)
+        subarr.freq = None
+        subarr.name = name
 
         if freq is not None:
-            failure = lib.conformity_check(subarr.view('i8'), freq)
+            failure = lib.conformity_check(subarr.asi8, freq)
             if failure is not None:
                 raise ValueError("%s does not satisfy frequency %s"
                                   % (np.datetime64(failure), freq))
 
-        subarr = subarr.view(cls)
-        subarr.freq = None
-        subarr.name = name
-
         return subarr
 
     @classmethod
@@ -1123,6 +1121,11 @@ class DatetimeIndex(Int64Index):
 
         return newdti
 
+    @property
+    def asi8(self):
+        # to do: cache me?
+        return self.values.view('i8')
+
     def shift(self, n=1):
         if self.freq is None:
             raise ValueError("Cannot shift, frequency of index is empty")
@@ -1138,7 +1141,6 @@ class DatetimeIndex(Int64Index):
                 key = _dt_unbox(key)
             val = arr_idx[key]
             if self.freq:
-                print self.freq
                 # suffer another cache lookup? how to avoid?
                 return _dt_box(val, self.freq,
                                self.first + self._engine.get_loc(val))
@@ -1170,46 +1172,46 @@ class DatetimeIndex(Int64Index):
 
     @property
     def year(self):
-        return lib.fast_field_accessor(self.values.view('i8'), 'Y')
+        return lib.fast_field_accessor(self.asi8, 'Y')
 
     @property
     def month(self):
-        return lib.fast_field_accessor(self.values.view('i8'), 'M')
+        return lib.fast_field_accessor(self.asi8, 'M')
 
     @property
     def day(self):
-        return lib.fast_field_accessor(self.values.view('i8'), 'D')
+        return lib.fast_field_accessor(self.asi8, 'D')
 
     @property
     def hour(self):
-        return lib.fast_field_accessor(self.values.view('i8'), 'h')
+        return lib.fast_field_accessor(self.asi8, 'h')
 
     @property
     def minute(self):
-        return lib.fast_field_accessor(self.values.view('i8'), 'm')
+        return lib.fast_field_accessor(self.asi8, 'm')
 
     @property
     def second(self):
-        return lib.fast_field_accessor(self.values.view('i8'), 's')
+        return lib.fast_field_accessor(self.asi8, 's')
 
     @property
     def microsecond(self):
-        return lib.fast_field_accessor(self.values.view('i8'), 'us')
+        return lib.fast_field_accessor(self.asi8, 'us')
 
     def __iter__(self):
-        return iter(_dt_box_array(self.values.view('i8')))
-        #return iter(self.values.astype('O'))
+        asi8 = self.asi8
+        if hasattr(self, 'freq') and self.freq is not None:
+            zeroloc = self.first + self._engine.get_loc(asi8[0])
+            return iter(_dt_box_array(asi8, self.freq, zeroloc))
+        else:
+            return iter(_dt_box_array(asi8))
 
     def searchsorted(self, key, side='left'):
-        """
-        Workaround numpy coredump in searchsorted
-        """
-        if isinstance(key, (datetime, lib.Timestamp)):
-            key = _dt_unbox(lib.Timestamp(key))
-        elif isinstance(key, np.ndarray):
+        if isinstance(key, np.ndarray):
             key = np.array(key, dtype='M8[us]', copy=False)
-        elif not isinstance(key, np.datetime64):
-            raise TypeError("Key %s is unrecognized type" % key)
+        else:
+            key = _dt_unbox(key)
+
         return self.values.searchsorted(key, side=side)
 
     def is_type_compatible(self, typ):
@@ -1239,9 +1241,8 @@ class DatetimeIndex(Int64Index):
 
     @cache_readonly
     def _engine(self):
-        view = self.view('i8', type=np.ndarray)
         mapping = lib.map_indices_int64
-        return _gin.DictIndexEngineDatetime(view, mapping)
+        return _gin.DictIndexEngineDatetime(self.asi8, mapping)
 
     def equals(self, other):
         """
@@ -1250,18 +1251,13 @@ class DatetimeIndex(Int64Index):
         if self is other:
             return True
 
-        if other.inferred_type == 'datetime64':
-            other = other.view('i8', type=np.ndarray)
-        elif other.inferred_type == 'datetime':
-            # TODO: faster conversion from datetime object to datetime64?
-            other = np.array(other, dtype='M8[us]', copy=False)
-            other = other.view('i8', type=np.ndarray)
-        elif len(other) == 0 and len(self) == 0 and other.dtype == object:
-            # fun corner case
-            return True
+        if other.inferred_type != 'datetime64':
+            try:
+                other = DatetimeIndex(other)
+            except:
+                return False
 
-        selfi8 = self.view('i8', type=np.ndarray)
-        return np.array_equal(selfi8, other)
+        return np.array_equal(self.asi8, other.asi8)
 
     def insert(self, loc, item):
         """
diff --git a/pandas/src/datetime.pyx b/pandas/src/datetime.pyx
index 53a8703c0..8fe64e7fc 100644
--- a/pandas/src/datetime.pyx
+++ b/pandas/src/datetime.pyx
@@ -66,24 +66,28 @@ cdef class _Timestamp(datetime):
     cdef:
         int64_t value       # numpy int64
         object freq         # frequency reference
-        int64_t offset      # offset into frequency cache
 
     def __add__(self, other):
-        if (is_integer_object(other) or PyInt_Check(other) or
-            PyLong_Check(other)):
-            if self.freq is None or self.offset == -1:
+        cdef:
+            int64_t idx
+            ndarray[int64_t] buf
+            DatetimeCache dtcache
+
+        if is_integer_object(other):
+            if self.freq is None:
                 msg = ("Cannot add integral value to Timestamp "
                        "without both freq and offset.")
                 raise ValueError(msg)
             else:
-                cached = _fcache[self.freq]
-                return Timestamp(cached[self.offset + other])
+                dtcache = _tcaches[self.freq]
+                buf = dtcache.get_cache()
+                idx = dtcache.lookup(self.value)
+                return Timestamp(buf[idx + other])
         else:
             return super(_Timestamp, self).__add__(other)
 
     def __sub__(self, other):
-        if (is_integer_object(other) or PyInt_Check(other) or
-            PyLong_Check(other)):
+        if is_integer_object(other):
             return self.__add__(-other)
         else:
             return super(_Timestamp, self).__sub__(other)
@@ -132,7 +136,7 @@ cdef convert_to_tsobject(object ts):
                             dts.day, dts.hour,
                             dts.min, dts.sec, dts.us)
     # this is cheap
-    elif is_integer_object(ts) or PyInt_Check(ts) or PyLong_Check(ts):
+    elif is_integer_object(ts): # or PyInt_Check(ts) or PyLong_Check(ts):
         retval.value = ts
         PyArray_DatetimeToDatetimeStruct(retval.value, NPY_FR_us, &dts)
         retval.dtval = <object>PyDateTime_FromDateAndTime(
@@ -246,675 +250,530 @@ cdef inline int64_t weekend_adjustment(int64_t dow, int bkwd):
             return (7 - dow)
     return 0
 
-cdef:
-    int64_t us_in_day = conversion_factor(r_microsecond, r_day)
+cdef int64_t us_in_day = conversion_factor(r_microsecond, r_day)
 
-# TODO: refactor count/generate logic, too much code duplication
+cdef class _Offset:
+    """
+    This class is used to generate timestamps from a provided start time,
+    maintaining state between each call to generate().
+    """
+    cpdef int64_t generate(self):
+        pass
 
-def generate_annual_range(object start, Py_ssize_t periods, int64_t dayoffset=0,
-                          int64_t biz=0):
+    cpdef reset(self, object start=None):
+        pass
+
+cdef class YearOffset(_Offset):
     """
-    Generate annual timestamps beginning with start time, and apply dayoffset to
+    Generate annual timestamps from provided start time; apply dayoffset to
     each timestamp. If biz > 0, we choose the next business day at each time;
     previous if < 0.
 
     Parameters
     ----------
-    start : timestamp-like
-    periods : int
     dayoffset : int
-    biz : boolean
-
-    Returns
-    -------
-    Array of datetime64
+    biz : int
     """
     cdef:
-        Py_ssize_t i, ly
-        int64_t adj, days, y, dow
-        ndarray[int64_t] dtindex
-        _TSObject ts
-
-    ts = convert_to_tsobject(start)
-    dtindex = np.empty(periods, np.int64)
-
-    dayoffset *= us_in_day
-
-    # apply offset to first element, propogates through array
-    dtindex[0] = ts.value + dayoffset
-    dow = ts_dayofweek(ts)
-
-    # need bday adjustment?
-    if biz != 0:
-        adj = weekend_adjustment(dow, biz < 0)
-    else:
-        adj = 0
-
-    dtindex[0] += adj * us_in_day
-
-    # do we count days in year in y or y+1? ignore offset!
-    ly = ts.dtval.month > 2 or (ts.dtval.month == 2 and ts.dtval.day == 29)
-    y  = ts.dtval.year
-
-    for i in range(1, periods):
-        days = 365 + is_leapyear(y + ly)
-        # reverse prior b-day adjustment
-        dtindex[i] = dtindex[i-1] + (days - adj) * us_in_day
-        y += 1
-        # apply new b-day adjustment
-        if biz != 0:
-            dow = (dow + days) % 7
-            adj = weekend_adjustment(dow, biz < 0)
-            dtindex[i] += adj * us_in_day
+        int64_t t, adj, dow, y, ly
+        object start
+        int64_t dayoffset, biz
 
-    return dtindex # .view(np.datetime64)
+    def __init__(self, int64_t dayoffset=0, int64_t biz=0):
+        self.dayoffset = dayoffset
+        self.biz = biz
 
-def generate_monthly_range(object start, Py_ssize_t periods, int64_t dayoffset=0,
-                           int64_t stride=1, int64_t biz=0):
-    """
-    Generate monthly timestamps beginning with start time, and apply dayoffset to
-    each timestamp. Stride, to construct strided timestamps (eg quarterly). If
-    biz > 0, we choose the next business day at each time; previous if < 0.
+    cpdef reset(self, object start=None):
+        cdef:
+            _TSObject ts
 
-    Parameters
-    ----------
-    start : timestamp-like
-    periods : int
-    dayoffset : int
-    stride : int, > 0
-    biz : boolean
+        if start is not None:
+            self.start = start
 
-    Returns
-    -------
-    Array of datetime64
-    """
-    cdef:
-        Py_ssize_t i, j, m, y, ly
-        int64_t days, dow, adj
-        ndarray[int64_t] dtindex
-        _TSObject ts
+        ts = convert_to_tsobject(self.start)
 
-    if stride <= 0:
-        raise ValueError("Stride must be positive")
+        self.t = ts.value + (self.dayoffset * us_in_day)
+        self.y = ts.dtval.year
 
-    ts = convert_to_tsobject(start)
+        self.ly = (ts.dtval.month > 2
+                   or (ts.dtval.month == 2 and ts.dtval.day == 29))
 
-    dtindex = np.empty(periods, np.int64)
+        if self.biz != 0:
+            self.dow = (ts_dayofweek(ts) + self.dayoffset) % 7
+            self.adj = weekend_adjustment(self.dow, self.biz < 0)
+        else:
+            self.adj = 0
 
-    dayoffset *= us_in_day
+    cpdef int64_t generate(self):
+        cdef:
+            int64_t tmp, days
 
-    # applies offset to first element, propogates through array
-    dtindex[0] = ts.value + dayoffset
-    dow = ts_dayofweek(ts)
+        tmp = self.t + self.adj * us_in_day
 
-    # need bday adjustment?
-    if biz != 0:
-        adj = weekend_adjustment(dow, biz < 0)
-    else:
-        adj = 0
+        days = 365 + is_leapyear(self.y + self.ly)
 
-    dtindex[0] += adj * us_in_day
+        self.t += days * us_in_day
+        self.y += 1
 
-    # for day counting. ignore offset
-    m = ts.dtval.month - 1
-    y = ts.dtval.year
-    ly = is_leapyear(y)
+        if self.biz != 0:
+            self.dow = (self.dow + days) % 7
+            self.adj = weekend_adjustment(self.dow, self.biz < 0)
 
-    for i in range(1, periods):
-        # reverse prev b-day adjustment
-        dtindex[i] = dtindex[i-1] - adj * us_in_day
+        return tmp
 
-        days = 0
-        for j in range(0, stride):
-            if m >= 12:
-                m -= 12
-                y += 1
-                ly = is_leapyear(y)
-            days += _days_per_month_table[ly][m]
-            m += 1
-
-        dtindex[i] += days * us_in_day
-
-        # apply new b-day adjustment
-        if biz != 0:
-            dow = (dow + days) % 7
-            adj = weekend_adjustment(dow, biz < 0)
-            dtindex[i] += adj * us_in_day
-
-    return dtindex # .view(np.datetime64)
-
-def generate_relativemonthly_range(object start, Py_ssize_t periods,
-                                   int64_t week=0, int64_t day=0):
+cdef class MonthOffset(_Offset):
     """
-    Generate relative monthly timestamps using the month & year of provided
-    start time. For example, fridays of the third week of each month (week=3,
-    day=4); or, thursdays of the last week of each month (week=-1, day=3).
+    Generate monthly timestamps from provided start time, and apply dayoffset
+    to each timestamp.  Stride to construct strided timestamps (eg quarterly).
+    If biz > 0, we choose the next business day at each time; previous if < 0.
 
     Parameters
     ----------
-    start : timestamp-like
-    periods : int
-    week : int
-    day : int, 0 to 6
-
-    Returns
-    -------
-    Array of datetime64
+    dayoffset : int
+    stride : int, > 0
+    biz : int
     """
     cdef:
-        Py_ssize_t i, m, y, ly
-        int64_t days, adj, dow
-        ndarray[int64_t] dtindex
-        _TSObject ts
+        Py_ssize_t stride, ly, m
+        int64_t t, y, dow, adj, biz, dayoffset
+        object start
 
-    if day < 0 or day > 6:
-        raise ValueError("Day offset must be 0 to 6")
+    def __init__(self, int64_t dayoffset=0, Py_ssize_t stride=1,
+                 int64_t biz=0):
+        self.dayoffset = dayoffset
+        self.stride = stride
+        self.biz = biz
 
-    ts = convert_to_tsobject(start)
+    cpdef reset(self, object start=None):
+        cdef:
+            _TSObject ts
 
-    dtindex = np.empty(periods, np.int64)
+        if start is not None:
+            self.start = start
 
-    # rewind to beginning of month
-    dtindex[0] = ts.value - (ts.dtval.day - 1) * us_in_day
+        if self.stride <= 0:
+            raise ValueError("Stride must be positive")
 
-    # apply adjustment: week of month, plus to particular day of week
-    dow = dayofweek(ts.dtval.year, ts.dtval.month, 1)
-    adj = (week * 7) + (day - dow) % 7
-    dtindex[0] += adj * us_in_day
+        ts = convert_to_tsobject(self.start)
 
-    # for day counting
-    m = ts.dtval.month - 1
-    y = ts.dtval.year
-    ly = is_leapyear(y)
+        self.t = ts.value + (self.dayoffset * us_in_day)
 
-    for i in range(1, periods):
-        # reverse prev adjustment
-        dtindex[i] = dtindex[i-1] - adj * us_in_day
+        # for day counting
+        self.m  = ts.dtval.month - 1
+        self.y  = ts.dtval.year
+        self.ly = is_leapyear(self.y)
 
-        if m >= 12:
-            m -= 12
-            y += 1
-            ly = is_leapyear(y)
+        if self.biz != 0:
+            self.dow = (ts_dayofweek(ts) + self.dayoffset) % 7
+            self.adj = weekend_adjustment(self.dow, self.biz < 0)
+        else:
+            self.adj = 0
 
-        # move to next month start
-        days = _days_per_month_table[ly][m]
-        dtindex[i] += days * us_in_day
+    cpdef int64_t generate(self):
+        cdef:
+            int64_t tmp, days
+            Py_ssize_t j
 
-        # apply new adjustment
-        dow = (dow + days) % 7
-        adj = (week * 7) + (day - dow) % 7
-        dtindex[i] += adj * us_in_day
+        tmp = self.t + self.adj * us_in_day
 
-        m += 1
+        days = 0
+        for j in range(0, self.stride):
+            if self.m >= 12:
+                self.m -= 12
+                self.y += 1
+                self.ly = is_leapyear(self.y)
+            days += _days_per_month_table[self.ly][self.m]
+            self.m += 1
 
-    return dtindex # .view(np.datetime64)
+        self.t += days * us_in_day
 
-def generate_daily_range(object start, Py_ssize_t periods, int64_t stride=1,
-                         int64_t biz=0):
-    """
-    Generate daily timestamps beginning with start time. If biz != 0, we skip
-    weekends. Stride, to construct weekly timestamps.
+        if self.biz != 0:
+            self.dow = (self.dow + days) % 7
+            self.adj = weekend_adjustment(self.dow, self.biz < 0)
 
+        return tmp
+
+cdef class DayOfMonthOffset(_Offset):
+    """
+    Generate relative monthly timestamps from month & year of provided start
+    time. For example, fridays of the third week of each month (week=3, day=4);
+    or, thursdays of the last week of each month (week=-1, day=3).
 
     Parameters
     ----------
-    start : timestamp-like
-    periods : int
-    stride : int, > 0
-    biz : boolean
-
-    Returns
-    -------
-    Array of datetime64
+    week : int
+    day : int, 0 to 6
     """
     cdef:
-        Py_ssize_t i
-        int64_t dow, adj
-        ndarray[int64_t] dtindex
-        _TSObject ts
+        Py_ssize_t stride, ly, m
+        int64_t t, y, dow, adj, day, week
+        object start
 
-    if stride <= 0:
-        raise ValueError("Stride must be positive")
+    def __init__(self, int64_t week=0, int64_t day=0):
+        self.week = week
+        self.day = day
 
-    ts = convert_to_tsobject(start)
+    cpdef reset(self, object start=None):
+        cdef:
+            _TSObject ts
 
-    dtindex = np.empty(periods, np.int64)
+        if start is not None:
+            self.start = start
 
-    dtindex[0] = ts.value
-    dow = ts_dayofweek(ts)
+        if self.day < 0 or self.day > 6:
+            raise ValueError("Day offset must be 0 to 6")
 
-    # need bday adjustment?
-    if biz != 0:
-        adj = weekend_adjustment(dow, 0)
-        if adj != 0:
-            dow = 0
-    else:
-        adj = 0
-
-    dtindex[0] += adj * us_in_day
-
-    # generate weekdays
-    for i in range(1, periods):
-        dtindex[i] = dtindex[i-1] + (stride * us_in_day)
-        if biz != 0:
-            dow += stride
-            dow %= 7
-            # skip sat., sun.
-            if dow == 5:
-                dtindex[i] += 2 * us_in_day
-                dow = 0
-            elif dow == 6:
-                dtindex[i] += us_in_day
-                dow = 0
-
-    return dtindex #.view(np.datetime64)
-
-# counting logic, helps working with ranges as above
-
-def count_annual_range(object start, object end, int64_t dayoffset=0,
-                       int64_t biz=0):
-    """
-    Count number of periods from first conforming date on or after start,
-    up to but not including end.
+        ts = convert_to_tsobject(self.start)
 
-    Parameters
-    ----------
-    start : timestamp-like
-    end : timestamp-like
-    dayoffset : int
-    biz : boolean
+        # rewind to beginning of month
+        self.t = ts.value - (ts.dtval.day - 1) * us_in_day
 
-    Returns
-    -------
-    int
-    """
-    cdef:
-        int64_t i=0, ly, adj, days, y, dow
-        _TSObject s, e
-
-    s = convert_to_tsobject(start)
-    e = convert_to_tsobject(end)
+        # adjustment: week of month, plus to particular day of week
+        self.dow = dayofweek(ts.dtval.year, ts.dtval.month, 1)
+        self.adj = (self.week * 7) + (self.day - self.dow) % 7
 
-    dayoffset *= us_in_day
+        # for day counting
+        self.m = ts.dtval.month - 1
+        self.y = ts.dtval.year
+        self.ly = is_leapyear(self.y)
 
-    # apply offset to first element, propogates through array
-    t = s.value + dayoffset
-    dow = ts_dayofweek(s)
+    cpdef int64_t generate(self):
+        cdef:
+            int64_t tmp, days
 
-    # need bday adjustment?
-    if biz != 0:
-        adj = weekend_adjustment(dow, biz < 0)
-    else:
-        adj = 0
+        tmp = self.t + self.adj * us_in_day
 
-    t += adj * us_in_day
+        # advance state
+        days = _days_per_month_table[self.ly][self.m]
+        self.dow = (self.dow + days) % 7
+        self.m += 1
+        if self.m >= 12:
+            self.m -= 12
+            self.y += 1
+            self.ly = is_leapyear(self.y)
 
-    # do we count days in year in y or y+1? ignore offset!
-    ly = s.dtval.month > 2 or (s.dtval.month == 2 and s.dtval.day == 29)
-    y  = s.dtval.year
+        self.t += days * us_in_day
 
-    while t < e.value:
-        i += 1
-        days = 365 + is_leapyear(y + ly)
-        # reverse prior b-day adjustment
-        t = t + (days - adj) * us_in_day
-        y += 1
-        # apply new b-day adjustment
-        if biz != 0:
-            dow = (dow + days) % 7
-            adj = weekend_adjustment(dow, biz < 0)
-            t += adj * us_in_day
+        self.adj = (self.week * 7) + (self.day - self.dow) % 7
 
-    return i
+        return tmp
 
-def count_monthly_range(object start, object end, int64_t dayoffset=0,
-                        int64_t stride=1, int64_t biz=0):
+cdef class DayOffset(_Offset):
     """
-    Count number of periods from first conforming date on or after start,
-    up to but not including end.
+    Generate daily timestamps beginning with first valid time >= start time. If
+    biz != 0, we skip weekends. Stride, to construct weekly timestamps.
 
     Parameters
     ----------
-    start : timestamp-like
-    end : timestamp-like
-    dayoffset : int
     stride : int, > 0
     biz : boolean
-
-    Returns
-    -------
-    int
     """
     cdef:
-        Py_ssize_t j, m, y, ly
-        int64_t i=0, t, days, dow, adj
-        _TSObject s, e
+        Py_ssize_t stride
+        int64_t t, adj, dow, biz
+        object start
 
-    if stride <= 0:
-        raise ValueError("Stride must be positive")
+    def __init__(self, int64_t stride=1, int64_t biz=0):
+        self.stride = stride
+        self.biz = biz
 
-    s = convert_to_tsobject(start)
-    e = convert_to_tsobject(end)
+    cpdef reset(self, object start=None):
+        cdef:
+            _TSObject ts
 
-    dayoffset *= us_in_day
+        if start is not None:
+            self.start = start
 
-    # applies offset to first element, propogates through array
-    t = s.value + dayoffset
-    dow = ts_dayofweek(s)
+        if self.stride <= 0:
+            raise ValueError("Stride must be positive")
 
-    # need bday adjustment?
-    if biz != 0:
-        adj = weekend_adjustment(dow, biz < 0)
-    else:
-        adj = 0
+        ts = convert_to_tsobject(self.start)
 
-    t += adj * us_in_day
+        self.t = ts.value
 
-    # for day counting
-    m = s.dtval.month - 1
-    y = s.dtval.year
-    ly = is_leapyear(y)
+        if self.biz != 0:
+            self.dow = ts_dayofweek(ts)
+            self.adj = weekend_adjustment(self.dow, 0)
+        else:
+            self.adj = 0
 
-    while t < e.value:
-        i += 1
-        # reverse prev b-day adjustment
-        t = t - adj * us_in_day
+    cpdef int64_t generate(self):
+        cdef:
+            int64_t tmp
 
-        days = 0
-        for j in range(0, stride):
-            if m >= 12:
-                m -= 12
-            y += 1
-            ly = is_leapyear(y)
-            days += _days_per_month_table[ly][m]
-            m += 1
-
-        t += days * us_in_day
-
-        # apply new b-day adjustment
-        if biz != 0:
-            dow = (dow + days) % 7
-            adj = weekend_adjustment(dow, biz < 0)
-            t += adj * us_in_day
+        tmp = self.t + self.adj * us_in_day
 
-    return i
+        self.t += (self.stride * us_in_day)
 
-def count_relativemonthly_range(object start, object end,
-                                int64_t week=0, int64_t day=0):
-    """
-    Count relative monthly timestamps using the month & year of start time.
-    For example, friday in the third week of each month (week=3, day=4); or,
-    thursday of last week of each month (week=-1, day=3).
+        if self.biz != 0:
+            self.dow += self.stride
+            self.dow %= 7
+            self.adj = weekend_adjustment(self.dow, 0)
 
-    Parameters
-    ----------
-    start : timestamp-like
-    end : timestamp-like
-    week : int
-    day : int, 0 to 6
+        return tmp
 
-    Returns
-    -------
-    Array of datetime64
+cdef ndarray[int64_t] _generate_range(_Offset offset, Py_ssize_t periods):
+    """
+    Generate timestamps according to offset.
     """
     cdef:
-        Py_ssize_t i=0, m, y, ly
-        int64_t days, adj, dow, t
-        _TSObject s, e
-
-    if day < 0 or day > 6:
-        raise ValueError("Day offset must be 0 to 6")
-
-    s = convert_to_tsobject(start)
-    e = convert_to_tsobject(end)
-
-    # rewind to beginning of month
-    t = s.value - (s.dtval.day - 1) * us_in_day
-
-    # apply adjustment: week of month, plus to particular day of week
-    dow = dayofweek(s.dtval.year, s.dtval.month, 1)
-    adj = (week * 7) + (day - dow) % 7
-    t += adj * us_in_day
-
-    # for day counting
-    m = s.dtval.month - 1
-    y = s.dtval.year
-    ly = is_leapyear(y)
-
-    while t < e.value:
-        i += 1
-        # reverse prev adjustment
-        t = t - adj * us_in_day
-
-        if m >= 12:
-            m -= 12
-            y += 1
-            ly = is_leapyear(y)
-
-        # move to next month start
-        days = _days_per_month_table[ly][m]
-        t += days * us_in_day
-
-        # apply new adjustment
-        dow = (dow + days) % 7
-        adj = (week * 7) + (day - dow) % 7
-        t += adj * us_in_day
-
-        m += 1
+        Py_ssize_t i
+        ndarray[int64_t] dtindex
 
-    return i
+    dtindex = np.empty(periods, np.int64)
+    for i in range(periods):
+        dtindex[i] = offset.generate()
+    return dtindex
 
-def count_daily_range(object start, object end, stride=1, int64_t biz=0):
+cdef int64_t _count_range(_Offset offset, object end):
     """
-    Count number of periods from first conforming date on or after start,
-    up to but not including end.
-
-    Parameters
-    ----------
-    start : timestamp-like
-    end : timestamp-like
-    stride : int, > 0
-    biz : boolean
-
-    Returns
-    -------
-    int
+    Count timestamps in range according to offset up to (but not including)
+    end time.
     """
     cdef:
-        int64_t i=0, t, dow, adj
-        _TSObject s, e
+        Py_ssize_t i=0
+        _TSObject e
 
-    if stride <= 0:
-        raise ValueError("Stride must be positive")
-
-    s = convert_to_tsobject(start)
     e = convert_to_tsobject(end)
-
-    t = s.value
-    dow = ts_dayofweek(s)
-
-    # need bday adjustment?
-    if biz != 0:
-        adj = weekend_adjustment(dow, 0)
-        if adj != 0:
-            dow = 0
-    else:
-        adj = 0
-
-    t += adj * us_in_day
-
-    # generate weekdays
-    while t < e.value:
+    while offset.generate() < e.value:
         i += 1
-        t = t + (stride * us_in_day)
-        if biz != 0:
-            dow += stride
-            dow %= 7
-            # skip sat., sun.
-            if dow == 5:
-                t += 2 * us_in_day
-                dow = 0
-            elif dow == 6:
-                t += us_in_day
-                dow = 0
-
     return i
 
 # Here's some frequency caching logic
 # ----------------------------------------------------------------------------------
 
+# cache size...
 # daily 1850-2050 takes up 73049 x 8bytes / 2**20bytes => 0.56Mb of cache. seems ok
+# double this at least, for indexer
 
-_CACHE_START = Timestamp(datetime(1850, 1, 1))
-_CACHE_END   = Timestamp(datetime(2050, 1, 1))
-
-_fcache = {}
-
-def _get_freq(freq, start, end=None, n=None):
+cdef class DatetimeCache:
     """
-    Retrieve from cache (or generate, first time through) an array of times
-    that correspond to the frequency we care about.
+    Holds a contiguous array of datetimes according to some offset rule, along
+    with a int64=>Py_ssize_t hashtable to discover offsets in that array quickly.
     """
+    cdef:
+        object start
+        object end
+        object cache
+        object periods
+
+        _Offset generator
+        Int64HashTable indexer
+        object is_dirty
+
+    def __init__(self, _Offset generator,
+                 object start, object end=None, object periods=None):
+        """
+        Note, prefer periods argument over end for generating range.
+        """
+
+        self.generator = generator
+        self.start = start
+        self.end = end
+        self.cache = None
+        self.periods = periods
+        self.is_dirty = True
+
+    cpdef rebuild(self):
+        cdef:
+            int64_t periods
+            Py_ssize_t i
+            ndarray[int64_t] buf
+
+        if self.periods is not None:
+            periods = self.periods
+            if self.cache is not None and periods < len(self.cache):
+                periods = len(self.cache)
+        else:
+            periods = self.count()
+
+        self.generator.reset(self.start)
+        buf = _generate_range(self.generator, periods)
+
+        if self.end is None:
+            self.end = buf[-1]
+
+        self.cache = buf
+
+        self.indexer = Int64HashTable(size_hint=periods)
+        for i in range(periods):
+            self.indexer.set_item(buf[i], i)
+
+        self.is_dirty = False
+
+    cpdef set_start(self, object start):
+        self.start = start
+        self.is_dirty = True
+
+    cpdef set_end(self, object end):
+        self.end = end
+        self.is_dirty = True
+
+    cpdef set_periods(self, object periods):
+        self.periods = periods
+        self.is_dirty = True
+
+    cpdef Py_ssize_t count(self):
+        if not self.is_dirty:
+            return len(self.cache)
+
+        self.generator.reset(self.start)
+        return _count_range(self.generator, self.end)
+
+    cpdef lookup(self, object tslike):
+        cdef:
+            _TSObject ts
+
+        ts = convert_to_tsobject(tslike)
+        return self.indexer.get_item(ts.value)
+
+    cpdef get_cache(self):
+        return self.cache
+
+_DEFAULT_BEGIN = Timestamp(datetime(1850, 1, 1))
+_DEFAULT_END = Timestamp(datetime(2050, 1, 1))
+_tcaches = {}
+
+_months = {
+    'JAN' : 1,
+    'FEB' : 2,
+    'MAR' : 3,
+    'APR' : 4,
+    'MAY' : 5,
+    'JUN' : 6,
+    'JUL' : 7,
+    'AUG' : 8,
+    'SEP' : 9,
+    'OCT' : 10,
+    'NOV' : 11,
+    'DEC' : 12
+}
+
+_quarters = {
+    'JAN' : 1,
+    'FEB' : 2,
+    'MAR' : 3
+}
+
+_weekdays = {
+    'MON' : 0,
+    'TUE' : 1,
+    'WED' : 2,
+    'THU' : 3,
+    'FRI' : 4
+}
+
+def get_dtcache_freq(freq, start=None, end=None, n=None):
+    """
+    Retrieve from cache (or generate, first time through) times that correspond
+    to the frequency we care about.
+
+    If we fall off end of cache, we generate more cache.
+    """
+    cdef:
+        DatetimeCache tc
+
+    if start is not None:
+        start = Timestamp(start)
+        first = start
+    else:
+        first = _DEFAULT_BEGIN
 
-    # TODO: need some logic to auto-(re)size cache?
+    if end is not None:
+        end = Timestamp(end)
+        last = end
+    else:
+        last = _DEFAULT_END
+
+    if first.value > _DEFAULT_BEGIN.value:
+        first = _DEFAULT_BEGIN
+
+    if last.value < _DEFAULT_END.value:
+        last = _DEFAULT_END
 
-    if freq not in _fcache:
-        #  generate range to cache
+    if freq not in _tcaches:
         if freq == 'WEEKDAY':
-            per = count_daily_range(_CACHE_START, _CACHE_END, biz=1)
-            rng = generate_daily_range(_CACHE_START, per, biz=1)
+            offset = DayOffset(stride=1, biz=1)
+
         elif freq == 'DAILY':
-            per = count_daily_range(_CACHE_START, _CACHE_END, biz=0)
-            rng = generate_daily_range(_CACHE_START, per, biz=0)
+            offset = DayOffset(stride=1, biz=0)
+
         elif freq == 'EOM':
-            per = count_monthly_range(_CACHE_START, _CACHE_END, dayoffset=-1,
-                                      biz=-1)
-            rng = generate_monthly_range(_CACHE_START, per, dayoffset=-1,
-                                         biz=-1)
+            offset = MonthOffset(dayoffset=-1, biz=-1)
+
         elif freq.startswith('W@'):
-            begin = _CACHE_START
-            offset = _CACHE_START.weekday()
-            if freq.endswith('MON'):
-                offset = (0 - offset) % 7
-            elif freq.endswith('TUE'):
-                offset = (1 - offset) % 7
-            elif freq.endswith('WED'):
-                offset = (2 - offset) % 7
-            elif freq.endswith('THU'):
-                offset = (3 - offset) % 7
-            elif freq.endswith('FRI'):
-                offset = (4 - offset) % 7
-            else:
+            wkd = first.weekday()
+            dow = freq[-3:]
+            if dow not in _weekdays:
                 raise ValueError('Bad weekday %s' % freq)
-            begin += timedelta(days=offset)
+            first += timedelta(days=(_weekdays[dow] - wkd) % 7)
+            offset = DayOffset(stride=7, biz=1)
 
-            per = count_daily_range(begin, _CACHE_END, stride=7, biz=1)
-            rng = generate_daily_range(begin, per, stride=7, biz=1)
         elif freq.startswith('Q@'):
-            begin = _CACHE_START
-            if freq.endswith('JAN'):
-                begin += Delta(months=1)
-            elif freq.endswith('FEB'):
-                begin += Delta(months=2)
-            elif freq.endswith('MAR'):
-                begin += Delta(months=3)
-            else:
-                raise ValueError('Bad quarter month %s' % freq)
+            mo = freq[-3:]
+            if mo not in _quarters:
+                raise ValueError('Bad month quarter %s' % freq)
+            first += Delta(months=_quarters[mo])
+            offset = MonthOffset(dayoffset=-1, stride=3, biz=-1)
 
-            per = count_monthly_range(begin, _CACHE_END, dayoffset=-1,
-                                      stride=3, biz=-1)
-            rng = generate_monthly_range(begin, per, dayoffset=-1,
-                                         stride=3, biz=-1)
         elif freq.startswith('A@'):
-            begin = _CACHE_START
-            if freq.endswith('JAN'):
-                begin += Delta(months=1)
-            elif freq.endswith('FEB'):
-                begin += Delta(months=2)
-            elif freq.endswith('MAR'):
-                begin += Delta(months=3)
-            elif freq.endswith('APR'):
-                begin += Delta(months=4)
-            elif freq.endswith('MAY'):
-                begin += Delta(months=5)
-            elif freq.endswith('JUN'):
-                begin += Delta(months=6)
-            elif freq.endswith('JUL'):
-                begin += Delta(months=7)
-            elif freq.endswith('AUG'):
-                begin += Delta(months=8)
-            elif freq.endswith('SEP'):
-                begin += Delta(months=9)
-            elif freq.endswith('OCT'):
-                begin += Delta(months=10)
-            elif freq.endswith('NOV'):
-                begin += Delta(months=11)
-            elif freq.endswith('DEC'):
-                pass
-            else:
-                raise ValueError('Bad annual month %s' % freq)
+            mo = freq[-3:]
+            if mo not in _months:
+                raise ValueError('Bad annual month in %s' % freq)
+            if _months[mo] < 12:
+                first += Delta(months=_months[mo])
+            offset = YearOffset(dayoffset=-1, biz=-1)
 
-            per = count_annual_range(begin, _CACHE_END, dayoffset=-1, biz=-1)
-            rng = generate_annual_range(begin, per, dayoffset=-1, biz=-1)
         elif freq.startswith('WOM@'):
-            begin = _CACHE_START
             offset = freq.split('@')[1]
-            dlist = ['MON', 'TUE', 'WED', 'THU', 'FRI']
             week = int(offset[:-3])
             dow = offset[-3:]
-            if dow not in dlist:
+            if dow not in _weekdays:
                 raise ValueError('Bad weekday in %s' % freq)
-            dow = dlist.index(dow)
-
-            per = count_relativemonthly_range(begin, _CACHE_END,
-                                              week=week, day=dow)
-
-            rng = generate_relativemonthly_range(begin, per,
-                                                 week=week, day=dow)
+            offset = DayOfMonthOffset(week=week, day=_weekdays[dow])
 
         else:
             raise ValueError('Supplied frequency %s not implemented' % freq)
 
-        # cache range
-        _fcache[freq] = rng
+        first = Timestamp(first)
+
+        _tcaches[freq] = DatetimeCache(offset, first, last)
+
+    tc = _tcaches[freq]
 
-    rng = _fcache[freq]
-    start = Timestamp(start)
+    if first.value < tc.start.value:
+        tc.set_start(first)
 
-    if start.value < rng[0]:
-        raise ValueError('Fell off cache, expand timestamp cache')
+    if last.value > tc.end.value:
+        tc.set_end(last)
 
-    first = rng.searchsorted(start.value)
+    if tc.is_dirty:
+        tc.rebuild()
 
     if n is not None:
-        if n >= len(rng):
-            raise ValueError('Fell off cache, expand timestamp cache')
-        last = first + n - 1
-    else:
-        endval = Timestamp(end).value
-        if endval > rng[-1]:
-            raise ValueError('Fell off cache, expand timestamp cache')
-        last = rng.searchsorted(endval)
+        idx = tc.lookup(start.value)
+        if idx + n > tc.count():
+            tc.set_periods(idx + n)
+            tc.rebuild()
 
-    return (rng, first, last)
+    return tc
 
 def conformity_check(ndarray[int64_t] data, object freq):
     cdef:
-        Py_ssize_t p, i
-        int64_t first, last
+        Py_ssize_t i
 
     if len(data) == 0:
         return None
 
-    rng, first, last = _get_freq(freq, data[0], n=len(data))
+    cache = get_dtcache_freq(freq, data[0], n=len(data))
 
     i = 0
-    p = first
     while i < len(data):
-        if rng[p] != data[i]:
+        try:
+            cache.lookup(data[i])
+        except KeyError:
             return data[i]
         i += 1
-        p += 1
 
     return None
 
@@ -1471,16 +1330,12 @@ cdef class Delta:
 
 def pydt_to_i8(object pydt):
     '''
-    Convert from python datetime object to int64 representation compatible with
-    numpy datetime64; converts to UTC
+    Convert to int64 representation compatible with numpy datetime64; converts
+    to UTC
     '''
     cdef:
         _TSObject ts
 
-    if (not PyDateTime_Check(pydt) and
-        not isinstance(pydt, Timestamp)):
-        raise ValueError("Expected a timestamp, received a %s" % type(pydt))
-
     ts = convert_to_tsobject(pydt)
 
     return ts.value
@@ -1491,7 +1346,6 @@ def i8_to_pydt(int64_t i8, object tzinfo = None):
     '''
     return Timestamp(i8)
 
-
 # Accessors
 # ------------------------------------------------------------------------------
 
diff --git a/pandas/tests/test_daterange.py b/pandas/tests/test_daterange.py
index ba2193005..b3761fd78 100644
--- a/pandas/tests/test_daterange.py
+++ b/pandas/tests/test_daterange.py
@@ -355,106 +355,163 @@ class TestDateRange(unittest.TestCase):
 
 class TestDatetimePyx(unittest.TestCase):
 
-    def test_gen_ann_range(self):
-        rng = lib.generate_annual_range(datetime(2002,1,1), periods=12,
-                dayoffset=0, biz=0)
+    def test_yearoffset(self):
+        do  = lib.YearOffset(dayoffset=0, biz=0)
+        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
+        rng.rebuild()
+        buf = rng.get_cache()
 
-        self.assert_(len(rng) == 12)
+        self.assert_(len(buf) == 12)
 
-        for i, t in enumerate(rng):
+        for i, t in enumerate(buf):
             t = lib.Timestamp(t)
             self.assert_(t.day == 1)
             self.assert_(t.month == 1)
             self.assert_(t.year == 2002 + i)
 
-        rng = lib.generate_annual_range(datetime(2002,1,1), periods=12,
-                dayoffset=-1, biz=0)
+        do  = lib.YearOffset(dayoffset=-1, biz=0)
+        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
+        rng.rebuild()
+        buf = rng.get_cache()
 
-        for i, t in enumerate(rng):
+        for i, t in enumerate(buf):
             t = lib.Timestamp(t)
             self.assert_(t.day == 31)
             self.assert_(t.month == 12)
             self.assert_(t.year == 2001 + i)
 
-        rng = lib.generate_annual_range(datetime(2002,1,1), periods=12,
-                dayoffset=0, biz=-1)
+        do  = lib.YearOffset(dayoffset=-1, biz=-1)
+        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
+        rng.rebuild()
+        buf = rng.get_cache()
 
-        for i, t in enumerate(rng):
+        for i, t in enumerate(buf):
             t = lib.Timestamp(t)
             self.assert_(t.weekday() < 5)
 
-        rng = lib.generate_annual_range(datetime(2002,1,1), periods=12,
-                dayoffset=0, biz=1)
+        do  = lib.YearOffset(dayoffset=0, biz=1)
+        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
+        rng.rebuild()
+        buf = rng.get_cache()
 
-        for i, t in enumerate(rng):
+        for i, t in enumerate(buf):
             t = lib.Timestamp(t)
             self.assert_(t.weekday() < 5)
 
-    def test_gen_mth_range(self):
-        rng = lib.generate_monthly_range(datetime(2002,1,1), periods=12,
-                dayoffset=0, biz=0)
+    def test_monthoffset(self):
+        do  = lib.MonthOffset(dayoffset=0, biz=0)
+        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
+        rng.rebuild()
+        buf = rng.get_cache()
 
-        self.assert_(len(rng) == 12)
+        self.assert_(len(buf) == 12)
 
-        for i, t in enumerate(rng):
+        for i, t in enumerate(buf):
             t = lib.Timestamp(t)
             self.assert_(t.day == 1)
             self.assert_(t.month == 1 + i)
             self.assert_(t.year == 2002)
 
-        rng = lib.generate_monthly_range(datetime(2002,1,1), periods=12,
-                dayoffset=-1, biz=0)
+        do  = lib.MonthOffset(dayoffset=-1, biz=0)
+        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
+        rng.rebuild()
+        buf = rng.get_cache()
 
-        for i, t in enumerate(rng):
+        for i, t in enumerate(buf):
             t = lib.Timestamp(t)
             self.assert_(t.day >= 28)
             self.assert_(t.month == (12 if i == 0 else i))
             self.assert_(t.year == 2001 + (i != 0))
 
-        rng = lib.generate_monthly_range(datetime(2002,1,1), periods=12,
-                dayoffset=0, biz=-1)
+        do  = lib.MonthOffset(dayoffset=0, biz=-1)
+        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
+        rng.rebuild()
+        buf = rng.get_cache()
 
-        for i, t in enumerate(rng):
+        for i, t in enumerate(buf):
             t = lib.Timestamp(t)
             self.assert_(t.weekday() < 5)
 
-        rng = lib.generate_monthly_range(datetime(2002,1,1), periods=12,
-                dayoffset=0, biz=1)
+        do  = lib.MonthOffset(dayoffset=0, biz=1)
+        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=12)
+        rng.rebuild()
+        buf = rng.get_cache()
 
-        for i, t in enumerate(rng):
+        for i, t in enumerate(buf):
             t = lib.Timestamp(t)
             self.assert_(t.weekday() < 5)
 
         for i in (-2, -1, 1, 2):
             for j in (-1, 0, 1):
-                rng1 = lib.generate_annual_range(datetime(2002,1,1),
-                        periods=12, dayoffset=i, biz=j)
-                rng2 = lib.generate_monthly_range(datetime(2002,1,1),
-                        periods=12, dayoffset=i, biz=j, stride=12)
-                self.assert_((rng1 == rng2).all())
+                do1 = lib.MonthOffset(dayoffset=i, biz=j, stride=12)
+                do2 = lib.YearOffset(dayoffset=i, biz=j)
+                rng1 = lib.DatetimeCache(do1, start=datetime(2002,1,1), 
+                                         periods=12)
+                rng2 = lib.DatetimeCache(do2, start=datetime(2002,1,1), 
+                                         periods=12)
+                rng1.rebuild()
+                rng2.rebuild()
 
-    def test_gen_dly_range(self):
-        rng = lib.generate_daily_range(datetime(2002,1,1), periods=365, biz=0)
-        self.assert_(len(rng) == 365)
+                buf1 = rng1.get_cache()
+                buf2 = rng2.get_cache()
 
-        ts = lib.Timestamp(rng[-1])
+                self.assert_((buf1 == buf2).all())
+
+    def test_dayoffset(self):
+        do  = lib.DayOffset(biz=0)
+        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=365)
+        rng.rebuild()
+        buf = rng.get_cache()
+
+        self.assert_(len(buf) == 365)
+
+        ts = lib.Timestamp(buf[-1])
         self.assert_(ts.day == 31)
         self.assert_(ts.month == 12)
         self.assert_(ts.year == 2002)
 
-        rng = lib.generate_daily_range(datetime(2004,1,1), periods=366, biz=0)
-        self.assert_(len(rng) == 366)
+        do  = lib.DayOffset(biz=0)
+        rng = lib.DatetimeCache(do, start=datetime(2004,1,1), periods=366)
+        rng.rebuild()
+        buf = rng.get_cache()
 
-        ts = lib.Timestamp(rng[-1])
+        ts = lib.Timestamp(buf[-1])
         self.assert_(ts.day == 31)
         self.assert_(ts.month == 12)
         self.assert_(ts.year == 2004)
 
-        rng = lib.generate_daily_range(datetime(2002,1,1), periods=365, biz=1)
-        for i, t in enumerate(rng):
+        do  = lib.DayOffset(biz=1)
+        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=365)
+        rng.rebuild()
+        buf = rng.get_cache()
+
+        for i, t in enumerate(buf):
             t = lib.Timestamp(t)
             self.assert_(t.weekday() < 5)
 
+    def test_dayofmonthoffset(self):
+        do  = lib.DayOfMonthOffset(week=-1, day=4)
+        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=40)
+        rng.rebuild()
+        buf = rng.get_cache()
+
+        self.assert_(len(buf) == 40)
+
+        for i, t in enumerate(buf):
+            t = lib.Timestamp(t)
+            self.assert_(t.weekday() == 4)
+
+        do  = lib.DayOfMonthOffset(week=2, day=2)
+        rng = lib.DatetimeCache(do, start=datetime(2002,1,1), periods=40)
+        rng.rebuild()
+        buf = rng.get_cache()
+
+        self.assert_(len(buf) == 40)
+
+        for i, t in enumerate(buf):
+            t = lib.Timestamp(t)
+            self.assert_(t.weekday() == 2)
+
 if tm.PERFORM_DATETIME64_TESTS:
     class TestDatetime64Range(TestDateRange):
         def setUp(self):

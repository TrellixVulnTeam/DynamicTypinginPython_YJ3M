commit 71f621fe11b499a6e1420737faf375ba99bb619b
Author: Jeff Reback <jeff@reback.net>
Date:   Mon Mar 27 15:22:22 2017 -0400

    API: NaT boolean accessors now return False (#15782)
    
    TST: add pandas/tests/scalar/test_nat
    
    TST: revise testing of tseries accessors
    
    closes #15781

diff --git a/doc/source/whatsnew/v0.20.0.txt b/doc/source/whatsnew/v0.20.0.txt
index a0b2b47c4..3ab69e1ff 100644
--- a/doc/source/whatsnew/v0.20.0.txt
+++ b/doc/source/whatsnew/v0.20.0.txt
@@ -771,7 +771,8 @@ Other API Changes
   since pandas version 0.13.0 and can be done with the ``Series.str.extract``
   method (:issue:`5224`). As a consequence, the ``as_indexer`` keyword is
   ignored (no longer needed to specify the new behaviour) and is deprecated.
-
+- ``NaT`` will now correctly report ``False`` for datetimelike boolean operations such as ``is_month_start`` (:issue:`15781`)
+- ``NaT`` will now correctly return ``np.nan`` for ``Timedelta`` and ``Period`` accessors such as ``days`` and ``quarter`` (:issue:`15782`)
 
 .. _whatsnew_0200.deprecations:
 
diff --git a/pandas/_libs/tslib.pyx b/pandas/_libs/tslib.pyx
index 055534bbd..d441f1ec4 100644
--- a/pandas/_libs/tslib.pyx
+++ b/pandas/_libs/tslib.pyx
@@ -849,6 +849,30 @@ class NaTType(_NaT):
     def is_leap_year(self):
         return False
 
+    @property
+    def is_month_start(self):
+        return False
+
+    @property
+    def is_quarter_start(self):
+        return False
+
+    @property
+    def is_year_start(self):
+        return False
+
+    @property
+    def is_month_end(self):
+        return False
+
+    @property
+    def is_quarter_end(self):
+        return False
+
+    @property
+    def is_year_end(self):
+        return False
+
     def __rdiv__(self, other):
         return _nat_rdivide_op(self, other)
 
@@ -3799,8 +3823,9 @@ def array_strptime(ndarray[object] values, object fmt,
 # these by definition return np.nan
 fields = ['year', 'quarter', 'month', 'day', 'hour',
           'minute', 'second', 'millisecond', 'microsecond', 'nanosecond',
-          'week', 'dayofyear', 'days_in_month', 'daysinmonth', 'dayofweek',
-          'weekday_name']
+          'week', 'dayofyear', 'weekofyear', 'days_in_month', 'daysinmonth',
+          'dayofweek', 'weekday_name', 'days', 'seconds', 'microseconds',
+          'nanoseconds', 'qyear', 'quarter']
 for field in fields:
     prop = property(fget=lambda self: np.nan)
     setattr(NaTType, field, prop)
@@ -4810,7 +4835,7 @@ def get_start_end_field(ndarray[int64_t] dtindex, object field,
     if field == 'is_month_start':
         if is_business:
             for i in range(count):
-                if dtindex[i] == NPY_NAT: out[i] = -1; continue
+                if dtindex[i] == NPY_NAT: out[i] = 0; continue
 
                 pandas_datetime_to_datetimestruct(
                     dtindex[i], PANDAS_FR_ns, &dts)
@@ -4823,7 +4848,7 @@ def get_start_end_field(ndarray[int64_t] dtindex, object field,
             return out.view(bool)
         else:
             for i in range(count):
-                if dtindex[i] == NPY_NAT: out[i] = -1; continue
+                if dtindex[i] == NPY_NAT: out[i] = 0; continue
 
                 pandas_datetime_to_datetimestruct(
                     dtindex[i], PANDAS_FR_ns, &dts)
@@ -4836,7 +4861,7 @@ def get_start_end_field(ndarray[int64_t] dtindex, object field,
     elif field == 'is_month_end':
         if is_business:
             for i in range(count):
-                if dtindex[i] == NPY_NAT: out[i] = -1; continue
+                if dtindex[i] == NPY_NAT: out[i] = 0; continue
 
                 pandas_datetime_to_datetimestruct(
                     dtindex[i], PANDAS_FR_ns, &dts)
@@ -4854,7 +4879,7 @@ def get_start_end_field(ndarray[int64_t] dtindex, object field,
             return out.view(bool)
         else:
             for i in range(count):
-                if dtindex[i] == NPY_NAT: out[i] = -1; continue
+                if dtindex[i] == NPY_NAT: out[i] = 0; continue
 
                 pandas_datetime_to_datetimestruct(
                     dtindex[i], PANDAS_FR_ns, &dts)
@@ -4871,7 +4896,7 @@ def get_start_end_field(ndarray[int64_t] dtindex, object field,
     elif field == 'is_quarter_start':
         if is_business:
             for i in range(count):
-                if dtindex[i] == NPY_NAT: out[i] = -1; continue
+                if dtindex[i] == NPY_NAT: out[i] = 0; continue
 
                 pandas_datetime_to_datetimestruct(
                     dtindex[i], PANDAS_FR_ns, &dts)
@@ -4885,7 +4910,7 @@ def get_start_end_field(ndarray[int64_t] dtindex, object field,
             return out.view(bool)
         else:
             for i in range(count):
-                if dtindex[i] == NPY_NAT: out[i] = -1; continue
+                if dtindex[i] == NPY_NAT: out[i] = 0; continue
 
                 pandas_datetime_to_datetimestruct(
                     dtindex[i], PANDAS_FR_ns, &dts)
@@ -4898,7 +4923,7 @@ def get_start_end_field(ndarray[int64_t] dtindex, object field,
     elif field == 'is_quarter_end':
         if is_business:
             for i in range(count):
-                if dtindex[i] == NPY_NAT: out[i] = -1; continue
+                if dtindex[i] == NPY_NAT: out[i] = 0; continue
 
                 pandas_datetime_to_datetimestruct(
                     dtindex[i], PANDAS_FR_ns, &dts)
@@ -4917,7 +4942,7 @@ def get_start_end_field(ndarray[int64_t] dtindex, object field,
             return out.view(bool)
         else:
             for i in range(count):
-                if dtindex[i] == NPY_NAT: out[i] = -1; continue
+                if dtindex[i] == NPY_NAT: out[i] = 0; continue
 
                 pandas_datetime_to_datetimestruct(
                     dtindex[i], PANDAS_FR_ns, &dts)
@@ -4934,7 +4959,7 @@ def get_start_end_field(ndarray[int64_t] dtindex, object field,
     elif field == 'is_year_start':
         if is_business:
             for i in range(count):
-                if dtindex[i] == NPY_NAT: out[i] = -1; continue
+                if dtindex[i] == NPY_NAT: out[i] = 0; continue
 
                 pandas_datetime_to_datetimestruct(
                     dtindex[i], PANDAS_FR_ns, &dts)
@@ -4948,7 +4973,7 @@ def get_start_end_field(ndarray[int64_t] dtindex, object field,
             return out.view(bool)
         else:
             for i in range(count):
-                if dtindex[i] == NPY_NAT: out[i] = -1; continue
+                if dtindex[i] == NPY_NAT: out[i] = 0; continue
 
                 pandas_datetime_to_datetimestruct(
                     dtindex[i], PANDAS_FR_ns, &dts)
@@ -4961,7 +4986,7 @@ def get_start_end_field(ndarray[int64_t] dtindex, object field,
     elif field == 'is_year_end':
         if is_business:
             for i in range(count):
-                if dtindex[i] == NPY_NAT: out[i] = -1; continue
+                if dtindex[i] == NPY_NAT: out[i] = 0; continue
 
                 pandas_datetime_to_datetimestruct(
                     dtindex[i], PANDAS_FR_ns, &dts)
@@ -4980,7 +5005,7 @@ def get_start_end_field(ndarray[int64_t] dtindex, object field,
             return out.view(bool)
         else:
             for i in range(count):
-                if dtindex[i] == NPY_NAT: out[i] = -1; continue
+                if dtindex[i] == NPY_NAT: out[i] = 0; continue
 
                 pandas_datetime_to_datetimestruct(
                     dtindex[i], PANDAS_FR_ns, &dts)
diff --git a/pandas/tests/indexes/datetimes/test_misc.py b/pandas/tests/indexes/datetimes/test_misc.py
index ef24c493f..76a26b09e 100644
--- a/pandas/tests/indexes/datetimes/test_misc.py
+++ b/pandas/tests/indexes/datetimes/test_misc.py
@@ -259,19 +259,14 @@ class TestDatetime64(tm.TestCase):
             dti.name = 'name'
 
             # non boolean accessors -> return Index
-            for accessor in ['year', 'month', 'day', 'hour', 'minute',
-                             'second', 'microsecond', 'nanosecond',
-                             'dayofweek', 'dayofyear', 'weekofyear',
-                             'quarter', 'weekday_name']:
+            for accessor in DatetimeIndex._field_ops:
                 res = getattr(dti, accessor)
                 assert len(res) == 365
                 assert isinstance(res, Index)
                 assert res.name == 'name'
 
             # boolean accessors -> return array
-            for accessor in ['is_month_start', 'is_month_end',
-                             'is_quarter_start', 'is_quarter_end',
-                             'is_year_start', 'is_year_end']:
+            for accessor in DatetimeIndex._bool_ops:
                 res = getattr(dti, accessor)
                 assert len(res) == 365
                 assert isinstance(res, np.ndarray)
diff --git a/pandas/tests/indexes/datetimes/test_ops.py b/pandas/tests/indexes/datetimes/test_ops.py
index 4abc28225..4681879d7 100644
--- a/pandas/tests/indexes/datetimes/test_ops.py
+++ b/pandas/tests/indexes/datetimes/test_ops.py
@@ -31,15 +31,10 @@ class TestDatetimeIndexOps(Ops):
         self.not_valid_objs = [o for o in self.objs if not mask(o)]
 
     def test_ops_properties(self):
-        self.check_ops_properties(
-            ['year', 'month', 'day', 'hour', 'minute', 'second', 'weekofyear',
-             'week', 'dayofweek', 'dayofyear', 'quarter'])
-        self.check_ops_properties(['date', 'time', 'microsecond', 'nanosecond',
-                                   'is_month_start', 'is_month_end',
-                                   'is_quarter_start',
-                                   'is_quarter_end', 'is_year_start',
-                                   'is_year_end', 'weekday_name'],
-                                  lambda x: isinstance(x, DatetimeIndex))
+        f = lambda x: isinstance(x, DatetimeIndex)
+        self.check_ops_properties(DatetimeIndex._field_ops, f)
+        self.check_ops_properties(DatetimeIndex._object_ops, f)
+        self.check_ops_properties(DatetimeIndex._bool_ops, f)
 
     def test_ops_properties_basic(self):
 
diff --git a/pandas/tests/indexes/period/test_ops.py b/pandas/tests/indexes/period/test_ops.py
index 4533428cf..3b94992f2 100644
--- a/pandas/tests/indexes/period/test_ops.py
+++ b/pandas/tests/indexes/period/test_ops.py
@@ -21,11 +21,10 @@ class TestPeriodIndexOps(Ops):
         self.not_valid_objs = [o for o in self.objs if not mask(o)]
 
     def test_ops_properties(self):
-        self.check_ops_properties(
-            ['year', 'month', 'day', 'hour', 'minute', 'second', 'weekofyear',
-             'week', 'dayofweek', 'dayofyear', 'quarter'])
-        self.check_ops_properties(['qyear'],
-                                  lambda x: isinstance(x, PeriodIndex))
+        f = lambda x: isinstance(x, PeriodIndex)
+        self.check_ops_properties(PeriodIndex._field_ops, f)
+        self.check_ops_properties(PeriodIndex._object_ops, f)
+        self.check_ops_properties(PeriodIndex._bool_ops, f)
 
     def test_asobject_tolist(self):
         idx = pd.period_range(start='2013-01-01', periods=4, freq='M',
diff --git a/pandas/tests/indexes/period/test_period.py b/pandas/tests/indexes/period/test_period.py
index 6a6c0ab49..6639fcd98 100644
--- a/pandas/tests/indexes/period/test_period.py
+++ b/pandas/tests/indexes/period/test_period.py
@@ -394,8 +394,8 @@ class TestPeriodIndex(DatetimeLike, tm.TestCase):
 
     def _check_all_fields(self, periodindex):
         fields = ['year', 'month', 'day', 'hour', 'minute', 'second',
-                  'weekofyear', 'week', 'dayofweek', 'weekday', 'dayofyear',
-                  'quarter', 'qyear', 'days_in_month', 'is_leap_year']
+                  'weekofyear', 'week', 'dayofweek', 'dayofyear',
+                  'quarter', 'qyear', 'days_in_month']
 
         periods = list(periodindex)
         s = pd.Series(periodindex)
diff --git a/pandas/tests/indexes/timedeltas/test_ops.py b/pandas/tests/indexes/timedeltas/test_ops.py
index 8c7b88a9c..2e9f11297 100644
--- a/pandas/tests/indexes/timedeltas/test_ops.py
+++ b/pandas/tests/indexes/timedeltas/test_ops.py
@@ -21,9 +21,9 @@ class TestTimedeltaIndexOps(Ops):
         self.not_valid_objs = []
 
     def test_ops_properties(self):
-        self.check_ops_properties(['days', 'hours', 'minutes', 'seconds',
-                                   'milliseconds'])
-        self.check_ops_properties(['microseconds', 'nanoseconds'])
+        f = lambda x: isinstance(x, TimedeltaIndex)
+        self.check_ops_properties(TimedeltaIndex._field_ops, f)
+        self.check_ops_properties(TimedeltaIndex._object_ops, f)
 
     def test_asobject_tolist(self):
         idx = timedelta_range(start='1 days', periods=4, freq='D', name='idx')
diff --git a/pandas/tests/scalar/test_nat.py b/pandas/tests/scalar/test_nat.py
new file mode 100644
index 000000000..ce2ed237f
--- /dev/null
+++ b/pandas/tests/scalar/test_nat.py
@@ -0,0 +1,248 @@
+import pytest
+
+from datetime import datetime, timedelta
+import pytz
+
+import numpy as np
+from pandas import (NaT, Index, Timestamp, Timedelta, Period,
+                    DatetimeIndex, PeriodIndex,
+                    TimedeltaIndex, Series, isnull)
+from pandas.util import testing as tm
+from pandas._libs.tslib import iNaT
+
+
+@pytest.mark.parametrize('nat, idx', [(Timestamp('NaT'), DatetimeIndex),
+                                      (Timedelta('NaT'), TimedeltaIndex),
+                                      (Period('NaT', freq='M'), PeriodIndex)])
+def test_nat_fields(nat, idx):
+
+    for field in idx._field_ops:
+
+        # weekday is a property of DTI, but a method
+        # on NaT/Timestamp for compat with datetime
+        if field == 'weekday':
+            continue
+
+        result = getattr(NaT, field)
+        assert np.isnan(result)
+
+        result = getattr(nat, field)
+        assert np.isnan(result)
+
+    for field in idx._bool_ops:
+
+        result = getattr(NaT, field)
+        assert result is False
+
+        result = getattr(nat, field)
+        assert result is False
+
+
+def test_nat_vector_field_access():
+    idx = DatetimeIndex(['1/1/2000', None, None, '1/4/2000'])
+
+    for field in DatetimeIndex._field_ops:
+        # weekday is a property of DTI, but a method
+        # on NaT/Timestamp for compat with datetime
+        if field == 'weekday':
+            continue
+
+        result = getattr(idx, field)
+        expected = Index([getattr(x, field) for x in idx])
+        tm.assert_index_equal(result, expected)
+
+    s = Series(idx)
+
+    for field in DatetimeIndex._field_ops:
+
+        # weekday is a property of DTI, but a method
+        # on NaT/Timestamp for compat with datetime
+        if field == 'weekday':
+            continue
+
+        result = getattr(s.dt, field)
+        expected = [getattr(x, field) for x in idx]
+        tm.assert_series_equal(result, Series(expected))
+
+    for field in DatetimeIndex._bool_ops:
+        result = getattr(s.dt, field)
+        expected = [getattr(x, field) for x in idx]
+        tm.assert_series_equal(result, Series(expected))
+
+
+@pytest.mark.parametrize('klass', [Timestamp, Timedelta, Period])
+def test_identity(klass):
+    assert klass(None) is NaT
+
+    result = klass(np.nan)
+    assert result is NaT
+
+    result = klass(None)
+    assert result is NaT
+
+    result = klass(iNaT)
+    assert result is NaT
+
+    result = klass(np.nan)
+    assert result is NaT
+
+    result = klass(float('nan'))
+    assert result is NaT
+
+    result = klass(NaT)
+    assert result is NaT
+
+    result = klass('NaT')
+    assert result is NaT
+
+    assert isnull(klass('nat'))
+
+
+@pytest.mark.parametrize('klass', [Timestamp, Timedelta, Period])
+def test_equality(klass):
+
+    # nat
+    if klass is not Period:
+        klass('').value == iNaT
+    klass('nat').value == iNaT
+    klass('NAT').value == iNaT
+    klass(None).value == iNaT
+    klass(np.nan).value == iNaT
+    assert isnull(klass('nat'))
+
+
+@pytest.mark.parametrize('klass', [Timestamp, Timedelta])
+def test_round_nat(klass):
+    # GH14940
+    ts = klass('nat')
+    for method in ["round", "floor", "ceil"]:
+        round_method = getattr(ts, method)
+        for freq in ["s", "5s", "min", "5min", "h", "5h"]:
+            assert round_method(freq) is ts
+
+
+def test_NaT_methods():
+    # GH 9513
+    raise_methods = ['astimezone', 'combine', 'ctime', 'dst',
+                     'fromordinal', 'fromtimestamp', 'isocalendar',
+                     'strftime', 'strptime', 'time', 'timestamp',
+                     'timetuple', 'timetz', 'toordinal', 'tzname',
+                     'utcfromtimestamp', 'utcnow', 'utcoffset',
+                     'utctimetuple']
+    nat_methods = ['date', 'now', 'replace', 'to_datetime', 'today']
+    nan_methods = ['weekday', 'isoweekday']
+
+    for method in raise_methods:
+        if hasattr(NaT, method):
+            with pytest.raises(ValueError):
+                getattr(NaT, method)()
+
+    for method in nan_methods:
+        if hasattr(NaT, method):
+            assert np.isnan(getattr(NaT, method)())
+
+    for method in nat_methods:
+        if hasattr(NaT, method):
+            # see gh-8254
+            exp_warning = None
+            if method == 'to_datetime':
+                exp_warning = FutureWarning
+            with tm.assert_produces_warning(
+                    exp_warning, check_stacklevel=False):
+                assert getattr(NaT, method)() is NaT
+
+    # GH 12300
+    assert NaT.isoformat() == 'NaT'
+
+
+@pytest.mark.parametrize('klass', [Timestamp, Timedelta])
+def test_isoformat(klass):
+
+    result = klass('NaT').isoformat()
+    expected = 'NaT'
+    assert result == expected
+
+
+def test_nat_arithmetic():
+    # GH 6873
+    i = 2
+    f = 1.5
+
+    for (left, right) in [(NaT, i), (NaT, f), (NaT, np.nan)]:
+        assert left / right is NaT
+        assert left * right is NaT
+        assert right * left is NaT
+        with pytest.raises(TypeError):
+            right / left
+
+    # Timestamp / datetime
+    t = Timestamp('2014-01-01')
+    dt = datetime(2014, 1, 1)
+    for (left, right) in [(NaT, NaT), (NaT, t), (NaT, dt)]:
+        # NaT __add__ or __sub__ Timestamp-like (or inverse) returns NaT
+        assert right + left is NaT
+        assert left + right is NaT
+        assert left - right is NaT
+        assert right - left is NaT
+
+    # timedelta-like
+    # offsets are tested in test_offsets.py
+
+    delta = timedelta(3600)
+    td = Timedelta('5s')
+
+    for (left, right) in [(NaT, delta), (NaT, td)]:
+        # NaT + timedelta-like returns NaT
+        assert right + left is NaT
+        assert left + right is NaT
+        assert right - left is NaT
+        assert left - right is NaT
+
+    # GH 11718
+    t_utc = Timestamp('2014-01-01', tz='UTC')
+    t_tz = Timestamp('2014-01-01', tz='US/Eastern')
+    dt_tz = pytz.timezone('Asia/Tokyo').localize(dt)
+
+    for (left, right) in [(NaT, t_utc), (NaT, t_tz),
+                          (NaT, dt_tz)]:
+        # NaT __add__ or __sub__ Timestamp-like (or inverse) returns NaT
+        assert right + left is NaT
+        assert left + right is NaT
+        assert left - right is NaT
+        assert right - left is NaT
+
+    # int addition / subtraction
+    for (left, right) in [(NaT, 2), (NaT, 0), (NaT, -3)]:
+        assert right + left is NaT
+        assert left + right is NaT
+        assert left - right is NaT
+        assert right - left is NaT
+
+
+def test_nat_arithmetic_index():
+    # GH 11718
+
+    dti = DatetimeIndex(['2011-01-01', '2011-01-02'], name='x')
+    exp = DatetimeIndex([NaT, NaT], name='x')
+    tm.assert_index_equal(dti + NaT, exp)
+    tm.assert_index_equal(NaT + dti, exp)
+
+    dti_tz = DatetimeIndex(['2011-01-01', '2011-01-02'],
+                           tz='US/Eastern', name='x')
+    exp = DatetimeIndex([NaT, NaT], name='x', tz='US/Eastern')
+    tm.assert_index_equal(dti_tz + NaT, exp)
+    tm.assert_index_equal(NaT + dti_tz, exp)
+
+    exp = TimedeltaIndex([NaT, NaT], name='x')
+    for (left, right) in [(NaT, dti), (NaT, dti_tz)]:
+        tm.assert_index_equal(left - right, exp)
+        tm.assert_index_equal(right - left, exp)
+
+    # timedelta
+    tdi = TimedeltaIndex(['1 day', '2 day'], name='x')
+    exp = DatetimeIndex([NaT, NaT], name='x')
+    for (left, right) in [(NaT, tdi)]:
+        tm.assert_index_equal(left + right, exp)
+        tm.assert_index_equal(right + left, exp)
+        tm.assert_index_equal(left - right, exp)
+        tm.assert_index_equal(right - left, exp)
diff --git a/pandas/tests/scalar/test_period.py b/pandas/tests/scalar/test_period.py
index 3128e9069..7a15600d6 100644
--- a/pandas/tests/scalar/test_period.py
+++ b/pandas/tests/scalar/test_period.py
@@ -110,20 +110,6 @@ class TestPeriodProperties(tm.TestCase):
         p = Period(tslib.iNaT)
         self.assertIs(p, pd.NaT)
 
-    def test_cons_null_like(self):
-        # check Timestamp compat
-        self.assertIs(Timestamp('NaT'), pd.NaT)
-        self.assertIs(Period('NaT'), pd.NaT)
-
-        self.assertIs(Timestamp(None), pd.NaT)
-        self.assertIs(Period(None), pd.NaT)
-
-        self.assertIs(Timestamp(float('nan')), pd.NaT)
-        self.assertIs(Period(float('nan')), pd.NaT)
-
-        self.assertIs(Timestamp(np.nan), pd.NaT)
-        self.assertIs(Period(np.nan), pd.NaT)
-
     def test_period_cons_mult(self):
         p1 = Period('2011-01', freq='3M')
         p2 = Period('2011-01', freq='M')
@@ -854,17 +840,6 @@ class TestPeriodProperties(tm.TestCase):
         self.assertEqual(Period(freq='Min', year=2012, month=2, day=1, hour=0,
                                 minute=0, second=0).days_in_month, 29)
 
-    def test_properties_nat(self):
-        p_nat = Period('NaT', freq='M')
-        t_nat = pd.Timestamp('NaT')
-        self.assertIs(p_nat, t_nat)
-
-        # confirm Period('NaT') work identical with Timestamp('NaT')
-        for f in ['year', 'month', 'day', 'hour', 'minute', 'second', 'week',
-                  'dayofyear', 'quarter', 'days_in_month']:
-            self.assertTrue(np.isnan(getattr(p_nat, f)))
-            self.assertTrue(np.isnan(getattr(t_nat, f)))
-
     def test_pnow(self):
 
         # deprecation, xref #13790
diff --git a/pandas/tests/scalar/test_timedelta.py b/pandas/tests/scalar/test_timedelta.py
index 7c5caa950..c2b895925 100644
--- a/pandas/tests/scalar/test_timedelta.py
+++ b/pandas/tests/scalar/test_timedelta.py
@@ -6,7 +6,7 @@ import pandas as pd
 import pandas.util.testing as tm
 from pandas.tseries.timedeltas import _coerce_scalar_to_timedelta_type as ct
 from pandas import (Timedelta, TimedeltaIndex, timedelta_range, Series,
-                    to_timedelta, compat, isnull)
+                    to_timedelta, compat)
 from pandas._libs.tslib import iNaT, NaTType
 
 
@@ -151,14 +151,6 @@ class TestTimedeltas(tm.TestCase):
                 500, 'ms').astype('m8[ns]').view('i8')
         self.assertEqual(Timedelta(10.5, unit='s').value, expected)
 
-        # nat
-        self.assertEqual(Timedelta('').value, iNaT)
-        self.assertEqual(Timedelta('nat').value, iNaT)
-        self.assertEqual(Timedelta('NAT').value, iNaT)
-        self.assertEqual(Timedelta(None).value, iNaT)
-        self.assertEqual(Timedelta(np.nan).value, iNaT)
-        self.assertTrue(isnull(Timedelta('nat')))
-
         # offset
         self.assertEqual(to_timedelta(pd.offsets.Hour(2)),
                          Timedelta('0 days, 02:00:00'))
@@ -686,11 +678,6 @@ class TestTimedeltas(tm.TestCase):
         expected = 'P0DT0H0M0.001S'
         self.assertEqual(result, expected)
 
-        # NaT
-        result = Timedelta('NaT').isoformat()
-        expected = 'NaT'
-        self.assertEqual(result, expected)
-
         # don't strip every 0
         result = Timedelta(minutes=1).isoformat()
         expected = 'P0DT0H1M0S'
diff --git a/pandas/tests/scalar/test_timestamp.py b/pandas/tests/scalar/test_timestamp.py
index bbf33c4db..e39375141 100644
--- a/pandas/tests/scalar/test_timestamp.py
+++ b/pandas/tests/scalar/test_timestamp.py
@@ -7,23 +7,19 @@ import numpy as np
 from datetime import datetime, timedelta
 from distutils.version import LooseVersion
 
-import pandas as pd
 import pandas.util.testing as tm
-
 from pandas.tseries import offsets, frequencies
 from pandas._libs import tslib, period
-from pandas._libs.tslib import get_timezone, iNaT
+from pandas._libs.tslib import get_timezone
 
 from pandas.compat import lrange, long
 from pandas.util.testing import assert_series_equal
 from pandas.compat.numpy import np_datetime64_compat
 from pandas import (Timestamp, date_range, Period, Timedelta, compat,
-                    Series, NaT, isnull, DataFrame, DatetimeIndex)
+                    Series, NaT, DataFrame, DatetimeIndex)
 from pandas.tseries.frequencies import (RESO_DAY, RESO_HR, RESO_MIN, RESO_US,
                                         RESO_MS, RESO_SEC)
 
-randn = np.random.randn
-
 
 class TestTimestamp(tm.TestCase):
 
@@ -202,8 +198,6 @@ class TestTimestamp(tm.TestCase):
             repr(Timestamp(2015, 11, 12, 1, 2, 3, 999999)),
             repr(Timestamp('2015-11-12 01:02:03.999999')))
 
-        self.assertIs(Timestamp(None), pd.NaT)
-
     def test_constructor_keyword(self):
         # GH 10758
         with tm.assertRaises(TypeError):
@@ -235,7 +229,7 @@ class TestTimestamp(tm.TestCase):
         self.assertEqual(base.toordinal(), ts.toordinal())
 
         ts = Timestamp.fromordinal(base.toordinal(), tz='US/Eastern')
-        self.assertEqual(pd.Timestamp('2000-01-01', tz='US/Eastern'), ts)
+        self.assertEqual(Timestamp('2000-01-01', tz='US/Eastern'), ts)
         self.assertEqual(base.toordinal(), ts.toordinal())
 
     def test_constructor_offset_depr(self):
@@ -260,7 +254,7 @@ class TestTimestamp(tm.TestCase):
         with tm.assert_produces_warning(FutureWarning,
                                         check_stacklevel=False):
             ts = Timestamp.fromordinal(base.toordinal(), offset='D')
-        self.assertEqual(pd.Timestamp('2000-01-01'), ts)
+        self.assertEqual(Timestamp('2000-01-01'), ts)
         self.assertEqual(ts.freq, 'D')
         self.assertEqual(base.toordinal(), ts.toordinal())
 
@@ -422,12 +416,12 @@ class TestTimestamp(tm.TestCase):
             self.assertRaises(NonExistentTimeError, ts.tz_localize,
                               tz, errors='raise')
             self.assertIs(ts.tz_localize(tz, errors='coerce'),
-                          pd.NaT)
+                          NaT)
 
     def test_tz_localize_errors_ambiguous(self):
         # See issue 13057
         from pytz.exceptions import AmbiguousTimeError
-        ts = pd.Timestamp('2015-11-1 01:00')
+        ts = Timestamp('2015-11-1 01:00')
         self.assertRaises(AmbiguousTimeError,
                           ts.tz_localize, 'US/Pacific', errors='coerce')
 
@@ -576,94 +570,6 @@ class TestTimestamp(tm.TestCase):
         for end in ends:
             self.assertTrue(getattr(ts, end))
 
-    def test_nat_fields(self):
-        # GH 10050
-        ts = Timestamp('NaT')
-        self.assertTrue(np.isnan(ts.year))
-        self.assertTrue(np.isnan(ts.month))
-        self.assertTrue(np.isnan(ts.day))
-        self.assertTrue(np.isnan(ts.hour))
-        self.assertTrue(np.isnan(ts.minute))
-        self.assertTrue(np.isnan(ts.second))
-        self.assertTrue(np.isnan(ts.microsecond))
-        self.assertTrue(np.isnan(ts.nanosecond))
-        self.assertTrue(np.isnan(ts.dayofweek))
-        self.assertTrue(np.isnan(ts.quarter))
-        self.assertTrue(np.isnan(ts.dayofyear))
-        self.assertTrue(np.isnan(ts.week))
-        self.assertTrue(np.isnan(ts.daysinmonth))
-        self.assertTrue(np.isnan(ts.days_in_month))
-
-    def test_nat_vector_field_access(self):
-        idx = DatetimeIndex(['1/1/2000', None, None, '1/4/2000'])
-
-        # non boolean fields
-        fields = ['year', 'quarter', 'month', 'day', 'hour', 'minute',
-                  'second', 'microsecond', 'nanosecond', 'week', 'dayofyear',
-                  'days_in_month']
-
-        for field in fields:
-            result = getattr(idx, field)
-            expected = [getattr(x, field) for x in idx]
-            self.assert_index_equal(result, pd.Index(expected))
-
-        # boolean fields
-        fields = ['is_leap_year']
-        # other boolean fields like 'is_month_start' and 'is_month_end'
-        # not yet supported by NaT
-
-        for field in fields:
-            result = getattr(idx, field)
-            expected = [getattr(x, field) for x in idx]
-            self.assert_numpy_array_equal(result, np.array(expected))
-
-        s = pd.Series(idx)
-
-        for field in fields:
-            result = getattr(s.dt, field)
-            expected = [getattr(x, field) for x in idx]
-            self.assert_series_equal(result, pd.Series(expected))
-
-    def test_nat_scalar_field_access(self):
-        fields = ['year', 'quarter', 'month', 'day', 'hour', 'minute',
-                  'second', 'microsecond', 'nanosecond', 'week', 'dayofyear',
-                  'days_in_month', 'daysinmonth', 'dayofweek', 'weekday_name']
-        for field in fields:
-            result = getattr(NaT, field)
-            self.assertTrue(np.isnan(result))
-
-    def test_NaT_methods(self):
-        # GH 9513
-        raise_methods = ['astimezone', 'combine', 'ctime', 'dst',
-                         'fromordinal', 'fromtimestamp', 'isocalendar',
-                         'strftime', 'strptime', 'time', 'timestamp',
-                         'timetuple', 'timetz', 'toordinal', 'tzname',
-                         'utcfromtimestamp', 'utcnow', 'utcoffset',
-                         'utctimetuple']
-        nat_methods = ['date', 'now', 'replace', 'to_datetime', 'today']
-        nan_methods = ['weekday', 'isoweekday']
-
-        for method in raise_methods:
-            if hasattr(NaT, method):
-                self.assertRaises(ValueError, getattr(NaT, method))
-
-        for method in nan_methods:
-            if hasattr(NaT, method):
-                self.assertTrue(np.isnan(getattr(NaT, method)()))
-
-        for method in nat_methods:
-            if hasattr(NaT, method):
-                # see gh-8254
-                exp_warning = None
-                if method == 'to_datetime':
-                    exp_warning = FutureWarning
-                with tm.assert_produces_warning(
-                        exp_warning, check_stacklevel=False):
-                    self.assertIs(getattr(NaT, method)(), NaT)
-
-        # GH 12300
-        self.assertEqual(NaT.isoformat(), 'NaT')
-
     def test_pprint(self):
         # GH12622
         import pprint
@@ -772,24 +678,40 @@ class TestTimestamp(tm.TestCase):
             self.assertRaises(ValueError, lambda: dti.round(freq))
 
         # GH 14440 & 15578
-        result = pd.Timestamp('2016-10-17 12:00:00.0015').round('ms')
-        expected = pd.Timestamp('2016-10-17 12:00:00.002000')
+        result = Timestamp('2016-10-17 12:00:00.0015').round('ms')
+        expected = Timestamp('2016-10-17 12:00:00.002000')
         self.assertEqual(result, expected)
 
-        result = pd.Timestamp('2016-10-17 12:00:00.00149').round('ms')
-        expected = pd.Timestamp('2016-10-17 12:00:00.001000')
+        result = Timestamp('2016-10-17 12:00:00.00149').round('ms')
+        expected = Timestamp('2016-10-17 12:00:00.001000')
         self.assertEqual(result, expected)
 
-        ts = pd.Timestamp('2016-10-17 12:00:00.0015')
+        ts = Timestamp('2016-10-17 12:00:00.0015')
         for freq in ['us', 'ns']:
             self.assertEqual(ts, ts.round(freq))
 
-        result = pd.Timestamp('2016-10-17 12:00:00.001501031').round('10ns')
-        expected = pd.Timestamp('2016-10-17 12:00:00.001501030')
+        result = Timestamp('2016-10-17 12:00:00.001501031').round('10ns')
+        expected = Timestamp('2016-10-17 12:00:00.001501030')
         self.assertEqual(result, expected)
 
         with tm.assert_produces_warning():
-            pd.Timestamp('2016-10-17 12:00:00.001501031').round('1010ns')
+            Timestamp('2016-10-17 12:00:00.001501031').round('1010ns')
+
+    def test_round_misc(self):
+        stamp = Timestamp('2000-01-05 05:09:15.13')
+
+        def _check_round(freq, expected):
+            result = stamp.round(freq=freq)
+            self.assertEqual(result, expected)
+
+        for freq, expected in [('D', Timestamp('2000-01-05 00:00:00')),
+                               ('H', Timestamp('2000-01-05 05:00:00')),
+                               ('S', Timestamp('2000-01-05 05:09:15'))]:
+            _check_round(freq, expected)
+
+        msg = frequencies._INVALID_FREQ_ERROR
+        with self.assertRaisesRegexp(ValueError, msg):
+            stamp.round('foo')
 
     def test_class_ops_pytz(self):
         tm._skip_if_no_pytz()
@@ -906,48 +828,30 @@ class TestTimestamp(tm.TestCase):
         check(val / 1000000000.0 + 0.5, unit='s', us=500000)
         check(days + 0.5, unit='D', h=12)
 
-        # nan
-        result = Timestamp(np.nan)
-        self.assertIs(result, NaT)
-
-        result = Timestamp(None)
-        self.assertIs(result, NaT)
-
-        result = Timestamp(iNaT)
-        self.assertIs(result, NaT)
-
-        result = Timestamp(NaT)
-        self.assertIs(result, NaT)
-
-        result = Timestamp('NaT')
-        self.assertIs(result, NaT)
-
-        self.assertTrue(isnull(Timestamp('nat')))
-
     def test_roundtrip(self):
 
         # test value to string and back conversions
         # further test accessors
         base = Timestamp('20140101 00:00:00')
 
-        result = Timestamp(base.value + pd.Timedelta('5ms').value)
+        result = Timestamp(base.value + Timedelta('5ms').value)
         self.assertEqual(result, Timestamp(str(base) + ".005000"))
         self.assertEqual(result.microsecond, 5000)
 
-        result = Timestamp(base.value + pd.Timedelta('5us').value)
+        result = Timestamp(base.value + Timedelta('5us').value)
         self.assertEqual(result, Timestamp(str(base) + ".000005"))
         self.assertEqual(result.microsecond, 5)
 
-        result = Timestamp(base.value + pd.Timedelta('5ns').value)
+        result = Timestamp(base.value + Timedelta('5ns').value)
         self.assertEqual(result, Timestamp(str(base) + ".000000005"))
         self.assertEqual(result.nanosecond, 5)
         self.assertEqual(result.microsecond, 0)
 
-        result = Timestamp(base.value + pd.Timedelta('6ms 5us').value)
+        result = Timestamp(base.value + Timedelta('6ms 5us').value)
         self.assertEqual(result, Timestamp(str(base) + ".006005"))
         self.assertEqual(result.microsecond, 5 + 6 * 1000)
 
-        result = Timestamp(base.value + pd.Timedelta('200ms 5us').value)
+        result = Timestamp(base.value + Timedelta('200ms 5us').value)
         self.assertEqual(result, Timestamp(str(base) + ".200005"))
         self.assertEqual(result.microsecond, 5 + 200 * 1000)
 
@@ -1004,9 +908,9 @@ class TestTimestamp(tm.TestCase):
         self.assertTrue(val != np.int64(1))
 
         # ops testing
-        df = DataFrame(randn(5, 2))
+        df = DataFrame(np.random.randn(5, 2))
         a = df[0]
-        b = Series(randn(5))
+        b = Series(np.random.randn(5))
         b.name = Timestamp('2000-01-01')
         tm.assert_series_equal(a / b, 1 / (b / a))
 
@@ -1149,8 +1053,8 @@ class TestTimestamp(tm.TestCase):
         s = Series(date_range('20010101', periods=10), name='dates')
         s_nat = s.copy(deep=True)
 
-        s[0] = pd.Timestamp('nat')
-        s[3] = pd.Timestamp('nat')
+        s[0] = Timestamp('nat')
+        s[3] = Timestamp('nat')
 
         ops = {'lt': 'gt', 'le': 'ge', 'eq': 'eq', 'ne': 'ne'}
 
@@ -1194,18 +1098,6 @@ class TestTimestamp(tm.TestCase):
             dt = Timestamp('2100-01-01 00:00:00', tz=tz)
             self.assertFalse(dt.is_leap_year)
 
-        self.assertFalse(pd.NaT.is_leap_year)
-        self.assertIsInstance(pd.NaT.is_leap_year, bool)
-
-    def test_round_nat(self):
-        # GH14940
-        ts = Timestamp('nat')
-        print(dir(ts))
-        for method in ["round", "floor", "ceil"]:
-            round_method = getattr(ts, method)
-            for freq in ["s", "5s", "min", "5min", "h", "5h"]:
-                self.assertIs(round_method(freq), ts)
-
 
 class TestTimestampNsOperations(tm.TestCase):
 
@@ -1293,95 +1185,6 @@ class TestTimestampNsOperations(tm.TestCase):
         self.assertEqual(t.value, expected)
         self.assertEqual(t.nanosecond, 10)
 
-    def test_nat_arithmetic(self):
-        # GH 6873
-        i = 2
-        f = 1.5
-
-        for (left, right) in [(pd.NaT, i), (pd.NaT, f), (pd.NaT, np.nan)]:
-            self.assertIs(left / right, pd.NaT)
-            self.assertIs(left * right, pd.NaT)
-            self.assertIs(right * left, pd.NaT)
-            with tm.assertRaises(TypeError):
-                right / left
-
-        # Timestamp / datetime
-        t = Timestamp('2014-01-01')
-        dt = datetime(2014, 1, 1)
-        for (left, right) in [(pd.NaT, pd.NaT), (pd.NaT, t), (pd.NaT, dt)]:
-            # NaT __add__ or __sub__ Timestamp-like (or inverse) returns NaT
-            self.assertIs(right + left, pd.NaT)
-            self.assertIs(left + right, pd.NaT)
-            self.assertIs(left - right, pd.NaT)
-            self.assertIs(right - left, pd.NaT)
-
-        # timedelta-like
-        # offsets are tested in test_offsets.py
-
-        delta = timedelta(3600)
-        td = Timedelta('5s')
-
-        for (left, right) in [(pd.NaT, delta), (pd.NaT, td)]:
-            # NaT + timedelta-like returns NaT
-            self.assertIs(right + left, pd.NaT)
-            self.assertIs(left + right, pd.NaT)
-            self.assertIs(right - left, pd.NaT)
-            self.assertIs(left - right, pd.NaT)
-
-        # GH 11718
-        tm._skip_if_no_pytz()
-        import pytz
-
-        t_utc = Timestamp('2014-01-01', tz='UTC')
-        t_tz = Timestamp('2014-01-01', tz='US/Eastern')
-        dt_tz = pytz.timezone('Asia/Tokyo').localize(dt)
-
-        for (left, right) in [(pd.NaT, t_utc), (pd.NaT, t_tz),
-                              (pd.NaT, dt_tz)]:
-            # NaT __add__ or __sub__ Timestamp-like (or inverse) returns NaT
-            self.assertIs(right + left, pd.NaT)
-            self.assertIs(left + right, pd.NaT)
-            self.assertIs(left - right, pd.NaT)
-            self.assertIs(right - left, pd.NaT)
-
-        # int addition / subtraction
-        for (left, right) in [(pd.NaT, 2), (pd.NaT, 0), (pd.NaT, -3)]:
-            self.assertIs(right + left, pd.NaT)
-            self.assertIs(left + right, pd.NaT)
-            self.assertIs(left - right, pd.NaT)
-            self.assertIs(right - left, pd.NaT)
-
-    def test_nat_arithmetic_index(self):
-        # GH 11718
-
-        # datetime
-        tm._skip_if_no_pytz()
-
-        dti = pd.DatetimeIndex(['2011-01-01', '2011-01-02'], name='x')
-        exp = pd.DatetimeIndex([pd.NaT, pd.NaT], name='x')
-        self.assert_index_equal(dti + pd.NaT, exp)
-        self.assert_index_equal(pd.NaT + dti, exp)
-
-        dti_tz = pd.DatetimeIndex(['2011-01-01', '2011-01-02'],
-                                  tz='US/Eastern', name='x')
-        exp = pd.DatetimeIndex([pd.NaT, pd.NaT], name='x', tz='US/Eastern')
-        self.assert_index_equal(dti_tz + pd.NaT, exp)
-        self.assert_index_equal(pd.NaT + dti_tz, exp)
-
-        exp = pd.TimedeltaIndex([pd.NaT, pd.NaT], name='x')
-        for (left, right) in [(pd.NaT, dti), (pd.NaT, dti_tz)]:
-            self.assert_index_equal(left - right, exp)
-            self.assert_index_equal(right - left, exp)
-
-        # timedelta
-        tdi = pd.TimedeltaIndex(['1 day', '2 day'], name='x')
-        exp = pd.DatetimeIndex([pd.NaT, pd.NaT], name='x')
-        for (left, right) in [(pd.NaT, tdi)]:
-            self.assert_index_equal(left + right, exp)
-            self.assert_index_equal(right + left, exp)
-            self.assert_index_equal(left - right, exp)
-            self.assert_index_equal(right - left, exp)
-
 
 class TestTimestampOps(tm.TestCase):
 
@@ -1722,22 +1525,3 @@ class TestTsUtil(tm.TestCase):
             self.assertEqual(
                 Timestamp(Timestamp.min.to_pydatetime()).value / 1000,
                 Timestamp.min.value / 1000)
-
-
-class TestTslib(tm.TestCase):
-
-    def test_round(self):
-        stamp = Timestamp('2000-01-05 05:09:15.13')
-
-        def _check_round(freq, expected):
-            result = stamp.round(freq=freq)
-            self.assertEqual(result, expected)
-
-        for freq, expected in [('D', Timestamp('2000-01-05 00:00:00')),
-                               ('H', Timestamp('2000-01-05 05:00:00')),
-                               ('S', Timestamp('2000-01-05 05:09:15'))]:
-            _check_round(freq, expected)
-
-        msg = pd.tseries.frequencies._INVALID_FREQ_ERROR
-        with self.assertRaisesRegexp(ValueError, msg):
-            stamp.round('foo')
diff --git a/pandas/tests/series/test_datetime_values.py b/pandas/tests/series/test_datetime_values.py
index 4c697c7e5..89f972a33 100644
--- a/pandas/tests/series/test_datetime_values.py
+++ b/pandas/tests/series/test_datetime_values.py
@@ -8,10 +8,8 @@ import pandas as pd
 
 from pandas.types.common import is_integer_dtype, is_list_like
 from pandas import (Index, Series, DataFrame, bdate_range,
-                    date_range, period_range, timedelta_range)
-from pandas.tseries.period import PeriodIndex
-from pandas.tseries.index import Timestamp, DatetimeIndex
-from pandas.tseries.tdi import TimedeltaIndex
+                    date_range, period_range, timedelta_range,
+                    PeriodIndex, Timestamp, DatetimeIndex, TimedeltaIndex)
 import pandas.core.common as com
 
 from pandas.util.testing import assert_series_equal
@@ -27,21 +25,13 @@ class TestSeriesDatetimeValues(TestData, tm.TestCase):
         # GH 7207, 11128
         # test .dt namespace accessor
 
-        ok_for_base = ['year', 'month', 'day', 'hour', 'minute', 'second',
-                       'weekofyear', 'week', 'dayofweek', 'weekday',
-                       'dayofyear', 'quarter', 'freq', 'days_in_month',
-                       'daysinmonth', 'is_leap_year']
-        ok_for_period = ok_for_base + ['qyear', 'start_time', 'end_time']
+        ok_for_period = PeriodIndex._datetimelike_ops
         ok_for_period_methods = ['strftime', 'to_timestamp', 'asfreq']
-        ok_for_dt = ok_for_base + ['date', 'time', 'microsecond', 'nanosecond',
-                                   'is_month_start', 'is_month_end',
-                                   'is_quarter_start', 'is_quarter_end',
-                                   'is_year_start', 'is_year_end', 'tz',
-                                   'weekday_name']
+        ok_for_dt = DatetimeIndex._datetimelike_ops
         ok_for_dt_methods = ['to_period', 'to_pydatetime', 'tz_localize',
                              'tz_convert', 'normalize', 'strftime', 'round',
                              'floor', 'ceil', 'weekday_name']
-        ok_for_td = ['days', 'seconds', 'microseconds', 'nanoseconds']
+        ok_for_td = TimedeltaIndex._datetimelike_ops
         ok_for_td_methods = ['components', 'to_pytimedelta', 'total_seconds',
                              'round', 'floor', 'ceil']
 
diff --git a/pandas/tests/test_base.py b/pandas/tests/test_base.py
index 68db0d193..032e3a186 100644
--- a/pandas/tests/test_base.py
+++ b/pandas/tests/test_base.py
@@ -219,7 +219,7 @@ class Ops(tm.TestCase):
                     self.assertEqual(result, expected)
 
             # freq raises AttributeError on an Int64Index because its not
-            # defined we mostly care about Series hwere anyhow
+            # defined we mostly care about Series here anyhow
             if not ignore_failures:
                 for o in self.not_valid_objs:
 
diff --git a/pandas/tests/test_categorical.py b/pandas/tests/test_categorical.py
index 8fd3c6324..b4072d04d 100644
--- a/pandas/tests/test_categorical.py
+++ b/pandas/tests/test_categorical.py
@@ -17,9 +17,11 @@ from pandas.types.common import (is_categorical_dtype,
 import pandas as pd
 import pandas.compat as compat
 import pandas.util.testing as tm
-from pandas import (Categorical, Index, Series, DataFrame, PeriodIndex,
-                    Timestamp, CategoricalIndex, DatetimeIndex,
-                    isnull, NaT)
+from pandas import (Categorical, Index, Series, DataFrame,
+                    Timestamp, CategoricalIndex, isnull,
+                    date_range, DatetimeIndex,
+                    period_range, PeriodIndex,
+                    timedelta_range, TimedeltaIndex, NaT)
 from pandas.compat import range, lrange, u, PY3
 from pandas.core.config import option_context
 
@@ -4299,9 +4301,6 @@ Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01
     def test_dt_accessor_api_for_categorical(self):
         # https://github.com/pandas-dev/pandas/issues/10661
         from pandas.tseries.common import Properties
-        from pandas.tseries.index import date_range, DatetimeIndex
-        from pandas.tseries.period import period_range, PeriodIndex
-        from pandas.tseries.tdi import timedelta_range, TimedeltaIndex
 
         s_dr = Series(date_range('1/1/2015', periods=5, tz="MET"))
         c_dr = s_dr.astype("category")
@@ -4312,10 +4311,14 @@ Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01
         s_tdr = Series(timedelta_range('1 days', '10 days'))
         c_tdr = s_tdr.astype("category")
 
+        # only testing field (like .day)
+        # and bool (is_month_start)
+        get_ops = lambda x: x._datetimelike_ops
+
         test_data = [
-            ("Datetime", DatetimeIndex._datetimelike_ops, s_dr, c_dr),
-            ("Period", PeriodIndex._datetimelike_ops, s_pr, c_pr),
-            ("Timedelta", TimedeltaIndex._datetimelike_ops, s_tdr, c_tdr)]
+            ("Datetime", get_ops(DatetimeIndex), s_dr, c_dr),
+            ("Period", get_ops(PeriodIndex), s_pr, c_pr),
+            ("Timedelta", get_ops(TimedeltaIndex), s_tdr, c_tdr)]
 
         self.assertIsInstance(c_dr.dt, Properties)
 
@@ -4325,12 +4328,13 @@ Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01
             ('round', ("D",), {}),
             ('floor', ("D",), {}),
             ('ceil', ("D",), {}),
+            ('asfreq', ("D",), {}),
             # ('tz_localize', ("UTC",), {}),
         ]
         _special_func_names = [f[0] for f in special_func_defs]
 
         # the series is already localized
-        _ignore_names = ['tz_localize']
+        _ignore_names = ['tz_localize', 'components']
 
         for name, attr_names, s, c in test_data:
             func_names = [f
@@ -4352,7 +4356,7 @@ Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01
                 elif isinstance(res, pd.Series):
                     tm.assert_series_equal(res, exp)
                 else:
-                    tm.assert_numpy_array_equal(res, exp)
+                    tm.assert_almost_equal(res, exp)
 
             for attr in attr_names:
                 try:
@@ -4367,7 +4371,7 @@ Categories (10, timedelta64[ns]): [0 days 01:00:00 < 1 days 01:00:00 < 2 days 01
             elif isinstance(res, pd.Series):
                 tm.assert_series_equal(res, exp)
             else:
-                tm.assert_numpy_array_equal(res, exp)
+                tm.assert_almost_equal(res, exp)
 
         invalid = Series([1, 2, 3]).astype('category')
         with tm.assertRaisesRegexp(
diff --git a/pandas/tseries/common.py b/pandas/tseries/common.py
index f9fd27176..7940efc7e 100644
--- a/pandas/tseries/common.py
+++ b/pandas/tseries/common.py
@@ -168,8 +168,7 @@ DatetimeProperties._add_delegate_accessors(
     typ='property')
 DatetimeProperties._add_delegate_accessors(
     delegate=DatetimeIndex,
-    accessors=["to_period", "tz_localize", "tz_convert",
-               "normalize", "strftime", "round", "floor", "ceil"],
+    accessors=DatetimeIndex._datetimelike_methods,
     typ='method')
 
 
@@ -208,7 +207,7 @@ TimedeltaProperties._add_delegate_accessors(
     typ='property')
 TimedeltaProperties._add_delegate_accessors(
     delegate=TimedeltaIndex,
-    accessors=["to_pytimedelta", "total_seconds", "round", "floor", "ceil"],
+    accessors=TimedeltaIndex._datetimelike_methods,
     typ='method')
 
 
@@ -230,9 +229,10 @@ PeriodProperties._add_delegate_accessors(
     delegate=PeriodIndex,
     accessors=PeriodIndex._datetimelike_ops,
     typ='property')
-PeriodProperties._add_delegate_accessors(delegate=PeriodIndex,
-                                         accessors=["strftime"],
-                                         typ='method')
+PeriodProperties._add_delegate_accessors(
+    delegate=PeriodIndex,
+    accessors=PeriodIndex._datetimelike_methods,
+    typ='method')
 
 
 class CombinedDatetimelikeProperties(DatetimeProperties, TimedeltaProperties):
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 11d2d2959..1992e1775 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -64,25 +64,26 @@ def _field_accessor(name, field, docstring=None):
             if self.tz is not utc:
                 values = self._local_timestamps()
 
-        # boolean accessors -> return array
-        if field in ['is_month_start', 'is_month_end',
-                     'is_quarter_start', 'is_quarter_end',
-                     'is_year_start', 'is_year_end']:
-            month_kw = (self.freq.kwds.get('startingMonth',
-                                           self.freq.kwds.get('month', 12))
-                        if self.freq else 12)
-
-            result = libts.get_start_end_field(values, field, self.freqstr,
-                                               month_kw)
-            return self._maybe_mask_results(result, convert='float64')
-        elif field in ['is_leap_year']:
-            # no need to mask NaT
-            return libts.get_date_field(values, field)
-
-        # non-boolean accessors -> return Index
-        elif field in ['weekday_name']:
+        if field in self._bool_ops:
+            if field in ['is_month_start', 'is_month_end',
+                         'is_quarter_start', 'is_quarter_end',
+                         'is_year_start', 'is_year_end']:
+                month_kw = (self.freq.kwds.get('startingMonth',
+                                               self.freq.kwds.get('month', 12))
+                            if self.freq else 12)
+
+                result = libts.get_start_end_field(values, field, self.freqstr,
+                                                   month_kw)
+            else:
+                result = libts.get_date_field(values, field)
+
+            # these return a boolean by-definition
+            return result
+
+        if field in self._object_ops:
             result = libts.get_date_name_field(values, field)
             result = self._maybe_mask_results(result)
+
         else:
             result = libts.get_date_field(values, field)
             result = self._maybe_mask_results(result, convert='float64')
@@ -232,14 +233,24 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
     offset = None
     _comparables = ['name', 'freqstr', 'tz']
     _attributes = ['name', 'freq', 'tz']
-    _datetimelike_ops = ['year', 'month', 'day', 'hour', 'minute', 'second',
-                         'weekofyear', 'week', 'dayofweek', 'weekday',
-                         'dayofyear', 'quarter', 'days_in_month',
-                         'daysinmonth', 'date', 'time', 'microsecond',
-                         'nanosecond', 'is_month_start', 'is_month_end',
-                         'is_quarter_start', 'is_quarter_end', 'is_year_start',
-                         'is_year_end', 'tz', 'freq', 'weekday_name',
-                         'is_leap_year']
+
+    # define my properties & methods for delegation
+    _bool_ops = ['is_month_start', 'is_month_end',
+                 'is_quarter_start', 'is_quarter_end', 'is_year_start',
+                 'is_year_end', 'is_leap_year']
+    _object_ops = ['weekday_name', 'freq', 'tz']
+    _field_ops = ['year', 'month', 'day', 'hour', 'minute', 'second',
+                  'weekofyear', 'week', 'weekday', 'dayofweek',
+                  'dayofyear', 'quarter', 'days_in_month',
+                  'daysinmonth', 'microsecond',
+                  'nanosecond']
+    _other_ops = ['date', 'time']
+    _datetimelike_ops = _field_ops + _object_ops + _bool_ops + _other_ops
+    _datetimelike_methods = ['to_period', 'tz_localize',
+                             'tz_convert',
+                             'normalize', 'strftime', 'round', 'floor',
+                             'ceil']
+
     _is_numeric_dtype = False
     _infer_as_myclass = True
 
diff --git a/pandas/tseries/period.py b/pandas/tseries/period.py
index c279d5a93..1e1496bbe 100644
--- a/pandas/tseries/period.py
+++ b/pandas/tseries/period.py
@@ -174,12 +174,18 @@ class PeriodIndex(DatelikeOps, DatetimeIndexOpsMixin, Int64Index):
     _box_scalars = True
     _typ = 'periodindex'
     _attributes = ['name', 'freq']
-    _datetimelike_ops = ['year', 'month', 'day', 'hour', 'minute', 'second',
-                         'weekofyear', 'week', 'dayofweek', 'weekday',
-                         'dayofyear', 'quarter', 'qyear', 'freq',
-                         'days_in_month', 'daysinmonth',
-                         'to_timestamp', 'asfreq', 'start_time', 'end_time',
-                         'is_leap_year']
+
+    # define my properties & methods for delegation
+    _other_ops = []
+    _bool_ops = ['is_leap_year']
+    _object_ops = ['start_time', 'end_time', 'freq']
+    _field_ops = ['year', 'month', 'day', 'hour', 'minute', 'second',
+                  'weekofyear', 'weekday', 'week', 'dayofweek',
+                  'dayofyear', 'quarter', 'qyear',
+                  'days_in_month', 'daysinmonth']
+    _datetimelike_ops = _field_ops + _object_ops + _bool_ops
+    _datetimelike_methods = ['strftime', 'to_timestamp', 'asfreq']
+
     _is_numeric_dtype = False
     _infer_as_myclass = True
 
diff --git a/pandas/tseries/tdi.py b/pandas/tseries/tdi.py
index 553338906..5d062dd38 100644
--- a/pandas/tseries/tdi.py
+++ b/pandas/tseries/tdi.py
@@ -127,8 +127,15 @@ class TimedeltaIndex(DatetimeIndexOpsMixin, TimelikeOps, Int64Index):
     _left_indexer_unique = _join_i8_wrapper(
         libjoin.left_join_indexer_unique_int64, with_indexers=False)
     _arrmap = None
-    _datetimelike_ops = ['days', 'seconds', 'microseconds', 'nanoseconds',
-                         'freq', 'components']
+
+    # define my properties & methods for delegation
+    _other_ops = []
+    _bool_ops = []
+    _object_ops = ['freq']
+    _field_ops = ['days', 'seconds', 'microseconds', 'nanoseconds']
+    _datetimelike_ops = _field_ops + _object_ops + _bool_ops
+    _datetimelike_methods = ["to_pytimedelta", "total_seconds",
+                             "round", "floor", "ceil"]
 
     __eq__ = _td_index_cmp('__eq__')
     __ne__ = _td_index_cmp('__ne__', nat_result=True)

commit 9f20c6628c96e66784f7eb302a284bfbd4c3e34d
Author: Jeff Reback <jeff@reback.net>
Date:   Thu Aug 27 22:46:46 2015 -0400

    Revert "Merge pull request #10727 from jorisvandenbossche/sphinx-traceback"
    
    This reverts commit d40627398cf78347f5a49fa060bad1c40514908a, reversing
    changes made to bd804aa75ac9b7a55c00101dbea01571cbdfd068.

diff --git a/doc/source/advanced.rst b/doc/source/advanced.rst
index 1888345e1..850f59c27 100644
--- a/doc/source/advanced.rst
+++ b/doc/source/advanced.rst
@@ -661,14 +661,18 @@ values NOT in the categories, similarly to how you can reindex ANY pandas index.
    Reshaping and Comparision operations on a ``CategoricalIndex`` must have the same categories
    or a ``TypeError`` will be raised.
 
-   .. ipython:: python
-      :okexcept:
+   .. code-block:: python
+
+      In [9]: df3 = pd.DataFrame({'A' : np.arange(6),
+                                  'B' : pd.Series(list('aabbca')).astype('category')})
+
+      In [11]: df3 = df3.set_index('B')
+
+      In [11]: df3.index
+      Out[11]: CategoricalIndex([u'a', u'a', u'b', u'b', u'c', u'a'], categories=[u'a', u'b', u'c'], ordered=False, name=u'B', dtype='category')
 
-      df3 = pd.DataFrame({'A' : np.arange(6),
-                          'B' : pd.Series(list('aabbca')).astype('category')})
-      df3 = df3.set_index('B')
-      df3.index
-      pd.concat([df2, df3]
+      In [12]: pd.concat([df2, df3]
+      TypeError: categories must match existing categories when appending
 
 .. _indexing.float64index:
 
@@ -734,18 +738,20 @@ In float indexes, slicing using floats is allowed
 
 In non-float indexes, slicing using floats will raise a ``TypeError``
 
-.. ipython:: python
-   :okexcept:
+.. code-block:: python
+
+   In [1]: pd.Series(range(5))[3.5]
+   TypeError: the label [3.5] is not a proper indexer for this index type (Int64Index)
 
-   pd.Series(range(5))[3.5]
-   pd.Series(range(5))[3.5:4.5]
+   In [1]: pd.Series(range(5))[3.5:4.5]
+   TypeError: the slice start [3.5] is not a proper indexer for this index type (Int64Index)
 
 Using a scalar float indexer will be deprecated in a future version, but is allowed for now.
 
-.. ipython:: python
-   :okwarning:
+.. code-block:: python
 
-   pd.Series(range(5))[3.0]
+   In [3]: pd.Series(range(5))[3.0]
+   Out[3]: 3
 
 Here is a typical use-case for using this type of indexing. Imagine that you have a somewhat
 irregular timedelta-like indexing scheme, but the data is recorded as floats. This could for
diff --git a/doc/source/basics.rst b/doc/source/basics.rst
index 6bfbfb87f..956c90ae6 100644
--- a/doc/source/basics.rst
+++ b/doc/source/basics.rst
@@ -352,11 +352,13 @@ objects of the same length:
 Trying to compare ``Index`` or ``Series`` objects of different lengths will
 raise a ValueError:
 
-.. ipython:: python
-    :okexcept:
+.. code-block:: python
+
+    In [55]: pd.Series(['foo', 'bar', 'baz']) == pd.Series(['foo', 'bar'])
+    ValueError: Series lengths must match to compare
 
-    pd.Series(['foo', 'bar', 'baz']) == pd.Series(['foo', 'bar'])
-    pd.Series(['foo', 'bar', 'baz']) == pd.Series(['foo'])
+    In [56]: pd.Series(['foo', 'bar', 'baz']) == pd.Series(['foo'])
+    ValueError: Series lengths must match to compare
 
 Note that this is different from the numpy behavior where a comparison can
 be broadcast:
diff --git a/doc/source/dsintro.rst b/doc/source/dsintro.rst
index 847044c47..5a62e7dcc 100644
--- a/doc/source/dsintro.rst
+++ b/doc/source/dsintro.rst
@@ -143,10 +143,10 @@ label:
 
 If a label is not contained, an exception is raised:
 
-.. ipython:: python
-    :okexcept:
+.. code-block:: python
 
-    s['f']
+    >>> s['f']
+    KeyError: 'f'
 
 Using the ``get`` method, a missing label will return None or specified default:
 
diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index a49a4745f..38629ee7b 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -293,10 +293,10 @@ Selection By Label
      dfl = pd.DataFrame(np.random.randn(5,4), columns=list('ABCD'), index=pd.date_range('20130101',periods=5))
      dfl
 
-  .. ipython:: python
-     :okexcept:
+  .. code-block:: python
 
-     dfl.loc[2:3]
+     In [4]: dfl.loc[2:3]
+     TypeError: cannot do slice indexing on <class 'pandas.tseries.index.DatetimeIndex'> with these indexers [2] of <type 'int'>
 
   String likes in slicing *can* be convertible to the type of the index and lead to natural slicing.
 
@@ -475,11 +475,13 @@ A single indexer that is out of bounds will raise an ``IndexError``.
 A list of indexers where any element is out of bounds will raise an
 ``IndexError``
 
-.. ipython:: python
-   :okexcept:
+.. code-block:: python
 
    dfl.iloc[[4,5,6]]
+   IndexError: positional indexers are out-of-bounds
+
    dfl.iloc[:,4]
+   IndexError: single positional indexer is out-of-bounds
 
 .. _indexing.basics.partial_setting:
 
diff --git a/doc/source/options.rst b/doc/source/options.rst
index 834b4b642..26871a114 100644
--- a/doc/source/options.rst
+++ b/doc/source/options.rst
@@ -57,7 +57,11 @@ The following will **not work** because it matches multiple option names, e.g.
 .. ipython:: python
    :okexcept:
 
-   pd.get_option("column")
+   try:
+       pd.get_option("column")
+   except KeyError as e:
+       print(e)
+
 
 **Note:** Using this form of shorthand may cause your code to break if new options with similar names are added in future versions.
 
diff --git a/doc/source/timeseries.rst b/doc/source/timeseries.rst
index a2067b9a3..6f30ff3f5 100644
--- a/doc/source/timeseries.rst
+++ b/doc/source/timeseries.rst
@@ -205,9 +205,9 @@ Invalid Data
 Pass ``errors='coerce'`` to convert invalid data to ``NaT`` (not a time):
 
 .. ipython:: python
+   :okexcept:
 
    # this is the default, raise when unparseable
-   @okexcept
    to_datetime(['2009/07/31', 'asd'], errors='raise')
 
    # return the original input when unparseable
@@ -656,7 +656,7 @@ apply the offset to each element.
    rng + DateOffset(months=2)
    s + DateOffset(months=2)
    s - DateOffset(months=2)
-
+   
 If the offset class maps directly to a ``Timedelta`` (``Day``, ``Hour``,
 ``Minute``, ``Second``, ``Micro``, ``Milli``, ``Nano``) it can be
 used exactly like a ``Timedelta`` - see the
@@ -670,7 +670,7 @@ used exactly like a ``Timedelta`` - see the
    td + Minute(15)
 
 Note that some offsets (such as ``BQuarterEnd``) do not have a
-vectorized implementation.  They can still be used but may
+vectorized implementation.  They can still be used but may 
 calculate signficantly slower and will raise a ``PerformanceWarning``
 
 .. ipython:: python
@@ -1702,13 +1702,13 @@ the top example will fail as it contains ambiguous times and the bottom will
 infer the right offset.
 
 .. ipython:: python
+   :okexcept:
 
    rng_hourly = DatetimeIndex(['11/06/2011 00:00', '11/06/2011 01:00',
                                '11/06/2011 01:00', '11/06/2011 02:00',
                                '11/06/2011 03:00'])
 
    # This will fail as there are ambiguous times
-   @okexcept
    rng_hourly.tz_localize('US/Eastern')
    rng_hourly_eastern = rng_hourly.tz_localize('US/Eastern', ambiguous='infer')
    rng_hourly_eastern.tolist()
diff --git a/doc/sphinxext/ipython_sphinxext/ipython_directive.py b/doc/sphinxext/ipython_sphinxext/ipython_directive.py
index 04a9e804f..ad7ada8e4 100644
--- a/doc/sphinxext/ipython_sphinxext/ipython_directive.py
+++ b/doc/sphinxext/ipython_sphinxext/ipython_directive.py
@@ -465,6 +465,10 @@ class EmbeddedSphinxShell(object):
 
         self.cout.seek(0)
         output = self.cout.read()
+        if not is_suppress and not is_semicolon:
+            ret.append(output)
+        elif is_semicolon: # get spacing right
+            ret.append('')
 
         # context information
         filename = self.state.document.current_source
@@ -494,16 +498,6 @@ class EmbeddedSphinxShell(object):
                 sys.stdout.write(s)
                 sys.stdout.write('<<<' + ('-' * 73) + '\n')
 
-        # if :okexcept: has been specified, display shorter traceback
-        if is_okexcept and "Traceback" in output:
-            traceback = output.split('\n\n')
-            output = traceback[-1]
-
-        if not is_suppress and not is_semicolon:
-            ret.append(output)
-        elif is_semicolon: # get spacing right
-            ret.append('')
-
         self.cout.truncate(0)
         return (ret, input_lines, output, is_doctest, decorator, image_file,
                     image_directive)

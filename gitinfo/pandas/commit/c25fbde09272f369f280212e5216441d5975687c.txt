commit c25fbde09272f369f280212e5216441d5975687c
Author: Jeff Reback <jeff@reback.net>
Date:   Fri Apr 7 15:09:09 2017 -0400

    DEPR: Panel deprecated
    
    closes #13563
    on top of #15677
    
    Author: Jeff Reback <jeff@reback.net>
    
    Closes #15601 from jreback/panel and squashes the following commits:
    
    04104a7 [Jeff Reback] fine grained catching warnings in tests
    f8800dc [Jeff Reback] add numpy reference for searchsorted
    fa136dd [Jeff Reback] doc correction
    c39453a [Jeff Reback] add perf optimization in searchsorted for FrozenNDArray
    0e9c4a4 [Jeff Reback] fix docs as per review & column name changes
    3df0abe [Jeff Reback] remove Panel from doc-strings, catch internal warning on Panel construction
    755606d [Jeff Reback] more docs
    d04db2e [Jeff Reback] add deprecate_panel section to docs
    538b8e8 [Jeff Reback] pep fix
    912d523 [Jeff Reback] TST: separate out test_append_to_multiple_dropna to two tests; when drop=False this is sometimes failing
    a2625ba [Jeff Reback] remove most Term references in test_pytables.py
    cd5b6b8 [Jeff Reback] DEPR: Panel deprecated
    6b20ddc [Jeff Reback] fix names on return structure
    f41d3df [Jeff Reback] API: df.rolling(..).corr()/cov() when pairwise=True to return MI DataFrame
    84e788b [Jeff Reback] BUG/PERF: handle a slice correctly in get_level_indexer

diff --git a/doc/source/computation.rst b/doc/source/computation.rst
index 57480a244..2423f1a34 100644
--- a/doc/source/computation.rst
+++ b/doc/source/computation.rst
@@ -505,13 +505,18 @@ two ``Series`` or any combination of ``DataFrame/Series`` or
 - ``DataFrame/DataFrame``: by default compute the statistic for matching column
   names, returning a DataFrame. If the keyword argument ``pairwise=True`` is
   passed then computes the statistic for each pair of columns, returning a
-  ``Panel`` whose ``items`` are the dates in question (see :ref:`the next section
+  ``MultiIndexed DataFrame`` whose ``index`` are the dates in question (see :ref:`the next section
   <stats.moments.corr_pairwise>`).
 
 For example:
 
 .. ipython:: python
 
+   df = pd.DataFrame(np.random.randn(1000, 4),
+                     index=pd.date_range('1/1/2000', periods=1000),
+                     columns=['A', 'B', 'C', 'D'])
+   df = df.cumsum()
+
    df2 = df[:20]
    df2.rolling(window=5).corr(df2['B'])
 
@@ -520,11 +525,16 @@ For example:
 Computing rolling pairwise covariances and correlations
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
+.. warning::
+
+   Prior to version 0.20.0 if ``pairwise=True`` was passed, a ``Panel`` would be returned.
+   This will now return a 2-level MultiIndexed DataFrame, see the whatsnew :ref:`here <whatsnew_0200.api_breaking.rolling_pairwise>`
+
 In financial data analysis and other fields it's common to compute covariance
 and correlation matrices for a collection of time series. Often one is also
 interested in moving-window covariance and correlation matrices. This can be
 done by passing the ``pairwise`` keyword argument, which in the case of
-``DataFrame`` inputs will yield a ``Panel`` whose ``items`` are the dates in
+``DataFrame`` inputs will yield a MultiIndexed ``DataFrame`` whose ``index`` are the dates in
 question. In the case of a single DataFrame argument the ``pairwise`` argument
 can even be omitted:
 
@@ -539,12 +549,12 @@ can even be omitted:
 .. ipython:: python
 
    covs = df[['B','C','D']].rolling(window=50).cov(df[['A','B','C']], pairwise=True)
-   covs[df.index[-50]]
+   covs.loc['2002-09-22':]
 
 .. ipython:: python
 
    correls = df.rolling(window=50).corr()
-   correls[df.index[-50]]
+   correls.loc['2002-09-22':]
 
 You can efficiently retrieve the time series of correlations between two
 columns using ``.loc`` indexing:
@@ -557,7 +567,7 @@ columns using ``.loc`` indexing:
 .. ipython:: python
 
    @savefig rolling_corr_pairwise_ex.png
-   correls.loc[:, 'A', 'C'].plot()
+   correls.loc[:, ('A', 'C')].plot()
 
 .. _stats.aggregate:
 
diff --git a/doc/source/dsintro.rst b/doc/source/dsintro.rst
index 4fcb63c18..2b11b23b1 100644
--- a/doc/source/dsintro.rst
+++ b/doc/source/dsintro.rst
@@ -763,6 +763,11 @@ completion mechanism so they can be tab-completed:
 Panel
 -----
 
+.. warning::
+
+    In 0.20.0, ``Panel`` is deprecated and will be removed in
+    a future version. See the section :ref:`Deprecate Panel <dsintro.deprecate_panel>`.
+
 Panel is a somewhat less-used, but still important container for 3-dimensional
 data. The term `panel data <http://en.wikipedia.org/wiki/Panel_data>`__ is
 derived from econometrics and is partially responsible for the name pandas:
@@ -783,6 +788,7 @@ From 3D ndarray with optional axis labels
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 .. ipython:: python
+   :okwarning:
 
    wp = pd.Panel(np.random.randn(2, 5, 4), items=['Item1', 'Item2'],
                  major_axis=pd.date_range('1/1/2000', periods=5),
@@ -794,6 +800,7 @@ From dict of DataFrame objects
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 .. ipython:: python
+   :okwarning:
 
    data = {'Item1' : pd.DataFrame(np.random.randn(4, 3)),
            'Item2' : pd.DataFrame(np.random.randn(4, 2))}
@@ -816,6 +823,7 @@ dictionary of DataFrames as above, and the following named parameters:
 For example, compare to the construction above:
 
 .. ipython:: python
+   :okwarning:
 
    pd.Panel.from_dict(data, orient='minor')
 
@@ -824,6 +832,7 @@ DataFrame objects with mixed-type columns, all of the data will get upcasted to
 ``dtype=object`` unless you pass ``orient='minor'``:
 
 .. ipython:: python
+   :okwarning:
 
    df = pd.DataFrame({'a': ['foo', 'bar', 'baz'],
                       'b': np.random.randn(3)})
@@ -851,6 +860,7 @@ This method was introduced in v0.7 to replace ``LongPanel.to_long``, and convert
 a DataFrame with a two-level index to a Panel.
 
 .. ipython:: python
+   :okwarning:
 
    midx = pd.MultiIndex(levels=[['one', 'two'], ['x','y']], labels=[[1,1,0,0],[1,0,1,0]])
    df = pd.DataFrame({'A' : [1, 2, 3, 4], 'B': [5, 6, 7, 8]}, index=midx)
@@ -880,6 +890,7 @@ A Panel can be rearranged using its ``transpose`` method (which does not make a
 copy by default unless the data are heterogeneous):
 
 .. ipython:: python
+   :okwarning:
 
    wp.transpose(2, 0, 1)
 
@@ -909,6 +920,7 @@ Squeezing
 Another way to change the dimensionality of an object is to ``squeeze`` a 1-len object, similar to ``wp['Item1']``
 
 .. ipython:: python
+   :okwarning:
 
    wp.reindex(items=['Item1']).squeeze()
    wp.reindex(items=['Item1'], minor=['B']).squeeze()
@@ -923,12 +935,55 @@ for more on this. To convert a Panel to a DataFrame, use the ``to_frame``
 method:
 
 .. ipython:: python
+   :okwarning:
 
    panel = pd.Panel(np.random.randn(3, 5, 4), items=['one', 'two', 'three'],
                     major_axis=pd.date_range('1/1/2000', periods=5),
                     minor_axis=['a', 'b', 'c', 'd'])
    panel.to_frame()
 
+
+.. _dsintro.deprecate_panel:
+
+Deprecate Panel
+---------------
+
+Over the last few years, pandas has increased in both breadth and depth, with new features,
+datatype support, and manipulation routines. As a result, supporting efficient indexing and functional
+routines for ``Series``, ``DataFrame`` and ``Panel`` has contributed to an increasingly fragmented and
+difficult-to-understand codebase.
+
+The 3-d structure of a ``Panel`` is much less common for many types of data analysis,
+than the 1-d of the ``Series`` or the 2-D of the ``DataFrame``. Going forward it makes sense for
+pandas to focus on these areas exclusively.
+
+Oftentimes, one can simply use a MultiIndex ``DataFrame`` for easily working with higher dimensional data.
+
+In additon, the ``xarray`` package was built from the ground up, specifically in order to
+support the multi-dimensional analysis that is one of ``Panel`` s main usecases.
+`Here is a link to the xarray panel-transition documentation <http://xarray.pydata.org/en/stable/pandas.html#panel-transition>`__.
+
+.. ipython:: python
+   :okwarning:
+
+   p = tm.makePanel()
+   p
+
+Convert to a MultiIndex DataFrame
+
+.. ipython:: python
+   :okwarning:
+
+   p.to_frame()
+
+Alternatively, one can convert to an xarray ``DataArray``.
+
+.. ipython:: python
+
+   p.to_xarray()
+
+You can see the full-documentation for the `xarray package <http://xarray.pydata.org/en/stable/>`__.
+
 .. _dsintro.panelnd:
 .. _dsintro.panel4d:
 
diff --git a/doc/source/whatsnew/v0.20.0.txt b/doc/source/whatsnew/v0.20.0.txt
index 31b0efa14..132f20cb7 100644
--- a/doc/source/whatsnew/v0.20.0.txt
+++ b/doc/source/whatsnew/v0.20.0.txt
@@ -10,13 +10,16 @@ users upgrade to this version.
 Highlights include:
 
 - The ``.ix`` indexer has been deprecated, see :ref:`here <whatsnew_0200.api_breaking.deprecate_ix>`
+- ``Panel`` has been deprecated, see :ref:`here <whatsnew_0200.api_breaking.deprecate_panel>`
 - Improved user API when accessing levels in ``.groupby()``, see :ref:`here <whatsnew_0200.enhancements.groupby_access>`
 - Improved support for UInt64 dtypes, see :ref:`here <whatsnew_0200.enhancements.uint64_support>`
 - A new orient for JSON serialization, ``orient='table'``, that uses the Table Schema spec, see :ref:`here <whatsnew_0200.enhancements.table_schema>`
+- Window Binary Corr/Cov operations return a MultiIndexed ``DataFrame`` rather than a ``Panel``, as ``Panel`` is now deprecated, see :ref:`here <whatsnew_0200.api_breaking.rolling_pairwise>`
 - Support for S3 handling now uses ``s3fs``, see :ref:`here <whatsnew_0200.api_breaking.s3>`
 - Google BigQuery support now uses the ``pandas-gbq`` library, see :ref:`here <whatsnew_0200.api_breaking.gbq>`
 - Switched the test framework to use `pytest <http://doc.pytest.org/en/latest>`__ (:issue:`13097`)
 
+
 Check the :ref:`API Changes <whatsnew_0200.api_breaking>` and :ref:`deprecations <whatsnew_0200.deprecations>` before updating.
 
 .. contents:: What's new in v0.20.0
@@ -425,6 +428,33 @@ Using ``.iloc``. Here we will get the location of the 'A' column, then use *posi
   df.iloc[[0, 2], df.columns.get_loc('A')]
 
 
+.. _whatsnew_0200.api_breaking.deprecate_panel:
+
+Deprecate Panel
+^^^^^^^^^^^^^^^
+
+``Panel`` is deprecated and will be removed in a future version. The recommended way to represent 3-D data are
+with a ``MultiIndex``on a ``DataFrame`` via the :meth:`~Panel.to_frame` or with the `xarray package <http://xarray.pydata.org/en/stable/>`__. Pandas
+provides a :meth:`~Panel.to_xarray` method to automate this conversion. See the documentation :ref:`Deprecate Panel <dsintro.deprecate_panel>`. (:issue:`13563`).
+
+.. ipython:: python
+   :okwarning:
+
+   p = tm.makePanel()
+   p
+
+Convert to a MultiIndex DataFrame
+
+.. ipython:: python
+
+   p.to_frame()
+
+Convert to an xarray DataArray
+
+.. ipython:: python
+
+   p.to_xarray()
+
 .. _whatsnew.api_breaking.io_compat:
 
 Possible incompat for HDF5 formats for pandas < 0.13.0
@@ -836,6 +866,51 @@ New Behavior:
 
    df.groupby('A').agg([np.mean, np.std, np.min, np.max])
 
+.. _whatsnew_0200.api_breaking.rolling_pairwise:
+
+Window Binary Corr/Cov operations return a MultiIndex DataFrame
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+A binary window operation, like ``.corr()`` or ``.cov()``, when operating on a ``.rolling(..)``, ``.expanding(..)``, or ``.ewm(..)`` object,
+will now return a 2-level ``MultiIndexed DataFrame`` rather than a ``Panel``, as ``Panel`` is now deprecated,
+see :ref:`here <_whatsnew_0200.api_breaking.deprecate_panel>`. These are equivalent in function,
+but MultiIndexed ``DataFrame`` s enjoy more support in pandas.
+See the section on :ref:`Windowed Binary Operations <stats.moments.binary>` for more information. (:issue:`15677`)
+
+.. ipython:: python
+
+   np.random.seed(1234)
+   df = pd.DataFrame(np.random.rand(100, 2),
+                     columns=pd.Index(['A', 'B'], name='bar'),
+                     index=pd.date_range('20160101',
+                                         periods=100, freq='D', name='foo'))
+   df.tail()
+
+Old Behavior:
+
+.. code-block:: ipython
+
+   In [2]: df.rolling(12).corr()
+   Out[2]:
+   <class 'pandas.core.panel.Panel'>
+   Dimensions: 100 (items) x 2 (major_axis) x 2 (minor_axis)
+   Items axis: 2016-01-01 00:00:00 to 2016-04-09 00:00:00
+   Major_axis axis: A to B
+   Minor_axis axis: A to B
+
+New Behavior:
+
+.. ipython:: python
+
+   res = df.rolling(12).corr()
+   res.tail()
+
+Retrieving a correlation matrix for a cross-section
+
+.. ipython:: python
+
+   df.rolling(12).corr().loc['2016-04-07']
+
 .. _whatsnew_0200.api_breaking.hdfstore_where:
 
 HDFStore where string comparison
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 9e95023cc..24f4d219f 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -4,10 +4,8 @@ Contains data structures designed for manipulating panel (3-dimensional) data
 # pylint: disable=E1103,W0231,W0212,W0621
 from __future__ import division
 
-import warnings
-
 import numpy as np
-
+import warnings
 from pandas.types.cast import (infer_dtype_from_scalar,
                                maybe_cast_item)
 from pandas.types.common import (is_integer, is_list_like,
@@ -132,6 +130,18 @@ class Panel(NDFrame):
 
     def __init__(self, data=None, items=None, major_axis=None, minor_axis=None,
                  copy=False, dtype=None):
+        # deprecation GH13563
+        warnings.warn("\nPanel is deprecated and will be removed in a "
+                      "future version.\nThe recommended way to represent "
+                      "these types of 3-dimensional data are with a "
+                      "MultiIndex on a DataFrame, via the "
+                      "Panel.to_frame() method\n"
+                      "Alternatively, you can use the xarray package "
+                      "http://xarray.pydata.org/en/stable/.\n"
+                      "Pandas provides a `.to_xarray()` method to help "
+                      "automate this conversion.\n",
+                      DeprecationWarning, stacklevel=3)
+
         self._init_data(data=data, items=items, major_axis=major_axis,
                         minor_axis=minor_axis, copy=copy, dtype=dtype)
 
diff --git a/pandas/core/window.py b/pandas/core/window.py
index 9c9f86145..89d2f5b24 100644
--- a/pandas/core/window.py
+++ b/pandas/core/window.py
@@ -927,8 +927,9 @@ class _Rolling_and_Expanding(_Rolling):
         If False then only matching columns between self and other will be used
         and the output will be a DataFrame.
         If True then all pairwise combinations will be calculated and the
-        output will be a Panel in the case of DataFrame inputs. In the case of
-        missing elements, only complete pairwise observations will be used.
+        output will be a MultiIndexed DataFrame in the case of DataFrame
+        inputs. In the case of missing elements, only complete pairwise
+        observations will be used.
     ddof : int, default 1
         Delta Degrees of Freedom.  The divisor used in calculations
         is ``N - ddof``, where ``N`` represents the number of elements.""")
@@ -964,11 +965,12 @@ class _Rolling_and_Expanding(_Rolling):
     other : Series, DataFrame, or ndarray, optional
         if not supplied then will default to self and produce pairwise output
     pairwise : bool, default None
-        If False then only matching columns between self and other will be used
-        and the output will be a DataFrame.
+        If False then only matching columns between self and other will be
+        used and the output will be a DataFrame.
         If True then all pairwise combinations will be calculated and the
-        output will be a Panel in the case of DataFrame inputs. In the case of
-        missing elements, only complete pairwise observations will be used.""")
+        output will be a MultiIndex DataFrame in the case of DataFrame inputs.
+        In the case of missing elements, only complete pairwise observations
+        will be used.""")
 
     def corr(self, other=None, pairwise=None, **kwargs):
         if other is None:
@@ -1397,8 +1399,9 @@ pairwise : bool, default None
     If False then only matching columns between self and other will be used and
     the output will be a DataFrame.
     If True then all pairwise combinations will be calculated and the output
-    will be a Panel in the case of DataFrame inputs. In the case of missing
-    elements, only complete pairwise observations will be used.
+    will be a MultiIndex DataFrame in the case of DataFrame inputs.
+    In the case of missing elements, only complete pairwise observations will
+    be used.
 bias : boolean, default False
    Use a standard estimation bias correction
 """
@@ -1652,7 +1655,8 @@ class EWM(_Rolling):
 
 
 def _flex_binary_moment(arg1, arg2, f, pairwise=False):
-    from pandas import Series, DataFrame, Panel
+    from pandas import Series, DataFrame
+
     if not (isinstance(arg1, (np.ndarray, Series, DataFrame)) and
             isinstance(arg2, (np.ndarray, Series, DataFrame))):
         raise TypeError("arguments to moment function must be of type "
@@ -1684,10 +1688,13 @@ def _flex_binary_moment(arg1, arg2, f, pairwise=False):
                         raise ValueError("'arg1' columns are not unique")
                     if not arg2.columns.is_unique:
                         raise ValueError("'arg2' columns are not unique")
-                    X, Y = arg1.align(arg2, join='outer')
+                    with warnings.catch_warnings(record=True):
+                        X, Y = arg1.align(arg2, join='outer')
                     X = X + 0 * Y
                     Y = Y + 0 * X
-                    res_columns = arg1.columns.union(arg2.columns)
+
+                    with warnings.catch_warnings(record=True):
+                        res_columns = arg1.columns.union(arg2.columns)
                     for col in res_columns:
                         if col in X and col in Y:
                             results[col] = f(X[col], Y[col])
@@ -1703,12 +1710,39 @@ def _flex_binary_moment(arg1, arg2, f, pairwise=False):
                         else:
                             results[i][j] = f(*_prep_binary(arg1.iloc[:, i],
                                                             arg2.iloc[:, j]))
-                p = Panel.from_dict(results).swapaxes('items', 'major')
-                if len(p.major_axis) > 0:
-                    p.major_axis = arg1.columns[p.major_axis]
-                if len(p.minor_axis) > 0:
-                    p.minor_axis = arg2.columns[p.minor_axis]
-                return p
+
+                # TODO: not the most efficient (perf-wise)
+                # though not bad code-wise
+                from pandas import Panel, MultiIndex, Index
+                with warnings.catch_warnings(record=True):
+                    p = Panel.from_dict(results).swapaxes('items', 'major')
+                    if len(p.major_axis) > 0:
+                        p.major_axis = arg1.columns[p.major_axis]
+                    if len(p.minor_axis) > 0:
+                        p.minor_axis = arg2.columns[p.minor_axis]
+
+                if len(p.items):
+                    result = pd.concat(
+                        [p.iloc[i].T for i in range(len(p.items))],
+                        keys=p.items)
+                else:
+
+                    result = DataFrame(
+                        index=MultiIndex(levels=[arg1.index, arg1.columns],
+                                         labels=[[], []]),
+                        columns=arg2.columns,
+                        dtype='float64')
+
+                # reset our index names to arg1 names
+                # reset our column names to arg2 names
+                # careful not to mutate the original names
+                result.columns = Index(result.columns).set_names(
+                    arg2.columns.name)
+                result.index = result.index.set_names(
+                    [arg1.index.name, arg1.columns.name])
+
+                return result
+
             else:
                 raise ValueError("'pairwise' is not True/False")
         else:
diff --git a/pandas/indexes/frozen.py b/pandas/indexes/frozen.py
index 97a1a3ea9..ab1228c00 100644
--- a/pandas/indexes/frozen.py
+++ b/pandas/indexes/frozen.py
@@ -117,6 +117,30 @@ class FrozenNDArray(PandasObject, np.ndarray):
                              quote_strings=True)
         return "%s(%s, dtype='%s')" % (type(self).__name__, prepr, self.dtype)
 
+    def searchsorted(self, v, side='left', sorter=None):
+        """
+        Find indices where elements of v should be inserted
+        in a to maintain order.
+
+        For full documentation, see `numpy.searchsorted`
+
+        See Also
+        --------
+        numpy.searchsorted : equivalent function
+        """
+
+        # we are much more performant if the searched
+        # indexer is the same type as the array
+        # this doesn't matter for int64, but DOES
+        # matter for smaller int dtypes
+        # https://github.com/numpy/numpy/issues/5370
+        try:
+            v = self.dtype.type(v)
+        except:
+            pass
+        return super(FrozenNDArray, self).searchsorted(
+            v, side=side, sorter=sorter)
+
 
 def _ensure_frozen(array_like, categories, copy=False):
     array_like = coerce_indexer_dtype(array_like, categories)
diff --git a/pandas/indexes/multi.py b/pandas/indexes/multi.py
index 96e0effbd..77774f328 100644
--- a/pandas/indexes/multi.py
+++ b/pandas/indexes/multi.py
@@ -2203,20 +2203,14 @@ class MultiIndex(Index):
         else:
 
             loc = level_index.get_loc(key)
-            if level > 0 or self.lexsort_depth == 0:
+            if isinstance(loc, slice):
+                return loc
+            elif level > 0 or self.lexsort_depth == 0:
                 return np.array(labels == loc, dtype=bool)
-            else:
-                # sorted, so can return slice object -> view
-                try:
-                    loc = labels.dtype.type(loc)
-                except TypeError:
-                    # this occurs when loc is a slice (partial string indexing)
-                    # but the TypeError raised by searchsorted in this case
-                    # is catched in Index._has_valid_type()
-                    pass
-                i = labels.searchsorted(loc, side='left')
-                j = labels.searchsorted(loc, side='right')
-                return slice(i, j)
+
+            i = labels.searchsorted(loc, side='left')
+            j = labels.searchsorted(loc, side='right')
+            return slice(i, j)
 
     def get_locs(self, tup):
         """
diff --git a/pandas/tests/io/test_pytables.py b/pandas/tests/io/test_pytables.py
index 82a98f5d0..9908a320a 100644
--- a/pandas/tests/io/test_pytables.py
+++ b/pandas/tests/io/test_pytables.py
@@ -1,9 +1,9 @@
 import pytest
 import sys
 import os
-from warnings import catch_warnings
 import tempfile
 from contextlib import contextmanager
+from warnings import catch_warnings
 
 import datetime
 from datetime import timedelta
@@ -11,7 +11,7 @@ import numpy as np
 
 import pandas
 import pandas as pd
-from pandas import (Series, DataFrame, Panel, MultiIndex, Int64Index,
+from pandas import (Series, DataFrame, Panel, Panel4D, MultiIndex, Int64Index,
                     RangeIndex, Categorical, bdate_range,
                     date_range, timedelta_range, Index, DatetimeIndex,
                     isnull)
@@ -22,8 +22,6 @@ from pandas.formats.printing import pprint_thing
 tables = pytest.importorskip('tables')
 from pandas.io.pytables import TableIterator
 from pandas.io.pytables import (HDFStore, get_store, Term, read_hdf,
-                                IncompatibilityWarning, PerformanceWarning,
-                                AttributeConflictWarning,
                                 PossibleDataLossError, ClosedFileError)
 
 from pandas.io import pytables as pytables
@@ -205,8 +203,10 @@ class TestHDFStore(Base, tm.TestCase):
             o = tm.makeDataFrame()
             assert_frame_equal(o, roundtrip('frame', o))
 
-            o = tm.makePanel()
-            assert_panel_equal(o, roundtrip('panel', o))
+            with catch_warnings(record=True):
+
+                o = tm.makePanel()
+                assert_panel_equal(o, roundtrip('panel', o))
 
             # table
             df = DataFrame(dict(A=lrange(5), B=lrange(5)))
@@ -368,8 +368,9 @@ class TestHDFStore(Base, tm.TestCase):
             store['a'] = tm.makeTimeSeries()
             store['b'] = tm.makeStringSeries()
             store['c'] = tm.makeDataFrame()
-            store['d'] = tm.makePanel()
-            store['foo/bar'] = tm.makePanel()
+            with catch_warnings(record=True):
+                store['d'] = tm.makePanel()
+                store['foo/bar'] = tm.makePanel()
             self.assertEqual(len(store), 5)
             expected = set(['/a', '/b', '/c', '/d', '/foo/bar'])
             self.assertTrue(set(store.keys()) == expected)
@@ -388,9 +389,11 @@ class TestHDFStore(Base, tm.TestCase):
             store['a'] = tm.makeTimeSeries()
             store['b'] = tm.makeStringSeries()
             store['c'] = tm.makeDataFrame()
-            store['d'] = tm.makePanel()
-            store['foo/bar'] = tm.makePanel()
-            store.append('e', tm.makePanel())
+
+            with catch_warnings(record=True):
+                store['d'] = tm.makePanel()
+                store['foo/bar'] = tm.makePanel()
+                store.append('e', tm.makePanel())
 
             df = tm.makeDataFrame()
             df['obj1'] = 'foo'
@@ -755,6 +758,7 @@ class TestHDFStore(Base, tm.TestCase):
         with ensure_clean_store(self.path) as store:
             _maybe_remove(store, 'df')
 
+            # PerformanceWarning
             with catch_warnings(record=True):
                 store.put('df', df)
 
@@ -764,39 +768,42 @@ class TestHDFStore(Base, tm.TestCase):
     def test_append(self):
 
         with ensure_clean_store(self.path) as store:
-            df = tm.makeTimeDataFrame()
-            _maybe_remove(store, 'df1')
-            store.append('df1', df[:10])
-            store.append('df1', df[10:])
-            tm.assert_frame_equal(store['df1'], df)
-
-            _maybe_remove(store, 'df2')
-            store.put('df2', df[:10], format='table')
-            store.append('df2', df[10:])
-            tm.assert_frame_equal(store['df2'], df)
-
-            _maybe_remove(store, 'df3')
-            store.append('/df3', df[:10])
-            store.append('/df3', df[10:])
-            tm.assert_frame_equal(store['df3'], df)
 
             # this is allowed by almost always don't want to do it
             # tables.NaturalNameWarning):
             with catch_warnings(record=True):
+
+                df = tm.makeTimeDataFrame()
+                _maybe_remove(store, 'df1')
+                store.append('df1', df[:10])
+                store.append('df1', df[10:])
+                tm.assert_frame_equal(store['df1'], df)
+
+                _maybe_remove(store, 'df2')
+                store.put('df2', df[:10], format='table')
+                store.append('df2', df[10:])
+                tm.assert_frame_equal(store['df2'], df)
+
+                _maybe_remove(store, 'df3')
+                store.append('/df3', df[:10])
+                store.append('/df3', df[10:])
+                tm.assert_frame_equal(store['df3'], df)
+
+                # this is allowed by almost always don't want to do it
+                # tables.NaturalNameWarning
                 _maybe_remove(store, '/df3 foo')
                 store.append('/df3 foo', df[:10])
                 store.append('/df3 foo', df[10:])
                 tm.assert_frame_equal(store['df3 foo'], df)
 
-            # panel
-            wp = tm.makePanel()
-            _maybe_remove(store, 'wp1')
-            store.append('wp1', wp.iloc[:, :10, :])
-            store.append('wp1', wp.iloc[:, 10:, :])
-            assert_panel_equal(store['wp1'], wp)
+                # panel
+                wp = tm.makePanel()
+                _maybe_remove(store, 'wp1')
+                store.append('wp1', wp.iloc[:, :10, :])
+                store.append('wp1', wp.iloc[:, 10:, :])
+                assert_panel_equal(store['wp1'], wp)
 
-            # ndim
-            with catch_warnings(record=True):
+                # ndim
                 p4d = tm.makePanel4D()
                 _maybe_remove(store, 'p4d')
                 store.append('p4d', p4d.iloc[:, :, :10, :])
@@ -820,42 +827,42 @@ class TestHDFStore(Base, tm.TestCase):
                     'p4d2', p4d2, axes=['items', 'major_axis', 'minor_axis'])
                 assert_panel4d_equal(store['p4d2'], p4d2)
 
-            # test using differt order of items on the non-index axes
-            _maybe_remove(store, 'wp1')
-            wp_append1 = wp.iloc[:, :10, :]
-            store.append('wp1', wp_append1)
-            wp_append2 = wp.iloc[:, 10:, :].reindex(items=wp.items[::-1])
-            store.append('wp1', wp_append2)
-            assert_panel_equal(store['wp1'], wp)
-
-            # dtype issues - mizxed type in a single object column
-            df = DataFrame(data=[[1, 2], [0, 1], [1, 2], [0, 0]])
-            df['mixed_column'] = 'testing'
-            df.loc[2, 'mixed_column'] = np.nan
-            _maybe_remove(store, 'df')
-            store.append('df', df)
-            tm.assert_frame_equal(store['df'], df)
-
-            # uints - test storage of uints
-            uint_data = DataFrame({
-                'u08': Series(np.random.randint(0, high=255, size=5),
-                              dtype=np.uint8),
-                'u16': Series(np.random.randint(0, high=65535, size=5),
-                              dtype=np.uint16),
-                'u32': Series(np.random.randint(0, high=2**30, size=5),
-                              dtype=np.uint32),
-                'u64': Series([2**58, 2**59, 2**60, 2**61, 2**62],
-                              dtype=np.uint64)}, index=np.arange(5))
-            _maybe_remove(store, 'uints')
-            store.append('uints', uint_data)
-            tm.assert_frame_equal(store['uints'], uint_data)
-
-            # uints - test storage of uints in indexable columns
-            _maybe_remove(store, 'uints')
-            # 64-bit indices not yet supported
-            store.append('uints', uint_data, data_columns=[
-                         'u08', 'u16', 'u32'])
-            tm.assert_frame_equal(store['uints'], uint_data)
+                # test using differt order of items on the non-index axes
+                _maybe_remove(store, 'wp1')
+                wp_append1 = wp.iloc[:, :10, :]
+                store.append('wp1', wp_append1)
+                wp_append2 = wp.iloc[:, 10:, :].reindex(items=wp.items[::-1])
+                store.append('wp1', wp_append2)
+                assert_panel_equal(store['wp1'], wp)
+
+                # dtype issues - mizxed type in a single object column
+                df = DataFrame(data=[[1, 2], [0, 1], [1, 2], [0, 0]])
+                df['mixed_column'] = 'testing'
+                df.loc[2, 'mixed_column'] = np.nan
+                _maybe_remove(store, 'df')
+                store.append('df', df)
+                tm.assert_frame_equal(store['df'], df)
+
+                # uints - test storage of uints
+                uint_data = DataFrame({
+                    'u08': Series(np.random.randint(0, high=255, size=5),
+                                  dtype=np.uint8),
+                    'u16': Series(np.random.randint(0, high=65535, size=5),
+                                  dtype=np.uint16),
+                    'u32': Series(np.random.randint(0, high=2**30, size=5),
+                                  dtype=np.uint32),
+                    'u64': Series([2**58, 2**59, 2**60, 2**61, 2**62],
+                                  dtype=np.uint64)}, index=np.arange(5))
+                _maybe_remove(store, 'uints')
+                store.append('uints', uint_data)
+                tm.assert_frame_equal(store['uints'], uint_data)
+
+                # uints - test storage of uints in indexable columns
+                _maybe_remove(store, 'uints')
+                # 64-bit indices not yet supported
+                store.append('uints', uint_data, data_columns=[
+                             'u08', 'u16', 'u32'])
+                tm.assert_frame_equal(store['uints'], uint_data)
 
     def test_append_series(self):
 
@@ -937,8 +944,9 @@ class TestHDFStore(Base, tm.TestCase):
 
                 # only support for fixed types (and they have a perf warning)
                 self.assertRaises(TypeError, check, 'table', index)
-                with tm.assert_produces_warning(
-                        expected_warning=PerformanceWarning):
+
+                # PerformanceWarning
+                with catch_warnings(record=True):
                     check('fixed', index)
 
     def test_encoding(self):
@@ -1131,15 +1139,17 @@ class TestHDFStore(Base, tm.TestCase):
                   [[np.nan, np.nan, np.nan], [np.nan, 5, 6]],
                   [[np.nan, np.nan, np.nan], [np.nan, 3, np.nan]]]
 
-        panel_with_missing = Panel(matrix, items=['Item1', 'Item2', 'Item3'],
-                                   major_axis=[1, 2],
-                                   minor_axis=['A', 'B', 'C'])
+        with catch_warnings(record=True):
+            panel_with_missing = Panel(matrix,
+                                       items=['Item1', 'Item2', 'Item3'],
+                                       major_axis=[1, 2],
+                                       minor_axis=['A', 'B', 'C'])
 
-        with ensure_clean_path(self.path) as path:
-            panel_with_missing.to_hdf(
-                path, 'panel_with_missing', format='table')
-            reloaded_panel = read_hdf(path, 'panel_with_missing')
-            tm.assert_panel_equal(panel_with_missing, reloaded_panel)
+            with ensure_clean_path(self.path) as path:
+                panel_with_missing.to_hdf(
+                    path, 'panel_with_missing', format='table')
+                reloaded_panel = read_hdf(path, 'panel_with_missing')
+                tm.assert_panel_equal(panel_with_missing, reloaded_panel)
 
     def test_append_frame_column_oriented(self):
 
@@ -1158,13 +1168,14 @@ class TestHDFStore(Base, tm.TestCase):
 
             # selection on the non-indexable
             result = store.select(
-                'df1', ('columns=A', Term('index=df.index[0:4]')))
+                'df1', ('columns=A', 'index=df.index[0:4]'))
             expected = df.reindex(columns=['A'], index=df.index[0:4])
             tm.assert_frame_equal(expected, result)
 
             # this isn't supported
-            self.assertRaises(TypeError, store.select, 'df1', (
-                'columns=A', Term('index>df.index[4]')))
+            with pytest.raises(TypeError):
+                store.select('df1',
+                             'columns=A and index>df.index[4]')
 
     def test_append_with_different_block_ordering(self):
 
@@ -1265,15 +1276,15 @@ class TestHDFStore(Base, tm.TestCase):
                 assert_panel4d_equal(result, expected)
 
                 # partial selection2
-                result = store.select('p4d', [Term(
-                    'labels=l1'), Term('items=ItemA'), Term('minor_axis=B')])
+                result = store.select(
+                    'p4d', "labels='l1' and items='ItemA' and minor_axis='B'")
                 expected = p4d.reindex(
                     labels=['l1'], items=['ItemA'], minor_axis=['B'])
                 assert_panel4d_equal(result, expected)
 
                 # non-existant partial selection
-                result = store.select('p4d', [Term(
-                    'labels=l1'), Term('items=Item1'), Term('minor_axis=B')])
+                result = store.select(
+                    'p4d', "labels='l1' and items='Item1' and minor_axis='B'")
                 expected = p4d.reindex(labels=['l1'], items=[],
                                        minor_axis=['B'])
                 assert_panel4d_equal(result, expected)
@@ -1281,100 +1292,103 @@ class TestHDFStore(Base, tm.TestCase):
     def test_append_with_strings(self):
 
         with ensure_clean_store(self.path) as store:
-            wp = tm.makePanel()
-            wp2 = wp.rename_axis(
-                dict([(x, "%s_extra" % x) for x in wp.minor_axis]), axis=2)
-
-            def check_col(key, name, size):
-                self.assertEqual(getattr(store.get_storer(
-                    key).table.description, name).itemsize, size)
-
-            store.append('s1', wp, min_itemsize=20)
-            store.append('s1', wp2)
-            expected = concat([wp, wp2], axis=2)
-            expected = expected.reindex(minor_axis=sorted(expected.minor_axis))
-            assert_panel_equal(store['s1'], expected)
-            check_col('s1', 'minor_axis', 20)
-
-            # test dict format
-            store.append('s2', wp, min_itemsize={'minor_axis': 20})
-            store.append('s2', wp2)
-            expected = concat([wp, wp2], axis=2)
-            expected = expected.reindex(minor_axis=sorted(expected.minor_axis))
-            assert_panel_equal(store['s2'], expected)
-            check_col('s2', 'minor_axis', 20)
-
-            # apply the wrong field (similar to #1)
-            store.append('s3', wp, min_itemsize={'major_axis': 20})
-            self.assertRaises(ValueError, store.append, 's3', wp2)
-
-            # test truncation of bigger strings
-            store.append('s4', wp)
-            self.assertRaises(ValueError, store.append, 's4', wp2)
-
-            # avoid truncation on elements
-            df = DataFrame([[123, 'asdqwerty'], [345, 'dggnhebbsdfbdfb']])
-            store.append('df_big', df)
-            tm.assert_frame_equal(store.select('df_big'), df)
-            check_col('df_big', 'values_block_1', 15)
-
-            # appending smaller string ok
-            df2 = DataFrame([[124, 'asdqy'], [346, 'dggnhefbdfb']])
-            store.append('df_big', df2)
-            expected = concat([df, df2])
-            tm.assert_frame_equal(store.select('df_big'), expected)
-            check_col('df_big', 'values_block_1', 15)
-
-            # avoid truncation on elements
-            df = DataFrame([[123, 'asdqwerty'], [345, 'dggnhebbsdfbdfb']])
-            store.append('df_big2', df, min_itemsize={'values': 50})
-            tm.assert_frame_equal(store.select('df_big2'), df)
-            check_col('df_big2', 'values_block_1', 50)
-
-            # bigger string on next append
-            store.append('df_new', df)
-            df_new = DataFrame(
-                [[124, 'abcdefqhij'], [346, 'abcdefghijklmnopqrtsuvwxyz']])
-            self.assertRaises(ValueError, store.append, 'df_new', df_new)
-
-            # min_itemsize on Series index (GH 11412)
-            df = tm.makeMixedDataFrame().set_index('C')
-            store.append('ss', df['B'], min_itemsize={'index': 4})
-            tm.assert_series_equal(store.select('ss'), df['B'])
-
-            # same as above, with data_columns=True
-            store.append('ss2', df['B'], data_columns=True,
-                         min_itemsize={'index': 4})
-            tm.assert_series_equal(store.select('ss2'), df['B'])
-
-            # min_itemsize in index without appending (GH 10381)
-            store.put('ss3', df, format='table',
-                      min_itemsize={'index': 6})
-            # just make sure there is a longer string:
-            df2 = df.copy().reset_index().assign(C='longer').set_index('C')
-            store.append('ss3', df2)
-            tm.assert_frame_equal(store.select('ss3'),
-                                  pd.concat([df, df2]))
-
-            # same as above, with a Series
-            store.put('ss4', df['B'], format='table',
-                      min_itemsize={'index': 6})
-            store.append('ss4', df2['B'])
-            tm.assert_series_equal(store.select('ss4'),
-                                   pd.concat([df['B'], df2['B']]))
-
-            # with nans
-            _maybe_remove(store, 'df')
-            df = tm.makeTimeDataFrame()
-            df['string'] = 'foo'
-            df.loc[1:4, 'string'] = np.nan
-            df['string2'] = 'bar'
-            df.loc[4:8, 'string2'] = np.nan
-            df['string3'] = 'bah'
-            df.loc[1:, 'string3'] = np.nan
-            store.append('df', df)
-            result = store.select('df')
-            tm.assert_frame_equal(result, df)
+            with catch_warnings(record=True):
+                wp = tm.makePanel()
+                wp2 = wp.rename_axis(
+                    dict([(x, "%s_extra" % x) for x in wp.minor_axis]), axis=2)
+
+                def check_col(key, name, size):
+                    self.assertEqual(getattr(store.get_storer(
+                        key).table.description, name).itemsize, size)
+
+                store.append('s1', wp, min_itemsize=20)
+                store.append('s1', wp2)
+                expected = concat([wp, wp2], axis=2)
+                expected = expected.reindex(
+                    minor_axis=sorted(expected.minor_axis))
+                assert_panel_equal(store['s1'], expected)
+                check_col('s1', 'minor_axis', 20)
+
+                # test dict format
+                store.append('s2', wp, min_itemsize={'minor_axis': 20})
+                store.append('s2', wp2)
+                expected = concat([wp, wp2], axis=2)
+                expected = expected.reindex(
+                    minor_axis=sorted(expected.minor_axis))
+                assert_panel_equal(store['s2'], expected)
+                check_col('s2', 'minor_axis', 20)
+
+                # apply the wrong field (similar to #1)
+                store.append('s3', wp, min_itemsize={'major_axis': 20})
+                self.assertRaises(ValueError, store.append, 's3', wp2)
+
+                # test truncation of bigger strings
+                store.append('s4', wp)
+                self.assertRaises(ValueError, store.append, 's4', wp2)
+
+                # avoid truncation on elements
+                df = DataFrame([[123, 'asdqwerty'], [345, 'dggnhebbsdfbdfb']])
+                store.append('df_big', df)
+                tm.assert_frame_equal(store.select('df_big'), df)
+                check_col('df_big', 'values_block_1', 15)
+
+                # appending smaller string ok
+                df2 = DataFrame([[124, 'asdqy'], [346, 'dggnhefbdfb']])
+                store.append('df_big', df2)
+                expected = concat([df, df2])
+                tm.assert_frame_equal(store.select('df_big'), expected)
+                check_col('df_big', 'values_block_1', 15)
+
+                # avoid truncation on elements
+                df = DataFrame([[123, 'asdqwerty'], [345, 'dggnhebbsdfbdfb']])
+                store.append('df_big2', df, min_itemsize={'values': 50})
+                tm.assert_frame_equal(store.select('df_big2'), df)
+                check_col('df_big2', 'values_block_1', 50)
+
+                # bigger string on next append
+                store.append('df_new', df)
+                df_new = DataFrame(
+                    [[124, 'abcdefqhij'], [346, 'abcdefghijklmnopqrtsuvwxyz']])
+                self.assertRaises(ValueError, store.append, 'df_new', df_new)
+
+                # min_itemsize on Series index (GH 11412)
+                df = tm.makeMixedDataFrame().set_index('C')
+                store.append('ss', df['B'], min_itemsize={'index': 4})
+                tm.assert_series_equal(store.select('ss'), df['B'])
+
+                # same as above, with data_columns=True
+                store.append('ss2', df['B'], data_columns=True,
+                             min_itemsize={'index': 4})
+                tm.assert_series_equal(store.select('ss2'), df['B'])
+
+                # min_itemsize in index without appending (GH 10381)
+                store.put('ss3', df, format='table',
+                          min_itemsize={'index': 6})
+                # just make sure there is a longer string:
+                df2 = df.copy().reset_index().assign(C='longer').set_index('C')
+                store.append('ss3', df2)
+                tm.assert_frame_equal(store.select('ss3'),
+                                      pd.concat([df, df2]))
+
+                # same as above, with a Series
+                store.put('ss4', df['B'], format='table',
+                          min_itemsize={'index': 6})
+                store.append('ss4', df2['B'])
+                tm.assert_series_equal(store.select('ss4'),
+                                       pd.concat([df['B'], df2['B']]))
+
+                # with nans
+                _maybe_remove(store, 'df')
+                df = tm.makeTimeDataFrame()
+                df['string'] = 'foo'
+                df.loc[1:4, 'string'] = np.nan
+                df['string2'] = 'bar'
+                df.loc[4:8, 'string2'] = np.nan
+                df['string3'] = 'bah'
+                df.loc[1:, 'string3'] = np.nan
+                store.append('df', df)
+                result = store.select('df')
+                tm.assert_frame_equal(result, df)
 
         with ensure_clean_store(self.path) as store:
 
@@ -1452,13 +1466,13 @@ class TestHDFStore(Base, tm.TestCase):
             assert(store._handle.root.df.table.cols.B.is_indexed is True)
 
             # data column searching
-            result = store.select('df', [Term('B>0')])
+            result = store.select('df', 'B>0')
             expected = df[df.B > 0]
             tm.assert_frame_equal(result, expected)
 
             # data column searching (with an indexable and a data_columns)
             result = store.select(
-                'df', [Term('B>0'), Term('index>df.index[3]')])
+                'df', 'B>0 and index>df.index[3]')
             df_new = df.reindex(index=df.index[4:])
             expected = df_new[df_new.B > 0]
             tm.assert_frame_equal(result, expected)
@@ -1470,7 +1484,7 @@ class TestHDFStore(Base, tm.TestCase):
             df_new.loc[5:6, 'string'] = 'bar'
             _maybe_remove(store, 'df')
             store.append('df', df_new, data_columns=['string'])
-            result = store.select('df', [Term('string=foo')])
+            result = store.select('df', "string='foo'")
             expected = df_new[df_new.string == 'foo']
             tm.assert_frame_equal(result, expected)
 
@@ -1523,15 +1537,15 @@ class TestHDFStore(Base, tm.TestCase):
             _maybe_remove(store, 'df')
             store.append(
                 'df', df_new, data_columns=['A', 'B', 'string', 'string2'])
-            result = store.select('df', [Term('string=foo'), Term(
-                'string2=foo'), Term('A>0'), Term('B<0')])
+            result = store.select('df',
+                                  "string='foo' and string2='foo'"
+                                  " and A>0 and B<0")
             expected = df_new[(df_new.string == 'foo') & (
                 df_new.string2 == 'foo') & (df_new.A > 0) & (df_new.B < 0)]
             tm.assert_frame_equal(result, expected, check_index_type=False)
 
             # yield an empty frame
-            result = store.select('df', [Term('string=foo'), Term(
-                'string2=cool')])
+            result = store.select('df', "string='foo' and string2='cool'")
             expected = df_new[(df_new.string == 'foo') & (
                 df_new.string2 == 'cool')]
             tm.assert_frame_equal(result, expected, check_index_type=False)
@@ -1551,7 +1565,7 @@ class TestHDFStore(Base, tm.TestCase):
             store.append('df_dc', df_dc,
                          data_columns=['B', 'C', 'string',
                                        'string2', 'datetime'])
-            result = store.select('df_dc', [Term('B>0')])
+            result = store.select('df_dc', 'B>0')
 
             expected = df_dc[df_dc.B > 0]
             tm.assert_frame_equal(result, expected, check_index_type=False)
@@ -1578,7 +1592,7 @@ class TestHDFStore(Base, tm.TestCase):
             store.append('df_dc', df_dc, data_columns=[
                          'B', 'C', 'string', 'string2'])
 
-            result = store.select('df_dc', [Term('B>0')])
+            result = store.select('df_dc', 'B>0')
             expected = df_dc[df_dc.B > 0]
             tm.assert_frame_equal(result, expected)
 
@@ -1589,99 +1603,104 @@ class TestHDFStore(Base, tm.TestCase):
             tm.assert_frame_equal(result, expected)
 
         with ensure_clean_store(self.path) as store:
-            # panel
-            # GH5717 not handling data_columns
-            np.random.seed(1234)
-            p = tm.makePanel()
-
-            store.append('p1', p)
-            tm.assert_panel_equal(store.select('p1'), p)
-
-            store.append('p2', p, data_columns=True)
-            tm.assert_panel_equal(store.select('p2'), p)
-
-            result = store.select('p2', where='ItemA>0')
-            expected = p.to_frame()
-            expected = expected[expected['ItemA'] > 0]
-            tm.assert_frame_equal(result.to_frame(), expected)
-
-            result = store.select('p2', where='ItemA>0 & minor_axis=["A","B"]')
-            expected = p.to_frame()
-            expected = expected[expected['ItemA'] > 0]
-            expected = expected[expected.reset_index(
-                level=['major']).index.isin(['A', 'B'])]
-            tm.assert_frame_equal(result.to_frame(), expected)
+            with catch_warnings(record=True):
+                # panel
+                # GH5717 not handling data_columns
+                np.random.seed(1234)
+                p = tm.makePanel()
+
+                store.append('p1', p)
+                tm.assert_panel_equal(store.select('p1'), p)
+
+                store.append('p2', p, data_columns=True)
+                tm.assert_panel_equal(store.select('p2'), p)
+
+                result = store.select('p2', where='ItemA>0')
+                expected = p.to_frame()
+                expected = expected[expected['ItemA'] > 0]
+                tm.assert_frame_equal(result.to_frame(), expected)
+
+                result = store.select(
+                    'p2', where='ItemA>0 & minor_axis=["A","B"]')
+                expected = p.to_frame()
+                expected = expected[expected['ItemA'] > 0]
+                expected = expected[expected.reset_index(
+                    level=['major']).index.isin(['A', 'B'])]
+                tm.assert_frame_equal(result.to_frame(), expected)
 
     def test_create_table_index(self):
 
         with ensure_clean_store(self.path) as store:
 
-            def col(t, column):
-                return getattr(store.get_storer(t).table.cols, column)
+            with catch_warnings(record=True):
+                def col(t, column):
+                    return getattr(store.get_storer(t).table.cols, column)
 
-            # index=False
-            wp = tm.makePanel()
-            store.append('p5', wp, index=False)
-            store.create_table_index('p5', columns=['major_axis'])
-            assert(col('p5', 'major_axis').is_indexed is True)
-            assert(col('p5', 'minor_axis').is_indexed is False)
-
-            # index=True
-            store.append('p5i', wp, index=True)
-            assert(col('p5i', 'major_axis').is_indexed is True)
-            assert(col('p5i', 'minor_axis').is_indexed is True)
-
-            # default optlevels
-            store.get_storer('p5').create_index()
-            assert(col('p5', 'major_axis').index.optlevel == 6)
-            assert(col('p5', 'minor_axis').index.kind == 'medium')
-
-            # let's change the indexing scheme
-            store.create_table_index('p5')
-            assert(col('p5', 'major_axis').index.optlevel == 6)
-            assert(col('p5', 'minor_axis').index.kind == 'medium')
-            store.create_table_index('p5', optlevel=9)
-            assert(col('p5', 'major_axis').index.optlevel == 9)
-            assert(col('p5', 'minor_axis').index.kind == 'medium')
-            store.create_table_index('p5', kind='full')
-            assert(col('p5', 'major_axis').index.optlevel == 9)
-            assert(col('p5', 'minor_axis').index.kind == 'full')
-            store.create_table_index('p5', optlevel=1, kind='light')
-            assert(col('p5', 'major_axis').index.optlevel == 1)
-            assert(col('p5', 'minor_axis').index.kind == 'light')
-
-            # data columns
-            df = tm.makeTimeDataFrame()
-            df['string'] = 'foo'
-            df['string2'] = 'bar'
-            store.append('f', df, data_columns=['string', 'string2'])
-            assert(col('f', 'index').is_indexed is True)
-            assert(col('f', 'string').is_indexed is True)
-            assert(col('f', 'string2').is_indexed is True)
-
-            # specify index=columns
-            store.append(
-                'f2', df, index=['string'], data_columns=['string', 'string2'])
-            assert(col('f2', 'index').is_indexed is False)
-            assert(col('f2', 'string').is_indexed is True)
-            assert(col('f2', 'string2').is_indexed is False)
+                # index=False
+                wp = tm.makePanel()
+                store.append('p5', wp, index=False)
+                store.create_table_index('p5', columns=['major_axis'])
+                assert(col('p5', 'major_axis').is_indexed is True)
+                assert(col('p5', 'minor_axis').is_indexed is False)
+
+                # index=True
+                store.append('p5i', wp, index=True)
+                assert(col('p5i', 'major_axis').is_indexed is True)
+                assert(col('p5i', 'minor_axis').is_indexed is True)
+
+                # default optlevels
+                store.get_storer('p5').create_index()
+                assert(col('p5', 'major_axis').index.optlevel == 6)
+                assert(col('p5', 'minor_axis').index.kind == 'medium')
+
+                # let's change the indexing scheme
+                store.create_table_index('p5')
+                assert(col('p5', 'major_axis').index.optlevel == 6)
+                assert(col('p5', 'minor_axis').index.kind == 'medium')
+                store.create_table_index('p5', optlevel=9)
+                assert(col('p5', 'major_axis').index.optlevel == 9)
+                assert(col('p5', 'minor_axis').index.kind == 'medium')
+                store.create_table_index('p5', kind='full')
+                assert(col('p5', 'major_axis').index.optlevel == 9)
+                assert(col('p5', 'minor_axis').index.kind == 'full')
+                store.create_table_index('p5', optlevel=1, kind='light')
+                assert(col('p5', 'major_axis').index.optlevel == 1)
+                assert(col('p5', 'minor_axis').index.kind == 'light')
+
+                # data columns
+                df = tm.makeTimeDataFrame()
+                df['string'] = 'foo'
+                df['string2'] = 'bar'
+                store.append('f', df, data_columns=['string', 'string2'])
+                assert(col('f', 'index').is_indexed is True)
+                assert(col('f', 'string').is_indexed is True)
+                assert(col('f', 'string2').is_indexed is True)
+
+                # specify index=columns
+                store.append(
+                    'f2', df, index=['string'],
+                    data_columns=['string', 'string2'])
+                assert(col('f2', 'index').is_indexed is False)
+                assert(col('f2', 'string').is_indexed is True)
+                assert(col('f2', 'string2').is_indexed is False)
 
-            # try to index a non-table
-            _maybe_remove(store, 'f2')
-            store.put('f2', df)
-            self.assertRaises(TypeError, store.create_table_index, 'f2')
+                # try to index a non-table
+                _maybe_remove(store, 'f2')
+                store.put('f2', df)
+                self.assertRaises(TypeError, store.create_table_index, 'f2')
 
     def test_append_diff_item_order(self):
 
-        wp = tm.makePanel()
-        wp1 = wp.iloc[:, :10, :]
-        wp2 = wp.iloc[wp.items.get_indexer(['ItemC', 'ItemB', 'ItemA']),
-                      10:, :]
+        with catch_warnings(record=True):
+            wp = tm.makePanel()
+            wp1 = wp.iloc[:, :10, :]
+            wp2 = wp.iloc[wp.items.get_indexer(['ItemC', 'ItemB', 'ItemA']),
+                          10:, :]
 
-        with ensure_clean_store(self.path) as store:
-            store.put('panel', wp1, format='table')
-            self.assertRaises(ValueError, store.put, 'panel', wp2,
-                              append=True)
+            with ensure_clean_store(self.path) as store:
+                store.put('panel', wp1, format='table')
+                self.assertRaises(ValueError, store.put, 'panel', wp2,
+                                  append=True)
 
     def test_append_hierarchical(self):
         index = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux'],
@@ -1909,8 +1928,9 @@ class TestHDFStore(Base, tm.TestCase):
         df['time2'] = Timestamp('20130102')
         check(df, tm.assert_frame_equal)
 
-        p = tm.makePanel()
-        check(p, assert_panel_equal)
+        with catch_warnings(record=True):
+            p = tm.makePanel()
+            check(p, assert_panel_equal)
 
         with catch_warnings(record=True):
             p4d = tm.makePanel4D()
@@ -1936,21 +1956,23 @@ class TestHDFStore(Base, tm.TestCase):
             store.put('df2', df)
             assert_frame_equal(store.select('df2'), df)
 
-            # 0 len
-            p_empty = Panel(items=list('ABC'))
-            store.append('p', p_empty)
-            self.assertRaises(KeyError, store.select, 'p')
+            with catch_warnings(record=True):
 
-            # repeated append of 0/non-zero frames
-            p = Panel(np.random.randn(3, 4, 5), items=list('ABC'))
-            store.append('p', p)
-            assert_panel_equal(store.select('p'), p)
-            store.append('p', p_empty)
-            assert_panel_equal(store.select('p'), p)
+                # 0 len
+                p_empty = Panel(items=list('ABC'))
+                store.append('p', p_empty)
+                self.assertRaises(KeyError, store.select, 'p')
 
-            # store
-            store.put('p2', p_empty)
-            assert_panel_equal(store.select('p2'), p_empty)
+                # repeated append of 0/non-zero frames
+                p = Panel(np.random.randn(3, 4, 5), items=list('ABC'))
+                store.append('p', p)
+                assert_panel_equal(store.select('p'), p)
+                store.append('p', p_empty)
+                assert_panel_equal(store.select('p'), p)
+
+                # store
+                store.put('p2', p_empty)
+                assert_panel_equal(store.select('p2'), p_empty)
 
     def test_append_raise(self):
 
@@ -2066,22 +2088,25 @@ class TestHDFStore(Base, tm.TestCase):
             store.append('df1_mixed', df)
             tm.assert_frame_equal(store.select('df1_mixed'), df)
 
-        # panel
-        wp = tm.makePanel()
-        wp['obj1'] = 'foo'
-        wp['obj2'] = 'bar'
-        wp['bool1'] = wp['ItemA'] > 0
-        wp['bool2'] = wp['ItemB'] > 0
-        wp['int1'] = 1
-        wp['int2'] = 2
-        wp = wp._consolidate()
+        with catch_warnings(record=True):
 
-        with ensure_clean_store(self.path) as store:
-            store.append('p1_mixed', wp)
-            assert_panel_equal(store.select('p1_mixed'), wp)
+            # panel
+            wp = tm.makePanel()
+            wp['obj1'] = 'foo'
+            wp['obj2'] = 'bar'
+            wp['bool1'] = wp['ItemA'] > 0
+            wp['bool2'] = wp['ItemB'] > 0
+            wp['int1'] = 1
+            wp['int2'] = 2
+            wp = wp._consolidate()
 
         with catch_warnings(record=True):
 
+            with ensure_clean_store(self.path) as store:
+                store.append('p1_mixed', wp)
+                assert_panel_equal(store.select('p1_mixed'), wp)
+
+        with catch_warnings(record=True):
             # ndim
             wp = tm.makePanel4D()
             wp['obj1'] = 'foo'
@@ -2166,9 +2191,12 @@ class TestHDFStore(Base, tm.TestCase):
             result = store.select('df')
             assert_frame_equal(result, df)
 
-            result = store.select('df', "C<100000")
+            result = store.select('df', where="C<100000")
             assert_frame_equal(result, df)
 
+            result = store.select('df', where="C<pd.Timedelta('-3D')")
+            assert_frame_equal(result, df.iloc[3:])
+
             result = store.select('df', "C<'-3D'")
             assert_frame_equal(result, df.iloc[3:])
 
@@ -2229,183 +2257,188 @@ class TestHDFStore(Base, tm.TestCase):
 
         with ensure_clean_store(self.path) as store:
 
-            # non-existance
-            crit1 = Term('index>foo')
-            self.assertRaises(KeyError, store.remove, 'a', [crit1])
+            with catch_warnings(record=True):
 
-            # try to remove non-table (with crit)
-            # non-table ok (where = None)
-            wp = tm.makePanel(30)
-            store.put('wp', wp, format='table')
-            store.remove('wp', ["minor_axis=['A', 'D']"])
-            rs = store.select('wp')
-            expected = wp.reindex(minor_axis=['B', 'C'])
-            assert_panel_equal(rs, expected)
+                # non-existance
+                crit1 = 'index>foo'
+                self.assertRaises(KeyError, store.remove, 'a', [crit1])
 
-            # empty where
-            _maybe_remove(store, 'wp')
-            store.put('wp', wp, format='table')
+                # try to remove non-table (with crit)
+                # non-table ok (where = None)
+                wp = tm.makePanel(30)
+                store.put('wp', wp, format='table')
+                store.remove('wp', ["minor_axis=['A', 'D']"])
+                rs = store.select('wp')
+                expected = wp.reindex(minor_axis=['B', 'C'])
+                assert_panel_equal(rs, expected)
 
-            # deleted number (entire table)
-            n = store.remove('wp', [])
-            self.assertTrue(n == 120)
+                # empty where
+                _maybe_remove(store, 'wp')
+                store.put('wp', wp, format='table')
 
-            # non - empty where
-            _maybe_remove(store, 'wp')
-            store.put('wp', wp, format='table')
-            self.assertRaises(ValueError, store.remove,
-                              'wp', ['foo'])
+                # deleted number (entire table)
+                n = store.remove('wp', [])
+                self.assertTrue(n == 120)
 
-            # selectin non-table with a where
-            # store.put('wp2', wp, format='f')
-            # self.assertRaises(ValueError, store.remove,
-            #                  'wp2', [('column', ['A', 'D'])])
+                # non - empty where
+                _maybe_remove(store, 'wp')
+                store.put('wp', wp, format='table')
+                self.assertRaises(ValueError, store.remove,
+                                  'wp', ['foo'])
 
     def test_remove_startstop(self):
         # GH #4835 and #6177
 
         with ensure_clean_store(self.path) as store:
 
-            wp = tm.makePanel(30)
-
-            # start
-            _maybe_remove(store, 'wp1')
-            store.put('wp1', wp, format='t')
-            n = store.remove('wp1', start=32)
-            self.assertTrue(n == 120 - 32)
-            result = store.select('wp1')
-            expected = wp.reindex(major_axis=wp.major_axis[:32 // 4])
-            assert_panel_equal(result, expected)
-
-            _maybe_remove(store, 'wp2')
-            store.put('wp2', wp, format='t')
-            n = store.remove('wp2', start=-32)
-            self.assertTrue(n == 32)
-            result = store.select('wp2')
-            expected = wp.reindex(major_axis=wp.major_axis[:-32 // 4])
-            assert_panel_equal(result, expected)
-
-            # stop
-            _maybe_remove(store, 'wp3')
-            store.put('wp3', wp, format='t')
-            n = store.remove('wp3', stop=32)
-            self.assertTrue(n == 32)
-            result = store.select('wp3')
-            expected = wp.reindex(major_axis=wp.major_axis[32 // 4:])
-            assert_panel_equal(result, expected)
-
-            _maybe_remove(store, 'wp4')
-            store.put('wp4', wp, format='t')
-            n = store.remove('wp4', stop=-32)
-            self.assertTrue(n == 120 - 32)
-            result = store.select('wp4')
-            expected = wp.reindex(major_axis=wp.major_axis[-32 // 4:])
-            assert_panel_equal(result, expected)
-
-            # start n stop
-            _maybe_remove(store, 'wp5')
-            store.put('wp5', wp, format='t')
-            n = store.remove('wp5', start=16, stop=-16)
-            self.assertTrue(n == 120 - 32)
-            result = store.select('wp5')
-            expected = wp.reindex(major_axis=wp.major_axis[
-                                  :16 // 4].union(wp.major_axis[-16 // 4:]))
-            assert_panel_equal(result, expected)
-
-            _maybe_remove(store, 'wp6')
-            store.put('wp6', wp, format='t')
-            n = store.remove('wp6', start=16, stop=16)
-            self.assertTrue(n == 0)
-            result = store.select('wp6')
-            expected = wp.reindex(major_axis=wp.major_axis)
-            assert_panel_equal(result, expected)
-
-            # with where
-            _maybe_remove(store, 'wp7')
-
-            # TODO: unused?
-            date = wp.major_axis.take(np.arange(0, 30, 3))  # noqa
-
-            crit = Term('major_axis=date')
-            store.put('wp7', wp, format='t')
-            n = store.remove('wp7', where=[crit], stop=80)
-            self.assertTrue(n == 28)
-            result = store.select('wp7')
-            expected = wp.reindex(major_axis=wp.major_axis.difference(
-                wp.major_axis[np.arange(0, 20, 3)]))
-            assert_panel_equal(result, expected)
+            with catch_warnings(record=True):
+                wp = tm.makePanel(30)
+
+                # start
+                _maybe_remove(store, 'wp1')
+                store.put('wp1', wp, format='t')
+                n = store.remove('wp1', start=32)
+                self.assertTrue(n == 120 - 32)
+                result = store.select('wp1')
+                expected = wp.reindex(major_axis=wp.major_axis[:32 // 4])
+                assert_panel_equal(result, expected)
+
+                _maybe_remove(store, 'wp2')
+                store.put('wp2', wp, format='t')
+                n = store.remove('wp2', start=-32)
+                self.assertTrue(n == 32)
+                result = store.select('wp2')
+                expected = wp.reindex(major_axis=wp.major_axis[:-32 // 4])
+                assert_panel_equal(result, expected)
+
+                # stop
+                _maybe_remove(store, 'wp3')
+                store.put('wp3', wp, format='t')
+                n = store.remove('wp3', stop=32)
+                self.assertTrue(n == 32)
+                result = store.select('wp3')
+                expected = wp.reindex(major_axis=wp.major_axis[32 // 4:])
+                assert_panel_equal(result, expected)
+
+                _maybe_remove(store, 'wp4')
+                store.put('wp4', wp, format='t')
+                n = store.remove('wp4', stop=-32)
+                self.assertTrue(n == 120 - 32)
+                result = store.select('wp4')
+                expected = wp.reindex(major_axis=wp.major_axis[-32 // 4:])
+                assert_panel_equal(result, expected)
+
+                # start n stop
+                _maybe_remove(store, 'wp5')
+                store.put('wp5', wp, format='t')
+                n = store.remove('wp5', start=16, stop=-16)
+                self.assertTrue(n == 120 - 32)
+                result = store.select('wp5')
+                expected = wp.reindex(
+                    major_axis=(wp.major_axis[:16 // 4]
+                                .union(wp.major_axis[-16 // 4:])))
+                assert_panel_equal(result, expected)
+
+                _maybe_remove(store, 'wp6')
+                store.put('wp6', wp, format='t')
+                n = store.remove('wp6', start=16, stop=16)
+                self.assertTrue(n == 0)
+                result = store.select('wp6')
+                expected = wp.reindex(major_axis=wp.major_axis)
+                assert_panel_equal(result, expected)
+
+                # with where
+                _maybe_remove(store, 'wp7')
+
+                # TODO: unused?
+                date = wp.major_axis.take(np.arange(0, 30, 3))  # noqa
+
+                crit = 'major_axis=date'
+                store.put('wp7', wp, format='t')
+                n = store.remove('wp7', where=[crit], stop=80)
+                self.assertTrue(n == 28)
+                result = store.select('wp7')
+                expected = wp.reindex(major_axis=wp.major_axis.difference(
+                    wp.major_axis[np.arange(0, 20, 3)]))
+                assert_panel_equal(result, expected)
 
     def test_remove_crit(self):
 
         with ensure_clean_store(self.path) as store:
 
-            wp = tm.makePanel(30)
-
-            # group row removal
-            _maybe_remove(store, 'wp3')
-            date4 = wp.major_axis.take([0, 1, 2, 4, 5, 6, 8, 9, 10])
-            crit4 = Term('major_axis=date4')
-            store.put('wp3', wp, format='t')
-            n = store.remove('wp3', where=[crit4])
-            self.assertTrue(n == 36)
-
-            result = store.select('wp3')
-            expected = wp.reindex(major_axis=wp.major_axis.difference(date4))
-            assert_panel_equal(result, expected)
-
-            # upper half
-            _maybe_remove(store, 'wp')
-            store.put('wp', wp, format='table')
-            date = wp.major_axis[len(wp.major_axis) // 2]
-
-            crit1 = Term('major_axis>date')
-            crit2 = Term("minor_axis=['A', 'D']")
-            n = store.remove('wp', where=[crit1])
-            self.assertTrue(n == 56)
-
-            n = store.remove('wp', where=[crit2])
-            self.assertTrue(n == 32)
-
-            result = store['wp']
-            expected = wp.truncate(after=date).reindex(minor=['B', 'C'])
-            assert_panel_equal(result, expected)
-
-            # individual row elements
-            _maybe_remove(store, 'wp2')
-            store.put('wp2', wp, format='table')
-
-            date1 = wp.major_axis[1:3]
-            crit1 = Term('major_axis=date1')
-            store.remove('wp2', where=[crit1])
-            result = store.select('wp2')
-            expected = wp.reindex(major_axis=wp.major_axis.difference(date1))
-            assert_panel_equal(result, expected)
-
-            date2 = wp.major_axis[5]
-            crit2 = Term('major_axis=date2')
-            store.remove('wp2', where=[crit2])
-            result = store['wp2']
-            expected = wp.reindex(major_axis=wp.major_axis.difference(date1)
-                                  .difference(Index([date2])))
-            assert_panel_equal(result, expected)
-
-            date3 = [wp.major_axis[7], wp.major_axis[9]]
-            crit3 = Term('major_axis=date3')
-            store.remove('wp2', where=[crit3])
-            result = store['wp2']
-            expected = wp.reindex(major_axis=wp.major_axis
-                                  .difference(date1)
-                                  .difference(Index([date2]))
-                                  .difference(Index(date3)))
-            assert_panel_equal(result, expected)
-
-            # corners
-            _maybe_remove(store, 'wp4')
-            store.put('wp4', wp, format='table')
-            n = store.remove(
-                'wp4', where=[Term('major_axis>wp.major_axis[-1]')])
-            result = store.select('wp4')
-            assert_panel_equal(result, wp)
+            with catch_warnings(record=True):
+                wp = tm.makePanel(30)
+
+                # group row removal
+                _maybe_remove(store, 'wp3')
+                date4 = wp.major_axis.take([0, 1, 2, 4, 5, 6, 8, 9, 10])
+                crit4 = 'major_axis=date4'
+                store.put('wp3', wp, format='t')
+                n = store.remove('wp3', where=[crit4])
+                self.assertTrue(n == 36)
+
+                result = store.select('wp3')
+                expected = wp.reindex(
+                    major_axis=wp.major_axis.difference(date4))
+                assert_panel_equal(result, expected)
+
+                # upper half
+                _maybe_remove(store, 'wp')
+                store.put('wp', wp, format='table')
+                date = wp.major_axis[len(wp.major_axis) // 2]
+
+                crit1 = 'major_axis>date'
+                crit2 = "minor_axis=['A', 'D']"
+                n = store.remove('wp', where=[crit1])
+                self.assertTrue(n == 56)
+
+                n = store.remove('wp', where=[crit2])
+                self.assertTrue(n == 32)
+
+                result = store['wp']
+                expected = wp.truncate(after=date).reindex(minor=['B', 'C'])
+                assert_panel_equal(result, expected)
+
+                # individual row elements
+                _maybe_remove(store, 'wp2')
+                store.put('wp2', wp, format='table')
+
+                date1 = wp.major_axis[1:3]
+                crit1 = 'major_axis=date1'
+                store.remove('wp2', where=[crit1])
+                result = store.select('wp2')
+                expected = wp.reindex(
+                    major_axis=wp.major_axis.difference(date1))
+                assert_panel_equal(result, expected)
+
+                date2 = wp.major_axis[5]
+                crit2 = 'major_axis=date2'
+                store.remove('wp2', where=[crit2])
+                result = store['wp2']
+                expected = wp.reindex(
+                    major_axis=(wp.major_axis
+                                .difference(date1)
+                                .difference(Index([date2]))
+                                ))
+                assert_panel_equal(result, expected)
+
+                date3 = [wp.major_axis[7], wp.major_axis[9]]
+                crit3 = 'major_axis=date3'
+                store.remove('wp2', where=[crit3])
+                result = store['wp2']
+                expected = wp.reindex(major_axis=wp.major_axis
+                                      .difference(date1)
+                                      .difference(Index([date2]))
+                                      .difference(Index(date3)))
+                assert_panel_equal(result, expected)
+
+                # corners
+                _maybe_remove(store, 'wp4')
+                store.put('wp4', wp, format='table')
+                n = store.remove(
+                    'wp4', where="major_axis>wp.major_axis[-1]")
+                result = store.select('wp4')
+                assert_panel_equal(result, wp)
 
     def test_invalid_terms(self):
 
@@ -2464,24 +2497,32 @@ class TestHDFStore(Base, tm.TestCase):
 
         with ensure_clean_store(self.path) as store:
 
-            wp = tm.makePanel()
-            wpneg = Panel.fromDict({-1: tm.makeDataFrame(),
-                                    0: tm.makeDataFrame(),
-                                    1: tm.makeDataFrame()})
-
             with catch_warnings(record=True):
 
+                wp = tm.makePanel()
+                wpneg = Panel.fromDict({-1: tm.makeDataFrame(),
+                                        0: tm.makeDataFrame(),
+                                        1: tm.makeDataFrame()})
                 p4d = tm.makePanel4D()
                 store.put('p4d', p4d, format='table')
-
-            store.put('wp', wp, format='table')
-            store.put('wpneg', wpneg, format='table')
-
-            # panel
-            result = store.select(
-                'wp', "major_axis<'20000108' and minor_axis=['A', 'B']")
-            expected = wp.truncate(after='20000108').reindex(minor=['A', 'B'])
-            assert_panel_equal(result, expected)
+                store.put('wp', wp, format='table')
+                store.put('wpneg', wpneg, format='table')
+
+                # panel
+                result = store.select(
+                    'wp',
+                    "major_axis<'20000108' and minor_axis=['A', 'B']")
+                expected = wp.truncate(
+                    after='20000108').reindex(minor=['A', 'B'])
+                assert_panel_equal(result, expected)
+
+                # with deprecation
+                result = store.select(
+                    'wp', where=("major_axis<'20000108' "
+                                 "and minor_axis=['A', 'B']"))
+                expected = wp.truncate(
+                    after='20000108').reindex(minor=['A', 'B'])
+                tm.assert_panel_equal(result, expected)
 
             # p4d
             with catch_warnings(record=True):
@@ -2516,74 +2557,79 @@ class TestHDFStore(Base, tm.TestCase):
                     store.select('p4d', t)
 
                 # valid for p4d only
-                terms = [(("labels=['l1', 'l2']"),),
-                         Term("labels=['l1', 'l2']"),
-                         ]
-
+                terms = ["labels=['l1', 'l2']"]
                 for t in terms:
                     store.select('p4d', t)
 
-            with tm.assertRaisesRegexp(TypeError,
-                                       'Only named functions are supported'):
-                store.select('wp', Term(
-                    'major_axis == (lambda x: x)("20130101")'))
+                with tm.assertRaisesRegexp(
+                        TypeError, 'Only named functions are supported'):
+                    store.select(
+                        'wp',
+                        'major_axis == (lambda x: x)("20130101")')
 
-            # check USub node parsing
-            res = store.select('wpneg', Term('items == -1'))
-            expected = Panel({-1: wpneg[-1]})
-            tm.assert_panel_equal(res, expected)
+            with catch_warnings(record=True):
+                # check USub node parsing
+                res = store.select('wpneg', 'items == -1')
+                expected = Panel({-1: wpneg[-1]})
+                tm.assert_panel_equal(res, expected)
 
-            with tm.assertRaisesRegexp(NotImplementedError,
-                                       'Unary addition not supported'):
-                store.select('wpneg', Term('items == +1'))
+                with tm.assertRaisesRegexp(NotImplementedError,
+                                           'Unary addition not supported'):
+                    store.select('wpneg', 'items == +1')
 
     def test_term_compat(self):
         with ensure_clean_store(self.path) as store:
 
-            wp = Panel(np.random.randn(2, 5, 4), items=['Item1', 'Item2'],
-                       major_axis=date_range('1/1/2000', periods=5),
-                       minor_axis=['A', 'B', 'C', 'D'])
-            store.append('wp', wp)
+            with catch_warnings(record=True):
+                wp = Panel(np.random.randn(2, 5, 4), items=['Item1', 'Item2'],
+                           major_axis=date_range('1/1/2000', periods=5),
+                           minor_axis=['A', 'B', 'C', 'D'])
+                store.append('wp', wp)
 
-            result = store.select(
-                'wp', "major_axis>20000102 and minor_axis=['A', 'B']")
-            expected = wp.loc[:, wp.major_axis >
-                              Timestamp('20000102'), ['A', 'B']]
-            assert_panel_equal(result, expected)
+                result = store.select(
+                    'wp', where=("major_axis>20000102 "
+                                 "and minor_axis=['A', 'B']"))
+                expected = wp.loc[:, wp.major_axis >
+                                  Timestamp('20000102'), ['A', 'B']]
+                assert_panel_equal(result, expected)
 
-            store.remove('wp', 'major_axis>20000103')
-            result = store.select('wp')
-            expected = wp.loc[:, wp.major_axis <= Timestamp('20000103'), :]
-            assert_panel_equal(result, expected)
+                store.remove('wp', 'major_axis>20000103')
+                result = store.select('wp')
+                expected = wp.loc[:, wp.major_axis <= Timestamp('20000103'), :]
+                assert_panel_equal(result, expected)
 
         with ensure_clean_store(self.path) as store:
 
-            wp = Panel(np.random.randn(2, 5, 4), items=['Item1', 'Item2'],
-                       major_axis=date_range('1/1/2000', periods=5),
-                       minor_axis=['A', 'B', 'C', 'D'])
-            store.append('wp', wp)
-
-            # stringified datetimes
-            result = store.select(
-                'wp', "major_axis>datetime.datetime(2000, 1, 2)")
-            expected = wp.loc[:, wp.major_axis > Timestamp('20000102')]
-            assert_panel_equal(result, expected)
-
-            result = store.select(
-                'wp', "major_axis>datetime.datetime(2000, 1, 2, 0, 0)")
-            expected = wp.loc[:, wp.major_axis > Timestamp('20000102')]
-            assert_panel_equal(result, expected)
-
-            result = store.select(
-                'wp', ("major_axis=[datetime.datetime(2000, 1, 2, 0, 0), "
-                       "datetime.datetime(2000, 1, 3, 0, 0)]"))
-            expected = wp.loc[:, [Timestamp('20000102'),
-                                  Timestamp('20000103')]]
-            assert_panel_equal(result, expected)
-
-            result = store.select('wp', "minor_axis=['A', 'B']")
-            expected = wp.loc[:, :, ['A', 'B']]
-            assert_panel_equal(result, expected)
+            with catch_warnings(record=True):
+                wp = Panel(np.random.randn(2, 5, 4),
+                           items=['Item1', 'Item2'],
+                           major_axis=date_range('1/1/2000', periods=5),
+                           minor_axis=['A', 'B', 'C', 'D'])
+                store.append('wp', wp)
+
+                # stringified datetimes
+                result = store.select(
+                    'wp', 'major_axis>datetime.datetime(2000, 1, 2)')
+                expected = wp.loc[:, wp.major_axis > Timestamp('20000102')]
+                assert_panel_equal(result, expected)
+
+                result = store.select(
+                    'wp', 'major_axis>datetime.datetime(2000, 1, 2)')
+                expected = wp.loc[:, wp.major_axis > Timestamp('20000102')]
+                assert_panel_equal(result, expected)
+
+                result = store.select(
+                    'wp',
+                    "major_axis=[datetime.datetime(2000, 1, 2, 0, 0), "
+                    "datetime.datetime(2000, 1, 3, 0, 0)]")
+                expected = wp.loc[:, [Timestamp('20000102'),
+                                      Timestamp('20000103')]]
+                assert_panel_equal(result, expected)
+
+                result = store.select(
+                    'wp', "minor_axis=['A', 'B']")
+                expected = wp.loc[:, :, ['A', 'B']]
+                assert_panel_equal(result, expected)
 
     def test_same_name_scoping(self):
 
@@ -2678,12 +2724,13 @@ class TestHDFStore(Base, tm.TestCase):
 
     def test_index_types(self):
 
-        values = np.random.randn(2)
+        with catch_warnings(record=True):
+            values = np.random.randn(2)
 
-        func = lambda l, r: tm.assert_series_equal(l, r,
-                                                   check_dtype=True,
-                                                   check_index_type=True,
-                                                   check_series_type=True)
+            func = lambda l, r: tm.assert_series_equal(l, r,
+                                                       check_dtype=True,
+                                                       check_index_type=True,
+                                                       check_series_type=True)
 
         with catch_warnings(record=True):
             ser = Series(values, [0, 'y'])
@@ -2702,18 +2749,31 @@ class TestHDFStore(Base, tm.TestCase):
             self._check_roundtrip(ser, func)
 
         with catch_warnings(record=True):
+
+            ser = Series(values, [0, 'y'])
+            self._check_roundtrip(ser, func)
+
+            ser = Series(values, [datetime.datetime.today(), 0])
+            self._check_roundtrip(ser, func)
+
+            ser = Series(values, ['y', 0])
+            self._check_roundtrip(ser, func)
+
+            ser = Series(values, [datetime.date.today(), 'a'])
+            self._check_roundtrip(ser, func)
+
             ser = Series(values, [1.23, 'b'])
             self._check_roundtrip(ser, func)
 
-        ser = Series(values, [1, 1.53])
-        self._check_roundtrip(ser, func)
+            ser = Series(values, [1, 1.53])
+            self._check_roundtrip(ser, func)
 
-        ser = Series(values, [1, 5])
-        self._check_roundtrip(ser, func)
+            ser = Series(values, [1, 5])
+            self._check_roundtrip(ser, func)
 
-        ser = Series(values, [datetime.datetime(
-            2012, 1, 1), datetime.datetime(2012, 1, 2)])
-        self._check_roundtrip(ser, func)
+            ser = Series(values, [datetime.datetime(
+                2012, 1, 1), datetime.datetime(2012, 1, 2)])
+            self._check_roundtrip(ser, func)
 
     def test_timeseries_preepoch(self):
 
@@ -2876,13 +2936,9 @@ class TestHDFStore(Base, tm.TestCase):
 
     def test_wide(self):
 
-        wp = tm.makePanel()
-        self._check_roundtrip(wp, assert_panel_equal)
-
-    def test_wide_table(self):
-
-        wp = tm.makePanel()
-        self._check_roundtrip_table(wp, assert_panel_equal)
+        with catch_warnings(record=True):
+            wp = tm.makePanel()
+            self._check_roundtrip(wp, assert_panel_equal)
 
     def test_select_with_dups(self):
 
@@ -2944,25 +3000,24 @@ class TestHDFStore(Base, tm.TestCase):
             assert_frame_equal(result, expected, by_blocks=True)
 
     def test_wide_table_dups(self):
-        wp = tm.makePanel()
         with ensure_clean_store(self.path) as store:
-            store.put('panel', wp, format='table')
-            store.put('panel', wp, format='table', append=True)
-
             with catch_warnings(record=True):
+
+                wp = tm.makePanel()
+                store.put('panel', wp, format='table')
+                store.put('panel', wp, format='table', append=True)
+
                 recons = store['panel']
 
-            assert_panel_equal(recons, wp)
+                assert_panel_equal(recons, wp)
 
     def test_long(self):
         def _check(left, right):
             assert_panel_equal(left.to_panel(), right.to_panel())
 
-        wp = tm.makePanel()
-        self._check_roundtrip(wp.to_frame(), _check)
-
-        # empty
-        # self._check_roundtrip(wp.to_frame()[:0], _check)
+        with catch_warnings(record=True):
+            wp = tm.makePanel()
+            self._check_roundtrip(wp.to_frame(), _check)
 
     def test_longpanel(self):
         pass
@@ -3009,70 +3064,72 @@ class TestHDFStore(Base, tm.TestCase):
                                      check_frame_type=True)
 
     def test_select(self):
-        wp = tm.makePanel()
 
         with ensure_clean_store(self.path) as store:
 
-            # put/select ok
-            _maybe_remove(store, 'wp')
-            store.put('wp', wp, format='table')
-            store.select('wp')
-
-            # non-table ok (where = None)
-            _maybe_remove(store, 'wp')
-            store.put('wp2', wp)
-            store.select('wp2')
-
-            # selection on the non-indexable with a large number of columns
-            wp = Panel(np.random.randn(100, 100, 100),
-                       items=['Item%03d' % i for i in range(100)],
-                       major_axis=date_range('1/1/2000', periods=100),
-                       minor_axis=['E%03d' % i for i in range(100)])
-
-            _maybe_remove(store, 'wp')
-            store.append('wp', wp)
-            items = ['Item%03d' % i for i in range(80)]
-            result = store.select('wp', Term('items=items'))
-            expected = wp.reindex(items=items)
-            assert_panel_equal(expected, result)
-
-            # selectin non-table with a where
-            # self.assertRaises(ValueError, store.select,
-            #                  'wp2', ('column', ['A', 'D']))
+            with catch_warnings(record=True):
+                wp = tm.makePanel()
 
-            # select with columns=
-            df = tm.makeTimeDataFrame()
-            _maybe_remove(store, 'df')
-            store.append('df', df)
-            result = store.select('df', columns=['A', 'B'])
-            expected = df.reindex(columns=['A', 'B'])
-            tm.assert_frame_equal(expected, result)
+                # put/select ok
+                _maybe_remove(store, 'wp')
+                store.put('wp', wp, format='table')
+                store.select('wp')
+
+                # non-table ok (where = None)
+                _maybe_remove(store, 'wp')
+                store.put('wp2', wp)
+                store.select('wp2')
+
+                # selection on the non-indexable with a large number of columns
+                wp = Panel(np.random.randn(100, 100, 100),
+                           items=['Item%03d' % i for i in range(100)],
+                           major_axis=date_range('1/1/2000', periods=100),
+                           minor_axis=['E%03d' % i for i in range(100)])
+
+                _maybe_remove(store, 'wp')
+                store.append('wp', wp)
+                items = ['Item%03d' % i for i in range(80)]
+                result = store.select('wp', 'items=items')
+                expected = wp.reindex(items=items)
+                assert_panel_equal(expected, result)
+
+                # selectin non-table with a where
+                # self.assertRaises(ValueError, store.select,
+                #                  'wp2', ('column', ['A', 'D']))
+
+                # select with columns=
+                df = tm.makeTimeDataFrame()
+                _maybe_remove(store, 'df')
+                store.append('df', df)
+                result = store.select('df', columns=['A', 'B'])
+                expected = df.reindex(columns=['A', 'B'])
+                tm.assert_frame_equal(expected, result)
 
-            # equivalentsly
-            result = store.select('df', [("columns=['A', 'B']")])
-            expected = df.reindex(columns=['A', 'B'])
-            tm.assert_frame_equal(expected, result)
+                # equivalentsly
+                result = store.select('df', [("columns=['A', 'B']")])
+                expected = df.reindex(columns=['A', 'B'])
+                tm.assert_frame_equal(expected, result)
 
-            # with a data column
-            _maybe_remove(store, 'df')
-            store.append('df', df, data_columns=['A'])
-            result = store.select('df', ['A > 0'], columns=['A', 'B'])
-            expected = df[df.A > 0].reindex(columns=['A', 'B'])
-            tm.assert_frame_equal(expected, result)
+                # with a data column
+                _maybe_remove(store, 'df')
+                store.append('df', df, data_columns=['A'])
+                result = store.select('df', ['A > 0'], columns=['A', 'B'])
+                expected = df[df.A > 0].reindex(columns=['A', 'B'])
+                tm.assert_frame_equal(expected, result)
 
-            # all a data columns
-            _maybe_remove(store, 'df')
-            store.append('df', df, data_columns=True)
-            result = store.select('df', ['A > 0'], columns=['A', 'B'])
-            expected = df[df.A > 0].reindex(columns=['A', 'B'])
-            tm.assert_frame_equal(expected, result)
+                # all a data columns
+                _maybe_remove(store, 'df')
+                store.append('df', df, data_columns=True)
+                result = store.select('df', ['A > 0'], columns=['A', 'B'])
+                expected = df[df.A > 0].reindex(columns=['A', 'B'])
+                tm.assert_frame_equal(expected, result)
 
-            # with a data column, but different columns
-            _maybe_remove(store, 'df')
-            store.append('df', df, data_columns=['A'])
-            result = store.select('df', ['A > 0'], columns=['C', 'D'])
-            expected = df[df.A > 0].reindex(columns=['C', 'D'])
-            tm.assert_frame_equal(expected, result)
+                # with a data column, but different columns
+                _maybe_remove(store, 'df')
+                store.append('df', df, data_columns=['A'])
+                result = store.select('df', ['A > 0'], columns=['C', 'D'])
+                expected = df[df.A > 0].reindex(columns=['C', 'D'])
+                tm.assert_frame_equal(expected, result)
 
     def test_select_dtypes(self):
 
@@ -3084,7 +3141,7 @@ class TestHDFStore(Base, tm.TestCase):
             _maybe_remove(store, 'df')
             store.append('df', df, data_columns=['ts', 'A'])
 
-            result = store.select('df', [Term("ts>=Timestamp('2012-02-01')")])
+            result = store.select('df', "ts>=Timestamp('2012-02-01')")
             expected = df[df.ts >= Timestamp('2012-02-01')]
             tm.assert_frame_equal(expected, result)
 
@@ -3099,15 +3156,15 @@ class TestHDFStore(Base, tm.TestCase):
             expected = (df[df.boolv == True]  # noqa
                         .reindex(columns=['A', 'boolv']))
             for v in [True, 'true', 1]:
-                result = store.select('df', Term(
-                    'boolv == %s' % str(v)), columns=['A', 'boolv'])
+                result = store.select('df', 'boolv == %s' % str(v),
+                                      columns=['A', 'boolv'])
                 tm.assert_frame_equal(expected, result)
 
             expected = (df[df.boolv == False]  # noqa
                         .reindex(columns=['A', 'boolv']))
             for v in [False, 'false', 0]:
-                result = store.select('df', Term(
-                    'boolv == %s' % str(v)), columns=['A', 'boolv'])
+                result = store.select(
+                    'df', 'boolv == %s' % str(v), columns=['A', 'boolv'])
                 tm.assert_frame_equal(expected, result)
 
             # integer index
@@ -3115,7 +3172,7 @@ class TestHDFStore(Base, tm.TestCase):
             _maybe_remove(store, 'df_int')
             store.append('df_int', df)
             result = store.select(
-                'df_int', [Term("index<10"), Term("columns=['A']")])
+                'df_int', "index<10 and columns=['A']")
             expected = df.reindex(index=list(df.index)[0:10], columns=['A'])
             tm.assert_frame_equal(expected, result)
 
@@ -3125,7 +3182,7 @@ class TestHDFStore(Base, tm.TestCase):
             _maybe_remove(store, 'df_float')
             store.append('df_float', df)
             result = store.select(
-                'df_float', [Term("index<10.0"), Term("columns=['A']")])
+                'df_float', "index<10.0 and columns=['A']")
             expected = df.reindex(index=list(df.index)[0:10], columns=['A'])
             tm.assert_frame_equal(expected, result)
 
@@ -3196,14 +3253,14 @@ class TestHDFStore(Base, tm.TestCase):
             store.append('df', df, data_columns=['ts', 'A', 'B', 'users'])
 
             # regular select
-            result = store.select('df', [Term("ts>=Timestamp('2012-02-01')")])
+            result = store.select('df', "ts>=Timestamp('2012-02-01')")
             expected = df[df.ts >= Timestamp('2012-02-01')]
             tm.assert_frame_equal(expected, result)
 
             # small selector
             result = store.select(
-                'df', [Term("ts>=Timestamp('2012-02-01') & "
-                            "users=['a','b','c']")])
+                'df',
+                "ts>=Timestamp('2012-02-01') & users=['a','b','c']")
             expected = df[(df.ts >= Timestamp('2012-02-01')) &
                           df.users.isin(['a', 'b', 'c'])]
             tm.assert_frame_equal(expected, result)
@@ -3211,21 +3268,21 @@ class TestHDFStore(Base, tm.TestCase):
             # big selector along the columns
             selector = ['a', 'b', 'c'] + ['a%03d' % i for i in range(60)]
             result = store.select(
-                'df', [Term("ts>=Timestamp('2012-02-01')"),
-                       Term('users=selector')])
+                'df',
+                "ts>=Timestamp('2012-02-01') and users=selector")
             expected = df[(df.ts >= Timestamp('2012-02-01')) &
                           df.users.isin(selector)]
             tm.assert_frame_equal(expected, result)
 
             selector = range(100, 200)
-            result = store.select('df', [Term('B=selector')])
+            result = store.select('df', 'B=selector')
             expected = df[df.B.isin(selector)]
             tm.assert_frame_equal(expected, result)
             self.assertEqual(len(result), 100)
 
             # big selector along the index
             selector = Index(df.ts[0:100].values)
-            result = store.select('df', [Term('ts=selector')])
+            result = store.select('df', 'ts=selector')
             expected = df[df.ts.isin(selector.values)]
             tm.assert_frame_equal(expected, result)
             self.assertEqual(len(result), 100)
@@ -3296,17 +3353,6 @@ class TestHDFStore(Base, tm.TestCase):
             result = concat(results)
             tm.assert_frame_equal(expected, result)
 
-            # where selection
-            # expected = store.select_as_multiple(
-            #    ['df1', 'df2'], where= Term('A>0'), selector='df1')
-            # results = []
-            # for s in store.select_as_multiple(
-            #    ['df1', 'df2'], where= Term('A>0'), selector='df1',
-            #        chunksize=25):
-            #    results.append(s)
-            # result = concat(results)
-            # tm.assert_frame_equal(expected, result)
-
     def test_select_iterator_complete_8014(self):
 
         # GH 8014
@@ -3518,8 +3564,7 @@ class TestHDFStore(Base, tm.TestCase):
                                      getattr(getattr(result, idx), attr, None))
 
             # try to append a table with a different frequency
-            with tm.assert_produces_warning(
-                    expected_warning=AttributeConflictWarning):
+            with catch_warnings(record=True):
                 df2 = DataFrame(dict(
                     A=Series(lrange(3),
                              index=date_range('2002-1-1',
@@ -3544,9 +3589,7 @@ class TestHDFStore(Base, tm.TestCase):
     def test_retain_index_attributes2(self):
         with ensure_clean_path(self.path) as path:
 
-            expected_warning = Warning if PY35 else AttributeConflictWarning
-            with tm.assert_produces_warning(expected_warning=expected_warning,
-                                            check_stacklevel=False):
+            with catch_warnings(record=True):
 
                 df = DataFrame(dict(
                     A=Series(lrange(3),
@@ -3566,8 +3609,7 @@ class TestHDFStore(Base, tm.TestCase):
 
             self.assertEqual(read_hdf(path, 'data').index.name, 'foo')
 
-            with tm.assert_produces_warning(expected_warning=expected_warning,
-                                            check_stacklevel=False):
+            with catch_warnings(record=True):
 
                 idx2 = date_range('2001-1-1', periods=3, freq='H')
                 idx2.name = 'bar'
@@ -3578,23 +3620,28 @@ class TestHDFStore(Base, tm.TestCase):
 
     def test_panel_select(self):
 
-        wp = tm.makePanel()
-
         with ensure_clean_store(self.path) as store:
-            store.put('wp', wp, format='table')
-            date = wp.major_axis[len(wp.major_axis) // 2]
 
-            crit1 = ('major_axis>=date')
-            crit2 = ("minor_axis=['A', 'D']")
+            with catch_warnings(record=True):
 
-            result = store.select('wp', [crit1, crit2])
-            expected = wp.truncate(before=date).reindex(minor=['A', 'D'])
-            assert_panel_equal(result, expected)
+                wp = tm.makePanel()
 
-            result = store.select(
-                'wp', ['major_axis>="20000124"', ("minor_axis=['A', 'B']")])
-            expected = wp.truncate(before='20000124').reindex(minor=['A', 'B'])
-            assert_panel_equal(result, expected)
+                store.put('wp', wp, format='table')
+                date = wp.major_axis[len(wp.major_axis) // 2]
+
+                crit1 = ('major_axis>=date')
+                crit2 = ("minor_axis=['A', 'D']")
+
+                result = store.select('wp', [crit1, crit2])
+                expected = wp.truncate(before=date).reindex(minor=['A', 'D'])
+                assert_panel_equal(result, expected)
+
+                result = store.select(
+                    'wp', ['major_axis>="20000124"',
+                           ("minor_axis=['A', 'B']")])
+                expected = wp.truncate(
+                    before='20000124').reindex(minor=['A', 'B'])
+                assert_panel_equal(result, expected)
 
     def test_frame_select(self):
 
@@ -3622,7 +3669,7 @@ class TestHDFStore(Base, tm.TestCase):
             df = tm.makeTimeDataFrame()
             store.append('df_time', df)
             self.assertRaises(
-                ValueError, store.select, 'df_time', [Term("index>0")])
+                ValueError, store.select, 'df_time', "index>0")
 
             # can't select if not written as table
             # store['frame'] = df
@@ -3701,7 +3748,7 @@ class TestHDFStore(Base, tm.TestCase):
 
             hist.to_hdf(hh, 'df', mode='w', format='table')
 
-            expected = read_hdf(hh, 'df', where="l1=[2, 3, 4]")
+            expected = read_hdf(hh, 'df', where='l1=[2, 3, 4]')
 
             # sccope with list like
             l = selection.index.tolist()  # noqa
@@ -4005,6 +4052,7 @@ class TestHDFStore(Base, tm.TestCase):
         df = concat([df1, df2], axis=1)
 
         with ensure_clean_store(self.path) as store:
+
             # dropna=True should guarantee rows are synchronized
             store.append_to_multiple(
                 {'df1': ['A', 'B'], 'df2': None}, df, selector='df1',
@@ -4015,14 +4063,27 @@ class TestHDFStore(Base, tm.TestCase):
             tm.assert_index_equal(store.select('df1').index,
                                   store.select('df2').index)
 
+    @pytest.mark.xfail(run=False,
+                       reason="append_to_multiple_dropna_false "
+                       "is not raising as failed")
+    def test_append_to_multiple_dropna_false(self):
+        df1 = tm.makeTimeDataFrame()
+        df2 = tm.makeTimeDataFrame().rename(columns=lambda x: "%s_2" % x)
+        df1.iloc[1, df1.columns.get_indexer(['A', 'B'])] = np.nan
+        df = concat([df1, df2], axis=1)
+
+        with ensure_clean_store(self.path) as store:
+
             # dropna=False shouldn't synchronize row indexes
             store.append_to_multiple(
-                {'df1': ['A', 'B'], 'df2': None}, df, selector='df1',
+                {'df1a': ['A', 'B'], 'df2a': None}, df, selector='df1a',
                 dropna=False)
-            self.assertRaises(
-                ValueError, store.select_as_multiple, ['df1', 'df2'])
-            assert not store.select('df1').index.equals(
-                store.select('df2').index)
+
+            with pytest.raises(ValueError):
+                store.select_as_multiple(['df1a', 'df2a'])
+
+            assert not store.select('df1a').index.equals(
+                store.select('df2a').index)
 
     def test_select_as_multiple(self):
 
@@ -4220,7 +4281,7 @@ class TestHDFStore(Base, tm.TestCase):
         with ensure_clean_store(self.path, 'w', **options) as store:
             store.put('obj', obj, format='table')
             retrieved = store['obj']
-            # sorted_obj = _test_sort(obj)
+
             comparator(retrieved, obj)
 
     def test_multiple_open_close(self):
@@ -4351,16 +4412,16 @@ class TestHDFStore(Base, tm.TestCase):
         with ensure_clean_store(
                 tm.get_data_path('legacy_hdf/legacy_table.h5'),
                 mode='r') as store:
-            store.select('df1')
-            store.select('df2')
-            store.select('wp1')
 
-            # force the frame
-            store.select('df2', typ='legacy_frame')
+            with catch_warnings(record=True):
+                store.select('df1')
+                store.select('df2')
+                store.select('wp1')
+
+                # force the frame
+                store.select('df2', typ='legacy_frame')
 
-            # old version warning
-            with tm.assert_produces_warning(
-                    expected_warning=IncompatibilityWarning):
+                # old version warning
                 self.assertRaises(
                     Exception, store.select, 'wp1', 'minor_axis=B')
 
@@ -4466,7 +4527,8 @@ class TestHDFStore(Base, tm.TestCase):
             'legacy_hdf/legacy_table_%s.h5' % pandas.__version__), 'a')
 
         df = tm.makeDataFrame()
-        wp = tm.makePanel()
+        with catch_warnings(record=True):
+            wp = tm.makePanel()
 
         index = MultiIndex(levels=[['foo', 'bar', 'baz', 'qux'],
                                    ['one', 'two', 'three']],
@@ -4803,12 +4865,11 @@ class TestHDFStore(Base, tm.TestCase):
         for index in types_should_fail:
             df = DataFrame(np.random.randn(10, 2), columns=index(2))
             with ensure_clean_path(self.path) as path:
-                with self.assertRaises(
+                with catch_warnings(record=True):
+                    with self.assertRaises(
                         ValueError, msg=("cannot have non-object label "
                                          "DataIndexableCol")):
-                    with catch_warnings(record=True):
-                        df.to_hdf(path, 'df',
-                                  format='table',
+                        df.to_hdf(path, 'df', format='table',
                                   data_columns=True)
 
         for index in types_should_run:
@@ -4979,7 +5040,7 @@ class TestHDFStore(Base, tm.TestCase):
         with ensure_clean_store(self.path) as store:
             store.append('test', df, format='table', data_columns=True)
 
-            ts = pd.Timestamp('2014-01-01') # noqa
+            ts = pd.Timestamp('2014-01-01')  # noqa
             result = store.select('test', where='real_date > ts')
             expected = df.loc[[1], :]
             tm.assert_frame_equal(expected, result)
@@ -5092,28 +5153,30 @@ class TestHDFComplexValues(Base):
             assert_frame_equal(df, reread)
 
     def test_complex_across_dimensions_fixed(self):
-        complex128 = np.array([1.0 + 1.0j, 1.0 + 1.0j, 1.0 + 1.0j, 1.0 + 1.0j])
-        s = Series(complex128, index=list('abcd'))
-        df = DataFrame({'A': s, 'B': s})
-        p = Panel({'One': df, 'Two': df})
+        with catch_warnings(record=True):
+            complex128 = np.array(
+                [1.0 + 1.0j, 1.0 + 1.0j, 1.0 + 1.0j, 1.0 + 1.0j])
+            s = Series(complex128, index=list('abcd'))
+            df = DataFrame({'A': s, 'B': s})
+            p = Panel({'One': df, 'Two': df})
 
-        objs = [s, df, p]
-        comps = [tm.assert_series_equal, tm.assert_frame_equal,
-                 tm.assert_panel_equal]
-        for obj, comp in zip(objs, comps):
-            with ensure_clean_path(self.path) as path:
-                obj.to_hdf(path, 'obj', format='fixed')
-                reread = read_hdf(path, 'obj')
-                comp(obj, reread)
+            objs = [s, df, p]
+            comps = [tm.assert_series_equal, tm.assert_frame_equal,
+                     tm.assert_panel_equal]
+            for obj, comp in zip(objs, comps):
+                with ensure_clean_path(self.path) as path:
+                    obj.to_hdf(path, 'obj', format='fixed')
+                    reread = read_hdf(path, 'obj')
+                    comp(obj, reread)
 
     def test_complex_across_dimensions(self):
         complex128 = np.array([1.0 + 1.0j, 1.0 + 1.0j, 1.0 + 1.0j, 1.0 + 1.0j])
         s = Series(complex128, index=list('abcd'))
         df = DataFrame({'A': s, 'B': s})
-        p = Panel({'One': df, 'Two': df})
 
         with catch_warnings(record=True):
-            p4d = pd.Panel4D({'i': p, 'ii': p})
+            p = Panel({'One': df, 'Two': df})
+            p4d = Panel4D({'i': p, 'ii': p})
 
             objs = [df, p, p4d]
             comps = [tm.assert_frame_equal, tm.assert_panel_equal,
@@ -5430,12 +5493,3 @@ class TestTimezones(Base, tm.TestCase):
                 store.append('df', df)
                 result = store.select('df')
                 assert_frame_equal(result, df)
-
-
-def _test_sort(obj):
-    if isinstance(obj, DataFrame):
-        return obj.reindex(sorted(obj.index))
-    elif isinstance(obj, Panel):
-        return obj.reindex(major=sorted(obj.major_axis))
-    else:
-        raise ValueError('type not supported here')
diff --git a/pandas/tests/test_expressions.py b/pandas/tests/test_expressions.py
index f669ebe37..dc4787176 100644
--- a/pandas/tests/test_expressions.py
+++ b/pandas/tests/test_expressions.py
@@ -2,6 +2,7 @@
 from __future__ import print_function
 # pylint: disable-msg=W0612,E1101
 
+from warnings import catch_warnings
 import re
 import operator
 import pytest
@@ -32,19 +33,26 @@ _mixed2 = DataFrame({'A': _frame2['A'].copy(),
                      'D': _frame2['D'].astype('int32')})
 _integer = DataFrame(
     np.random.randint(1, 100,
-                      size=(10001, 4)), columns=list('ABCD'), dtype='int64')
+                      size=(10001, 4)),
+    columns=list('ABCD'), dtype='int64')
 _integer2 = DataFrame(np.random.randint(1, 100, size=(101, 4)),
                       columns=list('ABCD'), dtype='int64')
-_frame_panel = Panel(dict(ItemA=_frame.copy(), ItemB=(
-    _frame.copy() + 3), ItemC=_frame.copy(), ItemD=_frame.copy()))
-_frame2_panel = Panel(dict(ItemA=_frame2.copy(), ItemB=(_frame2.copy() + 3),
-                           ItemC=_frame2.copy(), ItemD=_frame2.copy()))
-_integer_panel = Panel(dict(ItemA=_integer, ItemB=(_integer + 34).astype(
-    'int64')))
-_integer2_panel = Panel(dict(ItemA=_integer2, ItemB=(_integer2 + 34).astype(
-    'int64')))
-_mixed_panel = Panel(dict(ItemA=_mixed, ItemB=(_mixed + 3)))
-_mixed2_panel = Panel(dict(ItemA=_mixed2, ItemB=(_mixed2 + 3)))
+
+with catch_warnings(record=True):
+    _frame_panel = Panel(dict(ItemA=_frame.copy(),
+                              ItemB=(_frame.copy() + 3),
+                              ItemC=_frame.copy(),
+                              ItemD=_frame.copy()))
+    _frame2_panel = Panel(dict(ItemA=_frame2.copy(),
+                               ItemB=(_frame2.copy() + 3),
+                               ItemC=_frame2.copy(),
+                               ItemD=_frame2.copy()))
+    _integer_panel = Panel(dict(ItemA=_integer,
+                                ItemB=(_integer + 34).astype('int64')))
+    _integer2_panel = Panel(dict(ItemA=_integer2,
+                                 ItemB=(_integer2 + 34).astype('int64')))
+    _mixed_panel = Panel(dict(ItemA=_mixed, ItemB=(_mixed + 3)))
+    _mixed2_panel = Panel(dict(ItemA=_mixed2, ItemB=(_mixed2 + 3)))
 
 
 @pytest.mark.skipif(not expr._USE_NUMEXPR, reason='not using numexpr')
@@ -204,7 +212,7 @@ class TestExpressions(tm.TestCase):
 
     @slow
     def test_panel4d(self):
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+        with catch_warnings(record=True):
             self.run_panel(tm.makePanel4D(), np.random.randn() + 0.5,
                            assert_func=assert_panel4d_equal, binary_comp=3)
 
diff --git a/pandas/tests/test_generic.py b/pandas/tests/test_generic.py
index 0e8e8dc43..118039d1f 100644
--- a/pandas/tests/test_generic.py
+++ b/pandas/tests/test_generic.py
@@ -3,6 +3,8 @@
 
 from operator import methodcaller
 from copy import copy, deepcopy
+from warnings import catch_warnings
+
 import pytest
 import numpy as np
 from numpy import nan
@@ -1570,17 +1572,18 @@ class TestPanel(tm.TestCase, Generic):
         tm._skip_if_no_xarray()
         from xarray import DataArray
 
-        p = tm.makePanel()
+        with catch_warnings(record=True):
+            p = tm.makePanel()
 
-        result = p.to_xarray()
-        self.assertIsInstance(result, DataArray)
-        self.assertEqual(len(result.coords), 3)
-        assert_almost_equal(list(result.coords.keys()),
-                            ['items', 'major_axis', 'minor_axis'])
-        self.assertEqual(len(result.dims), 3)
+            result = p.to_xarray()
+            self.assertIsInstance(result, DataArray)
+            self.assertEqual(len(result.coords), 3)
+            assert_almost_equal(list(result.coords.keys()),
+                                ['items', 'major_axis', 'minor_axis'])
+            self.assertEqual(len(result.dims), 3)
 
-        # idempotency
-        assert_panel_equal(result.to_pandas(), p)
+            # idempotency
+            assert_panel_equal(result.to_pandas(), p)
 
 
 class TestPanel4D(tm.TestCase, Generic):
@@ -1590,15 +1593,12 @@ class TestPanel4D(tm.TestCase, Generic):
     def test_sample(self):
         pytest.skip("sample on Panel4D")
 
-    def test_copy_and_deepcopy(self):
-        pytest.skip("copy_and_deepcopy on Panel4D")
-
     def test_to_xarray(self):
 
         tm._skip_if_no_xarray()
         from xarray import DataArray
 
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+        with catch_warnings(record=True):
             p = tm.makePanel4D()
 
             result = p.to_xarray()
@@ -1624,12 +1624,20 @@ for t in ['test_rename', 'test_rename_axis', 'test_get_numeric_data',
           'test_stat_unexpected_keyword', 'test_api_compat',
           'test_stat_non_defaults_args',
           'test_clip', 'test_truncate_out_of_bounds', 'test_numpy_clip',
-          'test_metadata_propagation']:
+          'test_metadata_propagation', 'test_copy_and_deepcopy',
+          'test_sample']:
+
+    def f():
+        def tester(self):
+            with catch_warnings(record=True):
+                return getattr(super(TestPanel, self), t)()
+        return tester
+
+    setattr(TestPanel, t, f())
 
     def f():
         def tester(self):
-            with tm.assert_produces_warning(FutureWarning,
-                                            check_stacklevel=False):
+            with catch_warnings(record=True):
                 return getattr(super(TestPanel4D, self), t)()
         return tester
 
@@ -1660,10 +1668,11 @@ class TestNDFrame(tm.TestCase):
         with tm.assertRaises(ValueError):
             s.sample(n=3, weights='weight_column')
 
-        panel = pd.Panel(items=[0, 1, 2], major_axis=[2, 3, 4],
-                         minor_axis=[3, 4, 5])
-        with tm.assertRaises(ValueError):
-            panel.sample(n=1, weights='weight_column')
+        with catch_warnings(record=True):
+            panel = Panel(items=[0, 1, 2], major_axis=[2, 3, 4],
+                          minor_axis=[3, 4, 5])
+            with tm.assertRaises(ValueError):
+                panel.sample(n=1, weights='weight_column')
 
         with tm.assertRaises(ValueError):
             df.sample(n=1, weights='weight_column', axis=1)
@@ -1726,14 +1735,15 @@ class TestNDFrame(tm.TestCase):
         assert_frame_equal(sample1, df[['colString']])
 
         # Test default axes
-        p = pd.Panel(items=['a', 'b', 'c'], major_axis=[2, 4, 6],
-                     minor_axis=[1, 3, 5])
-        assert_panel_equal(
-            p.sample(n=3, random_state=42), p.sample(n=3, axis=1,
-                                                     random_state=42))
-        assert_frame_equal(
-            df.sample(n=3, random_state=42), df.sample(n=3, axis=0,
-                                                       random_state=42))
+        with catch_warnings(record=True):
+            p = Panel(items=['a', 'b', 'c'], major_axis=[2, 4, 6],
+                      minor_axis=[1, 3, 5])
+            assert_panel_equal(
+                p.sample(n=3, random_state=42), p.sample(n=3, axis=1,
+                                                         random_state=42))
+            assert_frame_equal(
+                df.sample(n=3, random_state=42), df.sample(n=3, axis=0,
+                                                           random_state=42))
 
         # Test that function aligns weights with frame
         df = DataFrame(
@@ -1763,9 +1773,10 @@ class TestNDFrame(tm.TestCase):
             tm.assert_series_equal(s.squeeze(), s)
         for df in [tm.makeTimeDataFrame()]:
             tm.assert_frame_equal(df.squeeze(), df)
-        for p in [tm.makePanel()]:
-            tm.assert_panel_equal(p.squeeze(), p)
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+        with catch_warnings(record=True):
+            for p in [tm.makePanel()]:
+                tm.assert_panel_equal(p.squeeze(), p)
+        with catch_warnings(record=True):
             for p4d in [tm.makePanel4D()]:
                 tm.assert_panel4d_equal(p4d.squeeze(), p4d)
 
@@ -1773,24 +1784,26 @@ class TestNDFrame(tm.TestCase):
         df = tm.makeTimeDataFrame().reindex(columns=['A'])
         tm.assert_series_equal(df.squeeze(), df['A'])
 
-        p = tm.makePanel().reindex(items=['ItemA'])
-        tm.assert_frame_equal(p.squeeze(), p['ItemA'])
+        with catch_warnings(record=True):
+            p = tm.makePanel().reindex(items=['ItemA'])
+            tm.assert_frame_equal(p.squeeze(), p['ItemA'])
 
-        p = tm.makePanel().reindex(items=['ItemA'], minor_axis=['A'])
-        tm.assert_series_equal(p.squeeze(), p.loc['ItemA', :, 'A'])
+            p = tm.makePanel().reindex(items=['ItemA'], minor_axis=['A'])
+            tm.assert_series_equal(p.squeeze(), p.loc['ItemA', :, 'A'])
 
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+        with catch_warnings(record=True):
             p4d = tm.makePanel4D().reindex(labels=['label1'])
             tm.assert_panel_equal(p4d.squeeze(), p4d['label1'])
 
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+        with catch_warnings(record=True):
             p4d = tm.makePanel4D().reindex(labels=['label1'], items=['ItemA'])
             tm.assert_frame_equal(p4d.squeeze(), p4d.loc['label1', 'ItemA'])
 
         # don't fail with 0 length dimensions GH11229 & GH8999
-        empty_series = pd.Series([], name='five')
-        empty_frame = pd.DataFrame([empty_series])
-        empty_panel = pd.Panel({'six': empty_frame})
+        empty_series = Series([], name='five')
+        empty_frame = DataFrame([empty_series])
+        with catch_warnings(record=True):
+            empty_panel = Panel({'six': empty_frame})
 
         [tm.assert_series_equal(empty_series, higher_dim.squeeze())
          for higher_dim in [empty_series, empty_frame, empty_panel]]
@@ -1825,13 +1838,15 @@ class TestNDFrame(tm.TestCase):
             tm.assert_series_equal(s.transpose(), s)
         for df in [tm.makeTimeDataFrame()]:
             tm.assert_frame_equal(df.transpose().transpose(), df)
-        for p in [tm.makePanel()]:
-            tm.assert_panel_equal(p.transpose(2, 0, 1)
-                                  .transpose(1, 2, 0), p)
-            tm.assertRaisesRegexp(TypeError, msg, p.transpose,
-                                  2, 0, 1, axes=(2, 0, 1))
 
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+        with catch_warnings(record=True):
+            for p in [tm.makePanel()]:
+                tm.assert_panel_equal(p.transpose(2, 0, 1)
+                                      .transpose(1, 2, 0), p)
+                tm.assertRaisesRegexp(TypeError, msg, p.transpose,
+                                      2, 0, 1, axes=(2, 0, 1))
+
+        with catch_warnings(record=True):
             for p4d in [tm.makePanel4D()]:
                 tm.assert_panel4d_equal(p4d.transpose(2, 0, 3, 1)
                                         .transpose(1, 3, 0, 2), p4d)
@@ -1853,12 +1868,13 @@ class TestNDFrame(tm.TestCase):
         tm.assertRaisesRegexp(ValueError, msg,
                               np.transpose, df, axes=1)
 
-        p = tm.makePanel()
-        tm.assert_panel_equal(np.transpose(
-            np.transpose(p, axes=(2, 0, 1)),
-            axes=(1, 2, 0)), p)
+        with catch_warnings(record=True):
+            p = tm.makePanel()
+            tm.assert_panel_equal(np.transpose(
+                np.transpose(p, axes=(2, 0, 1)),
+                axes=(1, 2, 0)), p)
 
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+        with catch_warnings(record=True):
             p4d = tm.makePanel4D()
             tm.assert_panel4d_equal(np.transpose(
                 np.transpose(p4d, axes=(2, 0, 3, 1)),
@@ -1880,15 +1896,16 @@ class TestNDFrame(tm.TestCase):
             tm.assert_frame_equal(out, expected)
 
         indices = [-3, 2, 0, 1]
-        for p in [tm.makePanel()]:
-            out = p.take(indices)
-            expected = Panel(data=p.values.take(indices, axis=0),
-                             items=p.items.take(indices),
-                             major_axis=p.major_axis,
-                             minor_axis=p.minor_axis)
-            tm.assert_panel_equal(out, expected)
-
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+        with catch_warnings(record=True):
+            for p in [tm.makePanel()]:
+                out = p.take(indices)
+                expected = Panel(data=p.values.take(indices, axis=0),
+                                 items=p.items.take(indices),
+                                 major_axis=p.major_axis,
+                                 minor_axis=p.minor_axis)
+                tm.assert_panel_equal(out, expected)
+
+        with catch_warnings(record=True):
             for p4d in [tm.makePanel4D()]:
                 out = p4d.take(indices)
                 expected = Panel4D(data=p4d.values.take(indices, axis=0),
@@ -1902,9 +1919,9 @@ class TestNDFrame(tm.TestCase):
         indices = [-3, 2, 0, 1]
         s = tm.makeFloatSeries()
         df = tm.makeTimeDataFrame()
-        p = tm.makePanel()
 
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+        with catch_warnings(record=True):
+            p = tm.makePanel()
             p4d = tm.makePanel4D()
 
         for obj in (s, df, p, p4d):
@@ -2011,8 +2028,9 @@ class TestNDFrame(tm.TestCase):
         self.assertTrue(e.equals(f))
 
     def test_describe_raises(self):
-        with tm.assertRaises(NotImplementedError):
-            tm.makePanel().describe()
+        with catch_warnings(record=True):
+            with tm.assertRaises(NotImplementedError):
+                tm.makePanel().describe()
 
     def test_pipe(self):
         df = DataFrame({'A': [1, 2, 3]})
@@ -2043,15 +2061,16 @@ class TestNDFrame(tm.TestCase):
             df.A.pipe((f, 'y'), x=1, y=0)
 
     def test_pipe_panel(self):
-        wp = Panel({'r1': DataFrame({"A": [1, 2, 3]})})
-        f = lambda x, y: x + y
-        result = wp.pipe(f, 2)
-        expected = wp + 2
-        assert_panel_equal(result, expected)
-
-        result = wp.pipe((f, 'y'), x=1)
-        expected = wp + 1
-        assert_panel_equal(result, expected)
-
-        with tm.assertRaises(ValueError):
-            result = wp.pipe((f, 'y'), x=1, y=1)
+        with catch_warnings(record=True):
+            wp = Panel({'r1': DataFrame({"A": [1, 2, 3]})})
+            f = lambda x, y: x + y
+            result = wp.pipe(f, 2)
+            expected = wp + 2
+            assert_panel_equal(result, expected)
+
+            result = wp.pipe((f, 'y'), x=1)
+            expected = wp + 1
+            assert_panel_equal(result, expected)
+
+            with tm.assertRaises(ValueError):
+                result = wp.pipe((f, 'y'), x=1, y=1)
diff --git a/pandas/tests/test_panel.py b/pandas/tests/test_panel.py
index ab0322abb..bc7bb8a4d 100644
--- a/pandas/tests/test_panel.py
+++ b/pandas/tests/test_panel.py
@@ -3,7 +3,6 @@
 
 from warnings import catch_warnings
 from datetime import datetime
-
 import operator
 import pytest
 
@@ -31,25 +30,37 @@ import pandas.core.panel as panelm
 import pandas.util.testing as tm
 
 
+def make_test_panel():
+    with catch_warnings(record=True):
+        _panel = tm.makePanel()
+        tm.add_nans(_panel)
+        _panel = _panel.copy()
+    return _panel
+
+
 class PanelTests(object):
     panel = None
 
     def test_pickle(self):
-        unpickled = self.round_trip_pickle(self.panel)
-        assert_frame_equal(unpickled['ItemA'], self.panel['ItemA'])
+        with catch_warnings(record=True):
+            unpickled = self.round_trip_pickle(self.panel)
+            assert_frame_equal(unpickled['ItemA'], self.panel['ItemA'])
 
     def test_rank(self):
-        self.assertRaises(NotImplementedError, lambda: self.panel.rank())
+        with catch_warnings(record=True):
+            self.assertRaises(NotImplementedError, lambda: self.panel.rank())
 
     def test_cumsum(self):
-        cumsum = self.panel.cumsum()
-        assert_frame_equal(cumsum['ItemA'], self.panel['ItemA'].cumsum())
+        with catch_warnings(record=True):
+            cumsum = self.panel.cumsum()
+            assert_frame_equal(cumsum['ItemA'], self.panel['ItemA'].cumsum())
 
     def not_hashable(self):
-        c_empty = Panel()
-        c = Panel(Panel([[[1]]]))
-        self.assertRaises(TypeError, hash, c_empty)
-        self.assertRaises(TypeError, hash, c)
+        with catch_warnings(record=True):
+            c_empty = Panel()
+            c = Panel(Panel([[[1]]]))
+            self.assertRaises(TypeError, hash, c_empty)
+            self.assertRaises(TypeError, hash, c)
 
 
 class SafeForLongAndSparse(object):
@@ -58,11 +69,12 @@ class SafeForLongAndSparse(object):
         repr(self.panel)
 
     def test_copy_names(self):
-        for attr in ('major_axis', 'minor_axis'):
-            getattr(self.panel, attr).name = None
-            cp = self.panel.copy()
-            getattr(cp, attr).name = 'foo'
-            self.assertIsNone(getattr(self.panel, attr).name)
+        with catch_warnings(record=True):
+            for attr in ('major_axis', 'minor_axis'):
+                getattr(self.panel, attr).name = None
+                cp = self.panel.copy()
+                getattr(cp, attr).name = 'foo'
+                self.assertIsNone(getattr(self.panel, attr).name)
 
     def test_iter(self):
         tm.equalContents(list(self.panel), self.panel.items)
@@ -107,10 +119,6 @@ class SafeForLongAndSparse(object):
 
         self._check_stat_op('skew', this_skew)
 
-    # def test_mad(self):
-    #     f = lambda x: np.abs(x - x.mean()).mean()
-    #     self._check_stat_op('mad', f)
-
     def test_var(self):
         def alt(x):
             if len(x) < 2:
@@ -239,47 +247,48 @@ class SafeForSparse(object):
         index, columns = self.panel._get_plane_axes(0)
 
     def test_truncate(self):
-        dates = self.panel.major_axis
-        start, end = dates[1], dates[5]
-
-        trunced = self.panel.truncate(start, end, axis='major')
-        expected = self.panel['ItemA'].truncate(start, end)
+        with catch_warnings(record=True):
+            dates = self.panel.major_axis
+            start, end = dates[1], dates[5]
 
-        assert_frame_equal(trunced['ItemA'], expected)
+            trunced = self.panel.truncate(start, end, axis='major')
+            expected = self.panel['ItemA'].truncate(start, end)
 
-        trunced = self.panel.truncate(before=start, axis='major')
-        expected = self.panel['ItemA'].truncate(before=start)
+            assert_frame_equal(trunced['ItemA'], expected)
 
-        assert_frame_equal(trunced['ItemA'], expected)
+            trunced = self.panel.truncate(before=start, axis='major')
+            expected = self.panel['ItemA'].truncate(before=start)
 
-        trunced = self.panel.truncate(after=end, axis='major')
-        expected = self.panel['ItemA'].truncate(after=end)
+            assert_frame_equal(trunced['ItemA'], expected)
 
-        assert_frame_equal(trunced['ItemA'], expected)
+            trunced = self.panel.truncate(after=end, axis='major')
+            expected = self.panel['ItemA'].truncate(after=end)
 
-        # XXX test other axes
+            assert_frame_equal(trunced['ItemA'], expected)
 
     def test_arith(self):
-        self._test_op(self.panel, operator.add)
-        self._test_op(self.panel, operator.sub)
-        self._test_op(self.panel, operator.mul)
-        self._test_op(self.panel, operator.truediv)
-        self._test_op(self.panel, operator.floordiv)
-        self._test_op(self.panel, operator.pow)
-
-        self._test_op(self.panel, lambda x, y: y + x)
-        self._test_op(self.panel, lambda x, y: y - x)
-        self._test_op(self.panel, lambda x, y: y * x)
-        self._test_op(self.panel, lambda x, y: y / x)
-        self._test_op(self.panel, lambda x, y: y ** x)
-
-        self._test_op(self.panel, lambda x, y: x + y)  # panel + 1
-        self._test_op(self.panel, lambda x, y: x - y)  # panel - 1
-        self._test_op(self.panel, lambda x, y: x * y)  # panel * 1
-        self._test_op(self.panel, lambda x, y: x / y)  # panel / 1
-        self._test_op(self.panel, lambda x, y: x ** y)  # panel ** 1
-
-        self.assertRaises(Exception, self.panel.__add__, self.panel['ItemA'])
+        with catch_warnings(record=True):
+            self._test_op(self.panel, operator.add)
+            self._test_op(self.panel, operator.sub)
+            self._test_op(self.panel, operator.mul)
+            self._test_op(self.panel, operator.truediv)
+            self._test_op(self.panel, operator.floordiv)
+            self._test_op(self.panel, operator.pow)
+
+            self._test_op(self.panel, lambda x, y: y + x)
+            self._test_op(self.panel, lambda x, y: y - x)
+            self._test_op(self.panel, lambda x, y: y * x)
+            self._test_op(self.panel, lambda x, y: y / x)
+            self._test_op(self.panel, lambda x, y: y ** x)
+
+            self._test_op(self.panel, lambda x, y: x + y)  # panel + 1
+            self._test_op(self.panel, lambda x, y: x - y)  # panel - 1
+            self._test_op(self.panel, lambda x, y: x * y)  # panel * 1
+            self._test_op(self.panel, lambda x, y: x / y)  # panel / 1
+            self._test_op(self.panel, lambda x, y: x ** y)  # panel ** 1
+
+            self.assertRaises(Exception, self.panel.__add__,
+                              self.panel['ItemA'])
 
     @staticmethod
     def _test_op(panel, op):
@@ -299,92 +308,100 @@ class SafeForSparse(object):
                          len(self.panel.items))
 
     def test_combineFrame(self):
-        def check_op(op, name):
-            # items
-            df = self.panel['ItemA']
+        with catch_warnings(record=True):
+            def check_op(op, name):
+                # items
+                df = self.panel['ItemA']
 
-            func = getattr(self.panel, name)
+                func = getattr(self.panel, name)
 
-            result = func(df, axis='items')
+                result = func(df, axis='items')
 
-            assert_frame_equal(result['ItemB'], op(self.panel['ItemB'], df))
+                assert_frame_equal(
+                    result['ItemB'], op(self.panel['ItemB'], df))
 
-            # major
-            xs = self.panel.major_xs(self.panel.major_axis[0])
-            result = func(xs, axis='major')
+                # major
+                xs = self.panel.major_xs(self.panel.major_axis[0])
+                result = func(xs, axis='major')
 
-            idx = self.panel.major_axis[1]
+                idx = self.panel.major_axis[1]
 
-            assert_frame_equal(result.major_xs(idx),
-                               op(self.panel.major_xs(idx), xs))
+                assert_frame_equal(result.major_xs(idx),
+                                   op(self.panel.major_xs(idx), xs))
 
-            # minor
-            xs = self.panel.minor_xs(self.panel.minor_axis[0])
-            result = func(xs, axis='minor')
+                # minor
+                xs = self.panel.minor_xs(self.panel.minor_axis[0])
+                result = func(xs, axis='minor')
 
-            idx = self.panel.minor_axis[1]
+                idx = self.panel.minor_axis[1]
 
-            assert_frame_equal(result.minor_xs(idx),
-                               op(self.panel.minor_xs(idx), xs))
+                assert_frame_equal(result.minor_xs(idx),
+                                   op(self.panel.minor_xs(idx), xs))
 
-        ops = ['add', 'sub', 'mul', 'truediv', 'floordiv', 'pow', 'mod']
-        if not compat.PY3:
-            ops.append('div')
+            ops = ['add', 'sub', 'mul', 'truediv', 'floordiv', 'pow', 'mod']
+            if not compat.PY3:
+                ops.append('div')
 
-        for op in ops:
-            try:
-                check_op(getattr(operator, op), op)
-            except:
-                pprint_thing("Failing operation: %r" % op)
-                raise
-        if compat.PY3:
-            try:
-                check_op(operator.truediv, 'div')
-            except:
-                pprint_thing("Failing operation: %r" % 'div')
-                raise
+            for op in ops:
+                try:
+                    check_op(getattr(operator, op), op)
+                except:
+                    pprint_thing("Failing operation: %r" % op)
+                    raise
+            if compat.PY3:
+                try:
+                    check_op(operator.truediv, 'div')
+                except:
+                    pprint_thing("Failing operation: %r" % 'div')
+                    raise
 
     def test_combinePanel(self):
-        result = self.panel.add(self.panel)
-        self.assert_panel_equal(result, self.panel * 2)
+        with catch_warnings(record=True):
+            result = self.panel.add(self.panel)
+            assert_panel_equal(result, self.panel * 2)
 
     def test_neg(self):
-        self.assert_panel_equal(-self.panel, self.panel * -1)
+        with catch_warnings(record=True):
+            assert_panel_equal(-self.panel, self.panel * -1)
 
     # issue 7692
     def test_raise_when_not_implemented(self):
-        p = Panel(np.arange(3 * 4 * 5).reshape(3, 4, 5),
-                  items=['ItemA', 'ItemB', 'ItemC'],
-                  major_axis=pd.date_range('20130101', periods=4),
-                  minor_axis=list('ABCDE'))
-        d = p.sum(axis=1).iloc[0]
-        ops = ['add', 'sub', 'mul', 'truediv', 'floordiv', 'div', 'mod', 'pow']
-        for op in ops:
-            with self.assertRaises(NotImplementedError):
-                getattr(p, op)(d, axis=0)
+        with catch_warnings(record=True):
+            p = Panel(np.arange(3 * 4 * 5).reshape(3, 4, 5),
+                      items=['ItemA', 'ItemB', 'ItemC'],
+                      major_axis=pd.date_range('20130101', periods=4),
+                      minor_axis=list('ABCDE'))
+            d = p.sum(axis=1).iloc[0]
+            ops = ['add', 'sub', 'mul', 'truediv',
+                   'floordiv', 'div', 'mod', 'pow']
+            for op in ops:
+                with self.assertRaises(NotImplementedError):
+                    getattr(p, op)(d, axis=0)
 
     def test_select(self):
-        p = self.panel
+        with catch_warnings(record=True):
+            p = self.panel
 
-        # select items
-        result = p.select(lambda x: x in ('ItemA', 'ItemC'), axis='items')
-        expected = p.reindex(items=['ItemA', 'ItemC'])
-        self.assert_panel_equal(result, expected)
+            # select items
+            result = p.select(lambda x: x in ('ItemA', 'ItemC'), axis='items')
+            expected = p.reindex(items=['ItemA', 'ItemC'])
+            assert_panel_equal(result, expected)
 
-        # select major_axis
-        result = p.select(lambda x: x >= datetime(2000, 1, 15), axis='major')
-        new_major = p.major_axis[p.major_axis >= datetime(2000, 1, 15)]
-        expected = p.reindex(major=new_major)
-        self.assert_panel_equal(result, expected)
+            # select major_axis
+            result = p.select(lambda x: x >= datetime(
+                2000, 1, 15), axis='major')
+            new_major = p.major_axis[p.major_axis >= datetime(2000, 1, 15)]
+            expected = p.reindex(major=new_major)
+            assert_panel_equal(result, expected)
 
-        # select minor_axis
-        result = p.select(lambda x: x in ('D', 'A'), axis=2)
-        expected = p.reindex(minor=['A', 'D'])
-        self.assert_panel_equal(result, expected)
+            # select minor_axis
+            result = p.select(lambda x: x in ('D', 'A'), axis=2)
+            expected = p.reindex(minor=['A', 'D'])
+            assert_panel_equal(result, expected)
 
-        # corner case, empty thing
-        result = p.select(lambda x: x in ('foo', ), axis='items')
-        self.assert_panel_equal(result, p.reindex(items=[]))
+            # corner case, empty thing
+            result = p.select(lambda x: x in ('foo', ), axis='items')
+            assert_panel_equal(result, p.reindex(items=[]))
 
     def test_get_value(self):
         for item in self.panel.items:
@@ -396,27 +413,28 @@ class SafeForSparse(object):
 
     def test_abs(self):
 
-        result = self.panel.abs()
-        result2 = abs(self.panel)
-        expected = np.abs(self.panel)
-        self.assert_panel_equal(result, expected)
-        self.assert_panel_equal(result2, expected)
-
-        df = self.panel['ItemA']
-        result = df.abs()
-        result2 = abs(df)
-        expected = np.abs(df)
-        assert_frame_equal(result, expected)
-        assert_frame_equal(result2, expected)
+        with catch_warnings(record=True):
+            result = self.panel.abs()
+            result2 = abs(self.panel)
+            expected = np.abs(self.panel)
+            assert_panel_equal(result, expected)
+            assert_panel_equal(result2, expected)
 
-        s = df['A']
-        result = s.abs()
-        result2 = abs(s)
-        expected = np.abs(s)
-        assert_series_equal(result, expected)
-        assert_series_equal(result2, expected)
-        self.assertEqual(result.name, 'A')
-        self.assertEqual(result2.name, 'A')
+            df = self.panel['ItemA']
+            result = df.abs()
+            result2 = abs(df)
+            expected = np.abs(df)
+            assert_frame_equal(result, expected)
+            assert_frame_equal(result2, expected)
+
+            s = df['A']
+            result = s.abs()
+            result2 = abs(s)
+            expected = np.abs(s)
+            assert_series_equal(result, expected)
+            assert_series_equal(result2, expected)
+            self.assertEqual(result.name, 'A')
+            self.assertEqual(result2.name, 'A')
 
 
 class CheckIndexing(object):
@@ -425,188 +443,200 @@ class CheckIndexing(object):
         self.assertRaises(Exception, self.panel.__getitem__, 'ItemQ')
 
     def test_delitem_and_pop(self):
-        expected = self.panel['ItemA']
-        result = self.panel.pop('ItemA')
-        assert_frame_equal(expected, result)
-        self.assertNotIn('ItemA', self.panel.items)
+        with catch_warnings(record=True):
+            expected = self.panel['ItemA']
+            result = self.panel.pop('ItemA')
+            assert_frame_equal(expected, result)
+            self.assertNotIn('ItemA', self.panel.items)
 
-        del self.panel['ItemB']
-        self.assertNotIn('ItemB', self.panel.items)
-        self.assertRaises(Exception, self.panel.__delitem__, 'ItemB')
+            del self.panel['ItemB']
+            self.assertNotIn('ItemB', self.panel.items)
+            self.assertRaises(Exception, self.panel.__delitem__, 'ItemB')
 
-        values = np.empty((3, 3, 3))
-        values[0] = 0
-        values[1] = 1
-        values[2] = 2
+            values = np.empty((3, 3, 3))
+            values[0] = 0
+            values[1] = 1
+            values[2] = 2
 
-        panel = Panel(values, lrange(3), lrange(3), lrange(3))
+            panel = Panel(values, lrange(3), lrange(3), lrange(3))
 
-        # did we delete the right row?
+            # did we delete the right row?
 
-        panelc = panel.copy()
-        del panelc[0]
-        assert_frame_equal(panelc[1], panel[1])
-        assert_frame_equal(panelc[2], panel[2])
+            panelc = panel.copy()
+            del panelc[0]
+            assert_frame_equal(panelc[1], panel[1])
+            assert_frame_equal(panelc[2], panel[2])
 
-        panelc = panel.copy()
-        del panelc[1]
-        assert_frame_equal(panelc[0], panel[0])
-        assert_frame_equal(panelc[2], panel[2])
+            panelc = panel.copy()
+            del panelc[1]
+            assert_frame_equal(panelc[0], panel[0])
+            assert_frame_equal(panelc[2], panel[2])
 
-        panelc = panel.copy()
-        del panelc[2]
-        assert_frame_equal(panelc[1], panel[1])
-        assert_frame_equal(panelc[0], panel[0])
+            panelc = panel.copy()
+            del panelc[2]
+            assert_frame_equal(panelc[1], panel[1])
+            assert_frame_equal(panelc[0], panel[0])
 
     def test_setitem(self):
-        # LongPanel with one item
-        lp = self.panel.filter(['ItemA', 'ItemB']).to_frame()
-        with tm.assertRaises(ValueError):
-            self.panel['ItemE'] = lp
+        with catch_warnings(record=True):
 
-        # DataFrame
-        df = self.panel['ItemA'][2:].filter(items=['A', 'B'])
-        self.panel['ItemF'] = df
-        self.panel['ItemE'] = df
+            # LongPanel with one item
+            lp = self.panel.filter(['ItemA', 'ItemB']).to_frame()
+            with tm.assertRaises(ValueError):
+                self.panel['ItemE'] = lp
 
-        df2 = self.panel['ItemF']
+            # DataFrame
+            df = self.panel['ItemA'][2:].filter(items=['A', 'B'])
+            self.panel['ItemF'] = df
+            self.panel['ItemE'] = df
 
-        assert_frame_equal(df, df2.reindex(index=df.index, columns=df.columns))
+            df2 = self.panel['ItemF']
 
-        # scalar
-        self.panel['ItemG'] = 1
-        self.panel['ItemE'] = True
-        self.assertEqual(self.panel['ItemG'].values.dtype, np.int64)
-        self.assertEqual(self.panel['ItemE'].values.dtype, np.bool_)
+            assert_frame_equal(df, df2.reindex(
+                index=df.index, columns=df.columns))
 
-        # object dtype
-        self.panel['ItemQ'] = 'foo'
-        self.assertEqual(self.panel['ItemQ'].values.dtype, np.object_)
+            # scalar
+            self.panel['ItemG'] = 1
+            self.panel['ItemE'] = True
+            self.assertEqual(self.panel['ItemG'].values.dtype, np.int64)
+            self.assertEqual(self.panel['ItemE'].values.dtype, np.bool_)
 
-        # boolean dtype
-        self.panel['ItemP'] = self.panel['ItemA'] > 0
-        self.assertEqual(self.panel['ItemP'].values.dtype, np.bool_)
+            # object dtype
+            self.panel['ItemQ'] = 'foo'
+            self.assertEqual(self.panel['ItemQ'].values.dtype, np.object_)
 
-        self.assertRaises(TypeError, self.panel.__setitem__, 'foo',
-                          self.panel.loc[['ItemP']])
+            # boolean dtype
+            self.panel['ItemP'] = self.panel['ItemA'] > 0
+            self.assertEqual(self.panel['ItemP'].values.dtype, np.bool_)
 
-        # bad shape
-        p = Panel(np.random.randn(4, 3, 2))
-        with tm.assertRaisesRegexp(ValueError,
-                                   r"shape of value must be \(3, 2\), "
-                                   r"shape of given object was \(4, 2\)"):
-            p[0] = np.random.randn(4, 2)
+            self.assertRaises(TypeError, self.panel.__setitem__, 'foo',
+                              self.panel.loc[['ItemP']])
+
+            # bad shape
+            p = Panel(np.random.randn(4, 3, 2))
+            with tm.assertRaisesRegexp(ValueError,
+                                       r"shape of value must be \(3, 2\), "
+                                       r"shape of given object was \(4, 2\)"):
+                p[0] = np.random.randn(4, 2)
 
     def test_setitem_ndarray(self):
-        timeidx = date_range(start=datetime(2009, 1, 1),
-                             end=datetime(2009, 12, 31),
-                             freq=MonthEnd())
-        lons_coarse = np.linspace(-177.5, 177.5, 72)
-        lats_coarse = np.linspace(-87.5, 87.5, 36)
-        P = Panel(items=timeidx, major_axis=lons_coarse,
-                  minor_axis=lats_coarse)
-        data = np.random.randn(72 * 36).reshape((72, 36))
-        key = datetime(2009, 2, 28)
-        P[key] = data
-
-        assert_almost_equal(P[key].values, data)
+        with catch_warnings(record=True):
+            timeidx = date_range(start=datetime(2009, 1, 1),
+                                 end=datetime(2009, 12, 31),
+                                 freq=MonthEnd())
+            lons_coarse = np.linspace(-177.5, 177.5, 72)
+            lats_coarse = np.linspace(-87.5, 87.5, 36)
+            P = Panel(items=timeidx, major_axis=lons_coarse,
+                      minor_axis=lats_coarse)
+            data = np.random.randn(72 * 36).reshape((72, 36))
+            key = datetime(2009, 2, 28)
+            P[key] = data
+
+            assert_almost_equal(P[key].values, data)
 
     def test_set_minor_major(self):
-        # GH 11014
-        df1 = DataFrame(['a', 'a', 'a', np.nan, 'a', np.nan])
-        df2 = DataFrame([1.0, np.nan, 1.0, np.nan, 1.0, 1.0])
-        panel = Panel({'Item1': df1, 'Item2': df2})
+        with catch_warnings(record=True):
+            # GH 11014
+            df1 = DataFrame(['a', 'a', 'a', np.nan, 'a', np.nan])
+            df2 = DataFrame([1.0, np.nan, 1.0, np.nan, 1.0, 1.0])
+            panel = Panel({'Item1': df1, 'Item2': df2})
 
-        newminor = notnull(panel.iloc[:, :, 0])
-        panel.loc[:, :, 'NewMinor'] = newminor
-        assert_frame_equal(panel.loc[:, :, 'NewMinor'],
-                           newminor.astype(object))
+            newminor = notnull(panel.iloc[:, :, 0])
+            panel.loc[:, :, 'NewMinor'] = newminor
+            assert_frame_equal(panel.loc[:, :, 'NewMinor'],
+                               newminor.astype(object))
 
-        newmajor = notnull(panel.iloc[:, 0, :])
-        panel.loc[:, 'NewMajor', :] = newmajor
-        assert_frame_equal(panel.loc[:, 'NewMajor', :],
-                           newmajor.astype(object))
+            newmajor = notnull(panel.iloc[:, 0, :])
+            panel.loc[:, 'NewMajor', :] = newmajor
+            assert_frame_equal(panel.loc[:, 'NewMajor', :],
+                               newmajor.astype(object))
 
     def test_major_xs(self):
-        ref = self.panel['ItemA']
+        with catch_warnings(record=True):
+            ref = self.panel['ItemA']
 
-        idx = self.panel.major_axis[5]
-        xs = self.panel.major_xs(idx)
+            idx = self.panel.major_axis[5]
+            xs = self.panel.major_xs(idx)
 
-        result = xs['ItemA']
-        assert_series_equal(result, ref.xs(idx), check_names=False)
-        self.assertEqual(result.name, 'ItemA')
+            result = xs['ItemA']
+            assert_series_equal(result, ref.xs(idx), check_names=False)
+            self.assertEqual(result.name, 'ItemA')
 
-        # not contained
-        idx = self.panel.major_axis[0] - BDay()
-        self.assertRaises(Exception, self.panel.major_xs, idx)
+            # not contained
+            idx = self.panel.major_axis[0] - BDay()
+            self.assertRaises(Exception, self.panel.major_xs, idx)
 
     def test_major_xs_mixed(self):
-        self.panel['ItemD'] = 'foo'
-        xs = self.panel.major_xs(self.panel.major_axis[0])
-        self.assertEqual(xs['ItemA'].dtype, np.float64)
-        self.assertEqual(xs['ItemD'].dtype, np.object_)
+        with catch_warnings(record=True):
+            self.panel['ItemD'] = 'foo'
+            xs = self.panel.major_xs(self.panel.major_axis[0])
+            self.assertEqual(xs['ItemA'].dtype, np.float64)
+            self.assertEqual(xs['ItemD'].dtype, np.object_)
 
     def test_minor_xs(self):
-        ref = self.panel['ItemA']
+        with catch_warnings(record=True):
+            ref = self.panel['ItemA']
 
-        idx = self.panel.minor_axis[1]
-        xs = self.panel.minor_xs(idx)
+            idx = self.panel.minor_axis[1]
+            xs = self.panel.minor_xs(idx)
 
-        assert_series_equal(xs['ItemA'], ref[idx], check_names=False)
+            assert_series_equal(xs['ItemA'], ref[idx], check_names=False)
 
-        # not contained
-        self.assertRaises(Exception, self.panel.minor_xs, 'E')
+            # not contained
+            self.assertRaises(Exception, self.panel.minor_xs, 'E')
 
     def test_minor_xs_mixed(self):
-        self.panel['ItemD'] = 'foo'
+        with catch_warnings(record=True):
+            self.panel['ItemD'] = 'foo'
 
-        xs = self.panel.minor_xs('D')
-        self.assertEqual(xs['ItemA'].dtype, np.float64)
-        self.assertEqual(xs['ItemD'].dtype, np.object_)
+            xs = self.panel.minor_xs('D')
+            self.assertEqual(xs['ItemA'].dtype, np.float64)
+            self.assertEqual(xs['ItemD'].dtype, np.object_)
 
     def test_xs(self):
-        itemA = self.panel.xs('ItemA', axis=0)
-        expected = self.panel['ItemA']
-        assert_frame_equal(itemA, expected)
+        with catch_warnings(record=True):
+            itemA = self.panel.xs('ItemA', axis=0)
+            expected = self.panel['ItemA']
+            assert_frame_equal(itemA, expected)
 
-        # get a view by default
-        itemA_view = self.panel.xs('ItemA', axis=0)
-        itemA_view.values[:] = np.nan
-        self.assertTrue(np.isnan(self.panel['ItemA'].values).all())
+            # get a view by default
+            itemA_view = self.panel.xs('ItemA', axis=0)
+            itemA_view.values[:] = np.nan
+            self.assertTrue(np.isnan(self.panel['ItemA'].values).all())
 
-        # mixed-type yields a copy
-        self.panel['strings'] = 'foo'
-        result = self.panel.xs('D', axis=2)
-        self.assertIsNotNone(result.is_copy)
+            # mixed-type yields a copy
+            self.panel['strings'] = 'foo'
+            result = self.panel.xs('D', axis=2)
+            self.assertIsNotNone(result.is_copy)
 
     def test_getitem_fancy_labels(self):
-        p = self.panel
+        with catch_warnings(record=True):
+            p = self.panel
 
-        items = p.items[[1, 0]]
-        dates = p.major_axis[::2]
-        cols = ['D', 'C', 'F']
+            items = p.items[[1, 0]]
+            dates = p.major_axis[::2]
+            cols = ['D', 'C', 'F']
 
-        # all 3 specified
-        assert_panel_equal(p.loc[items, dates, cols],
-                           p.reindex(items=items, major=dates, minor=cols))
+            # all 3 specified
+            assert_panel_equal(p.loc[items, dates, cols],
+                               p.reindex(items=items, major=dates, minor=cols))
 
-        # 2 specified
-        assert_panel_equal(p.loc[:, dates, cols],
-                           p.reindex(major=dates, minor=cols))
+            # 2 specified
+            assert_panel_equal(p.loc[:, dates, cols],
+                               p.reindex(major=dates, minor=cols))
 
-        assert_panel_equal(p.loc[items, :, cols],
-                           p.reindex(items=items, minor=cols))
+            assert_panel_equal(p.loc[items, :, cols],
+                               p.reindex(items=items, minor=cols))
 
-        assert_panel_equal(p.loc[items, dates, :],
-                           p.reindex(items=items, major=dates))
+            assert_panel_equal(p.loc[items, dates, :],
+                               p.reindex(items=items, major=dates))
 
-        # only 1
-        assert_panel_equal(p.loc[items, :, :], p.reindex(items=items))
+            # only 1
+            assert_panel_equal(p.loc[items, :, :], p.reindex(items=items))
 
-        assert_panel_equal(p.loc[:, dates, :], p.reindex(major=dates))
+            assert_panel_equal(p.loc[:, dates, :], p.reindex(major=dates))
 
-        assert_panel_equal(p.loc[:, :, cols], p.reindex(minor=cols))
+            assert_panel_equal(p.loc[:, :, cols], p.reindex(minor=cols))
 
     def test_getitem_fancy_slice(self):
         pass
@@ -646,127 +676,132 @@ class CheckIndexing(object):
         assert_series_equal(p.loc[:, date, col], p.major_xs(date).loc[col])
 
     def test_getitem_fancy_xs_check_view(self):
-        item = 'ItemB'
-        date = self.panel.major_axis[5]
-
-        # make sure it's always a view
-        NS = slice(None, None)
-
-        # DataFrames
-        comp = assert_frame_equal
-        self._check_view(item, comp)
-        self._check_view((item, NS), comp)
-        self._check_view((item, NS, NS), comp)
-        self._check_view((NS, date), comp)
-        self._check_view((NS, date, NS), comp)
-        self._check_view((NS, NS, 'C'), comp)
-
-        # Series
-        comp = assert_series_equal
-        self._check_view((item, date), comp)
-        self._check_view((item, date, NS), comp)
-        self._check_view((item, NS, 'C'), comp)
-        self._check_view((NS, date, 'C'), comp)
+        with catch_warnings(record=True):
+            item = 'ItemB'
+            date = self.panel.major_axis[5]
+
+            # make sure it's always a view
+            NS = slice(None, None)
+
+            # DataFrames
+            comp = assert_frame_equal
+            self._check_view(item, comp)
+            self._check_view((item, NS), comp)
+            self._check_view((item, NS, NS), comp)
+            self._check_view((NS, date), comp)
+            self._check_view((NS, date, NS), comp)
+            self._check_view((NS, NS, 'C'), comp)
+
+            # Series
+            comp = assert_series_equal
+            self._check_view((item, date), comp)
+            self._check_view((item, date, NS), comp)
+            self._check_view((item, NS, 'C'), comp)
+            self._check_view((NS, date, 'C'), comp)
 
     def test_getitem_callable(self):
-        p = self.panel
-        # GH 12533
+        with catch_warnings(record=True):
+            p = self.panel
+            # GH 12533
 
-        assert_frame_equal(p[lambda x: 'ItemB'], p.loc['ItemB'])
-        assert_panel_equal(p[lambda x: ['ItemB', 'ItemC']],
-                           p.loc[['ItemB', 'ItemC']])
+            assert_frame_equal(p[lambda x: 'ItemB'], p.loc['ItemB'])
+            assert_panel_equal(p[lambda x: ['ItemB', 'ItemC']],
+                               p.loc[['ItemB', 'ItemC']])
 
     def test_ix_setitem_slice_dataframe(self):
-        a = Panel(items=[1, 2, 3], major_axis=[11, 22, 33],
-                  minor_axis=[111, 222, 333])
-        b = DataFrame(np.random.randn(2, 3), index=[111, 333],
-                      columns=[1, 2, 3])
+        with catch_warnings(record=True):
+            a = Panel(items=[1, 2, 3], major_axis=[11, 22, 33],
+                      minor_axis=[111, 222, 333])
+            b = DataFrame(np.random.randn(2, 3), index=[111, 333],
+                          columns=[1, 2, 3])
 
-        a.loc[:, 22, [111, 333]] = b
+            a.loc[:, 22, [111, 333]] = b
 
-        assert_frame_equal(a.loc[:, 22, [111, 333]], b)
+            assert_frame_equal(a.loc[:, 22, [111, 333]], b)
 
     def test_ix_align(self):
-        from pandas import Series
-        b = Series(np.random.randn(10), name=0)
-        b.sort_values()
-        df_orig = Panel(np.random.randn(3, 10, 2))
-        df = df_orig.copy()
+        with catch_warnings(record=True):
+            from pandas import Series
+            b = Series(np.random.randn(10), name=0)
+            b.sort_values()
+            df_orig = Panel(np.random.randn(3, 10, 2))
+            df = df_orig.copy()
 
-        df.loc[0, :, 0] = b
-        assert_series_equal(df.loc[0, :, 0].reindex(b.index), b)
+            df.loc[0, :, 0] = b
+            assert_series_equal(df.loc[0, :, 0].reindex(b.index), b)
 
-        df = df_orig.swapaxes(0, 1)
-        df.loc[:, 0, 0] = b
-        assert_series_equal(df.loc[:, 0, 0].reindex(b.index), b)
+            df = df_orig.swapaxes(0, 1)
+            df.loc[:, 0, 0] = b
+            assert_series_equal(df.loc[:, 0, 0].reindex(b.index), b)
 
-        df = df_orig.swapaxes(1, 2)
-        df.loc[0, 0, :] = b
-        assert_series_equal(df.loc[0, 0, :].reindex(b.index), b)
+            df = df_orig.swapaxes(1, 2)
+            df.loc[0, 0, :] = b
+            assert_series_equal(df.loc[0, 0, :].reindex(b.index), b)
 
     def test_ix_frame_align(self):
-        p_orig = tm.makePanel()
-        df = p_orig.iloc[0].copy()
-        assert_frame_equal(p_orig['ItemA'], df)
+        with catch_warnings(record=True):
+            p_orig = tm.makePanel()
+            df = p_orig.iloc[0].copy()
+            assert_frame_equal(p_orig['ItemA'], df)
 
-        p = p_orig.copy()
-        p.iloc[0, :, :] = df
-        assert_panel_equal(p, p_orig)
+            p = p_orig.copy()
+            p.iloc[0, :, :] = df
+            assert_panel_equal(p, p_orig)
 
-        p = p_orig.copy()
-        p.iloc[0] = df
-        assert_panel_equal(p, p_orig)
+            p = p_orig.copy()
+            p.iloc[0] = df
+            assert_panel_equal(p, p_orig)
 
-        p = p_orig.copy()
-        p.iloc[0, :, :] = df
-        assert_panel_equal(p, p_orig)
+            p = p_orig.copy()
+            p.iloc[0, :, :] = df
+            assert_panel_equal(p, p_orig)
 
-        p = p_orig.copy()
-        p.iloc[0] = df
-        assert_panel_equal(p, p_orig)
+            p = p_orig.copy()
+            p.iloc[0] = df
+            assert_panel_equal(p, p_orig)
 
-        p = p_orig.copy()
-        p.loc['ItemA'] = df
-        assert_panel_equal(p, p_orig)
+            p = p_orig.copy()
+            p.loc['ItemA'] = df
+            assert_panel_equal(p, p_orig)
 
-        p = p_orig.copy()
-        p.loc['ItemA', :, :] = df
-        assert_panel_equal(p, p_orig)
+            p = p_orig.copy()
+            p.loc['ItemA', :, :] = df
+            assert_panel_equal(p, p_orig)
 
-        p = p_orig.copy()
-        p['ItemA'] = df
-        assert_panel_equal(p, p_orig)
+            p = p_orig.copy()
+            p['ItemA'] = df
+            assert_panel_equal(p, p_orig)
 
-        p = p_orig.copy()
-        p.iloc[0, [0, 1, 3, 5], -2:] = df
-        out = p.iloc[0, [0, 1, 3, 5], -2:]
-        assert_frame_equal(out, df.iloc[[0, 1, 3, 5], [2, 3]])
+            p = p_orig.copy()
+            p.iloc[0, [0, 1, 3, 5], -2:] = df
+            out = p.iloc[0, [0, 1, 3, 5], -2:]
+            assert_frame_equal(out, df.iloc[[0, 1, 3, 5], [2, 3]])
 
-        # GH3830, panel assignent by values/frame
-        for dtype in ['float64', 'int64']:
+            # GH3830, panel assignent by values/frame
+            for dtype in ['float64', 'int64']:
 
-            panel = Panel(np.arange(40).reshape((2, 4, 5)),
-                          items=['a1', 'a2'], dtype=dtype)
-            df1 = panel.iloc[0]
-            df2 = panel.iloc[1]
+                panel = Panel(np.arange(40).reshape((2, 4, 5)),
+                              items=['a1', 'a2'], dtype=dtype)
+                df1 = panel.iloc[0]
+                df2 = panel.iloc[1]
 
-            tm.assert_frame_equal(panel.loc['a1'], df1)
-            tm.assert_frame_equal(panel.loc['a2'], df2)
+                tm.assert_frame_equal(panel.loc['a1'], df1)
+                tm.assert_frame_equal(panel.loc['a2'], df2)
 
-            # Assignment by Value Passes for 'a2'
-            panel.loc['a2'] = df1.values
-            tm.assert_frame_equal(panel.loc['a1'], df1)
-            tm.assert_frame_equal(panel.loc['a2'], df1)
+                # Assignment by Value Passes for 'a2'
+                panel.loc['a2'] = df1.values
+                tm.assert_frame_equal(panel.loc['a1'], df1)
+                tm.assert_frame_equal(panel.loc['a2'], df1)
 
-            # Assignment by DataFrame Ok w/o loc 'a2'
-            panel['a2'] = df2
-            tm.assert_frame_equal(panel.loc['a1'], df1)
-            tm.assert_frame_equal(panel.loc['a2'], df2)
+                # Assignment by DataFrame Ok w/o loc 'a2'
+                panel['a2'] = df2
+                tm.assert_frame_equal(panel.loc['a1'], df1)
+                tm.assert_frame_equal(panel.loc['a2'], df2)
 
-            # Assignment by DataFrame Fails for 'a2'
-            panel.loc['a2'] = df2
-            tm.assert_frame_equal(panel.loc['a1'], df1)
-            tm.assert_frame_equal(panel.loc['a2'], df2)
+                # Assignment by DataFrame Fails for 'a2'
+                panel.loc['a2'] = df2
+                tm.assert_frame_equal(panel.loc['a1'], df1)
+                tm.assert_frame_equal(panel.loc['a2'], df2)
 
     def _check_view(self, indexer, comp):
         cp = self.panel.copy()
@@ -776,57 +811,60 @@ class CheckIndexing(object):
         comp(cp.loc[indexer].reindex_like(obj), obj)
 
     def test_logical_with_nas(self):
-        d = Panel({'ItemA': {'a': [np.nan, False]},
-                   'ItemB': {'a': [True, True]}})
+        with catch_warnings(record=True):
+            d = Panel({'ItemA': {'a': [np.nan, False]},
+                       'ItemB': {'a': [True, True]}})
 
-        result = d['ItemA'] | d['ItemB']
-        expected = DataFrame({'a': [np.nan, True]})
-        assert_frame_equal(result, expected)
+            result = d['ItemA'] | d['ItemB']
+            expected = DataFrame({'a': [np.nan, True]})
+            assert_frame_equal(result, expected)
 
-        # this is autodowncasted here
-        result = d['ItemA'].fillna(False) | d['ItemB']
-        expected = DataFrame({'a': [True, True]})
-        assert_frame_equal(result, expected)
+            # this is autodowncasted here
+            result = d['ItemA'].fillna(False) | d['ItemB']
+            expected = DataFrame({'a': [True, True]})
+            assert_frame_equal(result, expected)
 
     def test_neg(self):
-        # what to do?
-        assert_panel_equal(-self.panel, -1 * self.panel)
+        with catch_warnings(record=True):
+            assert_panel_equal(-self.panel, -1 * self.panel)
 
     def test_invert(self):
-        assert_panel_equal(-(self.panel < 0), ~(self.panel < 0))
+        with catch_warnings(record=True):
+            assert_panel_equal(-(self.panel < 0), ~(self.panel < 0))
 
     def test_comparisons(self):
-        p1 = tm.makePanel()
-        p2 = tm.makePanel()
+        with catch_warnings(record=True):
+            p1 = tm.makePanel()
+            p2 = tm.makePanel()
 
-        tp = p1.reindex(items=p1.items + ['foo'])
-        df = p1[p1.items[0]]
+            tp = p1.reindex(items=p1.items + ['foo'])
+            df = p1[p1.items[0]]
 
-        def test_comp(func):
+            def test_comp(func):
 
-            # versus same index
-            result = func(p1, p2)
-            self.assert_numpy_array_equal(result.values,
-                                          func(p1.values, p2.values))
+                # versus same index
+                result = func(p1, p2)
+                self.assert_numpy_array_equal(result.values,
+                                              func(p1.values, p2.values))
 
-            # versus non-indexed same objs
-            self.assertRaises(Exception, func, p1, tp)
+                # versus non-indexed same objs
+                self.assertRaises(Exception, func, p1, tp)
 
-            # versus different objs
-            self.assertRaises(Exception, func, p1, df)
+                # versus different objs
+                self.assertRaises(Exception, func, p1, df)
 
-            # versus scalar
-            result3 = func(self.panel, 0)
-            self.assert_numpy_array_equal(result3.values,
-                                          func(self.panel.values, 0))
+                # versus scalar
+                result3 = func(self.panel, 0)
+                self.assert_numpy_array_equal(result3.values,
+                                              func(self.panel.values, 0))
 
-        with np.errstate(invalid='ignore'):
-            test_comp(operator.eq)
-            test_comp(operator.ne)
-            test_comp(operator.lt)
-            test_comp(operator.gt)
-            test_comp(operator.ge)
-            test_comp(operator.le)
+            with np.errstate(invalid='ignore'):
+                test_comp(operator.eq)
+                test_comp(operator.ne)
+                test_comp(operator.lt)
+                test_comp(operator.gt)
+                test_comp(operator.ge)
+                test_comp(operator.le)
 
     def test_get_value(self):
         for item in self.panel.items:
@@ -840,28 +878,26 @@ class CheckIndexing(object):
             self.panel.get_value('a')
 
     def test_set_value(self):
-        for item in self.panel.items:
-            for mjr in self.panel.major_axis[::2]:
-                for mnr in self.panel.minor_axis:
-                    self.panel.set_value(item, mjr, mnr, 1.)
-                    assert_almost_equal(self.panel[item][mnr][mjr], 1.)
-
-        # resize
-        res = self.panel.set_value('ItemE', 'foo', 'bar', 1.5)
-        tm.assertIsInstance(res, Panel)
-        self.assertIsNot(res, self.panel)
-        self.assertEqual(res.get_value('ItemE', 'foo', 'bar'), 1.5)
-
-        res3 = self.panel.set_value('ItemE', 'foobar', 'baz', 5)
-        self.assertTrue(is_float_dtype(res3['ItemE'].values))
-        with tm.assertRaisesRegexp(TypeError,
-                                   "There must be an argument for each axis"
-                                   " plus the value provided"):
-            self.panel.set_value('a')
-
-
-_panel = tm.makePanel()
-tm.add_nans(_panel)
+        with catch_warnings(record=True):
+            for item in self.panel.items:
+                for mjr in self.panel.major_axis[::2]:
+                    for mnr in self.panel.minor_axis:
+                        self.panel.set_value(item, mjr, mnr, 1.)
+                        assert_almost_equal(self.panel[item][mnr][mjr], 1.)
+
+            # resize
+            res = self.panel.set_value('ItemE', 'foo', 'bar', 1.5)
+            tm.assertIsInstance(res, Panel)
+            self.assertIsNot(res, self.panel)
+            self.assertEqual(res.get_value('ItemE', 'foo', 'bar'), 1.5)
+
+            res3 = self.panel.set_value('ItemE', 'foobar', 'baz', 5)
+            self.assertTrue(is_float_dtype(res3['ItemE'].values))
+            with tm.assertRaisesRegexp(TypeError,
+                                       "There must be an argument "
+                                       "for each axis"
+                                       " plus the value provided"):
+                self.panel.set_value('a')
 
 
 class TestPanel(tm.TestCase, PanelTests, CheckIndexing, SafeForLongAndSparse,
@@ -872,292 +908,315 @@ class TestPanel(tm.TestCase, PanelTests, CheckIndexing, SafeForLongAndSparse,
         assert_panel_equal(x, y)
 
     def setUp(self):
-        self.panel = _panel.copy()
+        self.panel = make_test_panel()
         self.panel.major_axis.name = None
         self.panel.minor_axis.name = None
         self.panel.items.name = None
 
     def test_constructor(self):
-        # with BlockManager
-        wp = Panel(self.panel._data)
-        self.assertIs(wp._data, self.panel._data)
-
-        wp = Panel(self.panel._data, copy=True)
-        self.assertIsNot(wp._data, self.panel._data)
-        assert_panel_equal(wp, self.panel)
-
-        # strings handled prop
-        wp = Panel([[['foo', 'foo', 'foo', ], ['foo', 'foo', 'foo']]])
-        self.assertEqual(wp.values.dtype, np.object_)
-
-        vals = self.panel.values
-
-        # no copy
-        wp = Panel(vals)
-        self.assertIs(wp.values, vals)
-
-        # copy
-        wp = Panel(vals, copy=True)
-        self.assertIsNot(wp.values, vals)
-
-        # GH #8285, test when scalar data is used to construct a Panel
-        # if dtype is not passed, it should be inferred
-        value_and_dtype = [(1, 'int64'), (3.14, 'float64'),
-                           ('foo', np.object_)]
-        for (val, dtype) in value_and_dtype:
-            wp = Panel(val, items=range(2), major_axis=range(3),
-                       minor_axis=range(4))
-            vals = np.empty((2, 3, 4), dtype=dtype)
-            vals.fill(val)
-            assert_panel_equal(wp, Panel(vals, dtype=dtype))
-
-        # test the case when dtype is passed
-        wp = Panel(1, items=range(2), major_axis=range(3), minor_axis=range(4),
-                   dtype='float32')
-        vals = np.empty((2, 3, 4), dtype='float32')
-        vals.fill(1)
-        assert_panel_equal(wp, Panel(vals, dtype='float32'))
+        with catch_warnings(record=True):
+            # with BlockManager
+            wp = Panel(self.panel._data)
+            self.assertIs(wp._data, self.panel._data)
+
+            wp = Panel(self.panel._data, copy=True)
+            self.assertIsNot(wp._data, self.panel._data)
+            assert_panel_equal(wp, self.panel)
+
+            # strings handled prop
+            wp = Panel([[['foo', 'foo', 'foo', ], ['foo', 'foo', 'foo']]])
+            self.assertEqual(wp.values.dtype, np.object_)
+
+            vals = self.panel.values
+
+            # no copy
+            wp = Panel(vals)
+            self.assertIs(wp.values, vals)
+
+            # copy
+            wp = Panel(vals, copy=True)
+            self.assertIsNot(wp.values, vals)
+
+            # GH #8285, test when scalar data is used to construct a Panel
+            # if dtype is not passed, it should be inferred
+            value_and_dtype = [(1, 'int64'), (3.14, 'float64'),
+                               ('foo', np.object_)]
+            for (val, dtype) in value_and_dtype:
+                wp = Panel(val, items=range(2), major_axis=range(3),
+                           minor_axis=range(4))
+                vals = np.empty((2, 3, 4), dtype=dtype)
+                vals.fill(val)
+                assert_panel_equal(wp, Panel(vals, dtype=dtype))
+
+            # test the case when dtype is passed
+            wp = Panel(1, items=range(2), major_axis=range(3),
+                       minor_axis=range(4),
+                       dtype='float32')
+            vals = np.empty((2, 3, 4), dtype='float32')
+            vals.fill(1)
+            assert_panel_equal(wp, Panel(vals, dtype='float32'))
 
     def test_constructor_cast(self):
-        zero_filled = self.panel.fillna(0)
+        with catch_warnings(record=True):
+            zero_filled = self.panel.fillna(0)
 
-        casted = Panel(zero_filled._data, dtype=int)
-        casted2 = Panel(zero_filled.values, dtype=int)
+            casted = Panel(zero_filled._data, dtype=int)
+            casted2 = Panel(zero_filled.values, dtype=int)
 
-        exp_values = zero_filled.values.astype(int)
-        assert_almost_equal(casted.values, exp_values)
-        assert_almost_equal(casted2.values, exp_values)
+            exp_values = zero_filled.values.astype(int)
+            assert_almost_equal(casted.values, exp_values)
+            assert_almost_equal(casted2.values, exp_values)
 
-        casted = Panel(zero_filled._data, dtype=np.int32)
-        casted2 = Panel(zero_filled.values, dtype=np.int32)
+            casted = Panel(zero_filled._data, dtype=np.int32)
+            casted2 = Panel(zero_filled.values, dtype=np.int32)
 
-        exp_values = zero_filled.values.astype(np.int32)
-        assert_almost_equal(casted.values, exp_values)
-        assert_almost_equal(casted2.values, exp_values)
+            exp_values = zero_filled.values.astype(np.int32)
+            assert_almost_equal(casted.values, exp_values)
+            assert_almost_equal(casted2.values, exp_values)
 
-        # can't cast
-        data = [[['foo', 'bar', 'baz']]]
-        self.assertRaises(ValueError, Panel, data, dtype=float)
+            # can't cast
+            data = [[['foo', 'bar', 'baz']]]
+            self.assertRaises(ValueError, Panel, data, dtype=float)
 
     def test_constructor_empty_panel(self):
-        empty = Panel()
-        self.assertEqual(len(empty.items), 0)
-        self.assertEqual(len(empty.major_axis), 0)
-        self.assertEqual(len(empty.minor_axis), 0)
+        with catch_warnings(record=True):
+            empty = Panel()
+            self.assertEqual(len(empty.items), 0)
+            self.assertEqual(len(empty.major_axis), 0)
+            self.assertEqual(len(empty.minor_axis), 0)
 
     def test_constructor_observe_dtype(self):
-        # GH #411
-        panel = Panel(items=lrange(3), major_axis=lrange(3),
-                      minor_axis=lrange(3), dtype='O')
-        self.assertEqual(panel.values.dtype, np.object_)
+        with catch_warnings(record=True):
+            # GH #411
+            panel = Panel(items=lrange(3), major_axis=lrange(3),
+                          minor_axis=lrange(3), dtype='O')
+            self.assertEqual(panel.values.dtype, np.object_)
 
     def test_constructor_dtypes(self):
-        # GH #797
-
-        def _check_dtype(panel, dtype):
-            for i in panel.items:
-                self.assertEqual(panel[i].values.dtype.name, dtype)
-
-        # only nan holding types allowed here
-        for dtype in ['float64', 'float32', 'object']:
-            panel = Panel(items=lrange(2), major_axis=lrange(10),
-                          minor_axis=lrange(5), dtype=dtype)
-            _check_dtype(panel, dtype)
-
-        for dtype in ['float64', 'float32', 'int64', 'int32', 'object']:
-            panel = Panel(np.array(np.random.randn(2, 10, 5), dtype=dtype),
-                          items=lrange(2),
-                          major_axis=lrange(10),
-                          minor_axis=lrange(5), dtype=dtype)
-            _check_dtype(panel, dtype)
-
-        for dtype in ['float64', 'float32', 'int64', 'int32', 'object']:
-            panel = Panel(np.array(np.random.randn(2, 10, 5), dtype='O'),
-                          items=lrange(2),
-                          major_axis=lrange(10),
-                          minor_axis=lrange(5), dtype=dtype)
-            _check_dtype(panel, dtype)
-
-        for dtype in ['float64', 'float32', 'int64', 'int32', 'object']:
-            panel = Panel(np.random.randn(2, 10, 5), items=lrange(
-                2), major_axis=lrange(10), minor_axis=lrange(5), dtype=dtype)
-            _check_dtype(panel, dtype)
-
-        for dtype in ['float64', 'float32', 'int64', 'int32', 'object']:
-            df1 = DataFrame(np.random.randn(2, 5),
-                            index=lrange(2), columns=lrange(5))
-            df2 = DataFrame(np.random.randn(2, 5),
-                            index=lrange(2), columns=lrange(5))
-            panel = Panel.from_dict({'a': df1, 'b': df2}, dtype=dtype)
-            _check_dtype(panel, dtype)
+        with catch_warnings(record=True):
+            # GH #797
+
+            def _check_dtype(panel, dtype):
+                for i in panel.items:
+                    self.assertEqual(panel[i].values.dtype.name, dtype)
+
+            # only nan holding types allowed here
+            for dtype in ['float64', 'float32', 'object']:
+                panel = Panel(items=lrange(2), major_axis=lrange(10),
+                              minor_axis=lrange(5), dtype=dtype)
+                _check_dtype(panel, dtype)
+
+            for dtype in ['float64', 'float32', 'int64', 'int32', 'object']:
+                panel = Panel(np.array(np.random.randn(2, 10, 5), dtype=dtype),
+                              items=lrange(2),
+                              major_axis=lrange(10),
+                              minor_axis=lrange(5), dtype=dtype)
+                _check_dtype(panel, dtype)
+
+            for dtype in ['float64', 'float32', 'int64', 'int32', 'object']:
+                panel = Panel(np.array(np.random.randn(2, 10, 5), dtype='O'),
+                              items=lrange(2),
+                              major_axis=lrange(10),
+                              minor_axis=lrange(5), dtype=dtype)
+                _check_dtype(panel, dtype)
+
+            for dtype in ['float64', 'float32', 'int64', 'int32', 'object']:
+                panel = Panel(
+                    np.random.randn(2, 10, 5),
+                    items=lrange(2), major_axis=lrange(10),
+                    minor_axis=lrange(5),
+                    dtype=dtype)
+                _check_dtype(panel, dtype)
+
+            for dtype in ['float64', 'float32', 'int64', 'int32', 'object']:
+                df1 = DataFrame(np.random.randn(2, 5),
+                                index=lrange(2), columns=lrange(5))
+                df2 = DataFrame(np.random.randn(2, 5),
+                                index=lrange(2), columns=lrange(5))
+                panel = Panel.from_dict({'a': df1, 'b': df2}, dtype=dtype)
+                _check_dtype(panel, dtype)
 
     def test_constructor_fails_with_not_3d_input(self):
-        with tm.assertRaisesRegexp(ValueError,
-                                   "The number of dimensions required is 3"):
-            Panel(np.random.randn(10, 2))
+        with catch_warnings(record=True):
+            with tm.assertRaisesRegexp(ValueError, "The number of dimensions required is 3"):  # noqa
+                    Panel(np.random.randn(10, 2))
 
     def test_consolidate(self):
-        self.assertTrue(self.panel._data.is_consolidated())
+        with catch_warnings(record=True):
+            self.assertTrue(self.panel._data.is_consolidated())
 
-        self.panel['foo'] = 1.
-        self.assertFalse(self.panel._data.is_consolidated())
+            self.panel['foo'] = 1.
+            self.assertFalse(self.panel._data.is_consolidated())
 
-        panel = self.panel._consolidate()
-        self.assertTrue(panel._data.is_consolidated())
+            panel = self.panel._consolidate()
+            self.assertTrue(panel._data.is_consolidated())
 
     def test_ctor_dict(self):
-        itema = self.panel['ItemA']
-        itemb = self.panel['ItemB']
+        with catch_warnings(record=True):
+            itema = self.panel['ItemA']
+            itemb = self.panel['ItemB']
 
-        d = {'A': itema, 'B': itemb[5:]}
-        d2 = {'A': itema._series, 'B': itemb[5:]._series}
-        d3 = {'A': None,
-              'B': DataFrame(itemb[5:]._series),
-              'C': DataFrame(itema._series)}
+            d = {'A': itema, 'B': itemb[5:]}
+            d2 = {'A': itema._series, 'B': itemb[5:]._series}
+            d3 = {'A': None,
+                  'B': DataFrame(itemb[5:]._series),
+                  'C': DataFrame(itema._series)}
 
-        wp = Panel.from_dict(d)
-        wp2 = Panel.from_dict(d2)  # nested Dict
+            wp = Panel.from_dict(d)
+            wp2 = Panel.from_dict(d2)  # nested Dict
 
-        # TODO: unused?
-        wp3 = Panel.from_dict(d3)  # noqa
+            # TODO: unused?
+            wp3 = Panel.from_dict(d3)  # noqa
 
-        self.assert_index_equal(wp.major_axis, self.panel.major_axis)
-        assert_panel_equal(wp, wp2)
+            self.assert_index_equal(wp.major_axis, self.panel.major_axis)
+            assert_panel_equal(wp, wp2)
 
-        # intersect
-        wp = Panel.from_dict(d, intersect=True)
-        self.assert_index_equal(wp.major_axis, itemb.index[5:])
+            # intersect
+            wp = Panel.from_dict(d, intersect=True)
+            self.assert_index_equal(wp.major_axis, itemb.index[5:])
 
-        # use constructor
-        assert_panel_equal(Panel(d), Panel.from_dict(d))
-        assert_panel_equal(Panel(d2), Panel.from_dict(d2))
-        assert_panel_equal(Panel(d3), Panel.from_dict(d3))
+            # use constructor
+            assert_panel_equal(Panel(d), Panel.from_dict(d))
+            assert_panel_equal(Panel(d2), Panel.from_dict(d2))
+            assert_panel_equal(Panel(d3), Panel.from_dict(d3))
 
-        # a pathological case
-        d4 = {'A': None, 'B': None}
+            # a pathological case
+            d4 = {'A': None, 'B': None}
 
-        # TODO: unused?
-        wp4 = Panel.from_dict(d4)  # noqa
+            # TODO: unused?
+            wp4 = Panel.from_dict(d4)  # noqa
 
-        assert_panel_equal(Panel(d4), Panel(items=['A', 'B']))
+            assert_panel_equal(Panel(d4), Panel(items=['A', 'B']))
 
-        # cast
-        dcasted = dict((k, v.reindex(wp.major_axis).fillna(0))
-                       for k, v in compat.iteritems(d))
-        result = Panel(dcasted, dtype=int)
-        expected = Panel(dict((k, v.astype(int))
-                              for k, v in compat.iteritems(dcasted)))
-        assert_panel_equal(result, expected)
+            # cast
+            dcasted = dict((k, v.reindex(wp.major_axis).fillna(0))
+                           for k, v in compat.iteritems(d))
+            result = Panel(dcasted, dtype=int)
+            expected = Panel(dict((k, v.astype(int))
+                                  for k, v in compat.iteritems(dcasted)))
+            assert_panel_equal(result, expected)
 
-        result = Panel(dcasted, dtype=np.int32)
-        expected = Panel(dict((k, v.astype(np.int32))
-                              for k, v in compat.iteritems(dcasted)))
-        assert_panel_equal(result, expected)
+            result = Panel(dcasted, dtype=np.int32)
+            expected = Panel(dict((k, v.astype(np.int32))
+                                  for k, v in compat.iteritems(dcasted)))
+            assert_panel_equal(result, expected)
 
     def test_constructor_dict_mixed(self):
-        data = dict((k, v.values) for k, v in self.panel.iteritems())
-        result = Panel(data)
-        exp_major = Index(np.arange(len(self.panel.major_axis)))
-        self.assert_index_equal(result.major_axis, exp_major)
+        with catch_warnings(record=True):
+            data = dict((k, v.values) for k, v in self.panel.iteritems())
+            result = Panel(data)
+            exp_major = Index(np.arange(len(self.panel.major_axis)))
+            self.assert_index_equal(result.major_axis, exp_major)
 
-        result = Panel(data, items=self.panel.items,
-                       major_axis=self.panel.major_axis,
-                       minor_axis=self.panel.minor_axis)
-        assert_panel_equal(result, self.panel)
+            result = Panel(data, items=self.panel.items,
+                           major_axis=self.panel.major_axis,
+                           minor_axis=self.panel.minor_axis)
+            assert_panel_equal(result, self.panel)
 
-        data['ItemC'] = self.panel['ItemC']
-        result = Panel(data)
-        assert_panel_equal(result, self.panel)
+            data['ItemC'] = self.panel['ItemC']
+            result = Panel(data)
+            assert_panel_equal(result, self.panel)
 
-        # corner, blow up
-        data['ItemB'] = data['ItemB'][:-1]
-        self.assertRaises(Exception, Panel, data)
+            # corner, blow up
+            data['ItemB'] = data['ItemB'][:-1]
+            self.assertRaises(Exception, Panel, data)
 
-        data['ItemB'] = self.panel['ItemB'].values[:, :-1]
-        self.assertRaises(Exception, Panel, data)
+            data['ItemB'] = self.panel['ItemB'].values[:, :-1]
+            self.assertRaises(Exception, Panel, data)
 
     def test_ctor_orderedDict(self):
-        keys = list(set(np.random.randint(0, 5000, 100)))[
-            :50]  # unique random int  keys
-        d = OrderedDict([(k, mkdf(10, 5)) for k in keys])
-        p = Panel(d)
-        self.assertTrue(list(p.items) == keys)
+        with catch_warnings(record=True):
+            keys = list(set(np.random.randint(0, 5000, 100)))[
+                :50]  # unique random int  keys
+            d = OrderedDict([(k, mkdf(10, 5)) for k in keys])
+            p = Panel(d)
+            self.assertTrue(list(p.items) == keys)
 
-        p = Panel.from_dict(d)
-        self.assertTrue(list(p.items) == keys)
+            p = Panel.from_dict(d)
+            self.assertTrue(list(p.items) == keys)
 
     def test_constructor_resize(self):
-        data = self.panel._data
-        items = self.panel.items[:-1]
-        major = self.panel.major_axis[:-1]
-        minor = self.panel.minor_axis[:-1]
-
-        result = Panel(data, items=items, major_axis=major, minor_axis=minor)
-        expected = self.panel.reindex(items=items, major=major, minor=minor)
-        assert_panel_equal(result, expected)
+        with catch_warnings(record=True):
+            data = self.panel._data
+            items = self.panel.items[:-1]
+            major = self.panel.major_axis[:-1]
+            minor = self.panel.minor_axis[:-1]
+
+            result = Panel(data, items=items,
+                           major_axis=major, minor_axis=minor)
+            expected = self.panel.reindex(
+                items=items, major=major, minor=minor)
+            assert_panel_equal(result, expected)
 
-        result = Panel(data, items=items, major_axis=major)
-        expected = self.panel.reindex(items=items, major=major)
-        assert_panel_equal(result, expected)
+            result = Panel(data, items=items, major_axis=major)
+            expected = self.panel.reindex(items=items, major=major)
+            assert_panel_equal(result, expected)
 
-        result = Panel(data, items=items)
-        expected = self.panel.reindex(items=items)
-        assert_panel_equal(result, expected)
+            result = Panel(data, items=items)
+            expected = self.panel.reindex(items=items)
+            assert_panel_equal(result, expected)
 
-        result = Panel(data, minor_axis=minor)
-        expected = self.panel.reindex(minor=minor)
-        assert_panel_equal(result, expected)
+            result = Panel(data, minor_axis=minor)
+            expected = self.panel.reindex(minor=minor)
+            assert_panel_equal(result, expected)
 
     def test_from_dict_mixed_orient(self):
-        df = tm.makeDataFrame()
-        df['foo'] = 'bar'
+        with catch_warnings(record=True):
+            df = tm.makeDataFrame()
+            df['foo'] = 'bar'
 
-        data = {'k1': df, 'k2': df}
+            data = {'k1': df, 'k2': df}
 
-        panel = Panel.from_dict(data, orient='minor')
+            panel = Panel.from_dict(data, orient='minor')
 
-        self.assertEqual(panel['foo'].values.dtype, np.object_)
-        self.assertEqual(panel['A'].values.dtype, np.float64)
+            self.assertEqual(panel['foo'].values.dtype, np.object_)
+            self.assertEqual(panel['A'].values.dtype, np.float64)
 
     def test_constructor_error_msgs(self):
-        def testit():
-            Panel(np.random.randn(3, 4, 5), lrange(4), lrange(5), lrange(5))
+        with catch_warnings(record=True):
+            def testit():
+                Panel(np.random.randn(3, 4, 5),
+                      lrange(4), lrange(5), lrange(5))
 
-        assertRaisesRegexp(ValueError,
-                           r"Shape of passed values is \(3, 4, 5\), "
-                           r"indices imply \(4, 5, 5\)",
-                           testit)
+            assertRaisesRegexp(ValueError,
+                               r"Shape of passed values is \(3, 4, 5\), "
+                               r"indices imply \(4, 5, 5\)",
+                               testit)
 
-        def testit():
-            Panel(np.random.randn(3, 4, 5), lrange(5), lrange(4), lrange(5))
+            def testit():
+                Panel(np.random.randn(3, 4, 5),
+                      lrange(5), lrange(4), lrange(5))
 
-        assertRaisesRegexp(ValueError,
-                           r"Shape of passed values is \(3, 4, 5\), "
-                           r"indices imply \(5, 4, 5\)",
-                           testit)
+            assertRaisesRegexp(ValueError,
+                               r"Shape of passed values is \(3, 4, 5\), "
+                               r"indices imply \(5, 4, 5\)",
+                               testit)
 
-        def testit():
-            Panel(np.random.randn(3, 4, 5), lrange(5), lrange(5), lrange(4))
+            def testit():
+                Panel(np.random.randn(3, 4, 5),
+                      lrange(5), lrange(5), lrange(4))
 
-        assertRaisesRegexp(ValueError,
-                           r"Shape of passed values is \(3, 4, 5\), "
-                           r"indices imply \(5, 5, 4\)",
-                           testit)
+            assertRaisesRegexp(ValueError,
+                               r"Shape of passed values is \(3, 4, 5\), "
+                               r"indices imply \(5, 5, 4\)",
+                               testit)
 
     def test_conform(self):
-        df = self.panel['ItemA'][:-5].filter(items=['A', 'B'])
-        conformed = self.panel.conform(df)
+        with catch_warnings(record=True):
+            df = self.panel['ItemA'][:-5].filter(items=['A', 'B'])
+            conformed = self.panel.conform(df)
 
-        tm.assert_index_equal(conformed.index, self.panel.major_axis)
-        tm.assert_index_equal(conformed.columns, self.panel.minor_axis)
+            tm.assert_index_equal(conformed.index, self.panel.major_axis)
+            tm.assert_index_equal(conformed.columns, self.panel.minor_axis)
 
     def test_convert_objects(self):
+        with catch_warnings(record=True):
 
-        # GH 4937
-        p = Panel(dict(A=dict(a=['1', '1.0'])))
-        expected = Panel(dict(A=dict(a=[1, 1.0])))
-        result = p._convert(numeric=True, coerce=True)
-        assert_panel_equal(result, expected)
+            # GH 4937
+            p = Panel(dict(A=dict(a=['1', '1.0'])))
+            expected = Panel(dict(A=dict(a=[1, 1.0])))
+            result = p._convert(numeric=True, coerce=True)
+            assert_panel_equal(result, expected)
 
     def test_dtypes(self):
 
@@ -1166,875 +1225,940 @@ class TestPanel(tm.TestCase, PanelTests, CheckIndexing, SafeForLongAndSparse,
         assert_series_equal(result, expected)
 
     def test_astype(self):
-        # GH7271
-        data = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
-        panel = Panel(data, ['a', 'b'], ['c', 'd'], ['e', 'f'])
+        with catch_warnings(record=True):
+            # GH7271
+            data = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
+            panel = Panel(data, ['a', 'b'], ['c', 'd'], ['e', 'f'])
 
-        str_data = np.array([[['1', '2'], ['3', '4']],
-                             [['5', '6'], ['7', '8']]])
-        expected = Panel(str_data, ['a', 'b'], ['c', 'd'], ['e', 'f'])
-        assert_panel_equal(panel.astype(str), expected)
+            str_data = np.array([[['1', '2'], ['3', '4']],
+                                 [['5', '6'], ['7', '8']]])
+            expected = Panel(str_data, ['a', 'b'], ['c', 'd'], ['e', 'f'])
+            assert_panel_equal(panel.astype(str), expected)
 
-        self.assertRaises(NotImplementedError, panel.astype, {0: str})
+            self.assertRaises(NotImplementedError, panel.astype, {0: str})
 
     def test_apply(self):
-        # GH1148
-
-        # ufunc
-        applied = self.panel.apply(np.sqrt)
-        with np.errstate(invalid='ignore'):
-            expected = np.sqrt(self.panel.values)
-        assert_almost_equal(applied.values, expected)
-
-        # ufunc same shape
-        result = self.panel.apply(lambda x: x * 2, axis='items')
-        expected = self.panel * 2
-        assert_panel_equal(result, expected)
-        result = self.panel.apply(lambda x: x * 2, axis='major_axis')
-        expected = self.panel * 2
-        assert_panel_equal(result, expected)
-        result = self.panel.apply(lambda x: x * 2, axis='minor_axis')
-        expected = self.panel * 2
-        assert_panel_equal(result, expected)
-
-        # reduction to DataFrame
-        result = self.panel.apply(lambda x: x.dtype, axis='items')
-        expected = DataFrame(np.dtype('float64'), index=self.panel.major_axis,
-                             columns=self.panel.minor_axis)
-        assert_frame_equal(result, expected)
-        result = self.panel.apply(lambda x: x.dtype, axis='major_axis')
-        expected = DataFrame(np.dtype('float64'), index=self.panel.minor_axis,
-                             columns=self.panel.items)
-        assert_frame_equal(result, expected)
-        result = self.panel.apply(lambda x: x.dtype, axis='minor_axis')
-        expected = DataFrame(np.dtype('float64'), index=self.panel.major_axis,
-                             columns=self.panel.items)
-        assert_frame_equal(result, expected)
+        with catch_warnings(record=True):
+            # GH1148
 
-        # reductions via other dims
-        expected = self.panel.sum(0)
-        result = self.panel.apply(lambda x: x.sum(), axis='items')
-        assert_frame_equal(result, expected)
-        expected = self.panel.sum(1)
-        result = self.panel.apply(lambda x: x.sum(), axis='major_axis')
-        assert_frame_equal(result, expected)
-        expected = self.panel.sum(2)
-        result = self.panel.apply(lambda x: x.sum(), axis='minor_axis')
-        assert_frame_equal(result, expected)
+            # ufunc
+            applied = self.panel.apply(np.sqrt)
+            with np.errstate(invalid='ignore'):
+                expected = np.sqrt(self.panel.values)
+            assert_almost_equal(applied.values, expected)
 
-        # pass kwargs
-        result = self.panel.apply(lambda x, y: x.sum() + y, axis='items', y=5)
-        expected = self.panel.sum(0) + 5
-        assert_frame_equal(result, expected)
+            # ufunc same shape
+            result = self.panel.apply(lambda x: x * 2, axis='items')
+            expected = self.panel * 2
+            assert_panel_equal(result, expected)
+            result = self.panel.apply(lambda x: x * 2, axis='major_axis')
+            expected = self.panel * 2
+            assert_panel_equal(result, expected)
+            result = self.panel.apply(lambda x: x * 2, axis='minor_axis')
+            expected = self.panel * 2
+            assert_panel_equal(result, expected)
+
+            # reduction to DataFrame
+            result = self.panel.apply(lambda x: x.dtype, axis='items')
+            expected = DataFrame(np.dtype('float64'),
+                                 index=self.panel.major_axis,
+                                 columns=self.panel.minor_axis)
+            assert_frame_equal(result, expected)
+            result = self.panel.apply(lambda x: x.dtype, axis='major_axis')
+            expected = DataFrame(np.dtype('float64'),
+                                 index=self.panel.minor_axis,
+                                 columns=self.panel.items)
+            assert_frame_equal(result, expected)
+            result = self.panel.apply(lambda x: x.dtype, axis='minor_axis')
+            expected = DataFrame(np.dtype('float64'),
+                                 index=self.panel.major_axis,
+                                 columns=self.panel.items)
+            assert_frame_equal(result, expected)
+
+            # reductions via other dims
+            expected = self.panel.sum(0)
+            result = self.panel.apply(lambda x: x.sum(), axis='items')
+            assert_frame_equal(result, expected)
+            expected = self.panel.sum(1)
+            result = self.panel.apply(lambda x: x.sum(), axis='major_axis')
+            assert_frame_equal(result, expected)
+            expected = self.panel.sum(2)
+            result = self.panel.apply(lambda x: x.sum(), axis='minor_axis')
+            assert_frame_equal(result, expected)
+
+            # pass kwargs
+            result = self.panel.apply(
+                lambda x, y: x.sum() + y, axis='items', y=5)
+            expected = self.panel.sum(0) + 5
+            assert_frame_equal(result, expected)
 
     def test_apply_slabs(self):
+        with catch_warnings(record=True):
 
-        # same shape as original
-        result = self.panel.apply(lambda x: x * 2,
-                                  axis=['items', 'major_axis'])
-        expected = (self.panel * 2).transpose('minor_axis', 'major_axis',
-                                              'items')
-        assert_panel_equal(result, expected)
-        result = self.panel.apply(lambda x: x * 2,
-                                  axis=['major_axis', 'items'])
-        assert_panel_equal(result, expected)
-
-        result = self.panel.apply(lambda x: x * 2,
-                                  axis=['items', 'minor_axis'])
-        expected = (self.panel * 2).transpose('major_axis', 'minor_axis',
-                                              'items')
-        assert_panel_equal(result, expected)
-        result = self.panel.apply(lambda x: x * 2,
-                                  axis=['minor_axis', 'items'])
-        assert_panel_equal(result, expected)
-
-        result = self.panel.apply(lambda x: x * 2,
-                                  axis=['major_axis', 'minor_axis'])
-        expected = self.panel * 2
-        assert_panel_equal(result, expected)
-        result = self.panel.apply(lambda x: x * 2,
-                                  axis=['minor_axis', 'major_axis'])
-        assert_panel_equal(result, expected)
-
-        # reductions
-        result = self.panel.apply(lambda x: x.sum(0), axis=[
-            'items', 'major_axis'
-        ])
-        expected = self.panel.sum(1).T
-        assert_frame_equal(result, expected)
+            # same shape as original
+            result = self.panel.apply(lambda x: x * 2,
+                                      axis=['items', 'major_axis'])
+            expected = (self.panel * 2).transpose('minor_axis', 'major_axis',
+                                                  'items')
+            assert_panel_equal(result, expected)
+            result = self.panel.apply(lambda x: x * 2,
+                                      axis=['major_axis', 'items'])
+            assert_panel_equal(result, expected)
 
-        result = self.panel.apply(lambda x: x.sum(1), axis=[
-            'items', 'major_axis'
-        ])
-        expected = self.panel.sum(0)
-        assert_frame_equal(result, expected)
+            result = self.panel.apply(lambda x: x * 2,
+                                      axis=['items', 'minor_axis'])
+            expected = (self.panel * 2).transpose('major_axis', 'minor_axis',
+                                                  'items')
+            assert_panel_equal(result, expected)
+            result = self.panel.apply(lambda x: x * 2,
+                                      axis=['minor_axis', 'items'])
+            assert_panel_equal(result, expected)
+
+            result = self.panel.apply(lambda x: x * 2,
+                                      axis=['major_axis', 'minor_axis'])
+            expected = self.panel * 2
+            assert_panel_equal(result, expected)
+            result = self.panel.apply(lambda x: x * 2,
+                                      axis=['minor_axis', 'major_axis'])
+            assert_panel_equal(result, expected)
 
-        # transforms
-        f = lambda x: ((x.T - x.mean(1)) / x.std(1)).T
+            # reductions
+            result = self.panel.apply(lambda x: x.sum(0), axis=[
+                'items', 'major_axis'
+            ])
+            expected = self.panel.sum(1).T
+            assert_frame_equal(result, expected)
 
         # make sure that we don't trigger any warnings
         with catch_warnings(record=True):
+            result = self.panel.apply(lambda x: x.sum(1), axis=[
+                'items', 'major_axis'
+            ])
+            expected = self.panel.sum(0)
+            assert_frame_equal(result, expected)
+
+            # transforms
+            f = lambda x: ((x.T - x.mean(1)) / x.std(1)).T
+
+            # make sure that we don't trigger any warnings
             result = self.panel.apply(f, axis=['items', 'major_axis'])
             expected = Panel(dict([(ax, f(self.panel.loc[:, :, ax]))
                                    for ax in self.panel.minor_axis]))
             assert_panel_equal(result, expected)
 
-        result = self.panel.apply(f, axis=['major_axis', 'minor_axis'])
-        expected = Panel(dict([(ax, f(self.panel.loc[ax]))
-                               for ax in self.panel.items]))
-        assert_panel_equal(result, expected)
-
-        result = self.panel.apply(f, axis=['minor_axis', 'items'])
-        expected = Panel(dict([(ax, f(self.panel.loc[:, ax]))
-                               for ax in self.panel.major_axis]))
-        assert_panel_equal(result, expected)
-
-        # with multi-indexes
-        # GH7469
-        index = MultiIndex.from_tuples([('one', 'a'), ('one', 'b'), (
-            'two', 'a'), ('two', 'b')])
-        dfa = DataFrame(np.array(np.arange(12, dtype='int64')).reshape(
-            4, 3), columns=list("ABC"), index=index)
-        dfb = DataFrame(np.array(np.arange(10, 22, dtype='int64')).reshape(
-            4, 3), columns=list("ABC"), index=index)
-        p = Panel({'f': dfa, 'g': dfb})
-        result = p.apply(lambda x: x.sum(), axis=0)
-
-        # on windows this will be in32
-        result = result.astype('int64')
-        expected = p.sum(0)
-        assert_frame_equal(result, expected)
+            result = self.panel.apply(f, axis=['major_axis', 'minor_axis'])
+            expected = Panel(dict([(ax, f(self.panel.loc[ax]))
+                                   for ax in self.panel.items]))
+            assert_panel_equal(result, expected)
+
+            result = self.panel.apply(f, axis=['minor_axis', 'items'])
+            expected = Panel(dict([(ax, f(self.panel.loc[:, ax]))
+                                   for ax in self.panel.major_axis]))
+            assert_panel_equal(result, expected)
+
+            # with multi-indexes
+            # GH7469
+            index = MultiIndex.from_tuples([('one', 'a'), ('one', 'b'), (
+                'two', 'a'), ('two', 'b')])
+            dfa = DataFrame(np.array(np.arange(12, dtype='int64')).reshape(
+                4, 3), columns=list("ABC"), index=index)
+            dfb = DataFrame(np.array(np.arange(10, 22, dtype='int64')).reshape(
+                4, 3), columns=list("ABC"), index=index)
+            p = Panel({'f': dfa, 'g': dfb})
+            result = p.apply(lambda x: x.sum(), axis=0)
+
+            # on windows this will be in32
+            result = result.astype('int64')
+            expected = p.sum(0)
+            assert_frame_equal(result, expected)
 
     def test_apply_no_or_zero_ndim(self):
-        # GH10332
-        self.panel = Panel(np.random.rand(5, 5, 5))
+        with catch_warnings(record=True):
+            # GH10332
+            self.panel = Panel(np.random.rand(5, 5, 5))
 
-        result_int = self.panel.apply(lambda df: 0, axis=[1, 2])
-        result_float = self.panel.apply(lambda df: 0.0, axis=[1, 2])
-        result_int64 = self.panel.apply(lambda df: np.int64(0), axis=[1, 2])
-        result_float64 = self.panel.apply(lambda df: np.float64(0.0),
-                                          axis=[1, 2])
+            result_int = self.panel.apply(lambda df: 0, axis=[1, 2])
+            result_float = self.panel.apply(lambda df: 0.0, axis=[1, 2])
+            result_int64 = self.panel.apply(
+                lambda df: np.int64(0), axis=[1, 2])
+            result_float64 = self.panel.apply(lambda df: np.float64(0.0),
+                                              axis=[1, 2])
 
-        expected_int = expected_int64 = Series([0] * 5)
-        expected_float = expected_float64 = Series([0.0] * 5)
+            expected_int = expected_int64 = Series([0] * 5)
+            expected_float = expected_float64 = Series([0.0] * 5)
 
-        assert_series_equal(result_int, expected_int)
-        assert_series_equal(result_int64, expected_int64)
-        assert_series_equal(result_float, expected_float)
-        assert_series_equal(result_float64, expected_float64)
+            assert_series_equal(result_int, expected_int)
+            assert_series_equal(result_int64, expected_int64)
+            assert_series_equal(result_float, expected_float)
+            assert_series_equal(result_float64, expected_float64)
 
     def test_reindex(self):
-        ref = self.panel['ItemB']
+        with catch_warnings(record=True):
+            ref = self.panel['ItemB']
 
-        # items
-        result = self.panel.reindex(items=['ItemA', 'ItemB'])
-        assert_frame_equal(result['ItemB'], ref)
+            # items
+            result = self.panel.reindex(items=['ItemA', 'ItemB'])
+            assert_frame_equal(result['ItemB'], ref)
 
-        # major
-        new_major = list(self.panel.major_axis[:10])
-        result = self.panel.reindex(major=new_major)
-        assert_frame_equal(result['ItemB'], ref.reindex(index=new_major))
+            # major
+            new_major = list(self.panel.major_axis[:10])
+            result = self.panel.reindex(major=new_major)
+            assert_frame_equal(result['ItemB'], ref.reindex(index=new_major))
 
-        # raise exception put both major and major_axis
-        self.assertRaises(Exception, self.panel.reindex, major_axis=new_major,
-                          major=new_major)
+            # raise exception put both major and major_axis
+            self.assertRaises(Exception, self.panel.reindex,
+                              major_axis=new_major,
+                              major=new_major)
 
-        # minor
-        new_minor = list(self.panel.minor_axis[:2])
-        result = self.panel.reindex(minor=new_minor)
-        assert_frame_equal(result['ItemB'], ref.reindex(columns=new_minor))
+            # minor
+            new_minor = list(self.panel.minor_axis[:2])
+            result = self.panel.reindex(minor=new_minor)
+            assert_frame_equal(result['ItemB'], ref.reindex(columns=new_minor))
 
-        # this ok
-        result = self.panel.reindex()
-        assert_panel_equal(result, self.panel)
-        self.assertFalse(result is self.panel)
+            # this ok
+            result = self.panel.reindex()
+            assert_panel_equal(result, self.panel)
+            self.assertFalse(result is self.panel)
 
-        # with filling
-        smaller_major = self.panel.major_axis[::5]
-        smaller = self.panel.reindex(major=smaller_major)
+            # with filling
+            smaller_major = self.panel.major_axis[::5]
+            smaller = self.panel.reindex(major=smaller_major)
 
-        larger = smaller.reindex(major=self.panel.major_axis, method='pad')
+            larger = smaller.reindex(major=self.panel.major_axis, method='pad')
 
-        assert_frame_equal(larger.major_xs(self.panel.major_axis[1]),
-                           smaller.major_xs(smaller_major[0]))
+            assert_frame_equal(larger.major_xs(self.panel.major_axis[1]),
+                               smaller.major_xs(smaller_major[0]))
 
-        # don't necessarily copy
-        result = self.panel.reindex(major=self.panel.major_axis, copy=False)
-        assert_panel_equal(result, self.panel)
-        self.assertTrue(result is self.panel)
+            # don't necessarily copy
+            result = self.panel.reindex(
+                major=self.panel.major_axis, copy=False)
+            assert_panel_equal(result, self.panel)
+            self.assertTrue(result is self.panel)
 
     def test_reindex_multi(self):
+        with catch_warnings(record=True):
 
-        # with and without copy full reindexing
-        result = self.panel.reindex(items=self.panel.items,
-                                    major=self.panel.major_axis,
-                                    minor=self.panel.minor_axis, copy=False)
-
-        self.assertIs(result.items, self.panel.items)
-        self.assertIs(result.major_axis, self.panel.major_axis)
-        self.assertIs(result.minor_axis, self.panel.minor_axis)
-
-        result = self.panel.reindex(items=self.panel.items,
-                                    major=self.panel.major_axis,
-                                    minor=self.panel.minor_axis, copy=False)
-        assert_panel_equal(result, self.panel)
-
-        # multi-axis indexing consistency
-        # GH 5900
-        df = DataFrame(np.random.randn(4, 3))
-        p = Panel({'Item1': df})
-        expected = Panel({'Item1': df})
-        expected['Item2'] = np.nan
-
-        items = ['Item1', 'Item2']
-        major_axis = np.arange(4)
-        minor_axis = np.arange(3)
-
-        results = []
-        results.append(p.reindex(items=items, major_axis=major_axis,
-                                 copy=True))
-        results.append(p.reindex(items=items, major_axis=major_axis,
-                                 copy=False))
-        results.append(p.reindex(items=items, minor_axis=minor_axis,
-                                 copy=True))
-        results.append(p.reindex(items=items, minor_axis=minor_axis,
-                                 copy=False))
-        results.append(p.reindex(items=items, major_axis=major_axis,
-                                 minor_axis=minor_axis, copy=True))
-        results.append(p.reindex(items=items, major_axis=major_axis,
-                                 minor_axis=minor_axis, copy=False))
-
-        for i, r in enumerate(results):
-            assert_panel_equal(expected, r)
+            # with and without copy full reindexing
+            result = self.panel.reindex(
+                items=self.panel.items,
+                major=self.panel.major_axis,
+                minor=self.panel.minor_axis, copy=False)
+
+            self.assertIs(result.items, self.panel.items)
+            self.assertIs(result.major_axis, self.panel.major_axis)
+            self.assertIs(result.minor_axis, self.panel.minor_axis)
+
+            result = self.panel.reindex(
+                items=self.panel.items,
+                major=self.panel.major_axis,
+                minor=self.panel.minor_axis, copy=False)
+            assert_panel_equal(result, self.panel)
+
+            # multi-axis indexing consistency
+            # GH 5900
+            df = DataFrame(np.random.randn(4, 3))
+            p = Panel({'Item1': df})
+            expected = Panel({'Item1': df})
+            expected['Item2'] = np.nan
+
+            items = ['Item1', 'Item2']
+            major_axis = np.arange(4)
+            minor_axis = np.arange(3)
+
+            results = []
+            results.append(p.reindex(items=items, major_axis=major_axis,
+                                     copy=True))
+            results.append(p.reindex(items=items, major_axis=major_axis,
+                                     copy=False))
+            results.append(p.reindex(items=items, minor_axis=minor_axis,
+                                     copy=True))
+            results.append(p.reindex(items=items, minor_axis=minor_axis,
+                                     copy=False))
+            results.append(p.reindex(items=items, major_axis=major_axis,
+                                     minor_axis=minor_axis, copy=True))
+            results.append(p.reindex(items=items, major_axis=major_axis,
+                                     minor_axis=minor_axis, copy=False))
+
+            for i, r in enumerate(results):
+                assert_panel_equal(expected, r)
 
     def test_reindex_like(self):
-        # reindex_like
-        smaller = self.panel.reindex(items=self.panel.items[:-1],
-                                     major=self.panel.major_axis[:-1],
-                                     minor=self.panel.minor_axis[:-1])
-        smaller_like = self.panel.reindex_like(smaller)
-        assert_panel_equal(smaller, smaller_like)
+        with catch_warnings(record=True):
+            # reindex_like
+            smaller = self.panel.reindex(items=self.panel.items[:-1],
+                                         major=self.panel.major_axis[:-1],
+                                         minor=self.panel.minor_axis[:-1])
+            smaller_like = self.panel.reindex_like(smaller)
+            assert_panel_equal(smaller, smaller_like)
 
     def test_take(self):
-        # axis == 0
-        result = self.panel.take([2, 0, 1], axis=0)
-        expected = self.panel.reindex(items=['ItemC', 'ItemA', 'ItemB'])
-        assert_panel_equal(result, expected)
+        with catch_warnings(record=True):
+            # axis == 0
+            result = self.panel.take([2, 0, 1], axis=0)
+            expected = self.panel.reindex(items=['ItemC', 'ItemA', 'ItemB'])
+            assert_panel_equal(result, expected)
 
-        # axis >= 1
-        result = self.panel.take([3, 0, 1, 2], axis=2)
-        expected = self.panel.reindex(minor=['D', 'A', 'B', 'C'])
-        assert_panel_equal(result, expected)
+            # axis >= 1
+            result = self.panel.take([3, 0, 1, 2], axis=2)
+            expected = self.panel.reindex(minor=['D', 'A', 'B', 'C'])
+            assert_panel_equal(result, expected)
 
-        # neg indicies ok
-        expected = self.panel.reindex(minor=['D', 'D', 'B', 'C'])
-        result = self.panel.take([3, -1, 1, 2], axis=2)
-        assert_panel_equal(result, expected)
+            # neg indicies ok
+            expected = self.panel.reindex(minor=['D', 'D', 'B', 'C'])
+            result = self.panel.take([3, -1, 1, 2], axis=2)
+            assert_panel_equal(result, expected)
 
-        self.assertRaises(Exception, self.panel.take, [4, 0, 1, 2], axis=2)
+            self.assertRaises(Exception, self.panel.take, [4, 0, 1, 2], axis=2)
 
     def test_sort_index(self):
-        import random
-
-        ritems = list(self.panel.items)
-        rmajor = list(self.panel.major_axis)
-        rminor = list(self.panel.minor_axis)
-        random.shuffle(ritems)
-        random.shuffle(rmajor)
-        random.shuffle(rminor)
-
-        random_order = self.panel.reindex(items=ritems)
-        sorted_panel = random_order.sort_index(axis=0)
-        assert_panel_equal(sorted_panel, self.panel)
-
-        # descending
-        random_order = self.panel.reindex(items=ritems)
-        sorted_panel = random_order.sort_index(axis=0, ascending=False)
-        assert_panel_equal(sorted_panel,
-                           self.panel.reindex(items=self.panel.items[::-1]))
-
-        random_order = self.panel.reindex(major=rmajor)
-        sorted_panel = random_order.sort_index(axis=1)
-        assert_panel_equal(sorted_panel, self.panel)
-
-        random_order = self.panel.reindex(minor=rminor)
-        sorted_panel = random_order.sort_index(axis=2)
-        assert_panel_equal(sorted_panel, self.panel)
+        with catch_warnings(record=True):
+            import random
+
+            ritems = list(self.panel.items)
+            rmajor = list(self.panel.major_axis)
+            rminor = list(self.panel.minor_axis)
+            random.shuffle(ritems)
+            random.shuffle(rmajor)
+            random.shuffle(rminor)
+
+            random_order = self.panel.reindex(items=ritems)
+            sorted_panel = random_order.sort_index(axis=0)
+            assert_panel_equal(sorted_panel, self.panel)
+
+            # descending
+            random_order = self.panel.reindex(items=ritems)
+            sorted_panel = random_order.sort_index(axis=0, ascending=False)
+            assert_panel_equal(
+                sorted_panel,
+                self.panel.reindex(items=self.panel.items[::-1]))
+
+            random_order = self.panel.reindex(major=rmajor)
+            sorted_panel = random_order.sort_index(axis=1)
+            assert_panel_equal(sorted_panel, self.panel)
+
+            random_order = self.panel.reindex(minor=rminor)
+            sorted_panel = random_order.sort_index(axis=2)
+            assert_panel_equal(sorted_panel, self.panel)
 
     def test_fillna(self):
-        filled = self.panel.fillna(0)
-        self.assertTrue(np.isfinite(filled.values).all())
-
-        filled = self.panel.fillna(method='backfill')
-        assert_frame_equal(filled['ItemA'],
-                           self.panel['ItemA'].fillna(method='backfill'))
-
-        panel = self.panel.copy()
-        panel['str'] = 'foo'
-
-        filled = panel.fillna(method='backfill')
-        assert_frame_equal(filled['ItemA'],
-                           panel['ItemA'].fillna(method='backfill'))
-
-        empty = self.panel.reindex(items=[])
-        filled = empty.fillna(0)
-        assert_panel_equal(filled, empty)
-
-        self.assertRaises(ValueError, self.panel.fillna)
-        self.assertRaises(ValueError, self.panel.fillna, 5, method='ffill')
-
-        self.assertRaises(TypeError, self.panel.fillna, [1, 2])
-        self.assertRaises(TypeError, self.panel.fillna, (1, 2))
-
-        # limit not implemented when only value is specified
-        p = Panel(np.random.randn(3, 4, 5))
-        p.iloc[0:2, 0:2, 0:2] = np.nan
-        self.assertRaises(NotImplementedError, lambda: p.fillna(999, limit=1))
-
-        # Test in place fillNA
-        # Expected result
-        expected = Panel([[[0, 1], [2, 1]], [[10, 11], [12, 11]]],
-                         items=['a', 'b'], minor_axis=['x', 'y'],
-                         dtype=np.float64)
-        # method='ffill'
-        p1 = Panel([[[0, 1], [2, np.nan]], [[10, 11], [12, np.nan]]],
-                   items=['a', 'b'], minor_axis=['x', 'y'],
-                   dtype=np.float64)
-        p1.fillna(method='ffill', inplace=True)
-        assert_panel_equal(p1, expected)
-
-        # method='bfill'
-        p2 = Panel([[[0, np.nan], [2, 1]], [[10, np.nan], [12, 11]]],
-                   items=['a', 'b'], minor_axis=['x', 'y'], dtype=np.float64)
-        p2.fillna(method='bfill', inplace=True)
-        assert_panel_equal(p2, expected)
+        with catch_warnings(record=True):
+            filled = self.panel.fillna(0)
+            self.assertTrue(np.isfinite(filled.values).all())
+
+            filled = self.panel.fillna(method='backfill')
+            assert_frame_equal(filled['ItemA'],
+                               self.panel['ItemA'].fillna(method='backfill'))
+
+            panel = self.panel.copy()
+            panel['str'] = 'foo'
+
+            filled = panel.fillna(method='backfill')
+            assert_frame_equal(filled['ItemA'],
+                               panel['ItemA'].fillna(method='backfill'))
+
+            empty = self.panel.reindex(items=[])
+            filled = empty.fillna(0)
+            assert_panel_equal(filled, empty)
+
+            self.assertRaises(ValueError, self.panel.fillna)
+            self.assertRaises(ValueError, self.panel.fillna, 5, method='ffill')
+
+            self.assertRaises(TypeError, self.panel.fillna, [1, 2])
+            self.assertRaises(TypeError, self.panel.fillna, (1, 2))
+
+            # limit not implemented when only value is specified
+            p = Panel(np.random.randn(3, 4, 5))
+            p.iloc[0:2, 0:2, 0:2] = np.nan
+            self.assertRaises(NotImplementedError,
+                              lambda: p.fillna(999, limit=1))
+
+            # Test in place fillNA
+            # Expected result
+            expected = Panel([[[0, 1], [2, 1]], [[10, 11], [12, 11]]],
+                             items=['a', 'b'], minor_axis=['x', 'y'],
+                             dtype=np.float64)
+            # method='ffill'
+            p1 = Panel([[[0, 1], [2, np.nan]], [[10, 11], [12, np.nan]]],
+                       items=['a', 'b'], minor_axis=['x', 'y'],
+                       dtype=np.float64)
+            p1.fillna(method='ffill', inplace=True)
+            assert_panel_equal(p1, expected)
+
+            # method='bfill'
+            p2 = Panel([[[0, np.nan], [2, 1]], [[10, np.nan], [12, 11]]],
+                       items=['a', 'b'], minor_axis=['x', 'y'],
+                       dtype=np.float64)
+            p2.fillna(method='bfill', inplace=True)
+            assert_panel_equal(p2, expected)
 
     def test_ffill_bfill(self):
-        assert_panel_equal(self.panel.ffill(),
-                           self.panel.fillna(method='ffill'))
-        assert_panel_equal(self.panel.bfill(),
-                           self.panel.fillna(method='bfill'))
+        with catch_warnings(record=True):
+            assert_panel_equal(self.panel.ffill(),
+                               self.panel.fillna(method='ffill'))
+            assert_panel_equal(self.panel.bfill(),
+                               self.panel.fillna(method='bfill'))
 
     def test_truncate_fillna_bug(self):
-        # #1823
-        result = self.panel.truncate(before=None, after=None, axis='items')
+        with catch_warnings(record=True):
+            # #1823
+            result = self.panel.truncate(before=None, after=None, axis='items')
 
-        # it works!
-        result.fillna(value=0.0)
+            # it works!
+            result.fillna(value=0.0)
 
     def test_swapaxes(self):
-        result = self.panel.swapaxes('items', 'minor')
-        self.assertIs(result.items, self.panel.minor_axis)
+        with catch_warnings(record=True):
+            result = self.panel.swapaxes('items', 'minor')
+            self.assertIs(result.items, self.panel.minor_axis)
 
-        result = self.panel.swapaxes('items', 'major')
-        self.assertIs(result.items, self.panel.major_axis)
+            result = self.panel.swapaxes('items', 'major')
+            self.assertIs(result.items, self.panel.major_axis)
 
-        result = self.panel.swapaxes('major', 'minor')
-        self.assertIs(result.major_axis, self.panel.minor_axis)
+            result = self.panel.swapaxes('major', 'minor')
+            self.assertIs(result.major_axis, self.panel.minor_axis)
 
-        panel = self.panel.copy()
-        result = panel.swapaxes('major', 'minor')
-        panel.values[0, 0, 1] = np.nan
-        expected = panel.swapaxes('major', 'minor')
-        assert_panel_equal(result, expected)
+            panel = self.panel.copy()
+            result = panel.swapaxes('major', 'minor')
+            panel.values[0, 0, 1] = np.nan
+            expected = panel.swapaxes('major', 'minor')
+            assert_panel_equal(result, expected)
 
-        # this should also work
-        result = self.panel.swapaxes(0, 1)
-        self.assertIs(result.items, self.panel.major_axis)
+            # this should also work
+            result = self.panel.swapaxes(0, 1)
+            self.assertIs(result.items, self.panel.major_axis)
 
-        # this works, but return a copy
-        result = self.panel.swapaxes('items', 'items')
-        assert_panel_equal(self.panel, result)
-        self.assertNotEqual(id(self.panel), id(result))
+            # this works, but return a copy
+            result = self.panel.swapaxes('items', 'items')
+            assert_panel_equal(self.panel, result)
+            self.assertNotEqual(id(self.panel), id(result))
 
     def test_transpose(self):
-        result = self.panel.transpose('minor', 'major', 'items')
-        expected = self.panel.swapaxes('items', 'minor')
-        assert_panel_equal(result, expected)
-
-        # test kwargs
-        result = self.panel.transpose(items='minor', major='major',
-                                      minor='items')
-        expected = self.panel.swapaxes('items', 'minor')
-        assert_panel_equal(result, expected)
-
-        # text mixture of args
-        result = self.panel.transpose('minor', major='major', minor='items')
-        expected = self.panel.swapaxes('items', 'minor')
-        assert_panel_equal(result, expected)
-
-        result = self.panel.transpose('minor', 'major', minor='items')
-        expected = self.panel.swapaxes('items', 'minor')
-        assert_panel_equal(result, expected)
-
-        # duplicate axes
-        with tm.assertRaisesRegexp(TypeError,
-                                   'not enough/duplicate arguments'):
-            self.panel.transpose('minor', maj='major', minor='items')
+        with catch_warnings(record=True):
+            result = self.panel.transpose('minor', 'major', 'items')
+            expected = self.panel.swapaxes('items', 'minor')
+            assert_panel_equal(result, expected)
 
-        with tm.assertRaisesRegexp(ValueError, 'repeated axis in transpose'):
-            self.panel.transpose('minor', 'major', major='minor',
-                                 minor='items')
+            # test kwargs
+            result = self.panel.transpose(items='minor', major='major',
+                                          minor='items')
+            expected = self.panel.swapaxes('items', 'minor')
+            assert_panel_equal(result, expected)
 
-        result = self.panel.transpose(2, 1, 0)
-        assert_panel_equal(result, expected)
+            # text mixture of args
+            result = self.panel.transpose(
+                'minor', major='major', minor='items')
+            expected = self.panel.swapaxes('items', 'minor')
+            assert_panel_equal(result, expected)
 
-        result = self.panel.transpose('minor', 'items', 'major')
-        expected = self.panel.swapaxes('items', 'minor')
-        expected = expected.swapaxes('major', 'minor')
-        assert_panel_equal(result, expected)
+            result = self.panel.transpose('minor',
+                                          'major',
+                                          minor='items')
+            expected = self.panel.swapaxes('items', 'minor')
+            assert_panel_equal(result, expected)
 
-        result = self.panel.transpose(2, 0, 1)
-        assert_panel_equal(result, expected)
+            # duplicate axes
+            with tm.assertRaisesRegexp(TypeError,
+                                       'not enough/duplicate arguments'):
+                self.panel.transpose('minor', maj='major', minor='items')
 
-        self.assertRaises(ValueError, self.panel.transpose, 0, 0, 1)
+            with tm.assertRaisesRegexp(ValueError,
+                                       'repeated axis in transpose'):
+                self.panel.transpose('minor', 'major', major='minor',
+                                     minor='items')
+
+            result = self.panel.transpose(2, 1, 0)
+            assert_panel_equal(result, expected)
+
+            result = self.panel.transpose('minor', 'items', 'major')
+            expected = self.panel.swapaxes('items', 'minor')
+            expected = expected.swapaxes('major', 'minor')
+            assert_panel_equal(result, expected)
+
+            result = self.panel.transpose(2, 0, 1)
+            assert_panel_equal(result, expected)
+
+            self.assertRaises(ValueError, self.panel.transpose, 0, 0, 1)
 
     def test_transpose_copy(self):
-        panel = self.panel.copy()
-        result = panel.transpose(2, 0, 1, copy=True)
-        expected = panel.swapaxes('items', 'minor')
-        expected = expected.swapaxes('major', 'minor')
-        assert_panel_equal(result, expected)
+        with catch_warnings(record=True):
+            panel = self.panel.copy()
+            result = panel.transpose(2, 0, 1, copy=True)
+            expected = panel.swapaxes('items', 'minor')
+            expected = expected.swapaxes('major', 'minor')
+            assert_panel_equal(result, expected)
 
-        panel.values[0, 1, 1] = np.nan
-        self.assertTrue(notnull(result.values[1, 0, 1]))
+            panel.values[0, 1, 1] = np.nan
+            self.assertTrue(notnull(result.values[1, 0, 1]))
 
     def test_to_frame(self):
-        # filtered
-        filtered = self.panel.to_frame()
-        expected = self.panel.to_frame().dropna(how='any')
-        assert_frame_equal(filtered, expected)
-
-        # unfiltered
-        unfiltered = self.panel.to_frame(filter_observations=False)
-        assert_panel_equal(unfiltered.to_panel(), self.panel)
-
-        # names
-        self.assertEqual(unfiltered.index.names, ('major', 'minor'))
-
-        # unsorted, round trip
-        df = self.panel.to_frame(filter_observations=False)
-        unsorted = df.take(np.random.permutation(len(df)))
-        pan = unsorted.to_panel()
-        assert_panel_equal(pan, self.panel)
-
-        # preserve original index names
-        df = DataFrame(np.random.randn(6, 2),
-                       index=[['a', 'a', 'b', 'b', 'c', 'c'],
-                              [0, 1, 0, 1, 0, 1]],
-                       columns=['one', 'two'])
-        df.index.names = ['foo', 'bar']
-        df.columns.name = 'baz'
-
-        rdf = df.to_panel().to_frame()
-        self.assertEqual(rdf.index.names, df.index.names)
-        self.assertEqual(rdf.columns.names, df.columns.names)
+        with catch_warnings(record=True):
+            # filtered
+            filtered = self.panel.to_frame()
+            expected = self.panel.to_frame().dropna(how='any')
+            assert_frame_equal(filtered, expected)
+
+            # unfiltered
+            unfiltered = self.panel.to_frame(filter_observations=False)
+            assert_panel_equal(unfiltered.to_panel(), self.panel)
+
+            # names
+            self.assertEqual(unfiltered.index.names, ('major', 'minor'))
+
+            # unsorted, round trip
+            df = self.panel.to_frame(filter_observations=False)
+            unsorted = df.take(np.random.permutation(len(df)))
+            pan = unsorted.to_panel()
+            assert_panel_equal(pan, self.panel)
+
+            # preserve original index names
+            df = DataFrame(np.random.randn(6, 2),
+                           index=[['a', 'a', 'b', 'b', 'c', 'c'],
+                                  [0, 1, 0, 1, 0, 1]],
+                           columns=['one', 'two'])
+            df.index.names = ['foo', 'bar']
+            df.columns.name = 'baz'
+
+            rdf = df.to_panel().to_frame()
+            self.assertEqual(rdf.index.names, df.index.names)
+            self.assertEqual(rdf.columns.names, df.columns.names)
 
     def test_to_frame_mixed(self):
-        panel = self.panel.fillna(0)
-        panel['str'] = 'foo'
-        panel['bool'] = panel['ItemA'] > 0
-
-        lp = panel.to_frame()
-        wp = lp.to_panel()
-        self.assertEqual(wp['bool'].values.dtype, np.bool_)
-        # Previously, this was mutating the underlying index and changing its
-        # name
-        assert_frame_equal(wp['bool'], panel['bool'], check_names=False)
-
-        # GH 8704
-        # with categorical
-        df = panel.to_frame()
-        df['category'] = df['str'].astype('category')
-
-        # to_panel
-        # TODO: this converts back to object
-        p = df.to_panel()
-        expected = panel.copy()
-        expected['category'] = 'foo'
-        assert_panel_equal(p, expected)
+        with catch_warnings(record=True):
+            panel = self.panel.fillna(0)
+            panel['str'] = 'foo'
+            panel['bool'] = panel['ItemA'] > 0
+
+            lp = panel.to_frame()
+            wp = lp.to_panel()
+            self.assertEqual(wp['bool'].values.dtype, np.bool_)
+            # Previously, this was mutating the underlying
+            # index and changing its name
+            assert_frame_equal(wp['bool'], panel['bool'], check_names=False)
+
+            # GH 8704
+            # with categorical
+            df = panel.to_frame()
+            df['category'] = df['str'].astype('category')
+
+            # to_panel
+            # TODO: this converts back to object
+            p = df.to_panel()
+            expected = panel.copy()
+            expected['category'] = 'foo'
+            assert_panel_equal(p, expected)
 
     def test_to_frame_multi_major(self):
-        idx = MultiIndex.from_tuples([(1, 'one'), (1, 'two'), (2, 'one'), (
-            2, 'two')])
-        df = DataFrame([[1, 'a', 1], [2, 'b', 1], [3, 'c', 1], [4, 'd', 1]],
-                       columns=['A', 'B', 'C'], index=idx)
-        wp = Panel({'i1': df, 'i2': df})
-        expected_idx = MultiIndex.from_tuples(
-            [
-                (1, 'one', 'A'), (1, 'one', 'B'),
-                (1, 'one', 'C'), (1, 'two', 'A'),
-                (1, 'two', 'B'), (1, 'two', 'C'),
-                (2, 'one', 'A'), (2, 'one', 'B'),
-                (2, 'one', 'C'), (2, 'two', 'A'),
-                (2, 'two', 'B'), (2, 'two', 'C')
-            ],
-            names=[None, None, 'minor'])
-        expected = DataFrame({'i1': [1, 'a', 1, 2, 'b', 1, 3,
-                                     'c', 1, 4, 'd', 1],
-                              'i2': [1, 'a', 1, 2, 'b',
-                                     1, 3, 'c', 1, 4, 'd', 1]},
-                             index=expected_idx)
-        result = wp.to_frame()
-        assert_frame_equal(result, expected)
-
-        wp.iloc[0, 0].iloc[0] = np.nan  # BUG on setting. GH #5773
-        result = wp.to_frame()
-        assert_frame_equal(result, expected[1:])
-
-        idx = MultiIndex.from_tuples([(1, 'two'), (1, 'one'), (2, 'one'), (
-            np.nan, 'two')])
-        df = DataFrame([[1, 'a', 1], [2, 'b', 1], [3, 'c', 1], [4, 'd', 1]],
-                       columns=['A', 'B', 'C'], index=idx)
-        wp = Panel({'i1': df, 'i2': df})
-        ex_idx = MultiIndex.from_tuples([(1, 'two', 'A'), (1, 'two', 'B'),
-                                         (1, 'two', 'C'),
-                                         (1, 'one', 'A'),
-                                         (1, 'one', 'B'),
-                                         (1, 'one', 'C'),
-                                         (2, 'one', 'A'),
-                                         (2, 'one', 'B'),
-                                         (2, 'one', 'C'),
-                                         (np.nan, 'two', 'A'),
-                                         (np.nan, 'two', 'B'),
-                                         (np.nan, 'two', 'C')],
-                                        names=[None, None, 'minor'])
-        expected.index = ex_idx
-        result = wp.to_frame()
-        assert_frame_equal(result, expected)
+        with catch_warnings(record=True):
+            idx = MultiIndex.from_tuples(
+                [(1, 'one'), (1, 'two'), (2, 'one'), (2, 'two')])
+            df = DataFrame([[1, 'a', 1], [2, 'b', 1],
+                            [3, 'c', 1], [4, 'd', 1]],
+                           columns=['A', 'B', 'C'], index=idx)
+            wp = Panel({'i1': df, 'i2': df})
+            expected_idx = MultiIndex.from_tuples(
+                [
+                    (1, 'one', 'A'), (1, 'one', 'B'),
+                    (1, 'one', 'C'), (1, 'two', 'A'),
+                    (1, 'two', 'B'), (1, 'two', 'C'),
+                    (2, 'one', 'A'), (2, 'one', 'B'),
+                    (2, 'one', 'C'), (2, 'two', 'A'),
+                    (2, 'two', 'B'), (2, 'two', 'C')
+                ],
+                names=[None, None, 'minor'])
+            expected = DataFrame({'i1': [1, 'a', 1, 2, 'b', 1, 3,
+                                         'c', 1, 4, 'd', 1],
+                                  'i2': [1, 'a', 1, 2, 'b',
+                                         1, 3, 'c', 1, 4, 'd', 1]},
+                                 index=expected_idx)
+            result = wp.to_frame()
+            assert_frame_equal(result, expected)
+
+            wp.iloc[0, 0].iloc[0] = np.nan  # BUG on setting. GH #5773
+            result = wp.to_frame()
+            assert_frame_equal(result, expected[1:])
+
+            idx = MultiIndex.from_tuples(
+                [(1, 'two'), (1, 'one'), (2, 'one'), (np.nan, 'two')])
+            df = DataFrame([[1, 'a', 1], [2, 'b', 1],
+                            [3, 'c', 1], [4, 'd', 1]],
+                           columns=['A', 'B', 'C'], index=idx)
+            wp = Panel({'i1': df, 'i2': df})
+            ex_idx = MultiIndex.from_tuples([(1, 'two', 'A'), (1, 'two', 'B'),
+                                             (1, 'two', 'C'),
+                                             (1, 'one', 'A'),
+                                             (1, 'one', 'B'),
+                                             (1, 'one', 'C'),
+                                             (2, 'one', 'A'),
+                                             (2, 'one', 'B'),
+                                             (2, 'one', 'C'),
+                                             (np.nan, 'two', 'A'),
+                                             (np.nan, 'two', 'B'),
+                                             (np.nan, 'two', 'C')],
+                                            names=[None, None, 'minor'])
+            expected.index = ex_idx
+            result = wp.to_frame()
+            assert_frame_equal(result, expected)
 
     def test_to_frame_multi_major_minor(self):
-        cols = MultiIndex(levels=[['C_A', 'C_B'], ['C_1', 'C_2']],
-                          labels=[[0, 0, 1, 1], [0, 1, 0, 1]])
-        idx = MultiIndex.from_tuples([(1, 'one'), (1, 'two'), (2, 'one'), (
-            2, 'two'), (3, 'three'), (4, 'four')])
-        df = DataFrame([[1, 2, 11, 12], [3, 4, 13, 14],
-                        ['a', 'b', 'w', 'x'],
-                        ['c', 'd', 'y', 'z'], [-1, -2, -3, -4],
-                        [-5, -6, -7, -8]], columns=cols, index=idx)
-        wp = Panel({'i1': df, 'i2': df})
-
-        exp_idx = MultiIndex.from_tuples(
-            [(1, 'one', 'C_A', 'C_1'), (1, 'one', 'C_A', 'C_2'),
-             (1, 'one', 'C_B', 'C_1'), (1, 'one', 'C_B', 'C_2'),
-             (1, 'two', 'C_A', 'C_1'), (1, 'two', 'C_A', 'C_2'),
-             (1, 'two', 'C_B', 'C_1'), (1, 'two', 'C_B', 'C_2'),
-             (2, 'one', 'C_A', 'C_1'), (2, 'one', 'C_A', 'C_2'),
-             (2, 'one', 'C_B', 'C_1'), (2, 'one', 'C_B', 'C_2'),
-             (2, 'two', 'C_A', 'C_1'), (2, 'two', 'C_A', 'C_2'),
-             (2, 'two', 'C_B', 'C_1'), (2, 'two', 'C_B', 'C_2'),
-             (3, 'three', 'C_A', 'C_1'), (3, 'three', 'C_A', 'C_2'),
-             (3, 'three', 'C_B', 'C_1'), (3, 'three', 'C_B', 'C_2'),
-             (4, 'four', 'C_A', 'C_1'), (4, 'four', 'C_A', 'C_2'),
-             (4, 'four', 'C_B', 'C_1'), (4, 'four', 'C_B', 'C_2')],
-            names=[None, None, None, None])
-        exp_val = [[1, 1], [2, 2], [11, 11], [12, 12], [3, 3], [4, 4],
-                   [13, 13], [14, 14], ['a', 'a'], ['b', 'b'], ['w', 'w'],
-                   ['x', 'x'], ['c', 'c'], ['d', 'd'], ['y', 'y'], ['z', 'z'],
-                   [-1, -1], [-2, -2], [-3, -3], [-4, -4], [-5, -5], [-6, -6],
-                   [-7, -7], [-8, -8]]
-        result = wp.to_frame()
-        expected = DataFrame(exp_val, columns=['i1', 'i2'], index=exp_idx)
-        assert_frame_equal(result, expected)
+        with catch_warnings(record=True):
+            cols = MultiIndex(levels=[['C_A', 'C_B'], ['C_1', 'C_2']],
+                              labels=[[0, 0, 1, 1], [0, 1, 0, 1]])
+            idx = MultiIndex.from_tuples([(1, 'one'), (1, 'two'), (2, 'one'), (
+                2, 'two'), (3, 'three'), (4, 'four')])
+            df = DataFrame([[1, 2, 11, 12], [3, 4, 13, 14],
+                            ['a', 'b', 'w', 'x'],
+                            ['c', 'd', 'y', 'z'], [-1, -2, -3, -4],
+                            [-5, -6, -7, -8]], columns=cols, index=idx)
+            wp = Panel({'i1': df, 'i2': df})
+
+            exp_idx = MultiIndex.from_tuples(
+                [(1, 'one', 'C_A', 'C_1'), (1, 'one', 'C_A', 'C_2'),
+                 (1, 'one', 'C_B', 'C_1'), (1, 'one', 'C_B', 'C_2'),
+                 (1, 'two', 'C_A', 'C_1'), (1, 'two', 'C_A', 'C_2'),
+                 (1, 'two', 'C_B', 'C_1'), (1, 'two', 'C_B', 'C_2'),
+                 (2, 'one', 'C_A', 'C_1'), (2, 'one', 'C_A', 'C_2'),
+                 (2, 'one', 'C_B', 'C_1'), (2, 'one', 'C_B', 'C_2'),
+                 (2, 'two', 'C_A', 'C_1'), (2, 'two', 'C_A', 'C_2'),
+                 (2, 'two', 'C_B', 'C_1'), (2, 'two', 'C_B', 'C_2'),
+                 (3, 'three', 'C_A', 'C_1'), (3, 'three', 'C_A', 'C_2'),
+                 (3, 'three', 'C_B', 'C_1'), (3, 'three', 'C_B', 'C_2'),
+                 (4, 'four', 'C_A', 'C_1'), (4, 'four', 'C_A', 'C_2'),
+                 (4, 'four', 'C_B', 'C_1'), (4, 'four', 'C_B', 'C_2')],
+                names=[None, None, None, None])
+            exp_val = [[1, 1], [2, 2], [11, 11], [12, 12],
+                       [3, 3], [4, 4],
+                       [13, 13], [14, 14], ['a', 'a'],
+                       ['b', 'b'], ['w', 'w'],
+                       ['x', 'x'], ['c', 'c'], ['d', 'd'], [
+                           'y', 'y'], ['z', 'z'],
+                       [-1, -1], [-2, -2], [-3, -3], [-4, -4],
+                       [-5, -5], [-6, -6],
+                       [-7, -7], [-8, -8]]
+            result = wp.to_frame()
+            expected = DataFrame(exp_val, columns=['i1', 'i2'], index=exp_idx)
+            assert_frame_equal(result, expected)
 
     def test_to_frame_multi_drop_level(self):
-        idx = MultiIndex.from_tuples([(1, 'one'), (2, 'one'), (2, 'two')])
-        df = DataFrame({'A': [np.nan, 1, 2]}, index=idx)
-        wp = Panel({'i1': df, 'i2': df})
-        result = wp.to_frame()
-        exp_idx = MultiIndex.from_tuples([(2, 'one', 'A'), (2, 'two', 'A')],
-                                         names=[None, None, 'minor'])
-        expected = DataFrame({'i1': [1., 2], 'i2': [1., 2]}, index=exp_idx)
-        assert_frame_equal(result, expected)
+        with catch_warnings(record=True):
+            idx = MultiIndex.from_tuples([(1, 'one'), (2, 'one'), (2, 'two')])
+            df = DataFrame({'A': [np.nan, 1, 2]}, index=idx)
+            wp = Panel({'i1': df, 'i2': df})
+            result = wp.to_frame()
+            exp_idx = MultiIndex.from_tuples(
+                [(2, 'one', 'A'), (2, 'two', 'A')],
+                names=[None, None, 'minor'])
+            expected = DataFrame({'i1': [1., 2], 'i2': [1., 2]}, index=exp_idx)
+            assert_frame_equal(result, expected)
 
     def test_to_panel_na_handling(self):
-        df = DataFrame(np.random.randint(0, 10, size=20).reshape((10, 2)),
-                       index=[[0, 0, 0, 0, 0, 0, 1, 1, 1, 1],
-                              [0, 1, 2, 3, 4, 5, 2, 3, 4, 5]])
+        with catch_warnings(record=True):
+            df = DataFrame(np.random.randint(0, 10, size=20).reshape((10, 2)),
+                           index=[[0, 0, 0, 0, 0, 0, 1, 1, 1, 1],
+                                  [0, 1, 2, 3, 4, 5, 2, 3, 4, 5]])
 
-        panel = df.to_panel()
-        self.assertTrue(isnull(panel[0].loc[1, [0, 1]]).all())
+            panel = df.to_panel()
+            self.assertTrue(isnull(panel[0].loc[1, [0, 1]]).all())
 
     def test_to_panel_duplicates(self):
         # #2441
-        df = DataFrame({'a': [0, 0, 1], 'b': [1, 1, 1], 'c': [1, 2, 3]})
-        idf = df.set_index(['a', 'b'])
-        assertRaisesRegexp(ValueError, 'non-uniquely indexed', idf.to_panel)
+        with catch_warnings(record=True):
+            df = DataFrame({'a': [0, 0, 1], 'b': [1, 1, 1], 'c': [1, 2, 3]})
+            idf = df.set_index(['a', 'b'])
+            assertRaisesRegexp(
+                ValueError, 'non-uniquely indexed', idf.to_panel)
 
     def test_panel_dups(self):
+        with catch_warnings(record=True):
 
-        # GH 4960
-        # duplicates in an index
+            # GH 4960
+            # duplicates in an index
 
-        # items
-        data = np.random.randn(5, 100, 5)
-        no_dup_panel = Panel(data, items=list("ABCDE"))
-        panel = Panel(data, items=list("AACDE"))
+            # items
+            data = np.random.randn(5, 100, 5)
+            no_dup_panel = Panel(data, items=list("ABCDE"))
+            panel = Panel(data, items=list("AACDE"))
 
-        expected = no_dup_panel['A']
-        result = panel.iloc[0]
-        assert_frame_equal(result, expected)
+            expected = no_dup_panel['A']
+            result = panel.iloc[0]
+            assert_frame_equal(result, expected)
 
-        expected = no_dup_panel['E']
-        result = panel.loc['E']
-        assert_frame_equal(result, expected)
+            expected = no_dup_panel['E']
+            result = panel.loc['E']
+            assert_frame_equal(result, expected)
 
-        expected = no_dup_panel.loc[['A', 'B']]
-        expected.items = ['A', 'A']
-        result = panel.loc['A']
-        assert_panel_equal(result, expected)
+            expected = no_dup_panel.loc[['A', 'B']]
+            expected.items = ['A', 'A']
+            result = panel.loc['A']
+            assert_panel_equal(result, expected)
 
-        # major
-        data = np.random.randn(5, 5, 5)
-        no_dup_panel = Panel(data, major_axis=list("ABCDE"))
-        panel = Panel(data, major_axis=list("AACDE"))
+            # major
+            data = np.random.randn(5, 5, 5)
+            no_dup_panel = Panel(data, major_axis=list("ABCDE"))
+            panel = Panel(data, major_axis=list("AACDE"))
 
-        expected = no_dup_panel.loc[:, 'A']
-        result = panel.iloc[:, 0]
-        assert_frame_equal(result, expected)
+            expected = no_dup_panel.loc[:, 'A']
+            result = panel.iloc[:, 0]
+            assert_frame_equal(result, expected)
 
-        expected = no_dup_panel.loc[:, 'E']
-        result = panel.loc[:, 'E']
-        assert_frame_equal(result, expected)
+            expected = no_dup_panel.loc[:, 'E']
+            result = panel.loc[:, 'E']
+            assert_frame_equal(result, expected)
 
-        expected = no_dup_panel.loc[:, ['A', 'B']]
-        expected.major_axis = ['A', 'A']
-        result = panel.loc[:, 'A']
-        assert_panel_equal(result, expected)
+            expected = no_dup_panel.loc[:, ['A', 'B']]
+            expected.major_axis = ['A', 'A']
+            result = panel.loc[:, 'A']
+            assert_panel_equal(result, expected)
 
-        # minor
-        data = np.random.randn(5, 100, 5)
-        no_dup_panel = Panel(data, minor_axis=list("ABCDE"))
-        panel = Panel(data, minor_axis=list("AACDE"))
+            # minor
+            data = np.random.randn(5, 100, 5)
+            no_dup_panel = Panel(data, minor_axis=list("ABCDE"))
+            panel = Panel(data, minor_axis=list("AACDE"))
 
-        expected = no_dup_panel.loc[:, :, 'A']
-        result = panel.iloc[:, :, 0]
-        assert_frame_equal(result, expected)
+            expected = no_dup_panel.loc[:, :, 'A']
+            result = panel.iloc[:, :, 0]
+            assert_frame_equal(result, expected)
 
-        expected = no_dup_panel.loc[:, :, 'E']
-        result = panel.loc[:, :, 'E']
-        assert_frame_equal(result, expected)
+            expected = no_dup_panel.loc[:, :, 'E']
+            result = panel.loc[:, :, 'E']
+            assert_frame_equal(result, expected)
 
-        expected = no_dup_panel.loc[:, :, ['A', 'B']]
-        expected.minor_axis = ['A', 'A']
-        result = panel.loc[:, :, 'A']
-        assert_panel_equal(result, expected)
+            expected = no_dup_panel.loc[:, :, ['A', 'B']]
+            expected.minor_axis = ['A', 'A']
+            result = panel.loc[:, :, 'A']
+            assert_panel_equal(result, expected)
 
     def test_filter(self):
         pass
 
     def test_compound(self):
-        compounded = self.panel.compound()
+        with catch_warnings(record=True):
+            compounded = self.panel.compound()
 
-        assert_series_equal(compounded['ItemA'],
-                            (1 + self.panel['ItemA']).product(0) - 1,
-                            check_names=False)
+            assert_series_equal(compounded['ItemA'],
+                                (1 + self.panel['ItemA']).product(0) - 1,
+                                check_names=False)
 
     def test_shift(self):
-        # major
-        idx = self.panel.major_axis[0]
-        idx_lag = self.panel.major_axis[1]
-        shifted = self.panel.shift(1)
-        assert_frame_equal(self.panel.major_xs(idx), shifted.major_xs(idx_lag))
-
-        # minor
-        idx = self.panel.minor_axis[0]
-        idx_lag = self.panel.minor_axis[1]
-        shifted = self.panel.shift(1, axis='minor')
-        assert_frame_equal(self.panel.minor_xs(idx), shifted.minor_xs(idx_lag))
-
-        # items
-        idx = self.panel.items[0]
-        idx_lag = self.panel.items[1]
-        shifted = self.panel.shift(1, axis='items')
-        assert_frame_equal(self.panel[idx], shifted[idx_lag])
-
-        # negative numbers, #2164
-        result = self.panel.shift(-1)
-        expected = Panel(dict((i, f.shift(-1)[:-1])
-                              for i, f in self.panel.iteritems()))
-        assert_panel_equal(result, expected)
-
-        # mixed dtypes #6959
-        data = [('item ' + ch, makeMixedDataFrame()) for ch in list('abcde')]
-        data = dict(data)
-        mixed_panel = Panel.from_dict(data, orient='minor')
-        shifted = mixed_panel.shift(1)
-        assert_series_equal(mixed_panel.dtypes, shifted.dtypes)
+        with catch_warnings(record=True):
+            # major
+            idx = self.panel.major_axis[0]
+            idx_lag = self.panel.major_axis[1]
+            shifted = self.panel.shift(1)
+            assert_frame_equal(self.panel.major_xs(idx),
+                               shifted.major_xs(idx_lag))
+
+            # minor
+            idx = self.panel.minor_axis[0]
+            idx_lag = self.panel.minor_axis[1]
+            shifted = self.panel.shift(1, axis='minor')
+            assert_frame_equal(self.panel.minor_xs(idx),
+                               shifted.minor_xs(idx_lag))
+
+            # items
+            idx = self.panel.items[0]
+            idx_lag = self.panel.items[1]
+            shifted = self.panel.shift(1, axis='items')
+            assert_frame_equal(self.panel[idx], shifted[idx_lag])
+
+            # negative numbers, #2164
+            result = self.panel.shift(-1)
+            expected = Panel(dict((i, f.shift(-1)[:-1])
+                                  for i, f in self.panel.iteritems()))
+            assert_panel_equal(result, expected)
+
+            # mixed dtypes #6959
+            data = [('item ' + ch, makeMixedDataFrame())
+                    for ch in list('abcde')]
+            data = dict(data)
+            mixed_panel = Panel.from_dict(data, orient='minor')
+            shifted = mixed_panel.shift(1)
+            assert_series_equal(mixed_panel.dtypes, shifted.dtypes)
 
     def test_tshift(self):
         # PeriodIndex
-        ps = tm.makePeriodPanel()
-        shifted = ps.tshift(1)
-        unshifted = shifted.tshift(-1)
+        with catch_warnings(record=True):
+            ps = tm.makePeriodPanel()
+            shifted = ps.tshift(1)
+            unshifted = shifted.tshift(-1)
 
-        assert_panel_equal(unshifted, ps)
+            assert_panel_equal(unshifted, ps)
 
-        shifted2 = ps.tshift(freq='B')
-        assert_panel_equal(shifted, shifted2)
+            shifted2 = ps.tshift(freq='B')
+            assert_panel_equal(shifted, shifted2)
 
-        shifted3 = ps.tshift(freq=BDay())
-        assert_panel_equal(shifted, shifted3)
+            shifted3 = ps.tshift(freq=BDay())
+            assert_panel_equal(shifted, shifted3)
 
-        assertRaisesRegexp(ValueError, 'does not match', ps.tshift, freq='M')
+            assertRaisesRegexp(ValueError, 'does not match',
+                               ps.tshift, freq='M')
 
-        # DatetimeIndex
-        panel = _panel
-        shifted = panel.tshift(1)
-        unshifted = shifted.tshift(-1)
+            # DatetimeIndex
+            panel = make_test_panel()
+            shifted = panel.tshift(1)
+            unshifted = shifted.tshift(-1)
 
-        assert_panel_equal(panel, unshifted)
+            assert_panel_equal(panel, unshifted)
 
-        shifted2 = panel.tshift(freq=panel.major_axis.freq)
-        assert_panel_equal(shifted, shifted2)
+            shifted2 = panel.tshift(freq=panel.major_axis.freq)
+            assert_panel_equal(shifted, shifted2)
 
-        inferred_ts = Panel(panel.values, items=panel.items,
-                            major_axis=Index(np.asarray(panel.major_axis)),
-                            minor_axis=panel.minor_axis)
-        shifted = inferred_ts.tshift(1)
-        unshifted = shifted.tshift(-1)
-        assert_panel_equal(shifted, panel.tshift(1))
-        assert_panel_equal(unshifted, inferred_ts)
+            inferred_ts = Panel(panel.values, items=panel.items,
+                                major_axis=Index(np.asarray(panel.major_axis)),
+                                minor_axis=panel.minor_axis)
+            shifted = inferred_ts.tshift(1)
+            unshifted = shifted.tshift(-1)
+            assert_panel_equal(shifted, panel.tshift(1))
+            assert_panel_equal(unshifted, inferred_ts)
 
-        no_freq = panel.iloc[:, [0, 5, 7], :]
-        self.assertRaises(ValueError, no_freq.tshift)
+            no_freq = panel.iloc[:, [0, 5, 7], :]
+            self.assertRaises(ValueError, no_freq.tshift)
 
     def test_pct_change(self):
-        df1 = DataFrame({'c1': [1, 2, 5], 'c2': [3, 4, 6]})
-        df2 = df1 + 1
-        df3 = DataFrame({'c1': [3, 4, 7], 'c2': [5, 6, 8]})
-        wp = Panel({'i1': df1, 'i2': df2, 'i3': df3})
-        # major, 1
-        result = wp.pct_change()  # axis='major'
-        expected = Panel({'i1': df1.pct_change(),
-                          'i2': df2.pct_change(),
-                          'i3': df3.pct_change()})
-        assert_panel_equal(result, expected)
-        result = wp.pct_change(axis=1)
-        assert_panel_equal(result, expected)
-        # major, 2
-        result = wp.pct_change(periods=2)
-        expected = Panel({'i1': df1.pct_change(2),
-                          'i2': df2.pct_change(2),
-                          'i3': df3.pct_change(2)})
-        assert_panel_equal(result, expected)
-        # minor, 1
-        result = wp.pct_change(axis='minor')
-        expected = Panel({'i1': df1.pct_change(axis=1),
-                          'i2': df2.pct_change(axis=1),
-                          'i3': df3.pct_change(axis=1)})
-        assert_panel_equal(result, expected)
-        result = wp.pct_change(axis=2)
-        assert_panel_equal(result, expected)
-        # minor, 2
-        result = wp.pct_change(periods=2, axis='minor')
-        expected = Panel({'i1': df1.pct_change(periods=2, axis=1),
-                          'i2': df2.pct_change(periods=2, axis=1),
-                          'i3': df3.pct_change(periods=2, axis=1)})
-        assert_panel_equal(result, expected)
-        # items, 1
-        result = wp.pct_change(axis='items')
-        expected = Panel({'i1': DataFrame({'c1': [np.nan, np.nan, np.nan],
-                                           'c2': [np.nan, np.nan, np.nan]}),
-                          'i2': DataFrame({'c1': [1, 0.5, .2],
-                                           'c2': [1. / 3, 0.25, 1. / 6]}),
-                          'i3': DataFrame({'c1': [.5, 1. / 3, 1. / 6],
-                                           'c2': [.25, .2, 1. / 7]})})
-        assert_panel_equal(result, expected)
-        result = wp.pct_change(axis=0)
-        assert_panel_equal(result, expected)
-        # items, 2
-        result = wp.pct_change(periods=2, axis='items')
-        expected = Panel({'i1': DataFrame({'c1': [np.nan, np.nan, np.nan],
-                                           'c2': [np.nan, np.nan, np.nan]}),
-                          'i2': DataFrame({'c1': [np.nan, np.nan, np.nan],
-                                           'c2': [np.nan, np.nan, np.nan]}),
-                          'i3': DataFrame({'c1': [2, 1, .4],
-                                           'c2': [2. / 3, .5, 1. / 3]})})
-        assert_panel_equal(result, expected)
+        with catch_warnings(record=True):
+            df1 = DataFrame({'c1': [1, 2, 5], 'c2': [3, 4, 6]})
+            df2 = df1 + 1
+            df3 = DataFrame({'c1': [3, 4, 7], 'c2': [5, 6, 8]})
+            wp = Panel({'i1': df1, 'i2': df2, 'i3': df3})
+            # major, 1
+            result = wp.pct_change()  # axis='major'
+            expected = Panel({'i1': df1.pct_change(),
+                              'i2': df2.pct_change(),
+                              'i3': df3.pct_change()})
+            assert_panel_equal(result, expected)
+            result = wp.pct_change(axis=1)
+            assert_panel_equal(result, expected)
+            # major, 2
+            result = wp.pct_change(periods=2)
+            expected = Panel({'i1': df1.pct_change(2),
+                              'i2': df2.pct_change(2),
+                              'i3': df3.pct_change(2)})
+            assert_panel_equal(result, expected)
+            # minor, 1
+            result = wp.pct_change(axis='minor')
+            expected = Panel({'i1': df1.pct_change(axis=1),
+                              'i2': df2.pct_change(axis=1),
+                              'i3': df3.pct_change(axis=1)})
+            assert_panel_equal(result, expected)
+            result = wp.pct_change(axis=2)
+            assert_panel_equal(result, expected)
+            # minor, 2
+            result = wp.pct_change(periods=2, axis='minor')
+            expected = Panel({'i1': df1.pct_change(periods=2, axis=1),
+                              'i2': df2.pct_change(periods=2, axis=1),
+                              'i3': df3.pct_change(periods=2, axis=1)})
+            assert_panel_equal(result, expected)
+            # items, 1
+            result = wp.pct_change(axis='items')
+            expected = Panel(
+                {'i1': DataFrame({'c1': [np.nan, np.nan, np.nan],
+                                  'c2': [np.nan, np.nan, np.nan]}),
+                 'i2': DataFrame({'c1': [1, 0.5, .2],
+                                  'c2': [1. / 3, 0.25, 1. / 6]}),
+                 'i3': DataFrame({'c1': [.5, 1. / 3, 1. / 6],
+                                  'c2': [.25, .2, 1. / 7]})})
+            assert_panel_equal(result, expected)
+            result = wp.pct_change(axis=0)
+            assert_panel_equal(result, expected)
+            # items, 2
+            result = wp.pct_change(periods=2, axis='items')
+            expected = Panel(
+                {'i1': DataFrame({'c1': [np.nan, np.nan, np.nan],
+                                  'c2': [np.nan, np.nan, np.nan]}),
+                 'i2': DataFrame({'c1': [np.nan, np.nan, np.nan],
+                                  'c2': [np.nan, np.nan, np.nan]}),
+                 'i3': DataFrame({'c1': [2, 1, .4],
+                                  'c2': [2. / 3, .5, 1. / 3]})})
+            assert_panel_equal(result, expected)
 
     def test_round(self):
-        values = [[[-3.2, 2.2], [0, -4.8213], [3.123, 123.12],
-                   [-1566.213, 88.88], [-12, 94.5]],
-                  [[-5.82, 3.5], [6.21, -73.272], [-9.087, 23.12],
-                   [272.212, -99.99], [23, -76.5]]]
-        evalues = [[[float(np.around(i)) for i in j] for j in k]
-                   for k in values]
-        p = Panel(values, items=['Item1', 'Item2'],
-                  major_axis=pd.date_range('1/1/2000', periods=5),
-                  minor_axis=['A', 'B'])
-        expected = Panel(evalues, items=['Item1', 'Item2'],
-                         major_axis=pd.date_range('1/1/2000', periods=5),
-                         minor_axis=['A', 'B'])
-        result = p.round()
-        self.assert_panel_equal(expected, result)
+        with catch_warnings(record=True):
+            values = [[[-3.2, 2.2], [0, -4.8213], [3.123, 123.12],
+                       [-1566.213, 88.88], [-12, 94.5]],
+                      [[-5.82, 3.5], [6.21, -73.272], [-9.087, 23.12],
+                       [272.212, -99.99], [23, -76.5]]]
+            evalues = [[[float(np.around(i)) for i in j] for j in k]
+                       for k in values]
+            p = Panel(values, items=['Item1', 'Item2'],
+                      major_axis=pd.date_range('1/1/2000', periods=5),
+                      minor_axis=['A', 'B'])
+            expected = Panel(evalues, items=['Item1', 'Item2'],
+                             major_axis=pd.date_range('1/1/2000', periods=5),
+                             minor_axis=['A', 'B'])
+            result = p.round()
+            assert_panel_equal(expected, result)
 
     def test_numpy_round(self):
-        values = [[[-3.2, 2.2], [0, -4.8213], [3.123, 123.12],
-                   [-1566.213, 88.88], [-12, 94.5]],
-                  [[-5.82, 3.5], [6.21, -73.272], [-9.087, 23.12],
-                   [272.212, -99.99], [23, -76.5]]]
-        evalues = [[[float(np.around(i)) for i in j] for j in k]
-                   for k in values]
-        p = Panel(values, items=['Item1', 'Item2'],
-                  major_axis=pd.date_range('1/1/2000', periods=5),
-                  minor_axis=['A', 'B'])
-        expected = Panel(evalues, items=['Item1', 'Item2'],
-                         major_axis=pd.date_range('1/1/2000', periods=5),
-                         minor_axis=['A', 'B'])
-        result = np.round(p)
-        self.assert_panel_equal(expected, result)
-
-        msg = "the 'out' parameter is not supported"
-        tm.assertRaisesRegexp(ValueError, msg, np.round, p, out=p)
+        with catch_warnings(record=True):
+            values = [[[-3.2, 2.2], [0, -4.8213], [3.123, 123.12],
+                       [-1566.213, 88.88], [-12, 94.5]],
+                      [[-5.82, 3.5], [6.21, -73.272], [-9.087, 23.12],
+                       [272.212, -99.99], [23, -76.5]]]
+            evalues = [[[float(np.around(i)) for i in j] for j in k]
+                       for k in values]
+            p = Panel(values, items=['Item1', 'Item2'],
+                      major_axis=pd.date_range('1/1/2000', periods=5),
+                      minor_axis=['A', 'B'])
+            expected = Panel(evalues, items=['Item1', 'Item2'],
+                             major_axis=pd.date_range('1/1/2000', periods=5),
+                             minor_axis=['A', 'B'])
+            result = np.round(p)
+            assert_panel_equal(expected, result)
+
+            msg = "the 'out' parameter is not supported"
+            tm.assertRaisesRegexp(ValueError, msg, np.round, p, out=p)
 
     def test_multiindex_get(self):
-        ind = MultiIndex.from_tuples([('a', 1), ('a', 2), ('b', 1), ('b', 2)],
-                                     names=['first', 'second'])
-        wp = Panel(np.random.random((4, 5, 5)),
-                   items=ind,
-                   major_axis=np.arange(5),
-                   minor_axis=np.arange(5))
-        f1 = wp['a']
-        f2 = wp.loc['a']
-        assert_panel_equal(f1, f2)
-
-        self.assertTrue((f1.items == [1, 2]).all())
-        self.assertTrue((f2.items == [1, 2]).all())
-
-        ind = MultiIndex.from_tuples([('a', 1), ('a', 2), ('b', 1)],
-                                     names=['first', 'second'])
+        with catch_warnings(record=True):
+            ind = MultiIndex.from_tuples(
+                [('a', 1), ('a', 2), ('b', 1), ('b', 2)],
+                names=['first', 'second'])
+            wp = Panel(np.random.random((4, 5, 5)),
+                       items=ind,
+                       major_axis=np.arange(5),
+                       minor_axis=np.arange(5))
+            f1 = wp['a']
+            f2 = wp.loc['a']
+            assert_panel_equal(f1, f2)
+
+            self.assertTrue((f1.items == [1, 2]).all())
+            self.assertTrue((f2.items == [1, 2]).all())
+
+            ind = MultiIndex.from_tuples([('a', 1), ('a', 2), ('b', 1)],
+                                         names=['first', 'second'])
 
     def test_multiindex_blocks(self):
-        ind = MultiIndex.from_tuples([('a', 1), ('a', 2), ('b', 1)],
-                                     names=['first', 'second'])
-        wp = Panel(self.panel._data)
-        wp.items = ind
-        f1 = wp['a']
-        self.assertTrue((f1.items == [1, 2]).all())
+        with catch_warnings(record=True):
+            ind = MultiIndex.from_tuples([('a', 1), ('a', 2), ('b', 1)],
+                                         names=['first', 'second'])
+            wp = Panel(self.panel._data)
+            wp.items = ind
+            f1 = wp['a']
+            self.assertTrue((f1.items == [1, 2]).all())
 
-        f1 = wp[('b', 1)]
-        self.assertTrue((f1.columns == ['A', 'B', 'C', 'D']).all())
+            f1 = wp[('b', 1)]
+            self.assertTrue((f1.columns == ['A', 'B', 'C', 'D']).all())
 
     def test_repr_empty(self):
-        empty = Panel()
-        repr(empty)
+        with catch_warnings(record=True):
+            empty = Panel()
+            repr(empty)
 
     def test_rename(self):
-        mapper = {'ItemA': 'foo', 'ItemB': 'bar', 'ItemC': 'baz'}
+        with catch_warnings(record=True):
+            mapper = {'ItemA': 'foo', 'ItemB': 'bar', 'ItemC': 'baz'}
 
-        renamed = self.panel.rename_axis(mapper, axis=0)
-        exp = Index(['foo', 'bar', 'baz'])
-        self.assert_index_equal(renamed.items, exp)
+            renamed = self.panel.rename_axis(mapper, axis=0)
+            exp = Index(['foo', 'bar', 'baz'])
+            self.assert_index_equal(renamed.items, exp)
 
-        renamed = self.panel.rename_axis(str.lower, axis=2)
-        exp = Index(['a', 'b', 'c', 'd'])
-        self.assert_index_equal(renamed.minor_axis, exp)
+            renamed = self.panel.rename_axis(str.lower, axis=2)
+            exp = Index(['a', 'b', 'c', 'd'])
+            self.assert_index_equal(renamed.minor_axis, exp)
 
-        # don't copy
-        renamed_nocopy = self.panel.rename_axis(mapper, axis=0, copy=False)
-        renamed_nocopy['foo'] = 3.
-        self.assertTrue((self.panel['ItemA'].values == 3).all())
+            # don't copy
+            renamed_nocopy = self.panel.rename_axis(mapper, axis=0, copy=False)
+            renamed_nocopy['foo'] = 3.
+            self.assertTrue((self.panel['ItemA'].values == 3).all())
 
     def test_get_attr(self):
         assert_frame_equal(self.panel['ItemA'], self.panel.ItemA)
@@ -2046,12 +2170,13 @@ class TestPanel(tm.TestCase, PanelTests, CheckIndexing, SafeForLongAndSparse,
         assert_frame_equal(self.panel['i'], self.panel.i)
 
     def test_from_frame_level1_unsorted(self):
-        tuples = [('MSFT', 3), ('MSFT', 2), ('AAPL', 2), ('AAPL', 1),
-                  ('MSFT', 1)]
-        midx = MultiIndex.from_tuples(tuples)
-        df = DataFrame(np.random.rand(5, 4), index=midx)
-        p = df.to_panel()
-        assert_frame_equal(p.minor_xs(2), df.xs(2, level=1).sort_index())
+        with catch_warnings(record=True):
+            tuples = [('MSFT', 3), ('MSFT', 2), ('AAPL', 2), ('AAPL', 1),
+                      ('MSFT', 1)]
+            midx = MultiIndex.from_tuples(tuples)
+            df = DataFrame(np.random.rand(5, 4), index=midx)
+            p = df.to_panel()
+            assert_frame_equal(p.minor_xs(2), df.xs(2, level=1).sort_index())
 
     def test_to_excel(self):
         try:
@@ -2094,162 +2219,191 @@ class TestPanel(tm.TestCase, PanelTests, CheckIndexing, SafeForLongAndSparse,
                 assert_frame_equal(df, recdf)
 
     def test_dropna(self):
-        p = Panel(np.random.randn(4, 5, 6), major_axis=list('abcde'))
-        p.loc[:, ['b', 'd'], 0] = np.nan
+        with catch_warnings(record=True):
+            p = Panel(np.random.randn(4, 5, 6), major_axis=list('abcde'))
+            p.loc[:, ['b', 'd'], 0] = np.nan
 
-        result = p.dropna(axis=1)
-        exp = p.loc[:, ['a', 'c', 'e'], :]
-        assert_panel_equal(result, exp)
-        inp = p.copy()
-        inp.dropna(axis=1, inplace=True)
-        assert_panel_equal(inp, exp)
+            result = p.dropna(axis=1)
+            exp = p.loc[:, ['a', 'c', 'e'], :]
+            assert_panel_equal(result, exp)
+            inp = p.copy()
+            inp.dropna(axis=1, inplace=True)
+            assert_panel_equal(inp, exp)
 
-        result = p.dropna(axis=1, how='all')
-        assert_panel_equal(result, p)
+            result = p.dropna(axis=1, how='all')
+            assert_panel_equal(result, p)
 
-        p.loc[:, ['b', 'd'], :] = np.nan
-        result = p.dropna(axis=1, how='all')
-        exp = p.loc[:, ['a', 'c', 'e'], :]
-        assert_panel_equal(result, exp)
+            p.loc[:, ['b', 'd'], :] = np.nan
+            result = p.dropna(axis=1, how='all')
+            exp = p.loc[:, ['a', 'c', 'e'], :]
+            assert_panel_equal(result, exp)
 
-        p = Panel(np.random.randn(4, 5, 6), items=list('abcd'))
-        p.loc[['b'], :, 0] = np.nan
+            p = Panel(np.random.randn(4, 5, 6), items=list('abcd'))
+            p.loc[['b'], :, 0] = np.nan
 
-        result = p.dropna()
-        exp = p.loc[['a', 'c', 'd']]
-        assert_panel_equal(result, exp)
+            result = p.dropna()
+            exp = p.loc[['a', 'c', 'd']]
+            assert_panel_equal(result, exp)
 
-        result = p.dropna(how='all')
-        assert_panel_equal(result, p)
+            result = p.dropna(how='all')
+            assert_panel_equal(result, p)
 
-        p.loc['b'] = np.nan
-        result = p.dropna(how='all')
-        exp = p.loc[['a', 'c', 'd']]
-        assert_panel_equal(result, exp)
+            p.loc['b'] = np.nan
+            result = p.dropna(how='all')
+            exp = p.loc[['a', 'c', 'd']]
+            assert_panel_equal(result, exp)
 
     def test_drop(self):
-        df = DataFrame({"A": [1, 2], "B": [3, 4]})
-        panel = Panel({"One": df, "Two": df})
+        with catch_warnings(record=True):
+            df = DataFrame({"A": [1, 2], "B": [3, 4]})
+            panel = Panel({"One": df, "Two": df})
 
-        def check_drop(drop_val, axis_number, aliases, expected):
-            try:
-                actual = panel.drop(drop_val, axis=axis_number)
-                assert_panel_equal(actual, expected)
-                for alias in aliases:
-                    actual = panel.drop(drop_val, axis=alias)
+            def check_drop(drop_val, axis_number, aliases, expected):
+                try:
+                    actual = panel.drop(drop_val, axis=axis_number)
                     assert_panel_equal(actual, expected)
-            except AssertionError:
-                pprint_thing("Failed with axis_number %d and aliases: %s" %
-                             (axis_number, aliases))
-                raise
-        # Items
-        expected = Panel({"One": df})
-        check_drop('Two', 0, ['items'], expected)
-
-        self.assertRaises(ValueError, panel.drop, 'Three')
-
-        # errors = 'ignore'
-        dropped = panel.drop('Three', errors='ignore')
-        assert_panel_equal(dropped, panel)
-        dropped = panel.drop(['Two', 'Three'], errors='ignore')
-        expected = Panel({"One": df})
-        assert_panel_equal(dropped, expected)
-
-        # Major
-        exp_df = DataFrame({"A": [2], "B": [4]}, index=[1])
-        expected = Panel({"One": exp_df, "Two": exp_df})
-        check_drop(0, 1, ['major_axis', 'major'], expected)
-
-        exp_df = DataFrame({"A": [1], "B": [3]}, index=[0])
-        expected = Panel({"One": exp_df, "Two": exp_df})
-        check_drop([1], 1, ['major_axis', 'major'], expected)
-
-        # Minor
-        exp_df = df[['B']]
-        expected = Panel({"One": exp_df, "Two": exp_df})
-        check_drop(["A"], 2, ['minor_axis', 'minor'], expected)
-
-        exp_df = df[['A']]
-        expected = Panel({"One": exp_df, "Two": exp_df})
-        check_drop("B", 2, ['minor_axis', 'minor'], expected)
+                    for alias in aliases:
+                        actual = panel.drop(drop_val, axis=alias)
+                        assert_panel_equal(actual, expected)
+                except AssertionError:
+                    pprint_thing("Failed with axis_number %d and aliases: %s" %
+                                 (axis_number, aliases))
+                    raise
+            # Items
+            expected = Panel({"One": df})
+            check_drop('Two', 0, ['items'], expected)
+
+            self.assertRaises(ValueError, panel.drop, 'Three')
+
+            # errors = 'ignore'
+            dropped = panel.drop('Three', errors='ignore')
+            assert_panel_equal(dropped, panel)
+            dropped = panel.drop(['Two', 'Three'], errors='ignore')
+            expected = Panel({"One": df})
+            assert_panel_equal(dropped, expected)
+
+            # Major
+            exp_df = DataFrame({"A": [2], "B": [4]}, index=[1])
+            expected = Panel({"One": exp_df, "Two": exp_df})
+            check_drop(0, 1, ['major_axis', 'major'], expected)
+
+            exp_df = DataFrame({"A": [1], "B": [3]}, index=[0])
+            expected = Panel({"One": exp_df, "Two": exp_df})
+            check_drop([1], 1, ['major_axis', 'major'], expected)
+
+            # Minor
+            exp_df = df[['B']]
+            expected = Panel({"One": exp_df, "Two": exp_df})
+            check_drop(["A"], 2, ['minor_axis', 'minor'], expected)
+
+            exp_df = df[['A']]
+            expected = Panel({"One": exp_df, "Two": exp_df})
+            check_drop("B", 2, ['minor_axis', 'minor'], expected)
 
     def test_update(self):
-        pan = Panel([[[1.5, np.nan, 3.], [1.5, np.nan, 3.], [1.5, np.nan, 3.],
-                      [1.5, np.nan, 3.]],
-                     [[1.5, np.nan, 3.], [1.5, np.nan, 3.], [1.5, np.nan, 3.],
-                      [1.5, np.nan, 3.]]])
+        with catch_warnings(record=True):
+            pan = Panel([[[1.5, np.nan, 3.], [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.]],
+                         [[1.5, np.nan, 3.], [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.]]])
 
-        other = Panel([[[3.6, 2., np.nan], [np.nan, np.nan, 7]]], items=[1])
+            other = Panel(
+                [[[3.6, 2., np.nan], [np.nan, np.nan, 7]]], items=[1])
 
-        pan.update(other)
+            pan.update(other)
 
-        expected = Panel([[[1.5, np.nan, 3.], [1.5, np.nan, 3.],
-                           [1.5, np.nan, 3.], [1.5, np.nan, 3.]],
-                          [[3.6, 2., 3], [1.5, np.nan, 7], [1.5, np.nan, 3.],
-                           [1.5, np.nan, 3.]]])
+            expected = Panel([[[1.5, np.nan, 3.], [1.5, np.nan, 3.],
+                               [1.5, np.nan, 3.], [1.5, np.nan, 3.]],
+                              [[3.6, 2., 3], [1.5, np.nan, 7],
+                               [1.5, np.nan, 3.],
+                               [1.5, np.nan, 3.]]])
 
-        assert_panel_equal(pan, expected)
+            assert_panel_equal(pan, expected)
 
     def test_update_from_dict(self):
-        pan = Panel({'one': DataFrame([[1.5, np.nan, 3], [1.5, np.nan, 3],
-                                       [1.5, np.nan, 3.], [1.5, np.nan, 3.]]),
-                     'two': DataFrame([[1.5, np.nan, 3.], [1.5, np.nan, 3.],
-                                       [1.5, np.nan, 3.], [1.5, np.nan, 3.]])})
-
-        other = {'two': DataFrame([[3.6, 2., np.nan], [np.nan, np.nan, 7]])}
-
-        pan.update(other)
-
-        expected = Panel(
-            {'two': DataFrame([[3.6, 2., 3], [1.5, np.nan, 7],
-                               [1.5, np.nan, 3.], [1.5, np.nan, 3.]]),
-             'one': DataFrame([[1.5, np.nan, 3.], [1.5, np.nan, 3.],
-                               [1.5, np.nan, 3.], [1.5, np.nan, 3.]])})
-
-        assert_panel_equal(pan, expected)
+        with catch_warnings(record=True):
+            pan = Panel({'one': DataFrame([[1.5, np.nan, 3],
+                                           [1.5, np.nan, 3],
+                                           [1.5, np.nan, 3.],
+                                           [1.5, np.nan, 3.]]),
+                         'two': DataFrame([[1.5, np.nan, 3.],
+                                           [1.5, np.nan, 3.],
+                                           [1.5, np.nan, 3.],
+                                           [1.5, np.nan, 3.]])})
+
+            other = {'two': DataFrame(
+                [[3.6, 2., np.nan], [np.nan, np.nan, 7]])}
+
+            pan.update(other)
+
+            expected = Panel(
+                {'two': DataFrame([[3.6, 2., 3],
+                                   [1.5, np.nan, 7],
+                                   [1.5, np.nan, 3.],
+                                   [1.5, np.nan, 3.]]),
+                 'one': DataFrame([[1.5, np.nan, 3.],
+                                   [1.5, np.nan, 3.],
+                                   [1.5, np.nan, 3.],
+                                   [1.5, np.nan, 3.]])})
+
+            assert_panel_equal(pan, expected)
 
     def test_update_nooverwrite(self):
-        pan = Panel([[[1.5, np.nan, 3.], [1.5, np.nan, 3.], [1.5, np.nan, 3.],
-                      [1.5, np.nan, 3.]],
-                     [[1.5, np.nan, 3.], [1.5, np.nan, 3.], [1.5, np.nan, 3.],
-                      [1.5, np.nan, 3.]]])
+        with catch_warnings(record=True):
+            pan = Panel([[[1.5, np.nan, 3.], [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.]],
+                         [[1.5, np.nan, 3.], [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.]]])
 
-        other = Panel([[[3.6, 2., np.nan], [np.nan, np.nan, 7]]], items=[1])
+            other = Panel(
+                [[[3.6, 2., np.nan], [np.nan, np.nan, 7]]], items=[1])
 
-        pan.update(other, overwrite=False)
+            pan.update(other, overwrite=False)
 
-        expected = Panel([[[1.5, np.nan, 3], [1.5, np.nan, 3],
-                           [1.5, np.nan, 3.], [1.5, np.nan, 3.]],
-                          [[1.5, 2., 3.], [1.5, np.nan, 3.], [1.5, np.nan, 3.],
-                           [1.5, np.nan, 3.]]])
+            expected = Panel([[[1.5, np.nan, 3], [1.5, np.nan, 3],
+                               [1.5, np.nan, 3.], [1.5, np.nan, 3.]],
+                              [[1.5, 2., 3.], [1.5, np.nan, 3.],
+                               [1.5, np.nan, 3.],
+                               [1.5, np.nan, 3.]]])
 
-        assert_panel_equal(pan, expected)
+            assert_panel_equal(pan, expected)
 
     def test_update_filtered(self):
-        pan = Panel([[[1.5, np.nan, 3.], [1.5, np.nan, 3.], [1.5, np.nan, 3.],
-                      [1.5, np.nan, 3.]],
-                     [[1.5, np.nan, 3.], [1.5, np.nan, 3.], [1.5, np.nan, 3.],
-                      [1.5, np.nan, 3.]]])
+        with catch_warnings(record=True):
+            pan = Panel([[[1.5, np.nan, 3.], [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.]],
+                         [[1.5, np.nan, 3.], [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.]]])
 
-        other = Panel([[[3.6, 2., np.nan], [np.nan, np.nan, 7]]], items=[1])
+            other = Panel(
+                [[[3.6, 2., np.nan], [np.nan, np.nan, 7]]], items=[1])
 
-        pan.update(other, filter_func=lambda x: x > 2)
+            pan.update(other, filter_func=lambda x: x > 2)
 
-        expected = Panel([[[1.5, np.nan, 3.], [1.5, np.nan, 3.],
-                           [1.5, np.nan, 3.], [1.5, np.nan, 3.]],
-                          [[1.5, np.nan, 3], [1.5, np.nan, 7],
-                           [1.5, np.nan, 3.], [1.5, np.nan, 3.]]])
+            expected = Panel([[[1.5, np.nan, 3.], [1.5, np.nan, 3.],
+                               [1.5, np.nan, 3.], [1.5, np.nan, 3.]],
+                              [[1.5, np.nan, 3], [1.5, np.nan, 7],
+                               [1.5, np.nan, 3.], [1.5, np.nan, 3.]]])
 
-        assert_panel_equal(pan, expected)
+            assert_panel_equal(pan, expected)
 
     def test_update_raise(self):
-        pan = Panel([[[1.5, np.nan, 3.], [1.5, np.nan, 3.], [1.5, np.nan, 3.],
-                      [1.5, np.nan, 3.]],
-                     [[1.5, np.nan, 3.], [1.5, np.nan, 3.], [1.5, np.nan, 3.],
-                      [1.5, np.nan, 3.]]])
+        with catch_warnings(record=True):
+            pan = Panel([[[1.5, np.nan, 3.], [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.]],
+                         [[1.5, np.nan, 3.], [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.],
+                          [1.5, np.nan, 3.]]])
 
-        self.assertRaises(Exception, pan.update, *(pan, ),
-                          **{'raise_conflict': True})
+            self.assertRaises(Exception, pan.update, *(pan, ),
+                              **{'raise_conflict': True})
 
     def test_all_any(self):
         self.assertTrue((self.panel.all(axis=0).values == nanall(
@@ -2276,90 +2430,95 @@ class TestLongPanel(tm.TestCase):
     """
 
     def setUp(self):
-        import warnings
-        warnings.filterwarnings(action='ignore', category=FutureWarning)
-
-        panel = tm.makePanel()
-        tm.add_nans(panel)
-
+        panel = make_test_panel()
         self.panel = panel.to_frame()
         self.unfiltered_panel = panel.to_frame(filter_observations=False)
 
     def test_ops_differently_indexed(self):
-        # trying to set non-identically indexed panel
-        wp = self.panel.to_panel()
-        wp2 = wp.reindex(major=wp.major_axis[:-1])
-        lp2 = wp2.to_frame()
+        with catch_warnings(record=True):
+            # trying to set non-identically indexed panel
+            wp = self.panel.to_panel()
+            wp2 = wp.reindex(major=wp.major_axis[:-1])
+            lp2 = wp2.to_frame()
 
-        result = self.panel + lp2
-        assert_frame_equal(result.reindex(lp2.index), lp2 * 2)
+            result = self.panel + lp2
+            assert_frame_equal(result.reindex(lp2.index), lp2 * 2)
 
-        # careful, mutation
-        self.panel['foo'] = lp2['ItemA']
-        assert_series_equal(self.panel['foo'].reindex(lp2.index), lp2['ItemA'],
-                            check_names=False)
+            # careful, mutation
+            self.panel['foo'] = lp2['ItemA']
+            assert_series_equal(self.panel['foo'].reindex(lp2.index),
+                                lp2['ItemA'],
+                                check_names=False)
 
     def test_ops_scalar(self):
-        result = self.panel.mul(2)
-        expected = DataFrame.__mul__(self.panel, 2)
-        assert_frame_equal(result, expected)
+        with catch_warnings(record=True):
+            result = self.panel.mul(2)
+            expected = DataFrame.__mul__(self.panel, 2)
+            assert_frame_equal(result, expected)
 
     def test_combineFrame(self):
-        wp = self.panel.to_panel()
-        result = self.panel.add(wp['ItemA'].stack(), axis=0)
-        assert_frame_equal(result.to_panel()['ItemA'], wp['ItemA'] * 2)
+        with catch_warnings(record=True):
+            wp = self.panel.to_panel()
+            result = self.panel.add(wp['ItemA'].stack(), axis=0)
+            assert_frame_equal(result.to_panel()['ItemA'], wp['ItemA'] * 2)
 
     def test_combinePanel(self):
-        wp = self.panel.to_panel()
-        result = self.panel.add(self.panel)
-        wide_result = result.to_panel()
-        assert_frame_equal(wp['ItemA'] * 2, wide_result['ItemA'])
+        with catch_warnings(record=True):
+            wp = self.panel.to_panel()
+            result = self.panel.add(self.panel)
+            wide_result = result.to_panel()
+            assert_frame_equal(wp['ItemA'] * 2, wide_result['ItemA'])
 
-        # one item
-        result = self.panel.add(self.panel.filter(['ItemA']))
+            # one item
+            result = self.panel.add(self.panel.filter(['ItemA']))
 
     def test_combine_scalar(self):
-        result = self.panel.mul(2)
-        expected = DataFrame(self.panel._data) * 2
-        assert_frame_equal(result, expected)
+        with catch_warnings(record=True):
+            result = self.panel.mul(2)
+            expected = DataFrame(self.panel._data) * 2
+            assert_frame_equal(result, expected)
 
     def test_combine_series(self):
-        s = self.panel['ItemA'][:10]
-        result = self.panel.add(s, axis=0)
-        expected = DataFrame.add(self.panel, s, axis=0)
-        assert_frame_equal(result, expected)
+        with catch_warnings(record=True):
+            s = self.panel['ItemA'][:10]
+            result = self.panel.add(s, axis=0)
+            expected = DataFrame.add(self.panel, s, axis=0)
+            assert_frame_equal(result, expected)
 
-        s = self.panel.iloc[5]
-        result = self.panel + s
-        expected = DataFrame.add(self.panel, s, axis=1)
-        assert_frame_equal(result, expected)
+            s = self.panel.iloc[5]
+            result = self.panel + s
+            expected = DataFrame.add(self.panel, s, axis=1)
+            assert_frame_equal(result, expected)
 
     def test_operators(self):
-        wp = self.panel.to_panel()
-        result = (self.panel + 1).to_panel()
-        assert_frame_equal(wp['ItemA'] + 1, result['ItemA'])
+        with catch_warnings(record=True):
+            wp = self.panel.to_panel()
+            result = (self.panel + 1).to_panel()
+            assert_frame_equal(wp['ItemA'] + 1, result['ItemA'])
 
     def test_arith_flex_panel(self):
-        ops = ['add', 'sub', 'mul', 'div', 'truediv', 'pow', 'floordiv', 'mod']
-        if not compat.PY3:
-            aliases = {}
-        else:
-            aliases = {'div': 'truediv'}
-        self.panel = self.panel.to_panel()
-
-        for n in [np.random.randint(-50, -1), np.random.randint(1, 50), 0]:
-            for op in ops:
-                alias = aliases.get(op, op)
-                f = getattr(operator, alias)
-                exp = f(self.panel, n)
-                result = getattr(self.panel, op)(n)
-                assert_panel_equal(result, exp, check_panel_type=True)
-
-                # rops
-                r_f = lambda x, y: f(y, x)
-                exp = r_f(self.panel, n)
-                result = getattr(self.panel, 'r' + op)(n)
-                assert_panel_equal(result, exp)
+        with catch_warnings(record=True):
+            ops = ['add', 'sub', 'mul', 'div',
+                   'truediv', 'pow', 'floordiv', 'mod']
+            if not compat.PY3:
+                aliases = {}
+            else:
+                aliases = {'div': 'truediv'}
+            self.panel = self.panel.to_panel()
+
+            for n in [np.random.randint(-50, -1), np.random.randint(1, 50), 0]:
+                for op in ops:
+                    alias = aliases.get(op, op)
+                    f = getattr(operator, alias)
+                    exp = f(self.panel, n)
+                    result = getattr(self.panel, op)(n)
+                    assert_panel_equal(result, exp, check_panel_type=True)
+
+                    # rops
+                    r_f = lambda x, y: f(y, x)
+                    exp = r_f(self.panel, n)
+                    result = getattr(self.panel, 'r' + op)(n)
+                    assert_panel_equal(result, exp)
 
     def test_sort(self):
         def is_sorted(arr):
@@ -2382,43 +2541,44 @@ class TestLongPanel(tm.TestCase):
                                   self.panel.to_sparse)
 
     def test_truncate(self):
-        dates = self.panel.index.levels[0]
-        start, end = dates[1], dates[5]
+        with catch_warnings(record=True):
+            dates = self.panel.index.levels[0]
+            start, end = dates[1], dates[5]
 
-        trunced = self.panel.truncate(start, end).to_panel()
-        expected = self.panel.to_panel()['ItemA'].truncate(start, end)
+            trunced = self.panel.truncate(start, end).to_panel()
+            expected = self.panel.to_panel()['ItemA'].truncate(start, end)
 
-        # TODO trucate drops index.names
-        assert_frame_equal(trunced['ItemA'], expected, check_names=False)
+            # TODO trucate drops index.names
+            assert_frame_equal(trunced['ItemA'], expected, check_names=False)
 
-        trunced = self.panel.truncate(before=start).to_panel()
-        expected = self.panel.to_panel()['ItemA'].truncate(before=start)
+            trunced = self.panel.truncate(before=start).to_panel()
+            expected = self.panel.to_panel()['ItemA'].truncate(before=start)
 
-        # TODO trucate drops index.names
-        assert_frame_equal(trunced['ItemA'], expected, check_names=False)
+            # TODO trucate drops index.names
+            assert_frame_equal(trunced['ItemA'], expected, check_names=False)
 
-        trunced = self.panel.truncate(after=end).to_panel()
-        expected = self.panel.to_panel()['ItemA'].truncate(after=end)
+            trunced = self.panel.truncate(after=end).to_panel()
+            expected = self.panel.to_panel()['ItemA'].truncate(after=end)
 
-        # TODO trucate drops index.names
-        assert_frame_equal(trunced['ItemA'], expected, check_names=False)
+            # TODO trucate drops index.names
+            assert_frame_equal(trunced['ItemA'], expected, check_names=False)
 
-        # truncate on dates that aren't in there
-        wp = self.panel.to_panel()
-        new_index = wp.major_axis[::5]
+            # truncate on dates that aren't in there
+            wp = self.panel.to_panel()
+            new_index = wp.major_axis[::5]
 
-        wp2 = wp.reindex(major=new_index)
+            wp2 = wp.reindex(major=new_index)
 
-        lp2 = wp2.to_frame()
-        lp_trunc = lp2.truncate(wp.major_axis[2], wp.major_axis[-2])
+            lp2 = wp2.to_frame()
+            lp_trunc = lp2.truncate(wp.major_axis[2], wp.major_axis[-2])
 
-        wp_trunc = wp2.truncate(wp.major_axis[2], wp.major_axis[-2])
+            wp_trunc = wp2.truncate(wp.major_axis[2], wp.major_axis[-2])
 
-        assert_panel_equal(wp_trunc, lp_trunc.to_panel())
+            assert_panel_equal(wp_trunc, lp_trunc.to_panel())
 
-        # throw proper exception
-        self.assertRaises(Exception, lp2.truncate, wp.major_axis[-2],
-                          wp.major_axis[2])
+            # throw proper exception
+            self.assertRaises(Exception, lp2.truncate, wp.major_axis[-2],
+                              wp.major_axis[2])
 
     def test_axis_dummies(self):
         from pandas.core.reshape import make_axis_dummies
@@ -2449,82 +2609,70 @@ class TestLongPanel(tm.TestCase):
         self.assert_numpy_array_equal(dummies.values, minor_dummies.values)
 
     def test_mean(self):
-        means = self.panel.mean(level='minor')
+        with catch_warnings(record=True):
+            means = self.panel.mean(level='minor')
 
-        # test versus Panel version
-        wide_means = self.panel.to_panel().mean('major')
-        assert_frame_equal(means, wide_means)
+            # test versus Panel version
+            wide_means = self.panel.to_panel().mean('major')
+            assert_frame_equal(means, wide_means)
 
     def test_sum(self):
-        sums = self.panel.sum(level='minor')
+        with catch_warnings(record=True):
+            sums = self.panel.sum(level='minor')
 
-        # test versus Panel version
-        wide_sums = self.panel.to_panel().sum('major')
-        assert_frame_equal(sums, wide_sums)
+            # test versus Panel version
+            wide_sums = self.panel.to_panel().sum('major')
+            assert_frame_equal(sums, wide_sums)
 
     def test_count(self):
-        index = self.panel.index
+        with catch_warnings(record=True):
+            index = self.panel.index
 
-        major_count = self.panel.count(level=0)['ItemA']
-        labels = index.labels[0]
-        for i, idx in enumerate(index.levels[0]):
-            self.assertEqual(major_count[i], (labels == i).sum())
+            major_count = self.panel.count(level=0)['ItemA']
+            labels = index.labels[0]
+            for i, idx in enumerate(index.levels[0]):
+                self.assertEqual(major_count[i], (labels == i).sum())
 
-        minor_count = self.panel.count(level=1)['ItemA']
-        labels = index.labels[1]
-        for i, idx in enumerate(index.levels[1]):
-            self.assertEqual(minor_count[i], (labels == i).sum())
+            minor_count = self.panel.count(level=1)['ItemA']
+            labels = index.labels[1]
+            for i, idx in enumerate(index.levels[1]):
+                self.assertEqual(minor_count[i], (labels == i).sum())
 
     def test_join(self):
-        lp1 = self.panel.filter(['ItemA', 'ItemB'])
-        lp2 = self.panel.filter(['ItemC'])
+        with catch_warnings(record=True):
+            lp1 = self.panel.filter(['ItemA', 'ItemB'])
+            lp2 = self.panel.filter(['ItemC'])
 
-        joined = lp1.join(lp2)
+            joined = lp1.join(lp2)
 
-        self.assertEqual(len(joined.columns), 3)
+            self.assertEqual(len(joined.columns), 3)
 
-        self.assertRaises(Exception, lp1.join,
-                          self.panel.filter(['ItemB', 'ItemC']))
+            self.assertRaises(Exception, lp1.join,
+                              self.panel.filter(['ItemB', 'ItemC']))
 
     def test_pivot(self):
-        from pandas.core.reshape import _slow_pivot
-
-        one, two, three = (np.array([1, 2, 3, 4, 5]),
-                           np.array(['a', 'b', 'c', 'd', 'e']),
-                           np.array([1, 2, 3, 5, 4.]))
-        df = pivot(one, two, three)
-        self.assertEqual(df['a'][1], 1)
-        self.assertEqual(df['b'][2], 2)
-        self.assertEqual(df['c'][3], 3)
-        self.assertEqual(df['d'][4], 5)
-        self.assertEqual(df['e'][5], 4)
-        assert_frame_equal(df, _slow_pivot(one, two, three))
-
-        # weird overlap, TODO: test?
-        a, b, c = (np.array([1, 2, 3, 4, 4]),
-                   np.array(['a', 'a', 'a', 'a', 'a']),
-                   np.array([1., 2., 3., 4., 5.]))
-        self.assertRaises(Exception, pivot, a, b, c)
-
-        # corner case, empty
-        df = pivot(np.array([]), np.array([]), np.array([]))
-
-
-def test_monotonic():
-    pos = np.array([1, 2, 3, 5])
-
-    def _monotonic(arr):
-        return not (arr[1:] < arr[:-1]).any()
-
-    assert _monotonic(pos)
-
-    neg = np.array([1, 2, 3, 4, 3])
-
-    assert not _monotonic(neg)
-
-    neg2 = np.array([5, 1, 2, 3, 4, 5])
-
-    assert not _monotonic(neg2)
+        with catch_warnings(record=True):
+            from pandas.core.reshape import _slow_pivot
+
+            one, two, three = (np.array([1, 2, 3, 4, 5]),
+                               np.array(['a', 'b', 'c', 'd', 'e']),
+                               np.array([1, 2, 3, 5, 4.]))
+            df = pivot(one, two, three)
+            self.assertEqual(df['a'][1], 1)
+            self.assertEqual(df['b'][2], 2)
+            self.assertEqual(df['c'][3], 3)
+            self.assertEqual(df['d'][4], 5)
+            self.assertEqual(df['e'][5], 4)
+            assert_frame_equal(df, _slow_pivot(one, two, three))
+
+            # weird overlap, TODO: test?
+            a, b, c = (np.array([1, 2, 3, 4, 4]),
+                       np.array(['a', 'a', 'a', 'a', 'a']),
+                       np.array([1., 2., 3., 4., 5.]))
+            self.assertRaises(Exception, pivot, a, b, c)
+
+            # corner case, empty
+            df = pivot(np.array([]), np.array([]), np.array([]))
 
 
 def test_panel_index():
diff --git a/pandas/tests/test_window.py b/pandas/tests/test_window.py
index ceb12c6c0..5fc31e932 100644
--- a/pandas/tests/test_window.py
+++ b/pandas/tests/test_window.py
@@ -10,8 +10,8 @@ import numpy as np
 from distutils.version import LooseVersion
 
 import pandas as pd
-from pandas import (Series, DataFrame, Panel, bdate_range, isnull,
-                    notnull, concat, Timestamp)
+from pandas import (Series, DataFrame, bdate_range, isnull,
+                    notnull, concat, Timestamp, Index)
 import pandas.stats.moments as mom
 import pandas.core.window as rwindow
 import pandas.tseries.offsets as offsets
@@ -172,7 +172,7 @@ class TestApi(Base):
         tm.assert_index_equal(result, expected)
 
         result = r['A'].agg([np.sum, np.mean]).columns
-        expected = pd.Index(['sum', 'mean'])
+        expected = Index(['sum', 'mean'])
         tm.assert_index_equal(result, expected)
 
         result = r.agg({'A': [np.sum, np.mean]}).columns
@@ -1688,6 +1688,160 @@ class TestMoments(Base):
         self.assertEqual(type(frame_result), DataFrame)
 
 
+class TestPairwise(object):
+
+    # GH 7738
+    df1s = [DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[0, 1]),
+            DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[1, 0]),
+            DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[1, 1]),
+            DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]],
+                      columns=['C', 'C']),
+            DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[1., 0]),
+            DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[0., 1]),
+            DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=['C', 1]),
+            DataFrame([[2., 4.], [1., 2.], [5., 2.], [8., 1.]],
+                      columns=[1, 0.]),
+            DataFrame([[2, 4.], [1, 2.], [5, 2.], [8, 1.]],
+                      columns=[0, 1.]),
+            DataFrame([[2, 4], [1, 2], [5, 2], [8, 1.]],
+                      columns=[1., 'X']), ]
+    df2 = DataFrame([[None, 1, 1], [None, 1, 2],
+                     [None, 3, 2], [None, 8, 1]], columns=['Y', 'Z', 'X'])
+    s = Series([1, 1, 3, 8])
+
+    def compare(self, result, expected):
+
+        # since we have sorted the results
+        # we can only compare non-nans
+        result = result.dropna().values
+        expected = expected.dropna().values
+
+        tm.assert_numpy_array_equal(result, expected)
+
+    @pytest.mark.parametrize('f', [lambda x: x.cov(), lambda x: x.corr()])
+    def test_no_flex(self, f):
+
+        # DataFrame methods (which do not call _flex_binary_moment())
+
+        results = [f(df) for df in self.df1s]
+        for (df, result) in zip(self.df1s, results):
+            tm.assert_index_equal(result.index, df.columns)
+            tm.assert_index_equal(result.columns, df.columns)
+        for i, result in enumerate(results):
+            if i > 0:
+                self.compare(result, results[0])
+
+    @pytest.mark.parametrize(
+        'f', [lambda x: x.expanding().cov(pairwise=True),
+              lambda x: x.expanding().corr(pairwise=True),
+              lambda x: x.rolling(window=3).cov(pairwise=True),
+              lambda x: x.rolling(window=3).corr(pairwise=True),
+              lambda x: x.ewm(com=3).cov(pairwise=True),
+              lambda x: x.ewm(com=3).corr(pairwise=True)])
+    def test_pairwise_with_self(self, f):
+
+        # DataFrame with itself, pairwise=True
+        results = [f(df) for df in self.df1s]
+        for (df, result) in zip(self.df1s, results):
+            tm.assert_index_equal(result.index.levels[0],
+                                  df.index,
+                                  check_names=False)
+            tm.assert_index_equal(result.index.levels[1],
+                                  df.columns,
+                                  check_names=False)
+            tm.assert_index_equal(result.columns, df.columns)
+        for i, result in enumerate(results):
+            if i > 0:
+                self.compare(result, results[0])
+
+    @pytest.mark.parametrize(
+        'f', [lambda x: x.expanding().cov(pairwise=False),
+              lambda x: x.expanding().corr(pairwise=False),
+              lambda x: x.rolling(window=3).cov(pairwise=False),
+              lambda x: x.rolling(window=3).corr(pairwise=False),
+              lambda x: x.ewm(com=3).cov(pairwise=False),
+              lambda x: x.ewm(com=3).corr(pairwise=False), ])
+    def test_no_pairwise_with_self(self, f):
+
+        # DataFrame with itself, pairwise=False
+        results = [f(df) for df in self.df1s]
+        for (df, result) in zip(self.df1s, results):
+            tm.assert_index_equal(result.index, df.index)
+            tm.assert_index_equal(result.columns, df.columns)
+        for i, result in enumerate(results):
+            if i > 0:
+                self.compare(result, results[0])
+
+    @pytest.mark.parametrize(
+        'f', [lambda x, y: x.expanding().cov(y, pairwise=True),
+              lambda x, y: x.expanding().corr(y, pairwise=True),
+              lambda x, y: x.rolling(window=3).cov(y, pairwise=True),
+              lambda x, y: x.rolling(window=3).corr(y, pairwise=True),
+              lambda x, y: x.ewm(com=3).cov(y, pairwise=True),
+              lambda x, y: x.ewm(com=3).corr(y, pairwise=True), ])
+    def test_pairwise_with_other(self, f):
+
+        # DataFrame with another DataFrame, pairwise=True
+        results = [f(df, self.df2) for df in self.df1s]
+        for (df, result) in zip(self.df1s, results):
+            tm.assert_index_equal(result.index.levels[0],
+                                  df.index,
+                                  check_names=False)
+            tm.assert_index_equal(result.index.levels[1],
+                                  self.df2.columns,
+                                  check_names=False)
+        for i, result in enumerate(results):
+            if i > 0:
+                self.compare(result, results[0])
+
+    @pytest.mark.parametrize(
+        'f', [lambda x, y: x.expanding().cov(y, pairwise=False),
+              lambda x, y: x.expanding().corr(y, pairwise=False),
+              lambda x, y: x.rolling(window=3).cov(y, pairwise=False),
+              lambda x, y: x.rolling(window=3).corr(y, pairwise=False),
+              lambda x, y: x.ewm(com=3).cov(y, pairwise=False),
+              lambda x, y: x.ewm(com=3).corr(y, pairwise=False), ])
+    def test_no_pairwise_with_other(self, f):
+
+        # DataFrame with another DataFrame, pairwise=False
+        results = [f(df, self.df2) if df.columns.is_unique else None
+                   for df in self.df1s]
+        for (df, result) in zip(self.df1s, results):
+            if result is not None:
+                with catch_warnings(record=True):
+                    # we can have int and str columns
+                    expected_index = df.index.union(self.df2.index)
+                    expected_columns = df.columns.union(self.df2.columns)
+                tm.assert_index_equal(result.index, expected_index)
+                tm.assert_index_equal(result.columns, expected_columns)
+            else:
+                tm.assertRaisesRegexp(
+                    ValueError, "'arg1' columns are not unique", f, df,
+                    self.df2)
+                tm.assertRaisesRegexp(
+                    ValueError, "'arg2' columns are not unique", f,
+                    self.df2, df)
+
+    @pytest.mark.parametrize(
+        'f', [lambda x, y: x.expanding().cov(y),
+              lambda x, y: x.expanding().corr(y),
+              lambda x, y: x.rolling(window=3).cov(y),
+              lambda x, y: x.rolling(window=3).corr(y),
+              lambda x, y: x.ewm(com=3).cov(y),
+              lambda x, y: x.ewm(com=3).corr(y), ])
+    def test_pairwise_with_series(self, f):
+
+        # DataFrame with a Series
+        results = ([f(df, self.s) for df in self.df1s] +
+                   [f(self.s, df) for df in self.df1s])
+        for (df, result) in zip(self.df1s, results):
+            tm.assert_index_equal(result.index, df.index)
+            tm.assert_index_equal(result.columns, df.columns)
+        for i, result in enumerate(results):
+            if i > 0:
+                self.compare(result, results[0])
+
+
 # create the data only once as we are not setting it
 def _create_consistency_data():
     def create_series():
@@ -2083,21 +2237,6 @@ class TestMomentsConsistency(Base):
                             assert_equal(expanding_f_result,
                                          expanding_apply_f_result)
 
-                        if (name in ['cov', 'corr']) and isinstance(x,
-                                                                    DataFrame):
-                            # test pairwise=True
-                            expanding_f_result = expanding_f(x, pairwise=True)
-                            expected = Panel(items=x.index,
-                                             major_axis=x.columns,
-                                             minor_axis=x.columns)
-                            for i, _ in enumerate(x.columns):
-                                for j, _ in enumerate(x.columns):
-                                    expected.iloc[:, i, j] = getattr(
-                                        x.iloc[:, i].expanding(
-                                            min_periods=min_periods),
-                                        name)(x.iloc[:, j])
-                            tm.assert_panel_equal(expanding_f_result, expected)
-
     @tm.slow
     def test_rolling_consistency(self):
 
@@ -2203,25 +2342,6 @@ class TestMomentsConsistency(Base):
                             assert_equal(rolling_f_result,
                                          rolling_apply_f_result)
 
-                        if (name in ['cov', 'corr']) and isinstance(
-                                x, DataFrame):
-                            # test pairwise=True
-                            rolling_f_result = rolling_f(x,
-                                                         pairwise=True)
-                            expected = Panel(items=x.index,
-                                             major_axis=x.columns,
-                                             minor_axis=x.columns)
-                            for i, _ in enumerate(x.columns):
-                                for j, _ in enumerate(x.columns):
-                                    expected.iloc[:, i, j] = (
-                                        getattr(
-                                            x.iloc[:, i]
-                                            .rolling(window=window,
-                                                     min_periods=min_periods,
-                                                     center=center),
-                                            name)(x.iloc[:, j]))
-                            tm.assert_panel_equal(rolling_f_result, expected)
-
     # binary moments
     def test_rolling_cov(self):
         A = self.series
@@ -2257,11 +2377,11 @@ class TestMomentsConsistency(Base):
         def get_result(obj, obj2=None):
             return getattr(getattr(obj, dispatch)(**kwargs), name)(obj2)
 
-        panel = get_result(self.frame)
-        actual = panel.loc[:, 1, 5]
+        result = get_result(self.frame)
+        result = result.loc[(slice(None), 1), 5]
+        result.index = result.index.droplevel(1)
         expected = get_result(self.frame[1], self.frame[5])
-        tm.assert_series_equal(actual, expected, check_names=False)
-        self.assertEqual(actual.name, 5)
+        tm.assert_series_equal(result, expected, check_names=False)
 
     def test_flex_binary_moment(self):
         # GH3155
@@ -2429,17 +2549,14 @@ class TestMomentsConsistency(Base):
         rolling_result = self.frame.rolling(window=len(self.frame),
                                             min_periods=1).corr()
 
-        for i in result.items:
-            tm.assert_almost_equal(result[i], rolling_result[i])
+        tm.assert_frame_equal(result, rolling_result)
 
     def test_expanding_corr_pairwise(self):
         result = self.frame.expanding().corr()
 
         rolling_result = self.frame.rolling(window=len(self.frame),
                                             min_periods=1).corr()
-
-        for i in result.items:
-            tm.assert_almost_equal(result[i], rolling_result[i])
+        tm.assert_frame_equal(result, rolling_result)
 
     def test_expanding_cov_diff_index(self):
         # GH 7512
@@ -2507,8 +2624,6 @@ class TestMomentsConsistency(Base):
         s_expected = Series(np.nan, index=s.index)
         df = DataFrame([[1, 5], [3, 2], [3, 9], [-1, 0]], columns=['A', 'B'])
         df_expected = DataFrame(np.nan, index=df.index, columns=df.columns)
-        df_expected_panel = Panel(items=df.index, major_axis=df.columns,
-                                  minor_axis=df.columns)
 
         functions = [lambda x: (x.rolling(window=10, min_periods=5)
                                 .cov(x, pairwise=False)),
@@ -2540,13 +2655,24 @@ class TestMomentsConsistency(Base):
                 # scipy needed for rolling_window
                 continue
 
+    def test_rolling_functions_window_non_shrinkage_binary(self):
+
+        # corr/cov return a MI DataFrame
+        df = DataFrame([[1, 5], [3, 2], [3, 9], [-1, 0]],
+                       columns=Index(['A', 'B'], name='foo'),
+                       index=Index(range(4), name='bar'))
+        df_expected = DataFrame(
+            columns=Index(['A', 'B'], name='foo'),
+            index=pd.MultiIndex.from_product([df.index, df.columns],
+                                             names=['bar', 'foo']),
+            dtype='float64')
         functions = [lambda x: (x.rolling(window=10, min_periods=5)
                                 .cov(x, pairwise=True)),
                      lambda x: (x.rolling(window=10, min_periods=5)
                                 .corr(x, pairwise=True))]
         for f in functions:
-            df_result_panel = f(df)
-            tm.assert_panel_equal(df_result_panel, df_expected_panel)
+            df_result = f(df)
+            tm.assert_frame_equal(df_result, df_expected)
 
     def test_moment_functions_zero_length(self):
         # GH 8056
@@ -2554,13 +2680,9 @@ class TestMomentsConsistency(Base):
         s_expected = s
         df1 = DataFrame()
         df1_expected = df1
-        df1_expected_panel = Panel(items=df1.index, major_axis=df1.columns,
-                                   minor_axis=df1.columns)
         df2 = DataFrame(columns=['a'])
         df2['a'] = df2['a'].astype('float64')
         df2_expected = df2
-        df2_expected_panel = Panel(items=df2.index, major_axis=df2.columns,
-                                   minor_axis=df2.columns)
 
         functions = [lambda x: x.expanding().count(),
                      lambda x: x.expanding(min_periods=5).cov(
@@ -2613,6 +2735,23 @@ class TestMomentsConsistency(Base):
                 # scipy needed for rolling_window
                 continue
 
+    def test_moment_functions_zero_length_pairwise(self):
+
+        df1 = DataFrame()
+        df1_expected = df1
+        df2 = DataFrame(columns=Index(['a'], name='foo'),
+                        index=Index([], name='bar'))
+        df2['a'] = df2['a'].astype('float64')
+
+        df1_expected = DataFrame(
+            index=pd.MultiIndex.from_product([df1.index, df1.columns]),
+            columns=Index([]))
+        df2_expected = DataFrame(
+            index=pd.MultiIndex.from_product([df2.index, df2.columns],
+                                             names=['bar', 'foo']),
+            columns=Index(['a'], name='foo'),
+            dtype='float64')
+
         functions = [lambda x: (x.expanding(min_periods=5)
                                 .cov(x, pairwise=True)),
                      lambda x: (x.expanding(min_periods=5)
@@ -2623,24 +2762,33 @@ class TestMomentsConsistency(Base):
                                 .corr(x, pairwise=True)),
                      ]
         for f in functions:
-            df1_result_panel = f(df1)
-            tm.assert_panel_equal(df1_result_panel, df1_expected_panel)
+            df1_result = f(df1)
+            tm.assert_frame_equal(df1_result, df1_expected)
 
-            df2_result_panel = f(df2)
-            tm.assert_panel_equal(df2_result_panel, df2_expected_panel)
+            df2_result = f(df2)
+            tm.assert_frame_equal(df2_result, df2_expected)
 
     def test_expanding_cov_pairwise_diff_length(self):
         # GH 7512
-        df1 = DataFrame([[1, 5], [3, 2], [3, 9]], columns=['A', 'B'])
-        df1a = DataFrame([[1, 5], [3, 9]], index=[0, 2], columns=['A', 'B'])
-        df2 = DataFrame([[5, 6], [None, None], [2, 1]], columns=['X', 'Y'])
-        df2a = DataFrame([[5, 6], [2, 1]], index=[0, 2], columns=['X', 'Y'])
-        result1 = df1.expanding().cov(df2a, pairwise=True)[2]
-        result2 = df1.expanding().cov(df2a, pairwise=True)[2]
-        result3 = df1a.expanding().cov(df2, pairwise=True)[2]
-        result4 = df1a.expanding().cov(df2a, pairwise=True)[2]
-        expected = DataFrame([[-3., -5.], [-6., -10.]], index=['A', 'B'],
-                             columns=['X', 'Y'])
+        df1 = DataFrame([[1, 5], [3, 2], [3, 9]],
+                        columns=Index(['A', 'B'], name='foo'))
+        df1a = DataFrame([[1, 5], [3, 9]],
+                         index=[0, 2],
+                         columns=Index(['A', 'B'], name='foo'))
+        df2 = DataFrame([[5, 6], [None, None], [2, 1]],
+                        columns=Index(['X', 'Y'], name='foo'))
+        df2a = DataFrame([[5, 6], [2, 1]],
+                         index=[0, 2],
+                         columns=Index(['X', 'Y'], name='foo'))
+        # TODO: xref gh-15826
+        # .loc is not preserving the names
+        result1 = df1.expanding().cov(df2a, pairwise=True).loc[2]
+        result2 = df1.expanding().cov(df2a, pairwise=True).loc[2]
+        result3 = df1a.expanding().cov(df2, pairwise=True).loc[2]
+        result4 = df1a.expanding().cov(df2a, pairwise=True).loc[2]
+        expected = DataFrame([[-3.0, -6.0], [-5.0, -10.0]],
+                             columns=Index(['A', 'B'], name='foo'),
+                             index=Index(['X', 'Y'], name='foo'))
         tm.assert_frame_equal(result1, expected)
         tm.assert_frame_equal(result2, expected)
         tm.assert_frame_equal(result3, expected)
@@ -2648,149 +2796,30 @@ class TestMomentsConsistency(Base):
 
     def test_expanding_corr_pairwise_diff_length(self):
         # GH 7512
-        df1 = DataFrame([[1, 2], [3, 2], [3, 4]], columns=['A', 'B'])
-        df1a = DataFrame([[1, 2], [3, 4]], index=[0, 2], columns=['A', 'B'])
-        df2 = DataFrame([[5, 6], [None, None], [2, 1]], columns=['X', 'Y'])
-        df2a = DataFrame([[5, 6], [2, 1]], index=[0, 2], columns=['X', 'Y'])
-        result1 = df1.expanding().corr(df2, pairwise=True)[2]
-        result2 = df1.expanding().corr(df2a, pairwise=True)[2]
-        result3 = df1a.expanding().corr(df2, pairwise=True)[2]
-        result4 = df1a.expanding().corr(df2a, pairwise=True)[2]
-        expected = DataFrame([[-1.0, -1.0], [-1.0, -1.0]], index=['A', 'B'],
-                             columns=['X', 'Y'])
+        df1 = DataFrame([[1, 2], [3, 2], [3, 4]],
+                        columns=['A', 'B'],
+                        index=Index(range(3), name='bar'))
+        df1a = DataFrame([[1, 2], [3, 4]],
+                         index=Index([0, 2], name='bar'),
+                         columns=['A', 'B'])
+        df2 = DataFrame([[5, 6], [None, None], [2, 1]],
+                        columns=['X', 'Y'],
+                        index=Index(range(3), name='bar'))
+        df2a = DataFrame([[5, 6], [2, 1]],
+                         index=Index([0, 2], name='bar'),
+                         columns=['X', 'Y'])
+        result1 = df1.expanding().corr(df2, pairwise=True).loc[2]
+        result2 = df1.expanding().corr(df2a, pairwise=True).loc[2]
+        result3 = df1a.expanding().corr(df2, pairwise=True).loc[2]
+        result4 = df1a.expanding().corr(df2a, pairwise=True).loc[2]
+        expected = DataFrame([[-1.0, -1.0], [-1.0, -1.0]],
+                             columns=['A', 'B'],
+                             index=Index(['X', 'Y']))
         tm.assert_frame_equal(result1, expected)
         tm.assert_frame_equal(result2, expected)
         tm.assert_frame_equal(result3, expected)
         tm.assert_frame_equal(result4, expected)
 
-    def test_pairwise_stats_column_names_order(self):
-        # GH 7738
-        df1s = [DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[0, 1]),
-                DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[1, 0]),
-                DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[1, 1]),
-                DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]],
-                          columns=['C', 'C']),
-                DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[1., 0]),
-                DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=[0., 1]),
-                DataFrame([[2, 4], [1, 2], [5, 2], [8, 1]], columns=['C', 1]),
-                DataFrame([[2., 4.], [1., 2.], [5., 2.], [8., 1.]],
-                          columns=[1, 0.]),
-                DataFrame([[2, 4.], [1, 2.], [5, 2.], [8, 1.]],
-                          columns=[0, 1.]),
-                DataFrame([[2, 4], [1, 2], [5, 2], [8, 1.]],
-                          columns=[1., 'X']), ]
-        df2 = DataFrame([[None, 1, 1], [None, 1, 2],
-                         [None, 3, 2], [None, 8, 1]], columns=['Y', 'Z', 'X'])
-        s = Series([1, 1, 3, 8])
-
-        # suppress warnings about incomparable objects, as we are deliberately
-        # testing with such column labels
-        with warnings.catch_warnings():
-            warnings.filterwarnings("ignore",
-                                    message=".*incomparable objects.*",
-                                    category=RuntimeWarning)
-
-            # DataFrame methods (which do not call _flex_binary_moment())
-            for f in [lambda x: x.cov(), lambda x: x.corr(), ]:
-                results = [f(df) for df in df1s]
-                for (df, result) in zip(df1s, results):
-                    tm.assert_index_equal(result.index, df.columns)
-                    tm.assert_index_equal(result.columns, df.columns)
-                for i, result in enumerate(results):
-                    if i > 0:
-                        # compare internal values, as columns can be different
-                        self.assert_numpy_array_equal(result.values,
-                                                      results[0].values)
-
-            # DataFrame with itself, pairwise=True
-            for f in [lambda x: x.expanding().cov(pairwise=True),
-                      lambda x: x.expanding().corr(pairwise=True),
-                      lambda x: x.rolling(window=3).cov(pairwise=True),
-                      lambda x: x.rolling(window=3).corr(pairwise=True),
-                      lambda x: x.ewm(com=3).cov(pairwise=True),
-                      lambda x: x.ewm(com=3).corr(pairwise=True), ]:
-                results = [f(df) for df in df1s]
-                for (df, result) in zip(df1s, results):
-                    tm.assert_index_equal(result.items, df.index)
-                    tm.assert_index_equal(result.major_axis, df.columns)
-                    tm.assert_index_equal(result.minor_axis, df.columns)
-                for i, result in enumerate(results):
-                    if i > 0:
-                        self.assert_numpy_array_equal(result.values,
-                                                      results[0].values)
-
-            # DataFrame with itself, pairwise=False
-            for f in [lambda x: x.expanding().cov(pairwise=False),
-                      lambda x: x.expanding().corr(pairwise=False),
-                      lambda x: x.rolling(window=3).cov(pairwise=False),
-                      lambda x: x.rolling(window=3).corr(pairwise=False),
-                      lambda x: x.ewm(com=3).cov(pairwise=False),
-                      lambda x: x.ewm(com=3).corr(pairwise=False), ]:
-                results = [f(df) for df in df1s]
-                for (df, result) in zip(df1s, results):
-                    tm.assert_index_equal(result.index, df.index)
-                    tm.assert_index_equal(result.columns, df.columns)
-                for i, result in enumerate(results):
-                    if i > 0:
-                        self.assert_numpy_array_equal(result.values,
-                                                      results[0].values)
-
-            # DataFrame with another DataFrame, pairwise=True
-            for f in [lambda x, y: x.expanding().cov(y, pairwise=True),
-                      lambda x, y: x.expanding().corr(y, pairwise=True),
-                      lambda x, y: x.rolling(window=3).cov(y, pairwise=True),
-                      lambda x, y: x.rolling(window=3).corr(y, pairwise=True),
-                      lambda x, y: x.ewm(com=3).cov(y, pairwise=True),
-                      lambda x, y: x.ewm(com=3).corr(y, pairwise=True), ]:
-                results = [f(df, df2) for df in df1s]
-                for (df, result) in zip(df1s, results):
-                    tm.assert_index_equal(result.items, df.index)
-                    tm.assert_index_equal(result.major_axis, df.columns)
-                    tm.assert_index_equal(result.minor_axis, df2.columns)
-                for i, result in enumerate(results):
-                    if i > 0:
-                        self.assert_numpy_array_equal(result.values,
-                                                      results[0].values)
-
-            # DataFrame with another DataFrame, pairwise=False
-            for f in [lambda x, y: x.expanding().cov(y, pairwise=False),
-                      lambda x, y: x.expanding().corr(y, pairwise=False),
-                      lambda x, y: x.rolling(window=3).cov(y, pairwise=False),
-                      lambda x, y: x.rolling(window=3).corr(y, pairwise=False),
-                      lambda x, y: x.ewm(com=3).cov(y, pairwise=False),
-                      lambda x, y: x.ewm(com=3).corr(y, pairwise=False), ]:
-                results = [f(df, df2) if df.columns.is_unique else None
-                           for df in df1s]
-                for (df, result) in zip(df1s, results):
-                    if result is not None:
-                        expected_index = df.index.union(df2.index)
-                        expected_columns = df.columns.union(df2.columns)
-                        tm.assert_index_equal(result.index, expected_index)
-                        tm.assert_index_equal(result.columns, expected_columns)
-                    else:
-                        tm.assertRaisesRegexp(
-                            ValueError, "'arg1' columns are not unique", f, df,
-                            df2)
-                        tm.assertRaisesRegexp(
-                            ValueError, "'arg2' columns are not unique", f,
-                            df2, df)
-
-            # DataFrame with a Series
-            for f in [lambda x, y: x.expanding().cov(y),
-                      lambda x, y: x.expanding().corr(y),
-                      lambda x, y: x.rolling(window=3).cov(y),
-                      lambda x, y: x.rolling(window=3).corr(y),
-                      lambda x, y: x.ewm(com=3).cov(y),
-                      lambda x, y: x.ewm(com=3).corr(y), ]:
-                results = [f(df, s) for df in df1s] + [f(s, df) for df in df1s]
-                for (df, result) in zip(df1s, results):
-                    tm.assert_index_equal(result.index, df.index)
-                    tm.assert_index_equal(result.columns, df.columns)
-                for i, result in enumerate(results):
-                    if i > 0:
-                        self.assert_numpy_array_equal(result.values,
-                                                      results[0].values)
-
     def test_rolling_skew_edge_cases(self):
 
         all_nan = Series([np.NaN] * 5)
diff --git a/pandas/tests/tools/test_concat.py b/pandas/tests/tools/test_concat.py
index c41924a79..623c5fa02 100644
--- a/pandas/tests/tools/test_concat.py
+++ b/pandas/tests/tools/test_concat.py
@@ -1,4 +1,5 @@
 from warnings import catch_warnings
+
 import numpy as np
 from numpy.random import randn
 
@@ -1283,8 +1284,9 @@ class TestConcatenate(ConcatenateBase):
         assert_frame_equal(result, expected)
 
         # invalid concatente of mixed dims
-        panel = tm.makePanel()
-        self.assertRaises(ValueError, lambda: concat([panel, s1], axis=1))
+        with catch_warnings(record=True):
+            panel = tm.makePanel()
+            self.assertRaises(ValueError, lambda: concat([panel, s1], axis=1))
 
     def test_empty_dtype_coerce(self):
 
@@ -1322,56 +1324,59 @@ class TestConcatenate(ConcatenateBase):
         tm.assert_series_equal(result.dtypes, df.dtypes)
 
     def test_panel_concat_other_axes(self):
-        panel = tm.makePanel()
+        with catch_warnings(record=True):
+            panel = tm.makePanel()
 
-        p1 = panel.iloc[:, :5, :]
-        p2 = panel.iloc[:, 5:, :]
+            p1 = panel.iloc[:, :5, :]
+            p2 = panel.iloc[:, 5:, :]
 
-        result = concat([p1, p2], axis=1)
-        tm.assert_panel_equal(result, panel)
+            result = concat([p1, p2], axis=1)
+            tm.assert_panel_equal(result, panel)
 
-        p1 = panel.iloc[:, :, :2]
-        p2 = panel.iloc[:, :, 2:]
+            p1 = panel.iloc[:, :, :2]
+            p2 = panel.iloc[:, :, 2:]
 
-        result = concat([p1, p2], axis=2)
-        tm.assert_panel_equal(result, panel)
+            result = concat([p1, p2], axis=2)
+            tm.assert_panel_equal(result, panel)
 
-        # if things are a bit misbehaved
-        p1 = panel.iloc[:2, :, :2]
-        p2 = panel.iloc[:, :, 2:]
-        p1['ItemC'] = 'baz'
+            # if things are a bit misbehaved
+            p1 = panel.iloc[:2, :, :2]
+            p2 = panel.iloc[:, :, 2:]
+            p1['ItemC'] = 'baz'
 
-        result = concat([p1, p2], axis=2)
+            result = concat([p1, p2], axis=2)
 
-        expected = panel.copy()
-        expected['ItemC'] = expected['ItemC'].astype('O')
-        expected.loc['ItemC', :, :2] = 'baz'
-        tm.assert_panel_equal(result, expected)
+            expected = panel.copy()
+            expected['ItemC'] = expected['ItemC'].astype('O')
+            expected.loc['ItemC', :, :2] = 'baz'
+            tm.assert_panel_equal(result, expected)
 
     def test_panel_concat_buglet(self):
-        # #2257
-        def make_panel():
-            index = 5
-            cols = 3
-
-            def df():
-                return DataFrame(np.random.randn(index, cols),
-                                 index=["I%s" % i for i in range(index)],
-                                 columns=["C%s" % i for i in range(cols)])
-            return Panel(dict([("Item%s" % x, df()) for x in ['A', 'B', 'C']]))
-
-        panel1 = make_panel()
-        panel2 = make_panel()
-
-        panel2 = panel2.rename_axis(dict([(x, "%s_1" % x)
-                                          for x in panel2.major_axis]),
-                                    axis=1)
-
-        panel3 = panel2.rename_axis(lambda x: '%s_1' % x, axis=1)
-        panel3 = panel3.rename_axis(lambda x: '%s_1' % x, axis=2)
-
-        # it works!
-        concat([panel1, panel3], axis=1, verify_integrity=True)
+        with catch_warnings(record=True):
+            # #2257
+            def make_panel():
+                index = 5
+                cols = 3
+
+                def df():
+                    return DataFrame(np.random.randn(index, cols),
+                                     index=["I%s" % i for i in range(index)],
+                                     columns=["C%s" % i for i in range(cols)])
+                return Panel(dict([("Item%s" % x, df())
+                                   for x in ['A', 'B', 'C']]))
+
+            panel1 = make_panel()
+            panel2 = make_panel()
+
+            panel2 = panel2.rename_axis(dict([(x, "%s_1" % x)
+                                              for x in panel2.major_axis]),
+                                        axis=1)
+
+            panel3 = panel2.rename_axis(lambda x: '%s_1' % x, axis=1)
+            panel3 = panel3.rename_axis(lambda x: '%s_1' % x, axis=2)
+
+            # it works!
+            concat([panel1, panel3], axis=1, verify_integrity=True)
 
     def test_panel4d_concat(self):
         with catch_warnings(record=True):
diff --git a/pandas/tests/types/test_missing.py b/pandas/tests/types/test_missing.py
index 2e35f5c1b..efd6dda02 100644
--- a/pandas/tests/types/test_missing.py
+++ b/pandas/tests/types/test_missing.py
@@ -1,5 +1,6 @@
 # -*- coding: utf-8 -*-
 
+from warnings import catch_warnings
 import numpy as np
 from datetime import datetime
 from pandas.util import testing as tm
@@ -76,14 +77,15 @@ class TestIsNull(tm.TestCase):
             tm.assert_frame_equal(result, expected)
 
         # panel
-        for p in [tm.makePanel(), tm.makePeriodPanel(),
-                  tm.add_nans(tm.makePanel())]:
-            result = isnull(p)
-            expected = p.apply(isnull)
-            tm.assert_panel_equal(result, expected)
+        with catch_warnings(record=True):
+            for p in [tm.makePanel(), tm.makePeriodPanel(),
+                      tm.add_nans(tm.makePanel())]:
+                result = isnull(p)
+                expected = p.apply(isnull)
+                tm.assert_panel_equal(result, expected)
 
         # panel 4d
-        with tm.assert_produces_warning(FutureWarning, check_stacklevel=False):
+        with catch_warnings(record=True):
             for p in [tm.makePanel4D(), tm.add_nans_panel4d(tm.makePanel4D())]:
                 result = isnull(p)
                 expected = p.apply(isnull)
diff --git a/pandas/util/testing.py b/pandas/util/testing.py
index 9a9f3c6c6..9d7b00437 100644
--- a/pandas/util/testing.py
+++ b/pandas/util/testing.py
@@ -1747,8 +1747,10 @@ def makePeriodPanel(nper=None):
 
 
 def makePanel4D(nper=None):
-    return Panel4D(dict(l1=makePanel(nper), l2=makePanel(nper),
-                        l3=makePanel(nper)))
+    with warnings.catch_warnings(record=True):
+        d = dict(l1=makePanel(nper), l2=makePanel(nper),
+                 l3=makePanel(nper))
+    return Panel4D(d)
 
 
 def makeCustomIndex(nentries, nlevels, prefix='#', names=False, ndupe_l=None,

commit c9a5c91c80c496dfe305ac68f57951603c0a3ef1
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Feb 8 20:04:06 2012 -0500

    STY: pep8

diff --git a/pandas/core/index.py b/pandas/core/index.py
index ca086443c..c3dbd46c4 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -12,6 +12,7 @@ import pandas._engines as _gin
 
 __all__ = ['Index']
 
+
 def _indexOp(opname):
     """
     Wrapper function for Series arithmetic operations, to avoid
@@ -22,9 +23,11 @@ def _indexOp(opname):
         return func(other)
     return wrapper
 
+
 class InvalidIndexError(Exception):
     pass
 
+
 class Index(np.ndarray):
     """
     Immutable ndarray implementing an ordered, sliceable set. The basic object
@@ -213,7 +216,7 @@ class Index(np.ndarray):
 
     def __setitem__(self, key, value):
         """Disable the setting of values."""
-        raise Exception(str(self.__class__) + ' object is immutable' )
+        raise Exception(str(self.__class__) + ' object is immutable')
 
     def __getitem__(self, key):
         """Override numpy.ndarray's __getitem__ method to work as desired"""
@@ -307,7 +310,7 @@ class Index(np.ndarray):
         if label not in self:
             loc = self.searchsorted(label, side='left')
             if loc > 0:
-                return self[loc-1]
+                return self[loc - 1]
             else:
                 return np.nan
 
@@ -589,8 +592,8 @@ class Index(np.ndarray):
 
     def isin(self, values):
         """
-        Compute boolean array of whether each index value is found in the passed
-        set of values
+        Compute boolean array of whether each index value is found in the
+        passed set of values
 
         Parameters
         ----------
@@ -608,8 +611,8 @@ class Index(np.ndarray):
             method = method.lower()
 
         aliases = {
-            'ffill' : 'pad',
-            'bfill' : 'backfill'
+            'ffill': 'pad',
+            'bfill': 'backfill'
         }
         return aliases.get(method, method)
 
@@ -914,7 +917,7 @@ class Int64Index(Index):
             # other iterable of some kind
             if not isinstance(data, (list, tuple)):
                 data = list(data)
-            data= np.asarray(data)
+            data = np.asarray(data)
 
         if issubclass(data.dtype.type, basestring):
             raise TypeError('String dtype not supported, you may need '
@@ -925,8 +928,8 @@ class Int64Index(Index):
             subarr = np.array(data, dtype=np.int64, copy=copy)
             if len(data) > 0:
                 if (subarr != data).any():
-                    raise TypeError('Unsafe NumPy casting, you must explicitly '
-                                    'cast')
+                    raise TypeError('Unsafe NumPy casting, you must '
+                                    'explicitly cast')
 
         subarr = subarr.view(cls)
         subarr.name = name
@@ -967,6 +970,7 @@ class Int64Index(Index):
         name = self.name if self.name == other.name else None
         return Int64Index(joined, name=name)
 
+
 class DateIndex(Index):
     pass
 
@@ -1019,6 +1023,7 @@ class Factor(np.ndarray):
         else:
             return np.ndarray.__getitem__(self, key)
 
+
 def unique_with_labels(values):
     rizer = lib.Factorizer(len(values))
     labels, _ = rizer.factorize(values, sort=False)
@@ -1035,6 +1040,7 @@ def unique_with_labels(values):
 
     return uniques, labels
 
+
 def unique_int64(values):
     if values.dtype != np.int64:
         values = values.astype('i8')
@@ -1043,9 +1049,11 @@ def unique_int64(values):
     uniques = table.unique(values)
     return uniques
 
+
 class MultiIndex(Index):
     """
-    Implements multi-level, a.k.a. hierarchical, index object for pandas objects
+    Implements multi-level, a.k.a. hierarchical, index object for pandas
+    objects
 
     Parameters
     ----------
@@ -1294,7 +1302,8 @@ class MultiIndex(Index):
         ----------
         arrays : list / sequence
         sortorder : int or None
-            Level of sortedness (must be lexicographically sorted by that level)
+            Level of sortedness (must be lexicographically sorted by that
+            level)
 
         Returns
         -------
@@ -1319,7 +1328,8 @@ class MultiIndex(Index):
         ----------
         tuples : array-like
         sortorder : int or None
-            Level of sortedness (must be lexicographically sorted by that level)
+            Level of sortedness (must be lexicographically sorted by that
+            level)
 
         Returns
         -------
@@ -1569,7 +1579,6 @@ class MultiIndex(Index):
 
         new_labels = [lab.take(indexer) for lab in self.labels]
 
-
         new_index = MultiIndex._from_elements(self.values.take(indexer),
                                               labels=new_labels,
                                               levels=self.levels,
@@ -1980,8 +1989,8 @@ class MultiIndex(Index):
         other_tuples = other.values
         uniq_tuples = sorted(set(self_tuples) & set(other_tuples))
         if len(uniq_tuples) == 0:
-            return MultiIndex(levels=[[]]*self.nlevels,
-                              labels=[[]]*self.nlevels,
+            return MultiIndex(levels=[[]] * self.nlevels,
+                              labels=[[]] * self.nlevels,
                               names=result_names)
         else:
             return MultiIndex.from_arrays(zip(*uniq_tuples), sortorder=0,
@@ -2000,15 +2009,15 @@ class MultiIndex(Index):
         result_names = self.names if self.names == other.names else None
 
         if self.equals(other):
-            return MultiIndex(levels=[[]]*self.nlevels,
-                              labels=[[]]*self.nlevels,
+            return MultiIndex(levels=[[]] * self.nlevels,
+                              labels=[[]] * self.nlevels,
                               names=result_names)
 
         difference = sorted(set(self.values) - set(other.values))
 
         if len(difference) == 0:
-            return MultiIndex(levels=[[]]*self.nlevels,
-                              labels=[[]]*self.nlevels,
+            return MultiIndex(levels=[[]] * self.nlevels,
+                              labels=[[]] * self.nlevels,
                               names=result_names)
         else:
             return MultiIndex.from_tuples(difference, sortorder=0,
@@ -2071,6 +2080,7 @@ class MultiIndex(Index):
     get_major_bounds = slice_locs
 
     __bounds = None
+
     @property
     def _bounds(self):
         """
@@ -2083,15 +2093,16 @@ class MultiIndex(Index):
 
         return self.__bounds
 
-
     def _wrap_joined_index(self, joined, other):
         names = self.names if self.names == other.names else None
         return MultiIndex.from_tuples(joined, names=names)
 
+
 # For utility purposes
 
 NULL_INDEX = Index([])
 
+
 def _sparsify(label_list):
     pivoted = zip(*label_list)
     k = len(label_list)
@@ -2117,6 +2128,7 @@ def _sparsify(label_list):
 
     return zip(*result)
 
+
 def _ensure_index(index_like):
     if isinstance(index_like, Index):
         return index_like
@@ -2127,8 +2139,8 @@ def _validate_join_method(method):
     if method not in ['left', 'right', 'inner', 'outer']:
         raise Exception('do not recognize join method %s' % method)
 
-# TODO: handle index names!
 
+# TODO: handle index names!
 def _get_combined_index(indexes, intersect=False):
     indexes = _get_distinct_indexes(indexes)
     if len(indexes) == 0:
@@ -2140,9 +2152,10 @@ def _get_combined_index(indexes, intersect=False):
         for other in indexes[1:]:
             index = index.intersection(other)
         return index
-    union =  _union_indexes(indexes)
+    union = _union_indexes(indexes)
     return _ensure_index(union)
 
+
 def _get_distinct_indexes(indexes):
     return dict((id(x), x) for x in indexes).values()
 
@@ -2172,6 +2185,7 @@ def _union_indexes(indexes):
     else:
         return Index(lib.fast_unique_multiple_list(indexes))
 
+
 def _trim_front(strings):
     """
     Trims zeros and decimal points
@@ -2181,6 +2195,7 @@ def _trim_front(strings):
         trimmed = [x[1:] for x in trimmed]
     return trimmed
 
+
 def _sanitize_and_check(indexes):
     kinds = list(set([type(index) for index in indexes]))
 
@@ -2193,7 +2208,6 @@ def _sanitize_and_check(indexes):
         else:
             return indexes, 'list'
 
-
     if len(kinds) > 1 or Index not in kinds:
         return indexes, 'special'
     else:
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 81e81e0c5..0b70e4fec 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -84,15 +84,15 @@ class _NDFrameIndexer(object):
                 raise IndexingError('setting on mixed-type frames only '
                                     'allowed with scalar values')
 
-            plane_indexer = indexer[:het_axis] + indexer[het_axis+1:]
+            plane_indexer = indexer[:het_axis] + indexer[het_axis + 1:]
             item_labels = self.obj._get_axis(het_axis)
             for item in item_labels[het_idx]:
                 data = self.obj[item]
                 data.values[plane_indexer] = value
         else:
-           if isinstance(indexer, tuple):
-               indexer = _maybe_convert_ix(*indexer)
-           self.obj.values[indexer] = value
+            if isinstance(indexer, tuple):
+                indexer = _maybe_convert_ix(*indexer)
+            self.obj.values[indexer] = value
 
     def _getitem_tuple(self, tup):
         try:
@@ -139,10 +139,10 @@ class _NDFrameIndexer(object):
 
                 # might have been a MultiIndex
                 if section.ndim == self.ndim:
-                    new_key = tup[:i] + (_NS,) + tup[i+1:]
+                    new_key = tup[:i] + (_NS,) + tup[i + 1:]
                     # new_key = tup[:i] + tup[i+1:]
                 else:
-                    new_key = tup[:i] + tup[i+1:]
+                    new_key = tup[:i] + tup[i + 1:]
 
                     # unfortunately need an odious kludge here because of
                     # DataFrame transposing convention
@@ -195,7 +195,7 @@ class _NDFrameIndexer(object):
 
         if com._is_bool_indexer(key):
             key = _check_bool_indexer(labels, key)
-            return self.obj.reindex(**{axis_name : labels[np.asarray(key)]})
+            return self.obj.reindex(**{axis_name: labels[np.asarray(key)]})
         else:
             if isinstance(key, Index):
                 # want Index objects to pass through untouched
@@ -206,7 +206,7 @@ class _NDFrameIndexer(object):
             if _is_integer_dtype(keyarr) and not _is_integer_index(labels):
                 keyarr = labels.take(keyarr)
 
-            return self.obj.reindex(**{axis_name : keyarr})
+            return self.obj.reindex(**{axis_name: keyarr})
 
     def _convert_to_indexer(self, obj, axis=0):
         """
@@ -315,6 +315,7 @@ class _NDFrameIndexer(object):
 
         return self._slice(slicer, axis=axis)
 
+
 def _is_index_slice(obj):
     def _is_valid_index(x):
         return com.is_integer(x) or com.is_float(x) and np.allclose(x, int(x))
@@ -326,6 +327,7 @@ def _is_index_slice(obj):
 
     return not both_none and (_crit(obj.start) and _crit(obj.stop))
 
+
 class _SeriesIndexer(_NDFrameIndexer):
     """
     Class to support fancy indexing, potentially using labels
@@ -354,6 +356,7 @@ class _SeriesIndexer(_NDFrameIndexer):
     def _setitem_with_indexer(self, indexer, value):
         self.obj._set_values(indexer, value)
 
+
 def _check_bool_indexer(ax, key):
     # boolean indexing, need to check that the data are aligned, otherwise
     # disallowed
@@ -370,10 +373,12 @@ def _check_bool_indexer(ax, key):
 
     return result
 
+
 def _is_series(obj):
     from pandas.core.series import Series
     return isinstance(obj, Series)
 
+
 def _maybe_convert_ix(*args):
     """
     We likely want to take the cross-product
@@ -388,28 +393,35 @@ def _maybe_convert_ix(*args):
     else:
         return args
 
+
 def _is_null_slice(obj):
     return (isinstance(obj, slice) and obj.start is None and
             obj.stop is None and obj.step is None)
 
+
 def _is_integer_dtype(arr):
     return issubclass(arr.dtype.type, np.integer)
 
+
 def _is_integer_index(index):
     return index.inferred_type == 'integer'
 
+
 def _is_label_like(key):
     # select a label or row
     return not isinstance(key, slice) and not _is_list_like(key)
 
+
 def _is_list_like(obj):
     return np.iterable(obj) and not isinstance(obj, basestring)
 
+
 def _need_slice(obj):
     return (obj.start is not None or
             obj.stop is not None or
             (obj.step is not None and obj.step != 1))
 
+
 def _maybe_droplevels(index, key):
     # drop levels
     if isinstance(key, tuple):
@@ -419,4 +431,3 @@ def _maybe_droplevels(index, key):
         index = index.droplevel(0)
 
     return index
-

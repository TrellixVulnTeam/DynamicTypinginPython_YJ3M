commit a92d411cc75a4086439305a4c396157ab43662ee
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Nov 9 22:14:19 2011 -0500

    BUG: fix outer join with MultiIndex, is_monotonic bug fix, GH #351

diff --git a/RELEASE.rst b/RELEASE.rst
index da7f5c8e2..5d8e2313d 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -91,6 +91,8 @@ pandas 0.5.1
   - Fix failure passing Int64Index to Index.union when both are monotonic
   - Fix error when passing SparseSeries to (dense) DataFrame constructor
   - Added missing bang at top of setup.py (GH #352)
+  - Change `is_monotonic` on MultiIndex so it properly compares the tuples
+  - Fix MultiIndex outer join logic (GH #351)
 
 Thanks
 ------
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 175cfcbac..f8d04d648 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -91,7 +91,7 @@ class Index(np.ndarray):
 
     @cache_readonly
     def is_monotonic(self):
-        return self._is_monotonic(self)
+        return self._is_monotonic(self.values)
 
     _indexMap = None
     _integrity = False
@@ -517,6 +517,9 @@ class Index(np.ndarray):
             return join_index
 
     def _join_monotonic(self, other, how='left', return_indexers=False):
+        this_vals = self.values
+        other_vals = other.values
+
         if how == 'left':
             join_index = self
             lidx = None
@@ -526,11 +529,13 @@ class Index(np.ndarray):
             lidx = lib.left_join_indexer_object(other, self)
             ridx = None
         elif how == 'inner':
-            join_index, lidx, ridx = lib.inner_join_indexer_object(self, other)
-            join_index = Index(join_index)
+            join_index, lidx, ridx = lib.inner_join_indexer_object(this_vals,
+                                                                   other_vals)
+            join_index = self._wrap_joined_index(join_index, other)
         elif how == 'outer':
-            join_index, lidx, ridx = lib.outer_join_indexer_object(self, other)
-            join_index = Index(join_index)
+            join_index, lidx, ridx = lib.outer_join_indexer_object(this_vals,
+                                                                   other_vals)
+            join_index = self._wrap_joined_index(join_index, other)
         else:  # pragma: no cover
             raise Exception('do not recognize join method %s' % how)
 
@@ -539,6 +544,10 @@ class Index(np.ndarray):
         else:
             return join_index
 
+    def _wrap_joined_index(self, joined, other):
+        name = self.name if self.name == other.name else None
+        return Index(joined, name=name)
+
     def slice_locs(self, start=None, end=None):
         """
         For an ordered Index, compute the slice locations for input labels
@@ -1641,6 +1650,11 @@ class MultiIndex(Index):
 
         return self.__bounds
 
+
+    def _wrap_joined_index(self, joined, other):
+        names = self.names if self.names == other.names else None
+        return MultiIndex.from_tuples(joined, names=names)
+
 # For utility purposes
 
 NULL_INDEX = Index([])
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index e2881ed10..0a4641e13 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -3514,6 +3514,39 @@ class TestDataFrameJoin(unittest.TestCase):
 
         a.join(d)
 
+    def test_join_multiindex(self):
+        index1 = MultiIndex.from_arrays([['a','a','a','b','b','b'],
+                                         [1,2,3,1,2,3]],
+                                        names=['first', 'second'])
+
+        index2 = MultiIndex.from_arrays([['b','b','b','c','c','c'],
+                                         [1,2,3,1,2,3]],
+                                        names=['first', 'second'])
+
+        df1 = DataFrame(data=np.random.randn(6), index=index1,
+                        columns=['var X'])
+        df2 = DataFrame(data=np.random.randn(6), index=index2,
+                        columns=['var Y'])
+
+        df1 = df1.sortlevel(0)
+        df2 = df2.sortlevel(0)
+
+        joined = df1.join(df2, how='outer')
+        ex_index = index1.get_tuple_index() + index2.get_tuple_index()
+        expected = df1.reindex(ex_index).join(df2.reindex(ex_index))
+        assert_frame_equal(joined, expected)
+        self.assertEqual(joined.index.names, index1.names)
+
+        df1 = df1.sortlevel(1)
+        df2 = df2.sortlevel(1)
+
+        joined = df1.join(df2, how='outer').sortlevel(0)
+        ex_index = index1.get_tuple_index() + index2.get_tuple_index()
+        expected = df1.reindex(ex_index).join(df2.reindex(ex_index))
+        assert_frame_equal(joined, expected)
+        self.assertEqual(joined.index.names, index1.names)
+
+
 def _join_by_hand(a, b, how='left'):
     join_index = a.index.join(b.index, how=how)
 

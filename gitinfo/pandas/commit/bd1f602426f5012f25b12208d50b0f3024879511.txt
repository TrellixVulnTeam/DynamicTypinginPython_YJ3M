commit bd1f602426f5012f25b12208d50b0f3024879511
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Thu Mar 11 22:39:06 2010 +0000

    more unit tests, miscellaneous fixes for tdates.c removal
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@139 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/__init__.py b/pandas/__init__.py
index 7e1febdf6..f290baba1 100644
--- a/pandas/__init__.py
+++ b/pandas/__init__.py
@@ -12,3 +12,47 @@ from pandas.info import __doc__
 from pandas.core.api import *
 from pandas.io.parsers import parseCSV, parseText, parseExcel
 from pandas.stats.api import *
+
+from numpy.testing import Tester
+class NoseWrapper(Tester):
+    '''
+    This is simply a monkey patch for numpy.testing.Tester, so that extra_argv can
+    be changed from its default None to ['--exe'] so that the tests can be run
+    the same across platforms.
+    '''
+    def test(self, label='fast', verbose=1, extra_argv=['--exe'], doctests=False,
+             coverage=False):
+        ''' Run tests for module using nose
+
+        %(test_header)s
+        doctests : boolean
+            If True, run doctests in module, default False
+        coverage : boolean
+            If True, report coverage of NumPy code, default False
+            (Requires the coverage module:
+             http://nedbatchelder.com/code/modules/coverage.html)
+        '''
+
+        # cap verbosity at 3 because nose becomes *very* verbose beyond that
+        verbose = min(verbose, 3)
+
+        from numpy.testing import utils
+        utils.verbose = verbose
+
+        if doctests:
+            print "Running unit tests and doctests for %s" % self.package_name
+        else:
+            print "Running unit tests for %s" % self.package_name
+
+        self._show_system_info()
+
+        # reset doctest state on every run
+        import doctest
+        doctest.master = None
+
+        argv, plugins = self.prepare_test_args(label, verbose, extra_argv,
+                                               doctests, coverage)
+        from numpy.testing.noseclasses import NumpyTestProgram
+        t = NumpyTestProgram(argv=argv, exit=False, plugins=plugins)
+        return t.result
+test = NoseWrapper().test
diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index 55a155ed1..0bca109c3 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -163,6 +163,14 @@ class DateRange(Index):
         return index
 
 
+    @property
+    def _allDates(self):
+        return True
+        # if not hasattr(self, '_cache_allDates'):
+        #     self._cache_allDates = isAllDates(self)
+
+        # return self._cache_allDates
+
     @classmethod
     def getCachedRange(cls, start=None, end=None, periods=None, offset=None,
                        timeRule=None):
@@ -231,14 +239,14 @@ class DateRange(Index):
         if self.ndim == 0:
             return self.item()
 
-        if len(self) > 0:
-            self.indexMap = map_indices(self)
-        else:
-            self.indexMap = {}
+        # if len(self) > 0:
+        #     self.indexMap = map_indices(self)
+        # else:
+        #     self.indexMap = {}
 
         self.offset = getattr(obj, 'offset', None)
         self._parent = getattr(obj, '_parent',  None)
-        self._allDates = True
+        # self._allDates = True
 
     def __lt__(self, other):
         return self.view(np.ndarray) < other
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index ebc499423..9901af926 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -803,23 +803,18 @@ class DataFrame(Picklable, Groupable):
         after = datetools.to_datetime(after)
 
         if before is None:
-            before = self.index[0]
+            beg_slice = 0
         elif before not in self.index:
-            loc = self.index.searchsorted(before, side='left')
-            before = self.index[loc]
+            beg_slice = self.index.searchsorted(before, side='left')
+        else:
+            beg_slice = self.index.indexMap[before]
 
         if after is None:
-            after = self.index[-1]
+            end_slice = len(self.index)
         elif after not in self.index:
-            loc = self.index.searchsorted(after, side='right') - 1
-
-            if loc >= len(self.index):
-                loc = -1
-
-            after = self.index[loc]
-
-        beg_slice = self.index.indexMap[before]
-        end_slice = self.index.indexMap[after] + 1
+            end_slice = self.index.searchsorted(after, side='right')
+        else:
+            end_slice = self.index.indexMap[after] + 1
 
         return beg_slice, end_slice
 
@@ -902,8 +897,8 @@ class DataFrame(Picklable, Groupable):
         if self.index.equals(index):
             return self.copy()
 
-        if len(index) == 0:
-            return DataFrame(index=NULL_INDEX)
+        # if len(index) == 0:
+        #     return DataFrame(index=NULL_INDEX)
 
         if not isinstance(index, Index):
             index = Index(index)
@@ -989,7 +984,7 @@ class DataFrame(Picklable, Groupable):
         if periods == 0:
             return self
 
-        if timeRule is not None and offset is None:
+        if timeRule and not offset:
             offset = datetools.getOffset(timeRule)
 
         N = len(self)
@@ -1049,15 +1044,19 @@ class DataFrame(Picklable, Groupable):
 
         if axis == 0:
             target = self
+            agg_index = self.cols()
         elif axis == 1:
             target = self.T
+            agg_index = self.index
 
-        results = dict([(k, func(target[k])) for k in target.columns])
+        results = {}
+        for k in target.cols():
+            results[k] = func(target[k])
 
         if hasattr(results.values()[0], '__iter__'):
-            return DataFrame(data=results, index=target.index)
+            return self._constructor(data=results, index=target.index)
         else:
-            return Series(results)
+            return Series(results, index=agg_index)
 
     def tapply(self, func):
         """
@@ -1350,6 +1349,8 @@ class DataFrame(Picklable, Groupable):
             raise Exception('Columns overlap: %s' % sorted(overlap))
 
         if len(other.index) == 0:
+            print other.cols()
+
             result = self.copy()
 
             for col in other:
@@ -1417,12 +1418,20 @@ class DataFrame(Picklable, Groupable):
         Series or TimeSeries
         """
         try:
-            theCount = np.isfinite(self.values).sum(axis)
+            cols = self.cols()
+            values = self.asMatrix(cols)
+
+            if axis == 0:
+                axis_labels = cols
+            else:
+                axis_labels = self.index
+
+            mask = np.empty(values.shape, dtype=bool)
+            mask.flat = notnull(values.ravel())
+            return Series(mask.sum(axis), index=axis_labels)
         except Exception:
             f = lambda s: notnull(s).sum()
-            theCount = self.apply(f, axis=axis)
-
-        return Series(theCount, index=self._get_agg_axis(axis))
+            return self.apply(f, axis=axis)
 
     def sum(self, axis=0):
         """
@@ -1453,16 +1462,18 @@ class DataFrame(Picklable, Groupable):
         """
         y = np.array(self.values, subok=True)
 
+        axis_labels = self._get_agg_axis(axis)
         try:
+            mask = np.isfinite(y)
             if not issubclass(y.dtype.type, np.int_):
-                y[np.isnan(y)] = 0
+                y[-mask] = 0
             theSum = y.sum(axis)
-            theCount = self.count(axis)
+            theCount = mask.sum(axis)
             theSum[theCount == 0] = NaN
         except Exception:
             theSum = self.apply(np.sum, axis=axis)
 
-        return Series(theSum, index=self._get_agg_axis(axis))
+        return Series(theSum, index=axis_labels)
 
     def cumsum(self, axis=0):
         """
@@ -1551,7 +1562,10 @@ class DataFrame(Picklable, Groupable):
         -------
         Series or TimeSeries
         """
-        return self.sum(axis) / self.count(axis).values().astype(float)
+        summed = self.sum(axis)
+        count = self.count(axis).astype(float)
+
+        return summed / count.reindex(summed.index)
 
     def median(self, axis=0):
         """
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index 899eb92c1..5aee5e11f 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -73,7 +73,7 @@ class GroupBy(object):
         elif isinstance(obj, DataFrame):
             klass = DataFrameGroupBy
 
-        return object.__new__(klass, obj, grouper)
+        return object.__new__(klass)
 
     def __init__(self, obj, grouper):
         self.obj = obj
diff --git a/pandas/core/index.py b/pandas/core/index.py
index aee619b80..e3f604b59 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -3,8 +3,7 @@
 # pylint: disable-msg=W0232
 
 import numpy as np
-from pandas.lib.tdates import isAllDates
-from pandas.lib.tseries import map_indices
+from pandas.lib.tseries import map_indices, isAllDates
 
 def _indexOp(opname):
     """
@@ -17,14 +16,15 @@ def _indexOp(opname):
     return wrapper
 
 
+
 class Index(np.ndarray):
     """Extension of numpy-array to represent a series index,
     dates or otherwise.
 
     Index is immutable always (don't even try to change elements!).
 
-    Note that the Index can ONLY contain immutable objects. Mutable objects are not
-    hashable, and that's bad!
+    Note that the Index can ONLY contain immutable objects. Mutable
+    objects are not hashable, and that's bad!
     """
     def __new__(cls, data, dtype=object, copy=False):
         subarr = np.array(data, dtype=dtype, copy=copy)
@@ -41,27 +41,38 @@ class Index(np.ndarray):
             # tolist will cause a bus error if this is not here, hmm
 
             return self.item()
-
-
             # raise Exception('Cannot create 0-dimensional Index!')
 
         # New instance creation
         if obj is None:
-            self.indexMap = map_indices(self)
-            self._allDates = isAllDates(self)
+            pass
 
         # New from template / slicing
         elif isinstance(obj, type(self)) and len(self) != len(obj.indexMap):
-            self.indexMap = map_indices(self)
-            self._allDates = isAllDates(self)
+            pass
 
         # View casting
         else:
-            self.indexMap = getattr(obj, 'indexMap', map_indices(self))
-            self._allDates = getattr(obj, '_allDates', isAllDates(self))
+            if hasattr(obj, '_cache_indexMap'):
+                self._cache_indexMap = obj._cache_indexMap
+                self._cache_allDates = getattr(obj, '_cache_allDates', None)
 
         self._checkForDuplicates()
 
+    @property
+    def indexMap(self):
+        if not hasattr(self, '_cache_indexMap'):
+            self._cache_indexMap = map_indices(self)
+
+        return self._cache_indexMap
+
+    @property
+    def _allDates(self):
+        if not hasattr(self, '_cache_allDates'):
+            self._cache_allDates = isAllDates(self)
+
+        return self._cache_allDates
+
     def _checkForDuplicates(self):
         if len(self.indexMap) < len(self):
             raise Exception('Index cannot contain duplicate values!')
@@ -71,9 +82,9 @@ class Index(np.ndarray):
 
     def __setstate__(self,state):
         """Necessary for making this object picklable"""
-        np.ndarray.__setstate__(self,state)
-        self.indexMap = map_indices(self)
-        self._allDates = isAllDates(self)
+        np.ndarray.__setstate__(self, state)
+        self._cache_indexMap = map_indices(self)
+        self._cache_allDates = isAllDates(self)
 
     def __deepcopy__(self, memo={}):
         """
diff --git a/pandas/core/matrix.py b/pandas/core/matrix.py
index 7467455fc..c9329fcea 100644
--- a/pandas/core/matrix.py
+++ b/pandas/core/matrix.py
@@ -102,8 +102,18 @@ class DataMatrix(DataFrame):
         Somehow this got outrageously complicated
         """
         if len(data) == 0:
+            if objects is not None:
+                if isinstance(objects, DataMatrix):
+                    if index is not None and objects.index is not index:
+                        objects = objects.reindex(index)
+                else:
+                    objects = DataMatrix(objects, index=index)
+
+                index = objects.index
+
             if index is None:
                 index = NULL_INDEX
+
             values = np.empty((len(index), 0), dtype=dtype)
             columns = NULL_INDEX
             return index, columns, values, objects
@@ -364,8 +374,6 @@ class DataMatrix(DataFrame):
         space = max([len(str(k)) for k in self.cols()]) + 4
 
         counts = self.apply(notnull).sum(0)
-        if self.objects is not None:
-            counts = counts.append(self.objects.apply(notnull).sum(0))
 
         columns = []
         for j, col in enumerate(self.columns):
@@ -1082,9 +1090,6 @@ class DataMatrix(DataFrame):
         if index is self.index:
             return self.copy()
 
-        if len(index) == 0:
-            return DataMatrix(index=NULL_INDEX)
-
         if not isinstance(index, Index):
             index = Index(index)
 
@@ -1096,7 +1101,8 @@ class DataMatrix(DataFrame):
                                            index.indexMap, method)
 
         tmpMatrix = self.values.take(fillVec, axis=0)
-        tmpMatrix[-mask] = NaN
+        if len(index) > 0:
+            tmpMatrix[-mask] = NaN
 
         if self.objects is not None and len(self.objects.columns) > 0:
             newObjects = self.objects.reindex(index)
@@ -1221,31 +1227,12 @@ class DataMatrix(DataFrame):
         if not len(self.cols()):
             return self
 
-        results = {}
-
         if isinstance(func, np.ufunc):
             results = func(self.values)
-        else:
-            if axis == 0:
-                target = self
-            elif axis == 1:
-                target = self.T
-
-            results = dict([(k, func(target[k])) for k in target.columns])
-
-        if isinstance(results, np.ndarray):
             return DataMatrix(data=results, index=self.index,
                               columns=self.columns, objects=self.objects)
-
-        elif isinstance(results, dict):
-            if isinstance(results.values()[0], np.ndarray):
-                return DataMatrix(results, index=self.index,
-                                  columns=self.columns,
-                                  objects=self.objects)
-            else:
-                return Series(results)
         else:
-            raise Exception('Should not reach here')
+            return DataFrame.apply(self, func, axis=axis)
 
     def applymap(self, func):
         """
@@ -1278,9 +1265,11 @@ class DataMatrix(DataFrame):
         other : DataFrame
         """
         if not other:
-            return self
+            return self.copy()
+
         if not self:
-            return other
+            return other.copy()
+
         if (isinstance(other, DataMatrix) and
             self.columns.equals(other.columns)):
 
diff --git a/pandas/core/panel.py b/pandas/core/panel.py
index 7d00f3170..38e21c01d 100644
--- a/pandas/core/panel.py
+++ b/pandas/core/panel.py
@@ -975,6 +975,9 @@ class LongPanel(Panel):
 
         self.factors = factors or {}
 
+    def __len__(self):
+        return len(self.index)
+
     @classmethod
     def fromRecords(cls, data, major_field, minor_field,
                     factors=None, exclude=None):
@@ -1586,6 +1589,9 @@ class LongPanelIndex(object):
 
         self._mask = mask
 
+    def __len__(self):
+        return len(self.major_labels)
+
     def __getstate__(self):
         return (_pickle_array(self.major_axis),
                 _pickle_array(self.minor_axis),
diff --git a/pandas/core/series.py b/pandas/core/series.py
index e124f0c64..d6e88953c 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -843,6 +843,14 @@ class Series(np.ndarray, Picklable, Groupable):
 
         If there is no good value, NaN is returned.
 
+        Parameters
+        ----------
+        date : datetime or similar value
+
+        Note
+        ----
+        Dates are assumed to be sorted
+
         Returns
         -------
         value or NaN
@@ -854,10 +862,10 @@ class Series(np.ndarray, Picklable, Groupable):
 
         if isnull(v):
             candidates = self.index[notnull(self)]
-            candidates = candidates[candidates <= date]
+            index = candidates.searchsorted(date)
 
-            if candidates.any():
-                asOfDate = candidates[-1]
+            if index > 0:
+                asOfDate = candidates[index - 1]
             else:
                 return NaN
 
diff --git a/pandas/core/tests/__init__.py b/pandas/core/tests/__init__.py
deleted file mode 100644
index 0f65ad168..000000000
--- a/pandas/core/tests/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-                
diff --git a/pandas/core/tests/test_frame.py b/pandas/core/tests/test_frame.py
index e326cd6ae..c72692d5a 100644
--- a/pandas/core/tests/test_frame.py
+++ b/pandas/core/tests/test_frame.py
@@ -10,12 +10,12 @@ import numpy as np
 from pandas.core.api import DataFrame, Index, Series, notnull
 import pandas.core.datetools as datetools
 
-from pandas.core.tests.common import (assert_almost_equal,
-                                      assert_series_equal,
-                                      assert_frame_equal,
-                                      randn)
+from pandas.util.testing import (assert_almost_equal,
+                                 assert_series_equal,
+                                 assert_frame_equal,
+                                 randn)
 
-import pandas.core.tests.common as common
+import pandas.util.testing as common
 
 #-------------------------------------------------------------------------------
 # DataFrame test cases
@@ -493,6 +493,15 @@ class TestDataFrame(unittest.TestCase):
 
         assert_frame_equal(mixed_appended, mixed_appended2)
 
+        # append empty
+        appended = self.frame.append(self.empty)
+        assert_frame_equal(self.frame, appended)
+        self.assert_(appended is not self.frame)
+
+        appended = self.empty.append(self.frame)
+        assert_frame_equal(self.frame, appended)
+        self.assert_(appended is not self.frame)
+
     def test_asfreq(self):
         offset_monthly = self.tsframe.asfreq(datetools.bmonthEnd)
         rule_monthly = self.tsframe.asfreq('EOM')
@@ -635,6 +644,17 @@ class TestDataFrame(unittest.TestCase):
             else:
                 self.assertEqual(value, self.frame[item][idx])
 
+        # mixed-type getXS
+        test_data = {
+                'A' : {'1' : 1, '2' : 2},
+                'B' : {'1' : '1', '2' : '2', '3' : '3'},
+        }
+        frame = self.klass(test_data)
+        xs = frame.getXS('1')
+        self.assert_(xs.dtype == np.object_)
+        self.assertEqual(xs['A'], 1)
+        self.assertEqual(xs['B'], '1')
+
         self.assertRaises(Exception, self.tsframe.getXS,
                           self.tsframe.index[0] - datetools.bday)
 
@@ -700,6 +720,7 @@ class TestDataFrame(unittest.TestCase):
         # length zero
         newFrame = self.frame.reindex([])
         self.assert_(not newFrame)
+        self.assertEqual(len(newFrame.cols()), len(self.frame.cols()))
 
         # pass non-Index
         newFrame = self.frame.reindex(list(self.ts1.index))
@@ -765,6 +786,9 @@ class TestDataFrame(unittest.TestCase):
         shiftedFrame = self.tsframe.shift(5, offset=datetools.BDay())
         self.assert_(len(shiftedFrame) == len(self.tsframe))
 
+        shiftedFrame2 = self.tsframe.shift(5, timeRule='WEEKDAY')
+        assert_frame_equal(shiftedFrame, shiftedFrame2)
+
         d = self.tsframe.index[0]
         shifted_d = d + datetools.BDay(5)
         assert_series_equal(self.tsframe.getXS(d),
@@ -782,6 +806,14 @@ class TestDataFrame(unittest.TestCase):
         d = self.frame.index[0]
         applied = self.frame.apply(np.mean, axis=1)
         self.assertEqual(applied[d], np.mean(self.frame.getXS(d)))
+        self.assert_(applied.index is self.frame.index) # want this
+
+        # empty
+        applied = self.empty.apply(np.sqrt)
+        self.assert_(not applied)
+
+        applied = self.empty.apply(np.mean)
+        self.assert_(not applied)
 
     def test_tapply(self):
         d = self.frame.index[0]
@@ -974,7 +1006,7 @@ class TestDataFrame(unittest.TestCase):
         # corner cases
 
         # nothing to merge
-        merged = target.merge(source[:0], on='C')
+        merged = target.merge(source.reindex([]), on='C')
 
         # overlap
         source_copy = source.copy()
diff --git a/pandas/core/tests/test_index.py b/pandas/core/tests/test_index.py
index b83db9349..3211c726c 100644
--- a/pandas/core/tests/test_index.py
+++ b/pandas/core/tests/test_index.py
@@ -1,6 +1,6 @@
 from datetime import timedelta
 from pandas.core.index import Index
-import pandas.core.tests.common as common
+import pandas.util.testing as common
 import pandas.lib.tseries as tseries
 import numpy as np
 import os
diff --git a/pandas/core/tests/test_matrix.py b/pandas/core/tests/test_matrix.py
index b8dd696ad..9fcab4939 100644
--- a/pandas/core/tests/test_matrix.py
+++ b/pandas/core/tests/test_matrix.py
@@ -4,8 +4,10 @@ import unittest
 from numpy.random import randn
 import numpy as np
 
-from pandas.core.api import Series, DataMatrix
-import pandas.core.tests.test_frame as test_frame
+from pandas.core.api import Series, DataMatrix, DataFrame
+
+import pandas.util.testing as common
+import test_frame
 
 #-------------------------------------------------------------------------------
 # DataMatrix test cases
@@ -59,6 +61,17 @@ class TestDataMatrix(test_frame.TestDataFrame):
         dm = DataMatrix(objects=self.mixed_frame.objects)
         self.assert_(dm.index is self.mixed_frame.index)
 
+        # take dict of objects
+        index = self.mixed_frame.index
+        dm = DataMatrix(data={}, objects=self.mixed_frame.objects._series)
+        self.assert_(isinstance(dm.objects, DataMatrix))
+        self.assert_(dm.index is dm.objects.index)
+
+        index = self.mixed_frame.index
+        dm = DataMatrix(objects=self.mixed_frame.objects._series)
+        self.assert_(isinstance(dm.objects, DataMatrix))
+        self.assert_(dm.index is dm.objects.index)
+
     def test_copy(self):
         # copy objects
         copy = self.mixed_frame.copy()
@@ -118,6 +131,12 @@ class TestDataMatrix(test_frame.TestDataFrame):
         # XXX
         obj_result = self.mixed_frame.objects.fill(value=0)
 
+    def test_count_objects(self):
+        dm = DataMatrix(self.mixed_frame._series)
+        df = DataFrame(self.mixed_frame._series)
+
+        common.assert_series_equal(dm.count(), df.count())
+        common.assert_series_equal(dm.count(1), df.count(1))
 
 if __name__ == '__main__':
     unittest.main()
diff --git a/pandas/core/tests/test_panel.py b/pandas/core/tests/test_panel.py
index 41a34fd09..5f5a5b401 100644
--- a/pandas/core/tests/test_panel.py
+++ b/pandas/core/tests/test_panel.py
@@ -8,10 +8,10 @@ import numpy as np
 from pandas.core.api import Index, notnull
 from pandas.core.datetools import bday
 from pandas.core.panel import WidePanel, LongPanelIndex, LongPanel
-from pandas.core.tests.common import (assert_frame_equal,
+from pandas.util.testing import (assert_frame_equal,
                                       assert_series_equal,
                                       assert_almost_equal)
-import pandas.core.tests.common as common
+import pandas.util.testing as common
 
 class PanelTests(object):
 
@@ -163,14 +163,14 @@ class TestWidePanel(unittest.TestCase, PanelTests):
         assert(self.panel._get_axis(2) is self.panel.minor_axis)
 
     def test_get_axis_number(self):
-        assert(self.panel._get_axis_number('items'), 0)
-        assert(self.panel._get_axis_number('major'), 1)
-        assert(self.panel._get_axis_number('minor'), 2)
+        self.assertEqual(self.panel._get_axis_number('items'), 0)
+        self.assertEqual(self.panel._get_axis_number('major'), 1)
+        self.assertEqual(self.panel._get_axis_number('minor'), 2)
 
     def test_get_axis_name(self):
-        assert(self.panel._get_axis_name(0), 'items')
-        assert(self.panel._get_axis_name(1), 'major')
-        assert(self.panel._get_axis_name(2), 'minor')
+        self.assertEqual(self.panel._get_axis_name(0), 'items')
+        self.assertEqual(self.panel._get_axis_name(1), 'major')
+        self.assertEqual(self.panel._get_axis_name(2), 'minor')
 
     def test_get_plane_axes(self):
         # what to do here?
diff --git a/pandas/core/tests/test_series.py b/pandas/core/tests/test_series.py
index bcc820851..f3a7f9b2e 100644
--- a/pandas/core/tests/test_series.py
+++ b/pandas/core/tests/test_series.py
@@ -11,9 +11,9 @@ import unittest
 import numpy as np
 
 from pandas.core.api import (Index, Series, TimeSeries, DataFrame)
-from pandas.core.tests.common import assert_series_equal
 import pandas.core.datetools as datetools
-import pandas.core.tests.common as common
+from pandas.util.testing import assert_series_equal
+import pandas.util.testing as common
 
 #-------------------------------------------------------------------------------
 # Series test cases
@@ -49,6 +49,9 @@ class TestSeries(unittest.TestCase):
 
         self.assertRaises(Exception, Series, [0, 1, 2], index=None)
 
+        self.assert_(not isinstance(self.empty, TimeSeries))
+        self.assert_(not isinstance(Series({}), TimeSeries))
+
     def test_fromDict(self):
         data = {'a' : 0, 'b' : 1, 'c' : 2, 'd' : 3}
 
diff --git a/pandas/core/tests/test_tseries.py b/pandas/core/tests/test_tseries.py
index d95a92cb0..9add8c449 100644
--- a/pandas/core/tests/test_tseries.py
+++ b/pandas/core/tests/test_tseries.py
@@ -1,6 +1,6 @@
 import unittest
 
-import pandas.core.tests.common as common
+import pandas.util.testing as common
 import pandas.lib.tseries as tseries
 
 class TestUtil(unittest.TestCase):
diff --git a/pandas/lib/src/common.pyx b/pandas/lib/src/common.pyx
index 6e99979e7..340b2748c 100644
--- a/pandas/lib/src/common.pyx
+++ b/pandas/lib/src/common.pyx
@@ -117,6 +117,9 @@ def isAllDates(ndarray index):
     iter = <flatiter> PyArray_IterNew(index)
     length = PyArray_SIZE(index)
 
+    if length == 0:
+        return False
+
     for i from 0 <= i < length:
         date = PyArray_GETITEM(index, PyArray_ITER_DATA(iter))
 
diff --git a/pandas/lib/src/tseries.c b/pandas/lib/src/tseries.c
index c136ab4bb..82c7c461f 100644
--- a/pandas/lib/src/tseries.c
+++ b/pandas/lib/src/tseries.c
@@ -1,4 +1,4 @@
-/* Generated by Cython 0.12.1 on Tue Mar 09 14:38:09 2010 */
+/* Generated by Cython 0.12.1 on Thu Mar 11 17:20:53 2010 */
 
 #define PY_SSIZE_T_CLEAN
 #include "Python.h"
@@ -1753,44 +1753,71 @@ static PyObject *__pyx_pf_7tseries_isAllDates(PyObject *__pyx_self, PyObject *__
  *     iter = <flatiter> PyArray_IterNew(index)
  *     length = PyArray_SIZE(index)             # <<<<<<<<<<<<<<
  * 
- *     for i from 0 <= i < length:
+ *     if length == 0:
  */
   __pyx_v_length = PyArray_SIZE(((PyArrayObject *)__pyx_v_index));
 
   /* "H:\workspace\pandas\pandas\lib\src\common.pyx":120
  *     length = PyArray_SIZE(index)
  * 
+ *     if length == 0:             # <<<<<<<<<<<<<<
+ *         return False
+ * 
+ */
+  __pyx_t_2 = (__pyx_v_length == 0);
+  if (__pyx_t_2) {
+
+    /* "H:\workspace\pandas\pandas\lib\src\common.pyx":121
+ * 
+ *     if length == 0:
+ *         return False             # <<<<<<<<<<<<<<
+ * 
+ *     for i from 0 <= i < length:
+ */
+    __Pyx_XDECREF(__pyx_r);
+    __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __Pyx_GOTREF(__pyx_t_1);
+    __pyx_r = __pyx_t_1;
+    __pyx_t_1 = 0;
+    goto __pyx_L0;
+    goto __pyx_L5;
+  }
+  __pyx_L5:;
+
+  /* "H:\workspace\pandas\pandas\lib\src\common.pyx":123
+ *         return False
+ * 
  *     for i from 0 <= i < length:             # <<<<<<<<<<<<<<
  *         date = PyArray_GETITEM(index, PyArray_ITER_DATA(iter))
  * 
  */
-  __pyx_t_2 = __pyx_v_length;
-  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_2; __pyx_v_i++) {
+  __pyx_t_3 = __pyx_v_length;
+  for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_3; __pyx_v_i++) {
 
-    /* "H:\workspace\pandas\pandas\lib\src\common.pyx":121
+    /* "H:\workspace\pandas\pandas\lib\src\common.pyx":124
  * 
  *     for i from 0 <= i < length:
  *         date = PyArray_GETITEM(index, PyArray_ITER_DATA(iter))             # <<<<<<<<<<<<<<
  * 
  *         if not PyDateTime_Check(date):
  */
-    __pyx_t_1 = PyArray_GETITEM(((PyArrayObject *)__pyx_v_index), PyArray_ITER_DATA(__pyx_v_iter)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 121; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_1 = PyArray_GETITEM(((PyArrayObject *)__pyx_v_index), PyArray_ITER_DATA(__pyx_v_iter)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_1);
     __Pyx_DECREF(__pyx_v_date);
     __pyx_v_date = __pyx_t_1;
     __pyx_t_1 = 0;
 
-    /* "H:\workspace\pandas\pandas\lib\src\common.pyx":123
+    /* "H:\workspace\pandas\pandas\lib\src\common.pyx":126
  *         date = PyArray_GETITEM(index, PyArray_ITER_DATA(iter))
  * 
  *         if not PyDateTime_Check(date):             # <<<<<<<<<<<<<<
  *             return False
  *         PyArray_ITER_NEXT(iter)
  */
-    __pyx_t_3 = (!PyDateTime_Check(__pyx_v_date));
-    if (__pyx_t_3) {
+    __pyx_t_2 = (!PyDateTime_Check(__pyx_v_date));
+    if (__pyx_t_2) {
 
-      /* "H:\workspace\pandas\pandas\lib\src\common.pyx":124
+      /* "H:\workspace\pandas\pandas\lib\src\common.pyx":127
  * 
  *         if not PyDateTime_Check(date):
  *             return False             # <<<<<<<<<<<<<<
@@ -1798,16 +1825,16 @@ static PyObject *__pyx_pf_7tseries_isAllDates(PyObject *__pyx_self, PyObject *__
  * 
  */
       __Pyx_XDECREF(__pyx_r);
-      __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 124; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_1 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_1);
       __pyx_r = __pyx_t_1;
       __pyx_t_1 = 0;
       goto __pyx_L0;
-      goto __pyx_L7;
+      goto __pyx_L8;
     }
-    __pyx_L7:;
+    __pyx_L8:;
 
-    /* "H:\workspace\pandas\pandas\lib\src\common.pyx":125
+    /* "H:\workspace\pandas\pandas\lib\src\common.pyx":128
  *         if not PyDateTime_Check(date):
  *             return False
  *         PyArray_ITER_NEXT(iter)             # <<<<<<<<<<<<<<
@@ -1817,7 +1844,7 @@ static PyObject *__pyx_pf_7tseries_isAllDates(PyObject *__pyx_self, PyObject *__
     PyArray_ITER_NEXT(__pyx_v_iter);
   }
 
-  /* "H:\workspace\pandas\pandas\lib\src\common.pyx":127
+  /* "H:\workspace\pandas\pandas\lib\src\common.pyx":130
  *         PyArray_ITER_NEXT(iter)
  * 
  *     return True             # <<<<<<<<<<<<<<
@@ -1825,7 +1852,7 @@ static PyObject *__pyx_pf_7tseries_isAllDates(PyObject *__pyx_self, PyObject *__
  * def isAllDates2(ndarray[object, ndim=1] arr):
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 127; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
@@ -1846,7 +1873,7 @@ static PyObject *__pyx_pf_7tseries_isAllDates(PyObject *__pyx_self, PyObject *__
   return __pyx_r;
 }
 
-/* "H:\workspace\pandas\pandas\lib\src\common.pyx":129
+/* "H:\workspace\pandas\pandas\lib\src\common.pyx":132
  *     return True
  * 
  * def isAllDates2(ndarray[object, ndim=1] arr):             # <<<<<<<<<<<<<<
@@ -1875,25 +1902,25 @@ static PyObject *__pyx_pf_7tseries_isAllDates2(PyObject *__pyx_self, PyObject *_
   __Pyx_INCREF((PyObject *)__pyx_v_arr);
   __pyx_v_date = Py_None; __Pyx_INCREF(Py_None);
   __pyx_bstruct_arr.buf = NULL;
-  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_arr), __pyx_ptype_5numpy_ndarray, 1, "arr", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_arr), __pyx_ptype_5numpy_ndarray, 1, "arr", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   {
     __Pyx_BufFmt_StackElem __pyx_stack[1];
-    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_arr, (PyObject*)__pyx_v_arr, &__Pyx_TypeInfo_object, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 129; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    if (unlikely(__Pyx_GetBufferAndValidate(&__pyx_bstruct_arr, (PyObject*)__pyx_v_arr, &__Pyx_TypeInfo_object, PyBUF_FORMAT| PyBUF_STRIDES, 1, 0, __pyx_stack) == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   }
   __pyx_bstride_0_arr = __pyx_bstruct_arr.strides[0];
   __pyx_bshape_0_arr = __pyx_bstruct_arr.shape[0];
 
-  /* "H:\workspace\pandas\pandas\lib\src\common.pyx":134
+  /* "H:\workspace\pandas\pandas\lib\src\common.pyx":137
  *     '''
  * 
  *     cdef int i, size = len(arr)             # <<<<<<<<<<<<<<
  *     cdef object date
  * 
  */
-  __pyx_t_1 = PyObject_Length(__pyx_v_arr); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 134; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_1 = PyObject_Length(__pyx_v_arr); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 137; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __pyx_v_size = __pyx_t_1;
 
-  /* "H:\workspace\pandas\pandas\lib\src\common.pyx":137
+  /* "H:\workspace\pandas\pandas\lib\src\common.pyx":140
  *     cdef object date
  * 
  *     if size == 0:             # <<<<<<<<<<<<<<
@@ -1903,7 +1930,7 @@ static PyObject *__pyx_pf_7tseries_isAllDates2(PyObject *__pyx_self, PyObject *_
   __pyx_t_2 = (__pyx_v_size == 0);
   if (__pyx_t_2) {
 
-    /* "H:\workspace\pandas\pandas\lib\src\common.pyx":138
+    /* "H:\workspace\pandas\pandas\lib\src\common.pyx":141
  * 
  *     if size == 0:
  *         return False             # <<<<<<<<<<<<<<
@@ -1911,7 +1938,7 @@ static PyObject *__pyx_pf_7tseries_isAllDates2(PyObject *__pyx_self, PyObject *_
  *     for i from 0 <= i < size:
  */
     __Pyx_XDECREF(__pyx_r);
-    __pyx_t_3 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 138; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+    __pyx_t_3 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     __Pyx_GOTREF(__pyx_t_3);
     __pyx_r = __pyx_t_3;
     __pyx_t_3 = 0;
@@ -1920,7 +1947,7 @@ static PyObject *__pyx_pf_7tseries_isAllDates2(PyObject *__pyx_self, PyObject *_
   }
   __pyx_L5:;
 
-  /* "H:\workspace\pandas\pandas\lib\src\common.pyx":140
+  /* "H:\workspace\pandas\pandas\lib\src\common.pyx":143
  *         return False
  * 
  *     for i from 0 <= i < size:             # <<<<<<<<<<<<<<
@@ -1930,7 +1957,7 @@ static PyObject *__pyx_pf_7tseries_isAllDates2(PyObject *__pyx_self, PyObject *_
   __pyx_t_4 = __pyx_v_size;
   for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_4; __pyx_v_i++) {
 
-    /* "H:\workspace\pandas\pandas\lib\src\common.pyx":141
+    /* "H:\workspace\pandas\pandas\lib\src\common.pyx":144
  * 
  *     for i from 0 <= i < size:
  *         date = arr[i]             # <<<<<<<<<<<<<<
@@ -1945,7 +1972,7 @@ static PyObject *__pyx_pf_7tseries_isAllDates2(PyObject *__pyx_self, PyObject *_
     } else if (unlikely(__pyx_t_5 >= __pyx_bshape_0_arr)) __pyx_t_6 = 0;
     if (unlikely(__pyx_t_6 != -1)) {
       __Pyx_RaiseBufferIndexError(__pyx_t_6);
-      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 141; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
     }
     __pyx_t_3 = *__Pyx_BufPtrStrided1d(PyObject **, __pyx_bstruct_arr.buf, __pyx_t_5, __pyx_bstride_0_arr);
     __Pyx_INCREF((PyObject*)__pyx_t_3);
@@ -1953,7 +1980,7 @@ static PyObject *__pyx_pf_7tseries_isAllDates2(PyObject *__pyx_self, PyObject *_
     __pyx_v_date = __pyx_t_3;
     __pyx_t_3 = 0;
 
-    /* "H:\workspace\pandas\pandas\lib\src\common.pyx":143
+    /* "H:\workspace\pandas\pandas\lib\src\common.pyx":146
  *         date = arr[i]
  * 
  *         if not PyDateTime_Check(date):             # <<<<<<<<<<<<<<
@@ -1963,7 +1990,7 @@ static PyObject *__pyx_pf_7tseries_isAllDates2(PyObject *__pyx_self, PyObject *_
     __pyx_t_2 = (!PyDateTime_Check(__pyx_v_date));
     if (__pyx_t_2) {
 
-      /* "H:\workspace\pandas\pandas\lib\src\common.pyx":144
+      /* "H:\workspace\pandas\pandas\lib\src\common.pyx":147
  * 
  *         if not PyDateTime_Check(date):
  *             return False             # <<<<<<<<<<<<<<
@@ -1971,7 +1998,7 @@ static PyObject *__pyx_pf_7tseries_isAllDates2(PyObject *__pyx_self, PyObject *_
  *     return True
  */
       __Pyx_XDECREF(__pyx_r);
-      __pyx_t_3 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+      __pyx_t_3 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
       __Pyx_GOTREF(__pyx_t_3);
       __pyx_r = __pyx_t_3;
       __pyx_t_3 = 0;
@@ -1981,13 +2008,13 @@ static PyObject *__pyx_pf_7tseries_isAllDates2(PyObject *__pyx_self, PyObject *_
     __pyx_L8:;
   }
 
-  /* "H:\workspace\pandas\pandas\lib\src\common.pyx":146
+  /* "H:\workspace\pandas\pandas\lib\src\common.pyx":149
  *             return False
  * 
  *     return True             # <<<<<<<<<<<<<<
  */
   __Pyx_XDECREF(__pyx_r);
-  __pyx_t_3 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 146; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
+  __pyx_t_3 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 149; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
   __Pyx_GOTREF(__pyx_t_3);
   __pyx_r = __pyx_t_3;
   __pyx_t_3 = 0;
diff --git a/pandas/stats/fama_macbeth.py b/pandas/stats/fama_macbeth.py
index a6dc2ca9f..d78c8dfd9 100644
--- a/pandas/stats/fama_macbeth.py
+++ b/pandas/stats/fama_macbeth.py
@@ -33,16 +33,11 @@ class FamaMacBeth(object):
 
         from pandas.stats.plm import MovingPanelOLS
         self._ols_result = MovingPanelOLS(
-            y=y, x=x, weights=weights,
-            window_type=ROLLING, window=1,
+            y=y, x=x, weights=weights, window_type=ROLLING, window=1,
             intercept=intercept,
-            nw_lags=nw_lags,
-            entity_effects=entity_effects,
-            time_effects=time_effects,
-            x_effects=x_effects,
-            cluster=cluster,
-            dropped_dummies=dropped_dummies,
-            verbose=verbose)
+            nw_lags=nw_lags, entity_effects=entity_effects,
+            time_effects=time_effects, x_effects=x_effects, cluster=cluster,
+            dropped_dummies=dropped_dummies, verbose=verbose)
 
         self._cols = self._ols_result._x.items
 
diff --git a/pandas/stats/ols.py b/pandas/stats/ols.py
index 4d415b9c9..76b19be00 100644
--- a/pandas/stats/ols.py
+++ b/pandas/stats/ols.py
@@ -1,7 +1,8 @@
 """
-Simple OLS.
+Ordinary least squares regression
 """
-from __future__ import division
+
+# pylint: disable-msg=W0201
 
 from itertools import izip, starmap
 from StringIO import StringIO
@@ -499,8 +500,8 @@ class MovingOLS(OLS):
     window: int
         size of window (for rolling/expanding OLS)
     """
-    def __init__(self, y, x, window_type=common.ROLLING,
-                 window=10, min_periods=None, intercept=True,
+    def __init__(self, y, x, window_type='expanding',
+                 window=None, min_periods=None, intercept=True,
                  nw_lags=None, nw_overlap=False):
 
         self._args = dict(intercept=intercept, nw_lags=nw_lags,
@@ -508,12 +509,24 @@ class MovingOLS(OLS):
 
         OLS.__init__(self, y=y, x=x, **self._args)
 
-        self._window = int(window)
+        self._set_window(window_type, window, min_periods)
+
+    def _set_window(self, window_type, window, min_periods):
         self._window_type = common._get_window_type(window_type)
 
-        if min_periods is None:
-            min_periods = window
+        if self._is_rolling:
+            if window is None:
+                raise Exception('Must pass window when doing rolling '
+                                'regression')
+
+            if min_periods is None:
+                min_periods = window
+        else:
+            window = len(self._x)
+            if min_periods is None:
+                min_periods = 1
 
+        self._window = int(window)
         self._min_periods = min_periods
 
 #-------------------------------------------------------------------------------
@@ -557,6 +570,14 @@ class MovingOLS(OLS):
     def f_test(self, hypothesis):
         raise Exception('f_test not supported for rolling/expanding OLS')
 
+    @cache_readonly
+    def forecast_mean(self):
+        return Series(self._forecast_mean_raw, index=self._result_index)
+
+    @cache_readonly
+    def forecast_vol(self):
+        return Series(self._forecast_vol_raw, index=self._result_index)
+
     @cache_readonly
     def p_value(self):
         """Returns the p values."""
@@ -932,6 +953,55 @@ class MovingOLS(OLS):
 
         return np.array(results)
 
+    @cache_readonly
+    def _forecast_mean_raw(self):
+        """Returns the raw covariance of beta."""
+        nobs = self._nobs
+        window = self._window
+
+        # x should be ones
+        dummy = DataMatrix(index=self._y.index)
+        dummy['y'] = 1
+
+        cum_xy = self._cum_xy(dummy, self._y)
+
+        results = []
+        for n, i in enumerate(self._valid_indices):
+            sumy = cum_xy[i]
+
+            if self._is_rolling and i >= window:
+                sumy = sumy - cum_xy[i - window]
+
+            results.append(sumy[0] / nobs[n])
+
+        return np.array(results)
+
+    @cache_readonly
+    def _forecast_vol_raw(self):
+        """Returns the raw covariance of beta."""
+        beta = self._beta_raw
+        window = self._window
+        dates = self._index
+        x = self._x
+
+        results = []
+        for n, i in enumerate(self._valid_indices):
+            date = dates[i]
+            if self._is_rolling and i >= window:
+                prior_date = dates[i - window + 1]
+            else:
+                prior_date = dates[0]
+
+            x_slice = x.truncate(prior_date, date).values
+            x_demeaned = x_slice - x_slice.mean(0)
+            x_cov = np.dot(x_demeaned.T, x_demeaned) / (len(x_slice) - 1)
+
+            B = beta[n]
+            result = np.dot(B, np.dot(x_cov, B))
+            results.append(np.sqrt(result))
+
+        return np.array(results)
+
     @cache_readonly
     def _y_fitted_raw(self):
         """Returns the raw fitted y values."""
diff --git a/pandas/stats/plm.py b/pandas/stats/plm.py
index 5ea57c51a..23e397b9e 100644
--- a/pandas/stats/plm.py
+++ b/pandas/stats/plm.py
@@ -586,7 +586,7 @@ class MovingPanelOLS(MovingOLS, PanelOLS):
         ENTITY or TIME, indicating entity/time clustering
     """
     def __init__(self, y, x, weights=None,
-                 window_type=common.ROLLING, window=10,
+                 window_type='expanding', window=None,
                  min_periods=None,
                  min_obs=None,
                  intercept=True,
@@ -611,13 +611,7 @@ class MovingPanelOLS(MovingOLS, PanelOLS):
 
         PanelOLS.__init__(self, y=y, x=x, **self._args)
 
-        self._window_type = common._get_window_type(window_type)
-        self._window = window
-
-        if min_periods is None:
-            min_periods = window
-
-        self._min_periods = min_periods
+        self._set_window(window_type, window, min_periods)
 
         if min_obs is None:
             min_obs = len(self._x.items) + 1
diff --git a/pandas/stats/tests/common.py b/pandas/stats/tests/common.py
index 2c84c5612..d08411775 100644
--- a/pandas/stats/tests/common.py
+++ b/pandas/stats/tests/common.py
@@ -7,7 +7,7 @@ import unittest
 import numpy as np
 
 from pandas.core.api import DataMatrix, DateRange
-from pandas.core.tests.common import assert_almost_equal
+from pandas.util.testing import assert_almost_equal
 
 N = 100
 K = 4

commit 93c9fb3df578c642763c2279dd90e4dc519771d2
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Sat Apr 28 14:39:30 2012 -0400

    REF: refactoring timegrouper for upsampling

diff --git a/pandas/core/generic.py b/pandas/core/generic.py
index e35110d0e..68244313d 100644
--- a/pandas/core/generic.py
+++ b/pandas/core/generic.py
@@ -159,9 +159,9 @@ class PandasObject(Picklable):
         from pandas.tseries.resample import asfreq
         return asfreq(self, freq, method=method, how=how)
 
-    def resample(self, rule, how='mean', axis=0, as_index=True,
+    def resample(self, rule, how='mean', axis=0,
                  fill_method=None, closed='right', label='right',
-                 convention=None, kind=None, loffset=None):
+                 convention=None, kind=None, loffset=None, limit=None):
         """
         Convenience method for frequency conversion and resampling of regular
         time-series data.
@@ -177,32 +177,15 @@ class PandasObject(Picklable):
         label : {'right', 'left'}, default 'right'
             Which bin edge label to label bucket with
         convention : {'start', 'end', 's', 'e'}
-
-        as_index : see synonymous argument of groupby
         loffset : timedelta
             Adjust the resampled time labels
         """
         from pandas.tseries.resample import TimeGrouper
-
-        if axis != 0:
-            raise NotImplementedError
-
-        grouper = TimeGrouper(rule, label=label, closed=closed,
-                              axis=self._get_axis(axis), kind=kind)
-
-        # since binner extends endpoints
-        if grouper.downsamples:
-            # down- or re-sampling
-            grouped  = self.groupby(grouper, axis=axis, as_index=as_index)
-            result = grouped.agg(how)
-        else:
-            # upsampling
-            result = self.reindex(grouper.binner[1:], method=fill_method)
-
-        if isinstance(loffset, (DateOffset, timedelta)):
-            if len(result.index) > 0:
-                result.index = result.index + loffset
-        return result
+        sampler = TimeGrouper(rule, label=label, closed=closed, how=how,
+                              axis=axis, kind=kind, loffset=loffset,
+                              fill_method=fill_method, convention=convention,
+                              limit=limit)
+        return sampler.resample(self)
 
     def first(self, offset):
         """
diff --git a/pandas/core/groupby.py b/pandas/core/groupby.py
index b4af5d158..ce729dbc2 100644
--- a/pandas/core/groupby.py
+++ b/pandas/core/groupby.py
@@ -4,7 +4,7 @@ import numpy as np
 
 from pandas.core.frame import DataFrame
 from pandas.core.generic import NDFrame
-from pandas.core.index import Index, MultiIndex
+from pandas.core.index import Index, MultiIndex, _ensure_index
 from pandas.core.internals import BlockManager, make_block
 from pandas.core.series import Series
 from pandas.core.panel import Panel
@@ -787,12 +787,18 @@ def generate_bins_generic(values, binner, closed):
     return bins
 
 
+class CustomGrouper(object):
+
+    def get_grouper(self, obj):
+        raise NotImplementedError
+
 
 class BinGrouper(Grouper):
 
-    def __init__(self, bins, binlabels):
+    def __init__(self, bins, binlabels, filter_empty=False):
         self.bins = bins
-        self.binlabels = binlabels
+        self.binlabels = _ensure_index(binlabels)
+        self._filter_empty_groups = filter_empty
 
     @property
     def nkeys(self):
@@ -822,6 +828,18 @@ class BinGrouper(Grouper):
     def ngroups(self):
         return len(self.binlabels)
 
+    @cache_readonly
+    def result_index(self):
+        return self.binlabels
+
+    @property
+    def levels(self):
+        return [self.binlabels]
+
+    @property
+    def names(self):
+        return [self.binlabels.name]
+
     #----------------------------------------------------------------------
     # cython aggregation
 
@@ -1027,9 +1045,9 @@ def _get_grouper(obj, key=None, axis=0, level=None, sort=True):
                 level = None
                 key = group_axis
 
-    if isinstance(key, Grouper):
-        key.set_axis(group_axis)
-        return key, []
+    if isinstance(key, CustomGrouper):
+        gpr = key.get_grouper(obj)
+        return gpr, []
 
     if not isinstance(key, (tuple, list)):
         keys = [key]
diff --git a/pandas/src/period.c b/pandas/src/period.c
index 226c85911..7944e74fb 100644
--- a/pandas/src/period.c
+++ b/pandas/src/period.c
@@ -1,6 +1,6 @@
+#include "period.h"
 #include "limits.h"
 // #include "numpy/ndarraytypes.h"
-#include "period.h"
 
 /*
  * Borrowed and derived code from scikits.timeseries that we will expose via
@@ -962,7 +962,7 @@ int64_t asfreq(int64_t period_ordinal, int freq1, int freq2, char relation)
     int64_t val;
     freq_conv_func func;
     asfreq_info finfo;
-	
+
 	func = get_asfreq_func(freq1, freq2, 0);
     get_asfreq_info(freq1, freq2, &finfo);
 
@@ -1073,7 +1073,7 @@ int64_t get_python_ordinal(int64_t period_ordinal, int freq)
 {
     asfreq_info af_info;
     int64_t (*toDaily)(int64_t, char, asfreq_info*);
-	
+
     if (freq == FR_DAY)
         return period_ordinal;
 
diff --git a/pandas/tseries/frequencies.py b/pandas/tseries/frequencies.py
index 894abd884..59e4279f6 100644
--- a/pandas/tseries/frequencies.py
+++ b/pandas/tseries/frequencies.py
@@ -819,9 +819,9 @@ def _maybe_add_count(base, count):
     else:
         return base
 
-def _is_subperiod(source, target):
+def is_subperiod(source, target):
     """
-    Returns True if conversion/resampling is possible between source and target
+    Returns True if downsampling is possible between source and target
     frequencies
 
     Parameters
@@ -838,25 +838,49 @@ def _is_subperiod(source, target):
     target = target.upper()
     source = source.upper()
     if _is_annual(target):
-        if _is_weekly(source):
-            raise ValueError('Weekly rules do not properly segment '
-                             'a yearly span')
-        if _is_annual(source) and source != target:
-            raise ValueError('Can only be same year end')
         return source in ['D', 'B', 'M', 'H', 'T', 'S']
     elif _is_quarterly(target):
-        pass
         return source in ['D', 'B', 'M', 'H', 'T', 'S']
     elif target == 'M':
-        pass
         return source in ['D', 'B', 'H', 'T', 'S']
     elif _is_weekly(target):
-        return source in ['D', 'B', 'H', 'T', 'S']
+        return source in [target, 'D', 'B', 'H', 'T', 'S']
     elif target == 'B':
         return source in ['B', 'H', 'T', 'S']
     elif target == 'D':
         return source in ['D', 'H', 'T', 'S']
 
+def is_superperiod(source, target):
+    """
+    Returns True if upsampling is possible between source and target
+    frequencies
+
+    Parameters
+    ----------
+    source : string
+        Frequency converting from
+    target : string
+        Frequency converting to
+
+    Returns
+    -------
+    is_superperiod : boolean
+    """
+    target = target.upper()
+    source = source.upper()
+    if _is_annual(source):
+        return target in ['D', 'B', 'M', 'H', 'T', 'S']
+    elif _is_quarterly(source):
+        return target in ['D', 'B', 'M', 'H', 'T', 'S']
+    elif target == 'M':
+        return source in ['D', 'B', 'H', 'T', 'S']
+    elif _is_weekly(source):
+        return source in [target, 'D', 'B', 'H', 'T', 'S']
+    elif target == 'B':
+        return source in ['D', 'B', 'H', 'T', 'S']
+    elif target == 'D':
+        return source not in ['D', 'B', 'H', 'T', 'S']
+
 
 def _is_annual(rule):
     return rule.upper().startswith('A-')
@@ -880,20 +904,10 @@ _weekday_rule_aliases = {
     6: 'SUN'
 }
 
-_month_aliases = {
-    1: 'JAN',
-    2: 'FEB',
-    3: 'MAR',
-    4: 'APR',
-    5: 'MAY',
-    6: 'JUN',
-    7: 'JUL',
-    8: 'AUG',
-    9: 'SEP',
-    10: 'OCT',
-    11: 'NOV',
-    12: 'DEC'
-}
+MONTHS = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL',
+          'AUG', 'SEP', 'OCT', 'NOV', 'DEC']
+
+_month_aliases = dict((k + 1, v) for k, v in enumerate(MONTHS))
 
 def _is_multiple(us, mult):
     return us % mult == 0
diff --git a/pandas/tseries/resample.py b/pandas/tseries/resample.py
index 6aa5d32f0..cb4fcff85 100644
--- a/pandas/tseries/resample.py
+++ b/pandas/tseries/resample.py
@@ -1,7 +1,9 @@
+from datetime import timedelta
+
 import numpy as np
 
-from pandas.core.groupby import BinGrouper
-from pandas.tseries.frequencies import to_offset
+from pandas.core.groupby import BinGrouper, CustomGrouper
+from pandas.tseries.frequencies import to_offset, is_subperiod, is_superperiod
 from pandas.tseries.index import DatetimeIndex, date_range
 from pandas.tseries.offsets import DateOffset
 from pandas.tseries.period import PeriodIndex, period_range
@@ -11,7 +13,8 @@ import pandas.core.common as com
 from pandas._tseries import Timestamp
 import pandas._tseries as lib
 
-class TimeGrouper(BinGrouper):
+
+class TimeGrouper(CustomGrouper):
     """
     Custom groupby class for time-interval grouping
 
@@ -23,145 +26,191 @@ class TimeGrouper(BinGrouper):
     begin : optional, timestamp-like
     end : optional, timestamp-like
     nperiods : optional, integer
+    convention : {'start', 'end', 'e', 's'}
+        If axis is PeriodIndex
 
     Notes
     -----
     Use begin, end, nperiods to generate intervals that cannot be derived
     directly from the associated object
     """
-
-    axis = None
-    bins = None
-    binlabels = None
-    begin = None
-    end = None
-    nperiods = None
-    binner = None
-
-    _filter_empty_groups = False
-
-    def __init__(self, offset='Min', closed='left', label='left',
-                 begin=None, end=None, nperiods=None, axis=None,
-                 kind=None):
-        self.freq = offset
+    def __init__(self, freq='Min', closed='right', label='right', how='mean',
+                 begin=None, end=None, nperiods=None, axis=0,
+                 fill_method=None, limit=None, loffset=None, kind=None,
+                 convention=None):
+        self.freq = freq
         self.closed = closed
         self.label = label
         self.begin = begin
         self.end = end
-        self.nperiods = None
+        self.nperiods = nperiods
         self.kind = kind
+        self.convention = convention or 'E'
+        self.axis = axis
+        self.loffset = loffset
+        self.how = how
+        self.fill_method = fill_method
+        self.limit = limit
 
-        if axis is not None:
-            self.set_axis(axis)
+        if axis != 0:
+            raise NotImplementedError
 
-    def set_axis(self, axis):
-        """
-        Injects the axisect we'll act on, which we use to initialize grouper
-        """
-        if id(self.axis) == id(axis):
-            return
+    def resample(self, obj):
+        axis = obj._get_axis(self.axis)
+        if isinstance(axis, DatetimeIndex):
+            return self._resample_timestamps(obj)
+        elif isinstance(axis, PeriodIndex):
+            return self._resample_periods(obj)
+        else:
+            raise TypeError('Only valid with DatetimeIndex or PeriodIndex')
 
-        if not isinstance(axis, (DatetimeIndex, PeriodIndex)):
-            raise ValueError('Only valid with DatetimeIndex or PeriodIndex')
+    def get_grouper(self, obj):
+        # Only return grouper
+        return self._get_time_grouper(obj)[1]
 
-        self.axis = axis
+    def _get_time_grouper(self, obj):
+        axis = obj._get_axis(self.axis)
+
+        if self.kind is None or self.kind == 'timestamp':
+            binner, bins, binlabels = self._get_time_bins(axis)
+            grouper = BinGrouper(bins, binlabels)
+        else:
+            index = binner = PeriodIndex(start=axis[0], end=axis[-1],
+                                         freq=self.freq)
+
+            end_stamps = (index + 1).asfreq('D', 's').to_timestamp()
+            bins = axis.searchsorted(end_stamps, side='left')
+
+            grouper = BinGrouper(bins, index)
+
+        return binner, grouper
+
+    def _get_time_bins(self, axis):
+        return _make_time_bins(axis, self.freq, begin=self.begin,
+                               end=self.end, nperiods=self.nperiods,
+                               closed=self.closed, label=self.label)
+
+    def _resample_timestamps(self, obj):
+        axis = obj._get_axis(self.axis)
 
-        if len(self.axis) < 1:
-            # TODO: Should we be a bit more careful here?
-            self.bins = []
-            self.binlabels = []
-            return
+        binner, grouper = self._get_time_grouper(obj)
 
-        if isinstance(self.axis, DatetimeIndex):
-            self.binner, self.bins, self.binlabels = self._group_timestamps()
-        elif isinstance(self.axis, PeriodIndex):
-            self.binner, self.bins, self.binlabels = self._group_periods()
+        # downsamples
+        if len(grouper.binlabels) < len(axis):
+            grouped  = obj.groupby(grouper, axis=axis)
+            result = grouped.agg(self.how)
         else:
-            raise ValueError('Invalid index: %s' % type(self.axis))
+            assert(axis == 0)
+            # upsampling
 
-    def _group_timestamps(self):
-        if self.kind is None or self.kind == 'timestamp':
-            binner = self._generate_time_binner()
-
-            # a little hack
-            trimmed = False
-            if len(binner) > 2 and binner[-2] == self.axis[-1]:
-                binner = binner[:-1]
-                trimmed = True
-
-            # general version, knowing nothing about relative frequencies
-            bins = lib.generate_bins_dt64(self.axis.asi8, binner.asi8,
-                                          self.closed)
-
-            if self.label == 'right':
-                labels = binner[1:]
-            elif not trimmed:
-                labels = binner[:-1]
-            else:
-                labels = binner
+            # this is sort of a hack
+            result = obj.reindex(binner[1:], method=self.fill_method)
 
-            return binner, bins, labels
-        elif self.kind == 'period':
-            index = PeriodIndex(start=self.axis[0], end=self.axis[-1],
-                                freq=self.freq)
+        if isinstance(self.loffset, (DateOffset, timedelta)):
+            if (isinstance(result.index, DatetimeIndex)
+                and len(result.index) > 0):
 
-            end_stamps = (index + 1).asfreq('D', 's').to_timestamp()
-            bins = self.axis.searchsorted(end_stamps, side='left')
+                result.index = result.index + self.loffset
 
-            return index, bins, index
+        return result
 
-    def _group_periods(self):
-        if self.kind is None or self.kind == 'period':
-            # Start vs. end of period
-            memb = self.axis.asfreq(self.freq)
+    def _resample_periods(self, obj):
+        axis = obj._get_axis(self.axis)
 
+        # Start vs. end of period
+        memb = axis.asfreq(self.freq, how=self.convention)
+
+        if is_subperiod(self.axis.freq, self.freq):
+            # Downsampling
             if len(memb) > 1:
-                rng = np.arange(memb.values[0], memb.values[-1] + 1)
+                rng = np.arange(memb.values[0], memb.values[-1])
                 bins = memb.searchsorted(rng, side='right')
             else:
                 bins = np.array([], dtype=np.int32)
 
             index = period_range(memb[0], memb[-1], freq=self.freq)
-            return index, bins, index
+            grouper = BinGrouper(bins, index)
+
+            grouped = obj.groupby(grouper, axis=axis)
+            return grouped.agg(self.how)
+        elif is_superperiod(self.axis.freq, self.freq):
+            # Generate full range
+            new_index = period_range(memb[0], memb[-1], freq=self.freq)
+
+            # Get the fill indexer
+            indexer = memb.get_indexer(new_index, method=self.fill_method,
+                                       limit=self.limit)
+
+            return _take_new_index(obj, indexer, new_index, axis=self.axis)
         else:
-            # Convert to timestamps
-            pass
+            raise ValueError('Frequency %s cannot be resampled to %s'
+                             % (self.axis.freq, self.freq))
+
+
+def _take_new_index(obj, indexer, new_index, axis=0):
+    from pandas.core.api import Series, DataFrame
+    from pandas.core.internals import BlockManager
+
+    if isinstance(obj, Series):
+        new_values = com.take_1d(obj.values, indexer)
+        return Series(new_values, index=new_index, name=obj.name)
+    elif isinstance(obj, DataFrame):
+        if axis == 1:
+            raise NotImplementedError
+        data = obj._data
+
+        new_blocks = [b.take(indexer, axis=1) for b in data.blocks]
+        new_axes = list(data.axes)
+        new_axes[1] = new_index
+        new_data = BlockManager(new_blocks, new_axes)
+        return DataFrame(new_data)
+    else:
+        raise NotImplementedError
 
-    def _generate_time_binner(self):
-        offset = self.freq
-        if isinstance(offset, basestring):
-            offset = to_offset(offset)
 
-        if not isinstance(offset, DateOffset):
-            raise ValueError("Rule not a recognized offset")
+def _make_period_bins(axis, freq):
+    index = PeriodIndex(start=axis[0], end=axis[-1], freq=freq)
+    end_stamps = (index + 1).asfreq('D', 's').to_timestamp()
+    bins = axis.searchsorted(end_stamps, side='left')
 
-        first, last = _get_range_edges(self.axis, self.begin, self.end,
-                                       offset, closed=self.closed)
-        binner = DatetimeIndex(freq=offset, start=first, end=last,
-                               periods=self.nperiods)
+    return index, bins, index
 
-        return binner
 
-    @property
-    def downsamples(self):
-        return len(self.binlabels) < len(self.axis)
+def _make_time_bins(axis, freq, begin=None, end=None, nperiods=None,
+                    closed='right', label='right'):
+    assert(isinstance(axis, DatetimeIndex))
 
-    @property
-    def names(self):
-        return [self.axis.name]
+    if len(axis) == 0:
+        # TODO: Should we be a bit more careful here?
+        return [], [], []
 
-    @property
-    def levels(self):
-        return [self.binlabels]
+    if isinstance(freq, basestring):
+        freq = to_offset(freq)
 
-    @cache_readonly
-    def ngroups(self):
-        return len(self.binlabels)
+    if not isinstance(freq, DateOffset):
+        raise ValueError("Rule not a recognized offset")
 
-    @cache_readonly
-    def result_index(self):
-        return self.binlabels
+    first, last = _get_range_edges(axis, begin, end, freq, closed=closed)
+    binner = DatetimeIndex(freq=freq, start=first, end=last,
+                           periods=nperiods)
+
+    # a little hack
+    trimmed = False
+    if len(binner) > 2 and binner[-2] == axis[-1]:
+        binner = binner[:-1]
+        trimmed = True
+
+    # general version, knowing nothing about relative frequencies
+    bins = lib.generate_bins_dt64(axis.asi8, binner.asi8, closed)
+
+    if label == 'right':
+        labels = binner[1:]
+    elif not trimmed:
+        labels = binner[:-1]
+    else:
+        labels = binner
 
+    return binner, bins, labels
 
 def _get_range_edges(axis, begin, end, offset, closed='left'):
     if begin is None:
diff --git a/pandas/tseries/tests/test_resample.py b/pandas/tseries/tests/test_resample.py
index 58c5fd3b2..fa7c17cea 100644
--- a/pandas/tseries/tests/test_resample.py
+++ b/pandas/tseries/tests/test_resample.py
@@ -273,24 +273,67 @@ def _simple_pts(start, end, freq='D'):
     return Series(np.random.randn(len(rng)), index=rng)
 
 
+from pandas.tseries.frequencies import MONTHS
+from pandas.util.compat import product
+
 class TestResamplePeriodIndex(unittest.TestCase):
 
-    def test_basic_resample(self):
+    def test_basic_downsample(self):
         ts = _simple_pts('1/1/1990', '6/30/1995', freq='M')
         result = ts.resample('a-dec')
+
         expected = ts.groupby(ts.index.year).mean()
         expected.index = period_range('1/1/1990', '6/30/1995',
                                       freq='a-dec')
         assert_series_equal(result, expected)
 
-    def test_upsample_ffill(self):
+        # this is ok
+        assert_series_equal(ts.resample('a-dec'), result)
+
+    def test_not_subperiod(self):
+        # These are incompatible period rules for resampling
+        ts = _simple_pts('1/1/1990', '6/30/1995', freq='w-wed')
+        self.assertRaises(ValueError, ts.resample, 'a-dec')
+        self.assertRaises(ValueError, ts.resample, 'q-mar')
+        self.assertRaises(ValueError, ts.resample, 'M')
+        self.assertRaises(ValueError, ts.resample, 'w-thu')
+
+    def test_basic_upsample(self):
         ts = _simple_pts('1/1/1990', '6/30/1995', freq='M')
         result = ts.resample('a-dec')
 
-        resampled = result.resample('D', fill_method='ffill',
-                                    convention='end')
+        resampled = result.resample('D', fill_method='ffill', convention='end')
+
+        expected = result.to_timestamp('D', how='end')
+        expected = expected.asfreq('D', 'ffill').to_period()
+
+        assert_series_equal(resampled, expected)
+
+    def test_annual_upsample(self):
+        targets = ['D', 'B', 'M']
+
+        for month in MONTHS:
+            ts = _simple_pts('1/1/1990', '12/31/1995', freq='A-%s' % month)
+
+            for targ, conv, meth in product(targets, ['start', 'end'],
+                                            ['ffill', 'bfill']):
+                result = ts.resample(targ, fill_method=meth,
+                                     convention=conv)
+                expected = result.to_timestamp(targ, how=conv)
+                expected = expected.asfreq(targ, meth).to_period()
+                assert_series_equal(result, expected)
+
+    def test_quarterly_upsample(self):
+        pass
+
+    def test_monthly_upsample(self):
+        pass
+
+    def test_weekly_upsample(self):
+        pass
 
-        # expected = result.
+    def test_resampl_to_timestamps(self):
+        pass
 
 
 class TestTimeGrouper(unittest.TestCase):
diff --git a/pandas/tseries/tests/test_timeseries.py b/pandas/tseries/tests/test_timeseries.py
index 16a430826..07e616180 100644
--- a/pandas/tseries/tests/test_timeseries.py
+++ b/pandas/tseries/tests/test_timeseries.py
@@ -26,7 +26,6 @@ import cPickle as pickle
 import pandas.core.datetools as dt
 from numpy.random import rand
 from pandas.util.testing import assert_frame_equal
-from pandas.tseries.resample import TimeGrouper
 from pandas.core.datetools import BDay
 import pandas.core.common as com
 

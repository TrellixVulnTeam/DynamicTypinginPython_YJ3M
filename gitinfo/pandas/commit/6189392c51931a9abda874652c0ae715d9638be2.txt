commit 6189392c51931a9abda874652c0ae715d9638be2
Author: Chang She <chang@lambdafoundry.com>
Date:   Mon May 7 16:08:11 2012 -0400

    DOC: DateRange -> date_range in Sphinx docs

diff --git a/doc/source/basics.rst b/doc/source/basics.rst
index 180e9b930..c038f5e95 100644
--- a/doc/source/basics.rst
+++ b/doc/source/basics.rst
@@ -19,12 +19,12 @@ the previous section:
 
 .. ipython:: python
 
-   index = DateRange('1/1/2000', periods=8)
+   index = date_range('1/1/2000', periods=8)
    s = Series(randn(5), index=['a', 'b', 'c', 'd', 'e'])
    df = DataFrame(randn(8, 3), index=index,
                   columns=['A', 'B', 'C'])
    wp = Panel(randn(2, 5, 4), items=['Item1', 'Item2'],
-              major_axis=DateRange('1/1/2000', periods=5),
+              major_axis=date_range('1/1/2000', periods=5),
               minor_axis=['A', 'B', 'C', 'D'])
 
 .. _basics.head_tail:
@@ -385,7 +385,7 @@ maximum value for each column occurred:
 .. ipython:: python
 
    tsdf = DataFrame(randn(1000, 3), columns=['A', 'B', 'C'],
-                    index=DateRange('1/1/2000', periods=1000))
+                    index=date_range('1/1/2000', periods=1000))
    tsdf.apply(lambda x: x.index[x.dropna().argmax()])
 
 You may also pass additional arguments and keyword arguments to the ``apply``
@@ -409,7 +409,7 @@ Series operation on each column or row:
    :suppress:
 
    tsdf = DataFrame(randn(10, 3), columns=['A', 'B', 'C'],
-                    index=DateRange('1/1/2000', periods=10))
+                    index=date_range('1/1/2000', periods=10))
    tsdf.values[3:7] = np.nan
 
 .. ipython:: python
@@ -622,7 +622,7 @@ We illustrate these fill methods on a simple TimeSeries:
 
 .. ipython:: python
 
-   rng = DateRange('1/3/2000', periods=8)
+   rng = date_range('1/3/2000', periods=8)
    ts = Series(randn(8), index=rng)
    ts2 = ts[[0, 3, 6]]
    ts
diff --git a/doc/source/computation.rst b/doc/source/computation.rst
index 2a1aed6fe..ac7b7e79e 100644
--- a/doc/source/computation.rst
+++ b/doc/source/computation.rst
@@ -180,7 +180,7 @@ These functions can be applied to ndarrays or Series objects:
 
 .. ipython:: python
 
-   ts = Series(randn(1000), index=DateRange('1/1/2000', periods=1000))
+   ts = Series(randn(1000), index=date_range('1/1/2000', periods=1000))
    ts = ts.cumsum()
 
    ts.plot(style='k--')
diff --git a/doc/source/dsintro.rst b/doc/source/dsintro.rst
index 99876d66c..83a8feee8 100644
--- a/doc/source/dsintro.rst
+++ b/doc/source/dsintro.rst
@@ -475,7 +475,7 @@ column-wise:
 
 .. ipython:: python
 
-   index = DateRange('1/1/2000', periods=8)
+   index = date_range('1/1/2000', periods=8)
    df = DataFrame(randn(8, 3), index=index,
                   columns=['A', 'B', 'C'])
    df
@@ -653,7 +653,7 @@ From 3D ndarray with optional axis labels
 .. ipython:: python
 
    wp = Panel(randn(2, 5, 4), items=['Item1', 'Item2'],
-              major_axis=DateRange('1/1/2000', periods=5),
+              major_axis=date_range('1/1/2000', periods=5),
               minor_axis=['A', 'B', 'C', 'D'])
    wp
 
@@ -782,6 +782,6 @@ method:
 .. ipython:: python
 
    panel = Panel(np.random.randn(3, 5, 4), items=['one', 'two', 'three'],
-                 major_axis=DateRange('1/1/2000', periods=5),
+                 major_axis=date_range('1/1/2000', periods=5),
                  minor_axis=['a', 'b', 'c', 'd'])
    panel.to_frame()
diff --git a/doc/source/groupby.rst b/doc/source/groupby.rst
index 07ae26a71..dc5c9e938 100644
--- a/doc/source/groupby.rst
+++ b/doc/source/groupby.rst
@@ -499,7 +499,7 @@ next). This enables some operations to be carried out rather succinctly:
 .. ipython:: python
 
    tsdf = DataFrame(randn(1000, 3),
-                    index=DateRange('1/1/2000', periods=1000),
+                    index=date_range('1/1/2000', periods=1000),
                     columns=['A', 'B', 'C'])
    tsdf.ix[::2] = np.nan
    grouped = tsdf.groupby(lambda x: x.year)
diff --git a/doc/source/index.rst b/doc/source/index.rst
old mode 100755
new mode 100644
diff --git a/doc/source/indexing.rst b/doc/source/indexing.rst
index f8c10c2e1..82023cf5f 100644
--- a/doc/source/indexing.rst
+++ b/doc/source/indexing.rst
@@ -52,7 +52,7 @@ indexing functionality:
 
 .. ipython:: python
 
-   dates = np.asarray(DateRange('1/1/2000', periods=8))
+   dates = np.asarray(date_range('1/1/2000', periods=8))
    df = DataFrame(randn(8, 4), index=dates, columns=['A', 'B', 'C', 'D'])
    df
    panel = Panel({'one' : df, 'two' : df - df.mean()})
@@ -969,7 +969,7 @@ containers for the axis labels:
   - ``Int64Index``: a version of ``Index`` highly optimized for 64-bit integer
     data, such as time stamps
   - ``MultiIndex``: the standard hierarchical index object
-  - ``DateRange``: fixed frequency date range generated from a time rule or
+  - ``date_range``: fixed frequency date range generated from a time rule or
     DateOffset. An ndarray of Python datetime objects
 
 The motivation for having an ``Index`` class in the first place was to enable
diff --git a/doc/source/install.rst b/doc/source/install.rst
index 14179c004..c9e03695d 100644
--- a/doc/source/install.rst
+++ b/doc/source/install.rst
@@ -44,7 +44,7 @@ Optional dependencies
   * `scikits.statsmodels <http://statsmodels.sourceforge.net/>`__
      * Needed for parts of :mod:`pandas.stats`
   * `pytz <http://pytz.sourceforge.net/>`__
-     * Needed for time zone support with ``DateRange``
+     * Needed for time zone support with ``date_range``
 
 .. note::
 
diff --git a/doc/source/io.rst b/doc/source/io.rst
index 109f99f3b..98a69ba50 100644
--- a/doc/source/io.rst
+++ b/doc/source/io.rst
@@ -453,12 +453,12 @@ Objects can be written to the file just like adding key-value pairs to a dict:
 
 .. ipython:: python
 
-   index = DateRange('1/1/2000', periods=8)
+   index = date_range('1/1/2000', periods=8)
    s = Series(randn(5), index=['a', 'b', 'c', 'd', 'e'])
    df = DataFrame(randn(8, 3), index=index,
                   columns=['A', 'B', 'C'])
    wp = Panel(randn(2, 5, 4), items=['Item1', 'Item2'],
-              major_axis=DateRange('1/1/2000', periods=5),
+              major_axis=date_range('1/1/2000', periods=5),
               minor_axis=['A', 'B', 'C', 'D'])
 
    store['s'] = s
diff --git a/doc/source/merging.rst b/doc/source/merging.rst
index 1deff7fa9..a8152643d 100644
--- a/doc/source/merging.rst
+++ b/doc/source/merging.rst
@@ -162,7 +162,7 @@ need to be:
 
 .. ipython:: python
 
-   df = DataFrame(randn(6, 4), index=DateRange('1/1/2000', periods=6),
+   df = DataFrame(randn(6, 4), index=date_range('1/1/2000', periods=6),
                   columns=['A', 'B', 'C', 'D'])
    df1 = df.ix[:3]
    df2 = df.ix[3:, :3]
diff --git a/doc/source/missing_data.rst b/doc/source/missing_data.rst
index 493492121..d724938c2 100644
--- a/doc/source/missing_data.rst
+++ b/doc/source/missing_data.rst
@@ -204,7 +204,7 @@ for interpolation methods outside of the filling methods described above.
    :suppress:
 
    np.random.seed(123456)
-   ts = Series(randn(100), index=DateRange('1/1/2000', periods=100,
+   ts = Series(randn(100), index=date_range('1/1/2000', periods=100,
                                            timeRule='EOM'))
    ts[20:40] = np.nan
    ts[60:80] = np.nan
diff --git a/doc/source/overview.rst b/doc/source/overview.rst
index 15efbdf62..4d891d38f 100644
--- a/doc/source/overview.rst
+++ b/doc/source/overview.rst
@@ -13,7 +13,7 @@ Package overview
  * Index objects enabling both simple axis indexing and multi-level /
    hierarchical axis indexing
  * An integrated group by engine for aggregating and transforming data sets
- * Date range generation (DateRange) and custom date offsets enabling the
+ * Date range generation (date_range) and custom date offsets enabling the
    implementation of customized frequencies
  * Input/Output tools: loading tabular data from flat files (CSV, delimited,
    Excel 2003), and saving and loading pandas objects from the fast and
diff --git a/doc/source/timeseries.rst b/doc/source/timeseries.rst
index 8dbfa25dd..e409a1a64 100644
--- a/doc/source/timeseries.rst
+++ b/doc/source/timeseries.rst
@@ -249,10 +249,10 @@ alias parsing is case sensitive.
 
 .. _timeseries.daterange:
 
-Generating date ranges (DateRange)
+Generating date ranges (date_range)
 ----------------------------------
 
-The ``DateRange`` class utilizes these offsets (and any ones that we might add)
+The ``date_range`` class utilizes these offsets (and any ones that we might add)
 to generate fixed-frequency date ranges:
 
 .. ipython:: python
@@ -260,49 +260,49 @@ to generate fixed-frequency date ranges:
    start = datetime(2009, 1, 1)
    end = datetime(2010, 1, 1)
 
-   rng = DateRange(start, end, offset=BDay())
+   rng = date_range(start, end, offset=BDay())
    rng
-   DateRange(start, end, offset=BMonthEnd())
+   date_range(start, end, offset=BMonthEnd())
 
-**Business day frequency** is the default for ``DateRange``. You can also
-strictly generate a ``DateRange`` of a certain length by providing either a
+**Business day frequency** is the default for ``date_range``. You can also
+strictly generate a ``date_range`` of a certain length by providing either a
 start or end date and a ``periods`` argument:
 
 .. ipython:: python
 
-   DateRange(start, periods=20)
-   DateRange(end=end, periods=20)
+   date_range(start, periods=20)
+   date_range(end=end, periods=20)
 
 The start and end dates are strictly inclusive. So it will not generate any
 dates outside of those dates if specified.
 
-DateRange is a valid Index
+date_range is a valid Index
 ~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-One of the main uses for ``DateRange`` is as an index for pandas objects. When
+One of the main uses for ``date_range`` is as an index for pandas objects. When
 working with a lot of time series data, there are several reasons to use
-``DateRange`` objects when possible:
+``date_range`` objects when possible:
 
   - A large range of dates for various offsets are pre-computed and cached
     under the hood in order to make generating subsequent date ranges very fast
     (just have to grab a slice)
   - Fast shifting using the ``shift`` method on pandas objects
-  - Unioning of overlapping DateRange objects with the same frequency is very
+  - Unioning of overlapping date_range objects with the same frequency is very
     fast (important for fast data alignment)
 
-The ``DateRange`` is a valid index and can even be intelligent when doing
+The ``date_range`` is a valid index and can even be intelligent when doing
 slicing, etc.
 
 .. ipython:: python
 
-   rng = DateRange(start, end, offset=BMonthEnd())
+   rng = date_range(start, end, offset=BMonthEnd())
    ts = Series(randn(len(rng)), index=rng)
    ts.index
    ts[:5].index
    ts[::2].index
 
 More complicated fancy indexing will result in an ``Index`` that is no longer a
-``DateRange``, however:
+``date_range``, however:
 
 .. ipython:: python
 
@@ -347,11 +347,11 @@ Frequency conversion
 
 The primary function for changing frequencies is the ``asfreq`` function. This
 is basically just a thin, but convenient wrapper around ``reindex`` which
-generates a ``DateRange`` and calls ``reindex``.
+generates a ``date_range`` and calls ``reindex``.
 
 .. ipython:: python
 
-   dr = DateRange('1/1/2010', periods=3, offset=3 * datetools.bday)
+   dr = date_range('1/1/2010', periods=3, offset=3 * datetools.bday)
    ts = Series(randn(3), index=dr)
    ts
    ts.asfreq(BDay())
@@ -373,16 +373,16 @@ extremely common in, but not limited to, financial applications.
 Until then, your best bet is a clever (or kludgy, depending on your point of
 view) application of GroupBy. Carry out the following steps:
 
-1. Generate the target ``DateRange`` of interest
+1. Generate the target ``date_range`` of interest
 
 .. code-block:: python
 
-   dr1hour = DateRange(start, end, offset=Hour())
-   dr5day = DateRange(start, end, offset=5 * datetools.day)
-   dr10day = DateRange(start, end, offset=10 * datetools.day)
+   dr1hour = date_range(start, end, offset=Hour())
+   dr5day = date_range(start, end, offset=5 * datetools.day)
+   dr10day = date_range(start, end, offset=10 * datetools.day)
 
 
-2. Use the ``asof`` function ("as of") of the DateRange to do a groupby
+2. Use the ``asof`` function ("as of") of the date_range to do a groupby
    expression
 
 .. code-block:: python
@@ -395,12 +395,12 @@ Here is a fully-worked example:
 .. ipython:: python
 
    # some minutely data
-   minutely = DateRange('1/3/2000 00:00:00', '1/3/2000 12:00:00',
+   minutely = date_range('1/3/2000 00:00:00', '1/3/2000 12:00:00',
                         offset=datetools.Minute())
    ts = Series(randn(len(minutely)), index=minutely)
    ts.index
 
-   hourly = DateRange('1/3/2000', '1/4/2000', offset=datetools.Hour())
+   hourly = date_range('1/3/2000', '1/4/2000', offset=datetools.Hour())
 
    grouped = ts.groupby(hourly.asof)
    grouped.mean()
diff --git a/doc/source/visualization.rst b/doc/source/visualization.rst
index 7c1885730..be969f379 100644
--- a/doc/source/visualization.rst
+++ b/doc/source/visualization.rst
@@ -38,7 +38,7 @@ The ``plot`` method on Series and DataFrame is just a simple wrapper around
 
 .. ipython:: python
 
-   ts = Series(randn(1000), index=DateRange('1/1/2000', periods=1000))
+   ts = Series(randn(1000), index=date_range('1/1/2000', periods=1000))
    ts = ts.cumsum()
 
    @savefig series_plot_basic.png width=4.5in
@@ -85,7 +85,7 @@ You may pass ``logy`` to get a log-scale Y axis.
 
    plt.figure();
 
-   ts = Series(randn(1000), index=DateRange('1/1/2000', periods=1000))
+   ts = Series(randn(1000), index=date_range('1/1/2000', periods=1000))
    ts = np.exp(ts.cumsum())
 
    @savefig series_plot_logy.png width=4.5in

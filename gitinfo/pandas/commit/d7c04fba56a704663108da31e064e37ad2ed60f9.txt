commit d7c04fba56a704663108da31e064e37ad2ed60f9
Author: jbrockmendel <jbrockmendel@gmail.com>
Date:   Tue Nov 7 05:09:47 2017 -0800

    Index tests indexing (#18145)

diff --git a/pandas/tests/indexes/datetimes/test_datetime.py b/pandas/tests/indexes/datetimes/test_datetime.py
index cc6eeb44c..36f691903 100644
--- a/pandas/tests/indexes/datetimes/test_datetime.py
+++ b/pandas/tests/indexes/datetimes/test_datetime.py
@@ -410,89 +410,6 @@ class TestDatetimeIndex(object):
         assert ordered[::-1].is_monotonic
         tm.assert_numpy_array_equal(dexer, np.array([0, 2, 1], dtype=np.intp))
 
-    def test_take(self):
-        dates = [datetime(2010, 1, 1, 14), datetime(2010, 1, 1, 15),
-                 datetime(2010, 1, 1, 17), datetime(2010, 1, 1, 21)]
-
-        for tz in [None, 'US/Eastern', 'Asia/Tokyo']:
-            idx = DatetimeIndex(start='2010-01-01 09:00',
-                                end='2010-02-01 09:00', freq='H', tz=tz,
-                                name='idx')
-            expected = DatetimeIndex(dates, freq=None, name='idx', tz=tz)
-
-            taken1 = idx.take([5, 6, 8, 12])
-            taken2 = idx[[5, 6, 8, 12]]
-
-            for taken in [taken1, taken2]:
-                tm.assert_index_equal(taken, expected)
-                assert isinstance(taken, DatetimeIndex)
-                assert taken.freq is None
-                assert taken.tz == expected.tz
-                assert taken.name == expected.name
-
-    def test_take_fill_value(self):
-        # GH 12631
-        idx = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
-                               name='xxx')
-        result = idx.take(np.array([1, 0, -1]))
-        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
-                                    name='xxx')
-        tm.assert_index_equal(result, expected)
-
-        # fill_value
-        result = idx.take(np.array([1, 0, -1]), fill_value=True)
-        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', 'NaT'],
-                                    name='xxx')
-        tm.assert_index_equal(result, expected)
-
-        # allow_fill=False
-        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
-                          fill_value=True)
-        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
-                                    name='xxx')
-        tm.assert_index_equal(result, expected)
-
-        msg = ('When allow_fill=True and fill_value is not None, '
-               'all indices must be >= -1')
-        with tm.assert_raises_regex(ValueError, msg):
-            idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assert_raises_regex(ValueError, msg):
-            idx.take(np.array([1, 0, -5]), fill_value=True)
-
-        with pytest.raises(IndexError):
-            idx.take(np.array([1, -5]))
-
-    def test_take_fill_value_with_timezone(self):
-        idx = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
-                               name='xxx', tz='US/Eastern')
-        result = idx.take(np.array([1, 0, -1]))
-        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
-                                    name='xxx', tz='US/Eastern')
-        tm.assert_index_equal(result, expected)
-
-        # fill_value
-        result = idx.take(np.array([1, 0, -1]), fill_value=True)
-        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', 'NaT'],
-                                    name='xxx', tz='US/Eastern')
-        tm.assert_index_equal(result, expected)
-
-        # allow_fill=False
-        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
-                          fill_value=True)
-        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
-                                    name='xxx', tz='US/Eastern')
-        tm.assert_index_equal(result, expected)
-
-        msg = ('When allow_fill=True and fill_value is not None, '
-               'all indices must be >= -1')
-        with tm.assert_raises_regex(ValueError, msg):
-            idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assert_raises_regex(ValueError, msg):
-            idx.take(np.array([1, 0, -5]), fill_value=True)
-
-        with pytest.raises(IndexError):
-            idx.take(np.array([1, -5]))
-
     def test_map_bug_1677(self):
         index = DatetimeIndex(['2012-04-25 09:30:00.393000'])
         f = index.asof
diff --git a/pandas/tests/indexes/datetimes/test_indexing.py b/pandas/tests/indexes/datetimes/test_indexing.py
index 9416b08f9..4ce9441d8 100644
--- a/pandas/tests/indexes/datetimes/test_indexing.py
+++ b/pandas/tests/indexes/datetimes/test_indexing.py
@@ -1,3 +1,4 @@
+from datetime import datetime
 import pytest
 
 import pytz
@@ -5,7 +6,10 @@ import numpy as np
 import pandas as pd
 import pandas.util.testing as tm
 import pandas.compat as compat
-from pandas import notna, Index, DatetimeIndex, datetime, date_range
+from pandas import notna, Index, DatetimeIndex, date_range, Timestamp
+from pandas.tseries.offsets import CDay, BDay
+
+START, END = datetime(2009, 1, 1), datetime(2010, 1, 1)
 
 
 class TestDatetimeIndex(object):
@@ -239,3 +243,234 @@ class TestDatetimeIndex(object):
             assert result.name == expected.name
             assert result.freq == expected.freq
             assert result.tz == expected.tz
+
+    def test_getitem(self):
+        idx1 = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
+        idx2 = pd.date_range('2011-01-01', '2011-01-31', freq='D',
+                             tz='Asia/Tokyo', name='idx')
+
+        for idx in [idx1, idx2]:
+            result = idx[0]
+            assert result == Timestamp('2011-01-01', tz=idx.tz)
+
+            result = idx[0:5]
+            expected = pd.date_range('2011-01-01', '2011-01-05', freq='D',
+                                     tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx[0:10:2]
+            expected = pd.date_range('2011-01-01', '2011-01-09', freq='2D',
+                                     tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx[-20:-5:3]
+            expected = pd.date_range('2011-01-12', '2011-01-24', freq='3D',
+                                     tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx[4::-1]
+            expected = DatetimeIndex(['2011-01-05', '2011-01-04', '2011-01-03',
+                                      '2011-01-02', '2011-01-01'],
+                                     freq='-1D', tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+    def test_take(self):
+        # GH 10295
+        idx1 = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
+        idx2 = pd.date_range('2011-01-01', '2011-01-31', freq='D',
+                             tz='Asia/Tokyo', name='idx')
+
+        for idx in [idx1, idx2]:
+            result = idx.take([0])
+            assert result == Timestamp('2011-01-01', tz=idx.tz)
+
+            result = idx.take([0, 1, 2])
+            expected = pd.date_range('2011-01-01', '2011-01-03', freq='D',
+                                     tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx.take([0, 2, 4])
+            expected = pd.date_range('2011-01-01', '2011-01-05', freq='2D',
+                                     tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx.take([7, 4, 1])
+            expected = pd.date_range('2011-01-08', '2011-01-02', freq='-3D',
+                                     tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx.take([3, 2, 5])
+            expected = DatetimeIndex(['2011-01-04', '2011-01-03',
+                                      '2011-01-06'],
+                                     freq=None, tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq is None
+
+            result = idx.take([-3, 2, 5])
+            expected = DatetimeIndex(['2011-01-29', '2011-01-03',
+                                      '2011-01-06'],
+                                     freq=None, tz=idx.tz, name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq is None
+
+    def test_take_invalid_kwargs(self):
+        idx = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
+        indices = [1, 6, 5, 9, 10, 13, 15, 3]
+
+        msg = r"take\(\) got an unexpected keyword argument 'foo'"
+        tm.assert_raises_regex(TypeError, msg, idx.take,
+                               indices, foo=2)
+
+        msg = "the 'out' parameter is not supported"
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, out=indices)
+
+        msg = "the 'mode' parameter is not supported"
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, mode='clip')
+
+    # TODO: This method came from test_datetime; de-dup with version above
+    def test_take2(self):
+        dates = [datetime(2010, 1, 1, 14), datetime(2010, 1, 1, 15),
+                 datetime(2010, 1, 1, 17), datetime(2010, 1, 1, 21)]
+
+        for tz in [None, 'US/Eastern', 'Asia/Tokyo']:
+            idx = DatetimeIndex(start='2010-01-01 09:00',
+                                end='2010-02-01 09:00', freq='H', tz=tz,
+                                name='idx')
+            expected = DatetimeIndex(dates, freq=None, name='idx', tz=tz)
+
+            taken1 = idx.take([5, 6, 8, 12])
+            taken2 = idx[[5, 6, 8, 12]]
+
+            for taken in [taken1, taken2]:
+                tm.assert_index_equal(taken, expected)
+                assert isinstance(taken, DatetimeIndex)
+                assert taken.freq is None
+                assert taken.tz == expected.tz
+                assert taken.name == expected.name
+
+    def test_take_fill_value(self):
+        # GH 12631
+        idx = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
+                               name='xxx')
+        result = idx.take(np.array([1, 0, -1]))
+        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
+                                    name='xxx')
+        tm.assert_index_equal(result, expected)
+
+        # fill_value
+        result = idx.take(np.array([1, 0, -1]), fill_value=True)
+        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', 'NaT'],
+                                    name='xxx')
+        tm.assert_index_equal(result, expected)
+
+        # allow_fill=False
+        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
+                          fill_value=True)
+        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
+                                    name='xxx')
+        tm.assert_index_equal(result, expected)
+
+        msg = ('When allow_fill=True and fill_value is not None, '
+               'all indices must be >= -1')
+        with tm.assert_raises_regex(ValueError, msg):
+            idx.take(np.array([1, 0, -2]), fill_value=True)
+        with tm.assert_raises_regex(ValueError, msg):
+            idx.take(np.array([1, 0, -5]), fill_value=True)
+
+        with pytest.raises(IndexError):
+            idx.take(np.array([1, -5]))
+
+    def test_take_fill_value_with_timezone(self):
+        idx = pd.DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01'],
+                               name='xxx', tz='US/Eastern')
+        result = idx.take(np.array([1, 0, -1]))
+        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
+                                    name='xxx', tz='US/Eastern')
+        tm.assert_index_equal(result, expected)
+
+        # fill_value
+        result = idx.take(np.array([1, 0, -1]), fill_value=True)
+        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', 'NaT'],
+                                    name='xxx', tz='US/Eastern')
+        tm.assert_index_equal(result, expected)
+
+        # allow_fill=False
+        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
+                          fill_value=True)
+        expected = pd.DatetimeIndex(['2011-02-01', '2011-01-01', '2011-03-01'],
+                                    name='xxx', tz='US/Eastern')
+        tm.assert_index_equal(result, expected)
+
+        msg = ('When allow_fill=True and fill_value is not None, '
+               'all indices must be >= -1')
+        with tm.assert_raises_regex(ValueError, msg):
+            idx.take(np.array([1, 0, -2]), fill_value=True)
+        with tm.assert_raises_regex(ValueError, msg):
+            idx.take(np.array([1, 0, -5]), fill_value=True)
+
+        with pytest.raises(IndexError):
+            idx.take(np.array([1, -5]))
+
+
+class TestBusinessDatetimeIndexIndexing(object):
+    def setup_method(self, method):
+        self.rng = pd.bdate_range(START, END)
+
+    def test_getitem(self):
+        smaller = self.rng[:5]
+        exp = DatetimeIndex(self.rng.view(np.ndarray)[:5])
+        tm.assert_index_equal(smaller, exp)
+
+        assert smaller.offset == self.rng.offset
+
+        sliced = self.rng[::5]
+        assert sliced.offset == BDay() * 5
+
+        fancy_indexed = self.rng[[4, 3, 2, 1, 0]]
+        assert len(fancy_indexed) == 5
+        assert isinstance(fancy_indexed, DatetimeIndex)
+        assert fancy_indexed.freq is None
+
+        # 32-bit vs. 64-bit platforms
+        assert self.rng[4] == self.rng[np.int_(4)]
+
+    def test_getitem_matplotlib_hackaround(self):
+        values = self.rng[:, None]
+        expected = self.rng.values[:, None]
+        tm.assert_numpy_array_equal(values, expected)
+
+
+class TestCustomDatetimeIndexIndexing(object):
+    def setup_method(self, method):
+        self.rng = pd.bdate_range(START, END, freq='C')
+
+    def test_getitem(self):
+        smaller = self.rng[:5]
+        exp = DatetimeIndex(self.rng.view(np.ndarray)[:5])
+        tm.assert_index_equal(smaller, exp)
+        assert smaller.offset == self.rng.offset
+
+        sliced = self.rng[::5]
+        assert sliced.offset == CDay() * 5
+
+        fancy_indexed = self.rng[[4, 3, 2, 1, 0]]
+        assert len(fancy_indexed) == 5
+        assert isinstance(fancy_indexed, DatetimeIndex)
+        assert fancy_indexed.freq is None
+
+        # 32-bit vs. 64-bit platforms
+        assert self.rng[4] == self.rng[np.int_(4)]
+
+    def test_getitem_matplotlib_hackaround(self):
+        values = self.rng[:, None]
+        expected = self.rng.values[:, None]
+        tm.assert_numpy_array_equal(values, expected)
diff --git a/pandas/tests/indexes/datetimes/test_ops.py b/pandas/tests/indexes/datetimes/test_ops.py
index 6e66e4a36..9e4f8d979 100644
--- a/pandas/tests/indexes/datetimes/test_ops.py
+++ b/pandas/tests/indexes/datetimes/test_ops.py
@@ -537,40 +537,6 @@ class TestDatetimeIndexOps(Ops):
                 tm.assert_numpy_array_equal(indexer, exp, check_dtype=False)
                 assert ordered.freq is None
 
-    def test_getitem(self):
-        idx1 = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
-        idx2 = pd.date_range('2011-01-01', '2011-01-31', freq='D',
-                             tz='Asia/Tokyo', name='idx')
-
-        for idx in [idx1, idx2]:
-            result = idx[0]
-            assert result == Timestamp('2011-01-01', tz=idx.tz)
-
-            result = idx[0:5]
-            expected = pd.date_range('2011-01-01', '2011-01-05', freq='D',
-                                     tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx[0:10:2]
-            expected = pd.date_range('2011-01-01', '2011-01-09', freq='2D',
-                                     tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx[-20:-5:3]
-            expected = pd.date_range('2011-01-12', '2011-01-24', freq='3D',
-                                     tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx[4::-1]
-            expected = DatetimeIndex(['2011-01-05', '2011-01-04', '2011-01-03',
-                                      '2011-01-02', '2011-01-01'],
-                                     freq='-1D', tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
     def test_drop_duplicates_metadata(self):
         # GH 10115
         idx = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
@@ -605,64 +571,6 @@ class TestDatetimeIndexOps(Ops):
         res = Series(idx).drop_duplicates(keep=False)
         tm.assert_series_equal(res, Series(base[5:], index=np.arange(5, 31)))
 
-    def test_take(self):
-        # GH 10295
-        idx1 = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
-        idx2 = pd.date_range('2011-01-01', '2011-01-31', freq='D',
-                             tz='Asia/Tokyo', name='idx')
-
-        for idx in [idx1, idx2]:
-            result = idx.take([0])
-            assert result == Timestamp('2011-01-01', tz=idx.tz)
-
-            result = idx.take([0, 1, 2])
-            expected = pd.date_range('2011-01-01', '2011-01-03', freq='D',
-                                     tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx.take([0, 2, 4])
-            expected = pd.date_range('2011-01-01', '2011-01-05', freq='2D',
-                                     tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx.take([7, 4, 1])
-            expected = pd.date_range('2011-01-08', '2011-01-02', freq='-3D',
-                                     tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx.take([3, 2, 5])
-            expected = DatetimeIndex(['2011-01-04', '2011-01-03',
-                                      '2011-01-06'],
-                                     freq=None, tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq is None
-
-            result = idx.take([-3, 2, 5])
-            expected = DatetimeIndex(['2011-01-29', '2011-01-03',
-                                      '2011-01-06'],
-                                     freq=None, tz=idx.tz, name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq is None
-
-    def test_take_invalid_kwargs(self):
-        idx = pd.date_range('2011-01-01', '2011-01-31', freq='D', name='idx')
-        indices = [1, 6, 5, 9, 10, 13, 15, 3]
-
-        msg = r"take\(\) got an unexpected keyword argument 'foo'"
-        tm.assert_raises_regex(TypeError, msg, idx.take,
-                               indices, foo=2)
-
-        msg = "the 'out' parameter is not supported"
-        tm.assert_raises_regex(ValueError, msg, idx.take,
-                               indices, out=indices)
-
-        msg = "the 'mode' parameter is not supported"
-        tm.assert_raises_regex(ValueError, msg, idx.take,
-                               indices, mode='clip')
-
     def test_infer_freq(self):
         # GH 11018
         for freq in ['A', '2A', '-2A', 'Q', '-1Q', 'M', '-1M', 'D', '3D',
@@ -792,29 +700,6 @@ class TestBusinessDatetimeIndex(object):
         # only really care that it works
         repr(self.rng)
 
-    def test_getitem(self):
-        smaller = self.rng[:5]
-        exp = DatetimeIndex(self.rng.view(np.ndarray)[:5])
-        tm.assert_index_equal(smaller, exp)
-
-        assert smaller.offset == self.rng.offset
-
-        sliced = self.rng[::5]
-        assert sliced.offset == BDay() * 5
-
-        fancy_indexed = self.rng[[4, 3, 2, 1, 0]]
-        assert len(fancy_indexed) == 5
-        assert isinstance(fancy_indexed, DatetimeIndex)
-        assert fancy_indexed.freq is None
-
-        # 32-bit vs. 64-bit platforms
-        assert self.rng[4] == self.rng[np.int_(4)]
-
-    def test_getitem_matplotlib_hackaround(self):
-        values = self.rng[:, None]
-        expected = self.rng.values[:, None]
-        tm.assert_numpy_array_equal(values, expected)
-
     def test_shift(self):
         shifted = self.rng.shift(5)
         assert shifted[0] == self.rng[5]
@@ -864,7 +749,6 @@ class TestBusinessDatetimeIndex(object):
 
 
 class TestCustomDatetimeIndex(object):
-
     def setup_method(self, method):
         self.rng = bdate_range(START, END, freq='C')
 
@@ -884,28 +768,6 @@ class TestCustomDatetimeIndex(object):
         # only really care that it works
         repr(self.rng)
 
-    def test_getitem(self):
-        smaller = self.rng[:5]
-        exp = DatetimeIndex(self.rng.view(np.ndarray)[:5])
-        tm.assert_index_equal(smaller, exp)
-        assert smaller.offset == self.rng.offset
-
-        sliced = self.rng[::5]
-        assert sliced.offset == CDay() * 5
-
-        fancy_indexed = self.rng[[4, 3, 2, 1, 0]]
-        assert len(fancy_indexed) == 5
-        assert isinstance(fancy_indexed, DatetimeIndex)
-        assert fancy_indexed.freq is None
-
-        # 32-bit vs. 64-bit platforms
-        assert self.rng[4] == self.rng[np.int_(4)]
-
-    def test_getitem_matplotlib_hackaround(self):
-        values = self.rng[:, None]
-        expected = self.rng.values[:, None]
-        tm.assert_numpy_array_equal(values, expected)
-
     def test_shift(self):
 
         shifted = self.rng.shift(5)
diff --git a/pandas/tests/indexes/period/test_indexing.py b/pandas/tests/indexes/period/test_indexing.py
index 3d6fba982..1d44a4bd9 100644
--- a/pandas/tests/indexes/period/test_indexing.py
+++ b/pandas/tests/indexes/period/test_indexing.py
@@ -1,4 +1,4 @@
-from datetime import datetime
+from datetime import datetime, timedelta
 
 import pytest
 
@@ -9,6 +9,7 @@ from pandas.compat import lrange
 from pandas._libs import tslib, tslibs
 from pandas import (PeriodIndex, Series, DatetimeIndex,
                     period_range, Period)
+from pandas._libs import period as libperiod
 
 
 class TestGetItem(object):
@@ -504,3 +505,98 @@ class TestIndexing(object):
 
         tm.assert_numpy_array_equal(result[0], expected_indexer)
         tm.assert_numpy_array_equal(result[1], expected_missing)
+
+    # TODO: This method came from test_period; de-dup with version above
+    def test_get_loc2(self):
+        idx = pd.period_range('2000-01-01', periods=3)
+
+        for method in [None, 'pad', 'backfill', 'nearest']:
+            assert idx.get_loc(idx[1], method) == 1
+            assert idx.get_loc(idx[1].asfreq('H', how='start'), method) == 1
+            assert idx.get_loc(idx[1].to_timestamp(), method) == 1
+            assert idx.get_loc(idx[1].to_timestamp()
+                               .to_pydatetime(), method) == 1
+            assert idx.get_loc(str(idx[1]), method) == 1
+
+        idx = pd.period_range('2000-01-01', periods=5)[::2]
+        assert idx.get_loc('2000-01-02T12', method='nearest',
+                           tolerance='1 day') == 1
+        assert idx.get_loc('2000-01-02T12', method='nearest',
+                           tolerance=pd.Timedelta('1D')) == 1
+        assert idx.get_loc('2000-01-02T12', method='nearest',
+                           tolerance=np.timedelta64(1, 'D')) == 1
+        assert idx.get_loc('2000-01-02T12', method='nearest',
+                           tolerance=timedelta(1)) == 1
+        with tm.assert_raises_regex(ValueError,
+                                    'unit abbreviation w/o a number'):
+            idx.get_loc('2000-01-10', method='nearest', tolerance='foo')
+
+        msg = 'Input has different freq from PeriodIndex\\(freq=D\\)'
+        with tm.assert_raises_regex(ValueError, msg):
+            idx.get_loc('2000-01-10', method='nearest', tolerance='1 hour')
+        with pytest.raises(KeyError):
+            idx.get_loc('2000-01-10', method='nearest', tolerance='1 day')
+        with pytest.raises(
+                ValueError,
+                match='list-like tolerance size must match target index size'):
+            idx.get_loc('2000-01-10', method='nearest',
+                        tolerance=[pd.Timedelta('1 day').to_timedelta64(),
+                                   pd.Timedelta('1 day').to_timedelta64()])
+
+    # TODO: This method came from test_period; de-dup with version above
+    def test_get_indexer2(self):
+        idx = pd.period_range('2000-01-01', periods=3).asfreq('H', how='start')
+        tm.assert_numpy_array_equal(idx.get_indexer(idx),
+                                    np.array([0, 1, 2], dtype=np.intp))
+
+        target = pd.PeriodIndex(['1999-12-31T23', '2000-01-01T12',
+                                 '2000-01-02T01'], freq='H')
+        tm.assert_numpy_array_equal(idx.get_indexer(target, 'pad'),
+                                    np.array([-1, 0, 1], dtype=np.intp))
+        tm.assert_numpy_array_equal(idx.get_indexer(target, 'backfill'),
+                                    np.array([0, 1, 2], dtype=np.intp))
+        tm.assert_numpy_array_equal(idx.get_indexer(target, 'nearest'),
+                                    np.array([0, 1, 1], dtype=np.intp))
+        tm.assert_numpy_array_equal(idx.get_indexer(target, 'nearest',
+                                                    tolerance='1 hour'),
+                                    np.array([0, -1, 1], dtype=np.intp))
+
+        msg = 'Input has different freq from PeriodIndex\\(freq=H\\)'
+        with tm.assert_raises_regex(ValueError, msg):
+            idx.get_indexer(target, 'nearest', tolerance='1 minute')
+
+        tm.assert_numpy_array_equal(idx.get_indexer(target, 'nearest',
+                                                    tolerance='1 day'),
+                                    np.array([0, 1, 1], dtype=np.intp))
+        tol_raw = [pd.Timedelta('1 hour'),
+                   pd.Timedelta('1 hour'),
+                   np.timedelta64(1, 'D'), ]
+        tm.assert_numpy_array_equal(
+            idx.get_indexer(target, 'nearest',
+                            tolerance=[np.timedelta64(x) for x in tol_raw]),
+            np.array([0, -1, 1], dtype=np.intp))
+        tol_bad = [pd.Timedelta('2 hour').to_timedelta64(),
+                   pd.Timedelta('1 hour').to_timedelta64(),
+                   np.timedelta64(1, 'M'), ]
+        with pytest.raises(
+                libperiod.IncompatibleFrequency,
+                match='Input has different freq from'):
+            idx.get_indexer(target, 'nearest', tolerance=tol_bad)
+
+    def test_indexing(self):
+        # GH 4390, iat incorrectly indexing
+        index = period_range('1/1/2001', periods=10)
+        s = Series(np.random.randn(10), index=index)
+        expected = s[index[0]]
+        result = s.iat[0]
+        assert expected == result
+
+    def test_period_index_indexer(self):
+        # GH4125
+        idx = pd.period_range('2002-01', '2003-12', freq='M')
+        df = pd.DataFrame(pd.np.random.randn(24, 10), index=idx)
+        tm.assert_frame_equal(df, df.loc[idx])
+        tm.assert_frame_equal(df, df.loc[list(idx)])
+        tm.assert_frame_equal(df, df.loc[list(idx)])
+        tm.assert_frame_equal(df.iloc[0:5], df.loc[idx[0:5]])
+        tm.assert_frame_equal(df, df.loc[list(idx)])
diff --git a/pandas/tests/indexes/period/test_period.py b/pandas/tests/indexes/period/test_period.py
index ae500e663..e5ee078d3 100644
--- a/pandas/tests/indexes/period/test_period.py
+++ b/pandas/tests/indexes/period/test_period.py
@@ -1,15 +1,12 @@
 import pytest
 
 import numpy as np
-from numpy.random import randn
-from datetime import timedelta
 
 import pandas as pd
 from pandas.util import testing as tm
 from pandas import (PeriodIndex, period_range, notna, DatetimeIndex, NaT,
                     Index, Period, Int64Index, Series, DataFrame, date_range,
                     offsets, compat)
-from pandas.core.indexes.period import IncompatibleFrequency
 
 from ..datetimelike import DatetimeLike
 
@@ -64,42 +61,6 @@ class TestPeriodIndex(DatetimeLike):
             result = tm.round_trip_pickle(idx)
             tm.assert_index_equal(result, idx)
 
-    def test_get_loc(self):
-        idx = pd.period_range('2000-01-01', periods=3)
-
-        for method in [None, 'pad', 'backfill', 'nearest']:
-            assert idx.get_loc(idx[1], method) == 1
-            assert idx.get_loc(idx[1].asfreq('H', how='start'), method) == 1
-            assert idx.get_loc(idx[1].to_timestamp(), method) == 1
-            assert idx.get_loc(idx[1].to_timestamp()
-                               .to_pydatetime(), method) == 1
-            assert idx.get_loc(str(idx[1]), method) == 1
-
-        idx = pd.period_range('2000-01-01', periods=5)[::2]
-        assert idx.get_loc('2000-01-02T12', method='nearest',
-                           tolerance='1 day') == 1
-        assert idx.get_loc('2000-01-02T12', method='nearest',
-                           tolerance=pd.Timedelta('1D')) == 1
-        assert idx.get_loc('2000-01-02T12', method='nearest',
-                           tolerance=np.timedelta64(1, 'D')) == 1
-        assert idx.get_loc('2000-01-02T12', method='nearest',
-                           tolerance=timedelta(1)) == 1
-        with tm.assert_raises_regex(ValueError,
-                                    'unit abbreviation w/o a number'):
-            idx.get_loc('2000-01-10', method='nearest', tolerance='foo')
-
-        msg = 'Input has different freq from PeriodIndex\\(freq=D\\)'
-        with tm.assert_raises_regex(ValueError, msg):
-            idx.get_loc('2000-01-10', method='nearest', tolerance='1 hour')
-        with pytest.raises(KeyError):
-            idx.get_loc('2000-01-10', method='nearest', tolerance='1 day')
-        with pytest.raises(
-                ValueError,
-                match='list-like tolerance size must match target index size'):
-            idx.get_loc('2000-01-10', method='nearest',
-                        tolerance=[pd.Timedelta('1 day').to_timedelta64(),
-                                   pd.Timedelta('1 day').to_timedelta64()])
-
     def test_where(self):
         i = self.create_index()
         result = i.where(notna(i))
@@ -142,45 +103,6 @@ class TestPeriodIndex(DatetimeLike):
         result = i.where(notna(i2), i2.values)
         tm.assert_index_equal(result, i2)
 
-    def test_get_indexer(self):
-        idx = pd.period_range('2000-01-01', periods=3).asfreq('H', how='start')
-        tm.assert_numpy_array_equal(idx.get_indexer(idx),
-                                    np.array([0, 1, 2], dtype=np.intp))
-
-        target = pd.PeriodIndex(['1999-12-31T23', '2000-01-01T12',
-                                 '2000-01-02T01'], freq='H')
-        tm.assert_numpy_array_equal(idx.get_indexer(target, 'pad'),
-                                    np.array([-1, 0, 1], dtype=np.intp))
-        tm.assert_numpy_array_equal(idx.get_indexer(target, 'backfill'),
-                                    np.array([0, 1, 2], dtype=np.intp))
-        tm.assert_numpy_array_equal(idx.get_indexer(target, 'nearest'),
-                                    np.array([0, 1, 1], dtype=np.intp))
-        tm.assert_numpy_array_equal(idx.get_indexer(target, 'nearest',
-                                                    tolerance='1 hour'),
-                                    np.array([0, -1, 1], dtype=np.intp))
-
-        msg = 'Input has different freq from PeriodIndex\\(freq=H\\)'
-        with tm.assert_raises_regex(ValueError, msg):
-            idx.get_indexer(target, 'nearest', tolerance='1 minute')
-
-        tm.assert_numpy_array_equal(idx.get_indexer(target, 'nearest',
-                                                    tolerance='1 day'),
-                                    np.array([0, 1, 1], dtype=np.intp))
-        tol_raw = [pd.Timedelta('1 hour'),
-                   pd.Timedelta('1 hour'),
-                   np.timedelta64(1, 'D'), ]
-        tm.assert_numpy_array_equal(
-            idx.get_indexer(target, 'nearest',
-                            tolerance=[np.timedelta64(x) for x in tol_raw]),
-            np.array([0, -1, 1], dtype=np.intp))
-        tol_bad = [pd.Timedelta('2 hour').to_timedelta64(),
-                   pd.Timedelta('1 hour').to_timedelta64(),
-                   np.timedelta64(1, 'M'), ]
-        with pytest.raises(
-                IncompatibleFrequency,
-                match='Input has different freq from'):
-            idx.get_indexer(target, 'nearest', tolerance=tol_bad)
-
     def test_repeat(self):
         # GH10183
         idx = pd.period_range('2000-01-01', periods=3, freq='D')
@@ -189,16 +111,6 @@ class TestPeriodIndex(DatetimeLike):
         tm.assert_index_equal(res, exp)
         assert res.freqstr == 'D'
 
-    def test_period_index_indexer(self):
-        # GH4125
-        idx = pd.period_range('2002-01', '2003-12', freq='M')
-        df = pd.DataFrame(pd.np.random.randn(24, 10), index=idx)
-        tm.assert_frame_equal(df, df.loc[idx])
-        tm.assert_frame_equal(df, df.loc[list(idx)])
-        tm.assert_frame_equal(df, df.loc[list(idx)])
-        tm.assert_frame_equal(df.iloc[0:5], df.loc[idx[0:5]])
-        tm.assert_frame_equal(df, df.loc[list(idx)])
-
     def test_fillna_period(self):
         # GH 11343
         idx = pd.PeriodIndex(['2011-01-01 09:00', pd.NaT,
@@ -437,15 +349,6 @@ class TestPeriodIndex(DatetimeLike):
             for x, val in zip(periods, field_s):
                 assert getattr(x, field) == val
 
-    def test_indexing(self):
-
-        # GH 4390, iat incorrectly indexing
-        index = period_range('1/1/2001', periods=10)
-        s = Series(randn(10), index=index)
-        expected = s[index[0]]
-        result = s.iat[0]
-        assert expected == result
-
     def test_period_set_index_reindex(self):
         # GH 6631
         df = DataFrame(np.random.random(6))
diff --git a/pandas/tests/indexes/timedeltas/test_indexing.py b/pandas/tests/indexes/timedeltas/test_indexing.py
index 844033cc1..cb88bac63 100644
--- a/pandas/tests/indexes/timedeltas/test_indexing.py
+++ b/pandas/tests/indexes/timedeltas/test_indexing.py
@@ -1,7 +1,9 @@
-import pytest
-
 from datetime import timedelta
 
+import pytest
+import numpy as np
+
+import pandas as pd
 import pandas.util.testing as tm
 from pandas import TimedeltaIndex, timedelta_range, compat, Index, Timedelta
 
@@ -110,3 +112,197 @@ class TestTimedeltaIndex(object):
             tm.assert_index_equal(result, expected)
             assert result.name == expected.name
             assert result.freq == expected.freq
+
+    def test_getitem(self):
+        idx1 = timedelta_range('1 day', '31 day', freq='D', name='idx')
+
+        for idx in [idx1]:
+            result = idx[0]
+            assert result == Timedelta('1 day')
+
+            result = idx[0:5]
+            expected = timedelta_range('1 day', '5 day', freq='D',
+                                       name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx[0:10:2]
+            expected = timedelta_range('1 day', '9 day', freq='2D',
+                                       name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx[-20:-5:3]
+            expected = timedelta_range('12 day', '24 day', freq='3D',
+                                       name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx[4::-1]
+            expected = TimedeltaIndex(['5 day', '4 day', '3 day',
+                                       '2 day', '1 day'],
+                                      freq='-1D', name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+    def test_take(self):
+        # GH 10295
+        idx1 = timedelta_range('1 day', '31 day', freq='D', name='idx')
+
+        for idx in [idx1]:
+            result = idx.take([0])
+            assert result == Timedelta('1 day')
+
+            result = idx.take([-1])
+            assert result == Timedelta('31 day')
+
+            result = idx.take([0, 1, 2])
+            expected = timedelta_range('1 day', '3 day', freq='D',
+                                       name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx.take([0, 2, 4])
+            expected = timedelta_range('1 day', '5 day', freq='2D',
+                                       name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx.take([7, 4, 1])
+            expected = timedelta_range('8 day', '2 day', freq='-3D',
+                                       name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq == expected.freq
+
+            result = idx.take([3, 2, 5])
+            expected = TimedeltaIndex(['4 day', '3 day', '6 day'], name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq is None
+
+            result = idx.take([-3, 2, 5])
+            expected = TimedeltaIndex(['29 day', '3 day', '6 day'], name='idx')
+            tm.assert_index_equal(result, expected)
+            assert result.freq is None
+
+    def test_take_invalid_kwargs(self):
+        idx = timedelta_range('1 day', '31 day', freq='D', name='idx')
+        indices = [1, 6, 5, 9, 10, 13, 15, 3]
+
+        msg = r"take\(\) got an unexpected keyword argument 'foo'"
+        tm.assert_raises_regex(TypeError, msg, idx.take,
+                               indices, foo=2)
+
+        msg = "the 'out' parameter is not supported"
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, out=indices)
+
+        msg = "the 'mode' parameter is not supported"
+        tm.assert_raises_regex(ValueError, msg, idx.take,
+                               indices, mode='clip')
+
+    # TODO: This method came from test_timedelta; de-dup with version above
+    def test_take2(self):
+        tds = ['1day 02:00:00', '1 day 04:00:00', '1 day 10:00:00']
+        idx = TimedeltaIndex(start='1d', end='2d', freq='H', name='idx')
+        expected = TimedeltaIndex(tds, freq=None, name='idx')
+
+        taken1 = idx.take([2, 4, 10])
+        taken2 = idx[[2, 4, 10]]
+
+        for taken in [taken1, taken2]:
+            tm.assert_index_equal(taken, expected)
+            assert isinstance(taken, TimedeltaIndex)
+            assert taken.freq is None
+            assert taken.name == expected.name
+
+    def test_take_fill_value(self):
+        # GH 12631
+        idx = TimedeltaIndex(['1 days', '2 days', '3 days'],
+                             name='xxx')
+        result = idx.take(np.array([1, 0, -1]))
+        expected = TimedeltaIndex(['2 days', '1 days', '3 days'],
+                                  name='xxx')
+        tm.assert_index_equal(result, expected)
+
+        # fill_value
+        result = idx.take(np.array([1, 0, -1]), fill_value=True)
+        expected = TimedeltaIndex(['2 days', '1 days', 'NaT'],
+                                  name='xxx')
+        tm.assert_index_equal(result, expected)
+
+        # allow_fill=False
+        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
+                          fill_value=True)
+        expected = TimedeltaIndex(['2 days', '1 days', '3 days'],
+                                  name='xxx')
+        tm.assert_index_equal(result, expected)
+
+        msg = ('When allow_fill=True and fill_value is not None, '
+               'all indices must be >= -1')
+        with tm.assert_raises_regex(ValueError, msg):
+            idx.take(np.array([1, 0, -2]), fill_value=True)
+        with tm.assert_raises_regex(ValueError, msg):
+            idx.take(np.array([1, 0, -5]), fill_value=True)
+
+        with pytest.raises(IndexError):
+            idx.take(np.array([1, -5]))
+
+    def test_get_loc(self):
+        idx = pd.to_timedelta(['0 days', '1 days', '2 days'])
+
+        for method in [None, 'pad', 'backfill', 'nearest']:
+            assert idx.get_loc(idx[1], method) == 1
+            assert idx.get_loc(idx[1].to_pytimedelta(), method) == 1
+            assert idx.get_loc(str(idx[1]), method) == 1
+
+        assert idx.get_loc(idx[1], 'pad',
+                           tolerance=Timedelta(0)) == 1
+        assert idx.get_loc(idx[1], 'pad',
+                           tolerance=np.timedelta64(0, 's')) == 1
+        assert idx.get_loc(idx[1], 'pad',
+                           tolerance=timedelta(0)) == 1
+
+        with tm.assert_raises_regex(ValueError,
+                                    'unit abbreviation w/o a number'):
+            idx.get_loc(idx[1], method='nearest', tolerance='foo')
+
+        with pytest.raises(
+                ValueError,
+                match='tolerance size must match'):
+            idx.get_loc(idx[1], method='nearest',
+                        tolerance=[Timedelta(0).to_timedelta64(),
+                                   Timedelta(0).to_timedelta64()])
+
+        for method, loc in [('pad', 1), ('backfill', 2), ('nearest', 1)]:
+            assert idx.get_loc('1 day 1 hour', method) == loc
+
+        # GH 16909
+        assert idx.get_loc(idx[1].to_timedelta64()) == 1
+
+        # GH 16896
+        assert idx.get_loc('0 days') == 0
+
+    def test_get_loc_nat(self):
+        tidx = TimedeltaIndex(['1 days 01:00:00', 'NaT', '2 days 01:00:00'])
+
+        assert tidx.get_loc(pd.NaT) == 1
+        assert tidx.get_loc(None) == 1
+        assert tidx.get_loc(float('nan')) == 1
+        assert tidx.get_loc(np.nan) == 1
+
+    def test_get_indexer(self):
+        idx = pd.to_timedelta(['0 days', '1 days', '2 days'])
+        tm.assert_numpy_array_equal(idx.get_indexer(idx),
+                                    np.array([0, 1, 2], dtype=np.intp))
+
+        target = pd.to_timedelta(['-1 hour', '12 hours', '1 day 1 hour'])
+        tm.assert_numpy_array_equal(idx.get_indexer(target, 'pad'),
+                                    np.array([-1, 0, 1], dtype=np.intp))
+        tm.assert_numpy_array_equal(idx.get_indexer(target, 'backfill'),
+                                    np.array([0, 1, 2], dtype=np.intp))
+        tm.assert_numpy_array_equal(idx.get_indexer(target, 'nearest'),
+                                    np.array([0, 1, 1], dtype=np.intp))
+
+        res = idx.get_indexer(target, 'nearest',
+                              tolerance=Timedelta('1 hour'))
+        tm.assert_numpy_array_equal(res, np.array([0, -1, 1], dtype=np.intp))
diff --git a/pandas/tests/indexes/timedeltas/test_ops.py b/pandas/tests/indexes/timedeltas/test_ops.py
index ff52afea2..67238665a 100644
--- a/pandas/tests/indexes/timedeltas/test_ops.py
+++ b/pandas/tests/indexes/timedeltas/test_ops.py
@@ -358,38 +358,6 @@ dtype: timedelta64[ns]"""
             tm.assert_numpy_array_equal(indexer, exp, check_dtype=False)
             assert ordered.freq is None
 
-    def test_getitem(self):
-        idx1 = pd.timedelta_range('1 day', '31 day', freq='D', name='idx')
-
-        for idx in [idx1]:
-            result = idx[0]
-            assert result == pd.Timedelta('1 day')
-
-            result = idx[0:5]
-            expected = pd.timedelta_range('1 day', '5 day', freq='D',
-                                          name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx[0:10:2]
-            expected = pd.timedelta_range('1 day', '9 day', freq='2D',
-                                          name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx[-20:-5:3]
-            expected = pd.timedelta_range('12 day', '24 day', freq='3D',
-                                          name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx[4::-1]
-            expected = TimedeltaIndex(['5 day', '4 day', '3 day',
-                                       '2 day', '1 day'],
-                                      freq='-1D', name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
     def test_drop_duplicates_metadata(self):
         # GH 10115
         idx = pd.timedelta_range('1 day', '31 day', freq='D', name='idx')
@@ -424,61 +392,6 @@ dtype: timedelta64[ns]"""
         res = Series(idx).drop_duplicates(keep=False)
         tm.assert_series_equal(res, Series(base[5:], index=np.arange(5, 31)))
 
-    def test_take(self):
-        # GH 10295
-        idx1 = pd.timedelta_range('1 day', '31 day', freq='D', name='idx')
-
-        for idx in [idx1]:
-            result = idx.take([0])
-            assert result == pd.Timedelta('1 day')
-
-            result = idx.take([-1])
-            assert result == pd.Timedelta('31 day')
-
-            result = idx.take([0, 1, 2])
-            expected = pd.timedelta_range('1 day', '3 day', freq='D',
-                                          name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx.take([0, 2, 4])
-            expected = pd.timedelta_range('1 day', '5 day', freq='2D',
-                                          name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx.take([7, 4, 1])
-            expected = pd.timedelta_range('8 day', '2 day', freq='-3D',
-                                          name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq == expected.freq
-
-            result = idx.take([3, 2, 5])
-            expected = TimedeltaIndex(['4 day', '3 day', '6 day'], name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq is None
-
-            result = idx.take([-3, 2, 5])
-            expected = TimedeltaIndex(['29 day', '3 day', '6 day'], name='idx')
-            tm.assert_index_equal(result, expected)
-            assert result.freq is None
-
-    def test_take_invalid_kwargs(self):
-        idx = pd.timedelta_range('1 day', '31 day', freq='D', name='idx')
-        indices = [1, 6, 5, 9, 10, 13, 15, 3]
-
-        msg = r"take\(\) got an unexpected keyword argument 'foo'"
-        tm.assert_raises_regex(TypeError, msg, idx.take,
-                               indices, foo=2)
-
-        msg = "the 'out' parameter is not supported"
-        tm.assert_raises_regex(ValueError, msg, idx.take,
-                               indices, out=indices)
-
-        msg = "the 'mode' parameter is not supported"
-        tm.assert_raises_regex(ValueError, msg, idx.take,
-                               indices, mode='clip')
-
     def test_infer_freq(self):
         # GH 11018
         for freq in ['D', '3D', '-3D', 'H', '2H', '-2H', 'T', '2T', 'S', '-3S'
diff --git a/pandas/tests/indexes/timedeltas/test_timedelta.py b/pandas/tests/indexes/timedeltas/test_timedelta.py
index 615c0d0ff..533b06088 100644
--- a/pandas/tests/indexes/timedeltas/test_timedelta.py
+++ b/pandas/tests/indexes/timedeltas/test_timedelta.py
@@ -50,66 +50,6 @@ class TestTimedeltaIndex(DatetimeLike):
                                    '10 days 01:00:03'], freq='D')
         tm.assert_index_equal(result, expected)
 
-    def test_get_loc(self):
-        idx = pd.to_timedelta(['0 days', '1 days', '2 days'])
-
-        for method in [None, 'pad', 'backfill', 'nearest']:
-            assert idx.get_loc(idx[1], method) == 1
-            assert idx.get_loc(idx[1].to_pytimedelta(), method) == 1
-            assert idx.get_loc(str(idx[1]), method) == 1
-
-        assert idx.get_loc(idx[1], 'pad',
-                           tolerance=pd.Timedelta(0)) == 1
-        assert idx.get_loc(idx[1], 'pad',
-                           tolerance=np.timedelta64(0, 's')) == 1
-        assert idx.get_loc(idx[1], 'pad',
-                           tolerance=timedelta(0)) == 1
-
-        with tm.assert_raises_regex(ValueError,
-                                    'unit abbreviation w/o a number'):
-            idx.get_loc(idx[1], method='nearest', tolerance='foo')
-
-        with pytest.raises(
-                ValueError,
-                match='tolerance size must match'):
-            idx.get_loc(idx[1], method='nearest',
-                        tolerance=[Timedelta(0).to_timedelta64(),
-                                   Timedelta(0).to_timedelta64()])
-
-        for method, loc in [('pad', 1), ('backfill', 2), ('nearest', 1)]:
-            assert idx.get_loc('1 day 1 hour', method) == loc
-
-        # GH 16909
-        assert idx.get_loc(idx[1].to_timedelta64()) == 1
-
-        # GH 16896
-        assert idx.get_loc('0 days') == 0
-
-    def test_get_loc_nat(self):
-        tidx = TimedeltaIndex(['1 days 01:00:00', 'NaT', '2 days 01:00:00'])
-
-        assert tidx.get_loc(pd.NaT) == 1
-        assert tidx.get_loc(None) == 1
-        assert tidx.get_loc(float('nan')) == 1
-        assert tidx.get_loc(np.nan) == 1
-
-    def test_get_indexer(self):
-        idx = pd.to_timedelta(['0 days', '1 days', '2 days'])
-        tm.assert_numpy_array_equal(idx.get_indexer(idx),
-                                    np.array([0, 1, 2], dtype=np.intp))
-
-        target = pd.to_timedelta(['-1 hour', '12 hours', '1 day 1 hour'])
-        tm.assert_numpy_array_equal(idx.get_indexer(target, 'pad'),
-                                    np.array([-1, 0, 1], dtype=np.intp))
-        tm.assert_numpy_array_equal(idx.get_indexer(target, 'backfill'),
-                                    np.array([0, 1, 2], dtype=np.intp))
-        tm.assert_numpy_array_equal(idx.get_indexer(target, 'nearest'),
-                                    np.array([0, 1, 1], dtype=np.intp))
-
-        res = idx.get_indexer(target, 'nearest',
-                              tolerance=pd.Timedelta('1 hour'))
-        tm.assert_numpy_array_equal(res, np.array([0, -1, 1], dtype=np.intp))
-
     def test_pickle_compat_construction(self):
         pass
 
@@ -144,53 +84,6 @@ class TestTimedeltaIndex(DatetimeLike):
         tm.assert_index_equal(idx_diff, expected)
         tm.assert_attr_equal('freq', idx_diff, expected)
 
-    def test_take(self):
-
-        tds = ['1day 02:00:00', '1 day 04:00:00', '1 day 10:00:00']
-        idx = TimedeltaIndex(start='1d', end='2d', freq='H', name='idx')
-        expected = TimedeltaIndex(tds, freq=None, name='idx')
-
-        taken1 = idx.take([2, 4, 10])
-        taken2 = idx[[2, 4, 10]]
-
-        for taken in [taken1, taken2]:
-            tm.assert_index_equal(taken, expected)
-            assert isinstance(taken, TimedeltaIndex)
-            assert taken.freq is None
-            assert taken.name == expected.name
-
-    def test_take_fill_value(self):
-        # GH 12631
-        idx = pd.TimedeltaIndex(['1 days', '2 days', '3 days'],
-                                name='xxx')
-        result = idx.take(np.array([1, 0, -1]))
-        expected = pd.TimedeltaIndex(['2 days', '1 days', '3 days'],
-                                     name='xxx')
-        tm.assert_index_equal(result, expected)
-
-        # fill_value
-        result = idx.take(np.array([1, 0, -1]), fill_value=True)
-        expected = pd.TimedeltaIndex(['2 days', '1 days', 'NaT'],
-                                     name='xxx')
-        tm.assert_index_equal(result, expected)
-
-        # allow_fill=False
-        result = idx.take(np.array([1, 0, -1]), allow_fill=False,
-                          fill_value=True)
-        expected = pd.TimedeltaIndex(['2 days', '1 days', '3 days'],
-                                     name='xxx')
-        tm.assert_index_equal(result, expected)
-
-        msg = ('When allow_fill=True and fill_value is not None, '
-               'all indices must be >= -1')
-        with tm.assert_raises_regex(ValueError, msg):
-            idx.take(np.array([1, 0, -2]), fill_value=True)
-        with tm.assert_raises_regex(ValueError, msg):
-            idx.take(np.array([1, 0, -5]), fill_value=True)
-
-        with pytest.raises(IndexError):
-            idx.take(np.array([1, -5]))
-
     def test_isin(self):
 
         index = tm.makeTimedeltaIndex(4)

commit 277eb1eb0be3a5a9dd0bcbb1b589a289b4130aa4
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Wed Dec 28 19:45:12 2011 -0500

    ENH: speed up join / align ops in cases where axes are equal

diff --git a/RELEASE.rst b/RELEASE.rst
index b014514dd..71727b089 100644
--- a/RELEASE.rst
+++ b/RELEASE.rst
@@ -48,6 +48,10 @@ pandas 0.6.2
     DataFrame
   - Added ``DataFrame.to_panel`` with code adapted from ``LongPanel.to_long``
   - ``reindex_axis`` method added to DataFrame
+  - Add ``level`` option to binary arithmetic functions on ``DataFrame`` and
+    ``Series``
+  - Add ``level`` option to the ``reindex`` and ``align`` methods for
+    broadcasting values across a level (GH #542, PR #552, others)
 
 **Improvements to existing features**
 
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 995af97ec..bfe41c229 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -55,6 +55,9 @@ axis : {0, 1, 'index', 'columns'}
 fill_value : None or float value, default None
     Fill missing (NaN) values with this value. If both DataFrame locations are
     missing, the result will be missing
+level : int or name
+    Broadcast across a level, matching Index values on the
+    passed MultiIndex level
 
 Notes
 -----
@@ -1346,6 +1349,9 @@ class DataFrame(NDFrame):
         join : {'outer', 'inner', 'left', 'right'}, default 'outer'
         axis : {0, 1, None}, default None
             Align on index (0), columns (1), or both (None)
+        level : int or name
+            Broadcast across a level, matching Index values on the
+            passed MultiIndex level
 
         Returns
         -------
@@ -1401,6 +1407,7 @@ class DataFrame(NDFrame):
         return left, right
 
     def _align_level(self, multi_index, level, axis=0, copy=True):
+        assert(isinstance(multi_index, MultiIndex))
         levnum = multi_index._get_level_number(level)
         data = self.reindex_axis(multi_index.levels[levnum], axis=axis,
                                  copy=False)._data
@@ -1461,6 +1468,9 @@ class DataFrame(NDFrame):
             backfill / bfill: use NEXT valid observation to fill gap
         copy : boolean, default True
             Return a new object, even if the passed indexes are the same
+        level : int or name
+            Broadcast across a level, matching Index values on the
+            passed MultiIndex level
 
         Examples
         --------
@@ -1501,6 +1511,9 @@ class DataFrame(NDFrame):
             backfill / bfill: use NEXT valid observation to fill gap
         copy : boolean, default True
             Return a new object, even if the passed indexes are the same
+        level : int or name
+            Broadcast across a level, matching Index values on the
+            passed MultiIndex level
 
         Examples
         --------
diff --git a/pandas/core/index.py b/pandas/core/index.py
index 544bfa1e8..cf2865f5b 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -586,6 +586,14 @@ class Index(np.ndarray):
             return this.join(other, how=how,
                              return_indexers=return_indexers)
 
+        _validate_join_method(how)
+
+        if self.equals(other):
+            if return_indexers:
+                return self, None, None
+            else:
+                return self
+
         if self.is_monotonic and other.is_monotonic:
             return self._join_monotonic(other, how=how,
                                         return_indexers=return_indexers)
@@ -598,8 +606,6 @@ class Index(np.ndarray):
             join_index = self.intersection(other)
         elif how == 'outer':
             join_index = self.union(other)
-        else:
-            raise Exception('do not recognize join method %s' % how)
 
         if return_indexers:
             if join_index is self:
@@ -621,7 +627,6 @@ class Index(np.ndarray):
         labels of the level in the MultiIndex. The order of the data indexed by
         the MultiIndex will not be changed (currently)
         """
-
         if isinstance(self, MultiIndex) and isinstance(other, MultiIndex):
             raise Exception('Join on level between two MultiIndex objects '
                             'is ambiguous')
@@ -692,8 +697,6 @@ class Index(np.ndarray):
             join_index, lidx, ridx = self._outer_indexer(self.values,
                                                          other.values)
             join_index = self._wrap_joined_index(join_index, other)
-        else:  # pragma: no cover
-            raise Exception('do not recognize join method %s' % how)
 
         if return_indexers:
             return join_index, lidx, ridx
@@ -1836,3 +1839,8 @@ def _ensure_index(index_like):
     if isinstance(index_like, Index):
         return index_like
     return Index(index_like)
+
+
+def _validate_join_method(method):
+    if method not in ['left', 'right', 'inner', 'outer']:
+        raise Exception('do not recognize join method %s' % how)
diff --git a/pandas/core/series.py b/pandas/core/series.py
index 1885bab22..94962b741 100644
--- a/pandas/core/series.py
+++ b/pandas/core/series.py
@@ -67,7 +67,7 @@ def _maybe_match_name(a, b):
     return name
 
 def _flex_method(op, name):
-    def f(self, other, fill_value=None):
+    def f(self, other, level=None, fill_value=None):
         return self._binop(other, op, fill_value=fill_value)
 
     f.__doc__ = """
@@ -80,6 +80,9 @@ def _flex_method(op, name):
     fill_value : None or float value, default None (NaN)
         Fill missing (NaN) values with this value. If both Series are
         missing, the result will be missing
+    level : int or name
+        Broadcast across a level, matching Index values on the
+        passed MultiIndex level
 
     Returns
     -------
@@ -1071,7 +1074,7 @@ copy : boolean, default False
         name = _maybe_match_name(self, other)
         return self._constructor(new_values, index=new_index, name=name)
 
-    def _binop(self, other, func, fill_value=None):
+    def _binop(self, other, func, level=None, fill_value=None):
         """
         Perform generic binary operation with optional fill value
 
@@ -1082,6 +1085,9 @@ copy : boolean, default False
         fill_value : float or object
             Value to substitute for NA/null values. If both Series are NA in a
             location, the result will be NA regardless of the passed fill value
+        level : int or name
+            Broadcast across a level, matching Index values on the
+            passed MultiIndex level
 
         Returns
         -------
@@ -1469,7 +1475,7 @@ copy : boolean, default False
             mapped = lib.map_infer(self.values, func)
             return Series(mapped, index=self.index, name=self.name)
 
-    def align(self, other, join='outer', copy=True):
+    def align(self, other, join='outer', level=None, copy=True):
         """
         Align two Series object with the specified join method
 
@@ -1477,6 +1483,12 @@ copy : boolean, default False
         ----------
         other : Series
         join : {'outer', 'inner', 'left', 'right'}, default 'outer'
+        level : int or name
+            Broadcast across a level, matching Index values on the
+            passed MultiIndex level
+        copy : boolean, default True
+            Always return new objects. If copy=False and no reindexing is
+            required, the same object will be returned (for better performance)
 
         Returns
         -------
diff --git a/vb_suite/miscellaneous.py b/vb_suite/miscellaneous.py
new file mode 100644
index 000000000..8295d275f
--- /dev/null
+++ b/vb_suite/miscellaneous.py
@@ -0,0 +1,22 @@
+from vbench.benchmark import Benchmark
+from datetime import datetime
+
+common_setup = """from pandas_vb_common import *
+"""
+
+#----------------------------------------------------------------------
+# cache_readonly
+
+setup = common_setup + """
+from pandas.util.decorators import cache_readonly
+
+class Foo:
+
+    @cache_readonly
+    def prop(self):
+        return 5
+obj = Foo()
+"""
+misc_cache_readonly = Benchmark("obj.prop", setup, name="misc_cache_readonly",
+                                ncalls=2000000)
+
diff --git a/vb_suite/reindex.py b/vb_suite/reindex.py
index 040a75fc3..f8ffd7f15 100644
--- a/vb_suite/reindex.py
+++ b/vb_suite/reindex.py
@@ -84,3 +84,24 @@ reindex_fillna_pad = Benchmark("ts3.fillna(method='pad')", setup,
 
 reindex_fillna_backfill = Benchmark("ts3.fillna(method='backfill')", setup,
                                     name="reindex_fillna_backfill")
+
+#----------------------------------------------------------------------
+# align on level
+
+setup = common_setup + """
+index = MultiIndex(levels=[np.arange(100), np.arange(100)],
+                   labels=[np.arange(100).repeat(100),
+                           np.tile(np.arange(100), 100)])
+random.shuffle(index.values)
+df = DataFrame(np.random.randn(len(index), 4), index=index)
+df_level = DataFrame(np.random.randn(100, 4), index=index.levels[0])
+"""
+
+reindex_frame_level_align = \
+    Benchmark("df.align(df_level, level=0, copy=False)", setup,
+              start_date=datetime(2011, 12, 27))
+
+reindex_frame_level_reindex = \
+    Benchmark("df_level.reindex(df.index, level=0)", setup,
+              start_date=datetime(2011, 12, 27))
+
diff --git a/vb_suite/suite.py b/vb_suite/suite.py
index e27463fb2..c7b0e83ea 100644
--- a/vb_suite/suite.py
+++ b/vb_suite/suite.py
@@ -4,7 +4,7 @@ from datetime import datetime
 import os
 
 modules = ['groupby', 'indexing', 'reindex', 'binary_ops',
-           'sparse', 'index_object']
+           'sparse', 'index_object', 'miscellaneous']
 
 by_module = {}
 benchmarks = []

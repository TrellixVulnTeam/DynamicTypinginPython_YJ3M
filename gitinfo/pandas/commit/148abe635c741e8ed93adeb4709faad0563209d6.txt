commit 148abe635c741e8ed93adeb4709faad0563209d6
Author: jreback <jeff@reback.net>
Date:   Tue Mar 4 19:24:52 2014 -0500

    BUG: Bug in setitem with loc on mixed integer Indexes (GH6546)

diff --git a/doc/source/release.rst b/doc/source/release.rst
index f5e2c8028..d84afc66b 100644
--- a/doc/source/release.rst
+++ b/doc/source/release.rst
@@ -200,6 +200,7 @@ Bug Fixes
 - Regression from 0.13 in the treatmenet of numpy ``datetime64`` non-ns dtypes in Series creation (:issue:`6529`)
 - ``.names`` attribute of MultiIndexes passed to ``set_index`` are now preserved (:issue:`6459`).
 - Bug in setitem with a duplicate index and an alignable rhs (:issue:`6541`)
+- Bug in setitem with loc on mixed integer Indexes (:issue:`6546`)
 
 pandas 0.13.1
 -------------
diff --git a/pandas/core/index.py b/pandas/core/index.py
index f67270530..30e18d239 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -555,6 +555,29 @@ class Index(IndexOpsMixin, FrozenNDArray):
         """ convert a list indexer. these should be locations """
         return key
 
+    def _convert_list_indexer_for_mixed(self, keyarr, typ=None):
+        """ passed a key that is tuplesafe that is integer based
+            and we have a mixed index (e.g. number/labels). figure out
+            the indexer. return None if we can't help
+        """
+        if com.is_integer_dtype(keyarr) and not self.is_floating():
+            if self.inferred_type != 'integer':
+                keyarr = np.where(keyarr < 0,
+                                  len(self) + keyarr, keyarr)
+
+            if self.inferred_type == 'mixed-integer':
+                indexer = self.get_indexer(keyarr)
+                if (indexer >= 0).all():
+                    return indexer
+
+                from pandas.core.indexing import _maybe_convert_indices
+                return _maybe_convert_indices(indexer, len(self))
+
+            elif not self.inferred_type == 'integer':
+                return keyarr
+
+        return None
+
     def _convert_indexer_error(self, key, msg=None):
         if msg is None:
             msg = 'label'
diff --git a/pandas/core/indexing.py b/pandas/core/indexing.py
index 288934dbd..c7970309a 100644
--- a/pandas/core/indexing.py
+++ b/pandas/core/indexing.py
@@ -911,20 +911,10 @@ class _NDFrameIndexer(object):
                 # asarray can be unsafe, NumPy strings are weird
                 keyarr = _asarray_tuplesafe(key)
 
-            if is_integer_dtype(keyarr) and not labels.is_floating():
-                if labels.inferred_type != 'integer':
-                    keyarr = np.where(keyarr < 0,
-                                      len(labels) + keyarr, keyarr)
-
-                if labels.inferred_type == 'mixed-integer':
-                    indexer = labels.get_indexer(keyarr)
-                    if (indexer >= 0).all():
-                        self.obj.take(indexer, axis=axis, convert=True)
-                    else:
-                        return self.obj.take(keyarr, axis=axis)
-                elif not labels.inferred_type == 'integer':
-
-                    return self.obj.take(keyarr, axis=axis)
+            # handle a mixed integer scenario
+            indexer = labels._convert_list_indexer_for_mixed(keyarr, typ=self.name)
+            if indexer is not None:
+                return self.obj.take(indexer, axis=axis)
 
             # this is not the most robust, but...
             if (isinstance(labels, MultiIndex) and
@@ -1064,11 +1054,9 @@ class _NDFrameIndexer(object):
                     objarr = _asarray_tuplesafe(obj)
 
                 # If have integer labels, defer to label-based indexing
-                if is_integer_dtype(objarr) and not is_int_index:
-                    if labels.inferred_type != 'integer':
-                        objarr = np.where(objarr < 0,
-                                          len(labels) + objarr, objarr)
-                    return objarr
+                indexer = labels._convert_list_indexer_for_mixed(objarr, typ=self.name)
+                if indexer is not None:
+                    return indexer
 
                 # this is not the most robust, but...
                 if (isinstance(labels, MultiIndex) and
diff --git a/pandas/tests/test_indexing.py b/pandas/tests/test_indexing.py
index f466ea302..1d033782a 100644
--- a/pandas/tests/test_indexing.py
+++ b/pandas/tests/test_indexing.py
@@ -835,6 +835,19 @@ class TestIndexing(tm.TestCase):
         expected = DataFrame(dict(A = Series(val1,index=keys1), B = Series(val2,index=keys2))).reindex(index=index)
         assert_frame_equal(df, expected)
 
+        # GH 6546
+        # setting with mixed labels
+        df = DataFrame({1:[1,2],2:[3,4],'a':['a','b']})
+
+        result = df.loc[0,[1,2]]
+        expected = Series([1,3],index=[1,2],dtype=object)
+        assert_series_equal(result,expected)
+
+        expected = DataFrame({1:[5,2],2:[6,4],'a':['a','b']})
+        df.loc[0,[1,2]] = [5,6]
+        assert_frame_equal(df, expected)
+
+
     def test_loc_setitem_frame_multiples(self):
 
         # multiple setting

commit d545f0958b2e62c7d3303ede7cb8a994b18e8a6a
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Fri Oct 1 00:20:06 2010 -0400

    Fixed DateRange.union logic, docs, changed XDateRange class to a generator function

diff --git a/pandas/core/daterange.py b/pandas/core/daterange.py
index 7d16828e4..a09c18bc2 100644
--- a/pandas/core/daterange.py
+++ b/pandas/core/daterange.py
@@ -1,4 +1,4 @@
-# pylint: disable-msg=E1101,E1103
+# pylint: disable=E1101,E1103
 
 from datetime import datetime
 import operator
@@ -8,85 +8,7 @@ import numpy as np
 from pandas.core.index import Index
 import pandas.core.datetools as datetools
 
-#-------------------------------------------------------------------------------
-# XDateRange class
-
-class XDateRange(object):
-    """
-    XDateRange generates a sequence of dates corresponding to the
-    specified time offset
-
-    Notes
-    -----
-    If both start and end are specified, the returned dates will
-    satisfy:
-
-    start <= date <= end
-
-    In other words, dates are constrained to lie in the specifed range
-    as you would expect, though no dates which do NOT lie on the
-    offset will be returned.
-
-    XDateRange is a generator, use if you do not intend to reuse the
-    date range, or if you are doing lazy iteration, or if the number
-    of dates you are generating is very large. If you intend to reuse
-    the range, use DateRange, which will be the list of dates
-    generated by XDateRange.
-
-    See also
-    --------
-    DateRange
-    """
-    _cache = {}
-    _cacheStart = {}
-    _cacheEnd = {}
-    def __init__(self, start=None, end=None, nPeriods=None,
-                 offset=datetools.BDay(), timeRule=None):
-
-        if timeRule is not None:
-            offset = datetools.getOffset(timeRule)
-
-        if timeRule is None:
-            if offset in datetools._offsetNames:
-                timeRule = datetools._offsetNames[offset]
-
-        start = datetools.to_datetime(start)
-        end = datetools.to_datetime(end)
-
-        if start and not offset.onOffset(start):
-            start = start + offset.__class__(n=1, **offset.kwds)
-        if end and not offset.onOffset(end):
-            end = end - offset.__class__(n=1, **offset.kwds)
-            if nPeriods == None and end < start:
-                end = None
-                nPeriods = 0
-
-        if end is None:
-            end = start + (nPeriods - 1) * offset
-
-        if start is None:
-            start = end - (nPeriods - 1) * offset
-
-        self.offset = offset
-        self.timeRule = timeRule
-        self.start = start
-        self.end = end
-        self.nPeriods = nPeriods
-
-    def __iter__(self):
-        offset = self.offset
-        cur = self.start
-        if offset._normalizeFirst:
-            cur = datetools.normalize_date(cur)
-        while cur <= self.end:
-            yield cur
-            cur = cur + offset
-
-#-------------------------------------------------------------------------------
-# DateRange cache
-
-CACHE_START = datetime(1950, 1, 1)
-CACHE_END   = datetime(2030, 1, 1)
+__all__ = ['DateRange']
 
 #-------------------------------------------------------------------------------
 # DateRange class
@@ -97,6 +19,9 @@ def _bin_op(op):
 
     return f
 
+_CACHE_START = datetime(1950, 1, 1)
+_CACHE_END   = datetime(2030, 1, 1)
+
 class DateRange(Index):
     """
     Fixed frequency date range according to input parameters.
@@ -117,7 +42,6 @@ class DateRange(Index):
     timeRule : timeRule to use
     """
     _cache = {}
-    _parent = None
     def __new__(cls, start=None, end=None, periods=None,
                 offset=datetools.bday, timeRule=None, **kwds):
 
@@ -143,21 +67,20 @@ class DateRange(Index):
             end = datetools.to_datetime(end)
 
             # inside cache range
-            fromInside = start is not None and start > CACHE_START
-            toInside = end is not None and end < CACHE_END
+            fromInside = start is not None and start > _CACHE_START
+            toInside = end is not None and end < _CACHE_END
 
             useCache = fromInside and toInside
 
             if (useCache and offset.isAnchored() and
                 not isinstance(offset, datetools.Tick)):
 
-                index = cls.getCachedRange(start, end, periods=periods,
-                                           offset=offset, timeRule=timeRule)
+                index = cls._cached_range(start, end, periods=periods,
+                                          offset=offset, timeRule=timeRule)
 
             else:
-                xdr = XDateRange(start=start, end=end,
-                                 nPeriods=periods, offset=offset,
-                                 timeRule=timeRule)
+                xdr = generate_range(start=start, end=end, periods=periods,
+                                     offset=offset, timeRule=timeRule)
 
                 index = np.array(list(xdr), dtype=object, copy=False)
 
@@ -187,7 +110,7 @@ class DateRange(Index):
         return True
 
     @classmethod
-    def getCachedRange(cls, start=None, end=None, periods=None, offset=None,
+    def _cached_range(cls, start=None, end=None, periods=None, offset=None,
                        timeRule=None):
 
         # HACK: fix this dependency later
@@ -198,7 +121,7 @@ class DateRange(Index):
             raise Exception('Must provide a DateOffset!')
 
         if offset not in cls._cache:
-            xdr = XDateRange(CACHE_START, CACHE_END, offset=offset)
+            xdr = generate_range(_CACHE_START, _CACHE_END, offset=offset)
             arr = np.array(list(xdr), dtype=object, copy=False)
 
             cachedRange = DateRange.fromIndex(arr)
@@ -237,7 +160,6 @@ class DateRange(Index):
             endLoc = cachedRange.indexMap[end] + 1
 
         indexSlice = cachedRange[startLoc:endLoc]
-        indexSlice._parent = cachedRange
 
         return indexSlice
 
@@ -251,7 +173,6 @@ class DateRange(Index):
             return self.item()
 
         self.offset = getattr(obj, 'offset', None)
-        self._parent = getattr(obj, '_parent',  None)
 
     __lt__ = _bin_op(operator.lt)
     __le__ = _bin_op(operator.le)
@@ -266,7 +187,7 @@ class DateRange(Index):
         """Override numpy.ndarray's __getitem__ method to work as desired"""
         result = self.view(np.ndarray)[key]
 
-        if isinstance(key, (int, np.int32)):
+        if isinstance(key, int):
             return result
         elif isinstance(key, slice):
             newIndex = result.view(DateRange)
@@ -290,6 +211,19 @@ class DateRange(Index):
     __str__ = __repr__
 
     def shift(self, n, offset=None):
+        """
+        Specialized shift which produces a DateRange
+
+        Parameters
+        ----------
+        n : int
+            Periods to shift by
+        offset : DateOffset or timedelta-like, optional
+
+        Returns
+        -------
+        shifted : DateRange
+        """
         if offset is not None and offset != self.offset:
             return Index.shift(self, n, offset)
 
@@ -302,14 +236,101 @@ class DateRange(Index):
         return DateRange(start, end, offset=self.offset)
 
     def union(self, other):
-        if isinstance(other, DateRange) and other.offset == self.offset:
-            # overlap condition
-            if self[-1] >= other[0] or other[-1] >= self[0]:
-                start = min(self[0], other[0])
-                end = max(self[-1], other[-1])
+        """
+        Specialized union for DateRange objects. If combine
+        overlapping ranges with the same DateOffset, will be much
+        faster than Index.union
+
+        Parameters
+        ----------
+        other : DateRange or array-like
+
+        Returns
+        -------
+        y : Index or DateRange
+        """
+        if not isinstance(other, DateRange) or other.offset != self.offset:
+            return Index.union(self.view(Index), other)
 
-                return DateRange(start, end, offset=self.offset)
-            else:
-                return Index.union(self, other)
+        offset = self.offset
+
+        # to make our life easier, "sort" the two ranges
+        if self[0] <= other[0]:
+            left, right = self, other
+        else:
+            left, right = other, self
+
+        left_start, left_end = left[0], left[-1]
+        right_start, right_end = right[0], right[-1]
+
+        # Only need to "adjoin", not overlap
+        if (left_end + offset) >= right_start:
+            return DateRange(left_start, max(left_end, right_end),
+                             offset=offset)
         else:
             return Index.union(self, other)
+
+def generate_range(start=None, end=None, periods=None,
+                   offset=datetools.BDay(), timeRule=None):
+    """
+    Generates a sequence of dates corresponding to the specified time
+    offset. Similar to dateutil.rrule except uses pandas DateOffset
+    objects to represent time increments
+
+    Parameters
+    ----------
+    start : datetime (default None)
+    end : datetime (default None)
+    periods : int, optional
+
+    Note
+    ----
+    * This method is faster for generating weekdays than dateutil.rrule
+    * At least two of (start, end, periods) must be specified.
+    * If both start and end are specified, the returned dates will
+    satisfy start <= date <= end.
+
+    Returns
+    -------
+    dates : generator object
+
+    See also
+    --------
+    DateRange, dateutil.rrule
+    """
+
+    if timeRule is not None:
+        offset = datetools.getOffset(timeRule)
+
+    if timeRule is None:
+        if offset in datetools._offsetNames:
+            timeRule = datetools._offsetNames[offset]
+
+    start = datetools.to_datetime(start)
+    end = datetools.to_datetime(end)
+
+    if start and not offset.onOffset(start):
+        start = offset.rollforward(start)
+
+    if end and not offset.onOffset(end):
+        end = offset.rollback(end)
+
+        if periods is None and end < start:
+            end = None
+            periods = 0
+
+    if end is None:
+        end = start + (periods - 1) * offset
+
+    if start is None:
+        start = end - (periods - 1) * offset
+
+    cur = start
+    if offset._normalizeFirst:
+        cur = datetools.normalize_date(cur)
+
+    while cur <= end:
+        yield cur
+
+        # faster than cur + offset
+        cur = offset.apply(cur)

commit ca1bdf6e1c11b893afb11745a8d30703a0014ff0
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Mon Nov 23 02:39:06 2009 +0000

    working on min_periods for regular OLS, leaving things in a semi-broken state for now
    
    git-svn-id: http://pandas.googlecode.com/svn/trunk@48 d5231056-7de3-11de-ac95-d976489f1ece

diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 933e61cdf..5eaa71b49 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -316,6 +316,20 @@ class DataFrame(Picklable, Groupable):
             else:
                 raise
 
+    def pop(self, item):
+        """
+        Return column and drop from frame. Raise KeyError if not
+        found.
+
+        Returns
+        -------
+        Series
+        """
+        result = self[item]
+        del self[item]
+
+        return result
+
     def __setitem__(self, key, value):
         """
         Add series to DataFrame in specified column.
diff --git a/pandas/stats/ols.py b/pandas/stats/ols.py
index 36d0219c0..c4c434f97 100644
--- a/pandas/stats/ols.py
+++ b/pandas/stats/ols.py
@@ -10,12 +10,13 @@ from scipy import stats
 
 from pandas.core.api import DataFrame, DataMatrix, Series
 from pandas.util.decorators import cache_readonly
+import pandas.lib.tseries as tseries
 import pandas.stats.common as common
 import pandas.stats.math as math
 
-
 class OLS(object):
-    """Runs a simple OLS.
+    """
+    Runs a full sample ordinary least squares regression
 
     Parameters
     ----------
@@ -35,11 +36,12 @@ class OLS(object):
         self._nw_lags = nw_lags
         self._nw_overlap = nw_overlap
 
-        self._y, self._x, self._x_filtered = self._prepare_data()
+        (self._y, self._x, self._x_filtered,
+         self._index, self._time_has_obs) = self._prepare_data()
+
         self._x_raw = self._x.values
         self._y_raw = self._y.view(np.ndarray)
         self._nobs = len(self._y_raw)
-        self._index = self._y.index
 
         self.sm_ols = sm.OLS(self._y_raw, self._x_raw).fit()
 
@@ -51,13 +53,13 @@ class OLS(object):
         -------
         (DataFrame, Series).
         """
-
-        y, x, x_filtered = _filter_data(self._y_orig, self._x_orig)
+        (y, x, x_filtered,
+         union_index, valid) = _filter_data(self._y_orig, self._x_orig)
 
         if self._intercept:
             x['intercept'] = x_filtered['intercept'] = 1.
 
-        return y, x, x_filtered
+        return y, x, x_filtered, union_index, valid
 
     @property
     def nobs(self):
@@ -425,6 +427,10 @@ Degrees of Freedom: model %(df_model)d, resid %(df_resid)d
     def __repr__(self):
         return self.summary
 
+    @property
+    def _total_times(self):
+        return self._time_has_obs.sum()
+
 
 class MovingOLS(OLS):
     """
@@ -443,8 +449,9 @@ class MovingOLS(OLS):
     window: int
         size of window (for rolling/expanding OLS)
     """
-    def __init__(self, y, x, window_type=common.ROLLING, window=10,
-                 intercept=True, nw_lags=None, nw_overlap=False):
+    def __init__(self, y, x, window_type=common.ROLLING,
+                 window=10, min_periods=None, intercept=True,
+                 nw_lags=None, nw_overlap=False):
 
         self._args = dict(intercept=intercept, nw_lags=nw_lags,
                           nw_overlap=nw_overlap)
@@ -453,36 +460,135 @@ class MovingOLS(OLS):
 
         self._window_type = common._get_window_type(window_type)
         self._window = window
+        self._min_periods = window if min_periods is None else min_periods
+
+    @property
+    def _is_rolling(self):
+        return self._window_type == common.ROLLING
+
+    @cache_readonly
+    def beta(self):
+        """Returns the betas in Series/DataMatrix form."""
+        return DataMatrix(self._beta_raw,
+                          index=self._result_index,
+                          columns=self._x.cols())
 
     @cache_readonly
     def _beta_raw(self):
         """Runs the regression and returns the beta."""
-        Y  = self._y_raw
-        X  = self._x_raw
+        beta, indices = self._rolling_ols_call
 
-        return math.rolling_ols(X, Y, self._window_type, self._window)
+        return beta[indices]
 
     @cache_readonly
-    def beta(self):
-        """Returns the betas in Series/DataMatrix form."""
-        return DataMatrix(
-            self._beta_raw, index=self._index[-len(self._beta_raw):],
-            columns=self._x.cols())
+    def _result_index(self):
+        return self._index[self._valid_indices]
+
+    @property
+    def _valid_indices(self):
+        return self._rolling_ols_call[1]
 
     @cache_readonly
-    def _df_raw(self):
-        """Returns the degrees of freedom."""
-        df = []
-        start = self._window - 1
-        for i in xrange(start, len(self._x_raw)):
-            if self._window_type == common.ROLLING:
-                begin = i - start
+    def _rolling_ols_call(self):
+        return self._calc_betas()
+
+    def _calc_betas(self):
+        N = len(self._index)
+        K = len(self._x.cols())
+
+        betas = np.empty((N, K), dtype=float)
+        betas[:] = np.NaN
+
+        valid = self._time_has_obs
+        enough = self._enough_obs
+        window = self._window
+
+        # Use transformed (demeaned) Y, X variables
+        cum_xx = self._cum_xx(self._x)
+        cum_xy = self._cum_xy(self._x, self._y)
+
+        for i in xrange(N):
+            # XXX
+            if not valid[i] or not enough[i]:
+                continue
+
+            xx = cum_xx[i]
+            xy = cum_xy[i]
+            if self._is_rolling and i >= window:
+                xx = xx - cum_xx[i - window]
+                xy = xy - cum_xy[i - window]
+
+            betas[i] = math.solve(xx, xy)
+
+        have_betas = np.arange(N)[-np.isnan(betas).any(axis=1)]
+
+        return betas, have_betas
+
+    def _cum_xx(self, x):
+        K = len(x.cols())
+        valid = self._time_has_obs
+        cum_xx = []
+
+        last = np.zeros((K, K))
+        for i, date in enumerate(self._index):
+            if not valid[i]:
+                cum_xx.append(last)
+                continue
+
+            xs = x.getXS(date)
+            xx = last = last + np.outer(xs, xs)
+            cum_xx.append(xx)
+
+        return cum_xx
+
+    def _cum_xy(self, x, y):
+        valid = self._time_has_obs
+        cum_xy = []
+        last = len(x.cols())
+        for i, date in enumerate(self._index):
+            if not valid[i]:
+                cum_xy.append(last)
+                continue
+
+            xs = np.asarray(x.getXS(date))
+            xy = last = last + xs * y[date]
+            cum_xy.append(xy)
+
+        return cum_xy
+
+    @cache_readonly
+    def rank(self):
+        return Series(self._rank_raw, index=self._result_index)
+
+    @cache_readonly
+    def _rank_raw(self):
+        rank = self._rolling_rank
+
+        return rank[self._valid_indices]
+
+    @cache_readonly
+    def _rolling_rank(self):
+        dates = self._index
+        enough = self._enough_obs
+        window = self._window
+
+        ranks = np.empty(len(dates), dtype=float)
+        ranks[:] = np.NaN
+        for i, date in enumerate(dates):
+            if self._is_rolling and i >= window:
+                prior_date = dates[i - window + 1]
             else:
-                begin = 0
+                prior_date = dates[0]
 
-            df.append(math.rank(self._x_raw[begin : i + 1]))
+            x_slice = self._x.truncate(before=prior_date, after=date)
+            ranks[i] = math.rank(x_slice.values)
 
-        return np.array(df)
+        return ranks
+
+    @cache_readonly
+    def _df_raw(self):
+        """Returns the degrees of freedom."""
+        return self._rank_raw
 
     @cache_readonly
     def df(self):
@@ -490,7 +596,6 @@ class MovingOLS(OLS):
         index = self.beta.index
         return Series(self._df_raw, index=index)
 
-
     @cache_readonly
     def _df_model_raw(self):
         """Returns the raw model degrees of freedom."""
@@ -506,18 +611,7 @@ class MovingOLS(OLS):
     @cache_readonly
     def _df_resid_raw(self):
         """Returns the raw residual degrees of freedom."""
-        df = []
-
-        start = self._window - 1
-        for i in xrange(start, self._nobs):
-            if self._window_type == common.ROLLING:
-                nobs = self._window
-            else:
-                nobs = i + 1
-
-            df.append(nobs - self._df_raw[i - start])
-
-        return np.array(df)
+        return self._window_nobs - self._df_raw
 
     @cache_readonly
     def df_resid(self):
@@ -549,19 +643,14 @@ class MovingOLS(OLS):
     @cache_readonly
     def _p_value_raw(self):
         """Returns the raw p values."""
-        p_value = []
-        start = self._window - 1
-        for i in xrange(start, self._nobs):
-            if self._window_type == common.EXPANDING:
-                nobs = i + 1
-            else:
-                nobs = self._window
-            fabs = np.fabs(self._t_stat_raw[i - start])
-            result = 2 * (1 - stats.t.cdf(fabs,
-                nobs - self._df_raw[i - start]))
-            p_value.append(result)
+        get_prob = lambda a, b: 2 * (1 - stats.t.cdf(a, b))
 
-        return np.array(p_value)
+        result = starmap(get_prob,
+                         izip(np.fabs(self._t_stat_raw), self._df_resid_raw))
+
+        result = np.array(list(result))
+
+        return result
 
     @cache_readonly
     def p_value(self):
@@ -774,32 +863,73 @@ class MovingOLS(OLS):
 
         return results
 
-def _filter_rhs(rhs):
-    merged_df = None
+    def _beta_matrix(self, lag=0):
+        assert(lag >= 0)
+
+        labels = self._y_trans.index.major_labels - lag
+        indexer = self._valid_indices.searchsorted(labels, side='left')
+
+        beta_matrix = self._beta_raw[indexer]
+        beta_matrix[labels < 0] = np.NaN
+
+        return beta_matrix
+
+    @cache_readonly
+    def _window_nobs_raw(self):
+        if self._is_rolling:
+            window = self._window
+        else:
+            # expanding case
+            window = len(self._index)
+
+        result = tseries.rolling_sum(self._time_has_obs, window,
+                                     minp=1)
+
+        return result.astype(int)
+
+    @cache_readonly
+    def _window_nobs(self):
+        return self._window_nobs_raw[self._valid_indices]
+
+    @cache_readonly
+    def _enough_obs(self):
+        # XXX: what's the best way to determine where to start?
+        return self._window_nobs_raw >= max(self._min_periods,
+                                            len(self._x.columns) + 1)
+
+def _safe_update(d, other):
+    """
+    Combine dictionaries with non-overlapping keys
+    """
+    for k, v in other.iteritems():
+        if k in d:
+            raise Exception('Duplicate regressor: %s' % k)
+
+        d[k] = v
+
+def _combine_rhs(rhs):
+    """
+    Glue input X variables together while checking for potential
+    duplicates
+    """
+    series = {}
 
     if isinstance(rhs, Series):
-        merged_df = DataFrame({'x' : rhs})
+        series['x'] = rhs
     elif isinstance(rhs, DataFrame):
-        merged_df = rhs
-    else:
+        _safe_update(series, rhs)
+    elif isinstance(rhs, dict):
         for name, value in rhs.iteritems():
             if isinstance(value, Series):
-                df = DataFrame({name : value})
-            elif isinstance(value, DataFrame):
-                df = value
-            elif isinstance(value, dict):
-                df = DataFrame(dict)
+                _safe_update(series, {name : value})
+            elif isinstance(value, (dict, DataFrame)):
+                _safe_update(series, value)
             else:
-                raise Exception('Invalid RHS data type: %s' % str(type(value)))
-
-            if merged_df is None:
-                merged_df = df
-            else:
-                merged_df = merged_df.leftJoin(df)
-
-    merged_df = merged_df.dropIncompleteRows()
+                raise Exception('Invalid RHS data type: %s' % type(value))
+    else:
+        raise Exception('Invalid RHS type: %s' % type(rhs))
 
-    return merged_df
+    return series
 
 def _filter_data(lhs, rhs):
     """
@@ -809,7 +939,6 @@ def _filter_data(lhs, rhs):
     ----------
     lhs: Series
         Dependent variable in the regression.
-
     rhs: dict, whose values are Series, DataFrame, or dict
         Explanatory variables of the regression.
 
@@ -821,16 +950,20 @@ def _filter_data(lhs, rhs):
     if not isinstance(lhs, Series):
         raise Exception('lhs must be a Series')
 
-    pre_filtered_rhs = _filter_rhs(rhs)
+    combined_rhs = _combine_rhs(rhs)
+
+    pre_filtered_rhs = DataMatrix.fromDict(combined_rhs).dropIncompleteRows()
 
-    frame = pre_filtered_rhs.copy().reindex(lhs.index)
+    # Union of all indices
+    combined_rhs['_y'] = lhs
+    full_dataset = DataMatrix.fromDict(combined_rhs)
 
-    frame['_y'] = lhs
-    frame = frame.dropIncompleteRows()
+    index = full_dataset.index
 
-    filtered_lhs = frame['_y']
-    del frame['_y']
+    obs_count = full_dataset.count(axis=1, asarray=True)
+    valid = obs_count == len(full_dataset.cols())
 
-    filtered_rhs = frame
+    filtered_rhs = full_dataset.reindex(index[valid])
+    filtered_lhs = filtered_rhs.pop('_y')
 
-    return filtered_lhs, filtered_rhs, pre_filtered_rhs
+    return filtered_lhs, filtered_rhs, pre_filtered_rhs, index, valid
diff --git a/pandas/stats/plm.py b/pandas/stats/plm.py
index fce4415ca..948897866 100644
--- a/pandas/stats/plm.py
+++ b/pandas/stats/plm.py
@@ -306,10 +306,9 @@ class PanelOLS(OLS):
         X = self._x_trans_raw
         Y = self._y_trans_raw
 
-        XX = np.dot(X.T, X)
-        XY = np.dot(X.T, Y)
+        beta, ssr, rank, sing = np.linalg.lstsq(X, Y)
 
-        return math.solve(XX, XY)
+        return beta
 
     @cache_readonly
     def beta(self):
@@ -478,10 +477,6 @@ class PanelOLS(OLS):
     def _time_has_obs(self):
         return self._time_obs_count > 0
 
-    @property
-    def _total_times(self):
-        return self._time_has_obs.sum()
-
 def _convertDummies(dummies, mapping):
     # cleans up the names of the generated dummies
     new_items = []
@@ -559,7 +554,8 @@ class MovingPanelOLS(PanelOLS, MovingOLS):
         ENTITY or TIME, indicating entity/time clustering
     """
     def __init__(self, y, x, weights=None,
-                 window_type=common.ROLLING, window=10, min_periods=0,
+                 window_type=common.ROLLING, window=10,
+                 min_periods=None,
                  intercept=True,
                  nw_lags=None, nw_overlap=False,
                  entity_effects=False,
@@ -584,7 +580,7 @@ class MovingPanelOLS(PanelOLS, MovingOLS):
 
         self._window_type = common._get_window_type(window_type)
         self._window = window
-        self._min_periods = min_periods
+        self._min_periods = window if min_periods is None else min_periods
 
     @cache_readonly
     def beta(self):
@@ -592,35 +588,6 @@ class MovingPanelOLS(PanelOLS, MovingOLS):
                           index=self._result_index,
                           columns=self._x.items)
 
-    @cache_readonly
-    def _beta_raw(self):
-        """Runs the regression and returns the beta."""
-        beta, indices = self._rolling_ols_call
-
-        return beta[indices]
-
-    @cache_readonly
-    def rank(self):
-        return Series(self._rank_raw, index=self._result_index)
-
-    @cache_readonly
-    def _rank_raw(self):
-        rank = self._rolling_rank
-
-        return rank[self._valid_indices]
-
-    @cache_readonly
-    def _result_index(self):
-        return self._index[self._valid_indices]
-
-    @property
-    def _valid_indices(self):
-        return self._rolling_ols_call[1]
-
-    @cache_readonly
-    def _rolling_ols_call(self):
-        return self._calc_betas()
-
     def _calc_betas(self):
         N = len(self._index)
         K = len(self._x.items)
@@ -661,12 +628,11 @@ class MovingPanelOLS(PanelOLS, MovingOLS):
         cum_xx = []
 
         last = np.zeros((K, K))
-        for i in xrange(len(dates)):
+        for i, date in enumerate(dates):
             if not valid[i]:
                 cum_xx.append(last)
                 continue
 
-            date = dates[i]
             x_slice = x.getValueSlice(date, date)
             xx = last = last + np.dot(x_slice.T, x_slice)
             cum_xx.append(xx)
@@ -679,12 +645,11 @@ class MovingPanelOLS(PanelOLS, MovingOLS):
         cum_xy = []
 
         last = np.zeros((len(x.items), 1))
-        for i in xrange(len(dates)):
+        for i, date in enumerate(dates):
             if not valid[i]:
                 cum_xy.append(last)
                 continue
 
-            date = dates[i]
             x_slice = x.getValueSlice(date, date)
             y_slice = y.getValueSlice(date, date)
 
@@ -693,10 +658,6 @@ class MovingPanelOLS(PanelOLS, MovingOLS):
 
         return cum_xy
 
-    @property
-    def _is_rolling(self):
-        return self._window_type == common.ROLLING
-
     @cache_readonly
     def _rolling_rank(self):
         dates = self._x.index.major_axis
@@ -733,11 +694,6 @@ class MovingPanelOLS(PanelOLS, MovingOLS):
 
         return df[self._valid_indices]
 
-    @cache_readonly
-    def _df_resid_raw(self):
-        """Returns the raw residual degrees of freedom."""
-        return self._window_nobs - self._df_raw
-
     @cache_readonly
     def _var_beta_raw(self):
         """Returns the raw covariance of beta."""
@@ -902,19 +858,6 @@ class MovingPanelOLS(PanelOLS, MovingOLS):
         """Returns the raw t-stat value."""
         return np.nan_to_num(self._beta_raw / self._std_err_raw)
 
-    @cache_readonly
-    def _p_value_raw(self):
-        """Returns the raw p values."""
-        get_prob = lambda a, b: 2 * (1 - stats.t.cdf(a, b))
-
-        result = starmap(get_prob,
-                         izip(np.fabs(self._t_stat_raw),
-                              self._window_nobs - self._df_raw))
-
-        result = np.array(list(result))
-
-        return result
-
     @cache_readonly
     def _resid_raw(self):
         beta_matrix = self._beta_matrix(lag=0)
@@ -988,6 +931,8 @@ class MovingPanelOLS(PanelOLS, MovingOLS):
 
     @cache_readonly
     def _enough_obs(self):
+        # XXX: what's the best way to determine where to start?
+
         return self._window_nobs_raw >= max(self._min_periods,
                                             len(self._x.items) * 2)
 
diff --git a/pandas/stats/tests/test_ols.py b/pandas/stats/tests/test_ols.py
index 69066dd5a..5a8b8bdb6 100644
--- a/pandas/stats/tests/test_ols.py
+++ b/pandas/stats/tests/test_ols.py
@@ -6,6 +6,7 @@ Unit test suite for OLS and PanelOLS classes
 
 from __future__ import division
 
+from cStringIO import StringIO
 from datetime import datetime
 import unittest
 
@@ -21,6 +22,9 @@ from pandas.stats.api import *
 from pandas.stats.plm import NonPooledPanelOLS
 from pandas.stats.tests.common import assert_almost_equal, BaseTest
 
+def _check_repr(obj):
+    str = '%s' % obj
+
 class TestOLS(BaseTest):
 
     FIELDS = ['beta', 'df', 'df_model', 'df_resid', 'f_stat', 'p_value',
@@ -359,9 +363,10 @@ class TestPanelOLS(BaseTest):
     def checkNonPooled(self, x, y, **kwds):
         # For now, just check that it doesn't crash
         result = ols(y=y, x=x, pool=False, **kwds)
-        print result
+
+        _check_repr(result)
         for attr in NonPooledPanelOLS.ATTRIBUTES:
-            print getattr(result, attr)
+            _check_repr(getattr(result, attr))
 
     def checkRollingOLS(self, x, y, window_type=ROLLING, **kwds):
         window = 25  # must be larger than rank of x
@@ -435,11 +440,11 @@ class TestPanelOLS(BaseTest):
             assert_almost_equal(ref, res)
 
 def _check_non_raw_results(model):
-    print model
-    print model.resid
-    print model.summary_as_matrix
-    print model.y_fitted
-    print model.y_predict
+    _check_repr(model)
+    _check_repr(model.resid)
+    _check_repr(model.summary_as_matrix)
+    _check_repr(model.y_fitted)
+    _check_repr(model.y_predict)
 
 def _period_slice(panelModel, i):
     index = panelModel._x_trans.index
diff --git a/pandas/stats/tests/test_ols_filter.py b/pandas/stats/tests/test_ols_filter.py
index 14dcac499..80ef83bbf 100644
--- a/pandas/stats/tests/test_ols_filter.py
+++ b/pandas/stats/tests/test_ols_filter.py
@@ -72,7 +72,7 @@ class TestOLSFilter(unittest.TestCase):
         self.tsAssertEqual(exp_rhs2, rhs['x2'])
 
     def tsAssertEqual(self, ts1, ts2):
-        self.assert_((ts1 == ts2).all())
+        self.assert_(np.array_equal(ts1, ts2))
 
 if __name__ == '__main__':
     unittest.main()

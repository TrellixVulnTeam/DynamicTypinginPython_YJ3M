commit bd169dc0a91f50031f6c2240075ff84d6b296576
Author: Albert Villanova del Moral <albert.villanova@gmail.com>
Date:   Tue Mar 28 20:17:41 2017 -0400

    BUG: Fix index order for Index.intersection()
    
    closes #15582
    
    Author: Albert Villanova del Moral <albert.villanova@gmail.com>
    Author: Jeff Reback <jeff@reback.net>
    
    Closes #15583 from albertvillanova/fix-15582 and squashes the following commits:
    
    2d4e143 [Albert Villanova del Moral] Fix pytest fixture name collision
    64e86a4 [Albert Villanova del Moral] Fix test on right join
    73df69e [Albert Villanova del Moral] Address requested changes
    8d2e9cc [Albert Villanova del Moral] Address requested changes
    968c7f1 [Jeff Reback] DOC/TST: change to use parameterization
    9e39794 [Albert Villanova del Moral] Address requested changes
    5bf1508 [Albert Villanova del Moral] Address requested changes
    654288b [Albert Villanova del Moral] Fix Travis errors
    33eb740 [Albert Villanova del Moral] Address requested changes
    3c200fe [Albert Villanova del Moral] Add new tests
    ef2581e [Albert Villanova del Moral] Fix Travis error
    f0d9d03 [Albert Villanova del Moral] Add whatsnew
    c96306d [Albert Villanova del Moral] Add sort argument to Index.join
    047b513 [Albert Villanova del Moral] Address requested changes
    ec836bd [Albert Villanova del Moral] Fix Travis errors
    b977278 [Albert Villanova del Moral] Address requested changes
    784fe75 [Albert Villanova del Moral] Fix error: line too long
    1197b99 [Albert Villanova del Moral] Fix DataFrame column order when read from HDF file
    d9e29f8 [Albert Villanova del Moral] Create new DatetimeIndex from the Index.intersection result
    e7bcd28 [Albert Villanova del Moral] Fix typo in documentation
    a4ead99 [Albert Villanova del Moral] Fix typo
    c2a8dc3 [Albert Villanova del Moral] Implement tests
    c12bb3f [Albert Villanova del Moral] BUG: Fix index order for Index.intersection()

diff --git a/doc/source/whatsnew/v0.20.0.txt b/doc/source/whatsnew/v0.20.0.txt
index 787857095..2e8227298 100644
--- a/doc/source/whatsnew/v0.20.0.txt
+++ b/doc/source/whatsnew/v0.20.0.txt
@@ -750,6 +750,62 @@ New Behavior:
    TypeError: Cannot compare 2014-01-01 00:00:00 of
    type <class 'pandas.tslib.Timestamp'> to string column
 
+.. _whatsnew_0200.api_breaking.index_order:
+
+Index.intersection and inner join now preserve the order of the left Index
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+`:meth:Index.intersection` now preserves the order of the calling ``Index`` (left)
+instead of the other ``Index`` (right) (:issue:`15582`). This affects the inner
+joins (`:meth:DataFrame.join` and `:func:merge`) and the ``.align`` methods.
+
+- ``Index.intersection``
+
+  .. ipython:: python
+
+     left = pd.Index([2, 1, 0])
+     left
+     right = pd.Index([1, 2, 3])
+     right
+
+  Previous Behavior:
+
+  .. code-block:: ipython
+
+     In [4]: left.intersection(right)
+     Out[4]: Int64Index([1, 2], dtype='int64')
+
+  New Behavior:
+
+  .. ipython:: python
+
+     left.intersection(right)
+
+- ``DataFrame.join`` and ``pd.merge``
+
+  .. ipython:: python
+
+     left = pd.DataFrame({'a': [20, 10, 0]}, index=[2, 1, 0])
+     left
+     right = pd.DataFrame({'b': [100, 200, 300]}, index=[1, 2, 3])
+     right
+
+  Previous Behavior:
+
+  .. code-block:: ipython
+
+     In [4]: left.join(right, how='inner')
+     Out[4]:
+         a    b
+     1  10  100
+     2  20  200
+
+  New Behavior:
+
+  .. ipython:: python
+
+     left.join(right, how='inner')
+
 
 .. _whatsnew_0200.api:
 
@@ -984,6 +1040,7 @@ Bug Fixes
 
 - Bug in ``DataFrame.to_stata()`` and ``StataWriter`` which produces incorrectly formatted files to be produced for some locales (:issue:`13856`)
 - Bug in ``StataReader`` and ``StataWriter`` which allows invalid encodings (:issue:`15723`)
+- Bug with ``sort=True`` in ``DataFrame.join`` and ``pd.merge`` when joining on indexes (:issue:`15582`)
 
 - Bug in ``pd.concat()`` in which concatting with an empty dataframe with ``join='inner'`` was being improperly handled (:issue:`15328`)
 - Bug in ``groupby.agg()`` incorrectly localizing timezone on ``datetime`` (:issue:`15426`, :issue:`10668`, :issue:`13046`)
diff --git a/pandas/core/frame.py b/pandas/core/frame.py
index 90baa1aff..03f93f1e5 100644
--- a/pandas/core/frame.py
+++ b/pandas/core/frame.py
@@ -124,10 +124,14 @@ Parameters
 ----------%s
 right : DataFrame
 how : {'left', 'right', 'outer', 'inner'}, default 'inner'
-    * left: use only keys from left frame (SQL: left outer join)
-    * right: use only keys from right frame (SQL: right outer join)
-    * outer: use union of keys from both frames (SQL: full outer join)
-    * inner: use intersection of keys from both frames (SQL: inner join)
+    * left: use only keys from left frame, similar to a SQL left outer join;
+      preserve key order
+    * right: use only keys from right frame, similar to a SQL right outer join;
+      preserve key order
+    * outer: use union of keys from both frames, similar to a SQL full outer
+      join; sort keys lexicographically
+    * inner: use intersection of keys from both frames, similar to a SQL inner
+      join; preserve the order of the left keys
 on : label or list
     Field names to join on. Must be found in both DataFrames. If on is
     None and not merging on indexes, then it merges on the intersection of
@@ -147,7 +151,8 @@ right_index : boolean, default False
     Use the index from the right DataFrame as the join key. Same caveats as
     left_index
 sort : boolean, default False
-    Sort the join keys lexicographically in the result DataFrame
+    Sort the join keys lexicographically in the result DataFrame. If False,
+    the order of the join keys depends on the join type (how keyword)
 suffixes : 2-length sequence (tuple, list, ...)
     Suffix to apply to overlapping column names in the left and right
     side, respectively
@@ -4472,16 +4477,18 @@ it is assumed to be aliases for the column names.')
             * left: use calling frame's index (or column if on is specified)
             * right: use other frame's index
             * outer: form union of calling frame's index (or column if on is
-                specified) with other frame's index
+              specified) with other frame's index, and sort it
+              lexicographically
             * inner: form intersection of calling frame's index (or column if
-                on is specified) with other frame's index
+              on is specified) with other frame's index, preserving the order
+              of the calling's one
         lsuffix : string
             Suffix to use from left frame's overlapping columns
         rsuffix : string
             Suffix to use from right frame's overlapping columns
         sort : boolean, default False
             Order result DataFrame lexicographically by the join key. If False,
-            preserves the index order of the calling (left) DataFrame
+            the order of the join key depends on the join type (how keyword)
 
         Notes
         -----
diff --git a/pandas/indexes/base.py b/pandas/indexes/base.py
index 54f73a246..7f0de963e 100644
--- a/pandas/indexes/base.py
+++ b/pandas/indexes/base.py
@@ -2089,8 +2089,8 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
         """
         Form the intersection of two Index objects.
 
-        This returns a new Index with elements common to the index and `other`.
-        Sortedness of the result is not guaranteed.
+        This returns a new Index with elements common to the index and `other`,
+        preserving the order of the calling index.
 
         Parameters
         ----------
@@ -2128,15 +2128,15 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
                 pass
 
         try:
-            indexer = Index(self._values).get_indexer(other._values)
+            indexer = Index(other._values).get_indexer(self._values)
             indexer = indexer.take((indexer != -1).nonzero()[0])
         except:
             # duplicates
-            indexer = Index(self._values).get_indexer_non_unique(
-                other._values)[0].unique()
+            indexer = Index(other._values).get_indexer_non_unique(
+                self._values)[0].unique()
             indexer = indexer[indexer != -1]
 
-        taken = self.take(indexer)
+        taken = other.take(indexer)
         if self.name != other.name:
             taken.name = None
         return taken
@@ -2831,8 +2831,7 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
         new_index = self._shallow_copy_with_infer(new_labels, freq=None)
         return new_index, indexer, new_indexer
 
-    def join(self, other, how='left', level=None, return_indexers=False):
-        """
+    _index_shared_docs['join'] = """
         *this is an internal non-public method*
 
         Compute join_index and indexers to conform data
@@ -2844,11 +2843,20 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
         how : {'left', 'right', 'inner', 'outer'}
         level : int or level name, default None
         return_indexers : boolean, default False
+        sort : boolean, default False
+            Sort the join keys lexicographically in the result Index. If False,
+            the order of the join keys depends on the join type (how keyword)
+
+            .. versionadded:: 0.20.0
 
         Returns
         -------
         join_index, (left_indexer, right_indexer)
         """
+
+    @Appender(_index_shared_docs['join'])
+    def join(self, other, how='left', level=None, return_indexers=False,
+             sort=False):
         from .multi import MultiIndex
         self_is_mi = isinstance(self, MultiIndex)
         other_is_mi = isinstance(other, MultiIndex)
@@ -2929,6 +2937,9 @@ class Index(IndexOpsMixin, StringAccessorMixin, PandasObject):
         elif how == 'outer':
             join_index = self.union(other)
 
+        if sort:
+            join_index = join_index.sort_values()
+
         if return_indexers:
             if join_index is self:
                 lindexer = None
diff --git a/pandas/indexes/range.py b/pandas/indexes/range.py
index 103a3ac2f..be68c97fb 100644
--- a/pandas/indexes/range.py
+++ b/pandas/indexes/range.py
@@ -431,29 +431,16 @@ class RangeIndex(Int64Index):
 
         return self._int64index.union(other)
 
-    def join(self, other, how='left', level=None, return_indexers=False):
-        """
-        *this is an internal non-public method*
-
-        Compute join_index and indexers to conform data
-        structures to the new index.
-
-        Parameters
-        ----------
-        other : Index
-        how : {'left', 'right', 'inner', 'outer'}
-        level : int or level name, default None
-        return_indexers : boolean, default False
-
-        Returns
-        -------
-        join_index, (left_indexer, right_indexer)
-        """
+    @Appender(_index_shared_docs['join'])
+    def join(self, other, how='left', level=None, return_indexers=False,
+             sort=False):
         if how == 'outer' and self is not other:
             # note: could return RangeIndex in more circumstances
-            return self._int64index.join(other, how, level, return_indexers)
+            return self._int64index.join(other, how, level, return_indexers,
+                                         sort)
 
-        return super(RangeIndex, self).join(other, how, level, return_indexers)
+        return super(RangeIndex, self).join(other, how, level, return_indexers,
+                                            sort)
 
     def __len__(self):
         """
diff --git a/pandas/io/pytables.py b/pandas/io/pytables.py
index b3b253f15..f75a4761e 100644
--- a/pandas/io/pytables.py
+++ b/pandas/io/pytables.py
@@ -4321,7 +4321,7 @@ def _reindex_axis(obj, axis, labels, other=None):
 
     labels = _ensure_index(labels.unique())
     if other is not None:
-        labels = labels & _ensure_index(other.unique())
+        labels = _ensure_index(other.unique()) & labels
     if not labels.equals(ax):
         slicer = [slice(None, None)] * obj.ndim
         slicer[axis] = labels
diff --git a/pandas/tests/frame/test_join.py b/pandas/tests/frame/test_join.py
new file mode 100644
index 000000000..f7a510023
--- /dev/null
+++ b/pandas/tests/frame/test_join.py
@@ -0,0 +1,140 @@
+# -*- coding: utf-8 -*-
+
+import pytest
+import numpy as np
+
+from pandas import DataFrame, Index
+from pandas.tests.frame.common import TestData
+import pandas.util.testing as tm
+
+
+@pytest.fixture
+def frame():
+    return TestData().frame
+
+
+@pytest.fixture
+def left():
+    return DataFrame({'a': [20, 10, 0]}, index=[2, 1, 0])
+
+
+@pytest.fixture
+def right():
+    return DataFrame({'b': [300, 100, 200]}, index=[3, 1, 2])
+
+
+@pytest.mark.parametrize(
+    "how, sort, expected",
+    [('inner', False, DataFrame({'a': [20, 10],
+                                 'b': [200, 100]},
+                                index=[2, 1])),
+     ('inner', True, DataFrame({'a': [10, 20],
+                                'b': [100, 200]},
+                               index=[1, 2])),
+     ('left', False, DataFrame({'a': [20, 10, 0],
+                                'b': [200, 100, np.nan]},
+                               index=[2, 1, 0])),
+     ('left', True, DataFrame({'a': [0, 10, 20],
+                               'b': [np.nan, 100, 200]},
+                              index=[0, 1, 2])),
+     ('right', False, DataFrame({'a': [np.nan, 10, 20],
+                                 'b': [300, 100, 200]},
+                                index=[3, 1, 2])),
+     ('right', True, DataFrame({'a': [10, 20, np.nan],
+                                'b': [100, 200, 300]},
+                               index=[1, 2, 3])),
+     ('outer', False, DataFrame({'a': [0, 10, 20, np.nan],
+                                 'b': [np.nan, 100, 200, 300]},
+                                index=[0, 1, 2, 3])),
+     ('outer', True, DataFrame({'a': [0, 10, 20, np.nan],
+                                'b': [np.nan, 100, 200, 300]},
+                               index=[0, 1, 2, 3]))])
+def test_join(left, right, how, sort, expected):
+
+    result = left.join(right, how=how, sort=sort)
+    tm.assert_frame_equal(result, expected)
+
+
+def test_join_index(frame):
+    # left / right
+
+    f = frame.loc[frame.index[:10], ['A', 'B']]
+    f2 = frame.loc[frame.index[5:], ['C', 'D']].iloc[::-1]
+
+    joined = f.join(f2)
+    tm.assert_index_equal(f.index, joined.index)
+    expected_columns = Index(['A', 'B', 'C', 'D'])
+    tm.assert_index_equal(joined.columns, expected_columns)
+
+    joined = f.join(f2, how='left')
+    tm.assert_index_equal(joined.index, f.index)
+    tm.assert_index_equal(joined.columns, expected_columns)
+
+    joined = f.join(f2, how='right')
+    tm.assert_index_equal(joined.index, f2.index)
+    tm.assert_index_equal(joined.columns, expected_columns)
+
+    # inner
+
+    joined = f.join(f2, how='inner')
+    tm.assert_index_equal(joined.index, f.index[5:10])
+    tm.assert_index_equal(joined.columns, expected_columns)
+
+    # outer
+
+    joined = f.join(f2, how='outer')
+    tm.assert_index_equal(joined.index, frame.index.sort_values())
+    tm.assert_index_equal(joined.columns, expected_columns)
+
+    tm.assertRaisesRegexp(ValueError, 'join method', f.join, f2, how='foo')
+
+    # corner case - overlapping columns
+    for how in ('outer', 'left', 'inner'):
+        with tm.assertRaisesRegexp(ValueError, 'columns overlap but '
+                                   'no suffix'):
+            frame.join(frame, how=how)
+
+
+def test_join_index_more(frame):
+    af = frame.loc[:, ['A', 'B']]
+    bf = frame.loc[::2, ['C', 'D']]
+
+    expected = af.copy()
+    expected['C'] = frame['C'][::2]
+    expected['D'] = frame['D'][::2]
+
+    result = af.join(bf)
+    tm.assert_frame_equal(result, expected)
+
+    result = af.join(bf, how='right')
+    tm.assert_frame_equal(result, expected[::2])
+
+    result = bf.join(af, how='right')
+    tm.assert_frame_equal(result, expected.loc[:, result.columns])
+
+
+def test_join_index_series(frame):
+    df = frame.copy()
+    s = df.pop(frame.columns[-1])
+    joined = df.join(s)
+
+    # TODO should this check_names ?
+    tm.assert_frame_equal(joined, frame, check_names=False)
+
+    s.name = None
+    tm.assertRaisesRegexp(ValueError, 'must have a name', df.join, s)
+
+
+def test_join_overlap(frame):
+    df1 = frame.loc[:, ['A', 'B', 'C']]
+    df2 = frame.loc[:, ['B', 'C', 'D']]
+
+    joined = df1.join(df2, lsuffix='_df1', rsuffix='_df2')
+    df1_suf = df1.loc[:, ['B', 'C']].add_suffix('_df1')
+    df2_suf = df2.loc[:, ['B', 'C']].add_suffix('_df2')
+
+    no_overlap = frame.loc[:, ['A', 'D']]
+    expected = df1_suf.join(df2_suf).join(no_overlap)
+
+    # column order not necessarily sorted
+    tm.assert_frame_equal(joined, expected.loc[:, joined.columns])
diff --git a/pandas/tests/frame/test_misc_api.py b/pandas/tests/frame/test_misc_api.py
index 321d46739..42427df90 100644
--- a/pandas/tests/frame/test_misc_api.py
+++ b/pandas/tests/frame/test_misc_api.py
@@ -57,92 +57,6 @@ class SharedWithSparse(object):
                 expected = self.frame[col][idx]
                 tm.assert_almost_equal(result, expected)
 
-    def test_join_index(self):
-        # left / right
-
-        f = self.frame.reindex(columns=['A', 'B'])[:10]
-        f2 = self.frame.reindex(columns=['C', 'D'])
-
-        joined = f.join(f2)
-        self.assert_index_equal(f.index, joined.index)
-        self.assertEqual(len(joined.columns), 4)
-
-        joined = f.join(f2, how='left')
-        self.assert_index_equal(joined.index, f.index)
-        self.assertEqual(len(joined.columns), 4)
-
-        joined = f.join(f2, how='right')
-        self.assert_index_equal(joined.index, f2.index)
-        self.assertEqual(len(joined.columns), 4)
-
-        # inner
-
-        f = self.frame.reindex(columns=['A', 'B'])[:10]
-        f2 = self.frame.reindex(columns=['C', 'D'])
-
-        joined = f.join(f2, how='inner')
-        self.assert_index_equal(joined.index, f.index.intersection(f2.index))
-        self.assertEqual(len(joined.columns), 4)
-
-        # outer
-
-        f = self.frame.reindex(columns=['A', 'B'])[:10]
-        f2 = self.frame.reindex(columns=['C', 'D'])
-
-        joined = f.join(f2, how='outer')
-        self.assertTrue(tm.equalContents(self.frame.index, joined.index))
-        self.assertEqual(len(joined.columns), 4)
-
-        assertRaisesRegexp(ValueError, 'join method', f.join, f2, how='foo')
-
-        # corner case - overlapping columns
-        for how in ('outer', 'left', 'inner'):
-            with assertRaisesRegexp(ValueError, 'columns overlap but '
-                                    'no suffix'):
-                self.frame.join(self.frame, how=how)
-
-    def test_join_index_more(self):
-        af = self.frame.loc[:, ['A', 'B']]
-        bf = self.frame.loc[::2, ['C', 'D']]
-
-        expected = af.copy()
-        expected['C'] = self.frame['C'][::2]
-        expected['D'] = self.frame['D'][::2]
-
-        result = af.join(bf)
-        assert_frame_equal(result, expected)
-
-        result = af.join(bf, how='right')
-        assert_frame_equal(result, expected[::2])
-
-        result = bf.join(af, how='right')
-        assert_frame_equal(result, expected.loc[:, result.columns])
-
-    def test_join_index_series(self):
-        df = self.frame.copy()
-        s = df.pop(self.frame.columns[-1])
-        joined = df.join(s)
-
-        # TODO should this check_names ?
-        assert_frame_equal(joined, self.frame, check_names=False)
-
-        s.name = None
-        assertRaisesRegexp(ValueError, 'must have a name', df.join, s)
-
-    def test_join_overlap(self):
-        df1 = self.frame.loc[:, ['A', 'B', 'C']]
-        df2 = self.frame.loc[:, ['B', 'C', 'D']]
-
-        joined = df1.join(df2, lsuffix='_df1', rsuffix='_df2')
-        df1_suf = df1.loc[:, ['B', 'C']].add_suffix('_df1')
-        df2_suf = df2.loc[:, ['B', 'C']].add_suffix('_df2')
-
-        no_overlap = self.frame.loc[:, ['A', 'D']]
-        expected = df1_suf.join(df2_suf).join(no_overlap)
-
-        # column order not necessarily sorted
-        assert_frame_equal(joined, expected.loc[:, joined.columns])
-
     def test_add_prefix_suffix(self):
         with_prefix = self.frame.add_prefix('foo#')
         expected = pd.Index(['foo#%s' % c for c in self.frame.columns])
diff --git a/pandas/tests/indexes/test_base.py b/pandas/tests/indexes/test_base.py
index c4dc10d81..a8197b070 100644
--- a/pandas/tests/indexes/test_base.py
+++ b/pandas/tests/indexes/test_base.py
@@ -626,14 +626,14 @@ class TestIndex(Base, tm.TestCase):
         # non monotonic
         idx1 = Index([5, 3, 2, 4, 1], name='idx')
         idx2 = Index([4, 7, 6, 5, 3], name='idx')
-        result2 = idx1.intersection(idx2)
-        self.assertTrue(tm.equalContents(result2, expected2))
-        self.assertEqual(result2.name, expected2.name)
+        expected = Index([5, 3, 4], name='idx')
+        result = idx1.intersection(idx2)
+        self.assert_index_equal(result, expected)
 
-        idx3 = Index([4, 7, 6, 5, 3], name='other')
-        result3 = idx1.intersection(idx3)
-        self.assertTrue(tm.equalContents(result3, expected3))
-        self.assertEqual(result3.name, expected3.name)
+        idx2 = Index([4, 7, 6, 5, 3], name='other')
+        expected = Index([5, 3, 4], name=None)
+        result = idx1.intersection(idx2)
+        self.assert_index_equal(result, expected)
 
         # non-monotonic non-unique
         idx1 = Index(['A', 'B', 'A', 'C'])
@@ -642,6 +642,11 @@ class TestIndex(Base, tm.TestCase):
         result = idx1.intersection(idx2)
         self.assert_index_equal(result, expected)
 
+        idx2 = Index(['B', 'D', 'A'])
+        expected = Index(['A', 'B', 'A'], dtype='object')
+        result = idx1.intersection(idx2)
+        self.assert_index_equal(result, expected)
+
         # preserve names
         first = self.strIndex[5:20]
         second = self.strIndex[:10]
diff --git a/pandas/tests/tools/test_merge.py b/pandas/tests/tools/test_merge.py
index ff2750035..8011bc4a1 100644
--- a/pandas/tests/tools/test_merge.py
+++ b/pandas/tests/tools/test_merge.py
@@ -1355,3 +1355,51 @@ class TestMergeCategorical(object):
                            np.dtype('int64')],
                           index=['X', 'Y', 'Z'])
         assert_series_equal(result, expected)
+
+
+@pytest.fixture
+def left_df():
+    return DataFrame({'a': [20, 10, 0]}, index=[2, 1, 0])
+
+
+@pytest.fixture
+def right_df():
+    return DataFrame({'b': [300, 100, 200]}, index=[3, 1, 2])
+
+
+class TestMergeOnIndexes(object):
+
+    @pytest.mark.parametrize(
+        "how, sort, expected",
+        [('inner', False, DataFrame({'a': [20, 10],
+                                     'b': [200, 100]},
+                                    index=[2, 1])),
+         ('inner', True, DataFrame({'a': [10, 20],
+                                    'b': [100, 200]},
+                                   index=[1, 2])),
+         ('left', False, DataFrame({'a': [20, 10, 0],
+                                    'b': [200, 100, np.nan]},
+                                   index=[2, 1, 0])),
+         ('left', True, DataFrame({'a': [0, 10, 20],
+                                   'b': [np.nan, 100, 200]},
+                                  index=[0, 1, 2])),
+         ('right', False, DataFrame({'a': [np.nan, 10, 20],
+                                     'b': [300, 100, 200]},
+                                    index=[3, 1, 2])),
+         ('right', True, DataFrame({'a': [10, 20, np.nan],
+                                    'b': [100, 200, 300]},
+                                   index=[1, 2, 3])),
+         ('outer', False, DataFrame({'a': [0, 10, 20, np.nan],
+                                     'b': [np.nan, 100, 200, 300]},
+                                    index=[0, 1, 2, 3])),
+         ('outer', True, DataFrame({'a': [0, 10, 20, np.nan],
+                                    'b': [np.nan, 100, 200, 300]},
+                                   index=[0, 1, 2, 3]))])
+    def test_merge_on_indexes(self, left_df, right_df, how, sort, expected):
+
+        result = pd.merge(left_df, right_df,
+                          left_index=True,
+                          right_index=True,
+                          how=how,
+                          sort=sort)
+        tm.assert_frame_equal(result, expected)
diff --git a/pandas/tools/merge.py b/pandas/tools/merge.py
index 60d523a8e..7de2549ca 100644
--- a/pandas/tools/merge.py
+++ b/pandas/tools/merge.py
@@ -733,7 +733,8 @@ class _MergeOperation(object):
 
         if self.left_index and self.right_index and self.how != 'asof':
             join_index, left_indexer, right_indexer = \
-                left_ax.join(right_ax, how=self.how, return_indexers=True)
+                left_ax.join(right_ax, how=self.how, return_indexers=True,
+                             sort=self.sort)
         elif self.right_index and self.how == 'left':
             join_index, left_indexer, right_indexer = \
                 _left_join_on_index(left_ax, right_ax, self.left_join_keys,
diff --git a/pandas/tseries/index.py b/pandas/tseries/index.py
index 1992e1775..9123131a6 100644
--- a/pandas/tseries/index.py
+++ b/pandas/tseries/index.py
@@ -1048,7 +1048,8 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
             this.offset = to_offset(this.inferred_freq)
         return this
 
-    def join(self, other, how='left', level=None, return_indexers=False):
+    def join(self, other, how='left', level=None, return_indexers=False,
+             sort=False):
         """
         See Index.join
         """
@@ -1062,7 +1063,7 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
 
         this, other = self._maybe_utc_convert(other)
         return Index.join(this, other, how=how, level=level,
-                          return_indexers=return_indexers)
+                          return_indexers=return_indexers, sort=sort)
 
     def _maybe_utc_convert(self, other):
         this = self
@@ -1214,9 +1215,10 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
               not other.offset.isAnchored() or
               (not self.is_monotonic or not other.is_monotonic)):
             result = Index.intersection(self, other)
-            if isinstance(result, DatetimeIndex):
-                if result.freq is None:
-                    result.offset = to_offset(result.inferred_freq)
+            result = self._shallow_copy(result._values, name=result.name,
+                                        tz=result.tz, freq=None)
+            if result.freq is None:
+                result.offset = to_offset(result.inferred_freq)
             return result
 
         if len(self) == 0:
@@ -1539,7 +1541,7 @@ class DatetimeIndex(DatelikeOps, TimelikeOps, DatetimeIndexOpsMixin,
     def _set_freq(self, value):
         self.offset = value
     freq = property(fget=_get_freq, fset=_set_freq,
-                    doc="get/set the frequncy of the Index")
+                    doc="get/set the frequency of the Index")
 
     year = _field_accessor('year', 'Y', "The year of the datetime")
     month = _field_accessor('month', 'M',

commit f8f0b05924a2112f2f90e80b2df48c64839f7d4f
Author: Wes McKinney <wesmckinn@gmail.com>
Date:   Tue Aug 9 15:31:07 2011 -0400

    TST: MultiIndex test coverage

diff --git a/pandas/core/index.py b/pandas/core/index.py
index 92cbc8641..39592a290 100644
--- a/pandas/core/index.py
+++ b/pandas/core/index.py
@@ -394,6 +394,16 @@ class MultiIndex(Index):
         except Exception:
             return False
 
+    def format(self, space=2):
+        stringified_levels = [lev.format().split('\n') for lev in self.levels]
+
+        result_levels = []
+        for lab, lev in zip(self.labels, stringified_levels):
+            taken = np.array(lev, dtype=object).take(lab)
+            result_levels.append(taken)
+
+        return adjoin(space, *result_levels)
+
     def is_all_dates(self):
         return False
 
@@ -421,6 +431,11 @@ class MultiIndex(Index):
 
         return MultiIndex(levels=levels, labels=labels, sortorder=sortorder)
 
+    @classmethod
+    def from_tuples(cls, tuples, sortorder=None):
+        arrays = zip(*tuples)
+        return MultiIndex.from_arrays(arrays, sortorder=sortorder)
+
     @property
     def indexMap(self):
         if not hasattr(self, '_cache_indexMap'):
@@ -462,6 +477,10 @@ class MultiIndex(Index):
         else:
             if _is_bool_indexer(key):
                 key = np.asarray(key)
+                sortorder = self.sortorder
+            else:
+                # cannot be sure whether the result will be sorted
+                sortorder = None
 
             new_tuples = arr_idx[key]
             new_labels = [lab[key] for lab in self.labels]
@@ -470,44 +489,31 @@ class MultiIndex(Index):
             result = new_tuples.view(MultiIndex)
             result.levels = self.levels
             result.labels = new_labels
+            result.sortorder = sortorder
+
             return result
 
     def __getslice__(self, i, j):
         return self.__getitem__(slice(i, j))
 
-    def format(self, space=2):
-        stringified_levels = [lev.format().split('\n') for lev in self.levels]
-
-        result_levels = []
-        for lab, lev in zip(self.labels, stringified_levels):
-            taken = np.array(lev, dtype=object).take(lab)
-            result_levels.append(taken)
+    def sortlevel(self, level=0, ascending=True):
+        """
 
-        return adjoin(space, *result_levels)
+        """
+        labels = list(self.labels)
+        primary = labels.pop(level)
 
-    def get_loc(self, key):
-        if isinstance(key, tuple):
-            return self._get_tuple_loc(key)
-        else:
-            assert(self.sortorder == 0)
-            # slice level 0
-            level = self.levels[0]
-            labels = self.labels[0]
+        # Lexsort starts from END
+        indexer = np.lexsort(tuple(labels[::-1]) + (primary,))
 
-            loc = level.get_loc(key)
-            i = labels.searchsorted(loc, side='left')
-            j = labels.searchsorted(loc, side='right')
-            return slice(i, j)
+        if not ascending:
+            indexer = indexer[::-1]
 
-    def _get_tuple_loc(self, tup):
-        indexer = self._get_label_key(tup)
-        try:
-            return self.indexMap[indexer]
-        except KeyError:
-            raise KeyError(str(tup))
+        new_labels = [lab.take(indexer) for lab in self.labels]
+        new_index = MultiIndex(levels=self.levels, labels=new_labels,
+                               sortorder=level)
 
-    def _get_label_key(self, tup):
-        return tuple(lev.get_loc(v) for lev, v in zip(self.levels, tup))
+        return new_index, indexer
 
     def get_indexer(self, target, method=None):
         """
@@ -606,6 +612,30 @@ class MultiIndex(Index):
             result.append(label)
         return tuple(result)
 
+    def get_loc(self, key):
+        if isinstance(key, tuple):
+            return self._get_tuple_loc(key)
+        else:
+            assert(self.sortorder == 0)
+            # slice level 0
+            level = self.levels[0]
+            labels = self.labels[0]
+
+            loc = level.get_loc(key)
+            i = labels.searchsorted(loc, side='left')
+            j = labels.searchsorted(loc, side='right')
+            return slice(i, j)
+
+    def _get_tuple_loc(self, tup):
+        indexer = self._get_label_key(tup)
+        try:
+            return self.indexMap[indexer]
+        except KeyError:
+            raise KeyError(str(tup))
+
+    def _get_label_key(self, tup):
+        return tuple(lev.get_loc(v) for lev, v in zip(self.levels, tup))
+
     def truncate(self, before=None, after=None):
         """
         Slice index between two major axis values, return new MultiIndex
@@ -646,6 +676,9 @@ class MultiIndex(Index):
         if self.nlevels != other.nlevels:
             return False
 
+        if len(self) != len(other):
+            return False
+
         # if not self.equal_levels(other):
         #     return False
 
@@ -686,7 +719,7 @@ class MultiIndex(Index):
         self_tuples = self.get_tuple_index()
         other_tuples = other.get_tuple_index()
         uniq_tuples = np.unique(np.concatenate((self_tuples, other_tuples)))
-        return MultiIndex.from_arrays(*zip(*uniq_tuples))
+        return MultiIndex.from_arrays(zip(*uniq_tuples), sortorder=0)
 
     def intersection(self, other):
         """
@@ -709,16 +742,15 @@ class MultiIndex(Index):
         self_tuples = self.get_tuple_index()
         other_tuples = other.get_tuple_index()
         uniq_tuples = sorted(set(self_tuples) & set(other_tuples))
-        return MultiIndex.from_arrays(*zip(*uniq_tuples))
+        return MultiIndex.from_arrays(zip(*uniq_tuples), sortorder=0)
 
     def _assert_can_do_setop(self, other):
-        if not hasattr(other, '__iter__'):
-            raise Exception('Input must be iterable!')
-
         if not isinstance(other, MultiIndex):
             raise TypeError('can only call with other hierarchical '
                             'index objects')
 
+        assert(self.nlevels == other.nlevels)
+
     def get_major_bounds(self, begin=None, end=None):
         """
         Return index bounds for slicing LongPanel labels and / or
@@ -786,25 +818,6 @@ class MultiIndex(Index):
 
         return self.__bounds
 
-    def sortlevel(self, level=0, ascending=True):
-        """
-
-        """
-        labels = list(self.labels)
-        primary = labels.pop(level)
-
-        # Lexsort starts from END
-        indexer = np.lexsort(tuple(labels[::-1]) + (primary,))
-
-        if not ascending:
-            indexer = indexer[::-1]
-
-        new_labels = [lab.take(indexer) for lab in self.labels]
-        new_index = MultiIndex(levels=self.levels, labels=new_labels,
-                               sortorder=level)
-
-        return new_index, indexer
-
 # For utility purposes
 
 NULL_INDEX = Index([])
diff --git a/pandas/tests/test_frame.py b/pandas/tests/test_frame.py
index 2cde6221c..5b50bde5e 100644
--- a/pandas/tests/test_frame.py
+++ b/pandas/tests/test_frame.py
@@ -745,8 +745,7 @@ class TestDataFrame(unittest.TestCase, CheckIndexing):
         df = DataFrame(d)
         self.assert_(isinstance(df['Col1']['Row2'], float))
 
-        dm = DataFrame([[1,2],['a','b']],
-                       index=[1,2], columns=[1,2])
+        dm = DataFrame([[1,2],['a','b']], index=[1,2], columns=[1,2])
         self.assert_(isinstance(dm[1][1], int))
 
     def test_constructor_ndarray(self):
diff --git a/pandas/tests/test_index.py b/pandas/tests/test_index.py
index e13061f8b..1a2087ac8 100644
--- a/pandas/tests/test_index.py
+++ b/pandas/tests/test_index.py
@@ -368,7 +368,21 @@ class TestMultiIndex(unittest.TestCase):
         self.assertEquals(result, (2, 4))
 
     def test_slice_locs_not_contained(self):
-        pass
+        # some searchsorted action
+
+        index = MultiIndex(levels=[[0, 2, 4, 6], [0, 2, 4]],
+                           labels=[[0, 0, 0, 1, 1, 2, 3, 3, 3],
+                                   [0, 1, 2, 1, 2, 2, 0, 1, 2]],
+                           sortorder=0)
+
+        result = index.slice_locs((1, 0), (5, 2))
+        self.assertEquals(result, (3, 7))
+
+        result = index.slice_locs((2, 2), (5, 2))
+        self.assertEquals(result, (4, 7))
+
+        result = index.slice_locs((1, 0), (6, 3))
+        self.assertEquals(result, (3, 8))
 
     def test_consistency(self):
         # need to construct an overflow
@@ -472,6 +486,79 @@ class TestMultiIndex(unittest.TestCase):
                              True, True], dtype=bool)
         self.assert_(np.array_equal(mask, expected))
 
+    def test_equals(self):
+        self.assert_(self.index.equals(self.index))
+        self.assert_(self.index.equal_levels(self.index))
+
+        self.assert_(not self.index.equals(self.index[:-1]))
+        self.assert_(not self.index.equals(self.index.get_tuple_index()))
+
+        # different number of levels
+        index = MultiIndex(levels=self.index.levels[:-1],
+                           labels=self.index.labels[:-1])
+        self.assert_(not self.index.equals(index))
+        self.assert_(not self.index.equal_levels(index))
+
+        # levels are different
+        major_axis = Index(range(4))
+        minor_axis = Index(range(2))
+
+        major_labels = np.array([0, 0, 1, 2, 2, 3])
+        minor_labels = np.array([0, 1, 0, 0, 1, 0])
+
+        index = MultiIndex(levels=[major_axis, minor_axis],
+                           labels=[major_labels, minor_labels])
+        self.assert_(not self.index.equals(index))
+        self.assert_(not self.index.equal_levels(index))
+
+        # some of the labels are different
+        major_axis = Index(['foo', 'bar', 'baz', 'qux'])
+        minor_axis = Index(['one', 'two'])
+
+        major_labels = np.array([0, 0, 2, 2, 3, 3])
+        minor_labels = np.array([0, 1, 0, 1, 0, 1])
+
+        index = MultiIndex(levels=[major_axis, minor_axis],
+                           labels=[major_labels, minor_labels])
+        self.assert_(not self.index.equals(index))
+
+    def test_union(self):
+        piece1 = self.index[:5][::-1]
+        piece2 = self.index[3:]
+
+        the_union = piece1.union(piece2)
+
+        tups = sorted(self.index.get_tuple_index())
+        expected = MultiIndex.from_tuples(tups)
+
+        self.assert_(the_union.equals(expected))
+
+        # corner case, pass self or empty thing:
+        the_union = self.index.union(self.index)
+        self.assert_(the_union is self.index)
+
+        the_union = self.index.union(self.index[:0])
+        self.assert_(the_union is self.index)
+
+        self.assertRaises(TypeError, self.index.union,
+                          self.index.get_tuple_index())
+
+    def test_intersection(self):
+        piece1 = self.index[:5][::-1]
+        piece2 = self.index[3:]
+
+        the_int = piece1.intersection(piece2)
+        tups = sorted(self.index[3:5].get_tuple_index())
+        expected = MultiIndex.from_tuples(tups)
+        self.assert_(the_int.equals(expected))
+
+        # corner case, pass self
+        the_int = self.index.intersection(self.index)
+        self.assert_(the_int is self.index)
+
+        self.assertRaises(TypeError, self.index.intersection,
+                          self.index.get_tuple_index())
+
     def test_dims(self):
         pass
 
